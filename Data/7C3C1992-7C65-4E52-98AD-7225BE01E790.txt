 I
中英文摘要 
本子計畫主要目的是建構一套適用於農業之無線感測網路系統。本系統將無線感測器
佈建於室內農場和戶外田野中，使得農作物之生長環境資訊可以有效被監測和掌握。在系
統實作和理論研究方面，本子計畫有兩個主要的議題：(1)無線感測網路的佈建; (2)行動感
測車的開發與派遣。在三年中，我們分別針對此兩大議題，有系統的研究與設計。 
在無線感測網路的佈建的議題方面，第一年，我們針對任意佈建的無線感測網路設計
分散式省電通訊協定，來確保無線感測網路的覆蓋性與連結性。第二年，我們主要致力於
如何有效運用最少量的感測器佈建於農場中，達到確保網路覆蓋性和連結性，使得感測器
佈建成本有效降低。第三年，我們研究如何運用移動式感測器，自動化的佈建感測網路，
達到彈性擴充網路功能的目的。 
在行動感測車的開發與派遣的議題方面，第一年，我們針對移動式感測器之軟硬體設
計，開發一套移動式感測器平台移動式感測器派遣演算法，用以取得農場進一步之影像資
料。第二年，我們致力於設計負載平衡之移動式感測器派遣方案，達到可以快速反應並回
報網路上同時存在的多個事件。第三年，我們利用移動式感測器進行資料收集的工作，並
研究移動式感測器之行動管理方案，開發一套移動式感測器資料收集平台和其路徑規劃方
案。 
 
關鍵字：感測網路、網路覆蓋、網路連結、省電通訊協定、移動式感測器、資料收集。 
 
The goal of this subproject is to build a wireless sensor application system to suit 
agricultural needs. In this application system, we deploy sensors in a greenhouse or a farm to 
monitor environmental information during plants growing. In this subproject, for both practical 
and theoretical aspects, there are two primary issues, (1) sensor deployment, and (2) design and 
dispatch of mobile sensors. During the pass three years, we focus on the two primary issues to 
design our agricultural application platforms systematically. 
 For the issue of sensor deployment, in the first year, we focus on designing distributed and 
power-saving protocols to guarantee coverage and connectivity for random deployment of 
sensors. In the second year, we focus on how to use the least number of sensors to achieve both 
coverage and connectivity such that the deploying cost is reduced. In the third year, we study how 
to use mobile sensors to deploy a WSN automatically such that the functionality of the WSN can 
be more flexible. 
 For the issue of design and dispatch of mobile sensors, in the first year, we focus on 
designing the hardware and software of mobile sensors platforms, and then design a dispatch 
algorithm of mobile sensors to capture the images from anywhere in a farm. In the second year, 
we focus on designing load-balancing dispatch algorithms of mobile sensors to react multiple 
events quickly. In the third year, we use mobile sensors to collect data from sensors in a farm, and 
study the mobility management of mobile sensors. In addition, we also design a data collection 
mobile platform to gather data form sensors. 
 
Keywords: wireless sensor network, coverage, connectivity, power-saving protocol, mobile 
sensor, data collection
 II
Computing (WCMC), (to appear) 
 2
主要致力於如何有效運用最少量的感測器佈建於農場中，達到確保網路覆蓋性和連結性，
使得感測器佈建成本有效降低。第三年，我們研究如何運用移動式感測器，自動化的佈建
感測網路，達到彈性擴充網路功能的目的。在行動感測車的開發與派遣的議題方面，第一
年，我們針對移動式感測器之軟硬體設計，開發一套移動式感測器平台移動式感測器派遣
演算法，用以取得農場進一步之影像資料。第二年，我們致力於設計負載平衡之移動式感
測器派遣方案，達到可以快速反應並回報網路上同時存在的多個事件。第三年，我們利用
移動式感測器進行資料收集的工作，並研究移動式感測器之行動管理方案，開發一套移動
式感測器資料收集平台和其路徑規劃方案。 
二、研究目的 
網路佈建議題主要探討如何佈建一個可以成功運作的無線感測網路。無線感測器網路
要能成功的運作，要能同時確保無線感測網路之覆蓋性(coverage)和連結性 (connectivity)，
無線感測器網路的覆蓋問題，主要目標要達到整個感測區域(例如溫室或是農場)能夠被佈建
的無線感測器覆蓋，才能達到完整監督環境之目的。無線感測器網路的連結性問題，主要
目標要達到無線感測器之間能夠有足夠多的通訊路徑，以確保網路的通訊上的穩健性，才
能達到偵測的環境資訊可以成功的回報之目的。因此，本子計畫第一年度針對網路佈建議
題，對任意灑置的感測器網路，開發分散式的省電通訊協定來達到同時確保網路覆蓋性
(coverage)和網路連結性 (connectivity)。此外，我們亦設計感測器活動週期和睡眠週期排程
之策略，達到省電和進而延長網路的生命週期之目的。本子計畫第二年度針對網路佈建議
題，針對有障礙物存在的環境中，我們主要研究目的是探討如何運用最少量的感測器佈建
於各種不規則形狀的農場中，來達到監測農場所需的網路覆蓋性和網路連結性，提高感測
器的利用率、降低佈建成本。本子計畫第三年度針對網路佈建議題，主要的研究目的是利
用移動式感測器自動化佈建網路，達到彈性調整網路拓撲，以及快速反應事件之能力。 
行動感測車的開發與派遣的議題，最主要目的是要實現移動式感測器的概念，達到即
時的且動態的監控溫室或農場中的狀況。因此，本子計畫第一年度針對行動感測車的開發
與派遣的議題，主要研究目的是研發一套行動感測車系統，其兼具大範圍的動態資料收集、
取得溫室/農場內即時影像的能力。此外，為了讓此行動感測車系統能夠有效派遣和運用，
我們規劃設計其被派遣的策略，來提高行動感測車的派遣效率。本子計畫第二年度針對行
動感測車的開發與派遣的議題，主要研究目的是考慮的是當有多個事件發生並需要派遣多
個移動式感測器去獲取進一步影像資訊時，如何在負載平衡得考量下有效的派遣移動式感
測器。本子計畫第三年度針對行動感測車的開發與派遣的議題，探討利用移動式感測器進
行資料收集的工作時，移動式感測器資料收集平台之軟硬體開發和其路徑規劃方案，達到
延長網路存活時間之目的。 
三、文獻探討 
下面我們針對本計劃中的兩個主要的目標：(1) 無線感測網路的佈建; (2)行動感測車的
開發與派遣，整理了相關文獻。無線感測網路的佈建佈建方面，許多文現在探討網路覆蓋
 4
散式省電通訊協定，達到網路覆蓋和網路連結性，主要分為下述三步驟： 
Step1：感測器利用週期性的發BEACON訊息來收集評估鄰近區域網路覆蓋和網路連結的程
度。 
Step2：我們設計兩套通訊協定：包含睡眠通訊協定(sleep protocol)，電量控制通訊協定(power 
control protocol)。若感測器網路已經達到滿足需求的 coverage 和 connectivity。我們可以利
用睡眠通訊協定(sleep protocol)和電量控制通訊協定(power control protocol) 調降網路的
coverage 和 connectivity。 
Step3：我們設置兩個timer：Tsleep和Tcycle。Tsleep主針對進入睡眠模式的感測器，用Tsleep
來週期性的喚醒自己。Tcycle：重新檢查區域性的網路覆蓋和連結程度，目的是避免當鄰居
的感測器耗盡電源時，網路的覆蓋和連結程度會低於需求的網路覆蓋和網路連結。此外，
必須增設一個HELP訊息，目的是當網路上有些感測器耗盡電源時，可以透過HELP訊息來
提高網路的覆蓋和連結程度。詳細研究方法細節在附錄ㄧ中說明。 
此外，我們針對任意佈建的無線感測網路，提出感測器的活動週期(active period)和睡
眠週期(sleep period)的排程演算法，進一步達到省電的目的。其方法步驟如下述︰ 
對於任兩個感測器的感測範圍的交叉點，有一個工作周期(working cycle)的時間排程。圖二
為感測器的工作周期(working cycle)結構圖，主要包含兩個階段(phase)：初始化階段
(initialization phase)和感測階段(sensing phase)。在初始化階段(initialization phase)，每一個感
測器必須醒來(wake up)廣播 HELLO 封包，此封包含ㄧ個隨機過程產生的值 Refi。在感測階
段(sensing phase)被切割成 r 個 round，每個 round 有相等長度的時間 Trnd。在此通訊協定中， 
 
 
圖二、感測器的工作周期(working cycle)結構圖。 
 
我們選擇兩個參數 Fornti 和 Backi 來控制每個感測器的活動週期(active period)和睡眠週期
(sleep period)。對感測器 si 而言，在時間區段[(Refi-Fornti)mod Trnd]到[(Refi+Backi)mod Trnd]
的時間內，他必須保持活動(active)，在此 round 的其他時間他才可以進入睡眠狀態。感測
器 si 感測範圍內的交叉點排程的時間聯集，即為感測器 si 必須保持活動(active)的時間週期。
例如圖三(a)有五個感測器包含交叉點 p、q、r、m、n。圖三(b)為感測器 s1、s2、s3 交叉點
p 的時間排程。圖三(c)感測器 s1 活動週期(active)為聯集交叉點 p、q、r、m、n 的排程時間。
詳細研究方法細節在附錄二中說明。 
 
 6
障礙物
(a) 切割single-row/multi-row區域
(b) single-row區域佈建感測器
3c sr r<
(c) multi-row region佈建感測器
D
二等分
線min
r
B
A
障礙物
被切割
的區域
expanded line
C
E
3 minr
3 minr
3 minr
3 minr
1
2 3
4
5
case
rc rs
rc
22
4
cr
s sr r+ −
3c sr r≥ case
rs3
rc
rs
 
圖四：低成本網路佈建策略之實例。 
 
C. 透過移動式感測器自動佈建策略： 
在第三年，網路佈建的目標是如何利用移動式感測器佈建網路佈成一個具連結性的骨
幹網路，且每個移動式感測器均衡負責ㄧ樣多的下層靜態感測器。如圖五(a)為佈建前之網
路狀況，圖五(b)為佈建後，較均衡的網路狀態。其主要佈建概念如下步驟遞迴的執行︰ 
Step1︰現有已經連結到sink的移動式感測器來劃分負責的區域範圍。 
Step2︰每個已經連結到sink的移動式感測器在自己負責區域內，將下層靜態感測器形成一
樹狀結構。 
Step3︰每個已經連結到sink的移動式感測器，沿著自己負責區域內樹狀結構網大的子樹持
續移動至適當位置。 
詳細研究方法細節在附錄四中說明。 
 8
),( ji lsd 為行動感測車 is 由目前位置移動到事件發生地點 jl 需要移動的距離。經由轉換之
後，我們利用最大權重配對的問題的解答來找出此問題的解。同樣的。我們亦可以透過更
改權重設定方式為 ),( jimv lsde ×− ，用類似方式求目標為最小總移動距離得解答。 
 
圖六：行動感測車之系統架構 
 
z 當m>n時：有些行動感測車必須拜訪多個緊急事件位置： 
為了解決此問題，我們將緊急事件位置利用K-means分群法分成n個群組(cluster)，並分配每
個群組派遣ㄧ台行動感測車。 
詳細研究方法細節在附錄五中說明。 
 
B. 負載平衡之移動式感測器派遣演算法： 
在第二年，行動感測車的開發與派遣的目標是處理多個事件存在於農場中，如何在負
載平衡得考量下有效的派遣移動式感測器。當農場中有幾處特定區域或事件需要派遣動態
傳回進ㄧ步影像資料時，派遣移動式感測器之策略將考慮在每ㄧ個動態移動式感測器負載
平衡。我們提出一個分散式的作法如圖七所示，感測區域被切割成格子狀，每個格子內有
一個grid head負責收集該格子內的移動式感測器(mobile sensor)資訊(包含其位置和剩餘電
量資訊)，和所有需要移動式感測器監測的事件位置(event location)。當grid head收到靜態感
測器回報的事件之後，會派遣其格子內或附近格子內的移動式感測器去取得進ㄧ步的影像
資料。 
 10
線感測器作為移動式無線感測器，將監測資料由各區域性的資料中心收集到後端。關於此
移動式感測器行動管理方案之詳細說明於附錄七中。 
 
圖八、無線感測網路之農業應用系統實作，(a) 網路佈建方式 (b) 無線連結圖與資料讀數。 
五、結果與討論 
無線感測網路應用於農業上，不但可以幫助農民種植作物上更為方便，且低佈建成本
也可進一步地促進無線感測網路的普及。本子計畫在三年中，主要致力於開發無線感測網
路農業應用系統，針對無線感測網路的佈建的議題方面，和行動感測車的開發與派遣的議
題方面均有深入的研究探討與成果。 
z 本計畫三年內的研究成果： 
第一年，在無線感測網路的佈建的議題方面，我們針對任意佈建的無線感測網路設計
分散式省電通訊協定，來確保無線感測網路的覆蓋性與連結性。在行動感測車的開發與派
遣的議題方面，我們針對移動式感測器之軟硬體設計，開發一套移動式感測器平台和移動
式感測器派遣演算法，用以取得農場進一步之影像資料。 
第二年，在無線感測網路的佈建的議題方面，我們主要致力於如何有效運用最少量的
感測器佈建於農場中，達到確保網路覆蓋性和連結性，使得感測器佈建成本有效降低。行
動感測車的開發與派遣的議題方面，我們致力於設計負載平衡之移動式感測器派遣方案，
達到可以快速反應並回報網路上同時存在的多個事件。 
第三年，在無線感測網路的佈建的議題方面，我們研究如何運用移動式感測器，自動
化的佈建感測網路，達到彈性擴充網路功能，快速反應網路事件的目的。在行動感測車的
開發與派遣的議題方面，我們利用移動式感測器進行資料收集的工作，並研究移動式感測
器之行動管理方案，開發一套移動式感測器資料收集平台和其路徑規劃方案。 
z 本計畫三年內的研究成果為 7 篇論文如下： 
¾ 附錄一：C.-F. Huang, Y.-C. Tseng, and H.-L. Wu, “Distributed Protocols for Ensuring 
Both Coverage and Connectivity of a Wireless Sensor Network”, ACM Trans. on 
Sensor Networks Vol. 3, No. 1, March 2007. 
¾ 附錄二：C.-F. Huang, L.-C. Lo, Y.-C. Tseng, and W.-T. Chen “Decentralized 
Energy-Conserving and Coverage-Preserving Protocols for Wireless Sensor Networks”, 
 12
[3] S. Meguerdichian, F. Koushanfar, G. Qu, and M. Potkonjak, "Exposure in wireless ad-hoc 
sensor networks", in ACM Int'l Conf. on Mobile Computing and Networking (MobiCom), 
2001, pp. 139-150. 
[4] G. Veltri, Q. Huang, G. Qu, and M. Potkonjak, "Minimal and maximal exposure path 
algorithms for wireless embedded sensor networks", in ACMInt'l Conf. on Embedded 
Networked Sensor Systems (SenSys), 2003, pp. 40-50. 
[5] C.-F. Huang, and Y.-C. Tseng, "The coverage problem in a wireless sensor network", in 
ACM Int'l Workshop on Wireless Sensor Networks and Applications (WSNA), 2003, pp. 
115-121. 
[6] C.-F. Huang, Y.-C. Tseng, and L.-C. Lo, "The coverage problem in three-dimensional 
wireless sensor networks", in IEEE Global Telecommunications Conference (Globecom), 
2004. 
[7] Y. Xu, J. Heidemann, and D. Estrin, "Geography-informed energy conservation for ad hoc 
routing", in ACM Int'l Conf. on Mobile Computing and Networking (MobiCom), 2001, pp. 
70-84. 
[8] B. Chen, K. Jamieson, H. Balakrishnan, and R. Morris, "Span: an energy-efficient 
coordination algorithm for topology maintenance in ad hoc wireless networks", ACM 
Wireless Networks 8, 5 (Sep.), 2002, pp. 481- 494. 
[9] M. Burkhart, P. V. Rickenbach, R. Wattenhofer, and A. Zollinger, "Does topology control 
reduce interference?", in ACM Int'l Symp. on Mobile Ad Hoc Networking and Computing 
(MobiHOC), 2004, pp. 9 - 19. 
[10] N. Li, and J. C. Hou, "FLSS: A fault-tolerant topology control algorithm for wireless 
networks", in ACM Int'l Conf. on Mobile Computing and Networking (MobiCom), 2004. 
[11] R. Wattenhofer, L. Li, P. Bahl, and Y.-M. Wang, "Distributed topology control for power 
efficient operation in multihop wireless ad hoc networks" in IEEE INFOCOM, 2001. pp. 
1388 - 1397. 
[12] K. Chakrabarty, S. S. Iyengar, H. Qi, and E. Cho, “Grid coverage for surveillance and target 
location in distributed sensor networks,” IEEE Transactions on Computers, vol. 51, no. 12, 
pp. 1448–1453, 2002. 
[13] S. S. Dhillon and K. Chakrabarty, “Sensor placement for effective coverage and surveillance 
in distributed sensor networks,” in IEEE Wireless Communications and Networking, 2003, 
pp. 1609–1614. 
[14] F. Y. S. Lin and P. L. Chiu, “A near-optimal sensor placement algorithm to achieve 
complete coverage/discrimination in sensor networks,” IEEE Communications Letters, vol. 
9, no. 1, pp. 43–45, 2005. 
[15] K. Kar and S. Banerjee, “Node placement for connected coverage in sensor networks,” in 
International Symposium on Modeling and Optimization in Mobile, Ad Hoc and Wireless 
Networks, 2003. 
[16] A. Cerpa and D. Estrin, “ASCENT: adaptive self-configuring sensornetworks topologies,” in 
IEEE INFOCOM, 2002, pp. 1278–1287. 
[17] D. Tian and N. D. Georganas, “A coverage-preserving node scheduling scheme for large 
附錄一： 
 
Distributed Protocols for Ensuring 
Both Coverage and Connectivity of 
a Wireless Sensor Network 
 
 
 
 
 
 
C.-F. Huang, Y.-C. Tseng, and H.-L. Wu 
 
ACM Trans. On Sensor Networks Vol. 3, No. 1, March 2007. 
2 · C.-F. Huang et al.
Sohrabi et al. 2000]. The flexibility of installing and configuring a sensor network is thus
greatly improved. Recently, a lot of research activities have been dedicated to sensor net-
works, including design of physical and medium access layers [Shih et al. 2001; Woo and
Culler 2001; Ye et al. 2002] and routing and transport protocols [Braginsky and Estrin
2002; Ganesan et al. 2001; Heinzelman et al. 2000]. Localization and positioning applica-
tions of wireless sensor networks are discussed in [Bahl and Padmanabhan 2000; Savvides
et al. 2001; Tseng et al. 2003].
Since sensors may be spread in an arbitrary manner, a fundamental issue in a wireless
sensor network is to ensure coverage and connectivity. Given a sensor network, the cov-
erage issue is concerned with how well the sensing field is monitored by sensors. In the
literature, this problem has been formulated in various ways. Coverage can be regarded as
a metric to evaluate the quality of service (surveillance) provided by the network. Between
a given pair of points in the sensing field, some works focus on finding a path connecting
these two points which is best or worst monitored by sensors when an object traverses
along the path [Li et al. 2003; Meguerdichian et al. 2001; Meguerdichian et al. 2001; Vel-
tri et al. 2003]. In [Huang and Tseng 2003; Huang et al. 2004], the coverage problem is
formulated as one of determining if a 2D/3D sensing field area is sufficiently k-covered,
i.e., each point in the field is within the sensing ranges of at least k sensors. The proposed
approach looks at how the perimeter of each sensor’s sensing range is covered, thus leading
to efficient polynomial-time algorithms. On the other hand, some works are targeted at par-
ticular applications (such as energy conservation [Abrams et al. 2004; Tian and Georganas
2003; Yan et al. 2003]), but the central idea is still related to the coverage issue.
The connectivity issue is concerned with the diversity of communication paths between
sensors. This would affect network robustness and communication performance. The GAF
protocol [Xu et al. 2001] aims to extend the network lifetime by turning off redundant
nodes while keeping the same level of routing fidelity, which is defined as uninterrupted
connectivity between communicating nodes. GAF imposes a virtual grid on the network
and nodes in the same grid coordinate with each other to determine who can sleep and how
long. Reference [Chen et al. 2002] presents a connectivity-maintaining protocol, SPAN,
which can turn off unnecessary nodes such that all active nodes are connected through a
communication backbone and all inactive nodes are directly connected to at least one active
node. Maintaining a network connected is also a basic requirement of works targeted at
topology control, which is to adjust sensors’ transmission power for energy efficiency and
collision avoidance [Burkhart et al. 2004; Li and Hou 2004; Wattenhofer et al. 2001].
In this work, we study the relationship between sensing coverage and communication
connectivity of a sensor network. Reference [Wang et al. 2003] proposes a coverage deter-
mination algorithm by looking at how intersection points between sensors’ sensing ranges
are covered by their neighbors, and claims that coverage can imply connectivity as long as
sensors’ communication ranges are no less than twice their sensing ranges. A Coverage
Configuration Protocol (CCP) that can provide different degrees of coverage and mean-
while maintain communication connectivity is presented. If the communication ranges are
less than twice the sensing ranges, [Wang et al. 2003] proposes to integrate CCP with SPAN
[Chen et al. 2002] to provide both sensing coverage and communication connectivity. A
similar result is also drawn in [Zhang and Hou 2004a], and thus only the coverage prob-
lem is addressed. A decentralized density control algorithm called Optimal Geographical
Density Control (OGDC) is then proposed to reduce the number of working nodes to cover
ACM Journal Name, Vol. V, No. N, M 20YY.
4 · C.-F. Huang et al.
 j1,L
 j3,L
 j2,L
 j4,L
 j6,L
 j5,L
 j7,L
 j8,L
 j1,R
 j3,R
 j2,R
 j4,R
 j6,R
 j5,R
 j7,R
 j8,R




 j8,L
 j8,R
si
 j3,L
 j4,L
 j7,L
 j6,L
 j5,L
 j3,R
 j4,R
 j7,R
 j6,R
 j5,R
 j1,R
 j1,L
 j2,R
 j2,L
(b)(a)
Fig. 1. Determining the perimeter coverage of a sensor s i.
distance of ri and a communication distance of ci. So, si can detect an object/event located
within a distance of ri from itself and talk to another sensor within a distance of c i. Note
that we make no assumption about the relationship of r i and ci. Only bidirectional links are
considered. So when two sensors can hear each other, we say that there is a communication
link, or simply a link, between them.
Definition 1. A point in A is said to be covered by s i if it is within si’s sensing range.
Given an integer k, a point in A is said to be k-covered if it is covered by at least k distinct
sensors. The sensor network is said to be k-covered if every point in A is k-covered.
Definition 2. The sensor network is said to be 1-connected if there is at least one path
between any two sensors. The sensor network is said to be k-connected if there are at least
k disjointed paths between any two sensors.
The deployment of sensors is not concerned in our work and we assume the network is
1-covered at least. We formulate the general form of coverage and connectivity problem
as follows.
Definition 3. Given any two integers ks and kc, the ks-Covered and kc-Connected
Problem, or the (ks, kc)-CC problem, is a decision problem whose goal is to determine
whether the sensor network is ks-covered and kc-connected.
As far as we know, the general (ks, kc)-CC problem has not been well addressed yet.
In [Huang and Tseng 2003], the coverage problem has been solved in an efficient way.
Below, we briefly review the result, which will be used as a basis in our derivation. Given
any sensor, reference [Huang and Tseng 2003] tries to look at the perimeter that bounds the
sensor’s sensing range (for convenience, this may be simply referred to as “the perimeter of
the sensor”). The algorithm essentially determines the coverage level of the sensing field
A by determining the perimeter of each sensor.
Definition 4. Consider any two sensors si and sj . A point p on the perimeter of si is
perimeter-covered by sj if this point is within the sensing range of sj , i.e., the distance
between p and sj is less than rj . A point p on the perimeter of si is k-perimeter-covered if
ACM Journal Name, Vol. V, No. N, M 20YY.
6 · C.-F. Huang et al.
si
sj
sx
sy
sz
p
q
r
(a) (b)
si sj
sx
p q
rx
si sj
sx
p
q
rx
si sj
sx
p rx
Fig. 2. Proof of Lemma 1: (a) the path construction, and (b) possible cases of s x.
LEMMA 1. Consider any two sensors si and sj . If each sensor in S is 1-MPC, there
must exist a communication path between si and sj .
PROOF. This proof is by construction. If si’s sensing region intersects with sj , by Def-
inition 6, there must exist a path between si and sj , which proves this lemma. Otherwise,
draw a line segment L connecting si and sj , as illustrated in Fig. 2(a). Let L intersect si’s
perimeter at point p. Since si is 1-MPC, by Definition 6, there must exist a sensor sx in
N(i) which covers p and has a path to si. In addition, either sx must cover sj , or sx’s
perimeter must intersect L at a point, namely q, which is closer to s j than p is. Fig. 2(b)
shows several possible combinations of sx and rx. In the former case, by Definition 6,
there must exist a path between sx and sj , and thus si and sj , which proves this lemma. In
the latter case, there must exist another sensor sy in N(x) which covers q. We can repeat
the above argument until a sensor sz is found which either covers sj or intersects L at a
point, say r, inside sj’s sensing range. Note that since the number of sensors is finite, the
construction must eventually terminate and the path from s i must reach sj . Otherwise, the
intersection point of sj’s perimeter and L is not covered by any sensor. As a result, there
must exist a path between sz and sj , which proves this lemma.
THEOREM 2. A sensor network is k-covered and 1-connected iff each sensor is k-MPC.
PROOF. For the “if” part, we have to guarantee both the coverage and connectivity. The
fact that the network is k-covered has been proved by Theorem 1 because each sensor
which is k-MPC is also k-perimeter-covered. In addition, Lemma 1 can guarantee that the
network is 1-connected, hence proving the “if” part.
For the “only if” part, we have to show that each sensor is k-perimeter-covered and has
a path to each sensor whose sensing region intersects with its region. The first concern can
be ensured by Theorem 1, while the second concern can be ensured by the fact that the
network is 1-connected.
ACM Journal Name, Vol. V, No. N, M 20YY.
8 · C.-F. Huang et al.
a
r ca a=
c
cc=2rc
rc
b
rb
cb=1.5rb
Fig. 4. An example to compare Theorem 3 with results in literature. Solid circles and dotted circles are sensors’
sensing ranges and communications ranges, respectively.
si
sx
Fig. 5. An example that k-LDPC is looser than k-DPC.
3.2 Looser Connectivity Conditions
Definition 7. The direct neighboring set of s i, denoted as DN(i), is the set of sensors
each of which has a communication link to s i and whose sensing region intersects with
si’s sensing region. Similarly, the multi-hop neighboring set of s i, denoted as MN(i), is
the set of sensors each of which has a (single- or multi-hop) path to s i and whose sensing
region intersects with si’s.
Definition 8. Consider any sensor si. We say that si is k-loose-direct-neighbor-peri-
meter-covered, or k-LDPC, if si is k-perimeter-covered by and only by nodes in DN(i).
Similarly, we say that si is k-loose-multihop-neighbor-perimeter-covered, or k-LMPC, if
si is k-perimeter-covered by and only by nodes in MN(i).
We comment that for any sensor si, DN(i) ⊆ MN(i) ⊆ N(i). So the definition that
si is k-LDPC is looser than that si is k-DPC in the sense that k-DPC guarantees that there
is a link from si to each of N(i), but k-LDPC only guarantees that there is a link from s i
to each of DN(i). For example, consider sensor s i in Fig. 5. There is another sensor sx
whose sensing range intersects with sensor si’s sensing range but who has no link to s i,
i.e., sx ∈ N(i)−DN(i). Without taking sx into account, si is 1-perimeter-covered by and
only by nodes in DN(i) and is thus 1-LDPC. However, s i is not 1-DPC since it does not
ACM Journal Name, Vol. V, No. N, M 20YY.
10 · C.-F. Huang et al.
Fig. 7. An example of two connected components each of which 1-covers A.
and Theorem 5 are more practical because each sensor only needs to collect its reachable
neighbors’ information to make its decision. Most applications can be satisfied if a subset
of sensors is connected and can provide sufficient coverage. The redundance caused by
multiple components may be eliminated by a higher level coordinator, such as the base
station, to properly schedule each component’s working time such that no two components
of the network are active at the same time.
4. DISTRIBUTED COVERAGE AND CONNECTIVITY PROTOCOLS
The quality of a sensor network can be reflected by the levels of coverage and connectiv-
ity that it offers. The above results provide us a foundation to determine, or even select,
the quality of a sensor network by looking at how each sensor’s perimeter is covered by
its neighbors. Section 4.1 shows how to translate the above results to fully distributed
coverage-and-connectivity-determination protocols. When sensors are overly deployed,
the coverage and connectivity of the network may exceed our expectation. In this case,
Section 4.2 proposes a distributed quality selection protocol to automatically adjust its cov-
erage and connectivity by putting sensors into sleep mode and tuning sensors’ transmission
power. In Section 4.3, we show how to integrate the above results into one energy-saving
protocol to prolong the network lifetime.
4.1 Coverage and Connectivity Determination Protocols
The goal of the protocol is to determine the levels of coverage and connectivity of the
network. For a sensor to determine how its perimeter is covered, first it has to collect
how its one-hop neighboring sensors’ sensing regions intersect with its sensing region and
calculate the level of its perimeter coverage. Periodical BEACON messages can be sent
to carry sensors’ location and sensing range information. On receiving such BEACON
messages, a sensor can determine who its direct neighbors are and how its perimeter is
covered by them. As reviewed in Section 2, determining a sensor’s perimeter coverage can
be done efficiently in polynomial time [Huang and Tseng 2003]. If the level of perimeter
coverage is determined to be k in this step, we can say that this sensor is k-LDPC.
If the above level of coverage, k, is below our expectation, the sensor can flood a QUERY
message to its neighbors to find out who else having overlapping sensing regions with
itself. The flooding can be a localized flooding (with a certain hop limit) to save cost. Each
ACM Journal Name, Vol. V, No. N, M 20YY.
12 · C.-F. Huang et al.
Fig. 8. An example of the Sleep Protocol. Sensor sx is a candidate with respect to sensor sy .
(2) If sx is a candidate for each sy that is a direct neighbor of sx, then sx is eligible to go
to the sleep mode. Then sx waits for a random backoff time Trand and overhears if
there is any other sleeping request. (One possibility is to set Trand according to sx’s
remaining energy.) If any sleeping request is heard, sx will go back to step 1, hold for
another random period, and try again. Otherwise, sx will send a SLEEP message to
each of its neighbors and wait for their responses by setting up a timer T s.
(3) Each sy which is a neighbor of sx can reply a GRANT-SLEEP message to sx if it has no
pending grant currently. Otherwise, a REJECT-SLEEP message is replied. Note that
to avoid erroneously putting too many sensors into sleep and to maintain synchroniza-
tion, a sensor can have at most one pending grant at one time. Specifically, a GRANT-
SLEEP message is clear from the pending status once a CONFIRM/WITHDRAW mes-
sage is received (see step 4 below).
(4) If sx can collect a GRANT-SLEEP message from each of its neighbors, sx broadcasts
a CONFIRM message to its neighbors and then goes to sleep. If any REJECT-SLEEP
message is received or the timer Ts expires, sx broadcasts a WITHDRAW message to
its neighbors.
Note that in the above step 1, sx needs to know all direct neighbors of sensor sy . Since
sx and sy are direct neighbors, these sensors are sx’s two-hop neighbors. Fig. 8 shows
an example of the above protocol. If sx intends to go to sleep, it will check the perimeter
p(sx, sy) (shown in thick line). Since p(sx, sy) is also covered by sz and sw. If the target
coverage is ks=1, then sx is a candidate with respect to sy . Also note that the timer T is
necessary because we assume an unreliable broadcast.
4.2.2 The Power Control Protocol. The power control protocol is aim to reduce the
transmission power of sensors to save energy. Since this operation does not affect the sens-
ing unit(s), the sensing capability of sensors (and thus the level of coverage of the network)
is not reduced. Suppose that the network is ks-LDPC. The purpose of this protocol is to
reduce some sensors’ transmission power to make the network at least k c-LDPC, where ks
≥ kc. This results in a ks-covered, kc-connected network.
This protocol assumes that each sensor knows the information of its two-hop neighbors.
For sensor sx which intends to reduce its transmission powers, it executes the following
procedure:
ACM Journal Name, Vol. V, No. N, M 20YY.
14 · C.-F. Huang et al.
connect the communication link between sx and its farthest direct neighbor, sy , by power
control. First, sx examines its intersection with sy . Both segments p(sx, sy) and p(sy, sx)
are 2-LDPC, so sx sends a DISCONNECT message to sy , which will agree by replying a
GRANT-DISC message. Then sx can reduce its transmission power to the level that can
reach the next farthest neighbor sz . Next, sx examines its intersection with sz . Both seg-
ments p(sx, sz) and p(sz, sx) are 2-LDPC, so sx sends a DISCONNECT message to sz .
Suppose that sz has a pending disconnecting request currently, it will reply a REJECT-
DISC message to sx. Then sx stops its procedure. Note that in the above scenario, sy
may not necessarily reduce its transmission power even if it grants sx’s request to reduce
power. For example, sy may not be able to reduce its power because sw wants to remain
connected with sy . In order to maintain connectivity with sw, sy can still reach sx. This
results in an asymmetric link between sx and sy (i.e., the transmission power of sx cannot
reach sy, but the transmission power of sy can reach sx). Therefore, only sx can benefit
from the transmission power.
4.3 An Integrated Energy-Saving Protocol
In Fig. 10, we show how to integrate the above coverage and connectivity determination
protocol, sleep protocol, and power control protocol together into one protocol. The pur-
pose is to save energy while maintaining the quality of the network. Basically, these sub-
protocols are executed in that order. We assume that the goal is to achieve a k s-covered, kc-
connected network, where ks ≥ kc. In particular, we set up two timers, one called Tsleep
for sleeping sensors to wake up themselves, and one called T cycle for sensors to re-check
their local coverage and connectivity (this is to prevent neighboring sensors from running
out of batteries, thus resulting in a network weaker than ks-covered and kc-connected).
Also, a new HELP message is designed for sensors to call others’ assistance to increase
the coverage and connectivity of the network (if possible) when some sensors run out of
energy. Note that whenever a sensor goes to the initial state, it will use the largest trans-
mission power to determine its local network coverage and connectivity. For example, this
applies to a sensor when it receives a HELP message under a reduced transmission power
status.
5. SIMULATION RESULTS
In this section, we present two sets of simulation experiments. Experiment 1 tests the
network coverage and connectivity at different sensing ranges and communication ranges.
Experiment 2 evaluates the performance of the proposed energy-saving protocol.
5.1 Experiment 1: Coverage and Connectivity
We have developed a simulator to compare the network coverage and connectivity calcu-
lated by Theorem 5 and by an exhausted search algorithm. All results in this section are
from averages of at least 100 runs. The simulation environment is a 100x100 square area,
on which sensors are randomly deployed. The sensing range and communication range of
each sensor are uniformly distributed in certain ranges.
Fig. 11 shows the coverage and connectivity under different communication ranges.
Note that Theorem 5 may not be able to find the exact coverage and connectivity levels
because it only relies on local information. Our goal is to compare the results obtained by
Theorem 5 (which implies coverage as well as connectivity) against the minimum of the
actual coverage and actual connectivity obtained by an exhausted search. So Fig. 11(a)
ACM Journal Name, Vol. V, No. N, M 20YY.
16 · C.-F. Huang et al.
Fig. 11. Network coverage and connectivity under different communication ranges.
sensors’ communication ranges have no variation, while in each point of Fig. 12(b), the
variation range is 20. As can be seen, although in both cases Theorem 5 finds about the
same values of coverage and connectivity, since the actual connectivity reduces, Theorem 5
actually matches closer to the actual situations in the case of Fig. 12(b). In Fig. 13, we con-
duct the similar simulation by keeping the communication ranges unchanged but changing
the mean and variation of sensing ranges. The trend is similar – Theorem 5 matches closer
to the actual situations when there are larger variations in sensing ranges. Also, by com-
paring Fig. 12 and Fig. 13, we observe that the gaps reduce when the ratios of average
communication range to average sensing range increase. The reason is that as the ratio
increases, a sensor is able to collect more information about its neighborhood.
5.2 Experiment 2: Network Life Time
This section verifies our integrated energy-saving protocol for prolonging network lifetime
while ensuring both coverage and communication quality. We consider three performance
metrics: number of alive nodes, coverage level, and connectivity level. In these experi-
ments, there are 300 sensors randomly deployed in a 100x100 square area with sensing
range = 15 ∼ 25 units, communication range = 30 ∼ 50 units, and initial energy = 8000
∼ 12000 units (all in a uniform distribution). Our goal is to achieve a k s-covered and kc-
connected network. We sample the network status every 10 seconds. We assume a constant
traffic rate for each sensor, and the energy cost of each transmission is proportional to a
sensor’s transmission range. The energy cost for sensing is also proportional to a sensor’s
sensing range [Lu et al. 2005]. Therefore, for each sensor s i, the energy consumed every
second is proportional to the sum of its sensing range r i and its current communication
ACM Journal Name, Vol. V, No. N, M 20YY.
18 · C.-F. Huang et al.
Na ve CCP+SPAN Sleep Sleep+PC Na ve CCP+SPAN Sleep Sleep+PC
Fig. 14. Comparisons of the naive, CCP+SPAN, Sleep, and Sleep+PC protocols.
ACM Journal Name, Vol. V, No. N, M 20YY.
20 · C.-F. Huang et al.
Fig. 17. Network lifetime under different coverage and connectivity requirements (Sensing
Range = 15 ∼ 25 and Communication Range = 30 ∼ 50).
situations, Sleep+PC performs the best. In fact, when the communication range increases,
the gaps between Sleep+PC and other protocols enlarge relatively. So our power control
scheme can effectively reduce network connectivity and prolong network lifetime. Basi-
cally, our schemes can perform better when sensors have larger communication ranges.
This is because sensors with larger transmission ranges can find more neighbors, collect
more necessary information needed for making sleeping and power-controlling decisions,
and thus have higher chance to go to sleep and/or shrink their powers. Besides, it is obvi-
ous that power control can more effectively reduce network connectivity if sensors’ initial
communication ranges are larger. However, how much Sleep+PC can outperform other
schemes also relies on the network density and the level of coverage and connectivity to be
achieved. If ks and kc are closer to kinit, our scheme is less effective. Fig. 16 shows the
similar experiments under the same communication range (30 ∼ 50) but different sensing
ranges. In Fig. 17, we further test under different coverage and connectivity requirements.
Around 1 to 2 times more lifetime can be seen when comparing Sleep+PC to CCP+SPAN.
6. CONCLUSIONS AND FUTURE WORK
We have proposed fundamental theorems for determining the levels of coverage and con-
nectivity of a sensor network. Earlier works are all based on stronger assumptions that
the sensing distances and communication distances of sensors must satisfy some relations.
We study this issue under an arbitrary relationship between sensing and communication
ranges. Based on the proposed theorems, we have developed distributed protocols for
determining the levels of coverage and connectivity of a sensor network and even for ad-
justing a sensor network to achieve the expected levels of coverage and connectivity. The
approaches that we take are to put some sensors into the sleep mode and to reduce some
sensors’ transmission power. As far as we know, the combination of these mechanisms has
not been well studied in this field, especially when coverage and connectivity issues are
concerned. In our work, a deterministic model is used to formulate sensors’ sensing and
communication ranges. In reality, these values may follow a probabilistic model (such as
ACM Journal Name, Vol. V, No. N, M 20YY.
22 · C.-F. Huang et al.
TSENG, Y.-C., KUO, S.-P., LEE, H.-W., AND HUANG, C.-F. 2003. Location tracking in a wireless sensor
network by mobile agents and its data fusion strategies. In Int’l Symp. on Information Processing in Sensor
Networks (IPSN).
VELTRI, G., HUANG, Q., QU, G., AND POTKONJAK, M. 2003. Minimal and maximal exposure path algorithms
for wireless embedded sensor networks. In ACM Int’l Conf. on Embedded Networked Sensor Systems (SenSys).
40–50.
WANG, X., XING, G., ZHANG, Y., LU, C., PLESS, R., AND GILL, C. 2003. Integrated coverage and connec-
tivity configuration in wireless sensor networks. In ACM Int’l Conf. on Embedded Networked Sensor Systems
(SenSys). 28–39.
WATTENHOFER, R., LI, L., BAHL, P., AND WANG, Y.-M. 2001. Distributed topology control for power effi-
cient operation in multihop wireless ad hoc networks. In IEEE INFOCOM. 1388 – 1397.
WOO, A. AND CULLER, D. E. 2001. A transmission control scheme for media access in sensor networks. In
ACM Int’l Conf. on Mobile Computing and Networking (MobiCom). 221–235.
XU, Y., HEIDEMANN, J., AND ESTRIN, D. 2001. Geography-informed energy conservation for ad hoc routing.
In ACM Int’l Conf. on Mobile Computing and Networking (MobiCom). 70–84.
YAN, T., HE, T., AND STANKOVIC, J. A. 2003. Differentiated surveillance for sensor networks. In ACM Int’l
Conf. on Embedded Networked Sensor Systems (SenSys). 51–62.
YE, W., HEIDEMANN, J., AND ESTRIN, D. 2002. An energy-efficient MAC protocol for wireless sensor net-
works. In IEEE INFOCOM. 1567–1576.
ZHANG, H. AND HOU, J. C. 2004a. Maintaining sensing coverage and connectivity in large sensor networks.
In NSF International Workshop on Theoretical and Algorithmic Aspects of Sensor, Ad Hoc Wireless, and Peer-
to-Peer Networks.
ZHANG, H. AND HOU, J. C. 2004b. On deriving the upper bound of lifetime for large sensor networks. In ACM
Int’l Symp. on Mobile Ad Hoc Networking and Computing (MobiHOC). 121 – 132.
Received MM YY; accepted MM YY
ACM Journal Name, Vol. V, No. N, M 20YY.
Decentralized Energy-Conserving and Coverage-
Preserving Protocols for Wireless Sensor Networks
CHI-FU HUANG, LI-CHU LO, YU-CHEE TSENG
National Chiao-Tung University
and
WEN-TSUEN CHEN
National Tsing-Hua University
In this paper, we propose several decentralized protocols that schedule sensors’ active and sleeping periods to
prolong the network lifetime while maintain the sensing field sufficiently covered. The proposed protocols are
based on a model similar to that of [Yan et al. 2003], but improve its results in several senses. First, our approach
can significantly reduce the computational complexity incurred, and at the same time achieve better accuracy in
determining the coverage of the sensing area. Second, we extend the result such that it can support multi-layer
coverage of the sensing field. Third, we further enhance [Yan et al. 2003] by proposing several optimization
mechanisms to balance or reduce sensors’ energy expenditure.
Categories and Subject Descriptors: C.2.2 [Computer-Communication Networks]: Network Protocols—Ap-
plications; C.3 [Special-Purpose and Application-Based Systems]: —Real-time and embedded systems
General Terms: Algorithms, Design, Performance
Additional Key Words and Phrases: Sensor network, coverage, energy conservation, computational geometry
1. INTRODUCTION
The coverage problem has been widely studied in [Huang and Tseng 2003; Clouqueur
et al. 2002; Meguerdichian et al. 2001]. However, in wireless sensor networks, to maintain
sufficient coverage and to achieve long system lifetime are two contradicting factors in
topology design. This issue has been extensively studied recently [Ye et al. 2003; Tian and
Georganas 2003; Hsin and Liu 2004; Gui and Mohapatra 2004].
This paper proposes several decentralized energy-conserving and coverage-preserving
protocols to prolong the network lifetime while maintain the sensing field sufficiently cov-
ered. The proposed protocols are based on the model in [Yan et al. 2003], but improve its
results in several senses, including lower computational complexity and higher accuracy,
extension to support multi-layer coverage, and several optimization mechanisms to further
balance or reduce sensors’ energy expenditure.
Author’s address: C.-F. Huang, L.-C. Lo, and Y.-C. Tseng, Dept. of CS, NCTU, Hsin-Chu, 30050, Taiwan; W.-T.
Chen, Dept. of CS, NTHU, Hsinchu, 30043, Taiwan.
This research is co-sponsored by NSC under grant number 93-2752-E-007-001-PAE, by III under the Communi-
cations Software Technology Project, by MOEA under grant number 94-EC-17-A-04-S1-044, by ITRI, Taiwan,
and by Intel Inc.
Permission to make digital/hard copy of all or part of this material without fee for personal or classroom use
provided that the copies are not made or distributed for profit or commercial advantage, the ACM copyright/server
notice, the title of the publication, and its date appear, and notice is given that copying is by permission of the
ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute to lists requires prior specific
permission and/or a fee.
c© 20YY ACM 0000-0000/20YY/0000-0001 $5.00
ACM Journal Name, Vol. V, No. N, M 20YY, Pages 1–5.
Energy-Conserving and Coverage-Preserving Protocols · 3
Sensing Phase
Round 1 Round 2
...
Round m
...
Trnd
Refi
BackiFronti
Tw_cycle
Tsen
Round r
active period
sleeping period
... ...
Tw_cycle
Initialization PhaseTinit
HELLO
backoff
Tw_cycle
Fig. 1. The structure of sensors’ working cycles.
should be carefully selected to ensure that the sensing area is sufficiently covered. We use
a theorem stated in [Hall 1988], which claims that if all intersection points between any
two sensors’ sensing ranges and between any sensor’s sensing range and the boundary of
A are sufficiently covered, then the target area A is sufficiently covered. More specifically,
for each intersection point, we have to schedule at least one sensor to be on-duty at any
moment to cover this point.
To calculate Fronti and Backi, let the set of intersection points inside si’s sensing
area be P . For each point p ∈ P , si calculates two values, Frontp,i and Backp,i, as
follows. Let C(p) be the set of sensors that cover point p (including s i). Then si sorts the
reference times of all these sensors in C(p) into a list Lp in an ascending order, and derives
that: Frontp,i = [(Refi − prev(Refi)) mod Trnd]/2 and Backp,i = [(next(Refi) −
Refi) mod Trnd]/2, where prev(Refi) and next(Refi) are the reference times before
and after Refi in the list Lp, respectively. Note that here we consider Lp as a circular
list. Intuitively, the above equations allow sensors in Lp to cooperatively cover point p in
a time-division manner. For two consecutive reference times in L p, the corresponding two
sensors will divide their responsibility at the middle point of their reference times, such
that one covers p before the middle point, and the other does after the middle point. To
ensure that each intersection point is covered, the active period of sensor s i is set to the
union of schedules obtained from all intersection points under s i’s coverage. So we define
Fronti = max∀p∈P{Frontp,i} and Backi = max∀p∈P {Backp,i}.
Suppose that a node has at most d neighbors. The computational complexity of our
scheme is O(d3) for each node. The scheme in [Yan et al. 2003] takes a grid approximation
approach. Given a grid width of g, it takes time O(d πr
2
g2 ) for a sensor to decide its working
schedule, where r is sensors’ sensing range.
3.1.2 Energy-Based 1-CP Protocol. Below, we try to utilize sensors’ remaining en-
ergies to balance their energy consumption and prolong network lifetime. This requires
each sensor si to broadcast its remaining energy Ei in its HELLO. Observe that in our
basic scheme, for each intersection point p, the interval between two adjacent reference
times in Lp will affect the corresponding sensors’ on-duty times in a round. Therefore, the
reference times of sensors with more energies should be placed more sparsely in a round
than those with less energies. To achieve this goal, each round is logically divided into
two zones with different lengths, [0, 3Trnd4 ) and [
3Trnd
4 , Trnd). Sensors with more energies
should randomly choose their reference times from the larger zone, while sensors with less
remaining energies should choose from the smaller zone. The criteria to determine sensors’
remaining energies may be based on some agreement, such as a threshold. Alternatively,
a node finding its remaining energy ranked top 50% among its neighbors can choose from
ACM Journal Name, Vol. V, No. N, M 20YY.
Energy-Conserving and Coverage-Preserving Protocols · 5
40
50
60
70
80
90
100
0 50 100 150 200 250 300 350 400
time(rounds)
co
v
er
ag
e(
%
)
Basic
Basic-LSF
Basic-SLF
40
50
60
70
80
90
100
0 50 100 150 200 250 300 350 400
time(round)
co
v
er
ag
e(
%
)
Energy
Energy-LSF
Energy-SLF
Fig. 2. Simulation results (A = 100 × 100, r = randomly from 10 to 50).
shrinks its on-duty time to [Refi − Front′p,i, Refi + Back
′
p,i]. (Note that this can be
easily done by putting all integrated schedules of sensors in C(p) on the time axis.)
(4) The final integrated schedule of si is [Refi−Front′i, Refi+Back
′
i], where Front
′
i =
max∀p∈P {Front′p,i} and Back
′
i = max∀p∈P {Back
′
p,i}.
(5) After calculating its final schedule, si broadcasts this schedule to its neighbors, and it
can not change its schedule any more in this cycle.
4. CONCLUSIONS
This paper has proposed several decentralized energy-conserving and coverage-preserving
protocols to prolong the network lifetime while maintain the sensing field sufficiently cov-
ered. Fig. 2 compares the coverage ratios of our protocols in a 100-node network. More
simulation results can be found in [Lo 2005].
REFERENCES
CLOUQUEUR, T., PHIPATANASUPHORN, V., RAMANATHAN, P., AND SALUJA, K. K. 2002. Sensor deployment
strategy for target detection. In ACM Int’l Workshop on Wireless Sensor Networks and Applications (WSNA).
GUI, C. AND MOHAPATRA, P. 2004. Power conservation and quality of surveillance in target tracking sensor
networks. In ACM Int’l Conf. on Mobile Computing and Networking (MobiCom).
HALL, P. 1988. Introduction to the Theory of Coverage Processes. Wiley, New York.
HSIN, C.-F. AND LIU, M. 2004. Network coverage using low duty-cycled sensors: Random & coordinated
sleep algorithms. In Int’l Symp. on Information Processing in Sensor Networks (IPSN).
HUANG, C.-F. AND TSENG, Y.-C. 2003. The coverage problem in a wireless sensor network. In ACM Int’l
Workshop on Wireless Sensor Networks and Applications (WSNA).
LO, L.-C. 2005. Decentralized energy-conserving and coverage-preserving protocols for wireless sensor net-
works. M.S. thesis, National Chiao-Tung University, Hsin-Chu, 30050, Taiwan.
MEGUERDICHIAN, S., KOUSHANFAR, F., POTKONJAK, M., AND SRIVASTAVA, M. B. 2001. Coverage prob-
lems in wireless ad-hoc sensor networks. In IEEE INFOCOM. 1380–1387.
TIAN, D. AND GEORGANAS, N. D. 2003. A node scheduling scheme for energy conservation in large wireless
sensor networks. Wireless Commun. and Mobile Comput. (WCMC) 3, 271–290.
YAN, T., HE, T., AND STANKOVIC, J. A. 2003. Differentiated surveillance for sensor networks. In ACM Int’l
Conf. on Embedded Networked Sensor Systems (SenSys). 51–62.
YE, F., ZHONG, G., LU, S., AND ZHANG, L. 2003. PEAS: A robust energy conserving protocol for long-lived
sensor networks. In Int’l Conf. on Distributed Computing Systems (ICDCS).
Received MM YY; accepted MM YY
ACM Journal Name, Vol. V, No. N, M 20YY.
IEEE TRANSACTIONS ON MOBILE COMPUTING, TMC-0278-1006.R1 1
Efficient Placement and Dispatch of Sensors
in a Wireless Sensor Network
You-Chiun Wang, Chun-Chi Hu, and Yu-Chee Tseng, Senior Member, IEEE
Abstract— Sensor deployment is a critical issue because it
affects the cost and detection capability of a wireless sensor
network. In this work, we consider two related deployment
problems: sensor placement and sensor dispatch. The former asks
how to place the least number of sensors in a field to achieve
sensing coverage and network connectivity, while the latter asks
how to determine from a set of mobile sensors a subset of
sensors to be moved to an area of interest with certain objective
functions such that the coverage and connectivity properties are
satisfied. This work is targeted toward planned deployment.
Our solution to the placement problem allows an arbitrary-
shaped sensing field possibly with arbitrary-shaped obstacles and
an arbitrary relationship between the communication distance
and sensing distance of sensors, and thus significant relaxes
the limitations of existing results. Our solutions to the dispatch
problem include a centralized one and a distributed one. The
centralized one is based on adopting the former placement results
and converting the problem to the maximum-weight maximum-
matching problem with the objective of minimizing the total
energy consumption to move sensors or maximizing the average
remaining energy of sensors after movement. Designed in a
similar way, the distributed one allows sensors to determine their
moving directions in an autonomous manner.
Index Terms— connectivity, coverage, deployment, mobile sen-
sors, network management, topology control, wireless sensor
networks.
I. INTRODUCTION
THE emerging wireless sensor networks provide an inexpen-sive and powerful means to monitor the physical environ-
ment. Such a network is composed of many tiny, low-power
nodes, each consisting of actuators, sensing devices, a wireless
transceiver, and possibly a mobilizer [2]. These sensor nodes are
massively deployed in a region of interest to gather and process
environmental information. Wireless sensor networks have appli-
cations in agricultural production [5], traffic management [16],
emergency navigation [27], and surveillance [28].
How to deploy sensors is a critical issue because it affects the
cost and detection capability of a wireless sensor network. This
work investigates the sensor deployment problem. We target at
planned deployment in environments such as buildings or known
fields. We address two related problems: sensor placement and
sensor dispatch. The placement problem asks how to place the
least number of sensors in a field to achieve desired coverage
and connectivity properties [23], [26], [33], where coverage is to
guarantee that every location in the sensing field is monitored by
at least one sensor and connectivity is to ensure that there are
Manuscript received October 15, 2006; revised April 17, 2007.
Y.-C. Wang is with the Department of Computer Science, National Chiao-
Tung University, Hsin-Chu, 30010, Taiwan. E-mail: wangyc@cs.nctu.edu.tw
C.-C. Hu is with the Department of Computer Science, National Chiao-
Tung University, Hsin-Chu, 30010, Taiwan. E-mail: cchu@cs.nctu.edu.tw
Y.-C. Tseng is with the Department of Computer Science, National Chiao-
Tung University, Hsin-Chu, 30010, Taiwan. E-mail: yctseng@cs.nctu.edu.tw
sufficient routing paths between sensors. Note that coverage is
affected by sensors’ sensitivity, while connectivity is decided by
sensors’ communication ranges. The dispatch problem assumes
that sensors are mobilized and the goal is, given a set of mobile
sensors and an area of interest inside the sensing field, to choose
a subset of sensors to be delegated to the area of interest with
certain objective functions such that coverage and connectivity
properties are satisfied.
In the literature, the art gallery problem [24], [25] also aims
to use the minimum number of guards to watch a polygon area.
However, it is assumed that a guard can watch any point as long
as line-of-sight exists and it does not address the communication
issue between guards. Several studies [8], [13], [21] model a
sensing field as grid points and discuss how to place sensors
on some grid points to satisfy certain coverage requirements.
Reference [8] discusses how to place two types of sensors with
different costs and sensing ranges such that every grid point is
covered by sensors and the total cost is minimized. The work
in [13] considers a probabilistic sensing model and discusses
how to place sensors in a field possibly with obstacles such
that every grid point is covered with a minimum confidence
level. In [21], the objective is to place sensors to ensure that
every grid point is covered by different sensors; the result is to
distinguish from different grid points for localization applications.
Using grid approximation may cause high computation cost. Also,
these works do not address the relationship between sensors’
communication distance rc and sensing distance rs. The work in
[18] suggests to place sensors strip by strip, but it only addresses
the rc = rs case and does not consider the existence of obstacles.
Sensor deployment has also been discussed in the area of robotics
[1], [15]. With robots, sensors can be deployed one by one and the
result can be applied to an unknown environment. Some works
[7], [26], [32], [33] address the coverage and connectivity issue by
assuming that there is redundancy in the initial deployment and
the goal is to alternate sensors between sleep and active modes
to reduce energy consumption while maintaining full coverage of
the sensing field.
Mobilizers have been assumed in several studies. References
[14], [29], [35] discuss how to move sensors to enhance coverage
of the sensing field by using the Voronoi diagram or attrac-
tive/repulsive forces between sensors. The works in [30], [31]
partition the sensing field into grids, and move sensors from high-
density grids to low-density ones to construct a uniform topology.
The work [4] suggests to move some sensors to make the network
biconnected. In [6], it discusses how to move sensors to some
locations (such as where events happen) while still maintaining
complete coverage of the sensing field. As can be seen, the goals
of existing works are quite different from the dispatch problem
defined in this work. In fact, the works [11], [17], [28] have
proposed their design and implementation of mobile sensors.
Such mobile platforms are controlled by embedded computers and
IEEE TRANSACTIONS ON MOBILE COMPUTING, TMC-0278-1006.R1 3
(a) (b)
s
r
c
r
3
s
r
3
s
r
3
s
r
Fig. 3. Two possible sensor placements: (a) coverage-first placement and (b)
connectivity-first placement.
III. SOLUTIONS TO THE SENSOR PLACEMENT PROBLEM
To start with, we first consider two possible placements. The
first one tries to reduce the number of sensors by minimizing the
overlapping coverage. The result would be as shown in Fig. 3(a),
where neighboring sensors are evenly separated by a distance of√
3rs. This scheme is efficient when rc ≥
√
3rs since connectivity
is automatically guaranteed. However, when rc <
√
3rs, extra
sensors have to be added to maintain connectivity. It is inefficient
because all sensing field has been covered and these newly
added sensors will not make any contribution to coverage. The
second possible placement is to meet the connectivity requirement
first. This placement would be as shown in Fig. 3(b), where
neighboring sensors are evenly separated by a distance of rc.
This scheme is efficient when rc ≤
√
3rs because coverage
is automatically guaranteed. However, when rc >
√
3rs, extra
sensors have to be added to maintain coverage. It is inefficient
because the overlapping coverage could be large.
Our placement has the following features. First, it avoids the
dilemma in the above placements by taking both rc and rs into
account. Second, our solution is more general as it allows an
arbitrary shape of sensing field A and possibly obstacles in A. Our
scheme works in two steps. First, it partitions A into a number of
regions. Regions are classified into single-row regions and multi-
row regions. A single-row region is a belt-like area with width
no larger than
√
3rmin, where rmin = min{rc, rs}, so a row of
sensors is sufficient to fully cover the region while maintaining
connectivity. A multi-row region is perceivably larger and can
be covered by several rows of sensors. Fig. 4 gives an example,
where the sensing field is partitioned into eight single-row regions
and six multi-row regions.
A. Partitioning the Sensing Field
Algorithm 1 gives the pseudo code of our partition algorithm.
The idea is to first identify all single-row regions. After excluding
single-row regions, the remaining regions are multi-row regions.
To identify single-row regions, we expand the boundaries of
A inward and perimeters of obstacles outward by a distance of√
3rmin. If there is a single-row region between one obstacle
and A’s boundary line segment uv, the expanded parallel line
u′v′ must cut off a partial region, say, O of the obstacle or A
(the area outside A). Then we can take a projection from O
to uv to obtain the single-row region. Fig. 4(a) shows how to
find single-row regions for the boundary, where the dotted lines
are the expanded parallel lines of A’s boundaries. After taking
projections, we can obtain six single-row regions a, b, d, e, f ,
and h in Fig. 4(b). Then we can perform the same steps for
each obstacle. Note that a single-row region obtained from one
obstacle may have overlapping with those obtained earlier (due
to different projections). In this case, we can simply merge those
with overlappings into one single-row region. This guarantees that
our partition algorithm will produce a unique output. Fig. 4(b)
shows all obtained single-row regions.
The aforementioned step may obtain several single-row regions.
Excluding such regions, the remaining areas of A are multi-row
regions. An example is given in Fig. 4(c). Note that there could
be still obstacles inside a multi-row region (e.g., the region 6).
Algorithm 1: Partition
Input: A: sensing field
B: set of A’s boundaries and obstacles’ perimeters
Output: single-row and multi-row regions
foreach uv ∈ B do /∗ find out all single-row regions ∗/1
expand a parallel line u′v′ by a distance of
√
3rmin;2
if u′v′ cuts off a partial region O of an obstacle then3
take a project P from O to uv;4
if P overlaps an existing single-row region P ′ then5
merge P and P ′ into one single-row region;6
else7
make P a new single-row region;8
end9
exclude all single-row regions from A and the rest of the10
regions are multi-row regions;
B. Placing Sensors in Single-row Regions
For a single-row region, we can find its bisector and then place
a sequence of sensors along the bisector to satisfy both coverage
and connectivity. A bisector can be found by doing a triangulation
on that region, as shown in Fig. 5, and then connecting the
midpoints of all dotted lines. Following the bisector, we can place
a sequence of sensors each separated by a distance of rmin to
ensure coverage and connectivity of that region, as shown in
Fig. 5. Note that we always add an extra sensor at the end of
the bisector for ensuring connectivity to neighboring regions.
C. Placing Sensors in Multi-row Regions
Multiple rows of sensors will be placed in such regions. Below,
we first consider a simple 2D plane without boundaries and
obstacles. Then, we extend our result to an environment with
boundaries and obstacles. Finally, we discuss the property of
network connectivity in our placement scheme.
1) A Simple 2D Plane: Given a 2D plane without boundaries
and obstacles, we will place sensors row by row. The basic idea is
to form a row of sensors that can guarantee continuous coverage
and connectivity. Adjacent rows should guarantee continuous cov-
erage of the area. Finally, we may add some columns of sensors
between adjacent rows, if necessary, to ensure connectivity. Based
on the relationship of rc and rs, we separate the discussion into
two cases.
Case 1: rc <
√
3rs. In this case, sensors on each row are
separated by a distance of rc, so the connectivity of each row
can be guaranteed. Since rc <
√
3rs, each row of sensors can
cover a belt-like area with a width of 2δ, where δ =
√
r2s − r
2
c
4 .
IEEE TRANSACTIONS ON MOBILE COMPUTING, TMC-0278-1006.R1 5
TABLE I
COORDINATES OF THE SIX NEIGHBORS OF A SENSOR AT LOCATION (x, y)
IN A MULTI-ROW REGION.
neighbor rc <
√
3rs rc ≥
√
3rs
n1 (x + rc, y) (x +
√
3rs, y)
n2 (x +
rc
2
, y − (rs + δ)) (x +
√
3rs
2
, y − 3rs
2
)
n3 (x− rc2 , y − (rs + δ)) (x−
√
3rs
2
, y − 3rs
2
)
n4 (x− rc, y) (x−
√
3rs, y)
n5 (x− rc2 , y + (rs + δ)) (x−
√
3rs
2
, y + 3rs
2
)
n6 (x +
rc
2
, y + (rs + δ)) (x +
√
3rs
2
, y + 3rs
2
)
Adjacent rows will be separated by a distance of rs+δ and shifted
by a distance of rc2 . With such an arrangement, the coverage of
the whole area is guaranteed. Fig. 6(a) – (c) show three possible
subcases. Note that in this case, we have to add a column of
sensors between two adjacent rows, each separated by a distance
no larger than rc, to connect them.
Case 2: rc ≥
√
3rs. In this case, the previous approach will
waste a lot of sensors because a small rs will cause two rows to
be very close. So when rc ≥
√
3rs, we propose to place sensors in
a typical triangular-latticed manner such that adjacent sensors are
regularly separated by a distance of
√
3rs, as shown in Fig. 6(d).
Both coverage and connectivity properties are ensured.
2) Multi-row Regions with Boundaries and Obstacles: Next,
we modify the above solution for placing sensors in a region with
boundaries and obstacles. Observe that in our solution, sensors
are placed with regular patterns. Thus, it can be transformed into
an incremental approach where sensors are added into the field
one by one. In Table I, we list the coordinates of a sensor’s six
neighbors. We can place the first sensor in any location of the
region. From the first sensor, the six locations that can potentially
be added with sensors are determined. These locations are inserted
into a queue Q. We then enter a loop in which each time an entry
(x, y) is dequeued from Q. If (x, y) is not inside any obstacle
and not outside the multi-row region, a sensor will be placed in
(x, y). Also, the six neighboring locations of (x, y) in Table I are
inserted into Q if they have not been checked before. This process
is repeated until Q becomes empty.
There are three minor issues left in the above solution. First,
some areas near the boundaries or obstacles may be uncovered.
Second, when rc <
√
3rs, we need to add extra sensors between
adjacent rows to maintain connectivity. Third, connectivity to
neighboring regions needs to be maintained. Fig. 7(a) presents an
example. These problems can be solved by sequentially placing
sensors along the boundaries of the multi-row region and the
perimeters of obstacles, as shown in Fig. 7(b). There are two
cases to be considered. When rc <
√
3rs, since the maximum
width of the uncovered area does not exceed rc, sensors should
be separated by a distance of rc. When rc ≥
√
3rs, the maximum
width of the uncovered area does not exceed
√
3rs, so sensors
should be separated by a distance of
√
3rs. Since rc ≥
√
3rs, the
connectivity between these extra sensors and the regularly placed
sensors are guaranteed.
Note that we can save sensors in the last step by carefully
selecting the first sensor’s position in each multi-row region. In
particular, for each multi-row region, we can place the first sensor
near its longest boundary with a distance of δ if rc <
√
3rs and a
distance of rs2 otherwise. This will make the first row of sensors
fully cover the longest boundary of the multi-row region and thus
we do not have to add extra sensors in the last step. In addition, if
the distance between a row of sensors and a boundary of the multi-
row region (or an obstacle) is no larger than δ when rc <
√
3rs
and no larger than rs2 when rc ≥
√
3rs, we can also skip the last
step. For example, some boundaries in Fig. 7 are not added with
extra sensors.
3) Network Connectivity in a Multi-row Region: Here we
discuss the property of network connectivity in our placement
scheme. There are two cases to be discussed. When rc ≥
√
3rs,
because a sensor will directly connect to its six neighbors (refer
to Fig. 6(d)), the network is guaranteed to be at least 6-connected.
This means that the network will not be partitioned unless there
are more than five sensors broken.
On the other hand, when rc <
√
3rs, if both ends of each row
are connected with sensors (refer to Fig. 7(b)), the network is
guaranteed to be at least 2-connected. To improve the network
connectivity, we can add several columns of sensors, each evenly
separated and connecting rows together. With this, not only the
network connectivity is improved, but also the lengths of routing
paths are reduced. For example, in Fig. 7(b), two additional
columns of sensors are added on the top part. The original hop
count between sensors a and b is thus reduced from eight to five
with the help of additional columns. In Section V, we will further
address this issue through simulations.
D. Adapting to the Probabilistic Sensing Model
Up to now, our placement solution is based on the assumption
of binary sensing model. In some cases, however, the detection
probability of a sensor will decay with the distance from the
sensor to the object. For example, references [13], [36] suggest
that the detection probability of a location u by a sensor si can
be modeled by:
pusi =
{
e−αd(si,u), if d(si, u) ≤ rs
0, otherwise ,
where α is a parameter representing the physical characteristics
of the sensor and d(si, u) is the distance between si and u. Thus,
when an object located at u is within the sensing ranges of a set
Ŝ of sensors, the detection probability can be evaluated as
p(u) = 1−
∏
si∈Ŝ
(1− pusi).
It can be observed that in our placement solutions, for any
combination of rc and rs, there must exist a location which is
covered by only one sensor and has a distance of rs to the sensor.
The detection probability for such a location is e−αrs . Therefore,
our placement solutions can guarantee a detection probability of
at least e−αrs in any location of the sensing field. On the other
hand, if we want to guarantee that every point in the sensing field
has a detection probability no smaller than a given threshold pth,
we can compute a virtual sensing distance r′s by
e−αr
′
s = pth ⇒ r′s = − ln pthα .
According to the above argument, if we replace rs by r′s when
running our placement solutions, it is guaranteed that every point
in the sensing field has a detection probability of at least pth.
IEEE TRANSACTIONS ON MOBILE COMPUTING, TMC-0278-1006.R1 7
elements, each called a virtual location. The weight of each
edge in Ĝ that also appears in G remains the same as that in
G, and the weight of each edge from si ∈ S to (xj , yj) ∈ L̂
is set to wmin, where
wmin = min
si∈S, (xj ,yj)∈L
{w(si, (xj , yj))} − 1.
Intuitively, a virtual location is a dummy one. Its purpose is
to make the two sets S and {L∪L̂} of the bipartite graph Ĝ
to have equal sizes. This allows us to transform the problem
to the maximum-weight perfect-matching problem on graph
Ĝ, whose purpose is to find a perfect matching M in Ĝ
with the maximum total weights of edges in M. (How to
compute M will be discussed in Section IV-A.2.) Note that
the value of wmin is set in such a way that selecting an edge
incident to a virtual location has no impact to a solution to
the maximum-weight perfect-matching problem.
5. For each edge (si, (xj , yj)) in M such that (xj , yj) /∈ L̂,
we move sensor si to location (xj , yj) via the shortest path.
However, if there is any edge (si, (xj , yj)) ∈ M such that
(xj , yj) /∈ L̂ and ei−c(si, (xj , yj)) ≤ 0, it means that we do
not have sufficient energy to move sensors to all locations
in L because M is the optimal solution. Thus the algorithm
terminates.
1) Computing the Shortest Distance d(si, (xj , yj)): Our goal is
to find the shortest collision-free path from si’s current position
to (xj , yj), considering the existence of obstacles. Specifically,
the movement of si should not collide with any obstacle. Several
studies have addressed this issue [12], [22], [34]. Here we propose
a modified approach of [22].
Considering its physical size, si is modeled as a circle with a
radius r. Intuitively, si has a collision-free motion if its center
always keeps at a distance of r or larger away from every
obstacle and A’s boundaries. This can be done by expanding
the perimeters of all obstacles outwardly and A’s boundaries
inwardly by a distance of r and preventing si from moving into
these expanded areas. The problem can be translated to one of
finding a shortest path from si to (xj , yj) in a weighted graph
H = (si ∪ (xj , yj)∪V, E), where V contains all vertices v of the
polygons representing the expanded areas of obstacles and A’s
boundary such that v is not inside other expanded areas, and E
contains all edges (u, v) such that u, v ∈ {si∪(xj , yj)∪V} and uv
does not pass any expanded area of obstacles or A. The weight of
(u, v) ∈ E is length of uv. Fig. 8 gives an example, where double
circles are vertices of H. Nodes g and h are not vertices because
they are inside obstacles 2’s and 3’s expanded areas, respectively.
Edges (a, c), (a, d), (b, c), and (b, d) ∈ E , but (b, e) and (b, f) /∈ E
because they pass the expanded area of obstacle 2.
2) Finding the Maximum-Weight Perfect-Matching M: Recall
that given the bipartite graph Ĝ = (S ∪ L ∪ L̂,S × {L ∪ L̂}), the
goal is to find a perfect matching M in Ĝ with the maximum
total weights of edges in M. In this section, we discuss how to
use the Hungarian method [19] to solve this problem.
Definition 1: Given Ĝ = (S ∪ L ∪ L̂,S × {L ∪ L̂}), a feasible
vertex labeling of Ĝ is a real-valued function f on {S ∪ L ∪ L̂}
such that for all si ∈ S and (xj , yj) ∈ {L ∪ L̂},
f(si) + f((xj , yj)) ≥ w(si, (xj , yj)).
Definition 2: Given a feasible vertex labeling of Ĝ, an equality
subgraph Ĝf = (S ∪L∪ L̂, Ef ) is the subgraph of Ĝ in which Ef
contains all edges (si, (xj , yj)) in Ĝ such that
f(si) + f((xj , yj)) = w(si, (xj , yj)).
Theorem 1: Let f be a feasible vertex labeling of Ĝ and M be
a perfect matching of Ĝf , then M is a maximum-weight perfect
matching of Ĝ.
Proof: We show that no other perfect matching M′ in Ĝ
has a total weight larger than M.
w(M′) =
∑
(si,(xj ,yj))∈M′
w(si, (xj , yj))
≤
∑
(si,(xj ,yj))∈M′
f(si) + f((xj , yj))
=
∑
(si,(xj ,yj))∈M
f(si) + f((xj , yj))
=
∑
(si,(xj ,yj))∈M
w(si, (xj , yj))
= w(M),
so M has the maximum total weights of edges.
The Hungarian method is based on the observation from
Theorem 1. It first assigns an arbitrary feasible vertex labeling
for the graph Ĝ, and then adjusts the labels of vertices until it
can find a perfect matching M in the equality subgraph Ĝf . One
possible feasible vertex labeling is to set f((xj , yj)) = 0 for all
(xj , yj) ∈ {L∪L̂} and to set f(si) to the maximum of the weights
of the edges adjacent to si for all si ∈ S, i.e.,
f(si) = max
(xj ,yj)∈{L∪L̂}
{w(si, (xj , yj))}, ∀si ∈ S.
The complete procedure of the Hungarian method is stated as
follows:
1. Find a maximum matching M in Ĝf . If M is perfect, we
find out the solution and the method finishes. Otherwise,
there must be an unmatched vertex si ∈ S. We then assign
two sets X = {si} and Y = ∅.
2. In the graph Ĝf , if NĜf (X ) = Y , where NĜf (X ) is the set
of vertices in {L∪ L̂} that are adjacent to the vertices in X ,
then go to step 3. Otherwise, we set
β = min
si∈X
(xj ,yj)∈{L∪L̂}−Y
{f(si)+f((xj , yj))−w(si, (xj , yj))},
and construct a new labeling f ′ for Ĝ by
f ′(v) =
⎧⎨
⎩
f(v)− β, for v ∈ X
f(v) + β, for v ∈ Y
f(v), otherwise
.
Then we replace f by f ′, reconstruct the equality subgraph
Ĝf ′ , and go to step 1. Note that we have to satisfy the
conditions of β > 0 and NĜf′ (X ) = Y; otherwise, we
need to reselect another β value that can satisfy the above
conditions.
3. Choose a vertex (xl, yl) in NĜf (X ) but not in Y . If (xl, yl)
is matched with sk ∈ S in M, then we update X = X ∪{sk}
and Y = Y ∪ {(xl, yl)}, and go back to step 2.
Note that each time when we relabeling the graph Ĝ, we may
introduce new edges into the new equality subgraph Ĝf , until
all edges in Ĝ are included. Therefore, the Hungarian method
can always find a perfect matching in Ĝf since Ĝ is a complete
bipartite graph.
IEEE TRANSACTIONS ON MOBILE COMPUTING, TMC-0278-1006.R1 9
(a) rectangle (b) circle (c) non-convex polygon
(d) H-shape (e) office (Fig. 2) (f) arbitrary shape (Fig. 4)
200
300
400
200
80
400
240
300 160
180
400
150
300
400
300
400
5
5
40 120
20
30
80
60
5
18080
5
5
5
20
40
100
200
100 60
60
80
120 60
80 20 10
150
110
Fig. 9. Six types of sensing fields used in the simulations. The unit of length is meter.
(a) (b)
Fig. 10. Two common regular placement patterns: (a) hexagon placement
and (b) square placement.
discussed in the beginning of Section III, and two common regular
placement patterns [3], hexagon and square, as shown in Fig. 10.
To ensure both coverage and connectivity, we set the distance
between adjacent sensors to rmin in the hexagon placement. In
the square placement, the distance between adjacent sensors is
set to rc if rc <
√
2rs, and set to
√
2rs otherwise.
Fig. 11 shows the number of sensors required in different
placement methods. As can be seen, our placement method uses
the least number of sensors in all cases. The coverage-first method
uses more sensors when rs < rc <
√
3rs, because it needs
many extra sensors to maintain connectivity between neighboring
sensors. The connectivity-first method uses more sensors when
rc ≤ rs, because it is dominated by the value of rc and the
overlapping in coverage is large. The hexagon method uses more
sensors when rc > rs, because the distance between adjacent
sensors is limited to small rs. The situation becomes worse as rs
becomes smaller. The square method uses more sensors when
rc <
√
2rs, because it is dominated by the value of rc and
the overlapping in coverage could be also large. Note that when
rc ≥
√
3rs, our method works the same as the coverage-first
method in each individual region, so both schemes will use the
same number of sensors.
When rc <
√
3rs, our placement scheme has the flexibility to
reduce the routing paths of sensors by adding several columns
of sensors. In the second experiment, we evaluate the effect of
the number of additional columns on the all-pair shortest paths
of sensors. In particular, we measure the average hop count of
the shortest path between any two sensors in our placement. In
this experiment, we set the sensing field as the one specified in
Fig. 9(a), and we consider the case of rc = rs. Fig. 12 shows the
results when rc is set to 10 m, 5 m, and 3 m, where the number
of sensors in each row will be 41, 81, and 161, respectively. In
Fig. 12, we can observe that the average hop count of the all-
pair shortest paths can be reduced when we add more columns
of sensors. However, adding these columns will increase the total
number of sensors to be placed in the sensing field. From Fig. 12,
we can find that the suitable number of additional columns is
around two to three when the number of sensors in each row is
among 40 to 160.
The third experiment evaluates different dispatch schemes. The
sensing field A is a 900 m × 900 m square. The region of interest
I is a 300 m × 300 m square located at the center of A. Sensors
are randomly scattered over the region of A−I. With the setting
of (rc, rs) = (28, 16), (23.5, 13.45), (21, 12), (19.5, 11.05), (17.5,
10.1), (16.5, 9.45), and (15.5, 8.9), we will need 150, 200, 250,
300, 350, 400, and 450 sensors, respectively, to be dispatched to
I, according to our placement algorithm. To fairly compare the
centralized and the distributed schemes, the number of sensors is
intentionally set to the required number of sensors in I. Sensors’
initial energies are randomly selected from [1000, 1500] units, and
we set the moving cost Δm = 1 energy unit per meter. The speed
of a sensor is set to 0.5 m/s. For our distributed dispatch method,
we set the timer Tbroadcast as one second. For comparison,
we also design a random method, where we arbitrarily select a
sensor to move to each location in a centralized manner. Fig. 13
shows the simulation results under different number of sensors
required in I. From Fig. 13(a), we can observe that our centralized
method (using Eq. (1) as the objective function) consumes the
least energy compared to other methods. This is a result of our
maximum-matching approach. The distributed method consumes
more energy than the centralized method since our greedy strategy
can make local decisions. The similar result can be observed
from Fig. 13(b), where the centralized method (using Eq. (2) as
the objective function) can achieve the highest average remaining
energy of sensors in I. Note that under both objective functions,
the random method always consumes the most energy, even
though sensors are selected in a centralized manner. This reflects
IEEE TRANSACTIONS ON MOBILE COMPUTING, TMC-0278-1006.R1 11
850
880
910
940
970
1000
1030
150 200 250 300 350 400 450
number of sensors in I
a
v
e
ra
g
e
re
m
a
in
in
g
e
n
e
rg
y
centralized
distributed
random
20
40
60
80
100
120
140
160
180
150 200 250 300 350 400 450
number of sensors in I
to
ta
l
m
o
v
in
g
e
n
e
rg
y
(x
1
0
0
0
) centralized
distributed
random
(b)
(a)
Fig. 13. Comparison of different dispatch methods: (a) the total energy
consumption for movement when using Eq. (1) as the objective function,
and (b) the average remaining energy of sensors when using Eq. (2) as the
objective function.
0
200
400
600
800
1000
1200
1400
1600
1 2 3 4 5 6 7 8 9 10
n
u
m
b
e
r
o
f
b
ro
a
d
c
a
s
ts
p
e
r
s
e
n
s
o
r
272
272.25
272.5
272.75
273
273.25
273.5
273.75
274
274.25
274.5
274.75
275
a
v
e
ra
g
e
m
o
v
in
g
d
is
ta
n
c
e
o
f
s
e
n
s
o
rs
(m
)
number of broadcasts
moving distance
0
200
400
600
800
1000
1200
1400
1600
1 2 3 4 5 6 7 8 9 10
n
u
m
b
e
r
o
f
b
ro
a
d
c
a
s
ts
p
e
r
s
e
n
s
o
r
274.25
274.5
274.75
275
275.25
275.5
275.75
276
276.25
276.5
276.75
a
v
e
ra
g
e
m
o
v
in
g
d
is
ta
n
c
e
o
f
s
e
n
s
o
rs
(m
)
number of broadcasts
moving distance
(b) number of sensors: 400
(a) number of sensors: 200
Tbroadcast (second)
Tbroadcast (second)
Fig. 14. Effect of Tbroadcast on the number of broadcasts and average
moving distance of a sensor.
under grant number 94-EC-17-A-04-S1-044, by ITRI, Taiwan, by
Microsoft Corp., and by Intel Corp.
REFERENCES
[1] E. U. Acar, H. Choset, and P. N. Atkar, “Complete sensor-based coverage
with extended-range detectors: a hierarchical decomposition in terms
of critical points and voronoi diagrams,” in IEEE/RSJ International
Conference on Intelligent Robots and Systems, 2001, pp. 1305–1311.
[2] I. F. Akyildiz, W. Su, Y. Sankarasubramaniam, and E. Cayirci, “A survey
on sensor networks,” IEEE Communications Magazine, vol. 40, no. 8,
pp. 102–114, 2002.
[3] X. Bai, S. Kumar, D. Xuan, Z. Yun, and T. H. Lai, “Deploying wireless
sensors to achieve both coverage and connectivity,” in ACM International
Symposium on Mobile Ad Hoc Networking and Computing, 2006, pp.
131–142.
[4] P. Basu and J. Redi, “Movement control algorithms for realization of
fault-tolerant ad hoc robot networks,” IEEE Network, vol. 18, no. 4, pp.
36–44, 2004.
[5] J. Burrell, T. Brooke, and R. Beckwith, “Vineyard computing: sensor
networks in agricultural production,” IEEE Pervasive Computing, vol. 3,
no. 1, pp. 38–45, 2004.
[6] Z. Butler and D. Rus, “Event-based motion control for mobile-sensor
networks,” IEEE Pervasive Computing, vol. 2, no. 4, pp. 34–42, 2003.
[7] A. Cerpa and D. Estrin, “ASCENT: adaptive self-configuring sensor
networks topologies,” in IEEE INFOCOM, 2002, pp. 1278–1287.
[8] K. Chakrabarty, S. S. Iyengar, H. Qi, and E. Cho, “Grid coverage for
surveillance and target location in distributed sensor networks,” IEEE
Transactions on Computers, vol. 51, no. 12, pp. 1448–1453, 2002.
[9] T. Clouqueur, K. K. Saluja, and P. Ramanathan, “Fault tolerance in
collaborative sensor networks for target detection,” IEEE Transactions
on Computers, vol. 53, pp. 320–333, 2004.
[10] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, Introduction
to Algorithms, The MIT Press, 2001.
[11] T. A. Dahlberg, A. Nasipuri, and C. Taylor, “Explorebots: a mobile
network experimentation testbed,” in ACM SIGCOMM Workshop on
Experimental Approaches to Wireless Network Design and Analysis,
2005, pp. 76–81.
[12] G. M. Dai, A. H. Du, Q. H. Li, and M. C. Wang, “Planning of moving
path based on simplified terrain,” in IEEE International Conference on
Machine Learning and Cybernetics, 2003, pp. 1915–1918.
[13] S. S. Dhillon and K. Chakrabarty, “Sensor placement for effective
coverage and surveillance in distributed sensor networks,” in IEEE
Wireless Communications and Networking, 2003, pp. 1609–1614.
[14] N. Heo and P. K. Varshney, “Energy-efficient deployment of intelligent
mobile sensor networks,” IEEE Transactions on Systems, Man and
Cybernetics - Part A: Systems and Humans, vol. 35, no. 1, pp. 78–92,
2005.
[15] A. Howard, M. J. Mataric´, and G. S. Sukhatme, “An incremental self-
deployment algorithm for mobile sensor networks,” Autonomous Robots,
vol. 13, no. 2, pp. 113–126, 2002.
[16] T. T. Hsieh, “Using sensor networks for highway and traffic applica-
tions,” IEEE Potentials, vol. 23, no. 2, pp. 13–16, 2004.
[17] D. Johnson, T. Stack, R. Fish, D. M. Flickinger, L. Stoller, R. Ricci,
and J. Lepreau, “Mobile Emulab: a robotic wireless and sensor network
testbed,” in IEEE INFOCOM, 2006.
[18] K. Kar and S. Banerjee, “Node placement for connected coverage
in sensor networks,” in International Symposium on Modeling and
Optimization in Mobile, Ad Hoc and Wireless Networks, 2003.
[19] H. W. Kuhn, “The Hungarian method for the assignment problem,”
Naval Research Logistics Quarterly, vol. 2, pp. 83–97, 1955.
[20] LAN/MAN Standards Committee of the IEEE Computer Society, “IEEE
Std 802.15.4-2003, Wireless medium access control (MAC) and physical
layer (PHY) specifications for low-rate wireless personal area networks
(LR-WPANs),” IEEE, 2003.
[21] F. Y. S. Lin and P. L. Chiu, “A near-optimal sensor placement algorithm
to achieve complete coverage/discrimination in sensor networks,” IEEE
Communications Letters, vol. 9, no. 1, pp. 43–45, 2005.
[22] Y. H. Liu and S. Arimoto, “Finding the shortest path of a disc
among polygonal obstacles using a radius-independent graph,” IEEE
Transactions on Robots and Automation, vol. 11, pp. 682–691, 1995.
[23] S. Meguerdichian, F. Koushanfar, M. Potkonjak, and M. B. Srivastava,
“Coverage problems in wireless ad-hoc sensor networks,” in IEEE
INFOCOM, 2001, pp. 1380–1387.
[24] J. O’Rourke, Art gallery theorems and algorithms, Oxford University
Press, 1987.
附錄四： 
 
Non-Location-Based Mobile Sensor 
Relocation in a Hybrid 
Static-Mobile Wireless Sensor 
Network 
 
 
 
F.-J. Wu, H.-C. Hsu, Y.-C. Tseng, and C.-F. Huang 
 
SENSORCOMM, 2009 
data-pumpsensor relaying path
sink
wireless link
(a) (b)
m1
m2
m3
m4
sink
s1
s2 s2
Figure 1. An example of data collection scenario in a
WSN: (a) the initial deployment (b) after relocation of
data-pumps.
load balance. Connectivity needs to make sure that the
high-tier network is not partitioned, while load balance is
to make sure that each syphon serves the similar number
of sensors. We successfully use virtual Voronoi cells to
navigate syphons to achieve both goals simultaneously in a
distributed manner. The navigation part is achieved relying
on the underlaying low-tier topology.
Several existing works have addressed mobile sensor
issues, but focused on different concerns. In [5], [22], mobile
sensors are relocated based on the virtual forces. The work
[14] uses the Voronoi diagram to detect coverage holes and
relocates mobile sensors to cover these holes. These works
[5], [14], [22] all assume that location information is avail-
able. How to use the minimum number of mobile sensors
to guarantee coverage and connectivity is discussed in [15],
[16]. On the contrarily in our work, mobile sensors serve as
the high-tier network under our two-tier architecture.
The rest of this paper is organized as follows. Section
2 formally deﬁnes our problem. The proposed distributed
protocol is in Section 3. Section 4 shows our simulation
results, and Section 5 concludes this paper.
2. Network Model and Problem Deﬁnition
In a sensing ﬁeld F , we are given a two-tier network with
a static sink m0, a set of static sensors S = {s1, s2, . . . , sn},
and a set of mobile data-pumps M = {m1,m2, . . . ,me}
(i.e., syphons). We assume that there are much more statics
sensors than data-pumps, i.e., e  n. Every node (sink,
static sensors, and data-pumps) has a short-range antenna
with a transmission distance rc. Each of the sink and data-
pumps has a long-range antenna with a transmission distance
Rc. Short-range antennas can only communicate with short-
range antennas, and so are long-range antennas. The former
forms the low-tier network, and the latter forms the high-
tier network. Sink m0 is a special data-pump which can not
move. Our goal is to utilize the resource-richer data-pumps
to help relay the sensory data from static sensors to m0.
The problem if formulated as follows. Initially, all S
and M are randomly deployed in F . Deployment of S is
assumed to be dense enough so that the low-tier network is
always connected. Deployment of M is sparse and thus the
high-tier network could be partitioned. A data-pump that is
connected to m0 in the high-tier network is called attached,
and is unattached otherwise. We assume no knowledge about
the location of any node in S and M. Data collection is
conducted by the cooperation of S and M. A si ∈ S
can ﬁrst send its sensory data, along the low-tier network,
to the nearest attached data-pump, called the master data-
pump χ(si). Then χ(si) can relay the data, via the high-tier
network, to m0. Let C(mi) = {sj |χ(sj) = mi}, the set
of sensors served by mi, called mi’s virtual Voronoi cell
(‘cell’ for short). Our goal is to design a distributed range-
free relocation protocol for data-pumps to achieve both
connectivity and load balance. The connectivity requirement
is to enforce all data-pumps to remain attached to m0 after
relocation, while the load balance requirement is to keep the
sizes of virtual Voronoi cells as similar as possible under all
possible combinations of |M| and |S|. Note that the solution
should be ‘range-free’ in the sense that navigating theses
data-pumps can not rely on any geographic locations.
We propose two metrics to evaluate a relocation solution,
and our goal is to minimize the two metrics: (i) load
balance metric: max∀i,j{|C(mi)|−|C(mj)|} and (ii) radius
metric: max∀i,j{R(mi) − R(mj)}, where R(mi) is the
(low-tier) radius of mi’s virtual Voronoi cell centered at
mi. Figure 1(a) and Figure 1(b) are examples before and
after relocating M, respectively. Note that an unattached
data-pump makes no contribution to relaying sensing data,
because it is partitioned from the main part of the high-tier
network.
3. Distributed Data-Pump Relocation Protocol
Our protocol has two operational modes: balancing mode
and connecting mode. An attached data-pump will enter the
balancing mode, while an unattached data-pump will enter
the connecting mode. Initially, only the sink is attached
and all other data-pumps consider themselves unattached.
After the relocation process starts, each attached data-pump
will periodically announce an Attachment message. Once
an unattached data-pump hearing an Attachment message, it
consider itself attached and also periodically announce an At-
tachment message. Under the balancing mode, a data-pump
will try to move toward the center of its virtual Voronoi
cell and push away from its neighboring data-pumps. Under
the connecting mode, a data-pump will attempt to connect
to an attached data-pump. Once an unattached data-pump
becomes an attached one, it will remain attached until the
protocol terminates. Next, we describe these two modes in
details. At the end, we will discuss the synchronization issue.
mi must choose the P (mi) with minimum cost(P (mi))
such that either the following rules can be satisﬁed: (i)
H(P (mi)) < H(mi) or (ii) H(P (mi)) = H(mi) and
H(P (P (mi))) < H(P (mi)), where H(mi), H(P (mi)),
and H(P (P (mi))) are the minimum high-tier hop count
from sink to mi, P (mi), and the parent of P (mi) in
the high-tier network, respectively. Here, the cost(P (mi))
is deﬁned by βN cP (mi) + (1 − β)φ(P (mi),mi), where
N cP (mi) is the number of data-pumps whose parents are
P (mi), φ(P (mi),mi) is the received signal strength of the
Attachment message from P (mi) to mi, and 0 ≤ β ≤ 1
is the weight to reﬂect the importance between N cP (mi) and
φ(P (mi),mi). Note that the smaller N cP (mi) will open up
an opportunity for data-pumps to span the larger-scale high-
tier network served by them as much as possible, while the
smaller φ(P (mi),mi) will open up an opportunity for data-
pumps to move toward the position decided in phase 2 as far
as possible under keeping the connectivity in the high-tier
network.
Next, we detail the protocol as follows. Initially, sink must
broadcast a message via the high-tier network to identify
the H(mi) of each mi. Then, the sink must broadcast a
Select Parent message via the high-tier network and wait
for time period Δtp to count N csink. When a data-pump mi
receives the ﬁrst Select Parent message from another data-
pump, denoted by mj , it will send a Become child message
to mj , set P (mi) = mj , rebroadcast the Select Parent
message, and wait for time period Δtp. Once the mj receives
a Become child message from mi, it must update N cmj by
N cmj + 1 and add mi into its children list L
c(mj), where
Lc(mj) contains the data-pumps whose parents is mj . After
a data-pump mi’s timer Δtp is expired, mi will announce a
Conﬁrm Parent(mi, N cmi) message. When a data-pump mi
receives another Conﬁrm Parent(mk, N cmk) message from a
neighboring data-pump mk with cost(mk) < cost(mj), and
mk is satisﬁed any one of the above rules, it will announce
a Change Parent(mj ,mk) message to change its parent mj
by mk. On the other hand, when mj and mk receive the
Change Parent(mj ,mk) message from mi, they will update
their children list, respectively.
Phases 4: Navigation by sensors. In this phase, each data-
pump mi start to move along the sequence of sensors in
the history of cn(mi), denoted by Q, computed by phase 2
until the termination condition of this round has reached as
follows.
1. If Q = ∅, mi will remove the ﬁrst entry from Q, said
sj , and announce a Navigation Request(sj) message via the
low-tier network. Otherwise, this round is terminated.
2. When the sensor sj hears the Navigation Request(sj)
message, it will repeatedly announce a Come Here(sj)
message.
3. Once mi receives the Come Here(sj) message, it
will try to ﬁnd the moving direction toward sj by the
following way. Initially, mi will set D1, . . . , DK directions
based on its local coordinate and then go and back between
the current position and the position by moving toward
Di direction for d units distance, respectively, to test the
difference in received signal strength, where i = 1, . . . ,K.
Then, mi move toward the direction with the maximum
increasing difference in received signal strength by d units
distance. This process will be repeated until mi can not
ﬁnd a direction with increasing received signal strength (it
implies that mi is nearby the sj). Then, mi must send a
Navigation Complete(sj) to sj to stop the announcement
of Come Here(sj) message.
4. After mi moves to the position nearby the sj , it must
check whether it sill can hear the Attachment messages from
P (mi) and each mj ∈ Lc(mi). If so, it will go to step 1
for continuing to move. Otherwise, this round is terminated
and mi must backtrack to the previous positions until the
connectivity between mi and P (mi) and between mi and
each mj ∈ Lc(mi) could be reconnected.
The above four phases will be repeatedly executed round
by round until the maximum execution round has been
reached. Note that the number of execution rounds will have
an impact on the performance of load balance. We will use
simulation to ﬁnd a modest maximum execution round later.
3.2. Connecting Mode for Unattached Data-Pumps
The main idea of this mode is to enforce each unattached
data-pump mi to move, based on the local information,
toward the sink until it is attached. Speciﬁcally, each
unattached data-pump mi will move toward the neighboring
sensor with minimum sensor hop count from sink (in terms
of short-range antenna hop count). After initial deployment,
the sink will broadcast a message via the low-tier network
to identify the h(sj , sink) for each sj , where h(sj , sink)
is the sensor hop counts from sj to the sink in the low-tier
network. Each unattached data-pump mi must periodically
announce a Connection Request message via the low-tier
network to query nearby sensors. When a sensor sj receives
a Connection Request message from mi, it reply a Connec-
tion Reply(h(sj , sink)) message to mi. According to the
received Connection Reply messages, mi will request the
sensor sj with minimum h(sj , sink) to provide the nav-
igation by announcing a Navigation Request(sj) message
via the low-tier network. Then, mi can move toward the
sensor sj by running the same procedures in the step 2
and step 3 of the phases 4. This procedure is repeatedly
executed by mi until it can hear the Attachment message
from other attached data-pumps and then become an attached
one. Once mi has became an attached data-pump, it must
periodically announce an Attachment message and switch to
the balancing mode until the maximum execution rounds has
been reached.
 0
 0.2
 0.4
 0.6
 0.8
 1
 0  5  10  15  20  25  30  35  40  45  50
fa
irn
es
s 
in
de
x
round
ours
 1
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0
 500  1000  1500  2000  2500
fa
irn
es
s 
in
de
x
radius of deployment, Rf (m)
ours-only connecting mode
ours
SODaR
(a) (b)
 0
 200
 400
 600
 800
 1000
 500  1000  1500  2000  2500
m
o
ve
m
e
n
t o
ve
rh
ea
d(m
)
radius of deployment, Rf (m)
ours-only connecting mode
SODaR
 0
 5
 10
 15
 20
 25
 30
 500  1000  1500  2000  2500
co
m
m
u
n
ic
at
io
n 
ov
er
he
ad
radius of deployment, Rf (m)
ours-only connecting mode
SODaR
(c) (d)
Figure 3. Simulation results.
the simulation result on the communication overhead, where
our protocol is slightly increasing with the Rf increasing.
Note that the probability that the SODaR can work is
decreasing with the Rf increasing, so the communication
overhead in SODaR decreases when Rf is increasing.
5. Conclusion and Future Work
To prolong network lifetime, this paper adopts a hybrid
static-mobile WSN including resource-richer mobile data-
pumps and static sensors to conduct data collection, where
data-pumps have responsibility to help relay data from
nearby sensors to the sink. We propose a distributed mobile
data-pump relocation protocol to achieve the connectivity
and load balance among mobile data-pumps such that the
performance of data collection is improved. Without location
information about sensors and mobile data-pumps, we use
the connectivity among sensors as a clue to help relocation
mobile data-pumps by themselves. Simulation results show
that our protocol can provide prominent load balance among
mobile data-pumps Our future work will consider to relocate
data-pumps when sensors have different trafﬁc load such that
data-pumps’ load could be balanced.
Acknowledgments
Y.-C. Tseng’s research is co-sponsored by MoE ATU
Plan, by NSC grants 95-2221-E-009-058-MY3, 96-2218-E-
009-004, 96-2219-E-007-008, 97-3114-E-009-001, 97-2221-
E-009-142-MY3, and 97-2218-E-009-026, by MOEA under
grant 94-EC-17-A-04-S1-044, by ITRI, Taiwan, and by III,
Taiwan.
References
[1] A. Anandkumar, L. Tong, A. Swami, and A. Ephremides.
Minimum cost data aggregation with localized processing for
statistical inference. In Proc. IEEE INFOCOM, pages 780–
788, 2008.
附錄五： 
 
iMouse: An Integrated Mobile 
Surveillance and Wireless Sensor 
System 
 
 
 
 
 
Y.-C. Tseng, Y.-C. Wang, K.-Y. Cheng, and Y.-Y. Hsieh 
 
IEEE Computer, Vol. 40, No. 6, June 2007, pp. 60-66. (SCI, EI) 
so that one mobile sensor can efficiently visit each
cluster.
SYSTEM DESIGN
Figure 1 shows the iMouse architecture, which con-
sists of static and mobile sensors and an external server.
The static sensors form a WSN to monitor the environ-
ment and notify the server of unusual events. Each sta-
tic sensor comprises a sensing board and a mote for
communication. In our current prototype, the sensing
board can collect three types of data: light, sound, and
temperature. We assume that the sensors are in known
locations, which users can establish through manual set-
ting, GPS, or any localization schemes.1
An event occurs when the sensory input is higher or
lower than a predefined threshold. Sensors can com-
bine inputs to define a new event. For example, a sen-
sor can interpret a combination of light and
temperature readings as a potential fire emergency. To
detect an explosion, a sensor can use a combination
of temperature and sound readings. Or, for home 
security, it can use an unusual sound or light reading.
To conserve static sensors’ energy, event reporting is
reactive.
Mobile sensors can move to event locations, exchange
messages with other sensors, take snapshots of event
scenes, and transmit images to the server. As Figure 2
shows, each mobile sensor is equipped with a Stargate pro-
cessing board (www.xbow.com/Products/productsde-
tails.aspx?sid=229), which is connected to the following:
• a Lego car (http://mindstorms.lego.com/eng/
default.asp), to support mobility; 
• a mote, to communicate with the static sensors;
• a webcam, to take snapshots; and 
• an IEEE 802.11 WLAN card, to support high-speed,
long-distance communications, such as transmitting
images.
The Stargate controls the movement of the Lego car
and the webcam. 
The external server provides an interface through
which users can obtain the system status and issue com-
mands. It also maintains the network and interprets the
May 2007 77
(4) Move to emergency sites and take 
advanced actions (for example, take 
snapshots)
(1) 
Issu
e co
mm
and
s
to th
e ne
two
rk
(5) R
epor
t ana
lyze
d
data
 thro
ugh
 WL
AN
(3) Dispatch
(2) Report events
(2) Report events
Report
statuses
Issue
commands
Home/office
environment
Internet
Mobile sensors
Event
User
Wireless link
External server
Static sensor
A
F
G
E
D
C
B
I
H
Figure 1.The iMouse system architecture.Three main components make up the iMouse architecture: static sensors, mobile sensors,
and an external server.The user issues commands to the network through the server (1). Static sensors monitor the environment
and report events (2). When notified of an unusual event, the server notifies the user and dispatches mobile sensors (3), which
move to the emergency sites, collect data, (4) and report back to the server (5).
uct S  L = {(si, lj)|si S, lj L}. We set
the weight of (si, lj) to ei – emv  d(si, lj),
where ei is the current energy of si; emv
is the energy cost for a mobile sensor
to move by one unit; and d(si, lj) is the
distance from si’s current location to lj .
The solution is the maximum match-
ing P of G, which we can find through
traditional maximum-weight match-
ing solutions.2 Alternatively, we can
set our objective to minimizing mobile
sensors’ total moving distances. We
can also use maximum-matching to
achieve this by setting the weight of
(si, lj) to –emove  d(si, lj).
When m > n, some mobile sensors
must visit multiple sites. To solve this
problem, we divide emergency sites
into n clusters (for example, by the
classical K-means method) and assign
each group to one mobile sensor. In
this case, each mobile sensor’s cost
will include moving to the closest site
in each group and then traversing the
rest of the sites one by one. Given a
set of locations to be visited, we can
use a heuristic to the traveling sales-
man problem2 to determine the tra-
versal order.
IMPLEMENTATION AND 
EXPERIMENTAL RESULTS
Our static sensors are MICAz
motes (www.xbow.com/Products/
productdetails.aspx?sid=164). A
MICAz is a 2.4-GHz, IEEE 802.15.4-
compliant module allowing low-
power operations and offering a
250-Kbps data rate with a direct-
sequence spread-spectrum (DSSS)
radio.
The Stargate processing platform
consists of a 32-bit, 400-MHz Intel
PXA-255 XScale reduced-instruc-
tion-set computer (RISC) with a 64-
Mbyte main memory and 32-Mbyte
extended flash memory. It also has a
daughterboard with an RS-232 serial
port, a PCMCIA slot, a USB port,
and a 51-pin extension connector,
which can be attached to a mote. It
drives the webcam through a USB
port and the IEEE 802.11 WLAN
card through its PCMCIA slot. The
Stargate controls the Lego car via 
a USB port connected to a Lego
May 2007 79
Related Work in Wireless Surveillance
Traditional visual surveillance systems continuously videotape scenes to
capture transient or suspicious objects. Such systems typically need to
automatically interpret the scenes and understand or predict actions of
observed objects from the acquired videos. For example, Wu-chi Feng
and his colleagues proposed a video-based surveillance network in which
an 802.11 WLAN card transmits the information that each video camera
captures.1
Researchers in robotics have also discussed the surveillance issue.2
Robots or cameras installed on walls identify obstacles or humans in the
environment. These systems guide robots around these obstacles. Such
systems normally must extract meaningful information from massive
visual data, which requires significant computation or manpower.
Some researchers use static WSNs for object tracking.3,4 These systems
assume that objects can emit signals that sensors can track. However,
results reported from a WSN are typically brief and lack in-depth informa-
tion. Edoardo Ardizzone and his colleagues propose a video-based 
surveillance system for capturing intrusions by merging WSNs and video-
processing techniques.5 The system complements data from WSNs with
videos to capture the possible scenes with intruders. However, cameras 
in this system lack mobility, so they can only monitor some locations. 
Researchers have also proposed mobilizers to move sensors to en-
hance coverage of the sensing field6 and to strengthen the network 
connectivity.7 Other work addresses the pursuer-evader game, in which 
a pursuer must intercept an evader in the field with the assistance of
WSNs.8 To our knowledge, no one has adequately addressed the integra-
tion of WSNs with surveillance systems, which motivates us to propose
the iMouse system.
References
1. W.C. Feng et al., “Panoptes: Scalable Low-Power Video Sensor Networking
Technologies,” ACM Trans. Multimedia Computing, Comm., and Applications,
vol. 1, no. 2, 2005, pp. 151-167.
2. J.H. Lee and H. Hashimoto, “Controlling Mobile Robots in Distributed Intelli-
gent Sensor Network,” IEEE Trans. Industrial Electronics, vol. 50, no. 5, 2003,
pp. 890-902.
3. X. Ji et al., “Dynamic Cluster Structure for Object Detection and Tracking in
Wireless Ad-Hoc Sensor Networks,” Proc. IEEE Int’l Conf. Comm., IEEE Press,
2004, pp. 3807-3811.
4. W. Zhang and G. Cao, “DCTC: Dynamic Convoy Tree-Based Collaboration for
Target Tracking in Sensor Networks,” IEEE Trans. Wireless Comm., vol. 3, no. 5,
2004, pp. 1689-1701.
5. E. Ardizzone et al., “An Integrated Architecture for Surveillance and Monitoring
in an Archeological Site,” Proc. ACM Int’l Workshop Video Surveillance and Sensor
Networks, ACM Press, 2005, pp. 79-85.
6. N. Heo and P.K. Varshney, “Energy-Efficient Deployment of Intelligent Mobile
Sensor Networks,” IEEE Trans. Systems, Man and Cybernetics—Part A: Systems
and Humans, vol. 35, no. 1, 2005, pp. 78-92.
7. P. Basu and J. Redi, “Movement Control Algorithms for Realization of Fault-
Tolerant Ad Hoc Robot Networks,” IEEE Network, vol. 18, no. 4, 2004, pp. 36-44.
8. C. Sharp et al., “Design and Implementation of a Sensor Network System for
Vehicle Tracking and Autonomous Interception,” Proc. 2nd European Workshop
Wireless Sensor Networks, IEEE Press, 2005, pp. 93-107.
tree-maintenance message, adjusting the WSN’s topol-
ogy, and connecting and disconnecting a specified
mobile sensor.
• The sensor-status area shows the current status of a
static sensor being queried. 
• The action-control area lets users control the mobile
sensors’ actions, including movement and taking
snapshots.
• The monitor area shows the WSN’s network topology
and the mobile sensors’ patrolling paths. When a sen-
sor detects an event, a fire icon appears in the corre-
sponding site. 
• The log area displays some of the system’s status mes-
sages.
SIMULATION RESULTS
Our experiments considered only grid networks. To
help us understand the sensor dispatch problem in gen-
eral irregular WSNs, we developed a simulator. We eval-
uated the average waiting time for an event location
being visited and mobile sensors’ total energy con-
sumption. We compared a greedy algorithm against the
K-means algorithm. 
Given a set S of mobile sensors and a set L of emer-
gency sites, the greedy algorithm contains a sequence of
iterations. In each iteration, we assigned the mobile sen-
sor with the smallest distance to the nearest location.
We repeated this process until all mobile sensors were
assigned to locations. If there were unvisited locations,
the first mobile sensor reaching its destination picked its
next location in the same greedy manner. This continued
until all locations were visited. 
In our simulation, the sensing field was 15  15 meters.
We assumed that moving one meter takes one Joule and
10 seconds. A mobile sensor moves in a straight line
from one location to another. Each experiment had 100
rounds, and in each round a certain number of events
were generated at random locations. After each round,
mobile sensors stayed at their final destinations and
waited for the next schedules. We marked each simula-
tion result with a 90 percent confidence interval.
Our comparison results under different numbers of
event sites and mobile sensors showed that the greedy
algorithm performs better than the K-means algorithm
because of its time-critical nature. The K-means algorithm
gives mobile sensors unbalanced job assignments, caus-
May 2007 81
Figure 6. User interface at the external server.The interface consists of six areas through which the user can monitor the system’s
status and control the mobile sensors.
Action-control areaMonitor area Log area Sensor-status area
System-command area
Patrolling
path
Direction of the
mobile sensor
Configure area
Event
WSN Link
附錄六： 
 
Exploring Load-Balance to Dispatch 
Mobile Sensors in Wireless Sensor 
Networks 
 
 
 
 
 
Y.-C. Wang, W.-C. Peng, M.-H. Chang, and Y.-C. Tseng 
 
Int'l Conf. on Computer Communication and Networks (ICCCN), 2007. 
cost
a
b
c
d
a
0
85
40
50
b
85
0
50
55
c
40
50
0
85
d
50
55
85
0
a
b
c
d
s1
a
b
c
d
40
55
(a) the shortest paths and energy costs to reach event locations
a
b
c
d
12040
85 (fail)
s2
s1
s2
s1
s2
(b) minimizing the total moving energy in each round
a
b
c
d
50
50
a
b
c
d
after 8 rounds
(c) balancing the loads of s1 and s2 in each round
400
400
400
400
after 7 rounds
15
s1
s2
400
400
s1
s2
0
0
Fig. 1. Comparison of different dispatch methods.
locations is no larger than that of mobile sensors, we transform
the dispatch problem to a maximum-matching problem in
a weighted bipartite graph, where the vertex set contains
mobile sensors and event locations, and the edge set contains
the edges from each mobile sensor to each event location.
However, instead of finding the matching with a minimum
edge weight [3], we use a preference list and a bound to select
the matching. Specifically, the load-balance can be achieved
in that the preference list helps assign an event location with
a suitable mobile sensor, while the bound is to avoid selecting
edges with extreme weights. When event locations are more
than mobile sensors, we propose an efficient clustering scheme
to group locations into clusters, where the number of clusters
is the same as that of mobile sensors. In this way, we can adopt
the above matching approach to dispatch each mobile sensor
to a cluster of event locations. Then, mobile sensors can use
the traveling-salesman approximation algorithm [3] to reach
all event locations within clusters. Nevertheless, CentralSD
requires a server to collect information of mobile sensors
and events, which incurs a considerable amount of message
transmissions. To solve this problem, we develop an algorithm
GridSD (Grid-based architecture for Sensor Dispatching) to
dispatch mobile sensors in a distributed manner. In GridSD,
a grid structure is maintained and the loads of collecting
information and message exchanging are distributed into grids,
thereby reducing both message transmissions and computation
complexity.
A large amount of research [4]–[6] has elaborated on the
issue of using mobile sensors to enhance the sensing coverage
of a WSN. The authors in [7] consider how to move more
sensors close to the locations of events predicted, while
maintaining complete coverage of the sensing field. Assuming
that the object’s trajectory can be predicted and discusses how
to maneuver mobile sensors to acquire data from the object
in real-time, the authors in [8] use mobile sensors to track
a moving object. In [9], static sensors detecting events will
navigate nearby mobile sensors to move to their locations. The
mobile sensor with shorter moving distance and more energy
will be invited by the static sensors. In [10], static sensors
estimate the coverage holes close to them and use the hole
size to compete for mobile sensors. The mobile sensor will
select the largest one and move to fill the hole. Prior works
mainly utilize mobile sensors for coverage holes and object
tracking, but not to the general dispatch problem formulated
in this paper, let alone exploring load-balancing in dispatching
mobile sensors and developing two algorithms to deal with the
general dispatch problem. These features distinguish this paper
from others.
II. THE SENSOR DISPATCH PROBLEM
In this paper, a hybrid WSN consisting of static and mobile
sensors is considered. Static sensors form a connected network
and fully cover the area of interest to continuously monitor
the environment. When events are detected, there is a set of n
mobile sensors S = {s1, s2, . . . , sn} to be dispatched to the
event locations (as reported by static sensors) to provide higher
quality of sensing results. By existing localization techniques
[11], sensors are aware of their locations.
The problem of dispatching mobile sensors is modeled as
follows. We consider that there is a set of event locations
L = {l1, l2, . . . , lm}, each to be visited by a mobile sensor.
We allow an arbitrary relationship of m and n. The goal
is to determine a dispatch schedule Φi for each mobile
sensor si such that each location in L is visited exactly
once by one mobile sensor. Each schedule Φi is denoted by
a sequence of event locations, and the jth location to be
visited is written as Φi[j]. Let ei be si’s energy and c(Φi)
be the energy required to complete si’s schedule, c(Φi) =
Δmove × (d(si,Φi[1]) +
∑|Φi|−1
j=1 d(Φi[j],Φi[j + 1])), where
Δmove is the energy required to move a sensor one-unit
distance, d(si,Φi[1]) is the distance from si’s current position
to Φi[1], and d(Φi[j],Φi[j +1]) is the distance between Φi[j]
and Φi[j + 1]. Clearly, a schedule of a mobile sensor should
satisfy ei ≥ c(Φi).
For performance reason, the objective function of the dis-
patch problem is to minimize the total energy cost incurred
by movements, i.e., min
∑
si∈S c(Φi). To balance the energy
consumption of mobile sensors, we should also attempt to
reduce the standard deviations of energy consumption among
mobile sensors.
Note that the above modeling is only concerned about one
round of sensors’ dispatch schedules. In general, multiple
rounds of dispatch schedules need to be determined, where
each round contains those events being detected over a fixed
amount of time, and the goal is to extend mobile sensors’
lifetimes to the maximum number of rounds. The length of
a round depends on users’ real-time constraint. Since event
locations are unexpected, we only focus on the optimization
of one round in this paper.
III. MOBILE SENSOR DISPATCHING ALGORITHMS
We first propose a centralized solution, where there is a
central server that collects the sets L and S and computes
sensors’ schedules. Then, a distributed solution is developed.
2) Case of |S| < |L|: When the number of event locations
is larger than that of mobile sensors, we can group those
event locations whose distance are close to each other into a
cluster. This can be achieved by K-means [12]. Consequently,
by the previous matching scheme, each mobile sensor can be
dispatched to one cluster and then travels the event locations
within the assigned cluster. To facilitate the presentation of
this paper, we briefly describe how K-means works. In K-
means, event locations are randomly partitioned into n non-
empty clusters. For each cluster, we determine the mean from
the event locations assigned to the same cluster. Then, each
event location should join the cluster whose mean is the closest
one to it. After all event locations decide their corresponding
clusters, we should re-calculate the mean for each cluster. The
above procedure is repeated until no event relocation is needed.
To evaluate the energy cost of the clustering result, the cost
φ(cˆk) of each cluster cˆk is formulated as the total edge weight
of the minimum spanning tree in that cluster, where the weight
of an edge (li, lj) is the distance between two event locations
li and lj . For example, in Fig. 3(a), φ(A) = 50, φ(B) = 12,
φ(C) = 15, and φ(D) = 68. Unfortunately, K-means may not
minimize the total cost of the clusters derived, especially when
some “sparse” event locations are far away from others. In this
case, K-means groups these sparse locations into the same
cluster, thereby increasing the total cost of clusters. Consider
an example in Fig. 3(a), where four clusters are determined by
K-means. Since both clusters A and D consist of sparse event
locations (i.e., l1 and l10), the total cost of clusters is thus
increased. By properly splitting and merging some clusters,
the result of K-means is adjusted to reduce the total cost
of clusters. Intuitively, those clusters containing sparse event
locations should be split. However, in order not to change
the number of clusters, we should merge two clusters when
splitting a large one. In particular, let wintramax be the maximum
edge weight among edges in all clusters and wintermin be the
minimum inter-cluster distance, where the distance between
two clusters cˆa and cˆb is the distance of the two closest
locations li ∈ cˆa and lj ∈ cˆb. If wintramax > wintermin , we can split
the cluster with the edge whose weight is wintramax (by removing
that edge) and then merge two clusters whose distance is wintermin
(by connecting them with the shortest edge). We can repeat
the above procedure until wintramax ≤ wintermin . In this way, we
can avoid scenarios that some clusters have too large costs,
thus reducing the total cost of clusters. Fig. 3 illustrates an
example. In Fig. 3(a), wintramax is 50 (in cluster D) and wintermin is
15 (between clusters A and B). We thus split cluster D into
two clusters D1 and D2, and then merge clusters A and B
into the same one, as shown in Fig. 3(b). Similarly, we can
further split cluster A and then merge clusters C and D1 to
reduce the total cost of clusters. The final result is shown in
Fig. 3(c).
After grouping event locations into n clusters Cˆ = {cˆ1, cˆ2,
. . . , cˆn}, we can use the matching scheme to dispatch mobile
sensors to these clusters. To assign edge weights of the graph
G = (S ∪ Cˆ, S × Cˆ), the energy cost is re-formulated as
c(si, cˆk) = Δmove × (d(si, lj) + φ(cˆk)), ∀si ∈ S and cˆk ∈ Cˆ,
40
10
15
12
20
15
50
18
cluster A
cluster B
cluster C
cluster D
50
40
10
15
12
15
18
cluster A
cluster D2
cluster C
cluster D1
10
15
20
15
18
cluster A1
cluster A2
cluster C
12
(a) total cost: 145
(b) total cost: 110 (c) total cost: 90
50 20 50
40
50
l1
l2
l3
l4
l5
l6
l7
l8
l9
l10
l1
l2
l3
l4
l5
l6
l7
l8
l9
l1
l2
l3
l4
l5
l6
l7
l8
l9
l10
cluster D2
50
l10
Fig. 3. An example to cluster event locations.
where lj ∈ cˆk is the closest event location to si. Specifically,
the total energy consumption for si to visit cˆk includes the
energy to move to the closest event location lj in cˆk and the
energy to reach all event locations in cˆk. When si is dispatched
to a cluster cˆk, it first moves to the closest event location lj in
cˆk and then exploits the solution of traveling salesman problem
[3] to reach other event locations with a minimum cost.
B. GridSD: A Distributed Dispatch Algorithm
Note that CentralSD needs a central server to collect the
information of mobile sensors and events, which results in a
large amount of message transmissions. In this section, we
propose a distributed algorithm GridSD that explores a grid-
based architecture to reduce the messages incurred.
As shown in Fig. 4, GridSD divides the sensing field into
grids. For each grid, we select a grid head to collect the
information of mobile sensors and event locations within its
territory. Specifically, each mobile sensor informs its location
and remaining energy to its corresponding grid head. When
detecting events, static sensors report to their grid heads. On
obtaining such information, a grid head performs CentralSD
to dispatch mobile sensors to the events occurred in its grid.
However, if there is no mobile sensor in the grid, the grid head
will search available mobile sensors in other grids.
To reduce the number of message transmissions when a grid
head searches for mobile sensors in other grids, we propose a
modified approach of the grid-quorum [5]. Specifically, each
grid head sends advertisement (ADV) messages containing the
number of mobile sensors in its grid to the same column of
grids. In this way, each grid head has the information of mobile
sensors in other grids located in the same column. When a grid
head wants to search mobile sensors in other grids, it sends
a request (REQ) message to the grid head in the same row.
Due to the grid structure, there must be a grid head receiving
both ADV and REQ messages. Consider an example in Fig. 4,
deviation compared with CentralSD since each grid head only
has partial information of mobile sensors.
10
20
30
40
50
60
5 10 15 20 25 30 35 40
ratio of event locations to static sensors (%)
a
v
e
ra
g
e
e
n
e
rg
y
c
o
n
s
u
m
p
ti
o
n
(J
)
CentralSD
GridSD
iterative optimization
0
5
10
15
20
25
30
5 10 15 20 25 30 35 40
ratio of event locations to static sensors (%)
s
ta
n
d
a
rd
d
e
v
ia
ti
o
n
o
f
e
n
e
rg
y
c
o
n
s
u
m
p
ti
o
n
(J
)
CentralSD
GridSD
iterative optimalization
(a) average energy consumption
(b) standard deviation of energy consumption
Fig. 6. Comparisons on energy consumption.
Although CentralSD outperforms GridSD in terms of sys-
tem lifetime, it incurs a large amount of message transmis-
sions. Fig. 7 shows the number of packet delivery of CentralSD
and GridSD. We can observe that the number of message
transmissions in CentralSD grows fast as the event locations
increase, while that in GridSD remains constant since the loads
of message exchange are distributed among grid heads.
0
500
1000
1500
2000
2500
3000
3500
5 10 15 20 25 30 35 40
ratio of event locations to static sensors (%)
n
u
m
b
e
r
o
f
p
a
c
k
e
t
d
e
liv
e
ry
CentralSD
GridSD
Fig. 7. Comparison on number of packet delivery.
When the number of event locations are larger than that
of mobile sensors, we group event locations into clusters and
dispatch mobile sensors to each cluster. Fig. 8 shows the effect
of our clustering scheme on the energy consumption. As can
be seen in Fig. 8, when the clustering scheme is adopted,
mobile sensors can have a lower energy consumption because
they do not need to travel around event locations far from each
other.
V. CONCLUSIONS
In this paper, a general problem of dispatching mobile
sensors is formulated. By exploring the concept of load
balance, we proposed CentralSD to efficiently dispatch mobile
sensors. A clustering scheme is developed to group event
50
100
150
200
250
300
1.2 1.5 1.8 2.4 2.7 3.0
ratio of event locations to mobile sensors
a
v
e
ra
g
e
e
n
e
rg
y
c
o
n
s
u
m
p
ti
o
n
(J
)
with clustering
without clustering
Fig. 8. The effect of clustering on energy consumption.
locations when the number of events is larger than that of
mobile sensors. To reduce message transmissions, we proposed
a distributed algorithm GridSD. Simulation results show that
the proposed algorithms can have a longer system lifetime
compared with the iteratively-optimized algorithm.
ACKNOWLEDGEMENT
Y. C. Tseng’s research is co-sponsored by Taiwan MoE ATU
Program, by NSC grants 93-2752-E-007-001-PAE, 96-2623-7-
009-002-ET, 95-2221-E-009-058-MY3, 95-2221-E-009-060-
MY3, 95-2219-E-009-007, 95-2218-E-009-209, and 94-2219-
E-007-009, by Realtek Semiconductor Corp., by MOEA under
grant number 94-EC-17-A-04-S1-044, by ITRI, Taiwan, by
Microsoft Corp., and by Intel Corp.
W. C. Peng is supported in part by Taiwan MoE ATU
Program and by the National Science Council, Project No.
NSC 95-2211-E-009-61-MY3 and NSC 95-2221-E-009-026,
Taiwan, Republic of China.
REFERENCES
[1] D. Johnson, T. Stack, R. Fish, D. M. Flickinger, L. Stoller, R. Ricci,
and J. Lepreau, “Mobile Emulab: a robotic wireless and sensor network
testbed,” in IEEE INFOCOM, 2006.
[2] Y. C. Tseng, Y. C. Wang, and K. Y. Cheng, “An integrated mobile
surveillance and wireless sensor (iMouse) system and its detection delay
analysis,” in ACM Int’l Symp. on Modeling, Analysis and Simulation of
Wireless and Mobile Systems, 2005, pp. 178–181.
[3] J. R. Evans and E. Minieka, Optimization Algorithms for Networks and
Graphs, 2nd ed. Marcel Dekker Inc., 1992.
[4] N. Heo and P. K. Varshney, “Energy-efficient deployment of intelligent
mobile sensor networks,” IEEE Trans. on Syst., Man and Cybern. A,
vol. 35, no. 1, pp. 78–92, 2005.
[5] G. Wang, G. Cao, T. L. Porta, and W. Zhang, “Sensor relocation in
mobile sensor networks,” in IEEE INFOCOM, 2005, pp. 2302–2312.
[6] Y. Zou and K. Chakrabarty, “Sensor deployment and target localization
based on virtual forces,” in IEEE INFOCOM, 2003, pp. 1293–1303.
[7] Z. Butler and D. Rus, “Event-based motion control for mobile-sensor
networks,” IEEE Pervasive Computing, vol. 2, no. 4, pp. 34–42, 2003.
[8] M. D. Naish, E. A. Croft, and B. Benhabib, “Dynamic dispatching
of coordinated sensors,” in IEEE Int’l Conf. on Systems, Man, and
Cybernetics, 2000, pp. 3318–3323.
[9] A. Verma, H. Sawant, and J. Tan, “Selection and navigation of mobile
sensor nodes using a sensor network,” in IEEE Int’l Conf. on Pervasive
Computing and Communications, 2005, pp. 41–50.
[10] G. Wang, G. Cao, and T. L. Porta, “A bidding protocol for deploying
mobile sensors,” in IEEE Int’l Conf. on Network Protocols, 2003, pp.
315–324.
[11] N. Bulusu, J. Heidemann, and D. Estrin, “GPS-less low-cost outdoor
localization for very small devices,” IEEE Personal Commun. Mag.,
vol. 7, no. 5, pp. 28–34, 2000.
[12] J. Han and M. Kamber, Data Mining: Concepts and Techniques, D. D.
Cerra, Ed. Academic Press, 2001.
Mobility Management Algorithms and Applications for Mobile
Sensor Networks
You-Chiun Wang, Fang-Jing Wu, and Yu-Chee Tseng
Department of Computer Science, National Chiao-Tung University, Hsin-Chu, 30010, Taiwan
Email: {wangyc, fangjing, yctseng}@cs.nctu.edu.tw
Abstract
Wireless sensor networks (WSNs) offer a convenient way to monitor physical environments. In the past, WSNs are
all considered static to continuously collect information from the environment. Today, by introducing intentional
mobility to WSNs, we can further improve the network capability on many aspects, such as automatic node
deployment, ﬂexible topology adjustment, and rapid event reaction. In this article, we survey recent progress in
mobile WSNs and compare works in this ﬁeld in terms of their models and mobility management methodologies.
The discussion includes three aspects. Firstly, we discuss mobility management of mobile sensors for the purposes
of forming a better WSN, enhancing network coverage and connectivity, and relocating some sensors. Secondly,
we introduce path-planning methods for data ferries to relay data between isolated sensors and to extend a WSN’s
lifetime. Finally, we review some existing platforms and discuss several interesting applications of mobile WSNs.
KEY WORDS: mobility management, path planning, sensor applications, topology adjustment, wireless sensor
networks.
1. Introduction
The development of wireless technologies and micro-
sensing MEMS has triggered the success of wireless
sensor networks (WSNs). A WSN is composed of
one or multiple remote sinks and many tiny, low-
power sensors, each equipped with actuators, sensing
devices, and wireless transceivers [1]. These sensors
are massively deployed in a region of interest (ROI)
to continuously collect and report surrounding data.
WSNs offer a convenient way to monitor physical
environments. Many applications such as object
tracking, health monitoring, security surveillance,
and intelligent transportation [2, 3, 4, 5] have been
proposed.
A WSN is usually deployed with static sensors
to perform monitoring missions. However, due to
the dynamics of events or environments, a purely
static WSN could face these challenges: (1) Sensors
are often scattered in a ROI by aircrafts or robots
[6]. These randomly scattered sensors could not
guarantee complete coverage of the ROI and may
be partitioned into disconnected subnetworks. The
existence of obstacles could even worsen the problem.
(2) Sensors are usually powered by batteries. As
some sensors exhaust their energy, holes could appear
and the network could be broken. However, in many
scenarios, it is quite difﬁcult to recharge sensors or
redeploy nodes. (3) A WSN may need to support
multiple missions or have multiple types of sensors
[7]. Sometimes, we may need to send a certain type
of sensors to particular locations to support particular
needs. Without mobility, this is difﬁcult to achieve.
(4) While most efforts assume that sensors are cheap,
some types of sensors may be expensive. Dispatching
of those expensive ones from locations to locations
may be necessary.
1
Fig. 1(b) shows an example, where s2, s3, and s4 all
exert repulsive forces on s1.
In the above two methods, oscillation check and
stability check are performed to examine whether a
sensor has reached its ﬁnal destination. When a sensor
si moves back and forth inside a small region many
times, it has entered the oscillation state. On the other
hand, when si moves less than a threshold distance in
a ﬁxed duration, it has entered the stable state. In both
cases, si will stop moving.
Reference [12] considers that sensors work under
a probability sensing model. The goal is to deploy a
minimum number of sensors such that the detection
probability of the ROI is above a predeﬁned threshold.
To achieve this, we can ﬁrst deploy sufﬁcient sensors
to satisfy the detection probability. Then, sensors can
exert repulsive forces on each other. In this way, the
number of sensors may be reduced since some sensors
may be pushed outside the ROI.
2.1.2. Graph-Based Deployment
The work [13] adopts a Voronoi diagram to search
uncovered holes and moves sensors to cover these
holes. Given a set of sensors on a 2D plane, the
Voronoi diagram [14] consists of a number of Voronoi
polygons such that each polygon contains one sensor
and the points in the polygon are closer to the interior
sensor than to other exterior sensors. When the sensing
range of a sensor cannot completely cover its Voronoi
polygon, there could be an uncovered hole in that
polygon. In [13], it proposes the following methods
to cover this hole:
Voronoi-based (VOR) method: A sensor should
move toward the farthest vertex of its current polygon.
Fig. 2(b) gives an example, where the dotted polygon
is sensor si’s current polygon and u is the farthest
vertex. Sensor si will move along the direction−→siu and
stop at v1, where |uv1| = rs.
Minimax method: A sensor should move to the
minimax point of its current polygon, where the
minimax point of a polygon is the center of the circle
with the minimum radius that can cover the whole
polygon (refer to [13] for details about ﬁnding the
circle). Fig. 2(c) gives an example, where v2 is the
minimax point of si’s current polygon.
2.1.3. Assignment-Based Deployment
Reference [15] focuses on deployment in ROIs with
obstacles. It considers two related problems: sensor
placement and sensor dispatch. The former asks how
u
v1
rs
(b) VOR method
v2
(c) Minimax method
(a) a Voroni diagram
si si
Voronoi
polygon
sensor
Voronoi
polygon
farthest
vertex
minimax point
Fig. 2. The VOR and Minimax methods.
to use the minimum number of sensors in a ROI to
guarantee coverage and connectivity. The latter asks
how to dispatch mobile sensors to the designated
locations computed by the placement result such that
their moving energy is minimized.
To solve the placement problem, [15] partitions
a ROI A into single-row and multi-row regions. A
single-row region requires one row of sensors to
cover it, and a multi-row region requires multiple
rows of sensors to cover it. To partition A, we ﬁrst
identify all single-row regions, which is achieved
by expanding A’s boundaries inward and obstacles’
perimeters outward by a distance of
√
3rmin, where
rmin = min{rc, rs}. When the expanded line cuts off
an obstacle with an area, we take a project from that
area to identify a single-row region. Fig. 3(a) gives an
example, where 5 single-row regions (with numbers)
are identiﬁed. Other regions will be multi-row ones.
Then, we place sensors in each region as follows:
Single-row region: We place a sequence of sensors
along the region’s bisector, each separated by a
distance of rmin. Fig. 3(b) gives an example.
Multi-row region: Two cases are considered, as
Fig. 3(c) shows. When rc ≥
√
3rs, adjacent sensors
are regularly separated by a distance of
√
3rs. When
rc <
√
3rs, sensors in each row are separated by a
distance of rc. Adjacent rows are separated by a
distance of rs +
√
r2s − r
2
c
4 and shifted by a distance
of rc2 . To connect adjacent rows, we add a column of
sensors between them, each separated by a distance
not larger than rc.
3
that select lj as their destinations and their distances
djβ to lj . Initially, OCCi[j] = ∅,∀j. Then, si selects
the nearest location lj such that |OCCi[j]| < nj as
its destination, adds (si, d(si, lj)) in OCCi[j], and
moves to lj .
2. Sensor si periodically updates and exchanges
its table with one-hop neighbors. When si hears the
OCCk table from a neighbor sk, si combines OCCi
with OCCk as follows: For each j, we calculate a
union Uj = OCCi[j] ∪OCCk[j]. If |Uj | > nj , we
remove the records in Uj that have longer moving
distances, until |Uj | = nj . Then, we replace OCCi[j]
by Uj . If si was in the original OCCi[j] entry, but
is not in the new OCCi[j] entry, it means that si is
replaced by other sensors with a shorter distance to lj .
Thus, si should reselect another destination.
3. After si reaches lj , it still exchanges its table with
neighbors. Since the sink will eventually observe that
all locations are covered, it can notify all sensors to
exit from the dispatch method.
2.2. Solutions to Enhancing Coverage and
Connectivity of a WSN
After deploying a WSN, some sensors may be broken
or may exhaust their energy. These failed sensors
may disconnect the network or cause uncovered
holes. One can move some mobile sensors to relieve
this problem. We introduce two such solutions for
enhancing connectivity and coverage of a WSN.
2.2.1. Connectivity Enhancement
Reference [18] considers a static WSN with several
isolated groups, called islands. To help these islands
communicate with each other, we can add some
mobile sensors between them. For two islands IG and
IH , the minimum number of mobile sensors required
to connect them is MG,H =
⌈
dG,H
rc
− 1
⌉
, where
dG,H = min
si∈IG,sj∈IH
{di,j} is the shortest distance
between IG and IH . Let N(IG) be the number
of sensors in island IG and W (IG,m) be the
optimal set of islands that can be connected by
m mobile sensors starting from island IG. It can
be derived that W (IG,m) = max{W (IG ∪ IH ,m−
MG,H) + N(IG ∪ IH)}, where IH is an island to
be directly connected by IG and N(IG ∪ IH) =
N(IG) + N(IH) + MG,H . However, for an island IG,
if the remaining m mobile sensors cannot connect
to any other island, we set W (IG,m) = 0. Using
dynamic programming, the minimum m to connect all
islands can be found.
The work [19] considers strengthening the topology
of a WSN to be biconnected. First, each cut-vertex
is identiﬁed. For example, in Fig. 5(a), c1 and c2 are
cut-vertices. By removing cut-vertices, the network is
divided into several biconnected components (called
blocks). Actually, we can ‘pull’ two neighboring
blocks together to eliminate the cut-vertex between
them. With this observation, a block movement method
is proposed as follows: Given a network topology, we
ﬁrst identify all blocks along with their cut-vertices. A
block can have zero, one, or multiple sensors. If two
cut-vertices are directly connected, an empty block is
established. Then, we can translate the network into
a block tree, whose nodes contain blocks and cut-
vertices. The block with the maximum number of
sensors is the root. In Fig. 5(a), there are 5 blocks
(including the empty block B4) and 2 cut-vertices c1
and c2. Block B1 is the root and blocks B2, B3, and
B5 are leaves. The method executes in two iterations
until the network becomes biconnected: (1) Move each
leaf block toward the nearest sensor of its parent block,
until a new edge appears. (2) If its parent block is
empty, we further move it to the upstream cut-vertex of
its parent block. Fig. 5(a) gives an example, where B5
moves toward v of its parent block B1, and B2 and B3
move toward the cut-vertex c1 since their parent block
B4 is empty. The ﬁnal topology is shown in Fig. 5(b).
v
(a) initial network topology (b) final network topology
B1
B5
B3
B2
B4
c1 c2
root
Fig. 5. An example of the block movement method.
2.2.2. Coverage Enhancement
The work [20] proposes a bidding protocol to enhance
the coverage of a hybrid WSN composed of static and
mobile sensors. Static sensors detect uncovered holes
locally and bid for mobile sensors by the sizes of holes.
It involves the following steps:
1. Each mobile sensor is assigned with a base price,
which is an estimation of the hole size when it leaves
its current position. Initially, the base price is zero
for all mobile sensors. Then, mobile sensors broadcast
their positions and base prices in their local areas.
5
C1
ADV
navigation field
si
mjADV
ADV
C2
C2
C2
C3
C3
C3
C4
Fig. 7. Navigate a mobile sensor by credits, where C1 >
C2 > C3 > C4.
we ﬁrst calculate the energy cost w(si, lj) = em ×
d(si, lj) for each sensor si ∈ S to reach each location
lj ∈ L, where em is the energy cost to move a sensor
in one step. The scheme tries to ﬁnd a matching M
between sensors and locations by allowing a boundBj
for each lj ∈ L as follows:
1. For each lj ∈ L, we use a bound Bj to limit the
candidate sensors that lj can match with. A sensor
si is said as lj’s candidate if w(si, lj) ≤ Bj . Since
a larger bound may lead a sensor to select a farther
location, Bj will be increased gradually. Initially, each
Bj = 1|L|
∑|L|
j=1 min∀i,(si,lj)∈S×L
{w(si, lj)}.
2. For each unmatched lj ∈ L, we ﬁnd a candidate
sensor si with the minimum w(si, lj) to match with.
If si is still unmatched, we add the pair (si, lj) in
M. Otherwise, si must be matched with another
location lo. In this case, lj will compete with lo
for si by three rules: (1) If Bj > Bo, we match si
with lj to avoid expanding Bj . (2) If Bj = Bo and
w(si, lj) < w(si, lo), we match si with lj to reduce
its energy consumption. (3) If Bj = Bo and si is the
only candidate of lj but is not that of lo, we match
si with lj . When lj wins the competition, the pair
(si, lo) is replaced by the new pair (si, lj) in M, and
lo becomes unmatched. Otherwise, lj checks other
candidate sensors, until there is no candidate.
3. If lj cannot ﬁnd any match, we increase Bj by
ΔB and go to step 2, until a match is found.
4. We repeat steps 2 and 3, until each lj ∈ L can
ﬁnd a sensor to match with.
Fig. 8 gives an example, where ΔB = 70. The
initial bound is 79+97+943 = 90. In Fig. 8(b), l1
matches with s2 with bound B1 = 90 and l2 matches
with s4 with bound B2 = 90 + 70 = 160. Then, after
expanding B3, l3 ﬁnds that its candidate s4 has been
matched with l2, so it competes with l2 for s4.
Since B3 = B2 and w(s4, l3) < w(s4, l2), (s4, l2) is
replaced by (s4, l3) in Fig. 8(c). Similarly, l2 obtains
s2 from l1 in Fig. 8(d) and thus l1 selects an unmatched
sensor s1. Fig. 8(e) shows the ﬁnal result.
(a) energy costs of mobile sensors
(b) M = {(s2, l1), (s4, l2)} (c) M = {(s2, l1), (s4, l3)}
(d) M = {(s2, l2), (s4, l3)} (e) M = {(s1, l1), (s2, l2), (s4, l3)}
cost
l2
l1
l3
s4
97
147
94
s3
153
238
177
s2
133
79
233
s1
219
105
181
l2
s3
s1
l3
s2
s4l1
B3(160)
l2
s3
s1
l1
l3
s2
s4
B2 (160)
l2
s3
s1
l1
l3
s2
s4
B1(160)
(90)
l2
s3
s1
l1
l3
s2
s4
B1
B2(160)
Fig. 8. An example of ﬁnding the matchingM.
When |S| < |L|, a clustering approach is proposed
and then the similar matching steps are executed (we
omit the details).
Reference [25] considers a mobile WSN as a multi-
robot system and addresses the cooperation among
robots. Each robot is regarded as a resource and
may be required by multiple concurrent missions.
It points out that deadlock may happen when some
missions never ﬁnish executing and resources are tied
up, preventing other missions from starting. Then, a
deadlock avoidance policy based on the Petri nets is
proposed.
2.4. Summary of Mobility Management
Table I summarizes the mobility management methods
for mobile sensors. While most methods consider a
purely mobile WSN, [18, 20, 23, 24, 25] consider
a hybrid WSN. References [18, 20] use mobile
sensors to improve the topology of a static WSN,
and [23, 24] use static sensors to detect events and
send mobile sensors to event locations. For sensors’
detection, [10, 12, 15, 17] consider the probabilistic
sensing model. For coverage and connectivity, most
deployment methods [10, 11, 13, 15, 17] address both
issues, but the work [12] addresses only the coverage
issue. References [20, 21, 22] move sensors to improve
a WSN’s coverage, while references [18, 19] move
sensors to improve the network connectivity. For
7
into 4 segments ξ1, ξ2, ξ3, and ξ4. Φp(·, ξ1) = 0 since
F cannot communicate with any sensor. Φp(s2, ξ2) =
Φp(s1, ξ4) = 1 since F can only communicate with
one sensor. Φp(s2, ξ3) = Φp(s1, ξ3) = 12 since F
should share its time to s1 and s2.
4. To meet the bandwidth requirement of each si,
F should spend sufﬁcient time to communicate with
si. If there is no sufﬁcient time, the segments for si
should be extended properly. For example, in Fig. 9(a),
segment ξ2 may be extended to the dotted curve to
increase the communication time with s2. Let xj be
the extra communication time of F to extend ξj and
ti be the original communication time of F for si.
A linear programming is formulated to minimize the
total extra communication time of F :
min
m∑
j=1
xj ,
subject to
(ti +
∑m
j=1 Φp(si, ξj)xj) ·R
|p|
v +
∑m
j=1 xj
≥ bi, (1)
where R is F’s data rate and bi is the bandwidth
requirement of si. Here, the numerator and denomi-
nator are the expected amount of data that can be sent
and received by si and the total moving time ofF after
extension, respectively. The path p after extension is
F’s traveling path.
The work [27] further considers multiple data
ferries. Given n sensors and m data ferries, the goal is
to ﬁnd a set of paths for data ferries to visit all sensors
such that the average message delay is minimized and
the bandwidth requirement of each sensor is met. Four
types of solutions are proposed.
Single-route algorithm (SIRA): All data ferries
will move along the same path and there is no
communication between them. Fig. 9(a) gives an
example with two ferries. This algorithm directly
extends that of [26]. For any path p, the delay to deliver
data from si to sj on p is T
p
ij =
|p|
2mv +
dpij
v . So, the
average delay of p is T p =
∑
1≤i,j≤n wijT
p
ij∑
1≤i,j≤n wij
, where
wij is the weight assigned to each T
p
ij . Still, edge
replacement and sequence reordering are applied to
improve p. Finally, the linear programming in Eq. (1)
can be rewritten as:
min
n∑
i=1
yi,
subject to R · (2rc + yi)|p|+∑nj=1 yj
≥ bi
m
, (2)
F data ferry sensorpath of a data ferry
F
F
contact point
G4
F F
F
F
cr F
F
1s
2s1ȟ 2ȟ
3ȟ
4ȟ
v
u
relaying
sensor
G3
G1 G2
F
F
extending
path
Fig. 9. Path-planning examples for data ferries.
where yi is the extra moving length of data ferries
in the communication range of si. In Eq. (2), the
left-hand term is the product of data ferries’ data
rate and the ratio of data ferries’ communication time
allocated to si, and the right-hand term means that si’s
bandwidth requirement bi is shared by m data ferries.
Multi-route algorithm (MURA): Each data ferry
will move along a different path and there is no
communication between them. Fig. 9(b) gives an
example. In this algorithm, given a set of paths P ,
we use a 2-tuple (E1(P), E2(P)) as the cost function
to evaluate the quality of P , where E1(P) is the
estimated total overload of data ferries in P and
E2(P) is the estimated total message delay incurred
by P (refer to [27] for details). Intuitively, overload
is the amount of data that newly appear and cannot be
delivered over a time interval. Initially, we assume that
each sensor has a ferry. Let P be the current path set
and ni be number of ferries in pi ∈ P . We adopt four
operations to reduce the number of ferries and to reﬁne
the path set P: (1) overlap(pi, pj): We extend path
pj ∈ P by including one sensor in path pi ∈ P , pi 
=
pj such that the cost is minimized. (2) merge(pi, pj):
We combine pi and pj into one new path, and put all
ni + nj ferries on the new path. (3) merge−(pi, pj):
This is the same as merge(pi, pj), except that we
decrease the number of ferries by one. (4) reduce(pi):
We decrease ni by one for pi if ni > 1. We iteratively
select one operation in a greedy manner to minimize
the cost, until there are only m paths. After obtaining
m paths, we can apply SIRA to optimize each path.
9
subject to
∀sj ,
∑
li∈L′
h(ci, ti, sj) + max
li∈L′
{g(ci, sj)} ≥ τ, (4)
In Eq. (3), O is the ROI’s center, d(li, O) is the
distance between li and O, and β is a constant to
measure the quality of the path yet to be constructed
for F . In Eq. (4), maxli∈L′{g(ci, sj)} is an estimation
of the meeting probability between F and sj .
3. After calculating L′ and the staying time ti
for each li ∈ L′, we then adopt any TSP solution to
construct a path to visit all way-points in L′.
3.2. Solutions to Prolonging a WSN’s Lifetime
by Data Ferries
The previous section mainly focuses on using
data ferries to relay data between isolated sensors.
Nevertheless, with richer energy, data ferries can also
help prolong the lifetime of a connected WSN. It
is widely known that sensors nearby the sink could
exhaust their energy faster. By scheduling data ferries
to collect data from sensors, the energy consumption
of sensors can be balanced and thus the network
lifetime can be prolonged. We will introduce four
path-planning solutions for data ferries in a connected
WSN: The recursive planning uses a divide-and-
conquer scheme to plan a ferry’s path. The tree-
based planning uses a tree structure to plan ferries’
paths. The single-hop collection allows a ferry to
directly contact each sensor. While the above solutions
are centralized, the distributed navigation considers
guiding data ferries by sensors in a distributed manner.
3.2.1. Recursive Planning
Given a set of sensors S and a data ferry F , [30]
considers planning F’s path to visit some sensors
in S such that the F’s moving distance (or time)
can be bounded by a pre-deﬁned threshold, and the
network lifetime is maximized. Suppose that F will
move from a location la = (xa, ya) to another location
lb = (xb, yb). The idea is to recursively pick a turning
point between la and lb, until we can ﬁnd a path
la → l1 → · · · → lm → lb such that the distance (or
time) bounded can be meet, and the network lifetime
is maximized when F moves along the path, where
l1, l2, · · · , lm are the turning points. A divide-and-
conquer scheme is proposed as follows:
1. Given two locations la and lb, we select a set of
possible turning points such that each point locates
at (xa+xb2 , kΔy), where k is an integer and Δy is a
constant such that every turning point will be inside
the ROI. Among these turning points, we select the
point lv and construct a path la → lv → lb such that
the network lifetime can be maximized whenF moves
along that path (refer to [30] for the details about
calculating the network lifetime). Fig. 12(a) gives an
example, where there are 4 turning point and a path
la → lv2 → lb is constructed.
2. We divide sensors into two groups according
to their distances to the line segments la → lv and
lv → lb (a sensor will favor the closer line segment).
For example, in Fig. 12(b), sensors s1, s2, and s3 are
in one group, while s4 and s5 are in another group.
3. For each cluster of sensors, we recursively
execute the above two steps, until the distance (or
time) bounded is reached. Fig. 12(c) shows the ﬁnal
result, where there are two iterations.
(a) iteration 1: select one turning point
ǻy
1
v
l
ǻy
ǻy
2
v
l
3
v
l
4
v
l
(c) result of iteration 2
(b) iteration 1: clustering
turning point
sensor
a
l
b
l
ǻy
ǻy
ǻy
2
v
l
sensor
a
l
b
l1s
2s
3s
4s 5s
ǻy
ǻy
ǻy al bl
F
cluster1 cluster2 cluster3 cluster4
ǻy),
2
xx( ba 
ǻy)-,
2
xx( ba 
Fig. 12. An example of the recursive planning method for a
data ferry.
3.2.2. Tree-Based Planning
Given a data ferry F and a routing tree T = (V, E)
rooted a sink, where V contains all sensors S and the
sink B, and E contains all tree edges, [31] considers
11
intermediate navigator
navigation agent communication link
moving path
F
N
E
Y
MX
Z
L
C
G
W
H
B
A
I
Fig. 14. An example of distributed navigation by sensors.
• When a sensor receives a Declare-NA, it will
give up becoming a NA by broadcasting an
Accept-NA message.
• When a sensor receives Accept-NA from all
lower-depth neighbors, it will declare itself as
a NA by broadcasting a Declare-NA message.
This process is repeated until each sensor is either a
NA or a one-hop neighbor of a NA. Then, for each pair
of NAs, the nodes passed by the shortest path (in terms
of hop count) between these two NAs are marked as
INs.
2. Path computation: A path P is formed to visit
each NA. The work proposes adopting the ant colony
optimization-TSP solution [38].
3. Navigation: Finally, the data ferry travels along
P with the assistance of INs based on a DOA model.
When visiting a NA, both NA and those sensors
dominated by NA will send their data to the ferry.
Reference [39] extends the above protocol to the
k-hop data collection scheme where sensors that are
within k hops from a NA can send their data to the NA
(and thus the ferry). To reduce the latency to deliver
data to a NA, a sensor can pre-transmit its data to a
sensor that is 1-hop away from a NA.
3.3. Summary of Path Planning
Table II summarizes the path-planning methods for
data ferries. While most methods consider centralized
approaches, [36, 39] uses sensors to navigate a data
ferry in a distributed manner. References [30, 31,
32, 39] consider that data sent from sensors to a
data ferry can be multi-hop transmission; other work
[26, 27, 28, 29, 34, 35, 36] consider that ferries
should directly communicate with each sensor. For
the issue of communication time, [26, 27] extend
the communication time of sensors to meet their
bandwidth requirements, [29] minimizes the total
waiting time of a ferry at each point along the path,
and [35] adopts an physical layer technology to help
a ferry quickly collect data from sensors. For energy
concern, [30] balances the trafﬁc loads among sensors,
while [31, 32, 34, 35, 36, 39] reduce the total energy
consumption of sensors. For the length concern, [30,
31, 32] give constraints on path lengths, while [26, 27,
28, 29, 34, 35, 36, 39] try to minimize path lengths.
4. Platforms and Applications of Mobile
WSNs
Below, we review some interesting platforms and
applications. Mobile Emulab [40] is a robotic testbed
developed for mobile WSNs. Mobile sensors are
robots that carry single-board computers and sensing
devices. Remote users can control these mobile
sensors in a real-time and interactive way, or through
a script. Fig. 15 shows its system architecture. The
video cameras will overlook the ROI and track
mobile sensors. Snapshots are periodically reported
to the vision system. Through image processing, the
positions of mobile sensors are determined. The robot
system can send motion commands to mobile sensors,
which can report their sensing data to the robot
system. On the other hand, the robot system can
query the current positions of mobile sensors via the
robot-backend system. Remote users can send motion
requests to control mobile sensors, or send event
requests to obtain the ROI’s status.
Emulab interface
motion requests
 event requests
position data
event reports
position data
vision system
user
video cameras
 motion requests
position data position queries
event reports
mobile sensors
robot-backend system
snapshots
robot system
motion commands sensing data
Fig. 15. The system architecture of Mobile Emulab.
13
this work designs an adaptive speed control algorithm
to determine whether a data ferry should slow down
depending on its current data deliver rate. Speciﬁcally,
a data ferry has three speeds: SLOW, STOP, and FAST.
A sensor can indicate how much data that it wishes
to transfer in a packet header. Then, the data ferry
can select a speed accordingly. To address the second
issue, a data ferry can broadcast an interest message
to help sensors learn their distances to the data ferry’s
moving path.
5. Conclusions
Static WSNs have limitations on supporting multiple
missions and handling different situations when
network conditions change. Introducing mobility to
WSNs can improve the network capability and thus
relieve the above limitations. This article provides a
comprehensive survey of current works on mobile
WSNs. Various mobility management and path-
planning schemes have been discussed. Also, several
mobile platforms and applications have introduced.
Acknowledgment
Y.-C. Tseng’s research is co-sponsored by MoE ATU
Plan, by NSC grants 96-2218-E-009-004, 97-3114-E-
009-001, 97-2221-E-009-142-MY3, and 98-2219-E-
009-005, by MOEA 98-EC-17-A-02-S2-0048 and 98-
EC-17-A-19-S2-0052, and by ITRI, Taiwan.
References
1. I.F. Akyildiz, W. Su, Y. Sankarasubramaniam, and E. Cayirci,
“A survey on sensor networks,” IEEE Comm. Magazine,
vol. 40, no. 8, pp. 102–114, 2002.
2. A. Rapaka and S. Madria, “Two energy efﬁcient algorithms
for tracking objects in a sensor network,” Wireless Comm. and
Mobile Computing, vol. 7, no. 6, pp. 809–819, 2007.
3. F. Hu, Y. Xiao, and Q. Hao, “Congestion-aware, loss-
resilient bio-monitoring sensor networking for mobile health
applications,” IEEE J. Selected Areas in Comm., vol. 27, no. 4,
pp. 450 – 465, 2009.
4. H. Liu, P. Wan, and X. Jia, “Maximal lifetime scheduling for
sensor surveillance systems with k sensors to one target,” IEEE
Trans. Parallel and Distributed Systems, vol. 17, no. 12, pp.
1526–1536, 2006.
5. M. Tubaishat, P. Zhuang, Q. Qi, and Y. Shang, “Wireless
sensor networks in intelligent transportation systems,”
Wireless Comm. and Mobile Computing, vol. 9, no. 3, pp. 287–
302, 2009.
6. S.S. Dhillon and K. Chakrabarty, “Sensor placement for
effective coverage and surveillance in distributed sensor
networks,” Proc. IEEEWireless Comm. and Networking Conf.,
pp. 1609–1614, 2003.
7. G. Cao, G. Kesidis, T.F.L. Porta, B. Yao, and S. Phoha,
“Purposeful mobility in tactical sensor networks,” Sensor
Network Operations, 2006.
8. D. Tian and N.D. Georganas, “A coverage-preserving node
scheduling scheme for large wireless sensor networks,”
Proc. ACM Int’l Workshop Wireless Sensor Networks and
Applications, pp. 32–41, 2002.
9. Y.C. Wang, C.C. Hu, and Y.C. Tseng, “Efﬁcient deployment
algorithms for ensuring coverage and connectivity of wireless
sensor networks,” Proc. IEEE Int’l Conf. Wireless Internet, pp.
114–121, 2005.
10. Y. Zou and K. Chakrabarty, “Sensor deployment and target
localization in distributed sensor networks,” ACM Trans.
Embedded Computing Systems, vol. 3, no. 1, pp. 61–91, 2004.
11. N. Heo and P.K. Varshney, “Energy-efﬁcient deployment of
intelligent mobile sensor networks,” IEEE Trans. Systems,
Man, and Cybernetics–Part A, vol. 35, no. 1, pp. 78–92, 2005.
12. N. Aitsaadi, N. Achir, K. Boussetta, and B. Gavish, “A
gradient approach for differentiated wireless sensor network
deployment,” Proc. IFIP Wireless Days Conf., 2008.
13. G. Wang, G. Cao, and T.F.L. Porta, “Movement-assisted
sensor deployment,” IEEE Trans. Mobile Computing, vol. 5,
no. 6, pp. 640–652, 2006.
14. F. Aurenhammer, “Voronoi diagrams–a survey of a funda-
mental geometric data structure,” ACM Computing Surveys,
vol. 23, no. 3, pp. 345–405, 1991.
15. Y.C. Wang, C.C. Hu, and Y.C. Tseng, “Efﬁcient placement and
dispatch of sensors in a wireless sensor network,” IEEE Trans.
Mobile Computing, vol. 7, no. 2, pp. 262–274, 2008.
16. H.W. Kuhn, “The Hungarian method for the assignment
problem,” Naval Research Logistics Quarterly, vol. 2, pp. 83–
97, 1955.
17. Y.C. Wang and Y.C. Tseng, “Distributed deployment schemes
for mobile wireless sensor networks to ensure multilevel
coverage,” IEEE Trans. Parallel and Distributed Systems,
vol. 19, no. 9, pp. 1280–1294, 2008.
18. S. Zhou, M.Y. Wu, and W. Shu, “Finding optimal
placements for mobile sensors: wireless sensor network
topology adjustment,” Proc. IEEE Circuits and Systems Symp.
Emerging Technologies: Frontiers of Mobile and Wireless
Comm., pp. 529–532, 2004.
19. P. Basu and J. Redi, “Movement control algorithms for
realization of fault-tolerant ad hoc robot networks,” IEEE
Network, vol. 18, no. 4, pp. 36–44, 2004.
20. G. Wang, G. Cao, P. Berman, and T.F.L. Porta, “Bidding
protocols for deploying mobile sensors,” IEEE Trans. Mobile
Computing, vol. 6, no. 5, pp. 515–528, 2007.
21. Z. Butler and D. Rus, “Event-based motion control for mobile-
sensor networks,” IEEE Pervasive Computing, vol. 2, no. 4,
pp. 34–42, 2003.
22. G. Wang, G. Cao, T.F.L. Porta, and W. Zhang, “Sensor reloca-
tion in mobile sensor networks,” Proc. IEEE INFOCOM, pp.
2302–2312, 2005.
23. A. Verma, H. Sawant, and J. Tan, “Selection and navigation of
mobile sensor nodes using a sensor network,” Pervasive and
Mobile Computing, vol. 2, no. 1, pp. 65–84, 2006.
24. Y.C. Wang, W.C. Peng, M.H. Chang, and Y.C. Tseng,
“Exploring load-balance to dispatch mobile sensors in wireless
sensor networks,” Proc. IEEE Int’l Conf. Computer Comm.
and Networks, pp. 669–674, 2007.
25. P. Ballal, A. Trivedi, and F. Lewis, “Deadlock avoidance policy
in mobile wireless sensor networks with free choice resource
routing,” International Journal of Advanced Robotic Systems,
vol. 5, no. 3, pp. 279–290, 2008.
26. W. Zhao and M.H. Ammar, “Message ferrying: proactive
routing in highly-partitioned wireless ad hoc networks,” Proc.
IEEE Workshop Future Trends of Distributed Computing
Systems, pp. 308–314, 2003.
27. W. Zhao, M. Ammar, and E. Zegura, “Controlling the mobility
of multiple data transport ferries in a delay-tolerant network,”
Proc. IEEE INFOCOM, pp. 1407–1418, 2005.
28. B. Yuan, M. Orlowska, and S. Sadiq, “On the optimal robot
15
