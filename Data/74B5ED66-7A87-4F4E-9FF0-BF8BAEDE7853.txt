 
中文關鍵詞： 剖面導向程式設計，多型剖面，織入，模組性，型態擴充、
函數語言、狀態處理 
英 文 摘 要 ： Aspect-oriented programming (AOP) aims at 
modularizing concerns such as profiling and security 
that crosscut the components of a software system. 
Recently we have developed an aspect-oriented 
functional language, AspectFun, for investigating 
various issues in introducing aspect orientation to a 
polymorphically typed functional language. In this 
project, we carry on our work of AspectFun. Besides 
extending AspectFun’s core mechanism for future 
research, we investigated two issues of using aspects 
for enhancing program modularity and extensibility. 
First, in a purely functional language, a basic 
crosscutting concern is ’side effect’, i.e., state 
manipulation via assignments. Indeed, even we can 
hide the hairy details of manipulating state by using 
the state-of-the-art technology of monadic 
assignments； we have to do a comprehensive rewriting 
of our functional programs. Unfortunately, typical 
aspects such as profiling and tracing are most 
naturally implemented using side effects. If we 
cannot handle side effects directly in an aspect, the 
modularity acquired through aspects will be greatly 
compromised. Therefore, we extended AspectFun with 
side-effecting aspects which support state 
manipulation mechanisms such as user-defined 
variables and assignments directly. On the 
implementation side, we developed some compilation 
techniques, which transform the pure-functional part 
into a monadic style, and weave in the aspects. 
Furthermore, we devised a caching mechanism to 
preserve the lazy semantics of AspectFun while being 
able to execute side-effecting aspects in a non-
interfering way.  
 
Second, we investigated the feasibility of using 
aspects to address the type extension requirements as 
stated in the famous expression problem (which calls 
for language mechanisms that can support type-safe 
I 
中文摘要 
 
關鍵詞：剖面導向程式設計，多型剖面，織入，模組性，型態擴充、函數語言、狀態處理 
 
剖面導向程式設計(Aspect-Oriented Programming, AOP)是近年來繼物件導向程式設計(OOP)後，所
興起的一種新的模組化程式設計方法。從 AOP的觀點來看，應用程式除了功能邏輯以外，還有許多
像安全需求等的橫跨性關注(crosscutting concerns)；實現這些橫跨性關注的程式碼應該要從功能模組
中分離出來，自成一模組並稱之為剖面。剖面與功能模組之間的界接點由所謂橫切點(pointcut)來定
義，並透過稱之為織入(weaving)的機制將剖面程式碼(advice)整合入功能模組中，從而合成完整程式，
滿足系統整體需求。這樣實現橫跨性關注的程式碼就可以集中封裝於適當的模組中，避免掉程式碼糾
結與重複的問題。 
 
先前我們的國科會研究計畫（NSC95-2221-E-004-004-MY2）以型態導向的方法，發展了一套多
型剖面的織入技術，並據以設計實作了一個實驗性的剖面導向函數語言 AspectFun。本計劃在
AspectFun 語言既有的基礎上，進一步探討剖面機制在函數式語言的程式模組化與擴充性方面的一些
課題，所要進行的探討涵蓋實作、語言設計與理論模型與驗證各個面向，主題則大致上可分為三部份: 
(1) AspectFun語言核心機制的擴充與實作，以奠定後續研究的基礎。(2)探討如何以剖面與編譯技術來
模組化純粹函數語言內最基本的橫跨性關注：狀態處理 (state manipulation via assignment) ，將設計
與實作具備狀態處理功能的剖面 (side-effecting aspects)來處理的狀態改變，以提高純粹函數程式的模
組化。(3)探討如何以剖面處理函數語言型態擴充(type extension)的需求，評估剖面導向的解決方案在
程式擴充性方面的適用性。 
 
我們的成果簡述如下：在以剖面處理函數語言型態擴充(type extension)的需求方面，我們開發出
了好幾個可以增加 AspectFun語言表達能力的機制與設施，也將這些機制實作於 AspectFun語言中，
不過也發現到它們的限制：個別編譯的困難。在以剖面與編譯技術來模組化純粹函數語言內的狀態處
理方面，我們發展了具備狀態處理功能的剖面 (side-effecting aspects)與 monadification 程式轉換演算
法，不僅可以處理一般程式，對於應用惰性求值的函數式語言也可適用，可以順利處理的狀態改變，
提高純粹函數程式的模組化。我們也將這套機制與轉換技術實作於 AspectFun的編譯器，並將其發布
於中研院的開放源碼平台 Open Foundry。此外，我們定義了 side-effecting aspects的操作型與語義，驗
證我們的程式轉換與織入方法的正確性。 
III 
目錄 
一、前言 ........................................................................................................................................................................1 
二、研究目的 .................................................................................................................................................................1 
三、文獻探討 ...............................................................................................................................................................3 
四、研究方法 ...............................................................................................................................................................4 
五、結果與討論 ..........................................................................................................................................................8 
六、參考文獻 ...............................................................................................................................................................10 
附錄一、期刊論文..........................................................................................................................................................  
附錄二、期刊論文..........................................................................................................................................................  
 
 
 
 
 
 
 
 
 
2 
本計劃有以下幾個研究目的。首先，AspectFun語言雖然已經具備了許多關於剖面的核心機制，
但要真正應用起來，還有一些不方便之處。例如，在 advice內僅能取得 advised函數的引數，無法像
AspectJ一樣，可以取得更多的關於 join point的資訊，像是 advised函數的名字與型態等的資訊(this join 
point, tjp)。其次，AspectFun語言目前僅提供一些基礎形態和常用的 tuples和 lists兩種結構型態，還
欠缺一個定義資料型態(data type)的核心功能，使得應用範例的撰寫上頗為侷限。所以我們新增此一
功能，這部份也是接下來兩項研究項目的必要元素。 
接著，我們比較剖面與 Haskell 函數語言的 type class在處理型態擴充需求議題的可行性，型態擴
充議題我們以著名的 Expression Problem[4] 作為代表(程式語言機制如何確保程式在擴充資料與運算
函數的過程中，不需要修改舊有的程式碼，並能確保程式的型態安全)。接著我們會探討 AspectFun
剖面如何以模組化方式來輔助實現泛型程式設計(generic programming)[5]。泛型程式設計是指函數接
收一額外的型態引數，且函數所執行的運算是依據此型態引數結構來進行的。型態引數是用來表示函
數所處理的引數或其回傳值型態為何，但型態引數在函數定義中可能是明確定義的或者隱含的。在此
研究中我們會展示以剖面實現的泛型程式設計更優於使用 type class。此外，本研究為使 AspectFun可
以實現泛型程式設計方法，必須採用 safe typecast設施，我們亦在 AspectFun 增加擴充了 Existential 
types 機制與多型互遞迴函數的織入技術。 
最後，AspectFun語言跟 Haskell語言[6]一樣，是一個純粹的函數式語言，並沒有提供 assignment
等的狀態處理(side-effecting)機制(.除了 print 外)。而在這樣的語言中，一個最基本常見的橫跨性關注
就是 side-effect via assignments。一般說來，使用純粹函數式語言時，所有牽涉到共用狀態(shared state)
的函數通通要改寫，將狀態當成一額外的參數，在彼此之間相互傳遞(threaded with a state parameter)。
近來 Haskell引進 monad [7][8]的機制，可以將狀態處理封裝在 monad之內，大幅簡化狀態處理的程
式撰寫，但是一旦使用 monad，程式所有相關部分都要改成 monadic的寫法，因此也是一種橫跨式的
大幅變動。偏偏 aspect 常用來實現的 profiling 與 tracing 等工作，都是需要有狀態處理功能的，所以
即便我們可以將狀態處理部分限縮在 aspect內，以 monad實現模組化狀態處理的需求，但是原本是單
純的函數構成的程式本體，卻也必須跟著改寫成 monadic方式，如此一來，大大減損了使用 aspect模
組化的優勢。所以本計劃的一個重點就是要探討如何在 AspectFun直接提供具備狀態處理功能的剖面 
(side-effecting aspects)，透過編譯技術將其與程式本體自動轉換成 monadic方式，以提高純粹函數程式
的處理狀態的模組化程度。此外，這個機制還必須能在不影響 AspectFun語言的 lazy semantics下運作。
所以，我們定義 side-effecting aspects的操作型與語義，驗證我們的織入(weaving)方法的正確性。 
 
三、文獻探討 
 
自從 1997年 Kiczales et al. [1]提出 AOP的程式設計方法後，許多的程式語言與軟體工程的學者
專家紛紛投入這方面的研究，彷彿循著當年 OOP的發展軌跡一般，由 Programming, Design漸漸進入
Analysis (OOA)。陸續我們看到各式 AO程式語言的誕生，以及從整個軟體開發流程角度切入探討 AO
4 
提出了以 monad來作為 AO理論基礎的想法。此後，類似的想法與討論陸續出現在網路相關的論壇中，
最近 Hoper &Ostermann [19]發表了一篇論文，應用兩個典型的範例來比較 aspect和 monad在處理橫
跨性關注的表達能力，其中討論了兩者之間如何模擬另一方的功能。這和我們要進行的研究不同，我
們所計畫的 side-effecting aspect是要直接在剖面內使用變數來撰寫狀態改變程式碼，然後再用所發展
的編譯技術，將程式轉譯成使用 monad的 Haskell程式碼，以達到封裝狀態處理於剖面內的程式模組
化目的。 
在程式擴充性的研究方面，常常拿來當作標竿問比較各程式語言擴充機制的問題就是所謂的 the 
Expression problem [4]。這個問題探討在程式的資料型態與運算函數同時要增加的情況下，是否可以
在不改變也不重複既有程式，而又能確保型態安全性的限制下完成。針對此問題，物件導向語言學者
提出來的解決方式是應用泛型(generics)和 visitor pattern以及 virtual class[20][21]機制；函數式語言方
面則有 Caml與 Haskell的 polymorphic variant機制[22][23]。最近物件導向與函數混合式語言 Scala也
提出他們的解決方案[24]。在剖面導向語言方面，則還沒有比較深入的探討。不過，直得一提的是
Aspectual Caml 也注意到可能可以用 aspect 來處理程式擴充性的議題，因此設計了類似的 inter-type 
declaration的機制來實驗可能的解決之道。不過，他們並沒有在這方面進行嚴格的理論分析。比較接
近我們構想的研究是 Washbur&Weirich 所發表的，探討如何以 PolyAML 實現型態導向程式設計的論
文 [25]。 
 
四、研究方法 
 
分三方面概要說明如下，詳內內容請參考附錄中以發表之論文： 
 
（一）在擴充 AspectFun核心機制方面，我們增加了以下數項核心功能到 AspectFun語言中： 
 (a)使用者自訂資料型態，範例： 
data Tree a = Leaf a  
| Node (Tree a) (Tree a) 
 
 (b)函數定義可以用 pattern matching方式進行。範例： 
sumTree (Leaf i) = i 
sumTree (Node l r) = … 
add (sumTree l) (sumTree r) = … 
 
 (c)增加關鍵字 tjp (this join point)，供剖面取得 join point的資訊。範例： 
advice@tracing around {ANY} (arg) {  
             print “Function” + tjp + “called”; proceed arg } 
 
這幾項功能中，都透過修改目前的 AspectFun 編譯器完成，此編譯器可在中研院資訊所發展的
自由軟體鑄造場(Open Foundry)下載。 
6 
其次，我們發展以 advice 來輔助泛型程式設計的方法。基本上也是以 Hinze 提出的 Spine 型態為
中介泛型型態: 
     dataSpine a = Con (Constr a) 
        | forallb.ToSpine b => 
         App (Spine (b -> a)) b 
     dataConstr a = Descr a 
 
這裡用到 existential types,所以我們也擴充 AspectFun，加了此一設施。 
  然後我們以 Washburn等人提出的 泛型函數 strings(從任意的結構型態中擷取其中的 string包
成串列回傳)為例，來說明我們的方法，遇到的困難以及如何克服的作法。 
     
strings :: a -> [String] 
    strings x = strings‟ (toSpine x)  
    in strings‟:: Spine a -> [String] 
strings‟ (Con c) = [ ] 
strings‟ (App f x) =  
strings‟ f ++ strings x in 
n@advice around {strings}(arg :: String) = [arg] in … 
 
在上述程式片段中，我們以 type-scoped advice n 處理當引數型態為 String 時的例外工作。在
AspectFun 中，我們期望每次 strings 被呼叫時皆會先觸發 advice n 判斷引數型態，但實際執行的情
況在 strings‟定義中呼叫 strings 時並沒有觸發 advice n，所以無法達到擷取字串的要求。 
進一步分析後，發現問題的原因是由於 Spine a 定義中使用了 Existential type，但 AspectFun 是靜
態型別的語言，型態資訊只存在於編譯過程中，程式設計者無法直接對型態資訊進行操作。當程式中
使用 Existential type，型態推論系統為了確保型態安全只能推導出較抽象的型態資訊，因此在 strings‟
定義中呼叫 strings 時推導系統只能判斷出此時傳給 strings 的引數型態是某個未知型態 a 而非具體的
String型態，導致 advice n 不會被觸發。 
為了解決 Existential type 造成的型態資訊不足問題，我們採用的作法是將型態資訊保留至程式執
行期間，讓程式設計者可以在執行期間自行根據型態選擇運算工作，而非依賴編譯器藉著不足的型態
資訊決定。概念上，我們需要 safe typecast機制[6]，以利 advice n的運作: 
 
     n@advice around {strings} (x) = 
      casecast x :: Maybe String of 
      Just s  -> [s] 
      Nothing -> proceed x 
 
要在靜態型別語言中增加safe cast設施，具體的作法是藉由資料型態定義來編碼表示帶有型態標籤的
值 : 
    data Typed a = Typed a (TypeRep a) 
8 
 setIndentind; 
 putMsg $ ind ++ "`returns " ++ show result; 
result 
 
在編譯轉換方面，我們會將使用者自定變數當成 user state，連同輸出用的內部狀態一起用 state monad
封裝起來，並透過一些輔助函數，將這些處理狀態的剖面程式碼轉譯成 Haskell 的 monad 程式碼。以
上面的追蹤剖面為例，大致上會轉譯成下列程式碼；(轉譯後的追蹤剖面, monadic style) 
 
type S a = State (UserState, InternalState) a //state monad 
tracer proceed = return $ \arg -> return $ \acc -> 
do ind <- getIndent 
 setIndent ("| " ++ ind) 
 putMsg $ ind ++ "fact is call with " ++ show arg 
 p<- proceed arg 
 result<- p acc 
 setIndentind 
 putMsg $ ind ++ "`returns "  ++ show result 
   return result 
 
但還有引數(argument)求值的議題要設法解決。因為 AspectFun跟 Haskell一樣，都是採取惰性求值(lazy 
evaluation)方式來計算引數的值；但是引進 monad後，由於 monad的特性會與惰性求值產生一些互動，
上面的轉譯後的程式的執行結果與預期會有不同，monad的取值動作(bind)會改變引數的求值順序或重
複計算。針對此一問題，我們發展了一個 caching state monad來保留惰性求值，附錄的 PEPM’09論文
中詳述了這個解決方法。 
 接著我們進行對上述這個轉換演算法的正確性進行探討，其中一個難題就是這個問題示當我們要
轉換的對象是高階函數時，原有的轉換言算法就不能正確運作。針對此問題，我們擴增了一些轉換機
制，讓高階函數也能透過原本的架構順利運作，但也無可避免的增加了一些轉換後程式碼執行期的負
擔(overhead)。此外，我們也完成了這些機制的形式化分析，得出 AspectFun擴充後的操作型語義，並
且能夠克服先前無法處理高階函數的限制，推導出正確性定理之證明，詳細的結果發表於 HOSC國際
期刊（附錄二）。 
 
五、結果與討論 
 
我們計畫的研究重點在探討如何以剖面(aspect)與編譯技術來模組化純粹函數語言內最基本的橫跨
性關注：狀態處理 (state manipulation via assignment)。我們的出發點是我們稍早所發展出來的剖面導
向函數語言 AspectFun，AspectFun 語言跟 Haskell 語言一樣，是一個純粹的函數式語言，並沒有提供
assignment等的狀態處理(side-effecting)機制(.除了 print外)。在這樣的語言中，一個最基本常見的橫跨
10 
六、參考文獻 
 
[1] G. Kiczales, J. Lamping, A. Menhdhekar, C. Maeda, C. Lopes, J.-M. Loingtier, and J. Irwin, 
Aspect-oriented programming, in ECOOP '97 Object-Oriented Programming 11th European Conference," 
Finland (M. Aksit and S. Matsuoka, eds.), vol. 1241, pp. 220-242, New York, NY: Springer-Verlag, 1997. 
[2] MengWang, Kung Chen, Siau-ChengKhoo, Type-DirectedWeaving of Aspects for 
Higher-orderFunctionalLanguages, ACM SIGPLAN 2006 Workshop on Partial Evaluation and Program 
Manipulation (PEPM '06) Charleston, South Carolina, January 9-10, 2006. 
[3] Kung Chen, S C Weng, M Wang, S.C. Khoo, and C.H. Chen. “A Compilation Model for Aspect-Oriented 
Polymorphically Typed Functional Languages”, International Symposium of Static Analysis (SAS 2007), 
Lecture Notes in Computer Science 4634, pp. 34-51. < NSC-95-2221-E-004-004> 
[4] P. Wadler, The expression problem. Posted on the Java Genericity mailing list (1998). 
[5] Ralf Hinze and Andres Loh, Generic programming in 3D, Science of computer programming Vol. 74, 
Issue 8 (June 2009). 
[6] The Haskell Language Report, http://www.haskell.org/onlinereport/
[7] P. Wadler, The essence of functional programming, 19'th Symposium on Principles of Programming 
Languages, ACM Press, Albuquerque, January 1992. 
[8] P.Wadler, Monads for functional programming, in J. Jeuring and E. Meijer, editors, Advanced Functional 
Programming, Springer Verlag, LNCS 925, 1995. 
[9] Early Aspects: Aspect-Oriented Requirement Engineering and Architecture Design, website at 
http://www.early-aspects.net/  
[10] M. Wand, G. Kiczales, and C. Dutchyn. A semantics for advice and dynamic join points in 
aspect-oriented programming. Foundations of Aspect-Oriented Languages (FOAL), 2002, Extended version: 
ACM TOPLAS, 26(5):890–910, September 2004. 
[11] Hidehiko Masuhara, GregorKiczales: Modeling Crosscutting in Aspect-Oriented Mechanisms.ECOOP 
2003: 2-28. 
[12] C. Clifton and G. Leavens. Minimao: Investigating the semantics of proceed. In Proceedings of the 
Foundations of Aspect-Oriented Languages, 2005. 
[13] D. Tucker and S. Krishnamurthi. Pointcuts and advice in higher-order languages.In Proceedings of the 
2nd International Conference on Aspect-Oriented Software Development, 2003. 
[14] R. Jagadeesan, A. Jeffrey, and J. Riely. A calculus of untyped aspect-oriented programs. In Proceedings 
of the 2003 European Conference on Object Oriented Programming, pages 54–73. Springer, 2003. 
[15] Daniel S. Dantas and David Walker, Harmless advice, In Foundations of Object-Oriented Languages 
(FOAL 05), March 2005. 
[16] D. S. Dantas, D. Walker, G. Washburn, and S. Weirich.PolyAML: a polymorphic aspect-oriented 
functional programmming language. In Proc. of ICFP’05. ACM Press, September 2005. 
[17] H. Masuhara, H. Tatsuzawa, and A. Yonezawa. Aspectual Caml: an aspect-oriented functional language. 
In Proc. of ICFP’05. ACM Press, September 2005. 
[18] Wolfgang De Meuter, Monads as a theoretical foundation for AOP, Workshop on Aspect-Oriented 
Programming at ECOOP, 1997. 
[19] Christian Hofer and Klaus Ostermann, On the relation of aspects and monads, Proceedings of the 6th 
12 
 
附錄一 
 
Kung Chen, S.C. Weng, M. Wang, S.C. Khoo, and C.H. Chen, (2010) “Type-Directed Weaving of Aspects for 
Polymorphically Typed Functional Languages”, Science of Computer Programming 75, Issue 11, pages 
1048-1076, Nov. 2010. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Science of Computer Programming 75 (2010) 1048–1076
Contents lists available at ScienceDirect
Science of Computer Programming
journal homepage: www.elsevier.com/locate/scico
Type-directed weaving of aspects for polymorphically typed
functional languages
Kung Chen a, Shu-Chun Weng b, Meng Wang c, Siau-Cheng Khoo d,∗, Chung-Hsin Chen a
a National Chengchi University, Taiwan
b National Taiwan University, Taiwan
c Oxford University, United Kingdom
d National University of Singapore, Singapore
a r t i c l e i n f o
Article history:
Received 17 September 2008
Received in revised form 1 March 2010
Accepted 9 April 2010
Available online 20 May 2010
Keywords:
Aspect-oriented programming
Type-scoped advice
Static weaving
Polymorphically typed functional language
a b s t r a c t
Incorporating aspect-oriented paradigm to a polymorphically typed functional language
enables the declaration of type-scoped advice, in which the effect of an aspect can
be harnessed by introducing possibly polymorphic type constraints to the aspect.
The amalgamation of aspect orientation and functional programming enables quick
behavioral adaption of functions, clear separation of concerns and expressive type-directed
programming. However, proper static weaving of aspects in polymorphic languages with
a type-erasure semantics remains a challenge. In this paper, we describe a type-directed
static weaving strategy, as well as its implementation, that supports static type inference
and static weaving of programs written in an aspect-oriented polymorphically typed
functional language, AspectFun. We show examples of type-scoped advice, identify the
challenges faced with compile-time weaving in the presence of type-scoped advice, and
demonstrate how various advanced aspect features can be handled by our techniques.
Finally, we prove the correctness of the static weaving strategy with respect to the
operational semantics of AspectFun.
© 2010 Elsevier B.V. All rights reserved.
1. Introduction
Aspect-oriented programming (AOP) aims at modularizing concerns such as profiling and security that crosscut
components of a software system [11]. In AOP, a program consists of many functional modules and some aspects that
encapsulate the crosscutting concerns. An aspect provides two kinds of specification: pointcut , comprising a set of functions,
designates when and where to crosscut other modules; and advice, which is a piece of code, that will be triggered for
execution when the corresponding pointcut is reached during run time. The complete program behavior is derived by some
novel ways of composing functional modules and aspects according to the specifications given within the aspects. Such a
composing activity can be done at compile time or run time, and is referred to as weaving in AOP. Weaving results in the
behavior of those functional modules impacted by aspects being modified accordingly.
While majority of the developments of AOP have been based on the object-oriented (OO) paradigm, there has been
increasing awareness that the idea of AOP, if not the exact mechanism developed in the OO setting, is able to offer
distinguished benefit to conventional functional languages in terms of modularity [23,22]. To start with, let us consider
a simple example of sorting a list. Assuming we already have a function sort :: [a] -> [a] that implements the
quicksort algorithm and picks the pivot from the head. For specific application domains, it is generally very useful if we can
∗ Corresponding author.
E-mail address: khoosc@comp.nus.edu.sg (S.-C. Khoo).
0167-6423/$ – see front matter© 2010 Elsevier B.V. All rights reserved.
doi:10.1016/j.scico.2010.04.001
1050 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
Programs pi ::= d in pi | e
Declarations d ::= x = e | f x = e | n@advice around {pc} (arg) = e
Arguments arg ::= x | x :: t
Pointcuts pc ::= ppc | pc + cf | pc − cf
Primitive PC’s ppc ::= f x | any | any\[f ] | n
Cflows cf ::= cflow(f ) | cflow(f (_ :: t))
| cflowbelow(f ) | cflowbelow(f (_ :: t))
Expressions e ::= c | x | proceed | λx.e | e e | let x = e in e
Types t ::= Int | Bool | a | t → t | [t]
Advice Predicates p ::= (f : t)
Advised Types ρ ::= p.ρ | t
Type Schemes σ ::= ∀a¯.ρ
Fig. 1. Syntax of the AspectFun language.
This class implements a list with a method max. When the input is a Boolean list, we may want to use bit operations for
implementation efficiency. This can be attained via a type-scoped aspect.
aspect BooleanMax {
List<Boolean> around(List<Boolean> x): args(x) &&
execution(List<Boolean> List<Boolean>.max(List<Boolean>)) {
// special code for boolean arguments
} }
However, for those invocations of max that occur inside another polymorphic method, we shall run into the same difficulty
of static weaving as described above. Furthermore, due to the type-erasure semantics of Java, run-time type test of the list
element type is not feasible. The solution presented in this paper, which works well in functional languages such as Haskell,
can shed light on the possible improvement to the compilation of aspect-oriented programs written in other paradigms.
In this paper, we present a type-directed aspect weaving scheme for polymorphically typed functional languages that
can solve this problem with static weaving. We consolidate our past research in this field [21,20,2] and makes significant
revisions and extensions to several dimensions of our research. Moreover, we illustrate our scheme with an experimental
language, AspectFun, and provide the following:
1. A complete treatment of static and consistent weaving for the core features of AspectFun, including type-scoped advice
and nested advice (whose body is also advised).
2. A full formulation of the correctness of static weaving wrt the operational semantics of AspectFun and its proof.
3. A complete implementation of our static weaving scheme which turns aspect-oriented functional programs into
executable Haskell code without aspects.1
The outline of the paper is as follows: Section 2 presents our experimental language AspectFun, highlighting various
aspect-oriented features our scheme supports through examples in AspectFun. Section 3 defines an operational semantics
for AspectFun. In Section 4, we describe our type inference system and the corresponding type-directed static weaving
process. Next, we formulate the correctness of static weavingwith respect to the semantics ofAspectFun. Finally, we discuss
relatedwork in Section 6 and conclude in Section 7. Appendix provides the detailed proof of the correctness of staticweaving.
2. AspectFun: The aspect language
This section introduces the aspect-oriented functional language, AspectFun, for our investigation. We shall first describe
the core features of AspectFun, and outline the compilation process we employ to implement it. Thenwe shall present some
example applications of AspectFun.
2.1. Language features
Fig. 1 presents the language syntax.2Wewrite o¯ as an abbreviation for a sequence of objects o1, . . . , on (e.g. declarations,
variables, etc.) and fv(o) as the set of free variables in o. We assume that o¯ and o, when used together, denote unrelated
objects.
1 The implementation is available at http://of.openfoundry.org/projects/801/.
2 To simplify the presentation, we leave out type annotations, user-defined data types, if expressions, patterns and sequencings (;), but may make use
of them in examples.
1052 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
AspectFun
program
1. Parsing and
Dependency
analysis
Abstract
syntax tree
2. De-sugaring
Type
environment for
built-in functions
Refined abstract
syntax tree
3. HM-like Type
inference
Base type
environment
Explicit
AspectFun
4. Static pointcut
matching
Function-advice
association
5. Type Inference
and Static
weaving (Sec. 4)
Expressions
with chains
6. Guard insertion
Not discussed
in this paper
Expressions
with chains
and guards
7. Cflow anlayses
and Optimization
8. Monad
Transformation
Chain
expressions
9. Chain
expansion
Sugared lambda
calculus
10. Code
generation
Haskell
program
Fig. 2. Compilation process of AspectFun .
2.2.1. Behavioral adaptation
AOP enables us to adapt and reuse existing code in a modular fashion. Let us consider an example of monadic evaluators
[17] for the lambda calculus.
Example 1.
data Term = Var String
| Lam String Term
| App Term Term
eval :: Term -> M Term
eval (Var n) = return (Var n)
eval (Lam n t) = return (Lam n t)
eval (App t1 t2) = do t1’ <- eval t1
t2’ <- eval t2
case t1’ of
Lam n t -> eval (subst (n,t2’) t)
t -> return (App t t2’)
The evaluator, eval, reduces a lambda term using a monad, M. The default evaluation strategy above is call-by-value. A
definition of a call-by-name evaluator will be very similar and only differs in the App case. Instead of defining two separate
functions that are largely overlapping, we can treat the above definition as a ‘template’ function and override it later by
aspects.
cbn@advice around {eval} (e) =
case e of (App t1 t2) ->
do t1’ <- eval t1
case t1’ of Lam n t -> eval (subst (n,t2) t)
t -> return (App t t2)
_ -> proceed e
1054 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
example, the Spine type defined below is a general and uniformway of representing elements of a data type that can support
the definition of generic functions, such as strings.
data Spine a = Con (Constr a)
| forall b. App (Spine (b -> a)) b
data Constr a = Descr a
If a constructor does not take any argument, it is encoded by Con together with information about the constructor.
Otherwise, a constructor taking arguments is encoded by applying App to the representation of the constructor and to its
arguments. The function toSpine, which converts a data type to its spine representation, can be defined in a type-directed
manner.
toSpine :: a -> Spine a
toSpine x = undefined
int@advice around {toSpine} (arg::Int) = Con (Descr 0)
char@advice around {toSpine} (arg::Char) = Con (Descr ’a’)
list@advice around {toSpine} (arg::[a]) =
case arg of [] -> Con (Descr [])
(x:xs) -> App (App (Con (Descr (:))) x) xs
...
Type-scoped advice is put into gooduse to bring in newcases oftoSpine for the ever-growing set of data types. For example,
toSpine [1,2,3] produces
App (App (Con (Descr (:)) 1) [2,3])
This shallow encoding is pushed inwards by generic functions that make use of it, as we will see shortly. Since all data types
are now mapped to a single one, Spine, we can easily define functions that work on this representation. For example, the
following code collects strings from a structure.
strings :: a -> [String]
strings x = strings’ (toSpine x)
strings’ :: Spine a -> [String]
strings’ (Con c) = []
strings’ (App f x) = strings’ f ++ strings x
The intention of the above program is to uniformly traverse the structures of any data types (including strings seen as lists of
Chars). To be able to collect strings, we need a small exception of this generic behavior that returns a stringwhen the input is
a string. This is another type-directed operation. It is tempting to use type-scoped advice here to advise strings. However,
we notice that the call to strings in the body of strings’ is given the second argument of App as input, whose type is
existentially quantified in the definition of Spine and is not available statically. This makes type-scoped advice, together
with any other type-directed-programming mechanisms that relies on static resolution, not applicable.
A standard technique for handling this exception case, which can be found in the generic programming literature, is to
use dynamic ‘‘type’’ testing based on some kinds of term encodings of types [12,13,7]. Independently, encoding of dynamic
type casting in statically type languages [24,3] is also available. Here, we choose to follow Hinze and Löh [7] by wrapping a
value of type a with a type representation to form a data type, Typed a, and use a cast function that compares the type
representation with a target type. As a result, the exceptional case of string inputs can be handled by the following advice.
n@advice around {strings} (x) =
case cast x :: Maybe String of Just s -> [s]
Nothing -> proceed x
This advice intercepts all executions of strings. When the input is dynamically verified to be a string, we return that string
in the result; otherwise, control is passed back to strings if there is no other intercepting advice. (We need to adapt the
earlier definition of toSpine to accept Typed a as its argument type. The detail is omitted here.)
We think this ability of accepting dynamic type castingwith aspects is one of the strengths of AOP, since it allowsmodular
extensions. Suppose we later implement a data type of ASCII code of characters and wish to consider a list of ASCII’s as a
string, function strings can be easily extended with another special case using the following aspect.
n1@advice around {strings} (x) =
case cast x :: Maybe [Ascii] of Just s -> [s]
Nothing -> proceed x
Thismodular extensibility is difficult to achievewith other type-directed approaches such as Haskell type classes. It is worth
mentioning that just like encodings of dynamic typing do not render static typing obsolete, the use of type casts in advices
does not replace static weaving.
1056 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
(OS:Value) E;A ` c ⇓ c
E;A ` (|λlx : t. e, E ′|) ⇓ (|λlx : t. e, E ′|) E;A ` (|Λa. e, E ′|) ⇓ (|Λa. e, E ′|)
(OS:Lamb) E;A ` λlx : tx. e ⇓ (|λlx : tx. e, E |) E;A ` Λa. e ⇓ (|Λa. e, E |)
(OS:Thunk)
E ′;A ` e ⇓ v
E;A ` (|e, E ′|) ⇓ v
e is not an abstraction
(OS:App)
E;A ` e1 ⇓ (|λlx : tx. e3, E ′|) Trigger((|λx : tx. e3, E ′|), l) = (|λy : ty. e4, E ′′|)
E ′′[y 7→ (|e2, E |)];A ` e4 ⇓ v
E;A ` e1 e2 ⇓ v
(OS:Ty-App)
E;A ` e1 ⇓ (|Λa. e2, E ′|) E ′;A ` [t/a]e2 ⇓ v
E;A ` e1{t} ⇓ v
(OS:Let)
E[x 7→ (|e1, E |)];A ` e2 ⇓ v
E;A ` let x = e1 in e2 ⇓ v
(OS:Var)
[x 7→ e] ∈ E E;A ` e ⇓ v
E;A ` x ⇓ v
(OS:Decl)
E[id 7→ (|e1, E |)];A ` pi ⇓ v
E;A ` id = e1 in pi ⇓ v
(OS:Adv)
∀a¯.t1 → t2 = σ
E;A ` n :: σ@advice around {pc} (x :: t1) = e1 in pi ⇓ v
E;A ` n :: σ@advice around {pc} (x) = e1 in pi ⇓ v
(OS:Adv-An)
∀a¯.t1 → t2 = σ
E;A.(n : σ , pc, t1, (|Λa¯.λn:t1→t2x : t1.e1, E |)) ` pi ⇓ v
E;A ` n :: σ@advice around {pc} (x :: t1) = e1 in pi ⇓ v
Fig. 5. Operational semantics for EA.
expression in a thunk is a lambda expression or a type abstraction, the thunk is called a closure. Constants and closures are
considered values in EA and will not be further evaluated. Finally, during the evaluation of an EA program, the environment
associates a namewith a thunk as its binding. Wewrite E[y 7→ th] for the environment which extends E by assigning thunk
th to variable y, assuming that any name clash has been resolved via proper renaming.
Among the reduction rules for EA three rules, namely (OS:Decl), (OS:Adv) and (OS:Adv-An), process top-level
declarations; and the rest of rules handle various forms of expressions. Rule (OS:Decl) makes a thunk out of the defining
expression of a global variable or function and the current environment, and then puts it into the environment for further
evaluation of the underlying program. On the other hand, rules (OS:Adv) and (OS:Adv-An) collect the set of advice declared
in a program and deposit it in the advice store,A. BothA and E are essential to the evaluation of the expression inside an
EA program.
The (OS:Adv) rule simply delegates the collection task to the (OS:Adv-An) rule, making non-type-scoped advice a special
case of type-scoped advice with the inferred parameter type as the scope. The (OS:Adv-An) performs the real work of advice
collection: organizing a type-scoped advice into a quadruple, (n : σ , pc, t, e), and appending it to the advice store A. The
quadruple consists of advice name type pair, pointcut, type scope and thunkified advice body.
As to the reduction rules for expressions of EA they mostly follow the standard ones for a typed lambda calculus with
constants. The only exception is the rule for function application, (OS:App), which also handles the triggering andweaving of
advice. Specifically, the closure to apply and the label associated with it are passed to the advice triggering function Trigger,
which is specified in Fig. 6 together with other auxiliary function declarations. The Trigger function first chooses the set of
eligible advice based on the label and the argument type, and weaves them into the function invocation – through a series
of environment extension of advice closures – for execution. Note that, although we adopt the call-by-name evaluation
strategy, our weaving scheme does not rely on this choice.
Three points worth mentioning here. First, in the main body ofWeave function, the function Trigger is invoked again to
handle any possible triggering of second-order advice. Second, among the advice matched by JPMatch, the function Choose
keeps all the advice whose type scope is more general than the type passed to it, regardless of its return type. Consequently,
it is likely that, during the subsequent execution of thewoven advice, a run-time type errormay occur and the reduction fails
(unless, of course, the program has been analyzed to be safe by our type system). Third, the set of advice selected by Choose
is kept in a list and ordered according to the sequential ordering of their declarations in the program. While we believe
1058 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
4. Static weaving
In our compilation scheme, aspects are woven statically (Step 5 in Fig. 2). Specifically, we present in this section a
type inference system which guarantees type safety and, at the same time, weaves the aspects through a type-directed
translation. The input to the inference and weaving system is a well-typed EA program, converted from its AspectFun
version as described in Section 3. But, to ease the presentation, we often omit the type annotations in an expression in
the following discussion. Moreover, we concentrate on advice with only primitive pointcuts, yet our static weaving scheme
can be adequately extended to handle composite pointcuts such as f+cflowbelow(g). The readers are referred to our
earlier work [2] for the detailed treatment.
4.1. Type-directed weaving
The essential construct of our staticweaving scheme is the advised type. As brieflymentioned in Section 2, an advised type,
denoted as ρ, is used to capture function names and their types that may be required for advice resolution.We illustrate this
concept with our tracing example given in Section 2. The relevant code snippet is repeated below for ease of presentation.
n1@advice around {any} (arg) = ... in
n2@advice around {f} (arg::[Char]) = ... in
f x = x in
h x = f x in
(f 10, f "c", h "d")
We focus on the call to function f in the body of h. The issue of static weaving here is essentially the same aswe described
in Section 1 for the example of function sortcat. If we were to naively infer that the argument x to function f in the RHS
of h’s definition is of polymorphic type, we would be tempted to conclude that (1) advice n1 should be triggered at the call,
and (2) advice n2 should not be triggered as its type scope is less general than a→ a. As a result, only n1would be statically
woven to the call to f.
Unfortunately, this naive approach would cause inconsistent behavior of f at run time, as only the invocation of f "c"
will trigger advice n2. By contrast, according to the operational semantics of AspectFun, both of the invocations (f "c")
and (f "d") (indirectly called from (h "d")) should trigger n2. We consider such a naive approach to static weaving
as incoherent because the two invocations of f would exhibit different behaviors (i.e., they would receive different sets of
advice) even though they would receive arguments of the same type. More formally, a static weaving scheme is deemed as
‘‘coherent’’ if the static woven program evaluates to the same value as the evaluation of the original program according to
its operational semantics.5
Our static weaving scheme resolves this problem by inferring an advised type for function h. Specifically, function h
possesses the advised type ∀a.(f : a → a).a → a, in which (f : a → a) is called an advice predicate. It signifies that the
execution of any application of hmay require triggering of the advice on f whose type can be instantiated to t ′ → t ′, where t ′ is
an instantiation of type variable a.Moreover, function h and the invocation h "d"will be translated by the weaver into the
following form.
h df x = df x
<h, {n1}> <f, {n1, n2}> "d"
Here function f inside the definition of h has been turned into an advice parameter , df, which may be resolved to
a woven expression. We use the notation, 〈_ , {. . .}〉, to denote such woven expressions and refer to them as chain
expressions. Intuitively, a chain expression denotes composition of advice associated with an underlying function. For
instance, 〈f , {n1, n2}〉 denotes chaining of two pieces of advice n1 and n2 to the advised function f. During the code
generation stage, chain expressions will be expanded to ordinary Haskell expressions, as will be shown in Section 4.4.
Note that advised types are used to indicate the existence of some advice indeterminable at compile time. If a function
contains only applications whose advice is completely determined, then the function will not be associated with an advised
type; it will be associated with a normal (and possibly polymorphic) type. As an example, the type of the advised function
f in Example 2 is ∀a.a→ a since it does not contain any application of advised functions in its definition.
The main set of type inference rules, as described in Figs. 7 and 8, is an extension to the Hindley–Milner system. We
introduce a judgement Γ ` e : ρ  e′ to denote that expression e has type ρ under type environment Γ and it is
translated to e′. We assume that the advice declarations are preprocessed and all the names which appear in any of the
pointcuts are recorded in an initial global store A. Note that locally defined functions are not subject to being advised and
not listed in A. We also assume the type information of all the functions collected in the previous step of AspectFun to EA
conversion is stored in Γbase. The function | · | returns the cardinality of a sequence of objects.
5 This notion of ‘‘coherence’’ is different from the coherence concept defined in qualified types [9]which states that different translations of an expression
are semantically equivalent.
1060 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
This condition basically means that under a given typing environment, a function’s type is no more general than any of its
advice. For instance, under the environment Γ = {n1 : ∀a.[a] → [a] FG f, n2 : Int → Int FG f}, wvΓ (f : b→ b) is false
because the type is not specific enough to determine whether n1 and n2 should apply whereas wvΓ (f : Bool → Bool) is
vacuously true and, in this case, no advice applies. Note that since unification and matching are defined on types instead of
type schemes, quantified variables are freshly instantiated to avoid name capturing. In this paper, we sometimes omit the
typing environment part of the weavable constraint when it is clear from the context.
There are three rules for variable lookups. Rule (Var) is standard. Complementarily, in the case that variable x is advised
(x ∈ A), there are two rules, (Var-A) and (Var-P), for handling it, depending on type context underlying the occurrence
of x. Essentially, when the weavable condition holds, rule (Var-A) applies; otherwise, rule (Var-P) does. The details are as
follows.
Rule (Var-A) will create a fresh instance t ′ of the type scheme bound to x in the environment. Then we check weavable
condition of (x : t ′). If the check succeeds (i.e., x’s input type is no more general or equivalent to those of the advice with
unifiable types), x will be chained with the translated forms of all the advice defined on it, having equivalent or more
general types than x has (the selection is done by [ni|ti D t ′]). We coerce all these pieces of selected advice to have non-
advised type during their translation Γ ` ni : t ′  ei. This ensures correct weaving of advice advising the bodies of
the selected advice. The detail will be elaborated in Section 4.6. Finally, the translated expression is normalized by bringing
all the advice abstractions of x outside the chain 〈. . .〉. This ensures type compatibility between the advised call and its
advice.
If the weavable condition check fails, there must exist some advice for xwith more specific types, and rule (Var-A) fails
to apply. Since x ∈ A still holds, rule (Pred) can be applied, which adds an advice predicate to a type. (Note that we only
allow sensible choices of t constrained by tx D t .) Correspondingly, its translation yields a lambda abstraction with an advice
parameter. This advice parameter enables concrete advice-chained functions to be passed in at a later stage, called releasing,
through the application of rule (Rel). Before releasing, any occurrences of an advice parameter in the contextwill be handled
by rule (Var-P), and remains intact.
To sum up, variables that are not advised are handled by rule (Var). Advised variables whose type instantiations satisfy
the weavable condition are handled by rule (Var-A). In other situations, variables are turned to an advice parameter by rule
(Pred) and then handled by rule (Var-P).
We illustrate the application of rules (Pred) and (Rel) by deriving the type and the woven code for the program shown
in Example 2. We use C as an abbreviation for Char . During the derivation of the definition of h, we have:
Γ = { f :∗ ∀a.a→ a  f, n1 : ∀a.a→ a FG f,h  n1, n2 : ∀b.[C] → [C] FG f  n2}
f{t} : t → t  df ∈ Γ2
(Var-P)
Γ2 ` f{t} : t → t  df
x : t  x ∈ Γ2
(Var)
Γ2 ` x : t  x
(App)
Γ2 = Γ1.x : t  x ` (f{t} x) : t  (df x)
(Abs)
Γ1 = Γ , f{t} : t → t  df ` λx : t.(f{t} x) : t → t  λx.(df x)
(Pred)
Γ ` λx : t.(f{t} x) : (f{t} : t → t).t → t  λdf .λx.(df x)
Next, for the derivation of the first element of the main expression, h "d", we have:
Γ3 = { f :∗ ∀a.a→ a  f, n1 : ∀a.a→ a FG f,h  n1,
n2 : ∀b.[C] → [C] FG f  n2, h :∗ ∀a.(f{a} : a→ a).a→ a  h}
A B
(Rel)
Γ3 ` h{[C]} : [C] → [C]  (〈h{[C]} , {n1}〉) 〈f{[C]} , {n1, n2}〉
. . .
(App)
Γ3 ` (h{[C]} "d") : [C]  〈h{[C]} , {n1}〉 〈f{[C]} , {n1, n2}〉 "d"
where
A = h :∗ ∀a.(f{a} : a→ a).a→ a  h ∈ Γ3 . . .(Var-A)
Γ3 ` h{[C]} : (f{[C]} : [C] → [C]).[C] → [C]  〈h{[C]} , {n1}〉
and
B = f :∗ ∀a.a→ a  f ∈ Γ3 . . .(Var-A)
Γ3 ` f{[C]} : [C] → [C]  〈f{[C]} , {n1, n2}〉
We note that rules (Abs), (Let) and (App) are rather standard. Rule (Let) only binds f with : (instead of with :∗) which
signalizes locally defined functions are not subject to advising.
Rules (Pred) and (Rel) introduce and eliminate advice predicates respectively. Rule (Pred) adds an advice predicate to
a type. Correspondingly, its translation yields a lambda abstraction with an advice parameter. At a later stage, rule (Rel)
1062 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
eM : Expressions containing advice chains
[[·]] : eM −→ Expanded expression
[[x = e1 in e2]] = x = [[e1]] in [[e2]]
[[let x = e1 in e2]] = let x = [[e1]] in [[e2]]
[[λx : t.e]] = λx : t.[[e]]
[[e1 e2]] = [[e1]] [[e2]]
[[Λa.e]] =Λa.[[e]]
[[e{t}]] = [[e]]{t}
[[x]] = x
[[proceed]] = proceed
[[〈f {t¯} e , {}〉]] = [[f {t¯} e]]
[[〈f {t¯} e , {ea, eadvs}〉]] = proceedApply(ea, 〈f {t¯} e , {eadvs}〉)
proceedApply(n{t¯} e, k) = [[n{t¯} e k]] if rank(n) = 0
proceedApply(〈n{t¯} e , {ns}〉, k)= [[〈n{t¯} e k , {ns}〉]] otherwise
rank(x) =
1 if x ≡ 〈f {t¯} e , {}〉1+maxi rank(eai) if x ≡ 〈f {t¯} e , {ea}〉0 otherwise
typeErase : Expanded expression −→ Implicit AspectFun
typeErase(x = e1 in e2) = x = typeErase(e1) in typeErase(e2)
typeErase(let x = e1 in e2) = let x = typeErase(e1) in typeErase(e2)
typeErase(λx : t.e) = λx.typeErase(e)
typeErase(e1 e2) = typeErase(e1) typeErase(e2)
typeErase(Λa.e) = typeErase(e)
typeErase(e{t}) = typeErase(e)
typeErase(x) = x
typeErase(proceed) = proceed
Fig. 10. Definition of chain expansion.
After applying chain expansion and type erasing, the final result is the following AspectFun expression:
nscope proceed arg = proceed (tail arg) in
n proceed arg = proceed arg in
n2nd proceed arg = proceed arg in
f x = x in
g df x = (df x, f (x, x), nscope f [x]) in
h x = (\df. n2nd (n (g df))) (nscope f) [x] in
k df x = (\df. n2nd (n (g df))) df x in
(h 1, k f 2)
4.5. Advising recursive functions
We have seen our predicating/releasing systemwork for non-recursive function. However, if we apply rule (Rel) to a call
of an advised recursive function, it may end up looping infinitely.
Let us illustrate thiswith an example of advising recursive functions.Many listmanipulation functions, such asreverse,
append, and union, can be written in a recursive pattern in which their accumulating parameter is simply returned when
their input parameter is empty.6We can capture this pattern using a piece of advice. Herewe focus on the reverse function
to illustrate our scheme. The dummy advice n1 in the following program is necessary for demonstrating the issue involved.
n@advice around {reverse, append, setUnion} (arg) =
\y -> if (null arg) then y else (proceed arg) y in
n1@advice around {reverse} (arg::[Bool]) = proceed arg in
reverse :: [a]->[a]->[a]
reverse x accum = reverse (tail x) (cons (head x) accum) in
reverse [1,2] []
After conducting type inference of advice n, n1 and function reverse, we obtain the following result (we omit the
irrelevant translation part for the moment). We write tr as an abbreviation of [a] → [a] → [a].
Γ = { n : ∀ab.[a] → b→ b, n1 : ∀a.[Bool] → a, reverse :∗ ∀a.(reverse : tr).tr}
6 The second input of append can be seen as an accumulator parameter. A similar argument applies to union.
1064 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
Now consider the call to g in the body of h’s definition. The type context for g is a → a, which is proper for weaving
its advice n3. Consequently, the call to f inside the body of n3 is also of type a→ a. However, this type is not sufficiently
specific for advising f. As a result, we have to give h an advised type with g:a->a as the predicate. The program is then
translated as follows.
n1 proceed arg:Int = proceed arg in
n2 proceed arg = proceed arg in
f x = x in
n3 df proceed arg = df arg in
g x = x in
h dg x = dg x in
h <g,{n3 <f,{n1,n2}>}> 1
Note that advice n3 is only chained in the main expression where the context is sufficiently specific for both the calls to g
and f.
Nested advice that applies to the execution of its own body merits further discussion because such advice becomes
mutually dependent on the functions it advises. On the one hand, we can employ this dependency to achieve modular and
adaptive code reuse for recursive functions. Recall the eval function and its advice cbn presented in Example 1 (Section 2).
Inside cbn, function eval is invoked, which in turn will trigger cbn to ensure the evaluation strategy is changed to call-by-
name completely.
On the other hand, such a piece of advice must be handled with care because it may make the weaver non-terminating
as the case of recursive functions. Consider the following program with a list function f and two pieces of advice, n and n1,
on f.
n@advice around {f}(arg) = if null arg then arg else f (tail arg) in
n1@advice around {f}(arg::[Int]) = proceed arg in
f (x:xs) = xs in
f [1,2,3]
Here advice n on function f invokes f inside its body, thus forming a cycle between f and itself. In other words, function f
and advice n are just like two mutually recursive functions. Hence we can translate the example using the same technique
of (Rel-F) rule as follows.
n df proceed arg = (if (null arg) then arg
else (df (tail arg))) in
n1 proceed arg = (proceed arg) in
f (x:xs) = xs in
(let VF = <f,{n VF, n1}> in VF) [1,2,3]
However, if we modify the body of advice n by supplying a different type of argument, say [arg], to the call to f, then
the static weaver will run into an infinite releasing loop when handling the main expression. The reason is obvious: the
static weaving of a piece of advice requires releasing of some predicate, (f : t), which in turn, directly or indirectly, calls for
releasing of another predicate on identical advisee, f , but with a structurally increasing type, say [t]. Such vicious circular
advice that crashes the static weaver will also cause the program to loop even when weaving is done at run time. Therefore,
we choose to reject such advice statically by enhancing the rules (Adv) and (Adv-an)with a sanity check that identifies such
predicate cycles. Specifically, after translating an advice declaration, for each predicate of the advice, the static weaver will
compute the set of predicates that will be released when the underlying advice is woven. If there exist multiple predicates
on the same advisee with structurally increasing types in the set, the weaver will reject the program.
Lastly, we note that, besides the cycles formed from cyclical calls of advice and functions, there is onemore kind of cycles
that can be created, namely cycles formed through triggering of two or more pieces of advice. This is possible because of
the presence of second-order advice. However, we do not see any practical value of having such a circular set of advice and
insist on a stratified approach to declaring advice. In this approach, programs with circular set of advice will be spotted by
our dependency analysis step and rejected.
4.7. Unresolved advice predicates
A problem inherent with our advised type approach to static weaving is the possibility of unresolved advice predicates.
For example, consider the following AspectFun program:
n@advice around {f} (arg::[Char]) = proceed (tail arg) in
f l = length l in
g i = i + f [] in
g 5
1066 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
if
E∗;A∗ ` e∗ ⇓ v∗ iff E;A ` e ⇓ v andA∗;A ` v∗ ∼= v : σ
whereA∗;A ` v∗ ∼= v : σ is defined by:
A∗;A ` c ∼= c : σ
A∗;A ` (|Λb∗. e∗1, E∗1 |) ∼= (|Λb. e1, E1|) : ∀a.σ1
iff ∀t, (E∗1 ,A∗); (E1,A) ` [t/b∗]e∗1 ' [t/b]e1 : σ1
A∗;A ` (|e∗1, E∗1 |) ∼= (|e1, E1|) : t1 → t2
where e∗1 and e1 are both lambda expressions
iff (E2,A∗); (E3,A) ` e2 ' e3 : t1 implies
(E2,A
∗); (E3,A) ` (|e∗1, E∗1 |) e2 ' (|e1, E1|) e3 : t2
We shall omit the type scheme σ when it is obvious from the context.
Note that we can also extend the above equivalence to relate two open EA programs since all top-level declarations of an
EA program will be turned into a thunk and put into the environment or advice store for evaluating the main expression.
As an example of the equivalence relation, consider the definition of g in Example 3 (Section 3.2): g x = (f x, f(x,
x), f [x]). In particular, we focus on the part in which function f is applied to a list argument [x], namely f {[a]}
[x] in the explicitly typed version. As described in Section 4.4, after static weaving, this occurrence of function f is woven
with advice nscope as <f {[a]}, {nscope {a}}> and is subsequently expanded to nscope {a} (f {[a]}). It is
easy to show that
(E∗,∅); (E,A) ` nscope {a} (f {[a]}) ' f {[a]}
where E∗ is the operational semantics environment with static weaving done while (E,A) is the original operational
semantics context.
First, the left-hand side expression, (nscope {a} (f {[a]})), will be evaluated to a closure of the lambda expression
\arg:[a].proceed (tail {a} arg) and an environment in which proceed is bound to the value of f {[a]}.
On the other hand, when the right-hand side expression, f {[a]} is evaluated and applied to [x], by the definition of
Trigger, the advice nscopewill be triggered and woven to f {[a]}, resulting in the same closure. Hence, by the definition
of∼=, the two expressions are equivalent.
Next, we give a definition which ensures that the type bindings in a static weaving environment are consistent with
those of the expressions kept by an operational semantics context. Note that, as the static weaver will eventually convert all
advice declarations into normal function declarations, the woven expression will be evaluated in an operational semantics
context with an empty advice store. Therefore, we provide two definitions for specifying consistency of type bindings: one
for the general operation semantics contexts and the other for the specialized contexts in which the advice store is empty,
thus relating only the operational semantics environment. Both are specified in terms of the three forms of bindings which
may occur in a static weaving environment. Essentially, the general definition of consistency states the condition before
performing static weaving while the specialized one for the case after static weaving is done. For brevity, we refer to both
definitions of consistency as respect of environment.
Definition 3 (Respect of Environment). An operational semantics environment E and an advice store A are said to respect
a static weaving environment Γ , written as (E,A) ∝ Γ , if the domains of E andA are disjoint and the union of them are as
large as the domain of Γ , and for every x in the domain of Γ ,
1. if x : ∀a¯.ρ  x ∈ Γ then [x 7→ (|ex, E ′|)] ∈ E , and Γ ′ ` ex{a¯} : ρ for any Γ ′ satisfying (E ′,A) ∝ Γ ′.
2. if x{t¯} : ρ  dx ∈ Γ then [x 7→ (|ex, E ′|)] ∈ E , and Γ ′ ` ex : ρ for any Γ ′ satisfying (E ′,A) ∝ Γ ′.
3. if x : ∀a¯.p¯.ty → tx FG f  x ∈ Γ then (x : ∀a¯.ty → tx, pc, ty, (|ex, E ′|)) ∈ A, and Γ ′ ` ex{a¯} : p¯.ty → tx for any Γ ′
satisfying (E ′,A) ∝ Γ ′.
The specialized version of respect of environment relation holds without the advice store. Specifically, an operational
semantics environment E∗ is said to respect a static weaving environment Γ , written as E∗ ∝ Γ , if the domain of E∗ is as
large as that of Γ and for every x in the domain of Γ ,
1. if x : ∀a¯.ρ  x ∈ Γ then [x 7→ (|e∗x , E ′|)] ∈ E∗, and Γ ′ ` e∗x {a¯} : ρ for any Γ ′ satisfying E ′ ∝ Γ ′.
2. if x{t¯} : ρ  dx ∈ Γ then [dx 7→ (|e∗x , E ′|)] ∈ E∗, and Γ ′ ` e∗x : ρ for any Γ ′ satisfying E ′ ∝ Γ ′.
3. if x : ∀a¯.ρ FG f  x ∈ Γ then [x 7→ (|e∗x , E ′|)] ∈ E∗, and Γ ′ ` e∗x {a¯} : ρ for any Γ ′ satisfying E ′ ∝ Γ ′.
Besides consistency of type bindings,we need to define the consistency of binding definitions common in two operational
semantics contexts. Yet, as advice predicates may appear in the binding definitions produced by static weaving, we cannot
apply the' directly to relate them to those in the operational semantics context of the source program. Hence, we need to
provide a conditional form of equivalencewhichmatches an EA expressionwith advice predicates to a pure EA expression in
away that is compliantwith the' relation and satisfies the underlying advice predicates. First, we notice that the predicates
created during static weaving can be realized at run time through functions – and their associated advice – of appropriate
types. This is captured by the notion of feasibility.
1068 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
Definition 7 (AdviceName and AdviceSet).
AdviceSet(λy¯.〈f y¯ , {e¯}〉) = {AdviceName(ei) | ei ∈ e¯}
AdviceName(e) = case e of
n dg → n
〈n dg , {adv}〉 → n
AdviceUnifiers(e, t) = let (AdviceName(e) : ∀a¯.tn, . . .) ∈ A
[t¯/a¯]tn = t
in t¯
The first lemma shows that the set of advice selected by (Var-A) rule is the same as those returned by Choose function of
the operational semantics.
Lemma 1 (Advice Selection). If (E,A) ∝ Γ , and Γ ` f {t¯} : p¯.t1 → t2  λdp.〈f {t¯} dp , {e¯∗}〉, then for any type substitutions
S we have AdviceSet(λdp.〈f {t¯} dp , {e¯∗}〉) = Names(Choose(f , St1)) where Names(s) = {n | (n : σn, . . .) ∈ s}.
The second lemma shows that the chain expression assembled by (Var-A) rule is consistent with the source expression
under the same program context.
Lemma 2 (Consistency of chain expressions). Suppose that E∗
Γ∞ (E,A). If
1. Γ ` f {t¯} : p¯.t  λdp.〈f {t¯} dp , {e∗0, e∗1, . . . , e∗n}〉, f v(p¯) ⊆ f v(t), and
2. for i = 0, 1, . . . , n, let (AdviceName(e∗i ) : σi, pc i, (|ei, Ei|)) ∈ A,
E∗; (Ei[proceed 7→ epr ],A) ` proceedApply(e∗i , e∗pr)
Γ∞ ei{AdviceUnifiers(e∗i , t)} : t,
holds for all (E∗,∅); (Ei,A) ` e∗pr ' epr ,
then
E∗; (E,A) ` λdp.〈f {t¯} dp , {e¯∗}〉 Γ∞ f {t¯} : p¯.t.
Given the above lemmas, we prove the following theorem which states that, under consistent contexts and the static
weaving environment derived from an EA program, any expressions produced by the static weaver will be consistent with
their corresponding source expressions.
Theorem 1 (Soundness of Expression Weaving). If E∗
Γ∞ (E,A), Γ ` e : p¯.t  e∗, and f v(p) ⊆ f v(t), then E∗; (E,A) `
e∗
Γ∞ e : p¯.t.
Finally, we prove that the static weaver maintains the consistency of contexts when processing all forms of top-level
bindings of an EA program. Thus, combined with the above theorem, we establish the correctness of our static weaving
scheme, as the following theorem shows.
Theorem 2 (Soundness of Static Weaving). Let pi0 be an EA program. If ∅ ` pi0 : t  pi∗0 , then ` [[pi∗0 ]] ' pi0 : t.
6. Related work
6.1. Aspect-oriented languages
Two works closely related to ours are AspectML [5,4] and Aspectual Caml [15]. Both works have made many significant
results in supporting polymorphic pointcuts and advice in strongly typed functional languages such as ML. While these
works have introduced some expressive aspect mechanisms into the underlying functional languages, they have not
successfully reconciled coherent and static weaving — two essential features for an aspect-oriented functional language
we investigated in this paper.
AspectML [5,4] advocates first-class join points for constructing generic aspect libraries. In order to support non-
parametric polymorphic advice, AspectML includes case-advice which is similar to our type-scoped advice. Its type system
is a conservative extension to the Hindley–Milner type inference algorithm with a form of local type inference based on
some required annotations. During execution, advice is looked up through labels and run-time type analysis is performed
to handle the matching of type-scoped pointcuts. This completely dynamic mechanism gives additional expressiveness by
allowing run-time advice introduction. However, many optimization opportunities are lost as advice triggering information
is not present during compilation. Lastly, advice is anonymous in AspectML and apparently not intended to be the targets
of advising, i.e. no second-order advice.
Aspectual Caml [15] supports static typing and weaving. In particular, type inference on advice is carried out without
consulting the types of the functions designated by the pointcuts. Similar to AspectML, it allows a restricted form of type-
1070 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
Appendix. Proof of correctness of static weaving
In this appendix, we give in detail the proof of correctness of static weaving. After presenting a few straightforward
propositions, we shall prove the key lemmas and theorems stated in Section 5. Note that, as in the main text, e is used to
stand for an EA source expression and e∗ for the result of static weaving.
We begin by listing down some properties about operational semantics and basic properties about expression
equivalence.
Proposition 1. If we write (E∗,A∗); (E,A) ` e∗ ' e in a different form
(e∗; E∗,A∗) ' (e; E,A)
then it is an equivalence relation, that is, satisfying reflexivity, symmetry, and transitivity.
Proposition 2. Given an EA expression e∗ and an annotated lambda expression λf :tf x : tx.e, if (E∗,A∗); (E,A) ` e∗ '
Trigger((|λx : tx.e, E1|), f : tf ), then (E∗,A∗); (E1,A) ` e∗ ' λf :tf x : tx.e, and vice versa.
Proposition 3. If (E,A) ` e ⇓ v then, for any x ∈ dom(E), we always have (E,A) ` [E(x)/x]e ⇓ v.
Lemma 1 (Advice Selection). If (E,A) ∝ Γ , and Γ ` f {t¯} : p¯.t1 → t2  λdp.〈f {t¯} dp , {e¯∗}〉, then for any type substitutions
S we have AdviceSet(λdp.〈f {t¯} dp , {e¯∗}〉) = Names(Choose(f , St1)) where Names(s) = {n | (n : σn, . . .) ∈ s}.
Proof.
1. We first show that the translation in the lemma is derived via (Var-A) rule. This is proved by induction on the number
of predicates in p¯ as follows.
If p¯ is empty, then clearly the translation is just an instance of (Var-A) rule due to the presence of advice chain. Suppose
that when p¯ contains n predicates, it is still an instance of (Var-A). Now assume that there are n+1 predicates in p¯. If the
outermost predicate is generated by applying the (Pred) rule, then we have the derivation, Γ .x{t¯ ′} : t  xt ` e : ρ  e∗t
where ρ has n predicates and t is the type instantiating the type scheme of x. By the induction hypothesis, this translation
is derived via (Var-A) rule and e ≡ x is an advised function. This contradicts the condition of the (Pred) rule. Since no
other rule produces a translation with the given form of predicated typed and chain expression except (Var-A), the
translation in the lemma is indeed an instance of (Var-A), on an advised function, f {t¯}.
2. We then prove the lemma in two steps:
(a) if Γ ` f {t¯} : p¯.t  e∗c and Γ ` f {St¯} : S(p¯.t)  e∗d , then AdviceSet(e∗c ) = AdviceSet(e∗d).
(b) if Γ ` f {St¯} : S(p¯.t1 → t2)  λdp.〈f {St¯} dp , {e¯∗}〉 then
Names(Choose(f , St1)) = AdviceSet(λdp.〈f {St¯} dp , {e¯∗}〉)
Combining these two steps yields the set equality in the lemma.
(a) From the premise of (VAR-A), we must have AdviceSet(e∗c ) ⊆ AdviceSet(e∗d). Hence it suffices to show that
AdviceSet(e∗d) ⊆ AdviceSet(e∗c ). This is done by contradiction, as follows.
Assume that there exists an advice binding n : ∀b¯.q¯.tn FG f such that tn D St but tn 6D t . Let t1 → t2 = t and
tk → tnk = tn. By tn D St , we have tk D St1, which in turn implies that tk and t1 are unifiable. So, by the condition
wv(f : t1 → t2), we have tn D t . This contradicts the assumption.
Since no such advice exists, AdviceSet(e∗d) ⊆ AdviceSet(e∗c ).
(b) Let Aset = AdviceSet(λdp.〈f dp , {e¯∗}〉), Cset = Names(Choose(f , St1)). By (E,A) ∝ Γ ,
ni : ∀b.q.ti → tni FG f ∈ Γ ⇔
(ni : ∀α.τx → τni , pci, τi, ei) ∈ A ∧ ∃pc ∈ pci. JPMatch(f , pc) ≡ true
Let us consider the advice selection criteria for both Aset and Cset . For advice ni to be selected in Aset , (Var-A) requires
that ti → tni D t1 → t2. By contrast, Cset requires that ti D t1 according to Choose(f , t1).
First, it is easy to see that Aset ⊆ Cset since ti → tni D t1 → t2 implies ti D t1.
Second, we show that Cset ⊆ Aset by assuming otherwise and get a contradiction due to (E,A) ∝ Γ . If there exists
an advice nk with type ∀b¯.p¯′.tk → tnk such that nk ∈ Cset but not Aset . Then, tk D t1 but S1tnk 6D S1t2 where t1 = S1tk.
Let ∀a¯.p¯.tf1 → tf2 = Γ (f ), then (t1 → t2) = [St¯/a¯](tf1 → tf2). Consider the kinds of advice binding for nk.
(i) (Adv): By the condition of (Adv), tk → tnk D tf1 → tf2 , which in turn implies that tnk D t2 since
tf1 → tf2 D t1 → t2. This contradicts the assumption.
(ii) (Adv-An): By the condition of (Adv-An), there exists a substitution S0 such that
tk = S0tf1
and tnk D S0tf2 (1)
Then t1 = S1S0tf1 , i.e. S1S0 = [St¯/a¯]. Hence by (1),
S1tnk D S1S0tf2 = [St¯/a¯]tf2 = t2
This contradicts the assumption.
Since no such advice exists, we conclude that Cset ⊆ Aset . 
1072 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
Let (n1 : ∀b¯.tn, pc, ty, (|Λb¯.λn1:tny : ty.en, En|)) ∈ A. We reduce the RHS of (2) according to the definitions ofWeave (in Fig. 6)
and get
[Stn/b¯]tn = S ′tf
ep = Weave((|λx : S ′tx.S ′ef , E1|), S ′tf , {A(n2), . . . ,A(nm)})
ea = [Stn/b¯]en
RHS = Trigger((|λy : [Stn/b¯]ty.ea, En[proceed 7→ ep]|), n1 : [Stn/b¯]tn) ; E,A
by Proposition 2
' λn1:[Stn/b¯]tny : [Stn/b¯]ty.ea ; En[proceed 7→ ep];A
' (Λb¯.λn1:tny : ty.en){Stn} ; En[proceed 7→ ep];A
Thus, we need to show that
(E∗0 ,∅); (En[proceed 7→ Weave((|λx : S ′tx.S ′ef , E1|)], S ′tf , {A(n2), . . . ,A(nm)}),A)
` proceedApply(Se∗1, S〈f {t¯} dp , {e∗2, . . . , e∗m}〉) ' (Λb¯.λn1:tny : ty.en){Stn} : S ′tf (∗)
By the assumption of the lemma,
E∗0 ; (En[proceed 7→ epr ],A) ` proceedApply(e∗1, e∗pr)
Γ∞ (Λb¯.λn1:tny : ty.en){tn} : t
Applying Definition 5 with the same S, we see that (*) holds if
(E∗0 ,∅); (E,A) ` e∗pr ≡ [[S〈f {t¯} dp , {e∗2, . . . , e∗m}〉]] '
epr ≡ Weave((|λx : S ′tx.S ′ef , E1|), S ′tf , {A(n2), . . . ,A(nm)})
But this is immediate from the induction hypothesis for the length (|e¯∗| = m− 1), and the lemma is proven. 
A special case of Definition 5 occurs when there is no predicates on type. In such a case, we do not have to consider ep in
Definition 5, which yields a stronger proposition.
Proposition 4. If E∗; (E,A) ` e∗ Γ∞ e : p¯.t and p¯ is empty, then (E∗,∅); (E,A) ` [[Se∗]] ' Se : St for any type substitution
S.
Theorem 1 (Soundness of Expression Weaving). If E∗
Γ∞ (E,A), Γ ` e : p¯.t  e∗, and f v(p) ⊆ f v(t), then E∗; (E,A) `
e∗
Γ∞ e : p¯.t.
Proof. Weagain strengthen the statement by allowing e to be an advice namewith type application andprove it by induction
on the height (h) of the derivation tree for Γ ` e : p.t  e∗.
When e is advice n{AdviceUnifiers(e∗i , t)}, respect relation is replaced by E∗; (En[proceed 7→ ep],A) `
proceedApply(e∗, e∗p)∞ en{AdviceUnifiers(e∗i , t)} : p¯.t for all (E∗,∅); (En,A) ` e∗p ' epwhere (n : σn, pc, tx, (|en, En|)) ∈ A
as in Lemma 2.
Induction basis (h = 1):
There are only two cases, namely (Var) and (Var-P), and e ≡ x{t¯} for some variable, function, or advice x that
x : σ  e∗ ∈ Γ or x{t¯} : t  dx ∈ Γ . Both cases are direct from E∗ Γ∞ (E,A).
Induction step:
Suppose that the respect condition hold for all derivation trees of height less than h. We prove that, for an expression e
with a derivation tree, Γ ` e : p¯.t  e∗, of height h. Consider the last step of the derivation:
Case (Pred): We have a derivation of the form:
x :∗ ∀a¯.p¯x.tx ∈ Γ [t¯/a¯]tx D t1
Γ .x{t¯} : t1  dx ` e : q.t  e∗t
Γ ` e : (x{t¯} : t1).q.t  λdx.e∗t
Hence, p ≡ (x{t¯} : t1).q and e∗ ≡ λdx.e∗t . We need to show that
E∗; (E,A) ` λdx.e∗t
Γ∞ e : (x{t¯} : t1).q¯.t
According to Definition 5, assuming dp are fresh, when given S and (|e∗p, E∗|) m S(x{t¯} : t1).Sq¯, we show that
E∗[dp 7→ (|e∗p, E∗|)]; (E,A) ` [[Se∗t dp]] ' Se : St (3)
Since p¯ ≡ (x{t¯} : t1).q, we can write (|e∗p, E∗|) as (|e∗x , E∗|).(|e∗q, E∗|), dp = dx.dq such that (|e∗x , E∗|) m S(x{t¯} : t1).
1074 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
Case (Abs): We have a derivation of the form:
Γ .x : t1  x ` eb : t2  e∗b
Γ ` λx : t1.eb : t1 → t2  λx : t1.e∗b
Induction hypothesis gives that for all E∗1
Γ .x:t1 x∞ (E1,A), E∗1 ; (E1,A) ` e∗b ∞ eb : t2.
Given any pair of expressions ex and e∗x with (E∗,∅); (E,A) ` e∗x ' ex : t1, it is obvious that
E∗[x 7→ (|e∗x , E∗|)]
Γ .x:t1 x∞ (E[x 7→ (|ex, E |)],A)
So we can assign the left-hand side to E∗1 , the right-hand side to (E1,A1), and apply Proposition 4 getting
(E∗1 ,∅); (E1,A) ` Se∗b ' Seb : St2
for all type substitution S. Thus
(E∗,∅); (E,A) ` Sλx : t1.e∗b ' Sλx : t1.eb : S(t1 → t2)
⇒ E∗; (E,A) ` λx : t1.e∗b
Γ∞ λx : t1.eb : t1 → t2
Case (App): By straightforward induction on e1 and e2 of (e1 e2). 
Theorem 2 (Soundness of Static Weaving). Let pi0 be an EA program. If ∅ ` pi0 : t  pi∗0 , then ` [[pi∗0 ]] ' pi0 : t.
Proof. We use a stronger proposition to prove it. Suppose E∗
Γ∞ (E,A). If Γ ` pi : t  pi∗ for a sub-program pi of pi0,
i.e. pi0 ≡ d0.pi , then (E∗,∅); (E,A) ` [[pi∗]] ' pi : t . Afterwards, the original result of the theorem can be obtained by
assigning ∅ to Γ , E∗, E ,A and d0.
Let pi ≡ d¯.e. We prove the above proposition by induction on the length of declarations of pi , |d¯|.
Induction basis:
|d¯| = 0: we havepi ≡ e. Since the type of a program is restricted to non-predicated type, this case is a direct consequence
of Theorem 1 and Proposition 4.
Induction step:
When the proposition holds for pi with length(d¯) = k, we shall prove it for pi1 with length(d¯) = k+ 1. Let pi1 ≡ d.pi . The
Induction step to prove is that if E∗1
Γ1∞ (E1,A1) and Γ1 ` pi1 : t1  pi∗1 then (E∗1 ,∅); (E1,A1) ` [[pi∗1 ]] ' pi1. We prove it
by a case analysis on d and induction on the derivation for Γ1 ` d.pi : t1  pi∗1 :
Case (Global): We have a derivation of the form:
Γ1 ` ex : p¯.tx  e∗x Γ1.x : ∀a¯.p¯.tx  x ` pi : t1  pi∗
Γ1 ` x = Λa¯. ex in pi : t1  x = Λa¯. e∗x in pi∗
Given Γ1 ` ex : p¯.tx  e∗x , by Theorem 1, E∗1 ; (E1,A1) ` e∗x
Γ1∞ ex : p¯.tx. And by E∗1
Γ1∞ (E1,A1) and Definition 6,
Γ ≡ Γ1. x : ∀a¯.p¯.tx  x
E∗ ≡ E∗1 [x 7→ (|[[Λa¯. e∗x ]], E∗1 |)]
Γ∞ (E1 [x 7→ (|Λa¯. ex, E1|)],A1) ≡ (E,A)
Thus, by the induction hypothesis of the second premise, Γ ` pi : t1  pi∗, we have
(E∗,∅); (E,A) ` [[pi∗]] ' pi : t1
Combining with
(E∗1 ,∅); (E∗,∅) ` [[pi∗1 ]] ≡ x = [[Λa¯. e∗x ]] in [[pi∗]] ' [[pi∗]] : t1
(E1,A1); (E,A) ` pi1 ≡ x = Λa¯. ex in pi ' pi : t1
implies (E∗1 ,∅); (E1,A1) ` [[pi∗1 ]] ' pi1 : t1.
Case (Adv): We have a derivation of the form:
Γ1.proceed : tn  proceed ` λx : tx.ea : p¯.tn  e∗a
fi : ∀b¯.ti ∈ Γbase tn D [t¯/b¯]ti Γ1.n : ∀a¯.p¯.tn FG f¯  n ` pi : t1  pi∗
Γ1 ` n :: ∀a¯.tn@advice around {f¯ } (x) = ea in pi : t1
 n = Λa¯.addProceed(e∗a, tn) in pi∗
with tx being the argument part of tn.
1076 K. Chen et al. / Science of Computer Programming 75 (2010) 1048–1076
[11] G. Kiczales, J. Lamping, A. Menhdhekar, C. Maeda, C. Lopes, J.-M. Loingtier, J. Irwin, Aspect-oriented programming, in: M. Akşit, S. Matsuoka
(Eds.), in: Proceedings European Conference on Object-Oriented Programming, vol. 1241, Springer-Verlag, Berlin, Heidelberg, and New York, 1997,
pp. 220–242.
[12] R. Lämmel, S. Peyton Jones, Scrap your boilerplate: a practical design pattern for generic programming, in: Proceedings of the ACM SIGPLANWorkshop
on Types in Language Design and Implementation, TLDI 2003, ACM SIGPLAN Notices 38 (3) (2003) 26–37.
[13] R. Lämmel, S. Peyton Jones, Scrap your boilerplate with class: extensible generic functions, in: Proceedings of the ACM SIGPLAN International
Conference on Functional Programming, ICFP 2005, ACM Press, 2005, pp. 204–215.
[14] J.R. Lewis, M. Shields, J. Launchbury, E. Meijer, Implicit parameters: dynamic scoping with static types, in: Symposium on Principles of Programming
Languages, 2000, pp. 108–118.
[15] H. Masuhara, H. Tatsuzawa, A. Yonezawa, Aspectual Caml: an aspect-oriented functional language, in: Proc. of the Tenth ACM SIGPLAN International
Conference on Functional Programming, ACM Press, 2005, pp. 320–330.
[16] P. Wadler, Theorems for free! in: FPCA’89: Proceedings of the Fourth International Conference on Functional Programming Languages and Computer
Architecture, ACM, New York, NY, USA, 1989, pp. 347–359.
[17] P. Wadler, The essence of functional programming, in: Proc. of the 19th Annual ACM Symposium on Principles of Programming Languages,
Albuquerque, NM, ACM Press, 1992, pp. 1–14.
[18] P. Wadler, S. Blott, How to make ad-hoc polymorphism less ad-hoc, in: Conference Record of the 16th Annual ACM Symposium on Principles of
Programming Languages, ACM, 1989, pp. 60–76.
[19] M.Wand, G. Kiczales, C. Dutchyn, A semantics for advice and dynamic join points in aspect-oriented programming, ACMTransactions on Programming
Languages and Systems 26 (5) (2004) 890–910.
[20] M. Wang, K. Chen, S.-C. Khoo, On the pursuit of static and coherent weaving, in: Foundations of Aspect-Oriented Languages Workshop at AOSD 2006.
Iowa State University, TR 06-01, 2006, pp. 37–46.
[21] M. Wang, K. Chen, S.-C. Khoo, Type-directed weaving of aspects for higher-order functional languages, in: PEPM’06: Workshop on Partial Evaluation
and Program Manipulation, ACM Press, 2006.
[22] M. Wang, B.C.d.S. Oliveira, What does aspect-oriented programming mean for functional programmers? in: P. Jansson (Ed.), Proceedings of the ACM
SIGPLANWorkshop on Generic Programming, WGP’09, ACM, 2009.
[23] G.Washburn, S.Weirich, Good advice for type-directed programming aspect-oriented programming and extensible generic functions, in: Proceedings
of the 2006 ACM SIGPLANWorkshop on Generic Programming, ACM Press, New York, NY, USA, 2006, pp. 33–44.
[24] S. Weirich, Type-safe cast: (functional pearl), in: Proc. of ICFP’00, ACM Press, 2000, pp. 58–67.
21 Introduction
Aspect-oriented programming (AOP) aims at capturing crosscutting concerns. Many
crosscutting concerns are orthogonal to the mainline computation that they interacts
with. A few examples of such concerns are profiling, tracing, and memoization. By their
own nature, aspects that implement such orthogonal concerns do not alter the evalua-
tion result of the base program; their computations are manifested in side-effects. We
refer to such aspects as side-effecting aspects (also know as non-interfering aspects [2]
from a data-flow perspective). Side-effecting aspects are particularly useful because or-
thogonal concerns are more likely to be subject to deploying, updating, and removing
from a software system, a situation where AOP solutions are doubly attractive.
Most aspect-oriented programming languages are based on object-oriented lan-
guages, where uncontrolled side-effects are the norm. The recent surge of interests in
introducing aspect-oriented concepts in functional languages [3,16], in particular in
purely functional languages [1,21,18], poses fresh challenges. Although we can hide
the hairy details of state manipulation by using monads [19], it does require advance
planning, which is fundamentally at odds with the concept of obliviousness in AOP.
Adding monadic effects to a pure program entails a comprehensive rewriting; it is
therefore convenient to support side-effecting directly and automate the process via
source-to-source transformation. Such a technique has been pioneered by La¨mmel [14]
and is referred to as monadification by Erwig and Ren [5]. In many situations, this
convenience comes at a cost: primitive support for side-effects compromises referential
transparency property and all the nice reasoning properties that derive from it. Our
proposal, on the other hand, eliminates the need for compromise between property
preservation and convenience. This is achieved through a carefully designed weaving
scheme, which preserves the non-interfering nature of side-effecting aspects.
In our previous work on AspectFun [1], an aspect-oriented lazy functional language
with a Haskell-like syntax, we have developed a state-based implementation for control-
flow related advice which uses a reader monad to maintain function execution states
(entry and exit) and employs a monadification step to convert the woven program. In
this paper, we generalize this approach to the language level by providing constructs for
writing side-effecting aspects directly and systematic monadification procedures for im-
plementing them. Specifically, we propose to equip AspectFun aspects with user-defined
mutable variables for performing side-effecting operations and extend its compiler with
a more powerful monadification module based on cached state monad transformers to
realize them.
The general vision is clear: a state monad is employed as the repository for mutable
variables and and all functions are lifted into monadic ones. But care must be taken in
implementing of such a scheme. First of all, monadification always imposes an evalua-
tion order, which may or may not be what is desired. Even when a preferred evaluation
order is known up front, it is not a simple task to instruct the monadification process
to faithfully follow in the context of lazy semantics of Haskell. Let’s illustrate this point
by considering a small example involving debugging Haskell programs through tracing
taken from [4].
f x = 3 ‘div‘ x
h = ... -- arbitrarily deep computation
g = h (f 0)
4of top-level declarations followed by a main expression. Top-level definitions include
global variables and function definitions, as well as aspects. An aspect declaration pro-
vides two specifications: An advice, which is a function-like expression named via the
prefix n@; and a pointcut designator , around {pc}, designating when the advice will be
executed. In aspect-oriented programming [11], the specific program execution points
that triggers advice are called join points. Here, we focus on join points at function
invocations. Thus a pointcut basically specifies a function whose invocations may trig-
ger the execution of advice. The act of triggering advice during a function application
is called weaving. When an advice of the form “n@advice around {pc} (arg) = e” is
triggered by a call to a function, say f , the argument variable arg is bound to the
actual argument of the f -call.
Programs pi ::= d in pi | e
Declarations d ::= x = e | f x = e | f :: t→ t |
n@advice around {pc} (arg) = e
Arguments arg ::= x | x :: t
Pointcuts pc ::= ppc | pc+ cf | pc− cf
Primitive PC’s ppc ::= f x | any | any\[f ] | n
Cflows cf ::= cflow(f) | cflow(f( :: t)) |
cflowbelow(f) | cflowbelow(f( :: t))
Expressions e ::= c | x | proceed | λx.e | e e |
if e then e else e | let x = e in e
Types t ::= Int | Bool | a | t→ t | [t]
Predicates p ::= (f : t)
Advised Types ρ ::= p.ρ | t
Type Schemes σ ::= ∀a¯.ρ
Fig. 1 Syntax of the AspectFun Language
Advice may be executed before, after , or around a join point. Specifically, around
advice is executed in place of the indicated join point, allowing the call to the advised
function to be replaced. A special keyword proceed may be used inside the body of
around advice. It is bound to the function that represents “the rest of the computation”
at the advised join point. As both before advice and after advice can be simulated by
around advice that uses proceed, we only consider around advice in this paper.
Precisely, a pointcut, pc, may be either a primitive pointcut or a composite pointcut.
A primitive pointcut, ppc, specifies a function (f) or an advice name (n) the invocations
of which will be advised. A sequence of pointcuts, pc, indicates the union of all the sets
of join points selected by each. A primitive pointcut can also be a catch-all keyword any.
When used, the corresponding advice will be triggered whenever a function is invoked.
Name-based primitive pointcuts can be composed with control-flow based pointcuts
(cflow and cflowbelow) to form composite pointcuts, which inspect the run-time stack
of function execution.
6Let’s look into an example of Fibonacci function fib benefiting from a momoization
aspect to remove repeated computation and a profiling aspect.
Example 1
fib n = if n <= 1 then 1
else fib (n - 1) + fib (n - 2) in
--aspect 1
aspect profiler where
var profileMap :: Map.Map String Int
advice around {fib} (arg) =
let incProfile fname =
set! pMap = getProfileMap;
let newMap =
case of Map.lookup fname pMap of
Nothing -> Map.insert fname 1 pMap
Just v -> Map.insert fname (v+1) pMap
in setProfileMap newMap
in incProfile "fib"; proceed arg in
--aspect 2
aspect memoFib where
var memoMap :: Map.Map Int Int
advice around {fib} (arg) =
case lookupCache arg of
Just v -> v
Nothing -> set! v = proceed arg;
insertCache arg v; v in
fib 10
Caution has to be taken for operations involving state access since the order of
evaluation matters. We use the keyword set! for sequenced bindings. They effectively
force the evaluation of a binding prior to the evaluation of its body, simulating a kind of
eager semantics. In profiler, the auxiliary function incProfilemakes sure the state is
fully evaluated before attempting to update it, removing the risk of a race condition. In
memoFib, the inputs of the state operation insertCache, are evaluated before the state
update. Though it is probably not the only way to correctly implement the momoization
aspect, we enforce the coding convention for the sake of program comprehension.
Besides mutable variables, IO is also an important element for side-effecting as-
pects such as tracing aspects. Hence we also provide a function, putMsg :: String
-> String -> (), for performing output in aspects. The first string parameter is the
name of aspect which puts the second parameter (the message) into an internal buffer.
Together with the getter and setter functions, they form the state API of an aspect.
The second example is a tracing aspect for the tail recursive factorial function,
adapted from Kishon’s thesis work on program monitoring [12].
Example 2
fac n acc = if n == 0 then acc
else fac (n - 1) (n * acc)
8to a monadic style, in order to retain its functional purity. This and the following section
illustrate our monadification transformation for expressions, pure or side-effecting, in
a woven code.
First, we present a general framework for monadifying an expression using an ab-
stract monad, (M, return, >>=), in a non-strict evaluation context, and show that our
monadification scheme possesses good properties with respect to the static and dynamic
semantics of expressions in woven code. Next, in the following section, we specialize M
to a specific state monad in Haskell so that we can also define the monadified version
of those state-aware functions used by side-effecting aspects.
3.1 Monadifying Expressions
Like the pioneering work of La¨mmel [14], our monadification transformation consists
of two major steps, namely A-normalization [7] and monad introduction.
3.1.1 A-Normalization
Given an expression, A-normalization converts it into a form in which every intermedi-
ate computation is assigned a name by a let-expression. Such normalized expressions,
called A-normal form, is a popular intermediate representation used in compilers [7]
and semantic specifications [15] for functional languages. Essentially, in A-normal form,
all applications are applications of an expression to a variable. The arguments of an
application and the condition part of an if-expression are all captured by the binding
parts of let-expressions wrapped around them.3
Let us take the profiling of the fib function presented before as an example. The
input to our A-normalization step is the following woven Haskell code generated by
the AspectFun compiler.
let profiler proceed arg = incProfile "fib";
proceed arg in
let fib n = if n <= 1 then 1
else profiler fib (n - 1) +
profiler fib (n - 2) in
profiler fib 10 --main
The aspect, profiler, becomes an ordinary function with an additional parameter,
proceed that captures the continuation to the advised function. Moreover, all invoca-
tions of the fib function are now left to the profiler function.
After A-normalization, the above profiler program is converted to the following
code.
let profiler proceed arg = incProfile "fib";
proceed arg in
let fib n = let nleq1 = n <= 1 in
if nleq1 then 1
else let nm2 = n - 2 in
3 Note that we conduct alpha renaming along with A-normalization to avoid any name
conflicts.
10
the type of the expression to be monadified. Recall that we conduct the monadifica-
tion transformation after type-directed weaving. Thus the type of every expression is
available in this step. Figure 2 displays the complete set of type-directed rewriting
rules, implicitly parameterized over a monad (M, return,À), along with some auxiliary
functions.
Most of the rewriting rules are purely syntactic and quite simple; the only notable
exception is the (Var) rule for variables, which will be explained in detail later. We
summarize the other rules as follows. Constants and primitive functions are lifted to
the monadic space by the return operation and the liftM operation of the designated
monad, respectively. There are two rules for rewriting if-expressions, depending on their
condition part. We may need to apply a monad-binding to trigger the evaluation of
their monadified condition expression. The rewriting rules for side-effecting constructs,
(Seq) and (Set), are standard in using monads to handle states. The remaining cases
are simply syntactic composition of the monadified components.
[[·]]tΓ : e! −→ e
(Const) [[c]]tΓ = return c
(Prim) [[p]]tΓ = liftMn p where n is the arity of primitive function p
(If) [[if a then e1 else e2]]tΓ = [[a]]
Bool
Γ >>= λa
′.if a′ then [[e1]]tΓ else [[e2]]
t
Γ a
′ is fresh
(Lam) [[λx.e]]t1→t2Γ = λx.[[e]]
t2
Γ
(App) [[e a]]tΓ = [[e]]
ta→t
Γ [[a]]
ta
Γ
(Let) [[let x = e1 in e2]]tΓ = let x = [[e1]]
tx
Γ in [[e2]]
t
Γ
(Seq) [[e1; e2]]tΓ = [[e1]]
t1
Γ >>= λ .[[e2]]
t
Γ
(Set) [[set! x = e1; e2]]tΓ = [[e1]]
t1
Γ >>= λx
′.let x = return x′ in [[e2]]tΓ
(Var) [[x]]tΓ = pos
S
t′(x)
where ∀a¯.t′ = Γ (x) and S is a substitution such that t = St′
posSt1→t2(e) = λx. pos
S
t2
(e negSt1(x)) x /∈ fv(e)
posSa(e) = flatten[Sa] (e) if a ∈ dom(S)
posSt (e) = e otherwise
negSt1→t2(e) = λx. neg
S
t2
(e posSt1(x)) x /∈ fv(e)
negSa(e) = return (e) if a ∈ dom(S) and Sa is not an atomic type
negSt (e) = e otherwise
flatten[t](e) = e if t is atomic
flatten[t1 → t2 · · · tn → t′](e) = (λx1 · · ·xn. e >>= λe′. e′ x1 · · ·xn) otherwise
Fig. 2 Type-Directed Monadification Rules and Auxiliary Functions
The rule for variables, (Var), is the most complicated one. Its complexity arises
due to the need to support polymorphic higher-order functions. Indeed, if it is not
the case, the rewriting rule for a variable simply leaves it intact: [[x]]tΓ = x. Before
proceeding to explain the details of how the (Var) rule works, let us see an example
of the monadification transformation that does not involve any higher-order functions.
12
M Int). Therefore, the result of monadifying id1 cannot simply be id1; otherwise, ac-
cording to the type scheme of id, the monadic type assigned to id1 would beM (M Int→
M Int)→ M (M Int→ M Int), which will lead to a type error. On the other hand,
applying (Var) to monadify id1 would reconcile the type mismatch and produce a
type-correct result:
[[id1]]
(Int→Int)→(Int→Int)
Γ
= posSa→a(id1)
= λx. posSa(id1 neg
S
a(x))
= λx. flatten[Sa] (id1 (return x))
= λx. flatten (id1 (return x))
where S = [a 7→ (Int→ Int)]
flatten = λv.λx. v >>= λv′. v′ x
We shall give a formal account of the correctness of such enhancements in the following
section.
It is worth further discussing the need of inserting calls to return and flatten
combinators when monadifying higher-order functions. Essentially, the reason for doing
so can be traced back to the definition of our monadification operator, M(·). Recall
its first equation:
M(t1 → t2) ⇒M(t1) → M(t2)
This equation embodies the key features as well as the limitations of our monadification
scheme. In particular, as pointed out in [8], in this scheme, “the effect of monadification
on a function is to produce a function, rather than a computation of a function.”
Consequently, monadification of higher-order functions requires the insertion of some
boilerplate code to make the resulting expression type check.
An alternative equation for monadic types we had considered is the following one:
M(t1 → t2) ⇒ M (M(t1) → M(t2))
Although this alternative equation simplifies the monadification of higher-order func-
tions, it leads to more complicated monadic types and monadified expressions with
much more boilerplate code that simply acts to add or remove additional monadic
structure. Hence we decide to retain the original equation.
3.2 Semantics and Correctness
This section gives a formal account of the static and dynamic semantics of expressions
and presents the properties of our monadification scheme with respect to the semantics.
There are two major theorems. First, the type of a monadified expression is the same
as the monadic type assigned to the original expression. Second, the semantic value
of a pure expression is preserved by the monadification transformation. The technical
lemmas and their proofs can be found in the appendix.
14
t M(t)
M(S)M(t)
St M(St)
M(·)S(S)posStneg
Fig. 4 The Non-distributivity Between Substitution and Monadification Operator
– For a type substitution S from type variables to types,M(S) is also a type substi-
tution with dom(M(S)) = dom(S) and
M(S)(a) =
{
Sa if Sa is an atomic type
M(Sa) otherwise
The definition of M(Γ ) is straightforward, but the definition of M(S) needs some
extra attention. Specifically, as a type substitution may turn a type variable into a
functional type, the monadification operator has been pushed to monadify the resulting
functional type in such cases. However, although bothM(·) and S are distributive over
the functional type operator (→), they do not distribute with each other when applying
to a functional type. In other words, M(t1 → t2) = M(t1) → M(t2), S(t1 → t2) =
(St1 → St2), but, in general, M(St) 6=M(S)M(t).
This can be illustrated by the (id1 id2) example presented above. As the type
scheme for id is ∀a.a → a, a valid type instance for id is t = b → b. Now, given
type substitution S = [b 7→ (Int → Int)], we get M(St) = (M Int → M Int) →
(M Int → M Int). But, on the other hand, M(S)M(t) = M (M Int → M Int) →
M (M Int→M Int). Due to this non-distributive result, we have to insert flatten and
return operators when monadifying a higher-order function in the (Var) rule via the
pos and neg functions. Figure 4 highlights the general idea. Basically, the neg function
maps an expression with type M(St) to one with type M(S)M(t); the pos function
works for the other direction of mapping.
Given the above formal definitions, we can derive the first key property of our
monadification scheme which ensures that the type of a monadified expression is the
same as the monadic type assigned to the original expression.
Theorem 1 (Type Preservation) Given an expression e and a type environment
Γ , if Γ ` e : t then M(Γ ) ` [[e]]tΓ :M(t),
3.2.2 Dynamic Semantics and Value Preservation
This section presents a small-step operational semantics for evaluating expressions in
a lazy way. Similar to the static semantics, pure expressions, effectual expressions, and
monadic expressions are all included so that we can reason about their evaluation in
the same framework. Hence we shall simply refer to them as expressions if the context
does not require distinguishing them.
16
left-hand side because the contents of the store are not observable when the evaluation
is done.
Rules for common expressions (7→
?
stands for both 7→ and 7→
h
)
(OS:App1)(h, S,O, (λx.e) e1) 7→? (h[x 7→ e1], S,O, e)
(OS:App2)
(h, S,O, e1) 7→
?
(h′, S′,O′, e′1)
(h, S,O, e1 e2) 7→
?
(h′, S′,O′, e′1 e2)
(OS:If1)
b = True or b = False
(h, S,O, if b then eTrue else eFalse) 7→
?
(h, S,O, eb)
(OS:If2)
(h, S,O, a) 7→
?
(h′, S′,O′, a′)
(h, S,O, if a then e1 else e2) 7→
?
(h′, S′,O′, if a′ then e1 else e2)
(OS:Prim)
(h, S,O, e1) 7→ (h′, S′,O′, e2)
(h, S,O, p e1) 7→
?
(h′, S′,O′, p e2)
for primitive p
(OS:hval)
h(x) = vh
(h, S,O, x) 7→
?
(h, S,O, vh)
(OS:heval)
(h[x 7→⊥], S,O, h(x)) 7→
h
(h′, S′,O′, e)
(h, S,O, x) 7→
?
(h′[x 7→ e], S′,O′, x)
(OS:Let)(h, S,O, let x = e1 in e2) 7→? (h[x 7→ e1], S,O, e2)
Fig. 6 Semantic Rules for Common Expressions
The rules in Figure 6 for common expressions are pretty standard. The (OS: App1)
and (OS:App2) rules are the congruence rule and computation rule for reducing an ap-
plication, respectively. Similar rules exist for reducing an if-expression. For primitives,
we list only a template congruence rule. The remaining three rules are inter-related.
The (OS:Let) rule deposits the expression of a let-binding into a new cell in the
heap. Later, when the variable is referenced, if the expression associated with it is al-
ready a heap value, then (OS:hval) will simply return the heap value. Otherwise, the
(OS:heval) rule will employ the heap step transition rules to evaluate the expression
repeatedly until a heap value is reached, and then update the underlying heap cell using
the value, thus achieving the sharing required for future references to the variable.
There are two groups of rules in Figure 7. The first group provides the evaluation
rules for the source-level effectual constructs, including those of the state API. The
Cons operator in the (OS:Put) rule is the list constructor operator. The setter and
getter for accessing a user-defined mutable variable F are denoted by primitives setF
and getF , respectively. We write (S[F 7→ v]) for updating the variable F in the store,
and (projF S) for retrieving its value from the store. The second group specifies the
evaluation rules for monadic expressions produced by the monadification transforma-
tion, following the standard monadic semantics.
18
(OS:let)
7→ (h[x 7→ 2][v1 7→ getC+ 1], {c = 0}, [ ], setC v1 ;x+ x)
(OS:Seq2), (OS:Prim), (OS:HEval), (OS:Getter)
7→ (h[x 7→ 2][v1 7→ 0 + 1], {c = 0}, [ ], setC v1 ;x+ x)
(OS:Seq2), (OS:Prim), (OS:HEval)
7→ (h[x 7→ 2][v1 7→ 1], {c = 0}, [ ], setC v1 ;x+ x)
(OS:Seq2), (OS:HVal)
7→ (h[x 7→ 2][v1 7→ 1], {c = 0}, [ ], setC 1 ;x+ x)
(OS:Seq2), (OS:Setter),
7→ (h[x 7→ 2][v1 7→ 1], {c = 1}, [ ], ();x+ x)
(OS:Seq1)
7→ (h[x 7→ 2][v1 7→ 1], {c = 1}, [ ], x+ x)
(OS:Prim), (OS:HVal)
7→ (h[x 7→ 2][v1 7→ 1], {c = 1}, [ ], 2 + x)
(OS:Prim), (OS:HVal)
7→ (h[x 7→ 2][v1 7→ 1], {c = 1}, [ ], 2 + 2)
7→ (h[x 7→ 2][v1 7→ 1], {c = 1}, [ ], 4)
Next, we show the major steps for evaluating e. The sub-expression to be evaluated
at each major step is underlined to help the reader find the points quickly.
(∅, {c = 0}, [ ], e)
7→∗ (h, {c = 0}, [ ], set! v = v2 ∗ v3 ; let v4 = (show getC) in (putMsg “main” v4) ; v)
where h = [d 7→ λx.(let v1 = getC+ 1 in setC v1 ;x+ x), v2 7→ (d 2), v3 7→ (d 3)]
7→∗ (h[v1 7→ 1][v2 7→ 4], {c = 1}, [ ],
set! v = 4 ∗ v3 ; let v4 = (show getC) in (putMsg “main” v4) ; v)
7→∗ (h[v1 7→ 2][v2 7→ 4][v3 7→ 6], {c = 2}, [ ],
set! v = 4 ∗ 6; let v4 = (show getC) in (putMsg “main” v4) ; v)
7→∗ (h[v1 7→ 2][v2 7→ 4][v3 7→ 6], {c = 2}, [ ],
let v4 = (show getC) in (putMsg “main” v4); 24)
7→∗ (h[v1 7→ 2][v2 7→ 4][v3 7→ 6][v4 7→ “2”], {c = 2}, [ ], (putMsg “main” v4); 24)
7→∗ (h[v1 7→ 2][v2 7→ 4][v3 7→ 6][v4 7→ “2”], {c = 2}, [(“main”, “2”)], 24)
Hence, the value of e is 24, and the output stream is [(“main”, “2”)]:
e
[(“main”,“2”)]7−→ 24
Now, consider the monadified version of e:
[[e]]IntΓ = let d = λx.let v1 = liftM2 (+) getC (return 1)
in (setC v1 >>= λ .(liftM2 (+) x x))
in let v2 = (d (return 2)) in let v3 = (d (return 3)) in (liftM2 (∗) v2 v3) >>= E
where E = λv′. let v = return v′
in let v4 = (liftM show getC)
in (liftM2 putMsg (return “main”) v4)
>>= λ .v
20
aspects. Specifically, state information consists of two parts: a user variable record and
an output buffer. We refer to them as the aspect state and the state monad encapsu-
lating them as the aspect monad.
Since the specific content of the user variable record depends on the individual
program, we provide the following generic state monad, GM v, based on the standard
state monad of Haskell. The putMsgM function extracts its string arguments out of
the monad and appends them to the internal output buffer4. In addition, two utility
functions, getUserVar and modifyUserVar, are supplied to facilitate the generation of
the monadified versions of state accessor functions for user variables. Their Haskell
code is as follows.
type GM v = State (v, OutputBuf)
-- v is a program-specific type
OutputBuf = [(String, String)]--(advName,msg) pair
putMsgM :: GM v String -> GM v String -> GM v ()
putMsgM a m = do a’ <- a; m’ <- m
modify $ \(u, ms) -> (u, (a’, m’):ms)
getUserVar :: GM v v
getUserVar = do (uv,_) <- get
return uv
modifyUserVar :: (v -> v) -> GM v ()
modifyUserVar trans = modify $ \(u, s) -> (trans u, s)
The definition of the aspect monad for a specific program is derived from its decla-
rations of mutable variables. Take the profiler aspect as an example, the enhanced
AspectFun compiler will generate the following definition of a specialized aspect monad
and the associated accessor functions for its mutable variable, profileMap.
--one variable one field
data UserVar = U {profileMap::Map.Map String Int}
--aspect monad
type M = GM UserVar
--state accessor functions
getProfileMapM :: M (Map.Map String Int)
getProfileMapM = getUserVar >>= \u -> return $ profileMap u
setProfileMapM :: M (Map.Map String Int) -> ()
setProfileMapM var =
do var’ <- var
modifyUserVar $ \u -> u{ profileMap = var’ }
Functions such as getProfileMapM defined above, as well as those that invoke them
are state-aware; their invocations mostly require immediate access to the underlying
state monad. Yet, as mentioned before, AspectFun is a lazy language. Hence we provide
set!-expressions and sequencing expressions to enable the user to override the default
lazy evaluation semantics when applying such state-aware functions.
In the previous section, the monadification of set!-expressions and sequencing ex-
pressions was presented in terms of the monad’s >>= operation. From now on, we
4 The code uses “cons”, but we reverse the buffer when it is dumped at the end of program
execution.
22
putMsgM (return "tracerFacM") str_5
proceedResult <- proceed v_1 v_2
let result = return proceedResult
setIndentM ind
let s_result = (liftM show) result
let str_6 = (liftM2 (++)) (return "fac returns ") s_result
let str_7 = (liftM2 (++)) ind str_6
putMsgM (return "tracerFacM") str_7
result
facM :: M Int -> M Int -> M Int facM n acc =
do let eq_n_zero = (liftM2 (==)) n (return 0)
neq0 <- eq_n_zero
if neq0 then acc
else do let nmacc = (tracerMulM (liftM2 (*)) n acc
let nm1 = (liftM2 (-)) n (return 1)
(tracerFacM facM) nm1 nmacc
mainM = (tracerFacM facM) (return 3) (return 1)
The use of set!-expression allows explicit control of evaluation order.
4.2 Cached State Monad for Preserving Laziness
We have seen that in addition to sequencing the desired order of evaluation within side-
effecting aspects, explicit use of set!-expressions is able to influence the base program
by evaluating the arguments of proceed prior to the call. At the same time, we also want
the option of being able to write side-effecting aspects that do not interfere with the
lazy semantics of their base program. This preservation of laziness turns out to be non-
trivial to enforce because any reference to the arguments of an advice in a sequenced
expression may force the evaluation of them. Consider a variant of Example 2.
fac n acc = if n == 0 then acc
else fac (n - 1) (n * acc)
aspect tracer where
var indent :: String = ""
advice around{fac, (*)} (arg) = \arg2 ->
set! ind = getIndent ;
setIndent ("| " ++ ind);
putMsg "tracer" (ind++tjp++" receives ["++
show arg ++ ", " ++ show arg2 ++ "]");
set! result = proceed arg arg2 ;
setIndent ind;
putMsg "tracer" (ind++tjp++" returns " ++
show result);
result
We have removed the set!-expressions that evaluate the arguments eagerly, hoping to
obtain a trace reflecting the lazy evaluation of fac.
24
do let eq_n_zero = (liftM2 (==)) n (return 0)
neq0 <- eq_n_zero
if neq0 then acc
else do let nmacc = (tracerMulM (liftM2 (*)) n acc
let nm1 = (liftM2 (-)) n (return 1)
(tracerFacM facM) nm1 nmacc
mainM = (tracerFacM facM) (return 3) (return 1)
Running the above monadified tracing program with (facM (return 3) (return
1)) yields the following incorrect trace.
fac receives [3, 1]
| | times receives [3, 1]
| | times returns 3
| fac receives [2, 3]
| | | | times receives [3, 1]
| | | | times returns 3
| | | times receives [2, 3]
| | | | times receives [3, 1]
| | | | times returns 3
| | | times returns 6
| | fac receives [1, 6]
...
| | | | | | times receives [3, 1]
| | | | | | times returns 3
| | | | | times receives [2, 3]
| | | | | | times receives [3, 1]
| | | | | | times returns 3
| | | | | times returns 6
| | | | times returns 6
| | | fac returns 6
| | fac returns 6
| fac returns 6
fac returns 6
From the generated trace, we can see that some expressions, such as times 3 1,
are evaluated more than once and in the wrong order. In other words, the monadified
tracing program obtained not only changes the order of evaluation but also duplicates
the evaluation of some expressions, thus delivering the tracing messages in the wrong
order. This result is disturbing because the sole purpose of tracing is to track the
evaluation steps of the underlying program and record them in the output stream.
A closer look at the monadified aspect code reveals the source of the problem: Call-
ing the lifted show function, (liftM show), with the argument arg2 (the accumulating
parameter), which in turn invokes the show function to obtain string representations
of the arguments. This will lead to premature evaluation of the invocation of the mul-
tiplication, which is also being traced. Later, when the call to facM is resumed via
the proceed call, the multiplication call will be triggered and traced again. Hence the
problem is how to preserve the lazy evaluation of the base program while monadify-
ing aspects which are perceived to be non-interfering, such as tracing. Unfortunately,
existing monadification schemes such as [14,5,7,9] do not address these issues.
26
The cache is a map from integers (locations) to cells containing thunks or values.
The type (CState s a) is the key element of the new aspect monad. It can be viewed
as a state monad extended with a cache of cells. When feeding an extended state,
(s, cache), to run, the new aspect monad will produce an “either-object”: either a
real value, (Left a), or a cell location, (Right n), of the cache. Because of the cache
wrapper, we define a special “unpacker” function, runCState, to assist in realizing
state processing for the extended aspect monad. Specifically, it first activates the state
processing function via the field accessor, realrunCState, to obtain an either-object,
and then passes it to the fromCacheEither function, which may look up the cell in the
cache and trigger the monadic computation stored therein via the fromCell function.
The definition of the bind operator (À=) of the new aspect monad is almost identical
to the standard state monad except the call to realrunCState. Note that, due to the
use of the forall quantifier in the definition of Cell type, we have to use the GHC
extension of unsafeCoerce function in the fromCell function.
Also shown in Figure 8 are three functions for manipulating the cache. Function
getNewCacheLoc extends the cache and returns the new location. Function setCache
puts a monadic computation into the designated location of the cache. Finally, function
add2cache employs the two functions to put a monadified function argument compu-
tation into the cache.
With the introduction of (CState s a), the issue of duplicated evaluation of func-
tion arguments can be resolved. Recall that, after A-normalization, all non-atomic
function arguments will become let-bound expressions. Hence, we can enhance the
monadification rewriting rule for let-expressions by applying the add2Cache function
to fully applied function calls as follows.
[[let x = e1 in e2]]
t
Γ = if e1 is of functional type or a constant
then do {let x = [[e1]]txΓ ; [[e2]]tΓ }
else do {x← add2cache $ [[e1]]txΓ ; [[e2]]tΓ }
Following this enhancement, the revised monadification of the tracing program is as
follows.
tracerFacM :: (M Int -> M Int -> M Int) ->
(M Int -> M Int -> M Int)
tracerFacM proceed arg arg2 =
do getIndentResult <- getIndentM
let ind = return getIndentResult
ind’ <- add2Cache $ (liftM2 (++)) (return "| ") ind
setIndentM ind’
s_arg2 <- add2Cache $ (liftM show) arg2
str_1 <- add2Cache $ (liftM2 (++)) s_arg2 (return "]")
str_2 <- add2Cache $ (liftM2 (++)) (return ",") str_1
s_arg <- add2Cache $ (liftM show) arg
str_3 <- add2Cache $ (liftM2 (++)) s_arg str_2
str_4 <- add2Cache $ (liftM2 (++)) (return "fac receives [") str_3
str_5 <- add2Cache $ (liftM2 (++)) ind str_4
putMsgM (return "tracerFac") str_5
proceedResult <- proceed arg arg2
let result = return proceedResult
28
a result, the monadified tracing program will produce the same result as described
in [12] when run with facM (return 3) (return 1). On the other hand, on certain
occasions, such as debugging as mentioned in the introduction, one may prefer an eager
tracing of the base programs. Thus, we could also offer both options of monadifying
show, namely (liftM show) and showM, and let the user decide which one to use.
5 Transforming Monadic Programs
Although AspectFun does not yet support monadic base programs, we can still de-
scribe how to extend our modification transformation when the base program is already
monadic. We illustrate this by refactoring the monadic version of the “display update”
example presented by Hofer and Ostermann [10].
The context of this “display update” example [11] is a simple figure editor that
manipulates typical shapes such as points and lines. Any update done on such shapes
will trigger an action for display refresh. It is a model example of crosscutting concerns
(i.e., display refresh) that can be nicely handled by aspect-oriented programming. In
their work, Hofer and Ostermann aim to show a simulation of aspect-oriented program-
ming with monads. To achieve this goal, besides introducing the IO monad for state
manipulation, they also introduced an additional monad, MonadIO, and an overloaded
withStateChange operator to implement the crosscutting concern of display refresh.
By contrast, we use side-effecting aspects to separate the concern of display refresh
from the base module of shape manipulation; thus the base module only needs to use
the IO monad to support shape updates. Example 3 displays the main fragments of
the refactored code.
Example 3
newtype Point = P (IORef (Int, Int))
newPoint :: Int -> Int -> IOPoint ...
setPointX, setPointY :: Point -> Int -> IO () ...
movePointBy::Point-> Int -> Int -> IO () ...
newtype Line = L (IORef (Point, Point))
newLine :: Point -> Point -> IO Line ...
getLineP1, getLineP2 :: Line -> IO Point ...
moveLineBy :: Line -> Int -> Int -> IO ()
...
sample :: Line->IO()--a test case
sample l = moveLineBy l 7 (-9)
data DisplayObject=forall a.Displayable a => DisplayObject a
aspect DisplayUpdate where
-- user variable
var displayObject ::DisplayObject = DisplayObject EmptyDisplay
-- advice 1:before advice
initDisplay@advice around{sample} (l) =
setDisplayObject (DisplayObject l); proceed l
30
we shall use the liftM operator to lift operations on the base monad before applying
them, and use the liftN operator to lift results of computations in the base monad, N.
The following enhanced versions of (Prim) and (App) illustrate the ideas.
(Prim) [[p]]tΓ = liftMn p
where n is the arity of the primitive function or
the base monad operation p
(App) [[e a]]tΓ =
if isFullAppBaseMonadOP (e1)
then do {x← [[e]]ta→tΓ [[a]]taΓ ; liftN x}
else [[e]]ta→tΓ [[a]]
ta
Γ
Secondly, the revised rule for let-expressions presented in Section 4.2 needs yet another
adjustment. Specifically, if the binding of a let-expression is a monadic expression,
then we should not apply the add2Cache function, as the computation encapsulated in
a monad should be evaluated whenever it is referenced.
Thirdly, we need to extend the rewriting rules to handle the bind (À=) and the
return operations of the base monad.
(Bind) [[do {x← e1; e2}]]tΓ = do {x′ ← [[e1]]t1Γ ; let x = return x′; [[e2]]tΓ }
(Return) [[return e]]tΓ = [[e]]
t
Γ
In the case of (Bind), we need to use the return of the new monad to move the result
of do-binding action back to the new monad. As to the case of (Return), we simply
drop the returnof the base monad and return the monadified expression.
The following code snippets show the original version of the getLineP1 function
and its monadified version.
getLineP1 :: Line -> IO Point
getLineP1 (L l) =
do (p1,_) <- readIORef l
return p1
getLineP1M :: M Line -> M Point
getLineP1M ll =
do (L lBindout) <- ll --PatternMatching
let l = return lBindout --Bind
bmOP <- (liftM readIORef) l --Prim
(p1BindOut, _) <- liftIO bmOP --App
let p1 = return p1Bindout --Bind
p1 --Return
5.2 Unified Monadification Scheme
We started from a simple state monad of user variables and output buffer, and then
extended it with a cache facility. Now we generalize the state monad along another
direction using monad transformers. It would be nice to combine these different en-
hancements under a unified monadification framework. Specifically, we devise a cache-
extended state monad transformer that can accommodate the aspect monads presented
32
StateT s m a
CacheT (StateT s m) a 
CState s a 
State s a
Fig. 9 Summary of the Monad Transformations
convert A-normalized expressions into monadic computation. The rules are given in
natural semantics style and exhibit a degree of non-determinism to support the case of
monadifying only selected functions. In [5], Erwig and Ren developed a set of syntax-
directed rewriting rules that can convert a group of selected functions into a monadic
form and identified the correctness criteria for the conversion. Once again, neither of
these approaches addressed the issues related to lazy semantics.
In this work, the monadification transformation is performed after type inference
and after static weaving of the base program and its side-effecting aspects. Hence we
have full type information of the expression available for monadification. Moreover,
our monadification scheme differs from previous approaches by also lifting function
parameters to the monadic space. While this decision enables us to derive a simple
monadification function for transforming the woven code in a lazy context, it prohibits
us from being able to monadify only selected functions, as was done by the above two
approaches. In particular, any library functions for AspectFun must also be monadified
if they cannot be simply lifted to work with side-effecting aspects. However, none of
the approaches, including ours, can handle the case that the source code of external
functions invoked in the monadified function is unavailable.
Fischer et al. [6] presented an efficient implementation of non-strictness, sharing
and non-determinism embedded in a purely functional language, such as Haskell. They
devised some customized monadic data types to support non-determinism in non-strict
context. To enable explicit sharing, a combinator, share, is supplied to introduce vari-
ables for non-deterministic computations that represent values rather than computa-
tions. Not surprisingly, their share combinator plays the same role as our add2Cache
function, as manifested by their type signature, m a -> m (m a), where m is instanti-
ated to CState s in our case. Indeed, there is a close correspondence between their
monadic implementation of the sharing facility and our cache-extended state monad:
Both have an implementation of thunk stores with respect to a monad.
The Functional Programming Group at Kent University maintains a web page
titled, Monadification as Refactoring, which collects five different styles of monadifica-
tion and uses a simple interpreter to illustrate these styles. Our monadification scheme
presented in Section 3.1 is referred to as restricted call-by-name monadification, and
the other so-called full call-by-name monadification is the one that we had considered
but not adopted.
Kishon’s thesis work [12,13] developed a semantics-directed program monitoring
framework. The main tool his framework employed for collecting program execution
information is code instrumentation. His annotation labels for marking program points
34
3. Dantas, D. S., D. Walker, G. Washburn, and S. Weirich: 2008, ‘AspectML: A polymorphic
aspect-oriented functional programming language’. ACM Trans. Program. Lang. Syst.
30(3), 1–60.
4. Ennals, R. and S. P. Jones: 2003, ‘HsDebug : Debugging Lazy Programs by Not Being
Lazy’. In: In Haskell 03: Proceedings of the 2003 ACM SIGPLAN workshop on Haskell.
pp. 84–87.
5. Erwig, M. and D. Ren: 2004, ‘Monadification of Functional Programs’. Science of Com-
puter Programming 52(1-3), 101–129.
6. Fischer, S., O. Kiselyov, and C.-C. Shan: 2009, ‘Purely functional lazy non-deterministic
programming’. In: ICFP ’09: Proceedings of the tenth ACM SIGPLAN International
Conference on Functional Programming. New York, NY, USA, pp. 11–22.
7. Flanagan, C., A. Sabry, B. F. Duba, and M. Felleisen: 1993, ‘The essence of compiling with
continuations’. In: Proceedings of the ACM SIGPLAN 1993 conference on Programming
language design and implementation. pp. 237–247.
8. Functional Programming Group, K. U.: 2005, ‘Monadification as a refactoring’.
9. Hatcliff, J. and O. Danvy: 1993, ‘A generic account of continuation-passing styles’. In: Pro-
ceedings of the 21st ACM SIGPLAN-SIGACT symposium on Principles of programming
languages. pp. 237–247.
10. Hofer, C. and K. Ostermann: 2007, ‘On the Relation of Aspects and Monads’. In: Foun-
dations of Aspect-Oriented Languages Workshop at AOSD. pp. 37–46.
11. Kiczales, G., E. Hilsdale, J. Hugunin, M. Kersten, J. Palm, and W. G. Griswold: 2001,
‘An Overview of AspectJ’. In: ECOOP ’01: Proceedings of the 15th European Conference
on Object-Oriented Programming, Vol. 2072 of LNCS. pp. 327–353.
12. Kishon, A.: 1992, ‘Theory and Art of Semantics-Directed Program Execution Monitoring’.
Ph.D. thesis, Yale University.
13. Kishon, A. and P. Hudak: 1995, ‘Semantics Directed Program Execution Monitoring’.
Journal of Functional Programming 5(4), 501–547.
14. La¨mmel, R.: 1999, ‘Reuse by Program Transformation’. In: Trends in Functional Program-
ming: Vol. 1, Selected papers from the 1st Scottish Functional Programming Workshop.
pp. 144–153.
15. Launchbury, J.: 1993, ‘A Natural Semantics for Lazy Evaluation’. In: Proceedings of the
20th ACM SIGPLAN-SIGACT symposium on Principles of Programming Languages. pp.
144–154.
16. Masuhara, H., H. Tatsuzawa, and A. Yonezawa: 2005, ‘Aspectual Caml: an aspect-oriented
functional language’. In: ICFP ’05: Proceedings of the tenth ACM SIGPLAN International
Conference on Functional Programming. New York, NY, USA, pp. 320–330.
17. Meuter, W. D.: 1997, ‘Monads as a theoretical foundation for AOP’. In: International
Workshop on Aspect-Oriented Programming at ECOOP.
18. Oliveira, B. C. d. S., T. Schrijvers, and W. R. Cook: 2010, ‘EffectiveAdvice: Disciplined
Advice with Explicit Effects’. In: ACM SIG Proceedings of the 9th International Confer-
ence on Aspect-Oriented Software Development (AOSD).
19. Wadler, P.: 1992, ‘The Essence of Functional Programming’. In: Proceedings of the 19th
Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages.
pp. 1–14.
20. Wang, M., K. Chen, and S.-C. Khoo: 2006, ‘Type-Directed Weaving of Aspects for Higher-
order Functional Languages’. In: PEPM ’06: Workshop on Partial Evaluation and Pro-
gram Manipulation. pp. 78–87.
21. Wang, M. and B. C. d. S. Oliveira: 2009, ‘What does aspect-oriented programming mean
for functional programmers?’. In: WGP ’09: Proceedings of the 2009 ACM SIGPLAN
workshop on Generic programming. New York, NY, USA, pp. 37–48.
22. Wansbrough, K. and S. Peyton Jones: 1999, ‘Once Upon a Polymorphic Type’. In: Twenty-
sixth ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. pp.
15–28.
A Proofs of Monadification Properties
In this appendix, we give in detail the proofs of type preservation and value preservation for
our monadification scheme, respectively.
36
uunionsq
Given the two lemmas above, we can prove the first theorem, which ensures that the type
of a monadified expression is the same as the monadic type assigned to the original expression.
Theorem 1 (Type Preservation of Monadification) Given an expression e and a type
environment Γ , if Γ ` e : t then M(Γ ) ` [[e]]tΓ :M(t),
Proof By induction on the derivation of Γ ` e : t.
(Var) Lemma 2
(Lam) By induction, M(Γ ).x : M(t1) ` [[e]]t2Γ : M(t2). Hence, M(Γ ) ` λx.[[e]]t2Γ : M(t1) →
M(t2). The case follows since λx.[[e]]t2Γ = [[λx.e]]t1→t2Γ .
(App) Trivial.
(If) Trivial if the rule (If-C) is applied. Otherwise, by induction hypothesis, M(Γ ) ` [[a]]tΓ :M(Bool). Applying the rule (Bind) withM(Γ ) ` λa′.if a′ thenM(e1) elseM(e2) : Bool→
M(t), we get M(Γ ) ` [[if a then e1 else e2]]tΓ :M(t).
(Let) Trivial since M(gen(Γ, t1)) = gen(M(Γ ),M(t1)).
(Seq) Trivial since M(Γ ) ` λ .[[e2]]tΓ : t1 →M(t2) = t1 →M t2.
(Set) Similar to (Seq).
uunionsq
Next, we proceed to develop the technical machinery for proving the value preservation
property of our monadification scheme. We first extend the monadification function [[·]]Γ to
work on heap h such that [[h]]Γ (x) = [[h(x)]]
t
Γ for x ∈ dom(h) and t is Γ (x) with quantified
type variables instantiated to fresh variables. Then, as the heap is essential to the evaluation
of an expression, monadic or not, we define the notions of respect and preservation by a heap
for an expression with respect to monadification. First, a monadified expression eM of type
M(t) is said to respect a non-monadic expression e of type t under a heap h according to the
structure of t and the semantic evaluation of eM as follows.
– if t is atomic, then (h, S, ², e) 7→∗ (h′, S′, ², v) implies ([[h]]Γ , S, ², eM ) 7→∗ (h′′, S′′, ², return v).
– if t = M(t1) → M(t2), then, for every eN of type M(t1) respecting e1, application
(eM eN ) respects (e e1) under h.
Second, an expression e of type t is said to be preserved by a heap h if and only if [[e]]tΓ respects
e under h. Since the functional case of expression preservation will be used very often, for ease
of discussion, we shall adopt the following alternative yet equivalent definition.
– if t = t1 → t2, then, for every e1 of type t1 preserved by h, application (e x) is preserved
by h[x 7→ e1] where x is a fresh variable.
Besides, a heap should be consistent with the type environment such that Γ ` h if and
only if Γ ` h(x) : Γ (x) for every x ∈ dom(h). Finally, if h(x) is preserved by h[x 7→⊥] for every
x ∈ dom(h), we simply say that h is preserved.
The first lemma shows that the respect relation between expressions is invariant under the
application of the pos function.
Lemma 3 Given a monadified expression eM of type M(t), if it respects another expression
e of type t under a heap h, then for any type substitution S, posSt (eM ) has type M(St) and
respects the same expression e of type St under h.
Proof We prove it with a similar property of neg simultaneously by a structural induction on
t.
– For an expression eM of typeM(St), if it respects another expression e of type St under a
heap h, then negSt (eM ) can be seen as if having typeM(t) and respects the same expression
e of type t under h.
The typing parts in both propositions follows directly from the proof of Lemma 2 by adding
or removing the monadic type substitution M(S).
To prove the respect part, we assume that e evaluates to some value v under h. Consider
the following cases.
1. t is a type variable a in the domain of S:
38
– t = t1 → t2: Given the evaluation sequence (h[y 7→ e1], S, ², x y) 7→∗ (h′, S′, ², v) for a fresh
y and some preserved e1 with type t1, we need to show ([[h[y 7→ e1]]]Γ , S, ², [[x y]]t2Γ ) 7→∗
(h′′, S′′, ², return v), as Γ.y : t1 ` h[y 7→ e1].
By a reasoning similar to the above case, we can divide the given sequence to
(h[y 7→ e1], S, ², x y) 7→∗ (h′′, S′′, ², x y) 7→ (h′′, S′′, ², vh y) 7→∗ (h′′′, S′′′, ², vx y) 7→∗ (h′, S′, ², v)
where h′′(x) = vh.
We can construct the monadified evaluation sequence as for the above case; the main
difference is that [[x]]tΓ = pos
Sx
tx
(x), where Γ (x) = ∀a¯.tx and Sxtx = t1 → t2, may not be
equal to x. However, the monadification of y, pos
Sy
ty
(y) where Syty = t1, is also the result
of applying the pos function.
By Lemma 3, posSxtx (x) is an expression of type Sxtx which respects vh, and pos
Sy
ty
(y) has
type Syty = t1 and respects h(y). Then [[x y]]
t2
Γ = pos
Sx
tx
(x) pos
Sy
ty
(y) respects vh h(y), and
will evaluate to some vM that respects v. Hence this case is proved.
uunionsq
The third lemma shows value preservation by a heap for a well-typed expression.
Lemma 5 If Γ ` e : t, then for all preserved h such that Γ ` h, e is preserved by h.
Proof By structural induction on e.
– e ≡ x. By Lemma 4.
– e ≡ λx. e2. Let t = t1 → t2. Given the evaluation sequence (h[y 7→ e1], S, ², (λx. e2) y) 7→∗
(h′, S′, ², v) for a fresh y and some preserved e1 with type t1, we need to show
([[h[y 7→ e1]]]Γ , S, ², [[(λx. e2) y]]t2Γ ) 7→∗ (h′′, S′′, ², return v).
Moreover, we have
(h[y 7→ e1], S, ², (λx. e2) y) 7→ (h[y 7→ e1][x 7→ y], S, ², e2).
and
([[h]]Γ [y 7→ [[e1]]tΓ ], S, ², (λx. [[e2]]tΓ ) [[y]]t1Γ ) 7→ ([[h]]Γ [y 7→ [[e1]]t2Γ ][x 7→ [[y]]t1Γ ], S, ², [[e2]]t2Γ )
Now, as Γ.x : t1.y : t1 ` e2 : t2, we have Γ.x : t1.y : t1 ` h[y 7→ e1][x 7→ y], by induction
on e2 and [[h]]Γ [y 7→ [[e1]]tΓ ][x 7→ [[y]]t1Γ ] = [[h[y 7→ e1][x 7→ y]]]Γ , we get
([[h[y 7→ e1]]]Γ , S, ², [[(λx. e2) y]]t2Γ ) 7→ ([[h[y 7→ e1][x 7→ y]]]Γ , S, ², [[e2]]t2Γ ) 7→∗ (h′′, S′′, ², return v).
Hence e is preserved by h.
– e ≡ e1 e2. Trivial.
– e ≡ if a then e1 else e2. By induction on a:
[[e]]tΓ = [[a]]
Bool
Γ >>= λx. if x then [[e1]]
t
Γ else [[e2]]
t
Γ 7→∗ return b >>= λx. if x then [[e1]]tΓ else [[e2]]tΓ
Then e is preserved by h following from induction on e1 and e2.
– e ≡ let x = e1 in e2. Similar to the case of λx. e2.
uunionsq
As a consequence of Lemma 5, we obtain the main theorem of value preservation.
Theorem 2 (Value Preservation) Given a pure expression e and an atomic type t, if
∅ ` e : t and e ²7−→ v then [[e]]tΓ
²7−→ return v
Proof A special case of Lemma 5 by letting Γ an empty set and h an empty heap. uunionsq
40
import qualified Data.Map as M
import GHC.Prim( unsafeCoerce# )
fromJust’ s Nothing = error s
fromJust’ _ (Just a) = a
data Cell = forall s a. Cell Bool (CState s a) -- Cell Ever_used Thunk
type Cache = M.Map Int (Maybe Cell)
emptyCache = M.empty
newtype CState s a = CState{ realrunCState :: (s, Cache) -> (Either a Int, (s, Cache)) }
runCState :: CState s a -> (s, Cache) -> (a, (s, Cache))--Helper function for aspect monad
runCState a (s, cs) = uncurry fromCacheEither $ realrunCState a (s, cs)
evalCState :: CState s a -> s -> (a, s)
evalCState a s = second fst $ uncurry fromCacheEither $ realrunCState a (s, emptyCache)
instance Monad (CState s) where -- Standard State monad impl.
return t = CState $ \(s, cs) -> (Left t, (s, cs))
ma >>= k = CState $ \(s, cs) -> let (a, (s’, cs’)) = runCState ma (s, cs)
in realrunCState (k a) (s’, cs’)
instance MonadState s (CState s) where
put s’ = CState $ \(s, cs) -> (Left (), (s’, cs))
get = CState $ \(s, cs) -> (Left s, (s, cs))
putCache cs’ = CState $ \(s, cs) -> (Left (), (s, cs’))
getCache = CState $ \(s, cs) -> (Left cs, (s, cs))
getNewCacheLoc :: CState s Int
getNewCacheLoc = CState $ \(s, cs) -> let n = M.size cs
cs’ = M.insert n Nothing cs
in (Left n, (s, cs’))
cached :: Int -> CState s a
cached n = CState $ \(s, cs) -> (Right n, (s, cs))
setCache :: Int -> CState s a -> CState s a
setCache n t = do cs <- getCache
case M.lookup n cs of
Nothing -> cached n -- for showM, shouldn’t happen otherwise
Just Nothing -> let cs’ = M.insert n (Just $ Cell False t) cs
in putCache cs’ >> cached n
Just (Just _) -> cached n
fromCacheEither :: forall s a. Either a Int -> (s, Cache) -> (a, (s, Cache))
fromCacheEither (Left a) (s, cs) = (a, (s, cs))
fromCacheEither (Right n) (s, cs) =
let (t, (s’, cs’)) = fromCell (fromJust’ "a" $
fromJust’ (show n ++ show (M.keys cs)) $
M.lookup n cs) (s, cs)
(a, (s’’, cs’’)) = fromCacheEither t (s’, cs’)
in (a, (s’’, M.insert n (Just $ Cell True ((return a) :: CState s a)) cs’’))
fromCell :: Cell -> (s, Cache) -> (Either a Int, (s, Cache))
fromCell (Cell _ c) = realrunCState (unsafeCoerce# c)
add2Cache :: CState s a -> CState s (CState s a)
國科會補助專題研究計畫項下出席國際學術會議心得報告 
                                     日期： 98年05 月 15 日 
計畫編號 NSC 97－2221－E－004－001－MY3 
計畫名稱 程式之模組性與擴充性:驗證方法與工具-子計畫五:剖面導向函數語言之模組化狀態處理與型態擴充研究（第 1 年） 
出國人員
姓名 陳 恭 
服務機構
及職稱 國立政治大學資訊科學系副教授 
會議時間 
98 年 01 月 19 日
至 
98 年 01 月 20 日 
會議地點 
Savannah, Georgia, USA 
會議名稱 
(中文) 
( 英 文 ) ACM SIGPLAN Workshop on Partial Evaluation and Program 
Manipulation (PEPM 2009) 
發表論文
題目 
(中文) 
(英文)  Designing Aspects for Side-Effect Localization 
一、參加會議經過 
ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation (PEPM)是程式轉換研究
領域的一個著名的國際學術會議，首次會議於 1992 年舉辦，至今已有十幾年的歷史。近年來，PEPM
都與程式語言領域的最主要學術會議 Principles of Programming Languages(POPL)一併舉行，今年也是
如此。 
本計劃第一年的重要主題是探討如何以剖面與程式轉換的編譯技術來模組化純粹函數語言內最基
本的橫跨性關注：狀態處理 (state manipulation via assignments) ，將設計與實作具備狀態處理功能的剖
面 (side-effecting aspects)來處理的狀態改變，以提高純粹函數程式的模組化。我們發展了具備狀態處
理功能的剖面 (side-effecting aspects)與 monadification 程式轉換演算法。一方面使用者可以定義狀態變
數，然後在剖面中使用，,直接撰寫需要狀態處理的剖面。另一方面，我們設計了一套程式轉換技術，
將這些具狀態的剖面與基底程式(base program)自動轉成使用 monad 的程式。我們的做法不僅可以處理
一般程式，對於應用惰性求值(lazy evaluation)的函數式語言也可適用。透過這樣的處理，使用者可以
直接以剖面順利處理的狀態改變，提高純粹函數程式的模組化。我們的論文是 1 月 19 日下午的場次發
表。 
二、與會心得 
在會議中，我們遇到了程式轉換領域的一些知名學者與專家，透過跟他們的交流，讓我們對於這
個議題有了更進一步的認識。尤其是 Oleg Kiselyov 博士，他提到以 monadification 進行程式轉換時，
 1
 3
論文接受之電郵通知  
 
寄件人 PEPM 2009 pepm2009@easychair.org 
收件人 Kung Chen <chenk@cs.nccu.edu.tw> 
日期 2008 年 11 月 11 日下午 6:06 
主旨 PEPM 2009 notification 
  
Dear authors, 
 
Thank you for your submission to PEPM'09. 
 
On behalf of the PEPM'09 program committee, we are pleased to inform you 
that your paper has been accepted for presentation at PEPM'09 and 
publication in the conference proceedings. 
 
All the reviews on your paper are attached below. 
 
We will soon send instructions for preparation of the camera-ready 
version of your paper to be included in the conference proceedings. 
We can anticipate that the deadline for this final version is November 
24, instead of November 17 as initially announced, but please take 
into account that this is a strict deadline. 
 
We look forward to seeing you at the conference. 
 
Best regards, 
 
German Puebla and German Vidal 
 
 
2.1 AspectFun Overview
Figure 1 shows the syntax of AspectFun. We write o¯ as an abbre-
viation for a sequence of objects o1, ..., on (e.g. declarations, vari-
ables etc). An AspectFun program is a sequence of top-level decla-
rations followed by a main expression. Top-level definitions include
global variables and function definitions, as well as aspects. An as-
pect declaration provides two specifications: An advice, which is a
function-like expression named via the prefix n@; and a pointcut
designator, around {pc}, designates when the advice will be ex-
ecuted. In aspect-oriented programming [6], the specific program
execution points to trigger an advice is called join points. Here, we
focus on join points at function invocations. Thus a pointcut basi-
cally specifies a function whose invocations may trigger the exe-
cution of advice. The act of triggering an advice during a function
application is called weaving. The argument variable arg is bound
to the actual argument of the named function call.
Programs π ::= d in π | e
Declarations d ::= x = e | f x = e | f :: t → t |
n@advice around {pc} (arg) = e
Arguments arg ::= x | x :: t
Pointcuts pc ::= ppc | pc + cf | pc− cf
Primitive PC’s ppc ::= f x | any | any\[f ] | n
Cflows cf ::= cflow(f) | cflow(f( :: t)) |
cflowbelow(f) | cflowbelow(f( :: t))
Expressions e ::= c | x | proceed | λx.e | e e |
if e then e else e | let x = e in e
Types t ::= Int | Bool | a | t → t | [t]
Predicates p ::= (f : t)
Advised Types ρ ::= p.ρ | t
Type Schemes σ ::= ∀a¯.ρ
Figure 1. Syntax of the AspectFun Language
Advice may be executed before, after, or around a join point.
Specifically, around advice is executed in place of the indicated
join point, allowing the call to the advised function to be replaced.
A special keyword proceed may be used inside the body of around
advice. It is bound to the function that represents “the rest of the
computation” at the advised join point. As both before advice and
after advice can be simulated by around advice that uses proceed,
we only need to consider around advice in this paper.
Precisely, a pointcut, pc, may be either a primitive pointcut
or a composite pointcut. A primitive pointcut, ppc, specifies a
function (f ) or an advice name (n) the invocations of which will
be advised. A sequence of pointcuts, pc, indicates the union of all
the sets of join points selected by each. A primitive pointcut can
also be a catch-all keyword any. When used, the corresponding
advice will be triggered whenever a function is invoked. Name
based primitive pointcuts can be composed with control-flow based
pointcuts (cflow and cflowbelow) to form composite pointcuts,
which inspects the run-time stack of function execution.
In Figure 1, the argument variable arg may contain a type
scope, the t in x :: t. When such a type scope is present, the
applicability of a piece of advice is bounded by its pointcut as well
as its type scope. Specifically, when the function in the pointcut is
polymorphic, a type scoped argument only matches executions of
the function with arguments of types that are subsumed by their
scope. This is particularly useful as many functional languages are
polymorphically typed.
Expressions in AspectFun are pretty standard and are evaluated
with a lazy semantics. As mentioned above, the special keyword
proceed may be used inside the body of around advice. When
applied, proceed will resumes the execution of advised functions
or other advice that also designates the same function as its join
point, as in AspectJ.
AspectFun is polymorphically and statically typed. It intro-
duces a concept of advised types [13] that extend types with pred-
icates of the form (f : t). Advised types are inspired by Haskell’s
type classes and are used to capture the need of advice weaving
based on type context. As a result, AspectFun is able to statically
resolve type scopes on pointcut and weave aspects into base pro-
gram. We have built a compiler that employs a type-directed static
weaver to translate an AspectFun program into executable Haskell
code. The readers are referred to [1] for more details.
2.2 Side-Effecting Aspects
We now describe how we extend AspectFun to support side-
effecting aspects. The essential construct we add to AspectFun
is user-defined mutable variables declared at top-level. We use var
as the keyword to begin such a declaration. The precise syntax is
as follows.
Declarations d ::= . . . | var id :: t = e
Such mutable variables are declared with a monomorphic and
ground type, t, and an optional initializing expression, e. Side-
effecting aspects employ mutable variables to keep pertinent state
information. For example, the following declaration introduces a
mutable variable profileMap whose type is Map.Map String Int
with initial value empty1. Later, we shall use it to develop a profil-
ing aspect.
var profileMap :: Map.Map String Int = Map.empty
getProfileMap :: Map.Map String Int
setProfileMap :: Map.Map String Int -> ()
Also associated with each mutable variable declared is a pair
of getter and setter functions. With them, the user can write helper
functions to develop side-effecting aspects. For example, the fol-
lowing function, incProfile, will increase the calling count of a
function whose name is passed to it.
incProfile :: String -> ()
incProfile fname =
let! pMap = getProfileMap --strict evaluation
in let newMap =
case of Map.lookup fname pMap of
Nothing -> Map.insert fname 1 pMap
Just v -> Map.insert fname (v+1) pMap
in setProfileMap newMap
Here we provide another construct, let!, for users to override
the default lazy evaluation semantics of the normal let expres-
sions. In other words, the expression used in the local definition of
a let! expression will be evaluated eagerly unlike its let counter-
part. This is necessary because operations such as getProfileMap
are state-aware and require the current state snapshot before con-
tinuing the subsequent evaluations. This will become clearer when
monadification transformation is introduced later.
Besides mutable variables, output is also an important element
for side-effecting aspects such as tracing aspects. Hence we also
provide a function, putMsg :: String -> String -> (), for
performing output in aspects. The first string parameter is the name
of aspect which puts the second parameter (the message) into an
1 The Map is an alias of the Data.Map in Haskell prelude.
Here the user variable, displayObject, is the object to display,
which is either a line or a point. The function sample is a test case.
There are three aspects. The first one, initDisplay sets the object
to display before running the test case, sample. The other two as-
pects, moveUpdate and setUpdate, trigger the display refresh op-
eration when a point or a line is updated. They both have composite
pointcuts: Besides the update functions, they include a control-flow
based pointcut, -cflow(updateDisplay), which ensures that the
advice code will not be triggered when the updateDisplay func-
tion is still in execution, thus preventing repeated display refresh
during a single update operation.
3. Monadifying Aspect Programs
The first step of AspectFun compilation is to weave aspects into
the base program, thus producing an integrated program, which we
call a woven code. In the presence of side-effecting aspects, it is
necessary for the woven code to be generated in monadic style, in
order to retain its functional purity.
This section describes how we enhance the compiler of Aspect-
Fun to support side-effecting aspects through incremental monad
computation. First, we present a general framework for monadify-
ing functional expressions in a non-strict evaluation context. Next,
we illustrate the method to incorporate a state monad into the
framework so that we can also monadify those state-aware func-
tions used by side-effecting aspects properly. Finally, we identify
further requirements for preserving laziness by examining the trac-
ing aspect example, and describe an extension of the framework to
fulfill these requirements.
3.1 Monadifying Pure Expressions
We begin with a general framework for monadifying functional ex-
pressions. Like the pioneering work of La¨mmel [9], our monad-
ification transformation also consists of two major steps, namely
A-normalization [3] and monad introduction.
3.1.1 A-Normalization
Given an expression, the A-normalization step converts it into a
sequential version according to the call-by-value sequencing. Such
normalized expressions, called A-normal forms, are a popular inter-
mediate representation used in compilers for functional languages.
Essentially, in an A-normal form, function applications and the
condition parts of if-expressions are all flattened by let-expressions.
Let’s take the profiling of the fib function presented before as
an example. The input to our A-normalization step is the following
woven Haskell code generated by the AspectFun compiler.
let profiler proceed arg = incProfile "fib";
proceed arg in
let fib n = if n <= 1 then 1
else profiler fib (n - 1) +
profiler fib (n - 2) in
profiler fib 10 --main
The aspect, profiler, becomes an ordinary function with an ad-
ditional parameter, proceed that captures the continuation to the
advised function. Moreover, all invocations of the fib function are
now left to the profiler function.
After A-normalization, the above profiler program is converted
to the following code.
let profiler proceed arg = incProfile "fib";
proceed arg in
let fib n = let nleq1 = n <= 1 in
if nleq1 then 1
else let nm2 = n - 2 in
let fibm2 = profiler fib nm2 in
let nm1 = n - 1 in
let fibm1 = profiler fib nm1 in
(+) fibm1 fibm2 in
profiler fib 10 --main
3.1.2 Monad Introduction
The second step of the monadification transformation is monad
introduction. This aims to lift computations in the input expressions
to a designated monad, (M, return,). Its essence can be captured
by the monadification operator M defined over types as follows.
M(t1 → t2) ⇒ M(t1) → M(t2) (1)
M(a) ⇒ M a (2)
where rule (1) applies to functional types and rule (2) applies on
non-functional types.
We note that the monadification schemes proposed by La¨mmel
[9] and Erwig and Ren [2] do not lift arguments of functions to
monadic space. By contrast, we lift function arguments to monadic
space in order to capture the computation of arguments inside the
aspect monad and thus support the non-strict evaluation semantics
of AspectFun.
The concrete steps for lifting computations to monadic space
are formalized as a rewriting function, [[·]]Γ , that converts an A-
normalized expression, e, to a monadified version, eM , over the
designated monad, M . The subscript Γ is a type environment con-
taining the types for the free identifiers occurring in e. Figure 2 dis-
plays the definition of [[·]]Γ , implicitly parameterized over a monad
M .
The key parts of the moandification function [[·]]Γ can be sum-
marized as follows. Constants and primitive functions are lifted to
the monadic space by the return operation and the liftM oper-
ation of the designated monad, respectively. For if expressions,
since their boolean conditions had been turned into a monadified
expression, we need to apply a do-binding to trigger its evaluation.
The remainding cases are quite straightforward.
The following code shows the monadified version of the fib
function defined earlier4.
fibM :: M Int -> M Int
fibM n =
do let leq_n_one = (liftM2 (<=)) n (return 1)
nleq1 <- leq_n_one
if nleq1 then return 1
else do let nm2 = (liftM2 (-)) n (return 2)
let fibnm2 = profilerM fibM nm2
let nm1 = (liftM2 (-)) n (return 1)
let fibnm1 = profilerM fibM nm1
(liftM2 (+)) fibnm1 fibnm2
[[·]]Γ as defined possesses the following two good properties. First,
its output expression has the desired monadified type.
Proposition 1 (Type Lifting) Given an A-normalized expression e
and a type environment Γ, if Γ  e : t, then, regardless of the
underlying monad,
M(Γ)  [[e]]Γ : M(t)
where M(Γ) is the pointwise application of M to the type part of
all bindings in Γ.
Second, it preserves the semantic value of the input expression.
This can be specified by replacing the underlying monad with the
Identity monad.
Proposition 2 (Semantics Preserving) Given an A-normalized
expression e and a type environment Γ, if Γ  e : t and e −→∗β v,
4 A fold over the do-bindings is performed to polish the code.
changed. The profiler aspect employs a sequencing expression.
Hence its body becomes a do-expression after monadification. Fi-
nally, the monadification of the helper function incProfile is
more involved, because of the use of the let!-expressions. Applying
the enhanced monadification function to it, we obtain the following
monadified version for the incProfile function.
profilerM :: (M Int -> M Int) -> (M Int -> M Int)
profilerM proceed arg = do incProfileM (return "fib")
proceed arg
incProfileM fname =
do pMap’ <- getProfileMapM -- access user variable
let pMap = return pMap’
let lookupResult’ = (liftM2 Map.lookup) fname pMap
lookupResult <- lookupResult’
let newMap = case lookupResult of
Nothing -> (liftM3 Map.insert)
fname (return 1) pMap
(Just v’) -> do let v = return v’
let np1 = (liftM2 (+)) v (return 1)
(liftM3 Map.insert)
fname np1 pMap
setProfileMap newMap
3.3 Preserving Laziness
With the introduction of the specialized state monad and the eager
approach of monadifying let!-expressions, we can support the de-
sired order of evaluation required for side-effecting aspects. How-
ever, monadification brings along its own “side effect”. Whereas
an expression may be evaluated once under lazy semantics despite
being referred to (by an identifier) multiple times in a program, its
monadified counterpart may be evaluated at every reference. When
the monad involved is state-aware or can perform IO operation,
multiple evaluations of the monad can interfere eccentrically with
the underlying base program that obeys lazy semantics. This is-
sue emerges when we attempted to monadify the tracing aspect of
Example 2. As shown in [7], according to the lazy semantics, the
tracing result of (fac 3 1) should be
fac receives [3, 1]
| fac receives [2, 3]
| | fac receives [1, 6]
| | | fac receives [0, 6]
| | | | times receives [1, 6]
| | | | | times receives [2, 3]
| | | | | | times receives [3, 1]
| | | | | | times returns 3
| | | | | times returns 6
| | | | times returns 6
| | | fac returns 6
| | fac returns 6
| fac returns 6
fac returns 6
However, our monadified tracing aspect of fac does not yield the
same result. Consider the following code for the tracing example
generated by our monadification function5.
tracerFacM :: (M Int -> M Int -> M Int) ->
(M Int -> M Int -> M Int)
tracerFacM proceed arg arg2 =
do getIndentResult <- getIndentM
let ind = return getIndentResult
let ind’ = (liftM2 (++)) (return "| ") ind
setIndent ind’
let show_arg2 = (liftM show) arg2
let str_1 = (liftM2 (++)) show_arg2 (return "]")
let str_2 = (liftM2 (++)) (return ",") str_1
let show_arg = (liftM show) arg
5 The tracerMulM is very similar to tracerFacM, and thus omitted.
let str_3 = (liftM2 (++)) show_arg str_2
let str_4 = (liftM2 (++)) (return "fac receives [")
str_3
let str_5 = (liftM2 (++)) ind str_4
putMsgM (return "tracerFacM") str_5
proceedResult <- proceed arg arg2
let result = return proceedResult
setIndent ind
let s_result = (liftM show) result
let str_6 = (liftM2 (++)) (return "fac returns ")
s_result
let str_7 = (liftM2 (++)) ind str_6
putMsgM (return "tracerFacM") str_7
result
facM :: M Int -> M Int -> M Int
facM n acc =
do let eq_n_zero = (liftM2 (==)) n (return 0)
neq0 <- eq_n_zero
if neq0 then acc
else do let nmacc = (tracerMulM (liftM2 (*)) n acc
let nm1 = (liftM2 (-)) n (return 1)
(tracerFacM facM) nm1 nmacc
mainM = (tracerFacM facM) (return 3) (return 1)
Running the above monadified tracing program with (facM
(return 3) (return 1)) yields the following incorrect trace.
fac receives [3, 1]
| | times receives [3, 1]
| | times returns 3
| fac receives [2, 3]
| | | | times receives [3, 1]
| | | | times returns 3
| | | times receives [2, 3]
| | | | times receives [3, 1]
| | | | times returns 3
| | | times returns 6
| | fac receives [1, 6]
.
.
.
| | | | | | times receives [3, 1]
| | | | | | times returns 3
| | | | | times receives [2, 3]
| | | | | | times receives [3, 1]
| | | | | | times returns 3
| | | | | times returns 6
| | | | times returns 6
| | | fac returns 6
| | fac returns 6
| fac returns 6
fac returns 6
From the generated trace, we can see that some expressions,
such as times 3 1, are evaluated more than once and in wrong or-
ders. In other words, the monadified tracing program obtained not
only changes the order of evaluation but also duplicates the eval-
uation of some expressions, thus delivering wrong order of trac-
ing messages. This result is disturbing: Aspects such as tracing are
usually perceived as a non-interference aspect in typical imperative
aspect-oriented programs. However, for aspect-oriented functional
language with lazy semantics, such aspects can turn out to be inter-
fering despite the introduction of monadic computation.
A closer look at the monadified aspect code reveals the source
of the problem: Calling the lifted show function, (liftM show),
with the argument arg2, which in turns invokes the show function
to obtain string representations of the arguments. This will lead
to premature evaluation of the invocation of the multiplication,
which is also being traced. Later, when the call to facM is resumed
via proceed call, the multiplication call will be triggered and
traced again. Hence the problem here is how to preserve the lazy
str_4 <- add2Cache $
(liftM2 (++)) (return "fac receives [") str_3
str_5 <- add2Cache $ (liftM2 (++)) ind str_4
putMsgM (return "tracerFac") str_5
proceedResult <- proceed arg arg2
let result = return proceedResult
setIndentM ind
show_res <- add2Cache $ showM result
str_6 <- add2Cache $
(liftM2 (++)) (return "fac returns ") show_res
str_7 <- add2Cache $ (liftM2 (++)) ind str_6
putMsgM (return "tracerFac") str_7
result
facM :: M Int -> M Int -> M Int
facM n acc =
do eq_n_zero <- add2Cache $ (liftM2 (==)) n (return 0)
neq0 <- eq_n_zero
if neq0 then acc
else do nmacc <- add2Cache $
(tracerMulM (liftM2 (*)) n acc
nm1 <- add2Cache $ (liftM2 (-)) n (return 1)
(tracerFacM facM) nm1 nmacc
Lastly, note that in Section 3.2, we decided against treating let!-
expression as syntactic sugar. With the introduction of cache into
our system, it is worth noticing that we do not have to introduce
add2cache operations to the monadified let!-definition.
4. Transforming Monadic Programs
Although AspectFun does not yet support monadic base programs,
we can still describe how to extend our modification transformation
when the base program is already monadic.
4.1 Using Monad Transformers
In the presence of monadic base programs, we need to employ
the state monad transformer mechanism to combine the monad of
the base program with the aspect monad. For example, the display
update program in Example 3 uses the IO monad, hence the aspect
monad for it is defined as follows.
type S m a = StateT (UserVar, OutputBuf) m a
type M a = S IO a
In general, the monadification operator M should be extended as
follows:
M(t1 → t2) ⇒ M(t1) →M(t2) (3)
M(a) ⇒ MT N a (4)
M(N (t1 → t2)) ⇒ MT N (M(t1) →M(t2)) (5)
M(N a) ⇒ MT N a (6)
where N is the monad used in the base program (base monad), and
MT is the monad transformer being used. In Example 3, N is IO
and MT is StateT (UserVar, OutputBuf).
Finally, the monadification function, [[·]]Γ , also needs to be ad-
justed. There are two categories of changes. Firstly, we must apply
proper lifting operations when passing computed values between
the base monad and the aspect monad. Essentially, we shall use
liftM operator to lift operations on the base monad before apply-
ing them, and use liftN operator to lift results of computations in
the base monad, N. The following enhanced versions of (PRIM) and
(APP) illustrate the ideas.
(PRIM) [[p]]Γ = liftMn p
where n is the arity of the primitive function
or the base monad operation p
(APP) [[e1 e2]]Γ =
if isFullAppBaseMonadOP (e1)
then do {x ← [[e1]]Γ [[e2]]Γ; liftN x}
else [[e1]]Γ [[e2]]Γ
Secondly, we need to extend the [[·]]Γ function to handle the bind
(=) and the return operations of the base monad.
(BIND) [[do {x ← e1; e2}]]Γ =
do {x′ ← [[e1]]Γ; let x = return x′; [[e2]]Γ}
(RETURN) [[return e]]Γ = [[e]]Γ
In the case of (BIND), we need to use the return of the new monad
to move the result of do-binding action back to the new monad. As
to the case of (RETURN), we simply drop the return of the base
monad and return the monadified expression.
The following code snippets show the original version of the
getLineP1 function and its monadified version.
getLineP1 :: Line -> IO Point
getLineP1 (L l) =
do (p1,_) <- readIORef l
return p1
getLineP1M :: M Line -> M Point
getLineP1M ll =
do (L lBindout) <- ll --PatternMatching
let l = return lBindout --Bind
bmOP <- (liftM readIORef) l --Prim
(_, p1BindOut) <- liftIO bmOP --App
let p1 = return p1Bindout --Bind
p1 --Return
4.2 Unified Monadification Scheme
We started from a simple state monad of user variables and output
buffer, and then extended it with a cache facility. Now we gener-
alized the state monad along another direction using monad trans-
former. It would be nice to combine these different enhancements
under a unified monadification framework. Specifically, we devise
a cache-extended state monad transformer that can accommodate
the aspect monads presented so far as special cases. This monad
transformer, CStateT, is defined in terms of another monad trans-
former, CacheT as follows.
newtype CacheT m a = CacheT{
realrunCacheT :: Cache ->
m (Either a Int, Cache)}
type CStateT s m a = CacheT (StateT s m) a
instance MonadTrans CacheT where
lift ma = CacheT $
\cs -> ma >>= \a -> return (Left a, cs)
instance Monad m => Monad (CacheT m) where
return t = CacheT $ \cs -> return (Left t, cs)
ca >>= k = CacheT $ \cs ->
do (ea, cs’) <- realrunCacheT ca cs --Either a
(ra, cs’’) <- fromCacheEither ea cs’
realrunCacheT (k ra) cs’’
instance MonadIO m => MonadIO (CacheT m) where
liftIO = lift . liftIO
...
References
[1] Kung Chen, Shu-Chun Weng, Meng Wang, Siau-Cheng Khoo,
and Chung-Hsin Chen. A compilation model for aspect-oriented
polymorphically typed functional languages. In Static Analysis, 14th
International Symposium, SAS 2007, volume 4634 of LNCS, pages
34–51. Springer-Verlag, 2007.
[2] Martin Erwig and Delin Ren. Monadification of functional programs.
Science of Computer Programming, 52(1-3):101–129, 2004.
[3] Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen.
The essence of compiling with continuations. In Proceedings of the
ACM SIGPLAN 1993 conference on Programming language design
and implementation, pages 237–247, 1993.
[4] John Hatcliff and Olivier Danvy. A generic account of continuation-
passing styles. In Proceedings of the 21st ACM SIGPLAN-SIGACT
symposium on Principles of programming languages, pages 237–247,
1993.
[5] Christian Hofer and Klaus Ostermann. On the relation of aspects and
monads. In Foundations of Aspect-Oriented Languages Workshop at
AOSD, pages 37–46. ACM Press, 2007.
[6] Gregor Kiczales, Erik Hilsdale, Jim Hugunin, Mik Kersten, Jeffrey
Palm, and William G. Griswold. An overview of aspectj. In ECOOP
’01: Proceedings of the 15th European Conference on Object-
Oriented Programming, volume 2072 of LNCS, pages 327–353.
Springer-Verlag, 2001.
[7] Amir Kishon. Theory and Art of Semantics-Directed Program
Execution Monitoring. PhD thesis, Yale University, June 1992.
[8] Amir Kishon and Paul Hudak. Semantics directed program execution
monitoring. Journal of Functional Programming, 5(4):501–547,
1995.
[9] Ralf La¨mmel. Reuse by program transformation. In Functional
Programming Trends 1999. Intellect, 2000. Selected papers from the
1st Scottish Functional Programming Workshop. Intellect, 2000.
[10] Sheng Liang, Paul Hudak, and Mark Jones. Monad transformers and
modular interpreters. In Proceedings of the 22nd ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages, pages
333–343, 1995.
[11] W. De Meuter. Monads as a theoretical foundation for aop.
In International Workshop on Aspect-Oriented Programming at
ECOOP, 1997.
[12] Philip Wadler. The essence of functional programming. In
Proceedings of the 19th Annual ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages, pages 1–14, 1992.
[13] Meng Wang, Kung Chen, and Siau-Cheng Khoo. Type-directed
weaving of aspects for higher-order functional languages. In PEPM
’06: Workshop on Partial Evaluation and Program Manipulation,
pages 78–87. ACM Press, 2006.
[14] Keith Wansbrough and Simon Peyton Jones. Once upon a polymor-
phic type. In Twenty-sixth ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages, pages 15–28, January 1999.
 2
我們已經將這套機制與轉換技術實作於 AspectFun 語言中。 
 
除了簡報以上成果外，我也將目前所遇到的問題與解決之道題出來就教於在場的學者專家。這個
問題示當我們要轉換的對象是高階函數時，原有的轉換言算法就不能正確運作。針對此問題，我們擴
增了一些轉換機制，讓高階函數也能透過原本的架構順利運作，但也無可避免的增加了一些轉換後程
式碼執行期的負擔(overhead)。與會的丹麥 Aarhus 大學教授 Danvy 針對此一課題，提出了他的看法並
給我們一些具體的建議。 
在會議中，我們遇到了好幾位在此領域久仰大名的資深學者，例如 :John Hughes, Lennart 
Augustsson，Olivier Danvy和 David MacQueen，也見識了他們好學不倦，仍然自己寫程式的學者風範。
此外，也接觸了多位知名的專家，既有任教大學的學者，也有於產業界應用函數程式設計的專家。例
如，創辦Galois公司的John Launchbury博士，以及創辦BlueSpec公司的Rishiyur Nikhil博士。透過他們的
演講，我也了解到一些如何將函數程式設計應用到產業的方式。最後，我也與和會的日本韓國學者進
行廣泛的交流，一方面建立交流管道，一方面也藉此了解他們的研究課提與成果，收穫頗豐。 
 三、考察參觀活動(無是項活動者略) 
四、建議 
 這次參與 WG 2.8 的年會是很特別的經驗，會議中除了一般的專題演講外，還安排了分組討論
與程式解題的活動，非常強調與會者的互動。跟日本韓國比起來，函數程式設計與語言在台灣還
是相當少學者耕耘的領域，因此我們這個整合型計畫也附帶以夏日學校（summer school）方式來
推廣函數程式設計，目前已經舉辦了三次。希望國科會資訊學門可以繼續支援我們這個活動。 
五、攜回資料名稱及內容 
六、其他 
 
  
 4
 
I'm expecting a total attendance of around 30 people (roughly 50/50 members/guests), which is small 
enough to have real debate.  There's a list of WG2.8 members below -- I'm sure you will already know 
most or all of them. 
 
What would you get out of it?  I think you'd enjoy the meeting a lot.  It's a great chance to have an 
extended time with some really bright people.  It's not all talks -- there are longish breaks, so there is time 
for side conversations.  It's a significant commitment though; it would only be worth coming if you can 
spend most of the week with us.  The dates immediately precede FLOPS in Sendei 
http://www.kb.ecei.tohoku.ac.jp/flops2010/wiki/, which makes it easy for those coming from outside Japan 
to attend both meetings. 
 
I really hope you can come.  I'll look forward to your reply. 
 
best wishes 
 
Simon Peyton Jones 
 
======================= 
WG2.8 members 
 
Arvind, Benjamin Pierce, Bob Harper, Manuel Chakravarty, Chris Clack, 
Chris Okasaki, Colin Runciman, Conal Elliott, Corky Cartwright, David 
Turner, Jack Dennis, Didier Remy, David MacQueen, Erik Meijer, Norman 
Ramsey, Greg Morrisett, Fritz Henglein, John Launchbury, Kathleen 
Fisher, Koen Claessen, Lennart Augustsson, Mark Jones, Martin Odersky, 
Olivier Danvy, Paul Hudak, Peter Thiemann, Philip Wadler, Ralf Hinze, 
Rishiyur Nikhil, Dick Kieburtz, Simon Peyton Jones, Steve Zdancewic, 
Joe Stoy, Stephanie Weirich, Xavier Leroy, Don Syme, John Hughes, John 
O'Donnell, Mary Sheeran, Olin Shivers, Richard Bird, Rinus Plasmeijer, 
Satnam Singh 
國科會補助專題研究計畫項下出席國際學術會議心得報告 
                                     日期：100年 12月02 日 
計畫編號 NSC 97－2221－E－004－001－MY3 
計畫名稱 程式之模組性與擴充性:驗證方法與工具-子計畫五:剖面導向函數語言之模組化狀態處理與型態擴充研究（第 3 年） 
出國人員
姓名 陳 恭 
服務機構
及職稱 國立政治大學資訊科學系教授 
會議時間 
100 年 10 月 17 日
至 
100 年 10 月 18 日 
會議地點 
Shanghai, PRC 
會議名稱 
(中文) 
(英文)  2011 Asian/Pacific Workshop on Aspect-Oriented Software Design 
發表論文
題目 
(中文) 
(英文) An Aspect-Based Taint Tracker for Finding Security Vulnerabilities in Web 
Applications 
一、參加會議經過 
此 Workshop 是由本人與數位亞洲地區的學者於 2005 年 3 月發起的學術交流活動，第一次在該年
12 月於臺北圓山飯店與 Asia-Pacific Software Engineering 會議(APSEC’05)一起舉行。今年是第七次舉
辦，由上海交通大學主辦，有 30 位左右參與者，分別來自中國大陸、美國、日本、台灣與瑞士。  
本人在此會議中分享的是「An Aspect-Based Taint Tracker for Finding Security Vulnerabilities in Web 
Applications」。我指導學生應用AspectJ對 Java網頁應用程式的安全漏洞進行動態分析。為了在程式執
行期間得到可利用的分析資訊，我們運用了AspectJ的插碼技術。我們的工具會先將負責收集資訊的模
組插入應用程式的源碼，並以單元測試的方式執行程式，於程式執行的過程中將分析資訊傳遞給分析
模組，利用Java 語言的特性進行汙染資料（user input）的追蹤，以發現程式中的安全弱點。由於Java
語言字串的參考特色，我們的工具可以準確地追蹤受污染的字串的流向，順利地找出能造成安全漏洞
的弱點路徑。日本東京大學的Masuhara教授在會議中，就我們的工具提出了一些具體的改善建議，也
是此行的一個收獲。 
二、與會心得 
本次會議有兩個場次讓我印象深刻，簡要描述如下。 
 
來自瑞士 Lugano 大學的 Walter Binder 教授發表「High-level Abstractions for Instrumentation-based 
Dynamic Program Analysis」。他的演講內容非常精采，首先他分享了他們研究團隊過去以 AspectJ 語
 1
 3
 
97 年度專題研究計畫研究成果彙整表 
計畫主持人：陳恭 計畫編號：97-2221-E-004-001-MY3 
計畫名稱：程式之模組性與擴充性：驗證方法與工具--子計畫五:剖面導向函數語言之模組化狀態處理
與型態擴充研究 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 2 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 1 0 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 6 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
■達成目標 
□未達成目標（請說明，以 100 字為限） 
□實驗失敗 
□因故實驗中斷 
□其他原因 
說明： 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：■已發表 □未發表之文稿 □撰寫中 □無 
專利：□已獲得 □申請中 ■無 
技轉：□已技轉 □洽談中 ■無 
其他：（以 100 字為限） 
3. 請依學術成就、技術創新、社會影響等方面，評估研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）（以
500 字為限） 
本計畫以我們過去發展出的 AspectFun 語言為基礎，進行擴充性探討。最主要的成果是以
剖面與編譯技術來模組化純粹函數語言內的狀態處理。純粹函數語言（Haskell 為典型範
例）不直接支援指定敘述（assignment），狀態處理必須透過 monad 的機制，將狀態處理
封裝在 monad 之內，以簡化狀態處理的程式撰寫。但是一旦使用 monad，程式所有相關部
分都要改成 monadic 的寫法，因此也是一種橫跨式的大幅變動。我們的作法是在 AspectFun
直接提供具備狀態處理功能的剖面 (side-effecting aspects)，透過編譯技術將其與程
式本體自動轉換成 monadic 方式（稱為 mondaification），以提高純粹函數程式的處理狀
態的模組化程度。我們的 monadification 轉換方法不僅可以處理高階函數，對於應用惰
性求值的函數式語言也可適用，大幅提高純粹函數程式的模組化。我們也將這套機制與轉
換技術實作於 AspectFun 的編譯器，並將其發布於中研院的開放源碼平台 Open Foundry。
此外，我們定義了 side-effecting aspects 的操作型與語義，驗證我們的程式轉換方法
的正確性。 這些結果都收錄於我們即將刊登於 Higher-Order Logic and Symbolic 
Computation 期刊的論文（附錄二）。 
 
剖面導向技術的發展已有一段時日，但將剖面應用於模組化純粹函數語言內的狀態處理是
本計劃的創新之處，未來應可以繼續延伸，朝功能更完整的語言機制發展。我們的研究範
疇涵蓋了程式語言的設計、實作與理論模型與驗證各個面向，兼具廣度與深度，參與的學
生與助理得以吸收許多程式語言理論與實務的專業知識與技術。不過，由於程式語言的研
