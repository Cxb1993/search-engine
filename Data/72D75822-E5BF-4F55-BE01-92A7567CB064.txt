of rounds cannot be reduced if no faulty processor is 
present in the network, and much time will be wasted 
on unnecessary rounds of message exchange. In 
contrast, EBA protocols dynamically adjust the number 
of rounds of message exchange according to the 
influence from faulty processors. In terms of 
efficiency, EBA protocols certainly outperform IBA 
protocols. All of the existing EBA protocols have 
been designed for static networks, they cannot work 
on MANET. In this study, we revisit the EBA problem 
in MANETs to increase the reliability of MANETs. 
Furthermore, we also prove and conduct several 
simulation results to validate that the proposed 
protocol requires the minimum rounds of message 
exchange and can tolerate the maximum number of 
malicious faulty processors. 
英文關鍵詞： Fault-tolerance Distributed System, Byzantine 
Agreement, Eventual Byzantine Agreement, Immediate 
Byzantine Agreement, Early Stopping, Mobile Ad-hoc 
Network. 
 
  2
exchange is determined by the total number of processors in the network. In other words, the number of 
rounds cannot be reduced if no faulty processor is present in the network, and much time will be wasted on 
unnecessary rounds of message exchange. In contrast, EBA protocols dynamically adjust the number of 
rounds of message exchange according to the influence from faulty processors. In terms of efficiency, EBA 
protocols certainly outperform IBA protocols. All of the existing EBA protocols have been designed for 
static networks, they cannot work on MANET. In this study, we revisit the EBA problem in MANETs to 
increase the reliability of MANETs. Furthermore, we also prove and conduct several simulation results to 
validate that the proposed protocol requires the minimum rounds of message exchange and can tolerate the 
maximum number of malicious faulty processors.  
Keywords: Fault-tolerance Distributed System, Byzantine Agreement, Eventual Byzantine Agreement, 
Immediate Byzantine Agreement, Early Stopping, Mobile Ad-hoc Network.  
 
1. Introduction 
The rapid development of wireless networking technology in recent years has induced a significant 
evolution of network patterns from static networks to dynamic networks [9][11][12][25][27]. The Mobile 
Ad-hoc Network (MANET) is a kind of dynamic network. The characteristics of MANETs are flexibly, 
mobility, scalability and self-organizing [9][12][25]. However, this evolution has also made it easy for 
attackers to join the networks and launch malicious attacks [17][27]. The reliability of MANETs is thus 
seriously challenged. Therefore, how to create a reliable and fault-tolerant MANET is an important issue 
[17][20]. In this section, we give brief introductions of the classifications of network models and the related 
works of fault-tolerance issue. 
1.1 The Classification of Network Models 
The network models can be classified into two categories based on their mobility features. The two 
types are static network and MANET. Static networks rely on physical wires for communication and 
therefore lack mobility. Topology of static networks is usually stationary and invariable [8][15][22][24].  
There are four common types of static networks: (1) Broadcast Network: a broadcast network is a 
network architecture in which a set of processors are connected via a shared communications line, called a 
bus. Compared with other types of networks, broadcast networks require lower deployment costs but higher 
management and maintenance costs. Because all the processors are connected to one single bus, damage of 
this bus may cause breakdown of the entire network [8]. An example of bus network is shown in Figure 1(a). 
(2)Fully Connected Network: a fully connected network is a mesh network in which each of the processors is 
connected to each other directly. So, processors can directly communicate with one another without relay of 
  4
1. 2 Fault-Tolerance 
Fault-tolerant distributed systems maintain normal operation at all times. If any component is damaged, 
the systems may have reduced performance but still produce unaffected computing results. To ensure that the 
system is robust, we need a mechanism to allow a set of processors to reach a common agreement, even in 
the presence of failures and malicious attacks [20]. Therefore, there has been a dramatic proliferation of 
research concerned with the Byzantine Agreement (BA) problem [2][14][16][18][19][22][24]. The 
applications of BA are replicated file system [1], the design of IPS systems [6], and landing tasks controlled 
by a flight path finding system [3]. 
1.2.1 Immediate Byzantine Agreement (IBA)  
BA problem was first studied by Pease, Shostak, and Lamport [18] in 1980. Protocols designed to deal 
with the BA problem should satisfy the following conditions:  
(BA_Condition 1): All non-faulty processors reach on the same common agreement value; 
(BA_Condition 2): If the source processor is non-faulty, then all non-faulty processors agree on the 
source processor’s initial value. 
The network context is described as follows: In a network consisting of n (n≥4) processors, one 
processor is selected to be the source processor with an initial value vs and the network can tolerate a 
maximum of t (t = ⎣(n-1)/3⎦) faulty processors [16][18]. The process of executing the BA protocol begins 
with the source processor sending its initial value vs to other processors in the network. These other 
processors will then exchange the messages they have received. After t+1 rounds of message exchange, if the 
number of faulty processors in the network is smaller than t, non-faulty processors in the network can reach 
an agreement. The term "round" denotes the message exchange interval between any pair of processors. A 
round is defined as follows: (1) sends messages to other processors; (2) receives messages from other 
processors; (3) does local processing. The main difficulty of the BA problem lies in that the source processor 
may be a faulty processor too. In this condition, which we call the worst-case of BA problem, the source 
processor may send different initial values to other processors in the network to prevent them from reaching 
an agreement.  
The above description reveals that all conventional agreement problems assume that a maximum 
number of faulty processors (t = ⎣(n-1)/3⎦) are present in the network. BA protocols that require t+1 rounds 
of message exchange are developed to cope with this condition. This type of BA protocols is also called 
Immediate Byzantine Agreement (IBA) protocol [2][18][19][24]. Many graceful IBA protocols with 
different symptom of faulty components have been proposed. For example, Lamport et al. [18] solved the 
BA problem in fully connected networks, Babaoglu et al. [2] solved the BA problem in bus networks, Siu et 
  6
partially connected network) [14][22]. While MANETs are becoming more dominant in nowadays, these 
EBA protocols cannot be applied to MANETs. Mobile processors may move away during operation of EBA 
protocols and thus miss some messages. After they return to the network, their loss of some messages makes 
it impossible for them to obtain a common agreement value. To date, no EBA protocol has been designed for 
MANETs. Therefore, this study attempts to design an EBA protocol for distributed MANETs and use it to 
create a highly reliable distributed networking environment. The classification of network models, Byzantine 
Agreement problems and failure types is shown in Figure 2. 
 
Figure 2. The classifications of network models, Byzantine Agreement problems and failure types 
1.4 Roadmap 
This report consists of five sections, and the remainder is organized as follows. Section 2 shows the 
conditions for EBA problem. Section 3 proposes the EBA protocol and gives an example of executing our 
protocol. Section 4 proves the correctness of our protocol. Section 5 proves the performance evaluation of 
our protocol. Finally, the conclusion is proposed in Section 6. 
 
2. The Conditions for Eventual Byzantine Agreement Problem 
Before the EBA problem can be solved in MANETs, the behavior of faulty processors, constraints and 
system model must be made clear in advance. 
2.1 The behavior of faulty processors 
Common types of faults of processors are as follows: (1) Crash fault: The processor is severely 
damaged and cannot operate normally [13]; (2) Omission fault: Loss or delayed transmission of packets 
occurs to the processor during message exchange, thus disabling other processors to receive the packets 
successfully [21]; (3) Invariant faults: The processor always sends an invariant value to other processors no 
matter what it has received [22]; (4) Malicious faults: The processor, being malicious itself or under control 
of an external attacker, works with other faulty processors to disrupt normal operation of the system. This 
type of fault is viewed as a fault with intelligence [4]. 
Therefore, malicious fault is the most serious failure type. This implies that if the system can work 
  8
 Let t be the number of allowed malicious faulty processors, t= ⎣(n- |PAwP|-1)/3⎦. 
 Let fact be the actual number of malicious faulty processors, 0 ≤ fact ≤ t. 
 
Figure 3. An example of a MANET  
 
3. The Concept and Approach of the Proposed Protocol 
To provide reliable MANETs, we propose the protocol "Eventual Byzantine Agreement Protocol for 
MANETs with malicious faulty processors" (EBAMANET) to solve the EBA problem with malicious faulty 
processors in MANETs.  
The goal of EBAMANET is to reach a common agreement value with non-faulty processors in the presence 
of malicious faulty processors. There are three phases in EBAMANET. The three phases are Message 
Exchanging Phase, Decision Making Phase and Agreement Replenishing Phase. A brief explanation of each 
phase of the proposed approach is as follows. Message Exchanging Phase is a phase where processors send 
and receive messages to and from other processors. To collect enough messages for reaching an agreement, 
EBAMANET requires min{fact+2, t+1} rounds of message exchange in this phase. After each round of message 
exchange, the early stopping rule function designed for MANETs will be used to determine if enough 
messages have been collected. Processors with enough messages collected can enter the next phase, Decision 
Making Phase; processors without enough messages collected need to continue the message exchange 
operation. In Decision Making Phase, a decision function is available for processors to compute the final 
agreement value. This function ensures that all non-faulty processors can obtain the same agreement value. 
Moreover, some processors may be away during message exchange, these processors will directly enter 
Agreement Replenishing Phase when they return to the network. In this phase, return processors will request 
always-alive processors (did not move away from the network during the execution of EBAMANET) to send 
them the agreement value. After these return processors have collected the same agreement values from t+1 
processors, the final agreement value can be determined.  
That is, EBAMANET includes the early stopping rule function and decision function to solve the EBA 
problem with malicious faulty processors in MANETs. In the following section, we give the detailed 
descriptions of early stopping rule function and decision function. 
  10
will be affected by at most t-(i-1) faulty processors. If the number of leaves with value 0 deducted by 
t-(i-1) is still greater than 1/2 of all leaves, value 0 represents the absolute majority, and it will be 
unaffected by influence from other faulty processors; (3) In round i, non-faulty processors will be 
affected by at most t-(i-1) faulty processors. If the number of leaves with value 1 deducted by t-(i-1) is 
still greater than 1/2 of all leaves, value 1 represents the absolute majority, and it will be unaffected by 
influence from other faulty processors; (4) If all the above three conditions are not met, the function 
will return τ, meaning that the messages collected so far are not enough for reaching an agreement, and 
another round of message exchange is necessary. 
To be succinct, the ESRMANET function has four conditions. Conditions 1, 2, and 3 are intended to 
check if the collected value (δj or 1 or 0) can represent the majority. If positive, the value will be 
unaffected if other faulty processors exist. Condition 4 is intended to tell processors that the current 
value is not a value agreed by the absolute majority and it may be affected by other malicious faulty 
processors. 
Function ESRMANET (Leaves, i, n, t) 
1. begin 
1:   if ((|Leaves|δj ≥ (n-t-(i-1))) or  ----- (1) 
2:     (((|Leaves|0 - (t-(i-1))) / ((n-(i-1)-|Leaves|δj)/2))≥ 1) or  ----- (2) 
3:     (((|Leaves|1 - (t-(i-1))) / ((n-(i-1)-|Leaves|δj)/2)) > 1)  ----- (3) 
4:     return Ω 
5:   else  
6:     return τ   ----- (4) 
7: end 
Figure 4. Early Stopping Rule for MANET with malicious faulty processors (ESRMANET) 
 The decision function "DecMANET" 
The goal of decision function is used to compute the agreement value. In this study, we propose a 
decision function for MANETs: Decision function for MANET with malicious faulty processors 
(DecMANET). In the worst case, after min{fact+2, t+1} rounds of message exchange, each non-faulty 
processor can receive enough messages to remove the influence from malicious  faulty processor by 
using the DecMANET function. The DecMANET function only counts the non-value δ0 (excluding the last 
level of the ic-tree) for all vertices at the i level of an ic-tree, where1≤i≤t+1, t=⎣(n-1)/3⎦. The formal 
description of the proposed DecMANET function is shown in Figure 5. Function #x(α) is used to count the 
number of occurrences of x in α’s child nodes. Function Maj(α) is used to compute the majority value 
of α’s child nodes. 
DecMANET function has five conditions: If the vertex α is a leaf, then there is only one value in the 
  12
3.1.2 The Decision Making Phase in EBAMANET 
After having collected sufficient messages, the processors will enter Decision Making Phase. In this 
phase, all non-faulty processors can use the DecMANET function to compute the final agreement value. The 
procedure is as follows: After entering Decision Making Phase, the processors will input their ic-tree leaves 
(e.g. Level i) into the DecMANET function to compute the values of their parent nodes (Level i-1), level after 
level, until the value at the root (Level 1) is obtained. This root value is the final agreement value. Further, 
after obtaining the agreement value using the DecMANET function, processors will send the agreement value to 
other processors in the network. For those which have not reached an agreement, if they receive the same 
agreement value (v) from t+1 processors, they will also set v as their root value (i.e. agreement value). Since 
the system has a maximum of t malicious faulty processors, if processors which have not reached an 
agreement can obtain the same agreement value from t+1 processors, the influence from t malicious faulty 
processors can be masked. Therefore, this value agreed by t+1 processors can be viewed as the final 
agreement value. 
3.1.3 The Agreement Replenishing Phase in EBAMANET 
When any processor returns or any newcomer joins the network, the processor will request other 
processors reaching an agreement to send it the agreement value. After collecting the same agreement value 
from t+1 processors, the return processor will set the value as its final agreement value. In this phase, return 
processors and newcomers collect values from processors reaching an agreement, thus accelerating 
achievement of an agreement. 
The EBAMANET protocol can be presented with the following primitives:  
 EncSend(m,p): send the message m to processor p by encryption technology. 
 EncRcv(m,p): receive the message m from processor p by encryption technology. 
 Package(i,m): according the structure of level i of the ic-tree, package level i of the ic-tree to 
message m. 
 Unpackage(m,i): according the structure of level i of the ic-tree, unpackage message m. 
 val(αp): the value of vertex αp in the ic-tree. 
 CrtV(αp,v): create the vertex αp, and set val(αp)=v. 
 Rqt(p): request the agreement value of processor p. 
 Alive(p): checks the processor p is in the network or not. 
 ChEsP(p): checks the processor p is an early stopping processor or not. 
 vs: the initial value of source processor. 
 p-vBA: the agreement value of the processor p. 
 p-BA: the set of agreement values from other processors which is hold by processor p. 
 
  14
Figure 3). Among these processors, processor ps and processor p5 are malicious faulty processors, and 
processor ps is deemed as the source processor (worst case). By solving the worst case of the EBA problem in 
a MANET, we attempt to demonstrate the applicability of the proposed EBAMANET to all conditions of 
MANETs. During execution of EBAMANET, non-faulty processors are unaware of which processors are faulty. 
To help readers better understand the operation of EBAMANET, we will highlight faulty processors using 
special icons. 
In round 1 of Message Exchanging Phase, processor ps (source processor) sends its initial value to other 
processors in the network. Since processor ps is a malicious faulty processor, it may send inconsistent values 
(as shown in Figure 8(a)). After receiving the initial value of source processor ps, other processors store the 
value in the root of their ic-trees (as shown in Figure 8(b)). After all these steps are done, the processors then 
enter round 2. Source processor ps will not engage in message exchange starting from round 2. 
In round 2, processors will exchange the messages they have obtained in round 1 with one another. If 
processor p6 moves away in this round (as shown in Figure 8(c)), other processors in the network will fail to 
receive the message from processor p6 and use δ0 to denote the missing message (val(p6)=δ0). Moreover, if 
malicious faulty processor p5 sends 1 to processors p1, p2, p3, p4, p9, and p10, and 0 to p7, p8, p11, and p12, 
processors p1, p2, p3, p4, p9, and p10 will have the same ic-tress (as shown in Figure 8(d)); processors p11 and 
p12 have the same ic-tree (as shown in Figure 8(e)); and processors p7 and p8 have the same ic-tree (as shown 
in Figure 8(f)). In the meantime, these processors will use ESRMANET to examine if they have collected 
enough messages for an early entry into Decision Making Phase. In round 2 (i=2), processors p1, p2, p3, p4, p9, 
and p10 receive value 1 from nine processors (|leaves|1=9) and value δ0 (|leaves|δ0=1) from one processor. The 
condition of ESRMANET is met (|leaves|1-(t-(i-1))/((n-(i-1)- |leaves|δj)/2) =(9-(4-1))/((13-1-1)/2) >1). Processors 
p1, p2, p3, p4, p9, and p10 can thus enter Decision Making Phase first and use the DecMANET function to obtain 
the agreement value=1 (DecMANET(1,1,1,1,1,δ0,0,0,1,1,1,1)=1). After obtaining the agreement value, 
Processors p1, p2, p3, p4, p9, and p10 send the agreement value to other processors (as shown in Figure 8(g)) 
and stop exchanging messages. In contrast, processor p7, p8, p11, and p12 have not collected enough messages 
(i.e. the condition of ESRMANET is not met) for obtaining an agreement value and need to stay in Message 
Exchanging Phase. 
In round 3, processor p7, p8, p11, and p12 will receive the agreement value=1 from processors p1, p2, p3, p4, 
p9 and p10. The number of processors sending them agreement value=1 is greater than t (6>4), so processors 
p7, p8, p11, and p12 can reach an agreement. If processor p6 returns to the network at this moment (as shown in 
Figure 8(h)), it can directly enter Agreement Replenishing Phase, requesting other processors in the network 
to send it the agreement value (as shown in Figure 8(i)). Therefore, processor p6 can obtain the agreement 
  16
 
(h). Processor p6 returns the network
 
(i). Processor p6 receives other processor’s agreement value in the network 
Figure 8. An Example of execution EBAMANET 
 
4. The Correctness and Complexity of the Proposed Protocol 
The following lemmas and theorems are used to prove the correctness of the proposed protocol 
EBAMANET. 
Lemma 1: All correct vertices of an ic-tree are common. 
Proof: There are no vertices with repeated names in an ic-tree. At level t+1 or above, the correct vertex has 
at least 2t+1 children, out of which at least t+1 children are correct. The true values of these t+1 
correct vertices are in common, and the majority value of vertex is common. The correct vertex is 
common in the ic-tree if the level of is lower than t+1. As a result, all correct vertices of the ic-tree 
are common. 
Lemma 2: The common frontier exists in the ic-tree. 
Proof: There are t+1 vertices along each root-to-leaf path of an ic-tree in which the root is labeled by the 
source processor name, and the others are labeled by a sequence of processor names. Since at most t 
malicious faulty processors can be failed, there is at least one correct vertex along each root-to-leaf 
path of the ic-tree. By Lemma 1, the correct vertex is common, and the common frontier exists in 
each non-faulty processor’s ic-tree. 
Lemma 3: Let α be a vertex; α is common if there is a common frontier in the sub-tree rooted at α. 
Proof: If the height of α is 0 and the common frontier (α itself) exists, then α is common. If the height of α 
is r, the children of α are all in common under the induction hypothesis with the height of the 
children being r-1. 
  18
t+1} rounds of message exchange to reach an agreement. They require the same number of rounds of 
message exchange in this scene, so comparison of their performances is not necessary. The proposed 
protocol will be primarily compared with OMA, GPBA, and EMAP, as shown in Figure 9(a). 
 
Figure 9(a). The comparison of EBAMANET and IBA in terms of the number of round with ⎣(n-1)/3⎦ 
malicious faulty processor 
As shown in Figure 9(a), the number of rounds required by OMA, GPBA, and EMAP is positively 
related to the total number of processors (n), and all processors need to run ⎣(n-1)/3⎦+1 rounds to reach an 
agreement. For instance, OMA, GPBA, and EMAP require 34 (⎣(100-1)/3⎦+1) rounds if n=100 and 50 
(⎣(150-1)/3⎦+1) rounds if n=150. In contrast, the proposed EBAMANET protocol requires only 2 rounds if the 
source processor is non-faulty. It has such superior performance mainly because non-faulty source 
processors do not maliciously send inconsistent initial values to other processors in the first round. As a 
result, most processors can exchange a consistent value in the second round and use the ESRMANET function to 
enter Decision Making Phase and reach an early agreement. If the source processor is a malicious faulty 
processor, the number of rounds that EBAMANET requires will fall between 2 and ⎣(n-1)/3⎦+1. For instance, it 
requires 30 (2~34) and 33 (2~50) if n=100 and 150, respectively. Through this simulation result, we can 
confirm that EBAMANET outperforms OMA, GPBA, and EMAP in terms of efficiency, especially when the 
source processor is non-faulty. 
The second test scene is based on a static fully connected network with only 10% malicious faulty 
processors. The simulated network is static, so OESA and EGAP originally designed for static networks can 
certainly work in this scene. Like EBAMANET protocol, they all require (min{ fact+2, t+1}) rounds of message 
exchange to reach an agreement. Comparison with OESA and EGAP is thus unnecessary. We will focus on 
comparison of the proposed protocol with OMA, GPBA, and EMAP. The results are shown in Figure 9(b)). 
  20
 
Figure 9(c). The comparison of EBAMANET and IBA in terms of the number of round in the MANET 
The time that processors move away or return is variable. If processors move away or return to the 
network sporadically in every round, IBA protocols (OMA, GPBA, and EMAP) and EBA protocols (OESA 
and EGAP) may require more times of re-launch and certainly more rounds of message exchange. As shown 
in Figure 9(c), given 150 processors, IBA protocols (OMA, GPBA, and EMAP) require 532 rounds, while 
EBA protocols (OESA and EGAP) require 160 rounds. If most away processors return at nearly the same 
time, these protocols will require fewer rounds of message exchange. This is why IBA protocols (OMA, 
GPBA, and EMAP) require fewer rounds when n=250 than when n=200. The same phenomenon can be 
found among EBA protocols (OESA and EGAP) operating when n=300 and n=350. 
In contrast, EBAMANET requires return processors to wait until always-alive processors reach an 
agreement and then obtain their agreement value. Return processors can thus use the DecMANET function to 
obtain an agreement value. This is why EBAMANET has much higher efficiency than other protocols in 
MANETs. For instance, EBAMANET requires only 38 rounds if n=350. In the same scenario, OMA, GPBA, and 
EMAP require 1722 rounds, and OESA and EGAP require 582 rounds. The results of the three simulation 
results reveal the high applicability of EBAMANET for MANETs. 
 
6. Conclusion 
With advancement of software and hardware technologies in recent years, most processors are able to 
maintain normal operation for a long time. The number of faulty processors (fact) in reality is thus small and 
even far smaller than ⎣n/3⎦. If IBA protocols are used, all processors are required to run ⎣(n-1)/3⎦+1 rounds 
of message exchange even in the absence of faulty processors. Much time will be wasted on unnecessary 
rounds of message exchange. In contrast, EBA protocols which dynamically adjust the number of rounds of 
message exchange according to the practical number of faulty processors will be more efficient. 
  22
Secure Computing, Vol. 7, No. 1, pp. 80-93, 2010. 
[2] O. Babaoglu and R. Drummond, “Streets of Byzantium: Network Architectures for Fast Reliable 
Broadcasts,” IEEE Transactions on Software Engineering, Vol. 11, pp. 546-554, 1985. 
[3] A. Bar-Noy, D. Dolev, C. Dwork, H. Raymond Strong, "Shifting Gears: Changing Algorithms on the 
Fly To Expedite Byzantine Agreement," Information and Computation, Vol. 97, No. 2, pp. 205-233, 
1992. 
[4] A.N. Bessani, M. Correia, J. da Silva Fraga, L.C. Lung, "An Efficient Byzantine-Resilient Tuple 
Space," IEEE Transactions on Computers, Vol. 58, No. 8, pp. 1080-1094, 2009. 
[5] D. R. Broug, Logic Programming. New Frontiers, Kluwer Academic, 1992. 
[6] F. C. Colon Osorio, "Using Byzantine Agreement in the Design Of IPS Systems," Proceeding of the 
IEEE International Conference on Performance, Computing, and Communications, Vol. 97, No. 2, pp. 
528-537, 2007. 
[7] A. Caruso, S. Chessa, "Worst-Case Diagnosis Completeness in Regular Graphs under the PMC 
Model ," IEEE Transactions on Computers, Vol. 56, No. 7, pp. 917-9249, 2007. 
[8] T.E. Carroll, and D. Grosu, "Strategyproof Mechanisms for Scheduling Divisible Loads in 
Bus-Networked Distributed Systems," IEEE Transactions on Parallel and Distributed Systems, Vol. 19, 
No. 8, pp. 1124-1135, 2008. 
[9] M.D. de Amorim, A. Ziviani, Y. Viniotis, L. Tassiulas, "Practical Aspects of Mobility in Wireless 
Self-Organizing Networks," IEEE Wireless Communications, Vol. 15, No. 6, pp. 6-7, 2008. 
[10] M. Fisher, and N. Lynch, "A Lower Bound for the Assure Interactive Consistency," Information 
Processing Letters, Vol. 14, No. 3, pp. 183-186, 1982. 
[11] L. Garcia, L. Arnaiz, F. Alvarez, J.M. Menendez, K. Gruneberg, "Protected Seamless Content Delivery 
in P2P Wireless and Wired Networks," IEEE Wireless Communications, Vol. 16, No. 5, pp. 50-57, 
2009. 
[12] D. Huang, "Unlinkability Measure for IEEE 802.11 Based MANETs," IEEE Transactions on Wireless 
Communications, Vol. 7, No. 3, pp. 1025-1034, 2008. 
[13] S. Jafar, A. Krings, T. Gautier, "Flexible Rollback Recovery in Dynamic Heterogeneous Grid 
Computing," IEEE Transactions on Dependable and Secure Computing, Vol. 6, No. 1, pp. 32-44, 2009. 
[14] A.W. Krings, and T Feyer, "The Byzantine Agreement Problem: Optimal Early Stopping," Proceeding 
of the 32nd Hawaii International Conference on System Sciences, Vol. 8, pp. 1-12, 1999. 
[15] S. Kamil, L. Oliker, A. Pinar, J. Shalf, "Communication Requirements and Interconnect Optimization 
for High-End Scientific Applications," IEEE Transactions on Parallel and Distributed Systems, Vol.21, 
No. 2, pp. 188-202, 2010. 
[16] L. Lamport, R. Shostak, and M. Pease, "The Byzantine Generals Problem," ACM Transactions On 
Programming Languages and Systems, Vol. 4, No. 3, pp. 382-401, 1982. 
[17] T. Maseng, R. Landry, K. Young, "Military Communications," IEEE Communications Magazine, Vol. 
47, No. 10, pp. 36-38, 2009. 
[18] M. Pease, R. Shostak, and L. Lamport, "Reaching Agreement in the Presence of Faults," Journal of 
ACM, Vol. 27, No. 2, pp. 228–234, 1980. 
[19] H.S. Siu, Y. H. Chin, W.P. Yang, "Byzantine Agreement in the Presence of Mixed Faults on Processors 
and Links," IEEE Transaction on Parallel and Distributed Systems, Vol. 9, No. 4, pp. 335-345, 1998. 
1 
 
國科會補助專題研究計畫項下出席國際學術會議心得報告 
 
                               日期： 100 年 12 月 20 日 
一、參加會議經過 
二、與會心得 
三、考察參觀活動(無是項活動者略) 
四、建議 
五、攜回資料名稱及內容 
六、其他 
計畫編號 NSC99－2218－E－032－001－MY3 
計畫名稱 行動隨意式網路下強勢合議問題以及錯誤診斷問題之研究(3/3) 
出國人員
姓名 
鄭建富 
服務機構
及職稱 
淡江大學資訊工程學系 
助理教授 
會議時間 
100 年 12 月 12 日
至 
100 年 12 月 13 日 
會議地點 Hong Kong 
會議名稱 
(中文) 未來通訊與網路國際學術研討會 
(英文) International Workshop on Future Communication and 
Networking , IWFCN 2011 
發表論文
題目 
(中文) 以簽章訊息為基礎之合議問題 
(英文) Solving Consensus Problem with Signed Message 
3 
 
Natural Language Understanding 
Computer networks 
Parallel and Distributed Computing 
Computer Architecture 
Operating Systems 
Security and Cryptography 
Mobile computing 
Reconfigurable computing systems 
Embedded systems 
Data Management & Databases 
Information Retrieval 
Web Data Management 
Web Information Systems 
Multimedia DB's 
Mining Data, Text, Web 
Services, Grid, Cloud 
Power system release 
Predictive Control 
Process Control 
Real Time Control 
 
 
此外，在本研討會當中，共邀請了 2 位專家學者做專題講演，其主題內容如下： 
Keynote Speech 1: Intelligent Pattern Recognition and Applications – Modeling and Simulation in HC 
Interactive Environment 
Speaker: 
Dr. Patrick S.P. Wang,  
Fellow of IAPR and WASE, IEEE Outstanding Achievement Awardee. 
Professor of the Department of the Computer and Information Science, Northeastern University, 
Boston,  
Zijiang Visiting Chair, ECNU, Shanghai, NTU, Taipei  
iCORE Visiting Professor, University of Calgary, Canada  
Otto-von-Guericke Distinguished Guest Professor, University Magdeburg, Germany  
Founding Editor-in-Chief, IJPRAI and MPAI Book Series, WSP 
 
Keynote Speech 2: Neurodynamic Optimization Approaches to Shortest-path Routing 
Speaker: 
Dr. Jun Wang,  
Professor of the Department of the Mechanical & Automation Engineering, The Chinese 
University of Hong Kong 
Founding Editor-in-Chief, IJPRAI and MPAI Book Series, WSP 
5 
 
 
五、攜回資料名稱及內容 
  會議論文集、會議指南、大會 T 恤、識別證。 
 
六、其它 
  無 
 
 1 Copyright © #### by ASME 
 
Proceedings of 2011 International Conference on Instrumentation, Measurement, Circuits and Systems  
ICIMCS 2011 
December 13-14, 2011, Hong Kong 
SOLVING CONSENSUS PROBLEM WITH SIGNED MESSAGE 
 
 
Chien-Fu Cheng 
Department of Computer Science and Information 
Engineering, Tamkang University. 
New Taipei City, Taiwan 
cfcheng@mail.tku.edu.tw 
Kuo-Tang Tsai 
Department of Computer Science and Information 
Engineering, Tamkang University. 
New Taipei City, Taiwan 
kttsai@wireless.cs.tku.edu.tw 
 Hsien-Chun Liao 
Department of Computer Science and 
Information Engineering, Tamkang University. 
New Taipei City, Taiwan 
hcliao@wireless.cs.tku.edu.tw 
 
 
 
ABSTRACT 
Helping distributed systems keep away influences 
from faulty components and accurately perform assigned 
tasks is the primary goal of consensus algorithms. 
However, some signed message-based consensus 
algorithms still have certain drawbacks which make them 
ineffective in some conditions. To address this issue, we 
propose a new signed message-based consensus 
algorithm in this paper. 
 
Keywords: distributed consensus problem; oral message; 
signed message and grouping 
 
INTRODUCTION 
The consensus problem is a well-known type of 
fault-tolerance problems [5]. In any distributed system, 
some processors may not properly function due to 
damage of internal components, external influences or 
malicious attacks and therefore affect the computing 
results of the entire system [2][3]. By solving the 
consensus problem, we can enhance the reliability and 
fault-tolerance of distributed systems. Protocols designed 
to deal with the consensus problem with n commanders 
should satisfy the following two conditions: 
(Termination): All non-faulty processors agree on the 
same value; (Validitymv): If the initial value of each non-
faulty processor is vi, then all non-faulty processors agree 
on vi.  
We know that solution of the consensus problem 
mainly relies on message exchange. Previous research has 
classified the messages exchanged by use of the digital 
signature technology into oral messages and signed 
messages [9][10]. The algorithms that achieve consensus 
by exchanging oral messages are called Oral Message-
based Consensus Protocol (OMC protocol), and those 
achieve consensus by exchanging signed messages are 
called Signed Message-based Consensus Protocol (SMC 
protocol). Use of digital signature is a key factor affecting 
the fault-tolerance of a consensus protocol. Given n 
processors in a distributed computing network, OMC 
protocols can tolerate (n-1)/3 faulty processors [9]. In 
the same setting, SMC protocols can tolerate more than 
(n-1)/3 faulty processors due to use of digital signature. 
OM algorithm is the first OMC protocol. It was 
introduced in a paper co-authored by Lamport et al. [9] in 
1982. In this paper, the authors also developed an SMC 
protocol called SM algorithm [9]. Both algorithms (OM 
and SM) require (n-1)/3+1 rounds of message 
exchange. Due to high complexity of message exchange, 
many later researchers proposed solutions to reduce the 
complexity.  
For OMC protocols, some researchers proposed to 
determine termination of message exchange based on 
sufficiency of messages collected. This kind of algorithm 
is called the Eventual Consensus Algorithm (ECA). The 
Ensure Algorithm developed by Krings et al. [8] and the 
SMBTC (Synchronous Mortal Byzantine Tolerant 
Consensus) algorithm by Widder et al. [11] all belong to 
ECA. For SMC protocols, some researchers attempted to 
reduce the number of rounds of message exchange by 
employing the digital signature technology or improving 
the algorithm. For instance, Dalui et al. [6] introduced the 
Quick Consensus algorithm.  
In the following sections, we will introduce the 
algorithms proposed to mainly reduce the rounds of 
message exchange required, including the Ensure 
Algorithm [8], the SMBTC algorithm [11] and the Quick 
Consensus algorithm [6] respectively.  
 The Ensure algorithm by Krings et al.  
Ensure algorithm is proposed by Krings et al. [8]. 
During execution of the Ensure algorithm, each processor 
 3 Copyright © #### by ASME 
byzantine fault. The Quick Consensus algorithm requires 
only two rounds of message exchange but cannot achieve 
consensus in some conditions, as demonstrated in the 
preceding paragraph. Therefore, we will revisit the 
consensus problem in this paper to improve the 
drawbacks of these algorithms.  
 
THE CONCEPT AND APPROACH 
In this section, we will introduce the system model 
and the proposed protocol GCPsm.  
 System model 
The assumptions we have made for the network are 
as follows:  
 N is the set of processors in the network, where 
n=|N|. 
 Each processor has its own initial value and can be 
identified uniquely in the network.  
 The failure types of the fallible processors are 
malicious fault and dormant fault.  
 The maximum number of faulty processors 
allowed is n-2 (n ≥ t+2, where t=tm+td, tm is the 
number of malicious processors and td is the 
number of dormant processors).  
 A processor does not know the fault status of other 
processors.  
 All messages are signed; processors cannot falsify 
a message signed by other processors.  
 The Proposed Protocol GCPsm 
The proposed protocol is called Grouping Consensus 
Protocol with signed message (GCPsm). GCPsm is used to 
solve the consensus problem with malicious and dormant 
processors in the network. The basic operation of GCPsm 
is as follows: Each subgroup will first decide its "local" 
consensus value through message exchange and then elect 
the chief of its subgroup. Later, all the chiefs will 
exchange their local consensus values with each other to 
obtain the "global" consensus value. After obtaining the 
global consensus value, they will broadcast this value 
among the members of their subgroup to make all non-
faulty processors reach the consensus. The proposed 
protocol involves three tasks, including Group_Cons 
Task, Gmsg_Collect Task, and Re_Elect Task. 
Because GCPsm derives the "global" consensus value 
from "local" consensus values exchanged among 
subgroups, we must obtain the "local" consensus value of 
each subgroup first. We develop the SignConsensus 
function to meet this need. The pseudo code of 
SignConsensus function and GCPsm is shown in Fig. 2 
and Fig. 3.  
 
CONCLUSION 
In this study, we revisited the consensus problem in 
distributed systems. We proposed a signed message-based 
consensus algorithm that makes use of digital signature to 
effectively reduce the complexity of message exchange. 
The proposed algorithm can not only facilitate 
achievement of consensus by removing influences from 
malicious and dormant processors but also reduce the 
complexity of message exchange. 
 
REFERENCES 
 
[1] A.N. Bessani, M. Correia, J. da Silva Fraga, L.C. Lung, "An 
Efficient Byzantine-Resilient Tuple Space," IEEE Transactions 
on Computers, Vol. 58, No. 8, pp. 1080-1094, 2009. 
[2] C.F. Cheng, S.C. Wang and T. Liang, "Byzantine Agreement 
Protocol & Fault Diagnosis Agreement for Mobile Ad-Hoc 
Network," Fundamenta Informaticae, vol. 89, no. 2, pp.161-187, 
2008. 
[3] C.F. Cheng, S.C. Wang and T. Liang, "Investigation of 
Consensus Problem over Combined Wired/Wireless Network," 
Journal of Information Science and Engineering, vol. 25, No. 4, 
pp.1267-1281, 2009. 
[4] M. Correia, N. F. Neves, L. C. Lung and P. Verissimo, "Worm-
IT – A Wormhole-based Intrusion-tolerant Group 
Communication System," Journal of Systems and Software, vol. 
80, no. 2, pp.178–197, 2007. 
[5] M. Correia, N. F. Neves and P. Verissimo, "From Consensus to 
Atomic Broadcast: Time-Free Byzantine-Resistant Protocols 
without Signatures," The Computer Journal, vol.49, no.1, pp.82-
96, 2006. 
[6] M. Dalui, B. Chakraborty and B.K. Sikdar, "Quick Consensus 
Through Early Disposal of Faulty Processes," Proceedings of the 
22nd IEEE International Conference on Systems, Man and 
Cybernetics. pp. 1989-1994, 2009.  
[7] R. Friedman, A. Mostefaoui and M. Raynal, "Simple and 
Efficient Oracle-Based Consensus Protocols for Asynchronous 
Byzantine Systems," IEEE Transactions on Dependable and 
Secure Computing, vol. 2, no. 1, pp.46-56, 2005.  
[8] A. W. Krings and T. Feyer, "The Byzantine Agreement Problem: 
Optimal Early Stopping," Proceedings of the 32nd Annual 
Hawaii International Conference on System Sciences, LNCS 520, 
Springer-Verlag, Berlin, 1999. 
[9] L. Lamport, R. Shostak, and M. Pease, "The Byzantine Generals 
Problem," ACM Transaction on Programming Language 
Systems, Vol.4, No. 3, pp.382-401, 1982. 
[10] R.L. Rivest, A. Shamir and L. Adleman, "A Method for 
Obtaining Digital Signatures and Public-Key Cryptosystems," 
Communications of the ACM, vol. 21, no. 2, pp.120–126, 1978. 
[11] J. Widder, G. Gridling and B. Weiss and J.P. Blanquart, 
"Synchronous Consensus with Mortal Byzantines," Proceedings 
of the 37th Annual IEEE/IFIP International Conference on 
Dependable systems and Networks, pp.102-112, 2007.  
[12] W. Zhao, "Design and Implementation of a Byzantine Fault 
Tolerance Framework for Web Services," Journal of Systems and 
Software, vol. 82, no. 6, pp.1004–1015, 2009. 
 
 
 
國科會補助計畫衍生研發成果推廣資料表
日期:2011/05/25
國科會補助計畫
計畫名稱: 行動隨意式網路下強勢合議問題以及錯誤診斷問題之研究
計畫主持人: 鄭建富
計畫編號: 99-2218-E-032-001-MY3 學門領域: 計算機網路與網際網路
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
擔任國際知名學術研討會之議程委員： 
1.IEEE INFOCOM 2011, the 30th IEEE International Conference on Computer 
Communications (EI). 
2.IEEE ICCT 2011, the 12th IEEE International Conference on 
Communication Technology (EI). 
3.IEEE NBiS 2011, the 14th IEEE International Conference on 
Network-Based Information Systems. 
4.ACC 2011, the International Conference on Advances in Computing and 
Communications. 
5.CSCIST 2011, the 5th Cross-Strait Conference on Information Science 
and Technology. 
6.iCube 2011, the 3rd International Conference on University Basic 
computers education and eLearning. 
 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
