 I
無線感測處理器核心之研究與設計(3/3) 
 
計畫編號： 95-2221-E-007-022- 
執行期間： 中華民國 95 年 8 月 1 日至 96 年 10 月 31 日 
主持人： 許雅三教授 
Email: yshsu@ee.nthu.edu.tw 
執行單位： 國立清華大學電機所 
 
 
一､ 中文摘要 
 
近年來,許多人提出各類無線感測網路的研究。其應用包括家庭應用,安全監測,
健康醫療之應用,環境監測等等。在此計畫裡,我們針對三個重要議題提出研究:
安全性,低功耗設計,及如何評估及比較各種感測平台。另外也提出感測架構的
設計。在此報告中,將把近來我們的結果做一描述。 
 
關鍵詞：無線感測網路, 感測平台, 安全性, 低功耗設計 
 
 
Abstract 
In recent years, many wireless sensor networks have been proposed and deployed for a wide 
variety of researches and applications. The possible wireless sensor network platforms 
include: smart home systems, security surveillance, health care and handicapped assistance, 
environment and habitat monitoring, etc. In this project we have proposed several methods 
to address three important issues: security, architecture for low power sensor node, and 
evaluation method for wireless sensor platforms. We have also provided architecture for the 
sensor node device specifically designed for wireless sensor network applications. In this 
report, we concentrate on the results we have obtained so far in these three aspects.  
 
Keywords: wireless sensor network (WSN), sensor node, security, low power sensor 
node 
 
 
 1
一､前言 
Wireless sensor network is one of the most interesting research areas with a profound effect 
on technological developments. It also has become the topic of intensive research and still 
has lots of space to explore. They say sensor network will have great influence on our living 
in the future.  
 
Recent advances in MEMS and low power and highly integrated digital electronics have led 
to the design and development of micro sensors. In general, those sensors are equipped with 
data processing (a microcontroller) and communication capabilities (radio or transceiver). 
The sensing circuitry can then measure ambient conditions related to the environment 
surrounding those sensors and transforms them into electric signals.  One can then process 
those collected signal to reveal the properties of located objects and also events happening 
in the neighborhood of the sensor.  The sensors send collected data to a host usually via 
radio transmitter either directly or indirectly through a data concentration center such as a 
gateway.   
 
二､研究目的 
In recent years, many wireless sensor networks have been proposed and deployed for a wide 
variety of researches and applications. The possible wireless sensor network platforms 
include: smart home systems, security surveillance, health care and the handicapped 
assistance, environment and habitat monitoring, and etc. A few key issues of these sensor 
network platforms are security, power consumption, and quantitative evaluation. But most 
current deployments rely on commercially available wireless sensor network devices (e.g., 
Mica2). They are typically built using general-purpose-designed commodity chips and 
suffer several inefficiencies. In this project we have proposed several methods to address 
those issues. We have also provided architecture for the sensor node device specifically 
designed for wireless sensor network applications. In this report, we concentrate on the 
results we have obtained so far in these three aspects. In the first part of this project, we 
concentrated on the security. In the second part of the project, we concentrated on the design 
of a low power node. In the last part of this research we concentrated on the evaluation 
method. The details will be described in the following sections.  
 
 3
transformations, they are defined as the standard AES algorithm. The cipher is reduced to 7 
rounds. Key generation process is the same as in AES. Our objection is to do one more 
MixColumns transformation within the last round. Although this change doesn’t gain more 
security, it does save spaces if we use SubMix instead. The SubMix transformation is 
implemented by three look-up tables (in hardware) instead of computing polynomial 
multiplications for efficiency concern.     
 
We move computational costs from encryption onto decryption, because data broadcasted 
through radio might be easily corrupted and retransmission occurs very often. Besides, 
every message needs a message authentication code (called MAC) also computed by 
encryption algorithm to prevent fabricated data. One can see sensors usually do more 
encryption than decryption.     
 
AES was designed to stand against both linear and differential attacks. Linear attack was 
introduced by Mitsuru Matsui. The main purpose of linear attack is to find the relationship 
between input and output. Although the probability is quite low, suppose the attacker is 
allowed to choose plaintext and ciphertext adaptively (known as adaptive chosen ciphertext 
attack), with sufficient pairs, he is able to recover some parts of a round key and perhaps the 
whole secret key by exhaustive search. Differential attacks to DES-like ciphers suggested by 
E.Biham & A. Shamir extended from fault attacks analyses the effect of differences in 
plaintext pairs on differences in ciphertext pairs. The probabilities discovered will help an 
attacker to extract the most probable key as long as there are sufficient chosen plaintext 
pairs. The standard way is to trace a path of high probable differences through the various 
stages of encryption.      
 
To cut down computational cost, we attempt to abbreviate the number of rounds. However, 
this will also reduce the complexity to break the cipher. In this study, we show that the 
coefficients of SubMix transformation we chose not only reduce number of tables required, 
but also have high diffusion property. Linear and differential attacks against MEAS are 
infeasible in WSN environment. By calculating their probabilities we find out the required 
plaintext and ciphertext pairs are far more than a sensor node can possibly send within 
rekeying period.      
 
We have also implemented our modified AES algorithm in hardware. Due to the limited 
 5
V Power gating: By partitioning the circuit into several domains operating at different 
supply voltages, both static and dynamic power savings are possible. But the 
adjustment of voltage and clock frequency requires long latency, and consumes large 
space.   
V SLEEP mode: This method has a notable latency considering the huge capacitance on 
the power supply node in a unit. 
V Clock gating: It’s simple to implement and requires a latency of only several cycles 
   
In our design, we use the clock gating technique to accomplish our design. The 
microcontroller (MCU) which suits to WSN must be a small and low power one. Here we 
choose microchip PIC16C57 MCU architecture to be the kernel and add our automatic 
power management circuit on it.   
 
We modify the microchip PIC16C57 microcontroller and add our automatic power 
management mechanism on it. We think that the power management should be flexible to 
meet different requirements. Therefore, we provide a serious of instructions for users to set 
the corresponding power management hardware.  
 
First, the customers can activate or deactivate the automatic power management mechanism 
according to their requirements through the instructions (DYN_EN and DYN_CLOSE; 
those two instructions will set or clear bit <4> in status register) (please refer to Appendix B 
for details for discussion in this and the following sections). If the power management 
mechanism is activated, the MCU will go through different states to save power (the last 
state is Sleep state) automatically. Each state has its operating frequency (defined by users 
using the instructions we provided). We provide a clock generator to supply eight different 
clock frequencies (4MHz, 2MHz, 1MHz, 500KHz, 250KHz, 125KHz, 61.25KHz and 
30.625KHz, respectively), the operating frequency of each power state can be chosen 
among them. The control signals when the automatic power management mechanism is 
activated are ‘busy(B)’, ‘powerlow(P)’ and ‘interrupt(I)’. These three signals will affect the 
transition of power management finite state machine and they are explained in Appendix B. 
Otherwise, if the users choose not to use the automatic power management, they still can 
force the MCU to enter a lower power state by using the instructions we provided. Those 
instructions will affect the stored value in Option register. Since the Option register is the 
input select signal of the clock generator, the operating frequency will be changed once the 
 7
Wireless sensing systems have enabled new data collection methods that lead to 
advances in science, engineering, medicine, and many other fields. They have  
motivated a wide range of research work from ad hoc sensor networks at the high  
level to novel sensing devices at the low level.  Although systems that perform 
these tasks are already available commercially, such system design remains a 
difficult challenge.  Many constraints including energy availability, physical form 
factor, timing precision, and sensor data quality must be dramatically improved 
beforethese wireless sensor networks can realize their full potentials. Unfortunately, 
it is difficult to measure progress in these systems due to the lack of commonly 
accepted metrics and benchmark suites.  Even if such metrics and benchmark suites 
were available, it would still be a challenge to actually run these benchmarks, 
because environmental conditions that comprise the input to the sensing systems 
may be difficult to reproduce.  
     
As a result, the field of wireless sensor networks remains largely an academic  
exercise. It is not so much because ``killer applications'' do not exist, but quite the  
contrary, application experts demand solutions that are promised but cannot be  
delivered by today's off-the-shelf solutions. These requirements range from wireless  
transmission distance, reliable communication, high data rate, low jitter, high 
linearity, high sensitivity, high specificity, small form factors, to name a few. Many 
anecdotes indicate that application experts end up building their own specialized 
system instead of taking advantage of off-the-shelf solutions. While this approach 
solves their problems, such systems tend to expensive due to the low volume and 
incur redundant effort in firmware and host software programming.  Moreover, the 
overspecialization severely limits the domain of application.  
     
We believe that in order for wireless sensor networks to become a commercially 
successful field, the sensor platforms must be evaluated by quantifiable metrics. 
General purpose computers have been able to make tremendous real, measurable 
progress with benchmarks such as SPEC, but the counterpart for sensing systems 
does not exist. Even though some sensor benchmarks have been proposed, they do 
not quite evaluate the systems in ways that matter to application experts. It is thus 
the goal of this study to first identify the properties that matter to real-world 
applications and map them to system performance metrics. Then we propose a 
 9
duration of the entering time of each state, if they want to reduce the states of the power 
management finite state machine to meet their requirements. For instance, if a user wants to 
cancel the ALMOST SLEEP state, hoping that the IDLE state can directly enter the SLEEP 
state, what the user needs to do is to set the Period A to S zero, or set the frequency of 
ALMOST SLEEP state as the same as the IDLE state. Through these approaches, users can 
reduce the state of the finite state machine in power management without modifying  
hardware.  
 
In the research of methodology for quantitative evaluation of wireless sensor platforms, we 
have shown a new methodology for the quantitative evaluation of wireless sensor 
platforms for real-world applications. Many such applications cannot compromise 
the quality of data that they collect from the sensors, but unfortunately today’s 
off-the-shelf solutions often treat these sensing aspects as afterthoughts, but instead 
they emphasize the wireless and ad hoc network capabilities. Because application 
requirements are diverse, it is impossible to define a single metric or set of metrics 
that will be relevant to all applications, but the principles of quantitative evaluation 
is still essential in order to measure progress. Our solution is to identify these 
metrics that are of interest to sensing and map them to system-level metrics, so that 
they can be evaluated and composed as black boxes. By composing these metrics in 
the form of a fitness function, we can now generate different fitness scores for 
different applications of a given platform. We believe this methodology represents 
the first step towards a systematic evaluation of candidate solutions for application 
experts so that they can select the right solution for their application without having 
to spend much wasted effort only to find out that the platform cannot deliver the 
solution they need. 
 
七､參考文獻 
[1] F. Akyildiz, W. Su, Y. Sankarasubramaniam,E Cyirci. “Wireless Sensor 
Networks : A Survey”, Computer Networks, 38(4) : 293-422, 2002 
[2] D. Estrin, R. Govindan, J. Heidemann, S. Kumar, “Next century challenges: 
scalable coordination in sensor networks”, ACM MobiCom’99, Washingtion, 
USA, 1999, pp. 263–270. 
[3] MICA, MICA2 Motes & Sensors, Crossbow Technology, 
http://www.xbow.com 
 11
Y.L. Yin，http://theory.lcs.mit.edu/~rivest/rc6.pdf。 
[17] STATUS REPORT ON THE FIRST ROUND OF THE DEVELOPMENT OF 
THEADVANCED ENCRYPTION STANDARD，James Nechvatal、Elaine 
Barker, Donna Dodson, Morris Dworkin, James Foti, Edward Roback。
http://csrc.nist.gov/CryptoToolkit/aes/round1/r1report.htm 
[18] Federal Information Processing Standards Publication 197 Announcing the 
ADVANCED ENCRYPTION STANDARD (AES) 。
http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf 
[19] Denial of Service in Sensor Networks，Wood, A.D.; Stankovic, J.A.; 
Computer , Volume: 35 Issue: 10 , Oct. 2002 Page(s): 54 -62。 
[20] Random key predistribution schemes for sensor networks Haowen Chan; Perrig, 
A.; Song, D.; Security and Privacy, 2003. Proceedings. 2003 Symposium on , 
May 11-14, 2003 Page(s): 197 -213 
[21] Secure routing in wireless sensor networks: attacks and countermeasures 
Karlof, C.; Wagner, D.; Sensor Network Protocols and Applications, 2003. 
Proceedings of the First IEEE. 2003 IEEE International Workshop on , 11 May 
2003 Page(s): 113 -127 
[22] I.A. Essa, Ubiquitous sensing for smart and aware environments, IEEE 
Personal Communications (October 2000) 47–49. 
[23] J. Agre, L. Clare, An integrated architecture for cooperative sensing networks, 
IEEE Computer Magazine (May 2000) 106–108. 
[24] P. Bauer, M. Sichitiu, R. Istepanian, K. Premaratne, The mobile patient: 
wireless distributed sensor networks for patient monitoring and care, 
Proceedings 2000 IEEE EMBS International Conference on Information 
Technology Applications in Biomedicine, 2000, pp. 17–21. 
[25] B.G. Celler et al., An instrumentation system for the remote monitoring of 
changes in functional health status of the elderly, International Conference 
IEEE-EMBS, New York, 1994, pp. 908–909. 
[26] A. Cerpa, J. Elson, M. Hamilton, J. Zhao, Habitat monitoring: application 
driver for wireless communications technology, ACM SIGCOMM’2000, Costa 
Rica, April 2001 
[27] D. Estrin, R. Govindan, J. Heidemann, S. Kumar, Next century challenges: 
scalable coordination in sensor networks, ACM MobiCom’99, Washingtion, 
USA, 1999, pp. 263–270. 
[28] J.M. Kahn, R.H. Katz, K.S.J. Pister, Next century challenges: mobile 
networking for smart dust, Proceedings of the ACM MobiCom’99, Washington, 
USA, 1999, pp. 271–278. 
[29] E.M. Petriu, N.D. Georganas, D.C. Petriu, D. Makrakis, V.Z. Groza, 
 13
distributed microsensor networks, Proceedings of ACM MobiCom’95, August 
1995. 
[43] E. Shih, S. Cho, N. Ickes, R. Min, A. Sinha, A. Wang, A. Chandrakasan, 
Physical layer driven protocol and algorithm design for energy-efficient 
wireless sensor networks, Proceedings of ACM MobiCom’01, Rome, Italy, 
July 2001, pp. 272–286. 
[44] A. Perrig, R. Szewczyk, V. Wen, D. Culler, J.D. Tygar, SPINS: security 
protocols for sensor networks, Proceedings of ACM MobiCom’01, Rome, Italy, 
2001, pp. 189–199. 
[45] B. Warneke, B. Liebowitz, K.S.J. Pister, Smart dust:communicating with a 
cubic-millimeter computer, IEEE Computer (January 2001) 2–9. 
[46] Konstantinos Sarrigeorgidis, Jan M. Rabaey, Massively Parallel Wireless 
Reconfigurable Processor Architecture and Programming, 10th Reconfigurable 
Architectures Workshop RAW 2003,  April 22, 2003, Nice, France 
[47] See http://www.tensilica.com for more information 
[48] See http://eyes.eu.org/ for more information 
[49] Clinton Kelly IV, Virantha Ekanayake, and Rajit Manohar. SNAP: A Sensor 
Network Asynchronous Processor. Proceedings of the Ninth International 
Symposium on Asynchronous Circuits and Systems, Vancouver, BC, May 2003.  
[50] John Teifel and Rajit Manohar. Programmable Asynchronous Pipeline Arrays. 
Proceedings of the 13th International Conference on Field Programmable 
Logic and Applications, Lisbon, Portugal, September 2003. 
[51] John Teifel, David Fang, David Biermann, Clinton Kelly, IV, and Rajit 
Manohar. Energy-Efficient Pipelines. Proceedings of the Eighth International 
Symposium on Asynchronous Circuits and Systems, Manchester, UK, March 
2002 
 
八､附錄 
 
2 
[12][13] developed by Joan Daemen and Vincent 
Rijnment was selected by NIST as new encryption 
standard in October, 2000 [15][18]. AES is iterated 
with Boolean transformation applied to the plaintext 
block called state. Recently, various hardware 
implementations of AES showed good performance 
and suitable for wireless applications. 
2.1 AES polynomial multiplication 
Polynomial multiplication in AES corresponds 
with multiplications of polynomials modulo an 
irreducible polynomial of degree 8. By default setting, 
this irreducible polynomial is m(x) = x8 + x4 + x3 + x 
+ 1. For example, {57} • {83} = {C1}, where ‘•’ 
denotes polynomial multiplication in GF(28).  
First we have binary representation of {57} as 
{01010111}2, which stands for (x6 + x4 + x2 + x + 1). 
Polynomial multiplication is computed by 
 
(1)      1)  x   x  x (x modulo 1)   x (x
 1  x   x  x  x  x  x  x  x  x
 1)  x  (x 1)  x   x  x (x
34867
3456891113
7246
++++++=
+++++++++=
++++++
 
 
One can easily verify that {57} • {01} = {57} where 
{01} is the identity. If given two polynomials and 
their multiplications over an irreducible polynomial 
equals to the identity element, for example {DE} • 
{90} = {01}, they are inverses of each other. 
 
2.2 AES equivalent round 
Each round of AES has an equivalent format 
which output exactly same ciphertext; that is, we can 
change the order of SubBytes and ShiftRows. The 
standard AES round is as follow: 
 
AES-round ( ) { 
 SubBytes (state); 
 ShiftRows (state); 
 MixColumns (state); 
 AddRoundKey (state, RoundKey); 
} 
SubBytes transformation operates on each byte of 
current state, and ShiftRows only change their 
positions among rows. We can rearrange their order 
and have equivalent round as follow:  
 
Equivalent-round ( ) { 
 ShiftRows (state); 
 SubBytes (state); 
 MixColumns (state); 
 AddRoundKey (state, RoundKey); 
} 
 
Then, we merge SubBytes and MixColumns into a 
new transformation called SubMix. Thus, encryption 
requires only three stages. 
 
MAES-round ( ) { 
 ShiftRows (state); 
 SubMix (state); 
 AddRoundKey (state, RoundKey); 
} 
 
2.3 MixColumns transformation 
MixColumns substitutes and permutes data at 
the same time to achieve high diffusion property. 
During MixColumns transformation, columns are 
considered as polynomials over GF(28) and 
multiplied with a fixed polynomial a(x) under x4+1, 
given by  
 
(2)  {02}.{01}x{01}x{03}x  a(x) 23 +++=  
 
Let S0,c denotes the first byte of column c, S’0,c 
after MixColumns and S2,c ~ S3,c respectively. Each 
column then multiplies the rotations of a(x). This can 
be written as a matrix multiplication. 
 
)3(
02010103
03020101
01030201
01010302
,3
,2
,1
,0
'
,3
'
,2
'
,1
'
,0
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
=
⎥⎥
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢⎢
⎢
⎣
⎡
c
c
c
c
c
c
c
c
S
S
S
S
S
S
S
S
 
 
In standard AES, coefficients of MixColumns 
are very simple, but more complicated of 
InvMixColumns, because AES was designed to be 
also efficient in software. The xtime operation means 
to multiply a polynomial x modulo m(x), and can be 
implemented with a shifter and bit-wised XOR. It is a 
very efficient way to compute polynomial 
multiplications when there are more zeros in binary 
representation of the operand, since we only need to 
shift left iteratively. Obviously, computational cost of 
{37} is much greater than that of {03} using xtime 
computations. 
 
)4(}01{}01{
}03{}02{
,3,2
,1,0
'
,0
•⊕•⊕
•⊕•=
cc
ccc
SS
SSS  
 
If we take a closer look, the portion of S3, c • {01} = 
S3, c doesn’t contributes effort in mixing data if S0, c, 
S1, c, and S2, c are fixed to zeros, then output of this 
stage is exactly same to the input. 
 
In contrast, MAES is designed for hardware 
where table look-up is the fastest way, and computing 
{37} and {03} are the same. Hence, we are allowed 
4 
and substitutes them with different values by table 
loop-up. The outputs of previous stage are XORed to 
obtain the final value. This can be written as a matrix 
multiplication like equation (3).  
 
)7(
)SubBytes(
)SubBytes(
)SubBytes(
)SubBytes(
17175D37
3717175D
5D371717
175D3717
,3
,2
,1
,0
'
,3
'
,2
'
,1
'
,0
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
=
⎥⎥
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢⎢
⎢
⎣
⎡
c
c
c
c
c
c
c
c
S
S
S
S
S
S
S
S
 
 
According to the Design of Rijndael [13], SubBytes 
and MixColumns have the following property: 
 
(8)                              b(x))  (x)SubBytes(a 
 b(x) ) (x)SubBytes(a
•=
•
 
 
For example, if input s(x) = {01} + {02}x + {03}x2 + 
{04}x3, the value of S0, c after SubMix is computed by 
 
{C2} = {5C} ♁ {E7} ♁ {6E} ♁ {17} =
17)SubByte(04 ♁ 5D)SubByte(03 ♁
37)SubByte(02 ♁ 17)SubByte(01 =
{17} )SubByte(04♁{5D})SubByte(03♁
{37} )SubByte(02♁{17} )SubByte(01 =
) {04} , {03} , {02} , {01} SubMix( = 'S c 0,
••
••
••
••
 
 
Figure 3 Illustration of the SubMix transformation. 
 
SubByte(a(x) ‧ b(x)) can be realized in two 
different ways; one by look-up table, which is faster 
but requires large space, while the other way is 
bit-wised mapping that can be implemented by XOR 
gates [21], smaller but slower. To handle the tradeoff, 
we attempt to use look-up tables for SubMix. 
 
First, if implemented with look-up tables, each 
table requires 256 bytes in size (same as Sbox in 
AES), and we need both 3*256 bytes for encryption 
and decryption. Compare to AES, which needs one 
table for SubBytes, 3*256 bytes for MixColumns and 
4*256 bytes for InvMixColumns. Our result saves 
512 bytes space in total. Table 1 shows a comparison 
of sizes using look-up table implementations. 
 
Table 1 Comparison of AES and MAES 
 AES MAES 
SubBytes 1 table 0 table 
MixColumns 3 tables 3 tables 
InvSubBytes 1 table 0 table 
InvMixColumns 4 tables 3 tables 
 
Secondly, if implemented with look-up tables, 
the following are bit-wised mapping equations to 
compute multiplication of {DE} with input a(x) = a0 
+ a1x + a2x2 + a3x3 + a4x4 + a5x5 + a6x6 + a7x7 to output 
a(x)’: 
 
)9('
'
'
'
'
'
'
'
53107
74206
6315
5204
754303
76542102
76543101
64210
 a  a  a aa
  a  a  a aa
  a  a aa
  a  a aa
  a  a  a  a aa
 a  a  a  a  a  a aa
  a  a  a  a  a  a aa
 a  a  a aa
⊕⊕⊕=
⊕⊕⊕=
⊕⊕=
⊕⊕=
⊕⊕⊕⊕=
⊕⊕⊕⊕⊕⊕=
⊕⊕⊕⊕⊕⊕=
⊕⊕⊕=
 
 
3.3 Decryption 
 
As for decryption, its round is slightly different, 
because we perform an extra MixColumns at the end 
of encryption. There needs an InvMixColumns right 
after the first step of decryption --- AddRoundKey to 
stay equivalence. The rest parts of decryption are 
exactly same to the standard AES. It is described in 
pseudo code in Fig 10. 
 
Nr = 7 
Begin 
    state = input 
   AddRoundKey(RoundKey[Last]) 
   InvMixColumns(state) 
   For round=Nr-1 step -1 downto 1 
      InvShiftRows (state) 
      InvSubBytes(state) 
   AddRoundKey (state, RoundKey[round]) 
       InvMixColumns(state) 
    End for 
 
    InvShiftRows(state) 
    InvSubBytes(state) 
    AddRoundKey(state, RoundKey[First]); 
    output = state 
End 
Figure 4 Pseudo code for the inverse cipher 
 
4. Security Analysis 
AES was designed to stand against both linear 
and differential attacks. Linear attack was introduced 
by Mitsuru Matsui [17]. The main purpose of linear 
6 
value of difference. The fault propagates from one 
byte to a column after MixColumns. After ShiftRows, 
the fault is shifted to different columns, and will be 
distributed to the whole state after next MixColumns. 
SubBytesafter
00'ε0
0'ε00
'ε000
000'ε
ShiftRowsafterMixColumnsafter
00ε370
0ε5D00
ε17000
000ε17
000ε37
000ε5D
000ε17
000ε17
SubBytesafterShiftRowsafter
0000
0000
0000
000ε
0000
0000
0000
000ε
3
2
1
0
0
0
0
0
0
0
0
0
0
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
→
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
⋅
⋅
⋅
⋅
→
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
⋅
⋅
⋅
⋅
→
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
→
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
 
To estimate our success rate, first we construct a 
differential distribution table of AES’s Sbox like in 
[11] and find out some probable faults are likely to 
happen more than others. For Example, let ε = {1F}, 
then we have ε0 = SubBytes(ε) = {A3}. After 
MixColumns transformation, difference propagation 
of the first column are {5D}, {A3}, {A3}, and {FE} 
with a probability less than 0.006169%. In the last 
round, we check the differential table again to obtain 
the last probability, which is about 0.003060%. 
Hence, number of pairs to mount a successful 
differential attack (to obtain the last round key) will 
be 5.29*108 pairs. 
 
As for MAES, let ε = {67}, then we have ε0 = 
SubBytes(ε) = {E6}. After MixColumns 
transformation, difference propagation of the first 
column are {66}, {66}, {65}, and {B9} with a 
probability less than 0.006168% and 0.003064% in 
the last round. Our proposed SubMix transformation 
turns out to be as strong as standard AES.  
 
5. Implementation 
 
Due to the limited resources including power 
supply and area on wireless sensor network nodes, 
we will introduce some techniques we use in the 
design of MAES to achieve the goals of reduced 
power and low gate count in this section. 
 
After the analysis of overall AES and modified 
AES, inclusive of encryption, decryption, and key 
expansion, some portions of these three algorithms 
should be focused to implement an efficient design 
with lower power consumption and lower gate count.  
 
Firstly, as to the key expansion part, two 
methods including pre-computation method and 
on-the-fly key schedule method [6] are usually used 
to generate round keys. On-the-fly key schedule first 
generates the expanded keys from the Cipher key and 
then decides the round key of each round. Each round 
key is used when it is generated, so it is not necessary 
to use storage elements to store keys as what 
pre-computation method does. Under the concern of 
area and power, on-the-fly key schedule is adopted. 
 
Secondly, the most critical part and 
power-hungry part of AES and MAES are (1) 
SubBytes in key expansion and encryption round 
functions, and (2) InvSubBytes in decryption round 
functions [26] [2]. We use Galois field arithmetic [16] 
to complete the operations under the consideration of 
timing and area. 
 
5.1 Area Reduction Techniques 
There are many methods that can be used to 
implement Sbox. The better way is using the Galois 
field arithmetic [16] [9] under the consideration of 
performance and area. One operation of SubBytes is 
calculating the multiplicative inverse over GF(28). 
However, it is quite complex to compute directly, 
therefore we first transform it from GF(28) to 
GF((24)2) and then we can use inverter in GF((24)2). 
Since the polynomial x8 + x4 + x3 + x + 1 ({11B} in 
hexadecimal form) used in AES and MAES is not a 
primitive irreducible polynomial, we had better use 
isomorphism before and after the implementation of 
GF((24)2) inverter. In GF((24)2), the primitive 
irreducible polynomial x8 + x4 + x3 + x2 + 1 ({11D} in 
hexadecimal form) is a better basis. The isomorphism 
function from GF(28) to GF((24)2) is B as shown in 
Equation 12 [16] [25] and the isomorphism function 
from GF((24)2) to GF(28) is B-1 as shown in Equation 
13 [16] [25]. 
 
)12(
10001110
01100000
01000001
00101000
00001110
01001011
00110101
00000101
'
'
'
'
'
'
'
'
0
1
2
3
4
5
6
7
0
1
2
3
4
5
6
7
⎥⎥
⎥⎥
⎥⎥
⎥⎥
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢⎢
⎢⎢
⎢⎢
⎢⎢
⎢
⎣
⎡
⎥⎥
⎥⎥
⎥⎥
⎥⎥
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢⎢
⎢⎢
⎢⎢
⎢⎢
⎢
⎣
⎡
=
⎥⎥
⎥⎥
⎥⎥
⎥⎥
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢⎢
⎢⎢
⎢⎢
⎢⎢
⎢
⎣
⎡
b
b
b
b
b
b
b
b
b
b
b
b
b
b
b
b
 
8 
gate transfers signal transitions from input to output 
with probability 100%. For AND, OR gates, the 
probability is 50%. Therefore, it is a good way to 
place AND or OR gates before XOR gates to reduce 
the probabilities of signal transition, as illustrated in 
Figure 13. 
 
(1)XOR gate 
 
(2)AND gate 
 
(3)OR gate 
 
Figure 12 Propagation probabilities of signal 
transitions 
 
As shown in Figure 14, composite field Sbox 
and Inverse Sbox are divided into three blocks to 
reduce the probabilities of signal transitions [2]. In 
addition, the two-level logic, i.e. AND-XOR arrays 
are used to reduce the number of dynamic hazards. 
 
In conclusion, we use the following approaches 
to achieve power reduced Sbox and Inverse Sbox: (1) 
Use composite field Sbox to reduce gate count, (2) 
Divide combinational logic into three stages to 
reduce the probabilities of signal transitions, and (3) 
Adjust the signal timing by using two-level 
(AND-XOR) logic to reduce the number of dynamic 
hazards. 
 
 
Figure 13.1  Two-level AND-XOR logic 
 
Figure 13.2  Two-level OR-XOR logic 
 
 
Figure 14 3-stage AND-XOR architecture used for 
composite field S-box 
 
Figure 15 shows the key scheduler we use in our 
MAES design [26] [14]. When the encryption routine 
is processed, EN/ DE = 1 and Init_K0 through 
Init_K3 are the Cipher key. In the beginning, Init_K0 
through Init_K3 are put into K0 through K3, 
respectively. After one clock cycle, 
)]otWord(K3)[SubWord(RRcon[0]K00K ⊕⊕=
K’1=K’0⊕ K1, K’2=K’1⊕ K2, K’3=K’2⊕ K3 and 
the generated K’0 through K’3 become the new K0 
through K3. After another 6 clock cycles, all round 
keys are generated and the final round key are stored 
in registers. Similarly, when the decryption routine is 
processed, EN/DE = 0 and Init_K0 through Init_K3 
are the final key stored in registers. At first, Init_K0 
through Init_K3 are put into K0 through K3, 
respectively. After one clock cycle, K’3=K2⊕ K3, 
K’1=K0⊕ K1, K’2=K1⊕ K2,  
))]otWord(K'3[SubWord(RRcon[0]K00K' ⊕⊕=
, and the generated K’0 through K’3 become the new 
K0 through K3. After another 6 clock cycles, all 
round keys are generated. 
10 
References 
[1] A. Satoh, S. Morioka, K. Takano, and S. 
Munetoh, “Unified hardware architecture 
for128-bit block ciphers AES and Camellia”, in 
Cryptographic Hardware and Embedded 
Systems (CHES) 2003. Aug. 2003, 
Springer-Verlag. 
[2] A. Hodjat, I. Verbauwhede, “Minimum Area 
Cost for a 30 to 70 Gbits/s AES Processor”, 
IEEE computer Society Annual Symposium on 
VLSI,. pp. 83-88, Feb. 2004. 
[3] Boneh, DeMillo, and Lipton, On the 
Importance of Checking Cryptographic 
Protocols for Faults, Lecture Notes in 
Computer Science, Advances in Cryptology, 
proceedings of EUROCRYPT’97, pp. 37-51, 
1997. 
[4] B. Schneier, et. al. The Twofish Encryption 
Algorithm: A 128-Bit Block Cipher. John Wiley 
& Sons, April 1999. 
[5] B. Schneier, "Blowfish" ,Fast Software 
Encryption, Cambridge Security Workshop 
Proceedings (December 1993), Springer-Verlag, 
1994, pp. 191-204. 
[6] C.-L. Horng, “An AES Cipher Chip Design 
Using On-the-Fly Key Scheduler”, Master 
Thesis, Dept. Electrical Engineering, National 
Tsing Hua University, Hsinchu, Taiwan, June 
2004. 
[7] D. Wheeler and R. Needham. Tea, a tiny 
encryption algorithm. 
http://www.ftp.cl.cam.ac.uk/ftp/papers/djw-rmn
/djw-rmn-tea.html , November 1994. 
[8] D.W. Carman. Constraints and approaches for 
distributed sensor network security. Technical 
Report, #00-010, NAI Labs, 2000. 
[9] E. D. Mastrovito, “VLSI Architecture for 
Computations in Galois Fields”, Ph.D. Thesis, 
Dept of EE, Linköping Univ., Lingköping, 
Sweden 1991. 
[10] E. Trichina, “Combinational logic design for 
AES SubByte transformation on masked data”, 
IACR report, 2003. Available at 
http://eprint.iacr.org/2003/236.pdf. 
[11] E. Biham, A. Shamir. Differential Cryptanalysis 
of DES-like Cryptosystems. Journal of 
Cryptology, Vol. 4 No. 1 1991. 
[12] J. Daemen, L. Knudsen, and V. Rijmen. The 
Block Cipher Square. In E. Biham, editor, Fast 
Software Encryption ’97, volume 1267 of 
Lecture Notes in Computer Science, pages 
149–165, Haifa, Israel, January 1997. 
Springer-Verlag. 
[13] J. Daemen and V. Rijmen. AES proposal: 
Rijndael. 
http://csrc.nist.gov/encryption/aes/rijndael/Rijn
dael.pdf, 1999 
[14] J. H. Shim, D. W. Kim, Y. K. Kang, T. W. 
Kwon, and J. R. Choi, “A rijndael 
cryptoprocessor using shared on-the-fly key 
scheduler”, in Proc. 3rd IEEE Asia-Pacific 
Conf. ASIC, Taipei, Aug. 2002, pp. 89–92. 
[15] J. Nechvatal, et. al., Report on the 
Development of the Advanced Encryption 
Standard(AES), National Institute of Standards 
and Technology, October 2,2000. 
[16] J. Wolkerstorfer, E. Oswald, and M. Lamberger, 
“An ASIC Implementation of the AES SBoxes 
“, CT-RSA 2002, LNCS 2271, pp. 67-78,2002. 
[17] M. Matusi, "Linear Cryptanalysis Method for 
DES Cipher." In T. Helleseth, editor, Advances 
in Cryptology - EUROCRYPT'93, Volume765 
of Lecture Notes in Computer Science, 
pp.386-397. Springer-Verlag, Berlin, 
Heidelberg, NewYork, 1994. 
[18] National Institute of Standards and Technology 
(NIST), Advanced Encryption Standard (AES), 
National Technical Information Service, 
Springfield, VA 22161, Nov. 2001. 
[19] National Bureau of Standards, NBS FIPS PUB 
46, “Data Encryption Standard," National 
Bureau of Standards, U.S. Department of 
Commerce, Jan 1977. 
[20] P. Dusart, G. Letourneux, O. Vivolo, 
Differential Fault Analysis on AES, available at: 
http://www.unilim.fr/laco/rapports/2003/R2003
_01.pdf, 2003 
[21] P. Noo-intara, S. Chantarawong, and S. 
Choomchuay, "Architectures for MixColumn 
Transform for the AES," Proc. of  Information 
and Computer Engineering Workshop 2004 
(ICEP2004), Prince of Songkla University 
(Phuket Campus), January 2004, pp.152-156. 
[22] RSA Laboratories. PKCS #1: RSA encryption 
standard, Version 1.5, November 1993. 
[23] R. L. Rivest. The RC5 Encryption Algortihm, 
Proceedings of Fast Software Encryption 
Workshop 1994, pp. 86-96.  
12 
Appendix I 
 
Table 3 SubMix table of {17} 
58 ee 6f 8b 51 e0 bc 89 bd 17 04 57 b5 cc 22 78
54 5b 6d f9 e9 73 d2 7f 50 f5 8d 7e fa ff 24 c2
ad 8c 27 a4 cf 60 1a 26 e1 e8 5f 68 1d 11 aa 20
5c a7 ef fb d3 6c 4b 88 65 45 75 3a 95 b3 e6 41
af 4c 32 fd ea ab 4a a3 f2 3c db f1 79 2d 0b 29
e5 be 00 e7 d6 9b df 5d f7 43 02 12 21 53 64 1f
a9 c9 35 fe 8e 44 84 3e fc d0 2e d7 dc 59 c3 1b
cb 9a b7 a8 30 ed 05 34 2c ba 3f c1 6b a2 46 87
31 e4 52 f0 01 7b eb 0e 9e c6 c0 4e 3d 2f c4 33
61 62 6a 4d f8 40 1e cd c5 de 70 37 63 16 81 28
14 93 2b 96 18 72 8a 38 ec 90 47 4f 09 55 48 a5
71 7a d8 92 86 e2 7d 0c 85 ae 23 82 2a 9c 69 b8
5e b2 9d 1c 8f d1 94 b0 ac 5a 56 b6 36 3b f4 e3
0a 77 83 13 0f 39 0d ca 76 f6 b9 67 07 d5 98 d4
03 c7 a6 7c ce 06 bf 42 9f a1 10 bb 08 97 6e 74
91 b4 da f3 15 66 99 d9 a0 b1 25 dd c8 80 49 19
 
Table 4 SubMix table of {37} 
8c f7 0d 72 38 2f f3 5a e7 37 50 40 47 69 9e 3a
7c b0 25 c0 9b a6 ea 56 2c 30 0a 42 fc b8 e6 b1
bc 1e da 08 55 c1 d3 ce 3b 8f e0 61 bf 4f d0 b6
dc 34 e3 e8 fe 31 eb 4e 85 33 de 65 f1 3f 57 63
94 87 c5 90 a7 c4 ff 64 5c 1d 5e 60 2e 52 9c 02
6b db 00 43 ba 29 0e c8 18 4b 28 73 a2 10 91 97
ec 2d a9 ac 36 27 be 35 84 c2 6e ae 32 98 a5 c7
05 3d 6f f8 ed cb 44 bd 46 8b 21 8d 5d 70 0f 82
f9 7f 04 74 14 06 b3 d8 6d e1 99 af 09 7a c9 d1
d5 e9 49 93 d4 77 83 7d dd 1a 9a 81 fd 23 fa 16
0b 89 2a cd fb b2 66 4d df b5 1b bb b4 68 d7 1c
8e 12 62 9d 96 07 7e f0 aa 80 8a c6 3e 45 75 a3
f4 2b 51 ab 22 d6 e5 03 a8 a4 54 7b 95 71 24 13
88 f6 d2 67 cc 59 e4 11 e2 0c b7 ad 6c 86 15 92
3c f5 20 6a 41 78 cf 5f 79 4c 5b 9f a0 d9 19 ca
a1 53 4a 48 1f b9 01 76 58 17 f2 26 39 ee c3 ef
 
14 
Appendix II 
Plaintext  bits 74 68 69 73 20 69 73 20 61 20 74 65 73 74 21 21 
Key bits        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
Ciphertext bits 82 8f 0d 72 38 71 26 fc 0e 46 6a 19 9f 07 3e 4b 
==========================================================================================
Round Key  00 00 00 00 
           00 00 00 00 
           00 00 00 00 
           00 00 00 00 
Round 1> 
After ShiftRows  74 20 61 73 
                 69 20 74 68 
                 74 21 69 73 
                 21 73 20 65 
After SubMix      2c 42 1d 71 
                  f6 07 0e ea 
                  ac ec ba 6a 
                  c5 ad 02 8c 
After AddRoundKey  4e 20 7f 13 
                   95 64 6d 89 
                   cf 8f d9 09 
                   a6 ce 61 ef 
Round 2> 
After ShiftRows  4e 20 7f 13 
                 64 6d 89 95 
                 d9 09 cf 8f 
                 ef a6 ce 61 
After SubMix      89 e2 b9 f8 
                  9d f9 24 8e 
                  b1 1d f9 ea 
                  53 62 07 0b 
After AddRoundKey  12 1b 22 01 
                   05 02 bc 75 
                   29 e6 61 11 
                   9a c8 ce a1 
Round 3> 
After ShiftRows  12 1b 22 01 
                 02 bc 75 05 
                 61 11 29 e6 
                 a1 9a c8 ce 
After SubMix      15 c5 68 71 
                  67 87 2b b7 
                  49 a7 a2 92 
                  af a4 9a 7a 
After AddRoundKey  85 ac 9a 7a 
                   f0 eb df b8 
                   7d 68 f5 3e 
                   ff 5e a9 e3 
Round 4> 
After ShiftRows  85 ac 9a 7a 
                 eb df b8 f0 
                 f5 3e 7d 68 
                 e3 ff 5e a9 
After SubMix      fd 85 ff 96 
                  83 f8 56 8f 
                  d7 68 d5 fe 
                  2f a8 12 b3 
After AddRoundKey  13 02 8a e8 
                   85 92 c8 1e 
                   0d 7d 97 10 
                   54 29 a0 98 
Round 5> 
After ShiftRows  13 02 8a e8 
                 92 c8 1e 85 
                 97 10 0d 7d 
                 98 54 29 a0 
After SubMix      e4 90 04 cc 
                  91 ea a5 24 
                  ce 92 34 03 
                  34 e1 5f af 
After AddRoundKey  9b 68 89 3f 
                   bf ae 7f 6f 
                   e5 ac 48 91 
                   bc e8 e4 3f 
Round 6> 
After ShiftRows  9b 68 89 3f 
                 ae 7f 6f bf 
                 48 91 e5 ac 
                 3f bc e8 e4 
After SubMix      16 46 5f 99 
                  49 5f 74 31 
                  11 43 f6 9a 
                  ed 34 bc 7a 
After AddRoundKey  fa 52 c6 f3 
                   28 7a 8b 85 
                   5a 36 ff 01 
                   68 b8 8b dd 
Round 7> 
After ShiftRows  fa 52 c6 f3 
                 7a 8b 85 28 
                 ff 01 5a 36 
                 dd 68 b8 8b 
After SubMix      a3 ba a1 b4 
                  4d 21 89 e7 
                  19 24 01 e9 
                  18 0c 02 d0 
After AddRoundKey  82 8f 0d 72 
                   38 71 26 fc 
                   0e 46 6a 19 
                   9f 07 3e 4b 
Ciphertext 
 2
  In our design, we use the clock gating technique 
[5],[6],[7],[8] to accomplish our design. 
  The microcontroller (MCU) which suits to WSN must 
be a small and low power one. Here we choose 
microchip PIC16C57 MCU [2],[3],[4] architecture to 
be the kernel and add our automatic power 
management circuit on it. 
 
3. Hardware 
 
We modify the microchip PIC16C57 microcontroller 
and add our automatic power management mechanism 
on it. Figure 1 is the architecture overview of the 
modified PIC16C57, the red frames are our new added 
power management logic. . 
 
 
 
busy
idle
asleep
p low
OutputBOutputC OutputA
ROM
Instruction 
register
Instruction decoder
General 
/Special 
purpose
register
W
ALU
status[2:0]
O
ption
<2:0>
   status[4:3]
PC Stack1
Stack2
Clock Generator
Dynamic power 
management
RST CLK
 p save
TMR0
B P I
State Reg.
Figure 1: Architecture overview of modified 
PIC16C57 MCU 
 
We think that the power management should be 
flexible to meet different requirements. Therefore, we 
provide a serious of instructions for users to set the 
corresponding power management hardware, the related 
instruction will be described in the next section. First, the 
customers can activate or deactivate the automatic power 
management mechanism according to their requirements 
through the instructions (DYN_EN and DYN_CLOSE; 
those two instructions will set or clear bit <4> in status 
register). If the power management mechanism is 
activated, the MCU will go through different states to 
save power (the last state is Sleep state) automatically. 
Each state has its operating frequency (defined by users 
using the instructions we provided). We provide a clock 
generator to supply eight different clock frequencies 
(4MHz, 2MHz, 1MHz, 500KHz, 250KHz, 125KHz, 
61.25KHz and 30.625KHz, respectively),the operating 
frequency of each power state can be chosen among 
them. The control signals when the automatic power 
management mechanism is activated are ‘busy(B)’, 
‘powerlow(P)’ and ‘interrupt(I)’. These three signals will 
affect the transition of power management finite state 
machine and they will be explained in section 5. 
Otherwise, if the users choose not to use the automatic 
power management, they still can force the MCU to 
enter a lower power state by using the instructions we 
provided. Those instructions will affect the stored value 
in Option register. Since the Option register is the input 
select signal of the clock generator, the operating 
frequency will be changed once the value stored in 
Option register changed.         
Each power state (the power states are defined in 
section 5) has its corresponding operating frequency 
which can be set by the users through the instructions we 
provided according to different requirements. The users 
only have to set those parameters once at beginning, the 
desired operating frequency related to each power state 
will be saved in the State register (see Figure 1), and then 
the State register will control the operating frequency of 
each state. The MCU will follow the user defined 
frequency state to implement the power management. 
One more thing users have to define by themselves 
though the instructions we provided is the timer (TMR0) 
which controls the duration of sleep time. For example, if 
the user set the timer as 30 minutes, whenever the MCU 
goes into sleep, it will wake up after 30 minutes. Here we 
provide the sleeping duration from 1 minute to 31 hours. 
The sleep duration will be saved in TMR0 register in 
Figure1. 
 
4. Instruction Set 
 
We list the corresponding power management related 
instructions in Table1. The ‘BUSY’, ‘IDLE’, ‘ASLEEP’, 
‘PWRLOW’ and ‘PWRSAVE’ instructions are made for 
automatic dynamic power management. To execute these 
five instructions, the value ‘k’ will be stored in State 
register in corresponding location. ‘DYN_EN’ and 
‘DYN_CLOSE’ can enable or disable automatically 
power management respectively by setting or clearing 
the bit<4> in Status register. Executing the instruction 
‘SLEEP’, bit<3> in the Status register will be set, 
therefore, no clock will be supplied to the MCU. 
‘WDTM’ and ‘WDTH’ mean writting value into TMR0 
register. If the user uses ‘WDTM, k’, the value ‘k’ will be 
interpreted as k minutes, the bit<7> in TMR0 register is 
cleared. If the user uses ‘WDTH, k’, the value ‘k’ will be 
interpreted as k hours, the bit<7> in TMR0 register is set. 
The instructions ‘NORMAL’, ‘FDIV2’, ‘FDIV4’, 
‘FDIV8’, ‘FDIV16’, ‘FDIV32’, ‘FDIV64’ and 
‘FDIV128’ enable users to change the operating freqeucy 
manually by setting the value in Option register when the 
automatic dynamic power management is disabled.  
 
Mnemonic,Oper
ands 
Description 
BUSY k  Set appropriate frequency when 
in busy state 
IDLE  k 
 
Set appropriate frequency 
when in idle state  
 4
instruction ‘ASLEEP’, compared with other states 
(except SLEEP state). The reason why we defined 
it as an ALMOST SLEEP state is that when the 
MCU goes to SLEEP state, it will cause some 
penalty to wake it up, therefore, the MCU runs in a 
relatively slower state for another extra period 
instead of going into sleep state directly.  
 
V POWERLOW: POWERLOW state will be 
activated when the battery power is low. When the 
battery power of one sensor node is low and the 
MCU has just finished its task, it will go into the 
POWERLOW state. The operating frequency of 
this state can be set by the instruction ‘PWRLOW’.  
 
V POWERSAVE: POWERSAVE state is similar to 
BUSY state but battery is low. The performance of 
the MCU in POWERSAVE state maybe isn’t as 
good as that in BUSY state (the operating 
frequency which is user defined maybe not as fast 
as it in BUSY state). It is the trade off between 
battery power and performance. The corresponding 
operating can be defined by instruction 
‘PWRSAVE’.  
 
V SLEEP: SLEEP state is the power down state. In 
this state, no switching power is consumed, and the 
clock is in the gated situation. There are two ways 
to wake up the MCU form sleeping; one is to set 
the timer ‘TMR0’ to calculate the sleep duration. 
Once the time expired, the MCU will return to 
ALMOST SLEEP state from SLEEP state. Another 
is that the peripheral (e.g. sensor or radio) raise the 
interrupt signal, this will force the MCU wakeup 
from SLEEP state to ALMOST SLEEP and if the 
busy signal is also raised it will take one another 
cycle (0.25us) to return to BUSY state.   
 
The operating frequencies of BUSY, IDLE, ALMOST 
SLEEP, POWERLOW and POWERSAVE can be 
defined by users. Let’s explain the situations when the 
automatic dynamic power management is on. When the 
‘busy’ signal is raised by the sensor (or radio etc.) and 
received by the MCU, the MCU will enter the BUSY 
state. After processing all the data, the MCU will go into 
the IDLE state immediately. In IDLE state, the frequency 
slows down (user defined) and the MCU waits for 
another ‘busy’ signal to return to the BUSY state, or 
remains idling for a while (this ‘idle period’ is called 
Period I to A) before entering ALMOST SLEEP state. If 
in this period, the battery is low, the ‘powerlow’ signal 
will be raised and the MCU will enter POWERLOW 
state directly.In the POWERLOW state, if the ‘busy’ 
signal is raised, the MCU will enter the POWERSAVE 
state. After MCU finishes its job, it will return to the 
POWERLOW state from POWERSAVE state. Otherwise, 
it would idle for another period ( Period P to A), and 
enter ALMOST SLEEP state from POWERLOW state. 
It is noted that: 
Period I to A >>Period P to A 
If the sensor node uses the solar power or other 
rechargeable battery, when the battery is charged to a 
certain extent, the MCU will return to IDLE state from 
POWERLOW state. 
After idling for a period in ALMOST SLEEP state, if 
no ‘busy’ signal is raised, the MCU will enter SLEEP 
state. In SLEEP state, the MCU is shut down. That 
means the clock does not tick until the set timer times out 
or there comes an interruption to wake up the MCU. The 
MCU will follow the route in Figure 2 to return to work. 
 
B. Automatic Dynamic Power Management is disabled 
 
The two square graphs in Figure 2 present the finite 
state machine when our automatic dynamic power 
management is turned off (the corresponding instruction 
is ‘DYN_CLOSE’). The MCU will not enter a relative 
lower power state automatically, but the users still can 
instruct the MCU and force it to change its operating 
frequency by instructions ‘NORMAL’, ‘FDIV2’, 
‘FDIV4’, ‘FDIV8’, ‘FDIV16’, ‘FDIV32’, ‘FDIV64’ and 
‘FDIV128’. We define two states below: 
 
V ACTIVE: When a user decides not to activate the 
dynamic power management mechanism, and 
instead wants to control the operating frequency 
manually, we provide two basic states: ACTIVE 
state and SLEEP state, which are turn-on and 
turn-off states. In the ACTIVE state, users still can 
change the operating frequency of the MCU by 
instructions. 
 
V SLEEP: SLEEP state is the power down state. In 
this state, no switching power is consumed, and the 
clock is in the gated situation. There are two ways 
to wake up the MCU form sleeping, the two 
approaches are described in part A.  
 
Now, let’s look at the square figure in Figure 2: 
When the automatic dynamic power management is 
shut down by the users through the instruction 
‘DYN_CLOSE’, the operating frequency of the MCU 
can not change automatically, instead, it sets by the user 
himself. The default value is CLK, which is about 4MHz, 
and the value of frequency the user set will be stored in 
the option register.  
After the user shuts down the MCU through 
instruction ‘SLEEP’, it enters the SLEEP state. It 
remains in this state until the set timer times out or there 
comes an interrupt to wake up the MCU. The MCU will 
enter ACTIVE state once wakened. In ACTIVE state, the 
user can change the operating frequency among eight 
different frequencies to meet their needs or to shut down 
the MCU through instructions.  
 
6. Experimental Result 
 
we use synopsys prime power [9] to evaluate the total 
power. The MCU in Figure 3 idles 99 percent of the 
whole simulation time (no data need to be processed), 
 6
  
Busy state 4MHz 
Idle state 2MHz 
Table 4: Condition of Figure 6   
 
7. Conclusion 
 
From the simulation result, we can come up with a 
conclusion that it’s a good idea to lower the operating 
frequency when a MCU or sensor node is idling as soon 
as possible. And our MCU can automatically switch the 
frequency in operating to save the battery power.    
The users can modify the duration of the entering time 
of each state, if they want to reduce the states of the 
power management finite state machine to meet their 
requirement. For instance, if the user wants to cancel the 
ALMOST SLEEP state, hoping that the IDLE state can 
directly enter the SLEEP state, what the user needs to do 
is to set the Period A to S zero, or set the frequency of 
ALMOST SLEEP state as the same as the IDLE state. 
Through these approaches, the users can reduce the state 
of the finite state machine in power management without 
modifying the hardware.   
 
8. Future Work 
 
The designers can take our MCU as a base, and add 
new instructions to meet the requirements of every 
application. Or they can modify the size of the data path 
to mount the MCU to their WSN system. The designers 
who use our MCU can add or reduce the states of power 
management finite state machine to optimize the MCU to 
meet their requirements. 
In our MCU, we only use the frequency scaling to 
manage the power, but the designers can add voltage 
scaling technique or other approaches to perfect the 
power management mechanism. 
Our MCU also can be viewed as a clock central 
controller which is to generate the clock to feed to the 
peripheral units. If the system demands that each unit 
running on different frequencies, a little hardware should 
be added on it, and additional instructions should be 
added, too.  
    
9. Reference 
 
[1] Yan Luo, Jia Yu, Jun Yang, Laxmi Bhuyan, Low 
Power Network Processor Design Using Clock Gating, 
IEEE/ACM Design Automation Conference (DAC), 
Ahaheim, California, June 13-17, 2005 
[2] Rudolf Usselmann, Mini-risc core, Sep 2004. 
[3]See 
http://www.opencores.org/projects.cgi/web/minirisc for 
more information. 
[4] PIC16C5X EPROM/ROM-based 8-bit CMOS 
microcontroller Series, from http://www.microchip.com. 
[5] Yan Luo, Jia Yu, Jun Yang, Laxmi Bhuyan, Low 
Power Network Processor Design Using Clock Gating, 
IEEE/ACM Design Automation Conference (DAC), 
Ahaheim, California, June 13-17, 2005. 
[6] Jaewon Oh and Massoud Pedram, Gated Clock 
Routing for Low-Power Microprocessor Design,IEEE 
TRANSACTIONS ON COMPUTER-AIDED DESIGN 
OF INTEGRATED CIRCUITS AND SYSTEMS, VOL. 
20, NO. 6, JUNE 2001 715‘, Senior Member, IEEE. 
[7] Zia Khan Gaurav Mehta ,Automatic Clock Gating for 
Power Reduction 
Graphics Component Division Low Power Design 
Technology, Intel Corporation 1900 
[8]Wolfgang Embacher Christian Bosch Martin 
Embacher Frank Trautmann, Advanced Clock Gating 
with Power Compile.  
[9]Synopsys, Prime Power, Download from 
http://www.cic.org.tw 
 
severely limits the domain of application.  
  We believe that in order for wireless sensor networks to become a commercially  
successful field, the sensor platforms must be evaluated by quantifiable metrics.  
General purpose computers have been able to make tremendous real, measurable  
progress with benchmarks such as SPEC, but the counterpart for sensing systems do  
not exist. Even though some sensor benchmarks have been proposed, they do not  
quite evaluate the systems in ways that matter to application experts. It is thus the goal  
of this paper to first identify the properties that matter to real-world applications and  
map them to system performance metrics. Then we propose a methodology for  
actually evaluating these systems. If successful, it will be possible to put a score on  
every sensor platform so that application users can evaluate and compare solutions in  
advance, without spending much effort evaluating a system only to find out that it  
does not meet their requirements. We believe that this is the only way that the whole  
field of wireless sensing systems can make real progress in meaningful ways.  
  This paper first reviews related works and provides a background on various  
metrics, including power efficiency, sensitivity and specificity, timing jitter, data  
accuracy, and communication. We propose ways to quantify such performance aspects  
and compose these scores. We then describe our experimental setup for actual  
quantitative evaluation of two existing wireless sensing platforms. 
 
2. Background and Related Work 
 
  Methods for evaluating different aspects of wireless sensors have been proposed.  
They can be divided into component-level analysis, system-level benchmarking, and  
emulation. 
 
2.1 General Metrics for Sensing 
  General metrics for evaluating sensing devices include sensitivity, specificity or  
selectivity, linearity. 
  Sensitivity refers to the smallest level of signal that can be detected by the sensing  
device.  More specifically, it may need to be qualified by the minimum duration. In  
the case of a periodic signal to be sensed, the temporal sensitivity may be expressed in  
terms of the frequency range. For instance, the sensitivity of an accelerometer would  
be the smallest level of acceleration that can be measured.  Because acceleration is  
often periodic (e.g., vibration), the sensitivity would be in terms of acceleration units  
(g) per electrical unit (mV) and the frequency range (e.g., 10--200Hz). 
  Specificity or selectivity refers to the ability for the sensing device to identify the  
contribution by the subject in the presence of similar signals generated by non-subject  
form of energy they transform, such as thermal, mechanical, optical, chemical,  
electromagnetical, and others. Each of these sensors operate under a distinct principle  
and therefore have different transformation characteristics. For example, an  
impedance-structured sensor with its output current linearly proportional to the 
measured voltage has better linearity than a diode-based sensor with an identical  
non-linear I/V curve. There are several systematic deviations observed in real sensors 
like zero-offset, hysteresis error, and dynamic drift, which might be possible to  
eliminate by calibration. Random noise is another source that gives rise to sensing  
deviation. 
 
2.3 System-Level Metrics 
  Even if components work well individually, after integration to form the WSN  
system, their behavior might be different and more complicated, often due to  
interferences between devices. In fact, inaccuracies in the data can often be attributed  
to the overall system design, rather than just intrinsic errors of sensing device and  
ADC. This is because the system makes a series of data conversions from sensing  
devices and ADC channels to several intermediate stages. For example, the resolution  
and accuracy of an ADC is dependent on its reference voltage. A system without a  
stable supply or reference voltages will cause deviation of the sampled result. Also,  
the relative positions of components sometimes decrease device performance. A  
particular layout of circuits may introduce noises in the form of device coupled  
interference, thermal noises, or other random noises. These effects all have influences  
on the data conversion accuracy, decreasing sensitivity or increasing nonlinearity. 
  Timing precision in a WSN node is the compound effect of many system timing  
factors. For example, the actual sampling period of the WSN node depends on the  
intrinsic clock jitter, wiring delay, software overhead, and dynamic workload, etc. As  
a result, the introduced cycle periods may differ from each other, or the accumulated  
deviation may be much larger than the published values. These variations also impact  
the system’s conversion accuracy, since sampling with inaccurate period leads to  
aperture errors of data. 
  Power is one of the main metrics for many WSN systems. Unfortunately, it also has  
the highest impact on the sensor data quality. Although it is desirable to use 
low-power devices, they often fail to obtain accurate data or achieve timing  
synchronization. Furthermore, the conventional method to lower the overall supply  
voltage also lowers the signal noise margin and reduce the circuit driving capability,  
which in turn decreases the data specificity and linearities of timing precision. 
  The stated sensing quality issues from WSN metric to system level are critical to  
many real-world sensing applications. Unfortunately, few available platforms today  
  This section describes our methodology for evaluation of WSN platforms. We first  
provide detailed definitions for the metrics, and then we describe how to compose  
these metrics together for the system level in terms of fitness metrics. 
3.1 Metrics for Sensing 
  This subsection defined metrics for sensing. They are categorized into conversion  
accuracy and timing precision. 
 
3.1.1 A-to-D Conversion Accuracy 
  The traditional static tests of conversion mechanism in [5, 15] try to locate the  
transition level for each step by repeatedly adjusting the test signal. These methods  
take long test durations and may become imprecise for high resolution ADCs due to  
non-negligible noise influences. The histogram test, also called code density test, is a  
dynamic approach to verifying the nonlinearities. It addresses the above problem and  
dramatically reduces the test duration. In the approach, a regular signal such as a  
triangular [1, 14] or sine-wave [2, 17] is applied to the ADC input. With sufficient  
samples taken, the corresponding digital output forms a code bin distribution. Since  
the test signal has an expected probability density function, the transition level can be  
estimated by comparing the measured and the theoretical distribution. 
  In our experiment, we use a triangular waveform as the test signal, since it has a  
simple form of probability distribution. In [2], several suggested parameter settings  
for the test signal overdrive and the number of records is proposed in order to increase  
the precision of the measurement. The transfer function can be determined from the  
following way: 
• Apply the test signal to the analog input of the platform. 
• Collect the overall S samples of output code digitized by the N-bit ADC. 
• For each code k, calculate the total occurrence nk of k. 
• Theoretically, the nk of each code bin should be uniformly distributed, thus the  
actual transfer level T(k) for k can be obtained by: 
(1)          )(
0
∑
=
⋅=
k
i
i
ref
S
nVkT  
as indicated in Fig. 1, where Vref is the reference voltage of the ADC. 
 
The DNL and the INL are calculated from: 
(2)      (LSB)         1)()1()( −−+=
QV
kTkTkDNL  
(3)      (LSB)       )}(max{ iDNLDNL =  
(4)      (LSB)      )()(
0
∑
=
=
k
i
iDNLkINL  
jitter. Jitters can be categorized into three different types: period jitter, 
cycle-to-cycle jitter, and accumulated jitter, as mentioned in [16, 9] and shown in Fig.  
2. For convenience, we assume cycle-to-cycle jitter (JCC) in this discussion by  
default. 
(7)        )}()1(max{)(max iTiTiJJ PERPERCCCC −+==  
where TPER(i) is the period of the ith sample. 
 
Figure 2. Different Types of Jitter 
 
  For evaluation, we first program the platform to sample at a certain fixed rate. Then, 
a stable sawtooth test signal is fed into the platform’s analog input channel. The  
periodic sampled results are transmitted from the platform and are collected by the  
base station. Thus the jitter can be determined following the notations and  
computations below: 
N = stated resolution bits of the ADC component. 
fsample = platform sampling frequency. 
fsaw = frequency of the sawtooth test signal. 
VFS = voltage full swing of the test signal. 
Vref = reference voltage of the platform. 
D(i) = digitized output code of ith sample 
Qideal = ideal voltage difference between consecutive samples. 
Qreal (i) = avg. calculated volt. diff. betw. ith and (i + 1)th samples. 
J(i) = ith sampling cycle-to-cycle jitter of the platform. 
 
(8)        
sample
saw
FSideal
f
fVQ ⋅=  
(9)        
2
)()1()( Nrefreal
iDiDViQ −+⋅=  
    accuracies for each sampling period, the maximum cycle-to-cycle jitter for the  
platform will be the more appropriate metric. 
(14)        1
_ TermLong
CC
LT
time T
J
f −=  
    where LTtimef  time is the fitness for long term accuracy required applications and  
TLong_Term is the tolerable average timing deviation. 
(15)        
})(max{
1
Temp
CCTemp
time T
iJ
f −=  
    where Temptimef  is the fitness for temporal accuracy required applications and  
TTemp is the tolerable temporal timing deviation. 
 
 
  • Radio Connectivity: For the fitness estimation of the connectivity, it is proper to  
    consider time domain connectivity instead of spatial domain, since the latter  
    usually has implied power issues. The time domain connectivity can be  
    represented by the packet error rate of a platform. By performing an experiment  
    like attenuator tests proposed in [11]. We can get the packet error rate PPE (%)  
    of the platform, which is the fitness quality for connectivity, 
(16)        PEtyconnectivi Pf =  
  • Lifetime: The lifetime can be simulated using systems like B# [13], which  
    provide a closed-loop, accurate profiling and evaluation environment for WSN  
    platforms. The fitness quantity of lifetime can be determined by the simulated  
    lifetime and the ideal or claimed lifetime. 
 
  Utilizing the fitness function determine the effect of the quantities above, we can  
estimate the overall fitness of a particular platform for the designate application. 
 
4. Experiment and Analysis 
 
This section first describes our experimental setup used to benchmark a commercial  
sensor platform. Then we discuss results in terms of the metrics defined in the  
preceding sections. 
 
4.1 Experimental Setup 
• Crossbow MPR410 (MICA2) and MIB510 
 
 
Figure 4. Instruments for Measurement of Signal Transformation Performance 
 
Fig. 5 is the data acquisition system (DAS). It can be used for both data monitoring  
and signal generation. It has 16-bit ADC and DAC and can reach a 200KHz high  
sampling rates. In our experiment, it is used mainly for generating signals such as  
triangular or sawtooth wave. In the future, we want to replace the DAS with an  
integrated signal emulator that can emulate analog/digital signals, power sources, and  
RF signals. Fig. 6 shows a hardware prototype of this emulator. 
 
Figure 5. National Instruments Data Acquisition System PCI-6014 
 
Fig. 7 shows the sensor platform used in our measurement, the Crossbow  
MPR410(MICA2) and Fig. 8 shows the serial interface board MIB510 to which the  
is the number of samples taken in each test signal, and other definitions of the above  
parameters are the same as those stated in 3.1.2. We observe the sampling jitter under  
different test frequencies. The observed result is listed in Table 2. Since the maximum  
difference between the adjacent two samples is affected by the quantization error of  
the ADC, the actual difference falls in a range around the calculated value with  
uncertainty. Here we tentatively introduce the claimed uncertainty ±2 LSB in the 
platform’s ADC specification. 
 
 
Figure 7. Crossbow MPR410 Sensor Board (MICA2) 
 
 
Figure 8. Crossbow MIB510 Serial Interface Board 
 
 
  The MICA2 mote’s microcontroller ATMEL ATmega128 features a successive  
approximation (SAR) ADC with 10-bit resolution, and the data sheet claims to have  
0.5 LSB INL. However, our histogram test result shows that the measured conversion  
has 1.23 LSB INL, indicating that there might be extra interferences and noise effects  
within the tested platform. 
 
Parameter Name Variable Value 
Samples per Record M 199995 
Total Cycles per Record R 3 
Repeated Times N 4 
Overall Samples S 2399940 
Sampling rate fs 200 (Hz) 
Signal Frequency f 0.40001 (Hz) 
Signal Amplitude A 1.66 (Volt) 
Tolerance B 0.1 (LSB) 
Voltage Overide VOD 0.01 (Volt) 
Table 3. Parameter Settings for Histogram Test of ADC 
 
 
Figure 9. The Output Code Distribution of Histogram Test 
 
 
Figure 12. INL Deviations Between the Individual and the Ideal Output Level 
 
4.3 Analysis 
This subsection evaluates the tested platform base on the above experiment results. If 
application developers are considering this platform for a data acquisition application, 
the metrics that should be considered should include data precision, timing accuracy,  
connectivity, and life time. The corresponding fitness quantities can be calculated  
from formulas in Section 3.2 : 
  • Data Precision: The offset VOS we measured on the MICA2 mote is about 0 volt. 
%88.99
2
02327.111 10 =+−=+−= VFS
VOSVNLfdata       (17) 
  • Timing Accuracy: Suppose the application ALT requires long term timing  
    deviation to be less than 5 ms. 
%6.97
)(5
)(12.011
_
=−=−=
ms
ms
T
J
f
TermLong
CCLT
time       (18) 
    If the application ATP requires temporal timing deviation to be less than 5ms. 
)(5
)(101
}max{
1
ms
ms
T
J
f
Temp
CCTemp
time −=−=       (19) 
Since The fitness value ranges between 0 and 1, we get 0=Temptimef  
References 
 [1] F. Alegria, P. Arpaia, A. M. da Cruz Serra, and P. Daponte. Performance analysis  
    of an adc histogram test using small triangular waves. IEEE Transactions On  
    Instrumentation and Measurement, 51(4):723–729, Aug. 2002. 
 [2] J. Blair. Histogram measurement of adc nonlinearities using sine waves. IEEE  
    Transactions on Instrument and Measurement, 43(3):373–383, June 1994. 
 [3] P. H. Chou and C. Park. Energy-efficient platform designs for real-world 
    wireless sensing applications. In Proc. IEEE/ACM International Conference on  
    Computer-aided Design, 2005. 
 [4] M. Hempstead, M. Welsh, and D. Brooks. TinyBench: the case for a 
    standardized benchmark suite for tinyos based wireless sensor network devices.  
    In Proc. 29th Annual IEEE International Conference on Local Computer  
    Networks (LCN), pages 585–586, Nov. 2004. 
 [5] IEEE 1057. Standard for Digitizing Waveform Recorders, Dec. 1994. 
 [6] Y.W. Law, J. Doumen, and P. Hartel. Survey and benchmark of block ciphers for  
    wireless sensor networks. ACM Transactions on Sensor Networks (TOSN),  
   2:65–93, Feb. 2006. 
 [7] D. Li and P. H. Chou. Maximizing efficiency of solar-powered systems by load  
    matching. In Proc. International Symposium on Low Power Electronics and  
   Design (ISLPED), pages 162–167, Aug. 2004. 
 [8] J. P. Lynch, K. J. Loh, T. C. Hou, Y. Wang, J. Yi, C. B. Yun, K. C. Lu, and C. H.  
    Loh. Validation case studies of wireless monitoring systems in civil structures. In  
    Proc. 2nd International Conference on Structural Health Monitoring of Intelligent  
    Infrastructure (SHMII-2), Nov. 2005. 
 [9] MAXIM Application Note 2744. Jitter Measurements for CLK Generators or  
    Synthesizers, Sept. 2003. 
[10] L. Nazhandali, M. Minuth, and T. Austin. SenseBench: toward an accurate  
    evaluation of sensor network processors. In Proc. IEEE International Symposium  
    on Workload Characterization, pages 197–203, Oct. 2005. 
[11] C. Park and P. H. Chou. EmPro: an environment/energy emulation and profiling  
    platform for wireless sensor networks. In Proc. 3rd Annual IEEE  
    Communications Society on Sensor and Ad Hoc Communications and  
    Networks(SECON), volume 1, pages 158–167, Sept. 2006. 
[12] C. Park, K. Lahiri, and A. Raghunathan. Battery discharge characteristics of  
□ 赴國外出差或研習 
□ 赴大陸地區出差或研習 
x 出席國際學術會議 
□ 國際合作研究計畫出國 
心得報告 
計 畫 名 稱 無線感測處理器核心之研究與
設計 
計 畫 編 號 95-2221-E-007-022- 
報 告 人 
姓 名 許雅三 
服 務 機 構
及 職 稱 清華大學電機系教授 
會議/訪問時間 
 地點 
September 26-28, 2007. Houston, Texas USA 
會 議 名 稱 High Performance Computing and Communications  
發表論文題目 Security enhancement and performance evaluation of an object-based storage system（檢附論文檔案） 
 
一、主要任務摘要（五十字以內） 
 
With rapid growth in computing and communications technology, the past decade has 
witnessed a proliferation of powerful parallel and distributed systems and an ever-increasing 
demand for practice of high performance computing and communications (HPCC). We have 
presented papers in this conference for the research results we have obtained. 
 
二、對計畫之效益（一百字以內） 
 
Many important issues in the design of computer and communication continue to 
receive careful examinations in recent years.  This includes peer-to-peer computing, parallel 
and distributed computing, grid computing, security, performance and evaluation 
methodology, sensor selection and placement, mobile agents and routing, web services and 
internet computing, networking, etc.  Many of these working items have been discussed in 
this conference, and the results can be very valuable to the research, design, and 
implementation of our projects.  Especially we will examine various possibilities for the 
design and implementation of our architecture.   
 
In addition, I also had the opportunity to meet with pioneer researches in this field and 
discuss the trends and directions with them. When there is any chance in the future, we may 
invite some of them to visit Taiwan to exchange ideas, first hand experience, and information 
with researchers from local universities and research organizations.  
 
Security Enhancement and Performance
Evaluation of an Object-Based Storage System
Po-Chun Liu, Sheng-Kai Hong, and Yarsun Hsu
Department of Electrical Engineering
National Tsing Hua University Hsinchu, 30013, Taiwan
{pcliu,phinex}@hpcc.ee.nthu.edu.tw, yshsu@ee.nthu.edu.tw
Abstract. Object-based storage oﬄoads some works of file systems to
storage devices to improve security, scalability, and performance. Secu-
rity is a main concern when sharing data over network. We examine
the security model of object-based storage and find that there is some
problem in the model. It can be disabled by modifying specific field in
the command. We propose a solution to this problem by encryption that
makes unauthenticated clients impossible to alter the field. The overhead
of this encryption is quite low. Thus the performance of our enhanced
object-based storage system is comparable to that of the original one
while offering an enhanced security. In addition, we have compared the
performance of OSD systems with that of iSCSI and NFS. The write
performance of an object-based storage system is much better because it
can oﬄoad some tasks to storage devices, and the CPU usage at client
side is also largely reduced.
Key words: object-based storage, security, encryption, file system
1 Introduction
The design of storage subsystems becomes an important issue with the improve-
ment of computer system. Although direct attached storage (DAS) devices have
much better performance compared to network attached storage (NAS), the ad-
vantages of NAS, such as scalability and file sharing, make it become important
in large scale computer systems. However, when a storage subsystem is connected
to internet, security is always a main concern for system designers. Object-based
storage systems [1][2] provide a security model which protects the shared data
in storage devices and eases the storage subsystem design in a very large scale
computer system.
The main concept of object-based storage is to oﬄoad the space management
component of existing file system to the storage device itself. Application clients
thus request for an object (or file) instead of many disk blocks. The new interface
can reduce traffics between application clients and storage devices. And the
application clients only need to manipulate hierarchy management, naming, and
user access control. The work data structure mapped to physical organization
and disk space management is left to be done in storage device.
Fig. 1. The architecture of our OSD system
does not concern about the disk space and thus its loading is eased compared to
traditional storage system.
When an application client wants to issue an OSD command, it prepares pa-
rameters such as partition ID, object ID, the length and the starting address of
the object it wants to access. Before it issues the command, it needs to request
a credential, which contains capability and capability key, from security man-
ager. The capability is generated by policy/storage manager which coordinates
requests from different application clients and determines their access rights.
Once the application client gets the credential, it packs the capability contained
in the credential into OSD CDB and sends the CDB via iSCSI initiator over
network. The command it issues can be verified by storage device server and
executed correctly with appropriate access right.
There are four supported security methods, NOSEC, CAPKEY, CMDRSP,
and ALLDATA [3][10]. The NOSEC method means security model is disabled
and all data is unprotected. The CAPKEY method protects the capability of the
CDB and the CMDRSP protects entire CDB and responses from targets. The
ALLDATA method makes sure all of the data between initiators and targets
are under protection. If the security model is enabled, the initiator needs to
compute an integrity check value before sending the command. In our system
we use HMAC (Hash Message Authentication Code) [11] algorithm and use the
secret key generated by security manager to compute integrity check value of
specific data depending on the security method. The integrity check value is
then packed into OSD CDB and the command is issued.
data transmitted between authenticated application clients and storage device
server are not be altered.
If the command is not tampered with, the storage device server then checks
whether the accessed object is allowed and the access right of the command
depending on the capability in the CDB. The storage device server will also check
the parameters such as object created time. Moreover, the specific permission
bits must be set according to the service action and object type. Only when all
the parameters of capability are verified can the storage device server execute
the OSD command.
The storage device server translates the OSD commands to VFS (Virtual
Filesystem Switch) system calls and exploits existing Linux file system such as
ext3 to do the space allocation and management. For example, OSD-CREATE-
PARTITION can be translated to mkdir() of Linux file system to create a direc-
tory to be treated as a partition of the object-based storage. We treat directories
of Linux file system as partitions and ordinary files as user objects.
2.5 Potential Problem
The security model of OSD systems provide some level of protection to avoid
malicious alteration of data over network. The credential integrity check value,
also called as capability key, is generated by security manager to compute the
integrity check value of protected data. The unauthenticated application clients
have no idea how to reconstruct the capability key because the key used to com-
pute the credential integrity check value is only known by the security manger
and the storage device server. Thus any unauthenticated application client can-
not generate a valid integrity check value without knowing capability key and
this is why the security model can avoid any malicious alteration by unauthen-
ticated application clients.
Even though the integrity check value based security model protects the
data from being altered, the CDB still can be seen by others. Unauthenticated
application clients can capture the capability by monitoring the CDB sent by
authenticated ones. If they change the security method field in the capability to
NOSEC and set integrity check value of CDB to 0s, then they can still access
the objects that the captured capability allows. All unauthenticated clients have
to do is to capture a valid capability, modify the security method, and send
the command using the modified capability to disable the security model. That
is to say, unauthenticated application clients can force storage device server
not checking the integrity check value by changing the security method field to
NOSEC.
Because the security method of certain command fully depends on the ca-
pability, the storage device server will check the integrity check value only if
the security method field of capability is not NOSEC. The security model will
not work if unauthenticated application clients can tamper the security method
field. In this study, we propose a solution to resolve this potential problem and
assure that the security model always works.
non-singular matrix; if not, we regenerate another random matrix and examine
it again. We can find the non-singular within four tries because the probability
of a randomly generated matrix being non-singular is more than 25% [13][14].
Then the public key is generated by multiplying S, G, and P, G′ = SGP .
The OSD storage server must decrypt the received CDB before computing
the integrity check value. Because G′ = SGP , we can rewrite the encrypt data
c = mSGP ⊕ e. The server first multiplies c with the inverse of P and gets the
equation: c′ = (mSGP⊕e)P−1 = mSG⊕eP−1 = m′G⊕e′. Here e′ has the same
weight as e and then the server can decode c′ with error pattern e′ to m′ using
generating matrix G. We compute the syndrome of c′ and find the least weight
error pattern and then decode c′ to m′. Once m′ is found, the original message
can be decrypted by multiplying m′ by the inverse of S because m′ = mS and
then m = m′S−1.
Both the encryption and the decryption process are very simple because the
matrix multiplications can be replaced with logic AND in binary field. With this
insignificant computing overhead we can provide an enhanced security model
without adding much cost. Unauthenticated clients now cannot capture a valid
capability to generate an unauthenticated CDB by just changing the security
method in the capability.
4 Performance Evaluation
In this section we will show the performance of our system and compare it with
other file systems. We use two identical machines with configuration listed in
Table. 1 and connect them with a 3COM gigabits switch. We use the program
bonnie++ version 1.03a [15] with file size set to 1 GB and block size 8 KB
for all of the performance evaluations. We evaluate the performance under five
environments:
OSD-NOSEC: In this environment we use the OSD system according to OSD
T10 standard with security manager disabled. The keys and integrity check
values are all set to zero. In the initiator we implement an OSD file system
based on the Intel iSCSI/OSD reference implementation, and in the target
we exploit existing ext3 file system to manage the disk space. The initiator
and target are connected through a gigabits network.
OSD-CAPKEY: In this environment we use the OSD system with security
method set to CAPKEY. The security manager needs to generate a key
for initiators to compute integrity check value. The initiator and target are
implemented in the same way as OSD-NOSEC.
ENHANCED: This uses the enhanced security model we have proposed. The
architecture is the same as an OSD system except an additional encryption
process.
iSCSI: We use a storage subsystem which supports dual 1 Gbits iSCSI ports
as the underlying storage medium. In the initiator we use Linux-iSCSI driver
[16] to connect to the iSCSI storage through a gigabits network and mount
it as a local disk.
Fig. 2. (a)Performance when writing a character at a time (b)Performance when writ-
ing a block at a time
test is due to disk performance, where performance of iSCSI storage is limited
by disk. We can improve the performance by about 65 % if we configure the
iSCSI storage to a RAID 5 storage subsystem. The performance improvement
for NFS is smaller compared with OSD system and iSCSI storage due to RPC
procedure because every command is limited by the RPC response time. The
write performance of our OSD system is much better in this test.
Fig. 3(a) shows the performance of reading a character at a time. The poor
performance in all environments is now again due to the huge overhead if it
only reads a character at a time because the entire block needs to be transferred
while only one character is needed. Now the OSD system is about 17 % slower
than the iSCSI storage and this is due to the overhead of OSD device server
when processing a READ command. Unlike in the writing case, where the OSD
file system does not need to wait for the target server to process the command,
it now needs to wait for the target server to process the command and return
accessed data. The overhead of the target server processing the OSD command
includes security check, capability validation and command execution. Thus the
overhead causes the performance degradation in reading data compared to iSCSI
storage. But the CPU usage of initiator is reduced by about 18 % (78.2 % in
iSCSI storage and 63.7% in the OSD system with NOSEC) in the OSD system
due to the oﬄoading of disk space management to the target server. The NFS
performs better than both iSCSI storage and OSD systems due to the use of a
client cache.
Because these machines share the switch with other computers in our lab-
oratory, the traffic of the switch can impact the performance of this system.
The original read performance of ENHANCED is somewhat better than OSD-
NOSEC and OSD-CAPKEY due to different traffic of the switch. Thus we re-
measure the performance of these three systems by disconnecting all the other
computers and get the result shown in Fig. 3(a).
Fig. 3(b) shows the performance of reading a block at a time. The overall
performance is better than per character read performance as shown in Fig. 3(a).
The iSCSI storage and NFS improve a lot due to lower overhead when reading
a block at a time. An entire block now contains valid data and traffics between
Fig. 4. Performance when rewriting an existing file
client side of OSD systems can be reduced significantly. We also find that our
OSD system performs much better than the others when writing a file because
a client’s OSD file system dose not need to manage disk space. An application
client can issue another command right after receiving an acknowledgement re-
sponse from storage device server without waiting for it to execute the command.
The read and rewrite performances are not as good as write performance due
to the overhead of the file system used to emulate object-based disk in the stor-
age server.The degradation is expected to be improved significantly when real
object-based disk becomes available in the future.
The first task to do in the future is to improve the rewrite performance. We
want to build an OSD system with performance comparable to iSCSI storage,
thus we first need to improve the performance when rewriting a file. The reason
that rewrite performance is not as good as write performance is that data needs
to be read from the server to the client side, and the data is then modified and
sent back to the server. We propose to implement a new command REWRITE
to be used to eliminate this unnecessary data read from a storage server to an
application client. The new data is sent to the server and the modification is
done in the server side directly.
The ultimate goal is to design a real object-based disk. Currently the OSD
server emulates object-based storage disk by utilizing the Linux ext3 file system
to manage the disk space of the server and its overhead is very large. If we
can design an intelligent disk which can manage disk space by itself, the read
performance improvement will be significant. And this will take the storage
technique to another era.
