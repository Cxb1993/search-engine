2目錄
摘要 …………………………………………………………………………3
1. 前言 ………………………………………………………………………4
2. 具秘密資訊保護之公平交換機制 ………………………………………7
2.1 緒論 …………………………………………………………………7
2.2 定義與基本模型 ……………………………………………………9
2.3 離線半性任第三方 …………………………………………………10
2.4 VEDL 證明細節………………………………………………………14
2.5 門檻式公平交換協定 ………………………………………………15
2.6 結語 …………………………………………………………………22
2.7 參考文獻 ……………………………………………………………22
3. 具秘密保護之合約簽署 …………………………………………………25
3.1 具非洩漏特性之合約簽署協定 ……………………………………25
3.2 植基於雙線函數之公平合約簽署系統 ……………………………49
4. 電子付款機制之應用 ……………………………………………………64
4.1 具公平交換特性之電子付款系統 …………………………………64
4.2 具秘密資訊保護之公平電子付款系統 ……………………………84
5. 無線網路電子商務應用實作 ……………………………………………101
5.1 前言 …………………………………………………………………101
5.2 工具介紹 ……………………………………………………………101
5.3 程式實作 ……………………………………………………………105
5.4 實驗數據 ……………………………………………………………110
5.5 結語 …………………………………………………………………111
6. 結論與計畫成果評估 ……………………………………………………112
附錄：實作程式列表（部分）………………………………………………114
41.前言
近年來在網際網路的發展之下，出現了不同於傳統的商務行為也就是所謂的
電子商務，凡透過網路的交易行為皆可以統稱為電子商務。電子商務的蓬勃發
展，使得我們日常生活大大的改變。在商業上的改變更是顯著，電子商務架構於
網路之上，只要在有網路有電腦的地方就可以隨時隨地的交易，更是不受地點的
限制。隨著環境的改變，交易模式也漸漸的網路化了。傳統的產業借由網路的便
利，已不再受區域的限制，可以將商品展示於網路上行銷到全世界，擴大銷售對
象範圍以尋求更多的商機。
雖然目前電子商業已經蓬勃發展，但絕大部分的使用者都對其交易的公平
性、安全性、可靠性仍是存有很大的疑慮。因此在網路安全的疑慮一直是大家關
心的議題及致力解決的重點。為了讓使用者能夠放心的在網路上購物、交易，我
們必須致力於網路安全的發展，由技術上、管理上、及法律上的層面著手。建立
一個安全可靠公平的網路交易環境。以消除使用者對電子商務的不信任以及打造
真正安全可靠的交易環境，加以利用網路的便利以刺激電子商務更加蓬勃發展。
透過密碼學技術讓網路上雙方能夠公平地交換秘密資訊的方式稱之為公平
交換協定 (Fair Exchange Protocol)。公平的交換協定可以使用在於網路上電子資
料的交換上，像是數位簽章、電子貨品的買賣付錢，甚至於合約的簽署…等等。
而什麼要使用到公平交換協定呢？因為在網路上交換除了要避免懷有惡意的人
士破壞之外還要維持交易本身的公平性及正確性。對交易的公平性而言是非常重
要的，由於在網路上沒有辨法可以提供面對面的交易，且交易的公平性卻是買賣
雙方所擔憂的問題。不誠實的買賣雙方若有故意欺騙的行為即可能造成損失即交
易物品缺乏其正確性。公平的交換協定的目的是指在雙方交換簽章時只有兩種結
果，一是雙方都可以得到對方的資訊，另一是雙方都拿不到對方的資訊，在這兩
種結果下才可以達到真正公平，只有真正的公平才能使資料在交換時達到最完整
的互換不致遭受欺騙，也才能使整個網路的運用更加可以讓人信賴。
6第 2 章提出一個具有秘密保護的公平交換機制，主要是針對秘密資訊保護，
並介紹幾種不同的模式，包含單一以及多重的 TTP，除了將焦點置於安全性考
量之外，也強調可靠度之提升。在單一 TTP 的模式下，我們所提出的方法可以
保護交換的資訊。而在多重 TTP 的模式下，我們的方法亦有能力平衡整體系統
的安全度與可靠度。
第 3 章主要提出具秘密保護之合約簽署協定。其中包含兩個系統。第一個系
統是稱為「非洩漏」 (non-disclosure) 特性之合約簽署，可防止參與協定的任一
方誤用在交換過程所留下的一些證據，造成一些利益上的損害。在文中展示兩種
實現方式，一為「秘密分割」，另一為「可轉換簽章」。此外，為滿足傳統紙張型
式的合約簽署特性，在本文中採用了多人簽章技術。第二個系統是提出一個有效
率的合約簽署系統，利用 Boneh 及 Gentry 所提出之聚合簽章 (Aggregate
Signature) 來達到離線型半信任 TTP 系統。此外，使用聚合簽章系統以及雙線
函數 (Bilinear Pairings) 將可提供系統可靠度的提升。
第 4 章主要將公平交換的概念延伸至電子付款系統。主要是電子現金系統
(e-cash)。在 4.1 節 系統中提出如何將公平交換的機制應用於電子現金系統中，
而在 4.2 節中進一步利用雙線性函數建構出具有秘密資訊保護之公平電子付款
機制。
第 5 章將上述 4.1 節的公平電子現金系統實作於 PDA 上以證明我們的
系統可以應用於無線網路的設施上。實驗的結果其效能並未很好，主要的原因是
需要一些大量的運算及證明協定。然而已經初步達成本計畫在無線網路應用上之
目標。
最後，我們在第 6 章對整體計畫成果作一評估。
8常的程序進行時就會發生紛爭，則 TTP 在此時發揮效用，將密文解密取得訊息
後傳送給適當的一方以維持公平性。
不幸地，on-line / off-line TTP 有兩個嚴重的缺點。第一個是 TTP 可輕易地
取得雙方交換的秘密。這表示使先前的並沒有考慮到 TTP 可能濫用他所接收的
秘密而危害到雙方的權益。舉例來說，如果交換的秘密是黑函（blackmail）或是
交易報告，若 TTP 不經意的洩漏出去則會對交易造成嚴重的傷害。Franklin 和
Reiter 在 1997 年[FR97]提出第一個防止交換的秘密被 TTP 濫用的技巧；他們提
出了線上式半信任第三方來取代離線式可信任第三方，因此 TTP 不管交易是否
正常進行皆會介入其中運作，但效率並不理想。在本文中，我們提出一個新的
off-line TTP 公平交換協定，成功地保護交換的秘密；不僅在交換資訊時有很好
的效率，並且 TTP 在協定有紛爭的情況才會介入，有效地降低 TTP 直接取得交
換秘密的機會。
而第二個缺點是，TTP 必須是完全可信賴的，例如假設 TTP 不會與交換雙
方的任一方共謀。在本章中，亦提出兩種（t, n）門檻式第三方（（t, n） threshold
third parties）技巧克服此缺點。（t, n） 門檻式協定的其他特性是提高了可靠性與
提供錯誤容忍（fault-tolerance），可容忍僅一個 TTP 失敗、犯錯，或拒絕完全遵
循交換程序[Gon93]。
2.1.1 貢獻
在本章中，提出了三個提供不同安全性與可靠性的協定。第一個協定是基本
的且使用單一 TTP 為一個秘密切割模式（secret-dividing model），類似文獻
[FR97]。第二個協定是藉由可公開驗證秘密共享（Publicly Verifiable Secret
Sharing ，PVSS）[Sta96]設計的多重 TTP 模式，而 PVSS 可直接被應用於如文獻
[Sta96]中公平交換的門檻式方法，並建立一個秘密金鑰代管系統 (secret-key
escrow)。然而，為了保護交換秘密，我們提供了一個概念，即當使用者要求 TTP
解決紛爭時，必須將他的秘密分為多個部分給多重 TTP。第三個協定結合了前兩
10
定義 2.2.2 （離線式（t, n）門檻式可信任第三方（於公平交換協定上））
假設兩個使用者 AU 和 BU 想以公平的方式來交換他們的秘密，則在交換協定
中發生錯誤時會存在著n個人擔任仲裁者。當 TTP 是誠實且沒有與交換雙方任
一方共謀，只要n裡面至少 t個成員是有效的，則可完成交換程序且達到公平性。
反之，若 t個或更多方共謀，則可取得交換秘密。若我們假設 TTP 與 AU 或 BU 共
謀，在超過半數的 TTP 是誠實的情形下，可以保證協定的公平性（ [有效並誠
實的 TTP 個數] ≧ t ≧ 1
2
n
）。
t 值需小心的選擇。在安全性的考量上， t 必須是一個很大的數，但這也代
表參與協定的 TTP 數目亦需增加。另一個複雜的問題是每個 TTP 接收到利益受
損的一方所發出的要求介入解決糾紛時需確認其交換秘密的正確性。這個問題可
以利用可公開驗證秘密共享（PVSS）[Sta96]來解決。
定義 2.2.3 （離線式（t, n）門檻式半信任第三方（於公平交換協定上））
類似定義 2.2.2。然而，即使 t個或更多方彼此合作，在 TTP 沒有與 AU 或 BU
共謀的情況下，他們仍無法取得任何有關交換秘密的資訊。
定義 2.2.3 說明了在我們的方法中有著彈性的模式。由於門檻值 t的選擇可使
安全性與可靠性互相調節；我們無法使一個系統兼具高安全性與高可靠性。因此
我們提供了一個機制，允許我們可以稍微調節 t的數值達到可接受的可靠性，去
保護秘密免於 TTP 間共謀所造成的傷害。
2.3 離線半信任第三方
如果交換秘密的正確性無法確認，那麼公平交換協定就不會存在任何意義
了。最普遍的作法是公證單位經由單向雜湊函數（one-way hash）[FR97]去驗證
12
定義 2.3.2 （基於離散對數之可驗證加密）[Sta96]
令 PU 為 一 個 證 明 者 而 VU 為 一 個 驗 證 者 。 PU 可 以 利 用 證 明
VEDLProof ( , , ( ))C PK f m 在不揭露訊息m （
*
qm Z ）下向 VU 證明密文C 確實是訊
息m 的加密。其中 PK 是加密用的公開金鑰（例如： ( )PKC E m ）， ( )f m 是訊息
m 附有驗證特性的單向雜湊函數所產生的數值（可見定義 2.3.1）。
離線式半信任第三方的公平交換協定如下所述。假設交換者 AU 和 BU 想要交
換他們各自的秘密 As 和 Bs ，此外介於交換者間的傳輸通道是安全的。
協定一
步驟 1. BU 將 B BB( ), desc , Certs sf s 傳送給 AU 。
步驟 2. AU 會驗證 B B BB B Auth B BCert {desc , , ( ), Sig (desc , , ( ))}s s sU f s U f s 是否正
確。如果驗證成功， AU 隨機選擇
*
1 qa Z ，然後計算 12 A 1 moda s a q ，
而 *A qs Z 是 AU 的秘密。然後 AU 將下列資訊傳送給 BU ：
T A A A T1 1 A 2 VEDL 1 T 1
( ), ( ), ( ),desc ,Cert ,Sig ( ), ,Proof ( ( ), , ( ))PK s s U PKE a f a f s a E a PK f a
；而 TPK 是 TTP 的公鑰， A B A B{ , , ( ), ( ), text}U U f s f s ，其中 text是交
換事件的敘述。
步驟 3. 當接收到步驟 2 所傳送的資料時， BU 驗證 ACert s 是否有效。亦會檢查證
明
TVEDL 1 T 1
Proof ( ( ), , ( ))PKE a PK f a 、簽章 ASig ( )U 以及等式
2 1 A( , ( )) ( )F a f a f s 是否成立。如果上述驗證成立，則 BU 傳送其秘密資
訊 Bs 給 AU ，否則 BU 拒絕繼續執行協定。
步驟 4. AU 驗證 Bs 是否與其可驗證的單向雜湊函數值 B( )f s 一致。如果成立， AU
14
2.4. VEDL 證明細節
對於 VEDL 的相關證明細節僅簡述如下:若讀者想知道更詳細的數學推導，
可以參考 [Sta96]。
ElGamal’s 的公鑰系統[ELG85]敍述如下（質數 p 、 q和 'q 如定義 2.3.1 所
述）。假設用來加密的公鑰為 modexey h q ， qh Z 是級數為 'q 的 'qG 的產生器，
而 'e qx Z
 是用來加密的私鑰。 'qk Z 是隨機產生的變數。對訊息m 的加密以下
列的式子表示：
1
1 2( ) ( , ) ( mod , mod )e
k k
y eE m C C h q m y q
 
而密文的解密則為 11 2e
xm C C  。接下來的定義則可用來做為 VEDL 的證明。
定義 2.4.1 雙重離散對數相等證明（Proof of equivalence of discrete logarithm to
discrete loglogarithm（PEDLDLL））[BDM98，BF98]。
令 p、q、 'q 、g和 h，使用前文的定義，且 , qz w Z 和 pW Z ，令 modxw h q
和 ( ) modzW g p
 。當一個知道 'qZ  的驗證者可以利用PEDLDLL來證明 w和
W 是根據相同之計算而來，而不用洩露和 z。
這個證明的推導和驗證可以參考[BDM98，Sta96]。值得一提的是，這個證
明可以為非交互式的（non-interactive），所以對每一個人而言，可以自行驗證其
正確性，而不需要和驗證者互相配合。
以下為利用VEDL來證明 ( ( ), , ( ))PKE m PK f m ：
1
1 2( ) ( , ) ( mod , mod )
k k
PK eE m C C h q m y q
 
ePK y
( ) modmf m g p
接下來重新將等式整理得到：
16
所 有 modjCjL g p ， qs Z 是 分 享 的 秘 密 。 秘 密 擁 有 者 安 全 的 傳 送
1
1
mod
t j
i j ij
s s C d q

  （ i qd Z ， 0id  ）給每一個參與者 iU ， id 是針對每一個
iU 所公開的值。在公開驗證的部分，秘密的擁有者對所有經過分享的秘密，使
用 PK 做加密的動作： ( ), 1,...,PK iE s i n ，並與 ( mod )isiv g p 、VEDL證明
VEDLProof ( ( ), , )iPK i i iE s PK v 一 起 公 布 。 並 藉 由 檢 查 是 否 符 合
1 ( )
1
(mod )
j
i
t d
i jj
v V L p

 ， 1,...,i n 以及VEDL證明是否完整建立來驗證每一個分
享。
以下將介紹一個新的離線式 （t, n） 門檻式可信任第三方方法
協定二
步驟 1. BU 傳送 ( )Bf s 、 Bsdesc 和 BsCert 給 AU
步驟 2. AU 將其秘密 As 利用 PVSS，分割成n個部分（每一個以 iAs 表示）。所以 AU
必須計算
1
1
mod
i j i
t j
A A A Aj
s s C d q

  、 1,...,i n ， iAd 是一個公開的變數，
再計算並且公布 modAj
j
C
AL g p 、 1,..., 1j t ， ( mod )Aii
S
Av g p ，
( )
T ii
PK AE s 和 VEDLProof ( ( ), , )T i i iiPK A T AE s PK v 、 1,...,i n ， iTPK 表示 iTTP的公
鑰。之後 AU 傳送以下的訊息給 BU ： ( )Af s 、 Asdesc 、 AsCert 、 ASig ( )U 、
{ , , ( ), ( ), text}A B A BU U f s f s ， text表示對交換事件的敍述。
步驟 3. BU 驗證 AsCert 和 ASig ( )U 。如果兩者都正確，則 BU 利用 PVSS 檢查所有
分享的部分。故 BU 必須檢查
( )1
1
( ) (mod ) , 1, 2,...,
j
Ai
i A j
dt
A A j
v f s L p i n

  是
否成立。並對 VEDLProof ( ( ), , ), 1, 2,...,T i iiPK A T i AE s PK v i n 進行完整的推
導。如果上述兩個驗證方式都通過檢驗，則 BU 傳送其秘密 Bs 給 AU 。反
18
VEDLProof ( ( ), , ), 1,...,T l l llPK A T AE s PK v l n
VEDLProof ( ( ), , ), 1,...,T l l llPK B T BE s PK v l n
如果上述的式子都正確， iTTP 則傳送 iAs 給 BU ，而為了防止可能發生的問
題， iTTP也需要將 iBs ，傳送給 AU 。
定理 2.5.1 （協定二中的公平性）
假設在協定二中，所參與的 TTP 都是誠實的，並且有 t個或 t個以上的 TTP
參與了整個過程，透過協定二，將可以保證 AU 或 BU 都可以公平的得到對方的秘
密資訊；而參與過程的數個 TTP，將無法得到 AU 或 BU 的秘密資訊，以保證協定
二的公平性。（值得一提的是，如果發生 TTP 和 AU 或 BU 其中一人共謀的情況時，
協定二仍可以保證其公平性，但[參與交換和誠實的 TTP 的數目] 1
2
n
t  
。）
定理 2.5.2（協定二中對交換秘密的保護）
在協定二中，如果沒有 TTP 和 AU 或 BU 共謀，並且只有 1t個或數目更少的
TTP 是不誠實的，當這些不誠實的 TTP 發生共謀時，也不能洩露 AU 和 BU 所交
換的訊息。
2.5.2 離線式 （t, n）門檻式半信任第三方
在此我們提出了一個改良的架構，考慮到即使 t個或超過 t個 TTP 發生彼此
共謀的情況時，仍然不能洩露 AU 和 BU 所交換的訊息；不過前提是 AU 和 BU 都是
正直且誠實的兩方。在這部分應用了協定一中，將 AU 欲交換的秘密分割成兩個
部分的觀念。其中一個分割的秘密資訊，只在 AU 和 BU 中做交換，而另一個分割
的部分，則再分割成n個更小的秘密資訊，並把這n個部分，以n個不同的 TTP
的公鑰加密，當發生糾紛時， BU 在把其秘密資訊傳送給數個 TTP 時，也同樣先
20
分享的部分。所以 BU 必須檢查
1 ( )
1
1
( ) (mod ) 1,2,...,
j
Ai
i A j
t d
A
j
v f a L p i n


  是
否成立。並對 VEDL 1Proof ( ( ), , )T i iiPK i T AE a PK v 進行完整的推導。如果上述兩
個驗證方式都通過檢驗， BU 則再驗證 2 1( , ( )) ( )AF a f a f s 是否成立。如
果上述的檢查都正確，則 BU 傳送其秘密 Bs 給 AU 。反之 BU 則停止該程序。
步驟 4. AU 檢驗 Bs 是否包含了其經過認證的雜湊值 ( )Bf s 。如果經過檢查正確無
誤，則 AU 傳送 As 給 BU 。
執行到步驟 4 時，此時交換的糾紛可能己經發生。因為在步驟 3 時， BU 己
經在把 Bs 傳送給 AU ，但在第 4 步驟時， BU 卻無法收從 AU 收到 As ，問題便因此
產生。
步驟 5. BU 隨機選取 1b 並計算
1
2 1 modBb s b q
 ，並將其 1b 利用PVSS，分割成n個
部分（每一個以 1ib 表示）。所以 AU 必須計算
1
1 1 1
mod
i j i
t j
B Bj
b b C d q

  、
1,...,i n ， Bid 是一個公開的變數，再計算並且公布以下的訊息：
2( )APKE b
2
2( ) mod
bf b g p
VEDL 2 2Proof ( ( ), , ( ))A APK PKE b E f b
1
1( ) mod
bf b g p
modB j
j
C
BL g p 、 1,..., 1j t 
1 modi
i
b
B g p  、 1,...,i n
1( )TiPK iE b 、 1,...,i n
VEDL 1Proof ( ( ), , )T iiPK i T biE b PK v 、 1,...,i n
22
性。（值得一提的是，如果發生 TTP 和 AU 或 BU 其中一人共謀的情況時，協定三
仍然可以完成其公平性，但[參與交換和其中誠實的 TTP 的數目] 1
2
n
t  
。）
定理 2.5.4（協定三中對交換秘密的保護）
在協定三中，如果沒有 TTP 和 AU 或 BU 共謀，即使所有的 TTP 都不誠實，
並且所有的 TTP 聯合共謀，也不能洩露 AU 和 BU 所交換的訊息。
2.6 結語
在本章中，我們提出了幾個保護交換秘密資訊的方法，同時保障了雙方的權
益。這是第一篇考慮加入門檻值來保護公平交換協定的文章，並且提高了安全性
和可靠性。這也是第一篇討論到二個主題，第一個是探討當 TTP 發生共謀時的
研究；第二個部分是，針對不同層級的安全性進行詳細的分析。在此我們證明了
三個提出的協定，而因為採取了一個更具彈性的設計和想法，所以可以很容易的
實作出成果。在未來工作中，將會繼續發展出一個公平交換的通用模型，達到可
以安全交換秘密的目的。
2.7 參考文獻
[ASW98] [ASW00]N. Asokan, V. Shoup and M. Waidner, "Optimistic Fair
Exchange of Digital Signatures," IEEE Journal on Selected Areas in
Communications, April, 2000, pp. 593-610.
[Bao04] F. Bao, "Colluding attacks to a payment protocol and two signature
exchange schemes," In Advances in cryptology - Proceedings of
Asiacrypt 2004. Lecture notes in computer science (LNCS), 3329,
Springer-Verlag, 2004, pp. 417-429.
[BDM98] F. Bao, R.H. Deng, and W. Mao, "Efficient and practical fair exchange
protocols with off-line TTP," Proceedings of the 1998 IEEE
Symposium on Security and Privacy, Oakland(CA): IEEE Computer
press, 1998, pp. 77-85.
24
Berlin: Springer, 1996, pp. 55-61.
[ZG97] J. Zhou and D. Gollmann, "An efficient non-repudiation protocol,"
Proceedings of 1997 IEEE Computer Security Foundations Workshop
(CSFW’97), IEEE CS Press, June, 1997, pp. 126-132.
26
這樣的方式是一個沒有效率的做法，甚至會成為通訊跟計算的瓶頸。所以，如果
TTP 轉換角色，扮演一個糾紛調解人，只有在兩個交易者間發生爭論時，才會參
與交易以解決紛爭，這樣效能便可以提升。而這種只有在交換程序中發生錯誤，
或當兩個交易者其中之一有惡意行為時，TTP 才會介入的做法，稱為離線式
TTP[ASW00，BDM98，BF98，Che98，GJM99，ZG97]。這種方法是由 Franklin
和 Reiter 在 1977 年所提出的[FR97] ，第一個優點是保護參與交換者的隱私。他
們提出一個技術：STTP(Semi-trusted third party)。透過這樣的方式，可以避免 TTP
無限制地獲得欲交換的資料。這意味著從現在起沒有一個可以被完全地信賴的
TTP，TTP 存取受限制是為了排除它可能誤用交換資料的情況。然而這個由
Franklin 跟 Reiter 所提出的 STTP，仍然是一個效率不佳的在線式 TTP，所以還
是必須處理大量的資料交換。因此並不適合做簽章的交換。
一個公平的合約簽署，必須提供一個性質：交換雙方都可以獲得或是交換雙
方都無法獲得對方的資訊，以保證真正的公平。如果交換雙方在合約簽署程序
中，無法完成整個交換過程，沒有「證據」可以讓某一交換方證明另一交換方同
意來簽署合約，（雖然沒有完成整個的協議）。則稱為非洩漏性（Non-disclosure）。
Bao 等人[BDM98] 提出了一個實用且有效率的協定，可以用來完成簽章的公平
交換。他們提出了新觀念，「訊息加密為簽章認證」（Certificate of encrypted
message being a signature CEMBS ）。利用這樣的方法，將一個包含交換者簽章
的訊息加密，而不會洩露簽章內容。這個 CEMBS 的可以經由交互式或非交互式
零知識證明來證明安全性。如果使用非交互式證明，則會留下證據，將會被另一
交換者利用，產生該交換者合法取得對方簽章的假象。雖然這個證據並不是一個
正規的簽章型態，仍然公開了一些重要的資訊。即使採用交互式零知識證明的證
明方式，仍舊容易受到中間人攻擊（Middle-person attack）[JSI96]。而陷阱門技
術 (trap-door technique) [JSI96] 則可以用來提供非交互式零知識證明的證明過
程。
28
Garay 等人[GJM99]在 1999 年提出了一個新的概念:無誤用的樂觀式合約簽
署協定(Abuse-Free Optimistic Contract Singing)。這個概念跟我們所提出的結果很
相似。在他的協定中有許多很好的解答跟分析。但遺憾的是，他們並沒討論關於
TTP 會洩露簽章的部份，在文章中所提到的是完全被信任的 TTP。此外在 1998
年 Chen [Che98]提出了一個有效率的公平交換協定，是利用驗證簽章系統
(Confirmation Signature Scheme)，但在文中卻沒有提出合約簽署的部分。
最近的研究焦點鎖定在改善可驗證的加密訊息(Verifiable Encrypted Message
VEM)或可驗證的加密簽章(Verifiable Encrypted Signature VES)(也稱為 CEMBS)
的效率分析。VEM(或 VES)是離線式 TTP 公平交換協定主要的基礎材料，但因
為使用零知識(zero-knowledge)協定，所以是費時的方法。Nenadic 等人[NZB04]
提出了一個公平以 DSA 為基礎的簽章交換協定並使用有效率的 VES。Boneh 等
人[BGLS03]又提出以 VES 為基礎的聚集簽章(Aggregate Signature)，當作更有效
率且更一進步的方法。其中並配合雙線性函數加密系統 (Pairing-Based
Cryptosystem) 的使用。然而這些協定並沒有提及類似我們所提出的「非洩漏」
屬性的需求。
為了達到我們的目的，在此提出了兩個方法，稱為秘密分割法和可轉換簽
章。前者是由 Franklin 和 Reiter[FR97]跟 Bao 和 Deng[BD99] 的方法所延伸，而
第二個提出的方法則包含了確認簽章系統的部分，其中的內容部分如同[Cha94，
MS98]的方法。總之，我們的貢獻包含了以下兩方面：
1. 這篇文章介紹了「非洩漏」的公平合約簽署的概念，有著以下兩種重要的特
性。〈a〉如果合約簽署協定失敗，沒有一個交易者，可以得到其它交易者同
意簽署合約的證據〈b〉TTP 不能獲得關於交換雙方在交換中，任何合約簽署
的可驗證資訊。
30
這密文(C1,C2)可以被解密如下：
1
1 2 mod
SKm C C q 
SK 是相對於公鑰PK 的私鑰(即 modSKPK q )。
假設 ( ) (mod )mf m g p 已經過可信任的認證中心(Trust Authority)認證
2 2( ) mod
kC mC PKf m g g p 
這個方程式說明，如果這個證明者(prover)可以證明，這個基底為的 1C 的
離散對數，會相等於基底為 g 和PK 的 2( )Cf m 的雙離散對數，然後就可以證明C 是
訊息 m 加密後的形式。這樣的論證稱為雙層離散對數等價證明 Proof of
Equivalence of Discrete Logarithm to Discrete LogLogarithm(PEDLDLL)，而這
個證明可以使用交互式或非交互式協定的證明[BDM98，Sta96]。然而這個非交
互式協定雖然有較好的效率，但不能做零知識證明(zero-knowledge proof)，因為
驗證者(verifier)可以經由傳送這個證明給其它人而洩露出這個證據。因此，我們
使用陷阱門委任 (trapdoor commitment) 技術[JSI96]來設計一個非交互式零知識
證明的 PEDLDLL。
定義. 3.1.2.2 (非交互式零知識證明的 PEDLDLL) 令 p、q、 'q 、g 和依先
前 的 定 義 。 令 *pW Z 、 *qw Z 、 *qh Z ， 且 假 設 (mod )kw q 、 和
( ) (mod )
khW g p ， *'qk Z 。一個證明者(prover)知道秘密 k，用非交互式零知識
證明的 PEDLDLL 證明w跟W 都是由相同的 k 產生的，而不需洩露 k 跟 k。
這個非交互式零知識證明的 PEDLDLL 的方法被討論如下：
令 ( , )V VSK PK 是一對驗證者 (verifier) 用來加密的私鑰和公鑰，所以
modVSKVPK q 。這個證明者(prover)先隨機挑選u 和 v， *'qk Z 和 *'qq Z 。並
32
1 1( || || || || || || || || ... || || )g ge H w h W g t t t t      ， w跟W 是由 VU 任意地選擇的偽
造訊息。所以，V 可以簡單地計算 iu ， 1,2,...i 且 v使用下列兩個方程式：
i i iu e 
1( ) (mod ')Vv u SK q  
定義. 3.1.2.3 (由指定驗證者驗證之離散對數的可驗證加密 Verifiable
Encryption of Discrete Logarithms with a Designated Verifier, VEDLDV)令 PU
是一個證明者且 VU 是一個被指定(designated)的驗證者。 PU 可以向 VU 證明，密
文C 是m 經過加密後的訊息，而沒有洩露m 的資訊。
PU 對 VU 做 VEDLDV ,Proof ( , , ( ))VU C PK f m 的證明， PK 是用來加密的公開金
鑰， ()f 代表的是一個單向雜湊函數。然而這個被指定的驗證者 VU ，不能傳送可
驗證的證據給其他人，以說服其他人這個證明是正確的。
這個證明者依據定義 3.1.2.1 建立了一個加密，以產生這個證明。然後，他
證明這個加密，的確使用一個非交互式零知識證明的 PEDLDLL，就如同定義
3.1.2.2 的描述。
3.1.3 一個簡單直接卻不完美的協定 (A Straightforward but
Defective Protocol)
此小節介紹有關直接卻有缺陷的協定，指出因為設計上的缺失導致證據的
遺漏，且會被某些有心人士拿來利用。我們利用 Schnorr’s 多重簽章架構 [Sch89]
將合約簽章的長度減半。
在介紹詳細的流程之前，我們先定義一個具乘法性質的單向函數。
34
3. 驗證與 BU 進行簽章交換： BU 推算出  ,A Bc H R R h m  並確認其中
   
   
  
?
?
2 1
1 1
?
mod p ,
, and
, ,
ACCEPT,
TTP
C
A A A
A
VEDL PK TTP
R f z y
F a f a f z
Proof E a PK f a

 

以及確認其中    1A TTPx PK ASig E a c f z 是合法的。如果這些都正確，則 BU
會推算出  modB B Bz c x r q   並且發送 Bz 給 AU ；否則， BU 會中止協定。
4. 驗證與 AU 進行簽章交換： AU 進行確認 , Bc z 的動作。如果此訊息正確，
AU 將會發送 , Ac z 給 BU ；否則 AU 也會中止協定。
爭議：在步驟 4，若 AU 是不誠實的，可能會出現爭議。在此個案，因為 AU 的簽
章 , Bc z 已在步驟 3 被送出，而 BU 無法接受由 AU 傳來的合法訊息 , Ac z 。因
此， BU 可能會轉而向 TTP 尋求解決方法，在接下來的步驟進行說明。
5. 尋 求 爭 議 的 解 決 ： BU 發 送 下 列 的 訊 息 ：
           1 1, , , , , ,A TTP TTP Ax PK A PK PK B A BSig E a c f z E a E z f z f z c h m 和
    , ,
AVEDL PK B A B
Proof E z PK f z 給 TTP 解密。
6. 解決爭議：TTP 推算出    ' modcA A AR f z y p 和    ' modcB B BR f z y p
並且確認      1 ' ' ,A TTPx PK A B ASig E a H R R h m f z 是否合法。同時，
    , ,
AVEDL PK B A B
Proof E z PK f z 的合法性也要被檢查。如果這些簽章都
是合法的，TTP 便會發送  
APK B
E z 給 AU 並且將 1a 發送給 BU 迫使此交換程
36
3.1.4.1 主要協定
在此協定主要的任務是排除 AU 的證據遭到偽造以及重送攻擊。此外，我們
重點在 VEDL的證明。如果 VEDL交互證明成立，便可以認定黑暗中的證明(proof
in the dark)和不可轉移性。然而，Jakobsson 等人[JSI96]指出一些有關於一般交
互作用證明的缺點。基於效率與安全性，我們提出一個觀點，利用非交互作用零
知識證明(請參考定義 3.1.2.2 和定義 3.1.2.3)。
因此產生了一個新的協定二，主要是將協定一的某些步驟加以修改，詳述如下。
協定二: 利用秘密分割技術的非洩漏公平合約簽章協定(修改自協定一)
Non-disclosure Fair Contract Signing Protocol with the Secret Divide Technique
(modified from Protocol 1)
2.’可驗證加密簽章的傳送（Delivery of verifiable encrypted signature）：
AU 推算出合約 m 的簽章  , Ac z ，其中  ,A Bc H R R h m  而
 modA A Az c x r q   。 然 後 ， AU 任 意 選 擇 *1 qa Z 並 推 算 出
 12 1 modAa z a q 。接著， AU 發送      1 1 2 2, , , ,TTPPK AE a f a f z a f a 和
  1 1, , ,TTPVEDLDV B PK TTPProof U E a PK f a 給 BU 。
3.’驗證與 BU 進行簽章交換（Verification and signature exchange for UB）：
BU 推算出  ,A Bc H R R h m  並確認其中
38
3.1.5 使用可轉換簽章實現一個公平的非洩漏合約簽署協定
3.1.5.1 主要協定
在本章節中主要核心技術為可轉換簽章。一個被稱為指定確認者簽章
( designated confirmer signature) 的對稱式可轉換簽章系統在 1994 年首先由
Chaum [Cha94] 所提出，並且在 1998 年由 Michels 及 Stadler [MS98] 改進。接
下來的定義將解釋指定確認者簽章系統( designated confirmer signature scheme)的
主要概念及實現結果。
定義 3.1.5.1
如果一個在訊息 m 中的簽章 '( )S m 滿足以下需求的話，則稱此簽章為指定確
認者簽章( designated confirmer signature)：
1. 簽章 '( )S m 只能被簽章者或者被指定確認者所證明
2. 簽章者能夠使接收者相信簽章事實上是合法的，而且一個被指定確認者可以
隨時來證明簽章的合法性。然而，接收者無法獲得一個可以轉移的證明
(Transferable proof)，意思也就是接收者無法向第三方去證明簽章是合法的且
是由簽章者所簽。
定義 3.1.5.2 確認者委任系統(Confirmer Commitments) 的實現 [MS98]
p 和q為兩個大質數且 | 1q p， qG 為 *pZ 的子集合且級數為q， :{0,1}q qh Z
為一個抵抗碰撞的雜湊函數。根據以下三個階段可以建構一個安全的確認者委任
系統(confirmer commitment)。
1. 金鑰產生： g 是一個在 qG 中隨機產生的生成子(generator)且
40
簽章架構描述如下， AU 從 Ar  *pZ 隨機選出， BU 從 Br  *pZ 隨機選出。然後
經由兩者協商之後，計算 (mod )ArAR g p 和 )(mod pgR BrB  。 BU 隨機選出
comt  *pZ ，並且建立自己的被指定確認者簽章 ' ( ) ( , )b BS m z d ，其中
( ( )|| )
1 2(( ( ) || ), , ) ( , ) ( , ) mod
com q A B comt h h m R R t
A B TTP TTPd Com h m R R g y d d g y p
    
( ) modB B Bz r H d x q  。
AU 也可以建立其自己的被指定確認者簽章
' ( ) ( , )A AS m z d ，其中
( ) modA A Az r H d x q  。由此可知，此結合的簽章 '( )S m 為 ( , )z d ，其中
(( ) ( )( )) modA B A B A Bz z z r r H d x x q     
在本篇協定的正常階段，兩方應參與協定來簽署契約。如果在簽章交換過程
中發生爭執，可信任第三方此時將加入協定，並將被指定確認者簽章轉換成自行
認證簽章。協定中兩階段(正常及爭執階段)敘述如下。
協定三：使用可轉換簽章的非洩漏公平合約簽署協定(Non-disclosure Fair
Contract Signing Protocol with the Convertible Signature)
正常階段 AU 及 BU 兩方交換他們自有的簽章，然後在過程最後階段，如果兩方
誠實的話，兩方可獲得包含簽章的認證合約。
1. 一般參數
AU 及 BU 協商出一般變數 AR 及 BR 。
2. 被指定確認者簽章之傳送
BU 傳送m 的被指定確認簽章 ' ( )BS m 以及確認者 commitment d 給 AU 。
42
給 AU 和 BU ，並且傳送 ( )BPKE z 給 BU 。最後， AU 及 BU 雙方均獲得
( )( ) '( ), ( (( ( ) || ( ) ( ) , , ))H dTTP A B TTPSig m S m CDK Com h m f z y y g y   。
3.1.5.2 實現細節
三個演算法敘述如下：
演算法 1： ( , )BDVP A d
( , )BDVP A d 可以藉由一個非交互式架構 [FOO91], [MS98]。然而，為了效率
與安全性，在此需要一個非交互式零知識證明。[Cha94] 曾提出一個證明兩個離
散對數相等的簡易方法。在此，我們描述他的非交互式零知識證明版本。知道一
個 隨 機 comt 的 證 明 者 BU ， 想 要 在 不 洩 露 出 comt 之 下 ， 向 AU 證 明
( ( )|| )
1 2log ( ) log ( )
q A B
TTP
h h m R R
g y comd g d t
    。令 ( ( )|| )1 1' (mod )q A B
h h m R Rd d g p   。
BU 隨 機 選 出
*, , qZ ， 接 著 計 算 (mod )Ag y p  、
'
1 2( || || || || || || )TTP TTPe g d y d g y
  以及 ( ) modcoms e t q    。此證明為四元
素的組合( , , ,e s )。為了要驗證這個證明， AU 先計算 (mod )Ag y p  以及檢
驗是否滿足 ' '1 2 1 2( || || || || || || )
s e s e
TTP TTPe g d y d g d y d
   
？
。
這個證明只能使 AU 相信，原因類似定義 3.1.2.2。這代表知道私鑰 Ax 的 AU 能
夠輕易的偽造一個模擬的副本。 AU 隨機選出
*, , qs Z  然後計算
qxv
qe
dydgdydgHe
pg
A
s
TTP
s
TTP
mod)(
,mod)(
),||'||||||'||||(
,mod
1
2121










44
加/解密以及證明系統。結果如表 3.1。
兩種協定均須要使用Pr ()VEDLDVoof 這個負擔相當重的證明系統。完成這個證
明需要 3+3 次模指數運算，次模加法運算及一次雜湊運算，其中約介於 140
到 160 之間。驗證證明需要 3+2 次模指數運算，2次模乘法運算以及一次雜湊
運算。在協定二中，正常階段(第一步到第四步驟)需要一次證明，爭執階段(第
五步以及第六步驟)也需要一次證明。然而，在協定三中，爭執階段只需要一次
證明。因此在實務上，由可信任第三方來解決爭議通常是較少發生的，因為大部
份的交換步驟可以正常地的完成，因此協定三可推斷出比協定二更有效率。
在協定三，可信任第三方可以傳送一個 decommitting key 來轉換確認簽章。
既然如此，在爭議階段由信任第三方所轉換的簽章與在正常階段由交換方所產生
的簽章不同，因為由可信任第三方與原始簽章者所產生的轉換是可區分的。因此
可信任第三方是否參與簽約的過程，可以直接從簽章格式被發現。這個問題在協
定二中不會出現。
46
效率。雖然本篇提出一個非交互式零知識證明來改善效率，但是這一種證明需要
許多的參數。Asokan 等人[ASW00] 提出一個在公平交換機制中的代管(escrow)
方法。如何修改我們的協定來使的他們能夠使用 escrow 方法應該是一個很有趣
的問題。
第二，多方簽約的延伸可以當是未來的研究主題。此外，我們想要設定一個
能夠抵抗兩個或多個可能共謀的交換方的協定。
3.1.8 參考文獻
[ASW00] N. Asokan, V. Shoup and M. Waidner, "Optimistic Fair Exchange of
Digital Signatures," IEEE Journal on Selected Areas in
Communications, April, 2000, pp. 593-610.
[BD99] F. Bao and R.H. Deng, "An efficient fair exchange protocol with
off-line semi-trusted third party," Proceedings of the International
Workshop on Cryptographic Techniques and E-Commerce, Hong
Kong, 1999, pp.37-47.
[BDM98] F. Bao, R.H. Deng, and W. Mao, "Efficient and practical fair exchange
protocols with off-line TTP," Proceedings of the 1998 IEEE
Symposium on Security and Privacy, Oakland(CA): IEEE Computer
press, 1998, pp. 77-85.
[BF98] C. Boyd and E. Foo, "Off-line Fair Payment Protocols Using
Convertible Signature," In Advances in Cryptology - Proceedings of
Asiacrypt’98,Lecture notes in computer science (LNCS), 1514,
Springer-Verlag, 1998, pp. 271-285.
[BGLS03] C. Boyd and E. Foo, "Off-line Fair Payment Protocols Using
Convertible Signature," In Advances in Cryptology - Proceedings of
Asiacrypt’98,Lecture notes in computer science (LNCS), 1514,
Springer-Verlag, 1998, pp. 271-285.
[Blu83] M. Blum, "How to exchange (secret) keys," ACM Transactions on
Computer and System, vol.1, no.2, pp.175-193, 1983.
[Cha94] D. Chaum. "Designated Confirmer Signatures," In Advances in
Cryptology - Proceedings of Eurocrypt’94, Lecture notes in computer
science (LNCS), 950, Springer-Verlag, 1994, pp. 86-91.
48
signature exchange protocol,” 9th IEEE Symposium on Computers and
Communications (ISCC’2004), pp.412-417, Alexandria, Egypt,
June/July 2004.
[OO94] T. Okamoto, K. Ohta, "How to simultaneously exchange secrets by
general assumptions," Proceedings of the 2nd ACM Conference on
Computer and Communications security, 1994, pp. 184-192.
[Sch89] C.P. Schnorr, "Efficient identification and signatures for smart cards,"
In Advances in Cryptology - Proceedings of Crypt’89, Lecture notes
in computer science (LNCS), 435, Springer-Verlag, 1989, pp.
239-252.
[Sta96] M. Stadler, "Publicly Verifiable Secret Sharing," In Advances in
cryptology - Proceedings of Eurocrypto’96, Lecture notes in computer
science (LNCS), 1070, Springer-Verlag, 1996, pp. 190-199.
[ZG96] J. Zhou and D. Gollmann, "A fair non-repudiation protocol,"
Proceedings of the 1996 IEEE Symposium on Security and Privacy,
Berlin: Springer, 1996, pp. 55-61.
[ZG97] J. Zhou and D. Gollmann, "An efficient non-repudiation protocol,"
Proceedings of 1997 IEEE Computer Security Foundations Workshop
(CSFW’97), IEEE CS Press, June, 1997, pp. 126-132.
50
（Confirmation signature）的替代方式去設計他們的公平交換協定；第一個可驗
證的簽章即利用由 Boneh 等人[BGL03]在 2003 年提出的雙線性配對(函數)
(Bilinear pairings)來加密。Boneh 與 Shacham 也運用了他們的聚集(aggregate)與可
驗證加密簽章方法，設計一個高效率的簽章公平交換。
我們將研究簽署者的隱私性。基於商業利益，有些敏感(sensitive)的合約必
須保密，例如在網際網路市場上，兩家公司會想有一個秘密合約，合作提高生產
以促進競爭力。而當資訊洩漏時，就會對交易造成危害。由於 TTP 介於簽署雙
方佔有重要的地位，他可以藉由解決紛爭的機會取得簽署的合約；更糟的情形是
TTP 將這些有價值的秘密賣給原本交易雙方的商業對手，並表明這些秘密是有效
的。
另一個實際的例子是網路購買。在顧客與商家經由網際網路線上交易前，他
們必須合作產生一份訂貨合約；但他們也許會害怕此購買訊息會洩漏被第三方所
知，尤其是商業上所感興趣的資訊。為了避免在合約中簽章被 TTP 所濫用，我
們採納由 Franklin 與 Reiter[FR97]所提出的半信任第三方（Semi-trusted third
party，STTP）方式設計合約簽署協定，不僅達到了安全性也達到了隱私性。一
個半信任的第三方的意思是指除了與簽署雙方共謀以外，他可以有任何不法的行
為。所以一個近似 STTP 模組且合適的策略是當 TTP 介入協定時，對 TTP 隱藏
欲交換的簽章以保證安全與公平性。
當尋找一個可以完全信任的管理機構需要花很多成本時，STTP 的概念是很
有用的；而另一個使用 STTP 的原因是假設一個可信任的管理機構能安全地抵擋
所有可能的攻擊並不合適。由於 STTP 無法取得合約中交換的簽章，所以當 STTP
有危害時，並不會危及簽署者的隱私性。不幸地，Franklin 與 Reiter 只有提出線
上式 STTP 的解決方案，而且他們的協定無法適用於交換簽章；因此我們將提出
52
平交換協定，會隠藏要交換的訊息以避免讓 STTP 知道。
一些關於雙線性配對函數和聚集簽章的定義，將會在之後介紹。在文中我們也會
簡短的說明這些觀念。讓讀者可以由這些說明得到比較深入的了解。
定義 3.2.2.2 (雙線性配對函數)
令 1G 、 2G 和 3G 是三個級數為 q 的乘法群，令 P 為 1G 中的任一個產生器
(generator)，使得 OqP ，O是 1G 中的零元素(zero element)。令Q為 2G 中的任
一個產生器(generator)。假設在 1G 、 2G 和 eG 中，解離散對數問題(DLP)是困難的，
如果一個對應函數(mapping function) 1 2: ee G G G  滿足下面的條件，則稱為雙
線性函數。
1. 雙線性(Bilineararity)：令P 屬於 1G ，Q屬於 2G ， a 和b 屬於
*
qZ 。且等式
( , ) ( , )abe aP bQ e P Q
2. Non-degeneracy：存在 P 屬於 1G ，Q屬於 2G ，但 ( , ) 1e P Q 
3. 可計算性(Computability)：對所有的P 屬於 1G 和Q屬於 2G ，存在一個有效的
演算法，可以計算 ( , )e P Q 。
定義 3.2.2.3 (聚集簽章 Aggregate signature)[BLS03]
聚集簽章有五個元素(tuple) { , , , , }keyGen Sign Verify Aggregate AggVerify ，
且允許對任意不同的訊息產生簽章。令 1G 、 2G 、 3G 、 eG 、P 、Q、 q 和 e 相同
於之前的定義。假設存在一個可計算的同型(isomorphism)從 2G 到 1G ，且
( )Q P  ，和一個赫式函數 1:{0,1}H G 。此五個演算法敍述如下：
54
2. 簽署和交換(Sign and Exchange)：如果先前傳送給 Bu 的訊息可以通過驗證，
Bu 也簽署這個合約，並且傳送 Bu 的簽章給 Au 。 Au 在得到 Bu 的簽章之後，會
檢查其正確與否，如果正確， Au 則傳送他的簽章給 Bu 。到此，合約簽署的步
驟完成。
3. 紛爭處理(Dispute-solving)：在上敍的過程中，紛爭可能已經發生。例如：雖
然 Bu 誠實的傳送其簽章給 Au ，但 Bu 卻沒有收到 Au 的簽章。為了維持公平，
將執行以下的四個步驟，並把T 的功能加入。
(a). Bu 用 Au 的公鑰來加密 Bu 的簽章，並傳送這個密文給T 。
(b). Bu 將 Au 在預先交換階段，傳送給 Bu 的訊息，再傳送給T 。
(c). T 檢查由 Bu 收到的訊息。如果檢驗正確，T 則解密 Au 的密文，並將這
個解密過的密文傳送給 Bu 。所以 Bu 可以透過T 的解密，得到 Au 的簽章。
(d). T 再傳送 Bu 在步驟(a)所產生的密文給 Au 。
部分安全的問題敍述如下：
公平性分析
由於需要證明該協定的安全性，所以必須證明，在協定的最後結果中，讓 Au
和 Bu 都得到對方的簽章，或者是 Au 和 Bu 都得不到對方的簽章。而這個分析必須
包含一個檢驗作弊的動作，以檢查是否有作弊行為的發生。我們將介紹以下的理
論，以說明可能發生的情況。
定理 3.2.2.1 這個提出的合約簽署模型可以完成公平性
詳細的證明過程，請見原始論文（第 6 章說明）。
定理 3.2.2.2這個提出的合約簽署模型可以保護簽章者的隠私。
詳細的證明過程，請見原始論文第 6 章說明）。
56
( ) ( )B T T Bx x x xA A B T A T B        獲得。
現在，我們需要證明上述解密程式是正確的。函數有以下之性質
2( ( ), ) ( ( ), ), ,e u v e v u for any u v G  
因此，解密方程式是正確的，因為
1 1
(( ) , ) ( , ) ( , ) ( , )
( , ) ( , ) ( , )
B T B Tx x x x
A B T A B T
A B B T T
e Q e Q e Q e Q
e Q e v e v
     
  
 
 
  
  
並且，經由以下推導過程，可以得到 ( , )Ae Q 為：
( , ) ( ( ) ( ) , )
( , ) ( ( ) , ) ( ( ), )
( , ) ( ( ), ) ( ( ), )
( , ) ( ( ) , ) ( ( ) , )
( , ) ( , ) ( , )
B T
B T
B T
B T
r r
A A B A T
r r
A B T
r r
A B T
r r
A B T
A B B T T
e Q e v v Q
e Q e v Q e v Q
e h v e v Q e v Q
e h v e Q v e Q v
e h v e v e v
  
  
 
 
 

  
  
  
  
於是，我們可以得到
1 1(( ) , ) ( , ) ( , ) ( , ) ( , ) ( , ) ( , )B Tx xA B T A B B T T B B T T Ae Q e h v e v e v e v e v e h v            
我們新的合約簽署協定描述如下。協定也是分為三個部分。
CSP-SP協定︰具有簽章者隱私保護的合約簽署協定
1.預先交換︰ Au 對合約M做一個雙重可驗換加密簽章，也就是 ( , , )B T A   ，並
加它送給 Bu .
2.簽章及交換︰ Bu 檢查 Au 送來的訊息。如果證實成功， Bu 將他對合約M的簽章
送給 Au ；當 Au 認可 Bu 的簽章後， Au 將他的簽章送給 Bu 。
3.紛爭解決︰在 Au 收到 Bu 的簽章之後，他可能送出一個錯誤的簽章給 Bu 以欺騙
Bu 。以下列出 Bu 如何要求T 解決紛爭
(a). Bu 將 ( , )A B B A   和 ( , , )B T A   送給T 。
58
( , )A B  TxA T 
Ax
B B A   ( )T Bx xA A T B   
(b). 紛爭解決階段
圖3.2.1：CSP-SP協定之訊息傳送流程
3.2.4 穩定性考慮
由 Franklin 和 Reiter 所提出的 STTP 架構只考慮安全性的問題而沒有促進系
統的穩定性。我們假定 STTP 不會跟簽署雙方共謀，那麼唯一的問題就是 STTP
無法去完成他該做的工作。舉例來說，STTP 可能會遭受惡意的病毒攻擊，以至
於停止服務。一般來說，我們有兩個方法可以解決這樣的問題。
1. 複製伺服器(Replication Server)：建立一個完全複製自 STTP 伺服器的伺服
器，這個複製的伺服器每隔一段時間必須跟原始的 STTP 伺服器通訊，以
更新資料。
2. 多個獨立伺服器(Multiple Individual Server)：建立兩個以上不同架構、平
台、密碼和密鑰的獨立伺服器。然而，這些伺服器必要時都可以用來解決
對簽章內容的紛爭。
我們選擇使用第二個解決方法。有兩個原因：(1)比起複製自原始伺服器的
伺服器，使用者更相信由不同組織提供的獨立伺服器。因為通常由相同實體管理
的伺服器具有相似的安全缺點。(2)由不同的組織所提供的伺服器比較可以抵擋
有意的阻斷服務攻擊。只有一兩個伺服器是”勤奮的(deligent)”以確保服務可以
持續提供服務。簽署者可以透過採納第二種策略獲得更大的保險。
60
上面方法的正確性可以被鑑定。在公開驗證的時候，下面的等式會成立。
2
1
2
1
2
1
2
1
( , ) ( ( ) , )
( , ) ( ( ) , )
( , ) ( ( ), )
( , ) ( ( ), )
( , ) ( ( ) , )
( , )
A T
T T
T T
T T
TT
x r
A
x r
A T
x r
A T
x r
A T
xr
A T
A
e Q e h SK Q
e h v e v Q
e h v e Q v
e h v e v Q
e h v e v Q
e h v
 






 
 
 
 
 
 
1 2
( , )T Te v
另一個驗證式
2 1,
( , ) ( , ) ( )A A T Te Q e h v e v   的推導類似上面過程。
在解密階段，因為等式 1 1
2 2
( / , ) ( , ) ( , )T Tx xA T A Te Q e Q e Q   
  
2 1 2 1
1( , ) ( , ) ( , ) ( , )A T T T T Ae h v e v e v e h v     和 2 21 1( / , ) ( , ) ( , )
T Tx x
A T A Te Q e Q e Q   
  
1 2 1 2
1( , ) ( , ) ( , ) ( , )A T T T T Ae h v e v e v e h v     成立，我們可以看出 1T 和 2T 可以個別解密
加密過的簽章。
這個共享可驗證加密簽章可以和第三節的 CSP-SP 協定結合來促進穩定
度。我們稱這個結合的協定為 CSP-SPR 協定。使 Au 計算 A A B T  ，這裡 T
是 1T 和 2T 間的共享可驗證加密簽章， Au 必須在預先交換階段傳送 1 2( , , , )B T T A   
給 Bu 。如果有紛爭發生， Bu 必須與 1T 和 2T 通訊以維持協定的公平性。
3.2.5 效能分析
在這個章節裡，我們將分析協定的效能。因為我們提出的概念是新的，所以
我們無法用相同的性質去與其他的方法做比較。因此，我們著重於比較與[BLS03]
62
行的。我們的方法在正常交易時只增加了很少的執行成本，而且可以保障在紛爭
發生時簽署者的隱私性。
此外，CSP-SP 和 CSP-SPR 在解決正義的協定所需要的計算量是一樣
的。簽署者 Bu 只需要傳送副本訊息給 1T 和 2T 就可以解決紛爭，而不需要多付出
額外的執行成本。
3.2.6 結語
文中提出了兩個協定來提高簽署者的隱私和內容簽署協定系統的穩定
度。我們的協定或許有輕微計算上的增加，但是選擇的 TTP 不必是完全被信任，
也不必是完全穩定的。因為被公開接受的伺服器並不能完全的避免入侵者入侵和
病毒的攻擊，所以即便所有的伺服器都被破解了，我們仍舊提供解決的方法以保
障簽署者的隱私。
如同[BLS03]，我們的協定並沒有[GJM99]所提出的避免遭受誤用的性
質。我們未來的研究計畫改進我們的協定，使得交換簽章不會受到參與者的誤用。
3.2.7 參考文獻
[ASW00] N. Asokan, V. Shoup, and M. Waidner, “Optimistic fair exchange of 
digital signature.” IEEE Journal on Selected Areas in
Communications, 18:591-610, 2000.
[BDM98] F. Bao, R. H. Deng, and W. Mao, ”Eficient and practical fair 
exchange protocols with off-line TTP,”In Proceedings of the 1998
IEEE Symposium on Security and Privacy, pages 77-85, Oakland,
CA, May 1998. IEEE Computer Press.
[Blu83] M. Blum, ”How to exchange secret keys, ”ACM Transactions on
Computer Systems, 1(2):175-193, 1983.
[BGLS03] D. Boneh, C. Gentry, B. Lynn, and H. Shacham, ”Aggregate and 
verifiably encrypted signatures from bilinear maps, ”Advances in
Cryptology - Proceedings of Eurocrypt 2003, Lecture Notes in
Computer Science (LNCS) 2656, pages 272-293.
64
4. 電子付款機制之應用
4.1 具公平交換特性之電子付款系統
4.1.1 簡介
過去的幾年裡，電子現金有很多議題被廣泛討論，例如：匿名性(Anonymiy)、
不可追溯性 (Untraceability)、不可偽造性 (Unforgeability)、不可重複使用性
(Unreuseability)、不可否認性(Non-Repudiation)…等等。儘管如此，當電子現金
系統在網路上實施時，還是存在著一些問題。舉例來說：當一個網路上的買家已
經將應付款項付給賣家，他如何確保賣家會將他已經付過款的商品寄給他；反
之，一個已經將商品傳送給買家的商家，如何確保買家會將應該支付的款項傳送
給自己。為了解決這個問題，我們在電子現金系統的付款階段中結合了一個公平
交換的協定。
電子現金系統可以分為兩種模式：線上模式和離線模式。在線上模式的架構
底下，交易階段需要電子現金的發行銀行參與，這可能是驗證電子現金的正確性
最直接的辦法，但是此模式在即時交易的效率並不理想；而在離線的模式下，賣
家可以自行驗證電子現金的正確性而不需要透過一個連線的銀行，如此對於交易
的效率是有幫助的，但是卻要適切的設計其重複花費的偵測機制。
電子現金系統最早是在 1983 年由 Chaum 所提出的[DC83]。Chaum 博士利
用盲簽章(Blind signature)來實現”匿名性”和”不可追溯性”的電子現金。在這之
後，1993 年 Brand 利用 wallet with observers 此一類似智慧卡的硬體概念實現了
電子現金的”不可追溯性”[Bra93]。在這篇論文裡面，只有被重複花費(Double
spending)的電子現金才可以被追溯其使用者為誰。2001 年，Wang 和 Zhang 使用
離散對數假定(Discrete logarithm assumption)和切斷及選擇(Cut-and-choose)的技
66
著一個位元(bit-by-bit)洩露秘密的方式來達到公平性。這樣的方式太過於沒有效
率，並且會有一個位元的不公平存在[OO94]。所以引入可信任第三方這個角色
變得必要。一種最直接的架構是利用一個線上可信任第三方，於每次欲交換資料
時加以驗證資料的正確性，但是這樣的架構有著計算上及通訊上的瓶頸
[ASW97]。為了降低成本，許多之前的學者建議使用離線的可信任第三方架構。
在此架構之下，惟有交換過程發生爭議的時候，可信任的第三方才需要介入以解
決爭議，在此可信任的第三方扮演著調解人的角色[ASW00]。
除此之外，線上公平交換系統有著一個嚴重的問題，那就是線上的可信任第
三方可以輕易的得知所有將換雙方欲交換的資訊，為了解決這個問題，有學者便
提出了半信任的第三方的架構[FR97]。
4.1.1.1 貢獻：
我們建構了一個公平的電子現金交易系統，此系統提供了交易階段雙方的公
平性。之前的公平交換協定著重於電子簽章的交換，並且會洩露使用者的身分。
在我們的架構底下，即使爭議發生了，使用者的身分依舊不會被洩漏。
在 4.1.2 節，我們將介紹幾個工具以便實現我們的協定。4.1.3 節我們提出一個公
平的電子現金的基本模型。4.1.4 節是整個協定的詳細介紹。4.1.5 節我們討論了
此架構的安全性及公平性。最後，4.1.6 節是結語的部份。
4.1.2 預備知識
4.1.2.1 離散對數假定
68
的 m 加密而來。因為 2 2 ( )C mC yM g g
  式子成立，任何人可以經由下面的式子去
驗證離散對數 1C 基於 f 等同於雙重離散對數 2
CM 基於 g 和 y。此相互作用的証明
過程如(圖 4.1.1)。
證明者 驗証者
重複做 k 次
Stadler 在他的文章中建議一個非相互作用的證明。使 *1 :{0,1} {0,1}
lH  是一
個 赫 式 方 程 式 ( ( 100)l 。 證 明 者 選 擇 'i R qe Z 並 且 計 算
( )(mod ), (mod ), 1...
ei
i
i i
e y
f gt f q t g q i l   。
接著他再計算 1 1 1( ,..., ) ( (mod '),..., (mod '))l l lR j j e q e q     ， i為
1 11 2
( || || || || || ... || || )
l ll f g f g
H M C C t t t t 的第 i 的位元。
此時，證明者傳送計算出的 R 和給驗證者，然後驗證者計算並且驗證
21 ( )
1 (mod ), ( ) , 1...
jl
i i i i
i i
j C y
f gt f C q t g M i l
     。如果是正確的，則驗證者接受
這個證明。
4.1.3 基本模型
在本節裡我們解釋公平的電子現金架構。架構裡有四個參與者：銀行/可信
任的第三方、買家、商家、可信任的認證中心，為了方便，我們分別表示成
,f gt t
{0,1}R
(mod ')j e q 

j
圖4.1.1:可驗證加密的相互作用證明
2
1
( )
( )
(mod )
if 0
if 1
j
j
j
f
y
g
C y
g
t f C q
t g
t M




 
 
驗証
'
( )
(mod )
e
R q
e
f
y
g
e
t f q
t g
 


計算
計算
計算
70
付款階段：結合一個公平交換的協定，付款階段可以確保買賣雙方不是都得
到他們想要的東西，就是都得不到他們想要的東西。
兌款階段：商家可以將他從買家那裡得到的電子現金換成真實帳戶裡頭的存
款。
下個章節將介紹詳細的協定內容。
4.1.4 提出的方法
4.1.4.1 初始化階段
假設 'q q和 和使用前文的定義，且 2 ' 1q q 。 1 2, ,g g g G 是三個級數為 q
的群 qG 的產生器。B/T 有兩個金鑰對，當 B/T 扮演銀行的角色去幫使用者簽署
電子現金時它的私密金鑰是 '' qx Z ，相對應公開金鑰是 'xh g 。當它扮演一個公
正的第三方去加密或者解密電子現金的時候，它的私密金鑰是 'qx Z ，相對應的
公開金鑰是 modxy f q 。
首先，由使用者選擇一個隨機變數 1 qu Z ，並且計算 11uI g 當作他的帳號資
料(注意： 11 2 1
ug g  )，接著使用者將 I 傳送給銀行。銀行在此計算 '2( )xz Ig 並且
傳送給使用者。
商家在此階段則須計算出它的商品公開資訊： modi
i
goods
goodsPI g p ，
1,...,i n ，n等於商家要註冊的商品數目， goods為欲販售的商品，PI 是這些商
品的公開資訊。商家將這些公開資訊、商品、還有對於商品的描述傳送給可信任
的認證中心。可信任的認證中心會驗證這些公開資訊、商品、商品描述。如果驗
72
銀行將由使用者的帳戶中扣除等值的存款以支付此電子現金。一個使用者可
以利用兌換階段中，所獲得的電子現金與先行電子現金成為付款階段中的買家。
4.1.4.3 付款階段
在正常的交易情況中，付款階段需要四個步驟。(圖 4.1.4)
2, ( )
w wa g b Ig 
w隨機產生
1 2, ,s x x隨機產生
1 2
2 1 2( ) ,
x xsA Ig B g g 計算
' sz z計算
' , ' , ' ( , , ', ', ')u v su va a g b b A c H A B z a b  計算
,u v隨機產生
'/c c u加入盲因子
' modr cx w q 簽署r
2, ( )
r c r cg h a Ig z b 驗證
' modr ru v q 去除盲因子
: , , ( ', ', ', ')coin A B z a b r電子現金
1
1 2': , , ', ', ', ( , ) ( , ' )coin A B z a b C C f r y
  先行電子現金
C B
圖4.1.3：兌換階段
c
74
在此步驟，買家將先行現金傳送給商家後，商家驗證 1A 之後計算一個赫
式值 d 包含了電子現金、商家名稱、日期/時間以及商品描述。買家則利用 d 及
兌換階段隨機產生的 1 1 2, , ,u s u u 計算出 1 2,r r ，並且傳送給商家由之驗證
1 2
1 2
r r dg g A B ，這是為了向商家證明自己是此電子現金的合法擁有者。傳送 ', 'R A
給商家驗證 ' '' ', ' ' 'c cR h a A z b  是為了向商家證明這是一個向銀行兌換的合法
電子現金。並且利用一個零知識證明證明自己知道 ', 'R A 裡面的 'r 。商家驗證通
過後傳送一個將任意長度對應到長度為 l的赫式函數 lH 給買家，買家隨機產生 l
個 ie 後計算出 l組 ,i if gt t 並且利用赫式函數 lH 計算出 , R 。最後傳送 , , ,i if gt t R 給
C M
1
1 2, , ', ', ', ( , ) ( , ' )A B z a b C C f r y
  
0
1,
( , , , / , )
iM goods
A
d H A B I date time desc


如果 計算
d
1 1 1
2 2
( ) mod
mod
r d u s x q
r ds x q
 
 
計算
計算
' '
1 2, , ' , '
r rr r R g A A 
1 2
1 2
r r dg g A B驗證
'
'
' '
' ' '
c
c
R h a
A z b


'
( )
1,...,
(mod )i
i
ei
i
i R q
e
f
y
g
i l e Z
t f q
t g
 


計算
計算
, , , for 1,...,
i if g
t t R i l 
1 11 2
1 1 1
( ' || || || || || ... || || )
( ,..., ) ( (mod '),..., (mod '))
ll
l f g f g
l l l
H R C C t t t t
R j j e q e q

 

   
計算
計算
:{0,1}* {0,1}llH 
圖4.1.5：付款階段的第一個步驟(驗證先行電子現金)
2
2
1 1
1 ( )
1 ( )
for 1,...,
(mod )
( ' )
( ' )
i i
i
ji
i i
i
ji
i i
i
j
f
C y
g
C y
g
i l
t g C q
t g R
t g A

 
 






驗證
76
做完了以上四個步驟的交易我們稱為正常的交易，對於交易的兩方都是公平
的，兩方都可以得到他們想要的東西。一旦無法成功的完成四個步驟，那麼買家
或商家可以透過下面的三個子協定解決問題。
4.1.4.3.1 取消交易
這個子協定只能夠由買家發動，如果買家傳送了先行電子現金給商家並且在
一段時間過後沒有收到來自商家的先行商品，則他可以發出一個詢問的訊息給商
家，如果商家回覆有收到此先行電子現金，那麼買家可以再等待一段時間。如果
買家仍然沒有收到來自商家的先行商品，則買家可以選擇取消此交易。
買家將 1 2, , ( ', ', ', '), , ,A B z a b z r r 日期/時間、商家名稱、商品描述等資料傳送給
銀行/可信任的第三方。在驗證過這些資料之後，銀行將這些資訊存在一個資料
庫裡面，日後商家將無法兌現這個存在取消資料庫裡面的電子現金。(圖 4.1.9)
/C B T
1 2, , ( ', ', ', '), , , , / , iM goodsA B z a b r r r I date time desc
1 2
r' ' ' '
1 2
', ' ' ( , )
_
c r c
r r d
g h a A z b sign A B
g g A B
Database C
 

經由 驗證
驗證買家擁有權
將此交易資料存在
圖 4.1.9：取消交易的子協定
C M
igoods
圖4.1.8：付款階段的第四個步驟(驗證商品)
i
i
goods
goodsPI g
驗證
78
4.1.4.4 兌現階段
當商家正常的執行完付款階段的四個步驟，或是執行了解決商家問題子協定
後，則他可以得到一個合法的電子現金，此時他可以利用兌現階段將他得到的電
子現金兌現成銀行帳號裡的存款。(圖 4.1.12)
4.1.5 安全性及公平性分析
4.1.5.1 安全性分析
不可重複使用性：如果一個電子現金被兌現了兩次，銀行將會收到兩組在付
款階段所產生的訊息： 1 2 1 2( , , ), ( ', ', ')d r r d r r ，於是銀行可以用這兩組資料計算出
1 1 2 2( ') /( ')
1 1
r r r ru g   並且計算出使用者的帳號 I 。這表示如果有一個買家重複使用了
他的電子現金，它的身分將會被銀行知道，銀行可以對他的帳戶做一些適當的處
理。
不可追溯性：這個特性是用來保護使用者，也就是買家的隱私性。經過兌換
電子現金的階段，由於使用者與銀行使用的是一個盲簽章的協定，所以經過此階
M B
1 2, , ( ', ', ', '), , , / , igoodsA B z a b r r r date time desc
1 1 2 2
1 2
( ') /( ')
1 2
( , ) _
( , ),
_
r r r r
r r d
A B Database D
g
sign A B g g A B
Database D
 
，
如果 在 裡面
用 追溯重複花費的使用者
若否 則驗證
將此金額存進商家帳戶
並將此電子現金記錄在
圖 4.1.12：兌現階段
80
在這種情況之下，買家可以得到電子商品商家可以得到電子現金。
(2) 當商家有不正常的行為：
商家可能有三種不正常的行為：
I.商家收到買家傳送的先行電子現金之後並沒有交付先行商品給買家：
買家可以透過取消交易的子協定來停止交易。如果買家在商家進行商家問題
解決子協定之前，提出取消交易子協定的要求，則是為交易取消，雙方都得不到
目的物；若是買家在商家提出解決商家問題子協定之後才提出取消的要求，則公
平的第三方在子協定最後將商品傳送給買家，並將電子現金傳送給商家。
II.商家傳送不正確的先行商品給買家：
不正確的先行電子商品無法通過一個商家對買家做的證明。此時買家可以選
擇進行取消交易的子協定，則雙方都得不到目的物。
III.商家收到電子現金後沒有傳送商品給買家：
在這種強況下，買家已經獲得一個合法的先行商品，買家可以拿此先行商品
跟相關的資料向可信任的公正第三方進行解決買家問題子協定。則雙方都可以得
到目的物。
(3) 買家有不正常的行為：.
I.買家傳送不正確的先行電子現金給商家：
錯誤的先行電子現金會導致在買家對商家做的可驗證的加密證明的協定不會
通過。在這種情況下，雙方都不可能得到目的物。
82
for e-cash systems,” ELSEVIER Applied mathematics and Computation
vol.163, no.2, 2005, pp. 869-877.
[CLX05] T. J. Ca, D. D. Lin, and R. Xue, “A randomized RSA-based partially
blind signature scheme for electronic cash,” Computer & Security
vol.24, no.1, 2005, pp.44-49.
[DC83] D. Chaum. Blind Signature Systems. In Advances in Cryptology –
Proceedings of Crypto’83, pp.153-156, 1983.
[FR97] M. K. Franklin, M. K. Reiter, “Fair Exchange with a Semi-Trusted
Third Party,” InProceedings of The Fourth ACM Conference on
Computer and Communications Security, 1997, pp.1-6.
[HT05] X. S. Hou, C. W. Tan,“A New Electronic Cash Model,”Conference on
Information Technology: Coding and Computing (ITCC04), vol.1, 2004,
pp.374-379.
[KMK03] B. G.. kim, S. J. Min, and K. J. Kim, “Fair tracing based on VSS and 
blind signature without Trustees,”International research center of
Information Security(IRIS) Computer Security Symposium(2003).
[KO03] S. J. Kim, H. K. Oh, “Eficient Anonymous Cash Using the Hash 
Chain,”IEICE, Transactions on Communications, vol.E86-B, no.3,
2003, pp. 1140-1143.
[OO91] T. Okamoto, K. Ohta, “Universal Electronic Cash,” In Advances in
Cryptology –Proceedings of Crytpo’91, Springer-Verlag, 1998, pp.
324-337.
[OO94] T. Okamoto, K. Ohta, “How to simultaneously exchange secrets by 
general assumption,” Proceedings of 2nd ACM Conference on
Computer and Communications Security, 1994, pp.184-192.
[SK04] R. Song, L. Korba, “How to make E-cash with Non-repudiation and
Anonymity,” Conference on information Technology: Coding and
Computing (ITCC’04)NRC: 46549, 2004.
[Sta96] M. Stadler, “Publicly Verifiable Secrete Sharing,”In Advances in
Cryptology –Proceedings of Eurocrypt’96, , Springer-Verlag,1996, pp.
190-199.
[TO98] T. Okamoto, “An Eficient Divisible Electronic Cash Scheme,” 
Proceedings of Crypto’95, Lecture Notes in Computer Science 963,
Springer-Verlag, 1995, pp.438-451.
[Wang03] C.H. Wang, “Untraceable Fair Network Payment Protocols with 
Off-Line TTP,” In Advances in Cryptology – Proceedings of
Asiacrypt’03, Lecture Notes in Computer Science 2894, 2003,
pp.173–187.
84
4.2 具秘密資訊保護之公平電子付款系統
4.2.1 簡介
本節使用近年來密碼學發展上的一個重要工具-雙線性函數 (Bilinear
Pairing)，提出一個電子現金架構，同時也是第一個採用雙線性函數達到具公平
性質的電子現金架構。搭配一個離線半信任的公正第三方(Off-line Semi Trusted
Third Party)，使得我們不但可以確保進行交易的雙方不會有任何一方遭受不公
平，而且交易雙方的資料將不會被半信任的公正第三方完全得知。比起使用離散
對數所實現的電子現金系統，採用雙線性函數的本架構可以將用來加密或簽章的
鑰匙長度縮短，同時只需使用較小的記憶體空間。
4.2.2 預備知識
為了實現電子現金的架構，在此，我們利用 Boneh 等人提出之簽章協定
[BGLS03]為基礎，設計一個新的盲簽章協定。在 Boneh 等人的簽章協定之簽署
過程中，我們發現可以加入一個盲因子的運算於原始訊息中，而將原始訊息盲
化。此新的盲簽章之形式相同於 Boneh 等人的簽章，故我們的盲簽章可衍伸為
可驗證加密盲簽章。
在我們的盲簽章協定中，請求者隨機選擇一個盲因子，藉由盲因子將原始
訊息打亂，再傳送給簽章者。當請求者接收到簽章者傳送過來的簽章後，他再將
簽章中的盲因子去除，而得到一個簽章者對原始訊息所做的簽章。但是，簽章者
無法得知最後的簽章與他所簽的訊息之間的關聯。接著，將詳細地介紹我們的盲
簽章協定。我們的盲簽章協定由四個演算法組成，包括了 Setup、Extraction、
BSGeneration 以及 Verification。
Setup: 鑰匙產生中心(TKGC) 選擇三個群 G1、G2,及 Ge，這三個群的秩(order)都
86
Verification: 接收者只有在 2( , ) ( , )se g e h v  ，在此 ( )h H m ，成立的時候，才
會接受簽章是正確的。
現在我們看看盲簽章架構的正確性。
因為
1
1
1
1
1 2
1 2
1 2
( )
( ) ( )
( ) ( )
( ) ( )
s
s s
s s
s s s
s
r
s
xr r
s
x x rr
x x rr
x x x rr
x
v
g h v
g h g
g h g
g h g
h
 








 
  
  
  
  

所以， 2 2 2( , ) ( , ) ( , ) ( , )s s
x x
se g e h g e h g e h v    。
在底下的部份，我們將稱上面的方法為基本盲簽章。
4.2.2.3 基本盲簽章的變形
我們將把基本盲簽章做一個變形，將之變化成一個可驗證加密盲簽章。我
們知道一個可驗證的加密技術可以達到公平簽章交換的目的。這個新的可驗證加
密盲簽章可以幫助我們實現電子現金架構，下面我們將會介紹它。
可驗證加密盲簽章
在我們的可驗證加密盲簽章架構裡有三個參與者：請求者、接收者和一個
第三方，請求者和接受者的鑰匙對分別為(xr,vr) 和 (xt,vt)。
可驗證加密盲簽章的產生：假設請求者擁有簽章者所簽署，對於訊息 m 產生的
盲簽章。請求者將做下列動作：
(1) 隨機選擇一個 pu Z

88
4.2.3.1 系統模型:
我們的 E-cash 系統包含了四個角色，管理者(trustee)、顧客(customer)、銀
行(bank)以及商家(merchant)，及八個主函數，系統初始化(Initialization)、開戶
(Opening)、使用者註冊(User Registration)、商品註冊(Goods Registration)、提款
(Withdrawal)、付款(Payment)、請款(Deposit)與追蹤(Tracing)。各主函數之運作流
程描述如下。
系統初始化: 每個參與的角色從 Zp*隨機選擇 xi，並計算 2 i
x
iv g 。則其私密鑰匙
與公開鑰匙對為(xi,vi)。
開戶: 顧客通過身分認證後，銀行為顧客開一個帳戶 accu。
使用者註冊: 在這個階段中，顧客向管理者註冊他的假名公鑰。
(1) 顧客隨機選擇 ps px Z
 ，計算 2 2ps
x
psQ g G  ，並對他的身分資訊 idu與假名
公鑰 psQ 做簽章，簽章方式為 1 1( || ) c
x
u u psH id Q G   ，其中 H1 是一個單向
雜湊函、xc 是顧客的私密鑰匙。 隨後，顧個透過安全通道將 ( , , )u u psid Q 傳
送給管理者。
(2) 管理者利用檢查等式 2 1( , ) ( ( || ), )u u ps ue g e H id Q v  是否成立以驗證 u的正確
性。假如 u是正確的，則管理者對 psQ 做簽章，形式為 1 1( ) txt psH Q G  ，
並將 t傳送給顧客。
90
圖 4.2.3: 商品註冊流程圖
(3) 商家檢查此簽章是否確實為管理者對該項商品之簽章。首先，商家計算
2( ( ), )e goods g  與 2 ( , )desH goods  ， 再 利 用 驗 證 等 式
2( , ) ( , )goods te g e v  是否成立以檢查 goods 之正確性。
商品註冊階段的訊息交換流程如圖 4.2.3 所示。
提款: 在這個階段中，銀行對顧客的錢做盲簽章。
(1) 顧客產生錢幣 c，其中 c 包含了錢幣面額與一個隨機亂數。顧客隨機選擇
pu Z
 ，計算 1 1( || )psH c Q G  ，並且將盲化為 1 1' ug G   。之後，
顧客經由安全通道將 '傳送給銀行。
商家 管理者
2
2
2
( )
( ( ), )
( , )
( , ) ( , )
mx
des
goods t
goods
compute
e goods g
H goods
verify
e g e v
 
 
 
 




, ,desgoods goods 
2
2
2 1
1
( , ) ( ( ), )
( ( ), )
( , )
t
m
T
des
x
goods
verify
e g e goods v
if correct
e goods g G
H goods G
G
 
 
 
 

 
 
 goods
92
(a) 顧客隨機選擇 pv Z
 ，並計算 2 1( )vg G   及 1( )vum bv G   ，其
中 bv 是銀行的公開鑰匙。其後，顧客將可驗證加密錢幣設定為
1u b um G   。
(b) 顧客對訊息 msg 做簽章，式形為 1 1( || || || )
psx
c m psH c id msg Q G   ，並
將 ( , , , , , )ps t u cc Q    傳送給商家。
(3) 商家檢查等式 2 1( , ) ( ( ), )t ps te g e H Q v  、 2 1( , ) ( ( || ) , )u ps be g e H c Q v   與
2( , )ce g  1( ( || || || ), )m ps pse H c id msg Q Q 是否成立，來驗證 ,t u 與 c的正確
性。假如， ,t u  與 c都是正確無誤，商家將 , ( )goods goods  傳送給顧客。
(4) 顧客收到商品後，計算 2 2( ( ( ), ), )desH e goods g goods  ，並利用驗證等式
2( , ) ( , )goods te g e v  是否成立以檢查 goods 之正確性，若是正確，再計算
1( ( ))goods goods  以取得商品，並將 b傳送給商家。
(5) 商家再檢查 b的正確性。
下圖是付款(正常)階段的訊息流程圖。
在這樣的交易過程中，可能會發生不法行為。第一種情況是步驟(4)中，商
家並未收到顧客傳送的 b，或是即使商家收到 b，但是 b並不正確。第二種情
況是商家於步驟(2)收到 ( , , , , , )ps t u cc Q    之後，直接要求銀行解出 b而不將商
品傳送給顧客。這些情況我們都可利用下一個程序來解決。
94
驗證 , , ,t goods mc u   與 c的正確性。假如 , , ,t goods mc u   與 c都正確，則
銀行計算分別將 ( , )mc c  與 / bxu b  傳送給顧客與商家。
(3) 顧客收到 ( , )mc c  之後，計算 1( )cxmc c   以取得商品。
(4) 商家計算 ( )b mx xu b m   以取得 b。
這個階段結束之後，顧客與商家分別取得他們所需要的商品與錢幣。下圖
呈現付款(發生爭議)的訊息交換流程。
在付款(發生爭議)階段，仲裁者的角色也可以由系統管理者(trustee)來擔
任。若是由系統管理者來擔任的話， ( )vum bv  需改成 ' ( )vum tv  ，並且 u的
驗證式也需更改為 2( , ) ( ( || ), ) ( , )u ps b te g e H c Q v e v   。如此一來，付款(正常)與
付款(發生爭議)階段中之雙線性函數的運算次數均會增加。
請款: 商家將 ( , , , , , )ps t b cc Q   傳送給銀行，銀行確認資料正確無誤後，將錢
存進商家的帳戶中。
(1)商家將 ( , , , , , )ps t b cc Q   傳送給銀行。
(2) 銀 行 檢 查 等 式 2 1( , ) ( ( ), )t ps te g e H Q v  、 2 1( , ) ( ( || ), )b ps be g e H c Q v  與
2 1( , ) ( ( || || || ), )c m ps pse g e H c id msg Q Q  是否成立來驗證 ,t b與 c的正確
性。假如 ,t b 與 c都是正確的，接著銀行檢查是否 c與 psQ 已在資料庫中，
若是，則銀行找出相對應的 'c ，並將它傳送給商家。
96
集成單一的簽章。為了方便管理，銀行可以聚集來自同一商家之錢幣。利用聚
集盲簽章的方式，我們可以有效率的使用銀行的資料庫。
追蹤: 如果銀行發行某位顧客使用兩次錢幣，則銀行與管理者合作找出該位顧客
之身分資料，並將之列入黑名單中。
(1) 銀行找出該錢幣的兩次交易記錄 ( , , , , , )ps m t b cc Q id   與
( , , , , , ')ps m t b cc Q id   ，並將它們傳送給管理者。
(2) 管理者檢查這些資料的正確性，從資料庫中找出該顧客的 ,ps uQ id 與 u，並
將 , ,ps U cQ id 傳送給銀行
(3) 銀行將該顧客的身分資料加入黑名單中。
4.2.4 效能分析
在表 4.1 中，我們分析電子現金系統中所需的計算成本。
表 4.1: 參與者在電子現金系統中所需之計算成本.
付款階段
兌款階段
正常狀況 爭議狀況
顧客
1 iso
1 hash
2 exp(G1)
2 mul(G1)
1 inv(G1)
2 iso
1 invfuc
2 hash
5 exp(G1)
2 mul(G1)
3 po
1 invfuc
銀行 1 exp(G1) －
4 hash
1 exp(G1)
98
假如顧客將他的錢幣用了兩次，銀行與管理者可以合作找出該顧客的身分
資訊，並且銀行會將此顧客加入黑名單中。
不可追蹤(Untraceable)
在 withdrawal 階段中，銀行用盲簽章的方式簽顧客的錢，銀行無法知道他
所簽的訊息與最後簽章間的關聯。故提領後的錢是不會被追蹤的。
不可偷竊(Unstealable)
假如顧客的錢 ( , , , )b t psc Q  被偷了，竊賊無法使用這筆錢。在付費(payment)
過程中，雖然竊賊可以計算出 , um 與 b，但是竊賊無法簽署一個正確的 c，
這是因為竊賊並不知道錢的擁有者的私密鑰匙 psx 。假使竊賊使用他的公開鑰匙
Qps’ 替換錢幣擁有者的公開鑰匙 Qps ，其中，對應於 Qps’的私密鑰匙是 xps’，他
可以用他的私密鑰匙 xps’簽署一個正確的 'c，並將 ( , ', ', , ', ')ps t u cc Q    傳送給
商家。但是，當商家驗證 , 't u  與 'c 時，商家會發現 'u 並不正確，因為 b是
由銀行對 || psc Q 做的簽章、而不是對 || 'psc Q 做簽章，故 'u 無法通過驗證式
2( ', ) ( ( || ) , )u ps be g e H c Q v   的檢驗。所以，即使提領的錢被竊了，竊賊也無法
花用它。
4.2.6 參考文獻
[ASW00] N. Asokan, V. Shoup, and M. Waidner, "Optimistic fair exchange of
digital signature," IEEE Journal on Selected Areas in
Communications, vol. 18, pp. 591-610, 2000.
[Blu83] M. Blum, "How to exchange (secret) keys," ACM Transactions on
Computer System, vol. 1, no. 2, pp. 175-193, 1983.
[BDM98] F. Bao, R. H. Deng, and W. Mao, "Efficient and practical fair
exchange protocols with off-line TTP," 1998 IEEE Symposium on
100
[ZG96] J. Zhou and D. Gollmann, "A fair non-repudiation protocol," In
Proceedings of the 1996 IEEE Symposium on Security and Privacy,
IEEE Computer Press, 1996, pp. 55-61.
[ZG97] J. Zhou and D. Gollmann, "An efficient non-repudiation protocol," In
Proceedings of the 1997 IEEE Computer Security Foundations
Workshop (CSFW 10), 1997, pp. 126-132.
102
a. 產生大的數值
由於簽章演算法需要用到極大的整數與餘數運算，換言之；即需要處理比一
般程式語言資料型別中比 Long．MAX_VALUE 更大的整數，或是比 Double．
MAX_VALUE 更大的浮點數值。
解決的方式則是引用 java．Math 套件中可以代表任意精確度整數的
BigInteger class，此 class 可以滿足實作數位簽章程式中，需要處理大數
值的需求，建構子如下︰
Public BigInteger ( int bitLength，Random rnd )
bitLength︰代表所需數值的位元長度。
rnd︰此建構子會用給定的 Random 物件來隨機產生數值。
b. 產生質數
在產生質數方面，BigInteger class 提供了符合此需求的建構子。
Public BigInteger ( int bitLength，int certainty，Random rnd )
bitLength︰代表數值的位元長度。
Certainty︰此參數決定產生的數值是質數的機率。
rnd︰此建構子會用給定的 Random 物件來隨機產生數值。
假設 Certainty的值為 n，則 BigInteger class 產生的數值為質數的
機率為（1 - 1/2n），若此 n值為 16，則機率為 0.9999847412109375。
c. 判斷質數
在判斷一存在的數值是否為質數，BigInteger class 有此 Method。
Public boolean isProbablePrime (int certainty)
Certainty︰若判斷的結果所 return 的 Boolean 值為 true，則判斷為正確的
104
上面執行的程式，並且可以提供我們其執行結果。(圖 5.1)
圖 5.1 Nokia 6.0 SDK 開發軟體
因為硬體的關係，個人數位助理(personal digital assistant)的硬體資源
不若個人電腦(personal computer)的多，不論是在處理速度與記憶體大小及硬
碟空間上，前者都遠不如後者。所以，在攥寫程式與軟體上，有其需要注意的地
方，例如：在 Nokia 9210c 上面，可供程式執行使用的記憶體僅為 8.0mb，且在
Nokia 手機 pda 上面支援的 Pjava 並不支援所有 java 程式的 class 功能，事實
上，Pjava 只支援 java 語言到 1.1 版之前的所有 class。
PJEE(Personal Java Emulation Environment)是 java 語言在一種較小型數
位產品上執行 java 程式的執行環境(java runtime environment，JRE)，當我們
在數位產品上安裝了 PJEE 之後，我們就可以利用 PJEE 來執行 java 語言程式。
當我們利用超過 java 1.1 版的 java 軟體開發環境(java development kit，
JDK)攥寫 java 語言程式之後，如果想要在其在只支援 Pjava 的硬體上面執行，
則我們需要再編譯(compiler)時，於指定的路徑後面宣告其使用的函式庫路徑及
想要編譯成的版本，例如：
C:\...>javac –classpath D:/pjee1.1\lib\classes.zip –target 1.1
Main.java
此外，我們可以將寫好的 java 程式包裝成.jar 檔，使得我們的目標程式變
106
生 512bit 的 q’，並且由之產生 q=2q’+1，p=2q’+1，利用 q’、q及 p找出 f、
g、g1 及 g2 四個產生器(generator)。在系統中這些參數可以公佈給各個參與者
並且重複使用，故我們將產生的參數儲存起來(圖 5.4)
圖 5.4 產生相關參數
利用上面這些參數及協定中的數學原理，我們可以計算出三方的金鑰對如
下：(圖 5.5)
使用者金鑰對： 11 1( , )
uu I g
銀行金鑰對： '( ', )xx h g
可信任第三方金鑰對： ( , )xx y f
圖 5.5 產生參與者金鑰對
108
5.8)(圖 5.9)
值得一提的是，在 Pjava 中並不提供訊息摘要的函式庫，所以再此我們需要
自行攥寫一個訊息摘要的函式庫供 client 端使用，而這個函式庫相當於我們在
server 端(銀行及商家)使用的 SHA-1 訊息摘要函式庫，是一個輸出為 160 bits
的訊息摘要。於 server 端則可以直接只用 java 所提供的 SHA-1 函式庫。
圖 5.8 產生電子現金
圖 5.9 產生先行電子現金
5.3.3 交易階段(付款階段)
首先，我們得產生一些交易時需要的參數，例如：商家的名稱、交易時間、
以及商品的描述等等。(圖 5.10)
110
圖 5.12 驗證結果
5.4 實驗數據
表 5.1 ：系統使用環境
系統使用環境
硬體週邊
 中央處理器︰Pentium(R) 4 3.2 GHz
 記憶體︰1024 MB
 硬碟︰80 GB
使用軟體︰
 作業系統︰Windows 2000/XP
 Nokia Symbian 6.0 SDK
 Java 2 Platform, Standard Edition version 1.4.2
在初始化階段，由於找到符合我們設定條件的大整數可能需要花費很多時間
(多至數小時)，所以我們將這些可固定的系統參數都儲存起來，重複使用。如此，
在初始化階段跟兌款階段所需花費的時間就相當的短。在 pc 上面執行完前面兩
個階段大概只需花費一秒左右的時間，所以我們將重點放在交易階段的效率。
在 client(買家)端，如表 5.2 所示，如果我們做一個証明一百次(安全度為
2100-1/2100)的可驗證加密的証明，那麼由 Nokia 9210c 來執行需要 9點多秒。
112
6.結論與計畫成果評估
本計畫執行完成，歷經兩年的時間。完成的成果包括理論推導分析、應用協
定開發以及程式撰寫等。整體而言，已達成了大部分計畫所欲達成的目標，並有
多篇論文刊登於國內外重要期刊及會議上。其主要的部分包括：
1. （基礎）具秘密保護之秘密公平交換協定
描述於計畫書第 2 章，計畫內容並已投稿，刊登情形如下：
(2006) C. H. Wang, C. H. Yin and C. H. Juan. How to Protect Exchanged
Secrets in the Fair Exchange Protocol with Off-line TTP. Computers &
Electrical Engineering, vol. 32, issue 5, pages 364-375, 2006. (accepted in
January 2006) (SCI Expanded)
2. （基礎）具秘密保護之合約簽署協定
描述於計畫書第 3 章，計畫內容並已投稿，刊登情形如下：
(2006) C. H. Wang and C. H. Yin. Practical Implementations of a
Non-disclosure Fair Contract Signing Protocol. IEICE Transactions on
Fundamentals of Electronics, Communications and Computer Sciences, vol.
E89-A, no. 1, pages 297-309, January 2006. (SCI Expanded)
(2005) C. H. Wang and Y. S. Kuo. An Efficient Contract Signing Protocol
Using the Aggregate Signature Scheme to Protect Signers' Privacy and
Promote Reliability. ACM SIGOPS Operating Systems Review, vol. 39,
issue 4, pages 66-79, Oct. 2005. (EI)
3. （應用）具公平交換特性之電子付款機制
描述於計畫書第 4 章，計畫內容並已投稿，刊登情形如下：
(2006) C. H. Wang and W. M. Chiang. A Novel E-cash System with
Fairness Property. The 16th Information Security Conference (ISC 2006),
Feng Chia University, Taichung, Taiwan, pages 394-403, June 8-9, 2006.
另有部分成果在學生之碩士論文中，亦準備整理投稿。
郭晏陞，植基於雙線性函數之多人簽章與聚集簽章及其在電子商務應
用應用之研究，嘉義大學資訊工程系碩士論文，2006 年 7 月。
114
附錄：實作程式列表（部分）
package com.symbian.devnet.crystal.cbademo;
import java.util.*;
import java.math.*;
import java.security.*;
import java.lang.*;
import com.symbian.devnet.crystal.awt.*;
import com.symbian.epoc.awt.*;
import java.awt.*;
class CBADemo extends CFrame implements CBAListener
{
private CBAHandler cba;
final static int SHOW_POPUP_BUTTON = EikCommandButtonGroup.BUTTON1;
final static int TOGGLE_CLOSE_BUTTON = EikCommandButtonGroup.BUTTON2;
final static int CYCLE_DEFAULT_BUTTON = EikCommandButtonGroup.BUTTON3;
final static int CLOSE_BUTTON = EikCommandButtonGroup.BUTTON4;
private PopUp popUp;
public static void main( String args[] )
{
new CBADemo();
}
TextArea ta; // = new TextArea("text_area");
public void my_println(int i){
ta.append( Integer.toString(i) + "\n");
}
public void my_print(int i){
ta.append( Integer.toString(i) );
}
public void my_println(){
116
popUp = new PopUp( this );
}
class my_SHA_emu{
BigInteger my_now;
final BigInteger my_base = new BigInteger(
"12991456640317524289180029919811805674528676263218938822343284321826415630451
5728120446452643279");
final BigInteger my_mod = new BigInteger(
"12991456640317524289180029919811805674528676263218938822343284321826415630451
572812044645264327921278028026855085221012656556560222939089953386539599977103");
my_SHA_emu(){
my_now = my_base.pow(1); //this is reset
}
void update(byte[] bytes){
BigInteger input = new BigInteger(bytes);
my_now = my_now.modPow(input,this.my_mod);
}
byte[] digest(){
byte [] my_return = new byte[20];
byte [] my_ByteArray;
my_ByteArray = this.my_now.toByteArray();
for (int i = 0; i<20; i++){
my_return[i]=my_ByteArray[i];
}
my_now = my_base.pow(1); //this is reset
118
my_println("p = " +p);
my_println();
BigInteger f = new BigInteger
("101424471836521677594586972940577845136850378220977188264826917250639932850216315
79643778950877009607622165100680711178252348678485124465229377400066352205");
my_println("f = " +f);
my_println();
BigInteger g = new BigInteger
("162816335926731878649983663513337881405236159205588406798908874242350903611139324
56020430220773650800337894374075284072033778298076765819247254255812997693");
my_println("g = " +g);
my_println();
BigInteger g1 = new BigInteger
("287654212281574872254628063419407180188719219804182681250691220333302684872797369
1184833961832726230307495391850099887047389590887369353139908492307993135");
my_println("g1 = " +g1);
my_println();
BigInteger g2 = new BigInteger
("126542045587061776535625224674429570130819276269512732934356584711470975343528969
76437847762149292431996698234855889568852794832913972697041258655734898163");
my_println("g2 = " +g2);
my_println();
int q_pl_bitLength = q_pl.bitLength();
int q_bitLength = q.bitLength();
int p_bitLength = p.bitLength();
my_println(q_pl_bitLength);
int certainty = 100;
120
my_println();
my_println();
my_println("=========================Withdrawal
Phase============================");
my_println("============================Bank computing a,b:");
BigInteger w = new BigInteger(q_bitLength , new Random());
BigInteger a = BigInteger.ONE;
BigInteger b = BigInteger.ONE;
a = g.modPow(w,p);
b = I.multiply(g2).modPow(w,p);
my_println("Bank random w = "+w+ " (private)");
my_println("Bank compute a =g^w = "+a);
my_println(" b =(Ig2)^w = "+b);
my_println();
my_println("============================Customer computing A,B,z':");
BigInteger s = new BigInteger(q_bitLength , new Random());
BigInteger x1 = new BigInteger(q_bitLength , new Random());
BigInteger x2 = new BigInteger(q_bitLength , new Random());
BigInteger A =BigInteger.ONE;
BigInteger B =BigInteger.ONE;
BigInteger z_pl =BigInteger.ONE;
A = I.multiply(g2).modPow(s,p);
B = ((g1.modPow(x1,p)).multiply(g2.modPow(x2,p))).mod(p);
z_pl = z.modPow(s,p);
my_println("Customer random s = "+s+ " (private)");
my_println(" x1 = "+x1+ " (private)");
my_println(" x2 = "+x2+ " (private)");
my_println();
my_println("Customer compute A = (Ig2)^s = "+A);
my_println(" B = g1^x1*g2^x2 = "+B);
my_println(" z'= z^s = "+z_pl);
my_println("============================Customer computing a',b',c',c:");
122
my_println("Digest byte count = "+hash_message.length);
my_println(" c = c'/u = "+c);
my_println();
my_println("============================Bank computing r:");
BigInteger r = (c.multiply(x_pl).add(w)).mod(q);
my_println("Bank compute r = "+r);
my_println();
my_println("============================Customer verifing...");
my_println(" g^r=h^c*a:");
// verify g^r=h^c*a
BigInteger gr = g.modPow(r,p);
my_println(" g^r = "+gr);
BigInteger hca = ((h.modPow(c,p)).multiply(a)).mod(p);
my_println(" h^c*a = "+hca);
my_println();
my_println(" (Ig2)^r=z^c*b:");
// verify (Ig2)^r=z^c*b
BigInteger Ig2r = I.multiply(g2).modPow(r,p);
my_println(" (Ig2)^r = "+Ig2r);
BigInteger zcb = z.modPow(c,p).multiply(b).mod(p);
my_println(" z^c*b = "+zcb);
my_println();
my_println("============================Customer compute r':");
BigInteger r_pl = (r.multiply(u).add(v)).mod(q);
my_println("Customer compute r' = "+r_pl);
my_println();
my_println("============================Customer compute coin:");
my_println("coin = A,B,(z',a',b',r')");
my_println(" A = "+A);
my_println(" B = "+B);
my_println(" z' = "+z_pl);
my_println(" a' = "+a_pl);
124
byte[] IM_array = IM.toByteArray();
byte[] date_time_array = date_time.toByteArray();
byte[] desc_goods_array = desc_goods.toByteArray();
//MessageDigest hash0 = MessageDigest.getInstance("SHA");
my_SHA_emu hash0 = new my_SHA_emu();
hash0.update(A_array);
hash0.update(B_array);
hash0.update(IM_array);
hash0.update(date_time_array);
hash0.update(desc_goods_array);
byte[] hash0_message = hash0.digest();
d = new BigInteger(hash0_message);
my_println("assume that:");
my_println("IM = "+IM);
my_println("date/time = "+date_time);
my_println("desc_goods = "+desc_goods);
my_println("then...");
my_println(" d = H0(A,B,IM,date/time,desc_goods)");
my_println(" = "+d);
my_println();
my_println("============================Customer compute r1,r2,R',A':");
BigInteger d_p = d.mod(q);
BigInteger r1 = (d_p.multiply(u1.multiply(s)).add(x1)).mod(q);
BigInteger r2 = (d_p.multiply(s).add(x2)).mod(q);
BigInteger R_pl = g.modPow(r_pl,p);
BigInteger A_pl = A.modPow(r_pl,p);
BigInteger c_p = c.multiply(u).mod(q);
//my_println(c_p);
126
BigInteger e = new BigInteger(q_pl_bitLength,new Random());
//random e belongs Zq_pl
BigInteger tf = f.modPow(e,q);
BigInteger tg = g.modPow(y.modPow(e,q),p);
//computes tf, tg
BigInteger beta = new BigInteger(1,new Random());
//random beta belongs {0,1}
BigInteger j = (e.subtract(beta.multiply(alpha))).mod(q_pl);
my_println(" e = "+e );
my_println(" tf = "+tf );
my_println(" tg = "+tg );
my_println(" beta = "+beta );
my_println(" j = "+j );
my_println("============================Merchant verifing...");
BigInteger fjC1beta = (f.modPow(j,q).multiply(C1.modPow(beta,q))).mod(q);
BigInteger gyj = g.modPow(y.modPow(j,q),p);
BigInteger R_plC2yj = R_pl.modPow(C2.multiply(y.modPow(j,q)),p);
//verify tf=f^j*C1^beta
my_println(" tf = f^j*C1^beta");
my_println(" tf = "+tf );
my_println(" f^j*C1^beta = "+fjC1beta );
my_println();
//verify (tg=g^y^j when beta=0) or (tg=R'^C2*y^j when beta=1)
my_println(" tg = g^y^j if beta=0 or tg = R'^C2*y^j if beta=1");
my_println(" tg = "+tg );
my_println(" g^y^j = "+gyj+" (beta=0)");
my_println(" R'^C2*y^j = "+R_plC2yj+" (beta=1)");
128
//non iterative
//long long3 = System.nanoTime();
my_println("//non iterative");
BigInteger e_array[] = new BigInteger[160];
for (i = 0; i<160; i++){
e_array[i] = new BigInteger(q_pl_bitLength, new Random());
}//for
BigInteger tf_array[] = new BigInteger[160];
BigInteger tg_array[] = new BigInteger[160];
for (i=0; i<160; i++){
tf_array[i] = f.modPow(e_array[i],q);
tg_array[i] = g.modPow(y.modPow(e_array[i],q),p);
}//for
//MessageDigest H = MessageDigest.getInstance("SHA");
my_SHA_emu H = new my_SHA_emu();
//H.reset();
byte beta_array[];
H.update(R_pl.toByteArray());
H.update(A_pl.toByteArray());
H.update(C1.toByteArray());
H.update(C2.toByteArray());
for (i = 0; i<160; i++){
H.update(tf_array[i].toByteArray());
H.update(tg_array[i].toByteArray());
}//for
beta_array = H.digest();
// my_println("beta_array = H.digest(e_array[0]);");
// my_println(beta_array.length);
130
proof = false;
break;
}//if
if (!( ( beta.equals(ZERO) && tg.equals(gyj) )
|| ( beta.equals(ONE) && tg.equals(R_plC2yj) )
)
){
proof = false;
break;
}//if
}//for loop
//long long4 = System.nanoTime();
my_println("non_iterative proof");
my_println(" proof = "+proof);
// my_println("time needed in payment phase (non_iterative)= " +(long4-long3)*0.000000001+
" seconds");
// my_println("time needed in payment phase (brand's)= " +(endpay-startpay)*0.000000001+ "
seconds");
}//main
public void cbaActionPerformed( CBAEvent e ) throws NoSuchAlgorithmException
{
switch ( e.getID() )
{
case SHOW_POPUP_BUTTON:
//this.my_print("123");
//this.my_println("999");
ta.setColumns(1024);
ta.setRows(1024);
this.my_cls();
this.test_coin();
132
default:
cba.setDefaultButton( SHOW_POPUP_BUTTON );
}
break;
case CLOSE_BUTTON:
shutDown();
break;
}
}
} // This is the end of the CBADemo class
class PopUp extends Dialog implements CBAListener
{
final int WIDTH = 300;
final int HEIGHT = 100;
private CBAHandler cba;
final static int CLOSE_BUTTON = EikCommandButtonGroup.BUTTON4;
PopUp( Frame parent )
{
super( parent , "Run" , false );
setSize( WIDTH, HEIGHT );
cba = new CBAHandler( this );
cba.setCloseText();
}
public void cbaActionPerformed( CBAEvent e )
{
switch ( e.getID() )
{
