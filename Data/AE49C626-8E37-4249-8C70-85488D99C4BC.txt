中英文摘要：（低耗電 low power、非同步電路 asynchronous circuit、8051 微控制器 8051
microcontroller、Balsa 語言、FPGA）
近來可攜式裝置的使用越來越普遍，因此低耗電的設計成為重要的目標，由於資料驅動的
特性使得非同步電路適用於低耗電設計，我們會提出一個新的非同步 8051 微控制器的解碼
器設計，這是由於 8051 是最普遍使用的解碼器之一，而且往往在其應用上低耗電特性是相
當重要的。
在本論文中電路設計使用Balsa語言，一種以CSP (Communication Sequential Process)
為基礎的非同步電路硬體描述語言並且可以合成非同步電路，由 Balsa 可以合成適用於
Xilinx 合成器的 Verilog netlist，我們可以比較非同步與同步電路在 Xilinx FPGA 上的
表現或使用其它 CAD 工具來實現晶片設計。
Recently mobile devices have been popularly used, and low power is becoming an import
subject. With the data-driven feature, the asynchronous circuit is suited to be used for low-power
design. We will propose a new decoder design of the asynchronous 8051 microcontroller because
the 8051 is one of the most popular microcontroller and is often used in applications where low
energy consumption is important.
The circuit is a complied VLSI-program, using Balsa as VLSI-programming language
which is a CSP-based asynchronous hardware description language and synthesis tool. A Verilog
netlist for XST (XILINX Synthesis Tool) is generated by Balsa. We will compare asynchronous
8051 and synchronous 8051 in XILINX FPGA and then use Cadence tools and Synopsys tools to
synthesis the layout of the circuit.
報告內容：
Research in asynchronous circuit design can be traced back to the mid 1950s, however,
because of testability and easy to design issues, synchronous design becomes the major
technology of digital circuit design. However, in the late 1990s projects in academia and industry
demonstrated that it is possible to design asynchronous circuits which exhibit significant benefits
in nontrivial real-life examples, and therefore commercialization of the technology began to take
place.
We hope to design a new decoder with low power and high performance features, and thus
the asynchronous design technology is the one we chose for this purpose.
The architecture of the pipelined asynchronous 8051
The architecture of asynchronous pipelined 8051 is show in figure 1
action signal is read, it returns the target byte according to the address. If the action signal is write,
it fetches 32 byte data which start from the address.
Fetcher ctrl controls all the buffers. It fetches the value of the program counter first. Then it
checks if the target byte exists in one of the buffers. If there is a buffer which has the byte,
Fetcher ctrl sends a read request and the address to the buffer and then passes the target byte to
the ID stage. If the target byte is the last byte of the buffer, fetcher ctrl will send a write request to
the buffer. However, if no buffer has the target byte, fetcher ctrl will flush all the buffers.
The ID stage is divided into ID1 and ID2 two stages. In the ID1, it fetches the first byte of
an instruction, decodes this instruction, determine the remained bytes, abstract the opcode, and
generate the control signal of this instruction. In the ID2, it would fetch remained bytes and
provide completed control signals for the OF stage. If the current instruction is a branch
instruction, the ID2 stage would calculate the target address and handle the branch action.
When ID1 receives the instruction byte, it would determine that this instruction is regular or
non-regular. This could decrease the size of the multiplexer. Then, according to the instruction,
ID1 generates the signals needed by the following stages such as the remained bytes, the opcode,
the read signal, and the write signal. In order to decrease the area cost, we use the shared
procedure in Balsa, which would construct only one component whatever times this procedure is
called.
In the ID2 stage, it will fetch the remained bytes first. To avoid the race condition between
the ID1 stage and ID2 stage, we use the “handshake enclosure”description in Balsa to promise
that ID2 fetches the remained bytes before ID1 fetches a new instruction.
After fetches all remained bytes, ID2 would transform these bytes into suitable operands and
pass all signals to the OF stage. If the instruction is a branch instruction, ID2 would calculate the
target address and change the PC value if the branch is taken.
We had already implemented an asynchronous pipelined 8051 with Balsa. The Balsa
program was compiled into a handshake component netlist, and finally this netlist was converted
to a verilog gate-level netlist for Xilinx FPGA. With the gate-level netlist, we used other CAD
tool to implement this circuit and do some simulation.
Because we wanted to implement the circuit in Xilinx FPGA, first we got the gate-level
netlist by Balsa. Second, we imported this netlist into Xilinx ISE, a CAD tool for Xilinx FPGA.
Then we added "keep hierarchy" description for each handshake component to avoid the
optimization of CAD tool because the optimization will break the timing constraint. Finally we
followed the standard design flow of the Xilinx FPGA, and burned the design into FPGA. All the
flow is shown in Figure 2.
[6] Martin, A.J.; Nystrom, M.; Papadantonakis, K.; Penzes, P.I.; Prakash, P.; Wong, C.G.;
Chang, J.; Ko, K.S.; Lee, B.; Ou, E.; Pugh, J.; Talvala, E.-V.; Tong, J.T.; Tura, A, “The
Lutonium: a sub-nanojoule asynchronous 8051 microcontroler”, Asynchronous
Circuits and Systems, 2003. Proceedings. Ninth International Symposium on 12-15 May
2003 Page(s):14–23
[7] Je-Hoon Lee; Won-Chul Lee; Kyoung-Rok Cho, “A novel asynchronous pipeline
architecture for CISC type embedded controler, A8051”, Circuits and Systems, 2002.
MWSCAS-2002. The 2002 45th Midwest Symposium on Volume 2, 4-7 Aug. 2002
Page(s):II-675 - II-678 vol.2
[8] Chelcea, T.; Nowick, S.M.; “Resynthesis and peephole transformations for the
optimization of large-scale asynchronous systems”,Design Automation Conference,
2002. Proceedings. 39th , 10-14 June 2002 Pages:405–410
計畫成果：
We have successfully completed the behavior simulation in Balsa with small benchmarks
such as GCD and Fibnacci Code. The simulation results are shown in the following.
1. The performance of the decoder
Because we integrate a cache-like buffer with our decoder, we need to know the effects
with different kinds of buffers. We first measured the issue rate with different numbers of
buffers. The buffer size is 32 bytes, and because the programs of GCD or Fibnacci Code are
small, the benchmark is 256 instruction of the additions. The result is shown in Table 1.
The numbers of buffers The consumed time(in Balsa units) The normalized result
0 155,062,000 20.55
1 11,896,100 1.58
2 7,544,200 1
3 10,012,600 1.33
Table 1. The comparison of different numbers of buffers
Second, we measured the issue rate in different sizes of buffers. The buffer size are 8
bytes, 16 bytes, 32 bytes and 64 bytes. The result is shown in Table 2.
The size of buffer
(byte)
The consumed time
(in Balsa units) The normalized result
8 7,801,000 1.03
16 7,629,800 1.01
32 7,544,200 1
64 7,501,400 0.99
Table 2. The comparison of different sizes of buffers
Finally, we measured the performance of the whole pipelined asynchronous 8051 with
different sizes of the buffer. The result is shown in Table 3.
The size of buffer
(byte)
The consumed time
(in Balsa units) The normalized result
