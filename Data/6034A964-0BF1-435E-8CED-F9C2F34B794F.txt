2 
 
 
三、計畫內容 
3.1. 第一部分計畫成果：具有無失真及快
速預覽雙重解碼功能的秘密影像分享機
制 
我們設計兩種 TiOISSS，分別為無失
真模式及可壓縮模式。包含三部分內容: 
(1)無失真模式(k, n)-TiOISSS (2)壓縮模式
(k, n)-TiOISSS (3)抗錯誤的(k, n)-TiOISSS 
研究。 所使用的符號定義如下。 
 
符號定義: 
P() (k, n)-PISSS 的加密 
P-1() (k, n)-PISSS 的解密 
I 灰階秘密影像 I，大小為 I ，
為 P()的輸入 
Pi P(I)的分享影像輸出，i[1, n], 
大小為(|I|/k). 
G() (k, n, m, g)-GVCS 的加密， 1B
和 0B的灰階值則依 Pi裡的灰
階值而定。 
G-1() (k, n, m, g)-GVCS 的解密 (以
分享影像的疊合來達到視覺
解密) 
H() 半色調函式，把灰階的影像轉
換對應半色調影像。 
I   經過半色調的灰階秘密影
像， I =H(I)，大小為
|I|=|I|/(kw) 
Gi G( I  )的分享影像輸出，i [1, 
n]，大小為  ( ) ( )m I k g  . 
無失真模式： 
我們先依 PISSS 決定  8 | |I k 個加
密位元數，則每個(k, n, m, g)-GVCS 的分
享影像的 |I|/k 個灰階像素可以用來隱藏
 8 | |I k 個位元數，有 g 個灰階像素
sub-pixels 在每個(k,n,m, g)-GVCS 的 m 
sub-pixels 裡，GVCS 的半色調秘密影像 I
大小應為 |I|/(kg)，而分享影像大小為
m|I|。對應無失真的像素擴張量 m，定義
為 ( ) / ( )LPROm m k g  。 
     
                                    
加密程序： 
輸入：灰階秘密影像 I；參數 k, n, m, g；基
本矩陣 1B和 0B。 
輸出：n 張分享影像 Gi，i[1, n]。 
1-1)對灰階秘密影像 I 加密產生分享影像
Pi= P(I)，i[1, n]。 
1-2) 對灰階秘密影像 I 產生半色調秘密
影像 I 。 
1-3) 輸出 n 張分享影像 Gi=G( I  )，i[1, 
n]。 
 
解密程序： 
輸入：從任 n 張分享影像
1 2
, , ,
ki i i
G G G 取
出 k 張分享影像。 
輸出：半色調秘密影像 I  (第 1 層解密)；
灰階秘密影像 I (第 2 層解密)。 
/*第一階層解密：不需經電腦計算；從 k
張分享影像相疊，視覺解密得秘密影像 I 
。第 2 階層解密: 需經電腦解密；Lagrange 
interpolation 解密得 I */ 
階段一(預覽階段)： 
2-1) G-1 (
1 2
, , ,
ki i i
G G G )；經由疊合 k 個分
享影像，視覺上解得較為模糊的半色調秘
密影像 I 。 
階段二 (完美解回階段)： 
2-2) 從
1 2
, , ,
ki i i
G G G 張分享影像，去除掉
白色像素，而獲得
1 2
, , ,
ki i i
P P P 等分享影
像。 
2-3) 秘密影像 I從
1 2
, , ,
ki i i
P P P 張分享影像
解得，I= P-1 (
1 2
, , ,
ki i i
P P P )。 
/*利用 Lagrange interpolation 來解回灰階
秘密影像*/ 
 
  
可壓縮模式： 
 在本計畫案具有多樣性解碼功能的祕
密影像分享機制之研究，在第二階層的解
密是利用 PISSS，所以我們可以利用[36]
的壓縮方法來對要隱藏的秘密影像來做壓
縮。假定 J()為 Jpeg 的壓縮函式，壓縮過
的影像 IC=J(I)，壓縮比 R=影像 I 的位元數
4 
 
且 1j 1nk  。每一個行向量其漢明量
(Hamming weight)為 k1；舉例來說：方
法二的
4,2
11 12 13 14 15 16
21 22 23 24 25 26
31 32 33 34 35 36
41 42 43 54 45 46
1 1 1 0 0 0
1 0 0 1 1 0
0 1 0 1 0 1
0 0 1 0 1 1
b b b b b b
b b b b b b
B
b b b b b b
b b b b b b
  
              
。
Si    n 張分享影像，其 i[1, n]，大
小為|O|/n (方法一)和|O|/k (方法二)。 
Rt 由任意 t 張分享影像還原成的影
像。 
inf()     還原的影像其資料佔秘密影
像 O 的百分比比例。 
 
方法一：  nk 張子影像的(k, n)比例式秘密
分享機制 
方法一其(k, n)-SSIS 機制的加密和解密程
序基於  nk 張互斥的子影像和多項式定理
(polynomial-based)的(k, k)-SIS 機制。使用
方法一的(2, n)-SSIS 機制其分享影像大小
為|O|/n，比 Wang 等人的(2, n)-SSIS 機制
的|O|/2 還小；且當 n 越大時，分享影像大
小兩者會有更顯著的差異。第二部分計畫
方法一的加密程序和解密程序詳加說明於
下。 
 
加密程序： 
輸入：一張秘密影像 O。 
輸出：n 張分享影像 Si, i[1, n]。 
1. 由 P(O)得到 Ox, x[1,  nk ]。 
2. 對於每張影像Ox，藉由 , ( )k k xE O 產生k
張子影像之分享影像 ( 1xO , 2xO , …, kxO )。 
3. 令 1 2 nS S S    。 
4. 選一個矩陣  ,n k ijB b 。 
5. For j=1 to  nk  do 
{Set y=1; 
For i=1 to n 
{If bij=1 then ˆ i yj jO O  and y=y+1; else 
ˆ i
jO  ;} 
}; 
6.  
1
ˆ ,  [1,  ].
n
ik
i jj
S O i n   
    /* 加密出 n 張分享影像 1 2,  ,  ,  nS S S  */ 
 
解密步驟： 
輸入：n 張分享影像 Si, i[1, n]。 
輸出：Rt, where tk。 
1. 所有參與者各自從自己的分享影像 Si, 
i[1, n]，取出他們的 ˆ ijO , j[1,  nk ]。 
2. 對於任何 t (k)張分享影像，參與者從
他自己的 ˆ ijO 找到對應的子影像之分享影
像 yxO 。 
3. 分享影像Ox經由 , ( )k kD  解密，可得到k
張子影像之分享影像 (亦即滿足門檻值
(threshold property))。 
4. 重建從(3)解密出來的子影像可還原
影像Rt。 
 
由 inf(Rt)來看必要條件(安全性
(Security condition)和比例式特性
(Scalability condition))，我們的(k, n)-SSIS
機制如下所示。  
(1) [安全條件(Security condition) ]：
inf(Rt)=0 for t (k–1)。  
(2) [比例式條件(Scalability 
condition) ]：inf(Rt)<inf(Rt+1) for 
ktn, and inf(Rn)=1。 
此安全條件保證我們(k, n)-SSIS 機制能完
善保密。滿足條件(1)表示達到門檻值特
性，少於 k 張分享影像不能獲得任何秘密
資訊。條件(2)表示還原影像的品質是依分
享影像的數量比例依其上面給定的門檻值 
(i.e. 比例式特性)，並且 inf(Rn)=1 保證藉
由所有參與者可以成功還原完整的秘密影
像。 
 
定理一：方法一的(k, n)-SSIS 機制其分享
影像大小為秘密影像的 1/n。 
證明：假設一秘密影像 O，我們首先證明
分享影像大小為 | |O n。在方法一中，一張
秘密影像 O 被分割成  nk 張大小為  | | nO k
的互斥子影像。由於 ,n kB 的每個行向量有 k
6 
 
加密步驟： 
輸入：一張秘密影像 O。 
輸出：n 張分享影像 Si, i[1, n]。 
1. 由 P(O)得到 Ox, x[1,  1nk  ]。 
2. 對於每張影像Ox，藉由 , ( )k k xE O 產生 k 
張子影像之分享影像 ( 1xO , 2xO , …, kxO )。 
3. 令 1 2 nS S S    。 
4. 選擇一個矩陣  , 1n k ijB b  。 
5. For j=1 to  1nk   do 
{Set y=2; 
For i=1 to n 
{If bij=1 then ˆ i yj jO O  and y=y+1; else 
1ˆ i
j jO O ;} 
}; 
6.  1
1
ˆ ,  [1,  ]
n
ik
i jj
S O i n  。 
    /* 產生 n 張分享影像 1 2,  ,  ,  nS S S  */ 
解密步驟： 
輸入：n 張分享影像 Si，i[1, n]。 
輸出：Rt, where tk。 
1. 所有參與者各自地從自己的分享影像
Si, i[1, n]，提取他們的 ˆ ijO , j[1,  1nk  ]。 
2. 對於任何 t (k)張分享影像，參與者從
他自己的 ˆ ijO 找到相應的子影像之分享影
像 yxO 。 
3. 分享影像Ox經由 , ( )k kD  解密，有k張子
影像之分享影像 (亦即滿足門檻值)。 
4. 重建從步驟 3 解密出來的子影像可還
原的影像 Rt。 
 
定理二：方法二的(k, n)-SSIS 機制其分享
影像大小為秘密影像的 1/ k。 
證明：假設一張秘密影像 O，我們首先證
明分享影像大小為 | |O k。在方法二中，一
張秘密影像 O 分割成  1nk  張大小為
 | | 1nkO  的互斥子影像。因為
 1
1
ˆ ,  [1,  ]
n
ik
i jj
S O i n  ，每張分享影像|Si|有
 1nk  張子影像之分享影像，所以分享影
像大小為  | | 1nkO   1 / k  1nk   = | |O k 。 
由於在 , 1n kB  中，t (tk–1)列沒有(k1)
個“1”和至少1個“0”，所以不足k張子影像
之分享影像去還原任何一張子影像，因此
inf(Rt)值為0 for tk–1，故證明了安全條
件。考慮比例式條件，每個行向量有(k1)
個“1”和(nk+1)個“0”。所以在 , 1n kB  中，任
意t (k)列有  1tk  個t元組，每一t元組有
(k1)個“1”和(tk+1) 個“0”，故保證有足夠
的子影像之分享影像去還原子影像。因
此，我們可以還原  1tk  張子影像且t (k)
張分享影像可重建影像Rt。由於還原的子
影像數量為  1tk  ，且子影像的總數量為 1nk  ，則inf(Rt)=    1 1t nk k   for 
ktn。因為        11 1 1 1t n t nk k k k    ，所
以inf(Rt)<inf(Rt+1) for ktn。顯而易見地，
inf(Rn)=    1 1n nk k  =1。如上所述，使用
方法二的(k, n)-SSIS機制滿足條件(1)和條
件(2)，而且是(k, n)-SSIS機制。 
 
範例 3：(3, 4)-SSIS schem 用方法二加密出
4 張分享影像 
一張秘密影像O用多秘密模式依空間
大小分割成 6 張(since  4 62  )子影像 O1, 
O2, …, O6。每個子影像用基於多項式定理
的(3, 3)-SIS 機制加密成 3 張子影像之分享
影像。所以我們共得到 18 張大小為|O|/18
的子影像之分享影像。 (3, 4)-SSIS 機制的
矩陣 , 1 4, 2n kB B  為 
4,2
11 12 13 14 15 16
21 22 23 24 25 26
31 32 33 34 35 36
41 42 43 54 45 46
1 1 1 0 0 0
1 0 0 1 1 0 .
0 1 0 1 0 1
0 0 1 0 1 1
b b b b b b
b b b b b b
B
b b b b b b
b b b b b b
  
              
               
 
1 1 1 1 1 1 2 2 2 1 1 1
1 2 3 4 5 6 1 2 3 4 5 6
2 2 2 2 2 2 3 1 1 2 2 1
1 2 3 4 5 6 1 2 3 4 5 6
3 3 3 3 3 3 1 3 1 3 1 2
1 2 3 4 5 6 1 2 3 4 5 6
4 4 4 4 4 4 1 1 3 1 3 3
1 2 3 4 5 6 1 2 3 4 5 6
ˆ ˆ ˆ ˆ ˆ ˆ
ˆ ˆ ˆ ˆ ˆ ˆ
ˆ .ˆ ˆ ˆ ˆ ˆ ˆ
ˆ ˆ ˆ ˆ ˆ ˆ
i
j
O O O O O O O O O O O O
O O O O O O O O O O O O
O
O O O O O O O O O O O O
O O O O O O O O O O O O
 
                  
              
8 
 
in visual cryptography, Designs, Codes and 
Cryptography, 38 (2006) 219-236. 
[23] D.S. Tsai, T.H. Chen and G. Horng, A cheating 
prevention scheme for binary visual cryptography 
with homogeneous secret images , Pattern 
Recognition 40 (2007) 2356-2366. 
[24] C.N. Yang and T.S. Chen, Reduce shadow size in 
aspect ratio invariant visual secret sharing schemes  
using a square block-wise operation, Pattern 
Recognition 39 (2006) 1300-1314. 
[25] S. Cimato, A. De Santis, A.L. Ferrara and B. 
Masucci, Ideal contrast visual cryptography schemes  
with reversing, Information Processing Letters 93 
(2005) 199-206. 
[26] C.N. Yang, C.C. Wang and T.S. Chen, Visual 
cryptography schemes with reversing, The Computer  
Journal 51 (2008) 710-722. 
[27] A. Shamir, How to share a secret, 
Communications of the Association for Computing 
Machinery 22 (1979) 612–613. 
[28] C.C. Thien and J.C. Lin, Secret image sharing, 
Computers & Graphics 26 (2002) 765-770. 
[29] R.Z. Wang and C.H. Su, Secret image sharing 
with smaller shadow images, Pattern Recognition 
Letters 27 (2006) 551-555. 
[30] C.C. Thien and J.C. Lin, An image-sharing 
method with user-friendly shadow images, IEEE 
Trans. on Circ. and Sys. for Video Tech. 13 (2003) 
1161-1169. 
[31] C.N. Yang, K.H. Yu, and R. Lukac, User-friendly 
image sharing using polynomials with different 
primes, International Journal of Imaging Systems and 
Technology 17 (2007) 40-47. 
[32] C.C. Lin and W.H. Tsai, Secret image sharing  
with steganography and authentication, Journal of 
Systems & Software 73 (2004) 405-414. 
[33] C.N. Yang, T.S. Chen, K.H. Yu, C.C. Wang, 
Improvements of image sharing with steganography 
and authentication, Journal of Systems & Software 80 
(2007) 1070-1076.  
[34] C.C. Chang, Y.P. Hsieh, C.H. Lin, Sharing 
secrets in stego images with authentication. Pattern 
Recognition 41 (2008) 3130-3137. 
[35] D. Jin, W.Q. Yan and M.S. Kankanhalli, 
Progressive color visual cryptography, Journal of 
Electronic Imaging 14 (2005) 033019-1-033019-13.  
[36] S.J. Lin and J.C. Lin, VCPSS: A two-in-one 
two-decoding-options image sharing method 
combining visual cryptography (VC) and 
polynomial-style sharing (PSS) approaches, Pattern 
Recognition 40 (2007) 3652-3666. 
[37] P.A. Eisen and D.R. Stinson, Threshold visual 
cryptography schemes with specified whiteness, 
Designs, Codes and Cryptography 25 (2007) 15-61. 
[38] R.Z. Wang, S.J. Shyu, Scalable secret image 
sharing, Signal Processing: Image Communication 
22(2007)363-373. 
[39] S. Cimato, R. De Prisco and A. De Santis, 
Colored visual cryptography without color darkening, 
Theoretical Computer Science, 374 (2007) 26 1-276.  
[40] F. Liu, C.K. Wu and X.J. Lin, Color Visual 
Cryptography Schemes, IET Information Security, 2 
(2009) 151-165. 
[41] W.P. Fang, J.C. Lin, Progressive viewing and 
sharing of sensitive images, Pattern Recognition and 
Image Analysis, 16 (4) (2006) 638-642. 
[42] R.Z. Wang, Y.K. Lee, S.Y. Huang, T.L. Chia, 
Multilevel Visual Secret Sharing, Proceedings of the 
Second International Conference on Innovative 
Computing, Information and Control (2007) 283-283. 
[43] C.C. Wu, S.J. Kao, W.C. Kuo, M.S. Hwang, 
Enhance the image sharing with steganography and 
authentication, Proceedings of Intelligent Information 
Hiding and Multimedia Signal Processing (2008) 
1177-1181. 
[44] Z. Eslami, S.H. Razzaghi and J.Z. Ahmadabadi, 
Secret image sharing based on cellular automata and  
steganography, Pattern Recognition 43 (2010) 
397-404. 
[45] C.L. Liu, Introduction to Combinatorial 
Mathematics, McGraw-Hill (1968). 
A new type of ISSS with two decoding options was introduced
recently, where the secret image is revealed both by stacking the
transparencies and by computation. This scheme is referred to as the
two-in-one ISSS (TiOISSS). This utility TiOISSS can decode secret
images for preview by HVS when a computer is temporarily un-
available. When the computer is available during the decoding scene,
we then spend more computation to obtain a high-quality image for
high-end applications. So far, two TiOISSSs [35,36] have been
proposed. Both schemes can stack shadows to decode a halftone
secret image by HVS in the ﬁrst stage, and they can perfectly
reconstruct the gray-level secret image in the second stage. A possible
application scenario of TiOISSS is described below. In a distributed
multimedia system, the n shadows of PISSS can be delivered in a
distributed system where each shadow is stored in any distributed
storage node. In this application, the failure of (n−k) shadows during
transmission does not affect the reconstruction phase, as the secret
image can be perfectly restored using k shadows. Suppose a fake
shadow is received. The receivermay spend considerable computation
and ﬁnally ﬁnd the received shadow is wrong. Because the recon-
struction phase of PISSS is very computationally intensive, we can
therefore apply the TiOISSS to save the computational time for
verifying of the validity of shadows. The receiver can ﬁrst verify the
shadows by visually previewing the secret without computation. After
the successful veriﬁcation, the receiver then recovers the original gay-
level secret image by computation.
In this paper, we design a new TiOISSS by properly combining VCS
and PISSS to develop their specialities and simultaneously avoid the
disadvantages. When compared with the previous TiOISSSs, our
scheme has the lesser shadow size. The rest of this paper is organized
as follows: Section 2 reviews PISSS and VCS. Two previous TiOISSSs
[35,36] are brieﬂy described in Section 3. The proposed framework is
introduced in Section 4, and experimental results and comparisons
are given in Section 5. Finally, Section 6 concludes the paper.
2. Preliminaries
Theproposed scheme is ahybrid of PISSSandVCS; as a result,weﬁrst
describe PISSS and VCS which are basic elements of our new TiOISSS.
2.1. PISSS
A polynomial-based (k, n) secret sharing scheme was ﬁrstly
proposed by Shamir [27], in which the secret data is encrypted into n
shadows. Any k shadows can be used to reconstruct the secret, but any
k−1 or fewer shadows get no information. By taking the secret data
as g0 (constant term) in the following (k−1)-degree polynomial g(x)
where p is a prime number, we could construct n shadows (xi, g(xi))
by choosing n different xi, i∈ [1, n].
g xð Þ = g0 + g1x + ::: + gk−1xk−1ð Þ mod p: ð1Þ
Any k shadows (without loss of generality, we use k shadows (xi, g
(xi)), i∈ [1, k]) can be used to reconstruct the (k−1)-degree
polynomial g(x) by Lagrange interpolation as follows. Afterwards,
the secret data g0 can be determined from g0=g(0).
g xð Þ = g x1ð Þ
x−x2ð Þ x−x3ð Þ::: x−xkð Þ
x1−x2ð Þ x1−x3ð Þ::: x1−xkð Þ
+ g x2ð Þ
x−x1ð Þ x−x3ð Þ::: x−xkð Þ
x2−x1ð Þ x2−x3ð Þ::: x2−xkð Þ
+ ⋯ + g xkð Þ
x−x1ð Þ x−x2ð Þ::: x−xk−1ð Þ
xk−x1ð Þ xk−x2ð Þ::: xk−xk−1ð Þ
mod p:
ð2Þ
Through Shamir's secret sharing scheme, we could take every
secret pixel as g0 in a (k−1)-degree polynomial g(x) to construct n
random grayscale values in shadows to construct a (k, n)-PISSS. At this
time, the prime number p=251 is chosen such that g(x) is
constrained between 0 and 250 and suitable to represent the
conventional 8-bit grayscale or color images. Notice that the possible
values of an 8-bit gray pixel are from 0 to 255, so the grayscale values
(N250) need to be modiﬁed to 250 and will cause distortion.
Obviously, we can use Galois Field GF(28) rather than the ordinary
arithmetic (mod 251) to achieve a lossless scheme. Thien and Lin
further reduced shadow with size 1/k times that of the secret
image [28] by embedding the secret data in all coefﬁcients of g(x). The
formal encoding is brieﬂy described below.
We ﬁrst divide a secret image into τ non-overlapping k-pixel
blocks, and every j-th (0≤ j≤τ−1) block includes the secret pixel
values pjk, pjk+1, ..., pjk+k−1. The (k−1)-degree polynomial Sj(x)
represents a shadow pixel associated with the j-th block on shadow.
Sj xð Þ = pjk + pjk + 1x + pjk + 2x2 + ::: + pjk + k−1xk−1
 
in GF 28
 
;
ð3Þ
where x is often an image identiﬁcation and 0≤ j≤τ−1. The value of
Sj(x) is generated using the original pixel values pjk, pjk+1, ..., pjk+k−1
included in the jth block. In this paper, the Galois Field GF(28) was
chosen to achieve a lossless secret image. Because we embed the k
pixels each time, the size of shadow image is 1/k of the secret image.
By reversing the encoding, the polynomial in Eq. (3) can be
reconstructed from k shadow pixels; hence, the blocks can be
recovered and ﬁnally we can restore the secret image.
2.2. VCS
The ﬁrst VCS was Naor-Shamir's (k, n)-VCS to encrypt a halftone
secret image into noise-like shadows. The authors used the whiteness
(the number of white subpixels in a m-subpixel block) to distinguish
the black color from the white color, i.e., “m−h”B“h”W (respectively
“m− l”B“l”W) represents a white (respectively black) color, where
hN l. A black-and-white (k, n)-VCS can be designed using two base
n×mmatrices B1 and B0 with elements “1” and “0” denoting black and
white subpixels. When sharing a black (respectively white) secret
pixel, the dealer randomly chooses one row of the matrix in the set C1
(respectively C0) which includes all matrices obtained by permuting
the columns in B1 (respectively B0) to a relative shadow. Let OR(Bi|r),
i=0, 1, denote the “OR”-ed vector of any r rows in Bi, and H(⋅) be the
Hamming weight of a vector. Then, the base matrices of the (k, n)-VCS
satisfy the following conditions:
ðV 1Þ: H OR B1 jrð Þð Þ≥ m–lð Þ and H OR B0 jrð Þð Þ≤ m–hð ÞÞ for r = k;
where 0≤ lbh≤m:
ðV 2Þ: H OR B1 jrð Þð Þ = H OR B0 jrð Þð Þ for r≤ k–1ð Þ:
The ﬁrst condition is often referred to as the contrast condition, and
the secret image can be recognized due to their different contrasts of
black and white colors. The second condition is the security condition
that assures the (k, n)-VCS of perfect secrecy.
Example 1. Construct a (2, 2)-VCS of h=1, l=0 and m=2 using
B1 =
10
01
 
and B0 =
10
10
 
. The secret is a printed-text image VCS.
A (2, 2)-VCS with B1 =
10
01
 
and B0 =
10
10
 
has H(OR(B1|2))=
2, H(OR(B0|2))=1, and H(OR(B1|1))=H(OR(B0|1))=1 which satisfy
(V-1) and (V-2) conditions. In the reconstructed image, the black
color is 2B0W and the white color is 1B1W (or 1W1B). However, each
shadow contains 1B1W and 1W1B with the same frequencies so that
one cannot see anything from his own shadow. Fig. 1(a) is a black-
1601C.-N. Yang, C.-B. Ciou / Image and Vision Computing 28 (2010) 1600–1610
4. The proposed (k, n)-TiOISSS
VCS and PISSS have their respective features. As is known, VCS has
the vague reconstructed image and PISSS has a perfect reconstruction.
VCS has the distinctive stacking-to-see capability, while PISSS spends
the computation for reconstruction. It is reasonable to adopt the
stacking-to-see property of VCS into PISSS to achieve a two-in-one
scheme where the secret image is revealed both by stacking the
transparencies and by computation. Our new TiOISSS is also a com-
bination of VCS and PISSS, which is somewhat similar to Lin et al.'s
scheme, but theway is completely different to that in Lin et al.'s scheme.
Jin et al.'s TiOISSS is a lossless version (i.e. no distortion in the
secret image) but has a large pixel expansion. Lin et al.'s TiOISSS is a
compressible version. It compresses the secret image such that the
shadow size has enough space to hide the information of a
compressed image. Although Lin et al.'s scheme reduces the pixel
expansion of Jin et al.'s scheme, the reconstructed image has
distortion. Obviously, Lin et al.'s approach can be extended to the
lossless version by expanding the halftone image with the size
jI′j ¼ n= kð Þ × jIj × 8=log2
m
w
 
to hide the original secret image. For
the lossless version of Lin et al.'s TiOISSS, the pixel expansion mLIN(L) is
m Lð ÞLIN = n = kð Þ × m × 8=log2
m
w
 
: ð7Þ
For example, the pixel expansion of Lin et al.'s (2, 4)-TiOISSS in
Example 2 (i.e. k=n=2, m=4, w=2) is mLIN(L)=24.76.
Jin et al.'s schemecannotbeused ina compressible versionbecause it
uses a look-up table to recover the grayscale value of the pixel. The
proposed TiOISSS has two versions- the lossless version and the
compressible version. For simplicity, we ﬁrst describe the proposed
TiOISSS, which reconstructs a lossless secret image. The compressible
version is just an easy extension of the lossless TiOISSS, and will be
discussed in Section 4.3.
4.1. Design concept
Our design concept adopts the gray subpixel into VCS, and this
grayscale values simultaneously represent the output of the (k−1)-
degree polynomial in PISSS. In VCS, it is evident that when a subpixel is
stacked by the white subpixel, its intensity is kept unchanged. While
stacking two gray subpixels, we get a grayer color (a dark version of the
color). Therefore, ifwe replace black subpixelswithgray subpixels in the
shadow,westill canuse thewhiteness ineverym subpixel todistinguish
the black color from the white color in the reconstructed image. Here,
we adopt the widely accepted deﬁnition of color superimposition in
[37,38] to deﬁne the colormixing functionwhen stacking two subpixels
with the grayscale values between 0 and 255.
Deﬁnition 1. The grey level of the result pixel by stacking the two
pixels can be expressed (approximately) as follows, in which each
mixed color is produced by a color mixing operation C(⋅).
g3 = C g1; g2ð Þ = Int g1 × g2ð Þ= 255ð Þ; ð8 1Þ
where Int(⋅) function maps a real number to the nearest integer. The
values of g1, g2, g3 are any grayscale values between 0 and 255, and “0”
(respectively “255”) is a black (respectivelywhite) color. FromEq. (8-1),
we can easily have
g1¼C g1; 255ð Þ; ð8 2Þ
255¼C 255; 255ð Þ: ð8 3Þ


In Eq. (8-1), it is easy to verify g3bg1 and g3bg2, and this implies
that stacking two gray pixels of g1 and g2 results in a grayer pixel of g3.
Eq. (8-2) shows the grayscale value unchanged when stacking with
the white pixel and Eq. (8-3) shows that the stacked result is a white
color when stacking two white pixels.
Example 3. Consider Example 1, and randomly use gray subpixels
gi∈ [0, 255] instead of black subpixels in B1 and B0 and do not change
the white subpixel.
As a replacement in B1 and B0, we haveB′1 =
gi 0
0 gj
 
and B′0 =
gi 0
gj 0
 
, respectively. In the reconstructed image, it is observed that
the stacked result in the black area (using B′1) is 1gi1gj and the stacked
result in the white area (using B′0) is 1gk1W or 1W1gk, where gkbgi
and gkbgj. Through the whiteness, we can visually reveal the secret.
Each shadow contains 1gi1W (or 1W1gi) which is a gray-and-white
and noise-like image, so that one cannot see anything from any
shadow. In Fig. 2(a) are two noise-like shadows (Shadow1, Shadow2)
and Fig. 2(b) shows the reconstructed image (Shadow 1+Shadow 2).
It is observed that the secret VCS is also revealed but is a little blurred
when compared with Fig. 1(c).
We call the VCS with the matrices B′1 and B′0 the gray-subpixel
based VCS (GVCS). Matrices B′1 and B′0 are the same as B1 and B0
except that the gray subpixels replaced the black subpixels. Hence,
GVCSholds the contrast and security conditions (V-1) and (V-2), and it
is still a VCS. In this paper, we use the notation (k, n, m, g)-GVCS, to
denote a (k, n)-GVCS with B′1 and B′0, in which every row has g
gray subpixels and (m−g) white subpixels. The whiteness, (m−g)
white subpixels in everym-subpixel block, can be used to distinguish
the black color from the white color. The grayness of the non-white
subpixels in the reconstructed image is different from the pure
blackness in VCS, and it will distort the clarity (see Figs. 1(c) and 2(b)).
In order to design a TiOISSS based on GVCS and PISSS, we should
carefully observe the distinguishing characteristics of both image
secret sharing schemes. As shown in Table 1, all characteristics of GVCS
and PISSS are opposite; hence, combining GVCS and PISSS creates the
following problem. It is obvious that we need two secret images- a
halftone secret image for GVCS and a gray-level secret image for PISSS.
In our TiOISSS, the gray-level secret image is shared by PISSS. Then, we
divide the halftone secret image into shadows by GVCS, in which the
grayscale values in B′1 and B′0 are chosen according to the outputs of the
(k−1)-degree polynomials in PISSS. Also, we should determine the
sizes of both secret images such that there are enoughgray subpixels in
GVCS to represent the outputs of PISSS.
4.2. The lossless version of the proposed TiOISSS
We construct a (k, n)-TiOISSS based on a (k, n)-PISSS and a (k, n,m,
g)-GVCS tp share a gray-level secret image I. For the lossless version,
Fig. 2. A (2, 2)-GVCS of h=1, l=0andm=2: (a) two shadows: Shadow1 and Shadow2
(b) the reconstructed image: Shadow 1+Shadow 2.
1603C.-N. Yang, C.-B. Ciou / Image and Vision Computing 28 (2010) 1600–1610
pixels of G1 and G2, and then reconstruct the gray-level Lena in
Fig. 4(a) by I=P−1(P1, P2).
Case (2) B1 =
110
101
 
, B0 =
110
110
 
:
Since m=3 and g=2, we need a halftone image I′ of the size is
|I′|=|I|/(k×g)=|I|/4. Output two shadowsGi=G(I′), i=1, 2, byusing (2,
2, 3, 2)-GVCS, and the values of gray subpixels are chosenaccording to the
gray pixels in P1 and P2. In Fig. 5(a) are two gray-and-white shadows G1
and G2 of the size m×|I′|=0.75×|I| (512×384-pixels). Fig. 5(b) is the
stacked result by stackingG1 andG2. By the sameapproach inCase (1),we
can also reconstruct the original gray-level Lena I.
Example 5. Construct the proposed (2, 3)-TiOISSS using B1 =
100
010
001
2
4
3
5
and B0 =
100
100
100
2
4
3
5.
A 512×512 gray-level Lena image is tested. Through (2, 3)-PISSS,
we ﬁrst obtain three 512×256 gray-level noise-like shadows P1, P2
and P3, as shown in Fig. 6(a). Since m=3 and g=1, we need a
halftone image I′ of the size |I′|=|I|/(k×g)=|I|/2. Output three
shadows Gi=G(I′), i=1, 2 and 3 by using (2, 3, 3, 1)-GVCS, and the
values of gray subpixels are chosen according to the gray pixels in P1,
P2 and P3. Fig. 6(b) are three gray-and-white shadows G1, G2 and G3 of
the size m×|I′|=1.5×|I| (512×768-pixels). In Fig. 6(c) are the
Fig. 4. The proposed (2, 2)-TiOISSS using base matrices with h=1, l=0 and m=2:
(a) 512×256 halftone image I′ (b) two 512×512 gray-and-white shadows, G1 and G2
(c) the previewed image: G1+G2.
Fig. 3. A (2, 2)-PISSS: (a) 512×512 gray-level Lena secret image I (b) 512×256 gray-
level noise-like shadows, P1 and P2.
Fig. 5. The proposed (2, 2)-TiOISSS using base matrices with h=1, l=0 and m=3:
(a) two 512×512 gray-and-white shadows, G1 and G2 (b) the previewed image: G1+G2.
Fig. 6. The proposed (2, 3)-TiOISSS using base matrices with h=2, l=1 and m=3:
(a) three 512×256 gray-level noise-like shadows, P1, P2 and P3 (b) three 512×768
gray-and-white shadows, G1, G2 and G3 (c) the previewed image by stacking any two
out of three shadows.
1605C.-N. Yang, C.-B. Ciou / Image and Vision Computing 28 (2010) 1600–1610
When usingNaor-Shamir (3, n)-VCSwithm=2n−2,w=g=m/2,
we have
m Lð ÞLIN = n = 3ð Þ × m × 8=log2
m
w
 
= 8 × m × nð Þ= 3ð Þ= log2 mm= 2
 
= 8 × m × nð Þ = 3ð Þ= log2
m × m−1ð Þ × ⋯ × m= 2 + 1ð Þ
m= 2ð Þ × m= 2−1ð Þ × ⋯ × 1
 
N 8 × m × nð Þ= 3ð Þ= log2 mm=2
 
= 16n= 3ð Þ= log2 mð Þ
= 16n = 3ð Þ= log2 2n−2ð Þð Þ N 4n−4ð Þ= 3ð Þ= log2 2n−2ð Þð Þ
= 2= 3ð Þ × 2n−2ð Þ= log2 2n−2ð Þð Þ N 2 = 3 = m= k × gð Þ
= m Lð ÞPRO since g = m= 2 and k = 3ð Þ: ð12Þ
When using Naor-Shamir (2, n)-VCS withm=n, w=m−1, g=1,
we have
m Lð ÞLIN = n = 2ð Þ × m × 8=log2
m
w
 
= 4 × m × mð Þ= log2 mm−1
 
= 4m2
 
= log2 mð Þ = 4mð Þ m= log2 mð Þð Þ N 4m N m= 2
= m= k × gð Þ = m Lð ÞPRO since g = 1 and k = 2ð Þ: ð13Þ
From Eqs. (11), (12) and (13), we obtain mLIN
(L) NmPRO
(L) . The proof is
completed.
Table 2 lists the pixel expansions of some (k, n)-TiOISSSs. Our
scheme (respectively, Lin et al.'s scheme) could choose different g
(respectively,w) in the samem to reduce the shadow size. For example,
both (2, 2)-TiOISSSs can use B1 =
110
101
 
, B0 =
110
110
 
instead of
B1 =
10
01
 
, B0 =
10
10
 
to reduce the pixel expansions from mPRO
(L) =1
and mLIN
(L)=16 to mPRO
(L) =3/4 and mLIN
(L)=15.14, respectively. Our (2, 3)-
TiOISSS could reduce the pixel expansion from 3/2 to 3/4 by replacing
B1 =
100
010
001
2
4
3
5, B0 =
100
100
100
2
4
3
5 with B1 =
110
011
101
2
4
3
5, B0 =
110
110
110
2
4
3
5, but the
pixel expansion mPRO
(L) =22.71 of Lin et al.'s scheme cannot be further
Fig. 7. Two shadows (Shadow 1, Shadow 3) and their stacked result of three (2, 4)-
TiOISSSs using base matrices with h=2, l=1 and m=4: (a) Jin et al.'s scheme with
shadow size 3072×3072-pixels (b) Lin et al.'s scheme with shadow size 2548×2548-
pixels (c) the proposed scheme with shadow size 512×512-pixels.
Fig. 8. Two shadows (Shadow 1, Shadow 3) and their stacked result of the compressible
version of (2, 4)-TiOISSSs using base matrices with h=2, l=1 and m=4, by R=6.5
(a) the 512×512 compressed images IC (b) Lin et al.'s scheme with shadow size
1024×1024-pixels (c) the proposed scheme with shadow size 402×402-pixels.
1607C.-N. Yang, C.-B. Ciou / Image and Vision Computing 28 (2010) 1600–1610
To elucidate on the good results of the proposed scheme among
the existing TiOISSSs, some properties are evaluated: (1) the resolution
of the reconstructed image (2) the decoding complexity (3) the shadow
images (including the image pattern, the shadow size, the ﬁle size of
shadow) (4) the pixel expansion (5) the progressive decryption. A
comparison between our TiOISSS and the other two TiOISSSs in [35,36]
is listed in Table 3. All three schemes have dual modes of decoding- one
for preview (or when a computer is temporarily unavailable) and the
other for perfectly reconstructing the original gray-level secret image.
Also, they all have a distinctive stacking-to-see property. Our scheme
and Lin et al.'s scheme use Lagrange interpolation for perfect
reconstruction with the computational complexity O(k) and no
additional memory space, while Jin et al.'s scheme uses a 8×8 ROM
look-up table (Table 2 in [35]) for reconstruction without computation.
Our gray-and-white shadows have the beneﬁt of reducing the physical
size and the ﬁle size of the shadow when compared with other two
TiOISSSs. In [35], by simply creating different images which have the
same image as I but of a different resolution, Jin et al.'s scheme could
provide a progressive mechanism to decode the images at multiple
resolutions. In fact, the progressive decryption can also be easily added
into the proposed TiOISSS and Lin et al.'s scheme by the so-called
scalable PISSS [40], which can gradually reconstruct a secret image in a
progressive mode. The approach in [40] is very similar to Jin et al.'s
scheme; we should partition I into some sub-images. As described, all
three TiOISSSs have the capability of the progressive decryption.
We also compare the proposed TiOISSS with other ISSSs (the VCS
[1–17], the extended VCS [18], the PISSS [28], the PISSS with the
shrunken secret on shadows [30], the PISSS with authentication
ability [32]) to gauge our TiOISSS's purpose. As shown in Table 4, we
provide a comparative evaluation of their advantages and disadvan-
tages. All ISSSs can encrypt a secret image into shadows. Our TiOISSS
and the schemes in [1–17,28] have noise-like shadows, while other
schemes [18,30,32] have the meaningful shadows. However, the
shadow in [30] is a shrunken version of the secret image. Actually the
portrait on the shadow images has already leaked the secret
information and hence it is, strictly speaking, not an ISSS. The shadow
in [32] is a cover image and could be any high-quality natural image.
Although the extended VCS [18] has the meaningful shadows, their
qualities are vague (note: this scheme is a VCS). All VCS-like
schemes [1–18] have the poor visual qualities of the reconstructed
images but they have the distinctive stacking-and-see property.
PISSS-like schemes [28,30,32] can reconstruct the high-quality secret
image but need the computation of Lagrange interpolation. The
proposed scheme is a hybrid of VCS and PISSS. It has two decoding
options: one is easy (using the stacking-and-see property) and the
other is hard (using Lagrange interpolation) to gain the secret with
Table 3
A comparison between our TiOISSS and other two TiOISSSs.
TiOISSS The proposed scheme Jin et al.'s scheme [35] Lin et al.'s scheme [36]
The resolution Phase 1 U U U
Phase 2 ∞ ∞ ∞
The decoding complexity Phase 1 H H H
Phase 2 The space complexity NO L-T (8×8 ROM) NO
The computational complexity L-I (O(k)) NO L-I (O(k))
The shadow images The pattern G-W B-W B-W
The shadow size S M L
The ﬁle size S M L
The pixel expansion S M L
The progressive decryption Yes Yes Yes
Notation: ∞: perfect reconstruction of the original image (note: for lossless version); U: the unacceptable image quality of reconstructed image; H: stack shadows and use HVS to
preview the secret; L-I: use Lagrange interpolation for reconstruction; L-T: use a look-up table for reconstruction; G-W: gray-and-white noise-like shadows; B-W: black-and-white
noise-like shadows; S, M, L: the values of shadow size, ﬁle size and pixel expansion are small, medium and large scales, respectively.
Table 4
A comparison between our TiOISSS and some other image secret sharing technologies.
Our TiOISSS VCS [1–17] PISSS [28] PISSS with shrunk
secret on shadow [30]
PISSS with
authentication [32]
EVCS [18]
Feature of
scheme
Sharing secret image into
shadows with two decoding
options
Sharing secret image
into shadows
Sharing secret image into
shadows
Sharing secret image into
shadows with
authentication ability
Sharing secret image
into shadows
Shadow
images
Noise-like random dots on
shadow images
A shrunken version of
secret image on shadow
images
Meaningful images on shadow images
Secret image Two secret images: a halftone
image and a gray image
Halftone, gray, or
color
Gray secret image (note: the approach can be extended to color secret image
by processing each color plane)
Halftone
Image quality
of decoded
image
The vague image in Phase 1,
and the perfect reconstruction
of gray image in Phase 2
Vague Perfect
reconstruction of
original secret
Reconstruction of secret
image with high PSNR
Perfect reconstruction of
original secret
Vague
Stacking-to-see
property
Yes Yes No No No Yes
Perfect
reconstruction
of secret
Yes No Yes No Yes No
Decoding
options
Two One One One One One
Decoding
complexity
Phase 1 — easy: stack shadows
and directly decode by HVS
Easy: stack shadows
and directly decode
by HVS
Hard: use lagrange interpolation to reconstruct the secret image Easy: stack shadows
and directly decode
by HVSPhase 2 — hard: use Lagrange
interpolation
1609C.-N. Yang, C.-B. Ciou / Image and Vision Computing 28 (2010) 1600–1610
Constructions and properties of k out of n scalable secret image sharing
Ching-Nung Yang *, Sin-Ming Huang
Department of Computer Science and Information Engineering, National Dong Hwa University, #1, Sec. 2, Da Hsueh Rd., Hualien, Taiwan
a r t i c l e i n f o
Article history:
Received 26 September 2009
Received in revised form 30 December 2009
Accepted 30 December 2009
Keywords:
Secret sharing
Image secret sharing
Lagrange interpolation
Shadow image
Steganography
a b s t r a c t
Recently, Wang et al. introduced a novel (2, n) scalable secret image sharing (SSIS) scheme, which can
gradually reconstruct a secret image in a scalable manner in which the amount of secret information
is proportional to the number of participants. However, Wang et al.’s scheme is only a simple 2-out-
of-n case. In this paper, we consider (k, n)-SSIS schemes where a qualiﬁed set of participants consists
of any k participants. We provide two approaches for a general construction for any k, 2 6 k 6 n. For
the special case k = 2, Approach 1 has the lesser shadow size than Wang et al.’s (2, n)-SSIS scheme, and
Approach 2 is reduced to Wang et al.’s (2, n)-SSIS scheme. Although the authors claim that Wang
et al.’s (2, n)-SSIS scheme can be easily extended to a general (k, n)-SISS scheme, actually the extension
is not that easy as they claimed. For the completeness of describing the constructions and properties of a
general (k, n)-SSIS scheme, both approaches are introduced in this paper.
 2010 Elsevier B.V. All rights reserved.
1. Introduction
Secret image sharing (SIS) scheme shares a secret image into
some shadow images (referred to as shadows) that distributed to
participants. A set of qualiﬁed participants can recover the secret
image, while non-qualiﬁed subsets of participants have no infor-
mation about the secret image. The concept of SIS scheme is usu-
ally referred to as a (k, n)-threshold scheme, k 6 n, in which k is
a threshold value to reveal the secret and n is the total number
of shadows. One can reconstruct a secret image by k or more shad-
ows, while he cannot gain any information from less than k shad-
ows. There are two major kinds of SIS schemes: one is the visual
cryptography scheme (VCS) and the other is the polynomial-based
SIS scheme. In VCS, the decoding process is performed directly by
the human eyes, while the polynomial-based SIS scheme needs
some processing to reconstruct the secret image.
The beauty of VCS scheme is that the qualiﬁed subsets of partic-
ipants are able to recover the secret image without any crypto-
graphic knowledge. Due to the unconditional security and the
stacking-to-see property, VCS provides new and secure imaging
applications. As far, VCS has been applied to numerous applications
including visual authentication, steganography, and image encryp-
tion. For example, the stacking-to-see property can securely and
cheaply share a printed-text secret image (such as a password) in
situations where no computer assistance is available or desirable.
The ﬁrst VCS encrypted a black-and-white secret image into
noise-like shadows [1]. Most studies tried to enhance the visual
quality or reduce the pixel expansion [2–4]. Some other studies
consider gray and chromatic VCSs to broaden the application pos-
sibilities [5–11]. Besides, some extended VCSs had meaningful
shadows to address the suspect problem caused by noise-like
shadows [12,13]. VCSs having speciﬁc features (such as sharing
multiple secrets, cheating prevention, keeping aspect ratio invari-
ant) were given in Refs. [14–17]. Two variant VCSs, a progressive
VCS [18] and a multilevel VCS [19], could gain the resolution of a
secret image gradually by stacking more shadows.
Usually, the underlying operation of VCS is OR-operation, and
this results in the poor visual quality. A lossless SIS scheme which
can reconstruct the original secret image is the polynomial-based
SIS scheme. Thien et al. used the secret pixels as all coefﬁcients
in a (k  1)-degree polynomial to construct a (k, n)-SIS scheme
[20], and Wang et al. further reduced the shadow size by using
the Huffman code [21]. Shadows in [20,21] are noise-like. It would
be beneﬁcial to design a SIS scheme with the ability of steganogra-
phy, i.e. the shadow looks like the cover image (a pre-selected
meaningful image). Two user-friendly (k,n)-SIS schemes [22,23]
produced the shadow with a shrunken secret image on it. Besides,
Lin et al. added the authentication capability into the (k, n)-SIS
scheme by using a 4-pixel block [24]; afterwards, the schemes in
Refs. [25–28] solved the weak authentication in Ref. [24], and en-
hanced the detection ratio of manipulating shadows.
Generally, the conventional SIS scheme only has the threshold
property that recovers either the entire image or nothing, and this
limits its possible applications. Recently, Wang et al. recommended
adding the scalable decoding capability (the scalability) into the
threshold scheme. The so-called scalability is that the amount of
secret information is proportional to the number of shadows used
0030-4018/$ - see front matter  2010 Elsevier B.V. All rights reserved.
doi:10.1016/j.optcom.2009.12.077
* Corresponding author. Tel.: +886 3 8634025; fax: +886 3 8634010.
E-mail address: cnyang@mail.ndhu.edu.tw (C.-N. Yang).
Optics Communications 283 (2010) 1750–1762
Contents lists available at ScienceDirect
Optics Communications
journal homepage: www.elsevier .com/ locate/optcom
fOi1 ;Oi2 ; . . . ;Oitg. So, any t participants can recover t sub-images,
and all n participants will have the original image O (since
O = O1 [ O2 [    [ On). Finally, Wang et al.’s (2, n)-SSIS scheme
could gradually reveal a secret image. Since Wang et al.’s (2, n)-SSIS
scheme uses the (2, 2)-SIS scheme, thus j Oyx j¼j Ox j =2 ¼j O j =2n.
From Eq. (3), we have the shadow size as follows
Sij j ¼
[n
x¼1
Oyx

 ¼Xn
x¼1
Oyx
  ¼Xn
x¼1
jOj=2nð Þ ¼ jOj=2: ð4Þ
Actually, in Wang et al.’s (2, n)-SSIS scheme, the authors pro-
posed three modes to partition an image O into n sub-images
{O1, O2, . . ., On}, which are so-called as the multi-secret mode, the
priority mode and the progressive mode. Each sub-image should
hold two properties – (1) the disjoint property: any two sub-
images do not have the same overlapping information, i.e.,
Oi \ Oj = ; for i– j, (2) the union property: their union is the origi-
nal image O, i.e., O = O1 [ O2 [    [ On. Actually, the disjoint prop-
erty provides the scalability, and the union property assures all
participants of the perfect reconstruction of a secret image. Three
partition modes are, respectively, described below.
2.2.1. Multi-secret mode
This partition is the spatial partition. Fig. 1a shows a partition
example, which an image O is ‘‘spatially” partitioned into four
disjoint sub-images {O1, O2, O3, O4}. It is observed that these four
sub-images satisfy the disjoint property and the union property.
If the image O is equally partitioned, we then have jO1j = jO2j =
jO3j = jO4j = jOj/4. Notice that we often use the same sub-image
size; however it s not necessary.
2.2.2. Priority mode
The priority mode divides an image according to the bit-planes.
For example, if we need four sub-images, we could use two out of
eight bits in every pixel of O to generate fO01, O02, O03, O04g; for exam-
ple the bit-planes (b7b6), (b5b4), (b3b2), (b1b0) are extracted to form
O01, O
0
2, O
0
3 and O
0
4, where (b7, b6, . . ., b0) is a 8-bit pixel in O. Such
partition is denoted as O01 : ðb7b6Þ, O02 : ðb5b4Þ, O03 : ðb3b2Þ,
O04 : ðb1b0Þ, and is shown in Fig. 1b. The different gray color in
Fig. 1b represents the different resolution.
2.2.3. Progressive mode
The progressive mode is a combination of the multi-secret
mode and the priority mode. For example, we construct four sub-
images fO001, O002, O003, O004g by combining the multi-secret mode in
Fig. 1a and the priority mode in Fig. 1b. The sub-image O001 embraces
(b7b6), (b5b4), (b3b2) and (b1b0) in O1, O2,O3 and O4, respectively, and
the partition is denoted as O001 ¼ ðO1  O2  O3  O4Þ : ðb7b6  b5b4
b3b2  b1b0Þ. Other three sub-images are O002 ¼ ðO1  O2  O3
O4Þ : ðb1b0  b7b6  b5b4  b3b2Þ; O003 ¼ ðO1  O2  O3  O4Þ : ðb3b2
b1b0  b7b6  b5b4Þ; O004 ¼ ðO1  O2  O3  O4Þ : ðb5b4  b3b2  b1
b0  b7b6Þ. Fig. 1c reveals these four sub-images.
Fig. 1. Three partition modes: (a) the multi-secret mode (b) the priority mode using O01 : ðb7b6Þ; O02 : ðb5b4Þ;O03 : ðb3b2Þ; O04 : ðb1b0Þ (c) the progressive mode combining the
multi-secret mode in (a) and the priority mode in (b) O001 ¼ ðO1  O2  O3  O4Þ : ðb7b6  b5b4  b3b2  b1b0Þ; O002 ¼ ðO1  O2  O3  O4Þ : ðb5b4  b3b2  b1b0  b7b6Þ;
O003 ¼ ðO1  O2  O3  O4Þ : ðb3b2  b1b0  b7b6  b5b4Þ; O004 ¼ ðO1  O2  O3  O4Þ : ðb1b0  b7b6  b5b4  b3b2Þ.
1752 C.-N. Yang, S.-M. Huang /Optics Communications 283 (2010) 1750–1762
3.1.1. Encoding of Approach 1
Input: a secret image O.
Output: n shadows Si, i 2 [1, n].
(1) Obtain Ox, x 2 1; nk
 	 

, by P(O).
(2) For every image Ox, create k sub-shadows ðO1x ,O2x , . . ., OkxÞ by
Ek,k(Ox).
(3) Set S1 = S2 =    = Sn = ;.
(4) Choose a matrix Bn,k = [bij].
(5) For j = 1 to n
k
 
do
{Set y = 1;
For i = 1 to n
{If bij = 1 then bOij ¼ Oyj and y = y + 1; else bOij ¼ ;;}
};
(6) Si ¼
S nkð Þ
j¼1
bOij; i 2 ½1;n:
/* generate n shadows S1, S2, . . . ,Sn */
3.1.2. Decoding of Approach 1
Input: n shadows Si, i 2 [1, n].
Output: Rt, where tP k.
(1) All participants extract their bOij, j 2 1; nk
 	 

, from their
own shadows Si, i 2 [1, n], respectively.
(2) For any t (Pk) shadows, a participant ﬁnds the correspond-
ing sub-shadows Oyx from his bOij.
(3) Decode the sub-images Ox via Dk,k(), which have k sub-
shadows (i.e. satisfy the threshold property).
(4) Assemble the decoded sub-images in Eq. (3) to obtain a
reconstructed imageRt.
The required conditions of a SSIS scheme were not described in
the previous paper [29]. However, to show the security and the
scalability in terms of inf(Rt), the formal required conditions (the
security condition and the scalability condition) of our (k, n)-SSIS
scheme are deﬁned as follows.
(1) [Security condition]: inf(Rt) = 0 for t 6 (k–1).
(2) [Scalability condition]: inf(Rt) < inf(Rt+1) for k 6 t 6 n, and
inf(Rn) = 1.
The security condition assures the (k, n)-SSIS scheme of the per-
fect secrecy. Satisfying condition (1) implies achieving the thresh-
old property, which no secret information can be obtained from
less than k shadows. The second condition shows that the quality
of a reconstructed image is proportional to the number of shadows
above the given threshold (i.e., the scalability property). Also, The
value of inf(Rn) = 1 assures that all participants can successfully
reconstruct the complete secret image.
Theorem 1. The scheme from Approach 1 is a (k, n)-SSIS scheme
with the shadow size 1/n times to the secret image.
Proof. Suppose a secret image is O. We ﬁrst prove that the shadow
size is jOj/n. In Approach 1, an image O is divided into nk
 
disjoint
sub-images with the size jOj= n
k
 
. Since every column vector in
Bn,k has k ‘‘1” and (n-k) ‘‘0”, each row vector in Bn,k will have
n 1
k 1
 
‘‘1”. From Step (5) and Step (6) in encoding of Approach 1,
we have bOij ¼ ; for bij = 0 and Si ¼ S nkð Þj¼1 bOij; i 2 ½1;n: So, a shadow jSij
has n 1
k 1
 
sub-shadows, and the shadow size is calculated as
jSij¼ jOj= nk
 
 1=kð Þ  n 1k 1
 
¼ jOj=n.
To prove the security condition, since t (t 6 k  1) rows in Bn,k do
not have k ‘‘1”, there are no enough k sub-shadows to reconstruct
any one sub-image and thus the value of inf(Rt) is 0. Regarding the
scalability condition, any t (Pk) rows in Bn,k have
t
k
 
t-tuples
have k ‘‘1”, which assures that we have enough sub-shadows to
reconstruct a sub-image. Thus, we can recover tk
 
disjoint sub-
images to assemble a reconstructed imageRt. Since the number of
all sub-images is nk
 
, inf ðRtÞ ¼ tk
 ,
n
k
 
for k 6 t 6 n. Because
t
k
 ,
n
k
 
<
t þ 1
k
 ,
n
k
 
, we have inf(Rt) < inf(Rt+1) for
k 6 t 6 n. Obviously, the value of inf ðRnÞ ¼ nk
 ,
n
k
 
¼ 1.
As described above, the (k, n)-SSIS scheme from Approach 1
satisﬁes conditions (1) and (2), and it is a (k, n)-SSIS scheme. h
The following example shows a (k, n)-SSIS scheme with k > 2.
Example 2. Generate four shadows of a (3, 4)-SSIS scheme by
Approach 1.
A secret image O is ﬁrst spatially partitioned into four (since
4
3
 
¼ 4) sub-images, O1, O2, O3 and O4, using the multi-secret
mode. Each sub-image is encrypted into three sub-shadows by a
polynomial-based (3, 3)-SIS scheme. We then have 12 sub-shad-
ows, Oyx where 1 6 x 6 4 and 1 6 y 6 3, and each sub-shadow has
the size j O j =12ðsince j Oyx j¼j Ox j =3 ¼j O j =12Þ. The matrix
Bn,k = B4,3 of a (3, 4)-SSIS scheme is
B4;3 ¼
b11 b12 b13 b14
b21 b22 b23 b24
b31 b32 b33 b34
b41 b42 b43 b44
26664
37775 ¼
1 1 1 0
1 1 0 1
1 0 1 1
0 1 1 1
26664
37775: ð6Þ
According to Step (5) in encoding and Eq. (6), the bOijh i are created as
follows.
bOijh i ¼
bO11 bO12 bO13 bO14bO21 bO22 bO23 bO24bO31 bO32 bO33 bO34bO41 bO42 bO43 bO44
2666664
3777775 ¼
O11 O
1
2 O
1
3 ;
O21 O
2
2 ; O14
O31 ; O23 O24
; O32 O33 O34
266664
377775: ð7Þ
Four shadows, S1, S2, S3, S4, are then generated by
Si ¼
S4
j¼1
bOij; i 2 ½1; 4:
S1 ¼ bO11 [ bO12 [ bO13 [ bO14 ¼ O11 [ O12 [ O13 [ ; ¼ O11 [ O12 [ O13;
S2 ¼ bO21 [ bO22 [ bO23 [ bO24 ¼ O21 [ O22 [ ; [ O14 ¼ O21 [ O22 [ O14;
S3 ¼ bO31 [ bO32 [ bO33 [ bO34 ¼ O31 [ ; [ O23 [ O24 ¼ O31 [ O23 [ O24;
S4 ¼ bO41 [ bO42 [ bO43 [ bO44 ¼ ; [ O32 [ O33 [ O34 ¼ O32 [ O33 [ O34:
ð8Þ
From Eq. (8), the shadow size jS1j is O11
 þ O12 þ O13  ¼j O j =12
3 ¼j O j =4; also, we have jS2j = jS3j = jS4j = jOj/4. When using three
shadows in reconstruction, we will obtain O1 from {S1, S2, S3}, O2
from {S1, S2, S4}, O3 from {S1, S3, S4}, and O4 from {S2, S3, S4}. So,
inf(R3) = 1/4. When all shadows {S1, S2, S3, S4} are jointly used for
1754 C.-N. Yang, S.-M. Huang /Optics Communications 283 (2010) 1750–1762
Proof. Suppose a secret image is O. We ﬁrst prove that the shadow
size is jOj/k. In Approach 2, an image O is divided into n
k 1
 
dis-
joint sub-images with size jOj
,
n
k 1
 
. Since
Si ¼
S nk1ð Þ
j¼1
bOij; i 2 ½1;n, every shadow has nk 1
 
sub-shadows,
so the shadow size is jOj
,
n
k 1
 
 1=kð Þ  nk 1
 
¼ jOj=k.
To prove the security condition, t (6k–1) rows in B0n;k1 do not
have (k-1) ‘‘1” and at least 1 ‘‘0”, and there are no enough k sub-
shadows to reconstruct any one sub-image. Thus, the value of
inf(Rt) is 0 for t 6 k–1. Consider the scalability condition. Every
column vector has (k-1) ‘‘1” and (n-k+1) ‘‘0”. So, any t (Pk) rows in
B0n;k1 have
t
k 1
 
t-uples with (k-1) ‘‘1” and (t-k+1) ‘‘0”, which
assures that we have enough sub-shadows for reconstructing a
sub-image. Therefore, we can recover tk 1
 
sub-images and
assemble a reconstructed imageRt for t (Pk) shadows. Since the
number of recovered sub-images is tk 1
 
and the number of
total sub-images is nk 1
 
, inf ðRtÞ ¼ tk 1
 ,
n
k 1
 
for
k 6 t 6 n. Because tk 1
 ,
n
k 1
 
<
t þ 1
k 1
 ,
n
k 1
 
, we
have inf(Rt) < inf(Rt+1) for k 6 t 6 n. Obviously, the value of
inf ðRnÞ ¼ nk 1
 ,
n
k 1
 
¼ 1.
As described above, the (k, n)-SSIS scheme from Approach 2
satisﬁes conditions (1) and (2), and it is a (k, n)-SSIS scheme. h
Example 4. Generate four shadows of a (3, 4)-SSIS scheme by
Approach 2.
A secret image O is ﬁrst spatially partitioned into six (since
4
2
 
¼ 6) sub-images,O1, O2, . . ., O6, using the multi-secret mode.
Each sub-image is encrypted into three sub-shadows by a polyno-
mial-based (3, 3)-SIS scheme. We then have 18 sub-shadows with
the size jOj/18. The matrix B0n;k1 ¼ B04;2 and bOijh iof a (3, 4)-SSIS
scheme are shown as follows:
B04;2 ¼
b11 b12 b13 b14 b15 b16
b21 b22 b23 b24 b25 b26
b31 b32 b33 b34 b35 b36
b41 b42 b43 b54 b45 b46
26664
37775 ¼
1 1 1 0 0 0
1 0 0 1 1 0
0 1 0 1 0 1
0 0 1 0 1 1
26664
37775:
ð12Þ
bOijh i¼
bO11 bO12 bO13 bO14 bO15 bO16bO21 bO22 bO23 bO24 bO25 bO26bO31 bO32 bO33 bO34 bO35 bO36bO41 bO42 bO43 bO44 bO45 bO46
2666664
3777775¼
O21 O
2
2 O
2
3 O
1
4 O
1
5 O
1
6
O31 O
1
2 O
1
3 O
2
4 O
2
5 O
1
6
O11 O
3
2 O
1
3 O
3
4 O
1
5 O
2
6
O11 O
1
2 O
3
3 O
1
4 O
3
5 O
3
6
266664
377775:
ð13Þ
Four shadows, S1, S2, S3, S4, are then generated by
Si ¼
S6
j¼1
bOij; i 2 ½1; 4:
S1 ¼ bO11 [ bO12 [ bO13 [ bO14 [ bO15 [ bO16 ¼ O21 [ O22 [ O23 [ O14 [ O15 [ O16;
S2 ¼ bO21 [ bO22 [ bO23 [ bO24 [ bO25 [ bO26 ¼ O31 [ O12 [ O13 [ O24 [ O25 [ O16;
S3 ¼ bO31 [ bO32 [ bO33 [ bO34 [ bO35 [ bO36 ¼ O11 [ O32 [ O13 [ O34 [ O15 [ O26;
S4 ¼ bO41 [ bO42 [ bO43 [ bO44 [ bO45 [ bO46 ¼ O11 [ O12 [ O33 [ O14 [ O35 [ O36:
ð14Þ
The shadow size S1j j ¼ O21
 þ O22 þ O23 þ O14 þ O15 þ O16  j¼
j O j =18 6 ¼j O j =3; also, we have jS2j = jS3j = jS4j = jOj/3. When
using three shadows in reconstruction, we will obtain O1, O2 and
O4 from {S1, S2, S3}, O1, O3 and O5 from {S1, S2, S4}, O2, O3 and O6 from
{S1, S3, S4}, O4, O5 and O6 from {S2, S3, S4}. So, inf(R3) = 3/6 = 1/
2.When all shadows {S1, S2, S3, S4} are jointly used in reconstruc-
tion, a complete secret image O = O1 [ O2 [ O3 [ O4 [ O5 [ O6 can
be obtained and thus inf(R4) = 1. It is obvious that any one shadow
or any two shadows do not have enough sub-shadows for recon-
structing a sub-image, and thus inf(R1) = inf(R2) = 0.
Approach 2 will be reduced to Wang et al.’s (2, n)-SSIS scheme
for k = 2. The following example shows a (2, 4)-SSIS scheme using
Approach 2.
Example 5. Generate four shadows of a (2, 4)-SSIS scheme by
Approach 2.
A secret image O is ﬁrst spatially partitioned into four (since
4
1
 
¼ 4) sub-images using the multi-secret mode: O1, O2, O3 and
O4. Each sub-image is encrypted into two sub-shadows by a
polynomial-based (2, 2)-SIS scheme. We then have 8 sub-shadows,
and each sub-shadow has the size jOj/8. The matrix B0n;k1 ¼ B04;1
and bOijh i of a (2, 4)-SSIS scheme are shown as follows:
B04;1 ¼
b11 b12 b13 b14
b21 b22 b23 b24
b31 b32 b33 b34
b41 b42 b43 b44
26664
37775 ¼
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
26664
37775: ð15Þ
bOijh i ¼
bO11 bO12 bO13 bO14bO21 bO22 bO23 bO24bO31 bO32 bO33 bO34bO41 bO42 bO43 bO44
2666664
3777775 ¼
O21 O
1
2 O
1
3 O
1
4
O11 O
2
2 O
1
3 O
1
4
O11 O
1
2 O
2
3 O
1
4
O11 O
1
2 O
1
3 O
2
4
266664
377775: ð16Þ
Fig. 3. Ten sub-images O1-O10 partitioned from a secret image Jet.
1756 C.-N. Yang, S.-M. Huang /Optics Communications 283 (2010) 1750–1762
Wang et al.’s (2, n)-SSIS scheme. Scheme IV implies that Approach
2 is reduced to Wang et al.’s (2, n)-SSIS scheme for k = 2. On the
other hand, Schemed V and VI show the performance of our ap-
proaches using the priority mode and the progressive mode. All
schemes reveal that our general (k, n)-SSIS schemes have the sca-
lability property. Consider that a secret image can be exactly par-
titioned into different sub-images used in the above all
experiments. A natural gray image 510  510-pixel Jet is used as
a secret image.
Example 6. Construct the (3, 5)-SSIS scheme by Approach 1 using
Jet as a secret image.
Since nk
 
¼ 53
 
¼ 10, we ﬁrst divide a 510  510 Jet into ten
255  102 sub-images O1 – O10, as shown in Fig. 3. By E3,3(Ox), we
then have three 255  34 sub-shadows (O1x , O2x , O3x ) for each sub-
image Ox (since k = 3, so j O1x j¼j O2x j¼j O3x j¼j Ox j =3 ¼j O j =30).
The matrix B5,3 of a (3, 5)-SSIS scheme is shown below.
B5;3 ¼
1 1 1 1 1 1 0 0 0 0
1 1 1 0 0 0 1 1 1 0
1 0 0 1 1 0 1 1 0 1
0 1 0 1 0 1 1 0 1 1
0 0 1 0 1 1 0 1 1 1
26666664
37777775: ð18Þ
Fig. 5. The reconstructed images of (3, 5)-SSIS scheme using Approach 2 for different numbers of shadows: (a1)–(a10) ten R3 images with inf(R3) = 3/10 (b1)–(b5) ﬁve R4
images with inf(R4) = 6/10, (c) the R5 image with inf(R5) = 1.
1758 C.-N. Yang, S.-M. Huang /Optics Communications 283 (2010) 1750–1762
Fig. 8. The reconstructed images of (2, 5)-SSIS scheme using Approach 2 for different numbers of shadows: (a) a R2 image from {S1, S2} with inf(R2) = 2/5, (b) a R3 image from
{S1, S2, S3} with inf(R3) = 3/5, (c) a R4 image from {S1, S2, S3, S4} with inf(R4) = 4/5, (d) the R5 image with inf(R5) = 1.
Fig. 9. The reconstructed images of (3, 4)-SSIS schemes using priority modes: (a) Approach 1 using the priority O01 : ðb7b0Þ; O02 : ðb6b1Þ; O03 : ðb5b2Þ; O04 : ðb4b3Þ, (b) Approach 1
using the priority O01 : ðb7b6Þ; O02 : ðb5b4Þ; O03 : ðb3b2Þ; O04 : ðb1b0Þ (c) Approach 1 using the priority O01 : ðb7b3Þ; O02 : ðb6b2Þ; O03 : ðb5b1Þ; O04 : ðb4b0Þ (d) Approach 2 using the
priority O01 : ðb7Þ; O02 : ðb6Þ; O03 : ðb5Þ; O04 : ðb4Þ; O05 : ðb3b2Þ; O06 : ðb1b0Þ.
1760 C.-N. Yang, S.-M. Huang /Optics Communications 283 (2010) 1750–1762
has the lesser shadow size (jOj/6) than that of Wang ’s (2, n)
scheme (jOj/2). Although, the amount of information of our two ap-
proaches for the general scheme (k > 2) is not ‘‘smoothly” propor-
tional to the number of shadows engaged in decoding. Our
approaches actually are the ﬁrst general (k, n)-SSIS schemes. Ap-
proach 1 trades the scalability for the shadow size, and Approach
2 is an extension of Wang et al.’s scheme.
The threshold property and the scalability property indicate the
wide range of potential applications. We believe that our (k, n)-SSIS
scheme with the generality (kP 2) and the small shadow size will
serve as a basis for more applications. Some concrete application
examples are shown as follows to illustrate the real cases of our
scheme.
(1) The conventional SIS scheme only has the threshold prop-
erty that recovers either the entire image or nothing, and
this limits its possible applications. In some cases we may
require the input image to be gradually revealed depending
on the number of the participants. It is a reasonable applica-
tion scenario that the majority in the participants will reveal
the more sub-images.
(2) Suppose a participant holds a certain sub-shadow of the spe-
ciﬁc sub-image. When revealing the speciﬁc sub-image, this
participant must be involved in the decryption process. For
example, we may assign different priorities to different par-
ticipants such that those participants with the higher prior-
ities will obtain the important secret information.
(3) The progressive mode could provide the multiple-resolution
of a secret image. This multi-resolution property can be used
for the multiple-level service for the secret image distribu-
tion and transmission in which the secret can be revealed
at different levels.
(4) Consider the application in an image distribution system.
The n shadows are delivered, and each shadow is stored in
any distributed storage node. Owing to the threshold prop-
erty and the scalability property of a (k, n)-SSIS scheme,
the failure of (n-k) shadows during transmission merely
loses the resolution of the image and does not affect the
reconstruction phase.
5. Conclusion
There are two main achievements in our (k, n)-SSIS scheme- the
ﬁrst is to give two construction methods of the general (k, n)-SSIS
schemes, and the second is the less shadow size which will be
more suitable for faster transmission in an image distribution sys-
tem. As we know using nk 1
 
locks and n 1k 1
 
keys per par-
ticipant is a trivial solution to construct a (k, n)-threshold scheme,
these locks and keys become increasingly difﬁcult to manage and
store. However, this solution can be directly to implement a (k,
n)-SSIS scheme. Our both approaches do not provide the smooth
scalability. How to design a general (k, n)-SSIS scheme with the
smooth scalability is interesting and deserves further studying.
We leave this as an open problem.
Acknowledgment
This work was supported in part by the Testbed@TWISC, Na-
tional Science Council under the Grants NSC 98-2219-E-006-001.
References
[1] M. Naor, A. Shamir, Lect. Notes Comput. Sci. 950 (1995) 1.
[2] R. ITO, H. Kuwakado, H. Tanaka, IEICE Trans. Fund. Elect. Comm. Comput. Sci.
E82-A (1999) 2172.
[3] C.N. Yang, Pattern Recognit. Lett. 25 (2004) 481.
[4] S. Cimato, R. De Prisco, A. De Santis, Comput. J. 49 (2006) 97.
[5] M. Iwamoto, H. Yamamoto, IEICE Trans. Fund. Elect. Commun. Comput. Sci.
E85-A (2002) 2238.
[6] C.C. Lin, W.H. Tsai, Pattern Recognit. Lett. 24 (2003) 349.
[7] E.R. Verheul, H.C.A. Van Tilborg, Codes Cryptography 11 (1997) 179.
[8] C.N. Yang, C.S. Laih, Codes Cryptography 20 (2000) 325.
[9] J.C. Hou, Pattern Recognit. 36 (2003) 1619.
[10] S.J. Shyu, Pattern Recognit. 39 (2006) 866.
[11] C.N. Yang, T.S. Chen, Pattern Recognit. 41 (2008) 3114.
[12] G. Ateniese, C. Blundo, A. De Santis, D.R. Stinson, Theor. Comput. Sci. 250
(2001) 143.
[13] C.N. Yang, T.S. Chen, Int. J. Pattern Recognit. Artif. Intell. 21 (2007) 879.
[14] S.J. Shyu, S.Y. Huang, Y.K. Lee, R.Z. Wang, K. Chen, Pattern Recognit. 40 (2007)
3633.
[15] J.B. Feng, H.C. Wu, C.S. Tsai, Y.F. Chang, Y.P. Chu, Pattern Recognit. 41 (2008)
3572.
[16] D.S. Tsai, T.H. Chen, G. Horng, Pattern Recognit. 40 (2007) 2356.
[17] C.N. Yang, T.S. Chen, Pattern Recognit. 39 (2006) 1300.
[18] W.P. Fang, J.C. Lin, Pattern Recognit. Image Anal. 16 (2006) 638.
[19] R.Z. Wang, Y.K. Lee, S.Y. Huang, T.L. Chia, Inform. Control (2007) 283.
[20] C.C. Thien, J.C. Lin, Comput. Graphics 26 (2002) 765.
[21] R.Z. Wang, C.H. Su, Pattern Recognit. Lett. 27 (2006) 551.
[22] C.C. Thien, J.C. Lin, IEEE Trans. Circuit Syst. Video Technol. 13 (2003) 1161.
[23] C.N. Yang, K.H. Yu, R. Lukac, Int. J. Imaging Syst. Technol. 17 (2007) 40.
[24] C.C. Lin, W.H. Tsai, J. Syst. Software 73 (2004) 405.
[25] C.N. Yang, T.S. Chen, K.H. Yu, C.C. Wang, J. Syst. Software 80 (2007) 1070.
[26] C.C. Wu, S.J. Kao, W.C. Kuo, M.S. Hwang, in: Proceedings of IEEE IIH-MSP, 2008,
p. 1177.
[27] C.C. Chang, Y.P. Hsieh, C.H. Lin, Pattern Recognit. 41 (2008) 3130.
[28] Z. Eslami, S.H. Razzaghi, J.Z. Ahmadabadi, Pattern Recognit. 43 (2010) 397.
[29] R.Z. Wang, S.J. Shyu, Signal Process.: Image Commun. 22 (2007) 363.
[30] A. Shamir, Commun. Assoc. Comput. Mach. 22 (1979) 612.
[31] C.L. Liu, Introduction to Combinatorial Mathematics, McGraw-Hill, New York,
1968.
Table 2
Comparison of the general (k, n)-SSIS schemes.
Scheme Scalability
inf(Rk):inf(Rk+1): . . .:inf(Rt): . . .:inf(Rn1):inf(Rn)
Approach 1 (jSij = jOj/n) 1= n
k
 
: kþ 1ð Þ= n
k
 
: . . . :
t
k
 
=
n
k
 
: . . . : n kð Þ=n : 1
Approach 2 (jSij = jOj/k) k= nk 1
 
: k kþ 1ð Þ=2ð Þ= nk 1
 
: . . . :
t
k 1
 
=
n
k 1
 
: . . . : n kþ 1ð Þ=n : 1
1762 C.-N. Yang, S.-M. Huang /Optics Communications 283 (2010) 1750–1762
國立東華大學 
專任教師出席國際學術會議報告 
 
報告人姓名 楊慶隆 服務機構及職稱 
東華大學資工系 
教授 
會議時間 17-19, Dec 2010 會議地點 中國．北京 
會議 
名稱 
 (中文) 2010 IEEE 資訊理論及資訊安全國際研討會 (ICITIS 2010) 
 (英文) 2010 International Conference on Information Theory and Information Security 
(ICITIS 2010) 
發表 
論文 
題目 
 (中文) 三元詢問樹無線射頻標籤防碰撞機制的設計 
 (英文) A Practical Implementation of Ternary Query Tree for RFID Tag Anti-Collision
報告內容應包括下列各項： 
一、參加會議經過 
1. ICITIS 2010 會議: 
ICITIS 2010 (地點：中國北京)，是北京郵電大學及IEEE主辦的第一屆資訊理論及資訊安全國
際研討會。會議時間為期三天(12月17-19日)。本次會議論文審查和會議內容有一定水準，論
文收錄於IEEE Proceedings及電子期刊資料庫IEEE Xplore中，且納入Ei Compendex 及 ISTP
索引。共計有 650 篇論文投稿，共接受270 篇論文，論文接受率為40%。第二屆資訊理論及
資訊安全國際研討會ICITIS 2011將於明年11月在中國杭州舉行。 
2. 會議經過: 
CSA2009 國際會議舉行時間為 12 月 17 日至 12 月 19 日。本人 12 月 16 日從台灣搭機至中國
北京。12 月 17 日報到後，利用時間帶領東華大學資訊工程系所 1 位博士生及 6 位碩士生，
至北京清華大學計算機科學與技術系王道順教授實驗室參觀、訪問。12 月 18 日參與會議，
並由北郵大學國際合作與交流處的任春霞處長，導覽北郵大學並參觀重點實驗室，當天並與
ICITIS 2010 會議 General Chair 北郵大學信息安全中心主任楊義先教授討論未來合作的可能
(註:北郵大學為東華大學的姐妹校)。12 月 19 日繼續參與會議，12 月 20 日從中國北京搭機返
回台灣。 
3. 會議主題: 
ICITIS2010 會議主要是包含資訊與通訊安全相關的議題，會議總共有六個 oral sessions (1) (1) 
Signal and Information Processing (2) Information Security and Information Network (3) Computer 
Technology and Applications (4) Network and Information Security (5) Communication and 
Information System (6) Network Theory and Technology。 
 三、 考察參觀活動 
(1) 利用 12/17(五)註冊後，至北京清華大學計算機科學與技術系王道順教授實驗室參訪。
(2) 由北郵大學國際合作與交流處的任春霞處長，導覽北郵大學並參觀重點實驗室。 
(3) 參觀北郵大學信息安全中心主任楊義先教授實驗室。 
 
四、 建議 
(1) 大陸地區學者可經營企業，讓學術研究的理論真正落實成為技術研發的成果，有某種程
度的實際成效。我們雖然無法仿效，但是如何讓理論與實務結合是我們應當認真思索。
(2) 此次 ICITIS2010 由北郵大學舉辦，大陸學生在國際會議上英文的表達能力相當不錯。
此次參與會議期間，正巧碰到北郵大學英語四、六級考試，大陸地區對學生英文的要求，
造就了學生良好的英文能力。近年來，我們有些學校也都有類似的英文程度檢定規定、
以提升學生英文素質，此規定應積極推廣。 
 
五、 攜回資料名稱及內容 
(1) 會議論文集一冊: IEEE ICITIS 2010 論文集 (ISBN: 987-1-4244-6940-6)。 
(2) 研討會論文集光碟，ISBN﹕987-1-4244-6941-3，IEEE Catalog Number: CFP1087J-CDR。
(3) Call for papers: (1) 2011 International Symposium on Network Coding (NetCode2011) (2) 
2011 Asia-Pacific Youth Conference on Communication (2011APYCC) (3) 2011 National  
Teaching Seminar on Cryptography and Information Security (NTS-CIS 2011)。 
 
六、 其他  
(會議相關照片) 
       
    (a) ICITIS2010大會主講Kwangjo Kim           (b) 北郵大學國家重點實驗室 
 
 
 
 
國立東華大學 
專任教師出席國際學術會議報告 
 
報告人姓名 楊慶隆 服務機構及職稱 
東華大學資工系 
教授 
會議時間 18-20, January, 2011 會議地點 日本．東京 
會議 
名稱 
 (中文) 2011 電子商務, 電子化政府, 電子化社會, 電子化教育國際研討會 
 (英文) 2011 International Conference on e-Commerce, e-Administration, e-Society, 
e-Education, and e-Technology (e-CASE & e-Tech 2011) 
發表 
論文 
題目 
 (中文) 憑證中的憑證:行動商務的新型憑證設計 
 (英文) Certificate-in-Certificate: Designing A New Certificate Extension for 
Mobile-Commerce 
報告內容應包括下列各項： 
二、參加會議經過 
6. ICITIS 2010 會議: 
ICITIS 2010 (地點：中國北京)，是國際商務學者聯合會(IBAC)及臺灣知識協會主辦的第五屆
e-CASE & e-Tech國際研討會，時間為期三天 (1月18-20日 )，並包含一個Symposium，
International Symposium Marketing and Logistics (ISML 2011)。前四次會議分別在香港、曼谷、
新加坡、澳門等地舉辦。本次會議共計有 560 篇論文投稿，論文接受率為67%。第六屆e-CASE
& e-Tech國際研討會將於明年在日本的Kitakyushu舉行。 
7. 會議經過: 
CSA2009 國際會議舉行時間為 1 月 18 日至 1 月 20 日。本人 1 月 17 日從台灣搭機至日本東京。
1 月 18 日報到後並參加歡迎晚宴，與參加會議學者交流。1 月 19 日參與會議。1 月 20 日繼
續參與會議，並擔任 e-Technology session 主持人，主持會議。1 月 21 日從日本東京搭機返回
台灣。 
8. 會議主題: 
ICITIS2010 會議主要是包含電子商務、電子化政府、電子化社會、電子化教育相關的議題，
會議總共有六個 oral sessions (1) e-Commerce (2) e-Education (3) e-Society (4) e-Education (5) 
e-Technology (6) e-Administration。一些會議主題並有 Poster Sessions。 
9. 論文發表: 
本 人 論 文 “Certificate-in-Certificate: Designing A New Certificate Extension for Mobile-
Commerce”，主題是 e-Commerce，為 oral presentation。論文刊載於大會論文集 pp. 554-564。
論文發表由本人博士班吳志成同學報告，本人擔任大會的 e-Technology session 的主持人。 
吳宗杉教授、台東大學張耀中教授等。 
 
三、 考察參觀活動 
     無。 
 
四、 建議 
     本人此次在大會主持的 session，有一個 presentation 作者缺席，餐與國際會議但是 no show
是不佳的典範。鼓勵老師、學生參與國際會議時，也要注意此項問題。 
 
五、 攜回資料名稱及內容 
(4) 研討會論文集光碟 Proceedings of e-CASE & e-Tech 2011，ISBN﹕2074-5710。 
(5) Call for papers: (a) 2011 International Symposium on Business And Information (BAI2011) 
(b) The 2012 International Conference on e-Commerce, e-Administration, e-Society, 
e-Education and e-Technology (e-CASE & e-Tech 2012)。 
(6) 期刊一本: International Journal of BUSINESS and INFORMATION, Vol. 5, No. 1, June 
2010。 
 
六、 其他  
(會議相關照片) 
     
     (a) e-CASE & e-Tech 2011歡迎晚宴     (b)本人主持的session，演講者Mehdi Asgarkhani 
     
   (c) 本人主持的session，演講者 Prof. Tsai  (d) 本人與博士班吳志成同學生在會場合影 
0940222 修訂/表 RD104 
http://mail.ndhu.edu.tw/cgi-bin/msg_read?cmd=print_mail&m=40864...
1 of 1 2010/11/9 下午 10:36
來源: etech2011@gmail.com
收信: cnyang@mail.ndhu.edu.tw
日期: Tue, 28 Sep 2010 18:32:16 +0800
標題: e-CASE & e-Tech 2011--- Acceptance Notification and Invitation Letter
(1091)
Acceptance Notification and Invitation Letter
2011 International Conference on e-Commerce, e-Administration, e-Society, e-Education, and
e-Technology  (e-CASE & e-Tech 2011)
Toshi Center Hotel, Tokyo, Japan
January 18-20, 2011
Paper Number: 1091
Paper Title: Certificate-in-Certificate: Designing A New Certificate Extension for Mobile-Commerce
Author: Ching-Nung YAng, Gen-Cheng Wu, Chih-Cheng Wu
Dear Ching-Nung Yang,
It is our pleasure to inform you that your paper has passed the review process
and been accepted by the e-CASE & e-Tech 2011.  The Program Committee would like to invite you to
attend the e-CASE & e-Tech 2011 in Tokyo.
We kindly ask you to prepare and upload your final version of paper together
with your registration before the deadline of November 10, 2010. For a paper or abstract to be included in 
the conference proceedings, at least one author
must register and pay the registration fees before the deadline. You can find all information at the 
conference website.
http://www.e-case.org/2011
If you have any questions, please do not hesitate to contact Conference Coordinator
Dr. Chien-Kuo Li at eCASE2011@gmail.com
Once again, thank you very much for your contribution. We hope to welcome you at the Toshi Center Hotel
in January, 2011.
Yours sincerely,
Chien-Kuo Li, Ph.D.
Coordinator of e-CASE & e-Tech 2011
unnecessary inquiries when applying QT protocol. If we had 
queried all the nodes (the successful identified nodes and the 
collided nodes), we may skip the remainder leaves of this 
collided node to avoid the unnecessary inquiries. However, 
this approach is only effective for the idle nodes at the tail 
leaves. As shown in Fig. 1, the idle nodes marked by a 
dotted line can be discarded. In this paper, we design a TQT 
that combines 3B2T conversion and the approach discarding 
the unnecessary inquiries to enhance the efficiency. 
Figure 1. Identification of eight tags using MQT with M=8.
B. 3B2T Conversion 
Since 296<261, we can convert a binary 96-bit (EPC)2 to 
61 ternary digits to (EPC)3. However this conversion cannot 
be implemented efficiently by a light-weight tag. In this 
paper, we propose a practical 3B2T conversion to convert 3 
bits to 2 ternary digits one time. As shown in Fig. 2, we 
have total 2(96/3)=64 ternary digits, which is slightly 
greater than 61. Actually, we can identify tags successfully 
without requiring all 64 ternary digits. Therefore, applying 
TQT on 61-digit (EPC)3 and 64-digit (EPC)3 will have the  
almost same performance. 
Figure 2. 3B2T conversion.
C. The Proposed TQT 
The proposed TQT algorithm using 3B2T and discarding 
the unnecessary inquiries is shown in Fig. 3. Some notations 
are first defined. 
NOTATION USED
t
the tag’s ternary ID, a y-tuple t=(t1, t2, …, ty), where 
ti{0, 1, 2}, 1iy, and y is the length of tag’s ID; for 
example EPC has y=64
q
the query string sent from a reader , the x-tuple q=(q1,
q2, …, qx), where qi{0, 1, 2}, 1ix; x is the length of 
a query string
Q a queue maintained by a reader storing the query strings
Push (Q, s) push a query string s into the queue Q
Pop (Q) pop a query string q=Pop(Q) from the queue Q
V(q, t)
verify q whether matches the prefix of tag’s (EPC)3,
i.e., 
1 2 | |
? ( ,  ,  , )
q
q t t t  ; if q= 1 2 | |( ,  ,  , ) qt t t  then  
V(q, t)=1 else V(q, t)=0
Let 3B2T() be a conversion operation to gain (EPC)3=
3B2T((EPC)2). Note: the string t and q used in the proposed 
TQT algorithm are ternary digits, which ti{0, 1, 2} and 
qi{0, 1, 2}. A tag’s ID will be first converted to a (EPC)3
code t=(t1, t2, …, t64). Notice that we only process the 3B2T 
conversion in need of ti, 1i64, and thus we do not have to 
covert 96-bit (EPC)2 one time. When the tag is uniquely 
identified the tag responds its (EPC)2. Also, we skip the 
remainder leaves of a collided node to avoid the unnecessary 
inquiries. 
Figure 3. The proposed TQT algorithm by using 3B2T and discarding the 
unnecessary inquiries.
Example 1. Suppose nine tags have length of tag’s ID 9 bits, 
which are (000000000), (001010000), (0010111 10), 
(001110101), (011000001), (100111010), (101010100), 
(110000111), and (110111010). 
Three bits of nine tags {(000), (001), (001), (001), (011), 
(100), (101), (110), (110)} are first converted to 
{(t1t2)}={(00), (01), (01), (01), (10), (11), (12), (20), (20)} 
by 3B2T. A reader initially pushes (Q, 0), (Q, 1) and (Q, 2) 
in a null queue Q, i.e., the initial Q={0, 1, 2}. When a reader 
broadcasts the query string q=0, a tag with ID t1=0 responds. 
Four tags with the ternary digits (00) and (01) respond. A 
284
a so-called warehouse distribution. As we know, 96-bit EPC 
embraces four sections- the header (H: 8 bits), the GMN (G: 
28 bits), the object class (O: 24 bits), and the serial number 
(S: 36 bits). These items with the similar IDs may have the 
same encoding scheme (header), the same company prefixes 
(GMN), the same object class, and the different serial 
Number. Therefore EPC data of most items from the same 
warehouse will be very similar since the items are 
manufactured by the same company. The tag-collision in a 
warehouse distribution scenario often has the identical lf=60 
bits (H+G+O) and the different ls=36 bits (S). Experimental 
results of NC, NI and NT are shown in TABLE III. It is 
observed that all NT of BQT, MQT and TQT protocols 
increase due to the same prefixes. For n=2000, our TQT 
needs 5571 total interrogation cycles. When discarding tail 
leaves, TQT save 828 idle cycles and has 4762 total 
interrogation cycles. However, BOT and MQT with 
(without) discarding tail leaves needs 5834 (5366) and 
10534 (8257) total interrogation cycles, respectively. Our 
TQT protocol still has the better performance than other two 
protocols for very similar EPC. 
TABLE III. THE VALUES OF NC, NI AND NT FOR TAGS WITH SIMILAR EPC
BQT MQT (M=16) TQT
n NC NI NT NC NI NT NC NI NT
100 206 108 (45)
414 
(351) 49 
651 
(382) 
800 
(531) 139 
167
(74)
406
(313)
200 348 150 (68)
698 
(616) 83 
1067 
(673) 
1350 
(956) 230 
238
(113)
668
(543)
300 487 189(87)
976 
(874) 126
1609 
(1044) 
2035 
(1470) 321 
306
(151)
927
(772)
400 641 243 (117)
1284 
(1158) 168
2139 
(1429) 
2707 
(1997) 427 
405
(207)
1232
(1034)
500 781 283(134)
1564 
(1415) 215
2747 
(1858) 
3462 
(2573) 524 
483
(244)
1507
(1268)
1000 1494 496(238)
2990 
(2732) 375
4635 
(3271) 
6010 
(4646) 1000 
884
(446)
2884
(2446)
2000 2916 918(450)
5834 
(5366) 657
7877 
(5600) 
10534 
(8257) 1934 
1637
(828)
5571
(4762)
B. Analysis of Probability for Discarding Tail Leaves  
We analyze the probability of discarding the tail leaf 
nodes for the random and very similar EPC. Let A be a set 
of tags with random EPCs, and A' be a set of tags with very 
similar EPCs (has the same lf-bit prefix). Let P(A, M, NI , NT)
and P(A', M, NI , NT) be the probabilities of nodes which can 
be discarded. 
Lemma 1.  	 
	 

	 

1
( )
1 1
1
( )
1
1 (1 )
( , , , )
(1 )


 



 

   

   


M i
i M i
i j
I T M
i M i
i
M j
i j
M
i
j p p
P A M N N
i p p
, where p= I TN N .
Proof. See the paper version. 
Lemma 2. ( ) 0.5( , , , ) , whereI I II T
I
AP N N NP A M N N
N
    
 
, , and ( / ) ( 1).
( 1)
I
I T I fIA
M N
P P A N N N N l b M
M
      

 
 
 
Proof. See the paper version.
Consider the case n=2000. By Lemma 1, we obtain P(A,
2, 750, 5498)=0.5 for BQT, and the real probability of 
discarded nodes is calculated as (750387)/750=0.484. For 
M=3 (our TQT) and M=16, we have P(A, 3, 1448, 
5286)=0.429 and P(A, 16, 7211, 9824)= 0.275. From 
TABLE III, we can get their real probabilities for TQT and 
MQT 0.467 and 0.261. The difference between P(A, 3, 1448, 
5286) and 0.467 is greater than others. The cause should be 
that our TQT using 3B2T conversion is not a real 3-ary tree 
(note: we do not have the leaf “22”). For the very similar 
EPC, the estimated probabilities of discarded nodes are P(A,
2, NI, NT)=0.5, P(A, 3, 828, 4762)= 0.435 and P(A, 16, 5600, 
8257)=0.286 from Lemma 2. Their real probabilities are 
0.509, 0.494 and 0.286, respectively. From the above values, 
we can verify the correctness of Lemma 1 and Lemma 2. 
IV. CONCLUSION
In this paper, we propose a practical implementation 
(3B2T conversion) of TQT protocol on resolving the tag-
collision problem in RFID network. Also, we propose an 
approach of discarding unnecessary inquiries to enhance the 
identification efficiency. Experiments reveal that the 
proposed TQT has better performance than other MQTs 
(M3). 
ACKNOWLEDGMENT
This work was supported in part by the 
Testbed@TWISC, National Science Council under the 
Grants NSC 99-2219-E- 006-011. 
REFERENCES
[1] K.W Chiang, C. Hua, T.S. Yum, “Prefix-randomized query-tree 
Protocol for RFID system,” in 2006 Proc. IEEE International 
Conference on Communication, Jun. 2006, pp. 1653-1657. 
[2] J. Myung, W. Lee, J. Srivastava, T.K. Shih, “Tag-Splitting: Adaptive 
Collision Arbitration protocols for RFID Tag Identification,” IEEE 
Trans. On Parallel and Distributed Systems, Jun. 2007, pp.763-775. 
[3] J. Ryu, H. Lee, Y. Seok, T. Kwon, Y. Chioi, “A hybrid query tree 
protocol for tag collision arbitration in RFID system,” in 2007 Proc. 
IEEE International Conference  on Communications, Jun. 2007, pp. 
5981-5986. 
[4] P. Pupunwiwat, B.Stantic, “Unified q-ary tree for RFID tag anti-
collision resolution,” in 2009 Proc.20th Australasian Database 
Conference, Mar. 2009, pp. 49-58. 
[5] C.H. Hsu, C.H. Yu, Y.P. Huang, “An enhanced query tree (EQT) 
protocol for memoryless tag anti-collision in RFID system,” in 2008
Proc. 2nd International Conference on Future Generation 
Communication and Networking, Dec. 2008, pp. 427-432. 
[6] C.N. Yang, Y.C. Kun, C.Y. Chiu, and Y.Y. Chu, "A new adaptive 
query tree on resolving RFID tag collision," in 2010 Proc. IEEE 
International Conference on RFID-Technology and Applications, Jun. 
2010, pp. 153-158. 
[7] P. Mathys, and P. Flajolet, “Q-ary collision resolution algorithms in 
random-access systems with free or blocked channel access,” IEEE 
Transactions on Information Theory, vol. 31, Mar. 1985, pp. 217-243.  
286
resolves the end-to-end security issue and optimizes the protocol to make the required 
computation acceptable in mobile environment. More PKI-based schemes, e.g., 
Anand and Narayanasamy (2008), Anuar et al. (2008), Hassinen et al. (2007), Kim et 
al. (2005), Kim et al. (2009), Li and Tao (2009), Martinez-Pelaez et al. (2008), Zhou 
and Dai (2008), were accordingly designed to ensure m-commerce the security and 
the privacy. 
As we know when using the public-key certificate, one should check the 
certificate validity, the certificate revocation, the certificate signature, and the 
certificate policies. In this paper, we put two or more public keys into a single 
certificate to form a so-called certificate-in certificate (CinC), so that we could speed 
up the verification process of all public keys by verifying the CinC for once. The rest 
of this paper is organized as follows. In Section 2, the X.509 certificate is briefly 
described. In Section 3, some m-commerce application scenarios requiring two or 
more public keys are introduced. Accordingly, three types of CinC (X-Certificate, 
ABC-Certificate, and the combination of X-Certificate and ABC-Certificate) are 
proposed to support such applications. Performance evaluation of the proposed CinCs 
and X.509 are given in Section 4. Section 5 concludes the paper.  
 
2. Preliminary: X.509 certificate 
The X.509 standard is a certificate format specified in ITU-T Recommendation X.509 
(formerly CCITT X.509). The public key certificates are widely used in internet for 
encryption, signature, and distribution of secret key. For example, SSL/TLS, IPSec, 
and S/MIME are presently used to achieve secure internet applications.  ISO/IEC/ 
ITU and ANSI X9 had developed X.509 version 3. Typically, an X.509 certificate 
contains the following basic fields: version, serial number, signature algorithm 
identifier, issuer, validity period, subject name, subject’s public key, issuer, subject, 
extension, and signature. Besides, X.509 version 3 format had the extension field, 
which an issuer could put some additional information. All recent PKI applications 
support X.509 version 3 certificate. This extension could provide more flexibility and 
special applications. Actually, ISO/IEC/ITU and ANSI X9 also had designed standard 
extensions embracing additional subject identification information, key attribute 
information, policy information, and certification path constraints. 
 
3. Designing a new certificate extension for m-commerce 
Some m-commerce application scenarios requiring two or more public keys are 
introduced. Accordingly, the new certificate extensions containing multiple public 
keys are designed for these m-commerce application scenarios. Our approach is to 
design an extension field including the public keys of other certificate. Thus, our new 
issuer name, …, and etc. To save the cost of certificate, we may put these two public 
keys into a single certificate. As shown in Figure 1(c), the public key for 
encryption/decryption is embedded in the extension field of the certificate in Figure 
1(a). Since we put two certificates into a single certificate, our new certificate type is 
so-called CinC. 
Actually, as shown in Figure 1, the public keys in X-Certificate could be same 
(PKX,s=PK'X,s and PKX,e=PK'X,e) or different (PKX,s PK'X,s and PKX,ePK'X,e) to those 
in the certificates of Figure 1(a) and Figure 1(b). Suppose the public keys are different. 
A merchant simultaneously have X-Certificate, the certificate of signature/verification, 
and the certificate of encryption/decryption for their respective uses. For example, to 
achieve the integrity of data, merchant X may use PKX,s in Figure 1(a). However, for 
the application in Scenario 1, it can use X-Certificate instead of the certificates in 
Figure 1(a) Figure 1(b) to save the verification time one times. Since the owner of 
these two public keys is merchant X, a reasonable choice is that the public keys are 
same (i.e., PKX,s=PK'X,s and PKX,e=PK'X,e). At this time, merchant X only needs one 
X-Certificate and thus save the cost of certificate. 
 
                  
                  (a)                  (b)              (c) 
Figure 1. Certificates of merchant X: (a) certificate of signature/ verification (b) 
certificate of encryption/decryption (c) X-Certificate 
 
3.2.2 ABC-Certificate. 
About Scenario 2, without loss of generality, we only consider the case with three 
merchants (A, B and C) in an alliance. It is easy to extend the concept to the general 
CinC with multi-membership. Figures 2(a), (b) and (c) show the certificates of 
public keys in ABC-certificate are used for the commercial purchase in ABC-alliance, 
and thus the reasonable choice is PKiPK'i. If so, merchant A has two keys: one is his 
own public key PKA for personal use and the other is a public key PK'A for the 
commercial purchase in ABC-alliance. He should store two private keys of PKA and 
PK'A. At this time, the m-commerce alliance should store the ABC-certificate and 
every merchant still maintain his own certificate. When shopping from the 
m-commerce portal, customers only spend a verification to purchase the products 
from the respective websites of merchants A, B and C. Finally, the verification time 
can be reduced. Suppose there are n merchants in this alliance. ABC-Certificate could 
save the verification time up to maximal (n-1) times. 
Figure 3 illustrates how ABC-alliance makes an application for the 
ABC-Certificate, and a customer purchases at merchant sites. All merchants should 
first send their public keys PK'i used in an alliance to the alliance manager (AM) of 
this commerce alliance. AM  then submits a certificate request service (CRS) 
including the subject name of alliance (ABC-alliance), the public key of ABC-alliance 
PKABC, all public keys PK'i of merchant i. ABC-Certificate should contain certificate 
policy that indicates the applicability of this certificate to a particular community 
(merchants A, B and C). Also, certificate authority (CA) prepares a certification 
practice statement (CPS), which describes a clear relationship between certificate 
policies and CPS. After verifying ABC-Certificate to gain the correct public keys PK'i, 
customers could purchase at all merchant sites in this alliance. 
In Figure 3, certificate request phase and purchase phase using ABC-Certificate 
are shown, and there are four entities: mobile customer (MC), merchants in an 
alliance (merchant i, i=A, B and C), AM, and CA in applying and using 
ABC-Certificate. The operational procedures of certificate request phase and purchase 
phase are described step by step as follows. 
 
Certificate request phase (steps (1)-(5) in Figure 3): 
In this phase every merchant should have his own public and private key pairs (PKi, 
SKi), and gain the public-key certificate (Certi) from CA. Also, merchant i should 
choose the public and private key pairs (PKi, SKi) used in a commercial alliance, and 
IDi is his identity. Besides, all merchants need to elect an AM as their alliance 
representative. The subject of ABC-Certificate is ABC-alliance, and the public key of 
ABC-alliance is PKABC. Notations  PK  and  SK  denote the functions encrypted 
and signed by the public key and the private key. 
 
(1) Merchant i  AM 
(8-2) MC  AM 
If need be, MC could communicate with ABC-alliance securely using PKABC. 
 
 (1) , ,
i
i i iSK
ID CertPK
 
 
(3) use  
gain and verify 
to


i
i
PK
PK
ABC A B C
(4) ={ABC-alliance,
, , , }  
CRS
PK PK PK PK
(5) ABC-Certificate
(2) send  to CA
for verifing the 
i
i
Cert
PK
(8-1) purchase
using iPK
ABC
A B C
(7) send ABC-Certificate
to CA,for verifying ,
, ,  
PK
PK PK PK
 
Figure 3. Certificate request and purchase phases when using ABC-Certificate 
 
 In the following situations, an ABC-Certificate should be revoked and AM 
needs applying a new ABC-Certificate. Suppose merchants are expelled from the 
alliance for violating the regulations of an alliance, or new merchants join this alliance. 
This is so-called the join/leaving problem. At this time, AM revokes the original 
ABC-Certificate and prepares a new CRS including new members to apply a new 
ABC-Certificate. On the other hand, if any key of merchants (SKi) is compromised 
ABC-Certificate also needs being revoked. 
 The X-Certificate contains two public keys of a same subject- merchant X, 
while the ABC-certificate includes all public keys of merchants in ABC-alliance. 
These two types of CinC could be integrated into one single certificate for the 
this time, a bonus benefit is the reduction of certificate space. Using X-Certificate 
saves one s certificate space if the little increase in the extension field is negligible. 
About the ABC-Certificate, since the subject of ABC-Certificate is ABC-alliance, and 
thus the reasonable choice is PKiPK'i. Merchant i has no need to store 
ABC-Certificate but requires its own certificate for personal use. At this time, every 
merchant has the same certificate space as using the original X.509 certificate. Table 1 
shows the performance of different types of certificates (Types I-III and X.509). 
 
Table 1. Comparison for different types of certificates 
certificate 
type 
capacity of 
public keys
verification 
times 
maximal reduction of 
verification times* 
Type I 2 1 1 
Type II n 1 (n1) 
Type III 2n 1 (2n1) 
X.509 1 1  
* the maximal reduction of verification when compared with X.509 
 
5. Conclusion 
In m-commerce, HTTPS (SSL/TLS) are often used to protect order/payment 
information. It implies that customers would need to verify merchants’ certificates. 
The proposed CinCs are based on X.509. So, they are backward compatible with 
X.509 certificate. Our CInCs support some specific m-commerce application 
scenarios. Moreover, they can speed up certificate verification and also reduce 
certificate space. 
 
ACKNOWLEDGMENT 
This work was supported in part by the Testbed@TWISC, National Science Council 
under the Grants NSC 99-2219-E-006-011. 
 
REFERENCES 
Anand, K. P. M., and Narayanasamy, P., Converged PKI-Based Authorization, 
Authentication Management and Delegation for an E-business, First 
International Conference on Distributed Framework and Applications, pp. 
121-125, 2008.  
Anuar, N. B., Kuen, L. N., Zakaria, O. and Gani, A., Mobile Messaging Using Public 
Key Infrastructure: m-PKI, WSEAS International Conferences, pp. 76-81, 
2008. 
Hassinen, M., Hyppönen, K. and Trichina, E., Utilizing National Public-key 
國科會補助計畫衍生研發成果推廣資料表
日期:2011/09/30
國科會補助計畫
計畫名稱: 具有多樣性解碼功能的秘密影像分享機制之研究
計畫主持人: 楊慶隆
計畫編號: 99-2221-E-259-014- 學門領域: 資訊安全
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無。 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
