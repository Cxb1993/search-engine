行政院國家科學委員會專題研究計畫報告  
熱能與功率導向之研究方法－應用於處理器之設計               
子計畫四 : 熱能導向之編譯器方法及相對溫度感應器設置之研究(2/3) 
計畫編號：NSC 98-2220-E-007-024 
執行期間：98 年 8 月 1 日至 99 年 7 月 31 日 
主持人：黃婷婷 清華大學資訊工程系 教授 
 
 
一、 中英文摘要： 
 
隨著製程的進步，晶片(Chip)間的匯流排隨
著製程不斷的進步及各種電子產品的需求
量增加，這些產品的設計複雜度也隨之上
昇，而這個趨勢造成電能耗損在 VLSI 的設
計上相對的越來越重要。由於單位面積消
耗的電能越來越大，造成溫度的效應也相
對越來越大。由於溫度所造成的影響甚
鉅，因此，目前有許多的研究，都著重在
如 何 有 效 的 進 行 熱 能 管 理 (thermal 
management)。 近幾年有許多針對中央
處理器(CPU)散熱的研究，而這些研究大致
上可以分成兩大類：靜態熱能管理(static 
thermal management)與動態熱能管理
(dynamic thermal management)。 
靜態熱能管理(static thermal management)
方面，我們提出的方法主要是在程式編譯
時做處理，並且著重於暫存器的熱能管
理。中央處理器的最高溫度點通常都發生
在暫存器，這是因為暫存器被存取的次數
相對於其他元件而言是最多的，而且暫存
器的面積都偏小，因此無法有效的散熱。 
動 態 熱 能 管 理 (dynamic thermal 
management)方面，進行熱能管理的方法
之一，是利用溫度感應器 (temperature 
sensor)來測量晶片上的溫度，目的希望減
少測量溫度的誤差。在現今的先進製程
中，製程變異性(process variations)是一個
會影響測量溫度的重要因素。目前所提出
關於溫度感應器的架構中，受到 process 
variations 的影響更是相當嚴重，最大的誤
差值甚至會達到＋(－)12℃，進而影響晶片
的 performance。所以計畫的目的希望提出
新的一種架構，同時考慮如何在設計的晶
片上，適當的擺上溫度感應器來進行測
量，來解決這些問題。 
因此在本計劃中探討兩個問題： 
(一)、靜態熱能管理之暫存器繫結及指令排
程以平衡及減少暫存器存取。 
(二)、動態熱能管理之相對溫度感應器之設
計及其設置。 
 
二、 研究計劃之背景及目的 
 
隨著製程不斷的進步及各種電子產品的需
求量增加，這些產品的設計複雜度也隨之
上昇，而這個趨勢造成電能耗損在 VLSI 的
設計上相對的越來越重要。由於單位面積
消耗的電能越來越大，造成溫度的效應也
相對越來越大。 
溫度會造成的影響有多，在這裡我們舉出
其中的四個例子，第一，電晶體的速度會
隨著溫度升高而降低，這是因為電荷攜帶
移動度(carrier mobility)也是隨著溫度上升
而降低；第二，溫度對漏電流的功率消耗
有顯著的影響，在高溫的時候，漏電流所
造成的功率消耗會呈現倍數成長的現象；
第三，導線(interconnect metal)上的電阻
(resistivity)也和溫度有非常密切的關係，舉
例來說，銅線的電阻在溫度由 20℃上升至
120℃時會增加約 39%，導線電阻越高，
導線的傳導速率越低，因此會嚴重影響產
品效能(performance)；第四，溫度對產品
可靠性(reliability)也有非常大的影響，這可
以 由 阿 瑞 尼 斯 方 程 式 (Arrhenius 
equation)：MTF = MTF0 exp(Eα / kbT) 
得到證明，其中 T 是溫度變化，MTF(mean 
time to failure)表示產品的平均壽命時間。
由這個方程式可以發現溫度越高，產品的
life time 越短。 
由於溫度所造成的影響甚鉅，因此，目前
有許多的研究，都著重在如何有效的進行
熱能管理(thermal management)。 近 幾
register re-binding)。 
　 指 令 排 程 以 減 少 暫 存 器 存 取 
(Thermal-aware post-compilation for 
instruction re-scheduling)。 
 
(二)、動態熱能管理之相對溫度感應器之設
計及其設置。 
而進行熱能管理的方法之一，是利用溫度
感應器(temperature sensor)來測量晶片上
的溫度，目的希望減少測量溫度的誤差。
在現今的先進製程中，製程變異性(process 
variations)是一個會影響測量溫度的重要
因素。目前所提出關於溫度感應器的架構
中，受到 process variations 的影響更是相
當嚴重，最大的誤差值甚至會達到＋(－)12
℃，進而影響晶片的 performance。所以計
畫的目的希望提出新的一種架構，同時考
慮如何在設計的晶片上，適當的擺上溫度
感應器來進行測量，來解決這些問題。 
為了能夠使動態熱能管理更有實際效用，
一個重要的關鍵就是必須準確地測量出溫
度，判斷出真正最高溫度點(hotspot)。在 [5]
和[6] 中，研究者提出了一種絕對溫度感應
器的一種架構，目的是為了藉著有效的配
置和擺放這些絕對溫度感應器，來正確的
測 量 溫 度 ， 並 且 將 溫 度 感 應 器 對
performance 和 threshold voltage 的影響
降到最低，絕對溫度感應器的架構如圖 
(二)： 
 
圖 (二) 
 
絕對溫度感應器的架構包含兩部分，CORE 
和 BJT。CORE 包含兩個主要的部份，一
個是 analog to digital (ADC)的轉換器，一
個是穩定電流的產生器。 BJT 是由
diode-connected bipolar transistor 構成，
主要是接受穩定電流，可以產生一個電壓
值回傳。在正常工作的情況下，藉由 CORE
提供 BJT 一個穩定的電流(Ibias)，BJT 可
以回傳給 CORE 一個穩定的電壓(VEB)，
配合 ADC 的轉換，得到數位的輸出值。根
據數位的輸出值，可以針對感應器所擺放
的位置，得到正確的溫度。在理想的狀況，
對於感應器所擺放的位置，BJT 和絕對溫
度是成線性相關的，而 CORE 對於溫度的
波動，則不容易受影響。 
為了瞭解在圖  (二) 的架構下，process 
variations 對於絕對溫度測量的影響，在
Ibias = 10uA 和 45nm 的製程下，進行了幾
個實驗，並採用 SPICE [8] 進行模擬的動
作。在第一個實驗中，假設考慮 process 
variations 只出現在 BJT 的部份，根據 VEB
所回傳的電壓，分別在 typical、fast、slow
三個 corner 進行溫度模擬的動作，發現在
考慮 process variations 造成 VEB 誤差的
狀況下，測量出的溫度和實際的溫度，最
大可以達到 8℃的誤差。在第二個實驗中，
假設考慮 process variations 只出現在
CORE 的部份，針對 typical corner 進行溫
度的模擬。為了反映出 process variations 
對於 Ibias 的影響，利用三種電流(8uA , 
10uA , 12uA)來進行分析。實驗結果發現，
測量出的溫度和實際的溫度，最大可以達
到 7℃的誤差。 
為了總結實驗ㄧ和實驗二的結果，在第三
個實驗中，同時考慮 process variations 對
於 BJT 和 CORE 所造成的影響，來進行溫
度的測量，實驗結果如圖 (三)所示： 
圖 (三) 
點(hotspot)是我們著重的目標。這個演算
法的概念主要是希望藉由減少暫存器的
存取次數來達到降低暫存器的最高溫度
點(hotspot)，在此，我們利用管線(pipeline)
中的前饋(forwarding)機制來達到這個目
的。 
原本在 pipeline 中的 forwarding 機制是用
來解決 data hazard 的問題，這是指有些
指令會有資料相依(data dependency)的
關係，意及前一個指令所產生的資料在下
一個指令會需要用到，當指令在 pipeline
中運作時，為了不因為這個原因而產生管
線閒置(stall)，則所需要的資料將直接由
pipeline buffer 中傳遞而不是經由存取暫
存器得到，這個方法稱為 forwarding。為
了減少存取暫存器的次數，我們提出一個
指令排程的方法，盡量將滿足 forwarding 
條件的指令經由排程放在一起，而當考慮
這個問題的時候，須要注意不能夠破壞每
個指令間的相關性。 
雖然 forwarding 的機制都存在於各個中
央處理器中，但是，一般的 forwarding 機
制是利用硬體控制的方式來判別資料的
來源，通常都還是要進行暫存器存取，也
就是說，暫存器會在不需要被存取的情況
下被存取，由圖 (五) 我們可以發現這
點，因此，除了提出一個適合的指令排程
(instruction scheduling)演算法使可以進
行 forwarding 的指令各數增加之外，我們
還必須額外考慮到 data path 的修改，使
forwarding 機制啟動的時候，不會有不必
要的暫存器存取發生。 
圖 (四) 
(三)、相對溫度感應器的設計及設置方式 
(Temperature sensor structure 
modification and placement) 
在考慮 process variations 的狀況下，由
於絕對溫度感應器無法精準地測量溫
度，也造成無法應用動態溫度管理的技
術，來降低溫度所造成的影響。在此，我
們提出一個全新的感應器架構，來取代目
前絕對溫度感應器的架構。這個新的架構
利用相對溫差的概念，來降低 process 
variations 造成的影響。 
 
圖 (五) 
由於採用相對溫差的概念，需要有一個溫
度的參考點，BJT 的部份會被劃分成兩個
部份，一個部份是 HBJT，需放在接近熱
點的位置來正確的測量溫度。  ㄧ個是
RBJT，需放在溫度較穩定的地方，來降
低 process variations 造成的影響。為了
要計算兩種 BJT 所在位置的溫度差異，在
CORE 的部分新加入了一個 subtractor，
目的希望藉由相減的方式，得出相對溫差
的數值。這個架構的好處在於由於採用相
對溫差的概念，即使 HBJT 和 RBJT 都受
到 process variations 的影響，導致回傳
的電壓(VEB)產生變異，仍然可以用相減
的方式，消去 process variations 所造成
的電壓變異。 
從這個原型中，衍生出問題需要去解決，
第一個由於引入了相對溫差的概念，能夠
算出溫度變化的量，但是絕對溫度的數
值，仍需要想辦法來計算。第二個由於提
出了溫度參照點的概念，需有額外的
BJT，來實行 RBJT 所需的功能，這會造
成額外面積的負擔，如何有效的決定
HBJT 和 RBJT 的數量，並針對 CORE 的
數目來進行分組，是一個重要的問題。 
在應用相對誤差的概念之後，新的架構包
含了 HBJT、RBJT 和 CORE 三部份。而
[4] K. Skadron, T. Abdelzaher and M. R. 
Stan, ”Control Theoretic Techniques 
and Thermal-RC Modeling for 
Accurate and Localized Dynamic 
Thermal Management,” Proceedings 
of the Eighth International 
Symposium on High-Performance 
Computer Architecture, February 
2002. 
[5] Rajarshi Mukherjee and Seda Ogrenci 
Memik, ”Systematic temperature 
sensor allocation and placement for 
microprocessors,” Proceedings of the 
43rd conference on Design 
Automation, 2006, pp. 542-547. 
[6] Hector Sanchez et al., ”Thermal 
management system for high 
performance PowerPCTM 
microprocessors,” Proceedings of 
Compcon, 1997, pp. 325-330. 
[7] J. H. Tseng and K. 
Asanovic, ”Banked Multiported 
Register Files for High-Frequency 
Superscalar Microprocessors,” Inter. 
Symp. on Computer Architecture, 
June 2003. 
[8] L. Nagel, ”Spice: A computer 
program to simulate computer 
circuits,”  in UC Berkeley UCBERL 
Memo M520, May 1995. 
[9] Y. Li, D. Brooks, Z. Hu, and K. 
Skadron, ”Performance, Energy, and 
Thermal Considerations for SMT and 
CMP architectures,” Proceedings of 
the Eighth International Symposium 
on High-Performance Computer 
Architecture, February 2005. 
[10] Fred C. Chow and John L. 
Hennessy, ”The priority-based 
coloring pproach to register 
allocation”, ACM Transactions on 
Programming anguages and Systems 
Vol. 12, No.4, Oct. 1990 
[11] J. H. Tseng and K. 
Asanovic, ”Energy-efficient register 
access”, Symposium on Integrated 
Circuits and System Design, Sep. 
2000 
[12] Intel 64 and IA-32 architectures 
Software Developer’s Manual, Intel 
Corp, 
www.intel.com/design/processor/man
uals 
[13] W. Stallings, ”Computer Organization 
and Architecture, 7th Edition”, 
Prentice Hall Publishers, 2006. 
[14] W. Liao, J. Basile, and L. 
He, ”Leakage Power Modeling and 
Reduction with Data 
Retention”,IEEE/ACM International 
Conference on Computer Aided 
Design, Nov. 2002. 
[15] W. Huangy, K. Sankaranarayanany, R. 
J. Ribandoz, M. R. Stan and K. 
Skadron,”An Improved Block-Based 
Thermal Model in HotSpot 4.0 with 
Granularity 
Considerations”,Proceedings of the 
Workshop on Duplicating, 
Deconstructing, and Debunking,June. 
2007 
[16] S. Rusu, G. Singer, ”The First IA-64 
Microprocessor”, IEEE Journal of 
Solid-state Circuits Vol. 35, No. 11 
November 2000 
[17] Kyeong-Jae Lee, Kevin Skadron and 
Wei Huang, ”Analytical model for 
sensor placement on 
microprocessors,” International 
Conference Computer Design, 2005, 
pp. 24-27. 
[18] W. Huang, S. Ghosh, K. 
Sankaranarayanan, K. Skadron and M. 
R. Stan, ”HotSpot: Thermal modeling 
for CMOS VLSI systems,” IEEE 
Transactions on Component 
Packaging and Manufacturing 
Technology, 2005. 
[19] David Brooks, Vivek Tiwari and 
Margaret Martonosi, ”Wattch: A 
framework for architectural-level 
power analysis and optimizations,” 
ISCA, 2000. 
[20] ”SPEC-CPU2000, Standard 
Performance Evaluation Council, 
Performance Evaluation in the New 
Millennium, Version 1.1,” 2000, 
http://www.specbench.org/osg/cpu20
00. 
[21] Michiel A. P. Pertijs, Kofi A. A. 
Makinwa, Johan H. Huijsing, ”A 
CMOS smart temperature sensor with 
附 錄： 
 
Thermal-aware Post Compilation 
for VLIW Architecture 
 
 
 
 
Proceeding of ASPDAC 
pp. 606-611, Jan. 2009 
 
Conventional 
Register File
Sub-bank 
Register File
enable 
signal
Fig. 2. The conventional and the sub-bank register ﬁles.
The second modiﬁcation is to add an enable signal to
each register ﬁle bank. The enable signal is used to turn-off
the access to the sub-bank register ﬁle so that the dynamic
power can be saved [8]. In a processor, register ﬁle is
always read even if an instruction requires no operands. We
utilize a forwarding scheme to turn off sub-bank register ﬁle.
The detailed architecture and an instruction scheduling are
described in Section III.B.
III. THE PROPOSED METHOD
In this section, we propose our two main techniques to
manage the temperature of register ﬁle. One is register binding
and the other is forwarding methods including forwarding-
aware architecture and instruction scheduling.
A. Register Binding
1) Motivation: Previous work [5] proposed a thermal man-
agement method for VLIW functional units at compiler level.
The main idea of the work is to balance the work load of
each functional unit. The order of each functional unit is
rearranged so that the access counts of each functional unit
are balanced. However, the temperature of the surrounding
units of functional units are not taken into consideration in
[5]. Since the heat would spread around, it is important to
take ﬂoorplan into consideration during the computation of
temperature.
For example, assume there are four sub-bank register ﬁles
called REG1, REG2, REG3, REG4 and four units surround
them named U1, U2, U3 and U4 as shown in Figure 3. Let the
four units with their corresponding temperatures are denoted
as U1Temp, U2Temp, U3Temp and U4Temp, and U1Temp >
U2Temp = U3Temp > U4Temp. Let’s consider three possible
register access orders.
REG1 REG2 REG3 REG4
U1 U2
U3 U4
Fig. 3. An example with sub-bank register ﬁles and adjacent units.
• Simple binding: If REG1 is free, then all data can be
bound to REG1. Obviously, in this case, REG1 becomes
hotspot.
• Round-robin-like binding [5]: To balance the access
count of the sub-bank register ﬁles, a round-robin rotation
of REG1 → REG2 → REG3 → REG4 can be used.
This approach is used in [5]. However, it can be predicted
that REG1 and REG2 are the potential hotspots since
U1Temp and U2Temp are higher than U3Temp and
U4Temp.
• Floorplan-aware binding: When ﬂoorplan information
is taken into consideration, it can be seen that REG4 is
the ﬁrst choice to be bound because REG4 is surrounded
by the coolest temperature U4Temp. For the next choice,
REG2 is the selection because REG4 is recently used
and REG2 is away from it. Next, REG3 is bound, and
ﬁnally is REG1. This sub-bank register ﬁle binding order
can balance the temperature.
From the above example, to accurately model a heat dissi-
pation of sub-bank register ﬁle, it is required to consider not
only the temperature of sub-bank register ﬁle (the temporal
usage of the register ﬁle) but also the temperature of adjacent
units (the spatial relations among register ﬁle). However, none
of previous approaches consider both temporal and spatial
information at the same time.
2) Binding Algorithm: Based on the observation mentioned
above, we propose a register binding method at post-compiler
level to eliminate hotspots. The main idea is to bind registers
so that the temperature of register banks are distributed evenly.
Before Binding algorithm proceeds, both temporal and
spatial information needs to be obtained ﬁrst. There are
two kinds of temporal information. One is the control ﬂow
graph (CFG) of the running program. Since the thermal
effect is continuous, the program ﬂow has to be taken into
consideration when register binding is performed. The other
temporal information is the temperature trace ﬁle which
contains temporal temperature information of every unit in
a target processor through running the entire program. These
two kinds of temporal information are used to predict the
temperature of register ﬁle and units surrounding it at any
time slot. As to the spatial information, the ﬂoorplan of a
target processor is used to tell which speciﬁc units surrounded
to the register ﬁle.
Our proposed algorithm is based on a priority-based graph
coloring algorithm [7] which starts by analyzing the CFG ﬁle
of the original program. First, the live range of each variable
is constructed by traversing the CFG. Then an corresponding
interference graph is built to represent the conﬂict between
live ranges. Next, the priority of each live range is calculated
so that the order of live range to process coloring can be de-
cided. According to the priority order, an available register is
assigned to each live range, which is similar to color the node
in the interference graph. According to the coloring algorithm,
the selection of color has to guarantee that adjacent nodes in
the interference graph have different colors. Therefore, the
same register is not assigned to conﬂicting live ranges after
applying the coloring algorithm.
In our Binding algorithm, the live ranges are processed
in the same priority order as graph coloring algorithm [7].
The main difference of our binding algorithm and [7] is that
a sub-bank register ﬁle is selected for binding by using our
new Penalty cost function. Moreover, in our algorithm, when
loop structure exists, the loop is split into smaller iteration
loops before constructing live ranges. This is because the
loop is executed for many iterations. If we only bind the loop
body based on one iteration, it is likely that the bound sub-
register bank becomes hotspot. In general, the loop is spilt
into K smaller loops when we have K sub-bank register ﬁles.
Figure 4 shows our detailed algorithm.
The cost function, Penalty, mentioned in Figure 4 is used
to determine whether a sub-bank register ﬁle is selected for
binding or not. The penalties are calculated for all sub-bank
register ﬁles and then the bank with the lowest penalty is
selected for binding. The Penalty of ith sub-bank register
ﬁle REGi is deﬁned as:
Penalty(REGi) = (weight)× profling penalty(REGi)
+(1− weight)× history penalty(REGi) (1)
where profling penalty and history penalty represent the
spatial and temporal impact to the sub-bank register respec-
tively, and weight is used to tune the importance of these two
terms.
607
7A-1
Prob(edgeĮȕ)
= 0.6
Prob(edgeĮȕ')
= 0.4
Prob(edgeȕȖ)
= 0.6
Prob(edgeȕ'Ȗ)
= 0.4
start here
Ȗ
REG1 = 4
REG2 = 3
C(Ȗ) = 20
ȕ
REG1 = 2
REG2 = 2
C(ȕ) = 30
ȕ'
REG1 = 5
REG2 = 3
C(ȕ') = 20
Į
REG1 = 2
REG2 = 3
C(Į) = 10
į
REG1 = 3
REG2 = 6
C(į) = 50
accumulate
window
50 
cycles
60 
cycles
Fig. 7. A partial CFG for computing accumulate window and
history penalty(REG1).
First, the upper and the lower ends of accumulate window
are computed. Since C(α) is less than observed cycle count,
we backward trace the CFG from basic block α. Now, a
branch is encountered. We apply the priority function and then
the basic block β′ is included into the accumulate window.
Since the accumulated cycle count (C(α) + C(β′)) is still less
than observed cycle count, the backward tracing continues.
We ﬁnd that the accumulated cycle count (C(α) + C(β′)
+ C(γ)) achieves observed cycle count after including basic
block γ. Therefore, the upper end of accumulate window is
found and the backward tracing stops. Similarly, the forward
tracing is performed. The forward tracing step stops when the
basic block δ is reached because the accumulated cycle count
(C(α) + C(δ)) is larger than the observed cycle count.
Therefore, the accumulate window of REG1 contains four
basic block α, β′, γ, and δ. Counts(REG1) is calculated
as (2+5+4+3) = 13. Hence, the history penalty(REG1) =
Counts(REG1)×Power(REG1)×R = 13×0.002×0.1 =
0.0026.
B. Forwarding-aware Method
1) Motivation: The forwarding unit exists in a pipelined
architecture to eliminate data hazards at run time. However,
when forwarding occurs, useless data is still read from register
ﬁle. Reducing the access to a register ﬁle can effectively
reduce the temperature of the register ﬁle. Based on this
observation, previous work [8] proposed to turn off a register
ﬁle when forwarding condition is detected. However, [8] did
not present any detailed mechanism to turn off the register
ﬁles. Only some simulation results are shown.
To eliminate this useless read to register ﬁle, we propose a
mechanism to turn-off register ﬁle. First, forwarding condition
is detected at compile time and encoded into instructions.
Then, at run time forwarding condition is decoded from
instructions to determine which sub-bank register ﬁles should
be turned off. In addition, based on this mechanism, a
forwarding-aware instruction scheduling is proposed to allow
more operand-forwarding.
TABLE I
THE FLAG FIELD AND THE CORRESPONDING CONDITION
ﬂag encoding forwarding condition
000 no forwarding occurs
001 Inst0, 1st source register
010 Inst1, 1st source register
011 Inst2, 1st source register
100 conﬂict
101 Inst0, 2nd source register
110 Inst1, 2nd source register
111 Inst2, 2nd source register
Forwarding-aware instruction scheduling was also proposed
in [11]. The main difference between our approach and
[11] is that we target at a VLIW architecture while the
technique proposed in [11] targets at out-of-order supersacalar
architecture where forwarding condition is detected at run-
time. Since our instruction-level parallelism is performed at
compiler time, both the order of instruction execution and
forwarding condition can be decided at compiler time. Our
forwarding condition is guaranteed to be the same at both
compiler time and run time. Therefore, hardware overhead
we need is only a decoder.
2) Instruction Encoding and its Decoding Architecture: In
this section, we describe the instruction encoding method and
implementation of its corresponding architecture. We target at
VLIW architecture, and IA-64 instruction encoding format is
adopted [9]. Figure 8 shows the encoding format.
The instruction format shown in Figure 8 is called a bundle.
It can be regarded as a compound instruction format. Each
bundle is 128-bit long, and contains three instructions (Inst0,
Inst1 and Inst2 in Figure 8) and a 5-bit template ﬁeld.
The template ﬁeld has two purposes. One is to specify the
execution unit type of each instruction, (e.g., indicating that
instruction 0 is executed in integer ALU) and the other is to
tell whether the next bundle is to be executed in parallel with
the current bundle.
Inst2 Inst1 Inst0 Template
41 bits 41 bits 41 bits 5 bits
Fig. 8. The bundle format in IA-64.
In order to record the forwarding condition, we modify the
bundle format as shown in Figure 9. An additional 3-bit ﬂag
ﬁeld is appended next to the template ﬁeld. The ﬂag ﬁeld
is used to distinguish all the forwarding conditions among
the three instructions. Table I shows the ﬂag encoding. For
example, ﬂag=(001) represents that the value of 1st source
register of Inst0 is forwarded, and the sub-bank register ﬁle
where this register is located can be turned off. A special
condition is conﬂict. It means that forwarding occurs but the
sub-bank register ﬁle can not be turned off because other
registers located in the same sub-bank register ﬁle need to
be read. In this case, we cannot turn off the sub-bank register
ﬁle directly.
Inst2 Inst1 Inst0 Template
41 bits 41 bits 41 bits 5 bits
Flag
3 bits
Fig. 9. The modiﬁed bundle format.
Complying with the modiﬁcation of bundle format, we
modify the architecture of 8-stage data-path of IA-64 [10] as
shown in Figure 10 where only four pipeline stages (EXP ,
REN , REG, and EXE) and one ALU are depicted in this
ﬁgure. New added components are shown in bold line.
609
7A-1
dl1 ul2
btb
decode
ialu
falu
itlbdtlb
il1
FREG1
FREG2
FREG3
FREG4
IREG1
IREG2
IREG3
IREG4
Fig. 13. The Itanium ﬂoorplan.
TABLE II
THE PARAMETERS OF TRIMARAN AND HOTSPOT
Trimaran HotSpot
Unit Num Parameter Value
Integer register 128 Frequency 3GHz
FP register 128 Vdd 1V
Integer Units 2 Initial temperature 60
FP units 2 Thermal Resistance 0.1 K/W
Load/store unit 2 Die size 10mm x 10mm
B. Experiment on Performance
This experiment is conducted to study the run-time per-
formance penalty caused by our methods. Three methods are
evaluated and the results are shown in Table IV. The column
labeled cycle count gives the cycle counts of each benchmark
program while the pen represents the performance penalty as
compared to the original case in percentage.
From Table IV, we can see that the binding algorithm does
not affect the performance at all. This is because the binding
algorithm only replaces registers from one sub-bank register
ﬁle to another.
On the other hand, performance penalty is incurred in
forwarding method as shown in column 6. The perfor-
mance penalty of forwarding method mainly occurs in
the loop structure. Once the scheduled instructions affect
the performance in single loop iteration, the effect becomes
more serious after loop execution. Therefore, the performance
penalty of forwarding method is 1.7% in the worst case
(blit), 0.7% in the best case (crc) and 1.3% on the average.
As to the combined method which executes both methods,
the performance penalty is less serious than the forwarding
method as shown in column 8. This is because the number
of instruction satisfying forwarding conditions becomes less
in the combined method after the binding algorithm is
applied, where the usage of all sub-register ﬁles are separated.
Therefore, the performance penalty of combined method is
only 1.1% in the worst case (engine), 0.5% in the best case
(crc) and 0.9% on the average.
V. CONCLUSION
In this paper, two techniques are proposed to reduce the
hotspots of register ﬁle of VILW architecture processor at
compiler level. The ﬁrst one is register binding to balance
the temperature of register ﬁle by taking both spatial and
temporal thermal information into consideration. The second
one is forwarding method which includes forwarding-aware
architecture and instruction scheduling to reduce the access
count of register ﬁle. The experimental results show that by
combining the two techniques, the peak temperature reduction
can reach 7.89 (oC) in the best case and 7.22 (oC) in average
with only 0.9% performance penalty in average.
TABLE III
THE EXPERIMENTAL RESULTS FOR PEAK TEMPERATURE REDUCTION.
Orig. Round-robin Our Our Ourbench- Binding Binding Forwarding Combined
mark temp temp r t temp r t num temp r t temp r t
(oC) (oC) (oC) (oC) (oC) (%) (oC) (oC) (oC) (oC)
bilv 95.33 92.86 2.47 89.95 5.38 25.03 93.67 1.66 89.77 5.56
blit 102.7 98.03 4.67 95.8 6.9 26.88 97.65 5.05 95.32 7.38
crc 99.73 94.72 5.01 92.79 6.94 35.94 95.9 3.83 92.77 6.96
des 100.89 95.03 5.86 93.86 7.03 24.15 97.62 3.27 93.57 7.32
energe 94.66 89.4 5.26 87.27 7.39 33.36 89.5 5.16 86.15 8.51
ﬁr 86.54 82.19 4.35 79.7 6.84 30.69 81.03 5.51 78.65 7.89
summin 97.28 93.25 4.03 90.56 6.72 22.57 93.18 4.1 89.97 7.31
whet 90.52 87.01 3.51 85.32 5.2 20.01 86.95 3.57 83.67 6.85
average 4.395 6.55 4.02 7.22
TABLE IV
THE EXPERIMENTAL RESULTS FOR PEAK TEMPERATURE REDUCTION.
bench-
mark
Orig. Binding Forwarding Combined
cycle cycle pen cycle pen cycle pen
count count (%) count (%) count (%)
bilv 376064357 376064357 0.0 380953193 1.3 379448936 0.9
blit 50440416 50440416 0.0 51297903 1.7 50944820 1
crc 5660433 5660433 0.0 5700056 0.7 5688735 0.5
des 41964763 41964763 0.0 42594234 1.5 42300481 0.8
energe 711784 711784 0.0 720325 1.2 720325 1.2
ﬁr 45077873 45077873 0.0 45799118 1.6 45573729 1.1
summin 492696 492696 0.0 496637 0.8 496637 0.8
whet 77202731 77202731 0.0 78360771 1.5 77897555 0.9
average 0.0 1.3 0.9
REFERENCES
[1] D. Brooks and M. Martonosi, ”Dynamic Thermal Management for
High-Performance Microprocessors,” Proceedings of the Seventh Inter-
national Symposium on High-Performance Computer Architecture, Feb-
ruary 2001.
[2] K. Skadron, T. Abdelzaher and M. R. Stan, ”Control Theoretic Tech-
niques and Thermal-RC Modeling for Accurate and Localized Dynamic
Thermal Management,” Proceedings of the Eighth International Sympo-
sium on High-Performance Computer Architecture, February 2002.
[3] Y. Li, D. Brooks, Z. Hu, and K. Skadron, ”Performance, Energy, and
Thermal Considerations for SMT and CMP architectures,” Proceedings
of the Eighth International Symposium on High-Performance Computer
Architecture, February 2005.
[4] K. Sankaranarayanan, S. Velusamy, M.R. Stan, and K. Skadron, ”A Case
for Thermal-Aware Floorplanning at the Microarchitectural Level,” The
Journal of Instruction-Level Parallelism Septempter 2005.
[5] M. Mutyam, F. Li, V. Narayanan, M. Kandemir and M. J. Irwin,
”Compiler-Directed Thermal Management for VLIW Functional Units,”
In. ACM SIGPLAN/SIGBED Conference on Languages, Compilers, and.
Tools for Embedded Systems, June 2006.
[6] J. H. Tseng and K. Asanovic, ”Banked Multiported Register Files for
High-Frequency Superscalar Microprocessors,” Inter. Symp. on Computer
Architecture, June 2003.
[7] Fred C. Chow and John L. Hennessy, ”The priority-based coloring
approach to register allocation”, ACM Transactions on Programming
Languages and Systems, October 1990
[8] J. H. Tseng and K. Asanovic, ”Energy-efﬁcient register access”, Sympo-
sium on Integrated Circuits and System Design, Sep. 2000
[9] Intel 64 and IA-32 architectures Software Developer’s Manual, Intel
Corp, ”http://www.intel.com/design/processor/manuals”
[10] W. Stallings, ”Computer Organization and Architecture, 7th Edition”,
Prentice Hall Publishers, 2006.
[11] S. Park, A. Shrivastava, N. Dutt, A. Nicolau, Y. Paek and E. Earlie,
”Bypass Aware Instruction Scheduling for Register File Power Reduc-
tion”. ACM SIGPLAN/SIGBED Internation Conference on Languages,
Compilers, and Tools for Embedded System, June 2006
[12] W. Liao, J. Basile, and L. He, ”Leakage Power Modeling and Reduction
with Data Retention”,IEEE/ACM International Conference on Computer
Aided Design, November 2002
[13] W. Huangy, K. Sankaranarayanany, R. J. Ribandoz, M. R. Stan and K.
Skadron,”An Improved Block-Based Thermal Model in HotSpot 4.0 with
Granularity Considerations”,Proceedings of theWorkshop on Duplicating,
Deconstructing, and Debunking,June. 2007
[14] S. Rusu, G. Singer, ”The First IA-64 Microprocessor”, IEEE Journal of
Solid-state Circuits, November 2000
611
7A-1
TSV Redundancy: Architecture and Design
Issues in 3D IC
Ang-Chih Hsieh†, TingTing Hwang†, Ming-Tung Chang‡, Min-Hsiu Tsai‡, Chih-Mou Tseng‡ and Hung-Chun Li‡
†Department of Computer Science, National Tsing Hua University, HsinChu, Taiwan 300
‡Global Unichip Corporation, Hsinchu, Taiwan 300
Abstract—3D technology provides many benets including
high density, high band-with, low-power, and small form-factor.
Through Silicon Via (TSV), which provides communication links
for dies in vertical direction, is a critical design issue in 3D
integration. Just like other components, the fabrication and
bonding of TSVs can fail. A failed TSV may cause a number
of known-good-dies that are stacked together to be discarded.
This can severely increase the cost and decrease the yield as
the number of dies to be stacked increases. A redundant TSV
architecture with reasonable cost for ASICs is proposed in this
paper. Design issues including recovery rate and timing problem
are addressed. Based on probabilistic models, some interesting
ndings are reported. First, the probability that three or more
TSVs are failed in a tier is less than 0.002%. Assumption of
that there are at most two failed TSVs in a tier is sufcient to
cover 99.998% of all possible faulty free and faulty cases. Next,
with one redundant TSV allocated to one TSV block, limiting
the number of TSVs in each TSV block to be no greater than
50 and 25 leads to 90% and 95% recovery rates when 2 failed
TSVs are assumed. Finally, analysis on overall yield shows that
the proposed design can successfully recover most of the failed
chips and increase the yield of TSV bonding to 99.99%. This can
effectively reduce the cost of manufacturing 3D ICs.
I. INTRODUCTION
3D integration techniques are proposed as solutions to
overcome the scaling limit [1]. 3D technology provides many
benets including high density, high band-with, low-power,
and small form-factor [2]. Through-Silicon Via (TSV) [3],
which provides communication links for dies in vertical
direction, is a critical design issue in 3D integration. In current
manufacturing process for 3D designs, each die to be inte-
grated is manufactured individually. When TSV technology
is applied, TSVs and bond pads are fabricated inside each
die [4][5]. Then, bonding technology is used for die stacking.
Just like other components, the fabrication and bonding of
TSVs can fail. A failed TSV may cause a number of known-
good-dies that are stacked together to be discarded. This can
severely increase the cost and decrease the yield as the number
of dies to be stacked increases.
To improve the yield, some recovery mechanism is needed.
A simple but effective solution is to add redundant TSVs
which can be used to replace failed TSVs. This idea has been
realized in 3D DRAM designs [6]. In the proposed scheme, for
every 4 signals, 6 TSVs are allocated as a group. A switching
This work was supported in parts by National Science Council of Taiwan,
Republic of China, under grant NSC 98-2220-E-007-024, NSC 98A052
box is required for each group to select which 4 TSVs
are actually used to transfer signals. The advantage of this
structure is that the delays of all signals are almost identical.
This is an attractive property for DRAM designs. Although
this structure is suitable to the dedicated layout style of
memory designs, the cost is too expensive for ASICs. Another
fault tolerance scheme that utilizes redundant TSVs targets on
3D network-on-chip (3DNoC) links [7]. Though signicant
yield improvement is achieved, the analysis and design ow
are based on the dedicated network structure of 3DNoC. For
ASICs, the analysis and design ow may not be suitable. In
this paper, a redundant TSV architecture and related design
issues are discussed. The proposed redundant TSV design can
successfully recover most of the failed chips and increase the
yield to 99.99% based on probabilistic models.
The rest of this paper is organized as follows. First, in Sec-
tion II, the yield of TSV bonding is discussed. In Section III,
the proposed architecture for TSV redundancy is introduced.
Next, in Section IV, the recovery rate and the number of
redundant TSVs required for the proposed architecture is an-
alyzed. Probabilistic model is used for evaluation. The design
issues for timing and required design ow are explained in
Section V. Finally the conclusion of this work is given in
Section VI.
II. FAILURE RATE ANALYSIS FOR TSV
The fabrication of TSV-based 3D ICs can be partitioned
into following stages. First, dies of each tier are fabricated
individually. The fabrication of TSVs in each tier takes place
in this stage. Depending on the technology (TSV rst/last),
either reactive-ion etching (RIE) or laser drilling is performed
before TSV metallization process. According to the diameter
and aspect ratio of TSV, proper material (Cu or W [5]) is
selected for metallization. In general, the size of a TSV is
much larger than other on-chip devices. This leads to certain
unique defect features for TSV forming [8]. For example, void
may be formed in TSV and causae a TSV to fail [10]. After the
fabrication of TSVs, wafer thinning is performed. Presently,
most 3D IC processes require each tier to be less than 100
microns [5]. The surface roughness is an important factor to
the yield of later bonding stage. When the dies of consecutive
tiers are stacked, the TSVs of the die in upped tier need to be
bonded to the bond pads of the die on lower tier, as shown in
Figure 1. Due to the alignment problem, a bond pad is required
 
 
 
 
 
978-3-9810801-6-2/DATE10 © 2010 EDAA 
 
 
0 10 1
TS
V_
0
TS
V_
1
R_
TS
V
0 1
TS
V_
2
0 1
TS
V_
3
0 10 1 0 1
out_0 out_1 out_2 out_3
in_0 in_1 in_2 in_3
0 10 1
TS
V_
0
TS
V_
1
R_
TS
V
0 1
TS
V_
2
0 1
TS
V_
3
0 10 1 0 1
out_0 out_1 out_2 out_3
in_0 in_1 in_2 in_3
FAILED
(b)(a)
Fig. 4. TSV Recovery Mechanism: (a) Normal operations of TSVs; (b) TSV 1 is failed and TSV 1, TSV 2, and TSV 3 are shifted right one position
0 10 1
TS
V_
0
TS
V_
1
R_
TS
V
0 1
TS
V_
2
0 1
TS
V_
3
0 10 1 0 1
out_0 out_1 out_2 out_3
in_0 in_1 in_2 in_3
reciever
sender
Fig. 3. Architecture for Redundancy TSV
Fig. 5. TSV Blocks
B. TSV Block and TSV-Chain
Due to manufacturing and physical design issues, TSVs are
not recommended to be placed arbitrarily on a plane. From
the aspect of manufacturing, a regular placement of TSVs
improves the exposure quality of the lithographic process
and therefore improves the yield. In real designs, TSVs are
suggested to be placed regularly in TSV blocks which are
determined in oorplan stage. Inside each TSV block, TSVs
are arranged in a grid-based structure to satisfy the pitch
constraint of bond pads. Examples of TSV blocks are shown
in Figure 5. Obviously, it is undesirable for a TSV-chain to
contain TSVs of different TSV blocks due to long wires
for signal shifting. Therefore, a TSV-chain in our design
is suggested to contains TSVs in the same TSV block.
Moreover, we let each TSV block contain only one redundant
TSV. This means, for each TSV block, only one TSV-chain is
dened. Nevertheless, in terms of recovery rate, the number of
TSVs in a TSV-chain needs to be limited. In case the number
of TSVs in a TSV block is too large for one TSV-chain, the
TSV block needs to partitioned to a number of smaller TSV
blocks.
The design issues for our the proposed TSV-chain are listed
as follows:
∙ Determine the number of TSVs in each TSV block
∙ Determine the path to link the TSVs in a TSV block as
a chain
The rst problem is related to the recovery of a 3D design.
In Section IV, an analysis based on probabilistic model is
performed to answer this question. The second problem is
related to the timing behavior of shifted signals. Discussions
on timing issues and guidelines for TSV-chain design are
presented in Section V.
IV. RECOVERY RATE ANALYSIS
In this section, the relation between the number of TSVs
in each TSV block and recovery rate is analyzed based on
probabilistic models. First, based on the failure rate of a single
TSV, the expected number of TSVs that may fail in a tier
is discussed in Section IV-A. The result of Section IV-A
determines the maximum number of failed TSVs that are
expected to be recovered by our proposed TSV-chains. Next,
for an expected number of failed TSVs in each tier, the
required number of TSV-chains as well as the size limit of
each TSV block are discussed in Section IV-B.
A. Analysis on the Expected Number of TSVs to be Recovered
Let 𝐹 stand for the failure rate of a single TSV and 𝑁
stand for the number of TSVs in a tier. The probability that
exact 𝑛 TSVs are failed in a tier can be expressed as
𝑃𝑓 𝑡𝑠𝑣=𝑛 = 𝐶
𝑁
𝑛 × (𝐹𝑛 ⋅ (1− 𝐹 )𝑁−𝑛)
where 𝐶𝑁𝑛 represents the number of combinations of 𝑁 TSVs
with 𝑛 of them failed and 𝐹𝑛 ⋅ (1 − 𝐹 )𝑁−𝑛 represents the
probability of 𝑛 chosen TSVs are failed while other 𝑁 − 𝑛
TSVs are not. Next, the term 𝐶 𝑅𝑎𝑡𝑖𝑜𝑛 is dened as the
probability that the number of failed TSVs is no greater than
𝑛, including the faulty free condition (that is, 𝑛 = 0). This can
be computed by accumulating 𝑃𝑓 𝑡𝑠𝑣=𝑖 for 0 ≤ 𝑖 ≤ 𝑛 and
can be expressed as
𝐶 𝑅𝑎𝑡𝑖𝑜𝑛 =
𝑛∑
𝑖=0
𝑃𝑓 𝑡𝑠𝑣=𝑖.
The values of 𝑃𝑓 𝑡𝑠𝑣=𝑛 and 𝐶 𝑅𝑎𝑡𝑖𝑜𝑛 for 𝐹 = 0.0001 and
𝑁 = {300, 400, 500} are listed in Table I.
tsv_4 tsv_3 tsv_2 tsv_1 tsv_0 tsv_rFailed
TSV
tsv_0
tsv_1
tsv_2
tsv_3
tsv_4
1/5 2/5 3/5 4/5 5/5
Fig. 7. All Possible Shifting Situations for a TSV-chain of Size 6 when 1
TSV is Failed
not be acceptable. In this section, timing issues for TSV-chain
design are discussed in Section V-A. The discussion leads
to the guidelines to link TSVs in a TSV block as a chain.
Candidate TSV-chain structures are proposed in Section V-B.
In Section V-C, design issues in each stage of 3D design ow
are discussed.
A. Design Issues for Timing
As explained in Section III-A, when a TSV is failed,
according to the position of the failed TSV in a TSV-chain,
one or more signals need to be shifted. Due to the chaining
structure, even under the assumption that each TSV has
identical failure rate, the probability for each TSV in a TSV-
chain to be shifted varies. Figure 7 shows this situation.
Assume that 1 TSV is failed in a TSV-chain of size 6,
all possible shifting situations are enumerated in Figure 7.
When no TSV is failed and no shifting is required, the TSV-
chain is shown in the right column of the rst row where
the redundant TSV is denoted as tsv r. For each row below,
the left column indicates the failed TSV and the right column
shows the shifting situation. The last row lists the shifting
probabilities of the TSVs in the TSV-chain when 1 TSV is
failed. For tsv 0, no matter which TSV in the TSV-chain is
failed, it is always shifted because it is on the position next to
the redundant TSV. On the contrary, tsv 4, which is at the head
position of the TSV-chain, need not to be shifted unless itself
is failed. In terms of extra delays introduced by signal shifting,
this property of TSV-chain indicates that the probability that
the delay of a signal linked by a TSV is increased depends
on the position of the TSV in the TSV-chain. This means, for
signals that are timing critical, it is preferable to assign these
signals at the head parts of TSV-chains.
An evaluation for an extreme case where only one signal is
timing critical is shown in Figure 8. The x-axis stands for the
number of TSVs in a TSV-chain and the y-axis stands for the
probability that the timing critical signal is shifted. The line
denoted as “Unaware” represents that the timing critical signal
has equal probability to be located at any position of a TSV-
chain. And the line denoted as “Timing Aware” represents that
the timing ctitical signal is always located at the beginning
of a TSV-chain. Assume that the failure rate of each TSV
is identical and there is only one failed TSV. The result in
Figure 8 shows that, in “Unaware” cases, the probabilities for
the timing critical signal to be shifted are greater than 50%
in all cases. On the contrary, by assigning the timing critical
30%
40%
50%
60%
70%
80%
90%
100%
ity
 fo
r 
th
e 
Ti
m
in
g 
C
ri
tic
al
 
ig
na
l t
o 
be
 sh
ift
ed
Unaware
Timing Aware
0%
10%
20%
10 20 30 40 50 60 70 80 90 100
Pr
ob
ab
ili
ty
 fo
r 
th
e 
Ti
m
in
g 
C
ri
tic
al
 
Si
gn
al
 to
 b
e 
sh
ift
ed
# of TSVs in a TSV-Chain
Fig. 8. Evaluation on the Possibility for the Timing Sensitive Signal to Be
Shifted
signal to the head of a TSV-chain, the probability is reduced to
2.93% in average. Based on the evaluation, timing sensitive
signals should always be routed through the TSVs located
at the head of TSV-chains. This is one of the guideline that
should be followed when designing TSV-chains.
The next issue is to minimize the delay caused by sig-
nal shifting. This can be done by minimizing the distance
between the connected TSVs in a TSV-chain. As mentioned
in Section III-B, TSVs in each block are placed in a grid-
based structure. Therefore, by requiring the connected TSVs
in a TSV-chain to be neighbors in the grid-based structure,
minimal and xed shifting delay can be guaranteed. This also
makes the shifting delay predictable in early design stages.
Thus, the second guideline for TSV-chain design is that any
two connected TSVs in a TSV-chain must be next to each
other in the grid-based structure.
B. TSV-chain Design Problem
For each TSV block in a plane, the structure of the TSV-
chain needs to be considered. The analysis in Section V-A
indicates that timing critical signals should always be routed
through the TSVs located at the head parts of TSV-chains.
In current design ow, signals that are assigned to each TSV
block are roughly determined in oorplan stage. However, the
exact assignment of signals to TSVs is not necessarily to be
done in this stage. From the perspective of physical design,
leaving the assignment of signals to TSVs to be done in
routing stage is benecial to minimize wire length. Therefore,
in addition to the guidelines obtained in Section V-A, the
design of TSV-chain should also consider routing issues.
Based on the concept of bounding box, discussion on wire
length is given rst. For two pins on two different tiers to
be connected, the relation between the bounding box of these
two pins and a TSV block can be listed as follows. First, the
bounding box and the TSV block can be non-overlapped. In
this situation, only going through a TSV on the boundary of
the TSV block can result in minimum wire length. Next, the
TSV block can be either partially or completely overlapped by
the bounding box. In this situation, any TSV that is overlapped
by the bounding box can result in minimum wire length.
Unless the bounding box is completely contained in the TSV
block, a TSV on the boundary of the TSV block can always
be found for minimum wire length. The discussion shows
that, TSVs on the boundary of a TSV block have higher
