 1 
 
 
A Stereoscopic Metrologic Module with Super-wide View 
1Chuang-Jan Chng*, 1Shu-Lin Hwang, 
1Department of Electronic Engineering, MingChi University of Technology 
 
*E-mail:cjchng@mail.mcut.edu.tw 
Abstract―This article describes the develop-
ment of a stereoscopic metrological module with an extra 
large viewing angle. This module is composed of 
three separated fisheye cameras. The software be-
gan from an open source project camorama, a 
popular testing tool to evaluate performance of 
network cameras. The based GTK+ toolkit and 
V4L library are adapted in developing our project. 
We expand the multi-channel capability, and the 
application specific video processing module. 
Furthermore, the POSIX thread library is adapted 
to distribute evenly the running load to the mul-
ti-core processor. The test shows we have pro-
moted CPU utility up to 350% in the quod-core 
CPU.   
摘要：本文描述發展超大視角 3D 視影感度量
組，它是由三支魚眼相機來集成的一組立體視
覺裝置能夠度量空間物件的三維坐標。軟體採
用 Camorama開放源碼為基礎。Camorama常用
來測試網絡相機的工具。它採用 GTK+ 套件及
V4L 程式庫對我們計劃發展幫助很大。我們擴
充多視訊通道功能，及發展專用的影像處理模
組。跟進一步，POSIX 執行緒程式庫要用來平
均分散執行負載到各個處理器核心。實際測試
顯示我們在四核心的 CPU 已經達到高達 275%
的使用率。 
KeyWords―GTK+,V4L,quad-core, pthreads. 
關鍵詞：GTK+， V4L, 多核心處理器， 多
執行緒庫 
Preface（前言） 
A stereoscopic sensing module, composed of 3 
separated fisheye cameras, can  measure 3-D 
coordinates of objects being lay around super-wide 
view angle have been developed in this project. 
The achievement of gigantic view angle is through 
the inherent optics of fisheye lens; whereas the key 
reason should succeed is our patent technology in 
deriving the visual model of it. 
Research Target（研究目的） 
Taking our patented technology of the fisheye 
image processing as a basis, we are developing a 
mini-motion capture system (MOCAP-F) using 
fisheye camera as its visual sensor. MOCAP-F will 
take simultaneously objective images from plural 
camera sets separately located. The each image 
been obtained will independently be processed in 
order to extract featured 2-D planer coordinates; 
then, referring positions and visual parameters of 
cameras, the 2-D coordinates obtained are each 
other paired to derive 3-D positions of the object 
in the viewing space. An involved image 
processing procedure composed of serial steps will 
be applied to each of the separated video stream. 
This processing pipeline is not only with the data 
intensity but also with the calculation intensity. 
Furthermore, the operations applied to among all 
the video channels are similar almost. Intuitively, a 
multi-thread implementation would be fine, and, 
better if using a multi-core architecture. Ideally, 
the processing task of each channel shall be han-
dled by a unique core to process 2-D jobs and then 
work together for the 3-D job. 
II. Documents’ Review       
（文獻探討） 
  Cameras used in computer vision survey im-
aging mechanism taking the perspective projection 
as basis. The deviation from is consequently based 
Generated by Foxit PDF Creator © Foxit Software
http://www.foxitsoftware.com   For evaluation only.
 3 
 
vealed the severest deviations occurred at the ze-
nithal angle of pi/4.  It contradicted to the com-
mon expectation that the deviations would grow 
with the image length. It is predicted an alternative 
result could be obtained if the viewpoint based in 
constructing the zenithal angles were adjusted.  
Hitherto there is no documented survey posing the 
projection center of a fisheye camera exactly and 
based to develop the model-based calibration me-
thodology in computer vision engineering.  
This paper is presented in the sequence hereafter. 
At first，the implementation of camorama will be 
introduce briefly, included its role as a software 
component in GNU/Linux world. Next, our exten-
sion of multi-channel videos and the adaption of 
pthread lib shall be discussed. And, at last, the ex-
perimental results will be based demonstrate our 
improvement to this project. 
III. Methods （研究方法） 
PC installing a multi-core processor is common 
nowadays. The software system aims at taking the 
benefit of parallel processing of the advanced ar-
chitecture. Ideally, the target is a linear throughput 
promotion in scale with the number of processing 
cores inside a CPU.  
However, the application process is a passive 
unit in the computer system. A running process 
cannot autonomously request CPU service. Such 
as in GNU/Linux, the kernel monopolizes all the 
system resources, including the allocation of CPU 
to one of the ready processes in waiting queue, or 
the preemption of a running context. Nevertheless, 
if there is an operation system cannot effectively 
manage the system resource, the developing of an 
advanced application would be formidable. 
GNU/Linux is well developed platform with stable 
and sturdy performance. Furthermore, it owns suf-
ficient legacy of open sources related to mul-
ti-media application. Taking a free resource as the 
foundation to an advanced application is a practice. 
We also take the strategy in developing our MO-
CAP-F project. However, the jobs are not go as we 
want. The legacy resource won’t run well in the 
contemporary hardware usually.  This a topic 
should concern, and that shall be narrated in this 
paper. 
Our project took an open source LGPL project 
–camorama, version 0.16 -- as a basis [camorama]. 
The source code is downloaded from the public 
server in world wide wed, and, further, its binary 
could run well in a usual Linux system. Like some 
other open source project, camorama began indi-
vidually by the author, Greg Jones, years ago, and, 
then, some hackers joined. In web we can find 
people talked this project; however, the newest 
message from it official site was dated October 9, 
2007. We have enhanced its performance and ad-
justed its software module. Might some ones like 
our modification? We hope we can contribute back 
to open source society in the near future.  
GTK+
Video4Linux
Device Driver
Physical Device
Kernel Space
User Space
System call / Kernel
Camorama
  
Figure-1 Layers of camorama. 
 
Under GNU/Linux，running context of a process 
is divided into two halves，one in user space and 
the other kernel space. Further, the working com-
ponent among modules related each other logically 
in layers. Figure-1describes layers of Camorama 
project. Camorama used two user space modules: 
GTK+ and Vieo4Linux. GTK+ is interface to 
graphical presentation and Video4Linux (or V4L) 
is to video capturing. They closely integrate with 
the Linux kernel and isolate camorama from the 
Generated by Foxit PDF Creator © Foxit Software
http://www.foxitsoftware.com   For evaluation only.
 5 
 
The later section of the main function confi-
gured the task running in the background. The 
procedure keeps active until the main process exit. 
Camorama implemented this job by the statement 
of:  
gtk_idle_add(  
(GSourceFunc) vpl_func,  
(gpointer) cam ); 
This arrangement makes the vpl_func() the 
background task. It defines contents of the video 
processing pipeline with (gpointer) cam as the ar-
gument. This task delivers performance of camo-
rama. In our download version, 0.16, the jobs se-
quentially executed to images are capturing, fil-
tering, and, then, displaying in the video window. 
The endless repetitive loop demonstrates an ani-
mation illusion. The execution rate and the actions 
inside the video processing pipeline (VPL) are 
based to perform the system evaluation.    
Camo_m, a multi-channel extension  
Camo_m extended functions of camorama. The 
modifications: First, expand the camera data 
structure to array type for handling four video 
channels. Second, make the VPL load of cameras 
heavier by adding specific algorithms, such as 
image remapping, features’ extraction, and image 
save, for MOCAP-F application. This modification 
makes the system closer to our target specification. 
 For further investigation, we also implement a 
damper module that can contribute the system 
wide load. This topic will be recalled in the result 
and discussion section. The target is to make the 
system feel not so comfortable, but work! 
UI of Camo_m changes. We shall briefly discuss 
the topic of UI implementation in this section. A 
GNU tools glade is used as the design aid to con-
struct the hierarchical tree structure of camo_m as 
shown in figure 4-3. Glade not only facilitates the 
configuration of window appearance but also gen-
erate the source code as a next step foundation, 
which automatically allocate components needed 
from GTK+ or GNOME library.  
 
 
Figure-3 UI tree of Camo_m 
To develop a window appearance with the layer 
structure described by figure-4 is quite 
straightforward. Fisrt, a GTKwindow widget is 
place to represent the visual presentation of an ap-
plication. This outer most component is a manda-
tory in a UI construction. Next, a GTKVBox is set 
up for the sake to contain a GTKMenu，  a 
GTKTable, and a StatusBar in next layer. These 
three components are also containers, which will 
configure the detail appearance of our application. 
The GTKMenu can contain any number of user 
options. Now only the items of the first sub layer 
are shown. They are CCD0, CCD1, …. In our im-
plementation of camo_m, the steps of VPL can be 
configured under this layer. To the GTKTable, it 
provides the way to display the 4 video channels in 
two by two rectangles of similar dimension. The 
sub-layer GTKFrame is needed if a title will be set 
for each channel; then inside which are the four 
drawing area. After these steps, the results are 
shown in figure 5. 
Generated by Foxit PDF Creator © Foxit Software
http://www.foxitsoftware.com   For evaluation only.
 7 
 
Camo_n, a multi-thread version 
Camo_n promotes the performance of camo_m 
by using POSIX Thread library. For the most part 
camo_m and of camo_n are kept similar. The only 
change is the arrangement of background tasks. It 
is composed of 2 sub-parts.  
for(i=0; i<number_of_camera; i++){  
…// othe part of the front task 
pthread_create( 
&camera->thread[i],  
NULL, (void*)&sub2_vpl_func,  
(void*)&arg[i]); 
gtk_idle_add( 
(GSourceFunc) sub1_vpl_func,  
(gpointer) cam[i]); 
  
…// 
} 
Under such modification, a separated thread that 
execute the function of sub2_vpl_func() will ser-
vice for each video channel. We put the application 
specific video algorithm inside for system evalua-
tion. Nevertheless, the jobs in sub2_vpl_func() are 
only that of trivial background tasks, such as the 
displaying update and etc. 
III. Results and Discussion   
（結果與討論） 
This project, MOCAP-F, use fisheye cameras to 
implement a movement capture apparatus. It takes 
GNU camo resource as the basis. Up here, the de-
velopment procedure had been briefly introduced. 
This section its performance in general PC of these 
implementation will be discussed. 
To evaluate performance of cmmo_m and ca-
mo_n alternately, we run them in the 
GNU/LINUX， Red Hat fedora 6.0. The PC used 
are alternatively of single-core, duo-core and 
quad-core PC. It is known that the performance of 
PC is not only decided by the CPU type, but also 
the working frequency of mother board, the in-
stalled peripheral IC, the amount and specification 
of memory, and so on, or even the vendor. We 
prefer categorize the test PCs to the single-core 
epoch, of duo-core epoch, and of quad-core epoch. 
The system load is monitored while the tested 
program started. It is not only a new process 
named camo_x found but also the loading index of 
XORG process increased. We infer the XORG 
variation is due to the screen animation using re-
source under GTK. In following discussion we 
sum up the load of XORG process and of camo_x 
process to the load of the application. 
Table_1 Performance indexes of camo_x 
 
Table_1 show the test results of camo_x. The 
first row displays the respective loading index of 
Xorg. The second is of the load of camo_x process. 
The third is the sum of the two raw above. The 
bottom is the cycles of VPL been finished per 
second. From here later, we define the VPL unit 
cost as row three over row four. In addition, be 
noted that the performance index of a single-core 
CPU is 100 units, of the duo-core is 200 units, and 
of the quad-core is 400 units. 
In testing single core PC, the system is quite 
clumsy and the CPU utility is more than 90%. ca-
mo_n only processes 1.1 image, but the CPU re-
sources already reached 91%, The camo_m has the 
load even higher and can process 2.5 images. An-
yhow, two tests reveal that single-core PC seemed 
unable run effectively in our MOCAP-F applica-
tion. The result guides us not to discuss the single 
core subject lately. By the ways, we cannot predict 
any effect obtained from the multi-thread modifi-
cation in the single-core’s system. 
In dual-core test, the camo_m uses 104 units of 
Generated by Foxit PDF Creator © Foxit Software
http://www.foxitsoftware.com   For evaluation only.
 9 
 
first three dampers are added, the app() has the uti-
lization that is still greater than 100 units. Contin-
uing to increase dampers will gradually reduce the 
utilization ratio of the app(). 
camo_m@dual
0
20
40
60
80
100
120
140
160
180
200
0 1 2 3 4 5 6 7
load數值
數
值
0
5
10
15
20
25
30
fr
am
es
\se
c
performanc
e
Xorg
main()
app
damper
load
CPU utility 
 
Figure-7. CPU indexes of camo_m at 
duo-core PC. 
 
camo_n@dual
0
20
40
60
80
100
120
140
160
180
200
0 1 2 3 4 5 6 7
load個數
數
值
0
5
10
15
20
25
30
fr
am
es
\se
c
performanc
e
Xorg
main()
app
damper
load
CPU utility 
 
Figure-8. CPU indexes of camo_n at duo-core 
PC. 
 
Figure_9 shows the camo_m app in a quad-core 
PC. This graph is quite different from the previous 
two of duo-core PC. As the stepping up of the 
damper load, the outcome of the application will 
no be degraded, kept always the number of VPL 
17 pieces per second. Viewing the loading profile, 
the damper curve is near linearly increased in the 
first three steps, and, then, kept constant; whereas, 
that of camo_m app is almost fixed, or, said as 
dropping slowly. For a detail observing, the nu-
meric data of this figure is shown in table-2. Au-
thors agree that the further discussion is needed.  
Figure-10 shows the camo_n app performance 
in four-core PC. The performance dealing with 
VPL has reached our specifications, which handle 
30 frames per second. The CPU utilization of this 
application is 275 units when in the absence of 
damper. After joined first damper, it take the CPU 
utilization of 100 units whereas the app dropped to 
225 units. The CPU load is almost full after added 
the second damper. Further stepping the number of 
the damper process, the CPU utilization units of 
app dropped limitedly. 
 
四核心camorama
0
50
100
150
200
250
300
350
400
0 1 2 3 4 5 6 7
load個數
數
值
0
5
10
15
20
25
30
fr
am
es
\se
c
performance
Xorg
main()
app
damper load
CPU utility
 
Figure-9. CPU indexes of camo_m at quad-core 
PC. 
四核心multi_c amera
0
50
100
150
200
250
300
350
400
0 1 2 3 4 5 6 7
load個數
數
值
0
5
10
15
20
25
30
35
fr
am
es
\se
c
performanc
e
Xorg
main()
app
damper
load
CPU utility
 
Figure-10. CPU indexes of camo_n at quad-core 
PC. 
The aim of this paper is to survey a solution that 
is suitable in the developing of an advanced 
project. The camo_m is expanded to handle multi-
channel will increases the VPL load, it is already 
unable to work smoothly in single-core PC. Then, 
the result discussion will focus on the double-core 
and four-core PC. 
Under the program structure without changing 
to expand into four cameras can be displayed. And 
Generated by Foxit PDF Creator © Foxit Software
http://www.foxitsoftware.com   For evaluation only.
