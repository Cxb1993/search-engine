?????????????????????(I)
“Design of Low-power Asynchronous Processors and Cache Systems”
?????NSC 96-2221-E-018 -025 -
?????96 ? 8 ? 1 ? ? 97 ? 7 ? 31 ?
??????? ?????????????????
??????
?????????????????
????????????????????
???????????????????
???????????????????
????????????????????
????????????????????
????????????????????
????????????????????
????????????????????
????????????????????
????????????????????
??????????????
?????????????? Balsa ?
????????????????????
????????????????????
????????????????????
?????????? AsynRISC-DHDT1P?
AsynRISC-DHDT2P ? AsynRISC-DRC???
??????????????????
DRC(Destination Register Chain) ? ? ? ?
DHDT(Data Hazard Detection Table)????
??????????????
????
Asynchronous circuits have the potential
advantages of low power consumption, high
operating speed, low electro-magnetic emission,
no clock skew problem, and robustness towards
variations in temperature, supply voltage and
fabrication process parameters. Since
asynchronous logic adopts distributed control
scheme, the traditional methods for handling
hazards in synchronous processors can not be
directly applied to asynchronous processors. In
this research, we have designed an asynchronous
pipelined processor, called AsynRISC, which is
implemented by using the asynchronous
hardware description language Balsa.
Experiment results show that an asynchronous
processor with the proposed data hazard
handling scheme, DRC (Destination Register
Chain), can achieve higher performance and
lower area cost than those with DHDT (Data
Hazard Detection Table) scheme.
??????????
?????????????(1)????
????(2)???????????(3)??
? clock skew ???(4)??????????
(5)??????????(6)???????
????
Balsa description
(.balsa file)
Breeze description
(HC netlist:.breeze file)
Compass netlist EDIF 200 netlist Cadence netlist
layout xilinx bitstream layout
Balsa behavioural
Simulation system
Behavioural
Simulation
Functional
Simulation
Timing/Power
analysis
Simulation
results
`balsa-c`
Synthesis
R
euse
`balsa-netlist`
????? Balsa ????????????
instruction color ? system color ??????
?????????????? Control
Transfer ? (???EXE stage ??? jump ?
?? taken ? branch ??)?EXE ?????
sys_color ???????(0 ? 1?1 ? 0)??
?????? system color??? branch target
address ???? IF stage?IF stage ?????
???? inst_color ????????
? AsynRISC-DHDT ?????????
Data hazard ????? DHDT (data hazard
detection table) ????? register file???
???? Forwarding ???? DHDT ????
??????? value ?????????
1-bit ? dirty ??? 2-bit ? PII (Pending
instruction index)???dirty ????????
?? value ???????????????
??????????? dirty ????? 1?
???????????????????
???????????????????
?????????? Forwarding ?????
?????????? PII (Pending instruction
index)?????????????????
???????????
? AsynRISC-DHDT2P ????????
????? DHDT ???????????
????????○1????????(value?
dirty?PII)???????? drity ?????
????????????????? drity
??? 1 ????????????????
? PII ?????? instruction index ????
????????????????????
?????????????? value ???
???????○2??????? drity ???
? 1????????? PII ????
Cur_index??? AsynRISC-DHDT1P ??ID
stage ?????? DHDT ??? phase ??
? ? ? ? ? phase ? ? ? ? ? ?
AsynRISC-DHDT ??ID stage ????? WB
stage ??????????????
DHDT?? ID stage ?????? DHDT??
WB stage ? ? ? ? ? ? ? ? ? ?
AsynRISC-DHDT2P ??ID stage ?????
? DHDT ?????????????
AsynRISC-DHDT1P ??ID stage ?????
? DHDT ? ? ? ? ? ? ? ? ? ?
AsynRISC-DHDT ????? 2 phase ? 1 phase
? DHDT ????????????????
operand_1
operand_2
forwarding
condition
FW_from_MEM
FW_from_WB
Forwarding
Unit
rd rs1 rs2
Register
File
?? rs1 ?
rd_EXE?rd_MEM
?? rs2 ?
rd_EXE?rd_MEM
DRC
rd_MEM
rd_EXE
IR
ID stage EXE stage
???AsynRISC-DRC ? ID stage
?????? AsynRISC-DRC ? ID stage
????? ID stage ?????? DRC
(Destination Register Chain)???????
rd?rd_EXE ? rd_MEM ????rd ????
? ? ? ? ???????? (destination
register)???? rd_EXE ? rd_MEM ???
?????????????? ID stage ??
????????????? source register
??? rd_EXE? rd_MEM ??????
forwarding condition?? source register number
== rd_EXE??? Register File ???? source
register ?????????????????
forwarding ?? channel FW_from_MEM ?
? ? ? ? ? source register number ==
rd_MEM?? source register ????????
forwarding ?? channel FW_from_WB ???
????? Balsa ????????
MIPS R2000 ????????????
AsynRISC-DHDT1P?AsynRISC-DHDT2P ?
AsynRISC-DRC????? Balsa ????
????????????
???? NSC 96-2221-E-018 -025 -
???? ?????????????????????(I)
??????
???????
???
?????????????????
?????? 25-27 May 2008, ??????
???? 2008 International Conference on Communications, Circuits and Systems
?????? Design of an Asynchronous Pipelined Processor
????????
?????????????????????????????????
????? ICCCAS 2008 ?????--???ICCCAS 2008 ?????????
???????????????????????????????????
????????????????? keynote speech???? keynote speech ?
????CNN (Celluar Neural Network): Twenty years later????? keynote
speech ????Memristor?????? 319 ???????? 36 ? lecture
sessions ????????? session ??? Low-power circuit design ?????
?????????????????????????????? ICCCAS
2008 ?????????????????????????????????
???????????
??????
ICCCAS 2008 ????????????????? CNN ? keynote
speech????? Nature ??? 2008 ???????????? (Memristor)?
???????????????????????????????????
????????????????--????????? ICCCAS 2008 ???
?????????????????? keynote speech?
????????? keynote speech ??CNN (Celluar Neural Network):
????????????????? Nonvolatile Memory?
?????? paper ????? Balsa ???????????????
???????????????????????????????????
clock skew ??????????????????????????????
???????????????????????????????????
session ???????????????????????????????
session ??????????????????
????????????????????????????????
?????????????????????????
Figure 1. Microarchitecture of the AsynRISC processor
II. MICROARCHITECTURE OF THE ASYNRISC
PROCESSOR
Figure 1 shows the microarchitecture of AsynRISC. The
AsynRISC processor is a five-stage pipelined asynchronous
processor with the same instruction set as that of MIPS
R2000. AsynRISC employs the coloring scheme and DHDT
(data hazard detection table) to deal with control hazards and
data hazards, respectively. As the MIPS R2000 processor,
the five pipeline stages in AsynRISC are IF (instruction
fetch), ID/RF (instruction decode/register fetch), EXE
(instruction execution or memory address calculation), MEM
(memory access) and WB (register write back).
A. Control Hazard Handling Scheme
In order to solve the problem of control hazards,
AsynRISC uses two 1-bit registers, the inst_color
(instruction color) register located in the IF stage and the
sys_color (system color) register located in the EXE stage, to
implement the coloring scheme (see Figure 1). In AsynRISC,
all control transfers, such as jumps or conditional branches,
take place in the EXE stage. When the processor is reset,
both inst_color and sys_color are reset to 0. When the IF unit
fetches a new instruction from memory, it will attach the
instruction with the color (value) of the inst_color register,
and then send the instruction to the succeeding stages. When
the EXE stage receives an instruction, it will first checks
whether the instruction color is matched with the system
color in the sys_color register. If it is matched, the
instruction will be executed as a normal instruction;
otherwise, the instruction will be nullified.
If a conditional branch is proven to be taken, the EXE
stage will change the color of the sys_color register, and then
send the branch target address together with the system color
to the IF stage. Those instructions from the branch fall-
through path might have entered into the pipelines before the
branch is resolved, but they will be nullified in the EXE
stage as their instruction colors are not matched with the new
system color. When the IF stage receives the new branch
target address and the new system color, it will use them to
update the program counter (PC) and the inst_color register.
Thus, those instructions from the branch target path will be
appended with instruction colors same as the system color,
and will be treated as normal instructions in the EXE stage.
B. Data Hazard Handling Scheme
The register file of the AsynRISC processor is organized
as a DHDT (data hazard detection table) to handle the data
hazards. Besides the value field, every general-purpose
register in the DHDT has two extra fields, the 1-bit pending
bit and the 2-bit pending instruction index (PII). If the
pending bit is 0, it indicates that the value in the
corresponding register is up-to-date; if the pending bit is 1,
the corresponding register is waiting for some instruction in
the pipeline to write back its new value, and the pending
instruction index (PII) field records which instruction in the
pipeline will produce the result.
In AsynRISC, the IF stage maintains two special registers,
the 2-bit instruction index register and the 1-bit FBTI (first
branch target instruction) register. Every instruction gets its
own index from the instruction index register and then the
instruction index register is increased by 1. Instruction
indexes are used to trace the order relationship between
instructions in the ID, EXE, MEM, and WB stages. Since at
most four instructions can reside in those four stages, two
bits are sufficient for the instruction index register.
When an instruction along with its own instruction index
enters the ID stage, it tries to get its source register operands
from the DHDT. If the source register’s pending bit is 0, the 
source operand can be acquired directly from the register;
however, if the pending bit is 1, the value in the source
register is not up-to-date and some instruction in the pipeline
will produce the real operand. In this case, the decoding
instruction can not get its source operand immediately, and it
will get the operand via the forwarding mechanism when it
enters the EXE stage. The decoder in the ID stage compares
the decoding instruction’s instruction index, denoted by Ik,
with its source register’s pending instruction index (PII),
denoted by Ij, to determine the forwarding condition, i.e.,
from which stage the operand should be forwarded to the
EXE stage when this instruction is being executed. If Ik =
alu_out mem_out
IF
inst_color
inst_index
FBTI_bit
PC
ID/RF
DHDT
R0
R31
R1
value pending PII
Forwarding
Unit
EXE
ALU
system color
MEM
Data
Memory
WBinst
inst_index
inst_color
FBTI
EXE_ctrl
operand_2
operand_1
forward_cond
inst_color
inst_index
MEM_ctrl
inst_index
WB_ctrl
inst_index
FW_from_MEM
FW_from_WB
WB_result, inst_index
branch_target_addr, system_color
Instruction
Memory
