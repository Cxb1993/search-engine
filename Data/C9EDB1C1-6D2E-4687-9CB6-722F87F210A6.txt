i摘要
本研究探討二個主題: UM L 圖形一致性檢查及軟體知識分類機制之精進。UML 語
言已是今日軟體設計最常使用的軟體塑模工具,，不同階段軟體文件的 UM L 圖形若有不
一致的情事發生,將導致軟體之錯誤，然而今日之物件導向軟體開發環境對於跨階段UML
圖形之一致性檢查功能卻嚴重不足，導致軟體開發團隊需花費甚多人力來做不同階段
UML 圖形的一致性的檢查，實有必要提出有效機制對跨階段(需求與分析階段間及分析
與設計階段間)的 UML 圖形作一致性檢查，以提升軟體文件之可追溯性。
本研究分析跨階段 UML 圖形中各元素的相亙關係，進而提出下列機制：
(1) 將 use case 的 flow of event 以表格式描述，以利 collaboration diagram 之 class 名稱及
responsibility 之制定,及作 use case 與 collaboration diagrams 的一致性檢查。
(2) 建立 design class 與 analysis class 的對應與導出關係,以利 analysis 階段與 design 階
段 class diagrams 的一致性檢查。
(3) 建立 analysis classes、middleware 及 system software 與 design classes 之關聯關係，以
方便設計階段 design classes 及 sequence diagram 之設計。
透過上述機制，可容易進行(1) use case diagram 與 collaboration diagram，(2)
collaboration diagram 與 analysis class diagram , (3) collaboration diagram 與 sequence
diagram，及(4) analysis class diagram 與 design class diagram 之一致性檢查，本研究己在
ArgoUML 開發環境加入上述機制,經驗證確有助於在開發前期提早發現軟體文件中 UML
圖形不一致的問題。
在軟體開發過程中，軟體工程師常需搜尋必要技術知識(論文、技術報告、或書本)
以助發展,目前技術知識庫的關鍵字缺乏良好制定法則，無法有效代表技術知識的完整意
iii
Abstract
This research studies two issues: consistency checking of UML diagrams and effective
classification technique for software knowledge. Unified Modeling Language (UML) has been
wisely used to build various software models in software development process. The inconsistencies
of UML diagrams of two sequence phases will generate defects or bugs in the final software
product. However, most of current UML building tools do not provide any facility to check the
inconsistency of UML diagrams of two sequence software development phases. Software
development teams have to spend extra human resources to check the inconsistency issue in UML
diagrams. The first purpose of this research is to develop effective consistency checking mechanism
to check UML diagrams of two sequence phases to improve the traceability between software
documents.
After analyzing the relationships between elements appeared in various cause-effect UML
diagrams of two sequence software phases (requirement capturing to analysis and analysis to
design), we find the following properties:
1. Using table to describe the flow of event of each use case scenario is easier to identify
class names and their responsibilities in collaboration diagrams and to check the
inconsistency of use case scenario and the corresponding collaboration diagram to
developer.
2. In design phase, defining the inheritance or derived relation between design class and
analysis class will give great help in doing consistency checking between analysis class
diagram and design class diagram.
3. Defining the inheritance or derived relations of design classes with analysis classes,
middleware, or system software will help to identify the inconsistency between sequence
diagrams and corresponding collaboration diagrams during the design phase.
Based on the above properties, we propose some facilities to help developers to define analysis
classes, design classes and sequence diagrams, we also propose some mechanisms to verify the
inconsistency between (1) use case scenario and collaboration diagram, (2) analysis class diagram
and collaboration diagram, (3) collaboration diagram and sequence diagram, and (4) analysis class
diagram and design class diagram. The above facilities and mechanisms have been implemented on
the ArgoUML developing system, developers can find out the inconsistencies between software
artifacts earlier and hence reduce mistakes and costs in software design.
When developing software, software developers need to search for some technical knowledge to
help the development. However, they usually spend a lot of time to find out the suitable technical
document due to the technical knowledge lack of good indexing keyword definition to stand for its
main point. Most popular used knowledge classification techniques are Taxonomy, Faceted
classification, Case-based reasoning, and Ontology. Among these techniques, Taxonomy is too
simple to be effective. Faceted classification is too complicated when the amount of knowledge
increases, it’s also difficult to define good facet for software knowledge. Case-based reasoning
lacks classification structure for knowledge domain. Ontology uses its model to describe knowledge,
but there is no relationship between knowledge. Since above techniques is not designed for software
knowledge, applying to software knowledge management has drawbacks. The second purpose of
this research is to develop new software knowledge classification technique to improve the
searching efficiency.
The main purpose of a technical document (paper, thesis, or technical report) is to propose a
new approach to a technical issue of a specific technical area. Books introduce some technical
knowledge (issues and solutions) in a specific area to readers. Hence, we can identify a technical
document by using the technical category it belongs, the issue it discusses, the approach it proposes
to solve the issue and techniques used in the approach. With this representation, it’s very easy to use
object oriented relations to construct the relationship between knowledge. Based on the above
concept, this research proposes a problem- approach-based knowledge classification technique for
software knowledge management system. This system classify knowledge domain with hierarchy
目錄
中文摘要 i
英文摘要 iii
第一章 緒論........................................................................................................................................1
1.1 計畫背景、研究工作項目與預期成果..............................................................................1
1.2 章節安排..............................................................................................................................4
第二章 UML 圖形背景知識與相關研究.............................................................................................6
2.1 USDP (Unified Software Development Process)與 UML.............................................6
2.2 UML 圖形間的一致性問題與相關研究...............................................................................8
第三章 UML圖形間相關性之分析................................................................................................ 11
3.1 USDP 各階段之產物........................................................................................................... 11
3.1.1 Requirement Capturing 階段............................................................................. 11
3.1.2 Analysis 階段.......................................................................................................15
3.1.3 Design 階段...........................................................................................................17
3.2 跨階段產物間相關性之分析............................................................................................21
3.2.1 from Requirement Capturing to Analysis....................................................21
3.2.2 from Analysis to Design..................................................................................28
第四章 具跨階段產物一致性檢查及輔助機制之設計..................................................................38
4.1 設計策略............................................................................................................................38
4.2 需求階段(Requirement Capturing)..............................................................................39
4.3 分析階段(Analysis)........................................................................................................40
4.4 設計階段(Design)............................................................................................................43
第五章 跨階段產物一致性檢查系統之架構..................................................................................48
5.1 ArgoUML 之系統架構........................................................................................................48
5.1.1 General architecture........................................................................................48
5.1.2 Packages................................................................................................................50
5.1.3 ArgoUML 介面設計.................................................................................................53
5.2 一致性檢查方法在 ArgoUML 上之設計架構....................................................................55
5.3 系統介面............................................................................................................................57
5.3.1 Requirement Capturing 階段.............................................................................57
5.3.2 Requirement Capturing to Analysis..............................................................62
第二部份 知識分類機制之精進....................................................................................................66
第六章 「知識分類機制」之背景知識與相關研究......................................................................67
6.1 軟體知識管理..................................................................................................................67
6.2 軟體知識分類方法..........................................................................................................70
6.2.1 Taxonomy..............................................................................................................70
6.2.4 Ontology..............................................................................................................76
6.3 現有知識分類方法的問題..............................................................................................77
第七章「問題–解法」軟體知識分類法之設計構想....................................................................80
7.1 軟體技術知識的本質......................................................................................................80
7.1.1 技術論文本質......................................................................................................80
7.1.2 技術報告本質......................................................................................................86
7.1.3 書本知識本質......................................................................................................87
7.2 以問題–解法為基礎的軟體知識分類方法..................................................................91
第一章 緒論
1.1 計畫背景、研究工作項目與預期成果
本研究是延續本人所執行國科會計畫「Web-based 軟體知識管理系統之研究
與製作」(執行期限:九十年八月至九三年七月),此軟體知識管理系統與 ArgoUML
開發平台整合為一具軟體知識管理機能的軟體開發平台,軟體設計人員利用此平
台開發軟體過程中,可隨時搜尋軟體知識庫、再利用軟體元件庫、軟體產物貯存
庫、及個人能力資料庫,有效解決軟體開發過程中搜尋軟體元件、軟體產物、軟
體知識、及諮詢伙伴等問題,此平台經試用後發現有二個新議題待解決:(1) 缺乏
跨 UML 圖形間自動檢驗機制,(2) 知識分類關鍵字制定機制不良，前者發生在軟
體開發由需求階段進入分析階段或由分析階段進入設計階段時,後者所產生的文
件是否均可追溯至前階段,若僅靠人檢查,易造成不同軟體發展階段文件的不一
致，而造成軟體錯誤；後者則因關鍵字選擇缺乏規則,易造成軟體知識文件分類
不良,而造成搜尋效率及效能不佳，甚至影嚮跨領域知識的搜尋，進而影嚮軟體
開發之效率及效能；因此本研究主要進行「跨 UML 圖形間自動檢驗機制」及「知
識分類機制之精進」之研究。
本研究擬進行的研究工作包括：
「跨 UML 圖形間自動檢驗機制」方面
1. UML 圖形間 things、relations 與 properties 間對應關係的尋找
2. UML 圖形間 traceability 與 consistency 檢查方式的探討
3. UML 圖形中 things 與 relations 內部表示方式的設計，以 ArgoUML 工具內
部的原有資料結構為基礎，再加上與 consistency 及 traceability 有關所新資
料
4. 在 ArgoUML 上開發跨 UML 圖形間 traceability 與 consistency 自動/半自
動檢查機制。
「知識分類機制之精進」
1. 軟體知識的關鍵字分類機制之探討
2. 軟體知識關聯性的分析
3(2) 進行實用性及完整性評估與精進
「知識分類機制之精進」部份
(1) 知識儲存格式及知識搜尋演算法：研究有效率的知識儲存格式，使其提供
有效率的新增、更新、搜尋功能。知識搜尋演算法則建構在知識網路之上，提供
快速的關鍵字搜尋及相關知識的取得。
(2) 知識分享平台的安全性架構：包含使用者驗證、知識加密、交易控管的安
全性架構，運用數位簽章、密碼方法及交易模型來達成。
(3) 製作及評估知識分享平台：運用前述的成果建構知識分享平台，並進一步
分析其所達成的效益。
5第一部份 跨 UML 圖形間自動檢驗機制
7的互動關係(以 sequence diagram 表示)、及定義各 design classes 間的關係。
d. Implement：依 Design 的結果運用程式語言實作軟體系統，系統的組成
包含 component、source code、scripts、binaries 與可執行檔案等，工作重點
包括 component 的配置、及 subsystem 與 class 的實作與 test。
e. Test：主要工作為設計與規劃系統的整合方式與測試流程、規劃 test
case、執行軟體及系統整合測試。
執行上述步驟的過程都會有相對應的產物(artifact)產出以供品管人員驗
證其正確性、完整性及一致性，這些產物大多以 UML 語言來表示撰寫此階段的模
式，這些產物將在第三章詳細介紹。
UML 語言之基本元素為 things 及 relations，由 things 及 relations 可構
建九種不同 diagrams 以描述軟體發展各階段的 models，利用這九種 diagrams
及相關說明文件即可構建出完整的軟體產物，這些 diagrams 甚至可透過 XML 語
言表示以供軟體設計文件交換之用，更加速軟體元件及軟體設計文件之再利用，
對軟體生產力與品質的提升有極大助益。UML之九種diagrams可分為structural
diagram 與 behavior diagram 兩大類，此九種 diagrams 簡要說明如下：
Structural Diagram
1. Class Diagram: 由 classes、 interfaces、collaboration 及 relations
等組成，以表示 classes 之間的關係。在 USDP 過程是透過 class diagram 以表
現 analysis classes(analysis 階段)或是 design classes(design 階段)之間的
關係。
2. Object Diagram: 由一組 objects 與 objects 之間關係所組成，Objects
通常來自 class diagram 中 classes 的 instances，用來代表設計階段特定
objects 間之互動關係。
3. Component Diagram: component 是系統中一個密不可分的運作單元，透
過 component diagram 可表示一群 components 之間的互動關係及各 component
的組成元素。
4. Deployment Diagram: 包含各類實體運算資源 nodes 的分佈與連接關
係，及各 node 上置放的 components，代表系統軟硬體佈署關係，在 design 及
implement 階段，可利用 deployment diagram 來表示各 node 上的 subsystems
及/或 components。
Behavior Diagram
5. Use-Case diagram: 包含 use cases、actors 及兩者間的關係，actors
代表與系統相關之周邊環境元件，use case表示一種系統功能，actor與 use case
9a.同階段 UML 圖形間相互的不一致：指同一個階段中(如同在 design 階段)，
產生的產物間有不一致的情形存在。例如 design 階段某一 sequence diagram
中，object A 呼叫另一個 object B 所不存在的 operation，即 class diagram
中 object B 所屬的 class 並沒有定義該 operation。
b.跨階段 UML 圖形相互間的不一致：指跨階段中(如 analysis 至 design 階
段)，產物間有不一致的情形存在。例如 analysis 階段中被定義的某個 analysis
package 並沒有在下個階段(design 階段)被 design subsystem 所實現，此時就
代表 design 階段並沒有完整的把上個階段的結果延續下來，所以就產生了不一
致。
產物的 UML diagram 若發生不一致的錯誤將導致開發者設計出錯誤的系統。
目前的軟體開發環境如 Rational 公司的 Rational Rose、The Regents of the
University of California 的 ArgoUML 等除可提供繪製 UML 圖形功能，也會自
動檢查單一 UML 圖形中資料之完整性、一致性、及模糊性，並提出警告訊息，但
其功能僅限制於同一個 diagram 形式內資料的檢查或是同一個開發階段，尚無法
作到跨圖表與跨階段間資料一致性的檢查，換言之，目前的工具尚無法作到跨
UML 圖形間追溯性的自動檢查，因此在發展大型軟體的過程仍然會發生不同階段
的設計文件間有 inconsistent、incomplete、及 ambiguous 的問題，仍需靠人
檢查以找出，花費甚多人力與時間，若有適當方法可自動或半自動檢查圖形間不
一致現象，對軟體發展的效率與品質的提升有重要助益。
有關跨 UML diagram 間的 traceability 與 consistency 檢查的研究成果雖
已有人提出，但仍有甚多不足之處，如 Padmanabhan Krishnan 提出將 UML 的
diagram 轉換成一套以 state 為基礎的 PVS 表示式[7]，再藉著 PVS 檢查 state
sequence 的架構來判斷這些由 diagram 轉換成的 states 是否一致。這項研究之
不足之處有：
1. 需另外引用一套新的語法
2. 僅能將 sequence diagram, activity diagram, use-case diagram 中
部分的 UML 轉成 PVS 語法。
3. 缺乏充足的實例證明能有效解決traceability與consistency的問題。
Oliver Laitenberger 提出一套”reading techniques”來幫助 reviewer
更有效的找出文件中不符合 consistency 之處[8]，不過僅針對需求與分析階段
中部分 diagrams 提供一些 review 時該注意的 guidelines，不能作到自動或半
自動檢查。Pascal Fradet 等人則提出利用圖論(graph theory)的關係(relation)
來檢查 diagram 與 diagram 間的圖形結構有沒有相似[9]，配合正規語言將
11
第三章 UML圖形間相關性之分析
本章主要探討 USDP 工作流程中自 requirement capturing 階段到 design
階段各階段產物的關係，包括同階段間產物的一致性與跨階段間產物的一致性，
並藉由這些相關性進一步提出如何透過適當增加產物的相關資訊來協助進行跨
階段圖形間的一致性檢查。
本章討論 USDP 中的前三個流程，包含了該階段流程的描述以及其所產生的
產物，另外也依據該階段產物間的關係提出本系統所能提供使用者之一致性檢查
功能。以下共分為三個小節，3.1 節討論 USDP 流程中各階段的產物以及在同一
個階段間產物的相關性，3.2 節討論跨階段產物的相關性。
3.1 USDP 各階段之產物
UML 語言所規範的九種 diagrams 用於描述 USDP 的各式文件，requirement
capturing 階段使用 use case diagram 描述系統中 actors 與 use cases 的關
係,activity diagram 描述一個 scenario 的活動流程；在 analysis 階段使用
class diagram 來說明系統內 analysis class 之間的關係,使用 collaboration
diagram 來描述特定之 analysis class 間如何互動以實現 use case 之某一
scenario；在 design 階段使用 class diagram 來說明系統內 design classes
的相亙關係,使用 sequence diagram 說明特定 design objects 間之互動流程以
實現一 use case 之特定 scenario,使用 deployment diagram 表示系統各 node
之關係及各 node 上佈署的 subsystem,使用 statechart diagram 描述一個複雜
design class 的狀態變化情形；在 Implementation 階段使用 component diagram
來描述系統 component內 component 間的關係,使用 deployment diagram 來表示
各 node 上 component 的佈署。
為發掘 USDP 各階段之 UML 圖形之關係，以下先描述 USDP 流程中的前三個階
段的工作流程、產物及使用之 UML 圖形。
3.1.1 Requirement Capturing 階段
Requirement Capturing 階段是開發流程中的第一個階段，根據 USDP 的定
義本階段的主要工作包含下列五個：
1. Find actors and use cases：
找出系統中的 actors 與系統所提供的 use case，並簡單描述每個 use case
的作用。
13
Architectural Description：architectural description 包含 use-case
model 的架構面(architectural view)描述，並說明在架構上有重要影響的 use
cases。系統的架構面必須同時將處理較重要或是較關鍵功能的 use cases 加以
描述，這些 use cases 將在系統的開發流程前期優先開發。
Glossary：glossary 被用來註明一些重要的或是常用的語詞(term)，這
些語詞將被系統開發人員或是系統分析師在描述系統時使用。它在整個開發文件
上扮演重要的角色，可以避免造成文字使用上的誤會以及定義不明的情況。
User-Interface Prototype：在 requirement capturing 階段可以先建立
使用者介面的雛型，這將對了解 human actor 與系統間之互動關係有助益，這不
只能幫助開發人員設計更好的使用者介面，也能讓開發人員更了解 use case。
use-case model 是以 use-case diagram 來表示各個 use case 與各個 actor
間的關係，use-case diagram 是 UML 標準所規定的圖形之一，用來描述系統的
static use case view，它提供了以下的資訊：
1.Use cases：系統所定義且必須完成的所有 use case。
2.Actors：用來起始 use case 的 actor，或是參與 use case 的其他 actor。
3.Relationships：包含了 dependency、generalization 以及 association，
用來表現 use case 間的關係。
一 use case 包含一個以上的 scenario，當系統複雜時，可透過 package 來
組合以展成階層式關係，方便使用者閱讀。以 Pay Invoice[6]這個 use case 為
範例，其詳細互動流程可描述如下︰
---------------------------------Start of Pay Invoice Use
Case--------------------------------
Use Case: PAY INVOICE
Initiator: Buyer
Actor: Buyer and Bank
Brief Description
The use case Pay Invoice is used by a Buyer to schedule invoice
payments. The Pay Invoice use cases then effects the payment on the due
date.
Context Diagram
15
1. In Step 2, the customer may instead ask the system to send an invoice
rejection back to the salesperson.
2. In Step 3, if there is not enough money in the account, the use case
will cancel the payment and notify the customer.
Postconditions
The use-case ends when the invoice has been paid or the invoice payment
was canceled and no money was transferred.
--------------------------------------End of Pay
Invoice-----------------------------------------
以上的 use-case model、use case、actor 及 use-case scenario 是以階層
式的方式來呈現的，use-case model 由 use case diagram 來表示，包含系統所
有定義的 use case 與 actor，而每個 use case 都必須有一個 use case
specification，其中包含了一個以上的 scenario，每一個 use case
specification 裡的 scenario 將會在 analysis 階段各自發展出一個
collaboration diagram。
3.1.2 Analysis 階段
根據 USDP 的定義 Analysis 階段包含有以下主要四個工作項目：
1. Architectural Analysis
1.1 定義系統中的 analysis package, service package, 與建立 analysis
package 間相亙依存關係。
1.2 定義 obvious entity class。
1.3 定義 common special requirement。
2. Analyze a Use Case
2.1 定義 analysis classes。
2.2 描述 analysis classes 間的 interaction。
2.3 Capturing special requirement
3. Analyze a Class
3.1 定義 analysis classes 所負責的 responsibility。
17
realization 是由一組 analysis classes 間的互動所構成，可使用
collaboration diagram 來透過那些 analysis class 之 responsibility 來完成
一特定 use case 之某一 scenario 所指定的功能，一個 use-case realization
可以直接對應到一個 requirement capturing 階段的 use case scenario。
 Analysis Package：analysis package 是將系統分為多個容易管理產物
的集合，它可以包含 analysis classes、use-case realizations、或是其他的
analysis packages。
Analysis 階段產生的 UML 圖形有 class diagram 與 collaboration diagram
兩種，每一個 collaboration diagram 均是透過數個 analysis class 的互動來
實現一個 scenario，而 class diagram 則是描述所有定義的 analysis class 的
關係，由以上的特性可以歸納出此兩種 UML 圖形間具有以下的相關性：
– 所有 collaboration diagram 中出現的非重複 analysis class 數量總數
必須與 class diagram 中的 analysis class 數量總數相同，這是因為所有被定
義的 analysis class 都必須出現在 class diagram 中，而這些 analysis class
也必須至少在一個 collaboration diagram 中參與互動。
– 在任何一個 collaboration diagram 中有 link 相連的 analysis class
也會在 class diagram 中有 relationship 相連，因為 collaboration diagram
中的 link 代表著要求另一 class 執行某一 responsibility，因此在 class
diagram 的對應 analysis classis 也有相對應的 relationship 存在。
同時在本階段的第一個流程將產生 analysis package，用來描述系統的架
構，analysis package 與上述的 collaboration diagram 及 class diagram 具
有以下的相關性：
– 在 class diagram 中有關係的一對 analysis classes，必須是位於同一
個 analysis package 中，或是彼此有關係相連的兩個 analysis package 中。這
是由於 analysis classes 的關係也會在 analysis package 間找到相對應的關
係，否則就是不一致。
3.1.3 Design 階段
Analysis 階段完成後緊接著的就是 Design 階段，根據 USDP 定義 Design 階
段的主要流程有以下四個：
1. Architectural Design：
1.1 定義系統的 node 與 network 並畫成 deployment diagram
1.2 定義系統的 subsystems 以及其提供的 interface, 這些 subsystems 大部
19
Design 階段最主要的工作是參照 analysis model 建立系統的結構來設計本
階段的 design model 並做為 implementation 階段的藍圖，有別於 Analysis 階
段較概念化的表示，Design 階段會考慮到實作的 physical model，使用者會因
為程式語言選擇的不同而產生具有多樣 stereotype 的 design class。
在經過 Analysis 的階段後，緊接著的 Design 階段就會將上個階段產生的產
物當作輸入，加以進一步處理後產生屬於 Design 階段的新的產物，Analysis 階
段所產生的 analysis model, analysis class(包含其 attributes 與
responsibilities), collaboration diagram, analysis class diagram, 以及
analysis package 都會在 Design 階段依照系統需求演進成其他的產物，圖 0-3
為此階段主要產物的關係圖，
圖 0-3 Design 階段之產物
這些產物包括有：
 Design model：用來描述 use case 的 physical realization 方法以及
functional 與 nonfunctional 的需求。
 Design class：由上個階段產生的 analysis class 演進而來，本階段將
參考 analysis class 而產生用來實現該 analysis class 的 design class。
 Use-Case realization-Design：用這個階段產生的 design class 取代上
個階段 interaction diagram 中的各個 analysis class，並建構以 design class
為主的 interaction diagram。
 Design subsystems
 Interface
 Deployment model：用來描述系統的各個 design subsystem 如何分布在
21
object 所屬類別的 operation 所構成，並以箭頭指向發生此 event 時 design
object 的目標狀態。
根據以上的特性可以歸納出以下幾種相關性：
a. sequence diagram 與 class diagram 的相關性
– 任何一個 sequence diagram 中有互動的 design object 間，在 class
diagram 中所屬的對應 class 間必須有關係存在。
– class diagram 中所有的 design class 其 instance 都必須至少參與一個
sequence diagram 的互動。
b. design subsystem 與 class diagram 的相關性
– 每個 class diagram 內的 design class 都必須屬於一個 design
subsystem。
– 在 class diagram 內有關係相連的一對 design classes 必須屬於同一個
design subsystem，或是有關係相連的一對 design subsystem 上。
c. design subsystem 與 sequence diagram 的相關性
– 任何一個 sequence diagram 中有互動的 design object 間，其所屬的對
應 subsystem 間必須有關係存在。
d. design subsystem 與 deployment diagram 的相關性
– 所有定義的 design subsystem 都必須要出現在 deployment diagram 上，
這是因為每個 design subsystem 根據定義都必須被配置在一個 node 上。
– 有關係的一對 design subsystems 必須被配置在同一個 node 上或是有
link 相連的兩個 node 上。
3.2 跨階段產物間相關性之分析
3.2.1 from Requirement Capturing to Analysis
從 requirement capturing 階段進到 analysis 階段時，主要工作之一是藉
由每一個 use case 的 detail specification 來產生 analysis 相對應的
23
圖 0-4 Pay Invoice use case—basic path 的 collaboration diagram
25
Buyer System
1. Display invoice list
2. Select an invoice
3. Check invoice to make sure goods were received
3.1 Get invoice
3.2 Get Order Confirmation of this invoice
4. Schedule invoice for
payment
5. Schedule payment
5.1 Check account
5.2 if (there is enough money in the buyer’s
account)
then generate a payment request
5.3 set the status of this invoice to
“scheduled”
5.4 send payment transaction to bank
5.5 set the status of this invoice to “paid”
圖 0-6 Pay Invoice use case—basic path 的 scenario 表格(標記名詞)
另外由圖 0-6 的 step3.2 可發現 invoice 的內容需有 order number，才能
檢查此貨物是否已送達，因此在表格旁加一欄來做註解如圖 0-7 所示，註解內
亦標示了重要名詞，對未來定義 entity class 的 attribute 有重要助益。
27
5. Schedule payment
5.1 Check account
5.2 if (there is enough money in the buyer’s account)
then generate a payment request
5.3 set the status of this invoice to “scheduled”
5.4 send payment transaction to bank
5.5 set the status of this invoice to “paid”
Payment request should
have seller’s account,
buyer’s account,
amount of money, and
scheduled date.
圖 0-7 Pay Invoice use case—basic path 的 scenario 表格(加入註解)
29
是 pay invoice 的 basic path 的 sequence diagram，sequence diagram 上共有
九個 design objects，這些 design objects 所屬的 design class 是為了要實
現 analysis class 的 responsibility 而產生，比較圖 0-9 與
圖 0-4 可發現，design class 的數量比 analysis class 的數量多，如多了
處理 invoice 的”Invoice Manager”與處理 order confirmation
的”OrderConfirmation Manager”，這兩個新增的 design class 都是屬於
container class 的類型。這種衍伸結果可知一個 analysis class 會在 design
階段由一個以上的 design classes 所實現，其中有一個 design class 會繼承原
先 analysis class 的名稱以及 responsibility，其他新產生的 design class
則各有其產生的原因，詳細說明如下。
31
Sequence diagram 中 design object 所屬的 design class 有部分可以追溯
回上階段的 analysis class，另一部分則是在本階段新增而無法追溯回上個階
段的，首先探討 design class 的產生來源，可先將 design class 分為下列三類：
1. primary design class：可直接 trace 回 analysis class 的 design class
稱為 primary design class。每個 analysis class 都會在 design 階段產生一
個 primary design class，這個 primary design class 必須負責實現 analysis
class 的 attribute 與 responsibility，例如圖 0-9 中的 Payment Requirement
UI、Order Handler 等。Primary design class 的名稱必須與其所追溯回的
analysis class 名稱相同。
2. 輔助 primary design class 的 design class：由於 primary design class
之 responsibility 所採用的 algorithm 過於複雜或是不同 data type 之間的轉
換等原因而產生輔助性質的 design class。
3. 採用既有的 middleware 或 system-software 時，為了將其中的資料型態
轉換為本系統使用的資料型態，或是為了系統可攜性(portability)而加入的
adaptor classes：這些 design class 是來自於轉換或協調 middleware 或
system-software subsystem 與發展中的系統之差異，或是為了提高系統可攜性
與相容性、降低對於系統外部 underlying infrastructure 的依存度而產生。
在 analysis 階段有三種類型的 analysis class，分別是 boundary class、
control class、與 entity class，以下將分別敘述在 design 階段實現三種不
同類型 analysis class 所產生的輔助性 design class：
1. Control class：具有以下兩種輔助性質的 design class。
(1)為了輔助 primary design class 完成 operation 所產生的 design class。
Primary design class 中有些較複雜的 responsibilities，將分解為多個
design classes 以降低單一 class 的複雜度，此 responsibility 需要借助其他
新增 design class 的 operation 來完成。
例如某個 control class 具有將一篇文章中某些特定字元出現次數編碼為
Huffman code 的 responsibility，此 responsibility 必須同時考量計算的效能
與相關演算法的使用，若直接將這個複雜的功能放進原本的 primary design
class，容易造成實作與維護時的複雜度；為了減少 class 的複雜度，使用者可
能會新增一個負責做 Huffman coding 處理的 design class，並藉由 primary
design class 呼叫此新增的 design class 所提供的 operation 來完成這個複雜
的 responsibility。
33
因為 entity class 或 container class 的 attribute 可能是較複雜的資料
結構，使用者所使用的程式語言本身並不支援, 所以使用者必須新建立 design
class 來實現此 attribute type。
同樣重覆上個例子，訂單資料的 entity class 其資料欄位除了單純的訂單
編號、客戶姓名、送貨地址等字串類型的欄位資料外，也可能會有表列式(list)
的資料結構，如訂貨明細等，這些資料結構可能不是所採用的程式語言原本就有
提供的資料結構，必須產生新的 design class 來負責完成這個表列式的
attribute type。
3. Boundary class：具有以下三種輔助性質的 design class。
(1)提高系統對不同 components 相容性的 design class。
一個 boundary class 所提供的 service 可能在 design 階段被分割成許多
components，每個 component 可能對應到實際硬體設備或軟體元件。為了方便系
統維護與升級，降低對這些 component 的依存性，會產生新的 design classes。
比方說 analysis 階段的 SysOutput boundary class 可能會在 design 階段
形成 printer 與 monitor 兩個 components，以及一個 design class 負責 driver
的更新與維護。
(2)為了實現 attribute type 的 design class。
提供 service 的 design class 可能含有非程式語言支援的 attribute type
或是 data structure, 使用者必須新建立 design class 來實現此 attribute
type。
比方說有一個負責讀入晶片卡的 boundary class，因為該 class 要讀取的
資料可能是一個類型為字串欄位的集合的個人資料，而這種 attribute type 並
不是使用者所採用的程式語言所支援的類型，所以使用者必須產生一個新的
design class 來負責實現這個字串集合的 attribute type。
(3)為了輔助 primary design class 的 operation 所產生的 design class。
Primary design class 中有些較複雜的 responsibilities，可能分解為多
個輸出入形式以對應不同的 actor、不同的輸出方式、或複雜資料的處理，
classes 為降低單一 class 的複雜度，會透過呼叫其他新增 design class 的
operation 來完成。
延用上一個例子，讀取晶片卡資料的 boundary class 其中有一個
responsibility 是讀入晶片卡上的個人資料，因為讀入資料的 responsibility
35
歸納如下：
Sequence diagram 與 collaboration diagram 同為 UML 語言內所規範的
interaction diagram，collaboration diagram 著重在描述 class 之間的組織
與互動關係，sequence diagram 上的 messages 不再如 collaboration diagram
一樣是 class的 responsibility，而是所要呼叫的operation，但這個operation
卻可以追溯到 analysis 階段 collaboration diagram 內的 responsibility，這
些相關性有：
1. 兩個原本在 analysis 階段的 collaboration diagram 內有 link 相連的
analysis class，會在 design 階段形成兩個對應的 class group 內之 design
class的link。圖 0-10是擷取自Pay invoice在analysis階段的collaboration
diagram，從 boundary class “Payment Request UI”會呼叫 entity class
“Invoice”的 responsibility “Browse”，這個 responsibility 是用作查看
系統內的 invoice 資料；
圖 0-10 Pay Invoice use case—basic path 的 collaboration diagram(部分)
而圖 0-11 是擷取自該 scenario 在 design 階段的 sequence diagram，圖中
的 Payment Request UI 屬一個 class group，Invoice Manager 與 Invoice 則是
屬於另一個 class group，原先在上個階段 boundary class “Payment Request
UI”與 entity class “Invoice”間的 link 會在本階段由 Payment Request UI
與 Invoice Manager 間的 link 所繼承。
37
2. 輔助 primary design class 的 design class，這些 design class
必須是因為輔助 primary design class 而產生的 design class。
3. Depend on middleware 或是 system software 的 design class 與輔
助它的 design class。
II. Class diagram
Design 階段的 class diagram 由 design class 與其間的 relationships 所
組成，同樣的此階段的 class diagram 也可以參考 sequence diagram 及上階段
的 analysis class diagram 來建立 relationships，歸納此兩階段間 class
diagram 的相關性如下：
Analysis 階段所產生之 class diagram 的 relationship 如何傳遞到 design
階段的 design class diagram 呢？有了 class group 的劃分，就可以將原本
analysis class 間的關係轉成 class group 間的關係，也就是這兩個相對應的
class group 內必須有至少兩個 analysis class 有 link 相連。
比方說 class group A (trace back)-> analysis class A，
class group B (trace back)-> analysis class B，
則 analysis class A 與 B 之間的關係由 class group A 與 group B 裡面的
design class所繼承，即group A中若無design class與group B的design class
有關係，則會發生不一致，將產生 inconsistency message 提醒使用者。
上述分析，已將 requirement capturing 階段到 design 階段各階段的產物
分析出跨階段各個產物間的相關性、一致性、追溯性與完整性，下一章將依照此
章節所提出的各產物特性來設計輔助軟體開發流程的系統。
39
依據此策略，本系統所設計的功能機制可分為下列三類：
1.流程進行輔助機制：在使用者進行設計而畫 UML 圖形時，適時提供已有元
素供使用者選用，以避免錯誤的發生，如提供使用者 responsibility 的清單，
讓使用者從中挑選合適的 responsibility。
2.同階段性 UML 圖形一致性檢查機制：當使用者完成某一個流程階段或完成
一個圖形繪製，系統自動檢查此流程產生的產物與其他已產生的產物間是否有不
一致的情形，例如使用者畫完一個 use case 中的 collaboration diagram 時，
檢查該圖中的 class 是否在已有的 analysis class 清單中。
3.階段產物的完整性檢查：當使用者完全完成 analysis 或 design 整個階段
時，系統所進行的整體檢查，確定使用者確實完成這個階段所必須產生的產物，
產物若不齊全就不允許使用者進入下一個流程，例如幫助使用者在 analysis 階
段完成時檢查是否每個 use case 裡的 scenario 都已經有建立相對應的
collaboration diagram。
4.2 需求階段(Requirement Capturing)
Requirement capturing 階段是 USDP 軟體開發工作流程中的第一個階段，
本階段使用者必須以 use case diagram 來表示系統所定義的 use cases 與
actors，同時註明各個 use case 的 specification。在 requirement capturing
階段系統提供了使用者建立 use-case model，並依照上一章提到的標記方法標
記各 scenario 裡的關鍵名詞，這些關鍵名詞將輔助使用者進行 analysis 階段的
流程。
Requirement capturing 階段的流程共分為五個項目，分別是 find actors
and use cases、prioritize use cases、detail a use case、prototype user
interface 與 structure the use-case model，各流程詳細的輔助功能茲列述如
下：
1. Find actors and use cases
系統提供使用者藉由繪製use case diagram來表示其所定義的actor與 use
cases，使用者在 use diagram 中加入並同時定義 use case 與 actor 的名稱，以
及 use case 與 actor 間的關係。繪製 use case diagram 的功能是由 ArgoUML
所提供。
2. Prioritize use cases
給予每個 use case 一個優先度欄位，使用者於本流程可設定各 use case
的優先度，系統會以優先度排序各個 use case，同時提醒使用者要在開發流程
41
1.3 定義 Common special requirement
使用者應定義一些共通的 special requirement，系統將會產生文字表格供
使用者填寫。
2. Analyze a Use Case
2.1 定義 analysis classes
使用者定義一個 use case scenario 之 analysis class 的名稱時會參考此
use case scenario 中使用者已標記的重要名詞，這些名詞將是 entity class
名稱的candidate。系統將提供scenario上的關鍵名詞讓使用者選擇當作entity
class name，若該名詞已被定義為entity class name，也將自動標明，當scenario
內的名詞被用來當 entity class 名稱，將特別標記。
因為 boundary class 的名稱一般不會出現在 scenario 裡，因此無法提供
boundary class 名稱的協助，但能提供此 scenario 中共有幾次的 I/O 動作予使
用者參考。而 control class 是使用者依系統要執行的動作之複雜度而決定是否
由 control class 來負責，並由使用者依工作性質來命名，因此無法協助 control
class 的命名。
2.2 描述 analysis object 間的 interaction
使用者需建立 collaboration diagram 來描述該 scenario 內的 analysis
class 如何互動。
系統將提供使用者已定義的 analysis class 供使用者選擇，scenario 敘述
句中名詞若為 analysis class 的名稱，將作標記以提醒使用者。當使用者加入
boundary class 時，將提供使用者在 scenario 上出現的 actor 名稱供使用者建
立 actor 與該 boundary class 之關係，並提供 I/O 相關的 scenario 敘述句供使
用者建立 link 及制定 boundary class 之 responsibility。
當使用者加入由 control class 或 boundary class 與 entity class 間的
link 時，系統將提供 scenario 有該 entity class 的敘述句供使用者建立 entity
class 之 responsibility 之用。當 boundary class 或 control class 與另一
control class 間建立 link 時，則提供其他 scenario 中仍未被使用到的敘述句
供使用者建立該 control class 之 responsibility 之用。
當使用者繪製完一個 scenario 的 collaboration diagram 時，系統會提供
以下的檢查：
(1) 檢查 scenario 中是否有尚未被加入 collaboration diagram 內的
43
此階段的工作是將所有已定義的 analysis class 分配到適當 package 中，
系統將會提供下列輔助：
(1) 列出所有的 analysis class 與該 analysis class 所參與的
collaboration diagram 及 scenario 名稱。
(2) 當 analysis class 被配置進某一 package 中時，系統提供與該
analysis class 有 link 的 analysis class 及出現的 collaboration diagram
名稱，供使用者選擇分配 package 之參考，這些相互間有 link 的 analysis class
會有相當大的機會被分配到同一個 package。
(3) 當全部的 analysis class 都配置進 package 後，系統自動列出每個
package 間的 analysis class 跨 package 呼叫的次數，以提醒使用者將次數高
的 analysis class 重新分配所屬的 package。
在完成上述四個 analysis 階段的核心活動後，系統會進行整體檢查以保證
能無誤的進入下一個階段，本階段的整體一致性檢查包括：
(1) 系統若在各 use case scenario 中發現有未被使用到的關鍵名詞，則必
須告知使用者檢查是否有未定義的 attribute 或 attribute type。
(2) 系統若發現在 collaboration diagram 中有 link 相連的 analysis
class 但相互間卻沒有 relationships 的關係相連，則提醒使用者有未定義的關
係。
(3) 系統會檢查是否每個在 collaboration diagram 中互相有溝通的
analysis class 其所屬的 package 之間是否也有關係存在。
4.4 設計階段(Design)
Design 階段的核心工作包括 architectural design、design a use case、
design a class 與 design a subsystem，各核心工作之輔助功能分述如下：
1. Architectural Design
1.1 定義系統的 node 與 network
ArgoUML 已有提供使用者建立 deployment diagram 之功能，包括每個 node
的名稱以及 node 間的溝通方式(如 internet、intranet 等)。
1.2 定義系統的 subsystems 以及 interface 並配置 deployment diagram
45
2.2 描述 use case 中各個 object 的互動
依據指定的 use case scenario，系統將首先列出其 collaboration diagram
及參與其中的 class 之相關 class group，並依 collaboration diagram 之
analysis class 互動順序，由左而右列出其 typical object 供使用者繪製
sequence diagram，使用者對每個 object 檢查是否需插入 class group 內成員
之 typical object；當使用者選擇其中的 design class 時，列出該 class group
的 analysis class 在上個階段呼叫其他 analysis class 的 responsibility 清
單。使用者必須選擇其中的 responsibility，然後建立實現該 responsibility
的(一連串)messages。當加入一個 message 於 sequence diagram 時，被呼叫的
design class 需定義其對應 operation 名稱。
當結束此 sequence diagram 繪製時，將執行下列一致性檢查：
(1) 檢查 sequence diagram 中的 message 是否都是 operation。
(2) 檢查 analysis 階段的 collaboration diagram 中的
responsibilities 是否都被實現了。
(3) 檢查與每一個 responsibility 對應的一連串 message 中，是否(只)
有一個跨 class group 的 message(即 primary operation)。
(4) 檢查與每一個 responsibility 對應的一連串 message 裡是否第一個
參與的 design class 與最後一個被呼叫的 design class 分別是在 analysis 階
段 caller 與 callee 相對應的 class group 中。
(5) 檢查與每一個 responsibility 對應的一連串 message 裡所有參與的
design class 都必須是屬於 caller 或 callee 的 class group，若不是則必須是
depend on middleware 或 system-software 的 design class，不滿足此條件則
告知使用者有不一致的情形發生。
2.3 定義 use case 中參與的 subsystems 與 interfaces
與 2.4 描述 use case 中各個 subsystem 的互動
由使用者自行繪製 subsystem 的 sequence diagram，系統不提供支援。
2.5 註記 implementation 階段的 requirements
提供文字表格讓使用者輸入 implementation 階段的 nonfunctional
requirement。
3. Design a Class
3.1 Outlining the Design Class
47
nonfunctional requirement 給使用者參考。同時也列出該 design class 所屬
analysis class 的 special requirement 供使用者進行定義之參考。
4. Design a Subsystem
4.1 維護 subsystems 間的 dependencies
在 architectural design 所有的 subsystem 都已被定義出來了，同時使用
者也已經建立了其間的 dependency，因此系統應自動提供使用者檢驗 subsystem
內的 design class 是否與該 subsystem 的 dependency 關係一致。
4.2 維護 subsystems 所提供的 interface
有被 design class 參考到的 subsystem 系統將檢查是否已提供 interface。
系統也會檢查每個 interface 是否都有對應的提供者。
4.3 維護 subsystem 中的 design class
同時系統也會提供每個 subsystem 內 design class 參考到其他 subsystem
(即 external reference)的數量給使用者參考，可以讓使用者選擇是否要重新
分配 subsystem 的 design class。
在完成上述四個 design 階段的核心工作後，系統會進行整體檢查以保證能
無誤的進入下一個階段，本階段的整體一致性檢查包括：
(1) 檢查是否每個 package 都已經產生對應的 subsystem 了，而如果有未完
成的 package 則必須提醒使用者。
(2) 檢查是否有被其他 subsystem 或 design class 使用到的 subsystem 其
interface 是否都被定義了，若有未定義的 interface 也必須提醒使用者
(3) 對於定義 design class，系統會檢查下列事項是否已經完成了：
 檢查是否每個 analysis class 都有建立相對應的 primary design
class。
 檢查是否每個 design class 內的 attribute type 都已經被實現了。
 檢查是否每個 design class 都有其出現的原因，若不是 primary
design class 或是為了輔助 primary design class 所產生的 design class，就
必須是 depend on middleware 或是 system-software subsystem 的 design
class，如果都不是則代表不一致。
49
處理 UML model 的 classes，GEF 負責將 UML diagram 的模型視覺化並表現在 UI
上，而 ArgoUML 則是將這兩部分的功能連結，並加入應用邏輯。
ArgoUML 採用 Model-View-Controller(MVC)的設計架構，MVC 架構將 UI 與系統
內部處理的資料分開，同一個 model 會有一至多個與之相連的 views，當 model
內容需做更改，將透過 controller 呼叫 model 內的 method 來改變其資料，同時
model 也通知所有 views 改變其狀態內容。
圖 0-13 ArgoUML architecture[14]
圖 0-14 Model-View-Controller Pattern[14]
圖 0-15為ArgoUML的framework，四層的架構(由下而上為Layer 0至 Layer 3)
讓開發人員可以在上兩層(Application-specific layer 與
51
 Layer 0
由負責紀錄的 Logging subsystem、負責地區性字串轉換的
Internationalization subsystem、及負責提供 java runtime 支援的 JRE(with
utils) subsystem，Layer 0 的這三個 subsystem 包含了其他三層所會使用到的
一般性功能，自 Layer 1 到 Layer 3 都會 depend on layer 0。
圖 0-17 Layer 0 packages[15]
 Layer 1
Argouml subsystem 架構中的最底層，Layer 1 除了 depend on Layer 0 之外
並沒有其他參考的 subsystem。其中包含了 Model、Todo Items、GUI Framework、
Help System 四個 subsystem，其中 Model subsystem 提供 UML 各種圖形的資料
結構，使用上一節提到的 NSUML 來實作 UML model，並提供較上層的 subsystem
使用。
圖 0-18 Dependencies between Layer 1 and Layer 0[15]
 Layer 2
包含以下六個 subsystems：
1. Diagrams：負責將 model 內的 diagram 以圖形化的方式表現出來，並
包含 diagram 上的工具列。
53
圖 0-20 Dependencies between Layer 3 and Layer 2[15]
圖 0-21 Dependencies between Layer 3 and Layer 1
5.1.3 ArgoUML 介面設計
圖 0-22 為 ArgoUML 開發工具在執行時的主要畫面，畫面一共分為下列四個部
分：
1. Explorer：在畫面的左上方，顯示目前的 project(或 model)的開發狀態
與產物，是一階層性的樹狀架構。
2. Editor：在畫面的右上方，由 Diagram 的編輯區域與 toolbar 所組成，
3. ToDos：在畫面的左下方，依優先度的順序來排列使用者自行建立的工作
清單，並以階層的方式表示。
55
圖 0-23 ArgoUML-multilevel structure
5.2 一致性檢查方法在 ArgoUML 上之設計架構
本研究將提出的產物一致性檢查方法(稱為 ArgoUSDP module)建置在
ArgoUML 上，使用 plugin 的方式來延伸 ArgoUML 的功能，使其支援軟體開發流
程上的產物檢查方法。藉由實作 ArogUML 所提供的延伸功能介面”
org.argouml.application.api.Pluggable”讓 Layer 2 的 Module Loader
subsystem 在程式啟動時將 ArgoUSDP 載入執行環境中。
ArgoUSDP 的起始模組是位在 ArgoUML 架構中的 Layer 3 中，並有少部分功能更
動到 ArgoUML 的原始碼，圖 0-24 是 ArgoUSDP 與 ArgoUML 主程式的 framework
關係圖。
Multi-level structure
57
layer，其中除了 Main module 在 Layer 3 外，其餘都位於 Layer 2 中。而圖 0-27
則說明 ArgoUSDP 與其他 subsystem 間的依存關係。
圖 0-26 ArgoUSDP framework
圖 0-27 ArgoUSDP 與其他 subsystem 間之關係
5.3 系統介面
ArgoUSDP 的輔助功能分為 Requirement Capturing 階段、Requirement
Capturing 至 Analyis、Analyis 至 Design 部分，第一部分的核心產物為 use case
diagram 與 use case scenario 的 specification，第二部分的核心產物為
collaboration diagram，第三部分的核心產物則是 sequence diagram。由於
ArgoUML 為持續在開發中的計畫，有部分的產物目前並沒有實作於 ArgoUML 中而
僅被規劃為未來之開發重點，其中缺少 sequence diagram 的支援使得本研究的
檢查方法無法將 Analysis 至 Design 階段的部分建置於 ArgoUML 中，而其他部分
的系統介面節錄如下。
5.3.1 Requirement Capturing 階段
使用者必須先定義系統的 use case model 並以 use case diagram 表示之，圖
59
圖 0-29 選擇 View Scenario
圖 0-30 是 scenario 的編輯視窗，視窗共分為三個部分，上方為按鈕列，
使用者可選擇新增 actor 欄位或是將此 scenario 存為 html 格式的檔案；中間部
分為表格編輯視窗，使用者可點選表格中的欄位以加入 responsibility；右邊
是關鍵名詞的列表，會列出該 scenario 中被使用者標示為關鍵名詞的字。同時
使用者可以點選欄位標頭以變更 actor 的名稱(如圖 0-31)。
使用者點選表格中的任一欄位後會開啟更詳細的scenario動作編輯視窗(如圖
0-32)，在該視窗中有較大的文字編輯空間，可以編輯較複雜格式的動作如
branch 或 loop。
61
圖 0-32 scenario 動作編輯視窗
圖 0-33 的動作編輯視窗中使用者選擇了其中的一段文字(invoice)，並點選選
單上的 mark 以標記為關鍵名詞，同時該段文字也會以粗體字型表示。
圖 0-33 標記關鍵名詞
63
在這個流程中會於 analysis phase 的分支下建立該 use case 的
collaboration diagram，本小節擷取部分輔助使用者產生 collaboration
diagram 的功能如下。
首先必須先定義參與該 scenario 的 analysis class(如圖 0-36)，同時在
圖 0-37 使用者透過 analysis class 的 property panel 選擇該 analysis class
的類型，本階段中使用者僅能選擇 entity、control、與 boundary 三種
stereotype。
圖 0-36 定義 analysis class
圖 0-37 選擇 analysis class 的類型
65
圖 0-39 Responsibility checklist
圖 0-40 Analysis class 的 responsibility
67
第六章 「知識分類機制」之背景知識與相關研究
軟體產業是一高度知識密集的產業，軟體的發展更是一項不斷創新知識的過
程，因此，做好知識的管理，將能加速知識傳遞與學習的過程，以便縮短軟體開
發的時程，提高軟體品質，進而降低整體開發成本與加快產品上市的時間。而軟
體知識分類方法的好壞，將決定軟體知識管理的效率，尤其軟體知識發展迅速，
大量的知識必須透過有效率的知識分類方法加以管理方能達到軟體知識管理的
目標。
本章首先在 6.1 節介紹軟體知識管理的基本概念及其流程，6.2 節將重點放
在軟體知識管理中的分類方法，並介紹目前最常用的知識分類方法。2.3 節則分
析現有知識分類方法運用在軟體知識管理上的問題。
6.1 軟體知識管理
軟體的發展是一項知識不斷創新的過程，每天都有新的問題被解決、新的知
識被創造出來，使得軟體的知識呈現多樣化且快速的成長。Ioana Rus 等人曾說
明知識管理對於軟體工程的重要性包括[27]：
 記錄與分享流程（Process）以及產物（Product）知識：軟體發展的流
程與產物會隨目標與內容的不同而有所差異，單一的發展模式無法滿足所有專案
的需要，因此發展者須不斷的藉由專案的過程來累積知識與經驗。然而有些發展
團隊卻常忽略這些工作經驗，以至於未能有效運用之前專案的成果而造成許多時
間的浪費。而知識管理強調的知識捕捉（Capture）與分享正是解決的良方。
 了解專門領域知識（Domain Knowledge）：軟體發展過程常需要瞭解問
題領域的相關知識，搜尋與學習這些知識往往要花上許多時間，但這些知識會散
在不同的成員身上，其效用有限，知識管理技術可幫助組織將這些專門知識
（Expertise）予以確認（Identify）、包裹（Package），進而供團隊共享，以提
升整體能力。
 獲得新技術、資訊：軟體是一個不容易掌握且發展快速的領域，科技不
斷地推陳出新，也許使軟體的能力更加強大了，但也是發展人員的夢魘，除了穩
定性、相容性外，也讓評估變的更加困難，需要花時間去適應與學習。知識管理
旨在促進組織分享的文化，透過溝通與實踐來縮短共同學習的曲線。
 分享所在環境的知識（Local Policy）：成功的軟體組織應該擁有許多
軟體經驗，而發展團隊的程式風格或一些慣例通常存在較有經驗的發展者腦中，
且常透過較非正式的溝通來傳承給新進人員。知識管理除了協助溝通，也試著去
69
圖 6 - 2 軟體知識管理模型
由上圖可知，軟體知識管理的主要活動包括：
 創造(Create)：創造新的、有價值的知識是知識管理主要的目的之一，
但並非所有創新都是無中生有，許多知識是透過合併或更改舊有的知識，進而賦
予其新的意義與價值。因此在創造的過程中首要的步驟是確認(Identify)欲得到
的知識是什麼，並具體詳細地加以指明(Specify)。
 搜尋(Search)：在目前知識爆炸的時代，要精確的從數以萬計的資料中
找出所要的知識並不容易，因此搜尋的機制也是非常重要的一環。關於搜尋的研
究與作法很多，但主要的想法是根據想要找的條件，選擇(Choose)適合的分類，
再搜尋現有的知識庫，並從搜尋的結果中挑選出(Select)需要的部分。
 調適(Adapt)：從前一步驟搜尋得到的知識通常與發展者實際所想要的
知識，不管在內容或者形式上都可能會有些落差，因此在不破壞原來知識的情況
下，先將之取出複製(Copy)一份，再經過適當的修改(Modify)或合併以符合實際
的情境所需。
 使用(Use)：知識的使用可說是知識循環中最重要的部分，各項步驟的
最終目的就是希望讓知識能被有效的應用(Apply)到實際狀況中，進而發揮知識
的價值。
 收集(Collect)：擷取(Acquire)發展過程中可再應用的產物、相關文
件、經驗等知識，整理成特定的適當形式(Formalize)，抽出(Extract)並儲存至
知識庫中。
 分類(Classify)：組織(Organize)知識，放入適當的分類與索引
(Index)，並合併(Integrate)其中相似的部分。同時在分類過程中也可能需要動
態適時的進行知識結構的調整。
71
Taxonomy 的基本原理即樹狀分類架構，將知識先分成數個大領域，各個大
領域再往下細分，每一個分類都可以繼續細分，例如軟體知識分類範例便可如圖
6 - 3 所示：
Domain
Subject
(Layer-1)
Type
Database GraphicO/SAlgorithm……
Subject
(Layer-2) VBC/C++ …..
JavaJ SQLHTML Perl
DB Mgmt SQL
Info. Storage & Retrieval
…..
Subject
(Layer-3) JavaBean RMIApplet Swingi…..
E-Book ArticleTutorialt i l …..
Conceptual/S
olution-Based
API Q&A
…..
Programming
Language
i
Computer Sciencet i
Conceptual-basedt l- Solution-basel i -
圖 6 - 3 軟體知識分類範例
6.2.2 Faceted Classification
Faceted Classification 係由印度的圖書館員 S. R. Ranganathan 於 1930
年代發明的，這是利用清楚定義（clearly defined）、完全互斥（mutually
exclusive）及完整窮舉（collectively exhaustive）的知識主題、特性來進行
分類[24]，其特色是讓知識分類具備更高的彈性及自由度，不必侷限於之前的分
類架構，隨時都可以新增一個 Facet 分類。Facet 可以是兩種型態，第一種即前
一小節所述的 Taxonomy 樹狀結構，第二種則是用表示連續數字的格式，如價格、
日期等等。
Faceted Classification 自 1960 年代以來被廣泛地使用，由於其分類具有
高度彈性，故被運用在各個不同領域。例如原本採用 Taxonomy 架構的杜威十進
分類法，也在其第 21 版加入了 Faceted Classification 的概念，除了原有的領
域分類外，還加入了如作者種族、書本語言、國家等不同面向的分類。此方法也
被運用到如商業管理（London Classification of Business Studies）[33]與
建築工程（Unified Classification for the Construction Industry）[34]
等不同領域。運用在軟體知識管理上，也有如 KM-Connection[35]等系統採用了
Faceted Classification 做為其分類架構，此系統採用的面向包括了產品、應
73
圖 6 - 6 Faceted Classification 範例-3
產地部份便會顯示在美國之下的產地，如加洲、華盛頓等，使用者可再以價
格做選擇，例如選擇 Top shelf 的酒類，可得如圖 6 - 7 之結果：
圖 6 - 7 Faceted Classification 範例結果
由於這些條件下只有四種酒類，故系統可直接列出其結果。由上例可知，此
方法的好處便是使用者的搜尋過程可以隨時利用不同面向縮小範圍，故可用其較
熟悉的面向快速找到符合的知識。
Faceted Classification 也有標準交換格式，稱為 XFML (the eXchangable
Faceted Metadata Language)[37]，此格式採用 XML 對 Facet 進行描述，讓不同
的知識庫可以籍此進行 Facet 的交換。
6.2.3 Case-based Reasoning
Case-based Reasoning（以下簡稱 CBR）是由 Roger Schank 所提出[38]，
一開始是為了解決 AI 的問題，他認為知識的儲存、經驗及學習是不可分隔的，
進而提出了 theory of dynamic memory。而 CBR 的特性即是利用過往的經驗來
解決新的問題，它試圖從過往的個案（Case）中找尋與目前問題最相似者，將其
解法進行適當的修改後來提供解答，並透過解答所達成的效果來進行學習，籍以
豐富其知識庫。其中還有一分支稱為 Analogy-based Reasoning[39]，試圖利用
跨領域的經驗來解決問題。CBR 的模型如圖 6 - 8 所示：
75
斷（Episode），在其下有不同的索引與對應的值，這些值又可以連結到其他的片
斷或直接連結到案例中，其示意圖如圖 6 - 10：
圖 6 - 10 Dynamic memory model 示意圖
Category & exemplar model 則是自案例中找出特性（Feature），並將一些
特性定義為類別（Category），這些類別可再進一步分析而成為模範（Exemplar），
同一個類別可以產生多種模範，而案例便可依此進行歸類。當新的案例出現時，
系統便對此案例分析後找出合適的模範，並將其下案例的解答分析整理後提出可
能的答案。其示意圖如圖 6 - 11：
圖 6 - 11 Category & exemplar model 示圖
過去已有些許研究者，利用 CBR 進行知識管理[41]，然而由於 CBR 必須仰賴
規格十分嚴謹的知識表示法，而且其複雜的模型必須完全相同才能夠讓不同的
CBR 系統溝通，因此一般都是運用在特定的領域解決特定的問題，例如處方、餐
廳菜單、病情診斷等，不適合用在五花八門的一般知識庫中。
77
OntoWrapper 可以從結構化的知識中淬取出其 Ontology，這些 Ontology 儲存在
知識庫中，採用 OntoShare 讓使用者進行搜尋，改善傳統關鍵字搜尋效率不彰的
問題。
On-To-Knowledge 對於文件建構了詳細的 Ontology 描述，如標題（title）、
摘要（summary）、作者、相關概念、附件等，而作者也描述其名字、e-mail 等
資訊，而相關概念也可採用分類的方式來描述，其示意圖如圖 6 - 13 所示：
圖 6 - 13 On-To-Knowledge Ontology 架構圖
由上圖的例子，可看出 Ontology 的基本概念是定義知識的特性以及特性間
的關係，甚至可利用邏輯化的方式對知識進行描述，故使用者在搜尋知識時可明
確地描述知識特性及概念，提昇知識搜尋的效率。
6.3 現有知識分類方法的問題
Taxonomy
Taxonomy 是最廣為引用的樹狀分類法，但從知識搜尋的觀點來看，Taxonomy
下的知識缺乏關係與連結，也沒辦法進行知識的分析。由於樹狀分類過於簡單，
因此也沒辦法依使用者需求給予適當的知識。雖然有非常多的知識庫都採用
Taxonomy 來做分類，但彼此之間由於缺乏共通的分類準則，因此沒有辦法進行
跨知識庫的整合。此外，Taxonomy 的層狀架構使其分類上缺乏彈性，因為知識
並非只有單一面向，而 Taxonomy 卻只能依特定方向進行分類。由於只能單純的
分類，故當知識量累積愈來愈多時，同類型知識也將非常可觀，使用者沒辦法從
79
但卻沒辦法讓使用者自由取得相關的知識。此外，不同領域的知識其特性並不相
同，因此用以描述的Ontology必然無法通用，而對每個領域都要發展其Ontology
也非常耗時耗力，這對領域廣泛的軟體知識而言尤其不合適；其次，Ontology
雖然能提供知識意義的描述，但其實對相關領域不熟的使用者而言，他對知識的
概念不足，因此在使用上反而覺得不便。誠如上述，使用者運用知識庫可概分為
三類，故對不同需求的使用者提供不同的搜尋才能真正對其產生幫助。
前了上述分類法各自的問題外，軟體知識管理一直都無法做到「知識處理自
動化」及「跨知識庫整合」的要求，知識處理若能自動化，將能夠提昇軟體知識
管理的效率。而知識庫之間的整合，將使知識庫的知識量大幅提昇，也能大幅縮
短使用者在各個知識庫之間找尋知識所耗費的時間。
由上可知，目前的知識管理搜尋與分類方法都有其不足之處，當知識累積數
量增多時，知識庫的效率及正確性便會降低，浪費使用者寶貴的時間。因此我們
需要更有效率的知識分類方法來改善此問題。
81
automated text categorization 則是他要處理的問題，格式是名詞+in+名詞，
故在這裡第一個名詞是解法，第二個名詞是問題。但另一篇 David F. Bacon
的”Compiler transformations for high-performance computing”[48]，看
起來跟前一篇標題格式頗為類似，但其實這篇論文的內容是在處理
multiprocessors 以及 superscalar processors 機器上的 compiler
optimization 問題，利用 compiler transformation 解決，而採用了 dependence
analysis 以及 locality 等技術來解決，這時前一個名詞變成解法，第二個名詞
則是問題所在領域。這兩篇標題型式如此類似的論文，其代表的意義卻相差非常
多。此外論文的標題由於沒有規定的格式，因此各種型式的標題都可能出現，舉
例而言，Weiyi Meng的”Building efficient and effective metasearch
engines”[49]，從標題上只能看出這篇論文要建構有效率的 metasearch
engine，看不出其提出的解法，且格式是採用動詞+名詞的方式，跟前兩篇不同；
又如 Jin Jing的”Client-server computing in mobile environments”[50]，
標題看起來跟第一篇類似，都是以名詞+in+名詞做為標題，但在這裡第一個名詞
（Client-server computing）並非解法，而是這篇論文處理的問題，其他尚有
更難判斷的例子，如 Steffen Heinz的”Burst tries: a fast, efficient data
structure for string keys”[51]，這篇的格式是名詞+：+形容詞+名詞+for+
名詞，但其實讀了內容後會發現這篇論文在講的是 text database 中的 string
data structure 問題，而提出了 Burst tries 做為解法。又如 Chang H. and
Iyengar S. S 的”Efficient algorithms to globally balance a binary search
tree”[52]，格式是名詞+to+動詞+名詞，而這些名詞卻不能完全代表這論文的
意義，讀完論文後會發現這篇論文處理的是 Binary search tree 中的 improve
worst case 問題，採用了 sequential balancing & parallel balancing 的解
法。
由上述的例子，可發現論文的標題有非常多不同的語法，由於自然語言並非
電腦可處理的正規語言，同一種語法可能代表不同的意義，因此有許多地方都是
含糊不清（ambiguous）的；且許多論文的標題都沒有真正提到他處理的問題以
及採用的解法，因此對使用者而言，找尋論文必須閱讀內容後才能判斷是否符合
所需，顯得非常沒有效率。
為改善此問題，一般技術論文都會定義「關鍵字」來增加對論文意義的描述，
然而一般關鍵字都較零散且缺乏規則，且關鍵字之間沒有具體的關聯性，如此對
知識的使用者幫助相當有限。最著名的 IEEE 期刊也只規定關鍵字定義的基本原
則，其中列出了一個 Keyword List 供作者從中選擇，並建議作者採用五到八個
關鍵字做為索引，若有新的關鍵字則提供給 IEEE 參考等等。即使如此關鍵字仍
是零散無規則的，如前所述，使用者在輸入關鍵字時其目的可能是不同的，然而
使用者卻沒有辦法對關鍵字加以定義，因此只能輸入他認為較重要的幾個字，這
往往會找出一些完全不符合需求的知識。以下舉上面幾篇論文為例：
83
論文若都將其提出的解法做為關鍵字，則使用者能夠快速地進行同問題間解法的
比較。例如某個做法是利用 Greedy，而另一個是利用 Dynamic Programming，這
就能夠讓使用者對此知識有基本概念，也能有個簡單比較的基礎。
(4) 技術（Technique）：一個特定解法可能是運用了某些技術，而這個
部份也是很有價值的。使用者不明白解法時，可以籍其所運用的技術有個概括性
的了解，例如前述的 dependence analysis、locality、splay trees 等。
因此，論文關鍵字可以圖 7 - 1 表示：
圖 7 - 1 論文關鍵字示意圖
這樣的分類是依據技術論文的「問題導向」本質而定的。由於技術論文的本
質即是根據特定的「問題」提出「解決方案」，因此只要能夠描述「問題」與「解
決方案」，便能夠描述一篇技術論文的內容。而問題可分成「領域」與「問題」，
解決方案則可分成「解法」與「使用技術」，現行的關鍵字由於沒有定義，因此
經常發生許多論文的關鍵字與其內容關聯性不高的問題；事實上，基於技術論文
的「問題導向」本質，只要定義上述四類關鍵字，便能夠充份描述一篇論文在哪
個領域處理了哪個問題，提出了什麼樣的解法以及使用了什麼樣的技術，這對論
文的描述、索引、查詢而言已經足夠了。
一篇論文的問題與解法，用一兩個關鍵字來描述自然有其不足之處。例如對
圖學相關內容不熟悉的讀者而言，光看到travel salesman problem或是Steiner
tree problem 等關鍵字是無法聯想到實際的問題。或者對 binary search tree
不熟悉的讀者而言，看到某一論文使用了 Hibbard's algorithm 或是 Knuth's
Domain
Problem
Approach
Technique
Use
Use
Use
Technique Technique
85
圖 7 - 3 論文關鍵字表示法範例（text categorization）
David F. Bacon的”Compiler transformations for high-performance
computing”論文定義了相當多的關鍵字：compilation、dependence analysis、
locality、multiprocessors、optimization、parallelism、superscalar
processors 等，這些關鍵字中，parallelism、multiprocessors、superscalar
processors 是領域，compiler optimization 是問題，這篇論文的解法是
compiler transformation，採用了 dependence analysis、locality 等技術，
故其關鍵字可表示成圖 7 - 4：
圖 7 - 4 論文關鍵字表示法範例（complier optimization）
Jin Jing的”Client-server computing in mobile environments”論文
中定義了非常多的關鍵字，只要論文有提到的內容都定為關鍵字，包括：
application adaptation、cache invalidation、caching、client/server、data
dissemination、disconnected operation、mobile applications、mobile
client/server、mobile computing 等等，其實讀了這篇論文可發現主要是在說
明 mobile client/server 的問題，提到了三種解法：mobile-aware adaptation、
extended client/server model 以及 mobile data access 等，各自有其運用技
superscalar processors
Domain
compiler optimization
Problem
compiler transformation
Approach
dependence analysis
Technique
locality
Technique
multiprocessors
Domain
information retrieval
Domain
text categorization
Problem
machine learning
Approach
train-and-test
Technique
k-fold cross-validation
Technique
87
這也跟技術論文的問題一樣，零散且缺乏規則的關鍵字並沒有辦法有效率地做為
知識索引，且技術報告在這方面的問題更大，因為技術報告原本就是針對較細的
議題進行探討，故一般以其真正探討的主題做為關鍵字則通常過於侷限，讓使用
者找不到資料，但若採用較寬的領域做為關鍵字，則又會讓只想找該領域知識的
使用者讀取不符需要的知識，例如 S. L. Martins, M. G. C. Resende, C. C.
Ribeiro, and P. M. Pardalos的”A parallel hybrid GRASP for the Steiner
tree problem in graphs using a hybrid local search strategy”[53]這篇
技術報告，它是要處理 graph 中 Steiner tree problem，提出了一個 parallel
greedy randomized adaptive search procedure（GRASP）做為解決方案，但如
果僅以 Steiner tree problem、parallel greedy randomized adaptive search
procedure 做為關鍵字的話，則只有使用者完全了解他的問題，直接找尋
「Steiner tree problem」才可能找到這篇報告，但若加入 graph 做為其關鍵字，
則所有對「graph」有興趣的使用者都可能找到這一篇探討特定問題的技術報告，
這都是因為關鍵字的定義缺乏法則及關聯性所導致的問題。
由於技術報告也是「問題導向」，一篇技術報告的內容主要是在「領域」中
探討特定「問題」，運用一個「論點或技術」提出「解法」，故我們同樣可以將其
關鍵字分為四類，即「領域」、「問題」、「解法」、「論點或技術」，這跟我們對技
術論文關鍵字的分類是一樣的，而由於其「問題導向」的本質，這樣的分類也足
以對其內容進行簡單的描述。
7.1.3 書本知識本質
書本知識對軟體開發者而言也是非常重要的知識來源。由於書本知識通常是
一般性介紹，故書本知識的產生是在相關議題技術論文發表到一定程度之後才會
出現，並非最前瞻的知識，其探討的內容也不會像技術報告或技術論文那樣深
入，相反地是側重介紹及教學的功能，這對想要了解或學習特定主題的軟體工程
師而言特別有幫助，一般人對一個不熟悉的領域通常都是透過書本知識來學習
的。分析書本知識的特性將能夠幫助想要學習的軟體工程師快速找到所需的教
材。
以知識產生的目的來看，書本知識是以介紹及教學為主要目的。各個主題都
會有所謂的入門書籍，若此主題的知識較繁多，則可能會有進階書籍。無論是入
門書籍或進階書籍，書本知識都是偏向介紹性質的。也因此，書本知識不會針對
某個特定議題進行深入探討，相反地，書本知識往往是對議題進行概略的介紹，
讓讀者能夠對此議題有個初步的了解。跟技術論文、技術報告的專一性相反，一
本書裡可能會提到數十個議題，因此書本知識是以廣博為主，而技術論文則以深
入見長。
從技術書籍的架構來分析其本質。一本技術書籍的基本架構都包括有目錄
89
其說明過程中會以範例讓讀者易於理解。這種內容尤其容易出現在偏向實作面的
書本，例如程式語言、資料結構、演算法、資料庫等等。範例有助於讀者對議題
的理解，但其實並沒有真正增加書本介紹的知識範圍，因此這部份的內容不必加
入對書本知識的描述中。
經由上述的分析，可知書本知識亦可籍由良好定義的關鍵字加以描述，這個
關鍵字可分為「主題」、「議題」、「解法」三類：
(1) 主題（Subject）：主題即是一本書所探討的主要內容，通常會是書名。
主題可以籍由一良好的分類架構將軟體技術知識的主題分類，使其定義標準化。
(2) 議題（Topic）：一本書的主題下會包含幾個主要的議題。這些議題下可
能又可細分為子議題，由於這些子議題的內容組成主要議題，故亦可看成主要議
題包含數個子議題。書本知識的議題間可能會有閱讀上的順序關係，例如閱讀
Object-oriented analysis 跟 Object-oriented design 之 前 應 先 閱 讀
Object-oriented concept，因此他們會有依存的關係。
(3) 解法（Approach）：如前所述，某些議題的介紹並不是分為子議題，而
是針對此議題介紹各種不同解法或方法，這類型便以「解法」定義。
書後的索引（Index）雖然也具有相當的參考價值，但由於索引實在太過龐
雜，若索引中的每個字都做為書本的關鍵字，反而在描述上增加許多困難，且看
不出書本內容的重點。而上述的三項關鍵字分類係依書本知識的架構得來，故以
此三類關鍵字便能對書本知識做有效率的描述，書本知識關鍵字可以圖 7 - 6
表示：
圖 7 - 6 書本關鍵字示意圖
Subject
Topic Topic Topic
Topic TopicTopicTopic Topic
Approach
Topic Topic
Approach
91
進行概略的比較，增進書本知識的效率。
7.2 以問題–解法為基礎的軟體知識分類方法
傳統的知識分類方法大都依知識所談到的內容加以分類（如 Taxonomy、
Faceted Classification）或描述（如 Case-based Reasoning、Ontology），但
鮮少依知識特性及使用者的需求考慮。因此當知識量累積過多時，常常讓使用者
無法快速取得他所需要的知識，使得知識庫缺乏效率。例如擁有大量論文的 IEEE
電子期刊資料庫、ACM 電子圖書館，雖然提供使用者知識的分類，也能夠讓使用
者以關鍵字查詢，但動輒上千篇的查詢結果卻讓使用者無法快速掌握其所需的知
識，使用者與系統的溝通僅能透過一些未經定義的關鍵字，因此使用者必須浪費
許多時間閱讀知識後發現此知識並非他所需要的。照理知識庫擁有愈多的知識愈
好，但沒有效率的知識分類法讓大量的知識變成系統及使用者的負擔，這是非常
可惜的。
依上一節所分析的，技術論文及技術報告皆是「問題導向」的知識，其目的
是為了提出對問題的解法。此外，使用者使用知識庫的目的可分為要了解某領
域、要深入了解某議題、找尋特定的問題的解答或了解技術的運用領域。從知識
的特性及使用者的需求，都能夠發現「問題–解法」是知識建構的一個重要基礎，
技術論文、技術報告是根據問題提出解法，而使用者找尋知識時也是在尋找問題
的解答。
因此，我們可以利用「問題–解法」為基礎提出一個軟體知識分類方法，若
我們能夠有效率地描述論文所處理的問題及其使用的解答，則使用者便可以快速
地找出他所需要的知識。更進一步，這套分類方法應該能夠自動對知識進行分
析，以一些準則對解法排序，避免使用者時間的浪費。此外，這套知識分類方法
也要能夠描述書本知識，讓使用者能找尋特定主題的介紹性知識。
根據 7.1.2 節對軟體知識本質的分析，發現軟體知識的關鍵字是最常見的索
引依據。然而目前的軟體關鍵字缺乏良好的定義法則，故顯得零散且無關聯性，
由其知識本質，我們可將技術論文及技術報告的關鍵字分為四類，即「領域」、「問
題」、「解法」、「技術」。這四個分類正好符合「問題–解法」架構，因為要描述
一個問題，應當先描述其所在領域，軟體知識的領域是有階層性的，一個大領域
可分為數個小領域，因此描述知識的領域最恰當的方式就是利用階層架構
（Hierarchy-structure），故我們可以稱領域為領域類別（Category），有了領
域之後，我們便可以在階層架構上加入對問題的描述。這些問題便可稱為該領域
下的「議題」（Issue）；而描述一個解法，重點就在於「解決方法」（Approach）
以及運用的「技術」（Technique），因此，我們只需利用有良好定義的關鍵字，
即可對技術論文及技術報告進行有效率的「問題–解法」分類與描述。
93
議題可視為介面，這個介面會有一些解法去實現（Realization）它。對特定的
議題，解法可能不止一種，例如對 text categorization 的議題，有些論文可能
採用 machine learning 的解法，有些論文則可能採用 neural networks 的解法，
這些不同的解法，可看成不同的類別在實作議題，解法之間可能會有改良的關
係，即一種解法是改良自另一種解法，這個關係就像是類別之間的繼承
（Inheritance）一樣。而很多論文可能會使用同一種解法，這些論文便可視為
該解法類別的物件（Object），這些論文物件因其內容不同，故運用的技術亦不
同；這些技術同樣可視為不同的類別，被論文物件所使用（Use）。當論文採用相
同的解法，並運用了同樣的技術，則表示這兩篇論文非常類似，新的論文能夠被
期刊接受並登出，表示新的論文應有一些改進舊論文之處，故可視為新論文是改
善（Refine）了舊的論文。
因此，關鍵字類型與技術知識可用類別圖（Class Diagram）來表示，如圖 7
- 8：
圖 7 - 8 技術知識關鍵字類別圖
書本知識的關鍵字也同樣具有物件導向的特性，如上所述，書本知識探討的
95
外，關鍵字是類別，故可以靜態地儲存在知識庫中，知識是物件，故能夠自由新
增至知識庫，增加了知識分類的彈性。將議題當做介面，而以解法來實作的概念，
讓使用者很容易找到議題的各種解法，以及其下有哪些知識物件。籍由解法之間
的繼承（Inheritance）以及知識物件之間改善（Refine）的關係，使用者可以
對解法與論文進行快速而有效率的比較，直接閱讀適合的論文，減少時間的浪費。
知識的關聯性能夠讓一個個獨立的知識形成一個知識網路，一個知識能夠依
不同的關係找到其他的知識，籍以滿足使用者各種不同的需求。這些關係可整理
如圖 7 - 10 所示，簡述如下：
圖 7 - 10 關鍵字分類及關聯性示意圖
(1) 包含（Aggregation）：關鍵字中的類別是層狀結構，因此彼此之間有著
包含的關係，書本知識的議題之間亦有包含的的關係；在物件導向中的
Aggregation 係指一個物件由其他物件所組成，在意義上是極相似的。因此利用
Aggregation 來表示類別之間的包含關係，此外也用來表示類別下所含議題的關
係。
(2) 實現（Realization）：一個特定的議題會有幾個解法試圖解決它，這樣
的關係就好比物件導向中一個定義好的介面（Interface），有一些物件實作它
（Implement）。這樣的關係在物件導向中稱為 Realization，因此我們利用
Realization 來代表議題與解法之間的關係。
(3) 使用（Use）：一個解法會運用一些技術，這樣的關係就類似物件導向中
一個類別使用了另一個類別一樣。因此我們就稱解法運用技術的關係為使用
（Use）。
Category Issue
Approach Technique
Aggregation
Equal
Association
Aggregation
Aggregation
Association
Dependency
Realization
Inheritance
Use
Equal
Equal
97
的解法，再由實現關係便可找到議題乃至於領域，便可了解技術的運用狀況。此
外，由於我們是以關鍵字做為描述的基礎，故傳統的關鍵字搜尋亦能幫助使用
者，且「問題–解法」的關鍵字分類法對關鍵字有嚴謹的定義，故使用者可直接
輸入有興趣的領域、議題、解法或技術，不會找出許多根本不適合的知識。如此
知識庫的知識愈多，愈能夠讓使用者找到有用的知識，達到軟體知識管理的真正
目的。
當使用者閱讀知識之後，也可能會想取得其他相關的知識；這種情況又可分
為幾種類型：想進一步了解目前知識中提到的技術、想知道此解法被哪些解法改
進或運用，這時便可利用上述的繼承（Inheritance）與運用（Use）關係來達成。
因此，上述的關係能夠讓使用者找出需要的知識，增進知識庫的效率，且能
讓使用者取得相關的知識，足以達到知識管理的需求。
有了關聯性後，可以更進一步地以符號的方法來表示：
(1) 包含（Aggregation）：
(2) 實現（Realization）：←
(3) 使用（Use）：⊕
(4) 繼承（Inheritance）：⊲
(5) 相等（Equal）：≡
(6) 關聯（Association）：⊲
(7) 依存（Dependency）：⊲
(8) 改善（Refine）：⊲
如此，我們便可以運用符號以及關鍵字來表示一個知識，例如前面的例子，
Steffen Heinz的”Burst tries: a fast, efficient data structure for string
keys”，其內容是處理 text database 領域中的 string data structure 問題，
他提出了稱為 burst tries 的解法，此解法運用了 splay trees、tries、binary
trees、hash table 等技術，故可以符號表示如下：
(database text database) 
string data structure ←
burst tries ⊕
(splay trees, tries, binary trees, hash table)
此解法是改善 ternary search tree 的，故可表示如下：
(database text database) 
99
software engineering 
project management 
( project metrics, risk management,
project planning 
(software scope, project estimation ←
(problem-based estimation,
LOC-based estimation, FP-based estimation)
, make/buy decision)
, project scheduling)
利用符號來表示樹狀結構對人來說雖然比較難以理解，但對電腦系統而言卻
是非常容易解析；只要定義完整的 BNF（Backus-Nauer form）以及 syntax，即
可透過 lex & yacc 產生解析器（parser），對此格式的字串進行解析。
以「問題–解法」為基礎的知識分類法由於將關鍵字完整定義，故能夠提升
技術知識搜尋的速度、準確性，且能依使用者不同需要給予適當的知識，且由於
「問題–解法」的原則在軟體知識中任何領域皆通用，故不會侷限於特定的領域
中，更重要的是這套方法能夠利用符號清楚而有效地描述知識，若技術論文、技
術報告以及書籍作者都透過此方法來定義並描述其關鍵字，則所有的知識皆能夠
在一個統一的架構下交換使用，知識庫之間能夠合作、交換知識，更進一步甚至
能夠架構一個知識分享平台讓所有的技術知識在這平台上提供、分享、搜集、買
賣知識，這個符號表示法也能夠採用 XML（Extensible Markup Language）來定
義規格，則知識的分享便成為簡單的任務，大幅增進軟體知識管理的效率。
7.3 效益比較及分析
在前一章提到了四種常用的知識分類方法，包括 Taxonomy、Faceted
Classification、Case-based Reasoning、Ontology。這四種分類方法各有其優
缺點，在 7.1.2 節中也曾提出這些方法的問題，以下將以我們提出的「問題–解
法」知識分類法與上述四種方法進行比較與分析。
與 Taxonomy 的比較
Taxonomy 是以樹狀架構為基礎的知識分類法，是最直觀也最為常用的方
法。Taxonomy 最主要的分類是以領域為主，例如著名的杜威十進分類法（Dewey
decimal classification），在第一層是以大領域分類，如自然科學、語言學、
社會科學等，再下一層就更細分，如自然科學可分為數學、天文學、物理、化學
101
缺乏明顯互斥的分類面向，因此對此未有標準的 Facet 分類系統。對技術論文而
言，其 Facet 除了領域類別外，還可能包括如作者、期刊等，而書本知識則可能
有作者、出版社、ISBN 等面向，這些面向雖然有助於縮小檢索範圍，但對知識
內容的描述沒有幫助，而主要的領域類別僅是一個單純的 Taxonomy，其缺點如
前所述，知識量增加時將對使用者造成負擔。此外，即使定義了更具意義的描述
面向，Facet Classification 對使用者而言仍不方便。因為使用者必須從各個
面向的大類別往下找尋，無法直接利用簡單的關鍵字，由於使用者並不清楚知識
工程師的分類架構，對某些面向而言這樣的方法是相當耗力的，尤其當 Facet
愈來愈多，分類階層愈來愈多時，在這裡面找尋知識是費時費力的。
而「問題–解法」分類架構採用樹狀架構的領域類別，在其下採用了「議題」、
「解法」、「技術」等三種不同類型的關鍵字，增加了對知識的描述，且使用者不
必透過各種面向去搜尋，可直接利用上述類型的關鍵字找尋，例如使用者可直接
找 Travel salesman problem 的解法，也可指定要找 Greedy 或 Dynamic
programming 解法的論文，或更進一步指定特定的技術等，找到知識之後利用此
分類架構中的物件導向關係可以找到使用相同解法與技術的論文，或找相關解
法、相關技術的知識，具備高度的彈性，籍由關鍵字搜尋比起 Facet
Classification 方法快速而直觀，對使用者而言較為方便。
因此，Facet Classification 雖然可對知識定義較多面向，但無法描述解
法、技術等知識，且難以將書本知識與技術論文、技術報告整合，提供各種不同
需求使用者適當的知識；知識間也僅有各面向的同類關係，欠缺知識比較與技術
相關性，使得知識僅是單純地以各面向分類，而無法對知識做較有意義的描述。
「問題–解法」知識分類法能改善上述問題，因此是較佳的分類方法。
與 Case-based Reasoning 的比較
Case-based Reasoning（以下簡稱 CBR）的原則是以過往的經驗來解決新的
問題，因此對知識的處理是先分析，再經過特定的程序使知識能符合其模型，當
使用者對知識有需求時，透過其介面對案例（Case）進行描述，系統將此案例分
析後找出最合適的方案。由於此方法牽涉到對案例與解決方法的內容描述，故其
模型往往相當複雜，且有一定的領域限制，沒辦法運用在各個不同領域中。對
CBR 方法而言，各個案例都是單獨的存在，彼此之間僅有一些共通性的關聯，而
沒有架構良好的分類系統。這對軟體知識而言是不合適的，因為軟體知識有非常
多的知識領域，而各領域之下又有各種不同的問題，這些問題若沒有經過知識領
的分類，將顯得雜亂而難以搜尋，且不容易描述與分辨。例如資料結構中的
Binary search tree 與搜尋引擎中的 Inverted file 都會有改善最差狀況
（Improve worst case）的問題，這看似類似的問題，由於其領域不同，相關的
解法與技術也完全不同，因此，CBR 方法以單純的「案例」對「解決方法」來描
述知識，不足以對領域既廣且深的軟體知識做有效的分類。
103
法對這些解法進行比較分析，造成使用者必須閱讀全部知識才能判斷，非常沒有
效率。Ontology 為增進效率，就必須提供更詳細的知識描述模型，但這個方法
的領域限制性，就無法運用在各個領域的軟體知識上，要對每個領域都要發展其
Ontology 也非常耗時耗力，且造成使用者搜尋時的困擾。
由上可知，「問題–解法」知識分類法除了對知識做良好的描述外，還建構
了知識的物件導向關聯性，使知識能夠互相比較與參考，達到真正知識網路的概
念，比起 Ontology 僅對知識描述更有效率。
105
第八章 軟體知識的關鍵字分類機制
前一章提出了以「問題–解法」為基礎的軟體知識關鍵字分類法，本章將進
一步介紹分類機制以及搜尋及排序法則。8.1 節將說明關鍵字的分類及關聯性建
構方法；8.2 節則說明領域類別架構的設計概念；8.3 節描述此分類法的知識搜
尋及排序法則；8.4 節中則說明符號表示法及其 BNF（Backus-Nauer form）。
8.1 關鍵字分類建構法則
在第三章中提出了以「問題–解法」為基礎的關鍵字分類法，將軟體知識的
關鍵字區分為類別（Category）、議題（Issue）、解法（Approach）、技術（Technique）
四個類型，當關鍵字分成這些類型後，就能夠更進一步地建構知識的關聯性。這
些關聯性有助於知識庫對知識的搜尋與分析，也能讓使用者在閱讀知識後取得相
關的知識內容。由於物件導向所提出的物件關係與知識之間的關係有相當高的相
似程度，因此我們可以利用物件之間的關係來表達知識之間的關係。
這些分類及關聯性需要清楚定義，方能使知識作者對其關鍵字有效地分類，
讓所有的知識在一個統一的架構下交換使用，使知識庫之間合作、交換知識，真
正達到軟體知識管理的最主要目的：將正確的知識在適當的時機提供給需要的成
員。
建構知識關鍵字時，關鍵字類型的選擇原則如下：
(1) 類別（Category）：類別指的是知識所在的領域類別。為了讓知識能夠
互相交換溝通，將建構一個公開且維護良好的知識分類，類似網景公司提出的
ODP （ Open Directory Project ） 或 是 ACM 分 類 系 統 （ ACM computing
classification system），供知識工程師或知識作者選取適當的領域類別，這個
類別架構應提供足夠的深度與彈性，對軟體知識領域適當地分類。有了這樣的分
類架構，對於知識領域的選擇就有標準可循，分類架構將在 8.2 節中詳細討論。
選擇技術論文或技術報告的領域類別時，應依據其探討的主題，在分類架構
上從大至小縮小範圍，選定類別後，再循父類別定義至根類別。舉例而言，若分
類架構中有 Data structure →Tree →Binary search tree 的類別，當一篇論
文所談論的內容是 Binary search tree，則其領域關鍵字即是 Data structure、
Tree、Binary search tree，但這些關鍵字之間有包含（Aggregation）的關係，
故知識庫能夠知道此知識是在討論 Binary search tree，不會造成模糊不清的
問題。以符號方法表示，即為：
Data structure Tree Binary search tree
書本知識的類別其實就是其探討的主題，一本書只會有一個主題，只要分類
107
法的關係，清楚定義這些關鍵字有助於使用者理解與搜尋。
(4) 技術（Technique）：技術關鍵字是指技術論文或技術報告所提出的解法
中所運用的技術。「解法」指的是論文運用的基本方法，例如第三章舉的例子中，
有一篇解決 text categorization 的論文是採 machine learning 的解法；而「技
術」則是指其實際運用的技術，例如這篇論文運用了train-and-test以及k-fold
cross-validation 的技術。知識作者在定義技術關鍵字時，也應參考目前分類
架構中已存在的技術關鍵字，一般而言，技術關鍵字應是清楚定義
（well-defined），且較成熟且廣為人知的。論文當然也可以有新的技術，不過
由於定義新的技術關鍵字將影響後面作者，故應經過知識工程師與該領域專家討
論後再加入分類架構中。
籍由上述法則，技術論文、技術報告與書本知識的作者都能夠清楚且明確地
定義其知識的關鍵字。當關鍵字依上述分類後，有些關係便會自動產生，例如類
別間與類別–議題間的包含（Aggregation）、議題–解法間的實現
（Realization）、以及論文與技術間的運用（Use）等。但仍有一些關聯性必須
由知識作者定義：
(1) 繼承（Inheritance）：繼承是指新的解法（Approach）是從舊的解法改
進而來的，這個關係是指方法的改進，而非論文的改進。例如針對排序的問題，
有一篇論文提出 bidirectional bubble sort 的方法，這是改進自 bubble sort
的，由於此方法是新的解法，因此可以定義繼承關係。這個關係並非所有的論文
作者都必須定義，只有當論文作者提出了新的解法，而此解法又是從舊有的解法
改進而來時，才需要定義此解法的繼承關係。這是因為解法可視為物件導向中的
類別，而論文或報告可視為物件，因此繼承關係對採用相同解法的論文都是一樣
的。
(2) 依存（Dependency）：依存指的書本知識中議題的先後閱讀關係，例如
閱讀 Object-oriented Design 之前應該先閱讀 Object-oriented Concept；這
部份的關係建立之後有利讀者找到一個適當的閱讀切入點，且可跳過沒有依存關
係的章節。當書本作者定義了書本的議題、子議題、解法等架構之後，便可定義
議題之間的依存關係，此關係對作者而言非常容易，因為書本知識主要便是在介
紹與說明，故其章節編排的先後原本就有依存關係的考量，作者便依此定義依存
關係即可。
(3) 改善（Refine）：當論文採用相同的解法，並運用一樣的技術時，知識
庫可自動依其發表時間建構改善關係。這個關係也可由技術論文或技術報告作者
直接定義，有時論文雖然用了不同的技術，卻也可能是改善自其他論文的方法，
故作者可以定義此關聯性。
由上述，可以整理技術論文或技術報告作者定義關鍵字步驟如圖 8 - 1：
109
並建構關鍵字的關聯性，對技術論文、技術報告的作者而言，定義關鍵字是發表
前必須的工作；對書籍作者而言，定義書後的索引亦是不可少的任務。採用以「問
題–解法」為基礎的關鍵字法，由於是依據知識的本質所定義，因此對知識作者
而言並不困難。對技術論文、技術報告的作者而言，他們一定非常清楚論文所在
的領域、處理的議題、提出的方法以及運用的技術；對書本知識的作者，同樣也
十分清楚書本知識探討的主題、議題、子議題或方法等，以往定義關鍵字還必須
思考哪些字詞比較重要，而以這種方法定義，反而更明確且更容易。
8.2 領域類別架構設計
領域類別是「問題–解法」知識分類法中的基本架構，由於領域具有階層特
性，大領域又可細分為小領域，因此可採用樹狀的階層架構（Hierarchy
structure），即 Taxonomy 的方法對領域進行分類。由於議題與解法都將建構在
此領域類別之下，因此這個分類必須有足夠的廣度與深度，以及適當的彈性，方
能讓使用者有效率地在其中找到合適的知識。
由於 Taxonomy 的分類非常方便且直觀，因此有非常多著名的 Taxonomy 領域
分類系統。以圖書館的分類而言，最常用的即為杜威十進分類法（Dewey Decimal
Classification）以及美國國會圖書分類法（Library of Congress
Classification），而運用在期刊上最著名的則是 ACM 分類系統（ACM Computing
Classification System），此外尚有網路上許多搜尋引擎使用的 ODP（Open
Directory Project）等，這些分類方法都是對知識領域分類的階層架構，以下
將對這些方法進行討論，並提出適合軟體知識的領域類別架構。
杜威十進分類法是由 Melvil Dewey 在 1876 年發明的，目前由 OCLC（Online
Computer Library Center）負責維護。杜威十進分類法是利用十進位的數字來
表示類別，首先將所有的知識領域劃分為十種類型（稱為 Main class），在每個
Main class 下又可劃分十種較小的子領域（稱為 Division），而在 Division 之
下又再分十種更小的領域（稱為 Section），而在 Section 之下的小領域通稱為
Subdivision。由於是採用十進位的數字表示，因此每個類別至多只能分為十個
子領域，但都可以無限地細分，至目前為止杜威十進分類系統已經需要四本書才
能夠寫完。此分類法主要是以四層為基礎，其下可彈性地細分，其分類範例如圖
8 - 3 所示：
111
電子化，沒有書本編目的問題，因此可以設計更具彈性的分類架構，以符合領域
學門發展的變化。
ODP（Open Directory Project）是由網景公司（Netscape Communication
Cooperation）提出及管理的。此分類架構與傳統分類不同，採用了自主管理的
方法，ODP 僅提供一些分類架構的準則，由一些志工對此分類的發展進行維護。
由於此分類法的開放性與彈性，使其發展快速而穩定，非常多的搜尋引擎都是使
用 ODP 做為其分類架構，如 AOL Search、Netscape Search、Google、Lycos、
DirectHit、HotBot 等。最高層級的分類是事先設定且不能更動的，其下的分類
則沒有限制其層級數量，僅提供一些簡單的分類準則，例如當一個分類下有超過
二十個連結時，志工應考慮對其進行細分等。此分類法尚有一項特色，它提供了
相關類別（Related Category）以及相等類別（Equal Category）來加強此分類
系統的效率。所謂相關類別指的是將具有相關性的類別加以連結，如此在類別中
搜尋時亦可以將其相關類別納入搜尋中，籍以增加搜尋的有效範圍，例如
Algorithm 中的 Graph 跟 Computation Geometry 就是一個相關類別的狀況。相
等類別則是提供使用者由不同的瀏覽路徑，例如 Internet → WWW →
Programming 與 Programming → WWW 其實是相同的，故在分類之中建立一些相
等的關係，使得使用者不會因為一開始選擇的類別而找不到他所需的知識。ODP
的分類範例如圖 8 - 5：
圖 8 - 5 ODP 分類範例
ODP 雖然沒有限制層級數量，但至目前為止其分類都以四層為主，這個分類
的設計是以網頁資料為基礎，因此四層的分類已經足夠。但軟體知識的發展是非
常深入的，四層分類將使得同一分類下的議題及知識太過龐大，且使用者也無法
依此分類準確地找到適合的知識，例如近年來急速發展的 Internet，若要細分
的話可能會出現下列的類別：Internet → WWW → Web Programming → Scripting
Language → ASP → Database Connection，光是這些就需要六層的分類才真正
能夠將知識恰當地分類。
ACM 分類系統（ACM Computing Classification）是最常運用在技術論文上
的分類法，此分類法由 ACM（Association for Computing Machinery）提出，
113
Section、Subdivision，而美國國會圖書分類法的四層架構由上而下則是 Main
class、Subclass、Division、Subdivision，參考這兩個著名的分類系統，定義
我們的七層分類架構如圖 8 - 7：
圖 8 - 7 七層分類架構示意圖
此七層架構提高了目前常用分類法的深度，讓軟體知識能夠依其討論內容恰
當地分類，而七層架構又不致於太過繁雜造成使用者困擾，例如近年來發展快速
的 Internet 就可以依此架構分類如圖 8 - 8：
Main class
Subclass
Division
Section
Subdivision
Subsection
Segment
115
8.3.1 知識排序法則
根據第七章的分析，找尋書本知識是想找領域的介紹或深入了解特定議題。
對領域介紹而言，書中若談到較多的子議題，往往代表其介紹的較為豐富且完
整。舉例而言，介紹演算法的書很多，若有一本介紹了十種主要的演算法，另一
本介紹了十五種，則介紹十五種的書對於要了解演算法的讀者而言會較有助益，
因為他會能從中了解較多的演算法。對特定議題而言，同樣是介紹愈多子議題者
愈有助益，例如第三章提到介紹 C++的書，對於 Inheritance 這個議題，若有的
書介紹了 Constructor、Polymorphism & Virtual Function、Destructor、
Multiple Inheritance，而有的書只介紹了前三個議題，則閱讀前者的讀者能多
對 Multiple Inheritance 有所了解，因此幫助較大。
除此之外，書本知識的頁數也具有一定的代表性，在一般情況下，相同的議
題，使用較多頁數的書本往往介紹得較為清楚且完整。這些特性將能夠運用在書
本知識的比較上。
對於技術論文或技術報告而言，因為要找尋的是問題的解法，故比較的應該
是何者是此問題的最佳解法。但解法的比較依領域不同，其準則亦不同，例如
Hash table 可能是比較其 Collision rate，而 Binary search tree 可能是比較
其 Internal path，但我們發現論文之間的解法可能是有繼承的關係，即新的解
法是從舊解法改良而來，一般而言，新的解法對該議題而言應有較好的效益，否
則不會被大家接受。此外，若兩篇論文採用相同的解法，並運用同樣的技術，表
示這兩篇論文的作法類似，則新的論文應是改善舊論文作法而產生的，且其效益
應較佳，假若採用相同解法與技術但效益卻沒有比較好的話，不會被期刊審訂的
領域專家所接受。如第三章所述，我們利用上述關係建構了繼承（Inheritance）
與改善（Refine）的關係，故可用以做為知識排序的比較法則。
此外，若一篇論文被許多其他領域的論文所引用（Citation），表示其解法
相當具有學術價值，故除了上述採用繼承、改善對解法做一基本比較外，尚可利
用論文被其他領域論文引用的次數來做排序。
由上述，對書本知識的排序準則依序是：子議題數、頁數；對技術報告與技
術論文的排序準則依序是：解法繼承、論文改善、被引用數。籍由這樣的準則，
在一般情況下能夠讓使用者找到最可能符合需求的知識。
8.3.2 知識搜尋方法
如 4.2 節所述，我們的分類將以七層架構為基礎，配合相關類別與相等類別
提昇知識搜尋效率。由於軟體領域既廣且深，因此使用這樣的分類較容易幫助使
用者找到符合的知識類別。如之前分析的，使用者找尋知識的需求可分為四種類
117
的時間。
在 7.3節中，定義了八種關聯性，這些關聯性的符號定義如下：
(9) 包含（Aggregation）：(
(10) 實現（Realization）：←
(11) 使用（Use）：⊕
(12) 繼承（Inheritance）：⊲
(13) 相等（Equal）：≡
(14) 關聯（Association）：⊲
(15) 依存（Dependency）：⊲
(16) 改善（Refine）：⊲
依這些關係對知識的描述，可定義其 BNF（Backus Naur Form）如下：
<knowledge> ::= <stmtlist>;
<stmtlist> ::= <stmt>;<stmtlist> |
<stmt>
<stmt> ::= (<category>) 
<issue>←<approach>⊕ <technique> |
<category> (<bookissue>) |
<caterelation> |
<issuedeplst> |
⊲<paper>
119
<bkissuelst> ::= <bookissue> |
<bookissue> , <bkissuelst>
<identifier> ::= <letter> {<letter> | <digit>}
<caterelation> ::= <identifier> ≡ (<categorylst>) |
<identifier> ⊲ (<categorylst>)
<issuedeplst> ::= <issue> ⊲ (<issuelst>)
<issuelst> ::= <identifier> {, <issuelst>}
<paper> ::= <author>. <name>.
<journal>, <page> - <page>
<author> ::= <identifier> { and <author>}
<name> ::= <identifier>
<journal> ::= <identifier>
<page> ::= <digit> {<digit>}
採用上述的文法，可以將關鍵字關聯性以符號表示。此文法設計有陳述句
（statement）的概念，因為知識的基本架構如書本知識的議題或技術論文的類
121
第九章 軟體知識庫系統之設計
本章將以「問題–解法」分類法實作一雛型（Prototype）知識庫，以證分
類法的可行性。在 9.1 節首先根據「問題–解法」知識分類法整理出系統功能需
求。接著 9.2 節根據這些需求，提出系統的設計架構與模組設計。9.3 節則將說
明系統資料儲存設計，最後在 9.4 節介紹實作的使用者介面。
9.1 系統功能需求
此雛型（Prototype）知識庫主要提供使用者進行知識的搜尋、檢索以及知
識工程師對知識內容及分類架構的維護。依「問題–解法」分類架構，關鍵字可
分為「類別」、「議題」、「解法」、「技術」四種類型，對每一種關鍵字都會有不同
的操作。依一般使用者與知識工程師的不同，可整理其需求如下：
(1) 一般使用者需求：一般使用者主要利用分類架構由上往下找尋知識，其
中包括找領域類別介紹、議題介紹、議題解法等目的，使用者也可以找尋特定技
術被運用在哪些論文或領域。此外可利用符號表示法新增知識。其需求可整理如
表 9 - 1：
一般使用者需求
編
號
需求 說明
R1 新增知識 利用符號表示法新增知識
R2 類別瀏覽 從分類架構中瀏覽知識類別，找到類
別後可閱讀其子議題、書本知識、最新狀
態等
R3 讀取議題 特定議題介紹、書本知識、最新狀態
等
R4 讀取解法 讀取解法介紹及相關論文等
R5 閱讀技術論文或技術
報告
閱讀其摘要、引用、運用技術等
R6 閱讀書本知識 讀取書本知識議題架構及依存關係
R7 技術運用狀況 了解技術運用論文、解法、議題、領
域
123
圖 9 - 1 知識庫系統架構圖
依前一節的功能需求，我們將系統分為幾個主要模組，利用層級式（Layer）
的設計方法，其模組架構圖如圖 9 - 2：
圖 9 - 2 系統模組架構圖
各模組功能介紹如下：
Web Browser
Web Browser
Web Browser
Client
ASP Module
ASP Module
ASP Module
ASP Module
Knowledge Data
(COM Object)
Knowledge Data
(Files)
Database
Web Server
Server
知識類
別模組
議題模
組
解法模
組
技術模
組
知識新
增模組
管理員
認證
UI Layer
技術知識
模組
書本知識
模組
符號表示
解析器
Common Tool Layer
檔案系統資料
快取模組
記憶體資料快
取模組
Cache Data Layer
資料庫
Database Layer
125
(2) 論文列表：依排序法則顯示採用該解法的論文，以及各論文使用的技
術。
(3)父議題：顯示特定解法的父議題及其父類別串。
(4)修改解法繼承關係：知識工程師可對解法繼承關係進行修改動作。
 技術模組：
(1) 相等 / 相關關鍵字簡介：顯示特定技術相等或相關的知識類別、議題
或解法，並連結至該關鍵字下的簡介。
(2) 運用論文：顯示運用特定技術的論文。
(3) 運用議題：顯示運用特定技術的議題及其父類別。
(4) 運用知識類別：顯示運用特定技術的知識類別。
(5) 新增技術：知識工程師可新增一特定技術。
(6) 修改技術關聯性：知識工程師可修改特定技術的相關 / 相等關鍵字。
 知識新增模組：
此模組可利用符號表示法描述知識後新增至知識庫。
 管理員認證：
此模組負責知識管理員的身份認證工作。
 書本知識模組：
(1) 書本議題架構：以樹狀架構方式列出書本議題架構，以及依存關係。
(2) 相關書本列表：列出介紹相同主題的書本。
(3) 讀取書本知識：若書本知識已電子化，直接給予使用者書本知識，否則
告知使用者書本知識所在位置。
 技術知識模組：
此模組提供使用者技術論文或技術報告及其相關知識，功能如下：
(1) 技術知識摘要：顯示技術論文或技術報告摘要。
127
技術等分類，此外還包括技術論文、技術知識、書本知識的資料，由於關鍵字間
以及知識間有關聯性，因此必須設計對應的資料表儲存其關聯性，整體知識庫表
格設計如圖 9 - 3 所示，依各資料表分述如下：
圖 9 - 3 資料表架構圖
 tblCategory：知識類別資料表
 CategoryID：自動遞增的數字代碼，Primary Key
 ParentCategory：父類別代碼，0表示最上層目錄。此欄建立索引。
 CategoryName：知識類別名稱
 Intro：知識類別簡介，為一指到長文字的指標。
 IssueCount：類別下的議題總數，此欄建立索引。
 UseCount：閱讀此類別介紹的次數，此欄建立索引。
知識類別為樹狀結構，因此每個類別必須儲存其父類別代碼，如此便可由程
式建立樹狀結構關係，由於建構是由上往下，故此欄會做為篩選條件，故建立索
引。子議題數與使用次數是用來對類別的熱門度排序，由於要排序，故必須建立
索引以加快速度。
 tblRelCategory：相關類別資料表
129
 TechniqueID：自動遞增的數字代碼，Primary Key。
 TechName：技術名稱。
 EqualTo：與此技術對等的關鍵字。
 RelatedTo：與此技術相關的關鍵字。
技術資料的介紹是來自於與其相關或相等的關鍵字，可能是知識類別、議題
或解法，故其表示法採用簡單編碼，以一個英文字母表示型態，接著便是其數字
代碼。知識類別為 C、議題為 I、解法為 A，例如特定技術與知識類別代碼 15 相
等，則表示為 C15。
 tblTechKlg：技術知識資料表
 TechKlgID：自動遞增的數字代碼，Primary Key。
 ApproachID：此知識採用的解法代碼，此欄建立索引。
 PaperName：論文或技術報告名稱。
 Abstract：摘要，為一指到長文字的指標。
 Author：知識作者。
 Source：知識來源，可能是期刊或研討會名稱。
 SourcePage：知識來源頁數範圍。
 CitedCount：此知識被引用數，此欄建立索引。
 UseCount：此知識被閱讀數，此欄建立索引。
 PublishDate：知識發表日期，此欄建立索引。
 FileName：知識全文檔案名稱。
 PaperType：知識是技術論文或技術報告，技術論文為 1，技術報告為 2。
技術知識包括技術論文與技術報告，由於此知識會運用特定解法解決特定議
題，故需儲存解法代碼。被引用數是論文排序準則之一，此欄的值由觸發程序維
護。發表日期亦可做為排序準則，這些欄位都建立索引以加速排序。技術知識的
全文檔案通常用 PDF（Portable Document Format），故存放在特定目錄下，資
料庫則儲存檔案名稱以便存取。
 tblCitation：引用資料表
 TechKlgID：技術知識代碼，此欄建立索引。
 CitationID：引用知識代碼，此欄建立索引。
技術知識的引用關係可做為排序準則，並可找出引用與被引用的知識。由於
兩種情況都有可能，故兩欄皆建立索引以加速存取速度。
131
 PublishDate：出版日期。
 FileName：書本全文檔案名稱。
 tblBkIssue：書本子議題資料表
 BkIssueID：自動遞增的數字代碼，Primary Key。
 BookID：議題所屬書本代碼，此欄建立索引。
 ParentIssue：父議題代碼，0表示最上層議題，此欄建立索引。
 IssueName：議題名稱。
 IssueType：議題類型，1為子議題，2為解法。
書本知識子議題是樹狀結構，議題下可能是子議題或解法，故同樣採用各議
題儲存其父議題的方式讓程式能建構樹狀結構。由於建構是由上而下，故父議題
代碼會做為搜尋條件，建立索引以加速存取。
 tblBkIssueDep：書本子議題依存關係資料表
 BkIssueID：書本子議題代碼，此欄建立索引。
 DependOn：依存子議題代碼，此欄建立索引。
書本子議題之間的依存關係由此資料表儲存。由於搜尋時可能會找依存哪些
子議題，也可能找哪些子議題依存於特定議題，故兩欄皆建立索引。
由於類別與議題都有「最新狀態」的功能，因此設計一特殊資料表來儲存各
類別、議題的最新狀態：
 tblLatestStatus：最新狀態資料表
 ParentType：關鍵字類別，此欄建立索引。
 ParentID：關鍵字代碼，此欄建立索引。
 SeqNum：最新狀態序號，愈小表示愈新，此欄建立索引。
 LatestType：知識類別。
 LatestID：知識代碼。
ParentType 是一個英文代碼來表示關鍵字類別，可能是 C（類別）或 I（議
題），SeqNum 表示序號，每個類別至多存五筆最新知識，故 SeqNum 是 1~5；
LatestType 是英文代碼表示知識類別，可能是 T（技術知識）或 B（書本知識）。
技術知識的引用數（CitedCount）是由 tblCitation 的觸發程序控制的，當
一筆資料寫入 tblCitation 時，會啟動觸發程序將此知識的 CitedCount 加 1，
刪除時也會啟動觸發程序將 CitedCount 減 1，籍此維護知識的引用數。
當 tblApproach 的資料有插入或刪除時，會執行一預存程序 spApprCount，
133
各類別設計介紹如下：
 Category
此物件儲存一個知識類別，並以一指標指向其父類別（ParentCategory），
類別簡介存放在檔案系統中，以 IntroFile 存檔名。最新狀態存放五個指標，指
向 Book 或 TechKlg，此外相等類別、相關類別及子類別都以 KeywordList 類別
存取，而其下的書本知識則以 BookList 存取，其關係圖如圖 9 - 5 所示：
圖 9 - 5 知識類別資料結構關係圖
 Issue
此物件儲存一個議題，以一指標指向其父類別（ParentCategory），簡介一
樣存放於檔案系統中，也以五個指標存放其最新狀態；其下的解法以
KeywordList 類別存取。其關係圖如圖 9 - 6 所示：
圖 9 - 6 議題資料結構關係圖
135
圖 9 - 9 技術知識資料結構關係圖
 Book
此物件儲存一個書本知識。利用一個指標指向此書本所探討的知識類別，並
以一 BkIssueList 類別存取其下的子議題，其關係圖如圖 9 - 10 所示：
圖 9 - 10 書本知識資料結構關係圖
 BkIssue
此物件儲存一個書本知識的子議題。利用一指標指向該書本知識，以一指標
指向父議題，並以一 BkIssueList 類別存取其下的子議題，關係圖如圖 9 - 11
137
識庫的功能，籍由「問題–解法」分類架構逐步縮小範圍，以查詢符合需要的知
識；關鍵字搜尋是供使用者直接查詢特定技術論文、技術報告或了解技術運用狀
況；最新文件是供使用者了解目前知識庫有哪些最新文件。在主頁下方有功能介
紹，如圖 9 - 12：
圖 9 - 12 一般使用者主畫面
新增知識分為新增技術論文、新增技術報告及新增書本知識，其中新增技術
論文的畫面中，要輸入論文名稱、作者、來源名稱、頁數範圍、摘要、出版日期、
符號表示關鍵字以及全文檔案，引用（Citation），如圖 9 - 13：
圖 9 - 13 新增論文畫面
引用的資料依論文引用固定格式，直接輸入所有的引用資料。每筆引用資料
開頭要編號，結束再多換一行。由於作者數量不固定，解析時可由後往前解析，
找出引用知識的資訊，這部份也可考慮採用 ACI（Autonomous Citation
139
圖 9 - 15 類別瀏覽主畫面
點選特定類別後，會顯示類別的簡介，對單一類別可以觀看其子類別、書本
知識、最新狀態、最熱門子類別、相關類別等，其畫面如圖 5 - 16 所示：
圖 5 - 16 類別簡介畫面
其中，最熱門子議題有兩種排序方式，一種依使用次數，另一種依其下子議
題數，如圖 9 - 17 所示：
141
圖 9 - 19 子議題列表畫面
點選特定議題後，可看到議題簡介。使用者可選擇觀看議題最新狀態或解法
列表，議題最新狀態是依出版日期列出解決此議題的技術知識，而解法列表則是
依繼承關係排序列出相關解法，如圖 9 - 20：
圖 9 - 20 解法列表畫面
點選解法後可看到解法簡介，並可找出採用該解法的技術知識，解法畫面如
圖 9 - 21：
143
圖 9 - 23 引用知識畫面
此外也可觀看論文運用的技術，如圖 9 - 24 所示：
圖 9 - 24 論文運用技術畫面
使用者可點選特定技術，以了解該技術的運用狀況，如圖 9 - 25：
145
圖 9 - 27 書本知識列表
若選擇一本書後，將進入書本知識介紹畫面，其中包括書本的基本資料及簡
介，此外使用者可選擇觀看議題架構，書本知識介紹如圖 9 - 28：
圖 9 - 28 書本知識簡介畫面
而書本知識子議題架構中，可點選子議題觀看其依存關係，如圖 9 - 29 所
示：
147
圖 9 - 31 類別架構管理畫面
知識工程師也可管理技術，以及與技術相關或相等的關鍵字，畫面如圖 9 -
32：
149
151
3. 提升 ArgoUML 開發環境之效能，使用者可以同時在建立 UML 圖形時檢視
系統中已定義的各項產物，並給予使用者建立圖形元素之建議及自動檢查 UML
圖形產物之完整性，改善以往 UML 圖形與檢查工具分開執行所造成的不方便。
10.2 「知識分類機制之精進」部份
目前的軟體知識庫都面臨缺乏效率的問題。當知識累積數量增多時，知識庫
的效率及正確性便會降低。知識庫的效率與知識分類方法有密不可分的關係，本
研究分析目前常用的知識分類方法，發現這些分類方法中，Taxonomy 太過簡單
故缺乏效率；Faceted Classification 會因知識數量增多而過於複雜；CBR 則缺
乏良好的分類架構；Ontology 只做到知識的描述，而欠缺知識間的關聯性。由
於這些方法都不是為了軟體知識管理而設計，故運用在軟體知識上都有其不足之
處。
因此，本研究從軟體知識的本質進行分析，探討了技術論文、技術報告、書
本知識等類型的軟體知識，發現這些知識都具有「問題導向」的特性。此外，為
了加速知識搜尋效率，這些知識都會定義關鍵字，然而一般關鍵字都較零散且缺
乏規則，且關鍵字之間沒有具體的關聯性。因此，本研究提出以「問題–解法」
為基礎的軟體知識分類法，將關鍵字分為「領域類別」（Category）、「議題」
（Issue）、「解法方法」（Approach）、「技術」（Technique）四類，並進一步發現
這些關鍵字類型以及軟體知識都可利用物件導向的中的類別或是物件來表示。故
可利用物件導向的各種關係定義彼此的關聯性，包括了包含（Aggregation）、實
現（Realization）、使用（Use）、繼承（Inheritance）、相等（Equal）、相關
（Association）、依存（Dependency）、改善（Refine）等。利用這些關鍵字類
型及關聯性，可有效對軟體知識分類，提供不同需求使用者適當的知識，也可對
知識進行比較與排序，即使知識數量增多仍能維持知識檢索的效率。
為改進常見分類法對軟體知識分類深度不足的缺點，本研究提出以七層架構
為基礎建構領域類別，以符合各領域學門的深度。此外，本研究更進一步將這些
關鍵字的關聯性以符號表示，並提出符號表示法的 BNF，使知識作者能利用「問
題–解法」知識分類法定義關鍵字，以此方法有效地對知識進行描述。
本研究依提出的知識分類方法，實作了一雛型（Prototype）知識庫，以驗
證其可行性。此系統使用 IIS（Internet Information Server）搭配 ASP（Active
Server Page）做為網站架設及系統開發平台，後端採用 SQL Server 資料庫存放
資料。
本研究所提出的軟體知識的分類方法具有下列優點：
153
(5)實作此分類法的雛型知識庫系統：
本研究根據提出的軟體知識分類法實作一個雛型知識庫系統，讓知識庫使用
者能依其需求找尋合適的知識，證實「問題–解法」知識分類法的可行性。
155
Object-Oriented Behavioral Models.
[14]Martin Skinner. Enhancing an Open Source UML Editor by Context-Based
Constraints for Components, University of Berlin, Thesis, December 2001
[15]Linus Tolke and Markus Klink. Cookbook for Developers of ArgoUML
[16]ArgoUML Tour. http://argouml.tigris.org/tours/index.html
[17]P. Naur and B. Randell (eds), Software Engineering: A Report on a
Conference sponsored by NATO Science Committee. NATO 1969
[18]劉文謙,施向玨與鍾乾癸, “軟體知識管理,” 第十三屆物件導向技術及應用
研討會, 臺中縣 霧峰鄉 臺中健康暨管理學院, 中華民國九十一年九月十三
日
[19]劉文謙,廖元誠,施向玨與鍾乾癸, “結合知識管理與能力管理之軟體發展環
境,” 第十四屆物件導向技術及應用研討會, 桃園縣 中壢市 元智大學, 中
華民國九十二年九月十二日
[20]http://support.microsoft.com/default.aspx?scid=fh;ZH-TW;KBHOWTO
[21]http://www.computer.org/publications/dlib/
[22]http://www.acm.org/dl/
[23]Bloom, B.S. (Ed.) Taxonomy of educational objectives: The
classification of educational goals: Handbook I, cognitive domain. New
York ; Toronto: Longmans, Green. 1956
[24]Wynar, Bohdan S. Introduction to cataloging and classification. 8th
edition. p. 320
[25]A. Aamodt, E. Plaza; Case-Based Reasoning: Foundational Issues,
Methodological Variations, and System Approaches. AI Communications.
IOS Press, Vol. 7: 1, pp. 39-59. 1994
[26]D. Fensel. Ontologies: Silver Bullet for Knowledge Management and
Electronic Commerce. Springer-Verlag
[27]I. Rus, et. Al., “Knowledge Management in Software Engineering: A
State-of-the-Art-Report,” DACS Report, 2001
[28]Ikujiro Nonaka and Hirotaka Takeuchi, "The Knowledge-Creating Company :
How Japanese Companies Create the Dynamics of Innovation", OXFORD
UNIVERSITY PRESS, 1995
157
Knowledge Sharing, International Journal of Human-Computer Studies,
43:907-928, 1995.
[46]Dieter Fensel and Ian Horrocks and Frank van Harmelen and Deborah L.
McGuinness and Peter F. Patel-Schneider, OIL: An Ontology
Infrastructure for the Semantic Web, IEEE Intelligent Systems, 2001,
16, 2.
[47]Fabrizio Sebastiani, Machine learning in automated text categorization,
ACM Computing Surveys Volume 34, Issue 1(March 2002), pp. 1-47
[48]David F. Bacon, Susan L. Graham and Oliver J. Sharp, Compiler
transformations for high-performance computing, ACM Computing Surveys
Volume 26, Issue 4 (December 1994), pp. 345-420
[49]W. Meng, C. Yu, and K. Liu. Building efficient and effective metasearch
engines. ACM Computer Surveys, March 2002.
[50]J. Jing, A. Helal, A. Elmagarmid, "Client-Server Computing in Mobile
Environments," ACM Computing Surveys Vol. 31, No. 2, pp. 117 - 157, June
1999.
[51]Steffen Heinz, Justin Zobel, Hugh E. Williams, “Burst Tries: A Fast,
Efficient Data Structure for String Keys”, Transaction of Information
System, Vol. 30, Issue 2
[52]H. Chang and S. S. Iyengar, `Efficient algorithms to globally balance
a binary search tree', Commun. ACM, 27, (7), 695--702 (1984).
[53]S.L. Martins, M.G.C. Resende, C.C. Ribeiro and P. Pardalos. A parallel
GRASP for the Steiner tree problem in graphs using a hybrid local search
strategy, J. of Global Optimization, 17: 267-283, 2000.
[54]R. S. Pressman, Software Engineering, A Practitioner's Approach,
European edition, McGraw-Hill, 1994.
[55]Richard Johnsonbaugh, Martin Kalin, Object-Oriented Programming in C++,
Prentice Hall, 2000
[56]Hafedh Mili, Ali Mili, Sherif Yacoub, Edward Addy, Reuse Based Software
Engineering: Techniques, Organizations, and Measurement, John Wiley &
Sons Inc, 2002
