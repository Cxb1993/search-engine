目          錄 
第 1 章 、研究目的、方法及時程規劃 ..................................................................... 1 
1.1、 研究目的 ..................................................................................................... 1 
1.2、 研究方法 ..................................................................................................... 1 
1.3、 時程規劃 ..................................................................................................... 2 
第 2 章 、執行流程...................................................................................................... 4 
2.1、 實驗室建置 ................................................................................................. 4 
2.2、 戰術教練儀系統功能圖 ............................................................................. 7 
2.3、 戰術教練儀系統架構圖 ............................................................................. 8 
第 3 章 、初步系統原始碼分析 ............................................................................... 10 
3.1、 System_pre-initialization .......................................................................... 10 
3.2、 Exercise Initialization Algorithm .............................................................. 38 
3.3、 變數對照表(data type) ........................................................................... 122 
3.4、 階段性成果(~990707)整理 .................................................................... 134 
第 4 章 、細步分解說明.......................................................................................... 135 
4.1、 Main/Local Computer 的 Task 統整 ...................................................... 135 
4.2、 整體系統執行流程 ................................................................................. 138 
4.2.1、 Step1：開啟操演環境 ................................................................ 140 
4.2.2、 Step2：建立資料傳輸連線 ........................................................ 141 
4.2.3、 Step3：如何傳遞訊息： ............................................................ 145 
4.2.4、 Step4：關閉操演： .................................................................... 150 
4.3、 訊息傳遞範例說明 ................................................................................. 151 
4.4、 B_sysi_app_process 程式說明 ............................................................... 169 
第 5 章 、High Level Architecture (HLA) ............................................................ 193 
5.1、 發展 HLA 的目的 .................................................................................. 193 
5.2、 HLA 簡介 ............................................................................................... 193 
5.3、 Run-Time Infrastructure (RTI) ................................................................ 195 
5.4、 Federation 的發展步驟 .......................................................................... 197 
5.5、 HLA 架構分析 ....................................................................................... 199 
第 6 章 、結論及未來執行建議 ............................................................................. 204 
6.1、 結  論 ..................................................................................................... 204 
6.2、 未來執行建議 ......................................................................................... 205 
 
 i
執行單位：台北大學資訊工程學系 
未來移植現行商用電腦之可行性，整體程式改寫方式，以及未來委商改版之
系統驗證機制。 
4. 本計畫最後將提出風險評估報告。 
 
 
圖 1-1 計畫流程圖 
1.3、時程規劃 
 
每季管制點計劃查核： 
（一）第 1 季:實驗環境確定與系統備便，確認原廠商設計架構。 
（二）第 2 季:完成初步系統原始碼研讀(含 SGI 電腦、整體系統架構)。 
（三）第 3 季:完成細部系統原始碼研讀(含戰技與戰術之相關原始碼分析）、
系統分析與風險評估。 
（四）第 4 季:進行結案報告撰寫。 
 2
執行單位：台北大學資訊工程學系 
第2章、執行流程 
2.1、實驗室建置 
 
1.海軍電腦兵棋中心原系統建置圖 
原 TTC 系統建置圖有誤，重新繪製如下： 
 
圖 2-1 海軍電腦兵棋中心原系統建置圖 
2.台北大學社科院 8F15 實驗室建置 
特於台北大學社會科學大樓 815 室建置本案之系統模擬實驗室，以利
本案進行相關研究及系統測試。玆說明如下： 
 4
執行單位：台北大學資訊工程學系 
TTC 海軍兵棋系統開關機操作概要 
一、 開機順序 
1. 24-port switch 
2. Octane 的外接式硬碟 
3. Octane(以 integ 登入) 
4. O2(Database) 
5. Local 端 O2 和 MFK 
二、 帳號密碼 
1. Root: C_shore 
2. ttc: 338##* 
3. integ: integ971 
4. O2: u2smart 
三、 IP 位置 
1. Octane: 128.143.80.201 
2. Database: 128.143.80.250 
3. Trainee 15: 128.143.80.79 
4. Controller 55: 128.143.80.55 
四、 關機順序 
方法一： 
z 由 Octane 下指令關掉所有 Local 端電腦。(遠端登入指令: rsh IP) 
1. 登入 Local 端的 O2(10K) 
2. 登入 O2(10K)後再登入 O2(5K) 
3. 下 init 0 指令把 O2(5K)關機後，下 exit 指令回到 O2(10K) 
4. 下 init 0 指令把 O2(10K)關機後，下 exit 指令回到 Octane 
5. MFK 關機方法如同一般的 Windows 系統 
6. 重複以上動作直到所有 Local 端電腦全部關機 
方法二： 
z 由 Octane 點選功能 
A. 從 TTC Menu 選擇 DB 
B. 選擇 Maintain DB 
C. 點選第 4 個選項—System shutdown 
D. 選擇第 1 個選項—local computer shutdown 
或選擇第 2 個選項—main computer shutdown 即可關機 
 
 6
執行單位：台北大學資訊工程學系 
    CODE_EXT_CC_CONFIG  
    CODE_EXT_DET_CONFIG  
    CODE_EX_CONFIG_RQST_FINISHED  
    CODE_EXT_DEV_CONFIG  
G. 等待 LOCAL_APP 傳來的訊息，如果接收的 Msg_Code 為
CODE_LOCAL_EXER_TERMINATION，代表已經接收到 console
初始化結束的訊息。  
H. 將初始化結束的訊息傳送給 Local_Computer 裡的每一個 console，
Msg_Code 為 CODE_EXERCISE_ST_TERMINATION 
 
2.3、戰術教練儀系統架構圖 
 
下圖為戰術教練儀系統架構圖： 
 
 
圖 2-4 戰術教練儀系統架構圖 
 
下圖為戰術教練儀訊息架構圖： 
 8
執行單位：台北大學資訊工程學系 
第3章、初步系統原始碼分析 
3.1、System_pre-initialization 
 
圖 3-1 System_pre-initialization 流程圖 
 
詳細說明如下： 
 
z 追蹤進度: 
.chestrc -> auto_run.sh -> new_ttc_main_start -> b_sysi_ttc_startup.adb 
->b_prc_process_creator.adb 
由上述追蹤的進度分成 4 個部分做說明： 
(一)、.chestrc 部分的說明。路徑：ttc/users/integ/.chestrc。 
(二)、auto_run.sh 部分的說明。路徑：/usr/ttc/bin/auto_run.sh 
(三)、new_ttc_main_start 部分的說明。路徑：/usr/ttc/bin/new_ttc_main_start 
(四)、b_sysi_ttc_startup.adb 跟 b_prc_process_creator.adb 兩部分的說明。 
路徑：皆在 util/integ/ver7.0.6/main/bsw 
詳細的部分將在下面做說明。 
 
 10
執行單位：台北大學資訊工程學系 
圖 3-2 TTC Menu 
 
所有選項都有對應到一支程式路徑以及參數。依據參數的不同會影響到之後
的選擇。在一開始的時候先從選單中的 Start 開始，由程式片段 3-1 可看出 Start
 12
執行單位：台北大學資訊工程學系 
z (二)、auto_run.sh 說明 
在程式片段 3-1 中可得知當點選 start 的按鈕後，會連結到 auto_run.sh。程式
片段 3-2即為 auto_run.sh的程式部分，在此檔案中我們擷取判斷參數的片段，Start
所帶的 2 個參數為 quite 和-manual。依據判斷 param1 的結果，得知前三項判斷
式皆不符合，因此執行最後 default 的部分(/usr/ttc/bin/new_ttc_main_start $param1 
$console_name $param2)。 
檔名：autorun.sh 
路徑：/usr/ttc/bin/auto_run.sh 
備註：auto_run.sh 程式總共 51 行，以下片段是在第 32 行~第 48 行 
<以上略> 
case "$param1" in 
   -maintain_db) 
     /usr/ttc/bin/maintain_system_exercises.csh 
     ;; 
   -test_db | -restart_db) 
     /usr/ttc/bin/test_db_stat.exe $param1 
     ;; 
   -find_specific_err) 
     echo -n "\nPlease enter the console name to check: " 
     read console_name 
     /usr/ttc/bin/find_specific_err.sh $console_name 
     ;; 
   -reset_master_pannel) 
     /usr/ttc/bin/reset_ew_pan.sh 
     ;;        
   *) 
/usr/ttc/bin/new_ttc_main_start $param1 $console_name $param2 
<以下略> 
程式片段 3-2 auto_run.sh 程式片段 
 
z (三)、new_ttc_main_start 說明 
依據(二)、auto_run.sh 說明的步驟得知接下來執行的程式為
new_ttc_main_start。New_ttc_main_start 這支程式會去檢查所有需要用到的執行
檔是否存在，以確保系統之後能正常運作。並且，依據指令的不同也會去檢查錯
誤的訊息以及系統目前的狀態。在程式片段 3-3 中，當所有程序都正常時，教官
台跟學員台會開始執行初始化的執行檔(b_sysi_ttc_startup.exe)，執行後便會等待
教官台跟學員台初始化結束。 
  
 14
執行單位：台北大學資訊工程學系 
 
z (四)、b_sysi_ttc_startup.adb 跟 b_prc_process_creator.adb 兩部分說明 
Ada 程式的附檔名為.adb，當進行編譯之後會得到.exe 的執行檔。所以程式
片段 3-3 裡的 b_sysi_ttc_startup.exe 就是從 b_sysi_ttc_startup.adb 編譯而來的。我
們依據 b_sysi_ttc_startup.adb 的程式碼繪製流程圖跟變數對照表。圖 3-3 所示為
b_sysi_ttc_startup.adb 程式裡的流程圖。表 3-1 為流程圖圖形說明。 
 
表 3-1 流程圖圖形說明 
 
動作和說明 
 
副程式和外部程式 
 
開始和結束 
 
做 if 判斷和迴圈判斷 
圖 3-3 b_sysi_ttc_startup.adb 流程圖 
 16
執行單位：台北大學資訊工程學系 
分定為 A 部分。圖 3-3 的一開始會先做宣告變數的動作，之後在圖 3-3 中的各個
副程式分別都有做不同的工作，列出在下列做說明： 
¾ A1-1：做記憶體共享。 
¾ A1-2：創造出 1 個 mailbox。 
¾ A1-3：創造出 1 個 mailbox。 
¾ A1-4：產生 process 並做資料庫的初始化。 
¾ A1-5：開始從資料庫進行資料讀取的動作。 
¾ A1-6：創造 process 並給予所創造出的 process 一個名稱。 
A 部分的詳細說明在接下來的 19 頁。 
圖 3-3 的 A1-1 (b_sysi_create_automata_shared_seg)是在做共享記憶體的動作，
是指同一塊記憶體區段被一個以上的行程所分享。A1-1 的部分如下圖所示： 
  
 18
執行單位：台北大學資訊工程學系 
編號：A1-2 
檔名：b_sysi_ttc_startup.adb 
說明：建立 Mailbox 
路徑：util\integ\ver7.0.6\main\bsw 
出處：b_sysi_ttc_startup.b_sysi_create_automata_mailbox (參照程式碼第 182 行
到第 203 行) 
 
圖 3-5 b_sysi_ttc_startup.b_sysi_create_automata_mailbox 流程圖 
編號：A1-3 
檔名：b_sysi_ttc_startup.adb 
說明：建立 Mailbox 
路徑：util\integ\ver7.0.6\main\bsw 
出處：b_sysi_ttc_startup.Create_Automata_Creation_Mailbox (參照程式碼第 227
行到第 249 行) 
 
圖 3-6 b_sysi_ttc_startup.Create_Automata_Creation_Mailbox 流程圖 
 20
執行單位：台北大學資訊工程學系 
編號：A1-4 
檔名：b_sysi_ttc_startup.adb 
說明：process 建立 
路徑：util\integ\ver7.0.6\main\bsw 
出處：b_sysi_ttc_startup.Create_Process_Creation_Process (參照程式碼第253行到
第329行) 
 
圖3-7 b_sysi_ttc_startup.Create_Process_Creation_Process流程圖 
在圖3-7流程圖的說明中可以看到B1的部分有一個b_prc_process_creator的執
行檔，接下來為B部分的說明。在b_prc_process_creator這個檔案裡分別會開啟另
外B1-1(B_prc_process_init.Init_Creator)跟
B1-2(B_Sysi_Process_Creator_Main.Main_Procedure)兩個檔案。 
圖3-8為B1-1(B_Prc_Process_Init.Init_Creator)的流程圖，圖3-8中的部分列在
下列做說明： 
¾ B1-1-1：執行b_prc_bind_automata_segment(如圖3-8) 
¾ B1-1-2：開啟2個mailbox，並使用msgget()產生2個message queue 
¾ B1-1-3：給予一個系統目前狀態正常的訊息 
 22
執行單位：台北大學資訊工程學系 
B1-1-1跟B1-1-4兩部分說明如下： 
編號：B1-1-1 
檔名：B_prc_process_init.adb 
說明：設置 shared memory 
路徑：util\integ\ver7.0.6\bsw\process_control\b_prc_process_main 
出處：B_prc_process_init.b_prc_bind_automata_segment (參照程式碼第52行到第
68行) 
 
圖3-9 B_prc_process_init.b_prc_bind_automata_segment流程圖 
在上圖為B_prc_process_init.b_prc_bind_automata_segment的流程圖。依據程
式碼的部分分成3個項目做說明。 
¾ B1-1-1-1：從AUTOMATA_SHARED_MEMORY_KEY中取得
share_memory_key。 
¾ B1-1-1-2(如圖3-10)：用函式Shmget()並依照shm_Id去創造一塊記憶體共
享的空間，依據shm_Id的值去判斷創造的共享空間是否有錯誤
(Shm_Id=-1表示有錯誤)。如果沒有錯的話，使用函式Shmat()去允許
process使用共享區塊。並且會設定此空間權限(READ_ONLY或是
READ_WRITE)。 
¾ B1-1-1-3：將address設置到Automata_Shared_Pointer裡。執行完後便回
到圖3-8，接著執行B1-1-2。 
 24
執行單位：台北大學資訊工程學系 
編號：B1-1-4 
檔名：b_oss_inter_prcs_mailbox.adb 
說明：訊息傳送 
路徑：util\integ\ver7.0.6\bsw\process_control\b_oss_inter_prcs_mailbox 
出處：b_oss_inter_prcs_mailbox.put_message (參照程式碼第404行到第456行) 
圖3-11 b_oss_inter_prcs_mailbox.put_message流程圖 
B1-1-4流程圖如上圖，一開始會檢測訊息的大小是否有超過buffer的大小，
如果沒有超過buffer的大小，即進入迴圈中並可將訊息放入，使用Msgsnd()進行
訊息的傳送，傳送後依舊會去判斷是否傳送成功，如果沒有成功則會找出錯誤的
原因。如果成功傳送就會exit()離開B_oss_inter_prcs_mailbox.put_message的部分。
離開後，B1-1(B_prc_process_init.Init_Creator)的部分就全部結束，接著會執行
B1-2(B_Sysi_Process_Creator_Main.Main_Procedure)的部分。 
  
 26
執行單位：台北大學資訊工程學系 
B1-2(B_Sysi_Process_Creator_Main.Main_Procedure)的部分： 
¾ B1-2-1：先取得一個MailBoxId。 
¾ B1-2-2：資料庫初始化。 
¾ B1-2-3：從B_sysi_Local_Config中取得console type，所有的console type
有MC、IC、MTC等。 
¾ B1-2-4：執行接收訊息的動作(如圖3-12)。在圖3-12裡，一開始會去判
斷需不需要等待，如果不用等待就會使用Msgrcv()去接收一個Message，
接收Message後，會去進行錯誤偵測，如果無誤則會將取得的Message
存進buffer中。 
¾ B1-2-5：如果需要重新啟動便會將unix process終止(如圖3-13)。 
¾ B1-2-6：取得mailbox ID並給予此ID的process一個process_name。 
¾ B1-2-7：判斷process的名稱為TTC_MMI還是TTC_AN，並依照process
名稱的不同執行不同的等待時間。 
¾ B1-2-8：(見圖3-14)一開始將Internal_Pid傳入
B_Prc_Proc_Automata.Get_File_Data將取得Exe_Var_Dir_Name、
Input_File_Name、Output_File_Name、Error_File_Name、
Image_File_Name等資訊，接著再判斷是否為Master或是Slave、是否為
DEBUG模式，判斷完之後將所需要的引數整理到Arg_List中，決定是否
要啟動CVD或是ada_debug.rc。接著開始判斷傳入的Internal_Pid的
Process_Name為何，依照不同的Process_Name將其所需的引數結合到
Arg_List中傳至B_Oss_Prcs_Mng.Ada_Exec執行，若Process_Id有錯誤則
回傳Exception。 
  
 28
執行單位：台北大學資訊工程學系 
編號：B1-2-5 
檔名：B_Sysi_Process_Creation.adb 
說明：終止程序 
路徑：util\integ\ver7.0.6\bsw\system_initialization\process_creation 
出處：B_Sysi_Process_Creation.Terminate_Process (參照程式碼第1481行到第
1505行) 
 
圖3-14 B_Sysi_Process_Creation.Terminate_Process流程圖 
執行B_Sysi_Process_Creation.Terminate_Process，目的是將現有的process中
止。由上面流程圖可看出，B1-2-5的部分會再細分為B1-2-5-1跟B1-2-5-2兩部分。 
¾ B1-2-5-1：一開始先取得process的ID。 
¾ B1-2-5-2：藉由process ID來得知哪個process要被終止 
  
 30
執行單位：台北大學資訊工程學系 
到此為止B部分則全部結束，繼續回到圖3-3中A部分的A1-5 
(b_sysi_get_automata_database，如圖3-16)，此function會去執行3件事，分別是Load 
num of processes、Load proc_Data和Load files，程式分別會對這三個檔案做開啟、
讀取和關閉的動作來讀取檔案中的資料。 
編號：A1-5 
檔名：b_sysi_ttc_startup.adb 
說明：讀取檔案 
路徑：util\integ\ver7.0.6\main\bsw 
出處：b_sysi_ttc_startup.b_sysi_get_automata_database (參照程式碼第63行到第
76行) 
 
圖3-16 b_sysi_ttc_startup.b_sysi_get_automata_database流程圖 
 32
執行單位：台北大學資訊工程學系 
編號：A1-6 
檔名：b_sysi_ttc_startup.adb 
說明：系統初始化 
路徑：util\integ\ver7.0.6\main\bsw 
出處：b_sysi_ttc_startup. b_sysi_create_processes (參照程式碼第80行到第146行)
圖3-17 b_sysi_create_processes流程圖 
  
 34
執行單位：台北大學資訊工程學系 
編號：A1-6-6-1 
檔名：b_sysi_process_creation.adb 
說明：傳送請求 
路徑：util\integ\ver7.0.6\bsw\system_initialization\process_creation 
出處：b_sysi_process_creation. Send_Process_Creation_Request (參照程式碼第
1046行到第1093行) 
 
圖3-19 B_sysi_process_creation.Send_Process_Creation_Request流程圖 
A1-6-6-1(Send_Process_Creation_Request)的部分： 
¾ A1-6-6-1-1：從B_Prc_Proc_Automata.Get_Creation_Automata_Mailbox_Id中 
取得mailbox ID 
¾ B1-1-4：B_Oss_Inter_Prcs_Mailbox.Put_Message(同圖3-11)。 
  
 36
執行單位：台北大學資訊工程學系 
3.2、Exercise Initialization Algorithm 
 
圖 3-21 Exercise_initializatio 流程圖 
 38
執行單位：台北大學資訊工程學系 
 
圖 3-22 Exercise_initialization(STAGE2)流程圖 
圖 3-22 為 Exercise_initialization(STAGE2)的部分，在執行
Exercise_initialization(STAGE2)前，需要選取此次操演所需要的項目，依序分別
為下列六項： 
1. Choose exercise name 
2. Select consoles 
3. Communication plan 
4. Voice communication units allocation 
5. Plotting Boards and Electronic Display/Units Allocation (PB/EDU) 
6. SACU No. 
當選取完上述 6 項後，系統便開始執行 Exercise_initialization 的部分。執行
Exercise_initialization的目的是為了讓所有參與的 console 能在相同的環境下進行
操演。在 Exercise_initialization 的階段，Main_Computer 跟 Local_Computer 會作
一系列的準備動作，包括資料庫建置、Multicast group 的建置、操演情境準備、
通訊裝置準備、以及狀態轉換。在 Exercise_initialization 的過程中，如果有一個
process 執行失敗，此系統會自動的將目前的狀態轉換回到 Offline 的狀態。也就
是說，當任何一台 controller 或 trainees 在 Exercise_initialization 的過程中沒有在
預定的時間內開啟，這幾台 controller 或 trainees 將無法參與此次的操演。 
在圖 3-22 中，一開始會先由 TTC_MNAGER 裡的 I20 傳送初始化的訊息給
APP_PROC。I21 的部分會負責接收訊息，如果訊息正確，便會執行 I22-I28 的部
分作 Main_Computer 的資料庫和 Multicast group 建置，而 I28 會傳遞初始化的訊
息給 Local_APP。Local_APP 中的 I3 接收到訊息後，便開始執行 I4-I13 的部分作
 40
執行單位：台北大學資訊工程學系 
圖 3-23 Exercise_initialization 流程圖 
 42
執行單位：台北大學資訊工程學系 
圖 3-25 Exercise_initialization(Local_Computer)流程圖 
 44
執行單位：台北大學資訊工程學系 
圖 3-26 Exercise_initialization(Main_Computer)流程圖 
 46
執行單位：台北大學資訊工程學系 
由圖 3-25 的部分可以看出，一開始是由 Local_Computer 的 MMI_OFFLINE
裡的 I1 開始做訊息傳遞(虛線 A)。I1 的部分會傳遞初始化的訊息給
Main_Computer 中的 I15，告知 Main_Computer 裡的 TTC_Manager 可以開始做初
始化的動作。在訊息傳遞的過程中，發送端會傳送一個 Msg_Code 給接收端。由
於 TTC_Manager 會接收到很多種不同的訊息，所以當 I15 接收訊息後，會判斷
是否接收初始化的 Msg_Code，如果是便會開始初始化的動作。 
編號：I15 
檔名：b_sysi_ttc_manager_main.adb 
說明：起始化和處裡訊息 
路徑：util_981127\util\integ\ver7.0.6\main\bsw 
出處：b_sysi_ttc_manager_main (參照程式碼第 60 行到第 87 行) 
 
圖3-27 b_sysi_ttc_manager_main流程圖 
I15的部分(如上圖所示)一開始會先做process的初始化，接著由I15-1的部分
做接收訊息與處理訊息的動作。I15-1裡所負責的部分會包括接下來的I16、I17、
I18和I19，這4個部分都會從I15-1的部分呼叫。最後就取得process的名稱以及
process_id便結束了TTC_MANAGER的初始化部分。 
  
 48
執行單位：台北大學資訊工程學系 
編號：I16 
檔名：b_sysi_ttc_manager.adb 
說明：傳送訊息至 TTC_MANAGER 或幫忙傳送到其他目的地 
路徑：util\integ\ver7.0.6\bsw\system_initialization\ttc_manager 
出處：b_sysi_ttc_manager.Handle_TTC_Msg (參照程式碼第340行到第388行) 
 
圖3-29 b_sysi_ttc_manager.Handle_TTC_Msg流程圖 
I16的部分(如上圖所示)是在對所接收到的訊息做處理。處理的部分分為兩種。
一種是訊息要傳給TTC_MANAGER的，另一種是訊息不是要傳給
TTC_MANAGER的。假如訊息是要傳給TTC_MANAGER的，則會在I16-1的部分
對訊息進行處理的動作。如果訊息不是要傳給TTC_MANAGER，則會在I16-2的
部分協助訊息做傳遞，將訊息傳到正確的位置。表3-3所列出的即為各種不同的
Msg_Code所會對應到的動作。就目前的階段而言，所接收到的Msg_Code是來自
於MMI_OFFLINE，所以對應到的為表3-3中的第一種情況
(CODE_EXERCISE_RQST_STARTUP1/CODE_EXERCISE_RQST_STARTUP2/ 
CODE_COMPLAN_CONFIG_RQST)。 
  
 50
執行單位：台北大學資訊工程學系 
CODE_CONSOLE_FAILED B_Sysi_Handle_Console_Failure.Handle_Failure 
CODE_CHECK_CONSOLE_VALIDITY B_Sysi_S_Ttc_Manager_Services.Check_Console_Vali
dity 
CODE_RQST_LIST_OF_EXERS B_Sysi_S_TTC_Manager_Services.Get_List_Of_Exers 
CODE_GENERAL_RQST_MSG GENERAL_RQST_M
SG.Msg_Code 
來自 MMI 的 GENERAL 
REQUEST 
CODE_GET_FREE_
EXT_DEV 
B_Sysi_S_TTC_Manager_Ser
vices.Get_Free_Ext_Dev       
CODE_RECORDED_
EW_CRAFT_IC_LST
B_Sysi_S_TTC_Manager_Ser
vices.Get_Recorded_Ew_Craft
_Ic_Lst 
CODE_READ_CONFIGURATION_FILE B_Sysi_Overall_Sys_Config.Merge_With_The_File 
CODE_UPDATE_CONFIGURATION_
DB 
B_Sysi_Overall_Sys_Config.Handle_Data_From_Other
_Site 
CODE_INTERSITE_HEARTBEAT B_Sysi_TTC_Mngr_Heartbeat.Handle_Heartbeat_Msg 
CODE_TRANSFER_TO_LIVE B_Sysi_Transfer_To_Live.Handle_Transfer_To_Live_
Msg 
 
  
 52
執行單位：台北大學資訊工程學系 
CODE_EXERCISE_RQST_STARTUP2 和 CODE_COMPLAN_CONFIG_RQST 中
的其中一個，故在 Exercise_initialization 的階段，並不會將 Invalid_Message 設為
TRUE。 
I17-3的部分會判斷Msg_Code是否為CODE_EXERCISE_RQST_STARTUP1。
如果所接收到的 Msg_Code 為 CODE_EXERCISE_RQST_STARTUP1，便會做參
數設定和鎖定資料庫的動作。 
由於在 Exercise_initialization 的階段的部分，I17-2 的部分並不會做
Invalid_Message的設定，故 Invalid_Message仍為FALSE的狀態，所以會執行 I17-5
的部分。 
  
 54
執行單位：台北大學資訊工程學系 
編號：I17-5-4 
檔名：B_Sysi_Exercise_Startup_Req_Handler.adb 
說明：判別 console 狀態 
路徑：util\integ\ver7.0.6\bsw\system_initialization\ttc_manager 
出處：B_Sysi_Exercise_Startup_Req_Handler. Handle_Exercise_Startup_Request 
(參照程式碼第1718行到第1982行) 
Start
Edit_State
MMI
(Invalid_Configuration := 
TRUE;
Send_Msg_To_Requested())
Configuration_Valid
Yes
No
No
Configuration_valid
configuration_valid
No
Health_List_Length /= 0
console MMI
(Invalid_Configuration := TRUE;
Send_Msg_To_Requested())
Yes
No
Invalid_configuration
True
Yes
1
(I17-5-4)B_sysi_e
I17-5-4-1
I18
I19
xercise_startup_req_handler.Handle_Exercise_Startup_Request
Check_Max_Num_Of_Exers
configuration
Yes
console
圖3-32 B_Sysi_Exercise_Startup_Req_Handler.Handle_Exercise_Startup_Request-1
流程圖 
 56
執行單位：台北大學資訊工程學系 
誤以至於沒有在操演的名單裡。故會傳送 console 錯誤的訊息給
MMI_OFFLINE。 
2. Check if the exercise is consistent 
判斷操演是不是 consistent。如果不是，會傳送錯誤訊息給 MMI_OFFLINE。 
3. Check exercise is combined or local 
判斷操演是 combined 所執行的操演，還是只有 Local 所執行的操演。不論
是 combined 或是 local 的情況，都會確認所結合操演的數量是否超過最大的
數量。如果超過最大的數量，則會傳遞錯誤的訊息給 MMI_OFFLINE。 
4. Check the console configuration: 
判斷 console 的 configuration 是不是 invalid。如果是 invalid，則會傳遞錯誤
的訊息給 MMI_OFFLINE。 
5. Check the CIC availability: 
判斷 CIC 的狀態，如果是 invalid，則會傳遞錯誤的訊息給 MMI_OFFLINE。 
6. Check the controller consoles for availability 
判斷 controller 的狀態，如果 controller 的狀態是錯誤的，則會傳遞錯誤的訊
息給 MMI_OFFLINE。 
7. Check the third party 
8. check external det config (if existing 
9. check external dev config 
以上(1)到(9)會依照順序做確認，假如有任何一個configuration為invalid，則
會傳送錯誤訊息給MMI，直到如果所有程序皆為valid，回傳值Configuration_Valid
才為True。如果為True，則會往yes的方向執行。 
在I18中會抓取發生錯誤的console，並在I19中一一的傳送錯誤名單給MMI。接著
在圖3-33中的I17-5-4-2中會傳送以下訊息： 
1. Destination_Host_Id : source_Id 
2. Application_Id : Dummy 
3. Destination_Type : 
B_Sysi_T_Ptp_Message_Types.TTC_MANAGER_TO_MMI_OFFLINE 
4. Msg_Code : 
B_Sysi_S_Ptp_Messages.CODE_MAIN_COMPUTER_RECOMEND 
在 I17-5-4-3 中會傳送以下訊息: 
1. Dest_Host_id : B_Sysi_Host_Types.SITE_1_SERVER_ID 或
B_Sysi_Host_Types.SITE_2_SERVER_ID 
2. Destination_Type : 
B_Sysi_T_Ptp_Message_Types.TTC_MANAGER_TO_TTC_MANAGER 
 
 58
執行單位：台北大學資訊工程學系 
表 3-4 編號 I20-1 的參數設定 
I20-1 的參數設定 
B_Sysi_Overall_Sys_Config.Lock_Shared_Segment 鎖定 shared segment 
B_Sysi_Overall_Sys_Config.Get_Exercise_List 現在正在進行的操演列表 
B_Db_Exercise_Run_Number.Get_Exercise_Run_Number 1.Run_State 或 Live_from_DB  
2. Edit_State 
假如是以上兩種情形中的其中一
種，則會取得操演編號 
Ex_Header.Ex_Run_Number := 1 將 Ex_Run_Number 設為 1，作為
debug 所用 
B_Sysi_Overall_Sys_Config.Get_Free_Application_Id 取得 application id 
Application_Proc_Id  Local_Application_Id 判斷 application_proc_id 為何，並設
定所對應到的 Local_Application_Id 
B_Sysi_Overall_Sys_Config.
B1 
Local_Application_Id := 1
B_Sysi_Overall_Sys_Config.
B2 
Local_Application_Id := 2
B_Sysi_Overall_Sys_Config.
B3 
Local_Application_Id := 3
B_Sysi_Overall_Sys_Config.
T1 
Local_Application_Id := 1
B_Sysi_Overall_Sys_Config.
T2 
Local_Application_Id := 2
others null 
b_sysi_overall_sys_config.Set_Exercise_Info_To_Default(
Exercise_Info) 
Set exercise info to default values 
Exercise_Info.Exercise_Name := Ex_Header.Ex_Name 設定操演資訊 
Exercise_Info.DB_Exercise_Num := 
Get_DB_Exer_Num_By_Name(Ex_Header.Ex_Name) 
Exercise_Info.Initialization_Mode := 
Ex_Header.Init_Mode 
Exercise_Info.Exercise_State := Ex_Header.EX_State 
Exercise_Info.Config := Basic_Configuration 
Exercise_Info.Config.Exercise_Type := 
Ex_Header.Ex_Type 
Exercise_Info.Application_Proc_Id := 
 60
執行單位：台北大學資訊工程學系 
Exercise_Info.Ew_Crafts_IC_Config := 
Ew_Crafts_IC_Config 
儲存 EW crafts 對應到的 IC's 
config (for replay only) 
B_Sysi_Overall_Sys_Config.Set_Exercise_Info  
** 設定控制台的使用率 ** 
對每個 controller console 做以下動作 
F_Controller_List.Num_Of_Controllers := 
Basic_Configuration.Num_Of_Controllers; 
F_Controller_List.Controller_Console_List := 
Basic_Configuration.Controllers_List; 
F_Controller_List.Group_Id := 
B_Sysi_Overall_Sys_Config.Get_New_Group_Name; 
Build the controller list 
B_Sysi_Overall_Sys_Config.Set_Controller_Console_List Set the console list 
B_Sysi_Overall_Sys_Config.Set_Console_Status Set the console status 
B_Sysi_Overall_Sys_Config.Set_Console_Main_Compute
r 
Set the console main computer 
B_Sysi_Overall_Sys_Config.Set_Console_Exercise_Id Set the console exercise Id 
B_Sysi_Overall_Sys_Config.Set_Console_Exercise_Type Set the console exercise type 
B_Sysi_Overall_Sys_Config.Set_Console_Usage_Type Set the console usage type 
**對每個 trainee 做以下動作** 
Trainee_Console_List.Num_Of_Trainees_Per_Craft := 
      
Basic_Configuration.Craft_Allocation_Table(i).Num_Of_
Consoles; 
Trainee_Console_List.MTC_Id := 
     Basic_Configuration.Trainee_Crafts_List.Crafts(i); 
Trainee_Console_List.Trainee_Console_List := 
        
B_Sysi_S_Config_Serv.Unpack_Trainee_Console_List 
Build the trainee console list 
B_Sysi_Overall_Sys_Config.Set_Console_Status Set the console status 
B_Sysi_Overall_Sys_Config.Set_Console_Main_Compute
r 
Set the console main computer 
B_Sysi_Overall_Sys_Config.Set_Console_Exercise_Id Set the console exercise id 
B_Sysi_Overall_Sys_Config.Set_Console_Craft Set the console craft 
B_Sysi_Overall_Sys_Config.Set_Console_Exercise_Type Set the console exercise type 
B_Sysi_Overall_Sys_Config.Set_Console_Usage_Type Set the console usage type 
B_Sysi_Overall_Sys_Config.Set_Trainee_Console_List Set the trainee console list 
**設定第三方使用率** 
B_Sysi_Overall_Sys_Config.Set_Third_Party_Allocation  
 62
執行單位：台北大學資訊工程學系 
編號：I21 
檔名：b_sysi_start_exercise_main.adb 
說明：等待初始化訊息 
路徑：util\integ\ver7.0.6\bsw\system_initialization\exercise_startup 
出處：b_sysi_start_exercise_main.Wait_For_Initialization_Message(參照程式碼第
215 行到第 264 行) 
 
圖3-35 b_sysi_start_exercise_main.Wait_For_Initialization_Message流程圖 
I21的部分(如上圖所示)是在等待I20所傳來的訊息，目的是在告知
APP_PROC的部分可以開始執行。由上圖可以看出，APP_PROC會不斷的接收訊
息，所以會一直在迴圈中進行判斷，判斷所得到的訊息是否為目前
Exercise_initialization階段的初始化訊息，當接收到的訊息正確時，便開始進行
APP_PROC的部分。 
上圖中的I21-1為接收訊息的部分，接收SOCKET所傳來的訊息後，即進行判
斷，判斷所傳來的Msg_Code是否為CODE_APP_MAIN_STARTUP。如果接收到
的訊息是CODE_APP_MAIN_STARTUP，則取得此次操演的exercise run number，
且可以繼續執行I22~I32的部分。如果所得到的Msg_Code不是
CODE_APP_MAIN_STARTUP，以目前Exercise_initialization的階段而言，I21的
部分會繼續的等待，直到Msg_Code為CODE_APP_MAIN_STARTUP。下面的部
分為I21-1接收訊息的部分。 
 64
執行單位：台北大學資訊工程學系 
另外，以此部分的 Msg_Destination 來說，只有三種發送的情況，此三種情
況如下表所示： 
表 3-5、編號 I21Msg_Destination 的三種情況 
Msg_Buffer 中的發送端及接收端 
Msg_Destination(來源_TO_目的)： 
Local_APP_TO_APP TTC_MANAGER_TO_APP MMI_OFFLINE_TO_APP
 
在接收到正確的訊息之後，接著會進行參數的設定。所有參數的設定都是為
了之後操演做準備。設定的部分都列於下表： 
表 3-6、參數設定的情況 
Function Name 說明 
1. Get_Exercise_Configuration 先將資源設為拒絕存取的狀態
(semaphore op=-1)，之後便開始取得
Exercise_Id 和 Exercise_Info，取得到所
需的資料後，便開放存取(semaphore 
op=1)。 
2. Set_System_State 將輸入的 System_State、System_Mode
分別指派給 Current_System_State、
Current_System_Mode。 
3. Set_Exercise_Run_Number 將 Exercise_No 指派給
Current_Exercise_Run_No。 
4. Set_DB_Exercise_Num 將 Exercise_No 指派給
Current_DB_Exercise_Num 
5. Prepare_Console_List 將所有的 controller 跟 trainee 加入到
console_list 中，並計算
Exercise_Num_Of_Consoles 數量。 
6. Set_Exercise_App_Config 將 Exercise_App_Config 的值指派給
Curr_Exercise_App_Config 
 
  
 66
執行單位：台北大學資訊工程學系 
I22為資料庫的部分(如上圖所示)。在建置資料庫的一開始會先判斷目前系統
的Exercise_State為哪種狀態，依據Exercise_State的不同會執行不同部分的程式。
Exercise_State的種類有4種，分別為Off-line state、Edit state、Run state跟Replay 
state。Off-line state為系統預設的狀態，當最初系統開啟的時候，即為Off-line state。
Edit state是在做編輯的動作，為操演前的準備動作。此外，Edit state只會在教官
台執行。Run state的部分會做操演清單的選取，選取這次操演所要的情境並執行
操演。由下面的表3-7可清楚的看出每一種System States都有對應到不同的
Initialization modes跟Execution Modes。以目前Exercise_initialization的階段而言，
所執行的部分是屬於Run state裡的LIVE_FROM_DB。這部分主要會取得此次操
演所需的資料並且將這些資料存於Global Data File中，以供Local Computer使
用。 
表3-7、System States所對應到的Initialization Modes跟Execution Modes 
System States Initialization Modes Execution Modes 
Off-line state N/A Database 
Maintenance 
Transition 
Edit state From-Db High-exercise-rate 
Low-exercise-rate 
Normal-exercise-rate 
Freeze-exercise 
Full-exercise-jump 
Run state Live-from-db 
Live-from-replay 
Live-from-recovery 
High-exercise-rate 
Low-exercise-rate 
Normal-exercise-rate 
Freeze-exercise 
Full-exercise-jump 
Replay state Normal-replay 
 
High-replay-rate 
Low-replay-rate 
Normal-replay-rate 
Freeze-replay 
Replay-jump 
Debrief-reports 
 
  
 68
執行單位：台北大學資訊工程學系 
編號：I22-2 
檔名：b_sysi_start_exercise_main.adb 
說明：創造 Global Data Files 
路徑：util\integ\ver7.0.6\bsw\system_initialization\exercise_startup 
出處：b_sysi_start_exercise_main.Create_GD_Files(參照程式碼第364行到第381
行) 
 
圖3-39 b_sysi_start_exercise_main.Create_GD_Files流程圖 
I22-2的部分(如上圖所示)會先創造出一個Global Data File的名字，並將剛剛
從資料庫中所得到的資訊存入所創造的Global Data File Name中。資料的儲存動
作為I23的部分。 
  
 70
執行單位：台北大學資訊工程學系 
編號：I23-1 
檔名：B_Rec_Gld_Modification_Tracking.adb 
說明：依照 Function Id 的不同給予指定位置跟大小 
路徑：util\integ\ver7.0.6\bsw\record\glb_data_handling 
出處：B_Rec_Gld_Modification_Tracking.Get_Function_GD_Address_And_Size 
(參照程式碼第209行到第321行) 
圖3-41 b_sysi_handle_global_data_files.Update_Function_Gd_In_File流程圖 
檔名：b_rec_gld_modification_tracking.adb 
路徑：\util\integ\ver7.0.6\bsw\record\glb_data_handling\b_rec_gld_modification_tracking.adb
出處：此程式總共 632 行，以下片段是在第 221 行~第 241 行 
<以上略> 
case Function_Id is 
      when B_RR_T_Ids_Msg.DYNAMICS => 
        if Is_Constant then 
          Buffer_Address := G_D_Dyn.Get_Database_Address; 
 72
執行單位：台北大學資訊工程學系 
編號：I23-2 
檔名：b_sysi_start_exercise_main.adb 
說明：指定地圖檔案路徑 
路徑：util\integ\ver7.0.6\bsw\system_initialization\exercise_startup 
出處：b_sysi_start_exercise_main.Unzip_Map_File(參照程式碼第489行到第531
行) 
圖3-42 b_sysi_start_exercise_main.Unzip_Map_File流程圖 
I23-2的部分會開啟此次操演所用的地圖，在上圖的流程圖中，一開始先取
得地圖的名稱，之後判斷CALC_MAPS_DIR裡，有沒有符合此次操演名稱的地圖
檔案。如果有在CALC_MAPS_DIR所對應到的路徑裡，則會開啟此次操演的地圖。
如果沒有，則由指定路徑找尋正確的檔案，並開啟。 
  
 74
執行單位：台北大學資訊工程學系 
I23-3的部分是在做狀態的轉換，狀態的轉換有兩種情況，分別是 
A. OFFLINE_STATE轉成ONLINE_STATE 
B. ONLINE_STATE轉成OFFLINE_STATE 
由程式片段3-5可知，I23-3的部分是將OFFLINE_STATE轉成
ONLINE_STATE的情況，並且是處於STAGE1的情形。I23-3-1的部分為轉換到
ONLINE_STATE的部分。當狀態轉換到ONLINE_STATE後，便會將舊的process
的刪除以及將新的process初始化。 
  
 76
執行單位：台北大學資訊工程學系 
I23-3-1的部分(如上圖所示)一開始會先做System_State的設定，將狀態設為
online的狀態。之後依據程式片段3-5中的程式所示，往STAGE1執行。I23-3-1-1
的部分會將不參與這次操演的Offline State process刪除掉，目的是要確定所有的
process都是這次操演所需的process。 
I23-3-1-2的部分是將所有的process重新初始化，目的是為了確認所有的
process可以互相溝通，程式碼如程式片段3-6所示。I23-3-1-2會呼叫I23-3-1-2-1。
在程式片段3-6程式碼的部分可看出I23-3-1-2-1會將System_Creation_Initialization
設為FALSE。System_Creation_Initialization設為FALSE會影響到之後的程式會不
會執行。後面的地方會說明I23-3-1-2-1的部分。 
檔名：b_sysi_handle_state_transition.adb 
路徑：util\integ\ver7.0.6\bsw\system_initialization\state_transition\b_sysi_handle_state_transition.adb
備註：此程式總共 480 行，以下片段是在第 52 行~第 68 行 
<以上略> 
procedure Reinitiate_Process ( 
New_State : in B_Prc_Proc_Automata.Process_State_Type 
) is 
begin 
<<I23-3-1-2-1>> 
  B_Sysi_Process_Creation.Initiate_Process ( 
   Internal_Pid                   => B_Prc_Process_Data.Internal_Pid, 
   System_Creation_Initialization => FALSE 
  ); 
 
  exception 
    when others => 
      B_Prc_TTC_Util.Exception_Log ( 
        Unit_Name      => "b_sysi_handle_state_transition.reinitiate_process", 
        Exception_Name => Current_Exception.Exception_Name); 
      raise; 
end Reinitiate_Process; 
<以下略> 
程式片段3-6  b_sysi_handle_state_transition. Reinitiate_Process 
  
 78
執行單位：台北大學資訊工程學系 
表3-8 記憶體大小以及位置的存取表 
Shared_Memory_Name Segment_Size Address 
SYSTEM_CONFIGURATIO
N_SHARED_MEMORY 
b_sysi_overall_sys_config.Get_Databas
e_Size 
b_sysi_overall_sys_config.Se
t_Structure_Pointer(Address) 
MMI_ONLINE_GRAPHICS
_SHARED_MEMORY 
A_MMI_S_Handle_Shared_Mem.Get_
Graphic_Data_Size 
A_MMI_S_Handle_Shared_
Mem.Set_Graphics_Address 
(Address) 
AN_APPLICATION_SHAR
ED_MEMORY 
A_MMI_S_Handle_Shared_Mem.Get_
XTerminal_Data_Size 
A_MMI_S_Handle_Shared_
Mem.Set_XTerminal_Addres
s (Address) 
LIB_MMI_SHARED_MEM
ORY  
A_MMI_S_Handle_Shared_Mem.Get_
Library_Data_Data_Size 
A_MMI_S_Handle_Shared_
Mem.Set_Library_Data_Addr
ess (Address) 
TO_FLAG_SHARED_MEM
ORY 
B_Prc_To_Handling.Get_Shared_Mem
ory_Size; 
B_Prc_To_Handling.Set_Sha
red_Memory_Ptr (Address) 
PAGES_INSERT_SHARED_
MEMORY 
B_Rec_S_Pages_Insert.Get_Database_
Size 
B_Rec_S_Pages_Insert.Set_
Data_Pointer (Address) 
 
I23-3-1-2-1-3的部分是在做mailbox部分的建置，同樣的，如果有old state 
process佔用到了new state process的mailbox空間，那I23-3-1-2-1-3的部分會將占用
到的部分做刪除的動作。處理完刪除的動作後，便會針對mailbox裡所有的mailbox 
id指定到適當的位子，如表3-9所示。 
表3-9 Mailbox位置的存取表 
Mailbox_Name Place 
MMI_TO_APP_MAILBOX B_Prc_Process_Data.MMI_TO_APP  
APP_TO_MMI_MAILBOX B_Prc_Process_Data.APP_TO_MMI  
MMI_TO_SDE_MAILBOX B_Prc_Process_Data.MMI_TO_SDE  
SDE_TO_MMI_MAILBOX B_Prc_Process_Data.SDE_TO_MMI  
APP_TO_AN_MAILBOX B_Prc_Process_Data.APP_TO_AN  
AN_TO_APP_MAILBOX B_Prc_Process_Data.AN_TO_APP  
TOH_TO_APP_MAILBOX B_Prc_Process_Data.TOH_TO_APP  
OFF_WAIT_POINT_MAILBOX B_Prc_Process_Data.OFF_WAIT_POINT  
SDE_WAIT_POINT_MAILBOX B_Prc_Process_Data.SDE_WAIT_POINT  
 80
執行單位：台北大學資訊工程學系 
編號：I24 
檔名：b_sysi_start_exercise_main.adb 
說明：創建 Automata 
路徑：util\integ\ver7.0.6\bsw\system_initialization\exercise_startup 
出處：b_sysi_start_exercise_main.Create_Automata(參照程式碼第 680 行到第 694
行) 
end
Start
(I24)b_s
I9
ysi_start_exercise_main.create_automata
Automata
(B_Prc_Task_Control.Create_Task_Automata)
 
圖 3-46 b_sysi_start_exercise_main.create_automata 流程圖 
I24 的部分是在做 Task 設定，將所有有參與這次操演的 Task 做順序的編排。
在 Exercise_initialization 的階段，Local_Computer 的 I9 和 Main_Computer 的 I24
都會做 create automata 的動作。Create automata 所呼叫的程式都是同一支程式，
所以在上圖會有呼叫 I9 的動作。由上面流程圖的部分可看出，I24 會呼叫 I9 的
部份去執行 Task 的設定。I9 的部分主要是在對每個 Task 執行一次 I9-1 的動作。
假如有 N 個 Task，那麼前 N-1 個 Task 會在 initial 的模式下進行，而最後一個
Task 會在 regular 模式下進行。 
  
 82
執行單位：台北大學資訊工程學系 
編號：I9-1 
檔名：B_Prc_Task_Control.adb 
說明：初始化 Task 的各種訊息 
路徑：util\integ\ver7.0.6\bsw\process_control\task_control 
出處：B_Prc_Task_Control.Take (參照程式碼第 41 行到第 179 行) 
圖 3-48 B_Prc_Task_Control.Take 流程圖 
I9-1 的部分如上圖所示，在一開始會先抓取三個部分的 ID，分別為： 
1. 目前 task 的 ID 
2. 目前 task 的 Mailbox ID(I9-1-1) 
3. 下一個 task 的 ID 
 84
執行單位：台北大學資訊工程學系 
編號：I9-2 
檔名：B_Prc_To_Handling.adb 
說明：處理 Process 
路徑：util\integ\ver7.0.6\bsw\process_control\task_control 
出處：B_Prc_To_Handling.Create_TO_Handling (參照程式碼第 143 行到第 211
行) 
圖 3-49 B_Prc_To_Handling.Create_TO_Handling 流程圖 
 86
執行單位：台北大學資訊工程學系 
圖 3-51 Local Computer Process Automata 
編號：I25 
檔名：b_sysi_start_exercise_main.adb 
說明：創造 Muitlcast Group 
路徑：util\integ\ver7.0.6\bsw\system_initialization\exercise_startup 
出處：b_sysi_start_exercise_main.Create_Multicast_Group(參照程式碼第 769 行
到第 788 行) 
Start
End
(I25)b_s
I25-1
ysi_start_exercise_main.Create_Multicast_Group
Multicast Group
(B_Bswa_Handle_Net_Comm_Msgs.Create_Multicast_Group)
 
圖3-52 b_sysi_start_exercise_main.Create_Multicast_Group流程圖 
  
 88
執行單位：台北大學資訊工程學系 
編號：I25-1 
檔名：b_bswa_handle_net_comm_msgs.adb 
說明：建立 MulticastGroup 
路徑：util\integ\ver7.0.6\bsw\bsw_applications\handle_net_comm_msgs 
出處：b_bswa_handle_net_comm_msgs.Create_Multicast_Group(參照程式碼第
2622行到第2706行) 
圖3-54 b_bswa_handle_net_comm_msgs.Create_Multicast_Group流程圖 
I25-1的部分(如上圖所示)是在建置一個Multicast_Group給所有console做加
入的動作，加入後才可以做溝通的動作。I25-1的一開始會先設定Group_Name，
接著由I25-1-1的部分得到所有這次操演的console清單，此清單會傳給每一台
console。I25-1-2的部分會作加入Multicast_Group的動作，加入Multicast_Group後
才能讓console跟console、controller跟controller之間做溝通。當加入完成，便由
I25-1-3的部分判斷所加入的Multicast_Group是GLOBAL_GROUP還是
LOCAL_GROUP。GLOBAL_GROUP為所有console所必須加入的GROUP，而
LOCAL_GROUP是針對controller跟controller之間所作的加入。 
 90
執行單位：台北大學資訊工程學系 
編號：I27-1 
檔名：B_Sysi_Handle_Global_Data_Files.adb 
說明：更新 Globe Data File 
路徑：util\integ\ver7.0.6\bsw\system_initialization\exercise_startup 
出處：B_Sysi_Handle_Global_Data_Files.Update_Function_Gd_In_File(參照程式
碼第151行到第260行) 
圖3-56 b_sysi_handle_global_data_files.Update_Function_Gd_In_File流程圖 
I27-1的部分(如上圖所示)為資料更新的動作。在一開始會先判斷目前的
Function Id是否為第一項，如果不為第一項，則會依序的計算各個項目的位置。
計算完後，即將Global Data File開啟且權限為O_WRONLY的權限(O_WRONLY
為可以寫入資料的權限)。開啟檔案後，由I23-1的部分取得non constant跟constant
的buffer size跟buffer address。並在I27-2的部分將更新的資訊寫入。寫入之後即使
用函式close做關閉檔案的動作。 
  
 92
執行單位：台北大學資訊工程學系 
I28(如上圖所示)的部分是要將 Initialization_Message 傳送給 Local_Computer，
訊息傳送的部分如圖 3-24 的虛線 F。在 I28 的部分會預設 Master_Slave_Scheme
為 False，並在一開始做一些判斷(I28-1、 I28-2、I28-3、I28-4、I28-5、I28-6、I28-7)，
有符合的部分才會作執行的動作。 
z I28-1：如果目前的System_State為Replay_State且Exercise_Type為Combined
以及 controller 的數量大於、等於 2，以上這三種條件都符合的話，就會將
Master_Slave_Scheme 設為 True。就目前 Exercise_Initialization 的狀況而言，
System_State 為 Run_State，故此 if 判斷不會執行，Master_Slave_Scheme 仍
然為 False。 
z I28-2：判斷 Master_Slave_Scheme，如果 Master_Slave_Scheme 是 True 就會
執行 Prepare_VP_File 的部分。Prepare_VP_File 是在做 VP 檔案的準備，以
供 VAPS 作連結使用。 
z I28-3：為外部裝置的判斷，如果有外部裝置，就會執行此部分。 
z I28-4：執行 controller部分的迴圈，在此迴圈中會設定誰為Master，誰為Slave。
並會對 controller 作一系列的判斷，判斷是否有所對應到的裝置，如果有，
就會回傳所屬得 Msg_Code 給 Local_Computer。可能的 Msg_Code 如表 3-11
所示。 
z I28-5：設定 App 的部分 
z I28-6：執行 trainee 部分的迴圈，在這個迴圈中，會對 trainee 作一系列的判
斷，判斷是否有所對應到的裝置，如果有，就會回傳所屬得 Msg_Code 給
Local_Computer。可能的 Msg_Code 如表 3-11 所示。 
z I28-7：如果 craft 沒有對應到任何一台 console，則會在 I28-7 的部分進行 craft
的配置動作。 
就 controller 跟 trainee 迴圈的部分而言，在迴圈裡面會判斷有沒有其他的外
部裝置，如果有，就會給予特定的 Msg_Code，並將所得到的 Msg_Code 傳給
Local_Computer。這部分得到的所有 Msg_Code 列於下表供參考。(斜體部分為有
特定外部裝置所得到的 Msg_Code。其餘的部分為一定會傳送的 Msg_Code。) 
 
表 3-11 Controller 跟 Trainee 的 Msg_Code 
Msg_Code for Controller Msg_Code for Trainee 
CODE_LOCAL_EXERCISE_STARTUP CODE_LOCAL_EXERCISE_STARTUP 
CODE_EXERCISE_STARTUP2 CODE_EXERCISE_STARTUP2 
CODE_EXT_CC_CONFIG CODE_EXT_CC_CONFIG 
CODE_EXT_DET_CONFIG CODE_EXT_DET_CONFIG 
CODE_EX_CONFIG_RQST_FINISHED  CODE_EXT_DEV_CONFIG 
CODE_EX_CONFIG_RQST_FINISHED  
 
  
 94
執行單位：台北大學資訊工程學系 
I29 的部分(如上圖所示)是在等待所有有參與操演的 console 傳遞訊息，讓
Main_Computer得知目前每一台 console的狀況。訊息是由圖 3-24中的 I13傳來，
訊息的傳遞為虛線 G 的部分。 
一開始在 I29-1 的部分會將所有 console 的 Host_Answer_List 設為 False，接
著，由於 I29 的部分會接收到所有 console 的訊息，故會在 loop 迴圈中不斷的重
覆執行。在 loop 迴圈中，一開始會先取得 I13 傳來的訊息，得到訊息後，由 I29-2
的部分判斷所收到的訊息是否正常，如果正常即往 I29-3 的方向執行。假如接收
的訊息有問題，則往 I29-4 的部分執行。 
I29-3 的部分是在確認所接收到的 Msg_Code 是否為
CODE_LOCAL_EXER_TERMINATION，如果得到的 Msg_Code 是
CODE_LOCAL_EXER_TERMINATION，則會將 Host_Answer_List 設為 True。
表示已經接收到 console 初始化結束的訊息。如果所接收到的 Msg_Code 不為
CODE_LOCAL_EXER_TERMINATION，則繼續回到 loop 執行。 
假如所接收到的訊息有問題，在 I29-4 的部分會做紀錄，所以每失敗一次，
To_Counter 的值就會增加。最後執行 I29-5 的部分，作失敗的處理。 
  
 96
執行單位：台北大學資訊工程學系 
編號：I30 
檔名：b_sysi_start_exercise_main.adb 
說明：初始化通訊傳輸裝置 
路徑：util\integ\ver7.0.6\bsw\system_initialization\exercise_startup 
出處：b_sysi_start_exercise_main.Initialize_Serials(參照程式碼第 1288 行到第
1311 行) 
 
圖 3-60 b_sysi_start_exercise_main.Initialize_Serials 流程圖 
I30 的部分(如上圖所示)是在做第三方的控制。假如有第三方的加入，便會
在 I30-1 的部分做訊息的控制，並建立第三方的連線，將第三方的裝置及動作傳
送給 Serial Manager，由 Serial Manager 進行操控。 
  
 98
執行單位：台北大學資訊工程學系 
編號：I31(I23-3-1) 
檔名：b_sysi_handle_state_transition.adb 
說明：轉為 Online State 
路徑：util\integ\ver7.0.6\bsw\system_initialization\state_transition 
出處：b_sysi_handle_state_transition.Transfer_To_Online_State(參照程式碼第 287
行到第 364 行) 
圖 3-62 b_sysi_handle_state_transition.Transfer_To_Online_State 流程圖 
I31 的部分(如上圖所示)為 Terminate offline processes and create online 
processes。這部分呼叫的程式跟 I23-3-1 的部分一樣，但是所要執行的部分及目
的是不相同的。程式片段如下面的程式片段 3-7 所示。和 I23-3-1 不同的地方是
I28 會執行 STAGE2 的部分而非 I23-3-1 的 STAGE1。 
 100
執行單位：台北大學資訊工程學系 
編號：I32 
檔名：b_sysi_start_exercise_main.adb 
說明：傳送初始化結束訊息給 Local 端 
路徑：util\integ\ver7.0.6\bsw\system_initialization\exercise_startup 
出處：b_sysi_start_exercise_main.Send_Startup_Termination_To_Locals(參照程式
碼第1343行到第1365行) 
 
圖 3-63 b_sysi_start_exercise_main.Send_Startup_Termination_To_Locals 流程圖 
I32 的部分(如上圖所示)會將 APP_PROC 初始化結束的訊息傳送給
LOCAL_APP，LOCAL_APP 裡的 I14 會負責接收此訊息，訊息傳遞的部分如    
圖 3-24 的虛線 H。由於初始化結束的訊息要傳送給 Local_Computer 裡的每一個
console，故在圖 3-63 中會不斷的執行迴圈的部分，且不斷的發送訊息。這部分
的 Msg_Code 為 CODE_EXERCISE_ST_TERMINATION。當 Local_Computer 的
console 接收到 CODE_EXERCISE_ST_TERMINATION 的訊息後，就會知道初始
化已經結束，並等待操演開始。 
 
 102
執行單位：台北大學資訊工程學系 
編號：I3 
檔名：b_sysi_start_exercise_local.adb 
說明：根據收到的訊息初始化各種參數 
路徑：util\integ\ver7.0.6\bsw\system_initialization\exercise_startup 
出處：b_sysi_start_exercise_local.Wait_For_Initialization_Message (參照程式碼第
139 行到第 324 行) 
圖3-65 b_sysi_start_exercise_local.Wait_For_Initialization_Message流程圖 
 104
執行單位：台北大學資訊工程學系 
2. CODE_GET_HEALTH_STATUS：回報每一台console的健康狀況，假設
有一台console已經當機了，就會將系統當機的狀態傳回給
TTC_MANAGER。 
3. CODE_GET_CONFIGURATION：將一些Configuration傳到
MMI_OFFLINE。詳細的參數如下： 
 
表3-13  CODE_GET_CONFIGURATION部分的參數設定 
參數設定 
GET_CONFIGURATION.Current_Site := B_Sysi_Local_Config.Get_Current_Site; 
GET_CONFIGURATION.Site_1_Host_Id := B_Sysi_Host_Types.SITE_1_SERVER_ID; 
GET_CONFIGURATION.Site_2_Host_Id := B_Sysi_Host_Types.SITE_2_SERVER_ID; 
GET_CONFIGURATION.Current_Host_Id := B_Sysi_Local_Config.Get_My_Host_Id; 
 
4. CODE_START_EDIT_MODE：如果Msg_code為
CODE_START_EDIT_MODE的時候，則會呼叫到這個部分並設定
Exercise_State，代表目前的狀態是在EDIT State。且此CASE不會同時和
CODE_LOCAL_EXERCISE_STARTUP執行(在同一次操演當中)，因為
他們分別設定Exercise_State為不同的狀態。 
5. CODE_EXERCISE_STARTUP2：設定一個變數。 
6. CODE_EXT_CC_CONFIG：設定一個變數。 
7. CODE_EXT_DET_CONFIG：如果有外部偵測裝置，就會對本機的DB
做一些設定(External Detection Configuration) 
8. CODE_EXT_DEV_CONFIG：如果有外部裝置，如PB、SACU、EDU，
就會設定此部分的變數。轉換成EXT_DEV這個模式。 
9. CODE_EX_CONFIG_RQST_FINISHED：表示Msg_Code的部分已經執
行完成，並離開switch_ case的迴圈判斷。 
  
 106
執行單位：台北大學資訊工程學系 
部分就會執行不同的事項。根據圖3-24所示，目前Exercise_initialization的階段，
I3所接收到的訊息是來自於TTC_MANAGER(B)跟APP_PROC(F)這兩端。下表所
列出的即為Get_EX_M_Message裡所有可能的傳送端資訊： 
 
表3-14  b_sysi_s_local_app_ptp_intrf中Msg_Destination的四種情況 
Get_EX_M_Message中的所有發送端及接收端 
Msg_Destination(來源_TO_目的)： 
LOCAL_APP LOCAL_APP_TO_TTC_MANAGER  
LOCAL_APP_TO_APP  
LOCAL_APP_TO_LOCAL_APP  
LOCAL_APP_TO_MMI_OFFLINE 
TTC_MANAGER TTC_MANAGER_TO_TTC_MANAGER  
TTC_MANAGER_TO_LOCAL_APP  
TTC_MANAGER_TO_APP  
TTC_MANAGER_TO_MMI_OFFLINE 
APP APP_TO_LOCAL_APP 
APP_TO_MMI_OFFLINE 
MMI_OFFLINE MMI_OFFLINE_TO_APP 
MMI_OFFLINE_TO_LOCAL_APP 
MMI_OFFLINE_TO_TTC_MANAGER 
 
I4的部分會判斷信息是否從TTC_MANAGER傳送來的，如果確定訊息是由
TTC_MANAGER傳來(虛線C)，此時的Msg_code就會是
CODE_GET_HEALTH_STATUS，在這部分會取得目前系統的狀態是否正常，並
將系統的狀況傳回給TTC_MANAGER。但如果訊息不是由TTC_MANAGER傳來
的，那就會執行一些變數的設定，以供之後使用。變數的設定依序列於下表所示： 
  
 108
執行單位：台北大學資訊工程學系 
編號：I6 
檔名：B_bswa_handle_net_comm_msgs.adb 
說明：建立 MemberList 及建立 MulticastGroup 
路徑：util\integ\ver7.0.6\bsw\bsw_applications\handle_net_comm_msgs 
出處：B_bswa_handle_net_comm_msgs.Join_Multicast_Group (參照程式碼第
2794行到第2710行) 
 
圖3-67 B_bswa_handle_net_comm_msgs.Join_Multicast_Group流程圖 
I6的部分(如上圖所示)是將需要參與此次操演的console加入到console_list中。
I7(如圖3-69所示)則是將需要參與此次操演的controller加入到console_list，由於
controller也是要加入到console_list中，故會在I7的部分再次的呼叫I6。把這些要
參與操演的console加入，才能讓彼此可以互相溝通。 
每當有一個controller要加入，Num_Of_Consoles的數量就需加1。在I6的一開始會
 110
執行單位：台北大學資訊工程學系 
編號：I7 
檔名：b_sysi_start_exercise_local.adb 
說明：將本機及教官台加入 MulticastGroup 
路徑：util\integ\ver7.0.6\bsw\system_initialization\exercise_startup 
出處：b_sysi_start_exercise_local.Join_Controller_Multicast_Group(程式碼第1091
行到第1122行) 
 
圖 3-69 b_sysi_start_exercise_local.Join_Controller_Multicast_Group 流程圖 
I7的部分是在將要參與操演的教官台加入到操演所設的Multicast_Group中。
所以在一開始會將需要參與此次操演的 controller 加入到 console_list，再由 I6 作
加入的動作。 
  
 112
執行單位：台北大學資訊工程學系 
<以下略> 
程式片段3-8  b_sysi_start_exercise_local.adb  
 程式片段3-8的部分與先前介紹的部份相似，差別在於一邊是對
Main_Computer的部分作狀態的轉換，這邊是對Local_Computer作狀態的轉換。 
  
 114
執行單位：台北大學資訊工程學系 
編號：I10 
檔名：b_sysi_start_exercise_local.adb 
說明：建立 Trainee 的 MulticastGroup 
路徑：util\integ\ver7.0.6\bsw\system_initialization\exercise_startup 
出處：b_sysi_start_exercise_local.Create_Trainee_Craft_Multicast_Group (參照程
式碼第1643行到第1651行) 
Start
(I10)b_sysi_start_exercise_local.Create_Trainee_Craft_Multicast_Group
trainee 
console
Yes
執行單位：台北大學資訊工程學系 
End
Trainee Multicast_Group
(Create_Trainee_Craft_Multicast_Group) No
 
圖3-72 b_sysi_start_exercise_local.Create_Trainee_Craft_Multicast_Group流程圖 
I10 的部分(如上圖所示)為建立 Multicast Group 的部分，所建立的 Multicast 
Group 是要給共同控制同一台 Craft 的 Console 加入。由於，每一台 Craft 可能由
數台 console 控制，故操控同一台 Craft 的 Console 需要被加入到同一個 Multicast 
Group 中。所以在一開始就會判斷目前的 console 是否為 trainee console(MTC 或
STC)，如果是的話，MTC 跟 STC 可以作建立 Multicast Group 跟加入 Multicast 
Group 的動作。 
  
 116
編號：I11(I23-3-1) 
檔名：b_sysi_handle_state_transition.adb 
說明：將狀態轉換為 Online 
路徑：util\integ\ver7.0.6\bsw\system_initialization\state_transition 
出處：b_sysi_handle_state_transition.Transfer_To_Online_State(參照程式碼第 287
行到第 364 行) 
 
圖 3-74  b_sysi_handle_state_transition.Transfer_To_Online_State 流程圖 
I11 的部分(如上圖所示)為 Terminate offline processes and create online 
processes。這部分呼叫的程式跟 I23-3-1 的部分一樣，但是所要執行的部分及目
的是不相同的。程式片段如下面的程式片段 3-9 所示。和 I23-3-1 不同的地方是
I11 會執行 STAGE2 的部分而非 I23-3-1 的 STAGE1。 
 118
執行單位：台北大學資訊工程學系 
編號：I12 
檔名：b_sysi_start_exercise_local.adb 
說明：等待 MMI Online Process 結束初始化的動作 
路徑：util\integ\ver7.0.6\bsw\system_initialization\exercise_startup 
出處：b_sysi_start_exercise_local.Wait_MMI_Termination_Msgs (參照程式碼第
973行到第1011行) 
 
圖 3-75 b_sysi_start_exercise_local.Wait_MMI_Termination_Msgs 流程圖 
I12的部分(如上圖)是在等待從MMI_OFFLINE傳來的訊息，假如訊息是從
MMI_OFFLINE傳來的，並且Msg_Code為CODE_MMI_END_INT，就表示
MMI_OFFLINE結束初始化的動作了。假如所得到的訊息不是MMI_OFFLINE傳
送的或是Msg_Code不是CODE_MMI_END_INT，則I12的部分會一直等待，直到
所接收到的訊息是所需要的。 
  
 120
執行單位：台北大學資訊工程學系 
編號：I14 
檔名：b_sysi_start_exercise_local.adb 
說明：等待初始化結束的訊息 
路徑：util\integ\ver7.0.6\bsw\system_initialization\exercise_startup 
出處：b_sysi_start_exercise_local.Wait_Exercise_Initialization_Termination (參照
程式碼第936行到第969行) 
 
圖3-77 b_sysi_start_exercise_local.Wait_Exercise_Initialization_Termination流程圖 
I14的部分(如上圖所示)是在等待I32所傳來的訊息，這部分的訊息傳遞如  
圖3-24的虛線H。I14的部分會呼喚I3-1的部分來取得訊息，訊息內容包括
Sending_Host、Sending_Process和Msg_Code，直到抓取到的Msg_Code為
CODE_EXERCISE_ST_TERMINATION。如果Msg_Code是
CODE_EXERCISE_ST_TERMINATION，則結束Local_Computer的初始化，並等
待操演開始。否則會不斷的在迴圈中抓取訊息。 
 
 
3.3、變數對照表(data type) 
 
 122
執行單位：台北大學資訊工程學系 
 124
Argc Integer 
b_oss_inter_prcs_mail
box.adb 
Create_Mailbox 
Msgq_Id Integer 
Error_Code Errno.Error_Codes 
count Integer 
Mailbox_Key Mailbox_Key_Type 
Mailbox  Mailbox_Type 
Put_Message 
Mailbox Mailbox_Type 
Message String 
Priority B_OSS_Priority_T.Priority_Type 
Result Integer 
// Msg_Buff Msg_Buff_Type 
Get_Message 
Mailbox Mailbox_Type 
Wait_Time Wait_Time_Type 
Buffer String 
Buffer_Length Positive 
Message_Priority(local) B_OSS_Priority_T.Priority_Type 
Result Get_Message_Result_Type 
Msg_Length Integer 
Msg_Flag Integer := 0 
Get_Message 
Mailbox Mailbox_Type 
Wait_Time Wait_Time_Type 
Buffer String 
 Buffer_Length Positive 
 Result Get_Message_Result_Type 
Message_Priority Priority_Type 
Open_Mailbox Mailbox_Key Mailbox_Key_Type 
 126
num_of_proc_name  (local) string 
proc_data_name        (local) string 
files_name                 (local) string 
num_of_proc_file      (local)    file_type 
proc_data_file          (local) file_type 
files_file                     
(local) 
file_type 
file_name_s                (local) A_Strings.a_string 
Set_Automata_Address address system.address 
b_prc_proc_automata.a
ds 
  AUTOMATA_MAILBOX_KEY constant B_Oss_Inter_Prcs_Mailbox.Mailbox_Key_Type := 
20000 
  AUTOMATA_CREATION_MAILBO
X_KEY  
constant B_Oss_Inter_Prcs_Mailbox.Mailbox_Key_Type := 
20001 
b_sysi_process_creatio
n.adb 
Create_Process 
Internal_Pid B_Prc_Proc_Automata.Process_Id_Type 
Return_Process_Status B_Prc_Proc_Automata.Return_Process_Status_T 
Is_Slave Boolean 
Is_Master Boolean 
Send_Process_Creation_Request 
Internal_Pid B_Prc_Proc_Automata.Process_Id_Type 
Is_Slave Boolean := FALSE 
Is_Master Boolean := FALSE 
Restart_Flag Boolean 
Creation_Process_Request B_Prc_Proc_Automata.Creation_Process_Request_Type 
Automata_Mailbox_Id B_Oss_Inter_Prcs_Mailbox.Mailbox_Type 
Mbox_Id Integer 
Msg_Buffer String 
Wait_Return_Status 
Return_Process_Status B_Prc_Proc_Automata.Return_Process_Status_T 
Msg_length Positive 
 128
Extra_Num_Of_Args Integer 
TTC_DEBUG Integer 
b_prc_process_init.adb
Init_Creator 
Return_Process_Status B_Prc_Proc_Automata.Return_Process_Status_T 
Msg_Buffer string 
Mailbox_Id B_Oss_Inter_Prcs_Mailbox.Mailbox_Type 
b_prc_bind_automata_segment 
Aut_Shared_Memory_Key B_Oss_Shared_Memory.Shared_Memory_Key_Type 
Shared_Address system.address 
Open_Automata_Creation_Mailbo
x 
Mailbox_Id B_Oss_Inter_Prcs_Mailbox.Mailbox_Type 
b_prc_open_automata_mailbox 
Mailbox_Id B_Oss_Inter_Prcs_Mailbox.Mailbox_Type 
Automata_Mailbox_Key B_Oss_Inter_Prcs_Mailbox.Mailbox_key_type 
b_oss_shared_memory
.adb 
Bind_Shared_Memory 
Shared_Memory_Key Shared_Memory_Key_Type 
Readability Shared_Memory_Readability_Type 
Address System.Address 
Shm_Id Integer 
Error_No Errno.Error_Codes 
The_Address System.Address 
Shared_Flag Flag_Type 
count Integer 
b_sysi_handle_global_
data_files.adb 
Save_Global_Data 
File_Name A_Strings.A_String 
Fd               B_Prc_File_Descr.File_Descriptor 
Func_GD_Address  System.Address 
Func_GD_Size    Integer 
Actual_Written Integer 
Status   Integer 
Command C_Strings.C_String 
 130
Exercise_Id B_Sysi_Overall_Sys_Config.Exercise_Id_Type 
Fd B_Prc_File_Descr.File_Descriptor 
Actual_Written Integer 
Write_Info_To_File Boolean 
Send_Initialization_Message_To_
Locals 
Trainee_List          Trainee_Console_List_Type 
Contr_List           Controller_Console_List_Type 
Temp_Value           Integer 
Master_Slave_Scheme   FALSE 
Is_EXT_DET_Console    EXT_DET_Consoles_Flag_Type 
Unzip_Map_File 
Command              C_Strings.C_String 
Status             Integer 
Maps_Dir            A_Strings.A_String 
Map_Name        string(1..20) 
Map_Name_Len        Integer 
Create_Ic_Mc_Multicast_Group 
Cont_List B_Sysi_Overall_Sys_Config.Controller_Console_List_Type 
Group_Name B_Netc_RMPG_Types_And_Constraints.Group_Name_Type 
Console_List B_Sysi_T_Ids_System_Config.Consoles_List_Type 
Wait_For_Response_From_Locals
Host_Answer_List Host_Answer_List_Type := TRUE_ARRAY 
Source_Host_Id B_Sysi_Host_Types.Host_Id_Type 
Source_Process B_Sysi_T_Ptp_Message_Types.Destination_Process_Type 
Msg_Code  B_Sysi_T_Ptp_Message_Types.Msg_Code_Type 
Msg_Args A_MMI_T_Warn.HMI_ArgElement_Type (1..1) 
Timeout B_Sysi_S_Main_App_PTP_Intrf.Time_Type 
Status  B_Sysi_S_Main_App_PTP_Intrf.Status_Type 
Delete_Fetch_Files Fd B_Prc_File_Descr.File_Descriptor 
b_bswa_handle_net_coCreate_Multicast_Group Group_Type Group_Type_Type 
 132
new_task_id     task_id_type 
Get_Task_Data 
Task_Id                   task_id_type 
Task_Priority                priority_type 
Process_Priority            priority_type 
Task_Name                 task_name_type 
activation_type            activation_type_type 
activating_mailbox_id    mailbox_type 
Set_Current_Task_Id Task_Id           Task_Id_Type 
Create_Task_Automata 
Exercise_State   (local) Ex_State_Type 
Computer_Type   (local) Console_Type_Type 
B_Prc_Task_Automata
.adb 
Set_Automata_State In_Automata_State         Automata_State_Type 
Get_Num_Of_Tasks num_of_tasks       task_id_type 
task 
Current_Task_Mailbox_Id     Mailbox_Type 
Activating_Task_Mailbox_ID    Mailbox_Type 
to_init                boolean 
wait_timeout               boolean 
task_priority              priority_type 
process_priority            priority_type 
task_name                   task_name_type 
new_task_id                  task_id_type 
activation_type              activation_type_type 
Current_Task_Id             task_id_type 
Msg_buffer                 string(1..2) 
Msg_length                 Integer:=2 
Result                       Get_Message_Result_Type 
b_sysi_start_exercise_l Send_Local_Initialization_Termin Server_Host_Id B_Sysi_Host_Types.Host_Id_Type 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
134 
3.4、階段性成果(~990707)整理 
表 3-17  階段性成果 
附件 1 變數對照表(data type) 
附件 2 B_bswa_handle_net_comm_msgs 
附件 3 b_oss_inter_prcs_mailbox 總結 
附件 4 B_Oss_Prcs_Mng 
附件 5 b_oss_shared_memory 總結 
附件 6 b_prc_bind_automata_segment 
附件 7 B_Prc_Environment 
附件 8 b_prc_open_automata_mailbox 
附件 9 b_prc_proc_automata 
附件 10 b_prc_process_init 總結 
附件 11 B_Prc_Task_Control 
附件 12 B_Prc_To_Handling 
附件 13 B_Prc_TTC_Util 
附件 14 B_Rec_Gld_Modification_Tracking 
附件 15 B_Serc_Serial_Interface 
附件 16 b_sysi_exercise_startup_handler 
附件 17 b_sysi_exercise_startup_req_handler 
附件 18 B_Sysi_Handle_Global_Data_Files 
附件 19 b_sysi_handle_state_transition 
附件 20 b_sysi_process_creation 
附件 21 b_sysi_process_creator_main 
附件 22 b_sysi_s_fetch_exercise 
附件 23 b_sysi_s_local_app_ptp_intrf 
附件 24 B_Sysi_S_Main_App_Ptp_Intrf 
附件 25 b_sysi_start_exercise_local 
附件 26 b_sysi_start_exercise_main 
附件 27 b_sysi_ttc_manager 
附件 28 b_sysi_ttc_manager_main 
附件 29 b_sysi_ttc_startup 
附件 30 Exercise_initialization 
附件 31 init 
附件 32 Open_Automata_Creation_Mailbox 
附件 33 Process Automata 
附件 34 TTC menu 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
Computer 裡 user 
interface 的離線狀
態。 
MMI_Online (**) 
 
H.P. 
處理 Local 
Computer 裡 user 
interface 的圖形顯
示及線上操作的功
能。 
MMI_AN (**) 
 
M.P. 
為 Local Computer
所屬，負責處理
X-Terminal 的相關
設備 
SER_COMM (*) 
VC_TASK H.P. 負責所有 Serial 
device 連結到
server 
SACU_TASK H.P. 
API_TASK H.P. 
NET_COMM 
REC_FROM_USERA_Task M.P. 負責 Main/Local 
Computer間的溝通Group_Task H.P. 
PTP_Server_Accept_Task H.P. 
SDE (***) 
 
L.P. 
處理戰術教練儀中
的 offline database 
(OFFLINE_STATE 
&Edit State) 
DB_PROC  (*)  L.P  
備註: 
Offline_i-Offline process for each exercise in Main Computer 
(*)-Activated only in Main Computer 
(**)-Activated only in Local Computer 
(***)-Activated only in IC Local Computer 
 
136 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
4.2、整體系統執行流程 
1. Server 端：一開始我們需要在 Server 端內部的 Host_Manager 裡(如圖 4-3 所
示)事先設定好所有的電腦名稱以及 IP 位置，以便之後可以藉由 Computer 
Name 直接對應到所屬的 IP 位置。上面所指的 Host_Manager 為 Unix 系統的
功能。。 
2. Server 端：在戰術教練儀的系統中，所有電腦名稱都儲存在 consoles.config(如
圖 4-4 所示)中，consoles.config 檔案為一開始工程師便設定在裡面的，故
Server 在 PING(Packet Internet Gopher)之前，便會先讀取此檔案，以得到所
有電腦的資訊。由圖 4-4 可看出電腦的數量繁多，所以在 PING 時，便會花
費不少時間等待。 
 
圖 4-3 Host_Manager 畫面擷取 
138 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
當 Client 端電腦開機完之後，就靜待 Server 端啟動整個操演環境。Server
端啟動 Client 端的步驟如下所示。依照以下 Step1~Step4 的步驟就可以啟動整套
戰術教練儀系統。 
4.2.1、Step1：開啟操演環境 
1. Server 端：在進行操演時會先確認每一台電腦是否都有正常開啟以及網路是
否正常，所以在一開始，Server 便會 PING 每一台電腦的 Computer Name，
確定電腦跟 Server 之間的連線是正常的。在 PING 的過程中，如果遠端有回
應，便可繼續測試下一台電腦。但如果有一台電腦沒有回應，即代表這台電
腦連線方面有問題，故此台電腦連線失敗，Server 將直接忽略掉此台電腦，
此台電腦則無法參與此次的操演。 
2. Server 端：當 PING 完所有電腦後，Server 會去遠端登入每一台電腦，並執
行主程式，雖然主程式是放在 Server 端，但是因為 Client 端的每一台電腦都
有掛載相關的檔案，所以可以順利執行。 
  
140 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
2. Trainees Craft Allocation：目的是選取出哪幾台電腦代表一台 Craft，一
台 Craft 裡的所有電腦即成為一個 Group(如圖 4-6 所示)。 
 
圖 4-6 Trainees Craft Allocation 畫面擷取 
3. Exercise Communication Plan：設定 Exercise Communication Plan。系統
會自動給予同一 Group 相同的 number(如圖 4-7 所示)。 
 
圖 4-7 Exercise Communication Plan 畫面擷取 
142 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
6. SACU Allocation：SACU No. Adversity Allocated Crafts(如圖 4-10 所
示)。 
 
圖 4-10 SACU Allocation 畫面擷取 
在一開始建立連線時，Client 端程式會使用 C 函式中的 Socket()去建立
網路連線，建立完後會得到一個 Socket id。之後會由學員台去讀取
Control_Message，並依照不同的 Control_Message 去完成 Group 跟 Member
的加入、刪除等指令。Control_Message 如下表所示： 
表 4-2 Control_Message Type 
Control_Message No. Control_Message No.
MESSAGE_ERROR 1 ALLREADY_OPEN_GROU
P 
9 
MEMBER_DROPPED  2 END_OF_RESET 10 
GROUP_TERMINATION_COMP
LETED  
3 TERMINATE_GROUP 
 
11 
NO_MEMBERS  4 ADD_MEMBER 12 
RESET_DISCARD_MESSAGE  5 DROP_MEMBER 13 
MEMBER_DROPPED_FROM_A
DDRESSING_LIST  
6 OPEN_GROUP 14 
HOLD_ON  7 GROUP_RESET 15 
CRITICAL_HOLD_ON  8 GROUP_OPENED 16 
144 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
圖 4-11 RMPG Mechanism 
在此套系統中，訊息的傳遞是透過 UNIX Domain Sockets 來進行傳遞。當訊
息要被傳遞出去時，必須先選取好所要傳遞的目的地(Message Destination、如表
4-3 所示)。程式會依據目的地的不同，將訊息放到 Global Queue 或是 Local Queue
中。Global Queue 裡的訊息可以傳送給其他不同的 Group。而 Local Queue 中的
訊息只能傳給系統內部。當訊息被置入到 Global Queue 中，系統會執行程式去處
理 Global Queue 中的訊息，將它傳遞出去。在訊息傳遞前，程式會依照 Message
146 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
封包的格式如表五所示： 
表 4-5 RMPG Network Message Packet Structure 
封包的格式 
PDU 
header 
Action 
Indication
Serial 
No. 
Source 
ID 
Add. 
list 
Ack list 
Len 
One ack  
1~N 
Data Buffer 
14bytes 1byte 3bytes 1byte 5bytes 1byte 160bytes 1300bytes 
 
 
圖 4-12 訊息傳遞與接收流程 
148 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
4.2.4、Step4：關閉操演： 
當一個操演要結束時，有 2 種方式可以將操演結束。第一種方式是直接
從Client端的觸控面板(MFK)裡按End Exercise按鈕。第二種方式是由 Server
端的 TTC Menu 中選擇 Stop TTC App 選項即可關閉操演。 
  
150 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
編號：M1-1 
檔名：A_Fir_S_Decoy_Firing.adb 
說明：傳送 Decoy Firing 的訊息 
路徑：util\integ\ver7.0.6\app\firing\decoy 
出處：A_Fir_S_Decoy_Firing.Close_Chaff_Firing (參照程式碼第 309 行到第 445
行) 
 
圖 4-14 A_Fir_S_Decoy_Firing.Close_Chaff_Firing 流程圖 
152 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
編號：M1-1-2-1 
檔名：B_BSWA_Message_Mechanism_Interface.adb 
說明：整理 Buffer_Header 和計算訊息長度，並依照目的地將訊息用不同的方
式送出 
路徑：util\integ\ver7.0.6\bsw\bsw_applications\msgs_interface 
出處：B_BSWA_Message_Mechanism_Interface. Put_Message_Service (參照程式
碼第 71 行到第 270 行) 
圖 4-16 b_bswa_message_mechanism_interface.Put_Message_Service 流程圖 
M1-1-2-1的部分(如上圖所示)會整理Buffer_Header和計算訊息大小，計算訊
息的大小是否有超過Buffer目前所能負載的大小，如果超過了，便會傳回錯誤的
訊息。如果沒有便會設定Msg_Buffer中的message_destination、Source_Node_Id、
Exercise_Id、System_State跟System_Mode。最後由M1-1-2-1-1的部分依照Message 
Destination的不同做不同的訊息處理跟傳送。對照表如下所示： 
  
154 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
SER_TP3 and SER_IMMEDIATE 
SER_TP4 and SER_IMMEDIATE 
SER_VC and SER_IMMEDIATE 
SER_VRR and SER_IMMEDIATE 
MMI_SPECIAL B_Bswa_Msgs_Handle_Int.Send_Msg_To_Ta
sk 
MMI_UPDATE B_Bswa_Msgs_Handle_Int.Send_Msg_To_Ta
sk 
EDU B_Bswa_S_Glb_Msg.Send_Internal_Msg 
PB B_Bswa_S_Glb_Msg.Send_Internal_Msg 
 
  
156 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
編號：M2 
檔名：b_bswa_handle_msg_mechanism.adb 
說明：處理 Global Queue 中的訊息 
路徑：util\integ\ver7.0.6\bsw\bsw_applications\handle_msg_mechanism 
出處：b_bswa_handle_msg_mechanism.Flush_Global_Messages (參照程式碼第
306 行到第 503 行) 
圖 4-18 b_bswa_handle_msg_mechanism.Flush_Global_Messages 流程圖 
158 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
編號：M2-2 
檔名：b_bswa_handle_net_comm_msgs.adb 
說明：將訊息轉換成 PDU 的封包格式並傳送出去 
路徑：util\integ\ver7.0.6\bsw\bsw_applications\handle_net_comm_msgs 
出處：b_bswa_handle_net_comm_msgs.Send_Msg_To_Net_Comm (參照程式碼第
2256 行到第 2498 行) 
圖 4-19 b_bswa_handle_net_comm_msgs.Send_Msg_To_Net_Comm 流程圖 
M2-2 的部分(如上圖所示)是要透過網路將訊息送出。訊息的傳送可分為 Local 
Group 和 Global Group。程式會依照 Group Type 的不同，設定所需的參數。在    
圖 4-19 中可看出，IMMEDIATE_MESSAGE 跟 REGULAR_MESSAGE 會先將訊
息轉換為 PDU 格式後，再做訊息的傳遞。而如果是 FORCE_TRANSIMISSION，
則會直接送出訊息，不做 PDU 格式轉換的動作。由於此例中的 Urgency 為
REGULAR_MESSAGE、Msg_Destination 為 NET_ALL，故程式在判斷時，會依
照所屬的部分執行。接著進入 M2-2-1 的部份。M2-2-1 會將訊息轉換成 PDU 的
格式儲存在 Buffer 裡面，直到 Buffer 無法容納新訊息。最後會進入 M2-2-2 的部
分，將 PDU 格式的封包傳送出去。 
160 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
編號：M3 
檔名：b_bswa_handle_net_comm_msgs.adb 
說明：從各個 group 中取得封包並放入 intermediate queue 中 
路徑：util\integ\ver7.0.6\bsw\bsw_applications\handle_net_comm_msgs 
出處：b_bswa_handle_net_comm_msgs.Intermediate_Task_Type (參照程式碼第
1678 行到第 1935 行) 
圖 4-21 b_bswa_handle_net_comm_msgs.Intermediate_Task_Type 流程圖 
M3 的部分首先會判斷封包是來自 Local Group、Global Group 或是 EW Group，
確認後便將封包存入到 Buffer 中。接著會從 Socket 中取得封包，並將 PDU 封包
轉換成訊息。最後由 M3-2 的部份將轉換後的訊息放入 Intermediate queue 中。 
  
162 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
編號：R1 
檔名：b_bswa_data_handler_main.adb 
說明：將各種訊息傳給 Data Handler 做處理 
路徑：util\integ\ver7.0.6\bsw\bsw_applications\data_handler 
出處：b_bswa_data_handler_main.Read_Messages (參照程式碼第 503 行到第 543
行) 
圖 4-23 b_bswa_data_handler_main.Read_Messages 流程圖 
R1 的部分(如上圖所示)是 Data Handler 在做訊息的處理。在一開始時，程式
會在 R1-1 的部分做訊息接收的動作，訊息的來源可能是 MMI、SER_COMM、
NET_COMM、Emergency 跟 Edu_Pb 的訊息。R1-1 的部分會依照來源的不同做
不同的處理，處理的方式大致都是把訊息從 Buffer 放置到 Queue 中。R1-2 的部
分是在做參數的設定，設定所得到的訊息大小在 Queue 中所佔的範圍。接下來
進入迴圈中進行訊息的讀取，R1-3 的部分會從 Local Queue 中取得訊息，再由
R1-4 進行訊息的處理。R1-4 中的處理方式會依照所得到 Msg_Code 的不同而呼
叫不同的程式，做不同的處理。對照如下表所示： 
  
164 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
編號：R1-1 
檔名：b_bswa_handle_msg_mechanism.adb 
說明：接收來自 MMI、NET_COMM、SER_COMM、Emergency 和 Edu_Pb 的
訊息 
路徑：util\integ\ver7.0.6\bsw\bsw_applications\handle_msg_mechanism 
出處：b_bswa_handle_msg_mechanism.Get_External_Messages (參照程式碼第
252 行到第 304 行) 
 
圖 4-24 b_bswa_handle_msg_mechanism.Get_External_Messages 流程圖 
R1-1 的部分(如上圖所示)會接收來自 MMI、NET_COMM、SER_COMM、
Emergency 跟 Edu_Pb 的訊息。在圖 4-24 中，SER_COMM、Emergency 跟 Edu_Pb
會先做 Computer_Type 的判斷後，才會做接收的動作。由於 TT task 的傳遞是透
過 NET_COMM 接收的，故在此只對 NET_COMM 做更進一步的說明。 
  
166 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
編號：R1-1-1-1 
檔名：B_Bswa_Handle_Net_Comm_Msgs.adb 
說明：處理從 Net_Comm 所接收的訊息 
路徑：integ\ver7.0.6\bsw\bsw_applications\handle_net_comm_msgs 
出處：B_Bswa_Handle_Net_Comm_Msgs.Get_Msg_From_NET_COMM (參照程
式碼第 2153 行到第 2252 行) 
圖 4-26 B_Bswa_Handle_Net_Comm_Msgs.Get_Msg_From_NET_COMM 流程圖 
程式一開始會先判斷 queue 中是否有訊息，如果有訊息，則從 Header 中抓
取訊息的長度、Msg_Code、Head 跟 Tail 資訊。接著判斷訊息的長度是否足夠容
納。如果可以，則使用函式 MemCpy()做訊息的複製。假如無法容納，則會將訊
息分 2 段並做 2 次做 MemCpy()的動作。 
  
168 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
編號：C 
檔名：b_sysi_app_process.adb 
說明：app process 的初始化設定 
路徑：util\integ\ver7.0.6\main\app 
出處：b_sysi_app_process (參照程式碼第 1 行到第 90 行) 
圖 4-27 B_sysi_app_process 流程圖 
在一開始的時候程式會先進入 if 的判斷式做判斷，判斷
B_Prc_Environment.Arge 是否等於 1。假如 B_Prc_Environment.Arge 不為 1，便
會進入 C1 跟 C2 的部份。C1 的部分主要是在做 Shared memory 位置的連結跟開
啟 MailBox。而 C2 的部分則是在做系統狀態的轉換，將系統狀態從 online state
轉變為 offline state。如果 B_Prc_Environment.Arge 是 1，則會執行 C3 的部分。
C3 是在做 Shared memory 位置的連結、開啟 MailBox、初始化 MailBox、初始化
Shared Memory 以及初始化 Semaphore。 
執行完 C1、C2 或是 C3 後，程式便開始執行 C4 跟 C5 的部份。C4 的部分
是將所需的 process 作優先權的設定。優先權可分為三種，分別為 H.P.(高)、M.P.(中)
和 L.P.(低)。而 C4 的部分是在建立低優先權的 process。C5 的部分會作資料庫的
初始化、Local Computer 跟 Main Computer 的通訊設定、task 的 pointer 設定以及
建立新的 task。 
  
170 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
編號：C2-1 
檔名：B_Sysi_Handle_State_Transition.adb 
說明：將目前的系統狀態轉換為 Offline State 
路徑：util\integ\ver7.0.6\bsw\system_initialization\state_transition 
出處：b_sysi_handle_state_transition.Transfer_To_Offline_State (參照程式碼第
368 行到第 424 行) 
 
圖 4-29 b_sysi_handle_state_transition.Transfer_To_Offline_State 流程圖 
172 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
編號：C2-1-1 
檔名：B_Bswa_Handle_MMI_Msgs.adb 
說明：刪除 MMI task 所使用的 2 個 mailbox 
路徑：util\integ\ver7.0.6\bsw\bsw_applications\handle_mmi_msgs 
出處：B_Bswa_Handle_MMI_Msgs.Stop_MMI_Tasks (參照程式碼第 769 行到第
804 行) 
 
圖 4-30 B_Bswa_Handle_MMI_Msgs.Stop_MMI_Tasks 流程圖 
C2-1-1 的部分(如上圖所示)是在刪除 task 間用來做溝通的 mailbox，由於當
初所建置的 mailbox 有 2 個，故在此要做 2 次刪除的動作。刪除的動作如上圖所
示。一開始先取得APP_MMI_UPDATE_TASK的mailbox Id，取得mailbox Id後，
先刪除 APP_MMI_UPDATE_TASK 的 mailbox，之後再取得
APP_MMI_UPDATE_TASK的mailbox Id，做刪除SPECIAL_MMI_TASK mailbox
的動作。 
  
174 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
上圖的部分為 B_sysi_app_process_main 的流程圖，C5-1 跟 C5-2 的部份是在
做資料庫的初始化。C5-1 的部分(如圖 4-32 所示)是針對外部裝置、VCU、PB、
EDU 等裝置的資料庫，而 C5-2 是在設定每一台 craft 是 Site1 還是 Site2，並且是
屬於 MC、MTC 或是 IC 這三種的哪一種類型。此外，Host ID 跟 Third Party ID
也同樣是在此處做設定。 
圖 4-32 是在做資料庫的初始化，在執行完資料庫的設定之後，會先取得
process name，以便在 C5-3 作資料庫載入的動作。資料載入的部分如圖 4-33 所
示。 
編號：C5-1 
檔名：B_Sysi_Host_Types.adb 
說明：初始化資料庫中的各種設定 
路徑：util\integ\ver7.0.6\bsw\system_initialization\sys_config_database 
出處：B_Sysi_Host_Types.Initialize_Database (參照程式碼第 1 行到第 129 行) 
 
圖 4-32 B_Sysi_Host_Types.Initialize_Database 流程圖 
176 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
編號：C5-4 
檔名：B_Sysi_S_Main_App_Ptp_Intrf.adb 
說明：建立通訊所使用的 socket channel 和指標設定 
路徑：util\integ\ver7.0.6\bsw\system_initialization\ptp_communications 
出處：B_Sysi_S_Main_App_Ptp_Intrf.Initialize_Communications (參照程式碼第
66 行到第 121 行) 
圖 4-34 B_Sysi_S_Main_App_Ptp_Intrf.Initialize_Communications 流程圖 
C5-4 的部分(如上圖所示)一開始會先取得 process 的名稱，之後判斷 process
來設定 socket channel。設完 socket channel 後，C5-4-1 的部分會根據 PID 建立連
結至 TTC-MANAGER 的 socket，並在 C5-4-2 的部分設置 Main Computer message
所需要使用的 pointer。Pointer 的設定如下所示： 
178 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
GET_CONFIGURATION = Addr_To_GET_CONFIGURATION (Address) 
START_EDIT_MODE = Addr_To_START_EDIT_MODE (Address) 
RQST_EX_NUM =  Addr_To_RQST_EX_NUM (Address) 
GET_EX_NUM =  Addr_To_GET_EX_NUM (Address) 
RQST_FREE_TRAIN_CONS = Addr_To_RQST_FREE_TRAIN_CONS (Address)
RQST_FREE_CNTRL_CONS = Addr_To_RQST_FREE_CNTRL_CONS 
(Address) 
GET_FREE_CONS =  Addr_To_GET_FREE_CONS (Address) 
RQST_FREE_THIRD_PARTY = Addr_To_RQST_FREE_THIRD_PARTY 
(Address) 
GET_FREE_THIRD_PARTY =  Addr_To_GET_FREE_THIRD_PARTY 
(Address) 
COMPLAN_CONFIG_RQST = Addr_To_COMPLAN_CONFIG_RQST (Address)
LOCAL_EXERCISE_GO_DOWN = Addr_To_LOCAL_EXERCISE_GO_DOWN 
(Address) 
MMI_END_INIT = Addr_To_MMI_END_INIT (Address) 
SET_EXERCISE_COMPLAN = Addr_To_SET_EXERCISE_COMPLAN 
(Address) 
GENERAL_APP_MSG = Addr_To_GENERAL_APP_MSG (Address) 
UPDATE_CONFIGURATION_DB = 
Addr_To_UPDATE_CONFIGURATION_DB (Address) 
START_FCOPY_COMMAND = 
Addr_To_START_FCOPY_COMMAND(Address) 
CONTROLLER_JOINS_EXERCISE = 
Addr_To_CONTROLLER_JOINS_EXERCISE (Address) 
ADD_CONTROLLER = Addr_To_ADD_CONTROLLER (Address) 
CONSOLE_FAILED = Addr_To_CONSOLE_FAILED (Address) 
CONSOLE_HEALTH_LIST = Addr_To_CONSOLE_HEALTH_LIST (Address) 
CHECK_CONSOLE_VALIDITY = Addr_To_CHECK_CONSOLE_VALIDITY 
(Address) 
RQST_LIST_OF_EXERS = Addr_To_RQST_LIST_OF_EXERS (Address) 
180 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
編號：C5-5 
檔名：B_Sysi_S_Local_App_Ptp_Intrf.adb 
說明：初始化 Socket 連線及建立 Inter_Task_MailBox、Guard 等 
路徑：util\integ\ver7.0.6\bsw\system_initialization\ptp_communications 
出處：B_Sysi_S_Local_App_Ptp_Intrf.Initialize_Communications (參照程式碼第
388行到第448行) 
 
圖4-35 B_Sysi_S_Local_App_Ptp_Intrf.Initialize_Communications流程圖 
182 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
Addr_To_LOCAL_MULTICAST_CREATION (Address) 
GET_CONFIGURATION = Addr_To_GET_CONFIGURATION (Address) 
START_EDIT_MODE = Addr_To_START_EDIT_MODE (Address) 
RQST_EX_NUM = Addr_To_RQST_EX_NUM (Address) 
GET_EX_NUM = Addr_To_GET_EX_NUM (Address) 
RQST_FREE_TTC_CONS = Addr_To_RQST_FREE_TTC_CONS (Address) 
RQST_FREE_CNTRL_CONS = Addr_To_RQST_FREE_CNTRL_CONS (Address) 
GET_FREE_CONS = Addr_To_GET_FREE_CONS (Address) 
RQST_FREE_THIRD_PARTY = Addr_To_RQST_FREE_THIRD_PARTY (Address)
GET_FREE_THIRD_PARTY =Addr_To_GET_FREE_THIRD_PARTY (Address) 
COMPLAN_CONFIG_RQST = Addr_To_COMPLAN_CONFIG_RQST (Address) 
LOCAL_EXERCISE_GO_DOWN = Addr_To_LOCAL_EXERCISE_GO_DOWN 
(Address) 
MMI_END_INIT = Addr_To_MMI_END_INIT (Address) 
SET_EXERCISE_COMPLAN = Addr_To_SET_EXERCISE_COMPLAN (Address) 
GENERAL_APP_MSG = Addr_To_GENERAL_APP_MSG (Address) 
UPDATE_CONFIGURATION_DB = Addr_To_UPDATE_CONFIGURATION_DB 
(Address) 
START_FCOPY_COMMAND = Addr_To_START_FCOPY_COMMAND(Address) 
CONTROLLER_JOINS_EXERCISE = 
Addr_To_CONTROLLER_JOINS_EXERCISE (Address) 
ADD_CONTROLLER = Addr_To_ADD_CONTROLLER (Address) 
CONSOLE_FAILED = Addr_To_CONSOLE_FAILED (Address) 
CONSOLE_HEALTH_LIST = Addr_To_CONSOLE_HEALTH_LIST (Address) 
CHECK_CONSOLE_VALIDITY = Addr_To_CHECK_CONSOLE_VALIDITY 
(Address) 
RQST_LIST_OF_EXERS = Addr_To_RQST_LIST_OF_EXERS (Address) 
LIST_OF_EXERS = Addr_To_LIST_OF_EXERS (Address) 
READ_CONFIGURATION_FILE = Addr_To_READ_CONFIGURATION_FILE 
(Address) 
DELETE_EXERCISE = Addr_To_DELETE_EXERCISE (Address) 
INTERSITE_HEARTBEAT = Addr_To_INTERSITE_HEARTBEAT (Address) 
TRANSFER_TO_LIVE = Addr_To_TRANSFER_TO_LIVE (Address) 
RQST_FREE_EXT_CONS = Addr_To_RQST_FREE_EXT_CONS (Address) 
GET_FREE_EXT_CONS = Addr_To_GET_FREE_EXT_CONS (Address) 
EXT_CC_CONFIG = Addr_To_EXT_CC_CONFIG (Address) 
EXT_DET_CONFIG = Addr_To_EXT_DET_CONFIG (Address) 
184 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
Read_Messages_Pointer_Tbl(Task_Name) = 
B_Bswa_Data_Handler_Main.Read_Messages'Address 
Any_Rate_Main_Loop_Pointer_Tbl(Task_Name) = 
B_Bswa_Data_Handler_Main.Handle_Reports'Address 
No_Zero_Rate_Main_Loop_Pointer_Tbl(Task_Name) = 
B_Bswa_Data_Handler_Main.Handle_Periodic'Address 
Read_Msgs_No_Handle_Pointer_Tbl(Task_Name) = 
B_Bswa_Data_Handler_Main.Read_Messages_Postpone'Address 
Read_Msgs_Ignore_Pointer_Tbl(Task_Name) = 
B_Bswa_Data_Handler_Main.Read_Messages_Ignore'Address 
Small_Init_Pointer_Tbl(Task_Name) = 
B_Bswa_Data_Handler_Main.After_Jump_Initialization'Address 
Full_Init_Pointer_Tbl(Task_Name) = 
B_Bswa_Data_Handler_Main.Full_Initialization'Address 
Init_Relevance_Pointer_Tbl(Task_Name) = 
B_Bswa_Data_Handler_Main.Init_Relevance'Address 
Termination_Pointer_Tbl (Task_Name) = 
B_Bswa_Data_Handler_Main.Handle_Termination'Address 
Init_Recovery_Pointer_Tbl (Task_Name) = 
B_Bswa_Data_Handler_Main.Init_For_Recovery'Address 
Init_For_Join_Member_Tbl (Task_Name) = 
B_Bswa_Data_Handler_Main.Init_For_Recovery'Address 
Task_Name=B_Prc_Task_Automata.REPLAY_HANDLER 
Read_Messages_Pointer_Tbl(Task_Name) = 
B_Rep_Main_Replay.Read_Messages'Address 
Any_Rate_Main_Loop_Pointer_Tbl(Task_Name) = 
B_Rep_Main_Replay.Handle_Periodic'Address 
No_Zero_Rate_Main_Loop_Pointer_Tbl(Task_Name) =System.NULL_ADDRESS 
Read_Msgs_No_Handle_Pointer_Tbl(Task_Name) =System.NULL_ADDRESS 
Read_Msgs_Ignore_Pointer_Tbl(Task_Name) = 
B_Rep_Main_Replay.Read_Messages_Ignore'Address 
Small_Init_Pointer_Tbl(Task_Name) = System.NULL_ADDRESS 
Full_Init_Pointer_Tbl(Task_Name) = 
B_Rep_Main_Replay.Full_Initialization'Address 
Init_Relevance_Pointer_Tbl(Task_Name) = 
B_Rep_Main_Replay.Init_Relevance'Address 
Termination_Pointer_Tbl (Task_Name) =  System.NULL_ADDRESS 
186 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
Init_Relevance_Pointer_Tbl(Task_Name) = 
A_Dyn_S_Dynamics.Init_Relevance'Address 
Termination_Pointer_Tbl (Task_Name) = 
A_Dyn_S_Dynamics.Handle_Termination'Address 
Init_Recovery_Pointer_Tbl (Task_Name) = 
A_Dyn_S_Dynamics.Init_For_Recovery'Address 
Init_For_Join_Member_Tbl (Task_Name) = 
A_Dyn_S_Dynamics.Init_For_Join_Member'Address 
Task_Name=B_Prc_Task_Automata.DETECTION 
Read_Messages_Pointer_Tbl(Task_Name) = 
A_Det_S_Detection.Read_Messages'Address 
Any_Rate_Main_Loop_Pointer_Tbl(Task_Name) = 
A_Det_S_Detection.Handle_Reports'Address 
No_Zero_Rate_Main_Loop_Pointer_Tbl(Task_Name) = 
A_Det_S_Detection.Handle_Periodic'Address 
Read_Msgs_No_Handle_Pointer_Tbl(Task_Name) = 
A_Det_S_Detection.Read_Messages_Postpone'Address 
Read_Msgs_Ignore_Pointer_Tbl(Task_Name) = 
A_Det_S_Detection.Read_Messages_Ignore'Address 
Small_Init_Pointer_Tbl(Task_Name) = 
A_Det_S_Detection.After_Jump_Initialization' Address 
Full_Init_Pointer_Tbl(Task_Name) =A_Det_S_Detection.Full_Initialization'Address
Init_Relevance_Pointer_Tbl(Task_Name) = 
A_Det_S_Detection.Init_Relevance'Address 
Termination_Pointer_Tbl (Task_Name) =  
A_Det_S_Detection.Handle_Termination'Address 
Init_Recovery_Pointer_Tbl (Task_Name) = 
A_Det_S_Detection.Init_For_Recovery'Address 
Init_For_Join_Member_Tbl (Task_Name) = 
A_Det_S_Detection.Init_For_Join_Member'Address 
Task_Name=B_Prc_Task_Automata.FIRING 
Read_Messages_Pointer_Tbl(Task_Name) = 
A_Fir_S_Manager.Read_Messages'Address 
Any_Rate_Main_Loop_Pointer_Tbl(Task_Name) = 
A_Fir_S_Manager.Handle_Reports'Address 
No_Zero_Rate_Main_Loop_Pointer_Tbl(Task_Name) = 
A_Fir_S_Manager.Handle_Periodic'Address 
188 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
Task_Name=B_Prc_Task_Automata.CC 
Read_Messages_Pointer_Tbl(Task_Name) =A_CC_S_Main.Read_Messages'Address
Any_Rate_Main_Loop_Pointer_Tbl(Task_Name) = 
A_CC_S_Main.Handle_Reports'Address 
No_Zero_Rate_Main_Loop_Pointer_Tbl(Task_Name) = 
A_CC_S_Main.Handle_Periodic'Address 
Read_Msgs_No_Handle_Pointer_Tbl(Task_Name) = 
A_CC_S_Main.Read_Messages_Postpone'Address 
Read_Msgs_Ignore_Pointer_Tbl(Task_Name) = 
A_CC_S_Main.Read_Messages_Ignore'Address 
Small_Init_Pointer_Tbl(Task_Name) = 
A_CC_S_Main.After_Jump_Initialization'Address 
Full_Init_Pointer_Tbl(Task_Name) =A_CC_S_Main.Full_Initialization'Address 
Init_Relevance_Pointer_Tbl(Task_Name) =A_CC_S_Main.Init_Relevance'Address 
Termination_Pointer_Tbl (Task_Name) =  System.NULL_ADDRESS 
Init_Recovery_Pointer_Tbl (Task_Name) = 
A_CC_S_Main.Init_For_Recovery'Address 
Init_For_Join_Member_Tbl (Task_Name) = 
A_CC_S_Main.Init_For_Join_Member'Address 
Task_Name=B_Prc_Task_Automata.MAIN_REC 
Read_Messages_Pointer_Tbl(Task_Name) = 
B_Rec_Main_Recording.Read_Messages'Address 
Any_Rate_Main_Loop_Pointer_Tbl(Task_Name) = 
B_Rec_Main_Recording.Handle_Reports'Address 
No_Zero_Rate_Main_Loop_Pointer_Tbl(Task_Name) = 
B_Rec_Main_Recording.Handle_Periodic'Address 
Read_Msgs_No_Handle_Pointer_Tbl(Task_Name) = 
B_Rec_Main_Recording.Read_Messages_Postpone'Address 
Read_Msgs_Ignore_Pointer_Tbl(Task_Name) = 
B_Rec_Main_Recording.Read_Messages_Ignore'Address 
Small_Init_Pointer_Tbl(Task_Name) = 
B_Rec_Main_Recording.After_Jump_Initialization'Address 
Full_Init_Pointer_Tbl(Task_Name) = 
B_Rec_Main_Recording.Full_Initialization'Address 
Init_Relevance_Pointer_Tbl(Task_Name) = 
B_Rec_Main_Recording.Init_Relevance'Address 
Termination_Pointer_Tbl (Task_Name) = 
190 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
C5-7 的部分會先設定第一個 automata task Id，設定完後再由 C5-8 的部分來
取得 automata task 的資料。並由 C5-9 跟 C5-10 來創造 Task。 
  
192 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
R u n tim e  In fra s tru c tu re
F e d e ra tio n  M a n a g e m e n t  D e c la ra tio n  M a n a g em e n t
O b je c t M a n a g e m e n t   O w n e rs h ip  M a n a g em e n t
T im e  M a n a g em e n t  D a ta  D is tr ib u tio n  M a n a g e m e n t
S im u la tio n sD a ta  C o lle c to r/
P a s s ive  V iew e r
In te rfa c e s
to  L ive
P la ye rs
L ive
P a rtic ip a n ts
F O M
S O M
F O M
S O M
F O M
S O M
 
圖 5-1 HLA 之基本架構圖 
¾ HLA 標準包括了以下三個部份： 
1. HLA Rules：為了要使模擬系統達到完整的互動所訂下的方針與條約。
HLA Rules 共有十條，分別用來定義 Federation 跟 Federate 之間的關
係。 
2. Interface Specification：主要是定義 RTI 的 API Function 及 Services。
另外，會確認每一個 Federate 都有提供 Callback 功能。 
3. Object Model Template(OMT)：是定義 HLA 中所有的模擬演訓本身
及其參與元件的資料格式。在 OMT 中，可分為 Federation Object 
Model (FOM)及 Simulation Object Model (SOM)兩大類。HLA 中的物
件模型(Object Model)可以用來描述一個個別的 Federate，而此時便
會產生一個 HLA Simulation Object Model (SOM)；亦可以是用來描述
集合多個有互動關係的 Federate 而成的 Federation，因而產生一個
Federation Object Model (FOM)。總而言之，OMT 的主要目的即在於
提昇各個模擬系統間的互通性及模擬系統各元件的重複使用性。 
表 5-1 SOM 與 FOM 說明 
Simulation Object Models (SOM) Federation Object Models (FOM) 
在一個 Federation 中，會存在一個
以上的 SOM，而 SOM 的最主要目的在
於描述在模擬演習當中之 Federate 可提
供給整個演習的功能。而 SOM 也和
FOM 一樣，是用物件類別、互動類別、
物件屬性及互動參數來定義。由於 FOM
和 SOM 的格式是相同的，所以 SOM 可
以成為 FOM 的一部分，亦即是說，在
發展 FOM 的過程中，可以先發展出所
有的 SOM，再將之合併成一個 FOM。
在一個 Federation 中只會有一個
FOM 存在，而 FOM 的最主要目的是在
於提供一個共通且標準化之格式來描
述其一 Federation 中各 Federate 之間資
料的交換情形。 
 
194 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
圖5-3 RTI與Federate Ambassadors示意圖 
¾ Federates 跟 RTI 之間定義了六項服務 
1. Federation Management(聯模演訓管理)：對於 Federation 的建
置、動態控制、修改和刪除等過程，以及 Federation 演習物件
的 save、restore 與 synchronization。這些功能皆由此服務來進
行處理，以完成整個模擬演習活動的協調。 
2. Declaration Management(聲明管理)：主要是在定義每一個
Federate 該如何對其他的 Federate 表明自己所擁有的物件屬性
資料，此表明代表 Federate 有能力維護和更新該物件的屬性資
料。因此，每一個 Federate 僅需要在操演時清楚的聲明自己能
產生的資料(publish)以及自己所需要的資料(subscribe)，便能
在操演中傳遞與接收資料。聲明管理的作用是在操演時建立
publish 跟 subscribe 的關係，以利用 RTI 的機制減少網路傳輸
的資料量。 
3. Object Management(物件管理)：物件管理建立在聲明管理的基
礎上，此兩部分互相搭配以維護資料的一致性。物件管裡的主
要功能有物件的註冊、屬性值的更新、Federate 間的互動以及
物件實例的刪除等功能。 
4. Ownership Management(所有權管理)：一個 Federate 有權更新
某個物件屬性的值，此 Federate 即擁有該物件的屬性。擁有物
件屬性所有權的 Federate 才有權更新該物件屬性的值。所有權
管理會負責 Federate 間所有權的釋放(push)與取得(pull)。 
5. Time Management(時間管理)：主要是負責處理 Federate 之間
的時間同步協調，使得聯合模擬演訓進行中所發生的事件皆能
保持應有的因果關係。 
196 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
FOM
FED file
RTI RID File
Federates
1
4
5
2
3
User
Feedback
Corrective Actions
Reusable Products
Program
Objectives
Sponsor
Requirements
Available
Resources
Define
Federation
Objectives
Develop
Federation
Conceptual
Model
Design
and
Develop
Federation
Integrate
and
Test
Federation Execute
Federation
and
Prepare
Results
Initial Planning
Documents
Federation
Objectives
Statement
Federation
Scenario
Federation
Conceptual
Model
Federation
Requirements
Test
Evaluation
Criteria
Scenario
Instance
Federation
Development
Plan
Testing
Data
Tested
Federation
圖 5-4 FEDEP 的發展 
 
198 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
負責確認所有電腦狀態是否正常以及幫忙傳遞訊息。APP_PROC 會處理所有
Main Computer 戰術方面的服務並且將訊息傳給 Local Computer。Main Computer
的所有資料則會儲存於所屬的操演資料庫內。Local Computer 的部份包含了 MFK、
User Interface、Local_APP和操演資料庫。MFK為使用者操作指令的觸控型電腦，
所有需下達的指令，如操演速率、武器選取皆由 MFK 操作。Local_APP 則會負
責所有 Local Computer 戰術方面的服務並且將訊息傳給 Main Computer。而 Local 
Computer 的所有資料會儲存於所屬的操演資料庫中。User Interface 則是顯示目
前整個演訓狀態的使用者操控畫面。 
鑒於現有之戰術教練儀已屆保固年限，且所使用之程式語言及電腦設備已經
為當今電腦科技所汰舊之技術，對於後續維護與更新幾乎是不可能的事，因此，
根據現有系統研究與了解，本計畫建議可在最小之技術風險之下將此套系統現有
的架構轉移成高階模擬架構(High Level Architecture、HLA)。由於 HLA 為目前普
遍使用的軍用架構且 HLA 的目的為整合各種模擬器與模擬系統，以提升整個模
擬範圍。因此，只要符合此架構便能與其他遵守此規範的模擬系統進行整合性聯
合模擬。此外，HLA 是針對模擬訓練而設計的，並且特別針對傳遞和時間問題
制定了完整的函式服務。故將現有的系統架構轉移成 HLA 架構之後，便能增進
性能並且延續此套系統的使用年限。 
圖 5-6 是套用到 HLA 架構後的新系統架構圖。基本的架構仍然維持原有的
架構，因此 Local Computer 與 Main Computer 所擁有的 MFK、User Interface、
Local_APP、APP_PROC 跟各自的操演資料庫仍維持不變，原本架構裡的
TTC_MANAGER，則可由 HLA 規格之 FedExec 所取代。在 RTI 的六項服務模組
裡已有現成的函式可以完成大部分的功能。Federation Management 中的函式
JoinFederationExecution 會負責成員的加入與離開。Declaration Management 會協
助同一 Federation 中，所有 Federate 間的資料交換、傳遞。函式
InitiateFederateRestore 則會處理操演的還原部份。而時間同步的問題則包含在
Time Management 中。而另外所需加入的部分則包含了資料庫的連結以及初始化
的動作。TTC_MANAGER 跟 FedExec 的對照表如表 5-2 所示。 
 
表 5-2 TTC_MANAGER 與 FedExec 對照表 
原有架構的 TTC Manager HLA 架構的 Fed Exec 
z 確認所有參與操演的電腦狀態是
否正常 
z 處理額外的電腦加入操演 
z 訊息的傳遞 
z 資料庫的連結與初始化 
z 負責操演的還原動作(recovery) 
z 管理 Federate 的加入和離開 
z 協助同一 Federation 中，所有
Federate 間的資料交換、傳遞 
z 有現有函式處理操演的還原
(restore)問題 
z 處理時間同步的問題 
z 資料庫的連結、初始化 
在 HLA 架構中，主要修改的部分可分為兩個方向。第一個方向是針對通訊
的方面做修改，將所有訊息的傳輸修改成由 RTI(Runtime Infrastructure)來處理。
由於通訊的方面有了 RTI 處理，故所有的戰術模組在設計時不需要考慮如何傳送，
只需要專注在戰術方面的設計與規劃，因此可以讓整個模組更專精且容易添增新
的戰術技能。第二個方向是修改 Local Computer 跟 Main Computer 內部 APP 的
200 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
在 APP 修改的部分，主要修改的方向是將原系統所擁有的 APP 套用到 HLA
架構之後，所需要做的變動。此變動可以更容易區分 Main Computer 跟 Local 
Computer 的功能。讓各自所負責的功能能夠更清楚辨別，也更具彈性。在原系
統裡，Client A 要傳遞訊息給 Client B 時，必須經由 Server 來幫助傳遞。故在原
系統中，有些 APP 會重複出現於 Main Computer 跟 Local Computer 裡。由圖 5-7
可看出，Dynamics、Detection 和 EX_MNG 等戰術方面的 APP 都重複出現於 Main 
Computer 跟 Local Computer 裡。但這些 APP 的功能卻大不相同。在 Server 中，
這些戰術方面的 APP 僅負責正確的接收跟傳遞訊息給 Client 端。故容易造成誤
導，以為這些 APP 模組的功能皆相同。但在 HLA 架構中，由於訊息的傳遞交給
了 RTI，故 Server 便不必做訊息方面的處理。因此，在 HLA 架構下的 Main 
Computer，便可以簡化其中的 APP。圖 5-8 為重新規畫後的結果。從圖 5-8 中可
看出，在 HLA 中的 Local Computer 跟 Main Computer 有了更清楚的規劃，功能
也更加明確。在 Local Computer 中，主要的功能將著重於戰術方面的執行，如船
艦運動學、武器發射、雷達偵測、使用者操作介面和回放功能。而 Main Computer
則為處理任務指派、操演仲裁跟回放控制。藉由系統模組化，讓整個系統結構作
更清楚的分割，使其功能單一能明確。也使未來系統程式的修改、維護及更新更
加容易，也可避免程式碼過度重複的問題。 
圖 5-7 原架構的 APP 模組 
202 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
第6章、結論及未來執行建議 
6.1、結  論 
本計畫是現役模擬系統-戰術教練儀系統之研改案，研究案目的是在提供艦
隊穩定之模擬訓練平台前提下，考量成本效益與風險等因素，利用現有商用電腦
平台快速運算之能力與易於維護之便，評估對現有系統以改寫或是移植方式來進
行系統精進的可行性，以符合日後作戰環境模擬演訓需求之範圍與日常維護之便
利性。 
 
本研究案的預計進行步驟如下： 
1. 先由現有之系統文件找出模擬軟體的大致系統架構，以及深入了解整體系統
的執行流程，藉由此步驟之分析將整體原始碼切割出 C 程式碼與 Ada 程式
碼兩大部分，以及每部分職司之功能。 
2. 接著分別針對 C 程式碼與 Ada 程式碼加以探討與分析，將整體模擬程式進
一步分離出與 SGI 電腦有關之程式碼、與整體模擬架構有關之程式碼，以
及與戰術想定有關之程式碼三大部分，並細部分析各大部分程式碼的演算法
及架構，同時開始逐步撰寫系統相關說明文件。 
3. 最後，依 UML 方式開始建置系統文件及說明文件，並提出評估報告，建議
未來移植現行商用電腦之可行性，整體程式改寫方式，以及未來委商改版之
系統驗證機制。 
4. 本計畫最後將提出風險評估報告。 
 
經數月的研讀現有系統程式碼，本研究案發現現有系統絕大部分是以 ADA
語言撰寫，僅小部分與網路及 SGI 電腦系統呼叫有關的程式是採用 C 與言撰寫，
因此本研究案的研究人員改成全力分析所有 ADA 語言相關的程式，目前已對整
體系架構已了解，也確認現有系統之運作方式為傳統之 Server-client 方式，本研
究順利依照預期進度執行。 
 
現有系統絕大部分是以 ADA 語言撰寫，僅小部分與網路及 SGI 電腦系統呼
叫有關的程式是採用 C 與言撰寫，因此全力分析所有 ADA 語言相關的程式，確
認現有系統之運作方式為傳統之 Server-client 方式。  
 
已確定無法採用直接移植方式，將現有系統由 SGI 電腦直接移轉至一般商
用電腦平台執行，原因如下： 
1. 現有戰術教練儀系統的使用者介面程式與資料庫系統皆為 SGI
機器上的專屬軟體，一般商用電腦平台無此類套裝軟體可以使
用。 
2. 現有戰術教練儀系統所使用之 ADA 語言為目前已鮮少被使用的
204 
99 年度學術合作研究案期末報告；戰術教練儀研改評估 
HLA 架構之 Local Computer 的功能 
主要的船艦運算功能是在個別電腦執行，包括：  
船艦運動學、武器發射、雷達偵測、使用者操控介面、本機演習回放。 
Detection Dynamics
CC
MMI_APPL_
Update_Task
_Trigger
Special_task
_Dispatch General_Task_
Dispatch
Local_replay
Firing
 
圖 6-2 HLA 架構之 Local Computer 的功能 
 
 
 
 
206 
國科會補助計畫衍生研發成果推廣資料表
日期:2011/01/15
國科會補助計畫
計畫名稱: 戰術教練儀研改評估
計畫主持人: 黃俊堯
計畫編號: 99-2623-E-305-001-D 學門領域: 電子與資訊系統
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
由於本計畫牽涉到國防機密，因此暫無量化之研究成果。 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
