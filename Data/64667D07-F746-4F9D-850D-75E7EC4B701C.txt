to locate cohesive subgroups. Once those cohesive 
subgroups are detected, it helps sociologists to 
understand the structures of networks. However, 
discovering cohesive subgroups in networks is 
computationally challenging task, especially when 
some cohesive subgroups are overlapping. There is no 
standard definition of cohesive subgroups and no 
consensus about how a network should be divided into 
groups. The analysis of cohesive subgroups is a 
fundamental problem in social networks, where one 
wishes to classify the network into groups. For a 
long time, people usually avoid solving the NP-hard 
problems exactly. It seems hopeless to optimally 
solve NP-hard problems in polynomial time. Some may 
try to develop approximation algorithms or heuristic 
algorithms, but some may just give up finding the 
optimal solution of the problem. Every NP-hard or NP-
complete problem can be solved by exhaustive search. 
It is upset that when the size of input grows, the 
running time becomes forbiddingly large. For some 
problems, it is possible to design algorithms that 
are significantly faster than exhaustive search, 
though still not polynomial time. We call the 
algorithms designed for solving NP-hard or NP-
complete problems exactly exact algorithms. During 
recent years, there are many clever strategies and 
exact algorithms for solving NP-hard problems 
discussed and published in very top international 
journals. In this project, we focus on NP-hard 
problems in social networks for finding cohesive 
subgroups according different criteria. Our research 
results include: 
(1) we designed and implemented a heuristic algorithm 
to find a large $k$-club in a given graph, 
(2) we designed and implemented a branch-and-bound 
algorithm for finding a maximum $k$-club in a given 
graph, 
(3) we designed and implemented a branch-and-bound 
algorithm for finding a maximum $2$-plex in a given 
graph, 
(4) we designed an exact algorithm to find a minimum 
$k$-club vertex cover, 
行政院國家科學委員會補助專題研究計畫
 成 果 報 告
期中進度報告
社群偵測之固定參數暨正確解演算法設計
Fixed-Parameter Algorithms and Exact Algorithms for Community
Detection
計畫類別 : 個別型計畫  整合型計畫
計畫編號 : NSC 98—2221—E—241—018–MY3 (NSC 98—2221—E—194—026–MY3)
執行期間 : 9 8年 8月 1日 至 101 年 7月 3 1日
計畫主持人 :張 貿 翔
共同主持人 :
計畫參與人員 : 洪綾珠、 陳立軒、 巫冠翰、 蔣岳翰、 繆朝安、 劉奕志、 雷興怡、 蕭凱倫
成果報告類型 (依經費核定清單規定繳交) :  精簡報告  完整報告
本成果報告包括以下應繳交之附件 :
赴國外出差或研習心得報告一份
赴大陸地區出差或研習心得報告一份
出席國際學術會議心得報告及發表之論文各一份
國際合作研究計畫國外研究報告書一份
處理方式 : 除產學合作研究計畫、 提升產業技術及人才培育研究計畫、 列管計畫
及下列情形者外, 得立即公開查詢
涉及專利或其他智慧財產權, 一年 二年後可公開查詢
執行單位 :弘 光 科 技大 學 資 訊工 程 系
中 華 民 國 1 0 1 年 1 0 月 3 1 日
Abstract
On studying social networks it is an important issue to locate cohesive subgroups.
Once those cohesive subgroups are detected, it helps sociologists to understand the struc-
tures of networks. However, discovering cohesive subgroups in networks is computation-
ally challenging task, especially when some cohesive subgroups are overlapping. There
is no standard definition of cohesive subgroups and no consensus about how a network
should be divided into groups. The analysis of cohesive subgroups is a fundamental prob-
lem in social networks, where one wishes to classify the network into groups. For a
long time, people usually avoid solving the NP-hard problems exactly. It seems hopeless
to optimally solve NP-hard problems in polynomial time. Some may try to develop ap-
proximation algorithms or heuristic algorithms, but some may just give up finding the
optimal solution of the problem. Every NP-hard or NP-complete problem can be solved
by exhaustive search. It is upset that when the size of input grows, the running time
becomes forbiddingly large. For some problems, it is possible to design algorithms that
are significantly faster than exhaustive search, though still not polynomial time. We call
the algorithms designed for solving NP-hard or NP-complete problems exactly exact al-
gorithms. During recent years, there are many clever strategies and exact algorithms for
solving NP-hard problems discussed and published in very top international journals. In
this project, we focus on NP-hard problems in social networks for finding cohesive sub-
groups according different criteria. Our research results include: (1) we designed and
implemented a heuristic algorithm to find a large k-club in a given graph, (2) we
designed and implemented a branch-and-bound algorithm for finding a maximum
k-club in a given graph, (3) we designed and implemented a branch-and-bound al-
gorithm for finding a maximum 2-plex in a given graph, (4) we designed an exact
algorithm to find a minimum k-club vertex cover, (5) we designed two heuristic al-
gorithms, IDROP COVER and CONSTELLATION COVER to find a k-club vertex cover, (6)
we designed an exact algorithm to find a minimum k-plex vertex cover, and (7) we
designed an exact algorithm for the densest k-set problem. In this report, we will
ii
Contents
1 前言 1
2 研究目的 2
3 文獻探討 3
4 研究方法 5
4.1 The maximum k-club problem . . . . . . . . . . . . . . . . . . . . . . . . . 5
4.1.1 An O∗(1.62n) exact algorithm . . . . . . . . . . . . . . . . . . . . . 5
4.1.2 Algorithmic tricks . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
4.1.3 Experiment Results . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
4.2 The minimum k-club vertex cover problem . . . . . . . . . . . . . . . . . . 23
4.2.1 An exact algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
4.2.2 A heuristic algorithm: IDROP cover . . . . . . . . . . . . . . . . . . 25
4.2.3 A heuristic algorithm: Constellation Cover . . . . . . . . . . . . . . 26
4.2.4 Experiment Results . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
4.3 The maximum k-plex problem . . . . . . . . . . . . . . . . . . . . . . . . . 31
4.3.1 Integer programming formulation . . . . . . . . . . . . . . . . . . . 31
4.3.2 Approaches by adapting combinatorial clique algorithms . . . . . . 33
4.3.3 Solving the dual problem of the maximum k-plex problem . . . . . 38
4.3.4 New branch-and-bound algorithms for solving the maximum 2-plex
problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
4.3.5 Experiment results. . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
4.4 The minimum k-plex vertex cover problem . . . . . . . . . . . . . . . . . . 68
4.4.1 An exact algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
4.5 Problems related to the maximum 2-plex problem . . . . . . . . . . . . . . 70
4.5.1 An exact algorithm for MAX-1-BDS . . . . . . . . . . . . . . . . . . 71
4.5.2 A fixed-parameter algorithm for the 1-BDD problem . . . . . . . . 80
iv
1 前言
Finding cohesive subgroups is an important issue in studying social networks. Many
models exist for defining cohesive subgraphs in social networks, such as clique, k-clique,
k-plex, k-clan, k-club, etc. The concept of k-club and k-plex are two of them. A k-club
of a graph is a subset of the vertex set which induces a subgraph of diameter k. It is a
relaxation of a clique, which induces a subgraph of diameter 1. The k-plex is defined as
a degree based model for finding cohesive subgroups introduced by Seidman and Fos-
ter [73]. A subset of vertices S is said to be a k-plex if the degree of every vertex in the
induced subgraph G[S] is at least |S| − k. Define the density of a graph G = (V ,E) to
be |E|/|V |. Use d(S) to denote the density of the subgraph of G induced by vertex set S.
A densest set of a graph G = (V ,E) is a subset D of V such that the density of G[D] is
maximum among all subgraphs of G induced by non-empty subsets of V . We call a subset
S of a graph G = (V ,E) a k-set (resp. at-least-k-set, at-most-k-set) if and only if S is of size
k (resp. of size not less than k, of size not larger than k). A densest k-set (resp. at-least-k-
set, at-most-k-set) S of G is a k-set (resp. at-least-k-set, at-most-k-set) of G such that the
density of G[S] is maximum among all subgraphs of G induced by k-sets (resp. at-least-
k-sets, at-most-k-sets) of G. Similarly, a sparsest k-set (resp. at-least-k-set, at-most-k-set)
S of G is a k-set (resp. at-least-k-set, at-most-k-set) of G such that the density of G[S] is
minimum among all subgraphs of G induced by k-sets (resp. at-least-k-sets, at-most-k-
sets) of G. It is easy to see that S is a densest k-set in G if and only if it is a sparsest k-set
in G¯, the complement of G.
We conducted algorithmic studies on finding a k-club and a k-plex of size as large
as possible. Also we introduce the minimum k-club vertex cover problem and the mini-
mum k-plex vertex cover problem. Each set of minimum k-club vertex cover or each set
of minimum k-plex vertex cover contains a set of cohesive subgroups and of course it
allows overlapping between cohesive subgroups. We give exact algorithms and heuristic
algorithms to find a k-club vertex cover and a k-plex vertex cover as small as possible.
1
3 文獻探討
For a graph G = (V ,E) and an integer k, a k-club in G is a vertex subset S ⊆ V such
that distG[S](u, v) 6 k for all u, v ∈ S. Denote distG(u, v) as the shortest distance from
u to v in G. It is well-known that the maximum clique problem is NP-hard [37]. In this
project, we study the maximum k-club problem for k > 2. Given an undirected graph
G = (V ,E) and an integer k, the maximum k-club problem is to find a k-club G[S] in
G with the maximum cardinality. Bourjolly et al. showed that the problem is NP-hard
even for any fixed k > 1 [15]. It is shown that the size of the maximum k-clique is
an upper bound of the size of the maximum k-club [14]. However the problem to find
a maximum k-clique is also NP-hard on arbitrary graphs and on graphs with diameter
more than k [6]. Bourjolly et al. gave some heuristic algorithms for finding k-clubs in
an undirected graph [14]. In [15], they gave a branch-and-bound algorithm for finding a
maximum k-club.
The k-plex is defined as a degree based model for finding cohesive subgroups intro-
duced by Seidman and Foster [73]. A subset of vertices S is said to be a k-plex if the
degree of every vertex in the induced subgraph G[S] is at least |S| − k. That is, S ⊆ V is a
k-plex if the following condition holds:
degG[S](v) = |N(v) ∩ S| > |S|− k ∀v ∈ S.
The maximum k-plex problem is to find the largest k-plex in a given graph. The problem
is NP-complete [7] and is W[1]-hard by using the size of k-plex as a parameter [53].
In [8], Balasundaram showed that the maximum k-plex problem admits a 0-1 integer
programming formulation and gave a branch-and-cut algorithm to solve it. In [63], a
combinatorial, exact algorithm is developed. This exact algorithm uses a very tight upper
bound given in [31]. McClosky and Hicks gave a branch-and-bound algorithm with new
upper bound derived by a heuristic coloring algorithm [60]. It adapts combinatorial clique
algorithms to find maximum k-plexes. In [10], Bevern et al. considered the problem
called k-plex cluster vertex deletion problem and gave a fixed parameter algorithm with
3
of approximation algorithms for the DENSEST k-SET problem and WEIGHTED DENSEST
k-SET problem based on LP relaxation [12, 13] and semidefinite programming [74, 42].
4 研究方法
In this section we demonstrate the results that we have achieved on the following
problems:
1. the maximum k-club problem,
2. the minimum k-club vertex cover problem,
3. the maximum 2-plex problem,
4. the minimum k-plex vertex cover problem,
5. problems related to the 2-plex problem,
6. problems related to the densest k-set problem, and
7. the densest k-set problem.
We first give some of our notation customs. For a graph G = (V ,E) and W ⊂ V , we use
G[W] to denote the induced subgraph of G by W. Let u, v ∈ V be two vertices in G. We
use distG(u, v) to denote the distance between u and v in G. For a vertex v 6∈W, we use
distG(v,W) to denote maxw∈W distG(v,w). Let Nk(v) = {u | distG(v) 6 k} denote the
k-neighborhood of v in G. For any vertex v ∈ V , we use degG(v) to denote the degree of
v in G.
4.1 The maximum k-club problem
4.1.1 An O∗(1.62n) exact algorithm
Bourjolly et al. [15] gave a branch-and-bound algorithm for solving the maximum k-club
problem without analyzing the time complexity. In this section, we analyze the worst-
case time complexity of this algorithm. At the root node of the search tree, two branches
are generated corresponding to removing or keeping the vertex selected. The algorithm
5
4.1.2 Algorithmic tricks
To implement the branch-and-bound algorithm to run fast, we incorporate four algorith-
mic tricks. One is to design a new heuristic algorithm that can find larger k-clubs than
existing heuristic algorithms. We use the k-club found by this new heuristic algorithm as
an initial feasible k-club. The second is to design simple and efficient reduction rules used
in each node of the search tree to reduce the size of the subproblem before branching. The
third is to have an efficient algorithm that computes an upper bound of sizes of k-clubs in
the graph associated with a node of the search tree. If this bound is not better than the
best solution found so far, then the branch-and-bound algorithm will terminate this node.
In [15] the authors find the k-clique number of the graph associated with each node of the
search tree as an upper bound. The main drawback of this approach is that the maximum
k-clique problem, which is NP-hard, must be solved to optimality to obtain a valid upper
bound. Inspired by branch-and-bound algorithms for solving the maximum clique prob-
lem, we came out with the idea using the k-coloring number as an upper bound. Later
we found the same technique was independently used in [59]. The k-coloring number of
a graph is the minimum number of colors one can use to color vertices of the graph such
that two vertices that are at a distance no more than k are in different colors. The size of
any feasible k-coloring of a graph can be used as an upper bound of the size of k-clubs
in the graph. During the execution, a branch-and-bound algorithm keeps on modifying
the input graph and storing partial results. Hence the fourth trick is to design efficient
dynamic data structures for storing the input graph and maintaining properties of the
graph. In each node of the branch-and-bound algorithm for finding a maximum k-club,
it tests whether the input graph is already a k-club and selects a vertex with minimum
k-neighborhood for branching if the input graph is not a k-club. Hence computing the k-
neighborhood of each vertex is a major procedure of the algorithm. Therefore we design
a dynamic data structure that stores the k-neighborhood of every vertex supporting vertex
deletion. We believe that this data structure is not only useful in the implementation of
7
tt
t
t t
t
t
t
t
t
t
❆
❆
❆
 
 
 
 
 
 
❅
❅
❅
❅❅
 
 
 
 
 
 
  
 
 
 ❅
❅
❅
v0
v1
v2
v3
v4
v5
v6
v7
v10
v9
v8
Figure 1: In this example graph, DROP finds 2-club {v5, v6, v7, v8, v9, v10} but IDROP finds
2-club {v0, v1, v2, v3, v4, v5, v6} of bigger size.
The idea behind the algorithm is that a maximum k-club may includes some vertices
whose k-neighborhood is not large but they are excluded from the solution obtained by
DROP. Fig. 1 shows an example graph in which DROP excludes those pendant vertices in
finding a 2-club and therefore it returns a 2-club of size smaller than that the one found
by IDROP. On our instances, IDROP always finds solutions that are at least as good as
DROP. From experimental results we observe that this algorithm never finds a solution
much inferior to those found by CONSTELLATION in our test instances.
A reduction rule
Let C be a k-club of graph G and v ∈ C. Then C is a subset of the k-neighborhood of v.
During the execution, a branch-and-bound algorithm maintains a best solution found so
far. Suppose the size of this solution is max. If the size of the k-neighborhood of a vertex
in the graph associated with a node of the search tree is no more than max, then we can
remove the vertex from the graph. We found this reduction rule is very useful in case the
variance of vertex degrees of the graph are large.
9
k-neighborhoods. In this report we independently designed a data structure called k-DN
for our special purpose. Later an anonymous reviewer reminded us that the dynamic
data structure described in [50] for directed graphs that supports edge deletion only and
maintains all-pairs shortest paths of length bounded by k can be applied for our purpose.
Since we solve the problem on undirected graphs, for the sake of completeness we
describe the data structure k-DN in this section. The data structure k-DN for undirected
graphs is able to maintain the k-neighborhood of each vertex after a series of vertex
deletion. In k-DN, each vertex of the input graph is identified by a number in {1, 2, . . . ,n}
where n is the number of vertices of the input graph. The basic building block of k-DN
is an array of n list nodes for each vertex i. Based upon this array we construct a double
linked list storing all vertices that are at distance d from vertex i for each 1 6 d 6 k. Any
vertex u other than i will be in at most a list of i and no matter u is in any list of i, the
list node storing u will be located at the u-th position of the array. For each vertex u in
a list of vertex i, we also store the distance between u and i in the graph and other data
that are important to our algorithm. For each u at distance d, 1 6 d 6 k, from vertex i,
we also maintain the number of vertices that are at distance d − 1 from vertex i and are
adjacent to vertex u. We call this number the upper degree of u with respect to vertex
i. In Fig. 2, we give an example to present a basic block of the k-DN data structure with
respect to vertex v0 in the graph shown in Fig. 1.
By using double linked list and a fixed-location for each node, a vertex can be inserted
into or deleted from a list in constant time. We can locate the set of vertices that are
at distance d from vertex i in constant time and report them in O(ℓ) time where ℓ is
the number of vertices that are at distance d from vertex i. In constant time, we can
report whether the distance between two vertices is greater than k or obtain the distance
between them if it is no more than k. The space used by the data structure is O(n2).
It can be constructed in O(nm) time as follows: First allocate an array of list nodes for
each vertex and initialize them. Then run a breadth-first traversal for each vertex i to
obtain the distance between i and any other vertex and then insert every vertex into the
11
Step 4. If h < k compute S as follows:
For each vertex s ∈ U and each neighbor t of s at distance h+ 1 from vertex j before
the deletion, decrease the upper degree of t with respect to j by one and insert t into
S if the upper degree of t with respect to vertex j becomes 0. Therefore S is the set
of vertices that are at distance h + 1 from vertex j before the deletion such that the
distance between vertex j and any vertex in S is increased after the deletion.
Step 5. Let U′ = U′ ∪U.
Step 6. Let U = S and h = h+ 1.
The correctness of the above procedure can be proved by induction. We claim that (1)
before each iteration, the lists storing vertices that are at distance less than h from vertex
j after the deletion are valid; (2) the distance after the deletion between vertex j and a
vertex s at distance h from vertex j before the deletion will be increased by the deletion
only if s ∈ U; and (3) the distance between vertex j and any vertex s ∈ U′ is at least h.
It is easy to check that all claims are true before each iteration. Hence the procedure
correctly updates the k-neighborhood of every vertex.
Next we analyze the time complexity of the update procedure. It is easy to see that it
takesO(deg(i)) to delete vertex i from the lists of vertex j that is in the k-neighborhood of
i, where deg(i) denote the degree of vertex i. For each vertex s in the k-neighborhood of
vertex j it takesO(k·deg(i)) time in total for all vertex deletions since it takesO(f·deg(i))
time in Step 2 if the distance between s and vertex j is increased by f in a deletion. And the
total distance increased is at most k − 1. Thus the overall running time of the procedure
of all deletions in updating the k-neighborhood of a vertex is
∑
i k · deg(i) and hence
the overall running time of the update procedure for all deletions is
∑
i
∑
i k · deg(i) =
O(knm). Thus we have the following result:
Theorem 2. The dynamic k-neighborhood of all vertices of a graph of n vertices andm edges
can be updated in O(km) amortized time for each vertex deletion.
13
some paper. Authors who are coauthors of Erdo˝s are called Erdo˝s 1 vertices and they are
adjacent to Erdo˝s. Authors who are not coauthors of Erdo˝s but are coauthors of some
of Erdo˝s’ coauthors are called Erdo˝s 2 vertices. In the experiment, we use ERDOS–x–
y to denote which network we consider where x represents the last two digits of the
year that the network was constructed and y represents the largest Erdo˝s number of an
author. For example, the vertices in ERDOS-99-2 correspond to 6100 authors who are
either coauthors of Erdo˝s or coauthors of one of Erdo˝s’ coauthors. Note that we use the
induced subgraphs where the vertex corresponding to Erdo˝s is excluded.
In Table 1, we compare the average size of k-clubs found by three heuristic algorithms,
CONSTELLATION, DROP, and IDROP in 100 random graphs. We also list the average size
of maximum k-clubs of those random graphs, for k = 2, 3, 4. From these results, we
see that in most cases IDROP returns large k-clubs which are very close to the optimum
solution. We developed two programs based on the same branch-and-bound algorithm
described in Section 4.1.1. One is using the size of the solution found by DROP as the
initial lower bound and the other is using the size of the solution found by IDROP. In
Table 2, we compare the performance of them. Since the solution of IDROP is at least
as good as the solution found by DROP, the number of leaves in the search tree with the
initial lower bound found by IDROP is always less than or equal to the number of leaves
in the search tree with the initial lower bound found by DROP. We also implement the
other two programs based on the branch-and-bound algorithm in Section 4.1.1, one is
applying the reduction rule given in Section 4.1.2, but the other is not. Both of them
use the k-DN data structure. In Table 3, we observe that by using this reduction rule the
number of leaves in the branch-and-bound search tree can be decreased and for those
random graphs with density 0.15 and 0.20, the running time can be slightly improved.
In Table 4, we test our programs on 100 random graphs of 150 vertices to compare the
performance of the program with k-DN data structure and the programwithout k-DN data
structure. In these experiment results, we see that the program with k-DN data structure
performs better than the other one. In Table 5 and 6, we list the size of k-clubs found by
15
Table 1: This table shows the average size of k-clubs, k = 2, 3, 4, found by CONSTELLATION,
DROP, and IDROP in a set of 100 random graphs of |V | = 150. We use bold texts to mark
those sizes of largest k-clubs found amongst the three heuristics.
k Density [a, b] CONSTELLATION DROP IDROP Exact
Size Time Size Time Size Time Size
2 0.05 [0.000, 0.100] 16.35 0.00 8.10 0.00 16.35 0.08 16.35
[0.025, 0.075] 16.31 0.00 8.22 0.00 16.31 0.08 16.31
[0.050, 0.050] 16.36 0.00 8.53 0.00 16.36 0.08 16.36
0.10 [0.050, 0.150] 26.47 0.00 14.34 0.00 21.10 0.15 26.47
[0.075, 0.125] 26.35 0.00 14.02 0.00 21.09 0.15 26.35
[0.100, 0.100] 26.15 0.00 13.94 0.00 20.69 0.15 26.15
0.15 [0.100, 0.200] 35.50 0.00 34.17 0.00 44.13 0.23 52.73
[0.125, 0.175] 35.17 0.00 32.73 0.00 42.98 0.24 52.91
[0.150, 0.150] 35.65 0.00 32.98 0.00 43.58 0.22 51.85
0.20 [0.100, 0.300] 44.24 0.00 130.71 0.00 133.85 0.06 134.31
[0.150, 0.250] 44.14 0.00 131.03 0.00 134.52 0.06 134.89
[0.200, 0.200] 44.77 0.00 131.83 0.00 135.10 0.05 135.45
3 0.05 [0.000, 0.100] 23.17 0.00 38.50 0.00 47.54 0.24 50.45
[0.025, 0.075] 22.84 0.00 38.36 0.00 48.58 0.20 51.59
[0.050, 0.050] 22.65 0.00 38.35 0.00 48.14 0.21 50.96
0.10 [0.050, 0.150] 38.94 0.00 149.82 0.00 149.82 0.00 149.82
[0.075, 0.125] 39.06 0.00 149.83 0.00 149.83 0.00 149.83
[0.100, 0.100] 38.05 0.00 149.81 0.00 149.81 0.00 149.81
4 0.05 [0.000, 0.100] 28.87 0.00 146.44 0.00 146.54 0.01 146.54
[0.025, 0.075] 27.86 0.00 146.41 0.00 146.48 0.01 146.48
[0.050, 0.050] 27.95 0.00 146.88 0.00 146.91 0.01 146.91
17
Table 3: In each row of the following table, we test on 100 random graphs, each of them
has 150 vertices. We create two copies of our program (with k-DN), one includes the data
reduction rule and the other does not. We list the results of the average running time and the
average number of leaves in the search tree for finding a maximum 2-club on those random
graphs.
density [a, b] with data reduction without data reduction
time # leaves time # leaves
0.05 [0.000, 0.100] 0.116 77.29 0.102 79.21
[0.025, 0.075] 0.117 78.60 0.104 80.44
[0.050, 0.050] 0.116 77.11 0.105 80.77
0.10 [0.050, 0.150] 1.020 3358.51 1.002 3781.51
[0.075, 0.125] 1.005 3152.54 0.979 3535.09
[0.100, 0.100] 1.008 3250.52 1.053 3665.53
0.15 [0.100, 0.200] 334.177 843763.15 329.875 903219.66
[0.125, 0.175] 389.458 962774.88 393.678 1034288.80
[0.150, 0.150] 318.306 900947.68 365.604 967441.72
0.20 [0.100, 0.300] 0.157 132.53 0.178 134.64
[0.150, 0.250] 0.139 117.77 0.173 118.32
[0.200, 0.200] 0.136 115.35 0.167 115.85
19
Table 5: This table presents the size of the maximum k-clubs, k = 2, 3, 4, in some DIMACS
graphs found by our program (with k-DN and the reduction rule) based on the branch-and-
bound algorithm described in Section 4.1.1 and the solution found by IDROP as the initial
lower bound. We also list the solution size of IDROP and DROP.
Graph Density Exact IDROP DROP
n k Size Time Size Time Size Time
c-fat200 0.08 200 2 18 0.01 18 0.01 18 0.00
3 24 0.04 24 0.03 24 0.00
4 30 0.06 30 0.06 30 0.00
0.16 200 2 35 0.07 35 0.07 35 0.00
3 46 0.21 46 0.18 46 0.00
4 57 0.40 57 0.36 57 0.00
0.43 200 2 87 0.70 87 0.59 87 0.00
3 200 0.03 200 0.01 200 0.00
4 200 0.04 200 0.00 200 0.00
c-fat500 0.04 500 2 21 0.08 21 0.05 21 0.00
3 28 0.13 28 0.13 28 0.00
4 35 0.24 35 0.23 35 0.00
0.07 500 2 39 0.35 39 0.26 39 0.00
3 52 0.64 52 0.62 52 0.00
4 65 1.31 65 1.29 65 0.00
0.19 500 2 96 3.59 96 2.80 96 0.00
3 128 7.81 128 7.73 128 0.00
4 159 19.25 159 18.37 159 0.00
21
4.2 The minimum k-club vertex cover problem
In this section, we discuss a variation of the vertex cover problem called the mini-
mum k-club vertex cover problem. The formal definition of this problem is listed in the
following.
Definition 1. Given a graph G = (V ,E) and an integer k. A k-club vertex cover S =
{S1,S2, . . . ,Sℓ} is a collection of k-clubs in G such that every vertex in G is in some Si
where Si ∈ S.
The minimum k-club vertex cover problem.
Input: Given an undirected graph G = (V ,E) and an integer k.
Output: A k-club vertex cover S with minimum cardinality.
Theorem 3. The minimum k-club vertex cover is NP-complete.
Proof. When k = 1, the special problem, minimum 1-club vertex cover, is also called the
minimum clique cover problem. It is equivalent to the well-investigated Graph Coloring
problem: A graph G has a vertex clique cover of size s if and only if its complement graph
can be colored with s colors such that two endvertices of edges in G have different colors.
This graph coloring problem is a well-known NP-complete problem. ✷
4.2.1 An exact algorithm
By modifying the branch-and-bound algorithm given in section 4.1.1, we can enumerate
a set of k-clubs, say C. The set C contains all maximal k-clubs and some non-maximal
k-clubs. Since k-club vertex cover can be reduced to the minimum set cover problem. For
the sake of completeness, we give the definition of the minimum set cover problem as
follows.
Minimum Set Cover problem
Input: A universal set U and a collection F = {C1,C2, . . . ,Cm} of subsets of U.
Output: A subset C ⊆ F with minimum cardinality such that
⋃
C∈C C = U.
23
can be taken as an upper bound of the minimum 3-club vertex cover problem. We list the
definition of the minimum dominating set and the minimum edge dominating set problem
as follows.
MINIMUM DOMINATING SET. Given a graph G = (V ,E), a dominating set S ⊆ V is a
vertex subset such that for all vertices v ∈ V either v ∈ S or v is adjacent to some vertex in
S. The minimum dominating set problem is to find the minimum cardinality of a dominat-
ing set in G. This is a NP-complete problem. It can be solved in O∗(1.5259n) (Chapter 6
of [34]).
MINIMUM EDGE DOMINATING SET. Given a graph G = (V ,E), an edge dominating
set M ⊆ E is a subset of edge set such that each edge in E shares an endpoint with
some edge inM. A minimum edge dominating set problem is to find an edge dominating
set of minimum cardinality. This is a NP-complete problem. There is a 2-approximation
algorithm for solving it [16]. Van Rooij and Bodlaender [70] give an O∗(1.3226n)-time
algorithm to solve the minimum edge dominating set problem exactly.
4.2.2 A heuristic algorithm: IDROP cover
Recall that in IDROP algorithm given a graph G = (V ,E) for each v ∈ V we construct
G[Nk(v)]. There are |V | = n new graphs G1,G2, . . . ,Gn being constructed, each one is
associated to specific vertex in G. And then for each Gi the IDROP algorithm call DROP
to find a k-club. Finally the algorithm returns the largest one found in those n graphs.
Suppose that the k-club found by DROP in Gi is Ci and Gi = Nk(vi) for vi ∈ V . Sort
C1,C2, . . . ,Cn according to their cardinality in decreasing order. Without lost generality
assume that |C1| > |C2| > · · · > |Cn|. Let S be a set of k-clubs. Initially set S = {C1}
Algorithm IDROP COVER
1. S = {C1}
2. For i = 2, . . . ,n, if vi 6∈
⋃
1<j<i{Cj|Cj ∈ S}, then S = S ∪ {Ci}.
3. Return S.
25
5. Return S.
Lemma 8. The set S found by Algorithm CONSTELLATION COVER is a k-club vertex cover.
Proof. In Step 1 of the algorithm, for each vi ∈ V , there existsWi(k) containing vi. Each
vi belongs to its correspondingWi. The algorithm always selectsWi to be a member of S
when its corresponding vertex vi is uncovered. It is easy to see that the algorithm returns
a set S such that
⋃
Wj∈S
Wj = V . This completes the proof. ✷
Theorem 9. The running time of Algorithm CONSTELLATION COVER is O(knm).
Proof. The running time of CONSTELLATION is O(k(n +m)) [14]. Algorithm CONSTEL-
LATION COVER iteratively executes Algorithm CONSTELLATION for n time. In Step 1 of
the algorithm it takes O(k(n2 + nm)) time to computeW1, . . . ,Wn. To sort them spends
O(n logn) time. It takes O(n2) time to obtain a k-club vertex cover in Step 4. Thus the
total running time of Algorithm CONSTELLATION COVER is O(knm). This completes the
proof. ✷
4.2.4 Experiment Results
We have implemented two heuristic algorithms, IDROP COVER and CONSTELLATION COVER,
for finding a k-club vertex cover. The program is implemented in C and all experiments
were conducted on an ASUSr workstation AS-D900 with Intelr Core i7 2.67 GHz and
12.00 GB ram and performed with single threaded workloads. The execution time of
those experiment results is measured in seconds.
In Table 7, 8, and 9, we list the average size of k-club vertex cover, k = 2, 3, 4, found
by IDROP COVER and CONSTELLATION COVER in 100 random graphs, respectively. Each
of those random graphs has 150 vertices. From those experiment results, we see that
when the density of input graphs is small, the size of k-club cover found by CONSTELLA-
TION COVER is smaller the one found by IDROP COVER. Conversely when the density of
input graph is large, IDROP COVER returns a k-club vertex cover is smaller than the one
returned by CONSTELLATION COVER.
27
Table 8: This table presents the average size of 3-club vertex cover found by IDROP COVER
and CONSTELLATION COVER and their average running time for finding those 3-club vertex
cover on 100 random graphs, |V | = 150.
k Density [a,b]
IDROP COVER CONSTELLATION COVER
# 3-clubs Time # 3-clubs Time
3 0.030 [0.000, 0.060] 45.64 0.168 34.35 0.000
[0.015, 0.045] 48.08 0.165 34.85 0.000
[0.030, 0.030] 45.61 0.168 33.92 0.000
0.050 [0.000, 0.100] 49.33 0.303 25.14 0.000
[0.025, 0.075] 49.08 0.312 25.20 0.000
[0.050, 0.050] 48.80 0.312 24.90 0.000
0.075 [0.025, 0.125] 7.51 0.118 18.79 0.000
[0.050, 0.100] 7.40 0.116 18.96 0.000
[0.075, 0.075] 7.96 0.081 18.80 0.000
0.100 [0.050, 0.150] 1.18 0.061 15.25 0.003
[0.075, 0.125] 1.17 0.061 15.27 0.003
[0.100, 0.100] 1.19 0.061 14.99 0.003
0.125 [0.075, 0.175] 1.00 0.052 12.94 0.000
[0.100, 0.150] 1.01 0.052 12.74 0.000
[0.125, 0.125] 1.00 0.050 13.00 0.000
0.150 [0.100, 0.200] 1.00 0.060 11.03 0.010
[0.125, 0.175] 1.00 0.060 11.23 0.010
[0.150, 0.150] 1.00 0.060 11.40 0.010
0.200 [0.100, 0.300] 1.00 0.060 8.92 0.011
[0.150, 0.250] 1.00 0.060 8.90 0.011
[0.200, 0.200] 1.00 0.060 8.65 0.011
0.250 [0.150, 0.350] 1.00 0.064 7.13 0.020
[0.200, 0.300] 1.00 0.064 7.15 0.020
[0.250, 0.250] 1.00 0.064 7.40 0.020
29
4.3 The maximum k-plex problem
In this section, we discuss some approaches found in literatures for solving the maxi-
mum k-plex problem.
Given a graph G = (V ,E), a k-plex in G is a subset S ⊆ V such that for all v ∈ S,
degG[S](v) > |S|−k. The maximum k-plex problem is to find a k-plex in G with maximum
cardinality.
4.3.1 Integer programming formulation
In [8], Balasundaram showed that the maximum k-plex problem can be formulated as a
0-1 integer programming formulation. Given a graph G = (V ,E) with |V | = n. Recall that
NG[v] is the closed neighborhood of a vertex v.
ωk(G) = max
∑
v∈V
xv
subject to:
∑
w∈V−NG[v]
xw 6 (k− 1)xv + (n − |NG[v]|)(1 − xv) ∀v ∈ V
xv ∈ {0, 1} ∀v ∈ V
In this formulation, xv = 1 if v ∈ V is in the k-plex and xv = 0 otherwise. The first
constraint ensures that if v is in k-plex, it has at most k − 1 non-neighbors. The first
constraint is redundant if v is not in k-plex. This gives a vector x ∈ {0, 1}n is feasible if and
only if its corresponding vertex set forms a k-plex. The objective function then returns the
size of maximum k-plexes.
For solving this integer programming, a branch-and-cut algorithm is developed in [8].
This algorithm is similar to branch-and-bound algorithms, it works in a search tree. At
each search node, it creates two branches by fixing a particular variable to be zero or
one. At such a node, solving the linear programming (LP) relaxation gives an upper
31
4.3.2 Approaches by adapting combinatorial clique algorithms
In [60], McClosky and Hicks gave two exact algorithms to solve the maximum k-plex prob-
lem. The first algorithm takes co-k-plex heuristic coloring as the upper bound and uses
a k-plex heuristic to find the lower bound. The second algorithm adapts the O¨sterga˚rd’s
clique algorithm [68] for solving the maximum k-plex problem. Suppose that ωk(G) =
|S∗| where S∗ denotes a maximum k-plex in G.
Definition 2 ([73]). Given a graph G = (V ,E), C ⊂ V induced a co-k-plex if ∆(G[C]) 6
k− 1 where ∆(G[C]] is the maximum degree in G[C].
Definition 3 ([60]). A co-k-plex coloring of a graph G is defined by a collection of vertex
sets C1, . . . ,Cm where each Ci is a co-k-plex and C1, . . . ,Cm partition V .
Lemma 12 ([60]). Any co-k-plex coloring satisfies the following inequality
ωk(G) = |S
∗| =
m∑
i=1
|S∗ ∩ Ci| 6
m∑
i=1
ωk(G[Ci]).
Let χk(G) be the co-k-plex chromatic number of G and let Π denote the set of all co-k-
plex colorings of G.
Lemma 13 ([60]).
χk(G) = min{
∑
C∈C
ωk(G[C]) | ∈Π}.
McClosky and Hicks gave an integer programming formulation for the maximum k-
plex problem based on the k-co-plex coloring. We list it in the following.
max{x(V) | x ∈ {0, 1}, x(C) 6 ωk(G[C]) for all C ∈ I}.
Here x(A) =
∑
v∈A xv, xv = 1 if v is in a maximum k-plex, otherwise xv = 0, and I
denotes the set of all co-k-plexes in G. Let Iv denote the set of co-k-plex containing v. The
above integer programming has the following dual form.
min{
∑
C∈I
ωk(G[C])yC | y ∈ {0, 1},y(Iv) > 1 for all v ∈ V}. (1)
33
These feasible y¯ imply that
ωk(G) 6
1
p
h∑
i=1
ωk(G[Ci])y¯Ci .
FCCH(V) [60]
1. told =∞; p = 1
2. tnew =ICCH(V); store the partition sets in C
3. while tnew < told
4. U = V; told = tnew; p = p+ 1
5. for all v ∈ U
6. if ∃Ci ∈ C such that v 6∈ Ci and Ci + v is a co-k-plex
7. Ci = Ci + v; U = U − v
8. end
9. end
10. ICCH(U); append new partition sets in C
11. Compute ji = max{m | am > k+m} for each Ci ∈ C
12. tnew =
1
p ·
∑
Ci∈C
min{2k − 2+ k mod 2,k+ ji,∆(G[Ci]) + k, |Ci|}
13. end
14. return told
Lemma 18 ([60]). If the number of iterations and the number of partition sets are O(n),
then the running time of FCCH heuristic is O(n4).
Lower Bound. Any feasible k-plex provides lower bound of ωk(G). Since a clique
must be a k-plex and this clique forms an independent set in the complement graph G¯,
McClosky and Hicks use a heuristic algorithm to find a large independent set in G¯ and
then extend the set to an maximal k-plex in G.
Given a w ∈ V , define the following sets in G¯.
S0 = {v ∈ V | distG¯ even } and S1 = {v ∈ V | distG¯ odd }.
35
an subset of V , i = 1, . . .n. It is easy to see that V1 = V and Vn = {vn}. Let ck(i) denote
the cardinality of maximum k-plexes in G[Vi]. S is the partial solution obtained so far.
Let U be the set that for all u ∈ U S + u is a k-plex. Obviously ωk(G[U]) 6 ck(i) where
i = min{j | vj ∈ U}.
OsterPlex(U,S)
1. if |U| = 0
2. if |K| > max
3. max = |S|
4. found−true
5. end
6. return
7. end
8. while U 6= ∅
9. if |S|+ |U| 6 max
10. return
11. end
12. i = min{j | vj ∈ U}
13. if |S|+ ck(i) 6 max
14. return
15. end
16. S ′ = S+ vi; U = U− vi
17. U ′ = {u ∈ U | S+ u is a k-plex}
18. OsterPlex(U ′,S ′)
19. if found=ture
20. return
21. end
22. end
23. return
37
Theorem 19. Minimum 1-bounded-degree-deletion is solvable in O(2.31t · t2 + tn) time
where t is an input parameter that indicates at most t vertices can be deleted from G.
The above branching rules can be extended to the general minimum d-bounded-
degree problem. Suppose H = (V , F) is an input instance of the minimum d-bounded-
degree problem and s is an upper bound of the number of vertices to be deleted. Moser
et al. gave the following reduction rules to enhance the efficiency of the algorithm.
• Remove each vertex v from H for which ∀w ∈ N[v] degH(w) 6 d.
• Remove v if degH(v) > d+ s.
• Remove v if there are (d+ 1) neighbors of v with degree 1 in H.
• Suppose that X is the set of vertices to be removed at this moment to obtain H− X,
a bounded-degree-d graph. If |N(X)| > (d + 1) · |X| then use the algorithm given
in [31] to obtain vertex sets A and B, remove all vertices in A.
The fixed parameter algorithm for solving the minimum d-bounded-degree deletion
problem proceeds the above reduction rules in each branch node in the search tree. It
computes |X| as an upper bound at each branch node and uses the |X| to detect better
branches called guided branches. From the experiment results, they showed that with
guided branches the exact algorithm is more efficient.
4.3.4 New branch-and-bound algorithms for solving the maximum 2-plex
problem
A graph is a k-plex if every vertex has at most k− 1 non-neighbors. We also refer to a set
K of vertices of graph G as a k-plex of G if G[K] is a k-plex. A maximum k-plex of G is a k-
plex of G of maximum cardinality. Letωk(G) denote the cardinality of a maximum k-plex
of G. To improve the combinatorial algorithms mentioned above, we tried to combine
the merits of them. The new algorithm adapts the branching technique and reduction
rules used in [63] and the iterative improving technique used in [60]. The algorithm
is as follows. First, it computes an ordering, x0, x1, . . . , xn−1, of vertices satisfying the
39
• For each u ∈ D2R(v), where D
2
R(v) = {u ∈ R | dist(u, v) = 2in G[R]}, let S = {v,u} ∪ S
and R = {r ∈ R | (r, v), (r,u) ∈ E(G)}.
From the above branching rule, we can see that the algorithm maintains the following
invariant: Every vertex in R is adjacent to all vertices in S. For each branch, we implement
the reduction rule used in [63]: If a vertex v ∈ R such that the degree of v in G[R] is no
more than (maxj−1+1)− |S|−1 = maxj−1− |S|, then remove v from R. We also implement
the following bounding rule in each branch: If |S| + |R| 6 maxj−1, then stop the branch.
Once upon we find that |S| > maxj−1 or that R is a 2-plex of Gj and |S| + |R| > maxj−1,
then it returnmaxj = maxj−1 + 1 and Pj = S ∪ R.
The pseudo code of the algorithm described above is given in section 4.3.4. Algorithm
2-plex-pj(j) determines whether Gj has a 2-plex containing xj and of size greater than
maxj−1. Given two disjoint subsets S and R of V where S is a 2-plex and R is the set of
vertices that are in V \ S and adjacent to all vertices in S, Algorithm 2-plexOS determines
whether G has a 2-plex containing S, contained in S ∪ R, and of size greater than max.
From another point of view, it determines whether G has a 2-plex contained in R and of
size greater than max− |S|.
We implement Algorithm YOC and run some benchmark instances. Our experiments
showed that if a solution is found, then the running time of this algorithm is faster than
both programs described in [63] and [60]. Our program run faster than the program
described in [63] in all cases. But there still are some instances that the program described
in [60] found a solution in one hour but ours did not.
Consider Algorithm 2-plex-pj(j). There is a branch that call Algorithm 2-plexOS in
Phase I and there is d branches that call Algorithm 2-plexOS. Notice that if the size of
a maximum 2-plex contained in NGj(X[j]) is of size less than maxj−1 − 1, then the set
{X[j]} ∪ {v ∈ Xj | (v,X[j]), (v,u) ∈ E(G)} will not contain a 2-plex of size greater than
maxj−1 for any u ∈ D
2
j (X[j]) = {u ∈ Xj | distGj(u,X[j]) = 2}. That is, if we can determine
that NGj(X[j]) does not contain any 2-plex of size greater than maxj−1 − 1 in Phase I of
Algorithm 2-plex-pj(j), then we can skip Phase II of Algorithm 2-plex-pj(j). We implement
41
Algorithm Y2C
S : Solution vertex set. s: |S|
R : Remain vertex set. r: |R|
Global: G, Plex = ∅
Initialize S = ∅,R = V ,Plex← HeuristicYC(),max = |Plex|.
Algorithm Y2C(S,R, s, r)
1. while s+ r > max and ∃v ∈ R : degG[R](v) < max− s − 1
2. R← R \ {v}, r = r− 1.
3. end
4. if s + r 6max then return
5. if G[S] is not k-plex return
6. if degG[R+S](v) > r+ s − 2
7. max = s + r
8. plex = S ∪ R
9. return
10. end
11. Arbitrarily choose a vertex v with minimum degree in G[R].
12. Y2C(S,R \ {v}, s, r − 1)
13. Y2C(S ∪ {v},R, s + 1, r)
14. return
43
Algorithm YOC
S : Solution vertex set. s: |S|
R : Remain vertex set. r: |R|.
Xj = {X[0],X[1], ...,X[j]}
Global: max=0, found, X
Algorithm. YOC(G)
1. The first phase of the algorithm is to determine the ordering x0, x1, . . . , xn−1 of ver-
tices.
2. Initially, R← V , j← |V |− 1.
3. while (G[R] is not a 2-plex)
4. Arbitrarily choose a vertex v ∈ R of minimum degree in G[R]
5. X[j]← v,R← R \ {v}, j← j− 1.
6. end while
7. Now R is a 2-plex of G and |R| == j + 1. Let h← j.
8. while(R 6= ∅)
9. Arbitrarily choose a vertex v ∈ R with minimum degree in G[R]
10. X[j]← v,R← R \ {v}, j← j− 1.
11. end while
12. The second phase is to determine whether pj > maxj−1 for all h < j < |V |.
13. max← h+ 1.
14. for j from h+ 2 up to |V |− 1
15. Determine whether Gj has a 2-plex containing X[j] and of size greater than max. If
yes, update max.
16. 2-plex-pj(j)
17. end for
18. return max.
19. end
45
S : Solution vertex set. s: |S|
R : Remain vertex set. r: |R|
Global: G, Plex = ∅
Algorithm. 2-plexOS(S,R, s, r)
Given two disjoint subsets S and R of V where S is a 2-plex and R is the set of vertices that
are in V \ S and adjacent to all vertices in S, Algorithm 2-plexOS determines whether G
has a 2-plex containing S, contained in S∪R, and of size greater thanmax. From another
point of view, it determines whether G has a 2-plex contained in R and of size greater than
max− |S|.
1. Phase I. Reduction, bounding, and termination phase.
2. while (s+ r > max and there exists v ∈ R such that degG[R](v) < max − s− 1)
3. R← R \ {v}, r← r − 1.
4. end while
5. if s + r 6max then return
6. while (there exists v ∈ R such that degG[R](v) = r − 1)
7. S← S ∪ {v}, s← s + 1,R← R \ {v}, r← r − 1
8. end while
9. if ∀v ∈ R,degG[R](v) 6 r− 2
10. max← s + r
11. plex← S ∪ R
12. found← true
13. return
14. end if
15. Phase II. Remove a vertex v from R.
16. Arbitrarily choose a vertex v ∈ R with minimum degree in G[R]
17. R ′ = R \ {v}, r ′ ← r− 1
18. 2-plexOS(S,R ′, s, r ′)
19. if found← true return
47
Algorithm YSC
If a solution of size greater than max is found then returnmaxFlag;
else if a solution of size max, then return nextFlag;
else return lessFlag.
S : Solution vertex set. s: |S|
R : Remain vertex set. r: |R|
maxFlag = 1, nextFlag = 2, lessFlag = 3
Global: G, Plex = ∅.
Initialize S = ∅,R = V , Flag,Plex← HeuristicYC(),max = |Plex|.
Algorithm. YSC(S,R, s, r) ✄ return maxFlag, nextFlag or lessFlag
1. while s+ r > max and ∃v ∈ R :degG[R](v) < max − s− 2
2. R← R \ {v}, r = r− 1.
3. end
4. if s + r < max then return lessFlag
5. if ∀v ∈ R,degG[R](v) > r− 2
6. if s + r > max
7. max = s + r
8. plex← S ∪ R
9. return maxFlag
10. end
11. else return nextFlag
12. end
13. Arbitrarily choose a vertex v with minimum degree in G[R].
14. Flag =YSC(S,R \ {v}, s, r − 1)
15. if s > 0 and Flag = maxFlag return maxFlag
16. if Flag = lessFlag return nextFlag
49
Algorithm OSYC
S : Solution vertex set. s: |S|, Vi = {X[0],X[1], ...,X[i]}
R : Remain vertex set. r: |R|.
Global: max = 0, X
Algorithm. OSYC(S,R, s, r)
R = V , i = |V |− 1,
1. while G[R] is not a 2-plex
2. Arbitrarily choose a vertex v ∈ R with minimum degree in G[R]
3. X[i] = v,R← R \ {v}, i = i− 1
4. end
5. for(j = 0; j 6 i; j = j+ 1)
6. Arbitrarily choose a vertex v ∈ R with maximum degree in G[R]
7. X[j] = v, R← R \ {v}
8. end
9. i = i+ 1, max = j
10. i = i+ 1
11. for j = i up to |V |− 1
12. v = X[j]
13. Compute T = {u ∈ Vj|u and v are true twins in G[Vj]}
14. if T 6= ∅
15. S← {v} ∪ T , R← (Vj \ T) ∩NG(v)
16. if |S| > max
17. max = |S|, plex← S
18. continue
19. end
20. if |R| > max − |S|
51
49. return
If a solution of size greater than max is found then returnmaxFlag;
else if a solution of size max, then return nextFlag;
else return lessFlag.
S : Solution vertex set. s: |S|
R : Remain vertex set. r: |R|
maxFlag = 1, nextFlag = 2, lessFlag = 3
Global: G, Plex = ∅.
Initialize Flag,Plex← HeuristicYC(),max = |Plex|.
Algorithm. plexOS1(S,R, s, r)✄ return maxFlag, nextFlag or lessFlag
1. if s > max
2. max = s
3. plex← S
4. return maxFlag
5. end
6. while s+ r > max and ∃v ∈ R : degG[R](v) < max− s − 2
7. R← R \ {v}, r = r− 1.
8. end
9. if s + r < max then return lessFlag
10. if ∀v ∈ R,degG[R](v) > r− 2
11. if s + r > max
12. max = s + r
13. plex← S ∪ R
14. return maxFlag
15. end
16. end
17. else return nextFlag
53
45. S ′ ← S ∪ {v,u}, R ′ ← R ∩NG(v) ∩NG(u).
46. Flag =2-plexOS1(S ′,R ′, s + 2, |R ′ |)
47. if Flag = maxFlag returnmaxFlag
48. end
49. return nextFlag
4.3.5 Experiment results.
The program is implemented in C and all experiments were conducted a 1.8 GHz Intel(R)
Core(TM)2 CPU 1.86GHz with 0.99GB of memory, with single threaded, and the execu-
tion time is measured in seconds.
We demonstrate three programs implemented based on three branch-and bound al-
gorithms, YOC, YSC, and OSYC for finding a maximum 2-plex on Erdo˝s networks and
DIMACS graphs. From those experiment results, we see that YSC has less running time
than OSYC, but the number of branch nodes of YSC is more than OSYC’s. The advantage
of OSYC is that it has the least number of branch nodes amongst the three branch-and-
bound algorithms. When we take those Erdo˝s networks as input instance, from those
experiment results, we see that the performance of YSC and OSYC is better than bdd-
solver [63]. When taking DIMACS graphs as input instances, we obtain that our program
cannot find the optimum solution within an hour if the input graph has density more than
0.5 and has number of vertices more than 200. When taking those sparse graphs as input
instance, our programs are very efficient.
55
Table 11: This table presents the size of maximum 2-plex in Erds˝s networks and the running
time of YOC and branching nodes in the branch-and-bound search tree of YSC. B-Nodes
denote the branching nodes in the branch-and-bound search tree. The Dens. denotes the
density of the graphs. We compare YSC with the algorithm bdddsolver in [63].
G |V | |E| Dens. Exact YSC bddsolver
time B–Nodes no guide guide
time B–Nodes time B–Nodes
ERDOS–97–1 472 1317 0.011 8 0.343 75 0.9 179 0.3 311
ERDOS–98–1 485 1381 0.011 8 0.375 85 1.1 201 0.4 358
ERDOS–99–1 492 1417 0.11 8 0.396 87 1.2 212 0.4 357
ERDOS–97–2 5488 8972 0.00059 8 2.11 136 12.7 187 8.6 502
ERDOS–98–2 5822 9509 0.00059 8 2.485 153 33.1 181 9.8 398
ERDOS–99–2 6100 9939 0.00059 8 2.73 260 44.1 194 11.0 414
57
Table 13: We take a set of DIMAC graphs as input graphs. This table presents the execution
time of YOC and the number of branching nodes in the branch-and-bound search tree of
YOC for finding a maximum 2-plex. For those cases that the program is not able to find the
optimum solution within an hour, we let the program return the current best solution and we
use bold texts to mark the 2-plex that is larger than the others. For those cases that we have
no exact solution, we use ’–’ to mark them. B-Nodes denote the number of branching nodes
in the branch-and-bound search tree. We compare our YOC algorithm with the OsterPlex
algorithm implemented in [60].
G |V | |E| Dens. Exact YOC OsterPlex
sol. time B–Nodes sol. time B–Nodes
brock200-1 200 14843 0.74 – 25 > 3600 11216384 23 > 3600 983266832
brock200-2 200 9876 0.49 13 13 12.14 159746 13 74 19636408
brock200-4 200 13089 0.66 – 19 > 3600 6104635 19 > 3600 917681365
brock400-2 400 59786 0.74 – 28 > 3600 5696693 23 > 3600 989222371
brock400-4 400 59765 0.71 – 28 > 3600 7027695 23 > 3600 926436143
brock800-2 800 208166 0.65 – 22 > 3600 7571080 21 > 3600 919220732
brock800-4 800 207643 0.65 – 21 > 3600 7882427 20 > 3600 996101972
c-fat200-1 200 1534 0.07 12 12 0.16 115 12 0.0 3677
c-fat200-2 200 3235 0.16 24 24 0.31 19 24 0.0 1895
c-fat200-5 200 8473 0.42 58 58 0.297 69 58 0.0 760
c-fat500-1 500 4459 0.03 14 14 0.094 210 14 0.0 19733
c-fat500-2 500 9139 0.07 26 26 0.234 337 26 0.0 10081
c-fat500-5 500 23191 0.18 64 64 0.828 142 64 0.0 4159
hamming6-2 64 1827 0.91 32 32 1.75 7620 32 0.0 396
hamming6-4 64 704 0.34 6 6 0.016 601 6 0.0 4526
hamming8-2 256 31616 0.96 128 128 > 3600 465693 128 0.0 7448
hamming8-4 256 20864 0.64 – 16 > 3600 9407503 16 47 7982728
hamming10-2 1024 518656 0.99 512 512 > 3600 359018 512 33 147919
hamming10-4 1024 434176 0.82 – 41 > 3600 5699607 41 > 3600 595181620
59
Table 15: We take a set of DIMAC graphs as input graphs. This table presents the execution
time of YSC and the number of branching nodes in the branch-and-bound search tree of
YSC for finding a maximum 2-plex. For those cases that the program is not able to find the
optimum solution within an hour, we let the program return the current best solution and we
use bold texts to mark the 2-plex that is larger than the others. For those cases that we have
no exact solution, we use ’–’ to mark them. B-Nodes denote the number of branching nodes
in the branch-and-bound search tree. We compare our YSC algorithm with the OsterPlex
algorithm implemented in [60].
G |V | |E| Dens. Exact YSC OsterPlex
sol. time B–Nodes sol. time B–Nodes
brock200-1 200 14843 0.74 – 25 > 3600 12757536 23 > 3600 983266832
brock200-2 200 9876 0.49 13 13 8.297 88644 13 74 19636408
brock200-4 200 13089 0.66 – 19 > 3600 11514774 19 > 3600 917681365
brock400-2 400 59786 0.74 – 28 > 3600 23281014 23 > 3600 989222371
brock400-4 400 59765 0.71 – 27 > 3600 7895120 23 > 3600 926436143
brock800-2 800 208166 0.65 – 21 > 3600 7896393 21 > 3600 919220732
brock800-4 800 207643 0.65 – 21 > 3600 7820206 20 > 3600 996101972
c-fat200-1 200 1534 0.07 12 12 0.013 18 12 0.0 3677
c-fat200-2 200 3235 0.16 24 24 0.047 11 24 0.0 1895
c-fat200-5 200 8473 0.42 58 58 0.11 30 58 0.0 760
c-fat500-1 500 4459 0.03 14 14 0.437 24 14 0.0 19733
c-fat500-2 500 9139 0.07 26 26 0.5 30 26 0.0 10081
c-fat500-5 500 23191 0.18 64 64 0.719 33 64 0.0 4159
hamming6-2 64 1827 0.91 32 32 1.75 14506 32 0.0 396
hamming6-4 64 704 0.34 6 6 0.016 276 6 0.0 4526
hamming8-2 256 31616 0.96 128 128 > 3600 471085 128 0.0 7448
hamming8-4 256 20864 0.64 – 16 > 3600 8588023 16 47 7982728
hamming10-2 1024 518656 0.99 512 512 > 3600 7983 512 33 147919
hamming10-4 1024 434176 0.82 – 41 > 3600 3571325 41 > 3600 595181620
61
Table 17: We take a set of DIMAC graphs as input graphs. This table presents the execution
time of OSYC and the number of branching nodes in the branch-and-bound search tree of
OSYC for finding a maximum 2-plex. For those cases that the program is not able to find the
optimum solution within an hour, we let the program return the current best solution and we
use bold texts to mark the 2-plex that is larger than the others. For those cases that we have
no exact solution, we use ’–’ to mark them. B-Nodes denote the number of branching nodes
in the branch-and-bound search tree. We compare our OSYC algorithm with the OsterPlex
algorithm implemented in [60].
G |V | |E| Dens. Exact OSYC OsterPlex
sol. time B–Nodes sol. time B–Nodes
brock200-1 200 14843 0.74 – 25 > 3600 8613977 23 > 3600 983266832
brock200-2 200 9876 0.49 13 13 24.531 159541 13 74 19636408
brock200-4 200 13089 0.66 – 19 > 3600 6102824 19 > 3600 917681365
brock400-2 400 59786 0.74 – 28 > 3600 32852707 23 > 3600 989222371
brock400-4 400 59765 0.71 – 27 > 3600 5240549 23 > 3600 926436143
brock800-2 800 208166 0.65 – 22 > 3600 5536441 21 > 3600 919220732
brock800-4 800 207643 0.65 – 21 > 3600 4797955 20 > 3600 996101972
c-fat200-1 200 1534 0.07 12 12 0.125 0 12 0.0 3677
c-fat200-2 200 3235 0.16 24 24 0.141 0 24 0.0 1895
c-fat200-5 200 8473 0.42 58 58 0.188 0 58 0.0 760
c-fat500-1 500 4459 0.03 14 14 1.828 0 14 0.0 19733
c-fat500-2 500 9139 0.07 26 26 1.906 0 26 0.0 10081
c-fat500-5 500 23191 0.18 64 64 2.712 0 64 0.0 4159
hamming6-2 64 1827 0.91 32 32 2.016 6338 32 0.0 396
hamming6-4 64 704 0.34 6 6 0.047 551 6 0.0 4526
hamming8-2 256 31616 0.96 128 128 > 3600 435200 128 0.0 7448
hamming8-4 256 20864 0.64 – 16 > 3600 5999155 16 47 7982728
hamming10-2 1024 518656 0.99 512 512 > 3600 211156 512 33 147919
hamming10-4 1024 434176 0.82 – 41 > 3600 3146083 41 > 3600 595181620
63
Table 19: This table presents the maximum size of 2-plex, found by YOC, YSC, and OSYC in
Erdo˝s networks including the execution time and number of branch nodes in the correspond-
ing branch-and-bound search trees.
G Exact YOC YSC OSYC
time B–Nodes time B–Nodes time B–Nodes
ERDOS–97–1 8 0.104 394 0.343 75 1.594 62
ERDOS–98–1 8 0.116 423 0.375 85 1.719 73
ERDOS–99–1 8 0.127 498 0.396 87 1.859 77
ERDOS–97–2 8 2.165 1804 2.110 136 3.127 135
ERDOS–98–2 8 3.283 1892 2.485 153 3.519 152
ERDOS–99–2 8 4.617 1951 2.730 260 3.904 158
65
Table 21: This table presents the size of maximum 2-plexes, found by YOC, YSC, and OSYC in
DIMACS graphs. For those cases the program cannot find optimum solution within an hour,
we let the program returns the current best solution. We use bold texts to mark the larger
one among those non-optimum solutions.
G Exact YOC YSC OSYC
sol. time B–Nodes sol. time B–Nodes sol. time B–Nodes
johnson8-2-4 5 5 0.000 127 5 0.000 171 5 0.000 126
johnson8-4-4 14 14 1.750 51456 14 1.890 71534 14 3.125 50226
keller4 15 15 103.344 1999144 15 53.484 1124565 15 163.922 1085656
MANN-a9 26 26 1.719 24801 26 1.719 14508 26 0.500 2811
MANN-a27 – 234 > 3600 234819 234 > 3600 107963 234 > 3600 7863
MANN-a45 – 660 > 3600 17741 660 > 3600 4885 660 > 3600 4681
p-hat300-1 10 10 1.579 10246 10 1.895 11672 10 3.152 10234
p-hat300-2 – 30 > 3600 17996698 30 > 3600 4285471 30 > 3600 2084033
p-hat300-3 – 43 > 3600 48105968 43 > 3600 8576352 43 > 3600 3560785
p-hat700-1 13 13 206.109 514022 13 243.187 513590 13 336.328 432358
p-hat700-2 – 48 > 3600 4920018 50 > 3600 4818194 48 > 3600 4818194
p-hat700-3 – 46 > 3600 2256101 46 > 3600 2657812 46 > 3600 1362099
san200-0.7-2 – 26 > 3600 2006033 24 > 3600 4595069 26 > 3600 1910612
san200-0.9-1 – 90 > 3600 2237891 90 > 3600 1725562 90 > 3600 1265358
67
Proof. It is easy to see that the number of maximal k-plexes is less than the number of
subsets of the vertex set. In [79], an O∗(2n) time algorithm is given to enumerate all
maximal k-plexes in a given graph. ✷
Theorem 22. The minimum k-plex vertex cover problem can be solved in O∗(4n) time.
Proof. The first step is applying algorithm YC given in section 4.3.4 or the algorithm given
in [79] to enumerate a set of k-plexes C that contains all maximal k-plexes. This can be
done in O∗(2n) time and |C| = O(2n). Let V = U and C = F be the input of the minimum
set cover problem. The second step is using that dynamic programming algorithm to find
a minimum set cover. This can be done in O(n · 2n · 2n) = O∗(4n). ✷
Remark 2. This exact algorithm is not very practical because there are at most 2n maxi-
mal k-plexes and the 2n subsets of V , by applying the dynamic programming algorithm
to solve the minimum set cover problem would need O(4n) memory space. There is an-
other exact algorithm given by van Rooij and Bodlaender in [71] with worst case running
time O∗(1.2302|U|+|F|). The algorithm solves the minimum set cover in polynomial space,
polynomial of |U| and |F|. By applying it the minimum k-club vertex cover can be solved
in time O∗(1.2302n+2
n
) which is much worse than the dynamic programming algorithm.
69
of G¯ is p. It is easy to see that the maximum k-plex in G is of size (n− p).
A series of fixed algorithms were developed for solving the d-BDD problem [66, 53?
]. For the special case 1-BDD, in [63], Moser et. al. provided a fixed-parameter algorithm
running in O(2.31p + pn) time based on bounded search trees and gave an iterated-
compression algorithm for the same problem with running time O(2p · p2 + pn). The
fixed-parameter algorithm based on bounded search tree in [63] can be modified to be
an exact algorithm for solving the MIN-1-BDD problem with running time O∗(1.8637n).
Chen et al. gave a fixed-parameter algorithm running in time O∗(3.24p) for solving the
2-BDD problem [20]. Fellows et al. showed that for unbounded d values, the d-BDD
problem is W[2]-complete [? ]. In [? ], Balasundaram et al. referred that the MAX-d-BDS
problem is as the problem of finding maximum-cardinality co-(d+ 1)-plexes.
4.5.1 An exact algorithm for MAX-1-BDS
In this section, our aim is to present a branching algorithm to compute a maximum
bounded-degree-1 subset of an undirected graph.
When the algorithm puts a vertex v into the solution set, we say that it selects v. When
the algorithm decides that a vertex v is not in the solution set, we say that it discards v.
Before explaining the algorithm in detail, we describe the main rules that the algorithm
will apply. Some proofs are omitted due to the space limit. For simplicity, we denote the
size of a maximum bounded-degree-d subset of an undirected graph G by βd(G). We give
the following simple observations.
Lemma 23 (Disconnected Rule). If G is disconnected and C is a component of G, then
β1(G) = β1(G[C]) + β1(G \ C).
Proof. Since G is disconnected and C is a component of G and β1(G) is the optimum
solution of the MAX-1-BDS problem in G, we see that β1(G) > β1(G[C]) + β1(G \ C).
Since β1(G[C]) and β(G \ C) are both optimum solutions of the MAX-1-BDS problem on
graphs G[C] and G \ C respectively, we have β1(G[C]) + β(G \ C) > β1(G). This shows
71
Proof. Suppose that there exists a solution S of the Max-1-BDS problem not containing
u and v. Since (u, v) is an isolated edge, S ∪ {u, v} is also a solution, a contradiction
to the assumption that S is a BOUNDED-DEGREE-1 subset of maximum size. Suppose
that one of u and v is not contained in S, say u. It is easy to see that S ∪ {u} is also a
BOUNDED-DEGREE-1 set since (u, v) is an isolated edge. Thus u and v must be selected
in any solution of the MAX-1-BDS problem. ✷
Lemma 27 (Degree-One Edge Rule). Let G = (V ,E) be a graph and (u, v) be a degree-one
edge of G satisfying one of the following conditions.
1. u is of degree two and v is of degree one;
2. Both u and v are of degree two, andw is the common neighbor of u and v, deg(w) = 3.
Then β1(G) = 2+ β1(G \ (N(u) ∪N(v))).
Proof. Suppose that u is of degree two and v is of degree one. Suppose that S is an
optimal solution not containing u. Let w be the other neighbor of u. It is easy to see
that v,w ∈ S otherwise S is not maximal. We may remove w from S and add u into S to
obtain another optimal solution that selects both u and v. Suppose that S contains u but
does not contain v. Then w must be selected in S otherwise S is not maximal. Similarly
we can remove w from S and add v into S to obtain another optimal solution that selects
both u and v. Suppose that both u and v has degree two, w is their common neighbor
and w has degree three. Suppose that S is an optimal solution not containing u then
(v,w) is a degree-one edge of the first case, v,w ∈ S. We may remove w from S and add
u into S to obtain another optimal solution that selects both u and v. This shows that
β1(G) = 2+ β1(G \ (N(u) ∪N(v))). ✷
Lemma 28 (Degree-One Vertex Rule 1). Let G = (V ,E) be a graph and v be a vertex of G
having at least two degree-one neighbors. Then β1(G) = |X| + β1(G \ (X ∪ {v})) where X is
the set of all degree-one neighbors of v.
Proof. Let S be an optimal solution selecting v. At most one vertex inN(v) can be selected
in S. Let X ⊆ N(v) be the collection of vertices of degree one. Note that |X| > 2. Suppose
73
or both v and u are selected from G. That is
β1(G) = max


β1(G \ v),
2 + β1(G \N[v]).
Proof. Suppose v is selected and all neighbors of v are discarded in some solution. As-
sume that V\X is a solution of MAX-1-BDS problemwhere X is the set of vertices discarded
fromG. Let X′ = X\{u}. We can verify thatG[V\X′] is BOUNDED-DEGREE-1. Hence V\X′
is also a solution. Suppose v is selected and all neighbors of v other than w, u 6= w, are
discarded in some solution. Let Y be the set of vertices discarded from G in this solution
and Y′ = (Y \ {w}) ∪ {u}. We also can verify that G[V \ Y′] is BOUNDED-DEGREE-1. Thus
if there is some solution that selects v from G, there is a solution that discards neither v
nor u. ✷
Lemma 32 (Difference Rule). Let v be a vertex of G and w be a neighbor of v such that
|N[w] \N[v]| = 1. Then there is a solution of MAX-1-BDS problem that either v is discarded
or v and one of its neighbors are selected from G. That is
β1(G) = max


β1(G \ v),
maxU∈U(2 + β1(G \N[U])
where U = {{u, v} | u ∈ N(v)}.
Proof. Suppose v is selected and all neighbors of v are discarded in some solution and let
V \ X be the solution and X be the set of vertices discarded from G, G \ X is BOUNDED-
DEGREE-1. By definition, for all u ∈ N(v) u ∈ X. Let z be the only vertex in N[w] \N[v].
If z /∈ X, then we obtain a solution by deleting the set of vertices in (X \ {w}) ∪ {z} from
G. If z ∈ X, then we obtain a solution by deleting vertices in X \ {w}. Hence there is a
solution that either v is discarded or v and one of its neighbors are selected from G. ✷
The standard branching of a maximum bounded-degree-1 subset algorithm chooses a
vertex v of maximum degree and then either it discards v from the solution and solves the
75
6. Degree-One Vertex Rule 2. There is a vertex v having a degree-one neighbor w.
Since Degree-One Edge rule is not applicable, the degree of v is at least three. Oth-
erwise (v,w) is an edge of degree at most one. In this case the algorithm either
discards v and selects w or selects {v,w} and discards N[v] \ {v,w}.
β1(G) = max


1 + β1(G \ {v,w}),
2 + β1(G \N[v]).
The worst branching vector is (2, 4) and its branching number is 1.2721.
7. True-Twin Rule. There are two vertices v and w such that N[w] = N[v], i.e., v and
w are true twins. Since Degree-One Edge rule is not applicable, the degrees of v and
w are at least two. The algorithm either discards {v,w} or selects {v,w} and discards
N[v] \ {v,w}. Hence
β1(G) = max


β1(G \ {v,w}),
2+ β1(G \N[v]).
The worst branching vector is (2, 3) and its branching number is 1.3248.
8. Domination Rule. There is a maximum-degree vertex v of G, a neighbor u of v, and
N[u] ⊂ N[v]. The degree of v is at least 3. The algorithm either discards v or selects
{v,u} and discards N[v] \ {v,u}. Hence
β1(G) = max


β1(G \ v),
2+ β1(G \N[v]).
The worst branching vector is (1, 4) and its branching number is 1.3803.
9. Degree-Two Vertex Rule. There is a degree-two vertex w satisfying the condition
that the neighbor v with larger degree between the two neighbors of w is of degree
at least three. Let x be the neighbor of w other than v. Since Domination rule is not
applicable, x and v are not adjacent and |N[u] \N[v]| > 1 for any u ∈ N(v). There
are two cases:
(a) the degree of x is two. If we discard v then (w, x) becomes a degree-one edge
and hence there is an optimal solution that selects {w, x} and discards the neigh-
bor of x other than w. On the other hand, if v is selected, then there is an
77
tree is a 3-regular graph happens at most once from the root to a leaf, since every
instance generated by the algorithm is an induced subgraph of the original input
graph. Therefore the worst case time complexity happens when the degree of v is
four. The branching vector is (1, 6, 6, 6, 6) and its branching number is 1.5099.
12. Standard Branching Rule. Let v be a vertex of maximum degree. Since Difference
Rule is not applicable, |N[u] \ N[v]| > 2 for any u ∈ N(v). In this case we apply
standard branching rule. Let U = {{v}} ∪ {{v,u} | u ∈ N(v)}. Then
β1(G) = max


β1(G \ {v}),
maxU∈U(|U| + β1(G \N[U]).
The worst case happens when the degree of v is three. Graph G is 3-regular if the
degree of v is three. The case that the instance assigned to a node of the search
tree is a 3-regular graph happens at most once from the root to a leaf, since every
instance generated by the algorithm is an induced subgraph of the original input
graph. Therefore the worst case time complexity happens when the degree of v is
four. The branching vector is (1, 5, 7, 7, 7, 7) and its branching number is 1.5171.
The above branching algorithm consists of reduction rules and branching rules. We
list them in the following.
• Reduction rules: Maximum Degree Two Rule, Isolated-Vertex Rule, Isolated-Edge
Rule, Degree-One Edge Rule, Degree-One Vertex Rule 1, and Disconnected Rule.
• Branching rules: Degree-One Vertex Rule 2, True-Twin Rule, Domination Rule, Degree-
Two Vertex Rule, Difference Rule, and Standard Branching Rule
Theorem 33. The MAX-1-BDS problem can be solved in O∗(1.5171n) time.
Remark 3. The above theorem implies that the MIN-1-BDD problem also can be solved in
O∗(1.5171n) time.
79
• Standard Branching Rule: the branching vector is (1, 4, 5, 5, 5, 5) and the branching
number is 1.6930.
Theorem 34. The 1-BDD problem can be solved in time O∗(1.7964p).
4.6 Problems related to the densest k-set problem
Define the density of a graph G = (V ,E) to be |E|/|V |. Use d(S) to denote the density of
the subgraph of G induced by vertex set S. A densest set of a graph G = (V ,E) is a subset
D of V such that the density of G[D] is maximum among all subgraphs of G induced by
non-empty subsets of V . We call a subset S of a graph G = (V ,E) a k-set (resp. at-least-
k-set, at-most-k-set) if and only if S is of size k (resp. of size not less than k, of size not
larger than k). A densest k-set (resp. at-least-k-set, at-most-k-set) S of G is a k-set (resp.
at-least-k-set, at-most-k-set) of G such that the density of G[S] is maximum among all
subgraphs of G induced by k-sets (resp. at-least-k-sets, at-most-k-sets) of G. Similarly,
a sparsest k-set (resp. at-least-k-set, at-most-k-set) S of G is a k-set (resp. at-least-k-set,
at-most-k-set) of G such that the density of G[S] is minimum among all subgraphs of G
induced by k-sets (resp. at-least-k-sets, at-most-k-sets) of G. It is easy to see that S is a
densest k-set in G if and only if it is a sparsest k-set in G¯, the complement of G. We say
that a vertex v covers an edge e if v is an end vertex of e. Use CG(S) for the set of edges
covered by a set S ⊆ V . A minimum (resp. maximum) k-vertex cover of an undirected
graph G is a k-set of G such that |CG(S)| is minimum (resp. maximum) among all k-sets
of G.
A densest k-set is also called a k-cluster [23]. The problem of finding a densest k-set
in an undirected graph was introduced in [23] by Corneil and Perl. It is a generalization
of the maximum clique problem. The following problems are closely related.
DENSEST SET Problem [39]
Input: A simple undirected graph G = (V ,E).
Output: A densest set D of G.
81
Known results. The DENSEST AT-LEAST-k-SET problem and the DENSEST AT-MOST-k-SET
problem are two variations of the DENSEST k-SET problem introduced by Andersen and
Chellapilla [2]. They gave a 3-approximation algorithm for the DENSEST AT-LEAST-k-SET
problem and showed that there is a 2-approximation algorithm with much higher running
time. Khuller and Saha showed that the DENSEST AT-LEAST-k-SET problem is NP-hard and
if there exists an α-approximation algorithm for DENSEST AT-MOST-k-SET problem, then
it implies a 4α-approximation algorithm for the DENSEST k-SET problem [49].
When parameterized by k, the DENSEST k-SET problem, SPARSEST k-SET problem,
MAXIMUM k-VERTEX COVER problem, and MINIMUM k-VERTEX COVER problem are W[1]-
hard in general graphs [27], they are evenW[1]-hard in regular graphs[17]. The PARTIAL
VERTEX COVER problem is closely related to the MAXIMUM k-VERTEX COVER problem.
Consider k as a parameter, the PARTIAL VERTEX COVER problem is W[1]-hard [41]. Kneis
et al. gave a randomized algorithm with running time 1.2993tnO(1) and a deterministic
algorithm with running 1.396tnO(1) for the PARTIAL VERTEX COVER problem [52].
Proposition 1. Let S be a k-set of an undirected graph G = (V ,E) where |V | = n. The
following four statements are equivalent.
1. S is a densest k-set of G.
2. S is a sparsest k-set of G¯.
3. V \ S is a minimum (n − k)-vertex cover of G
4. V \ S is a maximum (n − k)-vertex cover of G¯.
4.6.1 The densest k-set problem
The algorithm given in this report for the densest k-set problem is based on an approach
called split and list introduced in [51, 33, 34, 76, 77]. It can be seen a kind of divide and
conquer. It is well-known that divide and conquer is a strategy often used to design effi-
cient algorithms for solving problems in P. The split and list is an approach for designing
efficient algorithms to solve hard problems. The word ”split” means that we first split the
83
when k is sufficiently large and dependent on n, the brute force algorithm is not very
efficient. For theoretical interests, we give an O∗(1.7315n)-time algorithm to solve the
DENSEST k-SET problem. When k is sufficiently large and dependent on n, our algorithm
is more efficient than the brute force algorithm.
Table 22: The c values with respect to α.
α 0.2 0.25 0.3 0.35 0.4 0.45 0.5
c 1.6494 1.7548 1.8421 1.9107 1.9602 1.9901 2
Notice that S ⊆ V is a densest k-set in a graph G = (V ,E) if and only if S is a sparsest
k-set in G¯. In the rest of this report, we solve the SPARSEST k-SET problem.
The following definition of distance product given in [81] is useful for solving our
problem.
Definition 5 (Distance Products). Let A be an n ×m matrix and B be an m× n matrix.
The distance product of A and B, denote A ⋆ B, is an n× n matrix C such that
Cij =
m
min
k=1
{Aik + Bkj}, for 1 6 i, j 6 n.
Lemma 36. [81] Let A be an n × nr matrix and B be an nr × n matrix whose entries are
taken from the set {−ℓ, . . . , 0, . . . , ℓ}∪{+∞} where ℓ is a positive integer. The distance product
of A and B can be computed in O˜(min{ℓ ·nω(1,r,1),n2+r}) time where ω(1, r, 1) is the matrix
multiplication exponent.
Remark 4. Given two n × n matrices A and B whose entries are taken from the set
{−ℓ, . . . , 0, . . . , ℓ} ∪ {+∞} where ℓ is a positive integer much less than n, the distance
product of A and B can be computed in time O˜(ℓ ·nω(1,1,1)) where ω(1, 1, 1) = ω < 2.376
is the square matrix multiplication exponent.
We close this section with some notation. For a simple undirected graph we use n to
denote the number of vertices in it. For set S ⊆ V , let G[S] denote the subgraph of G
85
x in V1 represents a vertex set X ⊆ V1, |X| = k1; each node y ∈ V2 represents a vertex set
Y ⊆ V2, |Y| = k2; and each node z ∈ V3 represents a vertex set Z ⊆ V3, |Z| = k3. Let
E1 = {(x,y) | x ∈ V1 and y ∈ V2},
E2 = {(y, z) | y ∈ V2 and z ∈ V3}, and
E3 = {(z, x) | z ∈ V3 and x ∈ V1}.
The edge set of H is E = E1 ∪ E2 ∪ E3.
For each edge (x,y) ∈ E1, the weight of (x,y) is
w(x,y) = |EG(X)|+ |EG(X,Y)|
where X ⊆ V1 and Y ⊆ V2 are the vertex sets associated with x and y.
Similarly, for each (y, z) ∈ E2,
w(y, z) = |EG(Y)| + |EG(Y,Z)|
where Y ⊆ V2 and Z ⊆ V3 are the vertex sets associated with y and z.
For each (z, x) ∈ E3,
w(z, x) = |EG(Z)| + |EG(Z,X)|
where Z ⊆ V3 and X ⊆ V1 are the vertex sets associated with z and x.
Definition 6. A directed triangle (x,y, z) in H is a 3-cycle x → y → z → x where x ∈ V1,
y ∈ V2, and z ∈ V3. Define w(x,y, z) = w(x,y) +w(y, z) +w(z, x) to be the edge weight
of a directed triangle in H.
Lemma 37. For a graph G = (V ,E) and a balanced 3-partition (V1,V2,V3) of V , S ⊆ V is a
(k1,k2,k3)-set such that G[S] has ℓ edges if and only if there exists a directed triangle (x,y, z)
with edge weight ℓ in the corresponding auxiliary graph H = (V,E) of G with respect to the
balanced 3-partition (V1,V2,V3).
87
edge weighted 3-partite graph. Similarly, the DENSEST k-SET problem can be reduced
to the MAXIMUM WEIGHT TRIANGLE Problem on an edge weighted 3-partite graph. It is
known that the MAXIMUM WEIGHT TRIANGLE problem on a vertex-weighted graph of n
vertices can be solved in time O(nω+n2+o(1)) [24]. However, finding a maximum weight
triangle in a graph with vertex weights or edge weights in O(n3−ǫ) has been open for a
long time [24].
In the following lemma, we show that finding a minimum weight directed triangle in
H can be done in sub-cubic time.
Lemma 38. A minimum weight directed triangle in H can be computed by using a matrix
multiplication in time O˜(k2|V|ω) whereω is the square matrix multiplication exponent (ω <
2.376).
Proof. It is easy to see that finding a directed triangle containing an edge (z, x) ∈ E3 of
minimum edge weight among all triangles containing (z, x) in H can be done by finding a
length-2 path of minimum weight from x ∈ V1 to z ∈ V3. Thus for computing a minimum
weight triangle containing each edge in E3, it is sufficient to compute all-pairs length-2
paths of minimum weights from nodes in V1 to nodes in V3. Suppose that H is represented
by an adjacency matrix M = (Mij).
Mij =


w(i, j) if (i, j) ∈ E
+∞ if (i, j) 6∈ E
Note that for (i, j) ∈ E w(i, j) 6
(
k
2
)
< k2 and we use +∞ to represent weights of non-
edges. M is a |V| × |V| matrix whose finite entries are all integers in {0, 1, 2, . . . ,
(
k
2
)
}. The
minimum weight length-2 paths from all nodes in V1 to all nodes in V3 can be computed
by the distance product ofM ⋆M. Let C = M ⋆M. Note that for i ∈ V1 and j ∈ V3, Cij is
the minimum weight of a length-2 path i→ p→ j from node i to node j passing through
a node p ∈ V2. By Lemma 36, the distance product of M ⋆M can be computed in time
O˜(k2|V|ω). Let Dij = Cij +Mji for i ∈ V1 and j ∈ V3. We see that Dij is the minimum
89
tion exponent.
Proof. In Step 1 of the Split-and-List algorithm the balanced 3-partition (V1,V2,V3) is
with |V1| 6 |V2| 6 |V3| 6 ⌈n/3⌉. The number of vertices in H is
|V| = |V1|+ |V2 |+ |V3|
=
(
|V1|
k1
)
+
(
|V2|
k2
)
+
(
|V3|
k3
)
6
(
⌈n3 ⌉
k1
)
+
(
⌈n3 ⌉
k2
)
+
(
⌈n3 ⌉
k3
)
6 3 · 2⌈n/3⌉.
According to Lemma 39 the SPARSEST (k1,k2,k3)-SET problem can be solved in time
O˜(k2|V|ω) where ω is the square matrix multiplication exponent, ω < 2.376. We have
O˜(k2 · |V|ω) = O∗(k2 · 2⌈ωn/3⌉)
= O∗(k2 · 20.792n)
= O∗(k2 · 1.7315n).
Since there are
(
k+2
2
)
= O(k2) possibilities of (k1,k2,k3) satisfying k1 + k2 + k3 = k,
Step 2 of the Split-and-List is executed O(k2) times. Thus the execution time spent in
Step 2 is O∗(k4 · 1.7315n) = O∗(1.7315n). It takes O(n) time to obtain a balanced 3-
partition in Step 1 and it takes O(k2) time in Step 3 to obtain an optimal solution. The
total running time of the Split-and-List algorithm is O∗(1.7315n). This completes the
proof. ✷
Given a sparsest k-set S of G, we can easily obtain that V \ S is a maximum (n − k)-
vertex cover of G, V \ S is a minimum (n − k)-vertex cover of G¯, and S is a densest k-set
of G¯. Moreover, by executing the algorithm k times, we can obtain a densest at-most-k-set
of G¯. The DENSEST AT-LEAST-k-SET problem can also be solved by calling the Split-and-
List algorithm (n− k) times. The PARTIAL VERTEX COVER problem with parameters k and
t (using at most k vertices to cover at least t edges) can be solved by taking the Split-
and-List algorithm as a procedure to solve the SPARSEST (n − k)-SET problem. Thus all
91
the performance of the algorithm it is necessary to design a new heuristic algorithm like
IDROP for getting a better lower bound.
For the maximum 2-plex problem, we solved its complement problem called the maxi-
mum bounded-degree-1 subset problem, we designed an exact algorithm running in time
O∗(1.5171n). This algorithm is a branch-and-reduce algorithm. We used the measure and
conquer approach to analyze it. We showed that this exact algorithm runs in O∗(1.4834n)
time [19].
About the exact algorithms for finding the minimum k-club vertex cover and the min-
imum k-plex vertex cover, we applied a dynamic algorithm for solving the minimum set
cover problem. This dynamic algorithm is not very practical because it may take O(4n)
space. For instances of large size, we are not able to solve it within a limitation of memory
space. It is necessary to design an algorithm using less memory space and being able to
find a minimum k-club cover (or k-plex cover) within a reasonable time.
We designed an exact algorithm for the densest k-set problem. This algorithm runs in
exponential space. The open problem is whether the densest k-set problem can be solved
in time o(2n) and in polynomial space.
93
表在第29屆組合數學與計算理論研討會, 除此之外, 解決最密集k-集合問題的研究結果已發表在
NCS 2011,我們的研究是社群網路偵測的先期研究, 相信再不久將來可以看到更多國際學者投入
此一領域。 本計畫研究內容與原計畫相符程度甚高, 可以說達成預期目標, 研究成果具學術價值,
我們將陸續整理這些研究成果,於近期內投稿國際期刊。
7 參考文獻
References
[1] R. Alba. A graph-theoretic definition of a sociometric clique. Journal of Mathemat-
ical Sociology 3 (1973), pp. 113–126.
[2] R. Andersen and K. Chellapilla, Finding dense subgraphs with size bounds, In Pro-
ceedings of WAW’09, pp. 25–36, 2009.
[3] S. Arora, D. Karger, and M. Karpinski, Polynimial time approximation schemes
for dense instances of NP-hard problems, In Proceedings of the 27th Annual ACM
Symposium on Theory of Computing, pp. 284–293, 1995.
[4] Y. Asahiro, K. Iwama, H. Tamaki and T. Tokuyama, Greedily finding a dense sub-
graph, Journal of Algorithms 34 (2000), pp. 203–221.
[5] J. Backer and J. M. Keil, Constant factor approximation algorithms for the densest
k-subgraph problem on proper interval graphs and bipartite permutation graphs,
Information Processing Letters 110 (2010), pp. 635–638.
[6] B. Balasundaram, S. Butenko, and S. Trukhanov, Novel approaches for analyzing
biological networks. Journal of Combinatorial Optimization 10 (2005), pp. 23–39.
[7] B. Balasundaram, S. Butenko, I. V. Hicks, and S. Sachdeva. Clique relaxations in
social network analysis: The maximum k-plex problem. Manuscript, 2008.
95
[17] L. Cai. Parameterized complexity of cardinality constrained optimization problems.
The Computer Journal, 51 (2008), pp. 102–121.
[18] L. Cavique, A. B. Mendes, and J. M. A. Santos, An algorithm to discover the k-clique
cover in Networks, Proceedings of EPIA 2009, LNAI 5816 (2009), pp. 363–373.
[19] Maw-Shang Chang, Ling-Ju Hung, Ping-Chen Su, Measure and conquer: analysis
of a branch-and-reduce algorithm for the maximum bounded-degree-1 set prob-
lem, in proceedings of the 29th Workshop on Combinatorial Mathematics and Com-
putation Theory, pp. 136–145, 2012
[20] Z. Z. Chen, M. Fellows, B. Fu, H. Jiang, Y. Liu, L. Wand, and B. Zhu, A linear kernel
for co-path/cycle packing, Proceedings of AAIM 2010, LNCS 6124, pp. 90–102,
2010.
[21] D. Z. Chen, R. Fleischer, and Jian Li, Densest k-subgraph approximation on inter-
section graphs, In Proceedings of the 8th International Workshop on Approximation
and Online Algorithms (WAOA’10), pp. 83–93, 2010.
[22] T. F. Coleman and J. J. More´, Estimation of sparse Jacobian matices and graph
coloring problems, SIAM Journal on Numerical Analysis 20 (1983), pp. 187–209.
[23] D. Corneil, Y. Perl, Clustering and domination in perfect graphs, Discrete Applied
Mathematics 9 (1984), pp. 27–40.
[24] A. Czumaj and A. Lingas, Finding a heaviest vertex-weighted triangle is not harder
than matrix multiplication, SIAM Journal on Computing 39 (2009), pp. 431–444.
[25] C. Demetrescu and G. F. Italiano, A new approach to dynamic all pairs shortest
paths, Journal of the ACM, 51 (2004), pp. 968–992.
[26] DIMACS: Maximum clique, graph coloring, and satisfiability, Second DIMACS im-
plementation challenge (1995), http://dimacs.rutgers.edu/Challenges/.
97
[39] A. Goldberg, Finding a maximum density subgraph, Technical Report UCB/CSB
84/171, Department of Electrical Engineering and Computer Science, University
of California, Berkeley, CA, 1984.
[40] J. Grossman, P. Ion, and R. D. Castro, The Erdo˝s Number Project.
http://www.oakland.edu/enp
[41] J. Guo, R. Niedermeier, and S. Wernicke, Parameterized complexity of vertex cover
variants, Theory of Computing Systems 41 (2007), pp. 501–520.
[42] Q. Han, Y. Ye, and J. Zhang, An improved rounding method and semidefinite pro-
gramming relaxation for graph partition, Mathematical Programming 92 (2002),
pp. 509–535.
[43] R. Hassin, S. Rubinstein, and A. Tamir, Approximation algorithms for maximum
dispersion, Operations Research Letters 21 (1997), pp. 133–137.
[44] A. K. Jain and R. C. Dubes. Algorithms for clustering Data. Englewood Cliffs, NJ:
Prentice-Hall, 1988.
[45] D. S. Johnson, and M. A. Trick (Eds.), Cliques, Coloring and Satisfiability, DIMACS
Series in Discrete Mathematics and Theoretical Computer Science, 26, American
Mathematical Society, Providence, RI, 1996.
[46] R. Kannan, S. Vempala, and A. Vetta. On Clusterings-Good, Bad and Spectral. Jour-
nal of the ACM, 51 (2004), pp. 497–515.
[47] J. M. Keil, and T. Brecht, The complexity of clustering in planar graphs, Journal of
Combinatorial Mathematics and Combinatorial Computing 9 (1991), pp. 155–159.
[48] S. Khot, Ruling out PTAS for graph min-bisection, dense k-subgraph, and bipartite
clique, SIAM Journal on Computing 36 (2006), pp. 1025–1071.
99
nality k-clubs in graphs. http://iem.okstate.edu/baski/files/DISCO-k-clubs-2010-
02-11.pdf (2010)
[60] B. McClosky and I. V. Hicks, Combinatorial algorithms for the maximum k-plex
problem, Journal of Combinatorial Optimization , 2011. DOI: 10.1007/s10878-
010-9338-2
[61] G. B. Mertzios, A polynomial algorithm for the k-cluster problem on the interval
graphs, Electronic Notes in Discrete Mathematics 26 (2006), pp. 111–118.
[62] R. J. Mokken. Cliques, clubs and clans. Quality and Quantity 13 (1979), pp. 161–
173.
[63] H. Moser, R. Niedermeier, and M. Sorge, Algorithms and experiments for clique
relaxations–finding maximum s-plexes, Proceedings of SEA 2009, LNCS 5526
(2009), pp. 233–244.
[64] H. Moser, R. Niedermeier, and M. Sorge, Exact combinatorial algorithms and ex-
periments for finding maximum k-plexes, Journal of Combinatorial Optimization
24 (2012), pp. 347–373.
[65] R. Niedermeier, Invitation to Fixed-Parameter Algorithms, Oxford University Press,
2006.
[66] N. Nishmura, P. Ragde, D. M. Thilikos, Fast fixed-parameter tractable algorithms
for nontrivial generalizations of vertex cover, Discrete Applied Mathematics 152
(2005), pp. 229–245.
[67] T. Nonner, PTAS for densest k-subgraph in interval graphs, Manuscript, 2011.
[68] P. R. J. O¨sterga˚rd, A fast algorithm for the maximum clique problem, Discrete Ap-
plied Mathematics 120 (2002), pp. 197–207.
101
2-club in an undirected graph, Proceedings of NCS 2009: Workshop on Algorithms
and Bioinformatics, pp. 176–181.
[81] U. Zwick, All pairs shortest paths using bridging sets and rectangular matrix mul-
tiplication, Journal of the ACM 49 (2002), pp. 289–317.
8 附錄
8.1 Maw-Shang Chang, Ling-Ju Hung, Chih-Ren Lin, Ping-Chen Su, Finding large
k-clubs in undirected graphs, Proceedings of the 28th Workshop on Combinatorial
Mathematics and Computation Theory, pp. 1–10, 2011. Best Paper Award
8.2 Maw-Shang Chang, Ling-Ju Hung, Ping-Chen Su, Exact and fixed-parameter
algorithms for problems related to 2-plex, Proceedings of ICSEC 2011, pp. 203–208,
2011.
8.3 Maw-Shang Chang, Li-Hsuan Chen, Ling-Ju Hung, Peter Rossmanith, and Guan-
Han Woo, Exact Algorithms for Problems Related to the Densest k-Set Problem, in
Proceedings of NCS 2011: Algorithms and Bioinformatics Workshop, pp. 1–9, 2011.
Best Paper Award
8.4 Maw-Shang Chang, Ling-Ju Hung, Ping-Chen Su, Measure and conquer: analy-
sis of a branch-and-reduce algorithm for the maximum bounded-degree-1 set prob-
lem, in proceedings of the 29th Workshop on Combinatorial Mathematics and Com-
putation Theory, pp. 136–145, 2012
103
Nh(v) = {u | distG(u, v) 6 h}. A modified O-
notation, O∗, is used here to bound the running
time of those exponential time algorithms asymp-
totically. For functions f and g, f(n) = O∗(g(n))
if f(n) = O(g(n) · poly(n)) where poly(n) is a
polynomial. For more description about the O∗-
notation, we refer to the book [9].
We conducted algorithmic study on the max-
imum k-club problem for k > 2. In this paper,
we showed that for fixed integer k > 1, given
a positive integer s as an input parameter and a
graph G, determining whether G has a k-club of
size greater than or equal to s is fixed-parameter
tractable. We showed that one can find a k-
club of maximum size in O∗(1.62n) time where
n is the size of the input graph. We proposed a
new heuristic algorithm called IDROP that finds
larger k-clubs than the best known heuristic al-
gorithm called DROP in all graphs. We imple-
mented a combinatorial branch-and-bound algo-
rithm that finds a k-club of maximum size. To
speed up the program, we designed a dynamic
data structure that maintains the k-neighborhood
for each vertex of a graph. Given a graph of n
vertices, it can be constructed in O(n2) time us-
ing O(n2) space. It supports both vertex dele-
tion and edge deletion in O(km) amortized time
where m is the number of edges in the graph.
With this data structure, the k-neighborhood of
any vertex can be found in O(1) time and re-
ported in O(ℓ) time where ℓ is the number of ver-
tices in the k-neighborhood. From the experimen-
tal results that we obtained, we concluded that a
k-club of maximum size can be easily found in
sparse graphs and dense graphs. Our heuristic
algorithm performs very well. It finds, within
reasonable time, k-clubs of maximum size with
very high probability in sparse and dense graphs.
On our instances, the gap between the size of a k-
club of maximum size and a k-club found by the
heuristic algorithm is a constant independent of
the number of vertices in the graph.
This paper is organized as follows. In Sec-
tion 2, we give a fixed-parameter algorithm to
show that for any fixed k > 1, the maximum
k-club problem is fixed-parameter tractable. In
Section 3, we solve the time complexity prob-
lem of the branch-and-bound algorithm in [4, 17].
In Section 4.1, we present a new heuristic algo-
rithm, called IDROP that can be used to find a
new lower bound for the branch-and-bound al-
gorithm in [4]. In Section 4.2, we give a reduction
rule which can slightly reduce the running time of
the branch-and-bound algorithm. In Section 4.3,
we present a new data structure called k-DN to
be used in the implementation of the branch-and-
bound algorithm. In Section 5, we give some ex-
periment results to present that our new heuris-
tic algorithm finds larger k-clubs than existing
heuristic algorithms. We also present the perfor-
mance of our programs implemented based on
the branch-and-bound algorithm and with the k-
DN data structure and the data reduction rule.
2 The maximum k-club problem is
FPT
A problem is fixed-parameter tractable (FPT) if
given any instance of size n and a positive in-
teger s, one can give algorithms to solve it in
time f(s) · nO(1) where f(s) is a computable func-
tion only depending on s. We call those algo-
rithms fixed-parameter algorithms. There are many
results about fixed parameter algorithms intro-
duced in [18]. In this section, we give a fixed-
parameter algorithm to solve the maximum k-
club problem for any fixed k > 1.
The k-club problem
Input: A graphG = (V ,E) and two integers k > 1
and s > 1.
Output: Whether there is a k-club S in G with
|S| > s.
A fixed-parameter algorithm.
Step 1: Let λ be an integer, λ = s2 if k is even
and s3 if k is odd. If |V | 6 λ, list
(
|V|
s
)
subsets of V and check for each subset
S ⊆ V , |S| = s, whether the diameter of
G[S] is at most k by computing all pairs
shortest paths.
Step 2: If there exists a vertex v in G,
|N⌊k/2⌋(v)| > s, then we simply take
S = N⌊k/2⌋(v).
Step 3: For every v ∈ V , check
(
|Nk(v)|
s
)
subsets
of Nk(v) to see whether there exists a k-
club in Nk(v).
Lemma 1. Suppose for each v in G, |N⌊k/2⌋(v)| < s.
If k is even, |Nk(v)| < s
2. If k is odd, |Nk(v)| < s
3.
Proof. Suppose that k is even, for each v in G,
|Nk/2(v)| < s. For each w ∈ Nk/2(v), |Nk/2(w)| <
s, hence
|Nk(v)| 6
∑
w∈Nk/2(v)
(s − 1) 6 (s − 1)2 < s2.
第二十八屆 組合數學與計算理論研討會論文集 ＩＳＢＮ：978-986-02-7580-3
2
best solution found so far, then the branch-and-
bound algorithm will terminate this node. In [4]
the authors find the k-clique number of the graph
associated with each node of the search tree as
an upper bound. The main drawback of this ap-
proach is that the maximum k-clique problem,
which is NP-hard, must be solved to optimality to
obtain a valid upper bound. Inspired by branch-
and-bound algorithms for solving the maximum
clique problem, we came out with the idea using
the k-coloring number as an upper bound. Later
we found the same technique was independently
used in [17]. The k-coloring number of a graph
is the minimum number of colors one can use to
color vertices of the graph such that two vertices
that are at a distance no more than k are in dif-
ferent colors. The size of any feasible k-coloring
of a graph can be used as an upper bound of the
size of k-clubs in the graph. During the execution,
a branch-and-bound algorithm keeps on modify-
ing the input graph and storing partial results.
Hence the fourth trick is to design efficient dy-
namic data structures for storing the input graph
and maintaining properties of the graph. In
each node of the branch-and-bound algorithm for
finding a maximum k-club, it tests whether the
input graph is already a k-club and selects a ver-
texwith minimum k-neighborhood for branching
if the input graph is not a k-club. Hence comput-
ing the k-neighborhood of each vertex is a ma-
jor procedure of the algorithm. Therefore we de-
sign a dynamic data structure that stores the k-
neighborhood of every vertex supporting vertex
deletion. We believe that this data structure is not
only useful in the implementation of the branch-
and-bound algorithm, it also has its own interest.
In the rest of this section, we will describe our
new heuristic algorithm, reduction rules and the
dynamic data structure.
4.1 A new heuristic algorithm
In [3], Bourjolly et al. gave three heuristic al-
gorithms for finding a k-club in an undirected
graph called CONSTELLATION, DROP, and k-
CLIQUE & DROP. For readers’ convenience, we
briefly describe them. Algorithm DROP works
as follows: While the graph is not a k-club, re-
peatedly remove a vertex with smallest size of
k-neighborhood. Algorithm CONSTELLATION
is based on the following definition. Recursively
define the weight W(t), 2 6 t 6 k, for a graph G
as follows: If t = 2, let W(t) = NG[v], where v is
a vertex of maximum degree in G. For 2 < t 6 k,
let W(t) = W(t − 1) ∪NG(w), where w is a ver-
tex inW(t − 1) adjacent to maximum number of
vertices not in W(t − 1). Algorithm CONSTEL-
LATION computes W(t) iteratively and outputs
W(k). It is not hard to verify thatW(k) is indeed
a k-club of G. The third algorithm is called k-
CLIQUE & DROP. It first determines a maximum
k-clique K in G and then call DROP to find a k-
club in G[K].
Bourjolly et al. showed that the running times
of DROP and CONSTELLATION are O(n3m)
and O(k(n + m)), respectively. Since the prob-
lem to find a maximum k-clique is NP-hard, of
course the running time of algorithm k-CLIQUE
& DROP is not polynomial unless P=NP. Ac-
cording to the experiments done by the authors,
CONSTELLATIONfinds better solution in sparse
graphs and DROP finds better solution in dense
graphs. And the solutions found by the third al-
gorithm are dominated by one or the other of the
first two algorithms in most cases. Even in the
case that the third algorithm finds a better solu-
tion than the first two, it only finds a slightly bet-
ter solution. The slightly better solution does not
justify taking exponential time.
Now we describe our new heuristic algorithm
called Iterative DROP (IDROP for short). This al-
gorithm is a modification of the third algorithm:
For each vertex v in the graph we call DROP
to compute a k-club in the subgraph induced
by the k-neighborhood of v and then output a
best k-club among them. The running time of
this algorithm is polynomial. The idea behind
the algorithm is that a maximum k-club may in-
cludes some vertices whose k-neighborhood is
not large but they are excluded from the solu-
tion obtained by DROP. Fig. 1 shows an exam-
ple graph in which DROP excludes those pen-
dant vertices in finding a 2-club and therefore
it returns a 2-club of size smaller than that the
one found by IDROP. On our instances, IDROP
always finds solutions that are at least as good
as DROP. From experimental results we observe
that this algorithm never finds a solution much
inferior to those found by CONSTELLATION in
our test instances.
4.2 A reduction rule
Let C be a k-club of graph G and v ∈ C. Then
C is a subset of the k-neighborhood of v. Dur-
ing the execution, a branch-and-bound algorithm
maintains a best solution found so far. Suppose
the size of this solution is max. If the size of the
第二十八屆 組合數學與計算理論研討會論文集 ＩＳＢＮ：978-986-02-7580-3
4
0 1 2 3 4 5 6 7 8 9 10
0 1 1
-ﬀ 1 1 -ﬀ 1 1 -ﬀ 1 1 -ﬀ 1 1 -ﬀ 1 1 2 2 -ﬀ 2 1 -ﬀ 0 2 1
6
q- head 1
6
q- head 2
Figure 2: This presents a basic building block of the k-DN data structure for k = 2. The corresponding
vertex of this example is vertex v0 in the graph shown in Fig. 1. The double linked list starting from
head 1 stores those vertices adjacent to v0 and the double linked list starting from head 2 stores those
vertices at distance two from v0. For j ∈ {0, 1, 2, . . . , 10}, the left entry of j-th position of the array stores
the distance between vj and v0 and the right entry stores the upper degree of vj with respect to v0, for
example, the right entry of position 7 is 2 since v7 has two neighbors v5 and v6 in the list starting from
head 1.
an array of list nodes for each vertex and initial-
ize them. Then run a breadth-first traversal for
each vertex i to obtain the distance between i and
any other vertex and then insert every vertex into
the list storing all vertices at distance d from ver-
tex i if it is at distance d from i. This step takes
O(n+m) time per vertex, wherem is the number
of edges of the graph. If we store the number of
vertices in the list for each list and the number of
vertices in the k-neighborhood of every vertex i,
thenwe can verify whether the input graph is a k-
club by checking if the k-neighborhood of every
vertex equals the vertex set of the graph.
The critical part is how to update efficiently
the k-neighborhood of every vertex after deleting
a vertex i from the graph. Clearly, only the k-
neighborhood of vertices in the k-neighborhood
of vertex i affected by the deletion. In the follow-
ing we show how to update the k-neighborhood
of vertex j when vertex i is deleted. Let d be the
distance between i and j. Of course d 6 k.
Remove vertex i from the k-neighborhood
of vertex j first. If d = k then the procedure
terminates. In the following assume d < k. The
procedure maintains two sets U and U′ and a
variable h. Initially let h = d+1,U′ = ∅ andU be
the set of vertices that are at distance d + 1 from
vertex j and have no neighbors at distance d from
vertex j after the deletion. They are neighbors
of vertex i and the upper degrees of them with
respect to vertex j before the deletion is 1. Hence
the distance before the deletion between vertex j
and any vertex in U is h and will be increased
by the deletion. After the initialization, the
procedure repeats the following steps to update
the list of vertex j one by one while h 6 k and U
or U′ is not the empty set:
Step 1. Remove the set of vertices in U from the
list of vertex j storing the set of vertices
that are at distance h from vertex j.
Step 2. The distance between vertex j and any
vertex s ∈ U′ after the deletion is yet to
be determined. For each s ∈ U′ compute
the number of vertices that are at distance
h − 1 from vertex j after the deletion and
are adjacent to vertex s, insert s into the
list of vertex j storing the set of vertices
that are at distance h from vertex j and
remove s from U′ if the number is greater
than 0.
Step 3. Let S = ∅.
Step 4. If h < k compute S as follows:
For each vertex s ∈ U and each neighbor
t of s at distance h+1 from vertex j before
the deletion, decrease the upper degree of
twith respect to j by one and insert t into
S if the upper degree of t with respect to
vertex j becomes 0. Therefore S is the set
of vertices that are at distance h + 1 from
vertex j before the deletion such that the
distance between vertex j and any vertex
in S is increased after the deletion.
Step 5. Let U′ = U′ ∪U.
Step 6. Let U = S and h = h+ 1.
The correctness of the above procedure can be
proved by induction. We claim that (1) before
each iteration, the lists storing vertices that are at
distance less than h from vertex j after the dele-
tion are valid; (2) the distance after the deletion
between vertex j and a vertex s at distance h from
vertex j before the deletion will be increased by
第二十八屆 組合數學與計算理論研討會論文集 ＩＳＢＮ：978-986-02-7580-3
6
lower bound found by DROP. We also implement
the other two programs based on the branch-and-
bound algorithm in Section 3, one is applying the
reduction rule given in Section 4.2, but the other
is not. Both of them use the k-DN data structure.
In Table 3, we observe that by using this reduc-
tion rule the number of leaves in the branch-and-
bound search tree can be decreased and for those
random graphs with density 0.15 and 0.20, the
running time can be slightly improved. In Table 4,
we test our programs on 100 random graphs of
150 vertices to compare the performance of the
program with k-DN data structure and the pro-
gram without k-DN data structure. In these ex-
periment results, we see that the programwith k-
DN data structure performs better than the other
one. In Table 5 and 6, we list the size of k-
clubs found by the branch-and-bound algorithm,
DROP, and IDROP in some DIMACS graphs and
Erdo¨s collaboration networks. In most cases of
these benchmark graphs, the solution found by
IDROP is exact the size of maximum k-clubs.
References
[1] R. Alba. A graph-theoretic definition of a so-
ciometric clique. Journal of Mathematical Soci-
ology 3 (1973), pp. 113–126.
[2] V. Batagelj, Network/Pajek Graph Files.
http://vlado.fmf.uni-
lj.si/pub/networks/pajek/data/gphs.htm
[3] J.-M. Bourjolly, G. Laporte, and G. Pesant.
Heuristics for finding k-clubs in an undi-
rected graph. Computer & Operation Research,
27 (2000), pp. 559–569.
[4] J.-M. Bourjolly, G. Laporte, and G. Pesant.
An exact algorithm for maximum k-club
problem in an undirected graph. European
Journal of Operational Research, 138 (2002),
pp. 21–28.
[5] C. Demetrescu, A new approach to dynamic
all pairs shortest paths, Journal of the ACM,
51 (2004), pp. 968–992.
[6] DIMACS: Maximum clique, graph col-
oring, and satisfiability, Second DI-
MACS implementation challenge (1995),
http://dimacs.rutgers.edu/Challenges/.
[7] B. Everitt. Cluster Analysis. New York: Hal-
sted Press, 1980.
[8] G. W. Flake, R. E. Tarjan, and K. T. Tsiout-
siouliklis, Graph clustering and minimum
cut trees. Internet Mathematics, 1 (2004),
pp. 385–408.
[9] F. Fomin and D. Kratsch, Exact Exponential
Algorithms, Springer, 2010.
[10] M. Gendreau, P. Soriano, and L. Salvail,
Solving the maximum clique problem using
a tabu search approach, Annals of Operations
Research, 41 (1993) pp. 385–403.
[11] J. Grossman, P. Ion, and R. D. Castro, The
Erdo¨s Number Project.
http://www.oakland.edu/enp
[12] A. K. Jain and R. C. Dubes. Algorithms
for clustering Data. Englewood Cliffs, NJ:
Prentice-Hall, 1988.
[13] R. Kannan, S. Vempala, and A. Vetta. On
Clusterings-Good, Bad and Spectral. Journal
of the ACM, 51 (2004), pp. 497–515.
[14] V. King, Fully dynamic algorithms for
mataining all-pairs shortest paths and tran-
sitive closure in digraph, Proceedings of
FOCS 1999, pp. 81–91.
[15] S. T. Kuan, B. Y. Wu, and W. J. Lee, Find-
ing friend groups in Blogsphere, Proceed-
ings of 22nd International Conference on Ad-
vanced Information Networking and Applica-
tion, pp. 1046–1050, 2008.
[16] R. Luce. Connectivity and generalized
cliques in sociomatric group structure.
Psychometrika, 15 (1950), pp. 169–190.
[17] F. Mahdavi and B. Balasundaram,
On inclusionwise maximal and max-
imum cardinality k-clubs in graphs.
http://iem.okstate.edu/baski/files/DISCO-
k-clubs-2010-02-11.pdf (2010)
[18] R. Niedermeier, Invitation to Fixed-Parameter
Algorithms, Oxford University Press, 2006.
[19] J. Scott, Social Network Analysis- A Handbook,
Sage Publication, London, 2000.
[20] Valerie King. Fully dynamic algorithms for
maintaining all-pairs shortest paths and
transitive closure in digraphs. Proceedings of
the 40th Annual Symposium on Foundations of
Computer Science (1999), pp. 81–89.
[21] S. Wasserman and K. Faust. Social Network
Analysis. Cambridge University Press, 1994.
第二十八屆 組合數學與計算理論研討會論文集 ＩＳＢＮ：978-986-02-7580-3
8
Table 4: This table presents the average running time of programs with k-DN and without k-DN spent to find a
maximum k-club in 100 random graphs (|V | = 150). Both programs do not apply the data reduction rule. For each
test case, we use bold texts to mark the average running time that is less than the other.
k Density [a, b] without k-DN with k-DN
Time Time
2 0.050 [0.000, 0.100] 3.426 0.102
[0.025, 0.075] 2.620 0.104
[0.050, 0.050] 3.630 0.105
0.100 [0.050, 0.150] 14.723 1.002
[0.075, 0.125] 14.598 0.979
[0.100, 0.100] 14.563 1.053
0.150 [0.100, 0.200] 1966.253 329.875
[0.125, 0.175] 2268.970 393.678
[0.150, 0.150] 2022.607 365.604
0.200 [0.100, 0.300] 5.431 0.178
[0.150, 0.250] 5.265 0.173
[0.200, 0.200] 5.228 0.167
3 0.050 [0.000, 0.100] 49.109 5.230
[0.025, 0.075] 47.554 4.157
[0.050, 0.050] 40.153 4.177
0.100 [0.050, 0.150] 0.118 0.003
[0.075, 0.125] 0.113 0.002
[0.100, 0.100] 0.125 0.002
4 0.050 [0.000, 0.100] 1.606 0.006
[0.025, 0.075] 1.635 0.006
[0.050, 0.050] 1.448 0.007
Table 5: This table presents the size of the maximum k-clubs, k = 2, 3, 4, in some DIMACS graphs found by our
program (with k-DN and the reduction rule) based on the branch-and-bound algorithm described in Section 3 and
the solution found by IDROP as the initial lower bound. We also list the solution size of IDROP and DROP.
Graph Density Exact IDROP DROP
n k Size Time Size Time Size Time
c-fat200 0.08 200 2 18 0.01 18 0.01 18 0.00
3 24 0.04 24 0.03 24 0.00
4 30 0.06 30 0.06 30 0.00
0.16 200 2 35 0.07 35 0.07 35 0.00
3 46 0.21 46 0.18 46 0.00
4 57 0.40 57 0.36 57 0.00
0.43 200 2 87 0.70 87 0.59 87 0.00
3 200 0.03 200 0.01 200 0.00
4 200 0.04 200 0.00 200 0.00
c-fat500 0.04 500 2 21 0.08 21 0.05 21 0.00
3 28 0.13 28 0.13 28 0.00
4 35 0.24 35 0.23 35 0.00
0.07 500 2 39 0.35 39 0.26 39 0.00
3 52 0.64 52 0.62 52 0.00
4 65 1.31 65 1.29 65 0.00
0.19 500 2 96 3.59 96 2.80 96 0.00
3 128 7.81 128 7.73 128 0.00
4 159 19.25 159 18.37 159 0.00
Table 6: This table presents the size of the maximum k-clubs, k = 2, 3, 4, in Erdo¨s networks found by our program
(with k-DN and the reduction rule) based on the branch-and-bound algorithm described in Section 3 and the solu-
tion found by IDROP as the initial lower bound. We also list the solution size of IDROP and DROP. For those cases
that the system has insufficient memory space, we use ’-’ to mark them.
Graph Density Exact IDROP DROP
n k Size Time Size Time Size Time
Erdos-97-1 0.012 472 2 42 0.08 42 0.08 35 0.00
3 117 0.78 117 0.57 117 0.00
4 235 0.70 235 0.68 235 0.00
Erdos-98-1 0.012 485 2 43 0.09 43 0.09 36 0.00
3 123 0.84 123 0.62 121 0.00
4 244 1.45 244 1.41 243 0.00
Erdos-99-1 0.012 492 2 43 0.10 43 0.09 37 0.00
3 126 0.79 126 0.61 125 0.00
4 245 1.89 245 1.53 245 0.00
Erdos-97-2 0.001 5488 2 258 1.50 258 0.43 258 0.00
3 517 246.65 517 192.06 517 0.00
4 – – 1504 1498.12 1504 0.00
Erdos-98-2 0.001 5822 2 274 1.69 274 0.50 274 0.00
3 547 311.97 547 309.27 547 0.00
4 – – 1594 1863.62 1581 0.00
Erdos-99-2 0.001 6100 2 277 1.86 277 0.55 277 0.00
3 562 315.79 562 255.14 562 0.00
4 – – 1643 2199.42 1631 0.00
第二十八屆 組合數學與計算理論研討會論文集 ＩＳＢＮ：978-986-02-7580-3
10
maximum k-plex in G is of size (n− p).
Known results. Balasundaram et al. proved that
the maximum k-plex problem is NP-complete [3].
They gave a 0/1 integer program for the prob-
lem [1, 3]. It is known that the maximum k-plex
problem is W[1]-hard with respect to the parame-
ter s being the size of k-plexes [9]. Some branch-
and-bound algorithms were given for solving the
maximum k-plex problem based on different upper
bounds and lower bounds found by some heuris-
tics algorithms [15, 10]. Some graph editing prob-
lems are studied on finding a disjoint union of k-
plexes [8, 4]. In [16], Wu and Pei gave an algorithm
to enumerate all maximal k-plexes [16].
A series of fixed algorithms were developed for
solving the d-BDD problem [13, 9, 6]. For the spe-
cial case 1-BDD, in [11], Moser et. al. provided a
fixed-parameter algorithm running inO(2.31p+pn)
time based on bounded search trees and gave an
iterated-compression algorithm for the same prob-
lem with running time O(2p · p2 + pn). The fixed-
parameter algorithm based on bounded search tree
in [11] can be modified to be an exact algorithm
for solving the MIN-1-BDD problem with run-
ning time O∗(1.8637n). Chen et al. gave a fixed-
parameter algorithm running in time O∗(3.24p) for
solving the 2-BDD problem. Fellows et al. showed
that for unbounded d values, the d-BDD problem is
W[2]-complete [6]. In [2], Balasundaram et al. re-
ferred that the MAX-d-BDS problem is as the prob-
lem of finding maximum-cardinality co-(d + 1)-
plexes.
In this paper, we give some new reduction rules
to improve the running time of the fixed-parameter
algorithm in [11] for solving the maximum 1-BDS
problem and obtain an exact algorithm for solving
the same problem. The running time of the fixed
parameter algorithm is O∗(1.7964p) where p is the
number of vertices to be removed such that the re-
maining graph is BOUNDED-DEGREE-1 and the
running time of the exact algorithm is O∗(1.5171n)
where n is the number of vertices in the given
graph. We can easily use this algorithm to find a
2-plex of maximum size for a graph.
2. Preliminaries
A modified O-notation, O∗, is used here to bound
the running time of exponential time algorithms
asymptotically. For functions f and g, f(n) =
O∗(g(n)) if f(n) = O(g(n) · poly(n)) where poly(n)
is a polynomial. For more description about theO∗-
notation, we refer to the book [7].
Branching is one of the algorithmic techniques to
design exact algorithms. A typical branching algo-
rithm consists of a collection of reduction rules and
branching rules. Reduction rules are used to reduce
the input size. Branching rules are used to recur-
sively solve the smaller instances of the problem.
Search trees are often used to illustrate the execu-
tion of a branching algorithm. The root of a search
tree represents the input of the problem, every child
of the root represents a smaller instance reached by
applying a branching rule associated with the in-
stance of the root. One can recursively assign a
child to a node in the search tree when applying a
branching rule. Notice that we do not assign a child
to a node when applying a reduction rule. The run-
ning time of a branching algorithm is usually mea-
sured by the maximum number of leaves in its cor-
responding search tree. Let T (n) be the maximum
number of leaves in any search tree where n is the
input size. We analyze each branching rule and use
the worst-case time complexity over all branching
rules as an upper bound of the running time. Let b
be any branching rule. When rule b is applied, the
current instance is branched into r ≥ 2 instances
of size at most n − t1, n − t2, . . . , n − tr. Note that
n ≥ ti for i = 1, 2, . . . , r. We call b = (t1, t2, . . . , tr)
the branching vector of branching rule b. This can be
formulated in a linear recurrence
T (n) ≤ T (n− t1) + T (n− t2) + · · ·+ T (n− tr).
Theorem 1 ([7]). Let b be a branching rule with branch-
ing vector (t1, t2, . . . , tr). Then the running time of
the branching algorithm using only branching rule b is
O∗(αn), where α is the unique positive real root of
xn − xn−t1 − xn−t2 − · · · − xn−tr = 0
Remark 1. The positive real rootα is called the branch-
ing number. One can apply the above theorem to ana-
lyze the running time of a branching algorithm. Com-
pute αi for each branching rule bi. An upper bound of
the number of leaves in the search tree is O∗(cn) where
c = maxi αi. If the running time of the algorithm corre-
sponding to one node of the search tree is polynomial, the
running time of a branching algorithm is O∗(cn). For
more details about branching algorithms, please refer to
the book [7].
A problem is fixed-parameter tractable (FPT) if
given any instance of size n and a positive integer
p, one can give algorithms to solve it in time f(p) ·
nO(1) where f(p) is a computable function only
depending on p. We call those algorithms fixed-
parameter algorithms. There are many results about
fixed parameter algorithms introduced in [12].
204
© ICSEC 2011, September 2011, Bangkok, Thailand.
The standard branching of a maximum bounded-
degree-1 subset algorithm chooses a vertex v of
maximum degree and then either it discards v from
the solution and solves the problem recursively on
G \ {v}, or for every vertex set U ∈ U = {{v}} ∪
{{v, u} | u ∈ N(v)}, it selects U for the solution and
solves the problem recursively on G \N [U ]. Hence
β1(G) = max
{
β1(G \ v),
max
U∈U
(|U |+ β1(G \N [U ])).
Our algorithmwill apply the standard branching
rule when none of the other rules can be applied.
The description of the algorithm consists of a se-
quence of cases and subcases. To avoid a confusing
nesting of if-then-else statements let us use the fol-
lowing convention: The first case which applies is
used in the algorithm. Thus, inside a given case, the
hypothesis of all previous cases are assumed to be
false. Algorithm β1(G) computes for a given graph
G = (V,E) the maximum size of a vertex set S in-
ducing a bounded-degree-1 subgraph.
1. Maximum Degree-Two Rule. All vertices are
of degree at most two. In this case we solve the
problem in polynomial time and return the so-
lution. In the following the maximum degree
of G is greater than two.
2. Isolated-Vertex Rule. There is an isolated ver-
tex and let X be the set of all isolated vertices.
Then
β1(G) = |X |+ β1(G \X).
3. Isolated-Edge Rule. There is an isolated edge
and let X be the set of all isolated edges. Then
β1(G) = 2 · |X |+ β1(G \ V (X)).
4. Degree-OneEdgeRule. There is an edge (u, v)
of degree at most one and let X = N [{u, v}].
Then
β1(G) = 2 + β1(G \X).
5. Degree-One Vertex Rule 1. There is a vertex v
having at least two degree-one neighbors and
let X be the set of all degree-one neighbors of
v. Then
β1(G) = |X |+ β1(G \ (X ∪ {v})).
6. Degree-One Vertex Rule 2. There is a ver-
tex v having a degree-one neighbor w. Since
Degree-One Edge rule is not applicable, the de-
gree of v is at least three. Otherwise (v, w) is
an edge of degree at most one. In this case the
algorithm either discards v and selects w or se-
lects {v, w} and discardsN [v] \ {v, w}.
β1(G) = max
{
1 + β1(G \ {v, w}),
2 + β1(G \N [v]).
The worst branching vector is (2, 4) and its
branching number is 1.2721.
7. True-Twin Rule. There are two vertices v and
w such that N [w] = N [v], i.e., v and w are true
twins. Since Degree-One Edge rule is not ap-
plicable, the degrees of v andw are at least two.
The algorithm either discards {v, w} or selects
{v, w} and discardsN [v] \ {v, w}. Hence
β1(G) = max
{
β1(G \ {v, w}),
2 + β1(G \N [v]).
The worst branching vector is (2, 3) and its
branching number is 1.3248.
8. Domination Rule. There is a maximum-
degree vertex v of G, a neighbor u of v, and
N [u] ⊂ N [v]. The degree of v is at least 3.
The algorithm either discards v or selects {v, u}
and discardsN [v] \ {v, u}. Hence
β1(G) = max
{
β1(G \ v),
2 + β1(G \N [v]).
The worst branching vector is (1, 4) and its
branching number is 1.3803.
9. Degree-Two Vertex Rule. There is a degree-
two vertex w satisfying the condition that the
neighbor v with larger degree between the two
neighbors of w is of degree at least three. Let x
be the neighbor of w other than v. Since Dom-
ination rule is not applicable, x and v are not
adjacent and |N [u]\N [v]| ≥ 1 for any u ∈ N(v).
There are two cases:
(a) the degree of x is two. If we discard v
then (w, x) becomes a degree-one edge
and hence there is an optimal solution
that selects {w, x} and discards the neigh-
bor of x other than w. On the other hand,
if v is selected, then there is an optimal so-
lution that also selects one neighbor of v.
Let U = {{v, u} | u ∈ N(v)}. Hence
β1(G) = max
{
2 + β1(G \N [{x,w}]),
2 + maxU∈U β1(G \N [U ]).
The worst case happens when degree of v
is three. The branching vector is (4, 5, 5, 5)
and its branching number is 1.3413.
206
© ICSEC 2011, September 2011, Bangkok, Thailand.
{
T (p) = T (p− t1) + T (p− t2) + · · ·+ T (p− tr),
T (1) = 1.
The following branching vectors and branching
numbers are associated with branching rules listed
in Section 3 and the parameter p.
• Degree-One Vertex Rule 2: the branching vec-
tor is (1, 2) and the branching number is
1.6181.
• True-Twin Rule: the branching vector is (2, 1)
and the branching number is 1.6181.
• Domination Rule: the branching vector is (1, 2)
and the branching number is 1.6181.
• Degree-Two Vertex Rule: (a) the branch-
ing vector is (2, 3, 3, 3) and the branching
number is 1.6717; (b) the branching vector
is (2, 3, 3, 3, 3) and the branching number is
1.7964.
• Difference Rule: the branching vector is
(1, 4, 4, 4, 4) and the branching number is
1.7485.
• Standard Branching Rule: the branching vec-
tor is (1, 4, 5, 5, 5, 5) and the branching number
is 1.6930.
Theorem 3. The 1-BDD problem can be solved in time
O∗(1.7964p).
References
[1] B. Balasundaram, Cohesive subgroup model
for graph-based text mining. Proceedings of the
2008 IEEE Conference on Automation Science and
Engineering, pp. 989–994.
[2] B. Balasundaram, S. Chandramouli, and S.
Trukhanov, Approximation algorithms for
finding and partitioning unit-disk graphs
into co-k-plexes, Optimization Letters 4 (2010),
pp. 311–320.
[3] B. Balasundaram, S. Butenko, I. V. Hicks,
Clique relaxations in social network analysis:
The maximum k-plex problem, Operations Re-
search 59 (2011), pp. 133–142.
[4] R. van Bevern, H. Moser, and R. Niedermeier,
Approximation and tidying–a problem kernel
for s-plex cluster vertex deletion. To appear in
Algorithmica (Doi 10.1007/s00453-011-9492-7).
[5] Z. Z. Chen, M. Fellows, B. Fu, H. Jiang, Y. Liu,
L. Wand, and B. Zhu, A linear kernel for co-
path/cycle packing, Proceedings of AAIM 2010,
LNCS 6124, pp. 90–102.
[6] M. R. Fellows, J. Guo, H. Moser, R. Nieder-
meier, A generalization of Nemhauser and
Trotter’s local optimization theorem. To ap-
pear in Journal of Computer and System Sciences
(DOI 10.1016/j.jcss.2010.12.001).
[7] F. V. Fomin and D. Kratsch, Exact Exponential
Algorithms, Springer, 2010.
[8] J. Guo, C. Komusiewicz, R. Niedermeier, and
J. Uhlmann, A more relaxed model for graph-
based data clustering: s-plex cluster editing,
SIAM Journal on Discrete Mathematics 24 (2010),
pp. 1662–1683
[9] C. Komusiewicz, F. Hu¨ffner, H. Moser, and
R. Niedermeier, Isolation concepts for effi-
ciently enumerating dense subgraphs, Theoret-
ical Computer Science 410 (2009), pp. 3640–3654.
[10] B. McClosky and I.V. Hicks, Combinatorial al-
gorithms for the maximum k-plex problem, To
appear in Journal of Combinatorial Optimization
(DOI 10.1007/s10878-010-9338-2).
[11] H. Moser, R. Niedermeier, and M. Sorge,
Exact combinatorial algorithms and experi-
ments for finding maximum k-plexes, To ap-
pear in Journal of Combinatorial Optimization
(DOI 10.1007/s10878-011-9391-5).
[12] R. Niedermeier, Invitation to Fixed-Parameter
Algorithms, Oxford University Press, 2006.
[13] N. Nishmura, P. Ragde, D. M. Thilikos, Fast
fixed-parameter tractable algorithms for non-
trivial generalizations of vertex cover, Discrete
Applied Mathematics 152 (2005), pp. 229–245.
[14] S. B. Seidman and B. L. Foster, A graph-
theoretic generalization of the clique concept,
The Journal of Mathematical Sociology 6 (1978),
pp. 139–154
[15] S. Trukhannov, Novel approaches for solving
large-scale optimization problems on graphs, PhD
thesis, A&MUniversity, Texas.
[16] B. Wu and X. Pei, A parallel algorithm for enu-
merating all the maximal k-plexes. Proceedings
of PAKDD 2007, LNAI 4819 (2007), pp. 476–
483.
208
© ICSEC 2011, September 2011, Bangkok, Thailand.
subgroup in a graph would be a clique, a com-
plete subgraph, but it seems too restricted to
consider a clique as a cohesive subgroup in real
networks. Many clique relaxation models exist
for defining cohesive subgraphs in social net-
works, such as k-club, k-plex, etc. The concept
of densest k-sets is one of them.
Define the density of a graph G = (V,E) to
be |E|/|V |. Use d(S) to denote the density of
the subgraph of G induced by vertex set S. A
densest set of a graph G = (V,E) is a subset D
of V such that the density of G[D] is maximum
among all subgraphs of G induced by non-
empty subsets of V . We call a subset S of a
graph G = (V,E) a k-set (resp. at-least-k-set, at-
most-k-set) if and only if S is of size k (resp. of
size not less than k, of size not larger than k). A
densest k-set (resp. at-least-k-set, at-most-k-set)
S of G is a k-set (resp. at-least-k-set, at-most-k-
set) of G such that the density of G[S] is max-
imum among all subgraphs of G induced by
k-sets (resp. at-least-k-sets, at-most-k-sets) of G.
Similarly, a sparsest k-set (resp. at-least-k-set, at-
most-k-set) S of G is a k-set (resp. at-least-k-set,
at-most-k-set) of G such that the density of G[S]
is minimum among all subgraphs of G induced
by k-sets (resp. at-least-k-sets, at-most-k-sets)
of G. It is easy to see that S is a densest k-set
in G if and only if it is a sparsest k-set in G¯, the
complement of G. We say that a vertex v covers
an edge e if v is an end vertex of e. Use CG(S)
for the set of edges covered by a set S ⊆ V . A
minimum (resp. maximum) k-vertex cover of an
undirected graph G is a k-set of G such that
|CG(S)| is minimum (resp. maximum) among all
k-sets of G.
A densest k-set is also called a k-cluster [11].
The problem of finding a densest k-set in an
undirected graph was introduced in [11] by
Corneil and Perl. It is a generalization of the
maximum clique problem. The following prob-
lems are closely related.
DENSEST SET Problem [19]
Input: A simple undirected graph G = (V,E).
Output: A densest set D of G.
DENSEST k-SET Problem [11]
Input: A simple undirected graph G = (V,E)
and a positive integer k.
Output: A densest k-set of G.
DENSEST AT-LEAST-k-SET Problem [3]
Input: A simple undirected graph G = (V,E)
and a positive integer k.
Output: A densest at-least-k-set of G.
DENSEST AT-MOST-k-SET Problem [3]
Input: A simple undirected graph G = (V,E)
and a positive integer k.
Output: A densest at-most-k-set of G.
WEIGHTED DENSEST k-SET Problem
Input: A simple undirected graph G = (V,E)
with non-negative weights on edges and a
positive integer k.
Output: A k-set S of G such that the total
weight of edges in G[S] is maximum among
all subgraphs induced by k-sets of G.
SPARSEST k-SET Problem
Input: A simple undirected graph G = (V,E)
and a positive integer k.
Output: A sparsest k-set of G.
MAXIMUM k-VERTEX COVER Problem [13]
Input: A simple undirected graph G = (V,E)
and a positive integer k.
Output: A maximum k-vertex cover of G.
MINIMUM k-VERTEX COVER Problem [13]
Input: A simple undirected graph G = (V,E)
and a positive integer k.
Output: A minimum k-vertex cover of G.
PARTIAL VERTEX COVER Problem [20]
Input: A simple undirected graph G = (V,E)
and positive integers k and t.
Question: Is there an at-most-k-set S of G with
that |CG(S)| ≥ t?
Proposition 1. Let S be a k-set of an undirected
graph G = (V,E) where |V | = n. The following
four statements are equivalent.
1) S is a densest k-set of G.
2) S is a sparsest k-set of G¯.
3) V \S is a minimum (n−k)-vertex cover of G
4) V \S is a maximum (n−k)-vertex cover of G¯.
Known result. The DENSEST SET problem can
be solved in polynomial time by solving a
sequence of maximum flow problems [18], [19].
t t t
t t t
t
 
 @
@
v1
v2
v3
v4
v5
v6
v7
G
Figure 1: An example that with different den-
sity functions the DENSEST SET problem have
different solutions.
In Fig. 1, to find a solution S of the DENSEST
SET problem that density(S) is maximized, it is
easy to see that {v1, v2, v7} is a solution because
density({v1, v2, v7}) = 1. However, to find a
solution S of the same problem that d(S) is
maximized, we see that {v1, v2, v3, v4, v5, v6, v7}
is a solution. For the DENSEST k-SET prob-
lem (resp. SPARSEST k-SET problem), the so-
lution sets that d(S) is maximized (resp. min-
imized) and the solution set that density(S)
is maximized (resp. minimized) are the same,
since the number of vertices in a solution is
fixed.
Given a graph G = (V,E), a clique is a
complete subgraph in G and an independent
set is a subset of V that induces a subgraph
of G having no edges. A k-clique is a clique
induced by exact k vertices. A k-independent set
is an independent set having exact k vertices.
Suppose that C is the vertex set of a k-clique
in G. It is easy to see that C is a k-independent
set in G¯. The DENSEST k-SET and SPARSEST
k-SET problems are generalizations of the k-
CLIQUE problem and the k-INDEPENDENT SET
problem, respectively. The MINIMUM VERTEX
COVER problem is a special case of the MAXI-
MUM k-VERTEX COVER problem. All problems
listed in this paper are subset problems and in
the well-known survey [36] of exact algorithms,
for subset problems one often asks to have
exact algorithms that run in O∗(cn) time, c < 2.
However, whether there exists an O∗(cn)-time
algorithm with c < 2 to find a densest k-set
for an undirected graph of n vertices remains
open in the literature. In this paper, we give
the first algorithm that runs in O∗(cn) time
with c < 2 to compute a densest k-set and
a sparsest k-set of an undirected graph of n
vertices. The value of c for the algorithm is
1.7315. Using the algorithm as a procedure, we
also give the first exact algorithms to solve the
DENSEST AT-LEAST-k-SET problem, the DENS-
EST AT-MOST-k-SET problem, the MAXIMUM
k-VERTEX COVER problem, the MINIMUM k-
VERTEX COVER problem, and the PARTIAL
VERTEX COVER problem in O∗(cn) time with
c < 2, respectively. The values of c for these
algorithms remain to be 1.7315.
II. PRELIMINARIES
There are two modified O-notations O˜ and
O∗ used in this paper. An O˜ means O with log-
arithmic factors ignored, i.e., a function f(n) =
O˜(g(n)) if there exist positive constant c, k, and
n0 such that 0 ≤ f(n) ≤ cg(n) logk(n) for all n ≥
n0. An O∗ is used here to bound the running
time of exponential time algorithms asymptot-
ically. For functions f and g, f(n) = O∗(g(n))
if f(n) = O(g(n) · poly(n)) where poly(n) is a
polynomial. For more description about the O∗-
notation, we refer to the book [17].
The algorithm given in this paper is based
on an approach called split and list introduced
in [16], [17], [26], [34], [35]. It can be seen a
kind of divide and conquer. It is well-known
that divide and conquer is a strategy often
used to design efficient algorithms for solving
problems in P. The split and list is an approach
for designing efficient algorithms to solve hard
problems. The word ”split” means that we first
split the problem into parts and the word ”list”
means that for each part we list (enumerate)
all possible solutions for the subproblem cor-
responding to the part. Finally combine those
solutions of subproblems to obtain a solution
of the input by using a fast polynomial time
algorithm. For more details of the concept of
the approach, please refer to Chapter 9 of the
book [17].
For the DENSEST k-SET problem, k is an
input parameter. By brute force algorithm, this
problem can be solved in time O(k2
(
n
k
)
). When
the input k is a small constant, this problem
graph G = (V,E) with respect to a balanced 3-
partition (V1, V2, V3) of V is a vertex set U ⊆ V
such that |U ∩ V1| = k1, |U ∩ V2| = k2, and
|U∩V3| = k3. We use Mij to indicate the entry in
the ith row and the jth column of matrix M . In
this paper, we use the word vertex to mention
a point of undirected graphs and use the word
node for a point of directed graphs. A directed
edge (x, y) in a directed graph H = (V , E) is an
ordered pair of two nodes x, y ∈ V called that
the edge (x, y) leaves node x and enters node y.
A length-2 path x → y → z in a directed graph
H = (V , E) is a path from node x to node z
containing exact two directed edges (x, y) ∈ E
and (y, z) ∈ E , y 6= x, z.
III. AN O∗(1.7315n) ALGORITHM
In this section, we give an exact algorithm
for the SPARSEST k-SET problem. Suppose that
G = (V,E) is an undirected simple graph and S
is a sparsest k-set in G. We reduce the SPARSEST
k-SET problem to the SPARSEST (k1, k2, k3)-SET
problem.
SPARSEST (k1, k2, k3)-SET Problem
Input: A graph G = (V,E) and a balanced
3-partition (V1, V2, V3) of V , and three non-
negative integers k1, k2, k3.
Output: A (k1, k2, k3)-set U with respect to
(V1, V2, V3) such that the number of edges in
G[U ] is maximum among all (k1, k2, k3)-sets
respect to (V1, V2, V3).
For solving the SPARSEST (k1, k2, k3)-SET
problem, we construct an auxiliary edge
weighted graph H = (V , E , w). The graph H is
a directed 3-partite graph where V is the vertex
set and E is the edge set. The vertex set of H is
V = V1 ∪ V2 ∪ V3. Each node x in V1 represents
a vertex set X ⊆ V1, |X| = k1; each node y ∈ V2
represents a vertex set Y ⊆ V2, |Y | = k2; and
each node z ∈ V3 represents a vertex set Z ⊆ V3,
|Z| = k3. Let
E1 = {(x, y) | x ∈ V1 and y ∈ V2},
E2 = {(y, z) | y ∈ V2 and z ∈ V3}, and
E3 = {(z, x) | z ∈ V3 and x ∈ V1}.
The edge set of H is E = E1 ∪ E2 ∪ E3.
For each edge (x, y) ∈ E1, the weight of (x, y)
is
w(x, y) = |EG(X)|+ |EG(X, Y )|
where X ⊆ V1 and Y ⊆ V2 are the vertex sets
associated with x and y.
Similarly, for each (y, z) ∈ E2,
w(y, z) = |EG(Y )|+ |EG(Y, Z)|
where Y ⊆ V2 and Z ⊆ V3 are the vertex sets
associated with y and z.
For each (z, x) ∈ E3,
w(z, x) = |EG(Z)|+ |EG(Z,X)|
where Z ⊆ V3 and X ⊆ V1 are the vertex sets
associated with z and x.
Definition 2. A directed triangle (x, y, z) in H
is a 3-cycle x→ y → z → x where x ∈ V1, y ∈ V2,
and z ∈ V3. Define w(x, y, z) = w(x, y)+w(y, z)+
w(z, x) to be the edge weight of a directed triangle
in H .
Lemma 3. For a graph G = (V,E) and a bal-
anced 3-partition (V1, V2, V3) of V , S ⊆ V is a
(k1, k2, k3)-set such that G[S] has ` edges if and
only if there exists a directed triangle (x, y, z) with
edge weight ` in the corresponding auxiliary graph
H = (V , E) of G with respect to the balanced 3-
partition (V1, V2, V3).
Proof: Suppose that S ⊆ V is a (k1, k2, k3)-
set in G = (V,E) with respect to a balanced 3-
partition (V1, V2, V3) of V such that |S∩V1| = k1,
|S ∩ V2| = k2, and |S ∩ V3| = k3. Let X = S ∩ V1,
Y = S ∩ V2, and Z = S ∩ V3. There exists a
directed triangle (x, y, z) in H where nodes x ∈
V1, y ∈ V2, and z ∈ V3 represent X , Y , and
Z, respectively. Then the edge weight of the
directed triangle (x, y, z) is
w(x, y, z) = w(x, y) + w(y, z) + w(z, x)
= |EG(X)|+ |EG(X, Y )|+
|EG(Y )|+ |EG(Y, Z)|+
|EG(Z)|+ |EG(Z,X)|
= EG(S)
= `.
The Split-and-List Algorithm
Input: A graph G = (V,E) and a positive
integer k.
Output: A sparsest k-set S of G.
1) Partition V to be a balanced 3-partition
(V1, V2, V3).
2) For each (k1, k2, k3) satisfying k1 + k2 +
k3 = k, solve the SPARSEST (k1, k2, k3)-
SET problem given G = (V,E) and the
balanced 3-partition (V1, V2, V3) computed
in Step 1.
3) Return a set S such that G[S] has min-
imum number of edges among all solu-
tions S ′ of the SPARSEST (k1, k2, k3)-SET
problems found in Step 2.
Theorem 1. The Split-and-List algorithm solves
the SPARSEST k-SET problem on n-vertex graphs
in time O∗(2ωn/3) = O∗(1.7315n), where ω < 2.376
is the square matrix multiplication exponent.
Proof: In Step 1 of the Split-and-List al-
gorithm the balanced 3-partition (V1, V2, V3) is
with |V1| ≤ |V2| ≤ |V3| ≤ dn/3e. The number of
vertices in H is
|V| = |V1|+ |V2|+ |V3|
=
(|V1|
k1
)
+
(|V2|
k2
)
+
(|V3|
k3
)
≤
(dn
3
e
k1
)
+
(dn
3
e
k2
)
+
(dn
3
e
k3
)
≤ 3 · 2dn/3e.
According to Lemma 5 the SPARSEST
(k1, k2, k3)-SET problem can be solved in time
O˜(k2|V|ω) where ω is the square matrix multi-
plication exponent, ω < 2.376. We have
O˜(k2 · |V|ω) = O∗(k2 · 2dωn/3e)
= O∗(k2 · 20.792n)
= O∗(k2 · 1.7315n).
Since there are
(
k+2
2
)
= O(k2) possibilities of
(k1, k2, k3) satisfying k1 + k2 + k3 = k, Step 2
of the Split-and-List is executed O(k2) times.
Thus the execution time spent in Step 2 is
O∗(k4 · 1.7315n) = O∗(1.7315n). It takes O(n)
time to obtain a balanced 3-partition in Step 1
and it takes O(k2) time in Step 3 to obtain
an optimal solution. The total running time of
the Split-and-List algorithm is O∗(1.7315n). This
completes the proof.
IV. CONCLUDING REMARKS
Given a sparsest k-set S of G, we can easily
obtain that V \ S is a maximum (n− k)-vertex
cover of G, V \ S is a minimum (n − k)-
vertex cover of G¯, and S is a densest k-set
of G¯. Moreover, by executing the algorithm k
times, we can obtain a densest at-most-k-set
of G¯. The DENSEST AT-LEAST-k-SET problem
can also be solved by calling the Split-and-List
algorithm (n − k) times. The PARTIAL VER-
TEX COVER problem with parameters k and
t (using at most k vertices to cover at least
t edges) can be solved by taking the Split-
and-List algorithm as a procedure to solve the
SPARSEST (n − k)-SET problem. Thus all these
DENSEST k-SET, SPARSEST k-SET, MAXIMUM k-
VERTEX COVER, MINIMUM k-VERTEX COVER,
DENSEST AT-MOST-k-SET, DENSEST AT-LEAST-
k-SET, and PARTIAL VERTEX COVER problems
can be solved in time O∗(1.7315n).
REFERENCES
[1] S. Arora, D. Karger, and M. Karpinski, Polynimial time
approximation schemes for dense instances of NP-hard
problems, In Proceedings of the 27th Annual ACM Sympo-
sium on Theory of Computing, pp. 284–293, 1995.
[2] Y. Asahiro, K. Iwama, H. Tamaki and T. Tokuyama,
Greedily finding a dense subgraph, Journal of Algorithms,
34 (2000), pp. 203–221.
[3] R. Andersen and K. Chellapilla, Finding dense subgraphs
with size bounds, In Proceedings of WAW’09, pp. 25–36,
2009.
[4] J. Backer and J. M. Keil, Constant factor approximation
algorithms for the densest k-subgraph problem on proper
interval graphs and bipartite permutation graphs, Infor-
mation Processing Letters 110 (2010), pp. 635–638.
[5] A. Bhaskara, M. Charika, E. Chlamtac, U. Feige, and A.
Vijayaraghavan, Detecting high log-densities: an O(n1/4)-
approximation algorithms for the densest k-subgraph,
In Proceedings of the 42nd ACM Symposium on Theory of
Computing (STOC’10), pp. 201–210, 2010.
[6] A. Billonnet and F. Roupin, A deterministic approxi-
mation algorithm for the densest k-subgraph problem,
Journal of Operational Research 3 (2008), pp. 301–314.
[7] A. Billonnet, S. Elloumi, M-C. Plateau, Improving the
performance of standard solvers for quadratic 0-1 pro-
grams by a tight convex reformulation: The QCR method,
Discrete Applied Mathematics 157 (2009), pp. 1185–1197.
[8] L. Cai. Parameterized complexity of cardinality con-
strained optimization problems. The Computer Journal, 51
(2008), pp. 102–121.
Measure and Conquer:
Analysis of a Branch-and-Reduce Algorithm for the Maximum
Bounded-degree-1 Set Problem∗
Maw-Shang Chang†
Department of Computer Science and Information Engineering
HungKuang University, Taichung 43302, Taiwan
mschang@sunrise.hk.edu.tw
Ling-Ju Hung, and Ping-Chen Su
Department of Computer Science and Information Engineering
National Chung Cheng University, Chiayi 62102, Taiwan
{hunglc,spc98m}@cs.ccu.edu.tw
Abstract
Recently Measure and Conquer is used to ob-
tain tighter bounds of running time of branch-and-
reduce algorithms. A graph is bounded-degree-1 if
its maximum degree is less than or equal to one.
The maximum bounded-degree-1 set problem is
to find a vertex subset of maximum size that in-
duces a bounded-degree-1 subgraph. The problem
that to find a maximum bounded-degree-1 set in
a given graph is NP-hard. Chang et al. gave an
O∗(1.5171n)-time exact algorithm to solve it where
n is the number of vertices in the input graph [7].
In this paper, we modify this algorithm and ana-
lyze the new algorithm by the measure and conquer
approach. We show that the running time of the
new algorithm is O∗(1.4834n).
1 Introduction
The technique Branch and Reduce is one of
the major techniques used to design exact algo-
rithms. It is a recursive procedure consisting of
reduction rules and branching rules. The reduc-
tion rules are used to reduce the problem size, and
the branching rules are used to branch the original
problem into subproblems having smaller input
sizes. Branch-and-reduce algorithms always find
∗This research is partially supported by the National
Science Council of Taiwan under grants NSC 98–2221–E–
194–026–MY3 and NSC 99–2221–E–194–017–MY3.
†This work was partially done while this author was
with Department of Computer Science and Information En-
gineering, National Chung Cheng University.
optimal solutions. Search trees are often used to
illustrate the execution of a branching algorithm.
Let T (n) be the maximum number of leaves in
any search tree where n is the input size. We
analyze each branching rule and use the worst-
case time complexity over all branching rules as
an upper bound of the running time. Let b be any
branching rule. When rule b is applied, the cur-
rent instance is branched into r ≥ 2 instances of
size at most n − t1, n − t2, . . . , n − tr. Note that
n ≥ ti and ti ∈ R+ for i = 1, 2, . . . , r. We call
b = (t1, t2, . . . , tr) the branching vector of branch-
ing rule b. This can be formulated in a linear re-
currence
T (n) ≤ T (n− t1) + T (n− t2) + · · ·+ T (n− tr).
For functions f and g we write f(n) = O∗(g(n)) if
f(n) = O(g(n)poly(n)), where poly(n) is a polyno-
mial. Then T (n) = O∗(τn) where τ is the unique
positive real root of
xn − xn−t1 − xn−t2 − · · · − xn−tr = 0.
We call τ the branching number1 of branching
rule b [14]. If a branch-and-reduce algorithm has
several branching rules, then the running time of
it is O∗(αn) where α is the maximum branching
number among all branching rules.
Recently measure and conquer is used to obtain
tighter bounds on running time of many branch-
and-reduce algorithms [8, 4, 11, 9, 12, 13, 6, 14].
1To compute the branching number of a branch-
ing vector, please visit the following webpage:
http://ufo.cs.ccu.edu.tw/resources.htm
The 29th Workshop on Combinatorial Mathematics and Computation Theory
136
Before we present the algorithm, we define a
rule called Standard Branching Rule: When
the algorithm applies this rule, it selects a ver-
tex v of degree d and recursively solves d + 2
MAX-1-BDS problems on graphs Gi = G \ Ui,
respectively, where 1 ≤ i ≤ d + 2, N(v) =
{u1, u2, . . . , ud}, U1 = {v}, U2 = N [v], and for
i > 2, Ui = N [{v, ui−2}]. And then β1(G) =
max{β1(G1), 1+β1(G2),max3≤i≤d+2(2+β1(Gi))}.
In the first branch of standard branching rule, it
discards v. In the second branch, it selects v and
discards N(v). In each of the other branches, it
selects v and a neighbor u and discards N({v, u}).
The description of the algorithm consists of a
sequence of cases and subcases. To avoid a confus-
ing nesting of if-then-else statements let us use the
following convention: The first case which applies
is used in the algorithm. Thus, inside a given case,
the hypotheses of all previous cases are assumed
to be false. Algorithm β1(G) computes for a given
graph G = (V,E) the maximum size of a vertex
set S inducing a bounded-degree-1 subgraph.
1. Maximum Degree-Two Rule. All vertices
are of degree at most two. In this case we
solve the problem in polynomial time.
2. Isolated-Vertex Rule. There is an isolated
vertex and let X be the set of all isolated ver-
tices. Then β1(G) = |X |+ β1(G \X).
3. Isolated-Edge Rule. There is an isolated
edge and let X be the set of all isolated edges.
Then β1(G) = 2 · |X |+ β1(G \ V (X)).
4. Degree-One Edge Rule. There is an edge
(u, v) of degree one and let X = N [{u, v}].
Then β1(G) = 2 + β1(G \X).
5. Degree-One Vertex Rule 1. There is a
vertex v having at least two degree-one neigh-
bors and let X be the set of all degree-one
neighbors of v. Then β1(G) = |X | + β1(G \
(X ∪ {v})).
6. True-Twin Rule 1. There are two vertices
v and z such that N [z] = N [v], i.e., v and z
are true twins and dG(v) = dG(z) = 3. The
algorithm selects {v, z} and discards N(v) \
{z}. Hence β1(G) = 2 + β1(G \N [v]).
7. True-Twin Rule 2. There are two vertices
v and z such that N [z] = N [v], i.e., v and
z are true twins as Fig. 1(a). Since Degree-
One Edge Rule and True-Twin Rule 1 are not
applicable, the degrees of v and z are at least
four. The algorithm either discards {v, z} or
selects {v, z} and discardsN [v]\{v, z}. Hence
β1(G) = max{β1(G\{v, z}), 2+β1(G\N [v])}.
The worst branching vector is (2, 5) and its
branching number is 1.2366.
8. False-Twin Rule. There exist two vertices
u and v that are false twins in G as shown
in Fig. 1(b). The algorithm either discards
both u and v or selects both u and v. That is
β1(G) = max{β1(G\{u, v}), 2+β1(G\(N [v]∪
{u}))}. Since dG(u) = dG(v) ≥ 2, the worst
branching vector is (2, 4) and its branching
number is 1.2721.
9. Degree-One Vertex Rule 2. There is a
vertex v having a degree-one neighbor z as
Fig. 1(c). Since Degree-One Vertex Rule 1
and Degree-One Edge Rule are not applica-
ble, the degree of v is at least three and the
neighbors of v other than z are of degree
at least two. Otherwise (v, z) is an edge of
degree at most one. In this case the algo-
rithm either discards v and selects z or selects
{v, z} and discards N [v]\{v, z}, i.e., β1(G) =
max{1 + β1(G \ {v, z}), 2 + β1(G \ N [v])}.
The worst branching vector is (2, 4) and its
branching number is 1.2721.
10. Domination Rule 1. Let v be a vertex of
G and u be a neighbor of v satisfying that
N [u] ⊂ N [v] as Fig. 1(d). The degree of v
is at least 3. The algorithm either discards
v or selects {v, u} and discards N [v] \ {v, u}.
Hence β1(G) = max{β1(G \ {v}), 2 + β1(G \
N [v])}. The worst branching vector is (1, 4)
and its branching number is 1.3803.
11. Degree-Two Vertex Rule 1. There is a
degree-two vertex z satisfying the condition
that the neighbor v with larger degree be-
tween the two neighbors of z is of degree
at least three. Let x be the neighbor of
z other than v. Since Domination Rule is
not applicable, x and v are not adjacent and
|N [u] \ N [v]| ≥ 1 for any u ∈ N(v). The
degree of x is two as Fig. 1(e). The algo-
rithm either selects both x and z or selects
v and z or selects x, y, v and one of v’s
neighbor p other than z. That is β1(G) =
max{2+β1(G\(N [x]∪N [z])), 2+β1(G\(N [v]∪
N [z])), 4+maxU∈U(β1(G\(N [U ]∪N [{x, y}])}
where U = {{v, p} | p ∈ N(v), p 6= z}.
The worst case happens when degree of v is
three. The branching vector is (4, 5, 6, 6) and
its branching number is 1.3086.
The 29th Workshop on Combinatorial Mathematics and Computation Theory
138
N(v)\{z}}. Then β1(G) = max{β1(G\v), 1+
β1(G\N [v]),maxU∈U(2+β1(G\N [U ])}. The
worst case time complexity happens when the
degree of v is four. The branching vector
is (1, 5, 7, 7, 7) and its branching number is
1.4852.
17. Maximum-Degree Rule. Let v be a ver-
tex of maximum degree of G as Fig. 1(j).
Since Difference Rule 2 is not applicable,
|N [u] \ N [v]| ≥ 2 for any u ∈ N(v). In
this case we apply Standard Branching
Rule. With simple calculations we see that
the worst case happens when the degree of v is
four. The branching vector is (1, 5, 7, 7, 7, 7)
and its branching number is 1.5171 in this
case.
Theorem 1. The MAX-1-BDS problem can be
solved in O∗(1.5171n) time.
3 Measure and Conquer Analysis
We analyze the algorithm presented in Sec-
tion 2 in two stages: (i) the maximum degree of
the input graph is at least five and (ii) the max-
imum degree of the input graph is at most four.
If the maximum degree of input graph is at least
five, we can analyze the algorithm by simple anal-
ysis as Section 2. We see that the worst case hap-
pens when the Maximum-Degree Rule is applied
and its branching number is (1, 6, 8, 8, 8, 8, 8) and
the branching number is 1.474151. For any other
branching rule applied on an instance with max-
imum degree at least five, its branching number
is less than 1.474151. For input graph with max-
imum degree at most four, we use measure and
conquer approach.
For simplicity, we will slightly abuse the no-
tation. Use wi to denote the weight of a vertex
of degree i, wv to denote the weight of vertex v,
wG =
∑
v∈V wv to denote the weight of G where
G = (V,E) is the input graph. Use w for wG if
G is understood without ambiguity. We assume
wj ≥ wi iff j > i throughout this section. Let
∆wi = wi − wi−1 for i > 0. The size of the input
is the weight wG of the input graph. Suppose that
we apply a branching rule b and (t1, t2, . . . , tr) is
the corresponding branching vector. Then we ob-
tain a recurrence
T (wG) = T (wG − t1) + · · ·+ T (wG − tr).
Let α be the branching number of this rule. We see
that O∗(αwG) = O∗(αn) is the worst case running
time of this rule since wG ≤ n.
All reduction rules are done in polynomial time.
Hence we can focus on branching rules in the anal-
ysis. We will analyze all branching rules one by
one. A branching rule may incur several recur-
rence relations. In Table 2, we list all recurrence
relations associated with each branching rules.
Now we are ready to analyze branching rules.
Consider True-Twin Rule 2 first.
True-Twin Rule 2. The algorithm recursively
solves two MAX-1-BDS problems on graphs G1 =
G \ {v, z} and G2 = G \ N [v], respectively, in
this case. The recurrence relation for this rule is
T (w) = T (wG1)+T (wG2) = T (w− t1)+T (w− t2)
where t1 = w − wG1 and t2 = w − wG2 and
the branching vector is (t1, t2). For vertex u, use
∆1(u) for the weight of u in G minus the weight of
u in G1 and ∆2(u) for the weight of u in G minus
the weight of u in G2. By definition,
t1 = wdG(v) + wdG(z) +
∑
u∈N(v)\{z}
∆1(u);
t2 =
∑
u∈N [v]
wdG(u) +
∑
u∈N2(v)
∆2(u).
Since Degree-1-Edge Rule and True-Twin Rule 1
are not applicable, dG(v) = dG(z) = 4 and |N [v] \
{z}| ≥ 2.
t1 ≥
∑
x∈{v,z}
wdG(x)+∑
u∈N(v)\{z}
(wdG(u) − wdG(u)−2) ≥ 2w4;
t2 ≥
∑
u∈N [v]
wdG(u) +
∑
u∈N2(v)
∆wdG(u)
≥ 3w2 + 2w4.
False-Twin Rule. Suppose that the degree of
v is d, N(v) = {u1, u2, . . . , ud}, and u and v
are false twins, i.e., u ∈ N2(v) and N(u) =
{u1, u2, . . . , ud}. Define G1 = G \ U1 and G2 =
G \ U2 where U1 = {v, u} and U2 = N [{v, u}].
The algorithm recursively solves two MAX-1-BDS
problems on graphsG1 andG2 respectively. Hence
T (w) = T (wG1) + T (wG2)
and
T (w) = T (w − (w − wG1)) + T (w − (w − wG2)).
Define ti = w−wGi . Then the branching vector
is (t1, t2) in this case. Use ∆i(q) for the weight of
The 29th Workshop on Combinatorial Mathematics and Computation Theory
140
And
T (w) =
d+2∑
i=1
T (w − (w − wGi)).
Define ti = w − wGi . Then the branching vector
is (t1, t2, . . . , td+2) in this case. Use ∆i(u) for the
weight of vertex u in G minus the weight of u in
Gi. Then we have
ti =
∑
p∈Ui
wdG(p) +
∑
q∈N(Ui)
∆i(q).
Since Domination Rule 1 and False-Twin Rule
are not applicable, every uj , 1 ≤ j ≤ d, has a
private neighbor with respect to v. Note that 3 ≤
dG(v) ≤ 4. Hence for dG(v) = 3,
t1 ≥ w2 + 2w3 + 3 min
2≤i≤4
∆wi,
t2 ≥ 3w2 + 2w3 + min
2≤i≤4
∆wi,
t3 ≥ 3w2 + 2w3 + min
2≤i≤4
∆wi,
t4 = t5 ≥ 3w2 + 2w3 +∆w3.
For dG(v) = 4,
t1 ≥ w2 + w3 + w4 + 3 min
2≤i≤4
∆wi,
t2 ≥ 3w2 + w3 + w4 + min
2≤i≤4
∆wi,
t3 ≥ 4w2 + w3 + w4 + min
2≤i≤4
∆wi,
t4 = t5 = t6 ≥ 4w2 + w3 + w4 + min
3≤i≤4
∆wi.
Difference Rule 1. Suppose the degree of v is d
and N(v) = {u1, u2, . . . , ud = y}. For 1 ≤ i ≤ d,
define Gi = G \ Ui where U1 = {v} and for
i > 1, Ui = N [{v, ui−1}]. The algorithm recur-
sively solves d MAX-1-BDS problems on graphs
G1, G2, . . . , Gd, respectively. Hence
T (w) =
d∑
i=1
T (wGi)
and
T (w) =
d∑
i=1
T (w − (w − wGi)).
Define ti = w−wGi . Then the branching vector
is (t1, t2, . . . , td) in this case. Use ∆i(q) for the
weight of vertex q in G minus the weight of q in
Gi. Then we have
ti =
∑
p∈Ui
wdG(p) +
∑
q∈N(Ui)
∆i(q).
Since Domination Rule 1 is not applicable, every
uj , 1 ≤ j ≤ d, has a private neighbor with re-
spect to v. Since False-Twin Rule and Domina-
tion Rule 1 are not applicable, |N2(v)| > 1. Note
that d(v) = 4. Let ∆wmin = min{∆w3,∆w4}.
t1 ≥ w4 + 4∆wmin,
and for 2 ≤ i ≤ 4,
ti ≥ 5w3 + w4 +∆wmin.
Difference Rule 2. Suppose the degree of v is d
and N(v) = {u1, u2, . . . , ud}. For 1 ≤ i ≤ d + 1,
define Gi = G \ Ui where U1 = {v} and for i >
1, Ui = N [{v, ui−1}]. The algorithm recursively
solves (d + 1) MAX-1-BDS problems on graphs
G1, G2, . . . , Gd+1, respectively. Hence
T (w) =
d+1∑
i=1
T (wGi)
and
T (w) =
d+1∑
i=1
T (w − (w − wGi)).
Define ti = w−wGi . Then the branching vector
is (t1, t2, . . . , td+1) in this case. Use ∆i(q) for the
weight of vertex q in G minus the weight of q in
Gi. Then we have
ti =
∑
p∈Ui
wdG(p) +
∑
q∈N(Ui)
∆i(q).
Since Domination Rule 1 is not applicable, every
uj , 1 ≤ j ≤ d, has a private neighbor with re-
spect to v. Since False-Twin Rule and Domination
Rule 1 are not applicable, |N2(v)| > 1. Due to Dif-
ference Rule 1 is not applicable, every uj , 1 ≤ j ≤
d has a private neighbor with respect to any other
uℓ ∈ N(v). We see that |N2(v)| ≥ 4. Note that
d(v) = 4. Let ∆wmin = min{∆w3,∆w4}.
t1 ≥ w4 + 4∆wmin,
and for 2 ≤ i ≤ 5,
ti ≥ 5w3 + w4 + 3∆wmin.
Domination Rule 2. Suppose the degree of v is d
and N(v) = {u1, u2, . . . , ud = z}. For 1 ≤ i ≤ d+
1, define Gi = G \Ui where U1 = {v}, U2 = N [v],
and for i > 2, Ui = N [{v, ui−2}]. The algorithm
recursively solves (d + 1) MAX-1-BDS problems
on graphs G1, G2, . . . , Gd+1, respectively. Hence
The 29th Workshop on Combinatorial Mathematics and Computation Theory
142
and its branching number is (1.296212, 5.296212,
6.777841, 6.777841, 6.777841, 6.777841) with re-
spect the weight vectorw = (w0, w1, w2, w3, w4) =
(0, 0.5, 0.851306, 0.925947, 1) and the correspond-
ing branching number is 1.483369. Hence all
branching numbers of the algorithm are bounded
by 1.483369. Thus the MAX-1-BDS problem can
be solved in time O∗(1.4834n).
References
[1] B. Balasundaram, Cohesive subgroup model
for graph-based text mining, Proceedings of
the 2008 IEEE Conference on Automation
Science and Engineering, pp. 989–994, 2008.
[2] B. Balasundaram, S. Butenko, and
I. V. Hicks, Clique relaxations in social
network analysis: The maximum k-plex
problem, Operations Research, 59 (2011),
pp. 133–142.
[3] B. Balasundaram, S. Chandramouli, and
S. Trukhanov, Approximation algorithms for
finding and partitioning unit-disk graphs into
co-k-plexes, Optimization Letters, 4 (2010),
pp. 311–320.
[4] R. Beigel and D. Eppstein, 3-coloring in
time O(1.3289n), Journal of Algorithms, 54
(2005), pp. 168–204.
[5] N. Betzler, R. Bredereck, R. Niedermeier,
and J. Uhlmann, On bounded-degree vertex
deletion parameterized by treewidth, Discrete
Applied Mathematics, 160 (2012), pp. 53–60.
[6] D. Binkele-Raible, Amortized Analysis of Ex-
ponential Time- and Parameterized Algo-
rithms: Measure & Conquer and Reference
Search Trees, PhD Thesis, Trier University,
2010.
[7] M.-S. Chang, L.-J. Hung, and P.-C. Su, Exact
and fixed-parameter algorithms for problems
related to 2-plex, Proceedings of ICSEC 2011,
pp. 203–208, 2011.
[8] D. Eppstein, Quasiconvex analysis of
backtracking algorithms, Proceedings of
SODA 2004, pp. 781–790, 2004.
[9] D. Eppstein, Quasiconvex analysis of mul-
tivariate recurrence equations for backtrack-
ing algorithms, ACM Transactions on Algo-
rithms 2 (2006), pp. 492–509.
[10] M. R. Fellows, J. Guo, H. Moser, and R. Nie-
dermeier, A generalization of Nemhauser and
Trotter’s local optimization theorem, Journal
of Computer and System Sciences, 77 (2011),
pp. 1141–1158.
[11] F. V. Fomin, F. Grandoni, and D. Kratsch,
Measure and conquer: domination – a
case study, Proceedings of ICALP 2005,
LNCS 3580 (2005), pp. 191–203.
[12] F. V. Fomin, F. Grandoni, and D. Kratsch,
Measure and conquer: a simple O(20.288n)
independent set algorithm, Proceedings of
SODA 2006, pp. 18–25, 2006.
[13] F. V. Fomin, F. Grandoni, and D. Kratsch, A
measure & conquer approach for the analysis
of exact algorithms, Journal of the ACM 56
(2009) Article No. 25.
[14] F. Fomin and D. Kratsch, Exact Exponential
Algorithms, Springer, 2010.
[15] C. Komusiewicz, F. Hu¨ffner, H. Moser, and
R. Niedermeier, Isolation concepts for effi-
ciently enumerating dense subgraphs, The-
oretical Computer Science, 410 (2009),
pp. 3640–3654.
[16] B. McClosky and I.V. Hicks, Combinatorial
algorithms for the maximum k-plex problem,
Journal of Combinatorial Optimization, 23
(2012) pp. 29–49.
[17] H. Moser, R. Niedermeier, and M. Sorge,
Exact combinatorial algorithms and experi-
ments for finding maximum k-plexes, To ap-
pear in Journal of Combinatorial Optimiza-
tion (DOI 10.1007/s10878-011-9391-5).
[18] N. Nishmura, P. Ragde, D. M. Thilikos,
Fast fixed-parameter tractable algorithms for
nontrivial generalizations of vertex cover,
Discrete Applied Mathematics, 152 (2005),
pp. 229–245.
[19] S. B. Seidman and B. L. Foster, A graph-
theoretic generalization of the clique concept,
The Journal of Mathematical Sociology, 6
(1978), pp. 139–154.
[20] S. Trukhannov, Novel approaches for solving
large-scale optimization problems on graphs,
PhD Thesis, A&M University, Texas, 2008.
The 29th Workshop on Combinatorial Mathematics and Computation Theory
144
國科會補助專題研究計畫項下出席國際學術會議心得報告
日期:101年 10月31日
計畫編號
NSC 98–2221–E–241–018–MY3
(NSC 98–2221–E–194–026–MY3)
計畫名稱 社群偵測之固定參數暨正確解演算法設計
出國人員姓名 張貿翔
服務機構及
職稱
弘光科技大學資訊工程
學系教授
會議時間
100 年 9 月 6 日至
100 年 9 月 10 日
會議地點 泰國曼谷
會議名稱
(中文)第十五屆國際計算機科學和工程研討會
(英文) The 15th International Computer Science and
Engineering (ICSEC 2011)
發表論文題目
(中文) 2-Plex相關問題的正確解和固定參數演算法
(英文) Exact and Fixed-Parameter Algorithms for
Problems Related to 2-Plex
一、 參加會議經過
我們於九月六日於桃園機場搭機赴曼谷, 於機場搭計程車到ICSEC 2011舉辦的會
場 Rama Gardens Hotel,這個飯店位於曼谷的市郊距離機場約三十分鐘車程,我們搭
計程車離開機場到 Rama Gardens Hotel遇到下班的車潮, 在第一時間體驗了曼谷的
交通壅塞, 計程車花了一個小時多才抵達飯店。 七日至九日期間為研討會的活動時間,
議程分為英文與泰文兩部分, 與會過程中我們看到很多泰國學生非常踴躍地參與研討
會。
本會議舉辦期間,安排多場演講如下:
• Programming Extreme Scale Computers given by Ewing Lusk (Argonne Na-
tional Laboratory, US)
1
Figure 2: 參加研討會晚宴
究的自主性。
在研討會的晚宴上, 主辦單位頒發了最佳論文獎, 由台灣東華大學資訊工程學系彭
勝龍教授和他的學生獲獎, 因為他們剛好不在場, 由我上台代領獎項 (如圖 3)。 主辦單
位並安排了 Kasetsart 大學的學生在晚宴上表演泰國的傳統舞蹈, 我於晚宴結束時與
這些表演同學照了一張大合照 (圖 4)。
我們這次發表的論文, Exact and Fixed-Parameter Algorithms for Problems
Related to 2-Plex,主要是在社會網路上找到一個聚合子群體的相關問題, 這個問題是
NP-hard,我們改進前人的方法,得到更有效率的演算法可以在社會網路中上找到最大
的2-plex,我的博士生洪綾珠於九月九日下午在研討會會場口頭發表 (圖 5)。
本研討會收錄了以下三篇來自台灣的論文和一篇 poster:
• Maw-Shang Chang, Ling-Ju Hung, and Ping-Chen Su, Exact and Fixed-
Parameter Algorithms for Problems Related to 2-plex.
• Sheng-Lung Peng and Yu-Wei Tsay, On the Usage of Graph Spectra in
Protein Structural Similarity.
3
Figure 5: 博士生洪綾珠上台發表論文Exact and Fixed-Parameter Algorithms for
Problems Related to 2-Plex
• Ro-Yu Wu, An-Hang Chen, and Jou-Ming Chang, An Improved Loopless
Algorithm for Generating Binary Tree Sequences.
• Chung-Kung Yen, Sen-Miao Chen, Jia-Jie Liu, and Shun-Chieh Chang,
Pratical variations of the p-center problem on graphs (Poseter)
二、與會心得
這是我們第一次到泰國曼谷,第一眼看到曼谷的建築物會有種彷彿置身台北的感覺,
四處都是高樓大廈林立, 馬路上擁擠的車潮, 塞車對於曼谷的開車族就好像是日常生活
的一部分, 市中心的捷運車廂十分明亮寬敞, 遇到需要幫忙的外國人, 當地人都很熱心,
讓我們感覺到濃濃的人情味。
本次ICSEC 2011主辦單位邀請到數位國際知名學者擔任講者, 講述他們在其研究
領域上最新的發展,讓我們可以了解到國際學術研究之最新導向。 以環繞著multipro-
5
Exact and Fixed-Parameter Algorithms for Problems Related to 2-Plex ∗
Maw-Shang Chang, Ling-Ju Hung, and Ping-Chen Su
Department of Computer Science and Information Engineering
National Chung Cheng University, Chiayi 62102, Taiwan
{mschang,hunglc,spc98m}@cs.ccu.edu.tw
Abstract
Finding cohesive subgroups is an important issue
in studying social networks. Many models exist for
defining cohesive subgraphs in social networks, such as
clique, k-clique, k-club, etc. The concept of k-plex is
one of them. Given an undirected graph G = (V,E), a
k-plex S ⊆ V induces a subgraph G[S] such that every
vertex in G[S] has degree at least |S| − k. In this paper
we study the complement problem of the maximum 2-
plex problem called themaximum bounded-degree-
1 subset problem. The maximum bounded-degree-1
subset problem is to find a vertex subset of maximum
size that induces a bounded-degree-1 subgraph. A graph
G has a 2-plex of size s iff the complement graph of G
has a bounded degree-1 subset of size s. We give new re-
duction rules to improve the fixed-parameter algorithm
in [11] and obtain an exact algorithm for solving the
same problem. The running time of the fixed parame-
ter algorithm is O∗(1.7964p) where p is the number of
vertices to be removed such that the remaining graph is
bounded-degree-1 and the running time of the exact al-
gorithm is O∗(1.5171n) where n is the number of ver-
tices in the given graph.
Key Words: 2-plex, bounded-degree-1 subset, ex-
act algorithm, fixed-parameter algorithm
1. Introduction
Locating cohesive subgroups in social networks
helps people to understand the structures of net-
works. Finding cohesive subgroups in social net-
works can be considered as a problem of graph
clustering. Unfortunately there is no standard way
to define cohesive subgroups in networks. One
possible definition of a cohesive subgroup in a
graph would be a clique, a complete subgraph, but
it seems too restricted to consider a clique as a cohe-
sive subgroup in real networks. A k-plex of a graph
G = (V,E) is a vertex set S ⊆ V such that every
∗This research is partially supported by the National Science
Council of Taiwan under grants NSC 98–2221–E–194–026–MY3
and NSC 99–2221–E–194–017–MY3.
vertex in G[S] has degree at least |S| − k. It is de-
fined as a degree based relaxed model for finding
cohesive subgroups introduced by Seidman and
Foster [14]. Notice that a 1-plex is a clique. Themax-
imum k-plex problem in a given graph G is to find a
k-plex in Gwith maximum cardinality.
LetG = (V,E) be a simple undirected graph. For
a vertex v in G, use N(v) to denote the set of ver-
tices adjacent to v and use N [v] = N(v) ∪ {v}. We
call |N(v)| the degree of v. For a graphG = (V,E) let
∆(G) be the maximum degree ofG. We call a graph
G BOUNDED-DEGREE-d iff ∆(G) ≤ d. A ver-
tex subset S ofG is called a BOUNDED-DEGREE-d
Subset if ∆(G[S]) ≤ d. In the following, d is a fixed
positive integer. We list some related problems.
BOUNDED-DEGREE-d SUBSET (d-BDS)
Input: A graphG = (V,E) and a positive integer s.
Question: Is there a vertex set S ⊆ V of size at least
s such that G[S] is BOUNDED-DEGREE-d?
MAXIMUM BOUNDED-DEGREE-d SUBSET (MAX-
d-BDS)
Input: A graph G = (V,E).
Output: A vertex set S ⊆ V of maximum cardinal-
ity such that G[S] is BOUNDED-DEGREE-d.
BOUNDED-DEGREE-d VERTEX DELETION (d-BDD)
Input: An undirected graph G = (V,E) and a pos-
itive integer p.
Question: Is there a vertex set X ⊆ V of size at
most p making G[V \ X ] a graph of BOUNDED-
DEGREE-d?
MINIMUM BOUNDED-DEGREE-d VERTEX DELE-
TION (MIN-d-BDD)
Input: An undirected graph G = (V,E).
Output: A vertex set X ⊆ V of minimum cardinal-
ity such that G[V \X ] is BOUNDED-DEGREE-d.
By definition, a k-plex in G is a (k − 1)-BDS in
the complement graph of G, say G¯. Thus a graph
G with n vertices has a k-plex of size s iff G¯ has a
(k − 1)-BDS with s vertices. Also G¯ has a (k − 1)-
BDD set of size (n− s). Suppose that the minimum
(k − 1)-BDD set of G¯ is p. It is easy to see that the
203
© ICSEC 2011, September 2011, Bangkok, Thailand.
We close this section with some notation. Given
a graphG = (V,E), we use n to denote the number
of vertices inG. Two vertices u and v are called true
twins in G if N [u] = N [v]. A vertex v is called an
isolated vertex if |N(v)| = 0 and is called a degree-one
vertex if |N(v)| = 1. For an edge (u, v) ∈ E, define
the degree of (u, v) to be |N(u) ∪N(v) \ {u, v}|. An
edge (u, v) is called an isolated edge if |N(u)∪N(v)\
{u, v}| = 0 and is called a degree-one edge if |N(u) ∪
N(v) \ {u, v}| = 1. For a vertex subset X , let G[X ]
denote the graph induced byX in G. We useG \X
to denote G[V \X ]. LetW ⊆ E be a subset of edge
set, use V (W ) = ∪(u,v)∈W {u, v}. For a vertex subset
U ⊆ V , let N(U) = ∪u∈UN(u) \ U and N [U ] =
N(U) ∪ U .
3. An exact algorithm for MAX-1-BDS
In this section, our aim is to present a branching al-
gorithm to compute amaximum bounded-degree-1
subset of an undirected graph.
When the algorithm puts a vertex v into the so-
lution set, we say that it selects v. When the algo-
rithm decides that a vertex v is not in the solution
set, we say that it discards v. Before explaining the
algorithm in detail, we describe the main rules that
the algorithm will apply. Some proofs are omitted
due to the space limit. For simplicity, we denote the
size of a maximum bounded-degree-d subset of an
undirected graph G by βd(G). We give the follow-
ing simple observations.
Lemma 1 (Disconnected Rule). If G is disconnected
and C is a component of G, then β1(G) = β1(G[C]) +
β1(G \ C).
Lemma 2 (Maximum-Degree-TwoRule). If the max-
imum degree of G is at most two, then the MAX-1-BDS
problem can be solved in polynomial time.
Lemma 3 (Isolated-Vertex Rule). Let v be an isolated
vertex of G. Then there is a solution of the MAX-1-
BDS problem that v is selected fromG. That is β1(G) =
1 + β1(G \ {v}).
Lemma 4 (Isolated-Edge Rule). Let (u, v) be an iso-
lated edge of G. Then there is a solution of the MAX-1-
BDS problem that u and v are selected from G. That is
β1(G) = 2 + β1(G \ {u, v}).
Lemma 5 (Degree-One Edge Rule). Let G = (V,E)
be a graph and (u, v) be a degree-one edge of G. Then
β1(G) = 2 + β1(G \ (N(u) ∪N(v))).
Lemma 6 (Degree-One Vertex Rule 1). Let G =
(V,E) be a graph and v be a vertex of G having at least
two degree-one neighbors. Then β1(G) = |X |+ β1(G \
(X∪{v}))whereX is the set of all degree-one neighbors
of v.
Lemma 7 (Degree-One Vertex Rule 2). Let G =
(V,E) be a graph and v be a vertex ofG having a degree-
one neighbor w. Then
β1(G) = max
{
1 + β1(G \ {v, w}),
2 + β1(G \N [v]).
Lemma 8 (True Twin Rule). Let G = (V,E) be a
graph and v and w be a pair of true twins in G. Then
β1(G) = max
{
β1(G \ {v, w}),
2 + β1(G \N [v]).
Lemma 9 (Domination Rule). Let v be a vertex of G
and u be a neighbor of v with N [u] ⊂ N [v]. Then there
is a solution of the MAX-1-BDS problem that either v is
discarded or both v and u are selected from G. That is
β1(G) = max
{
β1(G \ v),
2 + β1(G \N [v]).
Proof. Suppose v is selected and all neighbors of v
are discarded in some solution. Assume that V \X
is a solution of MAX-1-BDS problem where X is
the set of vertices discarded from G. Let X ′ =
X \{u}. We can verify thatG[V \X ′] is BOUNDED-
DEGREE-1. Hence V \ X ′ is also a solution. Sup-
pose v is selected and all neighbors of v other than
w, u 6= w, are discarded in some solution. Let Y be
the set of vertices discarded from G in this solution
and Y ′ = (Y \ {w}) ∪ {u}. We also can verify that
G[V \ Y ′] is BOUNDED-DEGREE-1. Thus if there
is some solution that selects v from G, there is a so-
lution that discards neither v nor u. 2
Lemma 10 (Difference Rule). Let v be a vertex of G
and w be a neighbor of v such that |N [w] \ N [v]| = 1.
Then there is a solution of MAX-1-BDS problem that
either v is discarded or v and one of its neighbors are
selected from G. That is
β1(G) = max
{
β1(G \ v),
maxU∈U(2 + β1(G \N [U ])
where U = {{u, v} | u ∈ N(v)}.
Proof. Suppose v is selected and all neighbors of v
are discarded in some solution and let V \X be the
solution andX be the set of vertices discarded from
G, G \ X is BOUNDED-DEGREE-1. By definition,
for all u ∈ N(v) u ∈ X . Let z be the only vertex in
N [w] \N [v]. If z /∈ X , then we obtain a solution by
deleting the set of vertices in (X \ {w}) ∪ {z} from
G. If z ∈ X , then we obtain a solution by deleting
vertices in X \ {w}. Hence there is a solution that
either v is discarded or v and one of its neighbors
are selected from G. 2
205
© ICSEC 2011, September 2011, Bangkok, Thailand.
(b) the degree of x is at least three. If we dis-
card v then w becomes a degree-one ver-
tex and hence there is an optimal solution
that either selects w and discards x or se-
lects {w, x} and discards N(x) \ {w}. On
the other hand, if v is selected, then there
is an optimal solution that also selects one
neighbor of v. Let U = {{v, u} | u ∈
N(v)}. Hence
β1(G) = max
 1 + β1(G \N [w]),2 + β1(G \N [{x,w}]),
2 + maxU∈U β1(G \N [U ]).
The worst case happens when degree
of v is three. The branching vector is
(3, 5, 5, 5, 5) and its branching number is
1.4336.
In the following the minimum degree of G is
at least three.
10. Disconnected Rule. IfG is disconnected (let C
be a component of G)
return β1(G[C]) + β1(G \ C).
11. Difference Rule. There is a maximum-degree
vertex v of G, a neighbor w of v, and |N [w] \
N [v]| = 1. Since Domination rule is not appli-
cable, |N [u] \ N [v]| ≥ 1 for any u ∈ N(v). In
the case that v is selected, there is an optimal
solution that also contains a neighbor of v. Let
U = {{v, u} | u ∈ N(v)}. Then
β1(G) = max
{
β1(G \ {v}),
maxU∈U(2 + β1(G \N [U ]).
The worst case happens when the degree of
v is three. Graph G is 3-regular if the degree
of v is three. The case that the instance as-
signed to a node of the search tree is a 3-regular
graph happens at most once from the root to a
leaf, since every instance generated by the al-
gorithm is an induced subgraph of the origi-
nal input graph. Therefore the worst case time
complexity happens when the degree of v is
four. The branching vector is (1, 6, 6, 6, 6) and
its branching number is 1.5099.
12. Standard Branching Rule. Let v be a vertex of
maximum degree. Since Difference Rule is not
applicable, |N [u] \N [v]| ≥ 2 for any u ∈ N(v).
In this case we apply standard branching rule.
Let U = {{v}} ∪ {{v, u} | u ∈ N(v)}. Then
β1(G) = max
{
β1(G \ {v}),
maxU∈U(|U |+ β1(G \N [U ]).
The worst case happens when the degree of
v is three. Graph G is 3-regular if the degree
of v is three. The case that the instance as-
signed to a node of the search tree is a 3-regular
graph happens at most once from the root to a
leaf, since every instance generated by the al-
gorithm is an induced subgraph of the origi-
nal input graph. Therefore the worst case time
complexity happens when the degree of v is
four. The branching vector is (1, 5, 7, 7, 7, 7)
and its branching number is 1.5171.
The above branching algorithm consists of re-
duction rules and branching rules. We list them in
the following.
• Reduction rules: Maximum Degree Two
Rule, Isolated-Vertex Rule, Isolated-Edge Rule,
Degree-One Edge Rule, Degree-One Vertex
Rule 1, and Disconnected Rule.
• Branching rules: Degree-One Vertex Rule 2,
True-Twin Rule, Domination Rule, Degree-
Two Vertex Rule, Difference Rule, and Stan-
dard Branching Rule
Theorem 2. The MAX-1-BDS problem can be solved
in O∗(1.5171n) time.
Remark 2. The above theorem implies that the MIN-1-
BDD problem also can be solved in O∗(1.5171n) time.
4. A fixed-parameter algorithm for 1-
BDD
The branching algorithm for solving the MAX-1-
BDS problem in Section 3 can be modified to be a
fixed-parameter algorithm for solving the 1-BDD
problem. Note that the fixed-parameter algorithm
has an extra parameter p as a part of input where
p is the number of vertices to be removed for ob-
taining a BOUNDED-DEGREE-1 subset. We may
add two boundary conditions at the beginning of
the algorithm: (1) if the number of vertices being
discarded from G is more than p, return ”No”; (2)
if the input instance is BOUNDED-DEGREE-1, re-
turn ”Yes.”
Notice that the branching algorithm does not cre-
ate a new node in the search tree when applying re-
duction rules. Let T (p) be the running time of the
fixed parameter algorithm. Each branching vector
(t1, t2, . . . , tr) is obtained after applying a branch-
ing rule and it represents a collection of instances
with input parameters p − t1, p − t2, . . . , p − tr re-
spectively. Thus we have the following linear re-
currence
207
© ICSEC 2011, September 2011, Bangkok, Thailand.

98年度專題研究計畫研究成果彙整表 
計畫主持人：張貿翔 計畫編號：98-2221-E-241-018-MY3 
計畫名稱：具效率與隱私保護的社會網路分析演算法--社群偵測之固定參數暨正確解演算法設計 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 3 3 62% 
篇 
本研究成果獲得
第 28 屆組合數學
與計算理論研討
會最佳論文獎及
2011 年全國計算
機會議最佳論文
獎 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 1 1 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
■達成目標 
□未達成目標（請說明，以 100字為限） 
□實驗失敗 
□因故實驗中斷 
□其他原因 
說明： 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：□已發表 □未發表之文稿 ■撰寫中 □無 
專利：□已獲得 □申請中 ■無 
技轉：□已技轉 □洽談中 ■無 
其他：（以 100字為限） 
本計畫執行期間共發表四篇國內外研討會論文,關於找最大 k-club 的相關成果已經發表
在第28屆組合數學與計算理論研討會,在解決2-plex問題上,我們發表了兩篇研討會論文,一
篇發表在國際研討會ICSEC 2011,另一篇發表在第29屆組合數學與計算理論研討會,解決最密
集 k-集合問題的研究結果已發表在 NCS 2011。 
3. 請依學術成就、技術創新、社會影響等方面，評估研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）（以
500字為限） 
在這三年的研究中,我們針對 k-club 設計了一個新啟發式演算法 IDROP,相較於前人所設
計出的DROP演算法,大部分實驗的結果顯示我們的IDROP可以找到比較大的k-club,因此,
我們將 IDROP 所找到的解應用在 Branch-and-Bound 演算法上,將起始的 Lower Bound 提高
許多,加上我們所找到的新 Upper Bound 後,改善了前人 Branch-and-Bound 演算法的瓶頸。
在最大 2-plex 問題上 ,我們結合前人的研究成果 ,同樣也設計出一系列的
Branch-and-Bound 演算法和一個 Branch-and-Reduce 演算法。在最小 k-club 點覆蓋問題
和最小$k$-plex 點覆蓋問題上,我們都設計出啟發式演算法和正確解演算法,但是正確演
算法所需要的記憶體空間隨著圖上的點數呈指數性成長,當圖的點數很多時,我們的程式
就沒有足夠的空間執行。我們針對最密集 k 集合問題設計出時間複雜度為
$O^{\ast}(1.7315^n)$的正確解演算法,所需要的記憶體空間隨著圖上的點數呈指數性成
長。 
 
在本計畫執行期間在國內外研討會發表之研究成果: 
Maw-Shang Chang, Ling-Ju Hung, Chih-Ren Lin, Ping-Chen Su,Finding large k-clubs 
in undirected graphs,Proceedings of the 28th Workshop on Combinatorial Mathematics 
