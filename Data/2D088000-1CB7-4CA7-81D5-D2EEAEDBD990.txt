 2 
數相加，回傳前 K 筆分數最高的答案。 
 
三、文獻探討 
目前有相當多的研究討論如何處理 XML 查詢句中的結構限制。針對路徑表示法中
祖孫關係的限制，有的研究者將每個 XML的節點以 preorder 及 postorder 編碼，以快速
地決定任意兩個節點是否有祖孫或父子的關係[2]。研究[5]進一步利用 XR-Tree 作為
Index，以跳過一些不需要作處理的節點。但當 Query 中有多個祖孫限制，如 a//b//c
時，研究[7] 討論如何選擇運算的先後順序以達到最好的效率。 
由於 XML 資料具有文件的特性，所以合併 IR 的技術也被討論。在計畫 [6]中，
XML 結構的部分利用 preorder 和 postorder 對元素進行編碼，並將該編碼存放於
inverted list 中。該論文並修改基本的 top-K algorithm，使其能處理 XML文件結構上的
關係，以對 XML 文件進行 TOP K 的處理。 
 
四、研究方法 
我們先介紹 XML 文件和 XQuery 的基本語法，並說明本計畫所欲解決之問題。圖
1 的範例是符合 IMDB 定義的 XML 資料 [4]，該文件表示了兩部電影 (Show) 的資料，
而每個 Show 元素又包含了 Title 、Year 和 Review 等等子元素。 
為了可以從 XML Tree 中取出符合特定結構的元素，W3C 定義了路徑表示法。其中，
符號 “/”是用來表示前後兩個元素間必須具有父子關係，而符號 “//”則是用來表示
祖孫關係的限制。舉例來說，路徑表示法“/IMDB/Show”， 是指定根元素 IMDB 下的
子元素 Show ，在圖 1 中會有兩個元素被回傳。而另一方面，路徑表示法 
“/IMDB//Year”，則是只要是 IMDB 之下任何的子孫節點稱做 Year 的都可回傳，在圖
1 中也是會有兩個元素被回傳。 
一個 XQuery 的敘述式通常包含以下部分： For 子句讓變數可以遞迴取得一個運算
式的結果， Where 字句允許對變數做條件的限制，而 Return 子句則可以建構新的 XML
元素做為查詢的輸出。以圖 2 的 XQuery 範例做說明，該查詢句首先將符合路徑 
“/IMDB/Show” 的每個 Show 元素指定給變數 p，接著在 Where 敘述句中要求 p 下面的 
“/Title” 的內容必須包含關鍵字 “X File”，最後在 Return 敘述句中指定了所要回傳的元
素為 Year。在此範例中，“Show”、“Title”和“Year”必須符合路徑表示法所要求的特定的
結構限制，而 “contains” 函數則表達了元素包含關鍵字的限制。以下我們將介紹本篇計
畫所提出的資料結構與資料表示法，如何能有效率地處理結構限制和關鍵字限制。 
 
       
圖 1 XML Tree 之範例 
 
 4 
Path ID XML 文件中可能之路徑 P-Label < P1,P2> 
784 /IMDB <784,1594> 
2379 /IMDB/Show <2379,3218> 
3250 /IMDB/Show/Title <3250,3976> 
7252 /IMDB/Show/Year <7252,8121> 
9127 /IMDB/Show/Reviews <9127,10020> 
19437 /IMDB/Show/Box_office <19437,20306> 
29185 /IMDB/Show/Episode <29185,30054> 
31622 /IMDB/Show/Seasons <31622,32491> 
圖 4 元素路徑編碼表之範例 
 
 我們採用 P-Labeling 之作法 [3]，為 XML 文件中所有可能的後置路徑編碼。P-
Label 的表示法為 <p1, p2>，且 p1 與 p2 符合下列兩個特性：(1) p1 需小於等於 p2。(2)
給定 P、Q 兩點，若 Q.p1 ≦ P.p1 且 Q.p2 ≧ P.p2，則後置路徑 P 被 Q 所包含；若 P.p1 > 
Q.p2 或 P.p2 < Q.p1，則 P 和 Q 沒有交集。舉例來說，在圖 1 的 XML Tree 中，路徑
“//Year”的 P-Label 為 <7195 , 8818>，而路徑 “/IMDB/Show/Year”的 P-Label 為 
<7252, 8121>，被<7195, 8818>所包含，所以對應到 “/IMDB/Show/Year”的元素，也
會符合路徑“//Year”。 
 另外，由於每個路徑的 p1 會唯一，所以我們也利用該編碼做為路徑的代碼，稱
做 Path ID。我們將每個路徑的 P-label 和 Path ID 事先建立好，表示成元素路徑編碼
表。對應圖 1 的 XML Tree 的元素路徑編碼表，如圖 4 所示。 
 
 
元素編碼表 
 為了迅速地處理元素和元素之間結構上之關係，我們替元素加以編碼，包含起
始編碼 (Start)、結尾編碼 (End) 和深度編碼 (Level)。其中，起始編碼為元素的開始標籤
在 XML 文件中出現的順序，而結尾編碼則為元素的結束標籤在 XML 文件中出現的順
序。這兩個編碼，正好分別對應到該元素在 XML Tree 中的 preorder 順序和 postorder 順
序。而深度編碼則代表該元素在樹中位於第幾層。如圖 1 中，兩個 Show 元素的編碼，
分別是 (2, 17, 2) 和 (18, 29, 2)。 
 我們將對應到相同 Path ID 之元素集合，分別表示成一個個的表格，稱做結構表
格 (Structure Table)，如圖 5 (a) 為對應到圖 1 中，/IMDB/Show/Title 的 Structure Table。
但是，此表格並沒有辦法快速地處理關鍵字。所以我們另外設計了文數值表格 (Value 
Table)，記錄每一個元素所包含的關鍵字，與該關鍵字利用 BM25 Scoring Model[6]計算
出來的分數。在圖 5 (b)中，顯示兩個 Title 元素，所包含的每個關鍵字，個別的分數。
我們將 Structure table 和 Value table 合稱為元素編碼表，並將表中的每一筆資料稱做元
素編碼列。 
 
 
Start End Level 
3 4 3 
19 20 3 
(a) Structure Table 
 
 
 
Start End Keyword Score 
3 4 Fugitive 2.107 
19 20 X 1.603 
19 20 File 1.603 
 (b) Value Table 
 
圖 5 /IMDB/Show/Title 的元素編碼表 
 6 
 
 
B
+
 T
re
e
 
圖 8 索引架構之範例 
 
事先建立好 B+-Tree，以結構表格中元素的起始編碼做為索引，指到該元素在對應的文
數值表格中的位址，再由傳回的位址依序讀取該元素相關的關鍵字資料。此索引結構
如圖 8 所示。在圖 8 中，結構表格的第一筆元素編碼列的起始編碼為 3，透過 B+-Tree 
找出在對應的文數值表格中，記錄同一個元素相關資料之位址，也就是第一筆，再依
序讀取其關鍵字的資料，判斷是否此元素記錄了使用者所要求包含的關鍵字。如果此
元素編碼列符合使用者下達的結構上的關係以及關鍵字限制，則取出對應的分數，並
將該元素編碼列回傳。 
  
五、結果與討論 
我們進行數個實驗來評估我們資訊檢索系統的效能，並且和 MinProbe 系統[6]進行
效能之比較。MinProbe 之方法為，由有文數值限制之節點開始處理，且符合文數值限
制之元素將根據該元素的分數進行排序，接著再由這些元素跟 GN 節點的資料進行比
對，在比對的過程會給於符合結構的答案一個分數，並做 TopK 的處理。注意的是，該
方法並不需要找出符合所有文數值限制或是結構限制之答案，若是只有符合部分結構
和部分文數值限制之答案也可取出，再根據其分數進行 TopK之處理。 
我們採用的實驗環境，是 CPU 為 Pentium 4 3.0 GHz 的個人電腦，其記憶體為
512MB，作業系統為 Windows 2000 Advanced Server。採用 DBLP 之 Data Set 作為測試
資料，其大小為 30MB， 
 
回傳節點數量之影響 
在此實驗中主要控制查詢句中回傳節點之數量，以圖 9 的查詢句為主，並逐一擴
展其回傳節點的數量。圖 10 (a) 為該實驗之執行時間。我們可以觀察到，回傳節點數
量越多，查詢樹中所切割出來之後置路徑數量越多，相對的資訊擷取的時間也較長。
與 MinProbe 系統相比，由於我們系統的存取元素之次數比較少（參見圖 10 (b)），所
以我們的整體執行時間較少，效率比 MinProbe 更高。 
 
 
For $p in document (“http:://dblab.cs.ntou.edu.tw/dblp.xml”) /dblp/article 
Where some $t in $p/Year satisfies (contains ($t/text() , ‘1998’ ) 
Return $p/Title                                    
圖 9 實驗一之測試查詢句 
 
