1 
 
 
一、 中英文摘要 
摘要 
無線感測網路是目前正蓬勃發展的一項新興技術。藉由提供無所不在的感應能力、計
算能力以及通訊能力，無線感測網路大大便利了人類的生活。此類的環境可能包含許多價
廉的無線節點，其中每個節點都能夠提供收集、處理及儲存環境資訊的能力，並能與相鄰
的節點溝通。透過這種新興的技術，不管我們到什麼地方，都能夠更密切地與環境進行互
動。然而，在一個與外界隔絕而被孤立的無線感測網路環境中，資料被聚集到匯聚節點之
後仍無法傳遞到其他地方。 
本計劃提出一新的階層式無線感測網路架構來解決上述的問題，我們建議在現有的無
線感測網路架構中，再加入一個行動收集器(mobile mule)。行動收集器會固定地(如：預
先決定好行走路徑的公車)或偶爾地(如：無先決定行走路徑的計程車)去訪問被孤立的無
線感測網路中的匯聚節點，並且假設節點必須暫時存放收集到的資料直到行動收集器訪問
匯聚節點為止，並讓匯聚節點將收集到的資料傳送給行動收集器，使行動收集器能把資料
帶到外界。 
由於無線感測網路的一些天生限制，例如節點的記憶體存放空間是有限的等等，我們
定義了三個問題：(1) 在節點的記憶體存放空間有限的情況下，如何在盡可能減少資料流
失的情況下暫存感測到的資料，(2) 假如無法避免資料丟失，如何避免具有高度優先權的
資料被丟失，(3) 如何保持具有高度優先權的資料能較靠近匯聚節點，使得行動收集器靠
近孤立網路，但收集資料的時間有限時，能優先收集到較重要的資料。另外，我們認為，
如何決定要將網路中的哪個節點當成匯聚節點也是一項非常重要的研究議題。因為，匯聚
節點的位置將會關係到各節點間的電量消耗差異是否平衡，更進一步地會影響到整個網路
的存活時間。因此，我們針對這個部份定義了以下問題：如何決定匯聚節點的位置，以讓
整個網路的負載平衡。 
在這一新的網路架構之下，現有為原本感測網路所設計的方法及協定，並不能完全適
用，本計畫將以此一階層式無線感測網路為基礎，進一步研究相關的資料存放問題及通訊
協定，主要包含兩個方向：1. 階層式感測網路資料存放問題之研究 2. 階層式感測網路
平台協定設計與實作。 
本計畫提出一同時兼顧聯結性、資料完整度、高優先權資料優先保留等要求的資料存
放與交換策略，並以電腦模擬和理論分析兩種方式，來驗証所提出演算法的可行性及效能。
除此之外，我們也將設計與實作此一階層式感測網路平台，完成硬體平台的建構，設計及
修改相關的通訊協定，並研究這個平台的相關議題。 
 
關鍵字：無線感測網路、行動收集器、負載平衡、通訊協定 
3 
 
目錄 
一、 中英文摘要 
二、 報告內容 ................................................................................................. 1 
2-1前言 .................................................................................................... 1 
2-2研究目的 ............................................................................................. 3 
2-3研究方法 ............................................................................................. 4 
2-4結果與討論 ........................................................................................12 
2-5參考文獻 ............................................................................................15 
三、 計畫成果自評 ..........................................................................................16 
附錄一計畫執行期間論文發表 
  
2 
 
 
相較於傳統有線感測器，無線感測網路有下列優點： 
I. 大幅降低建置成本：傳統在佈置感測器網路時，約有 50%~90%的成本是耗費在佈線的
成本上，因此當使用無線隨意網路作為感測器溝通的方式後，就可以大幅度降低整體
的成本。 
II. 增加感測器擺放位置的彈性：由於擺脫了有線的束縛，因此感測器的擺放位置可以根
據需求以及環境的限制，調整擺放在不同的位置，這個特性讓無線感測網路的所能應
用的場景更加廣泛。傳統上，由於感測器所要佈建的環境可能會遭遇到許多的障礙物
(例如道路、湖泊、樓層、牆面等)，在這樣子的環境中，佈置感測器往往耗時費力。現
在，由於無線感測器是以無線方式通訊，我們只需要適當地點安置感測器，透過感測
器的自我組態能力，即可以形成一個可聯通的無線感測網路了 
III. 感測器位置具有可調性：在感測網路建置完成之後，因為應用需求或環境等因素的變
動，而需要改變感測器的位置時，我們可以很容易地動態調整感測器的位置，無線感
測器之間可以很快地重新組態，整個網路即可符合新的需求/限制。在傳統的有線感測
器的環境中，由於固定式佈線及架構的限制，任何的變更都是耗力費時的工作。 
事實上，透過無線感測網路這種新興的技術，可以讓人們與其週遭環境之間的互動更
加緊密。舉例來說，我們如在森林中設置火災偵測器(即可以偵測溫度及煙霧的感測器)，
當林間溫度升高時，感測器便可感測到溫度變化並發出警告，人們即可採取行動，避免區
域性的小火災釀成嚴重的森林大火，以保障民眾的生命財產安全。除此之外，在一般的辦
公大樓內，我們可以利用感測器將感測到的溫溼度及人數等資料處理後，傳回中央空調控
制器做調整，藉此同時達到環境舒適及節能省電的目的；若將感測器安裝在交通工具上或
4 
 
(2) 假如無法避免資料丟失，如何避免具有高度優先權的資料被丟失，(3) 如何保持具有高度
優先權的資料能較靠近匯聚節點，使得行動收集器靠近孤立網路，但收集資料的時間有限時，
能優先收集到較重要的資料。另外，我們認為，如何決定要將網路中的哪個節點當成匯聚節點
也是一項非常重要的研究議題。因為，匯聚節點的位置將會關係到各節點間的電量消耗差異是
否平衡，更進一步地會影響到整個網路的存活時間。因此，我們針對這個部份定義了以下問題：
(1)如何決定匯聚節點的位置，以讓整個網路的負載平衡。在下一章，我們將這兩項議題分開
討論。 
 
2-3 研究方法 
 本計畫之研究方法主要分為以下三個方向：A.階層式感測網路節點資料存放問題之研究 
B.匯聚節點位置之研究 C.階層式感測網路平台協定設計與實作 
 
A. 階層式感測網路節點資料存放問題之研究 
我們定義一個特殊的WSN，其包含一些靜止的節點以及行動收集器。靜止節點可以不斷
地感測周遭環境並週期性地產生回報封包，每個節點都有同樣的儲存空間Ssn(單位是封包)及傳
輸範圍Rsn。這些靜止節點結合成一個連通性的WSN，並且這些WSN都支援多點跳躍繞徑
(Multi-hop routing)。但是，這些WSN都被佈置在偏遠的區域並且與外界隔絕，他們必須依靠
行動收集器經過拜訪他們並且把他們感測到的資料帶到外界。行動收集器會停在一個特定的節
點上一段時間來收集感測到的資料，這個特定節點我們叫做匯聚節點(sink)。在這段時間內，
匯聚節點可以把自己跟其他節點的封包傳送給行動收集器。行動收集器停下的這段時間長度可
能是固定或是隨機的。行動收集器的移動方式可能是固定的(如：預先決定好行走路徑的公車)
或隨機的(如：無先決定行走路徑的計程車)。行動收集器之後可以將收集到的封包轉送給在外
界的中央收集器。圖三是一個我們的網路模型及資料收集策略的範例。 
 
6 
 
          min {𝐹(𝑃(𝜔))|𝜔 ∈ 𝑁(𝑢),𝐷(𝜔) < 𝐷(𝑢)}。 
 
 P1(反過來說，P2)代表比 u遠離(反過來說，靠近)匯聚節點的節點應該擁有比 u還低的優
先權(反過來說，比 u還高的優先權)。P3則強制讓到匯聚節點的距離與 u相同的節點應該擁有
與u相同的優先權。當一個節點同時擁有以上三樣特性，我們稱這個節點為排序完成(in-order)。
在圖四中，除了節點 m及 j以外，其他節點皆已排序完成。
 
 對於每個節點 u，我們定義 maxPost(u)表示在 u的鄰居中，滿足𝐷(𝜈) > 𝐷(𝑢)的節點𝜈中，
具有最高優先權的封包；𝑚𝑖𝑛𝑃𝑟𝑒(𝑢)表示在 u的鄰居中，滿足𝐷(𝜈) < 𝐷(𝑢)的節點𝜈中，具有最
低優先權的封包；maxEqual(u)表示在 u的鄰居中，滿足𝐷(𝜈) = 𝐷(𝑢)的節點𝜈中，具有最高優
先權的封包；以及𝑚𝑖𝑛𝐸𝑞𝑢𝑎𝑙(𝑢)表示在𝑢的鄰居中，滿足𝐷(𝜈) = 𝐷(𝑢)的節點𝜈中，具有最低優
先權的封包。根據以上的特性，我們設計我們用於節點𝑢 ∈ 𝐵𝐴的封包交換規則如下： 
E1：當𝐹�𝑚𝑎𝑥𝑃𝑜𝑠𝑡(𝑢)� > 𝐹(𝑃(𝑢))時，節點 u會嘗試與𝑚𝑎𝑥𝑃𝑜𝑠𝑡(𝑢)交換其所儲存的封包。 
E2：當𝐹(𝑃(𝑢)) > 𝐹�𝑚𝑖𝑛𝑃𝑟𝑒(𝑢)�時，節點 u會嘗試與𝑚𝑖𝑛𝑃𝑟𝑒(𝑢)交換其所儲存的封包。 
8 
 
狀態。但是毫無疑問的，對一個封包來說，每當比它高優先權的封包變成穩定狀態時，它將會
變成穩定狀態。當 BA的大小是有限時，封包交換的動作將會在有限步驟內結束。 
 
定理二. 當所有在 BA內的節點結束封包交換後，它們會是排序完成的狀態。 
證明：我們利用反證法來證明這個定理。假如節點𝑢不在穩定狀態，那麼其只會有以下三
種可能的情況： 
情況一：節點𝑢違反P1。也就是說存在一個鄰居𝜈 ∈ 𝑁(𝑢)，且𝐷(𝜈) > 𝐷(𝑢)，𝐹�𝑃(𝜈)� > 𝐹�𝑃(𝑢)�。
因為𝐹�𝑚𝑎𝑥𝑃𝑜𝑠𝑡(𝑢)� ≥ 𝐹�𝑃(𝜈)� > 𝐹(P(𝑢)）。根據 E1，它將不會停止交換封包。 
情況二：節點𝑢違反 P2但遵守 P1。也就是說存在一個鄰居𝜈 ∈ 𝑁(𝑢)，且𝐷(𝜈) < 𝐷(𝑢)，
𝐹�𝑃(𝜈)� < 𝐹�𝑃(𝑢)�。因為𝐹�𝑚𝑖𝑛𝑃𝑟𝑒(𝑢)� ≤ 𝐹�𝑃(𝜈)� < 𝐹(P(𝑢)）。根據 E2，它將不會停止交
換封包。 
情況三：節點𝑢違反 P3但遵守 P1跟 P2。也就是說存在一個鄰居𝜈 ∈ 𝑁(𝑢)，且𝐷(𝜈) = 𝐷(𝑢)，
𝐹�𝑃(𝜈)�不在 𝐹�𝑚𝑎𝑥𝑃𝑜𝑠𝑡(𝑢)�跟𝐹�𝑚𝑖𝑛𝑃𝑟𝑒(𝑢)�之間。因為節點𝑢遵守 P1跟 P2，所以我們可以
得到𝐹�𝑚𝑖𝑛𝑃𝑟𝑒(𝑢)� ≥ 𝐹�𝑚𝑎𝑥𝑃𝑜𝑠𝑡(𝑢)�。𝐹�𝑃(𝜈)�會比𝐹�𝑚𝑖𝑛𝑃𝑟𝑒(𝑢)�大或是比𝐹�𝑚𝑎𝑥𝑃𝑜𝑠𝑡(𝑢)�
小。 
(1) 𝐹�𝑃(𝜈)� > 𝐹�𝑚𝑖𝑛𝑃𝑟𝑒(𝑢)�。 
因為𝐹�𝑚𝑎𝑥𝐸𝑞𝑢𝑎𝑙(𝑢)� ≥ 𝐹�𝑃(𝜈)� > 𝐹�𝑚𝑖𝑛𝑃𝑟𝑒(𝑢)�。根據 E3.1，它將不會停止交換封
包。 
(2) 𝐹�𝑃(𝜈)� < 𝐹�𝑚𝑎𝑥𝑃𝑜𝑠𝑡(𝑢)�。 
因為𝐹�𝑚𝑖𝑛𝐸𝑞𝑢𝑎𝑙(𝑢)� ≤ 𝐹�𝑃(𝜈)� <  𝐹�𝑚𝑎𝑥𝑃𝑜𝑠𝑡(𝑢)�。根據 E3.2，它將不會停止交換
封包。 
情況一、二以及三皆牴觸我們節點會結束封包交換動作的假設，所以定理得證。 
 
總結來說，由於我們的資料交換策略利用較有力的網狀(mesh)連結來交換封包，所以根據
E3.1跟 E3.2，具有較高優先權的封包會有更多的機會可以被儲存於較靠近匯聚節點的位置。 
 另外，以下我們討論兩個能擴展的議題。 
 首先，將我們的策略擴展到𝑆𝑠𝑛 > 1的情況。我們定義𝑚𝑎𝑥𝑀𝑖𝑛𝑒(𝑢) (反過來說，
𝑚in𝑀𝑖𝑛𝑒(𝑢) )代表能儲存多個封包的節點𝑢中擁有最高(反過來說，最低)優先權的封包。當一
個節點擁有多個封包時，封包交換的規則應修改成以下的樣子： 
E1’：當𝐹�𝑚𝑎𝑥𝑃𝑜𝑠𝑡(𝑢)� > 𝐹�𝑚𝑖𝑛𝑀𝑖𝑛𝑒(𝑢)�，節點𝑢會嘗試將封包𝑚𝑎𝑥𝑃𝑜𝑠𝑡(𝑢)與𝑚𝑖𝑛𝑀𝑖𝑛𝑒(𝑢)交
換。 
E2’： 當𝐹�𝑚𝑎𝑥𝑀𝑖𝑛𝑒(𝑢)� > 𝐹�𝑚𝑖𝑛𝑃𝑟𝑒(𝑢)�，節點𝑢會嘗試將封包𝑚𝑎𝑥𝑀𝑖𝑛𝑒(𝑢)與𝑚𝑖𝑛𝑃𝑟𝑒(𝑢)交
10 
 
根據現有的資訊，就可以做精確的評估了。 
這個動作持續越多次會讓子樹間越接近負載平衡，但是，做越多次之後效果越不明顯。我們做
了實驗發現，大約重複 10次之後轉移對網路產生的影響會非常小，因此，我們認為重複 10
次是比較好的。 
透過上述轉移策略，將可達到匯聚節點各子樹之間的負載平衡。如此一來，匯聚節點將會
一步一步地轉移其位置，我們可以想像，在網路之中，匯聚節點會往網路中節點最密集的地方
轉移，接著，在接下來的每個回合都會往對目前位置來說節點最密集的地方轉移，最後將轉移
到整個網路的中心並達到一個平衡的狀態。 
 
C.階層式感測網路平台協定設計與實作 
 接下來，本計畫也實作了階層式感測網路平台及其相關協定。主要達成的工作項目有
下列兩項：(1) 硬體平台建構 (2)網路通訊協定設計修改 
 硬體平台建構 
在硬體平台的部分，主要可分為無線感測器、行動收集器、中央收集等三個部分，以下分別討
論之。 
 
 
圖五、Jennic JN5139為基礎的無線感測器平台  
 無線感測器的部分，其無線傳輸模組將我們使用 Jennic JN5139 晶片模組(如圖五
所示)，其為一符合 IEEE 802.15.4 規範之傳輸模組，選擇 Jennic的原因，主要是
因為其對 ZigBee/IEEE 802.15.4標準的支援性，以及其相關開發支援較為豐富，層
底之無線傳輸模組收到資料後，上層均以 Java語言來實作，而我們採用其提供之
802.15.4 Stack API 來做為開發無線傳輸之工具，修改/設計相關的通訊協定。 
 行動收集器的硬體平台，我們利用現存的小型可移動式裝置作為行動載具，上面
載有 Jennic 裝置作為系統運算控制中心，來建構移動式感測器。在行動載具硬體
的選用上，載具的部份我們選用市售的軌道模型火車，如圖六所示，這是一套由
12 
 
個網路拓樸，用來達成多節點跳躍式傳輸(multi-hop transmission)，將資料傳送到匯聚
節點。下層的每一個感測器都知道其鄰居，形成一個網狀(mesh)的結構。在網路一啟
動時，每一個下層網路的感測器會去偵測其到匯聚節點的距離，此過程可以由節點廣
播Beacon封包時，增加記錄距離的欄位來達成；當網路初始時，匯聚節點會擔任 Zigbee
協調者的角色，節點會各自選擇合適的頻道，並開始以短距的天線廣播 Beacon 封包
給鄰近的感測器，Beacon封包中包含此匯聚節點的 ID，目的是用來分辨不同的網路，
此外，還有一欄位記錄和匯聚節點之間的節點距離，一開始設為零；當節點接收到
Beacon 封包時加入此網路，並開始廣播 Beacon 封包，其中 ID 欄位不變，記錄距離
的欄位會加一；若一個感測器收到不同網路 ID的 Beacon，經比較距離欄位之後，就
可以選擇合適的行動收集器的網路加入。 
 上層收集器網路 
在上層收集器網路中包含行動收集器及中央收集器，由於行動收集器會經過中央
收集器附近並直接將資料轉送給中央收集器，我們讓上層網路直接套用 Zigbee協定架
構。中央收集器作為 Zigbee 協調者(Coordinator)而行動收集器作為末端設備(End 
device)，用來達成單節點直接傳輸(1-hop transmission)，將資料傳送到中央收集器。 
 
2-4 結果與討論 
 以下我們分成三個部份來呈現我們的成果 A.階層式感測網路節點存放資料交換策略之模
擬成果 B.階層式感測網路平台協定實作 C.總結 
A. 階層式感測網路節點存放資料交換策略之模擬成果 
我們模擬的環境為 400 個感測節點隨機布建在200 × 200的區域內，每個節點的傳書
範圍是 25，各個節點的封包到達率(packet arrive rate)為1 ∕ 50。並且每個封包隨機給定一
個0 ∼ 1000之間的優先權值。BA定義為距離匯聚節點 10個節點距離(hop)內的節點集合。
每個結果都各別執行 50次並取平均值。 
首先我們在圖七(a)及圖七(b)中分別比較將行動收集器訪問 WSN 的時間間隔當變數時；
以及在中比較將行動收集器收集的時間長短當變數時，收集到的封包的平均優先權值。我
們將我們的方法(Distributed Storage Management Strategy, DSMS)與 Greedy Forwarding(GF)
以及最佳解(OPT)做比較。GF 代表節點永遠盡量讓其封包往匯聚節點靠近直到前方沒有
儲存空間為止，OPT代表達到全面最佳化後的理想情況。圖七(a)中顯示當參訪間隔增加
時，收集到的優先權值平均也會上升。其中，一個槽(slot)的時間間隔代表封包移動一個
節點距離(hop)的時間。圖七(b)中顯示當收集時間拉長時，收集到的資料優先權值平均會
降低，不過這個影響非常小。 
14 
 
 
為了方便封包交換，我們設計了一個由行動收集器產生並傳給匯聚節點的
COLLECT_DATA訊息。每當接收一段資料，行動收集器會傳送 ACK訊息給匯聚節點。
我們的實作顯示出我們的資料存放與交換策略可以很簡單地在實際平台上實作出來。 
C. 總結 
我們的計畫針對資料必須暫存在一個被外界隔離的無線感測網路的情況，提出了一個
分散式的資料存放及交換策略，能保持具有較高優先權的資料存放位置越靠近匯聚節
點，並且減少資料丟失。我們證明了我們提出的策略的特性，並且在實際的平台上實
作了我們的策略，證明其為可行的。 
 
  
16 
 
四、計畫成果自評部份 
 
本結案報告研究內容與原計畫成果相符，其成果效益描述如下： 
 
(一) 學術技術面 
本計畫在學術方面，發表了兩篇會議論文[12][13]。在技術方面，本計畫在被孤立的無線
感測網路中，加入一行動收集器形成新的階層式無線感測網路架構，並針對這個架構設計了一
套資料存放與交換策略(Distributed Storage Management Strategy, DSMS)來解決孤立無線網路
中封包丟失的問題，並且在實際平台上實作了我們提出的系統，證明這套系統是可行並且能確
實應用在實際環境中，並可供國內業者直接套用於其產品上。 
 
(二) 經濟面效益 
本計畫所提出之系統，非常適用在山上或深海等無法隨時將資料回傳到外界而被孤立的無
線感測網路環境。由於近幾年無線感測網路的應用越來越多，尤其用來偵測天災發生的應用對
人類有非常大的幫助，如在高山偵測土石流流向；在海底偵測海底油田等。但是此類系統勢必
會遇到資料無法回傳至外界的問題。因此，我們的計畫將可協助有類似產品的國內業者開發產
品，降低其研發成本。並且，參與本計畫之學生及教師已藉由實驗熟悉無線感測網路相關套件
之開發程序，並有兩名碩士生已順利完成碩士論文且取得碩士學位，可即刻投入國內之人力市
場並降低國內業界之人才培訓成本。 
 
(三) 社會面效益 
本系統之應用能使人類能更即時的偵測到天災的發生以應對，以此減少社會對於天災的不
確定性產生的不安，並以此促進社會發展。 
above mud flood example, the node that is most frequently
visited by rangers can be the sink.
There have been many works related to mules. Data collec-
tion using mules is addressed in [7][12][13]. Using mules to
connect sparse sensor networks at the cost of higher latencies
is explored in [7]. Reference [12] analyzes the upper bound
of the optimal data transfer with mules. In [13], it shows
that using mules with predictable mobility can significantly
reduce communication power in WSNs. Using mobile ferries
to conduct routing in a highly disconnected ad hoc network is
discussed in [14][15][16]. A comprehensive survey of mobile
sensor networks can be found in [17]. However, how to buffer
packets generated by an isolated WSN remains an obscure
problem. To the best of our knowledge, our work is the first
one addressing distributed prioritized storing strategies for
isolated WSNs using mobile mules.
The rest of the paper is organized as follows. Section II
presents our system model. DSMS is given in Section III.
Some extensions of DSMS are in Section IV. Section V
contains our simulation results. Our implementation results are
shown in Section VI. Section VII concludes this paper.
II. SYSTEM MODEL
We consider a heterogeneous WSN consisting of some static
sensors and mobile mules. Static sensor nodes, or simply
nodes, can continuously monitor the environment and peri-
odically generate reporting packets, or simply packets. Each
node has the same storage space of Ssn (in unit of packet) and
communication range of Rsn. Two nodes u and v can com-
municate with each other if their distance dist(u, v) ≤ Rsn.
These static sensor nodes form a connected WSN. Multi-hop
routing is supported in each WSN. However, since these WSNs
are deployed in a remote field and are isolated from the outside
world, they rely on mobile mules to visit them and carry their
sensory data out. Mobile mules will stop by a specific node,
called sink, for a period of time to collect sensory data. During
this period, the sink can relay its own and others’ packets to the
mule. The stopping period can be a fixed or a random length.
The movement of mules can be by intention (pre-arranged,
such as a bus) or by opportunity (not pre-arranged, such as a
taxi). These mules can later deliver the collected packets to an
external base station. Fig. 2 shows an example of our network
model and data collection mechanism.
Whenever a mule arrives at the sink, the sink can commu-
nicate with the mule. However, we assume that the connection
time and the available storage space of the mule are both
unpredictable. Therefore, packets generated by nodes should
be prioritized to reflect their importance. This can be done by
a pre-agreed function, by an aging process, or by importance
of readings. Higher priority means more importance. We also
assume that there is a predefined region nearby the sink called
Buffer Area (BA). The set of sensor nodes in BA are designated
to store sensing data of the WSN. Therefore, all static sensor
nodes will try to forward their data to BA. As an example,
in Fig. 2, the BA of network C contains nodes within 3 hops
from the sink. (In an extreme case, one may designated all
Priority: 19
Priority: 21
Priority: 18
Priority: 6
Priority: 8
Priority: 17
Sink
Buffer Area
Base Station
Internet
Isolated Network A
Isolated Network B
Isolated Network C
mule route
Fig. 2. System model of the DSMS system.
WSN as the BA.) We regard the storage spaces of nodes in
BA as a distributed storage system. Our goal is to design a
distributed protocol to achieve three goals.
G1 : Dropping of packets in BA should be minimized.
G2 : If dropping of packets is unavoidable, the lower-priority
ones should be dropped first.
G3 : To facilitate mobile mules to collect data, higher priority
packets should be stored closer to the sink.
Definition 1. Given a WSN modeled as a graph G = (V,E),
a sink ∈ V , a BA ⊆ V , and a priority function F for
packets, the Distributed Storage Management (DSM) problem
is to develop a packet exchange protocol to maintain packets
being generated by the WSN within BA such that G1-G3 are
met and Ω(BA) =
∑
v∈BA,p→v F (p) is maximized, where
p→ v means that a packet p is stored at the storage of v.
III. PROPERTIES AND PROTOCOLS OF DSMS
The objective function Ω(BA) reflects our goal of accumu-
lating packets of higher priorities inside BA. We propose a
Distributed Storage Management Strategy (DSMS) based on
a shuffling mechanism. DSMS is a distributed solution. Nodes
not in BA will forward their packets to nodes in BA, while
nodes in BA will observe their neighbors’ states and exchange
packets with each other as necessary. We assume that each
node u knows its distance D(u) to the sink and its neighbor
set N(u). Without loss of generality, we assume that each
node u has only one buffer space (i.e., Ssn = 1). So the (only)
packet in u is written as P (u) and its priority is F (P (u)) (if
u has no packet, F (P (u)) = −1). Our scheme can be easily
extended to Ssn > 1.
DSMS tries to maintain the following properties for each
node u ∈ BA
P1 : For each node v ∈ N(u) such that D(v) > D(u),
F (P (v)) ≤ F (P (u)).
P2 : For each node v ∈ N(u) such that D(v) < D(u),
F (P (v)) ≥ F (P (u)).
P3 : For each node v ∈ N(u) such that D(v) =
D(u), max{F (P (w))|w ∈ N(u),D(w) > D(u)} ≤
F (P (v)) ≤ min{F (P (w))|w ∈ N(u),D(w) < D(u)}.
674
F (P (v)) < F (P (u)). Since F (minPre(u)) ≤ F (P (v)) <
F (P (u)). It will not stop exchanging packets according to
E2.
Case 3 : Node u violates P3 but it follows P1 and P2.
That is there is a node v ∈ N(u) such that D(v) =
D(u) and F (P (v)) is not between F (maxPost(u)) and
F (minPre(u)). Since node u follows P1 and P2, we
can get F (minPre(u)) ≥ F (maxPost(u)). The value of
F (P (v)) is either larger than F (minPre(u)) or smaller than
F (maxPost(u)).
(1) F (P (v)) > F (minPre(u)). Since
F (maxEqual(u)) ≥ F (P (v)) > F (minPre(u)). It
will not stop exchanging packets according to E3.1.
or
(2) F (P (v)) < F (maxPost(u)). Since
F (minEqual(u)) ≤ F (P (v)) < F (maxPost(u)). It
will not stop exchanging packets according to E3.2.
Cases 1, 2 and 3 all contradict our assumption that nodes
have stopped exchanging packets, so this theorem is proved.
To summarize, because DSMS utilizes the richer mesh links
to exchange packets, higher-priority packets have chance to
stay closer to the sink by rules E3.1 and E3.1. One question
is: how many packet exchanges may be incurred when a
new packet is generated. We will investigate this issue via
simulations.
IV. SOME EXTENSIONS
We discuss two extensions below. We first extend DSMS
to Ssn > 1. We define maxMine(u) (resp., minMine(u))
to be the packet of u with the highest (resp., lowest) priority.
Since a node may have multiple packets, the exchange rules
for node u are modified as follows:
E1’ : When F (maxPost(u)) > F (minMine(u)), node u
tries to exchange its packet minMine(u) with packet
maxPost(u).
E2’ : When F (maxMine(u)) > F (minPre(u)), node u
tries to exchange its packet maxMine(u) with packet
minPre(u).
E3.1’, E3.2’ are the same as previous as E3.1 and E3.2.
The definition of “in-order” can be directly extended to
Ssn > 1. Note that nodes only need to broadcast the highest
and the lowest priorities of its packets. It is not hard to prove
that previous properties still hold when Ssn > 1.
The second extension is to add a new transmission buffer
to each node to handle packet overflow. A packet waiting
to be transmitted should be put in the transmission buffer.
When a node u ∈ BA whose storage space is full generates
a new packet, it will keep packets with higher priorities and
move the lowest-priority one to its transmission buffer. We
assume that BA is more crowded, so such packets will be
forwarded to node v, where v ∈ N(u),D(v) > D(u) and
F (minMine(v)) is minimum. However, this decision will not
affect the correctness of our protocol.
x coordinate
y 
co
or
di
na
te
819.6318
640.4303
461.2287
282.0272
102.82
57
0 50 100 150 200
0
20
40
60
80
100
120
140
160
180
200
−200
−100
0
100
200
300
400
500
600
700
800
Fig. 4. A snapshot of priority distribution.
 550
 600
 650
 700
 750
 800
 850
 900
 950
 1000
 0  50  100  150  200  250  300  350  400
A
v
e
r
a
g
e
 
p
r
io
ri
ty
Numer of collecting nodes
Communication graph
Tree structure
Fig. 5. DSMS with a mesh-like communication graph and with a tree
structure.
V. SIMULATION RESULTS
We have conducted some simulations to verify our results.
Unless otherwise indicated, the simulation environment con-
tains 400 sensor nodes randomly deployed in 200× 200 field,
each with a transmission range of 25. The packet arrival rate is
1/50 per node, and each packet has a random priority between
0 and 1000. BA is set as the set of sensor nodes within 10
hops from the sink. All results are from the average of 50
test runs. Fig. 4 shows a snapshot of priority distribution in a
network with the sink at (0, 0) after applying DSMS.
We first compare DSMS when the richer mesh links are
adopted against when a tree is adopted. The shortest path
tree rooted at the sink is adopted for comparison, where each
node only is allowed to exchange its packets with its parent or
children. In this experiment, we vary the collecting duration
when a mule visits a sink node (i.e., how long a mule collects
the data from a fixed number of nodes). The results are shown
in Fig. 5. More higher-priority packets are collected when a
mesh-like communication graph is adopted.
Fig. 6 compares the average priorities of the packets col-
676
(a)
g
c
hf
k l
db
j
a
e
i
m
n p qo
(b)
Fig. 9. (a) Snapshot of our DSMS implementation. (b) A grid WSN.
lected by mobile mules when we vary the visited interval of
a sink or collecting duration of a mule. We compare DSMS
against Greedy Forward (GF), where a node always tries to
send its packets to any node closer to the sink until the latter
has no storage space. OPT represents an ideal situation when
the global optimization is achieved. Fig. 6(a) shows that as the
visited interval increases, the average priority also increases.
Here, the duration of one slot is how long a packet moves
one hop. Fig. 6(b) shows that the average priority decreases
slightly as the collecting duration is prolonged. However, the
impact is insignificant.
Fig. 7 shows the effect of BA’s size. In Fig. 7(a), we vary
the size of BA (in terms of hop count) but fix the visiting
period of a mule by enforcing that the 1/3 of data in the
network must be collected. In terms of the average priority of
collected packets, DSMS outperforms GF and is close to OPT
when the hop count is larger than 5. Fig. 7(b) shows that the
amount of dropped data will decrease when BA’s size becomes
larger. This is because much storage space could be used. On
the other hand, transmission overheads will decrease first and
then increase when the BA’s size is getting larger, where the
transmission overheads are increased by one if there is a packet
exchange. This is because packets with the smaller priorities
have to travel long to reach BA when BA’s size is relative
small (4∼7 hops). However, as the hop count is larger than
7, more packets will be exchanged toward BA. So, this will
cause the transmission overheads increasing.
Fig. 8 shows the transmission overheads of DSMS under the
different number of nodes and a new packet arrival. Fig. 8(a)
compares the transmission overheads by varying the number of
nodes and the packet arrival rate. As can be seen, DSMS costs
more packet exchanges than GF. The transmission overheads
caused by DSMS is about a constant higher than that by
GF. Fig. 8(b) shows that the packet transmissions will be
incurred when a new packet with a random priority is inserted
into a stabilized network. The number of packet transmissions
increases while the number of nodes increases, but the effect
is insignificant.
VI. IMPLEMENTATION
We have implemented DSMS in a simplified hardware
platform. A toy train is designed to repeatedly circle around a
toy rail. The train serves as a mule, and we deploy a wireless
node on it. A number of isolated grid WSNs are deployed
around the rail. Whenever the train has a connection with a
sink, it will pull as much data from the sink (and thus its BA)
as possible. Fig. 9(a) shows our implementation structure. Our
sensor hardware platform is a low-power and low-cost wireless
microcontroller, JN5139 [18], with ZigBee-compliant wireless
interface. The WSN in Fig. 9(b) is a 4×4 grid plus a sink. We
implement our DSMS on these Jennic microcontroller boards.
We use a light sensor to generate sensory packets with priority
ranging from 0 to 9, where a higher light intensity means
a higher priority. To view the priority of a piece of sensing
data, we display the value on an on-board 7-segment display.
To facilitate data exchange, we design a COLLECT DATA
message that can be initiated by the mule to the sink. After
collecting a piece of data, the mule will transmit an ACK
message to the sink.
Our implementation shows that the DSMS can be easily
implemented in a real sensor platform with a very small image
in each microcontroller. Fig. 10 shows a snapshot where after
applying our exchange rules, data in all nodes are in-order.
The implementation verifies that our DSMS protocol is quite
simple and only needs local information. So, it is suitable for
a distributed WSN.
678
Non-Location-Based Mobile Sensor Relocation in a Hybrid Static-Mobile Wireless
Sensor Network
Fang-Jing Wu, Hsiu-Chi Hsu, and Yu-Chee Tseng
Department of Computer Science
National Chiao-Tung University
Hsin-Chu, Taiwan
{fangjing, hchsu, yctseng}@cs.nctu.edu.tw
Chi-Fu Huang
Department of Computer Science and
Information Engineering
National Chung Cheng University
Chia-Yi, Taiwan
cfhuang@csie.nctu.edu.tw
Abstract
An inherent concern for a wireless sensor network (WSN)
is the unbalanced energy consumption problem, where sen-
sors closer to the sink are more likely to exhaust their
energy faster than other nodes. To mitigate this problem,
this paper considers including some resource-rich mobile
nodes, called mobile data-pumps, to conduct data relaying
from static sensors to the sink. The network thus becomes
a two-tier network, with the original static sensors at the
low tier and data-pumps at both low and high tiers. We
propose a novel distributed navigation protocol that does
not rely on any location information of sensor nodes to
relocate data-pumps to meet both goals of connectivity and
load balance. The main idea is a concept called virtual
Voronoi cells, which can help data-pumps to locally balance
their loads using the underlaying low-tier topology and
thus significantly balance energy consumption of sensors.
Simulation results are presented to verify the effectiveness
of our result.
Keywords: load balance, mobile computing, mobile sensor,
pervasive computing, wireless sensor network.
1. Introduction
The progress of embedded micro-sensing MEMS and
wireless technologies has made the success of wireless
sensor networks (WSNs). A WSN is usually composed of
a sink and a large number of sensors, each capable of
collecting environmental information. Research issues for
WSNs, such as deployment [15], [21], energy-efficient MAC
[7], [11], and data aggregation [3], have been intensively
studied.
Sensor deployment is a critical issue for WSNs. A suc-
cessful deployment must guarantee both connectivity and
coverage. The former is to ensure that sensory data can be
delivered to the sink, and the latter is to ensure that the whole
sensing field is fully monitored. Another big challenge is the
energy unbalanced problem, where it is known that sensors
closer to the sink are likely to consume their energy much
faster than other nodes; a lot of works have tried to address
this issue [1]–[4].
Recently, researchers have proposed to add resource-
richer mobile nodes to help relieve the energy unbalanced
problem. In [8], [9], [12], [13], [17], [18], [20], a set of
mobile collectors are used to move along pre-planned paths
to collect data from static sensors. The collection process
can be single-hop [9], [13], [20] or multi-hop [8], [12],
[17], [18]. While such approaches can balance the energy
consumption of sensors, moving these collectors may cause
long delays, thus harming real-time applications. To relieve
this limitation, [19] proposes a two-tier architecture, where
the low tier consists of typical sensor nodes and the high tier
consists of mobile data-pumps, called syphons, each with a
long-range and a short-range wireless interfaces. The short-
range ones can communicate with the low-tier network. The
goal is to design a range-free protocol to help these syphons
to move around to form a connected syphon tree rooted at
the sink by those long-range interfaces. The low-tier nodes
can first relay their data to the nearest syphons and then the
syphon tree can quickly relay these data to the sink. In this
way, the energy requirement of low-tier nodes is relaxed.
In this work, we adopt the same two-tier architecture as
in [19]. However, we observe that the design of [19] does
not try to balance the loads of syphons (i.e., the numbers of
sensors served by syphons). Note that unbalanced loads of
syphons will also affect the energy consumption, and thus
the lifetime, of both high- and low-tier nodes. To resolve this
problem, we propose a novel range-free relocation protocol
based on a virtual Voronoi cell concept. We assume no loca-
tion information for syphons, and nor for low-tier sensors.
The only assumption is that the initial deployment of low-
tier sensors should be dense enough to form a connected
network with the sink. Initially, syphons may or may not
be connected with the sink. Figure 1(a) gives an example,
where the data of sensor s1 is relayed by m1 and m2, and
that of sensor s2 needs to go long way to m3 and then to
the sink. If we can properly relocate syphons as shown in
Figure 1(b), then s2 can quickly relay its data via syphons.
Relocating syphons needs to address both connectivity and
55
70
42
s1
68
data-pump
sensor
moving direction
1349,   D|)(| 1mC
7044
s2 m0
m1
m2
m3
m0
m1
m2
m3
(a) (b)
wireless link
114
Figure 2. An example of relocating data-pumps.
3.1. Balancing Mode for Attached Data-Pumps
The main idea is to enforce each attached data-pump mi
to move, based on local information, toward the ‘center’
of its current virtual Voronoi cell while keep attached.
By so doing, load balance can be achieved eventually.
Geometrically, F can be partitioned into multiple Voronoi
cells based on attached data-pumps’ locations. However,
since no location information is assumed, we will use the
connectivity information among S as a clue to navigate data-
pumps. For example, in Figure 2(a), m1 can detect that it is
not at the center of its current virtual Voronoi cell by forming
an intra-cell tree rooted at itself. Our scheme will force m1
to move toward the child with the largest subtree, i.e., s1.
After repeating this movement process several times, m1’s
subtrees will reach certain equilibrium. Concurrently, m2
and m3 will conduct the same process. More importantly,
this will repartition the virtual Voronoi cells. Figure 2(b)
shows an ideal situation after several rounds.
Our protocol is designed as an iterative process with
multiple rounds. Each round has four phases, during which
a data-pump may make a movement. Phase 1 is to partition
F into virtual Voronoi cells in a distributed manner. Phase
2 will decide each data-pump’s moving direction. Phase
3 will choose each data-pump’s parent to maintain the
connectivity in the high-tier network. The actual movement
and termination conditions are decided in phase 4. Phases
among data-pumps need to be synchronized (refer to Sec
3.3).
Phase 1: Virtual cell construction. In this phase, each
data-pump mi will compute its cell C(mi) by forming a
tree Ti rooted at itself. Each sensor sj will maintain two
variables: χ(sj) and h(sj) (hop count from mi to sj in Ti).
Initially, χ(sj) = NULL and h(sj) =∞. To start with, mi
will broadcast a Cell(mi, h) message using its short-range
antenna with h = 1 (standing for hop count). When any sj
receives a Cell(mi, h) message, it will check the following
conditions: (i) χ(sj) = NULL and (ii) h < h(sj). If any
of the above conditions is true, sj will set χ(sj) = mi, set
h(sj) = h, and broadcast a Cell(mi, h+1) message. At the
end of Phase 1, each sensor will know its master data-pump.
Phase 2: Cell center estimation. In this phase, each
mi will try to identify the center sensor cn(mi) of its
cell C(mi). Initially, mi will assume itself as the center,
i.e., cn(mi) = mi, and broadcast a CENTER(cn(mi))
message around sensors in C(mi) to form a spanning tree
rooted at itself. Each sensor sj will calculate the depth and
the number of sensors of the subtree rooted at itself, denoted
by dj and nj , respectively. Then, each sensor sj can compute
a load index as follows:
εj = α · nj + (1− α) · dj ,
where 0 ≤ α ≤ 1 is a weight to reflect the importance of
our two metrics (i.e, the deviation among |C(mi)| and the
deviation among R(mi)). Then, mi will run the following
iterative process to update the center sensor cn(mi). The
main idea can be imagined that mi throws an agent which
is like a ball and will roll toward the center of C(mi) along
the sensors with higher load index. Specifically, in each
iteration, mi will try to update the center sensor cn(mi)
by the child of cn(mi) with the highest load index, denoted
by sc, if the following condition is satisfied: εcε′c ≥ 1, where
ε′c = α · (|C(mi)|−nc)degree(cn(mi))−1 + (1− α) · (dmax + h(sc,mi)) is
the estimation of the average load index for the remaining
subtrees rooted at cn(mi)’s children excluding the subtree
rooted at sc. Here, degree(cn(mi)) is the low-tier degree of
cn(mi) (in terms of short-range antenna degree), dmax is the
maximum depth of subtrees rooted at mi’s children in the
spanning tree except the subtree rooted at sc’s ancestor, and
h(sc,mi) is the short-range antenna hop count from sc to
mi along the spanning tree. Note that instead of reforming
the spanning tree, we use εcε′c to estimate if the loads between
the side of the subtree rooted at sc and the remaining side
in C(mi) is balancing after mi move to sc’s position. Once
mi updates cn(mi) = sc, it must memorize the history of
cn(mi) to help relocate itself along the sequence of sensors
in the history when moving. This completes one iteration.
This process is repeated until there is no descent of cn(mi)
can satisfy the above condition. Note that, this phase can be
repeated more times for refining the center sensor cn(mi) of
this cell. Figure 2 gives an example, where |C(m1)| = 349,
and α = 1. Initially, m1 finds the subtree rooted at s1 with
highest load index ε1 = 114 and updates cn(mi) = s1,
because ε1ε′1 =
114
58.75 ≥ 1, where ε′1 = 349−1144 = 58.75.
Then, m1 repeatedly run this process until it finds ε2ε′2 < 1,
where ε2 = 70, and ε′2 =
349−70
2 = 139.5. Finally, m1 can
identify the center sensor cn(m1) is s1.
Phases 3: Connectivity maintenance between mobile
data-pumps. In this phase, each data-pump mi must choose
an attached data-pump to be its parent, denoted by P (mi)
for keeping attached. Specifically, mi must make sure
that it can always hear the periodical Attachment message
from P (mi) when moving. To achieve this goal, each
3.3. Synchronization Between Phases
We suggest two possible approaches to synchronize the
phases between data-pumps. The first one is that the phases
switching is coordinated by the sink, while the second one
is that each data-pump will set a timer for each pases to
control the switching timing between phases.
For the first type synchronization, upon the network is re-
quested to perform our protocol, the sink must first broadcast
a Phase1-2 Start message via the high-tier network to in-
form attached data-pumps to construct cells and estimate the
centers of cells. When an attached data-pump mi receives
the Phase1-2 Start message, it will rebroadcast this message
via the high-tier network and then execute the phase 1 and
phase 2. After mi has finished phase1 and phase 2, it will
send a Phase1-2 End message to inform the sink. The sink
must collect Phase1-2 End messages from all attached data-
pumps and then broadcast a Phase3 Start message to inform
data-pumps to execute phase 3. It is similar to the above
procedures, the sink must wait until it knows that all data-
pumps have finished the current phase and then triggers the
next phase by broadcasting message in the high-tier network.
Also, when an unattached data-pump has became an attached
one, it must listen the synchronization messages from the
sink to conduct the balancing mode.
For the second type synchronization, each data-pump will
set a specified a timer for each phase. Upon the network is
requested to execute our protocol, each attached data-pump
mi will enter the phase 1 and start a timer Phases1 Timer.
After the Phases1 Timer expired, mi will enter the phase 2
and also wait a timer for the current phases until the timer
has expired. This process will be repeatedly phase by phase
until the protocol is terminated. On the other hand, when an
unattached data-pump mi becomes an attached one, it will
immediately send Synchronization Request message to the
neighboring data-pumps to query how long it should wait
for entering the balancing mode to start a new round. When
an attached data-pump receives a Synchronization Request
message, it will reply a Synchronization Reply message with
a time duration, based on the timers of the four phases
in the balancing mode. After mi receives reply message
from neighboring data-pumps, it will switch to the balancing
mode until the maximum execution rounds has been reached.
4. Simulation Results
We randomly deploy 20000 sensors and 75 data-pumps
in a disk-sharp field with a radius of Rf . The short-range
antenna and the long-range antenna have transmission
distances rc = 60 m and Rc = 240 m, respectively (we
use WiFi and ZigBee as the reference here; the former
has a transmission range of five times the latter [10]). We
set the parameters both α (in phase 2) and β (in phase 3)
as 0.5. Our simulation results are all from the average of
100 runs. We compare our protocol against the SODaR
protocol proposed in [19] by the following two ways.
The first one (denoted by ‘ours-only connecting mode’) is
that data-pumps only can perform the connecting mode to
achieve the same goal of the connectivity in the SODaR.
The second one (denoted by ‘ours’) is that data-pumps can
run two modes in our protocol to achieve the both goals of
connectivity and load balance. In SODaR, each unattached
data-pump mi must move along the circle composed of
sensors with the same sensor hop counts from the sink as
mi’s (in terms of short-range antenna hop count) to connect
an attached data-pump. In our simulations, we use three
metrics to evaluate the performance of ours and the SODaR
as follows.
1. The quantification of the balance: we use the
fairness index [6] to measure the deviation of data-
pumps’ loads. Here, the fairness index is calculated by
f(|C(m1)|, |C(m2)|, . . . , |C(me)|) = (Σ
e
i=1|C(mi)|)2
e·Σei=1(|C(mi)|)2 ,
where 0 ≤ f(|C(m1)|, |C(m2)|, . . . , |C(me)|) ≤ 1. Note
that a protocol with the larger fairness index implies the less
deviation of data-pumps’ loads (i.e., it is more balancing).
2. The movement overhead: we calculate the average
moving distance of data-pumps in a protocol.
3. The communication overhead: we calculate the total
number of messages exchanged in a protocol.
First, we find an adequate maximum execution round by
observing the improvement in balance under different num-
ber of execution rounds. Figure 3(a) shows the simulation
result, where the fairness index only is slightly improvement
after 10 rounds. Thus, we take the maximum execution
round of our protocol by 30 rounds in the following simula-
tions. Then, we investigate the impact of relocation protocols
on balance under different radius of deployment. Figure 3(b)
shows the result, where the fairness index is decreasing with
the increasing of Rf . This is because the number of data-
pumps is too less to span a large-scale high-tier network to
balance the loads of data-pumps when Rf is larger. Note
that our relocation protocol has prominent balance results
even if only the connecting mode is conducted. Then, we
focus on the goal of connectivity to compare the overheads
of relocation protocols under different Rf . Figure 3(c) shows
an interesting result on the movement overhead, where
SODaR only can successfully work under some deployment
cases (Rf is between 1000 and 2000) and results in higher
movement overhead. This is because it may fail that an
unattached data-pump in SODaR searches an attached data-
pumps within a limited area. Note that the SODaR results
in less movement overhead when Rf > 2000, because most
data-pumps can not relocate themselves due to the SODaR
fail. However, our connecting mode can always work out
fine, and unattached data-pumps can quickly connect to the
sink with less moving distance. Finally, in Figure 3(d) shows
[2] R. Cristescu, B. Beferull-lozano, and M. Vetterli. On network
correlated data gathering. In Proc. IEEE INFOCOM, pages
2571–2582, 2004.
[3] K.-W. Fan, S. Liu, and P. Sinha. Structure-free data aggre-
gation in sensor networks. IEEE Trans. Mobile Computing,
6(8):929–942, 2007.
[4] K.-W. Fan, S. Liu, and P. Sinha. Dynamic forwarding over
tree-on-DAG for scalable data aggregation in sensor networks.
IEEE Trans. Mobile Computing, 6(10):1271–1284, 2008.
[5] N. Heo and P.K. Varshney. Energy-efficient deployment of
intelligent mobile sensor networks. IEEE Trans. Systems,
Man, and Cybernetics–Part A, 35(1):78–92, 2005.
[6] R. K. Jain. The Art of Computer Systems Performance
Analysis: Techniques for Experimental Design, Measurement,
Simulation, and Modeling. John Wiley and Sons, New York,
1991.
[7] G. Lu, B. Krishnamachari, and C. S. Raghavendra. An adap-
tive energy-efficient and low-latency MAC for data gathering
in wireless sensor networks. In Proc. IEEE Int’l Parallel and
Distributed Processing Symp., 2004.
[8] M. Ma and Y. Yang. SenCar: an energy-efficient data gath-
ering mechanism for large-scale multihop sensor networks.
IEEE Trans. Parallel and Distributed Systems, 18(10):1476–
1488, 2007.
[9] M. Ma and Y. Yang. Data gathering in wireless sensor
networks with mobile collectors. Proc. IEEE Int’l Parallel
and Distributed Processing Symp., pages 1–9, 2008.
[10] T. Nolte, H. Hansson, and L. L. Bello. Wireless automotive
communications. In Euromicro Conference on Real-Time
Systems, pages 35–38, 2005.
[11] M.-S. Pan and Y.-C. Tseng. Quick Convergecast in Zig-
Bee Beacon-Enabled Tree-Based Wireless Sensor Networks.
Computer Comm., 31(5):999–1011, 2008.
[12] J. Rao and S. Biswas. Joint routing and navigation protocols
for data harvesting in sensor networks. In Proc. IEEE Int’l
Conf. Mobile Ad Hoc and Sensor Systems, pages 143–152,
2008.
[13] J. Rao, T. Wu, and S. Biswas. Network-assisted sink navi-
gation protocols for data harvesting in sensor networks. In
Proc. IEEE Wireless Comm. and Networking Conf., pages
2887–2892, 2008.
[14] G. Wang, G. Cao, and T.F.L. Porta. Movement-assisted sensor
deployment. IEEE Trans. Mobile Computing, 5(6):640–652,
2006.
[15] Y.-C. Wang, C.-C. Hu, and Y.-C. Tseng. Efficient placement
and dispatch of sensors in a wireless sensor network. IEEE
Trans. Mobile Computing, 7(2):262–274, 2008.
[16] Y.-C. Wang and Y.-C. Tseng. Distributed deployment schemes
for mobile wireless sensor networks to ensure multilevel
coverage. IEEE Trans. Parallel and Distributed Systems,
19(9):1280–1294, 2008.
[17] G. Xing, T. Wang, W. Jia, and M. Li. Rendezvous design
algorithms for wireless sensor networks with a mobile base
station. Proc. ACM Int’l Symp. Mobile Ad Hoc Networking
and Computing., pages 231–240, 2008.
[18] G. Xing, T. Wang, Z. Xie, and W. Jia. Rendezvous planning in
wireless sensor networks with mobile elements. IEEE Trans.
Mobile Computing, 7(12):1430–1443, 2008.
[19] G. Yang, B. T. amd Daji Qiao, and W. Zhang. Sensor-
aided overlay deployment and relocation for vast-scale sensor
networks. In Proc. IEEE INFOCOM, pages 2216–2224, 2008.
[20] M. Zhao, M. Ma, and Y. Yang. Mobile data gathering with
space-division multiple access in wireless sensor networks.
Proc. IEEE INFOCOM, pages 1283–1291, 2008.
[21] Y. Zou and K. Chakrabarty. Sensor deployment and target lo-
calization based on virtual forces. In Proc. IEEE INFOCOM,
pages 1293– 1303, 2003.
[22] Y. Zou and K. Chakrabarty. Sensor deployment and target
localization in distributed sensor networks. ACM Trans.
Embedded Computing Systems, 3(1):61–91, 2004.
國科會補助計畫衍生研發成果推廣資料表
日期:2011/08/18
國科會補助計畫
計畫名稱: 階層式無線感測網路設計與實作
計畫主持人: 黃啟富
計畫編號: 98-2218-E-194-010-MY2 學門領域: 計算機網路與網際網路
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
