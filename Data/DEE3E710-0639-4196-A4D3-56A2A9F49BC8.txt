 2
analyze and design the possible methods 
to achieve privacy control in social 
networks, and how to leverage cloud 
computation to alleviate computation 
and communication on mobile devices. 
Then a lightweight authentication 
mechanism will be designed and proposed 
to protect users from privacy 
information leakage as they are 
involved in social network and mobile 
e-commerce. Also, we will formalize a 
security layer above common social 
website platforms such as Facebook and 
OpenSocial. In the last year, we will 
implement an experimental platform on 
Android phone and social websites, 
combining cloud computation techniques 
provided by the main project. 
 
 
Keywords: social networks, cloud 
computing, mobile commerce, 
authentication mechanism, privacy 
preservation 
 
二、緣由與目的 
在 Google 的主導下，行動裝置和社
群網路都開始趨向使用開放平台：Android
統合行動裝置； OpenSocial 統合社群網
路。儘管 Andriod 手機在全球占有率尚未
超越第一大 Apple iPhone，全球最龐大的
社 群 網 路 Facebook 也 尚 未 加 入
OpenSocial；但業界均已意識到 Google 的
前 景 ， 開 始 以  Android/iPhone 和
Facebook/OpenSocial 雙軌同步進行的方
式開發。Google 所提供的 API 讓開發人員
可以超越不同硬體或社群網站進行開發或
資料整合。如同 Windows 95 對個人電腦的
衝擊，標準平台確立會大幅提升應用程式
開發的速度，但安全弱點也同樣被『標準
化』造就被攻擊範圍更廣、更迅速。  
社會網路和小世界（small world）理
論有密切關聯，著名的口號「六度分隔」
示範了即使互不認識，相隔遙遠的兩人彼
此間的人際連結也很短，幾個人際間距內
就會發生不當資料流動。 在網際網路中成
型的虛擬社會網路其實多數原生於真實社
會網路，實體生活中的個人資料也隨著映
射到網際網路的虛擬社會，而社會網路自
身的拓樸就是很豐富的敏 感資訊。如同搜
尋引擎已成為全世界最不受限又免費的徵
信資料庫，社群網站間和社群網站內的資
料流動將更不受使用者掌控（例：John 並
不願意公開曾經加入 某俱樂部，但 John
的友人主動設立俱樂部社群並將他納入。）
且多數用戶會同時加入多個社群網路，例
如同時使用 Facebook、Twitter、 Plurk、
MySpace 等等，每一社群網路都製造資訊溢
流，而且這些資訊洩漏常是不可逆的 （資
訊一旦投入網際網路，就難以消 
   
圖一：複數社群網路當中的身分有被辨認
出來的疑慮  
滅）。在可預期的未來，社群網路將繼搜
尋引擎之後成為人肉搜索的新利器，尤其
複數的社群網路將提供更精確的比對資訊
供有心人士使用。  
 4
OpenSocial 是 Google 於 2007 年底釋
出的 APIs，定義社群網站應用的共通介
面，目前最新版本為 v0.8。已有 
Engage.com、Friendster、hi5、Hyves、
imeem、LinkedIn、MySpace、Ning、Oracle、 
orkut、Plaxo、Salesforce.com、Six 
Apart、Tianji、Viadeo 及 XING 等社群
網站支持。簡言之，以 OpenSocial APIs
開發的應用可在上列所有社群網站上使
用。OpenSocial APIs 的設計目標之一是
要能使用現有標準的網路技術，由兩大部
分組成：(1)用戶端提供 Javascript 
APIs；(2)伺服器端使用 REST 或 RPC 通
訊協定。Javascript APIs 提供三個主要
功能區：People（關於個人及其相互關係
的資訊）；Activities（可發佈並檢視個
人活動的更新資 訊）；Persistence（簡
單的鍵值資料倉儲，可允許無伺服器的穩
態應用程式。）伺服器端根據 JSON-RPC 通
訊協定、AtomPub 通訊協定或 Plain XML 互
動，並由 OAuth 處理驗證。 
社群網站的龍頭 Facebook 同樣在稍早的 
2007 年年中提出了 Facebook Platform，
隨即風行全球社群網站，目前已有超過三
萬個開發人員加入，是目前最成功的社群
應用平台。Facebook Platform 包含下列
數個部分： 
1. API. 同樣使用 REST 介面，是使用
者在 Facebook 上存取社群網路資
料的標準界面。  
2. FBML. 依據使用者操作 Facebook 
慣性所定義的標記語言，為 HTML 的
子集。  
3. XFBML. 在 Facebook Connect 網站
所使用的 FBML 版本， Facebook 
Connect 將是下一代的 Facebook。  
4. FQL. 類 SQL 的指令集，與其他 
Facebook Platform 組件相容。  
5. FBJS. 基於標準 Javasccript 的擴
充 APIs 集，與一般 Javascript 相
較，提供對 AJAX 元件更便利的函
式庫。  
 
三、結果與討論 
 
在計畫的第一年中，我們已完成專案
規劃、系統規格書、系統測試計畫及國內
外相關技術之評估。收集目前主要的行動
裝置安全白皮書，如： RIM Inc. 的
BlackBerry及Google Inc. 的Android作業
系統；BlackBerry的Security Model；和
Android的Security Model 。探討目前社
群網路的應用情境與隱私策略。研究目前
網路程式與其移動特性無關的攻擊態樣
（意即無論在固接網路環境或者是移動網
路環境都一體受害的網路攻擊），收集在
OWASP Top 10、Adobe Flash/PDF 威脅和
在行動裝置上的網路管理介面等。收集行
動運算技術、伺服器輔助運算和輕量的PKI
技術等可強化和提升行動裝置在行動網路
安全及存活率的輕量化技術。所設計之隱
私保護及入侵偵防相關技術與發表論文於
國際期刊與會議中，詳細技術細節請參考
附件。 
 
四、 計劃成果自評 
 
在本計畫中，我們已完成下列預設目
標: 
 蒐集與研讀雲端安全、社群網路弱
點、行動裝置應用等之理論與模型相
關文獻 
 完成專案規劃畫 
 完成系統規格書 
 完成系統測試計書 
 我們提出了一個允許使用者匿名的彈
性認證協定。使得系統可以達到匿名
以保護使用隱私之能力。 
整體而言，本研究計畫之研究成果相
當多樣且具體，除了系統設計與實作外，
相關成果已發表在下列之會議及期刊： 
 6
patterns, and structural 
steganography,＂. In WWW, 2007.  
11. A. Mislove, M. Marcon, K. Gummadi, P. 
Druschel, and B. Bhattacharjee, 
“Measurement and analysis of online 
social networks,＂ In IMC, 2007.  
12. William Enck, Machigar Ongtang, and 
Patrick McDaniel, “On Lightweight 
Mobile Phone App Certification,＂ ACM 
CCS, 2009. 
13. Hristo Bojinov, Dan Boneh, and Elie 
Burzstein, “The (in)Security of 
Embedded Web Servers in Consumer 
Electronic Devices,＂ ACM CCS, 2009.  
14. Lomako, G., Park, I.P., Johnson, S., 
Braun, D., Guo, K, “Cryptographic 
consumer electronic devices 
filesystems performance,＂ IEEE CCNC, 
2006.  
15. L. Singh, J. Zhan, “Measuring 
topological anonymity in social 
networks,＂ IEEE International 
Conference on Granular Computing, 
2007. 
16. D.Boneh, and M. Franklin,  
“Identity-based encryption from the 
Weil pairing,＂ Crypto 2001, LNCS, vol. 
2139, Springer, pp. 213-229, 2001. 
17. M. Das, A. Saxena, V. Gulati and D. 
Phatak, “A novel remote user 
authentication scheme using bilinear 
pairings,＂ Computers & Security, vol. 
25, no. 3, pp. 184-189, 2006. 
18. W. Juang, “Efficient three-party key 
exchange using smart cards,＂ IEEE 
Trans. on Consumer Electronics, Vol. 50, 
No. 2, pp. 619-624, New York, IEEE Press, 
May 2004. 
19. K. Lauter, “The advantages of elliptic 
curve cryptography for wireless 
security,＂ IEEE Wireless 
Communications, Vol. 11, No. 1, pp. 
62-67, 2004. 
20. P. Kocher, J. Jaffe, and B. Jun, 
“Differential power analysis,＂ 
Advances in Cryptology, CRYPTO＇99, pp. 
388-397, 1999. 
21. T. N. Jagatic, N. A. Johnson, M. 
Jakobsson, and F. Menczer, “Social 
phishing,＂ Communications of the ACM, 
Vo. 50, pp. 94 - 100, Issue 10, 2007. 
22. L.A.Adamic, and E. Adar, “Friends and 
neighbors on the Web,＂ Social Networks 
25, 3 (July 2003), 211--230.   
23. N. Chou, R. Ledesma, Y. Teraguchi, D. 
Boneh, and J.C.Mitchell, “Client-side 
defense against Web-based identity 
theft,＂ 11th Annual Network and 
Distributed System Security Symposium, 
2004.   
24. R. Dhamija, J. D. Tygar, “The battle 
against phishing: Dynamic Security 
Skins,＂ the 2005 symposium on Usable 
privacy and security, p.77-88, July 
06-08, 2005,  
25. L Liu, E Yu, and J Mylopoulos, 
“Security and privacy requirements 
analysis within a social setting,＂ 
Conference on Requirements Engineering, 
2003. 
26. A. K. Ghosh, and T. M. Swaminatha, 
“Software security and privacy risks 
in mobile e-commerce,＂ Communications 
of the ACM, 2001. 
27. H Yang, H Luo, F Ye, S Lu, and L Zhang, 
“Security in mobile ad hoc networks: 
challenges and solutions,＂ IEEE 
Wireless Communications, 2004. 
28. B. Halpert, “Mobile device 
security,＂ 1st annual conference on 
Information security curriculum 
development, pp. 99-101, 2004. 
TABLE I
NOTATION
M the message
S the source node
T the destination node
n number of route nodes on the path
R = {Ri} the set of route nodes
KA,B the pairwise key shared by node A and B
MAC(K,M) message authentication code on M by key K
H set of hash functions used in Bloom filters
the base stations in WSNs or access points in MANET. We
say that a node B is another node A’s friend if they have
shared authentication key. End-to-end authentication between
friends can be trivially guaranteed with shared keys through
schemes like message authentication code (MAC) or public-
key signature.
For any two end nodes need to communicate, they must have
shared key, otherwise, the sender can delegate the message to
mutual friends of both end nodes. Thus, the transmission can
be divided into a sequence of transmission tasks of message
passing from friend to friend. How to decide such a partition
of routing paths is not our concern in this paper. We will focus
on providing hop-by-hop authentication as a service of end-
to-end message passing.
We assume the routing paths are stable and can be perceived
by the source node. For instance, in WSN, the base station
is likely to have pairwise key with each node and know the
routing path to every end.
B. Threat Model
The data integrity is ensured by the end-to-end authen-
tication, which is hard to break as long as the pairwise
key between source and destination nodes is kept secret.
The adversary aims to create redundant traffic and message
verification over the routing paths and degrading the network
performance. The main attacking technique will be to modify
upstream packets or forge packets and forward them. It can
fake as source or route nodes of some false data. The adversary
can also launch another kind of attack by discarding messages
passing through it. Such problem is intrinsical unsolvable
without collaboration among peer nodes. Besides, dropping
packet is against the purpose of wasting bandwidth, thus is
not our concern in this paper.
C. Bloom Filters
Bloom filters [3] is to represent a set of entries succinctly
to support membership queries with small false positive and
zero false negative probability. Initially, there is an m-bits
bitmap whose bits are all unmarked (set to 0) and k inde-
pendent random hash functions H = {H1, ...,Hk} with range
{0, ...,m−1}. To represent a set S = {s1, ...sn} of n entries,
the bits Hi(sj) are marked (set to 1) for 1 ≤ j ≤ n and
1 ≤ i ≤ k. After all entry sj are mapped to the bitmap, the
probability that a specific bit is marked will be
p = 1− (1− 1/m)kn, (1)
so there will be approximately mp = m(1 − (1 − 1/m)kn)
bits in the bitmap are marked on average. In this paper, we
denote the above process to build a m-bit Bloom bitmap as
followed.
bitmap
Bloom←−−−− H, S
To check whether a new entry x occurs in S, we check
if all Hi(x)-th bits the bitmap are marked. If yes, we can
state that S contains x and only mistake with a minor false
positive probability f = (1− p)k, depending on the values of
m/n and k. If not, x absolutely does not occur in S. Given
fixed ratio m/n, the optimized f is 0.5k = 0.6185m/n when
k = ln 2(m/n) and p ≈ 0.5; meanwhile the bitmap is about
half 1 and half 0.
III. BASIC DESIGN OF MECHANISM
We consider the case where the route nodes along the path
are all friends of the source, that is, the source has shared
authentication key with each of them. The source node S
is using the routing path RT = {R1, R2, ..., Rn} to send
message M to the destination node T .
We first present a basic protocol with fault in this section.
Then a further improved construction is shown in the next
section. For the sake of simplicity, we leave out how the
networks decide and maintain routing paths. We assume that
our protocol works above a reliable routing mechanism.
A. Basic Technique
For hop-by-hop authentication, the basic principle we adopt
is taking advantage of the Bloom filter technique to construct
a manifest of MACs for different route nodes. The resulting
Bloom filter is called en-route authentication bitmap (EAB).
Compared to message authentication code (MAC), which
allows a specific receiver to verify the message legitimacy
by one more several hash operations, EAB is targeted for
multiple receivers. We design EAB to have equivalent or less
size than MAC. This makes EAB occupy less bandwidth while
transmission, suitable to be passed along the routing path.
With EAB, each intermediate router will only bypass false data
with low probability. Thus, an adversary aiming at injecting
false data to a node multi-hop away has to successfully forge
a valid EAB for all en-route nodes, which accumulate even
lower probability to bypass.
B. Protocol Description
1) Source Node: Before multi-hop routing on path S,R, T
starts, the source node S specifies the authentication parame-
ters, including m, k, etc, according to its security requirement.
S first generates a signature sig on M , which provides the
end-to-end authentication. This signature could be based on
MAC or public-key signature. When MAC is adopted, only S
and T possess the MAC key. Note that M can be in encrypted
form, therefore the route nodes or eavesdroppers cannot harm
the confidentiality.
This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the WCNC 2010 proceedings.
Authorized licensed use limited to: National Taiwan University. Downloaded on August 09,2010 at 07:58:07 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 2. The segmentation of MAC refers to mapped bits in EAB. Only the
first three segments are used in this case.
C. Implementation of Hash Set
In practice, the source node need not to introduce extra
hash set H to process each MAC. If the MAC is based on
cryptographic hash functions, such as HMAC [4], the resulting
image itself can be directly used to index the marked bits. For
example, in Figure 2, an 160-bit SHA1-HMAC is used. By
partitioning the image into 160/5 = 32 pieces, the source
node can choose the first 3 pieces as the index of the marked
bits in EAB.
Such design is especially beneficial to computation cost,
while every route node only have to execute one hash operation
for verification.
D. Security Analysis
Since the EAB is constructed by MACs for different routers
and the MAC keys are kept secret from others, the attack’s
strategy will be to forge an EAB for its false data, trying to
pass through as more route nodes as possible. Note that EAB
is composed of hash mapping from MAC of different route
nodes, whose distribution is independent to the adversary.
Hence, compromise of any intermediate node will not help
the adversary deceiving other route nodes.
1) Probability of bypass: Figure 3 indicates the damage a
false message could incur. For example, more than 81% of
the injection attacks will be filtered out within two hops when
the source use 32-bit EAB and k = 3 hash operations. Larger
EAB has better protection, but comes at the price of bandwidth
cost. A 64−bit EAB with k = 6 can further mitigate the error
rate of two hops to be less than 0.05%. This means that the
attackers have to send out at least 1400 random messages to
reach the third-hop node with probability about one half. The
chance that t consecutive route nodes all bypass the bogus
data is formulated as followed.
Pbypass = (1− (1/m)nk)t (6)
1 2 3 4 5 6
0.
00
0.
05
0.
10
0.
15
The number of route nodes through which the false data has to pass.
Th
e 
pr
ob
ab
ilit
y 
of
 a
 s
uc
ce
ss
fu
l a
tta
ck
.
n=8
m=32, k=2
m=32, k=3
m=64, k=3
m=64, k=6
Fig. 3. The probability of successful attacks against EAB.
2) The parameter k: The number of hash operations k is
chosen to optimized the Bloom filter. The EAB will have the
least false positive rate when k = ln 2m/n.
3) The parameter δ: The purpose of the parameter δ is
to limit the maximum number of marked bits an adversary
can do. The distribution of EAB itself is essentially an (m, p)
Binomial distribution. Accordingly, the number of marked bits
can not be about mp every time. The number of marked bits
will fall in the range δ = 2
√
mp(1− p) with probability larger
than 95%. Without δ, the adversary could trivially forge an
EAB whose bits are all marked and pass all routers. This
setting brings two side-effects:
1) The adversary can assign the maximum rather than
average number of marked bit to optimize its success
probability.
2) The source node will occasionally generate EAB which
fails to satisfy the condition of Formula (4).
Both faults together will be corrected in the next section.
IV. IMPROVEMENT WITH RANDOM PADDING
In this section, we present a simple but effective correction
to the two problems introduced in previous section. This
solution even more enforces its security.
A. Restraint of EAB
We let S to append two information to the message body:
M ′ ← {S|T |M |padding|sigS,T (M |padding)} (7)
padding is a small-sized random string chosen by the source
node. β is the anticipated number of marked bits in EAB.
This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the WCNC 2010 proceedings.
Authorized licensed use limited to: National Taiwan University. Downloaded on August 09,2010 at 07:58:07 UTC from IEEE Xplore.  Restrictions apply. 
more key chain for authenticating traffic from direct neighbors.
LHAP needs to maintain the trust between nodes constantly. In
HEAP [8], each node trivially attaches MACs of its neighbors
to the broadcast message, thus will occupy more bandwidth
than [6] and ours. ALPHA [9] also focus on hop-by-hop
authentication, however, this solution demands bidirectional
channel and handshake between two ends. Curtain [10] is the
first to use Bloom filters [3] for authentication in WSNs, but
the authors only consider the case of broadcast authentication
from the base station. Dong et al. [11] offer two solutions of
hop-by-hop authentication. It mainly focus on filtering false
data for an underlying signature-based broadcast authentica-
tion, rather than more generic message routing. it is worthy
noting that their fist solution combines several truncated MACs
for neighbors, resulting in a merged authentication information
to statistically filter bogus data. Our scheme merges MACs via
Bloom filters and can serve the same purpose as theirs.
VI. CONCLUSIONS
We present a lightweight solution for hop-by-hop authenti-
cation in wireless networks. Our scheme enjoys the benefits
of low computation cost, low communication overhead, and
high accuracy. The authentication relies on the specialized
Bloom filters, the en-route authentication bitmaps (EAB),
which is transformed from mapping several MACs. The main
purpose of EAB is to filter false data in the first few hops,
instead of drop them at first sign. Therefore we allow an
acceptable false negative rate close to the adversary, but the
false negative rate soon converges as the hop count increases.
This tradeoff greatly reduces the communication overhead
incurred by authentication. We argue that such treatment could
be employed to other lightweight authentication schemes in
multiparty environments.
ACKNOWLEDGMENT
The authors thank the anonymous reviewers for their valu-
able comments. This research is supported by National Science
Council, Taiwan, under the grant numbers, NSC 96-2628-E-
002-182-MY3 and NSC 98-2218-E-002-032.
REFERENCES
[1] M. Bellare, J. Kilian, and P. Rogaway, “The security of cipher block
chaining,” in CRYPTO ’94: Proceedings of the 14th Annual International
Cryptology Conference on Advances in Cryptology. London, UK:
Springer-Verlag, 1994, pp. 341–358.
[2] A. Perrig, R. Szewczyk, V. Wen, D. Culler, and J. D. Tygar, “Spins:
security protocols for sensor networks,” in MobiCom ’01: Proceedings
of the 7th annual international conference on Mobile computing and
networking. New York, NY, USA: ACM, 2001, pp. 189–199.
[3] B. H. Bloom, “Space/time trade-offs in hash coding with allowable
errors,” Commun. ACM, vol. 13, no. 7, pp. 422–426, 1970.
[4] H. Krawczyk, M. Bellare, and R. Canetti, “Hmac: Keyed-hashing for
message authentication,” United States, 1997.
[5] M. Bellare, R. Canetti, and H. Krawczyk, “Keying hash functions
for message authentication,” in CRYPTO ’96: Proceedings of the 16th
Annual International Cryptology Conference on Advances in Cryptology.
London, UK: Springer-Verlag, 1996, pp. 1–15.
[6] S. Zhu, S. Setia, S. Jajodia, and P. Ning, “An interleaved hop-by-
hop authentication scheme for filtering of injected false data in sensor
networks,” in IEEE Symposium on Security and Privacy, 2004, pp. 259–
271.
[7] S. Zhu, S. Xu, S. Setia, and S. Jajodia, “Lhap: A lightweight hop-by-hop
authentication protocol for ad-hoc networks,” Distributed Computing
Systems Workshops, International Conference on, vol. 0, p. 749, 2003.
[8] R. Akbani, T. Korkmaz, and G. V. S. Raju, “Heap: hop-by-hop efficient
authentication protocol for mobile ad-hoc networks,” in SpringSim ’07:
Proceedings of the 2007 spring simulaiton multiconference. San Diego,
CA, USA: Society for Computer Simulation International, 2007, pp.
157–165.
[9] T. Heer, S. Go¨tz, O. G. Morchon, and K. Wehrle, “Alpha: an adaptive
and lightweight protocol for hop-by-hop authentication,” in CONEXT
’08: Proceedings of the 2008 ACM CoNEXT Conference. New York,
NY, USA: ACM, 2008, pp. 1–12.
[10] Y.-S. Chen, I.-L. Lin, C.-L. Lei, and Y.-H. Liao, “Broadcast authenti-
cation in sensor networks using compressed bloom filters,” in DCOSS,
2008, pp. 99–111.
[11] Q. Dong, D. Liu, and P. Ning, “Pre-authentication filters: providing
dos resistance for signature-based broadcast authentication in sensor
networks,” in WiSec ’08: Proceedings of the first ACM conference on
Wireless network security. New York, NY, USA: ACM, 2008, pp. 2–12.
This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the WCNC 2010 proceedings.
Authorized licensed use limited to: National Taiwan University. Downloaded on August 09,2010 at 07:58:07 UTC from IEEE Xplore.  Restrictions apply. 
JID:YJCSS AID:2451 /FLA [m3G; v 1.45; Prn:16/08/2010; 16:01] P.2 (1-9)
2 R.-C. Wang et al. / Journal of Computer and System Sciences ••• (••••) •••–•••
In 2000, Lee and Chang [10] proposed an RSA-based user identiﬁcation and key distribution protocol for maintaining
anonymity over distributed environments. Later, Wu and Hsu [11] showed that their protocol is vulnerable to the server
spooﬁng and the identity of a valid user could be exposed. Wu and Hsu proposed an improved method for enhancing secu-
rity and eﬃciency. However, Yang et al. [12] showed that Wu and Hsu’s protocol is still insecure. That is, a service provider
could obtain a valid user’s secret token after an exchange of messages. Yang et al. proposed a protocol for overcoming this
serious problem. Unfortunately, Mangipudi and Katti [13] pointed out that Yang et al.’s protocol is vulnerable to the denial
of service attack. That is, a valid user cannot always get a service from an application server. At the same time, Mangipudi
and Katti proposed a secure identiﬁcation and key agreement protocol with user anonymity (SIKA) [13]. The SIKA and the
aforementioned protocols [10–12] are not suitable in pervasive computing environments due to the fact that clients and
servers have to consume a lot of power to calculate communicated messages, to maintain other participants’ public keys,
and key lengths are long. Several user identiﬁcation and key exchange protocols were proposed based on the elliptic curve
cryptosystems for saving the communication and computation cost and key length [14–16]. Although the computation and
communication-eﬃciency is considered in previous elliptic curve-based protocols, those protocols do not take the privacy
issue into their considerations. By the way, all previous RSA-based identiﬁcation protocols with user anonymity did not
prove the security formally.
In this paper, we propose a secure and eﬃcient identiﬁcation and key agreement protocol with user anonymity (SEIKA)
based on the diﬃculty of cracking the elliptic curve Diﬃe–Hellman assumption [17,18]. Apart from user anonymity, three
attractive features are included in our protocol: (1) each user only needs to maintain a secret token and can employ it to
access several service providers; (2) service providers do not need to maintain a password or veriﬁcation ﬁle for verifying
the login requests; (3) if a new service provider joins the system, the user’s master key does not need to be updated.
Compared with the previous RSA-based protocols [10–13], the computational cost and the key length of our protocols
are, respectively, lower and shorter. In addition, an augmented protocol which provides explicit mutual authentication is
proposed. This protocol is called SEIKA’. To prove the security of the proposed protocols, we formally demonstrate two
security theorems by employing the random oracle model [19,20].
The structure of our paper is organized as follows. In the next section, we will describe our protocols. In Section 3, we
will analyze the security of our protocols. In Section 4, we will evaluate the performances of our protocols. Finally, we will
conclude this paper in Section 5.
2. Our protocols
In this section, we propose a secure and eﬃcient identiﬁcation and key agreement protocol with user anonymity (SEIKA)
based on the diﬃculty of elliptic curve Diﬃe–Hellman problem. Then, we describe how to transform the protocol into the
augmented protocol SEIKA’, which provides the explicit mutual authentication between a client and a server.
2.1. Notations
• We denote Uc and Us as the identities of a client and a server respectively. The client and the server can employ it to
identify the validation each other.
• EK (M) denotes that a plaintext M encrypted using a symmetric key K . The encryption scheme should satisfy the
indistinguishability under chosen plaintext attack (IND-CPA) property.
• DK (C) denotes that a ciphertext C decrypted using a symmetric key K .
• t1 and t2 are two random numbers chosen by Uc and Us respectively.
• H() denotes a secure one-way hash function and the output length is l.
• A smart card producing center (SCPC) chooses a large prime number q and two integer elements a and b, where
q > 2160 and a and b are smaller than q and satisfy 4a3 + 27b2 mod q = 0. Let C be a selected elliptic curve over ﬁnite
ﬁeld Fq: y2 = x3 + ax + b mod q. Let G be a base point with a prime order n in the elliptic curve. Let O be a point
of the elliptic curve at inﬁnite, where n × G is equal to O and n > 2160. Note that × denotes the elliptic curve point
multiplication operation.
Every user (Uc and Us) has to register on the SCPC. For each user, the SCPC selects a random number Xi and computes
a corresponding public key PKi = Xi ×G , where Xi < n. Each user will hold his secret key Xi . Finally, the SCPC maintains
and publishes a public key table which contains the identities and the public keys of the registered users. Note that the
server’s identity is known to each client and its public key can be found in the public key table.
2.2. Our protocol—SEIKA
When a client Uc wants to get a service from an application server Us and to protect his identity from being exposed
over public networks, the client and the server can perform the following steps.
1. The client selects a random number t1 and gets the server’s public key PKs = Xs × G from the public key table, where
t1 < n. The client computes K1 = t1 × PKs and T1 = t1 × G . The client uses K1 to compute M1 = EK1 (Uc ‖ Nonce1),
where Nonce1 is a nonce chosen by the client. Finally, the client sends a service request = (T1,M1) to the server.
JID:YJCSS AID:2451 /FLA [m3G; v 1.45; Prn:16/08/2010; 16:01] P.4 (1-9)
4 R.-C. Wang et al. / Journal of Computer and System Sciences ••• (••••) •••–•••
4′ . The server computes the digest value of (K3 ‖ Nonce2) and uses the computed result to verify the received message. If
they are the same, the server determines that the client is valid and computes the session key SK = H(Nonce1 ‖ Nonce2 ‖
K3). We use Fig. 2 to illustrate the SEIKA’ protocol.
3. Security analysis
In this section, we prove the security of the proposed protocols by using the random oracle model. We use the model to
enhance the reliability and precision of security analysis.
3.1. Security model
Deﬁnition 1. The proposed SEIKA is (t , qse , qh , qen , qex , ε)-secure against adaptive chosen message attacks if there is no
probabilistic polynomial-time adversary A which can win a non-negligible advantage ε running at most t steps and making
at most qse Send oracle, qh Hash oracle, qen Encrypt oracle and qex Execute oracle queries, where qse is the sum of qse1 Send1
oracle, qse2 Send2 oracle, and qse3 Send3 oracle queries.
Setup. A challenger B which can simulate the environment and interact with A prepares the system’s public parameters
{n,G, F ,H, E} and comes up with a random tape which consists of a long sequence of random bits, where the bit lengths of
the order n, the hash function H, and the key distribution of the encryption scheme are k, l1 and l2, respectively. All of k, l1
and l2 are security parameters. B then selects two random numbers r1 and r2 ∈ Zn to set T1 = r1 ∗ G , PKc = C1, T2 = r2 ∗ G
and PKs = C2. Finally, B simulates the SEIKA protocol to A with the inputs {n,G, F ,H, E, T1, T2,Nonce∗1,Nonce∗2,PKc,PKs}
and the random tape, where Nonce∗1 and Nonce∗2 are nonces and are randomly chosen by B.
We model the ability of the adversary A, where A can obtain an honest transcript from the Execute oracle and can
adaptively issue various kinds of queries to the Send, Hash, Encrypt and Decrypt oracles.
1. Send(
∏i
U ,M): When A sends a message M to an oracle
∏i
U , the challenger B returns what the protocol says.
The simulation of the Send oracle is given as follows:
(a) Send(
∏i
U ,M), where M = “start”
{ // referred to as Send1 query
K1 ←− r1 × PKs; M1 ←− EK1 (Uc ‖ Nonce∗1);
msg-out ←− 〈T1|M1〉;
internal-statiU ←− 〈
∏t
S , r1,Nonce
∗
1,msg-out〉;
SK(
∏i
U ) ←− FALSE;
return (msg-out);
}
(b) Send(
∏t
S ,M) and M = “start”
{ // referred to as Send2 query
〈T1,M1〉 ←− M; K1 ←− {0,1}l2 ; (Uc,Nonce∗1) ←− DK1 (M1);
if (Uc ∈ public key table) then
{ K2 ←− r2 × PKc ; K3 ←− α ∈ Zn;
M2 ←− EK2 (H(K3 ‖ Nonce∗1) ‖ Nonce∗2); msg-out ←− 〈T2|M2〉;
internal-statetS ←− 〈
∏i
U , r2,Nonce
∗
2,msg-out〉;
SK(
∏t
S ) ←− H(Nonce∗1 ‖ Nonce∗2 ‖ K3);
return (msg-out); }
else { msg-out ←−⊥; return (msg-out); }
}
(c) Send(
∏i
U ,M) and M = “start”
{ // referred to as Send3 query
〈Us, r1,Nonce∗1,msg-out1〉 ←− internal-stateiU ;
〈T2,M2〉 ←− M; K2 ←− {0,1}l2 ; K3 ←− α ∈ Zn;
(δ,Nonce∗2) ←− DK2 (M2);
if (δ == H(K3 ‖ Nonce∗1)) then
{ SK(
∏i
U ) ←− H(Nonce∗1 ‖ Nonce∗2 ‖ K3); return ⊥; }
else { return ⊥; }
}
2. Execute(
∏i
U ,
∏t
S): When A queries this oracle, A obtains an honest execution and a transcript of the protocol between
two oracles
∏i
U and
∏t
S .
3. Hash(M): When A queries this oracle, B ﬁrst checks whether M has been queried before. If so, B returns the previous
result back to A; otherwise, B generates a random number r and returns it to A. B also stores (M, r) into the H-table
which is used to record all previous Hash queries.
JID:YJCSS AID:2451 /FLA [m3G; v 1.45; Prn:16/08/2010; 16:01] P.6 (1-9)
6 R.-C. Wang et al. / Journal of Computer and System Sciences ••• (••••) •••–•••
Let QA be the event that A can forge a valid server to create a legal message = {T2,M2} with a non-negligible prob-
ability ε. Then we have Pr[QA] = ε. Without querying the hash oracle, the probability of A correctly guessing the hash
oracle value is not larger than 1
2l1
. We denote this event by NH and Pr[NH ]  12l1 . Necessarily, we can have that the
probability of A correctly outputting a legal forged message with H(K3 ‖ Nonce1) after making the hash oracle query is
Pr[QA ∧ ¬NH ] ε − 12l1 .
We divide the advantage of B into two simulations. One is that A makes the Execute oracle query to obtain an honest
transcript. Without loss of generality, the point α must be kept in the entry of the oracle and B can get the probability of
1
qex
to solve the ECDH problem. The other simulation is that B simulates the proposed protocol which is almost perfect and
is computationally indistinguishable to A. B can get the probability of (1− 1qex ) to solve the ECDH problem.
Now, we analyze the ﬁrst simulation as follows.
1. If the point α is directly derived with the knowledge of the points PKc and PKs , B wins the probability of 12k .
2. If the encrypted key in the encryption scheme is broken, B wins the probability of 1
2l2
.
3. Whether to do deriving the point or breaking the encryption scheme, if the digest value is correctly chosen from the
oracle, B wins the probability 1qh .
4. By the above mentioned, we have 1qex  (
1
2k
+ 1
2l2
) 1qh
.
In the second simulation, B might have to simulate the environment and to run A with inputs {F ,G,n, E,PKc,PKs, T1, T2}
and the prepared random tape. Although A is given the random bits, we know that A asks i-th query which is the same
as the execution of the proposed protocol.
If A still can output another legal encrypted message M∗2 eventually, B then has several chances to derive the point α
to the based point G .
1. If Send1 has been queried, then B has the probability 1qse1 to derive the point α. We then have
1
qse1
 1
2k
∗ 1qh .
2. Depending on the advantage of qse1 queries, if Send2 has been queried, then B has the probability of ( 1qse1 +
1
qse2
) to
derive the point α.
With the advantage from A breaking the encrypted key, B can solve the ECDH problem. Hence, we have 1qse1 +
1
qse2

( 1
2k
+ 1qen ) ∗ 1qh .
3. Depending on the advantage of qse1 and qse2 queries, if Send3 has been queried, then B has the probability of ( 1qse1 +
1
qse2
+ 1qse3 ) to solve the ECDH problem. Note that B can employ the Send3 oracle to prove whether the derived point α
is correct since the Decrypt oracle is involved.
As the above mentioned and qse = qse1 + qse2 + qse3 , we have 1qse1 +
1
qse2
+ 1qse3 
1
qse
 ( 1
2k
+ 1qen ) ∗ 1qh and (1− 1qex ) 1qse .
To judge the success probability of B from A outputting a valid encrypted message in the above simulation, we learn
the “Splitting lemma” [21] as follows. Let X be the set of possible sequence of random bits and the random function values
supplied to A before the H(K3 ‖ Nonce1) query is made. Let Y be the set of possible sequence of random bits and the
random function values provided to A after the query is made. For any x ∈ X and y ∈ Y , A can output a valid forged
message with the probability ε (Prx∈X, y∈Y [QA] = ε) on inputting a random value (x ‖ y). By the “Splitting lemma”, there
exists a subset D ∈ X such that
1. Pr[x ∈ D] = |D||X |  ε2 ,
2. ∀x ∈ D , Pry∈Y [QA] ε2 .
As the above mentioned, if n ∈ D is the supplied sequence of random bits and random function values for A before the
hash oracle query is made, then the probability of A outputting a valid forged message for any sequence of random bits
and random function values y′ ∈ Y after that is at least ( ε2 )2 = ε
2
4 such that Prx∈X, y′∈Y [QA] ε
2
4 .
In the probability of A outputting another valid forged message (T2, M∗2) with H(K3 ‖ Nonce1) = H(K3 ‖ Nonce∗1), we
have that the probability of B solving the ECDH is
(
ε − 1
2l1
)(
1− 1
qex
)(
(ε − 1
2l1
)2
4
)
 1
qse
(
(ε − 1
2l1
)3
4
)

((
(ε − 1
2l1
)3
4
)
∗
(
1
2k
+ 1
qen
)
∗ 1
qh
)
.
By adding the probability of B successfully solving the ECDH, we have
JID:YJCSS AID:2451 /FLA [m3G; v 1.45; Prn:16/08/2010; 16:01] P.8 (1-9)
8 R.-C. Wang et al. / Journal of Computer and System Sciences ••• (••••) •••–•••
Table 1
Comparison of the computation cost between our protocols and related protocols.
Secret token + public key Key length Computation cost
P1 1 163 bits × 2 = 326 bits 4TH + 8TECM + 4TSYM ≈ 4TH + 232TM + 4TSYM
P1′ 1 163 bits × 2 = 326 bits 6TH + 8TECM + 4TSYM ≈ 6TH + 232TM + 4TSYM
P2 1 + (1 + n)
(SCPC and n server’s
public keys)
1024 bits 4TH + 12TEXP + 6TM + 2TSYM + 1TINV ≈ 4TH + 2886TM + 2TSYM + 1TINV
P3 1+ 1
(SCPC’s public key)
1024 bits 2TH + 7TM + 9TEXP + 1TINV ≈ 2TH + 2167TM + 1TINV
P4 1+ 1
(SCPC’s public key)
1024 bits 2TH + 8TEXP + 5TM + 2TINV ≈ 2TH + 1925TM + 2TINV
P5 1+ 1
(SCPC’s public key)
1024 bits 2TH + 9TEXP + 5TM + 2TSYM + 1TINV ≈ 2TH + 2165TM + 2TSYM + 1TINV
Table 2
Functionality comparison between our protocols and other protocols.
C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 C11 C12
P1 Yes No Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes
P1′ Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes
P2 Yes Yes Yes No No No Yes Yes Yes Yes Yes No
P3 Yes No Yes No No No No Yes No Yes Yes No
P4 Yes No Yes No No No Yes Yes Yes No Yes No
P5 Yes No Yes No No No Yes Yes Yes Yes No No
From the comparisons, it is clear that the participants only need to hold their secret tokens without knowing the other
participant’s public key. Compared with other protocols, our protocol’s computation cost is lower and the key length is
shorter. Obviously, our protocols are suitable to be applied to wireless communications, mobile roaming and ad hoc net-
works with low-power computing environments.
4.2. Functionality comparison
We denote some notations and use Table 2 to show the functionality comparisons among related schemes as follows.
C1: The client does not need to remember a password or the server does not need to maintain a password ﬁle.
C2: The client and the server can explicitly authenticate each other.
C3: The client and the server negotiate a session key.
C4: The computation cost is low.
C5: A time synchronization problem does not exist in the system.
C6: The participants does not need to hold the system or other participant’s public key.
C7: The identity of the client cannot be traced.
C8: If a used session key is compromised, other sessions cannot be damaged.
C9: No one can impersonate the server to cheat the client.
C10: No one can impersonate a valid client to obtain the service from the server.
C11: The denial of service attack cannot work in the protocol.
C12: The reliability and precision of security analysis is high.
5. Conclusion
In this paper, we have proposed a secure and eﬃcient identiﬁcation and key agreement protocol with user anonymity
SEIKA, and have transformed the proposed protocol into an augmented protocol SEIKA’, which provides the explicit mutual
authentication. Our protocols have achieved three attractive features: (1) each user only needs to maintain his secret token
and can use it to access several service providers; (2) the service providers do not need to maintain a password ﬁle for
verifying the users login requests; (3) if a new service provider joins the system, the user’s master key does not need to be
updated. Compared with other protocols, the computation cost and the key length of the proposed protocols are lower and
shorter, respectively. In addition, we also use the random oracle model to justify the security of the proposed protocols.
Acknowledgment
This work is supported in part by the National Science Council under Grants NSC 98-2218-E-002-030, NSC 98-2218-E-
002-032 and NSC 98-2221-E-327-026.
2010出國差旅報告書
國科會補助國際合作與交流活動心得報告
訪問德國Darmstadt 科大/CASED 研究中心，荷蘭 Eindhoven 科大
參加 PQCrypto 2010 / Lattice Crypto Day / Eurocrypt 2010
報告主筆：楊柏因
中央研究院資訊科學研究所 副研究員
民國99年 6月 8日
出差期間：99年 5月 23日至6月8日
同出差人: 鄭振牟, 國立台灣大學電機工程學系, 助理教授
事由： 訪問德國 Darmstadt 科技大學/CASED 研究中心 5/23-28。
訪問 Eindhoven 科技大學 6/3-7
參加 Post-Quantum Crypto Workshop 2010 5/26-28
參加 Lattice Crypto Day 2010 5/29
參加 Eurocrypto 2010 5/30-6/3
感謝： 國科會計畫 NSC 98-2915-I-001-041, NSC 98-2218-E-002-030
們和 Buchmann 教授會面，討論 FP7 與我們自己的國際合作申請進度，同時也充
份的交換了最近一些合作研究的相關動態, 包括多變量密碼學, 使用特殊硬體進行密
碼學實作, 代數破密學, 絡(Lattice) 密碼學等等。其他參與的德方人員包括
Stanislas Bulygin 博士，Schneider 先生，其他學生如 Wael Mohammed 先生，
Richard Lindner 先生，Denise Demirel 小姐等等。
3、 5/26-28 PQCrypto 開會中的演講與內容
25 日晚間我們在 Fraunhofer 研究中心舉行歡迎酒會。與會的多數學者參加過前
年在 UCincinnati 的會議, 大家為再度聚首舉杯。次(26) 日一早，我們同樣在 
Fraunhofer 中心碰面，並在早上 9 點，本屆 PQCrypto 由主辦單位的 Markus 
Rückert 宣佈正式開始。第一節的課題是多變量密碼系統的理論，其第一場演講者
是印地安納大學的 Daniel Smith-Tone 博士，他提出對我和丁 (Jintai Ding) 在 
2008 年提出的 C*-p (Projected C Star Minus) 數位簽章系統的分析與理論基礎。
第二場是由美國辛辛那提大學的 Tim Hodges 教授主講在 XL 攻擊中，不同於由我
在 2004 所提出方程組應當發生的典型行為的誤差的表象與其成因。第二節是對多
變量系統的攻擊，分別由在當地出生的 Dieter Schmidt 教授講解所謂的異形莊子
算法，和由丁教授講解幾個最近提出的多變量系統的不妥之處。
午餐後進行第一場邀請演講，由 Renato Renner 講解『後量子時代的可證明安全
性』，即他對密碼學理論中對量子電腦會對攻擊的複雜度有那些影響的近況探討。
然後是第一天下午的兩節，主題是編碼類公開金鑰密碼系統的安全性探討。首先
由 Dan J. Bernstein 主講有了量子電腦之後 Grover 演算法可以如何加速對 
McEliece 這類系統的攻擊，然後是 Christiane Peters 解說如何透過更有效率的解
碼 (資訊集解碼 information set decoding) 以破解編碼類系統的方法。嗣後是兩
場關於用側向攻擊 (side channel) 來攻擊編碼類系統的方法，分別由 Falko 
Strenzke 與 Stefan Heyse 主講，我們很高興看到這樣的論文，因為硬體方面的側
向攻擊，表示大家開始覺得簡單的攻擊不易奏效與這個領域更趨成熟了。
28 日的演講主要是 Recent results session, 也就是讓大家介紹最近的發展。這天
的邀請演講者是 Greg Neven，他為大家帶來的是關於後量子時代隱私保護的探討。
這是很重要的因為密碼學上至今幾乎所有的隱私保護都和 RSA, ECC, 或 ElGamal 
有關，而絡理論或是多變量則是沒有這些探討的，吾人如果要用我們的方法來取
代這些密碼系統，則不得不對這些考量未雨籌繆的。
28 日最後一場演說結束，我們匆忙的離開現場趕到車站準備搭火車前往巴黎。很
不幸的在 Darmstadt 與 Frankfurt 中間的 Langen 站發生自殺事件，鐵軌封閉，
而我們要坐的 TGV特快車卻是從 Frankfurt 發車，不等人的，因此我們和同行的 
Lange，Bernstein，Sendrier 幾位教授只好分別搭計程車前往 Frankfurt市中心
追趕火車，還好成功趕上，並於當晚九點趕到巴黎東站，分別入住不同的小旅館。
4、 5/29-30 巴黎行：Lattice Crypto Day 於 ENS 開會與次日的行程
29 日清晨我們起身早餐並搭乘地鐵前往位於巴黎賽茵河左岸的法國第一學府高等
師範學院 (Ecole Normale Superieure, ENS), 參加一整天的演討會。本研討會由 
阮教授 (Prof. Phong Nguyen) 主持，讓大家能夠更為熟悉最近火熱的 Lattice
晶格 (Lattice, 或譯為絡) 密碼系統的最近理論發展。 以下是當天四場演講的內容，其
這篇的課題是最近風頭正健的 Craig Gentry 主講，我們被事先警告他演講
很爛，不過他似乎準備充分，聽來還不錯。 Operations in the encrypted 
domain 是個大題目，最簡單的例如：如果用 RSA 加密 a 與 b, 那麼兩個結
果乘起來就是用 RSA 加密 ab, 當然這類的加密會破壞一些本來密碼學理論
上的性質，不過最一般的狀況下，我們可以要求它滿足一些必要的條件，
這樣就可以用於加密，而把這樣的概念推到最極端的例子，就是所謂的
fully homomorphic encryption。我們可以這樣解釋：我們會加密一個一
個的 bit，然後要求可以從 b1 b2 的加密結果算出 b1 &b2 或 b1 ^b2 等等所有的
邏輯運算，於是我們就可以算出 bit 間所有可以用電路做出來的結果的加密。
建構出 fully homomorphic encryption 一直是長久以來密碼學理論家的大
題目。對於這點 Gentry 的作法如下，先在 Ring-LWE 問題上做出容許某個
深度以下的邏輯線路的計算，即  homomorphic-up-to-a-depth circuit，
然後就可以加固到任意邏輯線路。
聽起來真是非常棒，Gentry 也給出他的估計值，他說以我們所知的攻擊，
安全到 280 的系統大概加密一次是幾分鐘，然後還要花個幾小時去做加固，
所以只要大伙兒再加把勁就做出實用的版本來了！
掌聲如雷，聽起來很難比這個再完美了，可惜筆者忍不住在提問的時候，
詢問 Gentry 這個東西的 reduction 裏面所損失掉的倍數是多少，很不幸的
大概是以百萬計 (220 以上) 所以他這樣做個幾小時，只有達到最多 260 的安
全性而已。
•
•
•
•
次日早上，我們早餐後，與幾位 ENS 的研究人員在巴黎 Lyon 站的咖啡廳短暫會
面並商談合作加入 FP7 可能，然後 Lange 和 Bernstein 教授去機場搭飛機，而我
們則搭乘長程列車往 經馬賽港往Nice, 再換車前往Monte Carlo, 準備參加歐洲密
順帶一提，第一天晚間是被迫改期的歡迎晚會。我們在此捕捉到現任世界密碼學
會主席 Bart Preneel 教授並很榮幸的能與他敲釘轉角的確認他將於本年底來台擔
任中研院資訊所的傑出講座 (Distinguished Lecture Series)。
第二天在比較正常的 9:30 開始，早上的四場演講的主題是破密，但仍有兩個的主
題是 Lattice (並不意外)，另外兩場則是對我們最有意義的兩場：第三場是由巴黎
第六大學的 Ludovic Perret 主講，介紹企圖提高編碼類公開金鑰密碼系統 (Code-
based PKC) 效率的方法會如何製造問題，以及他 (和 Faugère, Otman, Tillich) 如
何據此攻擊歷史和 RSA 幾乎一樣久遠的 McEliece 公開金鑰密碼系統的兩個變體
的弱點並破解。第四場則由 D. Khovratovich (盧森堡大學) 主講他與 Biryukov, 
Dunkelman, Keller, 和 Shamir 的近作：利用子金鑰生成過程中非線性部份的缺陷，
來攻擊 256-bit AES 的一個變體。 
中午之前是 Moti Yung 的大會邀請演講。他以慣常的誇張語氣介紹了 Google 的
關鍵字下標和希臘的線上彩卷這兩個系統，即使我們完全看不出他在其中的貢獻，
仍然不能不承認這兩個系統是很有用的。
這天下午的第一節是形式(正規)化方法與工具，另一節是模型建構與證明。
Biryukov 講解了他和 Nikoliç的工具來尋找所謂的相關金鑰差分攻擊，和 
differential attack, linear attack 被研究得很透徹一樣，最後出現了對這兩者有幾
乎完美抗力的 AES (Rijndael)。大家現在也會有系統的推估 related-key 
differential attack 的抗力了。這節也由 D. Micciancio 教授講解 Computational 
Soundness, Co-Induction, and Encryption Cycles, M 教授在絡密碼上也是威名
遠播，PQC 上次 (2008) 曾經請來主講，可惜他的腔調實在太重而不好懂。第 2節
的純理論跟我們距離太遠，已經有點疲勞的我和鄭就幾乎放棄了，轉而溫習待會
自由發表晚會中的投影片了。
第二天晚間如常先由世界密碼學會 (IACR) 主席 Preneel 教授公佈本次當選的終身
會員(fellow)：姚其智, Yvo Desmedt, Andy Clark (IACR 前主席), J.-J. Quisquater
並頒發證書，然後是 Rump Session [自由發表會]，本次的自由發表晚會由於時間
問題被迫縮短，不過仍照例由 Dan J. Bernstein 教授主持，發表者有的一本正經的
發表其最近結果，有的則插科打諢搞笑。我們在會上告知大家 PQCrypto 2011 將
Susan Hohenberger 和 Brent Waters 講解如何驗證具備極大輸入空間的隨機函
數。聽完我們就落荒而逃了。 
我們前後搭乘法國國鐵的普通車 (到 Nice)，TGV特快車 (到巴黎)，和 Thalys 特快
車 (到比利時的 Liege)，歐鐵的普通車 (到荷蘭的 Maastricht)，和區間車 (到 
Eindhoven 再到 Utrecht) 。
6、 6/4-7 訪問艾因多分科技大學 (TU Eindhoven)
週五凌晨我們萬分疲憊的抵達 Eindhoven 附近的荷蘭歷史名城烏特勒茲 (Utrecht) 
而 Lange 教授已經在月台等候我們，我們被接到住處，擱下行李略為休息後，於
中午時分前往 TU Eindhoven, 在此和 Lange 教授與其研究群開始接下來的討論。
週一下午，我們向兩位教授告別，搭乘歐鐵快車到法蘭克福機場，並搭乘泰航班
機返台，並於次日晚上抵達。
7、 心得與建議
我們在這趟長達十七天的出差旅行中，主要的收穫除了在我們自己的研究上面得
到許多先進的寶貴意見，有助於未來在此領域上的更進一步突 破與改進外，更是
要感謝諸多贊助單位如國科會、經濟部技術處、國立台灣大學、以及中央研究院
等給我們這個機會能夠更加深入瞭解目前密 碼學的專家學者之主流研究方向。在
實務面，本研究群能夠成功爭取到 PQCrypto 2011 的主辦權，對於台灣在密碼學
界的知名度，應該會有很大的助益。
由於綠能雲端計算的崛起，密碼學界目前當紅的研究主題，乃是如何應用如絡密
碼學(Lattice-based cryptography) 及橢圓曲線密碼學，在雲端計算平台上，提供
能夠保戶使用者隱私的安全機制，值得國內學者進一步投入。這 些研究對於綠能
雲端計算典範是否能成功，有著決定性的影響力。政府目前非常重視在雲端計算
相關領域的研發，投入相當高的研發經費，如 果學界能好好利用這個機會，假以
時日台灣必能在此領域獲得豐碩的研發成果，達到世界一流的水準。
今年 PQCrypt、Lattice Crypto Day、以及 Eurocrypt 與會有許多來自歐美日韓的
國科會補助計畫衍生研發成果推廣資料表
日期:2010/12/21
國科會補助計畫
計畫名稱: 總計畫
計畫主持人: 雷欽隆
計畫編號: 98-2218-E-002-030- 學門領域: 資訊安全
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
獲得 99年度資安金盾獎第一名。 
與ＣＭＵ建立合作平台及互訪機制。 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
