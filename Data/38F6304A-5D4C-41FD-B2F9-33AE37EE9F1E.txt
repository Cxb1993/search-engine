Abstract 
 
Keywords: Inapproximability, Probabilistic checkable proof system, Locally testable  
codes, Locally decodable codes, Expander graphs, Lattice Problems. 
 
    This project aims to study the issues related to inapproximability, such as probabilistic 
checkable proof (PCP) systems, locally testable codes, locally decodable codes, 
construction methods and operators of expander graphs and the inapproximability of 
lattice problems. 
 
    There does not exist a general method to prove the inapproximability of combinatorial 
optimization problems until 1990’s. The PCP theorem gave a reduction from an NP-hard 
problem to a probabilistic checkable proof system that uses O(logn) random bits and 
constant query complexity. Following the PCP theorem, the MAX 3SAT problem is 
proved to be inapproximable within some constant factor. Moreover, many 
inapproximable results of combinatorial optimization problems are proved by reduction 
from the inapproximability of MAX 3SAT.  
 
    Locally testable codes are used as an important tool in the proof of PCP theorem. The 
improvement of locally testable codes often implies an improvement of corresponding 
PCP system. Besides the theoretical use in PCP theorem, locally testable codes are also 
useful in communication area as an ultra efficient error detection codes. We plan to 
develop new locally testable codes and locally decoable codes to improve their 
performance in communication area and we also plan to find the limits and properties of 
locally testable codes and locally decodable codes. 
 
 
 II
 1 前言 
    NP-completeness 理論在 70 年代被 Cook 等人[Coo71, Lev73, Kar72]提出，成功的
將許多最佳化(Optimization)的問題分類。然而許多重要的組合最佳化問題已經被證
明是 NP-hard，因此這些問題似乎無法找到有效率的演算法來求出最佳解。在缺乏
P=NP 的証明之前提下，面對這些問題我們可以選擇設計一個能在多項式時間內解
出許多實例(instance)，但在最差情況下仍需要指數時間的演算法，或是一個能有效
率計算近似最佳解的逼近演算法。 
    衡量一個逼近演算法的優劣取決於計算出的解與最佳解有多接近。如一個逼近演
算法針對一個最小化問題的任何實例求出的解均為最佳解的 r 倍以下，則稱之為 r-
approximate 演算法，相對的，一個演算法能夠對最大化問題任何實例求出最佳解 r
分之ㄧ以上，稱之為 r-approximate 演算法。而 r 稱之為效能比(Performance ratio)。 
    目前已經有些問題被證明對一個小的 r，除非 P=NP 無法設計出 r-approximate 的
多項式時間演算法。此類的結果即是所謂的不可逼進性(Inapproximability)結果。原
先證明一個決定性問題(Decision problem)的 NP-hardness 的方法大多採用 Karp 化簡
法(Reduction)或是 Turing 化簡法，將一個 NP-hard 的問題化簡(Reduce)到欲證明的
問題上。證明一個問題的不可逼近性亦能藉由化簡的方式來證明，如要證明一最大
化問題 OPT 除非再 P=NP 的條件下，沒有 r-approximate 演算法，只要證明一個
NP-hard 的問題 L 的任一個實例 x 能化簡到 OPT 的實例 G(x)且具有下列兩點特
性： 
1. 當 x∈L 時，G(x)的最佳解≥rk。 
2. c 當 x∉L 時，G(x)的最佳解<k。 
如此時有一 r-approximate 之多項式時間演算法，則對任何 NP 問題我們能夠透過該
演算法設計一個多項式時間演算法來解。 
    Fiege 等人[FGL+96]發現隨機可驗證系統(Probabilistic checkable proof system，簡
稱 PCP 系統)能夠給提供 NP 一個可靠的模型，並能用在證明 Independent set 問題
的不可逼近性上。1991 年，Arora 等人[AS98, ALM+98]證明了 PCP 定理，PCP 定
理給了 NP 問題新的詮釋：透過隨機可驗證系統來詮釋 NP，而不用傳統的 Turing 
Machine。且透過 PCP 定理證明了 Max 3SAT 問題的不可逼近性，即存在一常數
t，除非 P=NP 否則 Max 3SAT 問題沒有 t-approximate 多項式時間演算法。如同
Cook 定理證明了 SAT 問題是 NP-hard 之後，一連串的化簡證明了許許多多的問題
也是 NP-hard，PCP 定裡的證明也帶來一連串的突破，許多問題的不可逼近性能夠
透過化簡 Max 3SAT 問題而證明其不可逼近性。 
    PCP 定理無疑是現今研究最佳化問題之不可逼近性的重要基石，但由直接化簡得
來的結果不見得是最佳的。藉由其他的工具諸如擴張圖(Expander graphs)，亂數錯
取器(Randomness extractors)，問題本身的特性，以及在隨機可驗證系統的設計上尋
求改進，都可能可以造成不可逼近性結果的提升。藉由 PCP 定理的直接化簡，往
往可推出存在一個常數 t，除非 P=NP 否則某個組合最佳化問題沒有 t-approximate
多項式時間演算法，如 Clique 問題即是如此。然而透過問題本身的特性，可以證
得更進一步的結果。由 Alon 等人[AFWZ95]， Hastad[Has99]及 Zuckerman[Zuc06]
 - 1 -
2. 每次我們可以進行的操作是，將任一個量杯裝滿水，將任一個量杯中的水倒
空，以及將 A 量杯的水倒到 B 量杯，直到 A 量杯空了或是 B 量杯滿了。 
3. 求出使第i個量杯裝有ai水量的最少操作次數。 
在該篇論文中，作者證明了量出(a1,…,an)=(0,…,0,gcd(c1,…,cn))所需要的次數至少是
2|x|1-1，至多是 2|x|1，其中整數向量x是符合x∙(c1,…,cn)=gcd(c1,…,cn)的向量中，|x|1
最小的整數向量。此外，藉由這個結果以及Havas與Seifert[HS99]所證明出的定
理，量杯倒水問題是無法被逼近到任一常數倍的，即要除非P=NP，否則對於任一
r>1，不存在r-approximate的演算法。 
     當我們更進一步去細讀 Havas 與 Seifert[HS99]的論文時，我們可以發現他們是
藉由 Arora 等人[ABSS97]的結果，經由 Shortest Integer Solution(SIS)問題間隔保存
化 簡 (Gap Preserving Reduction) 到 所 謂 的 Shortest Diophantine Equation 
Solution(SDES)問題再進一步的化簡到 Shortest GCD Multiplier(SGCDM)問題。在此
我們先介紹此三個問題。所謂的 SIS 問題是： 
1. 給定n個整數向量b1,…,bn，並給一個整數目標向量t。 
2. 找出一整數向量x=(x1,…xn)，滿足x1b1+…+xnbn=t，且|x|值最小。 
所謂的 SDES 問題是： 
1. 給定n個整數b1,…,bn，並給另一個整數t。 
2. 找出一整數向量x=(x1,…xn)，滿足x1b1+…+xnbn=t，且|x|值最小。 
所謂的 SGCDM 問題是： 
1. 給定n個整數b1,…,bn。 
2. 找出一整數向量x=(x1,…xn)，滿足x1b1+…+xnbn=gcd(b1,…,bn)，且|x|值最小。 
[ST08]即是透過間隔保存化簡 SGCDM 到量杯倒水測量問題來證明不可逼近性。由
[HS99]與[ST08]的結果我們可以知道，如果能夠改進 SIS、SDES 或 SGCDM 問題
的不可逼近性結果，則量杯倒水測量問題的不可逼近性也就能夠獲得進一步的改
善。 
     Arora等人[ABSS97]的結果主要是針對晶格問題與相關的一些問題的不可逼近性
做研究，其中針對CVP問題的結果，被Dinur等人[DKRS03]改進了，其中，原本
CVP不可逼近至任一常數的結果，被改進到不可逼近至nc/loglogn，其中c為一個大於
0 的常數。然而細讀過[DKRS03]之後，我們得知Dinur等人[DKRS03]先透過PCP系
統的建制，證明了Super SAT(SSAT)問題的不可逼近性，然後在藉由Super SAT間
隔保存化簡至SIS問題，在藉由SIS問題化簡至CVP問題。因此，我們可以自此推得
量杯倒水測量問題，也是不可逼近至nc/loglogn，其中c為一個大於 0 的常數。即除非
P=NP，否則不存在nc/loglogn-approximate演算法。 
    我們藉由以下圖表來說明這些問題之間的關係： 
 - 3 -
5 結果與討論 
 
1. 我們針對以下的組合最佳化問題提出了明確的演算法，用以求出最佳解。在
一個雙層，每層有n格的飛鏢盤上安排分數a1…a2n，使相差的q次方和最大，
其中q>1。如n=8 且ai=i時，不論q為多少，最佳的安排方式均為下圖： 
1
16 2
15
3
14 4
13
5
12 6
11
10
7
8
9
 
2. 我們證明了上述問題能使用貪心演算法(Greedy algorithm)。因此能夠有效率
的在多項式時間內解決，故不需討論其複雜度與不可逼近性。 
3. 我們將此問題寫成論文”Arranging numbers on circles to reach maximum total 
difference”，發表於 Electronic Journal on Combinatorics, R47: Volume 14, 
2007。 
4. 單層的飛鏢盤問題已由 Cohen 與 Tonkes[CT01]及 Curtis[Cur04]解出有效率的
演算法，而更多層的飛鏢盤問題現今仍不知是否有有效率的演算法能解決，
亦不知其複雜度與不可逼近性。 
5. 我們證明了倒水問題新的不可逼近性結果，並投稿至 JISE。 
6. 我們若能夠改進 SSAT、SIS、SDES 或 SGCDM 其中任一個問題的不可逼近
性結果，則 CVP 問題與倒水問題均有參數相對應的不可逼近性結果。 
7. 至今仍沒有比[DKRS03]更佳的晶格問題之不可逼近性結果，如果相關問題有
所改進，是否對於倒水問題等有更進一步的改善仍需要進一步探討。 
8. 我們設計了一系列的頻率排序編碼，自{0,1}n映到Sn2，能夠對抗強度小於n/4
的L∞-norm雜訊，且能在雜訊小於n/6 時，查詢兩個位置的情況下，以高確率
(>2/3)解回一個位元的訊息，此結果發表在 International Symposium on 
Information Theory, 2009。 
9. 我們並設計了更多 Information rate 參數更好的頻率排序編碼，以及一系列相
關的性質與上下界，將投稿於 IEEE Transaction on Information Theory。 
 
參考文獻 
[ABSS97] S. Arora, L. Babai, J. Stern, and Z. Sweedyk. Hardness of Approximate 
Optima in Lattices, Codes, and Linear Systems. Journal of Computer ans 
System Sciences, Vol 54(2), pp. 317-331, 1997. 
[AFWZ95] N. Alon, U. Fiege, A. Wigderson, and D. Zuckerman, Derandomized 
graph products, Computational Complexity, 5(1):60-75, 1995. 
 - 5 -
[LTT08] Te-Tsung Lin, Shi-Chun Tsai, and Wen-Guey Tzeng. Efficient Encoding 
and Decoding with Permutation Arrays. 2008 International Symposium on 
Information Theory (ISIT2008). 
[Oba02] K. Obata, Optimal lower bounds for 2-query locally decoable linear codes, 
In the proceedings of the 6th RANDOM, vol. 2483 of Lecture Note in 
Computer Science, 39-50, 2002. 
[OPS07] R. Ostrovsky, O. Pandey and A. Sahai, Private Locally Decodable Codes, 
Report 2007/025, Cryptography ePrint Archive, 2007.  
[Rag07] P. Raghavendra, A note on Yekhanin’s locally decodable codes, Technical 
Report TR07-016, Electronic Colloquim on Computational Complexity, 
2007. 
[ST08] Min-Zheng Shieh and Shi-Chun Tsai. Jug Measuring: Algorithms and 
Complexity. Theoretical Computer Science, Vol 396, pp. 50-62, 2008. 
[ST09] Min-Zheng Shieh and Shi-Chun Tsai. Decoding Frequency Permutation 
Arrays under Infinite norm. 2009 IEEE International Symposium on 
Information Theory, 2009, Seoul, Korea. 
[Woo07] D. Woodruff, New lower bounds for generally locally decodable codes. 
Technical Report TR07-006, Electronic Colloquim on Computational 
Complexity, 2007. 
[Yek06] S. Yekhanin, New locally decodable codes and private information 
retrieval schemes, Technical Report TR06-127, Electronic Colloquim on 
Computational Complexity, 2006. 
[Zuc06] D. Zuckerman, Linear Degree Extractors and the Inapproximability of 
Max Clique and Chromatic Number, In Proc. 38th ACM Sympos. on 
Theory of Computing, 681-690, 2006. 
 
計畫成果自評 
1. 雙層飛鏢盤問題較原先評估的簡單，但多層飛鏢盤的難度仍未釐清，仍具有
研究探討的空間。 
2. 區域可解的頻率排續編碼的研究成果已於頂級資訊理論國際會議發表，並繼
續擴展內容，準備投稿至 IEEE transaction on Information Theory。 
3. 針對區域可解編碼的研究，將繼續朝建構新的編碼方式以及推導新的編碼長
度上下界努力。 
4. 關於頻率排序編碼的應用，將更進一步的尋求其他方面，如密碼學與資訊安
全的應用。 
5. 倒水問題的不可逼近性新結果可作為論文發表，已經投稿至 JISE。 
6. 而倒水問題與晶格問題相關的研究題材，仍需進一步的探討才能找出更進一
步的發展。 
 
 
附錄 
 - 7 -
613
4
18
1205
12
9
14
11
8
16
7
19 3 17
2
15
10
Figure 1: A traditional dartboard.
minimize the risk function. Later, Cohen and Tonkes [3] analyzed optimal permutations
for multisets of numbers. Recently, Curtis[4] designed a greedy algorithm to find an
optimal permutation pi = a1an−1a3an−3a5 · · ·an−4a4an−2a2an for the dartboard problem,
where a1 ≤ a2 ≤ · · · ≤ an.
In this paper, we extend the dartboard problem from single circle to double circles.
For example, the dartboard with two circles, is as shown in figure 2. Assume that we
are given a multiset of 2n numbers and a double layer dartboard. We use a pair of
permutations (v1 · · · vn, w1 · · ·wn) to describe the arrangement, as shown in figure 3, where
v1 · · · vn is a cyclic permutation for the outer circle and w1 · · ·wn is a cyclic permutation
for the inner circle. We can extend the definition of the risk function to the double
layer dartboard. For example, the risk of the arrangement (v1 · · · vn, w1 · · ·wn) in figure
3, denoted by rq(v1 · · · vn, w1 · · ·wn), is defined as
∑n
i=1
|vi − wi|
q +
∑n
i=1
|vi − vi−1|
q +∑n
i=1 |wi − wi−1|
q where v0 ≡ vn and w0 ≡ wn. We define the 2-dartboard problem as:
finding an arrangement (τV , τW ) for a multiset A = {a1, · · · , a2n} on two circles which
maximizes the risk function, where V and W is a partition of A and both have n elements.
Furthermore, we can extend the dartboard problem to k-layer dartboard. We use k
cyclic permutations (τ1, · · · , τk) to represents the arrangement where τi is a permutation
on n elements for the i-th circle. The risk function can be recursively defined as
rq(τ1, · · · , τk−2, τk−1 = v1 · · · vn, τk = w1 · · ·wn) = rq(τ1, · · · , τk−1)+rq(τk)+
n∑
i=1
|vi − wi|
q ,
where the last term is the sum over the q-th power of the absolute differences between
numbers of the (k − 1)-th and k-th circles. Similarly, the k-dartboard problem is: find-
ing an arrangement for a multiset A = {a1, · · · , akn} on k circles to maximize the risk
function.
For the k-dartboard problem, we show once the numbers on each circle is determined,
then we can find the maximum arrangement efficiently. Moreover, we show that for the
2-dartboard problem, there exists an efficient greedy algorithm given an arbitrary input.
the electronic journal of combinatorics 14 (2007), #R47 2
For an n-element multiset A, we denote the maximum permutation of A claimed in
Theorem 1 by pin(A). Cyclic permutations are reverse-invariant and shift-invariant when
calculating the risk function. That is, the value of risk is the same under the following
permutations α1 · · ·αn, αn · · ·α1 and αi+1 · · ·αnα1 · · ·αi for i ∈ [n − 1]. We denote the
reverse of permutation τ by τR.
Lemma 2. Given two multisets of numbers X = {x1, · · · , xn} and Y = {y1, · · · , yn}.
Assume that x1 ≤ · · · ≤ xn. If y1 ≤ · · · ≤ yn, then
∑n
i=1 |xi − yn−i+1|
q has the maximum
value over all possible permutations of yi’s, where q ≥ 1.
Proof. Assume that y1, · · · , yn are not sorted in increasing order and
∑n
i=1 |xi − yn−i+1|
q
is maximized. Thus, there exists i, j such that i < j and yn−i+1 < yn−j+1. We call i and
j form an inversion in yi’s . As xi ≤ xj, we know that |xi − yn−i+1|
q + |xj − yn−j+1|
q ≤
|xj − yn−i+1|
q + |xi − yn−j+1|
q by lemma 1. Therefore the sum does not decrease after
swapping yn−i+1 and yn−j+1. By repeating the swapping step whenever there is an inver-
sion in yi’s, then we can eventually rearrange yi’s in increasing order without decreasing
the sum, since there are at most O(n2) inversions in a permutation of size n. 2
With lemma 2, we have the following theorem.
Theorem 2. If n numbers on each circle are given, say X and Y are the multisets
of numbers on the outer circle and the inner circle, respectively, then the arrangement
(pin(X), pin(Y )
R), achieves the maximum risk. That is, rq(pin(X), pin(Y )
R) ≥ rq(τX , τY )
for any permutation τX of X and τY of Y .
Proof. Since the numbers on the outer circle are permuted with pin(X), the risk con-
tributed from the outer circle is maximized and so is pin(Y )
R to the inner circle. Assume
X = {x1, · · · , xn} with x1 ≤ · · · ≤ xn and Y = {y1, · · · , yn} with y1 ≤ · · · ≤ yn. Observe
that pin(X) = x1xn−1x3 · · ·xn−2x2xn and pin(Y )
R = yny2yn−2 · · · y3yn−1y1. By lemma 2,
we have the risk contributed from the difference between circles is maximized since xi is
adjacent to yn−i+1. Therefore, we conclude that rq(pin(X), pin(Y )
R) ≥ rq(τX , τY ) for every
permutation τX of X and τY of Y . 2
By the above, for convenience, we denote the maximum risk corresponding to partition
(X, Y ) by rq(X, Y ).
Corollary 1. Let Xi be the multiset of n numbers on the i-th circle, i = 1..k, then the
arrangement, permuting circle i with pin(Xi) if i is odd, else with pin(Xi)
R, achieves the
maximum risk.
Proof. By induction on k, assume the corollary is true up to k − 1. Similar to the proof
for theorem 2, the risks contributed from the first k − 1 circles and from the k-th circle
are maximized by induction basis. The risk contributed from the difference between the
(k − 1)-th and k-th circles is also maximized due to lemma 2. Thus the corollary is true
for k. 2
Let A be a multiset of kn elements and (A1, · · · , Ak) is a partition of A with each Ai
of the same size. We say a partition (A1, · · · , Ak) is maximum if rq(pin(A1), pin(A2)
R, · · · )
≥ rq(τ1, · · · , τk), for every arrangement (τ1, · · · , τk) of A. Note that corollary 1 implies
the electronic journal of combinatorics 14 (2007), #R47 4
on. Let l = min{i : xi ≥ yi} and r = min{j : xn−j+1 ≤ yn−j+1}. Let k = min(l, r). It is
clear that 1 < k < n, and for every i < k, xi < yi and xn−i+1 > yn−i+1. By lemma 1, we
have
|xi − yn−i+1|
q + |xn−i+1 − yi|
q ≤ |xi − xn−i+1|
q + |yi − yn−i+1|
q
for every i < k. Thus, swapping xi’s with yi’s and swapping xn−i+1’s with yn−i+1’s
respectively, for every i < k will not decrease the risk contributed from the difference
between circles. This kind of swapping is a basic step of our argument. The rest part of
proof is to decide the numbers we should swap. There are two possible cases:
• k = l < r: For k is odd, we swap xn−k+2, xk−2, xn−k+4, xk−4, · · · , xn−1, a1 with
yn−k+2, yk−2, yn−k+4, yk−4, · · · , yn−1, y1, respectively. We illustrate the swapping op-
eration in figure 5. For k is even, as in figure 6, we swap xn−k+2, xk−2, xn−k+4,
xk−4, · · · , x2, a2n with yn−k+2, yk−2, yn−k+4, yk−4, · · · , y2, yn, respectively.
a2n
x2
a1
xn−1
...
xn−k+2
xk
· · · · · ·
xn−k+1
xk−1
...
y1
yn−1
yn
y2
...
yk−1
yn−k+1
· · · · · ·
yk
yn−k+2
...
a2n
x2
y1
yn−1
...
yn−k+2
xk
· · · · · ·
xn−k+1
xk−1
...
a1
xn−1
yn
y2
...
yk−1
yn−k+1
· · · · · ·
yk
xn−k+2
...
Figure 5: The swapping operation when k = l and k is odd
a2n
x2
a1
xn−1
...
xk−1
xn−k+1
· · · · · ·
xk
xn−k+2
...
y1
yn−1
yn
y2
...
yn−k+2
yk
· · · · · ·
yn−k+1
yk−1
...
yn
y2
a1
xn−1
...
xk−1
xn−k+1
· · · · · ·
xk
yn−k+2
...
y1
yn−1
a2n
x2
...
xn−k+2
yk
· · · · · ·
yn−k+1
yk−1
...
Figure 6: The swapping operation when k = l and k is even
The swapping operation exchanges the elements in the gray regions. The new ar-
rangement has a1 and a2n on different circles. As mentioned above, swapping the
numbers in the gray regions does not decrease the risk from the difference between
circles. Moreover, the illustrations indicate that the neighbors of a1, a2n, y1 and yn
the electronic journal of combinatorics 14 (2007), #R47 6
lemma 1, we have
|xk−1 − xn−k+1|
q + |yk−1 − yn−k+1|
q ≤ |xk−1 − yn−k+1|
q + |yk−1 − xn−k+1|
q
Again, swapping does not decrease the risk function.
We conclude that there exists a maximum arrangement in the required form. 2
Proposition 2. For n ≥ 3, there exists a maximum partition (X∗, Y ∗) such that a1, a2n−1
∈ X∗ and a2, a2n ∈ Y
∗.
Proof. Let (X, Y ) be an arbitrary maximum partition. Let X = {x1, · · · , xn} with x1 ≤
· · · ≤ xn and Y = {y1, · · · , yn} with y1 ≤ · · · ≤ yn. By proposition 1, we can assume
x1 = a1 and yn = a2n. If a2 /∈ Y , then x2 = a2 since a2 is the second smallest element.
We obtain another arrangement with a2 on the inner circle by swapping a2 and y1, as in
the following illustration:
Before swapping After swapping
· · · a1 xn a2 xn−2 · · ·
· · · a2n y1 yn−1 y3 · · ·
· · · a1 xn y1 xn−2 · · ·
· · · a2n a2 yn−1 y3 · · ·
It is clear that a2 ≤ y1 and xn−2 ≤ a2n. By lemma 1, we have |a2n − y1|
q + |xn−2 − a2|
q ≤
|a2n − a2|
q + |xn−2 − y1|
q. Therefore the swapping operation does not decrease the risk
and the new arrangement is maximum. Hence, we can assume a2 ∈ Y from now on.
If a2n−1 /∈ X, then yn−1 = a2n−1 since a2n−1 is the second largest element. Similarly,
we can swap a2n−1 with xn to obtain an arrangement with a2n−1 on the outer circle:
Before swapping After swapping
· · · a1 xn x2 xn−2 · · ·
· · · a2n a2 a2n−1 y3 · · ·
· · · a1 a2n−1 x2 xn−2 · · ·
· · · a2n a2 xn y3 · · ·
It is clear that a2n−1 ≥ xn and y3 ≥ a1. By lemma 1, we have |a2n−1 − y3|
q + |xn − a1|
q ≤
|a2n−1 − a1|
q+|xn − y3|
q. The swapping operation does not decrease the risk. We conclude
that there exists a maximum partition satisfying the proposition. 2
Proposition 3. For n ≥ 3, there exists a maximum partition (X∗, Y ∗) such that a1, a2n−1,
a2n−2 ∈ X
∗ and a2, a3, a2n ∈ Y
∗.
Proof. Let (X, Y ) be a maximum partition. Let X = {x1, · · · , xn} with x1 ≤ · · · ≤ xn
and Y = {y1, · · · , yn} with y1 ≤ · · · ≤ yn. By proposition 2, let x1 = a1, xn = a2n−1,
y1 = a2 and yn = a2n. There are 3 disjoint possible cases such that (X, Y ) does not satisfy
the proposition. We will reduce them to the required form case by case.
• Case 1: “a3 ∈ X and a2n−2 ∈ Y .” By theorem 2, we can assume x2 = a3 and
yn−1 = a2n−2. Note that this is the only case that (X, Y ) does not satisfy the
the electronic journal of combinatorics 14 (2007), #R47 8
Proof. First, we prove the “moreover” part. Since a1 ≤ a2 · · · ≤ a2n and (X, Y ) satisfies
proposition 2, the maximum arrangement corresponding to (Y ∪{a1, a2n−1}, X∪{a2, a2n})
is in the following form:
· · · a2n−2 a1 a2n−1 a4 · · ·
· · · a3 a2n a2 a2n−3 · · ·
Let ∆ = |a1 − a2n|
q+|a1 − a2n−1|
q+|a1 − a2n−2|
q+|a2 − a2n|
q+|a2 − a2n−1|
q+|a2 − a2n−3|
q
+ |a3 − a2n|
q + |a4 − a2n−1|
q−|a3 − a2n−3|
q−|a4 − a2n−2|
q. It is easy to check that rq(Y ∪
{a1, a2n−1}, X ∪ {a2, a2n}) = ∆ + rq(X, Y ).
By way of contradiction. Assume (Y ∪{a1, a2n−1}, X ∪{a2, a2n}) is not maximum. By
proposition 3, there exists a maximum arrangement in the following form:
· · · a2n−2 a1 a2n−1 x2 · · ·
· · · a3 a2n a2 yn−1 · · ·
Let (a1a2n−2 · · ·x2a2n−1, a2na3 · · · yn−1a2) be the arrangement above and ∆
′ = |a1 − a2n|
q
+ |a1 − a2n−1|
q + |a1 − a2n−2|
q + |a2 − a2n|
q + |a2 − a2n−1|
q + |a2 − yn−1|
q + |a3 − a2n|
q +
|x2 − a2n−1|
q−|a3 − yn−1|
q−|x2 − a2n−2|
q. Again it is clear that rq(a1a2n−2 · · ·x2a2n−1, a2n
a3 · · · yn−1a2) = ∆
′ + rq(a2n−2 · · ·x2, a3 · · ·yn−1). Since (X, Y ) is maximum for the sub-
problem {a3, · · · , a2n−2}, rq(X, Y ) ≥ rq(a2n−2 · · ·x2, a3 · · ·yn−1). It implies ∆ < ∆
′. But
∆−∆′
= |a2 − a2n−3|
q + |a4 − a2n−1|
q − |a3 − a2n−3|
q − |a4 − a2n−2|
q
− |a2 − yn−1|
q − |x2 − a2n−1|
q + |a3 − yn−1|
q + |x2 − a2n−2|
q
≥ |a4 − a2n−1|
q − |a4 − a2n−2|
q − |x2 − a2n−1|
q + |x2 − a2n−2|
q
≥ 0
where the first inequality holds because a2 ≤ a3 and yn−1 ≤ a2n−3 and the second holds
because a4 ≤ x2 and a2n−2 ≤ a2n−1. A contradiction!
With the “moreover” part proved, the rest is to prove ({a1, a4, a6, a7}, {a2, a3, a5, a8}) is
maximum. Suppose not, then by proposition 3 and theorem 2, the only possible maximum
arrangement is (a1a6a5a7, a8a3a4a2). But rq(a1a6a5a7, a8a3a4a2)−rq(a1a6a4a7, a8a3a5a2) =
|a6 − a5|
q + |a7 − a5|
q − |a6 − a4|
q − |a7 − a4|
q + |a2 − a4|
q + |a3 − a4|
q − |a2 − a5|
q −
|a3 − a5|
q ≤ 0 due to a4 ≤ a5. A contradiction! Thus the proposition holds for n = 4 as
well. 2
4 Conclusion
We have resolved the 2-dartboard problem. However, it is still not clear how to solve the
k-dartboard problem when k > 2. It will be interesting to design an efficient algorithm
for it or prove it to be hard, say NP-hard, etc.
the electronic journal of combinatorics 14 (2007), #R47 10
Decoding Frequency Permutation Arrays under
Infinite norm
Min-Zheng Shieh
Department of Computer Science
National Chiao Tung University
1001 University Road, Hsinchu, Taiwan
Email: mzhsieh@csie.nctu.edu.tw
Shi-Chun Tsai
Department of Computer Science
National Chiao Tung University
1001 University Road, Hsinchu, Taiwan
Email: sctsai@cs.nctu.edu.tw
Abstract—A frequency permutation array (FPA) of length
n = mλ and distance d is a set of permutations on a multiset
over m symbols, where each symbol appears exactly λ times
and the distance between any two elements in the array is
at least d. FPA generalizes the notion of permutation array.
In this paper, under the distance metric ℓ∞-norm, we first
prove lower and upper bounds on the size of FPA. Then
we give a construction of FPA with efficient encoding and
decoding capabilities. Moreover, we show our design is locally
decodable, i.e., we can decode a message bit by reading at most
λ+ 1 symbols, which has an interesting application for private
information retrieval.
I. INTRODUCTION
Let n,m and λ be positive integers with n = mλ,
and Sλn be the set of all permutations on the multiset
{
λ︷ ︸︸ ︷
1, . . . , 1, . . . ,
λ︷ ︸︸ ︷
m, . . . ,m}. A frequency permutation array
(FPA) is a subset of Sλn for some positive integers m, λ
and n = mλ. A (λ, n, d)-FPA is a subset of Sλn and the
distance between any pair of distinct permutations is at
least d under any metric, such as Hamming distance, ℓ∞-
norm, etc. Permutation array (PA) is simply a special case
of FPA by choosing λ = 1. With a fixed length n, FPA has
a smaller set of symbols than PA. Thus, codes with FPA
have a better information rate than those with PA. A widely
adopted approach to building PAs under Hamming distance,
see for example [2], is using distance preserving mappings
or distance increasing mappings from Zk2 to S1n. Most of
those encoding schemes are efficient but it is not clear how
to decode efficiently. Lin et al. [8] proposed a couple of
novel constructions with efficient encoding and decoding
algorithms for PAs under l∞-norm. FPA was proposed by
Huczynska and Mullen [4] as a generalization of PA. They
gave several constructions of FPA under Hamming distance
and bounds for the maximum array size. In this paper, we
extends the ideas in [8] to constructing FPA under l∞-norm.
We prove lower and upper bounds of FPA. Then we show
the efficient encoding and decoding algorithms. Besides, we
show that our FPAs are locally decodable codes under l∞-
norm.
Recently, researchers have found that PAs have applica-
tions in areas such as power line communication (e.g. [9],
[12], [13] and [14]), multi-level flash memories (see [5]
and [6]). Similar to the application of PAs on power line
communication, we can encode a message as a frequency per-
mutation from Sλn and associate each symbol i ∈ {1, . . . ,m}
with a frequency fi. Then the message is transmitted as a
series of corresponding frequencies. For example, to send
a message encoded as (1, 2, 2, 1, 3, 3), we can transmit the
frequency sequence (f1, f2, f2, f1, f3, f3) one by one.
For flash memory application, different from the approach
by Jiang et. al. [5], [6], we can use FPA to provide multi-level
flash memory with error correcting capability. For example,
suppose a multi-level flash memory, where each cell has
m states, which can be changed by injecting or removing
charge into or from it. Over injecting or charge leakage
will alter the state as well. We can use the charge ranks
of n cells to represent a permutation from Sλn , i.e., the cells
with the lowest λ charge levels represent symbol 1, and so
on. With our efficient encoding and decoding algorithms,
a (λ, n, d)-FPA can be used in flash memory system to
represent information and correct errors caused by charge
level fluctuation.
A locally decodable code has an extremely efficient decod-
ing for any message bit by reading at most a fixed number
of symbols from the received word. Suppose that a FPA is
applied to a multi-level flash memory where the length of
a codeword is nearly a block of cells (about 105)[1]. This
feature allows us to retrieve the desire message bits from
a multi-level flash without accessing the whole block. With
the locally decodable property, we can raise the robustness
of the code without loss of efficiency. On the other hand,
locally decodable codes have been under study for years, see
[10] for a survey and [15], [3] for recent progress. They are
related to a cryptographic protocol called private information
retrieval (PIR for short). We show our construction of FPA
can also be used in cryptographic application.
Notations: Let m and λ be positive integers and let
n = mλ throughout the paper unless stated otherwise.
We use [n] to represent the set {1, . . . , n}. Sλn denotes the
permutations over the multiset {
λ︷ ︸︸ ︷
1, . . . , 1, . . . ,
λ︷ ︸︸ ︷
m, . . . ,m}. For
two vectors x and y of the same dimension, let l∞(x,y) =
x’s in S1n converted to the same y. Thus, we know the
third equality holds. Therefore, the lemma holds by moving
(λ!)n/λ to the left-hand side of the equation.
We still need to estimate perA(λ,n,d) in order to get
asymptotic bounds. Kløve [7] reports some bounds and
methods to approximate perA(1,n,d). We extend his analysis
for perA(λ,n,d).
Lemma 2. perA(λ,n,d) ≤ [(2dλ+ λ)!]
n
2dλ+λ .
Proof: It is known (Theorem 11.5 in [11]) that for (0, 1)-
matrix A, perA ≤
∏n
i=1(ri!)
1
ri where ri is the sum of
the i-th row. Since the sum of any row of A(λ,n,d) is at
most 2dλ + λ, we have perA ≤
∏n
i=1 [(2dλ+ λ)!]
1
2dλ+λ =
[(2dλ+ λ)!]
n
2dλ+λ
We give perA(λ,n,d) a lower bound by using the van
der Waerden permanent theorem (see p.104 in [11]): the
permanent of an n × n doubly stochastic matrix A (i.e., A
has nonnegative entries, and every row sum and column sum
of A is 1.) is no less than n!nn . Unfortunately, A(λ,n,d) is not
a doubly stochastic matrix, since the row sums and columns
sums range from dλ+ λ to 2dλ+ λ. We estimate the lower
bound via a matrix derived from A(λ,n,d) as follows.
Lemma 3. perA(λ,n,d) ≥ (2dλ+λ)
n
22dλ
· n!nn .
Proof: Let A˜ = 12dλ+λA(λ,n,d), which has the sum
of any row or column bounded by 1, but is not a doubly
stochastic matrix. Observe that every row sum of A˜ is 1
except the first dλ and last dλ rows. For i ∈ [d] and j ∈ [λ],
both row (iλ − λ + j) and row (n − iλ + j) sum to d+i2d+1 .
Now we construct an n×n matrix B from A˜ with each row
sum equal to 1 as follows:
For i ∈ [d] and j ∈ [λ], add 12dλ+λ to
1) The first (d− i+ 1)λ entries of row (iλ− λ+ j).
2) The last (d− i+ 1)λ entries of row (n− iλ+ j).
The row sums of the first dλ and last dλ rows of B are now
(d−i+1)λ
2dλ+λ +
d+i
2d+1 = 1.
We turn to check the column sums of B. Since A˜ is
symmetric and by the definition of B, we know B is
symmetric as well. Thus we have that B is doubly stochastic
and perB ≥ n!nn .
Now we turn to bound perA(λ,n,d). Observe that the
entries of the first dλ and last dλ rows of B are at most
2
2dλ+λ times of the corresponding entries of A
(λ,n,d)
, and
the other rows are exactly 12dλ+λ times of the corresponding
rows of A(λ,n,d). We have perA(λ,n,d) ≥ (2dλ+λ)
n
22dλ
perB ≥
(2dλ+λ)n
22dλ
n!
nn .
With Lemma 2 and Lemma 3, we have the asymptotic
bounds as follows.
Theorem 2.
n!
[(2dλ− λ)!]
n
2dλ−λ
≤ F∞(λ, n, d) ≤
22λ·⌊
d−1
2
⌋nn
(2λ · ⌊d−12 ⌋+ λ)
n
.
III. ENCODING AND DECODING
Our construction idea is based on the previous work[8]
by Lin, et al. We generalize their algorithm for constructing
FPAs. Furthermore, we give the first locally decoding algo-
rithm for FPAs under l∞-norm.
A. Encoding algorithm
We give an encoding algorithm Eλn,k (see Figure 1) which
convert k-bit message into a permutation in Sλn where n ≥
k + λ.
Algorithm Eλn,k
Input: (m1, . . . ,mk) ∈ Zk2
Output: (x1, . . . , xn) ∈ Sλn
max← n; min← 1;
for i← 1 to k do
if mi = 1
then {xi ← ⌈maxλ ⌉; max← max− 1;}
else {xi ← ⌈minλ ⌉; min← min+ 1;}
for i← k + 1 to n do
xi ← ⌈
min
λ ⌉; min← min+ 1;
Output (x1, . . . , xn).
Fig. 1: Eλn,k encodes messages in Zk2 with Sλn .
The encoding algorithm Eλn,k maps binary vectors from Zk2
to Sλn and it is a distance preserving mapping. It is clear that
Eλn,k runs in O(n) time while encoding any k-bit message.
Next we investigate the properties of the code obtained by
Eλn,k. Let Cλn,k be the image of Eλn,k.
Theorem 3. Cλn,k is a (λ, n, ⌊n−kλ ⌋)-FPA with cardinality
2k.
Proof: Consider two messages p = (p1, . . . , pk) and
q = (q1, . . . , qk) ∈ Zk2 . Let xp and xq be the outputs of
Eλn,k, respectively. Let r be the smallest index such that pr 6=
qr. Without loss of generality, we assume pr = 1, qr = 0 and
there are exactly z zeroes among p1, . . . , pr−1. Consequently,
xpr is set to ⌈maxλ ⌉ = ⌈
n−r+1+z
λ ⌉ and x
q
r is set to ⌈minλ ⌉ =
⌈ 1+zλ ⌉ by E
λ
n,k . The distance between xp and xq is:
⌈
n− r + 1 + z
λ
⌉
−
⌈
1 + z
λ
⌉
>
n− r + 1 + z
λ
−
1 + z
λ
− 1
=
n− r
λ
− 1
≥
n− k
λ
− 1, since r ≤ k.
The first inequality holds by the fact of ceiling function:
a ≤ ⌈a⌉ < a + 1, for any real number a. Note that the
distance has integer value only here. If n−kλ is integer then
the distance is at least
⌊
n−k
λ
⌋
; else it is at least
⌈
n−k
λ − 1
⌉
,
which is
⌊
n−k
λ
⌋
exactly, i.e., the distance between any two
Corollary 1. Given a codeword x = Eλn,k(m) for some m
and an index i, Lλn,k outputs mi correctly.
Proof: By Lemma 4, there exists ℓ ≤ λ such that Lλn,k
terminates at the ℓ-th iteration. Let j be the index picked at
the ℓ-th iteration, we have xj 6= xi, where j > i. Note that x
is a codeword: xi < xj implies mi = 0 and xi > xj implies
mi = 1. Hence, Lλn,k outputs mi correctly.
A private information retrieval system (PIR) consists of
q servers. All servers know a codeword x = (x1, . . . , xn)
representing a message m = (m1, . . . ,mk), and a user
wants to know one bit mi of m via query a symbol
from each server. We say a PIR has retrievability r if the
user can obtain the message bit with probability r. Let
D(s, i) be the distribution of entry queried from server i
when the user tries to retrieve mi. A PIR has privacy p if
maxi,j∈[k],s∈[q] ∆(D(s, i),D(s, j)) ≤ p, where ∆(·, ·) is the
statistical distance. A (q, r, p)-PIR is a q-server PIR with
retrievability r and privacy p. A (q, r, p)-PIR has perfect
retrievability if r = 1 and perfect privacy if p = 0.
With our FPA Cλn,k, we construct a (λ+1, 1, r)-PIR with
perfect retrievability and privacy r. The scheme is simple:
• For a message m, we put x = Eλn,k(m) on all λ + 1
servers.
• We retrieve mi by Lλn,k by querying entries from servers
in a random order.
The perfect retrievability is guaranteed by Corollary 1. How-
ever, in order to retrieve mi, xi must be queried from some
servers at certain positions ℓ > i, and we have r > 0. We
leave the improvement on the privacy r as our future work.
REFERENCES
[1] P. Cappelletti, C. Golla, P. Olivo, and E. Zanoni, Flash memories.
Kluwer Academic Publishers, 1999.
[2] J. C. Chang, R. J. Chen, T. Kløve and S. C. Tsai, “Distance-preserving
mappings from binary vectors to permutations,” IEEE Trans. Inform.
Th., vol. IT-49, pp. 1054–1059, Apr. 2003.
[3] Klim Efremenko, “3-Query Locally Decodable Codes of Subexponential
Length,” Electronic Colloquium on Computational Complexity, TR08-
069, 2008.
[4] Sophie Huczynska and Gary L. Mullen, “Frequency permutation arrays,”
Journal of Combinatorial Designs, vol. 14, pp. 463–478, 2006.
[5] A. Jiang, R. Mateescu, M. Schwartz and J. Bruck, “Rank Modulation
for Flash Memories,” in Proc. IEEE Internat. Symp. on Inform. Th.,
2008, pp. 1731-1735.
[6] A. Jiang, M. Schwartz and J. Bruck, “Error-Correcting Codes for Rank
Modulation,” in Proc. IEEE Internat. Symp. on Inform. Th., 2008, pp.
1736-1740.
[7] Torleiv Kløve, “Spheres of Permutations under the Innity Norm -
Permutations with limited displacement,” Reports in Informatics, Dept.
of Informatics, Univ. Bergen, Report no. 376, 2008.
[8] T. T. Lin, S. C. Tsai and W. G. Tzeng, “Efficient Encoding and Decoding
with Permutation Arrays,” in Proc. IEEE Internat. Symp. on Inform. Th.,
2008, pp. 211-214.
[9] K. W. Shum, ”Permutation coding and MFSK modulation for frequency
selective channel,” IEEE Personal, Indoor and Mobile Radio Commu-
nications, vol. 13, pp. 2063–2066, Sept. 2002.
[10] Luca Trevisan, “Some Applications of Coding Theory in Computa-
tional Complexity,” Quaderni di Matematica, vol. 13, pp. 347-424,
2004.
[11] J.H. van Lint, R. M. Wilson, A Course in Combinatiorics., 2nd ed.
Cambridge, U.K.: Cambridge Univ. Press, 2001.
[12] A. J. H. Vinck and J. Ha¨ring, “Coding and modulation for power-line
communications,” in Proc. Internat. Symp. on Power Line Commun.,
Limerick, Ireland, April 2000.
[13] A. J. H. Vinck, J. Ha¨ring, T. Wadayama, “Coded M-FSK for power
line communications,” in Proc. IEEE Internat. Symp. on Inform. Th.,
2000, p.137.
[14] A. J. H. Vinck, “Coded modulation for powerline communications,”
Proc. Int. J. Electron. Commun, vol. 54, pp. 45-49, 2000.
[15] Sergey Yekhanin, “Towards 3-query locally decodable codes of subex-
ponential length,” J. ACM, vol. 55(1), pp. 1-16, 2008.
 
一、參加會議經過 
 
於九十六年六月二十七日晚間搭乘班機抵達韓國首爾，深夜搭乘著巴士抵達韓國首爾
世貿中心 COEX 會展中心週邊的韓國首爾都心機場，入住旅館後，隔日一早八點即向大
會報到並且完成註冊手續，並參加了兩個 Tutorial，學習到不少重要的新技術。之後
連日參加大會中各種不同的 Session，聆聽其他論文發表者的口頭報告，了解學界目前
各領域的最新進展，也積極參與各項大會所舉行的社交活動，與各國學者相談甚歡。
並於七月三日下午向與會者報告我所著作的論文。詳細的時程請參考官方網頁。於七
月四日凌晨搭乘巴士前往韓國仁川機場搭乘班機返回台北。 
 
二、與會心得 
 
IEEE Information Symposium on Information Theory 係為資訊理論(Information 
Theory)學界最重要的國際會議，其中主要收錄的領域為： 
1. Channel and source coding  
2. Coding theory and practice  
3. Communication theory and systems  
4. Cryptography and security  
5. Data compression  
6. Detection and estimation  
7. Emerging applications of information theory 
8. Information theory and statistics  
9. Network and multi-user information theory  
10.Pattern recognition and learning  
11.Quantum information theory  
12.Sequences and complexity  
13.Signal processing 
等十三大領域。我所投稿的著作被分類雖然被在 Coding theory 的範疇中，然實則與
冊費 10000 元補助上限，並不足以支付全額的註冊費用，制度上雖看似有意鼓勵學生
投稿國際會議，然實是懲罰到在頂尖國際會議發表論文博士班學生，我還得想辦法去
弄經費填補超過補助額度的註冊費用，只因為我不是電信所的。建議學校應該統一蒐
集各科系的頂尖與重要國際會議，並對所有系所學生一視同仁，透過一致標準給予補
助。而且機票錢還捨不得給，連 6078 的機票支出都要摳到 6000。 
 
申請補助的過程中讓我最憤怒的事情，莫過於看到資工所的頂尖與重要國際會議清
單。看到了 Asiacrypt 排頂尖，而不見 Crypto，看到了 Conference on Computational 
Complexity 跟 Symposium on Discrete Algorithms，卻不見 ACM Symposium on Theory 
of Computation 跟 IEEE Foundation of Computer Science。這是因為投稿投不上最
頂級的的會議，所以就把重要會議當頂尖會議，而把頂尖會議當作沒有會議的做法。
這真的是令人無言以對，其他學門的東西我不是那麼清楚，但對於 Information theory
跟 Computation theory 都很熟悉的我，這根本是令人難以接受的事情。還好外人不是
這麼懂，所以不會被發現，不會被恥笑嗎？難道我們只能夠拿這些次優秀的國際會議
當最優秀的國際會議看待嗎？難道非得等有人投上最優秀的國際會議之後才發現，原
來我所投稿的世界公認最頂尖的國際會議，連自己系上的重要國際會議都稱不上，可
是比這個差一些的卻要叫做頂尖國際會議，註冊費可以全額補助的。這實在是太令人
傷心難過的事實了。自從發現這件事情以後我真的很擔心會被其他學校的相關系所發
現，原來交大資工這麼不爭氣，把最好的當作投不上的，為了爭取更多機會被全額補
助，而淨把些投的上的軟柿子放在頂尖會議的清單裡。學校應該要是一個更注重理想
的地方！ 
 
而且報告書的部分應該要放寬頁數限制，由之前的報告書看來，很多都是貼上了不必
要的會議資訊，比如說議程，相關研究領域等等，當然不可免俗的我也幹了這種事情。
與其浪費時間在湊頁數上，不如拿這些時間去多做一些研究，提升交大的國際能見度
以及研究品質，相信如此才是對交大更有助益的事情。對我而言寫這種軌東西寫一個
晚上，實在是深刻的感受到，這時間真是寶貴，我好想做研究，好想要讓新的研究成
果，在重要的期刊跟國際會議中刊登出來，讓大家知道在交大也是有人能夠做出好研
究，而不是只會寫些狗屁倒灶的官樣文章。 
摘要 
 
關鍵詞：不可逼近性，隨機可驗證系統，區域可測試編碼，區域可解編碼，擴張
圖，晶格問題。 
 
    本計畫主要的目的於研究不可逼近性領域的相關議題，如隨機可驗證系統
(Probabilistic checkable proof systems，簡稱 PCP 系統)，區域可測試編碼(Locally 
testable codes)，區域可解編碼(Locally decodable codes)，擴張圖(Expander graphs)，
以及晶格問題(Lattice problems)之不可逼近性。 
 
    在 1990 年之前，不可逼近性的議題上始終找不到自 NP-hard 問題至組合最佳化
問題一般性的直接化簡(Reduction)。直到隨機可驗證系統的計算模型被提出之後，
隨著 PCP 定理即 NP=PCP[O(logn),O(1)]的證明，Max 3SAT 的不可逼近性隨之獲得
證明，使得許多組合最佳化的不可逼近性獲得了證明。 
 
    隨機可驗證系統的證明過程中使用了區域可測試編碼作為證明的工具，而區域
可測試編碼除了在於隨機可驗證系統的證明中扮演了重要的角色之外，在通訊領
域方面也有許多的應用。本計畫隨著研究隨機可驗證系統的研究，亦同時開發新
的以及改良既有的區域可測試編碼及區域可解編碼供通訊上實務的應用，並進一
步了解其性質。 
 
 
     
 I
目錄 
 
 
 
 
 
1 前言 ..................................................................................................................................................- 1 - 
2 研究目的 ..........................................................................................................................................- 2 - 
3 文獻探討 ..........................................................................................................................................- 2 - 
4 研究方法 ..........................................................................................................................................- 4 - 
5 結果與討論 ......................................................................................................................................- 5 - 
參考文獻 ....................................................................................................................................................- 5 - 
計畫成果自評 ............................................................................................................................................- 7 - 
附錄 ............................................................................................................................................................- 7 - 
 
所提出的論文皆更進一步的利用 Clique 問題的特性，提出更佳的不可逼近性結
果。Arora 等人[ABSS97]及 Dinur 等人[DKRS03]接連透過新的 PCP 系統來證明一
些晶格問題以及一連串的相關問題具有更高的不可逼近性，他們的結果也成為研究
相關問題最主要的基礎。 
    PCP 定理的證明過程中引入了錯誤更正編碼(Error correcting code)的概念，且使
用了 Low-degree test 來完成正確性的證明。由於 Low-degree test 是一種只需要測試
一個字串中極少的位置就能以極高的正確率來判斷是不是一個 Codeword，故而將
區域可驗證編碼(Locally Testable Code)與隨機可驗證系統做了一個連結，在區域可
驗證編碼上有好的研究發展，可以應用到設計隨機可驗證系統，能在一些問題上獲
得更好的不可逼近性結果。此外，Katz 與 Trevisan [KT00]更提出了區域可解編碼
(Locally decodable codes)，此為區域可驗證編碼的延伸，只需要由編碼字串中的一
小部分資訊即可解回訊息中的某特定位置，除了通訊上的實務應用之外，更有助於
釐清計算理論上一些觀念，頗有研究價值。 
    而近年來編碼理論的進展，由傳統一般的非線性編碼與線性編碼，更發展到了所
謂排序編碼(Permutation Codes)，透過排序的特性對抗更為複雜特異的通訊頻道雜
訊，適合被應用在電力線網路(Power Line Networks)、移頻調變(Frequency-shift 
keying)以及脈衝振幅調變(Pulse-Amplitude Modulation)的環境上。近年來，大多數
的排序編碼方式是藉由傳統線性編碼方式，透過距離保持對應(Distance Preserving 
Mapping)或是距離增加對應(Distance Increasing Mapping)的方式所建構出。但直接
由排序解碼的方式卻一直缺乏有效率的做法，直到Lin等人(LTT08)針對L∞-norm的
雜訊頻道設計的排序編碼才具有有效率的編解碼方式。本計畫也針對此類排序編碼
延伸設計了一區域可驗證的排序編碼，更近一步的提升解碼的效率。 
2 研究目的 
    本計畫之研究目的主要為尋求在不可逼近性相關領域的理論研究突破。不可逼近
性的相關領域包括組合最佳化的逼近演算法，不可逼近性質，隨機可驗證系統，區
域可測試編碼，區域可解編碼，以及擴張圖的應用與晶格問題等等。 
    目前的研究方向將針對與晶格問題相關的不可逼近性結果以及區域可解的排序編
碼進行深入的研究，包括： 
1. 晶格問題的相關不可逼近性之研究。 
2. 新的編碼方式之研究。 
3. 編碼長度上下界之研究。 
4. 解碼所需查詢的位元數上下界之研究。 
5. 排序編碼在各個領域之應用研究，如通訊，密碼與資訊安全領域等等。 
 
3 文獻探討 
    在 Shieh 與 Tsai[ST08]的論文中所探討的量杯倒水量測問題 (Jug Measuring 
Problem)是如下定義的： 
1. 給定n個量杯，容量分別是正整數c1,…,cn。另給非負整數a1,…,an，ai≤ci。 
 - 2 -
SSAT SIS SDES SGCDM 
CVP 
Jug 
Measuring 
[DKRS03] 
[DKRS03] 
[HS99] [HS99] 
[ST08] 
 
    在以下段落中，我們使用xi來表示字串x的第i個符號(Symbol)，使用d(x,y)來代表
兩個字串的相對漢明距離(Relative Hamming Distance)。 
    Katz 與 Trevisan[KT00] 首 先 提 出 區 域 可 解 編 碼 的 定 義 ， 如 下 ： 
對固定常數δ, ε以及整數q，吾人定義一編碼C:{0,1}nÆΣm為(q,δ,ε)-區域可解編碼若
存在一個機率性演算法A滿足： 
1.對任一x∈{0,1}n，及y∈Σm滿足d(y,C(x))≤ δm，則對任一i∈[n]，A(y,i)=xi的機率不
小於 1/2+ε。 
2.執行演算法 A(y,i)時，至多自 y 中讀取 q 個符號。 
Katz 與 Trevisan 的論文中主要的結果為一個(q,δ,ε)-區域可解編碼的編碼長度 m 至
少為 ，其中 l 為 log|Σ|，即編碼後一個符號所佔用的位元數。而在 q=1
的特殊前提下，訊息長度 n 不能超過 。此外，任一個區域可解編碼能
夠對應到一個私密訊息取得程序(Private Information Retrieval Scheme)，即如能得到
參數更好的區域可解編碼，即能夠取得參數更佳的私密訊息取得程序。 
))/(( )1/( −Ω qqln
)( )1(1 −−Ω Ol εδ
    我們將焦點轉移到新的研究題材，即排序編碼以及頻率排序編碼上。所謂的長度
為n的排序編碼是指長度為n的所有排序Sn的一個子集合，而通常這個子集合內的任
兩個元素都具有相當程度的距離，藉以對抗雜訊。而頻率排序 (Frequency 
Permutation)編碼，則是由m個 1，m個 2，…，m個n所形成的所有排序Snm的子集合
形程。由Lin等人[LTT08]最新發表的論文，設計了一套由{0,1}kÆSn的高效率排序
編碼方式以及對應的快速簡單解碼方式，這個編碼方式確保任兩個碼之間的L∞-
norm至少是n-k，也因此只要是L∞-norm小於(n-k)/2 的雜訊，皆無法造成任何錯誤的
解碼結果。深入研究Lin等人的設計之後，發現這不只是第一個此類可以快速編碼
解碼的排序編碼，甚至能夠在雜訊很小的時候，僅靠隨機讀取兩個位置，以足夠高
的機率解對任一位元的訊息，這非常類似之前透過漢明距離定義的區域可解編碼定
義。我們透過了解了解Lin等人的結果，進一步設計出具有區域可解特性，且可以
對抗L∞-norm雜訊的頻率排序編碼。 
 
4 研究方法 
1. 針對晶格問題相關的題材作深入的研究與探討。 
2. 透過(Gap Preserving Reduction)來證明最佳化問題的不可逼近性。 
3. 藉由類似[LTT08]的手法設計出可區域解碼的頻率排序編碼。 
 
 - 4 -
[ALM+98] S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy, Proof 
verification and hardness of approximation problems, Journal of the ACM, 
45(3):501-555, 1998. 
[AS98] S. Arora and S. Safra, Probabilistic checking of proofs: A new 
characterization of NP, Journal of the ACM, 45(1):70-122, 1998. 
[BI01] A. Beimel and Y. Ishai, Information-Theoretic Private Information 
Retrieval, Technical Report TR01-15, Electronic Colloquim on 
Computational Complexity, 2001. 
[Coo71] S. Cook, The complexity of theorem-proving procedures, in Proc. 3rd 
ACM Sympos. on Theory of Computing, 151–158, 1971. 
[CM07] Wenbin Chen and Jiangtao Meng. Hardness of Approximating the 
Minimum Solutions of Linear Diophantine Equations. Theoretical 
Computer Science, Vol 374, pp. 191-195, 2007. 
[CMY08] Wenbin Chen, Jiangtao Meng, and Dengpan Yin. An Improved Lower 
Bound for Approximating Minimum GCD Multiplier in l∞ Norm 
(GCDM∞). Theoretical Computer Science, Vol 396, pp. 1-9, 2008. 
[CT01] G. L. Cohen and E. Tonkes, Dartboard arrangements, Electron J. Combin., 
8(2): R4, 2001. 
[Cur04] S. A. Curtis, Darts and hoopla board design, Information Processing 
Letters, 92: 53-56, 2004. 
[DKRS03] I. Dinur, G. Kindler, R. Raz, and S. Safra. Approximating CVP to within 
almost-polynomial factors is NP-hard. Combinatorica 23 (2), pp. 205-243, 
2003. 
[FGL+96] U. Feige, S. Goldwasser, L. Lovasz, S. Safra, and M. Szegedy. Interactive 
proofs and the hardness of approximating cliques. Journal of the ACM, 
43(2):268–292, 1996. 
[Has99] J. Hastad, Clique is Hard to approximate within n1-ε, Acta Mathematica, 
182:105-142, 1999. 
[HM06] S. Huczynska and G. L. Mullen. Frequency Permutation Arrays. Journal 
of Combinatorial Designs, Vol 14, pp. 463-478, 2006. 
[HS99] G. Havas and J.-P. Seifert. The Complexity of the Extended GCD Problem. 
Lecture Note in Computer Science, Vol 1672, 1999. 
[Kar72] R. Karp, Reducibilities among combinatorial problems, In R. Miller and J. 
Thatcher,editors, Complexity of Computer Computations, pages 85–103, 
1972. 
[KT00] J. Katz and L. Trevisan, On the efficiency of local decoding procedures 
for error-correcting codes, In Proc. 32nd ACM Sympos. on Theory of 
Computing, 80-86, 2000. 
[KW03] I. Kerenidis and R. de Wolf, Exponential lower bound for 2-query locally 
decodable codes, In Proc. 35th ACM Sympos. on Theory of Computing, 
106-115, 2006. 
[Lev73] L. Levin, Universal sorting problems, Problemy Peredaci Informacii, 
9:115–116, 1973. In Russian, English translation in Problems of 
Information Transmission, 9:265–266, 1973. 
[Lip94] R. J. Lipton, A new approach to information theory, In Proc. 11th Annual 
Symposium on Theoretical Aspects of Computer Science, 699-708, 1994. 
 - 6 -
Arranging numbers on circles to reach
maximum total variations
Ying-Jie Liao Min-Zheng Shieh Shi-Chun Tsai
Department of Computer Science
National Chiao Tung University, Hsinchu 30050, Taiwan
{yjliao,mzhsieh,sctsai}@csie.nctu.edu.tw
Submitted: Jan 15, 2007; Accepted: Jun 10, 2007; Published: Jun 28, 2007
Mathematics Subject Classification: 05A05, 05B30
Abstract
The dartboard problem is to arrange n numbers on a circle to obtain maximum
risk, which is the sum of the q-th power of the absolute differences of adjacent
numbers, for q ≥ 1. Curtis showed that the dartboard problem admits a greedy
algorithm. We generalize the dartboard problem by considering more circles and
the goal is to arrange kn number on k circles to obtain the maximum risk. In
this paper, we characterize an optimal arrangement for k = 2 and show that the
generalized dartboard problem also admits a greedy algorithm.
1 Introduction
Darts is a very popular game. Players throw darts and score points corresponding to
the sector the darts just landed on. The traditional dartboard is circular and partitioned
into several sectors as shown in figure 1. When playing darts, players often aim at the
high score sectors. But for ordinary players, it is hard to land the dart on the desired
sectors. The risk of aiming at an area can be measured by the difference between the
scores of adjacent sectors. As the larger the difference is, the higher the risk is and the
game becomes more challenging. The total risk of a dartboard is the sum over the risks of
all sectors. The so called dartboard problem, as discussed in Curtis’ paper [4], is to find
a cyclic permutation τ = α1 · · ·αn of a multiset {a1, · · · , an} on a circle which maximizes
the risk function
∑n
i=1 |αi − αi−1|
q where α0 ≡ αn and q ≥ 1.
The dartboard problem has been studied for a while. Eiselt and Laporte [5] used a
branch-and-bound algorithm[1] to find optimal permutations for the dartboard problem on
{1, 2, . . . , 20} for q = 1 and q = 2, and they observed that the traditional dartboard score
arrangement is not optimal. Chao and Liang [2] studied the permutations of n distinct
numbers arranged on a circle or a line and showed the arrangements that maximize or
the electronic journal of combinatorics 14 (2007), #R47 1
10
33
31
8
6
37
35
4
240
391
3
36
38
57
32
34
9
11
28
30
13
15
24
26
17
19 21
22 20
18
25
23
16 14
29
27
12
Figure 2: A double layer dartboard
· · · · · · · · ·
· · · · · · · · ·
v3
w3
v2 w2
v1
w1
vn
wn
vn−1
wn−1
vn−2
wn−2
vn−3
wn−3
Figure 3: An arrangement for double layer dartboard
However, it is not clear whether there exist an efficient algorithm for the k-dartboard
problem (k > 2) when the input does not specify the numbers on each circle. We leave it
as an open question.
2 Preliminaries
The following lemma is very useful in our proof, which was proved in Curtis’ paper[4].
Lemma 1. [4] Let lmin, lmax, rmin, rmax, q be real numbers with q ≥ 1. If lmin ≤ lmax and
rmin ≤ rmax, then |lmax − rmin|
q + |lmin − rmax|
q ≥ |lmax − rmax|
q + |lmin − rmin|
q.
With lemma 1, Curtis[4] proved the following theorem:
Theorem 1. [4] For arranging n numbers a1 ≤ a2 ≤ · · · ≤ an on a single circle dartboard,
the permutation a1an−1a3an−3a5 · · ·an−4a4an−2a2an maximizes the risk function.
the electronic journal of combinatorics 14 (2007), #R47 3
Algorithm GreedyPartition({a1, · · · , a2n})
1. if n = 3 then return ({a1, a2n−2, a2n−1}, {a2, a3, a2n})
2. if n = 4 then return ({a1, a4, a2n−2, a2n−1}, {a2, a3, a2n−3, a2n})
3. (X ′, Y ′) =GreedyPartition({a3, · · · , a2n−2});
4. X ← Y ′ ∪ {a1, a2n−1}, Y ← X
′ ∪ {a2n, a2};
5. return (X, Y );
Figure 4: Our greedy algorithm
that once the partition (A1, · · · , Ak) of kn numbers is determined, the maximum possible
risk achieved by (A1, · · · , Ak) can be determined, so we can just focus on finding a partition
that yields the maximum risk.
3 Optimal arrangement for 2-dartboard problem
In this section, we show how to solve the 2-dartboard problem with a greedy method.
Consider a multiset {a1, · · · , a2n} with a1 ≤ · · · ≤ a2n. By theorem 2, we focus on
finding a maximum partition. But trying all possible
(
2n
n
)
partitions is inefficient. Here
we propose an efficient greedy method to obtain a maximum partition, as in figure 4.
Theorem 3. There is an efficient algorithm solving the 2-dartboard problem.
Proof. There are only
(
2
1
)
= 2 and
(
4
2
)
= 6 possible partitions when n = 1 and n = 2,
respectively, so we can find out the maximum partition efficiently by brute force if n ≤ 2.
When n ≥ 3, we claim that GreedyPartition algorithm gives a maximum partition.
The correctness of a greedy algorithm can be justified by checking the greedy choice
property and the property of optimal substructure. To prove the greedy choice property
of GreedyPartition, we need to show that there exists a maximum partition (X, Y )
with {a1, a2n−1} ⊆ X and {a2, a2n} ⊆ Y . To prove the optimal substructure property, we
need to show that there exists a maximum partition (X, Y ) such that (Y −{a2, a2n}, X−
{a1, a2n−1}) is also a maximum partition for the subproblem with instance {a3, · · · , a2n−2}.
The proof of correctness consists of 4 propositions. The greedy choice property is proved
by proposition 1 and 2 and the optimal substructure is proved by proposition 3 and 4.
Proposition 1. For n ≥ 3, there exists a maximum partition (X∗, Y ∗) such that a1 ∈ X
∗
and a2n ∈ Y
∗.
Proof. Let (X, Y ) be another maximum partition. Let X = {x1, · · · , xn} with x1 ≤ · · · ≤
xn and Y = {y1, · · · , yn} with y1 ≤ · · · ≤ yn. By theorem 2, (x1xn−1x3 · · ·xn−2x2xn, yny2
yn−2 · · · y3yn−1y1) is an optimal arrangement. Without loss of generality, we can assume
x1 = a1. Note that a2n can be either yn or xn. If yn = a2n, then we’re done. Thus we
assume xn = a2n.
Since x1 = a1 and xn = a2n, we have x1 ≤ y1 and xn ≥ yn. Note if x1 = y1 or xn = yn,
then (Y, X) satisfies the proposition. Hence, we consider x1 < y1 and xn > yn from now
the electronic journal of combinatorics 14 (2007), #R47 5
are not changed. Hence the only possibility that swapping may decrease the risk
is from the two pairs (xk, xn−k+2) and (yk, yn−k+2) which may have higher risk sum
than (xk, yn−k+2) and (yk, xn−k+2) do. However, since k = l, we have xk ≥ yk and
xn−k+2 > yn−k+2. By lemma 1, we have
|xk − xn−k+2|
q + |yk − yn−k+2|
q ≤ |xk − yn−k+2|
q + |yk − xn−k+2|
q .
Thus the risk function does not decrease after the swapping operation.
• k = r ≤ l: For k is odd, we swap xk−1, xn−k+3, xk−3, xn−k+5 · · · , x2, a2n with
yk−1, yn−k+3, yk−3, yn−k+5, · · · , y2, yn, respectively, as in figure 7. For k is even, we
swap xk−1, xn−k+3, xk−3, xn−k+5 · · · , xn−1, a1 with yk−1, yn−k+3, yk−3, yn−k+5, · · · , yn−1,
y1, respectively, as in figure 8.
a2n
x2
a1
xn−1
...
xn−k+2
xk
· · · · · ·
xn−k+1
xk−1
...
y1
yn−1
yn
y2
...
yk−1
yn−k+1
· · · · · ·
yk
yn−k+2
...
yn
y2
a1
xn−1
...
xn−k+2
xk
· · · · · ·
xn−k+1
yk−1
...
y1
yn−1
a2n
x2
...
xk−1
yn−k+1
· · · · · ·
yk
yn−k+2
...
Figure 7: The swapping operation when k = r and k is odd
a2n
x2
a1
xn−1
...
xk−1
xn−k+1
· · · · · ·
xk
xn−k+2
...
y1
yn−1
yn
y2
...
yn−k+2
yk
· · · · · ·
yn−k+1
yk−1
...
a2n
x2
y1
yn−1
...
yk−1
xn−k+1
· · · · · ·
xk
xn−k+2
...
a1
xn−1
yn
y2
...
yn−k+2
yk
· · · · · ·
yn−k+1
xk−1
...
Figure 8: The swapping operation when k = r and k is even
Similarly, the swapping operation puts a1 and a2n on different circles, and the only
possibility that swapping may decrease the risk is from the two pairs (xn−k+1, xk−1)
and (yn−k+1, yk−1) which may have higher risk sum than (xn−k+1, yk−1) and (yn−k+1,
xk−1) do. However, due to k = r, we have xn−k+1 ≤ yn−k+1 and xk−1 < yk−1. By
the electronic journal of combinatorics 14 (2007), #R47 7
proposition when n = 3. In this case, we can rotate the 2-by-2 block, which contains
a1, a2, a2n−1 and a2n, 180 degrees:
Before rotation After rotation
· · · xn−1 a1 a2n−1 a3 · · ·
· · · y2 a2n a2 a2n−2 · · ·
· · · xn−1 a2 a2n a3 · · ·
· · · y2 a2n−1 a1 a2n−2 · · ·
Since a1 ≤ a2 and a2n−2 ≥ xn−1, we have
|a1 − xn−1|
q + |a2 − a2n−2|
q ≤ |a1 − a2n−2|
q + |a2 − xn−1|
q .
Similarly, since a2n ≥ a2n−1 and a3 ≤ y2 we have
|a2n−1 − a3|
q + |a2n − y2|
q ≤ |a2n − a3|
q + |a2n−1 − y2|
q .
Therefore, the rotation operation does not decrease risk. It yields a maximum
partition as required.
• Case 2: “a3 ∈ X and a2n−2 ∈ X.” By theorem 2, we have x2 = a3 and xn−1 = a2n−2.
Moreover, we can assume that y2 > a3 and yn−1 < a2n−2, since if y2 = a3 or
yn−1 = a2n−2 then it reduces to case 1. Now we can swap a2n−1 with a2n as follows:
Before swapping After swapping
· · · a2n−2 a1 a2n−1 a3 · · ·
· · · y2 a2n a2 yn−1 · · ·
· · · a2n−2 a1 a2n a3 · · ·
· · · y2 a2n−1 a2 yn−1 · · ·
Since a2n−1 ≤ a2n and a3 < y2, we know the swapping operation does not decrease
risk. Since x2 = a3 < y2 and yn−1 < a2n−2 = xn−1, we can apply similar swapping
operations as in the proof of proposition 1 with k > 2. Depending on the values of
k and n, the adjustment will yield to one of the following arrangements:
Swapping upper-left with lower right Swapping upper-right with lower-left
· · · yn−1 a2 a2n a3 · · ·
· · · y2 a2n−1 a1 a2n−2 · · ·
· · · a2n−2 a1 a2n−1 y2 · · ·
· · · a3 a2n a2 yn−1 · · ·
However, both cases yield a maximum partition as required.
• Case 3: “a3 ∈ Y and a2n−2 ∈ Y .” In this case, we swap a1 and a2, and apply similar
operations as in proposition 1 to obtain an arrangement which yields a partition as
required. The analysis is analogous to case 2.
From the above, this completes the proof of this proposition. 2
Proposition 4. For n ≥ 4, there exists a maximum partition (X∗, Y ∗) such that a1, a4,
a2n−2, a2n−1 ∈ X
∗ and a2, a3, a2n−3, a2n ∈ Y
∗. Moreover, for n > 4, suppose (X, Y ) is
a maximum partition satisfying proposition 2 for the sub-instance {a3, · · · , a2n−2}, then
(Y ∪ {a1, a2n−1}, X ∪ {a2, a2n}) is a maximum partition.
the electronic journal of combinatorics 14 (2007), #R47 9
Acknowledgments
The authors would like to thank the anonymous referees for their helpful comments. The
work was supported in part by the National Science Council of Taiwan under contract
NSC 95-2221-E-009-034.
References
[1] G. Carpaneto, P. Toth, Some new branching and bounding criteria for the asymmetric
traveling salesman problem, Management Science, 26: 736-743, 1980.
[2] Chern-Ching Chao, Wen-Qi Liang, Arranging n distinct numbers on a line or a circle
to reach extreme total variations, European J. Combin., 13: 325-334, 1992.
[3] G.L. Cohen, E. Tonkes, Dartboard arrangements, Electron J. Combin., 8(2): R4,
2001.
[4] S.A. Curtis, Darts and hoopla board design, Information Processing Letters, 92:
53-56, 2004.
[5] H.A. Eiselt, G. Laporte, A combinatorial optimization problem arising in dartboard
design, J. Oper. Res. Soc., 42(2): 113-118, 1991.
[6] C. Papadimitriou and K. Steiglitz Combinatorial Optimization, algorithms and com-
plexity, Prentice-Hall Inc., 1982.
[7] K. Selkirk, Re-designing the dartboard, The Mathematical Gazette, 60(413): 171-
178, 1976.
[8] D. Singmaster, Arranging a dartboard, Bulletin of the Institute of Mathematics and
its Applications, 16: 93-97, 1980.
the electronic journal of combinatorics 14 (2007), #R47 11
maxi |xi−yi|. We say two permutations x and y are d-close
to each other under metric δ(·, ·) if δ(x,y) ≤ d. The identity
permutation Iλn in Sλn is (1, . . . , 1, . . . ,m, . . . ,m).
II. LOWER AND UPPER BOUNDS
Let F∞(λ, n, d) be the cardinality of the maximum
(λ, n, d)-FPA and V∞(λ, n, d) be the number of elements
in Sλn being d-close to the identity Iλn under ℓ∞-norm. In
this section, we give a Gilbert type lower bound and a
sphere packing upper bound of F∞(λ, n, d) by bounding
V∞(λ, n, d).
First, we show that any d-radius ball in Sλn under l∞-norm
has the same cardinality.
Claim 1. For any x = (x1, . . . , xn) ∈ Sλn , there are exactly
V∞(λ, n, d) y’s in Sλn such that l∞(x,y) ≤ d.
Proof: Since every i ∈ [m] appears exactly λ times in
x, there exists a permutation π ∈ S1n such that x = π ◦ Iλn .
As a consequence, we have that l∞(Iλn , z) = l∞(x, π ◦ z)
for any z ∈ Sλn . Let Z = {z : z ∈ Sλn , l∞(Iλn , z) ≤ d},
Y = {π ◦ z : z ∈ Z} and Y¯ = Sλn − Y . For any y ∈ Y ,
we have l∞(x,y) = l∞(Iλn , π−1 ◦ y) ≤ d, since π−1 ◦ y ∈
Z . While for y′ ∈ Y¯ , l∞(x,y′) = l∞(Iλn , π−1 ◦ y′) > d.
Therefore, only |Y | = |Z| = V∞(λ, n, d) permutations in Sλn
are d-close to x.
Theorem 1.∣∣Sλn∣∣
V∞(λ, n, d− 1)
≤ F∞(λ, n, d) ≤
∣∣Sλn∣∣
V∞(λ, n, ⌊
d−1
2 ⌋)
.
Proof: To prove the lower bound, we use the fol-
lowing algorithm to generate a (λ, n, d)-FPA with size ≥
|Sλn|
V∞(λ,n,d−1)
.
1) C ← ∅, D ← Sλn .
2) Add an arbitrary x ∈ D to C, then remove all
permutations that is (d− 1)-close to x from D.
3) If D 6= ∅ then repeat step 2, otherwise output C.
D has initially |Sλn | elements and each iteration of step 2
removes at most V∞(λ, n, d − 1), so we conclude |C| ≥
|Sλn|
V∞(λ,n,d−1)
.
Now we turn to the upper bound. Consider a (λ, n, d)-FPA
C∗ with the maximum cardinality. Any two ⌊d−12 ⌋-radius
balls centered at distinct permutations in C∗ do not have any
common permutation, since the minimum distance is d. In
other words, the ⌊d−12 ⌋-radius balls centered at permutations
in C∗ are all disjoint. We have |C∗| ≤ |Sλn|
V∞(λ,n,⌊
d−1
2
⌋)
.
It is clear that |Sλn | = n!(λ!)n/λ . It is already known that
V∞(1, n, d) equals to the permanent of some special matrix
[8]. In this paper, we generalize previous analysis to give
asymptotic bounds for Theorem 1. The permanent of an n×n
matrix A = (ai,j) is defined as
perA =
∑
π∈Sn
n∏
i=1
ai,πi .
Define a symmetric n × n matrix A(λ,n,d) =
(
a
(λ,n,d)
i,j
)
,
where a(λ,n,d)i,j = 1, if
∣∣⌈ iλ⌉ − ⌈ jλ⌉∣∣ ≤ d; else a(λ,n,d)i,j = 0.
Note that a permutation (x1, . . . , xn) is d-close to Iλn if
and only if a(λ,n,d)i,xi = 1 for every i ∈ [n]. Now we
consider A(λ,λm,d). Since the λ copies of a symbol are
considered identical while computing the distance and the
entries indexed from (ℓλ − λ + 1) to ℓλ of Iλλm represent
the same symbol for every ℓ ∈ [m]. It implies that row
(ℓλ− λ+ 1) through row ℓλ of A(λ,λm,d) are identical and
so are columns indexed from (ℓλ − λ + 1) to ℓλ for every
ℓ ∈ [m]. Thus, we have A(λ,λm,d) = A(1,m,d)⊗ 1λ where ⊗
is the operator of tensor product and 1λ is a λ × λ matrix
with all entries equal to 1. For example, take λ = 2, m = 5
and d = 2:
A(1,5,2) =


1 1 1 0 0
1 1 1 1 0
1 1 1 1 1
0 1 1 1 1
0 0 1 1 1

 ,12 =
(
1 1
1 1
)
A(2,10,2) =


1 1 1 1 1 1 0 0 0 0
1 1 1 1 1 1 0 0 0 0
1 1 1 1 1 1 1 1 0 0
1 1 1 1 1 1 1 1 0 0
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1
0 0 0 0 1 1 1 1 1 1
0 0 0 0 1 1 1 1 1 1


Let r(1,m,d)i be the row sum of A(1,m,d)’s i-th row. We have:
r
(1,m,d)
i =


d+ i if i ≤ d,
2d+ 1 if d < i ≤ m− d,
m− i+ 1 + d if i > m− d.
Then for i ∈ [m] and j ∈ [λ], the row sum of the
(iλ − λ + j)-th row of A(λ,λm,d) is λr(1,m,d)i , due to
A(λ,λm,d) = A(1,m,d) ⊗ 1λ. We first calculate V∞(λ, n, d)
by using perA(λ,n,d).
Lemma 1.
V∞(λ, n, d) =
perA(λ,n,d)
(λ!)n/λ
.
Proof:
perA(λ,n,d)
= |{x ∈ S1n : ∀i, a
(λ,n,d)
i,xi
= 1}|
= |{x ∈ S1n : maxi |⌈
i
λ⌉ − ⌈
xi
λ ⌉| ≤ d}|
= (λ!)n/λ|{y ∈ Sλn : maxi |⌈
i
λ⌉ − yi| ≤ d}|
= (λ!)n/λ|{y ∈ Sλn : l∞(I
λ
n ,y) ≤ d}|
= (λ!)n/λV∞(λ, n, d)
The first equality holds since A(λ,n,d) is a (0, 1)-matrix and
by the definition of permanent. We can convert x ∈ S1n into
y ∈ Sλn by setting yi = ⌈xiλ ⌉, and there are exactly (λ!)
n/λ
codewords in Cλn,k is at least ⌊n−kλ ⌋. Since every message is
encoded into a distinct codeword, we have Cλn,k = 2k.
Since Cλn,k is a (λ, n, ⌊n−kλ ⌋)-FPA, we let d = ⌊
n−k
λ ⌋ for
convenience.
B. Unique decoding algorithm
Unique decoding algorithms for classic error correcting
codes are usually much more complicated than their encoding
algorithms. While, our proposed decoding algorithm Uλn,k
(see Figure 2) remains simple.
Algorithm Uλn,k
Input: (x1, . . . , xn) ∈ Sλn
Output: (m1, . . . ,mk) ∈ Zk2
max← n; min← 1;
for i← 1 to k do
if |xi − ⌈maxλ ⌉| < |xi − ⌈
min
λ ⌉|
then {mi ← 1; max← max− 1;}
else {mi ← 0; min← min+ 1;}
Output (m1, . . . ,mk).
Fig. 2: Uλn,k decodes words in Sλn to messages in Zk2 .
The running time of Uλn,k is clearly O(k), even faster than
the encoding algorithm. We show its correctness as follows.
Theorem 4. Given a permutation x = (x1, . . . , xn) which
is d−12 -close to E
λ
n,k(m) for some m ∈ Zk2 , algorithm Uλn,k
outputs m correctly.
Proof: By contradiction, assume Uλn,k outputs mˆ =
(mˆ1, · · · , mˆk) 6= m. Let Eλn,k(m) = (y1, . . . , yn), r be the
smallest index such that mr 6= mˆr and z be the number of
zeroes among m1, . . . ,mr−1. At the beginning of the r-th
iteration, max = n− r+1+ z and min = 1+ z because for
every i < r, mi = mˆi. Without loss of generality, assume
1 = mr 6= mˆr = 0. Note that yr is set to ⌈maxλ ⌉=⌈
n−r+1+z
λ ⌉
by Eλn,k. While mˆr is decoded to 0 by Uλn,k, we have
|xr − ⌈
max
λ ⌉| ≥ |xr − ⌈
min
λ ⌉|. Thus,
l∞(x, E
λ
n,k(m)) ≥ |xr − yr| = |xr − ⌈
max
λ ⌉|
≥ 12
(
|xr − ⌈
max
λ ⌉|+ |xr − ⌈
min
λ ⌉|
)
≥ 12
(
⌈maxλ ⌉ − ⌈
min
λ ⌉
)
= 12
(
⌈n−r+1+zλ ⌉ − ⌈
1+z
λ ⌉
)
≥ d2 .
The last inequality is true, since we know ⌈n−r+1+zλ ⌉ −
⌈ 1+zλ ⌉ ≥
⌊
n−k
λ
⌋
= d from the proof of Theorem 3. This
contradicts that x is d−12 -close to E
λ
n,k(m).
C. Locally decoding algorithm
Next we show a locally decoding algorithm Lλn,k, see
Figure 3, which is a probabilistic algorithm. We discuss its
efficiency and error probability in this subsection. We prove
that it reads at most λ + 1 entries of the received word in
Lemma 4, hence its running time is O(λ). It has a chance
to output wrongly, but we show that the error probability
is small in Theorem 5. Furthermore, Lλn,k always outputs
correct message bit when it was given a codeword as input,
see Corollary 1.
Algorithm Lλn,k
Input: i ∈ [n], (x1, . . . , xn) ∈ Sλn
Output: mi, the i-th message bit
J ← {i+ 1, . . . , n};
do
Uniformly and randomly pick j ∈ J ;
if xi > xj then output 1;
if xi < xj then output 0;
J ← J − {j};
loop;
Fig. 3: Lλn,k decodes one bit by reading at most λ+1 symbols.
Lemma 4. Given a permutation x = (x1, . . . , xn) ∈ Sλn,k
and an index i ∈ [k], Lλn,k terminates within λ iterations.
Proof: By contradiction, assume Lλn,k does not output
before the end of the λ-th iteration. For ℓ ≤ λ, let jℓ be
the index picked in the ℓ-th iteration. For every ℓ ≤ λ, we
have xi = xjℓ , otherwise Lλn,k outputs at the ℓ-th iteration.
Therefore, there are at least λ+1 entries of x equal to xi. It
implies x /∈ Sλn,k, a contradiction. There is some xjℓ 6= xi,
and Lλn,k outputs in the ℓ-th iteration.
Theorem 5. Given a permutation x = (x1, . . . , xn) δ-close
to a codeword Eλn,k(m) = (y1, . . . , yn) ∈ Sλn,k for some m
and an index i ∈ [k], Lλn,k outputs mi with probability at
least 1− 2δ+1d at its first iteration.
Proof: Without loss of generality, we assume mi =
0, yi = t and let u be the maximum number among
yi+1, . . . , yn, i.e., at the start of the i-th iteration min = t and
max = u while encoding. Assume there are γ numbers equal
to t among y1, . . . , yi−1, and there are γ′ numbers equal to
u among yi+1, . . . , yn. According to the encoding algorithm,
we have
{yi+1, . . . , yn} = {
λ−γ−1︷ ︸︸ ︷
t, . . . , t,
λ︷ ︸︸ ︷
t+ 1, . . . , t+ 1, . . . ,
γ′︷ ︸︸ ︷
u, . . . , u}
Since l∞(x, Eλn,k(m)) ≤ δ, we have |xj − yj | ≤ δ and
|xi − yi| ≤ δ. The probability that Lλn,k does not output mi
at the first iteration is:
Pr[xi ≥ xj ] ≤ Pr[yi + δ ≥ xj ]
≤ Pr[yi + δ ≥ yj − δ]
= Pr[yi + 2δ ≥ yj].
There are at most 2δλ+ λ− γ − 1 possible yj’s less than or
equal to yi + 2δ. Thus,
Pr[xi ≥ xj ] ≤
(2δ + 1)λ− γ − 1
n− i
≤
2δλ+ λ
dλ
=
2δ + 1
d
.
Therefore, the probability that Lλn,k outputs mi correctly at
the first iteration is at least 1− 2δ+1d .
行政院國家科學委員會補助國內研究生出席國際學術會議報告 
 
報告人姓名 謝旻錚 報告日期 98 年 7 月 5日 
系所及年級 資工所博士五年級 核定文號 98 年 月 日 
  ０9D085 
連絡電話 03-5712121-56677 電子信箱 mzhsieh@csie.nctu.edu.tw
會議期間 98/06/28-98/07/03 會議地點 Seoul, Korea 
會議名稱 2009 IEEE International Symposium on Information Theory 
發表論文題
目 
Decoding Frequency Permutation Arrays under Infinite Norm 
 
Cryptography and security 相關，並與現在盛行的 Flash memory 儲存技術有密切關
聯，因此這次發表，許多與會學者都是我感興趣的對象，也因此在開幕的接待會上與
相關學者攀談，認識了進行相關研究挪威籍 Torleiv Klove 教授，在大會晚宴上與荷
蘭籍歐洲專利局的特派員 Lothar 同桌吃飯更是學習到許多關於申請專利的知識。在我
口頭發表我的論文之後，有外國學者前來攀談並恭維我的，在我的報告結束後我也向
先前報告一篇我相當感興趣的論文作者聊聊，最後一天返國等待巴士時，甚至有我報
告時的聽眾，來自芬蘭的數學家 Tero 向我寒喧，當他們都說出我的口頭報告深受好評，
我感到相當的興奮。 
 
此次的 IEEE International Symposium on Information Theory 雖在鄰近台灣的韓國
所舉辦，但有註冊的台灣人也僅有十餘人，在這個頂尖資訊理論國際會議上不算太少，
卻仍然遙遙不及美國日本等科技強國，因此我覺得我們仍有許多需要努力充實之處。
資訊理論在資通產業上屬於基礎科學理論，不論是電機通信或是資訊工程系所都相當
的關聯性。而會議舉行的所在地韓國，也是在資訊通訊產業中具有舉足輕重地位的國
家，韓國所布建的 CDMA 行動電話系統，能自成一格，並且外銷到海外，與歐洲的
GSM/WCDMA 分庭抗哩，實在是令人佩服。反觀中國大陸的 TS-CDMA 至今仍無太大起色，
而台灣還缺乏國際地位。希望資訊理論能夠更深植在我們的大學教育中，能夠在未來
培養出更多具有優秀基礎科學認知的學生與工程師。 
 
總體來說，能夠參與這次如此重要的國際會議個人非常的興奮，能夠跟許多國際知名
學者交流以及吸收最新的理論與技術，實在是不可多得的機會。也趁此時認識了一些
相關領域的各國研究生，拓展未來研究上所需要的人脈。更進一步的，也獲取了跟這
些優秀學者以及研究生共同進行研究的機會，對於此點我真是在開心也不過了。 
 
三、建議 
 
以國力交通大學研發處的博士生出國參與國際會議的補助，IEEE International 
Symposium on Information Theory 被電信研究所列為頂尖國際會議第二名，作為一個
電信所的博士生能夠受到註冊費上的全額補助，但作為一個資訊所的博士生卻得受註
