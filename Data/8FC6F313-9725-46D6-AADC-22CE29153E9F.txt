iii 
目錄 
一、中英文摘要 ............................................................................................................ i 
二、報告內容 ............................................................................................................... 1 
（一）、前言............................................................................................................ 1 
（二）、研究目的.................................................................................................... 2 
（三）、文獻探討.................................................................................................... 2 
（四）、研究方法.................................................................................................... 3 
（五）、結果與討論.............................................................................................. 11 
三、參考文獻 ............................................................................................................. 12 
四、計畫成果自評 ..................................................................................................... 15 
Appendix I：Optimal Edge Ranking of Complete Bipartite Graphs in Polynomial Time, 
Discussiones Mathematicae Graph Theory 26 (2006) pp. 149−159.  
Appendix II：Optimal Vertex Ranking of Block Graphs (Paper to be submitted). 
 
 
 
 
 
 
2 
NP-hard for general graphs [22].  
Extensive work has been done in finding 
optimal edge rankings of trees [9, 36], 
now there exists a linear-time algorithm 
for trees [23]. Bodlaender et al. derived 
a formula to compute the edge ranking- 
number of a complete graph [3]. Little 
has been known about special classes of 
graphs for which the problem can be 
solved in polynomial time except trees 
and complete graphs.   
（二）、研究目的 
For any positive integer n, the 
complete graph of n vertices, denoted by 
Kn, is that graph with n vertices every 
two of which are adjacent.  A bipartite 
graph is one whose vertices can be 
partitioned into two (disjoint) nonempty 
sets V1 and V2, called bipartition sets, in 
such a way that every edge joins a 
vertex in V1 and a vertex in V2.  In 
particular, there are no edges within V1 
nor within V2.  A complete bipartite 
graph is a bipartite graph in which every 
vertex in V1 is adjacent to all vertices in 
V2.  The complete bipartite graph on 
bipartition sets of m vertices and n 
vertices, respectively, is denoted by Km,n.  
Note that Km,n = Kn,m. Properties and 
optimization problems of complete 
bipartite graphs have been studied in [8, 
12, 13, 14, 17]. Bodlaender et al. applied 
the concept of the edge- separator tree to 
derive a formula for complete graph Kn 
as follows [3]: For every positive integer 
n, χe(Kn) = 3
)(2 ngn +
, where g(1) = −1, 
g(2n) = g(n), and g(2n+1) = g(n+1)+n.  
In the first part of this report, we will 
design a polynomial-time algorithm to 
solve the edge ranking problem on 
complete bipartite graphs. 
A vertex v of a connected graph G 
is called a cut vertex if the removal of v 
from G disconnects G. A block of a 
connected graph is a maximal connected 
subgraph without any cut vertex.  Note 
that a vertex is a cut vertex if and only if 
it is the intersection of two or more 
blocks [7]. A block graph is a connected 
graph whose blocks are complete graphs.  
Note that the line graph of a tree is a 
block graph, but a block graph is not 
necessary to be the line graph of a tree, 
i.e., the class of block graphs contains 
the class of trees.  Block graphs have 
been studied by many researchers [1, 4, 
5, 6, 7, 15, 16, 20, 27, 28, 32, 34]. 
The algorithm for ranking edges of 
a graph can be used to rank the vertices 
of the line graph of this graph.  The 
line graph of a tree is a block graph but 
the reverse is not true. Therefore, the 
algorithm for the edge ranking problem 
on trees can not be used for solving the 
vertex ranking problem on block graphs.  
In the second part of this report, we will 
design an O(|V|2)-time algorithm to 
solve the vertex ranking problem on 
block graphs. 
（三）、文獻探討 
The vertex ranking problem is 
NP-hard for general graphs [26, 29] and 
even for cobipartite and bipartite graphs 
4 
G = (V, E), we assign a rooted tree T(ϕ) 
to it by an inductive construction as 
follows: 
(1) If there exists no label occurs more 
than once in G, then T(ϕ) consists of a 
single node r (called root) and the edge 
set of G is assigned to r. 
(2) Otherwise, let i be the largest label 
assigned to more than one edge by ϕ.  
Then, {i+1, i+2, ..., t} has to be an edge 
separator R of G.  We create a root r of 
T(ϕ) and assign R to r.  (The induced 
subgraph of G corresponding to the 
subtree of T(ϕ) rooted at r will be G 
itself.) 
Assuming that an edge-separator tree 
Ti(ϕ) with root ri has already been 
defined for each connected component 
Gi of the graph G[E\R], the children of r 
in T(ϕ) will be the nodes ri and the 
subtree of T(ϕ) rooted at ri will be Ti(ϕ). 
The rooted tree T(ϕ) is said to be an 
edge-separator tree of G.  The height 
of T(ϕ) is defined to be the largest 
number of edges assigned to nodes of 
T(ϕ) on a path from a leaf to the root.  
An edge-separator tree T(ϕ) is called the 
minimum-height edge-separator tree of 
G if its height is minimum among all 
edge-separator trees of G. 
Notice that all edges of G assigned 
to nodes of T(ϕ) on a path from a leaf to 
the root have different labels, and ϕ is an 
optimal edge ranking of G if and only if 
T(ϕ) is a minimum-height edge- 
separator tree of G. 
For every edge t-ranking of a graph 
G, the following property holds: if i is 
the largest label occurring more than 
once, then the edges with labels i+1, 
i+2, ..., t form an edge separator of G. 
Moreover, making an appropriate 
relabeling of these labels i+1, i+2, ..., t 
we get a new edge t-ranking of G with 
the property that there is a label j > i 
such that all edges with labels j, j+1, ..., t 
form an edge separator of G which is 
minimal under inclusion. Therefore, we 
can only consider the minimal edge 
separators to construct the edge- 
separator tree. 
By definition of edge ranking, two 
adjacent edges must be labeled by the 
different labels. Hence the following 
lemma is clearly correct: 
Lemma 1. χe(K1,n) = n, for every 
positive integer n. 
In the following, assume Km,n 
satisfies that m > 1 and n > 1.  We then 
have the following theorem: (The proof 
of the theorem is given in Appendix I) 
Theorem 1. Assume that Km,n is a 
complete bipartite graph with m > 1 and 
n > 1.  Then, χe(Km,n) = 
nnmm <≤<≤ 11 1;1min {m1n2 + m2n1 + 
max{χe(Km1,n1), χe(Km2,n2)}}, where m1+ 
m2 = m, and n1+n2 = n. 
Definition 2: Let Km,n be a complete 
bipartite graph with that m > 1 and n > 1.  
Let R be an edge separator of Km,n such 
that it separates Km,n into Kp,q and Km-p,n-q, 
|R| = p(n-q)+q(m-p), and χe(Km,n) = |R|+ 
max{χe(Kp,q), χe(Km-p,n-q)}.  We call p 
and q the separator points of Km,n. 
Following Theorem 1, we can 
6 
Following the above observations, 
we construct a tree-like hierarchy, called 
block tree, from a block graph.  Then 
we can take the advantages of the 
ranking algorithms for trees while 
solving the vertex ranking problem on 
block graphs. 
Definition 3: Let G = (V, E) be a block 
graph containing k blocks B1, B2, ..., Bk.  
The representation tree T* = (V*, E*) of 
G is constructed as follows:  Create k 
new nodes B1, B2, ..., Bk standing for 
these k blocks in G.  Let BT = {B1, 
B2, ..., Bk } and let V* = V ∪ BT.  The 
edge set E* of T* is defined as {(vi, Bj) | 
vi ∈ Bj in G for 1 ≤ i ≤ |V| and 1 ≤ j ≤ k}.  
Clearly, T* is a tree. 
For instance, given a block graph G 
shown in Figure 2(b), the representation 
tree T* of G is shown in Figure 3(a). 
B
1
v2
v3 v4
v5
B
2
B
3
B
4
B
5
v1
v6 v12
v7 v9v8
B
6
v10 v11
: block node
: cut vertex
: end vertex
B
7
(b)(a)
v1
v2
v3
v4
v5v6
v7 v8 v9 v10
v11
v12
B
1
B
2
B
3
B
4 B5 B6
B
7
 
Figure 3: (a) A representation tree 
constructed from a block graph shown in 
Figure 2(b), and (b) a block tree TB with 
root B1 for (a). 
When picking an arbitrary block 
node B of T* as the root, we get a rooted 
tree with root B. This rooted tree, 
denoted by TB = (V*, E*), is called the 
block tree corresponding to block graph 
G.  Figure 3(b) depicts the block tree of 
the block graph shown in Figure 2(b).  
Note that rooting a representation tree 
does not change the definition of vertex 
ranking, but it suggests a natural way to 
decompose the computation.  On the 
other hand, given a block graph, the 
block tree can be constructed in 
O(|V|+|E|) time by the depth first search 
[1]. 
We call an element of V* a node of 
block tree TB in general. The element of 
V* is called a block node of block tree TB 
if it is in BT; that is, it is not a vertex of 
V. A node is called an end vertex in TB if 
it is in V and is not a cut vertex in G. 
The remnants of nodes in TB are called 
cut vertices.  Figure 3(b) also reveals 
the types of nodes in TB. 
In this part, we will use the rooted 
block tree representation of a block 
graph to investigate the vertex ranking 
problem. In the rest of the part, assume 
that G = (V, E) is a block graph, TB is a 
block tree constructed from G, and B is 
the root of TB. 
The subtree of TB rooted at u is 
denoted by Tu, where u is either a cut 
vertex or a block node in TB. Let G[Tu] 
denote the subgraph of G induced by the 
set of vertices of V which are vertices in 
the subtree Tu of TB. For instance, G[TB4] 
= ({v7,v8}, {(v7,v8)}) and G[Tv1] = 
({v1,v5,v6}, {(v1,v5),(v1,v6)}) in Figure 
3(b). 
Let ϕ be a vertex ranking of a block 
tree TB. The label of a vertex v ∈ V is 
denoted by ϕ(v). A vertex v of G[TB] is 
said to be visible if all the labels on the 
path from v to B are smaller than or 
equal to the label of v. Take an example, 
all vertices incident to B are visible and 
8 
integers. Then, L1 p L2 if and only if 
there exists an integer i such that (a) aj = 
bj for all 1 ≤ j < i if i > 1, and (b) either 
ai < bi or p < i ≤ q. We write L1p L2 if L1 
= L2 or L1 p L2. For instance, {5,4,3,1} p 
{5,4,3,2}, {5,4,3,1} p  {5,4,3,1}, and 
{4,3} p {5,4,3,1}. A vertex ranking ϕ of 
a block tree TB is called critical if 
LB(ϕ)p LB(ϕ') for all rankings ϕ' of TB. A 
critical vertex ranking is an optimal 
vertex ranking, but the reverse may not 
be true.  All critical vertex rankings of 
TB have the same set of visible labels.  
The critical list of visible labels of TB, 
denoted by L*(TB), is the set of visible 
labels of a critical vertex ranking of TB. 
For a subtree Tu of TB rooted at u, a 
vertex ranking ϕ is also said to be 
critical if Lu(ϕ)pLu(ϕ') for all rankings 
ϕ' of Tu, where u might be a cut vertex 
or a block node in Tb.  Denoted by 
L*(Tu) the critical list of visible labels of 
Tu which is the set of visible labels of a 
critical vertex ranking of Tu. 
P. de la Torre et al. [9] and Zhou et 
al. [35] introduced the concept of 
supercritical ranking and subcritical 
ranking.  In this part we adopt the same 
notation but with different meanings.  
A vertex ranking ϕ of TB is supercritical 
if the restriction ϕ|TB is critical for every 
block node B of the block tree TB. A 
vertex ranking ϕ of TB is said to be 
subcritical if the restriction ϕ|TB is 
critical for every block node B and B ≠ B.  
Note that B is the root of TB.  The list 
of labels in a supercritical vertex ranking 
ϕ of a subtree Tu of TB is called the 
supercritical list of Tu, denoted by Ls(Tu), 
where u might be a vertex in G or a 
block node of TB. 
By the above definitions, a vertex 
ranking ϕ of TB is supercritical if and 
only if ϕ is subcritical and critical.  
And, a vertex ranking ϕ of Tv is also 
supercritical if the restriction ϕ|TB is 
supercritical for every block node B, 
where v is a vertex in G and B is a child 
of v in TB, and Lv(ϕ) is critical. 
It follows from the above 
definitions that every block tree has a 
supercritical ranking because this is 
simply an optimal ranking that has the 
lexicographically least supercritical list 
at the root. However, it does not follow 
that every block subtree has a 
supercritical vertex ranking. It is 
plausible that to obtain a list-optimal 
vertex ranking at the root, some subtree 
may require a non-optimal vertex 
ranking. In this part, we will prove that 
every block subtree does in fact have a 
supercritical vertex ranking. 
We briefly describe our strategy 
using a bottom-up approach to compute 
an optimal vertex ranking of TB as 
follows: 
1. For each end vertex v in TB, we can 
construct its critical vertex ranking 
and the critical list L*(Tv) = {1}. 
2. For each block node B in TB, assume 
that vertices v1, v2, ..., vk are the 
children of B in TB. By giving only 
vertices v1, v2, ..., vk new ranks, a 
supercritical (optimal) vertex 
ranking and the supercritical list 
10 
L = (p1, p2, ..., pk) is said to be a valid 
labeling if, for all branches i, the 
following statements hold: (1) pi ≥ li; (2) 
pi ∉ Ĺi; where Ĺi ={l∈Li | l>pi}, and (3) 
(Ĺi ∪ {pi}) ∩ (Ĺj ∪ {pj}) = ∅, for all 
branches i ≠ j. 
It is easy to verify that a valid 
labeling forms a vertex ranking of TB 
and is a subcritical ranking of TB. In the 
remainder of the part, we focus on 
solving the following labeling problem: 
Definition 6:  (Labeling Problem) 
Input: A block node B with children v1, 
v2, ..., vk and their associated critical lists 
L1, L2, ..., Lk corresponding to the vertex 
rankings ϕ1, ϕ2, ..., ϕk of Tv1, Tv2, ..., Tvk, 
respectively. 
Output: A valid labeling Z = (z1, z2, ..., zk) 
of VB that is optimal at B and Ls(TB) of 
TB, where vi is labeled by rank zi for 1 ≤ 
i ≤ k. 
To identify a labeling, we usually 
sort a labeling by the order of its labels 
(ranks) and not by vertex names. For 
convenience, we use zk to denote the 
largest label among the labeling on VB 
and z1 to denote the smallest label. This 
means that vi is the branch received the 
i-th smallest label.   
We then define the greedy-cover 
labeling given in [9] as follows: 
Definition 7: (gc labeling) Let L = (p1, 
p2, ..., pk) be a valid labeling of VB. A 
branch i is said to satisfy the 
greedy-cover (abbreviated as gc) 
property if for all branches j with pj < pi, 
Lj|pi p Li|pi, where Li|x = {l | l ∈ Li and l ≤ 
x}. L is said to be a gc labeling if every 
branch satisfies the gc property. 
The following lemma shows that 
there is always an optimal labeling of VB 
that is also gc labeling, but the reverse 
may not be true: (The poof of the lemma 
will be given in Appendix II) 
Lemma 4. Let L = (p1, p2, ..., pk) be a 
valid labeling of VB such that p1 < p2 < ... 
< pk.  Then, there is a valid gc labeling 
whose largest label is also pk.  
Moreover, if L is optimal, then the 
corresponding gc labeling can be made 
optimal too. 
Corollary 1. There is always an optimal 
labeling of VB that is also gc labeling.  
Based on the above corollary, we 
can restrict our search for labelings to gc 
labelings. The following lemma tells us 
which gc labeling we are searching for. 
(The proof of the lemma will be given in 
Appendix II) 
Lemma 5.  Among all valid gc 
labelings, the labeling that has the 
lexicographically smallest list of labels 
sorted from large to small is optimal.  
Based on Lemma 5, we can search 
for a gc labeling with a 
lexicographically minimum label list.  
The good news is that given a fixed 
label list, there is at most one gc labeling 
using that list and it can be found in 
polynomial time.  The bad news is that 
there appear, at first glance, to be 
exponentially many label lists to 
consider.  We need a search strategy to 
narrow down the exponential search 
space in polynomial time. Our strategies 
12 
三、參考文獻 
[1] A.V. Aho, J.E. Hopcroft, and J.D. Ullman, The design and analysis of computer 
algorithms, Addison-Wesley, Reading, MA, 1974. 
[2] B. Aspvall and P. Heggernes, Finding minimum height elimination trees for 
interval graphs in polynomial time, BIT 34 (1994) 484−509. 
[3] H.L. Bodlaender, J.S. Deogun, K. Jansen, T. Kloks, D. Kratsch, H. Müller, and Z. 
Tuza, Rankings of graphs, SIAM J. Discrete Math. 11 (1998) 168−181. 
[4] G.J. Chang, F.K. Hwang, and Y.C. Yao, Localizing combinatorial properties for 
partitions on block graphs, J. Combin. Optim. 2 (1999) 429−441. 
[5] G.J. Chang, Total domination in block graphs, Oper. Res. Lett. 8 (1989) 53−57. 
[6] G.J. Chang and G.L. Nemhauser, R-domination on block graphs, Oper. Res. Lett. 
1 (1982) 214−218. 
[7] M.S. Chang and J.J. Yang, Disjoint path on some classes of graphs, Master thesis, 
Department of Computer Science and Information Engineering, National Chung 
Cheng University, Taiwan, R.O.C., 1994. 
[8] C.C. Chou, C.M. Fu, and W.C. Huang, Decomposition of Km, n into short cycles, 
Discrete Math. 197/198 (1999) 195−203. 
[9] P. De La Torre, R. Greenlaw, and A.A. Schäffer, Optimal edge ranking of trees in 
polynomial time, Algorithmica 13 (1995) 592−618. 
[10] J.S. Deogun, T. Kloks, D. Kratsch, and H. Müller, On vertex ranking for 
permutation and other graphs, Lecture Notes in Computer Science 775, 
Springer-Verlag, Berlin, 1994, pp. 747−758. 
[11] J.S. Deogun, T. Kloks, D. Kratsch, and H. Müller, On vertex ranking for 
trapezoid, circular-arc and other graphs, Discrete Appl. Math. 98 (1999) 39−63. 
[12] H. Enomoto, T. Nakamigawa, and K. Ota, On the pagenumber of complete 
bipartite graphs. J. Combin. Theory Ser. B 71 (1997) 111−120. 
[13] P.E. Haxell, Partitioning complete bipartite graphs by monochromatic cycles, J. 
Combin. Theory Ser. B 69 (1997) 210−218. 
[14] A.J. Hoffman, On the line graph of the complete bipartite graph, Ann. Math. 
Statist. 34 (1964) 883−885. 
[15] J.Y. Hsiao, C.Y. Tang, R.S. Chang, and R.C.T. Lee, Single step searching in 
weighted block graphs, Inform. Sci. 81 (1994) 1−29. 
[16] L.T.Q. Hung, M.M. Sysło, M.L. Weaver, and D.B. West, Bandwidth and density 
for block graphs, Discrete Math. 189 (1998) 163−176. 
[17] A.A. Ivanov, R.A. Liebler, T. Penttila, and C.E. Praeger, Antipodal 
distance-transitive covers of complete bipartite graphs, Europ. J. Combinatorics 
14 
Sci. 225 (1999) 163−169. 
[35] X. Zhou, Md. Abul Kashem, and T. Nishizeki, Generalized edge-rankings of 
trees, IEICE Trans. Fundamentals, Special Section on Discrete Mathematics and 
its Applications E81-A, No.2 (1998) 310−320. 
[36] X. Zhou and T. Nishizeki, Finding optimal edge rankings of trees, in: Proc. 6th 
Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), 1995, pp. 
122−131.  A correct algorithm was given in “Advances in Computing 
Techniques, Algorithms, Databases and Parallel Processing, World Scientific, pp. 
23−35”. 
[37] J.S. Deogun and Y. Peng, Edge ranking of trees, Congr. Numer. 79 (1990) 
19−28. 
 
 
 
16 
 
Appendix I： Optimal Edge Ranking of Complete Bipartite Graphs in 
Polynomial Time, Discussiones Mathematicae Graph 
Theory 26 (2006) pp. 149−159. 





17 
 
Appendix II： Optimal Vertex Ranking of Block Graphs (Paper to be 
submitted). 
 
 
 
 
 
 
same label i contain an intermediate edge with label j > i. The vertex ranking problem is
equivalent to the problem of finding the minimum-height elimination tree [5][7] of a graph.
And the edge ranking problem is equivalent to the problem of finding the minimum-height
edge-separator tree [16][25] of a graph. These two ranking problems have received much
attention because of the following number of applications. The vertex ranking problem has
applications in VLSI layout and in scheduling the parallel assembly of a complex multi-
part product from its components [10][20][25]. For computing Cholesky factorizations of
matrices in parallel, the vertex ranking problem plays an important role [7][17]. Finding
an optimal edge ranking has an interesting application to scheduling the assembly steps
in manufacturing a complex multi-part product [11][20].
The vertex ranking problem is NP-hard for general graphs [19][21] and even for cobipar-
tite and bipartite graphs [3]. However, polynomial-time algorithms exist for cographs [24],
AT-free graphs [13], trapezoid graphs, permutation graphs, interval graphs and circular-
arc graphs [8]. The edge ranking problem is NP-hard in general [14].
With respect to trees, A.V. Iyer et al. [10] proposed an O(n log n)-time algorithm
to solve the vertex ranking problem. And Scha¨ffer [23] presented an O(n) algorithm for
solving the same problem on trees. In finding edge ranking of trees, P. de la Torre et
al. proposed the first polynomial-time algorithm which is bounded in time O(n3 log n)
[5]. There were some other papers in the literature on developing faster algorithms for
the edge ranking problem on trees, though erroneous they are [6][28], culminating in the
O(n2 log∆) time algorithm of Zhou et al. [27], where ∆ is the maximum degree of the
tree. Recently, Lam and Yue [15] presented a linear algorithm to solve the edge ranking
problem of trees using a different approach. Hence, both the vertex ranking and edge
ranking problems of trees can be solved in O(n) time now.
In this paper, we present two algorithms for solving the vertex ranking problem in
block graphs. Our ideas was inspired by the algorithms given by Zhou et al. [27] and Lam
et al. [15] for edge ranking of trees and given by Scha¨ffer [23] for vertex ranking of trees.
Note that the line graph of a tree is a block graph, but the reverse is not true, i.e., the
class of block graphs is the super class of trees. Hence the algorithms for the edge ranking
problem of trees can not be directly applied to solve the vertex ranking problem of block
graphs.
The remainder of this paper is organized as follows. Section 2 gives some basic defi-
nitions and notation. In Section 3, we present an O(n2 log∆) time algorithm to solve the
2
the following two subsection, we will define the block tree and the critical list of a block
graph. These two structures are fundamentals and important for deriving our efficient
algorithms.
2.1 The Block Tree
Let G = (V,E) be a block graph containing κ blocks B1, B2, · · · , Bκ. We construct a new
graph GT = (VT , ET ) from G as follows: Create κ new nodes B1, B2, · · · , Bκ standing for
these κ blocks in G. Let BT = {B1, B2, · · · , Bκ}. Then, VT = V ∪ BT . The edge set ET
of GT is defined as {(vı, B) | vı ∈ B in G for 1 ≤ ı ≤ |V | and 1 ≤  ≤ κ}. Figure 2(a)
depicts GT constructed from Figure 1(b). Obviously, GT is a tree.
When we pick an arbitrary block node B of GT as the root, we get a rooted tree with
root B. This rooted tree, denoted by TB = (VT , ET ), is called the block tree corresponding
to block graph G. Figure 2(b) shows the block tree of the block graph given in Figure
1(b). Note that rooting a block tree does not change the definition of vertex ranking, but
it suggests a natural way to decompose the computation. On the other hand, given a
block graph with m edges and n vertices, the block tree can be constructed in O(m+ n)
time by the depth first search [1].
We call an element of VT a node of block tree TB in general. The element of VT is
called a block node of block tree TB if it is in BT ; that is, it is not a vertex of V . A node
is called an end vertex in TB if it is in V and is not a cut vertex in G. The remnants of
nodes in TB are called cut vertices. Figure 2(b) illustrates the types of nodes in TB. Note
that we only rank the cut vertices and end vertices of TB for the vertex ranking problem.
The subtree of TB rooted at υ is denoted by Tυ, where υ is either a cut vertex or a block
node in TB. Let G[Tυ] denote the subgraph of G = (V,E) induced by the set of vertices of
V which are vertices in the subtree Tυ of TB. For instance, G[TB4 ] = ({v7, v8}, {(v7, v8)})
and G[Tv1 ] = ({v1, v5, v6}, {(v1, v5), (v1, v6)}) in Figure 2(b).
Suppose that block node B in TB has k children v1, v2, · · · , vk. Then we denote TB =
{B}+Tv1+Tv2+· · ·+Tvk+{(vi, B) | 1 ≤ i ≤ k}. On the other hand, suppose that cut vertex
v in TB has d children B1, B2, · · · , Bd. Then, we denote Tv = {v}+TB1 +TB2 + · · ·+TBd+
{(v,Bi) | 1 ≤ i ≤ d}. For example, TB1 = Tv1+Tv2+Tv3+Tv4+{B1}+{(B1, vi)|1 ≤ i ≤ 4}
and Tv3 = TB5 + TB6 + TB7 + {v3}+ {(v3, Bi)|5 ≤ i ≤ 7} in Figure 2(b).
4
For a vertex ranking ϕ of G and a subgraph G′ of G, we denote by ϕ|G′ a restriction
of ϕ to V (G′). Let ϕ′ = ϕ|G′ , then ϕ
′(v) = ϕ(v) for v ∈ V (G′).
Then, the following lemma can be proved easily by definitions.
Lemma 2.1. A vertex labeling ϕ of a block graph G[TB] is a vertex ranking of G[TB] if
and only if
(a)ϕ|G[Tv ] is a vertex ranking of G[Tv] for every child v of the root B of TB; and
(b)no more than one vertex of the same rank are visible from B under ϕ.
By Lemma 2.1, it is easy to verify that ϕ is a vertex ranking of block graph G if and
only if ϕ is a vertex ranking of block tree TB corresponding to G. Thus, in the remainder
of this paper, we focus on finding an optimal vertex ranking on block tree TB constructed
from the input block graph G. Note that we only rank the vertices except block nodes in
block tree TB and the paths connecting two distinct vertices can pass through some block
nodes. For example, the path in Figure 3(b) from v1 to v7 passes through block nodes B1
and B4. Intuitively, we assign 0 to all block nodes in block tree. Hence, we can focus on
ranking the other vertices in block tree. Then we define the valid ranking of a block tree
TB as follows:
Let TB = (VT , ET ) be a block tree with root B constructed from block graph G =
(V,E). Let BT be the set of block nodes in TB. Then, V = VT − BT . A vertex ranking
ϕ : VT −→ {0, 1, 2, · · · , κ} of a block tree TB is a vertex κ-ranking if all nodes in BT are
labeled by 0 and all elements in V are labeled by positive integers 1, 2, · · · , κ such that all
paths connecting two vertices in V with the same label i contain an intermediate vertex
with label j > i. The integer label 0 is called the dummy rank and the positive integer
labels 1, 2, · · · , κ are called the ranks.
In the remainder of this paper, we write υ ∈ Tu if υ is either a cut or an end vertex in
the subtree Tu of TB whenever we do not explicitly point out υ is a block node.
We then determine the lexicographical order ” ≺ ” of two sets L1 and L2 of positive
labels by examining the labels in decreasing order. And we write L1 ¹ L2 if L1 ≺ L2
or L1 = L2. For instance, {5, 4, 3, 1} ≺ {5, 4, 3, 2}, {5, 4, 3, 1} ¹ {5, 4, 3, 1}, and {4, 3} ≺
{5, 4, 3, 1}. A vertex ranking ϕ of a block tree TB is critical if LB(ϕ) ¹ LB(ϕ
′) for all
rankings ϕ′ of TB. A critical vertex ranking is an optimal vertex ranking, but the reverse
may not be true. All critical vertex rankings of TB have the same set of visible labels.
The critical list of visible labels of TB, denoted by L
∗(TB), is the set of visible labels of
6
function N as follows:
N (L, l) =
{
1 , if l ∈ L;
0 , otherwise.
Let Tυ be a subtree of TB rooted at υ, where υ might be either a cut vertex or a
block node. Assume that nodes u1, u2, · · · , uκ are children of υ in TB and ϕ is a vertex
ranking for each subtree Tui , but does not consider υ. Let the set of visible labels of Tui
is Li for each i under ϕ. With respect to Li’s, we say that there is a conflict at a label
` > 0 if
κ∑
i=1
N (Li, `) ≥ 2 for 1 ≤ ` ≤ m, where m is the largest integer in ∪
κ
i=1Li. On the
other hand, we call a positive integer to be free label if it is not in any visible list Li. For
example, Figure 4(a) shows the labeling ϕ for each subtree Tui , 1 ≤ i ≤ 4, of TB, but does
not consider the root B of TB. Then there exists a conflict at label 3 with respect to B
and integer 4 is the minimum free label under ϕ. It is clear that a labeling of Tυ is not a
valid ranking if there exists one (or more) conflict in this labeling. If we rank the subtrees
rooted at the children of υ optimally, then our algorithms attempt to resolve all conflicts
in Tυ optimally.
Following the above paragraph, assume that υ is a block node and we assign ` to ui
under ϕ, where ` ≥ ϕ(ui). We define L̂i and Li|x to be {l ∈ Li|l > `} and {l ∈ Li|l ≤ x},
respectively. If υ is a cut vertex and label ` is assigned to υ under ϕ, then we also denote
by L̂i the set {l ∈ Li|l > `}.
Zhou et al. [27] define a data structure called Order to support their algorithm for
ranking edges of trees. We adapt the same data structure used by our algorithms. The
array Order consists of records, each of which contains two items of data: TotalCount and
PointerToList. The length m of Order is the largest integer in ∪κi=1Li. For each integer
l, 1 ≤ l ≤ m, the item TotalCount[l] =
κ∑
i=1
N (Li, l). The item PointToList[l] stores the
lists Li for l ∈ Li. Figure 4(b) illustrates the data structure Order of the labeling ϕ on
Figure 4(a) ranking all nodes except the root B of TB.
It is clear that ϕ is not a valid vertex ranking of TB in Figure 4(a) since there exists a
conflict at label 3 under ϕ. Our algorithms attempt to resolve all conflicts optimally and
obtain a supercritical list of TB. Therefore, we solve the vertex ranking problem of a block
graph based upon its corresponding block tree.
8
3.1 Ranking the Cut Vertices of Block Trees
For a cut vertex υ in TB, we can assign a label ϕ(υ) to υ. Then, ϕ is a critical ranking of
Tυ with respect to υ if the critical lists of children of υ have been computed by ϕ.
The following assumption pertains to the lemma presented in this subsection.
Assumption 1. Let TB be a block tree. Let υ be a cut vertex in TB with children
B1, B2, · · · , Bd. Let ϕ be a partial vertex ranking of Tυ on TB1 , TB2 , · · · , TBd ; that is, ϕ
labels all vertices in Tυ\{υ}. The critical rankings of the subtrees TB1 , TB2 , · · · , TBd , as
well as their critical lists L∗(TB1), L
∗(TB2), · · · , L
∗(TBd), have been computed by ϕ.
In the following lemma, we shall show that a critical vertex ranking of Tυ and a critical
list L∗(Tυ) can be constructed from L
∗(TBi)’s, 1 ≤ i ≤ d.
Lemma 3.1. (Ranking Cut Vertex υ) Let υ, Bi, L
∗(TBi) and ϕ be defined exactly as in
Assumption 1. Let α be the largest rank occurring on more than one critical list L∗(TBi)
or 0 if the lists have no duplicates. Let β be the smallest free label strictly larger than α
with respect to L∗(TBi)’s. Then, assigning ϕ(υ) = β makes ϕ into a critical ranking of Tυ.
Proof . Let m be the largest integer in ∪di=1L
∗(TBi). Note that L
∗(TBi) = LBi(ϕ) for
1 ≤ i ≤ d. Let ϕi = ϕ|TBi , that is, ϕi is a restriction of ϕ to V (TBi). Then,
ϕ(u) =
{
ϕi(u) , if u ∈ TBi ; and
β , if u = υ.
Recall that L̂i = {l ∈ L
∗(TBi)|l > β}, 1 ≤ i ≤ d. Let L = ∪
d
i=1L̂i ∪ {β}. We shall prove
that ϕ is a critical ranking of Tυ and L
∗(Tυ) = L.
We first show that ϕ is a legal vertex ranking of Tυ. At first we consider β > m.
Let ϕi(x) = ϕj(y) for i 6= j. Suppose that ϕi(x) and ϕj(y) are in L
∗(TBi) and L
∗(TBj ),
respectively. Then, they become invisible from υ when ϕ(υ) = β. Hence, ϕ is a legal
vertex ranking of Tυ.
Suppose that β < m. Now, we consider that ϕ(x) = ϕ(y) = α (≤ α) for x, y 6= υ and
x, y ∈ Tυ. Assume that both x and y are in the same subtree TBi of Tυ for some i. Since ϕ
is a critical ranking of TBi , it is also a legal vertex ranking of TBi . Therefore, α /∈ L
∗(TBi)
and α /∈ Lυ(ϕ). Assume that x ∈ TBi and y ∈ TBj for i 6= j. Since α ≤ α < β and all
paths connecting x and y pass through υ in Tυ, α becomes invisible in Lυ(ϕ). Thus, there
10
L = L3 ∪ {β} and L
′ = L4 ∪ {βψ}, we have L ¹ L
′.
Next, we consider that βψ > β. If βψ /∈ L3, it is clear that L3 ≺ L4 ∪ {βψ}. Thus,
L4 ∪ {βψ} Â L3 ∪ [β, βψ − 1]. Since L
′ = L4 ∪ {βψ} and L = L3 ∪ [β, βψ − 1], we have
L′ Â L. Now, suppose βψ ∈ L3. Then, there exists one label γ such that γ > βψ, γ ∈ L4
but γ /∈ L3 (Otherwise, L3 Â L4, a contradiction occurs). Since γ /∈ L3 and γ > β, we
have L ≺ L3 ∪ {γ}. On the other hand, L3 ∪ {γ} ¹ L4 ∪ {βψ} = L
′. Therefore, L ≺ L′.
We finally consider the case of βψ < β. Since L3 ¹ L4, βψ ∈ L3 and βψ /∈ L4, we have
L3 ¹ L4 ∪ {βψ}. Since βψ < β and L ≺ L3, we have that L ≺ L3 ¹ L4 ∪ {βψ} = L
′.
Following the above arguments, we show that L ¹ L′ if α < αψ. This contradicts with
L′ ≺ L.
By the above three cases, we conclude that Lυ(ϕ) ¹ Lυ(ψ) for any vertex ranking ψ
of Tυ. Thus, ϕ is a critical ranking of Tυ and L is the critical list of Tυ. ¤
Let nυ and nbi , 1 ≤ i ≤ d, be the numbers of vertices in G[Tυ] and G[TBi ], respectively.
Then nυ =
d∑
i=1
nbi . In Lemma 3.1, ranking a cut vertex υ and constructing its critical list
L∗(Tυ) of Tυ from L
∗(TBi)’s can be done in O(nυ) time, since all lists are searched one
time [23]. Hence ranking a cut vertex takes O(nυ) time in total. Therefore, we have the
following theorem.
Theorem 3.2. (Ranking all cut vertices) Let G be a block graph with n vertices and TB
be its corresponding block tree. All cut vertices of TB can be ranked in O(n
2) time if the
critical lists of their children have been computed.
3.2 Ranking on the Block Nodes of Block Trees
In the remainder of this paper, we focus our attention on block nodes in TB. Without loss
of generality, we can only consider the root B of TB with respect to block nodes. For the
other block nodes in TB, we can apply the same approach processing the root of TB to
them. Hence, we only focus on processing the root of TB with respect to block nodes in
the remainder of this paper.
The following assumption pertains to all lemmas presented in the remainder of this
paper.
Assumption 2. Let G be a block graph and TB be its corresponding block tree rooted
at B. Assume that v1, v2, · · · , vk are children of B and their associated critical lists are
12
ϕ′(x) ≥ ϕ′(vi) = `i and Lvi(µi) = Li; otherwise, ϕ
′(x) ≥ ri ≥ µi(vi). Hence, x is also
visible from B under µ. This implies that if both x and y are visible from B under ϕ′,
then they are visible from B with respect to µ. Hence, µ is not a legal vertex ranking of
TB if both x and y are visible from B under ϕ
′. This contradicts that µ is a valid vertex
ranking of TB. Therefore, there exist no different vertices are visible from B under ϕ
′; that
is, ϕ′ is a legal vertex ranking of TB.
We then prove that Lvi(ϕ
′) ¹ Lvi(µ), 1 ≤ i ≤ k, and hence LB(ϕ
′) ¹ LB(µ).
Obviously, Lvi(ϕ
′) = {ϕ′(vi)} ∪ {l ∈ Li|l > ϕ
′(vi)} and Lvi(µ) = {µ(vi)} ∪ {l ∈
Lvi(µi)|l > µ(vi)}.
By the definition of ri, if ri = 0 then ϕ
′(vi) = `i and Lvi(ϕ
′) = Lvi(µ). Hence, assume
that ri 6= 0 in the following.
Since ri 6= 0, we have Lvi(ϕ
′) ≺ Lvi(µ), ri ∈ Lvi(µ) but ri /∈ Lvi(ϕi). Hence, {l ∈
Lvi(ϕi)|l > ri} ≺ {l ∈ Lvi(µ)|l > ri} ∪ {ri}.
The label ϕ′(vi) depends on the relative values of `i and ri and there are the following
two cases.
Case 1: `i ≥ ri.
Since `i ≥ ri ≥ µi(vi), and above ri, {l ∈ Lvi(ϕi)|l > ri} ≺ {l ∈ Lvi(µi)|l ≥ ri} agrees.
Hence, {l ∈ Lvi(ϕi)|l > `i} ¹ {l ∈ Lvi(µi)|l > µi(vi)}. Consequently, {l ∈ Lvi(ϕi)|l >
`i} ∪ {`i} ¹ {l ∈ Lvi(µi)|l > µi(vi)} ∪ {ui(vi)}; that is, Lvi(ϕ
′) ¹ Lvi(µ).
Case 2: `i < ri.
In this case, ϕ′(vi) = ri. Thus Lvi(ϕ
′) = {ri} ∪ (Lvi(ϕi) − [1, ri]). Since ri > `i,
µi(vi) ≤ ri, ri /∈ Lvi(ϕi), ri ∈ Lvi(µi) and Lvi(ϕi) ¹ Lvi(µi), we have {ri}∪{l ∈ Lvi(ϕi)|l >
ri} ¹ {l ∈ Lvi(µi)|l ≥ ri}. Thus, {ri} ∪ {l ∈ Lvi(ϕi)|l > ri} ¹ {l ∈ Lvi(µi)|l ≥ µi(vi)}.
That is Lvi(ϕ
′) ¹ Lvi(µ).
The above arguments prove that Lvi(ϕ
′) ¹ Lvi(µ) for 1 ≤ i ≤ k. Since lists Lvi(ϕ
′)’s
are pairwise disjoint, we conclude that LB(ϕ
′) ¹ LB(µ). Since ϕ
′ and ϕ are subcritical
vertex rankings of TB that are extensions of ϕ1, ϕ2, · · · , ϕk and LB(ϕ) ¹ LB(ψ) for all
subcritical rankings ψ of TB, we conclude that LB(ϕ) ¹ LB(ϕ
′). Since LB(ϕ) ¹ LB(ϕ
′),
LB(ϕ
′) ¹ LB(µ) and the operation ” ¹ ” is transitive, we conclude that LB(ϕ) ¹ LB(µ).
This contradicts with LB(µ) ≺ LB(ϕ). Thus, ϕ is critical and hence supercritical. ¤
Let B, vi, Li, `i and ϕi be defined exactly as in Assumption 2. The vertex vi is
referred to as branch i, 1 ≤ i ≤ k, of B. The set of vertices emanating (down) from a
14
prefix of values b1, b2, · · · , bt that are all bigger than pk. Assume that b1 < b2 < · · · < bt.
Set b0 equal to pk.
We will prove this lemma by contradiction. Suppose we have an optimal labeling M
in which the highest value used, h, is greater than pk. Suppose bi ≤ h ≤ bi+1. The values
bi+1, bi+2, · · · , bt must be visible with respect toM . Assume that h = bi or h = bi+1. Since
L is valid and each of the b’s is visible, each b is on L̂i of exactly one child of B. Thus,
if h = bi or h = bi+1, then the label h will be in some L̂ı. This implies that M would be
invalid. Thus, bi < h < bi+1. This means that LB(M ∪ ϕ) will start bt, bt−1, · · · , bi+1, h,
which is lexicographically greater than LB(L ∪ ϕ), which starts bt, bt−1, · · · , bi+1, bi. This
contradicts the assumption that M is an optimal labeling. ¤
Lemma 3.5. Let Z = (zk, zk−1, · · · , z1) be an optimal labeling such that zk > zk−1 >
· · · > z1. Let Sj = {vj , vj−1, · · · , v1} for 1 ≤ j ≤ k. Sj is a set comprising a suffix of the
branch set when sorted by labels in Z. Then, the labeling Z restricted to the branch set Sj
is optimal for subgraph (TB\ ∪
k
i=j+1 Tvi) of TB.
Proof . Let ZSj be a restriction of Z to Sj . Since Z ∪ ϕ is a valid ranking of TB, ZSj ∪ ϕ
is also a valid ranking of TB\∪
k
i=j+1 Tvi . By Lemma 3.4, there is an optimal labeling of Sj
that uses no values larger than zj since ZSj is a valid labeling of TB\ ∪
k
i=j+1 Tvi . Assume
that M is better than ZSj on TB\∪
k
i=j+1 Tvi . We can replace ZSj with M and get a better
overall labeling of TB. This contradicts the assumption that Z is optimal. ¤
Recall that Li|x represents {l ∈ Li|l ≤ x}. Then we define the greedy-cover labeling
given in [5] as follows.
Definition 3.3. Let L = (p1, p2, · · · , pk) be a valid labeling. A branch i is said to
satisfy the greedy-cover (abbreviated as gc) property if for all branches j with pj < pi,
Li|pi Â Lj |pi . L is said to be a gc labeling if every branch satisfies the gc property.
In the following, we shall show that a gc labeling is an optimal labeling, but the reverse
may not be true.
Lemma 3.6. (greedy cover lemma) Let L = (p1, p2, · · · , pk) be a valid labeling such that
pk > pk−1 > · · · > p1. Then, there is a valid gc labeling whose largest label is also pk.
Moreover, if L is optimal, then the corresponding gc labeling can be made optimal too.
16
still has a valid labeling.
As in Case 1, the definition of γ ensures that the values in the interval between γ and
pκ that are left visible in L are the same as the values left visible in L
′′. All values below
γ on L and Lκ are invisible in L
′′, but they might be visible on L and Lκ in L. So in
terms of optimality, L′′ is at least as good as L. Hence, if L is optimal, then L′′ is also
optimal. ¤
Corollary 3.7. There is always an optimal labeling that is also gc labeling.
Based on the above corollary, we can restrict our search for labelings to the class of gc
labelings. The following lemma tells us which gc labeling we are searching for.
Lemma 3.8. (Searching optimal labeling) Among all valid gc labelings, the labeling that
has the lexicographically smallest list of labels sorted from large to small is optimal.
Proof . Consider two competing valid gc labelings L= (pk, pk−1, · · · , p1) and L
′ = (p′k, p
′
k−1,
· · · , p′1) that are both sorted in decreasing order of label values; that is, pk > pk−1 > · · · >
p1 and p
′
k > p
′
k−1 > · · · > p
′
1.
Without loss of generality, assume that L ≺ L′ and j is the highest index at which pj
is less than p′j . All the labels larger than pj agree: pk = p
′
k, pk−1 = p
′
k−1, · · · , pj+1 = p
′
j+1.
Now consider the definition of gc labeling (Definition 3.3). Given that the largest label is
fixed at pk, the choice of which branch vertex gets that label is deterministic. Thus, since
both L and L′ are gc labelings, we see that vk = v
′
k, vk−1 = v
′
k−1, · · · , vj+1 = v
′
j+1.
Let L̂i = {l ∈ Li|l > pi} and L̂′i = {l ∈ Li|l > p
′
i}. Let L1 = ∪
k
i=j+1(L̂i ∪ {pi})
and L2 = ∪
k
i=j+1(L̂
′
i ∪ {p
′
i}). Since p
′
j > pj and pi = p
′
i, j + 1 ≤ i ≤ k, we have that
{l ∈ L1|l > p
′
j} = {l ∈ L2|l > p
′
j}; that is, each such value is either on both L1 and L2
or no neither. Furthermore, since p′j is used as a label in L
′, it will be on LB(ϕ ∪ L
′) and
it cannot be visible on any visible list L̂′i, 1 ≤ i < j. So the value p
′
j is not on the list
LB(L ∪ ϕ) induced by the labeling L, and L is a better labeling than L
′.
Since L and L′ are arbitrary gc labelings, the above argument shows that any gc
labeling that is not the lexicographically smallest will not be optimal. By Corollary 3.7,
there is a gc labeling that is an optimal labeling. Therefore, the optimal gc labeling must
be the gc labeling with the lexicographically minimum label list. ¤
Based on the previous lemma, our algorithm will search for a gc labeling with a lexi-
cographically minimum label list. The good news is that given a fixed label list, there is
18
Lemma 3.11. Let Z be an optimal gc labeling of VB. Let  ∈ [1, k] be the branch index
such that v is labeled by Zsup, and let V
′ = VB − {v}. Then, the following statements
hold true.
(1) The labeling Z ′ which is the restriction of Z to V ′ is an optimal gc labeling of V ′;
(2) Any optimal labeling Z ′ of V ′ can be extended to an optimal gc labeling Z of VB as
follows:
Z(v) =
{
Zsup , if v = v;
Z ′(v) , if v ∈ VB − {v};
Proof . By Lemma 3.5 and Lemma 3.6, statement (1) can be easy to verify.
Since Z ′ is an optimal gc labeling of V ′ and L|Zsup Â Li|Zsup for i 6= , Z is a gc
labeling. Furthermore, Zsup is the minimum integer z for which VB has a valid labeling
L of ML = z, hence Z is an optimal labeling of VB. Therefore, we conclude that Z is an
optimal gc labeling of VB. This completes the proof. ¤
Following Lemma 3.3 and Lemma 3.11, we have the following corollary.
Corollary 3.12. Let ϕ be a supercritical vertex ranking of TB. Let v be the branch vertex
of VB such that ϕ(v) = Zsup, and let T
′ = TB\Tv . Then, the following statements hold
true.
(1) The vertex ranking ϕ′ = ϕ|T ′ is supercritical;
(2) Any supercritical vertex ranking η′ of T ′ can be extended to a supercritical vertex
ranking η of TB as follows:
η(v) =


Zsup , if v = v;
η′(v) , if VB − {v};
ϕi(v) , if v ∈ Tvi\{vi}, 1 ≤ i ≤ k.
Using Lemma 3.8 and Corollary 3.12(2), one can easy to verify the following procedure
GC correctly solves the labeling problem if procedure SuperRank could correctly find
the super rank of VB.
Procedure GC(B). Finding an optimal greedy cover labeling.
Input: A root B with children v1, v2, · · · , vk and their associated critical lists L1, L2, · · · , Lk
corresponding to the rankings ϕ1, ϕ2, · · · , ϕk of Tv1 , Tv2 , · · · , Tvk , respectively.
Output: An optimal gc labeling Z = (Z[1], Z[2], · · · , Z[k]) of VB, and LB, the supercritical
list of TB.
Method:
20
Since
k∑
i=1
N (Li, z) = 0 and z ≥ MP , we have N (LL, l) ≤ N (LP , l) ≤ 1 for l 6= z, and
N (LL, z) =
k∑
i=1
N (Li, z) + 1 = 1. That is, ML = z and L is a required valid labeling of
VB. ¤
Let z be a positive integer. Let Li, vi, ϕi, `i, VB be defined exactly as in Assumption 2.
Then, the following two lemmas hold true.
Lemma 3.14. If
k∑
i=1
N (Li, l) ≤ 1 for 1 ≤ l ≤ m, then there exists an optimal labeling
Z = (z1, z2, · · · , zk) of VB such that Z(v) = MZ = z = max{l|l ∈ Z} and zi = `i for all
i, where m is the largest value in ∪ki=1Li.
Proof . Let L = (`1, `2, · · · , `k) be the starting labeling of VB. Since
k∑
i=1
N (Li, l) ≤ 1 for
1 ≤ l ≤ m, L is a valid labeling of VB. Since Li, 1 ≤ i ≤ k, is critical list of Tvi , for any
labeling P of VB, Li ¹ ({l ∈ Li|l > P (vi)} ∪ {P (vi)}). Therefore, ∪
k
i=1Li ¹ ∪
k
i=1({l ∈
Li|l > P (vi)}∪{P (vi)}) for any labeling P of VB. This implies that L is an optimal labeling
of VB. Hence, Z = L. Furthermore, zi = `i for all i and MZ = z = max{l|l ∈ Z}. ¤
Let  be a branch index such that L|z º Li|z for 1 ≤ i ≤ k. We then denote by z
′ the
largest label such that z′ < z and z′ /∈ ∪i∈[1,k]−{}L̂i. For example in Figure 4(a), if z = 5
then  = 2 and z′ = 4; if z = 4 then  = 2 and z′ = 3. We are now ready to give Lemma
3.15 which is a key to improve the time complexity.
Lemma 3.15. Suppose that α is defined. The children set VB has a valid labeling P such
that P (v) =MP = z if and only if the following conditions hold:
(a) α < z;
(b) either (ϕ(v) 6= z and
k∑
i=1
N (Li, z) = 0) or (ϕ(v) = z and
k∑
i=1,i6=
N (Li, z) = 0); and
(c) V ′ = VB − {v} has a valid labeling P
′ such that MP ′ = z
′ < z.
Proof . (=⇒) Let P = {p1, p2, · · · , pk} be a valid labeling of VB such that P (v) =MP =
z. If there exist two distinct integers s and t such that s, t ∈ [1, k] and Ls ∩ Lt 6= ∅, then
k ≥ 2 and α ≥ 1. Assume that α is in both Ls and Lt.
Suppose, by way of contradiction, that z ≤ α. Since z = MP is the largest value in
∪ki=1pi and z ≤ α, the conflict α remains existence in both L̂s and L̂t under P . This
implies that P is not a valid labeling. A contradiction occurs since P is a valid labeling.
Thus, statement (a) holds.
22
Proof . Let v be the branch vertex of VB such that ϕ(v) = β0. Let P be the following
labeling of VB:
P (v) =
{
β0 , if v = v;
βi , if v ∈ VB − {v}, for 1 ≤ i ≤ k − 1,
Note that P assigns βi to an arbitrary branch vertices except v.
Then, it is easy to see that there exists no conflict under P . That is, the labeling P of
VB is valid. Furthermore, MP = βk−1 if β0 < βk−1 and MP = β0 if βk−1 < β0.
Let P ′ be any valid labeling of VB. By Lemma 3.14 and Lemma 3.15, we have (1)
if α = 0, then
k∑
i=1
N (Li, l) ≤ 1 for l ∈ [1,m] and MP ′ = β0; and (2) if α > 0, then
MP ′ > α. If ϕ(v) = MP ′ , then MP ′ = β0; otherwise,
k∑
i=1
N (Li,MP ′) = 0. Therefore,
if
k∑
i=1
N (Li,MP ′) = 0 then, by the definition of β1, we have β1 ≤ MP ′ . By the above
arguments, we conclude that VB has no valid labeling P
′ with MP ′ < min{β0, β1}. ¤
Lemma 3.13, Lemma 3.14, Lemma 3.15 and Lemma 3.16 immediately imply the fol-
lowing lemma.
Lemma 3.17. The following two statements hold:
(1) Zsup ∈ {β0} ∪ {β1, β2, · · · , βk−1}; and
(2) let ı be an integer such that 1 ≤ ı ≤ k − 1, then Zsup ∈ {β0} ∪ {β1, β2, · · · , βı} if and
only if VB has a valid labeling P of MP = βı.
If VB has a valid labeling P with MP = z, then z ∈ K = {β0, β1, · · · , βk−1} by Lemma
3.17. From Lemma 3.14 and Lemma 3.15, we can easily derive the following recursive
procedure Check to decide whether VB has a valid labeling P with MP = z for a given
integer z ∈ K, inspecting the conditions (a), (b) and (c) in Lemma 3.15.
Procedure Check(VB, z). Inspecting whether VB has a valid labeling P with MP = z
for a given integer z.
Input: VB, Li, 1 ≤ i ≤ k, and z.
Output: True, if VB has a valid labeling P of MP = z; Otherwise, return False.
Method:
1. if |VB| = 1, then return true; /* B has exactly one child */
2. else /* k ≥ 2 */
24
presented in Section 2.3. Then, they use the technique of the radix sorting to sort Li in
array Order, and it can be done in time O(n) [1]. Then all L’s can be decreasingly picked
from array Order in O(n) time [27]. Therefore, we have the following lemma.
Lemma 3.18. [27] The Procedure Check(VB, z) takes O(n) time, where n is the number
of vertices in G[TB].
Similar to [27], we use the binary search technique to find the smallest integer Zsup.
Hence, Procedure Check is called at most log∆ times, where ∆ is maximum degree of
G[TB]. By Lemma 3.18, Procedure SuperRank takes O(n log∆) time. Since the block
node B has k children, we totally need to find Zsup k times. Thus, procedure GC(B)
solving the labeling problem runs in O(kn log∆) time. Therefore, an optimal vertex
ranking (supercritical ranking) of TB can be found in O((k1 +k2 + · · ·+kd)n log∆), where
ki, 1 ≤ i ≤ d, is the number of children of block node Bi in TB. Thus we have the following
theorem.
Theorem 3.19. The vertex ranking problem of a block graph with n vertices can be solved
in O(n2 log∆) time.
The following example shows an optimal gc labeling produced by procedure GC.
Example 1. Given an initial subcritical ranking of TB in Figure 5(a). In Figure 5(a), K =
{6, 7, 8, 12, 15}. Using binary search strategy, we first pick z to be 8. Then, call procedure
Check(VB, 8). In Check(VB, 8), |VB| = 5, α = 6,  = 1 (branch 1 has the largest Li|8)
and z′ = 7. Then, VB = VB − {v1} and call Check(VB, 7). In Check(VB, 7), |VB| = 4,
α = 5,  = 2 and z′ = 4. Then, VB = VB − {v2} and call Check(VB, 4). In Check(VB, 4),
|VB| = 3 and α = 5. Since α > 4, Check(VB, 4) returns false. Hence, Zsup 6= 8. We then
select z to be 12. Following the above checking, we can find Check(VB, 12) returns true.
Therefore, Zsup = 12. Consequently, branch 2 gets label 12 since `2 ≤ 12 and L2|12 is
the lexicographically largest among all Li|12’s. Then, Z = (0, 12, 0, 0, 0) and T ′ = T ′\Tv2 .
The resultant labeling is shown in Figure 5(b). Continue to find the other super ranks in
Figure 5(c)-(e), we finally get an optimal gc labeling Z = (8, 12, 1, 6, 7) shown in Figure
5(f).
26
free labels starting from α + 1, said x1, x2, · · · , xd−1. Assigning these free labels to some
d− 1 branches in D can resolve the conflict immediately. Yet, in some cases, this does not
overcome the conflict optimally, and it is actually better to assign some xi to branches
outside D. In Section 4.1.1, we state the situation under which assigning the smallest d−1
free labels to branches in D is always the best choice. We state how to deal with the other
case in Section 4.1.2.
4.1.1 Resolving the Maximum Conflict Immediately.
Consider the interval [α + 1, xd−1]. Suppose that the labels in L̂1, L̂2, · · · , L̂k do not fall
into [α + 1, xd−1]. In this case, for any i /∈ D, the labels in Li are either bigger than
xd−1 or smaller than α. Assigning a label in {x1, x2, · · · , xd−1} to a branch i /∈ D elim-
inates only labels smaller than α from L̂i. Thus, it is more beneficial to assign such a
label to a branch j in D as α is eliminated from L̂j . More interestingly, a simple strategy
suffices to choose which d−1 branches in D receive the smallest free labels x1, x2, · · · , xd−1:
Simple Strategy : Recall that Li|α = {l ∈ Li | l ≤ α}. Let ı be a branch in D such that Lı|α is
lexicographically smallest among all branches in D. The smallest free labels x1, x2, · · · , xd−1
are put, in any order, on the branches in D − {ı}.
An example is depicted in Figure 7. Notice that permuting the free labels among the
d−1 branches chosen has no effect on the visible labels left in the corresponding sub-block
trees; thus, the strategy does not consider these d− 1 branches one by one. Assume that
all previous conflicts have been resolved optimally, we can prove that the above simple
strategy minimizes lexicographically both the labels put on the branches and the visible
labels left in the sub-block trees (see Section 4.3).
4.1.2 Freeing Better Labels.
Suppose a visible label in some L̂i lies in the interval [α + 1, xd−1]. Then, the previous
simple strategy might not resolve the conflict optimally. Figure 8 shows such an example.
Intuitively, if there is a visible label ` in some L̂i falling in the range [α + 1, xd−1], it is
more advantageous to assign the free label just greater than ` to branch i instead of a
branch in D because this assignment eliminates a visible label greater than α. This gives
us some motivation to handle such a case as follows:
28
/* Step I: Initialization */
1. B[i]←− ϕi(vi), for 1 ≤ i ≤ k;
/* Step II: Locating the maximum conflict */
2. α←− max{l | l ∈ Li ∩ Lj , for i 6= j};
(* If there exists no conflict on Li’s, 1 ≤ i ≤ k, set α = 0 *)
3. while (α > 0) do
4. D = {i | α ∈ Li};
5. d = |D|;
/* Step III: Counting the suitable free labels */
6. γ = the smallest label in ∪ki=1L̂i bigger than α;
7. w = the number of free labels bigger than α but smaller than γ;
/* Step IV: Resolving the conflict immediately */
8. if (w ≥ d− 1) then
9. Compute the branch i0 ∈ D such that Li0 |α is the lexicographically
smallest among all branches in D;
10. for each i ∈ D − {i0} do
11. B[i]←− the next smallest free label bigger than α;
/* Step V: Freeing more free labels */
12. else /* w < d− 1 */
13. x = the smallest free label bigger than γ;
14.  = the branch such that L contains the largest label < x;
15. B[]←− x;
/* Step VI: Removing the labels which are no longer visible */
16. for each i such that B[i] gets a new value do
17. Li = {l ∈ Li | l > B[i]} ∪ {B[i]};
/* ReLocating the maximum conflict */
18. α←− max{l | l ∈ Li ∩ Lj , for i 6= j};
/* Step VII: Uniting the visible labels */
19. LB ←− ∪
k
i=1Li;
20. Output LB and B[i], for i = 1 to k;
The main body of the procedure RelaxGC is a while loop comprising Steps II-VI.
Each iteration attempts to resolve the currently maximum conflict. If there are enough
suitable free labels available, then the conflict is resolved immediately; otherwise, more
30
Intuitively, a gc labeling assigns the biggest label to a branch so as to cover the lex-
icographically largest set of labels. The labeling shown in Figure 9(b) is a gc labeling.
Among all labelings using Σ, there is a unique gc labeling, which causes the smallest set
of visible labels left in the subtrees, and which is thus optimal. The algorithm in Section
3 actually computes an optimal gc labeling and hence its output is optimal.
The optimal labeling computed by procedure RelexGC does not follow the rule
imposed by a gc labeling. Lam et al. [15] observe that with respect to a gc labeling
Z = (z1, z2, · · · , zk), if there exist two branch i and j such that both L̂i and L̂j contain
no labels between zi and zj inclusive, then zi and zj can be swapped without affecting the
optimality of the labeling. For instance, the labeling in Figure 9(b) is a gc labeling and
there exists no label between branch 1 and 4, hence we can swap the labels of branch 1
and 4. Figure 9(c) shows the result of swapping. Notice that if one branch get a swapping
label, then this label must be equal to or greater than the starting label. On the other
hand, we can not swap branch 1 and 2 in Figure 9(c) since branch 1 gets label 6 after
swapping and label 6 is in L1. Lam et al. [15] relax the definition of a gc labeling to
capture the above observation. In the following, we adapt the same notation but with a
little different meanings.
Definition 4.1. Let P = (p1, p2, · · · , pk) be a valid labeling. A branch i is said to satisfy
the relaxed greedy-cover (abbreviated as rgc) property if for all branches j with pj < pi,
Li|pi Â Lj |pi or both Li and Lj contain no labels in the interval [pj , pi]. P is called a rgc
labeling if every branch satisfies the rgc property.
By the definition of a rgc labeling, a gc labeling is also a rgc labeling, but the reverse
is not true. Also, unlike a gc labeling, a rgc labeling using Σ may not be unique. Consider
any rgc labeling P using Σ. By definition, we can permute the labels of P and produce a
gc labeling P˜ that is equivalent to P in the sense that 〈P 〉 = 〈P˜ 〉 and P˜ causes the same
set of visible labels left in every subtree Tvi as P . Therefore, if P is equivalent to the gc
labeling using Σ, P must be optimal.
Definition 4.2. Consider any partial labeling P = (p1, p2, · · · , pk).
(1) P is a gc-partial labeling if for any branch i such that pi > `i, for any branch j such
that pj < pi, Li|pi Â Lj |pi .
(2) P is a rgc-partial labeling if for any branch i such that pi > `i, branch i satisfies the
rgc property.
32
always an optimal labeling, Z ′ cannot be a valid labeling and must contain at least one
conflict, say, at a label x. Then, we have the following cases:
Case 1: x = δ.
Since ci+1 < ci+2 < · · · < cit and ciκ ≤ ziκ for  + 1 ≤ κ ≤ t, we have δ < ziκ for
+1 ≤ κ ≤ t. Hence, δ ∈ L̂w for some branch w ∈ {i1, i2, · · · , i}. Since δ ∈ P and δ ∈ L̂w
for some w, P is not a valid labeling. This contradicts that P is a valid labeling.
Case 2: x > δ.
Since conflict x originates from branch h, we have x ∈ L̂h and x < δ < zh. A
conflict occurring at label x implies that there must exist a branch p ∈ {i1, i2, · · · , i} −
{h} such that x is in L̂p. (Since δ < x < zh < z+1 < z+2 < · · · < zt, x /∈ L̂w for
w ∈ {i+1, i+2, · · · , it}.) With respect to P and P˜ , this conflict remains existence since
x > δ > α(P ). This implies that P is not a valid labeling. A contradiction occurs.
By the above cases, we conclude that δ ∈ Σ.
We then prove that δ ≤ zi . By way of contradiction, we suppose that δ > zi . Since
δ ∈ Σ, there exists a branch p ∈ {l1, l2, · · · , l−1} such that zp = δ. That is, zp > zi . We
derive a contradiction as follows:
(i) Z is a gc labeling, so L̂p|δ Â L̂i |δ.
(ii)Consider the label cp. Since p ∈ {i1, i2, · · · , i−1}, we know that cp < δ. Recall that
〈P 〉 is a gc-partial labeling, we have L̂i |δ Â L̂p|δ.
A contradiction occurs by (i) and (ii). Therefore, δ ≤ zi . ¤
The remainder of this subsection will prove that 〈P 〉 ¹ Σ by induction.
Initially, P = (`1, `2, · · · , `k), where `i = ϕi(vi) for 1 ≤ i ≤ k. By Lemma 3.17, it is
easy to verify the following lemma.
Lemma 4.2. Let P = (`1, `2, · · · , `k) be the starting labeling and Z = (z1, z2, · · · , zk) be
the optimal gc labeling. Then `i ≤ zi, for 1 ≤ i ≤ k.
By Lemma 4.2, the invariant 〈P 〉 ¹ Σ holds initially. Suppose that after a number of
iterations of the while loop, the rgc-partial labeling P produced satisfies the invariant.
In the next iteration, one or more branches will receive bigger labels. Let Q be the new
rgc-partial labeling. We are going to show that 〈P 〉 ≺ 〈Q〉 ¹ Σ.
We have a close look of the iteration that produces Q at the end. Step II and Step III
compute the values of α,D, d, γ, and w with respect to P . New labels are assigned to the
34
in P . Recall that w denotes the number of free labels in the interval [α + 1, γ − 1] with
respect to P .
(I). Σ contains more than p+ w labels bigger than α.
(II).If Σ and 〈P˜ 〉 contain the same set of labels ≥ x, then Σ contains at most p + w labels
bigger than α. (≡ If Σ contains more than p + w labels bigger than α, then Σ and 〈P˜ 〉
contain the different set of labels ≥ x)
Statements (I) and (II) together imply that Σ and 〈P˜ 〉 contain the different set of
labels ≥ x. By Lemma 4.1, ci ≤ zi for all i. Therefore, Σ must contain a label ` ≥ x such
that ` /∈ 〈P˜ 〉. Consequently, Σ º 〈P˜ 〉 ∪ {x} º 〈Q〉, and Lemma 4.5 follows.
Proof of Statement (I). Let Z = (z1, z2, · · · , zk) be the gc-labeling using Σ. For each
branch i with ci > `i, we have i /∈ D (due to Lemma 4.3) and zi ≥ ci > α. On the other
hand, Z must assign at least d− 1 branches in D with label bigger than α. Therefore, Z
uses at least p+ d− 1 > p+ w labels > α.
Proof of Statement (II). Suppose Σ and P˜ have the same set of labels ≥ x. Let
Z = (z1, z2, · · · , zk) be the gc-labeling using Σ. To prove this statement, we will prove the
following statements.
(II-1) For each label h ∈ 〈P˜ 〉 such that h ≥ x, h lies on the same branch under both Z and
P˜ . (The proof is left in Appendix A)
(II-2) For each label h ∈ [γ, x− 1], if h is used by P˜ then h is also used by Z and h labels the
same branch with respect to Z and P˜ ; otherwise, h is the label of a visible vertex residing in
the same block subtree Tvi with respect to both Z and P˜ . (The proof is left in Appendix B)
If the above statements hold, we conclude that P˜ and Z use the same set of labels
≥ γ. With respect to P˜ (or P ), let p1 be the number of labels ≥ γ and p2 be the number
of labels in [α + 1, γ − 1]. Note that p = p1 + p2. Z uses exactly p1 labels ≥ γ. Then,
p2 + w = (γ − 1)− (α+ 1) + 1 = γ − α− 1. Therefore, the number of labels used in 〈Z〉
that are greater than α is at most p1+[(γ−1)− (α+1)+1] = p1+γ−α−1 = p1+p2+w.
This completes the proof of this statement. ¤
In conclusion, based on Lemmas 4.2−4.5, we can show inductively that the partial
labeling P computed in every iteration of the while loop satisfies the invariant 〈P 〉 ¹ Σ.
36
[5] P. De La Torre, R. Greenlaw, and A.A. Scha¨ffer, Optimal edge ranking of trees in
polynomial time, Algorithmica 13 (1995), pp. 592-618.
[6] J.S. Deogun and Y. Peng, Edge ranking of trees, Congr. Numer. 79 (1990), pp. 19-28.
[7] J.S. Deogun, T. Kloks, D. Kratsch and H. Mu¨ller, On vertex ranking for permutation
and other graphs, Lecture Notes in Computer Science 775, Springer-Verlag, Berlin,
1994, pp. 747-758.
[8] J.S. Deogun, T. Kloks, D. Kratsch and H. Mu¨ller, On vertex ranking for trapezoid,
circular-arc and other graphs, Discrete Appl. Math. 98 (1999), pp. 39-63.
[9] L.T. Quoc Hung, M.M. SysÃlo, M.L. Weaver and D.B. West, Bandwidth and density
for block graphs, Discrete Math. 189 (1998), pp. 163-176.
[10] A.V. Iyer, H.D. Ratliff and G. Vijayan, Optimal node ranking of trees, Inform. Pro-
cess. Lett. 28 (1988), pp. 225-229.
[11] A.V. Iyer, H.D. Ratliff and G. Vijayan, On an edge ranking problem of trees and
graphs, Discrete Appl. Math. 30 (1991), pp. 43-52.
[12] M. Katchalski, W. Mccuaig and S. Seager, Ordered colourings, Discrete Math. 142
(1995), pp. 141-154.
[13] T. Kloks, H. Mu¨ller and C.K. Wong, Vertex ranking of asteroidal triple-free graphs,
Inform. Process. Lett. 68 (1998), pp. 201-206.
[14] T.W. Lam and F.L. Yue, Edge ranking of graphs is hard, Discrete Appl. Math. 85
(1998), pp. 71-86.
[15] T.W. Lam and F.L. Yue, Optimal edge ranking of trees in linear time, Algorithmica
30 (2001), pp. 12-33.
[16] C.E. Leiserson, Area efficient graph layouts for VLSI, in: Proc. 21st Annual IEEE
Symposium on Foundations of Computer Science, 1980, pp. 270-281.
[17] J.W.H Liu, The role of elimination trees in sparse factorization, SIAM J. Matrix
Anal. Appl. 11 (1990), pp. 134-172.
38
6 Appendix A
(Proof of Statement (II-1) in Lemma 4.5).
Without loss of generality, we assume that z1 > z2 > · · · > zk and b1 > b2 > · · · >
bp > α.
We prove this statement by induction starting with the largest label below.
Let 〈P˜ ′〉 = (ci1 , ci2 , · · · , cit) such that cij > `ij , 1 ≤ j ≤ t, and ci1 > ci2 > · · · > cit ≥ x.
Obviously, both ci1 and z1 lie on the same branch. Hence the statement holds initially.
Suppose that both cij and cj lie on the same branch under both Z and P˜ , for 1 ≤ j ≤
κ− 1 < t. We shall prove that both ciκ and zκ also lie on the same branch under both Z
and P˜ .
Suppose, by way of contradiction, that ciκ and zκ lie on the different branch under
both Z and P˜ .
By Lemma 4.1, ciκ ∈ Σ. Suppose that branch i and j are labeled by ciκ and zκ
respectively. Since ciκ ∈ Σ, and Z and P˜ contain the same set of labels ≥ x, there exists
one zp, 1 ≤ p ≤ t, such that zp lies on branch i with respect to Z. Hence, zp = ciκ lies on
branch i with respect to Z and P˜ . On the other hand, for branch j, zκ = ciq , 1 ≤ q ≤ t,
lies on branch j with respect to Z and P˜ .
With respect to Z, zκ > zp holds. Therefore, ciq > ciκ . A contradiction occurs.
Therefore, ciκ and zκ lie on the same branch under both Z and P˜ . 2
40
We first show that if κ ∈ 〈P˜ 〉 then κ ∈ 〈Z〉 and κ labels the same branch under both
Z and P˜ . By Property 1 of Lemma 4.1, κ ∈ 〈P˜ 〉 then κ ∈ 〈Z〉. Suppose that κ labels the
different branches, called branch ı and , with respect to P˜ and Z. Let cı (resp. z) be
the label of branch ı (resp. ) under P˜ (resp. Z). Note that cı = z = κ.
By Statement (II-1) in Lemma 4.5 and the induction hypothesis, we have that P˜ and
Z use the same set of labels ≥ κ − 1 and each label ≥ κ − 1 resides in the same branch
with respect to P˜ and Z. Since cı and z are in Σ, there exist c and zı such that c = z
lies on branch  under P˜ and zı = cı lies on branch ı under Z. Consequently, zı = z. A
contradiction with Z is a valid labeling. Therefore, if κ ∈ 〈P˜ 〉 then κ ∈ 〈Z〉 and κ labels
the same branch under both Z and P˜ .
We then prove that if κ /∈ 〈P˜ 〉 then κ is the label of a visible vertex in Tvi\{vi} with
respect to both Z and P˜ . Since κ is visible, κ ∈ L̂i with respect to P˜ (or P ). Suppose
that κ is invisible with respect to Z. Then, there must exist one branch j such that the
label of branch j is greater than κ. Since Z and P˜ contain the same set of labels ≥ x and
the labels ≥ x lie on the same branch under both Z and P˜ , κ becomes invisible and is a
free label under P˜ . This contradicts with κ is not a free label under P˜ . Hence, κ is also a
visible label under Z.
For contradiction, suppose that κ ∈ L̂j under Z and i 6= j, that is, κ lies on the
different branch with respect to Z and P˜ . Suppose that ui ∈ Tvi\{vi} and uj ∈ Tvj\{vj}
and the labels of ui and uj are all κ. Since both Z and P˜ are gc labeling, the labels ϕi(ui)
and ϕj(uj) of ui and uj , respectively, do not be relabeled by Lemma 3.3. Since Z is a valid
labeling and κ is visible with respect to Z, there must exist one label zı > κ such that it
is assigned to branch ı or . Assume that branch ı gets zı. By the induction hypothesis
and Statement (II-1) in Lemma 4.5, we have zı is assigned to branch ı with respect to Z
and P˜ . Therefore, κ /∈ L̂i under P . This contradicts with κ ∈ L̂i. Therefore, κ lies on the
same branch with respect to Z and P˜ .
By the above arguments, we conclude that this statement is true when h = κ. 2
42
v
1
v
2 v3 v4
5
6
8
5
6
9 6 5
L
1
3 4 4 2
B
^ L
2
^
L
3
^ L
4
^
Figure 6: L̂1 = {5, 6, 8}, L̂2 = {5, 6, 9}, L̂3 = {6} and L̂4 = {5} with respect to the starting
labeling (`1, `2, `3, `4) = (3, 4, 4, 2).
p L1 1,
p L2 2,
p L3 3,
p L4 4,
p L5 5,
1   2    3    4     5     6     7     8     9     10
ªD
D
D
D
a x1 x2 x3
ª
ª
ª
ª
^
^
^
^
^
D ª
Figure 7: There are 5 branches and (p1, p2, p3, p4, p5) = (2, 3, 2, 1, 5). The content of each
L̂i is represented by a number of ♠’s on the same row. There is a maximum conflict at
α = 3; D = {1, 2, 3, 4}. The smallest 3 free labels bigger than α are 4, 6 and 7. Assigning
4, 6, and 7 to branches 1, 3, and 4, respectively, (in any order) resolves the conflict, while
minimizing lexicographically the visible labels left.
5 555
7
8
2 2 3 1 4
5 555
7
8
6 9 10 1 4
5 555
7
8
2 2 3 1 4
9
76 8
(a) (b) (c)
Figure 8: (a)A block tree TB where L1 = {2, 5}, L2 = {2, 5}, L3 = {3, 5}, L4 = {1, 5} and
L5 = {4, 7, 8}. A conflict occurs at α = 5; D = {1, 2, 3, 4}. The smallest d− 1 free labels
bigger than α are {6, 9, 10}. (b)Applying the simple strategy to resolve the conflict would
assign 6, 9, 10 to branches 1, 2, 3, respectively. (c)A better way to resolve the conflict is
first to label branch 5 with 9.
44
