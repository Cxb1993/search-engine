Witnessing this progressive advancement, the IoT 
applications have to be brought closer into 
telecommunication industry. IoT application has to be 
standardized and seamlessly integrated in 
telecommunication network system. IP multimedia sub-
systems (IMS) has successfully show its capability to 
bring internet service network into telecommunication 
networks. IMS allows application deliverability in a 
standardized and measureable manner to allow QoS 
operation, charging system and provider policy for 
overall network operation. Above all those aspects 
service delivery of IoT applications have to 
consistently fulfill users’ demand and satisfaction 
where Quality of Service (QoS). 
 
In the first year of this project we have 
successfully conducted a preliminary research of IoT-
IMS platform as a breakthrough for next generation 
communications network application enrichment. A 
IMS+ID platform is designed for a framewor for IMS 
capability extension for IoT object identification 
system as standardized operation management for IoT 
networks, which eventually allows QoS treatment for 
each IoT application. The IMS+ID are implemented by 
integrating the Fostrak middleware service into HSS 
module at IMS on cloud computing system. Therefore 
IoT gateway will be able to discover any object at 
any event, identify them and post their service to 
IoT application layer with medical application 
implementation. The identified object then will 
trigger Policy and Charging Rules Function (PCRF) 
function base on event classification from IoT 
perception layer to manage the IoT traffic priority 
based on application scenario. IoT gateway 
functionality embedded on mobile device is 
constructed to enable event signature function to 
identify the object ID and its characteristics. 
英文關鍵詞： Internet of Things, IP Multimedia Subsystem, Quality 
of Service, Policy and Charging Rules Function, 
Perception Layer 
 
 第 2 頁 / 共 78 頁 
telecommunication network system. IP multimedia 
sub-systems (IMS) has successfully show its capability 
to bring internet service network into telecommunication 
networks. IMS allows application deliverability in a 
standardized and measureable manner to allow QoS 
operation, charging system and provider policy for 
overall network operation. Above all those aspects 
service delivery of IoT applications have to consistently 
fulfill users’ demand and satisfaction where Quality of 
Service (QoS). 
 
In the first year of this project we have successfully 
conducted a preliminary research of IoT-IMS platform as 
a breakthrough for next generation communications 
network application enrichment. A IMS+ID platform is 
designed for a framewor for IMS capability extension for 
IoT object identification system as standardized 
operation management for IoT networks, which 
eventually allows QoS treatment for each IoT application. 
The IMS+ID are implemented by integrating the Fostrak 
middleware service into HSS module at IMS on cloud 
computing system. Therefore IoT gateway will be able to 
discover any object at any event, identify them and post 
their service to IoT application layer with medical 
application implementation. The identified object then 
will trigger Policy and Charging Rules Function (PCRF) 
function base on event classification from IoT perception 
layer to manage the IoT traffic priority based on 
application scenario. IoT gateway functionality 
embedded on mobile device is constructed to enable 
event signature function to identify the object ID and its 
characteristics. 
 
Keywords: Internet of Things, IP Multimedia Subsystem, 
Quality of Service, Policy and Charging Rules Function, 
Perception Layer  
二、 緣由與目的 
隨著網際網路的蓬勃發展，未來網際網路除了以
標準的通訊協定整合電腦網路外，將由 IoT (Internet of 
Things)、 IoM (Internet of Media)、 IoS (Internet of 
Services)、IoE (Internet of Enterprises)等所組成，其中
IoT 更被視作最重要的基礎技術，可以使人們及裝置
(Thing)在任何時間(Anytime)、任何地點(Anyplace)與
任何裝置(Anything)、任何人(Anyone)溝通，並且妥善
地透過網路(Any path/Network)取得所需的服務(Any 
Service)。然而在 IoT 環境中，大量物件於傳遞訊息過
程中，將可能影響整體效能的問題，例如無線網路之
安全性、服務品質、資源管理、行動通訊電力耗損與
高錯誤率等問題。如繼續維持原有運作架構，勢必會
影響未來網際網路環境的整體執行效能。以下針對幾
項重要影響效能課題說明之。 
 
1.Quality-of-Service (QoS)：將 QoS 技術運用於未來網
際網路中較具挑戰性，其挑戰包括因頻寬之變動、IoT 
裝置與傳輸網路之間 Handoff 問題，嚴重影響封包之
傳 遞 ， 使 得 未 來 網 際 網 路 中 的 IoT Real-time 
Applications 相當容易受到各種外在因素影響，而無
法保證服務品質。現行的網路服務可以區分為 Best 
Effort Service 和 Real-Time Service。面對 Best Effort 
Service，如 FTP 協定的檔案傳輸、HTTP 協定的網頁
資料傳輸，此類服務於一段時間內完成工作即可；而
Real-Time Service，如語音訊息及影音資料，其服務品
質較具即時性的需求，頇在限定的時間內完成工作。
在現今的網路環境下，IoT 系統無法動態地針對不同
需求提供適當的服務，造成 QoS 之機制無法滿足使用
者需求。在一般的有線網路環境中，封包傳輸處於「最
佳效率」的狀態，此狀態賦予 Application 所需的網路
頻寬，但不會依據頻寬的可用性和網路的堵塞情形，
予以任何的品質保證，此項課題使得未來網際網路中
Real-time IoT Applications 服務之 QoS 無法確保。 
 
2.Resource Management：隨著未來網際網路的實現，
家庭、校園及中小企業裡所使用的 IoT 設備與日俱增，
被管理的裝置遍佈於環境的各個角落，因此需要一有
效率的管理方式。若是以近端管理方式，則必頇走訪
每一台 IoT 物件裝置來進行配置修改和效能監控，此
方式既耗時又耗力；若是透過遠端管理的方式，從單
 第 4 頁 / 共 78 頁 
用戶環境，指定QoS。IMS中「智慧型」的QoS Request，
被稱為政策決策功能 (Policy Decision Function，簡稱
PDF)模組(運作架構如圖三所示)，PDF 模組與基礎分
封網路互動，並控制基礎分封網路資源分配(透過 Go 
Interface 至 GGSN) [13-15]。 
 
圖三：IMS Policy Decision Function 運作架構 
 
  在 IMS 通訊標準中，明確規範 QoS 參數可在兩
個 UE (User Environment)的 Session 建立前，就進行協
商動作。其目的在於檢查兩個 UE 之間的各段連線是
否有足夠的Resource可供運用，當QoS參數被確認後，
IMS Network 則會要求 Core Network 及 Access 
Network 為該 Session 保留 Resource。其中 SIP INVITE
及 UPDATE Messages 的運作流程，如圖四所示[16, 
17]。 
 
  當 UE1 對 UE2 發出 INVITE Message 時，該
Message 會夾帶 QoS Proposal (request)，此 QoS 
Proposal 則 會 分 別 於 UE1 及 UE2 的
S-CSCF(Serving-Call Session Control Functions)檢查其
Subscription Level，並確定 QoS 參數。其後，UE2 會
回傳其所屬之 QoS Proposal，此 QoS Proposal 也會於
UE1 及 UE2 之 S-CSCF 檢查 Subscription Level，並根
據此 Level 確定 QoS 參數。最後，UE1 會接收 UE2
的 QoS Proposal，並開始建立 Session 或是根據 SIP 
UPDATE Message 做出 Renegotiate 的動作。透過 SIP 
Message 傳遞 QoS 參數，使得 Session Data 得以藉由
Session Description Protocol (SDP)傳輸[18]。 
 
圖四：IMS Pre-session QoS Negotiation 的運作流程 
 
3.2 Internet of Things (IoT) 
物聯網，顧名思義為網就是物物相連的網際網路
應用。這有兩層意義：第一，物聯網的核心和基礎仍
然是網際網路，其服務應用是在網際網路基礎上的延
伸和擴展；第二，應用延伸至物品與物品之間，可進
行資訊交換和通信。因此，物聯網的定義是透過射頻
識別（RFID）及紅外感應器等資訊傳感設備，把任何
物品與網路相連接，進行資訊交換和通信，以實現對
物品的智慧化識別、定位、跟蹤、監控和管理應用。 
 
物聯網上部署了大量的多種類型感測器，每個感
測器都是一個資訊收集元件，不同類別的感測器所收
集的資訊內容和資訊格式不同。感測器獲得的資料具
有即時性，可依週期性採集環境資訊。 
 
其次，物聯網技術的重要基礎和核心仍為是網際
網路，透過各種有線和無線網路與網際網路融合，將
物體的資訊即時準確地傳遞出去。在物聯網上的感測
器定時採集的資訊需要通過網路傳輸，由於其數量極
其龐大，形成了大量資訊，在傳輸過程中，為了保障
 第 6 頁 / 共 78 頁 
原則相結合，延伸其應用。 
 
EPC 系統的提出源自於射頻識別技術和電腦網路
技術的發展。EPC 標籤是這一代碼的載體，當 EPC 
標籤貼在物品上或內嵌在物品中的時候，即將該物品
與 EPC 標籤中的唯一代碼建立起了一對一的對應關
係。EPC 系統充分利用了射頻識別技術和網路技術的
優點，有效的解決對全球每一件產品的唯一標識問題
以及同時識別多個商品和非可視識別問題。 
 
全球產品電子代碼的編碼體系 EPC 系統是一個
非常先進的、綜合性的和複雜的系統。其最終目標是
為每一單品建立全球的、開放的標識標準。它由全球
產品電子代碼體系、射頻識別系統及資訊網路系統三
部分組成，主要包括六個方面如下表一所示。 
表一: EPC 系統的架構 
 
 
EPC Network 架構 
    EPC Network 建構了 RFID 的資訊網路，透過標
準的  EPC 碼和網路應用程式的整合，在  EPC 
Network 架構中， EPC 碼是 RFID 標籤內的一個代
碼，用以辨識單一物件，亦可以代表是一個全球的識
別標準，經由讀取器以及資訊網路，並透過介面軟體
與使用者應用系統連結。RFID 之 EPC 標準 EPC 
Network 是由下列五大要素所共同組成，各別說明分
別如下： 
 
(1) Electronic Product Code（EPC）：  
所謂的 EPC(Electronic Product Code)，是指在供
應鏈系統中以一串數字識別特定一項物品，再經由 
RFID 的 Reader 讀取 Tag，Reader 將這串數碼傳送
到電腦或是應用系統中。事實上，RFID 與條碼是完
全不同的技術，RFID 本身具有自己的領域及特性，
並非是為了取代條碼的。Auto ID Center 最初研發的
目的，主要是希望以 RFID 技術來彌補以往傳統條碼
所不足的功能而不是取代。如此，RFID 之 EPC 標
準的 EPC 碼與 EAN.UCC 條碼系統在設計上，彼此
相容並可以相互轉換，經由十六進位法轉換成 EPC
碼，亦能保留各系統原來所使用的需求特色。 
 
(2) Savant：  
RFID 分散式網路架構的概念最初的提案是經
由 Auto-ID Center 提出，並把這 Middleware 原件組
成在  EPC Network 中，命名為  Savant。Auto-ID 
Center 更在 2003 年 9 月發表了 「Auto-ID Savant 
Specification 1.0」的 Middleware 技術規範架構，因
應 EPC 標準的制定， RFID Middleware 未來發展也
需納入標準資料之處理，該技術規範也針對 RFID 應
用 EPC 的議題，並訂出 EPC Network 技術架構。
Reader 將不斷接收一連串的 EPC 碼，整個過程中最
重要也是最困難的環節就是傳送和管理這些作業和應
用系統之間的中介軟體（Middleware）負責收集、儲
存RFID讀寫器發射的 EPC資訊並採取相對應行動，
當 Reader 處理讀入 Tag 的資料，Savant 從 Reader 送
來的 EPC 辨識碼之後，把 EPC 碼當成輸入，送到
各處的 ONS 提出詢問，ONS 以查尋此項辨認碼所代
表的產品種類以及產品資訊，找尋對應 EPC 碼的產
品資料位址後回覆給 Savant。而 Savant 亦會在組織內
不同位置的電腦移動，管理並傳送資訊，防止系統與
網路的超載（Overload）。 
 
(3) Object Name Service（ONS）： 
物件命名服務（Object Name Service，ONS）功
能為物件資料查詢服務，當 Tag 中的 EPC  碼被讀取，
ONS 即時找尋該號碼所對應的產品資訊，ONS 伺服
器像電話簿一般提供 EPC 碼與 EPC 伺服器對照的
功能，如同 Internet 中的區域名稱伺服器（Domain 
Name Service，DNS），協助電腦找尋 Internet 的網站
一般，ONS 的功能為連結實體物件與相關資訊。當 
Reader 在讀取一個 EPC 的 Tag 時，EPC 號碼即被輸
入 Savant 中，接著到一個 Local Network 或 Internet 
的 ONS 系統中查詢該項產品資訊存放在何處。 
系統構成 名稱 說明
全球產品電子代
碼的編碼體系
EPC編碼標準 識別目標的特定代碼
EPC編籤
貼在物品之上或者內嵌在物
品之中
讀取器 讀取EPC標籤
EPC中間件 EPC系統的軟體支援系統
商品命名服務
 (Object Naming Service：ONS)
實體標記語言
（Physical Markup Language PML）
射頻識別系統
資訊網路系統
 第 8 頁 / 共 78 頁 
目前已有 Object Event、Aggregation Event、
Quantity Event、和Transaction Event共四種型態．
每種事件型態都有其衍伸的資料欄位。 
3. 服務層：EPCIS 提供兩項核心服務－Capture 
Interface 及 Query Interface．EPCIS 藉由 Capture 
Interface 捕捉在真實世界發生的 EPC Event，由
Query Interface 負責處理 EPCIS 的查詢請求並回
傳相關資料。Bindings：其目的在於連結資料定
義層與服務層的元件好讓 EPCIS 具有資料分享
的能力．資料定義層中的各個事件資料型態均有
相對應之 XML schema；服務層的 Capture 
Interface 對應的是 Message Queue 及 HTTP；
Query Control Interface 被賦予 WSDL（SOAP 
over HTTP）和 AS2；Query Callback Interface 則
是 HTTP、HTTPs 以及 AS2。 
 
四、 研究方法 
    以下介紹本研究所提出相關模組設計以及
IoT-IMS 通訊平台網路之 Operation 與 Administration
系統提供之 Application Classifier 機制功能。 
 
4.1 IoT-IMS Architecture 
    因為 Fosstrak 軟體提供很多 RFID系統部署的核
心組成部分，例如事件資料庫，過濾 RFID 資料
(Edgeware)和標籤數據的收集。開發者能在他們的部
署過程中獨立並倚賴 Fosstrak 標準組成部分的軟體。
其 Fosstrak ALE 中介軟體可以讓你從多個 RFID 讀寫
器收集並過濾資料。 
 
圖七: Fosstrak ALE 結構 
    Fosstrak ALE 中介軟體包含了三個獨立組件： 
 篩選和收集伺服器 --filtering and collection 
server 
 一個用於配置篩選和收集伺服器的獨立用戶
端。 
 一個用於配置篩選和收集伺服器的 web 用戶
端。 
    所有的元件都是按照 EPCglobal's ALE 1.1 規範
進行實現的。為了與 RFID 讀寫器進行通信，Fosstrak 
ALE 仲介軟體使用了 LLRP 協議。對於不支援 LLRP
協定的讀寫器，ALE 仲介軟體使用了 Forsstrak 硬體抽
象層（HAL）。為了配置支援 LLRP 協定的 RFID 讀寫
器，提供了 Fosstrak LLRP Commander 進行使用。 
 
    為了使 IMS 架構及 OpenIMS 之用戶服務器
（ Home Subscriber Server, HSS）啟動驗證功能，因此
必須與 EPCIS 架構有相關聯性。在通用的 OpenIMS
平台，HSS 是存在 UE 的資料庫，所以該資料庫將被
應用於與物件溝通的過程。本計畫了解用戶終端（IoT 
Gateway）與 IMS+ ID 的架構會與周圍的物體溝通連
結動作，這一機制是從感知層發現的序列步驟。當物
聯網 Gateway 和一個特定的對象作配對，Gateway 將
獲得物件的 UUID，然後藉由查詢 UUID 連結至
Fosstrak 平台的 RDBMS。在此同時，OpenIMS 的 HSS
將於用戶終端 Gateway 增加 object_UUID 於 HSS 資料
庫表格。  HSS 的資料庫表格存儲與應用伺服器
（Application Server, AS）關聯的用戶資料。 
 
    然而，本計畫所採用的方法，RDBMS 將查詢 ONS
以獲得相關服務，然後 URI 再連結 HSS 資料庫獲得
應用服務的對應資料。因此，每次 IoT Gateway 發現
連接到特定的物件對象時，皆需調用 HSS 資料庫的相
關資料。 
 第 10 頁 / 共 78 頁 
輪循服務請求機制，如減少複雜的排程規劃。為找到
一個解決辦法是需耗費資源的，如所需資源的計算是
如此費時，沒有用戶會真正等待其結果。然而，一個
被丟棄的連接不會停止在應用服務器的能源耗損。此
外，用戶將看到被丟棄的連接需求並極有可能會重新
發起請求。這個應用服務器不需額外的改變，解決辦
法是使用HTTP連接的連接超時。然而，當用戶發送一
個請求服務，卻無法得知結果，對於網路可用性的角
度而論，這是一個不能被接受的方法。 
 
(4) Decomposable delayed services 
第四類是可分解的延遲服務。將請求分解為子服
務，待各子服務回覆後，再重組為完整之答覆。 
 
五、 結果與討論 
以下介紹本研究的系統效能分析，以及相關實作
的成果。 
 
5.1 實作成果 
圖十為 IoT-IMS Database Schema，管理者可隨時
監控 Sensor 裝置的使用狀態，以使用者為主體導引出
Device 的相關資訊，利於使用者維持系統之運作。 
 
 
圖十: IoT-IMS Database Schema 
 
    圖十一為 IoT-IMS Parameter Database 介面，透過
此介面管理者可以了解使用者帳戶所對應之 Sensor資
訊，如使用者之生理狀態和Senor使用的時間等資訊，
並也將資料送到後端資料庫存放(MySQL Database)，
便於了解使用者所使用的服務資源等訊息。 
 
圖十一: IoT-IMS Parameter Database 
 
圖十二為透過 Monitor.o 功能模組，使 PCEF 可
得知目前擷取到的 IP 流量，自動判斷是否超過管理者
所設定之最大頻寬，再透過 iptable 語法寫進程式，即
能成功控制防火牆 terminate 此用戶。 
 
圖十二: 判斷是否超過最大頻寬 
 
5.2 效能分析 
 第 12 頁 / 共 78 頁 
 
六、 計畫成果自評 
     
本計畫第一年已使 IoT-IMS 營運管理可擴展為第二年
可提供 QoS 管理架構。本計畫創造了一個具有識別能
力的 IMS 綜合平台，讓通用的 IMS 平台辨識透過特
定移動之物聯網 Gateway 設備對象。 EPCIS Fosstrak
的 RDBMS 與 HSS 連結以擴大相關聯的服務對象。
該平台建構在 vSphere 的雲端平台，讓簡單的系統管
理可在同一時間進行確認與管理資源的QoS分配關係。
本計畫第一年的測試平台進行了物聯網的健康和醫療
應用服務層評估之物件識別和物聯網的應用程序類型
的能力。 
 
 
七、 參考文獻 
 
[1] J. Choi, Kihong Park and C.K. Kim, “Analysis of 
Cross-Layer Interaction in Multirate 802.11 
WLANs,” IEEE Transactions on Mobile Computing, 
Vol. 8, No. 5, pp. 682-693, May 2009. 
[2] B.J. Chang and J.F. Chen, “Cross-Layer-Based 
Adaptive Vertical Handoff with Predictive RSS in 
Heterogeneous Wireless Networks,” IEEE 
Transaction on Vehicular Technology, Vol. 57, No. 
11, pp. 3679-3692, Nov. 2008. 
[3] F. Foukalas, V. Gazis and N. Alonistioti, 
“Cross-Layer Design Proposals for Wireless Mobile 
Networks: a Survey and Taxonomy,” IEEE 
Communications Survey & Tutorials, Vol. 10, No 4, 
pp. 70-85, Apr. 2008. 
[4] C. Xiangqian, K. Makki, Y. Kang and N. Pissinou, 
“Sensor Network Security: a Survey,” IEEE 
Communications Surveys & Tutorials, Vol. 11, No. 2, 
pp. 52-73, Apr. 2009. 
[5] W.L. Benjamin, J.F. Colin and A.C. David, 
“Cross-Layer Verification of Type Flaw Attaches on 
Security Protocols,” Proceedings of ACM 13th 
Australasian Conference on Computer Science, Vol. 
62, pp. 171-180, 2007. 
[6] H. Ekstrom, “QoS control in the 3GPP evolved 
packet system,” IEEE Communications Magazine, 
Vol. 47, No. 2, pp. 76-83, Feb. 2009. 
[7] P. Bellavista, A. Corradi and L. Foschini, “IMS-based 
Presence Service with Enhanced Scalability and 
Guaranteed QoS for Interdomain Enterprise 
Mobility,” IEEE Wireless Communications, Vol. 16, 
No. 3, pp. 16-23, Jun. 2009. 
[8] Y.T. Mai, C.C. Yang and Y.H. Lin, “Cross-Layer QoS 
Framework in the IEEE 802.16 Network,” 
Proceedings of the 9th International Conference on 
Advanced Communication Technology, Vol. 3, pp. 
2090-2095, Feb. 2007. 
[9] M.S. Siddiqui, R.A. Shaikh and C.S. Hong, “QoS 
Control in Service Delivery in IMS,” Proceedings of 
the 11
th
 Interational Confernece on Advanced 
Communication Technology, Vol. 1, pp. 157-160, 
Feb. 2009. 
[10]M.K. Denjo, E. Shakshuki and H. Malik, “A 
Mobility-Aware and Cross-Layer Based Middleware 
for Mobile Ad Hoc Networks,” Proceedings of the 
21
th
 International Conference on Advanced 
Networking and Applications, pp. 474-481, 2007. 
[11] M. Chang, M. Lee and H. Lee “Per-Application 
Mobility Management with Cross-Layer Based 
Performance Enhancement,” IEEE Wireless 
Communications and Networking Conference, pp. 
2822-2827, March 2008. 
[12] V.C.M. Leung, J. Zhang, F.R. Yu, H.C.B. Chan and 
H. Tang, “Enhancing Interoperability in 
Heterogeneous Mobile Wireless Networks for 
Disaster Response,” IEEE Transactions on Wireless 
Communications, Vol. 8, No. 5, pp. 2424-2433, May 
2009. 
[13] L. Lifeng and L. Gang, “Cross-Layer Mobility 
Management based on Mobile IP and SIP in IMS,” 
Proceedings of the International Conference on 
Wireless Communications, Networking and Mobile 
Computing, pp. 803-806, Sep. 2007. 
[14] M.A. Melnyk, A. Jukan and C.D. Polychronopoulos, 
“A Cross-Layer Analysis of Session Setup Delay in 
IP Multimedia Subsystem (IMS) with EV-DD 
Wireless Transmission,” IEEE Transactions on 
Multimedia, Vol. 9, No. 4, pp. 869-881, Jun. 2007. 
[15] A. Anzaloni, M. Listanti and I. Petrilli, 
“Performance Study of IMS Authentication 
Procedures in Mobile 3G Networks,” Proceedings of 
the International Conference on Wireless 
Communications and Mobile Computing, pp. 
248-253, 2007. 
[16] W.K. Chiang, A. Ren and Y.C. Chung, "Integrating 
SIP-Based Network Mobility into IP Multimedia 
Subsystem," Proceedings of the IEEE Wireless 
Communications and Networking Conference, 
pp.1-6, 5-8 April 2009. 
[17]M.S. Siddiqui, S.O. Amin and C.S Hong, “A Set-Top 
Box for End-to-End QoS Management and Home 
Network Gateway in IMS,” IEEE Transactions on 
Consumer Electronics, Vol. 55, No. 2, pp. 527-534, 
May 2009. 
[18]K.S. Munasinghe and A. Jamalipour, “Interworked 
WiMAX-3G Cellular Data Networks: An 
Architecture for Mobility Management and 
Performance Evaluation,” IEEE Transactions on 
Wireless Communications, Vol. 8, No. 4, pp. 
1847-1853, Apr. 2009. 
[19] Q. Zhang and Y.Q. Zhang, “Cross-Layer Design for 
QoS Support in Multihop Wireless Networks,” 
Proceedings of the IEEE, Vol.96, No.1, pp.64-76, 
Jan. 2008. 
[20] B. Zamani, M. Mohammadi, A. Jalalvand, R. 
 第 14 頁 / 共 78 頁 
Knowledge and Data Engineering, Vol. 21, No. 6, 
pp. 814-828, Jun. 2009. 
[45] L. Busoniu, R. Babuska and B.D. Schutter “A 
Comprehensive Survey of Multiagent 
Reinforcement Learning,” IEEE Transactions on 
Systems, Man and Cybernetics, Part C: Applications 
and Reviews, Vol. 38, No. 3, pp. 156-172, Mar. 
2008. 
[46] V. Mahulkar, S. McKay, D.E. Adams and A.R. 
Chaturvedi, “System-of-Systems Modeling and 
Simulation of a Ship Environment with Wireless and 
Intelligent Maintenance Technologies,” IEEE 
Transactions on Systems, Vol. 39, No. 6, pp. 
1255-1270, Nov. 2009. 
[47] J Oscar and L Romero, “Self-Organized and 
Evolvable Cognitive Architecture for Intelligent 
Agents and Multi-agent Systems,” Proceedings of 
the International Conference on Computer 
Engineering and Applications (ICCEA), Vol. 1, pp. 
417-421, Nov. 2010. 
[48] A. Batool, A. Fardin and M. Parham, “A 
Multi-Agent Based Personalized Meta-Search 
Engine Using Automatic Fuzzy Concept Networks,” 
Proceedings of the International Conference on 
Knowledge Discovery and Data Mining, pp. 
208-211, Apr. 2010. 
[49] C. Xian-yi, L. Ying and Q. Jian-lin, “Cooperative 
Learning Based on Multi-Agent Systems,” 
Proceedings of the International Conference on 
Knowledge Discovery and Data Mining, pp. 
455-457, March 2010. 
[50] J. Yoon, K. Oh, C. Nam and D. Shin, “Agent-based 
Sensor Network Middleware using Reputation 
Mechanism over Heterogeneous Network 
Environments,” Proceedings of the International 
Conference on Computer and Automation 
Engineering (ICCAE), Vol. 2, pp. 373-376, April 
2010. 
[51] H. Al-Sammarraie, A. Merza, A. Shakeel and M. 
Adli, “Intelligent Agent System Architecture for 
Presenting Health Grid Contents from Complex 
Database,” Proceedings of the International 
Conference on Intelligent Systems, Modelling and 
Simulation (ISMS),pp. 38-42, Feb. 2010. 
[52] S. Arnon, D. Dov and S. Onn, “An 
Object-Process-Based Modeling Language for 
Multiagent Systems,” IEEE Transactions on Systems, 
Man, and Cybernetics, Part C: Applications and 
Reviews, Vol. 40, No. 2, pp. 227-241, Feb. 2010. 
[53] S. Liu, S. Wu and J.L. Chen, "Adaptive Cross-layer 
QoS Mechanism for Cognitive Network 
Applications," Proceedings of IEEE 12
th
 
International Conference on Advanced 
Communication Technology (ICACT), Vol. 2, pp. 
1389-1393, Feb. 2010. 
[54] R. Sunku, G.P. Rohan, M. Pande and D. Das, 
"Offline Charging for Multimedia Blended Services 
Using Service Capability Interaction Manager in 
IMS Network," Proceedings of the International 
Conference on Internet Multimedia Services 
Architecture and Application (IMSAA) , pp.1-6, 
March 2011. 
[55] A. Sarajlic and A. Sarajlic, "Definition, Analytical 
Derivation and Optimization of the Lower Credit 
Limit in Mobile User’s Prepaid Account for IMS 
Services," Proceedings of the International 
Conference on Information Technology Interfaces 
(ITI), pp.563-570, Aug. 2011. 
 
 第 16 頁 / 共 78 頁 
 
 /** 
      * this loads the necessary policies and 
invokes policy processor blocks based on priorities and 
trigger points 
 * and installs the created policy rule 
 * @param service information 
      */ 
 public int authorisation_request(String af_session, 
Vector ip_flows, Vector codecs) throws IOException  
 { 
  int result_code = -1; 
  /**Get policy profile information*/ 
  /**policy name; priority; trigger point*/ 
  Vector policy_vector = new Vector(); 
  for (int a = 0; a < policies.length; a++) 
  { 
   if(policies[a] != null) 
   { 
    String policy_info = policies[a] + 
";"; 
    String profile_loc = 
"/opt/OpenIMSCore/uctpcrf/policies/" + "profile_" + 
policies[a] + ".xml"; 
    //read policy profile information 
    Document doc = null; 
    DocumentBuilderFactory dbf = 
DocumentBuilderFactory.newInstance(); 
    try { 
      
     //Using factory get an 
instance of document builder 
     DocumentBuilder db = 
dbf.newDocumentBuilder(); 
      
     //parse using builder to get 
DOM representation of the XML file 
     doc = 
db.parse(profile_loc); 
      
   
   
 }catch(ParserConfigurationException pce) { 
     pce.printStackTrace(); 
    }catch(SAXException se) { 
     se.printStackTrace(); 
    }catch(IOException ioe) { 
     ioe.printStackTrace(); 
    }  
    Element docEle = 
doc.getDocumentElement(); 
    
    //get all policy information into 
vector format 
    NodeList nl = 
docEle.getElementsByTagName("priority"); 
    if(nl != null && nl.getLength() > 
0) { 
     Element priority = 
(Element)nl.item(0); 
     policy_info = policy_info 
+ priority.getFirstChild().getNodeValue().toString() + 
";"; 
    } 
  
    nl = 
docEle.getElementsByTagName("trigger_point"); 
    if(nl != null && nl.getLength() > 
0) { 
     Element trigger_point = 
(Element)nl.item(0); 
     NodeList nl1 = 
trigger_point.getElementsByTagName("media"); 
     if(nl1 != null && 
nl1.getLength() > 0) 
     { 
      Element media = 
(Element)nl1.item(0); 
 第 18 頁 / 共 78 頁 
    if(status == 
Constants.FlowStatus.ENABLED) 
    { 
     /**Send DIAMETER RAR 
remove message via Gx*/ 
     DiameterMessage rar = 
createRAR(session_id,dest_realm,PCC_rule_name,sourc
e_ip,dest_ip,source_port,dest_port,QoS_class,bw_ul,bw_
dl,guaranteed_br_ul,guaranteed_br_dl,1); //command - 1 
remove 
     System.out.println(); 
    
 System.out.println("-------------------------------------
-------------"); 
     System.out.println(); 
     System.out.println("INFO: 
Sending DIAMETER RAR message to PCEF"); 
     pcef_address = 
policyEngine.getPCEF(orig_realm,dest_realm); 
     DiameterMessage raa = 
diameterPeer.sendRequestBlocking(pcef_address,rar); 
     if (raa==null)  
     { 
     
 System.out.println("INFO: Time out waiting for 
PCEF RAA via Gx"); 
      result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
      return result_code; 
     } 
     else  
     { 
      System.out.println(); 
     
 System.out.println("INFO: Received DIAMETER 
RAA message from PCEF"); 
      if 
(raa.commandCode == Constants.Command.RAA) 
      {  
       AVP 
result_code_avp = 
raa.findAVP(Constants.AVPCode.RESULT_CODE,true, 
Constants.Vendor.DIAM); 
      
 if(result_code_avp != null) 
       { 
       
 result_code = result_code_avp.int_data; 
       
 if(result_code == 
Constants.ResultCode._DIAMETER_SUCCESS) 
        { 
        
 System.out.println("INFO: Result code SUCCESS 
received from PCEF"); 
        } 
        else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_INITIAL
_PARAMETERS) 
        { 
        
 System.out.println("INFO: Result code INVALID 
INITIAL PARAMETERS received from PCEF"); 
        
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        
 return result_code; 
        } 
        else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_TRIGGE
R_EVENT) 
        { 
        
 第 20 頁 / 共 78 頁 
      highest_priority_tag 
= a; 
     } 
     
    } 
    //policy with highest priority is 
policy_vector(a) 
    //create policy processor block 
for this policy 
    //pass info to this processor block 
and result code in return 
    //if result success enforce IP 
Flows 
    //then remove policy from policy 
vector 
    st = new 
StringTokenizer(policy_vector.get(highest_priority_tag).
toString(),";"); 
    String policy = st.nextToken(); 
    st.nextToken(); 
    String trigger_point = 
st.nextToken(); 
   
 if(policy.equals("domain_policies"))  
    { 
    
 if(trigger_point.equals("ANY")) 
     { 
     
 DomainPolicyProcessor dpp = new 
DomainPolicyProcessor(diameterPeer, policy_db, policy, 
username, password, remote_xcap_server); 
      result_code =  
dpp.authorisation_request(af_session, ip_flows, codecs); 
      
     } 
    } 
    
   
 policy_vector.removeElementAt(highest_priority_t
ag); 
 
    /**TO DO Add support to create 
dynamic Policy Processor Blocks*/ 
    //ADD new policy processor 
blocks here - remember to check the trigger points for 
each IP Flow which determine whether that policy 
should be called 
 
   } 
 
   /**To enforce ENABLED IP Flows in 
the bearer level*/ 
   if (result_code == 
Constants.ResultCode._DIAMETER_SUCCESS) 
   { 
    result_code = 
enforce_IP_Flows(ip_flows, orig_realm, dest_realm); 
   } 
   if (result_code == 
Constants.ResultCode._DIAMETER_SUCCESS) 
   { 
    System.out.println("\nINFO: The 
Request is Successful. The new session has ID : " + 
session_id); 
   } 
  } 
  return result_code; 
 } 
 
 /** 
      * This methods check through a session IP 
Flows and enforces those marked ENABLED in the 
bearer level 
 * @param ip_flows all IP Flows assocaited with 
IMS session 
 * @param orig_realm the realm or domain of the 
orginating user 
 第 22 頁 / 共 78 頁 
ATION; 
     return result_code; 
    } 
    else  
    { 
      
     if (raa.commandCode == 
Constants.Command.RAA) 
     {  
      System.out.println(); 
     
 System.out.println("INFO: Received DIAMETER 
RAA message from PCEF"); 
      AVP 
result_code_avp = 
raa.findAVP(Constants.AVPCode.RESULT_CODE,true, 
Constants.Vendor.DIAM); 
     
 if(result_code_avp != null) 
      { 
       result_code = 
result_code_avp.int_data; 
       if(result_code 
== Constants.ResultCode._DIAMETER_SUCCESS) 
       { 
       
 System.out.println("INFO: AAR Result code 
SUCCESS received from PCEF"); 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_INITIAL
_PARAMETERS) 
       { 
       
 System.out.println("INFO: AAR Result code 
INVALID INITIAL PARAMETERS received from 
PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_TRIGGE
R_EVENT) 
       { 
       
 System.out.println("INFO: Result code TRIGGER 
ERROR EVENT received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_PCC_RULE_EVE
NT) 
       { 
       
 System.out.println("INFO: Result code PCC 
RULE EVENT received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
       { 
       
 第 24 頁 / 共 78 頁 
       { 
       
 System.out.println("INFO: AAR Result code 
INVALID INITIAL PARAMETERS received from 
PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_TRIGGE
R_EVENT) 
       { 
       
 System.out.println("INFO: Result code TRIGGER 
ERROR EVENT received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_PCC_RULE_EVE
NT) 
       { 
       
 System.out.println("INFO: Result code PCC 
RULE EVENT received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
       { 
       
 System.out.println("INFO: Unknown Result Code 
received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
      } 
     } 
    } 
    System.out.println("INFO: IP 
Flow with flow id: " + flow_id + " is being removed 
from the bearer level"); 
   } 
   else 
   { 
    System.out.println("INFO: Flow 
status not yet recognised"); 
    result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
    return result_code; 
   }    
  } 
  if(result_code == 
Constants.ResultCode._DIAMETER_SUCCESS) 
  { 
   System.out.println("INFO: IP Flows 
associated with IMS session have been successfully 
processed"); 
  } 
 第 26 頁 / 共 78 頁 
  
    nl = 
docEle.getElementsByTagName("trigger_point"); 
    if(nl != null && nl.getLength() > 
0) { 
     Element trigger_point = 
(Element)nl.item(0); 
     NodeList nl1 = 
trigger_point.getElementsByTagName("media"); 
     if(nl1 != null && 
nl1.getLength() > 0) 
     { 
      Element media = 
(Element)nl1.item(0); 
      policy_info = 
policy_info + 
media.getFirstChild().getNodeValue().toString(); 
     } 
    } 
    policy_vector.add(policy_info); 
   } 
  } 
 
 
  //remove IP flows from bearer level 
  Vector current_ip_flows  = 
policyEngine.getIPFlows(session_id); 
  for (int b = 0; b < current_ip_flows.size(); 
b++) 
  { 
   int avail_QoS_ul = 0; 
   int avail_QoS_dl = 0; 
   st = new 
StringTokenizer(current_ip_flows.get(b).toString(),";"); 
   session_id = st.nextToken(); 
   session_id = session_id + ";" + 
st.nextToken(); 
   session_id =  session_id + ";" + 
st.nextToken(); 
   String flow_id = st.nextToken(); 
   String source_ip = st.nextToken(); 
   String dest_ip = st.nextToken(); 
   int dest_port = 
Integer.valueOf(st.nextToken()).intValue(); 
   int source_port = 
Integer.valueOf(st.nextToken()).intValue(); 
   int usage = 
Integer.valueOf(st.nextToken()).intValue(); 
   int status = 
Integer.valueOf(st.nextToken()).intValue(); 
   int bw_ul = 
Integer.valueOf(st.nextToken()).intValue(); 
   int bw_dl = 
Integer.valueOf(st.nextToken()).intValue(); 
   int QoS_class = 
Integer.valueOf(st.nextToken()).intValue(); 
   int guaranteed_br_ul = bw_ul; 
 //defaults to same as max 
   int guaranteed_br_dl = bw_dl;
 //defaults to same as max 
   String PCC_rule_name = session_id + 
";" + flow_id; 
      
   String pcef_address = ""; 
   /**Only send DIAMETER RAR 
remove message if flow is already enabled*/ 
 
   if(status == 
Constants.FlowStatus.ENABLED) 
   { 
    /**Send DIAMETER RAR 
remove message via Gx*/ 
    DiameterMessage rar = 
createRAR(session_id,dest_realm,PCC_rule_name,sourc
e_ip,dest_ip,source_port,dest_port,QoS_class,bw_ul,bw_
dl,guaranteed_br_ul,guaranteed_br_dl,1); //command - 1 
remove 
    System.out.println(); 
 第 28 頁 / 共 78 頁 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_TRIGGE
R_EVENT) 
       { 
       
 System.out.println("INFO: Result code TRIGGER 
ERROR EVENT received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_PCC_RULE_EVE
NT) 
       { 
       
 System.out.println("INFO: Result code PCC 
RULE EVENT received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
       { 
       
 System.out.println("INFO: Unknown Result Code 
received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
      } 
     } 
    } 
    System.out.println("INFO: IP 
Flow with flow id: " + flow_id + " is being removed 
from the bearer level"); 
   } 
  } 
  if(result_code == 
Constants.ResultCode._DIAMETER_SUCCESS) 
  { 
 
   //invoke policies according to priority 
and trigger points 
   
   //find highest priority and invoke - then 
remove policy and find next highest priority policy - 
continue until all policies invoked 
   while(policy_vector.size()>0) 
   { 
    int highest_priority = 100; 
    int highest_priority_tag = -1; 
    for (int a = 0; a < 
policy_vector.size(); a++) 
    { 
     st = new 
StringTokenizer(policy_vector.get(a).toString(),";"); 
     st.nextToken(); 
     int priority = 
Integer.valueOf(st.nextToken()).intValue(); 
     if(priority < 
highest_priority) 
     { 
      highest_priority = 
priority; 
 第 30 頁 / 共 78 頁 
   
  /**add Auth Application id */ 
                AVP auth_application_id_avp = new 
AVP(Constants.AVPCode.AUTH_APPLICATION_ID, 
true,  Constants.Vendor.DIAM); 
                
auth_application_id_avp.setData(Constants.Application.
GX); 
                
rar.addAVP(auth_application_id_avp); 
   
  /**add destination-realm*/ 
   AVP destination_realm_avp = new 
AVP(AVP.Destination_Realm,true,Constants.Vendor.DI
AM); 
 
 destination_realm_avp.setData(destination_realm); 
  rar.addAVP(destination_realm_avp); 
   
 
  if(command == 1) 
  { 
   /**add PCC Rule remove*/ 
   AVP charging_rule_remove_avp = 
new 
AVP(Constants.AVPCode.CHARGING_RULE_REMO
VE,true,Constants.Vendor.V3GPP); 
   /*Charging rule definition*/ 
   AVP charging_rule_definition_avp = 
new 
AVP(Constants.AVPCode.CHARGING_RULE_DEFIN
ITION,true,Constants.Vendor.V3GPP); 
    /*Flow description1*/ 
    AVP flow_description_avp = 
new 
AVP(Constants.AVPCode.FLOW_DESCRIPTION,true,
Constants.Vendor.V3GPP); 
    String flow = "permit out ip from 
" + source_ip + " to " + dest_ip + " " + dest_port; 
   
 flow_description_avp.setData(flow); 
   
 charging_rule_definition_avp.addChildAVP(flow_
description_avp); 
    /*Flow description2*/ 
    flow_description_avp = new 
AVP(Constants.AVPCode.FLOW_DESCRIPTION,true,
Constants.Vendor.V3GPP); 
    flow = "permit in ip from " + 
dest_ip + " to " + source_ip + " " + source_port; 
   
 flow_description_avp.setData(flow); 
   
 charging_rule_definition_avp.addChildAVP(flow_
description_avp); 
  
 charging_rule_remove_avp.addChildAVP(chargin
g_rule_definition_avp); 
   /*Charging rule name*/ 
   AVP charging_rule_name_avp = new 
AVP(Constants.AVPCode.CHARGING_RULE_NAME,
true,Constants.Vendor.V3GPP); 
  
 charging_rule_name_avp.setData(PCC_rule_name
); 
  
 charging_rule_remove_avp.addChildAVP(chargin
g_rule_name_avp); 
  
 rar.addAVP(charging_rule_remove_avp); 
  } 
  else if (command == 2) 
  { 
   /**add PCC Rule install*/ 
   AVP charging_rule_install_avp = new 
AVP(Constants.AVPCode.CHARGING_RULE_INSTA
LL,true,Constants.Vendor.V3GPP); 
   /*Charging rule definition*/ 
 第 32 頁 / 共 78 頁 
new 
AVP(Constants.AVPCode.MAX_REQUESTED_BAND
WIDTH_DL,true,Constants.Vendor.V3GPP); 
 
 max_requested_bandwidth_dl_avp.setData(max_b
w_dl); 
 
 authorised_qos_avp.addChildAVP(max_requested
_bandwidth_dl_avp);  
  /*Guaranteed bitrate uplink*/ 
  AVP guaranteed_bitrate_ul_avp = new 
AVP(Constants.AVPCode.GUARANTEED_BITRATE_
UL,true,Constants.Vendor.V3GPP); 
 
 guaranteed_bitrate_ul_avp.setData(guaranteed_br_
ul); 
 
 authorised_qos_avp.addChildAVP(guaranteed_bitr
ate_ul_avp); 
  /*Guaranteed bitrate downlink*/ 
  AVP guaranteed_bitrate_dl_avp = new 
AVP(Constants.AVPCode.GUARANTEED_BITRATE_
DL,true,Constants.Vendor.V3GPP); 
 
 guaranteed_bitrate_dl_avp.setData(guaranteed_br_
dl); 
 
 authorised_qos_avp.addChildAVP(guaranteed_bitr
ate_dl_avp); 
  rar.addAVP(authorised_qos_avp); 
    
  return rar; 
 } 
} 
 
2. DomainPolicyProcessor.java 
 
package pcrf; 
 
import java.io.*; 
import java.net.*; 
import java.util.*; 
 
import de.fhg.fokus.Constants; 
 
import de.fhg.fokus.diameter.DiameterPeer.data.AVP; 
import 
de.fhg.fokus.diameter.DiameterPeer.data.DiameterMessa
ge; 
import 
de.fhg.fokus.diameter.DiameterPeer.transaction.Transact
ionListener; 
import 
de.fhg.fokus.diameter.DiameterPeer.DiameterPeer; 
 
 
 
/** 
 * DomainPolicyProcessor: 
 *  
 * This class implements Session Admission and policy 
rule creation for Domain Policies 
 */ 
 
 
public class DomainPolicyProcessor 
{ 
 DiameterPeer diameterPeer; 
 xcap policyEngine = null; 
  
         
 /** Decision Engine constructor intialises 
variables*/ 
 public DomainPolicyProcessor(DiameterPeer 
diameterPeer, String policy_db, String policy, String 
username, String password, int remote_xcap_server) 
throws IOException 
 { 
 第 34 頁 / 共 78 頁 
" + session_id + " does not exist"); 
   result_code = newSession(af_session, 
ip_flows, codecs); 
  } 
  return result_code; 
  
 } 
 
 /** 
      * This checks if a new session is authorised 
and if so stores the relevant data in the policy repository 
 * @param af_session session information 
 * @param ip_flows associated ip flow information 
 * @param codecs requested codecs  
 */ 
 private int newSession(String af_session, Vector 
ip_flows, Vector codecs) throws IOException  
 { 
   
  int result_code = -1; 
 
  /**session id; originating realm; destination 
realm; source ip; dest ip*/ 
  //extract session information 
  StringTokenizer st = new 
StringTokenizer(af_session,";"); 
  String session_id = st.nextToken(); 
  session_id = session_id + ";" + 
st.nextToken(); 
  session_id = session_id + ";" + 
st.nextToken(); 
  String orig_realm = st.nextToken(); 
  String dest_realm = st.nextToken(); 
  String source_ip = ""; 
  String dest_ip = ""; 
 
  int total_req_bw_ul = 0; 
  int total_req_bw_dl = 0;   
 
  int avail_qos_bw_ul = 0; 
  int avail_qos_bw_dl = 0; 
 
  
  /**Check that the requested QoS classes can 
handle the bandwidth requirements for each IP Flow*/ 
   
  for (int a = 0; a < ip_flows.size(); a++) 
  { 
   st = new 
StringTokenizer(ip_flows.get(a).toString(),";"); 
   int req_bw_ul = 0; 
   int req_bw_dl = 0; 
   int QoS_class = -1; 
    
   int i = 0; 
   String temp = ""; 
   for (i = 0 ;i < 10 ;i++) 
   { 
    temp = st.nextToken(); 
   } 
   req_bw_ul = 
Integer.valueOf(st.nextToken()).intValue(); 
   req_bw_dl = 
Integer.valueOf(st.nextToken()).intValue(); 
   QoS_class = 
Integer.valueOf(st.nextToken()).intValue(); 
 
   total_req_bw_ul = total_req_bw_ul + 
req_bw_ul; 
   total_req_bw_dl = total_req_bw_dl + 
req_bw_dl;     
 
 
  
 if(policyEngine.checkQoSBW(QoS_class, 
req_bw_ul, req_bw_dl) == 0) 
   { 
    System.out.println("\nINFO: " + 
 第 36 頁 / 共 78 頁 
w_ul,req_bw_dl); 
  } 
 
  /**edit Domain remaining UL and DL 
bandwidth*/ 
   
  //if orig and dest realm are the same 
  if(orig_realm.equalsIgnoreCase(dest_realm)) 
  { 
  
 policyEngine.reqDomainBandwidth(orig_realm,tot
al_req_bw_ul,total_req_bw_dl);   
  } 
  //if orig and dest realm are different 
  else 
  { 
    
  
 policyEngine.reqDomainBandwidth(orig_realm,tot
al_req_bw_ul,total_req_bw_dl); 
  
 policyEngine.reqDomainBandwidth(dest_realm,tot
al_req_bw_ul,total_req_bw_dl); 
  } 
   
  result_code = 
Constants.ResultCode._DIAMETER_SUCCESS;  
  return result_code; 
 } 
 
 /** 
      * This checks if a previous sessions 
modifications are authorised and if so stores the relevant 
data in the policy repository 
 * @param service information 
      */ 
  
 public int modSession(String af_session, Vector 
ip_flows, Vector codecs) throws IOException  
 { 
   
  int result_code = -1; 
  
  /**session id; originating realm; destination 
realm; source ip; dest ip*/ 
  //extract session information 
  StringTokenizer st = new 
StringTokenizer(af_session,";"); 
  String session_id = st.nextToken(); 
  session_id = session_id + ";" + 
st.nextToken(); 
  session_id =  session_id + ";" + 
st.nextToken(); 
  String orig_realm = st.nextToken(); 
  String dest_realm = st.nextToken(); 
  String source_ip = ""; 
  String dest_ip = ""; 
 
  int total_req_bw_ul = 0; 
  int total_req_bw_dl = 0;   
 
  int avail_qos_bw_ul = 0; 
  int avail_qos_bw_dl = 0; 
 
  /**Check that the requested QoS classes can 
handle the bandwidth requirements for each IP Flow*/ 
 
  for (int a = 0; a < ip_flows.size(); a++) 
  { 
   st = new 
StringTokenizer(ip_flows.get(a).toString(),";"); 
   int req_bw_ul = 0; 
   int req_bw_dl = 0; 
   int QoS_class = -1; 
    
   int i = 0; 
   String temp = ""; 
   for (i = 0 ;i < 10 ;i++) 
 第 38 頁 / 共 78 頁 
  /**edit QoS_classes remaining UL and DL 
bandwidth*/ 
  for ( int b = 0; b < ip_flows.size(); b++) 
  {    
   st = new 
StringTokenizer(ip_flows.get(b).toString(),";"); 
   int req_bw_ul = 0; 
   int req_bw_dl = 0; 
   int QoS_class = -1; 
   int i = 0; 
   String temp = ""; 
   for (i = 0 ;i < 10;i++) 
   { 
    temp = st.nextToken(); 
   } 
   req_bw_ul = 
Integer.valueOf(st.nextToken()).intValue(); 
   req_bw_dl = 
Integer.valueOf(st.nextToken()).intValue(); 
   QoS_class = 
Integer.valueOf(st.nextToken()).intValue(); 
  
 policyEngine.reqQoSBandwidth(QoS_class,req_b
w_ul,req_bw_dl); 
  } 
 
  /**edit Domain remaining UL and DL 
bandwidth*/ 
   
  //if orig and dest realm are the same 
  if(orig_realm.equalsIgnoreCase(dest_realm)) 
  { 
  
 policyEngine.reqDomainBandwidth(orig_realm,tot
al_req_bw_ul,total_req_bw_dl); 
  } 
  //if orig and dest realm are different 
  else 
  { 
  
 policyEngine.reqDomainBandwidth(orig_realm,tot
al_req_bw_ul,total_req_bw_dl); 
  
 policyEngine.reqDomainBandwidth(dest_realm,tot
al_req_bw_ul,total_req_bw_dl); 
  } 
  
  result_code = 
Constants.ResultCode._DIAMETER_SUCCESS; 
  return result_code; 
 } 
 
 
/** 
      * This terminates an existing session 
 * - Updates information in the policy 
repository 
 * @param af_session session information 
      */ 
 public int termination_request(String af_session)  
throws IOException 
 { 
  int result_code = -1; 
  StringTokenizer st = new 
StringTokenizer(af_session,";"); 
  String session_id = st.nextToken(); 
  session_id = session_id + ";" + 
st.nextToken(); 
  session_id =  session_id + ";" + 
st.nextToken(); 
  String orig_realm = st.nextToken(); 
  String dest_realm = st.nextToken(); 
   
  int total_bw_ul = 0; 
  int total_bw_dl = 0; 
   
  /**Check that session exists*/ 
  if(policyEngine.sessionExists(session_id) == 
 第 40 頁 / 共 78 頁 
  else 
  { 
    
  
 policyEngine.freeDomainBandwidth(orig_realm,to
tal_bw_ul,total_bw_dl); 
  
 policyEngine.freeDomainBandwidth(dest_realm,to
tal_bw_ul,total_bw_dl); 
  } 
  /**remove all information from af_session*/ 
  policyEngine.deleteSession(session_id); 
  /**remove all associated ip flows*/ 
  policyEngine.deleteIPFlow(session_id); 
 
  result_code = 
Constants.ResultCode._DIAMETER_SUCCESS; 
  return result_code; 
 }  
} 
 
 
3. PCEF.java 
 
package pcrf; 
 
import java.net.Socket; 
import java.net.*; 
import java.util.*; 
import java.io.*; 
 
import de.fhg.fokus.pcef_diam.pcefDiameterStack; 
import 
de.fhg.fokus.diameter.DiameterPeer.DiameterPeer; 
 
/** 
 * PCEF: 
 *  
 * This is the main class for starting the PCEF 
 *   - It initialises the Diameter stack and accepts 
connections from PCRFs 
 *  - Implements the state machine that defines 
the PCEF behaviour 
 * @author Richard Good 
 */ 
public class PCEF 
{ 
 
 pcefDiameterStack diameterStack; 
 DiameterPeer diameterPeer; 
 String pcrfAddress; 
 String pcefID=null; 
 LinuxRouter linux_router; 
 static String policy_db = ""; 
 static String[] policies = new String[10]; //max 
num policies 10  
 static String username = ""; 
 static String password = ""; 
 xcap policyEngine = null; 
 static int remote_xcap_server; //one if remote zero 
if local 
 static String diffserv_interface=""; 
 static int data_counter; //1 enabled 0 disabled 
  
 /** 
 * The main method 
 * @param args 
 */ 
 public static void main(String[] args) throws 
IOException  
 { 
  getPreferences(); 
  String pcefID = "1"; 
     
  //FOR TESTING PURPOSES ASSUME 
PCEF ID 1 
  //System.out.print("Enter PCEF Name : "); 
  //pcefID = in.readLine(); 
 第 42 頁 / 共 78 頁 
pcef.properties**/ 
 private static void getPreferences() throws 
IOException 
 { 
  StringBuffer fileData = new 
StringBuffer(1000); 
          
   
  try 
  { 
   BufferedReader reader = new 
BufferedReader(new 
FileReader("/opt/OpenIMSCore/uctpcrf/config/pcef.prop
erties")); 
    
   char[] buf = new char[1024]; 
   int numRead=0; 
   while((numRead=reader.read(buf)) != 
-1){ 
    String readData = 
String.valueOf(buf, 0, numRead); 
    fileData.append(readData); 
    buf = new char[1024]; 
   } 
   reader.close(); 
   String fileStr =  fileData.toString(); 
   StringTokenizer st = new 
StringTokenizer(fileStr, "\n"); 
    
   String policy_db_line = 
st.nextToken(); 
   StringTokenizer st1 = new 
StringTokenizer(policy_db_line, "="); 
   st1.nextToken(); 
   StringTokenizer st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
   policy_db = st2.nextToken(); 
   String policies_line = ""; 
   int pol = 0; 
   while(pol != -1) 
   { 
    policies_line = st.nextToken(); 
    st1 = new 
StringTokenizer(policies_line, "="); 
   
 if(st1.nextToken().equals("policies")) 
    { 
     st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
     policies[pol] = 
st2.nextToken(); 
     pol++; 
    } 
    else 
    { 
     pol = -1; 
    } 
   } 
 
   String username_line = policies_line; 
   st1 = new 
StringTokenizer(username_line, "="); 
   st1.nextToken(); 
   st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
   username = st2.nextToken(); 
    
   String password_line = st.nextToken(); 
   st1 = new 
StringTokenizer(password_line, "="); 
   st1.nextToken(); 
   st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
   password = st2.nextToken(); 
  
   String remote_xcap_server_line = 
st.nextToken(); 
   st1 = new 
 第 44 頁 / 共 78 頁 
 * This is the main class for starting the Policy Control 
and Charging Function 
 *   - It initialises the Diameter stack and 
connects to P-CSCFs 
 *   - It initialises the Diameter stack and 
connects to PEPs 
  - It downloads necessary policies from an 
XCAP 
 *  - Implements the state machine that defines 
the PCRF behaviour 
 * @author Richard Good 
 */ 
public class PCRF  
{ 
 
 pcrfDiameterStack diameterStack; 
 DiameterPeer diameterPeer; 
 static int remote_xcap_server; //one if remote zero 
if local 
 static String policy_db = ""; 
 static String[] policies = new String[10]; //max 
num policies 10  
 static String username = ""; 
 static String password = ""; 
 xcap policyEngine = null; 
   
  
 /** 
 * The main method 
 * @param args 
 */ 
 public static void main(String[] args) throws 
IOException  
 { 
 
  //retrieves configuration information from 
config files 
  getPreferences(); 
 
  try  
  { 
   PCRF pcrf = new PCRF(); 
   pcrf.run(); 
    
  }  
  catch (Exception e) 
  { 
   e.printStackTrace(); 
  } 
 } 
 
  /** 
 * Constructor for PCRF 
 *  -initialises variables 
 *  -Ensures that there are PCEFs listed in the 
repository to control 
 * @param args 
 */ 
 public PCRF() throws RemoteException, 
IOException 
 { 
 
  diameterPeer = new 
DiameterPeer("config/DiameterPeerPCRF.xml"); 
  policyEngine = new xcap (policy_db, 
"domain_policies", username, password, 
remote_xcap_server); 
 } 
  
 /** 
 * This defines the behavour of the PCRF 
 *  -It starts the PCRF  
 * -Starts the diameter stack and connects to the 
P-CSCF 
 * -Starts the dimater stack and connects to all 
listed PCEFs 
 */ 
 public void run() throws IOException 
 第 46 頁 / 共 78 頁 
String.valueOf(buf, 0, numRead); 
    fileData.append(readData); 
    buf = new char[1024]; 
   } 
   reader.close(); 
   String fileStr =  fileData.toString(); 
   StringTokenizer st = new 
StringTokenizer(fileStr, "\n"); 
    
   String policy_db_line = 
st.nextToken(); 
   StringTokenizer st1 = new 
StringTokenizer(policy_db_line, "="); 
   st1.nextToken(); 
   StringTokenizer st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
   policy_db = st2.nextToken(); 
 
   int pol = 0; 
   String policies_line = ""; 
   while(pol != -1) 
   { 
    policies_line = st.nextToken(); 
    st1 = new 
StringTokenizer(policies_line, "="); 
   
 if(st1.nextToken().equals("policies")) 
    { 
     st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
     policies[pol] = 
st2.nextToken(); 
     pol++; 
    } 
    else 
    { 
     pol = -1; 
    } 
   } 
    
   String username_line = policies_line; 
   st1 = new 
StringTokenizer(username_line, "="); 
   st1.nextToken(); 
   st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
   username = st2.nextToken(); 
    
   String password_line = st.nextToken(); 
   st1 = new 
StringTokenizer(password_line, "="); 
   st1.nextToken(); 
   st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
   password = st2.nextToken(); 
  
   String remote_xcap_server_line = 
st.nextToken(); 
   st1 = new 
StringTokenizer(remote_xcap_server_line, "="); 
   st1.nextToken(); 
   remote_xcap_server = 
Integer.valueOf(st1.nextToken()).intValue(); 
  } 
  catch(FileNotFoundException e) 
  { 
   System.out.println("Preferences file 
not found"); 
  } 
 } 
 
 /** 
  * This method waits until exit is typed in the 
console 
  * If wait is typed, then it returns. 
  */ 
 private static void waitForExit() { 
  byte[] buffer = new byte[80];  
 第 48 頁 / 共 78 頁 
 
 /** 
 * Constructor for xcap 
 *  -initialises variables 
 * @param args 
 */ 
 public xcap(String policy_db, String policy, String 
username, String password, int remote_xcap_server) 
throws IOException 
 { 
  
  this.username = username; 
  this.password = password; 
  this.remote_xcap_server = 
remote_xcap_server; 
  /**TO DO fix OpenXCAP to allow different 
Applications*/ 
  if(remote_xcap_server == 1) 
  { 
   this.policy_db = policy_db + 
"resource-lists/users/" + username + "/resource-lists.xml";
  
  } 
  else 
  { 
   this.policy_db = policy_db + policy + 
".xml"; 
  } 
  parseXML(getXML()); 
 } 
 
 /**  
 * This converts an XML Document into a String 
used to convey the doc via HTTP 
 * @param dom The XML document to be 
converted to a string 
 * @return xmlStr the String representation of the 
xml doc 
 **/ 
 private String XMLDocToString(Document dom) 
 { 
  String xmlStr = null; 
  StringWriter strWriter = null; 
  XMLSerializer probeMsgSerializer = null; 
  OutputFormat outFormat = new 
OutputFormat(); 
   
  try 
  { 
   probeMsgSerializer = new 
XMLSerializer();  
   strWriter = new StringWriter(); 
   outFormat = new OutputFormat(); 
   
   // Setup format settings 
   outFormat.setVersion("1.0"); 
   outFormat.setEncoding("UTF-8"); 
   outFormat.setIndenting(true); 
   outFormat.setIndent(4); 
   
   // Define a Writer 
  
 probeMsgSerializer.setOutputCharStream(strWrite
r); 
   
   // Apply the format settings 
  
 probeMsgSerializer.setOutputFormat(outFormat); 
   
   // Serialize XML Document  
  
   probeMsgSerializer.serialize(dom); 
   xmlStr = strWriter.toString(); 
   strWriter.close(); 
   
  } 
  catch (IOException ioEx) 
  { 
 第 50 頁 / 共 78 頁 
conditions.getElementsByTagName("codec_id"); 
      if(nl1 != null && 
nl1.getLength() > 0) 
      {  
       Element 
codec_id = (Element)nl1.item(0); 
       NodeList nl2 = 
codec_id.getElementsByTagName("id");  
       if(nl2 != null 
&& nl2.getLength() > 0)  
       { 
        for(int a 
= 0 ; a < nl2.getLength();a++) 
        { 
        
 Element ID = (Element)nl2.item(a); 
        
 authCodecs.add(ID.getFirstChild().getNodeValue(
)); 
        }  
       } 
      } 
     } 
    } 
   } 
  } 
    
  //check that all requested codecs are 
authorised 
  int authorised = 1; 
  int supported = 0; 
  for ( int b = 0; b < codecs.size(); b++) 
  { 
   supported = 0; 
   for (int c = 0; c < authCodecs.size(); 
c++) 
   {  
   
 if(Integer.valueOf(codecs.get(b).toString()).intVal
ue() == 
Integer.valueOf(authCodecs.get(c).toString()).intValue()
) 
    { 
     supported = 1; 
    } 
   } 
   //Note this is to support dynamic 
codecs, see RFC 3551 
   if (supported == 0 && 
(Integer.valueOf(codecs.get(b).toString()).intValue() < 
96 || Integer.valueOf(codecs.get(b).toString()).intValue() 
> 127)) 
   { 
     authorised = 0; 
   } 
 
  } 
  //1 if authorised 0 if not 
  return authorised; 
 } 
 
 
 /** 
      * This receives the orig and term domains 
 * It checks that both domains are allowed 
 * @param String orig originating domain 
 * @param String term terminating domain 
 * @return 1 if authorised 0 if not   
 */ 
 public int checkDomain(String orig, String term) 
throws IOException 
 { 
  //fetch and parse the policy XML document 
  parseXML(getXML()); 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
 第 52 頁 / 共 78 頁 
 } 
  
 /** 
      * This checks if a session with given session 
id already exists 
 * @param String session_id the Session to check 
 * @return 1 if exists 0 if it does not   
 */ 
 public int sessionExists(String session_id) throws 
IOException 
 { 
  int session_exists = 0; 
  //fetch and parse the policy XML document 
  parseXML(getXML()); 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
  NodeList nl = 
docEle.getElementsByTagName("tris"); 
  if(nl != null && nl.getLength() > 0) { 
   //get the tris element 
   Element tris = (Element)nl.item(0); 
   NodeList nl1 = 
tris.getElementsByTagName("af_session"); 
   if(nl1 != null && nl1.getLength() > 0)  
   { 
    for(int i = 0 ; i < 
nl1.getLength();i++)  
    { 
     Element af_session = 
(Element)nl1.item(i); 
     NodeList nl2 = 
af_session.getElementsByTagName("session_id"); 
     if(nl2 != null && 
nl2.getLength() > 0)  
     { 
      Element  
Session_ID = (Element)nl2.item(0); 
     
 if(Session_ID.hasChildNodes() && 
session_id.equals(Session_ID.getFirstChild().getNodeVa
lue().toString())) 
      { 
       session_exists 
= 1; 
      } 
     } 
    } 
   } 
  } 
  return session_exists; 
 }  
  
 /** 
      * This checks if the specified QoS class can 
handle a given bandwidth (ul and dl) 
 * @param int QoS_class the QoS class that is too 
be checked 
 * @param int bw_ul the requested uplink 
bandwidth 
 * @param int bw_dl the requested downlink 
bandwidth 
 * @return 1 if authorised 0 if not   
 */ 
 public int checkQoSBW(int QoS_class, int bw_ul, 
int bw_dl) throws IOException 
 { 
   
  int authbw_ul = 0; 
  int authbw_dl = 0; 
  parseXML(getXML()); 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
   
  NodeList nl = 
docEle.getElementsByTagName("rule"); 
 第 54 頁 / 共 78 頁 
 
   
 /** 
      * This checks if the specified domain can 
handle a given bandwidth (ul and dl) 
 * @param String domain the Domain in question 
 * @param int bw_ul the requested uplink 
bandwidth 
 * @param int bw_dl the requested downlink 
bandwidth 
 * @return 1 if authorised 0 if not   
 */ 
 public int checkDomainBW(String domain, int 
bw_ul, int bw_dl) throws IOException 
 { 
   
  int authbw_ul = 0; 
  int authbw_dl = 0; 
  parseXML(getXML()); 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
  NodeList nl = 
docEle.getElementsByTagName("rule"); 
  if(nl != null && nl.getLength() > 0) { 
   for(int i = 0 ; i < nl.getLength();i++) { 
     
    //get the authorised codec rule 
    Element rule = 
(Element)nl.item(i); 
    String id = 
rule.getAttribute("id"); 
    if(id.equals("domain 
authorisation")) 
    { 
     NodeList nl3 = 
rule.getElementsByTagName("conditions"); 
     if(nl3 != null && 
nl3.getLength() > 0) 
     {  
      Element conditions = 
(Element)nl3.item(0); 
      NodeList nl1 = 
conditions.getElementsByTagName("domain"); 
      if(nl1 != null && 
nl1.getLength() > 0) 
      {  
       Element 
Domain = (Element)nl1.item(0); 
       NodeList nl2 = 
Domain.getElementsByTagName("address");  
       if(nl2 != null 
&& nl2.getLength() > 0)  
       { 
        for(int a 
= 0 ; a < nl2.getLength();a++) 
        { 
        
 Element address = (Element)nl2.item(a); 
        
 if(domain.equals(address.getFirstChild().getNode
Value())) 
         { 
         
 if(bw_dl < 
(Integer.valueOf(address.getAttribute("bw_downlink"))).
intValue()) 
         
 { 
         
  authbw_dl = 1; 
         
 } 
         
 if(bw_ul < 
(Integer.valueOf(address.getAttribute("bw_uplink"))).int
Value()) 
 第 56 頁 / 共 78 頁 
    { 
     Element Session_ID = 
(Element)nl2.item(0); 
    
 if(!Session_ID.hasChildNodes()) 
     { 
     
 Session_ID.appendChild(dom.createTextNode(ses
sion_id)); 
      nl2= 
af_session.getElementsByTagName("orig_domain"); 
      if(nl2 != null && 
nl2.getLength() > 0)  
      { 
       Element 
Orig_Domain = (Element)nl2.item(0); 
      
 Orig_Domain.appendChild(dom.createTextNode(o
rig_domain)); 
      } 
      nl2 = 
af_session.getElementsByTagName("term_domain"); 
      if(nl2 != null && 
nl2.getLength() > 0)  
      { 
       Element 
Term_Domain = (Element)nl2.item(0); 
      
 Term_Domain.appendChild(dom.createTextNode(t
erm_domain)); 
      } 
      nl2 = 
af_session.getElementsByTagName("codecs"); 
      if(nl2 != null && 
nl2.getLength() > 0)  
      { 
       Element 
Codecs = (Element)nl2.item(0); 
      
 Codecs.appendChild(dom.createTextNode(codec_l
ist)); 
      } 
     } 
     else 
     { 
      Element 
AF_Session1 = dom.createElement("af_session"); 
      Element 
Session_ID1 = dom.createElement("session_id"); 
     
 Session_ID1.appendChild(dom.createTextNode(se
ssion_id)); 
     
 AF_Session1.appendChild(Session_ID1); 
      Element 
Orig_Domain = dom.createElement("orig_domain"); 
     
 Orig_Domain.appendChild(dom.createTextNode(o
rig_domain)); 
     
 AF_Session1.appendChild(Orig_Domain); 
      Element 
Term_Domain = dom.createElement("term_domain"); 
     
 Term_Domain.appendChild(dom.createTextNode(t
erm_domain)); 
     
 AF_Session1.appendChild(Term_Domain); 
      Element Codecs = 
dom.createElement("codecs"); 
     
 Codecs.appendChild(dom.createTextNode(codec_l
ist)); 
     
 AF_Session1.appendChild(Codecs); 
     
 tris.appendChild(AF_Session1); 
     
 第 58 頁 / 共 78 頁 
docEle.getElementsByTagName("tris"); 
   if(nl0 != null && nl0.getLength() > 0)  
   { 
    Element tris = 
(Element)nl0.item(0); 
    //get a nodelist of <IP Flow> 
elements 
    NodeList nl = 
tris.getElementsByTagName("ip_flow"); 
    if(nl != null && nl.getLength() > 
0)  
    { 
     Element IP_Flow = 
(Element)nl.item(0); 
     NodeList nl1 = 
IP_Flow.getElementsByTagName("session_id"); 
     if(nl1 != null && 
nl1.getLength() > 0)  
     { 
      Element Session_ID 
= (Element)nl1.item(0); 
     
 if(!Session_ID.hasChildNodes()) 
      { 
      
 Session_ID.appendChild(dom.createTextNode(ses
sion_id)); 
       nl1 = 
IP_Flow.getElementsByTagName("flow_id"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
Flow_ID = (Element)nl1.item(0); 
       
 Flow_ID.appendChild(dom.createTextNode(flow_
id)); 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("source_ip"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
Source_IP = (Element)nl1.item(0); 
       
 Source_IP.appendChild(dom.createTextNode(sour
ce_ip)); 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("dest_ip"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
Dest_IP = (Element)nl1.item(0); 
       
 Dest_IP.appendChild(dom.createTextNode(dest_ip
)); 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("source_port"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
Source_Port = (Element)nl1.item(0); 
       
 Source_Port.appendChild(dom.createTextNode(so
urce_port)); 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("dest_port"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
Dest_Port = (Element)nl1.item(0); 
 第 60 頁 / 共 78 頁 
       Element 
Source_IP = dom.createElement("source_ip"); 
      
 Source_IP.appendChild(dom.createTextNode(sour
ce_ip)); 
      
 IP_Flow1.appendChild(Source_IP); 
       Element 
Dest_IP = dom.createElement("dest_ip"); 
      
 Dest_IP.appendChild(dom.createTextNode(dest_ip
)); 
      
 IP_Flow1.appendChild(Dest_IP); 
       Element 
Source_Port = dom.createElement("source_port"); 
      
 Source_Port.appendChild(dom.createTextNode(so
urce_port)); 
      
 IP_Flow1.appendChild(Source_Port); 
       Element 
Dest_Port = dom.createElement("dest_port"); 
      
 Dest_Port.appendChild(dom.createTextNode(dest_
port)); 
      
 IP_Flow1.appendChild(Dest_Port); 
       Element 
Flow_Usage = dom.createElement("flow_usage"); 
      
 Flow_Usage.appendChild(dom.createTextNode(us
age)); 
      
 IP_Flow1.appendChild(Flow_Usage); 
       Element 
Flow_Status = dom.createElement("flow_status"); 
      
 Flow_Status.appendChild(dom.createTextNode(sta
tus)); 
      
 IP_Flow1.appendChild(Flow_Status); 
       Element 
BW_Uplink = dom.createElement("bw_uplink"); 
      
 BW_Uplink.appendChild(dom.createTextNode(bw
_ul)); 
      
 IP_Flow1.appendChild(BW_Uplink); 
       Element 
BW_Downlink = dom.createElement("bw_downlink"); 
      
 BW_Downlink.appendChild(dom.createTextNode(
bw_dl)); 
      
 IP_Flow1.appendChild(BW_Downlink); 
       Element 
QoS_Class = dom.createElement("qos_class"); 
      
 QoS_Class.appendChild(dom.createTextNode(Qo
S_class)); 
      
 IP_Flow1.appendChild(QoS_Class); 
      
 tris.appendChild(IP_Flow1); 
      
 //docEle.appendChild(tris); 
      } 
     } 
      
    } 
    else 
    { 
     Element IP_Flow1 = 
dom.createElement("ip_flow"); 
     Element Session_ID1 = 
dom.createElement("session_id"); 
    
 第 62 頁 / 共 78 頁 
   } 
    
  } 
  putXML(XMLDocToString(dom)); 
 } 
  
 /** 
      * This removes a session from the Policy 
repository 
 * @param session_id the ID of the session to 
remove 
 */ 
 public void deleteSession(String session_id) 
throws IOException 
 { 
  parseXML(getXML()); 
   
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
  NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
  if(nl0 != null && nl0.getLength() > 0)  
  { 
   Element tris = (Element)nl0.item(0); 
   NodeList nl = 
tris.getElementsByTagName("af_session"); 
   if(nl != null && nl.getLength() > 0)  
   { 
    int i = 0; 
    while ((nl != null && 
nl.getLength() > 0) && i < nl.getLength()) 
    { 
     Element IMS_Session = 
(Element)nl.item(i); 
     i++; 
     NodeList nl1 = 
IMS_Session.getElementsByTagName("session_id"); 
     if(nl1 != null && 
nl1.getLength() > 0)  
     { 
      Element Session_ID 
= (Element)nl1.item(0); 
      String 
current_session_id = 
Session_ID.getFirstChild().getNodeValue().toString(); 
     
 if(current_session_id.equals(session_id)) 
      { 
      
 tris.removeChild(IMS_Session); 
       i = 0; 
      } 
     } 
     nl = 
tris.getElementsByTagName("af_session"); 
    } 
   } 
 
  } 
  putXML(XMLDocToString(dom)); 
 } 
  
 /** 
      * This removes an ip flow from the Policy 
repository 
 * @param session_id the ID of the IP Flows to 
remove 
 */ 
 public void deleteIPFlow(String session_id) throws 
IOException 
 { 
   
  parseXML(getXML()); 
   
  //get the root elememt 
  Element docEle = 
 第 64 頁 / 共 78 頁 
nl3.getLength() > 0) 
     {  
      Element conditions = 
(Element)nl3.item(0); 
      NodeList nl1 = 
conditions.getElementsByTagName("qos_class"); 
      if(nl1 != null && 
nl1.getLength() > 0) 
      {  
       Element 
qos_class = (Element)nl1.item(0); 
       NodeList nl2 = 
qos_class.getElementsByTagName("class_id");  
       if(nl2 != null 
&& nl2.getLength() > 0)  
       { 
        for(int a 
= 0 ; a < nl2.getLength();a++) 
        { 
        
 Element class_id = (Element)nl2.item(a); 
        
 if(QoS_class == 
(Integer.valueOf(class_id.getFirstChild().getNodeValue(
))).intValue()) 
         { 
         
 int temp = 
(Integer.valueOf(class_id.getAttribute("bw_downlink")))
.intValue() + bw_dl; 
         
 String new_bw_dl = "" + temp; 
         
 temp = 
(Integer.valueOf(class_id.getAttribute("bw_uplink"))).int
Value() + bw_ul; 
         
 String new_bw_ul = "" + temp; 
         
 class_id.setAttribute("bw_downlink",new_bw_dl); 
         
 class_id.setAttribute("bw_uplink",new_bw_ul); 
         
  
         } 
     
        }  
       } 
      } 
     } 
    } 
   } 
  } 
  putXML(XMLDocToString(dom)); 
 } 
 
 /** 
      * This deducts the specified uplink and 
downlink bandwidth to the specified QoS class 
 * @param QoS_class the QoS class to return the 
bandwidth to 
 * @param bw_ul the uplink bandwidth to deduct 
 * @param bw_dl the downlink bandwidth to 
deduct 
 */ 
 public void reqQoSBandwidth(int QoS_class, int 
bw_ul, int bw_dl) throws IOException 
 { 
   
  parseXML(getXML()); 
   
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
 
  NodeList nl = 
docEle.getElementsByTagName("rule"); 
 第 66 頁 / 共 78 頁 
 public void freeDomainBandwidth(String domain, 
int bw_ul, int bw_dl) throws IOException 
 { 
  parseXML(getXML()); 
   
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
 
  NodeList nl = 
docEle.getElementsByTagName("rule"); 
  if(nl != null && nl.getLength() > 0) { 
   for(int i = 0 ; i < nl.getLength();i++) { 
     
    //get the authorised codec rule 
    Element rule = 
(Element)nl.item(i); 
    String id = 
rule.getAttribute("id"); 
    if(id.equals("domain 
authorisation")) 
    { 
     NodeList nl3 = 
rule.getElementsByTagName("conditions"); 
     if(nl3 != null && 
nl3.getLength() > 0) 
     {  
      Element conditions = 
(Element)nl3.item(0); 
      NodeList nl1 = 
conditions.getElementsByTagName("domain"); 
      if(nl1 != null && 
nl1.getLength() > 0) 
      {  
       Element 
Domain = (Element)nl1.item(0); 
       NodeList nl2 = 
Domain.getElementsByTagName("address");  
       if(nl2 != null 
&& nl2.getLength() > 0)  
       { 
        for(int a 
= 0 ; a < nl2.getLength();a++) 
        { 
        
 Element address = (Element)nl2.item(a); 
        
 if(domain.equals( address.getFirstChild().getNode
Value())) 
         { 
         
 int temp = 
(Integer.valueOf(address.getAttribute("bw_downlink"))).
intValue() + bw_dl; 
         
 String new_bw_dl = "" + temp; 
         
 temp = 
(Integer.valueOf(address.getAttribute("bw_uplink"))).int
Value() + bw_ul; 
         
 String new_bw_ul = "" + temp; 
         
 address.setAttribute("bw_downlink",new_bw_dl); 
         
 address.setAttribute("bw_uplink",new_bw_ul); 
         
  
         } 
     
        }  
       } 
      } 
     } 
    } 
   } 
  } 
 第 68 頁 / 共 78 頁 
         
 address.setAttribute("bw_uplink",new_bw_ul); 
         
  
         } 
     
        }  
       } 
      } 
     } 
    } 
   } 
  } 
  putXML(XMLDocToString(dom)); 
 } 
  
 /** 
 * This puts an XML file to the XDMS server 
 * @param xmlDoc String representation of the 
document to put to the server 
 */ 
 public void putXML(String xmlDoc) throws 
IOException 
 { 
  if(remote_xcap_server == 1) 
  { 
 //  
 System.out.println("-------------------------------------
-------------"); 
 //   System.out.println(); 
 //   System.out.println("INFO: Sending 
HTTP PUT to XDMS Server"); 
 //   System.out.println();  
   
   HttpClient client = new HttpClient(); 
   client.getState().setCredentials( 
   AuthScope.ANY, 
   new 
UsernamePasswordCredentials(username,password) 
   ); 
   PutMethod put = new 
PutMethod(policy_db); 
   put.setDoAuthentication( true ); 
   put.setRequestEntity(new 
StringRequestEntity(xmlDoc,"text/plain","UTF-8")); 
   try { 
    // execute the PUT 
    int status = 
client.executeMethod( put ); 
   
    // print the status and response 
    //System.out.println(status + " " 
+ put.getResponseBodyAsString() +"\n"); 
    
  
   }finally { 
   // release any connection resources 
used by the method 
    put.releaseConnection(); 
   } 
  } 
  else 
  { 
   File domain_policies = new 
File(policy_db); 
                 FileWriter out = new 
FileWriter(domain_policies); 
   out.write(xmlDoc); 
                 out.close(); 
  } 
 } 
 
 /** 
 * This gets an XML file from the XDMS server 
 * @return xmlDoc InputStream  representation of 
the document retrieved from the server 
 */ 
 public InputStream getXML() throws IOException 
 第 70 頁 / 共 78 頁 
 */ 
 public Vector getIPFlows(String session_id) 
throws IOException 
 { 
    
  //fetch and parse the policy XML document 
  parseXML(getXML()); 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
   
  Vector ip_flows = new Vector(); 
   
  NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
  if(nl0 != null && nl0.getLength() > 0)  
  { 
   Element tris = (Element)nl0.item(0); 
   NodeList nl = 
tris.getElementsByTagName("ip_flow"); 
   if(nl != null && nl.getLength() > 0) { 
    for(int i = 0 ; i < 
nl.getLength();i++) { 
      
     String ip_flow = ""; 
     Element IP_Flow = 
(Element)nl.item(i); 
     NodeList nl1 = 
IP_Flow.getElementsByTagName("session_id"); 
     if(nl1 != null && 
nl1.getLength() > 0) { 
      Element Session_ID 
= (Element)nl1.item(0); 
     
 if(session_id.equals(Session_ID.getFirstChild().get
NodeValue().toString())) 
      { 
       ip_flow = 
ip_flow + session_id + ";"; 
       nl1 = 
IP_Flow.getElementsByTagName("flow_id"); 
       if(nl1 != null 
&& nl1.getLength() > 0) { 
        Element 
Flow_ID = (Element)nl1.item(0); 
        ip_flow 
= ip_flow + Flow_ID.getFirstChild().getNodeValue() + 
";"; 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("source_ip"); 
       if(nl1 != null 
&& nl1.getLength() > 0) { 
        Element 
Source_IP = (Element)nl1.item(0); 
        ip_flow 
= ip_flow + Source_IP.getFirstChild().getNodeValue() + 
";"; 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("dest_ip"); 
       if(nl1 != null 
&& nl1.getLength() > 0) { 
        Element 
Dest_IP = (Element)nl1.item(0); 
        ip_flow 
= ip_flow + Dest_IP.getFirstChild().getNodeValue() + 
";"; 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("source_port"); 
       if(nl1 != null 
&& nl1.getLength() > 0) { 
        Element 
Source_Port = (Element)nl1.item(0); 
        ip_flow 
= ip_flow + Source_Port.getFirstChild().getNodeValue() 
+ ";"; 
 第 72 頁 / 共 78 頁 
IOException 
 { 
  String pcrfAddress = ""; 
  //fetch and parse the policy XML document 
  parseXML(getXML()); 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
  NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
  if(nl0 != null && nl0.getLength() > 0)  
  { 
   Element tris = (Element)nl0.item(0); 
   //get all authorised domains and list of 
authorised QoS classes into vectors 
   NodeList nl = 
tris.getElementsByTagName("pcef"); 
   if(nl != null && nl.getLength() > 0)  
   { 
    for(int i = 0 ; i < 
nl.getLength();i++)  
    { 
     Element PCEF = 
(Element)nl.item(i); 
     NodeList nl1 = 
PCEF.getElementsByTagName("pcef_id"); 
     if(nl1 != null && 
nl1.getLength() > 0)  
     { 
      Element PCEF_ID = 
(Element)nl1.item(0); 
     
 if(pcef_id.equals(PCEF_ID.getFirstChild().getNod
eValue().toString())) 
      { 
       nl1 = 
PCEF.getElementsByTagName("pcrf_address"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
PCRF_Address = (Element)nl1.item(0); 
       
 pcrfAddress = 
PCRF_Address.getFirstChild().getNodeValue().toString(
); 
       } 
      } 
     } 
    } 
   } 
  }  
 
   
  return pcrfAddress; 
 } 
 
 /** 
 * This returns the address of the AS associated 
with a domain 
 * @param orig_realm the originating domain 
 * @param term_realm the terminating realm 
 * @return af_address the address of the AF 
 */ 
 public String getAF(String orig_realm,String 
dest_realm) throws IOException 
 { 
  String af_address = ""; 
  /**TODO Link multiple PCEFs if realms 
different*/ 
  /**If orig and dest realm the same*/ 
 
 //if(orig_realm.equalsIgnoreCase(dest_realm)) 
  //{ 
    
   //fetch and parse the policy XML 
document 
 第 74 頁 / 共 78 頁 
docEle.getElementsByTagName("tris"); 
  if(nl0 != null && nl0.getLength() > 0)  
  { 
   Element tris = (Element)nl0.item(0); 
   //get all authorised domains and list of 
authorised QoS classes into vectors 
   NodeList nl = 
tris.getElementsByTagName("pcrf"); 
   if(nl != null && nl.getLength() > 0)  
   { 
    for(int i = 0 ; i < 
nl.getLength();i++)  
    { 
     Element PCRF = 
(Element)nl.item(i); 
     NodeList nl1 = 
PCRF.getElementsByTagName("address"); 
     if(nl1 != null && 
nl1.getLength() > 0)  
     { 
      Element Address = 
(Element)nl1.item(0); 
     
 if(pcrf_address.equals(Address.getFirstChild().get
NodeValue().toString())) 
      { 
       nl1 = 
PCRF.getElementsByTagName("af_address"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
AF_Address = (Element)nl1.item(0); 
       
 af_address = 
AF_Address.getFirstChild().getNodeValue().toString(); 
       } 
      } 
     } 
    } 
   } 
   
  } 
  return af_address; 
 } 
 
 
 /** 
 * This returns the address of the PCEF associated 
with a domain 
 * @param orig_realm the originating domain 
 * @param term_realm the terminating realm 
 * @return pcefAddress the address of the PCEF 
 */ 
 public String getPCEF(String orig_realm,String 
dest_realm) throws IOException 
 { 
  String pcefAddress = ""; 
  /**TODO Link multiple PCEFs if realms 
different*/ 
  /**If orig and dest realm the same*/ 
 
 //if(orig_realm.equalsIgnoreCase(dest_realm)) 
  //{ 
    
   //fetch and parse the policy XML 
document 
   parseXML(getXML()); 
   //get the root elememt 
   Element docEle = 
dom.getDocumentElement(); 
  
   NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
   if(nl0 != null && nl0.getLength() > 0)  
   { 
    Element tris = 
(Element)nl0.item(0); 
 第 76 頁 / 共 78 頁 
      Element  PCEF_ID 
= (Element)nl1.item(0); 
     
 if(pcefID.equals(PCEF_ID.getFirstChild().getNod
eValue())) 
      { 
       nl1 = 
PCEF.getElementsByTagName("status"); 
       if(nl1 != null 
&& nl1.getLength() > 0) { 
        Element  
Status = (Element)nl1.item(0); 
       
 Status.replaceChild(dom.createTextNode(status),St
atus.getFirstChild()); 
       } 
      } 
     } 
      
    } 
   } 
 
  } 
  putXML(XMLDocToString(dom)); 
 } 
  
 /** 
 * This sets the stats of the specified PCRF to ON 
or OFF 
 * @param pcrfID ID of PCRF 
 * @param status either ON or OFF 
 */ 
 public void statusPCRF(String pcrfID, String 
status) throws IOException 
 { 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
   
  NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
  if(nl0 != null && nl0.getLength() > 0)  
  { 
   Element tris = (Element)nl0.item(0); 
   NodeList nl = 
tris.getElementsByTagName("pcrf"); 
   if(nl != null && nl.getLength() > 0) { 
    for(int i = 0 ; i < 
nl.getLength();i++) { 
      
     Element PCRF = 
(Element)nl.item(i); 
     NodeList nl1 = 
PCRF.getElementsByTagName("pcrf_id"); 
     if(nl1 != null && 
nl1.getLength() > 0) { 
      Element  PCRF_ID 
= (Element)nl1.item(0); 
     
 if(pcrfID.equals(PCRF_ID.getFirstChild().getNode
Value())) 
      { 
       nl1 = 
PCRF.getElementsByTagName("status"); 
       if(nl1 != null 
&& nl1.getLength() > 0) { 
        Element  
Status = (Element)nl1.item(0); 
       
 Status.replaceChild(dom.createTextNode(status),St
atus.getFirstChild()); 
       } 
      } 
     } 
      
    } 
   } 
 
 第 78 頁 / 共 78 頁 
 
  
2 
 
I. Background of visitation 
Internet of things (IoT) technology apparently will soon penetrate home appliances industrial 
domain. The IoT conceptual technology becomes a compliment of human smart and intelligent life. 
Recently we have witnessed several electronic appliance industries in East Asia such, one of them is 
Samsung has lunched this state of the art technology in their TV product. Samsung Smart TV is 
evidence that IoT technology is now very close to the digital home users.  
 
Once again this competition become very intense, especially for Taiwan, if no urgency will be 
targeting to uniquely applying research efforts in IoT applications, Taiwan’s digital appliance 
industries will face difficulties to shorten the gap in the future. Therefore IoT research in Taiwan has 
to be kept in its vision and continually set up some initiatives to accelerate the IoT research 
advancement.  
 
Responding for this issue, NSC supported IoT project in Taiwan has to strength the research 
initiatives with current progress of IoT technological innovation in East Asia. One of possible 
activity is through proposing collaborative research with leading IoT research center in East Asia 
region.     
 
AutoID Lab is the one of global initiatives in IoT technology developments. Pioneered by MIT then 
spread to several leading Universities in the world, AutoID Labs’ assessment for IoT technology are 
specialized in several domains. For example AutoID Lab KAIST (Korea) focuses on Wireless 
Sensor Node (WSN) based IoT application meanwhile AutoID Lab Fudan University (China) points 
semiconductor technology as their main research area. AutoID Lab Japan in Keio University under 
Japanese prestigious integrated research project: WIDE Project, it aims for human life cycle 
efficiency through intelligent capability of IoT technology. They currently focus on smart logistics, 
smart home, intelligent digital appliance and energy efficiency for consumer electronic devices. 
Based on AutoID Lab Japan performances and research experiences in IoT technology for 
consumer electronic appliances and smart home, our NSC supported IoT project envisions the 
possibility to extend our research collaboration. In detail, there are some important considerations 
leads us to establish a collaborative research with AutoID Lab Japan: 
 
1. Our ongoing NSC supported IoT research project puts efforts in implementing mobile 
networks based infrastructure for IoT applications. However we need to investigate how the 
proposed architecture cope extensibility of general IoT implementation for digital home 
appliance and consumer electronic.   
2. As IoT becomes an important application for future internet, having envisioning the form of 
test-bed can consider as a top priority.  
  
4 
 
researches and 
exchanging scientific 
research results over 
the integrated cross 
region test-bed. 
 
June 28
th
, 2012 
June 29
th
, 2012 
 
Prof. Jin Mitsugi 
 
 Visiting AutoID Lab, 
Keio University to 
learn their current 
IoT technology 
implementation in 
home digital 
appliances and 
consumer electronics 
as well as future 
internet applications 
and investigate the 
possibility for 
research cooperation 
in leveraging cloud 
computing 
application. 
  
 
Keio University 
Shonan Fujisawa 
Campus. 
    
With visiting those three research institutions, we will have complete dimension that supports each 
other in realizing our research frameworks in NSC supported project with visiting objectives for: 
1. AutoID Lab Japan is to obtain a new concept and model for IoT application development for 
consumer electronics and digital appliance, investigate them, and propose a collaborative 
work that related to our conceptual NSC project. It is favorable that cloud computing 
concept can be featured as a research extension for this implementation.  
 
2. NICT Japan is to obtain the current status of future internet test implementation in Japan and 
how its intention for supporting IoT technology. With having this knowledge we will be able 
to obtain a pattern on how our collaborative project with AutoID Lab will be supported in 
the future. 
 
3. Nakao Lab, the University of Tokyo, is to get in line of state of the art network virtualization 
technology. As known that network virtualization technology is the one of supporting 
technology to allow cloud computing service implementation for IoT application in network 
infrastructure.   
 
III. Visitation Details and Research Discussion at AutoID Lab 
  
6 
 
beings. Without this basic function the objects cannot be considered as a smart object. Smart 
objects will cooperate together forming a smart application. Very interesting concept is can back 
to the basic thought how the object originally designed for. Human design the objects to be 
located on certain dimensional area or space. Human interaction with the object should be 
different depends on where and how the object is located. Analyzing the human interaction with 
object and constrained to the spatial area, should be a model of IoT intelligent process. From the 
cloud point of view, the model is presenting knowledge and cloud perception that can be 
mapped to the intelligent process. The intelligent process will be eventually conveyed to the IoT 
device layer to smartly allocate the preferable decision to the users. Therefore human being can 
experience the smart feedback from sub-sensing layer. 
3.2 Research overview at AutoID Lab Japan 
During the visit AutoID Lab members introduces their research progress and implementation of 
EPC architecture in consumer electronics. There were three student presentations about IoT 
application based on EPC architecture. List of their presented research were: 
1. EPC over Home network for total life cycle information management of Consumer 
electronics 
2. Bridging UPnP and ZigBee with CoAP 
3. RFID Passive Tag implementation for melon farming. 
 
 
Figure 1: Research discussion at AutoID Lab. 
AutoID Lab Japan leverages Electronic Product Code (EPC) as their cornerstone to be the core of 
IoT architecture implementation. As extension some application layer protocol such as uPnP and 
CoAP protocol are used for physical device discovery. In their architecture AutoID Lab Japan 
  
8 
 
 
Figure 4: Proposed collaboration research framework. 
With support from proposed JGN-X/TWAREN connectivity and network slices virtualization, we 
will be able to conduct an extensive collaborative research with AutoID Lab Japan. Figure 4 depicts 
the proposed collaborative frameworks which enable us to conduct the cooperative research that 
subjected to three following proposal: 
1. Network virtualization support on data sensing contextualization for digital consumer 
electronic appliances. 
 
With existing EPC-ZigBee infrastructure of AutoID Lab, the system merely obtains static 
status and information from physical objects. IoT application generally receives the data 
through XML. However XML data cannot be used simultaneously to determine the 
contextualization of the status electronics appliances. Here network virtualization concept can 
be applied to allow contextualization from network traffic flows from each sensing 
environment. For example, the electronic devices with the same function may be located in 
different as 
 
2. Inter-cloud computing platform for IoT sensor data. 
This research will be conducted for an initiative for intelligent building and smart house 
technology. The technical implementation will involve the design of Cloud to IoT 
  
10 
 
data model then can be analyzed together and the interaction model in infer the actual 
information historically. Once the model can be inferred to a conclusive information, the 
sense layer of cloud computing will be designed and adjust to act based on the collected 
model of data. Since the model is centralized on the cloud system, the application design on 
the top layer will always reflected to the sensing model. Then is will gather the ease of the 
design should obviously gain when the application is migrated to different spatial area. The 
preliminary advantage of this mechanism will instantly obtain if the application has to be 
implemented on the large number of building or for the large community of houses.  
 
IV. Visit to experimental Japan internetworking test-bed research institutes 
 
4.1. National Institute of Information and Communications Technology (NICT) 
A. Research Discussion Background 
As explained in general purpose of visitation, network virtualization would become a very 
important research domain to support IoT service layer due to its massive contributive part for 
realizing the future internet application especially for evolutional network infrastructure. In recent 
years Taiwan domestic collaborative research has grown their substantial interest for focusing on 
the advancement for virtualized network to support future internet applications. IoT platform 
through IMS infrastructure is a potential research establishes promising advancement for mobile 
communication infrastructure. Currently Taiwan’s open internet test-bed e.g.: TWAREN and 
TANET have been utilized as underlying physical networks where the experimental applications for 
future internet applications are not only positively engaged as an extended research facility but 
actually it becomes a catalyzer for academic institution to elaborate their research results.  
 
Figure 5: NICT research meeting. 
  
12 
 
to allow various tests. The JGN-X network equipment includes layer2 switches and layer3 routers, 
and it has 26 access points nationwide. The backbone networks connecting the main access points 
consist of networks from 10 to 40 Gbps. Other access points are connected by bandwidths such as 1 
Gbps. L1 Environment: Physical network, including optical test-bed, L2 Environment: Network 
based on VLAN connectivity provided by layer2 switches, L3 Environment: Network based on IP 
connectivity with IPv4/IPv6 dual stack capability. 
 
Figure 7: JGN-X test-bed architecture. 
 
C. Proposal for TWAREN integration with JGN-X 
Regarding to the motivation, in this visitation research discussion, we point out a fundamental 
proposal to integrate our TWAREN (iGENI enabled) with NICT JGN-X. Current global L1 
interconnection of JGN-X is showed by Fig. 7. Obliviously there is no direct physical connection 
between JGN-X with any test-bed infrastructure in Taiwan. Interestingly as presented in section A, 
TWAREN has L2 connectivity with StarLight networks in the USA. Therefore our discussion with 
NICT side is focusing on establishing the connection via Starlight networks.  
  
14 
 
test-bed networks. The further implementation will involve the automatic domain discovery as the 
first step of scientific testing. The details for future achievement by the discussions: 
1. By undertaking the discussion regarding to integration between Taiwan test-bed network, 
one the integration has been established, each side Taiwan and Japan will investigate 
possible experimental collaboration involving IoT research issue.  
2. Possible scientific issue for the collaborative can be initiated by firstly prioritizing the 
TANET – JGN-X connectivity. The work extends by Taiwan National Center for 
High-Performance Computing (NCHC). 
 
4.2. Nakao Lab, the University of Tokyo 
 
A. Motivation: Network Virtualization: Network Programming  
Nakao Lab at the University of Tokyo, led by Prof. Akihiro Nakao,  who has a strong connection 
with NICT, NTT, KDDI, NEC, Hitachi and Fujitsu. He has been involved in some massive project 
with Japanese global companies as well as from government projects.  
 
Figure 10: Nakao Lab research meeting. 
As network virtualization appears a novel topic which it is intended for optimizing a network link 
for simultaneously used for difference applications, many networking research institutes pay a great 
attention for this research topic. What makes Nakao Lab of the University of Tokyo become very 
special for this particular research is their assessment for network virtualization comes with a 
different perspective. In the typical perspective this research, network virtualization is seen as a 
methodology to distinguish different data flow for a specific application. However Prof. Akihiro 
Nakao and his research team have a breakthrough from network virtualization perspective. 
“Network” is a communication infrastructure including link resources as well as processing and 
  
16 
 
 Network slices has capabilities to distinguish each flow inside the operation network, even 
for non-IP traffic. This capability allow the vision that inter-cloud computing service will be 
able penetrate the different traffic flow mechanisms. This means regardless the network  
 Network slices can be in-cooperated with network programming method. Therefore it would 
be very interesting to allow even more dynamic cloud computing application. For example 
for implementation of SLA.  
Therefore through the discussion, we are agreeing to have a collaborative project with Nakao Lab to 
build a research framework that allow inter-cloud computing operation with the support of network 
slices mechanism.  
 
2. Network Slicing for sensing network environment. 
IoT infrastructure relies deeply on wireless network infrastructure, therefore the conveying sensing 
and identification data have to be conducted in different manner, allows a certain treatment and 
traffic management. This concept should be undergo over a particular method, where wireless 
network can be dedicated the particular environment.  
 
During the research discussion with Prof. Nakao, he introduces WiVi technology which becomes 
the core technology developed by Nakao Lab. The WiVi technology is featuring the network slices 
mechanism in infrastructure and non-infrastructure wireless network.  
 
Figure 12: WiVi network slices. 
The WiVi basically aims for possibility for more than one functional service implementation 
through specific wireless network infrastructure. In this case this capability will be very convenient 
platform to provide isolated service by the wireless network. A WiVi example given in Fig. 12, with 
sole WiVi access point it can serve two or more wireless data-link type. 
 
Based on the example of WiVi implementation, we come to the possibility of providing different 
slices of wireless networks based on IoT application contextualization. For example given there are 
  
1 
 
 
行政院國家科學委員會補助專題研究計畫 
■成果報告   
□期中進度報告 
 
未來網際網路 IoT-IMS 通訊平台研究計畫 
子計畫四：未來網際網路 IoT-IMS 通訊平台之服務品質與資源
管理研究(1/2)  
計畫類別：□ 個別型計畫 ■ 整合型計畫 
計畫編號：  NSC 100－2219－E－011－004 
執行期間： 100年 5月 1日至 101年 6月 30日 
計畫主持人：陳俊良   國立台灣科技大學電機工程學系 
計畫共同主持人: 楊竹星 國立成功大學電機系 
計畫參與人員：蘇彥寧、黃志欽、鄭秉昇、陳品良、張新毅、邱柏盛  
 
成果報告類型(依經費核定清單規定繳交)：□精簡報告 ■完整報告 
 
本成果報告包括以下應繳交之附件： 
□赴國外出差或研習心得報告一份 
□赴大陸地區出差或研習心得報告一份 
■出席國際學術會議心得報告及發表之論文各一份 
□國際合作研究計畫國外研究報告書一份 
 
處理方式：除產學合作研究計畫、提升產業技術及人才培育研究計畫、列管
計畫及下列情形者外，得立即公開查詢 
          □涉及專利或其他智慧財產權，□一年□二年後可公開查詢 
          
執行單位：國立台灣科技大學電機工程學系 
中   華   民   國  101 年 6 月 30 日 
附件一 
  
3 
 
 
圖一：DIUF(University of Fribourg) 演講海報 
 
 
二、心得與建議 
 
利用參加 IEEE 2nd Baltic International Conference on Future Internet Communications 國際
會議之際，參訪了 University of Fribourg 並給予一場 Keynote Speech，收穫良多。除了吸收了
Fribourg 大學 IoT 最新研究成果外，亦暸解目前歐洲各國/FP7 著重之 IoT 研究項目與未來研
究發展方向。國內研究機構應更積極與國外相關研究組織與學術單位密切聯繫，必須時常參
加或舉辦相關的研討會議，以加強國際合作及師生交流活動，共同擬定台灣未來科技發展方
向；更重要的，要不斷參與世界脈動，與全球共同發展，期望打造出台灣學術全新的視野與
未來。 
 
In addition faculty staffs within Software Engineering Group and University has grown their 
deep interest upon IMS technology realization for IoT applications. Currently in cooperation with 
University of Applied Science, software engineering group University of Fribourg is undergoing a 
medical application project for mobile platform. The application is based on RESTful technology 
and Java Object representation. Current version of application is not intended for scalable 
implementation. However through the keynote the IMS+ID gives an extent idea about for this 
application can be scalable implemented on telecommunication infrastructure. Mobile System 
Competence Group (MobSysCG) led by Prof. Jean Frederic Wagen that focuses on IMS research 
topic has overseen the possible implementation for cooperative IMS systems. 
  
5 
 
出席 Internet Society Chapter Leader Workshop & iNet International Conference 
國際會議心得報告 
 
一、參加會議經過 
     
    Internet Society Chapter是一個國際組織，今年是20周年，所以擴大舉辦慶祝與研討會議。
本次國際會議分成兩個會議：Internet Society Chapter Leader Workshop (2012/4/20-2012/4/21)
及 iNet Conference (2012/4/22-2012/4/24)。Internet Society Chapter Leader Workshop 是大會邀請
國際上 100 位各國 Chapter Officer 參加，分享 Internet 政策運作及未來發展，並由大會資助
部分旅費及生活會，我因代表 iSOC Taiwan Chapter 獲邀出席(如圖二所示)。iNet Conference
是全程開放參加的會議，邀請全球對 Internet 架構、政策、應用有影響力的政府官員及公司分
享 Internet 的發展願景。 
 
 
圖二：代表 iSOC Taiwan Taipei Chapter 獲邀出席 email 
 
(1) Internet Society Chapter Leader Workshop 
 
Chapter Leader Workshop 是一個相當嚴謹會議，與會前各 Chapter 代表須先填寫
Questionnaire（如附件 2 所示），大會根據各國 Chapter 代表的 Questionnaire 內涵，分開圓
桌討論，每一圓桌 8 位代表，會議安排於 4/20(星期六)及 4/21(星期日)，從早上 9:00 至下
午 5:00，須全程與會。會議運作如下： 
  
7 
 
 
圖三：大會頒發之與會證書 
 
 
圖四: iSOC Taiwan Chapter 獲得 Chapter Award 
 
(2) iNet Conference 
 
 Internet Society 為針對網際網路政策、技術標準與未來應用發展的獨立協會，透過各地所
設立之辦事處，確保網際網路和建立在網際網路上之網路可做為開放平台提供永續服務發展。
目前 Internet Society 在 72 個國家有 80 多個分會，本次 2012 iNet Conference 中各國皆派出其
Chapter 代表參與此次會議並進行討論。 
 
 本次 iNet Conference 中安排了多位國際知名專家、學者進行專題演講，其中於 Opening 
Session (如圖五所示) Keynotes 演講者中有 Dr. Hamadoun Touré (國際電信聯盟秘書長)、Jimmy 
Wales (Wikipedia 創辦人)、Francis Gurry (世界知識產權組織總幹事)、Mitchell Baker (Mozilla
專案的領導者)、Vinton G. Cerf (Google 副總裁)、Leonard Kleinrock(UCLA 特聘教授)與 Lynn St. 
Amour (Internet Society 總裁兼執行長)， 講述了 20 年前至今日網際網路的歷程，人們如何運
  
9 
 
 
圖七: iNet 晚宴 
 
 
圖八: 與 iNet 與會者合影 
 
二、心得與建議 
 
 本次參加此 iSOC 及 iNET 國際會議收穫不少，除了吸收了各國最新研發成果及 Future 
Internet 政策外，亦暸解目前國際上著重之研發項目與未來研究發展方向。此外透過國際交
流對促進我國網路發展有很大的推進作用，因此國內政策研發機構應更積極與國際相關組織
密切聯繫，必須時常參加或舉辦相關的國際會議，以加強國際合作及交流活動展開，共同擬
定台灣未來科技發展方向；更重要的，要不斷參與世界脈動，與全球共同發展，期望打造出
台灣 Future Internet 全新的視野與未來。會後，本人亦代表 iSOC Taiwan Taipei Chapter 撰寫
  
11 
 
出席 IEEE 2nd Baltic International Conference on Future Internet Communications   
國際學術會議心得報告 
                                                             
一、參加會議經過 
 
In the midst of Europe economic recession that being happened in Greece and Spain, surprisingly, 
Eastern Europe and Baltic countries show different trend of economic growth. Especially in the area 
of ICT development, Baltic countries such as Lithuania, Latvia and Estonia become pioneers on 
internet infrastructure implementation and application. For example, based on speedtest.net 
Lithuania is rank number one in the term upload and download speed in the world by October 30, 
2011. This evidence proves that the Baltic countries are promising market as well as industry in ICT 
development in Europe.  
 
With this emerging trend within Baltic countries, some academic institutions and scholars within 
Baltic area, initiated Baltic Congress on Future Internet Communications (BCFIC) that intended for 
annual event. The first BCFIC was held in Riga the capital of Latvia, and then the 2
nd
 BCFIC is 
held in Vilnius Lithuania. 
 
The conferences address all the challenges of building the Future Internet, which based on mobile, 
wireless and fixed broadband communications infrastructures. BCFIC become a stages for 
researchers, officials, decision makers, practitioners from the public sector and industry, people 
involved in other related initiatives and many others. The conference facilitates knowledge transfer 
to the community and practitioners by promoting results dissemination. 
 
The Scientific Program incorporates all the components of Future Communication Networks 
including the topics Future Internet Technologies, Internet of the things, wireless networking for 
moving objects etc. The Internet of the Future incorporates a large number of autonomous wireless 
objects moving with diverse patterns and speeds while communicating via several radio interfaces. 
Examples of such objects may include humans, cars or unmanned aerial vehicles, with every object 
acting as a networking device generating, relaying and/or absorbing data. Achieving the Internet of 
the Future, will require global interoperability amongst objects/devices, not typically common place 
due to inherent features of today’s Internet. To overcome the current shortcomings, a number of 
research challenges have to be addressed in the area of networking, including protocol engineering, 
development of applications and services, as well as realistic use-cases. Applications, services, 
overlay networking will receive a special treatment within the Congress. 
 
  
13 
 
Wireless System. These sessions are preceded by two keynote speakers:  
 
a. Yaakov Kogan (IEEE Fellow) with his talk about “A Metric for Assessing Production Failure 
Rates in Telecommunications Networks”. This talk presents Mean Time Between Outages 
(MTBO) metric that provides the frequency of failures in telecommunications network 
elements (hardware and software) attributed to equipment supplier. He pointed that traditional 
Mean Time Between Failures (MTBF) metric only addresses total failures that lead to element 
replacement. MTBO allows capturing short duration outages (of the order of 1 second) which 
can interrupt such services as streaming video, telepresence, and online gaming. Interestingly 
he said that the traditional Availability metric is not sensitive to short duration outages in the 
presence of long duration failures. Application of MTBO is demonstrated for a wide range of 
network elements in wire-line and wireless networks including IP routers, Ethernet networks 
connecting a large number of cell routers to a redundant concentrator, mobility equipment 
with redundancy and power amplifiers in the Universal Mobile Telecommunications System 
(UMTS) base station (nodeB). Requirements to MTBO measurement tools are outlined. In 
case of hardware failures, the router MTBO is evaluated using absorbing Markov models. 
 
b. Boris Moltchanov, Telecom Italia on his talk about “European Future Internet tackling Clouds 
on the European Research Horizon”. This second keynote was emphasizing the trend of cloud 
computing application and implementation in European research institutes which enable the 
industrial point of view on how far this technology fits to current infrastructure in Europe.  
 
The accepted paper: Socio-Organism Inspired Model Forming Multi-Level Computational Scheme 
for Integrated IoT Service Architecture was presented in the session of Building Broadband 
Infrastructure. The presentation was responded with interesting discussion and feedbacks.  
 
此 Session 中共有五篇研究成果發表，除本人所發表之研究成果外，另外四項研究報告分
別為 MTBO - A Metric for Assessing Production Failure Rates in Telecommunications Networks、
Investigation of Maximum Distance Reach for Spectrally Efficient Combined WDM Systems、
Regulatory Framework and Technical Aspects of Broadband Access to the Internet in Europe、
Comparison of Chromatic Dispersion Compensation Techniques for WDM-PON Solution，皆與本
研究領域範疇相關聯，因此本人亦積極與其參與討論，相關研究成果將可作為本計畫未來研
究方向之基石。  
 
III. 2012/4/27: The last day of the conference present three sessions: Internet of Things and Smart 
Spaces, and split sessions of Traffic analysis, routing and protocols. The first session gave 
variety on IoT application implementation. Some papers present technical issue on Mobile 
applications Operating system development for IoT and M2M protocol. And others has discussed 
  
15 
 
附件 1- Keynote Speech- University of Fribourg 
 
Summary of Keynote 
 
The Keynote aimed on the emerging of Internet of Things (IoT) as an evolutional technology 
and endeavors as a top priority research agenda. The actual problem is, the IoT’s current 
development tends to merely combine some existing technological aspects and methodologies. 
Indeed, through its potentials, IoT technology should create optimistic commercialization by 
applications extensibility to serve every single aspects of human’s life. This ambitious goal has to 
be supported with a unique framework of integrated IoT service architecture, where in another 
aspect bringing IoT application to a standardized framework becomes an intriguing issue and 
attracts great concern from telecommunication industries.  
 
Realizing a new model for an integrated IoT service architecture becomes a preliminary as well 
as an imperative task for accomplishing further extension of IoT application implementation. 
Without prioritizing research efforts on IoT architecture technology, achieving IoT technology 
standardization will become problematic tasks in the future. IoT infrastructure should be consisted 
by heterogeneous entities which interoperability, scalability, and extensibility between them become 
the goal of IoT architecture design. Migration from RFID architecture, extension of service oriented 
architecture (SOA) and semantic mediator employment could be a fascinating prelude for defining 
future IoT architecture. Unfortunately, implementing those solutions will not solve the fundamental 
problem of IoT architecture on its inflexibility to adapt heterogeneous business processes. However, 
if the vision of implementing the future IoT architecture model could not be defined in a unique 
approach, the ultimate goal of IoT technology becomes completely difficult to be achieved. 
Capturing the problem, a sophisticated research effort is required to develop a concept to create 
unique architecture and framework for IoT application implementation.  
 
The keynote presents a research effort conducted by WNEC Lab Taiwan Tech in pursuing IoT 
architecture integration into telecommunications infrastructure. It observes a methodology on how 
IoT applications are designed and to be standardized and seamlessly integrated into 
telecommunication network systems. Leveraging the benefits of IP multimedia sub-system (IMS) 
capability to convey Internet service into telecommunication networks, a framework namely 
IMS+ID is constructed as IMS extension for IoT object identification system as standardized 
operation management for IoT infrastructure. It eventually allows Quality of Service (QoS) 
treatment for each IoT application. Fundamental approach on IMS+ID implementation is to convey 
EPCIS middleware services into HSS module in IMS platform. Therefore through this framework 
IoT gateway will be able to discover any object at any event, identify them and post their service to 
  
17 
 
functionality and feature to the internet user. What we have conducted in 2011 was the 
introduction of cloud computing service layer over IPv6 framework.  
 Reach a significant number of IPv6 based application ready in the market at the end of 
2012. Meanwhile we will continually expand the campaign of more “v6” applications 
available in for internet users. 
 A forum to accommodate the internet application developers has been established. 
Through the forum we would be able to conduct an effort to stimulate the developers 
especially in mobile applications, to develop application based on IPv6 infrastructure 
and framework. 
 Obtain detailed statistics about IPv6 related researches in Taiwan research and academic 
institution, and then act as active mediator enabling research cooperation to enhance the 
research and advancement in IPv6 researches. 
 Establish cross-nation IPv6 infrastructure that empowering by our capacity as mediator. 
With the infrastructure we will be able to increase the number cross nations research 
cooperation in IPv6 study. The scale of cooperation is initiated from East Asian and Asia 
Pacific regions.  
 
2. In order to extend ISOC existence and capacity as a trusted global internet community 
among internet users, we plan to conduct systematic plans and activities which eventually 
produce unique impacts but still it is integration for achieving ISOC community awareness 
and possible future leader re-generation. Some activities and programs  
 
 Hold some events creativity competition promoting the ISOC label through people’s 
creativity competition, for instance photography competition. The activities attract 
people’s eagerness in envisioning ISOC community through different way. The event 
then extended in academic level to attract young talented participants. 
 
 Increase the number of ISOC role and mission through the social networks, especially 
domestic social networks in Taiwan such as plurk and PTT BBS. The Taiwan domestics’ 
social network has million users and about more than a half of users are young people 
currently active in academic institution. This will allow us to have greater expected 
impact of ISOC mission campaign. 
 
 Provide e-learning system that can help internet users especially in academic institution 
to obtain fresh knowledge about future internet technology.  
 
5. What resources will your Chapter need to accomplish that goal(s)? 
 
  
19 
 
chapter workshop would give benefits for other chapters when they can grab our framework models 
that could be possibly applied in their chapter. 
 
 
 
附件 3- iSOC Taiwan Chapter 之 Impact Report 
 
 
1) ISOC Chapter Travel Fellowship Impact Report 
 
This Impact Report is for you to demonstrate how the funding has been of real benefit to the 
Chapter and to the community. This should be submitted no later than two (2) months after the trip 
to <chapter-support@isoc.org>. 
 
Please describe the activities you undertook to share the event experience and the knowledge 
you gained at the event with your Chapter and your local or regional community. Please be as 
specific and detailed as possible. Activities could include events, meetings, speaking 
engagements, seminars, etc. 
 
 
1. Follow-up and evaluation meeting – Taiwan Internet Trend Seminar 
 
a. Background 
Prior to the Geneva chapter leader workshop, TWNIC held Taiwan Internet Trend Seminar in 
March 28 to 30, 2012. The main agenda was the socialization of future internet core 
technologies such as IPv6, Internet of Things and Cloud Computing. The objectives of this 
event are matriculated on the sense of collaborative framework. It is very obvious since this 
event obtain massive attentions and supports from Taiwan government, ICT industries and 
notable Taiwan Universities. This particular event also got full support from ISOC Taiwan 
Chapter. 
 
b. Meeting details and objectives 
  
21 
 
 
Figure 1: Future internet research group meeting. 
 
In them meeting, the main agenda was to discuss the progress of each group. After the main 
agenda, a short presentation was given to share some points of ISOC Chapter leader workshop 
in Geneva and introduced the ISOC role in global as well in domestic domain. The main 
objective of the presentation was to stimulate the project to support open Internet tool 
technology development. In addition we also motivate the participants especially student to 
access resources from ISOC Global website.  
 
Will you continue sharing your experience with others, and if so, how? 
 
Yes, I will keep continue to share my experiences within Taiwan Chapter member and even 
non-member. Based my career in Taiwan higher academic institution, I would have more 
opportunity for me to share my knowledge to the students as new young generation. Possible tool or 
opportunity that I would use to share my experience: 
 
1. Teaching and lecture activity: main topic of my lecture is information and communication 
technology. Assume that student take this class has basic interest on ICT technology. Then 
thought my interactions with the student, it would be a best way to share my experience in 
joining ISOC program.  
 
2. Online academic platform: I join a project for open academic platform, namely Information 
Technology Software Academy (ITSA) supported by Taiwan Ministry Education. Based on 
strong domestic higher level academic institution network in Taiwan the ITSA project develops 
an open source software community to provide the best human resources and software 
professional services for industry. More than 15000 users are registered and actively access this 
platform. The platform is featuring academic resource sharing within global academic network 
  
23 
 
Describe any challenges you had or lessons learned from your experience of attending the 
event. 
 
1. Main sessions 
My experiences while attending ISOC global chapter workshop was the great impression toward 
quality of the sessions offered. The topic covered is very comprehensive, furthermore each 
session provided sharing from particular Chapter about what they have done. I think in the 
future we need to give more spaces and opportunity for not only successful Chapter but also the 
Chapter that has particular or unique problems to share their condition. 
 
2. Table discussion 
Yet the table discussion arrangement became a very good setting to allow deeper discussion 
within the chapter members. Another good point was the sharing condition in the group that one 
chapter learn about specific condition, necessities, current implementation and activities from 
the chapters. However there was fundamental problem in manage the opportunity to talk 
regarding to  
 
3. Participants diversity 
The chapter member who grouped by committee was from different backgrounds that settled on 
the same table to be accomplished each other. Each discussion session was taken for 55 minutes. 
From my personal perspective, capturing the session talk, formulating and accumulating the 
idea would be strongly affected with each chapter backgrounds. The representatives from each 
chapter are very diverse. Some of representatives have attended global chapter workshop 
previously, in the other hand some representative are new and young. This will create significant 
gaps in table discussion, but still these difficulties can be finally solved. However this 
impression might be different among other participants.    
       
 
 
 
 
 
 
 
 
 
 
 
  
25 
 
Please describe any new partnerships formed with people you met at the event. 
 
As part of Asia Pacific Chapter, Taiwan chapter is eager to look forward for any opportunity for 
partnership with other chapter in our region. From the workshop I learn that how internet 
technology development should be balanced, started from regional scope, which support the 
availability of users’ connection to the Internet. These understandings stimulate my perspective to 
share our Chapter strength in IPv6 technology implementation.  
   
During the meeting in Geneva, I met Mr. Pheakavoin Vong from Cambodia Chapter. We had some 
discussion and share about condition, activities and program implementation from each of our 
Chapter. From that discussion I intend to extend our partnership in the future. After the workshop 
we still continue the contact with Mr. Vong. We currently continue our discussion unregularly with 
one of Taiwan Chapter member Mr. Teofilus Larosa. 
 
From the last discussion we agree to have a real goal in the future. The goal is regarding to IPv6 
development program in Cambodia. As mentioned before Taiwan Chapter has adequate capacity to 
share the IPv6 technological and policies implementation. We have requested Mr. Vong to provide 
us their overview and current status of IPv6 development, so we can learn how we can contribute 
directly for Cambodia Chapter.  
 
Basically we try to set two real objectives from this partnership: 
3. By learning from Cambodia Chapter overview, we can identify actual and urgent needs from 
Cambodia Chapter. Therefore we may allocate our resources as contribution to their Chapter. 
We set three possible contributions: 
a. Provide document or training material from our Chapter about IPv6 development. 
b. Send our expert to Cambodia Chapter to conduct short training for the development, 
c. Invite eligible Cambodia Chapter member to visit our Chapter. 
 
For this planned activities we hope that Asia Pacific Chapter would be able to be facilitator as 
well as supports to realize our plan.  
 
4. By having experience in contributing useful tools Cambodia Chapter, we can learn about the 
challenges and model that could be implement in the future partnership with developed 
country for regional ICT development. 
       
Please describe how attending this event influence activities or programmes at your Chapter 
(if at all)? 
 
  
27 
 
附件 4- 2nd International Conference on Future Internet Communications-發表之論文 
A. Socio-Organism Inspired Model Forming Multi-Level Computational Scheme for 
Integrated IoT Service Architecture 
 
  
29 
 
 
 
 
 
  
31 
 
B. Optimal QoS Load Balancing Mechanism for Virtual Machines Scheduling in Eucalyptus 
Cloud Computing Platform 
 
 
  
33 
 
 
 
 
 
  
35 
 
 
 
  
37 
 
 
 
 
 
國科會補助計畫衍生研發成果推廣資料表
日期:2012/03/05
國科會補助計畫
計畫名稱: 子計畫四：未來網際網路IoT-IMS通訊平台之網路服務品質及維運管理研究
(1/2)
計畫主持人: 陳俊良
計畫編號: 100-2219-E-011-004- 學門領域: 通訊軟體及平台(網通國家型) 
研發成果名稱
(中文) IMS與ID平台發展於物聯網物件識別系統之應用
(英文) IMS+ID platform for Application of IoT object identification system
成果歸屬機構
國立臺灣科技大學 發明人
(創作人)
陳俊良,蘇彥寧,黃志欽,鄭秉昇,
陳品良,張新毅,邱柏盛
技術說明
(中文) 物聯網和通訊產業的結合，加速整合應用發展的實現。現今物聯網的應用已發展
為標準化並且與無縫通訊網絡系統的整合。與IP多媒體次系統(IMS)的整合已成
功地展示通訊網路系統和服務網路結合多媒體應用的處理能力且可提供標準化及
可測量之QoS 服務應用，如計費系統和通訊網絡運用之控管機制。本研究設計了
一套IMS與ID整合平台，其IMS與ID 表示IMS 延伸為物聯網物件識別系統，以作
為QoS 應用處理的規範管理。IMS 與ID實現Fosstrak中介平台整合IMS用戶服務
伺服器的建置。因此，物聯網Gateway 可在任何情況下發現任何物體，並且加以
辨識和提供應用層的服務。如物聯網Gateway 嵌入於行動終端設備中，將確定物
件ID和特性的識別功能，其所驗證的物件，將觸發以感知層為服務分級管理優先
之物件識別基礎的PCRF 功能應用機制。
(英文) The IMS+ID are implemented by integrating the Fosstrak middleware service into HSS 
module at IMS on cloud computing system. Therefore IoT gateway will be able to 
discover any object at any event, identify them and post their service to IoT application 
layer with medical application implementation. The identified object then will trigger 
Policy and Charging Rules Function (PCRF) function base on event classification from 
IoT perception layer to manage the IoT traffic priority based on application scenario. IoT 
gateway functionality embedded on mobile device is constructed to enable event 
signature function to identify the object ID and its characteristics.
產業別 農業；批發業；航空運輸輔助業；倉儲業；電信業
技術/產品應用範圍
The project triggers and pushes mobile applications market for new extensive 
number of killer applications. When telecommunication operators implement 
this framework, the application developers will be motivated to extend their 
design to a new scope of IoT application.
技術移轉可行性及
預期效益
本計畫以物聯網之概念，結合可運用於異質網路之IMS 平台，設計一套未來網際網路
IoT-IMS 通訊平台，讓使用者透過行動終端設備、感測器、智慧裝置等連線至網際網路，
並透過雲端運算技術，使大量資訊藉由雲端進行運算、存取，獲得高速運算能力與儲存
空間，減少因大量資料存取所造成之系統延遲，即時將所需之應用服務，傳送至遠端裝
置中。本計畫將延續前期所執行之成果，結合IoT-IMS通訊平台，確保整體網路架構之服
務品質，並利用相關管理策略，達到整體架構維護之功能。
註：本項研發成果若尚未申請專利，請勿揭露可申請專利之主要內容。
5.IoT-IMS 
Communication 
Platform for Future 
Internet(SCI) 
6.RFID-Based 
Positioning System 
for Telematics 
Location-Aware 
Applications(SCI) 
7.Design and 
Consideration of 
Intergrated PLC and 
3G Mobile Networks 
as Internet of 
Things 
Architecture(EI) 
8.Evaluation of 
Dynamic Perception 
Layer Scenarios 
Toward Energy 
Dissipation of 
Mobile IoT Gateway 
(in review)(SCI) 
9.A RESTified IMS 
Architecture 
Enabling Seamless 
Operation for IoT 
Application 
Services (in 
review)(SCI) 
研究報告/技術報告 1 1 100% 
研究報告’’未來網
際網路 IoTIMS 通訊平
台之網路服務品質及
維運管理研究’’ 
研討會論文 2 0 100% 
1.IoT Operations 
Management and 
Traffic Analysis for 
Future Internet(EI)
2.Socio-Organism 
Inspired Model 
Forming Multi-Level 
Computational 
Scheme for 
Integrated IoT 
Service 
Architecture (in 
review)(EI) 
專書 0 0 100% 章/本  
研討會/工作坊 0  
電子報、網站 0  
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
