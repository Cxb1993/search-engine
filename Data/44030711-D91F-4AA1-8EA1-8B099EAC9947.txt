i 
??????? 
???? 
?????????????????????????????????
??????? G??????? T?G???? T????????????
????????? PC???? T???????? PC??????????
???????? G ???? T ????????????????????
? T??????????????????????????????????
??????????????????????????????????
???????????????????????????????????
???????????????????????????????????
????????????????????????????????????
??????????????????????????????????? 
???? ??????????????????????????????
??????? 
 
 
iii 
?  ? 
??????? ............................................................................................................ i 
?????? ............................................................................................................... 1 
??????............................................................................................................ 1 
?????????????................................................................................ 2 
????????.................................................................................................... 3 
?????????.............................................................................................. 10 
?????? ............................................................................................................. 12 
???????? ..................................................................................................... 14 
???The Terminal Path Cover Problem in Graphs  
 
 
 
 
 
 
? 2 ? 
G w.r.t. T is a path cover of G such that 
the vertices of T are all end vertices of 
the paths in the path cover. A minimum 
terminal path cover of G w.r.t. T is a 
terminal path cover of G of minimum 
cardinality. The terminal path cover 
problem is to find a minimum terminal 
path cover of G. We denote the 
cardinality of a minimum terminal path 
cover of G w.r.t. T by π(G, T ), called the 
terminal path cover number. We call T 
the terminal set of G, the vertices in T 
the terminals, and the other vertices free 
vertices.  
????????????? 
The path cover problem is a special 
case of the terminal path cover problem 
with T = φ. The terminal path cover 
problem can be applied to the 
applications of the path cover problem 
when some vertices corresponding to the 
applications are restricted to be 
terminals. For example, the terminal 
path cover problem can be applied to 
find a VLSI layout with a set of node- 
disjoint paths of minimum cardinality 
such that some nodes must be end nodes 
of paths in the set, where electronic 
components are represented as nodes. 
A vertex of a graph is called a 
pendant vertex if its degree is one. Let G 
= (V, E) be a graph and let S ⊆ V. We 
construct a new graph PV(G, S) from G 
NP-Complete
Perfect
Weakly Chordal ParityComparabilityCocomparability
Split
Undirected
Path
Strongly
Chordal
Directed
Path
Bipartite
Interval
Circular-
Arc
Block
Distance-
Hereditary
Bipartite DH Ptolemaic
Cograph
Permutation
Trapezoid
Chordal
Bipartite
Bipartite
Permutation
Threshold
Tree
Chordal
Circle
Polynomial
Fig. 1: The complexity status (NP-complete, Polynomial) of the path cover 
problem for some graph subclasses of perfect graphs, where A → B indicates 
class A contains class B. 
? 4 ? 
from the terminal path cover problem to 
the path cover problem. Let G = (V, E) 
be a graph and let T  be a terminal set of 
G. We construct a new graph PV(G, T ) 
from G as follows: for every vertex t in 
T, we add a new vertex t' to G and 
connect t to t' with a new edge. It is easy 
to see that PV(G, T ) can be obtained 
from G in O(|T |) time. Then we prove 
π(G, T ) = π( PV(G, T ), φ).  
First, we prove that π(G, T ) ≥ 
π(PV(G, T ), φ). Let PCT be a minimum 
terminal path cover of G w.r.t. T and let 
P be a path in PCT such that its end 
vertex is a terminal t. Let t' be a pendant 
vertex of PV(G, T ) such that t' is 
adjacent to t but is not in G. By 
extending P to visit t', i.e. P = P→ t', it 
is still a path in PV(G, T ). Repeat the 
above process until every pendant vertex 
of PV(G, T ) not in G is covered by one 
path in PCT. Then, we obtain a path 
cover of PV(G, T ) of size |PCT |. Thus, 
π(G, T ) ≥ π(PV(G, T ), φ).  
Next, we prove π(G, T ) ≤ π(PV(G, 
T ), φ). Consider a minimum path cover 
PC of PV(G, T ). Let t be a terminal in G, 
t' be the pendant vertex in PV(G, T ) 
such that t' ∉ G and t' is adjacent to t in 
PV(G, T ), let P' be a path in PC covering 
t', and let P be a path in PC covering t. 
Note that if |P'| = 1, then P ≠ P'; 
otherwise, P = P'. We then do the 
following. If |P'| > 1, then we just 
remove t' from the path (since t' has 
degree 1, t' must be an end vertex of P'). 
If |P'| = 1 (i.e. P' visits t' only), then we 
remove P' from PC and split P into two 
pieces so that t is an end vertex of one of 
them. Note that if |P'| = 1 and t is an end 
vertex of P, then PC − {P, P'} ∪ {P→ P'} 
forms a path cover of PV(G, T ) of size 
less than |PC| and it contradicts that PC is 
a minimum path cover of PV(G, T ). 
Each of these above operations does not 
increase the number of paths in PC. 
Repeat the above process until all 
pendant vertices of PV(G, T ) not in G 
are removed. Then, we obtain a terminal 
path cover of G w.r.t. T of size at most 
|PC|. Thus, π(G, T ) ≤ π(PV(G, T ), φ). It 
follows from the above arguments that 
π(G, T ) = π(PV(G, T ), φ). 
A graph class C is said to be closed 
under the pendant-vertex operation if for 
every graph G in C with terminal set T, 
PV(G, T ) is also in C. By the above 
reduction, it is easy to see that in this 
case the terminal path cover problem on 
G w.r.t. T can be reduced to the path 
cover problem on PV(G, T ) in O(|T |) 
time. Thus, if the path cover problem on 
PV(G, T ) is solved in O(T(n)) time, then 
the terminal path cover problem on G 
w.r.t. T is solved in O(T(n)) time, too. 
Thus, we conclude the following 
theorem. 
Theorem 1. Let C be a graph class 
closed under the pendant-vertex 
operation. If the path cover problem on 
C is solved in O(T(n)) time, then the 
terminal path cover problem on it is also 
solved in O(T(n)) time. 
It is not difficult to see that trees, 
block graphs, Ptolemaic graphs, bipartite 
distance-hereditary graphs, distance- 
? 6 ? 
(2) π(G, T +v) ≥ π(G, T ); 
(3) π(G−v, T ) + 1 ≥ π(G, T +v) ≥ π(G−v, 
T ). 
Proof. Since a minimum terminal path 
cover of G−v w.r.t. T together with the 
path v forms a terminal path cover of G 
w.r.t. T+v, π(G−v, T ) + 1 ≥ π(G, T +v). 
Since a minimum terminal path cover of 
G w.r.t. T +v is a terminal path cover of 
G w.r.t. T, π(G, T +v) ≥ π(G, T ). On the 
other hand, suppose that PC is a 
minimum terminal path cover of G w.r.t. 
T +v. Consider removing vertex v from 
PC. What results is a terminal path cover 
PC* of G−v w.r.t. T. Since the deletion of 
a terminal in PC will decrease the 
number of paths by at most one and v is 
an end vertex of a path in PC, we get that 
|PC*| = |PC | or |PC*| = |PC | − 1. Since PC* 
is a terminal path cover of G−v w.r.t. T, 
|PC*| ≥ π(G−v, T ). Thus, |PC | = π(G, T +v) 
≥ |PC*| ≥ π(G−v, T ). Combining with 
Statement (1), we obtain that π(G−v, T ) 
+ 1 ≥ π(G, T +v) ≥ π(G−v, T ). Q.E.D. 
The following corollary can be 
easily verified from the above lemma. 
Corollary 6. Assume G is a graph with 
terminal set T and v ∈ V(G) − T. Then, 
π(G, T ) > π(G−v, T ) if and only if π(G, 
T ) = π(G, T +v) = π(G−v, T ) + 1. 
Now, we will review block graphs 
and introduce a tree-like decomposition 
structure of a block graph. Let G be a 
connected graph. A vertex v in G is 
called a cut vertex if the removal of v 
from G increases the number of 
connected components. A block is a 
maximal connected subgraph without a 
cut vertex. The intersection of two 
distinct blocks contains at most one 
vertex, and a vertex is a cut vertex if and 
only if it is the intersection of two or 
more blocks. Consequently, a graph with 
one or more cut vertices has at least two 
blocks. A connected graph is a block 
graph if every block in it is a clique 
(complete graph). Note that the line 
graph of a tree is a block graph, but the 
reverse is not true, i.e., block graphs 
form a super-class of trees. 
Our algorithm works on a tree-like 
decomposition structure, named block 
tree, of a block graph. Let G be a block 
graph with k blocks B1, B2, ..., Bk. The 
decomposition tree T* = (V*, E*) of G is 
constructed as follows: Create k new 
nodes B1, B2, ..., Bk standing for these k 
blocks in G. Let BT = {B1, B2, ..., Bk} 
and let V* = V ∪ BT. The edge set E* of 
T* is defined as {(vi, Bj) | vi ∈ Bj in G for 
vi ∈ V(G) and k ≥ j ≥ 1}. Clearly, T* is a 
tree. For instance, given a block graph G 
shown in Fig. 2(a), the decomposition 
tree T* of G is shown in Fig. 2(b). While 
picking an arbitrary block node B of T* 
as the root, we get a rooted tree with 
root B. This rooted tree, denoted by TB =  
= (V*, E*), is called the block tree 
corresponding to block graph G. Fig. 3 
depicts a block tree of the block graph 
shown in Fig. 2(a). Given a block graph 
G, the block tree can be constructed in 
O(n+m) time by the depth first search 
method [1]. The block tree is similar to 
the well-known block-cutvetex tree of a 
? 8 ? 
in a bottom-up manner. For each block 
node B, it computes π(GB, TGB). If B is 
the root of TB, then it outputs π(GB, TGB). 
Otherwise, let v be the parent of B. If v ∉ 
T, then it computes π(GB+v, TGB) and 
π(GB+v, TGB+v); otherwise it computes 
π(GB+v, TGB+v). For each cut node v, the 
algorithm computes π(Gv, TGv), π(Gv−v, 
TGv−v), and π(Gv−v, TGv+v) if v ∉ T. By 
visiting the block tree TB bottom-up, we 
can compute π(GB, T ). Note that the 
algorithm uses a dynamic programming 
strategy. In the following, we show how 
to compute the above stated values. 
We first compute the terminal path 
cover numbers of block nodes. Let B be 
a block node in TB. Assume that for each 
vi ∈ child(B) ∩ T, π(Gvi, TGvi) and 
π(Gvi−vi, TGvi−vi) have been computed, 
and for each vi ∈ child(B) − T, π(Gvi, 
TGvi), π(Gvi−vi, TGvi), and π(Gvi, TGvi+vi) 
have been computed. Then, π(GB, TGB) 
can be obtained from the above 
computed terminal path cover numbers. 
Our idea for computing π(GB, TGB) is 
derived from the previous proposed 
results and the computation in [25]. 
By definition of block tree, child(B) 
forms a clique and for vi, vj ∈ child(B), 
Gvi−vi and Gvj−vj are disjoint. Let vi ∈ 
child(B). By Lemma 3, if vi ∈ T then 
either π(Gvi, TGvi) = π(Gvi−vi, TGvi−vi) + 1 
or π(Gvi, TGvi) = π(Gvi−vi, TGvi−vi). By 
Lemma 5, if vi ∉ T and π(Gvi, TGvi) = 
π(Gvi, TGvi+vi) then either π(Gvi, TGvi) = 
π(Gvi−vi, TGvi) + 1 or π(Gvi, TGvi) = 
π(Gvi−vi, TGvi). Note that if vi ∉ T and 
π(Gvi, TGvi) = π(Gvi, TGvi+vi), then vi is an 
end vertex of a path in a minimum 
terminal path cover of Gvi w.r.t. TGvi. 
Then, we define four subsets of child(B) 
as follows: 
It = {vi | vi ∈ child(B) ∩ T and π(Gvi, TGvi) 
= π(Gvi−vi, TGvi−vi) + 1},  
Jt = {vi | vi ∈ child(B) ∩ T and π(Gvi, TGvi) 
= π(Gvi−vi, TGvi−vi)}, 
If = {vi | vi ∈ child(B) − T and π(Gvi, TGvi) 
= π(Gvi, TGvi+vi) = π(Gvi−vi, TGvi) + 1}, 
Jf = {vi | vi ∈ child(B) − T and π(Gvi, TGvi) 
= π(Gvi, TGvi+vi) = π(Gvi−vi, TGvi)}. 
We can see that if vj ∈ child(B) − (It 
∪ Jt ∪ If ∪ Jf), then vj ∉ T and π(Gvj, 
TGvj+vj) = π(Gvj, TGvj) + 1, i.e., vj is an 
intermediate vertex of a path in a 
minimum terminal path cover of Gvj w.r.t. 
TGvj. The following lemma shows how to 
compute π(GB, TGB) and can be proved 
by similar arguments in [25]. The proof 
is showed in Appendix, Lemma 3.5. 
Lemma 7. Assume that B is a block 
node in block tree TB. Then,  





 +−−
=∪≠+−
= ∑
∑
∈
∈
. ,
2
||||
||),(π
;    ,1||),(π
),(π
)(
)(
otherwise
JI
IG
JIandIifIG
G
Bchildv
ft
fGv
ftf
Bchildv
fGv
GB
i
ivi
i
ivi
B T
T
T
φφ
 
Next, we will compute the related 
terminal path cover numbers when the 
visited node is a cut node v. If v ∈ T, 
then we compute π(Gv, TGv) and π(Gv−v, 
TGv−v); otherwise, we compute π(Gv, 
TGv), π(Gv, TGv+v), and  π(Gv−v, TGv). 
Since all GBi’s for Bi ∈ child(v) are 
pairwise disjoint, the following lemma is 
obvious. 
Lemma 8. Assume that v is a cut node 
in block tree TB. If v ∈ T, then π(Gv−v, 
? 10 ? 
∑
∈ )(vchildBi
π(GBi, TGBi); otherwise, π(Gv, 
TGv+v) = ∑∈ )(vchildBi π(GBi, TGBi) + 1.  
Based on the above lemmas, we 
design a dynamic programming linear- 
time algorithm to compute π(GB, T ) as 
follows: Initially, let π(Gv, φ) = 1, π(Gv, 
{v}) = 1, and π(Gv−v, φ) = 0 for each end 
node v ∉ T; and let π(Gv, {v}) = 1 and 
π(Gv−v, φ) = 0 for each end node v ∈ T. 
Our algorithm then traverses the nodes 
of TB in a bottom-up manner. For each 
block node B, it computes π(GB, TGB) by 
using Lemma 7. If B is the root of TB, 
then it outputs π(GB, TGB). Otherwise, let 
v be the parent of B. If v ∉ T, then it 
computes π(GB+v, TGB) and π(GB+v, 
TGB+v); otherwise it computes π(GB+v, 
TGB+v) by using Lemma 9. For each cut 
node v, the algorithm computes π(Gv, 
TGv) by using Lemmas 11−12, π(Gv−v, 
TGv−v) by using Lemma 8, and π(Gv, 
TGv+v) by using Lemma 13 if v ∉ T. 
After visiting each node of TB once, 
π(GB, T ) is calculated. 
Now, we analyze the complexity of 
our algorithm. Let B be a block node 
with c children and let v be a cut node 
with b children in TB. Computing the 
related values on block node B and cut 
node v takes O(c) and O(b) time, 
respectively. Let B1, B2, ..., Bk be the 
block nodes in TB and let δ(Bi) denote 
the number of children of Bi for k ≥ i ≥ 1. 
Then, ∑
≥≥ 1
)(δ
ik
iB  = |V(GB)|. Thus, 
processing all block nodes requires 
O(|V(GB)|) time. Since the number of 
block nodes in TB is bounded in 
O(|V(GB)|) and processing all cut nodes 
takes O(k) time, processing all cut nodes 
requires O(|V(GB)|) time. It follows 
immediately from the above arguments 
that π(GB, T ) can be computed in 
O(|V(GB)|) time. 
Though we only describe the 
algorithm to compute π(GB, T ) for a 
block graph GB with terminal set T, it 
can be easily extended to find a 
minimum terminal path cover of GB in 
the same time bound. Hence, we 
conclude the following theorem. 
Theorem 14. The terminal path cover 
problem on a block graph G can be 
solved in O(n+m)-linear time. Moreover, 
if its block tree is given, then the 
terminal path cover number of G can be 
computed in O(n) time.  
????????? 
In this project, we first introduce a 
reduction from the terminal path cover 
problem to the path cover problem. This 
reduction can be applied to the graph 
classes closed under the pendant-vertex 
operation. By the reduction, the 
complexity of the terminal path cover 
problem is the same as that of the path 
cover problem for the stated graph 
classes. Although the proposed reduction 
can be applied to block graphs, we use a 
different method to directly solve the 
terminal path cover problem by not 
using the stated reduction. Our 
algorithm works on a tree-like 
decomposition structure, called block 
? 12 ? 
?????? 
[1] A.V. Aho, J.E. Hopcroft and J.D. Ullman, The Design and Analysis of Computer 
Algorithms, Reading, MA, 1974. 
[2] S.R. Arikati and C.P. Rangan, Linear algorithm for optimal path cover problem 
on interval graphs, Inform. Process. Lett. 35 (1990) 149−153. 
[3] K. Asdre and S. Nikolopoulos, A linear-time algorithm for the k-fiexed-endpoints 
path cover problem on cographs, Networks 50 (2007) 231−240. 
[4] A.A. Bertossi and M.A. Bonuccelli, Hamiltonian circuits in interval graph 
generalizations, Inform. Process. Lett. 23 (1986) 195−200. 
[5] F.T. Boesch and J.F. Gimpel, Covering the points a digraph with point-disjoint 
paths and its application to code optimization, J. ACM 24 (1977) 192−198, . 
[6] M.S. Chang, S.L. Peng and J.L. Liaw, Deferred-query: an efficient approach for 
some problems on interval graphs, Networks 34 (1999) 1−10. 
[7] G.J. Chang, Corrigendum to: The path-partition problem in block graphs, Inform. 
Process. Lett. 83 (2002) 293. 
[8] P. Damaschke, J.S. Deogun, D. Kratsch and G. Steiner, Finding Hamiltonian 
paths in cocomparability graphs using the bump number algorithm, Order 8 
(1992) 383−391. 
[9] M.R. Garey and D.S. Johnson, Computers and Intractability: A Guide to the 
Theory of NP-Completeness, Freeman, San Francisco, CA, 1979. 
[10] M.R. Garey, D.S. Johnson and L. Stockmeyer, Some simplified NP-complete 
graph problems, Theoret. Comput. Sci. 1 (1976) 237−267. 
[11] S. Goodman and S. Hedetniemi, On the Hamiltonian completion problem, Proc. 
1973 Capital Conf. on Graph Theory and Combinatorics, Lecture Notes in Math. 
406, Springer, Berlin, 1974, pp. 262−272. 
[12] R.W. Hung and M.S. Chang, Finding a minimum path cover of a 
distance-hereditary graph in polynomial time, Discrete Appl. Math. 155 (2007) 
2242−2256. 
[13] R.W. Hung and M.S. Chang, Solving the path cover problem on circular-arc 
graphs by using an approximation algorithm, Discrete Appl. Math. 154 (2006) 
76−105. 
[14] R.W. Hung, A linear-time algorithm for the terminal path cover problem in 
cographs, in: Proceddings of the 23rd Workshop on Combinatorial Mathematics 
and Computation Theory, Changhwa, Taiwan, 2006, pp. 62−75. 
(http://algo2006.csie.dyu.edu.tw/paper/1/B14.pdf) 
[15] L.T. Quoc Hung, M.M. Sysło, M.L. Weaver and D.B. West, Bandwidth and 
? 14 ? 
???????? 
?????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????? 
?????????????????????????????????
???????????????????????????????????
??????????????????????? 
1. ?????????????????????????????????
?????? 
2. ????????????????????????????????
?? 
3. ???????????????????????????????? 
4. ?????????????????????????????????
??????????????? 
 
The Terminal Path Cover Problem in Graphs∗†
Ruo-Wei Hung
Department of Computer Science and Information Engineering,
Chaoyang University of Technology,
Wufong, Taichung 41349, Taiwan
E-mail: rwhung@cyut.edu.tw
August 20, 2008
Abstract
In this paper, we study a generalization of the path cover problem, namely, the
terminal path cover problem. Given a graph G and a subset T of vertices of G, a
terminal path cover of G with respect to T is a set of pairwise vertex-disjoint paths
PC that covers all vertices of G such that the vertices of T are all end vertices of
paths in PC. The terminal path cover problem is to ﬁnd a terminal path cover of G
of minimum cardinality; note that, if T is empty, the stated problem coincides with
the classical path cover problem. In this paper, we ﬁrst show that for some graph
classes, the terminal path cover problem can be reduced to the path cover problem in
linear time. The class of block graphs is one of the stated graph classes and, hence,
the terminal path cover problem in it can be reduced to the path cover problem. On
the other hand, we give a tree-like decomposition structure to represent a block graph.
To show the eﬃciency of proposed tree-like structure, we use it to design a dynamic
programming linear-time algorithm for directly solving the terminal path cover prob-
lem in block graphs by not using the stated reduction.
Keywords: graph algorithms; path cover; terminal path cover; pendant-vertex oper-
ation; block graphs; linear-time algorithms.
1 Introduction
1.1 Framework– Motivation
All graphs considered in this paper are ﬁnite and undirected, without loops or multiple
edges. Let G = (V,E) be a graph without isolated vertices. Throughout this paper,
let m and n denote the numbers of edges and vertices of a graph, respectively. A well
studied problem with numerous practical applications in graph theory is to ﬁnd a minimum
∗This research was partly supported by the National Science Council of Taiwan (R.O.C.) under grant
no. NSC96-2221-E-324-024.
†A preliminary version of this paper has appeared in the International MultiConference of Engineers
and Computer Scientists 2008 (IMECS’2008), Hong Kong, Vol. I, 2008, pp. 286–292.
1
NP-Complete
Perfect
Weakly Chordal ParityComparabilityCocomparability
Split
Undirected
Path
Strongly
Chordal
Directed
Path
Bipartite
Interval
Circular-
Arc
Block
Distance-
Hereditary
Bipartite DH Ptolemaic
Cograph
Permutation
Trapezoid
Chordal
Bipartite
Bipartite
Permutation
Threshold
Tree
Chordal
Circle
Polynomial
Fig. 1: The complexity status (NP-complete, Polynomial) of the path cover problem for
some graph subclasses of perfect graphs, where A → B indicates class A contains class B.
1.2 Contribution
A vertex of a graph is called a pendant vertex if its degree is one. Let G = (V,E) be
a graph and let S ⊆ V . We construct a new graph PV (G,S) from G as follows: for
every vertex v in S create a new vertex v′, and connect v to v′ with an edge. Then,
every vertex of PV (G,S) not in V is a pendant vertex. A graph class C is said to be
closed under the pendant-vertex operation if for every graph G in C, PV (G,S) is also
in C. For example, the classes of planar graphs, trees, block graphs, Ptolemaic graphs,
distance-hereditary graphs, chordal graphs, bipartite graphs, and many more are closed
under the pendant-vertex operation. In this paper, we ﬁrst point out that for all graph
classes closed under the pendant-vertex operation, the computational complexity of the
terminal path cover problem is the same as that of the path cover problem. On the other
hand, we give a tree-like structure to decompose a block graph in which every block is a
3
G such that u|P1| and v1 are adjacent, let P1 → P2 denote the path u1 → u2 → · · · →
u|P1| → v1 → v2 → · · · → v|P2| that is said to be the concatenation of P1 and P2.
Now, we introduce a reduction from the terminal path cover problem to the path cover
problem. Let G = (V,E) be a graph and let T be a terminal set of G. We construct a
new graph PV (G, T ) from G as follows: for every vertex t in T , we add a new vertex t′
to G and connect t to t′ with a new edge. It is easy to see that PV (G, T ) can be obtained
from G in O(|T |) time. Then we prove π(G, T ) = π(PV (G, T ), ∅).
First, we prove that π(G, T ) ≥ π(PV (G, T ), ∅). Let PCT be a minimum terminal path
cover of G w.r.t. T and let P be a path in PCT such that its end vertex is a terminal t.
Let t′ be a pendant vertex of PV (G, T ) such that t′ is adjacent to t but is not in G. By
extending P to visit t′, i.e. P = P → t′, it is still a path in PV (G, T ). Repeat the above
process until every pendant vertex of PV (G, T ) not in G is covered by one path in PCT .
Then, we obtain a path cover of PV (G, T ) of size |PCT |. Thus, π(G, T ) ≥ π(PV (G, T ), ∅).
Next, we prove π(G, T ) ≤ π(PV (G, T ), ∅). Consider a minimum path cover PC of
PV (G, T ). Let t be a terminal in G, t′ be the pendant vertex in PV (G, T ) such that
t′ ∈ G and t′ is adjacent to t in PV (G, T ), let P ′ be a path in PC covering t′, and let
P be a path in PC covering t. Note that if |P ′| = 1, then P = P ′; otherwise, P = P ′.
We then do the following. If |P ′| > 1, then we just remove t′ from the path (since t′
has degree 1, t′ must be an end vertex of P ′). If |P ′| = 1 (i.e. P ′ visits t′ only), then
we remove P ′ from PC and split P into two pieces so that t is an end vertex of one of
them. Note that if |P ′| = 1 and t is an end vertex of P , then PC − {P, P ′} ∪ {P → P ′}
forms a path cover of PV (G, T ) of size less than |PC| and it contradicts that PC is a
minimum path cover of PV (G, T ). Each of these above operations does not increase the
number of paths in PC. Repeat the above process until all pendant vertices of PV (G, T )
not in G are removed. Then, we obtain a terminal path cover of G w.r.t. T of size at
most |PC|. Thus, π(G, T ) ≤ π(PV (G, T ), ∅). It follows from the above arguments that
π(G, T ) = π(PV (G, T ), ∅).
A graph class C is said to be closed under the pendant-vertex operation if for every
graph G in C with terminal set T , PV (G, T ) is also in C. By the above reduction, it is
easy to see that in this case the terminal path cover problem on G w.r.t. T can be reduced
to the path cover problem on PV (G, T ) in O(|T |) time. Thus, if the path cover problem
on PV (G, T ) is solved in O(T (n)) time, then the terminal path cover problem on G w.r.t.
T is solved in O(T (n)) time, too. Thus, we conclude the following theorem.
Theorem 2.1. Let C be a graph class closed under the pendant-vertex operation. If the
5
decrease the number of paths by at most one, the following lemma and corollary can be
easily veriﬁed.
Lemma 3.1. Assume G is a graph with terminal set T and v ∈ T . Then, π(G− v, T −
v) + 1 ≥ π(G, T ) ≥ π(G− v, T − v).
Corollary 3.2. Assume G is a graph with terminal set T and v ∈ T . Then, π(G, T ) >
π(G− v, T − v) if and only if π(G, T ) = π(G− v, T − v) + 1.
For a graph G with terminal set T and a free vertex v of G, we prove the following
lemma.
Lemma 3.3. Assume G is a graph with terminal set T and v ∈ V (G) − T . Then, the
following statements hold:
(1) π(G− v, T ) + 1 ≥ π(G, T + v);
(2) π(G, T + v) ≥ π(G, T );
(3) π(G− v, T ) + 1 ≥ π(G, T + v) ≥ π(G− v, T ).
Proof . Since a minimum terminal path cover of G − v w.r.t. T together with the path
v forms a terminal path cover of G w.r.t. T + v, π(G− v, T ) + 1 ≥ π(G, T + v). Since a
minimum terminal path cover of G w.r.t. T + v is a terminal path cover of G w.r.t. T ,
π(G, T + v) ≥ π(G, T ). On the other hand, suppose that PC is a minimum terminal path
cover of G w.r.t. T + v. Consider removing vertex v from PC. What results is a terminal
path cover P˜C of G − v w.r.t. T . Since the deletion of a terminal in PC will decrease
the number of paths by at most one and v is an end vertex of a path in PC, we get that
|P˜C| = |PC| or |P˜C| = |PC| − 1. Since P˜C is a terminal path cover of G − v w.r.t. T ,
|P˜C| ≥ π(G − v, T ). Thus, |PC| = π(G, T + v) ≥ |P˜C| ≥ π(G − v, T ). Combining with
Statement (1), we obtain that π(G− v, T ) + 1 ≥ π(G, T + v) ≥ π(G− v, T ). Q.E.D.
The following corollary can be easily veriﬁed from the above lemma.
Corollary 3.4. Assume G is a graph with terminal set T and v ∈ V (G) − T . Then,
π(G, T ) > π(G− v, T ) if and only if π(G, T ) = π(G, T + v) = π(G− v, T ) + 1.
3.2 The Block Tree
In this subsection, we will review block graphs and introduce a tree-like decomposition of
a block graph. Let G be a connected graph. A vertex v in G is called a cut vertex if the
removal of v from G increases the number of connected components. A block is a maximal
7
v1
v2
v5
v3
v6 v4
v9
v7
v8
v12
v11
v10
(a) (b)
B1
B2
B3
B4
B5 B6
B7
v1
v2
v3
v4
v5v6
v7 v8
v9 v10
v11
v12
B1
B2
B3
B4 B5 B6
B7
Fig. 2: (a) A block graph, and (b) a decomposition tree T ∗ for (a), where a square
represents a block and a ﬁlled circle indicates a cut vertex.
B1
v2
v3 v4
v5
B3 B4 B5
v1
v6 v12
v7 v9
v8
B6
v10 v11
B7
B
B2
Fig. 3: A block tree TB with root B = B1 for Fig. 2(b).
9
Lemma 3.5. Assume that B is a block node in block tree TB. Then,
π(GB, TGB ) =


∑
vi∈child(B)
π(Gvi , TGvi )− |If |+ 1 , if If = ∅ and It ∪ Jf = ∅;∑
vi∈child(B)
π(Gvi , TGvi )− |If | − 
|It|+|Jf |
2  , otherwise.
Proof . For each vi ∈ child(B), let PCvi be a minimum terminal path cover of Gvi w.r.t.
TGvi . For vi ∈ It (resp. vi ∈ Jt, vi ∈ If , vi ∈ Jf ), we may assume that vi (resp.
vi → pi, vi, vi → pi) is a path in PCvi , where pi = ∅. For the case that If = ∅ and
It ∪ Jf = ∅, let PC =
⋃
vi∈child(B)
PCvi −
⋃
vi∈If
{vi} ∪ {p}, where p is a path covering all
vertices of If . Then, PC is a terminal path cover of GB w.r.t. TGB . Hence, π(GB, TGB ) ≤∑
vi∈child(B)
π(Gvi , TGvi )− |If |+ 1. For the other cases, let P =
⋃
vi∈It
{vi}
⋃
vi∈Jf
{vi → pi} and
let PC = ⋃
vi∈child(B)
PCvi −
⋃
vi∈If
{vi} − P ∪ {p1, p2, · · · , p |It|+|Jf |
2
}, where each pj except
p1 is the concatenation of two paths in P and p1 is formed by the remaining one or two
paths in P together with all vi’s for vi ∈ If . Then, PC is a terminal path cover of GB
w.r.t. TGB . Hence, π(GB, TGB ) ≤
∑
vi∈child(B)
π(Gvi , TGvi )− |If | − 
|It|+|Jf |
2 .
On the other hand, suppose that PC is a minimum terminal path cover of GB w.r.t.
TGB . A path in PC is called mixed if it contains vertices in at least two diﬀerent Gvi ’s
for vi ∈ child(B). We may assume that PC is chosen such that the number of vertices in
mixed paths is minimal. Any mixed path r is of the form r1 → r′ → r2 such that r′ is
either empty or a sequence of some vi’s for vi ∈ child(B), and both r1 and r2 are either
empty or the form vi → pi, where vi ∈ child(B), V (pi) ⊆ V (Gvi), and pi = ∅. It follows
that the deletion of any vertex x in r′ from r is still a path, which we denote by r−x. Let
I ′ = {vi ∈ child(B)|vi ∈ TGvi and vi is the only vertex of Gvi appeared in one mixed path
r}, and
J ′ = {vj ∈ child(B)|Gvj contains a nonempty r1 or r2 of a mixed path r}.
It is not diﬃcult to see that I ′∩J ′ = ∅. We ﬁrst prove claim (1) that I ′ ⊆ If . Suppose
that vi ∈ I ′−If . Then, vi is in a mixed path r such that V (r)∩V (Gvi) = {vi}. By deﬁnition
of I ′, vi ∈ TGvi . Consider the terminal path cover PC′ = PC−PC‖Gvi−vi−{r}∪PCvi∪{r−
vi} of GB. Then, we get that |PC′| = |PC|−|PC‖Gvi−vi |+|PCvi | ≤ |PC|−π(Gvi−vi, TGvi )+
π(Gvi , TGvi ) ≤ |PC| since vi ∈ If and vi ∈ TGvi implies π(Gvi , TGvi ) ≤ π(Gvi − vi, TGvi )
by Corollary 3.4. Consequently, PC′ is another minimum terminal path cover of GB with
fewer vertices in all mixed paths than PC, a contradiction. Hence, I ′ ⊆ If .
Next, we prove claim (2) that J ′ ⊆ If ∪ It ∪ Jf . Suppose that vj ∈ J ′ − (If ∪ It ∪ Jf ).
Without loss of generality, assume that Gvj contains a nonempty r1 for some mixed path
rj = r1 → r′j → r2. Consider that r1 contains vj ∈ TGvj only. Let PC′ = PC − {rj} −
11
Lemma 3.6. Assume that υ is a cut node in block tree TB. If υ ∈ T , then π(Gυ−υ, TGυ −
υ) =
∑
Bi∈child(υ)
π(GBi , TGBi ); otherwise, π(Gυ − υ, TGυ) =
∑
Bi∈child(υ)
π(GBi , TGBi ).
Let B be a child block node of cut node υ in TB. Let GB +υ be the graph with vertex
set V (GB)∪ {υ} and edge set E(GB)∪ {(υ, vi)|vi ∈ child(B)}. For the graph GB + υ, we
can construct its block tree T υB from TB by setting υ to become a child of B such that T
υ
B
is rooted at B and υ has no child in T υB. It is easy to see that for block node B in T
υ
B,
If = ∅ if υ ∈ T ; and It = ∅ otherwise. Then, the following lemma can be easily veriﬁed
from Lemma 3.5.
Lemma 3.7. Assume υ is a cut node and B is a block node in child(υ). Then, π(GB +
υ, TGB + υ) =
∑
vi∈child(B)
π(Gvi , TGvi )− |If | − 
|It|+|Jf |
2 + 1, and if υ ∈ T then
π(GB + υ, TGB ) =


∑
vi∈child(B)
π(Gvi , TGvi )− |If |+ 1 , if It ∪ Jf = ∅;∑
vi∈child(B)
π(Gvi , TGvi )− |If | − 
|It|+|Jf |
2  , otherwise.
We next establish the following lemma to be used in proving Lemma 3.10.
Lemma 3.8. Assume that υ ∈ T is a cut node with child block node B in TB. If π(GB +
υ, TGB ) = π(GB, TGB ) and π(GB + υ, TGB ) = π(GB + υ, TGB + υ), then there exists no
minimum terminal path cover of GB + υ w.r.t. TGB such that it contains a path with end
vertex υ.
Proof . Since π(GB + υ, TGB ) = π(GB + υ, TGB + υ), by Statement (2) of Lemma 3.3
we have that π(GB + υ, TGB + υ) > π(GB + υ, TGB ). Since π(GB, TGB ) = π(GB +
υ, TGB ), we get that π(GB + υ, TGB + υ) > π(GB + υ, TGB ) = π(GB, TGB ), and, hence,
π(GB + υ, TGB + υ) = π(GB, TGB ). By Statement (3) of Lemma 3.3, π(GB, TGB ) + 1 ≥
π(GB + υ, TGB + υ) ≥ π(GB, TGB ). Since π(GB + υ, TGB + υ) = π(GB, TGB ), we get
π(GB + υ, TGB + υ) = π(GB, TGB ) + 1 = π(GB + υ, TGB ) + 1. If there exists a minimum
terminal path cover of GB + υ w.r.t. TGB such that it contains a path with end vertex υ,
then π(GB + υ, TGB ) = π(GB + υ, TGB + υ), a contradiction. Thus, υ can not be an end
vertex of a path in a minimum terminal path cover of GB + υ w.r.t. TGB . Q.E.D.
Let υ be a cut node and let B be a child of υ in TB. We observe that (1) if υ is a
terminal then it must be an end vertex of a path in a minimum terminal path cover of Gυ
w.r.t. TGυ , and (2) if υ is a free vertex and π(GB + υ, TGB ) = π(GB + υ, TGB + υ) then υ
is an end vertex of a path in a minimum terminal path cover of GB + υ w.r.t. TGB . Using
Lemma 3.7, we prove the following two lemmas.
13
υ, TGBi ) = π(GBi , TGBi )}|. Then,
π(Gυ, TGυ) =


∑
Bi∈child(υ)
π(GBi , TGBi )− 1 , if τ ≥ 2;∑
Bi∈child(υ)
π(GBi , TGBi ) , if τ ≤ 1 and η ≥ 1;∑
Bi∈child(υ)
π(GBi , TGBi ) + 1 , otherwise.
Proof . For Bi ∈ child(υ), let PCi be a minimum terminal path cover of GBi w.r.t.
TGBi . Consider the case of τ ≥ 2. Then, there exist two distinct Bα and Bβ such that
π(GBα+υ, TGBα ) = π(GBα+υ, TGBα+υ) = π(GBα , TGBα ) and π(GBβ+υ, TGBβ ) = π(GBβ+
υ, TGBβ + υ) = π(GBβ , TGBβ ). Let PCυα and PCυβ be minimum terminal path covers of
GBα+υ and GBβ +υ, respectively. Then, PCυα and PCυβ contain paths υ → pα and υ → pβ ,
respectively, where pα = ∅ and pβ = ∅. Let PC∗ =
⋃
Bi∈child(υ);Bi =Bα,Bβ
PCBi∪(PCυα−{υ →
pα}) ∪ (PCυβ − {υ → pβ}) ∪ {pα → υ → pβ}. Then, PC∗ is a terminal path cover of Gυ of
size
∑
Bi∈child(υ)
π(GBi , TGBi )−1 w.r.t. TGυ . Thus, π(Gυ, TGυ) ≤
∑
Bi∈child(υ)
π(GBi , TGBi )−1.
By the same arguments, we can prove that π(Gυ, TGυ) ≤
∑
Bi∈child(υ)
π(GBi , TGBi ) if τ ≤ 1
and η ≥ 1, and that π(Gυ, TGυ) ≤
∑
Bi∈child(υ)
π(GBi , TGBi ) + 1 if η = 0.
Now, suppose that PC is a minimum terminal path cover of Gυ w.r.t. TGυ . Let p′ →
υ → p′′ be a path in PC. Since GBi ’s for Bi ∈ child(υ) are pairwise disjoint, all vertices of
p′ or p′′ are in the same GBi . Let GBµ and GBω contain V (p′) and V (p′′), respectively, and
let P˜Cµ and P˜Cω be the restrictions of PC to GBµ −V (p′) and GBω −V (p′′), respectively.
Note that P˜Cµ = PCµ if p′ = ∅ and P˜Cω = PCω if p′′ = ∅. Then, P˜Cµ ∪ {p′ → υ} and
P˜Cω ∪ {υ → p′′} are terminal path covers of GBµ + υ and GBω + υ, respectively. Let PCυµ
and PCυω be the minimum terminal path covers of GBµ + υ and GBω + υ, respectively.
By Lemmas 3.5 and 3.7, π(GBi , TGBi ) + 1 ≥ π(GBi + υ, TGBi ) ≥ π(GBi , TGBi ) for each
Bi ∈ child(υ). Three cases arise.
Case 1 : τ ≥ 2. Consider removing vertex υ from PC. What results is a set P˜C of vertex-
disjoint paths which is clearly a terminal path cover of Gυ − υ w.r.t. TGυ . Since the
removal of a free vertex from PC increases the number of paths by at most one, we get
that |P˜C| ≤ |PC| + 1. Since all GBi ’s for Bi ∈ child(υ) are pairwise disjoint and P˜C is a
terminal path cover of Gυ − υ, |P˜C| ≥
∑
Bi∈child(υ)
π(GBi , TGBi ). Thus, |PC| ≥ |P˜C| − 1 ≥∑
Bi∈child(υ)
π(GBi , TGBi )− 1.
Case 2 : τ ≤ 1 and η ≥ 1. Suppose that p′ = p′′ = ∅. Let P˜C = PC − {υ}. Then, P˜C is a
terminal path cover of Gυ−υ w.r.t. TGυ . Thus,
∑
Bi∈child(υ)
π(GBi , TGBi ) ≤ |P˜C| = |PC|−1.
15
cover of Gυ of size
∑
Bi∈child(υ)
π(GBi , TGBi )+ 1. Thus,
∑
Bi∈child(υ)
π(GBi , TGBi )+1 = |P˜C| =
|PC| − 1− |P˜Cµ|+ |PCµ|+ 1 ≤ |PC|. Q.E.D.
It is easy to see that if υ ∈ T is a cut node in TB, then π(Gυ, TGυ +υ) can be computed
by setting υ to become a terminal and, hence, the following lemma can be easily veriﬁed
from Lemma 3.9.
Lemma 3.11. Assume that υ ∈ T is a cut node in TB. If there exists a block node
Bλ in child(υ) such that π(GBλ + υ, TGBλ + υ) = π(GBλ , TGBλ ), then π(Gυ, TGυ + υ) =∑
Bi∈child(υ)
π(GBi , TGBi ); otherwise, π(Gυ, TGυ + υ) =
∑
Bi∈child(υ)
π(GBi , TGBi ) + 1.
3.5 The Algorithm
Based on Lemma 3.5, Lemmas 3.6–3.7 and Lemmas 3.9–3.11, given a block tree TB together
with terminal set T we design a dynamic programming linear-time algorithm to compute
π(GB, T ) as follows: Initially, let π(Gv, ∅) = 1, π(Gv, {v}) = 1, and π(Gv − v, ∅) = 0 for
each end node v ∈ T ; and let π(Gv, {v}) = 1 and π(Gv − v, ∅) = 0 for each end node
v ∈ T . Our algorithm then traverses the nodes of TB in a bottom-up manner. For each
block node B, it computes π(GB, TGB ) by using Lemma 3.5. If B is the root of TB, then
it outputs π(GB, TGB ). Otherwise, let υ be the parent of B. If υ ∈ T , then it computes
π(GB +υ, TGB ) and π(GB +υ, TGB +υ); otherwise it computes π(GB +υ, TB +υ) by using
Lemma 3.7. For each cut node υ, the algorithm computes π(Gυ, TGυ) by using Lemmas
3.9–3.10, π(Gυ − υ, TGυ − υ) by using Lemma 3.6, and π(Gυ, TGυ + υ) by using Lemma
3.11 if υ ∈ T . After visiting each node of TB once, π(GB, T ) is calculated.
Now, we analyze the complexity of our algorithm. Let B be a block node with c
children and let υ be a cut node with b children in TB. Computing the related values on
block node B and cut node υ takes O(c) and O(b) time, respectively. Let B1, B2, · · · , Bk
be the block nodes in TB and let δ(Bi) denote the number of children of Bi for k ≥ i ≥ 1.
Then,
k∑
i=1
δ(Bi) = |V (GB)|. Thus, processing all block nodes requires O(|V (GB)|) time.
Since the number of block nodes in TB is bounded in O(|V (GB)|) and processing all cut
nodes takes O(k) time, processing all cut nodes requires O(|V (GB)|) time. It follows
immediately from the above arguments that π(GB, T ) can be computed in O(|V (GB)|)
time.
Though we only describe the algorithm to compute π(GB, T ) for a block graph GB
with terminal set T , it can be easily extended to ﬁnd a minimum terminal path cover of
GB in the same time bound. Hence, we conclude the following theorem.
17
[7] G.J. Chang, Corrigendum to: The path-partition problem in block graphs, Inform.
Process. Lett. 83 (2002) 293.
[8] P. Damaschke, J.S. Deogun, D. Kratsch and G. Steiner, Finding Hamiltonian paths in
cocomparability graphs using the bump number algorithm, Order 8 (1992) 383–391.
[9] M.R. Garey and D.S. Johnson, Computers and Intractability: A Guide to the Theory
of NP-Completeness, Freeman, San Francisco, CA, 1979.
[10] M.R. Garey, D.S. Johnson and L. Stockmeyer, Some simpliﬁed NP-complete graph
problems, Theoret. Comput. Sci. 1 (1976) 237–267.
[11] S. Goodman and S. Hedetniemi, On the Hamiltonian completion problem, Proc. 1973
Capital Conf. on Graph Theory and Combinatorics, Lecture Notes in Math. 406,
Springer, Berlin, 1974, pp. 262–272.
[12] R.W. Hung and M.S. Chang, Finding a minimum path cover of a distance-hereditary
graph in polynomial time, Discrete Appl. Math. 155 (2007) 2242–2256.
[13] R.W. Hung and M.S. Chang, Solving the path cover problem on circular-arc graphs
by using an approximation algorithm, Discrete Appl. Math. 154 (2006) 76–105.
[14] R.W. Hung, A linear-time algorithm for the terminal path cover prob-
lem in cographs, in: Proceddings of the 23rd Workshop on Combinatorial
Mathematics and Computation Theory, Changhwa, Taiwan, 2006, pp. 62–75.
(http://algo2006.csie.dyu.edu.tw/paper/1/B14.pdf)
[15] L.T. Quoc Hung, M.M. Syslo, M.L. Weaver and D.B. West, Bandwidth and density
for block graphs, Discrete Math. 189 (1998) 163–176.
[16] M.S. Krishnamoorthy, An NP-hard problem in bipartite graphs, SIGACT News 7
(1976) 26.
[17] S. Moran and Y. Wolfstahl, Optimal covering of cacti by vertex disjoint paths, The-
oret. Comput. Sci. 84 (1991) 179–197.
[18] H. Mu¨ller, Hamiltonian circuits in chordal bipartite graphs, Discrete Math. 156 (1996)
291–298.
[19] G. Narasimhan, A note on the Hamiltonian circuit problem on directed path graphs,
Inform. Process. Lett. 32 (1989) 167–170.
19
−1− 
???????????? 
                                                             
???? NSC96-2221-E-324-024 
???? ??????????????? 
?????? 
??????? 
??? 
??????????? ??? 
?????? 
?? 
19-21 March, 2008 
???? International MultiConference of Engineers and Computer Scientists 2008 
?????? A Linear-Time Algorithm for the Terminal Path Cover Problem in Block Graphs
 
???????? 
IMECS(International MultiConference of Engineers and Computer Scientists) 2008?? 
International Association of Engineers (IAENG)??????????????????
????????????????????????????????IMECS???
??? 30???? 250????????????????????????????
??????????????????????? 
IAENG(International Association of Engineers)?????????????????
????????????????? 30????????????????????
??????????????????????????????????????
??????????????????????????????????????
????????????????????????????? 
IMECS 2008 ????????????????????????Artificial 
Intelligence and Applications?Bioinformatics?Control and Automation?Computer Science?
Communication Systems and Applications?Data Mining and Applications?Electrical 
Engineering?Imaging Engineering?Industrial Engineering?Internet Computing and Web?
Operations Research?Scientific Computing?Software Engineering? 
??????????????(Regal-Kowloon Hotel)????? 3?(3? 19?~3
? 21 ?)??????? Computer Science???????????????????
??????????????? Keynote Speech ? Invited Talk??????? Prof. 
Craig Dougles?Prof. Ping-kong Alexander Wai?Dr. Ezendu Ariwa??????????
???????????????? Computer Science??? session????????
??????? 1028? papers?Program Committee??? 576?????? 56.03%?
???????????????????????????????????????
??????????????????????????????????????
?????????????? 
??????????A Linear-Time Algorithm for the Terminal Path Cover Problem 
