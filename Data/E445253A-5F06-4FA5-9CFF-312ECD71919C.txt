Investigating the FIFO Design Styles Based on the 
Balsa Synthesis System 
 
Ren-Der Chen               Che-An Lee                Pei-Hua Hsieh 
Department of Computer Science and Information Engineering 
National Changhua University of Education 
Changhua, Taiwan, R.O.C. 
E-mail: rdchen@cc.ncue.edu.tw 
 
 
Abstract—In this paper, three asynchronous FIFO design styles, 
linear, square, and cubic, are investigated based on the Balsa 
synthesis system. These styles are designed with the key 
difference being the path by which data travels through the 
FIFO. The design with shorter path should result in lower 
latency and higher throughput, but will require more 
complicated control. All the FIFOs are designed using the Balsa 
language, and the area cost and simulation time are compared 
for each FIFO with varying sizes. A tool is also presented for 
automatic generation of Balsa code for each FIFO. 
Keywords-Balsa, asynchronous, and FIFO. 
I.  INTRODUCTION 
Asynchronous circuits use a local handshaking protocol to 
control the transfer of data between components. To facilitate 
the design of large-scale asynchronous circuits, high-level 
synthesis tools are required [7, 9]. Balsa, an open-source 
system developed at the University of Manchester [1], is the 
name for both the synthesis system for designing asynchronous 
circuits and the language used to describe the circuit behavior 
[2, 4]. Its compilation process, called syntax-directed 
translation, performs a one-to-one mapping of each language 
construct into a network of handshake components [10] that 
implement it. The SPA processor [8] is a successful design 
example using Balsa.   
The FIFO is an implementation of a first-in-first-out data 
structure. Traditionally, the linear FIFO is implemented as a 
linear array of cells. The work on reducing forward latency in 
an asynchronous linear FIFO can be found in [6]. The square 
FIFO [3, 5] is a low-latency, high-throughput implementation 
consisting of a two-dimensional array of cells. Similarly, the 
cubic FIFO is a three-dimensional array of cells, featuring 
even lower latency and higher throughput. In the design of 
square or cubic FIFO, the data items are distributed over the 
FIFO cells and must be collected in such a way that the first-
in-first-out behavior is satisfied. In this paper, the Balsa 
synthesis system is used as the framework for designing the 
three styles of FIFOs, and an automatic tool is also presented 
to generate the Balsa code for each FIFO with varying sizes. 
This paper is organized as follows. Section II gives an 
overview of the Balsa synthesis system. Section III explains 
the design of a cubic FIFO. Section IV includes the 
experimental results and discussions, and finally Section V 
concludes the paper. 
II. BALSA SYNTHESIS SYSTEM 
The syntax-directed synthesis of asynchronous circuits is 
based on the compilation of a high-level description into a 
communicating network of predesigned modules. Each 
language construct is mapped one-to-one into a corresponding 
network of components that implement it. The structure of the 
resulting circuit is hence directly related to the description 
style, giving designers a high degree of flexibility to optimize 
circuits at the description language level. The Balsa synthesis 
system uses the syntax-directed translation to generate a 
handshake circuit [10] from a description written in the Balsa 
language. A handshake circuit is a communicating network of 
handshake components connected point-to-point using 
handshake channels. Channels carry data from one component 
to another under the control of a request-acknowledge 
handshake protocol. Each handshake component has a 
parameterized gate-level implementation, and a gate-level 
netlist can be directly generated for a handshake circuit by 
applying the appropriate parameters, e.g., data width, to each 
component instance. A large-scale handshake circuit can then 
be constructed by the composition of small handshake 
components that are implemented in isolation. 
Fig. 1 illustrates the Balsa description for a simple one-
place buffer. The buffer has an input channel in1 and an output 
channel out1. The variable buf stores the input data and the 
operation consists of an infinite repetition (loop..end) of two 
actions: input data from channel in1 into buf (in1 -> buf), 
sequenced (;) with the second action, output the data in buf to 
channel out1 (out1 <- buf). The handshake circuit generated by 
Balsa for the description is shown in Fig. 2, where the loop 
statement in Fig. 1 is implemented by the handshake 
component labeled with “*”.  
This work was supported by the National Science Council of Taiwan, 
R.O.C. under the project NSC 99-2221-E-018-027. 
import [balsa.types.basic] 
type DataType is 8 bits 
procedure buffer 
( 
 input   in1 : DataType; 
 output  out1 : DataType 
) is 
 variable buf : DataType 
begin 
 loop 
  in1->buf 
  ; 
  out1<-buf 
 end 
end 
Figure 1. Balsa description for a one-place buffer. 
cells. These cells are classified as Case 5. The first cell of the 
FIFO belongs to this case, and since it has no left-column cell, 
it gets data from a virtual input cell in the outside environment. 
Fig. 4 illustrates the classification of cells for the cubic FIFO 
in Fig. 3. 
C. Event sequence 
Since a cell in a cubic FIFO may get data from several 
source cells, some events about data movement need to be 
defined. For a cell c(i,j,k), the event α is defined as getting 
data from its up-layer cell c(i,j,k+1) and setting c(i,j,k+1) 
empty, the event β is defined as getting data from its up-row 
cell c(i-1,j,k) and setting c(i-1,j,k) empty, and the event γ is 
defined as getting data from its left-column cell c(i,j-1,k) and 
setting c(i,j-1,k) empty. Since a cell does not always contain 
data, each of these three events is activated only when its 
corresponding source cell contains data; otherwise, the event 
is still waiting for activation. The event sequence of a cell 
c(i,j,k), denoted as seq(i,j,k), is defined as a finite ordered list 
of events to be activated on c(i,j,k). The activation of an event 
sequence seq(i,j,k) starts from the first event in seq(i,j,k). 
When an event is activated, the event following it will be the 
next event waiting to be activated, and when the last event is 
activated, the next event for activation will be restarted from 
the first event in seq(i,j,k). The operation of a cubic FIFO can 
then be modeled as repeatedly checking the empties of each 
cell c(i,j,k) in the FIFO and then activating a new event in seq(i,j,k) if c(i,j,k) is empty. 
In our method, to preserve the order of data items entering 
the FIFO, each cell c(i,j,k) is associated with an appropriate 
event sequence. Table I shows the event sequence for each 
case of cells.  In Case 1, each cell gets data first from its up-
layer cell once and then from its left-column cell for j times. 
After that, the following action is repeated for (L-1) times: 
getting data from its up-row cell once and then from its left-
column cell for j times. For the leftmost cell c(L-1,0,0), which 
has no left-column cell, it gets data from its up-layer cell once 
and then from its up-row cell for (L-1) times. For example, the 
event sequence of cell c(3,2,0) in Fig. 3 is (α, γ, γ, β, γ, γ, β, γ, γ, β, γ, γ), and for the leftmost cell c(3,0,0), it is (α, β, β, β). In 
Case 2, each cell gets data from its up-layer cell once and then 
from its up-row cell for i times.  For the cells in row 0, which 
have no up-row cells, they get data from their up-layer cells 
only. For example, the event sequences of cells c(2,2,0) and c(0,2,0) in Fig. 3 are (α, β, β) and (α), respectively. In Case 3, 
Case 4, and Case 5, each cell gets data from its up-layer cell, 
up-row cell, and left-column cell, respectively. However, the 
left-column cell of c(0,0,3), the first cell of the FIFO, is the 
virtual input cell that provides the FIFO with new data items.  
D. Algorithm 
Since Balsa is a control-driven design framework, either 
the read or write operation of the FIFO must be activated by 
the outside environment. If it is a read operation, the data in 
the last cell is read out, and then the data items in the other 
cells are shifted between cells. If it is a write operation, the 
shift operation is performed, and then the new data is written 
into the first cell of the FIFO. For each cell c(i,j,k), this shift 
operation is performed by getting data from an appropriate 
cell. The source cell for c(i,j,k) to get data from must be 
carefully arranged so that the data items are read out in the 
same order they were written into the FIFO.  
The algorithm for the cubic FIFO design is given in Fig. 5. 
The FIFO behavior is enclosed in an endless loop for 
receiving any read or write request from the outside 
environment. When the FIFO is activated, the read event of 
the virtual output cell is first activated to get data from the last 
cell of the FIFO. Then the data shift operation is performed on 
each cell of the FIFO by activating an event in the event 
sequence of the cell. This activation process starts from the 
bottom layer to the top layer. In each layer, it starts from the 
bottom row to the top row, and in each row, it starts from the 
right column to the left column. In Fig. 3, for example, the 
number associated with each cell shows the activation order 
(in decreasing order) of the FIFO. The activation process 
starts from number 63 to 0, and then restarts again. Since the 
data items enter the FIFO in the top layer, the events of the 
cells in layer H-2 will be activated only when nrw is a multiple 
of the area (L*W) of the layer, where nrw is counted as the 
number of read or written operations performed on the FIFO. 
This is to ensure that the data items will be correctly 
distributed to the top layer before going down to the next 
layer. Similarly in the top layer, since the data items enter the 
FIFO in the top row, the events of the cells in the second row 
can be activated only when nrw is a multiple of the width (W) 
of the layer. This is also to ensure that the data items can be 
while (1) {
if (read_flag == 1) 
Activate the read event of the virtual output cell; 
for ( k=0; k <= H-1; k++ ) { 
// n1 
and n2 are arbitrary positive integers. 
if ( k == H-2  &&  nrw != n1 * (L*W) )  
continue; 
for ( i = L-1; i >= 0; i-- ) { 
if ( k == H-1  &&  i == 1  &&  nrw != n2* W ) 
continue; 
for ( j = W-1; j >= 0; j-- ) { 
if ( c(i,j,k) is empty ) 
Activate an event in seq(i,j,k); 
} 
} 
} 
} 
 
Figure 5. The cubic FIFO design algorithm. 
TABLE I.  EVENT SEQUENCE FOR EACH CLASSIFICATION OF CELLS 
 
Case Event sequence
Case 1: i = L-1, j = 0..(W-1), k = 0 
j L-1
α,γ,γ,...,γ ,δ,δ,...,δ
 
, 
where
j
δ= β,γ,γ,...,γ

 
Case 2: i = 0..(L-2), j = 0..(W-1), k = 0 
i
α,β,β,...,β

 
Case 3: i = 0..(L-1), j = 0..(W-1), k = 0..(H-2) α 
Case 4: i = 1..(L-1), j = 0..(W-1), k = H-1 β 
Case 5: i = 0, j = 0..(W-1), k = H-1 γ 
 
備註: 
本計畫相關研究成果發表於 
International Symposium on Integrated Circuits (ISIC) 
12-14 December 2011, Singapore (EI) 
 
99 年度專題研究計畫研究成果彙整表 
計畫主持人：陳仁德 計畫編號：99-2221-E-018-027- 
計畫名稱：多時脈系統中 FIFO 介面設計之研究 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 1 1 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 6 6 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
