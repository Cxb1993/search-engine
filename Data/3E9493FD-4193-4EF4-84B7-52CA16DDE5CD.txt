 2 
中文摘要 
忘卻式傳輸機制 (OT) 是密碼學上很重
要的一個基本元件，許多密碼學的應用都會
利用忘卻式傳輸來確保送方與收方都達到設
定的安全條件，OT 是密碼學裡的完全性密碼
元件，只要有安全的 OT 協定就可以達成任
何密碼學上的多人安全計算問題。本計畫研
究 OT 的相關問題。 
關鍵詞：分散式門檻密碼、預防式密碼、安
全模式。 
英文摘要 
Oblivious transfer (OT) is an important 
cryptographic primitive. Many cryptographic 
applications, such as private information 
retrieval, can be achieved by basing on the OT 
protocol. The OT protocol is complete in the 
sense that every multi-party secure computation 
of a polynomial-time computable function can 
be realized by using the OT protocol only. In 
this project, we study the related issues about 
OT.  
Keywords: Oblivious transfer, bounded storage 
model, secure multiparty computation. 
一、計畫緣貣及目的 
忘卻式傳輸（Oblivious Transfer，OT）
機制包含了傳送者 Sender（S）和接收者
Receiver（R）兩方，S 擁有一些秘密資訊 m0, 
m1,…，R 想要透過與 S 交換一些訊息而得到
其中的一個秘密資訊 m，OT 機制保證不會
讓 S 知道 R 的選擇 ，同時 R 也不會得到其
他沒有選到的秘密資訊。OT 機制是密碼學上
很重要的一個基本元件，許多密碼學的應用
都會利用忘卻式傳輸來確保送方與收方都達
到設定的安全條件，例如在電子商務的的應
用當中，商務網站可藉由這樣的機制販售付
費資訊，如 mp3 音樂的下載，使用者可以選
擇其想要購買的歌曲，並且保有隱私性，不
讓網站知道其所選擇購買的音樂為何，網站
也可藉由此機制保障其他未付費的資訊不會
洩漏給使用者。 
OT 是密碼學裡的完全性密碼元件
（complete cryptographic primitive），只要有
安全的 OT 協定就可以達成任何密碼學上的
多 人 安 全 計 算 （ multi-party secure 
computation）問題。所謂多人安全計算是指
多人參與的密碼安全協定，有一公開的函數
f，每一參與者 Pi 有一秘密值 xi，他們要透
過 公 開 交 換 訊 息 的 方 式 函 數 值
y=f(x1,x2,…)，最終所有的參與者都得到 y
值；對任何參與者 Pi 而言，除了可以由 y 和
xi 計算出的資訊之外，Pi 得不到其他參與者
Pj 的秘密值 xj 的其他資訊。由多人安全計算
的定義可以看出任何密碼協定都可以套用這
個模式，例如，在安全電子投票系統裡，最
後要計算出票數，但又不要洩漏個別投票者
所投的票，假設是投贊成與反對，每一投票
Vi 者貢獻 xi{0,1}（0 表反對，1 表贊成），
安全電子投票系統就是由所有的投票者安全
地計算出 f(x1,x2,…)=x1+x2+…。又如在雙人
相互身份認證的問題裡，Alice (P1) 的私密與
公開資訊為 x1 與 y1，Bob (P2) 的私密與公
開資訊為 x2 與 y2，Alice 與 Bob 的相互身份
認證就是計算 fy1,y2(x1,x2)=1 if and only if 
(y1,x1) 與  (y2,x2) 分別為成對的公開與私
密資訊。 
本計畫的目的有下列幾項：（1）研究以
OT 來直接建構安全的計算函數，例如比較兩
個數的大小，判斷一數 x 是否落於某一區間 
[a, b] 等，我們希望能夠將 query language 裡
所需的運算皆以 OT 直接實現；本計畫將實
做我們研究出的成果，我們希望實做出基於
OT 的安全 query language，達到保障使用者
與資料庫擁有者的隱私與安全。（2）我們打
算研究 k-out-of-n OT 機制，我們認為目前的
方法還不夠好，應該可以達到更佳的回合數
及訊息數。（3）我們將研究攻擊者限制模式
 4 
EUROCRYPT 2001: 119-135. 
2. Donald Beaver: How to Break a "Secure" Oblivious 
Transfer Protocol. EUROCRYPT 1992: 285-296. 
3. Ian F. Blake, Vladimir Kolesnikov: Strong 
Conditional Oblivious Transfer and Computing on 
Intervals. ASIACRYPT 2004: 515-529. 
4. Mihir Bellare and Silvio Micali. Non-Interactive 
Oblivious Transfer and Applications. In Proceedings 
of Advances in Cryptology - CRYPTO '89, volume 
435 of LNCS, pages 547-557. Springer-Verlag, 
1989.  
5. Gilles Brassard, Claude Crepeau and Jean-Marc 
Robert. All-or-Nothing Disclosure of Secrets. In 
Proceedings of Advances in Cryptology - CRYPTO 
'86, volume 263 of LNCS, pages 234-238. 
Springer-Verlag, 1986. 
6. Christian Cachin, Claude Crépeau, Julien Marcil: 
Oblivious Transfer with a Memory-Bounded 
Receiver. FOCS 1998: 493-502. 
7. Yan-Cheng Chang, Chi-Jen Lu: Oblivious 
Polynomial Evaluation and Oblivious Neural 
Learning. ASIACRYPT 2001: 369-384. 
8. Claude Crépeau, Jeroen van de Graaf, Alain Tapp: 
Committed Oblivious Transfer and Private 
Multi-Party Computation. CRYPTO 1995: 110-123. 
9. Yan Zong Ding: Oblivious Transfer in the Bounded 
Storage Model. CRYPTO 2001: 155-170. 
10. Shimon Even, Oded Goldreich and Abraham 
Lempel. A Randomized Protocol for Signing 
Contracts. Communications of the ACM, 
28(6):637-647, 1985. 
11. J.A. Garay, P.D. MacKenzie, Concurrent oblivious 
transfer, FOCS 2000, pp.314-324, 2000. 
12. Y. Gertner, Y. Ishai, E. Kushilevitz, T. Malkin, 
Protecting data privacy in private data retrieval 
schemes, STOC 98, pp.151-160, 1998. 
13. O. Goldreich, S. Micali, A. Wigderson. Proofs that 
yield nothing but the validity of the assertion and a 
methodology of cryptographic protocol design. 
FOCS 86, pp.174-187, 1986. 
14. O. Goldreich, S. Micali, A. Wigderson. How to play 
any mental game. SOTFC 87, pp.218-229, 1987. 
15. Dowon Hong, Ku-Young Chang, Heuisu Ryu. 
Efficient Oblivious Transfer in the Bounded-Storage 
Model. ASIACRYPT 2002: 143-159. 
16. Yuval Ishai, Joe Kilian, Kobbi Nissim, Erez Petrank: 
Extending Oblivious Transfers Efficiently. CRYPTO 
2003: 145-161. 
17. Joe Kilian: Founding Cryptography on Oblivious 
Transfer. STOC 1988: 20-31. 
18. Yi Mu, Junqi Zhang and Vijay Varadharajan. m out 
of n Oblivious Transfer. In Proceedings of the 7th 
Australasian Conference on Information Security 
and Privacy (ACISP '02), volume 2384 of LNCS, 
pages 395-405. Springer-Verlag, 2002. 
19. Ueli M. Maurer. Conditionally-Perfect Secrecy and 
a Provably-Secure Randomized Cipher. J. 
Cryptology 5(1): 53-66 (1992). 
20. Moni Naor and Benny Pinkas. Oblivious Transfer 
with Adaptive Queries. In Proceedings of Advances 
in Cryptology - CRYPTO '99, volume 1666 of 
LNCS, pages 573-590. Springer-Verlag, 1999. 
21. M. Naor, B. Pinkas. Oblivious transfer and 
polynomial evaluation, STOC 99, pp.145-254, 1999. 
22. M. Naor, B.Pinkas. Distributed oblivious transfer, 
Asiacrypt 00, Lecture Notes in Computer Science 
1976, pp.205-219, Springer-Verlag, 2000. 
23. M. Naor, B. Pinkas. Efficient oblivious transfer 
protocols, In Proceedings of the 12th Annual 
Symposium on Discrete Algorithms, pp.448-457, 
2001. 
24. Wakaha Ogata and Kaoru Kurosawa. Oblivious 
Keyword Search. Cryptology ePrint Archive: Report 
2002/182, IACR, 2002. 
25. Michael O. Rabin. How to exchange secrets by 
oblivious transfer. Technical Report TR-81, Aiken 
Computation Laboratory, Harvard University, 1981. 
26. J.P. Stern. A new and efficient all-or-nothing 
disclosure of secrets protocol, Asiacrypt 98, Lecture 
Notes in Computer Science 1514, pp.357-371, 
1 
 
出席 2008 公開金鑰密碼會議 (PKC 2008) 報告 
一、 時間與地點：3/9 - 3/12, 2008，巴塞隆納 西班牙。 
二、 參加會議經過 
第十一屆公開金鑰密碼會議（11th International Workshop on Practice and 
Theory in Public Key Cryptography，簡稱為 PKC 2008）為國際密碼研究學會
（International Association for Cryptologic Research，簡稱為 IACR)主辦，今年的
承辦單位為西班牙巴塞隆納市的 Universitat Politenica de Catalunya (UPC)。會議
在 UPC 的北校園舉行，與會人數約 100 人，其中來自台灣的與會者只有筆者一
人。會議為期四天（3/9~3/12），會議中安排了三場邀請演講，每天一場，相當精
采，其餘皆是論文發表，3/10 下午有一參觀古修道院的活動。整體來說，這次的
會議因為在學校內舉辦，較為簡單，但會場內討論的氣氛卻很熱烈，大家的發問
都很踴躍，休息時間也可看到許多相互交流與討論。 
三、 發表論文介紹 
我們這次所發表的論文為 ”Public Key Encryption Schemes with Low Number 
of Keys and Constant Decryption Time”，主要是公開金鑰廣播加密的問題，廣播
加密分為私密金鑰式的和公開金鑰式的，差別在於第三者是否可以廣播訊息給使
用者。已往對於私密金鑰式廣播加密系統的問題已提出最佳解，因此研究轉到公
開金鑰式的系統，先前的研究對於一些效率參數還無法達到很好，本篇論文提出
第一個公開金鑰式廣播加密系統，具有 O (1)公開金鑰、每位使用者 O(log N) 私
密金鑰及 O (r) 密文大小。其中還有一個系統的解密時間是 O(1)。這些系統是目
前最好的公開金鑰式廣播加密協定。在我報告完後，與會的學者表達了高度的興
趣，認為使用多項式在這樣的系統上，用得很巧妙，再加上雙線性函數與雜湊函
數的使用，實在是一個很不錯的創新。 
詳細的內容請見論文。 
四、 與會心得 
本次會議共有 71 篇論文送審，最後有 21 篇論文發表，每篇發表的時間為
30 分鐘，分為 8 個不同的主題： 
1. Algebraic and Number Theoretical Cryptanalysis (I) 
2. Theory of Public Key Encryption 
3. Digital Signatures (I) 
4. Identification, Broadcast and Key Agreement 
5. Implementation of Fast Arithmetic 
3 
 
域當中，好的國際會議往往是各國學者注目的焦點，發表在這些會議上，才容易
會受到大家的重視與肯定。另外，各國學者在會議期間積極的討論與交流的態
度，也是我們該學習的項目，希望我國學者能多與國外學者交流與的討論，如此
才能提升研究的水準，與世界的密碼研究接軌。 
六、 攜回資料名稱與內容 
1. PKC 2008 論文集一本。 
2. 參加人員名單與聯繫資料一份。 
3. 相關會議的 CFP。 
190 C.-K. Chu and W.-G. Tzeng
In this paper, we propose two IB-PRE schemes, which are both proved secure
in the standard model. The ﬁrst one is eﬃcient in both computation and cipher-
text length, and the other one achieves chosen-ciphertext security. Both of our
schemes satisfy the following properties of PRE, which are mentioned in [1,10].
– Unidirectionality. Alice can delegate decryption rights to Bob without per-
mitting she to decrypt Bob’s ciphertext.
– Non-Interactivity. Alice can compute re-encryption keys without the partic-
ipation of Bob or the private key generator (PKG).
– Multi-Use. The proxy can re-encrypt a ciphertext multiple times, e.g. re-
encrypt from Alice to Bob, and then re-encrypt the result from Bob to
Carol.
The schemes proposed by Green and Ateniese [10] also satisfy these properties
except that their CCA-secure construction is not multi-use. Therefore, we give
the answers to the two open problems left in [10] by providing
1. IB-PRE schemes secure in the standard model; and
2. a multi-use CCA-secure IB-PRE scheme.
Related Works. Mambo and Okamoto [14] ﬁrst introduced the notion of PRE.
They gave some transformations that allow the original recipient to forward
speciﬁc ciphertexts to another recipient. Blaze et al. [3] later provided another
deﬁnition for PRE that allows the keyholder to publish the proxy function and
have it applied by untrusted parties without further involvement by the origi-
nal keyholder. After that, several public-key based PRE were continuously pro-
posed [13,12,1,11,9]. Finally, Green and Ateniese [10] provided identity-based
PRE. Note that Ivan and Dodis [12] also proposed an identity-based PRE scheme
in which the PKG delegates decryption rights for all identities in the system.
Therefore, individual users cannot delegate their decryption rights. The concept
of their construction is much diﬀerent from the approach of Green and Ateniese.
Organizations. In the rest of this paper we ﬁrst give some preliminaries, in-
cluding the IBE schemes without random oracles (Section 2) and the deﬁnition
of IB-PRE (Section 3). Then we present a CPA-secure IB-PRE scheme in Sec-
tion 4 and a CCA-secure IB-PRE scheme in Section 5. The summary of this
paper is provided in Section 6.
2 Backgrounds
We brieﬂy describe the groups and IBE schemes that will be used in our con-
structions.
2.1 Pairings
Let G and G1 be two (multiplicatively) cyclic groups of prime order p. Let
e : G × G → G1 is a map with the following properties:
192 C.-K. Chu and W.-G. Tzeng
directly use the 2-level Wa-HIBE to construct a CCA-secure IBE scheme (Wa-
CCA-IBE).
The following scheme is a CCA-secure IBE scheme from Wa-HIBE [15] and
the results of Boneh and Katz [6].
– Setup(1λ): On input security parameter 1λ, the parameters are chosen like
the Wa-IBE scheme except that the function F is replaced by two functions
F1(v) = u′1
∏
i∈V
u1,i and F2(w) = u′2u2,0
∏
i∈W
u2,i,
where u′1, u1,1, . . . , u1,n, u
′
2, u2,0, u2,1, . . . , u2,n are chosen at random from G,
v, w are two n-bit strings and V ,W are the set of all i for which the i-th bit
of v and w is one, respectively. Moreover, let (G, Sign,Vrfy) be a one-time
signature scheme in which the veriﬁcation key output by G(1λ′) has length
n. The public parameter
μ = (g, g1, g2, F1(·), F2(·), (G, Sign,Vrfy))
and the master secret key mk = gα2 are outputted.
– KeyGen(μ,mk, v): Let v be an n-bit string representing an identity. Then
the private key for v is computed as
dv = (gα2 F1(v)
r , gr),
where r ∈R Zp.
– Encrypt(μ, v,M): Perform G(1λ′ ) to get (vk, sk). For the message M and
identity v, compute the ciphertext as
C˜ = (M · e(g1, g2)t, gt, F1(v)t, F2(vk)t),
where t ∈R Zp. Moreover, compute σ = Signsk(C˜). Output the ciphertext
C = (C˜, vk, σ).
– Decrypt(μ, d, C): Let d = (d1, d2) and C = (c1, c2, c3, c4, vk, σ). Check if
Vrfyvk((c1, c2, c3, c4), σ)
?= 1.
If not, output ⊥. Otherwise, compute d′1 = d1F2(vk)r
′
and d′2 = g
r′ , where
r′ ∈R Zp. Then decrypt C as
M = c1
e(d2, c3)e(d′2, c4)
e(d′1, c2)
.
By the security argument in [6], we have the following theorem.
Theorem 2. If Wa-HIBE is secure against chosen-plaintext attacks and
(G, Sig,Vrfy) is a one-time signature scheme, then Wa-CCA-IBE is secure against
chosen-ciphertext attacks.
194 C.-K. Chu and W.-G. Tzeng
1. Setup. Perform Setup(1λ) to get (μ,mk) and give μ to A.
2. Query phase 1. A makes the following queries.
(a) Extract(v): return dv = KeyGen(μ,mk, v) to A.
(b) RKExtract(v1, v2): return dv1→v2 =RKGen(μ, dv1 , v1, v2) to A, where
dv1 = KeyGen(μ,mk, v1).
If ATK=CCA, A can make the additional queries:
(c) Reencrypt(v1 , v2, Cv1): return Cv2 =Reencrypt(μ, dv1→v2 , v1, v2, Cv1)
to A, where dv1→v2 =RKGen(μ, dv1 , v1, v2), dv1 = KeyGen(μ,mk, v1).
(d) Decrypt(v, Cv): return M = Decrypt(μ, dv, Cv) to A, where dv =
KeyGen(μ,mk, v).
3. Challenge. A presents (v∗,m0,m1). If the queries
– Extract(v∗); and
– RKExtract(v∗, v′) and Extract(v′) for any identity v′,
are never made, return C∗ = Encrypt(μ, v∗,mb) to A, where b ∈R {0, 1}.
4. Query phase 2. A continues making queries as in the Query phase 1, except
for the following queries
– Extract(v∗);
– RKExtract(v∗, v′) and Extract(v′) for any identity v′;
– RKExtract(v∗, v′) and Decrypt(v′, Cv′) for any identity v′ and any
ciphertext Cv′ .
– Reencrypt(v∗ , v′, C∗) and Extract(v′) for any identity v′;
– Decrypt(v∗, Cv∗); and
– Decrypt(v′, Cv′) forany identityv′,whereCv′ ←Reencrypt(v∗, v′, C∗).
5. Guess. A outputs the guess b′ ∈ {0, 1}.
If b′ = b, A wins the game. Let OATK be the set of oracles that A can query
under ATK=CPA or CCA, and O˜ATK be the set of the same oracles with the
restrictions in Query phase 2. Then the advantage of A = (A1,A2) in the above
game is deﬁned as:
AdvIND-PrID-ATKA = Pr[b
′ = b : b ∈R {0, 1}, (μ,mk) ← Setup(1λ),
(v∗,m0,m1, st) ← AOATK1 (μ), C∗ ← Encrypt(μ, v∗,mb),
b′ ← AO˜ATK2 (st, C∗)] −
1
2
.
We say that an IB-PRE scheme is IND-PrID-ATK secure, ATK∈{CPA,CCA},
if for all probabilistic polynomial time algorithm A and negligible function ,
AdvIND-PrID-ATKA ≤ (k).
4 The First Construction
We present the ﬁrst scheme IB-PRE-I in this section. The scheme is based on
Wa-IBE, and provides CPA security. It is eﬃcient in both computation and
ciphertext length.
196 C.-K. Chu and W.-G. Tzeng
We can see that the recipient only needs k to decrypt the re-encrypted ciphertext.
Therefore the proxy can further convert the re-encrypted ciphertext to others by
iteratively re-encrypting R. As long as the recipient can decrypt the ciphertext
to get k, the message m can be computed as well. The scheme satisﬁes the multi-
use property. Note that R is not a single group element, but we can just encrypt
all elements in the tuple. The cost of ciphertext grows linearly with the number
of re-encryptions. As stated in [10], it seems to be inevitable for a non-interactive
scheme.
4.2 Security
Next we prove that the scheme IB-PRE-I is IND-PrID-CPA secure if the Wa-IBE
scheme is IND-ID-CPA secure. For the adversary A breaking IB-PRE-I, we build
a simulator B to break Wa-IBE. The simulator maintains a table with tuples
(β, v1, v2), where β ∈ {0, 1} and v1, v2 are two identities. Since we have to query
key extraction oracle of Wa-IBE for v to answer A’s queries to RKExtract(v, ·).
If A queries RKExtract(v, ·) and later sends v as the challenge identity, then
B cannot get the challenge ciphertext of Wa-IBE for v and the simulation must
fail. Therefore when A queries RKExtract(v, ·), B either sends v to the key
extraction oracle of Wa-IBE or randomly generates a re-encryption key. We set
β = 1 if B returns the correct key and β = 0 otherwise.
Theorem 3. Suppose there is an adversary A that has advantage  against the
game ExpA,IND-PrID-CPA. Then there is an algorithm B that breaks Wa-IBE with
advantage at least
AdvIND-ID-CPAB ≥ /e(1 + qE),
where qE is the maximal number of A’s queries to Extract, and e is the base
of the natural logarithm. The running time of B is O(time(A)).
Proof. Assume that there is an adversary A breaking IB-PRE-I. We construct
an algorithm B to break Wa-IBE. Given the public parameter μ of Wa-IBE
scheme, B performs the following steps. Note that B maintains a table with
tuples (β, v1, v2) ∈ {0, 1}×{0, 1}n×{0, 1}n. Let ∗ denote the wildcard. Without
loss of generality, we assume an input is queried to an oracle only once.
1. Setup. Give the parameter μ to A.
2. Query phase 1. A can make the following queries.
(a) Extract(v): B ﬁrst generates a random coin β so that Pr[β = 1] =
δ for some δ that will be determined later. If β = 0, or (0, v, ∗) or
(0, ∗, v) already exists on the table, B outputs a random bit and aborts.
Otherwise, B sends the query to the key extraction oracle of Wa-IBE to
get dv, and returns dv to A. B also records (1, v, v) on the table.
(b) RKExtract(v1, v2): B chooses a random coin β as in the Extract. If
β = 1, or (1, v1, v1) or (1, v2, v2) already exists on the table, B queries
the key extraction oracle of Wa-IBE for v1, and then computes the re-
encryption key as the original scheme and returns it to A. Otherwise, B
198 C.-K. Chu and W.-G. Tzeng
5 The Chosen-Ciphertext Secure Construction
The CCA-secure IB-PRE scheme is presented in this section. It is based on
Wa-CCA-IBE.
5.1 The Scheme IB-PRE-II
Like IB-PRE-I, we ﬁrst assume the proxy re-encrypts ciphertexts once.
– Setup(1λ): On input security parameter 1λ, the parameters are chosen like
the ﬁrst construction except that the function F is replaced by two functions
F1(v) = u′1
∏
i∈V
u1,i and F2(w) = u′2u2,0
∏
i∈W
u2,i,
where u′1, u1,1, . . . , u1,n, u
′
2, u2,0, u2,1, . . . , u2,n are chosen at random from G,
v, w are two n-bit strings and V ,W are the set of all i for which the i-th bit
of v and w is one, respectively. Let l ≤ |p| − 2 and E1 : {0, 1}l+1 → G1, E2 :
{0, 1}l → G be two encodings. Moreover, let (G, Sign,Vrfy) be a one-time
signature scheme in which the veriﬁcation key output by G(1λ′) has length
n. The public parameter
μ = (g, g1, g2, F1(·), F2(·), (G, Sign,Vrfy))
and the master secret key mk = gα2 are outputted.
– KeyGen(μ,mk, v): Let v be an n-bit string representing an identity. Then
the private key for v is computed as
dv = (gα2 F1(v)
r , gr),
where r ∈R Zp.
– Encrypt(μ, v,m): Perform G(1λ′) to get (vk, sk). For the message m ∈
{0, 1}l and identity v, compute
C˜ = (M · e(g1, g2)t, gt, F1(v)t, F2(vk)t),
where t ∈R Zp and M = E1(m||0). Moreover, compute σ = Signsk(C˜).
Output the ciphertext Cv = (C˜, vk, σ).
– RKGen(μ, dv1 , v1, v2): Let dv1 = (d1, d2). Compute the re-encryption key
for v2 as
dv1→v2 = (d1K
−1, d2, R),
where k ∈R {0, 1}l,K = E2(k) ∈ G and R ← Encrypt’(μ, v2, k). We deﬁne
Encrypt’ the same as Encrypt except that it appends ‘1’ to the message.
– Reencrypt(μ, dv1→v2 , Cv1): Let dv1→v2 = (dˆ1, d2, R) and Cv1 =
(c1, c2, c3, c4, vk, σ). Check if Vrfyvk((c1, c2, c3, c4), σ)
?= 1. If not, output ⊥.
Otherwise, compute d′1 = dˆ1F2(vk)r
′
, d′2 = gr
′
and
Cv2 = (Cv1 , R, d
′
1, d2, d
′
2)
where r′ ∈R Zp.
200 C.-K. Chu and W.-G. Tzeng
1. Setup. Give the parameter μ to A.
2. Query phase 1. A can make the following queries.
(a) Extract(v): B ﬁrst generates a random coin β so that Pr[β = 1] = δ
for some δ that will be determined later. If β = 0, or (0, v, ∗, ∗) or
(0, ∗, v, ∗) already exists on the table, B outputs a random bit and aborts.
Otherwise, B sends the query to the key extraction oracle of Wa-CCA-
IBE to get dv, and returns dv to A. B also records (1, v, v,⊥) on the
table.
(b) RKExtract(v1, v2): B chooses a random coin β as in the Extract.
If β = 1, or (1, v1, v1,⊥) or (1, v2, v2,⊥) already exists on the table, B
queries the key extraction oracle of Wa-CCA-IBE for v1, and then com-
putes the re-encryption key as the original scheme and returns it to A.
Otherwise, B returns a random re-encryption key dv1→v2 =
(x, y,Encrypt’(μ, v2, z)) for x, y ∈R G and z ∈R {0, 1}l. Finally, B records
the tuple (β, v1, v2, dv1→v2) on the table.
(c) Reencrypt(v1 , v2, Cv1): Let Cv1 = (c1, c2, c3, c4, vk, σ). If (∗, v1, v2, ∗)
does not exist on the table, B performs RKExtract(v1, v2) to get the
re-encryption key dv1→v2 . Then for the tuple (∗, v1, v2, dv1→v2), B uses
dv1→v2 to re-encrypt the ciphertext as the real scheme.
(d) Decrypt(v, Cv): If Cv is a regular encryption, B sends the ciphertext to
the decryption oracle of Wa-CCA-IBE for v, and returns the plaintext
to A if and only if it ends with ‘0’. If Cv is a re-encrypted ciphertext,
let Cv = (Cv1 , R, d′1, d2, d
′
2) and Cv1 = (c1, c2, c3, c4, vk, σ). If (0, v1, v, d˜)
exists on the table for any v1 and d˜ = (d˜1, d˜2, d˜3), B checks whether
e(d′1, g)
?= e(d˜1, g)e(F2(vk), d′2), d2
?= d˜2 and R
?= d˜3.
If the equations hold, B sends Cv1 to the decryption oracle of Wa-CCA-
IBE for v1, and returns the plaintext to A if and only if it ends with ‘0’.
Otherwise, B sends R to the decryption oracle of Wa-CCA-IBE scheme
for v to get k||1 (otherwise, return ⊥) and computes
M = c1
e(d2, c3)e(d′2, c4)
e(d′1K, c2)
for K = E2(k). If E1(M) = m||0 for some m, B returns m to A. Other-
wise, B returns ⊥.
3. Challenge. A sends (v∗,m0,m1) to B, if (1, v∗, v′, k) exists on the table for
any v′ and k, B randomly outputs a bit and aborts. Otherwise, B sends the
challenge (v∗,m0||0,m1||0) to the challenger of Wa-CCA-IBE. When the
challenger returns ciphertext C∗, B returns C∗ to A.
4. Query phase 2. A continues making the following queries, except for the
restrictions described in Deﬁnition 2.
(a) Extract(v): B answers queries as in the Query phase 1.
(b) RKExtract(v1, v2): For all v1 = v∗, B queries the key extraction oracle
of Wa-CCA-IBE for v1, and then computes the re-encryption key as the
original scheme and returns it to A. For v1 = v∗, B returns a random
202 C.-K. Chu and W.-G. Tzeng
8. Canetti, R., Halevi, S., Katz, J.: Chosen-ciphertext security from identity-based
encryption. In: Cachin, C., Camenisch, J.L. (eds.) EUROCRYPT 2004. LNCS,
vol. 3027, pp. 207–222. Springer, Heidelberg (2004)
9. Canetti, R., Hohenberger, S.: Chosen-ciphertext secure proxy re-encryption. Cryp-
tology ePrint Archive, Report 2007/171 (2007)
10. Green, M., Ateniese, G.: Identity-based proxy re-encryption. In: Proceedings of
Applied Cryptography and Network Security 2007 (ACNS ’07). LNCS, vol. 4521,
pp. 288–306. Springer, Heidelberg (2007)
11. Hohenberger, S., Rothblum, G.N., Shelat, A., Vaikuntanathan, V.: Securely ob-
fuscating re-encryption. In: Vadhan, S.P. (ed.) TCC 2007. LNCS, vol. 4392, pp.
233–252. Springer, Heidelberg (2007)
12. Ivan, A.-A., Dodis, Y.: Proxy cryptography revisited. In: Proceedings of the Net-
work and Distributed System Security Symposium (NDSS ’03) The Internet Soci-
ety (2003)
13. Jakobsson, M.: On quorum controlled asymmetric proxy re-encryption. In: Imai,
H., Zheng, Y. (eds.) PKC 1999. LNCS, vol. 1560, pp. 112–121. Springer, Heidelberg
(1999)
14. Mambo, M., Okamoto, E.: Proxy cryptosystems: delegation of the power to decrypt
ciphertexts. IEICE Transactions on Fundamentals of Electronics, Communications
and Computer Sciences E80-A(1), 54–63 (1997)
15. Waters, B.: Eﬃcient identity-based encryption without random oracles. In: Cramer,
R.J.F. (ed.) EUROCRYPT 2005. LNCS, vol. 3494, pp. 114–127. Springer, Heidel-
berg (2005)
Eﬃcient k-Out-of-n Oblivious Transfer Schemes 173
has two messages m1 and m2, and would like R to obtain exactly one of them.
In addition, S remains oblivious to R’s choice. Brassard, et al. [BCR86] further
extended OT12 to 1-out-of-n OT (OT
1
n) for the case of n messages.
Oblivious transfer has been studied extensively and in many ﬂavors. Most
of them consider the case that R chooses one message. In this paper we are
concerned about the case that R chooses many messages at the same time. A
k-out-of-n OT (OTkn) scheme is an OT scheme in which R chooses k messages at
the same time, where k < n. A straightforward solution for OTkn is to run OT
1
n
k times independently. However, this needs k times the cost of OT1n. The com-
munication cost is two-round, O(k) messages from R to S, and O(kn) messages
from S to R even using the most eﬃcient OT1n schemes [NP01,Tze02].
Oblivious transfer with adaptive queries (Adpt-OT) allows R to query the
messages one by one adaptively [NP99a]. For the setting, S ﬁrst commits the
messages to R in the commitment phase. Then, in the transfer phase, R makes
queries of the messages one by one. The cost is considered for the commitment
and transfer phases, respectively. It seems that the adaptive case implies the
non-adaptive case. But, the non-adaptive one converted from an adaptive one
usually needs more rounds (combining the commitment and transfer phases), for
example, the scheme in [OK02]. Since our scheme needs no trapdoors, there is
no entailed cost due to conversion. Adaptive OTkn is natural and has many appli-
cations, such as oblivious search, oblivious database queries, private information
retrieval, etc.
In this paper we propose eﬃcient two-round OTkn schemes, in which R sends
O(k) messages to S, and S sends O(n) messages back to R. The computation cost
of R and S is reasonable. The choices of R are unconditionally secure. For the
basic scheme, the secrecy of unchosen messages is guaranteed if the Decisional
Diﬃe-Hellman (DDH) problem is hard. When k = 1, our scheme is as eﬃcient as
the one in [Tze02]. Our schemes have the nice property of universal parameters,
that is, each pair of R and S need neither hold any secret key nor perform any
prior setup (initialization). The system parameters can be used by all senders
and receivers without any trapdoor speciﬁcation. Our OTkn schemes are the most
eﬃcient one in terms of the communication cost, either in rounds or the number
of messages.
Moreover, one of our schemes can be extended in a straightforward way to
an Adpt-OTkn scheme. In our adaptive-query scheme, S sends O(n) messages
to R in one round in the commitment phase. For each query of R, only O(1)
messages are exchanged and O(1) operations are performed. In fact, the number
k of queries need not be ﬁxed or known beforehand. This makes our scheme
highly ﬂexible.
1.1 Previous Work and Comparison
Rabin [Rab81] introduced the notion of OT and presented an implementation to
obliviously transfer one-bit message, based on quadratic roots modulo a compos-
ite. Even, Goldreich and Lempel [EGL85] proposed an extension of bit-OT12, in
which m1 and m2 are only one-bit. Brassard, Cre´peau and Robert [BCR86]
Eﬃcient k-Out-of-n Oblivious Transfer Schemes 175
Table 1. Comparison of OTkn schemes in communication cost.
Ours (this paper) Mu, et al. [MZV02] Naor, et al. [NP99b]
rounds 2 2 O(wk log n)
messages (R → S) O(k) O(n) O(wk log n))
messages (S → R) O(n) O(n) O(n + wk log n)
universal parameters Yes Yes No (need setup)
made to adaptiveness Yes (OTkn-II) No Yes
Table 2. Comparison of Adpt-OTkn schemes in communication cost.
Ours 2-dimensional one, OTkn,
(this paper) Naor, et al. [NP99a] Ogata, et al.[OK02]
commitment rounds 1 1 1
phase messages O(n) O(n) O(n)
transfer rounds 2 3* 2
phase messages O(1) O(
√
n)** O(1)
* Two invocations of OT1√n in parallel.
** Use the most round-eﬃcient OT1√n scheme as the basis.
2 Preliminaries
Involved Parties. The involved parties of an OT scheme is the sender and
receiver. Both are polynomial-time-bounded probabilistic Turing machines
(PPTM). A party is semi-honest (or passive) if it does not deviate from the steps
deﬁned in the protocol, but tries to compute extra information from received
messages. A party is malicious (or active) if it can deviate from the speciﬁed
steps in any way in order to get extra information.
A malicious sender may cheat in order or content of his possessed messages.
To prevent the cheat, we can require the sender to commit the messages in a
bulletin board. When the sender sends the encrypted messages to the receiver
during execution of an OT scheme, he need tag a zero-knowledge proof of show-
ing equality of committed messages and encrypted messages. However, in most
applications, the sender just follows the protocol faithfully. Therefore, we con-
sider the semi-honest sender only and the semi-honest/malicious receiver.
Indistinguishability. Two probability ensembles {Xi} and {Yi}, indexed by i, are
(computationally) indistinguishable if for any PPTM D, polynomial p(n) and
suﬃciently large i, it holds that
|Pr[D(Xi) = 1]− Pr[D(Yi) = 1]| ≤ 1/p(i).
Correctness of a Protocol. An OT scheme is correct if the receiver obtains the
messages of his choices when the sender with the messages and the receiver with
the choices follow the steps of the scheme.
Eﬃcient k-Out-of-n Oblivious Transfer Schemes 177
– System parameters: (g, h,Gq);
– S has messages: m1,m2, . . . , mn;
– R’s choices: σ1, σ2, . . . , σk;
1. R chooses two polynomials f(x) = a0 + a1x + · · ·+ ak−1xk−1 + xk and f ′(x) =
b0 + b1x+ · · ·+ bk−1xk−1 + xk where a0, a1, . . . , ak−1 ∈R Zq and b0 + b1x+ · · ·+
bk−1xk−1 + xk ≡ (x− σ1)(x− σ2) · · · (x− σk) mod q.
2. R −→ S : A0 = ga0hb0 , A1 = ga1hb1 , . . . , Ak−1 = gak−1hbk−1 .
3. S computes ci = (g
ki ,miB
ki
i ) where ki ∈R Z∗q and Bi = gf(i)hf
′(i) =
A0A
i
1 · · ·Ai
k−1
k−1 (gh)
ik mod p, for i = 1, 2, . . . , n.
4. S −→ R: c1, c2, . . . , cn.
5. Let ci = (Ui, Vi), R computes mσi = Vσi/U
f(σi)
σi mod p for each σi.
Fig. 1. OTkn-I: k-out-of-n OT against semi-honest receiver.
Assumption 2 (Chosen-Target Computational Diﬃe-Hellman (CT-
CDH)). Let Gq be a group of prime order q, g be a generator of Gq, x ∈R Z∗q .
Let H1 : {0, 1}∗ → Gq be a cryptographic hash function. The adversary A is given
input (q, g, gx, H1) and two oracles: target oracle TG(·) that returns a random
element wi ∈ Gq at the i-th query and helper oracle HG(·) that returns (·)x. Let
qT and qH be the number of queries A made to the target oracle and helper oracle
respectively. The probability that A outputs k pairs ((v1, j1), (v2, j2), . . . , (vk, jk)),
where vi = (wji )x for i ∈ {1, 2, . . . , k}, qH < k ≤ qT , is negligible.
3 k-Out-of-n OT Schemes
We ﬁrst present a basic OTkn scheme for the semi-honest receiver in the standard
model. Then, we modify the scheme to be secure against the malicious receiver
in the random oracle model. Due to the random oracle model, the second scheme
is more eﬃcient in computation.
3.1 k-Out-of-n OT Against Semi-honest Receiver
The sender S has n secret messages m1,m2, . . . ,mn. Without loss of generality,
we assume that the message space is Gq, that is, all messages are in Gq. The
semi-honest receiver R wants to get mσ1 ,mσ2 , . . . ,mσk . The protocol OT
k
n-I with
security against the semi-honest receiver is depicted in Figure 1.
For system parameters, let g, h be two generators of Gq where logg h is un-
known to all, and Gq be the group with some descriptions. These parameters
can be used repeatedly by all possible senders and receivers as long as the value
logg h is not revealed. Therefore, (g, h,Gq) are universal parameters.
The receiver R ﬁrst constructs a k-degree polynomial f ′(x) such that f ′(i) =
0 if and only if i ∈ {σ1, . . . , σk}. Then R chooses another random k-degree
polynomial f(x) to mask the chosen polynomial f ′(x). The masked choices
A0, A1, . . . , Ak−1 are sent to the sender S.
Eﬃcient k-Out-of-n Oblivious Transfer Schemes 179
– System parameters: (g,H1,H2, Gq);
– S has messages: m1,m2, . . . , mn;
– R’s choices: σ1, σ2, . . . , σk;
1. R computes wσj = H1(σj) and Aj = wσj g
aj , where aj ∈R Z∗q and j = 1, 2, . . . , k.
2. R −→ S: A1, A2, . . . , Ak.
3. S computes y = gx, Dj = (Aj)
x, wi = H1(i), and ci = mi ⊕ H2(wxi ), where
x ∈R Z∗q , i = 1, 2, . . . , n, and j = 1, 2, . . . , k.
4. S −→ R: y, D1,D2, . . . ,Dk, c1, c2, . . . , cn
5. R computes Kj = Dj/y
aj and gets mσj = cσj ⊕H2(Kj) for j = 1, 2, . . . , k.
Fig. 2. OTkn-II: k-out-of-n OT against malicious receiver.
Machine D′
Input: (g, u, v, w) (either from Y1 or Y2 in DDH)
Output: D(g, u, v, w)
If D distinguishes C˜ and X˜ with non-negligible advantage ε (Should be (n, t), we
omit the security parameter n and t here for simplicity, where t is the security
parameter.), D′ distinguishes Y1, Y2 in the DDH problem with at least non-
negligible advantage ε− 2/q, where dist(C˜, Y1) = 1/q and dist(X˜, Y2) = 1/q.

Complexity. The scheme uses two rounds (steps 2 and 4), the ﬁrst round sends
k + 1 messages and the second round sends 2n messages. For computation, R
computes 3k + 2 and S computes (k + 2)n modular exponentiations.
3.2 k-Out-of-n OT Against Malicious Receiver
A malicious player may not follow the protocol dutifully. For example, in scheme
OTkn-I, a malicious R might send some special form of Ai’s in step 2 such that he
is able to get extra information, such as the linear combination of two messages
(even though we don’t know how to do such attack). So, we present another
scheme OTkn-II that is provable secure against the malicious R. The scheme is
depicted in Figure 2.
Let Gq be the subgroup of Z∗p with prime order q, g be a generator of Gq,
and p = 2q + 1 is also prime. Let H1 : {0, 1}∗ → Gq, H2 : Gq → {0, 1}l be two
collision-resistant hash functions. Let messages be of l-bit length. Assume that
CT-CDH is hard under Gq.
Correctness. We can check that the chosen messages mσj , j = 1, 2, . . . , k, are
computed as
cσj ⊕H2(Kj) = mσj ⊕H2(wxσj )⊕H2(wxσj )
= mσj .
Security Analysis. We need the random oracle model in this security analysis.
Eﬃcient k-Out-of-n Oblivious Transfer Schemes 181
– System parameters: (g,H1,H2, Gq);
– S has messages: m1,m2, . . . , mn;
– R’s choices: σ1, σ2, . . . , σk;
Commitment Phase
1. S computes ci = mi ⊕H2(wxi ) for i = 1, 2, . . . , n, and y = gx where wi = H1(i),
and x ∈R Z∗q .
2. S −→ R : y, c1, c2, . . . , cn.
Transfer Phase
For each σj , j = 1, 2, . . . , k, R and S execute the following steps:
1. R chooses a random aj ∈ Z∗q and computes wσj = H1(σj), Aj = wσj gaj .
2. R −→ S : Aj .
3. S −→ R : Dj = (Aj)x.
4. R computes Kj = Dj/y
aj and gets mσj = cσj ⊕H2(Kj).
Fig. 3. Adpt-OTkn: Adaptive OT
k
n.
4 k-Out-of-n OT with Adaptive Queries
The queries of R in our schemes can be adaptive. In our schemes, the commit-
ments ci’s of the messages mi’s of S to R are independent of the key masking.
Therefore, our scheme is adaptive in nature. Our Adpt-OTkn scheme, which re-
phrases the OTkn-II scheme, is depicted in Figure 3.
The protocol consists of two phases: the commitment phase and the transfer
phase. The sender S ﬁrst commits the messages in the commitment phase. In
the transfer phase, for each query, R sends the query Aj to S and obtains the
corresponding key to decrypt the commitment cj .
Correctness of the scheme follows that of OTkn-II.
Security Analysis. The security proofs are almost the same as those for OTkn-II.
We omit them here.
Complexity. In the commitment phase, S needs n + 1 modular exponentiations
for computing the commitments ci’s and y. In the transfer phase, R needs 2
modular exponentiations for computing the query and the chosen message. S
needs one modular exponentiation for answering each R’s query. The commit-
ment phase is one-round and the transfer phase is two-round for each adaptive
query.
5 Conclusion
We have presented two very eﬃcient OTkn schemes against semi-honest receivers
in the standard model and malicious receivers in the random oracle model. Our
schemes possess other interesting features, such as, it can be non-interactive and
needs no prior setup or trapdoor. We also proposed an eﬃcient Adpt-OTkn for
Eﬃcient k-Out-of-n Oblivious Transfer Schemes 183
[GV87] Oded Goldreich and Ronen Vainish. How to solve any protocol problem
- an eﬃciency improvement. In Proceedings of Advances in Cryptology -
CRYPTO ’87, volume 293 of LNCS, pages 73–86. Springer-Verlag, 1987.
[IKNP03] Yuval Ishai, Joe Kilian, Kobbi Nissim, and Erez Petrank. Extending
oblivious transfers eﬃciently. In Proceedings of Advances in Cryptology
- CRYPTO ’03, volume 2729 of LNCS, pages 145–161. Springer-Verlag,
2003.
[Kil88] Joe Kilian. Founding cryptography on oblivious transfer. In Proceedings
of the 20th Annual ACM Symposium on the Theory of Computing (STOC
’88), pages 20–31. ACM, 1988.
[Lip] Helger Lipmaa. Oblivious transfer.
http://www.tcs.hut.ﬁ/˜helger/crypto/link/protocols/oblivious.html.
[Lip04] Helger Lipmaa. An oblivious transfer protocol with log-squared commu-
nication. Technical report, Cryptology ePrint Archive: Report 2004/063,
2004.
[MZV02] Yi Mu, Junqi Zhang, and Vijay Varadharajan. m out of n oblivious transfer.
In Proceedings of the 7th Australasian Conference on Information Security
and Privacy (ACISP ’02), volume 2384 of LNCS, pages 395–405. Springer-
Verlag, 2002.
[NP99a] Moni Naor and Benny Pinkas. Oblivious transfer and polynomial evalua-
tion. In Proceedings of the 31th Annual ACM Symposium on the Theory of
Computing (STOC ’99), pages 245–254. ACM, 1999.
[NP99b] Moni Naor and Benny Pinkas. Oblivious transfer with adaptive queries.
In Proceedings of Advances in Cryptology - CRYPTO ’99, volume 1666 of
LNCS, pages 573–590. Springer-Verlag, 1999.
[NP00] Moni Naor and Benny Pinkas. Distributed oblivious transfer. In Proceedings
of Advances in Cryptology - ASIACRYPT ’00, volume 1976 of LNCS, pages
200–219. Springer-Verlag, 2000.
[NP01] Moni Naor and Benny Pinkas. Eﬃcient oblivious transfer protocols. In
Proceedings of the 12th Annual Symposium on Discrete Algorithms (SODA
’01), pages 448–457. ACM/SIAM, 2001.
[NR94] Valtteri Niemi and Ari Renvall. Cryptographic protocols and voting. In
Results and Trends in Theoretical Computer Science, volume 812 of LNCS,
pages 307–317. Springer-Verlag, 1994.
[OK02] Wakaha Ogata and Kaoru Kurosawa. Oblivious keyword search. Journal
of Complexity, 20(2-3):356–371, 2004.
[Rab81] Michael O. Rabin. How to exchange secrets by oblivious transfer. Technical
Report TR-81, Aiken Computation Laboratory, Harvard University, 1981.
[SS90] Arto Salomaa and Lila Santean. Secret selling of secrets with several buy-
ers. Bulletin of the European Association for Theoretical Computer Science
(EATCS), 42:178–186, 1990.
[Ste98] Julien P. Stern. A new and eﬃcient all or nothing disclosure of secrets
protocol. In Proceedings of Advances in Cryptology - ASIACRYPT ’98,
volume 1514 of LNCS, pages 357–371. Springer-Verlag, 1998.
[Tze02] Wen-Guey Tzeng. Eﬃcient 1-out-n oblivious transfer schemes. In Proceed-
ings of the Public-Key Cryptography (PKC ’02), pages 159–171. Springer-
Verlag, 2002.
[YBD03] Gang Yao, Feng Bao, and Robert Deng. Security analysis of three oblivious
transfer protocols. Workshop on Coding, Cryptography and Combinatorics,
Huangshan City, China, 2003.
 
tablish a ﬂexible subscription system, in which users
pay diﬀerent premiums for diﬀerent access rights.
1.1 Related work
Hierarchical key assignment schemes for access control are
ﬁrst studied by Akl and Taylor [1]. Many researchers fol-
lowed to propose improvements [3, 9, 16]. Tzeng [22] pro-
posed a time-dependent hierarchical key assignment scheme,
which is an extension of them with an additional dimension
on time periods. The scheme has some interesting appli-
cations, for example, secure broadcasting and key backup.
The scheme cannot withstand the collusion attack.1 In this
paper we propose a new time-dependent hierarchical key as-
signment scheme that is secure against the collusion attack
of multiple adversaries.
Entity authentication has been studied extensively (see [8,
18, 20]). ISO/IEC has a series of standards for entity au-
thentication [10, 11, 12, 13, 14]. But most work assumes
that the user’s identity is not anonymous.
Kilian and Petrank [15] proposed a user identiﬁcation scheme
in which the system can authenticate a user’s identity with-
out knowing his identity. Their scheme has a third party
to generate a certiﬁcate for a user so that the user can use
the certiﬁcate to authenticate himself without revealing his
identity. In their scheme, it is hard to revoke a user’s cer-
tiﬁcate (membership). Thus, we need to employ another
delicate and time-consuming cryptographic scheme to ver-
ify the status of a certiﬁcate. The whole system becomes
very complicated.
Chaum [4] introduced the pseudonym system, in which a
user has a diﬀerent pseudonym for each organization. The
goal is to prevent organizations from inferring the user’s
information by combining their data of the user’s visiting
patterns. Chaum and Evertse [5] proposed a RSA-based
pseudonym system that is secure against cooperation of all
organizations. Lysanysanskaya, etc., proposed a pseudonym
system that discourages a user from sharing his master key
with other users. The master key is used to derive cer-
tiﬁcates for organizations. We can see that the goal of
pseudonym systems is diﬀerent from ours.
2. ENTITY SECURITYANDANONYMOUS
AUTHENTICATION
In the entity security model [18], user identiﬁcation, authen-
tication and authorization are three steps by which a sys-
tem provides services to a user. For user identiﬁcation, the
user sends his identity to the system and the system checks
whether the identity is legal for the system. For user au-
thentication, the system authenticates the user’s identity by
verifying whether the user possesses some secret informa-
tion (password, secret key, etc.) about the identity whom
the user claims to be. After authenticating the user’s iden-
tity, the system checks whether the user’s request is within
his access right. This is user authorization. After checking
authorization, the system processes the user’s legal requests.
1In the paper [22], the scheme is only proven to be secure
against the attacks from a single adversary. It is neither
claimed nor proven to be secure against the collusion attack
of multiple adversaries.
We can see that in the entity security model user identiﬁ-
cation is the main step that the system identiﬁes who the
user is. The system uses the user’s identity to retrieve the
user’s authentication and authorization data. Then, the sys-
tem uses the data to authenticate the user and authorizes
the user’s access right to resources. In some applications,
such as data retrieval from web sites, there may be only
one authorization level, that is, all users are allowed to use
all resources (ﬁles) of the system. In some other applica-
tions, there are multiple authorization levels. For example,
in a subscribed database system, each user may pay some
premium for accessing data of a speciﬁc category, such as
sports, business, etc. The system assigns the user to the
authorization level of the category which he pays for.
A straightforward solution for anonymous authentication is
to have a third party R to help. A user U registers his
identity α to R and gets a pseudo identity (pseudonym)
α [17]. R gives U ’s pseudo information to the system W
and hides U ’s real identity from W . Every time U visits the
system, he uses his pseudo identity α for authentication.
By this information, W authorizes U to access data in its
database. For the system to function properly, R need be
trusted by both the system and users. To implement an
appropriate R is not an easy task. Even though R is used,
the visiting pattern of α is exactly that of α. It can still be
used in some way. For example, it is possible to infer the
real identity α from the visiting pattern.
We solve the anonymous authentication problem by the cryp-
tographic techniques of public-key certiﬁcates and witness-
indistinguishable proof systems, which are shown in Sec-
tion 5.
3. PRELIMINARIES
Eﬃcient computation. By eﬃcient computation we mean
that the computing time is a polynomial function of the
input size. Note that the size of a number x is its bit length
log2 x+1. Modular multiplication and exponentiation are
eﬃciently computable.
Modular exponentiation over a composite number. Let p =
2p + 1 and q = 2q + 1 be two large primes, typically 512-
bit long, the composite number N = pq and the Euler’s
totient function φ(N) = (p − 1)(q − 1) = 4pq. We consider
the order-pq subgroup Gpq = {a4 mod n|a ∈ Z∗n} of Z∗n. We
say that g is a generator for Gpq if {gi|0 ≤ i ≤ pq − 1} =
Gpq. The modular exponentiation over N is to compute
xa mod N for given x, a and N . We can compute xa mod
N by the square-multiply method, which takes 1.5log2 a
modular multiplications in average. A modern computer
can easily aﬀord this computation.
Common modulus property. The common modulus prop-
erty is that given a, b, xa mod N and xb mod N , we can
compute xgcd (a,b) mod N as follows. We ﬁrst use the ex-
tended Euclidean algorithm to ﬁnd integers a and b such
that aa+ bb = gcd (a, b) and then compute
(xa mod N)a(xb mod N)b mod N
= xaa+bb mod N
= xgcd (a,b) mod N.
 
C2, . . ., C4 are base classes and the others are super classes.
The cover sets are E1 = {1}, E2={2}, E3 = {3}, E4 = {4},
E5={1, 2, 5}, E6 = {1, 3, 6}, E7 = {2, 3, 4, 7}, and E8 = {1,
2, 3, 4, 5, 6, 7, 8}. The class keys are
K1 = xe2e3e4e5e6e7e8 mod N, K2 = xe1e3e4e5e6e7e8 mod N,
K3 = xe1e2e4e5e6e7e8 mod N, K4 = xe1e2e3e5e6e7e8 mod N,
K5 = xe3e4e6e7e8 mod N, K6 = xe2e4e5e7e8 mod N,
K7 = xe1e5e6e8 mod N, K8 = x.
We see how to useK7 to deriveK3. Since E7−E3 = {2, 4, 7},
we have
K3 = Ke2e4e77 mod N = xe1e2e4e5e6e7e8 mod N.
Security. Given any set S of class keys, one cannot compute
the unauthorized class keys unless one can compute the eth
root modular a composite.
Theorem 4.1. [1] Given a set of class keys Ki1 , Ki2 , . . .,
Kit , one cannot compute the class key Kj of class Cj that is
not a descendent of any Cil , 1 ≤ l ≤ t, unless one can solve
the problem of computing the eth root modulo a composite
for some e ≥ 2.
4.2 New time-dependent hierarchical key as-
signment scheme
Let Ci, 1 ≤ i ≤ m, be the classes that are partially ordered.
Let time be divided into time periods 1, 2, . . . , z, where z
is the maximum time period. This maximum time period
should not be considered as limitation of the system. For
example, if each time period represents a week, z = 5200
denotes roughly 100 years. For a time-dependent hierarchi-
cal key assignment scheme, class Cj at time period t has
time-dependent class key Kj,t. We require that, given the
key trapdoor K[i,t1,t2], one can compute Kj,t if and only if
Cj ≤ Ci and t1 ≤ t ≤ t2. Furthermore, the size of K[i,t1,t2]
should be independent of the number of classes in the hier-
archy and the length of time periods.
Our construction revolutionizes the idea of Akl and Taylor’s
construction. We put all original classes of the hierarchy as
base classes Ci and add super classes C[i], 1 ≤ i ≤ m. Each
C[i] covers the base class set
{Cj |Cj ≤ Ci, 1 ≤ j ≤ m}.
Then, we assign class keys Kj to Cj , 1 ≤ j ≤ m, and trap-
doors K[i] to C[i] such that we can use trapdoor K[i] to
compute all class keys Kj if and only if Cj ≤ Ci. Now, the
security requirement of our scheme is diﬀerent from that of
Akl and Taylor’s. We only require that given any set of
key trapdoors K[i1,r1,s1], K[i2,r2,s2], . . ., K[il,rl,sl], one can-
not compute the class key Kj,t with Cj ≤ Cik , t < rk or
t > sk for all k, 1 ≤ k ≤ l.
Based on the above idea, our time-dependent hierarchical
key assignment scheme has mz base classes Cj,t, 1 ≤ j ≤
m, 1 ≤ t ≤ z, and mz(z + 1)/2 super classes C[i,t1,t2], 1 ≤
i ≤ z, 1 ≤ t1 ≤ t2 ≤ z. The base class Cj,t denote the class
Cj at time period t. Though we have total mz(z+1)/2+mz
classes, we use only mz exponents (e’s) for the scheme. The
key trapdoor K[i,t1,t2] corresponds to the time-dependent
class key of the super class C[i,t1,t2] that covers the base
classes Cj,t, for any Cj ≤ Ci and t1 ≤ t ≤ t2. We associate
each super class C[i,t1,t2] a cover set of base classes
E[i,t1,t2] = { (j, t) |Cj,t, Cj ≤ Ci, t1 ≤ t ≤ t2}.
The formal description is as follows.
1. System setup.
(a) Let N and Gpq be the ones deﬁned in Section 3.
(b) Let ej,t, 1 ≤ j ≤ m, 1 ≤ t ≤ z, be the ﬁrst mz
primes and
θ =
Y
1≤j≤m,1≤t≤z
ej,t.
(c) Choose a generator x ∈R Gpq.
2. Public parameters. (N, e1,1, . . . , em,z), Again, ei,t’s
need not be stored.
3. Time-dependent class key. The time-dependent
class key Kj,t of the base class Cj,t is
Kj,t = xθ/ej,t mod N.
4. Time-dependent key trapdoor. The key trapdoor
K[i,t1,t2] of the super class C[i,t1,t2], 1 ≤ i ≤ m, 1 ≤t1 ≤ t2 ≤ z, is
K[i,t1,t2] = xθ/(ej1,r1ej2,r2 ···ejl,rl ) mod N,
where E[i,t1,t2] = {(j1, r1), (j2, r2), . . . , (jl, rl)}.
5. Time-dependent key derivation. Given K[i,t1,t2]
of the super class C[i,t1,t2] and the public parameters,
we can compute Kj,t of the base class Cj,t if Cj ≤ Ci
and t1 ≤ t ≤ t2 as
Kj,t = (K[i,t1,t2])ej1,d1ej2,d2 ···ejs,ds mod N,
where E[i,t1,t2]−E[j,t,t]={(j1, d1), (j2, d2), . . ., (js, ds)}.
Security analysis. The security of this scheme is equiva-
lent to computing the eth roots modulo a composite.
Theorem 4.2. Given any set of key trapdoors K[i1,r1,s1],
K[i2,r2,s2], . . ., K[il,rl,sl], one cannot compute the class key
Kj,t with Cj ≤ Cik , t < rk or t > sk for all k, 1 ≤ k ≤ l,
unless one can solve the problem of computing the eth roots
modulo a composite for some e ≥ 2.
Proof. Let
E = E[i1,r1,s1] ∪ E[i2,r2,s2] ∪ · · · ∪ E[il,rl,sl].
Since Cj,t cannot be computed from any C[ik,rk,sk], 1 ≤
k ≤ l, we have (j, t) /∈ E. The key trapdoor K[ik,rk,sk]
has the form xvkej,t mod N for some vk. By the common
modulus property, one can compute xej,t·gcd (v1,...,vl) mod
N . However, the class key Kj,t has the form xb mod N for
some b with gcd(b, ej,t) = 1. To compute Kj,t from the
given key trapdoors, one has to remove the power of ej,t
 
Theorem 5.2 (Anonymity). The system serverW can
not know U ’s identity even if its computing power is unlim-
ited.
Proof. Assume that Uj has the certiﬁcate (αj , vj , sj)
and Uj has the certiﬁcate (αj , vj , sj). We show that the
distribution of the exchanged messages between Uj and W
is the same as that between Uj and W , j = j.
For the distribution of the exchanged message between Uj
and W , since wi, 1 ≤ i ≤ n, are randomly chosen over
Zp−1, ai’s are totally independent and each is uniformly
distributed over Z∗p . The values ci’s are of (n − 1)-degree
freedom under the constraint c = c1+c2+· · ·+cn mod p− 1,
where c is selected randomly by W . The value ri is totally
dependent on ai and ci, 1 ≤ i ≤ n. This argument is the
same for the distribution of the exchanged messages between
Uj and W . Since the two distributions are the same, W
cannot distinguish whom interacts with it. Therefore, user’s
identity is unknown to W even if W ’s computing power is
unlimited.
6. DATA ACCESS SYSTEM
Figure 2 shows a conventional model for data retrieval from
a web site with authentication, authorization and commu-
nication security. U ﬁrst sends his identity α to W . W
gets the authentication data of α and authenticates α by an
authentication protocol. If U passes the authentication, W
and U execute a key-exchange protocol to establish a com-
munication session key k. U then sends his data retrieval
command ω to W . W checks whether ω is authorized. If it
is so,W retrieves data D from its database system, encrypts
D with k as C = E(k,D), and sends the encrypted data C
to U , where E is a symmetric encryption method, such as
DES. Finally, U uses k to decrypt C to get D. Since W
knows α, U is not anonymous to W .
For secure communication,W has to encrypt dataD on-line.
If there are requests for retrieving data in a short period of
time, the on-line computation load of W would be heavy so
that the system performance is lowered.
Figure 3 shows our proposed model for data retrieval from
a web site. The data in the database of the web site is
encrypted with the class keys of the time-dependent hier-
archical key assignment scheme. The system authenticates
a user’s identity anonymously by an anonymous authenti-
cation scheme. The authorization is controlled by the key
trapdoor that a user possesses. In this model, on-line en-
cryption of communication is not necessary.
6.1 The system
W sets a partially ordered hierarchy with classes Ci, 1 ≤ i ≤
m, and assigns time-dependent class keys Ci,t, as described
in Section 4.2. W also chooses an anonymous authentica-
tion scheme, as described in Section 5. W can perform the
following operations.
1. Storing new data. When W decides to assign the
new data D to class Ci at time t, it uses the time-
dependent class key Ki,t to encrypt D as E(Ki,t, D)
and put it into the database of the web site.
2. User registration. When a new user U registers to
the system, W veriﬁes its identity and then issues a
certiﬁcate (α, v, s) to U . W adds U ’s authentication
key (α, v) into the authentication list L. Then, W
decides which class U should be in, say Ci, and what
data are authorized to U , say between time periods t1
and t2. W issues the key trapdoor K[i,t1,t2] to U .
3. Membership revocation. WhenW need revoke U ’s
membership, it simply removes U ’s authentication key
from its authentication list L. Thus, U can no longer
pass anonymous authentication with W .
4. Anonymous authentication. When U need retrieve
data from the system,W performs anonymous authen-
tication with U . If U passes the anonymous authenti-
cation, W starts to process the command.
5. Command processing. After passing anonymous
authentication, U sends a data retrieval command ω
to W . W simply sends the command to the database
system for processing. Suppose that the database sys-
tem returns data Dj,t = E(Kj,t, D). W sends Dj,t to
U . If U has the appropriate key trapdoor K[i,t1,t2],
he can decrypt Dj,t to obtain D. Otherwise, U is not
authorized to obtain D.
6.2 The user
After registering toW , U has two private parameters. One is
the certiﬁcate (α, v, s) for anonymous authentication and the
other is the key trapdoor K[i,t1,t2] for decrypting authorized
data. A user U can perform the following operations.
1. Anonymous authentication. When U need retrieve
data from the system, he uses his certiﬁcate (α, v, s)
to execute the anonymous authentication scheme with
W . If U passes the authentication, he sends his request
command to W .
2. Data decryption. Assume that Dj,t is returned by
W . If the requested data is authorized, that is, Cj ≤
Ci and t1 ≤ t ≤ t2, U uses his key trapdoor K[i,t1,t2] to
derive the time-dependent class key Kj,t. U decrypts
Dj,t with key Kj,t to obtain D.
6.3 A subscription system
W can establish a ﬂexible subscription system by the time-
dependent hierarchical key assignment scheme. W classiﬁes
data into classes by various criteria, such as, categories, sen-
sitivity, etc. We assume that the higher the class is, the more
valuable the data in the class is. Each data is also tagged
with time t. For example, a news is tagged with the time
period it was reported. Then, the data D classiﬁed into class
Ci of time period t is encrypted with key Ki,t and stored
into the database.
W places a price tag for class Ci and time periods [t1, t2]. If
a user U pays for the data in class Ci between time periods
t1 and t2, W gives him the key trapdoor K[i,t1,t2] so that he
can decrypt the authorized data.
The above subscription system has some distinct features.
Firstly, W can put its database on mirror sites for better
0 
[1] S.G. Akl and P.D. Taylor. Cryptographic solution to a
problem of access control in a hierarchy. ACM
Transactions on Computer Systems 1(3), pp.239-248,
1983.
[2] D. Boneh,M. Franklin. Anonymous authentication
with subset queries. In Proceedings of The 6th ACM
Conference on Computer and Communications
Security, ACM Press, 1999.
[3] C.C. Chang, R.J. Hwang, and T.C. Wu.
Cryptographic key assignment scheme for access
control in a hierarchy. Information Systems 17(3),
pp.243-247, 1992.
[4] D. Chaum. Security without identiﬁcation:
transaction systems to make big brother obsolete.
Communications of the ACM 28(10), pp.1030-1044,
1985.
[5] D. Chaum, J.-H. Evertse. A secure and
privacy-protecting protocol for transmitting personal
information between orgainzation. In Proceedings of
Advances in Cryptology - Crypto 86, Lecture Notes in
Computer Science 263, pp.118-167, 1986.
[6] D.E. Denning, D.K. Branstad. A taxonomy for key
escrow encryption systems. Communications of the
ACM 39(3), pp.34-40, 1996.
[7] U. Feige, A. Shamir. Witness indistinguishable and
witness hiding protocols. In Proceedings of The 22nd
ACM Symposium on Theory of Computing,
pp.416-426, ACM Press, 1990.
[8] W. Ford. Computer Communications Security:
Principles, Standard Protocols and Techniques.
Prentice Hall, Englewood Cliﬀs, New Jersey, 1994.
[9] L. Harn and H.Y. Lin. A cryptographic key generation
scheme for multilevel data security. Computers &
Security 9(6), pp.539–546, 1990.
[10] ISO/IEC 9798-1. Information technology - Security
techniques - Entity authentication mechanisms - Part
1: General model. ISO, Geneva, Switzerland, 1991
(ﬁrst edition).
[11] ISO/IEC 9798-2. Information technology - Security
techniques - Entity authentication - Part 2:
Mechanisms using symmetric encipherment
algorithms. ISO, Geneva, Switzerland, 1994 (ﬁrst
edition).
[12] ISO/IEC 9798-3. Information technology - Security
techniques - Entity authentication mechanisms - Part
3: Entity authentication using a public-key algorithm.
ISO, Geneva, Switzerland, 1993 (ﬁrst edition).
[13] ISO/IEC 9798-4. Information technology - Security
techniques - Entity authentication - Part 4:
Mechanisms using a cryptographic check function.
ISO, Geneva, Switzerland, 1995 (ﬁrst edition).
[14] ISO/IEC 9798-5. Information technology - Security
techniques - Entity authentication - Part 5:
Mechanisms using zero knowledge techniques. ISO,
Geneva, Switzerland, 1996 (draft).
[15] J. Kilian, E. Petrank. Identity escrow. In Proceedings
of Advances in Cryptology - Crypto 98, Lecture Notes
in Computer Science 1462, pp.169-185,
Springer-Verlag, 1998.
[16] S.J. Mackinnon, P.D. Taylor, H. Meijer, and S.G. Akl.
An optimal algorithm for assigning cryptographic keys
to control access in a hierarchy. IEEE Transactions on
Computers 34(9), pp.797-802, 1985.
[17] A. Lysyanskaya, R. Rivest, A. Sahai, S. Wolf.
Pseudonym systems. The 6th Annual Workshop on
Selected Areas in Cryptography, Lecture Notes in
Computer Science 1758, Springer-Verlag, 1999.
[18] S. Muftic. Security Mechanisms For Computer
Networks. Ellis Horwood, Chichester, England, 1989.
[19] R. Rivest, A. Shamir, L. Adleman. A method for
obtaining digital signatures and public-key
cryptosystems. Communications of the ACM 21(2),
pp.120-126, 1978.
[20] B. Schneier. Applied cryptography: protocol,
algorithms, and source code in C, 2nd Edition. John
Wiley & Sons, New York, 1996.
[21] W.-G. Tzeng. Common modulus and chosen message
attacks on public-key schemes with linear recurrence
relations. Information Processing Letters 70,
pp.153-156, 1999.
[22] W.-G. Tzeng. A time-bound cryptographic key
assignment scheme for access control in a hierarchy.
IEEE Transactions on Knowledge and Data
Engineering 14(1), pp.182-188, 2002.
[23] W.-G. Tzeng, C.-M. Hu. Inter-protocol interleaving
attacks on some authentication and key distribution
protocols. Information Processing Letters 69(6),
pp.297-302, 1999.
Public Key Broadcast Encryption with Low Number of Keys 381
broadcasted messages can be decrypted by authorized users only. Broadcast en-
cryption has many applications, such as pay-TV systems, encrypted ﬁle sharing
systems, digital right management, content protection of recordable data, etc.
A broadcasted message M is sent in the form 〈Hdr(S,m), Em(M)〉, where
m is a session key for encrypting M via a symmetric encryption method E. An
authorized user in S can use his private keys to decrypt the session key m from
Hdr(S,m). Since the size of Em(M) is pretty much the same for all broadcast
encryption schemes, we are concerned about the header size. The performance
measures of a broadcast encryption scheme are the header size, the number of
private keys held by each user, the size of public parameters of the system (public
keys), the time for encrypting a message, and the time for decrypting the header
by an authorized user. A broadcast encryption scheme should be able to resist
the collusion attack from revoked users. A scheme is fully collusion-resistant if
even all revoked users collude, they get no information about the broadcasted
message.
Broadcast encryption schemes can be stateless or stateful. For a stateful
broadcast encryption scheme, the private keys of a user can be updated from
time to time, while the private keys of a user in a stateless broadcast encryption
scheme remain the same through the lifetime of the system. Broadcast encryp-
tion schemes can also be public key or secret key. For a public key BE scheme,
any one (broadcaster) can broadcast a message to an arbitrary group of autho-
rized users by using the public parameters of the system, while for a secret key
broadcast encryption scheme, only the special dealer, who knows the system
secrets, can broadcast a message.
In this paper we refer ”stateless public key broadcast encryption” as ”public
key BE”.
1.1 Our Contribution
We propose three public key BE schemes that have eﬃcient complexity measures.
The ﬁrst scheme, called the BE-PI scheme (broadcast encryption with polyno-
mial interpolation), has O(r) header size, O(1) public keys, and O(logN) private
keys per user1, where r is the number of revoked users. This is the ﬁrst public
key BE scheme that has both public and private keys under O(logN) while the
header size is O(r). These complexity measures match those of eﬃcient secret
key BE schemes [11,20,21]. The idea is to run logN copies of the basic scheme
in [17,19,22] in parallel for lifting the restriction on a priori ﬁxed number of
revoked users. Nevertheless, if we implement the logN copies straightforwardly,
we would get a scheme of O(N) public keys. We are able to use the properties
of bilinear maps as well as special private key assignment to eliminate the need
of O(N) public keys and make it a constant number.
Our second scheme, called the PK-SD-PI scheme (public key SD broadcast en-
cryption with polynomial interpolation), is constructed by combining the polyno-
mial interpolation technique and the subset cover method in the SD scheme [16].
1 log is based on 2 if the base is not speciﬁed.
Public Key Broadcast Encryption with Low Number of Keys 383
polynomial interpolation (in fact, the Reed-Solomon code) to any linear code for
constructing public key BE schemes. The schemes in [7,13,14,17,19,22] all have
O(k) public keys, O(1) private keys, and O(r) header size, r ≤ k. However, k is
a-priori ﬁxed during the system setting and the public key size depends on it.
These schemes can withstand the collusion attack of up to k revoked users only.
They are not fully collusion-resistant.
Yoo, et al. [21] observed that the restriction of a pre-ﬁxed k can be lifted by
running logN copies of the basic scheme with diﬀerent degrees (from 20 to N) of
polynomials. They proposed a scheme of O(logN) private keys and O(r) header
size such that r is not restricted. However, their scheme is secret key and the
system has O(N) secret values. In the public key setting, the public key size is
O(N).
Recently Boneh, et al. [4] proposed a public key BE scheme that has O(1)
header size, O(1) private keys, and O(N) public keys. By trading oﬀ the header
size and public keys, they gave another scheme with O(
√
N) header size, O(1)
private keys and O(
√
N) public keys. Lee, et al. [15] proposed a better trade-oﬀ
by using receiver identiﬁers in the scheme. It achieves O(1) public key, O(logN)
private keys, but, O(r logN) header size. Boneh and Waters [5] proposed a
scheme that has the traitor tracing capability. This type of schemes [4,5,15]
has the disadvantage that the public keys are needed by a user in decrypting the
header. Thus, the de-facto private key of a user is the combination of the public
key and his private key.
It is possible to transform a secret key BE scheme into a public key one.
For example, Dodis and Fazio [6] transformed the SD and LSD schemes [12,16]
into public key SD and LSD schemes, shorted as PK-SD and PK-LSD. The
transformation employs the technique of hierarchical identity-based encryption
to substitute for the hash function. Instantiated with the newest constant-size
hierarchical identity-based encryption [2], the PK-SD scheme has O(r) header
size, O(1) public keys and O(log2 N) private keys. The PK-LSD scheme has
O(r/) header size, O(1) public keys and O(log1+ N) private keys, where 0 <
 < 1 is a constant. The decryption costs of the PK-SD and PK-LSD schemes
are both O(logN), which is the time for key derivation incurred by the original
relation of private keys. If we apply the HIBE technique to the secret key BE
schemes of O(logN) or O(1) private keys [1,11,20], we would get their public
key versions with O(N) private keys and O(N) decryption time.
2 Preliminaries
Bilinear map. We use the properties of bilinear maps. Let G and G1 be two
(multiplicative) cyclic groups of prime order q and eˆ be a bilinear map from
G × G to G1. Then, eˆ has the following properties.
1. For all u, v ∈ G and x, y ∈ Zq, eˆ(ux, vy) = eˆ(u, v)xy.
2. Let g be a generator of G, eˆ(g, g) = g1 = 1 is a generator of G1.
Public Key Broadcast Encryption with Low Number of Keys 385
In the above the adversary A is static since it chooses the target set S∗ of
users before the system setup. Let Advind-ccaA,Π (z) be the advantage that A wins
the above game, that is,
Advind-ccaA,Π (z) = 2 · Pr[AO(PK,SKU\S∗ ,m0,m1,Hdr(S∗,m)) = b :
S∗ ⊆ U , (PK,SKU) ← Setup(1z, Id,U),
Hdr(S∗,m) ← Enc∗(PK,S∗), b u← {0, 1}] − 1,
where SKU = {SKi : 1 ≤ i ≤ N} and SKU\S∗ = {SKi : Ui ∈ S∗}.
Deﬁnition 1. A public key BE scheme Π=(Setup, Enc, Dec) is (t, , qD)-IND-
CCA secure if for all t-time bounded adversary A that makes at most qD decryp-
tion queries, we have Advind-ccaA,Π (z) < .
In this paper we ﬁrst give schemes with one-way security against chosen plaintext
attacks (OW-CPA security) and then transform them to have IND-CCA security
via the Fujisaki-Okamoto transformation [9]. The OW-CPA security is deﬁned
as follows.
Init. The adversary A chooses a system identity Id and a target set S∗ ⊆ U
of users to attack.
Setup. The challenger C runs Setup(1z, Id, U) to generate a public key PK
and private key sets SK1, SK2, . . . , SKN . The challenger C gives SKi to A,
where Ui ∈ S∗.
Challenge. The challenger C runs Enc∗(PK,S∗) and outputs Hdr(S∗, m),
where m is randomly chosen.
Guess. A outputs a guess m′ for m.
Since A can always encrypt a chosen plaintext by himself, the oracle of en-
crypting a chosen plaintext does not matter in the deﬁnition. Let Advow-cpaA,Π (z)
be the advantage that A wins the above game, that is,
Advow-cpaA,Π (z) = Pr[A(PK,SKU\S∗,Hdr(S∗,m)) = m : S∗ ⊆ U ,
(PK,SKU) ← Setup(1z, Id,U),Hdr(S∗,m) ← Enc∗(PK,S∗)].
Deﬁnition 2. A public key BE scheme Π=(Setup, Enc, Dec) is (t, )-OW-CPA
secure if for all t-time bounded adversary A, we have Advow-cpaA,Π (z) < .
3 The BE-PI Scheme
Let G and G1 be the bilinear groups with the pairing function eˆ, where q is
a large prime. Let H1, H2 : {0, 1}∗ → G1 be two hash functions and E be a
symmetric encryption with key space G1.
The idea of our construction is as follows. For a polynomial f(x) of degree
t, we assign each user Ui a share f(i). The secret is f(0). We can compute the
secret f(0) from any t+1 shares. If we want to revoke t users, we broadcast their
Public Key Broadcast Encryption with Low Number of Keys 387
3. Dec(SKk,Hdr(S,m), C): Uk ∈ S. The user Uk does the following.
– Compute b0 = eˆ(gr, grk,αfα(k)) = g
rrk,αfα(k)
1 .
– Compute bj = eˆ(grk,α , grfα(ij)) = g
rrk,αfα(ij)
1 , 1 ≤ j ≤ L.
– Use the Lagrange interpolation method to compute
g
rrk,αfα(0)
1 =
L∏
j=0
b
λj
j , (1)
where λj =
(−i0)(−i1)···(−ij−1)(−ij+1)···(−iL)
(ij−i0)(ij−i1)···(ij−ij−1)(ij−ij+1)···(ij−iL) (mod q), i0 = k.
– Compute the session key
meˆ(gρ, hα)r · grrk,αfα(0)1
eˆ(gr, grk,αfα(0)hρα)
=
meˆ(gρ, hα)r · grrk,αfα(0)1
eˆ(gr, hρα) · grrk,αfα(0)1
= m. (2)
– Use m to decrypt the ciphertext body C to obtain the message M .
Correctness. We can easily see that the scheme is correct by Equation (2).
3.1 Performance Analysis
For each system, the public key is (Id, H1, H2, E,G,G1, eˆ, g, gρ), which is of
size O(1). Since all systems can use the same (H,E,G,G1, eˆ, g), the public key
speciﬁc to a system is simply (Id, gρ). Each system dealer has a secret ρ for
assigning private keys to its users. Each user Uk holds private keys SKk =
{sk,0, sk,1, . . . , sk,log N}, each corresponding to a share of polynomial fi in the
masked form, 0 ≤ i ≤ logN . The number of private keys is O(logN). When r
users are revoked, we choose the polynomial fα of degree 2α for encrypting the
session key, where 2α−1 < r ≤ 2α. Thus, the header size is O(2α) = O(r). It is
actually no more than 2r.
To prepare a header, the broadcaster needs to compute one pairing function,
2α+2 hash functions, and 2α+2 modular exponentiations, which is O(r) modular
exponentiations.
For a user in S to decrypt a header, with a little re-arrangement of Equation
(1) as
L∏
j=0
b
λj
j = b
λ0
0 · eˆ(grk,α ,
L∏
j=1
(grfα(ij))λj ),
the user needs to perform 3 pairing functions and 2α modular exponentiations,
which is O(r) modular exponentiations. The evaluation of λj ’s can be done in
O(L) = O(2r) if the header consists of
λ˜j =
(−i1) · · · (−ij−1)(−ij+1) · · · (−iL)
(ij − i1) · · · (ij − ij−1)(ij − ij+1) · · · (ij − iL) mod q, 1 ≤ j ≤ L.
The user can easily compute λj ’s from λ˜j ’s. Inclusion of λ˜j ’s in the header does
not aﬀect the order of the header size.
Public Key Broadcast Encryption with Low Number of Keys 389
If the query has ever been asked, we return the stored hash value for the query.
For other non-queried inputs, we return random values in G.
We should check whether the distributions of the parameters in our reduction
and those in the system are equal. We only check those related to α since the
others are correctly distributed. Since τ, w1, w2, . . . , wL are randomly chosen,
ga
(α)
i , 0 ≤ i ≤ L are uniformly distributed over GL+1. Due to the random oracle
model, their corresponding system parameters are also uniformly distributed
over GL+1. Since κ, μ1, μ2, . . . , μL are randomly chosen, the distribution of hα
and gri,α , 1 ≤ i ≤ L, are uniform over GL+1, which is again the same as that
of the corresponding system parameters. The distributions of gr in the header
and gρ in the public key are both uniform over G since they are set from the
given input gc and ga, respectively. Since the session key m is chosen randomly
from G1, meˆ(gρ, hα)r is distributed uniformly over G1. We set it to a random
value y ∈ G1. Even though we don’t know about m, it does not aﬀect the
reduction. Other parameters are dependent on what have been discussed. We
can check that they are all computed correctly. So, the reduction preserves the
right distribution.
If the revoked users compute m from the header with probability , we can
solve the BDH problem with the same probability 1 =  by computing the
following:
y · m−1 · eˆ(ga, gc)−κ = eˆ(gρ, hα)r · eˆ(g, g)−acκ
= eˆ(ga, gb+κ)c · eˆ(g, g)−acκ
= eˆ(g, g)abc. (3)
Let t′ be the time for this reduction and the solution computation in Equation
(3). We can see that t′ is polynomially bounded. Thus, if the collusion attack of the
revoked users takes t1 − t′ time, we can solve the BDH problem within time t1.
4 The BE-PI Scheme with IND-CCA Security
In Theorem 1, we show that the session key in the header is one-way secure
against any collusion of revoked users. There are some standard techniques of
transforming OW-CPA security to IND-CCA security. Here we present such a
scheme Π ′ based on the technique in [9].
The IND-CCA security of the Fujisaki-Okamoto transformation depends only
on the OW-CPA security of the public key encryption scheme, the FG security
of a symmetric encryption scheme E , and the γ-uniformity of the public key
encryption scheme. The FG-security is the counterpart of the IND-security for
symmetric encryption. A public key encryption scheme is γ-uniform if for every
key pair (pk, sk), every message x, and y ∈ {0, 1}∗, Pr[Epk(x) = y] ≤ γ. Before
applying the transformation, we check the following things:
1. The transformation applies to public key encryption, while ours is public key
broadcast encryption. Nevertheless, if the authorized set S is ﬁxed, our public
Public Key Broadcast Encryption with Low Number of Keys 391
the subsets in C, that is, S = ∪wi=1Sw, where Si ∈ C are disjoint, 1 ≤ i ≤ w. Each
subset Si in C is associated with a private key ki. A user is assigned a set of keys
such that he can derive the private keys of the subsets to which he belongs. The
subset keys ki cannot be independent. Otherwise, each user may hold too many
keys. It is preferable that the subset keys have some relations, for example, one
can be derived from another. Thus, each user Uk is given a set SKk of keys so
that he can derive the private key of a subset to which he belongs. A subset-cover
based broadcast encryption scheme plays the art of choosing a collection C of
subsets, assigning subset and user keys, and ﬁnding subset covers.
5.1 The PK-SD-PI Scheme
We now present our PK-SD-PI scheme, which is constructed by using the poly-
nomial interpolation technique on the collection of subsets in [16]. The system
setup is similar to that of the BE-PI scheme. Consider a complete binary tree T
of logN + 1 levels. The nodes in T are numbered diﬀerently. Each user in U is
associated with a diﬀerent leaf node in T . We refer to a complete subtree rooted
at node i as ”subtree Ti”. For each subtree Ti of η levels (level 1 to level η from
top to bottom), we deﬁne the degree-1 polynomials
f
(i)
j (x) = a
(i)
j,1x + a
(i)
j,0 (mod q),
where a(i)j,0 = lgH2(Id‖i‖j‖0) and a(i)j,1 = lgH2(Id‖i‖j‖1), 2 ≤ j ≤ η. For a user
Uk in the subtree Ti of η levels, he is given the private keys
sk,i,j = (grk,i,j , grk,i,jf
(i)
j (ij), grk,i,jf
(i)
j (0)hρ)
for 2 ≤ j ≤ η, where nodes i1, i2, . . . , iη are the nodes in the path from node i
to the leaf node for Uk (including both ends). We can read sk,i,j as the private
key of Uk for the jth level of subtree Ti. In Figure 1, the private keys (in the
unmasked form) of U1 and U3 for subtree Ti with η = 4 are given. Here, we use
hρ in all private keys in order to save space in the header.
Recall that in the SD scheme, the collection C of subsets is
{Si,t : node i is a parent of node t, i = t},
where Si,t denotes the set of users in subtree Ti, but not in subtree Tt. By our
design, if the header contains a masked share for f (i)j (t), where node t is in the
j-th level of subtree Ti, only user Uk in Si,t can decrypt the header by using his
private key sk,i,j , that is, the masked form of f
(i)
j (s), for some s = t. In Figure 1,
the share f (i)3 (t) is broadcasted so that only the users in Si,t can decrypt the
header.
For a set R of revoked users, let Si1,t1 , Si2,t2 , . . ., Siz ,tz be a subset cover for
U\R, the header is
(meˆ(gρ, h)r, gr, (i1, t1, g
rf
(i1)
j1
(t1)), . . . , (iz, tz, grf
(iz)
jz
(tz))),
where node tk is in the jk-th level of subtree Tik , 1 ≤ k ≤ z.
Public Key Broadcast Encryption with Low Number of Keys 393
and H2, all polynomials are independent. Thus, we can simply consider a partic-
ular Sα,t in the subset cover for S∗ = U\R, where t is at level β of subtree Tα.
The corresponding polynomial is f(x) = f (α)β (x) = a1x + a0 (mod q). Wlog, let
{U1, U2, . . . , Ul} be the set of revoked users that have the secret share about f(t).
The reduction to the BDH problem is as follows. Recall that the public key of the
PK-SD-PI method is (Id, H1, H2, E,G,G1, eˆ, g, gρ).
1. Let g be the generator in the system and gρ = ga.
2. Set f(t) = w and compute gf(t) = gw, where w is randomly chosen from Zq.
3. Let ga0 = gf(0) = ga · gτ , where τ is randomly chosen from Zq.
4. Compute ga1 from gf(t) and ga0 via the Lagrange interpolation.
5. The (random) hash values H2(Id‖α‖β‖0) and H2(Id‖α‖β‖1) are set as ga0
and ga1 respectively.
6. Set h = gb · gκ, where κ is randomly chosen from Zq.
7. The f(x)-related secret share of Ui, 1 ≤ i ≤ l, is computed as (gri , grif(t),
grif(0)hρ), where gri = g−b · gμi and μi is randomly chosen from Zq. Note
that grif(0)hρ = ga(μi+κ)−bτ+μiτ can be computed from the setting in the
previous steps.
8. The non-f(x)-related secret shares of Ui, 1 ≤ i ≤ l, can be set as follows.
Let f ′ be a polynomial related to subtree α′ and level β′, where t′ is in the
β′-th level and Ui ∈ Sα′,t′ . The secret share (gr′i , gr′if ′(t′), gr′if ′(0)hρ) of Ui is
computed from (gri , grif(t), grif(0)hρ). Let f ′(t′) = w′, f ′(0) = f(0)+ a′ and
r′i = ri + r
′, where w′, a′, and r′ are randomly chosen from Zq. Thus, gr
′
i =
gri ·gr′ , gr′if ′(t′) = (gr′i)w′ and gr′if ′(0)hρ = (grif(0)hρ)·gr′f(0)·gria′ ·gr′a′ . Note
that the hash values H2(Id‖α′‖β′‖0) and H2(Id‖α′‖β′‖1) can be answered
accordingly.
9. Set the challenge as
(y, gc, (i1, t1, g
cf
(i1)
j1
(t1)), (i2, t2, g
cf
(i2)
j2
(t2)), . . . , (iz, tz, gcf
(iz)
jz
(tz))),
where y is randomly chosen from G and thought as meˆ(gρ, h)c. Note that
g
cf
(ik)
jk
(tk), 1 ≤ k ≤ z, can be computed since f (ik)jk (tk) is a number randomly
chosen from Zq, as described in Step 2.
If the revoked users U1, U2, . . . , Ul can together compute the session key m
from the challenge with probability 1, we can compute
y · m−1 · eˆ(ga, gc)−κ = eˆ(gρ, h)c · eˆ(g, g)−acκ
= eˆ(ga, gb+κ)c · eˆ(g, g)−acκ = eˆ(g, g)abc (4)
with the same probability 1. This contradicts the BDH assumption.
Let t′ be the time for the reduction and solution computation in Equation
(4), where t′ is polynomially bounded. Thus, if the collusion attack takes t1 − t′,
we can solve the BDH problem in time t1.
Similarly, we can modify our PK-SD-PI scheme to have IND-CCA security like
Section 4
Public Key Broadcast Encryption with Low Number of Keys 395
With the same extension in [12], we can have a PK-LSD-PI scheme that
has O(1) public keys and O(log1+) private keys, for any constant 0 <  < 1.
The header size is O(r/), which is O(r) for a constant . The decryption cost
excluding the time of scanning the header is again O(1).
6 Conclusion
We have presented very eﬃcient public key BE schemes. They have low public
and private keys. Two of them even have a constant decryption time. Our results
show that the eﬃciency of public key BE schemes is comparable to that of
private-key BE schemes.
We are interested in reducing the ciphertext size while keeping other com-
plexities low in the future.
Acknowledgement
We thankEikeKiltz andMichelAbdalla for valuable comments on themanuscript.
References
1. Attrapadung, N., Imai, H.: Graph-decomposition-based frameworks for subset-
cover broadcast encryption and eﬃcient instantiations. In: Roy, B. (ed.) ASI-
ACRYPT 2005. LNCS, vol. 3788, pp. 100–120. Springer, Heidelberg (2005)
2. Boneh, D., Boyen, X., Goh, E.-J.: Hierarchical identity based encryption with
constant size ciphertext. In: Cramer, R.J.F. (ed.) EUROCRYPT 2005. LNCS,
vol. 3494, pp. 440–456. Springer, Heidelberg (2005)
3. Boneh, D., Franklin, M.: An eﬃcient public key traitor tracing scheme. In: Wiener,
M.J. (ed.) CRYPTO 1999. LNCS, vol. 1666, pp. 338–353. Springer, Heidelberg
(1999)
4. Boneh, D., Gentry, C., Waters, B.: Collusion resistant broadcast encryption with
short ciphertexts and private keys. In: Shoup, V. (ed.) CRYPTO 2005. LNCS,
vol. 3621, pp. 258–275. Springer, Heidelberg (2005)
5. Boneh, D., Waters, B.: A fully collusion resistant broadcast, trace, and revoke
system. In: Proceedings of the ACM Conference on Computer and Communications
Security - CCS 2006, pp. 211–220. ACM Press, New York (2006)
6. Dodis, Y., Fazio, N.: Public key broadcast encryption for stateless receivers. In:
Feigenbaum, J. (ed.) DRM 2002. LNCS, vol. 2696, pp. 61–80. Springer, Heidelberg
(2003)
7. Dodis, Y., Fazio, N.: Public key broadcast encryption secure against adaptive cho-
sen ciphertext attack. In: Desmedt, Y.G. (ed.) PKC 2003. LNCS, vol. 2567, pp.
100–115. Springer, Heidelberg (2002)
8. Fiat, A., Naor, M.: Broadcast encryption. In: Stinson, D.R. (ed.) CRYPTO 1993.
LNCS, vol. 773, pp. 480–491. Springer, Heidelberg (1994)
9. Fujisaki, E., Okamoto, T.: Secure integration of asymmetric and symmetric en-
cryption schemes. In: Wiener, M.J. (ed.) CRYPTO 1999. LNCS, vol. 1666, pp.
537–554. Springer, Heidelberg (1999)
1 
 
出席 2008 公開金鑰密碼會議 (PKC 2008) 報告 
一、 時間與地點：3/9 - 3/12, 2008，巴塞隆納 西班牙。 
二、 參加會議經過 
第十一屆公開金鑰密碼會議（11th International Workshop on Practice and 
Theory in Public Key Cryptography，簡稱為 PKC 2008）為國際密碼研究學會
（International Association for Cryptologic Research，簡稱為 IACR)主辦，今年的
承辦單位為西班牙巴塞隆納市的 Universitat Politenica de Catalunya (UPC)。會議
在 UPC 的北校園舉行，與會人數約 100 人，其中來自台灣的與會者只有筆者一
人。會議為期四天（3/9~3/12），會議中安排了三場邀請演講，每天一場，相當精
采，其餘皆是論文發表，3/10 下午有一參觀古修道院的活動。整體來說，這次的
會議因為在學校內舉辦，較為簡單，但會場內討論的氣氛卻很熱烈，大家的發問
都很踴躍，休息時間也可看到許多相互交流與討論。 
三、 發表論文介紹 
我們這次所發表的論文為 ”Public Key Encryption Schemes with Low Number 
of Keys and Constant Decryption Time”，主要是公開金鑰廣播加密的問題，廣播
加密分為私密金鑰式的和公開金鑰式的，差別在於第三者是否可以廣播訊息給使
用者。已往對於私密金鑰式廣播加密系統的問題已提出最佳解，因此研究轉到公
開金鑰式的系統，先前的研究對於一些效率參數還無法達到很好，本篇論文提出
第一個公開金鑰式廣播加密系統，具有 O (1)公開金鑰、每位使用者 O(log N) 私
密金鑰及 O (r) 密文大小。其中還有一個系統的解密時間是 O(1)。這些系統是目
前最好的公開金鑰式廣播加密協定。在我報告完後，與會的學者表達了高度的興
趣，認為使用多項式在這樣的系統上，用得很巧妙，再加上雙線性函數與雜湊函
數的使用，實在是一個很不錯的創新。 
詳細的內容請見論文。 
四、 與會心得 
本次會議共有 71 篇論文送審，最後有 21 篇論文發表，每篇發表的時間為
30 分鐘，分為 8 個不同的主題： 
1. Algebraic and Number Theoretical Cryptanalysis (I) 
2. Theory of Public Key Encryption 
3. Digital Signatures (I) 
4. Identification, Broadcast and Key Agreement 
5. Implementation of Fast Arithmetic 
