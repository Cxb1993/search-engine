1行政院國家科學委員會專題研究計畫成果報告
無線感測網路之輕量式動態目標物追蹤定位與可調式全域性防禦部
署方法製作
計畫編號：NSC 97-2221-E-031-001
執行期限：97 年 8 月 1 日至 98 年 7 月 31 日
主持人：郭育政 東吳大學資訊管理系副教授
計畫參與人員：林士傑、謝承位、梁峻齊、陳建良 東吳大學資訊管理系
一、中文摘要
本計畫將建立適合移動目標物之
動態追蹤的感測網路系統。本計畫第
一個目標是設計對移動目標物動態追
蹤之輕量化路由，建立一個快速的反
應路由，並對目標物所在的實體位置
進行定位，以利資料收集點對目標物
的即時追蹤。本計畫第二個目標則是
探討節點間，部署位置的動態調整，
尤其是當感測網路中的節點，可能因
電力失效或故障，而造成防禦上的漏
洞，如何動態調整節點間的位置，達
成全域性的防禦，以提高目標物追蹤
的精準度。
關鍵詞：無線感測網路、動態追蹤、
移動目標物、節點定位、節點部
署、省電性群體通訊
Abstract
In the first goal of this project, we
propose a lightweight routing algorithm
for the mobile target detection. We use
the information of the last routing path
to guide the way to construct the new
routing path. Besides, we propose a
location discovery algorithm to find the
real location of the mobile target such
that the sink node could find a shortest
path to the target and hunt the target. In
the second goal of this project, we
propose a sensor deployment algorithm.
Adjusting the sensor deployment such
that the whole sensor field is a full
coverage by sensors even some sensor
nodes in the network fail.
Keywords：Wireless sensor networks,
target tracing, mobile target, location
discovery, sensor deployment,
power-saving multicast protocol
二、計畫的緣由與目的
隨著無線區域網路技術的進步，
許多關於無線區域網路的應用也越來
越普及。尤其是 IEEE 802.15.1/藍芽
（Bluetooth）、 IEEE 802.15.4/ZigBee
等無線通訊標準的提出與發展，讓無
線網路裝置能在不具基礎架構的
(uninfrastructure)環境下，隨意連結形
成無基礎架構下的隨意網路(Ad Hoc
Wireless Network) ，因此以無基礎架
構的隨意網路為主要應用的無線感測
網路(Wireless Sensor Network, WSN)
成為近年來被熱烈討論的研究課題。
無線感測網路的環境是對於一個待感
測區域內，分佈有高密度之感測節點
以監控此環境，每個節點均由低耗
電、無線傳輸並具有感測裝置所組
成，並依照其特定需求偵測該區域之
相關數據(如溫度、溼度、壓力等)，經
由無線傳輸技術，建立一個感測網路
路由，將資料匯集至一個特定收集
3由重建的成本，無法快速反應出目標
物目前的現況。因此當目標物移動超
出原感測節點的偵測範圍時，若可透
過適當的機制，進行適當的導引，善
用原先已建立的路由，將可節省重建
路徑的時間與成本，快速地反應出目
標物的現況，進而進行即時性的動態
追縱。
本計畫將建立適合移動目標物之
動態追蹤的感測網路系統。本計畫第
一個目標是設計對移動目標物動態追
蹤之輕量化路由，建立一個快速的反
應路由，並對目標物所在的實體位置
進行定位，以利資料收集點對目標物
的即時追蹤。本計畫第二個目標則是
探討節點間，部署位置的動態調整，
尤其是當感測網路中的節點，可能因
電力失效或故障，而造成防禦上的漏
洞，如何動態調整節點間的位置，達
成全域性的防禦，以提高目標物追蹤
的精準度。
三、研究的方法與成果
過去，在感測網路資料收集的路
由方法中，每個感測節點大都各自獨
立以廣播方式建立自己到收集點的路
由，無法有效率地共享彼此所建立的
路由資訊。因此即便事件的發生常有
其地緣性，即事件發生區域的鄰近節
點，都可能會偵測到此事件，但由於
建立路由時，無法經由適當地導引，
共享彼此所建立的路由資訊，因此仍
將各自獨立建立自己到收集點的路
由。此路由方法在目標物固定不動
時，其建立或重建路由的需求不大，
因此路由的建置成本不大。但若要對
移動目標物進行動態追蹤時，即感測
的目標物與資料收集點將進行動態的
移動，則原有的路由路徑將會因為目
標物移出原感測節點的偵測範圍，造
成路徑斷裂，而需重建新的路由，此
時資料收集點也可能會隨著目標物移
動而進行追蹤移動，離開原來的位
置，因而加重了路由重建的成本，無
法快速反應出目標物目前的現況。因
此當目標物移動超出原感測節點的偵
測範圍時，若可透過適當的機制，進
行適當的導引，善用原先已建立的路
由，將可節省重建路徑的時間與成
本，快速地反應出目標物的現況，進
而進行即時性的動態追縱。
本計畫將建立適合移動目標物之
動態追蹤的感測網路系統。本計畫第
一個目標是設計對移動目標物動態追
蹤之輕量化路由，建立一個快速的反
應路由，並對目標物所在的實體位置
進行定位，以利資料收集點對目標物
的即時追蹤。本計畫第二個目標則是
探討節點間，部署位置的動態調整，
尤其是當感測網路中的節點，可能因
電力失效或故障，而造成防禦上的漏
洞，如何動態調整節點間的位置，達
成全域性的防禦，以提高目標物追蹤
的精準度。
【計畫第一個目標: 對移動目標物偵
測追蹤與定位之輕量化路由方法】
本計畫第一個目標是設計對移動
目標物動態追蹤之輕量化路由，建立
一個快速的反應路由，並對目標物所
在的實體位置進行定位，以利資料收
集點對目標物的即時追蹤。
(1) 對移動目標物動態偵測與追蹤
在感測網路中由於目標物移動或
因收集點追蹤移動時，將造成既有路
徑斷裂，因此我們將設計了輕量式路
由方法，在節點傳送資料時，可自動
5(II) 資料傳送路徑
在 AODV 機制中，節點會定期發
送招呼訊息(Hello message)，以確認鄰
點是否存在，由於 Hello 封包其實是有
限制(TTL 為 1)的 RREP 封包，為使所
有的節點皆可獲得資料傳送路徑，我
們於 Hello 封包擴增了來源 IP 位置及
Hop count 的欄位，記錄共用傳輸路由
資訊，以作為各節點資訊交換的訊
息。當節點向鄰點定期發送 Hello 訊息
時，收到鄰點回覆訊息，採用 Hop count
最小值進行更新路由資訊，所有節點
經過數個週期後，就會以擴散方式，
讓所節點皆具備有主要路由之路徑資
訊，如圖 3-3 所示，各節點透過 Hello
封包資訊的交換，將共用路由資訊以
擴散方式達到漸層效果，未來有資料
傳送需求之節點，皆可透過此 Hop
count 數遞減的節點將封包送回原路
由。
如圖 3-4 所示，節點上之數字代表
距離共用路由之距離，當目標物移動
至 A 點時，感測節點偵測到移動目標
物，擬將資料送回收集點，首先感測
點查詢本身路由資訊，以單播方式
（unicast）將資料送給鄰點中最小 Hop
count 的節點，逐步以此方式，將可以
最短路徑方式回到所建立之共同路
徑，未來當目標物移動至 B 點超出該
感測節點時，新感測節點無需重建路
由，以相同方法將資料朝共同傳輸路
由傳送，而達到部分路徑共用之目
的。初期若擴散速度未能及時更新部
分節點之路由資訊，致節點無資訊可
供參考如 C 點，節點傳送資料時，可
採任意方向傳送，終將會回到共用路
由，達到傳送回收集點之目的，當節
點路由資訊更新完畢後，即會以最短
路徑傳送至共用路由。
Sink node
4 4 4
33 3 3
4
22 2 2
1 1 1
00 0 0
1
33 3 3
11 1 1
22 2 2
4 4 3
13 3 2
2
02 2 1
1 1 0
10 0 0
0
43 3 3
21 1 1
32 2 2
2 2 3 3
1 1 2 2
0 0 1 1
1 0 0 0
2 1 1 1
5 4 4 4
3 2 2 2
4 3 3 3
44 4 4 54 4 4 5 5 5
Hop count=5
◆Target
圖 3-3 資料傳送資訊建立
◆
◆
4 4 4
33 3 3
4
22 2 2
1 1 1
00 0 0
1
3 3 3 3
1 1 1 1
2 2 2 2
4 4 3
13 3 2
2
02 2 1
1 1 0
10 0 0
0
43 3 3
21 1 1
32 2 2
2 2 3 3
1 1 2 2
0 0 1 1
1 0 0 0
2 1 1 1
5 4 4 4
3 2 2 2
4 3 3 3
4 4 4 4 54 4 4 5 5 5
Hop count=5
◆
◆
AB
C
Sink node
Target
圖 3-4 資料傳送方式
(III) 路由建立時機
輕量式路由第一次路徑建立主要
作為共用路由使用，其建立時機可區
分主動式及需求式二種，二種路由建
立的方法如同 AODV 之機制，其最大
差別是建立路徑的目的點不同，需求
式路由建立須等到 sink node 有需求
時，才建立至目標物的路由，而建立
好之路由，即做為共用傳輸路徑，但
此需求式路由 在 sink node 因實體追
蹤路徑的因素與追蹤物間偏離越遠時
將造成共用傳輸路徑的效果無法顯
著。而主動式路由則預先建立路由，
將預先以最遠的邊界點作為目的點建
立路徑，以增加資料傳送路徑與共用
傳輸路由的交集性。
主動建立共用傳輸路徑時，因無
法了解各節點的位置資訊，我們必須
試著利用既有的 AODV 路徑探尋的機
制，建立各節點之關係，進而尋找出
位於邊界的節點，以便建立與資料路
7我們探討節點間，部署位置的動
態調整，尤其是當感測網路中的節
點，可能因電力失效或故障，而造成
防禦上的漏洞。我們將設計以利用壓
力的大小代表感測節點背後受多少個
節點推擠，如壓力值為 3 代表其背後
有 3 個感測節點因移動，連鎖推擠此
感測節點。當節點產生振盪，則透過
壓力繼承來判斷各方推擠壓力的大
小，並決定往壓力較小的方向移動，
讓節點得到類似全域狀況(Global View)
的資訊，減少節點移動時的來回振盪
次數，進而降低電量的消耗；當有些
節點故障時，周圍節點可適時地移
動，讓整個網路仍能達到理想的覆蓋
範圍；當節點過多時，多餘的節點將
往感測區外圍移動，當成備援節點，
或移至外圍節點密度較低的地區。所
以我們提出兩種演算法: (I) 感測節點
動態部署演算法 與 (II) 感測節點故
障部署演算。
(I) 感測節點動態部署演算法
部署演算法為一分散式演算法，
各節點將感測範圍平均分成 6 個扇形
區域，分別感測周圍節點分布情形，
若節點間距小於感測半徑的 3 倍，則
紀錄該距離過近節點的力量及方向，
並做出對應移動。若兩個節點移動方
向相同，則後面的節點將繼承此方向
的壓力值，作為日後節點振盪判斷的
依據，以減少電量的消耗並提高節點
移動的準確性。然而由於部署演算法
為一分散式演算法，因此可能會面臨
分散式演算法中，常出現的感測節點
對稱現象，造成 livelock，面對此
livelock 現象，我們將使用常見的解決
方式，利用每個感測節點唯一的 ID，
來打破 symmetric，解決 livelock 現象。
圖 3-12 部署 16 個感測節點，每個
節點將感測範圍平均分成 6 個方向，
持續地調整周圍節點直到節點間距達
到感測半徑的 3 倍，即代表節點部署
完成。為了方便說明，由上至下、由
左至右假設節點為 A 至 P。圖 3-13 加
入兩個新節點 X、Y，並假設節點 X
和節點 D、節點 Y 和節點 J 的距離近
到可以忽略，節點 X、Y 會對節點間
距小於感測半徑 3 倍的周圍節點產
生壓力，要求周圍節點移動。以節點 X
為例，節點 D 會受節點 X 的推擠而往
東北方移動，並紀錄值為 1 的壓力，
同理，節點 J 也會受節點 Y 的推擠而
往西南方移動，並紀錄值為 1 的壓力，
如圖 3-14 所示（節點 D 和節點 J 實際
會移動至非常接近節點 G 的位置，但
為了方便圖示說明，將節點 D、G、J
至於圖 3-14 中相鄰的位置）。
H
E
A
B
C
G
D
F
K
J
I
L
O
M
N
P
圖 3-12
圖 3-14 中假設節點 D 先推擠節點
G 移動，則節點 G 將繼承節點 D 的壓
力值 1，再加上節點 D 本身對節點 G
產生的壓力值 1，所以 G 的壓力更新
為 2，表示此方向上有兩個節點因此壓
力而移動，如圖 3-15 所示。
9此圖也是加入 X、Y 兩個節點後，在
避免振盪的前提下，達到最大覆蓋範
圍的最終狀態。
X
Y
G
J
1
3
D
C
圖 3-18
X
Y
G
J
D
C
圖 3-19
X
Y
G
J
D
C
圖 3-20
(II) 感測節點故障部署演算法
由於感測區域充滿各種不可預料
的事件，感測節點本身也可能產生故
障，因此，我們必須考慮節點故障時
的解決方法，讓此部署演算法具備容
錯的能力。接下來，我們將以圖示當
節點發生故障時，部署演算法的運作
情形。
首先，我們的假設場景為所有感測節
點間距都達到感測半徑 3 倍的平衡
狀態，如圖 3-21 所示。另外，由於主
要待測區域為圖形中央的長方形區
域，因此，位於此區域外的感測節點
將自我設定為備援節點，以綠色表
示，並關閉節點本身的感測功能以節
省電力，以待日後使用。圖中節點 A
則代表發生故障的節點。
A
B
C
D
E
F
G
H
I
J
圖 3-21
C
D
G
F
B
E
I
-1
-1
-1
-1
-1
-1
H J
圖 3-22
圖 3-22 中，由於感測節點每隔一
段時間會感測節點本身與附近節點的
距離，因此，當節點 A 發生故障，節
點 A 的周圍節點 B 至 G 會感測到周圍
某個方向出現漏洞，為了填補這個漏
洞，這些節點會往漏洞的相反方向傳
11
B
C
D
E
F
G
H
I
K
M
3
J
L
2
圖 3-27
B
C
D
E
F
G
H
I
K
M
4
J
L
2
圖 3-28
圖 3-27 中，由於節點 B 位於節點
F 的東北方，而節點 F 又欲往東北方移
動，因此，節點 B 將繼承節點 F 的壓
力，將壓力值更新為 3 並往東北方移
動。同理，節點 M 則以值為 2 的壓力
往西南方移動。
圖 3-28 假設節點 B 先推擠節點 C
移動，則節點 C 將繼承節點 B 的壓力，
得到往東北方、值為 4 的壓力，並將
推擠節點 M 往東北方移動，但由於節
點 M 曾被節點 L、J 推往西南方，為了
避免節點 L、J 產生往回移動的情形，
節點 M 將不移動，並把壓力值傳遞給
節點 C，因此，節點 C 將得到往西南
方、值為 3 的壓力，如圖 3-29 所示。
同理，為了避免節點 B 產生往回移動
的情形，因此，節點 C 也無法往西南
方移動，而將選擇南、北、西北、東
南四個方向中，壓力小的任意一個方
向移動。
F
C
D
E
B
G
H
I
K
L
J
M
3
4
N
圖 3-29
F
D
E
BG
H
I
K
L
3
J
M2
4
C
N
3
P
Q
圖 3-30
圖 3-30 假設節點 C 往北方移動，
推擠節點 N 成為備援節點。節點 B 則
會繼承節點 M 往西南方的壓力，得到
往東北方和往西南方值皆為 3 的壓
力，由於壓力值相等，因此將靜止不
動。同理，節點 M 會繼承節點 B 往東
北方的壓力，得到往東北方值為 4 和
往西南方值為 2 的壓力，為了避免節
點 L、B 產生往回移動的情形，因此，
節點 M 將選擇南、北、西北、東南四
個方向中，壓力小的任一個方向移動。
F
D
E
BG
H
I
K
L
JC
M
P
Q
N
圖 3-31
13
distance vector (AODV) routing,” 
IETF Network Working Group,
Request for Comments: 3561, July
2003.http://www.ietf.org/rfc/rfc35
61.txt, 2007.
[11]Y. C. Tseng, S. Y. Ni, Y. S. Chen,
and J. P. Sheu, “The broadcast
storm problem in a mobile ad hoc
network,”Wireless Networks, no 8,
pp. 153–167, 2002
[12]D. Watts and S. Strogatz,
“Colective dynamics of small
world networks,” Nature, vol. 393,
pp. 440-442, 1998.
[13]E. P. Wu, “A localization repair 
routing protocol in wireless sensor
network,” MS Thesis. College of
Electrical Engineering and
Computer Science, National Chiao
Tung University, June 2005.
[14]A. Ghosh and S. K. Das,“Coverage
and connectivity issues in wireless
sensor networks ： A survey,”
Pervasive and Mobile Computing,
vol. 4, no. 3, pp. 303-304, 2008.
[15]G. Wang, G. Cao, T. Porta, and W.
Zhang, “Sensor Relocation in 
Mobile Sensor Networks,” 
Proceedings of IEEE INFOCOM,
March 2005.
[16]X. Li, N. Santoro, and I.
Stojmenovic, “Mesh-Based Sensor
Relocation for Coverage
Maintenance in Mobile Sensor
Networks,”Proceedings of the 4th
Int. Conf. on Ubiquitous
Intelligence and Computing (UIC)
(LNCS 4611), pp. 696-708, 2007.
II. 六、計畫成果自評
本研究結果與原計畫內容相符，並達
預期目標。此計畫研究部份成果，已
發表兩篇國際會議論文:
(1) Yu-Chen Kuo and Shih-Chieh Lin,
“A Fast Sensor Relocation Algorithm in
Wireless Sensor Networks,”
International Conference on Sensor
Networks, Information, and Ubiquitous
Computing (ICSNIUC 2009), pp.
254-261, Singapore, August 26~28,
2009. [EI] [NSC 97-2221-E-031-001]
(2) Yu-Chen Kuo, Wen-Tien Yeh, and
Ching-Sung Chen, “A Lightweight 
Routing Protocol for Mobile Target
Detection in Wireless Sensor Networks,”
NCM 2009: Fifth IEEE International
Joint Conference on INC, IMS and IDC,
pp. 1776-1782, August 25~27, 2009,
Seoul, Korea. [EI] [NSC
97-2221-E-031-001]
近期將整理修改後投至學術期刊發
表。
15
附件一
出席國際學術會議心得紀錄
教 師 姓 名 郭育政 服 務 單 位 東吳大學資訊管理系
會議時間地點
98 年 8 月 26 日至 98 年 8 月 28
日 地點:新加坡
獲補助學年度 98 學年度
會 議 名 稱
中文：
英文：Singapore 2009 ICSNIUC 2009: "International Conference on Sensor
Networks, Information, and Ubiquitous Computing"
發表論文題目
中文：
英文：A Fast Sensor Relocation Algorithm in Wireless Sensor Networks
與會心得(含參加會議經過、收穫及攜回資料名稱與內容)：
98 年 8 月 25 日下午 18:15 搭機前往新加坡，於 22:40 抵達新加坡後，前往飯店休息。
8 月 26 日上午 8:10 抵達 INSNUUC 2009 會場，進行註冊後，進入會場聽取新加坡當地的 5 位
學者的專題演講(Invited Talk)，內容包含影像辨識與化學應用對 Unbiquitous Computing 的影
響。下午則聽取計算機結構與機器結構 session 方面的論文報告。 8 月 27 日上午參加人工智
慧 Session，聽取有關人工智慧在電力與雲端計算的應用，席間遇到來自台灣仁德醫專共同科
的李教授，與他交換了其在數學領域方面的研究心得，下午則是準備將於 16:15 開始的自己論
文報告。由於上一場論文報告時間的延長，因此 16:40 才輪到自己場次的報告。本場次共有七
位出席報告，自己的報告排在最後。報告一開始有些許緊張，慢慢克服後，完成了 20 分鐘的
報告，並回答一位詢問有關自己論文分析數據上的問題。8 月 28 日聽取網路與目標物追蹤的
論文報告，由於與自己的研究領域相近，所以聽起來格外有心得。8 月 29 日中午搭機返台，
帶回會議論文集與論文光碟片，內含此次會議所有的紙本論文與其電子檔。此次出席國際研
討會，席間除了接觸到與自己領域相近的報告外，亦接觸到其他不同的研究領域，如數學、
化學、機械等，對同為 Unbiquitous Computing 的探討，給自己以不同方向與面向來思考問題，
收獲良多。也經由 5 天對新加坡的造訪，了解一國際化都市，在人文、教育與研究上，應具
備什麼條件，值得我們學習。
17
not work well in scenes such as the indoor, the seabed, and the
battlefield. However, our fast sensor relocation algorithm can
work well without GPS.
In summary, main contributions of this paper are as follows.
In order to reduce the relocation time, we are the first sensor
relocation algorithm to arrange redundant nodes to solve the
disorder distribution of redundant nodes. Redundant nodes are
arranged to form redundant walls. Redundant walls are
constructed in the position where the average distance to each
sensor node is the shortest. Thus, redundant walls can guide
the sensor node to find the redundant node in the minimum
time. In addition, our fast sensor relocation algorithm can
work without GPS. As shown in simulation results, our
algorithm is superior to T. Le et al.’s algorithm [6] in the time
to find the redundant node, the relocation time to replace the
faulty node and the message complexity.
The rest of this paper is organized as follows. Section 2
summarizes some related works. Section 3 introduces our
system model and assumptions. Then, we propose the fast
sensor relocation algorithm. Section 4 gives the simulation
results for the proposed algorithm. Finally, Section 5
concludes this paper.
II. Related Work
In this section, we briefly review the related works on the
sensor relocation. As we mentioned in Section 1, we still
separate the sensor relocation into two parts. The first part is
to find the nearby redundant node in the sensor network. The
second part is to relocate the redundant node to replace the
faulty node.
For the problem of finding the nearby redundant node in the
sensor network, G. Wang et al. [4] proposed a grid-quorum
based solution. They separated the sensing field into n×n grids
and chose a grid head in each grid. The grid head was
responsible for monitoring sensor nodes in its grid. If the grid
head found that there was a redundant node in its grid, the grid
head sent the message about the position of the redundant
node to all grid heads in the same column. The grid head,
which received the message, stored the position of the
redundant node. If the grid head found that there was a faulty
node in its grid, the grid head sent the request message to all
grid heads in the same row. Since there must be an
intersection in the row and the column, there must be at least
one grid head which stored the position of the redundant node
and received the request message. Thus, the grid head could
find the redundant node eventually.
X. Li et al. [5] proposed the information-mesh structure
instead of the grid structure. All redundant nodes sent notify
messages to the nearest sensor node. The nearest sensor node
stored the position of the redundant node and sent the message
with the position of the redundant node to neighbor sensor
nodes in the east, the west, the south, and the north. Sensor
nodes, which received the position of the redundant node,
forwarded the message in the same direction until there was
no neighbor sensor node. After all sensor nodes finished
forwarding the message, the information-mesh which stored
the position of redundant nodes was formed. When there was a
faulty node in the network, sensor nodes which found the
faulty node sent request messages to search for the redundant
node. When request messages intersected the
information-mesh, sensor nodes could find the position of the
redundant node via the information-mesh.
In order to record the location information of the redundant
node, researches discussed above assumed that GPS was
installed in each sensor node. However, high costs and high
power-consumptions of GPS are heavy burdens for sensor
nodes. Furthermore, due to the interference of buildings and
terrain obstructions, GPS can not work well in scenes such as
the indoor, the seabed, and the battlefield. Therefore, T. Le et
al. [6] proposed their algorithm without GPS. They assumed
that the low-energy node could broadcast the help message to
search for the redundant node before its energy was exhausted.
The redundant node, which received the help message, sent
the reply message to the low-energy node. The low-energy
node chose the nearest redundant node from many reply
messages and notified the nearest redundant node to replace it.
However, when the sensor node failed accidentally, the faulty
node could not broadcast the help message and choose the
nearest redundant node to replace it.
Thus, we hope our algorithm can work well without GPS
and upon the accidental damage. Besides, researches discussed
above randomly scattered redundant nodes around the sensing
field. It takes a long time for the sensor network to find the
redundant node due to the disorder arrangement of redundant
nodes.
For the problem of relocating the redundant node to replace
the faulty node, we separate related works into two parts. The
first part is the cascaded movement. The second part is the
direct movement.
Researches [4], [5] utilized the way of the cascaded
movement (the shift movement). The cascaded movement
means that the sensor node which found the faulty node builds
a path between the redundant node and the faulty node. In
order to reduce the relocation time, all sensor nodes along the
path shift their position toward the faulty node at the same
time. As shown in Fig. 2, A is the redundant node and D is the
faulty node. When the sensor node C finds that D failed, C
searches for the redundant node. We assume that the sensor
node C finds the redundant node A via the sensor node B, then
nodes C, B, and A will replace the faulty node by the cascaded
movement (When C moves to D, B moves to C, and A moves
to B at the same time).
A
B
C
D
Fig. 2 An example of sensor node movement
T. Le et al. [6] utilized the way of the direct movement. As
shown in Fig. 2, only the redundant node A moves to replace
the faulty node D along the path. Sensor nodes B and C do not
move. Though the direct movement was simple and easy to
implement, the relocation time was much longer when the
redundant node was far away from the faulty node.
19
propagate the askBoundary message to the north or the south.
Otherwise, the nearest sensor node will propagate the
askBoundary message to the east or the west. The sensor
node which receives the askBoundary message counts the
boundary distance and forwards the askBoundary message to
the next node in the same direction. Finally, after the boundary
node receives the askBoundary message, the boundary node
sends the replyBoundary message with the boundary distance
back to the redundant node.
For example, as shown in Fig. 5, we assume that ID of the
redundant node A is odd and ID of the redundant node B is
even. The redundant node A sends the askBoundary message
to the nearest sensor node C. Since ID of A is odd, C
propagates the askBoundary message to the north or the south
(Fig. 5 assumes that C propagates the askBoundary message to
the north). The askBoundary message propagates to the next
node in the same direction until the boundary node receives it.
After the boundary node D receives the askBoundary message,
D sends the replyBoundary message with the boundary
distance back to A. After A receives the replyBoundary
message, A can use the boundary distance to observe its
position. In the same way as A, the redundant node B sends
the askBoundary message to the nearest sensor node E. Since
ID of B is even, E propagates the askBoundary message to the
east or the west (Fig. 5 assumes that E propagates the
askBoundary message to the east). After the boundary node F
receives the askBoundary message, F sends the replyBoundary
message back to B such that B can observe its position.
A
B
C
D
E F
Fig. 5 Asking the boundary distance
2) Forming the redundant wall
After the redundant node receives the boundary distance,
the redundant node moves to the center of the sensing field
according to its ID. If its ID is odd, the redundant node moves
to the center in the north-south direction. If its ID is even, the
redundant node moves to the center in the east-west direction.
If there are a large number of redundant nodes, the center of
the sensing field will gather a lot of redundant nodes. If there
are enough redundant nodes in the sensing field, those
redundant nodes will form the redundant wall in the center.
The redundant wall will guide sensor nodes to find the
redundant node. Since the redundant wall is formed, the sensor
node can find the redundant node easily by sending the
message to one of the four directions. When the message
intersects the redundant wall, the sensor node can find the
redundant node via the redundant wall.
However, in fact, redundant nodes in the center may not be
enough to form a seamless redundant wall, which can guide all
sensor nodes from anywhere to find the redundant node. Thus,
after redundant nodes arrive the center of the sensing field,
redundant nodes will send messages to notify neighbor sensor
nodes the existence of redundant nodes.
Specifically, redundant nodes which move to the center in
the north-south direction will send messages to notify
neighbor sensor nodes in the east-west direction. Neighbor
sensor nodes will propagate messages in the east-west
direction until boundary nodes receive them. On the contrary,
redundant nodes which move to the center in the east-west
direction send messages to notify neighbor sensor nodes in the
north-south direction accordingly. After all redundant nodes
send messages to notify neighbor sensor nodes, seamless
cross-redundant walls will be formed in the center of the
sensing field.
For example, as shown in Fig. 6, the redundant node A
moves to the center in the north-south direction since ID of A
is odd. After A arrives the center of the sensing field, A sends
the message to notify neighbor sensor nodes in the east-west
direction to form the redundant wall. In the same way as A,
the redundant node B moves to the center in the east-west
direction since ID of B is even. After B arrives the center of
the sensing field, B sends the message to notify neighbor
sensor nodes in the north-south direction to form the
redundant wall. After all redundant nodes send messages to
notify their neighbor sensor nodes, seamless cross-redundant
walls will be formed in the center of the sensing field.
A
B
Fig. 6 Forming cross-redundant walls
In different applications, we may hope to arrange redundant
nodes to form different kinds of redundant walls, such as
3-redundant walls in Fig. 7. As shown in Fig. 7, redundant
nodes are arranged in the north-south direction to form the 1st,
2nd, and 3rd redundant walls in the one-fourth, the two-fourths,
and the three-fourths of the sensing field. In general, if the
number of redundant walls increases, sensor nodes can find
the redundant node more quickly. Thus, we separate redundant
nodes into n groups to form n redundant walls. Each redundant
node moves to the [(ID mod n)+1]th redundant wall according
to its ID. For example, as shown in Fig. 7, we assume that ID
21
the found-faulty node, the following node will prepare to
move to repair the coverage hole. However, the found-faulty
node may move back to the original position if it fails to
replace the faulty node. It will cause the oscillation between
the found-faulty node and the following node. The oscillation
will waste the power of sensor nodes. To avoid the oscillation,
the following node will query the found-faulty node after a
time period. If the following node does not receive the reply
from the found-faulty node, it means that the found-faulty
node has successfully replaced the faulty node. After that,
following nodes move to repair the coverage hole by the
cascaded movement.
For example, as dashed arrows shown in Fig. 9, sensor
nodes C, D, E, and F send askRedundant messages to search
for the redundant node in the opposite direction of the faulty
node. D and E do not move to replace the faulty node since
they can not find the information of the redundant node. C
receives the information of the redundant node H from the
sensor node I. F stores hop counts to the redundant node G
since F is on the redundant wall. Thus, as shown in Fig. 10, C
and F move to the position of the faulty node to replace the
faulty node. As shown in Fig. 11, C replaces the faulty node
and F moves back to the original position since hop counts
between C and H is smaller than hop counts between F and G.
After that, following nodes I and H move to repair the
coverage hole by the cascaded movement. The faulty nodes
replacement algorithm is described in Fig. 12.
C
D
E
FG
H
I
Fig. 9 Finding the redundant node
C
D
E
FG
H
I
Fig. 10 C and F compete to replace the faulty node
C
D
E
FG
H
I
Fig. 11 I and H repair the coverage hole by the cascaded movement
Notations：
d: the direction of the packet
hc: hop counts from the found-faulty node to the
redundant node
Messages：
askRedundant: search the information of the redundant node
replyRedundant: reply the sensor node its hop counts to the
redundant node
At sensor node Si
send hello messages to neighbor sensor nodes
receive replies of hello messages from neighbor sensor nodes
if (there is no reply about Sf in this round) {
Sf is assigned to be the faulty node
Si is assigned to be the found-faulty node
set hc = 0 and send askRedundant＜Si, d, hc＞to the next
node in the opposite direction of Sf
}
if (receive askRedundant＜Sj, d, hc＞) {
if (Si has hop counts information hci to the redundant node)
hc = hc + hci
send replyRedundant＜Sj, d, hc＞to the next node in the
opposite direction
else
hc++
forward askRedundant＜Sj, d, hc＞to the next node in the
same direction
}
if (receive replyRedundant＜Sj, d, hc＞) {
forward replyRedundant＜Sj, d, hc＞to the next node in
the same direction
}
if (receive replyRedundant＜Si, d, hc＞) {
if (the position of Sf is not replaced by other nodes)
move R to replace the faulty node Sf
following nodes move to repair the coverage hole by
the
cascaded movement
}
Fig. 12 The faulty nodes replacement algorithm
23
0
100
200
300
400
500
1 3 5
Number of Faulty Nodes
M
ov
in
g
D
is
ta
nc
es
(m
)
T. Le's algorithm
cross-redundant walls
3-redundant walls
5-redundant walls
Fig. 16 Moving distances (m)
As the moving distance shown in Fig. 16, T. Le’s algorithm
is better as the number of faulty nodes increases. This is
because their algorithm assumed that the faulty node could
broadcast the help message and choose a redundant node to
replace it. However, when the sensor node failed accidentally,
the accidental faulty node could not broadcast the help
message to redundant nodes. Thus, the accidental faulty node
would leave a permanent coverage hole. The permanent
coverage hole could not be repaired even the sensor network
still had redundant nodes. In our algorithm, even if the sensor
node fails accidentally, found-faulty nodes can coordinate
with each other and find the proper redundant node to replace
the faulty node. Thus, our algorithm can work well upon the
accidental node failure. Though we take more distances to
coordinate between found-faulty nodes, we can solve the
accidental node failure problem which they can not.
V. Conclusion
In this paper, we propose a fast sensor relocation algorithm
to arrange redundant nodes to form redundant walls without
GPS. Redundant walls are constructed in the position where
the average distance to each sensor node is the shortest. Thus,
redundant walls can guide the sensor node to find the
redundant node in the minimum time. When the sensor node
fails, our algorithm replaces the faulty node by the cascaded
movement. Simulation results show that our algorithm can
find the proper redundant node in the minimum time and
reduce the relocation time with low message complexity.
VI. ACKNOWLEDGMENT
This research was supported in part by the National Science
Council of the Republic of China under contract NSC
97-2221-E-031-001.
VII. REFERENCES
[17] I. F. Akyildiz, W. Su, Y. Sankarasubramaniam, and E. Cayirci, “A Survey 
on Sensor Networks,” IEEE Communication. Magazine, pp. 102-114,
August 2002.
[18] N. Ahmed, S. S. Kanhere and S. Jha, “The Holes Problem in Wireless
Sensor Networks：A Survey,” ACM SIGMOBILE Mobile Computing and
Communications Review, vol. 9, no. 2, pp. 4-18, April 2005.
[19] A. Ghosh and S. K. Das, “Coverage and connectivity issues in wireless
sensor networks：A survey,”Pervasive and Mobile Computing, vol. 4, no.
3, pp. 303-304, 2008.
[20] G. Wang, G. Cao, T. Porta, and W. Zhang, “Sensor Relocation in Mobile 
Sensor Networks,” Proceedings of IEEE INFOCOM, March 2005.
[21] X. Li, N. Santoro, and I. Stojmenovic, “Mesh-Based Sensor Relocation
for Coverage Maintenance in Mobile Sensor Networks,”Proceedings of
the 4th Int. Conf. on Ubiquitous Intelligence and Computing (UIC)
(LNCS 4611), pp. 696-708, 2007.
[22] T. Le, N. Ahmed, S. Jha, “Location-free Fault Repair in Hybrid Sensor
Networks,” Proceedings of the first ACM Int. Conf. Integrated Internet
Ad Hoc and Sensor Networks, vol. 138, no. 23, May 2006.
[23] B. Hofmann-Wellenhof, H. Lichtenegger, and J. Collins, Global
Positioning System: Theory and Practice, Fourth Edition, Springer
Verlag, 1997.
[24] J. Borenstein and Y. Koren, “Obstacle Avoidance with Ultrasonic
Sensors,”IEEE Journal of Robotics and Automation, vol. 4, no. 2, pp.
213-218, 1988.
[25] Q. Li and D. Rus, “Global Clock Synchronization in Sensor Networks,”
IEEE Transactions on Computers, vol. 5, no. 2, February 2006.
[26] B. Sundararaman, U. Buy, and AD. Kshemkalyni, “Clock
Synchronization for Wireless Sensor Networks: A Survey,”Ad-Hoc
Networks, vol. 3, no. 3, pp. 281-323, May 2005.
[27] D. Niculescu and B. Nath, “Ad Hoc Positioning System (APS) Using 
AoA,” Proceedings of IEEE INFOCOM, 2003.
[28] J. Ash and L. Poter, “Sensor network localization via received signal 
strength measurements with directional antennas,” Proceedings of the
Forty-Second Annual Allerton Conference on Communication, Control,
and Computing, pp. 1861–1870, September 2004.
[29] N. Patwari, A.O. Hero III, J. Ash, R.L. Moses, S. Kyperountas, and N.S.
Correal, “Locating the Nodes,’IEEE Signal Processing Magazine, vol.
22, no. 4, pp. 54–69, July 2005.
2
Abstract—Sensor relocation is to repair coverage holes caused by
node failures. One way to repair coverage holes is to find redundant
nodes to replace faulty nodes. Most researches took a long time to
find redundant nodes since they randomly scattered redundant nodes
around the sensing field. To record the precise position of sensor
nodes, most researches assumed that GPS was installed in sensor
nodes. However, high costs and power-consumptions of GPS are
heavy burdens for sensor nodes. Thus, we propose a fast sensor
relocation algorithm to arrange redundant nodes to form redundant
walls without GPS. Redundant walls are constructed in the position
where the average distance to each sensor node is the shortest.
Redundant walls can guide sensor nodes to find redundant nodes in
the minimum time. Simulation results show that our algorithm can
find the proper redundant node in the minimum time and reduce the
relocation time with low message complexity.
Keywords—Coverage, distributed algorithm, sensor relocation,
wireless sensor networks.
I. INTRODUCTION
ecent advances in electronics and wireless communication
technologies have accelerated the development and
applications of wireless sensor networks. A wireless sensor
network consists of a large number of tiny, low-cost,
low-power, and mobile sensor nodes, which are capable of
observing the environment, processing data and
communicating each other by radio. Such sensor networks
have been intensively utilized in a wide range of applications
such as medical treatment, unknown environment exploration,
battlefield surveillance, and so on [1].
Sink Node
Sensor Node
Internet
User
Sensing Field
AB
CD
E
Fig. 1 A wireless sensor network
As shown in Fig. 1, the deployed sensor nodes are randomly
scattered in a sensing filed. Each of the deployed sensor nodes
performs tasks assigned previously and communicates each
other to route sensing data back to the sink node (such as the
communication links between sensor nodes A, B, C, D, and E).
After receiving the data, the sink node transforms the data into
Authors are with the Department of Computer Science and Information
Management, Soochow University, Taipei, Taiwan, R.O.C (e-mail:
yckuo@csim.scu.edu.tw).
the useful information and then transmits it to users via
Internet.
Due to the low-cost and the mobile computational
capability of sensor nodes, they are usually deployed in the
harsh or the human-unreachable environment to perform the
sensing task. However, there is much accidental damage in the
harsh environment such as a battlefield explosion or a volcanic
eruption. Because of the environmental interference and the
low-power essence of sensor nodes, sensor nodes are prone to
failure unexpectedly. The faulty node introduces many errors
into the network and corrupts the network. For example, the
faulty node leaves a coverage hole [2] in the sensing field if it
can not perform the sensing task. The sensor network fails to
achieve its objectives when it can not provide the desired
coverage. Moreover, when there is a coverage hole in the
sensor network, the data transmission path through the
coverage hole will be broken and needed to rebuild. The
rebuilding process consumes much power and it is a heavy
burden for sensor nodes due to the low power essence.
Seriously, too more coverage holes may cause not only the
damage of the node connectivity [3], but also the network
partition. Some of the important data may lose and the data
integrity may be greatly degraded upon the network partition.
In order to avoid the network partition and the coverage
hole, it is necessary to find the redundant node to replace the
faulty node as soon as possible. The process is called the
sensor relocation. The sensor relocation consists of two stages.
The first stage is to find the nearby redundant node in the
sensor network. The second stage is to relocate the redundant
node to replace the faulty node. For the first stage, early
researches [4-6] randomly scattered redundant nodes around
the sensing field. It takes a long time for the sensor network to
find the redundant node due to the disorder arrangement of
redundant nodes. Therefore, we propose a fast sensor
relocation algorithm to arrange redundant nodes to form
redundant walls. If a sensor node is faulty, the neighbors of
the faulty node will find the nearest redundant node via
redundant walls. For the second stage, T. Le et al. [6] moved
the redundant node to replace the faulty node directly. Though
their method was simple and easy to implement, it could not
satisfy the timely requirement because of the low speed of the
mobile sensor node. Thus, we utilize the concept of the
cascaded movement [4] to replace the faulty node quickly.
On the other hand, in order to record the precise position of
the faulty node, early researches [4], [5] assumed that the
global position system (GPS) [7] was installed in each sensor
node. However, high costs and high power-consumptions of
GPS are heavy burdens for sensor nodes. Furthermore, due to
the interference of buildings and terrain obstructions, GPS can
Yu-Chen Kuo and Shih-Chieh Lin
A Fast Sensor Relocation Algorithm in
Wireless Sensor Networks
International Conference on Sensor Networks, Information, and Ubiquitous Computing (ICSNIUC 2009)
R
4Although researches [4], [5] can reduce the relocation time
by the cascaded movement, they still can not reduce the time
to find the redundant node due to the disorder arrangement of
redundant nodes. Next, we will introduce how our fast sensor
relocation algorithm can reduce the time to find the redundant
node by arranging redundant nodes to form redundant walls.
Besides, we will introduce how our algorithm replaces the
faulty node by the cascaded movement.
III. A Fast Sensor Relocation Algorithm
A、 System Model and Assumptions
First, we assume that sensor nodes are deployed as the grid
structure and the distance between each sensor node is R (R is
the transmission range of each sensor node), as black nodes
shown in Fig. 3. Redundant nodes are randomly scattered
around the sensing field, as white nodes shown in Fig. 3.
Second, we assume that each sensor node is equipped with the
ultrasonic obstacle-detecting module [8]. Thus, the sensor
node can detect the boundary and become the boundary node
if the distance between the boundary and the sensor node is
smaller than R. Third, we assume that sensor nodes are
synchronous [9], [10]. It means that each sensor node has the
same clock cycle and performs the sensing task at the same
time. Besides, we assume that sensor nodes can detect the
direction by the electronic compass and each sensor node
knows the length and the width of the sensing field. Moreover,
we assume that sensor nodes can detect relative distances and
angles to estimate the relative location information to nearby
nodes [11-13]. Finally, in order to find the faulty node in time,
sensor nodes periodically send hello messages to neighbor
sensor nodes to verify whether they are alive. Next, we will
introduce our fast sensor relocation algorithm in two parts.
The first part is the redundant nodes arrangement algorithm.
The second part is the faulty nodes replacement algorithm.
R
R
Fig. 3 The System Model (The black square stands for the boundary)
B、 Redundant nodes arrangement algorithm
In order to find the redundant node as soon as possible, the
redundant nodes arrangement algorithm arranges the deployed
redundant nodes to the specific position to form redundant
walls. In general, if the distance between redundant walls and
the faulty node is shorter, the time to find the redundant node
will be less. In addition, since each sensor node in the sensor
network may fail, we desire to arrange redundant nodes to a
proper position where the average distance from the redundant
node to each sensor node is the shortest.
Fig. 3 is the 2-D scenario. For easy understanding, we
consider the 1-D scenario first. As shown in Fig. 4, there are n
sensor nodes in a row and the position of each sensor node is
from 1 to n. The distance between each sensor node is R, and
we deploy the redundant node in the position x.
x2 nn-11
。。。。。。 。。。。。。
Deploy the redundant node
R R
Fig. 4 Deploy the redundant node in the position x
Let D(x) be the average distance from the redundant node to
each sensor node. Then, we obtain
        RxnRxnRxRx
n
xD  1...0...211)(
To minimize D(x), we have




2
1n
x or 



2
1n
Since 



2
1n
x or 



2
1n
stands for the center position of
those n sensor nodes, we can conclude that the average
distance from the redundant node to each sensor node is the
shortest when we arrange the redundant node in the center
position.
Therefore, if the redundant nodes arrangement algorithm
can arrange redundant nodes to the center of the sensing field,
the time to find the redundant node will be the shortest. After
discussing the 1-D scenario in Fig. 4, we focus on the 2-D
scenario in Fig. 3. We consider the 2-D scenario as two 1-D
scenarios (one is row and the other is column). Thus, we hope
that the redundant nodes arrangement algorithm can arrange
half of redundant nodes to the center of the row and arrange
the other half to the center of the column. After that,
cross-redundant walls are formed in the center, as shown in
Fig. 6. Next, we will introduce the following two steps of the
redundant nodes arrangement algorithm. The first step is (1)
Asking the boundary distance. The second step is (2) Forming
the redundant wall.
1) Asking the boundary distance
First, each redundant node sends the askBoundary message
to the nearest sensor node among its neighbor nodes to ask for
the boundary distance. The boundary distance stands for the
distance from the redundant node to the boundary. The
redundant node can use the boundary distance to observe its
position without using GPS. The nearest sensor node
propagates the askBoundary message to its neighbor sensor
node in one of the four directions (the east, the west, the south,
or the north) according to ID of the redundant node. If ID of
the redundant node is odd, the nearest sensor node will
6of redundant nodes A, B, and C are 7, 5, and 9, respectively. A
moves to the [(7 mod 3) +1]th redundant wall (i.e., the 2nd
redundant wall). B moves to the [(5 mod 3) +1]th redundant
wall (i.e., the 3rd redundant wall). C moves to the [(9 mod 3)
+1]th redundant wall (i.e., the 1st redundant wall). After all
redundant nodes move to those redundant walls, 3-redundant
walls are formed in the sensing field.
A
B
C
1st redundant wall
2nd redundant wall
3rd redundant wall
Fig. 7 Forming 3-redundant walls
As we mentioned before, the redundant nodes arrangement
algorithm can arrange redundant nodes into different kinds of
redundant walls according to the application. Even if the
number of sensor nodes increases or the deployment status
changes, our algorithm can adjust redundant walls easily to
reduce the time to find the redundant node. The redundant
nodes arrangement algorithm is described in Fig. 8.
Notations：
d: the direction of the packet
n: the number of redundant walls
td: the distance from the redundant node to the boundary
Messages：
askBoundary: ask the nearest sensor node to calculate td
replyBoundary: reply the redundant node td
At redundant node Sr
set td = 0 and send askBoundary＜Sr, Sn, d, td＞to the nearest
sensor node Sn
if (receive replyBoundary＜Sr, Sn, d, td＞) {
move to the [(ID mod n)+1]th redundant wall
according to its position to the boundary, td
send messages to neighbor sensor nodes in the
[(ID mod n)+1]th redundant wall
}
At sensor node Si
if (receive askBoundary＜Sr, Sn, d, td＞) {
if (Si is the boundary node)
td = td + the distance from Si to the boundary
if (Si == Sn)
send replyBoundary＜Sr, Sn, d, td＞to Sr
else
send replyBoundary＜Sr, Sn, d, td＞to the next node in
the opposite direction
else
td = td + R
if (Si == Sn)
propagate askBoundary＜Sr, Sn, d, td＞to the next node
in one of the four directions according to ID of Sr
else
forward askBoundary＜Sr, Sn, d, td＞to the next
node in the same direction
}
if (receive replyBoundary＜Sr, Sn, d, td＞) {
if (Si == Sn)
send replyBoundary＜Sr, Sn, d, td＞to Sr
else
forward replyBoundary＜Sr, Sn, d, td＞to the next node in
the same direction
}
Fig. 8 The redundant nodes arrangement algorithm
c) Faulty nodes replacement algorithm
The procedure of the faulty nodes replacement algorithm is
described as follows. All sensor nodes periodically send hello
messages to neighbor sensor nodes to verify whether they are
alive. If one of the neighbor sensor nodes did not reply, other
neighbor sensor nodes conceive that the sensor node which did
not reply is failed. To replace the faulty node, the sensor node
which found the faulty node performs the following two steps.
The first step is (1) Finding the redundant node. The second
step is (2) Replacing the faulty node.
Finding the redundant node
For simplicity, we use the found-faulty node to represent the
sensor node which found the faulty node. In our scenario,
found-faulty nodes are neighbor sensor nodes which are 1-hop
distance to the faulty node, i.e., the north, the south, the east,
and the west of the faulty node. Four found-faulty nodes send
askRedundant messages to search for the redundant node in
the opposite direction of the faulty node. If the node which
received the askRedundant message has the information of
the redundant node, it will send the replyRedundant message
with the information of the redundant node (i.e. hop counts to
the redundant node) to the found-faulty node. Otherwise, it
will propagate the askRedundant message to the next node in
the same direction until the information of the redundant node
is found.
Replacing the faulty node
After the found-faulty node receives the information of the
redundant node, it moves to the position of the faulty node to
exchange its hop counts to the redundant node with other
found-faulty nodes. The found-faulty node with the smallest
hop counts replaces the faulty node. Other found-faulty nodes
move back to their original position. If hop counts to the
redundant node are equal, the found-faulty node with the
smallest ID will replace the faulty node. When the
found-faulty node moves to replace the faulty node, the
position of the found-faulty node becomes a coverage hole.
Once the following node detects the coverage hole caused by
8IV. Simulation
Simulation environment
In the simulation, our algorithm is implemented using the
ns-2 simulator (version 2.27). Sensor nodes are deployed as
the grid structure in a 200m×200m square region and
redundant nodes are randomly scattered around the sensing
field. The distance and the communication range of each
sensor node are both 20m. The speed of the mobile sensor
node is 2.5 m/s.
In order to know the effectiveness in different network sizes,
we simulate our algorithm in three scenes. The first scene is
that 25 sensor nodes are deployed as 5×5 grid and 5 redundant
nodes are randomly scattered around the sensing field. The
second scene consists of 49 sensor nodes (7×7 grid) and 7
redundant nodes. The third scene consists of 81 sensor nodes
(9×9 grid) and 9 redundant nodes.
Since our algorithm can form different kinds of redundant
walls according to the application, we form three kinds of
redundant walls, which are cross, 3, and 5-redundant walls to
evaluate the effectiveness of different kinds of redundant walls.
Besides, we compare our algorithm with T. Le’s algorithm in
[5]. We measure the performance of both algorithms by four
metrics: (1) the time to find the redundant node, (2) the
relocation time, (3) the message complexity, and (4) the
moving distance to replace the faulty node.
Simulation results
0
0.1
0.2
0.3
0.4
0.5
0.6
(25,5) (49,7) (81,9)
( Number of Sensor Nodes , Number of Redundant Nodes )
Ti
m
e
to
fin
d
th
e
re
du
nd
an
tn
od
e
(s
)
T. Le's algorithm
cross-redundant walls
3-redundant walls
5-redundant walls
Fig. 13 Time to find the redundant node (s)
As shown in Fig. 13, no matter what kinds of redundant
walls are, our algorithm spends less time to find the redundant
node than T. Le’s algorithm. This is because our algorithm
arranges redundant nodes to form redundant walls, whereas T.
Le randomly scatters redundant nodes around the sensing field.
Since redundant walls are constructed in the position where
the average distance to each sensor node is the shortest, each
sensor node can find the redundant node more quickly from
nearby redundant walls. Besides, in Fig. 13, we can observe
that T. Le’s algorithm spends more time to find the redundant
node when the network size increases. The reason is that the
distance from the redundant node to each sensor node
becomes longer when the network size increases. Thus, their
algorithm needs more time to find the redundant node.
5
15
25
35
45
(25,5) (49,7) (81,9)
( Number of Sensor Nodes , Number of Redundant Nodes )
R
el
oc
at
io
n
Ti
m
e
(s
)
T. Le's algorithm
cross-redundant walls
3-redundant walls
5-redundant walls
Fig. 14 Relocation time (s)
As shown in Fig. 14, no matter what kinds of redundant
walls are, our algorithm outperforms T. Le’s algorithm in the
relocation time. Besides, the relocation time of T. Le’s
algorithm increases dramatically as the network size increases.
The reason is that T. Le’s algorithm replaces the faulty node
by the direct movement, whereas our algorithm replaces the
faulty node by the cascaded movement. When the network
size increases, the distance between the redundant node and
the faulty node is longer. As for the direct movement, the
redundant node has to move a long distance to replace the
faulty node alone. As for the cascaded movement, all nodes
along the path move at the same time. That is, the long
distance is shared by all nodes along the path. Thus, the
relocation time is significantly reduced in our algorithm. As
cross, 3, and 5 redundant walls shown in Fig. 14, 5-redundant
walls outperform 3-redundant walls and 3-redundant walls
outperform cross-redundant walls. This is because the more
redundant walls will distribute redundant nodes more and
shorten the distance from the faulty node to the redundant
node. Thus, 5-redundant walls perform the best in the
relocation time.
M
es
sa
ge
C
om
pl
ex
ity
0
100
200
300
400
(25,5) (49,7) (81,9)
( Number of Sensor Nodes , Number of Redundant Nodes )
T. Le's algorithm
cross, 3, 5-redundant walls
Fig. 15 Message complexity
Since the message complexity of cross, 3, and 5-redundant
walls are almost the same, we use one line to represent them.
The message complexity stands for the message to arrange
redundant nodes and to replace the faulty node. As shown in
Fig. 15, the message complexity of our algorithm is less than
that of T. Le’s algorithm. The reason is that T. Le broadcasts
messages to search for the redundant node, whereas our
algorithm only sends messages to one of the four directions
due to the existence of redundant walls.
