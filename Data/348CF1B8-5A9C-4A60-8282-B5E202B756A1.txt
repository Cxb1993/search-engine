  
 
2
 
行政院國家科學委員會專題研究計畫成果報告(期末報告） 
逐步聚焦搜尋法-一個較可調控之新超探索演算法 
計畫編號：NSC 96-2628-E-005-074-MY3 
執行期限：96 年 8 月 1 日至 99 年 7 月 31 日 
主持人：曾怜玉   國立中興大學資訊網路與多媒體研究所 
                 國立中興大學資訊科學與工程學系 
計畫參與人員：蔡杰松  陳駿  林亞泰  吳志盛  
 
摘要 
本計畫提出的方法本來叫作 Progressively Focusing Search (PFS)，後來經過進一步研究後，我
們決定改成一個更貼切的名字，叫作 Multiple Trajectory Search (MTS)，在計畫的第一年，我們應
用 Multiple Trajectory Search (MTS)在 Global Numerical Optimization 和 Multiple Objective 
Optimization 這兩個 real parameter 的最佳化問題上，並且在 2008 年 IEEE World Congress on 
Computational Intelligence 的 Competition on Large Scale Global Optimization 勇奪第一名，在 2009
年的 IEEE Congress on Evolutionary Computation 的 Competition on Performance Assessment of 
Constrained/Bound Constrained Multi-Objective Optimization Algorithms 也分別獲得第二與第三
名。在本計畫的第二年，我們使用 MTS 來解 combinatorial optimization problems 中其解可以用
permutation sequence 來表示的問題，計畫中我們採用第二種 approach，針對此種問題重新研發
MTS，我們利用所研發的 MTS 解了 flowshop scheduling problem 與 graph coloring problem 兩個問
題，而實驗所得的結果亦都不錯。在本計畫的第三年，我們進一步的應用 MTS 來解 combinatorial 
optimization problems 中其解可以是使用 binary sequence 來表示的問題，本年度我們利用 MTS 解
了 P-median problem 與 maximum clique problem 二個問題。在本報告中也敘述了 MTS 應用於這二
個問題的方法，並將實驗結果與目前頂尖的相關論文進行比較後，MTS 應用於 binary sequence 表
示的問題有相當好的表現，只是在整個方法的調整上，我們認為應該可以再更好，因此未來我們
希望能更進一步對 MTS 在 combinatorial optimization problems 上的應用再深入研究探討。 
 
關鍵詞：多軌跡搜尋法，數值最佳化問題，多目標最佳化問題，flowshop 排程問題，塗色問題，
P 中位問題，最大完全子圖問題。 
 
  
 
4
1. 前言 
本報告提出一個全新的 meta-heuristic 方法，在初始發展階段以方法的設計方向命名為
Progressively Focusing Search (PFS)，但在後來的研究中不斷的改良方法的搜尋方式與搜尋能
力，因此將其改名為 Multiple Trajectory Search(MTS)。在本報告中為了進一步的說明 MTS 是
一個可適用於求解各種最佳化問題的方法，我們將最佳化問題以編碼方式分成三類，分別是數
值化編碼、順序排列編碼與二進制編碼，並以三年的時間，每年針對一種編碼的問題來深入研
究 MTS 的適用性，並提出演算法與實驗數據以佐証 MTS 的效能。 
在數值化編碼的部份，我們以 Global Numerical Optimization 做為指標性題目，Global 
Numerical Optimization 在現實世界中是一個很重要的問題，無論工程，科學甚至生活上都有很
多這樣的問題存在，一般而言我們探討的問題都是單目標值函數的最佳化，這方面的研究也最
多；但有許多情況下，我們會同時針對多個目標值做最佳化；例如對汽車的開發上面可能要兼
顧省油，性能以及耐用性。這幾個性質可能會彼此相互牴觸，例如要兼顧省油跟性能，在這樣
的情況下我們會有些取捨的方法，和最佳化單一目標的情況不大相同，但同樣是十分重要的一
個問題。 
在順序排列編碼的部份，我們使用二個問題做指標性題目，第一個是 flowshop scheduling 
problem，這是一個著名的排程問題，於 1954 由 Johnson 提出並加以研究，至今仍是許多學者
關注的問題。由於流程型工廠（flowshop）對映到許多產業的生產模式，生產排程對各產業而
言一直都是一個重要的議題，尤其以今日競爭日益激烈的市場環境而言，各種價值鏈整合模式
的演進與產品多元化的發展，使得企業從採購、生產到配銷等整體運籌活動日益複雜，面對如
此快速多變的環境，為能準確快速回應顧客訂單的需求、充分利用有限資源，排程問題顯得更
加重要[45]。因此，對於 flowshop scheduling problem，從原來追求的最小完工時間逐漸衍生出
其他的準則與變形以符合現在的生產製造環境，例如：total flowtime 準則影響在製品的多寡，
與物料庫存水準，我們在這裏解的即是 total flowtime flowshop scheduling problem。而第二個
問題是圖形著色問題(Graph Coloring Problem)，它是圖形理論中的一個重要問題，在實際運用
上，有許多問題都與圖形著色問題有直接或間接的關係，也就是說若能發展一個有效率的演算
法，盡量的以最少的顏色塗滿一個圖形，則此演算法會對解某些問題之效率有一定程度的影
響，這包含了時刻表和排程（time tabling and scheduling）[14]，頻率指派用於電磁頻譜[21]
（frequency assignment for use of the electromagnetic spectrum），編譯器的暫存器配置[3]
（register allocation in compilers），印刷電路版之測試（printed circuit board testing）[19]，和從
有限元素法產生稀疏線性系統（the solution of sparse linear system originating from finite-element 
meshes）[56]。 
最後在二進制編碥的部份，我們也使用二個題目做為代表第一個是 P-median problem，這
是選址問題的基本題型，在現實生活中，舉凡物流中心、倉儲工廠、學校與基地台的位置設置
均與其相關，因此若能在前置作業中先選擇出較優良的設施位置，不僅可以降低傳送成本，還
能提升設施的運作效能。Pmp 除了在大型設施的決策任務中扮演重要角色，也在一些工廠內
設備的擺放、購物中心內部規畫、網路設備放置地點選擇…等規畫方案中被應用於成本、效率
的平衡。由於此問題的應用非常廣泛，因此早在 1960 年就被提出，更於 1969 年被証明為
NP-hard 問題 [43]。第二個問題是最大完全子圖問題(Maximum Clique Problem)，因其定義簡
單，題型經典，早在 1979 年之前就有學者從事相關研究，至今仍有許多的學者在鑽研此問題，
每年仍可看到解最大完全子圖問題的論文發表在國際期刊上。此外也有相當多的應用可以轉換
成最大完全子圖來處理，例如：圖形著色問題(graph coloring)、最大公式滿足性問題(maximum 
satisfiability problem)等等典型的 NP-hard 問題，再者最大完全子圖問題也擁有許多變形問題，
例如:Maximum Node Weights Clique Problem，或是在雙分圖（bipartite graph）中找出有最多邊
  
 
6
3. 文獻探討 
在本節我們將依要解的六個問題各自作文獻探討。 
3.1 Global Numerical Optimization and Multi-Objective Numerical Optimization 
Global numerical optimization主要是在Rn空間上面做搜尋，通常我們會寫成下面的型式 
  Minimize F(X) 
  Subject to l≦X≦u 
 其中X=(x1, x2, …, xN) 是一個在Rn space上的變數，F(X)是一個Objective Function. l=(l1, l2, …, 
lN)和u=(u1, u2, …, uN) 則定義出搜尋的空間，任意一組解X=(x1, x2, …, xN)必須滿足li≦xi≦ui 
(i=1, 2, …, N)。 
而Multiple Objective Optimization中因為有多個Objective Functions，要比較2組解的好壞，
並不像單一Objective問題那樣容易，我們會定義一個關係叫作dominance，如果x的每個
Objective的值都比y來的好，我們就稱為x dominates y，也可以稱為x比y好。另外在一個集合中，
如果任兩個elements都互相不dominate對方，則稱此集合為Approximation Set，在Multiple 
objective的問題中，我們所要找的就是一個Approximation Set而非單一最佳解，對於某個在解
空間上的點y，如果在解空間中不存在任何dominate y的解，我們則稱y為一Pareto optimum。  
在CEC2007以及CEC2008分別有些論文在探討Global numerical optimization[72], [38], [9], 
[46], [64], [74], [77], [67]以及Multiple objective optimization [75], [76], [63], [73], [40], [57], [44]. 
這些論文中分別使用[61]和[39]中的問題，在[61]中總共有7個問題，分別是在100,500以及1000
個維度上做搜尋。而[39]中則是有13個問題，其中問題1到7都是2個objectives的問題，而8到13
的問題有三個objectives和五個objectives這兩種變形。在本報告中就是使用Multiple Trajectory 
Search來解Global Numerical Optimization和Multiple Objective Optimization的兩個問題。 
 
3.2 Flowshop Scheduling Problem 
Flowshop Scheduling Problem 的定義如下：存在 n 個工作{J1, J2, …,Jn}與 m 個機器{M1, 
M2, …,Mm}。每個工作包含 m 個需要依序在不同機器上加工的操作，所有工作的加工順序皆相
同。每個的操作的處理時間皆為已知，以 Tij（i=1,…,n ; j=1,…,m）來表示第 i 個工作的第 j 個
操作的處理時間。另外，每部機器一次只能處理一個工作，不可中斷或搶先，且每個工作在
同一時間點，只能被一台機器處理。所謂的 flowtime 代表一個工作於最後一台機器的完成時
間。給定一個排程 π={π1, π2,.., πn}，則每個工作的完成時間可被遞迴地計算： 
   
jiandjCwhere
mjni
TjCjCjC jiii i
 and relevant for  0)0,C(  0),( 
,...,2,1;,...2,1
,)1,(),,(max,
i0
,1


 

 
 
一個工作 iJ 的 flowtime (或稱為完成時間)可被定義為 ),( mC i ， 代表一個工作 iJ
在最後一台機器 Mm 的完成時間。一個工作執行順序 π的 total flowtime 定義為： 



n
i
isum mCC
1
),()(   
代表所有工作的完成時間之總合。而以最小化 total flowtime 為目標的 flowshop scheduling 
problem，就是在所有可能的執行順序 Π中找一個執行順序 π*使得： 
  ),(*)( sumsum CC  
  
 
8
過去被用來解決 Graph Coloring Problem 的方法中，最早被提出的方法為 1979 年 Brélaz 提
出一種貪婪建構方法DSATUR algorithm [3]，其每一步驟都依照固定的原則來著色，此方法速
度快，但結果不好。接著在 1987 年 Hertz and Werra 提出 Tabucol Algorithm[35]，使用塔布搜
尋法（Tabu Search），使用上述的分配方式，在一組解裡一直更換有衝突（conflict）的端點，
來找出一組適當的解（feasible solution），也有用模擬退火法（Simulated Annealing）[12][42]
解此問題，在 1996 年 Fleurent and Ferland 提出 Hybird Approach [16]，使用指派方式的交配方
法（assignment crossover）加上塔布搜尋法，來解此問題。1999 年 Galinier and Hao 提出類似
的 Hybird Approach [24]，不過他使用的是分配方式的交配方法（partition crossover）加上塔布
搜尋法來解此問題。2003 年 Avanthay、Hertz and Zufferey 提出變動鄰域結構搜尋法（variable 
neighborhood search）[3]，定義出多個鄰域結構（neighborhood structure）加上塔布搜尋法，每
次均在目前所搜尋的解上，選定一種結構在這個鄰域裡找出最好的一組解，若比目前所搜尋的
解更好則更新目前的解，反之如果沒有比較好，就再選擇另一種鄰域結構，重覆此步驟，直到
作滿某個代數或已找到最佳解。 
 
3.4 P-median Problem 
在 P-median 問題上，我們假設每個顧客均有其需求量，因此必需尋找適合的供給設施，來
滿足其需求。此外我們也假設每個設施供給點的容量是無限制的，足以滿足任何顧客的需求。
另一方面我們限制每個顧客只能被一間設施所供給，但設施可以供給不只一個顧客。最後的目
標則是要選出 p 個設施位置，來滿足所有顧客的需求，並使得整體的距離成本最小。 
我們首先定義 },...,1{ nV  為顧客集合( Vi )，而 },...,1{ pF  則為無供應量限制的設施供給
點集合( Fj )，並假設存在一個成本矩陣 )( ijdD  ，且 FjVidij   , ,0 。此外我們再定義
二個 binary 變數: 

 
                                     otherwise;   0
; siteat  located ismedian  a if    1   Fj
y j  
與 
      
 
                                                                          otherwise;   0
; siteat  located mediana   toassigned is  client  if    1   FjVi
xij  
因此 p-median problem 便可被定義如下: 
min 
 

Vi Fj
ijij xd              (1) 
s.t. ,   1 Vix
Fj
ij 

            (2) 
  ,py
Fj
i 

             (3) 
    . ,    1 ,0, FjViyx jij           (4) 
 
限制式(2)確保了每個需求點只能由一個設施所供給。限制式(3)確保設施的數量必定為 p
個。在圖一的範例中，共有 7 個節點，並且將要選出其中之 3 個節點，當作中位點(median)或
稱作設施供給點。根據題目所給定之兩兩節點之間的距離，可以將問題轉換為一完全圖
(Complete weighted Graph)其中每個邊上之比重即為兩點之間的距離。我們可以輕易地找出一
組最佳解為{2、4、7}，其目標函數值為 16。在下面的章節，都將以圖 1 為範例進行詳細的方
法描述。 
  
 
10
法，主要是以 Orthogonal Array 均勻撒點搜尋的能力針對 Pmp 的元素獨立特性，以降低解空間
的方式進而達到使用較少的時間能求解較佳的解。 
 
3.5 Maximum clique problem 
最大子圖問題之目的為從一個有 n 個節點的圖形尋得最大彼此相連的完全子圖，其問題定
義如下: 一個無向圖 G = (V, E)，其中 V={v1, v2, …, vn}為端點集合，E={e1, e2, …, en}為邊集
合，如果 VC 且 C 中任兩端點都相連，則稱 C 是一個完全子圖(Clique)，如圖 2 所示，而最
大完全子圖問題就是要在無向圖 G 中找出有最大數量端點的完全子圖(Maximum Clique) 
 
 
圖2. Maximum Clique 圖示 
 
Glover 於 1989 年使用 Tabu Search[27][28]，以一個初始解為出發點，配合適當的鄰域結構
在解空間中移動並透過 tabu 的機制避免重覆搜尋相同的解。此外於 1993 年 Gendreau 與
Soriano[25]也提出使用 Tabu Search 來解最大完全子圖問題的方法；並於 1996 年再提出
Diversification strategies 來求解 Maximum Clique[58]。在 1990 年 Carraghan 及 Pardalos [10]提
出分枝界限法(branch and bound algorithm)，其基本做法是從端點編號由小至大的順序為出發
點，一路由端點編號小的開始加入，直到找出一個最大完全子圖，若是在加入端點的過程中，
發現剩餘可以加入的端點加上目前的完全子圖其大小已經無法比目前找到的最大完全子圖還
大時，此時便會停止繼續往下做，這個機制可以避免浪費時間去做不可能進步的區域，此方法
是一個很直覺的啟發式方法，但是當遇到點數量很多的問題時，便需要秏費非常多的時間來處
理，因此在 2002 年 Östergard[49]提出了改良這篇論文，主要是搜尋順序改由端點編號大到端
點編號小作搜尋，每一個端點每次只在比目前端點編號大的範圍中找出完全子圖，並紀錄成此
端點範圍內可找到的最大完全子圖。流程之中若發現目前可加入此完全子圖的端點數目就算加
入也無法比目前找到的最大完全子圖還大，就停止不做。這個演算法在邊密度較低的圖中運算
非常的快，但是隨著圖中邊的數量升高後，所需的運算時間將大量的增加。 
在 2003 年 Grosso 及 Locatelli[30]提出二階段的深度適應貪婪演算法(Deep Adaptive Greedy 
Seach)。第一階段會讓每一個端點都會當起始點，配合論文提出的改善制貪婪法則，可以找出
許多不同的完全子圖，經由統計後會挑選出部分的較佳端點。第二階段使用被挑選出來的端點
將被用來當起始點，並且使用 Adaptive Greedy Algorithm 來搜尋，並且起始點每一次重新開始
運算時會參考上一次所更新的解，來找這一次的最大的完全子圖(maximal clique)。此演算法對
於端點數目大，或是邊密度高的題目時，將會需要大量的計算時間，且不容易找到最佳解。 
在 2001 年，Battiti and Protasi[5]提出 Reactive Local Search (RLS)來解最大完全子圖問題，
此方法加強了 Local-Neighborhood-Search 的方法，當所有的發出的解都已經陷入了區域最佳解
時，RLS 會參考先前做過的資訊來判斷是否要要重新開始另一次的搜尋，並且 RLS 使用回饋
方式來控制 Tabu List 長度，主要是用來控制搜尋的廣度，最後再記錄並且觀察目前解的變化
  
 
12
4. 研究方法 
在本節我們將依要解的六個問題各自敘述其方法。 
4.1 Global Numerical Optimization Multi-Objective Numerical Optimization 
本研究使用 Multiple Trajectory Search 的方法做搜尋，此演算法首先先使用 Simulated 
Orthogonal Array (SOA)作一個均勻的取樣，挑出初始解，一開始初始解都放在 Foreground 的
集合中，接下來針對每個在 Foreground 的解所在的鄰近區域，執行一小段時間的 Local Search，
找出在該鄰近區域中較適合的 Local Search 方法，接下來才使用挑選出的 Local Search 方法在
該區域中做固定次數的搜尋並累加進步的次數。當每個區域都搜尋完成後，MTS 會挑選出前 
#ofForeground 個進步次數最多的解放進 Foreground，其他的解會放進 Background，每次搜尋
都只針對 Foreground 中的解作搜尋，在 Background 中的解就不做搜尋。當 Foreground 中的解
搜尋某一固定次數後，如果進步的次數不如原先在 Background 中解的進步次數，在 Foreground
中的解就會被放入 Background 中，而 Background 中原先進步次數較多的解就會被放入
Foreground 中，如此就確保在 Foreground 中的解能夠不斷的進步，完整的演算法如下所示： 
 
Multiple Trajectory Search 
/*Generate M initial solutions */ 
Build simulated orthogonal array SOAM×N 
For i = 1 to M 
 For j = 1 to N 
  Xi[j]=li+(ui-li)*SOA[i, j]/(M-1) 
 End For 
End For 
Evaluate function values of Xi’s 
For i=1 to M 
 Enable[i]←TRUE 
 Improve[i] ←TRUE 
 SearchRangeXi = (UPPER_BOUND-LOWER_BOUND)/2 
End For 
 
While ( #ofEvaluation ≦predefined_max_evaluation) 
For i=1 to M 
If Enable[i]=TRUE 
Then GradeXi←0 
For k =1 to #ofLocalSearch 
LS_TestGrade[k]←0 
End For 
For  j =1 to #ofLocalSearchTest 
     For k = 1 to #ofLocalSearch 
      LS_TestGrade[i]←LS_TestGrade[i]+ 
        LocalSearch[k](Xi, SearchRangeXi) 
     End For 
End For 
Choose the one with the best TestGrade and 
let it be LocalSearch[K]   /* K may be 1, 2, or 3 */ 
For j =1 to #ofLocalSearch 
     GradeXi←GradeXi+ 
LocalSearch[K](Xi, SearchRangeXi) 
End For 
End If 
End For 
For i = 1 to #ofLocalSearchBest 
  
 
14
 
Function LocalSearch[2](Xk, SR) 
If Improve[k]=FALSE 
 Then SR=SR/2 
 If SR < 1e-15 
  Then SR ←(UPPER_BOUND-LOWER_BOUND) *0.4 
 End If 
End If 
Improve[k] ←FALSE  
For l = 1 to N 
For i = 1 to N 
  r[i] ←Random{0,1,2,3} 
  D[i] ←Random{-1,1} 
 End For 
For i =1 to N 
  If r[i]=0 
   Then Xk[i] ← Xk[i]-SR*D[i] 
  End If 
End For 
   If Xk is better than current best solution 
    Then grade ← grade + BONUS1 
   Update current best solution 
 End If 
   If function value of Xk is the same 
  Then restore Xk to its original value 
   Else 
If function value of Xk degenerates 
    Then restore Xk to its original value 
      For i =0 to N 
    If r[i]=0 
      Then Xk[i] ← Xk[i]+0.5*SR*D[i]  
    End If 
   End For 
    If Xk is better than current best solution 
         Then grade ← grade + BONUS1 
     Update current best solution 
   End If 
        If function value of Xk has not been improved 
    Then restore Xk to its original value 
             Else 
         grade ← grade + BONUS2 
         Improve[k] ←TRUE 
   End If 
Else 
grade ← grade + BONUS2 
Improve[k] ←TRUE 
    End If 
 End If 
End For 
return grade 
 
Function LocalSearch[3](X,SR) 
For i = 1 to N 
X1←X’s ith coordinate is increased by 0.1 
 Y1←X’s ith coordinate is decreased by 0.1 
 X2←X’s ith coordinate is increased by 0.2 
  
 
16
End If 
Return TRUE 
 
而 4 種 LocalSearch 的演算法如下所示 
 
Function LocalSearch1(X, SearchRangeX) 
grade ←0 
For j = 1 to N     /*N is the number of dimensions*/ 
  r[j] ←Random{0,1,2,3} 
End For 
For i = 1 to #ofSamples  
For j = 1 to N     /*N is the number of dimensions*/ 
  If r[j]=0 
  Then α←Random[0,1) 
   If α<0.5 
      Then  s[j] ← X[j] + SearchRangeX[j]*Random{0,1,…,1000}/ 1000 
Else  s[j] ← X[j] –SearchRangeX[j] *Random{0,1,2…,1000} / 1000 
        End If 
Else s[j] = X[j] 
      End If 
End For 
    Evaluate the objective function values of s 
    AddtoApproximate←UpdateApproximationSet(s) 
    If AddtoApproximate Then grade ←grade + 1 
    If s dominates X 
    Then X←s 
         grade←grade+1  
    End If 
End For 
Return grade 
 
 
Function LocalSearch2(X, SearchRangeX) 
grade ←0 
For i = 1 to #ofSamples  
For j = 1 to N     /*N is the number of dimensions*/ 
  r[j] ←Random{0,1,2,3} 
  If r[j]=0 
  Then α←Random[0,1) 
     If α<0.5 
   Then  s[j] ← X[j] + SearchRangeX[j]*Random{0,1,…,1000}/ 1000 
   Else  s[j] ← X[j] –SearchRangeX[j] *Random{0,1,2…,1000}/ 1000 
        End If 
Else s[j] = X[j] 
End If 
End For 
    Evaluate the objective function values of s 
    AddtoApproximate←UpdateApproximationSet(s) 
    If AddtoApproximate Then grade ←grade + 1 
    If s dominates X 
    Then X←s 
         grade←grade+1  
    End If 
End For 
Return grade 
  
 
18
於取樣的點是在固定的 N /4 維度上或是在變動的 N /4 維度上。而 LocalSearch3 和 LocalSearch4
則是變動一個維度，也有此一維度是固定和變動的兩種方式。 
 
4.2 Flowshop Scheduling Problem 
本研究使用 Multiple Trajectory Search 的方法做搜尋，並利用它來解決以最小化 total 
flowtime 為目標的 Flowshop Scheduling Problem。多軌跡搜尋演算法的基本想法是在解空間中
盡量以均勻的方式產生多個起始解，然後再對這些解進行軌跡搜尋。因此，只要有某個起始解
與最佳解接近，我們就有較大的機會能找到它。在此先描述演算法的整體架構，之後再詳細說
明其中的機制。多軌跡搜尋演算法的架構如下所示： 
 
Procedure Multiple-Trajectory-Search 
Step 1. Set the number of initial solution Ps, the number of foreground solution Pf, termination 
condition max_loop, the number of max_fg and set loop to 1. 
Step 2. Produce the initial population Π that consists of Ps solutions by Random-Array(Ps). 
Step 3. Apply Trajectory-Search to the half part of Π that is taken in nondecreasing order by their 
total flowtime. 
Step 4. Set fg_loop to 1. 
Step 5. Choose Pf foreground solutions from Π and save it to the foreground list. 
Step 6. Apply Trajectory-Search to each solution in the foreground list. 
Step 7. fg_loop←fg_loop+1. 
Step 8. If fg_loop < max_fg, go to Step 5. Otherwise, loop ← loop +1. 
Step 9. If loop>max_loop then stop. Otherwise, go to Step 3. 
 
演算法一開始以隨機陣列(Random Array)產生初始族群(Initial Population)其中包含 Ps 個初
始解，詳細的方法將於 4.1 節描述。從 Step 3 到 Step 9，可視為一個世代(Generation)，於 Step 
3 中我們先將 population 依 total flowtime 的好壞排序，並對 total flowtime 較好的前 1/2 的解進
行 Trajectory-Search，此處的 Trajectory-Search 的方法將於 4.2 節介紹。接著，在 Step 5 中，我
們挑選 Pf 個解做為 foreground solutions，選擇的方式為：挑選在最近一次的 Trajectory-Search
中，進步最多的解，再依據 total flowtime 的好壞選擇較好且不重覆的解，做為 foreground 
solutions。挑選 foreground solutions 是為了優先搜尋較有潛力的區域，我們將反覆執行 Step 5
到 Step 8 共 max_fgs 次，每次只對 foreground solutions 進行 Trajectory-Search，然後再重新挑
選 foreground solution。此為避免落入區域最佳解(Local Optimum)並且增加其他區域被搜尋的
機會，若某個解 s 被選為 foreground solution，但是在執行 Trajectory-Search 之後並沒有進步，
我們就會限制它在最近的 T 次挑選中(Step 5)都不得被選為 foreground solution，且若 s 持續
maxT 次被選為 foreground solution 都沒進步，則限制 s 永遠不得再被挑選，其中 T 與 maxT 皆
為使用者所設定的參數。最後，若 loop 數大於使用者所設定的 max_loop 則停止，否則回到
Step 3。 
4.2.1 Random-Array procedure 
為了使得初始解能在解空間中均勻分佈，我們以直交陣列(Orthogonal Array)為基礎，設計
了隨機陣列(Random Array)並利用它來產生初始解。本研究以工作(Job)的排列(permutation π)
做為編碼來代表一組解，同時也代表工作的執行順序，舉例而言，假設有一個包含 6 個工作與
4 個機器(machine)的 flowshop scheduling problem，則 permutation π =[2, 3, 1, 6, 5, 4] 代表 6 個
工作在每台 machine 的執行順序為 J2, J3, J1, J6, J5, J4。隨機陣列主要的想法是希望產生一群初
始解，而這些初始解的每一個位置上，每個工作出現的次數能儘量相同。其演算法如下所示。
  
 
20
π代表起始解，c 代表 π的 total flowtime，SR 代表搜尋範圍(Search Range)。程序的一開始
會先設定切點串列(Cut Point List, CPL)的內容為 1 到 n-SR，代表可做為切點的位置。從 Step 3
到 Step 11 可視為一個世代，每代我們會從 CPL 中選一個切點 cp 做為搜尋的界線，將搜尋範
圍限定在 cp 到 cp+SR 之間。接著，在 Step 4 我們產生 m 個解於 R，產生的方式是使用交換操
作(Exchange operator)，表示為 Exch(x, y)，代表將解(solution)中位於 x 的工作與在位置 y 的工
作交換。首先，複製 m 個 π*，然後對每個 solution 執行 Exch(x, y)共 k 次，x 與 y 為介於 cp
與 cp+SR 之間隨機選擇的兩個值，k 為 2 <= k <= SR/2。換言之，在 R 中所有 solution 從位置
1 到位置 cp 之間與位置 cp+SR 到位置 n 之間的工作順序都是相同的，只有在位置 cp 與位置
cp+SR 間的工作順序會有所差異。接下來，從 Step 6 到 Step 9 可視為一個小迴圈。我們先對
每個 R 中的解執行 Single-Move-Local-Search，判斷是否有進步，若有進步則更新 π*，且重新
設定 CPL 並前往 Step 10，若沒有進步則對所有解執行 Multi-Move-Local-Search，然後回到 Step 
6 再 次 執 行 Single-Move-Local-Search ， 直 到 ls_loop 大 於 max_LST 。 有 關
Single-Move-Local-Search 以及 Multi-Move-Local-Search 將在 4.3 節中介紹。最後，若 loop 大
於(n-SR)/2，也就是嘗試過半數的切點之後，更新 max_LST 並傳回 π* 與 c* 。max_LST 代表
可執行 Multi-Move-Local-Search 的次數，每組解都有自己的 max_LST，初值為零，每次執行
Trajectory-search 後若有進步則將該值累加 2 否則減 1，最小為零，如此設計的目的是使進步
次數較多的解(可能也是品質較佳的解)可以做一次較大的變動，再重新開始搜尋，避免落入區
域最佳解，增加搜尋範圍。 
 
4.2.3 Local Search 
本研究使用的區域搜尋有兩種，Single-Move-Local-Search 與 Multi-Move-Local-Search。區
域搜尋(Local search)的目的是希望從一組解的鄰域(neighborhood)中找到更好的解。一組解 π
在解空間(solution space)中可被視為一個點，π的鄰域 N(π)定義為：對 π執行一個操作(operator)
後可到達的所有點所形成之集合。本問題可使用的操作的有交換操作(exchange operator)、插
入操作(insertion operator)與切斷修復操作(cut-repair operation)。交換操作表示為 Exch(x, y)，代
表將位於 x 的 job 與在位置 y 的 job 交換，而插入操作表示為 Ins(x, y)，代表將位於 x 的 job
插入在位置 y。切斷修復操作表示為 CutRepair(x, y)，以 x 決定一個切點 cp (cut point (x, x+1))，
若 y 小於 x 執行 Ins(y, x)，若 y 大於 x 則執行 Ins(y, x+1)，也就是將位於 y 的 Job 插入到 cut point
中為了讓區域搜尋能適應各種問題的實例 (Instance)並自動調整，本研究所提出的
Single-Move-Local-Search 使用上述的三種操作，先在較小的範圍內，以隨機的順序使用這三
種操作進行測試，選出效果最好的操作再進行真正的區域搜尋。為方便說明我們以 π 代表一
組解，c 代表 π的 total flowtime，參數 cp 則是代表本次搜尋的邊界，Single-Move-Local-Search
架構如下： 
 
Procedure Single-Move-Local-Search (π, c, cp) 
Step 1. π*←π, c*←c, set the number of loop=0 and ImproveTime[1..3] = 0; 
Step 2. Random choose a number lsType between 1 and 3. 
Step 3. If lsType=1 then execute Insertion-Search(π, c, cp, SR, SR/2) and go to Step 6. 
Step 4. If lsType=2 then execute Exchange-Search(π, c, cp, SR, SR/2) and go to Step 6. 
Step 5. If lsType=3 then execute Cut-Repair-Search(π, c, cp, SR, SR/2) and go to Step 6. 
Step 6. If c<c* then π*←π , c*←c , ImproveTime[lsType] = ImproveTime[lsType]+1 and 
loop=loop+1. 
Step 7. If loop < 10, go to Step 2. 
Step 8. Find the best kind of local search by compare the ImproveTime[1..3] and set its index to 
  
 
22
and t2≠c2 , t2≠c2+1.  
Step 5. Execute Cut-Repair operation CutRepair(c1, t1) and CutRepair(c2, t2)，Calculate the total 
flowtime after each Cut-Repair operator, let π be the new solution and c be the total 
flowtime of the new solution. 
Step 6. If c<c* then π*←π, c*←c. 
Step 7. loop = loop +1. 
Step 8. If loop < SR/2 then go to Step 4. Otherwise, stop and return π* and c*. 
 
4.3 Graph Coloring Problem 
本研究使用 Multiple Trajectory Search 的方法做搜尋，並利用它來解決以最小化著色數 k 的
圖形著色問題(graph coloring problem)。多軌跡搜尋演算法的基本想法是在解空間中盡量以均
勻的方式產生多個起始解，然後再對這些解進行軌跡搜尋。因此，只要有某個起始解與最佳解
接近，我們就有較大的機會能找到它。在此先描述演算法的整體架構，之後再詳細說明其中的
機制。多軌跡搜尋演算法的架構如圖 3 所示： 
 
},...,,{ 21 xsssS 
 
圖3. MTS 應用於 graph coloring problem 的簡易程式碼 
 
首先 MTS 會用隨機挑點著色的方式產生 x 個初始解，為了保証每個初始解都是合法的，在
產生的過程中，每個點必須選擇無衝突(conflict)的顏色類別來著色，若目前所有的顏色類別都
存在衝突，則必須使用新的顏色類別(行 1)。接下來便是整個 MTS 的搜尋程序(行 3-8)，MTS
中使用二個子程序來進行搜尋，一開始會對每個初始解進行區域搜尋(行 5)，期望讓初始解能
改進到不錯的區域最佳解。接下來再對每個初始解執行 Trajectory search(行 7)。整個程序會執
行 MaxRun 次。 
圖 4 為區域搜尋演算法的簡易程式碼，此演算法主要目的是強制將一個隨機顏色類別刪
除，並將該顏色類別的點全部移轉到其他的顏色類別，為了排除所有的衝突，此程序會不斷將
衝突的點重新塗色。整個演算法的執行說明如下: 一開始系統會隨機選取一個隨機的顏色類別
(行 5)，並將屬於此類別的所有點都放進 FreeV 集合中(行 6)，再將此顏色類別移除(行 7)。接
下來必須把FreeV集合中的點 v 重新指定成 c1顏色類別，直到FreeV為空集合時才結束(行 11)，
而 c1 的選擇方式必須依循最少衝突原則(行 13)，若點 v 被指定到 c1顏色類別後，c1存在衝突
的點，則將 c1記錄於 CF 集合中(CF 集合表示存在衝突的顏色類別)(行 15)。最後若 CF 不為空
集合表示這組解不合法(存在衝突的點)，因此必須再隨機從 CF 集合中挑選一個有衝突的顏色
類別 c2(行 17)，再把 c2 中衝突的點放進 FreeV 集合中(行 18)，並從 CF 集合中移除 c2(行 19)，
最後便重覆執行將 FreeV 集合中的點 v 重新指定顏色類別的動作(行 11-16)，而這個部份的停
止條件為 CF 為空集合(表示此為合法的解)或執行次數大於 1000(在有限時間內無法解決衝突)
  
 
24
js 
js 
js 
js 
js   
圖5. Trajectory search 應用於 graph coloring problem 之簡易程式碼 
 
4.4 P-median Problem(Pmp) 
本研究使用 Multiple Trajectory Search 的方法做搜尋，並利用它來解決 Pmp。多軌跡搜尋演
算法的基本想法是在解空間中盡量以均勻的方式產生多個起始解，然後再對這些解進行軌跡搜
尋。因此，只要有某個起始解與最佳解接近，我們就有較大的機會能找到它。在此先描述演算
法的整體架構，之後再詳細說明其中的機制。多軌跡搜尋演算法的架構如圖 6 所示。 
 
},...,,{ 21 xsssS 
 
圖6. MTS 應用於 P-median problem 的簡易程式碼 
 
一開始我們使用隨機方式產生 MTS 的初始解(行 1)並初始化二個集合 FC 與 FP (行 3-4)。
接下來便是整個 MTS 的搜尋程序(行 5-14)，MTS 中使用三個子程序來進行搜尋，一開始會對
每個初始解使用 FC 作為參數執行區域搜尋方法 OA_stuck_search(行 7)，期望讓初始解能改進
到不錯的區域最佳解。接下來再對每個初始解執行 m 次 Trajectory search(行 9)。當 x 個解都完
  
 
26
的影響力與其 level 的最佳設定。以 k 個因子，每個因子都有 2 個 level 的例子而言，若要進行
完全因子實驗（full-factorial experiment），需要進行 2k 次的實驗，而使用 Orthogonal Array 則
只需進行  )1log(2 k 次的實驗。如表 1 所示：一個有 3 個因子，每個因子都有兩個 level 的實驗，
我們以一個 )2( 34L 的 Orthogonal Array 來進行取樣並觀察實驗結果進行因子分析。令 iE 為第 i
次實驗的評估函數值；第 j 個因子的 level值為 k 時的主效果（The main effect of factor j with level 
k） jkF 定義為： 



n
i
ijkijk AEF
1
             (5) 
 
Input :  sin = 0111000
Orthogonal array interchange operator
Test No
Operator Factors
1        2        3
1
2
3
4
Evaluation
Value (Ei)
E1 = 24
E2 = 20
E3 = 16
E4 = 26
(2,1) (3,5) (4,7)
s1 = 0111000
s2 = 0100101
s3 = 1010001
s4 = 1001100
Solution is
0        0        0
0        1        1
1        0        1
1        1        0
Taguchi 
method
A10=E1+E2=44
A11=E3+E4=42
A10>A11 true
1        0        1
A20=E1+E3=40
A21=E2+E4=46
A20<A21 false
A30=E1+E4=50
A31=E2+E3=36
A30>A31  true
s5 = 1010001 E5 = 16
Output :  sout = 1010001  
圖9. OA_interchange 範例 
 
其中 ijkA 代表，若第 i 次的實驗中第 j 個因子選用的 level 為 k，則 ijkA 設為 1，否則為 0。計
算的結果，若實驗設計上評估函數是愈大愈好的話，則當 10 jj FF  就代表第 j 個因子的 level
設為 0 對評估函數的貢獻度較大，反之，若 10 jj FF  則代表 level 設定為 1 較佳。圖 9 為
OA_interchange 應用於圖 1 的範例示意圖，而圖 10 為 OA_interchange 之簡易程式碼。 
 
 
圖10. OA_interchange 之簡易程式碼 
 
  
 
28
},...,,{ 21 xsssS 
 
圖13. MTS 應用於 Maximum Clique Problem 之簡易程式碼 
 
圖 14 為 Difference_Initial 的簡易程式碼，此程序會初始化每個初始解(行 4)，並隨機挑選
三個頂點放入初始解中 (行 6 - 12)，值得注意的是每個初始解的三個頂點都是不重覆的(行
12)，因此可保証每個初始解都是不同的，最後會讓每個初始解的三個頂點當成種子開始發展
成 max clique (行 13)。 
 
 
圖14. Difference_Initial 的簡易程式碼 
 
圖 15 為區域搜尋方法(Drop_Add_LS)的簡易程式碼，依其執行順序分砍點、加點與更新三
個部份。砍點動作依更新狀態又分為小範圍(Small Drop)、中範圍(Middle Drop)與大範圍(Large 
Drop)三種不同的方法。小範圍砍點必須先決定砍點數量 r (行 7)，r 是隨機取得(介於 1 到的
s' 的 20% 之 clique 數量)，並隨機從 s' 移除 r 個點(行 8)。中範圍砍點也必須先決定砍點數
量 r (行 11)，r 也是隨機取得(介於 s' 的 20% 之 clique 數量到 s' 的 50% 之 clique 數量)，而
每個被移除的點均以 50%機率決定使用 heuristic 或隨機方法，heuristic 是以每個點的 degree
來排序，並移除 degree 最小的點(若有多個，則以隨機的方式挑選)(行 12)。大範圍砍點則是採
用 swap 的方式，也就是加入一個不存在於 s'的點 v 並從 s'移除與 v 不相連的點，為了避免 v
與 s'中的點完全不相連，因此必須限制 v 與 s'至少需要有 r 個點相連，而 r 也是隨機取得(介
於 s' 的 20% 之 clique 數量到 s' 的 50% 之 clique 數量)。砍點之後的 s' 將執行 FindPossibleAdd
程序加點成為 max clique(行 20)。最後更新種子 s (行 21 – 26)。 
 
  
 
30
 
圖17. Create Sub Solution 應用於 Maximum Clique Problem 之簡易程式碼 
 
  
 
32
表3. 500D 
 [72] [38] [9] [46] MTS [74] [77] [67] 
F1 
Mean 4.2974e-13 8.45e+01 9.3223e-14 2.835E-12 0.0000E+00 2.0958e-09 0 2.2737E-13 
Std 3.3145e-14 6.40e+00 2.7847e-14 3.324E-13 0.0000E+00 4.6182e-09 0 0.0000E+00 
F2 
Mean 6.6663e+01 4.35e+01 8.4648 9.138E+01 7.3194E-06 7.5737e+01 6.8934 e+01 2.7152E-10 
Std 5.6992e+00 5.51e-01 1.7360 9.134E+00 2.2418E-06 3.0465 2.0144 e+00 4.3927E-11 
F3 
Mean 9.2466e+02 5.77e+04 6.6115e+02 1.273E+03 5.0366E-03 1.8130e+03 4.6712e+07 8.6745E+02 
Std 1.7263e+02 8.04e+03 8.2652e+01 1.040E+03 2.5136E-02 2.7425e+02 5.8714e+06 1.8731E+02 
F4 
Mean 1.7933e-11 3.49e+03 1.4688e-12 4.732E+03 0.0000E+00 3.6403e+02 1.6088e+03 8.5569E+02 
Std 6.3110e-11 1.12e+02 3.4839e-12 6.512E+02 0.0000E+00 5.2353e+01 1.0429e+02 5.0784E+01 
F5 
Mean 2.1259e-13 1.64e+00 4.2064e-14 7.887E-04 0.0000E+00 6.9013e-04 0 1.1369E-13 
Std 2.4777e-14 4.69e-02 1.4492e-14 2.821E-03 0.0000E+00 2.4149e-03 0 0.0000E+00 
F6 
Mean 5.3433e-13 6.64e+00 1.4893e-13 1.984E+01 0.0000E+00 4.8041e-01 2.0022e+00 3.1264E-13 
Std 7.0100e-14 4.49e-01 1.1812e-13 2.106E-02 0.0000E+00 5.7362e-01 9.6612e-02 5.3550E-29 
F7 
Mean -7.4350e+03 -3.51e+03 -6.8816e+03 -6.073E+03 -7.0810E+03 -5.7487e+03 -4.1999e+03 -6.8276E+03
Std 8.0308e+00 2.10e+01 2.9375e+01 7.699E+01 1.5485E+01 1.8370e+02 1.2949e+01 4.8356E+01 
 
  
 
34
Std 2.0603e-005 7.0227e-003 1.0432E-03 1.4599e-06 3.6006E-05 0.0 0.9188e-6 
F4 
Mean 9.5499e-003 7.3128e-002 -2.2774E-03 1.0252e-02 -8.2653E-03 -0.9664e-1 -0.6721e-2 
Std 2.0103e-002 1.3753e-002 2.5926E-03 2.0423e-02 2.9059E-05 0.0 0.0 
F5 
Mean 3.6693e-004 3.2128e-002 1.1376E-03 3.5230e-03 -1.5774E-04 -0.5184e-4 -0.5184e-4 
Std 1.1179e-003 1.1163e-002 4.7492E-04 1.0547e-03 2.1885E-05 0.0 0.0 
F6 
Mean -1.5914e-004 5.6161e-003 9.1108E-03 -1.3804e-03 -7.1405E-04 -0.1749e-2 -0.1655e-2 
Std 8.8030e-004 3.7729e-003 4.7006E-03 2.8028e-04 3.8317E-04 0.0 0.2380e-3 
F7 
Mean -3.1869e-003 9.8829e-002 8.8991E-03 -8.9053e-06 -8.9649E-06 -0.1009e-4 -0.1009e-4 
Std 7.3642e-003 1.4204e-002 9.1123E-04 4.8052e-08 3.5966E-08 0.0 0.0 
表6. R-INDICATOR FOR FUNCTION 8-13 WHEN M=3 
 [75] [76] MTS [73] [40] [57] [44] 
F8 
Mean -1.9628e-005 4.9672e-006 1.1774E-04 -2.8157e-04 -8.4712E-05 -0.4208e-3 -0.4053e-3 
Std 2.6878e-005 2.6578e-005 2.0628E-04 1.3952e-05 1.3424E-06 0.0 0.2831e-4 
F9 
Mean 2.7135e-004 2.9092e-004 2.2640E-04 9.2015e-04 1.9330E-04 -0.6911e-7 -0.5660e-6 
Std 5.4702e-005 3.2116e-005 3.2211E-05 7.7980e-04 3.4578E-05 0.0 0.1265e-9 
F10 
Mean 1.8985e-004 5.1121e-004 6.2114E-05 1.6606e-05 4.8313E-07 -0.4961e-6 -0.4961e-6 
Std 7.6867e-005 3.5459e-005 2.3520E-05 2.8413e-06 3.6087E-07 0.0 0.0 
F11 
Mean 5.4831e-002 7.1993e-002 4.6296E-02 4.1279e-02 2.8693E-02 0.1833e-1 0.5407e-1 
Std 1.1323e-003 1.9769e-003 9.7399E-04 1.8740e-03 1.8812E-03 0.2362e-2 0.3974e-3 
F12 
Mean 2.8850e-003 5.4953e-003 2.1655E-02 -8.7998e-03 -2.6206E-04 -0.9204e-2 -0.9247e-2 
Std 8.8349e-004 2.6065e-003 2.4124E-03 1.9756e-04 9.1485E-04 0.1685e-2 0.2164e-2 
F13 
Mean 2.6125e-003 2.5961e-003 9.8289E-03 1.9736e-03 3.6178E-03 -0.3245e-2 -0.3124e-2 
Std 1.6914e-003 1.3200e-003 2.3963E-03 5.6658e-04 1.8337E-03 0.2301e-2 0.1317e-2 
表7. R-INDICATOR FOR FUNCTION 8-13 WHEN M=5 
 [75] [76] MTS [73] [40] [57] [44] 
  
 
36
Std 2.5914e-003 1.1163e-002 1.3727E-02 8.4295e-04 1.4530E-03 0.0 0.6896e-3 
F7 
Mean 1.0445e-003 2.5147e-001 2.9732E-02 -9.7364e-04 -3.7736E-03 -0.2965e-4 -0.2965e-4 
Std 1.6705e-002 3.8120e-002 1.3548E-03 5.3911e-07 1.1596E-06 0.0 0.0 
 
 
表9. HYPER VOLUME - INDICATOR FOR FUNCTION 8-13 WHEN M=3 
 [75] [76] MTS [73] [40] [57] [44] 
F8 
Mean 2.9473e-004 5.8029e-004 2.0035E-03 -2.5219e-03 -2.0953E-05 -0.3410e-2 -0.3173e-2 
Std 1.7478e-004 1.9354e-004 2.1732E-03 7.2154e-05 2.4065E-06 0.0 0.4823e-3 
F9 
Mean 4.2254e-003 4.7266e-003 1.4709E-03 1.4730e-02 1.5259E-03 0.1716e-6 -0.1775e-5 
Std 2.9261e-003 9.8537e-004 4.2398E-04 4.5110e-03 5.9954E-04 0.0 -0.4961e-9 
F10 
Mean 2.9342e-003 1.4568e-002 1.9956E-04 2.0089e-06 -1.4816E-07 -0.9516e-6 -0.9516e-6 
Std 3.1700e-003 1.9145e-003 1.0409E-04 1.2518e-06 3.7259E-09 0.0 0.0 
F11 
Mean 2.8858e-001 3.7213e-001 2.5296E-01 2.1716e-01 1.6826E-01 0.9692e-1 0.2775e-0 
Std 5.4276e-003 8.8523e-003 3.9664E-03 9.4187e-03 1.0301E-02 0.1247e-1 0.1800e-2 
F12 
Mean 7.6497e-002 8.2213e-002 1.8648E-01 -4.6597e-02 3.7447E-02 -0.8476e-1 -0.1681e-1 
Std 5.5866e-003 1.3225e-002 1.1354E-02 1.1639e-03 3.3994E-03 0.1600e-1 0.1649e-1 
F13 
Mean 5.1874e-002 5.3007e-002 1.0868E-01 -7.0871e-02 5.0744E-02 -0.1269e-0 -0.1265e-0 
Std 8.7839e-003 9.0272e-003 1.8133E-02 1.7834e-03 1.1031E-02 0.1274e-1 0.7819e-1 
表10. HYPER VOLUME - INDICATOR FOR FUNCTION 8-13 WHEN M=5 
 [75] [76] MTS [73] [40] [57] [44] 
F8 
Mean 8.6322e-005 1.1510e-004 1.3289E-03 -8.3990e-04 -2.5991E-04 -0.4521e-4 -0.4521e-4 
Std 3.6012e-005 1.9525e-004 3.5719E-04 4.2158e-07 2.7681E-04 0.0 0.0 
F9 
Mean 7.4833e-004 1.3963e-004 7.2187E-04 8.6013e-03 4.1870E-04 0.1641e-7 0.2968e-6 
Std 2.7683e-004 2.4653e-005 6.8496E-05 3.7755e-04 9.9036E-05 0.3896e-7 0.1566e-5 
F10 Mean 1.2401e-003 1.2602e-003 1.9433E-04 1.8440e-06 1.6230E-06 -0.1464e-7 -0.1464e-7 
  
 
38
Yamada 與 Reeves[71]的方法是以基因演算法為基礎，參考 path re-linking 的概念，提出新的交
配操作(crossover operator)與突變操作(mutation operator)，分別稱為 Multi-step crossover fusion
與 Multi-step mutation fusion。Yamada 與 Reeves[71]同樣採用 Taillard[59]所提出的效能評估測
試題組，但只有對前 5 組 instance 進行測試（共 50 個題目）。前 30 個 n 為 20 的題目，該方法
所找到的最佳解與表 2 我們所找到的最佳解相同，其實驗執行於 HP workstation，花費的時間
在數秒鐘到數分鐘之間，但精確的時間在文獻中並沒有提供。Yamada 與 Reeves[71]針對後面
的兩組 50×5（ta031~ta040）與 50×10（ta041~ta050）的題目分別花費了 45 與 90 分鐘進行長
時間的測試。因此，我們直接選擇後面的兩組 50×5 與 50×10 的題目做測試並與他們做比較。 
表12. MULTIPLE TRAJECTORY SEARCH 與其他方法之比較 
n×m LR M-MMAS PACO PSO MTS n×m LR M-MMAS PACO PSO MTS
Min Min Min Min Min Avg Min Min Min Min Min Avg
20,5 14226 14056 14056 14033 14033 14033.9 50,20 129095 127348 126962 128622 126336 126785.7
15446 15151 15214 15151 15151 15161.4 122094 121208 121098 122173 119655 120022.9
13676 13416 13403 13301 13301 13312.8 121379 118051 117524 118719 116643 117251.1
15750 15486 15505 15447 15447 15454.4 124083 123061 122807 123028 120858 121605.7
13633 13529 13529 13529 13529 13529.0 122158 119920 119221 121202 118914 119139.2
13265 13139 13123 13123 13123 13123.0 124061 122369 122262 123217 120896 121406.7
13774 13559 13674 13548 13548 13555.0 126363 123609 125351 125586 123418 123847.7
13968 13968 14042 13948 13948 13950.0 126317 124543 124374 125714 122952 123379.3
14456 14317 14383 14295 14295 14295.0 125318 124059 123646 124932 122130 122758.2
13036 12968 13021 12943 12943 12952.9 127823 126582 125767 126311 124461 124929.8
20,10 21207 20980 20958 20911 20911 20920.4 100,5 256789 257025 257886 254762 254718 255464.1
22927 22440 22591 22440 22440 22440.0 245609 246612 246326 245315 243510 244044.0
20072 19833 19968 19833 19833 19833.0 241013 240537 241271 239777 238729 239487.0
18857 18724 18769 18710 18710 18740.1 231365 230480 230376 228872 228539 229012.5
18939 18644 18749 18641 18641 18646.3 244016 243013 243457 242245 241405 241836.6
19608 19245 19245 19249 19245 19263.6 235793 236225 236409 234082 233459 234055.6
18723 18376 18377 18363 18363 18364.3 243741 243935 243854 242122 241109 241800.5
20504 20241 20377 20241 20241 20250.6 235171 234813 234579 232755 231699 232309.8
20561 20330 20330 20330 20330 20330.0 251291 252384 253325 249959 248990 249696.8
21506 21320 21323 21320 21320 21325.9 247491 246261 246750 244275 243807 244225.9
20,20 34119 33623 33623 34975 33623 33638.8 100,10 306375 305004 305376 303142 301380 302795.6
31918 31604 31597 32659 31587 31587.0 280928 279094 278921 277109 276837 277976.7
34552 33920 34130 34594 33920 33920.0 296927 297177 294239 292465 290579 292043.4
32159 31698 31753 32716 31661 31684.1 309607 306994 306739 304676 303941 305574.0
34990 34593 34642 35455 34557 34575.2 291731 290493 289676 288242 288101 288727.2
32734 32637 32594 33530 32564 32566.5 276751 276449 275932 272790 272229 273994.8
33449 33038 32922 33733 32922 32993.0 288199 286545 284846 282440 282663 283404.1
32611 32444 32533 33008 32412 32428.0 296130 297454 297400 293572 294355 295710.5
34084 33625 33623 34446 33600 33602.4 312175 309664 307043 305605 304560 306225.5
32537 32317 32317 33281 32262 32268.2 298901 296869 297182 295173 294782 296013.3
50,5 65663 65768 65546 65058 64817 64905.2 100,20 383865 373756 372630 374351 371136 372195.4
68664 68828 68485 68298 68112 68219.1 383976 383614 381124 379792 377476 378923.5
64378 64166 64149 63577 63226 63435.2 383779 380112 379135 378174 375307 376515.1
69795 69113 69359 68571 68381 68522.2 384854 380201 380765 380899 377936 379535.9
70841 70331 70154 69698 69504 69589.7 383802 377268 379064 376187 373378 374924.8
68084 67563 67664 67138 66966 67066.3 387962 381510 380464 379248 375238 377890.4
67186 67014 66600 66338 66289 66397.2 384839 381963 382015 380912 377774 379769.7
65582 64863 65123 64638 64381 64531.1 397264 393617 393075 392315 388641 390587.3
63968 63735 63483 63227 62988 63116.9 387831 385478 380359 382212 379310 381072.9
70273 70256 69831 69195 68811 69145.3 394861 387948 388060 386013 383125 384427.5
50,10 88770 89599 88942 88031 87501 87899.8
85600 83612 84549 83624 83109 83525.1
82456 81655 81338 80609 80177 80499.1
89356 87924 88014 87053 86758 87024.2
88482 88826 87801 87263 86841 87090.5
89602 88394 88269 87255 86759 87093.7
91422 90686 89984 89259 89238 89461.7
89549 88595 88281 87192 86832 87343.3
88230 86975 86995 86102 85983 86235.7
90787 89470 89238 88631 88196 88708.5  
 
這次實驗的 Multiple Trajectory Search 參數設定，將 Ps 設為 50、Pf 設為 10、max_loop 設為
  
 
40
5.3 Graph Coloring Problem 
本研究以 C++實作所提出的多軌跡搜尋演算法(Multiple Trajectory Search)，測試的平台為
DELL 筆記型電腦，使用的 CPU 為 Intel Core Duo 1.6GHz，記憶體為 2GB，作業系統為 Windows 
XP。為了比較 Multiple Trajectory Search 的效能，我們使用 MTS 求解基準測試問題中較困難
的 16 題目，並將實驗結果與下面三個方法進行比較:分別為 1996 年 Culberson 提出的貪婪演
算法 I_GREEDY[13]、1996 年 Glover 提出的分支搜尋法 T_B&B[29]與 2004 年 Barbosa 提出的
演化式方法 Evolve_P[4]。 
表15. MULTIPLE TRAJECTORY SEARCH ALGORITHM 與其他三個方法之比較 
Problem Best Known
I_GREEDY T_B&B Evolve_P MTS 
AVG_C Best_C Best_C Best_C AVG_C AvgT(s)
R125.1 5 5.0  5 5 5 5 20.516
R125.1c 46 46.0  46 46 46 46 19.869
R125.5 35 36.9  36 36 36 36 24.631
R250.1 8 8.0  8 8 8 8 19.731
R250.1c 64 64.0  65 64 64 64 35.48 
R250.5 65 68.4  66 65 68 68.4 51.414
flat300_26_0 26 37.1  41 28 33 33.1 124.203
flat300_20_0 20 20.2  39 23 20 20 777.18
flat300_28_0 31 37.0  41 29 33 33 124.086
DSJC125.5 17 18.9  20 20 18 18 58.364
DSJC250.5 28 32.8  35 29 30 30 105.559
DSJC500.5 48 58.0  65 59 54 54 209.22
le450_15a 15 17.9  16 17 16 16 145.122
le450_15b 15 17.9  15 17 16 16 141.472
le450_15c 15 25.6  23 25 21 21.6 163.097
le450_15d 15 25.8  23 25 20 21.6 136.536
 
比較結果列在表 15，其中 MTS 對每個題目均實驗 10 次，並列出最佳解(Best_C)、平均解
(AVG_C)與平均時間(AvgT)，而比較的三個方法則只列出最佳解或平均解(在論文中未明列求
解時間)。而實驗參數部份，初始解數量 x=10，搜尋時每次撒點數量 z=10，執行 trajectory search
的次數 m=4， trajectory search 內部執行的次數 m1=4，而區域搜尋的停止條件參數
maxstuck1=10，maxstuck2=5。由表 15 的結果顯示在解題品質上，MTS 對於 16 個題目，有 11
個是四個方法中解到最好的而且由平均解的數據可觀察到 MTS 的求解能力是非常穩定的。 
 
5.4 P-median Problem 
本研究以 C++實作所提出的多軌跡搜尋演算法(Multiple Trajectory Search Algorithm)，測試
的平台為個人電腦，使用的 CPU 為 Intel Core 2Duo 2.66GHz，記憶體為 2GB，作業系統為
windows XP。為了比較 Multiple Trajectory Search Algorithm 的效能，我們使用 MTS 求解基準
測試問題中的 40 個題目，並將實驗結果與下面 5 個方法進行比較:分別為 1993 年 Beasley 提出
的演算法 Lagrangean heuristics [7]，1997 年 Hansen 與 Mladenovic 提出的 RVNS[33]，2001 年
  
 
42
次全命中)，以解題品質來說 MTS 明顯優於其他所有的方法，以解題時間而言，MTS 在許多
大題目上的時間花費亦明顯少於其他方法。 
 
5.5 Maximum Clique Problem 
 
表17. MULTIPLE TRAJECTORY SEARCH ALGORITHM 與其他四個方法之比較 
Instance RLS[1] VNS[10] EA[15] SA[5] MTS 
Num problem name # of nodes Opt. |C| CPU(s) |C| CPU(s) |C| CPU(s) |C| CPU(s) |C| CPU(s) 
1 C125.9 125 34 34 0.01 34 0.02 34 1.5 34 <1 34 2.031 
2 Keller4 171 11 11 0 11 0.01 11 1.5 11 <1 11 0.656 
3 brock200_2 200 12 12 18.54 12 1.05 12 1.8 12 8 12 0.767 
4 brock200_3 200 15 - - - - - - 14 2 15 1.087 
5 brock200_4 200 17 17 37.62 17 6.8 17 2 16 1 17 1.413 
6 Gen200-p0.9_44 200 44 44 0.07 44 0.91 44 2.1 44 21 44 3.669 
7 Gen200-p0.9_55 200 55 55 0.03 55 0.24 55 3.9 55 1 55 4.089 
8 C250.9 250 44 44 0.06 44 0.22 44 2.9 44 4 44 4.441 
9 Hamming8-2 256 128 - - - - - - 128 3 128 11.28 
10 Hamming8-4 256 16 - - - - 16 1 16 <1 16 0.986 
11 P_hat300_1 300 8 8 0.04 8 0.02 8 2.4 8 <1 8 0.655 
12 P_hat300_2 300 25 25 0.01 25 0.01 25 2.3 25 <1 25 2.894 
13 P_hat300_3 300 36 36 0.04 36 0.07 36 2.7 36 2 36 3.972 
14 brock400_2 400 29 29 81.24 29 57.19 25 3.7 25 29 25 3.12 
15 brock400_3 400 31 - - - - - - 25 26 31 3.533 
16 brock400_4 400 33 33 209.67 33 36.9 33 3.9 25 26 33 3.128 
17 Gen400-p0.9_55 400 55 55 2.32 55 34.28 55 4.2 55 31 55 10.948 
18 Gen400-p0.9_65 400 65 65 0.1 65 1.22 65 4.2 65 28 65 7.28 
19 Gen400-p0.9_75 400 75 75 0.1 75 1 75 4.4 75 75 75 8.789 
20 C500.9 500 57 57 5.4 57 3.62 56 5.7 57 59 56 9.041 
21 DSJC500.5 500 14 13 0.37 13 0.89 13 4.7 13 17 13 1.644 
22 P_hat700_1 700 11 11 0.36 11 0.52 11 6.6 11 18 11 1.472 
23 P_hat700_2 700 44 44 0.05 44 0.05 44 8.9 44 3 44 10.508 
24 P_hat700_3 700 62 62 0.07 62 0.06 62 13.1 62 12 62 16.323 
25 Keller5 776 27 27 0.33 27 0.38 27 10.7 27 143 27 3.763 
26 brock800_2 800 24 21 9.15 21 11.78 21 8.9 21 124 21 4.481 
27 brock800_4 800 26 21 12.92 21 43.28 21 8.9 21 125 21 4.237 
28 C1000.9 1000 68 67 80.4 68 70.96 67 21.2 68 222 64 16.825 
29 DSJC1000.5 1000 15 15 12.45 15 14.58 15 12.1 15 363 15 2.136 
Hit  21  22  20  21   23   
Not hit  4  3  6  8   6   
Not run  4  4  3  0   0   
 
本研究以 C++實作所提出的多軌跡搜尋演算法(Multiple Trajectory Search Algorithm)，測試
的平台為個人電腦，使用的 CPU 為 Intel Core 2Duo 2.66GHz，記憶體為 2GB，作業系統為
windows XP。為了比較 Multiple Trajectory Search Algorithm 的效能，我們使用 MTS 求解基準
測試問題中的 29 個題目，並將實驗結果與下面四個方法進行比較:分別為 2001 年 Battiti 與
Protasi 提出的演算法 Reactive Local Search [5]，2004 年 Hansen、Mladenovic 與 Urosevic 提出
  
 
44
6. 結論 
本研究提出了一個新的超探索(Metaheuristic)演算法，名為多軌跡搜尋演算法(Multiple 
Trajectory Search Algorithm)。多軌跡搜尋演算法的基本想法是在解空間中盡量以均勻的方式產
生多個起始解，然後再對這些解進行軌跡搜尋(Trajectory-Search)。因此，只要有某個起始解與
最佳解接近，我們就有較大的機會能找到它。提出的 Trajectory-Search 是以某一個解為基礎，
隨機在其限定的某個鄰域(Neighborhood)中產生一些相似的解，然後再對這些解進行區域搜尋
(Local Search)，最後以結果最好的解取代原來的解。實驗的結果顯示，多軌跡搜尋演算法的效
能很好。 
最 後 本 報 告 以 六 個 最 佳 化 問 題 Global Numerical Optimization 、 Multi-Objective 
Optimization、Flowshop Scheduling Problem、Graph Coloring Problem、P-median Problem 與
Maximum Clique Problem 對 MTS 做基準測試，上述的六個問題均為典型的最佳化題目，每個
題目都具有指標性與代表性，而我們使用報告中所提出的 MTS 架構來設計演算法應用於五個
問題，均能簡單有效的搜尋到非常不錯的結果，尤其是在數值化編碼的問題更是參與過國際
IEEE 會議的比賽中拿到第一名的成績。在順序排列編碼的問題中，Flowshop Scheduling 
Problem 也詳列了許多突破非常多題目，更新了不少題目的目前已知最佳解。而在二進制編碼
的問題中，P-median Problem 也能在時間上勝過目前許多已發表在期刊上的方法。因此本報告
所提出的 MTS 在其能力上的確是能符合我們當初的提案理念，當然在未來的研究方向，我們
仍會思考如何再強化 MTS 的搜尋能力，並將其應用於更多的最佳化問題。 
 
 
  46
[22]. Garey, M.R., Johnson, D.S., and So, H.C., 1976. An application of graph coloring to printed circuit 
testing”, IEEE Trans. on Circuits and Systems, vol. CAS-23, pp. 591–599. 
[23]. Garey, M., Johnson, D., 1979. Computers and intractability: A guide to the theory of 
NP-completeness, W.H. Freeman and Company, New York. 
[24]. Galinier, P., and Hao, J.K., 1999. Hybrid evolutionary algorithms for graph coloring, Journal of 
Combinatorial Optimization, vol. 3, pp. 379–397. 
[25]. Gendreau, M., Soriano, P., Salvail, L., 1993. Solving the maximum clique problem using a tabu 
search approach, Annals of Operations Research, vol.41, pp.385-403. 
[26]. Geng, X., Xu, J., Xiao, J., and Pan, L., 2007. A Simple simulated annealing algorithm for 
maximum clique problem, Information Sciences, pp.5064-5017. 
[27]. Glover, F., 1989. Tabu search, Part 1, ORSA Journal on Computing, pp.190-206. 
[28]. Glover, F., 1990. Tabu search, Part 2, ORSA Journal on Computing, pp.4-32. 
[29]. Glover, F., Parker, M., and Ryan, J., 1996. Coloring by tabu branch and bound, in Cliques, 
Coloring, and Satisfiability: Second DIMACS Implementation Challenge, D.S. Johnson and M.A. 
Trick (Eds.), American Mathematical Society: Providence, RI, pp. 285–307. 
[30]. Grosso, A., Locatelli, M., 2004. Combining Swaps and Node Weights in an Adaptive Greedy 
Approach for the Maximum Clique Problem, Journal of Heuristics, vol.10, pp.135–152. 
[31]. Hansen, P., and Mladenovicm, N., 1992. Two algorithms for maximum cliques in dense graphs, 
Technical Report GERAD Research Report G-92-18. 
[32]. Hansen, P., Mladenovic, N., and Urosevic, D., 2004. Variable neighborhood search for the 
maximum clique, Discrete Applied Mathematics, vol.145, pp.117-125. 
[33]. Hansen, P., and Mladenovic, N., 1997. Variable neighbor search for P-median problem, Elsevier, 
Location Science, Vol.5, No.4, pp.207.226. 
[34]. Hansen, P., Mladenovic, N., and Perez-Brito, D., 2001. Variable neighborhood decomposition 
search, Journal of Heuristics, Vol.7, No.3, pp.335-350. 
[35]. Hertz, A., and de Werra, D., 1987. Using tabu search techniques for graph coloring, Computing, 
vol. 39, pp. 345–351 
[36]. Ho, J.C., 1995. Flowshop sequencing with mean flow time objective. European Journal of 
Operational Research 81, 571-578. 
[37]. Ho, S.Y., Chen, J.H., 2000. A GA-based systematic reasoning approach for solving traveling 
salesman problems using an orthogonal array crossover. in Proceeding of The Fourth 
International IEEE Conference/Exhibition on High Performance Computing in Asia-Pacific 
Region, Beijing, China, pp. 659-663. 
[38]. Hsieh, S. T., Sun, T. Y., Liu, C. C. and Tsai, S. J., 2008. Solving Large Scale Global Optimization 
Using Improved Particle Swarm Optimizer, Proceedings of 2008 IEEE Congress on Evol. Comput. 
[39]. Huang, V. L., Qin, A. K., Deb, K., Zitzler, E., Suganthan, P. N., Liang, J. J., Preuss, M., Huband, S., 
2007. Problem Definitions for Performance Assessment on Multi-objective Optimization 
Algorithms, Special Session on Constrained Real-Parameter Optimization, Technical Report, 
Nanyang Technological University, Singapore. Available: http://www.ntu.edu.sg/home/EPNSugan/ 
[40]. Huang, V. L., Qin, A. K., and Suganthan, P. N., 2007. Multi-objective Optimization based on 
Self-adaptive Differential Evolution Algorithm, Proceedings of 2007 IEEE Congress on Evol. 
Comput. 
[41]. Johnson, S.M, 1954. Optimal two-and-three stage production schedules with setup times included. 
Naval Research Logistics Quarterly 1, 61-68. 
[42]. Johnson, D.S., Aragon, C.R., McGeoch, L.A., Schevon, C., 1991. Optimization by simulated 
annealing: An experimental evaluation, Part II: Graph coloring and number partitioning”, 
Operations Research, vol. 39, pp. 378–406. 
[43]. Kariv, O., and Hakimi, S.L., 1969. An algorithmic approach to network location problems; part 2. 
The p-medians, SIAM Journal on Applied Mathematics, Vol.37, pp.539-560. 
  48
[66]. Wang, C., Chu, C., Proth, J.-M., 1997. Heuristic approaches for CiFmn ////  scheduling 
problems. European Journal of Operational Research 96, 636-644. 
[67]. Wang, Y., and Li, B., 2008. A Restart Univariate Estimation of Distribution Algorithm:Sampling 
under Mixed Gaussian and L´evy probability Distribution, Proceedings of 2008 IEEE Congress on 
Evol. Comput. 
[68]. Whitaker, R., 1983. A fast algorithm for the greedy interchange of large-scale clustering and 
median location problems, INFOR, Vol.21, pp.95-108. 
[69]. Woo, D.S., Yim, H.S., 1998. A heuristic algorithm for mean flowtime objective in flowshop 
scheduling. Computers and Operational Research 25, 175-182. 
[70]. Xu, X., Ma, J., and Lei, J., 2007. An Improves Ant Colony Optimization for the maximum clique 
problem, Proceedings of the Third International Conference on Natural Computation, August 
27-27, China, pp.766-770, IEEE, ICNC 2007. 
[71]. Yamada, T., Reeves, C.R., 1998. Solving the Csum permutation flowshop scheduling problem by 
genetic local search. In: Proceedings of 1998 IEEE International Conference on Evolutionary 
Computation, pp. 230-234. 
[72]. Yang, Z., Tang, K., and Yao, X., 2008. Multilevel Cooperative Coevolution for Large Scale 
Optimization, Proceedings of 2008 IEEE Congress on Evol. Comput. 
[73]. Zamuda, A., Brest, J., Boskovic, B. and Zumer, V., 2007. Differential Evolution for Multiobjective 
Optimization with Self Adaptation, Proceedings of 2007 IEEE Congress on Evol. Comput. 
[74]. Zamuda, A., Brest, J., Boskovic, B., and Zumer, V., 2008. Large Scale Global Optimization Using 
Differential Evolution With Self-adaptation and Cooperative Co-evolution, Proceedings of 2008 
IEEE Congress on Evol. Comput. 
[75]. Zielinski, K., and Laur, R., 2007. Differential Evolution with Adaptive Parameter Setting for 
Multi-Objective Optimization, Proceedings of 2007 IEEE Congress on Evol. Comput. 
[76]. Zielinski, K., and Laur, R., 2007. Adaptive Parameter Setting for a Multi-Objective Particle Swarm 
Optimization Algorithm, Proceedings of 2007 IEEE Congress on Evol. Comput. 
[77]. Zhao, S. Z., Linang, J. J., Suganthan, P. N., and Tasgetiren, M. F., 2008. Dynamic Multi-Swarm 
Particle Swarm Optimizer with Local Search for Large Scale Global Optimization, Proceedings of 
2008 IEEE Congress on Evol. Comput. 
[78]. Zhang, Q., Sun, J., Tsang, E., 2005. An Evolutionary Algorithm With Guided Mutation for the 
Maximum Clique Problem, IEEE Transactions on Evolutionary Computation, vol.9, no.2, 
pp.192-200. 
 
  50
出席國際學術會議心得報告 
 
一、參加會議經過 
承蒙國科會的補助得予參加 2007 年 9 月 25 日至 28 日在新加坡 Swissotel the Stamford 舉辦的
2007 IEEE Congress on Evolutionary Computation 國際會議，這個會議可以說是全世界 Evolutionary 
Computation 領域最重要的一個會議，每年都有很多來自全世界各地的學者參加，今年也不例外，
估計有近千人參加。 
 
二、與會心得 
我和我博士班的學生陳駿今年都參加了這個會議，我們有一篇論文”Multiple Trajectory Search 
for Multi-objective Optimization” 參加了一個 Multi-objective Optimization Competition 的 Special 
Session，結果我們得到一個在中間的名次，但是在比賽中我們發現我們的方法在搜尋初期時搜尋
效能非常好，排名第二，但隨著時間增加，我們的方法卻陷入不進步的狀態，換句話說，我們的
方法在中期與後期不能作有效的搜尋，回國後我們探討原因並找出改進的方法，使得我們的
Multiple Trajectory Search 有很大的進步，能夠有這樣的進步要拜參與此一 Competition 之賜，因
此參加國際會議，有機會與各地的學者作學術交流，對我們是很重要的，在此也建議國科會與教
育部可以多多補助國內的教授或研究人員出國開會，藉此提昇研究的質與量。。 
此次的會議，大會除了 Keynote Speech 外又邀請了好幾位講員在每天固定時段給專題演講，
每位講員都很認真預備他們的演講，因此個人覺得從這些演講中也獲益良多。 
這次會議由新加坡大學與 Nanyang Technological University 主辦，主辦單位非常用心也非常好
客，除了議程排得很好外，Banquet 也非常豐盛，並且在 Banquet 中安排了節目，分別由印度裔、
馬來裔與華裔各表演一個代表各自文化的節目，尤其是華裔節目”變臉” 真是非常精采，此外在最
後一天的晚上，主辦單位招待所有與會者去參觀新加坡的夜間動物園，也讓大家留下一個美好的
回憶。 
我和陳駿也抽空去了一趟聖淘沙，可惜下了雨，又加上時間不多，只能匆匆去回，參觀了水
族館與看了 4D 電影。 
 
  52
出席國際學術會議心得報告 
 
一、參加會議經過： 
    承蒙國科會與中興大學之補助，於 2009 年五月十三日搭機飛往挪威 Trondheim 參加 2009 年
IEEE Congress on Evolutionary Computation 會議，這個會議每年都會舉行，可以說是演化式計算最重
要的會議之一，今年很難得在北歐的挪威 Trondheim 舉行，Trondheim 是挪威第三大城，但是人
口卻只有 16 萬，它是一座大學城，挪威規模第二大的 Norwegian University of Technology and 
Science 就在這個城市內，這個大學有兩萬學生，規模比中興大學大一點，但教師、研究人員與
Post Doc.卻有差不多兩千人。由於人口不多，整個城市呈現出一種小鎮或鄉村的寧靜，由於城市
傍山靠海又有河流過，風景相當美，溫度大約在攝氏 10 度上下，但由於較乾燥，因此並不覺得冷。
會場設在 Nova 會議中心，並不是非常寬敞但設備很完善，今年的會議估計有四百多位來自全世
界各地的專家學者參加。 
    五月十八日安排的是 Tutorial，我整天共聽了四場，收獲頗豐。整個會議我大多選與
Multi-Objective Optimization 相關的 sessions 參加，至於我和我博士班學生陳駿的論文安排在五月
二十日下午發表，我們參加一個 Special Session，是關於 Constrained/Bound Constrained 
Multi-Objective Optimization 的競賽，我們在此二競賽中分別獲得第二名與第三名，可惜的是除了
第一名有獎狀外其他都沒有獎狀。由於參加競賽，我與同樣參加競賽的學者有很好的交流。 
    本次大會每天早上安排一場 Keynote Speech，邀請的主講者都是這些領域中研究作得相當好
的學者，聽這些演講覺得獲益良多。 
 
二、與會心得： 
    參加較頂尖的研討會，聽好的演講，與來自世界各地的精英交流，確實很有啟發性，晚上在
旅館時，拿起紙筆作一些思考，就又想出一些改進的想法，回來後與我的學生討論並請他作實驗，
果然我們的方法又進步了，相信我們還可以作得更好，我深深覺得參加好的學術會議對我們作研
究有很大的幫助，我也建議國科會、教育部和學校應該多多補助並鼓勵老師們參加頂尖的學術研
討會。 
 
三、考察參觀活動： 
    五月十七日是挪威國慶日，前一天在莫斯科舉行的 Eurovision Song Contest 挪威拿了冠軍，
挪威真是雙喜臨門，五月十七日在 Trondheim 整天都有慶祝活動，所有人幾乎都湧到街上，上午
有兒童的遊行，下午則有市民的遊行，大多數的女士都穿著她們傳統的服裝，部份男士也穿著傳
統服裝，挪威人慶祝國慶真是非常歡欣熱烈，後來得知挪威曾被丹麥統治過，因此當他們脫離丹
麥而獨立時，他們是何等的高興，因此每年國慶日他們都熱烈地慶祝，他們對自己國家的熱愛令
人感動。另外值得一提的是這裏的物價非常高，Burger King 一份套餐要價約新臺幣四百元，幾乎
是台灣的三倍。 
 
四、具體建議： 
    建議國科會應該多多補助並鼓勵老師們參加頂尖的學術研討會。 
 
五、攜回資料名稱及內容： 
    2009 年 IEEE World Congress on Computational Intelligence 會議論文集(DVD-ROM) 
 
 
 
出席國際學術會議心得報告 
                                                             
計畫編號 NSC 96-2628-E-005-074-MY3 
計畫名稱 逐步聚焦搜尋法 -- 一個較可調控之新超探索式演算法 
出國人員姓名 
服務機關及職稱 曾怜玉 
會議時間地點 2007 年 9 月 25 日至 28 日  新加坡 
會議名稱 2007 IEEE Congress on Evolutionary Computation 
發表論文題目 Multiple Trajectory Search for Multiobjective Optimization 
 
一、參加會議經過 
承蒙國科會的補助得予參加 2007 年 9 月 25 日至 28 日在新加坡 Swissotel the Stamford 舉
辦的 2007 IEEE Congress on Evolutionary Computation 國際會議，這個會議可以說是全世界
Evolutionary Computation 領域最重要的一個會議，每年都有很多來自全世界各地的學者參
加，今年也不例外，估計有近千人參加。 
 
二、與會心得 
我和我博士班的學生陳駿今年都參加了這個會議，我們有一篇論文”Multiple Trajectory 
Search for Multi-objective Optimization” 參加了一個 Multi-objective Optimization Competition
的 Special Session，結果我們得到一個在中間的名次，但是在比賽中我們發現我們的方法在搜
尋初期時搜尋效能非常好，排名第二，但隨著時間增加，我們的方法卻陷入不進步的狀態，
換句話說，我們的方法在中期與後期不能作有效的搜尋，回國後我們探討原因並找出改進的
方法，使得我們的 Multiple Trajectory Search 有很大的進步，能夠有這樣的進步要拜參與此一
Competition 之賜，因此參加國際會議，有機會與各地的學者作學術交流，對我們是很重要的，
在此也建議國科會與教育部可以多多補助國內的教授或研究人員出國開會，藉此提昇研究的
質與量。。 
此次的會議，大會除了 Keynote Speech 外又邀請了好幾位講員在每天固定時段給專題演
講，每位講員都很認真預備他們的演講，因此個人覺得從這些演講中也獲益良多。 
這次會議由新加坡大學與 Nanyang Technological University 主辦，主辦單位非常用心也非
常好客，除了議程排得很好外，Banquet 也非常豐盛，並且在 Banquet 中安排了節目，分別由
印度裔、馬來裔與華裔各表演一個代表各自文化的節目，尤其是華裔節目”變臉” 真是非常精
采，此外在最後一天的晚上，主辦單位招待所有與會者去參觀新加坡的夜間動物園，也讓大
家留下一個美好的回憶。 
我和陳駿也抽空去了一趟聖淘沙，可惜下了雨，又加上時間不多，只能匆匆去回，參觀
了水族館與看了 4D 電影。 
 
 
上，上午有兒童的遊行，下午則有市民的遊行，大多數的女士都穿著她們傳統的服裝，部份
男士也穿著傳統服裝，挪威人慶祝國慶真是非常歡欣熱烈，後來得知挪威曾被丹麥統治過，
因此當他們脫離丹麥而獨立時，他們是何等的高興，因此每年國慶日他們都熱烈地慶祝，他
們對自己國家的熱愛令人感動。另外值得一提的是這裏的物價非常高，Burger King 一份套餐
要價約新臺幣四百元，幾乎是台灣的三倍。 
 
四、具體建議： 
    建議國科會應該多多補助並鼓勵老師們參加頂尖的學術研討會。 
 
五、攜回資料名稱及內容： 
    2009 年 IEEE World Congress on Computational Intelligence 會議論文集(DVD-ROM) 
 
 
    聖安東尼奧旅館很多而且有不少高檔的，可見是美國人常來旅遊的地方，主要可能是因
為有一個 Alamo，Alamo 在德州獨立戰爭的歷史上扮演著重要角色，故事是關於在 1836 年裡
重要的 13 天；當時德州居民不滿墨西哥政府稅率與法律，宣布要由墨國獨立，因此畫下德州
為爭取獨立的悲壯故事；防守在 Alamo 的德州人僅 200 人，卻要與 7000 個墨軍奮戰，此戰
爭維持了 13 天，整個 Alamo 的德州戰士皆被殲滅。也因為在前線的 Alamo 拖延了墨軍，讓
德州的軍隊在三個星期後，取得了決定性的勝利。除了 Alamo 外另一個景點就是 Riverwalk，
有一條運河穿過聖安東尼奧，在運河的兩旁有各種餐廳或 Cafe，人們可以很優閒地坐在河邊
吃東西看風景。 
 
四、具體建議： 
    建議國科會應該多多補助並鼓勵老師們參加頂尖的學術研討會。 
 
五、攜回資料名稱及內容： 
    2009 年 IEEE International Conference on Systems, Man, and Cybernetics 會議論文集(隨身
碟) 
 
 
 
96年度專題研究計畫研究成果彙整表 
計畫主持人：曾怜玉 計畫編號：96-2628-E-005-074-MY3 
計畫名稱：逐步聚焦搜尋法-一個較可調控之新超探索式演算法 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 7 6 100% 
篇 
三年期整個計畫 論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 7 0 100% 三年期整個計畫 
博士生 2 0 100% 三年期整個計畫 
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 6 6 100% 三年期整個計畫 
研究報告/技術報告 3 3 100% 三年期整個計畫 
研討會論文 14 6 100% 
篇 
三年期整個計畫 論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 5 0 100% 三年期整個計畫 
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 1 0 100% 
人次 
三年期整個計畫 
 
