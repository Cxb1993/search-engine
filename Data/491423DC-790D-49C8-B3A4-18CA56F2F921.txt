2 
 
 擬 DCVSL 架構電路分析 
i. 基本區塊介紹 
ii. 運算邏輯區塊介紹 
iii. 應對延遲區塊介紹 
 擬 DCVSL 架構實驗與分析 
i. 擬 DCVSL 樣版的範例實現 
ii. 延遲錯誤模擬 
 
3.1 擬 DCVSL 架構電路分析 
本計畫提出一個擬 DCVSL 自我時序電路設計的結構，這個電路結構改良
自傳統的 DCVSL 架構。我們將電路當作一個完整的區塊來設計，主要區分為
三個部分，第一個部分是 DCVSL 的基本區塊，第二個部分是主要實作電路運
算的網路，第三個部分則是電路應對的延遲。 
基本區塊，裡陎主要是改良過後的動態雙軌式邏輯結構所構成，再來運算
區塊則是由 NMOS domino 方式所實作出來的邏輯函數，最後延遲應對區塊主
要是用來取代雙軌結構的對應運算函數，有點類似重複性的函數型實作。實
作的結構如圖 1 所示，接下來的小節，將對各個區塊做介紹。 
 
DCVSL
Basic Block
Matched 
Delay
Req
Input
OUT
OUTB
ACK
NMOS
Network
 
圖 1 擬 DCVSL 電路架構圖 
 
  3.1.1 基本區塊介紹 
接下來我們要介紹的是擬 DCVSL 架構的基本電路區塊，如圖 2 虛線表示。 
 
4 
 
3.1.2 運算邏輯區塊介紹 
運算邏輯區塊的部份，如圖 3 中的虛線部份所表示。 
 
DCVSL
Basic Block
Matched 
Delay
Req
Input
OUT
OUTB
ACK
NMOS
Network
 
 
圖 3 擬 DCVSL 電路架構運作邏輯區塊示意圖 
我們之所以使用 NMOS 作為運算邏輯區塊實作的理由，主要是 NMOS 相
較於 PMOS 有較短的反應時間，也就是轉態時間會稍微快一點。就單一階結構
而言，我們所實作的邏輯函數區塊和傳統的 DCVSL 設計相同，一旦我們需要
實作的邏輯函數太大，沒有辦法放入單一階的結構使用時，我們會重新處理電
路，將它實作成多階的 NMOS 骨牌式設計結構，當然我們還是可以保留最後一
階，類似於傳統式 DCVSL 設計的形式。以電路的陎積而言，相較於傳統式的
DCVSL 而言，我們節省了另一個逆向函數(反函數)的實作，所以我們所要用到
的電晶體數目將遠少於傳統式 DCVSL 電路架構，具有大幅減少陎積的優點，
此優點將在實作更大型的邏輯函數會更加的明顯。此外，我們僅僅以二個最小
SIZE 的電晶體跟一個應對延遲，就可以使用一個可程式化的應對延遲來取代整
個逆向邏輯區塊的實作，就功率消耗而言我們也有很顯著的改進，從我們的一
些模擬結果可看出當電路越大時，不管是在陎積、速度或是功率消耗方陎，所
得到的改進都會更加的明顯。 
 
3.1.3 應對延遲區塊介紹 
應對延遲主要是來應對實現正向邏輯運算所需要的最差狀況延遲時間，這
個延遲時間對於大部分簡單的邏輯運算函數而言十分容易匹配。例如我們從柏
克來 SIS 的元件庫當中，隨機取出十個函數所測試得到的結果，我們僅採用簡
單的反向器就足以匹配。當我們要實作一個較複雜的電路而需要較長的延遲
時，也可使用一些其他改良過的延遲元件，這個延遲基本上它需要佔用的電路
陎積與功率都非常的小，假設要實作比較大的電路時，仍然可以保有體積小與
低功率消耗的優勢。 
6 
 
Matched 
Delay
Req
Input
OUT
OUTB
ACK
F
DCVSL
Basic Block
 
圖 4 擬 DCVSL 實現 SIS 資料庫的函數表示圖 
 
在圖 4 中，將需要實現的函數，分為正相函數與反相函數，並以 NMOS
實現。我們亂數挑出五個函數來實現，並比較其效能，這些函數分別為: 
F01 = ( c’ + b’ ) ( j’ k’ l’ + g’ h’ i’ + d’ e’ f’ ) + a’  
F02 = d’ e’ f’ ( c’ +b’ ) + ( l’ + k’ ) ( j’ + i’ ) ( c’ + b’ ) ( h’ + g’ ) + a’ 
F03 = ( g’ h’ ( j’ + i’ ) + d’ e’ f’ ) ( c’ + b’ ) + a’ 
F04 = j’ k’ l’ ( c’ + b’ ) + (h’ i’ + f’ g’ ) ( c’ + b’ ) ( e’ + d’ ) + a’ 
F07 = d’ e’ ( c’ + b’ ) + ( j’ k’ + h’ i’ ) ( c’ + b’ )( g’ + f’ ) + a’ 
這些函數是由美國加州柏克萊大學所開發的邏輯合成工具裡陎的元件資料
庫中挑出來的，這個工具是專門用來為循序(Sequential)數位邏輯電路做最佳
化，並且提供技術映射(Technology Mapping)的函數資料庫，這些函數就是
從這個資料庫中亂數取出來的。而這個工具與資料庫早在 2005 年以前就被
開發出來，直到現今在非同步設計領域中，仍是一個相當重要的工具之一，
其資料庫也包含了相當多常被用到的函數，因此我們選擇在這個資料庫中，
隨機挑選出一些函數來實現，將我們的擬 DCVSL 架構做成樣板後，如圖 5
所示，與傳統式的 DCVSL 與雙軌骨牌式電路比較效能上的差異。 
18u
1
5
u
 
圖 5 擬 DCVSL 電路樣板佈局圖 
8 
 
耗才是對於電路設計當中最重要的考量時，我們可以選擇實現這個函數的互補
函數而犧牲一點電路速度。但是由表 2 中可以發現，我們所犧牲的電路速度其
實並不多，而且在大多數的情況下，電路運作速度仍然比傳統的 DCVSL 架構
更快。如果除去對於陎積與速度的選擇並未最佳化的影響後，我們所提供的擬
DCVSL 架構可以很輕易當成一個低功率消耗電路的設計樣版，效能上的表現
並不亞於傳統式 DCVSL，但是佈局陎積卻可以小很多。 
 
表 2 功率消耗與延遲時間比較表 
          Selected Cases                     Power Consumption (uw)                  Worst-case Evaluation Time (ps)
SPEC I Lit DCVSL Domino PD PDC DCVSL Domino PD PDC
f01 12 91 146 137 106 162 574 628 581 599
f02 12 99 153 149 110 164 573 653 581 590
f03 12 72 127 123 105 150 524 596 590 590
f04 12 97 153 147 110 164 600 665 581 597
f07 11 95 159 151 111 170 631 712 581 606
I; # of inputs Lit: # of literals PD: Pseudo-DCVSL(logic equation)  PDC: Pseudo-DCVSL(complemented logic equation)  
 
3.3.2 實現多階函數 
因為 DCVSL 架構是雙軌式的結構，我們的擬 DCVSL 結構並不受限於一定
要實現真實那一邊的函數，如果實現互補的函數會比較有利的話，我們當然可
以選擇實現互補的那一邊，這個決定將會關係到速度與功率，而這個特性可以
讓我們更有彈性的選擇要實現的目標函數。以及閘(AND Gate)的例子來說，傳
統式的 DCVSL 必須同時實現真實的串連函數區塊與並連的互補函數區塊，但
是我們的架構卻不需要，模擬結果的數據如表 3 所示。 
 
表 3 十輸入及閘特性比較表 
 
 
由表 3 中可以發現，使用擬 DCVSL 架構來實現並連的電晶體網路時，速
度將可以加快，但是功率消耗也同時增加 ; 而實現串連的電晶體網路時，將
可以得到一個低功率消耗的擬 DCVSL 架構及閘。這是因為一般的輸入訊號在
並連的電晶體網路的切換頻率遠比串連網路的切換頻來的高。 
電路的佈局陎積是我們選擇要實現那一邊函數的考量點之一，而無論選擇
那一邊，擬 DCVSL 架構將可以將另外一邊的互補函數以簡單應對延遲電路所
取代，因此擬 DCVSL 架構都會比傳統式的 DCVSL 架構來的小，功率消耗也
比傳統式的 DCVSL 更省。 
 
10 
 
由圖 8 的佈局圖中，虛線範圍內為擬 DCVSL 架構所做成的樣板，直接套
用到真實或互補式的函數，不但在實現函數時相當的容易，在電路佈局陎積也
比傳統式的 DCVSL 小很多。功率消耗與延遲時間如表 4 所示。 
 
表 4  進位鏈模擬結果比較表 
Carry chain
T F T F T (match) F T (match) F
Delay (ns) 1.566 1.664 1.349 1.429 1.585 1.540 1.255 1.204
Power (uw/MHz)
Layout area (um^2) 1978 2168 1200 975
DCVSL Dual-rail PD  PDC   
3.319 2.901 2.088 2.147
 
 
在表 4 中很明顯可以發現，以擬 DCVSL 所實現的進位鏈與其他兩種架構
相比之下，大幅節省了至少 40%的佈局陎積，在表中我們也對延遲時間與功率
消耗做完整的呈現與比較，毫無意外的，實驗結果與之前的討論相吻合，以擬
DCVSL 架構所實現的進位鏈電路節省了約 35%以上的功率消耗。不僅如此，
最差狀況延遲時間也很明顯地獲得改進，因為延遲時間會因為內部節點的負載
大小而有所影響，與傳統式的 DCVSL 相比較，擬 DCVSL 在實作這個多級的
進位鏈時，可以提升約 24%的速度。 
 
3.4 延遲錯誤模擬 
延遲錯誤的發生，是當電路處於運算週期時，如果應對延遲的時間不夠長，
來不及等到實作函數區塊運算完成就發出完成訊號時，就會產生這樣的錯誤。
而這種情況通常是因為製程的變異性、訊號交互影響(coupling)、雜訊等因素
所產生。解決這個問題最簡單的方式，就是將實際的延遲時間再多加上一個合
理範圍的延遲時間，這個多加上去的時間稱為安全邊際。這個簡單的方式廣泛
地應該用同步與非同步電路中，系統中的時脈訊號就是最常見的例子。我們的
擬 DCVSL 架構採用應對延遲方式取代反向邏輯，必須考量延遲錯誤的發生。 
 
3.4.1 延遲錯誤原因分析 
動態邏輯被驅動的速度比許多其他類似種類的邏輯架構更快; 然而，當一
個不需要的波形產生，並且電壓超過驅動電路的電壓臨界值時，便會造成電路
運算錯誤。在擬 DCVSL 架構當中，這個錯誤訊號會發生的原因，是因為應對
延遲電路並未偵測到運算函數區塊被驅動，因而遺失掉少許位元。在自我時序
的電路架構當中，接收端在接收到資料並且運算完成後，會回傳運算完成訊號
給輸出端，當錯誤發生的時候，如果我們可以在運算完成訊號被讀取到之前，
就及時修正回正確值的話，那麼這個錯誤訊號就可以被忽略掉。 
 
 
 
