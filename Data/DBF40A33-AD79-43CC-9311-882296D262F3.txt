In this research, 200 questionnaires were distributed 
to gather information and data analysis. 135 
questionnaires are collected determines 67.5% 
sampling degree. This study is not only discussing 
about how to implement cloud computing for gas 
reserves exploration, but also comparing results and 
gaining understanding of unique methodology taken by 
different petroleum companies in each country. This 
research will be a reference for petroleum companies 
to utilize cloud computing in gas reserve exploration 
and mining in the near future. This research have 
achieved two important contributions: (1) Current 
status and system analysis of cloud computing 
technology on national petroleum companies. (2) 
Import cloud computing feasibility analysis and 
specific recommendations on domestic petroleum 
companies. 
 
By leveraging cloud computing capabilities, this 
research technologically aims for gas layer 
exploration, gas manufacturing, cost calculation, 
data recording, real-time data update and hazard 
prediction. It is expected in the future that Taiwan 
petroleum companies will create innovative management 
methods with the results of cloud computing 
implementation to achieve efficient and high quality 
gas reverses and exploration management. 
英文關鍵詞： Cloud Computing, Petroleum Exploration, Knowledge 
Flow, Knowledge Management 
 
2 
 
research technologically aims for gas layer 
exploration, gas manufacturing, cost calculation, 
data recording, real-time data update and hazard 
prediction. It is expected in the future that 
Taiwan petroleum companies will create 
innovative management methods with the results 
of cloud computing implementation to achieve 
efficient and high quality gas reverses and 
exploration management. 
 
Keywords: Cloud Computing, Petroleum 
Exploration, Knowledge Flow, Knowledge 
Management 
 
I. 前言 
 
(一)、雲端運算的發展趨勢 
 
全球知名市調公司 Gartner 研究報告指
出，2010年企業在做科技策略規劃時，應將十
大趨勢列入規劃考量，如圖一所示，其中以雲
端運算(Cloud Computing)備受關注，它的重要
性由 2009年的第三名爬升至 2010年的首位；
另以 Gartner於 2009年提出之新興科技的成長
趨勢中，雲端運算正處在該科技發展階段中的
最高峰期，由此可知 2010 年以後雲端運算將
會是科技應用與發展的重要關鍵技術之一。 
 
根據國家標準和科技協會 (National 
Institute of Standards and Technology)給予雲端
運算的定義─「雲端運算是一種能便利地依使
用者需求，透過網路存取的共享運算資源區(如
網路、伺服器、儲存裝置、應用程式與各類服
務)，即可利用最少的管理工作來與服務供應商
進行互動，以達到快速地配置與發佈」。雲端
運算服務模式可分為三類：軟體即服務
(Software as a Service；SaaS)、平台即服務
(Platform as a Service；PaaS)及基礎架構即服務
(Infrastructure as a Service；IaaS)。雲端運算部
署模式則分為四種：公共雲(Public Cloud)、私
有雲(Private Cloud)、社群雲(Community Cloud)
與混合雲(Hybrid Cloud) [1]。 
 
 
圖一、雲端運算技術崛起 
 
(二)、石油探採與雲端運算的應用趨勢 
 
石 油 情 報 週 刊 (Petroleum Intelligence 
Weekly)根據石油儲量、天然氣儲量、石油產
量、天然氣產量、石油煉製能力和油品銷售量
等 6項指標綜合測算出 2008年世界前 10大石
油公司，其排名為：沙烏地阿拉伯國家石油公
司 (Saudi Aramco)、 伊朗國家石油公司
(NIOC)、埃克森美孚公司(Exxon Mobil)、委內
瑞拉國家石油公司(PDV)、中國石油天然氣股
份有限公司(CNPC)、英國石油公司(BP)、皇家
荷蘭 /殼牌公司 (Shell)、美國康菲公司
(ConocoPhillips)、雪佛龍公司(Chevron)和道達
爾公司(Total)，而在此世界十大石油公司當
中，有多家已經將雲端運算應用於油氣探採與
管理營運中。 
 
目前國際十大石油公司大多導入雲端運
算應用於油氣探採與管理營運中，能有效縮短
知識流通與分享的時間，以達成即時的知識管
控。以 Saudi Aramco為例，透過雲端運算可進
行即時資訊監控和即時回覆，整合最佳的鑽井
流程與油井定位，進而降低生產成本並且增進
油田產值、改善油層管理與生產流程，提升整
體獲利。Saudi Aramco亦將即時資訊整合運用
於企業管理，透過多種數位科技導入探採和生
產流程，使得 Saudi Aramco在整合即時資訊的
實施方法與經驗中，已在數位化油田(Digital 
Oil Field)取得發展的優勢。 
 
 
 
4 
 
需求去獲得服務，並為使用者提供相關的付費
機制。服務供應商所提供的服務包括Microsoft
的線上更新服務與 Trend Micro 的網路安全等
等。 
 
    依據雲端企業儲存供應商 Nasuni 所制定
的測試分析，如何評定一雲端運算系統是否具
備良好的服務品質與穩定度，可從下列五點進
行系統的評定與分析[12]。 
 
1. 應用程式介面 (Application Programming 
Interface)整合測試，透過與應用程式介接測
試，可得知此雲端運算系統是否具備高度
相容性。 
2. 穩定性測試，透過此項測試，可得知此雲
端運算系統是否具備高度穩定度，穩定度
越高代表使用者於任何時間皆可取得服
務。 
3. 單元測試，測試雲端運算系統的基本功
能，此項測試透過是否能讀出與寫入不同
大小的檔案進行分析。 
4. 效能測試，測試資料經過雲端運算系統處
理後所傳回之速度，其中包含有運算速度
與傳輸速度。 
5. 擴充性測試，透過不斷寫入不同大小的檔
案，以了解當服務容量滿載時，伺服器回
應時間是否會因此拉長 
 
    雲端運算之特性如圖三所示。虛擬化之硬
體設備(Virtualization)，可改善伺服器散亂之問
題與降低電力成本，以及節省資料中心的硬體
儲存空間；透過雲端雲算可以減少硬體設備的
採購，降低企業主對於硬體之成本設備，加強
企業之競爭力；Huge Data Scale可以做為大量
資料儲存位置以供使用者使用，以及具有彈性
和可擴展性的特點，讓雲端運算能有更高的效
率和高可靠度優勢。 
 
 
 
圖三、雲端運算之特性 
 
 圖四顯示為雲端運算架構，在底層的 IaaS
把 系 統 層 級 分 為 VM Management 、
Deployment 、 QoS Negotiation 、 Admission 
Control 和 Accounting 等等，PaaS 增加了包含
用戶級別的中間層，其內容包括雲端運算程
序：Web 2.0 Interfaces、Mashups、Workflows
等，最後 SaaS 包括用戶級別的雲端運算程序
Social Computing、Enterprise和 CDNs等等。 
 
圖四、雲端架構 
 
雲端運算的基本架構分為以下三層
Application 、 Abstract Services 、 Flexible 
Infrastructure，Workflow所需 Resource皆會從
雲端運算系統上的 Abstract Services 中取得，
而 Resource則由 Flexible Infrastructure提供，
Abstract Services 會提供 Service Pool 讓
Workflow 要求資源時可以迅速的從 Service 
Pool中提取所需的資源。 
 
(二)、資訊管理系統應用於石油探採 
 
    資訊管理系統應用於石油能源產業主要
聚焦於可用更智慧的方法來管控探採與生產
程序，以最少的變化和最佳的個別科技應用於
使用者、流程和組織。同時，在即時的鑽井管
控中心結合創新科技技術落實，藉由協同操作
和遠距遙控的技術來達成流程的順暢，增加更
6 
 
 
圖六、研究方法與運作架構圖 
 
當前國內石油公司針對雲端運算導入油
氣探採之應用研究，尚屬啓蒙階段，透過國家
圖書館之文獻資料庫查證，並無相關研究文獻
可供參考和分析，且經由本案前期之初步訪
談，國內石油公司所屬之研究機構，或許已開
始進行內部討論，但目前並無具體之公開資料
可供參考，亦無相關之研究計畫可供參照，雲
端運算技術在油氣探採與鑽採工程之應用在
國內尚待發展。故本案透過上述方法，針對目
前國際石油公司整合雲端運算技術的過程與
影響進行研究分析，根據雲端運算技術應用於
油氣探採之現況、國外石油公司結合雲端架構
於油氣開採之現狀，整理出雲端運算之應用對
於油氣探採所帶來的優點與影響，如圖七所
示。 
 
圖七、雲端運算結合油氣探採的優點與影響 
 
雲端運算應用於石油能源產業主要重點
在於運用更智慧的方法來管控探採與生產程
序，將最少的變化和最佳的科技應用於使用
者、流程與組織。同時，在即時鑽井管控中心
做有系統的科技落實，藉由協同操作和遠距遙
控之技術來提升作業的效率與流程的順暢，透
過雲端運算的技術，整合知識的管理、協作與
企業社群運作，來達成加速了解數位化油田的
潛力，藉由創新的即時協作與監控管理來減低
生產的耗時，但石油能源產業正面臨成本和科
技的多重挑戰，如何結合企業的整體能量並運
用科技的協助來提升油田開採技術是當前重
要之課題。 
IV. 結果與討論 
 
根據研究結果顯示，目前已有多家石油公
司結合智慧聯網(Internet of Things)裝置，應用
於油氣探採之領域，提供即時資料存取平台協
助石油探採，並導入新科技進行油氣生產與開
發的協同管理，以提升企業產值，本研究之工
作重點及產出如表一所示。 
 
表一、工作重點及研究產出 
 計畫工作查核 技術文件/產出物 達成度 
1 
雲端運算應用於油
氣探採之石油公司
的看法、導入原因
與運用現況。 
各石油公司目前的
運用現況與初步成
效調查表。 
100% 
2 
雲端運算應用於油
氣探採的石油公
司，其經驗、心得
與資訊架構。 
各科技或顧問公司
將雲端運算應用於
油氣探採之資訊模
型或架構圖。 
100% 
3 
雲端運算應用於油
氣探採的石油公
司，其目前成效分
析。 
雲端運算應用於油
氣探採的石油公司
預期成效與實際成
效彙整。 
100% 
4 
彙整國外各石油公
司的資訊，提出雲
端運算應用於油氣
探採的模型或架
構。 
國外石油公司雲端
運算應用於油氣探
採的模型或架構
表。 
100% 
5 
綜合並評估國內石
油公司應用雲端運
算技術於探採業務
之可行性分析。 
國內石油公司導入
雲端運算的可行性
與具體建議報告
書。 
100% 
 
本研究根據應用現況、導入方法、成效分
析、資訊架構與可能瓶頸等五項指標，分別針
對國際十大石油公司進行雲端策略分析，如表
二所示，其中以星號標示之 BP、Shell、Chevron
8 
 
(Architectural) 和 佈 署 模 式 (Deployment 
Paradigms)，運用此種方式將可降低運算時
間和回應時間、盡量減少佈署實體基礎設施
的風險、降低進入的成本和增加創新步伐。 
 
 降低運算時間和回應時間 
對於雲端運算上的應用程序基本上是採
用批次處理作業，雲端運算伺服器可以直
接使用 1000 台伺服器去完成一項任務，
為使用 1台伺服器的 1/1000倍時間。對應
用程序來說需要提供客戶最快回應機
制，透過虛擬機器使用，達到回應時間的
最佳化，以滿足客戶的需求。 
 
 盡量減少佈署實體基礎設施的風險 
IT 組織可以透過使用雲端運算降低購買
實體伺服器的固有風險，使雲端運算基礎
設施的風險降到最低，其中企業數據中心
增加了尖峰工作量的處理能力，將需要大
量運算工作量送到公有雲，應用程序生命
週期的管理，以較佳的處理環境降低資源
的消耗，以較低的成本滿足即時需求。 
 
 降低進入的成本 
由於基礎設施透過租用取代購買，因此成
本可獲得控制，此應用開發的規範，有助
於減少產品上市時間，使得組織在雲端運
算環境中的應用程序佈署可以搶得競爭
先機。 
 
 增加創新步伐 
雲端運算可以幫助創新，使新成立公司或
組織可以快速部署新產品和降低成本，可
更有效率地與傳統的組織競爭，日益激烈
的競爭也有助於增加步伐的創新，透過使
用開放原始碼(Open Source)的軟體，讓許
多創新得以實現，藉由推動雲端運算讓整
個石油產業受益。 
 
本研究於計畫期間完成了雲端運算平台
之建置，如圖八所示，並基於雲端運算平台建
立油業資訊分析與油業知識管理平台，系統介
面如圖九所示。依本次所累積之經驗將成為日
後研究之基石，為後續研究開拓新的視野與契
機；另外，透過本計畫之研究，可望在有限的
油氣能源下，達到更妥善、有效的資源分配，
減少多餘的財政支出，帶動產業間的活絡，並
吸引產業資金的挹注。經由雲端運算技術的導
入，增進石油能源產業的發展能力，使石油能
源產業擁有更佳之競爭力。 
 
 
圖八、雲端運算平台之建置 
 
 
圖九、油業資訊分析與油業知識管理平台 
 
V. 結論 
透過本研究分析，確認雲端運算運用在油
氣探採的預測能達到油氣產能的擴增、成本耗
損的減低、資料往返時間的縮短、資料即時的
更新和現場風險評估，皆有正面助益。未來國
內石油公司導入雲端運算應用於油氣探採
時，本研究成果將可提供創新的管理方式與整
合新興科技的應用，以提高油氣探採的績效，
並提升整體營運效益，整合架構如圖十所示。
此外，本研究內容結合雲端運算與各式之新興
科技，參與之研究人員從中分析出能源石油產
10 
 
附錄 程式碼 
 
1. attachment.rb 
 
require "digest/md5" 
 
class Attachment < ActiveRecord::Base 
  belongs_to :container, :polymorphic => true 
  belongs_to :author, :class_name => 
"User", :foreign_key => "author_id" 
 
  
validates_presence_of :container, :filename, :auth
or 
  validates_length_of :filename, :maximum => 
255 
  validates_length_of :disk_filename, :maximum 
=> 255 
 
  acts_as_event :title => :filename, 
                :url => Proc.new {|o| 
{:controller => 'attachments', :action => 
'download', :id => o.id, :filename => 
o.filename}} 
 
  acts_as_activity_provider :type => 'files', 
                            :permission 
=> :view_files, 
                            :author_key 
=> :author_id, 
                            :find_options 
=> {:select => "#{Attachment.table_name}.*", 
                                       
       :joins => "LEFT JOIN 
#{Version.table_name} ON 
#{Attachment.table_name}.container_type='Vers
ion' AND #{Version.table_name}.id = 
#{Attachment.table_name}.container_id " + 
                                                        
"LEFT JOIN #{Project.table_name} ON 
#{Version.table_name}.project_id = 
#{Project.table_name}.id OR 
( #{Attachment.table_name}.container_type='Pro
ject' AND 
#{Attachment.table_name}.container_id = 
#{Project.table_name}.id )"} 
 
  acts_as_activity_provider :type => 
'documents', 
                            :permission 
=> :view_documents, 
                            :author_key 
=> :author_id, 
                            :find_options 
=> {:select => "#{Attachment.table_name}.*", 
                                       
       :joins => "LEFT JOIN 
#{Document.table_name} ON 
#{Attachment.table_name}.container_type='Doc
ument' AND #{Document.table_name}.id = 
#{Attachment.table_name}.container_id " + 
                                                        
"LEFT JOIN #{Project.table_name} ON 
#{Document.table_name}.project_id = 
#{Project.table_name}.id"} 
 
  cattr_accessor :storage_path 
  @@storage_path = 
Redmine::Configuration['attachments_storage_pa
th'] || "#{RAILS_ROOT}/files" 
 
  def validate 
    if self.filesize > 
Setting.attachment_max_size.to_i.kilobytes 
      errors.add(:base, :too_long, :count => 
Setting.attachment_max_size.to_i.kilobytes) 
    end 
  end 
 
  def file=(incoming_file) 
    unless incoming_file.nil? 
      @temp_file = incoming_file 
      if @temp_file.size > 0 
        self.filename = 
sanitize_filename(@temp_file.original_filename) 
        self.disk_filename = 
Attachment.disk_filename(filename) 
        self.content_type = 
@temp_file.content_type.to_s.chomp 
        if content_type.blank? 
          self.content_type = 
Redmine::MimeType.of(filename) 
        end 
        self.filesize = @temp_file.size 
      end 
    end 
  end 
  
  def file 
    nil 
  end 
 
12 
 
private 
  def sanitize_filename(value) 
    # get only the filename, not the whole path 
    just_filename = value.gsub(/^.*(\\|\/)/, '') 
    # NOTE: File.basename doesn't work right 
with Windows paths on Unix 
    # INCORRECT: just_filename = 
File.basename(value.gsub('\\\\', '/')) 
 
    # Finally, replace all non alphanumeric, 
hyphens or periods with underscore 
    @filename = 
just_filename.gsub(/[^\w\.\-]/,'_') 
  end 
 
  # Returns an ASCII or hashed filename 
  def self.disk_filename(filename) 
    timestamp = 
DateTime.now.strftime("%y%m%d%H%M%S") 
    ascii = '' 
    if filename =~ %r{^[a-zA-Z0-9_\.\-]*$} 
      ascii = filename 
    else 
      ascii = Digest::MD5.hexdigest(filename) 
      # keep the extension if any 
      ascii << $1 if filename =~ 
%r{(\.[a-zA-Z0-9]+)$} 
    end 
    while File.exist?(File.join(@@storage_path, 
"#{timestamp}_#{ascii}")) 
      timestamp.succ! 
    end 
    "#{timestamp}_#{ascii}" 
  end 
end 
 
2. auth_source.rb 
 
class AuthSource < ActiveRecord::Base 
  include Redmine::Ciphering 
   
  has_many :users 
   
  validates_presence_of :name 
  validates_uniqueness_of :name 
  validates_length_of :name, :maximum => 60 
 
  def authenticate(login, password) 
  end 
   
  def test_connection 
  end 
   
  def auth_method_name 
    "Abstract" 
  end 
   
  def account_password 
    read_ciphered_attribute(:account_password) 
  end 
   
  def account_password=(arg) 
    write_ciphered_attribute(:account_password, 
arg) 
  end 
 
  def allow_password_changes? 
    self.class.allow_password_changes? 
  end 
 
  # Does this auth source backend allow 
password changes? 
  def self.allow_password_changes? 
    false 
  end 
 
  # Try to authenticate a user not yet registered 
against available sources 
  def self.authenticate(login, password) 
    AuthSource.find(:all, :conditions => 
["onthefly_register=?", true]).each do |source| 
      begin 
        logger.debug "Authenticating '#{login}' 
against '#{source.name}'" if logger && 
logger.debug? 
        attrs = source.authenticate(login, 
password) 
      rescue => e 
        logger.error "Error during 
authentication: #{e.message}" 
        attrs = nil 
      end 
      return attrs if attrs 
    end 
    return nil 
  end 
end 
 
3. development.rb 
 
# Settings specified here will take precedence 
over those in config/environment.rb 
14 
 
LOGIN authentication and checking HELO for 
foo.com 
# 
# production: 
#   email_delivery: 
#     delivery_method: :smtp 
#     smtp_settings: 
#       address: "example.com" 
#       port: 25 
#       authentication: :login 
#       domain: 'foo.com' 
#       user_name: 'myaccount' 
#       password: 'password' 
# 
# ==== SMTP server at example.com using 
PLAIN authentication 
# 
# production: 
#   email_delivery: 
#     delivery_method: :smtp 
#     smtp_settings: 
#       address: "example.com" 
#       port: 25 
#       authentication: :plain 
#       domain: 'example.com' 
#       user_name: 'myaccount' 
#       password: 'password' 
# 
# ==== SMTP server at using TLS (GMail) 
# 
# This requires some additional configuration.  
See the article at: 
# 
http://redmineblog.com/articles/setup-redmine-to
-send-email-using-gmail/ 
# 
# production: 
#   email_delivery: 
#     delivery_method: :smtp 
#     smtp_settings: 
#       tls: true 
#       address: "smtp.gmail.com" 
#       port: 587 
#       domain: "smtp.gmail.com" # 
'your.domain.com' for GoogleApps 
#       authentication: :plain 
#       user_name: "your_email@gmail.com" 
#       password: "your_password" 
# 
# 
# === More configuration options 
# 
# See the "Configuration options" at the 
following website for a list of the 
# full options allowed: 
# 
# 
http://wiki.rubyonrails.org/rails/pages/HowToSen
dEmailsWithActionMailer 
 
 
# default configuration options for all 
environments 
default: 
  # Outgoing emails configuration (see examples 
above) 
 
 production: 
  email_delivery: 
    delivery_method: :smtp 
    smtp_settings: 
      tls: true 
      address: "smtp.gmail.com" 
      port: 587 
      domain: "smtp.gmail.com"  
      authentication: :plain 
      user_name: "wneclab@gmail.com" 
      password: "iamsmallma" 
 
   
  # Absolute path to the directory where 
attachments are stored. 
  # The default is the 'files' directory in your 
Redmine instance. 
  # Your Redmine instance needs to have write 
permission on this 
  # directory. 
  # Examples: 
  # attachments_storage_path: /var/redmine/files 
  # attachments_storage_path: D:/redmine/files 
  attachments_storage_path: 
   
  # Configuration of the autologin cookie. 
  # autologin_cookie_name: the name of the 
cookie (default: autologin) 
  # autologin_cookie_path: the cookie path 
(default: /) 
  # autologin_cookie_secure: true sets the 
cookie secure flag (default: false) 
  autologin_cookie_name: 
  autologin_cookie_path: 
  autologin_cookie_secure: 
16 
 
login_required: 
  default: 0 
self_registration: 
  default: '2' 
lost_password: 
  default: 1 
password_min_length: 
  format: int 
  default: 4 
attachment_max_size: 
  format: int 
  default: 5120 
issues_export_limit: 
  format: int 
  default: 500 
activity_days_default: 
  format: int 
  default: 30 
per_page_options: 
  default: '25,50,100' 
mail_from: 
  default: redmine@example.net 
bcc_recipients: 
  default: 1 
plain_text_mail: 
  default: 0 
text_formatting: 
  default: textile 
cache_formatted_text: 
  default: 0 
wiki_compression: 
  default: "" 
default_language: 
  default: en 
host_name: 
  default: localhost:3000 
protocol: 
  default: http 
feeds_limit: 
  format: int 
  default: 15 
gantt_items_limit: 
  format: int 
  default: 500 
# Maximum size of files that can be displayed 
# inline through the file viewer (in KB) 
file_max_size_displayed: 
  format: int 
  default: 512 
diff_max_lines_displayed: 
  format: int 
  default: 1500 
enabled_scm: 
  serialized: true 
  default:  
  - Subversion 
  - Darcs 
  - Mercurial 
  - Cvs 
  - Bazaar 
  - Git 
autofetch_changesets: 
  default: 1 
sys_api_enabled: 
  default: 0 
sys_api_key: 
  default: '' 
commit_ref_keywords: 
  default: 'refs,references,IssueID' 
commit_fix_keywords: 
  default: 'fixes,closes' 
commit_fix_status_id: 
  format: int 
  default: 0 
commit_fix_done_ratio: 
  default: 100 
commit_logtime_enabled: 
  default: 0 
commit_logtime_activity_id: 
  format: int 
  default: 0 
# autologin duration in days 
# 0 means autologin is disabled  
autologin: 
  format: int 
  default: 0 
# date format 
date_format: 
  default: '' 
time_format: 
  default: '' 
user_format: 
  default: :firstname_lastname 
  format: symbol 
cross_project_issue_relations: 
  default: 0 
notified_events: 
  serialized: true 
  default:  
  - issue_added 
  - issue_updated 
mail_handler_body_delimiters: 
18 
 
# Foundation, Inc., 51 Franklin Street, Fifth Floor, 
Boston, MA  02110-1301, USA. 
 
require 'uri' 
require 'cgi' 
 
class Unauthorized < Exception; end 
 
class ApplicationController < 
ActionController::Base 
  include Redmine::I18n 
 
  layout 'base' 
  exempt_from_layout 'builder', 'rsb' 
 
  # Remove broken cookie after upgrade from 
0.8.x (#4292) 
  # See 
https://rails.lighthouseapp.com/projects/8994/tick
ets/3360 
  # TODO: remove it when Rails is fixed 
  before_filter :delete_broken_cookies 
  def delete_broken_cookies 
    if cookies['_redmine_session'] && 
cookies['_redmine_session'] !~ /--/ 
      cookies.delete '_redmine_session' 
      redirect_to home_path 
      return false 
    end 
  end 
 
  
before_filter :user_setup, :check_if_login_require
d, :set_localization 
  filter_parameter_logging :password 
  protect_from_forgery 
 
  rescue_from 
ActionController::InvalidAuthenticityToken, :wit
h => :invalid_authenticity_token 
  rescue_from ::Unauthorized, :with 
=> :deny_access 
 
  include Redmine::Search::Controller 
  include 
Redmine::MenuManager::MenuController 
  helper Redmine::MenuManager::MenuHelper 
 
  Redmine::Scm::Base.all.each do |scm| 
    require_dependency 
"repository/#{scm.underscore}" 
  end 
 
  def user_setup 
    # Check the settings cache for each request 
    Setting.check_cache 
    # Find the current user 
    User.current = find_current_user 
  end 
 
  # Returns the current user or nil if no user is 
logged in 
  # and starts a session if needed 
  def find_current_user 
    if session[:user_id] 
      # existing session 
      (User.active.find(session[:user_id]) rescue 
nil) 
    elsif cookies[:autologin] && 
Setting.autologin? 
      # auto-login feature starts a new session 
      user = 
User.try_to_autologin(cookies[:autologin]) 
      session[:user_id] = user.id if user 
      user 
    elsif params[:format] == 'atom' && 
params[:key] && request.get? && 
accept_rss_auth? 
      # RSS key authentication does not start a 
session 
      User.find_by_rss_key(params[:key]) 
    elsif Setting.rest_api_enabled? && 
accept_api_auth? 
      if (key = api_key_from_request) 
        # Use API key 
        User.find_by_api_key(key) 
      else 
        # HTTP Basic, either 
username/password or API key/random 
        authenticate_with_http_basic do 
|username, password| 
          User.try_to_login(username, 
password) || User.find_by_api_key(username) 
        end 
      end 
    end 
  end 
 
  # Sets the logged in user 
  def logged_user=(user) 
    reset_session 
    if user && user.is_a?(User) 
20 
 
 
  # Authorize the user for the requested action 
outside a project 
  def authorize_global(ctrl = params[:controller], 
action = params[:action], global = true) 
    authorize(ctrl, action, global) 
  end 
 
  # Find project of id params[:id] 
  def find_project 
    @project = Project.find(params[:id]) 
  rescue ActiveRecord::RecordNotFound 
    render_404 
  end 
 
  # Find project of id params[:project_id] 
  def find_project_by_project_id 
    @project = 
Project.find(params[:project_id]) 
  rescue ActiveRecord::RecordNotFound 
    render_404 
  end 
 
  # Find a project based on params[:project_id] 
  # TODO: some subclasses override this, see 
about merging their logic 
  def find_optional_project 
    @project = Project.find(params[:project_id]) 
unless params[:project_id].blank? 
    allowed = 
User.current.allowed_to?({:controller => 
params[:controller], :action => params[:action]}, 
@project, :global => true) 
    allowed ? true : deny_access 
  rescue ActiveRecord::RecordNotFound 
    render_404 
  end 
 
  # Finds and sets @project based on 
@object.project 
  def find_project_from_association 
    render_404 unless @object.present? 
 
    @project = @object.project 
  rescue ActiveRecord::RecordNotFound 
    render_404 
  end 
 
  def find_model_object 
    model = 
self.class.read_inheritable_attribute('model_objec
t') 
    if model 
      @object = model.find(params[:id]) 
      self.instance_variable_set('@' + 
controller_name.singularize, @object) if @object 
    end 
  rescue ActiveRecord::RecordNotFound 
    render_404 
  end 
 
  def self.model_object(model) 
    write_inheritable_attribute('model_object', 
model) 
  end 
 
  # Filter for bulk issue operations 
  def find_issues 
    @issues = Issue.find_all_by_id(params[:id] 
|| params[:ids]) 
    raise ActiveRecord::RecordNotFound if 
@issues.empty? 
    if @issues.detect {|issue| !issue.visible?} 
      deny_access 
      return 
    end 
    @projects = 
@issues.collect(&:project).compact.uniq 
    @project = @projects.first if @projects.size 
== 1 
  rescue ActiveRecord::RecordNotFound 
    render_404 
  end 
 
  # Check if project is unique before bulk 
operations 
  def check_project_uniqueness 
    unless @project 
      # TODO: let users bulk edit/move/destroy 
issues from different projects 
      render_error 'Can not bulk 
edit/move/destroy issues from different projects' 
      return false 
    end 
  end 
 
  # make sure that the user is a member of the 
project (or admin) if project is private 
  # used as a before_filter for actions that do not 
require any particular permission on the project 
  def check_project_privacy 
    if @project && @project.active? 
22 
 
    @items = items || [] 
    @items.sort! {|x,y| y.event_datetime <=> 
x.event_datetime } 
    @items = @items.slice(0, 
Setting.feeds_limit.to_i) 
    @title = options[:title] || Setting.app_title 
    render :template => 
"common/feed.atom.rxml", :layout => 
false, :content_type => 'application/atom+xml' 
  end 
   
  # TODO: remove in Redmine 1.4 
  def self.accept_key_auth(*actions) 
    ActiveSupport::Deprecation.warn 
"ApplicationController.accept_key_auth is 
deprecated and will be removed in Redmine 1.4. 
Use accept_rss_auth (or accept_api_auth) 
instead." 
    accept_rss_auth(*actions) 
  end 
 
  # TODO: remove in Redmine 1.4 
  def accept_key_auth_actions 
    ActiveSupport::Deprecation.warn 
"ApplicationController.accept_key_auth_actions 
is deprecated and will be removed in Redmine 
1.4. Use accept_rss_auth (or accept_api_auth) 
instead." 
    self.class.accept_rss_auth 
  end 
   
  def self.accept_rss_auth(*actions) 
    if actions.any? 
      
write_inheritable_attribute('accept_rss_auth_acti
ons', actions) 
    else 
      
read_inheritable_attribute('accept_rss_auth_actio
ns') || [] 
    end 
  end 
   
  def accept_rss_auth?(action=action_name) 
    
self.class.accept_rss_auth.include?(action.to_sym
) 
  end 
   
  def self.accept_api_auth(*actions) 
    if actions.any? 
      
write_inheritable_attribute('accept_api_auth_acti
ons', actions) 
    else 
      
read_inheritable_attribute('accept_api_auth_actio
ns') || [] 
    end 
  end 
   
  def accept_api_auth?(action=action_name) 
    
self.class.accept_api_auth.include?(action.to_sy
m) 
  end 
 
  # Returns the number of objects that should be 
displayed 
  # on the paginated list 
  def per_page_option 
    per_page = nil 
    if params[:per_page] && 
Setting.per_page_options_array.include?(params[
:per_page].to_s.to_i) 
      per_page = params[:per_page].to_s.to_i 
      session[:per_page] = per_page 
    elsif session[:per_page] 
      per_page = session[:per_page] 
    else 
      per_page = 
Setting.per_page_options_array.first || 25 
    end 
    per_page 
  end 
 
  # Returns offset and limit used to retrieve 
objects 
  # for an API response based on offset, limit 
and page parameters 
  def api_offset_and_limit(options=params) 
    if options[:offset].present? 
      offset = options[:offset].to_i 
      if offset < 0 
        offset = 0 
      end 
    end 
    limit = options[:limit].to_i 
    if limit < 1 
      limit = 25 
    elsif limit > 100 
      limit = 100 
24 
 
  # Converts the errors on an ActiveRecord 
object into a common JSON format 
  def object_errors_to_json(object) 
    object.errors.collect do |attribute, error| 
      { attribute => error } 
    end.to_json 
  end 
 
  # Renders API response on validation failure 
  def render_validation_errors(object) 
    options = { :status 
=> :unprocessable_entity, :layout => false } 
    options.merge!(case params[:format] 
      when 'xml';  { :xml =>  object.errors } 
      when 'json'; { :json => {'errors' => 
object.errors} } # ActiveResource client 
compliance 
      else 
        raise "Unknown format 
#{params[:format]} in 
#render_validation_errors" 
      end 
    ) 
    render options 
  end 
 
  # Overrides #default_template so that the api 
template 
  # is used automatically if it exists 
  def default_template(action_name = 
self.action_name) 
    if api_request? 
      begin 
        return 
self.view_paths.find_template(default_template_
name(action_name), 'api') 
      rescue ::ActionView::MissingTemplate 
        # the api template was not found 
        # fallback to the default behaviour 
      end 
    end 
    super 
  end 
 
  # Overrides #pick_layout so that #render with 
no arguments 
  # doesn't use the layout for api requests 
  def pick_layout(*args) 
    api_request? ? nil : super 
  end 
end 
 
8. attachments_controller.rb 
 
# Redmine - project management software 
# Copyright (C) 2006-2011  Jean-Philippe Lang 
# 
# This program is free software; you can 
redistribute it and/or 
# modify it under the terms of the GNU General 
Public License 
# as published by the Free Software Foundation; 
either version 2 
# of the License, or (at your option) any later 
version. 
# 
# This program is distributed in the hope that it 
will be useful, 
# but WITHOUT ANY WARRANTY; without 
even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A 
PARTICULAR PURPOSE.  See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU 
General Public License 
# along with this program; if not, write to the 
Free Software 
# Foundation, Inc., 51 Franklin Street, Fifth Floor, 
Boston, MA  02110-1301, USA. 
 
class AttachmentsController < 
ApplicationController 
  before_filter :find_project 
  
before_filter :file_readable, :read_authorize, :exc
ept => :destroy 
  before_filter :delete_authorize, :only 
=> :destroy 
 
  verify :method => :post, :only => :destroy 
 
  def show 
    if @attachment.is_diff? 
      @diff = File.new(@attachment.diskfile, 
"rb").read 
      render :action => 'diff' 
    elsif @attachment.is_text? && 
@attachment.filesize <= 
Setting.file_max_size_displayed.to_i.kilobyte 
      @content = 
File.new(@attachment.diskfile, "rb").read 
26 
 
class AuthSourcesController < 
ApplicationController 
  layout 'admin' 
   
  before_filter :require_admin 
 
  # GETs should be safe (see 
http://www.w3.org/2001/tag/doc/whenToUseGet.
html) 
  verify :method => :post, :only => 
[ :destroy, :create, :update ], 
         :redirect_to => { :template 
=> :index } 
 
  def index 
    @auth_source_pages, @auth_sources = 
paginate 
auth_source_class.name.tableize, :per_page => 
10 
    render "auth_sources/index" 
  end 
 
  def new 
    @auth_source = auth_source_class.new 
    render 'auth_sources/new' 
  end 
 
  def create 
    @auth_source = 
auth_source_class.new(params[:auth_source]) 
    if @auth_source.save 
      flash[:notice] = 
l(:notice_successful_create) 
      redirect_to :action => 'index' 
    else 
      render 'auth_sources/new' 
    end 
  end 
 
  def edit 
    @auth_source = 
AuthSource.find(params[:id]) 
    render 'auth_sources/edit' 
  end 
 
  def update 
    @auth_source = 
AuthSource.find(params[:id]) 
    if 
@auth_source.update_attributes(params[:auth_so
urce]) 
      flash[:notice] = 
l(:notice_successful_update) 
      redirect_to :action => 'index' 
    else 
      render 'auth_sources/edit' 
    end 
  end 
   
  def test_connection 
    @auth_method = 
AuthSource.find(params[:id]) 
    begin 
      @auth_method.test_connection 
      flash[:notice] = 
l(:notice_successful_connection) 
    rescue => text 
      flash[:error] = l(:error_unable_to_connect, 
text.message) 
    end 
    redirect_to :action => 'index' 
  end 
 
  def destroy 
    @auth_source = 
AuthSource.find(params[:id]) 
    unless @auth_source.users.find(:first) 
      @auth_source.destroy 
      flash[:notice] = 
l(:notice_successful_delete) 
    end 
    redirect_to :action => 'index' 
  end 
 
  protected 
 
  def auth_source_class 
    AuthSource 
  end 
end 
 
10. boards_controller.rb 
 
# Redmine - project management software 
# Copyright (C) 2006-2011  Jean-Philippe Lang 
# 
# This program is free software; you can 
redistribute it and/or 
# modify it under the terms of the GNU General 
Public License 
# as published by the Free Software Foundation; 
either version 2 
28 
 
 
  def destroy 
    @board.destroy 
    redirect_to_settings_in_projects 
  end 
   
private 
  def redirect_to_settings_in_projects 
    redirect_to :controller => 'projects', :action 
=> 'settings', :id => @project, :tab => 'boards' 
  end 
 
  def find_project 
    @project = 
Project.find(params[:project_id]) 
  rescue ActiveRecord::RecordNotFound 
    render_404 
  end 
 
  def find_board_if_available 
    @board = @project.boards.find(params[:id]) 
if params[:id] 
  rescue ActiveRecord::RecordNotFound 
    render_404 
  end 
end 
 
11. documents_controller.rb 
 
# redMine - project management software 
# Copyright (C) 2006-2007  Jean-Philippe Lang 
# 
# This program is free software; you can 
redistribute it and/or 
# modify it under the terms of the GNU General 
Public License 
# as published by the Free Software Foundation; 
either version 2 
# of the License, or (at your option) any later 
version. 
#  
# This program is distributed in the hope that it 
will be useful, 
# but WITHOUT ANY WARRANTY; without 
even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A 
PARTICULAR PURPOSE.  See the 
# GNU General Public License for more details. 
#  
# You should have received a copy of the GNU 
General Public License 
# along with this program; if not, write to the 
Free Software 
# Foundation, Inc., 51 Franklin Street, Fifth Floor, 
Boston, MA  02110-1301, USA. 
 
class DocumentsController < 
ApplicationController 
  default_search_scope :documents 
  model_object Document 
  before_filter :find_project, :only => 
[:index, :new] 
  before_filter :find_model_object, :except => 
[:index, :new] 
  
before_filter :find_project_from_association, :ex
cept => [:index, :new] 
  before_filter :authorize 
   
  helper :attachments 
   
  def index 
    @sort_by = %w(category date title 
author).include?(params[:sort_by]) ? 
params[:sort_by] : 'category' 
    documents = 
@project.documents.find :all, :include => 
[:attachments, :category] 
    case @sort_by 
    when 'date' 
      @grouped = documents.group_by {|d| 
d.updated_on.to_date } 
    when 'title' 
      @grouped = documents.group_by {|d| 
d.title.first.upcase} 
    when 'author' 
      @grouped = documents.select{|d| 
d.attachments.any?}.group_by {|d| 
d.attachments.last.author} 
    else 
      @grouped = 
documents.group_by(&:category) 
    end 
    @document = @project.documents.build 
    render :layout => false if request.xhr? 
  end 
   
  def show 
    @attachments = 
@document.attachments.find(:all, :order => 
"created_on DESC") 
  end 
30 
 
  def index 
    @groups = Group.find(:all, :order => 
'lastname') 
 
    respond_to do |format| 
      format.html # index.html.erb 
      format.xml  { render :xml => @groups } 
    end 
  end 
 
  # GET /groups/1 
  # GET /groups/1.xml 
  def show 
    @group = Group.find(params[:id]) 
 
    respond_to do |format| 
      format.html # show.html.erb 
      format.xml  { render :xml => @group } 
    end 
  end 
 
  # GET /groups/new 
  # GET /groups/new.xml 
  def new 
    @group = Group.new 
     
    respond_to do |format| 
      format.html # new.html.erb 
      format.xml  { render :xml => @group } 
    end 
  end 
 
  # GET /groups/1/edit 
  def edit 
    @group = Group.find(params[:id], :include 
=> :projects) 
  end 
 
  # POST /groups 
  # POST /groups.xml 
  def create 
    @group = Group.new(params[:group]) 
 
    respond_to do |format| 
      if @group.save 
        flash[:notice] = 
l(:notice_successful_create) 
        format.html 
{ redirect_to(groups_path) } 
        format.xml  { render :xml => 
@group, :status => :created, :location => 
@group } 
      else 
        format.html { render :action => 
"new" } 
        format.xml  { render :xml => 
@group.errors, :status 
=> :unprocessable_entity } 
      end 
    end 
  end 
 
  # PUT /groups/1 
  # PUT /groups/1.xml 
  def update 
    @group = Group.find(params[:id]) 
 
    respond_to do |format| 
      if 
@group.update_attributes(params[:group]) 
        flash[:notice] = 
l(:notice_successful_update) 
        format.html 
{ redirect_to(groups_path) } 
        format.xml  { head :ok } 
      else 
        format.html { render :action => "edit" } 
        format.xml  { render :xml => 
@group.errors, :status 
=> :unprocessable_entity } 
      end 
    end 
  end 
 
  # DELETE /groups/1 
  # DELETE /groups/1.xml 
  def destroy 
    @group = Group.find(params[:id]) 
    @group.destroy 
 
    respond_to do |format| 
      format.html { redirect_to(groups_url) } 
      format.xml  { head :ok } 
    end 
  end 
   
  def add_users 
    @group = Group.find(params[:id]) 
    users = 
User.find_all_by_id(params[:user_ids]) 
    @group.users << users if request.post? 
    respond_to do |format| 
國科會補助計畫衍生研發成果推廣資料表
日期:2012/01/05
國科會補助計畫
計畫名稱: 雲端運算技術在油氣探採之應用
計畫主持人: 陳俊良
計畫編號: 100-2623-E-011-004-ET 學門領域: 石油開發技術
無研發成果推廣資料
申請中件數 0 0 100%  專利 
已獲得件數 0 0 100% 
件 
 
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
雲端運算為近年來熱門之應用研發議題，透過其具彈性之運算能力與儲存空間
應用於油氣探採領域，可有效縮短油氣生產過程中，即時資訊的存取及管控。
本研究透過文獻探討、遠距訪談與個案分析的方式，針對雲端運算技術應用於
油氣探採之導入方法、成效分析、資訊架構與可能遇到的瓶頸，進行研究與評
估，提出國內石油公司未來導入雲端運算之可行性分析與具體建議。本研究計
畫除探討如何將雲端運算技術應用於油氣探採外，並進行成果比對，以瞭解國
外各石油公司執行之步驟差異，其結果可做國內石油公司未來將雲端運算結合
油氣探採之參考。 
 
本研究計畫完成：(1)雲端運算技術應用於國外探採技術之現況與架構分析；(2)
國內石油公司導入雲端運算的可行性分析與具體建議。本研究探討雲端運算應
用在油層探勘、油氣生產、成本計算、資料存取、即時資訊更新和現場風險評
估等，未來國內石油公司導入雲端運算應用於油氣探採時，本計畫研究成果可
提供創新的管理方式與整合新興科技之應用，協助提高管理績效。透過本研究
分析，確認雲端運算在油氣探勘的預測、油氣產能的擴大、成本耗損的減低、
資料往返時程的縮短、資料即時的更新和現場風險的評估，皆有正面助益。未
來國內石油公司導入雲端運算應用於油氣探採時，本研究成果將可提供創新的
管理方式與整合新興科技的應用，以提高油氣探採的績效，並提升整體營運效
益。 
 
在協助產業技術發展方面，本計畫主持人除參與執行產學合作計畫(台灣電力公
司、浩鑫股份有限公司與融程電信股份有限公司)外，亦時常擔任法人(工研院
及資策會)及產業(雲端產業類公司、工業電腦類公司)技術人才培育之講師，將
學校研究成果直接轉移至產業實務應用。近期亦參與政府多起產業計畫之審查
工作，除書面外亦至產業給予實務技術之評估與交流，協助產業往前瞻與創新
技術發展。 
 
在國際標準制定上，以往我國因較少參與國際標準制定，使得我國在關鍵智財
權(Essential IPR)與核心技術較少，每年必須大量外購關鍵零組件與支付巨額
權利金，降低我國資通訊產品競爭力。為解決此困境，本計畫將研究成果積極
參與雲端技術應用於石油產業相關架構與標準制訂，提升我國資訊科技的國際
能見度。目前本案計畫主持人已與上海大學、澳洲 CSIRO ICT 中心及挪威斯塔
萬格大學(University of Stavanger)，進行雲端運算技術在油氣探採之應用技
術分析與架構探討，本案將持續參與並提出相關架構制定等技術與專利貢獻。
 
 成果項目 量化 名稱或內容性質簡述 
科 測驗工具(含質性與量性) 0  
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
■達成目標 
□未達成目標（請說明，以 100 字為限） 
□實驗失敗 
□因故實驗中斷 
□其他原因 
說明： 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：□已發表 ■未發表之文稿 □撰寫中 □無 
專利：□已獲得 □申請中 ■無 
技轉：□已技轉 ■洽談中 □無 
其他：（以 100 字為限） 
本研究計畫完成：(1)雲端運算技術應用於國外探採技術之現況與架構分析；(2)國內石油
公司導入雲端運算的可行性分析與具體建議。根據本計畫研究結果顯示，目前已有多家石油
公司結合智慧聯網(Internet of Things)裝置，應用於油氣探採之領域，提供即時資料存取
平台協助石油探採，並導入新科技進行油氣生產與開發的協同管理，以提升企業產值。上述
之研究成果對於全球能源產業具有關鍵性研究指標之參考價值，因此本計畫案除已完成「雲
端運算技術在油氣探採之應用」研究報告外，更將上述研究成果轉化為國際期刊論文與研討
會論文，做為未來全球研究此領域學者可參考之重要資訊，並可協助我國提升於此領域之關
鍵角色能力進而達到接軌國際，擴大我國研發能量蘊含。 
3. 請依學術成就、技術創新、社會影響等方面，評估研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）（以
500 字為限） 
根據本計畫之研究，雲端運算已開始應用於國外的油氣探勘與鑽採領域，結合雲端運算具
體優勢在於可以有效縮短油氣開採過程中的知識流通與分享的時間，透過資源的有效配置
與資訊的快速擴散，可達成即時知識與資訊的存取與管控。 
 
隨著石油能源產業的迫切需求和雲端運算技術的蓬勃發展，政府亦積極推動雲端運算，經
由各種國內推行的計畫可以預見國內政府對雲端應用的支持度，雲端運算技術與石油探採
的結合，絕對是國內政府當前關注之焦點。當前國內石油公司針對雲端運算導入油氣探採
之應用研究，尚屬啓蒙階段，本計畫基於上述需求，針對雲端運算技術在油氣探採之應用
進行研究分析，不僅研究雲端運算是否適合導入能源產業，更評估已導入雲端運算之產業
所能獲得效益進行分析。 
 
於產業影響方面，透過本計畫之研究綜觀國內各家石油公司的現況，藉此評估國內石油公
