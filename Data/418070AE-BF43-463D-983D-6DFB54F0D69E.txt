1行政院國家科學委員會補助專題研究計畫
■ 成 果 報 告
□期中進度報告
具輸出入裝置之(m,k)即時系統上的省電排程
計畫類別：■個別型計畫 □整合型計畫
計畫編號：NSC 99-2221-E-390-017
執行期間： 2010 年 8 月 1日至 2011 年 11 月 15 日
執行機構及系所：國立高雄大學 資訊工程學系
計畫主持人：郭錦福
共同主持人：
計畫參與人員：黃群雄、林豊鈞
成果報告類型(依經費核定清單規定繳交)：■精簡報告 □完整報告
本計畫除繳交成果報告外，另須繳交以下出國心得報告：
□赴國外出差或研習心得報告
□赴大陸地區出差或研習心得報告
■出席國際學術會議心得報告
□國際合作研究計畫國外研究報告
處理方式：除列管計畫及下列情形者外，得立即公開查詢
□涉及專利或其他智慧財產權，□一年□二年後可公開查詢
中 華 民 國 101 年 1 月 15 日
附件一
3在一個嵌入式系統中，除了處理器之外，也經常性的會有周邊裝置(如：記憶體、flash memory、
無線介面)，這些裝置是會消耗電能的，尤其是硬碟[10]，如圖1所示。動態電量管理(dynamic power
management: DPM)技術經常使用timeout機制來最小化週邊裝置的電能消耗，如果裝置閒置過久，則關
閉此裝置。一般的DPM研究大多是專注在非即時系統上，但是我們要注意的是其實除了處理器在執行
程式需要耗電之外，週邊裝置也是會耗電的。儘管關閉裝置或是將裝置切換成休眠模式可以節省裝置
的電能使用，但是我們需要注意的是開啟裝置或是在切換成可使用狀況是要花成本的(如：時間或是電
能)。另外，如果僅考慮處理器的省電的話，工作的執行時間可能會被拉長，如此一來裝置的使用時間
也會拉長，裝置所使用的耗電量會變大，所以處理器和裝置的耗電量之間存在著密切的關係[48]。
即時系統通常是由一組工作(task)所集合而成的，這些工作可能是週期性或是非週期性的，週期性
的工作由一連串的 job 所組成，job 中的執行需求的完成時間點被要求一定要在截線時間(deadline)之前
要完成，否則可能出現某種嚴重問題，這種系統被稱之為硬即時系統(hard real-time system)。然而我們
可以從許多的現實例子中發現，並非所有現實中的系統都有這麼嚴格的要求，譬如有些系統使用者可
以容忍系統中有工作的 job 可以 miss deadline，但需要平均地散佈在工作執行中的連續 job，如在[1,2,3]
中所提的多媒體訊號處理(multimedia processing)、即時通訊(real-time communication)、嵌入式控制系統
(embedded control system)。像多媒體應用中的視訊會議是可以容忍。因為有些系統所要求的是決定性
(deterministic)QoS[4,5,11]，而不是機率性的 QoS。為了要提供決定性(deterministic)QoS 給即時系統，系
統必須要支援統計性且最低極限的 QoS。一些類似的模式被提出，最具代表性的是(m,k) (0<m≦k)
real-time 模式[1,4,5]，這個模式定義了每個工作(task)在連續的 k 的 job 中需要最少 m 個 job 是 meet
deadline。如果在某個時間間格中發現此 QoS 限制被違反了，則系統產生了一個動態錯誤(dynamic
failure)，代表著系統排程器(scheduler)產生錯誤。這種要保證符合(m,k)要求的問題已經有學者證明是
NP-hard[4]。事實上，(m,k) model 是硬即時(hard real-time：HRT)的放寬條件變形，因為 HRT 可以當成
(k,k) model。
本研究目的是針對具週邊裝置的(m,k)嵌入式即時系統上的省電問題，因應工作時間限制特性與
(m,k)參數特性，提出一系列的即時省電排程機制，除了滿足(m,k)的需求外，且最小化系統執行過程
中的電量使用。來延長系統的運作時間，和達成系統中工作的時間要求，避免由於電量不足而關機，
或是減少重要工作無法在截線時間之前完成的情況出現。在過去研究中，絕大部分的假設是只考慮到
處理器支援 DVS 技術、單純(m,k)model、或是非即時系統中的裝置耗電性的探討，但誠如我們之前所
探討的，在目前常見系統中，其實有許多是可以抽象成系統中的應用程式執行需求符合(m,k) model，
且嵌入式系統所使用的是具 DVS 支援的處理器，系統中還有 I/O 裝置。由於嵌入式的硬體架構和執
行在嵌入式平台的工作特性，因此不可能提出一個符合各種情形之省電排程演算法，並須經由詳盡的
系統架構與工作特性分析後，才可能研究出符合特定性質之排程方法，來保證系統中的即時工作之
(m,k)即時需求。
2、相關研究
有一些研究整合(m,k)限制[13]設計了新的排程演算法，這些方法可以分成兩大類：動態與靜態。
Distance based priority (DBP)[1]和Dynamic Window-Constrained Scheduling屬於動態的方法，而Enhanced
Rate Monotonic (ERM)[5]和Enhanced Fixed-Priority (EFP)[4]則屬於靜態方法。 Hamdaoni 和Ramanathan
[1]針對(m,k) model提出了distance based priority (DBP) 方式來對一組job stream作排程，這個方法的背後
原理是依據job離錯誤狀態(failure state)的距離來動態給予優先權，距離越進者，代表有大的機率將會發
生錯誤狀態，因此需要給予較高的優先權，雖然此方法有不錯的效能表現，但是尚缺充分的可排程條
5統層次(system-level)耗電量總合，在這篇研究中作者假設裝置並沒有 DVS 支援。還有其他研究所探討
的議題是在 I/O 裝置的耗電性部分，將處理器部分給忽略，如[24,25]。另外，有一些研究是藉由最少
化搶先的次數來減少系統層次的耗電量[21]，因為允許搶先會導致工作的執行完成時間變長，裝置的
使用電量變多，所以延遲搶先的發生可以減少電量的消耗。因為切換狀態需要花額外的時間與時間，
在[22]的研究中，作者定義出可以藉由切換狀況來節省電量的最小閒置時間長度，如果閒置時間已超過
這個值，裝置就應該被切換成較省電的狀態。在[23]中，一個結合 DVS 和 DPM 的架構被提出，這個
機制主要要解決的問題對象是 I/O 裝置所消耗的電量佔整體的耗電量最大宗。
3、系統模式
我們假設只有一個處理器，且處理器具有 DVS 機制，處理器所能運作的電壓(/速度)並不是任意，
換句話說，處理器只能在某些允許的電壓(/速度)下運作[18, 19]，我們假設處理器的可運作電壓(/速
度){f1, f2, ..fM}，另外我們也假設處理器在切換電壓(/速度)的成本可以被忽略。
本研究中所要探討嵌入式系統中的問題的描述如下，一個(m,k) model即時系統中有N個週期性工作
N ,..,, 21 ，每個工作 j都有下列的參數，說明如下：
(1) 釋放時間(Release time) jr
(2) 週期(period) jp
(3) 截限時間 (deadline) jd
(4) 執行 cycle jc
(5) 裝置使用集合(device usage list) Li 來紀錄 j執行過程中會使用到的裝置，如果集合為空集合，
則代表不會使用到裝置。
針對這些工作我們有一些假設：
(1) 工作之間是獨立的而且可以被搶先
(2) 工作的job之deadline可能無法每個都meet
(3) 每個task j是由兩個整數mj和kj來描述，代表連續個mj的job中最少要有kj job是meet deadline。
由於處理器的所能運作的速度調整，假設工作開始執行後，不再調整供應電量，則在單位時間供
應電量 PD 下執行的工作，worst-case execution cycle 為 ci，則所消耗的電量 Ei(PD)可以下列式子算出，
s
c
*P)(PE iDDi 
式子中
dd
tdd
V
VV
s
2)(  得知，Vdd為供應之電壓，Vt為維持運作之最小供應電壓，為和硬體有關之係
數。執行速度越快，雖然可以以較少的時間完成，但是會需要較高電量消耗；反之，如果以較慢的執
行速度執行，雖然可以減少電量消耗，但卻延長了所需之執行時間。因此，工作的執行在消耗電能和
執行時間上存在著相依性，我們必須在這兩者之間者到一個平衡點，賴達成以現有的電量來達成工作
7藉由上面的參數定義，我們可以將本研究要探討的問題定義成：給予一個(m,k)工作集合和此工作集
合會使用到的I/O裝置集合H，請找出job的開始執行時間以致於裝置的耗電量被最小化且job能夠meet
(m,k)的條件。
在本研究中，我們和過去的研究主要的不同在於我們考慮到未來大部分的嵌入式系統將逐漸採用
具有 DVS 機制的處理器，且配備了 I/O 裝置，系統中的工作不需要 100% meet deadline，只需要達成
(m,k) 需求。首先我們將探討的工作是裝置的狀態切換是不需花額外時間與電量，之後則是需花額外時
間與電量，針對這兩種不同特性的問題，我們將提出排程演算法來決定處理器應該以何種電壓(/速度)
來執行各個工作與裝置何時應該切換成高能量狀態和切換成低能量狀態，所有工作都能夠具有即時保
證下使用較少的電量。在本研究中，我們假設工作是允許被搶先的，且搶先的成本是可以忽略的。
4、提出之方法
第一階段：符合(m,k)需求
針對每個 task i需要滿足的(mj,kj)需求，我們將要利用[11]的 Evenly Distributed Pattern、[54]
的 Deeply Red-Pattern、和[55]的 Reverse Evenly Distributed Pattern 作法，將工作的 job 分類成必須
要執行和不需要執行兩種。儘管這些方法都是不錯的方式，但是由於都只侷限在探討單一一個工
作(task)的本身(local)(m,k)特性，完全沒考慮到 task 的 job 之間的影響(global)，可能導致會有突然
在某個時間區間會有一堆 job 需要執行的狀況。例如：系統中有兩個 task i和 j， i的
(2,3)),( ii km 、週期和執行時間皆為 3， j的 (1,1)),( jj km 、週期和執行時間分別為 1 和 6，如
果依據 Deeply Red-Pattern、Evenly Distributed Pattern、和 Reverse Evenly Distributed Pattern，task
i的執行樣式(pattern)分別是(1,1,0)、(1,1,0)、和(0,1,1)，Deeply Red-Pattern、Evenly Distributed Pattern
都會使得系統中會有 task 無法滿足(m,k)需求，如圖 3 所示。如果工作到達系統的時間(ready time)
並非都是 0 的時，結果又不一樣，如圖 4 所示， i和 j的 ready time 分別是 0 和 4。
i i
i
j
i
j
圖 3 i在(1,1,0)與(0,1,1)執行樣式的執行狀況
9的執行不會miss deadline且需要考慮到裝置閒置的時間是否有大於或是等於breakeven time，如果有
則選擇切換到低能量的狀態，否則維持高能量的狀態，這樣一來，電量消耗才會最小化。當可以
延伸到樹的下一層時，代表著系統可以執行此job。我們將探討如何建立表1的對應排程樹，我們
假設兩個裝置在高(/低)能量狀態時所需要的電量是6(/1)單位，而轉換狀態所需的時間是1單位，所
需的電量是3單位。利用式子(4)，求得breakeven time為 2)11,
16
2*12*3
( 


Max ，如果閒置時間沒
超過2個單位時間則裝置不會切換成低能量狀態。如果在建樹的時候沒有考慮到pruning的條件，則
可能建造出一個非常巨大的樹，因此需要加上子樹刪除(pruning)條件，譬如：(1)如果會導致有job
miss deadline則這個節點就不會在延伸下去(如：如果將j3的開始執行時間(starting time)點安排在時
間點9，則j4一定會miss deadline，所以j3在時間點9之下的子樹即不用再長下去)，(2)如果同一層的
節點中，出現前面的兩個訊息一樣時，則我們只會選擇延伸有最小電量消耗的節點，因為這是執
行相同工作子集合的最省電方式。這些pruning的條件在計劃進行過程中，將會更深入的探討與證
明其正確性。圖5是依據上述方式所建立出的部份排程樹，粗體線條的路徑代表job在執行階段的
開始執行時間點。
J1,0,0
J2,3,23
Root
J3,6,46 J3,7,53 J3,8,52 J3,9,54
J4,9,63 J4,9,66 J4,9,58
J5,14,92J5,13,90J5,12,86 J5,15,94
J6,12,84
J7.16,116 J7.17,123 J7.18,124 J7.19,126 J7,20,128 J7,21,130
J8.18,129 J8.18,132 J8.18,147
J9.21,150
J10,25,177 J10,26,179 J10,27,181J10,24,173
圖5 排程完4個job後的部分排程
11
0.75
0.8
0.85
0.9
0.95
1
1,10 2,10 3,10 4,10 5,10 6,10 7,10 8,10 9,10
(m,k)
N
od
e
Sa
vi
ng
R
at
e
Deeply Red
Evenly Distributed
Reversed Evenly Distributed
圖 7 不同 QoS 的記憶體使用量
參考文獻：
[1] M. Hamdaoui and P. Ramanathan. A dynamic priority assignment technique for streams with (m,k)-firm
deadlines. IEEE Transactions on Computers, vol. 44, no. 5, pp. 1443 – 1451, Dec. 1995.
[2] D. Isovic and G. Fohler. Quality aware MPEG-2 stream adaptation in resource constrained systems.
Proceedings of the 16th EuroMicro Conference on Real-Time Systems (ECRTS'04), Catania, Italy, June
2004.
[3] G. Koren and D. Shasha. Skip-Over: algorithms and complexity for overloaded systems that allow skips.
Proceedings of the 16th IEEE Real-Time Systems Symposium (RTSS’95), Pisa, Italy, Dec. 1995.
[4] G. Quan and X. Hu. Enhanced fixed-priority scheduling with (m,k)-firm guarantee. Proceedings of the
21st IEEE Real-Time SystemsSymposium (RTSS’00), Orlando, FL, Nov. 2000.
[5] P. Ramanathan. Overload management in real-time control applications using (m, k)-firm guarantee. IEEE
Transactions on Parallel and Distributed Systems, vol. 10, no. 6, pp. 549–559, June 1999.
[6] H. Aydin, R. Melhem, D. Mosse and P.M. Alvarez. Power-aware Scheduling for Periodic Real-time Tasks.
IEEE Transactions on Computers, vol. 53, no. 5, pp. 584-600, May 2004.
[7] Y. Liu and A. Mok. An Integrated Approach for Applying Dynamic Voltage Scaling to Hard Real-Time
Systems. Proceedings of the 9th IEEE Real-Time and Embedded Technology and Applications Symposium
(RTAS’03), Washington D.C., May 2003.
[8] P. Pillai and K.G. Shin. Real-time dynamic voltage scaling for low power embedded operating systems.
Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP’01), Oct. 2001.
[9] A. Qadi, S. Goddard, and S. Farritor. A Dynamic Voltage Scaling Algorithm for Sporadic Tasks.
Proceedings of the 24th IEEE Real-Time Systems Symposium (RTSS’03), Cancun, Mexico, Dec. 2003.
[10] K. Li, R. Kumpf, P. Horton, T. Anderson, "A quantitative analysis of disk drive power management in
portable computers", Proc. Usenix Winter 1994 Conf.,pp. 279-292, 1994.
[11] M.Hamdaoui and P. Ramanathan, ‘Evaluating Dynamic FailureProbability for Streams with (m, k)-firm
Deadline’, IEEE Trans oneComputers, 46(12), pp.1325-1337, Dec.1997.
[12] A. Striegel and G. Manimaran. Best-effort scheduling of (m, k)-firm real-time streams in multihop
A Half-Key Key Management Scheme
for Wireless Sensor Networks
Yung-Feng Lu
Department of Computer
Science and Information
Engineering
National Taichung Institute of
Technology
yflu@ntit.edu.tw
Chin-Fu Kuo
Department of Computer
Science and Information
Engineering
National University of
Kaohsiung
chinfukuo2006@nuk.edu.tw
Ai-Chun Pang
Department of Computer
Science and Information
Engineering
National Taiwan University
acpang@csie.ntu.edu.tw
ABSTRACT
Wireless Sensor Networks (WSN) have recently been in the
limelight for many domains. The characteristics of sensor
networks have imposed various restrictions on their system
designs. Since sensor nodes usually are developed by low-
cost hardware, one major challenge in the development of
many sensor-network applications is to provide high-security
features with limited resources. In this paper, we propose a
half-key scheme based on the well-known random key pre-
distribution scheme and DDHV-D deployment knowledge to
provide resource-efficient key management in wireless sen-
sor networks with reduced memory space requirements and
better security enforcement. The capability of the proposed
approach is evaluated by an analytical model and a series of
experiments.
Categories and Subject Descriptors
C.2.0 [Computer Systems Organization]: Computer-
Communications Networks Security and Protection
General Terms
Security, Design
Keywords
wireless sensor networks, data delivery, security, key agree-
ment
1. INTRODUCTION
Wireless Sensor Networks (WSN) is an emerging technology
that has enabled various applications in many domains such
has environment monitoring, home automation, ubiquitous
computing, security enforcement and surveillance, military
systems. It plays a vital role in sensing, gathering and dis-
seminating information about environmental phenomena. A
sensor network usually consist of a large number of battery-
powered sensor nodes and some base stations. To secure
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee.
RACS ’11, November 2-5, 2011, Miami, FL, USA.
Copyright 2011 ACM 978-1-4503-1087-1/11/11 ...$10.00.
WSNs, the data transmission must be encrypted and au-
thenticated. Since sensor nodes usually are developed by
low-cost hardware, one major challenge in the deployment of
many sensor-network applications is to provide high-security
features with limited resources.
A lot of research results based on key encryption and/or
management have been proposed to enhance the security of
wireless sensor networks. Beside those excellent works on
key encryption [11, 14, 21, 23], key renewal scheme [10, 16],
lightweight authentic bootstrapping [5], many researchers
have also made their effective key management schemes,
such as those in [1, 2, 3, 4, 7, 9, 13, 19, 20, 22], in the
past few years. Tseng [15] proposed an authenticated group
key agreement protocol for resource-limited mobile devices.
A detailed survey of such schemes is provide by Xiao et. al.
in [18].
In particular, Eschenauer and Glicor proposed a random
key pre-distribution scheme (RKPS), in which each node is
randomly assigned a subset of keys from a key pool before
the deployment [4]. The RKPS consists of three phases:
key pre-distribution, shared-key discovery, and path-key es-
tablishment. If two neighboring nodes share one key, then
a direct link could be established. A q-composite random
key pre-distribution scheme [1] extends the random key pre-
distribution scheme by requiring two adjacent communicat-
ing sensor nodes to share at least q keys. The rationale
behind the extension is to provide a higher resilience for
key management. Liu and Ning [7] takes advantage of the
location information to improve the network connectivity.
In order to reduce the storage requirements of sensor nodes
and/or resolve the scalability issue, researchers have pro-
posed group-based or deployment-information-based method-
ologies, e.g., [3, 8, 22, 24]. Although the probability to have
two sensor nodes sharing common keying information in-
creased, a significant amount of keying information had to
be pre-loaded to each sensor node, regardless of whether a
piece of information would be used in the future. Perrig, et
al. [12] considered a secure architecture in which each node
shares a secret key with the base station. Two sensor nodes
must use the base station as a trusted third party to set up
a new key. Lai, et al. [6] proposed a session key negotiation
protocol based on a signal master key pre-deployed at sensor
nodes. Wong and Chen [17] considered key exchanging for
low-power computing devices, where one of the participants
255
2.2.2 Key-Space Predistribution
Algorithm 1 shows the procedure of key-space predistribu-
tion. Suppose the storage size of each sensor node is τ units
(unit: a full key). Since the size of each half-key space is λ+1
2
units, each sensor node could store 2τ
λ+1
half-key spaces. So,
after the key-space pools are set up, for each sensor node
in the deployment group Gi,j , we randomly select
2τ
λ+1
key
spaces from its corresponding half-key-space pool Si,j (Step
2); then, for each selected key space, we load the correspond-
ing row of its matrix into the memory of the node. Since
each half-key space might shared by two group of nodes,
i.e., as a local space or a visited space. To avoid collision,
for each half-key space, a node loads the row in the top half
of space if this space is a local space (Steps 3-5); otherwise,
it loads the row in the bottom half of space (Steps 6-8).
Algorithm 1: Key-Space Predistribution (for each
node nij.l)
1 for m = 1 to 2τ
λ+1
do
2 nij.l randomly select one new key space Ax from Sij ;
3 if Ax is a local space then
4 k = l;
5 Assign A(k) to nij.l;
6 else
7 k = l + ℵ
t×n ;
8 Assign A(k) to nij.l;
2.3 Online Phase: Session-Key Establishment
During the initialization of a sensor network, each node must
discover all of the half-key spaces shared with its neighboring
nodes within its wireless communication range. The discov-
ering of shared half-key spaces could be done by the broad-
casting of key-space identifiers among nodes. If the number
of half-key spaces shared between two neighboring nodes
is more than a user-defined threshold q, then we say that
these two nodes could establish a communication link; oth-
erwise, there is no communication link between these two
nodes. The rationale behind this setting is to avoid poten-
tial attacks, due to an insufficient number of session key
candidates.
Algorithm 2 shows the establishment of session key. If two
neighboring nodes i and j could have a communication link,
and i wishes to send data to j, then the initialization of the
communication link could be done as follows:
i first randomly picks up one half-key space sx in the com-
mon half-key space set of i and j (Step 1) and sends the
identifier idx of the selected half-key space to j (Step 2).
When j receives the identifier, j also randomly picks up one
half-key space sy in the common half-key space set of i (Step
3) and j and sends the identifier idy of the selected half key
to i (Step 4). Then, they can compute the selected half keys
(Step 5-7), i.e., kx,ij and ky,ij , using Blom’s scheme: Initially
node i has Ac(i) and G(i), and node j has Ax(j) and Gx(j).
After exchanging the Gx(i) and Gx(j), then the shared half
key between nodes i and j, kx,ij = kx,ji, can be computed
in the following manner by these two node independently:
kx,ij = Ax(i) ·Gx(j) = Ax(j) ·Gx(i) = kx,ji.
Since both nodes share half-key space sx and sy and know
their identifiers, ni and nj could create a session key at
each side by having kx,ij and ky,ij as the prefix and postfix
of the session key, respectively. The session key would be
used for data encryption/decryption until a new session key
is generated based on the similar approach. Note that in
order to avoid cryptanalysis attacks, any two nodes involved
in data transmission should change their session keys for
every specified time interval. In the next section, we will
exploit some security-related properties of the proposed half-
key approach.
Algorithm 2: Session Key Establishment
1 ni randomly picks up one half-key space sx in the common
half-key space set of ni and nj ;
2 ni sends the identifier (seed) idx of the selected half-key
space to nj ;
3 After nj receives the identifier, nj randomly picks up one
half-key space sy in the common half-key space set of ni
and nj ;
4 nj sends the identifier idy of the selected half-key space to
ni;
5 ni and nj compute the prefix half key
kx,ij = Ax(i) ·Gx(j) = Ax(j) ·Gx(i) = kx,ji;
6 ni and nj compute the postfix half key
ky,ij = Ay(i) ·Gy(j) = Ay(j) ·Gy(i) = ky,ji;
7 ni and nj derive a session key: ks=kx,ij ||ky,ij ;
3. ANALYSIS STUDY
The purpose of this section is to propose an analytic model
to provide insights in the performance evaluation of the pro-
posed approach. We evaluate resilience against node cap-
turing. Resilience against node capturing is defined as the
percentage of the secure links that are compromised after
a certain number of nodes are captured by the adversaries.
Note that the analysis is complicated by the possibility for
nodes in the sharing of keys or half keys.
Lemma 1. [3] Let A(u, v) be the event that u and v are
neighbors; let B′(u, v) be the event that u and v share at least
one common key space. The local connectivity P 1local (i.e.,
the probability of two neighboring nodes being able to find a
common key space) is the following conditional probability:
P
1
local = Pr(B
′
(u, v)|A(u, v)) =
Pr(B(u, v)andA(u, v))
Pr(A(u, v))
(1)
=
∑
i∈Ψ
∑
j∈Ψ Pr(B(ni, nj)) · Pr(A(ni, nj))∑
i∈Ψ
∑
j∈Ψ Pr(A(ni, nj))
(2)
Let A(u, v) be the event that u and v are neighbors; let
Bq(u, v) be the event that u and v share at least q common
key space. The local connectivity P qlocal (i.e., the probability
of two neighboring nodes being able to find a common key
space) is the following conditional probability:
Plocal = Pr(B
q
(u, v)|A(u, v)) =
Pr(Bq(u, v)andA(u, v))
Pr(A(u, v))
(3)
=
∑
i∈Ψ
∑
j∈Ψ Pr(Bq(ni, nj)) · Pr(A(ni, nj))∑
i∈Ψ
∑
j∈Ψ Pr(A(ni, nj))
(4)
Lemma 2. [3] Let gi = g(zi|ni ∈ Gi) represent the prob-
ability that a sensor node ni from group Gi resides within
257
Pr(c is compromised|A(u, v) and B(u, v))
≤
1
XY
∫ Y
y=0
∫ X
x=0
( ∑
i∈Ψ
1
XY
 ∑
i∈Ψ
∑
j∈Ψ p(ξ(i, j)) · Pr(A(ni, nj))∑
i′∈Ψ
∑
j∈Ψ p(ξ(i′, j))Pr(A(ni′ , nj))
2 ·
∫ Y
y=0
∫ X
x=0
Xi(x,y,Rc)∑
a=λ+1
(Xi(x, y, Rc)
a
)
(
τ
|Sc|
)
a
(1 −
τ
|Sc|
)
Xi(x,y,Rc)−a

2
dxdy.
(17)
4. PERFORMANCE EVALUATION
The purpose of this section is to evaluate the performance
of the proposed scheme, referred to as the Half-Key Pre-
distribution Scheme (HKPS). A simulation model was con-
structed for performance evaluation, in which nodes and
their neighboring relationship were randomly generated. The
performance of HKPS was evaluated, compared to the q-
composite random key pre-distribution scheme (RKPS) [1].
Note that each node was assigned a subset of keys randomly
picked up from a key pool before the network deployment.
Under HKPS and RKPS, a communication link could be es-
tablished between two neighboring nodes if they shared at
least q keys, where q was a parameter in the experiments.
The performance metrics for experiments was the resilience
against node capturing.
Sensor nodes under experiments were assumed to have the
same memory space and the same number of session key can-
didates under both HKPS and RKPS, i.e., 1 or 9. The con-
nectivity was set as 0.5 and the storage size was set as 200.
Note that a larger key pool size, in general, provided bet-
ter security support. Such a implication could be revealed
by the following experiments on the resilience against node
capturing under HKPS and RKPS.
 0
 0.1
 0.2
 0.3
 0.4
 0.5
 0.6
 0.7
 0.8
 0.9
 1
 0  100  200  300  400  500  600  700  800  900  1000
F
ra
ct
io
n
 o
f 
co
m
m
u
n
ic
at
io
n
s 
co
m
p
ro
m
is
ed
Captured nodes
RPKS-D Worst Group
RPKS-D Worst 10 Groups
RPKS-D Network Average
HPKS-D Worst Group
HPKS-D Worst 10 Groups
HPKS-D Network Average
Figure 1: Resilience against node capturing under
HKPS-D and RKPS-D (m = 200, λ = 0, q = 1).
Figure 1 shows that the resilience against node capturing
under HKPS-D and RKPS-D when λ was set as 0 and q was
set as 1. The X-axis is the number of captured nodes, and
the Y-axis is the ratio of the compromised links against all
links, i.e., the resilience against node capture. It was shown
that our proposed scheme is outperform RKPS-D. Similarly,
Figure 2 shows that the resilience against node capturing
under HKPS-D and RKPS-D when λ was set as 19 and q
was set as 1. Figure 3 shows that the resilience against node
capturing under HKPS-D and RKPS-D when λ was set as
19 and q was set as 9. As shown in the experimental results,
our proposed HKPS-D scheme also significant outperform
RKPS-D scheme.
 0
 0.1
 0.2
 0.3
 0.4
 0.5
 0.6
 0.7
 0.8
 0.9
 1
 0  100  200  300  400  500  600  700  800  900  1000
F
ra
ct
io
n
 o
f 
co
m
m
u
n
ic
at
io
n
s 
co
m
p
ro
m
is
ed
Captured nodes
RPKS-D Worst Group
RPKS-D Worst 10 Groups
RPKS-D Network Average
HPKS-D Worst Group
HPKS-D Worst 10 Groups
HPKS-D Network Average
Figure 2: Resilience against node capturing under
HKPS-D and RKPS-D (m = 200, λ = 19, q = 1).
 0
 0.1
 0.2
 0.3
 0.4
 0.5
 0.6
 0.7
 0.8
 0.9
 1
 0  100  200  300  400  500  600  700  800  900  1000
F
ra
ct
io
n
 o
f 
co
m
m
u
n
ic
at
io
n
s 
co
m
p
ro
m
is
ed
Captured nodes
RPKS-D Worst Group
RPKS-D Worst 10 Groups
RPKS-D Network Average
HPKS-D Worst Group
HPKS-D Worst 10 Groups
HPKS-D Network Average
Figure 3: Resilience against node capturing under
HKPS-D and RKPS-D (m = 1200, λ = 19, q = 9).
5. CONCLUSION
This paper proposes a half-key approach based on the ran-
dom key pre-distribution scheme [1] and DDHV-D deploy-
ment knowledge [3] to provide resource-efficient key man-
agement in wireless sensor networks. Distinct from the past
work, this paper focuses its study on the reducing of the
memory space requirements of a sensor network on key pre-
distribution and the providing of better security enforcement
in sensor data delivery. We present an analytical model to
exploit the properties of the proposed approach on resilience
against node capturing. The capability of the proposed ap-
proach is evaluated by a series of experiments. The pro-
posed scheme also provides significant improvement on the
two properties in the experiments.
6. ACKNOWLEDGMENTS
259
Energy-Aware Scheduling for Embedded Real-Time Systems with
Rechargeable Batteries
Chi-Lin Chou and Chin-Fu Kuo
Department of Computer Science and Information Engineering
National University of Kaohsiung, Kaohsiung, Taiwan, R.O.C.
clchou1980@gmail.com, chinfukuo2006@nuk.edu.tw
Abstract
Due to the power limited nature of embedded systems, power
efficiency is one issue in the design of embedded systems.
We propose a design in which an embedded system is pow-
ered by dual rechargeable batteries and the batteries don’t
operate simultaneously. We propose a linear programming
based approach to extend the lifetime of batteries. With the
proposed approach, the lifetime of a battery will be extended
and the design complexity of the system will be reduced. A
simulation model is built to investigate the performance of
the proposed approach. The capability of the proposed ap-
proach is evaluated by a series of simulations, for which we
have encouraging results.
Keywords Real-Time Scheduling, Energy-Aware, Recharge-
able Batteries
1. Introduction
In the past decade, the requirements for embedded systems
have been increasing rapidly and most embedded systems
are battery-operated. Due to the power limited nature of em-
bedded systems, power efficiency is one issue in the design
of embedded systems. Dynamic Voltage/Frequency Scaling
(DVS) is one of the most effective technique to extend the
lifetime of battery or reduce power consumption in real-time
systems, due to that the energy consumption of CMOS cir-
cuits is quadratically proportional to the supply voltage [1].
Another effective technique is the Dynamic power manage-
ment (DPM) policy that control if the system various com-
ponents should to be shut down according some condition
[2].
The related work can be divided into two categories: One
assumes that the energy used by an embedded system is
unlimited and the systems operate without energy storage.
Many proposed algorithms are designed to extend the exe-
cuting time of each instances by stealing the slack time and
scaling the processor speed. The other assumes that the en-
ergy storage of a battery supplies the energy to an embedded
system [3, 4].
The secondary category can be divided into two subtypes:
The first subtype is that the battery is not recharged [5] and
the other one is that the battery is rechargeable [6]. For some
applications of the secondary subtype, the location of the em-
bedded devices, as well as the method of deployment, would
make it hard to replace power sources each time a device
loses power. Renewable sources are starting to gain popular-
ity with regards to the powering devices for various applica-
tions. Solar energy is a major source of energy especially for
outdoor applications.
Most of the embedded systems are powered by a battery
or batteries that can be recharged. The embedded systems
use such batteries are like sensor nodes which are deployed
outside. Only environmental energy source can be used to
supply the energy. To keep the system executing correctly,
the system can be equipped with more than one battery. To
avoid exhausting the energy of a battery is an important
issue. The system can lose the data in the memory if the
current used battery is exhausted.
Quan, et al. presented a technique to derive voltage set-
tings for a variable voltage processor that exploits a fixed
priority assignment to schedule jobs [7]. However the work
assumes the energy supply is unlimited and exist an issue
that the slack time should be estimated exactly. Much related
work focuses on the system where the processor discharges
the energy from the battery and the battery is recharged si-
multaneously. The energy amount of of the energy might be
increased or decreased. Lin, et al. proposed the scheduling
of frame-based real-time tasks in partitioning schemes for
multiprocessor systems powered by rechargeable batteries
[3]. Moser et, al. present a real-time scheduling in a sys-
tem whose energy reservoir is replenished by an environ-
mental power source [6]. Some DVS problem can be mod-
eled as a linear programming to solve. [5] targeted a syn-
thesis problem for heterogeneous multiprocessor systems to
schedule a set of periodic real-time tasks under a given en-
ergy consumption constraint and solves the problem by re-
ducing integer linear programming to linear programming. A
dynamic power management (DPM) policy specifically tai-
lored to dual-battery-powered systems is proposed in [8]. But
the batteries in the system are not rechargeable.
In some operation environment, it can be impracticable to
replace or recharge batteries manually. For example, when
an embedded device is deployed in radioactive or poison
gas surrounding, the energy constraint has become a main
trouble for maintaining the device operating. To replenish
the energy storage by an environmental power source has
1
pletely applicable to our considered task set. Some modifica-
tion is necessary, we present a modified schedulable analysis
shown in the following:
THEOREM 1. [13] A set of n (periodic and aperiodic) tasks
is schedulable by EDF scheduling if
∀k
k=1,...,n
(
k
∑
i=1
Ci
Pi
)+ BkPk ≤ 1
where Bk is denoted the maximum blocking time for task τk.
In our discussed task model, the switch task has the
longest period Pn. In other words, the period is the lifetime
of battery. In order to do analyze, we first assume that it is
constant. For each task τk except the switch task, block time
sw can considered as switch time and it’s also constat. We
will propose a schedulability test for our model.
LEMMA 1. A set of n (periodic and aperiodic) tasks and a
virtual switch task τsw is schedulable by EDF scheduling if
∀k
k=1,...,n
(
k
∑
i=1
Ci
Pi
)+ swPk ≤ 1.
where sw is the execution time of the switch task τsw and Pk
is the period of task τk.
Proof. In our model, only the switch task could cause
block for the other tasks. The proof can be done by replacing
the blocking time Bk in above equation with the executing
time sw of switch task τsw. 
In this section we investigate the sub-optimal solution to
the frequencies assigned problem. The goal is to minimize
the switching times during a finite interval, on the other hand,
maximizing the lifetime of the device battery is our aim. We
first formulate this problem as an integer linear programming
problem as follows: Let Y be a frequency assignment matrix
and Y is an n×m matrix of binary variables, where n is the
task number and m is the number of frequency levels. Each
element yi, j is set as 1 if the frequency Fj is selected for task
τi. Otherwise yi, j is set to 0. As a result, the cross product of
frequency assignment matrix Y and the vector of frequency
levels gives a frequency assignment and such the assignment
can maximum the lifetime of a battery. The targeted problem
is to derive a matrix Y satisfying the following equations to
maximum the lifetime L:
Maximum L (1)
sub ject to
∀k
k=1,...,n
(
m
∑
j=1
k
∑
i=1
Ci
PiFi
yi, j)+ swPk
≤1 (2)
m
∑
j=1
n
∑
i=1
d LPi
eP( fi)
Ci
Fi
yi, j+Pstatic·(L−
m
∑
j=1
n
∑
i=1
d LPi
e
Ci
Fi
yi, j) (3)
≤Ebudget−Pstatic·sw
L≥RD (4)
Fi∈F,∀i=1,..,n, (5)
m
∑
j=1
yi, j=1,∀i=1,..,n, (6)
and yi, j∈{0,1},∀i=1,..,n,and j=1,..,m (7)
where L is the duration of exhausting energy of battery, in
other words L is denoted the lifetime of the battery. Ebudget
is denoted the capacity of the battery and Pstatic · sw is the
energy consumption which supports the data maintenance
during the battery switching.
Equation 1 indicates our aim to maximize the lifetime of
battery over the system. The lifetime depends on the vari-
able frequency/voltage setting of each tasks and the fre-
quencies are discrete. The binary variable yi, j could deter-
mine a discrete frequency Fj assigned to a task τi. Equa-
tion 2 presents the EDF schedulability analysis, and guar-
antees that no deadlines can be missed. Equation 3 presents
the energy constraints where the total energy consumption
can not exceed the capacity of the battery, where d LPi e is de-
noted the number of invoked instances of τi during the life-
time. Pstatic · (L−
m
∑
j=1
n
∑
i=1
d LPi e
Ci
Fi
yi, j) is the total static energy
consumption when the processor does not execute any tasks.
Equation 4 represents that when the current used battery is
exhausted, the state of the other battery is on the fully state.
Equation 5 is the frequency constraint where tasks can only
be executed at a feasible frequency level. Equations 6 and
7 control each tasks could be assigned only one frequency
by the binary variable yi, j. Finally if there will exist a solu-
tion, we could find a frequency assignment to maximize the
lifetime of battery.
3.2 Translate ILP Model into LP model
In this section, we propose to use relax the integer constraints
and transfer the original ILP problem to a linear program-
ming (LP) problem. An LP problem can be solved by an
LP solver in a polynomial time. However, the derived solu-
tion can not be applied for the original frequency assignment
problem. We must translate the fractional solution to an inte-
gral solution by a rounding approach.
The original integer linear programming (ILP) formula
can be translated into a LP problem shown as follows:
Maximum L (8)
sub ject to
∀k
k=1,...,n
(
k
∑
i=1
Ci
Pi
)+ swPk
≤1 (9)
n
∑
i=1
d LPi
eP( fi)
Ci
fi
+Pstatic·(L−
n
∑
i=1
d LPi
e
Ci
fi
) (10)
≤Ebudget−Pstatic·sw
L≥RD (11)
and 0< fi≤1,∀i=1,..,n (12)
In this relaxation, the variable yi, j is removed. Equations 9
and 10 are the schedulability analysis test and the energy
constraint, respectively. Equation 12 relaxes the constraint
of discrete frequencies.
We can use an LP solver [11] to solve the LP prob-
lem. The derived frequency solutions can not be in the fre-
quency set F = {Fi|1 ≤ i ≤ m}, which are called as non-
feasible frequency level. We must round-up the derived non-
feasible frequency levels to a higher feasible frequency level
3
Algorithm 2: REF( j,k,op1,op2,Lrd ,{ f ∗i })
1: Let Lre f = max{L j,k}, and x and y represent the frequency index of tasks τ j and
τk , respectively.
2: if Fmin ≤ Fx+op1 ≤ Fmax then
3: f ∗j ← Fx+op1
4: end if
5: if Fmin ≤ Fy+op2 ≤ Fmax then
6: f ∗k ← Fy+op2
7: end if
8: if ∀k
k=1,...,n
(
k
∑
i=1
Ci
Pi
)+
Bk
Pk
> 1 then
9: return 0
10: else
11: return
BinarySearch(max{ LR ,RD},
Ebudget−Pstatic ·sw
n
∑
i=1
( 1Pi
Ci
f∗i
)(P( fi)−Pstatic)+Pstatic
,Ebudget ,{ f ∗i })
12: end if
Algorithm 3: BINARYSEARCH(Llow,Lup,Ebudget ,{ f ∗i })
1: while Llow ≤ Lup do
2: if Llow = Lup or
n
∑
i=1
Llow
Pi
P( f∗i)
Ci
f∗i
+Pstatic · (Llow−
n
∑
i=1
Llow
Pi
Ci
f∗i
) = Ebudget −Pstatic · sw then
3: return Llow
4: else if
n
∑
i=1
Llow
Pi
P( f∗i)
Ci
f∗i
+Pstatic · (Llow−
n
∑
i=1
Llow
Pi
Ci
f∗i
) < Ebudget −Pstatic · sw
then
5: Lup = b
Llow+Lup
2 c
6: else
7: Llow = b
Llow+Lup
2 c
8: end if
9: end while
els: {0.15,0.4,0.6,0.8,1}. The other processor with ten fre-
quencies also be considered. The power consumption model
is P( f ) = α + β f 3 and could be derived approximately as
P( f ) = 0.08 + 1.52 f 3 Watt[14]. The energy storage of two
batteries is 700mAh and RD is equal to 5000s. The switch
cost is 5ms.
The performance of our algorithm is inspected on a large
number of task sets by the lifetime. Each simulation result
is an average over 1000 independent simulation runs. The
number of tasks in a tested task set are 2, 4, 6, 8, and 10. The
deadline of each task is randomly selected from the range
[200,1000]ms. The worst-case execution time of each task in
a task set is generated by a random variable with the range
of 1 and the corresponding deadline. The total task utiliza-
tion of the system is randomly generated between 0 and 0.9.
Because the switch cost is more than 0, the task set with the
utilization equal to 1 is not schedulable. The performance
metric is the normalized lifetime of battery. The normalized
lifetime of battery is the absolute lifetime derived by a tech-
nique divided by the optimal absolute lifetime derived by an
exhaustive algorithm.
4.2 Experimental Results
Figure 2 shows our simulation results when the numbers of
task are equal to 6 and 10. The x-axis is the utilization from
0.1 to 0.9, and the y-axis is the lifetime of battery normal-
ized to the optimal solution which is derived by the exhaus-
tive method. The gray bar is denoted the normalized lifetime
derived by rounding technique, and the black bar is denoted
the normalized lifetime derived by the rounding and refine-
ment technique. With the rounding technique, the simulation
results in Figures 2(a) and 2(b) are almost the same as the op-
timal solution, while the task utilization are from 0.1 to 0.3.
This is due to the energy consumption characteristics of Intel
XScale. The energy consumption for a time unit is 85.13mJ
at the first frequency level 0.15 while the energy consump-
tion is 177.28mJ at the secondary frequency level 0.4. The
secondary frequency level is more than the double of the first
frequency level. However, the energy consumption at the first
frequency level is up to 1.28 times larger than that at the sec-
ondary frequency level. Therefore, the tasks executed at the
secondary frequency level consume less energy than that at
the first frequency level. The frequencies derived by the LP
solver [11] for tasks are close to the total task utilization.
Tasks executed at the secondary level frequency 0.4 can con-
sume less energy than task executed at the frequency which
is smaller than 0.4. Therefore under the rounding technique,
the derived frequencies derived by the solver are rounded 0.4
and the lifetime of battery is almost close to the optimal solu-
tion while the task utilization are from 0.1 to 0.3. Compared
with the optimal approach, the rounding technique, and the
rounding and refinement technique can have better perfor-
mance when the total task utilization is 0.5 than that when
the utilization is 0.4 or 0.6. This is because when a derived
frequency by the LP solver is close to 0.4(/0.6) and larger
than 0.4(/0.6) for the task set with 0.4(/0.6) utilization, the
energy consumption is increased 53%(/57%) if the frequency
is changed to 0.6(/0.8). This makes more energy is consumed
and worse solutions are derived.
Figure 3 shows the normalized lifetime and the de-
rived by the rounding and refinement technique for the
task number is 6 when the processor has 10 evenly discrete
frequencies {0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0}, re-
spectively. Compared with Figure 2(a), it shows that the
rounding technique, and the rounding and refinement tech-
nique derive better frequency assignments for tested task sets
when the total task utilization is equal to 0.4 and 0.6. This is
because when the number of discrete frequency level is 10,
the variation between two near frequencies is less. When a
derived frequency by the LP solver is close to 0.4 and larger
than 0.4 for the task set with 0.4 utilization, the energy con-
sumption is increased 21.8% if the frequency is changed to
0.5. However, when the processor only has five discrete fre-
quencies, the energy consumption is increased 53% if the
frequency is changed to 0.6.
Figure 4 shows the simulation results when the processor
has five and ten discrete frequencies with γ = 1,3,5, and 7,
respectively. In the figures, the trend of the performance are
similar. When the γ value is larger, the performance is bet-
ter. The reason is that the number of tested refinement per-
mutations are increasing and the probability of deriving the
better solution is also increasing. Therefore, the normalized
lifetime will be improved.
5
RACS 2011 notification for paper 38
Kuo Chin-Fu <chinfukuo@gmail.com>
RACS 2011 <racs2011@easychair.org> 2011年9月2日下午6:08
收件者: Chin-Fu Kuo <chinfukuo2006@nuk.edu.tw>
Dear Chin-Fu Kuo
We are pleased to inform you that your paper (A Half-Key Key Management Scheme for Wireless
Sensor Networks) has been accepted as a full paper for RACS 2011.
Please, prepare the camera ready version of your paper and copyright transfer form. You should send
them to racs.papers@gmail.com until 30 Sept.
You can find the camera ready format on the submission page of RACS 2011 Homepage
(http://oslab.ssu.ac.kr/CFP/RACS2011/index.jsp?menu=paper_submission)
Final camera ready papers will not exceed 6 pages; 2 extra pages will be allowed at additional cost
($100 per page).
Copyright form will be notified before 9 Sept.
Every author must register RACS 2011 conference until 30 Sept.
Registration page will be opened soon.
Best regards,
RACS 2011 Program Chairs
Minyi Guo,
Saeed Ghassemzadeh,
Jiman Hong
----------------------- REVIEW 1 ---------------------
PAPER: 38
TITLE: A Half-Key Key Management Scheme for Wireless Sensor Networks
AUTHORS: Yung-Feng Lu, Chin-Fu Kuo and Ai-Chun Pang
The authors propose a half-key scheme based on the well-known random key pre-distribution
scheme
and DDHV-D deployment knowledge to
provide resource-efficient key management in wireless sensor
networks with reduced memory space requirements and
better security enforcement. The capability of the proposed
approach is evaluated by an analytical model and a series of
experiments.
Despite not been an expert on security, but more a MAC and networking researcher, it seem to me
that the approach has been correctly presented but only evaluated analytically. So the reader got
loss in a nightmare of equations (i know that they are needed from a security point of view),
however from the point of view of the conference a more detailed performance simulation section is
required. So I recommend the authors to implement the approach using a network simulation and
then
compare their approach with other approaches in the literature. Only at that time the benefits of
the new proposed approach will be revealed or not.
Last sentence before section 3: add "with" in "communicate each other".
to derived should be to derive
Page 3: remove "in" in "scheme in follow"
Page 5: in theorem 2, "at lest" should be "at least"
----------------------- REVIEW 4 ---------------------
PAPER: 38
TITLE: A Half-Key Key Management Scheme for Wireless Sensor Networks
AUTHORS: Yung-Feng Lu, Chin-Fu Kuo and Ai-Chun Pang
This paper paper proposes a key management scheme for WSNs that aims to reduce the memory
footprint. I have several concerns about this paper. First, the authors state their contribution is based
on DDHV-D. It is very difficult to grasp the difference between the proposed approach and DDHV-D,
with particular reference to memory usage. A more detailed analytical (supported by experimental
results) description will help.
6Ogihara 教授演講，以下就他的演講做一些大概的描述：
Data mining is an area that studies methods for computationally understanding large data sets. Data
mining in its infancy meant for busicess data analysis, but as more disciplines began producing and/or
collecting large volumes of data, the concept of data mining changed to mean analysis of large data sets
for new, often for discovery for new patterns. In the talk he presents some of his work in applications of
data mining in biology. He discussed the problem of estimating abundance of RNA where each RNA is
sensed by multiple sensors and each sensor senses a variety of RNA and how such problem can be
formulated as an optimization problem and solved. He also discussed the problem of predicting
interactions between proteins by integrating their sequence data and their attributes.
之後就開始論文報告，我們的論文於下午的第一場開始，報告之後和聆聽的學者做了一些交流。
晚上是歡迎晚會，由於歡迎晚會的地點在離學校較遠的地方，所以搭乘了台大教授所租借的車到
達餐廳，和與會的他國與本國學者做了一次學術交流。
第三天:
有二個session同時進行，我參加了其中的session “System Software”。以下為我較注意的論文摘
要：
論文一：多核心在嵌入式系統上越來約普遍，但是不同廠商的核心間的傳送機制會影響多核心應
用程式的移植性並減低軟體的發展。一般而言，平行程式是由 message-passing 機制來撰寫，MPI 架構
下的程式可以跨不同種系統，從 PC 到 Cluster 一直到超級電腦。MPI 對於嵌入式系統而言過大，因此
該群學者設計了一組新的函式庫，來加強多核心嵌入式系統的移植性與效能。也提出一些相對應的數
學模式與實驗結果來驗證函式庫的效能。
論文二：這篇論文探討多核心硬即時系統的temporal robustness，robustness 的是一種可以容錯的
能力，以至於不會有deadline被miss。作者們探討的是sporadic且dependent的工作，並提出一個
partitioning algorithm來將工作分配到處理器，以至於能夠最大化系統的robustness。
晚上是歡迎晚會，由於晚會是在邁阿密市區，所以搭乘薛春教授的車過去，由於他之前在學時曾
在邁阿密打工，因此帶我們到邁阿密的著名景點參觀。再晚會上，我再度與和與會的他國學者做了一
次學術交流。
二、與會心得
由於過去參加過許多國際研討會，此次研討會令人感到不同的是雖然它的規模不大，但是會
議論文的水準不錯。這樣的研討會可促進學者彼此間更進一步的交流。另外，會議所在的邁阿密
是美國南部的重要城市，主要的經濟命脈是觀光。此外，由於第一天只需報到，報到完後有空可
以抽空去參觀了一間位於邁阿密南邊的沼澤地公園，並搭乘著名的氣墊船，導遊詳細解說該地之
生態環境，對於美國政府維護生態的作法相當佩服，這些值得我們台灣借鏡的地方。且在美國遇
到很多國外學者，彼此交換名片，藉此可以提高學校的知名度。
8國科會補助專題研究計畫項下出席國際學術會議心得報告
日期： 年 月 日
參加會議經過
本人於新加坡當地時間 10 月 31 日到達新加坡樟宜機場，本人於會議當日（11 月 1 日）抵達
會議地點辦理報到手續，始獲知參加國家及人數眾多，不少是來自印度的學者，會場各國人士熱
絡之場景令人印象深刻。本次會議室和另一個國際會議 Annual International Conference on Advances
in Distributed and Parallel Computing (ADPC 2010) 一起舉辦。會議第一天安排了 keynote，我仔細
聽了整個過程。當天下午有個旅遊新加坡當地的行程。一連兩天之論文發表，論文發表之方式採
用上台報告。大致上，同時會有二個 session 一起進行，所以我選擇我有興趣的 session 參與。
第一天:
由於本次是結合和兩個會議一起舉辦，所以有的Keynote是屬於嵌入式領域的。我聽了一場
Keynote，由University of Surrey的Paul Krause教授演講。此外，也陸穿插聽了兩個會議的論文報告。
下午4點之後是當地旅遊，和與會的他國學者做了一次非學術性交流。
第二天:
上午由我報告我們的論文，報告之後和聆聽的學者做了一些交流。由於會議開始就到達會場，所
以聽了當天上午的所有論文報告， Behavioural Presentations and an Automata Theory of
Components，Sign Language， Improved Hybrid RMGT Distributed Scheduling Algorithm，和
Guaranteed Bounds for the Control Performance Evaluation in Distributed System Architectures。但是由
計畫編號 NSC 99-2221-E-390-017
計畫名稱
具輸出入裝置之(m,k)即時系統上的省電排程
出國人員
姓名
郭錦福
服務機構
及職稱
國立高雄大學 助理教授
會議時間
99 年 10 月 31日至 99年
11 月 3 日 會議地點 新加坡
會議名稱
(中文)即時系統與嵌入式系統國際研討會
(英文) Annual International Conference on Real-Time and Embedded Systems (RTES
2010)
發表論文
題目
(中文)具可充電電池之嵌入式系統上的即時排程
(英文) Real-Time Task Scheduling for Embedded Systems with Rechargeable Batteries
附件四
國科會補助計畫衍生研發成果推廣資料表
日期:2012/02/03
國科會補助計畫
計畫名稱: 具輸出入裝置之(m,k)即時系統上的省電排程
計畫主持人: 郭錦福
計畫編號: 99-2221-E-390-017- 學門領域: 計算機結構與計算機系統
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
