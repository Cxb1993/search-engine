A Study	on	Power	Domination	in	Honeycomb	Meshes
蜂巢格狀網路上的電力支配問題研究
國科會計劃編號	: NSC 100–2221–E–141–002.
張肇明
國立台北商業技術學院資訊與決策科學研究所
Email: spade@mail.ntcb.edu.tw
摘要
所謂「電力支配問題」，乃是在一電力系統中利用安置狀態測量單元	(簡稱	PMU) 以達到
整個電力系統的監測，同時要求	PMU 的個數為最少。這個問題和圖形理論的支配問題
的關連性十分密切。給定一圖 G = (V,E) 以模擬一電力系統，在 G 之點集合 V 中，找
出一個最小的子集合 S，使得 S 中的點可以完全監測到 V 中所有的點，則稱 S 為此一
PMU之集合，且稱集合 S 之大小為 G 之「電力支配數」。在一圖形 G 中之某節點若被
放置	PMU，則此節點可監測自己與其鄰點；若某一已監測點其分支數 > 1，且其未被監
測的鄰點只有一個，則此未被監測之鄰點的狀態即可改變為已被監測狀態。在過去的研究
中已經得知，即使將圖形限制為某些特殊的圖形，電力支配問題仍為一	NP-完備問題。在
[Discrete	Applied	Math., 154	(2006)	1023–1027]	一文中，Dorfling	和	Henning	二位學者已經
證明若圖形為一 n ×m 的格子圖，則很容易即可求出其電力支配數，此文並設計一演算
法使得	PMU 安置的個數為最少。在本計劃中，我們針對蜂巢格狀網路的電力支配問題進
行研究。對於一個 t 維度的蜂巢格狀網路 HMt，我們提出一個電力支配數的理論下界，
同時設計一配置方案以證明此一理論下界即為確切的電力支配數。
Abstract
The	power	domination	problem	is	to	find	a	minimum	placement	of	phase	measurement
units	(PMUs)	for	observing	the	whole	electric	power	system	represented	by	a	graph G. The
number	of	such	a	minimum	placement	of	PMUs	is	called	the	power	domination	number	of G
and	is	denoted	by γp(G). Finding γp(G) of	an	arbitrary	graph	is	known	to	be	NP-complete.
In	this	paper, we	deal	with	the	power	domination	problem	on	honeycomb	meshes. For	a
t-dimensional	honeycomb	mesh HMt, we	show	that γp(HMt) = ⌈2t3 ⌉. In	particular, we
present	an O(t)-time	algorithm	as	the	placement	scheme.
Keywords: Algorithms; Power	domination	problem; Power	domination	number; Phase	mea-
surement	units; Honeycomb	meshes;
1
the	power	domination	problem	on	honeycomb	meshes	and	provide	an	algorithm	to	obtain	a	minimum	PDS,
where	the	time	complexity	of	our	algorithm	is	proportional	to	the	size	of	such	a	PDS.
Honeycomb	meshes	are	defined	as	follows: One	hexagon	is	a	honeycomb	mesh	of	size	one, denoted
HM1. The	honeycomb	mesh HM2 of	size	two	is	obtained	by	adding	six	hexagons	to	the	boundary
edges	of HM1. Inductively, a	honeycomb	mesh HMt of	size t is	obtained	from HMt−1 by	adding	a
layer	of	hexagons	around	the	boundary	of HMt−1. Here	we	use	the	coordinate	system	introduced	by
Stojmenovic [20]. Let x-, y-	and z-axes	start	at	the	center	of	a	honeycomb	mesh	and	be	parallel	to	the
three	edge	directions, respectively	(see	Figure 1). A honeycomb	mesh	is	a	bipartite	graph	and	its	vertices
can	be	labeled	by	using	integer	triples (x, y, z) such	that 1 − t ⩽ x, y, z ⩽ t and 1 ⩽ x + y + z ⩽ 2.
Two	vertices (x, y, z) and (x′, y′, z′) are	adjacent	if	and	only	if |x − x′| + |y − y′| + |z − z′| = 1. For
HMt = (V1 ∪ V2, E), let Vi = {(x, y, z) |x + y + z = i}, i = 1, 2 (i.e., V1 and V2 denote	the	sets
of	white	vertices	and	black	vertices	in	honeycomb	mesh, respectively). Thus, if (x, y, z) ∈ V1, then	its
adjacent	neighbors	are (x+ 1, y, z), (x, y + 1, z), and (x, y, z + 1). On	the	other	hand, if (x, y, z) ∈ V2,
then	its	adjacent	neighbors	are (x− 1, y, k), (x, y − 1, z), and (x, y, z − 1).
x = 1z = 1
y
(0,1,0)
(1,1,0)
(1,0,0)
(1,0,1)
(0,0,1)
(0,1,1)
(-1,1,1)
(-1,1,2)
(-2,1,2)
(-2,1,3)
(-3,1,3)
(-3,1,4)
y = 1
xz
Figure 1: A honeycomb	mesh HM4.
3
is	a	fit	set	and	there	is	no	other	proper	fit	set S′′ ⊂ S such	that S′ ⊂ S′′. For	a	set S ⊆ V1, we	say
that S covers k x-values if |{a ∈ {1 − t, 2 − t, . . . , t}|(a, b, c) ∈ S}| = k. By	a	similar	way, we	can
define	the	terms	that S covers k y-values and S covers k z-values, respectively. For	example, consider
S = {(2,−1, 0), (3,−1,−1), (4, 0,−3)} ∈ V1 in HM4 (see	Figure 2(a)), where	each	vertex	of S is
marked	by	a	circle	and	each	vertex	of R(S) \ S is	marked	by	a	shape	of	drip. If	we	partition S into	two
sets S1 = {(2,−1, 0), (3,−1,−1)} and S2 = {(4, 0,−3)}, an	easy	observation	shows	that d(u, v) > 2
for	any	pair	of	vertices u ∈ R(S1) and v ∈ R(S2). Thus, S1 and S2 are	not	extendable. Note	that
R(S1) covers	2 x-values	and R(S2) covers	5 x-values	in	this	case. On	the	other	hand, if	we	partition
S into	two	sets S1 = {(2,−1, 0)} and S2 = {(3,−1,−1), (4, 0,−3)} and	consider u = (2,−1, 0) and
v = (3,−1,−1), then d(u, v) = 2 and R({u, v}) = {(2,−1, 0), (3,−1,−1), (3,−2, 0)} ̸= {u, v}.
Thus, S1 and S2 are	extendable	in	this	case. As	a	result, S is	not	a	fit	set. Figures 2(b)	and	2(c)	show
that S = {(2, 0,−1), (3,−1,−1), (4,−2,−1)} and S′ = {(1, 1,−1), (2, 0,−1), (2,−1, 0)} are	fit	sets,
respectively. In	particular, {(2, 0,−1), (3,−1,−1)} and {(3,−1,−1), (4,−2,−1)} are	maximal	fit	sets
within S, but {(2, 0,−1), (4,−2,−1)} is	not.
x = 1
y = 1
z = 1
x
y
z
x = 1
y = 1
z = 1 x = 1
y = 1
z = 1 y
xz
y
xz
(a)
(b) (c)
Figure 2: Examples	of	fit	sets	and	unfit	sets: (a)	an	unfit	set; (b)	and	(c)	two	fit	sets.
5
Proof. Suppose	to	the	contrary	that S \U is	not	a	fit	set. Then, S \U can	be	partitioned	into	two	nonempty
subsets U1 and U2 that	are	not	extendable. Since S is	a	fit	set, U and S \U are	extendable. By	Lemma 4,
U and U1 are	extendable	or U and U2 are	extendable. Without	loss	of	generality, suppose U and U1 are
extendable. If U1 is	fit, then	so	is U ∪U1 by	Lemma 5. This	contradicts	that U is	a	maximal	fit	set	within
S. Thus, U1 is	not	a	fit	set	and	there	exists	a	partition	of U1 containing	two	nonempty	sets U
′
1 and U
′
2 that
are	not	extendable. Again, by	Lemma 4, U and U ′1 or U and U ′2 are	extendable. Without	loss	of	generality,
suppose U and U ′1 are	extendable. By	the	same	argument, if	we	proceed	the	partition	of U ′1 repeatedly,
there	must	exist	a	fit	set	containing	at	least	one	vertex	that	is	extendable	with U . Thus, this	contradicts	that
U is	a	maximal	fit	set	within S. □
Let ℓ1, ℓ2, ℓ3 ∈ {1 − t, 2 − t, . . . , t} be	three	integers. In	the	coordinate	system	suggested	by
Stojmenovic [20], a positive	triangle with	white	vertices	(i.e., V1)	in HMt is	described	by
△(ℓ1,ℓ2,ℓ3) = {(x, y, z) ∈ V1 |x ⩽ ℓ1, y ⩽ ℓ2, z ⩽ ℓ3 and t ⩾ max{ℓ1 + ℓ2, ℓ2 + ℓ3, ℓ1 + ℓ3}}.
Note	that	the	condition ℓi + ℓj ⩽ t for	each	pair i, j ∈ {1, 2, 3} with i ̸= j guarantees	that	the	shape
of △(ℓ1,ℓ2,ℓ3) forms	a	triangle	in HMt. For	instance, the	set	of	observed	vertices	in	Figure 2(c)	forms	a
positive	triangle △(2,1,0) in HM4.
By	contrast, a negative	triangle with	white	vertices	in HMt is	described	by
▽(ℓ1,ℓ2,ℓ3) = {(x, y, z) ∈ V1 |x ⩾ ℓ1, y ⩾ ℓ2, z ⩾ ℓ3 and 1− t ⩽ min{ℓ1 + ℓ2, ℓ2 + ℓ3, ℓ1 + ℓ3}}.
In	particular, if ℓ1 + ℓ2 + ℓ3 = 1, we	let △(ℓ1,ℓ2,ℓ3) = {(ℓ1, ℓ2, ℓ3)} and ▽(ℓ1,ℓ2,ℓ3) undefined.
Similarly, a positive x-trapezoid with	white	vertices	in HMt is	described	by
Tx⩽ℓ1 = {(x, y, z) ∈ V1 |x ⩽ ℓ1 ⩽ 0, y ⩽ ℓ2 = t and z ⩽ ℓ3 = t}.
By	contrast, a negative x-trapezoid with	white	vertices	in HMt is	described	by
Tx⩾ℓ1 = {(x, y, z) ∈ V1 |x ⩾ ℓ1 ⩾ 1, y ⩾ ℓ2 = 1− t and z ⩾ ℓ3 = 1− t}.
We	can	define	positive	(respectively, negative) y-trapezoid	and z-trapezoid	in	a	similar	way. For	instance,
the	set	of	observed	vertices	in	Figure 2(b)	forms	a	positive z-trapezoid Tz⩽−1 in HM4.
From	the	above	definitions, it	is	easy	to	check	the	following	propositions.
Proposition 7 Let (x, y, z) ∈ V1 be	a	vertex	in HMt. Then,
R({(x, y, z)}) =

Tx⩽1−t if x = 1− t;
Ty⩽1−t if y = 1− t;
Tz⩽1−t if z = 1− t.
7
triangle, at	most	one	of ℓ1, ℓ2 and ℓ3 is	equal	to 1−t. Without	loss	of	generality, we	assume	that ℓ1 ̸= 1−t
and ℓ2 ̸= 1− t. Clearly, (ℓ1, ℓ2, 1− (ℓ1+ ℓ2)), (ℓ1, ℓ2+1,−(ℓ1+ ℓ2)) ∈ ▽(ℓ1,ℓ2,ℓ3) (see	Figure 3). Since
(ℓ1−1, ℓ2+1, 1−(ℓ1+ℓ2)) is	the	only	unobserved	neighbor	of	the	vertex (ℓ1, ℓ2+1, 1−(ℓ1+ℓ2)) ∈ V2,
it	becomes	observed. Thus, (ℓ1 − 1, ℓ2 + 1, 1− (ℓ1 + ℓ2)) ∈ R(S). This	contradicts	that	every	vertex	in
▽(ℓ1,ℓ2,ℓ3) has	an x-coordinate	at	least ℓ1.
For	statement	(2), without	loss	of	generality, we	suppose	to	the	contrary	that R(S) = △(ℓ1,ℓ2,ℓ3) for
some ℓ1, ℓ2, ℓ3 ∈ {1 − t, 2 − t, . . . , t} with max{ℓ1 + ℓ2, ℓ2 + ℓ3, ℓ1 + ℓ3} ⩽ t and	there	is	a	vertex
(x = 1 − t, y, z) ∈ R(S). By	Proposition 7, R(S) contains	all	vertices (x, y, z) with x = 1 − t (i.e.,
Tx⩽1−t ⊆ R(S)). This	contradicts	that R(S) is	a	positive	triangle. □
(ℓ1, ℓ2, 1− (ℓ1 + ℓ2))
(ℓ1 − 1, ℓ2 + 1, 1− (ℓ1 + ℓ2))
(ℓ1, ℓ2 + 1,−(ℓ1 + ℓ2))
x = ℓ1
y = ℓ2
z = ℓ3
(ℓ1, ℓ2 + 1, 1− (ℓ1 + ℓ2))
Figure 3: Illustration	of	Lemma 10.
The	following	proposition	follows	directly	from	the	definitions	of	positive	triangle	and	trapezoid.
Proposition 11 The	following	statements	are	true:
(1)	Let ℓ ⩽ 0 be	an	integer. The	positive x-trapezoid Tx⩽ℓ (respectively, y-trapezoid Ty⩽ℓ and z-trapezoid
Tz⩽ℓ)	in HMt covers t+ ℓ x-values	(respectively, y-values	and z-values).
(2)	Let ℓ1, ℓ2, ℓ3 ∈ {1− t, 2− t, . . . , t} be	three	integers	with max{ℓ1 + ℓ2, ℓ2 + ℓ3, ℓ1 + ℓ3} ⩽ t. The
positive	triangle △(ℓ1,ℓ2,ℓ3) in HMt covers ℓ1 + ℓ2 + ℓ3 x-, y-	and z-values.
Lemma 12 Let S ⊂ V1 be	a	fit	set	in HMt with |S| < t. Then, R(S) ̸= V1.
Proof. If t = 1, the	lemma	is	clearly	true. Let t ⩾ 2 be	an	integer. By	Lemmas 9 and	10, we	will	show	a
stronger	result	that R(S) is	formed	by	either	a	positive x-trapezoid	(respectively, y-trapezoid	or z-trapezoid)
9
t1
t2
R(U)
R(U)
R(S \ U)
x
y
z
y = t2 − t
w = (t, t2 − t, 1− t2)
v = (t, 1− t1, t1 − t)
z = t1 − t
R(S \ U)
x
y
z
y = ℓ
′
2
k1
k2
k2
k1
t1
R(U)
R(S \ U)
t2
y = ℓ2
y = t1 + t2 − t
x
y
z
(a) (b)
(c)
Figure 4: Illustrations	of	Lemma 12: (a)	two	positive	trapezoids; (b)	a	positive	trapezoid	and	a	positive
triangle; (c)	two	positive	triangles.
Lemma 13 Let S be	a	bias-SDS in HMt that	contains V2 for t ⩾ 2. Then, S ∩ V1 is	a	fit	set.
Proof. Let U = S ∩ V1. Since S is	a	bias-SDS in HMt, R(U) = V1. Suppose	to	the	contrary	that U is
not	a	fit	set. Then, U can	be	partitioned	into	two	nonempty	subsets U1 and U2 that	are	not	extendable. By
Lemma 3, we	have R(U1)∪R(U2) = R(U) = V1. We	first	claim	that	if u ∈ V2 is	a	vertex	of	degree	three,
then	either N(u) ⊆ R(U1) or N(u) ⊆ R(U2). The	assertion	is	clearly	true	since	if N(u) ∩ R(U1) ̸= ∅
and N(u)∩R(U2) ̸= ∅, then U1 and U2 are	extendable. Let u = (0, 2−t, t) and	without	loss	of	generality
we	suppose N(u) ⊆ R(U1) (see	Figure 5 for HM4). Since (0, 2− t, t− 1) ∈ R(U1), this	implies	that	all
neighbors	of (1, 2−t, t−1) are	contained	in R(U1) (i.e., {(0, 2−t, t−1), (1, 1−t, t−1), (1, 2−t, t−2)} ⊂
R(U1)). Furthermore, since (1, 2− t, t − 2) ∈ R(U1), this	implies	that	all	neighbors	of (2, 2− t, t − 2)
are	contained	in R(U1). By	the	same	argument, we	obtain Y1−t ⊂ R(U1) and Y2−t ⊂ R(U1). Since
every	vertex (x, y, z) with y = 3 − t and x + y + z = 2 has	a	neighbor	in Y2−t and	two	neighbors	in
Y3−t, we	have Y3−t ⊆ R(U1). Consequently, R(U1) = V1 by	induction. Note	that	every	vertex v ∈ V1
11
Algorithm	PDS-on-HM
Input: A honeycomb	mesh HMt.
Output: A PDS set P .
1: P ← ∅; k ← t− 1 mod	3;
2: if k = 0 then (x, y, z)← (0, 1, 0);
3: if k = 1 then (x, y, z)← (1, 1, 0);
4: if k = 2 then (x, y, z)← (0, 1, 1);
5: P ← P ∪ {(x, y, z)};
6: for i = 1 to ⌈2t3 ⌉ − 1
7: if x+ y + z = 1 then
8: x← x− 1; z ← z + 2;
9: else	if x+ y + z = 2 then
10: x← x− 2; z ← z + 1;
11: P ← P ∪ {(x, y, z)};
12: endfor
Figure 6: An	algorithm	for	constructing	a	PDS in HMt.
For	example, Figure 7 shows	the	power	dominating	sets	generated	by	the	algorithm	PDS-on-HM on
HMt for t = 1, 2, 3, where	each	vertex	of P is	marked	by	a	square	(i.e., a	PMU) and	each	vertex	of
N(P ) is	marked	by	a	circle. To	show	the	correctness	of	the	algorithm, we	need	the	following	terms. For
HMt = (V,E), we	redefine Xk = {(x, y, z) ∈ V |x = k and 1− k ⩽ y+ z ⩽ 2− k}. Also, define Yk
and Zk by	a	similar	way. In	addition, let V
+
x =
⋃t
k=1Xk and V
−
x =
⋃0
k=1−tXk. Again, by	a	similar
way, we	can	define V +y , V
−
y , V
+
z and V
−
z , respectively. Let Π
+
xy = V
+
x ∩ V +y and Π−xy = V −x ∩ V −y .
Also, define Π+xz , Π
−
xz , Π
+
yz and Π
+
yz similarly.
Lemma 15 For HMt with t ⩾ 1, if	every	vertex	of V +x (respectively, V −x , V +y , V −y , V +z or V −z )	is
observed, then	every	vertex	of V is	observed.
Proof. Suppose	that	all	vertices	of V +x are	observed. Since	every	vertex (x, y, z) ∈ X1 with y + z = 1
has	exactly	one	unobserved	neighbor, this	implies	that	every	vertex (x′, y′, z′) ∈ X0 with y′ + z′ = 1 is
observed. In	particular, (0, 1− t, t) is	observed	and	it	has	only	one	unobserved	neighbor (0, 2− t, t). Thus,
(0, 2− t, t) becomes	observed. It	follows	immediately	that	every	vertex (x′, y′, z′) ∈ X0 with y′+ z′ = 2
is	observed. Therefore, we	can	show	that	all	vertices	of X0, X−1, . . . , X1−t are	observed	by	induction. □
Lemma 16 For HMt with t ⩾ 1, Algorithm	PDS-on-HM correctly	produces	a	PDS of	size ⌈2t3 ⌉.
Proof. Let k ≡ (t − 1) mod 3 and	let P be	the	set	produced	by	PDS-on-HM.	Clearly, |P | = ⌈2t3 ⌉. In
the	following, we	will	show	that V −x ⊆ R2(N [P ]) if k = 2, and V +y ⊆ R2(N [P ]) otherwise. Thus, the
correctness	directly	follows	from	Lemma 15.
13
Π
+
yz
Π
+
xy
Π
−
xz
Π
+
yz
Π
−
xz
Π
−
xy
(a) (b)
(0, 0, 1)
(0, 1, 0)
(1, 1, 0)
(0, 1, 0)
Y1
Y0
Figure 8: Illustrations	of	Lemma 16: (a)	an	example	for k = 2 in HM3; (b)	an	example	for k = 1 in
HM5.
From	Lemmas 14 and	16, we	conclude	the	following.
Theorem 1 γp(HMt) = ⌈2t3 ⌉ for t ⩾ 1.
References
[1] A.	Aazami	and	M.D.	Stilp, “Approximation	algorithms	and	hardness	for	domination	with	propaga-
tion,”	SIAM J.	Discrete	Mathematics, Vol.	23, 2009, pp.	1382–1399.
[2] D.	Atkins, T.W.	Haynes, and	M.A.	Henning, “Placing	monitoring	devices	in	electric	power	networks
modelled	by	block	graphs,”	Ars	Combinatoria, Vol.	79, 2006, pp.	129–143.
[3] T.L.	Baldwin, L.	Mili, M.B.	Boisen, Jr., and	R.	Adapa, “Power	system	observability	with	minimal
phasor	measurement	placement,”	IEEE Trans.	Power	Systems, Vol.	8, 1993, pp.	707–715.
[4] D.J.	Brueni, “Minimal	PMU Placement	for	Graph	Observability: A Decomposition	Approach,”	M.S.
thesis, Virginia	Polytechnic	Institute	and	State	University, Blacksburg, VA,	1993.
[5] D.J.	Brueni	and	L.S.	Heath, “The	PMU placement	problem,”	SIAM J.	Discrete	Mathematics, Vol.
19, 2005, pp.	744–761.
[6] P.	Dorbec, M.	Mollard, S.	Klav￿ar, and	S.	￿pacapan, “Power	domination	in	product	graphs,”
SIAM J.	Discrete	Mathematics, Vol.	22, 2008, pp.	554–567.
[7] M.	Dorfling	and	M.A.	Henning, “A note	on	power	domination	in	grid	graphs,”	Discrete	Applied
Mathematics, Vol.	154, 2006, pp.	1023–1027.
[8] J.	Guo, R.	Niedermeier, and	D.	Raible, “Improved	algorithms	and	complexity	results	for	power
domination	in	graphs,”	Algorithmica, Vol.	52, 2008, pp.	177–202.
15
 1 
 
國科會補助專題研究計畫項下出席國際學術會議心得報告 
                                    日期「100年09月15日 
                                 
一︾參加會議經過 
The seminar “The 15th International Computer Science and Engineering Conference 2011” 
(ICSEC2011) takes place on September 7-9 in Bangkok, Thailand. We take airplane to Bangkok, 
and go to Rama Garden Hotel by taxi. ICSEC2011 is being held this year by Kasetsart University. 
During the past 10 years, ICSEC, which is evolved from NCSEC conference, is one of the best 
academics gathering from researchers and practitioners in computer engineering, computer science 
and IT community in Thailand. I am very pleased that I was invited to serve as a member of the 
technical program committees. This year, Nearly 100 papers were submitted from authors in 7 
countries around the world. These papers have gone through a thorough reviewing and selection 
process by experts in various fields. Among them, 39 high-quality papers have been selected for 
oral presentation, and additional 6 papers were considered qualified work-in-progress which have 
been accepted for poster presentation. ICSEC aims to bring together researchers, scientists, 
engineers, and scholar students to exchange and share their experiences, new ideas, and research 
results about all aspects of computer science, engineering and technology, and discuss the practical 
challenges encountered and the solutions adopted. 
計畫編號 100-2221-E-141-002- 
計畫名稱 蜂巢格狀網路上的電力支配問題研究 
出國人員
姓名 
張肇明 
服務機構
及職稱 
國立台北商業技術學院 教授 
會議時間 
100年9月7日 至 
100年9月9日 
會議地點 泰國 曼谷 
會議名稱 The 15th International Computer Science and Engineering Conference 2011 
發表論文
題目 
An improved loopless algorithm for generating binary tree sequences 
 3 
 
 
三︾ 發表論文全文或摘要 (詳如後文)〈 
四︾建議 : 無〈 
五︾攜回資料名稱及內容 
1. 議程表一份 「研討會三天的會議議程〈 
2. 論文集一本 「截錄研討會部分的投稿論文〈 
六︾其他: 無〈 
 
Keynote Speakers 
Ewing Lusk, Argone National Laboratory, USA 
Kenichi Matsumoto, Nara Institute of Science and technology, USA 
Simon  See, Nanyang Technological University of Singapore, Singapore  
Yuen  Poovarawan, Kasetsart University, Thailand 
Technical Program Committee: 
Benchaphon Limthanmaphon, KMITNB, Thailand 
Chanjira Sinthanayothin, National Electronics and Computer Technology Center, Thailand 
Chavalit Srisathapornphat, Kasetsart University, Thailand 
Darko Kirovski, Microsoft Research, USA 
Dusit Niyato, Nanyang Technological University, Singapore 
Jakkarin Suksawatchon, Burapha University, Thailand 
Jitimon Angskun, Suranaree University of Technology, Thailand 
Jou-Ming Chang, National Taipei College of Business, Taiwan 
Juggapong Natwichai, Chiang Mai University, Thailand 
Kanda Runapongsa Saikaew, Khon Kaen University, Thailand 
Karthik Pattabiraman, University of British Columbia, Canada 
Krisana Chinnasarn, Burapha University, Thailand 
Mario Mendez-Lojo, University of Texas at Austin, USA 
Martin Burtscher, Texas State University, USA 
Meyram Kirman, Intel Research, Spain 
Natasha Dejdumrong, KMUTT, Thailand 
Nevin Kirman, Intel Research, Spain 
Nutthanon Leelathakul, Burapha University, Thailand 
Paruj Ratanaworabhan, Kasetsart University, Thailand 
Pavadee Sompagdee, Thammasart University, Thailand 
Philippe Lenca, Telecom Bretagne, France 
Pizzanu Kanongchaiyos, Chulalongkorn University, Thailand 
Prachaya Chalermwat, Chulachomklao Royal Military Academy, Thailand 
Pruet Boonma, Chiang Mai University, Thailand 
Rafidah Md. Noor, University of Malaya, Malaysia 
Rapeepan Piriyakul, Ramkhamhaeng University, Thailand 
Raymond Greenlaw, United States Naval Academy, USA 
Saowapak (Sotthivirat) Thongvigitmanee, National Electronics and Computer Technology 
Center, Thailand 
Sheng-Lung Peng, National Dong Hwa University, Taiwan 
Sunisa Rimcharoen, Burapha University, Thailand 
Teerawat Prakobphon, KMITL, Thailand 
Ureerat Suksawatchon, Burapha University, Thailand 
Van Bang Le, University of Rostock, Germany 
Vasaka Visoottiviseth, Mahidol University, Thailand 
 
 
 
An Improved Loopless Algorithm for Generating Binary Tree Sequences
Ro–Yu Wu
Department of Industrial Management
Lunghwa University of Science and Technology
Taoyuan, Taiwan, ROC.
Email: eric@mail.lhu.edu.tw
An–Hang Chen, Jou–Ming Chang
Institute of Information and Decision Sciences
National Taipei College of Business
Taipei, Taiwan, ROC
Email: {hang, spade}@mail.ntcb.edu.tw
Abstract—In 1986, Pallo introduced the left weight sequences
(LW-sequences) for representing binary trees and showed that
every binary tree can be characterized by an LW-sequence. Us-
ing such a coding technique, Vajnovszki [Inform. Process. Lett.
68 (1998) 113-117] proposed a loopless algorithm to generate
LW-sequences of binary trees in Gray-code order, where the
algorithm needs 8n+O(1) space and each generation requires
3/5 comparisons and 9/13 assignments in the best/worst case,
respectively. In this paper, we present a new loopless generation
algorithm for LW-sequences, which takes 6n + O(1) space
and each generation requires exactly 3 comparisons and 6/10
assignments in the best/worst case, respectively. Moreover, as
a by-product, our algorithm can simultaneously generate the
Gray-code of the corresponding right weight sequences that
was introduced by Wu et al. [Theoret. Comput. Sci. 355 (2006)
303-314].
Keywords-Loopless algorithms, Coding trees, Gray-code gen-
eration, left weight sequences
I. INTRODUCTION
An exhaustive generation of a class of combinatorial
objects plays an important research in computer science.
Such a generated list of objects has many applications
including searching out the desired object among all candi-
dates, looking for a counterexample for a certain conjecture,
and experimentally measuring an average performance of
an algorithm over all possible inputs. A crucial issue on
enumerating objects is to ensure that each object can be
generated in a constant time. Ehrlich [4] defined a loopless
generation algorithm to be an algorithm where the amount of
computations needed to change one object into the next one
takes a constant time. Thus a loopless generation algorithm
can be implemented non-recursively by using, after the ini-
tialization of the first object, only “if-then-else” statements
and assignment statements. If the objects are encoded by
integer sequences and only one integer is changed between
two successive objects, then the result of enumeration will
produce a Gray-code order. The first loopless Gray-code
generation algorithm was introduced by Williamson [17].
The reader can refer to [12] for an excellent survey of listing
combinatorial objects in Gray-code order.
This research was partially supported by National Science Council of
Taiwan under the Grants NSC99-2221-E-262-013, NSC99-2115-M-141-
002 and NSC99-2115-M-141-001-MY2.
Binary trees are a common used combinatorial objects and
have been extensively studied over the past 40 years [1]–
[3], [13]. In [8], Pallo introduced the left weight sequences
(LW-sequence) for representing binary trees and showed that
every binary tree can be characterized by an LW-sequence (a
formal definition of LW-sequence will be given in Section
2). Also, there exist other types of integer sequences for
representing binary trees, e.g., a well-formed integer se-
quences called Z-sequences suggested by Zaks [22], a char-
acteristic integer sequences called T-sequences recommend
by Takaoka [14], and the so-called P-sequences introduced
by Pallo [9]. Many algorithms have been developed for
generating binary trees and their correspondence (see mono-
graphs [6], [11] and the references given there). In particular,
loopless algorithms for generating binary tree sequences are
attracted a great deal of attention in the literature [14]–[16],
[20].
In [10], Roelants van Baronaigien and Ruskey first de-
signed a recursive algorithm (i.e., a non-loopless algorithm)
to generate LW-sequences of binary trees in Gray-code
order, and in [15] Vajnovszki enumerated the same gen-
erated list using a loopless algorithm obtained by apply-
ing Williamson’s algorithm [17]. Takaoka [14] proposed a
loopless algorithm to generate T-sequences of binary trees
in Gray-code order. Xiang and Ushijima [20] presented a
loopless algorithm to generate Z-sequences of binary trees
in Gray-code order. Later on, Vajnovszki [16] developed
another loopless algorithm to generate P-sequences of binary
trees in Gray-code order. For ease of reference the results
mentioned above, each algorithm in Table I shows the
memory space required, the number of comparisons and
the number of assignments required in the best/worst case,
respectively. However, we note that the contest between any
two of the algorithms is meaningless because they adopted
the different types of binary tree sequences.
In this paper, we present a new loopless generation
algorithm for LW-sequences. Our algorithm takes 6n+O(1)
space and each generation requires exactly 3 comparisons
and 6/10 assignments in the best/worst case, respectively.
The rest of the paper is organized as follows. In Section
2, we give some basic definitions and introduce a useful
structural representation of binary trees. In Section 3, we
197
© ICSEC 2011, September 2011, Bangkok, Thailand.
131
1 2
1 2 3
1 42 3 1 43 1 4 1 41 4
51 2 43 51 43 51 4 51 51 2 4 51 4 51 51 2 51 51 2 3 51 51 51 2 51
2
3
Figure 2. The coding tree for representing LW-sequences of binary trees in T5.
3
1
1
12
1 2 3
14 23 1 43 1414 1 4
5 124 351 435 1451 51 2 4 5 14 51 51 25 15 123 51 5 151 25 1
2
3
Figure 3. A flip-flap tree.
III. LOOPLESS GRAY-CODE GENERATION FOR
LW-SEQUENCES
In this section, we propose a loopless algorithm to gen-
erate Gray-code of binary trees in LW-sequences. Our basic
idea is inspired by the so-called flip-flap arrangement in
a coding tree [19]. Let T denote the coding tree. For
every non-leaf node x ∈ T, we say that x has an up-
fragment (respectively, a down-fragment) if the labels of x’s
children are arranged (from left to right) in increasing order
(respectively, decreasing order). Moreover, an arrangement
of nodes in T is called a flip-flap arrangement provided the
following condition hold: if a node x has an up-fragment,
then its adjacency siblings (if exist) must have a down-
fragment, and vice versa. Then, the resulting coding tree
is called a flip-flap tree.
By Theorem 1, we know that, for every level i ￿ 2 on T,
two particular labels 1 and i always appear in any fragment,
and thus the two types of fragments can appear alternately in
each level of T. As a result, there is only one position having
different digits in the two LW-sequences corresponding to
the paths with adjacent leaves in a flip-flap tree T. By this
way, if the full labels along the path in the left-arm of T are
determined, the framework of T is also determined instantly.
Since there are 2n−1 choices to label the nodes in the left-
arm of T, the number of different ways to generate Gray-
code of binary trees with n internal nodes in LW-sequences
is at least 2n−1. For instance, Figure 3 shows a Gray-code
enumeration for n = 5, where LW-sequences begin with
(1, 2, 3, 4, 5) and thus the initial fragment in each level of T
is given by a down fragment.
199
© ICSEC 2011, September 2011, Bangkok, Thailand.
Table II
A LIST OF LW-SEQUENCES AND RW-SEQUENCE FOR BINARY TREES
WITH 5 INTERNAL NODES.
Tree LW-sequence RW-sequence L R
1 (1,2,3,4,5) (1,1,1,1,1) (0,1,2,3,4) (0,0,0,0,0)
2 (1,2,3,4,1) (1,1,1,2,1) (0,1,2,3,0) (0,0,0,5,0)
3 (1,2,3,1,1) (1,1,3,2,1) (0,1,2,0,0) (0,0,4,5,0)
4 (1,2,3,1,2) (1,1,3,1,1) (0,1,2,0,4) (0,0,5,0,0)
5 (1,2,3,1,5) (1,1,2,1,1) (0,1,2,0,3) (0,0,4,0,0)
6 (1,2,1,1,5) (1,3,2,1,1) (0,1,0,0,2) (0,3,4,0,0)
7 (1,2,1,1,3) (1,4,2,1,1) (0,1,0,0,3) (0,5,4,0,0)
8 (1,2,1,1,2) (1,4,3,1,1) (0,1,0,0,4) (0,3,5,0,0)
9 (1,2,1,1,1) (1,4,3,2,1) (0,1,0,0,0) (0,3,4,5,0)
10 (1,2,1,2,1) (1,4,1,2,1) (0,1,0,3,0) (0,4,0,5,0)
11 (1,2,1,2,3) (1,4,1,1,1) (0,1,0,3,4) (0,5,0,0,0)
12 (1,2,1,2,5) (1,3,1,1,1) (0,1,0,3,2) (0,4,0,0,0)
13 (1,2,1,4,5) (1,2,1,1,1) (0,1,0,2,4) (0,3,0,0,0)
14 (1,2,1,4,1) (1,2,1,2,1) (0,1,0,2,0) (0,3,0,5,0)
15 (1,1,1,4,1) (3,2,1,2,1) (0,0,0,1,0) (2,3,0,5,0)
16 (1,1,1,4,5) (3,2,1,1,1) (0,0,0,1,4) (2,3,0,0,0)
17 (1,1,1,3,5) (4,2,1,1,1) (0,0,0,2,1) (4,3,0,0,0)
18 (1,1,1,3,4) (5,2,1,1,1) (0,0,0,2,4) (5,3,0,0,0)
19 (1,1,1,3,1) (5,2,1,2,1) (0,0,0,2,0) (4,3,0,5,0)
20 (1,1,1,2,1) (5,4,1,2,1) (0,0,0,3,0) (2,4,0,5,0)
21 (1,1,1,2,3) (5,4,1,1,1) (0,0,0,3,4) (2,5,0,0,0)
22 (1,1,1,2,4) (5,3,1,1,1) (0,0,0,3,2) (5,4,0,0,0)
23 (1,1,1,2,5) (4,3,1,1,1) (0,0,0,3,1) (2,4,0,0,0)
24 (1,1,1,1,5) (4,3,2,1,1) (0,0,0,0,1) (2,3,4,0,0)
25 (1,1,1,1,4) (5,3,2,1,1) (0,0,0,0,2) (5,3,4,0,0)
26 (1,1,1,1,3) (5,4,2,1,1) (0,0,0,0,3) (2,5,4,0,0)
27 (1,1,1,1,2) (5,4,3,1,1) (0,0,0,0,4) (2,3,5,0,0)
28 (1,1,1,1,1) (5,4,3,2,1) (0,0,0,0,0) (2,3,4,5,0)
29 (1,1,2,1,1) (5,1,3,2,1) (0,0,2,0,0) (3,0,4,5,0)
30 (1,1,2,1,2) (5,1,3,1,1) (0,0,2,0,4) (3,0,5,0,0)
31 (1,1,2,1,4) (5,1,2,1,1) (0,0,2,0,3) (5,0,4,0,0)
32 (1,1,2,1,5) (4,1,2,1,1) (0,0,2,0,1) (3,0,4,0,0)
33 (1,1,2,3,5) (4,1,1,1,1) (0,0,2,3,1) (4,0,0,0,0)
34 (1,1,2,3,4) (5,1,1,1,1) (0,0,2,3,4) (5,0,0,0,0)
35 (1,1,2,3,1) (5,1,1,2,1) (0,0,2,3,0) (4,0,0,5,0)
36 (1,1,2,4,1) (3,1,1,2,1) (0,0,2,1,0) (3,0,0,5,0)
37 (1,1,2,4,5) (3,1,1,1,1) (0,0,2,1,4) (3,0,0,0,0)
38 (1,1,3,4,5) (2,1,1,1,1) (0,0,1,3,4) (2,0,0,0,0)
39 (1,1,3,4,1) (2,1,1,2,1) (0,0,1,3,0) (2,0,0,5,0)
40 (1,1,3,1,1) (2,1,3,2,1) (0,0,1,0,0) (2,0,4,5,0)
41 (1,1,3,1,2) (2,1,3,1,1) (0,0,1,0,4) (2,0,5,0,0)
42 (1,1,3,1,5) (2,1,2,1,1) (0,0,1,0,3) (2,0,4,0,0)
of binary trees in Gray-code simultaneously. In addition,
two auxiliary sequences to record the left child and right
child of each internal node are also generated. To the best
of our knowledge, it seems that the technique of generating
multiple types of sequences for binary trees is the first time
to be proposed. We believe that the technique could easily
be imitated to generate other combinatorial objects.
REFERENCES
[1] G. M. Adel’son-Vel’skii˘ and E. M. Landis, An algorithm for
organization of information, Soviet Mathematics Doklady 3
(1962) 1259–1263.
[2] A. Andersson, General balanced trees, J. Algorithms 30 (1999)
1–18.
[3] R. Bayer, Symmetric binary B-trees: data structure and main-
tenance algorithms, Acta Informatica 1 (1972) 290–306.
[4] G. Ehrlich, Loopless algorithms for generating permutations,
combinations, and other combinatorial configurations, J. ACM
20 (1973) 500–513.
[5] D.E. Knuth, The Art of Computer Programming, Vol. 3 —
Sorting and Searching, Addison-Wesley, 1973.
[6] D.E. Knuth, The Art of Computer Programming: Vol. 4 Fasci-
cle 4A — Generating All Trees, Addison-Wesley, 2005.
[7] J. M. Lucas, D. Roelants van Baronaigien, and F. Ruskey, On
rotations and the generation of binary trees. J. Algorithms 15
(1993) 343–366.
[8] J. Pallo, Enumerating, ranking and unranking binary trees,
Comput. J. 29 (1986) 171–175.
[9] J. Pallo and R. Racca, A note on generating binary trees in
A-order and B-order, Int. J. Comput. Math. 18 (1985) 27–39.
[10] D. Roelants van Baronaigien, F. Ruskey, A Hamiltonian path
in the rotation lattice of binary trees, Congr. Numer. 59 (1987)
313–318.
[11] F. Ruskey, Combinatorial Generation, Working version of
book in progress, 1995.
[12] C. D. Savage, A survey of combinatorial Gray codes, SIAM
Rev. 39 (1997) 605–629.
[13] D. D. Sleator and R. E. Tarjan, Self-adjusting binary search
trees, Journal of the ACM 32 (1985) 652–686.
[14] T. Takaoka, O(1) time algorithms for combinatorial genera-
tion by tree traversal, Comput. J. 42 (1999) 400–408.
[15] V. Vajnovszki, On the loopless generation of binary tree
sequences, Inform. Process. Lett. 68 (1998) 113–117.
[16] V. Vajnovszki, Generating a Gray code for P-sequences, J.
Math. Model. Algorithms 1 (2002) 31–41.
[17] S. G. Williamson, Combinatorics for Computer Science,
Computer Science Press, Rockville, MD, 1985.
[18] Ro-Yu Wu, Jou-Ming Chang, and Yue-Li Wang, A linear time
algorithm for binary tree sequences transformation using left-
arm and right-arm rotations, Theor. Comput. Sci. 355 (2006)
303–314.
[19] Ro-Yu Wu, Jou-Ming Chang, and Yue-Li Wang, Loopless
generation of non-regular trees with a prescribed branching
sequence, Comput. J. 53 (2010) 661–666.
[20] L. Xiang and K. Ushijima, On O(1) time algorithms for
combinatorial generation, Comput. J. 44 (2001) 292–302.
[21] L. Xiang, K. Ushijima, and S. G. Akl, Generating regular
k-ary trees efficiently, Comput. J. 43 (2000) 290–300.
[22] S. Zaks, Lexicographic generation of ordered trees, Theor.
Comput. Sci. 10 (1980) 63–82.
[23] D. Zerling, Generating binary trees using rotations, J. ACM
32 (1985) 694–701.
201
© ICSEC 2011, September 2011, Bangkok, Thailand.
 1 
 
國科會補助專題研究計畫項下出席國際學術會議心得報告 
                                    日期「101年04月23日 
                                 
一︾參加會議經過 
�World Academy of Science, Engineering and Technology於 101 年 2 月 19 日至 2 
月 21 日︽在馬來西亞吉隆坡舉辦年度國際學術研討會-�ICCSA 2012 International 
Conference on Computer Science and Application︽會議地點位於吉隆坡的 Pacific Regency 
Hotel 舉行〈會議 Agenda 如下「  
• 2月19日「抵達會場並完成報到程序及領取相關資料︽參與由主辦單位所舉辦的研
討會︽並於休息期間和與會之國際學者進行學術交流〈 
• 2月20日「參與由主辦單位所舉辦的研討會︽並於休息期間和與會之國際學者進行
學術交流〈 
• 2月21日「參與由主辦單位所舉辦的研討會︽並於休息期間和與會之國際學者進行
計畫編號 100-2221-E-141-002- 
計畫名稱 蜂巢格狀網路上的電力支配問題研究 
出國人員
姓名 
黃雯音 
服務機構
及職稱 
國立台北商業技術學院 研究生 
會議時間 
101年2月19日至101
年2月21日 
會議地點 馬來西亞 吉隆坡 
會議名稱 
ICCSA 2012 : International Conference on Computer Science and 
Application 
發表論文
題目 
Fault-free cycles in folded hypercubes with at most 2n-3 faulty elements 
 3 
四︾建議 
 無〈 
 
五︾攜回資料名稱及內容 
1. 議程表一份 「研討會三天的會議議程〈 
2. 論文集一本 「截錄研討會部分的投稿論文〈 
3. 會議光碟  「內容囊括研討會會議所有投稿論文的電子檔〈 
 
六︾其他 
 無〈 
 
 
 
 
TENTATIVE KUALA LUMPUR 2012 CONFERENCE PROGRAM 
The Complete Conference Registration is Required for Publication in the Conference Proceedings at 
http://www.waset.org/author.php 
 
PROGRAM LAST UPDATED: FEBRUARY 02, 2012 1
Time Paper Title Authors 
 Sunday February 19, 2012 
08:30 
09:00 Welcome & Registration Opening Remarks 
09:00 
11:00 T.B.A. HALL-A Session – I (February 19, 2012) 
 Recent Developments in Speed Control System of Pipeline 
PIGs For Deepwater Pipeline Applications 
Mohamad Azmi, Md Haniffa MdHaniffa 
Universiti Teknologi Petronas, Malaysia  
 The Effects of Roots Action of Tropical Green Roofs—
Replication of German FLL in Singapore 
Kian Kai Tan 
National University of Singapore, Singapore  
 
Overhead Estimation over Capacity of Mobile WiMAX Saeed AL-Rashdy CRC Harbin Institute of Technology, Harbin China, China 
 Communication Engineering Design of EDFA Gain Controller 
based on Disturbance Observer Technique 
Seong-Ho Song, Ki-Seob Kim, Seop-Hyeong Park, Seon-Woo Lee 
Hallym University, Korea 
 Hand Gesture Recognition using Blob Detection for Immersive 
Projection Display System 
Hasup Lee, Yoshisuke Tateyama, Tetsuro Ogi 
Keio University, Japan 
 Steady-State Performance of a New Model for UPFC Applied to 
Multi-Machine Systems with Nonlinear Load 
S. Ali Al-Mawsawi 
University of Bahrain, Bahrain 
 Three-Level Converters based Generalized Unified Power 
Quality Conditioner 
K. S. Rama Rao 
Universiti Teknologi Petronas, Malaysia 
 Oil Palm Empty Fruit Bunch as a New Organic Filler for 
Electrical Tree Inhibition 
M. H. Ahmad, A. A. A. Jamil, H. Ahmad, M. A. M. Piah, A. Darus, Y. Z. Arief, 
N. Bashir Universiti Teknologi Malaysia, Malaysia 
 
Concentrated Solar Power Generation Haitham Safar Kuwait Oil Company, Kuwait 
 Correction of Infrared Data for Electrical Components on a 
Board 
Seong Ho Song, Ki-Seob Kim, Seop-Hyeong Park, Seon-Woo Lee 
Hallym University, Korea 
 Magnetic Optimization Algorithm Approach For Travelling 
Salesman Problem 
Mohd Muzafar bin Ismail 
Universiti Teknikal Malaysia Melaka, Malaysia 
11:00 
11:15 Coffee Break 
11:15 
13:00 T.B.A. HALL-A Session – II (February 19, 2012) 
 
A Bootstrap’s Reliability Measure on Tests of Hypotheses Al Jefferson Pabelic, Dennis A. Tarepe Northern Consortium UK - Shenyang Center, People's Republic of China 
 
Estimate of the Renewal Function with Heavy-Tailed Claims Rassoul Abdelaziz High National School of Hydraulic, Algeria 
 Bootstrap Confidence Interval and Parameter Estimation for 
Zero Inflated Strict Arcsine Model 
Phang Yook Ngor, Loh Er Fu 
Universiti Teknologi Mara, Malaysia 
 Numerical Solution of a Fluid Flow in a Non-Uniform Channel: 
Application to Renal Flow 
Muthu Poosan Moopanar, Tesfahun Berhane 
National Institute of Technology, Warangal, India 
 
Exhaustion Numbers of 2-Subsets of Dihedral Groups              Shereen Sharmini, H. V. Chen, A. Y. M. Chin, S. Sharmini Universiti Tunku Abdul Rahman, Malaysia 
 Cycle Embedding in Folded Hypercubes with more Faulty 
Elements 
Wen-Yin Huang, Jia-Jie Liu, Jou-Ming Chang 
Shih Hsin University, Republic of China  
 Active Vibration Control of Flexible Beam using Differential 
Evolution Optimisation 
Mohd Sazli Saad, Hishamuddin Jamaluddin, Intan Zaurah Mat Darus 
Universiti Malaysia Perlis, Malaysia 
 A Method to Annotate Programs with High-Level Knowledge of 
Computation 
Nobuhiko Hishinuma, Jun Igari, Rentaro Yoshioka  
University of Aizu, Japan 
 The Weighted Minimum Tuple 2-Rainbow Domination on 
Graphs 
William Chung-Kung Yen, Jia-Jie Liu, Chao-Cheng Shih 
Shih Hsin University, Taiwan  




(a) FQ2








(b) FQ3
Fig. 1. Graphs of FQ2 and FQ3, in which complementary links are drawn
by dashed lines.
Lemma 1 ([19]). There is an automorphism δ of FQn such
that δ(Ei) = Ej for i, j ∈ {1, 2, . . . , n} ∪ {s}.
It directly derives the following corollary.
Corollary 2. FQn − Ei is isomorphic to Qn for i ∈
{1, 2, . . . , n} ∪ {s}.
In an n-dimensional faulty hypercube Qn, let Fv and Fe be
the sets of faulty nodes and faulty links of Qn, respectively. On
the problem of ﬁnding the lower bound of longest fault-free
cycle in Qn, Du et al. [4] have shown the result as Lemma 3.
Lemma 3 ([4]). Qn−Fv−Fe for n ≥ 3 contains a fault-free
cycle of length at least 2n − 2|Fv| if (1) |Fv|+ |Fe| ≤ 2n− 4
and |Fe| ≤ 2n− 5 and (2) every node in Qn is incident to at
least two fault-free links.
Lemma 4 ([11]). Every edge of Qn−Fv−Fe lies on a cycle
of every length from 4 to 2n−2|Fv| even if |Fv|+|Fe| ≤ n−2,
where n ≥ 3.
III. FAULT-FREE CYCLE IN THE FAULTY FOLDED
HYPERCUBES
In this section, we present our main result on considering
the constraints that (1) |FFv|+ |FFe| ≤ 2n− 3, (2) |FFe| ≥
n + 2, and (3) every vertex in FQn is incident with at least
two links, as shown in Theorem 6. In an n-dimensional faulty
folded hypercube FQn, we call a non-faulty node k-free if it
is incident to at most k fault-free links.
Lemma 5. If |FFv|+ |FFe| ≤ 2n− 3, there are at most two
2-free nodes contained in FQn.
Proof. By the deﬁnition of k-free node, a 2-free nodes is
adjacent to at least n−1 faulty elements, included faulty links
and faulty nodes. Since |FFv| + |FFe| ≤ 2n − 3, there is
at most two 2-free nodes contained in FQn and these two
nodes are adjacent with a common faulty link, say (u, v) (see
Figure 3 as an example). 
Theorem 6. FQn −FFv −FFe, for n ≥ 5 contains a fault-
free cycle of length at least 2n−2|FFv| if (1) |FFv|+|FFe| ≤
2n − 3, (2) |FFe| ≥ n + 2, and (3) every vertex is incident
with at least two links.
Proof. We consider the following three cases according to the
number of 2-free nodes:
Case 1: FQn contains no 2-free node.
Since |FFe| ≥ n + 2, there exists a dimension i such that
F (Ei) ≥ 2, for i ∈ {1, 2, . . . , n}∪{s}. By Corollary 2, FQn−
Ei is isomorphic to Qn. Thus, |FFv| + |FFe| ≤ 2n − 5 in
Qn. Since every node in FQn is k-free for some k ≥ 3,
every node in Qn is incident at least two fault-free links. By
Lemma 3, there exists a fault-free cycle of length 2n − 2|Fv|
(=2n − 2|FFv|) in Qn −Fv −Fe since |Fv|+ |Fe| ≤ 2n− 4,
|Fe| ≤ 2n−5, and every node in Qn is incident to at least two
fault-free links. Therefore, we obtain that FQn−FFv −FFe
contains a fault-free cycle of length at least 2n − 2|FFv|.
Case 2: There is a unique 2-free node u in FQn and every
node in FQn − {u} is k-free for some k ≥ 3.
Assume without loss of generality that d1(u) and d2(u) are
two non-faulty links and either di(u) is faulty link or u(i) is a
faulty node, for i ∈ {3, 4, . . . , n}∪{s}. Since |FFe| ≥ n+2,
there exists a dimension j such that F (Ej) ≥ 2, for j ∈
{1, 2, . . . , n} ∪ {s}. If j ∈ {1, 2}, FQn − Ej is isomorphic
to Qn. With the same arguments as Case 1, we have that
FQn−Ej also satisﬁes the constraints in Lemma 3. It derives
that FQn − FFv − FFe contains a fault-free cycle of length
at least 2n − 2|FFv|.
Now, we consider the case that j ∈ {1, 2}. There are two
subcases to consider.
Subcase 2.1: There exists a faulty link da(u) such that
d1(u(a)) is an non-faulty link and u(a) and u(a)(1) are non-
faulty nodes, where a ∈ {3, 4, . . . , n}∪ {s} (see Figure 2(a)).
Hence, FQn − Ek is isomorphic to Qn, where k ∈
{3, 4, . . . , n}∪{s}−{a}. Furthermore, Qn can be decomposed
to QLn−1 and Q
R
n−1 at dimension 1 and u ∈ QLn−1. Assume
that da(u) is an non-faulty link. Let FLv and F
L
e (respectively,
FRv and F
R
e ) denote the set of faulty nodes and faulty links in
QLn−1 (respectively, Q
R
n−1), respectively. Since u is a 2-free
node, F (E1) ≥ 2, F (Ek) ≥ 1, and da(u) is an non-faulty link,
|FLv |+ |FLe | ≥ n−1 and |FLv |+ |FLe | ≤ 2n−3−4 = 2n−7.
Let FL(w) denote the set of faulty elements adjacent to
node w, where w ∈ QLn−1. Since FL(u) = n − 3 and
|FLv |+ |FLe | ≤ 2n−7, FL(j) ≤ n−3 for all j ∈ QLn−1 except
u. Thus, every node in QLn−1 is incident at least two fault-free
International Journal of Computer and Communication Engineering 6 2012
215
|FFv| + |FFe| ≤ 2n − 3, (2) |FFe| ≥ n + 2, and (3) every
vertex is still incident with at least two links. We proved that
FQn−FFv−FFe for n ≥ 5 has a fault-free cycle of length at
least 2n−2|FFv|. In the further work, we interest to consider
whether FQn − FFv − FFe for n ≥ 5 still has a fault-free
cycle of length at least 2n−2|FFv| under the constraints : (1)
|FFv| + |FFe| ≤ 2n − 3, (2) |FFe| < n + 2, and (3) every
vertex is still incident with at least two links.
REFERENCES
[1] Ahmed EI-Amawy and Shahram Latiﬁ, Properties and performance
of folded hypercubes, IEEE Transactions on Parallel and Distributed
Systems, 2(1) (1991) 31–42.
[2] P. Banerjee, J.T. Rahmeh, C. Stunkel, V.S. Nair, K. Roy, V. Balasubrama-
nian, and J.A. Abraham, Algorithm-based fault tolerance on a hypercube
multiprocessor, IEEE Transactions on Computers, 39(9) (1990) 1132–
1145.
[3] J. Bruck, R. Cypher, and C.T. Ho, Efﬁcient fault-tolerant mesh and
hypercube architectures, Proceedings of IEEE Symposium on Fault-
Tolerant Computing, 1992, 162–169
[4] Z. Z. Du, J. Jin, M. J. Ma, J. M. Xu, Cycle embedding in hypercubes with
faulty vertices and edges, Journal of University of Science and Technology
of China, 38(9) (2008) 1020–1024.
[5] J.B. Dugan, S.J. Bavuso, and M.A. Boyd, Dynamic fault-tree models for
fault-tolerant computer systems, IEEE Transactions on Reliability, 41(3)
(1992) 363–377.
[6] D.R. Duh, G.H. Chen, and J.F. Fang, Algorithms and properties of a
new two-level network with folded hypercube as basic modules, IEEE
Transactions on Parallel and Distributed Systems, 6(7) (1995) 714–723.
[7] K. Efe, A variation on the hypercube with lower diameter, IEEE Trans-
actions on Computers, 40(11) (1991) 1312–1316.
[8] A. Esfahanian, L.M. Ni, and B.E. Sagan, The twisted n-cube with
application to multiprocessing, IEEE Transactions on Computers, 4(1)
(1991) 88–93.
[9] Jung-Sheng Fu, Fault-free cycles in folded hypercubes with more faulty
elements, Information Processing Letters, 108(5) (2008) 261–263.
[10] Sun-Yuan Hsieh, Some edge-fault-tolerant properties of the folded
hypercube, Networks, 51(2) (2008) 92–101.
[11] Sun-Yuan Hsieh and Tzu-Hsiung Shen, Edge-bipancyclicity of a hyper-
cube with faulty vertices and edges, Discrete Applied Mathematics, 156
(2008) 1802–1808.
[12] Sun-Yuan Hsieh, C. N. Kuo, and H. H. Chou, A further result on fault-
free cycles in faulty folded hypercubes, Information Processing Letters,
110 (2) (2009) 41–43.
[13] T.L. Kueng, T. Liang, J.J.M. Tan, and L.H. Hsu, Long paths in hy-
percubes with conditional node-faults, Information Sciences, 179 (2009)
667-681.
[14] F.T. Leighton, Introduction to Parallel Algorithms and Architectures:
Arrays, Trees, Hypercubes, Morgan Kaufmann Publishers Inc., 1992, 78–
82, 239–244.
[15] Y. Saad and M.H. Schultz, Topological properties of hypercubes, IEEE
Transactions on Computers, 37(7) (1988) 867–871.
[16] C.H. Tsai and Y.C. Lai, Conditional fault-tolerant edge-bipancyclicity
of hypercubes, Information Sciences, 177 (2007) 5590–5597.
[17] D. Wang, Embedding Hamiltonian cycles into folded hypercube with
faulty links, Journal of Parallel and Distributed Computing, 61(4) (2001)
545–564.
[18] J. M. Xu, M. J. Ma, Cycles in folded hypercubes, Applied Mathematics
Letters, 19(2) (2006) 140–145.
[19] J. M. Xu, M. J. Ma, Z. Z. Du, Edge-fault-tolerant properties of hyper-
cubes and folded hypercubes, Australasian Journal of Combinatorics, 35
(2006) 7–16.
[20] S.G. Ziavras, A versatile family of reduced hypercube interconnection
networks, IEEE Transactions on Parallel and Distributed Systems, 5(11)
(1993) 1210–1220.
International Journal of Computer and Communication Engineering 6 2012
217
100 年度專題研究計畫研究成果彙整表 
計畫主持人：張肇明 計畫編號：100-2221-E-141-002- 
計畫名稱：蜂巢格狀網路上的電力支配問題研究 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 3 3 100% 
篇 
1. 論 文 An 
efficient 
ranking 
algorithm of 
t-ary trees in 
Gray-code order
發表於第 29 屆
組合數學與計算
理論研討會 (台
北) 
2. 論 文
Independent 
spanning trees 
on Cartesian 
product of 
hybrid graphs 發
表於第 29 屆組
合數學與計算理
論研討會 (台北)
3. 論 文  A 
longest 
fault-free cycle 
in conditional 
faulty folded 
hypercubes 發表
於第 29 屆組合
數學與計算理論
研討會 (台北) 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
國內 
參與計畫人力 
（本國籍） 博士生 0 0 100% 
人次 
 
討會 (馬來西亞
吉隆坡) 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 4 4 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
