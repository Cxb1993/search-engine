Table of Contents
Chapter
1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
2 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2.1 Packet Overhearing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2.2 Fault Tolerance for Wireless Sensor Networks . . . . . . . . . . . . . . . 5
2.3 Reliable Routing Schemes in Wireless Sensor Networks . . . . . . . . . . 6
2.4 Event Region Detection in Wireless Sensor Networks . . . . . . . . . . . 7
2.5 Error Detection and Correction Code . . . . . . . . . . . . . . . . . . . . 8
2.6 Voting Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
3 System Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3.1 Failure Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.2 Assumptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.3 Protocol Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
4 Overhearing-based Detection Mechanism . . . . . . . . . . . . . . . . . 12
4.1 Construction Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
4.2 Overhearing Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
4.3 Decision phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
4.4 Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
5 Performance Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
5.1 Simulation Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
5.2 Failure Injection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
5.3 Traffic Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
5.4 Experimental Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
5.4.1 With Varying Failure Rates . . . . . . . . . . . . . . . . . . . . . 24
5.4.2 With Varying Traffic Load . . . . . . . . . . . . . . . . . . . . . . 27
6 Conclusion and Future Work . . . . . . . . . . . . . . . . . . . . . . . . . 32
6.1 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
6.2 Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
iii
List of Figures
3.1 The protocol stack. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
4.1 Example of OBD mechanism. . . . . . . . . . . . . . . . . . . . . . . . . 13
4.2 Example of overhearing phase. . . . . . . . . . . . . . . . . . . . . . . . . 14
4.3 Example of decision phase. . . . . . . . . . . . . . . . . . . . . . . . . . . 15
4.4 Algorithm for committee nodes. . . . . . . . . . . . . . . . . . . . . . . . 18
4.5 Algorithm for decision phase. . . . . . . . . . . . . . . . . . . . . . . . . 19
5.1 End-to-end delay between source and sink. . . . . . . . . . . . . . . . . . 24
5.2 Total energy consumption. . . . . . . . . . . . . . . . . . . . . . . . . . 25
5.3 Detection latency. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
5.4 AMV diagnosis strategy result. . . . . . . . . . . . . . . . . . . . . . . . 27
5.5 End-to-end delay between source and sink. . . . . . . . . . . . . . . . . . 30
5.6 Total energy consumption. . . . . . . . . . . . . . . . . . . . . . . . . . . 30
5.7 Detection latency. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
5.8 AMV diagnosis strategy result. . . . . . . . . . . . . . . . . . . . . . . . 31
v
recovery can tolerate the gateway experienced faults [4]. An energy efficient routing
algorithm propagates a query message to the appropriate geographical region to avoid
failure [5]. Multi-path routing schemes, such as [6], utilize multi-paths for transmitting
multi-copies of the same event to improve the resilience with node failures. Generally
speaking faults can be divided into hardware and software ones. Sensor nodes may suffer
hardware faults due to most prone to malfunctioning or drain of power. When a sensor
node occurs hardware faults, it is unable to communicate with other nodes. Software
faults may occur due to internal defects, such as corrupted processors, memories, or the
communication units. Sensor nodes suffer software faults continue communicating with
other nodes in the system, but the erroneous data will disseminate to the whole network.
Failure models discussed in the previous researches were concentrated on hardware fail-
ures. A few attentions were devoted to the faults during data processing inside hardware
or software components of sensor nodes or data delivery from sources to sink. Bit errors
in a data frame may occur before the frame’s checksum were computed and appended so
the sink will not notice the errors through error-detecting codes. Data inconsistent fail-
ures could be caused by incorrect data processing, memory leakage, or hardware/software
defects. Since data inconsistent faults did not crash sensor nodes, the failed nodes can
propagate erroneous information to the network and the sink may also yield incorrectly
consequent from wrong information gathering. If the faulty sensors are responsible for
battle field surveillance, the sink will not know the real status of the environment, and
will make incorrect decisions due to the wrong data. In this report, a detecting mecha-
nism is presented to tolerate data inconsistent failures by using reliable single path data
transmission.
2
Chapter 2
Related Work
2.1 Packet Overhearing
An important feature of wireless communication is overhearing which the node can over-
hear neighboring packets that are not destined for it. Several researches employ this
characteristic for some demands. Paek et al. used overhearing to provide a NACK-based
hybrid hop-by-hop and end-to-end reliability scheme [7]; Lee and Gerla proposed a scheme
without transmitting extra control message to provide multiple alternate routes and local
repair mechanism based on overhearing [8]; Dunkels et al. employed overhearing to avoid
routing problems with transport layer port number conflicts [9]. Moreover, it has been
shown that including promiscuous mode operation significantly reduced control overhead
and increased delivery ratio at higher speeds [10, 11]. However, packet overhearing is not
used in the current MAC design, only broadcast packets and those packets whose target
are the nodes’ address will be received, all other packets will be discarded. Appointed
BrOadcast achieved packet overhearing and reduced the routing overhead [12].
4
and Younis proposed a scheme to tolerate faults while performing sensor integration and
ensuring sensing coverage [18]. A mechanism for detecting crash faults in wireless sensor
networks was described in [19]. In order to avoid failures, an energy efficient routing
algorithm in [5] propagates a query to the appropriate geographical region. Multi-path
routing scheme, such as [6], utilize three paths for transmitting three copies of the same
event to improve the resilience with node failures. An algorithm guaranteed reliable and
fairly accurate output from a number of different types of sensors [20]. A comparison-
based diagnosis model utilized the one-to-many communication paradigm was presented
in [21].
2.3 Reliable Routing Schemes in Wireless Sensor Networks
Directed diffusion [22] provided a data dissemination paradigm for wireless sensor net-
works. Without location information, the directed diffusion used flooding to advertise the
interests from sinks to sources. Data delivery passed by diffusion paths and re-enforced
by the sources. Interests are periodically refreshed by the sinks. For continuous queries,
the cost of flooding is amortized over the amount of information exchanged over possi-
bly extended periods of time. For one-shot queries or mobility, directed diffusion with
flooding may incur excessive overhead especially in large scale networks.
Multipath routing is typically used for load balancing and fault tolerance. Two types
of multiple paths were constructed to enable energy-efficient recovery for both indepen-
dent and geographically-correlated failures [5]. Alternate paths in a braid were partially
disjoint from the primary path, but not completely node-disjoint. For patterned failures,
the braided multipath approach showed comparable resilience with the node-disjoint
6
2.5 Error Detection and Correction Code
Cyclic redundancy check (CRC) [6] are the most general in error detection and correction
codes. It is able to detect and correct bit errors, but extra circuits or software is a load
for sensors with limited computational power. Moreover, the codes may not be able
to solve Byzantine failures that behave arbitrarily. A somewhat simple checksum (e.g.,
IPv4 [26]) is typically applied to the packet header to ensure correctness of message type
and source-destination delivery.
2.6 Voting Algorithm
In general, replicated data is an approach for providing fault tolerance in distributed
systems. The voting algorithm is a kind of consistency control algorithm for replicated
data objects in distributed computing systems [27, 28]. The main idea of voting is to
get a quorum of data to agree on an operation before commitment. The algorithm relies
on quorum computations to provide reliability.
In 1992, Blough [27] proposed a majority-voting algorithm. With the scheme, the
majority voting obtains a correct result if no more than of the redundant elements produce
a faulty result. In other words, up to faulty elements can be tolerated by this technique.
8
3.1 Failure Models
Due to the cost, strict energy constraints, and most sensor nodes in the system fail with
high probability. The faulty sensor nodes are arbitrary. For instance, they may send
incorrect data. As mentioned before, the faults are called Data inconsistent failures.
• Data inconsistent failures represent the faults that binary contents in packets are
modified while being processed inside sensor nodes. For example, if the data frame
1101011011 is encoded with a CRC code generator polynomial G(x)=x4+ x+1, its
transmitted frame should be 11010110111110. However, if the last bit of the original
data frame is changed to 0 before it is encoded and transmitted by the sender, the
frame by applying CRC code will become 11010110101101. The outcome will still
be considered as correct by the receiver. The data inconsistent failures could be
caused by noise interference, incorrect data processing, memory leakage, and so on.
The definition of data inconsistent failure is described as follows. Node N receives
a packet datapkt and then relays it. A failure occurs if the content of datapkt received
by node N is different from that transmitted by node N .
3.2 Assumptions
The report assume that the transceiver of the sink is fault-free. The source nodes may
collect incorrect data due to sensing failure. The problem can be solved by a value
fusion or a decision fusion [25]. The packet header ensures correctness of message type
and source address. Majority voting is used for error detection and correction of the
packet payload. Nodes crash failures in the report are not considered. The crash failures
10
Chapter 4
Overhearing-based Detection
Mechanism
An important feature of wireless communication is the data content of packets can be
overheard by all other nodes within the sender’s transmission range. Therefore, this
report employs such characteristic to develop a mechanism for detecting data inconsistent
failures in wireless sensor networks. When a sensing node detects an interested event, it
will immediately generate a data packet which includes (src, data, seq), where src, data,
and seq represent the sensing node′s id, sensed data, and sequence number respectively.
Figure 4.1 is an example shows how the source transmits the interested data to the sink
through multi-hop wireless communication. R represents the relaying nodes of a path
with packet transmission. R0 is the sources node and Rn represents the sink node. The
n represents the hop count of the path. The Ci set represents the committee set with Ri.
The nodes in Ci set can overhear the same packet sent by Ri and Ri+1. Each committee
node in Ci compares the interested data sent by Ri and Ri+1 with the same sequence
12
Figure 4.2: Example of overhearing phase.
tee nodes to the sender and the number of actual committee is used for voting algorithm
in the decision phase. Since the actual number of committee nodes may be less than num-
ber of nodes that regarded by the system. The Committee SELECT message contains
two fields: primary node id and tested node id. When receiving Committee SELECT
message, each committee node will record sender id and receiver id of a pair of link in
the overhearing table. The performance evaluation with varying number of committee
nodes is displayed in next chapter.
4.2 Overhearing Phase
When the committee nodes of set Ci receive Committee SELECT message, they know
which relaying nodes have to overhear and record these information in their own overhearing table.
Committee nodes will discard the overheard data packet which sender does not exist in
its overheard table. The overheard table indicates that itself belong to which committee
set. As shown in Figure 4.2, Ri and Ri+1 are adjacent intermediate nodes of a path. Ri
and committee nodes in set Ci overhear and compare every data packets between Ri and
Ri+1. Since the nodes of the Ci set are within the communication range of Ri, they can
14
overhearing nodes are that are failed to overhearing the transmitting packets caused by
the unreliable network transmission. When the collecting time is expired, the Ri activates
an Absolute Majority Voting (AMV) algorithm to make a decision by gathering voting
messages. There are three kinds of result in AMV: affirmative, negative, and invalid. If
the affirmative votes are more than half of the number of committees, the results in AMV
is affirmative. If the negative votes are more than half of the number of committees, the
results in AMV is negative. Otherwise, it is considered as invalid. Equation 4.1 to 4.4
describe rules of the AMV.
V = {Vj|Vj ∈ {δA, δN} ,∀j = 0 ... n} (4.1)
Aj =

1 , Vj = δA
0 ,otherwrise
(4.2)
Nj =

1 , Vj = δN
0 ,otherwrise
(4.3)
AMV (V, nci) =

Invalid , (max{∑Aj,∑Nj} < n2 ) ∨ (∑Aj = ∑Nj)
Affirmative , (
∑
Aj >
∑
Nj) ∧ (∑Aj ≥ n2 )
Negative , (
∑
Aj <
∑
Nj) ∧ (∑Aj ≥ n2 )
(4.4)
If the result of the absolute majority voting is affirmative, Ri does not need any
strategy since the committee node does not detect any failure. If the result of the absolute
majority voting is negative, it means the data inconsistent failure is detected by Ri. The
reactive strategy triggers Ri to notify the sink sending failure data message. The reliable
routing protocol with acknowledgement ensures the failure data message that can be
16
Definition:
pkt: a copies of packet.
hash(): a hash function with overhearing buffer
ovrhear table: A list of nodes’ id that this nodes need to overhear.
overhear buffer: is a packet buffer to save the overhear packet.
comparison( pkt1, pkt2): compares two packet data inconsistent failure.
COMMITTEE NODE
Node C receives a data packet overhear pkt by overheard;
if overhear pkt.sender ∃ overhearing table.primary id and overhear pkt.reciver ∃
overhearing table.tested id then
add data pkt to the overhear buffer;
endif
if data pkt.reciver ∃ overhearing table.tested id then
pkt=hash(data pkt.seq, data pkt.send id) in overhearing buffer;
if pkt != NULL then
if comparison( pkt,overhear pkt) then
send a affirmative voting message;
else
send a negative voting message;
endif
else
drop overhear pkt;
endif
else
drop overhear pkt;
endif
Figure 4.4: Algorithm for committee nodes.
18
Chapter 5
Performance Evaluation
5.1 Simulation Environment
Both the overhearing-based and two-path detection mechanisms are implemented and
composed using the network simulator 2 (NS2). The IEEE 802.11 DCF was selected
to be the MAC layer protocol of overhearing-based mechanism in the simulations. For
performance comparison, the two-path mechanism [23] and the routing protocol without
fault-tolerance are simulated. In each simulation, 200 nodes were randomly placed in
a 250m*250m sensor field. The transmission radius of each sensor node was fixed to
be 40 meters. The sink was randomly located in the field. Several failure arrival rates
were applied to assess the impacts on the performance of the detection mechanism. The
energy consumption for transmission, reception and standby were 660mW, 395mW, and
35mW per second, respectively. Each simulation ran for 300 seconds of simulation time.
Each data point presented was an average of seven simulation runs. The simulation
parameters were summarized in Table 5.1.
20
Table 5.2: Detected Rates with Varying Committee Nodes
# of committee nodes Detected Rate
1 97.02%
3 99.13%
5 99.81%
7 99.85%
the traffic generation used the Uniform distribution to randomly pick n sensor nodes as
the nodes who invoke the traffic. The traffic report rate was one packet per second.
5.4 Experimental Results
The following metrics were used to evaluate both the OBD and tow-path detection mech-
anisms.
• End-to-End delay: The average transmission time that the source nodes deliver all
the data packets to the sink node. The delay is determined by some factors, such as
buffering during route discovery, queuing at the interface queue and finding routing
paths between two node
• Total dissipated energy: The energy consumed by all nodes in the network during
the simulation.
• Detection latency: The time interval from the occurrence of a failure node until the
failure detected by the sink.
At first, it needed to investigate how many committee nodes in a committee set is
adequate. Table 5.2 shows the detected rate with varying number of committee nodes
in a committee set. The parameter of failure injection times is 30 seconds and traffic
duration is 20 second in this simulation. As it shows when the number of committee
22
Figure 5.1: End-to-end delay between source and sink.
the additional overhead of OBD mechanism. Two scenario, varying failures rates and
varying event arrival rate, were performed in simulation experiments.
5.4.1 With Varying Failure Rates
In this scenario, different failure injection time was simulated. When λd = 20, it means
that failures are injected every 20 seconds and so on. Other parameter settings are shown
in Table 5.3.
Table 5.4 shows the failure detection performance of the OBD mechanism and the
two-path detection mechanism with varying failure rates respectively. With the OBD
mechanism, more than 99.82% of the failures can be detected. When the failure rate
increased, the system remained in a similar success detection rate. The undetected
faults could occur when a half of committee nodes are failed and the overheard packets
24
Figure 5.3: Detection latency.
Figure 5.2 shows the energy consumption of both schemes. The two-path detection
mechanism required over 34.06% of extra energy dissipation. The OBD mechanism only
incurred about 22.84% of the extra energy. With the OBD mechanism, total energy
dissipation did not increase obviously with the higher data inconsistent failure rates.
The extra energy in OBD mechanism is caused by construction phase message, the voting
message and control message.
The detection latency of both mechanism was illustrated in Figure 5.3 The detection
latency represents how fast a failure can be detected. The OBD mechanism needs a
gathering time to collect voting messages, and this leads to a higher detection latency.
The OBD mechanism paid about 0.01 more second compared to the two-path detection
mechanism.
26
Table 5.5: Parameter Settings with Varying Traffic Load
Data Inconsistent Failure
Average Injection Time λd= 10 sec.
Mean Number of Failures/Injection µd=3
Standard Deviation σd=2
Duration for Transient Failures δd=20 sec.
Traffic Load
Scenario-1 λt=30 sec. Duration =10 sec.
Scenario-2 λt=30 sec. Duration =20 sec.
Scenario-3 λt=10 sec. Duration =10 sec.
Scenario-4 λt=10 sec. Duration =20 sec.
Mean Number of Traffic/Injection µt=2
Standard Deviation σt=1
Table 5.6: Average Hop Count with Varying Traffic Load
OBD Two-Path
Scenario-1 4.0 6.0
Scenario-2 3.8 5.5
Scenario-3 4.2 6.2
Scenario-4 4.8 6.5
mechanism, more than 99.83% of the failures were detected. When the failure rate
increased, the successful detection rate was almost the same. As it showed, the undetected
failures of OBD scheme were less than those of the two-path detection mechanism.
The end-to-end delay for both mechanisms with various traffic load was illustrated
in Figure 5.5. The OBD mechanism saved about 0.07 second compared to the two-path
mechanism. The two-path mechanism paid over 41.32% additional overhead while the
The OBD mechanism only paid about 9.01% additional overhead.
Figure 5.6 compares the energy consumption of both schemes. The OBD remained
steady with varying traffic load and required about 19.18% of the extra energy with
comparison to the original protocol. Two-path rapidly increased with varying traffic
load and required about 29.66% of the extra energy compared with original protocol.
28
Figure 5.5: End-to-end delay between source and sink.
Figure 5.6: Total energy consumption.
30
Chapter 6
Conclusion and Future Work
6.1 Conclusion
This report addressed the problem of the data inconsistent failures in the wireless sensor
networks. An overhearing-based detection mechanism was developed for recovering data
inconsistent failures. The scheme can be integrated with any on-demand unicast routing
protocol. Data packets are delivered by the original routing protocol. The committee
nodes examine the consistency of the data packets and send voting messages with com-
paring results. The primary node activates an absolute majority voting algorithm to
make a decision after receiving voting messages. The detection mechanism relies on both
the comparisons provided by the primary node and the voting results. If any failure is
detected, the upstream relaying node utilizes path maintenance mechanism of the routing
protocol to notify the sink. When the sink receives the failure notification, it will drop
the packet for avoiding wrong decisions. The data packets will not be delayed by the
detection mechanism.
32
and committee node can be updated regularly. The work can also be further extended to
fault diagnosis. When each committee node compares data packets, it records the count
of failures. If the count is larger than a predefined value, the node will be considered as
faulty and will be isolated from the rest of network.
34
[12] C. Y. Hsu and S. T. Wang, “Appointed BrOadcast (ABO): Reducing Routing Over-
head in IEEE 802.11 Mobile Ad Hoc Networks,” Tech. Rep. TR-IIS-04-017, Institute
of Information Science, Academia Sinica, Taiwan, Oct. 2004.
[13] W. Ye, J. Heidemann, and D. Estrin, “An Energy-efficient MAC Protocol for Wire-
less Sensor Networks,” Proceedings of the 21st International Annual Joint Conference
of the IEEE Computer and Communications Societies, pp. 1567–1576, June 2002.
[14] T. van Dam and K. Langendoen, “An adaptive energy-efficient MAC protocol for
wireless sensor networks,” Proceedings of the 1st International Conference on Em-
bedded Networked Sensor Systems, pp. 171–180, Nov. 2003.
[15] P. Basu and J. Redi, “Effect of overhearing transmissions on energy efficiency in
dense sensor networks,” Proceedings of the third international Symposium on Infor-
mation Processing in Sensor Networks, pp. 196–204, Apr. 2004.
[16] M. Tubaishat, J. Yin, B. Panja, and S. Madria, “A Secure Hierarchical Model for
Sensor Network,” ACM SIGMOD Record, vol. 33, no. 1, pp. 7–13, Mar. 2004.
[17] K. Sanzgiri, B. Dahill, B. Levine, and E. Belding-Royer, “A secure routing protocol
for ad hoc networks,” International Conference on Network Protocols, pp. 78–87,
Nov. 2002.
[18] G. Gupta and M. Younis, “Fault-Tolerant Clustering of Wireless Sensor Networks,”
IEEE Wireless Communications and Networking Conference, pp. 1579–1584, Mar.
2003.
[19] S. Chessa and P. Santi, “Crash Faults Identification in Wireless Sensor Networks,”
Computer Communication, vol. 25, no. 14, pp. 1273–1282, Sept. 2002.
[20] D. N. Jayasimha, “Fault Tolerance in Multi-Sensor Networks,” IEEE Transactions
on Reliability, vol. 45, no. 2, pp. 308–315, June 1996.
[21] S. Chessa and P. Santi, “Comparison-Based System-Level Fault Diagnosis in Ad Hoc
Networks,” Proceedings of 20th IEEE Symposium on Reliable Distributed Systems,
pp. 257–266, Oct. 2001.
[22] C. Intanagonwiwat, R. Govindan, D. Estrin, J. Heidemann, and F. Silva, “Directed
Diffusion for Wireless Sensor Networking,” ACM/IEEE Transactions on Networking,
vol. 11, no. 1, pp. 2–16, Feb. 2003.
[23] S.-K. Huang, “A Fault-tolerant Multipath Routing Protocol in Wireless Sensor Net-
works,” Master’s thesis, Department of Electrical Engineering, National Cheng Kung
University, 2004.
[24] D. L. Hall, Mathematical Techniques in Multisensor Data Fusion. Artech House,
1992.
[25] T. Clouqueur, K. K. Saluja, and P. Ramanathan, “Fault Tolerance in Collaborative
Sensor Networks for Target Detection,” IEEE Transactions on Computers, vol. 53,
no. 3, pp. 320–333, Mar. 2004.
36
研究成果自評 
1. 順利研發容錯與安全的偵測模式，發展完整的無線網路繞路機制，並完成詳
細的系統效能評估。 
2. 無線感測網路的實際平台 (Tmote sky sensors) 建置完成。 
3. 部分計畫研究成果已刊登於著名國際期刊與會議。 
 
發表學術論文 
國際期刊論文: 
1. K. F. Ssu, C. H. Chou, L. W. Cheng, “Using Overhearing Technique to Detect 
Malicious Packet-Modifying Attacks in Wireless Sensor Networks,” Computer 
Communications, vol. 30, no. 11-12, pp. 2342-2352, Sept. 2007.  
2. C. H. Yang, K. F. Ssu, F. K. Wu, “A Comment on Variable-Range Transmission 
Power Control in Wireless Ad Hoc Networks,” IEEE Transactions on Mobile 
Computing, vol. 6, no. 10. pp. 1199, Oct. 2007.  
3. K. F. Ssu, C. H. Chou, W. T. Wang, S. H. Chung, “Improving Data 
Transmission with Helping Nodes for Geographical Ad Hoc Routing,” Computer 
Networks, vol. 51, no. 18, pp. 4997-5010, Dec. 2007.  
4. C. H. Chou, K. F. Ssu, H. C. Jiau, “Dynamic Route Maintenance for Geographic 
Forwarding in Mobile Ad Hoc Networks,” Computer Networks, vol. 52, no. 2, 
pp. 418-431, Feb. 2008.  
5. C. H. Chou, K. F. Ssu, H. C. Jiau, “Geographic Forwarding with Dead-End 
Reduction in Mobile Ad Hoc Networks,” IEEE Transactions on Vehicular 
Technology, vol. 57, no. 4, pp. 2375-2386, July 2008.  
6. C. H. Ou, K. F. Ssu, “Sensor Position Determination with Flying Anchors in 
Three-Dimensional Wireless Sensor Networks,” IEEE Transactions on Mobile 
Computing, vol. 7, no. 9, pp. 1084-1097, Sept. 2008.  
7. C. H. Wang, C. C. Lee, H. C. Jiau, T. L. Yang, K. F. Ssu, P. C. Chung, 
“Tele-Consultation Enhanced via Session Retrieval and Session Scheduling 
Capabilities,” Accepted for publication in Journal of Information Science and 
Engineering. 
國際會議論文: 
1. T. T. Wu, K. F. Ssu, H. C. Jiau, “Two-Way Coverage Mechanism for Wireless 
Sensor Networks,” Proceedings the IEEE International Symposium on Personal, 
Indoor and Mobile Radio Communications, Sept. 2006.  
行政院國家科學委員會補助國內研究生出席國際學術會議報告 
                                                            2008 年  6 月  23 日 
報告人姓名  
郭宏恩 
 
就讀校院 
（科系所）
                     □博士班研究生 
國立成功大學電腦與通信工程研究所 
                     ■碩士班研究生 
     時間 
會議 
     地點 
2008/06/11 至 2008/06/13 
 
日本東京 未來館 
本會核定 
補助文號 
NSC 95-2221-E-006-092-MY2 
會議 
名稱 
 (中文) 第四屆國際行動計算與無所不在網路會議 
 (英文) The Fourth International Conference on Mobile Computing and 
Ubiquitous Networking (ICMU 2008) 
發表 
論文 
題目 
 (中文) 在指向性感測網路中使用目標視景分群演算法解決多重覆蓋問題 
 (英文) Using Target-View Clustering Algorithm to Solve Target Multi-Coverage
Problem in Directional Sensor Networks 
報告內容應包括下列各項： 
一、參加會議經過 
國際行動計算與無所不在網路會議(International Conference on Mobile Computing and 
Ubiquitous Network, ICMU) 是由日本資訊處理協會(Information Processing Society of 
Japan, IPSJ)所主辦，為資訊網路與行動計算的研究學者、以及產業界相關研究人員提供國
際交流平台，以及各類通訊網路之最新穎科技的研究討論。 
ICMU 今年於 2008 年 6 月 11 日至 2008 年 6 月 13 日舉辦第四屆，地點位在日本東京的未
來館，該館本身即是用來展出各種未來科技的大型展覽館，因此更替 ICMU 會議增添了不少顏
色。今年總共有 65 篇來自各國的論文投稿，只有 19 篇完整論文及 6篇短論文被接受，每篇
論文皆經過兩位以上的匿名審查，雖然選出的篇數不多，但與會者皆能參與所有被接受論文
的討論，不致錯過任何一項會議議題，使得討論能更為凝聚。選出的論文被分成八個 sessions
來討論，主題包括：Radio System, Application network, Security, Ad-hoc network, 
Wireless LAN, Sensor network。 
在會議開始的前一天我抵達會場所在地：東京的台場(日本東京灣內一座以填海造陸方式
製造出來的巨大人工島)，第一天早上即準時出席會議，而我所投稿的論文被分在第二天的
Sensor network session。總共三天的會期中，每天早上都有一場Keynote speech，邀請一
位知名研究者或學者做為整天的開場。第一天早上的主題是關於Seamless Network Access 
Security in Heterogeneous Networks，演講者是Telcordia Technologies, Inc.的Dr. Subir 
Das，他不僅是多個國際會議的TCP member，也主導多個IEEE協定並身為目前IEEE 802.21: 
Media Independent Handover Services working group的Vice-Chair，在他的演講中介紹了
非常多種目前各類型的行動網路，以及在不同網路之間如何達到Seamless network access 
security的重要議題。第二天則是由DoCoMo Communications Laboratories Europe GmbH的
Dr. Hendrik Berndt所演講，身為DoCoMo Communications Laboratories in Europe的Chief 
Technology Officer and Senior Vice-President，自 2000 年以來被邀請為日本早稲田大學
(1) ICMU 舉行場地─未來館 
 
 
(2) 會議場地七樓的中庭及指示牌 
 
 
 
 
 
 
 
 
(4) 本人報告當時的照片 
 
 
 
 
the schedule to all members.
TVCA not only decreases the number of active sensors, but
prolongs the network lifetime in three aspects, alleviating the
load of cluster head, adapting variations in cluster range, and
reducing the transmission overhead while forwarding sensed
data to the sink.
First of all, TVCA is a heuristic algorithm using the target-
view concept instead of the traditional sensor-view, and it has
low computing complexity. The computing process of TVCA
is not a heavy load to the cluster head. Besides, the task of
cluster head will be transferred to the other sensor with the
most energy round by round.
Second, the big network is segmented into small clusters
with adjustable cluster size by a user determined parameter,
giving very well scalability to adapt coverage variation. Even
if any sensor (including cluster head) fails, the effect could
be limited in cluster range. On the other hand, to reduce
the overhead of cluster structure maintenance, we assume that
sensors are deployed to fixed location. After deployment sen-
sors could communicate with their neighbors in stable con-
nections without location moving. Cluster structure changes
only when sensor depletes its energy, and target moves out the
cluster range.
Third, data aggregation [7] mechanisms could be applied
to TVCA. Sensors near the detected target may individually
transmit the same sensed data to sink so the power is wasted.
In TVCA, all the sensed data could be gathered to the clus-
ter head, merged as needed, and then forwarded to the sink in
an energy-efficient way. Simulation result shows that TVCA
with GPSR [8] successfully reduced more than half transmis-
sion packets.
2 RELATED WORK
The coverage problems, models, and approaches with dif-
ferent objectives using the iso-
tropic sensing model have been discussed comprehensively [9–
11]. The MINIMUM COVER problem looks for the mini-
mum collection of sets to cover all elements [12]. The MAXI-
MUM COVER problem releases the full coverage to the max-
imum coverage of all elements [13]. Based on the SET K-
COVER problem [3] for area coverage, Cardei at al. address
the Disjoint Set Covers (DSC) problem for point coverage,
proved to be NP-Complete, and a corollary for k-DSC [14].
The objective is to find the maximum disjoint set covers. A
disjoint set cover represents a set of active sensors that de-
plete energy in one covering interval. The more disjoint set
covers exist, the more network operation time is needed. The
DSC can be transformed into a maximum-flow problem, for-
mulated as a mixed integer programming.
The DSC problem is derived to the maximum set covers
(MSC) problem [4]. Cardei at al. release the disjoint set re-
striction and allow sensors to operate for different time inter-
vals. Three centralized approaches are proposed, including an
integer linear programming approach, a heuristic linear pro-
gramming approach, and a greedy approach. This work con-
cludes centralized solutions.
2
s1 v1,1
t2
1
t1
1
t3
3
t4
2
t5
v1,2
v1,3
v1,4
v1,5
v1,6
v1,7
v1,8
Figure 2: The directional sensing model with eight switchable
directions.
Recently, the directional sensing model is taken notice to
solve the point coverage problems. Ai and Abouzeid intro-
duced directional sensors for target coverage [6]. A central-
ized integer linear programming solution and a distributed
greedy algorithm (DGA) were proposed. DGA uses only 1-
hop neighbor information for each sensor, with the assump-
tion that communication range is twice the sensing range.
With DGA, sensors orderly switch their disjoint sensing field
to cover the most targets, by their local information. DGA
also provides an energy-efficient protocol, SNCS, by assign-
ing the residual energy as the priority to extend the network
lifetime. SNCS could not preserve the robustness due to the
localization errors and orientation errors.
Another work by Cai et al. focused on the multiple di-
rectional cover set problem (MDCS)that organizes the sen-
sors into non-disjoint sets [5]. Three centralized algorithms
were proposed as a linear mixed integer programming solu-
tion, a progressive and prog-resd algorithm, and a feedback
algorithm. Sensors could operate for different time interval
with different directions. Considering that targets may not
be covered for a while during switching directions, the feed-
back algorithm reduces the number of cover sets by only K
iterations. However, the schedule is pre-computed without
consideration of network variation afterwards.
3 TARGET MULTI-COVERAGE (TMC)
PROBLEM
The directional sensor network model and notations used in
the paper are described. The TMC problem is then formally
defined and proved to be NP-Complete.
3.1 Directional Sensor Network Model
A directional sensor network has M targets and N sensors.
As illustrated in Figure 2, a sensor or a node j (1 ≤ j ≤ N) is
defined as sj , located at (xsj , ysj ) with fixed sensing range rj
and a fixed sensing angle θj that forms the region of sensing
field or view. A target i (1 ≤ i ≤M) is defined as ti, located
at (xti , yti) and classified to coverage level ki by application.
We denote the set of sensors S = {s1, s2, ..., sN}, the set
of targets T = {t1, t2, ..., tM}, and the set of multi-coverage
K = {k1, k2, ..., kM}. Sensors are assumed to know their
2
2
2
(a) Normal Condition
(b) Critical Condition
(c) Unsatisfied Condition
Figure 3: Three kinds of target condition.
ter. Targets must orderly do view-selection (in fact this is
performed by cluster head). Each target has its unique pri-
ority, based on the condition itself. The highest priority target
can firstly perform view-selection.
For target ti classified into multi-coverage ki, there are
three kinds of target conditions as illustrated in Figure 3:
4.2.1 Normal condition
The number of selectable sensors, namely that sensors has
not been occupied by any targets, is bigger than ki. Normal
targets have the lowest priority for view-selection, because
they still have redundant selectable sensors.
4.2.2 Critical condition
The number of selectable sensors is the same as ki. Critical
targets have the highest priority because losing any selectable
sensor will result to decreasing of complete coverage.
4.2.3 Unsatisfied condition
No matter how ti selects, it has no chance to be complete cov-
ered. Unsatisfied targets are prior to normal targets. Note that
targets with no more selectable sensors are directly removed
in the view-selection.
Target priority is briefly classified into these three condi-
tions, and targets in the same condition is further compared
by four sub-condition. If the first sub-condition does not dif-
ferentiate, then the second sub-condition is taken into com-
parison, and so on, until all targets have their unique priority.
• Priority in critical condition: Highest priority for
minimum ki;
⇒minimum ϕi (number of selected sensor);
⇒maximum number of targets∈ NTi;
⇒maximum i.
Target with minimum ki has the highest priority be-
cause the complete coverage is directly increased after
selection.
• Priority in unsatisfied and normal condition: Highest
priority for
maximum ki;
⇒minimum ϕi;
⇒maximum number of targets∈ NTi;
⇒maximum i.
Target with maximum ki has the highest priority be-
cause higher coverage level is more important to appli-
cation.
The next step for the highest priority target is to select one
view vj,hwith the greatest benefit. Similarly, the benefit is
compared by a series of condition, listed orderly as follows:
• The view has greatest benefit for
maximum number of critical targets∈ vj,h;
⇒maximum number of unsatisfied targets∈ vj,h;
⇒maximum number of normal targets∈ vj,h;
⇒maximum number of crossing-edges;
⇒maximum residual energy of sj ;
⇒maximum j.
Crossing-edges is the edges connected between vj,h and
vj,h in the connected graph, generally represents the
target density.
In every iteration only one target does the view-selection
that select one view. After selection, all sensors and targets
refresh their status, and continue for the next iteration, until
all targets finish their selection.
5 TARGET-VIEW CLUSTERING
ALGORITHM (TVCA)
TVCA has three phases addressed in this section. Com-
bined with target-view concept of view-selection, TVCA as-
sumes that the network is connected in the beginning for any
two sensors if they have a same neighbor target. Sensors must
know their locations and target information (e.g., location and
coverage level) in the sensing range.
5.1 Phase 0: Initialization
Sensors are deployed to the area. As network is connected,
sensors could contact the sink to get information about loca-
tions and targets existence in its sensing region. Sensors may
also scan around to find other environment information and
make stable connections with neighbor sensors to know NSt
of all their neighbor targets.
5.2 Phase 1: Clustering
Once D is broadcasted to the network, all sensors start the
target-view clustering with a timer for overlap handling. Sen-
sors could easily find if they belong to overlapped clusters. If
it happens, send a short overlap message to 1-hop neighbor
sensors. After time expiries, the overlapped sensors orderly
decides which cluster to joint by the priority of ID, and broad-
casts the decision to its 1-hop neighbor sensors. The decision
rule for each overlapped sensor is joining the cluster with the
nearest critical target, or the nearest cluster when there is no
critical neighbor targets. This decision rule is used here be-
cause it is the simplest way for sensors without any commu-
nication overhead. Sensors would definitely know which sen-
sors and targets are in the same cluster, while the highest ID
sensor is appointed to be the cluster head in this round.
0
20
40
60
80
100
120
140
160
0 50 100 150 200 250 300 350 400
Number of Sensors
(a)
N
u
m
b
e
r
 
o
f
 
A
c
t
i
v
e
 
S
e
n
s
o
r
s
TVCA (D=50)
TVCA (D=75)
TVCA (D=100)
TVCA (D=1000)
DGA
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0 50 100 150 200 250 300 350 400
Number of Sensors
(b)
T
h
e
 
R
a
t
i
o
 
o
f
 
C
o
m
p
l
e
t
e
 
C
o
v
e
r
a
g
e
TVCA (D=50)
TVCA (D=75)
TVCA (D=100)
TVCA (D=1000)
DGA
Figure 5: Using TVCA (with different D values) and DGA to
solve target 1-coverage problem.
When target moves or new target appears, it may cause two
or more different clusters to be merged when it locates on
the cluster border. Sensors near new joined target must ex-
change information with each other. If combination is needed,
all sensors in these clusters refresh their sensing table, and
send it to the new cluster head with the highest ID in the new
round. Contrarily, sensors rerun phase 2 with no cluster struc-
ture variation.
Due to sensor fails, in-cluster partition may occurs. Sensors
would not be able to connect with the cluster head, even the
cluster head itself may fails. Those survived sensors must
form another cluster and find the sensor with the highest ID
to take over the task of cluster head.
Moreover, if user adjusts cluster range D, then D is broad-
casted from sink, making all the sensors restarting from phase
1 to form new clusters.
6 SIMULATION RESULTS
Simulations were built using C++, and TVCA were com-
pared to DGA [6], a distributed greedy algorithm that sensors
select the view with the most number of targets. Sensors and
targets were randomly, uniformly distributed in a 1000×1000
region. Multi-coverage levels were random numbers between
1 and 3. We implemented 6 directional sensing models of dif-
ferent θ and P , but only the sensing model with θ = pi4 , P = 8
is showed in this section.
In experiment 1, we would like to compare the performance
0
50
100
150
200
250
300
0 50 100 150 200 250 300 350 400
Number of Sensors
(a)
N
u
m
b
e
r
 
o
f
 
A
c
t
i
v
e
 
S
e
n
s
o
r
s
TVCA (D=75)
TVCA (D=1000)
DGA
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0 50 100 150 200 250 300 350 400
Number of Sensors
(b)
T
h
e
 
R
a
t
i
o
 
o
f
 
C
o
m
p
l
e
t
e
 
C
o
v
e
r
a
g
e
TVCA (D=75)
TVCA (D=1000)
DGA
Figure 6: Using TVCA and DGA to solve TMC problem.
between TVCA and DGA, and to evaluate the effect of ad-
justing the cluster range parameter D. The sensing range was
fixed to 100, and the communication range was fixed to 200.
This model was also used in the following experiments. D
was fixed to 50, 75, 100, and 1000. D=1000 represents TVCA
without clustering, that is, a centralized version.
In Figure 5, there were 200 targets with only 1-coverage
deployed in the area, as the special case of multi-coverage.
The number of deployed sensors N were 10 to 400. The ra-
tio of complete coverage is the number of complete covered
targets divided by number of targets M . DGA achieved a
little more complete coverage for N <80, but when N in-
creased, TVCA used fewer sensors to achieve more coverage
than DGA. While N =400, TVCA used about 109 sensors to
achieve full coverage for D=75, 100, and 1000, whereas DGA
used 135 active sensors. TVCA with D=50 achieved less cov-
erage than the others because the D value was too small that
divided the network into too much 1-target-clusters, resulting
too many cluster overlapped sensors to decide which cluster
to joint. Contrarily, TVCA with D=1000 generated too much
control overhead in the network, reinforcing too much load to
the cluster head. The D value is a trade off, depending on the
density of deployed targets.
In Figure 6, targets were replaced by multi-coverage, but
400 sensors were not enough to achieve full coverage of 200
multi-coverage targets. When N =400, TVCA activated 221
sensors and achieved 97.5% complete coverage, whereas DGA
activated 252 sensors achieving only 94% coverage. In the
situation with lack of sensors, DGA activated more sensors
