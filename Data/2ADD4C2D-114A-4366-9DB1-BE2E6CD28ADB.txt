 2 
摘 要 
 
普適計算的進展帶來許多相關普適應用的快速發展，如智慧生活、老人照護
與農業發展等。情境感知的中介軟體技術更進一步提供了改善普適應用服務品
質。本篇論文提出一個適用於廣泛普適應用的模型以及結合工作流程管理系統的
執行框架。藉由此普適應用模型以及執行框架的分層式方法，本論文亦提出一個
發展普適應用方法論。此方法論包含資料模型及發展的工作流程並預期將減少應
用設計者發展普適應用的困難度。最後，一個普適醫療照護應用的例子說明了普
適應用使用工作流程技術的必要性，並且運用提出的方法論來設計此普適醫療照
護應用來證實此方法論的可行性。 
 
關鍵字：普適計算、工作流程管理系統、普適工作流程、普適應用。 
 
 4 
1 Introduction 
 
1993, M. Weiser gave the first ideology about pervasive/ubiquitous computing, and 
indicated the vision about “computing anywhere” [6]. Weiser stressed that the 
computation resources would no longer be bound on mainframes, work stations and 
even personal computers, but can be accessed all around the environments. Recently, 
many pervasive applications [3][8][9][19][17][20][10][19][35][36] [37][38][39] have 
been developed and each has its own characteristics. This report summarizes these 
characteristics across several application domains, such as smart living [8][19], 
pervasive healthcare including geriatrics care [9][20][35][36][37][38][39], agricultural 
development [10], and so forth. A generic pervasive application is aware of the 
environment and utilizes its computing resources with better quality. The 
characteristics of environment-aware/context-aware and utilization of heterogeneous 
resources/services are the typical factors to complicate the development of pervasive 
applications.  
 
In order to overcome these difficulties, a generic pervasive application model, based 
on the combination of essential components, maybe applied during the development. 
In this report, we present a model composed of three main components: (1) Context 
model with reasoning rules, (2) Process/workflow schema, and (3) Required services. 
The model can describe the scenarios of a pervasive system. 
 
On the other hand, the technologies, like context-sensitive middleware [4][5][29][30], 
providing the infrastructure for pervasive applications, can help to improve service 
qualities of pervasive applications. Based on our pervasive application model, this 
report also presents an execution framework for handling the designed applications. 
The framework comprises: (1) Context management system (CMS), (2) Workflow 
management system (WfMS) [12], and (3) Service management system (SMS). The 
applications among these systems provide pervasive applications an efficient 
middleware layer to access the pervasive environment. For example, CMS is in 
charge of acquiring and deducing the sensed context raw data to semantic situations, 
and then pushing events to WfMS. WfMS executes correspondent handling-processes 
when receiving events from CMS. The accessing of pervasive environment is through 
SMS. 
 
Besides, this report presents a general methodology, containing a basic data model 
and a development workflow, to develop pervasive applications based on the 
pervasive application model and execution framework. In the methodology, the 
 6 
2 Background 
 
The advanced technologies have introduced the computerization of all the electronic 
devices and connect them in a network. Heterogeneous services satisfying needs of 
people thus collaborate to offer a better quality of the daily life. This Section surveys 
existing pervasive applications and summarizes their characteristics in Sections 2.1. 
Besides, the existing pervasive systems or solutions are presented in section 2.3. We 
will discuss challenges from summarized characteristics of pervasive applications and 
the deficiencies of the current related work. In Section 2.4, the advantages of applying 
workflow into pervasive computing are presented. Our work attempts to provide a 
more complete architecture combining context model and workflow with required 
services to develop pervasive applications. 
 
2.1 Pervasive Applications 
2.1.1 A Survey of Pervasive Applications 
 
Recent years, more and more pervasive applications are developed, such as 
applications in smart living [8][19], pervasive healthcare including geriatrics care 
[9][20][35][36][37][38][39],agricultural development [10], and so forth. This section 
gives a survey and briefly introduces these applications. 
 
In case of smart living, the sensors or context providers are separated around the 
living environments to collect contexts. The contexts collected are about the 
household information and human behaviors such as moving, exercising, and 
entertaining around the living environments. Besides, the user’s preference also serves 
as another source of context. Through pre-defined rule, the pervasive application may 
automatically react to contexts such as tuning the illumination or purchasing daily 
commodities through the internet. 
 
Javier Cubo presents a smart living scenario called “Buying and Selling System” [19]. 
This system enables users to purchase tickets or make reservation of a hotel or a 
restaurant through handheld devices. The system collects the user’s ID, and service 
status to generate a workflow to complete the user’s purchasing mission. COCOA [3] 
also presents a smart living scenario: the e-movie application about anyone, anywhere, 
and anytime to access a movie. The e-movie application has a workflow performing a 
sequence of tasks such as display-searching, stream-downloading, and 
 8 
the exhibition to PDA through the wireless connection.  
 
2.1.2 Characteristics of Pervasive Applications 
 
Based on the above survey, our observation of several characteristics relevant to 
pervasive applications are as following: 
(1) In order to gather the raw data of environment information, a pervasive 
application utilizes the sensors/context providers, might be distributed or 
centralized around the environment. 
(2) After gathering the raw data of environment information, a pervasive 
application has its reasoning mechanism to understand the semantic meaning 
of these raw context data and takes correspondent actions.  
(3) A pervasive application might have several kinds of processes combined with 
a serious of activities such as a scheduling and serving of patient’s daily work, 
a patient’s physical status monitoring process, and an emergency handling 
process in the geriatric healthcare application.  
(4) For all kinds of process, the handling process for context change in pervasive 
applications might be trivial or complex. 
(5)  The core feature of pervasive applications is to utilize the ubiquitous 
services around the environment. Unfortunately, these services contained by 
devices or hardware resources might have heterogeneous interface and might 
be unknown in advance.  
These summarized characteristics above are the crucial concerned to develop a 
pervasive application. This work attempts to generalize all the factors affecting the 
development of pervasive applications. The next section discusses the existing 
development techniques of pervasive systems.  
 
2.2 Development Techniques for Pervasive Systems 
 
CoCA [4] is a platform combing a pervasive environment, GCoM modeling (a context 
model [16]), and CoCA services (context-aware services) for execution of pervasive 
applications. CoCA uses a Rule-Constraint-Action (RCA) engine to response the 
environment change and to enact corresponding service. The scenario in CoCA [4] is 
to assist people’s devices in the campus to intelligently react to the change of 
 10
 
2.3 Pervasive System with Workflow  
2.3.1 Workflow 
 
Workflow Management Coalition (WFMC) define a workflow as: “The automation of 
a business process, in whole or part, during which documents, information or tasks 
are passed from one participant to another for action, according to a set of 
procedural rules [12].” In addition, WFMC also defines the Workflow Management 
System (WfMS) as: “A System that defines, creates and manages the execution of 
workflows through the use of software, running on one or more workflow engines, 
which is able to interpret the process definition, interact with workflow participant 
and, where required, invoke the use of IT tools and application [12].”  
 
The benefits of Workflow are summarized as: 
(1) The management of resources allows dynamic task assignment. 
(2) Workflow allows human actor to perform actions that push forward the state 
of process. 
(3) The delegation of a task to a role increases the responsibility 
(4) Workflow complies with required services and regulatory requisites, hence 
accomplishing results by implementing well-made processes. 
 
2.3.2 The Advantage of Applying Workflow into Pervasive Environment 
 
Most pervasive applications are involved of complex processes divided into a number 
of smaller tasks. After interaction with the environment, pervasive applications are 
aware of the services the environment supports. Hence, using workflow can 
successfully describe the tasks in advance, and allow integrating/composing the 
available service during run time. In addition, the benefits of workflow in Section 
2.4.1 also fit the applying workflow into pervasive environment. These advantages are 
discussed as: 
 
(1) Workflow enforces the order constraint and specifies the transition rules 
among tasks. Hence, the application developers can plan workflows 
 12
as heart beating, blood pressure etc. Video sensors are deployed in living room to 
capture his motions. The patient’s handheld monitors the information collecting by 
sensors. The handheld warns the care center through telephone when any emergency. 
All the devices are connected by wireless network.  
Suddenly, the patient feels discomfort due to headache. The wearable sensors detects 
the blood pressure of this patient is Diastolic = 155 mm hg & Systolic = 99mm hg. 
The video sensors capture the patient’s posture is falling. The handheld identifies the 
patient is on the morbidity of hypertension. As a consequence, a warning message 
with vibration of handheld is triggered, and intermediately transmits the physiological 
data from wearable sensors to care center. Through professional judgment, the care 
canter confirms the patient is under an emergency status. Hence, a sequence of 
activities is performed: (1) Inform the physician and transmit relevant medical history, 
(2) Inform care provider to send ambulance, and (3) Inform Hospital to prepare 
correspondent handling process… 
 
In this scenario, pervasive healthcare including geriatrics care has highlighted the 
need of applying the workflow techniques into pervasive systems. Workflow 
technique is able to represent the pervasive healthcare monitoring process involving a 
sequence of activities associated with many participants. In Section 4, we will explain 
how to design a pervasive healthcare application based on our system architecture.  
 
3 A Pervasive Application Model and an Execution Framework  
 
On account of the characteristics of pervasive computing discussed in Section 2, there 
are some challenges for the developers to build the pervasive applications. For 
example, a better expressive model reduces the efforts of recognition for the 
environment; an efficient approach describes the complex process/workflows 
performing a sequence of tasks, and a mechanism acquires/accesses ubiquitous 
services that the surrounding provides during run time. In order to reduce these 
difficulties, our observation indicates three fundamental components regarding to 
developing pervasive applications. A pervasive application model with necessary 
components and their detailed formats is presented in Section 3.1. And to separate the 
design issues from run time, a framework supporting the execution environment is 
proposed in Section 3.2. An activity diagram and collaboration diagram illustrating 
the operation of the execution framework is presented in Section 3.3.  
 
3.1 The Necessary Components in Pervasive Applications 
 
 14
and so on) in an application. The above relationship among tasks is regarded 
as business processes (or processes) in an application. During run time, the 
pervasive system instantiates correspondent handling processes based on the 
current status of environment. Hence, the process schema is the second 
necessary component to develop a pervasive application. Section 3.1.2 gives 
a detailed explanation of our process schema approach. 
 
3. Required Services. The service description details the interaction between a 
task and its required services, whereas the above process schema indicates 
the execution logic among all tasks. However, the developers might not 
anticipate all run-time available services, and therefore the developers 
describe required services in an abstraction manner. A platform-independent 
service description, thus, is the third necessary component to develop a 
pervasive application. Section 3.1.3 gives a detailed explanation of our 
required service description approach. 
 
 
 
 
Figure 3 A Generic Model to Develop Pervasive Applications 
 
With the three fundamental components, a generic model to build pervasive 
 16
Through Dey’s definition and the observation of pervasive application in Section 2, 
we conclude a skeleton of context model:  
 
1. Basic Entities: 
• Location (indoor space or outdoor space) 
• Individual (person or non-person). 
• Activity (scheduled activity or a deduced situation) 
• Service (context providers, devices, network ) 
 
2. Properties/Relationships among the Above Entities: 
• Individual, Activity, and Service must be located in a Location.  
• In some location, Individual is engaged in some Activity 
utilizing Services that environment supports.  
 
Hence, Figure 4 illustrates the generic ontology in our upper-level context model base 
on the above skeleton: 
 
Figure 4 The Upper-Level Context Model of Class Hierarchy Diagram 
 
The Location entity, comprising indoor space and outdoor space, covers most 
location information of pervasive applications. The Individual entity, including person 
 18
 
Figure 5 The Two-Level Hierarchical Context Model 
 
3.1.1.2 RDF Reification 
 
 The OWL ontology can be mapped into RDF graph that is a collection of RDF 
triples. Each RDF triple is a statement containing three parts: (1) subject, (2) object, 
and (3) predicate. The statement can be described and recorded by RDF reification 
using the RDF/XML syntax specification. According to W3C, RDF reification 
vocabulary consists of the type rdf:statement, and the properties rdf:subject, 
rdf:predicate, and rdf:object. The following example explains the RDF reification. 
 
 20
        </rdfs:subClassOf> 
    </owl:Class> … 
<Person rdf:ID=”Steven”>       
    <Holds> 
            <PDA rdf:ID=”PDA_no.1”> 
   … 
    </Holds> 
    <LocatedIn> 
    <Location rdf:ID=”NCTULibrary”> 
    </LocatedIn> 
<EngagedIn> 
        <Activity rdf:ID=”ReadMail”> 
       … 
</EngagedIn> 
</Person> 
 
 
3.1.1.3 Context Reasoning  
 
In this section, we describe how context model captures and perceives the pervasive 
environment. The direct acquisition of context from the environment contains the raw 
data that only represents the low-level information (such as location, sound, video 
pictures and so on.) In order to identify the high level status of a context entity, a 
mechanism called context-reasoning is required to extract more useful information 
from these raw data of context.  
 
The context-reasoning performs two major categories of tasks that are discussed in the 
following: (1) Ontology-reasoning employs description logic (2) Developer-defined 
rule reasoning utilizes first-order logic.  
 
(1) Ontology Reasoning 
 
Web Ontology Language (OWL) is W3C recommendation to makes use of web 
standards to represents information with RDF/XML schema. OWL is based on 
Description logic (DL) that specifies the hierarchy of terminologies by means of a 
restricted set of first-order formulas. Hence, the equivalence of OWL and 
Description logic (DL) supports the use of existing DL business segment for class 
 22
<LocatedIn> 
      <Location rdf:ID=”NCTU Campus”> 
        </LocatedIn> … 
 
(2) Developer-Defined Rule Reasoning 
 
 Developer-Defined Rule offers the more flexible approach for the designers to 
perform context-reasoning suitable for their applications. In the design phase of an 
application, the developers can define their reasoning rules in conformity with the 
format of first-order logic. During the running phase, exploiting these 
developer-defined rules, the CMS deduces the high-level status contexts from the 
raw data of contexts gathered by the sensors/context providers. The following 
examples illustrate the reasoning by developer-defined rules: 
 
Status of user ?u  Rules 
Sleeping (?u locatedIn Bedroom) ^ (SmartBed 
PressureLevel High) ^ (Bedroom LightLevel 
Low) 
Watching TV (?u locatedIn ?l) ^ (?TV locatedIn ?l) ^ (?TV 
Status On) 
Cooking (?u locatedIn Kitchen) ^ (?SmatOven locatedIn 
Kitchen) ^ (?SmartOven Status On) 
Table 2 The Defined Rule Reasoning Example 
3.1.2 Process Schema and Required Service  
3.1.2.1 Process 
  
The process specification is used to navigate tasks that make up an application. The 
execution of a process during run time is viewed as a workflow. The operational 
language we use to express the process is by BPMN [43]. The structured activities 
defined by BPMN, including sequence, flow, switch, while, and so on, can represent 
the relationship among tasks in the design time of an application.  
 
The developers cannot anticipate all the run-time available services for the tasks in an 
application. Hence, the process specification needs the extra description to record the 
required services. The adopted method is by adding the semantic annotations 
associated to a process to mark up the used service during run time. The next section 
 24
 
Figure 8 The Service Matching Using OWL-S during Rum Time 
 
In Figure 8 the service management system (SMS) is designed to administrate the 
services that service providers advertize and the processes require during run time. 
The service management system is one sub-system of our framework supporting the 
execution environment of pervasive applications (shown in Section 3.4).  
 
The following example in Figure 9 shows how the developers specify a process and 
its required service descriptions. The upper-part of Figure 9 is an example of process.  
In this report, we use BPMN to model the processes in an application, and BPMN can 
translate into BPEL for execution. In the lower-part of 錯誤! 找不到參照來源。, 
Process.bpel denotes the correspondent BPEL representation, and 
RequiredService.xml is associated to the process in order to mark up the used services 
during run time.  
 
 26
The framework consists of three major sub-systems corresponding to the three 
requirements in Section 3.1: (1) Context management system (CMS), (2) Workflow 
management system (WMS), and (3) Service management system (SMS).  
 
In order to adapt the diverse environments, our framework adopts the concept of 
service-oriented architecture (SOA). The framework only preserves the necessary 
components. Taking the function of data-storage for example, it is often resource 
hungry but widely used by most components. As a result, our framework encapsulates 
the function of data-storage into the repository service that is provided according to 
environments. Since CMS and WMS require accessing the context model data, rules 
and process patterns frequently, the decoupling of data storage into service also 
minimizes the loading of the framework. Other encapsulated services, such as 
computation resources, reasoning modules, and devices, also follow the principle of 
SOA and the other components in the framework can easily access these wrapped 
services provided from the third parties in the various pervasive surroundings. 
 
 
Figure 10 A Framework Supporting the Execution of Pervasive Applications 
 
The following explains the three sub-systems in our framework: 
(1) Context Management System (CMS): 
The CMS comprises three major components: (1) Context capturer, (2) 
 28
dynamically invoke the service in the pervasive environment. The SMS in our 
framework can also use these systems to achieve the run-time invocation of 
services within a BPEL workflow. 
 
3.3 The Communication Mechanism inside the Execution Framework 
 
Figure 11 illustrates the activity diagram with relevant to the execution framework 
presented in Section 3. Since three elements built must be running upon the execution 
framework, we use the activity diagram of execution framework to interpret the 
details of invocation and flows.  
 
 
Figure 11 An Activity Diagram of the Execution Framework 
 
When a pervasive application starts, it activates the primary process and context 
gathering processes. The primary process is executing on the WfMS while the context 
 30
 
Figure 12 A Collaboration Diagram for the Execution Framework 
 
A collaboration diagram shown in Figure 12 illustrates the inter-cooperation among 
CMS, WfMS, and SMS. Our system keeps sensing the environment context c. CMS 
performs getSemantic(c) through context reasoning and push events to WfMS if 
necessary. Once receiving events, WfMs switches to the correspondent handling 
process. According to the required service descriptions, WfMS requests SMS and then 
SMS pull the services’ status/context from CMS. After acquiring the services’ status, 
SMS match available services by required service description and select one of them 
through pre-defined policy. Finally, SMS returns the selected service to WfMS. 
 
3.4 Summary 
 
In this Section, an application model involving three fundamental components and 
their details are presented for the developers to design their applications. Additionally, 
a framework supporting the execution environment is also presented. The decoupling 
of resource-consuming parts into wrapped services not only minimizes the number of 
elements needed to be maintained, but enables the deployment of our framework into 
the various pervasive environments. On account of conforming to the principle of 
SOA, the framework also enhances the convenient accessing and reusability of 
services.  
 
Figure 13 illustrates the layered-approach to design applications. In the application 
 32
4 A Development Methodology 
 
This Section introduces a development methodology of pervasive applications based 
on the application model and execution framework in Section 3. Following the 
specification principles of context model, process schema, and service description, the 
developers can design their pervasive applications. Figure 14 and Figure 15 illustrate 
how to develop pervasive applications from two distinct viewpoints. Figure 14 
indicates the necessary data items in the development methodology, whereas Figure 
15 shows the development workflow for such applications in BPMN.  
 
 
Figure 14 The Basic Data Model at Each Activities of Development Methodology 
 34
IV. The context entities with their attributes and relationships for the 
applied environment. 
 
In this stage, the above data are closely-related to the rest of development 
methodology. Items I and II are used for the process construction in the Step (2-2). 
Item III assists the developers to give universal service descriptions in the Step 
(2-3) and build the context information of service part in the domain-specific 
context model. Item IV helps to construct the knowledge about the deployed 
environment, and is derived from the generic context model presented in Section 
3. In addition, the domain analysis [40][41][42] helps the developers define the 
common and variable parts in Step (2-1). 
  
(2) Constructing Elements by Element Developers: 
This stage develops the data items inside each of three elements shown in Figure 
14. The development workflow in Figure 15 contains: (2-1) Building the 
domain-specific context model with reasoning rules, (2-2) Building 
processes/workflows, and (2-3) Building service descriptions, as below: 
 
(2-1) Building Domain-Specific Context Model with Reasoning Rules: 
 
 
 
Figure 16 A Workflow of the Domain-Specific Context Model Construction (CMC) 
 
 36
might be performed concurrently; however, its developing activity cannot 
start until (2-3) completes. In 錯誤! 找不到參照來源。, we use a massage 
event to indicate the wait. After getting the services, the corresponding 
(service) part in the model is constructed and (2-1) completes.  
 
(2-2) Building Process/Workflow: 
 
Figure 17 The Workflow of Building Process/Workflow in an Application (BPW) 
 
In this sub-stage, the element developers extract the processes/workflows 
from the Items I and II. There are at least two types of processes needed to 
be constructed:  
i. The processes associated with participants/organizations: This 
process is globally in charge of the cooperation among 
participants/organizations based on control logic and transitions.  
ii. The event-handling process: This process deals with the events 
delivered from context management system. The events correspond 
to the deduced situation classes in Step 2 in (2-1), Hence, the 
developers identify events and specify the event-handling 
processes. 
The built processes in the above type ii are relevant to the context-changing 
and the correspondent reaction, while the built processes in the type i are 
not.  
 
Figure 17 illustrates the workflow of building process/workflow. In the 
 38
 
 
 
Figure 18 A Workflow of Building Service Descriptions (BS) 
 
After the construction of the service parts of domain-specific context model in 
(2-1) is completed, all the elements in a pervasive application are built and a pair 
of throwing–catching events indicates to go to the next development stage. 
 
(3) Deploying Execution Framework Based on Target Environments By 
Deployers: 
Firstly, to instantiate the designed pervasive application system, the developers 
deploy CMS, WfMS, and SMS in the application environment according to our 
framework as centralized or distributed. For example, a smart home can adopt 
the centralized deployment approach, while a hospital or a shopping mall is 
suggested to use the distributed deployment approach.  
 
Next, the developers may request the service providers to furnish used pervasive 
servicers in all derived-processes if the applied environment lacks of them. For 
example, the used pervasive services in a pervasive healthcare application are 
wearable sensors, video sensors, handhelds etc. in a smart home.  
 
Finally, the applications developers put the built elements into three repositories 
in the execution framework: (1) the context-model elements including the 
generic and domain-specific context models are put into the context repository, 
 40
5 Case Study: A Pervasive Healthcare System for a Smart Home 
 
This Section applies our methodology to the example described in Section 2.4.3 to 
indicate its usability. Obviously, a smart home is usually supported by one or more 
healthcare center/providers for emergency handling.  Each step in the development is 
described in details as follows: 
 
(1) Analysis and Requirement Specification : 
I. Several service processes to achieve the goal of this application: 
A. Daily scheduling process: Arrange a target patient’ daily schedule 
according to her/his medical history and physician’s instruction.  
B. Regular serving process: Daily serves according to the scheduling from 
A. 
C. Context monitoring process:  
(1) Bio-signal measurement process: Gather a patient’s bio-signal data 
like the blood pressure repeatedly.   
(2) Posture-capturing processes: Capture the patient’s motion/posture 
repeatedly. 
D. Emergency handling: If the abnormal blood pressure or abnormal 
motion/posture is detected from C, the emergencies are identified to    
request the healthcare center to provide aid-support. 
II. Participated organizations: 
The organizations in this application are categorized into: (1) Smart 
Home (2) Healthcare center, and (3) Healthcare provider including 
hospitals, where the latter two are third-parties for supporting. Each target 
patient is located at a smart home. And, the environment information in a 
smart home is specified as context entities in a home-specific context 
model. The details of context entities in a smart home are analyzed in IV. 
 
III. Used services in a smart home: 
The context providers include wearable sensors and video sensors. A 
handheld is in charges of processing the context data and displays the jobs 
according to the patient’s daily schedule. PCs have a capability to perform 
 42
 
 
Figure 19 The Domain-Specific Context Model in a Smart 
 
In accordance with context entities defined in Stage (1), we utilize the 
OWL format described in Section 3 to specify the context model in a smart 
home. 錯誤! 找不到參照來源。 shows the mapping result.  
 
The reasoning rules defined for subclasses of deduced situations include: 
(1) Current status of a patient’s health: 
A. Morbidity of hypertension: 
(?u diastolic > 140)  ∩  (?u systolic > 90) 
  (?u DeducedSituation   
Morbidity_of_Hypertenstion) 
 
B. falling: 
Since falling is judged by image analysis techniques, the 
context management system gathers the motions of the patient 
and transmits them to healthcare center to acquire the image 
 44
 
Figure 20 A Workflow of Pervasive Healthcare Involving 
 
 
Figure 20 illustrates the details of the processes associated with all the 
participated organization by BPMN. In the beginning, the application 
concurrently activates three sub-processes in a smart home: (1) Bio-signal 
measurement sub-process, (2) Posture capture sub-process, and, (3) Daily 
schedule sub-process. The above two are in charge of monitoring the 
patient’s status (Context monitoring process) and repeat per time units. The 
gathering data of patient’s condition will transmit to the healthcare center. 
The latter one includes a scheduling process and regular serving process. 
(1)  Bio-signal measurement sub-process: 
 46
 
Figure 22 The Daily Schedule Sub-Process Containing the Scheduling and Regular Serving Process 
 
Figure 22 illustrates the daily schedule sub-process containing the 
scheduling and regular serving processes. The daily schedule sub-process 
arranges the patient’s to-do-list through contacting the hospital and 
checking the physician’s instruction. The daily to-do-list can be wrapped 
into a schedule description for regular serving process to perform. Based 
on the date, the regular process executes the appropriate process. Figure 
23 gives a simple example about a possible schedule for Monday.  
 
 
Figure 23 An Example of Regular Serving Process 
  
 48
 
In the healthcare center, the primary activity is the professional judgment 
of a patient’s bio-signal data and motions from the smart home as shown 
in Figure 20. The approach of professional judgment may utilize an 
expert system or a real physician to analyze the patient’s bio-signal data 
and motions. Besides, the professional judgment also provide second 
check whether the erroneous judgment from the smart home. 
 
In the healthcare provider, we give an example process in Figure 25. 
There are two emergency levels needed to be handled: (1) Medium level 
and (2) Heavy level. If the received message-event is medium, the 
healthcare provider sends ambulance. If heavy level, the healthcare 
provider sends helicopter and concurrently inform the physician in order 
to save the time. No matter a received event is the medium or heavy level; 
they finally activate the correspondent handling process in hospital. 
 
 
Figure 25 An Example of Emergency Handling Process in Healthcare Provider 
 
In conclusion, the three participating organizations have their own flow to 
perform. Among them, the smart home arranges the patient’s daily 
schedules, and continuously monitors and transmits the patient’s data to 
the healthcare center. If any emergency is identified, the healthcare center 
requests the healthcare provider to send appropriate aid support based on 
the emergency levels. By means of connecting these participating 
organizations, a entire pervasive healthcare application is constructed. 
 
(2-3) Building Service Descriptions: 
There are two kinds of service description needed to be constructed: (1) 
The required service description for tasks within designed processes, and 
 50
               </process: Output rdf:ID > 
   <process: Output rdf:ID = “Screen”> 
               </process: Output rdf:ID >                
  </process: hasOutput> 
  …  
</Match Computer> 
Figure 26 Two Examples of Required Service Descriptions 
 
(2) The service descriptions for pervasive services: An example of 
patient’s PDA description is as below: 
… 
 <Process: AtomicProcess rdf:ID =“PDA”> 
  <process: hasInput> 
   <process: Input rdf:ID = “Keyboard”> 
              </process: Input rdf:ID > 
<process: Input rdf:ID = “Camera”> 
              </process: Input rdf:ID > 
<process: Input rdf:ID = “Microphone”> 
              </process: Input rdf:ID > 
  </process: hasInput> 
<process: hasOutput> 
   <process: Output rdf:ID = “Speaker”> 
               </process: Output rdf:ID > 
   <process: Output rdf:ID = “Screen”> 
               </process: Output rdf:ID >                
  </process: hasOutput> 
  …  
Figure 27 An Example of Service Descriptions of PDA 
 52
 54
environments”, Special Issue on Ontologies for Distributed Systems, Knowledge 
Engineering Review, Acapulco MX, August 2003. 
[15] Wang X., Zhang D. Q., Gu T., Pung H. K. “Ontology Based Context Modeling 
and Reasoning using OWL”, workshop on context modeling and reasoning at 
IEEE International Conference on Pervasive Computing and Communication , 
Orlando, Florida, March 2004. 
[16] Dejene Ejigu, Marian Scuturici, Lionel Brunie, “An ontology-based approach to 
context modeling and reasoning in pervasive computing”, in Proceedings of the 
Fifth Annual IEEE International Conference on Pervasive Computing and 
Communications  
[17] Chaozhen Guo', Rongguang Ye ,Yan Li, “Research of cooperative long-distance 
education model based on pervasive computing,” in Proceeding of the Second 
International Conference on Pervasive Computing and Application, 
2007(ICPCA2007). 
[18] Xiangkui Yao, Stephen Fickas, “Pedestrian Navigation Systems: a Case Study of 
Deep Personalization, ” in First International Workshop on Software Engineering 
for Pervasive Computing Application, Systems, and Environments 
(SEPCASE’07) 
[19] Javier Cubo, Carlos Canal and Ernesto Pimentel, “Towards a Model-Based 
Approach for Context-Aware Composition and Adaptation: A Case Study using 
WF/.NET,” in 5th International Workshop on Model-based Methodologies for 
Pervasive and Embedded Software (MOMPES 2008) 
[20] Jeff Dallien, Wendy MacCaull, “Initial work in the design and development of 
verifiable Workflow Management Systems and some applications to health care,” 
in 5th International Workshop on Model-based Methodologies for Pervasive and 
Embedded Software (MOMPES 2008) 
[21] Yafang Wang、 Chenglei Yang、 Shijun Liu、 Rui Wang、 Xiangxu Meng “A 
RFID & Handheld Device-Based Museum Guide System,” in Proceeding of the 
Second International Conference on Pervasive Computing and Application, 
2007(ICPCA2007) 
[22] Pankaj Bhaskar and Sheikh I Ahamed, “Privacy in Pervasive Computing and 
Open Issues,” in Second International Conference on Availability, Reliability and 
Security (ARES'07) 
[23] H. S. Cheng, D. Zhang, J. G. Tan, “Protection of Privacy in Pervasive Computing 
Environments”, International Conference on Information Technology: Coding 
and Computing, 4-6 April 2005, pp. 242-247 
[24] V. Bellotti, A. Sellen, “Design for Privacy in Ubiquitous Computing 
Environments”, Proceedings of 3rd European Conference on Computer 
 56
[37] Kyuchang Kang, Hyung-jik Lee, Eun-jung Ko and Jeunwoo Lee, “A Systematic 
Design Tool of Context Aware System for Ubiquitous Healthcare Service in a 
Smart Home Dong-oh Kang,” IEEE Future generation communication and 
networking (fgcn 2007) 
[38] Li Xuemei, Jiang Liangzhong, Li Jincheng,  “Framework for Pervasive health 
monitoring,”  IEEE Proceedings of the 5th International Conference on 
Information Technology and Application in Biomedicine, in conjunction with 
The 2nd International Symposium & Summer School on Biomedical and Health 
Engineering, Shenzhen, China, May 30-31, 2008 
[39] R. Casas, A´ . Marco, I. Plaza, Y. Garrido and J. Falco, “ZigBee-based alarm 
system for pervasive healthcare in rural areas” IEEE IET Commun., 2008, 2  
[40] Dennis de Champeaux, Douglas Lea, and Penelope Faure, “Domain Analysis, 
Section 13, Object-Oriented System Development,”  in Addison Wesley. ISBN 
0-201-56355-X 1993  
[41] Frakes, W.B. and Kyo Kang, (2005), "Software Reuse Research: Status and 
Future", IEEE Transactions on Software Engineering, 31(7), July, pp. 529-536. 
[42] Kelly, S. and Tolvanen, J.-P., (2008) Domain-Specific Modeling: Enabling Full 
Code Generation, John Wiley & Sons, New Jersey. ISBN 978-0-470-03666-2 
[43]Business process execution language for web sevices, 
http://www.ibm.com/developerworks/library/ws-bpel/  
[44] Owl-s specifications, http://www.w3.org/Submission/OWL-S  
[45] Parameterized semantic matching for workflow composition. Technical Report 
RC23133, IBM, 2004. 
[46] M. Laukkanen and H. Helin, “Composing workflows of semantic web services,” 
In Workshop on Web Services and Agent-based Engineering, 2003 
[47] G. Hackmann, C. Gill, Gruia-Catalin Roman, “Extending BPEL for Interoperable 
Pervasive Computing,” in IEEE 2007 
[48] D. Ardagna and B. Pernici, “Adaptive Service Composition in Flexible 
Processes,” IEEE Transactions on Software Engineering, Vol.33, No. 6, June 
2007 
[49] Sik Chun Lam, Derek Sleeman, and Wamberto Vasconcelos, “Graph Based 
Ontology Checking,” K-CAP'05 5, Ban®, Canada Copyright 2005 ACM 
1-58113-000-0/00/0000, October 2-5, 2005 
[50] LI Zong-yong, WANG Zhi-xu, ZHANG Ai-hui, and Xu Yong, “The Domain 
Ontology and Domain Rules Based Requirements Model Checking,” 
International Journal of Software Engineering and Its Applications Vol. 1, No. 1, 
July, 2007 
[51] Jin Song Dong, Chew Hung Lee, and Hian Beng Lee, “A Combined Approach to 
國科會計畫 –NSC 95-2221-E-009-136-MY3 
一個以工作流程技術改進普適計算之研究  
國外差旅心得報告 
 
  
一、 參加會議經過 
第三十三屆國際電子電機工程師協會電腦軟體與應用國際會議(以下簡稱 COMPSAC09)於 2009
年七月二十日至二十四日於西雅圖舉辦，本人與指導教授王豐堅博士的論文獲得於 COMPSAC09
中舉辦的第三屆國際電子電機工程師協會軟品導向再利用國際研討會(以下簡稱
QUORS09)青睞，得以刊登於 COMPSAC09 的議程之中，本人亦於 2009 年七月十九日由台
灣出發前往西雅圖，並於當地時間七月二十日下午一點半，於 QUORS09 的第三個
session 中進行報告，之後本人全程參與 COMPSAC09 並與來自美國本地以及中國的許多
教授、學者有所交流，最後本人於當地時間七月二十八日由舊金山出發返回台灣，並
於台灣時間七月二十九日清晨到達台灣桃園國際機場，結束整個行程。 
 
二、 與會心得 
本人主要的研究興趣在於軟體測試(testing)、服務導向架構(service oriented 
architecture, SOA)以及雲端計算(cloud computing)等相關議題，COMPSAC09 中來自世界各
地的學者對於本人感興趣的議題多有發表，令本人獲益匪淺。 
 
來自德州大學達拉斯分校的 Dr. I-Ling Yen 於第二屆國際電子電機工程師協會即時服務導向
會議名稱 
（中文）第三屆國際電子電機工程師協會軟品導向再利用國際研討會 
於 第三十三屆國際電子電機工程師協會電腦軟體與應用國際
會議 
（英文）3rd IEEE International Workshop on Quality Oriented Reuse 
of Software in conjunction with 33rd IEEE International 
Conference on Computers, Software and Applications 
發表論文題目 
（中文）以文件流圖示做為文件異常使用的模型 
（英文）Using Artifact Flow Diagram to Model Artifact Usage 
Anomalies 
web 介面，試圖挑戰 Microsoft 在作業系統(operating system)上的龍頭地位，而 Microsoft
則發展屬於自己的雲端計算平台 Azure，以及機動部署(mobile deployment)機制，試圖以靈
活、快速的部署機制以及本身在作業系統上的優勢，爭搶雲端計算龍頭地位，並且以自有的
資料安全解決方案進一步挑戰如 Oracle 在資料庫管理系統(database management system, 
DBMS)上的領導地位。 
 
Dr. Mueller則在COMPSAC09 Testing方面的第三個session發表了”An Economical Approach 
to Usability Testing”，Dr. Mueller 指出 usability testing 由於需要 domain expert 的
參與，代價高昂，然而其僅能指出錯誤的存在，卻對於幫助解決軟體系統中的錯誤不甚有效，
往往造成 usability testing 的效果不彰，Dr. Mueller 提出以傳統 testing 技術進行
usability testing 的嶄新概念，Dr. Mueller 的實驗指出，藉由 effort based 的方式可以
有效彌補傳統 usability testing 的缺陷，並且降低 testing 的成本。 
 
而在 Fast Abstract 的第一個 session 中，則有多篇精彩的短論文發表，Dr. Cheng 提出了驗
證機器人安全性的新原則，Dr. McCaffrey 則以精彩的演講引出運用基因演算法計算成對測試
(pair-wise testing)test case 的演算法，在此 session 中，本人最感興趣的當屬 Dr. Yang
所發表的”An Ontology-Based Approach for GUI Testing”，講演中 Dr. Yang 闡明針對 GUI 
Testing 所建構的 Ontology，其中最重要的部分是互動元件的，然而礙於時間問題，Dr. Yang
並未能做出完整的講演，甚感遺憾。 
 
COMPSAC09 的第三個 keynote 則是 Dr. Okamoto 所發表的”Towards Fine Grained Scure 
Communications”，Dr. Okamoto 針對 security 的傳統議題如公私鑰加解密法，提出了新的
看法，Dr. Okamoto 鉅細靡遺的解說，令聽講者無論是否為 security 領域的專家，都能獲得
收穫。 
 
COMPSAC09 最後一天則由 Dr. Stephen S. Yau 主持 Concluding Panel，針對”Security and 
Privacy in Community-based Internet Applications”讓與會的數位專家學者提出意見，
其中 Dr. Voas 提出，security 與 privacy 並非同樣的議題，某些情況下 security 的技術可
以保護 privacy，而同時也有可能是必須藉由 privacy 來保護 security，在不同的狀況下，
security 與 privacy 可能有者不同的範圍，可能互相包含，也有可能僅僅有所關連，然而有
時為了保護使用者關鍵的 privacy information，可能必須要犧牲部分的 privacy 以維護整體
系統的 security，而資訊系統應該提供足夠的提示，令使用者知道當他使用系統時，犧牲了
什麼樣的 privacy 同時在 security 上獲得了如何的保護。 
 
三、 攜回資料名稱與內容 
本人此次參與 COMPSAC09 攜回最主要的資料為本次會議的 proceeding 與所有發表的論文全
Using Artifact Flow Diagrams to model Artifact Usage Anomalies 
Hwai-Jung Hsu, and Feng-Jian Wang 
Dept. of Computer science 
National Chiao-Tung University 
Hsinchu, Taiwan 
{hjhsu, fjwang}@csie.nctu.edu.tw 
 
 
Abstract—Workflow is a set of tasks which are systematized to 
achieve certain business goal(s), where the tasks run in a 
particular order under automatic control. Artifacts, 
collections of data items, are necessary for task (process) 
executions in a workflow. However, an execution may yield 
unexpected results due to improper artifact manipulation: e.g., 
activities miss artifact or artifact conflict occur at an activity 
dynamically. Therefore, the analyses on artifact usage in 
design phase are very important for quality insurance. This 
paper presents a model of artifact flow diagrams to state the 
artifact usage anomalies in processes transmitting artifacts 
based on DCDC, Distinct Control and Data Channel, model. 
There are four types of artifact usage anomalies identified in 
DCDC and the formal statement of each anomaly is described 
correspondingly for future study of anomaly search. 
Keywords- workflow, artifact, artifact flow diagram, DCDC 
I.  INTRODUCTION 
Workflow is a set of tasks which are systematized to 
achieve business goals by completing tasks in a particular 
order under automatic control [1]. Besides, resources are 
necessary for workflow implementation and support process 
execution. Resource allocation and resource constraint 
analysis [2 - 6] are popular topics of workflow research. 
Data flow analysis within workflow was much less 
addressed [7, 8], where artifacts are deemed as collections 
of data items operated in a task or process. Introducing 
analysis of artifact usage into workflow designs might help 
maintaining data consistency, as well as prevent the 
exceptions. In contrast to structural correctness, accuracy in 
artifact manipulation can help determine whether the 
execution result of a workflow is meaningful and desirable. 
Sadiq et al. [7] presented data flow validation issues in 
workflow modeling, including identifying requirements of 
data modeling and seven basic data validation problems. But, 
there is no discussion about any implementation or formal 
method to demonstrate how to apply their researches and 
which types of workflow model are compatible with their 
activity-based data model. Sun et al. [8] presented a data 
flow analysis framework for detecting data flow anomalies 
such as missing data, redundant data, and potential conflicts 
of data and provided several algorithms detect anomalies. 
However, the work is done only based on read and first 
initial write operations of an artifact. 
Formally, Jin Hyun Son [14] defined a well-formed 
workflow based on the concepts of closure and control 
block. He claimed that a well-formed workflow is free from 
structure errors, and that complex control flows can be made 
with nested control blocks. Aalst [9] identifies three major 
artifact transmission models in a workflow: (1) Global Data 
Store (GDS), (2) Integrated Control and Data Channels 
(ICDC), and (3) Distinct Control and Data Channels 
(DCDC), where DCDC is more flexible for representing 
artifact transmission than GDS and ICDC.  
This paper proposes a process model for describing a 
well-formed workflow, where the artifact transmissions in 
this model are based on DCDC model. There are four types 
of artifact usage anomalies addressed. 
On the other hand, each artifact in this model has a 
corresponding artifact flow diagram (AFG) to represent its 
transmissions and usages. By analyzing the artifact flow 
diagram, the artifact usage anomalies are stated, and the 
warning messages are be provided to the designers.  
The remainder of this paper is organized as follows. The 
background of this paper is described in section 2. The 
artifact flow diagram is modeled in section 3, and the 
artifact usage anomalies stated with the artifact flow 
diagram are introduced in section 4. Finally, we conclude 
this paper in section 5. 
II. BACKGROUND 
To develop an effective and reliable workflow 
application, a well-defined workflow model is necessary. 
The correctness issues in a workflow might be classified 
into three dimensions: control flow, resource, and data flow. 
The analysis of control flow aspect includes structural 
correctness focuses on soundless of control logic [10], 
process model analysis, workflow patterns [9, 11], and 
automatic control of workflow process [12], etc. The 
analysis of resource aspect includes resource allocation 
constraints [2], resource availability [3], resource 
management [5], and resource modeling [6], etc. The 
analysis of data flow aspect includes data flow validation 
[7], data flow formulation [8], and artifact usage anomalies 
detection [8][14], etc. 
A. Artifact Transmission Models 
Aalst [9] identifies three major artifact transmission 
models in a workflow: (1) Global Data Store, (2) Integrated 
Control and Data Channels, and (3) Distinct Control and 
Data Channels.  
Global Data Store (GDS): Each artifact is only allowed 
to have one instance in a workflow and the instance is 
typically stored in a global shared data store. All activities 
share the same artifact instances in the global data store. 
2009 33rd Annual IEEE International Computer Software and Applications Conference
0730-3157/09 $25.00 © 2009 IEEE
DOI 10.1109/COMPSAC.2009.145
275
activities are executed in parallel. 
∀ activities u and v, IsParallel(u, v) = true if and only if  
∃ e1 ∈ ABStacku and e2 ∈ ABStackv where e1.c = e2.c, 
e1.br ≠ e2.br and e1.c is an AND control block 
IsExclusive() is a boolean function representing if two 
activities executed exclusively 
    ∀ activities u and v, IsExclusive(u, v) = true if and only 
if  ∃ e1 in ABStacku and e2 in ABStackv where e1.c = 
e2.c, e1.br ≠ e2.br and e1.c is an XOR control block 
III. ARTIFACT FLOW DIAGRAM WITH DCDC 
In this paper, we apply artifact flow diagram to analyze 
artifact usage anomalies for workflows in DCDC.  
In DCDC, artifacts are passed between activities via 
explicit channels [15] which are distinct from control flows. 
Hence, each artifact has a corresponding artifact flow 
diagram representing the artifact usages and transmissions 
in a workflow. In addition, artifacts transfers are passed by 
value in our model and an activity starts execution only after 
all necessary artifacts are received. 
A. Artifact Operations and Usages 
An artifact is a collection of data items involved in a 
process, and artifact operations are applied in activities to 
perform artifacts. In [14], artifact operations are 
conceptually classified as initialize, read, update, and 
delete. 
In this paper, activities can decide where the artifacts are 
passed. Therefore, an additional operation Pass(), passing an 
artifact to another activity, is defined. Let ܲܽݏݏܮ݅ݏݐ௩ denote 
a linked list to record the pass operations in an activity v. 
Thus, Pass(d, u)∈ ܲܽݏݏܮ݅ݏݐ௩ if and only if v passes artifact 
d to activity u. In other words, v is the sender and u is the 
receiver of d. A receiver cannot receive the artifact if the 
reception occurs before the sender process. Hence, an 
activity cannot pass artifacts to its predecessors. 
For an activity v, the operations Pass() in ܲܽݏݏܮ݅ݏݐ௩  are 
performed only when all the other operations, such as 
initialize, read, update, and delete, are completed. Besides, 
we assume that artifacts are passed by value, and therefore 
more than one copy of an artifact may exist in a workflow.  
To identify the artifact usages in an activity, each 
activity contains the input and output artifacts sets: ܫ, ܱ, ܷା, 
and ܷି defined as follows. 
Definition 3  (Input and Output Artifacts Sets) 
∀ activity v,  
ܫ௩  is the set of artifacts read, updated, or deleted in v 
௩ܱ is the set of artifacts passed from v after execution of v 
௩ܷା is the set of artifacts initialized or updated in v 
௩ܷି  is the set of artifacts deleted in v 
To simplify our discussion, for an artifact d, an activity 
can be accompanied with one of the following roles of d, 
Producer, Reader, Updater, Destroyer, Irrelevantor, and 
Relevantor as definition 4. 
Definition 4  (Roles of an Activity to Artifacts) 
∀ activity v and artifact d,  
v is a Producer of d where d ∉ ܫ௩  and d ∈ ௩ܷା 
v is a Destroyer of d where d ∈ ܫ௩  and d ∈ ௩ܷି  
v is a Reader of d where  ݀ ∈ ܫ௩  and ൜݀ ∉ ௩ܷ
ା
݀ ∉ ௩ܷି  
v is an Updater of d where d ∈ ܫ௩  and d ∈ ௩ܷା or  
  ݀ ∉ ܫ௩ and ൜݀ ∉ ௩ܷ
ା
݀ ∉ ௩ܷି  
v is a Relevantor of d where if ݀ ∈ ௩ܱ or  
∃ an activity u and Pass(d, v)∈ܲܽݏݏܮ݅ݏݐ௨ 
v is an Irrelevantor of d where  ݀ ∉ ௩ܱ  and  
  ׍ u that Pass(d, v)∈ܲܽݏݏܮ݅ݏݐ௨ 
The role of v to d is notated as ܴ݋݈݁௩ௗ 
B. Artifact Operations and Usages 
An artifact flow diagram represents the usages and 
transmissions of artifacts in a process. During execution, an 
artifact is basically passed in a directed acyclic graph that 
guarantees no deadlock for artifacts between activities. The 
Artifact Flow Diagram is formally defined as follows. 
Definition 5  (An Artifact Flow Diagram) 
For an artifact d, artifact flow diagram for d in process p 
is denoted by ܣܨ௣ௗ = (ܣܨ ௣ܸௗ, ܣܨܨ௣ௗ, ܣܨ ௣ܰௗ), where  
ܣܨ ௣ܸௗ  is the set of activities and ∀  v∈ܣܨ ௣ܸௗ , ܴ݋݈݁௩ௗ  ≠ 
Irrelevantor. 
 ܣܨܨ௣ௗ is the set of flows. ∀  u, v ∈ܣܨ ௣ܸௗ, (u, v)∈ܣܨܨ௣ௗ if 
and only if Pass(d, v) ∈ ܲܽݏݏܮ݅ݏݐ௨, and  
ܣܨ ௣ܰௗ is the set of XBNodes in ܣܨ௣ௗ which are defined in 
the following flow graphs. 
Artifact Flow Diagram describes how artifacts are 
transferred according to process schema. However, during 
run-time, activities reside in an XOR control block might 
not be executed and therefore the artifacts transferring to or 
from such activities might only be potentially passed. 
Besides, u and v cannot both be executed if u and v are 
exclusive activities. Therefore the artifact passes between u 
and v can never happen during run-time.  
To modeling the problem, for each we define ܴ݁ܿ݁݅ݒ݁௩ௗ 
as the set of activities passing d to v and ܵ݁݊݀௩ௗ as the set of 
activities where v passes d. Both ܴ݁ܿ݁݅ݒ݁௩ௗ and ܵ݁݊݀௩ௗ  are 
categorized into explicit and potential sets as following 
definition.  
Definition 6  (Receiving/Sending Sets) 
∀ v ∈ ܣܨ ௣ܸௗ 
  ܴ݁ܿ݁݅ݒ݁௩ௗ = {u | u∈ܣܨ ௣ܸௗ, (u, v) ∈ܣܨܨ௣ௗ} 
    ܲܫ ௩ܰௗ ك ܴ݁ܿ݁݅ݒ݁௩ௗ , where  
  ∀ u ∈ ܲܫ ௩ܰௗ, ∃ e ∈ ܣܤܵݐܽܿ݇௨ \ ܣܤܵݐܽܿ݇௩  that e.c is an 
XOR block and IsExclusive(u, v) = false. 
    ܧܫ ௩ܰௗ ك ܴ݁ܿ݁݅ݒ݁௩ௗ \ ܲܫ ௩ܰௗ 
      ∀ u ∈ ܧܫ ௩ܰௗ, IsExclusive(u, v) = false. 
  ܵ݁݊݀௩ௗ = {u | u∈ܣܨ ௣ܸௗ, (v, u) ∈ܣܨܨ௣ௗ} 
    ܱܷܲ ௩ܶௗ ك ܵ݁݊݀௩ௗ, where  
  ∀ u ∈ ܱܷܲ ௩ܶௗ, ∃ e ∈ ܣܤܵݐܽܿ݇௨ \ ܣܤܵݐܽܿ݇௩  that e.c is 
an XOR block and IsExclusive(u, v) = false. 
   ܧܱܷ ௩ܶௗ ك ܵ݁݊݀௩ௗ \ ܲܫ ௩ܰௗ 
      ∀ u ∈ ܧܱܷ ௩ܶௗ, IsExclusive(u, v) = false. 
277
∀flow (u, v)∈ܣܨܨ௣ௗ, IsParallel(u, v) = true. 
 XOR Flow:  
∀flow (u, v)∈ܣܨܨ௣ௗ, IsExclusive(u, v) = true. 
 
Figure 5.  The Corresponding Artifact Flow Diagram for d. 
TABLE I.  THE STATES OF EACH ACTIVITY IN FIGURE 6 
 ܴ݁ܿ݁݅ݒ݁௩ௗ ܧܫܰᇱ௩ௗ ܲܫܰᇱ௩ௗ ܵ݁݊݀௩ௗ ܧܱܷܶᇱ௩ௗ ܱܷܲܶᇱ௩ௗ
ݒଵ ∅ ∅ ∅ {ݒଶ} {ݒଶ} ∅
ݒଶ {ݒଵ} {ݒଵ} ∅ {ݒଷ, ݒସ} {n1} ∅ 
ݒଷ {ݒଶ} {ݒଶ} ∅ {ݒସ, ݒହ} {ݒହ} ∅
ݒସ {ݒଶ, ݒଷ} {ݒଶ} ∅ {ݒହ, ݒ଺} {ݒହ, ݒ଺} ∅
ݒହ {ݒଷ, ݒସ} {n2} ∅ {ݒ଺} {ݒ଺} ∅ 
ݒ଺ {ݒସ, ݒହ} {ݒହ} {n3} ∅ ∅ ∅
In Table I, ݒଷ passes d to ݒସ and ݒହ; thus, ܵ݁݊݀௩యௗ  = {ݒସ, ݒହ }. However, ݒଷ  and ݒସ  are exclusive activities. Activity 
ݒସ  is not added into ܧܱܷ ௩ܶయௗ  or ܱܷܲ ௩ܶయௗ . Therefore, 
ܧܱܷܶᇱ௩యௗ  = {ݒହ} and ܱܷܲܶᇱ௩యௗ  = ∅. On the other hand, ݒ଺ 
receives d from ݒସ  and ݒହ ; thus, ܴ݁ܿ݁݅ݒ݁௩లௗ  = {ݒସ , ݒହ }. 
Activity ݒ଺  can not receive d from ݒସ  when ݒସ  is not 
selected to execute. Activity ݒ଺  receives d from ݒସ 
potentially. Hence, ݒସ is added into ܲܫ ௩ܰలௗ . Since ݒ଺ can not 
receive d from x1 when ݒଷ  is selected to execute, a 
conditional n3 is used to replace ݒସ  in ܲܫ ௩ܰలௗ . Finally, 
ܧܫܰᇱ௩లௗ  = {ݒହ} and ܲܫܰᇱ௩లௗ  = {n3}. 
TABLE II.  THE STATES OF EACH XBNODE IN FIGURE 6 
 
IV. ARTIFACT USAGE ANOMALIES 
In this section, the artifact usage anomalies are described 
and stated with artifact flow diagram. 
A. Missing Artifact Anomalies 
While an artifact d is used in activity v, a missing artifact 
anomaly occurs if v cannot receive d during execution time, 
and can be divided into the two cases below: 
1) Explicit Missing Artifacts: 
No activities pass d to v. 
      ݒ ∈ ܣܨ ௣ܸௗ  ר  หܧܫܰᇱ௩ௗห ൌ 0 ר  หܲܫܰᇱ௩ௗห ൌ 0 ר        
             ܴ݋݈݁௩ௗ ∈ ሼReader, Updater, Destroyer, Relevantorሽ  
2)  Implicit Missing Artifact: 
v only implicitly receives d, i.e. v might not receive d 
during run-time 
       ݒ ∈ ܣܨ ௣ܸௗ  ר  หܧܫܰᇱ௩ௗห ൌ 0 ר  หܲܫܰᇱ௩ௗห ൐ 0 ר          
             ܴ݋݈݁௩ௗ ∈ ሼReader, Updater, Destroyer, Relevantorሽ  
3) Destroyed Artifact:  
     v, a destroyer of d,  passes d to other activities 
      ݒ ∈ ܣܨ ௣ܸௗ ר ܴ݋݈݁௩ௗ ൌ Destroyer ר      
             ሺหܧܱܷܶᇱ௩ௗห ൐ 0 ש หܱܷܲܶᇱ௩ௗห ൐ 0ሻ 
B. Artifact Conflict Anomalies 
Since artifacts are passed by value in our process model, 
an activity may receive multiple copies or versions of one 
artifact. Hence, an activity may receive multiple copies of 
an artifact. The designer of process schema should design 
how to select or merges the copies in the activity, and 
therefore an artifact conflict should be warned to the 
designer when happens. 
1) Explicit Artifact Conflict: 
v explicitly receives multiple copies of d. 
    ݒ ∈ ܣܨ ௣ܸௗ  ר  หܧܫܰᇱ௩ௗห ൐ 1 
2) Implicit Artifact Conflict:  
v implicitly receives multiple copies of d. 
    ݒ ∈ ܣܨ ௣ܸௗ  ר ሺ൫หܧܫܰᇱ௩ௗห ൌ 1 ר  หܲܫܰᇱ௩ௗห ൐ 0൯ ש 
             ൫หܧܫܰᇱ௩ௗห ൌ 0 ר หܲܫܰᇱ௩ௗห ൐ 1൯ሻ 
If an activity receives an artifact d and produces another 
one, there is also an artifact conflict called production 
conflict. 
3) Production Conflict:  
v is a producer of d and receives another d from other 
activity. 
    ݒ ∈ ܣܨ ௣ܸௗ  ר  ܴ݋݈݁௩ௗ ൌ Producer ר 
              ሺหܧܫܰᇱ௩ௗห ൐ 0 ש  หܲܫܰᇱ௩ௗห ൐ 0ሻ 
C. Cross Passing Artifact Anomalies 
A cross passing artifact anomaly occurs when an artifact 
is passed between branches of an XOR/AND control block. 
Passing artifacts between exclusive activities is useless since 
the passing never takes place during run-time. Passing 
between parallel activities might cause racing hazard, and 
therefore should be warned. 
1)  Passing between Parallel Activities: 
u and v are parallel activities, and u passes d to v. 
          ሺݑ, ݒሻ ∈ ܣܨܨ௣ௗ  ר  IsParallelሺݑ, ݒሻ ൌ ݐݎݑ݁ 
2)  Passing between Exclusive Activities:  
u and v are exclusive activities, and u passes d to v.  
          ሺݑ, ݒሻ ∈ ܣܨܨ௣ௗ  ר  IsExclusiveሺݑ, ݒሻ ൌ ݐݎݑ݁ 
D. Redundant Anomalies 
A redundant update/initialization anomaly occurs when 
activity v updates or initializes d without passing d to other 
activities. On the other hand, a redundant pass anomaly 
occurs when v receives d without using d. 
1) Redundant Update/Initialization: 
v initializes or updates d without passing d to other 
activities.  
     ݒ ∈ ܣܨ ௣ܸௗ  ר หܧܱܷܶᇱ௩ௗห ൌ 0 ר  หܱܷܲܶᇱ௩ௗห ൌ 0 ר 
279
