 I
 
目錄 
 
中文摘要…………………………………………………………...……………………………..II 
 
Abstract…………………………………………………………...……………………………. IV 
 
I.  Introduction…………………………………………………...……………………….……. 1 
 
II.  Quasi-circuit Switching ........................................................................................................ 3 
II.A.  Stop-and-go queuing in shared memory switches………………………………….. 4 
II.B.  Crosspoint buffered switches……………………………………………………….. 5 
II.C.  Load balanced Birkhoff-von Neumann quasi-circuit switches………………………6 
II.D.  Benes quasi-circuit switches…………………………………………………………7 
 
III.  Capacity Reservation Algorithm for Packet Delay Control ............................................ 9 
III.A.  Average Packet Delay for Each Input Port……………………………………….. 10 
III.B.  Packet Control Algorithms……………………………………………………….. 12 
III.C.  Results and Discussions………………………………………………………….. 14 
 
IV.  Banyan-based Architecture for Quasi-Circuit Switching............................................... 29 
IV.A.  Banyan-based Quasi-circuit Switch………………………………………………. 29 
IV.B.  Switching Algorithms…………………………………………………………….. 31 
IV.C.  Simulation and Numerical Results…………………………………………………41 
 
V.  Conclusions........................................................................................................................... 54 
 
References…………………………………………………...……………………….…………. 55 
 
附錄 A………..……………………………………………...……………………….…………. A1 
 
附錄 B………..……………………………………………...……………………….…………. B1 
 
 
 III
先大尺度的負載平衡準線路式交換機而言，有更好的系統效能；特別是平均封包延遲時間
的標準差有大幅度的改善 (降低)，因此對於大型網路內的整體封包延遲時間，將能有更好
的控制與預測。 
 
關鍵詞：高速交換、布可荷夫-范紐曼交換機、多層級式交換機、服務品質、準線路式交換、
封包控制、班楊交換 
 
 
 V
Banyan-based quasi-circuit switching is proposed. A large dimension switch is decomposed into 
multiple 2×2 frame-based switching elements in order to reduce the implementation complexity. 
According to the numerical and simulation results, it was found that the performance of the 
Banyan-based architecture is better than that of the load-balanced architecture. Especially, the 
standard deviation of the average packet delay can be greatly reduced by applying the proposed 
architecture. Therefore, the overall packet delay in a network can be well controlled and 
predicted. 
 
Keywords: High speed switching, Birkhoff-von Neumann switches, Multi-stage switches, Quality 
of services, Quasi-circuit switching, Packet delay control, Banyan switching 
 
 
 2
To reduce the maximum frame delay, we propose the Clos quasi-circuit switches (with 
speedup). Unlike the classical Clos three-stage network, routing paths can be easily determined in 
the Clos quasi-circuit switches. By recursively expanding the Clos quasi-circuit switches, we 
derive the Benes quasi-circuit switches in which the routing path of a packet can be easily 
determined by the binary representation of the output of that packet. Moreover, the frame delay in 
the Benes quasi-circuit switch is substantially smaller than that in the load balanced Birkhoff-von 
Neumann quasi-circuit switch. 
 
To increase the link utilization, one may allow packets to be dropped inside a quasi-circuit 
switch once the link capacity is exceeded. By so doing, one can then apply the large deviation 
theory to infer the statistical QoS via measuring the average link utilization. As such, there is no 
need for centralized control as required in circuit switching and complicated packet scheduling as 
required in packet switching. 
 
In the second part of this report, we release the constraint of (r, T)-smooth in order to 
improve system throughput. That is, the total number of bits of a flow in every frame is now not 
bounded by r bits. We only have the average number of bits of a flow being r bits. In such a case, 
the input packets in a specific frame may overflow some bins in the central buffers; therefore, an 
input buffer in each input port is required. Furthermore, to control the packet overall delay for 
different input ports, we proposed two packet delay control algorithms to improve the statistics of 
the packet overall delay.  
 
In the third part of this report, we proposed a systematical way to implement a large 
dimension load balanced Birkoff-von Neumann quasi-circuit switch. A large dimension switch is 
implemented by integrating multiple small dimension elements in order to reduce the 
implementation complexity. This new architecture is based on Banyan switching architecture. A 
switch with a large dimension is decomposed into several 2×2 frame-based switching elements.  
 
 4
switching that only guarantees the order of packets. To see the connection between circuit 
switching and quasi-circuit switching, one may further partition a frame into a group of fixed size 
time slots. For circuit switching, assume that every packet can be transmitted in a time slot. Then 
circuit switching guarantees that for any two packets of the same local flow, the difference of 
their arriving time slots is the same as the difference of their departing time slots. This is much 
stronger than (P2). To summarize, quasi-circuit switching is between packet switching and circuit 
switching. In circuit switching, traffic is completely isolated by slot assignment. On the other 
hand, traffic is completely mixed in packet switching. Quasi-circuit switching uses frames to 
isolate traffic. By so doing, it still provides some guarantees of quality of services (QoS). At the 
same time, quasi-circuit switching allows packets to be multiplexed within a frame. This is 
known as the duration limited statistical multiplexing in [3].  
 
There are several direct consequences from (P1) and (P2). 
 
Proposition 4 Consider an M × N quasi-circuit switch with maximum frame delay d. Suppose 
that its inputs satisfy the no overbooking condition. 
(P3) Packets of the same local flow depart in the FCFS order. 
(P4) The maximum packet delay is bounded by (d+1)T, where T is the universal frame time. 
(P5) No packets are lost inside the switch. 
(P6) The local flow Ai,k is (ri,k,T)-smooth when it departs from the kth output link of the switch. 
 
We now give several examples to show how quasi-circuit switches can be built. 
 
 
Fig. 2.1. A shared memory switch 
 
II.A. Stop-and-go queuing in shared memory switches  
 
The simplest way to build a quasi-circuit switch is to use the shared memory architecture. 
Consider an M × N switch with an identical link capacity c. For a shared memory switch 
architecture (see Fig. 1), packets that arrive during the same frame from all input links are read 
into a common shared memory. In the next frame, a central controller then writes all those 
 
 
Memory 
. 
. 
. 
N 
Input Output 
. 
. 
. 
 6
memory architecture, there are two phases of memory access. During the first phase of a frame, 
the thji ),(  buffers, Nj ,...,2,1= , are connected to the thi  input link, Ni ,...,2,1= . An arriving 
packet from the thi  input link and destined for the thj  output link is then placed in the thji ),(  
buffer. During the second phase of a frame, the thji ),(  buffers, Ni ,...,2,1= , are connected to 
the thj  output link, Nj ,...,2,1= . Packets that are stored in the thji ),(  buffers, Ni ,...,2,1= , 
are then read out sequentially to the thj  output link.  Clearly, under the no overbooking 
condition, no packets are lost inside the switch and the frame delay is exactly one frame time. 
Moreover,  the memory access speed for this architecture is only required to be  twice of the 
link capacity. However, as pointed out in [1], the architecture based on crosspoint buffers does 
not scale for a large number of input/output links because of the square growth. It is only good 
either for small switches, or as basic architecture for the building blocks of modular multi-stage 
switches. 
 
 
Fig. 2.3. The load balanced architecture for quasi-circuit switches 
 
II.C. Load balanced Birkhoff-von Neumann quasi-circuit switches  
 
Both switch architectures in Example 5 and Example 6 do not scale when the number of 
input/output ports is large. Recently, a much more scalable switch architecture, called the load 
balanced Birkhoff-von Neumann switch, is proposed (see e.g., [14] and references therein). In 
such an architecture (see Fig. 3), there are two crossbar switch fabrics and buffers between these 
two crossbar switch fabrics. To build an NN ×  quasi-circuit switch with capacity c  by this 
architecture, one first partitions time into fixed size frames. Both the NN ×  crossbar switches 
in Fig. 3 have identical connection patterns for all time and change their connection patterns 
simultaneously at the beginning of every frame. The connection patterns are set up corresponding 
to a circular-shift matrix. As such, every input is connected to every output exactly once in every 
N  frames. 
．
．
．
First stage Second stage 
．
．
．
Central buffers 
#
#  
The first mem block
The second mem block
 8
the last stage. Every input link at the first stage and every output link at the third stage has 
capacity 1c . The second stage consists of two 22 NN ×  quasi-circuit switches with link capacity 
2c . As N  is a power of 2, each of the two 22 NN ×  quasi-circuit switches  can be further 
implemented by a three-stage Clos network with 22×  quasi-circuit switches at the first stage 
and the last stage, and two 44 NN ×  quasi-circuit switches with link capacity 3c  at the second 
stage. One can expand the 44 NN ×  switches recursively and we obtain a multi-stage switch with 
all 22×  quasi-circuit switches. In Fig. 4, we show an 88×  Benes quasi-circuit switch. For an 
NN ×  Benes network, it is well-known that the number of stages of is 1log2 2 −N  and the 
number of 22×  quasi-circuit switches is 22log NNN − .  
 
Unlike the classical Benes network, finding the routing path in the Benes quasi-circuit 
switch is very easy. Index the output links at the last stage from 1,...,2,1,0 −N . Consider a packet 
that is destined for output j  (at the last stage). Let nbbb ,...,, 21  be the bitn −  binary 
representation of j , e.g., 100  for 4=j  in Fig. 4. This binary representation is added in the 
packet header. As in the three-stage Clos quasi-circuit switch, the routing policy used in the 
Benes quasi-circuit switch consists of two parts: self-routing and load-balancing. 
 
(i) Self-routing: when the packet arrives at stage jn +−1 , nj ,...,2,1= , the packet is 
routed to the upper link if 0=jb  and the lower link if 1=jb . 
(ii) Load-balancing: when the packet arrives at stage j , 1,...,2,1 −= nj , and it is the thk  
packet in that frame that has the same sbbb n ',...,, 21  in its packet header, then the 
packet is routed to the upper link if k  is even, and the lower link if k  is odd. This can 
be implemented by keeping a bitjn −+− 12  vector at each input link of stage j . Let 
jn
jnbbbl
−
+−+++= 2...22 11201 . Then the packet is routed to the upper link if thl  bit of 
that bit vector is 0 and the lower link otherwise. Moreover, the thl  bit of that bit vector 
is toggled after the packet is routed. 
 
For a detailed report, please see [15]. 
 
 10
port 4 for a 4×4 switch with frame size equal to 3. The packets of the three preceding input ports 
have been sent into the central buffers as shown in Fig. 3.2. The remaining space in the first 
central buffer is one packet slot in 2nd bin, 3rd bin and 4th bin. The input packets coming from input 
port 4 are destined for output ports 1, 2 and 3. Since the buffer space in the 1st bin has been fully 
occupied by the packets from the three preceding input ports, the packet destined for output ports 
1 will be queued in the input buffer of port 4.  
 
 
Fig. 3.2. An example of input traffic patterns that induce packet block in input port 4. 
 
The frequent occurrence of packet block in the last input port will induce dramatic increase 
of the input queue length. Hence, packets experience very long latency, and performance is 
severely degraded for the last input port. To balance the performance of all input ports, a packet 
control algorithm is required, which is used to manage the space in the central buffer.  
 
III.A. Average Packet Delay for Each Input Port 
 
The goal of the packet control algorithm is to control the packet overall delays for different 
input ports, such that all input ports have almost the same average value. The basic concept is to 
reserve some central buffer space for the later input ports. The overall delay of a packet can be 
divided into two parts. The first part is the input buffer delay, and the second one is the packet 
latency inside the quasi-circuit switch.  
 
Assume that the probabilities for a packet destined to all output ports are the same. Then, 
according to Fig. 2, the average packet latency for a packet coming from input port i  to the 
desired output port is found to be  
 
1 ( 1) 1( ) ( ) (2 1) 1
2 2 2
F N F FL i N i F i
N
− − ×  = + − × + + × − −   ,             (3.1) 
First stage Central buffers
．．．．
4 4 3 3 2 2 1 1 1
4th bin3rd bin2nd bin1st bin
1 2 3
 12
delay of input port i  is )(iq , then we have the average overall packet delay being    
 
)()()( iqiLiD += .                              (3.2) 
 
For 1=i , we have the average overall packet delay being  
 
1 ( 1) 1(1) ( 1) 1 (1)
2 2 2
F N F FD N F q
N
− − ×  = + − × + + − +   .            (3.3) 
 
By taking input port 1 as a reference, we have the value of )(iq , that achieves the same average 
overall packet delay as input port 1, being 
 


 −×−+=
N
Fiqiq 11)1()1()( .                         (3.4) 
 
If the input buffer lengths of all input ports follow (3.4), the average overall packet delays for 
different input ports will be the same.  
 
III.B. Packet Control Algorithms 
 
In this sub-section, we use the average packet latency derived in pervious sub-section to 
propose two packet control algorithms – Packet Delay Control Algorithm 1 and Packet Delay 
Control Algorithm 2. The packet reservation algorithms will take the ideal input buffer lengths 
shown in (3.4) as references. Assume that the actual input queue length of input port i  at a 
specific time is )(ˆ iq . Then we define the exceeding parameter of input port i  as  
 
)()(ˆ)( iqiqiE −= .                             (3.5) 
 
For an input port with a larger value of )(iE , it has a higher priority for reserving the buffer 
space in the central buffers, in order to acquire the full link capacity. For example, if 4=N  and 
the order of the exceeding parameters is )1()2()3()4( EEEE ≥≥≥ , then input port 4 has the 
highest priority for reservation and input port 1 has the lowest priority for reservation. 
 
(A) Packet Delay Control Algorithm 1 
 
According to (3.5), the exceeding parameter )(iE  of each input port can be calculated. 
Then compare )(iE  for each input port. For an input port with a large value of )(iE , it means 
that this input port requires more reserved memory space (central buffer); thus this input port will 
be assigned a higher priority for central buffer reservation. For example, if 4N =  and 
 14
Packet Delay Control Algorithm 2 
z Find the input buffer length ˆ( )q i  of each input port.  
z According to (3.5), calculate the exceeding parameter )(iE  for each input port. 
z According to the exceeding parameters )(iE , decide the reservation priorities of all input 
ports. 
z According to (3.7), calculate the space reservation ratio ( , )R i j  for all bins of each input 
port. 
z According to the reservation priorities and the space reservation ratios, reserve the central 
buffer for each input port. 
 
The reservation process is assumed to be performed only for limited number of input ports. 
For the other ports with lower priorities, the remaining buffer space in the central buffers will be 
shared and reserved according to the queue lengths of the input buffers. For example, if the 
system is a 4×4 switch and there are 2 input ports with higher priorities performing the 
reservation process, the remaining buffer space will be shared by the other 2 input ports.  
 
III.C. Results and Discussions 
 
In this section, some simulation results are provided for performance evaluation. In the 
simulation, the system is assumed to be an 8×8 switch, and all input ports are assumed to be fully 
loaded, i.e. there are total FN ×  packets sent into the switch for every frame. Furthermore, the 
constraint of (r, T)-smooth has been released. The input traffic only bounded by the no 
overbooking condition for the average input rate. Furthermore, the distribution of the input traffic 
is assumed to be uniformly random. The simulation process is initiated when the system is empty, 
and is terminated when one million packets per input port have been successfully delivered to the 
correct output ports.  
 
Table 3.1 shows the theoretical and simulation results of the average packet latency in the 
switch for 8N =  and 50F = . It is found that the simulation results are very close to the 
theoretical results. This implies that the derivation of (3.1) is correct.  
 
Table 3.1.  Simulation results of the average packet switching delay for 8N =  and 50F = . 
Input port 1 2 3 4 
Simulation (slots) 553.03 509.31 465.53 421.85 
Theoretical (slots) 552.13 508.38 464.63 420.88 
Input port 5 6 7 8 
Simulation (slots) 378.11 334.29 290.16 245.30 
Theoretical (slots) 377.13 333.38 289.63 245.88 
 
 16
Algorithm 2 with 8N =  and 50F = . The mechanism with reservation for 2 input ports shows 
large values of standard deviation for all input ports; whereas the mechanism with reservation for 
4 input ports shows small values of standard deviation. This implies that consistent performance 
is guaranteed for different packets on different input ports when the mechanism with reservation 
for 4 input ports is applied. 
 
Table 3.4. Standard deviation of the packet overall delay for Packet Delay Control Algorithm 2 
with 8N =  and 50F = . 
Standard deviation (slots) Reserve for 2 ports Reserve for 4 ports 
Input port 1 30.602 0.963347 
Input port 2 25.4577 2.60198 
Input port 3 2.6086 1.76955 
Input port 4 17.2743 2.44813 
Input port 5 18.9862 1.4026 
Input port 6 27.7727 0.662177 
Input port 7 21.2931 1.52275 
Input port 8 26.6581 0.315871 
Average standard deviation 
of entire system 
21.3316 1.4608 
 
Since Packet Delay Control Algorithm 2 has a better performance than Packet Delay Control 
Algorithm 2, we focus only on the performance of Packet Delay Control Algorithm 2 in the 
following. Fig. 3.3 shows the average packet overall delay of the entire system versus frame size 
for different control schemes. For the case without any control mechanism, it has the smallest 
average packet overall delay. If the packet control mechanism is introduced, the performance will 
degrade. However, the degradation is inversely proportional to the value of frame size F , and is 
insignificant for 90=F .  
 
 18
St
an
da
rd
 d
ev
ia
tio
n 
(s
lo
ts
)
Frame size F
no control
reserve for 2 input ports
reserve for 3 input ports
reserve for 4 input ports
10 20 30 40 50 60 70 80 90
0
50
100
150
200
250
300
 
Fig. 3.4. Standard deviation of packet overall delay versus frame size for different control 
schemes. 
 
Fig. 3.5 shows the maximum queue length versus frame size for different control algorithms. 
Without any control mechanism, the switch system will have an extremely large maximum queue 
length, which means that a very large input buffer is essential in order to prevent any packet loss. 
On the other hand, the maximum queue length is greatly reduced when a packet delay control 
mechanisms is applied, especially for Packet Delay Control Algorithm 2.  
 
 20
A
ve
ra
ge
 d
el
ay
 (s
lo
ts
)
Input port number i
no control
reserve for 2 input ports
reserve for 3 input ports
reserve for 4 input ports
1 2 3 4 5 6 7 8
200
400
600
800
1000
1200
1400
 
Fig. 3.6. Average packet overall delay versus input port number for different control schemes 
with 50=F . 
 
Fig. 3.7 shows the standard deviation of packet overall delay versus input port number for 
different control schemes with 50=F . For the case without any control mechanism, each input 
port has large standard deviation, except for input port 1. For the mechanism with reservation for 
3 or 4 input ports, the standard deviation is almost zero. This implies that the packet overall delay 
is almost the same for all ports.  
 
 22
by using the packet control mechanism, the average packet overall delay is almost the same for 
each input port. This implies that the packet control mechanism can control the packet delay very 
well. Fig. 3.9 shows the standard deviation of the average packet overall delay versus input port 
number for different control schemes with 8N =  and 50F = . By applying the packet control 
mechanism, the standard deviation of the average packet overall delay is very small for each 
input port.  
 
1 2 3 4 5 6 7 8
0
2000
4000
6000
8000
10000
12000
Input port number
A
ve
ra
ge
 d
el
ay
 (s
lo
ts
)
No control
Reserve for 1 port
Reserve for 2 ports
Reserve for 8 ports
 
Fig. 3.8.  Average packet overall delay versus input port number for 8N =  and 50F = . 
 
 24
10 20 30 40 50 60 70 80 90 100
500
1000
1500
2000
2500
3000
3500
Frame size
A
ve
ra
ge
 d
el
ay
 (s
lo
ts
)
No control
Reserve for 1 port
Reserve for 2 ports
Reserve for 8 ports
 
Fig. 3.10.  Average packet overall delay versus frame size for different control schemes with 
8N = . 
10 20 30 40 50 60 70 80 90 100
0
500
1000
1500
2000
2500
3000
3500
Frame size
S
ta
nd
ar
d 
de
vi
at
io
n 
(s
lo
ts
)
No control
Reserve for 1 port
Reserve for 2 ports
Reserve for 8 ports
 
Fig. 3.11.  Standard deviation of the average packet overall delay versus frame size for different 
control schemes with 8N = . 
 26
10 20 30 40 50 60 70 80 90 100
0
2000
4000
6000
8000
10000
12000
14000
Frame size
M
ax
im
um
 q
ue
ue
 le
ng
th
 (s
lo
ts
)
No control
Reserve for 1 port
Reserve for 2 ports
Reserve for 8 ports
 
Fig. 3.13.  Maximum queue length versus frame size for different control schemes with 8N = . 
 
In order to further investigate the performance of the packet control algorithm, we consider a 
more severe scenario. Table 3.5 shows the standard deviations for different traffic pattern with 
different frame sizes. It is found that the standard deviation is proportional to the frame size. The 
standard deviation of the uniformly random distribution is always smaller than that of the Pareto 
distribution for different frame sizes. By controlling the standard deviation of input traffic 
patterns, we can have an input traffic pattern with a distribution more severe than the Pareto 
distribution. In the following simulation results, the standard deviation of the severe traffic 
pattern is set to be two times of that of the Pareto distribution.      
 
Table 3.5.  Standard deviations for different traffic pattern. 
 Uniformly random distribution Pareto distribution 
Frame size = 10 0.783 1.321 
Frame size = 20 1.178 2.052 
Frame size = 30 1.508 2.533 
Frame size = 40 1.648 2.946 
Frame size = 50 1.848 3.354 
Frame size = 60 2.043 3.692 
Frame size = 70 2.236 3.983 
Frame size = 80 2.341 4.237 
 28
10 20 30 40 50 60 70 80 90 100
0
0.1
0.2
0.3
0.4
0.5
Frame size
R
at
io
 o
f s
ta
nd
ar
d 
de
vi
at
io
n
Uniform distribution
Pareto distribution
Large variance
 
Fig. 3.15.  The ratio of the standard deviation of the average packet overall delay versus frame 
size for Packet Delay Control Algorithm 2 with reservation of 1 input port. 
 
 
 
 30
shown in Fig. 4.2(c). By using the recursive construction way, an N×N switch can be decomposed 
into multiple stages, each of which consists of N/2 2×2 SEs. 
 
4×4
O 1
O 2
O 3
O 4
I 1
I 2
I 3
I 4
2×2 2×2
2×2 2×2
(a)
8×8
(b) O 1
O 2
O 3
O 4
I 1
I 2
I 3
I 4
2×2
4×4
2×2
O 5
O 6
O 7
O 8
I 5
I 6
I 7
I 8
2×2
4×4
2×2
N×N
(c) O 1I 1 2×2
O NI N 2×2
… …
2
N× 2
N
2
N× 2
N…
N/2 SEs…
…
…
… …
 
Fig. 4.2.  Banyan-based architecture: (a) 4×4 switch, (b) 8×8 switch, and (c) N×N switch. 
 
Under the −),( Tr smooth constraint, no internal blocking occurs in a load balanced 
Birkoff-von Neumann quasi-circuit switch [15]. However, for any 2×2 switch fabric in the 
proposed architecture, packet lost may occur when there are more than F  packets destined to 
the same output link. In order to maintain the non-blocking property, speeding up the internal 
links is generally applied to the design of high speed switches. In this work the internal link speed 
is speeded up to two times of the external link speed. In other words, if the maximum achievable 
link capacity is R , then the external input and output link speeds will be limited to 2R . In 
addition, the size of the central buffers in all stages is increased from F  to F2 , except for the 
central buffers in the last stage. In such a way, even when all the arriving packets of a 2×2 SE are 
destined to the same output link, the central buffers will not be overflowed. In other words, no 
internal blocking occurs in each 2×2 SE. 
 
The operation of the Banyan-based quasi-circuit switching is illustrated by an 8×8 switch, as 
shown in Fig. 4.3. The number of time slots in a frame is assumed to be 4=F , and the arriving 
packets are assumed to be bursty. The number corresponding to an input packet is its destination 
port. For each 2×2 SE, the numbers in the range (shown in brackets) are the possible destinations 
of the packets passing through this SE. For example, the possible destinations of all the SEs in the 
first stage are in the range [1, 8], and each SE in the last stage has only two possible destinations. 
In (4.1), the input/output traffic patterns are shown in a matrix form.  
 
 32
 
Switching Algorithm 1 
The SEs in the first stage are divided into two equal sets: the upper set and the lower set, e.g. 
(SW1-1, SW1-2) and (SW1-3, SW1-4) for an 8×8 switch.  
z For an SE in the upper set, a packet destined to [1, 2N ] is switched to the upper output 
link; otherwise, it is switched to the lower output link. 
z For an SE in the lower set, a packet destined to [1, 2N ] is switched to the lower output 
link; otherwise, it is switched to the upper output link. 
 
Now we consider the architecture of a 16×16 switch. According to Fig. 4.2(c), a 16×16 
switch is decomposed into two stages: one consists of 8 2×2 SEs and the other consists of two 
8×8 switches. Consequently, we have the architecture of a 16×16 switch as shown in Fig. 4.4. 
Assumed that each frame also has four time slots and that the input traffic is in a uniform burst 
mode, as shown in (4.2). After the process of Switching Algorithm 1, it was found that some 
input traffic patterns may induce internal blocking in the two 8×8 switches. For example, there 
are 8 packets get into the first SE in Stage 2, i.e., [1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]. All 
these packets must be delivered into the first SE in Stage 3 in order to successfully deliver all 
packets to the correct destinations. Since the link capacity can handle only 4 packets, there are 4 
packets internally blocked in the first SE in Stage 2. In other words, if more than 2F  packets 
destined to output links O1-O4 concentrate in the input links I1, I2, I9 and I10, then the first SE 
in the Stage 2 will be poured into more than 2F  packets destined to the same 4×4 switch, 
inducing internal blocking in this SE.  
 




























16161616
15151515
12121212
11111111
8888
7777
4444
3333
14141414
13131313
10101010
9999
6666
5555
2222
1111
  ⇒   




























1313131314141414
1515151516161616
999910101010
1111111112121212
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
77778888
55556666
33334444
11112222
  ⇒   




























00000000
1515151516161616
00000000
00000000
00000000
00000000
1111111112121212
00000000
55556666
00000000
00000000
00000000
00000000
00000000
00000000
11112222
 
 34
 
Fig. 4.4.  Original 16×16 Banyan-based quasi-circuit switch. 
 
To cope with this internal blocking problem, an additional stage of SEs is required in order 
to re-distribute the input traffic. As shown in Fig. 4.5, we have the new architecture for a 16×16 
switch. The second stage is added to re-distribute the input traffic. The switching process of each 
SE in a re-distribution stage is almost the same as that shown in Switching Algorithm 1, except 
that there is no packet loss in each SE. The switching algorithm for the SEs in a re-distribution 
stage is shown as follows.  
 
Switching Algorithm 2 
The SEs in a re-distribution stage are divided into two equal sets: the upper set and the lower 
set.  
z For an SE in the upper set, a packet destined to [1, 4N ] is preferentially switched to the 
1,1,1,1 
2,2,2,2 
5,5,5,5 
6,6,6,6 
9,9,9,9 
10,10,10,10 
13,13,13,13 
14,14,14,14 
3,3,3,3 
4,4,4,4 
7,7,7,7 
8,8,8,8 
11,11,11,11 
12,12,12,12 
15,15,15,15 
1,1,1,1 
2,2,2,2 
5,5,5,5 
6,6,6,6 
11,11,11,11
12,12,12,12
15,15,15,15
(1~16) 
(1~16) 
(1,2) 
(3,4) 
(1~8) 
(1~8) 
(1~4) 
(1~4) 
(1~16) 
(1~16) 
(5,6) 
(7,8) 
(1~8) 
(1~8) 
(5~8) 
(5~8) 
(1~16) 
(1~16) 
(9,10) 
(11,12) 
(9~16)
(9~16)
(9~12)
(9~12)
(1~16) 
(1~16) 
(13,14) 
(15,16) 
(9~16)
(9~16)
(13~16)
(13~16)
16,16,16,16 16,16,16,16
Input 
packets 
Stage 1 Stage 2 Stage 3 Stage 4 Output 
packets 
Internal 
blocking
Internal 
blocking
 36




























16161616
15151515
12121212
11111111
8888
7777
4444
3333
14141414
13131313
10101010
9999
6666
5555
2222
1111
  ⇒   




























1313131314141414
1515151516161616
999910101010
1111111112121212
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
77778888
55556666
33334444
11112222
  ⇒   




























999910101010
1515151516161616
1313131314141414
1111111112121212
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
33334444
55556666
77778888
11112222
   
⇒   




























00000000
1515151516161616
00000000
1313131314141414
999910101010
00000000
1111111112121212
00000000
55556666
00000000
77778888
00000000
00000000
33334444
00000000
11112222
  ⇒   




























00000000
1515151516161616
00000000
1313131314141414
1111111112121212
00000000
999910101010
00000000
77778888
00000000
55556666
00000000
00000000
33334444
00000000
11112222
  ⇒   




























16161616
15151515
14141414
13131313
12121212
11111111
10101010
9999
8888
7777
6666
5555
4444
3333
2222
1111
  (4.3) 
 
Regarding the problem of finding the routing path in each SE, it can be easily achieved by 
using the concept of self-routing. According to the destination, each packet is assigned a packet 
header, which is a sequence of binary numbers identifying the preferential output links in all 
stage. Based on the above-mentioned switching algorithms and the packet header, each SE can 
deliver a packet to the correct output link. 
 
 38
 
Fig. 4.6.  The architecture of a 3232×  Banyan-based quasi-circuit switch. 
 
Now we consider the N×N Banyan-based quasi-circuit switch. Since the re-distribution 
stages are required, the architecture shown in Fig. 4.2(c) is infeasible. A new architecture for an 
N×N Banyan-based quasi-circuit switch is shown in Fig. 4.7. For any 2×2 SE in the first stage of 
an (N/2)×(N/2) switch, the input packets in a frame must contains no more than F2  packets 
destined to the same (N/4)×(N/4) switch in order to avoid the internal blocking. The maximum 
possible number of packets destined to an (N/4)×(N/4) switch is 4NF  under the no 
overbooking condition. These packets should be uniformly re-distributed in the preceding 
re-distribution stages. The worse case is that all these packets are switched to the same SE. Since 
each re-distribution stage can re-distribute F2  packets, there should be 
( ) 18224 −=− NFFNF  re-distribution stages. Therefore, we can infer that the number of 
total stages required for an N×N switch is 
 
( ) 22 8181 NNN SNSNS +=+−+= .                    (4.4) 
(1~32) 
(1~32) 
(1~32)
(1~32) 
(17~32) 
 
(1~16) 
 
 
 
 
 
 
 
 
(1~32) 
(1~32) 
(1~32) 
(1~32) 
(1~32) 
(1~32) (17~32) 
(17~32)
(17~32)
(17~32)
(17~32)
(17~32) 
(17~32) 
 
16×16
switch
 
16×16
switch
 
2F-a 
a+1 
2F-a 2F-a 2F-a 
2F+a-b 2F+a-b 2F+a-b 
b+1 
2F+b-c 2F+b-c 
c+1 
2F+c-d 
d+1 
(1~16) 
(1~16) 
(1~16) 
(1~16)
(1~16)
(1~16)
(1~16)
(1~16)
(1~16)
(1~16)
(1~16)
(1~16)
(1~16)
(1~16)
(1~16) 
(1~16) 
(1~16) 
(1~16) 
(1~16) 
(1~16) 
(1~16) 
 40
the maximum packet delay will be increased by an extra frame time for re-sequencing. The 
theoretical maximum packet delays of these two architectures are shown in Table 4.1. It was 
found that the maximum packet delay of Banyan-based architecture is smaller than that of the 
load balanced Birkoff-von Neumann architecture for the switch dimension larger than 16×16. 
 
Table 4.1.  Comparison of the maximum packet delay for the load balanced Birkoff-von 
Neumann and Banyan-based architectures. 
 
Load balanced 
Birkoff-von Neumann
Banyan-based 
Dimension Max. delay 
No. of stages 
NS  
Max. delay 
maxD  
4×4 7 F 2 12 F 
8×8 15 F 3 18 F 
16×16 31 F 5 31 F 
32×32 63 F 9 55 F 
64×64 127 F 17 103 F 
128×128 255 F 33 199 F 
256×256 511 F 65 391 F 
 
Furthermore, we compare the performance of the Banyan-based scheme with that of the 
Benes-based scheme. Benes-based quasi-circuit switch is also composed of 2×2 frame based SEs 
with the memory access speed and the frame size of each stage being related to the input frame 
size. The theoretical maximum packet delays of these two architectures are shown in Table 4.2. 
The threshold (a) shows the frame size threshold that makes the Banyan-based architecture have a 
better maximum packet delay performance than that of the Benes-based architecture. For 
example, for an 8×8 switch, the maximum packet delay of Banyan-based architecture is smaller 
than that of the Benes-based architecture when the frame size F  is smaller than 180. Since the 
memory access speed is a major concern for high speed switch, we also compare the link capacity 
(the memory access speed) between these two architectures. The threshold (b) shows the frame 
size threshold that makes the Banyan-based architecture have a smaller maximum memory access 
speed than that of the Benes-based architecture. For example, for a 64×64 switch, the maximum 
memory access speed of Banyan-based architecture is smaller than that of the Benes-based 
architecture when the frame size F  is smaller than 248. Finally, considering the hardware cost, 
we also compare the required number of stages for these two architectures. For the cases with a 
switch dimension smaller than 32×32, the hardware cost of the Banyan-based architecture is 
smaller than or equivalent to that of the Benes-based architecture. This implies that the 
Banyan-based architecture is more cost efficient than the Benes-based architecture for a small 
switch dimension.  
 
 42
4x4 8x8 16x16 32x32 64x64 128x128 256x256
102
103
104
105
106
size of input/output port
m
ax
. d
el
ay
LBS
LBT
BYS
BYT
 
Fig. 4.8.  Performance comparison for the maximum packet delay (Traffic pattern: uniform; 
Frame size = switch dimension). 
4x4 8x8 16x16 32x32 64x64 128x128 256x256
102
103
104
105
106
size of input/output port
m
ax
. d
el
ay
LBS
LBT
BYS
BYT
 
Fig. 4.9.  Performance comparison for the maximum packet delay (Traffic pattern: uniform burst; 
Frame size = switch dimension). 
 44
 
Fig. 4.12 – Fig. 4.15 show the results of the average packet delay versus switch dimension. 
The input traffic pattern is assumed to be uniform or uniform burst, and the frame size F  is 
assumed to be 64 or the same as the switch dimension. It was found that the average packet 
delays of the Banyan-based architecture are slightly worse than that of the load-balanced 
architecture. However, the difference is negligible for a switch with a large switch dimension.  
 
4x4 8x8 16x16 32x32 64x64 128x128 256x256
102
103
104
105
size of input/output port
av
g.
 d
el
ay
LBS
BYS
 
Fig. 4.12.  Performance comparison for the average packet delay (Traffic pattern: uniform; 
Frame size = switch dimension). 
 
 46
4x4 8x8 16x16 32x32 64x64 128x128 256x256
103
104
size of input/output port
av
g.
 d
el
ay
LBS
BYS
 
Fig. 4.15.  Performance comparison for the average packet delay (Traffic pattern: uniform burst; 
Frame size = 64). 
 
Fig. 4.16 shows the results of the standard deviation of the average packet delay versus 
switch dimension. The frame size is assumed to be 64=F . It was found that the Banyan-based 
architecture has a standard deviation much smaller than that of the load-balanced architecture, 
especially when the switch dimension is large. This implies that the overall packet delay for the 
Banyan-based architecture can be well controlled and predicted when a packet passes through a 
network with multiple switches. 
 
 
 48
0 2 4 6 8 10 12 14 16
600
800
1000
1200
1400
1600
input port number :
av
g.
 d
el
ay
(LBS)
(BYS)
 
Fig. 4.17.  The average delay versus the input port number for 64=F . 
 
Now we compare the packet delay performance between Banyan-based architecture and 
Benes-based architecture. The comparison between these two architectures is based on the 
assumption that the maximum link speed is the same. For Benes-based architecture, the 
simulation results are denoted as “BNS”. Fig. 4.18 – Fig. 4.23 show the results of the maximum 
packet delay versus frame size F . The input traffic pattern is assumed to be uniform or uniform 
burst, and the switch dimension is assumed to be 4×4, 16×16 or 64×64. It is found that the 
maximum packet delay of Banyan-based architecture is smaller than that of Benes-based 
architecture for the cases with a small frame size F . However, the superiority of the 
Banyan-based architecture declines, when the frame size F  increases. Finally, the performance 
of Banyan-based architecture becomes worse than that of Benes-based architecture.    
 
 50
5 20 35 50 65 80 95 110 125 140 155 170
0
500
1000
1500
2000
2500
3000
3500
4000
frame size
m
ax
. d
el
ay
BYS
BNS
 
Fig. 4.20.  Performance comparison for the maximum packet delay (Traffic pattern: uniform; 
Switch dimension: 16×16). 
 
0 20 35 50 65 80 95 110 125 140 155 170
0
500
1000
1500
2000
2500
3000
3500
4000
frame size
m
ax
. d
el
ay
BYS
BNS
 
Fig. 4.21.  Performance comparison for the maximum packet delay (Traffic pattern: uniform 
burst; Switch dimension: 16×16). 
 52
 
Fig. 4.24 – Fig. 4.26 show the results of the average packet delay versus frame size F . The 
input traffic pattern is assumed to be uniform, and the switch dimension is assumed to be 4×4, 
16×16 or 64×64. The phenomena similar to that shown in Fig. 4.18 – Fig. 4.23 are observed. 
Banyan-based architecture still outperforms the Benes-based architecture for the cases with a 
small frame size F .  
 
0 4 8 12 16 20 24 28 32 36 40 44
0
50
100
150
200
250
300
350
400
frame size
av
g.
 d
el
ay
BYS
BNS
 
Fig. 4.24.  Performance comparison for the average packet delay (Traffic pattern: uniform; 
Switch dimension: 4×4). 
 54
 
V. Conclusions 
 
In this work, we have developed the theory of quasi-circuit switching and the associated 
methods of building quasi-circuit switches. Quasi-circuit switching can provide quality of 
services at the time scale of frames while achieving statistical multiplexing gain within frames. 
We have also shown that quasi-circuit switches can be easily built based on the classical switch 
architectures, such as the shared memory switch architecture and the crosspoint buffered switch 
architecture.  
 
Since the (r, T)-smooth assumption strongly restricts the average throughput of the entire 
system, we release the constraint of (r, T)-smooth in order to improve system throughput. By 
adding input buffer at each input port, there is no packet loss even when the input traffic load is 
100%. Furthermore, to reduce the impact of bandwidth imbalance for different input ports, packet 
control algorithms are proposed to balance the performance of all input ports.   
 
Finally, considering the implementation issue, we have proposed the Banyan-based 
architecture for quasi-circuit switching. By using the recursive construction way, a Banyan-based 
quasi-circuit switch can be constructed by using multiple 2×2 switch elements. Hence, the 
implementation complexity can be greatly reduced. In addition, according to the numerical and 
simulation results, it was found that the performance of the Banyan-based architecture is better 
than that of the load-balanced architecture. Especially, the standard deviation of the average 
packet delay can be greatly reduced by applying the Banyan-based architecture. Therefore, the 
overall packet delay in a network can be well controlled and predicted. 
 
 
 
 
 56
[18] I. Keslassy, S-T Chuang, and N. McKeown, “A Load-Balanced Switch with an Arbitrary 
Number of Linecards,” Proc. IEEE INFOCOM, pp. 2007- 2016, March 2004. 
[19] N. McKeown, “The iSLIP Scheduling Algorithm for Input-Queued Switches,” IEEE 
Transactions on Networking, vol. 7, pp. 188-201, April. 
 
 
 
Banyan-based Architecture for Quasi-Circuit Switching 
 
 
Yuh-Ren Tsai, Member, IEEE,                                                Che-Wei Lo 
Institute of Communications Engineering,                               Cheertek Technology 
National Tsing Hua University                                          Hsinchu 300, Taiwan 
Hsinchu 300, Taiwan 
yrtsai@ee.nthu.edu.tw 
 
 
Abstract 
 
Load balanced Birkoff-von Neumann quasi-circuit 
switching was proposed to control the packet delay, as 
well as to solve the head-of-line blocking problem. 
Quasi-circuit switching, a frame based scheme, is 
proposed to provides guaranteed rate services. 
However, as the switch dimension increases, the 
maximum delay and the size of the one-cycle 
permutation matrices increase accordingly. In this 
work, a new architecture – Banyan-based quasi-circuit 
switching is proposed. A large dimension switch is 
decomposed into multiple 2×2 frame-based switching 
elements in order to reduce the implementation 
complexity. According to the numerical and simulation 
results, it was found that the performance of the 
Banyan-based architecture is better than that of the 
load-balanced architecture. Especially, the standard 
deviation of the average packet delay can be greatly 
reduced by applying the proposed architecture. 
Therefore, the overall packet delay in a network can be 
well controlled and predicted. 
Index Terms—Birkhoff-von Neumann Switches, 
Quasi-circuit Switching, Multi-stage Switches, Quality 
of Services, Packet Delay Control. 
 
1. Introduction 
 
Recently, many research works have focused on 
building high speed switches. In [1]-[2], the Birkoff-
von Neumann switch is proposed to settle the head-of-
line (HOL) blocking problem. The multi-stage load 
balanced Birkoff-von Neumann switch is proposed to 
avoid the restriction on the switch dimension due to 
the memory access speed limitation, and to solve the 
HOL blocking problem with low computational 
complexity [3]-[4]; however it does not guarantee the 
quality of service (QoS), such as the packet delay. A 
new switching type – frame based load balanced 
Birkoff-von Neumann quasi-circuit switching was 
proposed to control the packet delay, as well as to 
solve the HOL blocking problem [5]-[6]. Quasi-circuit 
switching is a frame based scheme, which provides 
guaranteed rate services with both the maximum delay 
and the size of the central buffers being bounded by 
constant values. However, the maximum delay and the 
size of the one-cycle permutation matrices dramatically 
increase in accordance with the switch dimension. 
Considering the implementation issue, a large 
dimension switch is generally implemented by 
integrating multiple small dimension elements in order 
to reduce the implementation complexity. In this work, 
we propose a new architecture based on Banyan 
switching for load balanced Birkoff-von Neumann 
quasi-circuit switching. A switch with a large 
dimension is decomposed into several 2×2 frame-
based switching elements. The remainder of this paper 
is organized as follows. Section 2 briefly introduces 
the concept of load balanced Birkoff-von Neumann 
quasi-circuit switching. Section 3 concentrates on the 
implementation of Banyan-based quasi-circuit switch. 
In Section 4 the simulation and numerical results are 
presented to verify the performance of the proposed 
architecture. Finally, conclusions are drawn in Section 
5.  
 
2. Load Balanced Quasi-circuit Switching 
 
For a quasi-circuit switched network, time is 
partitioned into multiple frames with the frame 
duration assumed to be T . Each frame is sub-divided 
into a fixed number, assumed to be F , of time slots, 
each of which contains one packet from a specific user. 
Furthermore, the no overbooking condition is assumed This work was supported in part by the National Science 
Council, Taiwan, R.O.C., under Grants NSC 93-2213-E-007-
042 and NSC 94-2213-E-007-008  
will not be overflowed. In other words, no internal 
blocking occurs in each 2×2 SE. 
The operation of the Banyan-based quasi-circuit 
switching is illustrated by an 8×8 switch, as shown in 
Fig. 3. The number of time slots in a frame is assumed 
to be 4=F , and the arriving packets are assumed to 
be bursty. The number corresponding to an input 
packet is its destination port. For each 2×2 SE, the 
numbers in the range (shown in brackets) are the 
possible destinations of the packets passing through 
this SE. For example, the possible destinations of all 
the SEs in the first stage are in the range [1, 8], and 
each SE in the last stage has only two possible 
destinations. In (1), the input/output traffic patterns are 
shown in a matrix form. 
















⇒
















⇒
















⇒
















8888
7777
6666
5555
4444
3333
2222
1111
00000000
77778888
55556666
00000000
33334444
00000000
00000000
11112222
55556666
77778888
00000000
00000000
00000000
00000000
33334444
11112222
8888
7777
4444
3333
6666
5555
2222
1111
(1) 
Since the internal link speeds are speeded up, the 
second and third matrixes are 8×8 matrixes. For an 
input traffic matrix Ψ , the element ji,Ψ , for 
Ni ,,1L=  and Fj ,,1L=  or F2 , represents the 
destination of the packet coming from the i-th input 
port at the j-th slot. If there is no packet coming from 
the i -th input port at the j-th time slot, this element is 
set to 0, =Ψ ji . According to Switching Algorithm 1, 
the output traffic pattern of the first stage is shown in 
the second matrix of (1). All the packets entering the 
upper 4×4 switch have the destinations in the range 
from O1 to O4; whereas, the destinations are in the 
range from O5 to O8 for those packets entering the 
lower 4×4 switch. Afterward, these two 4×4 switches 
properly deliver all packets to the correct destinations.  
The switching algorithm for the SEs in the first 
stage is shown as follows. 
 
Switching Algorithm 1 
The SEs in the first stage are divided into two equal 
sets: the upper set and the lower set, e.g. (SW1-1, 
SW1-2) and (SW1-3, SW1-4) for an 8×8 switch.  
z For an SE in the upper set, a packet destined to 
[1, 2N ] is switched to the upper output link; 
otherwise, it is switched to the lower output link. 
z For an SE in the lower set, a packet destined to 
[1, 2N ] is switched to the lower output link; 
otherwise, it is switched to the upper output link. 
 
Now we consider the architecture of a 16×16 switch. 
According to Fig. 2(c), a 16×16 switch is decomposed 
into two stages: one consists of 8 2×2 SEs and the 
other consists of two 8×8 switches. However, it was 
found that some input traffic patterns may induce 
internal blocking in the two 8×8 switches. For example, 
if all the packets destined to O1-O4 concentrate in the 
input links I1, I2, I9 and I10, then the top SE in the 
second stage will be poured into F4  packets destined 
to the same 4×4 switch, inducing internal blocking in 
this SE. Hence, at least one extra stage is required in 
order to re-distribute the input traffic. As shown in Fig. 
4, the second stage is added to re-distribute the input 
traffic. The switching algorithm for the SEs in a re-
distribution stage is shown as follows. 
 
Switching Algorithm 2 
The SEs in a re-distribution stage are divided into 
two equal sets: the upper set and the lower set.  
z For an SE in the upper set, a packet destined to 
[1, 4N ] is preferentially switched to the upper 
output link; otherwise it is preferentially 
switched to the lower one.  
z For an SE in the lower set, a packet destined to 
[ 2N +1, 43N ] is preferentially switched to the 
lower output link; otherwise, it is preferentially 
switched to the upper one. 
z However, if the preferential output link has been 
fully occupied in the central buffer, a packet will 
be switched to the other output link. 
[1,16] [1,8]
Stage 1 Stage 2 Stage 3
8×8 switch
I1
4×4
switch
I2
I9
I10
2F–a O1
O2
O3
O4[1,16]
[1,16]
[1,16]
[1,16]
[1,16]
[1,16]
[1,16]
[1,8]
2F+a+1
[1,8]
[1,8]
[9,16]
[9,16]
[9,16]
[9,16]
[1,8]
2F+1
[1,8]
[1,8]
[1,8]
[9,16]
[9,16]
[9,16]
[9,16]
4×4
switch
4×4
switch
4×4
switch
O5
O6
O7
O8
O9
O10
O11
O12
O13
O14
O15
O16
I3
I4
I5
I6
I7
I8
I11
I12
I13
I14
I15
I16
2F–a
a+1
Fig. 4.  A 16×16 Banyan-based quasi-circuit switch. 
Birkoff-von Neumann architecture for the switch 
dimension larger than 16×16. 
 
TABLE 1.  COMPARISON OF THE MAXIMUM PACKET DELAY  
 
Load balanced 
Birkoff-von 
Neumann 
Banyan-based 
Dimension Max. delay 
No. of stages 
NS  
Max. delay 
maxD  
4×4 7 F 2 12 F 
8×8 15 F 3 18 F 
16×16 31 F 5 31 F 
32×32 63 F 9 55 F 
64×64 127 F 17 103 F 
128×128 255 F 33 199 F 
256×256 511 F 65 391 F 
 
4. Simulation and Numerical Results 
 
The simulation and numerical results are provided 
to evaluate the performance of the proposed Banyan-
based quasi-circuit switch. We assume that all links are 
well synchronized and full loaded, i.e. there are F  
packets coming from an input link in a frame time. The 
input traffic pattern, assumed to be uniformly random, 
satisfies the no overbooking condition and the 
−),( Tr smooth constraint. For the load- balanced 
architecture, the theoretical and simulation results are 
denoted as “LBT” and “LBS”, respectively. For the 
proposed Banyan-based architecture, the theoretical 
and simulation results are denoted as “BYT” and 
“BYS”, respectively. The comparison between these 
two architectures is based on the assumption that the 
maximum link speed is the same. 
Fig. 6 shows the results of the maximum packet 
delay versus switch dimension. The frame size F  is 
assumed to be the same as the switch dimension, e.g. 
16=F  for a 16×16 switch. For the load-balanced 
architecture, it was found that the simulation results are 
the same as the theoretical ones. On the other hand, for 
the Banyan-based architecture, the simulation results 
are much smaller than the theoretical ones. The 
theoretical value will be achieved only when a packet 
always experiences the maximum packet delay in all 
stages. However, this situation will generally not 
happen for a switch with a large dimension. 
Furthermore, the maximum packet delay of the 
Banyan-based architecture will be smaller than that of 
the load-balanced architecture when the switch 
dimension is equal to or larger than 16. 
Fig. 7 shows the results of the average packet delay 
versus switch dimension. The frame size F  is assumed 
to be the same as the switch dimension. It was found 
that the average packet delays of the Banyan-based 
architecture are slightly worse than that of the load-
balanced architecture. However, the difference is 
negligible for a switch with a large switch dimension. 
Fig. 8 shows the results of the standard deviation of 
the average packet delay versus switch dimension. The 
frame size is assumed to be 64=F . It was found that 
the Banyan-based architecture has a standard deviation 
much smaller than that of the load-balanced 
architecture, especially when the switch dimension is 
large. This implies that the overall packet delay for the 
Banyan-based architecture can be well controlled and 
predicted when a packet passes through a network with 
multiple switches. 
Fig. 9 shows the results of the average delay versus 
the input port number for a 16×16 switch. The frame 
size is assumed to be 64=F . For the load-balanced 
architecture, the average packet delay is inversely 
proportional to the input port number. That is, input 
Switch Dimension
M
ax
im
um
 p
ac
ke
t d
el
ay
 (t
im
e 
sl
ot
)
4×4 8×8 16×16 32×32 64×64 128×128 256×256
10 6
LBS
LBT
BYS
BYT
10 5
10 4
10 3
10 2
Fig. 6.  Performance comparison for the maximum packet 
delay. 
Switch Dimension
A
ve
ra
ge
 p
ac
ke
t d
el
ay
 (t
im
e 
sl
ot
)
10 5
10 4
10 3
10 2 LBS
BYS
4×4 8×8 16×16 32×32 64×64 128×128 256×256
Fig. 7.  Performance comparison for the average packet 
delay. 
  B-1
附錄 B 
 
 
 
出席國際學術會議心得報告 
 
  B-3
綜觀此次會議的議題，可以發現有幾個研究方向是目前相當熱門的研究主題，例如 
MIMO (Multi-Input Multi-Output) 技術就有達到九個議程，多達 64 篇論文在此會議中發
表，顯見此研究主題所受到的重視；其中有多篇論文是有關於 space-time coding (STC) 在
不同系統中的設計與分析，由於 STC 特性十分複雜，系統化的設計碼架構具有較高的困難
度，因此大部分的研究主要都致力於研究方塊碼 (block code) 的架構，因為方塊碼具有比
較簡單的編碼、解碼結構，因此比較容易針對不同的系統設計出具有 diversity gain 及 
coding gain 的大尺度 STC。 
 
另一個重要研究主題是 OFDM (Orthogonal Frequency Division Multiplexing) 技術，共
有六個議程，多達  40 篇論文在此會議中發表；其中  MIMO-OFDM 技術、同步 
(Synchronization) 技術、通道估測 (Channel Estimation) 技術、及其他系統的應用技術 (包
括極寬頻 (Ultra-wide Band, UWB) 系統、無線區域網路 (WLAN) 系統、及無線都會網路 
(WMAN)系統) 等，都是相當重要的研究內容。 
 
另一個重要研究主題是 CDMA (Code Division Multiple Access) 技術，共有四個議程，
多達 36 篇論文在此會議中發表；其中 MC-CDMA (Multi-Carrier Code Division Multiple 
Access) 技術、Multi-user detection receiver 設計、極寬頻 (UWB) 系統應用技術等，都是
相當重要的研究內容。 
 
另外一個重要研究主題就是 MUD (Multi-user detection) 技術，共有四個議程，多達 20 
篇論文在此會議中發表；其中針對 CDMA 系統、MC-CDMA 系統、OFDM 系統等的多用
戶偵測接收是主要的研究重點，而 MIMO 與多用戶偵測接收的混合技術也是受到矚目的
重點。 
 
最後一個重要研究主題就是 WLAN/3G Interworking 技術，共有三個議程，多達 15 篇
論文在此會議中發表；此議題的受重視顯現出不同系統整合的重要性，特別是高速移動的
第三代行動通訊系統與低速移動的無線區域網路系統，更是未來整合的重點值得進一步注
意。 
 
此次會議的確吸收到不少新技術的知識，對於未來的技術發展趨勢也有更進一步的了
解，對於未來的研究將有相當多的助益。 
 
 
PL?~, is a reference value corresponding to the propagation 
environment, d, is the propagation distance between the , -th 
BS and the MS, n is the path loss exponent and x, is a log- 
normal distributed random variable representing the shadowing 
effect, i.e. (in dB scale) is a Gaussian random variable 
with mean zero and variance u 2 .  Thus the average received 
coded symbol energy-to-total noise plus interference power 
spectral density ratio T,,,,,, (in dB scale) for conventional 
system is a Gaussian random variable with variance U *  and 
mean 
where N, is the one-sided power spectral density of received 
additive white Gaussian noise (AWGN) plus co-channel 
interference and T, is the symbol duration. 
C. Diversity Combining Scheme 
In this work, we propose two novel diversity combining 
schemes to improve the link performance. 
I )  Scheme A 
As shown in Fig. 1, the transmitted symbols are equally 
partitioned into three parts and each part is transmitted by a 
single BS, i.e. BSj will transmit the j -th symbol for every 
three symbols. Similarly, if the MS is in the M -way sofi 
handoff state, BS- ; , ;= 1 ,..., M , will transmit the j -th 
symbol for every M symbols. Due to the fact that the 
transmitted symbol rate of each forward link channel is 
reduced by a factor of M ,  the transmitted symbol energy will 
be M times as compared to the conventional CDMA systems. 
Thus, the average received coded symbol energy-to-total noise 
plus interference power spectral density ratio becomes 
where p. is the mean of T,,,,,,, in Scheme A. 
y,.,ldBI 
2 )  Scheme B 
Forward error correction (FEC) coding technique is 
generally adopted to combat with the noise and interference 
for wireless communication systems. Especially, the 
convolutional coding scheme with code rate R=1/2 or 113 is 
widely used for mobile cellular systems. In Scheme B, we 
combine the coding and soft handoff to improvement the 
system performance. If the original code rate of radio link is 
R=l /k  and the MS is in the M-way soft handoff state, we 
change the code rate to R'=l/(Mxk), i.e. the total transmitted 
coded symbol rate is increased by a factor of M . Due to the 
traffic is managed by M forward-link channels, the coded 
symbols are equally distributed into M BSs for transmission 
as shown in Fig. I .  
According to the convolutional coding scheme, there are 
total of l/R'=Mxk generator polynomials lo generate the 
~ 
&7803-8255-2/04/$20.M) @uM4 IEEE. 486 
coded symbols. Therefore, each BS only employs k distinct 
generator polynomials to generate the corresponding coded 
symbols and then transmits the outputs. For example, if the 
MS is in the three-way soft handoff state and the original code 
rate is R=1/2, the code rate in Scheme B becomes R'=1/6 
and each BS uses 2 distinct generator polynomials to generate 
the corresponding coded symbols. It is noted that the occupied 
bandwidth keeps the same as the conventional system. 
Furthermore, the transmitted symbol rate of each forward-link 
channel remains the same and thus the energy per coded 
symbol remains the same as  compared to the conventional 
system. Hence the average received coded symbol energy-to- 
total noise plus interference power spectral density ratio 
becomes 
p F , . ~ i d B l  ' p 7 , l d B ) '  (4) 
where p. is the mean of T,,,,,,, in Scheme B. 
y,.,!dRl 
111. DECODING ALGORITHMS 
In this work, we concentrate on BPSK modulation. 
Furthermore, we assume that prefect interleaving is applied and 
thus fading gains of adjacent coded symbols can be viewed as  
independent. 
A .  Scheme A 
In the receiver, the Viterbi decoding algorithm is applied to 
decode the received coded symbols [ 6 ] - [ 7 ] .  In Scheme A, each 
coded symbol is tixther divided into M sub-symbols and 
interleaving is applied. The received signal of a coded symbol 
is a multivariate Gaussian distributed random variable with 
distribution firnction [3],[5] 
where 1 and g. , for ;=I ,..., / , are the i -th received and 
transmitted symbols, respectively, I is the number of total 
symbols in a frame, K,, is the received k-th sub-symbol and 
a,,, is the fading gain of the k -th sub-symbol 
1) Hard decision 
If hard decision is applied, a decision of '1' or '0' is made 
prior to decode the received symbols. For the conventional 
scheme, every symbol is combined from M forward-link 
channels regardless of the diversity combining schemes. Thus 
the average coded symbol error probability p, for each coded 
symbol will be the same. However, in Scheme A, coded 
symbols obtained from different forward-link channels may 
experience different path losses and shadowing effects which 
bring on different average symbol error probabilities. Assume 
that the estimated average symbol error probability of the 
received symbols from BS-; is , = I ,  ..., M .  Then we have 
the log-likelihood function as  
IV. SIMULATION RESULTS 
In this work, the convolutional codes employed in Scheme 
A, Scheme B and conventional system are shown in Table 1. 
Table I. The psrameters of convolutional codes 
Parameters 
Conventional 
Scheme A 
Code rate Constrain length 
112 or 113 
Generator polynomials 
8 G, =[247,371]; 
112 or 113 R G, = 1225.33 I ,  3671; 
G, =[275,275,253,371,33I, 
(3-wayS.H.) 116 or 119 8 235,313,357,2471 
In the simulation results, the measure of system 
performance is the souce  bits error probability p, versus 
E,/N,,  where E, is the average received bit energy of each 
forward-link channel. Furthermore, we assume that each 
forward-link channel suffers the same path loss, yet may 
experience different shadowing effect. Fig. 2 shows the results 
of Scheme A and conventional scheme for code rate R=1/2 
and MS in 2-way soft handoff state. The results show that the 
performance of Scheme A (with CSI or without CSI) is slightly 
worse than conventional scheme (MRC with CSI or EGC 
without CSI), yet is better than SC scheme. This implies that 
Scheme A didn't provide better performance than conventional 
scheme. Thus we only focus on Scheme B. 
For Scheme B, Fig. 3 and Fig. 4 show the results of p, 
versus F,/N,  with original code rate R=1/2 for MS in 2-way 
and 3-way soft handoff states, respectively. The results show 
that soft decision outperforms hard decision and provides a 
3dB improvement in F , / N , .  Furthermore, MRC outperfom 
ECC and SC as we expected. As compared with conventional 
scheme, we found that Scheme B provides better performance 
under the same condition - with or without CSI. Especially, we 
found that the Scheme B without CSI has almost the same 
performance as conventional scheme with MRC. This implies 
that, even though the CSI is not available, Scheme B still 
provides the same performance as conventional MRC with CSI. 
If the CSI information is available for Scheme B, more than 
1dB improvement in E,/N, can be obtained. By comparing the 
results of Fig. 3 and Fig. 4, we found that an improvement of 
2.5 dB in E,/N,  can he obtained for MS in 3-way soft handoff 
state. This is mainly due to that the number of diversity branch 
is increase by 2 to 3 and thus the total average received bit 
energy is raised. 
Fig. 5 and Fig. 6 show the results of 4 versus E b / N f  with 
original code rate R=1/3 for MS in 2-way and 3-way soft 
handoff states, respectively. As compared with Fig. 3 and Fig. 
4, we found better performances due to the increase of code 
rate are obtained. Furthermore, about 1dB improvement in 
E,/N,  for Scheme B over conventional MRC can still be 
obtained, However, the performance of Scheme B without CS1 
is slightly worse than conventional MRC with CSI, yet is better 
than conventional EGC without CSI. 
It is noted that the consumptions of channel bandwidth and 
transmission power are the same for conventional scheme, 
Scheme A and Scheme B. Scheme B only slightly increases the 
hardware complexity of convolutional code decoding 
algorithm. However, about IdB improvement in Eb/N,  can be 
obtained for Scheme B as compared with conventional MRC. 
For conventional MRC, channel fading gain estimation is 
essential and will greatly increase the hardware complexity of 
receiver. Furthennore, the introduction of estimation errors will 
further degrade system performance. Thus Scheme B may 
outperform conventional MRC, even if the CSI is not available. 
V. CONCLUSIONS 
In this work, we have proposed two macroscopic diversity 
combining schemes for MS in soft handoff state. In the 
proposed Scheme B, we combine coding and soft handoff to 
improvement the system performance. The code rate is 
enhanced by multiple-link transmission for soft handoff and the 
consumptions of channel bandwidth and transmission power 
remain the same as compared with conventional system. 
Through the simulation results, we found that a 1dB 
improvement in E, /N ,  over conventional MRC can be 
obtained for Scheme B. Furthermore, due to the introduction of 
estimation errors of channel fading gain, Scheme B may 
outperform conventional MRC, even if the CSI is not available. 
Thus, as compared with conventional scheme, Scheme B can 
provide a better performance or eliminate the complexity of 
channel fading gain estimation with the cost of slightly 
increases the decoding complexity. 
111 
PI 
I31 
141 
[SI 
171 
L61 
REFERENCES 
Physical layer standard far cdma2000 spread spectmm systems, 3GPP2 
C.POOO2-A. 3rd Generation Partnership Project 2, October 1999. 
Technical Specification Group Radio Access Networks, 3G TS 2 5 . m  
(Release 1999), 3rd Generation Pamership Project, June 2000. 
Gordon L. Stuber, "Principles of Mobile Communication," Second 
Edition. 
W. Yung, "Probability of bit error for MPSK modulation with diversity 
reception in Rayleigh fading and Log-normal shadowing channel ", 
IEEE Troans. Cummun., ~01.38, pp.933-937, July 1990. 
Simon Haykin. "Communication Systems," 4' Edition. 
John G.  Proakis ''Digiml Communications," Founh Edition. 
Andrew J. Viterbi "Convolutional Codes and Their Performance in 
Communication Systems." LEE€ Trans. Cammun, October 1971, 
pp.75 1-772. 
0-7803-82ss-~w$20.w o m  IEEE. 488 
