  
摘    要 
 
ITS 的目標在於促進交通安全、減少擁擠、提高機動性、增進經濟生產力、減少環境衝
擊、提昇能源使用效率及帶動相關產業發展。而先進交通管理系統(Advanced Transportation 
Management System, ATMS)乃為 ITS 下之核心系統，其中最重要的乃是駕駛人所需即時交通
資訊之傳輸、交通控制中心須依即時收取之資料，將最正確的訊息與決策傳給用路人與路側
設施，此涉及許多技術專業如通訊、電機、資訊工程等與開發空間，且商機無限；在 ATMS 之
資料傳輸中，乃採用 NTCIP(National Transportation Communications for ITS Protocol)
作為其傳輸協定，為了與現行通用之通訊協定相結合而不致有所衝突，NTCIP 之堆疊(Stack)
亦依循 ISO-OSI(Open Systems Interconnect)之七層模型架構。 
採用 ISO-OSI 之模型架構使得 NTCIP 不至於與現行通訊協定不相容，但開放式的網路環
境也為 NTCIP 帶來許多安全性(Security)的問題，如駭客(Hacker)可在封包傳輸途中進行攔
截，並對其進行竄改、偽裝、重送等攻擊，然而在實際應用上，其資料的傳輸安全性卻往往
為人們所忽略。故本研究透過現行之密碼學相關技術，針對資料傳輸之確認性
(Authentication)、機密性(Confidentiality)與完整性(Integrity)等對傳輸訊息進行加密
保護，對於 ATMS 之傳輸建立ㄧ套安全機制，藉此提高 ATMS 之傳輸安全性。 
然而目前之加密技術主要是防止封包加密之安全性；在過去的加密技術中，加密過程演
算法金鑰(Key)是固定且無法變更，在資料傳輸過程中的安全性與加密金鑰(Encryption Key )
的長短成正比，然而加密金鑰越長雖然可以提供相對較高的安全性但卻也對於系統造成不可
忽略的負效用；有鑑於此本研究提供一套在不增加金鑰長度且可確保封包安全之可變動式加
密演算機制，我們稱此機制為動態加密技術(Dynamic Encryption Technique)。 
加解密對於系統亦會產生負效用，因此本研究尚進行實驗設計，以探討其封包於加密前
後之傳輸時間影響，並進行統計檢定，以確認封包加密對其之影響幅度，最後會依實驗結果
對於加密前後之封包於 LAN 之傳輸時間進行可靠度分析研究，以使得採用加密機制之交控中
心人員能夠依其所需之可靠度，訂立相關傳輸時間之門檻值。 
 
關鍵字：先進交通管理系統、動態加密、密碼學、安全性、效率。 
 
 
 
 
 
 
 
 
 
 
  4
目    錄 
 
第一章 緒論......................................................................................................................................10 
1.1 研究背景與動機………………………………………………………………………….10 
1.2 研究目的……………………………………………………………………………….....11 
1.3 研究範圍………………………………………………………………………………….12 
1.4 研究方法………………………………………………………………………………….12 
1.5 研究內容與流程………………………………………………………………………….12 
1.6 研究報告章節…………………………………………………………………………….14 
第二章 文獻回顧..............................................................................................................................15 
2.1 先進交通管理系統……………………………………………………………………….15 
2.2  NTCIP…………………………………………………………………….……………..15 
2.2.1 NTCIP 之效益…………………..…………………………………………………16 
2.2.2 NTCIP 之架構………………………………..……………………………………16 
2.2.3 NTCIP 之專用通訊協定……………………………………………..……………18 
2.3 安全要素……………………………………………………………………............…….24 
2.3.1 網路安全模型………………………………………………………………….….24 
2.3.2 相關攻擊手法………………………………………………………………….….25 
2.3.3 安全服務……………………………………………………………………….….26 
2.4 相關加密技術………………………………………………………………………….…27 
2.4.1 對稱式加密法……………………………………………………………………..28 
2.4.2 非對稱式加密法…………………………………………………………………..37 
2.4.3 訊息確認與雜湊函數……………………………………………………………..43 
2.5 文獻評析………………………………………………………………………………….47 
第三章 動態加密安全機制之建立..................................................................................................49 
3.1 動態加密(Dynamic Encryption)機制……...……………………………………………..49 
3.2 開發工具…………………………………………………………………….....................50 
3.3 系統架構與流程………………………………………………………………………….51 
3.3.1  系統架構…………………………………………………………………………51 
3.3.2  動態金鑰產生器(Dynamic Key Generator)……………………………………..55 
3.3.3  機制流程………………………………………………………………………....57 
3.4 程式架構………………………………………………………………………………….58 
3.4.1 統一模型化語言…………………………………………………………………..58 
3.4.2 安全機制程式說明………………………………………………………………..60 
第四章 系統效能分析……………………………………………………………………………..67 
4.1 安全機制演算法評選 ……………………………………………………………………67 
4.1.1 對稱式加密法……………………………………………………………………..67 
  6
圖目錄 
 
圖 1.1 台北市交控系統架構圖[41]...................................................................................11 
圖 1.2 新竹市交控系統架構圖[42]...................................................................................11 
圖 2.1 NTCIP 標準架構示意圖[1].....................................................................................17 
圖 2.2 MIB 整合圖[41]........................................................................................................19 
圖 2.3 SNMP 組成元件架構圖[41]......................................................................................19 
圖 2.4 網路安全模型[36]...................................................................................................24 
圖 2.5 加密解密關係示意圖...........................................................................................27 
圖 2.6 對稱式加密法加密與解密示意圖.......................................................................28 
圖 2.7  Rot13 轉置加密解密示意範例..........................................................................28 
圖 2.8 傳統密碼系統模型...............................................................................................29 
圖 2.9 資料加密標準(DES)演算法加密(上)與解密(下)架構圖.................................31 
圖 2.10 三重資料加密標準(3-DES)演算法加密(上)與解密(下)架構圖...................32 
圖 2.11 SubBytes 轉換範例...........................................................................................34 
圖 2.12 列之位移方式.....................................................................................................35 
圖 2.13 列正向移位範例.................................................................................................35 
圖 2.14 MixColumns 範例................................................................................................36 
圖 2.15 AddRoundKey 範例..............................................................................................37 
圖 2.16 非對稱式加密示意圖.........................................................................................37 
圖 2.17 公開鑰匙加密系統.............................................................................................39 
圖 2.18 RSA 演算法特性..................................................................................................42 
圖 2.19 使用 MD5 產生訊息摘要.....................................................................................45 
圖 2.20 HMD5 處理流程....................................................................................................46 
圖 3.1 DES 加密演算法導入動態金鑰架構圖................................................................50 
圖 3.2 TMIC 進行文字、公開鑰匙與訊息摘要之封裝..................................................52 
圖 3.3 TCIS 進行封包還原以及訊息摘要之比較..........................................................52 
圖 3.4 秘密鑰匙之封裝...................................................................................................53 
圖 3.5 TMIC 取出秘密鑰匙..............................................................................................54 
圖 3.6 TMIC 與 TCIS 利用亂數進行鑰匙對應................................................................55 
圖 3.7 UML 類別圖............................................................................................................59 
圖 3.8 UML 類別關係圖....................................................................................................59 
圖 3.9 SecurityTMIC UML 示意圖..................................................................................60 
圖 3.10 KeyBase UML 示意圖..........................................................................................61 
圖 3.11 SecurityUtils UML 示意圖..............................................................................62 
圖 3.12 TMIC_SendWithEncryption UML 示意圖..........................................................63 
圖 3.13 TCISWithEncryption UML 示意圖....................................................................64 
  8
表目錄 
 
表 2.1 SNMP 訊息格式......................................................................................................20 
表 2.2 SNMP 訊息及代表的意義......................................................................................22 
表 2.3 STMP 訊息及代表的意義......................................................................................23 
表 2.4 STMP 訊息格式......................................................................................................24 
表 2.5 古典加密法 vs. 公開鑰匙加密法[36].................................................................40 
表 2.6 ECC vs. RSA.........................................................................................................43 
表 2.7 vdCurrentDataTable 編碼表..............................................................................47 
表 3.1 ATMS 安全機制流程表..........................................................................................58 
表 4.1 對稱式加密法演算法比較...................................................................................67 
表 4.2 對稱式加密法運算速度比較表...........................................................................69 
表 4.3 RSA vs. ECC.........................................................................................................71 
表 4.4 RSA 效能評比........................................................................................................73 
表 4.5 vdCurrentDataTable 編碼表(單車道)..............................................................76 
表 4.6 加密前後封包內容比較表(一)(位元組陣列表示)...........................................77 
表 4.7 加密前後封包內容比較表(一)(十六進位字串表示).......................................78 
表 4.8 加密前後封包內容比較表(二)...........................................................................79 
表 4.9 常見加密破解手法[36]...........................................................................................81 
表 4.10 暴力破解法費時對照表[36].................................................................................83 
表 4.11 封包加密前後大小比較(以 vdCurrentDataTable 為例)...............................87 
表 4.12 實驗一數據整理.................................................................................................89 
表 4.13 封包填充 t檢定表.............................................................................................90 
表 4.14 RSA 分送鑰匙效能分析(768 位元)...................................................................92 
表 4.15 AES 鑰匙數 vs.總耗時之迴歸分析(768 位元)................................................94 
表 4.16 RSA 分送鑰匙效能分析(1024 位元).................................................................96 
表 4.17 AES 鑰匙數 vs.總耗時之迴歸分析(1024 位元)..............................................98 
表 4.18 RSA 分送鑰匙效能分析(2048 位元).................................................................99 
表 4.19 AES 鑰匙數 vs.總耗時之迴歸分析(2048 位元)............................................101 
表 4.20 RSA 綜合比較表................................................................................................104 
表 4.21 實驗三數據.......................................................................................................107 
表 4.22 傳輸平均耗時比較表.......................................................................................108 
表 4.23 傳輸週期 vs.封包大小(未加密)....................................................................110 
表 4.24 二因子變異數分析---週期 vs.封包大小(未加密)......................................110 
表 4.25 傳輸週期 vs.封包大小(加密)........................................................................110 
表 4.26 二因子變異數分析---週期 vs.封包大小(加密)..........................................111 
表 4.27 傳輸週期 vs.封包大小影響比較表................................................................111 
  10
第一章 緒論 
1.1 研究背景與動機 
自 1960 年起，先進國家即開始應用資訊、通信及控制等相關技術來改善交通問題。80
年代中期以後，此領域之研究開始迅速發展。透過先進的電子、通訊、資訊、車輛及控制等
技術，以整合人、貨、路、車的管理策略，提供即時的資訊，從而建立涵蓋陸、海、空領域
及發揮全方位功能的交通管理系統，此即所謂的智慧型運輸系統(Intelligent 
Transportation System, ITS)。ITS 的目標在於促進交通安全、減少擁擠、提高機動性、增
進經濟生產力、減少環境衝擊、提昇能源使用效率及帶動相關產業發展。 
先進交通管理系統(Advanced Transportation Management System, ATMS)乃是 ITS 下之
主要子系統，電子、通訊、資訊以及電機等技術在此系統下被廣泛地利用，ATMS 之交通控制
中心須與路側設施進行大量的資料相互傳輸，其中包含了路側傳回中心之每分鐘車流量及時
制計畫等資料，及中心對於路側設備下達之指令如設定、查詢及對時等，由於其資料傳輸量
相當龐大，因此一般認為通訊技術乃是 ATMS 最為重要之一環。 
在 ATMS 之資料傳輸中，乃採用國家運輸 ITS 通訊協定 NTCIP(National Transportation 
Communications for ITS Protocol, NTCIP)作為其傳輸協定，為了與現行通用之通訊協定相
結合而不致有所衝突，NTCIP 之堆疊(Stack)亦參照 ISO-OSI(Open Systems Interconnect)
之七層模型架構。採用 ISO-OSI 之模型架構使得 NTCIP 不至於與現行通訊協定不相容，但開
放式的網路環境也為 NTCIP 帶來許多安全性(Security)的問題，如圖 1.1 以及 1.2 所示，車
輛偵測器(Vehicle Detector, VD)將蒐集而得之車流資料透過網路回傳至交控中心，接著將
該資料存入系統資料庫，而中心可對回傳之資料進行分析並產生一即時之控制策略，接著再
將此控制策略下達至路口之號誌控制器(Traffic Signal Controller, TSC)。 
在上述的傳輸過程中，ATMS 之傳輸封包是完全暴露而不受保護的，因此有心人士可利用
現有工具軟體如 Sniffer Pro 以及 Iris 等在封包傳輸途中進行攔截，且 NTCIP 之內部結構與
ISO-OSI 架構相類似，因此判讀容易，有心人士容易對其進行竄改、偽裝、重送等攻擊，更
甚者可能會導致 ATMS 系統癱瘓，或是路口時制混亂等問題；最完善之解決方法乃針對 ATMS
建構封閉式內部網路(Intranet)，亦即虛擬私有網路(Virtual Private Network, VPN)，由
於其網路環境與外界無互通，故只要在防火牆部分控管得當，駭客進行入侵之難度相對會提
高許多，然而其建構成本也會隨之上升，故其並非最佳解決之道。 
基於上述理由，本研究採用資訊安全之密碼學技術(Cryptography)，針對傳輸封包進行
加密動作，則即便駭客能夠於傳輸中途攔截封包，由於沒有相對應的鑰匙進行解密，則其仍
然無法得知封包內容，更遑論進行竄改與重送等攻擊；即使其能夠以暴力法(Brute-force 
Attack)對鑰匙進行全面搜尋，但一來每次的封包傳輸均會隨機選取不同鑰匙進行加密，且鑰
匙會在一定時間內進行全面更換；二來破解所需成本與破解後所得利益之本益比不見得會讓
駭客願意進行攻擊，基於上述理由，演算法的選用、鑰匙的產生與發送、中心身分的認證以
及乃為本研究之主要課題。 
  12
一般的加密過程藉由增加加密金匙(Encryption Key )數量來提高系統之安全性，但在
增加金匙數量相較之下亦對系統造成負效用，本研究研擬一套在不增加金鑰長度且可確保封
包安全之可變動式加密演算機制，藉由改變加密演算法中的加密金匙的改變來達到動態加密
的技術，以提高安全性與系統效能中取得經濟、安全且適合 ATMS 資料傳輸過程的有效加密方
式。 
1.3 研究範圍 
常見之資訊安全問題有病毒入侵、解讀或竄改封包訊息、阻絕式攻擊以及重送攻擊等諸
多手法，其抵禦方法亦應隨著攻擊手法而因應改變；而由於在 ATMS 中，其中心端與路側控制
器之資訊傳輸過程中，對於封包內容並未加以保護，而由於 ATMS 之封包傳輸頻率高且數量龐
大，因此一旦封包的傳輸遭受威脅，則整個 ATMS 便會喪失其運作機能。  
有鑑於此，本研究針對其資訊傳輸的過程中，利用近代密碼學技術，發送端在傳送封包
對其進行加密保護，接收端在接收封包後則會對其解密，接著判讀封包內容，則有心人士即
便能夠於傳輸過程中攔截封包，亦無法對封包內容進行讀取或者竄改，藉此可提高資訊傳輸
之安全性。 
1.4 研究方法 
本研究之主要研究方法有二，首先是採用資訊安全領域之密碼學技術，如對稱式加密
法，非對稱式加密法以及訊息摘要等進行安全機制的設計，接著以 Sun 開發之 Java 程式語言
進行該安全機制的實作，但由於加密動作亦會損耗系統效能，故本研究會進行三項實驗，針
對加密前以及加密後之封包大小以及傳輸效能變化進行評估比較，藉此檢定加密對於系統效
能之確實影響以及加密之需要與否。 
1.5 研究內容與流程 
本研究之具體研究內容如下： 
(1) 針對 ATMS 所採用之通訊協定 NTCIP，進行其安全性之評估，並指出封包傳輸過程中
可能面臨之安全威脅。 
(2) 探討近代密碼學技術之種類，基本理論以及其優缺點比較。 
(3)就上述安全威脅，利用近代密碼學技術，建立一套安全機制。 
(4) 採用 Java 程式語言進行該安全機制之實作。 
(5)進行加密演算法評選以及性質比較，並採用不同加密演算法對封包進行連續加密，
測量其產生鑰匙以及加解密所耗費時間，進而決定適用於 ATMS 之演算法為何。 
(6) 進行安全性分析，針對其可能面臨之攻擊手法以及該安全機制之抵擋效能，以及常
見的密碼破解手法，最後探討暴力破解法對該機制之安全性威脅。 
(7)進行傳輸效能分析，利用實驗進行封包傳輸時間測量，並探討加密前以及加密後之
傳輸差異與否以及其差異幅度。 
 
  14
1.6 研究報告章節 
本研究於結構上共分五章，各章節分述如下： 
第一章 緒論  
       說明研究背景、動機、目的、範圍、方法、內容以及研究流程。 
第二章 文獻回顧 
首先針對 ATMS 及其採用之通訊協定(NTCIP)進行簡介，接著透過資訊安全四要素機
密性、確認性、完整性以及不可否認性指出其安全性不足之處，最後再對近代密碼
學技術進行探討，主要可分為對稱式加密法、非對稱式加密法以及訊息摘要。 
第三章 安全機制之建立與實作 
本章節對本研究欲採用之研究方法進行介紹；由密碼學之理論作為基礎建立適合本
研究之安全機制，其安全機制建立之內容大概可分為下列兩部份： 
＊利用第二章所述之對稱式加密法以及非對稱式加密法進行鑰匙分送以及封包加密
的工作，輔以訊息摘要之技術以進行訊息來源端之確認。 
＊由近代密碼學技術之加密演算法(Encryption Algorithm)進而延伸本研究之動態加
密技術，在本章節中亦會對動態加密技術之架構做說明。 
接著利用 Java 程式語言進行系統實作，最後說明程式之運作流程。 
第四章 效能分析 
針對第三章建立之安全機制進行效能評估，主要分為安全性以及系統效率兩部分；
安全性部分主要乃針對其抵抗傳統攻擊手法進行分析，並探討其抵抗暴力法之效
能，在效率性部分則會設計實驗進行封包傳輸測試，以探討加密前後系統之效能影
響。 
第五章 結論與建議 
提出本研究所獲得之結論及建議，以供後續研究者參考指教。 
 
 
 
 
 
  16
生系統連線之困難。 
(3) 相互連結性 (Interconnectability) 
指不同類型的中心，其資料可互相流通，進而達到整合控制之目的。 
2.2.1 NTCIP 之效益 
由於 NTCIP 提供了各交通單位在運輸系統的操作上更多的彈性及選擇，藉由統一的標
準，NTCIP 去除了不同單位協調上的籓籬並允許同一通訊線路上存在不同設備種類及製造商
之產品。即使原先整套系統並沒有採行 NTCIP，但各交通單位在採購新設備時如能夠考慮相
容 NTCIP 之產品，則仍然能透過 NTCIP 獲得未來採購及昇級之優點，而 NTCIP 主要的效益
如下： 
1. 避免設備過早淘汰 
NTCIP 不可能針對早期的設備來訂定標準，但是有了統一的標準，大多數的供
應商都會在未來的商品提供 NTCIP 之支援以提升其相容性。故一個交控系統可能混
雜著 NTCIP 及非 NTCIP 的設備，而這些設備使用不同之通訊線路，或是這些設備雖
支援 NTCIP 但仍使用既有的通訊協定。只要交通單位在採購設備時選擇 NTCIP 相容
的產品，不論是上述那種情形，都能夠避免設備過早淘汰，以延長設備之使用期限。 
2. 減少跨單位之間的協調 
NTCIP 允許不同單位間進行資料交換，同時在相互授權的情形下，執行某些指
令以監控其他單位的系統狀態。像這類的資訊交換與協調可以透過手動或是自動的
方式來進行。如此一來則各單位間能夠分享資訊，並且進行跨單位的控制，以提供
用路人即時資訊以及連鎖化的匝道儀控等。 
3. 提供更多的供應商以供選擇 
若使用單位決定其系統採用 NTCIP 架構，就可以向不同的供應商購買 NTCIP 相
容之產品、現場設備、軟體等。也許只有同一供應商之產品才能夠充分運用其產品
的功能，但至少在同一標準下，任何供應商都可以提供基本功能，交通單位選擇廠
商的機會將更多樣化，也可避免單一供應商的壟斷。 
4. 單一的通訊網路 
NTCIP 使得管理系統能夠用相同的通訊頻道與混合的設備種類進行傳輸。例如
透過系統電腦上的軟體來控制號誌化交叉路口旁的資訊可變標誌(Changeable 
Message Sign, CMS)以顯示適當訊息。通訊網路通常是運輸管理系統中花費最大的
組成元件，採用 NTCIP 則確保這項投資未來使用上的彈性。 
2.2.2 NTCIP 之架構 
原先 NTCIP 遵照 OSI 參考模式的規範，對於控制中心與現場設備或控制中心之間連接的
標準，分別定義 Class B、Class A、Class C 及 Class E 四種 Profile，而新版的 NTCIP 標
準已不再使用 Class 來分級，而採用模組及分層方式來傳輸，類似 ISO 的 OSI 7 層。一般而
言，兩台電腦或其他電子設施間的資料傳輸和下面這幾層有關，為了有別於 ISO 和 Internet
所定出的 Layer，NTCIP 以 Level 來分層。NTCIP 的架構如圖 2.1 所示，其中包含 NTCIP 的
  18
 NTCIP 標準及通訊協定堆疊 
最先發展的 NTCIP 標準主要用於 Center-to-Field 的應用。這部份牽涉到新的
Application Level 通訊標準，其稱為 STMP (Simple Transportation Management Protocol)，
新的 Subnetwork Level 通訊標準則稱為 PMPP，而 Information Level 中新的資料格式標準，
則稱為動態物件(Dynamic Object)。 
在不同層之間可採用不同的標準來傳送資料，且這些標準彼此之間都是相容的。一個訊
息在 NTCIP 架構中的每層至多使用一個標準來傳輸。這種利用一連串標準來遞送訊息稱為標
準的堆疊「Stack of Standards」，或是通訊協定堆疊「Protocol Stack」。不同的設備在交
換資料時，有可能發生部份訊息採某一組標準來傳輸，而其他訊息則採另一組標準來傳輸之
情形。 
2.2.3 NTCIP 之專用通訊協定 
NTCIP 是專為 ITS 所設計的通訊協定架構，因此考慮到 ITS 在發展上的特殊需求，因應
衍生出較以往網路通訊協定不同之通訊協定。簡易運輸管理通訊協定(Simple 
Transportation Management Protocol, STMP)是 NTCIP 為運輸系統所量身定作的一套通訊協
定，而這通訊協定是參考網際網路中的簡易網路管理通訊協定(Simple Network Management 
Protocol, SNMP)，故以下先對 SNMP 進行簡述。 
1. 簡易網路管理通訊協定(Simple Network Management Protocol, SNMP) 
網路是一種分散且異質的環境，面對網路上種種的設備，如果沒有方法跟這些設
備進行「溝通」的話，相信要管理網路肯定是件不可能的任務， SNMP 便是管理端與
被管理端之間進行「溝通」的重要角色。SNMP 遵循 TCP/IP 通訊協定，利用 Get (取
得)、GetNext（取得下一個）、Set (設定)以及 Trap (事件)四項簡單的命令群透過
「輪詢(Polling)」的方式提供網路管理端清楚知道被管理端的各種情況資訊，達到
網路管理的目的，其組成要素有下列幾點（如圖 2.3 所示）： 
a. 管理端（Manager） 
管理端是網路管理人員與網路之間的橋樑；管理端必須建置網路管理工具
或能夠執行管理的應用軟體，以便針對網路上各被管理端進行監視、控制、資
訊蒐集的功能。 
b. 被管理端（Agent） 
一般網路環境中具備被管理條件的節點設備有主機伺服器、工作站、路由
器、橋接器、交換器以及集線器等等，上述設備即可視為被管理端。所謂被管
理端之成立條件便是具有支援 SNMP 功能，而現代的網路設備多已支援 SNMP。 
c. MIB 
 網路管理必須仰賴各網路被管理端元件的資料數值，這些資料數值即為
MIB 值(Management Information Base)，管理端便是藉由收集或改變被管理端
的 MIB 值來達到網路監控管理的目的。MIB 所描述的每一項訊息稱之為「被管
理的物件」(Managed Object)，一個 Managed Object 是通訊協定交換的資料中
  20
建制上，SNMP 定義了三種語法來建構 MIB 的架構，其分別為 SMI(Structure and 
Identification of Management Information)、ASN.1(Abstract Syntax Notation One)
以及 BER(Basic Encoding Rules)。 
a. SMI 
主要是以 ISO Naming Tree 的模式來制訂受管的網路範圍中，各個物件之
間的層級關係。 
b. ASN.1 
以不會混淆資料的描述格式來定義 SNMP 訊息，與受管物件（MIB 模組）的
格式，此語言是由 ISO 所定義的。 
c. BER 
BER 為一種編碼方式，其將 SNMP 的訊息處理成適合網路傳輸的格式，主要
是將 ASN.1 之資料編譯成更小且為二進位格式，此外它並不會混淆保有管理資
訊內容的表示方式，編碼後再透過網路傳送此筆資料。 
 在簡述了 SNMP 的基本架構後，接下來的部分則是針對 SNMP 的資料傳輸格式作
一簡單的介紹。如表 2.1 所示，SNMP 的資料傳輸格式大略的分為 PDU Header 及 PDU
本體兩個部分，所謂 PDU（Protocol Data Unit）為通訊協定資料單元，其主要是為
特定的通訊層級或是通訊協定所使用的封包資料。 
表 2.1 SNMP 訊息格式 
PDU Header PDU 本體 
Application 
Header 
Version Community PDU 
Type
Request 
ID 
Error 
Status
Error 
Index
Sequence Identity Value
 
a. Length 
Length 為 16 個位元整數值，以 octet 為單位，記載訊息的總長度。 
b. Version 
在這個欄位是用一個 octet 來記載用以編碼該訊息的 SNMP 通訊協定版本，
有效值 1指 SNMPv1，2 指 SNMPv2，依此類推。 
c. Community 
此欄位為 octet 的序列值，其指出即將要接收該訊息的主機所屬之管理社
群。此一欄位長度不定，且社群名稱也不太可能超過 128 個 octet。 
d. PDU TYPE 
所有要求訊息的 PDU 標頭格式均相同，而 Trap 訊息的 PDU 標頭則因用途不
同而有差異，其可分為下列幾個命令格式，GetRequest, GetNextRequest, 
GetResponse, SetRequest 以及 Trap，在這方面的詳細標準可參考 RFC 1157。 
 
  22
 
表 2.2 SNMP 訊息及代表的意義 
v1 V2 訊息型態 目的 訊息發起者
ˇ ˇ Get Request 用來讀取 Agent 所管轄之物件資訊。 Management Application
ˇ ˇ 
GetNext 
Request 
GetRequest 一次只能讀取一個管理資訊，
此命令則可讀取表列(Table)內所有連續物
件的資訊。 
Management 
Application
ˇ ˇ Set Request Agent 在接到這個命令後，將會改變其所控制物件的值。 
Management 
Application
ˇ ˇ 
Response Agent在接到GetRequest、GetNext Request
或是 Set Request，不論要求是否正確，皆
以本訊息作為回應，以表示收到命令已被處
理。若要求合乎條件，則回應適當的值，否
則在相關的欄位指定錯誤的情況為何。 
Agent 
Application
ˇ ˇ 
Trap Agent在某種特殊的情況下會自動發出事件
通知(Event Report)，告知管理者
(Management)某些狀況已發生。 
Agent 
Application
X ˇ GetBulk 用來讀取大量物件資料。 Management Application
X ˇ Inform 用來主動通知其他管理站台相關資訊。 Management Application
 
 
 
  24
表 2.4 STMP 訊息格式 
PDU Header Value 
 
d. 編碼方式的差異 
對於 SNMP 而言，其採用的編碼方式為 BER(Basic Encoding Rule)編碼方
式，而 STMP 所採用的編碼方式為 OER(Octet Encoding Rule)編碼方式。基本
上而言，此兩種編碼方式是相同的，只是在名稱上的差異而已。對於物件的敘
述必須轉成封包的格式才能在網路上傳送，而編碼方式也影響了封包的大小。  
e. 動態物件的使用 
STMP 與 SNMP 最大的差異點，即在於 STMP 可以配合使用 NTCIP 所定義之動
態物件，藉以減少不必要的封包檔頭浪費。 
2.3 安全要素 
本小節主要利用網路安全模型探討現階段於開放式網路下常見之攻擊手法，以及國際電
信聯盟(International Telecommunication Union, ITU)之電信標準化部門
(Telecommunication Standardization Sector, ITU-T)所定義之安全服務以及安全需求，最
後再探討近代密碼學之發展、種類、基本理論以及其優劣比較。 
 
2.3.1 網路安全模型 
 
圖 2.4 網路安全模型[36] 
  26
（2） 流量分析(Traffic Analysis) 
此為較複雜之一種攻擊手法，對手可以長期監聽傳輸封包的相關訊息，如其
傳輸的頻率與封包長度等，藉此他們可以判斷其通訊特性。 
被動式攻擊在偵測方面相當困難，但由於他們並不會對資料進行更動，故可採用加密的
技術以預防此類攻擊，在對付被動式攻擊時，我們強調的是預防而非偵測。 
2. 主動式攻擊 
主動式攻擊涉及對資料的篡改以及假造，它可進一步細分為四類： 
（1） 偽裝(Masquerade) 
當某實體欲假裝成另一個實體則可稱之為偽裝，如在 ATMS 系統中，敵人
可假冒為 TMIC，並對 TCIS 傳送非法的指令如強迫其更改時制計畫，以達到其
非法目的。 
（2） 重送(Reply) 
敵人會先被動地攔截資料，並重複傳送此一合法資料以達到非法目的。          
（3） 修改訊息(Modification of Messages) 
此乃 ATMS 最需預防之攻擊手法，敵人可能單純地更動合法訊息之一部分，
也可能延緩訊息的傳送或弄亂其順序，使得接收方解讀為錯誤訊息或是無法解
讀。 
（4） 阻絕式攻擊(Denial of Service) 
即為阻止或妨礙通訊設備的正常使用或管理，如常見的利用大量的電子郵
件同一時間送往某一伺服器而導致其癱瘓。 
主動式攻擊呈現了與被動式攻擊完全相反的特質，由於被動式攻擊的偵測困難，故評估
重點在於如何預防，相反地，要完全預防主動式攻擊是完全不可能的，因為我們無法得知敵
人何時會對系統進行攻擊，若要預防主動式攻擊則必須全天候的對系統進行保護，這對成本
而言是一大負擔，故針對主動式攻擊，我們的目標在於如何偵測並對遭受攻擊或破壞之系統
進行修復。 
2.3.3 安全服務 
ITU-T 在開放式通訊系統的協定層級上定義安全服務，藉此確保系統與資料傳輸的安全
性，其可分為五大類，分述如下： 
1. 確認性(Authentication) 
這項服務關心的是通訊的可靠度，其要保證的內容在於接收者所接收到的訊息，的
確是從其宣稱的來源所傳送的，換言之，路側端收到某一訊息時，必須要有一機制以判斷
該訊息確實是由中心端發送而非敵人所偽裝。 
2. 存取控制(Access Control) 
  28
2.4.1 對稱式加密法 
對稱式加密法(Symmetric Cryptography)，有時亦可稱為傳統加密或單一鑰匙加密，其
是在公開鑰匙加密架構出現之前的唯一加密方式。其主要是利用取代或置換技巧(圖 2.7 為利
用 Rot13 轉置加密解密示意範例)，對於欲加密之文件進行轉換，則即便旁人能夠獲得加密後
的文件，沒有經過反轉換之前，他仍然無法得知該文件之內容。 
 
圖 2.6 對稱式加密法加密與解密示意圖 
 
圖 2.7  Rot13 轉置加密解密示意範例 
而對稱式加密架構乃是由五個要素所組成，分述如下： 
z 明文(Plaintext)：原始的清晰訊息或資料，其為加密演算法的輸入(Input)。 
z 加密演算法(Encryption Algorithm)：我們可透過各種加密演算法，將明文做不同方
式的取代或置換。 
z 秘密鑰匙(Secret Key)：秘密鑰匙也是加密演算法的輸入。所謂的鑰匙是指某個與明
文無關的數值，通常我們會希望鑰匙長度能夠有足夠長度，以抵抗敵人的攻擊。而加
密演算法會根據不同的輸入鑰匙而產生不同的輸出，秘密鑰匙明確地決定了演算法所
執行的取代與置換。 
  30
同時接收端亦必須擁有這把鑰匙，才得以對接收訊息進行解密，而我們通常是透過ㄧ安全通
道進行鑰匙的發送。 
訊息X與加密用的鑰匙K為該加密演算法的輸入，而演算法的輸出即為密文Y =  [Y1, Y2,…, 
YN]，而我們可將此加密程序寫為： 
kY = E (X)  
(2.1) 
式 2.1 之表示指出加密演算法 E與鑰匙 K形成明文的一個函數，X帶入此函數所得到的
函數值就是密文 Y。 
而接收端在收取該密文後，便可利用其握有之秘密鑰匙對密文進行逆運算，如式 2.2 表示： 
KX = D (Y)  
(2.2) 
當敵人握有 Y但卻沒有 X或 K時，他/她可能會嘗試破解 X或 K，甚至於對兩者都加以破
解。我們假設破解者可得知加解密所採用之演算法(E 或 D)。若其對於訊息內容感到興趣，則
他/她會嘗試計算求得 X之估計值 Xˆ，但其多半具有更大的野心，故亦會嘗試求得 K之估計值
Kˆ 。 
 
 近代對稱式加密法 
以下介紹近代密碼學中較常使用之對稱式加密法，分別為資料加密標準(DES)、三重資
料加密標準(Triple-DES)、Blowfish 以及進階加密標準(AES)，而由於 AES 乃是未來 30 年對
稱式加密法之主流，故會詳加介紹其加密流程以及運算方法。 
1. 資料加密標準[4](Tuchman & Meyer, 1977) 
國家標準局(National Bureau of Standards, NBS)於 1973 年公開徵求國家加密標準提
案，而在所有的加密標準提案中，以 IBM 之 Walter Tuchman 與 Carl Meyer 所提出之研究報
告為最佳，故於 1977 年被 NBS 採用而成為國家資料加密標準，嚴格說來，Tuchman 與 Meyer
之研究於 1960 年已趨成熟，但一直到 1973 年方申請成為國家加密標準。 
而資料加密標準(Data Encryption Standard, DES)在使用中最大的缺失有二：其一為
其鑰匙長度不足，在 IBM 之研究計畫中，鑰匙長度本為 128 位元，然而提交而成為資料加密
標準後，鑰匙長度卻大幅刪減 72 位元而僅存 56 位元，如此的鑰匙長度在暴力破解法面前乃
是相當脆弱的，故鑰匙長度不足乃為 DES 之最大隱憂；其二是由於 DES 將其內部設計架構(即
重排表格:S-box)之設計依據列為機密檔案，故使用者無法確定 DES 內部是否有某些隱藏的弱
點。 
 
 
  32
 
 
圖 2. 10 三重資料加密標準(3-DES)演算法加密(上)與解密(下)架構圖 
4. 進階加密標準[4][5](Daemen & Rjimen, 2001) 
進階加密標準(Advanced Encryption Standard, AES)為繼資料加密標準(Data 
Encryption Standard, DES)與 Triple DES(3DES)後，NIST 所發布之新一代加密標準。由於
DES 之鑰匙長度不足，故在現今電腦運算日漸強大的時代下，其已逐漸趨於不足，而 3-DES
之鑰匙長度雖然達到 DES 鑰匙長度之三倍，但由於其實作效能極差，故 NIST 在 1997 年徵求
新的加密標準，直至 2001 年 11 月選定 Rijndael 為新的 AES 演算法，而 Rijndael 之研發者
為來自比利時的兩位密碼破解專家，分別為 Dr. Joan Daemen 與 Dr. Vincent Rjimen。 
Rijndael 之 AES 提案書定義了一個加密法，其區段長度核鑰匙長度能夠各自指定為
128、192 或 256 位元。而最終發布之 AES 則採用三種鑰匙長度，但卻限制加密區段長度為 128
位元。而在下列的介紹中，我們假設鑰匙長度為 128 位元，而這也是目前 BouncyCastle[6]實
作之 AES 演算法所唯一支援之鑰匙長度。 
Rijndael 是根據下列特性所設計的： 
z 對抗所有已知的攻擊 
z 在各種平台上快速地執行，並且具備簡潔的程式碼 
z 設計簡單易懂 
在介紹 AES 加密法之前，有必要定義對於一些基本的數學理論進行介紹： 
所有的 Bytes 在 AES 中被解釋為有限場的元素，有限場的元素可以作加法或乘法，這些運算
不同於一般數字的加法或乘法。而這些是以 GF(28)為基礎架構，有些運算以 1個 byte 為單位，
而有些運算以 4個 byte 為單位。 
GF(28)定義： 
每一個 Byte 都有 8個 bit，而這些 bit 非 0 即 1，因此我們可以將一個 Byte 看成一個
由係數 0或 1組成的七次多項式，假設有一個 Byte b，其由 
b7 b6 b5 b4 b3 b2 b1 b0所組成，且 b0到 b7均為 0或 1所組成，則我們可將該 Byte b 視為 
7 6 5 4 3 2 1
7 6 5 4 3 2 1 0b x +b x +b x +b x +b x +b x +b x +b  
(2.3) 
例如(25)16 = (00100101)2之多項式即為 5 2x +x +1 
(2.4)  
加法運算： 
  34
會參照 S-box 第 9 列第 5行之值{2A}，故{95}便對應至{2A}，SubByte 之轉換範例如圖 2.11
所示： 
EA 04 65 85 87 F2 4D 97 
83 45 5D 96 EC 6E 4C 90 
5C 33 98 B0 4A C3 46 E7 
F0 2D AD C5 
 
 
8C D8 95 A6 
圖 2.11 SubBytes 轉換範例 
若我們將 S-box 中的每一位元均標示成(b7, b6, b5, b4, b3, b2, b1, b0)，則以下列方式
轉換 S-box 中每個位元組的每一個位元： 
i i (i+4)mod 8 (i+5)mod 8 (i+6)mod 8 (i+7)mod 8 ib =b b b b b c′ ⊕ ⊕ ⊕ ⊕ ⊕  
(2.7) 
 
此處的 ic 是 c位元組的第 i個位元。其值為{63}，此亦表示( 7 6 5 4 3 2 1c c c c c c c ) = 
(01100011)。其中符號「′」表示此變數會更新為等號右邊的數值，將此轉換方式以矩陣表
示可得 
 
0
1
2
3
4
5
6
7
b 1  0  0  0  1  1  1  1
b 1  1  0  0  0  1  1  1
b 1  1  1  0  0  0  1  1 
b 1  1  1  1  0  0  0  1
 = 
b 1  1  1  1  1  0  0  0
0  1  1  1  1  1  0  0b
0  0  1  1  1 b
b
′⎡ ⎤⎢ ⎥
′⎢ ⎥
′⎢ ⎥⎢ ⎥
′⎢ ⎥⎢ ⎥′⎢ ⎥
′⎢ ⎥⎢ ⎥′⎢ ⎥
′⎢ ⎥⎣ ⎦
0
1
2
3
4
5
6
7
b 1
b 1
b 0
b 0
  + 
b 0
1b
 1  1  0 1b
0  0  0  1  1  1  1  1 0b
⎡ ⎤⎡ ⎤ ⎡ ⎤⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎣ ⎦ ⎣ ⎦⎣ ⎦
 
(2.8) 
而在解密過程中，位元組的反向取代方式稱為 InvSubBytes，其利用 Inverse S-Box 進
行反向取代，換言之，若輸入{2A}，則可得到{95}。 
列的位移方式 
列的正向移位方式稱為 ShiftRows，如圖 2.13 所示，State 的第 1列是不變的，而第 2
  36
0,0 0,1 0,2 0,3 0,0 0,1 0,2 0,3
1,0 1,1 1,2 1,3
2,0 2,1 2,2 2,3
3,0 3,1 3,2 3,3
s   s   s   s s   s   s   s02  03  01  01
s   s   s   s01  02  03  01
 = 
01  01  02  03 s   s   s   s
03  01  01  02 s   s   s   s
′ ′ ′ ′⎡ ⎤⎡ ⎤ ⎢ ⎥⎢ ⎥ ′⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎣ ⎦ ⎢ ⎥⎣ ⎦
1,0 1,1 1,2 1,3
2,0 2,1 2,2 2,3
3,0 3,1 3,2 3,3
s   s   s   s
s   s   s   s
s   s   s   s
⎡ ⎤⎢ ⎥
′ ′ ′⎢ ⎥⎢ ⎥′ ′ ′ ′⎢ ⎥
′ ′ ′ ′⎢ ⎥⎣ ⎦
 
(2.9) 
乘積矩中的每個元素，是一列與一行元素乘積的總和，此處的加法和乘法運算遵循GF(28)
之規範，對 State 中的單獨一行 j(0 j 3)≤ ≤ 進行 MixColumns 運算，其可表示如式(2.10)，圖
2.14 則為 MixColumn 之範例。 
0,j 0,j 1,j 2,j 3,j
1,j 0,j 1,j 2,j 3,j
2,j 0,j 1,j 2,j 3,j
3,j 0,j 1,j 2,j 3,j
s = (2 s ) (3 s ) s s
s = s (2 s ) (3 s ) s
s = s s (2 s ) (3 s )
s = (3 s ) s s (2 s )
′ • ⊕ • ⊕ ⊕
′ ⊕ • ⊕ • ⊕
′ ⊕ ⊕ • ⊕ •
′ • ⊕ ⊕ ⊕ •
 
(2.10) 
87 F2 4D 97 47 40 A3 4C 
6E 4C 90 EC 97 D4 70 9F 
46 E7 4A C3 94 E4 3A 42 
A6 8C D8 95 
 
 
ED A5 A6 BC 
圖 2.14 MixColumns 範例 
而行的混合方式稱為 InvMixColumns，以下列的矩陣乘法(2.11)定義之，其即為 2.9 之
逆運算。 
0,0 0,1 0,2 0,3 0,0 0,1 0,2 0,3
1,0 1,1 1,2 1,3
2,0 2,1 2,2 2,3
3,0 3,1 3,2 3,3
s   s   s   s s   s   s   s0E  0B  0D   09
s   s   s   s09  0E  0B  0D
 = 
0D   09  0E  0B s   s   s   s
0B  0D   09  0E s   s   s   s
′ ′ ′ ′⎡ ⎤⎡ ⎤ ⎢ ⎥⎢ ⎥
′⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎣ ⎦ ⎢ ⎥⎣ ⎦
1,0 1,1 1,2 1,3
2,0 2,1 2,2 2,3
3,0 3,1 3,2 3,3
s   s   s   s
s   s   s   s
s   s   s   s
⎡ ⎤⎢ ⎥
′ ′ ′⎢ ⎥⎢ ⎥′ ′ ′ ′⎢ ⎥
′ ′ ′ ′⎢ ⎥⎣ ⎦
 
(2.11) 
 
新增回合鑰匙的方式 
新增回合鑰匙的正向運算稱為 AddRoundKey，如圖 2.15 所示，State 中的 128 個位元，
會與回合鑰匙的 128 個位元進行逐一的位元 XOR 運算。此運算可視為 State 中某一行的 4個
位元組，與回合鑰匙中的一個字元進行交互運算，亦可視為「位元組層級」的運算，其範例
  38
z 明文(Plaintext)：可讀取之訊息或文字，為演算法之輸入 
z 加密演算法(Encryption Algorithm)：對於輸入的明文進行轉換 
z 公開鑰匙(Public Key)與私密鑰匙(Private Key)：演算法產生之金鑰對(Key 
Pair)，其中一把用來進行加密，另一把則用來解密，而公開鑰匙顧名思義可將其
放置於網路上供任何人下載，私密鑰匙則否。 
z 密文(Ciphertext)：演算法根據明文及鑰匙所產生之亂碼訊息，不同鑰匙對於同一
明文可產生不同密文。 
z 解密演算法(Decryption Algorithm)：此演算法會以其匹配的鑰匙與密文來產生原
本的明文。 
 
其基本加解密步驟如下，參照圖 2.17： 
1. 網路上的任一終端系統均會產生一組金鑰對，用於對訊息進行加密或解密。 
2. 每一系統均會將其加密鑰匙公佈於一公開之網路上或是註冊處，而該鑰匙便稱為公
開鑰匙，另一把相對應的鑰匙則稱為私密鑰匙。 
3. 若訊息來源 A欲傳送訊息至目的地 B，則 A會使用 B之公開鑰匙對該訊息進行加密並
將密文傳送給 B。 
4. 當 B 收到該訊息，則會使用自身之私密鑰匙進行解密，由於私密鑰匙僅 B 擁有，故
其他人無法對此 A傳送而來之密文進行解密。 
 
  40
表 2.5 古典加密法 vs. 公開鑰匙加密法[36] 
古典加密技術 公開鑰匙加密法 
運作條件： 
1. 加解密均採用相同鑰匙。 
2. 傳送端及接收端需共用演算
法及鑰匙。 
 
 
安全性要求： 
1. 需保護鑰匙不致外流。 
2. 若無可用資訊，則欲解開密文
有相當程度之困難性。 
3. 即使得知演算法與一定數量
密文，亦無法求得鑰匙。 
 
優/缺點： 
加解密速度快，但鑰匙之保護困難 
運作條件： 
1. 使用相同演算法及一組金鑰
對進行加解密，其中一把用於
加密，另一把則用於解密。 
2. 傳送端和接收端須分持金鑰
對中的兩把鑰匙。 
安全性要求： 
1. 需保護金鑰對中的某把鑰匙。
2. 若無可用資訊，則欲解開密文
有相當程度之困難性。 
3. 即便得知演算法，某些密文和
其中一把鑰匙，亦無法求得另
一把鑰匙。 
優/缺點： 
採用金鑰對的作法能夠有效保護私密
鑰匙，但其加解密速度相對於古典加密
技術慢上許多。 
 
 近代非對稱式加密法 
以下介紹兩種較具代表性之非對稱式加密法，分別為 RSA 以及橢圓曲線加密系統(ECC)，
而由於 RSA 演算法乃是非對稱式加密法之主流，故亦詳加介紹其加密方法以及運算流程。 
1. RSA 演算法[9](Rivest, Shamir and Adleman, 1978) 
Diffie 和 Hellman 於 1976 年所發表之開創性論文，顛覆了世人對於密碼系統的思維，
然而在當時這僅屬於一個概念，即便是 Diffie 和 Hellman 亦不能確定是否有公開鑰匙密碼系
統的存在。第一個出現的實作演算法是在1977年，由Ron Rivest、Adi Shamir以及Len Adleman
於 MIT 所發展並於 1978 年發表，稱為 RSA(Rivest-Shamir-Adleman)，RSA 之出現證實了公開
鑰匙加密法的存在，同時其在公開鑰匙密碼學領域亦取得了壓倒性的優勢，一直到現在它仍
然被廣泛的運用著。 
  42
據同餘運算的規則，該敘述只有在 d(或 e)和 (n)φ 互質時成立，且其可表示為gcd( (n), d) = 1φ 。 
在數學理論介紹完畢後，將其運用至 RSA 機制中，其主要元素如下： 
z p、q 兩質數                                (自選私有值) 
z n = pq                                      (計算而得公開值) 
z e，其中gcd( (n), e) = 1φ ;1<e< (n)φ               (自選公開值) 
z -1d e mod (n)φ≡                               (計算而得私有值) 
公開鑰匙由{e,n}所組成，而私密鑰匙則由{d,n}所組成，假設使用者 A於網路上公佈其
公開鑰匙，而 A之朋友 B欲傳送訊息 M給 A，則 B需先獲取其公開鑰匙{e,n}，並藉此計算密
文 eC = M (mod n)，再將 C傳送給 A，而 A在接收此密文後，便可利用其私密鑰匙{d,n}進行解
密，可還原明文訊息 dM = C (mod n) ；RSA 演算法之基本特性可參照圖 2.18。 
 
產生金鑰對 
選取 p,q                       p 與 q 均為質數且 p q≠  
計算 n = p q×  
計算 (n) = (p-1)(q-1)φ  
選取整數 e                    gcd( (n), e) = 1;1<e< (n)φ φ  
計算 d值                      
-1d e mod (n)φ≡  
公開鑰匙                      KU = {e,n} 
私密鑰匙                      KR = {d,n} 
                        KU                      KR  
加密 
明文：M<n 
密文： eC = M (mod n)  
 
C  
解密 
密文：C 
明文： dM = C (mod n)  
圖 2.18 RSA 演算法特性 
 
  44
雜湊函數的目的就是產生檔案、訊息或是資料區段的「指紋」，為了有效地確認訊息，
雜湊函數(H)必須具備下列特性[11]： 
1. H 可處理任意長度的資料區段。 
2. H 會產生固定長度的輸出。 
3. 給定輸入值 x，其輸出值 H(x)之計算是容易的。 
4. H(x)之逆運算是不可行的，此種性質稱為單向性(one-way)。 
5. 給定任意區段 x，無法找出符合 y x≠ 且H(y) = H(x)之 y，此性質稱為弱碰撞抵抗力  
    (weak collision resistance)。 
6. 無法找出符合H(x) = H(y)之 (x,y)，此性質稱為強碰撞抵抗力(strong collision  
    resistance)。 
 MD5 訊息摘要演算法 
MD5 訊息摘要演算法是 Ron Rivest 在 MIT 所發展而成，即便目前暴力法與密碼破解技術
日漸強大，其仍然為最多人使用之安全雜湊函數。 
MD5 之輸入為一個任意長度的訊息，其輸入訊息會被分成好幾個 512 位元的區段處理，
其輸出則為一個 128 位元的訊息摘要，基本處理流程如下： 
z Step1：增添位元數(Padding Bits) 
在訊息之後附加一些位元，使得其位元長度在取 512 的同餘後會等於 448(訊息長
度 448 mod 512≡ )，顧富家過後的訊息長度會比 512 位元的倍數少 64 位元，而此附加程
序是必須的，即便訊息長度已為 448 位元，仍須在其尾端加上 512 個位元，而附加的方
式為：先加一個 1，之後皆以 0填入。 
z Step2：增添長度 
在 Step1 之前，MD5 會將原始訊息長度表示成一段 64 位元的資料，在將該段資料
附加在 Step1 所產生的訊息末端，若訊息原始長度大於 642 ，則會對該原始長度取 642 之
同餘而附加之。 
經過前兩步驟後，訊息長度便會變為 512 位元的整數倍，見圖 2.19，可看出加長
之後的訊息被表示成一連串 512 位元的區段 0 1 L-1Y ,Y ,...,Y ，故加長後之總訊息長度變為
L 512× 個位元，其亦可表示為，訊息長度是 16 個 32 位元字元之整數倍，設M[0...N-1]
為訊息內字元，此處之 N為 16 之倍數，故可得N = L 16× 。 
  46
之表格 T，該表格內含 64 個元素，可表示為T[1...64]，MD5 採用 T[i]表示 T的第 i個元
素，其值等於 322 abs(sin(i))× 之整數部份，該表格提供了一組隨機性的 32 位元樣式，藉
此可將輸入區段之規律性消除。在經過四個回合之運算後，其輸出會與第一回合之輸出
(CVq)相加而產生 CVq+1。 
 
圖 2.20 HMD5 處理流程 
z Step5：輸出 
當 L個 512 位元之區段均處理後，第 L階段之輸出即為我們所需要之 128 位元的訊
息摘要。 
 
  48
統嘗試入侵。 
3. 某系統已接收服務，但該系統卻拒絕承認其已接受該服務，藉此規避應有的使用費，
此為不可否認性問題(Non-Repudiation)，可藉由數位簽章(Signature)解決。 
4. 資料封包在兩系統之間的傳輸是脆弱而未經保護的，任何有心者可以藉著某些駭客
工具進行資料封包的擷取，進而達到其不法目的。 
5. 在兩系統之間傳輸之資料封包，須確認其未經竄改，亦即確認該封包之完整性
(Integrity)。 
6. 利用 STMP 進行編碼之封包架構易懂，攻擊者在攔截封包後可輕易對其進行判讀以及
其欲發動之攻擊。 
第 6 點是本研究根據 NTCIP 之架構所提出的，而本研究主要針對上述問題中之第 4、5
以及 6點，也就是封包在兩系統之間的傳輸安全性問題以及其完整性之問題探討。採用如 2.4
節探討之密碼學相關技術，對其傳輸過程中進行安全機制之設計以保護傳送封包，主要是合
併對稱式加密法與非對稱式加密法使其成為一混雜系統(Hybrid System)，接著再搭配訊息摘
要的技術進行訊息以及公開鑰匙完整性的確認，藉此提高 ATMS 傳輸之安全性。 
 
  50
鑰的產生即為本研究達成動態加密技術的重點之ㄧ；在 3.3.2 節對於動態金鑰產生器
(Dynamic Key Generator)有詳述的介紹。如下圖 3.1 為對稱式加密 DES 加密法加入動態
金鑰產生器之架構圖；其中動態金鑰產生器之變動在本研究主要在每一個欲加密明文
(TMIC 傳送給 TCIS 之指令)之以亂數的方式產生加密金鑰或是以明文特徵(如時間、指令
模式、地點…等)等方式作為改變金鑰之變動參考來源。 
 
圖 3.1  DES 加密演算法導入動態金鑰架構圖 
3.2 開發工具 
在實作方面，本研究乃採用 Sun Microsystems 之 Java 程式語言進行，其主要原因如下： 
1. 具跨平台操作特性 
本系統初期預計採用 Microsoft Windows XP Embedded 版本進行，理由是其操作
方便，但在系統上軌道後則改採用 Linux Embedded 進行日後工作，有鑒於此，程式語
言的「跨平台性」則顯得相當重要，而 Java 在這方面功能遠勝其他程式語言。 
2. 本身具備安全套件 
由於 Java 具有本身可以透過網路下載、散佈等特性，故當初 Sun Microsystems 在
開發時便著重於安全防護的加強，其本身具有三項延伸套件，可供程式開發者搭配使
用，分別為： 
（1） JCE 延伸套件(Java Cryptography Extension) 
此套件主要是密碼學演算法的實作套件，其中包含了加密器(Cipher)、鑰匙
交換、訊息摘要與鑰匙管理系統等，此項套件能夠使程式開發者直接採用目前已
流通的演算法，而不需著重於演算法的數學細節。 
（2） JSSE 延伸套件(Java Secure Sockets Extension) 
藉由此套件可與SSL(Secure Sockets Layer)伺服器或客戶端進行訊息溝通。 
（3） JAAS 延伸套件(Java Authentication and Authorization Service) 
  52
T
MD
TKey Pair
MD 
Algorithm
M
MD
Byte ArrayTMICKU
TMICKU TMICKU
 
圖 3.2 TMIC 進行文字、公開鑰匙與訊息摘要之封裝 
TCIS 在接收該封包後，會先進行一封包分解動作，將該封包內含之文字訊息 T、公開鑰
匙 TMICKU 與訊息摘要 MD 分別取出，接著 TCIS 將 TMICKU 與數字訊息作為訊息摘要演算法 H之
輸入，並得出一個新的訊息摘要MD′： 
TMICMD  = H(M, KU )′  
(3.3) 
接著 TCIS 會將原封包中之 MD 與計算而得之MD′進行比較(見圖 3.3)，若兩者一致則表
示公開鑰匙 TMICKU 或訊息摘要 MD 未遭到竄改，則可進行下一步動作，反之則表示其遭到竄
改，亦表示該通訊管道上有敵人欲進行攻擊，故可對中心端發送一重新要求鑰匙之訊息。 
Byte Array
T
MD
MD
Algorithm
M
TMICKU Compare
True
False
Accept
Reject
MD′
 
圖 3.3 TCIS 進行封包還原以及訊息摘要之比較 
在第二章中我們曾經探討公開鑰匙加密法，其金鑰對中之公開鑰匙本身可在網路上公開
流傳，因此 TMIC 在傳送公開鑰匙至 TCIS 端時並不需要加以保護，但其仍然有可能遭到有心
人士攔截並加以竄改為其自身擁有之公開鑰匙(假設其已知道演算法以及鑰匙長度為何)，故
  54
 
 
Key1
Key n
Key3
Key2
C AsymmetricAlgorithm
TMIC’s
HD
TMICKR
TCISKS
.
.
.
TMIC
 
圖 3.5 TMIC 取出秘密鑰匙 
至此 TMIC 端與 TCIS 端已經完成交換秘密鑰匙之程序，且兩端分別存著 n把秘密鑰匙於
其自身硬碟中；接著當 TMIC 欲傳送命令或訊息至 TCIS 端時，其會產生一隨機亂數 R，由範
圍介於-127 至 128，接著將 R輸入一函數 f(x) ，而在本研究中採用 f(x) 如式 3.6： 
3 2f(x) = (5x +4x +2x+x ) mod n  
(3.6) 
f(x) 在最後必須要對 n進行同餘運算以確保計算結果不會超過鑰匙數量，進而導致無法
取出正確之相對應鑰匙，透過 R與 f(x) 可計算出鑰匙選擇基數 KI，KI 之範圍則會介於 0~n-1，
計算 KI 之過程如式 3.7： 
KI = f(R) 
(3.7) 
接著 TMIC 會藉著 KI 選取硬碟中之對應秘密鑰匙，並利用該鑰匙對欲傳送訊息進行加密
產生一密文封包，並將亂數 R附加至密文封包後傳送至 TCIS 端；TCIS 接收該封包後，會先
行擷取封包最末端欄位之亂數 R，並作為相同函數 f(x) 之輸入以得到 KI，接著利用 KI 由硬碟
中選取對應之秘密鑰匙對該加密封包進行解密，並在解密後執行該命令所要求之動作，圖 3.6
為利用 TMIC 與 TCIS 利用亂數取出相對應鑰匙之流程圖。 
 
 
  56
    public byte[]getEncoded() 
     可利用此種方法擷取金鑰經過編碼後的值。編碼是將一把金鑰值轉成位元組陣列的過   
     程，getEncoded()這個方法可將金鑰編碼時候所使用的格式名稱回傳給系統。 
    public String getFormat() 
     回傳編碼時所用的格式名稱。 
 金鑰介面 
Java 程式 JDK 中延伸了幾個定義不同種類金鑰的金鑰介面；如前章所敘，金鑰應用在對稱式
加密與非對稱式加密的方式上是不同的，且以下幾個子介面在本程式語言上從金鑰介面的繼
承僅是一種語意上的延伸而非方法上的差異。 
    Java.security.PublicKey 
      這種介面代表示一對金鑰中的公開金鑰(Public Key)，主要適用的對象是簽章與非對    
      稱式加密演算法。 
    Java.security.PrivateKey 
此介面代表示一對金鑰中的秘密金鑰(Private Key)，如同公開金鑰，主要適用的對象 
是簽章與非對稱式加密演算法。 
    Javax.crypto.SecretKey 
      此種介面代表的是給對稱式加密所使用的金鑰(Secret Key)，在對稱式加密中加密與   
      解密用的是同一把金鑰，所以本介面所產生的這把金鑰可以同是用在對稱式加密演算 
      法中加密與解密。 
 對稱式加密金鑰產生器之類別 
對稱式加密中所使用的金鑰僅有一把而不是一雙，Java 程式語言 JCE 套件中提供可供對
稱式加密的需要只產生一把隨機金鑰的 Javax.crypto.KeyGenerator 類別，這個類別可以使
用 Factory 方法:getInstance()獲得一個實體，以下即顯示產生一金鑰的程式碼: 
KeyGenerator kg=KeyGenerator.getInstance(“DES”); 
    要初始化 KeyGenerator，首先必須要輸入一個隨機資料(random)來源或欲產生的金鑰強
度(strength；意指金鑰的位元長度，不過依演算法的不同金鑰長度也代表不同的意義)，或
兩者作為初始化參數。一旦 KeyGenerator 物件初始化完成，便可以使用這個物件裡的
generateKey()方法來產生金鑰。 
    public final void init(SecureRandom random) 
將 KeyGenerator 物件初始化，並告訴 KeyGenerator 物件使用 random 引數作為隨機位 
元的來源產生 Key。 
    public final void init(int strength) 
      將 KeyGenerator 物件初始化，並參考金鑰強度引數設定產生金鑰的長度。 
    public final void init(int strength,SecureRandom random) 
      導入金鑰長強度與隨機位元來源兩個參數來初始 KeyGenerator 物件。 
  58
表 3.1 ATMS 安全機制流程表 
Step TMIC TCIS 
1 產生公開金鑰對(Key Pair)與要求
鑰匙之訊息 T 
等待要求鑰匙訊息… 
2 利用金鑰對中之公開鑰匙 TMICKU
與數字訊息 M產生訊息摘要 MD 
等待要求鑰匙訊息… 
3 將包含 T, TMICKU 與 MD 之封包傳
送至 TCIS 端 
接收 TMIC 傳送之封包。 
4 
 
等候秘密鑰匙封包… 利用 TMIC 傳送而來之 TMICKU 與預
存之 M 計算新訊息摘要MD′，再對
接收之 MD 與MD′進行比較。 
5 
 
等候秘密鑰匙封包… 利用對稱式加密法產生 n 把秘密鑰
匙，並將其存入自身硬碟中。 
6 
 
等候秘密鑰匙封包… 利用接收之公開鑰匙 TMICKU 對該 n
把秘密鑰匙加密，並將密文傳送回
TMIC。 
7 
 
 
利用私密鑰匙 TMICKR 對接收之密
文進行解密並取出秘密鑰匙，將其
存入自身硬碟中。 
等待 TMIC 下達之訊息… 
8 在發送訊息前，利用 R 與 KI 選取
一把秘密鑰匙進行加密，並將密文
與 R傳送至 TCIS。 
接收密文，擷取 R 後求出 KI，並利
用 KI 選取相對應之秘密鑰匙進行解
密，判讀訊息後執行動作。 
3.4 程式架構 
本研究乃採用昇陽開發之 Java 程式語言進行系統之實作，以便進行安全機制之績效評
估，以下會簡單介紹統一模型化語言(Unified Modeling Language, UML)，其可使程式設計
師了解程式之架構以及流程，接著會利用 UML 進行本研究所開發程式說明。 
3.4.1 統一模型化語言 
統一模型化語言(United Modeling Language, UML)是於 1997 年，由物件管理組織
(Object Management Group, OMG)所發布，為 Rational  Software  公司的 Grady  Booch、
Ivar  Jacobson  和 Jim  Rumbaugh 採用物件導向之概念所開發而成，該語言可用於指定
化、構築化  (結構化)和文件化的軟體與非軟體系統（如商業模型），而其最主要的目標之一
就是為開發團隊提供標準通用的設計語言來開發和構建電腦應用，通過使用 UML，IT 專業人
員能夠閱讀和交流系統架構和設計規劃--就像建築工人多年來所使用的建築設計圖一樣，而
到了 2003 年，UML 已經獲得了業界的認同，以下是其範例說明： 
  60
圖 3.8 則為 SecurityUtils 類別與其他類別之關係，由其上方可看出該 SecurityUtils
繼承(Inherit) java.lang 類別，由右上方則可得知在 EncryptTimTest 以及 KeyBase 此兩類
別中會呼叫 SecurityUtils 類別，並使用其中之方法(Method)；圖右下方可得知
SecurityUtils 本身會呼叫 java.io 以及 java.lang 類別及其內含之方法。 
3.4.2 安全機制程式說明 
本研究之撰寫程式主要可分為兩類，其一為交換鑰匙之機制，其二為在傳輸過程中進行
封包加解密之機制，而兩者亦可搭配使用使成一完整系統。 
1. 交換鑰匙機制 
在該機制中程式主要利用兩類別進行鑰匙之交換，分別為 SecurityTMIC 以及
KeyBase，SecurityTMIC 之工作乃是利用 SecurityUtils 類別產生非對稱式加密法金鑰對
以及訊息摘要，並發送要求鑰匙之訊息至 KeyBase 以獲得新的 AES 秘密鑰匙；而 KeyBase
則是不斷等候秘密鑰匙請求，在接收其請求後便呼叫 SecurityUtils 產生對稱式加密法之
秘密鑰匙，接著利用由中心傳送而來之公開鑰匙(Public Key)對其進行加密並傳送回
SecurityTMIC。圖 3.9 與 3.10 即為 SecurityTMIC 以及 KeyBase 之 UML 示意圖，而圖 3.11
為 SecurityUtils 之 UML 示意圖，其主要功能乃在於呼叫 java.security 類別，進而達到
一些安全性功能如產生鑰匙，產生訊息摘要，訊息加解密以及比對訊息摘要等。 
 
圖 3.9 SecurityTMIC UML 示意圖 
  62
 
圖 3.11 SecurityUtils UML 示意圖 
2. 傳輸加解密機制 
    傳輸加密機制主要可分為三個類別，分別為 TMIC_SendWithEncryption、
TCISWithEncryption 以及 TMIC_ReceiveWithEncryption，之所以如此設計主要是方便於
進行實驗設計，在未來亦可迅速整合入交控系統中；在程式運作流程方面，首先
TMIC_SendWithEncryption 會藉著 com.objsys.asn1j.runtime、iot.mibd.vd 產生 NTCIP
之 VD 物件，接著其會使用 SecurityUtils 內之方法對該封包進行加密，並將相關資料利
用 java.sql 類別存入系統資料庫內，之後傳送加密過後之封包至 TCIS。 
TCISWithEncryption 之工作乃是負責接受由 TMIC_SendWithEncryption 傳送而來之
加密封包，其在接收封包後會採用 SecurityUtils 中之方法對封包進行解密，解密判讀後
  64
 
圖 3.13 TCISWithEncryption UML 示意圖 

  68
在表 4.1 中簡單探討了上述四種演算法之性質比較，而在進行實際測試中，本研究採用
Java 語言撰寫，其測試環境為： 
                  CPU：Intel Pentium 4-1.8GHz 
                  RAM：1.00GB 
                  OS：Windows XP 
在測試項目方面，分別利用四種對稱式演算法對不同大小的明文進行加解密的動作，藉
此測量其運算耗費時間，其基本測試流程如圖 4.1 所示： 
鑰匙產生器
加密
解密
Time 1
Time 2
Time 3
Time 4
Time 5
Time 6
Secure
Random
位元組陣列
(Byte Array)
密文
明文
初始化
秘密鑰匙
 
圖 4.1 對稱式加密法效能評比之實驗流程 
由圖 4.1 所示，首先程式會進行鑰匙的初始化，此時會紀錄當時系統時間 Time1，此處
之系統時間取出乃採用 java.util.Date 物件之 getTime 方法，其取出之資料型態為 long，
單位則為毫秒(千分之ㄧ秒)；接著程式會利用一具備密碼學安全等級之虛擬亂數產生器
(Pseudo-Random Number Generator, PRNG)之類別 SecureRandom 產生亂數，再將其產生之亂
數餵入鑰匙產生器(Key Generator)進行秘密鑰匙之初始化，藉此可使鑰匙產生器在產生秘密
鑰匙的過程中更具隨機性，因此敵人更難對所產生之鑰匙進行破解及預測；秘密鑰匙產生後
程式會記錄系統時間 Time2；接著程式會產生一個位元組陣列(Byte Array)作為明文，其內
含之元素即為 0至陣列大小，例如陣列大小為 64 位元組，則其所包含的元素即為 0,1,2…63。 
  70
對稱式加密法加密比較
0
100
200
300
400
500
1.0E+01 6.4E+01 1.0E+02 1.0E+03 1.0E+04 1.0E+05 1.0E+06
明文大小(Byte)
耗
時
(m
s) AES
Blowfish
DES
3-DES
 
圖 4.2 對稱式加密法加密比較 
對稱式加密法解密比較
0
100
200
300
400
500
1.0E+01 6.4E+01 1.0E+02 1.0E+03 1.0E+04 1.0E+05 1.0E+06
明文大小(Byte)
耗
時
(m
s) AES
Blowfish
DES
3-DES
 
圖 4.3 對稱式加密法解密效能比較 
由上述圖表可得出下列結論： 
1. 欲加密明文大小越大，則加解密費時越高，然而此特性在明文大小大於 1000 位元組後較
明顯。 
2. 在此四種加密法中，運算效能為 AES>Blowfish>DES>3-DES。 
3. 在加解密部分，雖然其數值顯示加解密耗時均甚小。約只有 0~1 毫秒，然而其乃為長期
平均而言，實際上在測試過程中發現其加密所耗時乃落在一區間，如 AES 在 1000 位元組
  72
在非對稱式加密法之評選中，由於 ECC 實作不易且具有運算速度慢以及未趨成熟等缺
點，故不列入實驗測試中，而以 RSA 三種鑰匙長度(768，1024 以及 2048 位元)進行運算速度
以及安全性之測試，測試項目與對稱式加密法(4.1)相同，詳細流程見圖 4.4。 
鑰匙產生器
加密
解密
Time 1
Time 2
Time 3
Time 4
Time 5
Time 6
Secure
Random
位元組陣列
(Byte Array)
密文
明文
初始化
公開鑰匙私密鑰匙
 
圖 4.4 非對稱式加密法效能評比實驗流程 
藉著圖 4.4 可看出其實驗流程與對稱式加密法效能評比之實驗流程相近，唯一之不同點
即在進行鑰匙初始化後，其鑰匙產生器會產生一組金鑰對(Key Pair)而非一把秘密鑰匙，分
別為公開鑰匙(Public Key)與私密鑰匙(Private Key)，接著會產生一組位元組陣列，並取出
稍早產生之公開鑰匙對其進行加密，之後再利用私密鑰匙對其進行解密，進而紀錄六組系統
時間分別為 Time1~Time6，接著利用此六組系統時間計算出初始化鑰匙耗時、加密耗時以及
解密耗時。 
在數據蒐集方面，同樣是對於某明文大小進行連續 1000 次的加解密動作，而由於第一
筆資料會因為程式的初始化效應而失真，故捨棄而不用，相關數據見表 4.3 與圖 4.5。 
 
  74
1. 在鑰匙初始化耗時方面，768 位元與 1024 位元長度之鑰匙在初始化僅耗費 1秒以內，而
2048 位元長之鑰匙初始化卻需費時近 10 秒，其對於系統效率影響甚高。 
2. 非對稱式加密法之加密長度有所限制，且與其鑰匙長度呈正相關，在鑰匙長度為 768 位
元時，其輸入明文長度最大可至 85 位元組；鑰匙長度為 1024 位元時，輸入明文長度可
至 117 位元組；而鑰匙長度到達最大限制之 2048 位元時，其輸入明文長度可達到 245 位
元組，此亦為 RSA 目前為止可加密之最大長度。 
3. 公開鑰匙加密法之加密時間相對於解密時間甚少，且鑰匙長度越長，此現象越明顯，主
要原因乃在於在本研究之實驗測試中，加密是利用公開鑰匙而解密是利用私密鑰匙，由
於公開鑰匙可在網路上流通，故其值並無須保密，而一般而言寫入 1 比寫入 0 費時，故
開發者在公開鑰匙的設計中，通常會將其內部的初始位元以及結束位元設定為 1，其他
位元設計為 0，而私密鑰匙則無法如此設計，故加密時間相對於解密時間會少上許多。 
4. 在加密耗時方面，三種鑰匙長度所耗損時間均不甚高(3~8 毫秒)，且差異不大。 
5. 解密耗時部份，768 位元與 1024 位元之鑰匙長度所需時間相差不大，而 2048 位元相對
而言高出甚多，其對於講求效率之 ATMS 而言並不適用。 
6. 整體效率而言，鑰匙長度為 768 與 1024 位元所需耗費時間相距不遠，而鑰匙長度為 2048
所需時間相對而言高出甚多；而就安全性而言，鑰匙長度較長者安全性為佳，因此建議
採用鑰匙長度 1024 位元之 RSA 為 ATMS 之非對稱式加密演算法。 
 
4.2 系統安全性分析 
本研究之最初的研究目標即為設計ㄧ安全機制，對傳輸中的封包進行加密以達成資料保
護，因此毫無疑問地系統的安全性為本研究最主要的課題之一，而在安全性分析可包含三項
部分：分別為安全機制之分析，密碼分析以及暴力攻擊法分析。 
4.2.1 安全機制分析 
在第三章我們利用對稱式加密法、非對稱式加密法建立了ㄧ安全機制，並以 Java 語言
進行實作，而在 TMIC 與 TCIS 通訊的過程中，可能會遭遇到數種攻擊手法如攔截封包、偽裝、
竊聽或竄改等，以下將深入探討本研究之安全機制如何抵禦這些攻擊。 
  76
5. 重送(Reply) 
敵人依然監聽中心端與路側端之通訊，並將中心端傳送之路側端之封包攔截後，等
候一段時間後再行傳送，例如敵人可能會將離峰時刻之修改時制封包攔截，等候尖峰時刻
再行傳送至 TCIS，則由於路口時制的變換不當，會導致路口使用效率不良等狀況。解決
方法為 TMIC 在傳送封包前取出系統時間，接著將其加入封包內並加密，此稱為時間戳記
(Timestamp)，則 TCIS 在接收封包解密後先行取出時間戳記，與現行時間進行比對後，可
得其在在傳輸過程中是否有遭受攻擊，藉此其可判斷是否該執行該封包之命令。  
4.2.2 密碼分析 
密碼破解的方式取決於演算法、明文特性、以及明文-密文的組合範本，敵人在事前得
知演算法，並加以分析其特性，藉此推斷擷取封包之具體內容以及所採用的鑰匙，若其能夠
成功破解鑰匙，則所有以該鑰匙加密的訊息均會受到威脅。 
在 ATMS 中，乃採用 STMP 為 NTCIP 之專用通訊協定，而透過 STMP 編碼後之物件如表 4.5
所示： 
表 4.5 vdCurrentDataTable 編碼表(單車道) 
物件名稱 最新週期性偵測資料 
物件識別碼 vdCurrentDataTable 
OID 1, 3, 6, 1, 4, 1, 1206, 4, 2, 8, 11, 1 
STMP 編碼 
(十六進位字串
表示法) 
[b0][06][0c][2b][06][01][04][01][89][36] 
[04][02][08][0b][01][30][44][30][42][02] 
[01][01][02][01][01][02][01][01][02][01] 
[01][02][01][01][02][01][01][02][01][01] 
[30][03][02][01][02][30][03][02][01][02] 
[30][03][02][01][02][30][03][02][01][02] 
[30][03][02][01][02][30][03][02][01][02] 
[30][03][02][01][02][30][03][02][01][02] 
[30][03][02][01][02] 
位元組陣列表
示法 
[-80][6][12][43][6][1][4][1][-119][54][4] 
[2][8][11][1][48][68][48][66][2][1][1][2] 
[1][1][2][1][1][2][1][1][2][1][1][2][1][1] 
[2][1][1][48][3][2][1][2][48][3][2][1][2] 
[48][3][2][1][2][48][3][2][1][2][48][3][2] 
[1][2][48][3][2][1][2][48][3][2][1][2][48] 
[3][2][1][2][48][3][2][1][2] 
物件長度 87 byte 
  78
表 4.7 加密前後封包內容比較表(一)(十六進位字串表示) 
物件名稱：vdCurrentDataTable 
加密前 加密後 
[b0][06][0c][2b][06][01][04][01][89][36
] 
[04][02][08][0b][01][30][44][30][42][02
] 
[01][01][02][01][01][02][01][01][02][01
] 
[01][02][01][01][02][01][01][02][01][01
] 
[30][03][02][01][02][30][03][02][01][02
] 
[30][03][02][01][02][30][03][02][01][02
] 
[30][03][02][01][02][30][03][02][01][02
] 
[30][03][02][01][02][30][03][02][01][02
] 
[30][03][02][01][02] 
[7c][3f][a8][52][00][a6][2f][94][80][18
] 
[db][83][a8][78][57][c8][3e][2c][38][26
] 
[c0][b6][81][6a][2b][51][7a][f1][4c][12
] 
[cf][cd][a3][03][ab][a8][45][ca][cc][c0
] 
[b8][78][a9][9b][79][2b][19][f4][ab][9d
] 
[f9][28][86][a3][25][44][8f][a1][ca][26
] 
[b2][13][c2][f8][de][07][16][48][6b][7c
] 
[4f][0b][b2][91][7a][de][96][64][bb][26
] 
[78][83][c6][e7][c6][d6][c3][55][40][94
] 
[38][ee][b5][c1][33][8b][ac] 
而表 4.8 則利用相同明文，但是卻使用不同之 AES 秘密鑰匙對其進行加密，其加密前後
之封包比較。 
 
 
 
 
 
 
  80
[66][-110] 
十六進位字串表示法 
[b0][06][0c][2b][06][01][04][01][89] 
[36][04][02][08][0b][01][30][44][30] 
[42][02][01][01][02][01][01][02][01] 
[01][02][01][01][02][01][01][02][01] 
[01][02][01][01][30][03][02][01][02] 
[30][03][02][01][02][30][03][02][01] 
[02][30][03][02][01][02][30][03][02] 
[01][02][30][03][02][01][02][30][03] 
[02][01][02][30][03][02][01][02][30] 
[03][02][01][02] 
[c6][75][f7][e7][ae][fb][23][6c] 
[14][5a][f0][ad][5a][a4][d0][76] 
[60][3b][ba][83][56][d7][6d][9a] 
[7c][db][f9][b1][65][92][88][21] 
[f8][6c][75][45][2f][bc][05][c0] 
[fd][4a][ae][23][e2][15][5e][6e] 
[ce][f9][ff][81][6d][70][d8][98] 
[6c][61][b5][b5][e0][a9][e2][2b] 
[6b][fd][f8][d3][cc][79][2f][52] 
[19][82][cd][93][57][aa][2b][ae] 
[54][7a][9f][05][57][8c][d2][c0] 
[85][31][3e][5d][47][48][1c][42][92] 
透過表 4.8 與表 4.6 與 4.7 之比較，可得知在不同之祕密鑰匙加密下，輸入相同的明文
會得到不同的明文，且密文之間差異甚大，因此一般而言要解讀出封包內容並不容易，然而
此對於真正的密碼學家用處並不大，因此有必要就常見之攻擊手法進行逐一分析以及探討，
而在這部份本研究乃採國外之相關研究進行探討，常見之破解手法如表 4.9 所示。 
  82
計時破解法是指根據加解密之執行時間，取得鑰匙與明文之相關資訊。由於加解密
演算法之執行時間會隨著輸入的改變不同，故計時攻擊法利用此項特性可以計算出秘密鑰
匙中位元 1之個數(Hamming weight)[12]，且其為一種「只知道密文」之攻擊方式，雖然僅
算出 Hamming weight 無法得知正確的秘密鑰匙為何，但對於猜測正確鑰匙有著相當大的
幫助，然而到目前為止，這項手法無法有效地破解 DES，更遑論威力更強大的 Triple DES
與 AES。 
2. 差異破解法(Differential Cryptanalysis) 
直到 1990 年，差異破解法才正式地出現在文獻上，而第一份成果是由 Murphy 所發
表，其破解了名為 FEAL 之區段加密法[13]，此外 Biham 與 Shamir 亦曾發表論文[14]證實差異
破解法能夠破解許多加密法與雜湊函數。 
差異破解法是第一個能夠在複雜度低於 255的情況下就破解 DES 的方法，且此架構僅
需耗費 247級的成本即可成功破解 DES，，雖然與暴力破解法(需要 255級成本)相比少了許
多，但要自行選擇 247個自選明文卻相當困難，故該破解法通常只在學術界討論。在實際
應用上，其破解 DES 之效果並不良好，最主要的原因在於 DES 在開發時(1974)便已發現差
異破解法，故其中許多元素便是針對差異攻擊法加以設計，而由於 AES 為最新一代之加密
標準，其最初設計標準即為抵抗現有之攻擊手法，因此差異破解法對 AES 而言並無太大效
果。 
3. 線性破解法(Linear Cryptanalysis) 
線性攻擊法的原理在於尋找用來描述 DES 的轉換行為之線性近似(linear 
approximations)，利用此方法對 DES 進行破解需要 247個已知明文，與差異破解法相比較，
取得已知明文較自選明文容易，然而至目前為止，很少有研究指出線性破解法是有效的，
其對於 DES 的破解在實作上亦是不可行的，對 AES 亦同。 
4. 數學攻擊法(Mathematical Attacks) 
數學攻擊法主要是針對 RSA 之攻擊手法，其可分為下列三種： 
z 將 n分解成兩個質因數，藉此計算 (n) = (p-1)x(q-1)φ ，即可算出私密鑰匙 d。 
z 直接算出 (n)φ 而不必先算出 p和 q，藉此亦可計算 -1d = e (mod (n))φ 。 
z 直接計算 d而不先行計算 (n)φ 。 
多數針對 RSA 之密碼破解均著重於對 n之分解，因將其分解為兩個質因數 p和 q後
即可計算出其使用之私密鑰匙 d，因此 RSA 安全性的指標通常便指其抵抗因數分解之能
力。 
而由於計算機之運算能力持續增強，且因數分解演算法之技術亦持續改進，故最有
效之抵禦方法即為增加鑰匙之長度，因此學者們建議在不久的將來，合理的 RSA 鑰匙長
度應介於 1024 至 2048 位元之間，而本研究採用之鑰匙長度為 1024 位元，因此對於抵抗
數學攻擊法之效能在現今尚可，未來則可能需要提升鑰匙長度。 
除了決定鑰匙長度外，專家學者們並提出下列三點建議，以避免 n太容易遭到因數
  84
表 4.10 採用了四種不同的鑰匙長度進行測試，分別為 32 位元、56 位元(DES)，128 位
元(AES)以及 168 位元(3-DES)，此外亦顯示替代碼(substitute codes)之效果，其為 26 個字
母所組成，而 26 個字母之任意排列均可視為一把鑰匙；在表中假設了現行的計算機速度可以
在每微秒（百萬分之一秒）使用一把可能鑰匙對密文進行解密，就表 4.10 之結果而言，32
位元之鑰匙由於長度過短，故在 35.8 分鐘其所有鑰匙均會經過嘗試，因此其安全性便不足
夠，而 56、128 以及 168 位元長度之鑰匙在此運算速度下安全性尚足夠；然而攻擊者在攻擊
時並不會僅採用一部電腦，其會對高性能的電腦進行平行串接與同步運算，則運算效能可大
幅提昇數個數量級，因此表 4.10 最後一欄顯示運算速度在每微秒使用百萬把鑰匙對密文進行
解密之結果，其結果顯示 56 位元之鑰匙長度已不敷使用，在 10 個小時內可告破解，而本研
究中所採用之AES使用128位元之鑰匙長度，表4.10顯示其在超級電腦之攻擊下仍需5.4x1018
年才可破解，故就當前而言，暴力破解法對於 AES 尚不構成威脅。 
4.3 系統效率分析 
ATMS 之最大特點即在於其即時性， TMIC 會接收由 TCIS 傳送而來之路口訊息，如車流
狀況，時制計劃等資訊，而 TMIC 會利用接收而來之資訊，對架設於路口之號誌控制器(Traffic 
Signal Controller, TSC)或是資訊可變標誌(Changeable Message Sign, CMS)下達變更訊息
指示，然而其傳輸過程中，網路環境的穩定性以及封包的傳輸費時 ATMS 之效率影響甚鉅。 
本研究最主要的目的即為在開放之網路環境下於 ATMS 中加入一安全機制，以提升其抵
禦攻擊的能力，然而添加安全機制亦會產生一負效用，由於加密以及產生鑰匙等動作均會增
加系統之耗時，且對封包加密亦會改變其大小，此兩方面對系統效率之影響便為本小節探討
之目標。 
4.3.1 封包變化分析 
本研究之安全機制中，主要採用由對稱式加密法和非對稱式加密法搭配而成之混雜系統
作為其核心，利用非對稱式加密法進行數把秘密鑰匙之更換，接著在通訊過程中，隨機選取
一秘密鑰匙作為雙方之通訊鑰匙；故主要的加密動作仍集中於對稱式加密法，非對稱式加密
法之加密動作則僅止於交換鑰匙時。 
在 Java程式語言中，我們利用了 java.crypto.Cipher這個類別對資料進行加密，Cipher
可稱為「加密器」，故對稱式加密法所採用之加密器即稱為「對稱型 Cipher」，而其主要可分
為下列兩種： 
1. 串流式加密器(Stream Cipher) 
串流式加密器之最大特點即在於它一次僅針對一個字元進行加密或解密，因此加解
密次數即與字元之數量相同，雖然其較安全但相對而言甚費時，Vigenere 加密法與
Verman 加密法為其代表，而現行使用之對稱式加密法則很少採用串流式加密器。 
2. 區塊式加密器(Block Cipher) 
區段式加密器與串流式加密器最大的不同點即在前者加密或解密之對象為固定大
小之資料區塊，原始訊息會被切成數個區塊，而加密器會分別對其進行加密動作；以往
  86
 
圖 4.6 PKCS#5 之區塊填充法 
 
  88
6 222 224 0.90 
7 249 256 2.81 
8 277 288 3.97 
0%
2%
4%
6%
8%
10%
12%
14%
16%
1 2 3 4 5 6 7 8 車道數
封包變化比較圖
 
圖 4.8 封包變化比較圖 
一般而言，物件大小剛好為加密區段之整數倍之機率並不高，即便其物件大小為加密區
段整數倍，PKCS#5 亦會加入填充字元，故無論如何，只要對資料進行加密，其封包大小必定
會增加，而根據圖 4.8 顯示，其封包大小的變化率為隨機狀態，端賴其本身大小與加密區段
之關係而定。若封包大小為 N位元組，加密區段為 E位元組，則可導出其加密後之封包大小
X(位元組)如式 4.1： 
X = (N mod  E +1)  E×  
(4.1) 
而其封包變化百分比 P可表示為式 4.2： 
NP =   100%
(N mod  E +1)  E
×
×
 
(4.2) 
由上述可知，無論封包的大小為何，其加密器均會對其進行填充字元的填補，而封包大
小的增加，對於傳輸效能是否具有影響。則透過實驗一進行進一步的驗證。 
 實驗一：封包填充對傳輸時間之影響分析 
  90
1Byte vs. 16Bytes
0
10
20
30
40
50
60
70
80
90
0 2 4 6 8 10 12 14 16 18 20 22 時間(時)
傳
輸
費
時
(ms)
1Byte
16Bytes
 
圖 4.9 封包傳輸耗時比較圖(1Byte vs. 16Bytes) 
透過上述的圖表數據，本研究利用 Excel 進行兩平均數差之假設檢定： 
0Η ：封包填充對於傳輸時間無影響 
1Η ：封包填充對於傳輸時間有影響 
(4.3) 
在顯著水準為 0.05 下，利用 Excel 進行 t檢定，顯著水準為 0.05，得統計報表 4.13： 
表 4.13 封包填充 t檢定表 
兩個母體平均數差的檢定，假設變異數不相等     
  1Byte 16Bytes 
平均數 37.44906545 41.19479305
變異數 109.5193597 222.6820102
觀察值個數 12 12
假設的均數差 0   
自由度 20   
t 統計 -0.711911657   
P(T<=t) 單尾 0.242370878   
臨界值：單尾 1.724718218   
P(T<=t) 雙尾 0.484741756   
臨界值：雙尾 2.085963441   
  92
 實驗二數據分析 
1. RSA 鑰匙長度為 768 位元 
數據搜集整理後得表 4.14、4.15 與圖 4.10~4.14，圖 4.10 為 AES 產生鑰匙所耗費
時間，可明顯看出其所產生鑰匙越多，則耗時越長；圖 4.11 為 RSA 密碼系統總耗時，
可發現鑰匙產生所耗費時間相當均勻，約在 380 毫秒左右，而加密時間與解密時間均隨
著鑰匙數上升而增加，解密之耗時相對於加密而言高得多，平均而言，解密所耗費時間
約為加密之 3.35 倍；圖 4.12 為其整體鑰匙交換耗時分析圖，由圖中可看出在鑰匙交換
的過程中，所耗費之時間幾乎等於 RSA 密碼系統之總費時(包含產生鑰匙、加密以及解
密)，而 AES 產生鑰匙相對而言耗時微乎其微。 
表 4.14 RSA 分送鑰匙效能分析(768 位元) 
秘鑰數 
(把) 
秘鑰耗時
(ms) 
金鑰對 
(ms) 
公鑰加密 
(ms) 
私鑰解密
(ms) 
總耗時 
(ms) 
8  5  354  36  119  529  
16  8  376  71  227  696  
24  11  434  102  335  896  
32  15  353  133  442  957  
40  20  350  174  554  1111  
48  22  438  199  644  1316  
56  26  393  230  755  1418  
64  29  399  265  869  1582  
72  35  436  306  1024  1817  
80  34  368  321  1068  1809  
88  40  348  350  1175  1939  
96  44  365  381  1329  2139  
104  49  410  412  1427  2316  
112  52  357  434  1519  2381  
120  59  369  469  1624  2539  
128  66  322  496  1723  2623  
  94
鑰匙交換綜合比較(RSA Key長768位元)
0
500
1000
1500
2000
2500
3000
8 16 24 32 40 48 56 64 72 80 88 96 104 112 120 128 鑰匙數(把)
耗
時
(m
s) AES
RSA
Total
 
圖 4.12 鑰匙交換綜合比較(768 位元) 
表 4.15 AES 鑰匙數 vs.總耗時之迴歸分析(768 位元) 
摘要輸出           
         
迴歸統計       
R  0.99761       
R 平方 0.995225       
調整的 R 平
方 0.994884       
標準誤 48.01724       
觀察值個數 16       
         
ANOVA        
  自由度 SS MS F 顯著值   
迴歸 1 6727769 6727769 2917.942 1.19E-17   
殘差 14 32279.18 2305.655     
總和 15 6760048         
  係數 標準誤 t 統計 P-值 下限 95% 上限 95% 
截距 433.7164 25.18045 17.22433 8.06E-11 379.7097 487.7231 
x:鑰匙把數 17.58353 0.325513 54.01798 1.19E-17 16.88538 18.28169 
  96
表 4.16 RSA 分送鑰匙效能分析(1024 位元) 
鑰匙數 
(把) 
秘鑰耗時 
(ms) 
金鑰對 
(ms) 
公鑰加密 
(ms) 
私鑰解密 
(ms) 
總耗時 
(ms) 
8  4  904  41  241  1202  
16  8  998  80  430  1527  
24  12  1018  136  678  1857  
32  16  946  196  885  2057  
40  20  940  229  1080  2282  
48  23  981  262  1295  2577  
56  26  1073  295  1559  2972  
64  29  991  306  1683  3028  
72  32  1008  342  1901  3304  
80  37  951  360  2051  3420  
88  45  921  392  2247  3624  
96  43  885  416  2440  3800  
104  48  927  456  2647  4093  
112  52  954  490  2853  4366  
120  55  1014  522  3053  4662  
128  59  1012  553  3253  4904  
AES產生鑰匙耗時(RSA Key長1024位元)
0
10
20
30
40
50
60
70
8 16 24 32 40 48 56 64 72 80 88 96 104 112 120 128
鑰匙數
(把)
耗
時
(m
s)
 
圖 4.14 AES 產生鑰匙耗時(1024 位元) 
  98
 
表 4.17AES 鑰匙數 vs.總耗時之迴歸分析(1024 位元) 
摘要輸出           
         
迴歸統計       
R 的倍數 0.996951       
R 平方 0.993911       
調整的 R 平
方 0.993476       
標準誤 90.57587       
觀察值個數 16       
         
ANOVA        
  自由度 SS MS F 顯著值   
迴歸 1 18747757 18747757 2285.201 6.52E-17   
殘差 14 114855.8 8203.988     
總和 15 18862613         
         
  係數 標準誤 t 統計 P-值 下限 95% 上限 95% 
截距 1108.649 47.49839 23.34077 1.31E-12 1006.775 1210.523 
x:鑰匙把數 29.35251 0.614021 47.80377 6.52E-17 28.03556 30.66945 
AES鑰匙數 vs.總耗時(RSA Key長1024位元)
y = 29.353x + 1108.6
R2 = 0.9939
0
1000
2000
3000
4000
5000
6000
0 20 40 60 80 100 120 140 鑰匙數
(把)
耗
時
(m
s)
 
圖 4.17AES 鑰匙數 vs.總耗時(1024 位元) 
  100
AES鑰匙耗時(RSA Key長2048位元)
0
10
20
30
40
50
60
70
8 16 24 32 40 48 56 64 72 80 88 96 104 112 120 128
鑰匙數(把)
耗
時
(m
s)
 
圖 4.18 AES 產生鑰匙耗時(2048 位元) 
 
RSA密碼系統耗時(RSA Key長2048位元)
0
5000
10000
15000
20000
25000
8 16 24 32 40 48 56 64 72 80 88 96 104 112 120 128
鑰匙數(把)
耗
時
(m
s) KeyPair
Encrypt
Decrypt
 
圖 4.19 RSA 密碼系統耗時(2048 位元) 
  102
 
AES鑰匙數 vs.總耗時(RSA Key長2048位元)
y = 172.47x + 10486
R2 = 0.9537
0
10000
20000
30000
40000
0 20 40 60 80 100 120 140
鑰匙數(把)
耗
時
(m
s)
 
圖 4.21 AES 鑰匙數 vs.總耗時(2048 位元) 
4. 綜合分析 
在前三項我們分別探討了 RSA 鑰匙長度為 768、1024 以及 2048 位元之情況下，其
交換鑰匙之系統分析，並推導出其個別之迴歸模型，而在本小節中，會針對三種不同鑰
匙長度進行綜合分析與比較。  
產生AESKey耗時比較
0
10
20
30
40
50
60
70
8 16 24 32 40 48 56 64 72 80 88 96 104 112 120 128 鑰匙數(把)
總
耗
時
(m
s) 768
1024
2048
 
圖 4.22 產生 AES 秘密鑰匙耗時比較表 
  104
由圖 4.22 可看出三種鑰匙長度之實驗情況下，TCIS 端產生 AES 不同數量祕密鑰匙所耗
費之時間，由於 AES 產生鑰匙所耗費之時間與 RSA 並無關聯性，故可看出在三種鑰匙長度下，
產生 AES 秘密鑰匙所耗費的時間相差無幾；而圖 4.23、4.24 以及 4.25 則為 RSA 在三種鑰匙
長度之耗費效能評比，由圖 4.23 可看出 RSA 在產生金鑰對的時間分布屬均勻，與欲加密之明
文(AES 秘密鑰匙數)無關，在 768 位元時平均耗時約 380ms，1024 位元時平均耗時約 970ms，
2048 位元時則大幅上升至 10311ms；圖 4.24 及圖 4.25 為 RSA 在三種鑰匙長度下，對不同數
量之 AES 祕密鑰匙加解密之耗時比較，可看出其耗時隨著欲交換之鑰匙數量增加，而在解密
所耗費之時間相對加密而言甚鉅，在 768 位元時，解密耗時平均約為加密之 3.34 倍，1024
位元時解密耗時約為加密耗時之 5.44 倍，而在鑰匙長度為 2048 位元時，解密耗時平均為加
密耗時之 19.56 倍。將其整理後得表 4.20： 
表 4.20 RSA 綜合比較表 
鑰匙長度 
(bit) 
768 1024 2048 
產生 AES 秘鑰平均
費時(ms) 
32 32 33 
產生 RSA 金鑰對平
均費時(ms) 
380 970 10311 
RSA 
解密/加密 
3.34 5.44 19.56 
迴歸方程式 yˆ = 17.584x + 433.72 yˆ = 29.353x + 1108.6 yˆ = 172.47x + 10486
2R  0.9952 0.9939 0.9537 
  106
 加密： 
接收密文後，取出相對應之秘密鑰匙對其進行解密，並紀錄解密所耗費時
間 DecryptTime，將密文還原成明文後取出 Flag 以及呼叫 Decode 方法，
將其轉譯並印出該物件中所包含之參數，接著透過 Ethernet 回傳取出之
Flag 以及(DecryptTime)至 TMIC。 
(4) TMIC 在接收由 TCIS 回傳之 Flag 以及 DecryptTime 後，便可證實 TCIS 確實收到
傳送之封包，接著其取出系統時間(End Time)，單位同樣為毫秒，並至資料庫
中搜尋與接收之 Flag 相對應之欄位，取出先前存入之系統時間(Start Time)，
並與 End Time 相減後可得該封包傳輸所耗費之時間(Elapse Time)，最後再將
其與 DecryptTime 紀錄至 SQL Server 資料庫中，圖 4.26 為資料庫之欄位及部
分資料。 
 
圖 4.26 資料庫欄位 
  108
傳輸耗時
0
20
40
60
80
100
120
85 112 139 168 195 222 249 277
封包大小
(byte)
耗
時
(m
s) 30-D
30-E
60-D
60-E
 
圖 4.27 傳輸耗時(未加密(D)vs.加密(E)) 
表 4.22 傳輸平均耗時比較表 
 加密(ms) 
週期(s) 
未加密耗時 
(ms) 總耗時 加解密耗時 
30 70.5 83.6 13.3 
60 67.0 90.1 14.1 
平均 68.75 86.85 13.7 
 
  110
 
表 4.23 傳輸週期 vs.封包大小(未加密) 
封包 
 
週期 
1 2 3 4 5 6 7 8 
30(s) 68(ms) 67 72 67 75 78 69 68 
60 67 65 70 65 63 69 67 70 
 
表 4.24 二因子變異數分析---週期 vs.封包大小(未加密) 
雙因子變異數分析：無重複試驗    
ANOVA      
變源 SS 自由度 MS F P-值 臨界值 
週期 49 1 49 4.635135 0.068317 5.591448 
大小 90 7 12.85714 1.216216 0.40141 3.787044 
錯誤 74 7 10.57143    
       
總和 213 15     
 
（2） 加密 
而在加密的情況下我們亦對表 4.25 進行二因子變異數分析，顯著水準亦為 0.05，
虛無假設與對立假設同式 4.7 與 4.8，分析後得結果為表 4.26。 
表 4.25 傳輸週期 vs.封包大小(加密) 
封包 
 
週期 
1 2 3 4 5 6 7 8 
30 73 76 91 91 76 84 92 86 
60 76 78 83 91 90 101 100 102 
 
  112
 加密因子 
 0H  :加密對於傳輸時間無影響 
 1H  :加密對於傳輸時間有影響 
(4.10) 
 封包大小 
0H  :封包大小對於傳輸時間無影響 
1H  :封包大小對於傳輸時間有影響 
(4.11) 
 加密因子與封包大小之交互作用 
  0H  :加密因子與封包大小無交互影響 
  1H  :加密因子與封包大小具交互影響 
(4.12) 
表 4.28 封包大小 vs.加密因子 
車道 
加密 1 2 3 4 5 6 7 8 
未加密 
(ms) 
68 
67 
67 
65 
72 
70 
67 
65 
75 
63 
78 
69 
69 
67 
68 
70 
平均 67.5 66 71 66 69 73.5 68 69 
加密 73 76 
76 
78 
91 
83 
91 
91 
76 
90 
84 
101 
92 
100 
86 
102 
平均 74.5 77 87 91 83 92.5 96 94 
表 4.29 二因子變異數分析---重複實驗(加密因子 vs.封包大小) 
二因子變異數分析：重複實驗    
ANOVA       
變源 SS 自由度 MS F P-值 臨界值 
加密因子 2628.125 1 2628.125 74.55674 2.03E-07 4.493998
封包大小 597.875 7 85.41071 2.422999 0.067636 2.657197
交互作用 388.875 7 55.55357 1.575988 0.212931 2.657197
組內 564 16 35.25    
       
總和 4178.875 31     
  114
表 4.31 累積機率百分比(未加密) 
 車道 
耗時 1 2 3 4 5 6 7 8 
0-20 10.8 12.1 4.2 17.4 11.8 13.6 8 5.2 
21-40 28.4 30.7 18 35.4 25.6 29.8 21.4 21.4 
41-60 30.7 44.1 31.6 45.2 42 44.2 38.6 43.6 
61-80 70.2 75.2 70 67.6 74.8 60.2 65.6 68 
81-100 87.9 88.9 81.8 74.8 88.8 70.6 83.6 74.8 
101-120 100 100 96.6 95.8 95.6 88.8 96.6 93 
121-140 100 100 100 99.2 99.2 99.2 99 97 
141-160 100 100 100 99.2 100 100 99 100 
161-180 100 100 100 100 100 100 99 100 
181-200 100 100 100 100 100 100 100 100 
201-220 100 100 100 100 100 100 100 100 
累積機率分布圖(未加密)
0
20
40
60
80
100
120
10 30 50 70 90 110 130 150 170 190 210 耗時(ms)
累
積
百
分
比
(%
)
1車道
2車道
3車道
4車道
5車道
6車道
7車道
8車道
 
圖 4.29 累積機率分布圖(未加密) 
 
 
 
  116
交控中心人員可就加密情況以及未加密，針對其對可靠度之要求，給定 Time-Out 機制一明確
等候時間，使得中心程式在傳送加密封包時，能夠更具效率，且不會因為加密封包之傳輸時
間增加，而認為其封包失效而再度傳送，造成系統資源的不當浪費。 
表 4.33 可靠度門檻表(未加密 vs.加密) 
未加密之可靠度門檻值 
可靠度門檻值(%) 70 75 80 85 90 95 
傳 輸 時 間 門 檻 值
(ms) 
67 70 77 85 94 108 
加密之可靠度門檻值 
可靠度門檻值 70 75 80 85 90 95 
傳輸時間門檻值
(ms) 
97 104 112 120 128 141 
  118
換鑰匙數量，其中 x為欲交換之鑰匙數量， yˆ為預測之總耗時，單位為(ms)。 
    768 位元： yˆ = 17.584x + 433.72 
   1024 位元： yˆ = 29.353x + 1108.6 
   2048 位元： yˆ = 172.47x + 10486 
6. 透過實驗三可得下列兩點小結： 
（1） 在傳輸週期 30 與 60 秒之情況下，傳輸週期對於封包在 LAN 之傳輸費時並無顯
著影響。   
（2） 加密對於系統傳輸有著顯著影響，平均而言加解密需耗費 13.7 毫秒，而未加密
之封包於 LAN 傳輸需費時約 68.75 毫秒，加密過後則需費時約 86.9 毫秒，加密
對於傳輸時間約提昇 18.2 毫秒。 
7. 由於加密會造成傳輸總時間之增加，因此本研究在加密前後亦進行可靠度分析(見表
4.33)，藉此可讓交控中心人員或程式透過其要求之可靠度訂定一 Time-Out 機制等候
門檻值，使得中心傳輸資源不會造成無謂的浪費。 
5.2 建議 
未來在資訊安全與交控系統結合之研究中，仍有許多值得研究與發展之處，而本研究之
相關建議如下： 
1. 在第三章曾經提出 TMIC 以及 TCIS 須共用一函數 f(x) 進行雙方鑰匙的選擇，而要設計一
個良好的函數(即表示其鑰匙重複機率極低且不亦猜測)，牽涉到較複雜的數學理論，故
本研究對該處並未詳加探討，未來研究可在此處多加著墨。 
2. 本研究所提出之動態加密安全機制以及研究理論雖未經由目前線上侵入者入侵系統作測
試，但對於未來的 ATMS 資訊安全研究卻不失為一個起頭，在未來可以此為基礎加以延伸。 
3. 本研究在祕密鑰匙之管理採用 Java 之 I/O 方法，將其存入硬碟中，然而其具有遭入侵者
盜取之風險，較佳作法乃採用 Java 之 KeyStore 物件進行管理，然其必須透過付費方式，
已取得第三具公信力機構之認證，故本研究未加以採用，而未來較具經費之研究單位在
管理鑰匙方面可採用此作法。 
4. 本研究僅針對封包傳輸進行加密保護，而對於本機電腦之安全性並未多加著墨，如第 3
  120
參考文獻 
英文部分 
1. National Transportation Communications for ITS Protocol (NTCIP) 
Guide, NTCIP Joint Standards Committee, Draft Version 2, 1997。 
2. Coppersmith, D. “The Data Encryption Standard (DES) and Its Strength 
against Attacks.” IBM Journal of Research and Development, May 1994 
3. B.Scneier, “Description of a New Variable-Length Key, 64-Bit Block 
Cipher (Blowfish).” Fast Software Encryption, Cambridge Workshop 
Proceedings (December 1993), Springer-Verlag, 1994, pp 191-201.  
4. Daeman, J., and Rijmen, V. AES Proposal Rijndael, Version 2. 
Submission to NIST, March 1999. 
http://csrc.nist.gov/encryption/aes. 
5. Daemen, J., and Rijmen, V. “Rijndael: The Advanced Encryption 
Standard.” Dr.Dobb’s Journal, March 2001. 
6. http://www.bouncycastle.org/  
7. Lidl, R., and Niederreiter, H. “Introduction to Finite Fields and 
Their Applications.”  Cambridge: Cambridge University Press, 1994. 
8. Whitfield Diffie and Martin E. Hellman, Member, IEEE “New Directions 
in Cryptography.” Proceedings of the AFIPS National Computer 
Conference, June 1976. 
9. Rivest. R., Shamir, A., and Adleman, L. “A Method for Obtaining 
Digital Signatures and Public Key Cryptosystems.” Communications of 
the ACM, February 1978. 
10. Koblitz, N. “Elliptic Curve Cryptosystems.” Mathematics of 
Computation Vol. 48, Number 177, January 1987, pp 203-209. 
11. Simmons, G., ed. Contemporary Cryptography: The Science of 
Information Integrity. Piscataway, NJ: IEEE Press, 1992. 
12. Hevia, A., and Kiwi, M. “Strength of Two Data Encryption Standard 
Implementations Under Timing Attacks.” ACM Transactions on 
Information and System Security, November 1999. 
13. Murphy, S. “The Cryptanlysis of FEAL-4 with 20 Chosen Plaintexts.” 
Journal of Cryptography, No. 3, 1990. 
  122
(一)&(二)」，交通部委託研究計劃，2001 年 3 月。 
31. 中華智慧型運輸系統協會，「符合 NTCIP 的無線寬頻 ATMS 交控示範系
統（一）」，交通部委託研究計劃，2004 年 12 月。 
32. 交通部，「都市交通控制通訊協定 3.0 版」，2004 年 11 月。 
33. 黃韋凱，「台灣地區專用交通管理資訊庫(TMIB)之研究」，國立台灣大
學土木工程所交通組研究所碩士論文，2003 年 6 月 
34. 陳佳良，「NTCIP 物件利用 GPRS 傳輸之時間可靠度研究」，國立台灣大
學土木工程所交通組研究所碩士論文，2005 年 6 月。 
35. 胡育銘，「應用資訊安全於分散式測驗系統之研究」，國立台南師範學
院資訊教育研究所碩士論文，2002 年 6 月。 
36. 王青青，巫坤品譯，William Stallings 原著，「密碼學與網路安全原理與
實務第三版」，碁峯資訊股份有限公司，2004 年五月。 
37. 王旭正，柯宏叡「密碼學與網路安全理論、應用與實務」，博碩文化股份有
限公司，2004 年 5 月。 
38. 阮韻芳譯。Jonathan Knudsen 原著，「JAVA 密碼學」，1999 年三月。 
39. 王文中，「EXCEL 於資料分析與統計學上的應用」，博碩文化股份有限公司，
1997 年 9 月。 
40. 楊豐瑞，楊豐任，「網路概論與實務」，松崗電腦圖書資料股份有限公司，2001
年 1 月。 
41. 交通部運研所網站(http://www.iot.gov.tw/mp.asp?mp=1) 
42. 冠 陞 工 程 企 業 有 限 公 司
(http://www.kangsang.com.tw/control_center.htm) 
 
 
 2
壹  2008 AATT 
1.1 會議源起 
兩年一度之 AATT先進運輸技術學術研討會係於 1989年起辦理，當年也是 ITS的源頭。其
研討重點在科技化應用於解決交通設計、運作、管理的學術性探討。通常都有 1000位來自世界
各國運輸學術界人士參加。本屆是由希臘雅典科技大學主辦。 
 
1.2 會議議程 
 會議時間：2008 年 5 月 28-30 日 
 會議地點：希臘雅典第凡內大飯店 
 主辦機構：雅典科技大學主辦 
 會議方式：主要為專題演講、正規論文報告 
 
1.3會議主題 
Advanced Technologies in Transportation  
• Alternative Fuels and Propulsion System  
• Artificial Vision and Image Processing 
• ITS and Telematics 
• Man-Machine Interface 
• Technology Policy and User Acceptance 
• Traffic Monitoring, Simulation, and Control 
• Wireless and Broadband Communication 
• Sensors to support Transportation Operation 
• Vehicle Navigation, Guidance and Control  
Transportation Planning  
• Economics and Innovative Finance 
• Emergency Response and Evacuation 
• Vehicle Control  
• Incorporating Safety Management in 
Planning 
• System and Operations Planning and 
Modeling 
• Systems Engineering  
• Traffic Safety and Accidents 
• Transport Security 
• Telecommunication and e-commence 
Information Technology in Transportation  
• Management Information systems 
• New Software Tools and Implementation 
• GIS 
• Parallel and Distributed Processing 
• Reliability and Risk Analysis 
• System Integration and Interoperation 
• Web-Enabled Planning, Design, and 
Construction 
Transportation Modeling and Analysis 
• Soft Computing, Data Mining and Analysis
• Travel Behavior 
• Simulation and Modeling 
• Traffic Theory, Flow and Control 
• Statistical and Econometric Modeling 
• Optimization and Control 
• Artificial Intelligence and Novel Computing 
 4
INTRODUCTION 
 
In recent decades, Advanced Safety Vehicle (ASV) has been a hot spot research field in the Intelligent 
Transportation Systems (ITS). It is to develop an on-board system for automatic detection, diagnosis, 
decision, actuating warning and as well as avoidance of collision, etc. In this study, a collision warning 
algorithm is proposed, particular in determining thresholds of warning timing. The driving condition 
herein is divided into three levels: safe, cautious and dangerous. There are two thresholds should be 
identified: the threshold between safe level and cautious level, and the threshold between cautious level 
and dangerous level. The thresholds depend upon driver’s reaction-time. The former one is denoted as t1 
in seconds and the later one as t2 too. The measures can be taken as: t1 means the time when one brakes 
lightly while t2 means the time when one brakes on dangerous situations (forced brake). In general, 
‘reaction-time’ is measured by the manipulating factors with respect to relative distance, relative speed, 
relative acceleration, and by the driver’s factors of sex, age, experience, health, the length of continuity 
in driving etc. To measure t1 and t2, the preliminary initial values in spite of driver’s factors, can be 
obtained from field measurement. For further states, a neural network learning procedure is set up to 
adjust t1 and t2, that considers the driver’s prime attributes at that moment. 
Hideo (1996) developed an anti-collision for rear-end. Its equipment contains a radar system and a CCD. 
Seiler et al. (1998) developed a collision warning/avoidance system (CW/CA). They modified Mazda 
and Honda’s algorithms to offer a warning mechanism. Basically, the algorithm is from the aspect of 
distance-to-collision. Burgett et al. (1998) developed a collision warning algorithm for rear-end 
collisions. Based on relative motions between a preceding and an equipped vehicle, the warning criteria 
were established and confined on three zones along with different relative motion types. Jocoy and 
Knight (1998) also proposed an Intersection Collision Avoidance (ICA) system, applying radar 
equipment to track circumstance of intersection traffic. Mertz et al. (2000) studied an anti-collision 
system for transits. Song et al. (2004) designed an anti-lateral-collision system. The equipment is 
supersonic detectors. However, they all haven’t discussed the thresholds of t1 and t2. 
 
MEASUREMENT 
 
In general, a driver will perform a light brake when his or her vehicle is approaching and closing to its 
preceding car in a dilemma distance. While the driver thinks the distance is too tight, that a collision 
possibly occurs, he or she will execute a forced brake. The time at light braking is considered as t1 and 
forced braking as t2. In this study, the testing vehicle equips a CMOS camera on board (Fig.1-left). 
Through image processing, the relative distance can be obtained (Fig.1-right). Then by a mathematical 
difference method, relative velocity and acceleration are also calculated. Furthermore, the authors had 
successed to employ computer networking, displaying the scenario videos in the assigned website, and 
each visitor viewed the videos playing and hitted indicated function key representing brake when 
necessary he or she was thinking. The computer recorded each player’s reaction time including light 
braking (first stage of deceleration) and forced braking. Fig.2 shows a scenario video. 
 
 6
where, x1 denotes relative velocity (kph), and x2 is driving frequency (times/week). The regression is 
with F-value =14.635 and P-value almost vanishes. This expresses Eqn.(1) significant. 
The result for t2 is  
t2 = -0.152x1 + 0.107 x3+ 0.093 x2 -2.357                                         (2) 
where, x1 denotes relative speed (kph), x2 is driving frequency or timing (times/week), and x3  is 
running speed (kilo-meter/hour). The regression is with F-value =338.373 and P-value approaches 
vanish. Eqn.(2) is also significant. 
According to the results, the key factors on reaction time for braking actuation are relative velocity, 
driving frequency and running speed. Particularly, running speed is considered at forced braking, but 
light braking.  
Since ‘driving frequency’ is needed to input by driver when starting on board, Eqn.(1) and (2) are hardly 
practicing at this moment. Therefore, this study omits the thorny factor in practice and modifies Eqn.(1) 
and (2) by considering the observable factors only with x1 and x3. The result yields:  
t1= -0.065 x1 -0.076 x3 +16.292                                      
                  (3) 
t2= -0.152 x1 +0.107 x3 -2.164                                                       
  (4) 
 
THE WARNING MODULE 
 
Each driver has his/her own reaction time at the time of driving, hence the reaction time is not a constant. 
The study provides an artificial neural network (ANN) for the reaction time learning process based on 
the observable-key factors obtained from the last section. Each driver during starting period is assumed 
sober-minded and vigilant. His/Her behavior about t1 and t2 corresponding to x1 (relative speed), and x3 
(running speed) will be learned by ANN. The outcome of ANN is set to be specific t1 and t2 for the 
driver in a normal condition. Fig.3 reveals the network, where wi is the mimic weight representing the 
strength between an upper layer neuron and a down-stream layer neuron. Σ is a mechanism of 
summation. ϕ (.) is an active function, transferring Σ into the designed or normalized range of t1 and t2.  
 
Figure 3.  A conceptual ANN model for finding the thresholds t1 and t2 
 
In general, the relationship in Fig.3 can be modeling as: 
 8
 
Basically, the decision flow chart is depicted as Fig.4. Firstly, applying ANN to learn t1 and t2 under 
all testing drivers. In implementation, ECU utilizes the data transmitted from equipped sensors or CCD 
to obtain parameters including relative distance Dr, relative speed and relative acceleration/deceleration 
rates, further by the way of  γβα −−  filter to estimate next step parameters. Then, input the 
estimated parameters to the warning module and have an output of safe, cautious or dengerous sounds. 
Figure 5 illustates the ranges in a certain threshold condition. However, the range will be varied while 
the threshold is being changed on other driving conditions. 
 
Relative 
Distance 
Detection
Afa-Beta-
Gamma Filter
Warning 
Module
Cautious
Safe
Dangerous
Warning Unit
Estimation Model
r r rt=k, D .v .a
r r rt=k+1, D .v .a
ANN Learning 
for t1, t2
 
Figure 4.  Decsion flow chart in implementation 
 
 
Figure 5.  Thresholds in distance 
 
 10
貳  2008兩岸都市交通會議 
2.1 會議議程 
 會議時間：2008 年 9 月 18-20 日 
 會議地點：南京中山陵國際會議大飯店 
 主辦機構：東南大學、上海科協、江蘇省科協主辦 
 會議方式：主要為專題演講、正規論文報告 
2.2 本人發表之論文 
 
中國傳統預測方法於交通事故分析之現代解 
Modern Description to Traffic Accident Analysis with Chinese Traditional 
Prediction Approach 
 
張堂賢 許毓芳 游上民 
台灣大學土木工程研究所交通組 
10617 台灣台北市羅斯福路四段一號 
摘要 
現今交通安全相關研究不外乎從駕駛行為、車輛狀況與道路環境著手研究。而中國傳統預測
學術已存在數千年，歷史源遠流長。本研究結合中國傳統的四柱八字推命與現代科學之資料探
勘，挖掘出現有肇事資料中所隱含之資訊，以探討四柱八字之原理與交通事故之相關性，以及探
討四柱八字是否可用來預測事故之發生。希望能引起學者專家對傳統經典研究之興趣，將中國傳
統文化揉合現代科學方法加以驗證發揚。 
中文關鍵字：交通安全、易經、四柱八字、資料探勘 
Keywords：traffic safety、Yi-Jing、Bar-Tzi、data mining 
引言 
交通安全攸關人們的生命財產，一直以來是備受矚目的課題。目前交通事故相關研究不外乎
從人、車、路，也就是從駕駛行為、車輛狀況與道路環境著手研究。本研究擬從中國傳統預測學
說之角度切入，結合現代科學方法，探討中國傳統卜卦學理與交通事故之關係。 
「人法地，地法天，天法道，道法自然」，中國傳統文化崇尚自然，講求「天人合一」順應
大自然、與自然達成平衡，也從大自然中取得知識。傳統方法在很多時候被認為是迷信，或是毫
無規則可言。然事實上，以中國傳統預測方法為例，皆源於中國最古老的經典之一—《易經》。 
《易經》始自古人仰觀天文、俯察地理、觀鳥獸之文與地之宜，將自然現象歸納成八類。起
初是人們在禍福難測、不確定因素多時而使用占卜來尋求慰藉，這些事情不外乎是出獵、捕魚、
征戰…，後經長期觀察天象、地理，以及依照卜卦結果吉凶之經驗統計集結成冊，便成《易經》
的雛型，因此基本上《易經》即是形態學的概念經由經驗法則之歸納與演繹而成。 
在尚未有數學模式的時代，中國老祖先們早已懂得運用東方獨有的八卦、陰陽五行學說…等
方法對事物進行預測，暫且大膽假設這些方法有一定的準確性，方能流傳數千年仍不衰。接下來
 12
由上述可知，欲明易理之精義—氣、數、象、理，可從觀察宇宙萬事萬物之現象著手，觀「象」
可知「數」，觀數可知「氣」，氣出於「道」，是以知氣則明「理」。 
1.3 陰陽、四象、八卦 
《繫辭上傳》云：「是故易有太極，是生兩儀。兩儀生四象，四象生八卦」。太極乃天地人物
之本體，宇宙人生等萬有之根源。陰陽、四象、八卦皆有消長、循環、生生不息之特性。 
1.3.1 陰陽（兩儀） 
無極生太極。太極動而生陽，動極而靜，靜而生陰，靜極復動。宇宙間萬物皆有陰陽屬性，
陰中有陽，陽中有陰，兩者互相對立、依靠、轉化、消長，因彼此的消長，陰陽可變化出許多不
同之現象分類。 
(1) 陽（ ）：表天、父、熱、晝、表面、過去、破壞力、開放、單數等…。 
(2) 陰（ ）：表地、母、寒、夜、裡面、未來、包容力、內藏、複數等…。 
1.3.2 四象 
 兩儀生四象。「陽」被分為太陽、少陰；「陰」則被分為太陰、少陽。因此四象是指：太陽、
少陰、少陽、太陰，分別可以代表春、夏、秋、冬；生、長、老、死等等四類事物和現象，將事
物和現象分成四個階段、四種相聯繫的情況。 
(1) 太陽（ ）：為事物的陽性特徵上升，陰性特徵下降並分別達到各自相應的極點時的事物
狀態。 
(2) 少陰（ ）：為事物在陰性特徵逐漸增加，陽性特徵逐漸減少的過程中達到的事物的另一
種陰陽平衡狀態。 
(3) 太陰（ ）：為事物的陰性特徵上升，陽性特徵下降並分別達到各自相應的極點時的事物
狀態。 
(4) 少陽（ ）：為事物在陽性特徵逐漸增加，陰性特徵逐漸減少的過程中達到的事物的陰陽
平衡狀態。 
此為「圓環式的思考」而非「單線式的思考」。陰極陽生、陽極陰生，萬事萬物生生不息、循
環不已，可用正弦函數表示 。 
1.3.3先後天八卦 
先天八卦由伏羲氏所作，又稱伏羲卦；後天八卦則由文王所作，又稱文王卦。先天八卦為體、
後天八卦為用。目前之應用絕大多數為後天八卦，例如方位。 
     
 14
 
圖 8. 五術體系架構圖 
2. 四柱八字與交通安全之關係 
由上述可知，縱使中國傳統的預測方法都源自於易經，方法卻非常多元。經研究後發現，適
合用於交通事故分析的方法包括了五術中的「命」、「卜」、「相」，也就是命理、占卜、相術、堪
輿…等方法，然受現有資料限制，本研究選擇「四柱八字推命法」作為中國傳統預測方法於交通
事故分析現代解之初探。本研究期望利用現有之科學方法，在這些複雜的排列組合中找出與交通
事故相關之規則，研究流程如下圖： 
肇事資料
取得
中國傳統方法
之選定
四柱起法與肇事相關之八字規則
資料探勘
方法研究
現有肇事資料
符合八字規則
之比例
研擬適用於現代
之八字規則
結果分析
四柱八字推命
肇事時間、
肇事者生日
轉換成干支
資料
初步整理
 
演 
繹 
歸
納
 16
地支 -1 +6 +10 +5 -1 +6 +0 +7 +2 +8 +3 +9 
2.1.4 時柱的排法 
取其干支得使用「鼠遁日起時法」。口訣為：「甲己還需甲； 乙庚丙作初。丙辛從戊起； 丁
壬庚子居。戊癸何方發； 壬子是真途。」如下表所示： 
表 3. 五鼠遁日起時表 
時支 
依次為 
23-1 時 
子 
1-3 時 
丑 
3-5 時
寅 
5-7 時 
卯 
7-9 時 
辰 
9-11 時
巳 
11-13 時
午 
13-15 時
未 
15-17 時
申 
17-19 時
酉 
19-21 時 
戌 
21-23 時 
亥 
日干為 
甲或己 甲子 乙丑 丙寅 丁卯 戊辰 己巳 庚午 辛未 壬申 癸酉 甲戌 乙亥 
日干為 
乙或庚 丙子 丁丑 戊寅 己卯 庚辰 辛巳 壬午 癸未 甲申 乙酉 丙戌 丁亥 
日干為 
丙或辛 戊子 己丑 庚寅 辛卯 壬辰 癸巳 甲午 乙未 丙申 丁酉 戊戌 己亥 
日干為 
丁或壬 庚子 辛丑 壬寅 癸卯 甲辰 乙巳 丙午 丁未 戊申 己酉 庚戌 辛亥 
日干為 
戊或癸 壬子 癸丑 甲寅 乙卯 丙辰 丁巳 戊午 己未 庚申 辛酉 壬戌 癸亥 
2.2與車禍相關之八字規則研究 
本研究之資料來源為 2007年台北市信義、南港、大安、中正區之有效肇事資料 15466筆，取
發生事故之年、月、日、時與肇事者之出生年、月、日，轉換成四柱八字之型態後進行分析。由
於受資料限制，本研究僅使用與肇事者年柱、月柱、日柱相關者之八字規則為基礎做分析，相關
之規則如下： 
(1) 命局中有二馬以上者：命局中地支有寅申巳亥（驛馬）二支以上，遇大運流年來補齊者。 
(2) 身強之人：如表所示。(滿像現代的 Fuzzy 邏輯) 
表 4. 身強、身弱之判斷 
 月支
日干 寅 卯 辰 巳 午 未 申 酉 戌 亥 子 丑 
甲乙 強 強 強 弱 弱 弱 弱 弱 弱 強 強 強 
丙丁 強 強 強 強 強 強 弱 弱 弱 弱 弱 弱 
戊己 弱 弱 弱 強 強 強 弱 弱 弱 弱 弱 弱 
庚辛 弱 弱 弱 弱 弱 弱 強 強 強 弱 弱 弱 
壬癸 弱 弱 弱 弱 弱 弱 強 強 強 強 強 強 
(3) 流年之干支與命局地支合，形成強烈忌神。 
  「合」又分三合與六合，三合為：申子辰合水局，亥卯未和木局，寅午戌合火局，
巳酉丑合金局，辰戌丑未合土局。六合為：子丑合土，寅亥合木，卯戌合火，辰酉合金，
巳申合水，午未合土。  
(4) 命局四柱地支逢沖或刑時。 
 所謂相沖為：子午相沖，丑未相沖，寅申相沖，卯酉相沖，辰戌相沖，巳亥相沖。
相刑則分成四種，包括了：無禮之刑—子刑卯、卯刑子；恃勢之刑—申刑寅、寅刑巳、
巳刑申；無恩之刑—戌刑未、未刑丑、丑刑戌；自刑—辰刑辰、午刑午、酉刑酉、亥形
亥。 
 18
當增益（Lift）大於 1，表示規則的預測結果比單純的亂數還要好。若規則表示為 X⇒ Y ，則
三項指標的計算公式與意義分別介紹如下： 
(1) 支持度（Support）：在規則（Rule）中，項目一起出現的交易紀錄佔全部交易紀錄的百
分比。最小支持度能篩選掉不顯著的規則。公式如下： 
Support ( X ⇒  Y ) = P( X ∩ Y ) 
(2) 信賴度（Confident）：代表此條規則所含的預測強度。計算在前提項目 X發生的情況下，
發生結果 Y 的機率。公式如下： 
Confidence(X⇒ Y) = P(Y|X) = 
)(
)(
XP
YXP ∩   
(3) 增益（Lift）：比較信賴度與結果項目 Y 單獨發生時之機率兩者間的大小。公式如下： 
Lift(X=>Y) = 
)()(
)(
YPXP
YXP ∩  = 
)(
)|(
YP
XYP  
進行關聯規則時，其主要分為兩個主要階段： 
(1) 找出所有的高頻項目組（Frequent Itemsets）：依據定義，高頻項目組所出現的次數必
須大於等於事先定義的最小支持度數目。 
(2) 從找到的高頻項目組產生關聯規則：所產生的規則必須滿足決策者所給定支持度與信賴
度的最低門檻值，規則才能成立。 
2.4預期成果 
(1) 現有資料之肇事發生時間與肇事者生日間，符合四柱八字中「易肇事」規則之之比例為多
少。包括各規則符合之比例與所有規則之比例。 
(2) 使用資料探勘之方法歸納、挖掘現代肇事資料中所隱含之八字關係或規則。 
(3) 傳統四柱八字中易肇事規則與使用現代資料探勘結果之異同。 
(4) 從四柱八字中易肇事規則與資料探勘之結果，分析哪些規則對事故發生之影響較大。 
(5) 探討四柱中哪些因素（參數）對事故發生的影 
2.5初步分析成果 
從目前分析之案例，取數個範例分析如下 
範例一：男命。年柱：己未；月柱：癸酉；日柱：己丑；時柱：癸酉。用神：土金水。身弱。
事故發生時，大運為辛未，流年為庚辰。 
此例符合易肇事八字之規則有：流年支干支與命局合—辰酉合；命局中酉酉自刑、丑
未相沖。 
範例二：女命。年柱：癸巳；月柱：甲子；日柱：丙申；時柱：癸巳。用神：火木。身弱。
事故發生時，大運為己巳，流年為乙酉。 
此例符合易肇事八字之規則有：命局中含三個驛馬星，又逢大運也是驛馬；大運己巳，
與命局之日柱成申巳合；命局中兩巳與一申互刑，又逢大運來沖刑；用神為火、木，火剋
酉金，木剋己土。 
範例三：女命。年柱：庚戌；月柱：庚辰；日柱：戊寅；時柱：壬子。用神：火。身弱。事
