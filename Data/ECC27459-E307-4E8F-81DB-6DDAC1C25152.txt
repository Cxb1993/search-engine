Algorithms for Haplotype Block Partitioning and Tag
SNP Selection Problems Under Various Constraints
Yaw-Ling Lin‚àó
Dept. Computer Science and Information Engineering
Providence University, Taiwan
E-mail: yllin@pu.edu.tw
Abstract.
Global patterns of human DNA sequence variation (haplotypes) defined by common single nucleotide
polymorphisms (SNPs) have important implications for identifying disease associations and human
traits. Recent genetics research reveals that SNPs within certain haplotype blocks induce only a few
distinct common haplotypes in the majority of the population. The existence of haplotype block
structure has serious implications for association-based methods for the mapping of disease genes.
Our ultimate goal is to select haplotype block designations that best capture the structure within
the data. Here in this paper we propose several efficient combinatorial algorithms related to selecting
interesting haplotype blocks under different diversity functions that generalizes many previous results
in the literatures. In particular, given an m√ó n haplotype matrix A, we show linear time algorithms
for finding all interval diversities, farthest sites, and the longest block within A.
For selecting the multiple long blocks with diversity constraint, we show that selecting k blocks with
longest total length can be be found in O(nk). We also propose linear time algorithms in calculating
the all intra-longest-blocks and all intra-k-longest-blocks. For dealing with missing SNP data, we show
in this paper that the minimum diversity problem is NP-complete.
Keywords: algorithm, SNP, haplotype, diversity, haplotype block selection, missing data.
1 Introduction
Mutation in DNA is the principle factor that is responsible for the phenotypic differences among human
beings, and SNPs (single nucleotide polymorphisms) are the most common mutations, hence it is funda-
mental to complete a map of all SNPs in the human population. For this purpose a SNP is defined as a
position in a chromosome where each one of two (or more) specific nucleotides are observed in at least 10%
of the population [17]. The nucleotides involved in a SNP are called alleles. It has been observed that for
almost all SNPs only two different alleles are present, in such case the SNP is said biallelic, otherwise the
SNP is said multiallelic. In this paper, we will consider exclusively biallelic SNPs.
In diploid organisms, such as humans, each chromosome is made of two distinct copies and each copy
is called a haplotype. It is known that exactly one haplotype is inherited from the father and the other
is from the mother. More precisely, in the absence of recombinations events, each haplotype in a child
is identical to one of the two haplotypes of each parent. Whenever recombinations occur, a haplotype of
the child may consists of portions of both haplotypes of a parent. A current high-priority phase of human
genomics involves the development of a full Haplotype Map of the human genome [13].
There is currently a great deal of interest in how the recombination rate varies over the human genome.
The primary reason for this is the excitement about using linkage disequilibrium (LD) to map and identify
human disease genes. LD mapping (also known as ‚Äùassociation mapping‚Äù) differs from traditional linkage
‚àóThis work is supported in part by the National Science Council, Taiwan, R.O.C, grant NSC-97-2221-E-126-009.
Here in this paper we propose several efficient algorithms related to selecting interesting haplotype blocks
under different evaluation (diversity) functions that generalizes many previous results in the literatures
[2, 17, 23, 24, 6, 21, 14, 22, 1, 15, 9].
Diversity functions
Several operational definitions have been used to identify haplotype-block structures, including LD-based
[6, 21], recombination-based [14, 22], information-complexity-based [1, 15, 9] and diversity-based [2, 17, 24]
methods. The result of block partition and the meaning of each haplotype block may be different by using
different measuring formula. For simplicity, haplotype samples can be converted into haplotype matrices
by assigned major alleles to 0 and minor alleles to 1.
Definition 1 (haplotype block diversity) Given an interval [i, j] of a haplotype matrix A, a diversity
function, Œ¥ : [i, j]‚Üí Œ¥(i, j) ‚àà R is an evaluation function measuring the diversity of the submatrix A(i, j).
Haplotype blocks are the genome regions with high LD, thus it implies that no matter what kinds
of haplotype block definition we used, the patterns of haplotype within the block will be small, and the
diversity of the block will be low. In terms of diversity functions, the block selection problem can be viewed
as finding a segmentation of given haplotype matrix such that the diversities of chosen blocks satisfy certain
value constraint. Following we examine several haplotype block diversity evaluation functions. Given an
m √ó n haplotype matrix A, a block S(i, j) (i, j are the block boundaries) of matrix A is viewed as m
haplotype strings; they are partitioned into groups by merging identical haplotype strings into the same
group. The probability pi of each haplotype pattern si, is defined accordingly such that
‚àë
pi = 1. As an
example, Li [16] proposes a diversity formula defined by
Œ¥D(S) = 1‚àí
‚àë
si‚ààS
p2i . (1)
Note that Œ¥D(S) is the probability that two haplotype strings chosen at random from S are different from
each other. Other measurements of diversity can be obtained by choosing different diversity function; for
example, to measure the information-complexity one can choose the information entropy (negative-log)
function [1, 15, 9]:
Œ¥E(S) = ‚àí
‚àë
si‚ààS
pi log pi. (2)
In the literatures [17, 23, 24], Patil and Zhang et al. define a haplotype block as a region where at least
80% of observed haplotypes within a block must be common haplotype. As the same definition of common
haplotype in the literatures, the coverage of common haplotype of the block can be formulated as a form
of diversity:
Œ¥C(S) = 1‚àí
‚àë
si‚ààC
pi‚àë
si‚ààU
pi
=
‚àë
si‚ààM
1
m‚àë
si‚ààU
pi
. (3)
Here U denotes the unambiguous haplotypes, C denotes the common haplotypes, and M denotes the
singleton haplotypes. In other words, Patil et al. require that Œ¥C(S) ‚â§ 20%.
Some studies [6, 26, 25] propose the haplotype block definition based on LD measure D‚Ä≤; however,
there is no consensus definition for it so far. Zhang and Jin [26] define a haplotype block as a region in
which all pair-wise |D‚Ä≤| values are not lower than a threshold Œ±. Let S denote a haplotype interval [i, j].
We define the diversity as the complement of minimal |D‚Ä≤| of S. By the definition, S is a haplotype block
if its diversity is lower than 1‚àí Œ±.
Œ¥L1(S) = 1‚àímin{(|D‚Ä≤i‚Ä≤j‚Ä≤ |)|i ‚â§ i‚Ä≤ < j‚Ä≤ ‚â§ j}. (4)
Zhang et al. [25] also propose the other definition for haplotype block; they require at least Œ± proportion of
SNP pairs having strong LD (the pair-wise |D‚Ä≤| greater than a threshold) in each block. Similarly, we can
3
Results
The rest of the paper is organized as the following. In Section 2, we propose an O(mn + n2) time,
linear proportional to the input plus output size, algorithm for computing the all-interval-diversities
problem. We also show that all farthest-sites can be found totally in O(mn) time, linear proportional to
the input size. As a corollary, we show that the longest-block can be found in O(n) time by examining
the O(n)-sized farthest-sites array; that is, the the longest-block can be found in linear time. In
Section 3, we show that the k-longest-blocks can be found in O(nk). These blocks can be identified by
examining the farthest-sites array and sing the technique of sparse dynamic programming. We also show
that the all-intra-longest-block can be found totally O(n2) time, which is a linear time algorithm
proportional to the output size. The problem of all-intra-k-longest-blocks can be found totally in
O(n2k) time, which is a linear time algorithm proportional to the output size. In Section 6, we discuss
approaches in dealing with missing data, and we show some hardness results concerning the minimum
diversity problem.
2 Computing Diversities of all Blocks
Given an m√ón haplotype matrix A, the goal here is to compute the all pairs block diversity values. That
is, output the set {Œ¥(i, j) | 1 ‚â§ i ‚â§ j ‚â§ n}. Here we show that by using techniques of the suffix tree
[10, 19], there exits an O(mn + n2) time, linear proportional to the input plus output size, algorithm for
computing the all-interval-diversities problem. Consider the 7 √ó 11 haplotype matrix illustrated at
Figure 1, the computation of the submatrix diversity, say A(4, 7), can be illustrates at Figure 2.











		






 		 =‚àí‚àí=Œ¥
 
 
  
Figure 2: Compute the diversity of submatrix A(4, 7).
A naive algorithm would try to enumerate all different O(n2) blocks, each with data sized as much as
O(mn). While it takes at least linear time in computing the diversity of each submatrix, thus a totally
O(mn3) operations would be needed.
To obtain the desired linear time algorithm for computing all diversities, we use the suffix tree data
structure [10, 19]. It is well known that, given a string s ‚àà ‚àë‚àó of length n, the suffix tree of s, Ts,
that consists of all suffixes of s as leaves can be constructed in linear time. Thus, given an m √ó n
haplotype matrix A, our linear time algorithm begins by constructing m suffix trees of m rows of A,
T = {TA(1,1,n), TA(2,1,n), . . . , TA(m,1,n)}, in totally O(mn) time. Figure 3 illustrates the m suffix trees of
the given m√ó n haplotype matrix, where Si(j) denotes the jth suffix of row i.
After obtaining these m suffix trees, we can merge these m trees and obtain the total suffix tree T ‚àó with mn
leaves. Note that T ‚àó can also be obtained by concatenating the original m row-strings of the haplotype
matrix into one long string u = A(1, 1, n)]A(2, 1, n)] ¬∑ ¬∑ ¬∑ ]A(m, 1, n) and constructing the corresponding
suffix tree Tu, where ‚Äò]‚Äô denotes a symbol that does not appear in alphabets of the matrix. Note that the
structure of T ‚àó is equivalent to Tu. The next step of the algorithm is to construct n confluent subtrees,
which is discussed in the following.
5
tree ordering of L; otherwise, we can use the data structure of van Emde Boas [20] for sorting these finite
ranged integers in O(|A| log log |A|) time. The correctness and the time analysis of the proof is omitted
for most of the details are similiar to the arguments presented in [3]. ¬§
By Lemma 1, in O(mn) time, we can partition leaves of T ‚àó into n sets {A1, A2, . . . , An}, where Ai consists
of all m suffixes started at column i in given haplotype matrix. These Ai‚Äôs subsets can be used to construct
the corresponding n confluent LCA subtrees, T ‚àó‚ÜëAi ‚Äôs, as illustrated in Figure 5.
		 
		 		 		
 
Figure 5: The corresponding n confluent LCA trees for n columns in a haplotype matrix.
Each LCA tree T ‚àó‚ÜëAi represent the changing structure of m rows of submatrix A(i, n). Figure 6 shows an
example the confluent LCA subtrees, T ‚àó‚ÜëA8 , taken from the haplotype matrix shown in Figure 1. Observe
how the LCA tree reveals the structure of A(8, 11).
		

 



































Figure 6: The 8-LCA tree reveals the topological structure of 7 strings of A started at the 8th column.
Event List
The idea is to build up the event-list for each LCA tree T ‚àó‚ÜëAi so that all diversity values started at i, Œ¥(i, ¬∑)‚Äôs,
can be obtained in O(m+n) time. To do so, we need to perform a BFS-like search on each LCA tree T ‚àó‚ÜëAi .
This can be done by the bucket-sort technique. We first visit each node of all T ‚àó‚ÜëAi ‚Äôs, and append each
node into a global depth-list, ranked according to its distance to the root. After that, we pick up nodes
in the depth-list by the increasing depth order, and append them into the final event-list, as illustrated in
Figure 7.
	











































	
 

































Figure 7: The event list of the 8-LCA tree.
7
That is, the k-th block of the maximal segment S in [1, j] either does not include site j; otherwise, the
block [L[j], j] must be the last block of S. Note that f(k, 1, j) can be determined in O(1) time suppose
f(k ‚àí 1, 1, ¬∑)‚Äôs and f(k, 1, 1..(j ‚àí 1))‚Äôs being ready. It follows that f(k, 1, ¬∑)‚Äôs can be calculated from
f(k ‚àí 1, 1, ¬∑)‚Äôs, totally in O(n) time. Thus a computation ordering from f(1, 1, ¬∑)‚Äôs, f(2, 1, ¬∑)‚Äôs, . . . , to
f(k, 1, ¬∑)‚Äôs leads to the following result.
Theorem 4 (k-longest-blocks) Given a haplotype matrix A and a diversity upper limit D, find a seg-
mentation consists of k feasible blocks such that the total length is maximized can be done in O(nk) time
after a linear time preprocessing.
Given A and D, the all-intra-longest-block asks to find, for all constrained interval [i, j] ‚äÇ [1, n],
the corresponding longest block B ‚äÇ [i, j] with Œ¥(B) ‚â§ D. That is, the values f(1, i, j)‚Äôs. Similarly, we
first prepare the farthest sites of A in O(mn) time. Here we show that the answer can be found in O(n2)
time after the preprocessing. Using similar idea as illustrated at Figure 8. It can be verified that
f(1, i, j) = max{f(1, i, j ‚àí 1), (j ‚àí L[j] + 1)}
That is, the longest block in [i, j] either does not include site j; otherwise, the block [L[j], j] must be
the longest (feasible) block within [i, j]. Note that f(1, i, j) can be determined in O(1) time whenever
f(1, i, 1..(j ‚àí 1))‚Äôs being ready. It follows that f(1, i, ¬∑)‚Äôs can be calculated totally in O(n) time. Thus a
computation ordering from f(1, 1, ¬∑)‚Äôs, f(1, 2, ¬∑)‚Äôs, . . . , to f(1, n, ¬∑)‚Äôs leads to the following result.
Theorem 5 (all-intra-longest-block) Given a haplotype matrix A and a diversity upper limit D, find
for all constrained interval [i, j] ‚äÇ [1, n], the corresponding longest block B ‚äÇ [i, j] with Œ¥(B) ‚â§ D can be
done in O(n2) time after a linear time preprocessing.
Note that the computation time is linear proportional to the output plus input size, and thus is an optimal
algorithm in regarding of time efficiency.
or all constrained interval [i, j] ‚äÇ [1, n], find the longest segmentation with k feasible blocks such that
the total length is maximized. That is, output the set S = {B1, B2, . . . , Bk}, with Œ¥(B) ‚â§ D for each
B ‚àà S,B ‚äÇ [i, j], such that |B1|+ |B2|+ ¬∑ ¬∑ ¬∑+ |Bk| is maximized.
The all-intra-k-longest-blocks asks to find, for all constrained interval [i, j] ‚äÇ [1, n], the longest
segmentation with k feasible blocks such that the total length is maximized. Again, the problem can be
solved by first prepare the farthest sites of A in O(mn) time. Here we show that the answer can be found
in O(n2k) time after the preprocessing. Using similar idea as illustrated at Figure 8. It can be verified
that
f(k, i, j) = max{f(k, i, j ‚àí 1), f(k ‚àí 1, i, L[j]‚àí 1) + j ‚àí L[j] + 1}
That is, the k-th block of the maximal segment S in [i, j] either does not include site j; otherwise,
the block [L[j], j] must be the last block of S. Note that f(k, i, j) can be determined in O(1) time
suppose f(k‚àí 1, i, ¬∑)‚Äôs and f(k, i, 1..(j‚àí 1))‚Äôs being ready. It follows that f(k, i, ¬∑)‚Äôs can be calculated from
f(k ‚àí 1, i, ¬∑)‚Äôs, totally in O(n) time. Thus f(k, ¬∑, ¬∑)‚Äôs can be calculated from f(k ‚àí 1, ¬∑, ¬∑)‚Äôs totally in O(n2)
time. Thus a computation ordering from f(1, ¬∑, ¬∑)‚Äôs, f(2, ¬∑, ¬∑)‚Äôs, . . . , to f(k, ¬∑, ¬∑)‚Äôs leads to the following
result.
Theorem 6 (all-intra-k-longest-blocks) Given A,D, there exits an O(kn2)-time algorithm to find, for
all constrained interval [i, j] ‚äÇ [1, n], the longest segmentation with k feasible blocks such that the total
length is maximized.
4 Experimental Results
In response to needs for analysis and observation of human genome variation, we have established a website
and apply the algorithms described in this paper to provide several analysis tools for bioinformatic and
genetic researchers. The web-based system consists of a list of PHP and PERL CGI-scripts together with
several C programs for selecting haplotype blocks and analyzing the haplotype diversity. We also collect
9
[3] R. Cole, M. Farach, R. Hariharan, T. Przytycka, and M. Thorup. An O(n log n) algorithm for the
maximum agreement subtree problem for binary trees. SIAM Journal on Computing, 30(5):1385‚Äì1404,
2002.
[4] M. Daly, J. Rioux, S. Schafiner, T. Hudson, and E. Lander. Highresolution haplotype structure in the
human genome. Nature Genetics, 29:229‚Äì232, 2001.
[5] E. Dawson, G. Abecasis, et al. A first-generation linkage disequilibrium map of human chromosome
22. Nature, 418:544‚Äì548, 2002.
[6] S. B. Gabriel, S. F. Schaffner, H. Nguyen, et al. The structure of haplotype blocks in the human
genome. Science, 296(5576):2225‚Äì2229, 2002.
[7] M.R. Garey and D.S. Johnson. Computers and Intractability ‚Äì A Guide to the Theory of NP-
Completeness. Freeman, New York, 1979.
[8] D.B. Goldstein. Islands of linkage disequilibrium. Nature Genetics, 29:109‚Äì111, 2001.
[9] G. Greenspan and D. Geiger. Model-based inference of haplotype block variation. In Seventh Annual
International Conference on Computational Molecular Biology (RECOMB), 2003.
[10] D. Gusfield. Algorithms on Strings, Trees and Sequences: Computer Science and Computational
Biology. Cambridge University Press, 1997.
[11] International HapMap Project. http://www.hapmap.org/index.html.en.
[12] D. Harel and R. E. Tarjan. Fast algorithms for finding nearest common ancestors. SIAM Journal on
Computing, 13(2):338‚Äì355, 1984.
[13] L. Helmuth. Genome research: Map of the human genome 3.0. Science, 293(5530):583‚Äì585, 2001.
[14] R. R. Hudson and N. L. Kaplan. Statistical properties of the number of recombination events in the
history of a sample of dna sequences. Genetics, 111:147‚Äì164, 1985.
[15] M. Koivisto, M. Perola, R. Varilo, W. Hennah, J. Ekelund, M. Lukk, L. Peltonen, E. Ukkonen, and
H. Mannila. An mdl method for finding haplotype blocks and for estimating the strength of haplotype
block boundaries. In 8th Pacific Symposium on Biocomputing (PSB), pages 502‚Äì513, 2003.
[16] W.H. Li and D. Graur. Fundamentals of Molecular Evolution. Sinauer Associates, Inc, 1991.
[17] N. Patil, A. J. Berno, D. A. Hinds, et al. Blocks of limited haplotype diversity revealed by high
resolution scanning of human chromosome 21. Science, 294:1719‚Äì1723, 2001.
[18] D. Reich, M. Cargill, E. Lander, et al. Linkage disequilibrium in the human genome. Nature, 411:199‚Äì
204, 2001.
[19] Esko Ukkonen. On-line construction of suffix trees. Algorithmica, 14(3):249‚Äì260, 1995.
[20] P. van Emde Boas. Preserving order in a forest in less than logarithmic time and linear space.
Information Processing Letters, 6:80‚Äì82, 1977.
[21] J.D. Wall and J.K Pritchard. Haplotype blocks and linkage disequilibrium in the human genome.
Nature Reviews Genetics, 4(8):587‚Äì597, 2003.
[22] N. Wang, J.M. Akey, K. Zhang, R. Chakraborty, and L. Jin. Distribution of recombination crossovers
and the origin of haplotype blocks: the interplay of population history, recombination, and mutation.
Am. J. Human Genetics, 71:1227‚Äì1234, 2002.
[23] K. Zhang, M. Deng, T. Chen, M.S. Waterman, and F. Sun. A dynamic programming algorithm for
haplotype block partitioning. In The National Academy of Sciences, volume 99, pages 7335‚Äì7339,
2002.
11
Appendix
Figure 9: A view of the haplotype sample ‚Äì HapMap phase II haplotypes, chr19 in the YRI panel ‚Äì by
diversity visualization tool.
No. of blocks Average no.
Common No. of requiring ‚â• 1 common All Common
Method SNPs/block blocks SNPs haplotype/block blocks(%) SNP(%)
Ours > 10 736 733 4.32 32.5 77.8
3‚àí 10 751 686 3.16 33.1 18.0
< 3 779 216 2.12 34.4 4.2
Total 2,266 1,635 3.18 100.0 100.00
Zhang‚Äôs > 10 742 738 4.23 28.8 75.5
3‚àí 10 909 842 3.03 35.3 19.5
< 3 924 274 2.12 35.9 5.0
Total 2,575 1,854 3.05 100.0 100.0
Patil‚Äôs > 10 589 589 3.75 14.2 56.8
3‚àí 10 1,408 1,396 2.92 34.1 30.7
< 3 2,138 1,776 2.30 51.7 12.4
Total 4,135 3,761 2.72 100.0 100.0
Table 1: The comparison of properties of haplotype blocks defined by Zhang, Patil and us with 80% of
common haplotype coverage.
6 Dealing with Missing Data
We have propose several efficient algorithm in trying to identify interesting haplotype blocks in the genome.
However, in reality, some SNPs may be missing, and we may fail to distinguish two distinct haplotypes
due to the ambiguity caused by missing data. These missing data may cause ambiguity in identification
of an unknown haplotype sample.
Let us generalize the notion of haplotype matrix A be an m√ón matrix of m observations over n markers
(sites) such that Aij ‚àà {0, 1, 3}; Aij = 3 when the j-th SNP site of observation i is missing. One way
13
ÂúãÁßëÊúÉË£úÂä©Âá∫Â∏≠ÂúãÈöõÂ≠∏Ë°ìÊúÉË≠∞ÂøÉÂæóÂ†±Âëä  
                                                              
Ë®àÁï´Á∑®Ëôü  NSC-97-2221-E-126-009.  
Ë®àÁï´ÂêçÁ®±  ‰∫∫ÔßêÂü∫Âõ†È´îÂñÆÂ•óÂûãÂçÄÂ°äÂàÜÊûêËàáÁõ∏ÈóúÂïèÈ°å‰πãÁ†îÁ©∂  
Âá∫Âúã‰∫∫Âì°ÂßìÂêç  
ÊúçÂãôÊ©üÈóúÂèäËÅ∑Á®±  
Ôß¥ËÄÄÔ¶±   
ÈùúÂÆúÂ§ßÂ≠∏Ë≥áË®äÂ∑•Á®ãÁ≥ªÊïôÊéà  
ÊúÉË≠∞ÊôÇÈñìÂú∞Èªû  April 11-12, 2008; Hangzhou, China  
ÊúÉË≠∞ÂêçÁ®±  The 2nd Annual Meeting of Asian Association for Algorithms and 
Computation 
ÁôºË°®Ô•ÅÊñáÈ°åÁõÆ  Algorithms for Haplotype Block Partitioning and Tag SNP Selection 
Problems Under Various Constraints 
  
‰∏Ä„ÄÅÔ•´Âä†ÊúÉË≠∞Á∂ìÈÅéÔºö  
Ô¶éÔ®ÅÂúãÈöõ‰∫ûÊ¥≤ÂçÄÊºîÁÆóÊ≥ïÂèäË®àÁÆóÔß§Ô•ÅÁ†îË®éÊúÉ(The 2nd Annual Meeting of Asian Association for 
Algorithms and Computation, AAAC‚Äô09)ÊòØ‰∫ûÊ¥≤Âú∞ÂçÄÈáçË¶ÅÁöÑÔ¶éÔ®ÅË®àÁÆóÔß§Ô•ÅÂèäÊºîÁÆóÊ≥ïÊúÉË≠∞‰πã‰∏Ä„ÄÇÊú¨Ô¶é
Ô®ÅAAAC‚Äô09ÈÄôÊ¨°ÊòØÂæû2009Ô¶éÁöÑ4Êúà11Êó•Ëá≥4Êúà12Êó•Âú®‰∏≠ÂúãÂ§ßÔßìÁöÑÊù≠Â∑ûÂ∏Ç(Hangzhou)ËàâÔ®àÔºåÁ∏ΩÂÖ±ÁÇ∫Êúü
‰∫åÂ§©„ÄÇ‰ªäÔ¶éË®±Â§öÁï∂‰ª£ËëóÂêçË®àÁÆóÊ©üÁßëÂ≠∏ÂÆ∂Ô®¶Âá∫Â∏≠Ô¶∫ÈÄôÊ¨°ÊúÉË≠∞ÔºåÂ¶ÇFrancis Chin, Kazuo Iwama, Gerhard 
Woeginger, Kunihiko Sadakane, Xiaotie Deng, Hirotaka Ono Á≠âÔ®¶Âá∫Â∏≠Ô¶∫ÈÄôÊ¨°ÊúÉË≠∞„ÄÇÈÄôÊ¨°ÊúÉË≠∞‰∏≠ÔºåÊàë
ÁöÑÔ•ÅÊñáÂÆâÊéíÂú®Á¨¨‰∏ÄÂ§©‰∏ãÂçàÁöÑÁ¨¨‰∫åÂÄãsessionÔºåÈ°åÁõÆÊòØ‚ÄùAlgorithms for Haplotype Block Partitioning and 
Tag SNP Selection Problems Under Various Constraints‚ÄùÂæóÂà∞‰∏Ä‰∫õÔ•ßÈåØÁöÑÂõûÊáâ„ÄÇÊú¨Ê¨°ÊúÉË≠∞ÊàëÊòØÂîØ‰∏ÄÔ§≠
Ëá™‰∏≠ËèØÊ∞ëÂúãÂè∞ÁÅ£ÁöÑÂ≠∏ÁïåÁ†îÁ©∂‰∫∫Â£´ÔºåÂÖ∂ÂÆÉÁöÑÂ≠∏ËÄÖÂ§ßÂ§öÔ§≠Ëá™Êó•Êú¨ËàáË®±Â§öÊ≠êÊ¥≤Ôß§Ô•ÅÁïåÁöÑÂ≠∏ÁïåÁ†îÁ©∂‰∫∫Â£´„ÄÇ
Êú¨Ê¨°Â§ßÊúÉÁöÑ‰∏ªË¶Å organizer ‰πã‰∏ÄÊòØGuochuan Zhang (Zhejiang University)ÔºåÊàëÂÄëÈÅéÂéªÂú®Ë®±Â§öÊ¨°ÈáçË¶Å
ÊºîÁÆóÊ≥ïÂúãÈöõÊúÉË≠∞Â¶Ç ISAAC, MFCS,Ô®äÈù¢‰∏¶Ë®éÔ•ÅÈÅéË®±Â§öÊºîÁÆóÊ≥ïËàáË®àÁÆóÔß§Ô•ÅÂïèÈ°åÔºåÈÄôÊ¨°ÊúÉË≠∞Âú®‰ªñÂÄëÁöÑ
ÁµÑÁπî‰πã‰∏ãÈÅã‰ΩúÁöÑÂçÅÂàÜÈ†ÜÔßù„ÄÇÊúÉÂæåÊàë‰∏¶Âú®Áï∂Âú∞Ëàá Zhang Â§öË®éÔ•ÅÔ¶∫‰∏Ä‰∫õÊú™Ô§≠ÂÖ±ÂêåÂèØ‰ª•ÂÖ±ÂêåÁ†îÁ©∂ÁöÑÂïè
È°å„ÄÇ 
  
‰∫å„ÄÅËàáÊúÉÂøÉÂæóÔºö  
ÊÑüË¨ùÂúãÁßëÊúÉË£úÂä©Ê≠§Ê¨°ÊúÉË≠∞ÁöÑÔ¶ÉË≤ªÔºåËÆìÊú¨‰∫∫ËÉΩÂú®Ê≤íÊúâÁ∂ìÊøüË≤†Êìî‰∏ãÂ§öË™çÔßº‰∏Ä‰∫õË®àÁÆóÊºîÁÆóÊ≥ïÔ¶¥ÂüüÁöÑ
‰∏Ä‰∫õÂúãÈöõÊúãÂèã„ÄÅÂ¢ûÂä†‰∏Ä‰∫õÂÖ±ÂêåÁ†îÁ©∂ÁöÑÊ©üÊúÉ„ÄÇÊ≠§Ê¨°Ë®àÁÆóÊºîÁÆóÊ≥ïÊúÉË≠∞ÊúÄÂ§ßÁöÑÊî∂Á©´Èô§Ô¶∫Â§öÁü•ÈÅì‰∏Ä‰∫õÔ§Å
Êñ∞„ÄÅÔ§ÅÊúâË∂£„ÄÅÔ§ÅÊúâÊÑèÁæ©ÁöÑÁ†îÁ©∂È°åÁõÆÂèäÊñπÂêë‰πãÂ§ñÔºåÁï∂ÁÑ∂Â∞±ÊòØÂ§öË™çÔßºÊ≠§Ô¶¥ÂüüÁöÑ‰∏Ä‰∫õÁ†îÁ©∂ËÄÖ„ÄÇÁâπÂà•ÊòØÔºå
Âú®ÊàëÔ•ÅÊñáÂ†±ÂëäÂÆåÔ•ß‰πÖ‰πãÂæåÁöÑ‰ºëÊÅØÊôÇÈñìÔºåÊó•Êú¨Kyushu University ÁöÑ  Kunihiko Sadakane ÊòØ 
Compressed Suffix Trees Ëàá : Succinct Data Structures for Flexible Text Retrieval SystemsÁöÑÂ∞àÈñÄÁ†î
Á©∂‰∫∫Âì°ËàáÊàëÂÖ±Âêå‰∫§ÊèõÔ¶∫‰∏Ä‰∫õÊú™Ô§≠ÁµÑÂêàÊºîÁÆóÊ≥ïÂ¶Ç‰ΩïÊáâÁî®Âú®ÁîüÁâ©Ë≥áË®äÊäÄË°ì‰∏äÁöÑ‰∏Ä‰∫õÊÑèÔ®ä„ÄÇÈÄôÊ¨°ÊúÉË≠∞Êàë
‰πüÂ∞ç Hirotaka OnoÁ≠â‰∫∫Âú® A Faster Algorithm for L(2,1)-labeling of Trees È°åÁõÆÂæàÊúâËààË∂£Ôºå
‰ªñÂÄëÊúÄËøëÂ∞á Trees ‰∏äÁöÑ L(2,1)-labeling ÁöÑÂïèÈ°åÂÅöÂà∞ O(n) linear time; ÈÄô‰∫õÁµêÊûúÔºåÊàëÂÄëÂéª
Ô¶éÂú®Âè∞ÁÅ£Âä™Ô¶äÁöÑÂπæÂÄãÊúàÔºåÊ≤íÊÉ≥Âà∞‰ªñÂÄëÁöÑÁµêÊûúÊúâÈÄôÈ∫ºÂ•ΩÔºå‰πüÁµ¶Ô¶∫ÊàëË®±Â§öÁ†îÁ©∂ÊñπÈù¢ÁöÑÂïüÁ§∫„ÄÇ  
  
‰∏â„ÄÅÂª∫Ë≠∞Ôºö  
ÔßùÁî®ÂúãÈöõÊúÉË≠∞ÁöÑ‰∫§ÔßäÊ©üÊúÉÔºåÊàëÂÄëÂèØÂ∞áÊúÄÊñ∞ÁöÑÊàêÊûúÂ±ïÁèæÂú®‰∏ñ‰∫∫Èù¢ÂâçÔºåÂêåÊôÇ‰πüÂç≥ÊôÇÂú∞Ô¶∫Ëß£Âà∞ÁõÆÂâç
ÂúãÈöõÂ≠∏Ë°ìÁöÑÁµêÊûúËàáÊú™Ô§≠Á†îÁ©∂ÊñπÂêë„ÄÇÂú®ÈÄôÊ¨°Â§ßÔ¶öÊâÄËàâËæ¶Ê≠§ÊúÉË≠∞ÁöÑÊàêÂäüÁ∂ìÈ©ó‰πãÂæåÔºåÊú¨‰∫∫Ë™çÁÇ∫Ô•¥Âè∞ÁÅ£ËÉΩ
Â§öÂçîÂä©Á±åËæ¶‰∏Ä‰∫õÂ§†ÂìÅË≥™„ÄÅÈáçÔ•æÁ¥öÁöÑÂúãÈöõÊÄßÊúÉË≠∞ÔºåÂ∞çÂúãÂÆ∂ÁßëÂ≠∏ÁôºÂ±ï‰∏ÄÂÆöÊúâÂæàÂ§ßÁöÑÂä©Ô®ó„ÄÇ  
  
Âõõ„ÄÅÊîúÂõûË≥áÔ¶æÂêçÁ®±ÂèäÂÖßÂÆπÔºö  
Proceedings of The 2nd Annual Meeting of Asian Association for Algorithms and Computation 
(AAAC‚Äô09), Hangzhou, China, April 11-12, 2009. 
mapping methods in that marker-disease associations are sought in populations of unrelated individuals.
Such associations reflect the long evolutionary history of the chromosomal region (or the entire genome,
in case of genome-wide screens), involving recombination, mutation, demographic events, and (perhaps
most importantly) random reproductive success. The blocks of LD are regions, typically less than 100 kb,
in which LD decreases very little with distance between markers. Between these blocks, however, LD is
observed to decay rapidly with physical distance. Concomitant with the blocks of LD, these studies also
find low haplotype diversity within blocks. Often, more than 90% of the chromosomes in a sample possess
one of only two to five haplotypes within a block [4, 18, 17, 6, 5]. These results also show that the SNPs
within each block induce only a few distinct common haplotypes in the majority of the population, even
though the theoretical number of different haplotypes for a block containing n SNPs is exponential in n.
The existence of haplotype block structure has serious implications for association-based methods for
the mapping of disease genes. Conducting genome-wide association mapping studies could be much easier
than it used to be based on single marker [8]. On the one hand, if a causative allele occurs within a long
block of LD, then it may be difficult to localize that causative gene at a fine scale by association mapping.
On the other hand, if the diversity of haplotypes within blocks is low, then common disease genes may be
mapped, at least to within a haplotype block, by using far fewer markers than previously imagined [8].
Terminology and Problem Definition
Abstractly, input to the haplotype blocking problem consists of m haplotype vectors. Each position in
a vector is associated with a site of interest on the chromosome. Usually, the position in the haplotype
vector has a value of 0 if it is the major allele or 1 if minor allele.
Let the haplotype matrix A be an m√ó n matrix of m observations over n markers (sites). We refer to
the jth allele of observation i by Aij . For simplicity, we first assume that Aij ‚àà {0, 1}. A block, or marker
interval, [j, k] = „Äàj, j + 1, . . . , k„Äâ is defined by two marker indices 1 ‚â§ j ‚â§ k ‚â§ n. A segmentation is a
set of non-overlapping non-empty marker intervals. A segmentation is full if the union of the intervals is
[1, n]. The data matrix limited to interval [j, k] is denoted by A(j, k); the values of the ith observation are
denoted by A(i, j, k), a binary string of length k ‚àí j + 1. Figure 1 illustrates an example of a 7 √ó 11 0-1
haplotype matrix.
1 2 3 4 5 6 7 8 9 10 11
 1 2 3 4 5 6 7 8 9 10 11 
h1 1 0 0 0 0 0 1 0 0 0 1 
h2 1 0 1 1 0 0 0 1 1 0 0 
h3 0 0 1 0 0 0 1 1 0 0 1 
h4 1 1 1 0 1 0 0 0 1 1 1 
h5 1 1 0 0 0 1 1 0 1 1 1 
h6 0 0 0 0 0 0 1 0 0 0 1 
H7 0 1 0 0 0 0 1 1 0 0 0 
 
Figure 1: A haplotype matrix A and its corresponding submatrix A(8, 11).
Given an interval [j, k], a diversity function, Œ¥ : [j, k]‚Üí Œ¥(j, k) ‚àà R is an evaluation function measuring
the diversity of the submatrix A(j, k). We say an interval [j‚Ä≤, k‚Ä≤] is a subinterval of [j, k], written [j‚Ä≤, k‚Ä≤] ‚äÇ
[j, k], if j ‚â§ j‚Ä≤ and k‚Ä≤ ‚â§ k. Note that Œ¥-function is a monotonic non-decreasing function from [1..n, 1..n] to
the unit real interval [0, 1]; that is, 0 ‚â§ Œ¥(j‚Ä≤, k‚Ä≤) ‚â§ Œ¥(j, k) ‚â§ 1 whenever [j‚Ä≤, k‚Ä≤] ‚äÇ [j, k].
Given an input set of n haplotype vectors, a solution to the Haplotype Block Selection (HBS) Problem
is a segmentation of marker intervals, revealing these non-overlapped haplotype blocks of interest in the
chromosome.
Problem 1 (Haplotype Block Selection ‚Äì HBS (Generic))
Input: A haplotype matrix A.
Output: A set S of marker intervals satisfying some given constraints.
2
use the diversity to redefine the function. We define the diversity as the proportion of SNP pairs that do
not have strong LD. Therefore, haplotype interval S is a feasible haplotype block if its diversity is smaller
than a threshold. We can use the following diversity function to calculate the diversity of S. Here N(i, j)
denotes the number of SNP pairs that do not have strong LD in the interval [i, j].
Œ¥L2(S) =
N(i, j)(
(j‚àíi)+1
2
) = N(i, j)1
2 [(j ‚àí i)2 + j ‚àí i]
. (5)
Diversity measurement usually reflects the activity of recombination events occurred during the evolution-
ary process. Generally, haplotype blocks with low diversity indicates conserved regions of genome. By
using appropriate diversity functions, the block selection problem can be viewed as finding a segmentation
of given haplotype matrix such that the diversities of chosen blocks satisfy certain value constraint. In this
paper, we consider the following problems:
Problem 2 (all-interval-diversities) Given a haplotype matrix A, compute the all pairs block diversity
values. That is, output the set {Œ¥(i, j) | 1 ‚â§ i ‚â§ j ‚â§ n}.
Using techniques of the suffix tree [10, 19], we are able to propose an O(mn+n2) time, linear proportional
to the input plus output size, algorithm for computing the all-interval-diversities problem.
Problem 3 (farthest-sites) Given a haplotype matrix A and a given real diversity upper limit D, for
each marker site i find its corresponding farthest right marker j = R[i] so that Œ¥(i, j) ‚â§ D. That is, output
the set {R(i) = j | Œ¥(i, j) ‚â§ D < Œ¥(i, j+1), 1 ‚â§ i ‚â§ j ‚â§ n}. To simplify the boundary condition, we assume
that Œ¥(i, n+ 1) =‚àû.
We show that all farthest-sites can be found totally in O(mn) time, linear proportional to the input
size, by the the similar techniques of the suffix tree as in the all-pair-block-diversity problem.
Problem 4 (longest-block) Given a haplotype matrix A and a diversity upper limit D, find the longest
block [i, j] so that Œ¥(i, j) ‚â§ D. That is, output the argmaxi,j{|[i, j]| = j ‚àí i+ 1 | [i, j] ‚äÇ [1, n] and Œ¥(i, j) ‚â§
D}.
We show that the longest-block can be found in O(n) time by examining the O(n)-sized farthest-sites
array; that is, the the longest-block can be found in linear time.
Problem 5 (k-longest-blocks) Given a haplotype matrix A and a diversity upper limit D, find a seg-
mentation consists of k feasible blocks such that the total length is maximized. That is, output the set
S = {B1, B2, . . . , Bk}, with Œ¥(B) ‚â§ D for each B ‚àà S, such that |B1|+ |B2|+ ¬∑ ¬∑ ¬∑+ |Bk| is maximized.
We show that the k-longest-blocks can be found in O(nk). These blocks can be identified by examining
the farthest-sites array and sing the technique of sparse dynamic programming.
Problem 6 (all-intra-longest-block) Given a haplotype matrix A, a diversity upper limit D, for all
constrained interval [i, j] ‚äÇ [1, n], find the corresponding longest block B ‚äÇ [i, j] with Œ¥(B) ‚â§ D. That is,
output the argmaxB‚äÇ[i,j]{|B| | B ‚äÇ [i, j] and Œ¥(B) ‚â§ D}.
We show that the all-intra-longest-block can be found totally O(n2) time, which is a linear time
algorithm proportional to the output size.
Problem 7 (all-intra-k-longest-blocks) Given a haplotype matrix A, a diversity upper limit D, for all
constrained interval [i, j] ‚äÇ [1, n], find the longest segmentation with k feasible blocks such that the total
length is maximized. That is, output the set S = {B1, B2, . . . , Bk}, with Œ¥(B) ‚â§ D for each B ‚àà S,B ‚äÇ
[i, j], such that |B1|+ |B2|+ ¬∑ ¬∑ ¬∑+ |Bk| is maximized.
We show that the all-intra-k-longest-blocks can be found totally in O(n2k) time, which is a linear
time algorithm proportional to the output size.
4
  
  
 
	

	

	

	

	

	

	

	

	

Figure 3: The m suffix trees for m rows of a m√ó n haplotype matrix.
Confluent LCA Subtrees
The lowest common ancestor (LCA) between two nodes u and v in a tree is the furthest node from the
root node that exists on both paths from the root to u and v. Harel and Tarjan [12] have shown that
any n-node tree can be preprocessed in O(n) time such that subsequently LCA queries can be answered
in constant time.
Let T be a tree with leaf nodes L. Given S ‚äÇ L, let set Œõ(S) = {Lca(x, y) | x 6= y ‚àà S} denote the
collection of all (proper) lowest common ancestors defined over S.
Definition 2 (confluent subtree) The confluent subtree of S in T , denoted by T‚ÜëS, is a subtree of T
with leaves S and internal nodes Œõ(S). Further, u ‚àà Œõ(S) is a parent of v in T‚ÜëS if and only if u is the
lowest ancestor of v in T comparing to any other node in Œõ(S).
Our notation of confluent subtree is called induced subtrees in the literature [3]. Let T be a phylogenetic
tree with leaf nodes L. A post-order (pre-order, or in-order) traversal of nodes of L within T defines a tree
ordering of nodes on L. The following results is a generalization of the section 8 of [3].
Lemma 1 Let T be an n-node phylogenetic tree with leaf nodes L. The following subsequent operation can
be done efficiently after an O(n) time preprocessing. Given a query set A ‚äÇ L, the confluent subtree T‚ÜëA
can be constructed in O(|A|) time if A is given in sorted tree ordering; otherwise, T‚ÜëA can be constructed
in O(|A| log log |A|) time.
Confluent(T,A)
Input:A trees T with leaves L = {1, 2, . . . , n}, A ‚äÇ L.
Output: The confluent subtree of A in T , T‚ÜëA.
Preprocessing: Compute the tree ordering of L on T and the Lca queries preparation [12].
Notations: p[¬∑, T ‚Ä≤], left[¬∑, T ‚Ä≤], right[¬∑, T ‚Ä≤]: parent, left, right children links.
1 Let A = „Äàv1, v2, . . . , vk„Äâ be nodes of A in the tree ordering.
2 Create a dummy node Œª and let level[T, Œª]‚Üê +‚àû ; Push(S, Œª)
3 for i‚Üê 1 to k ‚àí 1 do B visit each vi‚Äôs.
4 x‚Üê Lca(vi, vi+1) ; y ‚Üê vi
5 while level[x, T ] > level[top[S], T ] do y ‚Üê Pop(S)
6 Push(S, x) ; p[vi+1, T ‚Ä≤]‚Üê x ; p[y, T ‚Ä≤]‚Üê x ; p[x, T ‚Ä≤]‚Üê top[S]
7 left[x, T ‚Ä≤]‚Üê y ; right[x, T ‚Ä≤]‚Üê vi+1 ; right[top[S], T ‚Ä≤]‚Üê x
8 root[T ‚Ä≤]‚Üê right[Œª, T ‚Ä≤] ; return T ‚Ä≤ as T‚ÜëA;
Figure 4: Computing the confluent subtree.
Proof. We propose an O(|A|) time algorithm, Confluent(T,A), shown in Figure 4. The algorithm
requires O(n) time preprocessing phase for building up the tree ordering of L on T , and perform the Lca
constant time queries preprocessing [12]. Further, the input A ‚äÇ L is assumed to be listed according to the
6
Lemma 2 The event-list of a given m√ó n haplotype matrix can be computed in O(mn) time.
By using the event-list, it is easily verified that diversities started at i, Œ¥(i, ¬∑)‚Äôs, can be obtained by following
the i-th entry of the event-list. Observe that there are at most m events along with each entry, and there
are at most n diversities need to be calculated. Thus diversities Œ¥(i, ¬∑)‚Äôs can be obtained in O(m+n) time
for each column i. It follows that all-interval-diversities can be found in O(mn + n2) time, linear
proportional to the input plus output size.
Theorem 1 (all-interval-diversities) Given an m √ó n haplotype matrix A, O(mn + n2) time suffices
to compute all interval diversities {Œ¥(i, j) | 1 ‚â§ i ‚â§ j ‚â§ n}.
Recall that, in the farthest-sites problem, with a given real diversity upper limit D, for each marker
site i we need to find its corresponding farthest right marker j = R[i] so that Œ¥(i, j) ‚â§ D. By using
the event-list and Lemma 2, it is easily verified that diversities started at i, Œ¥(i, ¬∑)‚Äôs, can be examined by
following the i-th entry of the event-list. Since there are at most m events along with each entry, the
farthest site can thus be identified in O(m) time for each column i. It follows that all farthest sites can be
found in O(mn) time, linear proportional to the input size.
Theorem 2 (farthest-sites) Given an m√ó n haplotype matrix and a given real diversity upper limit D,
for each marker site i we can find its corresponding farthest right marker j = R[i] so that Œ¥(i, j) ‚â§ D <
Œ¥(i, j + 1), totally in O(mn) time.
Corollary 3 (longest-block) Given an m√ón haplotype matrix and a diversity upper limit D, the longest
block with diversity not exceeding D can be found in O(mn) time.
3 Longest k Blocks with Diversity Constraints
We discuss a series of problem related to finding multiple blocks with diversity constraints in the section.
Given a haplotype matrix A and a diversity upper limit D, let S = {B1, B2, . . . , Bk} be a segmentation
of A with Œ¥(B) ‚â§ D for each B ‚àà S. The length of S is the total length of all block in S; i.e., `(S) =
|B1|+ |B2|+ ¬∑ ¬∑ ¬∑+ |Bk|. Our objective is to find a segmentation consists of k feasible blocks such that the
total length `(S) is maximized.
Given A and D, first we consider the most general form of the problem and define the block length
evaluation function
f(k, i, j) = max{`(S) | S a feasible segmentation of A(i, j) with k blocks}
Note that the k-longest-blocks asks to find the value f(k, 1, n). First of all, we prepare the left farthest
sites, L[j]‚Äôs, for each site j of A; according to Theorem 2, the array can be identified in O(mn) time.
Here we show that the answer can be found in O(nk) time after the preprocessing. The idea behind the
dynamic programming formula is illustrated at Figure 8.
 

 
	

Figure 8: The O(kn) algorithm to compute f(k, 1, n).
It can be verified that
f(k, 1, j) = max{f(k, 1, j ‚àí 1), f(k ‚àí 1, 1, L[j]‚àí 1) + j ‚àí L[j] + 1}
8
the haplotype data of human chromosome 21 from Patil et al. [17] and download haplotypes for all the
autosomes from phase II data of HapMap [11] so that the bioinformatic researchers can use the data to
evaluate the performance of the tools. On the other hand, researchers also can input their own haplotype
data by pasting the haplotype sample or uploading the file of haplotype sample, or input the address of
other websites‚Äô haplotype data.
The website provides tools to examine the diversity of haplotypes and partition haplotypes into blocks
by using different diversity functions. By using the diversity visualization tool, researchers can observe the
diversity of haplotypes in the form of the diagram of curves. The tool uses the diversity function (1), Œ¥D,
to calculate the diversities of all intervals. Figure 9 shows an example of the diversity visualization of the
haplotype sample downloaded from HapMap.
The website also provides the tools for researchers to partition haplotypes into blocks with constraints
on diversity and tag SNP number; by using the tool, researchers can find the longest segmentation consists
of non-overlapping blocks with limited number of tag SNPs. Researchers can upload a haplotype sample
or select a sample from our database, and then input a number of tag SNPs to partition the sample. As
an example; we pick the shortest contig of Patil‚Äôs haplotype sample (contig number: NT 001035, 69 SNPs)
and paste to the system; applying the diversity function (3), Œ¥C , and requiring the diversity must not be
greater than 0.2 (at least 80% of common haplotype) in each block; using 10 tag SNPs, the sample can be
partitioned into 19 haplotype blocks, and there are total of 61 SNPs in these blocks.
Our web system is freely accessible at http://bioinfo.cs.pu.edu.tw/hap/index.php. Some prelim-
inary results, including the selection of different diversity functions as well as choosing meaningful diversity
constraints, in using our tools can also be found in the web system.
5 Concluding Remarks
By using appropriate diversity functions, the block selection problem can be viewed as finding a segmenta-
tion of given haplotype matrix such that the diversities of chosen blocks satisfy certain value constraint. In
this paper, we propose several efficient combinatorial algorithms related to selecting interesting haplotype
blocks under different diversity functions.
By using the power data structures including suffix tree [10, 19] and the confluent LCA subtrees [12, 3],
we are able to show that the kernel combinatorial structure, event-list, can be constructed in time linear
proportional to the input. It follows in Theorem 1 that all interval diversities problem can be computed in
O(mn+n2) time. Using several dynamic programming deduction, we show in Theorem 2 that the farthest
sites problems problem can be computed in O(mn) time. As a corollary, we also show that the longest
block can also be found in O(mn) time. In Theorem 4, we show that finding longest k-block segmentation
with diversity constraints can be done in O(nk) time. In Theorem 5, we show that finding the longest
blocks with each constrained interval can be done in O(n2) time. In Theorem 6, we show that finding all
longest k-block segmentation with diversity constraints can be done in O(n2k) time. In Theorem 7, we
prove that the minimum diversity problem is NP-complete.
We need to point out that these time-efficiency results of our algorithms can be applied in many different
definitions of diversity functions; there we assume that the computation of the diversity of submatrix
A(j, k‚Ä≤) can be obtained from a shorter prefix of A(j, k), with k < k‚Ä≤, in time proportional to the size of
changing events . It is not hard to verify that the diversity functions listed in Eq. (1), (2), (3), as well as
many other different diversity functions, possess this property.
References
[1] Eric C. Anderson and John Novembre. Finding haplotype block boundaries by using the minimum-
description-length principle. Am. J. of Human Genetics, 73:336‚Äì354, 2003.
[2] D. Clayton. Choosing a set of haplotype tagging SNPs from a larger set of diallelic loci. Nature
Genetics, 29(2), 2001.
10
[24] K. Zhang, Z.S. Qin, J.S. Liu, T. Chen T, M.S. Waterman, and F. Sun. Haplotype block partitioning
and tag snp selection using genotype data and their applications to association studies. Genome Res.,
14(5):908‚Äì916, 2004.
[25] Kui Zhang, Zhaohui Qin, Ting Chen, Jun S. Liu, Michael S. Waterman, and Fengzhu Sun. HapBlock:
haplotype block partitioning and tag SNP selection software using a set of dynamic programming
algorithms. Bioinformatics, 21(1):131‚Äì134, 2005.
[26] Kun Zhang and Li Jin. HaploBlockFinder: haplotype block analyses. Bioinformatics, 19(10):1300‚Äì
1301, 2003.
12
to deal with the missing data when trying to determine the diversity of submatrix A(j, k) is trying to
set missing values of Aij ‚Äôs to either 0 or 1, such that the resulting diversity of A(j, k) is minimized. It is
worthy noting that the resulting diversity function is still monotonically non-decreasing. Unfortunately,
as we are going to show in the following, the assignment of missing data will be very difficult since its
corresponding decision problem is NP-complete.
Definition 3 (minimum-diversity) Let A be an m √ó n haplotype matrix with missing data such that
Aij ‚àà {0, 1, 3}. The minimum-diversity problem try to assign each entry Aij = 3 to either 0 or 1 such
that the resulting diversity Œ¥(A) is minimized.
Given a haplotype matrix A with missing data, we say two rows i, j of A are different if there exists
a column k such that {Aik, Ajk} = {0, 1}; in other words, it is impossible to assign missing data of A to
make the two rows identical. Two rows are compatible if they are not different.
Definition 4 (compatible-graph) Let A be an m √ó n haplotype matrix with missing data such that
Aij ‚àà {0, 1, 3}. The difference graph of A, denoted by G[A] = (V,E), consists of V = {1, 2, . . . ,m} as the
vertex set where two vertices ij ‚àà E if and only if row i and row j are compatible.
Here we show that this combinatorial problem is intractable even when the distances measurements
consist of only two different real numbers.
Theorem 7 The decision version of minimum-diversity problem is NP-complete.
Proof. The decision version of minimum-diversity problem is clearly in NP. Here we show that it is NP-
hard by a reduction from the minimum clique partition (CliPar) [7] of simple graphs to this problem.
Figure 10 illustrates the idea of reducing an instance of CliPar problem to the minimum diversity problem.


 

   
 	 	  
   	 
    	
    
    
			
	
Figure 10: A given graph G and the constructed minimum diversity instance.
Given an instance of CliPar, G = (V,E), we construct a haplotype matrix A such that the compatible
graph of A is exactly G; that is, G[A] = G. The construction is straightforward. Whenever (i, j) ‚àà E, we
construct a site, labelled as k = (i, j), such that Aik = 0 and Ajk = 1; while Ark = 3 for each r 6= i, j.
Furthermore, let the diversity of A is defined by
Œ¥(A) = (number of different strings in A)/m
It is readily verified that Œ¥(A) ‚â§ q/m if and only if G can be partitioned into at most q cliques. ¬§
14
15:10-15:30
 
Ei Ando, Hirotaka Ono, Kunihiko Sadakane and Masafumi
Yamashita. An Exact Algorithm for the Stochastic Longest Path
Problem in a DAG
15:30-15:50
 
 Jiexun Wang, Hiroshi Nagamochi, Liang Zhao and Tatsuya
Akutsu. Enumerating Colored and Rooted Cacti with Bounds on
Vertex/Edge Colors
Session 3-C: Combinatorial Algorithms
13:50-14:10
 
Caoan Wang. A Bound for Sum of Square Roots of Special
Integers
14:10-14:30
 
Xiangtong Qi. A Subcontractor's Pricing Game in Production
Scheduling
14:30-14:50
 
Mao-Cheng Cai and Xiaoguang Yang. Restricted Partial Inverse
Minimum Base Problem of a Matroid
14:50-15:10
 
Donglei Du, Ruixing Lu and Dachuan Xu. A Primal-Dual
Approximation Algorithm for the Facility Location Problem with
Submodular Penalties
15:10-15:30
 
Kerui Min, He Sun and Hong Zhu. Finding Real Icebergs in
Internet Traffic
15:30-15:50
 
Anthony Man-Cho So. Probabilistic Analysis of the Semidefinite
Relaxation Detector in Digital Communications
Session 4-A: Computational Geometry
16:20-16:40 Rudolf Fleischer and Yihui Wang. On the Camera PlacementProblem
16:40-17:00 Hee-Kap Ahn and Yoshio Okamoto. An Adaptive Algorithm forthe Planar Convex Hull
17:00-17:20
Siu-Wing Cheng, Jiongxin Jin, Antoine Vigneron and Yajun
Wang. Approximate Homotopic Shortest Paths in Anisotropic
Regions with Symmetric Cost
17:20-17:40
Keigo Kinpara, Tomoko Izumi, Taisuke Izumi and Koichi Wada.
Space-Efficient Self-Stabilizing Counting Protocol on Mobile
Sensor Networks with a Base Station
17:40-18:00 Takashi Horiyama and Masato Samejima. Enumeration ofPolyominoes for p4 Isohedral Tiling by the Reverse Search
Session 4-B: Graphs-2
16:20-16:40 Kazuo Iwama, Kazuhisa Seto and Suguru Tamaki. The PlanarHajos Calculus for Bounded Degree Graphs
16:40-17:00
Yusuke Hosaka, Hirotaka Ono, Kunihiko Sadakane and
Masafumi Yamashita. Faster Random Walks on Biconnected
Series-Parallel Graphs
17:00-17:20 He Sun and Hong Zhu. On Construction of Almost-Ramanujan Graphs
17:20-17:40 Yunfeng Xu and He Sun. Approximating the Spectral Gap ofExpanders in the Data Stream Model
17:40-18:00 Mingyu Xiao. New Branching Rules: Improvements onIndependent Set and Vertex Cover in Sparse Graphs
Session 4-C: Bioinformatics and Data Structure
16:20-16:40 Zhewei Wei, Ke Yi and Qin Zhang. Dynamic ExternalHashing: The Limit of Buffering
16:40-17:00
Kunsoo Park, Joo Young Yoon, Sunho Lee, Eunok Paek,
Heejin Park, Sang-Won Lee and Hee-Jung Jung. RAPID: Fast
and Accurate Determination of Monoisotopic Masses of
Polypeptides
17:00-17:20 Naoki Katoh and Shin-ichi Tanigawa. Combinatorial Rigidity ofMolecular Structures and the Molecular Conjecture
17:20-17:40 Yaw-Ling Lin. Algorithms for Haplotype Block Partitioning andTag SNP Selection Problems Under Various Constraints
17:40-18:00 Louxin Zhang. Estimating the Accuracy of the Parsimony andML Methods for Reconstruction of Ancestral States
Sunday, April 12, 2009
Session 5
8:40-9:40 Gerhard Woeginger. Analysis of Three Assignment Problems
Session 6
10:10-10:40 Mordecai Golin, Xiaoming Xu and Jiajin Yu. Generic Top-Down
Dynamic-Programming Approach to Prefix-Free Coding
10:40-11:10 Yoshiaki Nonaka, Hirotaka Ono, Kunihiko Sadakane and Masafumi
Yamashita. A Tight Upper Bound on the Cover Time of Metropolis
Walks
11:10-11:40 Andreas Dress. Topological Approaches to Tree Reconstruction
11:40-12:10 Bo Chen, Xujin Chen and Xiaodong Hu. Good Nash Equilibria in
Selfish Ring Routing
Session 7-A: Online Algorithms
AAAC 2009 -- programme http://www.cs.zju.edu.cn/people/yedeshi/aaac09/programme.html
2Ôºè3 2009/4/8 ‰∏äÂçà 09:37
