 
合作企業簡介 
合作企業名稱：澔學學習系統有限公司 
計畫聯絡人：尤弘志 
資本額：50 萬 
產品簡介：本計畫的合作企業「澔學學習系統有限公司」多年來致力於數位學習相關
軟體之開發，用戶主要為中小學教師以及對於數位學習需求殷切之企業團體。 
網址： http://www.intellischool.com.tw/default.aspx  電話：03-5341569 
研究摘要(500 字以內)： 
教育部近幾年來大力推動教改政策，如國中小學的九年一貫課程、綜合高中推廣與
設置、高中職課程架構的改制，其間的轉變，已造成中學校務行政上額外的負擔。特別
是在排課方面，因為課程的多樣化，使得排課問題愈來愈複雜。在多重排課限制必須面
面俱到的情況下，排課作業往往牽一髮而動全身，難以在有效的時間內找到最佳解。 
近年來在企業界大受矚目的資料探勘技術，其中的關聯法則探勘能從歷史資料中找
出事件發生的關連性，進而利用探勘出的規則，輔助決策的訂定。為了解決教改政策下
所衍生出的多重限制排課問題，可應用關連法則探勘分析現有的授課資訊，找出有用的
規則作為自動化的排課策略，以提高排課的效率，縮短排課所需耗費的行政人力與成本。 
目前常見的關連法則探勘方法大多以 Apriori 演算法為基礎。此法雖然簡單，且節
省記憶體空間，然而執行效率不佳，資料量稍大即無法在可容忍的時間內找到可用的結
果。而以雜湊函數為基礎的關連法則探勘演算法雖可提高執行效率，然其記憶體需求卻
呈指數成長，教務行政單位常用的一般個人電腦往往無法負擔。為了滿足排課作業的即
時性，以及適應一般校務行政資訊系統有限的記憶體支援能力，本計劃將提出一個高效
率的關連法則探勘演算法。此法以排序-索引-修剪(Sorting-Indexing-Trimming，簡稱 SIT)
等技術來改善關連法則探勘的效能，期望達到時間與空間效能兼顧的目的，使關連法則
探勘能確實應用於解決多重限制排課的實務問題。 
本計畫的合作企業「浩學科技」多年來致力於開發教務自動化軟體，開放給全國各
中學自由使用。透過本計畫產學合作的機會，可將本計畫的研究成果應用於其教務自動
化軟體中，預計將造福全國上千所中學，提升其教務行政效率。目前本計畫之研究成果
已由「浩學科技」實際應用於其排課系統中，未來將更進一步與合作企業洽談技術轉移
事宜，並且評估將計畫成果申請專利之可行性。 
人才培育成果說明： 
 本計畫共有一位碩士生及兩位大學部學生參與，整合主持人過去在數位學習方面的
相關研究，目前已完成四篇期刊論文，研究成果豐碩。由於計劃執行過程中與合作企業
進行相當密切的互動，使參與的同學能確實從企業界需求的角度出發，進行系統規劃、
分析與設計，不僅強化了大學部同學系統開發的實務能力，更使得碩士生的研究成果能
跳脫純學術研究的窠臼，與實務相結合，對其研究方向的定位，有相當大的助益。 
 
 
 
 
{m,p}
{f,p}
{f,m}
{c,p}
{c,m}
{c,f}
{b,p}
{b,m}
{b,f}
{b,c}
{a,p}
{a,m}
{a,f }
{a,c} 
{a,b}
Itemset
8
8
7
8
7
4
1
1
1
1
8
7
4
2
2
Count
a,c,d,f,l,m,n,p5
b,c,k,p,s4
b,f,h,j,o3
a,b,c,f,l,m,o2
a,c,d,f,g,i,m,p1
ItemsTid
 
圖 3  傳統 Apriori 演算法找尋高頻物項集合至少須比對的次數範例 
 
z Apriori 排序索引改良法(Apriori+ SI) 
傳統的 Apriori 演算法在找尋高頻項目集合時，要確認候選項目集合是否為各個交
易之子集合，需要進行反覆的比對，其所需之比對次數以圖 3 為例說明之。圖 3 右方為
交易資料庫的內容；左方為產生階層 2 候選項目集合時至少需要的比對次數。比對的步
驟及次數計算說明如下： 
步驟 1：比對候選項目集合{a,b} 
 首先找尋項目 a，只比對了 1 次就找到了。接著找尋項目 b，自 Tid=1 的第 2
個項目開始比對，結果發現是項目 c，不必再往下比對。一共比較了 2 次，確認候選項
目集合{a,b}不是 Tid=1 的子集合。 
步驟 2：比對候選項目集合{a,c} 
 找尋項目 a 只比對了 1 次，接者比對項目 c 於 Tid=1 的第 2 個位址項目開始比
對，結果只比對了 1 次，候選項目集合{a,c}共比對了 2 次，確認候選項目集合{a,c}是
Tid=1 的子集合。 
步驟 3：比對候選項目集合{a,f} 
 找尋項目 a 只比對了 1 次，接者比對項目 c 於 Tid=1 的第 2 個位址項目開始比
對結果分別比對 c→d→f 共 3 次，所以候選項目集合{a,f}共比對了 4 次，確認候選項目
集合{a,f}是 Tid=1 的子集合。 
依上述方法，依序比對候選項目集合{a,m}、{a,p}、{b,c}、{b,f}、{b,m}、{b,p}、
{c,f}、{c,m}、{c,p}、{f,m}、{f,p}、{m,p}是否為 Tid=1 的子集合，分別比對了 7、8、1、
1、1、1、4、7、8、7、8、8 次。 
1,8,9,12,14,15,16,175
7,11,13,15,164
4,6,10,13,173
8,10,12,13,14,16,172
1,3,5,12,14,15,16,171
ItemsTid
{16,17}
{15,17}
{15,16}
{14,17}
{14,16}
{14,15}
{13,17}
{13,16}
{13,15}
{13,14}
{12,17}
{12,16}
{12,15 }
{12,14} 
{12,13}
Itemset
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
Address
0017
151516
141315
121014
9613
5112
0011
0010
009
008
007
006
005
004
003
002
001
EndStartItem
017
116
1+2=315
1+2+3=614
1+1+2+3+4=1112
05
03
01
CountItem
 
圖 5 Apriori 排序索引改良法找尋高頻項目集合之範例 
步驟 5：候選項目集合{12,14}的第 2 個項目為 14，Tid=1 交易中的第 5 個項目亦為
14，因此只比對了 1 次即可確定候選項目集合{12,14}是 Tid=1 的子集合。 
依步驟 4~5 的方法比對{12,15}、{12,16}、{12,17}，則分別比對了 2、3、4 次，因
此總共比較了 1+1+2+3+4=11。 
 依此類推，如圖 5 右下方所示，Apriori 排序索引改良法總共只比對了
11+6+3+1=21 次即可確認候選項目集合是否為 Tid=1 的子集合。相較於傳統方法所需的
69 次比對，由此例可發現 Apriori 排序索引改良法能有效的減少比對次數。 
z MPHP 排序索引修剪改良法(MPHP+SIT) 
修剪的技巧在 Apriori 演算法的改良上並無任何效益，因為索引的方式已經將交易
中不可能出現的項目過濾掉，然而修剪的技巧卻可在 MPHP 的改良上發揮很好的效果。
當找尋到第 1 層的高頻項目集合時，可以先找出該高頻項目集合中最小的項目，令其為
m；接著，將資料庫所有交易中小於 m 的項目直接剪除，以圖 6 為例說明之。 
假設最小支持度為 3，圖 6 的修剪步驟如下： 
步驟 1：顯示原始交易資料庫。 
步驟 2：交易資料經項目排序及名次轉換後，多加一欄位 Start，初值設為 1，用
來紀錄交易內容在修剪之後，第一個需要產生 Hash table 的項目位置。此欄位是為
了讓程式無需真正刪除項目，只需略過不必產生 Hash table 的項目即可。 
步驟 3：計算各項目的出現次數，找出大於最小支持度的項目分別為 12、13、
14、15、16、17。 
步驟 4：交易中編號小於 12 的項目不可能成為高頻項目集合中的項目，因此可
加以修剪。Tid=1 的前面 3 個項目 1、3、5 可以修剪，所以將 Start 的值設為 4。依
此類推，分別將 Tid=2、3、4、5 的 Start 的值設為 5、4、3、4。 
修剪改良法的高效率關連法則探勘演算法。SIT 演算法於階層 2 找尋高頻項目集合時，
使用 MPHP 排序索引修剪改良法直接找出高頻項目集合，以達到最佳的執行效率；然而
為了避免 MPHP 在高階層時產生記憶體需求呈指數成長的問題，SIT 演算法於階層 3 以
後則改用 Apriori 排序索引改良法。 
SIT 關連法則探勘演算法如下: 
Algorithm SIT() 
s= a minimum support; 
I= {I1, I2, …, IN}, a set of distinguishable items in the database; 
N= |I|, total number of data items in the database; 
|D|= total transactions of the database; 
g= the number of gth group in database; 
IM=Index Mapping Array 
min_Item=Minimum item in L1 
 
Scan database D to obtain L1, the set of frequent 1-itemsets; 
//Trimming  
Find Minimum Item min_Item  
For all transaction t ∈ D do begin //scan database 
  For(i=1;t.itemcount;i++) do begin  
If t.item(i)>min_Item 
t.start=i; 
break; 
     endif 
end 
end 
 
//Create Index Mapping Array 
IM(0)=0 
For(i=1;N-1;i++) do begin 
   IM(i)=G(i)+IM(i-1); 
end 
 
//SIT Hash Function for 2-itemsets 
Create hashing function with NC2  hash addresses;  //construct hash function 
)()1()1(),(
1
1
ijiIMjGjiH
i
x
x −+−=∑ −+= −=
 
For all transaction t ∈ D do begin  //scan database 
   For all k-subsets ∈ t do begin 
      H(item1,item2)++;  
   end 
end 
L2= {2-subsets| H2 (item2,item2) ≥ s}; 
 
//Sorting-Indexing Apriori 
for (K=3; Lk-1 ;K++) do begin 
Ck =apriori-gen(Lk-1);//Generate new candidates form Lk-1  
for all transaction t D do begin 
      for (i=t.start ; t.itemcount-K+1; i++) do begin 
         for(j=ItemStart(t.item(i)); ItemEnd(t.item(i)); j++) do begin 
            for (m=2 ; K ; m++) do begin 
