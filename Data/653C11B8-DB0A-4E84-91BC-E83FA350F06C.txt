 II
中文摘要 
為了評估疊加層網路的效能，許多研究學者採用模擬的方式來得到結果。然而由於模擬環
境、網路拓墣、以及採用參數的不同，模擬的結果常常令人存疑。因此，有必要發展出一
個完善而嚴謹的分析模型，來評估疊加層網路的效能。 
分析疊加層網路的過程中，考量網路中節點群組的特性是相當重要的事項。對於一個完善
的分析模型而言，必須要能夠正確的計算任意一個節點經過任意選擇的距離後，會經過的
節點數目。 
在這個計畫中，我們提出一個完善而嚴謹的分析模型，來評估疊加層網路的效能。這個分
析模型可以用來快速的分析在不同的疊加層網路中，各種搜尋演算法的效能。 
關鍵詞 
對等式網路、疊加層網路、效能分析、搜尋演算法、拓墣模型。 
 
 IV
目錄 
中文摘要................................................................................................................................... II 
英文摘要.................................................................................................................................. III 
目錄..........................................................................................................................................IV 
前言............................................................................................................................................ 1 
研究目的.................................................................................................................................... 2 
文獻探討.................................................................................................................................... 3 
研究方法.................................................................................................................................... 5 
結果與討論.............................................................................................................................. 10 
結論與建議.............................................................................................................................. 13 
參考文獻.................................................................................................................................. 14 
發表之論文.............................................................................................................................. 17 
 
 2
研究目的 
In summary, our objectives are stated as follows: 
 Survey and study the related papers about network topology and random graph. 
 Extend the random graph model to calculate the number of vertices at any distance. 
 Use the resulting model to evaluate the performance of the existing search algorithms. 
 4
DFS-based methods [9]-[13].  By RW, the query source just sends one query message (walker) 
to one of its neighbors.  If this neighbor does not own the queried resource, it keeps on sending 
the walker to one of its neighbors, except for the one the query message comes from, and thus the 
search cost is reduced.  The main drawback of RW is the long search time.  Since RW only 
visits one node for each hop, the coverage of RW grows linearly with hop counts, which is slow 
compared with the exponential growth of the coverage of flooding.  Moreover, the success rate 
of each query by RW is also low due to the same coverage issue.  Increasing the number of 
walkers might help to improve the search time and success rate, but the effect is limited due to 
the link degree and redundant path.  As the example shown in Fig. 1, RW can only visit 12 
vertices of second neighbors even when the number of walkers is set as 32.  Certainly, the 
search is inefficient because 32 walkers only visit 12 vertices at the second hop. 
Flooding and RW are two typical examples of blind search algorithms by which query 
messages are sent to neighbors without any knowledge about the possible locations of the queried 
resources or any preference for the directions to send.  Some other blind search algorithms 
include modified-BFS (MBFS) [23], directed BFS [6], expanding ring [17], and random 
periodical flooding (RPF) [24].  These algorithms try to modify the operation of flooding to 
improve the efficiency.  However, they still generate a large amount of query messages.  Jiang 
et al. propose a LightFlood algorithm which is a combination of the initial pure flooding and 
subsequent tree-based flooding [25] [26].  DS and LightFlood operate analogously, but DS 
avoids the extra cost to construct and maintain the tree-like suboverlay. 
Knowledge-based search algorithms take advantage of the knowledge learned from previous 
search results and route query messages with different weights based on the knowledge.  Thus 
each node could relay query messages more intelligently.  Some examples are adaptive 
probabilistic search (APS) [27] [28], biased RW [29], routing index (RI) [30], local indices [31], 
and intelligent search [32].  APS builds the knowledge with respect to each file based on the 
past experiences.  RI classifies each document into some thematic categories and forwards query 
messages more intelligently based on the categories.  The operation of local indices is similar to 
that of super-peer networks.  Each node collects the file indices of peers within its predefined 
radius.  If a search request is out of a node’s knowledge, this node would perform a flooding 
search.  The intelligent search uses a function to compute the similarity between a search query 
and recently answered requests.  Nodes relay query messages based on the similarity.  There 
are some other research works which focus on replicating a reference pointer to queried resources 
in order to improve the search time [33] [34]. 
 
( ) ( )ττ  - 2'0 m - 1 2 - 1  1G ≅  (8) 
and 
( ) ( ) τ
τ
 - 3
m 
1G
1  1G
 - 3
'
0
'
1 ≅  (9) 
assuming 2 < τ < 3. 
B. Performance Metrics 
 Success Rate (SR) 
    Success rate (SR) is the probability that the query is success, i.e., there is at least one query 
hit.  Assume that the queried resources are uniformly distributed in the network with replication 
ratio R, and then SR can be calculated as 
( )CR - 1 - 1  SR =  (10)
where R is the replication ratio and C is the coverage.  This formula shows that the SR highly 
depends on the coverage of the search algorithms.  Following we use Equation (10) to obtain an 
important metric – guaranteed search time. 
 Guaranteed Search Time (GST) 
    To represent the capability of one search algorithm to find the queried resource with a given 
probability, we define the guaranteed search time (GST) as the search time it takes to guarantee 
the query success with success rate requirement SRreq.  GST represents the hop count that a 
search is successful with probabilistic guarantee.  Using Equation (10), GST is obtained when 
the coverage C is equal to ( ) ( )reqR - 1  SR- 1log .  For the MBFS search algorithms, this situation 
occurs when 
( ) ( ) ( ) ( ) ( )( )
( ) ( )( )
( ) ( )reqR - 1
1 - GST'
1
'
0
GST
2'
1
'
0
3'
1
'
0
2'
0
 SR- 1log 
1G  1G  p 
1G  1G  p  1G  1G  p  1G  p
MBFSMBFS
=
⋅⋅++
⋅⋅+⋅⋅+⋅
K  (11)
Thus the GST for MBFS is  
( )
( )( ) ( ) ( )
( ) ⎟⎟
⎟
⎠
⎞
⎜⎜
⎜
⎝
⎛
+⋅
⋅⋅= ⋅ 1  1G  p
 SR- 1log  1 - 1G  p
log 
GST
'
0
reqR - 1
'
1
1G  p
MBFS
'
1
 (12)
The GST of flooding is analogue to that of MBFS with probability p = 1.  The calculation of 
RW depends on the number of walkers k.  When k is set as 1, the GST for RW is obviously 
( ) ( )reqR - 1  SR- 1log .  When k is larger than 1, assume that 
( ) ( )( ) ( ) ( )( )t'1'01 - t'1'0 1G  1G  k  1G  1G ⋅≤≤⋅  (13)
i.e., k is equal to or larger than the average number of the tth neighbors of the query source, and 
assume that the effect of redundant paths can be neglected, and then the calculation for the GST 
of RW can be expressed as 
( ) ( ) ( ) ( ) ( )( )
( ) ( ) ( )reqR - 1RW
1 - t'
1
'
0
'
1
'
0
'
0
 SR- 1log  t - GST  k 
1G  1G 1G  1G  1G
=⋅+
⋅++⋅+ K  (14)
The GST for RW is 
 6
( )
( )[ ] ( )⎪⎪⎩
⎪⎪⎨
⎧
≥⋅
=
= ∑∏
∑
= =
=
2  h for ,VP  VP - 1
1  h for ,VP
  C N
1  i
1 - h
1 j 
hiji
N
1  i
hi
h  (19)
where N is the total number of vertices in the network. 
    Following we analyze the visiting probability Pi(Vh) for flooding, MBFS, RW, and DS, 
respectively.  First we consider the flooding and MBFS case.  The visiting probability Pi(Vh) of 
flooding or MBFS is 
( ) ( )( )[ ]⎪⎩⎪⎨
⎧
≥⋅⋅
=⋅⋅=
2  h for ,1G  p  p - 1 - 1
1  h for ,1G  p  p
  VP
1 - hC'
1i
'
0i
hi  (20)
where pi is the probability that vertex i is to be reached by certain edge.  [39] shows that pi can 
be written as 
∑ == N 1  i 1
1
i
im
im  p τ
τ
 (21)
where τ is the power-law exponent and m is the maximum degree. 
    When considering RW, we first calculate the probability that a vertex i is the candidate of 
RW. 
( ) ( )( )[ ]⎪⎩⎪⎨
⎧
≥⋅
=⋅=
2  h for ,1G  p - 1 - 1
1  h for ,1G  p
  RP
1 - hC'
1i
'
0i
hi  (22)
Then, the average number of candidates of RW at hop h is 
( )∑ == N 1  i hih RP  r  (23)
Hence, the probability that vertex i is visited at hop h for RW is 
( ) ( ) ⎥⎥⎦
⎤
⎢⎢⎣
⎡ ⎟⎠
⎞⎜⎝
⎛⋅=
k
h
hihi r
1 - 1 - 1  RP  VP  (24)
where k is the number of walkers. 
    The calculation of visiting probability Pi(Vh) for DS depends on the relation between h and n.  
When h ≦ n, Pi(Vh) is given by equation (20).  When h ＞ n, equation (22) to (24) are used to 
get Pi(Vh), where the k in (24) is set as Cn, i.e., the coverage at the nth hop.  Therefore, the 
visiting probability Pi(Vh) of DS is given by 
( )
( )
( )[ ]
( )⎪⎪
⎪
⎩
⎪⎪
⎪
⎨
⎧
>⎥⎥⎦
⎤
⎢⎢⎣
⎡ ⎟⎠
⎞⎜⎝
⎛⋅
≤≤⋅⋅
=⋅⋅
=
n  h for ,r
1 - 1 - 1  RP
n h 2 for ,1G  p  p - 1 - 1
1  h for ,1G  p  p
  RP
n
1 - h
C
h
hi
C'
1i
'
0i
hi  (25)
 Query Messages (QM) 
    Now we analyze the number of query messages.  When considering the flooding and 
MBFS case, the query message eh generated at hop h is given by 
 8
 10
結果與討論 
In this section we show the numerical results of the performance analysis described in 
section III.  From these results the effects of the parameters n and p are shown.  The number of 
nodes N is set as 10000.  The power-law exponent τ is set as 2.1, which is analogue to the 
real-world situation. 
Figure 1 illustrates that how the decision threshold n would affect the system performance.  Due 
to the page limit, we only show the result when p is set as 1.  The case of n = 1 is analogue to 
the RW search with k equal to the number of first neighbors, which is about 3.55 in this case.  
Moreover, the case that n = 7 is equal to the flooding search.  As this figure shows, the DS with 
n = 7 sends the query messages aggressively in the first three hops and gets good search 
efficiency.  But the performance degrades rapidly as the hop increases.  This is because that the 
cost grows exponentially with the path length between the query source and the target.  On the 
contrary, the SE of RW is better than that of flooding when the hop is 5 to 7.  When n is set as 2, 
DS gets the best SE for almost all hop counts.  This figure shows that the choice of parameter n 
can help DS to takes advantage of different contexts under which each search algorithm performs 
well. 
In order to obtain the best (n, p) combination, we illustrate the (n, p, SE) results in Figure 2.  
When p is large (0.7 ~ 1), set n = 2 would get the best SE.  Moreover, the best n value increases 
as the p decreases.  For example, when p is set as 0.2, the best n would be 5.  This is because 
that when p is small, n should be increased to expand the coverage.  On the contrary, when p is 
large, n should be decreased to limit the growth of query messages.  Therefore, the parameters n 
and p provide the tradeoff between the search performance and the cost.  This figure shows that 
the best SE is obtained when (n, p) is set as (2, 1). 
We show the numerical results of GST in Figure 3.  Replication ratio R is set as 0.01 in this 
case.  Similar results can be obtained when R is set as other values.  The numbers of walkers k 
for RW are set as 1 and 32.  The decision thresholds n are set as 2, 3 and 7, and p is set as 1.  
TTL is set as 7 in this case, thus the DS with n = 7 is equal to flooding.  From this figure DS 
with large n always gets the short GST because it always covers more vertices.  On the contrary, 
RW with k = 1 always gets the longest GST since its coverage is only incremental by one at each 
hop.  When k is set as 32, its coverage is enlarged and the GST can be improved.  However, 
DS still performs better than RW with 32 walkers even when n is set as only 2.  Note that when 
n is set as 3, DS performs as well as that with n = 7, i.e., flooding, while does not generate so 
many query messages. 
In summary, DS with n = 2 and p = 1 would get the best SE and significantly improve the 
GST.  While increasing n to 3, although SE is a little degraded, the shortest GST is obtained. 
 
 Figure 3.  GST vs. SR requirement.  R is set as 0.01 in this case.  The k for RW are set as 1 
and 32.  The n of DS are set as 2, 3 and 7, and p is set as 1.  TTL is set as 7 in this case, thus 
the DS with n = 7 is equal to flooding. 
 
 12
 14
參考文獻 
[1] D. Stutzbach, R. Rejaie, N. Duffield, S. Sen, W. Willinger, “Sampling Techniques for 
Large, Dynamic Graphs,” Global Internet Symposium, April 2006. 
[2] A. H. Rasti, D. Stutzbach, R. Rejaie, “On the Long-term Evolution of the Two-Tier 
Gnutella Overlay,” Global Internet Symposium, April 2006. 
[3] D. Milojicic, V. Kalogeraki, R. Lukose, K. Nagaraja, J. Pruyne, B. Richard, S. Rollins, 
and Z. Xu, “Peer-to-Peer Computing,” Tech. Rep. HPL-2002-57, HP, 2002. 
[4] K. Sripanidkulchai, “The popularity of Gnutella Queries and its Implications on 
Scalability,” white paper, Carnegie Mellon Univ. Pittsburgh, Feb. 2001. 
[5] M. Jovanovic, F.Annexstein, and K. Berman, “Scalability Issues in Large Peer-to-Peer 
Networks: A Case Study of Gnutella,” Tech. Report. Univ. of Cincinnati, Lab. For 
Networks and Applied Graph Theory, 2001. 
[6] B. Yang and H. Garcia-Molina, “Improving search in peer-to-peer networks,” in 
Proceedings of the 22nd International Conference on Distributed Computing Systems 
(ICDCS’02). Vienna, Austria: IEEE Computer Society, pp. 5–14, July 2002. 
[7] G. Kan, “Gnutella,” Peer-to-Peer Harnessing the Power of Disruptive Technologies, 
O’Reilly, pp.94-122, 2001. 
[8] RFC-Gnutella 0.6, http://rfc-gnutella.sourceforge.net /developer/testing/index.html 
[9] C. Gkantsidis, M. Mihail, A. Saberi, “Random Walks in Peer-to-Peer Networks,” in 
Proceedings of IEEE INFOCOM, pp. 120-130, 2004.
[10] L. A. Adamic, R. M. Lukose, A. R. Puniyani, B. A. Huberman, “Search in Power-Law 
Networks,” Phys. Rev. E 64, 046135, 2001. 
[11] L. A. Adamic, R. M. Lukose, B. A. Huberman, “Local search in unstructured networks,” 
Handbook of graphs and networks, WILEY-VCH GmbH & Co. KGaA, Weinheim, 
pp.295-317, 2003. 
[12] C. Gkantsidis, M. Mihail, A. Saberi, “Hybrid Search Schemes for Unstructured 
Peer-to-Peer Networks,” in Proceedings of IEEE INFOCOM, pp. 1526-1537, 2005. 
[13] N. Bisnik and A. Abouzeid, “Modeling and Analysis of Random Walk Search Algorithm 
in P2P Networks,” pp. 95-103, Second International Workshop on Hot Topics in 
Peer-to-Peer Systems, 2005 
[14] M. E. J. Newman, S. H. Strogatz, and D. J. Watts, “Random graphs with arbitrary degree 
distribution and their applications,” Phys. Rev. E 64, 026118, 2001. 
[15] H. Wang, T. Lin, “On efficiency in searching networks,” in Proceedings of IEEE 
INFOCOM, pp. 1490-1501, 2005. 
[16] P. Lin, T. Lin and H. Wang, “Dynamic Search Algorithm in Unstructured Peer-to-Peer 
Networks,” Global Telecommunications Conference, 2006. GLOBECOM ’06. IEEE, 
Nov. 2006. 
[17] Q. Lv, P. Cao, E. Cohen, K. Li, and S. Shenker, “Search and replication in unstructured 
peer-to-peer networks,” in Proceedings of the 16th Annual International Conference on 
Supercomputing (ICS’02), New York City, NY, USA, pp. 84–95, June 2002. 
 16
Peer-to-Peer Networks,” in Proceedings of the Eleventh International Conference on 
Information and Knowledge Management, pp. 300-307, Nov. 2002. 
[33] R. A. Ferreira, M. K. Ramanathan, A. Awan, A. Grama, S. Jagannathan, “Search with 
probabilistic guarantees in unstructured peer-to-peer networks,” in Proceedings of IEEE 
P2P'05, Konstanz, Germany, pp. 165-172, August 2005.
[34] N. Sarshar, P. O. Boykin, V. P. Roychowdhury, “Percolation search in power law 
networks: making unstructured peer-to-peer networks scalable,” in Proceedings of IEEE 
P2P'04, Zurich, Switzerland, pp. 2-9, August 2004.
[35] M. Mihail, A. Saberi, and P. Tetali, “Random walks with lookahead in power law random 
graphs,” Internet Mathematics 2006. 
[36] L. A. Adamic, “The small world web,” Proceedings of the 3rd European Conf. on Digital 
Libraries, volume 1696 of Lecture notes in Computer Science, pp. 443-452. Springer, 
1999. 
[37] S. Behnel and A. Buchmann, “Models and languages for overlay networks,” in Proc. of 
VLDB Workshop on Databases, Information Systems and Peer-to -Peer Computing.
[38] S. Behnel and A. Buchmann, “Overlay networks - implementation by specification,” in 
Proc. of Middleware 2005.
[39] W. Aiello, F. Chung, and L. Lu, “A random graph model for massive graphs,” 
Proceedings of the thirty-second annual ACM symposium on Theory of Computing, pp. 
171-180, 2000. 
 
On Efficiency in Searching Networks 
Hsinping Wang' and Tsungnan Lin*l 
'Graduate Institute of Communication Engineering 
+Department of Electncal Engineering 
National Taiwan University, Taipei, 106 I7 Taiwan 
(hpwang, tsungnan)@ntu.edu.tw 
Abstract-This paper deliberates on various critical aspects in 
evaluating searching networks. Existing metrics either draw 
biased conclusions tvgarding search performance ar provide 
w~rong guidelines for algorithm design. We, therefore, define a 
unified criterion, Search Efficiency (SE), to objectively address 
search performance in a comprehensive manner. The goal of  SE 
is to better characterize performance of searching networks than 
existing metrics do as well as to guide the design of future ones. 
We first validate the correctness of SE in performance evaluation 
in an ideal graph, strictly binarj tree, by analyzing SE for two 
typical search methods, breadth first search and random walk. 
We further show its strength in performance characterization in 
the real-world topology, power-law random graph, under various 
nehvark conditions. We finally design an algorithm, dynamic 
search, based on SE analysis. Its pmved outstanding 
performance demonstrates the strength of SE to provide 
guidance for the future design of searching networks. 
Keywor&-performance mduation, complex networks, search 
algorithm, peer-to-peer networks 
I. INTRODUCTION 
Searching networks, including social networks and 
computer networks, play an increasingly important role in 
human activity. A significant example is the recently popular 
peer-lo-peer F2P) file-sharing systems, e.g. Gnutella and 
KaZaA, where every peer co~laborativelp forms a searching 
network to locate desired files by a real-time search. In the 
social context of searching networks, people search their 
acquaintances for a particular item or expertise in a specific 
domain. Their acquaintances in turn report whether they have 
the desired item (expertise) or subsequently deliver th~s query 
to their next-step acquaintances. In this fashion, a social 
searching network or so called human acquaintanceship 
graph [8] is formed. Thus, a searching network is a system 
where each participant contributes to the network and 
collaborates to help others search targeted resources. 
In a searching network, one of the critical issues is to 
masimize search performance by choosing or designing 
algorithms used to perfom the search process. Novel 
algorithms [5 ,  6,  71 have been proposed to address different 
search aspects, such as success rate, search cost, Coverage, or 
number of hts, but an objective and comprehensive 
evaluation metric is missing. As a result, these algorithms tend 
to be designed with biased considerations and evaluated in 
limited dimensions. 
Breadth-first search (BFS) and random walk (RW) [5] are 
two basic and typical search methods in searching networks. 
BFS inherently maximizes the search speed and coverage but 
risks generating search queries in an uncontrolled (exponential) 
manner. RW, on the other hand, minimizes search cost but 
generates limited search coverage and results. As a result, one 
might draw distinct conclusions about algorithm performance, 
if different metrics are concerned. For example, Gkantsidis et 
al. [12] claimed RW performs better than BFS in terms of 
number of hits and failure probability give the same search 
cost for BFS and RW, but implicitly assumed an infinite 
search time for RW, which is clearly unfair. Jiang et al. [9] 
evaluated their proposed search scheme only by search 
coverage and message cost, leaving search speed and success 
rate unchecked. LV et al. [SI provided a spectrum of aspects 
on evaluation, but analyzed them individually and still lacked 
an overall consideration. 
Our work: therefore, deals with these one-sided 
perspectives and synthesizes a unified search criterion, Search 
Eflcienc), (Section Il), which is critical particularly in P2P 
endeavors, to objectively evaluate search algorithms and 
provide overall guidance for the design of searclung networks. 
With the unified metric SE, we first validate its correctness 
by deriving its mathematic formulas for BFS and RW in a 
simple topology, strictly binary tree (SBT), and analyzing 
whether the performance indicated by SE is reasonable. 
Furthermore, we extend the results of Newman [l] and 
Adamic [2] and further consider "redundancy" to analytically 
approximate SE for BFS, M-BFS [14], and RW in a 
power-law random graph (PLRG), which is shown to be the 
real topology of current searching networks. We thus validate 
SE in comparison with previous simulation works [5,  9, 111, 
deliver the unique performance characterization of SE, and 
provide in-depth analysis. 
Throughout the analysis in this paper, we compare various 
existing metrics with SE to address their limitation and 
strength. We show that no matter in SBT or PLRG, existing 
metrics draw biased conclusions regarding search 
performance; they either provide one-sided considerations or 
deliver wrong guidelines for algorithm design. Moreover, they 
fail to characterize performance variance under distinct 
network conditions, such as object replication ratios (Section 
111) and object dstributions (Section VI). 
In the final analysis, we propose a new algorithm, &naniic 
search, based on the results of SE analysis. We prove this 
algorithm outperforms existing ones and SE effectively 
provides guidance for algorithm design. 
This work was supported in part by Taiwan National Science Council 
under grant 93-2213-E-002-057, and by Quanta Computer Inc. under grant 
092E0018. 
0-7803-896&9/05/$20.00 (C)2005 IEEE 1490 
Authorized licensed use limited to: IEEE Xplore. Downloaded on October 15, 2008 at 22:01 from IEEE Xplore.  Restrictions apply.
Requester A 
Search A Search B 
grervA4sg QueryKm euelyMsg OuewHiLr --- - 
Run1 100 2 100 1 
Run? 100 0 100 1 
Depth 2 
Depth 3 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
Fig. 1. A strictly binary tree with the requester at the root 
itself despite long response time. We thus aggregate these 
responsive hits rather than divide by the averaged response 
time to give efficiency as 
Q'NelyHits(l) / t 100% 
QueVMsg R 
X-. 
The efficiency of this example becomes 99.01% rather than 
50.25%. where the last found hit contributes 0.01% to 
efficiency. rather than severely reducing it. 
where TTL stands for the limit of search covering 
D. Limitations of Senrch Eflciency 
The design goal of SE is to capture a simple but 
representative view of search performance. As a result. it is 
possible to consider more complex considerations for search 
evaluation We list three possible aspects that are not covered 
by SE: 
1)  In the contest of computer searching networks, the 
implementation of caches or DHT would significantly 
improve the search performance. which SE could reflect. 
However. SE doesn't consider the additional resources 
(processing power or memory) required by 
performanceboosted mechanisms. such as hash functions or 
caches. thus potentially overestimating the efficiency of 
algorithms adopting these additional mechanisms. 
2) The costs of searching each computer or peer should not 
be equally weighted. Consulting an institution for 
recommendations is clearly inore costly than asking a close 
friend. although we onIy assume they are equally costly. 
3) We make a limited measure of responsiveness by the 
factor t. In some applications. such as peer-to-peer telephony. 
(Skype). search response time is highly concerned while in 
others not. Therefore. it would be more flexible using P. a > 0, 
to adjust the ex%ent to which search responsiveness is 
concerned. 
By means of Search EflcienT, we can objectively evaluate 
performance of algorithms in searchug networks. In the 
remaining of this paper. therefore. we aim to characterize 
various existing search algorithms in t e m  of SE and 
demonstrate the biased view of existing search metrics 
compared with SE. In the following sections, we will 
mathematically derive the formulas for SE in the context of 
t h e  basic search approaches, BFS, RW and M-BFS. the 
variation of BFS. in two representative topologes, the strictly 
binary tree (SBT) as well as the power-law random graph 
(PLRG), in order to demonstrate the strength of SE. 
111. STRICTLY BINARY TREE 
We assume an &vertex strictly binay tree whose depth is 
about log2N and that the requester is at the root such that the 
response time ( t )  of a query hit is the same as the depth (d) 
where the target object is located. This tree is shown in Fig. 1. 
Moreover, for simplicity of analysis, we assume objects are 
un@rmly distributed in the tree or graph until Section VI. 
Before analyzing specific algorithms, we first prepare two 
common factors for the derivation Firstly, the number of 
objects searched out (QuetyHirs) is proportional to the search 
coverage C. Thus, we have 
QueryHits = R xC . (3) 
Secondly, the success mte of a search is also relevant to the 
search coverage. To begm with, we know that each node owns 
the target object with a probability of R; that is: each node 
lacks the object with it probability of 1-R. Suppose a search 
covers C vertices and thus the probability these C nodes share 
no targeted object is (1-R)'. Inversely. the probability these C 
nodes share one or more objects, or equivalently SuccessRak, 
is determined by 
SuccessRate = 1 - (1 - R) . (4) C 
1492 
Authorized licensed use limited to: IEEE Xplore. Downloaded on October 15, 2008 at 22:01 from IEEE Xplore.  Restrictions apply.
(h) Swcess Rate (a) Search Elfciency 
I 2  3 4 5 6 7 8 9 10 
Deprh 
(c) Coverage 
10000 
%- k=2 
1 2  3 4 5 6 7 8 9 10 
Depth 
100 
1030 
8 
3 
$ 
C 
IO 
. - . 
I^ - -  - 
I 
I 2  3 1 5  6 7 6 9 10 
Fig. 3. Performance comparison by various metria--(a) Search Eflcienry, (b) SuccessRaie, ( c )  Coverage, and (d) QtrepWsg-fm RW of various number of 
walkers k and for BFS in a strictly binary tree with R = 1% 
B. Multiple Random Wdks in Strictlv Binary Twe 
When it comes to RW search we use multiple "walkers" to 
traverse the network and the number of walkers is denoted by 
k. Each walker independently searches the network and 
randomly chooses one of the next-hop neighbors to continue 
its journey to the limit of 77" hops. 
Analytic Derivation: To begin with, we consider Coverage 
to derive SE. We know each vertex at depth t is visited by a 
random walker with equal probability, 112'. Moreover, each 
random walker independently makes its own decisions to 
traverse the topology. Thus, the probability that all k walkers 
don't visit a certain vertex is (1-1/23'. As a result, at depth t ,  
the average number of nodes visited (Coverage per Depfh) by 
k random walkers is given by the expectation 
E ( X ) ,  = 2' [I- ( l - p ] .  (9) 
By (3), QueryHits(t) = R,E(X),. Moreover, the query 
messages of random'walk are generated per hop for each 
walker until terminated by the 7TL limit, hence 
As a result, QE of k-random walk is 
QueyMsg = k.TTL. (10) 
Furthermore, from (4), we obtain 
&"Rate= l-( l-Rf = l-(l-R)'zE(x)l .(12) 
Therefore, Search Eflciency for A--random walks is 
where E(X), is determined by (9). 
Search Efficiency Analysis: Assuming R = 1%, we 
generate a series of performance results of SE in terms of 
various numbers of walkers k. We thus plot these results of SE 
(13), SuccessRafe (12), Coverage (9); and QueryMg (10) for 
RW and BFS in Fig. 3. 
In Fig. 3(a). we obsewe that all SEs of RW consistently 
increase with respect to the depth or search time. Nevertheless, 
they all are smaller than that of BFS due to too many 
(redundant) query messages in the local search and the slow 
covering and low SuccessRate in the long-term search. 
Therefore, they fail to utilize the regular structure of SBT. As 
for the number of walkers k. a too large (e.g. 50) or too small 
(e.g. 2) value of k gives degraded performance, thus resulting 
1494 
Authorized licensed use limited to: IEEE Xplore. Downloaded on October 15, 2008 at 22:01 from IEEE Xplore.  Restrictions apply.
6 First neighbors 
0 Second neighbors 
Fig. 4. Arandom graph for illustrating "redundancy" 
B. Redurtdanq in Power-lmv Random Graph 
Equation (1 7) equivalently tells us that the average number 
of the !I* neighbors is strictly the product of the average 
degree of each vertes, G'o( 1). and the average outgoing degree 
of verlices arrived by a randomly chosen edge, G'l(l): to the 
(h-1)" power. given the graph size AT is infinity. However, in 
reality-when AT is not infnite-it is simplv not the case 
specified in (17) where the number of h' neighbors is 
geometrically increasing. In other words. z), slmuld not be 
geometrically increasing due to the "redundancy" in random 
graphs. By redundanq we mean edges of any vertes that 
leads to repeatedly visited vertices, resulting in a fewer 
effective number of vertices reached by edges than the number 
of traversed edges. Thus, to express in the tenns of search 
networks, we use a definition similar to [lo]: 
'2 search network N km 'redundancy' ifthere exists a link 
(edge) i)? N that can be removed without reducing any vertex S 
search coverage, which is generated by certain search 
algorithm. '' 
To quantify the redundancy of a graph by certain search 
algorithm we define ''redundancy" as 
(20) 
No. of Vertices Effectively Reached 
No. of Edges Ever Tmversed 
Redundunqv = 1 - 
Note that redundancy may actually be useful to improve the 
fault tolerance of the system, since if one peer fails, another 
can perform its processing. Moreover, redundancy may be 
useful to reduce response time if a peer stands at a redundant 
edge closer to the searcher, Thus, fault tolerance and search 
latency tradeoff with efficiency when redundancy is 
concerned. 
We illustrate this notion of redundancy by Fig. 4, in which 
we draw a graph with 13 vertices and 15 edges where the 
black node is the search originator. gray nodes are the fust 
neighbors of the originator. and the white nodes are the second 
neighbors. Arrows show the directions and paths of message 
forwarding by BFS. Inspecting this graph we have the 
number of fmt neighbors of the black node, G'dl) = 3 ,  and 
the degree of outgoing edges of each first neighbor, Gfl( 1) = 4. 
Nevertheless, the effective number of second neighbors is 9, 
not simply the product of G',,( 1) and GIl (1): 12? as specified by 
(16). Thus, we obtain the redundancy by (20) as 1 - (3t9) / 
(3+12), or 11.5, which means in this case one-fifth (20%) of the 
edges are redundant by a BFS search. 
C. Breadth First Search in Power-law Rnndom Graph 
Analytic Derivation: To analytically quanti& the 
redundancy of a random graph we first derive the number of 
second neighbors z2 covered by BFS, which it is ideally 
G;( 1)G', (1) by (16). However, according to the discussion in 
Section VB. z2 will be lower than the ideal value when A' is 
not infinite due to the graph redundancy. To derive z2. it is 
largely equivalent to solve the problem that what the number 
of balls (vertices) ever chosen (or inversely left not chosen) is 
when choosing G'](l) balls out of A' balls and put them back, 
and repeat this procedure G'*( 1) times, with G',( 1) < IV. For 
simplicity: we first assume the probabiliv each ball (vertex) to 
be chosen is uniform. Thus tlie probability that each ball is 
un-selected is 1 - [G'1(1)/1Vl after one time of tlus procedure. 
After G'o(l) times of the procedure, tlie probabiliw each ball 
selected becomes 
1- [1-G I, (I)/ Ar]c'oi') 
Hence, if we assume all balls are chosen umformly and the 
expectation of the effective number of chosen balls (second 
neighbors) is 
when neglecting the chance to repeatedly reach the first 
neighbors. 
However. vertices are arrived at by edges with probabilities 
proportional to their degrees [l], rather than uniformly. as 
previously stated (Section YA). Suppose the probabilily each 
vertex to be reached by certain edge is p ,  for i = 1.2. ,.,, h'and 
p1 + p2 +...+ p~ = 1. In a power-law random graph, the 
probability p z  of vertex i is proportional to irs degree and 
equivalently given by 
such that zip, = 1? where m, the maximum degree. is set by 
If ignoring the chance to revisit the first neighbors. we 
could approximate the effective number of second neighbors 
PiT [4]. 
as 
J 
wheere we assume pl  << 1 as G;(1) << iV? whch is true in 
general cases. Note that the term p;Gf1( 1) approximately- 
represents the expectation of vertex i to be visited with Gf,( 1) 
independent selections, each of which only selects one vertex 
among the N ones (with returning back). Ths term is s w l y  
not the exact expectation of second neighbors (the actual 
value should be a little smaller), but an approsimation, which 
holds whenp, G'] (1) is much smaller than unity. 
To generalize it, the effective number of vertices arrived at 
the h~ depth or hop (Coverage per Depth or Ch) for h 2 
could be approximated by 
1496 
Authorized licensed use limited to: IEEE Xplore. Downloaded on October 15, 2008 at 22:01 from IEEE Xplore.  Restrictions apply.
5 
D 
I 3 4 5 6 I 
HOP 
Fig. 7. Search Eflciency for RW of various number of wikers k and for 
BFS in a power-law random graph with R = 1% 
D. Mulripie Random CVulks in PLRG 
The property of random walk is dramatically different from 
BFS. The former traverses a gmph in a random and 
unpredictable fashion while the latter operates rather regularly. 
In particular, the concept of depth used in BFS is not 
applicabie in random walk in that the walkers may go “back 
and forth” in the graph so that we could only describe them 
with respect to hop rather than depth. Therefore, we represent 
search coverage in terms of Cowrage per Hop ((3). 
Analytic Derivation: To derive the analytic formulas of 
performance metrics, we first obtain the number of 
“candidates” that RW might traverse at the h hop, which is 
conceptually similar to the number of hh neighbors of BFS, zh, 
except RW doesn’t have the concept of “depth” We denote 
that for RW as rh. Let Rh be the event a vertex is the candidate 
of RW at hop h (in the A* neighbors of RW), then the 
probability vertex i is the candidate of RW at hop h is 
I (p i  . G In (I), for h = 1 
The& the average number of candidates of RW at hop h is 
where P,&) is given by (29). 
Since random walkers have the behavior similar to those in 
the binay tree if the forwarding candidates are known, we 
apply the line of reasoning in the binary tree for PLRG Hence: 
the probability vertex i is visited at hop h for RW is 
4 (T’h) = 4 (ti n Rh) = 8 (Rh)  . (Vh 1 Rh ) 
To deal with the phenomenon vertices may be revisited, we 
apply the line of reasoning in BFS in PLRG Therefore, the 
formula of Ch in (23) still holds for RW except using Pi(Vh) of 
RW (3 1 j. Thus, SE for random walk with k walkers is gwen 
by 
where CA specified is by (23),  in which P,{Pi) is formulated by 
Search Efficiency Analysis: By the same conditions for 
BFS. we plot SE for RW of various numbers of walkers k and 
re-plot SE for BFS for comparison in Fig. 7 .  This figure shows 
RW generates consistently increasing performance in most 
cases of h-, which can be answered by its controlled fashon of 
message genemtion and granuiar coverage that have been 
suggested in [j]. In addition, the curve of k = 2,000 
reasonably explains the redundancy generated by too many 
walkers despite its fine properties in PLRG Inspecting the 
curve of BFS, it outperforms RW in the local search but 
inversely in the global (h>5), wluch confirm the simulation 
results in 1111. 
In sum, SE well characterizes the delayed performance. 
increase of RW and its consistent long-term performance. 
(31). 
E. Su )man ,  of Search Eflciency in PLRG 
Based on the unified metric SE and its temporal analysis, 
we better characterize that, in PLRG BFS gains its excellent 
performance in the local search space but decays I-apidly in the 
long-term search, M-BFS controls its performance increase or 
decrease by the. fraction parameter J and RW performs 
consistently in the global search space while its performance 
increase in relatively slow in the short-term search. 
Furthermore. by the analysis of SE and QE. we can explain 
the causes behind the ostensive phenomena: the great 
short-term performance of BFS stems from its aggressive 
search to deliver tqmnsive results while keeping little 
redundancy in the local and the long-term performance suffers 
from the overwhelming search cost generated while it still 
retrieves satisfactory results in the global. On the other hand, 
the delayed performance increase of RW is due to its 
conservative search and redundancy in the local while its 
conservatism trades for relatively little redundancy and thus 
consistent performance in the global. 
In particular, our work for PLRG strongly reflects previous 
works (simulations) in various respects and in turn is validated 
for its ability of characterizing, especially in tenns of temporal 
analysis. Besides, SE analysis indicates the choice of the 
fraction parameter depends on whether the short-term 
satisfaction or long-term efficiency is more concerned. 
Thus far, we have shown the potency of SE in performance 
characterizing and reasoning. We will further demonstrate its 
strength in guiding the design of search algorithms by 
inventing a new search based on SE and validate the 
performance improvement of the new search in the following 
section 
1498 
Authorized licensed use limited to: IEEE Xplore. Downloaded on October 15, 2008 at 22:01 from IEEE Xplore.  Restrictions apply.
(a) Search Efficiency 
70 
h 4 - k - 5 M U )  
U 5 0  
0 
240 
2 
30 
20 
w 
i n  
0 
1 3 4 5 6 7 
Hop 
0 
E 
U 
g I00 
10 
1 
I 2 3 4 5 6 7 
HOP 
(b) Query Efficiency 
250 
i 
1 2 3 4 . 5  6 7 
HOP 
1000000 
l(rOoO0 
0 10000 
c 
3 
2 1000 
6 
6 
100 
10 
I 
1 2 3 3 5 6 7 
(d) Query Message 
Fig. 9.  Pafonnance comparison bs various merrics-a) Search Eficiency, (b) Orrery Eficiency, (c)  Coveruge, and (d) Qustyhfsg-for RW of various number 
of walkers k and for BFS in PLRG vdhA = 1% under uniform and non-unifomi (NU) object distribution. Solid lines represent data of uniform distribution and 
dashed-lines reprzsent non-uniform distribution. 
We generate SE of Dynamic-I and -2 and make 
performance comparison with BFS. M-BFS (f= 0.3), and RW 
(k = 100) in Fig. 8. We take M-BFS withf= 0.3 in order to 
compare with Dynamic-2, which uses5 = 0.3. And we use 
100 as the number of walks for RW since it generates the best 
performance (in Fig. 7). 
In Fig. 8, we can observe that dynamic searches outperform 
other algorithms especially in the long-term search. They 
resemble BFS witlun h i 2  as expected and perform 
consistently as random walk does, thus outperforming others 
in long-term search as we design Note that Dynamic-2 trades 
its performance at 12 = 3 for its long-term efficiency by using a 
low probabilityf= 0.3, and vice versa for Dynamic-1. 
VI. NON-UNIFORM OBJECT DISTRIBUTION 
Throughout our analysis. for simplicity we had assumed the 
object distribution as uniform. However, this assumption leads 
to the conclusion that QzteryHirs equals to R-Coverage. which 
violates our argument in Section I1.A that Coverage is only 
one of the conditions to produce QueryHits. To support our 
argument and  jus^ our consideration of QueryHits in SE 
rather than Coverage, we analyze SE under a non-uIuform 
object distribution as proposed in [ 111. 
In ths object distribution, the probability a search agent 
(vertex) owns certain object is proportional to its degree d. Let 
0 be the event that certain search agent owns the targeted 
object, then the probability agent i has the object is 
determined by 
( 3 3 )  
R . N . d ,  
1=1 J 
C ( O ) . c d  = ' CN d ' 
such that C,PJ{O) = R N ,  where d, = m / i'" [4]. 
Analytic Derivation: Since the object distribution is not 
uniform, we cannot simply use RCoverage to represent 
Queqdfits, which in fact is formulated by 
QueryHits( h j 
1500 
Authorized licensed use limited to: IEEE Xplore. Downloaded on October 15, 2008 at 22:01 from IEEE Xplore.  Restrictions apply.
Dynamic Search Algorithm in Unstructured Peer-to-
Peer Networks* 
 
Po-Chiang Lin1, Tsung-Nan Lin12, and Hsinping Wang1 
1Graduate Institute of Communication Engineering 
2Department of Electrical Engineering 
National Taiwan University, Taipei, 10617 Taiwan 
{d94942014, tsungnan, r91942041}@ntu.edu.tw 
 
                                                
*This work was supported in part by Taiwan National Science Council under  
grant 95-2219-E-002-018 and 95-2221-E-002-190 
Abstract-Flooding and random walk (RW) are the two typical 
search algorithms in unstructured peer-to-peer networks.  The 
flooding algorithm searches the network aggressively.  It covers 
the most nodes but generates a large number of query messages.  
Hence it is considered to be not scalable.  This cost issue is 
especially serious when the queried resource locates far from the 
query source.  On the contrary, RW searches the network 
conservatively.  It only generates a fixed amount of query messages 
at each hop, but it may take particularly longer search time to find 
the queries resource.  We propose the dynamic search algorithm 
(DS) which is a generalization of flooding, modified breadth first 
search (MBFS), and RW.  This search algorithm takes advantage 
of different contexts under which each previous search algorithm 
performs well.  The operation of DS resembles flooding or MBFS 
for the short-term search, and RW for the long-term search.  We 
analyze the performance of DS based on the power-law random 
graph model and adopt some performance metrics including the 
guaranteed search time, query hits, query messages, success rate, 
and a unified metric, search efficiency.  The main objective is to 
obtain the effects of the parameters of DS. Numerical results show 
that proper setting of the parameters of DS can obtain the short 
guaranteed search time and provide a good tradeoff between the 
search performance and the cost. 
 
I. INTRODUCTION 
 
    The design of search algorithms is critical to the performance of 
unstructured peer-to-peer (P2P) networks.  In the unstructured P2P 
networks, each node does not have the global information about the 
whole topology and the location of queried resources.  Therefore, it 
depends on the search algorithms to help locating the queried resource 
and routing the message to the target node. 
    Related works about the search issue in unstructured P2P networks 
can be classified into two categories: breadth first search (BFS)-based 
methods, and depth first search (DFS)-based methods.  Flooding, 
which belongs to the BFS-based methods, is the default search 
algorithm for Gnutella network [1].  In this method, the query source 
sends the query message to all of its neighbors.  When a node receives 
a query message, it first checks if it has the queried resource.  If yes, it 
sends a response back to the query source to indicate the query hit.  
Otherwise, it sends the query message to all of its neighbors, except the 
one the query message comes from.  The drawback of flooding is the 
query cost.  It produces considerable query messages even when the 
resource distribution is scarce.  The search is especially inefficient 
when the target is far from the query source because the number of 
query messages would grow exponentially with hop count.  Figure 1 
shows a simple network scenario.  The link degree of each vertex in 
this graph is 4.  If the network grows unlimited from the query source, 
the number of query messages at each hop would be 4, 12, 36,…, 
respectively.  If the queried resource locates at on of the 3rd neighbors, 
it takes 4 + 12 + 36 = 52 query messages to find just one resource.  
Some BFS-based methods try to modify the flooding to improve the 
efficiency, including modified-BFS (MBFS) [2], directed BFS [3], 
expanding ring [4], and random periodical flooding (RPF) [5].  
However, these methods still generate the large amount of query 
messages when the queried resource locates far from the source.  On 
the other hand, random walk (RW) is an efficient search algorithm 
which belongs to the DFS-based methods.  In RW, the query source 
just sends one query message (walker) to one of its neighbors.  If this 
neighbor does not own the queried resource, it keeps on sending the 
walker to one of its neighbors, except the one the query message comes 
from.  Hence the search cost is reduced.  The main drawback of RW is 
that the search time to find the target is usually long.  Since RW only 
visits one node for each hop, the coverage of RW grows linearly with 
hop count, which is slow compared with the exponential growth of 
flooding.  Moreover, the success rate of each query by RW is also low 
due to the same coverage issue.  Increasing the number of walkers 
might help to improve the search time and success rate, but the effect is 
limited due to the link degree and the redundant path in the network.  
As the example shown in Figure 1, RW can only visit 12 vertices of 
second neighbors even when the number of walkers k is set as 32. 
Therefore, the search is inefficient because 32 walkers only visit 12 
vertices at the second hop. Some research works are designed to 
provide additional information about the more possible direction and 
route the walkers with different link weights based on these directional 
information, such as APS [6], biased RW [7] and routing index (RI) [8].  
Some other works focus on replicating the reference pointer to the 
queried resources in order to improve the search time [9] [10]. 
    In this paper we propose the dynamic search algorithm (DS) which 
is a generalization of flooding, MBFS, and RW. The DS algorithm 
overcomes the different disadvantages of flooding and RW, and takes 
advantage of different contexts under which each search algorithm 
performs well.  The operation of DS resembles flooding or MBFS for 
the short-term search, and RW for the long-term search.  In order to 
analyze the performance of DS, we apply Newman’s power-law 
©1-4244-0357-X/06/$20.00     2006 IEEE
This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE GLOBECOM 2006 proceedings.
Authorized licensed use limited to: National Taiwan University. Downloaded on October 15, 2008 at 22:05 from IEEE Xplore.  Restrictions apply.
( ) ( )τ
τ
 - 2'
0 m - 1 2 - 
1  1G ≅  (1) 
and 
( ) ( ) τ
τ
 - 3
m 
1G
1  1G
 - 3
'
0
'
1 ≅  (2) 
assuming 2 < τ < 3, where τ is the power-law exponent. 
B. Performance Metrics 
 Success Rate (SR) 
    Success rate (SR) is the probability that the query is success, i.e., 
there is at least one query hit.  Assume that the queried resources are 
uniformly distributed in the network with replication ratio R, and then 
SR can be calculated as 
( )CR - 1 - 1  SR =  (3) 
where R is the replication ratio and C is the coverage.  This formula 
shows that the SR highly depends on the coverage of the search 
algorithms.  Following we use (3) to obtain an important metric – 
guaranteed search time. 
 Guaranteed Search Time (GST) 
    To represent the capability of one search algorithm to find the 
queried resource with a given probability, we define the guaranteed 
search time (GST) as the search time it takes to guarantee the query 
success with success rate requirement SRreq.  GST represents the hop 
count that a search is successful with probabilistic guarantee.  Using 
Equation (3), GST is obtained when the coverage C is equal to 
( ) ( )reqR - 1  SR- 1log .  For the MBFS search algorithms, this situation 
occurs when 
( ) ( ) ( ) ( ) ( )( )
( ) ( )( )
( ) ( )reqR - 1
1 - GST'
1
'
0
GST
2'
1
'
0
3'
1
'
0
2'
0
 SR- 1log 
1G  1G  p 
1G  1G  p  1G  1G  p  1G  p
MBFSMBFS
=
⋅⋅++
⋅⋅+⋅⋅+⋅
…  (4) 
Thus the GST for MBFS is  
( )
( )( ) ( ) ( )
( ) 







+
⋅
⋅⋅
=
⋅
1  
1G  p
 SR- 1log  1 - 1G  p
log 
GST
'
0
reqR - 1
'
1
1G  p
MBFS
'
1
 (5) 
The GST of flooding is analogue to that of MBFS with probability p = 
1. The calculation of RW depends on the number of walkers k. When k 
is set as 1, the GST for RW is obviously ( ) ( )reqR - 1  SR- 1log .  When k 
is larger than 1, assume that 
( ) ( )( ) ( ) ( )( )t'1'01 - t'1'0 1G  1G  k  1G  1G ⋅≤≤⋅  (6) 
i.e., k is equal to or larger than the average number of the tth neighbors 
of the query source, and assume that the effect of redundant paths can 
be neglected, and then follow the same reason in (4), the GST for RW 
is 
( )( ) ( ) ( )( )
t  
k
1G  1G -  SR- 1log
 GST
1 - t
0  i
i'
1
'
0reqR - 1
RW +
⋅
=
∑
=  
(7) 
    Now we consider the GST for DS.  When the hop count h of query 
message is smaller than or equal to the decision threshold n, the GST 
of DS is equal to (5).  When h is larger than n, the GST for DS is 
( ) ( )
( ) ( )( )
( )( )
( )( ) ( )( )
( )( )
( ) ( )( ) 1 - 1G  1G  p
 SR- 1log
  n 
1G  p  1 - 1G  p
1 - 1G  p
 -
1G  1G  p
 SR- 1log
  n 
 GST
1 - n'
1
'
0
n
reqR - 1
1 - n'
1
'
1
n'
1
1 - n'
1
'
0
n
reqR - 1
DS
⋅⋅
+≅
⋅⋅⋅
⋅
⋅⋅
+
=
 
(8) 
We compare the GTS for DS and for RW with 1 walker.  The 
improvement ratio is 
( )
( ) ( )( )n'1'0
'
1
RW
DSRW
1G  p
1  
1G
1G
 - 1  
GST
GST - GST
⋅
⋅≅  (9) 
In Equation (9), the last term on the right would significantly affect the 
performance improvement.  The GTS of DS would be exponentially 
decreased with n, which can be expressed as O(1/n).  Larger p would 
also affect the performance, but the effect is slow when compared with 
n.  The extreme case of n is that it is set as the TTL limitation, i.e., DS 
performs as flooding or MBFS.  In this case the GST would be the 
shortest.  However, it would generate a huge amount of query 
messages.  The tradeoff between the search performance and the cost 
should be taken into consideration.  In the following paragraphs, we 
further analyze the number of query hits and the number of query 
messages, and further combine these metrics into a unified metric, 
search efficiency. 
 Query Hits (QH) 
    The number of query hits highly depends on the coverage, i.e., the 
number of total visited nodes.  Assume that the queried resources are 
uniformly distributed with replication ratio R in the network, and the 
coverage is C; hence the number of query hits is RC.  The coverage C 
can be regarded as the summation of the coverage at each hop.  
Therefore, we first analyze the coverage Ch at the hth hop.  Let Vh be 
the event that a vertex is visited at the hth hop.  Suppose the probability 
that the vertex i is visited at the hth hop is Pi(Vh).  When the hop count 
h = 1, Ch is the expectation of the vertices that are visited at the first 
hop.  When the hop count h is larger than 1, the calculation of Ch 
should preclude the event that the vertex has been visited in the 
previous hop.  Therefore, the coverage Ch at the hth hop can be written 
as 
( )
( )[ ] ( )


≥⋅
=
= ∑∏
∑
= =
=
2  h for ,VP  VP - 1
1  h for ,VP
  C N
1  i
1 - h
1 j 
hiji
N
1  i
hi
h  (10) 
where N is the total number of vertices in the network. 
    Following we analyze the visiting probability Pi(Vh) for flooding, 
MBFS, RW, and DS, respectively.  First we consider the flooding and 
MBFS case.  The visiting probability Pi(Vh) of flooding or MBFS is 
( ) ( )( )[ ]


≥⋅⋅
=⋅⋅
=
2  h for ,1G  p  p - 1 - 1
1  h for ,1G  p  p
  VP
1 - hC'
1i
'
0i
hi  (11) 
where pi is the probability that vertex i is to be reached by certain edge.  
Reference [14] shows that pi can be written as 
∑
=
=
N
1  i
1
1
i
im
im  p
τ
τ
 (12) 
©1-4244-0357-X/06/$20.00     2006 IEEE
This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE GLOBECOM 2006 proceedings.
Authorized licensed use limited to: National Taiwan University. Downloaded on October 15, 2008 at 22:05 from IEEE Xplore.  Restrictions apply.
    We show the numerical results of GST in Figure 5. Replication ratio 
R is set as 0.01 in this case.  Similar results can be obtained when R is 
set as other values.  The numbers of walkers k for RW are set as 1 and 
32.  The decision thresholds n are set as 2, 3 and 7, and p is set as 1.  
TTL is set as 7 in this case, thus the DS with n = 7 is equal to flooding.  
From this figure DS with large n always gets the short GST because it 
always covers more vertices.  On the contrary, RW with k = 1 always 
gets the longest GST since its coverage is only incremental by one at 
each hop.  When k is set as 32, its coverage is enlarged and the GST 
can be improved.  However, DS still performs better than RW with 32 
walkers even when n is set as only 2.  Note that when n is set as 3, DS 
performs as well as that with n = 7, i.e., flooding, while not generating 
so many query messages. 
    In summary, DS with n = 2 and p = 1 would get the best SE and 
significantly improve the GST.  While increasing n to 3, although SE is 
a little degraded, the shortest GST is obtained. 
 
V. CONCLUSION 
 
    In this paper we propose the DS algorithm which is a generalization 
of flooding, MBFS, and RW. The DS algorithm overcomes the 
different disadvantages of flooding and RW, and takes advantage of 
different contexts under which each search algorithm performs well. 
The operation of DS resembles flooding or MBFS for the short-term 
search, and RW for the long-term search.  We analyze the performance 
of DS based on some metrics including the average search time, 
guaranteed search time, number of query hits, number of query 
messages, success rate, and search efficiency. The main objective is to 
obtain the effects of the parameters of DS. Numerical results show that 
proper setting of the parameters of DS can obtain short guaranteed 
search time and provide a good tradeoff between the search 
performance and the cost. 
REFERENCES 
[1] Clip2 Distributed Search Services, “The Gnutella protocol 
specification v0.4,” http://dss.clip2.com 
[2] V. Kalogeraki, D. Gunopulos, and D. Zeinalipour-Yazti, “A 
local search mechanism for peer-to-peer networks,” in 
Proceedings of the 2002 ACM CIKM, November 2002, pp. 
300–307. 
[3] B. Yang and H. Garcia-Molina, “Improving search in peer-to-
peer networks,” ICDCS, July 2002, pp. 5–14. 
[4] Q. Lv, P. Cao, E. Cohen, K. Li, and S. Shenker, “Search and 
replication in unstructured peer-to-peer networks,” in Proc. of 
ICS’02, June 2002, pp. 84–95. 
[5] Z. Zhuang, Y. Liu, L. Xiao, and L. M. Ni, “Hybrid periodical 
flooding in unstructured peer-to-peer networks,” in 
Proceedings of ICPP’03, October 2003, pp. 171–178. 
[6] D. Tsoumakos and N. Roussopoulos, “Adaptive probabilistic 
search for peer-to-peer networks,” in Proceedings of the 3rd 
International Conference on Peer-to-Peer Computing 
(P2P’03), September 2003, pp. 102–109. 
[7] Y. Chawathe, S. Ratnasamy, L. Breslau, N. Lanham, and S. 
Shenker, “Making gnutella-like p2p systems scalable,” in 
Proceedings of the ACM SIGCOMM, August 2003, pp. 407–
418. 
[8] A. Crespo, H. Garcia-Molina, “Routing Indices for peer-to-
peer systems,” ICDCS, 2002. 
[9] R. A. Ferreira, M. K. Ramanathan, A. Awan, A. Grama, S. 
Jagannathan, “Search with probabilistic guarantees in 
unstructured peer-to-peer networks,” Proc. of P2P’05. 
[10] N. Sarshar, P. O. Boykin, V. P. Roychowdhury, “Percolation 
search in power law networks: making unstructured peer-to-
peer networks scalable,” Proc of P2P’04. 
[11] M. E. J. Newman, S. H. Strogatz, and D. J. Watts. Random 
graphs with arbitrary degree distribution and their 
applications. Phys. Rev. E, 64:026118, 2001. 
[12] H. Wang, T. Lin, “On efficiency in searching networks,” 
INFOCOM, March 2005. 
[13] L. A. Adamic, R. M. Lukose, B. A. Huberman, “Local search 
in unstructured networks,” Handbook of graphs and networks, 
WILEY-VCH GmbH & Co. KGaA, Weinheim, 2003, pp.295-
317. 
[14] W. Aiello, F. Chung, and L. Lu. A random graph model for 
massive graphs. Proceedings of the thirty-second annual ACM 
symposium on Theory of Computing, pages 171-180, 2000. 
[15] L. A. Adamic, R. M. Lukose, A. R. Puniyani, and B. A. 
Huberman. Search in power-law networks. Phys. Rev. E, 
64:046135, 2001. 
 
Figure 4. The effects of the parameters (n, p) on the SE. The best SE 
is obtained when (n, p) is set as (2, 1). 
Figure 5. GST vs. SR requirement.  R is set as 1%. k for RW are 
set as 1 and 32.  The n of DS are set as 2, 3 and 7, and p is set as 1.  
TTL is set as 7, thus the DS with n = 7 is equal to flooding. 
©1-4244-0357-X/06/$20.00     2006 IEEE
This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE GLOBECOM 2006 proceedings.
Authorized licensed use limited to: National Taiwan University. Downloaded on October 15, 2008 at 22:05 from IEEE Xplore.  Restrictions apply.
2 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS, TPDS-2008-07-17 
for the long-term search.  In order to analyze the per-
formance of DS, we apply the random graphs as the 
models of network topologies and adopt the probability 
generating functions to model the link degree distribution 
[14].  We evaluate the performance of search algorithms 
in accordance with some performance metrics including 
the success rate, search time, number of query hits, num-
ber of query messages, query efficiency, and search effi-
ciency [9] [15] [16].  Simulation experiments are per-
formed in a dynamic P2P networking environment in 
order to collect convincing results for algorithm evalua-
tions. The factors considered include the network topol-
ogy, link degree distribution, peer’s joining and leaving, 
and querying behavior as well as the activity of file shar-
ing [10] [17] [18] [19].  Our dynamic network model is 
constructed based on these factors that strongly reflect the 
real measurement studies [17] [20] [21] [22].  Numerical 
results show that DS could provide a good tradeoff be-
tween search performance and cost.  On average, DS per-
forms about 25 times better than flooding and 58 times 
better than RW in power-law graphs, and about 186 times 
better than flooding and 120 times better than RW in bi-
modal topologies. 
The rest of this paper is organized as follows.  Section 2 
shows the related works about the search issue in un-
structured P2P networks, followed by the detailed de-
scription of the proposed DS algorithm in Section 3.  The 
performance analysis is given in Section 4.  Numerical 
results and discussions are given in Section 5.  Finally, the 
conclusion is presented in Section 6. 
2 RELATED WORKS 
Flooding and RW are two typical examples of blind 
search algorithms by which query messages are sent to 
neighbors without any knowledge about the possible lo-
cations of the queried resources or any preference for the 
directions to send.  Some other blind search algorithms 
include modified-BFS (MBFS) [23], directed BFS [6], ex-
panding ring [17], and random periodical flooding (RPF) 
[24].  These algorithms try to modify the operation of 
flooding to improve the efficiency.  However, they still 
generate a large amount of query messages.  Jiang et al. 
propose a LightFlood algorithm which is a combination 
of the initial pure flooding and subsequent tree-based 
flooding [25] [26].  DS and LightFlood operate analo-
gously, but DS avoids the extra cost to construct and 
maintain the tree-like suboverlay. 
Fig. 1. A simple scenario of P2P network to dem-
onstrate the operation of flooding and RW. 
Knowledge-based search algorithms take advantage of 
the knowledge learned from previous search results and 
route query messages with different weights based on the 
knowledge.  Thus each node could relay query messages 
more intelligently.  Some examples are adaptive probabil-
istic search (APS) [27] [28], biased RW [29], routing index 
(RI) [30], local indices [31], and intelligent search [32].  
APS builds the knowledge with respect to each file based 
on the past experiences.  RI classifies each document into 
some thematic categories and forwards query messages 
more intelligently based on the categories.  The operation 
of local indices is similar to that of super-peer networks.  
Each node collects the file indices of peers within its pre-
defined radius.  If a search request is out of a node’s 
knowledge, this node would perform a flooding search.  
The intelligent search uses a function to compute the 
similarity between a search query and recently answered 
requests.  Nodes relay query messages based on the simi-
larity.  There are some other research works which focus 
on replicating a reference pointer to queried resources in 
order to improve the search time [33] [34]. 
3 DYNAMIC SEARCH ALGORITHM
In this section we provide the details of the proposed 
DS algorithm.  Subsection 3.1 presents the operation of 
DS algorithm, and subsection 3.2 provides the mechanism 
to combine DS with the knowledge-based search algo-
rithms. 
3.1 Operation of Dynamic Search Algorithm 
DS is designed as a generalization of flooding, MBFS, 
and RW.  There are two phases in DS.  Each phase has a 
different searching strategy.  The choice of search strategy 
at each phase depends on the relationship between the 
hop count h  of query messages and the decision thresh-
old  of DS. n
Phase 1. When h nd : 
At this phase, DS acts as flooding or MBFS.  The num-
ber of neighbors that a query source sends the query mes-
sages to depends on the pre-defined transmission prob-
ability .  If the link degree of this query source is d , it 
would only send the query messages to d  neighbors.  
When  is equal to 1, DS resembles flooding.  Otherwise 
it operates as MBFS with the transmission probability . 
p
p
p
p
Phase 2. When : h n!
At this phase, the search strategy switches to RW.  
Each node which receives the query message would send 
the query message to one of its neighbors if it does not 
have the queried resource.  Assume that the number of 
nodes visited by DS at hop  is the coverage n , and 
then the operation of DS at that time can be regarded as 
RW with nc  walkers.  However, there are some differ-
ences between DS and RW when we consider the whole 
operation.  Consider the simple scenario shown in Fig. 1.  
Assume that the decision threshold n  is set as 2.  When 
, DS performs the same as RW with  walkers.  
h n c
2h ! 2 12c  
 
This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication.
Authorized licensed use limited to: National Taiwan University. Downloaded on October 15, 2008 at 22:19 from IEEE Xplore.  Restrictions apply.
4 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS, TPDS-2008-07-17 
sented as 
 0
  1
m
k
k
k
G x p x
 
 ¦  (1) 
where kp  is the probability that a randomly chosen ver-
tex in the graph has degree k , and m  is the maximum 
degree.  Based on the generating function, the average 
degree of a randomly chosen vertex is given by 
 1 0
  1
' 1
m
k
k
z k kp G
 
  !  ¦ . (2) 
The average number of second neighbors is 
      ' '2 0 1 0 1
1
1 1
x
dz G G x G G
dx  
ª º  « »¬ ¼  (3) 
where  1G x  is given by 
    01 0
'
' 1
G x
G x
G
  (4) 
Due to the difficulties to correctly measure and sample 
the operational P2P networks, there are only limited real 
data about the topologies of such networks.  In this paper, 
we will use the top two most common topologies, the 
power-law graphs and the bimodal topologies, to evalu-
ate the search performance. 
Power-Law Graphs 
For the power-law random graph with the degree ex-
ponent W , kp  is proportional to -k W  [36].  That is, 
-  kp k
Wv . (5) 
According to [11], the following approximations for the 
power-law distribution are obtained. 
   ' 20 11 1-- 2G m -WW#  (6) 
and 
   
3-
'
1 '
0
11
3 -1
mG
G
W
W#   (7) 
assuming 2< <3W . 
Bimodal Topologies 
For the bimodal network topology [12] [29], few ultra-
peers are connected to a large number of nodes, and the 
rest have few neighbors.  This assumption is regarded as 
realistic and followed by most papers such as [37] and 
[38].  The probability that a randomly chosen peer be-
longs to the ultra-peers is denoted as , and the prob-
ability that this peer belongs to the other part with few 
neighbors is thus 
ultrap
1-few ultrap p .  The degrees of the ultra-
peers and the peers with few neighbors are denoted as 
 and ultrak fewk .  Applying these parameters to (1)-(4), the 
average number of neighbors at each hop for the bimodal 
topologies could be obtained. 
4.2 Performance Analysis 
Success Rate (SR) 
The success rate ( ) is the probability that a query is 
successful, i.e., there is at least one query hit.  Assume 
that the queried resources are uniformly distributed in 
the network with a replication ratio 
SR
R .   can be calcu-
lated as 
SR
 1- 1- CSR R  (8) 
where R  is the replication ratio and C  is the coverage.  
This formula shows that SR  highly depends on the cov-
erage of the search algorithms.  We use (8) to obtain an 
important performance metric, the search time ( ST ), in 
the following. 
Search Time (ST) 
    To represent the capability of one search algorithm 
to find the queried resource in time with a given probabil-
ity, we define the search time ( ) as the time it takes to 
guarantee the query success with success rate require-
ment req .   represents the hop count that a search is 
successful with a probabilistic guarantee.  Using 
ST
SR ST
(8),  
is obtained when the coverage C  is equal to 
 
ST
 1-log 1- reqR SR .  For MBFS search algorithms, this situa-
tion occurs when 
          
    
   
2' 2 ' ' 3 ' '
0 0 1 0 1
-1' '
0 1
1-
1 1 1 1
1 1
log 1-
MBFS
MBFS
STST
reqR
p G p G G p G G
p G G
SR
      
}  
 
1
 (9) 
Thus  for MBFS is  ST
 
      
 '1
'
1 1-
1 '
0
1 -1 log 1-
log 1
1
MBFS
reqR
p G
ST
p G SR
p G
§ · ¨ ¸ ¨ ¸¨ ¸© ¹
 (10) 
ST  of flooding is analogue to that of MBFS with probabil-
ity 1p  . 
The calculation of RW depends on the number of 
walkers .  When k  is set as 1, ST  for RW is obviously k
   1-log 1- reqR SR .  When  is larger than 1, assume that k
      - 1     ' '0 1 0 11 1 1 1t tG G k G G d d ' '  (11) 
i.e.,  is equal to or larger than the average number of the 
 neighbors of the query source, and assume that the 
effect of redundant paths can be neglected, and then the 
calculation for  of RW can be expressed as 
k
tht
ST
          
     
-1' ' ' ' '
0 0 1 0 1
1-
1 1 1 1 1
- log 1-
t
RW reqR
G G G G G
k ST t SR
  } 
   
 (12) 
ST  for RW is 
        -1 ' '0 11- 0log 1- - 1 1 
RW
it
reqR i
ST
SR G G
t
k
  ¦  (13) 
    Now we consider  for DS.  When the hop count 
 of the query message is smaller than or equal to the 
decision threshold n ,  of DS is equal to 
ST
h
ST (10).  When h  
is larger than , the calculation can be expressed as n
 
This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication.
Authorized licensed use limited to: National Taiwan University. Downloaded on October 15, 2008 at 22:19 from IEEE Xplore.  Restrictions apply.
6 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS, TPDS-2008-07-17 
sages for each hop keeps fixed as , i.e., the number of 
walkers.  Therefore, the total number of query messages 
for RW is k . 
k
TTL
The calculation of query messages for DS depends on 
 and .  The query messages  generated at hop  for 
DS can be written as 
h n he h
 
 
'
0
'
1 -1
1 ,   1
1 ,   2
,   
h h
n
p G for h
e p G C for h
C for h n
­   °°   d d®° !°¯
n  (25) 
Query Efficiency (QE) 
The number of query hits ( ) and the number of 
query messages ( ) are the well-known performance 
metrics for the evaluations of search algorithms.  Gener-
ally speaking, the objective of search algorithms is to get 
the most query hits with the fewest query messages, but 
these two metrics often conflict with each other.  There-
fore, it requires a more objective metric to evaluate the 
search performance.  We adopt the performance metrics 
proposed in 
QH
QM
[15], query efficiency ( ) and search effi-
ciency ( ), which consider both the search performance 
and the cost.  The similar criterion can also be found in 
QE
SE
[9].  
First we calculate .  In QE [15] QE  is defined as 
 
1 1
TTL
h
QH h
QE
QM R
  ¦  (26) 
where  means the query hits at the  hop,  
is the total number of query messages generated during 
the query, and 
 QH h thh QM
R  means the replication ratio of the que-
ried object.  Since a search getting hits in a faster fashion 
delivers better users’ experiences and should be gauged 
as the higher reputation, we modify (26) and show two 
types of .  1QE  is calculated as sQE (26) shows, and 
penalizes search results coming from far away. 2QE
 
1
2
1
TTL
h
QH h h
QE
QM R
  ¦  (27) 
Search Efficiency (SE) 
The search efficiency ( ) is proposed as a unified 
performance metric for search algorithms 
SE
[15].  A similar 
criterion can be found in [9].  While the query efficiency 
 does not consider the success rate ,  is defined 
as 
QE SR SE
 
1
TTL
h
QH h h SRSE
QM R
  ¦  (28) 
where  QH h h  means the query hits in the  hop 
weighted by the hop count, QM  is the total number of 
query messages generated during the query,  is the 
probability that the query is successful, i.e., there is at 
least one query hit, and 
thh
SR
R  means the replication ratio of 
the queried object.  Thus the success rate  is taken into 
consideration.  Assume that the object is uniformly dis-
tributed in the network.  Then the query hit at the  hop 
is equal to the multiplication of the coverage at the  
hop and the replication rate 
SR
thh
thh
R .  Therefore, (28) can be 
written as 
  11
1
1- 1-
TTL
hh
TTL C
hh
TTL
hh
C R h R
SE
Re
  
 
 
¦¦
¦  (29) 
where hC  is the coverage at the  hop, h  is the query 
messages generated at the  hop, and 
thh e
thh R  is the replica-
tion ratio.  We consider two types of .   does not 
penalize search results coming from far away. 
sSE 1SE
  11
1
1
1- 1-
TTL
hh
TTL C
hh
TTL
hh
C R R
SE
Re
  
 
 
¦¦
¦ , (30) 
and  is calculated as 2SE (29) shows. 
4.3 Experimental Environment 
We construct the experimental environment to evalu-
ate the performance of the knowledge-based DS algo-
rithm.  For the network topology modeling, we model the 
P2P network as Gnutella to provide a network context in 
which peers can perform their intended activities.  The 
measurements in [17] and [20] have suggested that the 
topology of Gnutella network has the property of two-
segment power-law link distribution.  Thus, we construct 
a P2P network of 100,000 peers in our simulator, in which 
the link distribution follows the reported two-segment 
power law.  We set the first power-law slope as 0.2316 
and the second as 1.1373, which are similar to the ones 
used in [17].  The statistics result of the topology embed-
ded in our simulator are that the maximum link degree is 
632, mean is 11.73, and standard deviation is 17.09.  Once 
the node (peer) degrees are chosen, we connect these 
peers randomly and reassure every peer is connected 
properly (each peer has at least one link). 
For the object distribution of the network, we assume 
there are 100 distinct objects with replication ratio of 
1%R  ; totally there are 100,000 objects in the network.  
The distribution of the 100,000 objects over the network 
follows the measurement characteristics reported in [21].  
In addition, due to the dynamic environment—peers join 
and leave dynamically—described in the following sub-
section, the total number of objects available in the net-
work will fluctuate according to the network size (num-
ber of on-line peers) but the replication ratio will roughly 
remain constant. 
Our dynamic peer behavior modeling largely follows 
the proposed idea of the peer cycle [18], which includes 
joining, querying, idling, leaving, and joining again to 
form a cycle.  The joining and leaving operations of peers 
(include idling) are inferred and then modeled by the 
uptime and session duration distributions measured in 
[21] and [22].  These measurement studies show similar 
results in the peer uptime distribution, where half of the 
peers have uptime percentage less than 10% and the best 
20% of peers have 45% uptime or more.  We use the log-
quadratic distribution suggested in [22] to re-build the 
uptime distribution, which is plotted in Figure 4.  But for 
the session duration distribution, those two studies lead 
to different results.  The median of session time in [22] is 
about 15 minutes while it is 60 minutes in [21].  In our 
modeling, we choose the median session duration time to 
be 20 minutes. 
 
This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication.
Authorized licensed use limited to: National Taiwan University. Downloaded on October 15, 2008 at 22:19 from IEEE Xplore.  Restrictions apply.
8 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS, TPDS-2008-07-17 
Fig. 7. ST  vs. SR  requirement.  R  is set as 0.01 in 
this case.  The walkers sK  for RW are set as 1 and 
32, respectively.  The n of DS are set as 2, 3 and 7, 
and p is set as 1.  TTL is set as 7 in this case, thus 
the DS with n = 7 is equal to flooding. 
Fig. 6. The best  ,n p  combination when N  is set 
as 10000, R  is set as 0.01, and TTL  is set as 7. 
Search Time 
We show the numerical results of ST  in Fig. 7.  In this 
case N  is set as 10000, R  is set as 0.01, and TT is set as 7. 
Similar results can be obtained when the parameters are 
set as other values.  The walkers s
L   
K  for RW are set as 1 
and 32.  The decision thresholds n are set as 2, 3 and 7, 
and  is set as 1.  TT  is set as 7 in this case, thus DS 
with  is equal to flooding.  From Fig. 7 DS with large 
 always gets the short  because it always covers 
more vertices.  On the contrary, RW with 
 
p L
7n  
n ST
1K   always 
gets the longest ST  since its coverage is only incremental 
by one at each hop.  When K  is set as 32, its coverage is 
enlarged and ST  can be improved.  However, DS still 
performs better than RW with 32 walkers even when  is 
set as only 2.  Note that when n  is set as 3, DS performs 
as well as that with , i.e., the flooding, while does 
not generate as many query messages.  In summary, DS 
with  and 
n
7n  
2n  1p   would get the best SE  and signifi-
cantly improve  in this case.  While increasing n  to 3, 
although  is a little degraded, the shortest ST  is ob-
tained. 
ST
SE
Comparison with Other Advanced Search Algorithms 
We also compare the performance of DS with that of 
other advanced search algorithms including Hybrid 
Search [12] and Expanding Ring [17].  The number of 
nodes N  is set as 10000.  Power-law exponent W  is set as 
2.1.  Replication ratio R  is set as 0.01 in this case.  Fig. 4 
shows  of these search algorithms.  SE  of Hybrid 
Search is analogue to that of RW.  They both increase 
slowly with hop counts.  SE  of Expanding Ring is ana-
logue to but a little worse than that of the flooding.  This 
is because Expanding Ring would revisit the nodes it has 
already visited before.  It would thus generate redundant 
messages.  SE  of DS is better than that of Hybrid Search 
and Expanding Ring for all hop counts. 
sSE
Fig. 7 shows  of these search algorithms.  The op-
eration of Hybrid Search is analogue to that of RW with 
.  Based on our simulation parameters, 
sST
 1' 1K G  1' 1G  
is roughly 16.  Thus ST  of Hybrid Search is better than 
that of RW(1), but worse than that of RW(32).  ST  of Ex-
panding Ring is almost 1 hop worse than that of the 
flooding.  When the flooding reaches the second 
neighbors at the second hop, Expanding Ring just revisits 
the first neighbors and there is no increment in coverage.  
For  requirement smaller than 0.7, ST  of DS(2) is 
shorter than that of Expanding Ring, while  of DS(2) 
would be longer than that of Expanding Ring for  re-
quirement larger than 0.7. 
SR
ST
SR
Scalability 
In order to validate the scalability of our DS algorithm, 
we show the search efficiency for different number of 
nodes in Fig. 8.  Nodes sN  are set as 10k, 50k, 100k, and 
500k, respectively.  The replication ratio R  is set as 0.01, 
and TT  is set as 7.  This figure shows that our DS algo-
rithm always performs better than flooding and RW in 
spite of the number of nodes. 
L
Performance under Various Network Topologies and 
Replication Ratios 
TABLE 2 and 3 show the search performance under 
power-law random graphs and bimodal topologies, re-
spectively.  The replication ratio R  is set as 0.01%, 0.1%, 
and 1%, respectively.  The performance metrics including 
the success rate ( ), search time ( ST ), number of query 
hits (QH ), number of query messages ( ), query effi-
ciency ( ), and search efficiency ( ), are listed in 
these tables.  Two types of QE  and  are shown.  
Ones without the penalty that the search results come 
from far away (  and 1 ), and the others with the 
penalty ( 2  and ), as mentioned in Section 4.2.  
When considering 1QE  and 2 , RW performs the best 
because it covers the fewest redundant nodes.  Although 
RW generates the fewest query messages, its SR , , 
, and the resulting  do not perform well.  In most 
cases, DS can perform closely to the flooding search when 
considering  and  without generating as many 
query messages as flooding does.  In summary, DS ob-
tains satisfactory performances in spite of the number of 
nodes, the replication ratio, and the network topologies.  
On average, it performs about 25 times better than the 
flooding and 58 times better than RW in power-law 
graphs, and about 186 times better than the flooding and 
SR
QM
QE SE
s sSE
1QE SE
QE 2SE
QE
ST
QH SE
SR ST
 
This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication.
Authorized licensed use limited to: National Taiwan University. Downloaded on October 15, 2008 at 22:19 from IEEE Xplore.  Restrictions apply.
10 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS, TPDS-2008-07-17 
ety, pp. 5–14, July 2002. 
[7] G. Kan, “Gnutella,” Peer-to-Peer Harnessing the Power 
of Disruptive Technologies, O’Reilly, pp.94-122, 2001. 
[8] RFC-Gnutella 0.6, http://rfc-gnutella.sourceforge.net 
/developer/testing/index.html 
[9] C. Gkantsidis, M. Mihail, A. Saberi, “Random Walks in 
Peer-to-Peer Networks,” in Proceedings of IEEE INFO-
COM, pp. 120-130, 2004.
[10] L. A. Adamic, R. M. Lukose, A. R. Puniyani, B. A. 
Huberman, “Search in Power-Law Networks,” Phys. 
Rev. E 64, 046135, 2001. 
[11] L. A. Adamic, R. M. Lukose, B. A. Huberman, “Local 
search in unstructured networks,” Handbook of graphs 
and networks, WILEY-VCH GmbH & Co. KGaA, Wein-
heim, pp.295-317, 2003. 
[12] C. Gkantsidis, M. Mihail, A. Saberi, “Hybrid Search 
Schemes for Unstructured Peer-to-Peer Networks,” in 
Proceedings of IEEE INFOCOM, pp. 1526-1537, 2005. 
[13] N. Bisnik and A. Abouzeid, “Modeling and Analysis of 
Random Walk Search Algorithm in P2P Networks,” pp. 
95-103, Second International Workshop on Hot Topics in 
Peer-to-Peer Systems, 2005 
[14] M. E. J. Newman, S. H. Strogatz, and D. J. Watts, “Ran-
dom graphs with arbitrary degree distribution and their 
applications,” Phys. Rev. E 64, 026118, 2001. 
[15] H. Wang, T. Lin, “On efficiency in searching networks,” 
in Proceedings of IEEE INFOCOM, pp. 1490-1501, 2005. 
[16] P.ȱLin,ȱT.ȱLinȱandȱH.ȱWang,ȱ“DynamicȱSearchȱAlgorithmȱ
inȱ Unstructuredȱ PeerȬtoȬPeerȱ Networks,”ȱ Globalȱ TeleȬ
communicationsȱ Conference,ȱ 2006.ȱ GLOBECOMȱ ’06.ȱ
IEEE,ȱNov.ȱ2006. 
[17] Q. Lv, P. Cao, E. Cohen, K. Li, and S. Shenker, “Search 
and replication in unstructured peer-to-peer networks,” 
in Proceedings of the 16th Annual International Confer-
ence on Supercomputing (ICS’02), New York City, NY, 
USA, pp. 84–95, June 2002. 
[18] Z. Ge, D. R. Figueiredo, S. Jaiswal, J. Kurose, and D. 
Towsley, “Modeling Peer-Peer File Sharing Systems,” in 
Proceedings of IEEE INFOCOM, pp. 2188-2198, 2003. 
[19] Kunwadee Sripanidkulchai. The popularity of gnutella 
queries and its implications on scalability. In O’Reilly’s 
www.openp2p.com, February 2001. 
[20] M. Ripeanu, A. Iamnitchi, I. Foster, “Mapping the 
Gnutella Network,” IEEE Internet Computing, Vol. 6, 
Issue 1, pp.50-56, Jan/Feb 2002. 
[21] S. Saroiu, P. K. Gummadi, S. D. Gribble, “A Measure-
ment Study of Peer-to-Peer File Sharing Systems,” 
MMCN, San Jose, CA, USA, January 2002. 
[22] J. Chu, K. Labonte, and B. Levine, ”Availability and 
Locality Measurements of Peer-to-Peer File Systems,” in 
ITCom: Scalability and Traffic Control in IP Networks. 
July 2002, vol. 4868 of Proceedings of SPIE.
[23] V. Kalogeraki, D. Gunopulos, and D. Zeinalipour-Yazti, 
“A local search mechanism for peer-to-peer networks,” 
in Proceedings of the 2002 ACM CIKM International 
Conference on Information and Knowledge Manage-
ment, McLean, Virginia, USA, pp. 300–307, November 
2002. 
[24] Z. Zhuang, Y. Liu, L. Xiao, and L. M. Ni, “Hybrid peri-
odical flooding in unstructured peer-to-peer networks,” 
in Proceedings of the 32nd International Conference on 
Parallel Processing (ICPP’03). Kaohsiung, Taiwan: IEEE 
Computer Society, pp. 171–178, October 2003. 
[25] S. Jiang, L. Guo, X. Zhang, “LightFlood: an efficient 
flooding scheme for file search in unstructured peer-to-
peer systems,” Parallel Processing, 2003. Proceedings. 
2003 International Conference on, pp.627-635, 9-9 Oct. 
2003. 
[26] S. Jiang, L. Guo, X. Zhang, H. Wang, “LightFlood: Mini-
mizing Redundant Messages and Maximizing Scope of 
Peer-to-Peer Search,” IEEE Transactions on Parallel and 
Distributed Systems, vol.19, no.5, pp.601-614, May 2008. 
[27] D. Tsoumakos and N. Roussopoulos, “Adaptive prob-
abilistic search for peer-to-peer networks,” in Proceed-
ings of the 3rd International Conference on Peer-to-Peer 
Computing (P2P’03). Link¨oping, Sweden: IEEE Com-
puter Society, pp. 102–109, September 2003. 
[28] D. Tsoumakos and N. Roussopoulos, “Analysis and 
comparison of P2P search Methods,” Technical Report 
CS-TR-4539, UMIACS-TR-2003-107, Dept. of Computer 
Science, University of Maryland, 2003. 
[29] Y. Chawathe, S. Ratnasamy, L. Breslau, N. Lanham, and 
S. Shenker, “Making gnutella-like p2p systems scalable,” 
in Proceedings of the ACM SIGCOMM 2003 Conference 
on Applications, Technologies, Architectures, and Proto-
cols for Computer Communication. Karlsruhe, Ger-
many: ACM Press, pp. 407–418, August 2003. 
[30] A. Crespo, H. Garcia-Molina, “Routing Indices for peer-
to-peer systems,” in Proc. of the 22nd Conference on 
Distributed Computing Systems, pp. 23-32, July 2002.
[31] B. Yang and H. Garcia-Molina, “Improving Search in 
Peer-to-Peer Networks”, in Proc. of the 22nd Conference 
on Distributed Computing Systems, pp. 5-14, July 2002. 
[32] V. Kalogeraki, D. Gunopulos and D. Zeinalipour-Yazti, 
“A Local Search Mechanism for Peer-to-Peer Networks,” 
in Proceedings of the Eleventh International Conference 
on Information and Knowledge Management, pp. 300-
307, Nov. 2002. 
[33] R. A. Ferreira, M. K. Ramanathan, A. Awan, A. Grama, 
S. Jagannathan, “Search with probabilistic guarantees in 
unstructured peer-to-peer networks,” in Proceedings of 
IEEE P2P'05, Konstanz, Germany, pp. 165-172, August 
2005.
[34] N. Sarshar, P. O. Boykin, V. P. Roychowdhury, “Percola-
tion search in power law networks: making unstructured 
peer-to-peer networks scalable,” in Proceedings of IEEE 
P2P'04, Zurich, Switzerland, pp. 2-9, August 2004.
[35] M. Mihail, A. Saberi, and P. Tetali, “Random walks with 
lookahead in power law random graphs,” Internet 
Mathematics 2006. 
[36] L. A. Adamic, “The small world web,” Proceedings of 
the 3rd European Conf. on Digital Libraries, volume 1696 
of Lecture notes in Computer Science, pp. 443-452. 
Springer, 1999. 
[37] S. Behnel and A. Buchmann, “Models and languages for 
overlay networks,” in Proc. of VLDB Workshop on Da-
tabases, Information Systems and Peer-to -Peer Comput-
ing.
[38] S. Behnel and A. Buchmann, “Overlay networks - im-
plementation by specification,” in Proc. of Middleware 
2005.
[39] W. Aiello, F. Chung, and L. Lu, “A random graph model 
for massive graphs,” Proceedings of the thirty-second 
annual ACM symposium on Theory of Computing, pp. 
 
This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication.
Authorized licensed use limited to: National Taiwan University. Downloaded on October 15, 2008 at 22:19 from IEEE Xplore.  Restrictions apply.
12 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS, TPDS-2008-07-17 
TABLE 2-A 
PERFORMANCE OF FLOODING IN POWER-LAW GRAPHS 
Replication Ratio (R) = 0.01% 
Size 
(N) 
Success rate 
(SR) 
Search Time 
(ST) 
Query Hits 
(QH) 
Query Messages 
(QM) 
Query Efficiency 
(QE1) 
Query Efficiency 
(QE2) 
Search Efficiency 
(SE1) 
Search Efficiency 
(SE2) 
10k 0.99 4.13 1.00 113k 0.088 1.25 0.087 1.24 
50k 0.99 3.57 5.00 997k 0.050 1.13 0.050 
 
1.12 
100k 1.00 3.38 10.00 2561k 0.039 0.88 0.039 0.88 
500k 1.00 3.03 50.00 23M 0.022 0.49 0.022 0.49 
Replication Ratio (R) = 0.1% 
Size 
(N) 
Success rate 
(SR) 
Search Time 
(ST) 
Query Hits 
(QH) 
Query Messages 
(QM) 
Query Efficiency 
(QE1) 
Query Efficiency 
(QE2) 
Search Efficiency 
(SE1) 
Search Efficiency 
(SE2) 
10k 1.00 3.30 9.99 113k 0.088 1.96 0.088 1.96 
50k 1.00 2.88 50.00 997k 0.050 1.13 0.050 1.13 
100k 1.00 2.74 100.00 2560k 0.039 0.88 0.039 0.88 
500k 1.00 2.48 500.00 23M 0.022 0.49 0.022 0.49 
Replication Ratio (R) = 1% 
Size 
(N) 
Success rate 
(SR) 
Search Time 
(ST) 
Query Hits 
(QH) 
Query Messages 
(QM) 
Query Efficiency 
(QE1) 
Query Efficiency 
(QE2) 
Search Efficiency 
(SE1) 
Search Efficiency 
(SE2) 
10k 1.00 2.47 99.94 113k 0.088 1.96 0.088 1.96 
50k 1.00 2.20 500.00 997k 0.050 1.13 0.050 1.13 
100k 1.00 2.10 1K 2561k 0.039 0.88 0.039 0.88 
500k 1.00 1.93 5K 23M 0.022 0.49 0.022 0.49 
 
TABLE 2-B 
PERFORMANCE OF RANDOM WALK IN POWER-LAW GRAPHS 
Replication Ratio (R) = 0.01% 
Size 
(N) 
Success rate 
(SR) 
Search Time 
(ST) 
Query Hits 
(QH) 
Query Messages Query Efficiency 
(QE1) 
Query Efficiency 
(QE2) 
Search Efficiency 
(SE1) (QM) 
Search Efficiency 
(SE2) 
10k 0.0025 23k 0.0025 24.85 1.00 36.00 0.0025 0.09 
50k 0.0028 23k 0.0028 28.18 1.00 35.71 0.0028 0.10 
100k 0.0030 23k 0.0030 29.54 1.00 36.67 0.0030 0.11 
500k 0.0032 23k 0.0033 32.53 1.00 37.50 0.0032 0.12 
Replication Ratio (R) = 0.1% 
Size 
(N) 
Success rate 
(SR) 
Search Time 
(ST) 
Query Hits 
(QH) 
Query Messages 
(QM) 
Query Efficiency 
(QE1) 
Query Efficiency 
(QE2) 
Search Efficiency 
(SE1) 
Search Efficiency 
(SE2) 
10k 0.025 2k 0.025 24.85 1.00 36.40 0.025 0.91 
50k 0.028 2k 0.028 28.18 1.00 36.79 0.028 1.03 
100k 0.029 2k 0.030 29.54 1.00 37.24 0.029 1.08 
500k 0.032 2k 0.033 32.53 1.00 37.19 0.032 1.19 
Replication Ratio (R) = 1% 
Size 
(N) 
Success rate 
(SR) 
Search Time 
(ST) 
Query Hits 
(QH) 
Query Messages 
(QM) 
Query Efficiency 
(QE1) 
Query Efficiency 
(QE2) 
Search Efficiency 
(SE1) 
Search Efficiency 
(SE2) 
10k 0.22 229.11 0.25 24.85 1.00 37.23 0.22 8.19 
50k 0.25 229.11 0.28 28.18 1.00 36.56 0.25 9.14 
100k 0.26 229.11 0.30 29.54 1.00 36.62 0.26 9.52 
500k 0.28 229.11 0.33 32.53 1.00 36.89 0.28 10.33 
 
 
This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication.
Authorized licensed use limited to: National Taiwan University. Downloaded on October 15, 2008 at 22:19 from IEEE Xplore.  Restrictions apply.
