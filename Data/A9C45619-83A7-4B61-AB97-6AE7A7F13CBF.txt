1. Introduction 
The key features of musical perception and composition are rhythm, melody and 
harmony. Rhythm is formed through the alternation of long and short notes, or 
through repetition of strong and weak dynamics. Because one metrical unit, such as a 
measure or a half note, can often be divided into two or three sub-units (as illustrated 
in Figures 1 and 2), this rhythm is endowed with a clear hierarchical structure. To 
express the hierarchical characteristics of rhythm, we need a data structure that 
possesses such a hierarchical nature. Fortunately, the plant kingdom is rich with 
branching structures, in which branches are derived from roots. In fact, the structure 
shown in Figure 1 is that of a binary tree. L-systems (Lindenmayer systems) [9,12,13] 
are designed to model plant development. Therefore, it is natural to construct a 
rhythmic representation by using an L-system. We will show how such a tree structure 
and its related parts can be constructed. In addition to reviewing previous works by 
Loguet-Higgins [10], This paper presents methods that represent rhythms using 
L-systems.  
Figure 1 shows that in each level of a tree a half note is represented by a different 
metrical unit. In the highest level, the metrical unit is a half note; in the next level, the 
unit is a quarter note; in the lowest level, the unit is an eighth note. The total duration 
in each level is equal to a half note. This structure can be extended to a measure or 
more, a composition as shown in Figure 2. 
 
 
 
Figure 1: One metrical can be divided into two or three subunits. 
duration lengths, we usually obtain two unequal length subsequences. This is because 
a note connecting the two subsequences has been split into two submetrical units. The 
preceding portion belongs to the preceding subsequences and the later portion belongs 
to the later subsequence. We will mark those units to identify their subsequences.  
These two subsequences represent two different subtrees of the root node. We further 
divide each subsequence into sub-subsequences, which are also rhythmic trees, and so 
on. This dividing process is completed when a tree node contains a single note 
(possibly one which has been split into two portions). We plot two such trees in 
Figures 2 and 3. The notes shown in Figure 3 are part of the whole tree of the 
beginning of Rachnaminoff’s Piano Concerto No3, Movement 1. The two notes in the 
rectangle have been split using our rhythmic tree process. 
 
 
   Figure 3. Musical tree of Rachmaninoff’s Piano Concerto No.3, Mov. 1. 
 
In the process of generating a rhythmic tree, we use events recorded in MIDI files. A 
MIDI file records events including note on, note off, speed change, footnotes, etc. A 
MIDI file records whenever keys of a keyboard are pressed and whenever they are 
released. Therefore, a note is represented by pressing and then releasing a key. We 
calculate the length of a note by subtracting its pressing time from its releasing time 
and normalize this length based on a unit recorded in the MIDI file header. Then we 
know which type of the note it is, i.e., a half note, quarter note, etc. Usually this length 
is not a multiple of the unit. This is because the input to a keyboard made by a human 
is not always precise.  
We then correct such imprecise length. Based on the unit, we know the shortest length 
of a valid note. Every valid note in the MIDI file must be a multiple of this smallest 
length. Whenever the length is not a multiple of the shortest length, we simply alter it 
positive orientation of angles is counterclockwise.  
  
- Turn right by angle δ. The next state of the turtle is (x, y, α - δ). 
 
For a string composed by the above symbols, the turtle will crawl according to 
commands indicated in a given order. The turtle interpretation of this string is the 
figure drawn by the turtle. To draw branches of a tree, we need two more symbols: 
 
[ Push the current state of the turtle onto a pushdown stack. The information 
saved on the stack contains the turtle’s position and orientation, and 
possibly other attributes, such as the color and width of the lines being 
drawn. 
  
] Pop a state from the stack and make it the current state of the turtle. No 
line is drawn although, in general, the position of the turtle changes. 
 
Figure 4: Using a bracketed L-system to represent and generate trees. 
(a): A tree represented by a bracketed string. (b) A tree generated by a bracketed 
L-system.  (c) Another tree generated by a bracketed L-system. 
 
These two symbols enable the turtle to go back to the root after drawing a branch so 
that it can draw other branches originating from the same root. This kind of L-system 
is called the bracketed L-system, and we call strings that represent trees bracketed 
strings. Figure 4 illustrates the bracketed string representation of an axial tree. 
2.2 Rewriting rules for rhythmic trees 
In music, a longer metrical unit can be replaced by the combination of several shorter 
Figure 6: Using rewriting rules to represent a rhythmic tree. 
 
 In Figure 6, LL denotes the left subtree’s left subtree, and RL denotes the right 
subtree’s left subtree. RRL and RRR are similar. Thus, the rewriting rules for the tree 
shown in Figure 6 are P Æ LL LR RL RRL RRR. 
2.3 Bracketed strings for a rhythmic tree 
 
Figure 7: Bracketed strings for two trees. 
As discussed above, bracketed strings can represent a hierarchical structure, such as 
an axial tree. Thus, bracketed strings may provide a suitable data structure for 
representing rhythm. We know that a half note can be divided into two quarter notes, 
and this fact can be represented by a tree structure, which has a parent node and two 
child nodes, as shown in Figure 7 (a). The bracketed string of the half note and its 
binary branches in Figure 7 (a) are F[+F][-F]: the first F is the command for tracing 
the root; [+F] is the command for tracing the right branch, and [-F] is the command 
for tracing the left branch. In Figure 7 (b), there is another example for a dotted half 
note. We will not discuss the bracketed string for the music notes [8] in this work. 
 
Figure 8: Bracketed String for Beethoven’s Piano Sonata No 6, Mov. 3 
 
Since we focus here only on rhythmic trees, we can simplify the bracketed string 
representations. First, our rhythmic trees have only 2 subtrees. Second, the ‘F’ 
notation for a rhythmic tree is trivial. With these two characteristics, we may omit the 
 
PÆ[-FL][+FR], 
LÆ …, 
RÆ ….,  
 
where ‘…’ is the rewriting rule for the bracketed string of each subtree. In this way, 
we do not have to write L for a left subtree and R for a right subtree; the orientation is 
already described in the bracketed string ‘-F’ and ‘+F’. Thus, we do not have to write 
words such as ‘RRL’, ‘RRR’, etc. Of course, we may still use such recursive subscript 
representations for rules for the sake of readability. In Figure 11, we show the 
rewriting rules for the bracketed string of the tree shown in Figure 6. 
 
PÆ[-FTL][+F TR] 
TLÆ[-F TLL][+F TLR] 
TRÆ[-F TRL][+F TRR] 
TRRÆ[-F TRRL][+F TRRR]
 
TLLÆ null, 
TLRÆ null, 
TRLÆ null, 
TRRLÆ null, 
TRRRÆ null. 
Figure 11: Rewriting rules for the bracketed string of a rhythmic tree. 
 
There are “nulls” in the rules. We use “null” to represent a terminal (or a tree node 
that doesn’t have any child subtree). For such null-subtree rewriting rules we simply 
ignore the nulls. The new rewriting rules without trivial nulls are as follows: 
 
PÆ[-FTL][+F TR], 
TLÆ[-F][+F], 
TRÆ[-F][+F TRR], 
TRRÆ[-F][+F]. 
 
Note that there are two identical rules in the above rewriting rules: TL and TRR. This 
redundancy raises a question: Can we combine them to simplify these rules? Doing so 
will not harm the whole structure if the redundant rules contain only null subtrees. We 
will show in the following what will happen if the rules do not contain only null 
subtrees. Assume that we have the following rules:  
  
Figure 12: Rhythmic tree. 
Here, we will use an example to clarify these definitions. In Figure 12, we name the 
tree rooted at A, B, C, and D, respectively, tree A, tree B, tree C, and tree D. Tree A is 
homomorphic to tree B and tree C, but tree A is not isomorphic to tree D. Tree A is 
isomorphic to tree C on depth 2, but they are not isomorphic on depth 3. Tree B is 
isomorphic to tree C on depth 0 and 1, but not on depth 2. D is not isomorphic to any 
other trees, nor is it homomorphic to any other trees. 
By using bracketed strings, we can obtain a much clearer definition of 
homomorphism. All homomorphic rewriting rules generate the same bracketed strings 
when all nonterminals are ignored. Using the following rewriting rules, we find that P 
and TL are homomorphic because if TL and TR are ignored, they generate exactly the 
same bracketed string, [-F][+F]. We also find that P and TRR are homomorphic 
because if TRRR, TL and TR are ignored, they generate the same bracketed string, 
[-F][+F]: 
 
PÆ[-FTL][+F TR], 
TLÆ[-F][+F], 
TRÆ[-F][+F TRR], 
TRRÆ[-F][+F TRRR], 
TRRRÆ[-F][+F]. 
 
In fact, in this example, all five rewriting rules are homomorphic to each other. But if 
we add a sixth rule, TRRRRÆ[-F], then it will not be homomorphic to any of the other 
rules. 
Once we define the similarity between rules, we can classify all the rules in the set 
into different subsets based on their similarity. Rules that belong to a class are all 
isomorphic to each other on depth X. All the rules’ names are replaced with the names 
of the classes to which the rewriting rules belong. After such name conversion, every 
new rewriting rule represents more rhythmic trees than it was. These new rewriting 
rules set can now generate new rhythmic trees, including the original one. 
(22) C8Æ null
Class #9    (1) C9Æ C5 C7 
Class #10    terminal 
(22) C10Æ null 
 Table (b): Classifying based on the similarity of a rewriting rules set. 
 
 
4. Rhythmic complexity 
After we list the rewriting rules for a rhythmic tree and classify all those rules, we 
attempt to explore the redundancy in the tree (or the hidden structure in the beats) that 
might be the base for building the cognitive map [2,3]. We then compute the 
complexity of the tree which those classified abstract rules represent. We know that a 
classified rewriting rule set is also a context free grammar, so we can define the 
complexity of a rewriting rule set as follows: 
 
DEFINE: Topological entropy of a Context Free Grammar [6,1]. 
The topological entropy Ko  of a CFG (Context Free Grammar) can be evaluated by 
means of the following procedure: 
 
(1) For each variable iV  with productions (in the Greibach form), 
ii ikikiiiii
UtUtUtV ,,, 2211 K→ , 
where { 1it , 2it , ... iikt } are terminals and { 1iU , 2iU ,… iikU } are non-terminals. The 
formal algebraic expression for each variable is 
 
∑
=
= i
k
j
ijiji UtV
1
. 
 
(2) By replacing every terminal ijt  with an auxiliary variable z, one obtains the 
generating function  
 
                   ∑∞
=
=
1
)()(
n
n
ii znNzV , 
where )(nNi is the number of words of length n descending from iV . 
 
the root node of the rhythmic tree. After obtaining the largest value, maxz , of )(1 zV , 
we set maxzR = , the radius of convergence of )(1 zV . We define the complexity of 
the rhythmic tree as RKo ln−= . 
We use the simple example in Table (b) for the depth 1 to show the computation 
procedure of the complexity. According to our definition the given values for the class 
parameters are ,1n,2,n3,n1,n1,n1,n ,1n,4n,5{n 13121154321 =========  
}. 3a 2,a
 5,a 5,a  4,a 5,a  5,a 4,a  2,a 4,a 4,a
2,a  3,a 2,a  1,a  1,a  22,n8,n  , 2n  ,4n  1,
512511
412411312311212211142141132
1311221211121115141312114
==
=========
==========n
Substituting these values in the above equation, we obtain 1)'(5 =zV  and 
')'(4 zzV =  directly. Then we obtain the formulas for )(3 zV , )(2 zV , and )(1 zV  
successively. They are 
=)'(3 zV ,'2/))'()'(2(')/)'()'('( 245
1
3
1
3
33
2313
zzVzVznzVzVzn
n
q
q
n
p
aap pp
=×××=∑∑
==  
and ,'4/))'()'(4(')/)'()'('()'( 254
1
2
1
22
22
2212
zzVzVznzVzVznzV
n
q
q
n
p
aap pp
=×××== ∑∑
==    
7/))'()'(1)'()'(1)'()'(2)'(3('
)/)'()'('()'(
244232
2
1
1
1
1
11
11
2111
zVzVzVzVzVzVzVz
nzVzVznzV
n
q
q
n
p
aap pp
××+××+××+××=
= ∑∑
==
 
.7/)'2'2)'('3( 4521 zzzVz ×+×+×=  
Rearranging the above equation for )(1 zV , we obtain a quadratic equation for )'(1 zV  
0)''(
7
2)'()'('
7
3 45
1
2
1 =++− zzzVzVz . 
Solving )'(1 zV , we obtain 
7
'6
)''(
49
2411
)'(
56
1 z
zz
zV
+−±
= . 
The following inequality must hold for the convergence of )'(1 zV ,  
0)''(
49
241 56 ≥+− zz  or 0037562.1'≤z =R. 
Hence the radius of convergence R is 1.0037562. The complexity is obtained by 
calculating Ko , where 003749.00037562.1lnln −=−=−= RKo . Thus, the 
complexity for the rule set in Table (b) depth 1 is –0.003749. 
 
Now we will present a practical example. We will use Beethoven’s Piano Sonatas 
Nos. 1 to 32 and Mozart’s Piano Sonatas Nos. 1 to 19 as an example, and show their 
complexity, Ko . We list the complexity of each piano sonata by Beethoven and 
Mozart in Figures 13-18. In these figures, we use three different isomorphic depths, 1, 
2, and 3, to compute the complexity. From the figures we can see that the complexity 
is high for both musicians. When we use higher depth isomorphism to classify rules, 
the complexity will decrease. This is because when we use higher depth isomorphism, 
redundancy between rules will decrease so the complexity will also decrease. 
Eventually the complexity will decrease to zero for the highest depth isomorphism. 
Conversely, lower depth isomorphism brings more rules in a class; redundancy 
between rules will increase and the number of classes will decrease. If the depth of 
isomorphism is too low, the rules set will become too simple. We may compute the 
complexity for different depths to see the differences. In the Figures 14 and 17, the 
complexity for depth 2 isomorphism is the highest. 
 
Figure 13: Beethoven’s 32 Piano Sonatas, using isomorphic depth 1. 
 
 
  
Figure 16: Mozart’s 19 Piano Sonatas, using isomorphic depth 1. 
 
 
 
 
 
 
Figure 17: Mozart’s 19 Piano Sonatas, using isomorphic depth 2. 
 
 
 
 
 
 
we have defined homomorphism and isomorphism so as to characterize the similarity 
between sections of different rhythmic trees as the redundancy of the cognitive map. 
But there still exist questions about the psychological implications of these 
characteristics, such as the depth of isomorphism. The proposed procedure might 
enable us to measure the psychological complexity (Feldman 2000) of rhythms. In our 
studies, we have found that different depths of isomorphism produce various degrees 
of complexity. If a rhythm is very simple, its complexity will be 0. The same situation 
also occurred when we used isomorphism with a very high depth value to compute the 
complexity of Mozart’s and Beethoven’s piano sonatas. In general, the results may 
confirm our intuition about these musical rhythms.  
In Figure 19, we plot a new rhythmic tree and its corresponding beat sequence 
generated using a classified rewriting rules set for our previous example, 
Rachmaninoff’s Piano Concerto No.3, Mov.1, shown in Figure 3.  
 
Figure 19, New rhythmic tree generated using the rules set shown in Figure 3. 
 
Finally, we tested a well-known musical work studied by Rauscher et al. [14]. Almost 
all the previous studies on the Mozart Effect have focused on a single piece of music, 
the Sonata for Two Pianos in D Major (K448). We have computed its complexity and 
found that it is generally higher than that of other sonatas by Mozart (see Figures 
16-18). The complexity of Mov.1 for isomorphism on depth 1 is 2.057585, for that on 
depth 2 is 2.542099, and for that on depth 3 is 2.724485. 
 
References 
[1] Badii, R. and Politi, A. (1997). Complexity, Hierarchical structures and scaling in 
physics. Cambridge University Press.  
 
