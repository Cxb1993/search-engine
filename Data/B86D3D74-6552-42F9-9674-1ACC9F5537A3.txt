 2
ing patterns and stochastic rules in biological se-
quences. They are best suited to problems that involve 
classifying sequences of observations or classifying 
observations within a sequence. Thus we propose in 
our project ways of efficiently calculating and obtain-
ing the posterior probabilities of sequence models lo-
cated within a given target sequence; the methods and 
programming package deduced from the project shall 
clearly help adding explicit understandings for the bi-
ological sequence analyzers. Some of our results in the 
project have been published in [21, 22, 23]. 
Keywords: Hidden Markov Model (HMM), profile 
HMM, biological sequence analysis, classification, 
posterior probability. 
 
二、緣由與目的 
 
Building a Haplotype Map of the human genome 
has become a central NIH promoted goal [15]. The in-
ternational Haplotype Map Project is focussed on de-
termining the common SNP haplotypes in several di-
verse human populations. It is widely expected that the 
relation between specific haplotypes and genotypes 
(such as certain disease) will allow the rapid location 
of gene that influence those disease. However, col-
lecting genotypes is cheaper and easier than collecting 
haplotypes. So it is the main approach that collecting 
genotype data and computationally inferring to haplo-
type data pairs. 
 
2.1 SNP, Genotype, Haplotype 
 
Mutation in DNA is the principle factor that is 
responsible for the phenotypic differences among 
human beings, and SNPs (single nucleotide 
polymorphisms) are the most common mutations. A 
SNP is defined as a position in a chromosome where 
each one of two (or more) specific nucleotides is 
observed in at least 10% of the population [18]. The 
nucleotides involved in a SNP are called alleles. 
In diploid organisms, such as human, there are two 
"copies" of each chromosome. A description of the 
data from a single cope is called a haplotype, and 
the mixed data on the two copies is called a geno-
type. In complex disease (affected by more than single 
gene,) it is more informative to have haplotype data 
than to have genotype data. On the other hand, it is 
not feasible to examine the two haplotypes separately 
in general, and genotype data rather than haplotype 
data is usually obtained. Computational methods for 
inference of haplotype information from the observed 
genotype data are thus highly demanding in the current 
trend of computational biology. 
We represent each of n genotypes as a vector, each 
with m site, where each value in a site is either 0,1 or 
2. A site i in genotype vector g has a value 0 (respec-
tively 1) if site i has value 0 (respectively 1) on both 
the underlying haplotypes (homozygous site), and has 
value 2 otherwise (heterozygous site). 
2.2 The Phylogenetic Networks 
 
Despite the existence of many well-studied effi-
cient algorithms [9, 1, 5, 4] for inferring the (perfect) 
phylogenetic tree haplotype information, the growth 
of genetic data reveals that much haplotyped (SNP) 
sequences do not fit the evolutionary tree (coalescent) 
models. A phylogenic network is a generalization of 
a phylogenetic tree, allowing structural properties that 
are not tree-like. In the phylogenetic networks, recom-
bination is an important situation between the evolu-
tion. It means a chimeric sequence derived by com-
bining another two gene sequences. In populations 
it is the key element underlying techniques that are 
widely hoped to locate genes influencing genetic dis-
eases. In graph theory, it can be represented as an 
cycle in a undirect graph. The phylogenetic network 
problem (with recombination) was introduced by Hein 
[13, 14]. The goal is to construct a phylogenetic net-
work that derives a given set of binary sequences with 
minimizing the number of recombinations used. The 
minimization criterion is motivated by the general utility 
of parsimony in biological problems, and because most 
evolutionary histories are thought to contain a small 
number of observable recombinations [10]. Un-
fortunately, the problem is shown to be NP-hard [19]. 
In a phylogenic network, there are four compo-
nents needed to specify: a directed acyclic graph, an 
assignment of sites on edges, an assignment of a se-
quence to each non-recombination, an assignment of 
a recombination point, and a sequence to each recom-
bination node. Figure 1 is an example for a phylo-
genetic network. The phylogenetic network generated 
by a matrix M[n, m] is shown at the right. There are 
exactly n nodes without incoming edges. Each node 
except root has either one or two incoming edges. A 
node with two incoming edges is call a "recombina-
tion node". There are two labels P and S on the in-
coming edges of recombination node; P means the 
"prefix" and S means the "suffix" to the recombination 
sequence, and the number on the recombination node 
means the site of sequence that recombined. 
The recombination events have some special or 
important biological meaning, and also are the req-
uisite role in evolution of species. In this paper, we 
propose some algorithms to reconstruct the recombi-
nation sequences and the phylogenetic networks. First, 
we use the linear time algorithm proposed by Gusfield 
[4] to construct the perfect phylogeny tree, and then 
add the recombination sequences derived by our algo-
rithms to form a phylogeny network. Given the bi-
ologically specified weights, the algorithm distinguish 
more important or meaningful sequences from the others; 
thus higher weighted sequences are considered as 
higher priority in processing the genotype matrix. The 
proposed phylogenetic network inference algorithms 
thus generate results that reflects these priorities. 
 
 4
 
 
Figure 1: A phylogenetic Network with Two Recombination Nodes 
 
Figure 2: x is a recombination node, and we use a dotted line to represent the recombination. In type C1, site i and 
j mutate separately and recombine the sequence 1,1. In type C2, site j mutates before i does, the recombination 
sequence is 1,0. And in type C3, site i mutates before j, the recombination sequence is 0,1 
first row containing the rightmost 1-entry in M. Ac-
cording to the arrangement of M, LPPH algorithm can 
construct a larger shadow tree. The means of "larger" 
is more rows in M could be processed and the shape 
of shadow tree is larger. 
In the course of processing the genotype matrix M 
containing the recombination sequences, LPPH algo-
rithm stops at certain point and report a recombination 
occurred in the evolution history. The condition of 
recombination can be checked by the method, called 
three-gamete test. If any two columns i, j in 
haplo-type sequences contain three rows with the pair 
(1,0), (0,1), and (1,1), then the two columns are called 
conflict. The sequences containing conflict pairs imply 
recombination events. There are three cases of recombi-
nation, as illustrated in Figure 2. 
Theorem 1 Two sites i and j (j > i) is a conflict pair. 
There will be three recombination types in the phylo-
genetic networks. 
Note that the algorithm arrange the matrix M be-
fore peforming the LPPH algorithm; it follows that 
more useful sequences are processed (as coalescent se-
quences) earlier. If the recombination occurred, less 
important sequence would be detected and the 
algorithm stopped. So we can get a recombination se-
quence by executing the LPPH once, and this sequence is 
useless or less important than the other two sequences. 
We use a structure call "conflict table" to record all 
sequences and construct the recombination sequences 
in the following steps. 
 
 6
 
 
Figure 3: The Phylogenetic Network Algorithm 
 
 
Figure 4: The Conflict Table Algorithm. 
 
 
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
1110
0110
0011
1100
:
D
C
B
A
M  
 
Sequence C is conflicted with A and B on sites pair 
(2,3), and sequence B is conflict with A and D on 
(1,3) or (2,3). In LPPH, B and C sequences are 
determined as the recombination sequences; however, 
other different possibilities exist. For example, if the 
priority of these four sequences is D, A, B, C. By 
processing the sequences according the priority, the 
sequence B will be determined a recombination se-
quence, but the next sequence C is allowed. 
Although the LPPH algorithm can determine the 
more important sequences A and D, but the number of 
non-recombination sequences is less than the priority 
method. The method retains the meaningful sequences 
and determines the recombination sequences which 
conflicted with these sequences. 
 
 
Table 3 
 
3.7 The Phylogenetic Network Algorithm with 
Priority Sequences 
 
In the line 1 to 3 of phylogenetic network 
algorithm with priority sequences shown in Figure 5, 
we add the weight of priority for each sequence and 
arrange the matrix M with priority. The priority may 
be the meaning of biology or the relationship for some 
special disease or populations. Then, the following 
steps are the same with the PN algorithm. In this 
algorithm, the more important sequences would be 
proceeded by LPPH earlier, relatively the chance to be 
retained is higher than others. 
 8
history of sequences subject to recombination. J. 
Mol. Evol, 36:396-405, 1993. 
15. L. Helmuth. Genome research: Map of the human 
genome 3.0. Science, 293(5530):583-585, 2001. 
16. R. Hudson. Gene genealogies and the coalescent 
process. Oxford Survey of Evolutionary Biology, 
7:1-44, 1990. 
17. G. Kimmel and R. Shamir. The incomplete perfect 
phylogeny gaplotype problem. In Proceedings of 
the second RECOMB Satellite Workshop on 
Computational Method for SNPs and Haplotypes, 
Pittsburg, USA, Feburary 20-21 2004. 
18. N. Patil, A. J. Berno, D. A. Hinds, et al. Blocks 
of limited haplotype diversity revealed by high 
resolution scanning of human chromosome 21. 
Science 294:1719-1723 2001. 
19. L. Wang, K. Zhang, and L. Zhang. Perfect 
phylogenetic networks with recombination. 
Journal of Computational Biology, 8:69-78, 2001. 
20. C. Wiuf. Inference on recombination and block 
structure using unphased data. Genetics, 
166(1):537-545, January 2004. 
21. Chiou-Nan Chen, Kuan-Ching Li, Chuan Yi Tang, 
Yaw-Ling Lin,, Hsiao-Hsi Wang, Tsung-Ying Wu, 
"On Design and Implementation of a 
Bioinformatics Portal in Cluster and Grid 
Environments," The 7th International Meeting on 
High Performance Computing for Computational 
Science (VECPAR'2006),  pp 44-57, Rio de 
Janeiro, Brazil, July 10-12, 2006. 
22. Yaw-Ling Lin, Wei-Shun Su, Tso-Ching Lee. 
"Identifying Long Haplotype Blocks with Low 
Diversity," Proceedings of the 23rd Workshop on 
Combinatorial Mathematics and Computation 
Theory, pp 151-159, Chang-Hua, Taiwan, April 
28-29, 2006. 
23. Wei-Shun Su, Tso-Ching Lee, Yaw-Ling Lin, 
National Computer Symposium (NCS'2005), 
Efficient Algorithms for Constructing Phylogenetic 
Networks with Restricted Recombinations, pp 1-7 
(BIB1;BI5), Tainan, Taiwan, December 15-16, 
2005. (ISBN 986-81480-2-2). 
phylogenetic tree haplotype information, the growth
of genetic data reveals that much haplotyped (SNP)
sequences do not fit the evolutionary tree (coalescent)
models. A phylogenic network is a generalization of
a phylogenetic tree, allowing structural properties that
are not tree-like. In the phylogenetic networks, recom-
bination is an important situation between the evolu-
tion. It means a chimeric sequence derived by com-
bining another two gene sequences. In populations
it is the key element underlying techniques that are
widely hoped to locate genes influencing genetic dis-
eases. In graph theory, it can be represented as an
cycle in a undirect graph. The phylogenetic network
problem (with recombination) was introduced by Hein
[13, 14]. The goal is to construct a phylogenetic net-
work that derives a given set of binary sequences with
minimizing the number of recombinations used. The
minimization criterion is motivated by the general util-
ity of parsimony in biological problems, and because
most evolutionary histories are thought to contain a
small number of observable recombinations [10]. Un-
fortunately, the problem is shown to be NP-hard [19].
In a phylogenic network, there are four compo-
nents needed to specify: a directed acyclic graph, an
assignment of sites on edges, an assignment of a se-
quence to each non-recombination, an assignment of
a recombination point, and a sequence to each recom-
bination node. Figure 1 is an example for a phylo-
genetic network. The phylogenetic network generated
by a matrix M [n,m] is shown at the right. There are
exactly n nodes without incoming edges. Each node
except root has either one or two incoming edges. A
node with two incoming edges is call a “recombina-
tion node”. There are two labels P and S on the in-
coming edges of recombination node; P means the
“prefix” and S means the “suffix” to the recombina-
tion sequence, and the number on the recombination
node means the site of sequence that recombined.
The recombination events have some special or
important biological meaning, and also are the req-
uisite role in evolution of species. In this paper, we
propose some algorithms to reconstruct the recombi-
nation sequences and the phylogenetic networks. First,
we use the linear time algorithm proposed by Gusfield
[4] to construct the perfect phylogeny tree, and then
add the recombination sequences derived by our algo-
rithms to form a phylogeny network. Given the bi-
ologically specified weights, the algorithm distinguish
more important or meaningful sequences from the oth-
ers; thus higher weighted sequences are considered as
higher priority in processing the genotype matrix. The
proposed phylogenetic network inference algorithms
thus generate results that reflects these priorities.
3 The Linear-Time Perfect Phylogeny
Haplotyping Algorithm (LPPH)
Given an input set of n genotype vectors of length
m, the Haplotyping Inference (HI) problem is to find
2n binary haplotype vectors such that these n geno-
types can be generated by the associated pairs of hap-
lotype vectors. This would be impossible without the
implicit or explicit use of some genetic model, either
to assess the biological fidelity of any proposed solu-
tion, or to guide the algorithm in constructing a so-
lution. The most powerful such genetic model is the
population-genetic concept of a coalescent [20, 16].
The coalescent model is an evolution history of 2n
haplotypes without recombination; it can be viewed
as a rooted tree with 2n leaves, and each of the m sites
labels exactly one edge on the tree. In computer sci-
ence terminology, the coalescent model says that the
2n haplotypes fit a perfect phylogeny.
The PPH problem was introduced in [9] with a
solution whose running time is O(nmα(nm)). The
nearly linear time algorithm is based on the linear-time
reduction of the PPH problem to the graph realization
problem. But the graph realization problem is some
what complicate resulting a PPH algorithm hard to un-
derstand and implement. In [9], it is conjectured that
the real linear-time algorithm to PPH problem should
be possible.
Another two slower and easier methods in [1, 5]
were based on “conflict-pairs” rather than graph mod-
els. The running time of both methods are O(nm2).
Related research has examined extensions, modifica-
tions or specializations of the PPH Problem [2, 3,
6, 11, 17], or examined the problem when the data
or solutions are assumed to have some special form
[12, 8, 7].
Recently, a really linear-time algorithm for PPH
problem was proposed in [4]. The algorithm makes no
assumptions about the form of data or the solution. It
is based on a directed, rooted graph, called “shadow
tree”. The algorithm uses some standard operations
which could be executed rapidly to ensure the prop-
erties of the shadow tree. Furthermore, the algorithm
has been fully implemented. The method provides an
implicit representation of all the PPH solutions. The
value of a linear-time algorithm for the PPH problem
is partly conceptual and partly for use in the inner-
loop of algorithm for more complex problem, where
the PPH problem must be solved repeatedly.
3.1 The Shadow Tree
The shadow tree is a kind of data structure which can
express distinct PPH solutions by flipping the class.
In shadow tree, there are two types of edges: tree
edge and shadow edge, which are both directed to-
wards to root. The tree and shadow edges are labelled
by columns from the genotype matrix M (with the
2
00
ji
x
P S
10 01
11
00
j
i
P
S
x
01
10
11
00
S
P
j
i
11
01
10
x
C1 C2 C3
Figure 2: x is a recombination node, and we use a dotted line to represent the recombination. In type C1, site i and
j mutate separately and recombine the sequence 1, 1. In type C2, site j mutates before i does, the recombination
sequence is 1, 0. And in type C3, site i mutates before j, the recombination sequence is 0, 1
(0, 1), and (1, 1), then the two columns are called con-
flict. The sequences containing conflict pairs imply re-
combination events. There are three cases of recombi-
nation, as illustrated in Figure 2.
Theorem 1 Two sites i and j (j > i) is a conflict pair.
There will be three recombination types in the phylo-
genetic networks.
Note that the algorithm arrange the matrix M be-
fore peforming the LPPH algorithm; it follows that
more useful sequences are processed (as coalescent se-
quences) earlier. If the recombination occurred, less
important sequence would be detected and the algo-
rithm stopped. So we can get a recombination se-
quence by executing the LPPH once, and this sequence
is useless or less important than the other two se-
quences. We use a structure call “conflict table” to
record all sequences and construct the recombination
sequences in the following steps.
4.1 Conflict Table
The conflict table CT is maintained as a two dimen-
sional array such that each entry is a conflict link. The
rows of CT are indexed by three kinds of conflict
pairs: (0, 1), (1, 0), and (1, 1). Each column of CT
is indexed by each pair of (i, j)-sites within the SNP
sequences for each 1 < i < j < m. Each value in
CT is a link list to the row numbers of haplotype se-
quences. As an example, suppose the given haplotype
matrix M is represented as the following.
M :
[
100
010
]
It follows that the corresponding conflict table for M
is the following
CT(M) (1,2) (2,3) (1,3)
10 1 2 1
01 2 0 0
11 0 0 0
Table 1
Note that the entries in CT are the linked list of row
numbers. If certain recombination sequence add in
CT , it must causes all values of certain column of CT
are greater than 0. We put the column numbers into
a set of recombination site, called “RS”. The recom-
bination sequence can be construct by most |RS| − 1
recombing. For example, if the third row 110 added
in M , it cause the recombination occurred. The table
CT (M) become:
CT(M) (1,2) (2,3) (1,3)
10 1 2,3 1,3
01 2 0 0
11 3 0 0
Table 2
In column 1, the values of three rows are all greater
than 0, the column pair is added into RS; thus RS =
{1, 2}. The sequence of row 3 of M can be derived
by recombing the two arbitrary sequences of column
1 and row 1, 2 of CT . The LPPH algorithm stops
when it encounters a recombination sequence; so we
know which sequence is derived by recombing. We
can delete this sequence fromM , and restart the LPPH
algorithm. Finally, a shadow tree for matrix M \R can
be constructed, where R is the set of recombination
sequences. We use LPPH algorithm to select recom-
bination sequences, and the conflict table to construct
these sequences; until finally produce a phylogenetic
network after linking these recombined sequences on
the initial perfect phylogeny tree derived by LPPH. It
4
2nd sequences at site 1, 2. Finally, add rs into matrix
H and return the sequences matrix H .
In the phylogenetic network algorithm, we use
LPPH algorithm to construct the sequences with no
recombination and determine the recombination se-
quences. Then use the conflict table to determine the
sequences and site which recombination occurred and
reconstruct the recombination sequences.
5 The Priority Sequences
It is possible to associate each sequence of the
given genomic data with a weight as an indication
of the biological importance, probability of coales-
cent (non-recombinant,) or reliability of each obtained
genotype sequence. These factors can be useful and
considered in the construction of haplotype inference.
Thus we can arrange the genotype matrixM by adding
the priority of each row, and arrange M by decreasing
the priority, with the highest priority sequence on the
first row. Then process one row at a time, start at first
row. This method can avoid the important sequences
be removed form M . For an example, we consider
four sequences in a genotype matrix M . The order of
processing of LPPH algorithm is A,B,C,D, respec-
tively, as shown in the following.
M :
A
B
C
D

1100
0011
0110
1110

Sequence C is conflicted with A and B on sites pair
(2, 3), and sequence B is conflict with A and D on
(1, 3) or (2, 3). In LPPH, B and C sequences are
determined as the recombination sequences; however,
other different possibilities exist. For example, if the
priority of these four sequences is D,A,B,C. By
processing the sequences according the priority, the
sequence B will be determined a recombination se-
quence, but the next sequence C is allowed.
LPPH Priority
non-recombination A,D A,C,D
recombination B,C B
Table 3
Although the LPPH algorithm can determine the more
important sequences A and D, but the number of
non-recombination sequences is less than the prior-
ity method. The method retains the meaningful se-
quences and determines the recombination sequences
which conflicted with these sequences.
5.1 The Phylogenetic Network Algo-
rithm with Priority Sequences
In the line 1 to 3 of phylogenetic network algorithm
with priority sequences shown in Figure 5, we add
the weight of priority for each sequence and arrange
the matrix M with priority. The priority may be the
meaning of biology or the relationship for some spe-
cial disease or populations. Then, the following steps
are the same with the PN algorithm. In this algorithm,
the more important sequences would be proceeded by
LPPH earlier, relatively the chance to be retained is
higher than others.
6 Conclusion and Further Work
In this paper we propose phylogenetic network in-
ference algorithm by using the LPPH algorithm to
determine a maximal non-recombinant phylogenetic
sequences in building a perfect phylogenetic tree as
the base case. In producing the shadow tree corre-
sponded to genotype matrix, it can also determine se-
quences that is constituted through the recombination
event. We can use the conflict table to find the se-
quences and sites causing recombination and construct
the recombination sequence, and the time complexity
is O(mn2 + m2n). As a variant of our phylogen-
tic network algorithm, our algorithm also deals with
sequences with different weights that reflect different
meaning or information, importance, or reliability. In
such case, we consider priorities of sequences and re-
tain the most sequences in the course of computing.
Most of common genetic related diseases are
caused by more than one gene. The distance between
PSPN(M)
Input: The genotype matrix M .
Output: The haplotype sequences H .
1 for each row i ∈M do
2 Add the weight of priority or importance on row i
3 Sort the matrix M by decreasing the degree of priority
4 H ← PN(M,∅)
5 return H
Figure 5: The Phylogenetic Network Algorithm with Priority Sequences.
6
Identifying Long Haplotype Blocks with Low
Diversity
Yaw-Ling Lin∗ Wei-Shun Su Tso-Ching Lee†
Dept. Computer Science and Information Engineering
Providence University, Taiwan
E-mail: yllin@pu.edu.tw,g9371011@cs.pu.edu.tw,tclee@vghtc.gov.tw
Abstract.
Given an m×n haplotype matrix A, we show
linear time algorithms for finding all inter-
val diversities, farthest sites, and the longest
block with low diversity.
For selecting the multiple long blocks with
diversity constraint, we show that selecting
k blocks with longest total length can be
be found in O(nk). We also propose lin-
ear time algorithms in calculating the all
intra-longest-blocks and all intra-k-longest-
blocks. For dealing with missing SNP data,
we propose methods that clarifies ambigu-
ous SNP sites; furthermore, we show some
hardness result concerning the minimum di-
versity problem.
Keywords: algorithm, SNP, haplotype, di-
versity, haplotype block selection, missing
data.
1 Introduction
Mutation in DNA is the principle factor that is re-
sponsible for the phenotypic differences among hu-
man beings, and SNPs (single nucleotide polymor-
phisms) are the most common mutations, hence it
is fundamental to complete a map of all SNPs in
the human population. For this purpose a SNP is
defined as a position in a chromosome where each
one of two (or more) specific nucleotides are ob-
served in at least 10% of the population [15]. The
nucleotides involved in a SNP are called alleles. It
has been observed that for almost all SNPs only
∗This work is partly supported by grants from the
Taichung Veterans General Hospital and Providence Uni-
versity (PU-94-11110-516203-001-001) and by the National
Science Council (NSC-94-2213-E-126-003) Taiwan, Repub-
lic of China.
†Taichung Veterans General Hospital. 160, Sec. 3,
Taichung Kang Road, Taichung, Taiwan 407.
two different alleles are present, in such case the
SNP is said biallelic, otherwise the SNP is said
multiallelic. In this paper, we will consider exclu-
sively biallelic SNPs.
In diploid organisms, such as humans, each
chromosome is made of two distinct copies and
each copy is called a haplotype. It is known that
exactly one haplotype is inherited from the father
and the other is from the mother. More precisely,
in the absence of recombinations events, each hap-
lotype in a child is identical to one of the two hap-
lotypes of each parent. Whenever recombinations
occur, a haplotype of the child may consists of por-
tions of both haplotypes of a parent. A current
high-priority phase of human genomics involves
the development of a full Haplotype Map of the
human genome [11].
There is currently a great deal of interest in
how the recombination rate varies over the human
genome. The primary reason for this is the ex-
citement about using linkage disequilibrium (LD)
to map and identify human disease genes. LD
mapping (also known as ”association mapping”)
differs from traditional linkage mapping methods
in that marker-disease associations are sought in
populations of unrelated individuals. Such associ-
ations reflect the long evolutionary history of the
chromosomal region (or the entire genome, in case
of genome-wide screens), involving recombination,
mutation, demographic events, and (perhaps most
importantly) random reproductive success. The
blocks of LD are regions, typically less than 100
kb, in which LD decreases very little with distance
between markers. Between these blocks, however,
LD is observed to decay rapidly with physical dis-
tance. Concomitant with the blocks of LD, these
studies also find low haplotype diversity within
blocks. Often, more than 90% of the chromosomes
in a sample possess one of only two to five haplo-
types within a block [3, 16, 15, 6, 4]. These re-
~151~
The 23rd Workshop on Combinatorial Mathematics and Computation Theory
Terminology and Problem Definition
Abstractly, input to the haplotype blocking prob-
lem consists of m haplotype vectors. Each position
in a vector is associated with a site of interest on
the chromosome. Usually, the position in the hap-
lotype vector has a value of 0 if it is the major
allele or 1 if minor allele.
Let the haplotype matrix A be an m×n matrix
of m observations over n markers (sites). We re-
fer to the jth allele of observation i by Aij . For
simplicity, we first assume that Aij ∈ {0, 1}. A
block, or marker interval, [j, k] = 〈j, j + 1, . . . , k〉
is defined by two marker indices 1 ≤ j ≤ k ≤ n.
A segmentation is a set of non-overlapping non-
empty marker intervals. A segmentation is full if
the union of the intervals is [1, n]. The data ma-
trix limited to interval [j, k] is denoted by A(j, k);
the values of the ith observation are denoted by
A(i, j, k), a binary string of length k − j + 1. Fig-
ure 1 illustrates an example of a 7× 11 0-1 haplo-
type matrix.
Given an interval [j, k], a diversity function,
δ : [j, k] → δ(j, k) ∈ R is an evaluation func-
tion measuring the diversity of the submatrix
A(j, k). We say an interval [j′, k′] is a subinter-
val of [j, k], written [j′, k′] ⊂ [j, k], if j ≤ j′ and
k′ ≤ k. Note that δ-function is a monotonic non-
decreasing function from [1..n, 1..n] to the unit real
interval [0, 1]; that is, 0 ≤ δ(j′, k′) ≤ δ(j, k) ≤ 1
whenever [j′, k′] ⊂ [j, k].
Given an input set of n haplotype vectors, a
solution to the Haplotype Block Selection (HBS)
Problem is a segmentation of marker intervals, re-
vealing these non-overlapped haplotype blocks of
interest in the chromosome. Here in this paper
we propose several efficient algorithms related to
selecting interesting haplotype blocks under dif-
ferent evaluation (diversity) functions that gen-
eralizes many previous results in the literatures
[2, 15, 20, 21, 6, 18, 12, 19, 1, 13, 9].
Given a sample (set) of strings such that each
string si is associated with a probability pi; that
is S = {(s1, p1), (s2, p2), . . . , (sk, pk)} such that∑
pi = 1. Li [14] propose a diversity formula de-
fined by
δD(S) = 1−
∑
pi∈S
p2i . (1)
The value of δD(S) is the probability that two hap-
lotype books chosen at random from S are differ-
ent from each other. According to the definition,
we can classify each haplotype submatrix as a sam-
ple space (multiset). For example, the submatrix
A(8, 11) of Figure 1 can be viewed as a sample S =
{(0001, 2/7), (0111, 2/7), (1000, 1/7), (1001, 1/7),
(1100, 1/7)}. It follows that δ(S) = δ(A(8, 11)) =
δ(8, 11) = 1− (4+4+1+1+1)/49 = 1− 11/49 =
38/49. It is possible to generalize the δD(·) func-
tion by raising the square to an arbitrary power q,
then we have
δq(S) = 1−
∑
pi∈S
pqi . (2)
Note that δD(S) is just δ2(S). Other measure-
ments of diversity can be obtained by choosing
different diversity function; for example, to mea-
sure the information-complexity one can choose
the information entropy (negative-log) function
[1, 13, 9]:
δE(S) = −
∑
pi∈S
pi log pi. (3)
By using appropriate diversity functions, the block
selection problem can be viewed as finding a seg-
mentation of given haplotype matrix such that the
diversities of chosen blocks satisfy certain value
constraint. In this paper, we consider the follow-
ing problems:
Problem 1 (all-interval-diversities) Given a
haplotype matrix A, compute the all pairs block
diversity values. That is, output the set {δ(i, j) |
1 ≤ i ≤ j ≤ n}.
Using techniques of the suffix tree [10, 17], we are
able to propose an O(mn+n2) time, linear propor-
tional to the input plus output size, algorithm for
computing the all-interval-diversities prob-
lem.
Problem 2 (farthest-sites) Given a haplotype
matrix A and a given real diversity upper limit D,
for each marker site i find its corresponding far-
thest right marker j = R[i] so that δ(i, j) ≤ D.
That is, output the set {R(i) = j | δ(i, j) ≤ D <
δ(i, j + 1), 1 ≤ i ≤ j ≤ n}. To simplify the bound-
ary condition, we assume that δ(i, n+ 1) = ∞.
We show that all farthest-sites can be found
totally in O(mn) time, linear proportional to the
input size, by the the similar techniques of the
suffix tree as in the all-pair-block-diversity
problem.
Problem 3 (longest-block) Given a haplotype
matrix A and a diversity upper limit D, find the
longest block [i, j] so that δ(i, j) ≤ D. That is,
output the arg maxi,j{|[i, j]| = j − i + 1 | [i, j] ⊂
[1, n] and δ(i, j) ≤ D}.
~153~
The 23rd Workshop on Combinatorial Mathematics and Computation Theory
diversity upper limit D, let S = {B1, B2, . . . , Bk}
be a segmentation of A with δ(B) ≤ D for each
B ∈ S. The length of S is the total length of all
block in S; i.e., ℓ(S) = |B1| + |B2| + · · · + |Bk|.
Our objective is to find a segmentation consists of
k feasible blocks such that the total length ℓ(S) is
maximized.
Given A and D, first we consider the most
general form of the problem and define the block
length evaluation function
f(k, i, j) = max { ℓ(S) | S a feasible segmenta-
tion of A(i, j) with k blocks }
Note that the k-longest-blocks asks to find
the value f(k, 1, n). First of all, we prepare the left
farthest sites, L[j]’s, for each site j of A; accord-
ing to Theorem 1, the array can be identified in
O(mn) time. Here we show that the answer can be
found in O(nk) time after the preprocessing. The
idea behind the dynamic programming formula is
illustrated at Figure 2.
It can be verified that
f(k, 1, j) = max{f(k, 1, j− 1), f(k− 1, 1, L[j]−
1) + j − L[j] + 1}
That is, the k-th block of the maximal segment
S in [1, j] either does not include site j; otherwise,
the block [L[j], j] must be the last block of S. Note
that f(k, 1, j) can be determined in O(1) time sup-
pose f(k − 1, 1, ·)’s and f(k, 1, 1..(j − 1))’s being
ready. It follows that f(k, 1, ·)’s can be calculated
from f(k − 1, 1, ·)’s, totally in O(n) time. Thus a
computation ordering from f(1, 1, ·)’s, f(2, 1, ·)’s,
. . . , to f(k, 1, ·)’s leads to the following result.
Theorem 3 (k-longest-blocks) Given a haplo-
type matrix A and a diversity upper limit D, find
a segmentation consists of k feasible blocks such
that the total length is maximized can be done in
O(nk) time after a linear time preprocessing.
Given A and D, the all-intra-longest-
block asks to find, for all constrained interval
[i, j] ⊂ [1, n], the corresponding longest block
B ⊂ [i, j] with δ(B) ≤ D. That is, the values
f(1, i, j)’s. Similarly, we first prepare the farthest
sites of A in O(mn) time. Here we show that
the answer can be found in O(n2) time after the
preprocessing. Using similar idea as illustrated at
Figure 2. It can be verified that
f(1, i, j) = max{f(1, i, j − 1), (j − L[j] + 1)}
That is, the longest block in [i, j] either does not
include site j; otherwise, the block [L[j], j] must
be the longest (feasible) block within [i, j]. Note
that f(1, i, j) can be determined in O(1) time
whenever f(1, i, 1..(j − 1))’s being ready. It fol-
lows that f(1, i, ·)’s can be calculated totally in
O(n) time. Thus a computation ordering from
f(1, 1, ·)’s, f(1, 2, ·)’s, . . . , to f(1, n, ·)’s leads to
the following result.
Theorem 4 (all-intra-longest-block) Given a
haplotype matrix A and a diversity upper limit D,
find for all constrained interval [i, j] ⊂ [1, n], the
corresponding longest block B ⊂ [i, j] with δ(B) ≤
D can be done in O(n2) time after a linear time
preprocessing.
Note that the computation time is linear propor-
tional to the output plus input size, and thus is an
optimal algorithm in regarding of time efficiency.
or all constrained interval [i, j] ⊂ [1, n], find
the longest segmentation with k feasible blocks
such that the total length is maximized. That
is, output the set S = {B1, B2, . . . , Bk}, with
δ(B) ≤ D for each B ∈ S,B ⊂ [i, j], such that
|B1|+ |B2|+ · · ·+ |Bk| is maximized.
The all-intra-k-longest-blocks asks to
find, for all constrained interval [i, j] ⊂ [1, n], the
longest segmentation with k feasible blocks such
that the total length is maximized. Again, the
problem can be solved by first prepare the far-
thest sites of A in O(mn) time. Here we show that
the answer can be found in O(n2k) time after the
preprocessing. Using similar idea as illustrated at
Figure 2. It can be verified that
f(k, i, j) = max{f(k, i, j − 1), f(k − 1, i, L[j] −
1) + j − L[j] + 1}
That is, the k-th block of the maximal segment
S in [i, j] either does not include site j; otherwise,
the block [L[j], j] must be the last block of S. Note
that f(k, i, j) can be determined in O(1) time sup-
pose f(k − 1, i, ·)’s and f(k, i, 1..(j − 1))’s being
ready. It follows that f(k, i, ·)’s can be calculated
from f(k − 1, i, ·)’s, totally in O(n) time. Thus
f(k, ·, ·)’s can be calculated from f(k− 1, ·, ·)’s to-
tally in O(n2) time. Thus a computation ordering
from f(1, ·, ·)’s, f(2, ·, ·)’s, . . . , to f(k, ·, ·)’s leads
to the following result.
Theorem 5 (all-intra-k-longest-blocks)
Given A,D, there exits an O(kn2)-time algorithm
to find, for all constrained interval [i, j] ⊂ [1, n],
the longest segmentation with k feasible blocks
such that the total length is maximized.
3 Dealing with Missing Data
We have propose several efficient algorithm in try-
ing to identify interesting haplotype blocks in the
~155~
The 23rd Workshop on Combinatorial Mathematics and Computation Theory
12
3 4
5
(1,3) (1,4) (2,4) (3,5)
1 0 0 3 3
2 3 3 0 3
3 1 3 3 0
4 3 1 1 3
5 3 3 3 1
0001
1110
Figure 3: A given graph G and the constructed minimum diversity instance.
haplotype patterns are as few as possible (with
low diversity.) There are two steps in the phase.
First, order the strings in set R, 〈r1, . . . , rn〉, by
the increasing order of number of missing sites; the
string containing the least missing data is placed
at the beginning. Second, compare each string ri,
for 2 ≤ i ≤ |R|, to other above strings rj , j < i.
We consolidate ri and rj if the two strings are
compatible and delete ri from the ordered list R.
Repeat the step until all strings are not compatible
with each other. Figure 4 illustrates the algorithm
of the third phase of our method.
Note that missing data may still exist in the
haplotype matrix after the missing data process;
e.g., some strings are never compatible with the
others or the values of one specific column are all
missing data. It’s worthy noting that the situa-
tions do not influence the computation of diversity
because two strings are always different no matter
how we assign the missing data and the values of
one specific column with all missing data are the
same.
4 Preliminary Experimental
Results
We use the haplotype data used in previous lit-
eratures [3, 15, 11, 4] and download several sets
of haplotype data from NCBI and other pub-
lic databases to evaluate the performance of our
block selection algorithms. Chromosome 21 spans
44.6Mbps long, the SNP data we adopt locates at
the region from the beginning of chromosome 21
to 28.5Mbps, and the haplotype we use to evaluate
partition results is in the range from 14.3Mbps to
the end of this chromosome. We focus on the over-
lapped region and evaluate the performance for
different block selection results. The overlapped
region 9911 SNPs and 840 haplotypes. We also
try to deal with missing data by heuristic related
to minimum diversity strategy as discussed in Sec-
tion 3.
Based on these obtained data, we have de-
veloped a web-based system, mostly consists of
a list of PHP and perl CGI-scripts together
with several C programs for selecting haplo-
type blocks and analyzing the haplotype di-
versity. The system is still under develop-
ment and the web system is freely accessible at
http://bioinfo.cs.pu.edu.tw/PU HapSel.htm.
Some preliminary results, including the selection
of different diversity functions as well as choosing
meaningful diversity constraints, in using our tools
can also be found in web system. Our web system
also provide the haplotype generator. The users
can input the size of haplotype matrix and the ra-
tio of value 0, our system will generate a haplotype
matrix for user to analysis automatically.
5 Concluding Remarks
By using appropriate diversity functions, the block
selection problem can be viewed as finding a seg-
mentation of given haplotype matrix such that the
diversities of chosen blocks satisfy certain value
constraint. In this paper, we propose several effi-
cient combinatorial algorithms related to selecting
interesting haplotype blocks under different diver-
sity functions.
Using several dynamic programming deduction,
we show in Theorem 1 that the farthest sites prob-
lems problem can be computed in O(mn) time. As
a corollary, we also show that the longest block
can also be found in O(mn) time. In Theorem 3,
we show that finding longest k-block segmentation
with diversity constraints can be done in O(nk)
time. In Theorem 4, we show that finding the
longest blocks with each constrained interval can
be done in O(n2) time. In Theorem 5, we show
that finding all longest k-block segmentation with
diversity constraints can be done in O(n2k) time.
In Theorem 6, we prove that the minimum diver-
sity problem is NP-complete.
We need to point out that these time-efficiency
results of our algorithms can be applied in many
different definitions of diversity functions; there we
~157~
The 23rd Workshop on Combinatorial Mathematics and Computation Theory
[15] N. Patil, A. J. Berno, D. A. Hinds, et al.
Blocks of limited haplotype diversity revealed
by high resolution scanning of human chro-
mosome 21. Science, 294:1719–1723, 2001.
[16] D. Reich, M. Cargill, E. Lander, et al. Link-
age disequilibrium in the human genome. Na-
ture, 411:199–204, 2001.
[17] Esko Ukkonen. On-line construction of suffix
trees. Algorithmica, 14(3):249–260, 1995.
[18] J.D. Wall and J.K Pritchard. Haplotype
blocks and linkage disequilibrium in the hu-
man genome. Nature Reviews Genetics,
4(8):587–597, 2003.
[19] N. Wang, J.M. Akey,
K. Zhang, R. Chakraborty, and L. Jin. Dis-
tribution of recombination crossovers and the
origin of haplotype blocks: the interplay of
population history, recombination, and muta-
tion. Am. J. Human Genetics, 71:1227–1234,
2002.
[20] K. Zhang, M. Deng, T. Chen, M.S. Water-
man, and F. Sun. A dynamic programming
algorithm for haplotype block partitioning.
In The National Academy of Sciences, vol-
ume 99, pages 7335–7339, 2002.
[21] K. Zhang, Z.S. Qin, J.S. Liu, T. Chen T, M.S.
Waterman, and F. Sun. Haplotype block par-
titioning and tag snp selection using geno-
type data and their applications to associ-
ation studies. Genome Res., 14(5):908–916,
2004.
~159~
The 23rd Workshop on Combinatorial Mathematics and Computation Theory
       
Keywords. Bioinformatics, Sequence alignment, Phylogenic tree, Web Portal, 
Cluster and Grid Computing. 
1. Introduction 
The merging of two rapidly advancing technologies, molecular biology and computer 
science, has resulted in a new informatics science, namely bioinformatics. 
Bioinformatics includes the methodologies of operating on molecular biological 
information, in order to expedite research in molecular biology. Modern molecular 
biology is characterized by the collection of large volumes of data. Take the classic 
molecular biology data type, the DNA sequence, for instance, major bioinformatics 
database centers including GeneBank, the NIH (National Institute of Health) genetic 
sequence database and its collaborating databases, the European Molecular Biology 
Laboratory and the DNA Data Bank of Japan, these data have reached a milestone of 
100 billion bases from over 165,000 organisms [3]. Common operations on biological 
data include sequences analysis, protein structures predication, genome sequences 
comparison, sequence alignment, phylogeny tree construction, pathway research, and 
sequence databases placement. The most basic and important bioinformatics task is to 
find the set of homologies for a given sequence, since sequences are often related in 
functions if they are similar. 
The genome research center such as the National Center for Biotechnology 
Information (NCBI) and the European Molecular Biology Laboratory (EMBL) hosts 
volumes of biological information in bioinformatics database. They also provide some 
bioinformatics tools for database search and data acquire. With the explosion of 
sequence information available to researchers, the challenge facing bioinformatics 
and computational biologists is to aid in biomedical researches and to invent efficient 
toolkits. Sequence comparison, multiple sequence alignment and phylogeny tree 
construction are the most fundamental works in biomedical research. There have been 
many abundant examples of bioinformatics applications that are able to provide 
solutions for these problems in biomedical research. The most extensively 
applications for these works are BLAST [4][5], ClustalW [6][7] and Phylip [8]. 
However, these bioinformatics applications typically are distributed in different 
individual projects and they require high performance computational environments. 
Biomedical researchers need to combine many works to conclude their investigation. 
For instance, in the south of an Asian area, once farms with many dead chickens are 
reported, biologist may need to identify if it was infected by H5N1 influenza virus 
urgently. After obtained the chicken’s testimony and RNA sequence, biologist may 
use BLAST tool to search and acquire other influenza virus sequences from the public 
database. ClustalW tool is required to compare and investigate their similarity, finally 
construct the phylogenic tree using Phylip tool. In the above situation, biomedical 
researchers need three bioinformatics applications. They may download a local 
version to their own computer or use them in individual server, but either one is 
complicated and inefficient way, due to a number of drawbacks that either solution 
may bring. Therefore, an efficient and integrated bioinformatics portal is necessary, in 
order to facilitate biomedical researches. 
       
 
Five sub-applications of BLAST perform the following tasks: 
 
1. blastp: compare an amino acid query sequence against a protein sequence 
database, 
2. blastn: compare a nucleotide query sequence against a nucleotide sequence 
database, 
3. blastx: compares the six-frame conceptual translation products of a 
nucleotide query sequence (both strands) against a protein sequence 
database, 
4. tblastn: compares a protein query sequence against a nucleotide sequence 
database dynamically translated in all six reading frames (both strands), 
5. tblastx: compares the six-frame translations of a nucleotide query sequence 
against the six-frame translations of a nucleotide sequence database. 
 
BLAST tool plays an extremely important role in NCBI GenBank database. It not 
only provides sequence database search, but also include many toolkits for sequence 
comparison. BLAST is based on Smith-Waterman local alignment algorithm [17][18], 
which basically identifies the best local alignment between two sequences by using 
dynamic programming and tracing back metrology through the sequence matrix. The 
mpiBLAST is a parallelized version of BLAST, developed by Los Alamos National 
Laboratory (LANL) [19]. The mpiBLAST segments the BLAST database and 
distributes it across cluster computing nodes, permitting BLAST queries to be 
processed on a number of computing nodes simultaneously. The mpiBLAST-g2 is an 
enhanced parallel program of LANL's mpiBLAST [21]. The enhanced program 
allows the parallel execution of BLAST on a grid computing environment, and based 
on MPICH-g2.  
ClustalW is a general purpose multiple sequence alignment program for DNA or 
proteins.It produces biologically meaningful multiple sequence alignments of 
divergent sequences. It calculates the best match for the selected sequences, and lines 
them up so that the identities, similarities and differences can be seen. ClustalW is 
one of the most popular sequences alignment packages, and it is not only a multiple 
sequence alignment package, but also a phylogenetic tree construction tool. The 
progressive alignment algorithm of ClustalW is based on three steps:  
 
1. Calculating sequence pairwise similarity;  
2. Construction of the phylogenic tree; 
3. Progressive alignment of sequence.  
 
In the first step, all pairs of sequences are aligned separately in order to calculate a 
distance matrix giving the divergence of each pair of sequences. As next step, the 
trees are used to guide the final multiple alignment processes that are calculated from 
the distance matrix of step 1 using the Neighbor-Joining method [22]. In the final 
step, the sequences are progressively aligned according to the branching order in the 
guided tree. ClustalW-MPI is a parallel implementation of ClustalW. All three steps 
have been parallelized in order to reduce the global execution time, and it runs on 
distributed workstation clusters as well as on traditional parallel computers [23]. The 
       
AMD 
Homogeneous 
Cluster
Intel 
Heterogeneous 
Cluster
AMD 64-bit OpenMosix
Cluster
SDCen tilion 1 2 00
PC C AP OP OWER RS - 23 2 C
Bay Netw o rks
RE ADY AL ARM RES ET
S D
E I A 2 3 2 I
O K
B002 - PDPC/ Parallel and Distributed Processing Center
PDPC 
M230 - Laboratory of Algorithms
M229a - CCI Computing Center
Outside World via TWAREN
 
Fig. 1. The PCGrid grid computing infrastructure. 
3.1. Selecting Computing Nodes to Run Parallel Applications 
There are two ways to select computing nodes in PCGrid computing platform, either 
manual or automatic. In the manual process, the developer chooses the computing 
nodes based on CPU activities, depending on it is status busy or idle, as shown in 
figures 2A and 2B. If the developer persists in selecting a computing node showing 
RUNNING (that is, CPU in use), this job will be queued, and it will only be started its 
execution when all selected computing nodes are idle. The alternative way to select 
computing nodes is automatic. All computing nodes in PCGrid platform are sorted 
and ranked, so that the developer selects a given condition, if he would like to select a 
number of computing nodes by its speed (and idle) or he would like to select a 
number of computing nodes with higher network bandwidth. 
All jobs submitted by any user are ranked according to user credentials, his level of 
priority inside the queue. The higher a user’s credentials; highest is the priority to 
execute this user’s applications in our computing platform. The queue is re-ranked 
every time a job is submitted to our grid platform.  
 
       
 
Fig. 3A. Performance data of each computing node involved in computation of PCGrid grid 
platform. 
 
Fig. 3B. Performance comparison of two application execution results, computing node by 
computing node, CPU load and memory usage. 
4. BioPortal: a Portal for Bioinformatics Applications in Grid 
4.1. Bioinformatics Services 
We have integrated most fundamental computing applications in biomedical research 
and bioinformatics inside BioPortal: sequence comparison, pairwise or multiple 
sequence alignment and phylogeny tree construction, all in a complete workflow. We 
also provide an additional feature to biologists, to choose automatically computing 
nodes to execute their parallel applications, by inputting the number of computing 
       
 
Biologists make use of ClustalW-MPI to perform multiple sequence alignment 
with a number of sequences, and then construct corresponding phylogenic tree using 
Phylip directly. Biologists do need not to copy the alignment result from the 
ClustalW-MPI and paste to Phylip to get the phylogeny tree, since our system provide 
a “shortcut” button in order to facilitate similar procedures. Figure 6 shows the web 
interface of ClustalW-MPI integrated with Phylip. We also develop a data format 
translation tool to ease biologist’s usage. Biologist can input GeneBank data format, 
and our translation toolkit can transform it to legal FASTA format for ClustalW-MPI, 
as in figure 8. Detailed description of all bioinformatics services available in our 
BioPortal is listed in table 1, while Figure 7 shows the complete workflow of the 
BioPortal.  
 
 
 
Fig. 6. Using Phylip application to construct phylogenic tree, directly from the output 
generated by ClustalW-MPI. 
  
Fig. 7. BioPortal web-based GUI complete workflow. 
 
 
       
5. Conclusions and Future Work 
We have constructed a campus scale computing grid platform and also implemented a 
portal integrated with a number of well-known bioinformatics application toolkits. 
Not only to provide easy access of bioinformatics application toolkits to biologists 
and geneticists, but also large amount of computational cycles in an easy way. This 
portal contributes three fundamental molecular biology activities: sequence 
comparison, multiple sequence alignment and phylogenic tree construction, all 
integrated in a friendly, WYSIWYG and easy-to-use web-based GUI portal. We have 
solved many data inconsistency problems and finally integrated a number of different 
tools that are able to cooperate all together. This BioPortal not only facilitate 
biomedical researcher investigations and computational biology courses in graduate-
level, as also it demonstrates a well-succeeded combination of high performance 
computing with the use of grid technology and bioinformatics. 
As future work, several directions of this research are ongoing. One of goals is to 
develop a one-stop-shop bioinformatics portal, to provide efficient and economic 
computational power and cycles to biomedical researchers. At the present moment, 
we are in the process of integrating other well-known bioinformatics applications into 
this BioPortal, for instance, applications for protein structure predication. We expect 
to continuously develop the grid technology, so that in near future, researchers will 
not only be able to seamlessly utilize PCGrid computational resources, but also 
expand on demand to larger grid computing platforms, such as regional or national 
grid platforms. 
References 
[1] K.C. Li, H.H. Wang, C.N. Chen, C.C. Liu, C.F. Chang, C.W. Hsu, S.S. Hung, "Design 
Issues of a Novel Toolkit for Parallel Application Performance Monitoring and Analysis 
in Cluster and Grid Environments", in I-SPAN'2005 The 8th IEEE International 
Symposium on Parallel Architectures, Algorithms, and Networks, Las Vegas, USA, 
2005. 
[2] H.C. Chang, K.C. Li, Y.L. Lin, C.T. Yang, H.H. Wang, and L.T. Lee, "Performance 
Issues of Grid Computing Based on Different Architecture Cluster Computing 
Platforms", in AINA'2005 The 19th IEEE International Conference on Advanced 
Information Networking and Applications, vol. II, Taipei, Taiwan, 2005. 
[3] Public Collections of DNA and RNA Sequence Reach 100 Gigabases, National Institutes 
of Health, August 22, 2005. (http:// www.nlm.nih. 
gov/news/press_releases/dna_rna_100_gig.html). 
[4] S.F. Altschul, W. Gish, W. Miller, E.G. Myers, and D.J. Lipman, “Basic Local 
Alignment Search Tool”, J. Mol. Biol. 215,403-410(1990) 
[5] S. F. Altschul, T. L. Madden, A. A. Schaeffer, J. Zhang, Z. Zhang, W. Miller and D.J. 
Lipman, “Gapped BLAST and PSI-BLAST: A new generation of protein database 
search programs”, Nucleic Acids Research, 25,3389-3402(1997) 
[6] D.G. Higgins, P.M. Sharp, “CLUSTAL: a package for performing multiple sequence 
alignment on a microcomputer”, Gene. 1988 Dec 15;73(1):237-44. 
