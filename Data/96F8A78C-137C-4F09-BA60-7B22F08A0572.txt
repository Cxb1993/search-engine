2始版本的編輯距離，若我們可以任選 X 中
的一個子字串，經由編輯後得到 Y，則此
時編輯距離有機會更小，這個新的編輯距
離我們稱之為區域編輯距離 dl(X, Y)。這兩
種編輯距離的動態規劃方法的核心如圖
一。
最原始版本的編輯距離問題已經被廣
泛的討論，許多有效率的方法也被提出
[Hirs77, Hunt77, Rick00, Yang87]。但此版
本的編輯距離問題只有考慮字元的編輯操
作，若要以此作為生物序列的比對方法，
則仍有不足之處。如圖二所示，S1及 S2分
別代表兩個 RNA序列，其中相同顏色的區
塊表示整段相同的子序列。若以原始的編
輯距離方法來計算 S1及 S2之間的相似度，
會發現兩者非常的不相似，但可能 S1與 S2
之間在結構上只有少數轉彎的區域不同，
而大部分的結構都是一樣的。於是原始版
本的編輯距離並不能夠符合生物上的意
義。要克服這樣的問題，我們需要能夠處
理區塊編輯操作的方法。為了方便解說，
以下的說明以序列編輯為觀點，而最後再
將之當成生物序列相似度比對的工具。
在前人的研究中，已定義了區塊搬移
操作，如圖二所示，在此區塊的定義是一
個子字串，必須完全符合原來字串的一部
份。當允許遞迴的區塊搬移操作發生時，
這個問題變得相當的難，且已被證明為
NP-hard的問題[Shap02]。由於無法在多項
式的時間內求出最佳解，前人提出了幾個
求得近似解的方法，例如 Shapira的方法已
被證明出 )( 46.0n 的下界[Shap02, Chro05,
Kapl06]。我們的研究則提出了另一個觀
點，若能夠對區塊編輯的操作加上一點限
制，則此問題便不再是 NP-hard 的問題，
而且時間複雜度與原始版本的編輯距離問
題相差不大。
在我們所定義的問題中，區塊的編輯
是不允許遞迴操作的，不會發生兩個區塊
編輯範圍重疊的問題，且編輯操作的順序
必須是依序由左而右。我們定義了三種區
塊編輯的操作，分別為區塊複製、區塊刪
除與區塊平移。而前人所提出的區塊搬移
則是使用更一般化的操作來代替，也就是
一個區塊複製加上一個區塊刪除的操作。
其中，區塊複製、區塊刪除適用於生物序
列上的比對，而區塊平移則適用於音樂序
列方面的比對，尤其適合於尋找相同旋律
但音調不同的音樂[Ann07]。
圖一：編輯距離 dc(X, Y)與區域編輯距離 dl(X, Y)的動態規劃演算法核心。
S1
S2
圖二：區塊搬移後極為相似的兩個序列。
4在我們的研究中，針對了其中三種問
題作了深入的探討，分別為 P(EIS, C)、P(EI,
L)、P(EI, N)。這三個問題以及他們相對應
的演算法，分述如下：
在 P(EIS, C)問題中，三種區塊複製操
作全部都被允許，而區塊複製與區塊刪除
的成本是常數。這個問題可以使用動態規
劃方式來求解，演算法核心公式如圖三所
示。但是直接計算此核心公式，所需要的
時間複雜度為 |)|)(( 2 mnnmO ，其中|∑|
代表字串中的字母種類數。這樣的計算量
實在太高，於是我們提出了一些前置處理
(preprocessing)的方法，經過這些前置處理
的步驟後，求解的時間便可以大幅降低。
我們進行前置處理的目的有兩個，第
一個是給定 S2的一個索引值當作起點，有
效找出 S1(或 Wi)上可以複製的最大共同子
字串，但是此最大長度的共同子字串未必
就是最好的。因此第二個目的就是在此可
複製範圍內，有效地找出最小的區塊編輯
距離。為了達到第一個目的，我們可以建
立反轉序列 S1’與 S2’串接後的 suffix tree。
建立完成之後，若要尋找某個起始索引點
可複製的範圍，便是由此起始索引點的葉
節點往上搜尋，找到第一個同時包含 S1’與
S2’的內部節點，則由此內部節點到根節點
圖五：用來搜尋區域最小值的資料結構，新增、刪除、查詢最小值的平均時間均為
常數時間。
圖六：求解 P(EI, L)問題的動態規劃演算法核心。
圖七：求解 P(EI, N)問題的動態規劃演算法核心。
6的字母種類有限的情況下，針對 T 來建構
它的 suffix tree[Ukko95, Fara00]或是 suffix
array[Abou02, Kim05]，是目前大家所熟知
的最佳前處理法(optimal preprocessing)。
由於傳統的字串比對其定義缺乏彈
性，只能在 T中找出所有和 P一模一樣的
子字串，而非和 P 相似的子字串，因此許
多學者們也分別提出不同的比對法則。其
中比較著名的有Amir等人[Amir04]所提出
的允許部份錯誤比對法，它可用來找出在 T
中所有和 P相差 k個字的子字串，k為使用
者所訂義的最大允許錯誤個數。此外，Amir
也 率 先 提 出 所 謂 的 放 大 搜 尋 概 念
[Amir92]。以之前的例子為例，原本 P2 = bb
aa bb cc並不存在於 T中，但若將 P2放大
兩倍，則變成一個新的字串δ2(P2) = bbbb
aaaa bbbb cccc，其中δ為放大函數。在我
們的例子中，δ2(P2)出現在 T 的右半邊畫
底線的位置。也就是說，原本的 P在 T中
雖然沒有出現，但 P 的某個放大字串卻可
能在 T中出現。Amir也進一步將此問題分
為正整數倍及正實數倍放大這兩種情況，
並且均分別提出了O(n+m)線性時間的演算
法[Amir92, Amir99]。
如同我們之前所說的，這些更有彈性
的比對法也有所謂的前處理問題，在我們
的研究中所針對的題目，是如何在 P 允許
正整數倍放大的情況下，對 T 設計一個有
效的前處理法，使得所有δα(P)在 T 中出
現的位置能在 O(m+Ud)的時間內被找出
來，其中 Ud為所有正確位置的個數，α ≥
1為一個正整數，代表放大的倍數。對於此
問題，之前唯一已知的前處理法是
Wang[Wang04]等人所提出的演算法。在字
母個數有限的情況下，Wang的方法需花費
O(nlogn)的前處理時間及空間，而能做到最
佳的 O(m+Ud)回答時間。在我們的研究
中，我們則成功的找出了 O(n)時間及空間
的前處理法，而且此處理法同樣能在
O(m+Ud)的時間內列出所有 P 在 T 中正確
的放大位置。也就是說，針對正整數倍放
大的字串比對問題，我們改進了 Wang 的
方法，並提出了目前唯一已知的最佳前處
理演算法[Peng07]。我們所提出的方法已在
2007年組合數學研討會中發表，並榮獲最
佳論文獎。由於詳細的證明過於繁雜，底
下我們只用一個簡單的例子來簡介我們的
方法。
給定一個有限字母集合∑ = {a, b, c}之
字串 T = aaaaa bbbbbbb aaaa bbb cccccc
aaaa bbbb aaaa bbbb cccc，我們的前處理法
共分為三個階段，分別為(1)產生所有能在
T 中找到的放大字串，將其碼長編碼串接
成另一個碼長編碼字串 TG’ (2)建構 TG’之
suffix tree (3)利用一維陣列上的範圍最大
值搜尋(range maximum query)，加速 P在
TG’中的搜尋速度。
(1) 建構 TG’：
由於 P會先進行放大再去和 T比對，反過
來說，我們可以將 T 進行整數倍縮小，來
確定有哪些放大過後的 P可以在 T中被找
到。在討論倍數α時，若某個 T 中的碼長
字元 tr滿足 r 為α的倍數，則 tr將被取代
為 tr/α。若 r不為α的倍數，則 tr將被取代
為 tq $ tq，q為 r/α所得到的商數，$則為一
個不存在原來字母集合中的符號，用途是
拿來串接字串。利用上面所說的概念，我
們共可得到 T1’~T7’這 7 個字串(分別代
表倍數 1到 7)，分別列舉如下：
T1’ = a5 b7 a4 b3 c6 a4 b4 a4 b4 c4
T2’ = a2 $ a2 b3 $ b3 a2 b1 $ b1 c3 a2 b2 a2 b2 c2
T3’ = a1 $ a1 b2 $ b2 a1 $ a1 b1 c2 a1 $ a2 b1 $
b1 a1 $ a1 b1 $ b1 c1 $ c1
T4’ = a1 $ a1 b1 $ b1 a1 $ c1 $ c1 a1 b1 a1 b1 c1
T5’ =a1 b1 $ b1 $ c1 $ c1
T6’ = b1 $ b1 $ c1
T7’ = b1
可以發現，當給定 P1 = bbb aaaa bbb cc時，
P1可在 T1’被偵測到，也就是δ1(P1)存在
於 T中。另外，給定 P2 = bb aa bb cc可在
T2’被偵測到，也就是代表δ2(P2)存在於 T
中。而事實上，若某個字串 P在 Tα’中被
偵測到，即表示 P 放大α倍之字串存在於
T中。正因為如此，TG’ = T1’$T2’$T3’
$T4’$T5’$T6’$T7’即為我們要的串接
字串。在我們的論文中，有說明如何在 O(n)
的時間內完成此步驟。
(2) 建構 TG’的 suffix tree：
8表二：正整數倍放大字串比對之相關研究結果
Algorithm Complexity Constant Integer Unbounded
Amir et al.
[Amir92]
Time
Space
Decision
Position
O(n+m)
O(n+m)
O(n+m)
O(n+m)
O(n+m)
O(n+m)
O(n+m)
O(n+m)
O(n+m)
O(n+m)
O(n+m)
O(n+m)
Wang et al.
[Wang04]
Time
Space
Decision
Position
O(nlogn)
O(nlogn)
O(m)
O(m+Ud)
O(nlogn)
O(nlogn)
O(m+logn)
O(m+Ud+logn)
O(nlogn)
O(nlogn)
O(m+logn)
O(m+Ud+logn)
Our method
[Peng07]
Time
Space
Decision
Position
O(n)
O(n)
O(m)
O(m+Ud)
O(n)
O(n)
O(m+logn)
O(m+Ud+logn)
O(nlogn)
O(n)
O(m+logn)
O(m+Ud+logn)
a4b2出現的位置來找答案，最差的情況仍要
O(n)的時間。因此，我們利用 Bender 及
Farach-Colton[Bend00]所提出的範圍最小
或最大值搜尋前處理法來縮短檢查的時
間。我們的想法是將這些要被檢查的位置
依字母種類分成多個陣列，如圖九所示。
在圖九中，在搜尋 a4b2之後，我們會得到
第 1~3 個 leaf node(即被紅色虛線框住的
leaf node)。由於 leaf node的前一個字已按
字母種類分類，所以我們接下來的檢查動
作可被視為是在陣列 b 的第 1~3 個元素之
中，找出所有元素值大於 1 的元素位置，
以此範例而言，會得到位置 1 和位置 3(即
第 1個 leaf node和第 3個 leaf node)。接著
再做簡單的對應，就能得到最後在 T’中
的位置 2 和 7 了。應用 Bender 及
Farach-Colton[Bend00]的結果，我們知道對
一個大小為 n的陣列 A進行 O(n)時間的前
處理後，對於任何一個給定的範圍(i, j)及數
值 c，子陣列 A[i, j]中所有比 c大的值可在
O(Ux)的時間內被找出，其中 Ux代表在 A[i,
j]內，元素值大於 c 的元素個數。也就是
說，在字母種類有限的情況下，對 TG’之
suffix tree內的 leaf node進行分類，並進行
O(n)時間的前處理之後，可保證檢查動作
只花 O(Ud)的時間。於是，全部的搜尋時間
可被降至最佳的 O(m+Ud)。
最後，我們用表格二來總結在正整數
倍放大下字串比對的相關研究結果，包含
Amir 等人在 1992 年最先發表的直接解法
[Amir92]，Wang 等人在 2004 年發表的第
一個已知的前處理法[Wang04]，以及最後
我們所提出的最佳前處理法[Peng07]。在表
格二中，Time、Space、Decision、Position
分別表示前處理所花的時間、前處理所花
的空間、決定 P 是否有任何放大字串存在
於 T所花的時間，以及找出所有 P的放大
字串在 T 的位置的時間。之外，我們也將
字母種類分成三種情況來討論，分別是字
母種類有限 (可於常數時間完成字母排
序，在表格中以 Constant來表示)、字母為
{1, 2, 3,…, n}(可於 O(n)時間完成字母排
序，在表格中以 Integer來表示)，以及字母
的大小順序只能用比對來決定(完成字母
排序需要 O(nlogn)時間，比如字元為實數
的情況，在表格中以 Unbounded來表示)。
由於報告中我們只對字母種類有限的情況
做說明，所以關於 Integer及 Unbounded情
況下的解法請參考我們所發表的論文。
在表二中，可以知道，我們所提的方
法在字母種類有限的情況下，已是在時間
複 雜 度 上 最 佳 的 前 處 理 法 (optimal
preprocessing)。除此之外，在 Integer 及
Unbounded 這兩種情況下，也是目前所知
最佳的前處理法。由於我們所提出的前處
理法只需 O(n)的空間，因此在資料庫設計
的應用上，較 Wang 的前處理法更能達到
節省空間的效果。將來，對於實數倍數放
