結構化特殊應用積體電路之面積，功率，效能最佳化之元件， 
設計工具與方法(I) 
“Devices, Tools and Methodologies for Area, Power, and Performance Optimization of Structured 
ASICs” 
計畫編號：NSC 99-2221-E-155 -087 
執行期間：99 年 8 月 1 日 至 100 年 7 月 31 日 
主持人：林榮彬 元智大學資訊工程系教授 
 
一、 中文摘要 
Structured ASIC 為一種晶片設計技術，它
與傳統之 gate array 相似，其不同之處在於 
Structured ASIC 已經預先製造一些金屬繞線
層，甚至已製造好一些金屬層之光罩，只保留
一些金屬層來定義底層之邏輯元件功能與完
成電路之繞線設計。本計畫主要工作是設計一
個 VCLB (Via-configurable logic blocks)，並發
展一個Memory Compiler運用這個VCLB來產
生 Memory IP。 
英文摘要 
Structured ASIC is an integrated circuit 
design technology which differentiates itself 
from traditional gate array technology in the way 
of configuring its logic function and interconnect. 
Structured ASIC uses vias to customize 
pre-fabricated transistors and predefined 
interconnects to complete a circuit design. This 
project is to develop a via-configurable logic 
block that can realize an SRAM block and 
develop an SRAM compiler for generating it. 
 
二、 計畫的緣由與目的 
A typical ASIC may contain a varying number 
of memory blocks of various sizes. The memory 
blocks can be placed at any legal locations. They 
are mainly SRAMs which can be used for cache 
memories, FIFOs, stacks, etc. They are 
customized for area, power, and performance 
optimization using a highly optimized SRAM 
cell and peripheral circuits. On the contrary, 
memory blocks in a structured ASIC are 
normally pre-diffused. As a result, a structured 
ASIC cannot have a varying number of memory 
blocks and cannot change their locations and 
sizes. Hence, a designer may encounter a number 
of problems such as insufficient number of 
memory blocks, improper memory block sizes 
and locations, etc. These limitations greatly 
discourage the adoption of structured ASICs. 
Clearly, we need remove these limitations to 
make structured ASIC a prevailing design 
technology. 
Basically, a memory block for structured 
ASIC can be pre-diffused and optimized for 
performance, area, and power using a highly 
customized memory cell as it is done for a 
typical ASIC. Such an implementation is shown 
in Figure 1(a). Another implementation, as 
shown in Figure 1(b), is to employ a VCLB 
customized specifically for implementing 
memory blocks. This VCLB is different from the 
one for realizing logic blocks. If a memory block 
is not used, the VCLB instances in the memory 
block can be still configured into some logic 
blocks. Both implementations shown in Figure 
1(a) and 1(b) face the same problem of having to 
determine the number of memory blocks, their 
sizes, and their locations beforehand. Yet another 
implementation, as shown in Figure 1(c), is to 
use the same VCLB for realizing logic and 
memory blocks. In this way, we can have an 
arbitrary number of relocatable and resizable 
memory blocks on a structured ASIC even 
though the structured ASIC still has a 
pre-diffused substrate. Clearly, chip performance, 
power dissipation, and area will be compromised 
for owning such a design freedom. Nevertheless, 
the design freedom brought about by employing 
a single VCLB is still a valuable asset for 
process technology, our single-port SRAM block 
has an area 1.5 to 14.4 times the area of their 
counterparts generated by an industrial SRAM 
compiler. It has an access time 1.46 to 2.35 times 
that of their counterparts. It has a read internal 
power 0.37 to 3.29 times that of their 
counterparts and a write internal power 0.5 to 
3.05 times that of their counterparts. Hence, 
exploiting such a structured ASIC technology 
requires understanding the trade-offs between the 
claimed advantages and performance, area, and 
power. Our main contributions are as follows. 
 Design a VCLB for implementing logic 
blocks, all the peripheral circuits of a SRAM 
block, and memory arrays. 
 Develop an SRAM compiler to generate 
SRAM blocks using our VCLB and 
predefined routing fabrics. 
 Demonstrate the feasibility of forming an 
arbitrary number of relocatable and resizable 
SRAM blocks for structured ASIC. A 32-bit 
OR1200-based SoC platform is implemented 
to prove the feasibility. 
Figure 7 shows a layout of the SoC platform 
designed based on M-VCLB. If SRAM blocks in 
this design were not relocatable and resizable, a 
structured ASIC would need eight pre-diffused 
SRAM blocks at fixed locations with fixed sizes. 
This places a great limitation on the applications 
of the via-configurable structured ASIC 
technology. 
 
 
Figure 12. An SoC platform with eight SRAM blocks. 
 
四、 結論與討論 
In this project we develop a method to create a 
relocatable and resizable SRAM block for 
via-configurable structured ASICs. Such a 
structured ASIC technology is enabled by using 
the same VCLB to implement logic blocks and 
SRAM blocks. We develop such a VCLB by 
properly sizing a VCLB originally optimized for 
logic gate implementation. We also develop an 
SRAM compiler to exploit this VCLB for 
generating relocatable and resizable SRAM 
blocks. Chip performance impact due to 
transistor down sizing is confined within an 
acceptable range. We also demonstrate an 
application of our relocatable and resizable 
SRAM blocks to an SoC platform design. In the 
future, we will work out a VCLB optimized for 
memory cell, but still being viable for logic gate 
implementation. 
 
五、參考文獻 
[1] F B. Zahiri, "Structured ASICs: opportunities 
and challenges," ICCD, pp. 404-4093, 2003. 
[2] K. C. Wu and Y. W. Tsai, "Structured ASIC, 
evolution or revolution?" ISPD,  pp. 
103-106, 2004. 
[3] L. T. Pileggi et al., "Exploring regular fabrics 
to optimize the performance-cost trade-off,"  
DAC, pp. 782-787 , 2003. 
[4] Z. Or-Bach, "Paradiam shift in ASIC 
technology in-stand metal out-stand cell," 
eASIC, 2006. 
[5] FARADAY. (2007, Dec.) Faraday platform 
solutions. [Online]. 
http://www.faraday-tech.com/html/products/s
tructuredASIC.html 
[6] C. Patel, A. Cozzie, H. Schmit, and L. 
Pileggi, “An architectural exploration of via 
patterned gate arrays,” ISPD, pp. 184–189, 
2003. 
[7] Y. Ran and M. Marek-Sadowska, "Designing 
via-configurable logic blocks for regular 
fabric", IEEE Trans. on VLSI Systems, Vol. 
14, No. 1, pp. 1-14, Jan. 2006. 
Clock Gating Optimization with Delay-Matching 
Shih-Jung Hsu 
Computer Science and Engineering 
Yuan Ze University 
Chung-Li, Taiwan 
Rung-Bin Lin 
Computer Science and Engineering 
Yuan Ze University 
Chung-Li, Taiwan
 
 
Abstract—Clock gating is an effective method of reducing power 
dissipation of a high-performance circuit. However, deployment 
of gated cells increases the difficulty of optimizing a clock tree. In 
this paper, we propose a delay-matching approach to addressing 
this problem. Delay-matching uses gated cells whose timing 
characteristics are similar to that of their clock buffer (inverter) 
counterparts. It attains better slew and much smaller latency 
with comparable clock skew and less area when compared to 
type-matching. The skew of a delay-matching gated tree, just like 
the one generated by type-matching, is insensitive to process and 
operating corner variations. Besides, delay-matching ECO of a 
gated tree excels in preserving the original timing characteristics 
of the gated tree. 
Keywords- Clock gating; low power design; clock tree 
I.  INTRODUCTION 
Clock gating is an effective method of reducing power 
dissipation of a high-performance circuit [1-14]. As shown in 
Fig. 1, En1 and En2 input to the AND gates can be employed 
to prevent clock signals from reaching the downstream flip-
flops and hence reduce the switching activity of flip-flops. 
However, deployment of gated cells such as AND gates 
increases the difficulty of synthesizing a low-skew gated tree. 
Arguing that different types of logic gates employed in a gated 
clock tree are detrimental to clock balancing based on load-
matching mechanism, the work in [14] proposes using type-
matching gates to grow a clock tree based on load-matching 
mechanism. Type-matching prescribes that all the logic gates 
on the same level must be of the same type. The logic gates on 
the same level can be either all inverters, buffers, NAND, 
AND, NOR, or OR gates.  Although type-matching approach 
can result in lower clock skew, it may incur excessive clock 
latency and bad slew at buffers and clock sinks due to having 
only a limited number of gated cell types in a typical standard 
cell library. It may also cause a design to use more cell areas.  
In this paper, we propose delay-matching concept to 
address some problems about type-matching. Delay-matching 
is achieved using gated cells whose timing characteristics are 
similar to that of their clock buffer (inverter) counterparts. 
Hence, a traditional clock tree synthesizer can be employed to 
obtain a delay-balanced clock tree just treating a gated cell as a 
clock buffer (inverter). Delay-matching concept can thus be 
easily implemented and integrated into an industrial design 
flow. To facilitate such a task, we also propose an approach to 
designing delay-matching cells and integrating them into a 
commercial standard cell library. We apply delay-matching to 
three occasions of clock gating. 
 
Figure 1. A gated clock design. 
 Optimizing a homogeneous gated tree where the clock 
paths from the root to all the sinks are of the same depth. 
Experimental results based on UMC 90nm process 
technology show that delay-matching attains better clock 
slew and much smaller clock latency with comparable 
clock skew at the typical, worst, and best corners when 
compared with type-matching approach. Delay-matching 
achieves all of these using less area than type-matching 
does. Besides, the skew of a delay-matching gated tree, 
just like the one generated by type-matching, is insensitive 
to process and operating corner variations. Moreover, the 
slews of a delay-matching gated tree are less sensitive to 
process and operating corner variations than that of a type-
matching gated tree.  
 Optimizing a non-homogeneous gated clock tree. Our 
results show that delay-matching obtains smaller latency 
and better slew but incurs larger area and skew.  
 Performing ECO (Engineering Change Order) of a gated 
tree. Our results show that delay-matching ECO excels in 
preserving the original timing characteristics of a gated 
tree. 
Note that delay-matching is a general concept. Its 
applications are not limited to the occasions presented in this 
work. One of its disadvantages is that we need to re-engineer a 
cell library to include delay-matching cells. 
The rest of this article is organized as follows. Section II 
presents some basics and problems about type-matching clock 
gating. Section III describes our delay-matching concept and 
how we design delay-matching cells. Section IV presents how 
delay-matching is employed to optimize a gated tree and shows 
some experimental results. The last section draws conclusions. 
978-3-9810801-7-9/DATE11/©2011 EDAA.  
PD
Fil
l P
DF
 Ed
ito
r w
ith
 Fr
ee
 W
r t
er 
an
d T
oo
ls
Similarly, CKORkX for its CKBUFkX counterpart and 
CKNANDkX and CKNORkX for its CKINVkX counterpart 
should also possess these properties. 
B. Designing of Delay-Matching Cells 
To design a delay-matching cell whose timing 
characteristics are similar to its counterpart, we must make the 
cell satisfy the last two properties presented above. Taking 
CKNAND1X as shown in Fig. 5 for example, we would like to 
make CKNAND1X similar to CKINV1X. Given that 
CKINV1X has a PMOS with channel width   	
and 
an NMOS with channel width
  	
 and their timing 
characteristics, we would like to determine the widths of P1, 
P2, N1, and N2 of CKNAND1X. Since we assume that clock 
control signal will arrive at input En much earlier than clock 
signal, we should make P2 as small as possible to reduce cell 
area. In our case, the width of P2 is set to 360nm. As for the 
widths of P1, N1, and N2, we perform HSPICE simulation to 
determine their values. Our approach has the following three 
steps. 
 For each pair of input slew (totally seven slews) at Clk 
and an output load (totally seven loads) at Y, HSPICE 
simulations are performed to determine the widths of P1, 
N1, and N2 such that the timing characteristics of 
CKNAND1X are similar to that of CKINV1X. We do this 
for all the 49 pairs of input slews and output loads. We 
hence obtain 49 width values of P1, N1, and N2, 
respectively. Note that HSPICE allows us to perform such 
simulation easily. This requires us to guess an initial width 
and a possible width range for each transistor at each 
simulation.  
 For each transistor, we find its average, maximum, and 
minimum widths from the 49 data sets. We use the 
average width as the width of the transistor and perform 
timing characterization of CKNAND1X with such width. 
We then find out the timing discrepancy TD, a sum of the 
absolute timing differences between CKNAND1X and 
CKBUF1X for all the 49 pairs.  
 With initial width set equal to the average width and its 
possible width range defined by the minimum and 
maximum widths obtained from the previous iteration, we 
repeatedly perform the above two steps until TD cannot be 
further reduced. The transistor widths are then determined 
by the iteration with the smallest TD. 
In the above procedure, we consider all the 49 pairs for 
determining transistor’s width. However, we find that with so-
obtained transistor sizes, a gated cell tends to have large timing 
discrepancies. Based on our observation, the transistor widths 
for the pairs with smaller slews and smaller loads tend to be 
much larger than the others. Hence, we employ only the 20 
pairs formed by larger input slews and output loads to 
determine transistor widths. The timing data presented 
hereafter are obtained using the transistor widths determined in 
such a way. Note that the above task for determining transistor 
widths of a delay-matching cell can be automated easily and 
efficiently. 
 
Figure 5. Transistor sizing of CKNAND1X (right) for matching CKINV1X 
How similar are our gated cells to their counterparts in 
terms of timing behavior? TABLE I shows a comparison of 
clock input capacitance of gated cells with that of their buffer 
(inverter) counterparts. As one can see, the input capacitance of 
CKNANDkX and CKANDkX is quite close to that of 
CKINVkX and CKBUFkX, respectively. This is a direct 
consequence of forcing the equivalence of timing 
characteristics between gated cells and their counterparts. 
TABLE II shows the average and maximum timing 
discrepancies between CKINVkX and CKNANDkX. The 
second to fifth columns show the discrepancies for the case of 
counting the data of all 49 pairs and the sixth to 9th columns 
show the discrepancies for the case of counting only the data of 
20 pairs with larger slews and loads. As one can see, timing 
discrepancy is on average small except for some cases. 
Especially, the discrepancy in rise delay (RD) between 
CKINVkX and CKNANDkX is large. The large discrepancy is 
mainly due to some data points which have small denominators 
in calculating discrepancies so that the average discrepancy is 
widened by these data points considerably. Similar results are 
observed for CKBUFkX and CKANDkX. 
It is worthwhile to mention that our delay-matching cells 
CKNANDkX has similar timing characteristics as that of 
CKNORkX because CKNANDkX and CKNORkX are both 
designed to have similar timing characteristics as that of 
CKINVkX. By the same reason, both CKANDkX and 
CKORkX have similar timing characteristics. For example, the 
timing discrepancies between our CKAND1X and CKOR1X 
on the 49 pairs of slew and load are on average 0.83% for rise 
delay, 2.68% for rise time, 0.85% for fall delay, and 2.89 for 
fall time. The maximum discrepancies are 9.13%, 19.81%, 
7.39%, and 14.89%, respectively.  
TABLE I.  INPUT CAPACITANCE OF GATED CELLS AND THEIR 
COUNTERPARTS (PF). 
 CKINV CKNAND CKNOR CKBUF CKAND CKOR 
1X 0.00391 0.00395 0.00455 0.0039 0.00418 0.00478 
2X 0.00704 0.00735 0.00841 0.0039 0.00442 0.00479 
3X 0.01015 0.01067 0.01234 0.00703 0.00738 0.008 
4X 0.01337 0.0138 0.01625 0.00703 0.0076 0.00837 
6X 0.01963 0.01988 0.0237 0.01015 0.01073 0.01211 
8X 0.02588 0.02694 0.03095 0.01337 0.01392 0.01567 
12X 0.03849 0.03983 0.0465 0.01962 0.02052 0.02198 
16X 0.05113 0.05193 0.06348 0.02588 0.02748 0.02867 
20X 0.06374 0.0668 0.07749 0.03223 0.03373 0.03641 
PD
Fil
l P
DF
 Ed
ito
r w
ith
 Fr
ee
 W
rit
er 
an
d T
oo
ls
buffered and placed clock tree without clock gating. We 
randomly select a certain percentage of clock buffers 
(inverters) in the clock tree and change them into 
corresponding gated cells. For simplicity, we wire together all 
the clock control signals on the same level. At this moment, we 
should obtain a clock tree like the one shown in Fig. 3. We 
place gated cells at the locations where their individual 
counterparts are located originally. Because gated cells are 
larger than their buffer (inverters) counterparts, we perform cell 
legalization using Cadence SOC Encounter to remove cell 
overlaps. We then use Encounter to complete clock tree and 
signal routing and obtain clock skew, latency, and slew at 
buffers and sinks. 
 Synthesis of a BigT gated tree 
We use a cell library augmented with large-drive gated cells 
for synthesizing a BigT gated tree. For simplicity, rather than 
using the type-matching algorithm presented in [14], we adopt 
an approach similar to our delay-matching one. The way of 
obtaining a type-matching gated tree using BigT is similar to 
that of delay-matching except that, after obtaining a clock tree 
like the one shown in Fig. 3, we replace buffers (inverters) with 
type-matching AND (NAND) gates to obtain a type-matching 
tree like the one shown in Fig. 2. 
 Synthesis of a SamllT gated tree 
We use a cell library that only has clock buffers and 
inverters of driving capabilities 1X, 2X, 3X, 4X, and 6X for 
clock tree synthesis. Similar to delay-matching approach, we 
also randomly replace a certain percentage of buffers and 
inverters with gated cells and obtain a gated clock tree like the 
one shown in Fig. 3. We then perform type-matching synthesis 
to obtain a gated clock tree like the one shown in Fig. 2. 
We evaluate the above clock gating approaches using three 
large ISCAS89 benchmark circuits (s35932, s38417, s38584) 
and eight large ITC99 benchmark circuits (b14, b15, b17~b22). 
These benchmarks have a few to 100 thousand equivalent 
NAND gates. Remember that we randomly replace a certain 
percentage of clock buffers (inverters) with gated cells. Here, 
we try 15%, 30%, and 50%. We consider typical, best, and 
worst corners. The typical/best/worst corner uses a 
typical/fast/worst SPICE model at 25/-40/125 degree C and 
100%/90%/110% VDD supply voltage.  
TABLE III shows the average values of various 
performance indices obtained by the above clock-gating 
approaches. At typical corner, NML is obviously not viable. 
DM (delay-matching) has its latency, skew, and slew close to 
that of NG (non-gating). Note that maintaining clock latency is 
important for re-spinning a design to implement clock gating. 
Delay-matching achieves substantial power saving with respect 
to NG at the expense of more cell areas. Power data include 
switching and leakage powers of clock tree but do not include 
switching and leakage powers of flip-flops. Note that a more 
significant power saving should be obtained from eliminating 
unnecessary switching of flip-flops and the logic driven by flip-
flops. To further verify the data obtained by Encounter, we also 
use Encounter to generate a SPICE netlist of a clock tree and 
use HSPICE to simulate the clock tree to obtain power, latency, 
skew, and slews at buffers and sinks. These data are presented 
in the right-most five columns of TABLE III.  
Compared to type-matching approach SmallT, DM obtains 
a much better latency and better slews at buffers and sinks with 
a slightly worse skew. Also, DM uses smaller cell area and 
incurs smaller wire length. The reason why SmallT uses more 
cell area and larger wire length is because SmallT creates a 
large gated tree (due to smaller fanout driven by per driver) in 
order to satisfy the slew constraint at buffers and sinks. This 
also causes type-matching to create a deep gated tree so that its 
latency is significantly larger than that of a delay-matching 
gated tree. 
We observe from TABLE III that using BigT improves 
latency and slews even though the latency and slews are still 
worse than that of DM. However, BigT incurs larger skew and 
uses considerably more cell area than DM. Since the 
source/drain capacitance of a large-drive gated cell is larger 
than that of its buffer (inverter) counterpart, the latency of a 
BigT gated tree is still larger than that of a delay-matching 
gated tree. 
TABLE III also shows some results at the best and worst 
corners. As one can see, the skews of both delay-matching 
gated tree and type-matching gated tree are not sensitive to 
corner variations. However, it seems that the slews of a delay-
matching gated tree are less sensitive to corner variations than 
that of a type-matching gated tree. The reason for this may be 
that a delay-matching gated tree provides a larger drive than a 
SmallT gated tree does. Or each of its buffers (inverters) drives 
a smaller load than that of a BigT gated tree. 
TABLE III.  RESULTS FOR HOMOGENEOUS GATED TREE SYNTHESES USING DIFFERENT GATING METHODS (BS: WORST SLEW AT BUFFERS (INVERTERS); SS: 
WORST SLEW AT CLOCK SINKS; CTW: TOTAL WIRE LENGTH OF CLOCK ROUTING; CTA: TOTAL CELL AREA OF A GATED CLOCK TREE). 
  Gating methods 
Latency 
(ps)  
Skew 
(ps)  BS (ps)  SS (ps) CTW (um) 
CTA 
(um^2)  
Power 
(mW) 
HSPICE 
Power Latency Skew BS SS 
Typical 
corner  
NG 146.32  15.97  19.40  18.95 12251 1264 2.31 2.17 168.06  17.37  24.60 22.25 
NML 206.78  80.78  31.63  32.46 12271 1267 1.70 1.67 228.02  82.42  41.89 35.71 
DM 150.10  19.84  21.45  20.18  12458  1673  1.86  1.77  173.14  22.16  27.64  24.20  
SmallT 280.47  14.45  38.10  23.00 13387 2558 1.90 1.96 295.35  15.88  42.23 25.83 
BigT 189.48  22.01  27.02  25.09  12517 2349  2.03  2.09  209.42  24.64  37.23  28.05  
Best 
corner  
NG 112.12  16.42  16.33  15.83 12251 1264 2.87 3.06 140.83  18.26  24.12 20.19 
NML 152.95  59.76  24.52  25.59 12271 1267 2.13 2.37 185.52  66.93  36.51 30.70 
DM 116.63  21.03  18.85  17.75 12458 1673 2.39 2.50 146.35  23.46  27.79 22.30 
SmallT 202.27  13.58  27.90  18.44  13387 2558  2.58  3.05  233.46  15.37  37.39  22.26  
BigT 146.07  23.84  22.39  21.29 12517 2349 2.73 3.28 176.86  26.95  35.55 25.96 
Worst   
corner  
NG 210.94  16.57  24.82  24.11 12251 1264 1.98 1.58 231.83  17.42  29.34 27.24 
NML 310.65  123.56  44.25  45.32 12271 1267 1.46 1.22 324.09  118.03  52.85 46.44 
DM 214.59  19.91  26.44  25.35  12458 1673  1.56  1.27  236.43  22.06  31.25  28.98  
SmallT 440.69  17.49  56.38  33.45 13387 2558 1.60 1.34 438.26  18.99  54.87 36.04 
BigT 276.08  21.73  35.74  33.50  12517 2349  1.83  1.44  288.92  23.91  43.12  35.25  
PD
Fil
l P
DF
 Ed
ito
r w
ith
 Fr
ee
 W
rit
er 
an
d T
oo
l
表 Y04 
行政院國家科學委員會補助國內專家學者出席國際學術會議報告 
                                                       100 年 3  月 31  日 
報告人姓名 
 
林榮彬 
服務機構 
及職稱 
元智大學資訊工程系 
教授 
     時間 
會議 
     地點 
Mar. 14, 2011 至 Mar. 18, 2011 
Grenoble, France 
本會核定 
補助文號 
NSC 99-2221-E-155 -087 
會議 
名稱 
 (中文)  
 (英文) Design Automation and Test in Europe 
發表 
論文 
題目 
 (中文)  
 (英文) Clock Gating Optimization with Delay-Matching 
一、參加會議經過 
本會議為全歐洲在 Electronic system design、automation 以及 testing 上最為重要之國際會
議，本大會論文水準高，口頭報告論文接受率約為 25%，會議一共為期五天。第一天為
Tutorial 課程之授課，共有 11 個課程，課程內容涵蓋目前與將來重要議題如 Electronic 
System Level Design and Verification， Design and Verification Challenges for Automotive 
Electronics，Testing TSV-Based 3D Stacked ICs，Low Power SoC Design 等等。接著就是
為期三天的 technical sessions，一共有 88 個 technical sessions 之論文 (選自 950 
submissions)。 最後一天為數個 workshops 之論文發表，這些 workshop 發表一些關於
micro power management， design methods and tools for FPGA-based scientific computing，
embedded parallel computing， 3D IC 及 model-based engineering for embedded system 之
發展等等。大會期間更有 74 家相關廠商參與展出，我們台灣參展之廠商只有一家，另
外亦有一些參展 University Booth 之學校。筆者於三月十六日發表一篇 15 分鐘之口頭報
告論文。本大會共安排了兩場 keynote addresses; 第一場為 Manchester University, 
Computer Science 教授 Steve Furber 主講，主題為 Biological-inspired massively-parallel 
architectures – computing beyond a million processors，主要是介紹他們所設計的平行運算
系統 SpiNNaker，此系統是基於模擬人類大腦運算架構設計而成的，其實這樣的想法並
不新但要實際建造這樣的系統並不容易。第二場 keynote address 是由 Philippe 
Magarshack, Group VP, STMicro, 來主講，講題為 How Technology R&D Leadership Brings 
a Competitive Advantage in the Fields of Multimedia convergence and Power Applications。  
二、與會心得 
台灣應多整取這種大型國際會議在台灣舉辦的機會，藉此與世界各地之先進技術、學術
人員進行各進一步之交流，提升台灣的能見度以及技術發展。 
 
三、建議 
歐洲學者非常注重 Embedded system design 與 System level 設計工具之發展，我們應加
強此領域之研發。 
 
四、攜回資料名稱及內容 
大會論文 CD 光碟一片。 
 
 
附
件
三 
PD
Fil
l P
DF
 E
dit
or 
wi
th 
Fr
ee
 W
rit
er 
an
d T
oo
ls
2. PROBLEM DEFINITION 
Routing of a net on a predefined routing fabric is to find a set of 
wires and a set of vias that can connect all the pins of the net. 
Figures 1(a) and 1(b) respectively show a via-configurable routing 
fabric and the set of wires and vias used for connecting S on 
M3_2 to T on M3_6. The number in the parentheses behind each 
wire’s name gives the wire length. A solid rectangle represents a 
used wire or via. Clearly, routing is highly restricted and creates 
many overhangs. Our routing problem is defined as follows:  
Given a placement design and a via configurable routing fabric, 
find a loop-free route for each net using only the wires given by 
the routing fabric and the vias between the used wires such that 
the total length of wires used by each net and the total length of 
overhangs can be minimized. 
 
Figure 1. Routing on a via-configurable fabric. 
 
Figure 2. A VCLB (left) and M3 fabric overlaying on it. 
Rover is independent of how a via-configurable logic block 
(VCLB) and a routing fabric are designed. However, for ease of 
presentation we here give a brief overview of our VCLB and 
routing fabric. Our VCLB shown on the left of Figure 2 is based 
on the one presented in [7]. We can make use of this VCLB to 
realize different logic gates, including flip-flops, using different 
sets of vias between M1 and M2. Our routing fabric is comprised 
of pre-defined wires on M3 through M5. The preferred direction 
for M3 and M5 is vertical while it is horizontal for M4. M3 fabric 
shown on the right of Figure 2 is designed to gain access to an M2 
pin either from a lower or an upper M3 wire.  
3. IMPLEMENTATION  OF ROVER 
Rover has three major tasks: global routing, detailed routing, and rip-
up and reroute. It is integrated into an industrial standard cell design 
flow as shown in Figure 3. The inputs to Rover mainly include a 
design DEF file, library LEF files, a routing-fabric description file, 
and a global route information file. The output from Rover is a DEF 
file. LEF and DEF files serve as an interface to industrial design tools. 
We devise a language to describe the repetitive patterns of a 
predefined routing fabric. The routing fabric in core area can be 
different from that in I/O-to-core area. For each predefined routing 
fabric, we use a statistical approach to quantifying its routing 
resource, which is presented as a table input to the global routing 
engine. Our detailed routing engine generates a routing resource graph 
for a given predefined routing fabric and uses it to carry out a routing 
task. Optionally, Rover can use some global route information 
produced by another global router to complete detailed routing. 
3.1 Resource Estimation of a Global Bin 
The routing resource of a global bin (G-bin for short) is normally 
quantified as the numbers of routable wires that can co-exist on 
the four sides of the G-bin, respectively. Basically, it is difficult to 
find out the exact resource of a G-bin containing predefined wires. 
Hence, we present a statistical method for it. Given a G-bin 
ሺ ௘ܶ, ௡ܶ, ௪ܶ, ௦ܶሻ where ௘ܶ ,  ௡ܶ ,  ௪ܶ  and ௦ܶ  are the sets of tracks on 
the east, north, west, and south sides of the G-bin, respectively, 
we select a side, say the north side, and generate  | ௡ܶ | pairs of 
൫݊௜, ݎ௝൯ where ݊௜ א ௡ܶ , ׫௜ୀଵ| ೙்| ݊௜ ൌ ௡ܶ   and ݎ௝  is randomly chosen 
from ௘ܶ, ௪ܶ, or  ௦ܶ. We then try to find a route from ݊௜ to  ݎ௝ for 
each ൫݊௜, ݎ௝൯ of the | ௡ܶ | pairs using Dijkstra’s algorithm. We tally 
the number of routable pairs. We repeat the above procedure for a 
large number of times and find the maximum, average, and 
minimum numbers of routable pairs for the north side, 
respectively. We repeat the above process for the east, west, and 
south sides. Up to this moment, we have obtained the maximum, 
average, and minimum numbers of routable pairs for the four 
sides of a G-bin. These numbers form a routing resource table.  
LEF files
(Library)
DEF file
(Design)
Routing 
resources tables
Global Routing
Detailed 
Routing
DEF file
(with routed 
wires)
Description of 
routing fabric
Global route 
information
 
Figure 3. Overview of Rover. 
Table 1 shows the routing resources of I/O and core G-bins obtained 
by our statistical approach. A core G-bin consists of a 4-by-4 array of 
VCLBs shown in Figure 2. An I/O G-bin has the same dimensions as 
that of a core G-bin, but it has different wiring patterns. Tr# denotes 
the number of tracks on a side of a G-bin. Max, Ave, and Min denote 
the maximum, average, and minimum routable pairs on a side, 
respectively. Basically, the number of routable pairs on the south 
(east) side will not equal that on the north (west) side if the pre-
defined wires are not symmetrically laid out on a G-bin. Since the 
south (east) side of a G-bin is the north (west) side of another G-bin, 
we take the number whichever is smaller on the two sides (east and 
west or north and south sides) as the resource capacity of a side.  
Table 1. Routing resources of a G-bin 
 I/O G-bin Core G-bin 
side Tr# Max Ave Min Tr# Max Ave Min 
N 60 55 47.2 38 60 41 33.9 26 
S 60 57 48.6 40 60 42 33.5 26 
E 56 48 41.6 34 56 45 35.6 28 
W 56 47 39.5 32 56 44 34.9 27 
38
PD
Fi
l P
DF
 Ed
ito
r w
ith
 Fr
ee
 W
rit
er 
an
d T
oo
ls
number of reroutings has been tried. Alternatively, we may use a 
negotiation-based method [10] to resolve overflows. We can also 
use other methods [13,15,16] to identify the nets being ripped up. 
3.3 Detailed Routing 
Our detailed routing has three major tasks: routing resource graph 
generation and update, routing of two-terminal nets, and rip-up 
and reroute. After generating a detailed routing resource graph, 
we route two-terminal nets one at a time in the ascending order of 
their net length. When we complete the routing of a multi-pin net, 
we perform redundancy removal to generate a shorter route. Due 
to page limit, we will not elaborate on this issue.  
 Routing resource graph generation and update 
We create a routing resource graph based on the given routing 
fabrics. A vertex represents a wire and an edge represents a 
potential via. There is a potential via at a place where two wires 
on adjacent layers intersect. Each vertex is assigned a weight 
equal to the length of its wire counterpart. We modify a detailed 
routing resource graph to account for Steiner points if they are not 
located at pins. Based on the coordinates of a Steiner point, we 
find all the wires that intersect a small yet user adjustable region 
around the Steiner point. We extract a subgraph solely formed by 
these wires except the M3 wires that overlap pins. We find the 
largest connected component from this subgraph. We then create a 
pseudo Steiner vertex with a weight equal to zero for this Steiner 
point. We place an edge between the pseudo Steiner vertex and 
each of the vertices in the largest connected component. Figure 
6(a) shows a pseudo Steiner vertex S that consists of wires E, F, 
G, and T. Note that a pseudo Steiner vertex corresponds to no 
physical wire. A pseudo Steiner vertex enables more flexible 
routing so that we can dynamically determine a Steiner wire for 
joining two-terminal connections. We will discuss this issue later. 
Note that we do not reserve the wires (vertices) connecting to a 
pseudo Steiner vertex because there are many wires of this sort. 
We also update a routing resource graph based on design DEF and 
library LEF files. We first add a pin vertex for each M2 pin in a 
VCLB with vertex weight equal to its pin length. We create an edge 
between a pin vertex and each of the wires (vertices) that intersect an 
M2 pin. This allows us to dynamically select an M3 wire for gaining 
access to a pin. Initially, we reserve the two M3 wires (see Figure 2) 
used for gaining access to the underlying pin. Once the routing to a 
pin is completed, we set free any unused M3 wire of this sort. Similar 
to the way of handling a pin, we create an I/O vertex for each I/O pad 
and edges between an I/O vertex and any wire (vertex) that touches 
the underlying I/O pad. Rover dynamically determines which wire on 
which layer should be used for connecting to an I/O pad. 
 Routing two-terminal nets 
We route two-terminal nets in ascending order of their net lengths. 
We employ Dijkstra’s algorithm to find a least cost path for a two-
terminal net using only wire segments within the G-bins traversed 
by the corresponding global route. We use an R-tree [23] to 
facilitate finding out only the wire segments within the G-bins of 
a global route. If we fail to find a detailed route within the so-
defined region, we perform rip-up and reroute. 
Our method may create an open if special care is not taken for any 
two connections joining at a pseudo Steiner vertex. We use Figure 6 
to explain this problem and its solution. Given the routing fabric in 
Figure 6(a), we would like to route the two-terminal nets, A to S, B to 
S, and C to S, of the same multi-pin net where S is a Steiner point. 
First, as shown in Figure 6(a), we search for the wires that intersect a 
small region defined for S. We find four wires, T, E, F, and G whose 
vertex counterparts form a connected component. We create a pseudo 
Steiner vertex also called S and establish an edge between S and each 
of the four vertices T, E, F, and G. We then complete routing of the 
two-terminal net between B and S using wires B, D, and E as shown 
in Figure 6(b). It is followed by routing A to S (Figure 6(c)) and 
routing C to S (Figure 6(d)). Note that the routing from C to S has re-
used wire G. We have not yet completed the routing of this multi-pin 
net. Since vertex S corresponds to no physical wire, the routing of the 
net contains an open. To solve this problem, we connect the two paths 
A to S and B to S by a least cost path from E to G (Figure 6(e)) by 
simply placing a via between them. In order to increase the chance of 
finding a path such as the one between E and G, we also employ all 
the vertices and edges outside the aforementioned connected 
component. Rip-up and reroute are performed as usual if such a path 
is not found. The above task is performed after all the two-terminal 
nets of a multi-pin net have been completely routed. Note that our 
routing method implicitly performs a multi-source to multi-sink 
routing for a multi-pin net. 
 
(a). Before routing 
 
(b). After routing B to S               (c). After routing A to S 
 
(d). After routing C to S    (e). Creating a path between B to S and A to S 
Figure 6. Paths joining at pseudo Steiner vertex S. 
 
(a). With B to T, A to T, C to T.   (b). With A to T, B to T, C to T 
Figure 7.  Choices of Steiner wire and routing sequence. 
40
PD
Fil
l P
DF
 Ed
ito
r w
ith
 Fr
ee
 W
rit
er 
an
d T
oo
ls
Table 3. Results by Rover with TSMC 0.18um (RT in minute).  
Circuits LE LEH LF LFH VR delay Ovh (%) RT 
b14 1.41 1.03 1.48 1.07 2.46 1.41 27.4 3 
b15 1.44 1.07 1.51 1.12 2.48 1.29 25.6 4 
b17 1.46 1.04 1.54 1.10 2.47 1.31 28.4 13 
b18 1.50 1.08 1.52 1.09 2.42 1.39 28.3 44 
b19 1.50 1.08 1.51 1.09 2.45 1.41 28.1 66 
b20 1.46 1.03 1.53 1.08 2.29 1.22 29.3 5 
b21 1.45 1.03 1.52 1.08 2.35 1.21 28.7 7 
b22 1.45 1.03 1.53 1.09 2.37 1.34 28.6 11 
Average 1.47 1.05 1.52 1.09 2.39 1.32 28.1  
Table 4. Results by Rover with UMC 90nm (RT in minute). 
Circuits LE LEH LF LFH VR delay Ovh (%) RT 
b14 1.23 1.11 1.28 1.16 3.12 1.18 9.5 3 
b15 1.20 1.10 1.26 1.15 3.29 1.22 8.7 5 
b17 1.27 1.13 1.34 1.19 2.76 1.29 10.7 12 
b18 1.35 1.18 1.43 1.25 2.35 1.28 12.9 34 
b19 1.34 1.17 1.43 1.25 2.34 1.28 12.8 92 
b20 1.37 1.19 1.46 1.26 2.37 1.32 13.3 5 
b21 1.38 1.19 1.46 1.27 2.29 1.29 13.5 4 
b22 1.39 1.20 1.47 1.27 2.29 1.26 13.6 7 
Average 1.32 1.16 1.39 1.22 2.60 1.27 11.9  
5. CONCLUSIONS 
This paper presents a fast structured ASIC router called Rover. 
Rover is tailored to address the specific features of predefined 
routing fabrics. This includes a statistical approach to estimating 
the routing resource of a global bin, the use of pseudo Steiner 
vertices, the algorithm of rip-up and reroute, etc. Rover is fully 
integrated into a standard cell design flow that exploits mostly 
existing tools. Compared to the data obtained by a commercial yet 
non-structured ASIC router, Rover incurs a 47% increase in total 
wire length but only 5% increase when excluding overhang wire 
length. It incurs 32% more delay on the longest path.  
6. REFERENCES 
[1] Zahiri, B. 2003. Structured ASICs: opportunities and 
challenges. In Proceedings of ICCD, 404-409. 
[2] Wu, K. C.  and Tsai, Y. W. 2004.  Structured ASIC, 
evolution or revolution?”  In Proceedings of ISPD, 103-106. 
[3] Okamoto, T., Kimoto, T., and Maeda, N. 2004. Design 
methodology and tools for NEC electronics’ structured ASIC 
ISSP. In Proceedings of ISPD, 90-96. 
[4] Ran, Y and Marek-Sadowska, M. 2006. Designing via-
configurable logic blocks for regular fabric. IEEE Trans. on 
VLSI Systems, Vol. 14, No. 1, (Jan. 2006), 1-14. 
[5] Ran, Y. and Marek-Sadowska, M. 2006. Via-configurable 
routing architectures and fast design mappability estimation 
for regular fabrics. IEEE Trans. on VLSI Systems, Vol. 14, 
(Sept. 2006), 998-1009. 
[6] Pileggi, L., Schmit, H., Strojwas, A. J., Gopalakrishnan, P., 
Kheterpal, V., Koorapaty, A., Patel, C., Rovner, V., and 
Tong, K. Y. 2004. Exploring regular fabrics to optimize the 
performance-cost trade-off. In Proceedings of  DAC, 782-
787. 
[7] Li, M. C., Tung, H. H., Lai, C. C., and Lin, R. B. 2008. 
Standard cell like via-configurable logic block for structured 
ASICs. In Proceedings of ISVLSI, 381–386. 
[8] Shenoy, N. V., Kawa, J., and Camposano, R. 2004. Design 
automation for mask programmable fabrics. In Proceedings 
of DAC, 192-197. 
[9] Betz, V. and Rose, J.  1997. VPR: A new packing, placement 
and routing tool for FPGA research. Lecture Notes in 
Computer Science 1304, 213-222. 
[10] McMurchie, L. and Ebeling, C.  1995. PathFinder: a 
negotiation-based performance-driven router for FPGAs. In 
Proceedings of Third International ACM Symposium on 
Field-Programmable Gate Arrays. 
[11] ISPD 2007 and 2008 global routing contest and benchmark 
suite. http://www.ispd.cc 
[12] FGR: A fairly good router 
http://vlsicad.eecs.umich.edu/BK/FGR 
[13] Cho, M., Lu, K., Yuan, K., and Pan, D. Z. 2007. BoxRouter 
2.0: architecture and implementation of a hybrid and robust 
global router. In Proceedings of  ICCAD, 503-508. 
[14] Xu, Y., Zhang, Y., and Chu, C. 2009. FastRoute 4.0: global 
router with efficient via minimization. In Proceedings of 
ASPDAC, 576-581. 
[15] Chang, Y. J., Lee, Y. T., Gao, J. R., Wu, P. C., and Wang, T. C. 
2010. NTHU-Route 2.0: A robust global router for modern 
designs. IEEE Trans. TCAD, Vol. 29, No. 12 (Dec. 2010). 
[16] Chen, H. Y., Hsu, C. H., and Chang, Y. W. 2009. High-
performance global routing with fast overflow reduction. In 
Proceedings of ASPDAC, 582-587. 
[17] Wu, T. H., Davoodi, A. and Linderoth, J. T. 2009. GRIP: 
Scalable 3D global routing using integer programming. In 
Proceedings of DAC, 320–325. 
[18] Moffitt, M. D., Roy, J. A., and Markov, I. L. 2008. The 
coming of age of (academic) global routing. In Proceedings 
of ISPD, 148-155. 
[19] Alpert, C. J., Li, Z., Moffitt, M. D., Nam, G. J., Roy, J. A., 
and Tellez, G. 2010. What makes a design difficult to route. 
In Proceedings of ISPD, 7-12. 
[20] Kheterpal, V., Strojwas, A. Z., and Pileggi, L. 2004. Routing 
architecture exploration for regular fabrics. In Proceedings of 
DAC, 204-207. 
[21] Ran Y. and Marek-Sadowska, M. 2004. An integrated design 
flow for a via-configurable gate array. In Proceedings of 
ICCAD, 582-589. 
[22] Chu, C. 2004. FLUTE: fast lookup table based wirelength 
estimation technique. In Proceedings of ICCAD, 696-701. 
[23] Guttman, A. 1984. R-Trees: a dynamic index structure for 
spatial searching. In Proceedings of ACM SIGMOD 
International Conf. on Management of Data, 47-57. 
[24] Cong, J., Fang, J., and Zhang, Y. 2001. Multilevel approach to 
full-chip gridless routing. In Proceedings of ICCAD, 396-403. 
[25] Chang, Y. W. and Lin, S. P. 2004. MR: A new framework 
for multilevel full-chip routing. IEEE Trans. on TCAD, Vol. 
23, No. 5 (May 2004), 793 - 800. 
 
42
PD
Fil
l P
DF
 Ed
ito
r w
ith
 Fr
ee
 W
r t
er 
an
d T
oo
ls
國科會補助計畫衍生研發成果推廣資料表
日期:2011/10/27
國科會補助計畫
計畫名稱: 結構化特殊應用積體電路之面積，功率，效能最佳化之元件，設計工具與方法
(I)
計畫主持人: 林榮彬
計畫編號: 99-2221-E-155-087- 學門領域: 積體電路及系統設計
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
