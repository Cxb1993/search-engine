(4) Star War: Episode I, (5) The Lord of The Rings II, (6) Jurassic Park, (7) Harry Pot-
ter and the Chamber of Secrets, (8) The Lord of The Rings I, (9) Finding Nemo, (10)
Independence Day。 當中除了“Finding Nemo”為一部3D 電腦動畫外, 其他的九部電影都
大量地使用了電影視覺效果。 事實上, 其中的六部電影 (1,2,5,6,8,10) 亦同時獲得上映當年
的奧斯卡 (Academy Awards)最佳視效獎 (Best Visual Effects)的肯定。由此可見,電影視
效不僅已成為今日電影製作不可或缺的一部份,更是賣座的決勝點。
在諸多電影視覺效果技術中, 透明度估計 (matting) 與影像合成 (compositing) 實為最
基本也最重要的元件。 電影製作者利用影像合成技術將演員由一段影片中取出, 再貼入另一
場景的背景影片中, 以創造演員處在新的背景場景的效果。 例如, 在電影阿甘正傳 (Forrest
Gump) 中, 電影製作者首先拍攝湯姆漢克斯 (Tom Hanks) 握手的影片, 再將他自影像中取
出,貼入甘迺迪與他人握手的影片中,營造出湯姆漢克斯與甘迺迪握手的假象。為了完成逼真
的合成影像,有許多技術上的問題必須考慮,例如攝影機與光影的配合等。另一重要技術就是
透明度估計, 在透明度估計問題中, 我們要將所望物件 (object), 如上例中的湯姆漢克斯, 由
所攝得的影像中取出, 去掉不要的背景。 特別值得注意的是我們還必須估計物件的透明度圖
(matte),以避免合成時在物件邊界 (object boundary)產生鋸齒效果 (aliasing artifacts),此
透明度圖對於描述具複雜邊界的物件,如髮絲,樹枝及煙霧,尤其重要。
為了有效估計透明度, 工業界中最常使用藍幕透明度估計法 (blue-screen matting)。 讓
演員在一個光照均勻的藍色布幕前表演, 再利用藍色的比例來估計透明度。 使用藍幕雖然可
以取得高品質的透明度圖,但有以下缺點: (1)拍攝場景受限,必須在可以架設藍幕的地方拍
攝。 (2)打光不易,藍幕透明度估計法需要均勻的光照,有時會與營照場景氣氛所需的燈光衝
突。 (3)昂貴,為了明亮且均勻的藍幕,必須使用特殊的布料或使用特製的塗料。
除了上述缺點外, 有時, 我們只是要在影片中插入物體, 如在電影侏儸紀公園 (Jurassic
Park) 中, 電影製作者首先拍攝演員在叢林中行進的影片, 再將電腦生成的恐龍插入演員與
叢林之中,此時,就不適宜使用藍幕。 在此種應用中,我們就須處理自然背景透明度估計 (nat-
ural matting) 的問題, 以往, 處理此問題最常見的方法為物件描繪 (rotoscoping)。 然而, 此
法不但耗時且不能處理具複雜邊界的物件。
綜言之, 一個有效且快速的自然背景透明度估計系統, 不僅可以節省大量的人力與金錢,
更能做到一些以往無法達成的視覺效果。本計劃希冀結合物件選取的便利性及透明度估計的
一般性, 發展一個易於使用的單一圖片快速物件選取及透明度估計系統。 讓使用者只需藉由
標出大概的前景及背景, 而非精細的三分圖, 即可估計前景的透明度圖。 系統包含兩大元件:
透明度估計法及物件選取演算法,分述於下兩章。
2 透明度估計法函式庫 (matting library)
我們實作了一個透明度估計法函式庫以便於實驗及測試各元件, 此函式庫可分為三大元
件: Algorithm, MatteData和 Iterator。 Algorithm主要負責透明度估計演算法的實作,例如
透明度估計演算法等; MatteData主要處理圖形前景、背景、透明度 (alpha)、三分圖 (trimap)
等相關操作; 而 Iterator 則肩負演算法的未知像素處理順序之責。 其間關係如圖 1 所示。 基
於此架構可藉由繼承舊有元件而開發新的元件, 並能和其它元件進行搭配及比較, 因此可做
2
2.1.2 帕松透明度估計法
帕松透明度估計法[5]利用色彩的梯度 (gradient), 透明度圖的梯度應和輸入圖的色彩成
正比
Oα(p) ≈ 1
F (p)−B(p)OC(p) , (5)
在此, p 為圖上一點, α(p) 為該點之透明度, C(p) 為該點的顏色, F (p) 為該點的前景顏色,
(B)為該點的背景顏色, O為梯度運算。 因此,帕松透明度估計法首先由輸入圖 C 求出色彩
梯度 OC, 再藉由前景及背景的色彩估計, 將色彩梯度 OC 轉成透明度梯度 Oα, 最後, 再由
透明度梯度來設定帕松方程式 (Poisson equation)來反求透明度圖 α。 亦即, 此法找一透明
圖 α∗ 使得其梯度與方程式 (5)所得梯度差距最小:
α∗ = argmin
α
∫
p∈Ω
|Oα(p)− 1
F (p)−B(p)OC(p)|
2dp, (6)
在此, F (p)及 B(p)是估計的前景及背景色彩, Ω為未知區域。
2.2 Iterator
在 Algorithm 運行中, Algorithm 會不斷向 Iterator 要求取得下一個待處理的點座標,
因此 Iterator 肩負決定全部未知區域 (unknown region) 的尋訪之責。 Iterator 對於貝氏透
明度估計法至為重要, 而對於帕松透明度估計法則較無影響, 原因是貝氏透明度估計法對於
每個點都要蒐集其鄰近區域的統計量, 因此不同的處理順序將會造成不同的結果。 我們實作
兩種 Iterator: BayesianIterator與 TwinQueueIterator,詳見後述。
2.2.1 BayesianIterator
BayesianIterator採用剝洋蔥順序 (onion peel order),由未知區域的邊界由外向內均勻
地擴展, 而對於和邊界相同距離的所有點而言, 我們採用 「細者優先」, 亦即未知區域的前景
邊界和背景邊界距離較短者,會優先於未知區域的前景邊界和背景邊界距離較長者。
2.2.2 TwinQueueIterator
TwinQueueIterator 首先會依 BayesianIterator 的作法建立一尋訪順序佇列 (queue)
QA。 每當有一點被計算完成, 若該點的透明度值低於或超過一閾值 (threshold) (亦即該點
很接近前景或很接近背景),且該點的顏色與合成圖的顏色差低於一閾值,則我們有較大的信
心相信這個點的計算結果是正確的, 因此將優先計算該點鄰近之點, 作法為將該點的鄰近之
點加入另一尋訪順序佇列QB。 當要決定下一點時,首先從QB 取出下一未計算之點,若QB
已空則從 QA 取出下一未計算之點。
2.3 Model
在貝氏透明度估計法中, 絕大多數的時間在於蒐集鄰近區域的統計資訊。 因此我們將鄰
近區域的蒐集獨立成一個貝氏透明度估計法的元件, 以利實驗不同的蒐集方式。 目前已實作
三個蒐集方式: GaussianModel、FastModel、SimpleModel。
4
圖 4: 使用 BayesianIterator 與 TwinQueueIterator 比較。 左邊:BayesianIterator, 右
邊:TwinQueueIterator
GaussianModel FastModel SimpleModel
time(second) 6.550 3.323 6.242
表 1: GaussianModel、FastModel和 SimpleModel執行時間比較
3 物件選取演算法 (object selection)
不管是貝式或帕松透明度估計法, 都須要使用者指定三色圖, 明確地區分出影像中的前
景、背景與未知區域。 即使是小張的影像,手動編輯三色圖通常也需要數分鐘以上的時間。
為了加速這個過程,我們在系統中實作了 GrabCut演算法[4],讓使用者僅須拉出一個包
含前景物件的方框,程式會自動產生一分二元遮罩 (binary mask)區分出大致的前景與背景,
此時使用者可將邊界擴張數個像素作為未知區域,或是作進一步的編輯以求得更好的結果。
3.1 GrabCut演算法使用的機率模型
GrabCut 使用高斯混合模型(Gaussian Mixture Model) 來估計每一個像素出現在前景
或是背景的機率。 當使用者畫出包含前景的方框後,演算法先將方框內的所有像素視為前景,
方框外的所有像素視為背景,接著為前景和背景分別建立它們的高斯混合模型。
一旦建立好前景與背景的機率模型, 演算法就可以估計方框中每一個像素分別出現在前
景或背景的機率,並依據此機率的大小,指定每個像素被指定為前景或背景時,所須要負擔的
成本。 此演算法也考慮到連續性 (smoothness term), 亦即臨近並且顏色接近的像素傾向於
同時被分配為前景或同時被分配為背景。
3.2 使用 max-flow min-cut求取最佳解
若將方框中的每個像素視為一個圖 (graph) 的節點, 並把所有節點分別連接到額外兩個
不同節點F與B,則任一個分離前景與背景的方法,都可以對應到一個把此圖中F與B分離的
切法 (cut)。 因為演算法已指定每個像素被分為前景或背景時所須負擔的成本,所以分離前景
與背景的問題可轉變為將此圖形做最小權重分割 (min-cut) 的問題。 通常這 個問題可以借
由求取最大流量 (max-flow)來得到最佳解。
6
