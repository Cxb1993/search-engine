Part II: An Efficient and Scalable Pattern Matching 
Scheme for Network Security Applications  
 
  
   II.1  Abstract……………...................................................................... 13 
  
   II.2  Introduction………………………............................................... 13 
  
   II.3  The Aho-Corasick Algorithm…………………………................ 15 
  
   II.4  Related Works……………………………………….................... 17 
  
      II.4.1  Banded-row format……..…................................................. 17 
  
      II.4.2  ClamAV…………………………………………................ 18 
  
   II.5  Improving The Banded-row Format AC....................................... 19 
  
   II.6  Our Proposed Scheme………………………………...………… 20 
  
Part III: A High-Performance Memory-Efficient Pattern 
Matching Algorithm and Its Implementation  
 
  
   III.1  Abstract…………………………………………………............ 25 
  
   III.2  Introduction…………………………………………………...... 25 
  
   III.3  The Bit-Split Aho-Corasick Algorithm………………………… 27 
  
   III.4  Our Proposed Algorithm……………………………………...... 30 
  
   III.5  FPGA Implementation…………………………………………. 33 
  
   III.6  Conclusion……………………………………………………… 35 
  
Bibliography……………………………………………………………… 37 
  
 
 
 II
比對(String Matching)的演算法實現於 FPGA，並配合嵌入式作業系統(Embedded 
Operation System)以軟體，韌體與硬體互相整合之開發方法，以達到硬體加速軟
體整合協調之目的。關於這個子計畫的目標是開發高效率的樣本匹配演算法為主
要項目。我們設計了三個樣本匹配演算法並且分別發表在三個不同的國際 IEEE
會議。 
 
關鍵字：嵌入式系統、字串比對、正規語言、網路安全 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 IV
  
 
 
 
 
Part I: 
Generalized Aho-Corasick Algorithm for 
Signature Based Anti-Virus Applications  
 
 
 
 
 
 
 
 1
used to detect and prevent the outbreak of an attack because an infected host is likely 
to behave differently from a normal host. As an example, a host infected by some 
virus/worm may try to infect other vulnerable hosts on the Internet with port/address 
scanning. Therefore, one can detect an infected host with the observation of high new 
connection attempt rate or high failure ratio of new connection attempts [5]. Behavior 
anomaly can be used to detect the so-called “zero-day” attacks. However, it tends to 
create false positives if the normal behavior cannot be precisely specified. Finally, 
pattern matching is a technique of looking for specific patterns in the payload of a 
packet or across packets. One can utilize the strings of malicious codes contained in 
viruses/worms for detection. Although it is limited to known viruses/worms with 
identified signatures, the pattern matching technique is quite valuable because of its 
accuracy. Fortunately, the signature of a new virus/worm can often be quickly derived 
nowadays once it occurs.  
There are some well-known pattern matching algorithms such as 
Knuth-Morris-Pratt (KMP) [2], Boyer-Moore (BM) [3], and Aho-Corasick (AC) [4]. 
The KMP and BM algorithms are efficient for single pattern matching but are not 
scalable for multiple patterns. The AC algorithm pre-processes the patterns and builds 
a finite automaton which can match multiple patterns simultaneously. Another 
advantage of the AC algorithm is that it guarantees deterministic performance under 
all circumstances. As a consequence, the AC algorithm is widely adopted in various 
systems, especially when worst-case performance is an important design factor. 
Unfortunately, the AC algorithm was developed only for strings while virus/worm 
signatures could be specified by regular expressions. It is well known that a regular 
expression is equivalent to a non-deterministic finite automata (NFA) which in turn is 
equivalent to a deterministic finite automata (DFA). As a consequence, a 
straightforward approach to identify matches of a regular expression is to construct a 
 3
We assume that a goto graph G for the set of strings W has been constructed with 
the AC algorithm. Let R denote the start state of graph G. If W is an empty set, then 
graph G contains only state R with g(R, a) = R for all symbols a.  
Some definitions are needed. We say u is a prefix and v is a suffix of the string 
uv. Moreover, u is a proper prefix if v is not empty. Likewise, v is a proper suffix if u 
is not empty. String u is said to represent state P in a goto graph if the shortest path 
from the start state to state P spells out u. The start state is represented by the empty 
string. String u is said to represent state Q relative to state P if the shortest path in the 
goto graph from state P to state Q spells out u.  
Note that there might be a self-loop at the start state. However, it becomes a tree 
after removing the self-loop, if exists. In the following definitions, we ignore the 
self-loop. We call state S the father of state P if there exists a symbol a such that g(S,a) 
= P. State P is said to be a descendent of state S if there exists a non-empty string u 
which represents state P relative to state S. The tree which consists of state S and all 
its descendent states is called the sub-tree of S. A goto graph G is said to be 
“extended” with string u if G is augmented with u by the enter procedure (without the 
output function) of the AC algorithm. We say a goto graph G is extended with string u 
from state P if G is augmented with u by the enter procedure (again, without the 
output function) using state P as the start state. Extension of a goto graph with a string 
includes creation of new states (if necessary) and generation of the goto function. We 
say a string u or a regular expression RE is “added” to the goto graph G if a valid 
pattern matching machine for W ∪{u} or W ∪RE is constructed by augmenting 
graph G. Computation of the output function is not considered because it is the same 
as that in the AC algorithm. For convenience, we call any state with non-empty output 
function a final state.  
Our constructed finite state pattern matching machine may consist of multiple 
 5
state S in G' so that the string representing S' (relative to NR) is the same as 
the string representing S (relative to R).  
5. Compute independently the failure functions for graphs G' and D". If, for 
some state S' in D", f(S') = P' is a virtual state, then repeatedly apply P' ← 
f(P') until P' is not a virtual state and assign f(S') = P'. 
6. For every state Q' in G with representing string us1, modify f(S) for every 
state S in the sub-tree of Q' by assigning f(S) = f(S') where S' is the 
corresponding state in D" of S in G'. Note that output(S) is updated as 
output(S) ∪{RE1 } if the representing string of S is   us1 vs2 .  
7. Delete the virtual states, i.e., use graphs G' and D' for traversal. 
 
I.4.1  ? Operator 
Assume that RE1= s1?s2. The procedure for adding s1?s2 to G is described 
below.  
1. Extend the goto graph G with s1. Denote by Q the state represented by s1. 
2. Extend the resulting graph from state Q with as2 for all symbols a in Σ. 
3. Determine the failure function for the resulting graph. 
The basic idea of the above procedure is to extend the original goto graph G with 
s1as2 for all possible symbols a. In other words, the regular expression s1?s2 is 
expanded into strings s1as2 for all possible symbols a. It is not hard to see that the 
pattern matching machine constructed with the above procedure is valid. 
 
I.4.3  {min, max} Operator 
Assume that RE1 = s1{min, max}s2. A straightforward solution of adding RE1 
to G is to add s1 ?k s2 to G for all k = min, …, max, where ?k denotes k repetitions of 
 7
In this section, we consider the case of adding multiple regular expressions RE1, 
RE2, …, and REn to a goto graph G built with a set of strings W. Since the ? operator 
can be expanded or replaced by the {min, max} operator, we will focus on multiple 
instances of * and {min, max} operators.  
 
I.5.1 Regular Expressions with * Operators Only 
Assume that RE1, RE2, …, and REn contain only * operators. To begin with, let 
us consider a simple example with only two instances of * operators RE1 = s1*s2*s3. 
For this case, the following procedure is performed to construct the pattern matching 
machine. 
1. Create two duplicated graphs of G, called D1 and D2, with start states NR1 
and NR2, respectively. 
2. Extend G with s1s2s3, D1 with s2s3, and D2 with s3. Denote the resulting 
graphs by G', D'1 , and D'2 . Let Q1, Q2 (in graph G'), and P (in graph D'1 ) 
denote, respectively, the states represented by s1, s1s2, and s2 relative to 
NR1.  
3. Compute the failure functions independently for graphs G', D'1 , and D'2 . 
4. For every state S in the sub-tree of a companion state of Q2 or the sub-tree 
of a companion state of P, modify f(S) = P', the longest proper suffix state of 
S in D'2 . The output function output(S) is updated as output(S) ∪{  RE1 } 
if the representing string of S is us1vs2ws3 . For every state S in the 
sub-tree of a companion state of Q1 but not in the sub-tree of any 
companion state of Q2, modify f(S) = P', the longest proper suffix state of S 
in D'1 . The output function output(S) is updated as output(S) ∪{ RE 1 } if 
the representing string of S is us2 vs3 .  
 9
number of forked traversals for clean traffic, as long as the first fragment is 
sufficiently long. Therefore, in real applications, one can set a limit, say 8, on the 
number of concurrent forked traversals for each traffic flow. Comparison of the 
performance of our proposed pattern matching machine with that of the ClamAV 
implementation will be reported in a future paper.  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 11
 II.1 Abstract 
Because of its accuracy, pattern matching technique has recently been applied to 
Internet security applications such as intrusion detection/prevention, anti-virus, and 
anti-malware. Among various famous pattern matching algorithms, the Aho-Corasick 
(AC) can match multiple pattern strings simultaneously with worst-case performance 
guarantee and is adopted in both Clam AntiVirus (ClamAV) and Snort intrusion 
detection open sources. The AC algorithm is based on finite automaton which can be 
implemented straightforwardly with a two-dimensional state transition table.  
However, the memory requirement prohibits such an implementation when the total 
length of the pattern strings is large. In this part we present a novel implementation 
which requires small memory space and achieves high throughput performance. 
 
II.2 Introduction 
Pattern matching has been an important technique in information retrieval and text 
editing for many years. Recently, it has been applied to Internet security for signature 
matching to detect virus, worms, intrusion, etc., because of its accuracy. 
There are some well-known pattern matching algorithms such as 
Knuth-Morris-Pratt (KMP) [2], Boyer-Moore (BM) [3], and Aho-Corasick (AC) [4].  
The KMP and BM algorithms are efficient for single pattern matching but are not 
scalable for multiple patterns.  The AC algorithm pre-processes the patterns and 
builds a finite automaton which can match multiple patterns simultaneously.  
Another advantage of the AC algorithm is that it guarantees deterministic 
performance under all circumstances.  It can be shown that the number of state 
transitions is at most 2n-1 for an input text string of length n. In fact, this number can 
 13
organized as follows.  In Sections II.3 and II.4, we review the AC algorithm and 
some related works, respectively. Section II.5 presents our idea which improves the 
throughput performance of the banded-row format AC. Section II.6 contains our 
proposed scheme. 
 
II.3 The Aho-Corasick Algorithm  
In this section, we briefly review the AC algorithm of constructing a finite state 
pattern matching machine for a given set of pattern strings Y = { }.  
Basically, the AC pattern matching machine is dictated by three functions: a goto 
function g, a failure function f, and an output function output.  Figure 1 shows the 
pattern matching machine for Y = {he, she, his, hers} [4]. 
1 2, ,..., yp p p
 
(a) The goto function. 
 
S 1 2 3 4 5 6 7 8 9 
f(S) 0 0 0 1 2 0 3 0 3 
(b) The failure function. 
 
S output(S)
2 {he} 
5 {she, he} 
7 {his} 
9 {hers} 
(c) The output function. 
Figure 1: The AC pattern matching machine for Y = {he, she, his, hers}. 
 
 15
Initially, the start state is assigned as the current state and the first symbol of T is 
the current input symbol. 
It was proved that the pattern matching machine makes at most 2n-1 state 
transitions in processing an input text string of length n. This is an important property 
because it provides performance guarantee in the worst case. Notice that failure 
transitions can be eliminated if the goto function is replaced with the next move 
function so that the pattern matching machine becomes a deterministic finite 
automaton. In this case, the number of state transitions is exactly n when an input text 
string of length n is processed.  
 
II.4 Related Works  
It is clear that, in an AC pattern matching machine, the goto function requires 
much more storage than the failure and the output functions. A straightforward 
implementation of the goto function is to use a two-dimensional state transition table.  
However, the memory requirement for such an implementation may become 
prohibitively large when the total length of the pattern strings is large. Two related 
compression schemes which are used in Snort and ClamAV are briefly reviewed 
below. 
II.4.1 Banded-row format 
The state transition table of the goto function in the AC pattern matching machine 
is often a sparse matrix because it is likely to contain only a few nonfail elements in 
each row. There are various compression schemes to reduce the memory requirement 
of a sparse matrix [7], [8]. The banded-row format [7] proposed by Marc Norton, the 
Snort IDS Team lead at Sourcefire Inc., is an effective compression scheme which 
allows fast random access to the data. 
 17
ClamAV uses a variation of the AC algorithm. To look up each input symbol 
quickly, ClamAV constructs a trie structure with a 256-element lookup array for each 
8-bit symbol. The memory requirement of ClamAV depends on how deep the trie is.  
Since the AC algorithm constructs an automaton of depth equal to the longest pattern 
length, the memory requirement of ClamAV’s structure would be unacceptably large 
because some patterns are of length more than 2,000 bytes.  Therefore, ClamAV 
modifies the AC algorithm so that the trie is constructed only to some maximum 
depth, and all patterns with the same prefix are stored in a linked list under the 
appropriate leaf state.  The maximum depth is dictated by the shortest pattern length, 
which is currently two bytes.  Figure 2 shows the ClamAV trie structure. 
 
 
Figure 2: The ClamAV trie structure. 
 
ClamAV follows the trie transition to process each input symbol. When a leaf 
state is visited, all patterns on its linked list are checked using sequential string 
comparisons. As a result, the throughput performance of ClamAV may severely 
degrade if a leaf state with a linked list containing a large number of patterns is 
visited.  
 
 19
In our proposed scheme, we classify states according to the number of child states 
and whether or not pattern strings are matched. Note that there might be a self-loop at 
the start state. However, the goto graph becomes a tree after removing the self-loop, if 
exists. In the following definitions, we ignore the self-loop and consider the goto 
graph as a tree. 
State R is said to be a child state of state S if there exists a symbol σ  such that 
g(S,σ ) = R. State S is said to be a branch state, a single-child state, or a leaf state, if it 
has at least two child states, exactly one child state, or no child state, respectively.  
Moreover, state S is said to be a final state if output(S) is not empty. It is clear that a 
leaf state is always a final state but not the converse. Finally, state S is said to be an 
explicit state if it is a branch state or a final state. 
We store all pattern strings and some data structures for the states on the goto 
graph. The data structures for branch, single-child, and leaf states are different.  
Assume that state S is a branch state. In this case, we store f(S) and g(S,σ ) for all 
possible input symbols σ . As a result, we also have a two-dimensional state 
transition table. However, the number of rows is only equal to the number of branch 
states. It is not hard to see that the number of branch states is at most y-1 if there are y 
pattern strings. To save space, the banded-row format is adopted to compress the 
two-dimensional table. To speed up matching procedure, we adopt the idea proposed 
in Section II.5. For convenience, the resulting state transition table is named the 
Branch State Transition (BST) table. 
Assume that state S is a single-child state. We say state R is a descendent state of 
state S if state R is a child state of state S or a descendent state of some child state of 
state S. In other words, state R is a descendent state of state S if there exist strings u 
and v such that u represents state S and uv (concatenation of u and v) represents state 
R for some nonempty string v. Furthermore, state R is said to be a descendent explicit 
 21
abcda and abba, which can be used as S.pattern. In our example, we picked pattern 
string abcda with identification 0. The data structures for the other single-child states 
can be obtained similarly. Figure 4 shows the data structures of our proposed scheme 
for this example.  
 
Branch state Band-width Start index Band values 
0 8 0 1 0 8 0 0 0 0 0 
2 2 1 6 3       
8 4 0 11 0 8 9     
(a) The Branch State Transition (BST) table. 
 
S S.pattern S.position S.distance
1: 0 1 1 
3: 0 3 2 
4: 0 4 1 
6: 1 3 1 
9: 2 2 1 
11: 3 2 2 
12: 3 3 1 
(b) Data structure for single-child states. 
 
S 1 2 3 4 5 6 7 8 9 10 11 12 13 
f(S) 0 0 8 9 10 0 1 0 0 1 1 2 3 
(c) The failure function. 
 
S output(S)
5 {0, 2} 
7 {1} 
10 {2} 
13 {3} 
others ∅  
 
 
 
 
 
 
(d) The output function. 
 
Figure 4: Data structures of our proposed scheme for Σ = {a, b, c, d, e, f, g, h} and 
Y = {abcda, abba, cda, cabc}.  
 23
 
 
III.1 Abstract 
Because of its accuracy, pattern matching technique has recently been applied to 
Internet security applications such as intrusion detection/prevention, anti-virus, and 
anti-malware. Among the various pattern matching algorithms, the Aho-Corasick (AC) 
can match multiple pattern strings simultaneously with worst-case performance 
guarantee and thus is widely adopted. However, the throughput performance of the 
original AC may not be satisfactory for high speed environments because only one 
symbol is processed in an operation cycle. In this paper we present an extension of the 
AC algorithm where multiple symbols are processed in an operation cycle to improve 
throughput performance. In our proposed scheme, all pattern strings, and the input 
text string as well, are divided into K substrings, if K symbols are processed in an 
operation cycle. Moreover, K pattern search engines are employed to scan the text 
substrings in parallel. As a result, the throughput performance can be improved by K 
times. We implemented our proposed pattern matching scheme with Xilinx FPGA and 
achieved more than 4.5Gbps throughput for K = 4. 
 
III.2 Introduction 
Pattern matching has been an important technique in information retrieval and 
text editing for many years. Recently, it has been applied to Internet security for 
signature matching to detect virus, worms, intrusion, etc. Because of the rapid 
advances of computer and network technologies, it becomes increasingly desirable for 
a high-performance pattern matching module that achieves at least 10Gbps 
throughput. 
There are some well-known pattern matching algorithms such as 
 25
scheme, an L-bit symbol is divided into L/m equal-size sub-symbols. For example, if 
L = 8 and m = 2, then every symbol is divided into 4 sub-symbols and each 
sub-symbol is composed of 2 bits. The sub-symbols derived from the same positions 
of the symbols in all pattern strings form a group. As a result, there are L/m groups of 
sub-symbols. A sub-trie is built for each group of sub-symbols. It is clear that the 
number of possible inputs reduces from 2L  for the original trie to  for each 
sub-trie. Therefore, the space requirement reduces from O( 2
2m
L ) to O( 2m /m ), which is 
significant because in most applications L = 8 and one can choose m = 2. Since we 
adopt the bit-splitting idea in our implementation, details of this scheme is described 
in Section III.3. 
L
In this paper, we present a generalization of the AC algorithm where multiple 
symbols are processed in each operation cycle. Different from the solution proposed 
in [9], our approach divides every pattern string into K substrings and construct tries 
for substrings, where K is the number of symbols processed in each operation cycle. 
The text string is also divided into K substrings. Besides, we use K search engines to 
scan text substrings in parallel. Experimental results show that our scheme can 
achieve more than 4.5Gbps throughput for K = 4 and in general requires less space 
than the scheme proposed in [9]. 
The rest of this paper is organized as follows. Section III.3 contains a review of 
the bit-split AC algorithm. In Section III.4, we present our generalization of the 
high-performance AC algorithm. FPGA implementation and experimental results are 
discussed in Section III.5. Finally, we draw conclusion in Section III.6. 
  
III.3 The Bit-Split Aho-Corasick Algorithm 
In this section, we review the bit-split AC algorithm which was proposed in [10]. 
 27
finds a match of S in operation cycle i for all j, 1≤ j ≤L/m. To check whether or not all 
tiles find matches of the same pattern string in the same operation cycle, the pattern 
strings are numbered and a partial match vector (PMV) is associated with every state 
of each sub-trie. The length of the PMV is f bits if there are f pattern strings. Consider 
the 
thj  sub-trie. The  bit of the PMV associated with state x is a 1 iff pattern 
string k is matched in state x. See Figure 6 for the PMVs of the fourth sub-trie shown 
in Figure 5. 
thk
Since every symbol is divided into L/m sub-symbols, the number of possible 
inputs reduces from 2L  for the original trie to  for each sub-trie. Consequently, 
the space requirement reduces significantly from O( ) to O( L/m ). The bit-split 
idea is adopted in our implementation to be presented in Section III.5. 
2m
2L 2m
 
 
Figure 5(a)：The original AC trie and 5(b)：the fourth sub-trie for pattern strings {he, 
she, his, hers} with m=2. 
 
 29
text string T is also divided into K substrings , , …, and  so that the  text 
substring = if i
1T 2T KT
thi
iT  ...i K i q K it t t ′+ +  r′≤  or it t ( 1)...K i q K it ′+ − +  i  Tf i here are 
K parallel pattern search engines, denoted by 1
r ′> .
E , 2E , …, and KE , each with its own 
AC trie that is the same as *PG rch engine iE  s ns text substring iT . . Sea ca
Depending on the values of q and r, there are various conditions for the pattern 
string S to be matched. As an example, for r = 0, search engine  finds a match of 
substring  at the end of operation cycle C for all i, 1
iE
iS ≤ i ≤K, is one possible 
condition. As another example, for r = 1, pattern string S is matched if search engine 
 finds a match of substring iE 1iS −  at the end of operation cycle C for all i, 3 i K, 
and search engines 
≤ ≤
1E  and 2E  find matches of substrings  and , respectively, 
at the end of operation cycle C+1.  The complete conditions for pattern string S to be 
matched are summarized in Table 1. The proof of the correctness of the listed 
conditions is straightforward and thus is omitted. 
KS 1S
Figure 7 illustrates an example of all the matches for S = abcdefghij and K = 6. 
In this example, we have = ag, = bh, = ci, = dj, = e and = f. There are 
totally six possible situations for pattern string S to be matched. 
1S 2S 3S 4S 5S 6S
 
Figure 7: All the possible condition to find a match of pattern string S = abcdefghij 
when K = 6. 
 31
renumbered as follows. Given n = qK + r, define = . After the 
renumbering, the conditions for pattern string S to be matched for the case q > 0 and r 
> 0 become (a) 
'
iS ( ) modi r KS +
iE  finds a match of , 1'iS ≤ i ≤K, at the end of operation cycle C or 
(b) l, 2 l K, ∃ ≤ ≤ l iE +  finds a match of 
'
1iS + , 0≤ i ≤K-l, at the end of operation cycle 
C and  finds a match of jE
'
1K l jS − + + , 1≤ j ≤ l-1, at the end of operation cycle C+1, 
the same as those for the case q > 0 and r = 0. As for the case q = 0 and r > 0, the same 
conditions can be applied as long as every search engine reports a match for null 
substring , r+1iS ≤ i K, unconditionally at the end of every operation cycle. As a 
consequence, we have unified conditions for pattern string S to be matched. 
≤
 
III.5 FPGA Implementation 
We implemented our proposed multi-symbol AC pattern matching algorithm 
with Xilinx Virtex2 Pro-30 FPGA. Figure 8 shows the architecture of our 
implementation. The bit-split idea is adopted to reduce memory requirement. The 
number of symbols processed in an operation cycle is four (i.e., K = 4) in our 
implementation. Note that since each pattern string is divided into four substrings, it is 
necessary to distinguish which substring is found when a search engine reports a 
match. Assume that there are f pattern strings which are numbered from 0 to f-1. As a 
result, the length of every PMV is 4f bits and the  bit of a PMV associated 
with state x is a 1 iff the  substring of pattern string i is matched in state x. 
(4 )thi k+
thk
 
 33
 Figure 9: Comparison of total memory requirement. 
 
The clock rate of our synthesized logic can be operated higher than 140 MHz. In 
other words, our proposed algorithm can easily achieve more than 4.5Gbps 
throughput with K = 4. Obviously, the throughput can be further improved as long as 
we increase the value of K. The tradeoff is larger space requirement and more 
complicated verification logic. We believe that K = 8 can be implemented with 
state-of-art FPGA development platform to achieve throughput higher than 10Gbps. 
 
III.6 Conclusion 
We have presented in this paper an extension of the Aho-Corasick pattern 
matching algorithm where multiple symbols are processed in an operation cycle. In 
our proposed scheme, K search engines are employed to scan the input text substrings 
in parallel to improve system performance. Since every pattern string is divided into 
K substrings, it is possible for each individual search engine to output a false positive. 
Thus some verification logic is needed to eliminate false positives. We showed that 
the match conditions and the verification logic can be simplified if the substrings are 
 35
Bibliographies 
 
[1] Clam anti virus signature database, www.clamav.net. 
 
[2] D. E. Knuth, J. H. Morris, and V. R. Pratt, “Fast pattern matching in strings,” TR 
CS-74-440, Stanford University, Stanford, California, 1974. 
 
[3] R. S. Boyer and J. S. Moore, “A fast string searching algorithm,” 
Communications of the ACM, Vol. 20, October 1977, pp. 762-772. 
 
[4] A. V. Aho and M. J. Corasick, “Efficient string matching: an aid to bibliographic 
search,” Communications of the ACM, Vol. 18, June 1975, pp.333-340. 
 
[5] S. E. Schechter, J. Jung, and A. W. Berger, "Fast detection of scanning worm 
infections." 7th International Symposium on Recent Advances in Intrusion 
Detection, French Riviera, September 2004. 
 
[6] N. Tuck, T. Sherwood, B. Calder, and G. Varghese, “Deterministic 
memory-efficient string matching algorithms for intrusion detection,” IEEE 
Infocom, 2004. 
 
[7] Marc Norton (the Snort IDS Team), “Optimizing pattern matching for intrusion 
detection,” Sourcefire Inc., September 2004. 
 
R.E. Tarjan and A.C.-C. Yao, “Storing a sparse table,” Communications of the 
ACM, vol. 22, pp. 606-611, November 1979. 
[8] 
 
[9] Y. Sugawara, M. Inaba and K. Hiraki, “Over 10Gbps string matching mechanism 
for multi-stream packet scanning systems,” Field Programmable Logic and 
Application, Vol. 3203, Sep. 2004, pp. 484-493. 
 
[10] L. Tan and T. Sherwood, “A high throughput string matching architecture for 
intrusion detection and prevention,” 32nd Annual International Symposium on 
Computer Architecture, pp. 112-122, 2005 
 
 37
A Scalable Loss-Tolerant Deterministic Packet 
Marking Scheme for IP Traceback 
 
Iven Lin and Tsern-Huei Lee 
Department of Communication Engineering 
National Chiao Tung University, Hsinchu, Taiwan 
E-mail: {iven, tlee}@banyan.cm.nctu.edu.tw 
 
Abstract- Deterministic packet marking (DPM) has recently 
been proposed as an alternative approach for IP traceback to 
identify the ingress router interfaces that receive and forward 
attack packets.  Scalable, simple to implement, and no extra 
bandwidth required are the major advantages of DPM.  Besides, 
it allows incremental deployment and service providers can 
implement it without revealing their internal network topology.  
Several DPM schemes have recently been proposed.  
Unfortunately, these schemes suffer from either a high false 
positive rate when there are multiple simultaneous attackers or a 
high false negative rate when packet loss happens because of 
congestion.  In this paper, we propose and evaluate the false 
positive and false negative rates of a novel DPM scheme that is 
much scalable than the previous schemes.  In the proposed DPM 
scheme, we use multiple hash functions to reduce the probability 
of address digest collision.  Our analysis and computer 
simulations show that the proposed DPM scheme results in much 
smaller false positive rate than previous schemes.  Moreover, by 
modifying the reconstruction procedure, one can control the false 
negative rate to combat packet loss with slight increase of false 
positive rate.  With eight different kinds of marks, the expected 
number of packets required to reconstruct an interface address is 
only 22. 
 
Ⅰ. Introduction 
 
As the Internet becomes ubiquitous the impact of attacks is 
getting more and more significant.  A widely reported attack, 
known as distributed denial-of-service (DDoS), is one that 
uses a number of compromised slaves to generate large packet 
flows to consume network resources such as transmission 
bandwidth and computation power so that normal services are 
seriously degraded or totally denied. Another common attack 
is for attackers to generate a few well-targeted packets to 
disable target systems. Identifying the sources of offending 
packets, after an attack is detected, is an important task to 
make the attackers accountable. 
Unfortunately, because of the anonymous nature of the 
Internet Protocol, it is very difficult to identify the true 
attackers because the source addresses contained in attack 
packets can be easily spoofed. To cope with DDoS attacks, 
several techniques have been developed by sending 
probabilistic samples of auditing routers’ identifications on a 
flow's path to the destination so the victim can reconstruct the 
attack path if a sufficient number of packets are collected from 
the flow.  ICMP traceback message [1][2] is proposed as an 
out-of-band carrier of the sample information.  Probabilistic 
packet marking [3]-[5], on the other hand, uses IP header bits 
in randomly selected packets to carry the information in-band.  
The sampling nature of these approaches limits their 
applications to the path identification of flood-based attacks.  
Recently, an alternative approach, called deterministic 
packet marking (DPM), was proposed for tracing multiple 
simultaneous attackers [6]-[8].  DPM is more scalable than 
other probabilistic packet marking schemes because it only 
requires edge routers to perform packet marking.  Besides, 
since all packets are marked before entering into the network, 
it can trace a large number of attackers simultaneously with 
only a few packets from each attacker.  Two situations, i.e., 
multiple attackers using the same source address to attack a 
victim or every attack packet carries a different source address, 
make the original DPM scheme proposed in [6] useless.  A 
modified DPM scheme, which we called DPM with address 
digest (DPM-AD), was developed to solve the problems 
encountered in these two situations.  However, the false 
positive rate of the DPM-AD scheme could be large if the 
number of edge routers is larger than the number of 
simultaneous attackers that spread uniformly over the Internet.  
The DPM scheme proposed in [8] results in significantly 
smaller false positive rate than the DPM-AD scheme does.  
Unfortunately, its false negative rate may not be acceptable if 
there is packet loss due to network congestion.  In fact, to 
control the damage, it is desirable to start the traceback 
process based on partially received marks once an attack is 
detected.  All the previous DPM schemes do not yield 
satisfactory performance in this regard. 
In this paper, we present and analyze the performance of a 
novel DPM scheme that is more scalable than all previous 
DPM schemes.  Another important advantage of the 
proposed scheme is that it allows tradeoff between false 
positive rate and false negative rate when one has to consider 
packet loss due to congestion.  In Section Ⅱ, we review 
previous DPM schemes.  Our proposed DPM scheme is 
presented in Section Ⅲ, followed by its performance and 
complexity analyses in Section Ⅳ.  Finally, we draw 
conclusion in Section Ⅴ. 
 
Ⅱ. Related Work 
 
The DPM scheme was first introduced in [6] for tracing 
back attacks.  It is scalable, simple to implement, and does 
not require extra bandwidth.  Besides, a service provider can 
verified with the hash results.  For convenience, this scheme 
will be referred as DPM-DPAC (Direct Partial Address 
Combining).  It was shown that the DPM-DPAC scheme 
results in significantly smaller false positive rate than the 
DPM-AD scheme.  Unfortunately, its false negative rate may 
not be acceptable if there is packet loss due to network 
congestion. 
 
III. The Proposed Deterministic Packet Marking Scheme 
 
3.1 The coding of marks 
As mentioned before, there are 17 bits in the IP header that 
can be utilized for marking by the ingress routers. Same as the 
DPM-DPAC scheme, we use 3 bits to distinguish 8 different 
kinds of marks.  The remaining 14 bits are used to carry 
partial address information or hash result of partial address.  
The scheme is designed so that every bit of the IP address is 
sent at least twice.  As a result, the scheme is robust in the 
sense that the victim can reconstruct the router interface 
address with any seven of the eight marks.  
 
Figure 2. Coding of marks of the proposed scheme. 
  
As shown in Figure 2, a router interface address is divided 
into five segments 1 2 3 4 5 , where 1 , 2 , 3 , and 4  
each denotes different partial 7-bit address, and 5  represents 
the last 4 bits of address.  Since the first four kinds of marks 
carry partial address information, for convenience, they will 
be referred to as address marks.  On the other hand, the final 
four marks are called digest marks because they contain hash 
results of partial addresses. Note that each address mark 
carries a segment of partial address and the 
a a a a a a a a a
a
xor  of two 
partial addresses. For example, the first kind of mark carries 
1  and a xor ( 2 , 5 ).  Since 2  is 7-bit long and 5  is 
only 4-bit long, we pad three leading 0’s to 5  before taking 
a a a a
a
xor ( , 5 ).  As a consequence, the leading 3 bits of 
2 5
2a a
( , )xor a a  and those of 2  are identical.  Similarly three 
leading 0’s are padded to 5  when taking
a
a xor ( 3 , 5 ), a a
xor ( 4 , 5 ), and a a xor ( 1 , 5 ).  It is not hard to see that 
every address bit is at least sent twice.  As an example, 1  
appears twice: in mark 1 and implicitly in mark 4.  Therefore, 
even if the first mark is lost on the way, the victim can still 
derive  from the fourth mark and  (which can be 
obtained from the second and the third marks or from the third 
and the fourth marks).  
a a
a
1a 5a
As for digest marks, they are designed to help the victim to 
find the correct IP addresses of ingress router interfaces that 
mark the attack packets. If there are  attackers, the victim 
is expected to receive  packets for each kind of marks. The 
victim can derive candidate ingress interface addresses from 
the received address marks.  In general, the number of 
candidate addresses is much greater than . All the 
candidate addresses are verified with digest marks to reduce 
the number of false positives.  To simplify the reconstruction 
process, one should interleave combination of address marks 
and verification with digest marks.  Detailed reconstruction 
process is presented in the following sub-section.  
N
N
N
 
3.2 The reconstruction process 
Assume that there are  attackers and the victim has 
received all marks.  For each first kind of mark, one can 
compare its 8
N
th to 10th bits with the 4th to 7th bits of every 
second kind of marks.  If there is a match, then the first 21 
bits and the last 4 bits of a candidate IP address is found.  Let 
1 2 3  and 5  denote, respectively, the first 21 bits and the 
last 4 bits of some candidate address.  It is clear that 1  is 
simply the first 7 bits of the selected first kind of mark and 2a  
the first 7 bits of the matched second kind of mark.  
Moreover, 5  can be derived from 2  and 
a a a a
a
a a xor ( , 5 ) and 
3  can be obtained from 5  and 
2a a
a a xor ( 3 , 5 ).  This 
process is repeated for all first kind of marks.  Let 1  
denote the set of all partial addresses ( 1 2 3 , 5 ) obtained 
from combining first and second kinds of marks.  Before 
combining with the third kind of marks, every partial address 
in set 1  is verified with the fifth kind of marks.  A partial 
address ( 3 , 5 ) survives if and only if (iff) 
1 2
a a
S
a a a a
S
1a 2a a a
3 5( , , , )Hash a a a a  matches any of the  fifth kind of 
marks.  Let  denote the set of survived partial addresses. 
N
2
By combining the partial addresses in set 2  and the  
third kind of marks, the victim will get a set of candidate 
32-bit IP addresses.  Assume that ( 1 , ) is a member 
of set .  A candidate IP address 1 2 3 4 5  is obtained 
due to ( 1a 2 3 , 5 ) if there is a third kind of mark which has 
3  as its first 7 bits and 
S
S N
a 2a 3a 5a
2S a a a a a
a a a
a xor ( 4 , 5 ) as its second 7 bits.  
Let 3  be the set of candidate 32-bit IP addresses.  The 
remaining work is to verify the candidate IP addresses with the 
rest (i.e., fourth, sixth, seventh, and eighth) kinds of marks.  
Let 4  denote the set of elements in  which pass the 
verification of the sixth kind of marks. 
a a
S
S 3S
After obtaining set 4 , one can verify the candidate IP 
addresses in  with the fourth kind of marks.  A candidate 
IP address 1 2 3 4 5  survives the verification iff there is a 
fourth kind of mark which has 4a  as its first 7 bits and 
S
4S
a a a a a
xor ( 1 , 5a ) as its second 7 bits.  Let 5  denote the set of 
candidate IP addresses that survives the verification. 
a S
The next step is to verify all elements of 5  with the 
seventh kind of marks.  Let 6  be the set that contains 
candidate IP addresses of  which pass the verification.   
S
S
5S
Then, for each address in 4 , we need to performs an S xor  
with its leading 7 bits and its last 4 bits in order to verify its 
validity with the fourth kind of marks. To obtain , we need 
to perform 
5S
5 4 3( )N N N+ − 82  xors  and 
5 4 38( ( ) 2 )N N N N+ − × = 2 6 5( )N N N+ − 382  matches.  
To get 6 , S
6 5 5( )N N N+ − 22  (which is equal to the average 
size of ) more hashes and 5S
6 5 52( ( ) 2 )N N N N+ − × = 2 7 6( )N N N+ − 522  more matches 
are required, and the average size of  is 6S
7 6 6( )N N N+ − 62 .  Finally, it requires 7 6 6( )N N N+ − 62  
hashes and 7 6 66( ( ) 2 )N N N N+ − × = 2 8 7( )N N N+ − 662  
matches to obtain 7 . Table 1 summarizes the computational 
complexity and the average size of sets  to . 
S
1S 7S
 
Table 1. The average size and the average number of hashes, 
matches, and xors  required in deriving sets  to . 1S 7S
 
As an example, for =1K, the DPM-DPAC scheme needs 
 hashes and  matches.  On the 
other hand, the proposed scheme requires  
hashes,  matches, and 
N
202 (2.578125) 202 (1.578125)
202 (0.191482)
202 (211.066147) 202 (0.265369) xors . 
If the hash function is the most time-consuming part (which is 
usually the case), the reconstruction process of the proposed 
scheme is much faster than that of the DPM-DPAC scheme.  
For our proposed scheme with loss-correction, the number 
of match, xor , and hash operations increase. To determine the 
complexity of the loss-correction reconstruction process, we 
need to know the complexity of { } which can be derived 
with the same skill we used for the original reconstruction 
process.  The detail is omitted due to space limitation.  
When =1K and no packet loss, the loss-correction 
reconstruction process requires 
 hashes, 
+ =  
matches, and + =  
i
N
20 20 202 (0.191482)+2 (1.443705)=2 (1.635187)
202 (211.066147) 202 (1710.272003) 202 (1921.33815)
202 (0.265369) 202 (1.700493) 202 (1.965862)
xors . Compared with DPM-DPAC scheme, it still requires 
fewer hash functions.  As a result, the loss-correction 
reconstruction process is still faster than that of the 
DPM-DPAC scheme. 
As mentioned in [7], the average number of packets 
required for reconstruction can be modeled as a coupon 
collection problem. Same as the DPM-DPAC scheme, our 
proposed scheme uses eight different kinds of marks and 
requires on average 22 packets to reconstruct an ingress 
interface. 
 
4.2 False positive rate 
Based on the average analysis provided in the last 
sub-section, the average number of false positives of the 
proposed scheme is 8 7 8( )N N− 02 .  For verification, we 
performed computer simulations 100 times for different values 
of . In our simulations the interface addresses are randomly 
selected and the digests are created with MD5 algorithm. 
Results show that, for =1K, the average false positive rate 
of the proposed scheme without loss-correction is around 
0.116%, which matches well with the above approximate 
analysis. For comparison, the false positive rate of the 
DPM-DPAC scheme under the same scenario is 0.488%, 
which is larger than four times of 0.116%.  Table 2 lists the 
false positive rates of the DPM-AD, DPM-DPAC, and our 
proposed scheme under various scenarios.  It can be seen that 
our proposed scheme is more scalable than previous schemes 
in the sense that it can trace back more simultaneous attackers 
under the same false positive rates. 
N
N
 
Table 2. The false positive rates of the DPM-AD, 
DPM-DPAC, and the proposed scheme without loss-correction 
process. 
 
  
4.3 False negative rate 
In the DPM-DPAC scheme, every address bit is contained 
in exactly one kind of mark and thus the correct ingress 
interface IP address cannot be reconstructed if any of its eight 
marks is lost. In other words, the probability of finding the 
correct ingress router interface address is equal to the 
probability that the victim receives all its eight marks. Let  
be the mark loss rate.  The probability that all eight kinds of 
marks of one ingress router interface are not lost is . 
As a result, the false negative rate, which is defined as the 
ratio of the number of false negatives to the number of 
attackers, is .  
m
8(1 )p−
81 (1 )p− −
Using the loss-correction reconstruction process, the victim 
can determine the interface address by any seven of the eight 
kinds of marks. Since the probability that exactly one of the 
eight kinds of marks is lost is , the false negative 
rate reduces to . 
78 (1 )p p−
8 71 (1 ) 8 (1 )p p p− − − −
 
Figure 4 shows the false positive and the false negative 
rates of our proposed scheme under different mark loss rate for 
