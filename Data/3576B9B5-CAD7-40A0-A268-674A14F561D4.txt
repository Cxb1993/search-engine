 1 
 
行政院國家科學委員會補助專題研究計畫 
□期中進度報告 
■期末報告 
 
               基於特徵碼之惡意文件偵測與分析 
Detection and Analysis of Malicious Document with Signature-Free Methods 
 
計畫類別：■個別型計畫   □整合型計畫 
計畫編號：NSC 100 － 2218 － E001 － 008 
執行期間：  2011 年 9 月  1 日至  2012 年 7 月 31 日 
 
執行機構及系所：中央研究院資訊科技創新研究中心 
 
計畫主持人：黃彥男 研究員 
共同主持人：  
計畫參與人員：吳明蔚、費爾德 
 
 
 
 
本計畫除繳交成果報告外，另須繳交以下出國報告： 
□赴國外移地研究心得報告 
□赴大陸地區移地研究心得報告 
■出席國際學術會議心得報告及發表之論文 
□國際合作研究計畫國外研究報告 
 
 
處理方式：除列管計畫及下列情形者外，得立即公開查詢 
            □涉及專利或其他智慧財產權，□一年□二年後可公開查詢 
 
中   華   民   國  101  年  7  月  31  日 
with the increasing complexity of malicious 
documents and limitations of existing 
automatic tools, the current behavior-based 
approach cannot successfulness identify a 
great number of recent malicious 
documents. 
In this project, we implement a system, 
which is a combination of static analyzer 
and a behavior-based proﬁler. The dynamic 
analyzer is implemented on top of a virtual 
machine emulator that intercepts the system 
processes and analyzes the CPU instructions, 
CPU registers and memory. The captured 
information is stored in a relational database 
and data mining techniques are used to 
extract information. We demonstrate the 
breadth of the implemented platform 
application by conducting two experiments: 
a packed document analysis and analyzing 
malicious documents (PDFs), served 
through a banner network. This problem is 
commonly known as malvertising 
(malicious advertising) incident tracing.    
Both tasks are known to be very 
difficult to do efficiently using existing 
methods and tools. We demonstrate how the 
precise behavior information can be easily 
obtained using our tool. With these two 
experiments, we show that our platform can 
provide security researchers and automatic 
malicious document detection systems with 
an efficient malicious document behavior 
analysis solution. 
2. Related Work 
2.1 Malicious Document as Attack Vector 
Malicious document is a trend 
frequently used in APT (newly coined term 
for targeted attacks, stands for “Advanced 
Percistent Threat) [9, 10, 11, 12]. The 
malicious documents are intentionally 
designed to disrupt availability, compromise 
conﬁdentiality, alter integrity, and cause 
abusive behaviors.  
The main target is to compromise 
target platform by exploiting a vulnerability 
in document processing, or document 
viewing software (such as Microsoft Word, 
Microsoft Office tools, Adobe Acrobat 
Reader and so on)[13, 14, 15]. The 
malicious document could typically contain 
other embedded components, such as 
malicious javascript, binary payload, which 
would be carried by malicious document. 
Type and nature of malicious document is 
typically very specific to document 
format[15]. Technically malicious document 
is an entry gate that exploits the software 
vulnerability in target platform, however, it 
may further install malicious binaries 
(backoors) and other malicious software. 
Therefore our platform is designed to be 
able to handle those cases, malicious 
documents and traditional malicious 
binaries. 
Security vendors, such as anti-virus 
tool maker mainly utilized static 
signature-based, or pattern matching, 
technology, to determine known malicious 
document, but apparently this approach 
suffers from low detection rate when 
dealing with unknown malicious document. 
Unfortunately, the attackers can easily 
produce numerous variants of known 
malicious document by using program 
encrypted form. This can bypass antivirus 
detection while being stored on disk, while 
the unpacked version only exists during 
execution time in the memory. 
One of the recent examples of 
document obfuscation, which was 
discovered in the wild, as shown in figure 3, 
is widespread use of XDP format to encode 
malicious PDF documents.  
Figure 3. Adobe Obscure XDP Format, Often 
Used to Obfuscate Exploit Delivery via Malicious 
Document 
 
Other attack methods include 
obfuscated javascript, where tools are 
readily available, as shown in figure 4. 
However, obfuscations are only effective to 
get around static pattern-matching, they are 
ineffective to dynamic behavior monitoring 
because in the end, any malicious document 
and malicious software are designed to 
perform malicious actions (keylogging, 
system hooking, etc.) to do its job, and thus 
could be monitored and efficiently detected. 
With well-trained malicious behavior 
profiles, behavior-based detection 
demonstrates highly detection rate. 
 
 
Figure 4. Javascript Obfuscator Example 
 
2.2 Behavior Profiling and Relevant 
Works 
 
The trained and built behavior model 
could also lead to high occurrence of false 
positive and/or false negative rate depending 
on the granularity of profiled behaviors. For 
example, certain system resources such as 
specific registry keys and files would enable 
malicious document to achieve particular 
malicious capabilities – these hooking 
points are malicious document attack points 
(MAPs)[19]. Unfortunately, legitimate 
software might also leverage one or more 
MAPs for legit purpose, e.g. automatic 
execution of a particular program makes 
better user experience. Therefore, accurate 
collection of fine-grained profiles is crucial 
to behavior-based dynamic monitoring 
approach. 
hardware execution to higher-level OS 
entities and operations, "The Platform" 
helps security researchers to see the 
high-level view of the payload embedded 
within the malicious document. Lastly, 
many malicious documents contain binary 
payload, which is designed to work in 
multi-thread manner, determining the 
correct call sequences is also essential and is 
addressed in the platform. In order to 
efficiently store huge volume of collected 
information on system call sequences and 
running program, we utilize relational 
database to store collected data. 
3. Methodology 
3.1 Platform Architecture 
We have implemented malicious 
document analysis platform with following 
features: 
- The platform keeps itself unreachable 
for typical malicious document by 
residing inside a virtual machine 
emulator, while existing analyzers 
generally leverage running agents in 
targeted OS, introducing extra 
overhead and provide additional attack 
vectors. 
- The Platform executes target binary, or 
opens suspicious document using 
document processing software on a 
complete operating system instead of a 
simulated system, therefore the 
collected data is very comprehensive. 
- The Platform tracks right call 
sequences and application-level 
functions, allowing security researchers 
to identify the malicious intents within 
malicious documents. 
- The Platform utilizes a relational 
database for data storage. 
- The increasing malvertising attacks can 
be effectively analyzed with The 
Platform. 
 
3.2 Tracking Malicious Documents served 
through Banner Network 
 
One of the main difficulties in 
analyzing malvertising is the determination 
of specific malicious advertisement 
anchor(s), which led to a malicious 
document and consequence infection [22]. A 
typical website often has many anchors, 
each of which delivers different 
advertisement to a browser from different 
sources. Each anchor, which is normally an 
HTML code snippet with JavaScript content, 
will dynamically load additional 
components into a web page. This often 
creates a new iframe which may load 
additional JavaScript or flash payload from 
an advertising agency, and at the end, this 
will load the advertisement content to the 
end user. The chain of loading an 
advertisement could be extremely complex, 
as a typical advertisement agency would 
include several ad-fraud prevention 
measures in order to prevent the click fraud. 
The ad-fraud prevention code is typically 
implemented in the form of obfuscated 
JavaScript code to blocked automated "bot" 
software. Typically such JavaScript is 
extremely difficult to be analyzed by human 
and will not run on any platform other than 
very different from behavior model of 
document processor working with regular 
document. For example, a typical document 
processor should not create/spawn 
additional processes, perform network 
connections and so on. This creating model 
to identify malicious documents should be 
much easier than identifying generic 
malicious binaries/executables. Since 
behavior of benign document processor 
could be very well defined. 
In figure 5, we can easily pin point, 
which vulnerabilities are being exploited by 
these documents, since we can identify the 
system calls, which lead to unexpected 
behavior (that violates security model). 
Additionally, in our platform, we can cluster 
documents and extracted features by 
similarity to build links between documents, 
and groups of documents. 
 
 
Figure 5. Classification of Malicious Documents 
per Group 
 
The success of behavior-based 
detection methods depend on adequate 
provision of abnormal behavior models. The 
lack of abnormal behavior model data can 
obviously lead to high false positive and/or 
false negative rates. For example, if the 
behavior model is not specified properly, 
some legitimate programs, which also 
modify system registry, can be mistakenly 
labeled as malicious software. Unfortunately, 
it is not an easy task to automate the 
abnormal behavior model collection from 
malicious programs. 
For example, when tracing malvertising 
attacks, following behavior may be 
considered as violating security model and 
visit to target website causes browser to 
spawn additional processes. 
When security researchers are dealing 
with fast-growing number of malicious 
software, they need an automated analysis 
platform to track and log all actions of 
malicious software running on an infected 
computer. It is much easier to analyze the 
system call sequences of a malicious 
program to recognize the intentions of 
malicious programs rather than reading 
assembler code of the malicious program. In 
addition, the system call arguments, stack 
data, register data, memory data and disk 
data can be used to provide useful 
information for incident analysis. Finally, an 
out-of-the-system analyzer placement 
prevents an analyzer from being disabled by 
malicious software. 
3.4 Implementation Details 
We implemented the platform on the 
top of QUEMU analyzer a generic and open 
source hardware emulation tool, because of 
to achieve this goal since we can identify 
every system call by its entry point. When a 
process invokes a system call, it jumps to 
the entry point of the system call and 
executes instructions. In other words, at any 
point of time when the current process is 
going to invoke a system call as the next 
step, the program counter register would 
hold the entry point of a system call. The 
monitoring component uses this 
characteristic to track and log system calls 
and application-level functions. 
System call arguments are also 
essential information in understanding the 
intention of malicious software. These call 
arguments are extracted from the stack 
frames. Whenever a call is made, a process 
must push all arguments onto the stack. 
These documents are also recorded by 
monitoring component. 
4. Experimental Results 
4.1 Malicious Analysis on Platform 
We conducted three case studies to 
demonstrate how our platform can be used 
in practice (show in Figure 6). 
 
Figure 6 Experiment Results 
In the first experiment, we take a 
malicious document, which embeds 
malicious payload and show how the 
platform can correctly map binary opcodes 
to high level system calls. Besides, 
application level functions which are 
tracked by the platform can help security 
researchers to understand the intention of 
malicious documents. In second experiment, 
we explain the steps of designing a generic 
unpacker and show how the platform can 
assist security researchers to analyze 
malicious programs. In the last experiment, 
we propose an approach to identify 
appropriate application level functions to 
track the chain of anchors, which 
sequentially load code leading to malicious 
components. We also show that has the 
capability to solve other emerging Internet 
threats. 
In order to show that the platform can 
correctly map hardware information to high 
-level system calls, we compare several 
results of our platform with those of some 
third-party software. First of all, we 
examine the manual analysis reports from 
online resources which are provided by 
anti-virus vendors. Next, we perform a 
dynamic analysis of specific malware 
binaries using our platform and online 
analysis tools such as CWSandbox 
(www.cwsandbox.org) and Anubis 
(anubis.iseclab.org) and compare the results 
with manual analysis reports.  However, it 
is very difficult to manually analyze 
malicious documents, which we have 
collected in our repository at the same time. 
Therefore we propose comparisons based on 
the initialized data section. The code 
section is the previous section. 
 Size of image: this element indicates 
the size of the program. If the size of 
image is greater than the base of data 
plus the size of the initialized data, it 
means that there is an external section 
after the initialized data section. 
External section is usually created by 
packers. 
 Entry point: this element indicates the 
start address of the program. 
 
There are two additional sections that 
are not deﬁned in PE ﬁle header. One is the 
dynamic allocation section; the other is the 
dynamic library section. Some unpacking 
procedures request the operating system to 
offer dynamic memory space for them to 
restore the original code when unpacking 
itself. We refer to this kind of section as a 
dynamic allocation section. In addition, an 
application may load other external libraries 
(dynamic linking libraries) to execute its 
tasks. We name the virtual space of loading 
libraries as dynamic library section. Figure 7 
is an illustration of a running process’s 
sections in virtual memory. The entry point 
of a packed program could be located at any 
section. Intelligence agency obtains all the 
aforementioned information when a process 
is going to be executed. We can retrieve this 
information in relational database later. 
   Next, we propose the following 
approach for holography to detect a 
section-change event. A return address that 
is obtained by spy satellite can be used not 
only to determine whether we are dealing 
with invoking system call that is a chained 
system call but also to determine in which 
section the invoked system call is located. 
By correlating the section boundaries that 
are provided by PE ﬁle header and some 
particular system calls such as VirtualAlloc, 
LoadLibrary et. al., and a return address, 
holography has the capability to detect the 
section-change event. 
 
 
Figure 7. The Structure of Sections in A Running 
Process 
 
Furthermore, two special situations 
should be addressed. First, when a chained 
system call is met, it absolutely ﬁts the 
section-change event. However, this 
situation is irrelevant to an unpacking 
procedure. Therefore, we propose an 
approach that ignores chained system calls. 
Second, we should deal with the 
section-change event carefully when a 
process enters or leaves a dynamic library 
section. Although a dynamic library section 
is independent with other sections, it does 
not mean an unpacking procedure is 
complete when a return address points to 
dynamic linking library memory space. 
Therefore, we consider that it is not a 
section-change event when a process enters 
or leaves a dynamic library section. 
Following are the exact steps of binary 
generic binary unpacking algorithm: 
 
1. Keep the initial section. 
2. Perform analysis of a packed sample 
using holography. 
3. Ignore chained system calls. 
 Figure 8. Section-Change Statistic 
4.2.3. Approach Evaluation 
Before we apply our approach to 
design a generic unpacker, we also examine 
some variants of Trojan.PSW.Coced 
samples from our malware repository and 
perform analysis using holography. There 
are 20 variants samples of 
Trojan.PSW.Coced in our repository. We 
use PEiD [23], a signature-based packer 
detector, to ﬁlter nonpacked variant samples. 
Only nine sampled variants are packed. We 
carry out the same experiment as in Section 
4.2.2. According to the detailed report in the 
Section 4.1, we examine whether malicious 
actions locate in the last section conﬁrm that 
the unpacking procedure is complete. 
Table 2 shows the results of this 
experiment. The data representation here is 
very similar to Table1. The ﬁrst experiment, 
Trojan.PSW.Coced, is a control group code. 
It is not packed by any packer. Therefore, a 
section-change event does not appear in the 
ﬁrst row. The others are packed samples, 
and a section-change event appears two 
times. According to our analysis, these 
binaries are not packed twice. The ﬁrst 
section is their entrance section, and they do 
not invoke any system calls. An unpacking 
procedure is executed in the second section. 
Next, we examine whether malicious 
actions appear in the third section. We can 
see that the number of security-relevant 
system calls in the third section is very 
different. Only three of them are close to the 
control group. We discover that although 
they are variants of Trojan.PSW.Coced, 
they still have some different actions. For 
example, the second variant sample, 
Trojan.PSW.Coced.229.d, uses four 
security-relevant system calls to create a 
duplicate process, and all malicious actions 
appear in the duplicated process. To ensure 
the unpacking procedure is complete, we 
search for the section that has the ﬁrst 
malicious action to appear. All the samples 
show that the ﬁrst malicious action appears 
in the third section. This experiment shows 
that our holography can help security 
researchers to conduct an experiment to ﬁnd 
a new behavior model. In addition, we 
propose a new approach to unpack. 
 
Table 2. Section-Change Event Statistic. 
 
 
   We extend the capability of holography 
to detect a section-change event. 
Holography dumps all the virtual memory 
space of a running process when a 
section-change event occurred in a process. 
To evaluate correctness, we design a set of 
tests to compare the results with Renovo 
[24], which is a dynamic approach for 
extracting packed code. We use PEiD to 
ﬁlter nonpacked malware samples from our 
malware repository, and we obtain 1543 
unique malware samples. We submit all of 
them to Renovo and download unpacked 
results from Renovo’s web site. We 
compare results between holography and 
Renovo one by one. During our experiments, 
requested by Dom26. However, the anchor 
that loads the Dom55 does not exist in 
Dom26 when we examine the Dom26 
HTML content. Actually, the anchor that 
loads Dom55 is dynamically generated by 
one javascript fragment. Therefore, intuitive 
system calls cannot provide sufficient 
behavior semantics to generate the correct 
chain of anchors. 
 
 
Figure 9. A web resource topology 
 
A ‘complete web resource topology’ is 
a web resource topology that lists each web 
resource that can be exactly identiﬁed with a 
corresponding anchor from its parent web 
resource. A complete web resource topology 
can help security researchers to ﬁnd a 
correct and complete chain of anchors that 
loads a particular advertisement. To 
generate a complete web resource topology, 
we need to know what kind of javascript 
methods can be used to dynamically 
generate an anchor and what kind of system 
calls or application-level functions can be 
used to track the javascript methods. For 
example, a javascript method 
‘document.write’ is an apparent technique to 
dynamically generate an anchor in a web 
page. We discover that an application-level 
function ‘CDocument::write’ that resides in 
dynamically loaded library ‘mshtml.dll’ can 
be used to track the javascript method. 
Therefore, the challenge of generating a 
complete web resource map is to ﬁnd out 
techniques that can be used to dynamically 
generate an anchor and identify 
corresponding system calls or 
application-level functions that can be used 
to track the techniques. 
 
4.3.2. Proposed approach 
Holography has the capability to track 
application-level functions and gathers 
corresponding parameters. Therefore, 
security researchers can use holography to 
generate a complete web resource topology. 
Figure 10 proposes an iterative approach. 
We use Microsoft Windows Browser 
(Internet Explorer) on the top of 
‘holography platform’ to browse a web page. 
We examine each ‘send’ system call, which 
is invoked by the browser. If a requested 
URL cannot be found in the corresponding 
anchor from its parent web page, we search 
the method from the running javascript code 
that generates the anchor. Next, we use IDA 
pro to ﬁnd an appropriate application-level 
function that can be used to track the 
javascript method. Therefore, human 
analyze can conﬁgure holography to track 
the discovered application-level functions 
and leverage the results to generate a 
complete resource topology. Table 3 shows 
the discovered javascript methods and 
corresponding application-level functions so 
far. 
 
 Forth line: A triple marks. The ﬁrst 
mark shows which javascript method 
generates a dynamic anchor that loads 
this web resource. The second mark 
shows which web resource includes the 
javascript code. The third mark shows 
how many bytes from the beginning 
where we can ﬁnd the javascript code. 
 
If an anchor is generated by the second 
javascript code, holography will generate a 
complete web resource topology as shown 
in Figure 12(b). Otherwise, holography will 
generate a complete web resource topology 
like Figure 12(a). In this experiment, we 
show holography can leverage 
application-level functions to generate a 
complete web resource topology. 
 
 
Figure 12. Resource Topology of Simple Web 
Page 
 
4.3.3.2 Browsing An Obfuscated Web 
Page 
 
Obfuscating javascript code is a 
common method used to protect source code. 
We use an online javascript obfuscator to 
obfuscate the previous simple web page. 
Next, we use the obfuscated javascript code 
to examine the capability of holography. 
Figure 13 is obfuscated javascript code, and 
Figure 14 is result. In Figure 14, the result 
shows that holography is not affected by 
obfuscation techniques. 
 
 
Figure 13. Obfuscated Simple Web Page. 
 
 
Figure 14. Result of Second Experiment 
 
4.3.3.3 Browsing A Commercial Web 
Page 
 
In this experiment, we browse a 
complex commercial web page 
‘http://www.gumtree.com’ to examine the 
capabilities of holography. Because the 
number of web resources in the web page is 
56, space limitations preclude display of a 
readable complete web resource topology. 
Therefore, we only choose a snippet of the 
web resource topology to show the 
effectiveness of our tool. Next, we 
compared our result with the Fireshark 
result. Figure 15 is our result, and Figure 16 
is the Fireshark result. 
 
 
 
actions of legitimate software may be 
mistakenly considered as malicious 
intention. Therefore, insufficient supply of 
abnormal behavior models can lead to high 
false positive and/or false negative rates. It 
is important to design an automatic, 
system-wide and fine-grained tool that can 
provide security researchers with the ability 
to efficiently extract abnormal behavior 
models from malicious documents. In this 
paper, we extend the capability of a 
hardware virtualization tool to capture the 
activities of running processes of document 
processing software without any assistance 
from an external tool or a driver installed on 
a guest operating system. In order to 
tracking the actions of each process, our 
platform monitors CPU instructions and 
obtains useful information in real-time from 
CPU registers and memory. Our platform 
has the advantage of being undetectable by 
malicious documents because the critical 
components of our platform do not share the 
same system with the malicious programs. 
Reference 
[1] Internet security threat report volume xiv 2009:  
http:/www.symantec.com/business/theme.jsp?t
hemeid=threatreport. 
[2] Financial aspects of network security: Malware 
and spam 2008: 
http://www.itu.int/ITU-D/cyb/events/2008/bris
bane/docs/bauer-financial-aspects-spam-malwa
re-brisbane-july-08.pdf 
[3] Anti-virus comparative no.22 2009: 
http://www.av-comparatives.org/images/stories
/test/ondret/avcreport22.pdf 
[4] Yan, W., Zhang, Z., and Ansari, N. “Revealing 
Packed Malware”, IEEE Security and Privacy, 
6,5, 65–69, 2008. 
[5] Brandon Dixon. Bypassing Antiviruses using 
XDP: 
http://blog.9bplus.com/av-bypass-for-malicious
-pdfs-using-xdp  
[6] Anubis: Analyzing unknown binaries:  
http://anubis.iseclab.org. 
[7] Yin, H., Song, D, Egele, M., Kruegel, C., and 
Kirda, E., “Panorama: Capturing System-wide 
Information Flow for Malware Detection and 
Analysis”, In Proceedings of ACM Computer 
and Communication Security, 2007. 
[8] Webawet: detecting web based threats: 
http://wepawet.iseclab.org/ 
[9] F.Li , A.Lai and D. Ddl, Evidence of Advanced 
Persistent Threat: A case study of malware for 
political espionage, 6th International 
Conference on Malicious and Unwanted 
Software (MALWARE), 2011 
[10] Sood, A.; Enbody, R.; , "Targeted Cyber 
Attacks - A Superset of Advanced Persistent 
Threats," Security & Privacy, IEEE , vol.PP, 
no.99, pp.1 
[11] Baize, E.;, "Developing Secure Products in the 
Age of Advanced Persistent Threats," Security 
& Privacy, IEEE , vol.10, no.3, pp.88-92, 
May-June 2012. 
[12] Andress J., (2011).  Advanced Persistent 
Threat, Attacker Sophistication Continues to 
Grow?ISSA Journal. 
[13] Yu-Xiang Gao; De-Yu Qi; , "Analyze 
and detect malicious code for 
compound document binary storage 
format," Machine Learning and 
Cybernetics (ICMLC), 2011 
International Conference on , vol.2, no., 
pp.593-596, 10-13 July 2011 
 1 
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。 
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
■  達成目標 
□ 未達成目標（請說明，以 100字為限） 
□ 實驗失敗 
□ 因故實驗中斷 
□ 其他原因 
說明： 
 
 
 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：■已發表 □未發表之文稿 □撰寫中 □無 
專利：□已獲得 □申請中 ■無 
技轉：□已技轉 □洽談中 ■無 
其他：（以 100字為限） 
 
 
 
3. 請依學術成就、技術創新、社會影響等方面，評估研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）（以
500字為限） 
    惡意文件的問題在現代資訊安全研究已經是核心的工作之一，諸多的研
究針對投入，也有許多成果已經發表。在本計畫執行的研究上，以文件特徵
碼的角度投入惡意文件的分析，是一個效益不錯的方法，有效的提供了惡意
文件分析與偵測。在學術成果上本，計畫的研究成果有一篇期刊、一篇國際
會議論文、與一篇國際會議之成果海報、並有不錯的回響。在技術創新上，
對於以特徵碼的角度分析與偵測惡意文件，提供了新的解決之道。在社會影
響上，因為惡意文件的問題在資訊安全領域上長期的影響使用者在訊息利用
上的安全，本計畫針對這樣的問題有深入的探討，其成果可貢獻於此類問題
的解決工作。 
 
 
附件一 
附件三 
研究發表成果 
 
 Journal Paper： 
Shih-Yao Dai, Fyodor Yarochkin, Ming-Wei Wu, Yennun Huang, and Sy-Yen 
Kuo, “Holography: a behavior-based profiler for malware analysis”, Journal 
of Software-Practice and Experience, 42(9): 1107-1136, 2012. 
 
 International Conference： 
Shih-Yao Dai, Fyodor Yarochkin, Sy-Yen Kuo, Ming-Wei Wu, and Yennun 
Huang, “Malware Profiler Based on Innovative Behavior-Awareness 
Technique”, Proceeding of 17th IEEE Pacific Rim International Symposium on 
Dependable Computing (PRDC), pp. 314-319, 2011. 
 
 Poster Paper： 
Fyodor Yarochkin, Yennun Huang, and Sy-Yen Kuo, “Evaluation of Scalable 
Event Analysis Platform”, Proceeding of 42nd Annual IEEE/IFIP International 
Conference on Dependable Systems and Networks (DSN), 2012. 
 
 備註：本計畫發表成果之期刊─“Holography: a behavior-based profiler for 
malware analysis” 為本計畫主要之成果，該期刊作者群包含本計畫主持人
黃彥男 (Yennun Huang) 博士，與本計畫參與人員費爾德 (Fyodor Yarochkin) 
及吳明蔚 (Ming-Wei Wu)。唯因本計畫主持人為新進人員，初次執行國科會
專題研究計畫，疏忽在該篇期刊的 ” ACKNOWLEDGEMENTS”  部分放
入國科會專題研究計畫編號等，能說明該期刊屬於本計畫之成果的相關文字
內容。故在此特別說明之。 
1108 S.-Y. DAI ET AL.
In the past, security vendors such as antivirus tool makers mainly utilized static signature-based
or pattern-matching technology to determine known malware, but apparently, this approach suffers
from a low detection rate when dealing with unknown malware [3]. Unfortunately, the attackers can
easily produce numerous variants of known malware by using program packing and code obfusca-
tion techniques, and antivirus vendors would have to come out with more signatures to recognize
these new unknown variants. In fact, the amount of new malicious software on the Internet more than
doubles every year [1]. There must be an effective approach, an alternative to static signature-based
technology, to address this threat.
Malicious binaries are typically protected by code obfuscation to evade pattern-matching detec-
tion, an approach that is recently gaining popularity. This method based on dynamic monitoring
of malware execution can only detect unknown malware as long as the malicious behavior pro-
files are available. For example, malware authors often use program packers for obfuscation [4],
which means a malicious binary is packed in compressed and encrypted form to successfully avoid
antivirus detection, whereas the unpacked version only exists during execution in the memory.
However, obfuscation is only effective to get around static pattern matching, it is ineffective at
avoiding dynamic behavior monitoring because after all, malware is designed to perform malicious
actions (keylogging, system hooking, etc.) that could be monitored and detected. With a well-trained
malware profile, behavior-based detection demonstrates a much higher detection rate.
However, a behavior model could also lead to a high occurrence of false positive and/or false
negative reporting depending on the granularity of the profiled behaviors. For example, certain sys-
tem resources such as specific registry keys and files would enable malware to achieve particular
malicious capabilities; these hooking points are malware attack points (MAPs) [5]. Unfortunately,
legitimate software might also leverage one or more MAPs for legitimate purpose; for example,
automatic execution of a particular program makes the user experience better. Therefore, accurate
collection of fine-grained profiles is crucial to behavior-based dynamic monitoring approach.
While designing and developing an automatic, system-wide, and fine-grained tool that can effec-
tively assist security researchers in extracting the behavior models of given malware samples, the
challenges and limitations of existing analyzers, such as Ether [6], Anubis [7], Panorama [8], TEMU
[9], and CWSandbox [10], have been thoroughly studied. For example, Panorama, TEMU and
CWSandbox require agents to be installed on a targeted operating system to collect and send infor-
mation to the analyzer for analysis. Malware thus has a chance to identify the presence of such an
agent and evade the analysis. Anubis adopts a virtual machine (VM) introspection approach to obtain
data in VM’s memory [11–13], but temporary data might be lost when using out-of-the-QEMU
collectors. Moreover, a new attack vector known as malvertising, which is short for malicious adver-
tisements (Ads) where malware is served to the visitors through malicious Ads from third parties,
is rising rapidly because existing analyzers have difficulty in profiling application-level functions
that are invoked by a process (the browser that is viewing and rendering the malicious Ads). This
capability is important because a website owner needs to track the chain of anchors (or links) in
determining the right loading sequence of the malicious advertisement to find the malicious party.
The holography tool that we have developed has resolved this limitation of current program profil-
ing tools and can effectively track application-level functions and determine the chain of anchors
for loading Ads.
Furthermore, holography extends the abilities of a VM emulator to capture the actions of running
processes. Holography is based on an analysis of CPU instructions, CPU registers, and memory data
to track actions of running processes and perform real-time collection of additional useful informa-
tion, such as stack data and memory data, for security researchers without installing additional
tools or drivers on the operating system. Security researchers can safely execute malware bina-
ries on ‘holography’ where runtime data would be collected and analyzed. Because ‘holography’
components are built as part of a VM emulator, which is separate from the virtualized operating
system where malware resides, it is relatively hard to be detected and disabled by malware. In
addition, ‘holography’ maps lower-level assembler code into higher-level system calls (Windows
API functions and Windows native API functions) and can track application-level functions of local
permission. By mapping from lower-level hardware execution to higher-level operating system enti-
ties and operations, holography helps security researchers to see a high-level view of the malware
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1110 S.-Y. DAI ET AL.
JavaScript engine failing with execution errors before the loaded script is able to complete its
execution and load consequential URL(s).
Jsunpack and a number of other command line tools (phoney client is the other one) utilize an
approach, similar to the wepawet tool, of embedding a customized third-party JavaScript engine.
However, this approach has limitations similar to those of the wepawet approach.
Browsing dynamically linked library (DLL) hooking is another technique that is frequently used
to detect and analyze ‘drive-by-download’ and ‘malvertising’ attacks. The essence of the technique
is that the browser DLL functions, responsible for opening a URL, are hooked and the behavior of
the Web Browser is monitored by intercepting the content passing to these functions. However, it is
still extremely difficult to reconstruct the accurate sequence graph of loaded URLs because of the
multithreaded nature of a browser that utilizes a pool of workers for each URL fetch. This makes
sequence/time-based analysis impossible. Also, the information collected from HTTP headers (i.e.,
HTTP referrer) is not sufficient for accurate sequence reconstruction.
The rest of this paper is organized as follows. Section 2 gives an overview of holography.
Section 3 presents the detail design and implementation of holography. Section 4 demonstrates
practical applications of holography and its effectiveness. Finally, section 5 concludes the paper.
2. OVERVIEW OF APPROACH
2.1. Abnormal behavior models
Behavior-based detection techniques identify malicious programs by observing their behavior mod-
els and system states. If the behavior models of a process and its system state deviate from ‘normal’,
the process may be considered to be malicious. Figure 1 shows a malware’s abstract behavior model
when a malicious program invades a computer system [20]. Usually, malicious programs infiltrate a
computer system from an external source and must pass the outer gate to intrude a computer. There
are several entrance points for malicious programs in the outer gate. Malicious programs need to
create some persistent states (e.g., files) inside the outer gate after they successfully infiltrate the
target computer. To automatically start without user consent, malicious programs must hook them-
selves to the middle gate. There are three hooking points for malicious programs in the middle gate.
Finally, malicious programs run in the inner gate and invoke system calls in the core gate to interact
with the operating system. Malicious programs damage and/or steal information from the infected
computers by invoking specific system calls with specific arguments.
In this abstract behavior model, some obvious abnormalities could be used to detect malware. For
example, malicious programs always attempt to run without revealing their presence. To do so, mali-
cious programs need to be able to start without user consent. The specific registry key‡ in the middle
gate can be used by malicious programs to perform an automatic bootstrap. MAPMon [5] monitors
the middle gate to determine surreptitious reboot surviving behaviors. As another example, some
malicious software uses vulnerabilities of legitimate software to bypass the outer gate and create a
persistent state inside the outer gate (e.g., a drive-by-download attack). This behavior model in the
outer gate may deviate from normal behavior models of the vulnerable software. Behavior-based
detection techniques can detect malicious programs by detecting this abnormal behavior.
The success of behavior-based detection methods depends on adequate provision of abnormal
behavior models. The lack of an abnormal behavior model data can obviously lead to high false
positive and/or false negative rates. For example, if the behavior model is not specified properly,
some legitimate programs, which also modify the system registry, can be mistakenly labeled as mali-
cious software. Unfortunately, it is not an easy task to automate the collection of abnormal behavior
models from malicious programs. Cobra [21], TTAnalyze [22], CWSandbox [10], Panorama [8],
TEMU [9], and Anubis [7] are some of the existing analyzers that provide security researchers with
convenient tools to obtain abnormal behavior models and study malicious software behaviors. How-
ever, they still have some open issues. For example, Panorama and Cobra use the assembler code of
‡The registry key is HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft /Windows/CurrentVersion/Run.
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1112 S.-Y. DAI ET AL.
Figure 2. Abstract steps of a malware process.
Figure 3. Holography overview.
execution, we want to obtain system calls that were invoked and their arguments. Later, this data
can be used to identify the intentions of the program.
Figure 3 shows the architecture of holography. We extended the capability of a VM emulator to
capture actions of running process. Intelligence agency, spy satellite, and process matrix are three
major components that we developed in the VM emulator. Before a program jumps to the code
section of a invoked system call, the program counter register in the CPU module keeps the first
instruction address (entry point) of the system call (step 4). Spy satellite checks the value of the
program counter (step 5) and asks the intelligence agency to determine whether the program wants
to invoke any system calls. Intelligence agency collects the entry points of all system calls and
the necessary information of arguments in advance. Intelligence agency can respond to spy satel-
lite’s question by verifying whether the value of the program counter is equal to an entry point
of any system call. When a program just wants to invoke a system call, spy satellite maps lower-
level assembler code mnemonics into a higher-level system call description and obtains the system
call arguments, stack data, register data, memory data, and disk data from the VM emulator. This
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1114 S.-Y. DAI ET AL.
During our development process, we found that spy satellite can log not only system calls that
are directly invoked by a process but also system calls that are not directly invoked by the process.
We named these indirect system call sequences as chained system calls.Chained system calls are
not directly invoked by a process. Instead, chained system calls are invoked by the system calls,
which the process had directly invoked. Spy satellite cannot easily differentiate chained system calls
because both of them share the same physical address of their page directory. Fortunately, we discov-
ered that the return address can be used to resolve this problem. A return address would typically
point to the next instruction behind an invoked function call. The top element of program stack
keeps a return address for a process returning from an invoked system call. So we simply verify if
a return address points to the virtual space of the tracked process, in which case the system call is
directly invoked by the tracked process. Otherwise, it is a chained system call. Spy satellite writes
an invoked system call with a return address into the process matrix. The additional information is
included so that it is possible to distinguish chained system calls. This information allows the secu-
rity researchers or data mining system to see the high-level view of execution flow without going
deep into chained system call details. Furthermore, cross correlation between chained system calls
can be carried out to identify system calls with similar semantics. The system calls that are executed
with the same purpose have a common chained system call. As an example, there are several high-
level system calls to create a process: WinExec, ShellExecute, ShellExecuteEx, and CreateProcess.
But all of them invoke a chained system call ‘CreateProcessInternal’ in kernel32.dll. The optimized
behavior analysis only needs to focus on the system call ‘CreateProcessInternal’ for determining
whether a process wants to create another process.
System call arguments are also essential information in understanding the intention of malicious
software. These call arguments are extracted from the stack frames. Whenever a call is made, a
process must push all arguments onto the stack (illustrated in Figure 2(step 3)) before the process
jumps to a system call. The content of each item in stack is either a memory pointer or a real data
value. Spy satellite directly dumps the arguments from the memory of emulated system and records
them in process matrix.
Finally, some programs run in the multithread mode. The execution order of a thread is unpre-
dictable. We know that each thread has the same physical address for the page directory because
all of them share the same virtual space with the main process. But the memory section of each
stack is different because each thread owns an independent stack. Spy satellite is using the memory
section address of each stack to determine when a thread is starting to run and which thread invokes
a system call. Spy satellite also writes this information into the process matrix.
3.1.1. Algorithm. We use Algorithm 4 to explain the implementation for the spy satellite mecha-
nism that is used to obtain the CR3 value. Algorithms 1, 2, and 3 are data structures that will be
referenced in Algorithm 4. In Algorithm 4, the variable ‘SysCallVector’ is an instance of vector
with the data structure SysCallInfo. This structure is created by the intelligence agency that stores
entry points of all system calls. It can help spy satellite to map lower assembler code into mnemonic
higher-level system calls that will be illustrated later. The variable ‘CPU’ is an instance of the
data structure CPUInfo that stores the value of a CPU’s registers. The variable ‘ProcessVector’
is an instance of vector with the data structure ProcessInfo. It stores a tracking process’s infor-
mation such as entry point, CR3 values, and so on (illustration in Algorithm 2). The variable
‘StartupProcessVector’ is an instance of vector with the data structure ProcessInfo. All entry points
of start-up processes that do not have a corresponding value of CR3 from CPU are stored in this
variable.
Algorithm 1 The structure of SysCallInfo
1: typedef struct SysCallInfo ¹
2: uint32 EntryPoint
3: char *SysCallName
4: uint8 ArgSize
5: º
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1116 S.-Y. DAI ET AL.
Algorithm 4 The algorithm of obtainment CR3 value
Require: Intelligence Agency must be loaded before this component.
1: INPUT:Vector SysCallVector<SysCallInfo>
2: INPUT:CPU CPUInfo
3: INPUT:Vector ProcessVector<ProcessInfo>
4: INPUT:Vector StartupProcessVector<ProcessInfo>
5: OUTPUT:Vector ProcessVector<ProcessInfo>
6: OUTPUT:Vector StartupProcessVector<ProcessInfo>
7: ProcessInfo NewProcess
8: uint32 BaseAddressofArguments
9: if (CPUInfo.ProgramCounter DD SysCallVector.at ("CreateProcessInternalW") .EntryPoint or
SysCallVector.at ("CreateProcessInternalA").EntryPoint) then
10: BaseAddressofArguments D CPUInfo.Reg[ESP]
11: NewProcess.FileName D get file name from (BaseAddressofArguments C4)
12: NewProcess.EntryPoint D get the entry point of the process by Intelligence Agency.
13: StartupProcess.insert(NewProcess)
14: end if
15: if (CPUInfo.ProgramCounter DD StartupProcessVector.at(someone) .EntryPoint) then
16: NewProcess D StartupProcessVector.takeAt(CPUInfo.ProgramCounter)
17: NewProcess.CR3 D CPUInfo.Reg[CR3]
18: NewProcess.PID D assignment a process id
19: ProcessVector.insert(NewProcess)
20: end if
21: return
Algorithm 5 The algorithm of obtainment system call
1: INPUT:Vector SysCallVector<SysCallInfo>
2: INPUT:CPU CPUInfo
3: INPUT:Vector ProcessVector<ProcessInfo>
4: INPUT:Vector MatrixVector<ProcessMatrix>
5: OUTPUT:Vector MatrixVector<ProcessMatrix>
6: ProcessMatrix NewProcessMatrix
7: uint32 BaseAddressofArguments
8: if (CPUInfo.ProgramCounter DD SysCallVector.at(someone) .EntryPoint) then
9: NewProcessMatrix.PID D ProcessVector. at(CPUInfo.ProgramCounter) .PID
10: NewProcessMatrix.TID D check base address of stack
11: NewProcessMatrix.SysCallEntryPoint D ProcessVector.at (CPUInfo.ProgramCounter)
.EntryPoint
12: BaseAddressofArguments D CPUInfo.Reg[ESP]
13: NewProcessMatrix.StackData D obtain return address and arguments address from BaseAd-
dressofArguments
14: NewProcessMatrix.MemoryData D obtain content of arguments from memory
15: MatrixVector.insert(NewProcessMatrix)
16: end if
17: return
All system call code typically resides in several DLLs. A DLL file will be loaded into memory
when a process requires a system call from the DLL file. All entry points of required system calls
will be wrote into the memory section of a starting process when the operating system allocates
memory resource for the process. On the basis of our study, all DLL files specify entry points of
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1118 S.-Y. DAI ET AL.
Algorithm 7 The structure of EXPORT_DIRECTORY
1: typedef struct EXPORT_DIRECTORY ¹
2: uint32 Characteristics;
3: uint32 TimeDateStamp;
4: uint32 MajorVersion;
5: uint32 MinorVersion;
6: uint32 Name;
7: uint32 Base;
8: uint32 NumberOfFunctions;
9: uint32 NumberOfNames;
10: uint32 AddressOfFunctions;
11: uint32 AddressOfNames;
12: uint32 AddressOfNameOrdinals;
13: º
Algorithm 8 The algorithm of obtainment all entry points of system calls
1: INPUT:Vector DLLLsitVector<String>
2: INPUT:Vector SysCallArgSizeVector<String>
3: OUTPUT:Vector SysCallVector<SysCallInfo>
4: PEHeader PEHeader
5: EXPORT_DIRECTORY ExportDirectory
6: ByteArray buffer
7: uint32 ExpDirAdd
8: SysCallInfo NewSysCall
9: for i D 0 to DLLListVector.count() do
10: buffer=getBinary(DLLListVector.at(i).FileName)
11: PEHeader.PEOffset D buffer C0x3C
12: PEHeader.CodeBase D buffer C PEHeader.PEOffset C0x2C
13: PEHeader.SizeofHeader D buffer C PEHeader.PEOffset C0x54
14: PEHeader.ExportDirectory D buffer C PEHeader.PEOffset C0x78
15: ExpDirAdd D PEHeader.ExportDirectory  PEHeader.CodeBase C
PEHeader.SizeofHeader
16: ExportDirectory=getBinary(ExpDirAdd)
17: RVA2pFile(ExportDirectory)
18: for j D 0 to ExportDirectory.NumberofFunctions do
19: NewSysCall.EntryPoint D buffer C ExportDirectory. AddressOfFunctions C4j
20: NewSysCall.SysCallName D buffer C ExportDirectory. AddressOfNameOrdinals C2j
21: NewSysCall.ArgSize D SysCallArgSizeVector. at(NewSysCall.SysCallName)
22: SysCallVector.insert(NewSysCall)
23: end for
24: end for
We use Algorithm 8 to illustrate the procedure of entry points collection.
1. The variable ‘DLLListVector’ is an instance of vector with the data structure string. It stores
the file names of DLL files. It must be provided by security researchers to indicate which are
the necessary DLL files on the system.
2. The variable ‘SysCallArgSizeVector’ is an instance of vector with the data structure string. It
stores total size of arguments of every system calls.
3. From line 9 to line 24 is a nested loop. The outer loop is in charge of obtaining PE file header
and exports the directory table. The inner loop is in charge of obtaining all entry points of
system calls in the DLL file.
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1120 S.-Y. DAI ET AL.
anchors that loads a particular advertisement. Besides, holography has the capability to gen-
erate a correct and clear chain of anchors. This feature can help security researchers to track
malvertising attack.
4. EXPERIMENTS AND DISCUSSIONS
In this section, we report on three case studies to demonstrate how ‘holography platform’ can be
used in practice.
In the first experiment, we want to demonstrate that holography can correctly map binary opcodes
to high-level system calls. Besides, application-level functions that are tracked by holography can
help security researchers to understand the intention of malware.
In second experiment, we explain the steps of designing a generic unpacker and show how
holography can assist security researchers to analyze malicious programs.
In the last experiment, we propose an approach to identify appropriate application-level functions
to track the chain of anchors, which sequentially load code leading to malicious components. We
also show that holography has the capability to solve other emerging Internet threats.
All malware samples that are used in our experiments are user-mode malware. We do not consider
kernel mode malware here.
4.1. Data accuracy evaluation
To show that holography can correctly map hardware information to high-level system calls, we
compare several results of holography with those of some third-party software. First of all, we
examine the manual analysis reports from online resources that are provided by antivirus vendors.
Next, we perform a dynamic analysis of specific malware binaries using holography and online anal-
ysis tools such as CWSandbox (www.cwsandbox.org) and Anubis (anubis.iseclab.org) and compare
the results with manual analysis reports. However, it is very difficult to manually analyze malware
binaries that we have collected in our repository at the same time. We propose two comparisons so
far.
First, we use a detailed report on Trojan.PSW.Coced binary in [27]. It is designed to steal user
passwords. We summarize its actions as following:
1. The malware program changes the values of following system registry keys:
[HKCU/Software/Mirabilis/ICQ/Agent/Apps/ICQ]
“Enable” = “yes”
“Path” = “<path to Trojan executable file>”
“Startup” = “”
“Parameters” = “”
[HKCU/Software/Mirabilis/ICQ/Agent]
“Launch Warning” = “No”
2. The malware program uses the system call ‘WnetEnumCachedPasswords’ to harvest infor-
mation about existing connections used by the system to access the Internet and extracts the
passwords for these connections.
3. The malware program sends harvested data to the remote malicious user’s email address:
lenin******@usa.net
4. The malware program uses mail.computer.com as Simple Mail Transfer Protocol gateway to
send outgoing messages.
We perform analysis of this malware program (‘Trojan.PSW.Coced’) using the online resource
CWSandbox (www.cwsandbox.org) and obtain the analysis report. These results can be found in
[28]. In [28], the malware’s first action, according to our summary, can easily be identified; however,
the malware’s fourth action is not recognized. The CWSandbox report only shows that the malware
program establishes a TCP connection to port 25 of the host with IP address ‘149.174.40.151’.
Security researchers must rely on some additional skills, such as knowledge of Simple Mail Trans-
fer Protocol commands, to identify and recognize the intention of the malware program. Moreover,
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1122 S.-Y. DAI ET AL.
Figure 5. A holography analysis report. The report contains detailed information about actions of Winsock.
‘RegSetValueExA’ to create the system registry keys and assign some values to them. In Figure 5,
the first to fourth application-level functions show that the malware program uses the mail server
‘mail.compuserve.com’ to send outgoing message to ‘lenin1917@usa.net’ email address. They cor-
respond to the malware’s third and fourth actions except for the name of the mail server. But the
IP address of the mail server is the same as that of the CWSandbox’s report. The fifth system call
shows that the malware program plans to execute the system call ‘WnetEnumCachedPasswords’.
However, this system call has been removed since IE 4.01 by Microsoft. Therefore, the malware pro-
gram cannot use this system call to collect account information from a compromised computer. In
this experiment, we leverage two application-level functions to help security researchers understand
the real intention of the malware.
We discover another detailed report on Backdoor.Berbew.D in [30]. It allows a remote attacker to
control a compromised computer. We summarize its actions as following:
1. The malware program copies itself to the system folder.
2. The malware program creates a DLL file in the system folder.
3. The malware program creates the Table I system registry keys.
4. The malware program changes the Table II system registry keys.
5. The malware program creates the iexplorer.exe process and attempts to access the following
URLs:
i. http:/ /www.x0x.biz/wcmd.txt
ii. http:/ /www.x0x.biz/ppslog.php
iii. http:/ /www.x0x.biz/piplog.php
6. The malware program uses TCP/UDP connections for malicious intent.
All the aforementioned actions can be easily found in the holography, CWSandbox, and Anubis
[31] reports except for the fifth action. After we analyze the sequential actions of the malicious
process and the IExplorer process, we obtain additional information from our relational database.
Tables III and IV show convincing evidence for the fifth action. Furthermore, the analysis of the
malicious process demonstrates that the process creates a malicious HTML file with a piece of
Table I. The malware program creates following system registry keys.
[HKCR/CLSID/79FB9088-19CE-715E-D900-216290C5B738/InProcServer32]
“”=<path to the DLL file>
“ThreadingModel”=“Apartment”
[HKLM/Software/Microsoft/Windows/CurrentVersion/ShellServiceObjectDelayLoad]
“Web Event Logger”=“79FB9088-19CE-715E-D900-216290C5B738”
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1124 S.-Y. DAI ET AL.
In this experiment, we proposed an assumption to unpack various packing malware. Next, we
leverage holography to verify our assumption. Finally, we leverage holography to evaluate our
proposed approach.
4.2.1. Proposed assumption. According to our accumulated knowledge and experience, we assume
that packed applications have following characteristics:
1. For the original code to be restored, a corresponding unpacking procedure must be attached
with packed files. Otherwise, the packed files cannot restore their original code.
2. The original entry point of a packed file will be changed to the entry point of an unpacking
procedure because an unpacking procedure must be the first procedure of a packed file.
3. An unpacking procedure is external code, and it must be attached to the packed code later.
Therefore, original code and an unpacking procedure should reside at different sections. It
means that an unpacking procedure is complete if a process invokes a system call that resides
at a different section within the process allocated memory.
4. If a program was packed by two or more packers, such event may happen more than once.
According to our assumptions, we define a section-change event, under which a process invokes
a system call within a different memory section. We can obtain unpacking results when a section-
changing event is occurring. Next, we propose explicit definitions of sections in a running process. A
running process is organized as several sections that are defined in the PE file header of the process.
The following data illustrates this.
Size of code: This element indicates the size of the code section.
Size of initialized data: This element indicates the size of the initialized data section.
Size of uninitialized data: This element indicates the size of the uninitialized data section.
Image base: This element indicates the base address of the program that is loaded
into memory.
Base of code: This element plus the image base indicates the start address of code sec-
tion. The previous section is normally an uninitialized data section. The
next section is the initialized data section.
Base of data: This element plus the image base indicates the start address of the
initialized data section. The code section is the previous section.
Size of image: This element indicates the size of the program. If the size of image is
greater than the base of data plus the size of the initialized data, it means
that there is an external section after the initialized data section. External
section is usually created by packers.
Entry point: This element indicates the start address of the program.
There are two additional sections that are not defined in PE file header. One is the dynamic
allocation section; the other is the dynamic library section. Some unpacking procedures request the
operating system to offer dynamic memory space for them to restore the original code when unpack-
ing itself. We refer to this kind of section as a dynamic allocation section. In addition, an application
may load other external libraries (dynamic linking libraries) to execute its tasks. We name the vir-
tual space of loading libraries as dynamic library section. Figure 6 is an illustration of a running
process’s sections in virtual memory. The entry point of a packed program could be located at any
section. Intelligence agency obtains all the aforementioned information when a process is going to
be executed. We can retrieve this information in relational database later.
Next, we propose the following approach for holography to detect a section-change event. A
return address that is obtained by spy satellite can be used not only to determine whether we are
dealing with invoking system call that is a chained system call but also to determine in which sec-
tion the invoked system call is located. By correlating the section boundaries that are provided by PE
file header and some particular system calls such as VirtualAlloc, LoadLibrary et. al., and a return
address, holography has the capability to detect the section-change event.
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1126 S.-Y. DAI ET AL.
The values of the second and third columns in each row represent how many security-relevant
system calls are invoked by the applications in the corresponding section. If an application never
causes a section-change event until it enters the event listening loop, the third column will be ‘N’.
In Table V, all applications stay only in the first section except Peazip and FastStone Image Viewer,
which are packed by UPX. This results show the correctness of our observation. Besides, Figure 7
illustrates the ratio of security-relevant system calls between sections. Only Peazip and FastStone
Image Viewer have two sections in Figure 7, which illustrate the section arrangement with the bot-
tom as the first section and the top as the second section in the bar chart. We can see that the first
section, which represents an unpacking procedure of a packed application, has a very small rel-
ative size. It means an unpacking procedure is a small task in a packed application. It meets the
characteristic of packing.
4.2.3. Approach evaluation. Before we apply our approach to design a generic unpacker, we also
examine some variants of Trojan.PSW.Coced samples from our malware repository and perform
analysis using holography. There are 20 variants samples of Trojan.PSW.Coced in our repository.
We use PEiD [33], a signature-based packer detector, to filter nonpacked variant samples. Only nine
sampled variants are packed. We carry out the same experiment as in Section 4.2.2. According to the
detailed report in the Section 4.1, we examine whether malicious actions locate in the last section
confirm that the unpacking procedure is complete.
Table V. Section-change event statistic.
First section Second section
Microsoft Office Word 5029 N
Microsoft Office PowerPoint 3758 N
Microsoft Office Excel 9196 N
OpenOffice Writer 7716 N
OpenOffice Impress 13755 N
OpenOffice Calc 13006 N
Firefox 3595 N
Microsoft Internet Explorer 5984 N
Google Chrome 953 N
Microsoft notepad 62 N
Adobe Reader 1078 N
Microsoft Windows Media Player 1852 N
RealPlayer 541 N
Peazip 429 1250
7-zip 134 N
FastStone Image Viewer 647 7444
XnView 1249 N
Figure 7. Section-change statistic.
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1128 S.-Y. DAI ET AL.
that are executed on their system. We assume that there could be many different ways to design a
novel unpacker. We use holography to analyze normal applications and packed applications to con-
firm our assumption. Next, we use holography to analyze variant samples of Trojan.PSW.Coced to
confirm that our proposed approach is also appropriate. Finally, we demonstrate that our results are
consistent with Renovo’s results. According to our previous experiments, holography can also be
used as an effective code unpacker.
4.3. Malvertising tracking
As mentioned in Section 1, because an anchor may be dynamically generated by a complex tech-
nique, tracking a chain of anchors that led to a particular advertisement is a difficult work. In this
experiment, we first examine problem of tracking a chain of anchors. Second, we propose an iter-
ative approach to find out the critical factors that are used to dynamically generate a new anchor.
Finally, we examine our tool by browsing a commercial web page and then compare our results with
those from Fireshark.
4.3.1. Problem statement. A direct graph GURL D .V , E/ is a web resource topology of a web page.
8vURL 2 V is a web resource, such as image, HTML content, style file, and javascript file, which
is requested from another web resource. A direct edge ev,v0 2 E that connects from v to v0 means
that a web resource v0 is requested from a web resource v. Currently existing analyzers usually
leverage intuitive system calls, such as system call ‘send’ and ‘recv’ that reside in the dynamically
loaded library ‘ws2_32.dll’ to generate a web resource topology GURL. Therefore, we also use them
to generate a web resource topology and to show their limitation.
Figure 8 is a snippet of web resource topology Ghttp://www.gumtree.com. We leverage information from
intuitive system calls such as system call ‘send’ and system call ‘recv’ to generate it. According to
Figure 8, Dom1 is an initial web page, and its URL is http://www.gumtree.com. Dom26 is another
web resource that resides at http://as.thegumtree.com/common/dart_wrapper_v3_mpu_004.html
Figure 8. A web resource topology.
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1130 S.-Y. DAI ET AL.
Table VII. Discovered javascript methods and corresponding application-level functions.
Javascript method/problem Application-level function Library file
Web resource content HttpReadData wininet.dll
What time a browser run a javascript code COleScript::ParseScriptText jscript.dll
document.write CDocument::write mshtml.dll
Local function tracking VAR::InvokeByNameW
NameTbl::InvokeInternal jscript.dll
NameList::NME::FEqualSymName
NameTbl::FGetVval
document.createElement CDocument::createElement mshtml.dll
CDoc::NewDwnCtx
To examine whether an HTTP request has a corresponding anchor at its parent web resource, we
configure holography to track an application-level function ‘HttpReadData’ and record data that are
displayed on a browser. In addition, the time of the javascript execution is also important informa-
tion. We configure holography to track an application-level function ‘COleScript::ParseScriptText’
to gather such information. If an analyst wants to know which local function is invoked, four
application-level functions in Table VII can provide the information. If a programmer uses the
javascript method ‘document.createElement’ to dynamically create javascript code or other web
resources, two application-level functions in Table VII can be used to track this behavior.
4.3.3. Evaluation. We conduct three experiments to examine the capability of holography to gener-
ate a complete web resource topology. In the first experiment, we use a browser on top of holography
to browse a simple web page. In the second experiment, we browse a obfuscated web page. In the
last experiment, we browse a commercial web page and compare results with those by Fireshark.
Browsing a simple web page
Table VIII shows the source code of a simple web page. Obviously, which javascript code will
generate an anchor that loads a web resource http://l.yim.com/f/i/tw/moday/hp/110406_15.jpg is
unpredictable. However, a complete web resource topology should correctly appear as ‘cause’ and
‘effect’ during browsing. We use this simple web page to examine the capability of holography.
Figure 10 shows the results of this experiment. Each ellipse shape represents a web resource.
Each ellipse shape includes three or four notes:
First line: Web resource name.
Second line: Web resource type.
Third line: Host server.
Forth line: A triple marks. The first mark shows which javascript method generates a dynamic
anchor that loads this web resource. The second mark shows which web resource
includes the javascript code. The third mark shows how many bytes from the beginning
where we can find the javascript code.
If an anchor is generated by the second javascript code, holography will generate a complete
web resource topology as shown in Figure 10(b). Otherwise, holography will generate a complete
web resource topology like Figure 10(a). In this experiment, we show holography can leverage
application-level functions to generate a complete web resource topology.
Browsing an obfuscated Web page
Obfuscating javascript code is a common method used to protect source code. We use an online
javascript obfuscator to obfuscate the previous simple web page. Next, we use the obfuscated
javascript code to examine the capability of holography. Table IX is obfuscated javascript code,
and Figure 11 is result. In Figure 11, the result shows that holography is not affected by
obfuscation techniques.
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1132 S.-Y. DAI ET AL.
Table IX. Obfuscated simple web page.
Dom1
text/html
ddsn.ee.ntu.edu.tw
Dom2
image/jpeg
l.yimg.com
SW:Dom1:258
Figure 11. Result of second experiment.
browse web pages, to become active. If a user triggers the specific events, malicious programs per-
form other malicious actions to attack the users/computers. In other words, holography can detect
malicious behaviors only after some events are triggered by users. Holography does not include an
auto-test engine that can simulate the actions of users. That is, holography cannot track actions that
belong to the second phase without a user performing some actions on the monitoring operating
system. This problem reduces the effectiveness of holography. We are developing solutions to solve
this problem as our future research.
The war between hackers and defenders is never ending. Hackers constantly look for new meth-
ods to avoid detection, whereas defenders continue to design new architectures to detect and remove
malicious programs. Therefore, we believe that there is no perfect and final solution for the malware
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1134 S.-Y. DAI ET AL.
Figure 13. A snippet of FireShark result.
Table X. Web resource information.
Resource name Host location Path
Dom41 ads.revsci.net /adserver/ako
Dom45 optimized-by.rubiconproject.com /a/7942/12757/26569-15.js
Dom48 b.scorecardresearch.com /beacon.js
Dom49 tap-cdn.rubiconproject.com /partner/scripts/rubicon/alice.js
Table XI. Correct results.
Destination Path
Dom41 Dom1!Dom4!Dom39!Dom41
Dom45 Dom1!Dom4!Dom28!Dom43!Dom44!Dom45
Dom48 Dom1!Dom4!Dom28!Dom43!Dom44!Dom45!Dom48
Dom49 Dom1!Dom4!Dom28!Dom43!Dom44!Dom45!Dom49
actions of legitimate software may be mistakenly considered as a malicious intention. Therefore, an
insufficient supply of abnormal behavior models can lead to high false positive and/or false negative
rates of detection. It is important to design an automatic, system-wide, and fine-grained tool that
can provide security researchers with the ability to efficiently extract abnormal behavior models
from malicious programs. In this paper, we extend the capability of a hardware virtualization tool to
capture the activities of running processes without any assistance from an external tool or a driver
installed on a guest operating system. For the actions of each process to be tracked, holography mon-
itors CPU instructions and obtains useful information in real time from CPU registers and memory.
Holography has the advantage of being undetectable by malware because the critical components of
holography do not share the same system as the malicious programs.
In this paper, we designed several experiments to demonstrate how ‘holography platform’ could
be used in practice. In the first experiment, we compared holography’s report with CWSandbox’s
and Kaspersky Lab’s analysis reports. The results showed that holography’s detection is accurate.
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
1136 S.-Y. DAI ET AL.
10. Willems C, Holz T, Freiling F. Toward automated dynamic malware analysis using cwsandbox. IEEE Security &
Privacy 2007; 5(2):32–39.
11. Neugschwandtner M, Platzer C, Comparetti PM, Baye U. Danubis – dynamic device driver analysis based on vir-
tual machine introspection. Seventh Conference on Detection of Intrusions and Malware & Vulnerability Assessment
(DIMVA), Bonn, Germany, 2010.
12. Garfinkel T, Rosenblum M. A virtual machine introspection based architecture for intrusion detection. Proceedings
of the Network and Distributed Systems Security Symposium, San Diego, California, USA, 2003; 191–206.
13. Jiang X, Wang X, Xu D. Stealthy malware detection through VMM-based ‘out-of-the-box’ semantic view recon-
struction. In CCS ’07: Proceedings of the 14th ACM conference on Computer and Communications Security. ACM:
New York, NY, USA, 2007; 128–138. Available from: http://doi.acm.org/10.1145/1315245.1315262 [last access 25
August 2011].
14. Dai SY, Yarochkin FV, Wu JS, Lin CH, Huang Y, Kuo SY. Holography: a hardware virtualization tool for malware
analysis. In PRDC ’09: Proceedings of the 2009 15th IEEE Pacific Rim International Symposium on Dependable
Computing. IEEE Computer Society: Shanghai, China, 2009; 263–268.
15. Dasient q3 malware update: Web-based malware infections double since last year, malvertising attacks continue over
summer, 2010. Available from: http://blog.dasient.com/2010/11/normal.html.
16. Fireshark. Available from: http://fireshark.org/ [last access 25 August 2011].
17. Cova M, Kruegel C, Vigna G. Detection and analysis of drive-by-download attacks and malicious javascript code. In
Proceedings of the 19th international conference on World wide web, WWW ’10. ACM: New York, NY, USA, 2010;
281–290. Available from: http://doi.acm.org/10.1145/1772690.1772720 [last access 25 August 2011].
18. Jsunpack-a generic javascript unpacker, 2011. Available from: http://jsunpack.jeek.org/dec/go.
19. Yun J, Shin Y, Kim H, Yoon H. Miguard: detecting and guarding against malicious iframe through API hooking.
IEICE Electronics Express 2011; 8(7):460–465.
20. Wang YM, Roussev R, Verbowski C, Johnson A, Wu MW, Huang Y, Kuo SY. Gatekeeper: monitoring auto-start
extensibility points (ASEPs) for spyware management. LISA ’04: Proceedings of the 18th USENIX conference on
System Administration, Berkeley, CA, USA, 2004; 33–46.
21. Vasudevan A, Yerraballi R. Cobra: fine-grained malware analysis using stealth localized-executions. In SP ’06: Pro-
ceedings of the 2006 IEEE Symposium on Security and Privacy. IEEE Computer Society: Washington, DC, USA,
2006; 264–279.
22. Bayer U, Moser A, Kruegel C, Kirda E. Dynamic analysis of malicious code. In Journal in Computer Virology.
Springer: Paris, 2006; 2(1):67–77.
23. QEMU. Available from: http://wiki.qemu.org/Main_Page [last access 25 August 2011].
24. Bochs: the open source IA-32 emulation project. Available from: http://bochs.sourceforge.net/ [last access 25 August
2011].
25. Microsoft Portable Executable and common object file format specification. Available from: http://www.
microsoft.com/whdc/system/platform/firmware/PECOFFdwn.mspx [last access 25 August 2011].
26. Norman sandbox online analyzer. Available from: http://www.norman.com/security_center/security_tools/submit_
file/ [last access 25 August 2011].
27. Trojan-psw.win32.coced. Available from: http://www.viruslist.com/en/viruses/encyclopedia?virusid=34235 [last
access 25 August 2011].
28. Malware report for id: 9286147. Available from: http://www.sunbeltsecurity.com/cwsandboxreport.aspx?id=9286147
& cs=623A4F0AD5B3B972FFD41E121674603A [last access 25 August 2011].
29. Anubis: analyzing unknown binaries–trojan.psw.coced. Available from: http://anubis.iseclab.org/?action=result&
task_id=160424affa3b4ece4410d3f515bafb23b [last access 25 August 2011].
30. Security response:backdoor.berbew.d, 2007. Available from: http://www.symantec.com/security_response/
writeup.jsp?docid=2004-042118-3301-99&tabid=2 [last access 25 August 2011].
31. Anubis: analyzing unknown binaries–backdoor.berbew.d. Available from: http://anubis.iseclab.org/?action=result&
task_id=17f13653ac7eddb94b1705248d0a9786c [last access 25 August 2011].
32. Oberhumer MFXJ, Molnnr L, Reiser JF. Ultimate packer for executables. Available from: http://upx.sourceforge.net/
[last access 25 August 2011].
33. Peid. Available from: http://www.peid.info/ [last access 25 August 2011].
34. Kang MG, Poosankam P, Yin H. Renovo: a hidden code extractor for packed executables. In WORM ’07: Proceed-
ings of the 2007 ACM workshop on Recurring malcode. ACM: NY, New York, USA, 2007; 46–53. Available from:
http://doi.acm.org/10.1145/1314389.1314399 [last access 25 August 2011].
35. Böhne L. Pandoras bochs: automatic unpacking of malware. Diploma Thesis, RWTH Aachen University, 2008.
36. Attacks on virtual machine emulators. Available from: http://www.symantec.com/avcenter/reference/Virtual_
Machine_Threats.pdf [last access 25 August 2011].
Copyright © 2011 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2012; 42:1107–1136
DOI: 10.1002/spe
Currently existing analyzers usually 
model or user model system calls seque
invoked by a target process to infer the pro
However, both of them cannot provide suffi
to security researchers to track chain of an
generated by several javascript codes, beca
represent a procedure of a javascript code.  K
user model system calls only represent an ex
We leverage an example to describe this 
we give a definition of web resource topolo
to represent relationship between web re
graph Gurl = (V, E) is a web resource top
page.     is a web resource, such 
HTML content, a style file and a javascri
requested from another web resource. 
	

    which connects from v to v’ m
resource v’ is requested from a web resour
construct a web resource topology of a
leverage two system calls ”send” and ”recv
the dynamically loaded library ”ws2 32.dl
web resource topology Gurl. When a brow
system call “send”, security researcher
Fig
analyze kernel 
nce which were 
cess’s intention. 
cient information 
chors which are 
use they cannot 
ernel model and 
ecution result. 
issue. First of all, 
gy which is used 
source. A direct 
ology of a web 
as an image, a 
pt file, which is 
A direct edge 
eans that a web 
ce v. In order to 
 web page, we 
” which reside in 
l” to generate a 
ser invokes the 
s can infer a 
relationship between two web resou
parameter. Besides, security rese
content of a web resourced from th
when a browser invokes the system
browse a web page “http://www
system call sequence which is inv
construct the corresponding web res
Figure 1 is a web resource top
According to Figure 1, Dom1 is an
URL is http://www.gumtree. com. 
resource which resides at “h
common/dart_wrapper_v3_mpu_00
by Dom1. Dom55 is a javascrip
“http://googleads.g.doubleclick.net/p
and it was requested by Dom26. Ho
loads the Dom55 does not exist in D
the Dom26 HTML content. Actually
Dom55 is dynamically generated by
Therefore, this two system calls c
behavior semantics to generate the c
ure 1. A web resource topology Ghttp://www.gumtree.com
rce from the system call 
archers can obtain the 
e system call parameter, 
 call “recv”. Next, we 
.gumtree.com” and use 
oke by the browser to 
ource topology. 
ology Ghttp://www.gumtree.com. 
 initial web page and its 
Dom26 is another web 
ttp://as.thegumtree.com/ 
4.html” and is requested 
t file which resides at 
agead/test_domain.js” 
wever, the anchor which 
om26 when we examine 
, the anchor which loads 
 one javascript fragment. 
annot provide sufficient 
orrect chain of anchors. 
315
Figure 2. Resource topology of simple w
Figure 3. Resource topology of obfuscated sim
• Third line: host server. 
• Forth line: a triple marks. The f
which javascript method genera
anchor which loads this web resou
mark shows which web resour
javascript code. The third mark sh
bytes from the beginning where 
javascript code. 
 
If an anchor is generated by the second
Holography will generate a correct web reso
shown in Figure 2 Otherwise, Holograph
another  case. In this experiment, we show
leverage application-level function calls to g
web resource topology. 
TABLE II is obfuscated javascript code
result. In Figure 3, the result shows that Holo
is not affected by obfuscation techniques. 
Next, we browse a complex co
page ”http://www.gumtree.com” to examin
of Holography platform. Because the n
resources in the web page is 56, space lim
display of a readable complete web res
Therefore, we remove image files and sty
web resource topology to show the effec
platform. We  also compared our result to 
result which is a web browser (Firefox)
designed to track chain of anchors. Figure 4
Figure 5 is Fireshark result. We discove
 
TABLE III.  CPRRECT RESULT
Destination Path 
Dom41 Dom1> Dom4> Dom39
Dom45 Dom1> Dom4> Dom28
Dom44> Dom45 
Dom48 Dom1> Dom4> Dom28
Dom44> Dom45> Dom4
Dom49 Dom1> Dom4 > Dom28
Dom44> Dom45> Dom4
 
eb page 
 
ple web page 
irst mark shows 
tes a dynamic 
rce. The second 
ce includes the 
ows how many 
we can find the 
 javascript code, 
urce topology as 
y will generate 
 Holography can 
enerate a correct 
 and Figure 3 is 
graphy platform 
mmercial web 
e the capabilities 
umber of web 
itations preclude 
ource topology. 
le files from the 
tiveness of our 
the Fireshark [8] 
 plug-in that is 
 is our result and 
r that Fireshark  
S 
> Dom41 
> Dom43> 
> Dom43> 
8 
> Dom43> 
9 
TABLE IV.  WEB RESOUR
Resource 
name 
Host location 
Dom1 www.gumtree.com 
Dom4 www.gumtree.com 
Dom28 as.thegumtree.com 
Dom39 js.revsci.net 
Dom41 ads.revsci.net 
Dom43 ad.uk.doubleclick.net 
Dom44 ad.doubleclick.net 
Dom45 optimized-
by.rubiconproject.com 
Dom48 b.scorecardresearch.com
 
cannot correctly generate the chain
resources in TABLE III after we
result. Actually each web reso
corresponding anchor for its parent 
correctly and clearly shows the chai
is the correct chain of anchor of 
TABLE IV is the corresponding info
V. CONCLUTION AND 
In this paper, we address the s
malware analyzer when they face n
as malicious advertisement. Bec
analyzers usually use kernel mode
calls to represent “effect” of a brows
 
CE INFORMATION 
Path 
/ 
/ 
/common/dart_wrap
per_v3_mpu_004.ht
ml 
/gateway/gw.js 
/adserver/ako 
/adj/gtr.home/uk;l2
=;l3=;l4=;kw=;loc=
United 
%20Kingdom;pos=;
sz=300x250;tile=1;
page type=home 
uk;ubercat=1;!!AT
TRS!!;site=rouk;mt
fIFPath=/common/;
env=live;vip 
design=control;dc 
ref=http%3A//www
.gumtree.com/ 
/noidadj/gtr.home/u
k;l2=;l3=;l4=;kw=;l
oc=United 
%20Kingdom;pos=;
sz=300x250;tile=1;
page type=home 
uk; 
ubercat=1;!!ATTRS
!!;site=rouk;mtfIFP
ath=/common/;env=
live;vip 
design=control;dc 
ref=http%3A//www
.gumtree.com/ 
/a/7942/12757/2656
9-15.js 
 /beacon.js 
 of anchors of four web 
 examine the Fireshark 
urce cannot find the 
web resource. Our result 
n of anchors. TABLE III 
four web resource and 
rmation.  
FUTURE WORKS 
hortcomings of existing 
ew malicious attack such 
ause existing malware 
l or user model system 
ing, they do not have the 
317
capability to represent sufficient information about “cause” 
of a browsing. In order to solve this issue, we extend the 
capability of Holography platform to monitor application 
level function calls which are invoked by any process. In our 
experiment, we show Holography platform not only can 
track chain of anchors on a sample web page, but also 
Holography platform does not effect by obfuscation 
techniques. Besides, we also show that our result is correct 
than Fireshark’s result when we browse a complex 
commercial web page. 
Although application level function calls can represent 
high level behavior semantic, fast and efficient search 
appropriate application level function calls is a challenge. 
Not all application level function calls can be easy inferred 
their intention. Therefore, our next step is looking for 
appropriate mechanism to fast and efficient search 
appropriate application. 
 
 
 
REFERENCES 
[1] Dinaburg A, Royal P, Sharif M, Lee W. Ether: malware analysis via 
hardware virtualization extensions, Proceedings of the 15th ACM 
conference on Computer and communications security, 2008; 51–62. 
[2] Anubis: Analyzing unknown binaries. URL http://anubis.iseclab.org. 
[3] Yin H, Song D, Egele M, Kruegel C, Kirda E. Panorama: capturing 
system-wide information flow for malwareʳ detection and analysis. 
CCS ’07: Proceedings of the 14th ACM conference on Computer and 
communicationsʳsecurity, New York, NY, USA, 2007; 116–127. 
[4] Willems C, Holz T, Freiling F. Toward automated dynamic malware 
analysis using cwsandbox. Security & Privacy,ʳ IEEE March-April 
2007; 5(2):32–39, doi:10.1109/MSP.2007.45. 
[5] Shih-Yao Dai, Yarochkin Fyodor, Ming-Wei Wu, Yennun Huang, 
Sy-Yen Kuo, ”Holography: A Behavior-based Profiler for Malware 
Analysis”, Software: Practice and Experience, (accepted for 
publication). 
[6] Dasient q3 malware update: Web-based malware infections double 
since last year, malvertising attacks continue over summer 2010. 
URL http://blog.dasient.com/2010/11/normal.htm 
[7] Dai SY, Yarochkin FV,Wu JS, Lin CH, Huang Y, Kuo SY. 
Holography: A hardware virtualization tool for malware analysis. 
PRDC ’09: Proceedings of the 2009 15th IEEE Pacific Rim 
International Symposium on Dependable Computing, IEEE Computer 
Society, 2009; 263–268. 
[8] Fireshark. URL http://fireshark.org/. 
 
 
 
319
Figure 1. Implementation Diagram
Our inspiration of CEP engine implementation was Cayuga
engine[2], that uses non-deterministic automata to process
and analyse event streams. There is also massive amount of
research works on analysis of algorithms for automated par-
titioned index management and fault-tolerance[4][5]. There
also has been quite some research on distributed event pro-
cessing and log analysis for fault detection. The most no-
table work on distributed analysis is Sawzall platform [6],
which introduces a domain-specific language for massive
parallel processing of log data for purpose of statistic ag-
gregation. Another work on fault detection through data
analysis was presented in[1], which applies bilinear logistic
regression to set of features, produced by a group of ma-
chines in a cluster. In terms of scalable architecture for large
distributed log data analysis Weigert et. al.[8]. proposes
an approach uses graph mining via queries to distributed
nodes. In this work authors apply graph analysis techniques
to identify graphs, which match the similarity of known at-
tack patterns.
3. Architecture
We have implemented our indexer on top of Apache
SOLR project after careful evaluation of performance met-
rics of alternative solutions. In particular we did evaluate
performance of other distributed storage systems: Cassan-
dra and Riak and reviewed relevant works[7][3] in our own
experimental evaluation we were not able to exceed speed
of data indexing above 30kb per second per each node of our
three-node cluster. Diagram4 depicts performance evalua-
tion results of riak-search indexer (the first half of the graph)
vs. Apache SOLR. The message queue was introduced into
the architecture to balance the event bursts, when indexer
throughput is insufficient to handle excess of event data.
The created backlog is typically resolved during periods of
lesser loads. Figure2 depicts the backlog occurence on the
period of 24 hours.
Figure 2. Event backlog on 24 hour scale
Figure 1 denotes over-all architecture of designed sys-
tem. Raw network event log data is being collected and
classified using a set of distributed network agents. A rule-
based pattern matcher is used for classification. Normalized
event data is routed into both CEP engine and indexers mes-
sage queue.
The CEP engine is a non-deterministic finite automata,
which maintains states pi per each source of log data. Each
of the incoming event e, if satisfies one of the conditions
ti, can transition into state qi with stored data x, e. The
CEP engine we have implemented, models the minimalist
form of Cayuga engine[2]. The stored data and states are
preserved in Stats distributed store.
The shard management automation uses centralized syn-
chronization component (ZooKeeper), to keep track of
available shards, and data is distributed across the shards
using the time frame. On the top of this we use two bal-
anced indexers to accept and store new input data, while on
backend indexes are replicated to backend systems during
periods of lesser loads (we use scheduled replication). As
could be seen from the 3 the IO load variates significantly
during busy and non-busy hours. The failure of any single
shard replica could be easily handled, as this could be near-
real-time detected and replication process could be kicked
off. Multiple simultaneous failures could also be addressed
by increasing the redundancy number of spare replicas.
We also noticed that the number of data queries by sys-
tem users varies on different time frames with majority of
management platforms. In Proceedings of the 20th ACM in-
ternational conference on Information and knowledge man-
agement, CIKM ’11, pages 2385–2388, New York, NY, USA,
2011. ACM.
[4] F. Leibert, J. Mannix, J. Lin, and B. Hamadani. Automatic
management of partitioned, replicated search services. In
Proceedings of the 2nd ACM Symposium on Cloud Comput-
ing, SOCC ’11, pages 27:1–27:8, New York, NY, USA, 2011.
ACM.
[5] N. Li, J. Rao, E. Shekita, and S. Tata. Leveraging a scal-
able row store to build a distributed text index. In Proceed-
ings of the first international workshop on Cloud data man-
agement, CloudDB ’09, pages 29–36, New York, NY, USA,
2009. ACM.
[6] R. Pike, S. Dorward, R. Griesemer, S. Quinlan, and G. Inc. In-
terpreting the data: Parallel analysis with sawzall. In Scientific
Programming Journal, Special Issue on Grids and Worldwide
Computing Programming Models and Infrastructure, pages
227–298.
[7] N. Ruflin, H. Burkhart, and S. Rizzotti. Social-data storage-
systems. In Databases and Social Networks, DBSocial ’11,
pages 7–12, New York, NY, USA, 2011. ACM.
[8] S. Weigert, M. Hiltunen, and C. Fetzer. Mining large dis-
tributed log-data in near real-time. In Managing Large-Scale
Systems via the Analysis of System Logs and the Application of
Machine Learning Techniques (SLAML/SOSP), SLAML ’11,
pages 5:1–5:8, New York, NY, USA, October 2011. ACM.
100年度專題研究計畫研究成果彙整表 
計畫主持人：黃彥男 計畫編號：100-2218-E-001-008- 
計畫名稱：基於免特徵碼之惡意文件偵測與分析 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 1 1 100%  
研究報告/技術報告 0 0 100%  
研討會論文 1 1 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
