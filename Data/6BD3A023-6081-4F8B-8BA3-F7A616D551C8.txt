中英文摘要及關鍵詞
本計畫所要探討的問題是在 GIS 系統裡的一致性的動態地圖標記. 此種方法
可防止標記在 zooming in 的時候不會消失，在 zooming out 的時候不會突然
出現. 在此計畫裡我們設計了有效的略計算法, 以及我們發現這類問題大多
是 NP-complete 的. 我們的結果發表在 top conference SOCG 2008, 以及受
邀到 top journal CGTA 發表而且已被接受.
關鍵詞: 動態地圖標記，略計算法， PTAS, 一致性
The aim of this project is to study the consistent dynamic map labeling
methods in geographical information system (GIS). Such methods prevent
many distracting behavior such as popping and jumping during the zooming
of the interactive maps. We designed some new effective approximation
algorithms for this purpose. Moreover, we also investigate the
computational complexity of the problem we studied, and we found that
several variants of such problems are NP-complete. This result appears
in top international conference -- ACM Symposium of Computational
Geometry (SoCG) 2008, and it will appear in a special issue of top
international journal -- Computational Geometry: Theory and
Applications (CGTA).
Keywords: dynamic map-labeling, approximation algorithm, PTAS,
Consistency
Optimizing Active Ranges
for Consistent Dynamic Map Labeling
Ken Been
Computer Science Dept.
Yeshiva University
New York, NY, USA
kbeen@yu.edu
Martin Nöllenburg
∗
Faculty of Informatics
Karlsruhe University
Germany
noellenburg@iti.uka.de
Sheung-Hung Poon
Dept. Computer Science
National Tsing Hua University
Hsin-Chu, Taiwan
spoon@cs.nthu.edu.tw
Alexander Wolff
Faculteit Wiskunde en Informatica
TU Eindhoven
The Netherlands
www.win.tue.nl/˜awolff
ABSTRACT
Map labeling encounters unique issues in the context of dy-
namic maps with continuous zooming and panning—an ap-
plication with increasing practical importance. In consistent
dynamic map labeling, distracting behavior such as popping
and jumping is avoided. In the model for consistent dynamic
labeling that we use, a label becomes a 3d-solid, with scale
as the third dimension. Each solid can be truncated to a
single scale interval, called its active range, corresponding
to the scales at which the label will be selected. The active
range optimization (ARO) problem is to select active ranges
so that no two truncated solids overlap and the sum of the
heights of the active ranges is maximized. The simple ARO
problem is a variant in which the active ranges are restricted
so that a label is never deselected when zooming in. We in-
vestigate both the general and simple variants, for 1d- as
well as 2d-maps. The 1d-problem can be seen as a schedul-
ing problem with geometric constraints, and is also closely
related to geometric maximum independent set problems.
Different label shapes define different ARO variants. We
show that 2d-ARO and general 1d-ARO are NP-complete,
even for quite simple shapes. We solve simple 1d-ARO op-
timally with dynamic programming, and present a toolbox
of algorithms that yield constant-factor approximations for
a number of 1d- and 2d-variants.
Categories and Subject Descriptors
I.3.5 [Computer Graphics]: Computational Geometry and
Object Modeling
∗Supported by the German Research Foundation (DFG) un-
der grant WO 758/4-3.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee.
SCG’08, June 9–11, 2008, College Park, Maryland, USA.
Copyright 2008 ACM 978-1-60558-071-5/08/06...$5.00.
General Terms
Algorithms, Theory
Keywords
Dynamic map labeling, approximation algorithms, NP-hard-
ness
1. INTRODUCTION
Recent years have seen tremendous improvements in Inter-
net-based, geographic visualization systems that provide con-
tinuous zooming and panning (e.g., Google Earth), but rel-
atively little attention has been paid to special issues faced
by map labeling in such contexts. In addition to the need
for interactive speed, several desiderata for a consistent dy-
namic labeling were identified by Been et al. [2]: labels do
not pop in and out or jump (suddenly change position or
size) during panning and zooming, and the labeling does
not depend on the user’s navigation history. As an example,
Google Earth does not currently satisfy these desiderata.
Model.
We adapt the labeling model of Been et al. [2] as fol-
lows. In static labeling the key operations are selection and
placement—select a subset of the labels that can be placed
without overlap. Let each label L be defined in its own label
coordinates. A static placement of L is its image Lˆ in world
coordinates under a transformation composed of translation,
rotation, and dilation (see Figure 1a). A further transfor-
mation takes a portion of world coordinates to the screen,
dilating by factor 1/s; we define s to be the scale. Note
that s is the inverse of cartographic scale.
In dynamic labeling we select at each scale a subset of
labels that can be placed without overlap. To meet the
desiderata for consistent dynamic labeling we (1) define a
dynamic placement of L to be a function that assigns a
static placement Lˆs to each scale s ≥ 0; (2) require that
each dynamic placement be continuous with scale; (3) de-
fine dynamic selection to be a Boolean function of scale; and
(4) require that each label Li, 1 ≤ i ≤ n, be selected pre-
cisely on a single interval of scales, [ai, Ai], which is called
the active range of Li.
10
d extrusion shape – technique ARO dilation NP-compl. approx. running time see
triangles – dynamic program simple bs no optimal O(n3) Thm. 3
unit squares – line stabbing c ? 2/3 O(n log n) Thm. 6
unit-height rect. – MIS c yes 1/3 O(n log n) Thm. 4
1 unit-width rect. – line stabbing c yes 1/2 O(n log n) Thm. 5
rectangles – divide & conquer
general
c yes 1/ log n O(n log n) Thm. 7
segments of congruent triangles bs ? 1/2 O((k + n) log n) Thm. 10
congruent trapezoids bs+ c ? 1/2 O(k log n+ n log2 n) Thm. 8
congruent square cones bs yes 1/4 O((k + n) log2 n) Cor. 1
congruent square cones simple bs yes 1/8 O(n log3 n) Cor. 2
2 arbitrary square cones bs yes 1/24 O(n log3 n) Thm. 12
segments of congruent square cones bs yes 1/4 O((k + n) log2 n) Thm. 11
congruent frusta
general
bs+ c yes 1/(4W ) O(n4) Thm. 9
Table 1: Results attained in this paper, where k is the number of pairwise intersections between extrusions, W is the width
ratio of top over bottom side, and d is the dimension of the ARO problems.
2d-ARO with proportional dilation is NP-complete, even if
all extrusions are congruent square cones. Both proofs are by
reduction from Planar3SAT, the latter using 3d gadgets.
We present an algorithmic study of ARO in Section 3 by de-
veloping an algorithmic toolbox containing both new tech-
niques and new applications of known techniques to solve
several variants of ARO problems. One of our algorithms is
exact, the others yield approximations. Table 1 summarizes
our results.
Since we have just started to investigate these new prob-
lems, many questions remain unsolved—most notably: does
any of our problems have a polynomial-time approximation
scheme (PTAS)?—and require future effort, see Section 4.
2. COMPLEXITY
In this section, we prove that two variants of ARO are NP-
complete. Both proofs use a reduction from the NP-hard
problem Planar3SAT [9]. An instance of Planar3SAT is
a 3SAT formula ϕ whose variable-clause graph Gϕ is planar.
Note that Gϕ can be laid out such that all variables corre-
spond to points on the x-axis and clauses to non-crossing
three-legged “combs” above or below the x-axis [8].
Theorem 1. General 1d-ARO with constant dilation is
NP-complete; i.e., given a set E = {E1, . . . , En} of axis-
aligned rectangular extrusions in the plane and a real K > 0,
it is NP-complete to decide whether there is a set of pairwise
disjoint truncated extrusions T = {T1, . . . , Tn} with T1 ⊆
E1, . . . , Tn ⊆ En and H(T ) ≥ K. The problem remains NP-
complete when restricted to instances where all extrusions
are squares and each has one of three sizes, all extrusions
are unit-width rectangles and each has one of two heights,
or all extrusions are unit-height rectangles and each has one
of two widths.
Proof. For membership in NP , decompose each Ei into
O(n) horizontal strips determined by the lines {s = si, s =
Si | 1 ≤ i ≤ n}. Clearly there is an optimal solution that
corresponds to a union of such strips. So we can guess a sub-
set of the strips and then check in polynomial time whether
(a) strips from the same square are consecutive, (b) no two
strips overlap, and (c) their total height is at least K.
To show hardness, let ϕ be an instance of Planar3SAT.
We first treat square extrusions; i.e., we construct a set Eϕ
of squares as illustrated in Fig. 2 and fix a threshold K > 0
such that H(S(Eϕ)) ≥ K for an optimal solution S(Eϕ) if
and only if ϕ is satisfiable.
The squares in Eϕ have side lengths 1, 5, and 7. We refer to
a square of side length j as a j-square. In Fig. 2 all 5-squares
are highlighted by bold boundaries. Each 7-square contains
a vertically and horizontally centered chain of five (unique)
1-squares. Thus the 7-square can contribute at most three
units to H if the 1-squares contribute one unit each. Note
that this is more than if the 7-square contributes seven units
and all 1-squares contribute zero. The contribution of a 7-
square is a (7 × 3)-rectangle that can either appear above
or below the chain of 1-squares. We say that the 7-square
is in upper or lower state, which gives us a means to encode
Boolean values. The contributing part of each square is
shaded in Fig. 2, and each type of square has its own degree
of shading.
Each square in Eϕ belongs to a variable gadget, a literal
gadget, or a clause gadget. These gadgets correspond one-
to-one to the n variables, 3m literals, and m clauses of ϕ,
respectively.
The gadget of a variable x consists of a horizontal chain
of nx 7-squares (thus containing 5nx 1-squares), where nx
is a constant that depends on the appearance frequency of
x in ϕ. Adjacent 7-squares overlap so that their states must
alternate. We let x being true correspond to the leftmost
7-square of the gadget being in upper state. It is clear that
the gadget of x contributes at most 8nx units to H .
The gadget of a literal λ in ϕ consists of a 5-square Eλ
containing five 1-squares, vertically centered. Number the
7-squares in each variable gadget from left to right. If λ is
negated, then Eλ intersects the top edge of an odd-numbered
(or bottom-edge of an even-numbered) 7-square of the cor-
responding variable gadget. Otherwise parity flips; see the
positions of Ey and E¬z in Fig. 2. Each literal gadget con-
tributes at most seven units to H .
The clause gadget forms the afore-mentioned three-legged
comb, with a leg for each literal. Each leg has a vertical
segment, and the left and right legs also have horizontal
segments that contain an even number of 7-squares. The
literal gadgets connect the variable to the clause leg, see
Fig. 2. The leg of literal λ consists of a fixed number mλ
(depending on ϕ) of 7-squares and 5mλ 1-squares, contribut-
ing at most 8mλ units to H .
12
(a) Variable gadget for x = true.
(b) One literal is true (green).
(c) All literals are false (red).
Figure 4: 3d-models of the variable and clause gadgets in Theorem 2 (with partial literal gadgets).
...
...
...
x ¬x
x
(a) Variable x = true.
...
...
...
x ¬x
x
(b) Variable x = false.
...
. . .. . .
false true
false
(c) One literal is true.
...
. . .. . .
false false
false
(d) All literals are false.
Figure 5: 2d-projections of the variable and clause gadgets in Theorem 2 (with partial literal gadgets).
rithm, line stabbing, and divide and conquer. We concen-
trate on two algorithms that apply new techniques: a top-
to-bottom fill-down sweep, and a level-based small-to-large
greedy algorithm.
3.1 Dynamic programming
Triangles.
We start by considering simple 1d-ARO with proportional
dilation: each extrusion Ei is a triangle with apex on the x-
axis and top side on the horizontal line s = Smax. The trun-
cated extrusions Ti differ only by having (possibly) lower top
sides. Observe that in an optimal solution at least one Ti
has height Smax, and thus divides the problem into two in-
dependent subproblems. This is the essence of the dynamic
programming solution.
Theorem 3. Simple 1d-ARO with proportional dilation
can be solved in O(n3) time.
Proof. Let pi be the apex of wedge-shaped extrusion Ei
on the x-axis. For ease of notation define dummy wedges
E0 and En+1 with apexes p0 and pn+1, and assume that
p0, . . . , pn+1 are sorted from left to right. For i < j, define
the free space ∆(i, j) between pi and pj to be the triangular
or trapezoidal space enclosed by s = 0, the right side of Ei,
the left side of Ej , and possibly s = Smax. Let A[i, j] be
the optimal solution for pi+1, . . . , pj−1 in ∆(i, j). In A[i, j],
at least one of Ti+1, . . . , Tj−1 must touch a non-bottom side
of ∆(i, j), thus dividing the problem into two independent
subproblems. For each k = i+ 1, . . . , j − 1, we denote by
hk the scale at which Tk first reaches a non-bottom side of
∆(i, j). Then A[i, j] = maxj−1k=i+1(A[i, k]+hk+A[k, j]), and
the optimal solution for our problem is A[0, n + 1]. Each
of the O(n2) entries in the dynamic programming table is
computed in O(n) time, giving O(n3) time in total.
3.2 Left-to-right greedy algorithm
Unit-height rectangles.
Van Kreveld et al. [13] presented the following greedy al-
14
Theorem 7. The divide-and-conquer algorithm computes
in O(n log n) time a (1/ log n)-approximation to the maxi-
mum total active range height for a set of n rectangles.
3.5 Top-to-bottom fill-down sweep
A number of variants of 1d- and 2d-ARO are approxi-
mated by a constant factor with Algorithm 1, below. The
idea is to sweep down over the extrusions in E , and if Ei ∈ E
is selected at scale s, we“fill”Ei from s down to its bottom—
i.e., we set [ai, Ai] = [si, s]. Thus we have ai = si for every
Ei that contributes to the objective function H at all.
Say that Ei is available if its available range includes the
current sweep scale s, and active if its active range has al-
ready been set and covers s. We are interested in event
points at which the conflict graph over the available extru-
sions changes. This happens at each Si and si, and with
some extrusion shapes it also happens at additional scales.
If Ei and Ej are both available at s and at s
′ > s, and they
intersect at s′ but not at s, then let sij refer to the lowest
scale at which they intersect. Let k be the number of sij
events over E . We make use of a subroutine, “try to pick”
Ei, which means, “if Ei does not intersect the interior of any
extrusion already chosen to be active at the current sweep
scale s, then make Ei active and set [ai, Ai] = [si, s]”.
Algorithm 1. Top-to-bottom sweep algorithm.
Sweep a line or plane from top to bottom. At
each event point of type Si, si, or sij , try to pick
each available but inactive extrusion Ej , in non-
increasing order of Sj .
The following lemma will help prove the approximation
factors. Let A = {(ai, Ai)} be the solution computed by
Algorithm 1. Say that Ej blocks Ei at scale s under a given
solution if Ei and Ej overlap (i.e., their interiors intersect)
at s and s ∈ [aj , Aj ]. Note that this implies that s /∈ [ai, Ai].
Say that two extrusions are independent at s if their restric-
tions to the horizontal plane at scale s are non-overlapping.
Lemma 2. If, for any E ∈ E and s ≥ 0, E can block no
more than c pairwise independent extrusions at s, then A is
a (1/c)-approximation for the maximum total active range
height of E .
Proof. Suppose that E ∈ E is inactive at scale s un-
der A. Then E must be blocked at the nearest event point
above (or at) s since otherwise it would be picked by Algo-
rithm 1. Since the extrusion conflict graph only changes at
event points, E is blocked at s. Thus, in A, if E is inactive
at any scale s then E is blocked at s.
If at any scale no extrusion can block more than cmutually
independent extrusions, and in A every inactive extrusion is
blocked, then at any scale the number of active extrusions in
an optimal solution can be no more than c times the number
in A. Integrating over all scales proves the lemma.
For each of the extrusion shapes covered in this section
we determine a value for c, usually 2 or 4. For example, it
is easy to see that c = 2 for unit-width rectangles (or, more
generally, for any set of rectangles where the x-order of the
left edges is the same as the x-order of the right edges),
so Algorithm 1 yields a (1/2)-approximation. It runs in
O(n log n) time. (Compare Theorem 5.)
Congruent trapezoids.
The top-to-bottom nature of Algorithm 1 ensures that if
Ej blocks Ei at scale s then Ei intersects at least one side
edge of Ej at s. This implies c = 2 in Lemma 2.
Theorem 8. Algorithm 1 computes a (1/2)-approximation
for the maximum total active range height of a set of n con-
gruent trapezoids in O(k log n + n log2 n) time, where k is
the number of pairs of intersecting trapezoids.
Proof. We first show that with congruent trapezoids, if
Ej blocks Ei at scale s under solution A, then Ei must
intersect at least one side edge of Ej at scale s. This implies
c = 2 in Lemma 2, and thus the 1/2 approximation factor.
Suppose Ej blocks Ei at s. If Si ≤ Sj then Ei is at
least as wide as Ej at s, so it must intersect a side edge of
Ej . If Si > Sj then Ei is also available at scale Aj , when
Algorithm 1 selects Ej , and since the trapezoids are wider at
higher scales, Ei and Ej also intersect at Aj . But Ei must
also be blocked by another trapezoid at Aj since otherwise
Algorithm 1 would choose it over Ej . Thus, Ei intersects a
side edge of Ej at Aj , and since they are congruent, it must
also at s.
It remains to justify the time complexity. Initially we
use a simple plane-sweep algorithm to find the sij events in
O((k + n) log n) time. Then we create the sorted event list
with si, Si, and sij events. If multiple events occur at the
same scale, then say that the si events come first, then the
sij events, and finally the Si events.
We use the fact that all trapezoids are congruent to trans-
form them into a dual space. For a trapezoid E denote the
abscissae of the intersections of the x-axis and the down-
ward extensions of the left and right edges of E by λ(E)
and ρ(E), respectively. (Notice that all trapezoids lie above
the x-axis.) This defines a point δ(E) = (λ(E), ρ(E)) in the
dual space. Similarly, an arbitrary point p above the x-axis
is mapped to a point δ(p) in the dual space using lines with
the same slopes as the left and right edges of the trapezoids.
See Fig. 7a. Most importantly, note that we can activate the
trapezoid E′ in the free space defined by the line segment
[p, q] if λ(E′) ≥ λ(p) and ρ(E′) ≤ ρ(q).
We use a balanced binary search tree for the active list,
where the active trapezoids are ordered left to right by their
segment intersections with the sweep line. For the available
list, we use a 2-dimensional “dynamic priority range tree”,
which stores δ(Ei) for each available but inactive trapezoid
Ei. A query on this structure asks for the point with maxi-
mum Si among those in a rectangular region of (λ, ρ) space.
Specifically, the query region [λ(p),∞)× (−∞, ρ(q)] returns
the highest trapezoid that can be made active in the free
space defined by line segment [p, q].
We modify the usual plane sweep algorithm as follows: if
multiple si events, or multiple sij events, share the same
scale, then we consider the group of events together.
For one or more si events at the current sweep scale, re-
move each Ei from the active list, maintaining a new list of
[p, q] intervals freed by each. If any free interval contains a
previously found interval, retain only the larger one. Then
we traverse the interval list until it is empty. For each [p, q]
on the interval list, query the available list for the topmost
trapezoid Ej that can be made active in [p, q]. If an Ej is
found, add it to the active list. This splits [p, q] into two
parts [p, p′] and [q′, q] to the left and right of Ej . Append
[p, p′] and [q′, q] to the interval list.
16
at most four such extrusions can be independent. Thus the
approximation factor 1/4 follows from Lemma 2.
In the implementation we use a range tree for the active
extrusions, a range tree for the available extrusions, and a
heap for the event list. The event list initially has all Si and
si events. The range trees store the apex locations in the
(x, y) plane of the underlying cones. We can easily compute
a range in the (x, y) plane containing cones that intersect a
given cone at a particular scale.
At event Si we first try to pick Ei. This requiresO(n log
2 n)
time over all Si events. Next we compute sij for each
Ej in the available list that intersects Ei. This requires
O(k′ + log2 n) time for each Ei, or O(k + n log
2 n) over-
all. Each computed sij is added to the event list, requiring
O(k log n) time in total. Finally, Ei is added to the available
list, requiring O(n log2 n) time in total.
At event si we first remove Ei from the available list, and
from the active list if it is active, requiring O(n log2 n) time
in total. If Ei has been active we search the available list
for extrusions that intersect Ei at si. This requires O(k
′ +
log2 n), or O(k + n log2 n) time overall. We can sort the
extrusions found in O(k′ log k′) time, or O(k log n) overall,
and then try to pick each one in order of their heights, which
will require O(k log2 n) time overall.
At event sij , if one of Ei and Ej is active, then try to pick
the other. This requires O(k log2 n) time overall.
Altogether, the time complexity is O((n+ k) log2 n).
Simple ARO with congruent square cones is a special case
of the above, with each [si, Si] = [0, Smax], so we immedi-
ately get the following corollary.
Corollary 1. Given a set of n congruent square cones,
Algorithm 1 computes a (1/4)-approximation for the maxi-
mum total active range height in O((n+ k) log2 n) time.
3.6 Level-based small-to-large greedy algorithm
In this section we give an algorithm for simple 2d-ARO
with square cones. It computes a (1/8)-approximation when
the cones are congruent, and a (1/24)-approximation other-
wise. The algorithm intersects the given cones with O(log n)
horizontal planes, starting at Smax and proceeding down-
ward.
Algorithm 2. Level-based algorithm for 3d-cones
Initially no extrusion is active. In phase i, i =
0, . . . , ⌈log n⌉, let πi be the horizontal plane at
scale s = Smax/2
i. Let Eij be the intersection
of extrusion Ej with πi and call E
i
j active if Ej
is already active. As long as there is an inac-
tive object Eij that does not intersect any active
object, choose the smallest such object Eij⋆ and
make Ej⋆ (and E
i
j⋆) active by setting Aj⋆ = s.
We first consider arbitrary square cones that are symmet-
ric to the vertical axes passing through their apexes. When
the algorithm terminates, all squares at level i that are not
active must intersect an active square—they are blocked. We
associate each blocked square Eij to one of the active squares
in the following way: (i) If Eij was not blocked at the be-
ginning of phase i but became blocked by a newly activated
square Eik, then associate E
i
j to E
i
k. (ii) If E
i
j was blocked
in the beginning of phase i then associate Eij to any of its
blocking squares that were active at the beginning of phase
i. Next, we show that the squares associated to an active
square cannot be arbitrarily small.
Lemma 3. Let Eij be an active square at level i with side
length ℓij . Then any square associated to E
i
j has side length
at least ℓij/3 and intersects the boundary of E
i
j.
Proof. Let Eik be associated to E
i
j with ℓ
i
k < ℓ
i
j . By
the greedy choice of the algorithm, all squares associated
to a newly active square are larger than it. This implies
that Ej must have been activated at a higher level, and that
Ek must have been reassigned to Ej at some level h ≤ i.
Thus, at level h− 1 square Eh−1k was associated to another
square Eh−1l . Note that for this reassignment to take place
at level h, Eh−1j must have been active. Thus we know that
Eh−1j and E
h−1
l do not intersect, but they both intersect
Eh−1k ; see Fig. 8a. At level h the reassignment takes place
because Ehk no longer intersects E
h
l but still intersects E
h
j ;
see Fig. 8b. Now suppose ℓhk < ℓ
h
j /3. Then by going from
level h to h− 1 the side lengths of the squares are doubled
and it is easy to verify that Eh−1k would be contained in
Eh−1j , a contradiction to the fact that E
h−1
k ∩ E
h−1
l 6= ∅.
As ℓhk ≥ ℓ
h
j /3 this also holds for level i, and since E
h−1
k
intersects the boundary of Eh−1j this is also still true for
level i.
Define π⌈log n⌉+1 as the plane s = 0. We denote the active
segments of the extrusions between planes πi−1 and πi in the
optimal solution S by Si and in the solution of our algorithm
byAi, respectively. We charge the active range heightH(Si)
to that of H(Ai+1).
Lemma 4. For each level i ∈ 1, . . . , ⌈log n⌉ − 1 it holds
that H(Ai+1) ≥ 1/24 H(Si).
Proof. Let square Eij be active in A and consider the
set D(Eij) of squares in πi associated to it. The squares
in D(Eij) that correspond to active extrusions in Si cannot
intersect each other.
By Lemma 3, all squares inD(Eij) have side length at least
ℓij/3 and intersect the boundary of E
i
j . Thus, at most 12 of
those squares can be independent in πi and hence active in
Si like in Fig. 9. Now the height between levels i and i− 1
is twice the height between levels i + 1 and i. Hence the
active height of Ej in Ai+1 is at least 1/24 times the sum of
heights of active extrusions in Si whose squares at level i are
associated to Eij . It follows thatH(Ai+1) ≥ 1/24 H(Si).
Theorem 12. Algorithm 2 computes a (1/24)-approxi-
mation to the maximum total active range height of a set
of arbitrary square cones in O(n log3 n) time.
Proof. It remains to compareH(S⌈logn⌉)+H(S⌈logn⌉+1)
to H(A⌈logn⌉+1) + H(A1). The height of π⌈log n⌉−1 is at
most 2Smax/n and obviously there are at most n active cone
segments in S below π⌈logn⌉−1, so their total active range
height is at most 2Smax. On the other hand, there is at least
one active cone segment in A1 of height Smax/2. Together
with Lemma 4 this implies the approximation factor 1/24.
For an efficient implementation of Algorithm 2 we store
the squares in each level i in a two-dimensional segment tree
τi, which supports deletion in O(log
2 n) time [4]. For each
square Eij that has been activated at a previous level we
18
Optimizing Active Ranges for Consistent Dynamic Map Labeling
Ken Beena, Martin No¨llenburgb,1, Sheung-Hung Poonc,2, Alexander Wolffd
aCyrus Innovation, LLC, New York, NY, U.S.A.
bFaculty of Informatics, Universita¨t Karlsruhe and Karlsruhe Institute of Technology (KIT), Germany
cDepartment of Computer Science, National Tsing Hua University, Hsinchu, Taiwan, R.O.C.
dFaculteit Wiskunde en Informatica, TU Eindhoven, The Netherlands
Abstract
Map labeling encounters unique issues in the context of dynamic maps with continuous zooming and
panning—an application with increasing practical importance. In consistent dynamic map labeling, dis-
tracting behavior such as popping and jumping is avoided. We use a model for consistent dynamic labeling
in which a label is represented by a 3d-solid, with scale as the third dimension. Each solid can be truncated
to a single scale interval, called its active range, corresponding to the scales at which the label will be
selected. The active range optimization (ARO) problem is to select active ranges so that no two truncated
solids intersect and the sum of the heights of the active ranges is maximized. Simple ARO is a variant in
which the active ranges are restricted so that a label is never deselected when zooming in. We investigate
both the general and simple variants, for 1d- as well as 2d-maps.
Different label shapes define different ARO variants. We show that 2d-ARO and general 1d-ARO are
NP-complete, even for quite simple shapes. We solve simple 1d-ARO optimally with dynamic programming,
and present a toolbox of algorithms that yield constant-factor approximations for a number of 1d- and
2d-variants.
Key words: consistent dynamic map labeling, active range optimization, NP-hardness, approximation
algorithms
1. Introduction
Recent years have seen tremendous improvements in Internet-based, geographic visualization systems
that provide continuous zooming and panning, but relatively little attention has been paid to special issues
faced by map labeling in such contexts. In addition to the need for interactive speed, several desiderata for
a consistent dynamic labeling were identified by Been et al. [2]: labels should not pop in and out or jump
(suddenly change position or size) during panning and zooming, and the labeling should not depend on
the user’s navigation history. Currently available systems (for example, Google Earth, NASA World Wind,
Microsoft Virtual Earth, and KDE Marble) do not satisfy these desiderata and their labeling algorithms
may produce rather unattractive dynamic labelings—at least during user interaction.
In static labeling we want to select a (maximum) subset of labels that can be placed without intersection,
given certain constraints on the size, location and orientation of each label. A natural extension of this to
dynamic labeling is to select at each scale a maximum subset of labels that can be placed without intersection,
subject to similar constraints on the label placements. We take the aforementioned consistency desiderata
as additional constraints. Clearly the desiderata mandate that the labeling at scale s must take into account
labelings at scales in the neighborhood of s. In fact we can go further: by taking scale as our “vertical”
dimension, the desiderata mandate that the label placement must be continuous with scale—that is, the
Email addresses: kbeen@cyrusinnovation.com (Ken Been), spoon@cs.nthu.edu.tw (Sheung-Hung Poon)
URL: i11www.iti.uka.de/group/noelle (Martin No¨llenburg), www.win.tue.nl/~awolff (Alexander Wolff)
1Supported by grant WO 758/4-3 of the German Research Foundation (DFG).
2Supported by grant 97-2218-E-007-006 of the National Science Council (NSC), Taiwan, R.O.C.
Preprint submitted to CGTA May 11, 2009
sy
x
(a)
aL
AL
sL
SL
x
s
(b)
x
s
(c)
Figure 3: (a) A dynamic placement of a 2d-label is a solid in extended world coordinates. Here: with
proportional dilation and invariant point placement with the center as the invariant point. (b) A 1d-label
with constant dilation, selectable range (sL, SL), and active range (aL, AL). (c) A 1d-label with proportional
dilation and the left endpoint of the label as the invariant point.
rotation and dilation factors given by continuous functions of scale. We call E the extrusion of L. An
example is given in Figure 3a. Let the lower and upper endpoints of the sweep curve segment have scale sL
and SL, respectively. Let the trace trs?(E) of E at scale s? be the intersection of E with the horizontal
line or plane s = s? for 1d and 2d labels, respectively. Then trs(E) is a static placement of L for each
s ∈ (sL, SL).
We define the selectable range of L to be the open interval (sL, SL). The selectable range defines the
scales at which L is available for selection. For example, street labels are selectable at smaller scales and
country labels at larger scales. Let Smax be a universal maximum scale for all labels. Then we require that
(sL, SL) ⊆ (0, Smax).
We define dynamic selection to be a Boolean function of scale. We require that each label L be selected
precisely on a single interval of scales, (aL, AL) ⊆ (sL, SL), which is called the active range3 of L. It
defines the scales at which L is actually selected or active. We define the truncated extrusion of L to be the
restriction of E to the active range (aL, AL). If its active range is empty then L is never selected.
This model is quite general. The extrusion shapes are determined by the label shape and the translation,
rotation and dilation functions that compose the dynamic placement, the only restriction being that these
functions are continuous. For the specific ARO variants that we consider in this paper, however, we now
restrict our attention to certain classes of extrusions that are simple and yet arise naturally in applications.
Our 2d-labels are open rectangles (for example, bounding boxes of textual labels); we also consider 1d-
labels, which are open intervals on the x-axis—see Figure 3b. For rotation and translation, we consider only
axis-aligned invariant point placements: the rotation component is constant and maps L to an axis-aligned
rectangle at each scale, and the translation component is constant and maps a particular reference point of
the label always to the same location in world coordinates. In other words, our labels never slide or rotate.
For the dilation component we consider only linear functions of the form DL(s) = bs + c, and only three
classes of these:
• If b = 0 and c > 0, that is, DL(s) = c, then the label size is fixed in world coordinates and inversely
proportional to scale on screen. Thus labels shrink at the same rate as the geographic features when
zooming out and grow when zooming in. The solid is then a “straight” extrusion, as in Figure 3b.
• If b > 0 and c = 0, that is, DL(s) = bs, then L has constant size on screen and size proportional to
scale in world coordinates. The solid is then a label-shaped cone with apex at s = 0 as in Figure 3a.
With invariant point placements, the cone contains the vertical line through its apex. The cone might
3For visualization we should consider the active range of L a half-open interval (aL, AL] since this gives a seamless transition
from one label to the next during zooming. For notational convenience, simplicity, and symmetry, however, we use open
intervals. This does not change our results.
3
d ARO extrusion shape dilation NPC approx. running time O(·) see
simple triangles bs no optimal n3 Thm. 4
unit squares c ? 2/3 n log n Thm. 7
unit-height rectangles c ? 1/3 n log n Thm. 5
1 unit-width rectangles c ? 1/2 n log n Thm. 6general
rectangles c yes 1/ log n n log n Thm. 8
segments of congruent triangles bs ? 1/2 (k + n) log n Thm. 10
congruent trapezoids bs+ c ? 1/2 (k + n) log n Thm. 9
congruent square cones bs yes 1/4 (k + n) log2 n Cor. 1
simple congruent square cones bs yes 1/4− ε n log n · log(n/ε)/ε Thm. 14
2 arbitrary square cones bs yes 1/24 n log3 n Thm. 13
segments of congruent square cones bs yes 1/4 (k + n) log2 n Thm. 12general
congruent square frusta bs+ c yes 1/(4W ) n2 Thm. 11
Table 1: Results attained in this paper, where d is the dimension of the ARO problems, NPC means NP-
complete, k is the number of pairwise intersections between (side edges/faces of) extrusions, ε > 0, andW is
the width ratio of top over bottom side.
rectangle. Buchsbaum et al. [3] give a (2+ε)-approximation algorithm for this problem and polynomial-time
approximation schemes for a number of special cases.
Previous work. Map labeling has been identified as an important application area by the Computational
Geometry Impact Task Force [4], and has been the focus of extensive algorithmic investigation [17]. The vast
majority of research on this topic covers static labeling. A typical goal is to select and place labels without
intersection while optimizing an objective function. The objective function might be simply the number of
labels [1, 16], or it might incorporate multiple cartographic criteria [5]. There are many variations possible,
and most have been shown to be NP-hard [8, 10, 16].
For dynamic labeling, Petzold et al. [13, 14] use a preprocessing phase to generate a data structure that
is searched during interaction to produce a labeling for the current scale and view area. Popping can occur
because a small change in scale or location leads to a recomputation of the labeling on a different set of
labels. Poon and Shin [15] precompute solutions for a number of scales; interpolating between these yields
solutions for any scale. Popping and jumping effects can occur because during zooming the labeling solution
for the current scale is computed regardless of the solution for the previous scale. In addition to introducing
consistency for dynamic map labeling, Been et al. [2] show that simple 2d-ARO is NP-complete for arbitrary
star-shaped labels, and implement a simple heuristic solution.
Outline. We investigate the complexity of ARO in Section 2. We prove that general 1d-ARO with constant
dilation is NP-complete, even if all extrusions are squares, and that simple 2d-ARO with proportional
dilation is NP-complete, even if all extrusions are congruent square cones. Both proofs are by reduction
from Planar 3SAT, the latter using 3d gadgets. We present an algorithmic study of ARO in Section 3,
developing a toolbox of techniques to solve several variants of ARO problems. One variant is solved exactly,
the others with approximations. Table 1 summarizes our results. Note that all our results for 2d-ARO with
congruent square cones can be generalized to congruent and non-rotated rectangular cones by dilating the
input space in x- or y-direction. Similarly, the result for arbitrary square cones can be generalized to similar,
non-rotated rectangular cones.
Dynamic labeling is a new sub-discipline of map labeling and our work presents a first extensive collection
of complexity and algorithmic results. Many questions, however, remain unsolved—most notably: does any
of our problems have a polynomial-time approximation scheme?—and require future effort. We conclude
the paper with a list of open problems in Section 4.
5
x = true y = false z = false
¬x y ¬z
QC Q
′
C
. . .
. . .
. . .


clause
gadget
{
variable
gadget
literal
gadget
Figure 5: The gadgets of our reduction for the clause C = (¬x ∨ y ∨ ¬z).
Literal gadgets. A clause of ϕ consists of three literals. A literal gadget connects a variable gadget to a
clause gadget, implementing one of the three legs of the aforementioned comb. The gadget of a literal λ
consists of a vertical part and, if λ corresponds to the left or right leg of a comb, a horizontal part. A vertical
part consists of a chain of regular 5-squares where consecutive squares overlap by one unit. A horizontal
part is identical to a variable gadget, see Figure 5. The last square of the vertical part is the first square of
the horizontal part.
Number the 5-squares in each variable gadget from left to right. If λ is negated, the first 5-square of
the gadget of λ overlaps the top of an odd-numbered (or the bottom of an even-numbered) 5-square of
the corresponding variable gadget by one unit. Otherwise parity flips; see the positions of the gadgets of
literals ¬x and y in Figure 5.
Note that the vertical part of a literal gadget contributes maximally to H (that is, with six units per
regular 5-square) if all 5-squares are in the same state as the intersected 5-square of the variable gadget.
If the gadget of a literal λ has a horizontal part, then the states of the 5-squares in that horizontal part
alternate as in a variable gadget. We insist that any horizontal part consists of an even number of 5-squares.
Thus the state of the final 5-square of the gadget of λ is opposite to that of the first 5-square. The literal
gadget can be seen as a mechanical construction that transmits pressure from the variable gadget into the
clause gadget: if the 5-square where a literal gadget is attached to its variable gadget from the top is in
upper state (corresponding to false) then the active ranges of all 5-squares of the literal gadget are “pushed”
towards the clause gadget; otherwise, if the literal is true, there is no pressure towards the clause.
For a literal λ, let mλ be the number of regular 5-squares, and let m′λ be the number of connectors in
the gadget of λ. Then λ contributes at most 6mλ +m′λ units to H.
Clause gadgets. The final square of each literal gadget connects to a clause gadget. A clause gadget consists
of two intersecting 5-squares QC and Q′C , containing six 1-squares as depicted in Figure 5. If the six 1-
squares contribute one unit each, the two 5-squares can also contribute at most one unit each. This is by
construction also the maximum contribution of a clause gadget. Let Q ∈ {QC , Q′C}. Note that there are
three scale intervals in which Q might contribute one unit to H, and that Q intersects the final 5-square
of two of the three legs corresponding to literals in C. Note that the literal gadgets have enough slack to
make the final 5-squares intersect Q as shown in Figure 5. Assume that the literal legs contribute maximally
to H. Then, if the two literal legs intersecting Q evaluate to false, only the middle unit-height strip of Q can
contribute (one unit) to H. But since QC and Q′C intersect, their two middle strips together can contribute
at most one unit. Thus, if all three literals evaluate to false, the clause gadget (QC , Q′C and the six 1-squares
in their union) contributes 7 units in total. On the other hand, if at least one literal in C evaluates to true,
7
green red
x ¬x
x¬x
cone 1
(a) Variable gadget for x = true.
x ¬x
x¬x
cone 1
(b) Variable gadget for x = false.
Figure 6: 3d-models and 2d-projections of a variable gadget (thick edges) with partial literal gadgets (thin
edges). Cones of gadgets carrying the value true are green, cones of gadgets carrying the value false are red.
Variable gadgets. A variable gadget consists of a cyclic chain of an even number of adjacent cones. By the
above observation this chain contributes maximally to H if every other cone is active in the range (0, Smax)
and the remaining cones in the range (0, Smax/2). Numbering the cones clockwise starting with the leftmost
cone in the top row of the gadget, we denote the state where the odd cones extend to the full scale Smax as
true and the state where the even cones extend to Smax as false; see Figure 6.
Literal gadgets. Each variable gadget has indentations. Their number depends on how often the variable
occurs in the clauses of ϕ. At each indentation we can connect a leg of a three-legged comb that serves as a
literal gadget. Each leg consists of an even chain of adjacent cones leading towards the clause gadget. The
middle leg of a comb is a simple vertical chain, whereas the left and right leg start vertically and then bend
90 degrees in order to reach the clause gadget horizontally. For a positive literal the leg is adjacent to the
beginning (in clockwise order) of the indentation, for a negative literal the leg is adjacent to the end of the
indentation, see Figure 6. Thus, if a literal evaluates to false, the corresponding literal leg must start with a
cone of height Smax/2; otherwise it can start with a cone of height Smax. A literal leg contributes maximally
to H if every other cone reaches Smax. Hence it has two maximal states—either the odd or the even cones
reach Smax.
9
observation on maximal contributions, a total active range height H(S) of at least K can be achieved by an
optimal solution S if and only if ϕ is satisfiable.
As in the proof of Theorem 1, the set Eϕ consists of O(m2) extrusions placed on a grid of size O(m2),
and the reduction takes polynomial time.
3. Algorithmic toolbox
We give a toolbox of six different algorithms to tackle several variants of 1d- and 2d-ARO problems, using
dynamic programming, a left-to-right greedy algorithm, line stabbing, divide and conquer, a top-to-bottom
fill-down sweep, and a level-based small-to-large greedy algorithm.
3.1. Dynamic programming
Triangles. We start by considering simple 1d-ARO with proportional dilation: each extrusion E is a triangle
with apex on the x-axis and top edge on the horizontal line s = Smax. The truncated extrusions differ only
by having (possibly) lower top edges. Observe that in an optimal solution at least one truncated extrusion
has height Smax, and thus divides the problem into two independent subproblems. This is the essence of
our dynamic program. Details can be found in the appendix.
Theorem 4. Simple 1d-ARO with proportional dilation can be solved in O(n3) time using O(n2) space.
3.2. Left-to-right greedy algorithm
Unit-height rectangles. Van Kreveld et al. [16] presented the following greedy algorithm for maximum in-
dependent set (MIS) among axis-aligned rectangles of unit height. We are given a set E of unit-height
rectangles. Until E is empty, repeatedly select the rectangle E ∈ E with leftmost right edge, and remove
from E all rectangles intersecting E. This takes O(n log n) time, and is a (1/2)-approximation for MIS [16].
It is not hard to see that the same algorithm yields a (1/3)-approximation for 1d-ARO.
Theorem 5. The maximum total active range height for a set of n rectangular extrusions of unit height
can be approximated within a factor of 1/3 in O(n log n) time.
3.3. Line stabbing
We use line stabbing for unit squares and unit-width rectangles, that is, general 1d-ARO with constant
dilation and equal-size labels. Line stabbing is a special case of the shifting technique by Hochbaum and
Maass [9]. Agarwal et al. [1] have used line stabbing to design a PTAS for maximum independent set among
unit-width rectangles. The idea is to stab the extrusions with vertical lines such that two lines have distance
at least 1, each extrusion is stabbed by exactly one line, and each line stabs at least one extrusion. Such
a set of lines can be computed greedily in linear time if the extrusions are given in left-to-right order. We
assume that the resulting lines are numbered l1 to lk from left to right, where k ≤ n. Since all extrusions
are open and have unit width, those intersecting line li for some 1 ≤ i ≤ k − 2 are disjoint from those
intersecting line li+2. The problem for a single stabbing line can be solved optimally by a simple greedy
algorithm, see the appendix.
Lemma 1. The maximum total active range height of a set E of n rectangles stabbed by a vertical line can
be computed in O(n log n) time.
Unit-width rectangles. For unit-width rectangles we partition the vertical stabbing lines into sets Λ1 and Λ2,
containing all the stabbing lines with odd and even indices, respectively. By Lemma 1 the solution for each
individual stabbing line, and thus also the solution Ai for all rectangles intersecting lines in Λi, can be
computed optimally for i ∈ {1, 2}. From the candidate solutions A1 and A2 we choose the one maximizing H
as our approximate solution A. Re-using arguments of Agarwal et al. [1], it is easy to see that A is a (1/2)-
approximation. Now Lemma 1 yields the following.
Theorem 6. The maximum total active range height for a set of n rectangular extrusions of unit width can
be approximated within a factor of 1/2 in O(n logn) time.
11
sx
E1
E2
E3sE1
E4 E5
(a) E2 is correctly selected first
s
x
E1
E2
E3
E4 E5
(b) E3 is selected first
pi
min{SE, SE′}
sEE′
E E′
Figure 9: It matters in which order extrusions E2 and E3 are
considered when the algorithm reaches scale sE1 . (At that
point we have AE2 = AE3 and SE2 > SE3 .) The total active
range height in case (b) is less than in case (a).
Figure 10: For a pair of distinct extru-
sions E,E′ ∈ E , sEE′ ≤ min{SE , SE′} is
the largest scale such that E ∩ E′ ∩ pi = ∅,
where pi is a horizontal plane at s = sEE′ .
Algorithm 1: Top-to-bottom fill-down sweep
Input : a set E of extrusions, a selectable range (sE , SE) for each E ∈ E
Output: an active range (aE , AE) for each E ∈ E
foreach E ∈ E do (aE , AE)← (sE , SE)
Q ← priority queue for E sorted lexicographically by (AE , SE)
while Q 6= ∅ do
remove first element E from Q and fix its current active range
foreach E′ ∈ Q do
if E′ ∩ E 6= ∅ then
AE′ ← min(AE′ , sEE′)
if AE′ = aE′ then remove E′ from Q
The correctness of Algorithm 1 is clear: each extrusion is assigned at most one active range that is a
subset of its selectable range, and none of the truncated extrusions intersect.
We now describe a generic implementation, that is, one that makes no further assumption about the
shapes of the extrusions. Our algorithm makes at most n steps. In each step, we make two passes through
the extrusions that are not fixed yet. In the first pass, we select the extrusion E with the lexicographically
largest pair (AE , SE). In the second pass, we adjust the upper end points of the active ranges of the others.
This immediately gives the following result.
Lemma 3. A generic implementation of Algorithm 1 runs in O(n2) time and uses O(n) space.
Let A = {(aE , AE) | E ∈ E} be the solution computed by Algorithm 1. Recall that the trace trs?(E)
of an extrusion E at scale s? is the intersection of E with the horizontal line or plane s = s? in 1d- and
2d-ARO, respectively. We say that an extrusion E blocks another extrusion E′ at scale s under a given
solution if the traces of E and E′ at s intersect and s ∈ (aE , AE). Note that this implies that s /∈ (aE′ , AE′).
We say that two extrusions are independent at s if their traces at scale s are disjoint. The following lemma
will help prove all approximation factors in this section.
Lemma 4. If, for any set E of extrusions, for any E ∈ E, and for any scale s ≥ 0, E blocks no more than c
pairwise independent extrusions at s, then Algorithm 1 computes a (1/c)-approximation for the maximum
total active range height.
Proof. In Algorithm 1, each extrusion E starts with AE = SE , and AE is lowered only as far as is necessary
to avoid conflicts with fixed extrusions. Thus, if E ∈ E is inactive in A at scale s, then E must be blocked
at s.
13
Trapezoidal segments of congruent triangles. Here we consider the 1d-ARO problem with proportional dila-
tion, where the extrusions are trapezoidal segments of congruent underlying triangles that have their apexes
on the x-axis.
Theorem 10. A (1/2)-approximation for the maximum total active range height of a set of n trapezoidal
segments of congruent triangles can be computed in O((k + n) log n) time and O(n) space, where k is the
number of side-edge intersections between pairs of trapezoids.
Proof. Since the underlying triangles are congruent and horizontally aligned, the width of every trapezoid
is the same at each scale. This implies that any trapezoid blocked by another trapezoid E intersects a
side edge of E. Thus, at most two extrusions blocked by E at scale s can be independent at s, and the
approximation factor 1/2 follows from Lemma 4.
We can use the same implementation as for congruent trapezoids.
Congruent frusta. Axis-aligned congruent square frusta are the 2d-ARO analogues of congruent trapezoids.
Here, a blocked frustum must intersect a side face of its blocker. The number of independent frusta that
can intersect a single face depends on W , the ratio of the length of the top edges of each frustum to the
length of their bottom edges.
Theorem 11. A 1/(4W )-approximation for the maximum total active range height of a set of n axis-aligned
congruent square frusta can be computed in O(n2) time and O(n) space, where W is the ratio of the length
of the top edges of each frustum to the length of its bottom edges.
Proof. Using an argument similar to that used in the proof of Lemma 5, it can be shown that if a frustum E
blocks another frustum E′ at scale s under solution A, then trs(E′) must intersect the boundary of trs(E).
Therefore, since at any scale s the side length of a trace of E is no more than W times the side length of a
trace of E′, E can block at most 4W independent extrusions at s. For an example withW = 3, see Figure 12.
The approximation factor of 1/(4W ) follows from Lemma 4. Running time and space requirements follow
directly from Lemma 3.
Frustal segments of congruent square cones. In this part we are concerned with extrusions that are frustal
segments of underlying axis-aligned congruent square cones with their apexes at s = 0. This is the 2d-ARO
equivalent of trapezoidal segments of congruent triangles, which we have treated in Theorem 10. As in the
case of trapezoids, we want to efficiently compute the set of (active) fixed extrusions that intersect a given
non-fixed extrusion. Now, however, the line-intersection approach is not sufficient. Instead, we represent
each extrusion by the position of the apex of its underlying cone. Using this representation, we maintain
the set of active fixed extrusions in a range tree [6, Chapter 5.3].
Theorem 12. A (1/4)-approximation for the maximum total active range height of a set of n frustal
segments of axis-aligned congruent square cones can be computed in O((k + n) log2 n) time and O(n log n)
space, where k is the number of side-face intersections between pairs of frusta.
Proof. Since the trace of every extrusion at some scale s has the same constant size, we know that any
extrusion blocked by an extrusion E at s must intersect one of the four corner edges of E at s. (Two side
faces meet at a corner edge.) This means that at most four blocked extrusions can be independent and the
approximation factor of 1/4 follows from Lemma 4.
The implementation is the same as for congruent trapezoids, except that the range tree requires O(n log n)
space and that updates and queries in a range tree take O(log2 n) time. The query time is due to the fact
that every query returns O(1) results.
Simple ARO with axis-aligned congruent square cones is a special case of the above, where (sE , SE) =
(0, Smax) for each E ∈ E , so we immediately get the following corollary.
Corollary 1. A (1/4)-approximation for the maximum total active range height of a set of n axis-aligned
congruent square cones can be computed in O((k + n) log2 n) time and O(n logn) space, where k is the
number of pairs of intersecting cones.
15
pihEh
E′
h
E′′
h
(a) Trace E′h is associated to E
′′
h .
Ei
`
1
2 `
3
2 `
′
Ei−1
E′
i
E′
i−1
(b) Trace Ei−1 contains E′i−1.
Figure 11: Intersection behavior of the traces of E,E′, and E′′ at different levels.
Let T ′ be a trace associated to T . If T ′ is associated to T by case (i) above we know that the side length
of T ′ is at least ` by the order in which Algorithm 2 selects the squares.
So assume T ′ = E′i is associated to T = Ei by case (ii) and let h < i be the largest level in which E
′
h is
not associated to Eh. (If there is no such level h then case (i) applies to E′0 and E0 and the statement of the
lemma holds.) Thus at level h we have E′h associated to some other active trace E
′′
h . Since Eh+1 blocks E
′
h+1
in the beginning of phase h+1 we know that Eh is already active and hence does not intersect E′′h . On the
other hand, both Eh and E′′h must intersect E
′
h. This situation is depicted in Figure 11a.
Let `′ be the side length of T ′ and suppose `′ < `/3. Now consider level i − 1. There, the side lengths
of the traces E′i−1 and Ei−1 are doubled, which means that E
′
i−1 is fully contained in Ei−1, see Figure 11b.
This also holds for level h ≤ i − 1 and thus E′h cannot intersect the active trace E′′h , since E′′h is disjoint
from Eh—a contradiction. For the same reason T ′ must intersect the boundary of T .
We now fix an optimal solution S. Let A denote the solution of Algorithm 2. For i = 1, . . . , Nk + 1
we denote the active segments of the extrusions between planes pii−1 and pii in S by Si and in A by Ai,
respectively. We charge H(SNk) and H(SNk+1) to H(A1), and for 1 ≤ i < Nk we charge H(Si) to H(Ai+1).
Lemma 7. It holds that H(A1) ≥ (H(SNk) + H(SNk+1))/α2, and if no more than c traces of extrusions
in S are associated to any given trace in A, then for i = 1, 2, . . . , Nk−1 it holds that H(Ai+1) ≥ H(Si)/(cα).
Proof. We first compare H(SNk) +H(SNk+1) to H(A1). The scale of piNk−1 is at most α · Smax/(kn) and
obviously there are at most n active cone segments in S below piNk−1, so their total active range height is at
most α/k ·Smax. On the other hand, there is at least one active cone segment in A1 of height Smax/(k+1).
Using α = (k + 1)/k yields H(A1) ≥ (H(SNk) +H(SNk+1))/α2.
Now let E ∈ E and let 1 ≤ i < Nk. If trsi(E) is active in S, either trsi(E) is active also in A or trsi(E)
is associated to a trace T ′ = trsi(E
′) that is active in A.
In the first case, E contributes to H(Ai+1) at least 1/α times what it contributes to H(Si) since the
height difference between pii−1 and pii is α times the height difference between pii and pii+1.
In the second case, let S(T ′) be the set of extrusions in S whose traces are associated to T ′. By
assumption we have |S(T ′)| ≤ c. Since we must also take into account the ratio of the height differences, we
get that the contribution of E′ to H(Ai+1) is at least 1/(cα) times the contribution of S(trsi(E′)) to H(Si).
Summing up over all extrusions yields the statement.
Theorem 13. Algorithm 2 computes a (1/24)-approximation for the maximum total active range height of
a set of n axis-aligned arbitrary square cones in O(n log3 n) time and O(n logn) space.
Proof. In order to analyze the performance of Algorithm 2, we consider a level i with 1 ≤ i < Nk and
an extrusion E ∈ E that is active at si in A, that is, the trace trsi(E) is active. Let ` be the side length
of trsi(E). By Lemma 6, all traces associated to trsi(E) have side length at least `/3 and intersect the
17
4. Open problems
ARO is an exciting new problem inspired by interactive web-based mapping applications, and this is the
first paper with an extensive, rigorous algorithmic study. We have described a number of approximation
algorithms, see Table 1 for an overview. An obvious question is whether any approximation factor can be
improved, or whether any of the problems admits a polynomial-time approximation scheme. Furthermore,
the complexity of general 1d-ARO is still unknown for regular shapes such as unit squares, congruent
trapezoids, and segments of congruent triangles.
Mapping applications in practice often need to work with different label models, such as labels of different
lengths and fonts; non-axis-aligned labels; non-rectangular labels, such as a road label that follows a curvy
road; and sliding labels—that is, non-invariant point placements. Any of these raises a number of interesting
theoretical questions.
Acknowledgments. We thank the anonymous referees for their valuable comments. They helped us in
particular to simplify and speed up Algorithm 1.
References
[1] P. K. Agarwal, M. van Kreveld, and S. Suri. Label placement by maximum independent set in rectangles. Comput. Geom.
Theory Appl., 11:209–218, 1998.
[2] K. Been, E. Daiches, and C. Yap. Dynamic map labeling. IEEE Trans. Visualization & Comput. Graphics, 12(5):773–780,
2006.
[3] A. L. Buchsbaum, H. Karloff, C. Kenyon, N. Reingold, and M. Thorup. OPT versus LOAD in dynamic storage allocation.
SIAM J. Comput., 33(3):632–646, 2004.
[4] B. Chazelle and 36 co-authors. The computational geometry impact task force report. In B. Chazelle, J. E. Goodman,
and R. Pollack, editors, Advances in Discrete and Computational Geometry, volume 223, pages 407–463. American
Mathematical Society, Providence, RI, 1999.
[5] J. Christensen, J. Marks, and S. Shieber. An empirical study of algorithms for point-feature label placement. ACM Trans.
Graphics, 14(3):203–232, 1995.
[6] M. de Berg, O. Cheong, M. van Kreveld, and M. Overmars. Computational Geometry: Algorithms and Applications.
Springer-Verlag, Berlin, third edition, 2008.
[7] T. Erlebach, K. Jansen, and E. Seidel. Polynomial-time approximation schemes for geometric intersection graphs. SIAM
J. Comput., 34(6):1302–1323, 2005.
[8] M. Formann and F. Wagner. A packing problem with applications to lettering of maps. In Proc. 7th Annu. ACM Sympos.
Comput. Geom. (SoCG’91), pages 281–288, 1991.
[9] D. S. Hochbaum and W. Maass. Approximation schemes for covering and packing problems in image processing and VLSI.
J. ACM, 32:130–136, 1985.
[10] D. E. Knuth and A. Raghunathan. The problem of compatible representatives. SIAM J. Discr. Math., 5(3):422–427,
1992.
[11] D. Lichtenstein. Planar formulae and their uses. SIAM J. Comput., 11(2):329–343, 1982.
[12] K. Mehlhorn and S. Na¨her. Dynamic fractional cascading. Algorithmica, 5:215–241, 1990.
[13] I. Petzold, G. Gro¨ger, and L. Plu¨mer. Fast screen map labeling—data-structures and algorithms. In Proc. 23rd Internat.
Cartographic Conf. (ICC’03), pages 288–298, Durban, South Africa, 2003.
[14] I. Petzold, L. Plu¨mer, and M. Heber. Label placement for dynamically generated screen maps. In Proc. 19th Internat.
Cartographic Conf. (ICC’99), pages 893–903, Ottawa, Canada, 1999.
[15] S.-H. Poon and C.-S. Shin. Adaptive zooming in point set labeling. In M. Li´skiewicz and R. Reischuk, editors, Proc.
15th Internat. Sympos. Fundam. Comput. Theory (FCT’05), volume 3623 of Lecture Notes Comput. Sci., pages 233–244.
Springer-Verlag, 2005.
[16] M. van Kreveld, T. Strijk, and A. Wolff. Point labeling with sliding labels. Comput. Geom. Theory Appl., 13:21–47, 1999.
[17] A. Wolff and T. Strijk. The Map-Labeling Bibliography. http://i11www.ira.uka.de/map-labeling/bibliography, 1996.
19
that p0, . . . , pn+1 are sorted from left to right. For i < j, define the free space ∆(i, j) between pi and pj to be
the triangular or trapezoidal space enclosed by s = 0, the right side edge of Ei, the left side edge of Ej , and
possibly s = Smax. Let A[i, j] (i < j) be the optimal solution for pi+1, . . . , pj−1 in ∆(i, j). In A[i, j], at least
one of the truncated extrusions must touch a non-bottom edge of ∆(i, j), thus dividing the problem into
two independent subproblems. For each k = i+ 1, . . . , j − 1, we denote by hi,jk the scale at which Ek first
reaches a non-bottom edge of ∆(i, j). We initialize A[i, i+ 1] = 0 for i = 0, . . . , n and recursively compute
A[i, j] = max{A[i, k] + hi,jk +A[k, j] | i+ 1 ≤ k ≤ j − 1}.
Obviously, the optimal solution for our problem is A[0, n + 1]. Each of the O(n2) entries in the dynamic
programming table is computed in O(n) time, resulting in a total running time of O(n3).
Theorem 5. The maximum total active range height for a set of n rectangular extrusions of unit height
can be approximated within a factor of 1/3 in O(n log n) time.
Proof. For ARO the greedy algorithm for MIS of van Kreveld et al. [16] yields a (1/3)-approximation, for
the following reason. Let S be any optimal solution. If an extrusion E with a non-empty active range in S
is inactive in the solution A of the algorithm, there must be an extrusion E′ 6= E that is selected in A
such that the right edge of E′ intersects E; therefore E has been removed from E in the algorithm and is
inactive in A. But since all extrusions are unit-height rectangles and E′ has the leftmost right edge when
it is selected, E′ cannot be responsible for removing from S rectangles with a total active range height of
more than three height units.
Lemma 1. The maximum total active range height of a set E of n rectangles stabbed by a vertical line can
be computed in O(n log n) time.
Proof. Clearly the active range height of E equals the height of the union of E . To compute a set of truncated
extrusions with this active range height, we sweep the extrusions from top to bottom. We repeatedly pick
the topmost extrusion E, set AE to the current scale, set aE to sE , and discard all extrusions E′ with
sE′ > sE . Correctness and running time are obvious.
21
