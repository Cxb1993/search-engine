 2 
set architecture, the mapping tool and compiler for the low-power reconfigurable 
processor core. In addition, the subproject has assisted other subproject to design and 
implement the hardware architecture of low-power reconfigurable processor core. 
 
 
2 ????? 
?????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
?????????????????? 
 
2.1 ??? 
??SoC??????????????????????????????
???????????????????????????????????
????????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???? [1] ????????????????????????
?hardware/software partitioning?????????code generation??[3]????
???????????????????????????????????
????????[4]????????????????[5]?????????
???????????????????????????????????
???????????????????????????????????
?????????????????????????SoC ???????? 
 4 
?????????????? 
?????????????????????????????????
???????????????????????????????????
???????????????????????????????????
????????????????????????[6, 7]?????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
??94 ????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
?????????????????????? 
 
2.3 ??? 
?????????????????????????????????
???????????????????????????????????
???????????????????????????????????
??????????????????deep-submicron???????????
???????????????????????????????????
????????????????????????????????
?reliability???????safety?????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
????????????????????????????????????
???????????????????????????throughput????
???????????????????????????????????
 6 
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
??????????????????ILP????????????????
???????????????????????????????????
???????????????????? 
?????????????????????????????????
???????????SUIF??????????????Task Graph?Task 
Graph??????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
????????Task Graph???????????????????????
????????????????????????????????? 
? ? Task Graph G(V, E) ? ? ? |V| ? functionality nodes ? ? |E| ?
communication edges???functionality nodes ?Fi ?????1 ??i ?|? V|???
communication edge ??Cj(Fi1, Fi2)?? , ??1 ??j ?|? E|?Fi1 ?Fi2 ???
communication edge Cj ?source functionality node ??destination functionality 
node?Functionality node Fi ???????????????????????
???????????functionality node Fi ????component type Mj ????
???? Fi ??Mj ??????????ILP model????????? 
· MLib: the set of all components available to perform the functionality nodes of task 
graph. 
· MLi: the set of components available to perform the functionality node Fi. 
· MNj: the number of components available for type Mj. 
· MAreaj: the area of a component of type Mj. 
· FTimei,j: execution time of functionality node Fi performed by component of type Mj. 
· CTimej: communication time of communication edge Cj. 
· StageT: the throughput constraint (the delay of a pipeline stage in the design). 
 8 
Data Dependency Constraint: 
????? G(V, E)?? communication edge Ci ???? source functionality node
? end time ?????? Ci? start time????Ci ? end time ???????
destination functionality node ? end time ????????????Functionality 
node Fi? communication edge Ci? start time sit  ? end time eit  ????????
???? 
e
it = sit + å å
Î ££
×
ij j
  
MLM NMk
kj,i,ji, ,x  FTime    
1
  " Fi Î V  (4) 
e
it = sit + ,y CTime ii ×    " Ci Î E  (5) 
???????????????? 
s
it - snt ³ nn y CTime × ,  " Fi Î V 
and its incoming communication edge Cn  (6) 
snt - sit ³ åå
££Î
×
j
  
ij NMk
kj,i,ji,
MLM
 x  FTime   
1
,  " Cn Î E 
and its source functionality node Fi  (7) 
? MLi12 = MLi1 Ç MLi2???? communication edge Cn(Fi1, Fi2)??? yn ????
? constraints ??? 
yn ³ kj,i2,kj,i1,       xx - ,  " Mj Î MLi12 and 1 £ k £ MNj (8) 
yn ³ kj,i1,kj,i2,       xx - ,  " Mj Î MLi12 and 1 £ k £ MNj (9) 
yn ³ xi1,j1,k,   " Mj1 Î MLi1, Mj1 Ï MLi12, 1 £ k £ MNj1 (10) 
yn ³ xi2,j2,k,   " Mj2 Î MLi2, Mj2 Ï MLi12, 1 £ k £ MNj2 (11) 
Pipelined Schedule: 
????? functionality node Fi ?? communication edge Ci ?????? start time 
s
it  ? end time eit  ?????? pipeline stage??????? Fi ???????
Ci ??????????? StageT??? 
å
££
=
Sp
pi,   z   
1
1 ,  " Fi Î V and Ci Î E  (12) 
s
it ³  StageT   pz  
Sp
pi, ´÷÷
ø
ö
çç
è
æ
-×å
££
1
1
, " FiÎV and CiÎE (13) 
 10
communication edges ?????????????????? throughput 
constraints??? StageT???????????? 3 ???????????
??? 45000????????????????????????????Total 
Area ?????????? component area?Dsw ????????????
??PS ??largest pipeline stage?CPU time ?????ILP model ??????
???????second???throughput constraint ??????2000?????
??????non-pipelined?PS = 1???throughput constraint ??????£ 700??
?????????pipelined ????????????????????MP3 
decoder ????????MP3 decoder ?Task Graph ??9?functionality nodes 
??11 communication edges???????????????????????
ILP model ??????throughput constraints ???????total component area 
???pipelined ??? 
 
???JPEG????? 
Fi aaFTimeSWaa aaMAreaHWaa aFTimeHWaa  aCia aaCTimeaa 
F1 (Preshift) 65 3600 20  C1 6 
F2 (DCT) 380 27000 280  C2 6 
F3 (Bound) 100 3750 80  C3 13 
F4 (Quantize) 250 14300 30  C4 11 
F5 (Zigzag) 85 6700 60  C5 10 
F6 (Encode) 610 37000 65  C6 12 
     C7 12 
 
 
???JPEG????? 
aaStageaTa aaTotal Areaaa aaDSWaa aaPSaa aaCPU Timeaa 
300 92350 0 3 1 
500 92350 0 2 1 
800 88700 1 2 14 
1000 79350 1 2 10 
2000 45000 1 1 1 
 
 
 12
???????????????????????????????????
???????????? task ???????????????? 
 
 
 
?????????? 
 
 
 14
?????????????????????? 
· Initialization????????????????????????????? 
· Crossover???? 2 ??????????????????? 
· Mutation??????????? 1 ?????????? bit????????
????? 
· Evaluation??????? f(i)?????????????? 
sgieicif
n
1i
i ×÷
ø
ö
ç
è
æ ×= å
=
])][[][()( , 
where 
ïî
ï
í
ì
-
<×
= å=
otherwise     1,
])][[][(  if      1,  
n
1i
G
LPLi Tgitics  
 
· Selection????????????? f(i)???????????? 
· Termination?????????????????????? 
 
??????????? FIR?Gaussian elimination ? IDCT ???????
????????? Speedup ??????????????????????
1.5V ???????????????????????RC & no DVS ????
????????????????????RC & DVS ???????????
???????????????????????????????????
???????????????????????????????????? 
 
 
??? ?????????? 
Example Speedup RC & no DVS RC & DVS 
FIR 1.11 1.04 0.86 
Gaussian elimination 1.11 1.02 0.61 
IDCT 1.11 1.01 0.84 
 
 
 
 
 16
a7 a6 a5 a4 a3 a2 a1 a0
b7 b6 b5 b4 b3 b2 b1 b0´
p15   p14 p13      p12      p11      p10       p9 p8 p7    p6 p5        p4 p3 p2      p1 p0
1
a7b1 a6b1 a5b1 a4b1 a3b1 a2b1 a1b1 a0b1
a7b2 a6b2 a5b2 a4b2 a3b2 a2b2 a1b2 a0b2
a7b3 a6b3 a5b3 a4b3 a3b3 a2b3 a1b3 a0b3
a7b4 a6b4 a5b4 a4b4 a3b4 a2b4 a1b4 a0b4
a7b5 a6b5 a5b5 a4b5 a3b5 a2b5 a1b5 a0b5
a7b6 a6b6 a5b6 a4b6 a3b6 a2b6 a1b6 a0b6
a7b7 a6b7 a5b7 a4b7 a3b7 a2b7 a1b7 a0b7
1
a7b0 a6b0 a5b0 a4b0 a3b0 a2b0 a1b0 a0b0
MSP MMP LSP
 
??? 8´8 modefied Baugh-Wooley ?? 
 
 
 
b6a6 a5 a4 b7 b5 b4a7
CS
AOI
OAI
AS2 AS3 AS4 BS4BS3BS2
AOI
CS6CS5
D2 D3Ñ3 Ñ 4
OAI
1 0
 
??? ?????????? 
 
 
?????? Synopsys Design Compiler ?? UMC 0.18um CMOS ????
????????? Synopsys Prime Power ?? MP3 decoder ? Inverse Modified 
Discrete Transform (IMDCT)????????????????????????
????????? Conventional?Type I?Type II?Type III_I ?? Type III_II ?
 18
????????????????? DFG ?????????????
MLIB ???????????(?)????????????????????
??????????????F2 ?????? 3 ?????? 2 ????? 3
???????? 7 ??????????????????????????
??????????? branch and bound ??????? 
 
 
 
moves
End
Power < current optimization
Initial solution 
Current solution
All neighbors
Tabu list
Local optimization
Stop rule
Bit = 0
Bit > 0
no
yes
Intensification
Pipeline schedule
Diversification
Aspiration criterion
DFG MLIB 
 
  ??? ?????????? 
 20
3. ??(move) 
?????????????????(?????????????)???
????? 
4. ????(tabu list) 
??????????????????????????????????
????? 
5. ????(memory structure) 
??????????????????????????????????
?????????????????????????(Intensification)??
??(Diversification)?????????????????????????
??????????????????????????? 
6. ????(aspiration criterion) 
???????????????????????? bit?????????
??????????? bit ?????????????????????
????? 
7. ????(Stopping criterion) 
????????????????? 
?? DFG ? MLIB ???????? CNPT ??????????????
???????????????????????????????????
????????????????????????????????? current 
solution ??????????????????? current solution ??????
???????????????????????????????????
??? 
?????????????????????(?)???????????
???????????????????????????????????
????????????????????????????????list 
schedule??????????CNPT ???????????????????
????????????? CNPT ???????????????????
???????????????????????????????????
 22
??????????????????????????????? 
???????????????????????? CNPT[8] ????
DFG ??????Random Graph Generator??? 50 ????????????
???task?????? 10 ?? 50 ????????????????????
???????????????????????????????????
???????????????????????????????????
?????????????????????????????????DVS?
???????????????????? CPU Time ???????????
???? 300 ???? 100 ???????????????? ILP ?????
? ILP ????????????????????????? 3000 ?????
??????????????????????? 300 ???? 100 ????
????????????????????????????? 
 
 
??? ??????????????? 
 10 nodes 20 nodes 30 nodes 40 nodes 50 nodes 
Case1 0% 0% 0% 0% +1.26% 
Case2 0% -1.09% -12.47% +2.55% -3.65% 
Case3 0% 0% 0% 0% 0% 
Case4 0% -1.36% -1.21% -1.06% 0% 
Case5 0% +0.30% -6.08% 0% 0% 
Case6 0% 0% -0.49% -1.98% -1.06% 
Case7 0% 0% 0% 0% 0% 
Case8 0% 0% -3.17% 0% +1.26% 
Case9 0% 0% -0.45% -1.19% 0% 
Case10 0% 0% 0% +2.30% -0.51% 
 
 24
??? ?????? 
Tabu (6 Hours)Tabu (6 Hours)Tabu (6 Hours)Tabu (6 Hours)ILPCompared with  
2.924%1.228%3.642%2.850%3.260%Average
0.00%0.00%0.00%0.00%0.00%Min
12.85%4.88%11.91%20.76%25.80%Max
699.9505.4192.959.86.4CPU time Ave.
0.36%4.88%0.00%0.00%0.00%Case10
1.00%0.50%0.07%0.00%1.86%Case9
5.39%0.00%0.55%20.76%25.80%Case8
1.33%0.50%4.99%0.00%0.00%Case7
4.49%0.87%1.42%0.00%0.40%Case6
1.22%0.00%9.97%1.85%0.00%Case5
0.00%3.80%1.42%0.00%0.00%Case4
1.44%0.00%0.00%0.00%0.00%Case3
1.16%0.00%11.91%1.97%0.34%Case2
12.85%1.73%6.41%3.92%1.40%Case1
50 nodes40 nodes30 nodes20 nodes10 nodes
 
 
 
4 ?????? 
?????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????????????? ARM ????????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
??[18, 19]???[18]????????????????[19]????????
???????????????????????????????????
????????? 
?????????????????????????????????
???????????????????????????????????
???????????????????????????????????
 26
microprocessor system,” IEEE Int. Solid-State Circuits Conf., vol. 466, pp. 294-295, 
Feb. 2000. 
 
[7] W. Namgoong, M. Yu, and T. Meng, “A high-efficiency variable-voltage CMOS 
dynamic dc-dc switching regulator,” IEEE Int. Solid-State Circuits Conf., vol. 489, 
pp. 380–381, Feb. 1997. 
 
[8] Tadahiro KURODA, “Low Power CMOS Design Challenges” IEICE TRANS. 
ELECTRON., Vol. E84-C, No. 8, August 2001. 
 
[9] V. Von Kaenel, P. Macken, and M. G. R. Degrauwe, “A voltage reduction technique 
for battery-operated systems,” IEEE J. Solid-State Circuits, vol. 25, pp. 1136–1140, 
Oct. 1990.  
 
[10] Y. R. Lin and Allen C.H. Wu, “Scheduling Techniques for Variable Voltage Low 
Power Designs,” ACM Transactions on Design Automation of Electronic Systems, 
Vol. 2, No. 2, pp. 81-79, April 1997. 
 
[11] B. Gorjiara, N. Bagherzadeh, and P. Chou, “A Efficient Voltage Scaling Algorithm 
for Complex SoCs with Few Number of Voltage Modes,” ACM Proceedings of the 
2004 international Symposium on Low Power Electronic and Design (ISLPED’04). 
 
[12] W.C. KWON and T.W. KIM, “Optimal Voltage Allocation Techniques for 
Dynamically Variable Voltage Processors,” ACM Transactions on Embedded 
Computing Systems, Vol. 4, No 1, pp. 211-230, February, 2005. 
 
[13] J. Luo and N. Jha, “Static and Dynamic Variable Voltage Scheduling Algorithms 
for Real-Time Heterogeneous Distributed Embedded Systems,” IEEE Proceeding 
of the 15th International Conference on VLSI Design (VLSID’02), 2002.  
 
[14] S. Mohanty and N. Ranganathan, “Energy-Efficient Datapath Scheduling Using 
Multiple Voltages and Dynamic Clocking,” ACM Transactions on Design 
Automation of Electronic Systems, Vol. 10, No. 2, pp. 330-353, 2005. 
 
[15] C.S. KIM and S.H HA: “Dynamic Voltage Scheduling with Buffers in Low-Power 
Multimedia Applications,” ACM Transactions on Embedded Computing Systems, 
Vol. 3, No. 4, pp. 686-705, November, 2004. 
 
?????????????????? 
 
?????????????????????????????????????
????????????????????????????3/3? 
?????NSC 95?2221?E?110?017 
?????95 ? 8 ? 1 ? ? 96 ? 10 ? 31 ? 
 
??????????????2007 IEEE Workshop on Signal Processing 
Systems (SiPS 2007)??????????? 2007 ? 10 ? 17 ??????????
?????????? IEEE Signal Processing Society?IEEE Circuits and Systems 
Society ???Shanghai Jiao Tong University ???? 2007 ? 10 ? 17 ?? 19 ???
??????????????????????????? 
SiPS 2007 ???? Keynote Speech???? Professor Magdy A. Bayoumi 
(University of Louisiana at Lafayette)?Professor Liang-Gee Chen (National Taiwan 
University)??? Professor Lajos Hanzo (University of Southampton) ???? 
?Wireless Sensors Networks & DSP: Marriage Made in Heaven???Toward 3D-Video: 
Challenge and Solution?????Wireless Multimedia Communications: A Tele-Presence 
Paradigm for Anyone, Anywhere, Anytime - or the Dawn of the "World Wide Wait" ????
??SiPS 2007 ???????????? Wireless Communications?MIMO Systems?
Channel Coding and Multimedia Signal Processing?Network and Communication?DSP 
Architectures?Channel and Source Coding?Communication Systems: Architectures and 
Networks ? Multimedia Signal Processing & Analysis ? Multimedia Coding and 
Area-Efficient Signed Fixed-Width Multipliers with Low-Error Compensation 
Circuit 
 
 
Jiun-Ping Wang and Shiann-Rong Kuang 
Department of Computer Science Engineering 
National Sun Yat-Sen University 
Kaohsiung, Taiwan 
Email: d933040009@student.nsysu.edu.tw and srkuang@cse.nsysu.edu.tw 
 
 
ABSTRACT 
In this paper, a framework of designing a low-error signed 
fixed-width multiplier that receives two n-bits operands and 
generates an n-bits product is proposed. The proposed error 
compensation circuit not only leads signed fixed-width 
multipliers to very low maximum error, mean error and 
mean-square error but also can be easily constructed with a 
simple logic gate. Moreover, the proposed signed fixed-
width multiplier is also applied to the inverse discrete 
cosine transform computation in JPEG image compression. 
Experimental results demonstrate that the proposed circuit 
not only improves the accurate performance but also 
significantly reduces the hardware complexity and power 
consumption when compared with the previous published 
compensation circuit. 
 
Index Terms— Baugh-Wooley algorithm, fixed-width 
multipliers, truncation error 
 
I. INTRODUCTION 
 
With the explosive growth of multimedia and digital 
signal processing (DSP) applications, the demand for 
designing high performance systems is one of the important 
objectives during VLSI implementation. Moreover, 
multipliers are always essential building components and 
the bottleneck in terms of performance and power 
consumption. Therefore, it is crucial to develop a multiplier 
with high speed and low power consumption.  
Currently parallel multipliers [1-5] have been widely 
adopted in high performance applications. In addition, 
multiplication operations with fixed-width property that 
receives two n-bits operands and produces an n-bit output 
product are widely used in many DSP and multimedia 
applications to avoid growth in word size. Significant 
hardware requirements and power savings of a fixed-width 
multiplier can be achieved by directly eliminating the adder 
cells for computing the n least-significant bits of 2n-bit 
output product but huge truncation errors are introduced. 
To improve the accuracy, various ripple-based and tree-
based error compensation circuits [614], which add 
efficient estimated carries to the carry inputs of the retained 
adder cells, have been developed to significantly abate the 
truncation error. 
The error compensation approaches adopted in fixed-
width multipliers mainly contain constant and adaptive 
schemes. In [68], pre-computed constant error 
compensation values are added along with the carry inputs 
of the retained adder cells. Although these approaches have 
the advantage of simple compensation value generation, the 
truncation error is still large. On the contrary, data-
dependent compensation approaches [914] are developed 
to achieve better accuracy than previous constant scheme 
by adaptively adjusting the compensation values according 
to the input data values. In [11], error compensation values 
are generated adaptively by utilizing some indices to 
incorporate the influence of input data values. The work in 
[12] chooses the proper generalized index and develops a 
methodology for designing ripple-based error compensation 
circuits to improve error performance of signed fixed-width 
array multipliers. In [13], a low-power fixed-width array 
multiplier using the left-to-right algorithm is developed. 
The adder cells for generating the least significant part of 
output product are removed to degrade the power 
consumption, and some error compensation cells are added 
to degrade the product error. Although larger truncation 
error can be degraded significantly by introducing indices, 
these approaches [1113] still have some limitations 
because the indices only consider some specific conditions. 
Moreover, these ripple-based error compensation circuits 
not only require considerable amount of logic gates when n 
increases but also are unsuitable for fast tree-based 
multipliers [25] since it may lengthen the critical path of 
tree-based multipliers. On the other hand, dual-tree error 
compensation circuits with low hardware complexity have 
been investigated in [14] to minimize either maximum 
absolute error or mean-square error of unsigned tree-based 
fixed-width multipliers. Nevertheless, these unsigned fixed-
1571-4244-1222-6/07/$25.00 ©2007 IEEE SiPS 2007
 
III. LOW-ERROR FIXED WIDTH MULTIPLIERS 
 
In this section, error compensation functions for fixed-
width multipliers are derived exhaustively and the 
corresponding compensation circuit with lower hardware 
cost is constructed to reduce the truncation error. 
 
 
A.    Error-Compensation Functions 
 
In almost all multimedia and DSP applications, the 
final output product is commonly generated from 
accumulating a series of products rather than from single 
multiplication operation directly. For these applications, the 
truncated multiplier with lower mean error or mean-square 
error may result in more accurate output data since positive 
and negative truncation errors have higher probability to 
compensate for each other. Therefore, we define fm and fms 
as the optimal error compensation functions which 
minimize the error metric Hm and Hms respectively. 
Furthermore, each value of compensation vector CV, 
denoted as CVe, can be obtained with different values of A 
and B. Hence we define )(CVe) as the set of (A;B) values 
that produce value CVe and N(CVe) as the number of 
elements in )(CVe). Considering an example of n = 6 and 
CVe = ( 50ba , a1b4, a2b3, a3b2, a4b1, 05ba ) = (1, 1, 1, 1, 1, 
0), three different (A;B) values including (1111102; 
1111112), (1111112; 0111112) and (1111102; 01111112) 
belong to )(CVe) and N(CVe) equals 3. Subsequently, for a 
given value CVe, all possible (A;B) values belonging to 
)(CVe) can be utilized to calculate the average value of 
Sum(A; B) as follows 
 
¦

 
)ĭ(CV);(e
e
e
);(    )(
)N(CV
1
CV
BA
avg BASumS                 (6) 
 
To obtain the better fm and fms functions, we calculate the 
entire mean error and mean-square error as follow
 
  ¦ u 
eCV
2
e
e
2
CVN
CV
)(
nmm
HH                     (7) 
 
 ¦ u 
eCV
2
e
e
2
CVN
CV
)(
nmsms
HH                   (8) 
 
Note that the value Hm(CVe) and Hms(CVe) in (7) and (8) can 
be calculated from all possible (A;B) values belonging to 
)(CVe). Therefore, Hm(CVe) and Hms(CVe) can be expressed 
as 
 
 ¦

 
)ĭ(CV);(
e
e
e
e
)();( 
)(
)( CV
CVN
1
CV
BA
mm fBASumH        (9) 
 
 ¦

 
)ĭ(CV);(
2
e
e
e
e
)();( 
)(
)( CV
CVN
1
CV
BA
msms fBASumH  (10) 
 
Based on above equations, we can observe that choosing 
the best choice of fm(CVe) and fms(CVe) for any 
compensation vector CVe will result in the minimum value 
Hm and Hms. In order to easily derive the simple fm and fms 
functions, we adopt the simple algebra in (9) and (10) and 
the Hm(CVe) and Hms(CVe) can be rewritten as 
 
)()( )( eee CVCVCV mavgm fS  H                  (11) 
 

2ee )CV();(
e
e
e
)]()([
)]();([)(
CVCV
CV
)CV(N
1
CV
e
msavg
BA
avgms
fS
SBASum

 ¦
)
H
 
O ¦
)
2
)CV();(
e
e e
)]();([
)(
CV
CVN
1
BA
avgSBASum           (12) 
 
where 
 
¦
)
 
)CV();(
ee
2
e
e e
)()()(
)(
CVCV2CV
CVN
1
BA
msavgavg fSSO  
)()( )()();(
)();()(
ee
2
ee
e
2
e
CVCV2
CV2CV2
CV2CV
msavg
avgms
avgms
fS
SfBASum
SBASumf



                (13) 
 
Ȝ  in (13) can be simplified as follow 
 
2
ee
2
eee
2
e
]CVCV[
CVCVCV2CV
)()(
)()()()(
msavg
msmsavgavg
fS
ffSSȜ
 
 
        (14) 
 
Substituting (14) into (12), we can obtain 
 
2
)CV(ĭ);(
e
e
2
eee
e
)]();([
)(
])()([)(
CV
CVN
1
CVCVCV
¦


 
BA
avg
msavgms
SBASum
fSH
        (15) 
 
 
159
for satisfying (16) is obtained by performing exhaustive 
simulation. The results in Table II illustrate that our 
proposed error compensation circuit is more accurate than 
Van’s circuit [12] for n from 6 to 16 since total probability 
satisfying equation (16) of the proposed error compensation 
circuit is much larger than that of the Van’s circuit when 
applying all possible input patterns. 
 
Table II. Probability analysis for different signed fixed-width 
multipliers 
 
Probability n Van [12] Ours 
6 0.8261 0.8864 
8 0.7639 0.8040 
12 0.7209 0.7529 
14 0.7227 0.7645 
16 0.7235 0.7611 
 
To further compare the accuracy of signed fixed-width 
multipliers with different error compensation circuits, the 
exhaustive simulation results in terms of Hmax, Hm and Hms for 
different bit-width n are calculated in Table III. Obviously, 
our proposed error compensation circuit is well suited to 
designing signed fixed-width multiplier since the proposed 
circuit outperforms the Van’s circuit in terms of Hmax, Hm and 
Hms. 
 
Table III. Error performance of different signed fixed-width 
multipliers 
 
n Multipliers Hmax Hm Hms
Van 1.390 -0.243 0.219 6 Ours 1.218 -0.183 0.189 
Van 1.722 -0.248 0.263 8 Ours 1.554 -0.186 0.232 
Van 2.388 -0.249 0.347 12 Ours 2.222 -0.187 0.315 
Van 2.722 -0.249 0.388 14 Ours 2.555 -0.187 0.357 
Van 3.055 -0.249 0.430 16 Ours 2.888 -0.187 0.399 
 
IV. EXPERIMENTAL RESULTS 
 
To estimate the accuracy of different error compensation 
circuits, we have modeled array and Wallace tree signed 
fixed-width multipliers for n from 6 to 16 in Verilog HDL 
and synthesized these fixed-width multipliers under the 
same area and time constraint through utilizing Synopsys 
Design Compiler with the TSMC 0.18 Pm CMOS standard 
cell technology library. As regards the power consumption 
estimation, Synopsys Prime Power tool was exploited to 
estimate the power consumption of the gate-level structures.  
The implementation results including gate counts (Area), 
critical path delay (Delay) and power consumption (Power) 
for array-based and tree-based signed fixed-width 
multipliers are shown in Table IV and Table V, respectively. 
In Table IV and Table V, DTM denotes the direct-truncated 
signed fixed-width multiplier without any error 
compensation circuit. As can be seen, the signed fixed-
width multipliers with our proposed error compensation 
circuit not only reduce the hardware complexity but also 
consume slightly low power consumption with respect to 
Van’s circuit when n increases gradually. Furthermore, it is 
clearly seen that the tree-based multipliers with our 
proposed error compensation circuit have approximately 
the same latency as the direct-truncated signed fixed-width 
multipliers. Consequently, the proposed circuit is extremely 
applicable to high-speed systems. 
 
Table IV. Implementation results of different fixed-width array 
multipliers 
 
n Multipliers Area  (gate) 
Delay  
(ns) 
Power  
(PW) 
DTM 131 2.67 58.15 
Van 171 3.36 109.89 6 
Ours 166 3.36 109.27 
DTM 257 4.06 163.37 
Van 314 4.74 261.59 8 
Ours 306 4.74 260.59 
DTM 638 6.82 629.10 
Van 726 7.51 849.22 12 
Ours 713 7.51 847.71 
DTM 892 8.20 1029.11 
Van 996 8.89 1337.42 14 
Ours 981 8.89 1335.41 
DTM 1189 9.58 1169.46 
Van 1309 10.27 1444.76 16 
Ours 1291 10.27 1443.86 
 
 
Table V. Implementation results of different fixed-width Wallace 
tree multipliers 
 
n Multipliers Area  (gate) 
Delay  
(ns) 
Power  
(PW) 
DTM 144 2.32 50.18 
Van 207 3.05 83.67 6 
Ours 202 2.77 83.62 
DTM 265 3.22 115.81 
Van 364 3.87 154.73 8 
Ours 356 3.64 153.75 
DTM 648 4.65 292.45 
Van 804 6.00 361.93 12 
Ours 791 4.95 359.69 
DTM 927 5.19 426.47 
Van 1122 6.56 504.61 14 
Ours 1106 5.46 503.23 
DTM 1231 5.89 573.67 
Van 1459 7.43 673.16 16 
Ours 1440 6.15 671.92 
161
