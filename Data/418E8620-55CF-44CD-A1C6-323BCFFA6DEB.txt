- 2 - 
2.1 The A5/1 Stream Cipher 
The A5/1 [3] is a clock-controlled and 
LFSR-based stream cipher which used for encrypting 
over the air transmissions in the GSM standard. The 
diagram of A5/1 stream cipher is illustrated in Figure 
1. It is composed by three LFSRs with different length 
and primitive feedback polynomials. Each LFSR is 
shifted, using clock cycles that are determined by a 
majority function. The initial state of the cipher 
depends on a 64-bit secret key and a 22-bit public 
frame number. After the initialization phase, the last 
bits of each LFSR are XORed to produce one output 
bit or keystream.  
 
Figure 1: The diagram of A5/1 stream cipher 
However, the major issue in A5/1 security is the 
short period problem. This cipher operation is based 
on three LFSRs, R1, R2, and R3 of lengths 19, 22, and 
23 bits, respectively. The experiment shows that the 
period of A5/1 is equal to (4/3)(223-1) [6]. Another 
basic issue is the collision problem. It means that A5/1 
may result in the same key stream when the LFSRs 
different seeds are used. 
2.2 The CCDM Stream Cipher 
CCDM [2] is the abbreviation of 
Clock-Controlled with Dual Mode. It is a new type of 
clock-controlled stream cipher with Dual Mode, 
which is based on irregular clocking and operating on 
two difference modes. The CCDM stream cipher is a 
LFSR-based binary stream cipher and has five LFSRs 
of lengths 61, 127, 107, 89 and 31 bits and denoted as 
R1, R2, R3, R4 and R5, respectively. But R5 is not 
depicted in the CCDM. For the CCDM algorithm, it 
takes a 128-bit secret key and a 287-bit initialization 
vector. The cipher works over two different modes as 
CCDM-Mode I and CCDM-Mode II that are 
illustrated in Figure 2 and Figure 3 respectively. 
 
Figure 2: The block diagram of CCDM-Mode I 
The CCDM-Mode I can be categorized into three 
classes: clock-controlling, S-box selection and key 
stream generation. Each of R2, R3 and R4 is clocked at 
least once and at most four times in each clock cycle 
by clock-control functions. After the clocking of the 
R2, R3 and R4, the R1 is clocked once. CCDM-Mode I 
uses eight 4×16 S-boxes of DES [10] for the 
keystream generation. In each cycle, R4 decide which 
S-boxed are used by R2 and R3. Then by applying 
XOR to the three 4-bit sequences that are produced by 
the S-boxes and combination of last two bits of R2 and 
R3, four bits of keystream are generated. 
 
Figure 3: The block diagram of CCDM-Mode II 
In the CCDM-Mode II, it operates with the same 
LFSRs, but a mutual clock-control mechanism is 
applied. The block diagram is depicted in Figure 3. 
Each of R2, R3 and R4 would be clocked at least twice 
and at most five times by three clock-control functions 
fc2, fc3 and fc4. There is a parameter Ci(t), that 
represents the number of clocking for i-th register at 
time t. The clock-control mechanism also depends on 
T2k, T3k and T4k, which are k-th clocking tap bit of R2, 
R3 and R4, respectively. The value of k is determined 
according the some bits of R1. If the two or three 
clocking tap values are the same as majority then the 
registers are clocked Ci(t) times respectively. 
Otherwise, the registers clocked once. So each of R2, 
R3 and R4 is clocked at least once and at most five 
times before each key stream bit is produced. Finally 
four bits of keystream are generated by taking four 
bits from each of R2, R3 and R4. 
However, the structure of CCDM-Mode I costs 
- 4 - 
of Edon80 [4] for a part of the mode controller. Since 
the four quasigroups are suitable for implementation 
and that no hidden weaknesses can be imposed [4]. 
The quasigroup is shown in Table 1. We let X be K1K0 
and let Y be K3K2. The value X defines the row r of the 
quasigroup, and the value Y defines the column c. For 
the data on the (r, c) in Table 1, each r and c is two bit 
length respectively. The result of (r, c) is two bit 
length, too. Then we take the result of (r, c) to control 
which output sequence generator will operate.  
Table 1: The quasigroup table 
 
In the hardware implementation, to reduce the 
gate numbers to store the quasigroup table, we use the 
Boolean functions and map the quasigroup table to 
logic [5]. Here, ⊕ denotes logic XOR and · denotes 
logic AND. The output signals m1 and m2 are 
computed by the Boolean functions as follows: 
m1 = K0 · K2 ⊕ K1 ⊕ K3    
m2 = K0 ⊕ K2     
Finally, we get the logic circuit to implement the 
mode controller. The circuit of mode controller is 
shown in Figure 6. 
 
Figure 6: The circuit of mode controller 
3.4 Clock Controller 
According to section 3.1, we know the main 
work of the LFSRa, LFSRb, LFSRc and output 
generator is to produce keystream. The respective 
rightmost bits of LFSRa, LFSRb and LFSRc are 
inputted to output generator to produce keystream, but 
the respective clock pulses of these three LFSRs are 
dependent on clock controller. There are two clock 
operation modes in the clock controller which are 
mode 0 and mode 1. That which outputs of the two 
modes will be outputted is according to the output 
signal m0 of mode controller. If m0 = 0, then outputs of 
mode 0 are outputted. On the other hand, if m0 = 1, 
then outputs of mode 1 are outputted. 
The clock controller consists of three LFSRs and 
some nonlinear Boolean functions. Three LFSRs are 
LFSRα, LFSRβ and LFSRγ and the respective rightmost 
bits of these LFSRs are inputted into nonlinear 
Boolean functions, and then the outputs of the 
nonlinear Boolean functions are used to control which 
LFSRa, LFSRb or LFSRc will be shifted. It means the 
clock controller controls respective clock pulses of the 
LFSRa, LFSRb and LFSRc. We will describe how the 
clock controller controls respective clock pulses of the 
LFSRa, LFSRb and LFSRc. 
First, the respective rightmost bits of the LFSRα, 
LFSRβ and LFSRγ are denoted by α0t, β0t and γ0t 
respectively at time t. They are inputted to fmaj 
function and fand function which are given by: 
fmaj = (α0t · β0t) + (α0t · γ0t) + (β0t · γ0t)  
fand = α0t · β0t · γ0t       
where, + denotes logic OR and · denotes logic AND. 
For the mode of m0 = 0, then fmaj function is selected. 
If α0t = fmaj then LFSRa is shifted. And while β0t = fmaj 
and γ0t = fmaj then LFSRb and LFSRc are shifted 
respectively. Similarly, for another mode of m0 = 1, 
the fand function will be selected. If α0t = fand then 
LFSRa is shifted. And while β0t = fand and γ0t = fand then 
LFSRb and LFSRc are shifted respectively. According 
to above, we define clkai, clkbi and clkci as clocking 
condition of LFSRa, LFSRb and LFSRc respectively, 
where i ∈ {0, 1}. For the mode of m0 = 0, then clka0, 
clkb0 and clkc0 are selected. If clka0 = 1 then LFSRa is 
shifted. And while clkb0 = 1 and clkc0 = 1 then LFSRb 
and LFSRc are shifted respectively. On the other hand, 
for the mode of m0 = 1, then clka1, clkb1 and clkc1 are 
selected. If clka1 = 1 then LFSRa is shifted. While clkb1 
= 1 and clkc1 = 1 then LFSRb and LFSRc are shifted 
respectively. 
Table 2: Clocking condition under m0 = 0  
 
- 6 - 
z1t = ft ⊕ c0t ⊕ et-1     
et = c0t ⊕ (ft ⊕ c0t) · et-1    
DSG2: 
ft = a0t ⊕ b0t ⊕ dt-1     
dt = b0t ⊕ (a0t ⊕ b0t) · dt-1   
The initial state of the bits, ft-1 and et-1, are defined to 
be zero and the output function of the OSG1 can be 
sorted as follows: 
z1t = a0t ⊕ b0t ⊕ c0t ⊕ dt-1 ⊕ et-1  
dt = b0t ⊕ (a0t ⊕ b0t) · dt-1    
et = c0t ⊕ (a0t ⊕ b0t ⊕ c0t ⊕ dt-1) · et-1  
Output Sequence Generator 2 (OSG2): The OSG2 is 
shown in Figure 9. In this generator, we build a hybrid 
carry bit gt and merge it with DSG to generate the 
keystream z2t, it can be defined as follows: 
z2t = a0t ⊕ b0t ⊕ c0t ⊕ gt-1   
gt = gt-1 ⊕ (a0t ⊕ gt-1 ⊕ c0t) · b0t  
The initial state of the bits, gt-1, is defined to be zero. 
 
Figure 9: The output sequence generator 2 
Output Sequence Generator 3 (OSG3): The OSG3 is 
shown in Figure 10. In this generator, we establish 
another hybrid carry bit ht and output function then 
merge them with DSG to generate the keystream z3t, it 
can be defined as follows: 
z3t = a0t ⊕ b0t ⊕ c0t ⊕ ht-1    
ht = a0t ·(b0t ⊕ c0t ⊕ ht-1) ⊕ b0t ⊕ c0t   
The initial state of the bits, ht-1, is defined to be 0. 
 
Figure 10: The output sequence generator 3 
3.6 Key/IV Setup 
The inputs of the keystream generator are called 
seeds. The requirement of this seeds must be random 
and unpredictable before generating the keystream. 
For this reason, we must use the key initialization 
procedure to perform the requirement. In this 
subsection, we describe the computation of the initial 
inner state before starting the keystream generation. 
First, part bits of the secret key are collaterally loaded 
into the 318-bit initial state of the cipher. Then the 
remaining bits of secret key and the 128-bit 
initialization vector are fed in the 318-bit initial state 
of the cipher by key initialization procedure. We 
generalize the Key/IV Setup into two phases, initial 
filling phase and key initialization procedure phase. It 
works as follows. 
3.6.1 Initial Filling Phase 
The 128-bit secret key K is denoted by K = K0, …, 
K127 and the 128-bit initialization vector IV is denoted 
by IV = IV0, …, IV127. The internal states of LFSRα, 
LFSRβ and LFSRγ are denoted by αi, βi and γi 
respectively, where: 
αi, 0 ≤ i ≤ 30      
βi, 0 ≤ i ≤ 16       
γi, 0 ≤ i ≤ 12       
And the internal states of LFSRa, LFSRb and LFSRc 
are denoted by ai, bi and ci, respectively, where:  
ai, 0 ≤ i ≤ 60       
bi, 0 ≤ i ≤ 88       
ci, 0 ≤ i ≤ 106     
The initial filling of each LFSR is done as follows: 
(a60, a59, …, a1, a0) ← (K59, K58, …, K0, 1)  
(α30, α29, …, α1, α0) ← (K89, K88, …, K60, 1) 
(b88, b87, …, b1, b0) ← (K87, K86, …, K0, 1)  
(β16, β15, …, β1, β0) ← (K105, K104, …, K88, 1) 
(c106, c105, …, c1, c0) ← (K105, K104, …, K0, 1) 
(γ12, γ11, …, γ1, γ0) ← (K117, K116, …, K106, 1) 
Notice that, only part bits of the secret key are 
collaterally loaded into the 318-bit initial state of the 
cipher. There are 38-bit secret key and 128-bit 
initialization vector have not used yet. 
3.6.2 Key Initialization Procedure Phase 
After part bits of the 128-bit secret key are 
- 8 - 
Table 6: Statistical Test Results under NIST SP800-22 
 
5  Conclusions and Future Works 
We have proposed a key-based multi-mode 
clock-controlled stream cipher with 128-bit secret key 
and 128-bit initialization vector. The cipher is 
equipped with multi-mode depending on the secret 
key. The different modes are shipped with different 
encrypting circuit depended on user’s session key. 
We have given the mathematical results about the 
period and linear complexity of the proposed cipher. 
The result shows that the period of the proposed 
stream cipher is enough to the consideration of the 
security requirements for each cipher mode. On the 
other hand, the linear complexity for the proposed 
stream cipher satisfied the security strength of AES, 
even stronger than AES. For the good statistical 
properties for randomness, the proposed cipher passes 
the FIPS PUB 140-1 tests at least in proportion of 
97.00% and passes the SP800-22 test suite at least in 
proportion of 98.00%. 
The structure of the proposed cipher is very 
simple, which is based on multi-LFSR and equipped 
multiple cipher modes to enhance the security. The 
designs of NLFSR-based circuit, FCSR-based circuit 
and optimization hardware circuit will be the direction 
in the future works. Also, more different attacks will 
be used to verify the security strength of the cipher. 
References 
[1] A. Biryukov, A. Shamir and D. Wagner, “Real 
Time Cryptanalysis of A5/1 on a PC,” in Proc. 
of the 7th International Workshop on Fast 
Software Encryption, Apr. 2000, pp. 1-18. 
[2] Đ. Eugüler and E. Anarim, “A Clock-Controlled 
Stream Cipher with Dual Mode,” Springer 
Proceedings in Physics Series, vol. 104, 
Complex Computing-Networks, 2006, pp. 
343-352. 
[3] M. D. Galanis, P. Kitsos, G. Kostopoulos, N. 
Sklavos, O. Koufopavlou, and C. E. Goutis, 
“Comparison of the hardware architectures and 
FPGA implementations of stream ciphers,” in 
Proc. of IEEE International Conference on 
Electronics, Circuits and Systems, Dec. 2004, 
pp.571-574. 
[4] D. Gligoroski, S. Markovski, L. Kocarew and M. 
Gusev, “Algorithm Description of Edon80,” 
eSTREAM Report, ECRYPT Stream Cipher 
Project, 2005. Available online at 
http://www.ecrypt.eu.org/stream/p3ciphers/edon
80/edon80_p3.zip 
[5] M. Kasper, S. Kumar, K. Lemke-Rust and C. 
Paar, “A Compact Implementation of Edon80,” 
eSTREAM Report, ECRYPT Stream Cipher 
Project, 2006. Available online at 
http://www.ecrypt.eu.org/stream/papersdir/2006/
057.pdf 
[6] G. Kostopoulos, N. Sklavos, M.D. Galanis, and 
O. Koufopavlou, “VLSI Implementation of 
GSM Security: A5/1 and W7 Ciphers,” in Proc. 
of the IEEE Work in Wireless Circuits on System 
(IEEE WoWCAS04), May 2004. 
[7] C. S. Laih, L. Harn and C. C. Chang, 
Contemporary Cryptography and Its 
Applications, Flag Publishing CO., LTD., Taipei, 
Taiwan, R.O.C., 2004. 
[8] M. H. Lim, B. M. Goi, S. G. Lee, and H. J. Lee, 
“Hierarchical Dawson’s Summation Generator,” 
in Proc. of the 2007 International Conference on 
Convergence Information Technology, Nov. 
2007, pp. 1395-1401. 
[9] A. Rukhin, J. Soto, J. Nechvatal, M. Smid, E. 
Barker, S. Leigh, M. Levenson, M. Vangel, D. 
Banks, A. Heckert, J. Dray and S. Vo, “Special 
Publication 800-22 Revision 1: A Statistical Test 
Suite for Random and Pseudorandom Number 
Generators for Cryptographic Applications,” 
National Institute of Standards and Technology, 
Aug. 2008. 
[10] W. Stallings, Cryptography and Network 
Security: Principles and Practice, 3rd Edition, 
Prentice-Hall Inc., Upper Saddle River, N.J., 
2003. 
[11] M. Živković, “A table of primitive binary 
polynomials,” Mathematics of Computation, vol. 
62, Issue 205, pp. 385-386, Jan. 1994. 
[12] National Institute of Standards and Technology, 
“Security Requirements for Cryptographic 
Modules,” Federal Information Processing 
Standards Publication 140-1, Jan. 1994. 
 
98年度專題研究計畫研究成果彙整表 
計畫主持人：吳錫聰 計畫編號：98-2221-E-197-008- 
計畫名稱：以金鑰為基礎的多模態鐘訊控制串流加密器之研究與實現 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 2 2 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 2 2 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 0 1 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
 
