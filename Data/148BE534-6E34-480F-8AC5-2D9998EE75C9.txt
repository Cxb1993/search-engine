II 
目錄 
1 前言(Preface) ......................................................................................................................1 
2 研究目的 .............................................................................................................................4 
3 文獻探討 .............................................................................................................................8 
4 研究方法、進行步驟及執行進度.....................................................................................20 
4.1 Methodology Modeling Domain (MMD) ..................................................................21 
4.1.1 SPACE統一超模型(SPACE Unified Metamodel) ........................................21 
4.1.2 The Foundation Metamodel ..........................................................................22 
4.1.3 流程模型(Process Metamodel) ......................................................................24 
4.1.4 工作產出模型(WorkProduct Metamodel).....................................................25 
4.1.5 角色模型(Role Metamodel) ...........................................................................26 
4.1.6 輔助工具模型(Tool Metamodel) ....................................................................27 
4.1.7 SPACE統一超模型 Sub Metamodels之整合 ...............................................28 
4.1.8 SPACE Unified Metamodel之結構...............................................................28 
4.1.9 SPACE Modeling Definition Tool： ..............................................................30 
4.1.10 MMD Interface：...........................................................................................31 
4.1.11 MMD Repository：........................................................................................31 
4.1.12 MMD總結......................................................................................................31 
4.2 Process Performing Domain：..................................................................................32 
4.2.1 PPD User Interface ........................................................................................34 
4.2.2 PPD Processor ................................................................................................35 
4.2.3 Connector .......................................................................................................39 
4.2.4 PPD總結 ........................................................................................................39 
4.3 Process Enactment Domain.......................................................................................39 
4.3.1 PED模組 ........................................................................................................40 
4.3.2 PED Interface： .............................................................................................41 
4.3.3 PED Repository： ..........................................................................................41 
4.3.4 PED總結 ........................................................................................................41 
4.4 SPACE Agent System................................................................................................42 
4.4.1 Process Enactment Agent Platform (PEn-AP)..............................................43 
4.4.2 Process Execution Agent Platform (PEx-AP) ...............................................43 
4.4.3 動態調整軟體方法之支援 ..............................................................................44 
4.4.4 SPACE 支援 CMMI......................................................................................44 
4.4.5 SPACE總結 ...................................................................................................49 
5 結論 ...................................................................................................................................50 
6 參考文獻(References) .......................................................................................................51 
7 近五年已發表之相關論文、期刊.....................................................................................56 
 
2 
 
圖 2 年度台灣資訊產品價值(Source: MIC/III March 2002) 
為提升整體產業產值、產業規模、產品發展能力、研發投入規模與實力、外銷能力、
大型資訊系統承接能力則必須要有國際標準之引導與認證或是軟體流程作業模型準則，如
ISO 9000系列、CMMI等等，才可取得國內外之軟硬體廠商之信任，進一步與國際級開發
廠商相互匹敵。 
從表 1 軟體產業環境 SWOT 之分析，我們試著利用管理學上的 SWOT(Strength, 
Weakness, Opportunity and Threat)分析，分析台灣軟體產業外在環境的機會與威脅；及內部
的優勢與劣勢。我們可以得知，由於台灣軟體開發的可再使用性很低，因此，台灣軟體產
業如要進軍國際，則必須要有國際標準輔助、相關軟體工程方法以及相關工具之導入，組
織團體才具其競爭力。因此，軟體工程的觀念在學、業界愈來愈受到重視，許多軟體開發
流程技術如雨後春筍般的被大量提出，例如 RUP(Rational Unified Process)、
OPEN(Object-orient Process Environment and Notation)、XP(eXtreme Process )、PRIME(Toward 
Process-Integrated Modeling Environments)等等。 
每一種開發流程都具有其特色及適合的專案大小類型，而許多對於軟體品質的衡量，
也逐漸採用相關標準所規範的準則，作為評量的依據。但是，不論軟體開發單位欲導入的
是何種開發流程技術，其中對於開發流程技術的繁雜規則、條例以及限制，卻往往讓企業
望之卻步。深究其原因，軟體開發人員缺乏經驗，同時缺乏相關方法、技術、工具與流程
控制，讓企業不知從何入門，是最大之隱憂。因此，如何在引入軟體流程作業模型準則時，
融入其中以畢其功於一役，並整合組織資源，發揮組織內部最大效益，是軟體工程導入一
大重點。相關電腦輔助工具(CASE Tool)則是另一個導入重點。雖然軟體工程方面的應用工
具更是多不可數，每一種工具或方法論往往只著重支援整體軟體開發程序的某部份，無法
涵蓋整體軟體發展過程，例如 Rational Rose只著重於設計階段之輔助開發。因此，統整各
類型工具並使其相互溝通利用成為系統開發環境中是在導入軟體工程中的一大挑戰。 
4 
2 研究目的 
近年來，由於軟體產業的發達，軟體系統的需求量愈來愈大，但是開發者對於軟體工
程的導入卻反而無所適從，一方面是軟體工程導入不易，開發人員教育訓練時間過長；一
方面所使用的軟體輔助開發工具相互整合來源資料亦有有難處，彼此間無協調整合機制。
如此多樣的不確定因素讓開發者之發展環境持續在改變而使其無所適從，軟體開發方法、
軟體開發流程與軟體輔助開發工具無法相互整合，以至於不能發揮整體綜效。 
為能使軟體開發整體效益有效地提昇，陸陸續續有多種標準化的模型(Models)與技術
(Technologies)被提出以解決各階段的問題，例如，物件導向分析與設計觀念之於軟體架構
分析與規劃[2][7]；標準化模型語言(UML)之於系統整體架構、設計、狀態控制、與測試分
析[3][5]；設計樣板(Design Patterns)之於問題定位與有效設計模式的導入[10]；元件再使用
(Reusable Components)之於回收應用高效益高認同之軟體與資料模組或片段[1]；標準化的
導入之於軟體作業流程準則[87]等等。它們試圖在所針對的領域中提出整合性的標準化，也
達到了相當的成果。 
然而，綜觀整個軟體開發流程的各個階段與並檢討其間的連貫關係，各階段發展的標
準、方法步驟以及應用工具，卻因為缺乏彼此之間協調與整合的考量機制存在，致使軟體
開發者在每一階段內部，必須以人工方式檢視並協調整合來自不同標準、方法及應用工具
之來源資料。也因不同設計之間的統合、細部分工等作業程序，使得軟體開發與研究者無
法以一個一致性、協同性的開發方式進行軟體系統的開發作業，而使得整個軟體開發成本
居高不下。 
UML
Design
Patterns
Framework
CBSE
Requirement
Analysis Design MaintenanceImplementation
 
圖 3 The Relationship of Some Software Paradigms and the Software Life Cycle 
另一方面，在軟體開發生命週期(參考圖 3)中，軟體設計的知識也需要一個系統化的表
示方式(Representation)，才可有效的累積軟體設計的知識。然而，知識的累積勢必需要導入
軟體流程作業模型準則，比如 CMMI，來維護並支持軟體知識(Software Knowledge)的保存。
但是軟體流程作業模型準則畢竟只是一準則而無強制性的行為模式，這樣的一個方式往往
會讓開發者失去持續執行的信心，最後無法徹底實施準則而導致整體開發的失敗。所以，
在理想狀況下，開發者因利用一內嵌作業模型(如：Embedded System Model)準則之環境來
作業，透過此環境的控管與支援來執行作業模型準則，如此一來即可作到自動化效果。因
此，我們希望能有利用一軟體流程作業模型準則，比如 CMMI，來完成軟體開發方法、軟
體開發流程與系統工具之整體開發環境，達到彼此互補而發揮綜效。 
本計劃的研究背景即是感受到這些上述問題，希望克服以上種種因素，將其他已導入
6 
XUM
 Framework RepresentationView
Representation
SubModel1 for
Use Case
diagram
XUMM
Transformation
Models in Standards
SubModel2 for
Class diagram
SubModel3 for
Collaboration
diagram...
SubModeln for
Design Patterns
Source
Code
Source Codes
with XUM tags
Components
Associations
...
...
...
SM1
SM2
SM3
SMn
 
圖 5 The unification and integration of models into XUM 
現在的軟體開發(Software Development)隨著軟體複雜度的增加，以及必須整合各種硬
體、OS、應用程式皆不同的異質性系統，譬如嵌入式系統與無線網路等，因而遭遇到更多
的困難與挑戰。而對於大部分的系統而言，軟體的發展與維護比起硬體的設計與實作更容
易產生問題。 
為了解決軟體開發上的問題，已有眾多軟體工程方法論、流程工程 (process 
engineering)、以及電腦輔助軟體工程工具組(Computer Assisted Software Engineering tools, 
CASE tools)相繼被提出。然而，這些方法論、流程工程、與 CASE tools並未經過適當的整
合，因此對於整個軟體開發流程來說，所能提供的支援並不完全。他們大多僅能支援軟體
流程裡的某個階段，所以在軟體開發過程中仍然有許多活動必須要仰賴人工作業；這樣會
容易產生錯誤、不一致與不可靠的情形發生，進而導致軟體品質與生產力的降低。 
在此我們將基於此研究基礎，持續開發相關管理工具，並計畫將我們的開發工具在嵌
入式系統作為驗證環境。而且 Embedded System Software development的未來發展是非常令
人期待的，因為它所需消耗的資源及成本不像在傳統 PC 上所要求的那麼高；並且可以客
制化，滿足客戶特殊的需求；同時，由於所需的成本與資源的限制，所以在開發上會有更
多的困難與考量，及產品品質的要求更高，所以在研發上必須比在傳統 PC 上更為小心謹
慎，避免不必要的資源浪費。因此，如果在 Embedded System上的測試結果是令人滿意，
那開發出具一致性、連貫性的整合開發環境，並建立一個系統環境，以驗證本構想的可行
性。 
以下為本計畫所提出之 SPACE特色： 
I. 提供一框架(Framework)以及應用程式介面(API)，供系統開發者客制化環境。我們
將研發一個開發方法，可以彈性的針對每個專案需求的不同。我們為整合 System，
加入 Process及 Collaboration的特色與 XML Represention，並導入合適的軟體開發
方法，調整為合適於組織的開發方法。我們希望能協助開發組織藉由我們的開發
方法，解決專案需求不斷變化的問題。 
II. 強調協同合作(Collaboration)之開發模式。 
協同合作所要強調的，就是達到開發團隊之間的合作機制。開發一項大型專
案，最常面臨到的問題，無非是開發團隊之間的溝通、協調與合作。現今針對協
同合作之相關議題有許多，例如：透過行動代理人(Agent)，扮演開發團隊之間的
溝通角色，除了取代傳統的人工，還能夠節省大量的成本花費[96]。 
8 
3 文獻探討 
本計畫提出之整體環境主要包含三個領域，軟體工程方法論、電腦輔助工具、流程控
制理論。而除了基本領域之外，亦涵蓋了 CMMI以及 ISO 9000系列標準。相關研究詳述如
下： 
I. 軟體工程方法論(Software Processes Methodology) 
A PRIME,Toward Process-Integrated Modeling Environments [54] 
近十年來的軟體工程趨勢，偏向以流程為主的開發環境(Process-centered 
Environments，PCEs)[54]。其焦點放在專案管理支援而忽略了工程師開發專
案流程的方法守則(Method Guidance)。所以，以流程導向為主的開發環境主
要是以支援資料整合機制為主，譬如其資料交換格式的儲存；然而，這暗示
著 PCEs的流程知識並不穩定，亦無法提供一完整軟體工程環境。 
在 PRIME 的框架(Framework)中，它允許以 Process-integrated 為主的工
具嵌入方法守則，與以 PCEs為主的工具相較之下，可以知道 PRIME的工具
是根據目前流程的實際情況和方法定義來調整自己的行為。PRIME的流程整
合工具必須完成工具模型的定義、工具模型與方法定義的整合、工具、
Process-aware 的控制流程機制、以及標準機制來完成整合環境模型、以廣泛
的通訊協定來同步工具與標準機制。 
PRIME提供了一個整合性之流程框架，能根據客制化之軟體方法定義與
流程發展現況來調節開發人員的行為，可以強化軟體方法導引準則之效力。
但其缺乏軟體相關標準的支援，如 CMMI、SPEM，也未強調現代眾所皆知的
軟體方法論之應用，如 RUP、XP，且其流程法規領域(Process Enactment 
Domain)對於軟體流程之控制與目前工作流程(Workflow)的定義比較之下顯
得較薄弱。本計畫所提出之 SPACE強化了 PRIME之優點且補其不足之處，
具有以下之特性： 
1. 以標準化技術及 Pattern-Based 為基礎： SPACE 應用了許多，如 OMG
之 UML、XML、SPEM，WfMC之Workflow Reference Model[93]，FIPA[94]
之 Agent Management Reference Model，Rational之 RUP等經過公認組織
與領域專家驗證之軟體標準。 
2. 符合 CMMI之精神： SPACE之架構是基礎於目前 CMMI制定的軟體流
程作業模型準則所發展的，能滿足 CMMI之核心精神，確保流程品質與
軟體品質。 
3. 智慧型代理人為基礎之工作流程模型： 基礎於 WfMC 之 Workflow 
Reference Model，SPACE應用了具智慧與可移動性之軟體代理人的技術
來實作流程法規領域，更能強化流程引擎對於軟體流程規則之控制，並
促進開發人員間之協調合作。 
4. 動態軟體方法(Dynamic Software Process)之支援： 在大部分之情況下，
因為專案需求不斷改變，軟體方法亦必須隨之更改。SPACE 將應用
10 
系統開發者只需所遵循之軟體工程方法論，依照其指示，一步一步的開發系
統，並不需要透徹的了解各種開發流程之詳細規範，便可達到依循特定開發
流程的開發成果；另外，本研究之開發環境也確切考慮到工具整合的問題，
本環境利用 XML 檔案的特性，訂定 Meta-data，利用文件檔案方式來串接各
階層工具所需之資訊。 
C 物件導向式流程、環境與標記(Object-Orient Process Environment and Notation, 
OPEN)[27][28][29][30][32] 
OPEN 是最早被公認的物件導向軟體開發流程。它提供了一組可以彈性
編修的工作項目與技術，以適用於各式各樣的軟體開發單位與商業領域[30]。
而正由於 OPEN具備極佳的彈性，所以 OPEN特別有益於軟體開發流程的制
定與需求工程[24] [25][31]。 
但是，OPEN 所強調的在於設計階段，即軟體系統之分析與設計模型的
塑模，並未包含完整的軟體開發流程，且也未將軟體開發品質標準與其方法
結合；再者，OPEN 並無將參與軟體開發過程中的因素加以分門別類，亦造
成導入上的困擾。在本研究中，我們不但將整個軟體開發生命週期：分析、
設計、實作、測試與維護的方法整合進來，更將方法與流程品質標準結合；
另一方面，本計畫所提出之 SPACE Unified Model亦將軟體工程參與之要素
加以歸類，並擁用其Meta-model，可讓組織團體導入更加容易入手。 
D 敏捷流程(Agile Process)[53][54]  
這套方法論強調視個案的實際需要來靈活運用各種工具和策略，有別於
其他紀律型的開發方法(如統一流程)，Agile 較注重人性，強調不同的人格特
質需要運用不同的管理策略，也就是因人、因時、因地制宜的策略[49][50]。 
Agile Process 最大的目標是能決定重要的商業流程並把他們整合進入
Agile Process中。在檢驗企業內部的商業流程時，首先要開發一個方法以 
評估企業本身的價值所在，然後在 Agile Process的結構裡，建立一個完全評
量模型，用它來考量了所有策略上與運作上的因子[50][51]。 
在這個方法中，缺乏了一個正規的軟體開發流程，無法確保流程標準與
秩序，並且沒有相關工具可以引用導入。而我們認為軟體的開發仍然需要一
軟體工程方法導入協助，進而利用相關工具開發才能有效節省成本。本研究
即是強調基礎於一個軟體工程方法、視商業流程與專案環境需求做適當的調
整、利用輔助工具以符合每個專案的需求。 
E 極端軟體製程(eXtreme Programming, XP) [40][41][46] [47][48] 
極端軟體製程是一種新式、輕巧的軟體開發方法，XP式的團隊運用客戶
駐點、持續測試、以及其獨特的規劃方式，為自己帶來快速的回饋以及大量
的溝通，這些都有助於團隊發揮出最大的效益[42][43]。 
相較於傳統的開發方式，XP強調客戶參與的做事方式跟測試先行的程式
技巧，專案以客戶主動聯繫開發團隊為開端，開發團隊則要求客戶必須在整
12 
用資訊整合串接起來，進而降低開發成本、加速軟體的開發。 
軟體工程階段大概涵括了需求分析階段、設計階段、實作階段、測試階段、
維護階段，各階段有相關可利用之工具可以使用，本計劃將整合相關之工具並連
結所有工具之產出物。 
III. 軟體組態管理(Software Configuration Management) 
軟體配置管理，簡稱 SCM（Software Configuration Management）,它應用于整
個軟體工程過程。我們知道，在軟體建立時變更是不可避免的，而變更加劇了項
目中軟體開發者之間的混亂。SCM活動的目標就是為了標識變更、控制變更、確
保變更正確實現並向其他有關人員報告變更。從某種角度講，SCM是一種標識、
組織和控制修改的技術，目的是使錯誤降為最小並最有效地提高生產效率。 
CMMI Level 2 中，共包含了六項主要的 Key Process Area(KPA)，Requirements 
Management, Software Project Planning, Software Project Tracking & Oversight, 
Software Subcontract Management, Software Quality Assurance, and Software 
Configuration Management。其中除了 Software Subcontract Management是不一定要
實做外（因為公司可能都不外包），其他一定都要有計畫的實做，才能符合 CMM 
Level 2 的基本要求。 
主要目的是建立和維持軟體在整個 lift cycle的完整性。舉個例子來說，在某
個時間點時，必須有能力把設定安裝等等事項，要能有效率，系統化的被控制和
實行外，還要有能力追蹤軟體改變的情況。其中還包括有系統化的找出該交付給
客戶的軟體，一切必須的工具和文件等等。 
Configuration Management是非常複雜而且重要的項目，市面上也有一些專門
為 SCM寫的軟體可以使用，會比自行開發容易。例如 Rational 的相關產品，Lucent 
Sablime Configuration Management System(CMS)等等。 
IV. SPEM , Software Process Engineering Metamodel[96] 
SPEM是OMG(Object Management Group)提出的，用來定義流程跟架構。OMG
在 2001年 12月定案，定義和發表 SPEM的規格。利用 Metamodel 來描述具體
的軟體發展流程(software development process)或是一系列有關軟體發展流程的關
係。然而，Process enactment是在 SPEM的領域之外的。以 SPEM為基礎的典型
工具將為編寫和定製 process。先前已經有發表過類似功能的 tool，如：Rational
的 RUP，稱為 Rational Process。可以幫助我們設計出一個提供使用者存取流程的
工作台。 
SPEM 的目的是定義具體的軟體發展流程，包括那些 Process或者 UML的指
令, 像是 RUP。在九十年代後期，統一流程和 UML 的產生，影響了軟體發展中
的基本轉變。Unified Process的差異是被使用在廣泛的工業實施上，必須加以訓練
和實踐流程才會成功。 
SPEM使用物件導向的方法來塑模相關的軟體流程，且 SPEM以 UML的語法
格式表示之。OMG定義成四層的組織架構： 
14 
1. Level-1：初始級(Initial) 
  企業對專案的目標很清楚明白。因此，專案的目標是可以實現。但
是由於專案的完成帶有很大的偶然性，企業無法保證在實施同類專案的
時候仍然能夠完成任務。企業在初始級上的項目實施對實施人員有很大
的依賴性。 
2. Level-2：管理級(Managed) 
  企業在專案實施上能夠遵守既定的計畫與流程，有資源準備及權責
負責人，對相關的項目實施人員有相應的培訓，對整個流程有監測與控
制，並與上級單位對專案與流程進行審查。企業在管理級水平上體現了
對專案的一系列的管理程式。這一系列的管理手段排除了企業在初始級
時完成任務的隨機性，保證了企業的所有專案實施都會得到成功。 
3. Level-3：定義級(Defined) 
  企業不僅僅能夠對專案的實施有一整套的管理措施，並保障項目的
完成；而且，企業能夠根據自身的特殊情況以及自己的標準流程，將這
套管理體系與流程予以制度化。企業不僅能夠在同類的專案上得到成功
的實施， 在不同類的專案上一樣能夠得到成功的實施。科學管理成為企
業的一種文化，企業組織的財富。 
4. Level-4：量化管理級(Quantitatively Managed) 
  企業的專案管理不僅僅形成了一種制度，而且要實現數位化的管
理。對管理流程要做到量化與數位化。通過量化技術來實現流程的穩定
性，實現管理的精確度，降低項目實施在品質上的不確定。 
5. Level-5：優化級(Optimizing) 
  企業的專案管理達到了最高的境界。企業不僅能夠通過資訊手段與
量化管理方式來實現對專案的管理，而且能夠充分利用資訊資料，對企
業在專案實施的過程中可能出現的錯誤予以預防。企業的專案管理並能
夠主動地改善流程，運用新技術，實現流程的優化。 
本計劃即是將 CMMI 管理流程的標準化精神納入 SPACE 之中，CMMI
的流程規範制定了許多軟體工程的開發流程，而本系統的開發方法即與
CMMI的流程結合，即是在設計開發流程的階段，由系統根據 CMMI的精神，
提供流程設計者指引與建議。另外，本系統的 CASE工具亦是根據 CMMI精
神所制定的文件與規格。因此，利用本系統所開發的專案即可確保達到 CMMI
所制定之軟體流程作業模型準則。 
B. ISO 9000 Series[81][82][83] 
ISO9000標準是 87年出版的，94年修改過一次。94版和 87版的寫法基
本上適應加工工業，按加工工業產品的過程編寫出來的。2000版是因為各行
各業都要用，所以進行改版，特別是服務業，過去的標準不適合服務業(如：
什麼是不合格、檢驗、生產等)，2000版改版後對服務企業比舊版本要好得多。 
新版 ISO9000系列標準由：9000、9001、9004(19011在 CD3階段，未出
16 
工作的效率與品質。在我們所提出的 SPACE中，各開發步驟所產出的文件格式是
可視軟體開發人員之需求來制定，而主要是以 UML所訂定的各種圖形為標準。 
II. XML與 XMI[62] 
XML是由World Wide Web Consortium (W3C)所制定的標準，一種延伸式的標
記語言，具有擴展性(Extensibility)、結構性(Structure)、描述性(Description)、確認
性(Validation)等特性。同時 XML具有跨平台的功能，對於不同的作業系統、硬體
設備、應用軟體、多元的輸入模式，開發者可以自行制定符合己身需求的標記
(tag)，做結構性的描述，促使相同的一份文件呈現不同的規格，適用於不同的軟
體，符合不同的設備、滿足多重的輸入方式。 
再者，使用者可定義各種 XML schema或者是根據W3C提供的 DTD建構物
件實體，完成一份標準的 XML 文件，不管是開發者或是使用者都能解析這份文
件，如：公司企業經常使用不同的應用軟體，依此方法定義資料格式，企業間資
料的傳輸便不是問題[62]。 
因為 XML本身就是一種Meta Language，可利用 XML定義各種Model的文
件語言, 在進行各種 model轉換時可以利用 XML延伸出的 XMI 來幫助文件的交
換及存取。XMI是 XML Metadata Interchange 的縮寫，在 XMI裡 X代表 XML跟
eXtensible雙重意義。XMI 在 1999年三月二十三日正式W3C被所建議為正式標
準。 
XMI是一種提供以 XML來交換 Object-oriented models和資料的標準，XMI
同時是 OMG(Object Management Group)所認可的一種新的標準，讓使用者可以根
據 XMI的標準標籤(Tag)將 UML文件轉換為 XML及 DTD文件。XMI讓 XML使
用起來更加的容易，因為它應用了 UML圖形化的特性來產生 XML所需的文件及
DTD檔。而且 XMI讓 XML DTD檔、軟體設計及 XML文件資料可以一致。XML
確實提供了一個很好的方法來讓我們可以分享及交換資料，可是必須要有一些額
外的機制，才能讓這方法用來分享或交換物件，而 XMI正是由 OMG認可的新標
準可以讓我們使用 XML來分享或交換物件。 
在本計劃中將以XML 作為各階段的接著劑，進行資料格式的轉換，也將UML 
轉成結構化語言。 
III. Software Agent[12][13][19][20][23] 
何謂智慧型代理人(Intelligent Agents)？不同領域對它有不同的解釋，如人工
智慧的研究人員可能認為代理人是「一種藉由執行某些工作，模擬人類關係的電
腦程式」(Selker 1994)；若以軟體工程的角度，則認為代理人是「軟體的一部份，
能用一組語言相互溝通、交換訊息」(Genesereth & Ketchpel 1994)；在分散式系統
的看法，代理人代表著「一種可以克服異質性電腦網路中，程式介面、資料格式
與通訊協定之間不相容的方法」(Ousterhout 1995)[14][15][16]。 
因為 Agent 會因不同的使用領域而有所差異，所以到目前為止智慧型代理人
並無一個明確的定義，大致上來說以 James 所提出的看法能被大多數人所接受，
他認為智慧型代理人是一個在動態變化的環境中計劃好的系統，可以改變自己的
18 
方法、限制，和其它的替代方案。 
D Win Win螺旋模型[58]：Win Win螺旋模型(Win Win Spiral Mode)是藉由
找出下一階段的參與人員，參與人員所關心的事項，和整合這些事項等
三個步驟來獲得下一階段所需要達成目標的各種方法以及這些方法的限
制，和其它的替代方案。 
E RAD (Rapid Application Development ) [58][59]：它是一種線性序列軟體
開發過程模型，能以元件為建構方法來快速的完成開發工作；其缺點乃
在開發大系統時，則需要足夠的人力資源來建立正確數量的 RAD小組。 
F 同步開發模型(Current Development Model) [58][60]：又稱為同步工程
(Concurrent Engineering)，可應用在所有型態的軟體開發上。它可以被大
致描述成一系列的主要技術活動、任務、及其結合狀態。此模型也定義
了一串的事件 ,會對軟體工程中的活動觸發狀態間的轉移。 
G 正規方法模型(Formal Methods Model) [58]：經由數學表示來說明、開發
及驗證一個電腦化系統，能排除含糊、矛盾的步驟，且提供了無缺陷軟
體的承諾，此模型適用於需要安全的環境。其缺點乃是其開發時間長，
需要教育訓練，不容易將此模型使用來與客戶作溝通。 
H 雛型法模型(Prototyping Model) [58][61]：其最大的優點是可以確實掌握
客戶需求，靈活的修改。在傳統模式中，雖然也有強調雛型系統的重要，
但是還不如採用物件導向技術來的容易建構。 
上述軟體發展流程各有各的適用範圍，而一個軟體系統發展過程中，也
有可能會同時應用兩種以上的軟體發展模型，因此本計劃利用了物件導向技
術的精神，提出了一個整合架構的模型。此模型將系統分析階段(System 
Requirement Analysis Phase ) 、軟體設計階段(Software Design Phase) 、系統
實作階段(System Implementation Phase)、系統維護階段(System Maintenance 
Phase), 以及架構在軟體開發標準之上所提出的中間模式( Inter-operable XML 
Meta-Model )整合串接起來，提昇了異質開發模式下的元件再利用性。 
V. Java Environment[63][64][65][66][67][68] 
二十世紀末兩項最大變革，就是網際網路與物件導向的興起。物件導向觀念
之所以成為主流的原因，不外是由於企業外在競爭環境的變遷快速，為滿足企業
需求，資訊人員必須加速應用軟體的開發以及應用系統的修改。物件導向技術的
優點包括了適合開發元件化軟體、易於修改、與重複使用性，已經成為全球軟體
開發的主流。因此多種物件導向的程式設計語言有隨著被發展， 譬如 Java等。Java
語言本身具有下列多項特色： 
1. Write once, run anywhere：具有可攜性以及跨平台的特性，因此適用於各種
異質環境與不同的作業系統。 
2. 維護簡單：易於除錯、程式修改、增加新功能方面，因為物件的特性，使得
這些維護也變得非常容易[66][67]。 
20 
4 研究方法、進行步驟及執行進度 
 
圖 6 SPACE 系統架構圖 
本計劃所提出之以智慧型代理人為基礎之軟體流程協同開發環境(Software Process and 
Agent based Collaborative development Environment, SPACE)為延續先前研究成果，針對系統
規模的度量、各相關子功能進行模組化之關連性探討、模組分析與設計、整合分析與原型
發展，利用其理論設計一套具實用性質的工具與系統整合流程環境。其流程、工具與領域
三者間的整合，如圖 6 SPACE 系統架構圖所示。 
SPACE 由三大設計領域組成：  1. Methodology Modeling Domain、2. Process 
Enactment Domain與 3. Process Performing Domain，以下分別詳加描述： 
22 
一個完整的 SPACE Unified Metamodel交集了上述 1+4個子模型，它們內部的關聯簡
化如下： 
 
圖 8 SPACE conceptual Model示意圖 
I. Role Metamodel利用“is responsible for”結合關係連結了WorkProduct Metamodel。 
II. WorkProduct Metamodel利用“Be Used as Input”與“Produces as Output”關係來跟
Process Metamodel互相連結。 
III. Role Metamodel利用“performs”結合關係來連結 Process Metamodel。 
IV. Tool Metamodel利用“supports”關係支援其他三個 Sub Metamodels。 
V. 在 SPACE Unified Metamodel內所有的 model elements和 relationships 都是透過
Foundation Metamodel裡的元素所描繪出來的。 
4.1.2 The Foundation Metamodel 
Foundation Metamodel是 SPACE Unified Metamodel裡最基本的 Sub Metamodel，它提
供了 SPACE Unified Metamodel所需要的基礎語義文法。Foundation Metamodel可以由三個
不同的 Views來表現，即 the core view、the relationship view、the basic elements view如圖
9，以下將分別描述之。 
 
圖 9 The Foundation Metamodel 完整架構圖 
24 
型元素間各種不同的相依關係，分別定義了不同的意義，以下詳細說明： 
 
圖 11 關係概觀圖 
Dependency如 UML所定義，Dependency是一種使用關係，代表某依事物規格的改變
有可能會影響到另一個使用該事物的事物規格，但反過來則不一定成立。 
Generalization如UML所定義，Generalization是一般性事物和其特殊性事物之間關係。 
Association 如 UML 所定義，Association 是一種結構關係，它可以訂定某一種事物的
物件是如何與另一種事物的物件之間互相連結的。 
4.1.2.3 基礎元素概觀(The Basic Elements View)  
The Basic Element View，如圖 12所示，詳細描述了在 SPACE Unified Metamodel裡面，
用來描述與引導流程元素的基本元素。以下詳細說明： 
 
圖 12 基礎元素概觀圖 
Guidance用來連結模型元素，以提供更多詳細的資訊來引導使用者運作此模型元素。
Guidance有兩個基本 attribute，AnnotatedElement和Kind。AnnotatedElement定義了Guidance
所連結的模型元素；Kind定義了此 Guidance的種類，屬於 GuidanceKind element。模型元
素根據不同的流程定義，可能連結數種可能的 GuidanceKind 子元素。 
GuidanceKind Guidance的分類，用以區別 Guidance的中種類。而 GuidanceKind包括
了 Technique、ToolMentor、CheckList、Guideline、Template、CASETool六大類。 
4.1.3 流程模型(Process Metamodel)  
流程模型是用來定義軟體開發流程之所有活動(activity)與其之間關聯順序的模型。如圖
26 
 
圖 14 WorkProduct Metamodel靜態結構圖 
UMLModel 在軟體開發生命週期中，使用 UML 所制定的各種 model。需求分析階段
後制定 UseCase Model、系統分析階段會制定 Analysis Model，而在設計及實作階段，則會
制定 Design Model和 Implementation Model，以各個階段所產出的 model來輔助系統開發流
程活動中的下一階段之順利執行。 
SourceCode包含系統開發原始程式碼、中介碼以及可執行檔。在軟體開發的流程中，
所產出的程式碼，可能包括 Java bytecode以及 component(含 executable file以及 dll(dynamic 
linking library) )。 
4.1.5 角色模型(Role Metamodel)  
角色模型是用來定義負責執行軟體開發流程活動之角色與角色指定人員的模型。如圖
15 Role Metamodel靜態結構圖。 
 
圖 15 Role Metamodel靜態結構圖 
28 
有具體功能的高階 CASE 工具如 RATIONAL ROSE，而高階 CASE 工具產出物即是
Workproduct類別中 UMLModel子類的實體，如 AnalysisModel 與 DesignModel。 
LowerCASETool 表示低階的 CASE 工具，如整合性的開發環境。LowerCASETool繼
承於 CASETool類別，在 SPACE系統中，延伸的子類別即是有具體功能的低階 CASE工具
如 JBUILDER。而低階 CASE工具產出物即是Workproduct類別中 Sourcecode子類的實體，
如函式庫與可執行檔。 
DocumentationTool 在 SPACE 中，此類別表示用來編輯文件的工具軟體，繼承於
CASETool 類別，DocumentationTool 類別延伸的子類別即是有具體功能的文件編輯工具，
如Microsoft word。而低階 CASE工具產出物即是Workproduct類別中 Document子類的實
體，如MS WORD、Excel檔或文字檔等等。 
4.1.7 SPACE統一超模型 Sub Metamodels之整合 
基礎於 1.1節所描述，SPACE統一超模型能利用 Foundation Metamodel提供的語意，
整合交集 Process Metamodel、Role Metamodel、Tool Metamodel、WorkProduct Metamodel
四個 Sub Metamodels且包含足夠之文法語義以描述軟體開發專案型態、軟體開發組織、軟
體技術領域等各種影響軟體開發之因素，以重新組態適合之軟體開發流程，如圖 17。 
 
圖 17 SPACE統一超模型交集四個 Sub Metamodels之靜態結構圖 
4.1.8 SPACE Unified Metamodel之結構 
我們以基礎於 XUM的 XML表示法，來描述本計劃之 SPACE Unified Metamodel。利
用 XUM 的語義文法的精神，設計了一個連結：Model_Link，用以描述 SPACE Unified 
Metamodel中之四個 Sub Metamodels間的交互參照關係。Model_Link現階段的連結共有三
30 
4.1.9 SPACE Modeling Definition Tool：  
SPACE Modeling Definition Tool是透過 SPACE Unified Metamodel裡的語意文法，來
塑模一個符合使用者需求的 application-specific SPACE Unified Model。根據 SPACE Unified 
Metamodel之組成 Sub Metamodels，SPACE Modeling Definition Tool亦必須擁有 Process 
Model、WorkProduct Model、Role Model與 Tool Model之塑模能力。詳細說明如下： 
Process Modeling：在設計軟體方法流程時，參考Methodology Knowledge Repository
之 Process Activity知識庫，軟體流程工程師能選擇 well-define的 UML-based 之 UP流程活
動(process activity)，並以 UML activity diagram (workflow diagram)來塑模客制化之軟體開發
流程之所有活動(activity)與其之間關聯順序的模型。 
WorkProuct Modeling：支援定義執行軟體開發流程活動後之產出物，並將之與其流程
活動關聯。參考Methodology Knowledge Repository之Work Product知識庫，軟體流程工程
師能選擇 well-define的 UML-based 之 UP 工作產出(work product, UP稱之 Artifacts)。如圖
19。 
 
圖 19 整合工作產出示意圖 
Role Modeling：支援定義負責執行軟體開發流程活動之角色，並將之與其流程活動關
聯。參考 Role/User Repository，軟體流程工程師能選擇 well-define的 UML-based 之 UP 角
色(Role)。如圖 20。 
 
圖 20 整合流程角色示意圖 
32 
以起始 application-specific之流程樣例(process instance)。 
4.2 Process Performing Domain： 
 
圖 22 Process Performing Domain架構圖 
根據軟體開發特性，在此領域中除了存在一般已被大眾所接受的軟體開發流程，也提
供組態工具讓系統開發者能訂立符合特定領域需求的流程，如 Real-time system、Embedded 
system 等等。而開發者除了單純流程制訂外，尚必須根據相關軟體開發週期，選擇各週期
中使用的相關 CASE工具，來輔助開發各步驟的進行。如：Requirement Tool（Drive metric 
socket set[1]、 Joint Deployment Process Owner(JDPO)[2]）、 Analysis & Design Tool
（Solaris[3]、Heap Analysis Tool(HAT)[4]、UML[5]）、Testing Tool（Junit[6]、RHiTech Code[7]）
and Measurement Tool（TestDirector[8]、WinRunner[9]）。同時，其各種產出物(Work Product)
也需被指定，如專案計畫書、系統測試計畫書、需求分析報告、系統設計文件等等。 
由於 Software Developer 對於 CASE Tool 的開發模式的不同，所開發出來的 Work 
Product也不盡相同，我們打算將 SPACE所定義的各項 CASE Tool，導入 Pattern-based的
概念，針對每一個階段，定義出不同的 Pattern讓 Software Developer套用，這樣做的主要
目的，就是讓其他參與的 Software Developer 也能夠很快的進入狀況，此外，導入
Pattern-based的還有一項好處就是，讓成功的設計與架構能夠輕易的被再利用，如此一來，
每一階段的 Work Product 品質便能夠獲得改善，維護的成本也能夠降低。由於 Software 
Developer 所設計出來的 Work Product，都是在 SPACE 所制訂的 Pattern 範疇內，故無論
Software Developer如何開發，其Work Product的 Layout都不會脫離 Pattern之框架，如此
一來，SPACE便可以針對所有用到的 Pattern，作有效率的分類管理並且將相關的開發經驗
記錄下來，往後 Software Developer開發新的系統時，SPACE便能夠根據以往的開發經驗，
34 
有特別選定的其他 Pattern格式，否則，就依照此 Template所提供之 Patterns來套用。 
 
圖 23 SPACE Hierarchy 
這部分主要的研究議題是可分為 1. User interface 2. Processor 3.Connector 如圖 22之標
示。由於 Process Performing Domain 的內容可說是許多 CASE tool的集合，tool set這個模
組負責協調與確保每個 Tool的正常執行。User interface是開發者對本系統的使用介面，開
發者透過它對 CASE tool要求服務與得到結果的呈現。Processor這部份負責控管使用者的
要求與系統其他模組的指令。Connector 即負責處理 Process Performing Domain與 Process 
domain間的互動機制。 
本計劃中 Process Performing Domain的系統功能，是負責處理使用者的操作作業，並
且協調各工具的執行。這部份可分三個層面分別是最上層為 User Interface 、中間的
Processor 與最下層的 Connector 如上圖之標示。以下就針對這三個層面的概念與對於研究
目的的關係做說明。 
4.2.1 PPD User Interface 
  User Interface即使用者操作本系統的介面。使用者透過此介面與 CASE工具互動，
而畫面的格式與資料型態與執行程序等，我們的系統也透過此介面呈現系統資訊。在研究
方向上，我們將研發一個 Tool Metamodel，再透過一Metamodel解譯器解讀並呈現此介面。
我們希望透過這個方式使此介面具有下列特色: 
n 以 XML作為資料描述與結構呈現的標準：我們將以 XML做為我們資料描述與結構的
統一標準，並與我們先前研究的 XUM 理論作為資料間關係定義的方法。我們希望利
用 XML的標準與結構彈性的優點，做為我們資料呈現與運用的系統特色。 
36 
    就PPD Processor的內部概念圖而言(如圖 24)，Software Developer可以利用SPACE
所定義的各項 Case Tool，於軟體開發流程的任一階段開發出該階段的Work Product。譬如
在 Requirement Phase 的 Work Product 包括 Requirements Management Plan、Stakeholder 
Requests、Supplementary Spec.、Requirements Attributes、與 Software Requirements Spec.等。
接著 Software Developer透過 Client/CASE Tool GUI，與 SPACE Client Tool作溝通，SPACE 
Client Tool會將Work Product轉換成 SPACE內定之 XML格式，由於每一份 XML文件，
皆以 XUM之軟體標準整合模型為基礎，故可以達到Work Product之相互串接與再用。 
傳統的 SCM Tool較注重於 Source Code的管理，如版本控制等，或者是僅侷限於單獨
Phase 之間的控管，譬如當系統設計人員變更了某個 Component 的名稱或內部結構，他必
須為新版本與舊版本之間的差異另製作一份說明文件，並存放到 SCM 裡的 Share Space；
然後其他的參與人員也只能經由 SCM Tool得到某份Work Product的變動通知，並到 Share 
Space內讀取說明文件才可得知被異動過的部分。 
而 SPACE將透過 XUM的機制，擴充了 SCM的功能，將各 Phase間的 Work Product
建立連結關係，以達到自動化追蹤的效果，即 SPACE的開發環境具有 Automatic Traceability
的特色。舉例來說，當需求開發人員變更了某份 Software Requirements Spec.文件，SPACE
能追蹤Requirement Phase內其他Work Product是否需要異動；也能利用XUM來追蹤Design 
Phase、Implement Phase、Testing Phase等其他 Phase的Work Product是否需要異動，達到
跨 Phase 管理的效能。而在系統通知其他參與人員前，也可將該參與人員需變動的部分事
先自動地分析出來，無須經由人工的過程另行製作一份說明文件。然後在通知其他的參與
者時，除了發布版本變動的訊息外，也將變動的部分以及該參與者需修該的部分一起提供。
另外，每當 Software Engineer透過各 CASE Tool產生Work Product並 Deliver到 SPACE後，
SPACE會自動 Trace 其他 Phase相關的Work Product(如 Documents或 Source Codes)，並檢
查其一致性，達到完全自動化的效果。 
基礎資訊架構部分(Tool set)，基於本計劃的目標之一:支援 CMMI的流程標準，我們規
劃了 1.協同作業平台 2.專案管理 3.檔案與文件管理 4.流程塑模工具與流程執行引擎 5.軟體
品質衡量工具 五個工具模組，這五個工具模組的說明如下: 
(1) 協同作業 
現今軟體系統的開發多是以許多人共同合作組成的團隊為單位，甚至是開發人員分散
在不同地點的虛擬團隊，因此基礎資訊架構必須能符合現今的開發模式。即基礎資訊架構
需有能處理協同運作的功能，如個人工作空間與平行作業的問題。協同作業模組的目的在
協調與控制同時作業的各項工作能正常運作。 
(2) 專案管理 
專案管理的目的是要掌握專案執行的狀態，以提供管理上決策的必要資訊。而對組織
而言，每個系統或軟體模組的開發都是一個專案，因此基礎資訊架構必須能將專案執行的
狀態回報給組織。此專案管理模組需含專案規劃與專案監控的功能，而這兩個工作項目也
是 CMMI Level 2中的兩個關鍵流程，因此本研究中的基礎資訊架構需有一個具專案規劃與
專案監控的專案管理工具。 
(3) 檔案/文件管理 
38 
心之一，它們都定義了度量使用者（Measure User）的需求。這個階段的活動包括
了「度量資料的匯整與處理」、「利用這些資料來分析個別的資訊需求與資訊需求
如何與相關議題互相關聯（inter-relate）」等。簡言之，就是把「規劃度量」階段
所產生的度量方式，加以執行，最後產生資訊產品供決策者參考。 
由於度量的資料過於龐大，經過匯整與處理不難發現這些度量的資料過於複
雜，想要透過人力去管理必有其缺失之處，因此透過目前相關已經開發完整的軟
體工具為最好的方法，這些工具提供了許多方便使用者度量上所會應用的功能，
但並未對度量後的結果加以整理，因此必須基於這些工具之上，對所度量的結果
加以整理以便在下一各階段的流程可以進行評估之用。 
u 評估度量(Evaluate Measurement)：評估度量乃利用度量技術或分析技術，來評估
「所採用的度量工具」和「度量流程的效能」，它可以幫助度量方式不斷的改善與
更新，也令度量流程更為成熟。 
u 建立基礎建設(Establish and Sustain Commitment)：這個模組主要是提供資源與組
織化的基礎建設（Organizational Infrastructure），用以幫助度量方案的可行性，因
此需要企業資源規劃(Enterprise Resource Planning)的人才來進行此模組的工作，也
就是所謂的 ERP系統，透過 ERP系統所調整出來的資料，可以對組織的資源，包
括人力資源、生產資源等企業顯性或隱性的資源做一個統整，對企業組隻或專案
提供基礎建設。 
u 技術與管理流程(Technical and Management Processes)：雖然這個模組就技術上而
言並非度量的活動之一，但是此模組所牽涉到的步驟卻是不管任何領域、任何專
案，都佔有相當份量的重要性：Configuration/Change Management & Project 
Management，也就是所謂的 CM/PM，專案沒有透過這一步驟的控管，不管在品質
上，或者是進度上的掌控皆難以調度，因此專業的專案管理者(Project Manager)扮
演很重要的角色，且專案管理者在這個階段，定義專案的資訊需求，最後則利用
度量後產生的資訊產品來作決策。 
 
圖 26 SPACE Measurement 與軟體開發流程之互動圖 
在 Process的方面，在各個 phase的部分，每執行完一部份便執行 Measurement，以確
保在度量時的正確性。倘若執行到某一步驟時，發生錯誤，則返回上一步驟再檢查；依舊
還是錯誤的話，在返回上一層在檢差一次。若確定錯誤來源之後，便從發生錯誤的部分重
40 
Performing Domain 之間的協調者和管理者。Process Enactment Domain 接受並解譯經過
Methodology Modeling Domain產出之 application-specific SPACE Unified Model，並根據其
定義，針對不同的流程活動呼叫 Process Performing Domain中相對應之 CASE tools，來輔
助流程活動的執行、促進其協同合作，並根據流程活動之產出物，以決定流程執行的狀態
改變。以下詳細描述 PED之模組定義。 
4.3.1 PED模組 
在WfMC的Workflow Reference Model中，Workflow、Workflow Engine與Workflow 
Enactment Service之定義如下： 
¨ Workflow：利用電腦化的工具來促進商業流程(business process)之自動化運作。 
¨ Workflow Definition：商業流程之電腦格式之呈現(representation)，其中包含操作定義
(manual definition)與工作流程定義(workflow definition)。 
¨ Workflow Engine：提供 workflow instance之 run time執行環境之軟體服務(或概念上來
說：“引擎”)。 
¨ Workflow Enactment Services：由一個以上之 work flow engine組成之軟體服務(software 
service)，以建立、管理及執行 work flow樣例(instances)。應用程式可以透過 workflow 
application programming interface (WAPI)來與 workflow enactment services接合。 
同樣地在本計畫 SPACE 中，我們可以將 SPACE 之 Workflow、Workflow Engine 與
Process Enactment Service定義如下： 
¨ Workflow：利用電腦化的工具來促進軟體流程(software process)之自動化運作。 
¨ Software Methodology Definition：軟體方法流程之電腦格式之呈現，且其中包含軟體
流程定義(process definition)、工作產出定義(work product definition)、角色定義(role 
definition)與輔助工具定義(tool definition)。 
¨ Workflow Engine：提供 process instance之 run time執行環境之軟體服務(“引擎”)。 
¨ Process Enactment Service：由一個 work flow engine組成之軟體服務，以建立、管理及
執行 SPACE work flow樣例。CASE tools可以透過 SPACE CASE tools programming 
interface (SCPI)來與 process enactment service接合 
¨ 流程生命週期(Process Lifecycle)：如圖 28所示，有五種狀態改變。 
1. 初始(initiated)－建立流程樣例(process instance)，包含關聯之流程狀態及相關資
料，但是流程仍尚未滿足開始執行的狀態條件。 
2. 執行(running)－Process instance開始執行，且啟動滿足開始狀態之流程活動。 
3. 暫停中(suspended)－Process instance進入靜止狀態且沒有流程活動被執行，直到流
程重返active狀態。  
4. 完成(completed)－Process instance已經滿足了所有完成之條件，並結束此process 
instance。所有流程運作之內部資料都被記錄下來，以作為日後之審核或統計資料。 
42 
地管理流程樣例(process instance)，使軟體開發流程的步驟能嚴格遵守流程定義，使相關活
動皆能在制度之下，協同合作地來執行，能確保開發品質與軟體品質，以滿足客戶需求，
提升軟體產業之競爭力。 
 
圖 29 SPACE軟體代理人系統架構圖 
4.4 SPACE Agent System 
SPACE基礎於 FIPA Agent Management Reference Model，預計使用智慧型軟體代理人
的技術來實作 PED之Workflow Engine與 PPD之 CASE tools間的互動機制。本計劃捨棄一
般以網路 soket機制而取智慧型軟體代理人之技術有兩個主要原因： 
1. Agent具有智慧： 如 PED章節所述，流程的執行進程取決於流程狀態之改變，而
此狀態改變的條件判斷是依據以工作產出(work product)為基礎之規則子句(rule 
clauses)。智慧型軟體代理人具有一定程度的智慧，能將蒐集的資料轉換為正規格
式的知識實體(ontology)，並根據外界賦予之責任(即規則子句)，推論反應適當之
行為。如此可以大幅降低流程引擎之計算負載，並將傳統之集中式控制改進為分
散式控制，使其具有能動態改變流程狀態的條件判斷之背景能力。 
2. Agent 具有移動性： 工作流程是由許多具順序性之活動執行所組成，Agent 的移
動性能取代傳統工作流程系統集中式資料庫管理，而將結束之活動與下一步活動
之間狀態改變的動作與流程相關資料之帶出帶入的動作，交由行動式代理人來實
行。因此，運用行動式代理人之技術能簡化工作流程系統的實作步驟，且更自然
地貼近工作流程的本質意義。 
如圖 29所示，SPACE之 agent based流程互動機制是分由兩個智慧型代理人平台之機
能來完成：Process Enactment Agent Platform與 Process Execution Agent Platform。 
 
44 
存取。 
4.4.3 動態調整軟體方法之支援 
在大部分之情況下，在流程執行過程中因為專案需求不斷改變，軟體方法亦必須即時
隨之調整。應用了 Design Patterns 之 Chains of Responsibilities 之設計概念，並根據
Master/Slave之責任獨立的自然特性，智慧型軟體代理人 PEn Agnet能動態地增加或修改軟
體流程控制的規則子句，反應於流程執行時期變動之軟體方法，改變其流程執行責任；而
PEx Agent自然也因為對應指令的改變而調整其協調合作行為，進而改變流程活動之執行。 
 
圖 30 Chain of Responsibility示意圖 
舉例來說(如圖 30)，即使流程已執行至 Activity 2，由於需求改變故必須調整原本之軟
體方法定義：將 Activity 3修改為 Activity 3’，並增加 Activity 5。由於 PEn Agent之流程控
制規則子句應用了 Chains of Responsibilities之設計概念而具有彈性、延伸性與低偶合性，
因此可以改變原本賦予 PEn Agent 之責任，且維持其完整性。PEn Agent 根據調整過後之
Activity 3’之規則子句下達合適之指令于 PEx Agent，繼續流程活動之協調執行，直至完成
Activity 4與 Activity 5，此流程樣例即可宣告執行結束且遵循調整後之軟體方法定義，完成
動態調整軟體方法之支援。 
4.4.4 SPACE 支援 CMMI 
表 4 SPACE支援 CMMI Level 2 
The process areas at maturity Level 2 in CMMI SPACE 
需求管理(Requirements Management) Requirement function 
Analysis Tool 
專案規劃(Project Planning) Requirement function 
Analysis Tool 
Measurement Tool 
專案監控(Project Monitoring and Control) PED 
供應商協議管理(Supplier Agreement Management) PSM 
度量與分析(Measurement and Analysis) PSM 
Analysis Tool 
Measurement Tool 
流程與產品品質保證(Process and Product Quality 
Assurance) 
Manual 
Measurement Tool 
Testing Tool 
46 
在本計畫中，面臨 CMMI Level 3 的各項標準，依然以 SPACE整個大架構來分析處理，
預期能夠支援到 CMMI Level 3的標準需求。 
表 5 SPACE支援 CMMI Level 3 
The process areas at maturity Level 3 in CMMI SPACE 
需求發展(Requirement Development produces) Requirement function 
Analysis Tool 
技術解決方案(Technical Solution) PSM 
Design Tool 
Testing Tool 
產品整合(Product Integration) SCM 
驗證(Verification) Testing tool 
確認(Validation) Testing tool 
組織流程專注(Organizational Process Focus) Unified Model 
組織流程定義(Organizational Process Definition) Workflow Engine 
組織訓練(Organizational Training) Manual 
Requirement function 
Measurement Tool 
整合的專案管理(Integrated Project Management) SCM 
風險管理(Risk Management) Requirement function 
Analysis Tool 
Testing tool 
決策分析與解決方案 (Decision Analysis and 
Resolute) 
Analysis & Design 
function 
適於整合之組織環境(Organization Environment for 
Integration) 
SPACE 
整合團隊合作(Integrated Teaming) SCM 
 透過 SPACE 所整合 Requirement Tools 之後所得到 Requirement function 與 Analysis 
Tool，可以針對需求所提供客戶與產品相關的需求與詳細分析，並同時預期到風險的評估。
界定出風險發生前的潛在問題，在開發期間能詳細規劃風險處理，以降低不利的衝擊，將
損害降到最低，以確保利益不至於遭受到太大的損害為預期目標。其理念與 CMMI Level 3 
中需求發展 (Requirement Development produces)中的發展客戶需求 (Develop Customer 
Requirements)、發展產品需求(Develop Product Requirements)與分析及確認需求(Analyze and 
Validate Requirements)；適於整合之組織環境(Organization Environment for Integration)中的
提供 IPPD之基礎環境(Provide IPPD Infrastructure)與管理人員以利整合(Manage People for 
Integation)；風險管理 (Risk Management)中的風險管理之準備 (Prepare for Risk 
Management)、界定並分析風險(Identify and Analyze Risks)與降低風險(Mitigate Risks)，相互
支援。 
PSM 則提供了技術與管理流程(Technical and Management Processes)的功能，用以發
展、設計與實作對於需求的解決方案。支援 CMMI Level 3 中的技術解決方案(Technical 
Solution)中的選擇產品組件解決方案 (Select Product Component Solutions)。發展設計
(Develop the Design)與實作產品設計(Implement the Product Design)部分，則可以再藉由
48 
組織流程績效(Organizational Process Performance) PSM 
數量化專案管理(Quantitative Project Management) PSM 
在本計畫中，透過 SPACE 所涵蓋 PSM，以達到建立並維護對組織標準流程績效的數
量化瞭解，提供流程績效資料、基準及模式，以便以數量化的方式管理組織的專案。 
針對 CMMI Level 4成熟度模式之數量化管理技術，進行先期的研究，收集與分析國內
外 CMMI數量化管理相關技術、方法與工具，並提出數量化管理流程的做法與建議之研究
報告，作為後續 CMMI導入指引研發之基礎，以改善國內軟體業的管理以及有效提升軟體
開發的品質。 
在執行度量動作之前，針對不同的軟體專案規模進行分級流程，根據專案規模分級流
程的結果，度量處理流程會根據此結果，回應適當的度量指標模組，以配合不同的需求來
實施不同的度量，避免過多的度量成本。 
我們的觀點認為，首先，每個衡量專案的度量指標必須要夠完善，並具有實質的效用
性。第二，在進入度量流程（Measurement Process）前，必須先將所欲度量的專案進行分
級。原因乃就台灣企業生態而言，不但企業種類繁多，而且大小不一，因此企業所從事的
專案規模也有相當的差異性。當專案分級後，在依據其規格，採用合適的度量指標，以求
實現精準的度量成果。而專案的分級，則可以依據下列幾項要素來加以考量： 
(1)人力資源：一個專案基本上所需要的人力包括了專案經理、專案監製、專案領導、
高級分析師、系統分析師、系統設計師、程式設計師、高級管理師、資
料庫管理師、硬體工程師、測試工程師、網路工程師、文件管理職員、
以及其他的助理職員等等，每項分類可能不只一位人員，因此人力乃是
評估專案規模的一項重要因素。 
(2)財務資本：一個專案基本上需要硬體成本（譬如電腦、網路、電話、印表機、傳真
機、以及其他耗材等）、軟體成本（譬如人工薪資、開發工具、應用軟
體等）、作業成本（譬如電話費、傳真費、出差費等）。因此，財務資本
乃是評估專案規模的一項重要因素。 
(3)開發時間：一個專案基本上可以分成商業邏輯分析、商業需求分析、商業流程設計、
系統需求分析、系統設計、系統開發、系統實作、系統測試、系統上線、
系統維護等階段，隨著專案類型、開發環境、人力財務等差異，各階段
所需的排程也會有所改變。因此，開發時間乃是評估專案規模的一項重
要因素。 
由以上分析可預見，SPACE所整合的效果，可以支援並滿足 CMMI Level 4 中所要求
達到工作項目(特定執行方法)與預期行為(特定目標)的標準。  
表 7 SPACE支援 CMMI Level 5 
The process areas at maturity Level 5 in CMMI SPACE 
組織創新與推展(Organizational Innovation and Deployment) Manual 
MMD 
Analysis Tool 
原因分析與解決方案(Causal Analysis and Resolution) Manual 
50 
5 結論 
本計劃之 SPACE由三個領域設計組成，Methodology Modeling Domain (MMD)、Process 
Enactment Domain (PED) 與Process Performing Domain (PPD)。MMD之核心：SPACE Unified 
Model，基礎於 XUM與 OMG之 Software Process Engineering Metamodel之設計，由流程模
型、工作產出模型、角色模型與輔助工具模型等四個 sub models 整合交集而成，提供了
SPACE在塑模軟體開發流程所需之超模型元素與其之間的關聯語義文法。本計劃並預計設
計一 Process Modeling Tool用來塑模、定義一個合乎 SPACE統一超模型之語意文法之客制
化之 SPACE Unified Model。MMD之設計概念滿足了本計劃第一點中心思想。 
PED 在 SPACE 中扮演 MMD 與 PPD 之間的協調者和管理者。利用 Workflow Engine
的自動化的軟體流程控制，以避免因人為的疏忽使軟體方法定義與實際流程執行產生不一
致的情形。PED之設計概念滿足了本計劃第二點中心思想。PPD負責處理使用者的操作作
業，並根據Workflow Engine之流程控制與工具呼叫(tool invocation)，協調指定之軟體流程
工具以輔助開發人員之流程執行。PPD之設計概念滿足了本計劃第三點中心思想。 
本計劃之 SPACE結合了MMD、PED與 PPD，提供一整合軟體方法、技術與軟體流程
工具之環境，除了支援流程重組態、客制化，並支援Workflow之流程自動化概念，應用智
慧型代理人之技術來協調軟體流程工具之使用，以促進開發人員之合作，使軟體方法定義
與實際流程執行具有一致性，確保流程品質與產品品質。 
 
52 
[18] Wooldridge, M. J. & Jennings, N. R., “Intelligent Agents,” Springer-Verlag, 1995. 
[19] Luck, M. and M. d’Inverno, “A formal framework for agency and autonomy,” In 
Proceedings of the First International Conference on Multi-Agent Systems, pp254-260. 
[20] Rao, A.S., Georgeff, M.P., “BDI agent: from theory to practice,” Proceedings of the first 
international conference on Multi-Agent-Systems(ICMAS), 1995. 
[21] Turban, E. and Aronson, J., “Decision Support Systems and Intelligent Systems,” NJ: 
Prentice-Hall, 1998. 
[22] Haverkamp, D. S. and Gauch, S. “Intelligent Information Agents: Review and challenges 
for Distributed Information Sources,” Journal of American Society for Information Science, 
49(4), 1998, pp.304-311. 
[23] David Kinny, “Reliable Agent Communication-A Pragmatic Perpective”, Department of 
Computer Science, University of Melbourne, 1999. 
[24] Brian Henderson-Sellers, Tony Simons, and Houman Younessi. The OPEN Toolbox of 
Techniques Addison-Wesley, September 1998. 
[25] Ian Graham, Brian Henderson-Sellers, and H.Y., “The OPEN Process Specification," 
Addison-Wesley, 1997. 
[26] B. Henderson-Sellers and I.M. Graham, “OPEN: Towards Method Convergence,” IEEE 
Computer, Volume 29 number 4, IEEE Computer Society, Los Alamitos, CA, USA, 
pp.86-89. 
[27] B. Henderson-Sellers, I.M. Graham, D. Firesmith, “Manuscript: ROAD966.TEX,” 
Knowledge Systems Corporation, Cary, NC, USA Printed: September 28, 1998. 
[28] B. Henderson-Sellers, “The OPEN Mentor Methodology”, Printed: September 28, 1998. 
[29] B. Henderson-Sellers, “OPEN: Object-oriented Process, Environment and Notation The. 
fist full lifecycle, third generation OO method,” Chapter for Handbook of Object 
Technology. 
[30] B. Henderson-Sellers, H. Younessi, and I. Graham, “The OPEN Process (Tasks, Techniques 
and Management)”, Chapter for Handbook of Object Technology. 
[31] “The OPEN alternative”, Object Expert, Volume 2 part 1, pp 14-15,1996. 
[32] Available http://www.markv.com/OPEN/ 
[33] “Rational Unified Process”Available http://www.rational.com/rup/ 
[34] Philippe Kruchten, “The Rational Unified Process -- An Introduction,” 2nd ed., 
Addison-Wesley-Longman, Reading, MA (2000). 
[35] Grady Booch et al., “UML Users' Guide,” Addison-Wesley-Longman, Reading, MA (2000). 
[36] Ivar Jacobson et al., “The Unified Software Development Process,” 
Addison-Wesley-Longman, Reading, MA (1999). 
[37] “What is the Rational Unified Process?”Available 
http://www.therationaledge.com/content/jan_01/f_rup_pk.html 
[38] “The Rational Unified Process”Available http://ootips.org/rup.html 
[39] “Extreme Programming Roadmap”Available 
http://c2.com/cgi/wiki?ExtremeProgrammingRoadmap. 
[40] “Extreme Programming”Available 
http://www.objectmentor.com/processImprovement/index 
[41]  “Extreme Programming”Available http://www.industriallogic.com/xp/ 
54 
[69] Steven P. Reiss , “The Desert environment”, ACM Transactions on Software Engineering 
and Methodology, Vol. 8, No. 4, October 1999, Pages 297–342. 
[70] Harri Oinas-Kukkonen, “Flexible CASE and hypertext”, ACM Computing Surveys (CSUR) 
December 1999. 
[71] Junichi Suzuki and Yoshikazu Yamamoto, "Managing the Software Design Documents with 
XML", Proceedings of the Sixteenth Annual International Conference of Computer 
Documentation (ACM SIGDOC '98), pp. 127-136, 1998. 
[72] Scott Henninger, “Case-Based Knowledge Management Tools for Software Development”, 
Automated Software Engineering 4 (3), pp.319-340. 
[73] David Kung , Jerry Gao , Pei Hsia , Yasufumi Toyoshima , Chris Chen , Young-Si Kim , 
and Young-Kee Song, “Developing an object-oriented software testing and maintenance 
environment,” Communications of the ACM October 1995  
[74] Matthews, E., and Burns, G., "VADS APSE: An Integrated Ada Programming Support 
Environment", Proceedings of the First Symposium on Environments and Tools for Ada, 
Redondo Beach, CA, 1990. 
[75] Charles Plesums, Computer Sciences Corporation, and Financial Services Group, “An 
Introduction to Workflow”, extracted from the Workflow Handbook 2002. 
[76] “Workflow Process Definition Interface -- XML Process Definition Language,” Document 
Number WFMC-TC-1025, Document Status –1.0 Final Draft, 2002. 
[77] “Workflow Management Coalition Workflow Client Application (Interface 2) Application 
Programming Interface (WAPI) Naming Conventions,” Document Number 
WFMC-TC-1013, 01-November-97. 
[78] “Workflow Management Coalition Workflow Standard – Interoperability Wf-XML 
Binding,” Document Number WFMC-TC-1023, Document Status – Final Draft, 
14-November-2001. (Version 1.1) 
[79] “Interworkflow Application Model: The Design of Cross-Organizational Workflow 
Processes and Distributed Operations Management,” Groupware Technical Sub 
Committee1, The Japanese Standards Association, Submitted to WfMC as: Document 
WFMC-TC-2102 Feb 97. 
[80] David Hollingsworth, “The Workflow Reference Model,” Document Number TC00-1003, 
Document Status - Issue 1.1, 19-Jan-95. 
[81] “The ISO Survey of ISO 9000 and ISO 14000 Certificates,” Tenth cycle: up to and 
including 31 December 2000. 
[82] ISO 9000-3 and EssentialSET for Software Development.Available 
http://www.spc.ca/downloads/products/ISO9000-3.pdf 
[83] “Cross-reference between ISO 9000-3 and ISO 9001 from Annex A in ISO 9000-3,” 
Available to http://www.tarrani.net/linda/docs/cmm9001.pdf 
[84] Walker Royce, “CMM vs. CMMI: From Conventional to Modern Software Management ,” 
Published in The Rational Edge.Available 
http://www.therationaledge.com/content/feb_02/f_conventionalToModern_wr.jsp 
[85] Len Bass and Bonnie E. John, “Supporting the CANCEL Command Through Software 
Architecture ,” CMU/SEI-2002-TN-021, 2002. 
[86] Cecilia Albert and Lisa Brownsword, “Evolutionary Process for Integrating COTS-Based 
56 
7 近五年已發表之相關論文、期刊 
[1] C.W. Chu, C. H. Chang, C.W. Lu, H. Yang, H.C. Jiau, Y.C. Chung, and B. Qiao, 
"Enhancing software maintainability by unifying and integrating standards," Advances in 
Software Maintenance Management: Technologies and Solutions, Idea Group Publishing: 
Hershey PA. 2003, pp. 114-150. 
[2] C.W. Lu, C.W. Chu, C.H. Chang, W.D. Lian, Y.C. Chung, “Integrating Divers Paradigms 
in Evolution and Maintenance by an XML-based Unified Model,”  Journal of Software 
Maintenance and Evolution. 
[3] C.W. Chu, et. al , “The Integrated COmprehensive Reverse Reuse Engineering Coversion 
Tools (CORRECT),” Journal of Engineering Science and Technology Bulletin Vol.60, 
2002, pp 66-69. 
[4] C.W. Chu, et al., “Design Pattern-Based N-tier Architecture for E-Commerce Systems,” 
Journal of Internet Technology, Vol. 2, No. 1, 2001, pp. 81-89. 
[5] C.W. Chu, et. al., “UMPAL: An Unstructured Mesh Partitioner and Load Balancer on 
World Wide Web,” Journal of Information Science and Engineering Vol. 7, No. 4, 2001. 
[6] Y. Li, H. Yang, C.W. Chu, “Information Elicitation from Software Code,” Handbook of 
Software Engineering and Knowledge Engineering, World Scientific Publishing, USA, 
2002. 
[7] C.W. Chu, C.W. Lu, C. H. Chang, and Y.C. Chung, “Reverse Engineering,” Handbook of 
Software Engineering and Knowledge Engineering, World Scientific Publishing, 2002. 
[8] Y. Li, H. Yang, and C.W. Chu, “A concept-oriented belief revision approach to domain 
knowledge recovery from source code,” Journal of Software Maintenance, Vol. 13, No. 1, 
2001. 
[9] C.W. Chu, C.W. Lu, C. H. Chang, and Y.C. Chung, “Pattern Based Software 
Re-engineering,” Handbook of Software Engineering and Knowledge Engineering, Worl 
Scientific Publishing, 2001. 
[10] C.W. Chu, C. W. Lu, C. P. Shiu, X. He, “Pattern-based Software Reengineering: A Case 
Study,” Journal of Software Maintenance, Vol 12, No. 2 , 2000, pp. 121-141. 
[11] C.W. Chu, C.W. Lu, C.H. Chang, Y.C. Ching and Y.M. Huang, “Software Maintainability 
Improvement: Integrating Standards and Models,” In Proceedings of 2002 Internal 
Computer Symposium (ICS2002), 2002. 
 
論，並且瞭解這些專家學者所做的相關研究後，也對我們的研究上有莫大的幫
助。此外 software applications的相關應用研究，在這一次的會議中提出了許多新
奇的觀點與看法，尤其是 testing on we-baseapplication的研究成果最令眾多學者
稱奇，也使我們這次的收穫更豐富更多元。 
三、建議 
 主辦單位舉辦的會議至今已有 20多年之久，過程總是謹慎細心，尤其對論
文品質的控管嚴格更是不在話下，實在是國內單位所要學習的對象。而參加國際
會議的研究人員乃是會議的主角，不僅對於自己的研究也對整個科學領域能有最
新且深入的學習，因此建議多鼓勵研究人員參加會議，並有助於開拓國際視野。 
四、攜回資料名稱及內容 
攜回 COMPSAC 2006的 PROCEEDING一本，書中含有所有在會議中發表
的文章全文。 
五、其他  
個人非常感謝國科會提供補助，使得次此會議得以成行。也使得個人對 
於軟體工程在 Quality以及 Testing方面的發展及研究有進一步的認知。 
 
  
2. Background 
 
2.1 Software Model 
 
The term “model” is used in many contexts and often 
has different meanings. Generally, a model can mean an 
abstraction and representation of the important factors of a 
complex reality, which is different from the thing it 
models, yet has the same main characteristics as the 
original. With a model, people can build up an 
understanding to the point where it is natural to answer a 
question by modelling it into some simpler context, 
answering the question with the model, and then 
interpreting the answer [14]. Models help people by 
letting them work at a higher level of abstraction. A model 
may hide or mask details and bring out the big picture. 
A model plays the analogous role in software 
development. Creating a model of a system is a useful 
way to understand a system. Software modelling is an 
essential part of large complex software projects. Software 
modelling assumes that abstract models convey 
information more effectively than source code. People 
should use abstract models to enhance their understanding 
of a system and to provide a common base for others to 
discuss it [21]. A model is always written in a language. 
To enable automatic transformation of a model, the 
language should be well defined, which has a well-defined 
form (syntax) and meaning (semantics) that can be 
interpreted automatically by a computer [6].  
 
2.2 UML, MOF and XMI 
 
Unified Modelling Language (UML) has become the 
worldwide de facto standard for the visualisation and the 
modelling of complex object-oriented and component 
based systems. It has significant tool support and a wide 
spread acceptance to developers, software architects and 
engineers. Rumbaugh et al [17] identifies three viewpoints 
necessary for understanding a software system: the objects 
manipulated by the computation (the data model), the 
manipulations themselves (functional model), and how the 
manipulations are organised and synchronised (the 
dynamic model). UML, through its various UML 
diagrams, encompasses all of Rumbaugh’s views.  
According to the UML Specification, the UML is 
actually an instance of the MOF (Meta Object Facility) 
meta-metamodel. The MOF defines a set of interfaces, 
which can be used to define different interoperable 
metamodels (including the UML metamodel). A 
metamodel is in fact an abstract language for some kinds 
of metadata.  
In order to enable the developers to achieve the same 
understanding and interpretation of the model when this 
model is exchanged among different technologies and 
tools, some sorts of common model exchange format are 
needed. XMI is an XML standard for exchanging UML 
models. 
 
2.3 Model Driven Architecture 
 
OMG’s Model Driven Architecture (MDA) intends to 
achieve language, vendor and middleware neutral 
software development. MDA focuses on various models 
existing in different phases of software development. A 
model could be a Computation Independent Model (CIM) 
or a Computational Model (CM). Both of them describe a 
system in a logic way. The former, also known as 
requirement model, does not involve technical factors, 
while the latter does. The computational model in MDA 
presents its most distinguishing features which exist in 
two forms: Platform Independent Model (PIM) or 
Platform Specific Model (PSM). PIM and PSM could be 
written in any formal languages that make them 
understandable by both human and machines. A series of 
PIM and PSM models construct a hierarchy of abstract 
levels. MDA models at different abstract levels can be 
transformed automatically to each other according to 
transformation rules. 
 
 
Design Business Logic
PIM
Map onto Implementation TechnologyPSM
Produce Final System
Code
Define Transformation Rules
Define PIM Meta Model Define PSM Meta Model
PIM2PSM Rules
PSM2Code Rules
 
Figure 1. MDA process 
 
Figure 1 shows the process of applying MDA. 
Transformation is carried out by automatic tools that take 
a PIM as input and produce a specific PSM as output. 
Nowadays MDA is supported by many tools. The 
Arcstyler is a MDA tool [5] which supports the whole 
application life cycle of software development. Arcstyler 
can import existing models that are compliant to XMI or 
create models from existing Java code. Arcstyler used the 
term MDA-Cartridges for the model transformation. 
Arcstyler provides the predefined cartridges for a number 
of technologies and platforms, such as Java, J2EE 
and .NET. Using the cartridge concept one could define 
the transformation rules for a new technology or platform 
 state space 
Remove variables: remove(X) removes the variables in 
X from the state space 
Sequence (S1:S2) executes S1 followed by S2 
Non-deterministic choice: chooses one of S1 or S2 for 
execution, the choice being made non-deterministically 
Recursion – a statement, S1, may contain occurrences 
of X as one or more of its component statements. These 
statements represent recursive calls to the procedure 
whose body is S1. 
 
z Extensions of WSL Kernel Language 
 
By building on the basic constructs of the WSL 
language, extensions to the WSL language include simple 
assignment, deterministic iteration (do-while loops) and 
deterministic choice (if-then) statements along with blocks 
of statements within procedure calls. 
In order to support Object Oriented Technology, the 
WSL kernel language was extended to include such 
constructs as class structure which contains both variables 
(attributes) and procedures (methods or operations).  
 
1. Class Definition 
Class T 
Var  
Ti : xi;  /* Attributes of Class */ 
Proc  
mj(In pinjk:Tk, Out poutjl:T_l)   
/* Methods of Class */ 
Begin 
Aj; /* WSL statements */ 
End. 
End 
This statement is the class building declaration. It 
defines a class named T, which has data fields xi of type 
Ti and methods mj. pinjk stands for the input parameters 
of method mj, and poutjl stands for the output parameters 
of method mj.  
2. Class Hierarchy 
T extends T’ 
This statement is used to build the object hierarchy. It 
declares that class T is a subclass of class T’. Therefore, T 
inherits the properties of T’. 
3. Field Reference 
x.d 
This is object field reference. x is an object, and d is a 
field of x. 
4. Method Invocation 
x.m (In ek, Out yl)  
This invokes the method m in object x. 
5. Object Declaration 
T : x  
This statement defines x as a variable of type T. If T is 
a class, x will be an object of class T. 
 
There are some other extensions of WSL for domain 
specific purpose, e.g. real time applications, which can be 
found in [23, 10]. 
 
z Program Transformation 
 
A program transformation can be defined as a process 
that modifies a program into a different form yet the 
program retains its original external behaviour. The 
purpose of the WSL transformations is to transform a 
program, using mathematically-proven transformations, 
into a more refined or simplified program. By doing so, 
the program’s complexity is reduced with the program’s 
original functionality preserved.  
Martin Ward has utilised program transformations in 
WSL to derive efficient algorithms from abstract 
specifications [18, 19]. One of the focuses of Ward’s work 
is to develop transformations that refine a program’s 
specification, expressed in terms of first order logic and 
set theory, into an efficient algorithm. Transformations are 
used in reverse engineering partially in order to derive of 
concise specifications from program source code [19].   
Once a source program has been translated into WSL, 
the WSL representation may then be input to such tools as 
FermaT transformation system [19] that has the capability 
for program transformations, code reductions, etc of this 
WSL representation. FermaT is an industrial-strength 
reengineering tool, which allows transformations and code 
simplification to be carried out automatically.  
 
3.3 Formal Model Transformation 
 
Model transformation is the equivalent of program 
transformation, but applied to models instead of programs. 
Many of the techniques that are used for program 
transformation can also be applied in the context of model 
transformation [22]. This part explains the technique for 
organising and maintaining legacy system models. It 
shows how to produce several views of a legacy system 
for reduction in model complexity through abstraction. 
From the reverse engineering point of view, 
transformation is a way of abstraction through changing 
the abstract level of a processed model, providing multiple 
levels of abstraction for every type of components. Model 
transformation focuses on high level modelling 
components while program transformation can still be 
used for low level source code transformation.  
Put in the MDA context, reverse engineering technique 
is designed for PSLs, not numerous programming 
languages. All kinds of software systems for reverse 
engineering will be translated into one PSL and be tackled 
by one set of reverse engineering techniques as long as 
these systems are implemented on a same platform. As the 
number of platform technologies is much less than that of 
 appropriate visibility. 
 Sequence Folding Abstraction Rule shows that if 
no contradiction is caused when substituting the 
sequential relation between two entities to 
conjunction relation, then the sequence of entities 
can be folded through conjunction. 
 
The following abstraction rules are used to simplify 
relationships. Interconnections between procedures, 
modules/objects and components that are judged as 
irrelevant will be abstracted or hidden in the model 
representation.  
 Primitive Component Rule:  Initial component is 
defined as primitive component, which can be source 
file, program module and subsystem. 
 Component Composition Rule: Component 
composition is to combine two components when 
they have direct connectors, such as procedure call or 
shared variable, may be combined into one 
component. 
 Trivial Component Rule: If a part of the 
system’s functionality is considered too “trivial” to 
be kept in high level abstraction, the components 
related to this part of functionality are identified as 
“trivial components”, which should be abstracted 
away in architecture abstraction. 
 Primitive Relationship Rule: Initial 
connector is defined as direct connector which can 
be shared resources, function or procedure call, inter-
process call, etc. 
 Relationship Composition Rule: to combine 
two connectors connecting the same component set 
into one connector. 
 Trivial Relationship Rule: If all the components 
connecting to a connector are trivial components, 
this connector is considered trivial connector and 
should be abstracted away in architecture abstraction. 
 
z Translation between WSL and PSL 
 
Ideally, a PSL should be the same language used to 
write a Specification Extraction rule. This could improve 
the consistency of modelling and facilitate the 
implementation of automatic tools. However, OCL itself 
is not a programming language, but a declarative language, 
which states what actions to perform, instead of how. A 
language consisting of programming constructs is still 
required for PSL. WSL is a suitable choice which can be 
used as part of PSL.  
Mapping from WSL to PSL and from PSL to WSL 
needs translation rules: (1) the translation between WSL 
constructs and PSL defined in OCL; (2) the translation of 
primitives and operators between WSL and PSL, or (3) 
the translation between WSL compound statements and 
PSL. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Figure 5. Translation between WSL class and 
PSL class 
 
Figure 5 shows a translation between WSL Class and 
PSL Class. A translation rule is defined to translate WSL 
class into PSL class, which denotes that: 
 A PSL class consists of attributes and operations. 
 Every WSL class is translated into a PSL class. 
 Every operation in the WSL class is translated into 
an operation in PSL class. 
 Every attribute (private, protected, or public) of the 
WSL class is translated into an attribute in the PSL 
class with the identical visibility. 
In this way, PSL is used to define the counterparts of 
other WSL constructs, such as “interface” and “exception”, 
and the corresponding translation rules. 
 
z Mathematical Model 
 
When the PSL is translated into WSL file, we have an 
optional way to establish a mathematical model instance.  
A mathematical model M [3] is a quadruple (T, C, F, A) 
where T is a finite universe of objects, C is a constants 
chosen from T, F is a finite set of functions and A is some 
constraints in equations. An important advantage of 
mathematical model is to have a standardised way of 
checking out answers to questions like [14]: 
 TYPE: What kind of objects is involved? 
 CONSTANTS: What special values are important? 
 FUNCTIONS: How are objects of each kind created 
and used? 
 ASSERTIONS: What facts can I really count on? 
General rules are needed. This is the hardest part. 
In [10], WSL, together with the abstraction and object 
extraction rules were defined in Interval Temporal Logic 
(ITL) [12], which can be interpreted in M.  
 
 
context PSL::Class 
def: 
   attributes() = feature->select(isTypeOf(Attribute)); 
   operations() = feature->select(isTypeOf(Operation)); 
 
Translation Class2Class (WSL, PSL) { 
   sources 
        c1: WSL::Class; 
   targets 
        c2: PSL::Class; 
   source invariant true; 
   target invariant true; 
   mappings 
        c1.attributes()<=> c2.attributes(); 
        c1.operations()<=> c2.operations(); 
} 
