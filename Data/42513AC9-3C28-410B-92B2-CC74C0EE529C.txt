I行政院國家科學委員會專題研究計畫成果報告
計劃名稱: 全域性計算環境下金鑰管理與隱私保護之研究
中文摘要
全域性安全服務上，目前較受注目的有金鑰管理、認證與隱私保護。而目
前提供的大部分解決方案，尚不是非常完善，是以國內外許多學者目前皆致力研
究提供更加方便，安全與有效率的安全機制。為了使得全域性計算環境下使用者
認證與金鑰協商機制更有效率、延展性與彈性，下列的幾點標準是非常重要的：
(1) 一個安全領域可以被動態的形成而且使用者可以在任何時間加入這一個安
全的領域; (2) 一個使用者只需要向一領域所管轄的安全控制器註冊一次並且可
以使用動態加入的伺服器所提供的所有服務; (3) 使用者可以隨意的選擇和改變
他的密碼來保護它的安全裝置，像是智慧卡等，或將密碼取消以適合全域式環境
下不可視（invisibility）的特性; (4) 因為無線通訊與容量的限制，所以這些裝置
不能提供強大的運算能力和較高的頻寬; (5) 伺服器與使用者之間可以彼此認證
對方; (6) 使用者必須與伺服器協調產生出一把交談金鑰來保護接下來的通訊;(7)
全域性計算環境下，因參與者動態加入，不容易提供同步時鐘。在本計劃中，我
們研究兼具彈性、效率性與安全性的各類型全域性計算環境下安全與隱私機制。
由我們的計劃，我們已在全域性計算環境上對各類型安全與隱私機制提供一組最
佳解決方案。
關鍵詞：金錀分配、全域性計算、網路安全
III
目錄
頁數
中文摘要 I
英文摘要 (Abstract) II
一、前言 1
二、研究目的 3
三、文獻探討 5
四、研究方法 7
五、結果與討論 9
參考文獻 11
計劃成果自評 14
附錄（一）可供推廣之研發成果資料表 15
附錄（二）出席國際會議與發表論文心得報告 18
附錄（三）已發表之論文 27
2便，安全的服務。另外隨著半導體製成的進步與製造成本的降低，全域性應用所
需要的資訊設備也降到可大量商業化的情形。可預知這方面的安全整合應用將是
現在與未來相當熱門的主題。
而隨著安全協定之正規安全證明的更加成熟，目前已有相當多技巧可以用來
證明設計出來的安全協定 [6] ，其主要可分為計算複雜度上的分析方式與電腦
安全的驗證方式。計算複雜度上的方式主要又分為隨機神喻模型與非隨機神喻模
型兩種。電腦安全的驗證方式則有基於信念邏輯，基於過程代數及基於狀態機三
類方法。同樣的全域性環境下之安全協定也需要正規的安全分析，以防止可能的
攻擊。
4與需保護的儲存的記憶體空間且必須有一有效的方法來管理金鑰。另外成員所需
儲存的金鑰數量也同時影響其執行的效率與需保護的儲存的記憶體空間。
由前述所知，金鑰管理，使用者認證與隱私保護在全域性計算環境中是非常
重要的一環。而本計劃的研究目的，即是利用密碼學的相關技巧與方法，來設計
兼具彈性、效率性與安全性的各類型全域性計算環境下安全與隱私機制，使其能
夠克服通訊本身安全的問題，讓全域性計算環境成為一種完整、安全、方便、有
效率而且可行的處理模式。
首先，我們將於本計畫中先收集目前國內外有關全域性計算環境下使用者認
證與金鑰協商之研究，藉以設計出同時滿足上述七項標準兼具彈性、效率性與安
全性的各類型全域性計算環境下安全與隱私機制。另外目前已經有很多業者提供
Smart Cards 來設計出卡片式通訊上之安全整合服務 [10, 11]。我們將研究與實作
如何使用目前 Smart Cards 來設計我們的兼具彈性、效率性與安全性的各類型全
域性計算環境下金鑰分配與認證機制。藉由此計畫之實施，相信兼具彈性、效率
性與安全性的全域性計算環境下安全與隱私機制提供更多之選擇。相信其將為現
今與未來兼具彈性、效率性與安全性的全域性計算環境下安全與隱私機制提供一
最佳參考範例。另可藉由此研究，訓練研究生發展兼具彈性、效率性與安全性的
各類型全域性計算環境下安全與隱私機制之能力，以及認識目前 Smart Cards [10,
11] 服務基本架構與可提供之安全服務。
在本計劃中，我們目的是要研究兼具彈性、效率性與安全性的各類型全域性
計算環境下安全與隱私機制。我們計畫能設計滿足上述的七項標準的全域性計算
環境下使用者認證與金鑰協商機制。由於隱私保護越來越受重視，我們也另外再
設計全域性計算環境下提供隱私保護之使用者認證與金鑰協商機制。由我們的計
劃，我們對全域性計算環境下安全的金錀分配方案，使用者認證與隱私保護提供
一組最佳的解決方案。
6系統經過適當的保護可避免資訊不當的洩露，確保個人資訊的安全存取，並減輕
使用者對於隱私侵害的疑慮，吸引使用者使用安全服務。更強的隱私保護機制還
包含需防流量分析的攻擊。藉由流量分析的攻擊，即使攻擊者不知使用者身份為
何，但卻可知道交易間的連結，而導出之間的關係。
另外隨著正規安全證明的更加成熟，目前已有相當多的工具可以證明設計出
來的安全協定 [6]。目前安全協定的正規安全分析可分為計算複雜度上的分析方
式與電腦安全的驗證方式。計算複雜度上的方式常見又可歸類為隨機神喻模型與
非隨機神喻模型兩種。電腦安全的驗證方式則可歸類有基於信念邏輯，基於過程
代數及基於狀態機三類方法。安全協定設計好後，使用一廣為接受的正規安全分
析已經是一基本的要求。
83. 使用者認證與金鑰協商階段：此階段使用者間可互相認證與協商一交談金
鑰 (session key)。
圖一為我們的初步全域性計算環境下安全服務架構圖。每位使用者只需到所轄安
全管理中心 (SC) 註冊一次領取主鑰匙 (master key), 之後使用者便不需與註冊
中心做溝通。
藉由本計劃的實施，我們已對目前全域性金鑰的分配與隱私之機制有具體的
研究成果。
SC 1
SC i
SC j
Routed Protocols
A
B
C
D
H
E
F
G
: Security Controller
: access Link
: Computation Node
: backbone Link
圖一:全域性計算環境下安全服務架構圖
Internetwork
10
Authentication and Key Agreement Using Bilinear Pairings", The 3rd Joint
Workshop on Information Security, Hanyang University, Seoul, Korea, July
10-11, 2008.
c. W. Juang and J. Wu, “Efficient User Authentication and Key Agreement with
User Privacy Protection,” International Journal of Network Security, Vol. 7, No.
2, pp. 126~135, September 2008.
d. W. Juang and J. Wu, “Efficient 3GPP Authentication and Key Agreement with
Robust User Privacy Protection,” IEEE Wireless Communications and 
Networking Conference (WCNC 2007), Hong Kong, March 2007.
e. J. Wu, W. Juang and S. Chen, “Eficient GSM Authentication and Key 
Agreement Protocols with Robust User Privacy Protection,” International
Workshop on Computer Networks and Wireless Communications (within
ICS’06), pp. 540-545, Taipei, Taiwan, December 2006.
f. H. Liaw and W. Juang, "A High Security Authentication Mechanism for
3G/WLAN Networks", The 3rd Joint Workshop on Information Security,
Hanyang University, Seoul, Korea, July 10-11, 2008.
g. R. Wang, W. Juang, C. Wu, and C. Lei, “A Lightweight Key Agreement 
Protocol with User Anonymity in Ubiquitous Computing Environments,” IEEE 
First International Conference on Multimedia and Ubiquitous Engineering, Seoul,
Korea, April 2007.
12
Authenticated Key Agreement Using Smart Cards,” International Workshop on
Web Technologies and Information Security (within ICS’06), pp. 898-903,
Taipei, Taiwan, December 2006.
17. W. Juang and J. Wu, “Efficient 3GPP Authentication and Key Agreement with
Robust User Privacy Protection,” IEEE Wireless Communications and 
Networking Conference (WCNC 2007), Hong Kong, March 2007.
18. W. Juang and J. Wu, “Efficient User Authentication and Key Agreement with
User Privacy Protection,” International Journal of Network Security, Vol. 7, No.
2, pp. 126~135, September 2008.
19. W. Juang, C. Lei, H. Liaw and W. Nien, "Robust and Efficient Three-party User
Authentication and Key Agreement Using Bilinear Pairings", The 3rd Joint
Workshop on Information Security, Hanyang University, Seoul, Korea, July
10-11, 2008.
20. A. Juels, “RFID Security and Privacy: A research Survey”, 
http://www.rsasecurity.com/rsalabs/staff/bios/ajuels/publications/pdfs/rfid_surve
y_28_0
9_05.pdf.
21. L. Lamport, “Password Authentication with Insecure Communication, 
Communications of the ACM, Vol. 24, pp. 770-772, 1981.
22. A. Lenstra, E. Tromer, A. Shamir, W. Kortsmit, B. Dodson, J. Hughes and P.
Leyland,“Factoring estimates for a 1024-bit RSA modulus,”In Laih, C. (ed.), 
Advances in Cryptology-AsiaCrypt'03, LNCS 2894, pp. 55-74, Springer, New
York, 2003.
23. H. Liaw and W. Juang, "A High Security Authentication Mechanism for
3G/WLAN Networks", The 3rd Joint Workshop on Information Security,
Hanyang University, Seoul, Korea, July 10-11, 2008.
24. R. Merkle, “One way hash functions and DES,”In Brassard, G. (ed.), Advances 
in Cryptology-Crypt'89, LNCS 435, pp. 428-446, Springer, New York, 1989.
25. G. Myles, A. Friday, N. Davies, “Preserving privacy in environments with 
location-based applications,” IEEE pervasive computing, Vol. 2, No. 1, pp. 
56-64, 2003.
26. NIST FIPS PUB 180-2, “Secure Hash Standard,”National Institute of Standards
and Technology, U. S. Department of Commerce, DRAFT, 2004.
27. NIST FIPS PUB 197, “Announcing the Advanced Encryption Standard (AES),” 
National Institute of Standards and Technology, U. S. Department of Commerce,
2001.
28. T. Parikh, “Using mobile phones for secure, distributed document processing in
the developing world,” IEEE pervasive computing, Vol. 4, No. 2, pp. 74-81,
2005.
14
計劃成果自評
1. 研究內容與原計劃相符程度：本研究內容與原申請計劃完全相符。
2. 達成預期目標概要：本計劃已有效設計出安全且彈性的全域性金鑰的分配與
隱私之機制，順利達成目標，並培育出相關的全域性金鑰的分配與隱私之系
統研發人才。
3. 研究成果的學術價值與應用價值：本研究成果兼顧學術與應用層面，可予國
內研究全域性金鑰的分配與隱私保護系統之相關研究機構參考。
4. 適合在學術期刊發表或申請專利：本研究之成果學術部分適合發表於國內外
專業期刊，而應用部分可申請專利。
5. 綜合評估：本研究在國科會給予足夠之經費下，已順利完成，部分成果已發
表於國際知名會議並投稿至國際知名期刊，因此自評為佳。
16
▓ 可申請專利 □可技術移轉 日期：98 年 1 月 12 日
國科會補助計畫
計畫名稱：全域性計算環境下金鑰管理與隱私保護之研究
計畫主持人：莊文勝
計畫編號：NSC 95-2221-E-327 -057 -MY2
學門領域：資訊安全
技術/創作名稱 提供隱私保護的遠端使用者認證與金鑰協商機制
發明人/創作人 莊文勝, 吳靖琳
技術說明
Using smart cards, remote user authentication and key agreement can
be simplified, flexible, and efficient for creating a secure distributed
computers environment. Addition to user authentication and key
distribution, it is very useful for providing identity privacy for users. In
this paper, we propose novel user authentication and key agreement
schemes with privacy protection. We first propose a single-server
scheme and then apply this scheme to a multi-server environment. The
main merits include: (1) the privacy of users can be ensured; (2) a user
can freely choose his own password; (3) the computation and
communication cost is very low; (4) servers and users can authenticate
each other; (5) it generates a session key agreed by the server and the
user; (6) our proposed schemes are nonce-based schemes which does
not have a serious time-synchronization problem.
可利用之產業
及
可開發之產品
安全資訊整合系統
技術特點
同技術說明
推廣及運用的價值
同技術說明
※ 1.每項研發成果請填寫一式二份，一份隨成果報告送繳本會，一份送 貴單位研發
成果推廣單位（如技術移轉中心）。
※ 2.本項研發成果若尚未申請專利，請勿揭露可申請專利之主要內容。
※ 3.本表若不敷使用，請自行影印使用。
18
附錄（二）出席國際會議發表論文之心得報告
1. 出席國際會議 Network & Distributed System Security Symposium,
NDSS’08 (NDSS 2008), San Diego, CA, USA, February 10-13, 2008, 之心
得報告
2. 出席國際會議 The 3rd Joint Workshop on Information Security (JWIS
2008), Seoul, Korea, July 10-11, 2008, 之心得報告
20
際會議之一。會議討論議題涵蓋網路與分散式系統安全理論及實務應用。2008 年
網路與分散式系統安全國際會議以歷史沿革為第十五屆，贊助單位為國際網際網
路學會，為相當有歷史延革的一國際會議。今年此次會議共有一百一十五篇論文
投稿，接受二十一篇，接受率為 18%。主辦單位同時也邀請兩位著名學者專家對
最新的網路與分散式系統安全技術進行專題演講。
本次的研討會主要由國際網際網路學會所贊助，同時也獲得美國國家安全局
（the National Security Agency, NSA）、Google、Afilias、聖地牙哥超級電腦中心、
微軟、Dartmouth 安全科技學院與 IEEE security and privacy magazine 等單位的
贊助。此次參加會議的人數總共 100 人。
貳、 邀請演講與論文發表
本次會議三天議程，共有兩位學者之兩場邀請演講及二十一篇論文發表。整
體觀之，NDSS 會議是以網路與分散式系統安全議題為主軸，內容相當多元。邀
請演講如下：
1. Breaking Online Games, Gary MaGraw, Cigital Inc., USA
2. Security and Usability: Mind the Gap, Paul Van Oorschot, Carleton University,
Canada
所接受論文發表包括大型系統安全、合作系統安全、隱私、軟體安全、反向
工程、入侵偵測、惡意軟體等。以下簡述邀請演講及部分論文發表內容。
第一場邀請演講題目為“Breaking Online Games”。講者為在Cigital Inc. 擔
任CTO 的 Gary MaGraw 博士。MaGraw 博士公認為軟體安全方面的權威。其餘
此領域上已經出了六本暢銷書，包含最近一本探討線上即時遊戲的書。演講內容
中，其指出目前線上即時遊戲常見的攻擊與目前的處理方式，並對線上即時遊戲
的攻擊模式做一深入的介紹。
第二場邀請演講題目為“Security and Usability: Mind the Gap”。講者為在
Carleton University 服務的 Paul Van Oorschot 博士。Paul Van Oorschot 博士先提出一
問題：是否網際網路適合一般人使用於需要安全與隱私保護的應用中，諸如：線
上銀行、匿名瀏覽應用及某些密碼管理的應用系統。其希望安全專家對於現今網
際網路上的安全應用之安全性與可用性能達到一平衡點。
除這兩場精彩的邀請演講外，本次會議中論文發表皆相當精采。茲選錄如下：
隱私主題中有一篇論文題目為“Analyzing Privacy in Enterprise Packet Trace 
22
參、 結語
此次赴美國聖地牙哥參加 NDSS 2008 會議，有機會與世界各國學者一同深入
討論網路與分散式系統安全研究未來的可能發展方向。此次會議參加人數約一百
人，可以強烈感受到網路與分散式系統安全研究在世界各地的蓬勃發展，令人印
象深刻。非常感謝國科會能提供足夠的經費讓本人參加此盛會。對本人而言，目
睹世界各國學者在網路與分散式系統安全研究工作上的表現，也讓我們能掌握網
路與分散式系統安全的主流研究趨勢。
肆、 攜回資料
本次參加會議所攜回之資料有下列三項：
1. 會議論文集。
2. 大會議程手冊。
3. 與會學者名冊及通訊地址。
24
論及實務應用。2008 年資訊安全聯合會議為第三屆。今年此次會議共有四十五篇
論文發表。主辦單位同時也邀請六位著名學者專家對最近的資訊安全現況進行專
題演講。
本次的研討會主要由韓國、日本與台灣主辦。預計未來將再邀請大陸、香港
與新加波參與。
陸、 邀請演講與論文發表
本次會議兩天議程，共有六位學者之六場邀請演講及四十五篇論文發表。整
體觀之，JWIS 會議是以資訊安全議題為主軸，內容相當多元。邀請演講如下：
3. Recent Developments in Communications Traceability, Youki Kadobayashi, Japan
4. iCAST, International Collaboration for Advancing Security Technology, Der-Tsai
Lee, Taiwan
5. Internet Worm Threat and Defending Mechanism, Bin Xiao, Hong Kong
6. A Survey of WiBro Security in Heterogeneous Wireless Networks, JooSeok Song,
Korea
7. Web Application Security Trends in Taiwan, Chi-Sung Laih, Taiwan
8. Introducing Cyber Clean Center of Japan - Practical Implementation and
Cooperation by Major Japanese ISPs in Anti-bot Measures within Japan, Koichi
Arimura, Japan
所接受論文發表包括網路安全、應用安全、RFID/感測網路安全、安全管理、
應用/密碼學、系統安全等。以下簡述本人主持的兩場邀請演講及本人發表的兩篇
論文內容。
第 一 場 邀 請 演 講 題 目 為 “Recent Developments in Communications
Traceability”。講者為在National Institute of Information and Communication
Technology 的 Youki Kadobayashi 博士。Kadobayashi 博士最近幾年執行數個大
型的通訊流量追蹤計畫。對此主題有相當多的成果。演講內容中，其指出目前流
量追蹤常見的攻擊與目前的處理方式，並對流量追蹤模式做一深入的介紹。
第二場邀請演講題目為“iCAST, International Collaboration for Advancing
Security Technology”。講者為在中研院資訊所服務的 Der-Tsai Lee 院士。李院士
26
捌、 攜回資料
本次參加會議所攜回之資料有下列三項：
4. 會議論文集。
5. 大會議程手冊。
Security Enhancement for Robust Password Authenticated Key Agreement
Using Smart Cards
Wen-Shenq Juang and Sian-Teng Chen
Department of Information Management
Shih Hsin University
wsjuang@cc.shu.edu.tw
Abstract
The authentication system is an important security
element in a distributed computer environment. In 2006,
Juang et al. proposed a robust and efficient password
authenticated key agreement scheme using smart cards.
They claim their scheme is robust and efficient.
However, we find that their scheme can not prevent the
offline dictionary attack with the smart card perfectly.
In this paper, we show this drawback and propose a
new scheme to remedy the drawback.
Keywords: Authentication, Key exchange, Smart card,
Elliptic curve cryptosystem, Offline dictionary attack.
1. Introduction
In a public network environment, if a user needs to use a
remote server, the user first needs to pass the
authentication scheme of the server. For providing a
secure authentication system, password-based methods
is often use in many remote login servers. Since Lamport
[9] proposed a password-based authentication scheme in
1981, several schemes [4,5,6,7,8] have been proposed.
These proposed schemes [4,5,6,7,8] pointed out some
attacks and weaknesses of Lamport’s scheme [9], and
then their improved schemes, were proposed.
In 2005, Fan et al. [4] proposed a robust remote
authentication scheme with smart cards. The scheme can
satisfy a lot of security capabilities. The major capability
of Fan et al.’s scheme [4] is preventing the offline
dictionary attack with the smart card.
In 2006, Juang et al. [6] proposed a robust and
efficient password authenticated key agreement using
smart cards. They claimed that their scheme can satisfy
all the capabilities of the Fan et al.’s scheme, and also
can provide identity protection, session key agreement,
low communication and computation cost, and can
prevent the insider attack. However, we find that Juang et
al.’s scheme can not provide the offline dictionary attack
with the smart card perfectly. In some situations, the
attacker can use this kind of attacks to login the server
successfully.
In this paper, we describe the attack for Juang et al.’s
scheme and propose a new scheme that not only satisfies
all the benefits of Juang et al.’s scheme but also can
prevent the offline dictionary attack with the smart card
completely.
In section 2, we first review Juang et al.’s scheme.
Then we will show the drawback of Juang et al.’s scheme
in section 3. In section 4, we will show our proposed
scheme. In section 5, we show the security analysis of
our proposed scheme. In section 6, we show the
performance consideration of our proposed scheme.
Finally in section 7, we make a conclusion.
2. Review of Juang et al.’s scheme
In this section, we will first review Juang et al.’s scheme.
Juang et al.’s scheme consists of three protocols, which
are the registration protocol, the login protocol and the
changing password protocol. We show these three
protocols as follows.
The registration protocol
If user i needs to register with the server, he does the
following protocol with the server. First, the server uses a
secure identification scheme to verify user i. Then user i
selects a password iPW and sends )}||(,{ bPWhID ii to
the server via a secure channel, where b is a random
number chosen by user i.
The server will create the card identifier iCI , which
is the number of cards that the server has issued to user i.
After the server receiving )}||(,{ bPWhID ii , if iID is a
new registration user, then the server will set 1iCI and
store },{ ii CIID in a registration table in the server. If the
server issues a new card to a user registered before, the
server will get },{ ii CIID from the registration table,
compute 1 ii CICI and store }1,{  iii CICIID to the
registration table.
The server computes ||||)||(( iisi IDbPWhEb 
)))||(||||(|| bPWhCIIDhCI iiii and ),( iii CI,sIDhV  . The
server then stores },,,{ iiii CIIDVb in a smart card and
sends this smart card to user i. Then user i stores b into
the smart card when he getting this smart card. The
smart card contains },,,,{ bCIIDVb iiii . User i then keeps
the smart card and iPW for the following login
process.
2. The server finds a generator point G of the order n,
where n is a large divisor, and 0Gn .
3. The server selects a random number x as his private
key and safely keeps it in his secret storage.
4. The server computes the public key )( GxPS  and
publishes the parameters ),,,,( nGEPP PS .
The registration phase
When user i needs to register in the server, he performs
the following phase with the server. First, the server
verifies user i by using a secure identification scheme.
Then user i sends )}||(,{ bPWhID ii to the server via a
secure channel, where b is a random number chosen by
user i and iPW is a password chosen by user i.
After receiving )}||(,{ bPWhID ii , the server creates the
card identifier
iCI , which is the number of cards that the
server has issued to user i. If iID is a new user, then the
server will set 1iCI and store },{ ii CIID in the
registration table in the server. If the server issues a new
card to user i that registered before, the server can get
},{ ii CIID from the registration table. Then the server
computes 1 ii CICI and stores }1,{  iii CICIID in
the registration table in the server.
The server generates ||||)||(( iisi IDbPWhEb 
)))||(||||(|| bPWhCIIDhCI iiii and ),( iii CI,sIDhV  . The
server then issues the smart card to user i that
contains },,,{ iiii CIIDVb . When getting this smart card, the
user then stores b into the smart card. The memory of
smart card contains },,,,{ bCIIDVb iiii . User i then keeps
the smart card and
iPW for the login phase.
The precomputation phase
The smart card selects a random number r, and computes
)( Gre  and )()( GxrPrc s  as a point over PE
before the start of the login phase. Then it stores (c,e) into
it’s memory for use in the login phase.
The login phase
When user i wants to login the server, he must inserts his
smart card into a card reader and inputs his password
iPW . In our proposed scheme, the smart card will
complete the precomputation phase before the login
phase.
After user i has inputted the password and the smart
card has finished the precomputation phase, the smart
card sends )(, eEb
iVi
to the server, where
),,( iii CIsIDhV  .
After receiving )(, eEb
iVi
, the server decrypts ib by
the secret key s and obtains ||||||)||( iii CIIDbPWh
))||(||||( bPWhCIIDh iii , and then the server computes
),,( iii CIsIDhV  . Therefore, the server will use iV to
decrypt )(eE
iV
to obtain e = )( Gr . Then the server
checks if
1. decrypting ib can get the authentication
tag )),(||||( bPWhCIID iii ,
2. iID is in the registration, and
3. iCI is stored in the registration table.
If any of the above verifications is false, the server
revokes the login request. If all of the above
verifications are true, the server selects a random
number u and computes )()( Gxrxec  and
)||||( iS VuchM  . Then the server sends sMu, to the
smart card.
After the smart card receiving su,M , it computes SM
and check if SM is equal to )||||( iVuch . If no, the smart
card revokes the login phase. Otherwise the smart card
computes )||||||)||(( ucVbPWhhM iiU  and a session key
),,( ucVhS ik  , then sends UM to the server. At this time,
the server is authenticated by the smart card.
When receiving UM , the server checks if UM is
equal to )||||||)||(( ucVbPWhh ii , If no, the server revokes
the login request. Otherwise the server accepts the login
request and computes a session key ),,( ucVhS ik  . Then
the smart card and the server authenticate each other and
can use the session key ),,( ucVhS ik  in secure
communication soon.
The changing password protocol
When user i needs to change his password, he needs to
agree a session key with the server through the login
phase in advance. Then the smart card can uses the
session key to encrypt the changing password message
)}||(,{ ** bPWhID ii and sends ))||(,( ** bPWhIDE iiSk to the
server. The server computes the new secret information
)))||(||||(||||||)||(( ***** bPWhCIIDhCIIDbPWhEb iiiiiisi 
after the server receiving the message, and sends )( *iS bE k
to the smart card. The smart card then decrypts the
message by the session key and stores *ib and
*b in its
memory.
5. Security analysis
In this section, we will analyze the security of our
proposed scheme.
(1) Mutual authentication
In our proposed scheme, the goal of mutual
authentication is to establish an agreed session key Sk
between the user and the server [5]. Let A mean the user,
B mean the server and A  kS B denote that the user and
the server share the common session key Sk. If there is an
Sk such that A believes A  kS B and B believes A  kS B
for the transaction, we can say the mutual authentication
In the precomputation phase of our proposed scheme,
that needs two multiplications of a number over an
elliptic curve. In the login phase, our proposed scheme
needs one symmetric key operation and three hashing
operations for a client, and needs one multiplication of a
number over an elliptic curve, two symmetric key
operations and four hashing operations for a server. The
computation cost of Juang et al.’s scheme [6] in the login
protocol requires one symmetric key operation and three
hashing operations for a client, and needs two symmetric
key operations and four hashing operations for a server.
The computation cost of Fan et al.’s scheme [4] in the
login protocol requires one modular multiplication and
three hashing operations for a client, and needs one
exponential operation, one symmetric key operation and
two hashing operations for a server.
We assume that the multiplication of a number over
an elliptic curve is approximant to twenty-nine modular
multiplications, and the exponential operation is
approximant to two hundred and forty modular
multiplications [7].
The efficient comparison between our scheme and
related schemes is shown in the Table 1.
2 Sym + 4 Hash1 Sym + 3 HashNo Need832 bitsJuang et al.[6]
1 Exp + 1 Sym+ 2 Hash
240M + 1 Sym + 2 Hash1M + 3 HashNo Need1344 bitsFan et al. [4]
1 EC_M +2 Sym + 4 Hash
29 M + 2 Sym + 4 Hash1 Sym + 3 Hash2 EC_M58 M1088 bitsOur scheme
E4E3E2E1
E1: communication cost of the login phase; E2: computation cost of the precomputation phase;
E3: computation cost of the login phase for a client; E4: computation cost of the login phase for a server;
Exp: exponential operation; Hash: hashing operation; Sym: symmetric encryption or decryption;
M: a modular multiplication operation; EC_M: multiplication operation of a number over an elliptic curve.
Table 1. Efficient comparison between our scheme and related schemes
(2) No password table
In order to prevent the server from holding and
protecting a large password table, a password or a
verification table should not be stored in the server. In
our proposed scheme, the hashed password with a
random number )||( bPWh i is encrypted in
)))||(||||(||||||)||(( bPWhCIIDhCIIDbPWhEb iiiiiisi  and is
sent to the server. The server does not need to keep a
password table. In our proposed scheme, the server only
needs to keep a registration table to store each card’s
identifier. This table is smaller than the password table
and does not need to keep secret.
(3) Choosing and changing the password by
users
In our proposed scheme, every user can select his
password. Hence the user can easily remember the
password. Also, we provide the password changing
phase for users to change their passwords.
(4) No time-synchronization problem
In the login phase of our scheme, we use two nonces u
and r to prevent the replay attack. No logical time clocks
are needed.
(5) Identity protection
The user’s identity iID in our scheme is included in ib ,
which is sent to the server and encrypted by using the
secret key s in the login phase. Only the server can
decrypt ib and get iID . Therefore, our proposed scheme
can provide identity protection.
(6) Revoking the lost cards without changing the
user’s identity
In our proposed scheme, if the user loses his smart card,
the server can revoke the lost card. When this user needs
to obtain a new smart card, the server will set 1 ii CICI
and issues a new smart card to the user.
(7) Session key agreement
In our scheme, the user and the server both can agree a
session key ),,( ucVhS ik  after the login phase.
7. Conclusion
In this paper, we have shown Juang et al.’s scheme’s
drawback and proposed a new scheme to remedy this
drawback. Our proposed scheme can prevent the offline
dictionary attack with the smart card perfectly and the
efficiency of our scheme is approximate to that of Juang
et al.’s scheme.
Acknowledgment. This work was supported in part by
the National Science Council of the Republic of China
under the Grant NSC 95-2221-E-128-004-MY2, and by
the Taiwan Information Security Center (TWISC),
National Science Council under the Grants NSC
95-3114-P-001-001-Y02 and NSC 94-3114-P-011-001.
References
[1] M. Burow, M. Abadi and R. Needham, “A logic of 
authentication,” ACM Trans. Comput. Syst., Vol. 8, 
1990, pp. 18-36.
[2] W. Diffie and M. Hellman, “New Directions in
Cryptography,”IEEE Trans. Inform. Theory, Vol. 22,
pp. 644-654, 1976.
[3] J. Don, A. Menezes and S. Vanstone, “The eliptic 
curve Digital Signature Algorithm (ECDSA),” 
International Journal of Information Security, Vol. 1, pp.
36-63, 2001.
[4] C. Fan, Y. Chan and Z. Zhang, “Robust remote
authentication scheme with smart cards,”Computer &
Security, Vol. 24, 2005, pp. 619-628.
Robust and Efficient Three-party User Authentication
and Key Agreement Using Bilinear Pairings
Wen-Shenq Juang1, Chin-Laung Lei2, Horng-Twu Liaw3 and Wei-Ken Nien3
Department of Information Management1
National Kaohsiung First University of Science and Technology
Kaohsiung, Taiwan
wsjuang@ccms.nkfust.edu.tw
Department of Electrical Engineering2
National Taiwan University
Taipei, Taiwan
lei@cc.ee.ntu.edu.tw
Department of Information Management3
Shih Hsin University
Taipei, Taiwan
Abstract. For providing a secure distributed computer environment, user
authentication and key agreement is very important. In additional to user
authentication and key agreement, identity privacy is very useful for users. In three-
party environments, both communicating parties can share separately passwords with
a trusted third party rather than themselves. This approach can reduce the key
management complexity when any two users may want to build a secure channel
between them. In this paper, we propose an robust and efficient three-party password
authenticated key agreement scheme using bilinear pairings. The main merits include:
(1) there does not need any password or verification table in the server; (2) users can
choose or change his own password freely; (3) both of the two users can authenticate
each other; (4) it can protect the user’s privacy; (5) the two users can generate a
session key; (6) it does not have a serious synchronization-clock problem; (7) even if
the secret information stored in a smart card is compromised, it can prevent the offline
dictionary attack.
Keywords: User authentication, session key agreement, bilinear pairings,
smart cards, three-party scheme, smart card loss problem.
1 Introduction
Since most of the communication is in open environments, sensitive data or
information must be properly protected. How to protect the communication content
privately and securely becomes extremely important.
Robust and Efficient Three-party User Authentication and Key Agreement Using Bilinear
Pairings 3
efficiency and between our scheme and the related schemes. Finally, we make a
conclusion in Section 6.
2 Review of Kwonet al.’sscheme
We suppose that two parties A and B try to establish a protected channel
between them by the help of the trusted third party S [12]. For instance, A and B are
both clients in the S’s service domain. Individual passwords for A and B are denoted
by Apw and Bpw .
3.3.1 Initial Setup
A and B choose passwords Apw and Bpw , and register to S in a secure way,
respectively. S stores [ , ,A v ] and [ , ,B  ] in its memory, where 0( , )Ah A pw ,
1( , )Au h A pw , uv g , 0( , )Bh B pw , 1( , )Bw h B pw , and wg .
3.3.2 Protocol
The protocol is shown in Figure 1. We only describe the messages for A. The
protocol for B may achieve in the similar steps.
L1: A computes 0 ( , )Ah A pw , 1( , )Au h A pw , and * ( )X E X where xX g , and
x is a random number, and sends message 1 *( , , )A B X to S .
L2: After receiving message 1, S may choose random numbers a, b, and r, and look
up the user profiles for acquiring [ , ,A v ] and [ , ,B  ].
L3: S can then retrieve X by decrypting X*, and computing aV v .
L4: S computes *2( , )e h X V , and ( )e aXg .
S then computes rX . Note that the random value r is very important in the
protocol since it really links A with B.
L5: S computes * ( )E  where ( )kdf  . Then S may reply with message
3 * 3( , , )AV X H by computing
3 * *
3( , , , , )AH h X V  where ( , , )A B S .
L6: Upon receiving message 3, A computes *2' ( , )e h X V , and
1 ( ')' u x eV   . If
3 * *
3( , , , , ')AH h X V  , A aborts this protocol. Otherwise, A computes
4 * *
4 ( , , , , ')AH h X V   and replies with message 5 4( )AH . A also computes
*
'( )D  where ' ( ')kdf  , and sends message 7 ( ) to B.
L7: After receiving message 5, S may log the failure result and abandon this
protocol if 4 * *4( , , , , )AH h X V   . The log of failure results lets S count the numbers
of impersonation tries and withstand the on-line password guessing attacks. This is
the general technique to withstand on-line attacks in the password-based protocols.
B may receive from A after messages 2, 4, and 6 in the same way. B then
computes *
'
( )D  , where ' ( ')kdf  .
Robust and Efficient Three-party User Authentication and Key Agreement Using Bilinear
Pairings 5
L10: B may abandon if 6 ( , , , )A BH k K . Therefore, if the protocol is not
abandoned, A and B could agree with xyrA BK K g  and use it to build their secure
channel in an authentic way.
3. Our proposed schemes
There are three entities in our scheme including A and B and the server. The
scheme consists of four phases: the setup phase, the registration phase, the key
agreement phase, and the key generation/authentication phase. Let 1G be an additive
cyclic group of a prime order q, and 2G be a multiplicative cyclic group of the same
order. Let P be a generator of 1G and 1 1 2ê :G G G  be a bilinear mapping [4,
24]. Let H:{0, 1}∗ → 1G be a cryptographic one-way hash function which maps a
string to a point of the additive cyclic group 1G [4, 23]. Let ( )h and ( )k be a secure
one-way hash function [17]. Let xE () be a secure symmetric encryption algorithm
with the secret key x [18] and ∥ be the ordinary string concatenation operation. Let
IDs be the identification of the server, and AID and BID be the identification of user A
and user B, respectively.
3.1 The setup phase
The server selects a secret key s and computes the public-key as sP. He also
randomly chooses a master symmetric secret key x and keeps it secret. Then the
server publishes the public information <Ps=sP, P> and keeps <s, x> secret.
3.2 The registration phase
If user A and user B with the identity AID and identity BID , respectively, would like
to register with the server, she/he performs the following protocol with the
server. Parameter i is in the name of user A and B, respectively.
R1. The server verifies user i through a secure identification scheme. If user i is
eligible, then user i selects her/his password iPW and a random number b,
computes  ih PW b , and sends   ,i iID h PW b to the server in a secure
channel.
R2. The server encrypts the hashed password by computing ib =
  || ( ( || ) )x i i i iE h PW b ID h h PW b ID .
R3. The server stores ib in a smart card and delivers it to user i in a secure channel.
The user keeps iPW and the smart card secretly for future login processes.
R4. After user i receiving the smart card, he inputs b into the smart card. The
memory of the smart card contains < ib , b>.
For each user, the registration phase is performed once. If the user loses his/her
smart card, he/she can perform the registration protocol with the server again.
Robust and Efficient Three-party User Authentication and Key Agreement Using Bilinear
Pairings 7
where ( , , )A B S . The random number r is very important that actually links A with
B in our protocol. Then the server sends < * 3, AH > to user A over a public channel.
Step 3 :Let user A receive the message < * 3, AH > from the server. User A
computes  ||Ah PW b . He then verifies if 3 *3( || || ( || ) || )A AH h h PW b   , where
( , , )A B S . If no, the protocol stops. Otherwise, user A computes
4 *
4 ( || || ( || ) || )A AH h h PW b   and sends 4AH to S. A also use private key  to
decrypt * via *( )D  α and sends  to B.
Let the server receive 4AH , S may log a fault information and reject this protocol
if 4 *4( || || ( || ) || )A AH h h PW b   . The log of failure information lets S count the
number of failed tries and prevent on-line dictionary attacks. This is the usual
technique to prevent on-line attacks in the password-based protocols.
)b(Ee
)mQ)(Ps,ê||Q||Ps||mP(h
mPX,m
A
q





1
)b(E
)nQ)(Ps,ê||Q||Ps||nP(h
nPY,n
B
q





1
  
  )ID)b||PW(h(hIDb||PWh)b(D
)(Dband
)ID)b||PW(h(hIDb||PWh)b(D
)e(Db
)sQ)(Y,ê||Q||Ps||Y(h
)sQ)(X,ê||Q||Ps||X(h
BBBBBx
B
AAAAAx
A











1
1
))y||)b||PW(h||||(hHand
))||)b||PW(h||||(hH
)y(Eyand
)(E
)S,B,A(
rYyand
rX
Zr
i
3
B
i
3
A
*
*
q







3
3








)||)b||PW(h||||(hH
)||)b||PW(h||||(hH
ifabort
)S,B,A(
A
4
A
A
3
A



4
3



)y||)b||PW(h||||(hH
iflog
)||)b||PW(h||||(hH
iflog
B
4
B
A
4
A


4
4

)K||y||||(kH
)y||)b||PW(h||||(hH
)K||y||||(kH
ifabort
nK
BB
B
4
B
BA
B




5
4
6




)K||y||||(kH
ifabort
AB 5
eXBA ,,,:1
33 A
* H,:
Client A Client B Server S
,,,,,:2,1 YeXBA
34 B
* H,y:
)y||)b||PW(h||||(hH
ifabort
y)y(D
)S,B,A(
B
3
B
*



3


yH A ,,:'8,3
3*
)K||y||||(kH
myK
)(D
AA
A
*


6


AA HH ,,:9,7,5
4 
BH:''8
44 ,:6,5 BA HH
}P,sPP{:Public}x,s{:Secret s 
Figure 3. The relay mode protocol of our proposed three-party scheme
3.3.2 The key generation/authenticate phase
Setup 4: B may derive from A after receiving the responding messages in the
same manner. B then computes *( )D y y  . B then computes BK n  and
5( || || || )B BH k y K  , and sends , By H to A.
Robust and Efficient Three-party User Authentication and Key Agreement Using Bilinear
Pairings 9
registration phase. An attacker can not make a valid ib without the information of the
server’s secret key x and theuser’s password iPW .
(4) Preventing the offline dictionary attack without the smart card
In order to prevent this attack [5], the transmitted messages of our scheme do not
enough information to check the validability of the password. The first message
between a user and the server of our scheme is { X, e }. If the attacker intercepts this
message, the attacker also can not derive APW because the attacker do not know the
secret key x. The attacker can not decrypt Ab to get  Ah PW b . So it is impossible
for the attacker to do the offline dictionary attack by this message. If the attacker
intercepts the message 4AH and AH , the attacker also has not enough information to
derive the password since the entropy of , b, m and AK are all very large.
7
8Hash+6Exp(
≈1440M)+4Sy
m
8Hash+3Exp
(≈720M)+2S
ym
8Hash+3Exp
(≈720M)+2S
ym
Kwon et al.
7
6Hash+2EC(≈
58M)+2BP+6
Sym
5Hash+2EC(
≈58M)+1BP
+2Sym
5Hash+2EC(
≈58M)+1BP
+2Sym
Our scheme
No. of messagesServerClient BClient A
Hash: hashing operation
Sym: symmetric encryption or decryption
EC: Scalar multiplication of elliptic curve point
BP: Bilinear pairing operation
Exp: exponential operation
M: a modular multiplication operation
Table 1. Efficient comparison between our scheme and related schemes
for three-party protocols
(5) Preventing the offline dictionary attack with the smart card
This attack is similar to the offline dictionary attack without the smart card, but the
attacker can get the smart card and acquire the secret information stored in a smart
card [5]. In our scheme, for example, user A’s password stored in a smart card is
embedded in Ab . Only the valid server can use the master secret key x to decrypt Ab
to acquire the hashed password  Ah PW b . If the attacker gets the smart card and
acquires the secret information stored in the smart card, before the attacker can forge
the valid user, he must generate 4 *4 ( || || ( || ) || )A AH h h PW b   . In this situation, the
attacker can obtain the correct and * , but the attacker can not generate the correct
 Ah PW b since  Ah PW b can only be generated by the eligible user online or be
derived by the server by decrypting   A|| ( ( || ) )A x A A Ab E h PW b ID h h PW b ID . So
the attacker can not get the correct password and create the authenticator 3AH and
4
AH .
Robust and Efficient Three-party User Authentication and Key Agreement Using Bilinear
Pairings 11
6. Conclusion
In this paper, we have proposed an efficient and flexible three-party password
authenticated key agreement scheme using bilinear pairings. Our scheme can provide
many nice properties, such as, identity protection, mutual authentication, revoking a
smart card without changing user’s identity, session key agreement, and no
synchronization-clock problem. In our schemes, if the secret information stored in a
smart card is compromised, our scheme can prevent the offline dictionary attack.
Also, our schemes can prevent server compromise and is very flexible in two modes
of three-party settings.
References
1. S. Bellovin and M. Merritt, "Augmented encrypted key exchange: password-
based protocols secure against dictionary attacks," Research in Security and
Privacy, Proceedings IEEE Computer Society Symposium, pp. 72-84, 1992.
2. S. Bellovin and M. Merritt, "Augmented encrypted key exchange: a password-
based protocol secure against dictionary attacks and password-file
compromise," ACM Conference on Computer and Communications Security,
pp. 244-250, 1993.
3. D. Boneh and M. Franklin, "Identity-based encryption from the Weil pairing,"
in Proc. Crypto 2001, LNCS, vol. 2139, Springer, pp. 213-229, 2001.
4. M. Das, A. Saxena, V. Gulati, and D. Phatak, "A novel remote user
authentication scheme using bilinear pairings," Computers & Security, 2006.
5. C. Fan, Y. Chan, and Z. Zhang, "Robust remote authentication scheme with
smart cards," Computers & Security, vol. 24, pp. 619-628, 2005.
6. A. Joux, "A one round protocol for tripartite Diffie-Hellman," Proceedings of
the 4th International Symposium on Algorithmic Number Theory, Lecture Notes
In Computer Science vol. 1838, pp. 385-394, 2000.
7. W. Juang, "Efficient password authenticated key agreement using smart card,"
Computer & Security, vol. 23, pp. 167-173, 2004.
8. W. Ku, "A hash-based strong-password authentication scheme without using
smart cards," ACM Operating Systems Review, vol. 38, pp. 29-34, 2004.
9. W. Ku and S. Chen, "Weaknesses and improvements of an efficient password
based remote user authentication scheme using smart cards," IEEE Trans. on
Consumer Electronics, vol. 50, pp. 204-207, 2004.
10. W. Ku, C. Chen, and H. Lee, "Weaknesses of Lee-Li-Hwang's hash-based
password authentication scheme," ACM Operating Systems Review, vol. 37, pp.
9-25, 2003.
11. W. Ku, C. Chen, and H. Lee, "Cryptanalysis of a variant of Peyravian-Zunic's
password authentication scheme," IEICE Trans. on Commun., vol. E86-B, pp.
1682-1684, 2003.
12. T. Kwon and D. H. Lee, "Three-party password authenticated key agreement
resistant to server compromise," Information Security Applications, Lecture
Notes in Computer Science, vol. 4298, pp. 312-323, 2007.
International Journal of Network Security, Vol.7, No.2, PP.126–135, Sep. 2008 126
Efficient User Authentication and Key
Agreement With User Privacy Protection
Wen-Shenq Juang and Jing-Lin Wu
(Corresponding author: Wen-Shenq Juang)
Department of Information Management, Shih Hsin University
No. 1, Lane 17, Section 1, Mu-Cha Road, Taipei 11604, Taiwan (Email: wsjuang@cc.shu.edu.tw)
(Received Sep. 23, 2006; revised and accepted Nov. 22, 2006)
Abstract
Using smart cards, remote user authentication and key
agreement can be simplified, flexible, and efficient for cre-
ating a secure distributed computers environment. Ad-
dition to user authentication and key distribution, it is
very useful for providing identity privacy for users. In
this paper, we propose novel user authentication and key
agreement schemes with privacy protection. We first pro-
pose a single-server scheme and then apply this scheme to
a multi-server environment. The main merits include: (1)
the privacy of users can be ensured; (2) a user can freely
choose his own password; (3) the computation and com-
munication cost is very low; (4) servers and users can au-
thenticate each other; (5) it generates a session key agreed
by the server and the user; (6) our proposed schemes are
nonce-based schemes which does not have a serious time-
synchronization problem.
Keywords: Network security, privacy protection,session
key, smart card, user authentication
1 Introduction
For obtaining permitted services by service providers in a
network environment, the user must legally login to the
provider’s server. In general, the user transmits a message
of user authentication to the server, and then the server
must be able to verify the identity of the user and give
him the right of using permitted services. Typically, the
user passes a password as a secret token to the server. The
server first checks if the user’s identity and the password
are matching. The server rejects the user’s request if his
identity or the password is not matching. If the password
is matching, the server give the user the right for using
the permitted services.
In 1981, Lamport [11] first proposed a password au-
thentication scheme at the both ends of the communi-
cation. Since then, many schemes have been proposed
to point out its drawback and improve the security and
efficiency of Lamport’s scheme [11]. Only passing a pass-
word for authenticating between the user and the server
is not enough, since it is less safety and is easily tapped
by the adversary. Before two parties can do secure com-
munication, a session key is needed for protecting sub-
sequence communications [1, 8, 9, 21]. Also, using smart
cards [8, 9, 21], remote user authentication and key agree-
ment can be simplified, flexible and efficient for creating
a secure distributed computers environment. It is also
useful for providing identity privacy for the users [21].
In 2004, Juang proposed two efficient authentication and
key agreement schemes [8, 9] for single server, and multi-
server environments. But both Juang’s schemes [8, 9]
have no ability of anonymity for the user. Yang et. al. [21]
proposed user identification and key distribution scheme
with the ability of privacy protection but we point out it
is less efficient because of using public-key cryptosystems.
For basically security and efficient requirements, the
following criteria are important for remote user authen-
tication and key agreement schemes with smart cards
[8, 9, 21].
C1. Privacy protection: When the user authenticates
successfully to the server, the adversary can not de-
rive the user’s identity.
C2. Freely chosen password: Users can freely chosen
and change their passwords for protecting their smart
cards.
C3. Low computation and communication cost:
Since capacity and communication constrains
of smart cards, they may not offer a powerful
computation capability and high bandwidth.
C4. Mutual authentication: Servers and users can
authenticate each other.
C5. Session key agreement: Servers and users must
negotiate a session key for subsequent communica-
tions.
In this paper, we propose two efficient user authen-
tication and key agreement schemes with the ability of
International Journal of Network Security, Vol.7, No.2, PP.126–135, Sep. 2008 128
into Sj . Assume that N1 is a nonce chosen by Ui and N2
is a nonce chosen by Sj for freshness checking. Assume
that ruk is a random number chosen by Ui and rsk is a
random number chosen by Sj for generating the session
key skk = h(rsk||ruk||vi,j). The following protocol is the
kth login with respect to his smart card.
Step 1: Ui → Sj : N1, UIDi, Evi,j (ruk, h(UIDi||N1));
Step 2: Sj → Ui : Evi,j (rsk, N1 + 1, N2);
Step 3: Ui → Sj : Eskk(N2 + 1).
Shared Key Inquiry Phase: In Step 3 of the registra-
tion phase, RC will send the encrypted shared secret key
Ewj (vi,j , UIDi) to each Sj . Upon receiving the message,
he will store it in his encrypted shared key table. If he
do not want to manipulate this table, the shared key can
be inquired from RC when it is needed. The following
protocol can be inserted between Step 1 and Step 2 of the
login and session key agreement phase when Sj needs the
shared key.
Step 1’: Sj → RC : N3, UIDi, SIDj ;
Step 1”: Ewj (vi,j , N3 + 1).
2.4 Yang et al.’s User Authentication and
Key Distribution Scheme
Yang et al. proposed a user authentication and key
distribution with user anonymity [21] based on fac-
toring, discrete logarithm and hash functions. The
major drawbacks of this scheme are that it has a
time-synchronization problem, and the computation and
communication cost is still high. There are three kinds
of participants in this scheme: a Smart Card Producing
Center (SCPC), service providers (servers) and users.
Let Ui denote user i, Pj denote service provider j. This
scheme consists of two phases: (1) the key generation
phase and (2) the anonymous user identification phase.
Their proposed scheme is as follows:
The key generation phase: The SCPC does the fol-
lowing to set up system parameters.
1) Chooses two large primes p and q, computes n = pq,
randomly selects a number e and computes d, where
ed ≡ 1 mod φ(n) and φ(n) = (p− 1)(q − 1).
2) Chooses an element g ∈ Z∗n which is a generator of
both Z∗p and Z
∗
q .
3) Publishes (e, n, g) as public system parameters and
keeps (d, p, q) secret.
4) Sends to each registered user Ui or service provider
Pi a secret token Si ≡ (IDi)
d mod n, where IDi is
the identity of Ui or Pi.
The anonymous user identification phase: If Ui
wants to request a service from Pj , they then performs
the following steps:
Step 1: Ui Sends the service request to Pj for requesting
services from Pj .
Step 2: Upon receiving the request, Pj chooses a random
number k and computes z ≡ gkS−1j mod n and sends
z to Ui.
Step 3: Upon receiving z, Ui chooses a random number
t and does the following computations:
a = zeIDj mod n,
Kij = a
t mod n,
x = get mod n,
s = gtS
h(x||T )
i mod n,
y = EKij (IDi),
where T is the current timestamp and Ki,j is the
common session key. Ui then sends (x, s, y, T ) to Pj .
Step 4: Upon receiving the message in Step 3, Pj checks
the timestamp T . If it is old, he aborts the pro-
tocol. Otherwise, he then obtains the common ses-
sion key Kij = x
k mod n and then decrypts y as
IDi = DKij (y) and verifies
xID
h(x||T )
i
?
= se mod n.
If the verification passes, then the service request is
granted.
3 Single Server Authentication
and Key Agreement with User
Anonymity
In this section, we propose an efficient single server user
authentication and key agreement scheme with privacy
protection. The concept used in this section will be used
in the next section to construct an efficient multi-server
user authentication and key agreement scheme with pri-
vacy protection. Let IDi be a unique identification of
user i. Also, let x be the master secret key kept secretly
by the server S.
3.1 The Proposed Scheme
The proposed scheme is as follows.
Registration Phase: Assume Ui submits his identity
IDi and his password PWi to the server S for registration.
If S accepts this request, he will perform the following
steps:
Step 1: Compute Ui’s secret information αi = h(x||IDi)
and βi = αi ⊕ PWi. Compute the pseudo iden-
tification number λi,1 = h(αi||IDi||1) and records
(k = 1, λi,1, IDi) in an identification table.
International Journal of Network Security, Vol.7, No.2, PP.126–135, Sep. 2008 130
Table 1: Efficiency comparison between our single server scheme and other related scheme
Our scheme Juang’s scheme [8]
D1 128 bits 128 bits
D2 384 bits 256 bits
D3 2 Hash 1 Hash
D4 6 Sym + 7 Hash 6 Sym + 3 Hash
D1: Password length
D2: Communication cost of authentication for cryptographic parameters
D3: Computation cost of registration
D4: Computation cost of authentication
Hash: Hashing operation Exp: Exponential operation
Sym: Symmetric encryption or decryption
2) The dictionary attack [1]: For computing the ses-
sion key ki, the adversary must know rui, rsi and
αi, where the entropy of rui, rsi or αi is very large.
The shared key αi is only kept by the user and the
server, so the session key are not be computed by the
adversary.
3) The replay attack [19]: Replay attack is simply re-
playing the message to the user or the server. For
instance, the user just logins one time to server, but
the adversary replays these authentication messages
to the server for getting the permission of extra lo-
gins. To avoid these kind of attacks, our proposed
scheme use nonces N1, N2, N2 + 1 to resist them.
4) The modification attack [20]: The modification at-
tack is a disturbance attack. The purpose of this
attack is that both the server and the user can not
normal communicate each other. The server and the
user consider they have the same session key ki, but
they have different session key k′i in fact. Our pro-
posed scheme can also resist this attack. Upon the
message N1, λi,k, Eαi(ruk, h(N1||ruk||λi,k)) in Step 1
of the user authentication and session key agreement
phase, the adversary can not add or modify this mes-
sage since the adversary does not has the share key
αi. If the adversary modify the message, the server
will reject this message since the authentication tag
is invalid. In the other hand, the user have the same
process to prevent this attack.
5) The stolen-verifier attack [3]: For achieving the abil-
ity of user anonymity, we use a pseudo identification
λi,k = h(αi||IDi||k) to communicate with the server.
If the λi,k is known by the attacker, the attacker is
still difficult to derive the user’s real identification
IDi since the shared key αi is protected by the se-
cure one-way hash function h() and the entropy of αi
is very large.
6) The insider attack [14]: The weak password PWi
used in our scheme is only for protecting the corre-
sponding smart card from being used by illegal users.
If a user uses PWi to access several servers for his
convenience, the insider of the server can not imper-
sonate the user to access other servers if this server
do not have the corresponding smart card. We can
replace βi = αi⊕PWi with αi⊕h(b⊕PWi) and use
the checking method mentioned in [14] for protect-
ing the weak password being known by the server.
But this approach will need the user to remember
the random number b and input it after getting the
smart card. The most important assumption for the
server is protecting his master secret key x secretly.
If this master secret key x is compromised, then the
total system is insecure.
3.3 Performance Considerations
We evaluate the efficiency of our scheme and Juang’s
scheme in Table 1. First, we assume the block size of se-
cure symmetric cryptosystems is 128 bits and the output
size of secure one way hashing functions is 128 bits. Be-
cause both our proposed single-server scheme and Juang’s
scheme are based on symmetric key cryptosystem, the
performance is very well. In our scheme and [8], the
password length only 128 bits is required. Our proposed
scheme needs 384 bits for the user authentication. Both
ours and Juang’s scheme [8], the computation cost for reg-
istration is only needed one hash operation. The compu-
tation cost are aggregated operation numbers, including
encryption operations, decryption operations or hashing
operations. The encryption and encryption operations
may be asymmetric or symmetric cryptosystem. In the lo-
gin and session key agreement phase of our scheme, three
symmetric key encryptions, three symmetric key decryp-
tions and seven hash operations are required. In that of
Juang’s scheme [8], only three symmetric key encryptions,
three symmetric key decryptions and three hash opera-
tion are required. The computation cost of the login and
session key agreement is not including cost of generating
session key. Although our proposed scheme has a little
high communication and computation cost than Juang’s
scheme [8], but our scheme have more complete function-
ality.
The functionality comparison between our proposed
scheme and related scheme is given in Table 2. Compared
International Journal of Network Security, Vol.7, No.2, PP.126–135, Sep. 2008 132
Upon receiving the message in Step 1, Sj first searches
the pseudo identification λi,j,k in the key table. He
then decrypts the message Eγi,j (ruk, h(N2||ruk||λi,j,k))
and verifies if the authentication tag h(N2||ruk||λi,j,k) is
valid using the shared key γi,j in the matched entries. If
yes in some entry, the corresponding valid user identifi-
cation UIDi is found. If it is valid and the nonce N2
is fresh, Sj sends a nonce N3 and the encrypted message
Eγi,j (rsk,h(rsk||N2||N3)) back to Ui. The encrypted mes-
sage includes the random value rsk chosen by Sj , which
is used for generating the kth session key skk, and the
nonce N3, which is for freshness checking.
Upon receiving the message in Step 2, Ui decrypts the
message by computing Dγi,j (Eγi,j (rsk,h(rsk||N2||N3))).
He then checks if the authentication tag h(rsk||N2||N3) is
in it for freshness checking. If yes, Ui computes the next
pseudo identification λi,j,k+1 = h(γi,j ||UIDi||SIDj ||k +
1), the kth session key skk = h(rsk||ruk||γi,j), and records
SIDj, λi,j,k in a table and sends the encrypted message
Eskk(N3 + 1) back to Sj .
After receiving the message in Step 3, Sj decrypts the
message by computing Dskk(Eskk ( N3 + 1)) and checks
if the nonce N3 + 1 is in it for freshness checking. He
then computes λi,j,k+1 = h(γi,j ||UIDi||SIDj ||k + 1) and
updates (UIDi, k+1, λi,j,k+1 = h(γi,j ||UIDi||SIDj ||k+
1), γi,j) in the key table. Then Ui and Sj can use the
session key skk in secure communication soon.
4.2 Security Analysis
Identity protection: Similarity, our proposed multi-
server scheme can offer user identity protection.
So the adversary can not know the user identifi-
cation. In the user authentication and session key
agreement phase, the user first sends a message
N2, λi,j,k, Eγi,j (ruk, h(N2||ruk||λi,i,k)) to the server.
Because this message does not include user identification
UIDi, the adversary can not know the user identification.
Mutual authentication: In Step 1 of the user authenti-
cation and session key agreement phase, after Sj receives
the message Eγi,j(ruk, h(N2||ruk||λi,j,k)), Sj will com-
pute Dγi,j (Eγi,j (ruk, h(N2||ruk||λi,j,k))) using the share
key γi,j of Ui and Sj . Then Sj can check if this au-
thenticator h(N2||ruk||λi,j,k) is valid. If yes, Sj chooses
a random number rsk and can computes the kth session
key skk = h(ruk||rsk||γi,j) and believes Ui
skk←→ Sj .
In Step 2 of the user authentication and ses-
sion key agreement phase, upon receiving the message
N3, Eγi,j (rsk,h(rsk||N2||N3)), Ui decrypts the message
Dγi,j (Eγi,j (rsk,h(rsk||N2||N3)) and confirms if this mes-
sage contains the authenticator h(rsk||N2||N3). If yes, Ui
generates a session key skk = h(ruk||rsk||γi,j) and believe
Ui
skk←→ Sj . Since N2 is chosen by Ui, Ui will believes Sj
believes Ui
skk←→ Sj .
In Step 3 of the user authentication and session key
agreement phase, after Sj receiving Eskk(N3 +1), he will
decrypt this message Eskk (N3 + 1) with the kth session
key skk and get N3 + 1. Then Sj checks if N3 which
is sent by him is correct. If yes, Sj believes Ui believes
Ui
skk←→ Sj.
Session key agreement: The session key
skk = h(ruk||rsk||γi,j) is known to nobody but Si
and Uj , since the random values ruk, rsk are randomly
chosen by the user and the server and are encrypted by
the shared key γi,j .
Withstanding attacks: We prove our scheme can resist
to following attack:
1) The man-in-middle attack [18]: Our proposed multi-
server scheme also can resist to the man-in-the-
middle attack. If the message is modified by the ad-
versary, either ends of the communication will find
out and reject this message. Since our proposed
scheme can accomplish strong mutual authentica-
tion, our scheme can resist this attack.
2) The dictionary attack [1]: For deriving the session
key skk, the adversary must know ruk, rsk and γi,j
but the shared key γi,j is only kept secretly by the
user, the server and KDC. The adversary can not
get the session key skk, since rui and rsi are ran-
domly chosen and protected by the shared key γi,j
and the entropy of ruk, rsk or γi,j is very large.
3) The replay attack [19]: The replay attack is sim-
ply replaying the message to the user or the server.
Our multi-server scheme also provide an ability to
avoid this attack. Our proposed scheme uses nonces
N2, N3, N3 + 1 to resist the replay attack.
4) The modification attack [20]: Upon the message
N2, λi,i,k, Eγi,j (ruk, h(N2||ruk||λi,j,k)) in Step 1 of
the user authentication and session key agreement
phase, the adversary can not alter this message since
the adversary does not has the share key γi,j . If the
adversary modify the message, the server will reject
this message. In the other hand, the user also can
observe the original message whether is changed by
the adversary. So this attack on our scheme can be
prevented.
5) The stolen-verifier attack [3]: In our proposed multi-
server scheme, we use a pseudo identification λi,j,k =
h(γi,j || UIDi||SIDj ||k) for user anonymity. With-
out knowing γi,j = h(αi||SIDj), the attacker can not
get the user’s real identification UIDi since the en-
tropy of γi,j is very large. Our proposed multi-server
scheme can withstand the stolen-verifier attack.
6) The insider attack [14]: The function of the weak
password PWi in our multi-server scheme is the same
with that in our single server scheme. The most im-
portant assumption forKDC is protecting his master
secret key x secretly. If this master secret key x is
International Journal of Network Security, Vol.7, No.2, PP.126–135, Sep. 2008 134
Table 3: Efficiency comparison between our multi-server scheme and other related schemes
Our scheme Yang et al.’s scheme [21] Juang’s scheme [9]
E1 256 bits 1024 bits 256 bits
E2 384 bits 5 × 1024 bits 256 bits
E3 1 Hash 2 Exp 1 Hash
E4 6 Sym + 5 Hash None 4 Sym +2 Hash
E5 6 Sym + 7 Hash 9 Exp + 2 Sym + 2 Hash 7 Sym + 3 Hash
E1: Memory needed in the smart card
E2: Communication cost of the authentication for cryptographic parameters
E3: Computation cost of the registration
E4: Computation cost of the shared key inquiring
E5: Computation cost of the user authentication and key agreement
Hash: Hashing operation Exp: Exponential operation
Sym: Symmetric encryption or decryption
Table 4: Functionality comparison between our multi-server scheme and other related schemes
Our scheme Yang et al.’s scheme [21] Juang’s scheme [9]
C1 Yes Yes No
C2 Yes Yes Yes
C3 Very low High Very low
C4 Yes Yes Yes
C5 Yes Yes Yes
C6 Yes No Yes
C1: Privacy protection
C2: Freely chosen password
C3: Communication and computation cost
C4: Mutual authentication
C5: Session key agreement
C6: No serious time synchronization problem
T ′− T < 4T where T ′ is the receiving time of the server
and T is the sending time of the user. Our proposed
schemes solve this serious problem, because we use nonces
to prevent the replay attacks.
In [5, 10], two robust user authentication and key
agreement schemes were proposed. The major benefit of
these two schemes is even the secret token stored in the
smart card is derived by the attacker, the oﬄine pass-
word guessing attack fails. For preventing this kind of
attack, public key cryptosystems must be used [4]. In
our proposed scheme, only symmetric cryptosystems and
one-way hashing functions are used. The basic assump-
tion in our proposed scheme is that the smart card is
tamper-resistant. Our proposed schemes can not prevent
this kind of attack when the card is lost and the secret
token can be derived from this lost card.
In our proposed scheme, the pseudo identification in-
formation (k = 1, λi,1, IDi) must be stored in the server
for getting the real identification information of users.
Even if this table is compromised by the attacker, this
scheme is also secure. Only the identification of the user
can be derived by the attacker. In [6], no any table is nec-
essary in the server side, but this scheme does not provide
the user privacy protection mechanism.
6 Conclusions
In this paper, we have proposed two user authentication
and key agreement schemes with privacy protection for
single server and multi-server environments. Regarding
the single-server scheme, it is more simple and efficient.
Regarding the multi-server scheme, users only need to reg-
ister one time and can use all provided services by service
providers. Both our proposed schemes have the ability of
privacy protection. Our schemes also have low commu-
nication and computation cost for user authentication by
only using symmetric cryptosystems and one-way func-
tions. Also, our schemes successfully solve the serious
time-synchronization problem in a distributed computers
environment since our proposed schemes are nonce-based.
Acknowledgments
This work was supported in part by the National Science
Council of the Republic of China under the Grant NSC
 
 
  
Abstract—In 2005, Zhang et al. proposed a novel authentication 
key agreement protocol for 3GPP-AKA protocol. They claim that their 
protocol can withstand the redirection attack, the attack in corrupted 
networks, and can solve the operational difficulty with the sequence 
numbers problem. In wireless communications, identity privacy is an 
important security issue we concern. There are two abnormal cases 
that a mobile station (MS) must send its real identity to a visited 
location register (VLR) when authenticating at location updating. One 
is that VLR can not verify IMSI of MS and the other is that VLR can 
not reach the previously visited VLR. We can find out that the identity 
of the user will be exposed when the adversary carries out the location 
privacy attack at location updating. For preventing the location privacy 
attack, users’ identities must be protected for 3GPP-AKA protocol. 
However, we point out that Zhang et al.’s improved 3GPP-AKA 
protocol is vulnerable to the location privacy attack, having higher 
space overhead on VLR, and having higher bandwidth consumption 
between HLR and VLR. In this paper, we propose an efficient 
authenticated key agreement scheme for 3GPP-AKA to overcome all 
the drawbacks of Zhang et al.’s scheme. 
 
Index Terms—Wireless security, Authentication, Key 
agreement, Privacy protection, Third-generation wireless 
communications 
I. INTRODUCTION 
ITH mobile devices such as cellular phones rising in popularity, 
the security of wireless networking becomes more significant. 
Users can conveniently use variable mobile services via this 
media in his home, corporation or another unfamiliar place. The radio 
interface and wireless services access are two territories, where the 
same level of protection as wired networks is not provided by wireless 
networks. It has lower level security unless more security measures are 
provided. When an illegal user enters an area of a radio interface of a 
network provider, he can intercept the messages over this radio 
interface. It results in some sensitive information about the user to be 
compromised. Besides, an illegal user could pretend a legal user to 
access the wireless network. These problems cause billing controversy 
among mobile users, network providers and service providers. While 
the mobile user roams to an unvisited service network, the service 
network needs to authenticate the mobile user via the mobile user’s 
home network. Over past years, since wireless networking has raised 
many security problems, several improved schemes for authenticated 
key agreement had been proposed [4,6-7,15] in wireless environments. 
 
This work was supported in part by the National Science Council of the 
Republic of China under the Grant NSC 95-2221-E-128-004-MY2, and by the 
Taiwan Information Security Center (TWISC), National Science Council under 
the Grants NSC 95-3114-P-001-001-Y02, NSC 95-3114-P-001-002-Y02, NSC 
95-2218-E-001-001, and NSC 95-2218-E-011-015. 
The authors are with the Department of Information Management, Shih 
Hsin University, Taipei, Taiwan. (corresponding author to provide phone: 
886-2-22368225; fax: 886-2-22367114; e-mail: wsjaung@cc.shu.edu.tw).  
But those protocols are not suitable completely to wireless 
communications for the mobile user.  
The Universal Mobile Telecommunication System (UMTS) has 
adopted the authentication key agreement of the Third-Generation 
Partnership Project (3GPP) [1-3], known as a standard of 
third-generation wireless communications (3G). The 3GPP-AKA 
protocol overcomes some problems of GSM-AKA. The emerging 
UMTS security architecture has some security features, including the 
user identity confidentiality, the user location confidentiality and the 
user untraceability [3]. But the 3GPP-AKA protocol violates the 
properties of the user identity confidentiality and the user location 
confidentiality when the abnormal cases occur at location updating [9]. 
This means that International Mobile Subscriber Identity (IMSI) for 
the mobile user/subscriber could be exposed by the location privacy 
attack [9]. On the other hand, Zhang et al. pointed out that 3GPP-AKA 
is vulnerable to the redirection attack, the attacks in corrupted network 
and having operational difficulty with the sequence numbers problem. 
Thus, they proposed an enhanced 3GPP-AKA protocol to improve 
these drawbacks in 2005 [17]. However, we point out that Zhang et 
al.’s protocol is no ability of identity protection when an attacker 
carries out the location privacy attack [9]. In this paper, we propose a 
novel authentication key agreement protocol for 3GPP. We use a 
temporary key mechanism [10] for reducing the space overhead of 
VLR and the bandwidth consumption is relative lower than Zhang et 
al.’s scheme. Besides, we provide identity protection, which is not 
provided by Zhang et al.’s scheme, when MS receives an identity 
request at location updating. 
The remainder of this paper is organized as follows. In section II, we 
review Zhang et al.’s authentication key agreement protocol for 3GPP. 
In section III, we point out some weaknesses of Zhang et al.’s 
3GPP-AKA scheme. In section IV, we show our proposed scheme 
with identity protection. In section V, we make a comparison of the 
efficiency and security between our scheme and related schemes. In 
section VI, we make a discussion. Finally, we make a conclusion in 
section VII. 
II. REVIEW OF ZHANG ET AL.’S SCHEME  
In 2005, Zhang et al. [17] proposed an enhanced 3GPP authentication 
key agreement protocol, called AP-AKA. They claimed that their 
protocol uses the original framework of 3GPP-AKA protocol and 
withstands some attacks. In [17], there are three cryptographic hashing 
algorithms F(), H(), and G() to be used, where F() and H() are 
functions to generate message authentication codes and G() is a 
function to generate a session key. Let “||” denote the string 
concatenation operation and “⊕” be the exclusive-or operation. Their 
protocol is executed when MS roams to a foreign network. While VLR 
on a foreign network has no available authentication vectors to 
authenticate MS, VLR must request authentication vectors from HLR 
of MS. We describe Zhang et al.’s protocol as follows. 
Step 1. VLR starts the protocol via sending a request to MS via the 
downlink channel. The request includes a random number FRESH. 
Step 2. Upon the receipt of the request from VLR, MS computes the 
authenticator VAC=F(K||FRESH||RND||IDVLR), where RND is a 
Efficient 3GPP Authentication and Key 
Agreement with Robust User Privacy Protection 
Wen-Shenq Juang and Jing-Lin Wu
W 
 
1525-3511/07/$25.00 ©2007 IEEE 
This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the WCNC 2007 proceedings. 
 
 
 
IV. OUR PROPOSED 3GPP-AKA SCHEMES WITH IDENTITY 
PROTECTION 
In this section, we present our proposed authentication and key 
agreement scheme. Like all proposed 3GPP-AKA schemes [1-3,17], 
we assume that each VLR and HLR for a MS will shared a secret key 
and can do secure communication and authentication. Our proposed 
scheme is not only to use a temporary key mechanism [10] to 
authenticate MS and prevent the location privacy attack but it also has 
lower overhead on VLR. Since MS can easily compute the temporary 
key through the shared secret key, VLR can be authenticated by MS 
successfully. Before we describe our proposed 3GPP-AKA scheme, 
some assumptions must be made. In our proposed scheme, we assume 
that MS and HLR share a secret key K. HLR has another master secret 
key x and computes wi=H(x||ri) as a secret token distributed to MS via 
a secure channel, where ri is an ith generated random number by HLR 
for identity protection. The random secret token wi is used when MS 
receives an identity request at location updating. Besides, our 
proposed scheme includes three main cryptographic hashing 
algorithms F(), H(), and G() [12]. F() and H() are functions to generate 
message authentication codes. G() is a function to generate shared 
keys. Since the location privacy attack may occur when MS receiving 
an identity request, our scheme can be divided into two cases to be 
described. One is a normal case, where HLR can send directly a 
temporary key and an authenticator to VLR for authenticating MS. 
The other case is when MS receives an identity request at location 
updating, MS and HLR will perform a special negotiation. Our 
proposed scheme at the normal case is presented in subsection A and 
the process of MS receiving an identity request at location updating is 
presented in subsection B. 
A. Our proposed 3GPP-AKA scheme at a normal case 
In our proposed scheme, it is not only providing the ability of identity 
protection while MS receiving an identity request at location updating 
but our scheme is also lower overhead on VLR and lower bandwidth 
consumption between HLR and VLR. Because of using a temporary 
key mechanism, VLR do not need to store authentication vectors in its 
database. Besides, using a temporary key mechanism, the bandwidth 
consumption of transmitting between HLR and VLR can be improved. 
We will illustrate our scheme as follows. 
Step 1. VLR sends firstly a random number N1 to MS via the 
downlink channel. 
Step 2. Upon receiving N1 from VLR, MS selects a random number 
N2 and generates VAC=F (K||N1||N2||IDVLR), where IDVLR is the real 
identity of VLR. MS sends N2, VAC, TMSI and LAI to VLR via the 
uplink channel. 
Step 3. Upon the receipt of N2, VAC, TMSI and LAI from MS, VLR 
will find the identity IMSI of MS from the previously visited VLR of 
MS. Then, VLR sends N1, N2, VAC, IMSI to HLR in a secure channel. 
Step 4. Upon receiving N1, N2, VAC and IMSI from VLR, HLR tries 
to find out the corresponding identity of MS with the received IMSI. If 
it holds, HLR extracts the corresponding shared key K. Next, HLR 
checks if N1 and N2 are fresh with respect to IMSI and VLR. For 
checking the freshness of N1 and N2, HLR can keep a recently used 
nonces table. If they are not fresh, HLR halts the process of 
authentication. Otherwise, HLR verifies if VAC=F (K||N1||N2||IDVLR). 
If they are different, HLR aborts the connection. Otherwise, HLR 
selects a random RAND and generates a temporary key 
TK=G(K||RAND||VAC) and an authentication token 
AUTH=F(K||RAND||VAC). Next, HLR sends TK, RAND and AUTH via 
a secure channel to VLR.  
Step 5. While receiving TK, RAND and AUTH from HLR via a 
secure channel, VLR keeps the temporary key TK in its database for 
subsequently secure communications. Then, VLR selects another 
random number RAND1, and computes the excepted response 
XRES=F(TK||RAND1)  and authenticator AUTHVLR=F(TK|| 
RAND1||AUTH). VLR stores XRES in its database. Then, VLR sends 
RAND1, RAND and AUTHVLR, AUTH to MS via the downlink  channel. 
Step 6. While receiving RAND1, RAND and AUTHVLR, AUTH from 
VLR, MS verifies if AUTH=F(K||RAND||VAC). If they are not 
identical, MS disconnects the connection. Otherwise, MS computes 
the temporary TK=G(K||RAND||VAC) for subsequent secure 
communications and checks if AUTHVLR=F(TK||RAND1||AUTH). If 
they are not match, MS aborts this connection. Otherwise, HLR and 
VLR is authenticated by MS. MS then generates RES=F(TK||RAND1) 
and sends it to VLR via the uplink channel.   
Step 7. Upon the receipt of RES from MS, VLR checks if XRES and 
RES are identical. If they match, the authentication is accomplished.  
Without authentication vectors, VLR can still authenticate MS since 
VLR can use the temporary key TK, shared with MS, to verify if the 
received RES and the stored XRES in its database match to correctly 
authenticate MS. After the above protocol, when MS wants to use the 
service again in the same VLR, only step 5 and 6 must be executed 
since the temporary key TK has been established. 
B. Our proposed scheme at location updating 
For preventing the location privacy attack [9], if MS receives an 
identity request at location updating from VLR, our protocol at 
location updating will be performed. Now, we will illustrate this 
protocol as follows. 
Step 1. VLR sends an identity request and a random number N3 to 
MS via the downlink channel. 
Step 2. While receiving N3 from VLR, MS extracts the stored secret 
token wi=H(x||ri) and ri from its database, where r1 was stored in MS 
when registering. MS generates Pi=wi⊕IMSI and selects another 
random number N4. Then, MS computes VAC=H(K||N3||N4||IDVLR||wi). 
MS sends Pi, N4, VAC, IDHLR and ri to VLR via the uplink channel. 
Step 3. Upon receiving N4, Pi, VAC, IDHLR and ri, VLR sends Pi, N3, 
N4, VAC and ri to HLR. 
Step 4. Upon the receipt of N3, N4, Pi, VAC, and ri, HLR uses its 
master key x to compute the secret token wi=H(x||ri) and verifies if 
VAC=H(K||N3||N4||IDVLR||wi). If they are not identical, HLR aborts this 
connection. Otherwise, HLR gets the identity 
IMSI=Pi⊕wi=(H(x||ri) ⊕IMSI) ⊕H(x||ri). Then, HLR gets the 
corresponding shared key K with MS. HLR generates a random 
number RAND and selects another random number ri+1 to be used next 
time and computes another secret token wi+1=H(x||ri+1) to be used next 
time. Then, HLR generates Ti+1=H(K||ri+1) ⊕wi+1, 
TK=G(K||RAND||VAC) and AUTH=F(K||RAND||VAC||wi+1). HLR 
sends TK, RAND, Ti+1, AUTH and ri+1 to VLR via a secure channel.  
Step 5. While VLR receiving TK, RAND, Ti+1, AUTH and ri+1, VLR 
chooses a random number RAND1 and computes another authenticator 
AUTHVLR=F(TK|| RAND1||AUTH) and the excepted response 
XRES=F(TK||RAND1). VLR sends RAND1, RAND, Ti+1, AUTHVLR, 
AUTH and ri+1 to MS via the downlink channel. 
Step 6. While receiving RAND1, RAND, Ti+1, AUTHVLR , AUTH and 
ri+1, MS computes the secret token 
wi+1=Ti+1⊕H(K||ri+1)=(H(K||ri+1) ⊕wi+1) ⊕H(K||ri+1). Then, MS 
checks if AUTH=F(K||RAND||VAC||wi+1). If they do not match, MS 
aborts this connection. Otherwise, HLR then computes a temporary 
key TK=G(K||RAND||VAC) and check if 
AUTHVLR=F(TK||RAND1||AUTH). If they are match, MS computes 
RES=F(TK||RAND1). Both HLR and VLR is authenticated by MS. MS 
stores then the secret token wi+1=H(x||ri+1), a random number ri+1 and 
the temporary key TK in its memory. MS sends RES to VLR via the 
uplink channel. 
Step 7. While receiving RES from MS, VLR checks if XRES and 
RES match. If they are not identical, VLR aborts this connection. 
Otherwise, VLR accepts the request and MS is authenticated by VLR 
successfully.  
After the above protocol, when MS wants to use the service again in 
the same VLR, only step 5 and 6 must be executed since the temporary 
This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the WCNC 2007 proceedings. 
 
 
 
secret by MS and HLR. Only MS and HLR can compute correctly the 
temporary key TK unless MS or HLR is compromised. The temporary 
key TK are difficult to be derived, since the entropy of the key K and 
TK are very large. 
3) The replay attack [14] 
The replay attack is replaying the same message of the receiver or the 
sender again. For resisting to the replay attack, we use the nonces to 
prevent this attack. In our scheme, the nonces N1, N2, N3 and N4 are 
used to check whether the messages are replayed by the adversary. If 
the receiver confirms that a nonce is not freshness, he will reject this 
message. 
4) The modification attack [16] 
This attack tends to disturb normal communications between both 
ends. Our scheme can also withstand this attack. The adversary can not 
alter authenticated messages since the adversary can not know the 
shared key K. If a message is modified by the attacker, the receiver will 
know this modified message by checking whether the authenticator is 
correct. If they do not match, the message is modified and receiver will 
reject this message. 
Our scheme Zhang et al. [17]
E1
E2
E3
E4
E5
E6
3GPP-AKA [3]
Table 1. Efficiency comparison between our 3GPP AKA scheme 
and the related schemes at normal case
E1: Memory needed in MS; E2: Memory needed in VLR; E3: Memory 
needed in HLR; E4: Computation cost for MS; E5: Computation cost
for VLR; E6: Computation cost for HLR; H: Hash operation; XOR: 
Exclusive-or operation; n: numbers of authentication vectors
5 H 
3 H 
2 H
512 bits
256 bits
256 bits
5 H 
None
(5 × n) H
128 bits
256 bits
(640+┌ log2n ┐)×n bits
384 bits
128 bits
(640×n) bits
5 H + 1 XOR
n×(5 H + 1 XOR)
None
 
G. Efficiency consideration 
We analyze the efficiency of our scheme and the related schemes 
while MS does not receive an identity request at location updating in 
Table 1. According to [1], the length of K, RAND, XRES, CK, IK and 
AUTH is 128 bits. We assume that 3GPP-AKA the cost of functions 
f1(), f2(), f3(), f4() and f5() is similar to one hash result. In [17] and our 
scheme, we assume that the output size of secure one-way hash 
functions H(), F(), and G() is 128 bits for convenience. In our scheme, 
we also assume that the master key x, the secret token wi=H(x||ri) and 
the random number ri is 128 bits. In our scheme and [17], the needed 
memory in MS is 512 bits and 256 bits, respectively. In [3], the needed 
memory for MS is 384 bits. The needed memory for VLR of our 
scheme is 256 bits. In [3,17], the needed memory for VLR is (640+┌ 
log2n┐)×n bits and (640×n) bits, respectively, where n is the number of 
authentication vectors. In our scheme, the needed memory in HLR is 
256 bits. The needed memory in HLR is 128 bits in [3,17]. The 
computation cost for MS in our scheme and [17] are five hash 
operations. In [3], the computation cost for MS requires five hash 
operations and one exclusive-or operation. In our scheme, the 
computation cost for VLR is two hash operations. In [3,17], VLR do 
not need to compute any information. The computation cost of our 
scheme for HLR is three hash operations. The computation cost for 
HLR of Zhang et al.’s scheme is (5×n) hash operations. But in [3], the 
computation cost for HLR is (5×n) hash operations and n exclusive-or 
operations.  
Our scheme Zhang et al. [17]
E1
E2
E3
E4
E5
E6
3GPP-AKA [3]
6 H + 2 XOR
6 H + 2 XOR
2 H
512 bits
256 bits
256 bits
5 H 
None
(5 × n) H
128 bits
256 bits
(640+┌ log2n ┐)×n bits
384 bits
128 bits
(640×n) bits
5 H + 1 XOR
n×(5 H + 1 XOR)
None
Table 2. Efficiency comparison between our 3GPP AKA scheme 
and the related schemes while MS receiving an identity request
E1: Memory needed in MS; E2: Memory needed in VLR; E3: Memory 
needed in HLR; E4: Computation cost for MS; E5: Computation cost
for VLR; E6: Computation cost for HLR; H: Hash operation; XOR: 
Exclusive-or operation; n: numbers of authentication vectors  
Then, we make an efficiency comparison between our scheme and 
the related schemes while MS receiving an identity request at location 
updating. The comparison is given in Table 2. In our scheme, the 
needed memory for MS is 512 bits. The needed memory for MS is 256 
bits in [17]. In [3], the needed memory for MS is 384 bits. In our 
scheme, the needed memory for VLR is 256 bits. But in [3,17], the 
required memory for VLR is (640+┌ log2n┐)×n bits and (640×n) bits, 
respectively. In our scheme, the needed memory for HLR is 256 bits. 
In [3,17], the required memory for HLR is 128 bits. In our scheme, the 
computation cost for MS is six hash operations and two exclusive-or 
operations. In [17], the computation cost for MS is five hash 
operations. The computation cost in MS needs five hash operations 
and one exclusive-or operation in [3]. The computation cost for VLR 
of our scheme is two hash operations. In [3,17], VLR do not need to 
compute any information. The computation cost for HLR of our 
scheme is six hash operations and two exclusive-or operations. In [17], 
(5×n) hash operations are required for HLR. But in [3], computation 
cost for HLR needs (5×n) hash operations and n exclusive-or 
operation. 
Note that the number n of authentication vector of Zhang et al.’s 
scheme could be set to 1 but the process of authentication between 
VLR and HLR will be busy for every authentication in the same VLR. 
Differ Zhang et al.’s scheme, our proposed scheme, based on a 
temporary key mechanism, do not need to authenticate MS in a long 
term period while MS requesting services in various time. In this way, 
we can embed lifetime of a temporary for specifying when VLR must 
request a new temporary key from HLR. 
We summarize the functionality of our scheme and the related 
schemes in Table 3. Compared with the schemes in [3,17], the listed 
properties are satisfied in our scheme. Zhang et al.’s scheme is not able 
to satisfy the identity privacy property. 3GPP-AKA scheme can also 
not satisfy identity privacy, solving resynchronization problem, and 
prevent the redirection attack and the corrupted network attack. 
Regarding to computation or communication cost, our scheme is 
relatively lower than both the schemes in [3,17]. 
VI. DISCUSSION 
In addition to using exclusive-or operations, the symmetric key 
cryptosystem can also be applied for our scheme to protect the identity 
IMSI of MS. For discussing simply, assume that the phase of checking 
the authenticator is ignored. Instead of Pi=H(x||ri) ⊕IMSI, MS 
computes Pi=E )||( irxH (IMSI) and sends Pi and ri to HLR, where EY() is 
a symmetric encryption function and Y is a symmetric key. Upon 
receiving Pi, HLR then can computes a symmetric decryption key 
wi=H(x||ri) and decrypt the identity IMSI=D )||( irxH (Pi), where DY() is a 
decryption function and Y is a symmetric key. Using this approach, 
This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the WCNC 2007 proceedings. 
 
Efficient GSM Authentication and Key Agreement Protocols with Robust User
Privacy Protection
Jing-Lin Wu, Wen-Shenq Juang and Sian-Teng Chen
Department of Information Management
Shih Hsin University
No. 1, Lane 17, Sec. 1, Muja Rd., Wenshan Chiu,
Taipei, Taiwan, 116, R.O.C
wsjuang@cc.shu.edu.tw
Abstract
Nowadays, GSM is used widely by people around the
world. However, there are also some problems of GSM
authentication to be found. In 2004, Choi et al.
proposed an authentication scheme with user privacy
protection in GSM. They claimed that their scheme can
improve some drawbacks of GSM authentication and
achieve an ability of user privacy protection. But we
point out that Choi et al.’s scheme is not able to achieve
privacy and is not able to resist some well-known
attacks completely. Hence, we propose a more efficient
GSM authentication protocol with robust identity
privacy protection. Our scheme also can remedy all
drawbacks of GSM authentication mentioned by Choi et
al. and resist to well-known attacks.
Keywords: Identity privacy, Mutual authentication,
Network security, Mobile security
1. Introduction
Recently, the wireless networking becomes more
popular and convenient to us. No matter where people
travel to, he can use services provided by service
providers. Radio interface and wireless network access
are two territories, where the same level of protection as
wired networks must be provided, in wireless
communications. When an illegal user enters the
territory of the radio interface of a network provider, he
is easy to intercept the transferred messages over this
radio interface and the sensitive information of the legal
user could be exposed to the adversary. Besides, the
adversary can pretend a legal user to access wireless
network services. These problems may cause bill
controversy among a mobile user, network providers
and service providers. In order to avoid these problems,
a secure authentication protocol must be established
before users use services.
Since the Global System for Mobile
communications (GSM), known as second-generation
digital cellular system (2G), was proposed in several
years ago, it has been widely utilized around the world
so far [5]. GSM authentication key agreement (GSM
AKA) is based on a challenge-response mechanism, but
this mechanism can not achieve mutual authentication.
VLR can easily authenticate MS by the assistance of
HLR, but MS can not authenticate VLR since the
random challenge is only generated by HLR. In addition
to mutual authentication, some drawbacks of GSM
AKA were pointed out and many improved schemes
[3][4][9][10] have been proposed to overcome
weaknesses of GSM AKA. Choi et al. proposed GSM
AKA scheme to overcome some problems of GSM
AKA in 2004 [4], but we point out that some security
problems are still not solved in Choi et al.’s scheme. In
this paper, we propose efficient and robust identity
privacy GSM AKA schemes to improve Choi et al.’s
scheme.
The remainder of this paper is organized as follows.
In section 2, we review Choi et al.’s GSM AKA
protocol. In section 3, we describe some problems of
Choi et al.’s AKA scheme. In section 4, we show our
proposed GSM AKA scheme with robust identity
privacy protection. In section 5, we make a comparison
of the efficiency and security among our scheme and the
other related schemes. In section 6, we make a
discussion. Finally, we make a conclusion.
2. Related works
Before illustrating Choi et al.’s authentication
protocol [5], the notations must be demonstrated. HLR
and VLR represent the home location register and the
visitor location register, respectively. IMSI and TMSI
represent the international mobile subscriber identity
and the temporary mobile subscriber identity. LAI
represents location area identifier. A3(), A5() and A8()
are three main cryptographic algorithms [5], where A3()
indicates an authentication algorithm, A5() indicates an
encryption/decryption algorithm and A8() indicates a
cipher key generation algorithm. Ek() denotes the
encryption function with the symmetric key k via the A5
algorithm. Dk() denotes the decryption function with the
symmetric key k via the A5 algorithm. IDHLR denotes a
unique identification of HLR, IDVLR denotes a unique
identification of VLR, and f() denotes a one-way hash
function. K represents the common shared key between
HLR and MS and Kc denotes the cipher key. “||”
represents the string concatenation symbol and “ ” ⊕
denotes the bitwise exclusive-or operation.
Choi et al.’s proposed the GSM AKA scheme with
privacy is based on the Alias (AL), where AL is a unique
identity of MS for traveling and assigned to the IMSI of
MS one-by-one. HLR assigns this AL to a user when
generation algorithm [5]. Let x be a master secret key
kept secretly by the HLR.
There are two situations for authentication when a
MS wants to use the service including the normal case
and the case while a MS receiving an identity request.
Due to space consideration, we only describe our
modified scheme for the case while a MS receiving an
identity request in Figure 1. The normal case will be
appeared in the full version of this paper. Now, we will
describe our scheme as follows.
Step 1. VLR sends identity request including a
random number N3 to MS through the downlink
channel.
Step 2. While MS receives the identity request and
N3, it firstly extracts the secret token wi=A3(x||ri) and the
random number ri. Then, MS selects a random number
RAND, and computes the authentication tag VAC=
f(K||IDVLR||RAND||N3||wi) and an expected response
SRES1=A3(K||RAND). Then MS generates an encrypted
IMSI by computing Pi=IMSI⊕wi. Next, MS sends Pi,
IDHLR, SRES1, VAC, RAND and ri to VLR through the
uplink channel.
Step 3. Upon receiving Pi, IDHLR, SRES1, VAC,
RAND and ri, VLR stores SRES1 in its database and
sends IDVLR, Pi, VAC, RAND, N3 and ri to HLR via a
secure channel.
Step 4. When receiving IDVLR, Pi, VAC, RAND, N3
and ri, HLR firstly checks if the nonces RAND and N3
are fresh. HLR can keep a recently used nonces table for
checking freshness. If they are fresh, HLR calculates the
secret token wi=A3(x||ri) and gets IMSI by computing
Pi⊕wi =(IMSI⊕wi)⊕wi =IMSI. Then, HLR can derive
the shared key K and verifies if VAC=f(K||IDVLR||
RAND||N3||wi). If they are not identical, HLR halts this
connection. Otherwise, HLR computes a temporary key
TK=A8(K||RAND) and an expected response
SRES2=A3(K||RAND). HLR then selects a random
number N4 and another random number ri+1 for being
used next time, and generates a secret token
wi+1=A3(x||ri+1) to be used next time and a message of
concealed secret token Ti+1=wi+1⊕A3(K||ri+1). Next,
HLR generates an authenticator MAC=f(K||N4||VAC||wi+1)
and an encrypted message EVH(IMSI||TK||SRES2||
Ti+1||MAC||ri+1), where VH is shared key with VLR.
HLR sends N4, EVH(IMSI||TK||SRES2||Ti+1||MAC||N4||ri+1)
to VLR.
Step 5. While receiving N4, EVH(IMSI||TK||
SRES2||Ti+1||MAC||N4||ri+1), VLR decrypts the message
by using the shared key VH. Then, it verifies if
SRES1=SRES2. If they are not match, VLR aborts this
connection. Otherwise, VLR keeps the temporary key
TK in its database and computes another authenticator
AUTH =f(TK||TMSInew||MAC), where TMSInew is a new
assigned temporary identity by VLR. Then, VLR sends
AUTH, Ti+1, ri+1, MAC, N4 and an encrypted message
ETK(TMSInew), where ETK() is using the A5 as the
encryption algorithm with the temporary key TK.
Step 6. After receiving AUTH, Ti+1, ri+1, MAC, N4,
and ETK(TMSInew), MS computes the secret token
wi+1 = Ti+1 ⊕ A3(K||ri+1) =wi+1⊕A3(K||ri+1))⊕A3(K||
ri+1) to be used next time and verifies if MAC=
f(K||N4||VAC||wi+1). If they are not match, MS halts this
connection. Otherwise, MS stores the secret token wi+1
and the random number ri+1 for being used next time. If
it is valid, MS computes the temporary key
TK=A8(K||RAND) and decrypts ETK(TMSInew) and gets
TMSInew. Next, MS verifies authenticators MAC=f(K||
N4||VAC||wi+1) and AUTH=f(TK||TMSI||MAC). If they are
identical, HLR and VLR are authenticated by MS and
the process of authentication is accomplished.
MS
4. N4, EVH (IMSI||TK||SRES2||Ti+1||MAC||ri+1)
5. AUTH, Ti+1, ri+1, MAC, N4, ETK(TMSInew)
2. Pi, IDHLR, SRES1, VAC, RAND, ri
1. N3
Figure 1. Our proposed GSM AKA authentication while MS
receiving an identity request
Identity request
3. IDVLR , Pi, SRES1,VAC, RAND, ri
VLR HLR
5. Security analysis and performance
consideration
5.1 Identity privacy
In [4], Choi et al claimed that their proposed GSM
AKA scheme can achieve identity privacy. But the
adversary can still know wherever location the same MS
is while sending an identity request to the same MS via
the alias AL during various times. Hence, we propose a
more strong GSM AKA scheme with identity privacy
protection by using the secret token wi=A3(x||ri) and the
random number ri to protect IMSI. We generates the
concealed message Pi=IMSI⊕wi for achieving location
privacy. Nobody, except HLR, can generate the secret
token wi=A3(x||ri). If the adversary eavesdrops the
concealed message Pi and the random number ri, the
adversary is also impossible to obtain IMSI without the
master key x kept secretly by HLR. Thus, compared
with [4], our schemes provide more robust location
privacy by using the secret token wi=A3(x||ri).
5.2 Mutual authentication
The goal of mutual authentication is that MS and
VLR establish an agreed temporary key TK and MS and
VLR can authenticate each other with the assistance of
HLR. In our scheme, we assume that the temporary key
TK is a kind of session keys to be used for a valid period.
Let A TK B denote that A and B share a common
session key TK. The mutual authentication is
accomplished between A and B if there exists an TK
such that A believes A TK B and B believes
A TK B for the transaction [1][6][7][8]. A strong
mutual authentication should include the following
request is shown in Table 1. In our scheme, the memory
needed for MS is 352 bits. In [3] and [10], the memory
needed for MS is 128 bits and 832 bits, respectively.
The memory needed for MS in [4] and [5] is 192 bits.
The memory needed for VLR is 160 bits in our scheme
and [4]. In [3] and [10], the memory needed for VLR is
146 bits. The memory required for VLR is (224n) bits
in [5]. In our scheme, the memory needed for HLR is
320 bits. In [3] and [5], the memory needed for HLR is
128 bits. In [4], the memory needed for HLR is 192 bits.
The memory needed for HLR is 640 bits in [10].
The computation cost for MS is one decryption
operation, six hash operations and two exclusive-or
operations in our scheme. The computation cost of MS
is two encryption operations and two hash operations in
[3]. In [4], the computation cost of MS is one encryption
operation, one decryption operation and three hash
operations. The computation cost for MS in [10] is one
exponential operation, one encryption and three hash
operations. The computation cost for MS in [5] is one
decryption operation and two hash operations. In our
scheme, the computation cost of VLR is one encryption
operation, one decryption operation and one hash
operation. Two encryption operations and one
decryption operation is required for VLR in [4]. In [3]
and [10], the computation cost for VLR is two
encryptions and one encryption operation, respectively.
Only one encryption operation is needed for VLR in [5].
The computation cost on HLR in our scheme is one
encryption operation, seven hash operations and two
exclusive-or operations. The computation cost of HLR
in [3] is two hash operations. However, in [4], the
computation cost for HLR is one encryption operation,
two decryption operations and three hash operations. In
[10], one exponential operation and two hash operations
are needed for HLR. However, (2n) hash operations
are required for HLR in [5].
E1
Our scheme
E2 E3 E4 E5 E6
1Sym+6H+2
XOR
1Sym+7H
+2XOR
2Sym+1H352 bits 320 bits160 bits
E1: Memory needed in MS; E2: Memory needed in VLR; E3: Memory ne eded in HLR; E4:
Computation cost for MS; E5: Computation cost for VLR; E6: Compu tation cost for HLR;
Exp: Exponential operation; Sym: Symmetric encryption/decryption operation; H: Hash
operation; XOR: Exclusive-or operation; n: numbers of authentication vectors.
GSM [5] 1 Sym + 2 H 1Sym (2n)H128 bits192 bits (224n) bits
Chang et al. [3] 2Sym+2H 2Sym 2H128 bits128 bits 146 bits
Peinado [10] 1Exp+1Sym
+3H
1Sym 1Exp+2H640 bits832 bits 146 bits
Choi et al. [4] 2Sym+3H 3Sym 3Sym+3H192 bits192 bits 160 bits
Table 1. Efficiency comparison among our 3GPP AKA scheme and the other
related schemes while MS receiving an identity req uest
Note that the encryption of TMSI using the
encryption key Kci through the A5 algorithm on the
VLR’s side and the decryption of TMSI using the 
decryption key Kci through the A5 algorithm on the
MS’s side are included in the computation cost in the
related GSM AKA protocols for the comparison.
We summarize the functionality of our scheme and
the related schemes in Table 2. In compared to Chang et
al.’s scheme [3], it is not able to provide identity privacy,
and not able to withstand the redirection attack and the
corrupted network attack. Besides, the modification
attack on Chang et al.’s scheme is not available (N/A)
since their scheme assumes that the new TMSI is
already assigned to MS before the authentication phase.
Compared with Choi et al.’s scheme [4], Choi et al.’s 
scheme is not able to prevent the redirection attack, the
corrupted network attack, the replay attack and the
modification attack. In addition, Choi et al.’s scheme 
only achieves weak identity privacy. Compared with
[10], even though their scheme provides identity privacy
but their scheme has not great performance since using
public key cryptography. Beside, Peinado’s scheme [10]
can not resist to the redirection attack and the corrupted
network attack, and have time synchronization problem.
Note that the modification attack on encrypted TMSI is
not available (N/A) since Peinado’s scheme uses an
encrypted ticket from HLR to replace with a new
assigned TMSI by the visited VLR. Regarding to
computation or communication cost, since using the
temporary key mechanism, our scheme and other related
schemes [3][4] are more lower than the schemes [5][10].
Our scheme satisfies all property of the listed and has
relatively great performance.
Our scheme Chang et al. [3]
C1
C2
C3
C4
C1: The computation cost for MS; C2: The computation cost for HL R; C3:
The computation cost for VLR; C4: The communication cost between
HLR and VLR; C5: The space overhead for VLR; S1: Identity priva cy; S2:
Mutual authentication between MS and VLR; S3: Preventing the rep lay
attack S4: Preventing the redirection attack; S5: Preventing the corrupted
network attack; S6: Preventing the modification attack while VLR assigns
a new TMSI; S7: No time synchronization problem.
C5
S1
S2
S3
Low Low
Yes
Low
Low
LowLow
Low Low
Low
Low
Yes
Yes No
S4
S5
Yes
Yes
S6 Yes N/A
Yes
Yes
No
No
GSM [5]
Low
High
High
Low
High
No
No
No
No
No
No
Low
Low
Low
Low
Low
Partial
No
Yes
No
No
No
Choi et al. [4] Peinado [10]
High
Low
Low
Low
High
Yes
N/A
Yes
Yes
No
No
S7 Yes Yes YesYes No
Table 2. Functionality comparison among our GSM AKA and
the other related GSM AKA schemes
6. Discussion
In this section, we discuss our proposed schemes for
more detailed considerations in advance. Instead of
using the exclusive-or operation, we also provide more
robust identity privacy of MS in GSM AKA protocols.
Besides, we focus on the lifetime of the temporary key
and make more detailed demonstrations.
In our proposed GSM AKA protocol, we use the
secret token wi =A3(x||ri) to protect IMSI of MS by
computing the message Pi=IMSI⊕wi. First of all, for
convenience to demonstrate, we assume that the
approach of checking the authenticator is ignored.
Instead of using Pi=IMSI⊕wi, MS generates an secret
token wi=A3(x||ri) as a symmetric encryption key and an
encrypted message Pi =
iw
E (IMSI), where Ey() is a
A High Security Authentication Mechanism for
3G/WLAN Networks
Horng-Twu Liaw1 and Wen-Shenq Juang2
Department of Information Management1
Shih Hsin University
Taipei, Taiwan
htliaw@cc.shu.edu.tw
Department of Information Management2
National Kaohsiung First University of Science and Technology
Kaohsiung, Taiwan
wsjuang@ccms.nkfust.edu.tw
Abstract. Because of the more and more services wireless communication
technology can offer nowadays, the quality of wireless communication became an
important key. In this research, 3G/UMTS and WLAN, which are two major wireless
communication techniques will be mentioned mainly. The former offers a wide-range,
high-movability, complete and safe record of accounting; the latter offers a narrow-
range, low-movability, high-speed-transmission access on the Internet. The
complementary between these two techniques can not only enhance the quality of
wireless communication but offer more services for customers to choose, and
customers can use wireless application services regardless of any environmental limit.
This research will focus on the problem of fast-handover when 3G/UMTS and
WLAN is interworking, such as authentication and authorization. About the two
formers, we will use W-SKE to accomplish authentication procedure, and achieve
safer Mutual Full Authentication and Fast-Authentication.
Keywords: 3G/UMTS, WLAN, Interworking, Authentication
1 Introduction
The mobile communication technologies have become more and more popular in
recent years, and cell phone service is an important example among kinds of mobile
communication. People can contact with each other by cell phone anytime and
anywhere even if they are traveling by train or walking on the street. Third-generation
mobile system(3G) like Universal Mobile Telecommunication System (UMTS) will
improve data capacity and make data rates up to 2Mb/s. In addition, 3G systems are
expected to provide new applications such as videophone or video streaming.
2 Related Cryptographic Schemes
In this section, we shall introduce some related cryptographic that involves our
study. Those are Keyed-Hash Message Authentication Code (HMAC), Hash-chaining
techniques, Challenge-Response and Symmetric key Encryption.
2.1 Keyed-Hash Message Authentication Code (HMAC)
The Message Authentication Codes (MAC) mechanism is used between two
parts that share a secret key in order to validate information transmitted between
them, and the MAC mechanism based on cryptographic hash function are called as
HMAC[13]. The HMAC can be used with any iterative cryptographic hash function,
e.g. MD5[14], SHA-1[15], in combination with a secret shared key. In other words,
the two parts that share secret key can use HMAC to achieve the message integrity
checks.
2.2 One-way Hashed Chain
A one-way hashed chain is composed of serial hashed values. The chain has the
properties of one-way. In 1981, Lamport proposed a one-way hashed chain
technique[12]; the hash chaining technique has been used in many application
[16][17][18]. Now we introduce the computation of the chain as follows. First, let h(s)
become a one-way function and compute hm(s)= h(h...(h(s))...)), and next, generate a
digital signature of hm(s) and send to authenticator. When the mobile node login the
system, the mobile node sends the ith password which equal hm-i(s) , so the mobile
node can prove itself to authenticator for m times and generate one time password in
each authentication. On the other hand, each hash-chaining value can be taken as the
non-repudiation evidence.
2.3 Challenge-Response Mechanism
The Authentication protocol proposed for the wireless mobile communication
systems are based on the challenge-response mechanism using the symmetric-key
encryption. An instance is: an identity of mobile node (MN) is denoted by ID, and f()
is a symmetric-key encryption function. Based on a random challenge r sent from the
authentication server(AS) on the network side, the MN sends its identity ID and the
response f(k,r) to the AS, where k is a secret key of the MN shared with the AS
beforehand. The AS finds the MN’s secret key k from its database, and completes the
authentication to the mobile subscriber by verifying f(k,r). The advantage can be
easily performed by MN with low computational, but not easy to maintain and waste
resources the database containing the secret keys of MNs.
2.4 Symmetric Cryptosystem
The symmetric cryptosystem utilizes the same key to encrypt the plaintext and
decrypt the ciphertext. Naturally, the sender and the receiver have to share this key
before the symmetric cryptosystem process which provided a much faster and more
efficient solution than other methods, such as asymmetric cryptosystem. Currently,
there are many well-known symmetric cryptosystems, such as DES[19] and AES[20].
4. Proposed Mechanism
In this section we propose a new authentication mechanism based on
challenge/response, HMAC and one-way hashed chain. Our protocols greatly improve
the security and the communication performance.
4.1 Network Architecture
The network architecture as shown in Figure.1 is considered for 3G/UMTS and
WLAN interworking in this study, MN denotes mobile node, H-AAA denotes home
AAA server of a mobile user MN, and F-AAA denotes foreign AAA server of the
WLAN that a MN wants to visit. The F-AAA and the H-AAA belong to separate
providers called AAA Brokers; those should be the association between the H-AAA
and the F-AAA. The AAA Brokers sets up reliable security associations and routes
AAA messages to the H-AAA.
Internet
802.11
Network
Router
F-AAA
Home Network
(3G Carrier Network)
AAA Broker Network
Proxy
AAA
Proxy
AAA AAA
Peering
H-AAA
MN
MN
AP
AP
Figure 1. The network architecture for 3G/UMTS and WLAN interworking
Our authentication model is based on Salgerelli’s work [6]. The authentication
model directly corresponds to network architecture in previous section. Figure.2
illustrates the various network entities involved in the authentication procedure. In
order to authenticate and/or protect data in transit between X and Y, a security
association AX,Y should be set up and can be defined as the combination of the nodes’
identity information(e.g. IMSI, NAI), some form of cryptographic key(e.g. public
keys, pre-shared symmetric key), and information on cryptographic algorithms to be
used. Each AS maintains a preconfigured security association AAS,F-AAA with its F-
AAA server, other AX,Y same meanings. In the 3G/WLAN interworking, F-AAA and
H-AAA may belong to separate service providers, and then an association has to be
set up via an AAA broker or pair-wise relationship should be setup part of roaming
agreement.
MACHM=HMACk(RANDM,IMSI)
4 The MN send the EAP Response/Identity message to AS, which involves IDH,
PIDM, RANDM, and MACHM.
5 The AS sends the EAP Response/Identity message to F-AAA, the ASID append to
the message.
6 F-AAA computes MACHF=HMACf (RANDF,IDF), in order to make the MN easy to
verity H-AAA legally.
7 The F-AAA sends the EAP Response/Identity message to H-AAA.
8 The H-AAA first checks whether the MN access profile is available. If not, the H-
AAA was rejected by the MN.
8.1 The H-AAA uses the pre-shared key and the received RANDM, RANDF , IDF,
IMSI to verity MN and F-AAA legally.
8.2 If verity failed, the will be rejected. Otherwise, the H-AAA generates random
seed RANDH to compute ks = fk(RANDM⊕RANDH).
8.3 After generating the authentication hash chaining, the H-AAA computes
xAUTH purpose to avoid falsity message.
8.4 The H-AAA computes the authentication hash-chain value xAHCiH and xAHC
j
F,
in order to make the MN easy to re-authentication by the H-AAA and the F-
AAA(the i and j indicates the hash time; and it can be adjusted on demand). Show
as follows:
xAHCiH=Hash
i(xAHC1H)
xAHCjF=Hash
j(xAHC1F)
8.5 The H-AAA computes the session key between the MN and the F-AAA,
shown as follows:
KMN-F =PRFKs(xAHC
i
H)
8.6 The H-AAA computes xMACFH for the purpose of the F-AAA avoid falsity
message from the malice attacker.
8.7 The H-AAA keeps TIDM and Ks, which have replaced PIDM and k for next
time of full authentication protocol.
9 The H-AAA sends the EAP success message to the F-AAA.
10 The F-AAA preserve xAHCjF, KMN-F and TIDM after receiving the EAP success
message. Among xAHC
j
F is the hash-chain value when MN and AS process re-
authentication protocol, KMN-F is a session key between the MN and the F-AAA;
TIDM will not be using PIDM at the time of full-authentication next-time, in order
to be anonymous.
10.1 The F-AAA proves whether xMACFH=?MACFH is equal from the H-AAA. If
the F-AAA is not with the secret key pre-shared f , it will fail to verity.
10.2 The F-AAA computes xMACFA for the purpose that make MN avoid falsity
message from the malice attacker.
10.3 The F-AAA computes the session key between the MN and the AS as shown
follows:
KMN-AS =
,MN FK
PRF (xAHCjF)
11 After the F-AAA forwards successful authentication message to the AS.
12 The AS preserve the KMN-AS, TIDM for the ease of transmission between the MN
and the AS.
13 The AS forwards the EAP success message to the MN.
14 The MN obtains the RANDH from the H-AAA and the RANDM producted when
MN requests for authentication. Then computes to the secret key KS produce
between the H-AAA and the MN of authentication time, shown as follows:
KS=fk(RANDM⊕RANDH)
14.1 The MN generates a new temporary identity TIDM=Hash(RANDM ⊕
RANDH,IMSI).
14.2 The MN computes the first authentication hash-chain value xAHC o as per
Eq.8.4
14.3 The MN computes the authentication hash-chain value xAHCiH and xAHC
j
F as
per Eq.8.6
14.4 The MN computes the session key KMN-F as per Eq.8.7
14.5 The MN computes the session key KMN-AS as per Eq.10.3
14.6 The MN verity xAUTH in order to avoid falsity message from the malice
attacker, show as follows as per Eq.8.5
14.7 The MN computes xMACFA for the purpose that make the MN avoid falsity
message from the malice attacker, show as follows as per Eq.10.2
14.8 The MN keeps TIDM and Ks which have replace PIDM and k for next time of
full authentication protocol.
In this step, the MN and the H-AAA successfully authenticate each other.
4.3.2 Fast Re-Authentication Protocol of the F-AAA
Here we depict the detailed successful re-authentication of the F-AAA. The MN
and the F-AAA share a session-key KMS,F which made the re-authenticate key. In the
step of the n-th re-authentication, j is limited for the number of F-AAA re-
authentication times, and j-n number of re-authentication times once left. Figure 4
illustrates this protocol; when the MN accesses the F-AAA which belongs to the
3GPP visit network, the authentication mechanism is also based on the hash chaining
technique. The MN presents its identity TIDM ,and the MN computes AHC
j-n
F , then
sends the result to the F-AAA. After this F-AAA verifies the Hash (xAHCj-
n+1
F)=?AHC
j-n
F ; If passing, it means the F-AAA has authenticated the MN. The AHC
j-
n
F is stored for the next authentication and for the non-repudiation evidence.
Afterwards, the
F-AAA responses to a challenge xMACFA=
,MN FK
HMAC (xAHCj-nF, ASID* ) , and
computes new session key KMN-AS =
MN FK
PRF

(xAHCj-nF). On the other hand, the
xMACFA and KMN-AS are sent to the WLAP AS; the AS keeps the KMN-AS which is used
as dynamic WEP key, and forwarded the xMACFA to the MN. The MN first verifies
the xMACFA. If passing, it means the MN has authenticated the F-AAA server. Next,
the MN derives the KMN-AS =
MN FK
PRF

(xAHCj-nF). Eventually, the mutual
authentication has been successfully completed and the WEP key has been
confidentially delivered. The Fast Re-Authentication Protocol of the F-AAA as shown
in Figure.4
means the MN has authenticated the New AS. Next, the MN produces the new
session KMN-AS**. Finally, the mutual authentication has been successfully completed
and the WEP key has been confidentially delivered.
5. Security Analysis
In this section, we will show our mechanism can preclude several attacks,
according to Byzantine insiders, which indicates the network elements belong to
independent service provider that are not trusted fully because it have a direct or
indirect security association between each other. The Security Analysis as shown in
Table.1
 Prevent Guessing Attack：In full authentication protocol, the Secret Key Pre-
shared k between the H-AAA and the MN, are for authentication purpose.
Therefore, it is possible for an attacker to reveal the Secret key Pre-shared k from
the known information. However, the k is impossible to derive it during a
reasonable time which is at least 128bits. Utilizing one time password of AHCi-m
and AHCj-n to upgrade session key in fast authentication, it is invalid to obtain
session key KWEP.
 Prevent Replay Attack：In full authentication protocol, it is the situation where
an attacker intercepts {IDH, PIDM, RANDM , MACHM} sent by the MN in step4
and uses it to masquerade as the MN to send the authentication request next time.
Though RANDM is generated by the MN, the malice attacker don’t knowing the
Secret Key Pre-shared k between the H-AAA and the MN, and it can’t respond
the correct MACHM and AUTH to the H-AAA and the MN both. On the other
hand, the authentication hash chaining value AHC of fast re-authentication will
be used only once, to replay the AHC will not pass the authentication.
 Prevent Impersonation Attack：The malice attacker attempts to impersonate the
MN to access the WLAN. In full authentication protocol, MACHM =
HMACk(RANDM,IMSI) is encrypted with a pre-shared secret k; hence without
secret key k, it can’t impersonate the MN. In fast re-authentication, the attacker
cannot compute xAHCiH=Hash
i(xAHC1H) or xAHC
j
F=Hash
j(xAHC1F) to
impersonate the MN, because the Pre-shared Secret Key k is only known by the
MN-self and the AHC1 has been securely sent to the H-AAA by the MN in full
authentication. In this case, the attacker can’t compute backward the
authentication hash chaining value AHC.
 Prevent WEP weakness attack：The WEP key congenital disadvantage in the
gold key IV value is not enough and easy to analyze and explain for the Brute-
Force attack in length,since the WEP key is also renewed in each full
authentication of fast re-authentication protocol. Therefore, our mechanism can
overcome the weakness of the original WEP.
 Prevent Forward Secrecy and Backward Secrecy to possible attacks：One
session key/secret key will not lead to the compromise of the past session
key/secret key and the corresponding transmission because one key follows the
form of randomness, the one-way property of hashing chains and the session key
pre-shared between each other. Thus, each session key/secret key is random and
TMS,AS denote the one between MS and AS. According to the number of authentication
time, we can see that TF-AAA,H-AAA > TF-AAA,AS > TMS,AS . Table.2 shows The Performance
Analysis comparison among our mechanism, EAP-AKA, W-SKE and IDKE. The
authentication latency of our full authentication is 2TF-AAA,H-AAA + 2TF-AAA,AS + 4TMS,AS ,
EAP-AKA is 4TF-AAA,H-AAA + 8TF-AAA,AS + 10TMS,AS ; W-SKE is 2TF-AAA,H-AAA + 4TF-AAA,AS
+ 6TMS,AS ; but IDKE doesn’t point out this method. Moreover, in terms of fast re-
authentication, our scheme is 2TF-AAA,AS + 4TMS,AS ; EAP-AKA is 6TF-AAA,AS + 8TMS,AS ;
IDKE is 2TF-AAA,AS + 4TMS,AS ; while W-SKE doesn’t mention it . If the time of
handover for authentication or re-authentication protocol is overlong, it will cause to
lose the packages. Our mechanism can shorten the authentication time delay.
7. Conclusions and Future Works
In our mechanism, we discuss about the security and authentication protocol for
WLAN and 3G/UMTS interworking. Three state-of-the–art authentication protocols
for integrated 3G/WLAN networks: EAP-AKA, W-SKE and IDKE, have been
examined, and shown the security weaknesses of W-SKE, the in-efficiency of EAP-
AKA, and integrate localized re-authentication of IDKE. Based on Keyed-Hash
Message Authentication Code (HMAC), Hash-chaining techniques, Challenge-
Response and Symmetric key Encryption, we have figured out a new authenticated
key exchange protocol. We propose a robust authentication protocol which can
perform efficient localized re-authentication procedure, provide non-repudiation
service, solve the problems of losing packages, shorten the authentication time delay
and greatly improve the security.
In our future work, we hope we will be able to solve Denial of Service (DoS)
attacks to improve the security. On the other hand, we also expect to do a more in-
depth research focused on the handover mechanism, roaming management, packet
forwarding and transmission in the future days.
References
[1]. 3GPP TR 22.934, “Feasibility study on 3GPP system to Wireless Local Area
Network(WLAN) interworking (Release 6)”, September 30, 2003
[2]. 3GPP TS 22.234, “3GPP system to Wireless Local Area Network(WLAN)
Interworking, System description (Release 6)”. September 2004.
[3]. 3GPP TS 33.234, “3G Securtiy; Wireless Local Area Network(WLAN)
interworking security (Release 7)”, June 2006
[4]. M.Buddhikot, G.Chandranmenon, S.Han, Y.W.Lee, S.Miller, and L.Salgarelli,
“Integration of 802.11 and Third-Generation Wireless Data Networks”. In
Proceedings of the IEEE INFOCOM’03, April 2003
[5]. J.Zhu, J.Ma, “A New Authentciation Scheme with Anonymity for Wireless
Envioronments”, Member, IEEE, 2004
[6]. L.Salgrelli, M.Buddhikot, J.Garay, S.Patel, S.Miller, “Efficient Authentication
and Key Distribution in Wireless IP Networks”, Bell Laboratories, Lucent
Technologies, IEEE Wireless Communication, December 2003
A Lightweight Key Agreement Protocol with User Anonymity in Ubiquitous
Computing Environments
Ren-Chiun Wang 
Department of Electrical Engineering 
National Taiwan University
No. 1, Sec. 4, Roosevelt Rd., Taipei, Taiwan 106, R.O.C.
 chiunchiunwang, bipa@fractal.ee.ntu.edu.tw
Wen-Shenq Juang
Department of Information Management
Shih-Hsin University
No. 1, Lane17, Sec. 1, Mu-Cha Rd., Taipei , Taiwan 116, R.O.C.
wsjuang@cc.shu.edu.tw
Chen-Chi Wu 
Chin-Laung Lei
Department of Electrical Engineering
National Taiwan University
No. 1, Sec. 4, Roosevelt Rd., Taipei, Taiwan 106, R.O.C.
lei@cc.ee.ntu.edu.tw
Abstract
In a smart living environment, a person can use vari-
ous intelligent devices to obtain his desired services at any
time and any place. For convenience, most of these devices
are small and of limited power and computation capacity.
Therefore, an admired protocol should take these into con-
sideration. In particular, identification and key agreement
are basic mechanisms when a user wants to get a secure
service from a server over the public networks. However,
if the user’s identity is transmitted in a plaintext, an adver-
sary can intercept the information and use it to launch some
attacks. In this paper, we propose a key agreement protocol
with user anonymity based on elliptic curve discrete loga-
rithm problem. In our protocol, the storage and computa-
tion costs are very low and the server does not maintain a
password file for identifying the users. Therefore, our pro-
tocol is suitable for applying ubiquitous computing environ-
ments.
1. Introduction
In ubiquitous computing environments, each user can
use many computers to obtain his service at any time and
any place without knowing how to use these computers
[2, 8, 20]. These computers could have a low communica-
tion and computation capability. When a user wants to get
a permitted service from a server, authentication and key a-
greement are basic mechanisms. Many protocols with their
applications and network security threats were proposed
and discussed [3, 5, 6, 7, 8, 9, 10, 11, 19, 20, 21, 23, 25]. For
protecting the communications between the users and the
servers, the human-memorable password [5, 6, 15, 16, 24],
the well-known Diffie-Hellman [4] and RSA [17] algo-
rithms are often adapted.
In the previous authentication and key agreement proto-
cols, some scholars found that if the identity of the user is
exposed over the public networks, this user easily becomes
a target of malicious attackers. Protecting the identity of the
user in a network is an important issue [1].
In 2000, Lee and Chang [13] proposed an RSA-based
user identification and key distribution protocol for main-
2007 International Conference on Multimedia and Ubiquitous Engineering(MUE'07)
0-7695-2777-9/07 $20.00  © 2007
Step 4. The server computes their session key 


= 
 mod
 and uses it to compute 


(), and to get 

.
If it holds for some 

existing in the identity list,
the server continues to check whether    
 


mod  is equal to   mod  . If it is true, the server
accepts this login request; otherwise, the server denies
this login request.
		      
In the SIKA protocol, the format of a valid client’s i-
dentity does not be clearly defined. In small scale systems,
if the length of identity is short for saving the storage and
communication cost, it is possible that the forgery attack
can work on the SIKA protocol. We will show these attacks
in the following.
Step a. If the identities of two valid clients  and  satisfy


  

 

mod  , the  can impersonate
 to obtain the service from the server. Note that the 
first compute 

 

  

mod and checks if


mod exists in the identity list.
Step b.  sends a service request to the server and gets a re-
sponse (,  , ) back.
Step c. Then,  computes  =     

= 
 mod  , 


= 
 mod  ,  =  mod  ,  = 	


(

) and   =


 (  

) mod  .  sends (, ,  ,  ) back
to the server, where  is a random number and   is
’s login time.
Step d. The server computes their session key 


= 
 mod
 and uses it to compute 


(), and to get 

.
If it holds for some 

existing in the identity list,
the server continues to check whether    
 


mod  is equal to   mod  . If it is true, the server
accepts this login request; otherwise, the login request
is denied. We can find    
 


= 

  

 


mod and   =    
 


  

 


mod .
We know       mod  and       mod
 , therefore the client ’s service request can pass the
verification of the server and impersonate  to obtain
the service.
In an extension of our attack, if the identities of two valid
clients  and  satisfy 

  

 

mod  , they
can cooperate to impersonate  to obtain the service from
the server without revealing their secret tokens. When the
 wants to impersonate  to get the service, the  selects
a random number  and computes  =   mod  , session
key =  mod ,  =	

(

) and =   

mod . Then sends  = 
 


mod to. Final-
ly, the  can calculate   =      mod and sends (, ,
 , 
) to the server. By the Step d, we can find the client’s
login request can pass the verification of the server and ob-
tain the permitted service. If there are
 conspirators, then
we can get  

valid clients who could suffer from this
threat.
3. Our protocol
In this section, we propose a lightweight key agreement
protocol with user anonymity based on the elliptic curve
discrete logarithm problem.
Key generation phase
Step 1. The SCPC chooses a large prime number   and an el-
liptic curve equation 	

:  =  +  +  over 

,
where  and  are field elements in 

and satisfy 4
+ 27 mod     0. G is a generator point of a large
order.
Step 2. The SCPC selects a random number 

in  

, com-
putes a corresponding public key 

= 

 G, and
issues 

to each registered users (clients and server-
s). Each user will hold his secret key 

. Finally, the
SCPC publishes a public key table which contains the
identities and the public keys of the registered users.
Note that the server’s identity is known to each client
and its public key can be found in the public key table.
We use table 1 to describe it.
Table 1. Public key table
Identity Public key

 

 
=
 
 




=

 
... ...




=

 
Anonymous user identification and key agreement
phase
Step 1. The client selects a random number 
 
in  

and gets
the server’s public key 

=

 G from the public
key table. Then the client computes
 
= 
 
 

and 
 
= 
 
 G. The client uses 
 
to compute
!
 
= 	

 
(

, "#
 
). Finally, the user sends a
$%& %$ = (
 
,!
 
) to the server.
Step 2. After receiving the service request, the server com-
putes 
 
= 
 
 

and uses it to compute


 
(!
 
), and to get (

, "#
 
). Finally, the
server verifies whether the 

exists in the public key
table. If not, the service request is denied; otherwise,
the server selects a random number 

in  

and gets
2007 International Conference on Multimedia and Ubiquitous Engineering(MUE'07)
0-7695-2777-9/07 $20.00  © 2007
of elliptic curve discrete logarithm problem for obtaining
the secret keys and use them to send fake messages. We
know it is very hard to solve the difficulty of elliptic curve
discrete logarithm problem.
Perfect forward secrecy
If one secret key of the client or the server is com-
promised by the adversary, the adversary can decrypt
the service request or !

. The adversary still can not
deduce the past common session keys H(

) from the
intercepted and decrypted messages without the secret
exponents of 
 
and 

. The adversary has to solve the
elliptic curve discrete logarithm problem.
Anonymity
The identity of the client is involved in Step 1 of the
anonymous user identification and key agreement phase.
However, we know !
 
is an encrypted message by using

 
, no one can decrypt it without the server’s private key


.
	  
In this section, we compare the computation cost and
functionality with the related protocols for evaluating our
protocol.
4.2.1 Efficiency comparison
Assume that 

denotes the time of one-way hashing oper-
ation, 

denotes the time of one exponential operation,

 
denotes the time of one modular inverse oper-
ation, 

denotes the time of one symmetric encryption
or decryption, 

denotes the time for one modular multi-
plication, and 


denotes the time for the multiplication
of a number over an elliptic curve.
In our protocol, the computation cost of the client is 3

+ 3


+ 2

that is very low. We use table 2 to show
that our comparison.
4.2.2 Functionality comparison
We use table 3 to show that our functionality comparison
with the related protocols.
5. Conclusion
In this paper, we have shown that the forgery attack for
the SIKA protocol. Then, we have proposed a lightweight
key agreement protocol with user anonymity based on the
elliptic curve discrete logarithm problem. Three attractive
features are included in our protocol that are: (1) each us-
er only needs to maintain his secret token and can use it to
Table 2. Comparisons of the computation
cost between our protocol and the related
protocols
Secret token Key Computation
+ public keys cost
Our 1 163 bits 6

+ 8


protocol 2 = + 4

=
326 bits 6

+ 232

+ 4

SIKA 1 + (1 + #) 1024 4

+ 12

(SCPC and # bits + 2

+ 6

server’s + 1
 
public keys) = 4

+ 2

+ 2886

+ 1
 
Lee-Chang’s 1+1 (SCPC’s 1024 2

+ 9

protocol public key) bits + 7

+
1
 
=
2

+ 2167

+ 1
 
Wu-Hsu’s 1+1 (SCPC’s 1024 2

+ 8

protocol public key) bits + 5

+
2
 
=
2

+ 1925

+ 2
 
Yang et 1+1 (SCPC’s 1024 2

+ 9

al.’s public key) bits + 1
 
protocol + 2

+
5

= 2

+
165

+ 2

+ 1
 
access several service providers; (2) the service provider-
s do not need to maintain a password file for verifying the
users login requests; (3) if a new service provider joins the
system, the user’s master key does not need to be updat-
ed. Apart from the above merits, the key length is short
and the computation cost is low in our protocol. Therefore,
our protocol is suitable for applying ubiquitous computing
environments.
References
[1] F. Bao and R. H. Deng. Privacy protection for transactions
of digital goods. Proc. of international conference on in-
formation and communications security, LNCS 2229, pages
202–213, 2001.
[2] G. Borriello. Key challenges in communication for ubiq-
uitous computing. IEEE Communications Magazine, pages
16–18, 2002.
2007 International Conference on Multimedia and Ubiquitous Engineering(MUE'07)
0-7695-2777-9/07 $20.00  © 2007
1出席國際學術會議心得報告
計畫編號 95-2221-E-128-004-MY2
計畫名稱 全域性計算環境下金鑰管理與隱私保護之研究
出國人員姓名
服務機關及職稱
莊文勝/世新大學資管系/副教授
會議時間地點 San Diego, CA, USA, February 10-13, 2008
會議名稱 Network & Distributed System Security Symposium, NDSS’08
發表論文題目 無
一、參加會議經過
Network & Distributed System Security Symposium 為網路與分散式安全
最頂尖的國際會議。今年於美國聖地牙哥舉辦。本人因計畫需要利用寒假期
間撥空參與此盛會。此會議論文發表共三天，會議開始前一天晚上並有一歡
迎晚會，讓與會學者能自由討論。會議第一天共有一邀請演講與三個場次的
論文發表，晚上並有一歡迎晚宴。會議第二天也有三個場次的論文發表。最
後一天則有一個邀請演講與最後一個場次的論文發表。除了參與此會議之
外，因預計明年台灣需輪到主辦中日韓三方資訊安全聯合會議，本人預計於
今年七月會再參與於韓國舉辦的中日韓三方資訊安全聯合會議並發表論文。
這次參與 NDSS 會議雖未發表論文，但藉由觀摩此會議的進行，對未來協助
主辦相關國際會議會有相當的幫助。另外 NDSS 是目前網路與分散式系統
安全最頂尖的的國際會議之一，參與此會議也讓本人更了解網路與分散式系
統安全最新趨勢。
二、與會心得
壹、 前言
網路與分散式系統安全國際會議(Network & Distributed System Security
Symposium, NDSS) 每年舉辦一次，為目前網路與分散式系統安全最頂尖的的國
3Anonymization”。其作者為麻州大學的 Bruno Ribeiro, Gerome Miklau 與 Don
Towsley 及 加州賓夕維尼亞大學的 Weifeng Chen 四位學者。藉由追蹤收集的精
確網路測量對於進階的網路設計與維護安全與可靠的網路是相當重要的一部
份。然而將網路追蹤的訊息釋出對個人隱私會有相當的危害。本論文中作者發展
一分析工具允許資料公布者可對其所公布的追蹤資料測量其最差情況攻擊者可
獲得的隱私弱點。藉由此分析工具，管理者可對隱私與資訊追蹤可用度之間的取
捨達到一平衡點。
反向工程主題中有一篇論文題目為“Automatic Network Protocol Analysis”。
其作者為 Technical University Vienna 的 Gilbert Wondracek, Christopher Kruegel, Engin
Kirda 與 Scuola Superiore S. Anna, Italy 的 Paolo Milani 四位學者。協定反向工程是
對網路協定應用層規格萃取的過程。此規格對一些安全相關的本文會有非常的幫
助，諸如：於入侵偵測系統中對封包的深入檢查等。但手動的協定反向工程非常
費時與瑣碎，是以便有許多學者提出自動的協定反向工程，但這些被提出的方案
其結果的精確度並不理想。此篇論文中，作者提出一新的自動協定反向工程方
案。此方案並以使用到目前使用中的協定與應用中。
入侵偵測主題中有一篇論文題目為“Limits of Learning-based Signature
Generation with Adversaries”。其作者為美國 CMU 的 S. Venkataraman, A. Blum 與
UCB 的 D. Song 三位學者。自動弱點特徵產生是必須的因為弱點發現與弱點防護
的時差一般相當有限。許多研究著重於如何自動的產生弱點特徵以快速防護系統
弱點。而其中以框架萃取技術最被廣泛使用於自動產生弱點特徵之方案中。本篇
論文以理論的觀點解釋於有入侵的環境中框架萃取技術於自動產生弱點特徵技
術的極限。
惡意程式主題中有一篇論文題目為 “Analysis-Resistant Malware”。其作者為
美國 CMU 的J. Bethencourt, D. Song與SRI International 的 Brent Waters 三位學
者。傳統上被加密的資料的計算的技術常被用於隱私保護的應用上。目前支援
homomorphic 的密碼系統常見被用來有效率的處理被加密的資料。而這些技術可
用於諸如電子投票，伺服器秘密資料檢索等應用上。本篇論文介紹此技術也可用
於惡意軟體的防偵測上。本篇論文並舉出一些範例以介紹如何使用隱私資料檢索
技術於惡意軟體的防偵測上，並針對目前一些常見隱私串流搜尋方案做相關的實
驗以說明於惡意環境上計算被加密資料的可行性。
5計畫編號 NSC 95-2221-E-327-057-MY2
計畫名稱 全域性計算環境下金鑰管理與隱私保護之研究
出國人員姓名
服務機關及職
稱
莊文勝/國立高雄第一科技大學資管系/副教授
會議時間地點 Seoul, Korea, July 10-11, 2008
會議名稱 The 3rd Joint Workshop on Information Security, JWIS 2008
發表論文題目
1. A High Security Authentication Mechanism for 3G/WLAN Networks
2. Robust and Efficient Three-party User Authentication and Key
Agreement Using Bilinear Pairings
三、 參加會議經過
第三次資訊安全聯合會議 (The 3rd Joint Workshop on Information
Security)舉辦目的主要提供亞太地區一資訊安全研究交流的國際會議。去年
於日本東京舉辦，今年於韓國漢城舉辦。本人因計畫與發表論文需要利用暑
假期間撥空參與此盛會。本人除了於會中發表兩篇論文外，並主持一邀請演
講的場次。此會議論文發表共兩天。會議第一天共有兩場次的四個邀請演講
與六個場次的論文發表，晚上並有一歡迎晚宴。會議第二天也有一場次的兩
個邀請演講與六個場次的論文發表。此會議明年將輪到台灣主辦，目前預計
會議地點將於高雄中山大學。這次參與 JWIS 2008 會議除發表兩篇論文與主
持一場次外，並藉由觀摩此會議的進行，對未來協助主辦相關國際會議會有
相當的幫助。
四、 與會心得
伍、 前言
資訊安全聯合會議 (Joint Workshop on Information Security, JWIS) 每年舉辦
一次，主要提供亞太地區資訊安全研究交流平台。會議討論議題涵蓋資訊安全理
7主要介紹目前台灣與柏克萊及卡內基美濃大學的資安跨國合作計畫並介紹台灣
的資安教學與研究中心。其希望將目前台灣於資安方面的努力與成果與亞太地區
學者分享並加強未來合作機會。
除這兩場精彩的邀請演講外，本次會議中論文發表皆相當精采。本人於會中
發表兩篇論文，茲說明如下：
本人發表的第一篇論文題目為“A High Security Authentication Mechanism for
3G/WLAN Networks”。其共同作者為世新大學的廖鴻圖教授。本文中，我們提出
3G/UMTS 與 WLAN 的整合認證機制。我們的安全認證機制除了有較少的計算與
通訊成本外，並有較強的隱私保護功能。另外我們也提供一系列的重新認證機制
以降低認證時的通訊與計算成本。
而本人另外發表一篇論文題目為“Robust and Efficient Three-party User
Authentication and Key Agreement Using Bilinear Pairings”。其共同作者為台灣大學
的雷欽隆教授、世新大學的廖鴻圖教授與粘為亙先生等四位學者。為提供安全的
分散式電腦環境，有效率且彈性的使用者認證與金鑰協商是非常重要的。為提供
此安全環境，我們提出利用雙線性配對達到有效率且彈性的三方使用者認證及金
鑰協商方案。雙線性配對的優點在於可擁有較短的金鑰長度，其不需要較大的儲
存空間。我們設計的協定主要運用在三方的環境中，其主要的優點包含：(1)在伺
服器內不需要存有任何密碼表或驗證表；(2) 使用者可以自由選擇或變更他們自
己的密碼；(3) 使用者彼此可以相互認證；(4) 使用者之間可以產生會議金鑰；(5)
沒有時間同步的問題；(6) 即使存在智慧卡內的秘密資訊被偷導致洩漏，也可以
防止離線式字典攻擊；(7) 其可以防止伺服器入侵的問題。
柒、 結語
此次赴韓國漢城參加 JWIS 2008 會議，有機會與亞太地區學者一同深入討論
資訊安全研究未來的可能發展方向。此次會議參加人數約一百人，可以強烈感受
到資訊安全研究在亞太地區的蓬勃發展，令人印象深刻。非常感謝國科會能提供
足夠的經費讓本人參加此盛會。對本人而言，目睹亞太各國學者在資訊安全研究
工作上的表現，也讓我們能掌握資訊安全的主流研究趨勢，並持續與亞太各國保
有密切合作關係。
A High Security Authentication Mechanism for
3G/WLAN Networks
Horng-Twu Liaw1 and Wen-Shenq Juang2
Department of Information Management1
Shih Hsin University
Taipei, Taiwan
htliaw@cc.shu.edu.tw
Department of Information Management2
National Kaohsiung First University of Science and Technology
Kaohsiung, Taiwan
wsjuang@ccms.nkfust.edu.tw
Abstract. Because of the more and more services wireless communication
technology can offer nowadays, the quality of wireless communication became an
important key. In this research, 3G/UMTS and WLAN, which are two major wireless
communication techniques will be mentioned mainly. The former offers a wide-range,
high-movability, complete and safe record of accounting; the latter offers a narrow-
range, low-movability, high-speed-transmission access on the Internet. The
complementary between these two techniques can not only enhance the quality of
wireless communication but offer more services for customers to choose, and
customers can use wireless application services regardless of any environmental limit.
This research will focus on the problem of fast-handover when 3G/UMTS and
WLAN is interworking, such as authentication and authorization. About the two
formers, we will use W-SKE to accomplish authentication procedure, and achieve
safer Mutual Full Authentication and Fast-Authentication.
Keywords: 3G/UMTS, WLAN, Interworking, Authentication
1 Introduction
The mobile communication technologies have become more and more popular in
recent years, and cell phone service is an important example among kinds of mobile
communication. People can contact with each other by cell phone anytime and
anywhere even if they are traveling by train or walking on the street. Third-generation
mobile system(3G) like Universal Mobile Telecommunication System (UMTS) will
improve data capacity and make data rates up to 2Mb/s. In addition, 3G systems are
expected to provide new applications such as videophone or video streaming.
2 Related Cryptographic Schemes
In this section, we shall introduce some related cryptographic that involves our
study. Those are Keyed-Hash Message Authentication Code (HMAC), Hash-chaining
techniques, Challenge-Response and Symmetric key Encryption.
2.1 Keyed-Hash Message Authentication Code (HMAC)
The Message Authentication Codes (MAC) mechanism is used between two
parts that share a secret key in order to validate information transmitted between
them, and the MAC mechanism based on cryptographic hash function are called as
HMAC[13]. The HMAC can be used with any iterative cryptographic hash function,
e.g. MD5[14], SHA-1[15], in combination with a secret shared key. In other words,
the two parts that share secret key can use HMAC to achieve the message integrity
checks.
2.2 One-way Hashed Chain
A one-way hashed chain is composed of serial hashed values. The chain has the
properties of one-way. In 1981, Lamport proposed a one-way hashed chain
technique[12]; the hash chaining technique has been used in many application
[16][17][18]. Now we introduce the computation of the chain as follows. First, let h(s)
become a one-way function and compute hm(s)= h(h...(h(s))...)), and next, generate a
digital signature of hm(s) and send to authenticator. When the mobile node login the
system, the mobile node sends the ith password which equal hm-i(s) , so the mobile
node can prove itself to authenticator for m times and generate one time password in
each authentication. On the other hand, each hash-chaining value can be taken as the
non-repudiation evidence.
2.3 Challenge-Response Mechanism
The Authentication protocol proposed for the wireless mobile communication
systems are based on the challenge-response mechanism using the symmetric-key
encryption. An instance is: an identity of mobile node (MN) is denoted by ID, and f()
is a symmetric-key encryption function. Based on a random challenge r sent from the
authentication server(AS) on the network side, the MN sends its identity ID and the
response f(k,r) to the AS, where k is a secret key of the MN shared with the AS
beforehand. The AS finds the MN’s secret key k from its database, and completes the
authentication to the mobile subscriber by verifying f(k,r). The advantage can be
easily performed by MN with low computational, but not easy to maintain and waste
resources the database containing the secret keys of MNs.
2.4 Symmetric Cryptosystem
The symmetric cryptosystem utilizes the same key to encrypt the plaintext and
decrypt the ciphertext. Naturally, the sender and the receiver have to share this key
before the symmetric cryptosystem process which provided a much faster and more
efficient solution than other methods, such as asymmetric cryptosystem. Currently,
there are many well-known symmetric cryptosystems, such as DES[19] and AES[20].
4. Proposed Mechanism
In this section we propose a new authentication mechanism based on
challenge/response, HMAC and one-way hashed chain. Our protocols greatly improve
the security and the communication performance.
4.1 Network Architecture
The network architecture as shown in Figure.1 is considered for 3G/UMTS and
WLAN interworking in this study, MN denotes mobile node, H-AAA denotes home
AAA server of a mobile user MN, and F-AAA denotes foreign AAA server of the
WLAN that a MN wants to visit. The F-AAA and the H-AAA belong to separate
providers called AAA Brokers; those should be the association between the H-AAA
and the F-AAA. The AAA Brokers sets up reliable security associations and routes
AAA messages to the H-AAA.
Internet
802.11
Network
Router
F-AAA
Home Network
(3G Carrier Network)
AAA Broker Network
Proxy
AAA
Proxy
AAA AAA
Peering
H-AAA
MN
MN
AP
AP
Figure 1. The network architecture for 3G/UMTS and WLAN interworking
Our authentication model is based on Salgerelli’s work [6]. The authentication
model directly corresponds to network architecture in previous section. Figure.2
illustrates the various network entities involved in the authentication procedure. In
order to authenticate and/or protect data in transit between X and Y, a security
association AX,Y should be set up and can be defined as the combination of the nodes’
identity information(e.g. IMSI, NAI), some form of cryptographic key(e.g. public
keys, pre-shared symmetric key), and information on cryptographic algorithms to be
used. Each AS maintains a preconfigured security association AAS,F-AAA with its F-
AAA server, other AX,Y same meanings. In the 3G/WLAN interworking, F-AAA and
H-AAA may belong to separate service providers, and then an association has to be
set up via an AAA broker or pair-wise relationship should be setup part of roaming
agreement.
MACHM=HMACk(RANDM,IMSI)
4 The MN send the EAP Response/Identity message to AS, which involves IDH,
PIDM, RANDM, and MACHM.
5 The AS sends the EAP Response/Identity message to F-AAA, the ASID append to
the message.
6 F-AAA computes MACHF=HMACf (RANDF,IDF), in order to make the MN easy to
verity H-AAA legally.
7 The F-AAA sends the EAP Response/Identity message to H-AAA.
8 The H-AAA first checks whether the MN access profile is available. If not, the H-
AAA was rejected by the MN.
8.1 The H-AAA uses the pre-shared key and the received RANDM, RANDF , IDF,
IMSI to verity MN and F-AAA legally.
8.2 If verity failed, the will be rejected. Otherwise, the H-AAA generates random
seed RANDH to compute ks = fk(RANDM⊕RANDH).
8.3 After generating the authentication hash chaining, the H-AAA computes
xAUTH purpose to avoid falsity message.
8.4 The H-AAA computes the authentication hash-chain value xAHCiH and xAHC
j
F,
in order to make the MN easy to re-authentication by the H-AAA and the F-
AAA(the i and j indicates the hash time; and it can be adjusted on demand). Show
as follows:
xAHCiH=Hash
i(xAHC1H)
xAHCjF=Hash
j(xAHC1F)
8.5 The H-AAA computes the session key between the MN and the F-AAA,
shown as follows:
KMN-F =PRFKs(xAHC
i
H)
8.6 The H-AAA computes xMACFH for the purpose of the F-AAA avoid falsity
message from the malice attacker.
8.7 The H-AAA keeps TIDM and Ks, which have replaced PIDM and k for next
time of full authentication protocol.
9 The H-AAA sends the EAP success message to the F-AAA.
10 The F-AAA preserve xAHCjF, KMN-F and TIDM after receiving the EAP success
message. Among xAHC
j
F is the hash-chain value when MN and AS process re-
authentication protocol, KMN-F is a session key between the MN and the F-AAA;
TIDM will not be using PIDM at the time of full-authentication next-time, in order
to be anonymous.
10.1 The F-AAA proves whether xMACFH=?MACFH is equal from the H-AAA. If
the F-AAA is not with the secret key pre-shared f , it will fail to verity.
10.2 The F-AAA computes xMACFA for the purpose that make MN avoid falsity
message from the malice attacker.
10.3 The F-AAA computes the session key between the MN and the AS as shown
follows:
KMN-AS =
,MN FK
PRF (xAHCjF)
11 After the F-AAA forwards successful authentication message to the AS.
12 The AS preserve the KMN-AS, TIDM for the ease of transmission between the MN
and the AS.
13 The AS forwards the EAP success message to the MN.
14 The MN obtains the RANDH from the H-AAA and the RANDM producted when
MN requests for authentication. Then computes to the secret key KS produce
between the H-AAA and the MN of authentication time, shown as follows:
KS=fk(RANDM⊕RANDH)
14.1 The MN generates a new temporary identity TIDM=Hash(RANDM ⊕
RANDH,IMSI).
14.2 The MN computes the first authentication hash-chain value xAHC o as per
Eq.8.4
14.3 The MN computes the authentication hash-chain value xAHCiH and xAHC
j
F as
per Eq.8.6
14.4 The MN computes the session key KMN-F as per Eq.8.7
14.5 The MN computes the session key KMN-AS as per Eq.10.3
14.6 The MN verity xAUTH in order to avoid falsity message from the malice
attacker, show as follows as per Eq.8.5
14.7 The MN computes xMACFA for the purpose that make the MN avoid falsity
message from the malice attacker, show as follows as per Eq.10.2
14.8 The MN keeps TIDM and Ks which have replace PIDM and k for next time of
full authentication protocol.
In this step, the MN and the H-AAA successfully authenticate each other.
4.3.2 Fast Re-Authentication Protocol of the F-AAA
Here we depict the detailed successful re-authentication of the F-AAA. The MN
and the F-AAA share a session-key KMS,F which made the re-authenticate key. In the
step of the n-th re-authentication, j is limited for the number of F-AAA re-
authentication times, and j-n number of re-authentication times once left. Figure 4
illustrates this protocol; when the MN accesses the F-AAA which belongs to the
3GPP visit network, the authentication mechanism is also based on the hash chaining
technique. The MN presents its identity TIDM ,and the MN computes AHC
j-n
F , then
sends the result to the F-AAA. After this F-AAA verifies the Hash (xAHCj-
n+1
F)=?AHC
j-n
F ; If passing, it means the F-AAA has authenticated the MN. The AHC
j-
n
F is stored for the next authentication and for the non-repudiation evidence.
Afterwards, the
F-AAA responses to a challenge xMACFA=
,MN FK
HMAC (xAHCj-nF, ASID* ) , and
computes new session key KMN-AS =
MN FK
PRF

(xAHCj-nF). On the other hand, the
xMACFA and KMN-AS are sent to the WLAP AS; the AS keeps the KMN-AS which is used
as dynamic WEP key, and forwarded the xMACFA to the MN. The MN first verifies
the xMACFA. If passing, it means the MN has authenticated the F-AAA server. Next,
the MN derives the KMN-AS =
MN FK
PRF

(xAHCj-nF). Eventually, the mutual
authentication has been successfully completed and the WEP key has been
confidentially delivered. The Fast Re-Authentication Protocol of the F-AAA as shown
in Figure.4
means the MN has authenticated the New AS. Next, the MN produces the new
session KMN-AS**. Finally, the mutual authentication has been successfully completed
and the WEP key has been confidentially delivered.
5. Security Analysis
In this section, we will show our mechanism can preclude several attacks,
according to Byzantine insiders, which indicates the network elements belong to
independent service provider that are not trusted fully because it have a direct or
indirect security association between each other. The Security Analysis as shown in
Table.1
 Prevent Guessing Attack：In full authentication protocol, the Secret Key Pre-
shared k between the H-AAA and the MN, are for authentication purpose.
Therefore, it is possible for an attacker to reveal the Secret key Pre-shared k from
the known information. However, the k is impossible to derive it during a
reasonable time which is at least 128bits. Utilizing one time password of AHCi-m
and AHCj-n to upgrade session key in fast authentication, it is invalid to obtain
session key KWEP.
 Prevent Replay Attack：In full authentication protocol, it is the situation where
an attacker intercepts {IDH, PIDM, RANDM , MACHM} sent by the MN in step4
and uses it to masquerade as the MN to send the authentication request next time.
Though RANDM is generated by the MN, the malice attacker don’t knowing the
Secret Key Pre-shared k between the H-AAA and the MN, and it can’t respond
the correct MACHM and AUTH to the H-AAA and the MN both. On the other
hand, the authentication hash chaining value AHC of fast re-authentication will
be used only once, to replay the AHC will not pass the authentication.
 Prevent Impersonation Attack：The malice attacker attempts to impersonate the
MN to access the WLAN. In full authentication protocol, MACHM =
HMACk(RANDM,IMSI) is encrypted with a pre-shared secret k; hence without
secret key k, it can’t impersonate the MN. In fast re-authentication, the attacker
cannot compute xAHCiH=Hash
i(xAHC1H) or xAHC
j
F=Hash
j(xAHC1F) to
impersonate the MN, because the Pre-shared Secret Key k is only known by the
MN-self and the AHC1 has been securely sent to the H-AAA by the MN in full
authentication. In this case, the attacker can’t compute backward the
authentication hash chaining value AHC.
 Prevent WEP weakness attack：The WEP key congenital disadvantage in the
gold key IV value is not enough and easy to analyze and explain for the Brute-
Force attack in length,since the WEP key is also renewed in each full
authentication of fast re-authentication protocol. Therefore, our mechanism can
overcome the weakness of the original WEP.
 Prevent Forward Secrecy and Backward Secrecy to possible attacks：One
session key/secret key will not lead to the compromise of the past session
key/secret key and the corresponding transmission because one key follows the
form of randomness, the one-way property of hashing chains and the session key
pre-shared between each other. Thus, each session key/secret key is random and
TMS,AS denote the one between MS and AS. According to the number of authentication
time, we can see that TF-AAA,H-AAA > TF-AAA,AS > TMS,AS . Table.2 shows The Performance
Analysis comparison among our mechanism, EAP-AKA, W-SKE and IDKE. The
authentication latency of our full authentication is 2TF-AAA,H-AAA + 2TF-AAA,AS + 4TMS,AS ,
EAP-AKA is 4TF-AAA,H-AAA + 8TF-AAA,AS + 10TMS,AS ; W-SKE is 2TF-AAA,H-AAA + 4TF-AAA,AS
+ 6TMS,AS ; but IDKE doesn’t point out this method. Moreover, in terms of fast re-
authentication, our scheme is 2TF-AAA,AS + 4TMS,AS ; EAP-AKA is 6TF-AAA,AS + 8TMS,AS ;
IDKE is 2TF-AAA,AS + 4TMS,AS ; while W-SKE doesn’t mention it . If the time of
handover for authentication or re-authentication protocol is overlong, it will cause to
lose the packages. Our mechanism can shorten the authentication time delay.
7. Conclusions and Future Works
In our mechanism, we discuss about the security and authentication protocol for
WLAN and 3G/UMTS interworking. Three state-of-the–art authentication protocols
for integrated 3G/WLAN networks: EAP-AKA, W-SKE and IDKE, have been
examined, and shown the security weaknesses of W-SKE, the in-efficiency of EAP-
AKA, and integrate localized re-authentication of IDKE. Based on Keyed-Hash
Message Authentication Code (HMAC), Hash-chaining techniques, Challenge-
Response and Symmetric key Encryption, we have figured out a new authenticated
key exchange protocol. We propose a robust authentication protocol which can
perform efficient localized re-authentication procedure, provide non-repudiation
service, solve the problems of losing packages, shorten the authentication time delay
and greatly improve the security.
In our future work, we hope we will be able to solve Denial of Service (DoS)
attacks to improve the security. On the other hand, we also expect to do a more in-
depth research focused on the handover mechanism, roaming management, packet
forwarding and transmission in the future days.
References
[1]. 3GPP TR 22.934, “Feasibility study on 3GPP system to Wireless Local Area
Network(WLAN) interworking (Release 6)”, September 30, 2003
[2]. 3GPP TS 22.234, “3GPP system to Wireless Local Area Network(WLAN)
Interworking, System description (Release 6)”. September 2004.
[3]. 3GPP TS 33.234, “3G Securtiy; Wireless Local Area Network(WLAN)
interworking security (Release 7)”, June 2006
[4]. M.Buddhikot, G.Chandranmenon, S.Han, Y.W.Lee, S.Miller, and L.Salgarelli,
“Integration of 802.11 and Third-Generation Wireless Data Networks”. In
Proceedings of the IEEE INFOCOM’03, April 2003
[5]. J.Zhu, J.Ma, “A New Authentciation Scheme with Anonymity for Wireless
Envioronments”, Member, IEEE, 2004
[6]. L.Salgrelli, M.Buddhikot, J.Garay, S.Patel, S.Miller, “Efficient Authentication
and Key Distribution in Wireless IP Networks”, Bell Laboratories, Lucent
Technologies, IEEE Wireless Communication, December 2003
Robust and Efficient Three-party User Authentication
and Key Agreement Using Bilinear Pairings
Wen-Shenq Juang1, Chin-Laung Lei2, Horng-Twu Liaw3 and Wei-Ken Nien3
Department of Information Management1
National Kaohsiung First University of Science and Technology
Kaohsiung, Taiwan
wsjuang@ccms.nkfust.edu.tw
Department of Electrical Engineering2
National Taiwan University
Taipei, Taiwan
lei@cc.ee.ntu.edu.tw
Department of Information Management3
Shih Hsin University
Taipei, Taiwan
Abstract. For providing a secure distributed computer environment, user
authentication and key agreement is very important. In additional to user
authentication and key agreement, identity privacy is very useful for users. In three-
party environments, both communicating parties can share separately passwords with
a trusted third party rather than themselves. This approach can reduce the key
management complexity when any two users may want to build a secure channel
between them. In this paper, we propose an robust and efficient three-party password
authenticated key agreement scheme using bilinear pairings. The main merits include:
(1) there does not need any password or verification table in the server; (2) users can
choose or change his own password freely; (3) both of the two users can authenticate
each other; (4) it can protect the user’s privacy; (5) the two users can generate a
session key; (6) it does not have a serious synchronization-clock problem; (7) even if
the secret information stored in a smart card is compromised, it can prevent the offline
dictionary attack.
Keywords: User authentication, session key agreement, bilinear pairings,
smart cards, three-party scheme, smart card loss problem.
1 Introduction
Since most of the communication is in open environments, sensitive data or
information must be properly protected. How to protect the communication content
privately and securely becomes extremely important.
Robust and Efficient Three-party User Authentication and Key Agreement Using Bilinear
Pairings 3
efficiency and between our scheme and the related schemes. Finally, we make a
conclusion in Section 6.
2 Review of Kwonet al.’sscheme
We suppose that two parties A and B try to establish a protected channel
between them by the help of the trusted third party S [12]. For instance, A and B are
both clients in the S’s service domain. Individual passwords for A and B are denoted
by Apw and Bpw .
3.3.1 Initial Setup
A and B choose passwords Apw and Bpw , and register to S in a secure way,
respectively. S stores [ , ,A v ] and [ , ,B  ] in its memory, where 0( , )Ah A pw ,
1( , )Au h A pw , uv g , 0( , )Bh B pw , 1( , )Bw h B pw , and wg .
3.3.2 Protocol
The protocol is shown in Figure 1. We only describe the messages for A. The
protocol for B may achieve in the similar steps.
L1: A computes 0 ( , )Ah A pw , 1( , )Au h A pw , and * ( )X E X where xX g , and
x is a random number, and sends message 1 *( , , )A B X to S .
L2: After receiving message 1, S may choose random numbers a, b, and r, and look
up the user profiles for acquiring [ , ,A v ] and [ , ,B  ].
L3: S can then retrieve X by decrypting X*, and computing aV v .
L4: S computes *2( , )e h X V , and ( )e aXg .
S then computes rX . Note that the random value r is very important in the
protocol since it really links A with B.
L5: S computes * ( )E  where ( )kdf  . Then S may reply with message
3 * 3( , , )AV X H by computing
3 * *
3( , , , , )AH h X V  where ( , , )A B S .
L6: Upon receiving message 3, A computes *2' ( , )e h X V , and
1 ( ')' u x eV   . If
3 * *
3( , , , , ')AH h X V  , A aborts this protocol. Otherwise, A computes
4 * *
4 ( , , , , ')AH h X V   and replies with message 5 4( )AH . A also computes
*
'( )D  where ' ( ')kdf  , and sends message 7 ( ) to B.
L7: After receiving message 5, S may log the failure result and abandon this
protocol if 4 * *4( , , , , )AH h X V   . The log of failure results lets S count the numbers
of impersonation tries and withstand the on-line password guessing attacks. This is
the general technique to withstand on-line attacks in the password-based protocols.
B may receive from A after messages 2, 4, and 6 in the same way. B then
computes *
'
( )D  , where ' ( ')kdf  .
Robust and Efficient Three-party User Authentication and Key Agreement Using Bilinear
Pairings 5
L10: B may abandon if 6 ( , , , )A BH k K . Therefore, if the protocol is not
abandoned, A and B could agree with xyrA BK K g  and use it to build their secure
channel in an authentic way.
3. Our proposed schemes
There are three entities in our scheme including A and B and the server. The
scheme consists of four phases: the setup phase, the registration phase, the key
agreement phase, and the key generation/authentication phase. Let 1G be an additive
cyclic group of a prime order q, and 2G be a multiplicative cyclic group of the same
order. Let P be a generator of 1G and 1 1 2ê :G G G  be a bilinear mapping [4,
24]. Let H:{0, 1}∗ → 1G be a cryptographic one-way hash function which maps a
string to a point of the additive cyclic group 1G [4, 23]. Let ( )h and ( )k be a secure
one-way hash function [17]. Let xE () be a secure symmetric encryption algorithm
with the secret key x [18] and ∥ be the ordinary string concatenation operation. Let
IDs be the identification of the server, and AID and BID be the identification of user A
and user B, respectively.
3.1 The setup phase
The server selects a secret key s and computes the public-key as sP. He also
randomly chooses a master symmetric secret key x and keeps it secret. Then the
server publishes the public information <Ps=sP, P> and keeps <s, x> secret.
3.2 The registration phase
If user A and user B with the identity AID and identity BID , respectively, would like
to register with the server, she/he performs the following protocol with the
server. Parameter i is in the name of user A and B, respectively.
R1. The server verifies user i through a secure identification scheme. If user i is
eligible, then user i selects her/his password iPW and a random number b,
computes  ih PW b , and sends   ,i iID h PW b to the server in a secure
channel.
R2. The server encrypts the hashed password by computing ib =
  || ( ( || ) )x i i i iE h PW b ID h h PW b ID .
R3. The server stores ib in a smart card and delivers it to user i in a secure channel.
The user keeps iPW and the smart card secretly for future login processes.
R4. After user i receiving the smart card, he inputs b into the smart card. The
memory of the smart card contains < ib , b>.
For each user, the registration phase is performed once. If the user loses his/her
smart card, he/she can perform the registration protocol with the server again.
Robust and Efficient Three-party User Authentication and Key Agreement Using Bilinear
Pairings 7
where ( , , )A B S . The random number r is very important that actually links A with
B in our protocol. Then the server sends < * 3, AH > to user A over a public channel.
Step 3 :Let user A receive the message < * 3, AH > from the server. User A
computes  ||Ah PW b . He then verifies if 3 *3( || || ( || ) || )A AH h h PW b   , where
( , , )A B S . If no, the protocol stops. Otherwise, user A computes
4 *
4 ( || || ( || ) || )A AH h h PW b   and sends 4AH to S. A also use private key  to
decrypt * via *( )D  α and sends  to B.
Let the server receive 4AH , S may log a fault information and reject this protocol
if 4 *4( || || ( || ) || )A AH h h PW b   . The log of failure information lets S count the
number of failed tries and prevent on-line dictionary attacks. This is the usual
technique to prevent on-line attacks in the password-based protocols.
)b(Ee
)mQ)(Ps,ê||Q||Ps||mP(h
mPX,m
A
q





1
)b(E
)nQ)(Ps,ê||Q||Ps||nP(h
nPY,n
B
q





1
  
  )ID)b||PW(h(hIDb||PWh)b(D
)(Dband
)ID)b||PW(h(hIDb||PWh)b(D
)e(Db
)sQ)(Y,ê||Q||Ps||Y(h
)sQ)(X,ê||Q||Ps||X(h
BBBBBx
B
AAAAAx
A











1
1
))y||)b||PW(h||||(hHand
))||)b||PW(h||||(hH
)y(Eyand
)(E
)S,B,A(
rYyand
rX
Zr
i
3
B
i
3
A
*
*
q







3
3








)||)b||PW(h||||(hH
)||)b||PW(h||||(hH
ifabort
)S,B,A(
A
4
A
A
3
A



4
3



)y||)b||PW(h||||(hH
iflog
)||)b||PW(h||||(hH
iflog
B
4
B
A
4
A


4
4

)K||y||||(kH
)y||)b||PW(h||||(hH
)K||y||||(kH
ifabort
nK
BB
B
4
B
BA
B




5
4
6




)K||y||||(kH
ifabort
AB 5
eXBA ,,,:1
33 A
* H,:
Client A Client B Server S
,,,,,:2,1 YeXBA
34 B
* H,y:
)y||)b||PW(h||||(hH
ifabort
y)y(D
)S,B,A(
B
3
B
*



3


yH A ,,:'8,3
3*
)K||y||||(kH
myK
)(D
AA
A
*


6


AA HH ,,:9,7,5
4 
BH:''8
44 ,:6,5 BA HH
}P,sPP{:Public}x,s{:Secret s 
Figure 3. The relay mode protocol of our proposed three-party scheme
3.3.2 The key generation/authenticate phase
Setup 4: B may derive from A after receiving the responding messages in the
same manner. B then computes *( )D y y  . B then computes BK n  and
5( || || || )B BH k y K  , and sends , By H to A.
Robust and Efficient Three-party User Authentication and Key Agreement Using Bilinear
Pairings 9
registration phase. An attacker can not make a valid ib without the information of the
server’s secret key x and theuser’s password iPW .
(4) Preventing the offline dictionary attack without the smart card
In order to prevent this attack [5], the transmitted messages of our scheme do not
enough information to check the validability of the password. The first message
between a user and the server of our scheme is { X, e }. If the attacker intercepts this
message, the attacker also can not derive APW because the attacker do not know the
secret key x. The attacker can not decrypt Ab to get  Ah PW b . So it is impossible
for the attacker to do the offline dictionary attack by this message. If the attacker
intercepts the message 4AH and AH , the attacker also has not enough information to
derive the password since the entropy of , b, m and AK are all very large.
7
8Hash+6Exp(
≈1440M)+4Sy
m
8Hash+3Exp
(≈720M)+2S
ym
8Hash+3Exp
(≈720M)+2S
ym
Kwon et al.
7
6Hash+2EC(≈
58M)+2BP+6
Sym
5Hash+2EC(
≈58M)+1BP
+2Sym
5Hash+2EC(
≈58M)+1BP
+2Sym
Our scheme
No. of messagesServerClient BClient A
Hash: hashing operation
Sym: symmetric encryption or decryption
EC: Scalar multiplication of elliptic curve point
BP: Bilinear pairing operation
Exp: exponential operation
M: a modular multiplication operation
Table 1. Efficient comparison between our scheme and related schemes
for three-party protocols
(5) Preventing the offline dictionary attack with the smart card
This attack is similar to the offline dictionary attack without the smart card, but the
attacker can get the smart card and acquire the secret information stored in a smart
card [5]. In our scheme, for example, user A’s password stored in a smart card is
embedded in Ab . Only the valid server can use the master secret key x to decrypt Ab
to acquire the hashed password  Ah PW b . If the attacker gets the smart card and
acquires the secret information stored in the smart card, before the attacker can forge
the valid user, he must generate 4 *4 ( || || ( || ) || )A AH h h PW b   . In this situation, the
attacker can obtain the correct and * , but the attacker can not generate the correct
 Ah PW b since  Ah PW b can only be generated by the eligible user online or be
derived by the server by decrypting   A|| ( ( || ) )A x A A Ab E h PW b ID h h PW b ID . So
the attacker can not get the correct password and create the authenticator 3AH and
4
AH .
Robust and Efficient Three-party User Authentication and Key Agreement Using Bilinear
Pairings 11
6. Conclusion
In this paper, we have proposed an efficient and flexible three-party password
authenticated key agreement scheme using bilinear pairings. Our scheme can provide
many nice properties, such as, identity protection, mutual authentication, revoking a
smart card without changing user’s identity, session key agreement, and no
synchronization-clock problem. In our schemes, if the secret information stored in a
smart card is compromised, our scheme can prevent the offline dictionary attack.
Also, our schemes can prevent server compromise and is very flexible in two modes
of three-party settings.
References
1. S. Bellovin and M. Merritt, "Augmented encrypted key exchange: password-
based protocols secure against dictionary attacks," Research in Security and
Privacy, Proceedings IEEE Computer Society Symposium, pp. 72-84, 1992.
2. S. Bellovin and M. Merritt, "Augmented encrypted key exchange: a password-
based protocol secure against dictionary attacks and password-file
compromise," ACM Conference on Computer and Communications Security,
pp. 244-250, 1993.
3. D. Boneh and M. Franklin, "Identity-based encryption from the Weil pairing,"
in Proc. Crypto 2001, LNCS, vol. 2139, Springer, pp. 213-229, 2001.
4. M. Das, A. Saxena, V. Gulati, and D. Phatak, "A novel remote user
authentication scheme using bilinear pairings," Computers & Security, 2006.
5. C. Fan, Y. Chan, and Z. Zhang, "Robust remote authentication scheme with
smart cards," Computers & Security, vol. 24, pp. 619-628, 2005.
6. A. Joux, "A one round protocol for tripartite Diffie-Hellman," Proceedings of
the 4th International Symposium on Algorithmic Number Theory, Lecture Notes
In Computer Science vol. 1838, pp. 385-394, 2000.
7. W. Juang, "Efficient password authenticated key agreement using smart card,"
Computer & Security, vol. 23, pp. 167-173, 2004.
8. W. Ku, "A hash-based strong-password authentication scheme without using
smart cards," ACM Operating Systems Review, vol. 38, pp. 29-34, 2004.
9. W. Ku and S. Chen, "Weaknesses and improvements of an efficient password
based remote user authentication scheme using smart cards," IEEE Trans. on
Consumer Electronics, vol. 50, pp. 204-207, 2004.
10. W. Ku, C. Chen, and H. Lee, "Weaknesses of Lee-Li-Hwang's hash-based
password authentication scheme," ACM Operating Systems Review, vol. 37, pp.
9-25, 2003.
11. W. Ku, C. Chen, and H. Lee, "Cryptanalysis of a variant of Peyravian-Zunic's
password authentication scheme," IEICE Trans. on Commun., vol. E86-B, pp.
1682-1684, 2003.
12. T. Kwon and D. H. Lee, "Three-party password authenticated key agreement
resistant to server compromise," Information Security Applications, Lecture
Notes in Computer Science, vol. 4298, pp. 312-323, 2007.
