 
In light of this, we propose a paradigm, called 
{Global Program Grid}, to allow programmatic entities 
written in different languages to be easily 
referenced, accessed, and composed over the Internet, 
much like how the World Wide Web integrates global 
resources. Functionally, the Global Program Grid 
comprises three parts: (1)~a type naming scheme 
called {Uniform Type Locator (UTL)} for addressing 
programmatic types along with the mechanism to access 
them； (2) a network protocol called {Internet 
Metaopject Protocol (IMOP)} for carrying out 
programmatic operations over TCP connections； and 
(3) a strongly and statically typed object-oriented 
programming language called {Meso} for weaving local 
program code and remote entities in a unified syntax.
 
英文關鍵詞： Meta Object Service Protocol (MOSP), Internet 
Metaobject Protocol (IMOP), Meso Programming 
Language, Uniform Type Locator (UTL), Global Program 
Grid, Internet Protocol, Internet Programming 
 
ii 
 
Global Program Grid. In Proceedings of the the 27th IEEE International Conference on 
Advanced Information Networking and Applications (AINA-2013), Barcelona, Spain, 
March 25-28, 2013. 
2. Stefan Hong and Yuh-Jzer Joung. Meso: An Object-Oriented Language for Building 
Strongly-typed Network Applications. In Proceedings of the 28th ACM Symposium On 
Applied Computing (SAC), Coimbra, Portugal March 18 - 22, 2013. 
3. Stefan Hong and Yuh-Jzer Joung. Method and System for Automatic Detecting and 
Resolving APIs. US Patent Application No. 13628189. 
 
 我們也完成整個平台系統的實作；程式碼可從我們的計劃網站http://gpgrid.org下載。 
研究期間我們還有另外產出二篇與雲端應用相關的國際會議論文，分別發表於PACIS 
2011與 HICSS2013，主題探討社群與推薦系統。 
fa()
  .. B.fb();  
  ...
  ...
fd()
   E.fe();
   ...
fb()
  .... D.fd();
  ...
  A.fa();
  ...   E.fe();
...
B DA
C E
fe()
   ...
Figure 2: Method calls are like “hyperlinks for programs”
“hyperlinks for programs”. Most programming languages provide an intuitive syntax to express
these “hyperlinks”.
fa()
  .. B.fb();  
  ...
  ...
  ...   E.fe();
...
fd()
   E.fe();
   ...
fb()
  .... D.fd();
  ...
  A.fa();
B DA
C E
fe()
   ...
Figure 3: “Hyperlinks for programs” do not work over networks
However, the syntax and the corresponding semantics of these “hyperlinks for programs” can
only reach local code, just like those hyperlinks that preceded the web. If we move A to E in Fig. 2
to five different computers that communicate over the Internet as in Fig. 3, these “hyperlinks for
programs” no longer work. The type names A to E defined in a programming language are only
meaningful within their local runtime environments. They bear no meaning on the Internet.
To allow programs to be linked over the Internet, one would wish to have a simple and intuitive
syntax for expressing “hyperlinks” to remote code, just like URLs in the web. Unfortunately, most
traditional solutions implement such “hyperlinks” in a more complex and indirect way: by disguising
remote resources as local ones and hiding the semantics of a remote method call beneath the syntax
of a local method call. There are two popular approaches, both based on Remote Procedure Calls
(RPCs) [1]: IDL-based RPCs [8, 7, 11] and RESTful style RPCs [3, 9], as illustrated in Fig. 4.
IDL-based RPCs often rely on an IDL (Interface Definition Language) compiler to generate
a proxy code from an IDL file that describes the interface of a callee. The proxy code is then
embedded into the client’s code so that syntactically it looks like a local call. For example, in
Fig. 4(1), the snippet in A is interpreted by the compiler as “calling method fb() on the local type
ProxyB”, although the true semantics perceived by the programmer is “calling method fb() on the
type B at bb.com”. The proxy code hides the actual data movement between the caller and the
2
code readability and make syntactic and semantic checking by language compilers virtually useless.
Our contributions
fa()
  ...
  ...
  ...
...
fd()
   ...
fb()
  ..
  ...
imop:bb.com/B imop:dd.com/Dimop:aa.com/A
imop:cc.com/C imop:ee.com/E
fe()
   ...
imop:bb.com/B.fb()
imop:aa.com/A.fa()
imop:dd.com/D.fd() imop:ee.com/E.fe()
imop:ee.com/E.fe()
Figure 6: The Global Program Grid
Rather than disguising remote resources as local ones, we expand the syntax and semantics of
a programming language to embrace the network. We designed and implemented a strongly and
statically typed object-oriented programming language called Meso that names each data type in a
global scheme, which contains not only its local name, but also its location on the Internet and the
protocol required to access it, such as the type names imop:aa.com/A to imop:ee.com/E shown
in Fig. 6. We call these global type names Uniform Types Locator(UTLs). The “hyperlinks for
programs” in Meso, i.e., method call expressions, can directly reference UTLs. This allows remote
method calls to be easily expressed in the language while being explicitly distinguished from local
calls. In addition, the Meso compiler can perform the same syntactic and semantic analyses on
both local and remote types. Checking against remote types is made possible by a new network
protocol we designed called Internet Metaopject Protocol (IMOP)2.
Altogether, our goal is to give programming languages the same world-wide scope as that
enjoyed by the web, yet with a simple and intuitive syntax for programs to collaborate over the
Internet. We believe that our design has the potential to allow programs to form a global grid in
a scale that may be comparable to the web. We therefore call this paradigm Global Program Grid.
The Global Program Grid
The Global Program Grid (or simply the grid) is a paradigm that allows programmatic entities
written in different languages to be easily referenced, accessed, and composed over the Internet.
It hinges on UTL, IMOP, and Meso, which resemble URL, HTTP, and HTML, respectively, that
enable the World Wide Web (see the table below). The web links documents by URLs, while the
grid associates programs by UTLs. HTTP serves as the de facto protocol for accessing documents in
2The protocol was named “Meta-Object Service Protocol (MOSP)” when we proposed the project, but it was
renamed to IMOP when we published our results because we believe that the latter better captures the idea and the
scope of our ultimate goal of the protocol.
4
represents the type text/html specified in the Multipurpose Internet Mail Extensions (MIME)
standard that identifies an HTML document.
A UTL as a whole represents a type’s unique name in the global naming space. Different UTLs
represent different types, regardless of the possibility of their semantic similarities. For example,
even though both meso:int and java:int represent numeric integers in the same value range, they
represent different types. For another example, if the UTL vb:ULong represents the ULong type
in Visual Basic, then even though the ULong type is equivalent to the UInt64 type in CTS,
vb:ULong and cts:UInt64 still represent different identities in two different technologies.
Internet Metaopject Protocol (IMOP)
The Internet Metaopject Protocol (IMOP) is a network protocol on top of a TCP/IP socket con-
nection. It has a text-based messaging syntax similar to HTTP. Unlike HTTP’s half-duplex nature,
however, IMOP is full-duplex in the sense that both ends of a connection can send request and
response messages to the other side. In addition, IMOP is strongly typed, meaning that each data
passed by IMOP messages, e.g., request arguments, return values and thrown exceptions, bears a
type with a UTL.
What distinguishes IMOP from many existing protocols for RPCs is the support of type reflec-
tions [6]. Every resource reachable by IMOP can be requested for its interface definition over the
connection. The IDL used to describe an interface can be negotiated between the sender and the
receiver. Still, we have designed a lightweight, programming language independent IDL based on
JSON (JavaScript Object Notation) [2] as the default IDL in IMOP.
The Meso language
Meso is a strongly and statically typed object-oriented programming language. The syntax is very
similar to Java. It has the same expression and statement structures, and shares similar object-
oriented metaphors such as classes and interfaces. In spite of the syntactical similarity, however, it
is not an extension to Java. Meso natively uses UTLs to name all its types. Since access mechanisms
identified by UTLs may range from network protocols to programming languages, incorporating
UTLs in the type system gives Meso an unprecedented expressing power to operate and compose
resources in heterogeneous environments. This unconventional type philosophy makes Meso very
different from Java.
Publications
The goal of the project was to design and implement the Meso language and the IMOP protocol.
The results have been published respectively in the following two papers:
• Stefan Hong and Yuh-Jzer Joung. Meso: An Object-Oriented Language for Building Strongly-
typed Network Applications. In Proceedings of the 28th ACM Symposium On Applied Com-
puting (SAC), Coimbra, Portugal March 18 - 22, 2013.
6
Meso: An Object-Oriented Programming Language for
Building Strongly-typed Internet-Based Network
Applications∗
Stefan Hong†
Dept. of Information Management
National Taiwan University
stefanhong@ntu.edu.tw
Yuh-Jzer Joung
Dept. of Information Management
National Taiwan University
joung@ntu.edu.tw
ABSTRACT
Programming languages rely on type systems to safeguard
the correctness of a program. In existing technologies, types
defined in a program are meaningful only within its runtime,
so the definition of a remote resource must be obtained and
verified to ensure a correct and type-safe interaction. How-
ever, obtaining a consistent meaning of a resource in a dis-
tributed environment requires much human effort and coor-
dination, thus making the development process difficult to
scale to an Internet-like open environment.
The key lies in the lack of a truly global naming scheme
to unambiguously and automatically resolve programmatic
types in the Internet. In light of this, we propose Uni-
form Type Locator (UTL), a worldwide scope type naming
scheme. We also design and implement a new strongly typed
object-oriented programming language called Meso to na-
tively support UTLs, and a protocol to facilitate program
interoperations. We illustrate through examples how Meso
can be used to make developing applications in an Internet-
like open environment as easy and type-safe as developing
them in a single runtime environment.
1. INTRODUCTION
Programming languages for network applications must be
able to express interactions such as to operate Service.func()
at host foo.com. Typically, an expression involves the name
of the service but not its interface definition. To ensure a
correct and safe interaction, however, the interface definition
of a remote service must be obtained and type-checked prior
to the interaction. For services to interact in an Internet-
like open environment, a service must be unambiguously
interpreted regardless of where its name is referenced. Sur-
prisingly, existing languages and techniques (e.g., CORBA [6],
WS-* stack [8], .NET Remoting [5], Java RMI [9], and DRb [7])
∗Research supported in part by the National Science Coun-
cil, Taiwan, Grant NSC 99-2221-E-002-099-MY3.
†Currently (2011-2013) a visiting PhD student in the School
of Information, University of California, Berkeley, CA.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee.
Copyright 20XX ACM X-XXXXX-XX-X/XX/XX ...$15.00.
provide little help to ensure this without human interven-
tion.
For example, in Java RMI, one must manually obtain a
remote interface definition and incorporate it into the client
program, or configure the class loader to allow the Java
Runtime to dynamically load the interface definition from
a designated location. Both processes are tedious, but more
importantly, they cannot prevent one from mistakenly tak-
ing an interface definition as another. As a result, a client
program might be compiled without errors but still not be
correctly executed. Moreover, two different remote resources
with the same name cannot be used simultaneously in a pro-
gram, preventing independently developed programs from
being seamlessly integrated into a third party program.
The above problems are less of a concern when an ap-
plication is developed in a closed environment (e.g., within
an organization), as one can enforce a naming convention
to avoid conflicts and designate a common resource reposi-
tory for obtaining a resource’s interface definition. They are,
however, inevitable in an Internet-like open environment, as
the naming conventions cannot be strictly enforced and no
authority exists to resolve a conflict.
A similar problem occurs in CORBA, which relies on IDL
files to generate client side programs. WSDL tried to solve
the naming conflict problem by using name space URIs, but
there is still no way to associate a unique definition to a
service name. Everyone could create a new WSDL file that
gives an arbitrary definition to the service name. In short,
existing technologies for programming languages provide no
mechanism to guarantee that a remote resource referenced
in a program is unambiguously interpreted in a truly global
scope—the Internet.
Our contributions
To solve the above problems, we propose a new type naming
scheme called Uniform Type Locator (UTL) to define data
type in a truly global scope—the worldwide scope. Syntac-
tically, a UTL is identical to a URI, but semantically, it is a
subset of URI that contains only programmatic data types.
A UTL consists of three parts: Type Scheme, Type Author-
ity, and Local Name, as follows:
Type Scheme
the mechanism to 
interpret the type 
Type Authority
the location where 
the type is defined
imop : api.org / service.IBulletin
Local Name
the identity within 
its authority
Type authority specifies the location where the type is de-
fined. Local name identifies the type within its authority
location. Type scheme identifies the technology related to
the type. Technology can be a language (e.g., Java or C#) or
8
namespace meso:app;
import meso:service.IBulletin;
import meso:service.Msg;
import meso:service.Board;
public class Client {
    private IBulletin b;
    public Client(IBulletin b) {
        this.b = b;
    }
    public void start() {
        Msg m = new Msg();
        m.user = "Joe";
        m.body = "Hello World!";
        b.post(m);
    }
    public static void main(string[] args) {
        Client c = new Client( new Board() );
        c.start();
    }
}
namespace meso:service;
public class Board 
           implements IBulletin {
    private Msg[] msgs;
    private int s = 0;
    public Board() {
        msgs = new Msg[100];
    }
    public void post(Msg m) {
        msgs[s++] = m;
    }
    public Msg[] list() {
        Msg[] tmp = new Msg[s];
        for (int i=0; i<s; i++)
            tmp[i] = msgs[i];
        return tmp;
    }
}
meso:service.Board meso:app.Client
Figure 2: A simple implementation of the abstract
interface in Fig. 1.
namespace meso:app;
import meso:service.IBulletin;
import meso:service.Msg;
import meso:service.Board;
public class Client {
    private IBulletin b;
    public Client(IBulletin b) {
        this.b = b;
    }
    public void start() {
        Msg m = new Msg();
        m.user = "Joe";
        m.body = "Hello World!";
        b.post(m);
    }
    public static void main(string[] args) {
        Client c = new Client( Board );
        c.start();
    }
}
namespace meso:service;
public object Board 
           implements IBulletin {
    private Msg[] msgs;
    private int s = 0;
    public Board() {
        msgs = new Msg[100];
    }
    public void post(Msg m) {
        msgs[s++] = m;
    }
    public Msg[] list() {
        Msg[] tmp = new Msg[s];
        for (int i=0; i<s; i++)
            tmp[i] = msgs[i];
        return tmp;
    }
}
meso:service.Board meso:app.Client
Figure 3: Re-implementation of Fig. 2 using single-
ton object.
typical client/server architecture for a network application.
To achieve this, we first redefine meso:service.Msg and
meso:service.IBulletin to make their names and defini-
tions uniquely identified throughout the Internet. Assume
that api.org will host the definitions. We then replace
the meso: portion in the UTLs with imop:api.org/, as
shown in Fig. 4, and physically store the code at api.org.
The imop:api.org/ portion means that the type definition
should be obtained from the authority address api.org via
the IMOP protocol, so the source code in Fig. 4 are mean-
ingful only when they are placed at api.org.
Next, we redefine the singleton object Board to make
it worldwide accessible. Assume that the object is offered
at news.com. The new code is shown in Fig. 5, which is
almost identical to that in Fig. 3, except that the object’s
UTL is changed to imop:news.com/pub.Board, and the
IBulletin interface it implements is now defined at api.org.
Note again the code must be executed at news.com so that
others can reach the Board object at the location indicated
by its UTL.
The Client class, on the other hand, does not have to
namespace imop:api.org/service;
public interface IBulletin {
     public void post(Msg m);
     public Msg[] list();
}
namespace imop:api.org/service;
public struct Msg {
     public string user;
     public string body;
}
imop:api.org/service.Msg imop:api.org/service.IBulletin
api.org
Figure 4: An interface defined in the worldwide
scope (cf. Fig. 1.)
namespace meso:app;
import imop:api.org/service.IBulletin;
import imop:api.org/service.Msg;
import imop:news.com/pub.Board;
public class Client {
    private IBulletin b;
    public Client(IBulletin b) {
        this.b = b;
    }
    public void start() {
        Msg m = new Msg();
        m.user = "Joe";
        m.body = "Hello World!";
        b.post(m);
    }
    public static void main(string[] args) {
        Client c = new Client( Board );
        c.start();
    }
}
namespace imop:news.com/pub;
import imop:api.org/service.IBulletin;
import imop:api.org/service.Msg;
public object Board 
           implements IBulletin {
    private Msg[] msgs;
    private int s = 0;
    public Board() {
        msgs = new Msg[100];
    }
    public void post(Msg m) {
        msgs[s++] = m;
    }
    public Msg[] list() {
        Msg[] tmp = new Msg[s];
        for (int i=0; i<s; i++)
            tmp[i] = msgs[i];
        return tmp;
    }
}
imop:news.com/pub.Board meso:app.Client
news.com
(any computer)
Figure 5: A bulletin implementation over the Inter-
net.
move to the worldwide scope. Each computer can have its
own client implementation. The only modification to the
Client class in Fig. 5 is that import statements now refer
to remote types such as imop:api.org/service.IBulletin.
When compiling the source code, the Meso compiler will ac-
quire the definitions of all remote types via the IMOP proto-
col for type checking. DuringClient’s execution, b.post(m)
invokes a method on the object stored in b, which is the
remote object imop: news.com/pub.Board. The Meso
runtime performs a remote method invocation, again via the
IMOP protocol.
The following can be learned from the above illustration.
First, developing an application with components interact-
ing over the Internet is as easy as developing an application
whose components interact only in a local runtime environ-
ment. For example, the main difference between Fig. 5 and
Fig. 3 is just the UTLs: the former uses global UTLs, while
the latter uses local UTLs. Moreover, when using remote
resources, Meso requires no tedious name bindings and ser-
vice registrations as those required in Java RMI, CORBA
or Web Services. Each resource can be unambiguously and
consistently interpreted via its UTL by every Meso compiler
and Meso runtime regardless of where it is referenced. As
such, interactions between components, whether local or re-
mote, can be easily and intuitively expressed in a program.
This improves code readability and thus reduces mainte-
nance cost. Even so, because definitions of remote resources
can be obtained over the wire from the authority addresses
specified in their UTLs, strong type checking can still be
offered to safeguard nonlocal interactions.
10
namespace meso:tool;
import imop:api.org/service.IBulletin;
import imop:api.org/service.Msg;
public class Reviews 
           implements IBulletin {
    private Msg[] msgs;
    private int s = 0;
    private string isbn;
    public Reviews(string isbn) {
        msgs = new Msg[100];
        this.isbn = isbn;
    }
    public void post(Msg m) {
        msgs[s++] = m;
    }
    public Msg[] list() {
        Msg[] tmp = new Msg[s];
        for (int i=0; i<s; i++)
            tmp[i] = msgs[i];
        return tmp;
    }
    public string getISBN() {
        return isbn;
    }
}
meso:tool.Reviews
namespace imop:book.com/mgrs;
import meso:tool.Reviews;
import imop:api.org/service.IBulletin;
public object ReviewManager {
    private Reviews[] objs; 
    private int s = 0;
    public ReviewManager() {
        objs = new Reviews[1000];
    }
    public IBulletin getReviews(string isbn){
        for (int i=0; i<s; i++) {
            if (objs[i].getISBN().equals( isbn ))
                return objs[i];
        }
        Reviews r = new Reviews( isbn );
        objs[s++] = r;
        return r;
    }
}
imop:book.com/mgrs.ReviewManager
book.com
(exists privately inside book.com)
Figure 8: Using a local class type to instantiate ob-
jects for remote use.
network. For example, among the methods of the Reviews
class in Fig. 8, only the post() and list() methods, which
are declared by the imop:api.org/service. IBulletin in-
terface, are accessible from the network. The public method
getISBN() and the constructor are not; they are public
only in their local runtime environment. This clean separa-
tion helps prevent local implementations from being inad-
vertently exposed to the world.
namespace meso:app;
import imop:api.org/service.IBulletin;
import imop:api.org/service.Msg;
import imop:book.com/mgrs.ReviewManager;
import java:java.lang.System;
public class Client {
    public void start(string isbn) {
        IBulletin b = ReviewManager.getReviews( isbn );
        for (Msg m : b.list()) {
            System.out.println( "User: " + (meso:string) m.user );
            System.out.println( "Msg: " + (meso:string) m.body );
        }
    }
    public static void main(string[] args) {
        Client c = new Client();
        c.start( args[0] );
    }
}
meso:app.Client
(any computer)
Figure 9: Integrating with Java
We further show a client side program in Fig. 9 to il-
lustrate how Meso is able to integrate with different type
schemes. Notice the statement import java:java.lang.
System in the code. When encountering the statement
System.out.println, the Meso compiler can resolve, by
the import statement, that the method belongs to the Java
type scheme. Thus, the runtime can invoke the correspond-
ing method in the Java library to do the printing. We can
also see how three different schemes are seamlessly inte-
grated into a Meso program under a unified syntax: imop:
(e.g., ReviewManager.getReviews()), java: (e.g., Sys-
tem.out.println()), and meso: (e.g., c.start()).
To summarize, the examples in this section demonstrated
how Meso embraces UTLs and object orientation to make
developing applications in an Internet-like open environment
as easy and type-safe as developing them in a single run-
time environment. As such, programmers will be able to
build complex Internet-based network applications far be-
yond what is achievable today.
3. DESIGN AND IMPLEMENTATION
In this section we address some design and implementa-
tion issues of Meso. First, we discuss the imop: scheme
and the associated protocol for interactions between differ-
ent programs. Then, we discuss Meso’s multi-scheme type
system and the benefits. Finally, we briefly discuss the cur-
rent implementation of Meso, and address some security and
performance concerns.
3.1 imop: type scheme and IMOP protocol
As motivated in Section 1, resources available for local op-
erations and resources available for remote operations may
have different concerns. Thus, they are explicitly distin-
guished by their UTLs: with and without authority ad-
dresses. This is different from the conventional wisdom
that favors location transparency in a distributed system
so that a program can still function correctly when the ob-
jects it uses are moved to a different place. Location trans-
parency is difficult to achieve in an Internet-scale open en-
vironment due to the lack of an authority to unambiguously
resolve name-to-address bindings. As a result, either the
same program might behave differently at different places,
or a tedious registration and binding process is required to
avoid potential conflicts. The overwhelming success of URL
vs. URN in naming documents in WWW provides a strong
support to our argument. Using URN instead of URL would
make the hyperlinks in a document less intuitive, and would
not yield WWW the same scale as we see today. We believe
that this is also the case for programmatic resources.
When local and remote resources are explicitly distin-
guished, operationally, it might appear that a protocol for
passing untyped messages to operate remote resources would
suffice. This is the case in the REST style web services [3]
and in DRb [7], where a remote resource is identified by a
URL and untyped messages are passed over to invoke it via a
default protocol. For strong type checking and a more com-
plex program interaction model beyond client-server (e.g.,
the examples in Fig. 6-8), we need to define data types for
interoperations over the network. The imop: type scheme
was designed for this purpose.
Data types in the imop: type scheme are somewhat sim-
ilar to that in a typical object-oriented language. Fig. 10
shows some of them. Primitive types are all predefined with
explicit value ranges and precisions. Structure types are
composite value types that may hold named fields but do
not have methods. An array type represents an array of
homogeneous data whose type can be of any type in the
scheme. All these types are called value types because their
data are always passed by value when sent over the network.
For structures and arrays, their entire content is serialized
and transferred over.
Among the types, three of them (structure, interface, and
object) use global UTLs so that they are accessible over
the Internet. Structures and interfaces represent abstract
data types that have no concrete value or implementation,
12
namespace imop:api.org/abc;
public class foo4 { ... }
3.3 Marshalling
Network applications often need to deal with multiple type
systems. Traditionally, it is a programmer’s responsibility
to perform marshalling (that is, converting data of a for-
eign type system to a format native to the language, or
vice versa). Thanks to Meso’s multi-scheme type system,
we are able to shift the responsibility from programmers to
the Meso compiler. The compiler is able to identify the
places where marshalling is needed: places where data is
used in a context that requires a different type scheme to
interpret the data. Therefore, it can insert marshalling code
appropriately or signal a type error if such marshalling is
not possible.
The marshalling code inserted by the compiler is provided
by the type scheme plug-in. Ideally, a scheme should provide
marshalling code for all possible target schemes. However,
given the openness of Meso’s multi-scheme type system (that
new type schemes can be added), it is impractical to provide
all the marshalling code.
Our solution lies in the meso: scheme, a type scheme
that all Meso language implementations must support. Ba-
sically, each scheme need only provide marshalling code for
converting to and from data types in the meso: scheme if a
conversion is possible. Therefore, the meso: scheme can be
used as a bridge to convert data types across two different
schemes.
A marshalling algorithm involves several subtle issues.
For example, mixing cross-scheme marshalling with same-
scheme conversions (e.g., from java:int to java:double) can
result in multiple conversion paths. Moreover, creating in-
ternal proxy objects is sometimes necessary for marshalling
reference type objects across schemes. It also needs a rea-
sonable policy to specify when marshalling should be implic-
itly applied (i.e., coercion), or explicitly requested (i.e., cast-
ing). While these details are beyond the scope of the paper,
Fig. 13 illustrates how marshalling can be applied on an
expression in Fig. 9.
java:java.lang.String
for (Msg m : b.list()) {
    System.out.println ( "User: " + (meso:string) m.user );
            ....
}
marshalling from IMOP 
to Meso (casting)
+ operator
marshalling from Meso to Java (coercion)
System.out.println ( );
meso:string
meso:string
imop:string
meso:string
Figure 13: Marshalling between type schemes
3.4 Multi-scheme reference types
A value type like java:int or meso:string belongs to ex-
actly one type scheme. In contrast, a reference type may
belong to multiple schemes at the same time. For example,
the tool.Reviews class in Fig. 8 is declared in the meso:
scheme, but since it implements the interface
imop:api.org/service.IBulletin, it belongs to the imop:
scheme as well. In general, a meso: scheme class can
implement interfaces from different schemes, so an object
instantiated from the class can be used in each of these
schemes. However, when operated in a scheme different from
the scheme the implementation belongs to, a moniker is cre-
ated to represent the object in that scheme. A moniker acts
as a proxy of a meso: scheme object to its caller in a dif-
ferent scheme, and reveals the object’s capability only per-
taining to the caller’s scheme. Operations performed on the
moniker are redirected back to the actual object it repre-
sents.
Meso runtime
meso:tool.Reviews
IMOP listener
meso:tool.Reviews
namespace meso:tool;
import imop:api.org/service.IBulletin;
import imop:api.org/service.Msg;
public class Reviews 
           implements IBulletin {
    ....
    public Reviews(string isbn) {
        .....
    }
    public void post(Msg m) {
         .....
    }
    public Msg[] list() {
         .....
    }
    public string getISBN() {
         .....
    }
}
(1) network requests
(2)
(3)
Meso 
object
compiled codeReviews()
compiled codelist()
compiled codegetISBN()
compiled codepost()
list()
post()
IMOP
moniker
imop:book.com/obj123
(a)
(b)
Figure 14: Using an object in multiple type schemes
Fig. 14 illustrates this. TheReviews class has four meth-
ods (including the constructor) and is compiled into an inter-
nal code used by the Meso runtime. Assume that an object
(a) of the class is created. Initially, there is only one internal
runtime reference pointing to the object. When the object is
returned to a client by the getReviews() method in Fig. 8,
a moniker (b) is created and is assigned with a new ran-
dom UTL, say imop:book.com/obj123, as its reference
in the worldwide scope. When a remote computer requests
(1) a definition of the moniker’s UTL, the moniker describes
itself as an imop: object that implements the imop: IBul-
letin interface. Subsequently, a request that invokes the
list() method (2) on the imop: object—which is actually
the moniker—is redirected to invoke the concrete code (3)
on the object (a).
From the network, a remote computer cannot know the
existence of the getISBN() method behind the moniker,
nor can it invoke the method. That is, the imop: object (b)
presented by the moniker looks just like what the interface
IBulletin has described and nothing else. This provides a
layer of protection when an object is exposed to the network.
Only the imop: interface it implements can be seen over
the network. All internal functions are concealed from the
network.
3.5 Implementation
Meso is designed for building Internet-scale network ap-
plications. A challenge for ensuring type-safe interactions
in such a scale is that the Internet environment is dynamic.
Data types defined today may be unilaterally changed to-
morrow. Thus, it is preferred to have the Meso compiler
perform type checking as late as possible to reflect the lat-
est state of the execution environment.
To do so, our implementation compiles Meso source code
on-the-fly upon loading, and performs type checking against
latest type definitions reflected from the network. To re-
duce network traffic, type definitions may be cached locally
using a cache-control header similar to that in HTTP. This
implementation makes Meso looks like a dynamic language
where programs are executed directly from the source code,
14
Internet Metaobject Protocol (IMOP):
Weaving the Global Program Grid
Stefan Hong
Dept. of Information Management
National Taiwan University
Taipei, Taiwan
Email: stefanhong@ntu.edu.tw
Yuh-Jzer Joung
Dept. of Information Management
National Taiwan University
Taipei, Taiwan
Email: joung@ntu.edu.tw
Abstract—Software applications are increasingly relying on
networks to function, but making programs to interact over
the network is still tedious and error-prone. Conventional tech-
nologies such as CORBA and the WS-* stack are complicated
to use, whereas RESTful style operations rely on costly ad-hoc
developments on a per-service basis. We believe the problem lies
in the lack of a network protocol that can solely and sufficiently
address interoperability needs.
In light of this, we developed Internet Metaobject Protocol
(IMOP), a remote method invocation protocol for object-based
resource representations. IMOP thoroughly defines operations
required to facilitate interactions, from reflecting a resource’s
definition to invoking its methods. It also rigorously defines the
types of data passed between systems, including primitive types,
composite value types, and reference types. All of these are
programming language neutral.
Index Terms—Internet Metaobject Protocol (IMOP); Meso;
Global Program Grid; Uniform Type Locator (UTL); Internet
Protocol; Remote Procedure Call (RPC)
I. INTRODUCTION
Finding an easy way to make programs interoperable over
networks has been a long quest for many decades, but the
rich body of existing work still left a lot to be desired.
Technologies such as Common Object Request Broker Ar-
chitecture (CORBA) [1] and the conventional Web Services
(WS-*) stack [2] strive to rigorously define the interaction
between programs over networks, while also providing a great
flexibility in operational models and networking transport
supports [2]. Such ambitious goal inevitably complicates the
overall design, and leaves rooms for software vendors to
inadvertently or even intentionally implement the specification
in a slightly incompatible way [3]. As a result, these heavy-
weight solutions often hinder, ironically, the interoperability
that they set out to achieve.
Apparently, the most successful network-based system tech-
nology that scales both up to the size of the Internet and
out to a wide variety of applications is the World Wide Web.
However, the web was designed to be a distributed hypermedia
system that aimed to facilitate the delivery of a resource from
one location to another when it is requested, made mostly by a
human upon following a link. It was not intended to facilitate
generic machine-to-machine operations.
Nevertheless, more and more people leverage the web,
and use the Representational State Transfer (REST) architec-
ture style [4] to build modern distributed applications. The
RESTful style aims to model the data transferred between
networked systems through a well-known interface, rather than
the imperative interfaces between systems with a well-known
data format [4], [5], [6]. Many people argue that the disso-
nance between the data-centric model and the predominate
imperative programming style makes REST principles difficult
to apply consistently throughout the system [7], [8], [5], [9].
In addition, the interoperability is still hard to achieve without
a commonly agreed data representation [9].
In short, the RESTful style defines too little to standardize
the interaction between programs over the network; some ad
hoc patches are often necessary to make them interoperable.
Conversely, technologies such as CORBA and the WS-* stack
define too much for the sake of interoperability; the additional
goals such as code portability and transport flexibility bloat
their overall designs and obscure the interoperability itself.
We believe that building network-based applications can
be greatly simplified by having a network protocol whose
design focuses on—and solely on—machine-verifiable inter-
operability. We therefore designed a protocol named Internet
Metaobject Protocol (IMOP) to fill this role. IMOP is a
remote method invocation protocol for object-based resource
representations. It is text-based and works in the application
layer. The novelty of IMOP lies in the explicit definition
of both protocol-level methods and instance-level methods
supported by a resource in the network. The former provides a
general framework to establish a conversation with a resource,
whereas the later operates the resource itself. Both levels of
methods have machine-processable definitions. In particular,
protocol-level methods are standardized by the protocol, while
instance-level methods are defined in a descriptor that may be
obtained through an over-the-wire reflection mechanism.
IMOP is one of the three elements that constitute the
Global Program Grid (or simply the grid)—an architecture we
proposed to facilitate an Internet-scale network-based object
system in which programs are interoperable through machine-
verifiable interfaces. The other two elements are: (1) a resource
type naming scheme called Uniform Type Locator (UTL);
and (2) a strongly and statically typed programming language
named Meso [10]. The roles of these three elements can be
analogized to the roles of URL, HTTP and HTML in the World
Wide Web (see the table below). The web links documents by
URLs, while the grid associates programs by UTLs. HTTP
16
DESC
CALL  method args
Response args
IMOP meta-methods
IMOP
descriptor
network-based applications
concept
Program
URL
DESC
CALL
Meta-
Object1
URL1
inst1
desc’
-tor1
DESC
CALL
Meta-
Object2
URL2
inst2
desc’
-tor2
object
interface
type
structure
type
object
object
Fig. 2. The grid and IMOP
HTTP and IMOP have different meta-methods distinguishes
their philosophical differences: HTTP moves resources, but
IMOP does not—it operates resources remotely.
Metaobjects effectively separate two layers of interoperabil-
ity concerns: the meta-level interoperability that is essential to
establish base-level communications, and the base-level inter-
operability that is necessary to facilitate program interactions.
Both are clearly addressed by IMOP. The former is achieved
by the meta-methods predefined in the protocol, while the
latter is governed by interface descriptors obtainable through
per-object reflections.
The use of metaobject might seems indirect or even in-
efficient, but in fact it is only a notion used to clarify the
concept behind the protocol. The syntax of an IMOP message
is not much different from that used in HTTP, and both can
be handled by software at a similar degree of complexity.
C. The rationale of creating a new protocol
Because of the syntactical similarity with HTTP, one might
think that HTTP can be easily extended with DESC and CALL
methods, thus rendering IMOP unnecessary. However, there
are three problems with this approach.
The first one concerns the fundamental philosophical dif-
ference between DESC/CALL and existing HTTP methods.
Mixing them in one protocol may cause confusion. For
example, it is unclear, at least from the URL alone, that
whether http://foo.com/bar represents a resource that can be
obtained over the network, or must be operated remotely. A
different protocol name stated in the URL scheme can clearly
distinguish the difference. The second problem concerns the
orthogonality between methods. Many existing HTTP methods
are able to carry arbitrary query parameters in the request URI
or in the message body. They provide a somewhat similar
but inconsistent functionality with CALL. Such inconsistency
is not preferred in a protocol’s design. The third problem
concerns the half-duplex nature of HTTP. Programs often
interact in a full-duplex manner that one will actively send
requests to the other. If they connect through a firewall or a
NAT where one end does not have a public IP address, it may
be crucial to perform full-duplex messaging at the application
layer. This, however, is not supported by HTTP.
These problems are hard to overcome without breaking the
compatibility with existing HTTP. As a result, we believe that
creating a new protocol would be more appropriate. It also
allows us to improve some aspects of HTTP that are otherwise
not possible for the sake of compatibility, such as using less
verbose headers.
D. Uniform Type Locator (UTL)
Before discussing the type system used in IMOP, one needs
to understand the notation of Uniform Type Locator (UTL).
Syntactically, a UTL is just a URI, but we use the term UTL to
explicitly refer to the informal subset of URI that identifies a
data type using three components: A Type Scheme, an optional
Type Authority, and a Local Name, as follows:
Type Scheme
the protocol that 
defines the type 
Type Authority
the location where 
the type is defined
imop : api.org / service.IBulletin
Local Name
the identity within 
its authority
The type scheme specifies the mechanism required to access
the type. The type authority, if it exists, specifies the location
where the type is defined. A UTL that contains an authority
component is called a global UTL, otherwise it is a local
UTL. Finally, the local name component identifies the type
within its authority location or the type scheme. The syntax
of the components and the delimiter used between them are
type scheme dependent, so long as the whole UTL complies
with the URI’s specification.
All global UTLs should be reflective so that a descriptor of
the type is obtainable from its authority using the mechanism
implied by its type scheme. The format of the descriptor
may be negotiable between a client and the authority. Being
reflective means that each global UTL bears a consistent
meaning throughout the Internet regardless of the context. In
contrast, the definition of a local UTL is either predefined by
the scheme, or is resolvable in a way known to the scheme
that may lead to context dependent definitions.
E. Instance-level and Protocol-level types
imop:boolean
imop:short
imop:int
imop:long
imop:float
imop:double
imop:char
imop:string
primitive structure
array
imop:foo.com/abc
imop:int[]
imop:string[][]
imop:foo.com/def[]
imop:foo.com/xyz[][]
imop:foo.com/def
imop:foo.com/xyz
interface
object
Reference typesValue types
Fig. 3. Examples of instance-level types
Methods in IMOP can be classified into two different
levels: protocol-level and instance-level. Each level of methods
have their own data types. Fig. 3 shows some types used
by instance-level methods, which include value types and
reference types. Data of values types are passed by value
over the connection when used as a method argument. This
is true even for structure and array values. The entire content
of these composite values are serialized and transferred over.
Conversely, reference type resources are never moved nor
18
namespace meso:foo;
import imop:bb.com/pb.B;
public class Ap1 {
  public static void main() {
    B.funcB( 123 );
  }
}
Ap1
aa
namepace imop:bb.com/pb;
public object B {
  public void funcB(int i) {
     ...
  }
}
bb.com
B
imop:bb.com/pb.B
IMOP/0.6  1  DESC  bb.com/pb.B
IMOP/0.6  1  200  OK
s: ...content size...
{ "itd": { "kind": "o",
  "mths": [{ "n": "funcB",
     "is": [ "imop:int" ] }]  }}
IMOP/0.6  2  CALL  bb.com/pb.B
s: ...content size...
{ "n": "funcB",
  "as": [
    { "t": "imop:int", "v": "123" }]
} IMOP/0.6  2  200  OK
(1) (2)
(3) (4)
Verify
Execute
Fig. 6. Ap1 at aa invokes a method on B at bb.com
conversation messages in IMOP. The program at the host aa
in the left, which does not have a public IP address, invokes
the method funcB on the object B at the host bb.com in the
right. The import statement in the source code of Ap1 allows
the identifier B used in the source code to be resolved as the
UTL imop:bb.com/pb.B.
Meso is a strongly typed programming language such that
no operation is allowed to perform on an entity that does
not support such operation. Therefore, when compiling the
source code of Ap1, the definition of imop:bb.com/pb.B
must be obtained to verify whether it can be invoked with
the method funcB(123). The compiler does so by asking
from the compile-time handler of the imop: scheme, which
in turns sends out an IMOP DESC request (1) over a TCP
connection to the host bb.com on port 901 to introspect the
type imop:bb.com/pb.B. The dialog balloon in the figure
shows the content of the message.
The request arrives at bb.com and is received by a runtime
handler of the imop: type scheme, which is configured to listen
to the port 90 and handle requests for the authority bb.com:90.
The handler accepts the request and asks the Meso runtime to
load the type imop:bb.com/pb.B from a local file under a pre-
configured directory similar to the document root of a web
server. The imop handler then generates a JSON descriptor
from the loaded type and sends it back in the response message
(2). The JSON descriptor shows that the instance at the UTL
is an object, and lists the methods that the object supports.
This information allows the compiler at the host aa to verify
the usage of the object before generating code to access it.
The sequence number “1” used in both request and response
envelopes is a unique message ID set up by the requester
per connection so that response messages can be paired with
request messages when they are delivered out of order.
During the execution of Ap1, the Meso runtime at aa
performs the invocation of the method funcB by handing it
over to its runtime handler of the imop: type scheme. The
1Port 90 is the default port number of IMOP, although its use has not
yet been officially registered with the Internet Assigned Numbers Authority
(IANA).
handler creates an IMOP CALL request (3) to the object
imop:bb.com/pb.B, and serializes arguments sent by the run-
time into a JSON-based format stored in the content. The
request is processed by the handler at bb.com by deserializing
arguments and then invoking the actual method on the object.
A response message (4) is returned to indicate a successful
invocation.
C. Using interface types
In the previous example, the remote resource used by Ap1
is predetermined at the development time since the UTL
imop:bb.com/pb.B is hard-coded in the source code. In this
section, we demonstrate how IMOP enables programs to
interact with an open set of resources that support the same
interface type. The example is illustrated in Fig. 7. In this
example, a client at Ap2 invokes a service C at cc.com to
operate an object E at ee.com. Both C and E reference an
interface D at dd.com.
IMOP/0.6  1  DESC  cc.com/pc.C
IMOP/0.6  1  200  OK
s: ...content size...
{ "itd": { "kind": "o",
  "mths": [{
    "n": "funcC",
    "is": [ "imop:dd.com/pd.D" ] }]
}}
IMOP/0.6  1  200  OK
s: ...content size...
{ "itd": { "kind": "i",
  "mths": [{
    "n": "funcD",
    "is": [ "imop:int" ] }]
}}
namepace imop:cc.com/pc;
import imop:dd.com/pd.D;
public object C {
  public void funcC(D obj) {
    obj.funcD( 123 );
  }
}
cc.com
C
imop:cc.com/pc.C
namespace imop:ee.com/pe;
import imop:dd.com/pd.D;
public object E
   implements D {
   public void funcD(int i) {
     ...
}}
ee.com
E
imop:ee.com/pe.E
namespace imop:dd.com/pd;
public interface D {
  public void funcD(int i);
}
dd.com
D
imop:dd.com/pd.D
namespace meso:foo;
import imop:cc.com/pc.C;
import imop:ee.com/pe.E;
public class Ap2 {
  public static void main() {
    C.funcC( E );
  }
}
Ap2
aa
IMOP/0.6  1  DESC  dd.com/pd.D
IMOP/0.6  1  DESC  ee.com/pe.E
IMOP/0.6  1  200  OK
s: ...content size...
{ "itd": { "kind": "o",
  "impls": [
    "imop:dd.com/pd.D"
  ]
}}
(1)
(2)
(3)
(4)
(5)
(6)
Fig. 7. Verifying the code of Ap2 (which invokes a service C at cc.com
to operate an object E at ee.com. Both C and E reference an interface D at
dd.com.)
1) Conversations for type verification: Fig. 7 depicts the
IMOP conversations initiated by the Meso compiler at aa
when compiling the source code of Ap2 in the left. First, to
verify whether funcC can be applied on the identifier C, the
compiler makes a DESC request (1) to reflect the definition of
imop:cc. com/pc.C. The response message (2) shows that the
resource is an object instance, which supports a method funcC
that takes one argument of type imop:dd.com/ pd.D. This
argument type has yet been seen by the compiler at aa, so the
compiler makes another DESC request (3) to the host dd.com
to reflect its definition. The “kind” field in the descriptor sent
by the response message (4) is “i”, meaning that the resource
is an interface instance. It is an abstract resource that does not
20
randomly. With that private name, the host aa becomes
h001@cc.com—an indirect authority address that identifies
the private host h001 reachable from cc.com. This address
faithfully reflects the location of aa so long as its connection
to cc.com is maintained. If the connection is broken, the host
aa may try to re-establish the same identity by sending another
BIND request via a new TCP connection, along with the host
name h001 and the original opaque handle set in the request
envelope. The opaque handle is a simple—albeit insecure—
way to authenticate itself. The host cc.com may accept that
requested name, or assign a new one in the response message.
Once the indirect address is obtained, the Meso runtime
at aa can assign the local object meso:foo.F a new global
UTL by combining the authority address h001@cc.com with
a randomly generated local name F1 (3). The new UTL
imop:h001@cc.com/F1 is then used as the argument to the
CALL request (4) to invoke the method funcC at cc.com.
When the request arrives at cc.com, the Meso runtime there,
again, needs to introspect this UTL before accepting it as
the argument. The runtime knows that one of its existing
connections can reach the authority h001@cc.com, and sends
the DESC request (5) through that connection. The response
message (6) shows that the UTL is an object instance that
implements the interface type D, and thus cc.com accepts the
reference imop:h001@cc.com/F1 and stores it in the variable
obj. Notice that the descriptor in the response message does
not reveal the UTLmeso:foo.F. The UTL is completely private
to aa.
After accepting the argument, the execution of funcC at
cc.com begins, wherein the method funcD invokes on the
reference stored in obj. The CALL request (7) is sent through
the same connection as the DESC request, and is ultimately
processed by the object F at aa. When the execution of funcD
is completed, a response message (8) is returned. Finally,
another response message (9) is sent from cc.com to indicate
that the original CALL request (4) is completed.
The UTL imop:h001@cc.com/F1 not only works between
aa and cc.com, but can also be passed around the Internet
without affecting its identity. To make conversation with the
type, a program at a different host will connect to the host
cc.com and send requests with the address h001@cc.com/F1
in the envelope, effectively using cc.com as a proxy. The host
cc.com may decide whether to fulfill such requests.
E. Summary
As we have illustrated above, with interface types and the
over-the-wire type reflection supported by IMOP, not only a
program can interact with an open set of remote resources
that it has not “seen” before, but such interaction can also
be rigorously and automatically verified by a runtime system.
In addition, the object-oriented nature of the language and
the protocol allows one to extend an existing interface and
build objects based upon the new interface. Existing objects
that understand only the old interface can still safely interact
with these new objects via polymorphism, and vice versa. For
example, in the Ap2 example in Fig. 7, suppose site ee.com
has a new object E’ that implements an interface D’ extended
from D. The site cc.com can still use existing service C to
operate E’, even though it does not know the new interface
D’.
Although the figures in this section might seem complicated,
the actual IMOP messages exchanged between hosts are quite
simple. Most operations can be achieved by DESC and CALL
messages, and their JSON-based content is very lightweight.
These conversations do not need a heavy-weight middleware
to process. They can be made by simple libraries written in
many programming languages.
Moreover, if we ignore the dialog balloons of IMOP, the
program codes in the examples are remarkably simple, even
though they are meant to deal with object interactions over the
Internet. For example, the program code in the Ap2 example
references and operates remote objects simply by their UTLs.
These expressions are very intuitive and easy to understand.
The global uniqueness feature of UTLs and the type reflection
mechanism of IMOP relieve programmer’s burden to manually
relate a reference name to the actual target object. As such,
developing applications in an Internet-like open environment
is as easy and type-safe as developing them in a single runtime
environment where one needs not worry about name resolution
between different runtime environments.
IV. RELATED WORK AND CONCLUSIONS
Existing technologies for program interactions are often
based on remote procedure calls (RPCs), e.g., CORBA, the
WS-* stack [13], .NET Remoting [14], Java RMI [15], and
DRb [16]. They are designed to make remote objects look like
local ones so that detailed procedures in handling a remote
method invocation can be hidden from a programmer. Still,
cumbersome steps such as object registration and binding are
often necessary to relate remote objects in a local code. Fig. 10
gives an example in Java RMI, where a client wishes to use
an object created by a server. Before the use, the server must
register the object to an RMI registry at foo.com with the
network name rmi://foo.com/B, while the client must resolve
that name from the same registry and binds the result to a
dynamic proxy.
package foo;
public interface IB { ... }
package foo;
public class IBimpl
       implements IB { ... }
package foo;
public interface IB { ... }
package abc;
import foo.IB;
public class Client { ...
  IB obj = 
    (IB) Naming.lookup(
           "rmi://foo.com/B"
         );
}
package foo;
public class Server { ...
  Naming.rebind(
    "rmi://foo.com/B", new IBimpl()
  );
}
"rmi://foo.com/B"Local proxy object
supports local foo.IB type Network name
Local IBimpl object
supports local foo.IB type
Fig. 10. Name binding in Java RMI
Also note that the object is of class IBimpl, which imple-
ments an interface foo.IB. The interface file must be obtained
by the server side and by the client side respectively for their
code to be compiled. It is possible that the server and the client
obtain different interface files of foo.IB, so that each of them
can be correctly compiled but execution of them will result
in a runtime error due to an inconsistent interpretation of the
22
[19] J. Kopecky´, K. Gomadam, and T. Vitvar, “hRESTS: An HTML
Microformat for Describing RESTful Web Services,” in Proc.
WI-IAT - Volume 01, 2008, pp. 619–625. [Online]. Available:
http://portal.acm.org/citation.cfm?id=1486927.1486962
[20] M. Hadley, “Web application description language,” Sun Microsystems,
Tech. Rep., August 2009.
24
  
26 
 
when the client device is being developed, the knowledge of the server and its APIs 
can be built into the client device directly. For example, a client device may be built to 
obtain map information from a particular web-based map server to display restaurant 
locations on a map. Since the web-based map server is chosen at development time, 
the information such as the web server’s access URL and its APIs can be compiled 
into the client device’s program. 
In many applications, however, the server’s information is unavailable while a 
client device is being developed. For example, different company’s networks may 
have different printer servers, network cameras, or database servers. The information 
about these servers is available only when a client device is participating in the 
network at runtime, but not at development time. Historically, to build a client device to 
communicate with such servers, the program in the client is built to work with a 
particular set of APIs, and the client uses an API detection mechanism to interrogate 
whether a given server supports the APIs at runtime. Since a client device may 
encounter many different servers in different networks, it is often preferred that the API 
detection mechanism can be applied to a wide range of servers. This is increasingly 
important with advances in the Internet and in mobility technologies, in that a client 
device has the potential to communicate with any server in the world. 
Unfortunately, at present, API detection mechanisms can only be applied to a 
very limited set of servers that are closely related to the client device during their 
development phase, and may even produce faulty results when applying to other 
servers. This is because most API detection mechanisms require some server specific 
information in the client device. Such information is not available at runtime and 
therefore must be built into the client device beforehand. 
For example, with the current API detection mechanism, a server may present 
  
28 
 
to apply in detecting a web server’s APIs. The large number of web application 
servers in the Internet dramatically increases the possibility of API naming collision, 
whereas reaching the consensus on API definitions among different web servers is 
difficult since each web server may be operated by a different party. Without the 
consensus on API definitions, a client cannot reliably detect a foreign web application 
server’s API at runtime and correctly communicate with the server thereafter.  
Therefore what is required is a mechanism that allows a client device to 
automatically resolve the APIs of a server in such way that the consensus of API 
definitions can be established between the client and the server even if the client, the 
server, and the API definitions are each developed by a different party.  
 
SUMMARY OF THE INVENTION 
This invention relates to a method and system that allows a client electronic 
device to automatically determine whether a server electronic device can be 
communicated in accordance with certain API definition using the information 
obtainable at runtime. This is achieved by requesting a server device for the APIs it 
supports from a client device, and the server device responding with information 
containing a list of API identifiers, wherein each identifier contains the network 
address where the corresponding API definition document is reposited. The client 
device then associates the API identifiers with the API that the client understands to 
resolve available APIs for communicating with the server. Here, “the client 
understands the API” means that the client supports the API and can communicate 
with a device in accordance with the API. 
The essence of this invention is to use the network address from which an API 
definition document can be fetched as an API identifier to assist the API detection and 
  
30 
 
as follows: the client fetches the API definition from the network address pointed to by 
the unrecognized identifier. If the definition contains a list of parent API identifiers that 
the API in question is extended from, and client recognizes any of the parent API 
identifiers, the client can communicate with the server through the recognized parent 
API. If the client device does not recognize the parent API identifiers in the list either, 
the client may further fetch their API definitions, which may contain even more parent 
API identifiers to be investigated. This recursive procedure goes on until the client 
recognizes a parent API identifier, or all obtained parent API identifiers are 
investigated. Note that the APIs corresponding to all parent API identifiers obtainable 
through the recursive tracing procedure are all called the parent APIs of an extended 
API. 
This invention also includes a method and system that allows a client electronic 
device to automatically discover a server electronic device that supports a particular 
API in a network. In the event that a client device seeks a server device that supports 
a particular API, the client device sends a broadcast message containing the 
aforementioned API identifier of the API to all devices in the network. A server 
receiving the message will determine the compatibility between the requested API and 
the server’s APIs, and will report the server’s network address to the client if the 
server determines that they are compatible.  
BRIEF DESCRIPTION OF THE DRAWINGS 
 
Fig. 1 shows a distributed system wherein the client determines the support of an API 
on the server in accordance with the first embodiment of the invention. 
 
Fig. 2 shows a distributed system wherein the client determines the support of an API 
on the server in accordance with the second embodiment of the invention. 
  
32 
 
printer becomes a client device when requesting date and time information from a 
network time server. 
Fig. 1 illustrates the first embodiment of this invention. In a distributed system 
100, a client electronic device 110 intends to communicate with a server electronic 
device 120, using methods described in the application programming interface 
definition document 135. The document 135 describes an API’s definition in a 
machine processable format, such as industry standard formats XML or JSON. The 
API definition document 135 details the communication actions that may apply to a 
server supporting the API, such as a list of function names with their respective input 
and output data types that may be called on the server, a list of properties that may be 
read from or write to the server, and a list of special data type definitions that may be 
used in the communication, and so on. 
The API definition document 135 is reposited in a host computer 130 in the 
distributed system 100, and (a) is the network address from which document 135 can 
be fetched in the system 100. Many standard technologies allow the computer 130 to 
provide the document 135 over the network. For example, computer 130 may have a 
web server running on it, and provides the document 135 over HTTP upon request. In 
such case, (a) is the HTTP URL address where the document 135 may be obtained 
from the web server. Here, (a) is also used as the API identifier that represents the API 
definition described in the document 135. We call this API as API (a) for brevity in this 
discussion. 
The client device 110 is built to communicate with any server that supports API 
(a). When developing the client, a programmer fetches the API definition document 
from the network address (a) (Fig. 1, step I), and the computer 130 will return a copy 
of the document 135 (Fig. 1, step II). The programmer then builds the client program 
  
34 
 
document 125 (Fig. 1, step VI). It should be noted that the mechanism for sending the 
API inquiry request depends on the network protocol between the client 110 and the 
server 120. For example, the server 120 may be a web server using HTTP protocol, 
and the server’s HTTP URL location is given to the client 110. In such case, the API 
inquiry request sent from the client 110 is just a standard HTTP GET request sent to 
the server’s URL location, and the server will return the document 125 in an HTTP 
response message.  
A server specification document contains a list of API identifiers corresponding 
to the APIs which the server supports, and optionally a list of communication action 
definitions specific to the server that are not part of the listed APIs. A server may 
support a number of APIs, and their API identifiers are listed in the server’s 
specification document. The server specification document may be created during the 
development of the server, or be generated at runtime by the server program from the 
list of API identifiers that the server supports. 
In this embodiment, the specification document 125 contains the API identifier 
(a). Once the client 110 obtained the document 125, the client 110 compares the API 
identifiers listed in the document 125 with the API identifier (a). If the identifier (a) 
matches an API identifier listed in the document 125, the client 110 concludes that the 
client may communicate with the server 120 by using methods described in API (a). 
For example, if the API (a) contains the definition of a remote function, the client 
device 110 may call the remote function on the server 120. It should be noted that a 
client may be built to support multiple APIs, and will determine whether each API is 
supported by a server, then select the supported APIs to communicate with the server 
accordingly. 
The significance of this API detection method lies in that the client 110 does not 
  
36 
 
what the latest definition of API (a) is, since the latest version is always the document 
135 currently available on the computer 130. 
It should also be noted that devices in the distributed system 100 may be 
interconnected by homogeneous as well as heterogeneous networks. That is, the 
client 110, the server 120, and the host computer 130 need not be interconnected with 
the same network technology. For example, the client 110 may use the Bluetooth 
technology to communicate with the server 120, whereas the computer 130 is on the 
Internet accessible through the TCP/IP protocol. The client 110 may obtain the server 
specification document 125 over a Bluetooth connection, whereas the API definition 
document 135 is fetched through HTTP over a TCP/IP connection. Each API identifier 
listed in a server specification document may reference the network address in a 
different networking technology. Similarly, each parent API identifier listed in an 
extended API definition document may also reference the network address in a 
different networking technology. 
Fig. 2 illustrates the second embodiment of this invention. In a distributed 
system 200, a client electronic device 210 intends to communicate with server 
electronic devices 220 and 230, using methods described in the API definition 
document 245. API definition documents 245, 255, and 265 are reposited in the host 
computers 240, 250, and 260 respectively in the distributed system 200; the 
documents can be obtained from the network addresses (b), (c), and (d) respectively 
in the distributed system 200; (b), (c), and (d) are also used as the API identifiers to 
represent the API definitions described in the documents 245, 255, and 265 
respectively in the distributed system 200. We call these APIs as API (b), API (c) and 
API (d) for brevity. 
The client device 210 is built to communicate with any server that supports the 
  
38 
 
titles. 
The API definition document of the extended API contains a list of network 
addresses, each of which is the API identifier of a parent API, along with the 
definitions of extra communication actions, such as a list of function names with their 
respective input and output data types that may be called on the server, a list of 
properties that may be read from or write to the server, and a list of special data type 
definitions that may be used in the communication, and so on. It should be noted that 
the API extension relationship may extend beyond one level, in that one API is 
extended from a parent API, which in turn is extended from yet another parent API, 
and so on. All APIs that an extended API directly or indirectly extended from are called 
the parent APIs of the extended API. 
In this embodiment, the client 210 needs to determine whether API (c) or API (d) 
is extended from the API (b) understood by the client. To investigate API (c), the client 
210 sends a request to the network address (c) (Fig. 2, step III) to fetch the API 
definition document 255 from the host computer 250 (Fig. 2, step IV). Here, the API 
definition in the document 255 does not list API (b) as a parent API. Therefore the 
client 210 determines that API (c) is not extended from API (b). Subsequently, the 
client 210 investigates API (d) by sending a request to the network address (d) (Fig. 2, 
step V) to fetch the API definition document 265 from the host computer 260 (Fig. 2, 
step VI). In this embodiment, the document 265 lists the API identifier (b) as a parent 
API. Therefore the client 210 determines that API (d) is extended from API (b). 
Accordingly, the client 210 concludes that it may communicate with the server 220 in 
accordance with API (b), since the server 220 supports API (d) and API (d) is an 
extension to API (b). The client 210 may choose to store the documents 255 and 265 
in the device for a period of time, so that the client does not need to obtain them again 
when the definition of API (c) or (d) is needed later. 
  
40 
 
server, the client needs to send an API inquiry request to the server to detect the 
server’s APIs. This may be time consuming if there are many servers the client needs 
to investigate. Therefore, in the third embodiment of the present invention, another 
method related to determining the support of an API on a server is broached. 
Fig. 3 illustrates the third embodiment of this invention. In a distributed system 
300, a client electronic device 310 intends to communicate with server electronic 
devices 320, 330, and 340 using methods described in the API definition document 
355. API definition document 355 and 365 are reposited in the host computer 350 and 
360 respectively in the distributed system 300; the documents can be obtained from 
the network address (e) and (t) respectively in the distributed system 300; (e) and (t) 
are also the API identifiers to represent the API definition described in the document 
355 and 365 respectively in the distributed system 300. We call these APIs as API (e), 
API (t) and API (d) for brevity. 
The client device 310 is built to communicate with any server that supports the 
API definition 355, which is identified by the API identifier (e). At runtime, the client 
device receives the address information of the server 320, 330, and 340 from sources 
such as user inputs, configuration files, or from communicating with another server. 
The client then intends to communicate with the servers. In this embodiment, the 
address information received by the client are in a compound format, wherein every 
compound address includes the network address of the server and a list of API 
identifiers of the APIs that the sever supports. In this embodiment, address(server 320) 
# encoded(t), address(server 330) # encoded(t), and address(server 340) # encoded(t) 
are three such compound addresses. In every compound address, the portion before 
the symbol ‘#’ is the network address of the server, and the portion after the symbol ‘#’ 
is an encoded string of the API identifiers that the server supports. It should be noted 
that different compound address formats may be used in the client device, and the 
  
42 
 
given in the above embodiments. The procedure begins when an address (n) is given 
(Fig. 4, step I). If the address format is not supported (Fig. 4, step II), the procedure 
will conclude that the server identified by (n) may not support API (a) and should not 
be communicated in accordance with API (a) (Fig. 4, step XIX). If the address format 
is supported, the address will be analyzed to see if it is a compound address (Fig. 4, 
step III). If it is not a compound address, the address (n) is the network address (r) of 
the server (Fig. 4, step IV). A network request will then be sent to (r) to obtain the 
server’s API information (Fig. 4, step V), which contains a list of API identifiers (L) (Fig. 
4, step VI). Conversely, if the address (n) is a compound address, (n) will be decoded 
into the server’s network address (r) and a list of API identifiers (L) (Fig. 4, step VII). 
Either way, (L) will contain a list of API identifiers supported by the server identified by 
the address (n). An empty list (V) is then created to store the identifiers that have been 
analyzed in the procedure (Fig. 4, step VIII). 
The API identifiers in (L) are analyzed as follows. An API identifier (w) in (L) is chosen 
and removed from (L) (Fig. 4, step X). If the chosen identifier (w) equals (a), the 
procedure ends immediately and concludes that the server identified by (n) supports 
API (a), and the server may be communicated at network location (r) (Fig. 4, step XX). 
If the chosen identifier (w) is not equal to (a), (w) will first be added to the list (V) (Fig. 
4, step XII) and then examined whether the definition document of API (w) has been 
obtained before (Fig. 4, step XIII). If it has not been obtained before, a network 
request will be sent to network location (w) (Fig. 4, step XIV), and the definition 
document of API (w) will be received in the response message (Fig. 4, step XV). If the 
definition document contains a list of API identifiers representing the parent APIs from 
which API (w) is extended (Fig. 4, step XVI), all these parent API identifiers are added 
to (L) (Fig. 4, step XVII). (L) is then examined to remove any API identifier in (L) that 
also exists in (V) (Fig. 4, step XVIII). The steps (IX) to (XVIII) are repeated until either 
  
44 
 
network used in the system 400. 
A server device that allows its existence to be automatically discovered has 
program code constantly listening to broadcast messages in the network. In this 
embodiment, server device 420, 430, and 440 are all listening to broadcast messages. 
The server 420 supports API (f); therefore upon receiving the broadcast request 
message sent from the client 410 looking for servers that support API (f), the server 
420 sends a response message containing the network address of server 420 to the 
client (Fig. 5, step II). The server 430 supports API (g), which is an extended API of 
API (f). Upon receiving the broadcast request message sent from the client 410, the 
server 430 knows that even though the server supports API (g), it can still be 
communicated with the requested API (f) from which API (g) is extended, so the server 
430 sends a response message containing the network address of server 430 to the 
client (Fig. 5, step III). The server 440 supports API (h), which is not an extension to 
the API (f). Accordingly, the server 440 makes no response upon receiving the 
broadcast message from the client 410. After receiving the response messages sent 
by the server 420 and 430, the client 410 obtained the network addresses of server 
420 and 430, and the discovery process is completed. The client may then 
communicate with server 420 and 430 in accordance with API (f). 
It should be noted that the broadcast request message sent by a client device 
may contain more than one API, and Boolean conditions may be used to express the 
requirement of the request. For example, the broadcast request message sent to the 
network of the system 400 may request servers that support either API (g) or API (h) 
to respond, or request servers that support both API (g) and API (h) to respond. In the 
former case, both server 430 and 440 will respond, while in the latter case, no server 
will respond as none of them support both API (g) and API (h). 
  
46 
 
WHAT IS CLAIMED IS: 
1. A method for detecting and resolving application programming interfaces (APIs) 
of a server in a distributed system, comprising: 
 requesting a server by a client for the APIs supported by the server; and 
 responding by the server to the client with a list containing the identifiers of the 
APIs supported by the server, wherein each of the identifiers contains the 
network address from which the corresponding API definition document can be 
obtained. 
 
2. The method as recited in claim 1, further comprising: 
 extending at least one parent API with extra features to an extended API; and 
 listing the extra features and the identifiers of the parent APIs in the definition 
document of the extended API, wherein each of the identifiers contains the 
network address from which the corresponding parent API definition document 
can be obtained. 
  
3. The method as recited in claim 1 or claim 2, wherein the program in a client or 
the program in a server is configured to: 
 fetch the API definition document from the network address pointed to by the 
identifier of one API supported by the program; and 
 compare the fetched API definition document to the corresponding API definition 
document used when the program was built to detect changes in the API 
definition. 
  
4. The method as recited in claim 1 or claim 2, further comprising: 
  
48 
 
7. The method as recited in claim 5 or claim 6, further comprising: 
 selecting by the client one identifier corresponding to one API understood by the 
client from: 
(c) identifiers in the list decoded; or 
(d) identifiers of parent APIs of an extended API whose identifier is in the list 
decoded; and 
 communicating with the server by the client in accordance with the API definition 
document corresponding to the selected identifier. 
  
8. An automatic API-detecting-and-resolving-enabled distributed system, 
comprising: 
 a server electronic device connected to at least one network and having a 
computer program stored therein to configure the server electronic device to: 
  
receive a request for the APIs supported by the server electronic device; 
respond to the request with a list containing the identifiers of the APIs supported 
by the server electronic device, wherein each of the identifiers contains the 
network address from which the corresponding API definition document 
can be obtained; and 
communicate in accordance with the API definition documents corresponding to 
the identifiers included in the list. 
 
9. A system as recited in claim 8, further comprising: 
a group of host computers wherein each host computer provides API definition 
documents to be fetched at the network addresses pointed to by: 
(a) a number of identifiers in the list responded by the server; and/or 
  
50 
 
(f)  a list containing the identifiers of the APIs supported by the server 
electronic device, wherein each of the identifiers contains the network 
address from which the corresponding API definition document can be 
obtained; 
decode the compound address into the network address of the corresponding 
server electronic device and a list of the identifiers of the APIs supported by 
the server electronic device; 
select one identifier corresponding to one API understood by the client electronic 
device from: 
(g) identifiers in the list decoded; or 
(h) identifiers of parent APIs of an extended API whose identifier is in the 
list decoded; and 
communicate with the server electronic device in accordance with the API 
definition documents corresponding to the selected identifier. 
  
12. A system as recited in claim 10, wherein the networks interconnecting the client 
electronic device, the server electronic device, and the host computers can be 
homogeneous or heterogeneous. 
 
13. A system as recited in claim 11, wherein the networks interconnecting the client 
electronic device, the server electronic device, and the host computers can be 
homogeneous or heterogeneous. 
 
14. A method for discovering a number of servers that support one API in a 
distributed system, comprising: 
  
52 
 
respond to the request with the network address of the server electronic device if 
the server electronic device can be communicated with in accordance with 
the API definition document corresponding to the identifier in the request. 
 
18. A system as recited in claim 17, further comprising: 
a group of host computers wherein each host computer provides API definition 
documents to be fetched at the network addresses pointed to by: 
(a) the identifier in the request; and/or 
(b) a number of identifiers of parent APIs of an extended API whose identifier is 
in the request. 
 
19. A system as recited in claim 17 or claim 18, further comprising: 
 a client electronic device connected to at least one network and having a 
computer program stored therein to configure the client electronic device to: 
  
request to a number of server electronic devices with the identifier of one API, 
wherein the identifier contains the network address from which the API 
definition document can be obtained; and 
receive a number of responses wherein each response contains the network 
address of a server electronic device that can be communicated with in 
accordance with the API definition document corresponding to the identifier 
in the request. 
 
20. A system as recited in claim 19, wherein the networks interconnecting the client 
electronic device, the server electronic device, and the host computers can be 
homogeneous or heterogeneous. 



 2
* Knowledge Systems 
* Organizational Systems and Technology 
* Software Technology 
The "Internet and the Digital Economy" track consists of the following mini-tracks: 
* Electronic Marketing 
* Emerging Risks and Systemic Concerns in Information Security Research and Applications 
* Innovation and the Digital Economy 
* Open Movements: FLOSS, Open Contents, Open Access and Open Communities  
* Research 2.0: Web 2.0 and Virtual Worlds as Research Environments 
* Social Networking and Communities 
* The Diffusion, Impacts, Adoption and Usage of ICTs upon Society 
Our paper, entitled “Recommendation Systems and Sales Concentration: The Moderating Effects of 
Consumers’ Product Awareness and Susceptibility to Recommendations”, belongs to the mini-track 
"Electronic Marketing". The paper investigates how recommendation systems affect sales concentration 
in the e-market. In the literature, there have been two opposite theories accounting for this issue: the 
winner-take-all theory and the long tail theory. The former predicts that the market will be homogenized 
by recommendation systems, whereas the later predicts that the market will be fragmented. We argue that 
both directions of influence are possible, depending on the types of products that recommendation 
systems favor. Furthermore, we argue that the effects of recommendation systems are moderated by 
consumers’ cognitive states before and after they encounter the systems, namely their awareness of 
products and their acceptance level to recommendations. We used the simulation method on the 
MovieLens dataset to support our hypotheses. The paper was nominated for best paper award. 
Unfortunately, we did not make it in the final competition among the other candidates in the “Internet and 
the Digital Economy” track. 
I also attended several other sessions. In general, I found that there are lots of interactions among 
the participants. There are always questions and discussions after each paper presentation in all the 
sessions I attended. I also met a number of people from Taiwan, including my colleague. I realized that 
there are five papers from our department. Unfortunately, two of them have no one to present the paper. 
There are two invited talks. The first one is given by Cynthia Breazeal, an associate professor at the 
MIT Media Lab. She is a pioneer of Social Robotics and Human Robot Interaction. Her talk, “The Social 
Side of Robotics”, highlight a number of provocative research findings that illuminate the social attributes 
of personal robots. As she claimed, "This new "breed" of social robot interacts with people in an 
interpersonal way, more as a partner rather than as a tool, and opens new applications for socially 
intelligent machines in the future." I was quite impressed by how they designed their robots to socially 
interact with human. Perhaps someday we will be sounded by robots which are able to express their 
 1
 
國科會補助專題研究計畫出席國際學術會議心得報告 
                                  日期：2011 年 9 月 1  日 
一、參加會議經過 
Established in 1993 in Taiwan, the Pacific Asia Conference on Information Systems (PACIS) is an 
annual conference for Information Systems and Information Technology academics and professionals, 
and is affiliated with the Association for Information Systems. Over the years it has gradually earned its 
reputation and now been considered one of the three most important conferences in the IS fields, the other 
two being International Conference on Information Systems (ICIS) and Hawaii International Conference 
on System Sciences (HICSS). PACIS, as its name suggests, is primarily held in the Asia Pacific. This 
year’s conference was held in Brisbane 7-11 July 2011, and hosted by the Information Systems Discipline 
of the Faculty of Science and Technology at Queensland University of Technology (QUT), and the 
Doctoral Consortium by University of Queensland (UQ). QUT is located in the Central Business District 
of Brisbane. The conference theme is “Quality Research in Pacific Asia”, which emphasizes the growing 
importance of the region as a source of internationally recognized top-tier research in Information 
Systems, and the growing recognition of value from IS contributions and developments beyond the 
discipline. 
PACIS 2011 attracted 529 paper submissions to 27 tracks. Each paper was peer reviewed by at least 
two reviewers and the track chair. Among which, 182 full papers were accepted, along with 18 poster 
presentations of research-in-progress papers. Each full paper gets 30 minutes to present. There are also 
several workshops and a Doctoral Consortium (23 students) associated with the conference.  
The paper list of PACISS 2011 can be found in 
http://www.pacis-net.org/index.jsp?t=proceeding&y=2011  
Overall, I found PACIS to be a nice conference to attend. The selected topics are broad and 
計畫編號 NSC 99-2221-E-002-099-MY3 
計畫名稱 為雲端運算設計之程式開發新方法 
出國人員
姓名 莊裕澤 
服務機構
及職稱 國立臺灣大學資訊管理學系 教授 
會議時間 2011 年 7 月 8 至 2011 年 7 月 15 日 會議地點 
Brisbane, Australia 
會議名稱 15th Pacific Asia Conference on Information Systems (PACIS 2011) 
發表題目 An Examination of Online Social Network Properties with Tie Strength 
附件五 
 1
 
國科會補助專題研究計畫出席國際學術會議心得報告 
                                   日期：2013 年 6 月 1 日 
一、參加會議經過 
For the past twenty-eight years, the ACM Symposium on Applied Computing (SAC) has 
been a primary gathering forum for applied computer scientists, computer engineers, 
software engineers and application developers from around the world. SAC is sponsored 
by the ACM special Interest Group on Applied Computing (SIGAPP) and had held regular 
meetings since 1986. This year, the 28th edition, was held at the Institute of Engineering of 
the Polytechnic Institute of Coimbra at Coimbra, Portugal. The program committee 
received 1063 papers, among which, 255 papers were selected, with an accept rate at 
23.98%. Accepted papers are published in the annual conference proceedings. 
二、與會心得 
I think the conference is well organized. Many attendees actively participate the 
conference through out the days. However, I find that it is a bit lack of focus. “Applied 
computing” is a catch-all umbrella that can cover all kind of computing related works 
short of theoretical ones, and the conference feels like it actually does. The conference has 
計畫編號 NSC 99-2221-E-002-099-MY3 
計畫名稱 為雲端運算設計之程式開發新方法 
出國人員
姓名 洪振超 
服務機構
及職稱 台大資管所博士生 
會議時間 
2013 年 3 月 18 日
至 
2013 年 3 月 22 日 
會議地點 
Coimbra, Portugal 
會議名稱 
(中文) 
(英文) The 28th Symposium On Applied Computing 
發表題目 
(中文) 
(英文) Meso: An Object-Oriented Programming Language Building 
Strongly-typed Internet-Based Network Applications 
附件五 
 1
 
國科會補助專題研究計畫出席國際學術會議心得報告 
                                  日期：2013 年 6 月 1  日 
一、參加會議經過 
The International Conference on Advanced Information Networking and Applications 
(AINA) is a conference sponsored by Technical Committee on Distributed Processing 
(TCDP) of the IEEE computer Society. It was held at the Catalonia Barcelona Plaza hotel 
in Barcelona, Spain. The conference covers theory, design and application of computer 
networks and distributed computing and information systems. The accepted papers are 
published in the proceeding of the conference by IEEE Computer Society. 
二、與會心得 
This is the first IEEE conference that I attended, and it feels quite different from the ACM 
conferences that I attended in the past. The event is smaller, the venue is smaller, and the 
attendees are less enthusiast. Given that what I published here is something that I worked 
for a long time, believe dearly, and wish influential people in the area can hear, I was quite 
sad end up in a place like this. During my presentation, people in the room couldn’t care 
計畫編號 NSC 99-2221-E-002-099-MY3 
計畫名稱 為雲端運算設計之程式開發新方法 
出國人員
姓名 洪振超 
服務機構
及職稱 台大資管所博士生 
會議時間 
2013 年 3 月 25 日
至 
2013 年 3 月 28 日 
會議地點 
Barcelona, SPAIN 
會議名稱 
(中文) 
(英文) The 27th IEE International Conference on Advanced Information 
Networking and Applications 
發表題目 
(中文) 
(英文) Internet Metaobject Protocol (IMOP): Weaving the Global Program 
Grid 
附件五 
國科會補助計畫衍生研發成果推廣資料表
日期:2013/12/26
國科會補助計畫
計畫名稱: 為雲端運算設計之程式開發新方法
計畫主持人: 莊裕澤
計畫編號: 99-2221-E-002-099-MY3 學門領域: 程式語言與軟體工程
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
完成整個平台系統的實作，並且開放程式碼供人下載使用，可從我們的計劃網
站 http://gpgrid.org 下載。 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
