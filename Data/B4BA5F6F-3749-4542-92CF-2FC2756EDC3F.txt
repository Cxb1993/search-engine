 1 
行政院國家科學委員會專題研究計劃期末報告 
快速里德所羅門碼解碼器與二元平方剩餘碼解碼器合併應用於 
數位訊號處理器上(3/3) 
計畫編號：NSC 95-2221-E-214-042-MY3 
執行期限：95年8月01日至98年7月31日 
主持人：張肇健 義守大學資訊工程學系 
 
一、中文摘要 
 
第一年度的計畫研究重點是將剩餘多項
式 (Remainder Polynomial) 加入快速轉換解
碼(Fast Transform Decoding)演算法與Gao演
算法的解碼步驟中發展出新程序的RS解碼
演算法並同時完成解碼器模擬測試。當年，
本研究小組依照研究計劃內容獲得了多項豐
碩成果。首先，里德所羅門碼解碼的快速解
碼法[1]已在期刊於今年在IEEE Trans. On 
Communications發表。進一步地，二次剩餘
碼(89, 45, 17)的代數解碼演算法也已經完
成。對於上述的解碼方式軟體模擬都已經儘
可能的測試完成。並發展出一套檢測解碼是
否正確的理論，配合此理論之解碼法已於
2008年 11月發表於 IEEE Transactions on 
Information Theory。 
第二年度的計畫研究重點是將修改
Welch-Berlekamp演算法與Euclidean演算法
實現在里德所羅門(RS)碼與改良後應用於二
次剩餘(QR)碼上。再者，與第一年完成的演
算法:快速轉換解碼(Fast Transform Decoding)
演算法與Gao演算法的解碼步驟中發展出新
程序的RS解碼演算法進行比較。該年，本研
究小組依照研究計劃內容獲得了多項豐碩成
果。首先，非系統里德所羅門碼解碼使用
Euclid’s與快速富麗葉轉換演算法的快速解
碼法[1]已在今年發表於期刊IEEE Trans. On 
Communications。此篇論文發展出ㄧ個取代
求錯誤位置與錯誤值多項式而直接獲得傳輸
訊息的解碼演算法。也同時記載與使用推廣
Gao’s演算法與Shiozaki-Truong-Cheung-Reed
之複雜度比較。在二次剩餘碼方面，首次使
用Euclidean演算法於二次剩餘碼的代數解碼
演算法 [2]也已經完成，並在今年被期刊
Journal of Information Science and Engineering
所接受並發表。此方式與以往常被使用的BM
解碼演算法之比較與分析結果也被完成且記
載於此篇論文中。 
第三年則比較第一與第二年得到的演算
法同時考量解碼速度與連結RS碼與QR碼用
於Digital SignalProcessing (DSP)上，提升原解
碼器之解碼速度。 
 
關鍵詞：里德所羅門碼， 二次剩餘碼，快速
富利葉轉換, 歐基理德演算法 
 
Abstract 
 
Reed-Solomon codes for correcting both 
errors and erasures are used extensively in space 
communication links, compact-disc (CD) audio 
systems, HDTV, digital versatile discs (DVD), 
and the IEEE 802.16 standard. The accepted 
paper, which is entitled a fast algorithm for the 
syndrome calculation in algebraic decoding of 
Reed-Solomon Codes, will be published in 
IEEE Transactions on Communications. 
In this letter, Fedorenko and Trifonov’s 
procedure is applied to evaluate the syndrome of 
the received word in the time-domain 
Reed-Solomon (RS) decoders. This application 
leads to a substantial reduction of the 
computational complexity of the syndrome 
 3 
去年已完成(89, 45, 17)二次剩餘碼的解碼，
並完成結果書寫成論文投稿於IEEE Trans. 
On Inform. Theory發表[13]。 
本研究小組首先提出一個經由改良
Gao’s 演算法所獲得的非系統里德所羅門碼
快速解碼演算法。更進ㄧ步，我們所提出的
解碼演算法所花的時間與Goa’s解碼演算法
做比較。結果如下Table III。 
 
Results and discussion 
 
In [13], we determine the unknown 
Syndromes S3 and S13 of the (89, 45, 17) QR 
Code. In what follows, the primary unknown 
syndromes S3 and S13 usually needed to realize 
the inverse-free BM algorithm are determined. 
An index with parentheses is attached to the 
unknown syndrome “Sr” to obtain the notation 
“Sr(v)”, indicating that the formulae  obtained 
are valid for the v-error case only. Also, the 
digit v after the word “Case” indicates that the 
number of errors occurred is v. Furthermore, 
“Case va)” and “Case vb)” denote two 
sub-cases for determining the primary 
unknown syndromes S3(v) and S13(v), 
respectively. In each case, one lists explicitly 
the two subsets I and J needed in [13, Eq. 2] to 
determine S3(v) and S13(v), separately. Because 
the equation in Sr(v) obtained from [13, Eq. 3] 
become more complicated when the value of v 
increases, only the explicit equations to 
determine the unknown syndromes in the cases 
v ≤ 2 will be shown in detail. In all other cases, 
i.e., v ≥ 3, four monomials of the polynomial 
det(S(I, J)) in S3(v) and S13(v) are only 
considered.  
In order to show that det(S(I, J)) in either 
S3(v) or S13(v) is a nonzero polynomial for the 
cases v ≥ 2, some special subsets I and J are 
given. It is obvious that det(S(I, J)) is a 
nonzero polynomial in S3(v) (resp., S13(v)) for 
case 2, because the coefficient of a term of 
det(S(I, J)) in S3(v) (resp., S13(v)) is equal to one. 
For the cases v ≥ 3, there exist four monomials 
of det(S(I, J)) in either S3(v) or S13(v) whose 
coefficients can be expressed as some powers of 
the primary known syndromes S1, S5, S9, and S11. 
By Corollary 1 given in [13], det(S(I, J)) is a 
nonzero polynomial in either S3(v) or S13(v) for v ≥ 
3. Then the value of either S3(v) or S13(v) is one of 
the roots of the equation det(S(I, J)) = 0. In 
other words, S3(v) (resp., S13(v)) can be 
determined by using the Chien search to solve 
the roots of det(S(I, J))=0 in S3(v) (resp., S13(v)). 
In each odd-error case, the syndrome S0 is 
always equal to one, but zero in every 
even-error case. 
Case 0: For the zero-error case, obviously, the 
primary known syndromes S3(0) = S13(0) = 
0. 
Case 1:  For the one-error case, the primary 
unknown syndromes S3(1) = S13 and 
S13(1) = S113. 
Case 2:  This case differs significantly from 
the previous two cases. One endeavors 
to find the unknown syndromes S3(2) and 
S13(2) by solving the roots of the 
equations shown in sub-cases a) and b), 
respectively. Assume the number of 
errors is two, i.e., v = 2 and S0 = 0. Two 
sub-cases are to be considered as 
follows: 
a)  Let I = {0, 1, 47} and J = {1, 6, 45}. 
From [13, Eq. 3], the equation, det(S(I, 
J)) = 0 which is expressed in terms of 
some powers of the unknown syndrome 
S3 is given in the following: 
S31042 + S1S564S31024+ S11024S348 + 
S1S333 + S12S33 + S11026S564 = 0.         (1) 
 5 
Case 6: For the six-error case, the 
following two sub-cases are 
considered:  
a) Let I = {0, 1, 3, 4, 5, 8, 47}, and J = {1, 
2, 3, 6, 17, 45, 88}. From [13, Eq. 3], 
one obtains det(S(I, J)) in S3 with four 
monomials S92S31109, S1110S31108, 
S164S31064, and S568S31061. According to 
Corollary 1 given in [13], det(S(I, J)) 
is a non-zero polynomial in S3(6). 
Similarly, S3(6) must be one of the 
roots of the nonzero polynomial. In 
other words, the unknown syndrome 
S3(6) can be determined by one of the 
roots of [13, Eq. 3]. 
b) As usual, let I = {0, 15, 17, 34, 35, 45, 
54} and J = {15, 17, 34, 36, 45, 55, 
70}. Obviously, one obtains det(S(I, 
J)) in S13 with four monomials 
S1S131960, S916S131860, S11S131836, and 
S54S131582. By Corollary 1 given in 
[13], det(S(I, J)) is a non-zero 
polynomial in S13(6). Similarly, S13(6) 
can be determined by one of the roots 
of [13, Eq. 3]. 
Case 7: The seven-error case similar to the 
six-error case is given as follows: 
a) Let I = {0, 1, 3, 4, 5, 8, 19, 47}, and J 
= {1, 2, 3, 6, 17, 45, 84, 88}. From 
[13, Eq. 2], the matrix S(I, J) is 
obtained. Obviously, det(S(I, J)) 
yields the polynomial in S3 with four 
monomials S92S31173, S1110S31172, 
S164S31128, and S568S31125. By Corollary 
1 given in [13], det(S(I, J)) is a 
nonzero polynomial in S3(7). The value 
of S3(7) is thus determined by one of 
the roots of [13, Eq. 3]. 
b) In this sub-case, one chooses I = {0, 
15, 17, 34, 35, 36, 45, 54}, and J = 
{15, 17, 34, 35, 36, 45, 55, 70}. The 
matrix S(I, J) obtained by [13, Eq. 2] is 
used to yield [13, Eq. 3]. Obviously, 
det(S(I, J)) yields the polynomial in S13 
with four monomials S54S131964, 
S916S131708, S11S131684, and S11025S131428. 
By Corollary 1 given in [13], det(S(I, 
J)) is a non-zero polynomial in S13(7). 
Similarly, S13(7) is determined by one of 
the roots of [13, Eq. 3]. 
Case 8: For the case of eight errors, S3(8) and 
S13(8) are determined in the following 
two sub-cases, respectively: 
a) In this case, the pair (I, J)’s is used to 
determine S3(8); that is, I ={0, 1, 3, 4, 5, 
8, 19, 22, 47}, and J = {1, 2, 3, 6, 17, 45, 
84, 87, 88}. From [13, Eq. 2], one 
obtains the matrix S(I, J) whose 
determinant is a polynomial in S3 with 
four monomials S5128S31269, S165S31253, 
S92S31239, and S112S31119. Therefore, S3(8) 
can be determined by one of the roots of 
[13, Eq. 3]. 
b)  Let I = {0, 34, 36, 53, 54, 55, 64, 74, 
83}, and J = {15, 16, 17, 26, 45, 51, 70, 
85, 87}. By an argument similar to the 
seven-error case, the determinant of 
the matrix S(I, J) yields the 
polynomial in S13 with four monomials 
S11024S131980, S9256S131950, S111088S131946, 
and S54S131845. Thus, S13(8) can be 
determined by one of the roots of [13, 
Eq. 3]. 
After determining the primary unknown 
syndromes S3 and S13, one now has enough 
syndromes to apply the modified inverse-free 
BM algorithm. 
The flowchart of the proposed (89, 45, 17) 
QR decoder is depicted in Fig. 1. Let Sk(v)’s 
denote the unknown syndromes which are 
 7 
occurred in the received vector r  of n  
symbols such that .1 2  ds  Define the 
erasure-locator polynomial and error-locator 
polynomial as    sj jZxx 1 ),()(  where 
jZ  is the locator of the erasure position in the 
erasure vector ,μ  and 
,)( )(
1   vj jXxxW  where jX  is the 
locator of the error position in the error vector 
,e  respectively. Thus, the errata-locator 
polynomial is defined as ).()( xx   
)( xW ,)~( 
1  svj jZx  where jZ~  is either 
the jth erasure or error location. Finally, define 
the error- evaluator polynomial as 
,))(()(
  ,11



v
jii
i
v
j
j XxYxB  where jY  is 
the thj error magnitude. Following Gao’s 
algorithm, the procedure to correct errors only 
of RS codes is restated explicitly in the 
following three steps: 
Algorithm 1 
1) Using the fast Fourier transform (FFT) over 
)2( mGF  given in [1], compute an 
interpolating polynomial from  
 i
i rT  )(   for ,1    0  ni  (2)
where .1)}(deg{  nxT  
2) From the known )(xT  and ,1)(  nxxg  
one of the extended Euclidean algorithms is 
used to solve Eq. (7) given in [1], i.e.,  
),()()()()1( xPxTxWxBx n   (3a)
where ),()()( xMxWxP     , 2)1()}(deg{  dxW  
and    .12)1()}(deg{  dxB  
From (3a), the congruence relation is obtained 
as  
 .1  mod   )()()(  nxxPxTxW  (3b)
When the maximum 
kxP )}({ deg + 2)( knkt  ,2)( kn   
an unique pair of polynomials P(x) and W(x) is 
thus obtained. 
3) The message polynomial can be 
reconstructed by 
.
)(
)()(
xW
xPxM   (4)
In step 1, let , )( 1
0  ni ii xaxT  where 
.)2( mi GFa   The coefficients of T(x) can be 
calculated by the inverse transform over 
),2( mGF  namely, 


 

 1
0
 1  
n
i
ji
jj rna   for .10  nj (5)
Here we restrict n  to be an odd number; that is, 
2. mod  1n  The symbol ja  in (5) for 
10  nj  can be computed by using any of 
fast algorithms for the Fourier transform over 
finite fields. The second step of Algorithm 1 can 
also be implemented by the use of the fast 
algorithm, such as Moenck’s algorithm  and 
the extended Euclidean algorithm. The extended 
Euclidean algorithm similar to the 
Berlekamp-Massey (BM) algorithm can be 
usually used to reduce hardware complexity. 
Then, Gao’s algorithm is modified to 
correct erasures as well as errors by replacing 
the initial conditions of the Euclidean algorithm 
by the erasure-locator polynomial )(x  and 
errata interpolating polynomial 
.)()()( xxTxT   By this means, the 
polynomials )()()( xxPxP   and 
)()()( xxWx   can be obtained 
simultaneously and simply by the Euclidean 
algorithm only. To illustrate this, first the 
multiplication of both sides of the congruence 
 9 
satisfying (8) and (9). 
The Euclidean algorithm applied next to the 
known polynomials 1nx  and )(xT   as 
given by (7) is utilized to solve Eq. (10) for the 
polynomials )(xP  and .)(x  To see this, 
two recursive formulas in the Euclidean 
algorithm are shown to be  
 )()()()( 112 xxQxx llll     (11)
and 
 ),()()()( 112 xPxQxPxP llll    (12)
where )(1 xQl  is obtained as the principal 
part of )()( 12 xPxP ll    and the initial 
conditions are ,0)(1  x  ),()(0 xx   
,1)(1  nxxP  and .)()(0 xTxP    
The recursions in (11) and (12) terminate 
when the maximum deg  2)1()}({ sdnxPl   
for the first time for some value .ll   The 
polynomials )()( xPxPl   and )()( xxl    
are thus obtained. Obviously, one can obtain 
)()( xWx   with the initial conditions 
1)(0 x  and 0)(1  x  in the Euclidean 
algorithm. In order to obtain 
),()()( xxWx   it is shown in [16] that, in 
general, one needs to change the initial 
conditions: )()(0 xx   and .x 0)(1   
3) The message polynomial is obtained by  
 .
)(
)(
)()(
)()()()(
x
xP
xxW
xxWxMxM 

  (13)
 
四、計畫成果自評 
 
本計劃經研究小組努力，在本計畫執行
期間已有上述多項豐碩成果。可見本研究小
組在研究方面有顯著的成果並依各年計劃進
度執行。 
1. 完成里德所羅門碼解碼的快速解碼法[1]
並撰寫完成以被期刊IEEE Trans. On 
Communications所接受發表詳見附件。 
2. 完成對里德所羅門碼解碼的新解碼「快速
Berlekamp-Massey 演算法」的驗證 [1]。 
3. 完成二次剩餘碼(89, 45, 17)代數完全解碼。 
4. 完成二次剩餘碼(89, 45, 17)代數完全解碼
演算法演算法之程式模擬測試。 
5. 將”二次剩餘碼(89, 45, 17)代數完全解碼演
算法 ”結果撰寫完成並投稿至 IEEE 
Transactions on Information Theory，目前已發
表詳見附件。 
5. 完成非系統里德所羅門碼解碼的快速解碼
法[1]並撰寫完成投稿至期刊IEEE Trans. 
On Communications。 
6. 完成對非系統里德所羅門碼解碼的快速解
碼法[1]的驗證。 
7. 完成使用Euclidean演算法之二次剩餘碼代
數解碼演算法。 
8. 完成使用Euclidean演算法之二次剩餘碼代
數解碼演算法之程式模擬測試。 
9. 分析Gao’s演算法用於解平方剩餘碼與RS 
碼之相異點。 
10. 發展(89, 45, 17)QR碼之完全解碼演算
法，並使用程式驗證與獲得與不同長度之
QR碼之解碼效能比較。 
11. 完成QR碼解碼之模擬器，提供未來硬體
時現實的協助及測試資料。 
因而本研究小組已完整執行向國科會申
請「快速里德所羅門碼解碼器與二元平方剩
餘碼解碼器合併應用於數位訊號處理器上」
之計畫目標。 
 
五、參考文獻 
 
[1] Tsung-Ching Lin, T. K. Truong, and P. D. Chen, 
“Simplified Procedure for Decoding 
Nonsystematic Reed-Solomon Codes over 
GF(2m) Using Euclid’s Algorithm and The Fast 
Fourier Transform,” IEEE Trans. on 
Communications , vol.57, no.6, pp.1588-1592, 
2009.6. 
 11 
 
 
 
 
 
IEEE TRANSACTIONS ON INFORMATION THEORY, VOL. 54, NO. 11, NOVEMBER 2008 5005
Algebraic Decoding of the (89; 45; 17) Quadratic
Residue Code
Trieu-Kien Truong, Fellow, IEEE, Pei-Yu Shih, Student Member, IEEE, Wen-Ku Su, Student Member, IEEE,
Chong-Dao Lee, Member, IEEE, and Yaotsu Chang
Abstract—Recently, an algebraic decoding algorithm suggested
by Truong et al. (2005) for some quadratic residue codes with
irreducible generating polynomials has been designed that uses
the inverse-free Berlekamp–Massey (BM) algorithm to determine
the error-locator polynomial. In this paper, based on the ideas
of the algorithm mentioned above, an algebraic decoder for the
(89; 45; 17) binary quadratic residue code, the last one not de-
coded yet of length less than 100, is proposed. It was also verified
theoretically for all error patterns within the error-correcting
capacity of the code. Moreover, the verification method developed
in this paper can be extended for all cyclic codes without checking
all error patterns by computer simulations.
Index Terms—Error-locator polynomial, inverse-free
Berlekamp–Massey (BM) algorithm, quadratic residues codes,
unknown syndromes.
I. INTRODUCTION
T HE Golay codes were first discovered by Golay [1] in1949. Prange [2] introduced the class of quadratic residue
(QR) codes, a nice family of cyclic codes. These QR codes
have code rates greater than or equal to and generally have
large minimum distances so that most of the known QR codes
are the best-known codes. Among them, the notable
QR code, in fact, is also called the binary Golay code. Its ex-
tended code was utilized to provide error control on
the Voyager mission; see [3]. It is well known that there are
11 binary QR codes with code length less than , namely,
, and . A series of different
algebraic decoding algorithms for these QR codes have been
proposed [4]–[14] but the algebraic decoding scheme for the
QR code is not available in the literature. Such a
QR code, which has the capability to correct up to
eight errors, can be constructed in a small field . Due to
Manuscript received June 4, 2007; revised July 23, 2008. Current version
published October 22, 2008. This work was supported by the National Science
Council, Taiwan, under Grants NSC95-2221-E-214-042 and NSC95-2115-M-
214-006.
T.-K. Truong, P.-Y. Shih, and W.-K. Su are with the Department
of Information Engineering, I-Shou University, Kaohsiung Country
84001, Taiwan (e-mail: truong@isu.edu.tw; d9203005@stmail.isu.edu.tw;
d9403003@stmail.isu.edu.tw).
C.-D. Lee is with the Department of Communication Engineering, I-Shou
University, Dashu Township, Kaohsiung Country 84001, Taiwan (e-mail:
chongdao@isu.edu.tw).
Y. Chang is with the Department of Applied Mathematics, I-Shou
University, Dashu Township, Kaohsiung Country 84001, Taiwan (e-mail:
ytchang@isu.edu.tw).
Communicated by I. Dumer, Associate Editor for Coding Theory.
Color version of Figure 2 in this paper is available online at http://ieeexplore.
ieee.org.
Digital Object Identifier 10.1109/TIT.2008.929956
this small size of the finite field, the computational complexity
can be dramatically reduced, and therefore, this code is consid-
ered to be one of the best in the family of the binary quadratic
residue codes. However, because the number of the error pat-
terns within the error-correcting capacity is large, it is difficult
to check all error patterns exhaustively for the decoding algo-
rithm by a computer-aided method. To overcome this, a theorem
and two corollaries are developed in this paper to theoretically
verify the correctness of a new algebraic decoding algorithm of
the QR code without the need of checking all error
patterns by computer simulations mentioned in the previous al-
gorithm [11].
In the past decades, the methods used most often to decode
binary QR codes are the Sylvester resultant [8], [10] or Gröbner
basis methods [15]. These methods can be used to solve the
Newton identities that are nonlinear and multivariate equations
of high degree. It becomes very difficult when the weight of the
occurred error becomes large. Moreover, different QR codes use
different sets of conditions to determine the error locations. As
a result, it is not practical for software implementation.
Recently, using the inverse-free Berlekamp–Massey (BM)
algorithm [16]–[18], an algebraic decoding algorithm for QR
codes [11] has been applied to determine the error-locator
polynomial. These facts also lead to designing the algebraic
decoders for many other binary QR codes of lengths up to
(see [13] and [14]), except for the QR codes of lengths
, and . In this paper, the previous algebraic decoding
algorithms can be modified to decode the QR code.
Finally, based on the theorem and two corollaries developed
in this paper, the proposed decoding algorithm verified by
software simulation using C++ language can correct all error
patterns up to its error-correcting capacity.
The structure of this paper is as follows. The background
of the binary QR codes is given in Section II. In Section III,
one analyzes the mapping relationship between the error
patterns and the ordered 4-tuples of the known primary syn-
dromes. Section IV shows the determination of the primary
unknown syndromes and of the QR code. In
Section V, the proposed decoding algorithm of the
QR code is developed in detail and simulation results are
given. Finally, this paper concludes with a brief summary in
Section VI.
II. THE TERMINOLOGY AND BACKGROUND OF THE QR CODES
Let be a prime number of the form . A
binary QR code of length is an cyclic code
with the generator polynomial , where
is the collection of all nonzero quadratic residues modulo ,
0018-9448/$25.00 © 2008 IEEE
Authorized licensed use limited to: IEEE Xplore. Downloaded on October 21, 2008 at 21:59 from IEEE Xplore.  Restrictions apply.
TRUONG et al.: ALGEBRAIC DECODING OF THE QUADRATIC RESIDUE CODE 5007
be the set of quadratic residues. The generator polynomial
factors into four binary irreducible polynomials as follows:
(4)
where , , , and are the minimal poly-
nomials of , , , and with coefficients in , re-
spectively; that is,
and for are the roots of ,
where . The QR code generated in
this manner can correct up to eight errors.
Based on the generator polynomial of the QR
code, the mapping relationship between each error pattern with a
weight less than or equal to 8 and its primary known syndromes
, , , and is given in the following evident theorem.
Lemma 1: Let with degree be the minimal poly-
nomial of over . The field
is a vector space over with a basis
. Also, let
and in , where
and are in with ,
. If then
.
Proof: Let and
belong to . If , then
. Because is a
basis, clearly, for , i.e., .
The proof is thus complete.
Theorem 1: Let , , , and be the min-
imal polynomials of , , , and over , where
is a primitive 89th root of unity in , respectively. Next,
let be the generator polynomial
of the QR code. Finally, let and
be the ordered 4-tuples of the primary known
syndromes of error patterns and with weights less
than or equal to 8, respectively. Then, if and only
if .
Proof: Using the division algorithm in the ring
, the error patterns and
can be written uniquely as follows:
(5a)
and
(5b)
where both and have degrees less than 45 and
, , , , , , , and
have degrees less than 11.
If , then
. By Lemma 1, in the field
is obtained, where is irreducible
over . Then, is equal to in .
Because their degrees are less than 89, they are also equal in
the ring . Therefore, one has
(5c)
and
(5d)
By substituting into (5c) and (5d),
, , and , one finds
. Also, and are
smaller than . Using a technique similar to that used
to prove in the field ,
one obtains in the ring .
Similarly, and in the ring
are obtained.
Now, the sum of (5a) and (5b) yields
(5e)
However, , , ,
and . Equation (5e) becomes
(5f)
Therefore, is a codeword. By the assumption,
each of and has a weight less than or equal to 8. If
, then the weight of the codeword is
no more than 16. This contradicts the minimal distance .
Thus, .
Authorized licensed use limited to: IEEE Xplore. Downloaded on October 21, 2008 at 21:59 from IEEE Xplore.  Restrictions apply.
TRUONG et al.: ALGEBRAIC DECODING OF THE QUADRATIC RESIDUE CODE 5009
, and are , , , and ,
respectively. Again, by Corollary 1, is
a nonzero polynomial in for all error patterns.
The unknown syndrome is then determined by
one of the roots of (3).
Case 5: For , two subcases need to be considered as
follows.
a) Let and
. is the poly-
nomial in with four monomials ,
, , and . By Corollary
1, is a nonzero polynomial in for
all error patterns. The value of is obtained by
solving one of the roots of (3).
b) Let and
. There are four
monomials , , , and
, which are contained in . By
Corollary 1, is a nonzero polynomial in
for all error patterns. The unknown syndrome
is thus determined by solving one of the roots
of (3).
Case 6: For the six-error case, the following two subcases
are considered.
a) Let and
. From (3), one obtains
in with four monomials ,
, , and . According to
Corollary 1, is a nonzero polynomial in
. Similarly, must be one of the roots of the
nonzero polynomial. In other words, the unknown
syndrome can be determined by one of the roots
of (3).
b) As usual, let and
. Obviously, one
obtains in with four monomials
, , , and . By
Corollary 1, is a nonzero polynomial in
. Similarly, can be determined by one of the
roots of (3).
Case 7: The seven-error case similar to the six-error case
is given as follows.
a) Let and
. From (2), the matrix
is obtained. Obviously, yields
the polynomial in with four monomials ,
, , and . By Corollary 1,
is a nonzero polynomial in . The
value of is thus determined by one of the roots
of (3).
b) In this subcase, one chooses
and
. The matrix
obtained by (2) is used to yield (3). Obvi-
ously, yields the polynomial in
with four monomials , , ,
and . By Corollary 1, is
a nonzero polynomial in . Similarly, is
determined by one of the roots of (3).
Case 8: For the case of eight errors, and are de-
termined in the following two subcases, respectively.
a) In this case, the pair ’s is used to determine
; that is, and
. From (2), one
obtains the matrix whose determinant is a
polynomial in with four monomials ,
, , and . Therefore,
can be determined by one of the roots of (3).
b) Let and
. By an
argument similar to the seven-error case, the deter-
minant of the matrix yields the polynomial
in with four monomials , ,
, and . Thus, can be deter-
mined by one of the roots of (3).
After determining the primary unknown syndromes and
, one now has enough syndromes to apply the modified in-
verse-free BM algorithm proposed in this paper.
V. MODIFIED ALGORITHM FOR DECODING THE
QR CODE UP TO EIGHT ERRORS
A software simulation shows that among all the seven-error
patterns, some of them cannot be decoded properly by using
the algebraic decoding algorithm developed by the authors [11],
[13], [14]. For example, if the weight seven-error pattern
occurs, the algorithm gener-
ates a wrong error-locator polynomial of degree six for ;
that is, whose root is
of multiplicity . Because such a root is not among the
89th root of unity, i.e., , no error po-
sition can be determined by the Chien search. To apply the al-
gorithm [11] to decode the QR code, this algorithm
should be modified to solve this phenomenon. To do this, one
observes that the condition in step (e) of the algorithm given
in [11] used to terminate the algorithm with is
not enough. Therefore, one more condition is needed to be con-
sidered in the previous algorithm. This additional condition is
used to check whether the number of roots of , which are
primitive 89th roots of unity, equals . As a consequence, for
, to determine the number of errors occurred, one not only
checks the degree of obtained from the BM algorithm, but
also checks whether has exactly distinct primitive 89th
roots of unity. Moreover, if the number of all correctable error
patterns is large, it is laborious to guarantee that the primary
unknown syndromes or can be determined by the com-
puter simulations through all correctable error patterns. Also, it
is very difficult to check whether the decoder works correctly for
all the correctable error patterns by using computer simulations.
In Section IV, by Corollary 1, one shows that there always exists
a nonzero polynomial in either or , because
each of them has at least one monomial with a nonzero coef-
ficient. Therefore, by guaranteeing that in either
or is a nonzero polynomial for each error pattern, one
determines the primary unknown syndromes or as one
Authorized licensed use limited to: IEEE Xplore. Downloaded on October 21, 2008 at 21:59 from IEEE Xplore.  Restrictions apply.
TRUONG et al.: ALGEBRAIC DECODING OF THE QUADRATIC RESIDUE CODE 5011
Fig. 2. Bit error probability P versus E =N for the (113; 57; 15); (89; 45;17); (47;24;11), and (23;12;7) QR codes with the hard-decision decoder.
error probability of 5 , the , and
QR codes are 1.15, 0.40, and 0.71 dB away from
the QR code, respectively.
VI. CONCLUSION
Binary QR codes are well known for their good behavior.
However, it is very difficult to especially decode the
QR code, which is one of the best codes known with the code
length and the dimension ; see [18, Fig. 5.2]. By Corollary
1, in either or is a nonzero polynomial for
each error pattern. Also, by Corollary 2, the error pattern
obtained by the decoding procedure is indeed correct if the or-
dered 4-tuple of the received word equals
the ordered 4-tuple of . As a result, the
long-awaited algebraic decoding algorithm of the
QR code proposed in this paper is theoretically verified. Thus,
all of the binary QR codes of length less than or equal to
have been successfully decoded.
ACKNOWLEDGMENT
The authors would like to thank the Associate Editor, Dr. I.
Dumer, and the reviewers for their constructive comments and
suggestions that improved the quality as well as the presentation
of this paper.
REFERENCES
[1] M. J. E. Golay, “Notes on digital coding,” Proc. IRE, vol. 37, no. 1, pp.
67–67, Jan. 1949.
[2] E. Prange, “Some cyclic error-correcting codes with simple decoding
algorithms,” Air Force Cambridge Research Center, Cambridge, MA,
TN-58-156, Apr. 1958.
[3] S. B. Wicker, Error Control Systems for Digital Communication and
Storage. Englewood Cliffs, NJ: Prentice-Hall, 1995.
[4] R. He, I. S. Reed, T. K. Truong, and X. Chen, “Decoding of the (47,
24, 11) quadratic residue code,” IEEE Trans. Inf. Theory, vol. 47, no.
2, pp. 1181–1186, Mar. 2001.
[5] R. W. Hamming, “Error detecting and error correcting codes,” Bell
Syst. Tech. J., vol. 29, pp. 147–160, 1950.
[6] I. S. Reed, X. Yin, T. K. Truong, and J. K. Holmes, “Decoding the (24,
12, 8) Golay code,” Proc. Inst. Electr. Eng., vol. 137, pp. 202–206, May
1990.
[7] M. Elia, “Algebraic decoding of the (23, 12, 7) Golay code,” IEEE
Trans. Inf. Theory, vol. IT-33, no. 1, pp. 150–151, Jan. 1987.
[8] I. S. Reed, X. Yin, and T. K. Truong, “Algebraic decoding of the (32,
16, 8) quadratic residue code,” IEEE Trans. Inf. Theory, vol. 36, no. 4,
pp. 876–880, Jul. 1990.
[9] I. S. Reed and X. Chen, Error-Control Coding for Data Networks.
Boston, MA: Kluwer, 1999.
[10] I. S. Reed, T. K. Truong, X. Chen, and X. Yin, “The algebraic decoding
of the (41, 21, 9) quadratic residue code,” IEEE Trans. Inf. Theory, vol.
38, no. 3, pp. 974–985, May 1992.
[11] Y. H. Chen, T. K. Truong, Y. Chang, C. D. Lee, and S. H. Chen,
“Algebraic decoding of quadratic residue codes using inverse-free
Berlekamp-Massey algorithm,” J. Inf. Sci. Eng., vol. 23, pp. 127–145,
Jan. 2007.
[12] X. Chen, I. S. Reed, and T. K. Truong, “Decoding the (73, 37, 13)
quadratic residue code,” Proc. Inst. Electr. Eng., vol. 141, pp. 253–258,
Sep. 1994.
[13] Y. Chang, T. K. Truong, I. S. Reed, H. Y. Cheng, and C. D. Lee, “Alge-
braic decoding of (71, 36, 11), (79, 36, 11), and (97, 49, 15) quadratic
residue codes,” IEEE Trans. Commun., vol. 51, no. 9, pp. 1463–1473,
Sep. 2003.
[14] T. K. Truong, Y. Chang, Y.-H. Chen, and C. D. Lee, “Algebraic de-
coding of (103, 52, 19) and (113, 57, 15) quadratic residue codes,”
IEEE Trans. Commun., vol. 53, no. 5, pp. 749–754, May 2005.
[15] X. Chen, I. S. Reed, T. Helleseth, and T. K. Truong, “Use of Gröbner
bases to decode binary cyclic codes up to the true minimum distance,”
IEEE Trans. Commun., vol. 40, no. 9, pp. 1654–1661, Sep. 1994.
[16] I. S. Reed, M. T. Shih, and T. K. Truong, “VLSI design of inverse-free
Berlekamp-Massey algorithm,” Proc. Inst. Electr. Eng., vol. 138, pp.
295–298, Sep. 1991.
[17] X. Youzhi, “Implementation of Berlekamp-Massey algorithm without
inversion,” Proc. Inst. Electr. Eng., vol. 138, pp. 138–140, 1991.
[18] R. E. Blahut, Theory and Practice of Error Control Code. Reading,
MA: Addison-Wesley, 1983.
[19] S. B. Wicker and V. K. Bhargava, Reed-Solomon Codes and Their Ap-
plications. New York: IEEE Press, 1994.
[20] S. V. Fedorenko and P. V. Trifonov, “Finding roots of polynomials over
finite fields,” IEEE Trans. Commun., vol. 50, no. 11, pp. 1709–1711,
Nov. 2002.
Authorized licensed use limited to: IEEE Xplore. Downloaded on October 21, 2008 at 21:59 from IEEE Xplore.  Restrictions apply.
PEI-YU SHIH, WEN-KU SU, TRIEU-KIEN TRUONG AND YAOTSU CHANG 
 
1284 
 
five errors. More recently, the authors [15, 16] used the technique mentioned above to 
obtain enough consecutive syndromes in binary QR codes of lengths 71, 79, 97, 103, and 
113. Then the error-locator polynomial is found by using the inverse-free Berlekamp- 
Massey (BM) algorithm. Until now, the QR codes of lengths less than or equal to 113 
have been decoded except for the case of length 89.  
In this paper, a new decoding scheme to decode binary QR codes is proposed. It is 
based on the Euclidean algorithm which is an efficient method to find the error-locator 
polynomial in Reed-Solomon (RS) and Bose-Chaudhuri-Hocquenghem (BCH) decoders. 
Even though the code rates of QR codes are approximately 1/2 and many QR codes are 
better than BCH codes with the code length n and dimension k, see Fig. 5.2 of [17], the 
proposed decoders for QR codes cost more computational complexity than the decoders 
for BCH codes by using the Euclidean algorithm. Therefore, an efficient decoding algo-
rithm needs to be developed for QR codes.  
The proposed decoding scheme has been verified by software simulation using pro-
grams written in C++ language. An exhaustive computer simulation running every error 
patterns within error-correcting capacity was executed successfully for the (23, 12, 7), 
(41, 21, 9), (47, 24, 11), and (71, 36, 11) QR codes. However, the computer search for 
the error patterns of the (79, 40, 15), (97, 49, 15), and (103, 52, 19) QR codes are not 
exhaustive. In other words, approximate one hundred million error patterns had been 
checked successfully and, as a consequence, demonstrated from a computer simulation 
that the algorithm for decoding these QR codes works well. 
This paper is organized as follows: A brief review of the binary QR codes and syn-
drome polynomial is introduced in sections 2 and 3, respectively. A new decoding algo-
rithm for binary QR codes is proposed in section 4. An example to decode (41, 21, 9) 
QR code is illustrated in detail. A few short remarks and conclusions of the new decod-
ing algorithm are given in section 5. The simulation results of the proposed algorithm 
and the BM algorithm are given in the last section of the paper. 
2. TERMINOLOGY AND BACKGROUND OF QUADRATIC  
        RESIDUE CODES 
Let n be a prime number of the form  1 ( mod 8).n ≡ ±  A binary QR code of length 
n is an (n, (n + 1)/2) cyclic code with the generator polynomial 
( ) ( )
n
i
i Qg x x β∈= −∏                                        (1) 
where Qn is the collection of all nonzero quadratic residues modulo n; that is, 
2{ |   mod  for 1 1}nQ i i j n j n= ≡ ≤ ≤ −                                 (2) 
and β is a primitive nth root of unity in the finite field GF(2m), where m is the smallest 
positive integer such that  n | 2m − 1. 
Let the code polynomial c(x) = c0  +  c1x + … + cn-1xn-1 be transmitted through a noisy 
channel. Then the received polynomial r(x) = r0 + r1x + … + rn-1xn-1 has the form 
PEI-YU SHIH, WEN-KU SU, TRIEU-KIEN TRUONG AND YAOTSU CHANG 
 
1286 
 
can be found by an explicit use of the fast algorithm developed in [15]. Next, consider 
the matrix S(I, J) of size (v + 1) × (v + 1) as follows: 
S(I, J) =
1 1 1 2 1 1
2 1 2 2 2 1
1 1 1 2 1 1
,
v
v
v v v v
i j i j i j
i j i j i j
i j i j i j
S S S
S S S
S S S
+
+
+ + + +
+ + +
+ + +
+ + +
⎡ ⎤⎢ ⎥⎢ ⎥⎢ ⎥⎢ ⎥⎢ ⎥⎣ ⎦
"
"
# # % #
"
                             (9) 
where the summation of the indices of Si’s is modulo n and the rank of S(I, J) is at most v 
which, in turn, implies 
det(S(I, J)) = 0.                                                    (10) 
If there is only one unknown syndrome, say Sr, among the entries of S(I, J), then Sr 
can be expressed as a function in terms of some known syndromes. Hence, during the 
decoding process, one is able to calculate the value of Sr with the information about 
those known syndromes. The complete procedures to determine the primary unknown 
syndromes for some QR codes are shown in [14-16]. In what follows, the polynomials 
S(x) and xn − 1 will be used in the proposed decoding scheme. 
3. SYNDROME POLYNOMIAL  
If the element β is a primitive root of xn − 1, then xn − 1 can be split into n linear fac-
tors, (1 − β ix), where 0 ≤ i ≤ n − 1. It is straightforward to see that the all-one polynomial  
(AOP) xn-1 + xn-2 + … + 1 is equal to 11 (1 )
n i
i xβ−= −∏ , i.e., β -1 = β n-1, β -2 = β n-2, …, β -(n-1)  
= β 1 are all the roots of the AOP. This fact leads to prove the following theorem. 
 
Theorem 1  Let c(x) and e(x) be a codeword of a binary QR code of length n and a cor-
rectable error pattern of weight v, respectively. Also, let S(x) given in Eq. (8) be the syn-
drome polynomial for the received codeword r(x) = e(x) + c(x). If the weight of e(x) is 
odd (resp., even), then S(x) (resp., 1 + S(x)) has v linear factors; that is, (1 − β ix), where 
β -i belongs to 1 2 1B { , , , }nβ β β −= …    ( 1) ( 2) 1{ , , , }n nβ β β− − − − −= " . 
 
Proof: Assume that the number of errors is odd, i.e., v = 2u + 1. By the definition of syn-
dromes mentioned in section 2, we have 2 11 2( ) ( ) +  + ( ) ,ull li i iiS β β β += + …  where 0 ≤ i ≤ n − 1. Then the evaluation of S(x) at β −i yields the following: 
2 1 2 11 2 1 2
2 11 2
22 2 2
( 1)( 1) ( 1) ( 1)
( ) ( )( ) ( )( )
           + ( )( )
u u
u
l ll l l li i i
n ln l n l n i
S β β β β β β β β β
β β β β
+ +
+
− − −
−− − − −
= + + + + + + + +
+ + +
… … …
…
     (11) 
1 1 1 2 2 2
2 1 2 1 2 1
2( ) ( 1)( ) 2( ) ( 1)( )
2( ) ( 1)( )
          = ( ) ( )
          + ( ).u u u
l i l i n l i l i l i n l i
l i l i n l i
β β β β β β
β β β+ + +
− − − − − − − −
− − − −
+ + + + + + + +
+ + +
… … …
…
  
PEI-YU SHIH, WEN-KU SU, TRIEU-KIEN TRUONG AND YAOTSU CHANG 
 
1288 
 
Example: Let α be a root of the primitive polynomial x20 + x3 + 1 and let β = α(220 -1)/41 = 
α25575 be a primitive 41st root of unity in GF(220). The set of quadratic residue modulo 41 
defined in Eq. (2) is Q41 = {1, 2, 4, 5, 8, 9, 10, 16, 18, 20, 21, 23, 25, 31, 32, 33, 36, 37, 
39, 40}. According to Eq. (1), the generator polynomial of the binary (41, 21, 9) QR 
code can be written as 
41
 
3 4 6 9 10 11 14 16 17 19 20
( ) ( )
      1 .
i
i Qg x x β
x x x x x x x x x x x x
∈= −
= + + + + + + + + + + + +
∏  
Assume the information polynomial is I(x) = 1 + x5 + x9 + x10 + x14 + x15 + x16 + x19 + 
x20. Then the code polynomial c(x), which is a multiple of g(x), is 
2 3 7 8 9 15 16 19 22 24 26 28
29 30 31 33 34 35 36 37 38 40
( ) = 1 + + + + + + + + + + + 
          + + + + + + + + + + .
c x x x x x x x x x x x x x
x x x x x x x x x x
+  
If the error polynomial e(x) is assumed to be x1 + x7 + x23 + x36, then the received poly-
nomial is the sum of the code polynomial c(x) and the error polynomial e(x). That is,  
2 3 8 9 15 16 19 22 23 24
26 28 29 30 31 33 34 35 37 38 40
( ) ( ) ( ) = 1 +  + + + + + + + + + + 
          + + + + + + + + + + + .
r x c x e x x x x x x x x x x x x
x x x x x x x x x x x
= +  
The decoding process developed in this paper is described as follows:  
First of all, the known syndrome Sk for each k in Q41 can be calculated from the re-
ceived polynomial r(x). That is,  
40
410 ( ) , .
k i
k iiS r β k Q== ∈∏  
For the binary (41, 21, 9) QR code, every known syndromes (resp., unknown syn-
dromes) can be expressed as some power of S1 (resp., S3). In other word, S3 is the pri-
mary unknown syndrome of the (41, 21, 9) QR code. Therefore, the same procedure 
given in [15] can be used in this paper to define the value of the primary unknown syn-
drome for each hypothetic number of errors occurred. After the values of the primary 
syndromes S1 and S3 are determined, Table 1 shows the relations among syndromes for 
the (41, 21, 9) QR code.  
By evaluating r(x) at the roots of g(x) mentioned above, the primary known syndrome 
is S1 = α 822540 ≠ 0, which means that there are errors occurred in the received polynomial 
r(x). 
If the number of errors is one, i.e., v = 1, the primary unknown syndrome is S3 = 
3
1S = α 370470. After the determination of the primary syndromes S1 and S3, all syndromes 
can also be determined. Therefore, the syndrome polynomial S(x) is further obtained. 
The output of the Euclidean algorithm is 
PEI-YU SHIH, WEN-KU SU, TRIEU-KIEN TRUONG AND YAOTSU CHANG 
 
1290 
 
Table 1. Values of subindices “ti” for identifies 2= .i
it jS S   
i 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 
j = 1 2 4 8 16 32 23 5 10 20 40 39 37 33 25 9 18 36 31 21 
j = 3 6 12 24 7 14 28 15 30 19 38 35 29 17 34 27 13 26 11 22 
0 822540 1006152 2 780117 3 60716 4 415151 5 431775 6α α x α x α x α x α x α x+ + + + + +  
    643571 7 156564 8α x α x+ +  513338 9 960279 10 274912 11 184888 12α x α x α x α x+ + + +  
    504021 13 15137 14 631236 15 766422 16α x α x α x α x+ + + +  380625 17 134849 18α x α x+ +  
     359 19 567333 20 292098 21 1016910 22 741675 23.α x α x α x α x α x+ + + + +  
Thus, the assumption is not valid and let v = v + 1 = 2.  
If v = 2, the primary unknown syndrome S3 can be determined by the technique de-
veloped in [15]. A computer search is used to find the following matrix of size 3 × 3: 
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢
⎣
⎡
1032
921
810
SSS
SSS
SSS
. 
There is only one unknown syndrome S3 among the entries of this matrix. By [14], 
the determinant of the above matrix is zero. The unknown syndrome S3 for the two-error 
case is  
2 2
2806751 2 9 2 8 1 10
3
1 8
,
S S S S S S S
S α
S S
+ += =  
where S0 = 0 and S1 = α 822584. Since v = 2 is even, the polynomial 1 + S(x) is used in 
Euclid’s algorithm. Simulation result shows that the output of the Euclidean algorithm is 
0 822540 429347 2 175384 3 91243 4 377861 5 214207 6α α x α x α x α x α x α x+ + + + + +  
361581 7 697654 8 858679 9 876804 10 103229 11 803475 12 α x α x α x α x α x α x+ + + + + +  
976871 13 394971 14 709321 15 445996 16 239844 17 323668 18 α x α x α x α x α x α x+ + + + + +  
133364 19 237532 20 414766 21 426278 22 403110 23 127875 24 .α x α x α x α x α x α x+ + + + + +  
Thus, the assumption is also not valid.  
If v = 3, the primary unknown syndrome S3 can be determined by the following 
equation: 
 
0 1 2 5
31 32 33 36
39 40 0 3
40 0 1 4
0,
S S S S
S S S S
S S S S
S S S S
=                                               (12) 
PEI-YU SHIH, WEN-KU SU, TRIEU-KIEN TRUONG AND YAOTSU CHANG 
 
1292 
 
codes. Because the most time-consuming usage in our decoding algorithm is the compu-
tation of g.c.d. (xn − 1, P(x)) using the Euclidean algorithm, especially, when the number 
of actual errors is not equal to the number of hypothetical errors occurred. In order to 
compare the decoding algorithm developed in [10, 15] for the (71, 36, 11) and (79, 40, 
15) QR codes, these two algorithms have been verified and implemented on the com-
puter using C++ language. The computational times shown in Table 2 were averaged 
over 100 computations. Furthermore, one observes from Table 2 that the speed of the 
proposed algorithm is slower than and almost equal to that of the BM algorithm given in 
[15, 16] for the (71, 36, 11) QR code and (79, 40, 15) QR code, respectively. Therefore, 
one needs to modify this new algorithm for which it offers a significant advantage in 
terms of computational complexity. 
 
Table 2. Computation time in seconds to decode QR codes. 
 
ACKNOWLEDGMENT 
The authors would like to express their deepest appreciation to the Editor and the 
referees for their valuable and useful comments that led to this paper. 
REFERENCES 
1. Telemetry Channel Coding, Recommendation for Space Data System Standard, CC- 
SDS 101.0-B-3, Blue Book, 1992. 
2. S. B. Wicker and V. K. Bhargava, Reed-Solomon Codes and Their Applications, IEEE 
Press, New Jersey, 1994. 
3. C. Basile et al., “The U.S. HDTV standard the grand alliance,” IEEE Spectrum, Vol. 
32, 1995, pp. 36-45. 
4. DVD Specifications for Rewritable Disc (DVD-RAM) Part 1, Physical Specifications, 
Version 2.0, 1999. 
5. E. Prange, “Some cyclic error-correcting codes with simple decoding algorithms,” 
Air Force Cambridge Research Center-TN-58-156, Cambridge, MA, 1958. 
6. R. W. Hamming, “Error detecting and error correcting codes,” Bell System Techni-
cal Journal, Vol. 29, 1950, pp. 147-160. 
7. M. J. E. Golay, “Notes on digital coding,” in Proceedings of the Institute of Electri-
cal and Electronic Engineers, Vol. 37, 1949, pp. 657. 
8. I. S. Reed, X. Yin, T. K. Truong, and J. K. Holmes, “Decoding the (24, 12, 8) Golay 
code,” IEE Proceedings – Communications, Vol. 137, 1990, pp. 202-206. 
9. M. Elia, “Algebraic decoding of the (23, 12, 7) Golay code,” IEEE Transactions on 
Information Theory, Vol. 33, 1987, pp. 150-151. 
10. I. S. Reed, X. Yin, and T. K. Truong, “Algebraic decoding of the (32, 16, 8) quad-
ratic residue code,” IEEE Transactions on Information Theory, Vol. 36, 1990, pp. 876- 
(n, k, d) QR code Errors New algorithm BM algorithm 
(71, 36, 11) QR code 5 0.047 0.008 
(79, 40, 15) QR code 7 0.483 0.5 
PEI-YU SHIH, WEN-KU SU, TRIEU-KIEN TRUONG AND YAOTSU CHANG 
 
1294 
 
Editor in the Asia area for the Journal of Visual Communication and Image Representa-
tion and as an Editor in the area of Coding Theory and Techniques for the IEEE Trans-
actions on Communications. Dr. Truong is a Fellow of the IEEE. 
 
 
Yaotsu Chang (張耀祖) received the B.S. degree in Mathematics from Soochow 
University, Taipei, Taiwan, R.O.C., and the M.S. degree in Mathematics from National 
Tsing Hua University, Hsinchu, Taiwan, R.O.C., and the Ph.D. degree in Mathematics 
from the University of Michigan, Ann Arbor, in 1994. He is a Professor in the Depart-
ment of Applied Mathematics, I-Shou University, Kaohsiung, Taiwan, R.O.C. His re-
search interests include error-correcting code, finite field, and algebraic combinatorics.  
 
 
 
 
2 IEEE TRANSACTIONS ON COMMUNICATIONS, VOL. 57, NO. 6, JUNE 2009
there be v error symbols and s erasure symbols occurred
in the received vector r of n symbols such that 2v + s ≤
d − 1. Define the erasure-locator polynomial and error-
locator polynomial as Λ (x) =
∏s
j=1 (x− Zj) where Zj is
the locator of the erasure position in the erasure vector μ,
and W (x) =
∏v
j=1 (x−Xj) where Xj is the locator of
the error position in the error vector e, respectively. Thus,
the errata-locator polynomial is defined as τ (x) = Λ (x).
W (x) =
∏v+s
j=1
(
x− Z˜j
)
where Z˜j is either the jth erasure
or error location. Finally, define the error-evaluator polynomial
as B (x) =
v∑
j=1
(
Yj ·
v∏
i=1,i=j
(x−Xi)
)
, where Yj is the jth
error magnitude. Following Gao’s algorithm, the procedure to
correct errors only of RS codes is restated explicitly in the
following three steps:
Algorithm 1
1) Using the fast Fourier transform (FFT) over GF (2m)
given in [18], compute an interpolating polynomial from
T (α′) = ri for 0 ≤ i ≤ n− 1 (1)
where deg {T (x)} ≤ n− 1.
2) From the known T (x) and g (x) = xn − 1, one of the
extended Euclidean algorithms is used to solve Eq. (7) in [6],
i.e.,
− (xn − 1) · B (x) + W (x) · T (x) = P (x) , (2a)
where P (x) = W (x) · M (x), deg {W (x)} ≤ (d− 1) /2,
and deg {B (x)} ≤ (d− 1) /2 − 1.
From (2a), the congruence relation is obtained as
W (x) · T (x) ≡ P (x) mod xn − 1. (2b)
It was shown in [6], [11] that when the maximum
deg {P (x)} < k + t ≤ k + (n− k) /2 = (n + k) /2, an
unique pair of polynomials P (x) and W (x) is thus obtained.
3) The message polynomial can be reconstructed by
M (x) =
P (x)
W (x)
. (3)
In step 1, let T (x) =
∑n−1
i=0 αix
i, where αi ∈ GF (2m). It
follows from [8] that the coefficients of T (x) can be calculated
by the inverse transform over GF (2m) namely,
αj = n−1 ·
(
n−1∑
i=0
rjα
−ij
)
for 0 ≤ j ≤ n− 1. (4)
Here we restrict n to be an odd number; that is, n ≡ 1 mod
2. The symbol αj in (4) for 0 ≤ j ≤ n− 1 can be computed
by using any of fast algorithms for the Fourier transform over
finite fields [18]–[20]. The second step of Algorithm 1 can
also be implemented by the use of the fast algorithm, such
as Moenck’s algorithm [21] and the extended Euclidean algo-
rithm [22]. It follows from [22] that the extended Euclidean
algorithm similar to the Berlekamp-Massey (BM) algorithm
can be usually used to reduce hardware complexity.
In the presence of errors as well as erasures, Shiozaki
and Gao [6], [11] suggested a decoding scheme to correct
both errors and erasures, called the Shiozaki-Gao algorithm. It
ignores the erasure locations and uses the Euclidean algorithm
so as to decode the shortened RS codes with length n−s. How-
ever, the shortened codeword loses the fast Fourier transform
structure, and as a sequence a fast transform over GF (2m)
given in [18] cannot be used to decode RS codes. This
result requires a substantial increment of the computational
complexity in the interpolating polynomial stage. The main
drawback of this decoding algorithm to correct errors and
erasures is illustrated by the following example:
Example 1: Consider the (7, 4) RS code over GF
(
23
)
with
a minimum distance d = 4. In this code, s erasures and
v errors under the condition 2v + s ≤ 3 can be corrected.
Assume the message vector is m =
(
α, α2, α5, α4
)
, where
α is a root of a 3rd degree primitive irreducible polynomial
p (x) = x3 + x + 1 over GF (2); that is, the message
polynomial is M (x) = α + α2x + α5x2 + α4x3, where
deg {M (x)} ≤ k − 1 = 3. The codeword vector is found
at the top of the next page. Furthermore, assume the erasure
vector is μ =
(
0, 0, 0, 0, 0, α3, 0
)
and the error vector is
e = (0, α, 0, 0, 0, 0, 0). Thus, the errata vector is μ˜ =
μ + e =
(
0, α, 0, 0, 0, α3, 0
)
and the received vector is r = c+
μ˜ = (r0, r1, r2, r3, r4, r5, r6) =
(
α5, α3, α3, α4, α4, α6, 1
)
.
Let S =
{
αi|0 ≤ i ≤ n− 1} be the set of erasure positions.
In this case, S =
{
α5
}
. Thus, the erasure-locator polynomial
is Λ (x) = x + α5. Hence, g (x) needed in Algorithm 1 is
replaced by
g (x) =
7−1∏
i=0,i=5
(
x− αi) = x7 − 1
Λ (x)
= x6 + α5x5 + α3x4 + αx3 + α6x2 + α4x + α2.(5)
1) By using Lagrange’s interpolation formula, construct an
interpolating polynomial T (x) with deg {T (x)} ≤ n−s−1 =
5 such that T (α′) = ri for 0 ≤ i ≤ 6 where α′ /∈ S. That is,
T (x) =
6∑
i=0,i=5
6∏
j=0,j =i,j =5
(
x− αj)
6∏
j=0,j =i,j =5
(αi − αj)
· ri
= αx5 + x4 + αx3 + α4. (6)
2) The Euclidean algorithm [16] is applied next to the
polynomial g (x) in (5) and T (x) in (6). An unique pair
of polynomials P (x) and W (x) is thus obtained. This is
accomplished by the recursive formula illustrated in Table I.
From the table described above, one observes that
deg {P (x)} = deg {P1 (x)} = 4 < (n− s + k/2) =
(7− 1 + 4) /2 = 5. Thus, the computation terminates at this
point for l = 1. Hence, one obtains W (x) = α6x + 1 and
P (x) = α3x4 + α6x2 + α6x + α.
3) The message polynomial is found via Eq. (3). That is,
M (x) =
P (x)
W (x)
=
α3x4 + α6x2 + α6x + α
α6x + 1
= α4x3 + α5x2 + α3x + α.
Again, from step 1 of the above example, one observes
that the FFT over GF (2m) can not be applied to calculate
the interpolating polynomial given in (6). Based on Gao’s
algorithm, an improved decoding scheme which makes use
4 IEEE TRANSACTIONS ON COMMUNICATIONS, VOL. 57, NO. 6, JUNE 2009
deg {W (x)} ≤ (d− 1− s/2) (8)
deg {P ′ (x)} ≤ (k − 1) + (d− 1− s/2)+ s = (k − 1) + 2 · (d− 1− s/2) − (d− 1− s/2)+ s
≤ (k − 1) + (d− 1− s) + s− (d− 1− s/2) = n− (d− 1− s/2) − 1 (9)
deg {B′ (x)} ≤ (d− 1− s/2) − 1 + s ≤ (d− 1− s) /2− 1 + s = (d− 3− s) /2 (10)
TABLE II
AN EXAMPLE OF THE EUCLIDEAN ALGORITHM USING TO FIND P ′(x) AND τ(x)
l )(1 xQl− )()()()( 112 xPxQxPxP llll −−− ′⋅+′=′ )()()()( 112 xxQxx llll −−− ⋅+= τττ
-1 - =′− )(1 xP 17 −x =− )(1 xτ 0
0 -
=′ )(0 xP )()()( xxTxT Λ⋅=′
52674 xxx ααα ++=
αααα ++++ xxx 43646
5
0 )()( ατ +=Λ= xxx
1 )(
)()(
0
1
0 xP
xPxQ
′
′
= − 3α= =′ )(1 xP
425564 xxx ααα ++
532 αα +++ xx
αατ += xx 31 )(
2 )(
)()(
1
0
1 xP
xPxQ
′
′
= 2α+= x =′ )(2 xP
233455 xxxx +++ αα
36 αα ++ x
2223
2 )( ααατ ++= xxx
The recursions in (15) and (16) terminate when the maxi-
mum deg {P ′l (x)} < n − (d− 1− s/2) for the first time
for some value l = l′. The polynomials P ′l′ (x) = P
′ (x) and
τl′ (x) = τ (x) are thus obtained. Obviously, one can obtain
τ (x) = W (x) with the initial conditions τ0 (x) = 1 and
τ−1 (x) = 0 in the Euclidean algorithm. In order to obtain
τ (x) = W (x) · Λ (x), it is shown in [16] that, in general,
one needs to change the initial conditions: τ0 (x) = Λ (x) and
τ−1 (x) = 0.
3) The message polynomial is obtained by
Mx =
MxW (x) Λ (x)
W (x) Λ (x)
=
P ′ (x)
τ (x)
. (17)
Note that given the inequalities in (8) and (9), we have also
proved step 2 by using a technique similar to that used for the
proof of Theorem 2 in [16].
To illustrate the decoding procedure for correcting errors
and erasures, an elementary example of an RS code over
GF
(
23
)
is now presented.
Example 2: Consider the same RS code over GF
(
23
)
with
a minimum distance d = 4 as in Example 1. In this code, the
message vector, the codeword vector, the erasure vector, the
error vector, the errata vector, and the received vector are the
same as given in Example 1.
1) Using the fast algorithm given in [18], compute an
interpolating polynomial T (x) from T (α′) = ri for 0 ≤
i ≤ 6, where deg {T ′ (x)} ≤ n − 1 = 6, namely, T (x) =
α4x6 + α4x5 + α6x3 + α3x2 + αx + α3.
2) The Euclidean algorithm [16] applied next to polynomial
x7 − 1 and T ′ (x) = T (x) · Λ (x), where Λ (x) = x + α5, is
used to solve Eq. (14) for the polynomials P ′ (x) and τ (x).
This is accomplished by the recursive formulas illustrated in
Table II.
The second line of Table II shows that the smallest index
l for which deg {P ′ (x)} = deg {P ′2 (x)} = 5 < n −
(d− 1− s/2) = 7 − (4− 1− 1) /2 = 6 is l = 2. Thus,
the computation terminates at this point for l = 2. Hence,
τ (x) = α3x2 +α2x+ α2 and P ′ (x) = x5 +α5x4 +α3x3 +
x2 + α6x + α3 are obtained.
It is readily seen that due to deg {T ′ (x)} = n − 1 + s >
deg {T (x)} = n − 1 or deg {T ′ (x)} − deg {T (x)} = s,
eventually, the algorithm proposed requires more steps than
Gao’s algorithm needed in the extended Euclidean algorithm
stage. In other words, the extra steps depend on the number
of erasures occurred in the received vector. However, software
simulations show that the speed of the new algorithm is only
slightly slower than that of Gao’s algorithm while executing
the Euclidean algorithm. Also, simulations show clearly that it
results in advantage of interpolating polynomial computation
using the FFT over GF (2m).
3) According to (17), the message polynomial is then re-
captured as M (x) = P ′ (x) /τ (x) = α4x3+α5x2+α2x+α.
IV. SIMULATION RESULTS
To compare the new algorithm with the Shiozaki-Gao
algorithm for decoding errors and erasures of RS codes, these
two algorithms written in C++ language has been verified and
implemented on Pentium IV 1.6G processor on windows XP
operating system. The computational times shown in Table
2240 IEEE TRANSACTIONS ON COMMUNICATIONS, VOL. 55, NO. 12, DECEMBER 2007
A Fast Algorithm for the Syndrome Calculation in Algebraic Decoding of
Reed–Solomon Codes
Tsung-Ching Lin, T. K. Truong, and P. D. Chen
Abstract—In this letter, Fedorenko and Trifonov’s procedure is
applied to evaluate the syndrome of the received word in time-
domain Reed–Solomon decoders. This application leads to a sub-
stantial reduction of the computational complexity of the syndrome
polynomial for correcting both errors and erasures. Moreover, sim-
ulation results for this new syndrome method are given.
Index Terms—Affine polynomial, Berlekamp–Massey (BM) al-
gorithm, Chien search, errata-locator polynomial, p-polynomial,
Reed–Solomon (RS) codes, syndrome.
I. INTRODUCTION
R EED–SOLOMON (RS) codes for correcting both errorsand erasures are used extensively in space communica-
tion links, compact disk (CD) audio systems, high-definition
television (HDTV), digital versatile disks (DVD), and the IEEE
802.16 standard [1], [2]. In the time-domain RS decoders over
GF (2m ), Horner’s rule [2] is widely used to compute the syn-
dromes Sj = r(αj ), for 1 ≤ j ≤ d− 1, where r(x) is the re-
ceived polynomial of degree n− 1 and d is the minimal distance
of an (n, k) RS code. This implies that it requires the substi-
tution of only d− 1 successive elements of GF (2m ) into the
polynomial r(x). More recently, Costa et al. [3] applied the
cyclotomic fast Fourier transform in the normal basis repre-
sentation to compute syndrome components needed in the RS
decoders due to Zakharova [4]. This novel algorithm was shown
to be superior in performance to Horner’s rule and Zakharova’s
method.
In 1967, Berlekamp [5] first used affine polynomials to de-
velop a very efficient algorithm for finding the roots of an affine
polynomial in GF (2m ) that can be used to find the roots of
the error-locator polynomial with a low degree. Then, Truong
et al. [6] showed that the Berlekamp–Rumsey–Solomon (BRS)
algorithm [7], together with the Chien search, was developed in
order to find the roots of error-locator polynomials up to degree
n = 11 for RS decoders. A computer simulation has shown that
this new fast algorithm was quicker than the Chien search. Re-
cently, Fedorenko and Trifonov [8] generalized Truong et al.’s
procedure to error-locator polynomials of arbitrary degree. This
new algorithm was shown to be approximately 2.6 times faster
than the Chien search. In their algorithm, the error-locator poly-
nomial can first be decomposed into a sum of multiples of affine
Paper approved by K. Narayanan, the Editor for Coding and Communication
Theory of the IEEE Communications Society. Manuscript received September
21, 2006; revised February 28, 2007 and April 2, 2007. This work was supported
by the National Science Council, R.O.C., under Grant NSC 95-2221-E-241-042.
The authors are with the Department of Information Engineering, I-Shou
University, Ta-Hsu Hsiang, 84008 Taiwan, R.O.C. (e-mail: tclin@isu.edu.tw;
truong@isu.edu.tw; cpd14642@ms2.hinet.net).
Digital Object Identifier 10.1109/TCOMM.2007.910595
polynomials A(x). If all m-bit symbols xj ∈ GF (2m ) are or-
dered such that they satisfy wt(xj − xj−1) = 1 as a Gray code,
where wt(a) is the Hamming weight of a, then the evaluation of
an affine polynomial at each xj , i.e., A(xj ) can be obtained as
the sum of the affine polynomial evaluated at xj−1 , i.e., A(xj−1)
and the p-polynomial evaluated at αk , i.e., L(αk ), where k in-
dices are the location of only a nonzero bit of xj − xj−1 . That
is
A(xj ) = A(xj−1) + L(αk ), for 0 ≤ k < m (1)
where A(x0) = A(0) = β and β ∈ GF (2m ).
Obviously, the computation of A(xj ) given in (1), where
xj ∈ GF (2m ), requires only one addition. In this letter, it is
shown that Fedorenko and Trifonov’s procedure can also be
applied to compute the syndromes in the RS decoders. It uses
new ordering of field elements αj for 1 ≤ j ≤ d− 1 to compute
A(αj ). The advantage of this new algorithm is that the com-
putation of A(αj ) also required only one addition. With this
improved technique for syndrome calculation, together with
Fedorenko and Trifonov’s procedure for root evaluation, the
complexity of the time-domain RS decoders [9] for correcting
errors as well as erasures can be dramatically reduced. Such a
fast decoding algorithm for the RS codes can be used as a NASA
standard that is concatenated with convolutional codes.
In the next section, the Fedorenko–Trifonov (FT) algorithm
for finding roots of the error-locator polynomial, usually needed
in the time-domain RS decoders, is briefly reviewed. Section III
develops a new method for the syndrome-evaluation problem.
Such an efficient method implemented on a computer using
C++ language is provided in Section IV. Finally, conclusions
are given in the last section of the letter.
II. FAST ALGORITHM FOR FINDING ROOTS OF A POLYNOMIAL
OVER GF (2m )
As mentioned in Section I, Truong et al. proposed an algo-
rithm for finding the roots of polynomials up to degree 11 for RS
decoders. Then, Fedorenko and Trifonov applied the Truong–
Jeng–Reed (TJR) algorithm, together with a Gray code, to find
the roots of the error-locator polynomial of arbitrary degree.
Before summarizing the FT algorithm, three definitions and
a lemma needed to develop their algorithm are considered as
follows.
Definition 1: A polynomial L(y) over GF (2m ) is called a
p-polynomial for p = 2 if
L(y) =
∑
i
ciy
2i (2)
0090-6778/$25.00 © 2007 IEEE
2242 IEEE TRANSACTIONS ON COMMUNICATIONS, VOL. 55, NO. 12, DECEMBER 2007
4) Compute the syndromes from Sj = r(αj ) =
r3(αj )3 +
∑2
i=0 Ai(α
j )(αj )5i for 1 ≤ j ≤ 6. This yields
(S6 , S5 , S4 , S3 , S2 , S1) =
(
0, α, α11 , α14 , α13 , 1
)
.
From (6), one only needs to compute the four values
Li(α0), Li(α1), Li(α2), and Li(α3) instead of all values
Li(αj ) for 0 ≤ j ≤ 6. These values, needed to evaluate the
affine polynomials Ai(αj ) at each 0 ≤ j ≤ 6, require only one
addition.
Example 2: Consider a (255, 223) RS code in GF (28) with
minimal distance d = 33. In this code, s erasures and v errors
under the condition 2v + s ≤ 32 can be corrected. The received
polynomial is defined as
r(x) =
254∑
i=0
rix
i (7)
where ri ∈ GF (28).
From (3), (7) can be decomposed into a sum of multiples of
affine polynomials, that is
r(x) = r3x3 +
50∑
i=0
Ai(x)x5i (8)
where Ai(x) =
∑3
j=0 r5i+2j x
2j + r5i = Li(x) + r5i for 0 ≤
i ≤ 50.
The computation of the syndromes is given by
Sj = r(αj )=r3(αj )3+
50∑
i=0
Ai(αj )(αj )5i , for 1 ≤ j ≤ 32
(9)
where α is a primitive element of GF (28).
Initially, one first computes Li(αj ) directly. Then, obviously,
Ai(αj ) is obtained for 0 ≤ j ≤ 7 and 0 ≤ i ≤ 50. In order to
compute the syndrome Sj for 1 ≤ j ≤ 32 in this example, the
vectors αj for 1 ≤ j ≤ 32 are properly rearranged to obtain the
following m = 8 sequences.
1) α0 = 00000001, α25 = 00000011, α14 = 00010011,
α198 = 00000111, α13 = 10000111, α24 = 10001111.
2) α1 = 00000010, α26 = 00000110, α15 = 00100110.
3) α2 = 00000100, α27 = 00001100, α16 = 01001100,
α104 = 00001101, α18 = 00101101.
4) α3 = 00001000, α28 = 00011000, α17 = 10011000,
α201 = 00111000, α9 = 00111010, α105 = 00011010,
α19 = 01011010, α200 = 00011100, α8 = 00011101,
α32 = 10011101, α197 = 10001101, α12 = 11001101,
α23 = 11001001.
5) α4 = 00010000, α29 = 00110000.
6) α5 = 00100000, α30 = 01100000, α202 = 01110000,
α10 = 01110100, α106 = 00110100, α20 = 10110100,
α203 = 11100000, α11 = 11101000, α22 = 11101010,
α21 = 01110101.
7) α6 = 01000000, α31 = 11000000.
8) α7 = 10000000.
In sequence 1, the initial vector is set to be α0 . The next vector
is chosen to be α25 ∈ S, where S = {α1 , α2 , α3 , . . . , α32},
such that α25 and α0 differ in only one bit [i.e.,
wt(α25 − α0) = 1]. Next, α14 obtained by S is chosen
so as to satisfy the condition wt(α14 − α25) = 1. If no vector
αj for 1 ≤ j ≤ 32 can be found to satisfy wt(αj − α14) = 1,
then another vector α198 /∈ S must be found so that both
α198 and the preceding vector α25 that belongs to S differs
in only one bit. The reason to choose this vector is that
α13 ∈ S following α198 can be chosen for which it satisfies
wt(α13 − α198) = 1. Finally, one proceeds in a similar way
to obtain α24 . From the precomputed values Li(αj ) for
0 ≤ j ≤ 7 and 0 ≤ i ≤ 50 and (1), the affine polynomials
Ai(α25) = Ai(α0) + Li(α), Ai(α14) = Ai(α25) + Li(α4),
Ai(α198) = Ai(α25) + Li(α2), Ai(α13) = Ai(α198) +
Li(α7), and Ai(α24) = Ai(α13) + Li(α3) are thus obtained.
In sequence 2, for a given initial vector α1 , the affine
polynomials are Ai(α26) = Ai(α) + Li(α2) and Ai(α15) =
Ai(α26) + Li(α5).
In sequence 3, for a given initial vector α2 , the 8-
bit vectors are ordered in such a manner that only one
bit changes from the current vector to the next vector,
except that α104 /∈ S following α16 is chosen to be the
next symbol that differs from the preceding vector α27
in only one bit. Again, from (1), one obtains Ai(α27) =
Ai(α2) + Li(α3), Ai(α16) = Ai(α27) + Li(α6), Ai(α104) =
Ai(α27) + Li(α0), and Ai(α18) = Ai(α104) + Li(α5).
In sequence 4, given an initial vector α3 , the 8-bit vec-
tors are in order such that the next vector is only one bit
that changes from the current vector, except that α201 and
α200 not found in S are chosen to be the next symbols
that differ from the preceding vector α28 ∈ S in only one
bit, respectively. Applying (1) to the resulting sequence then
yields
Ai(α28) = Ai(α3)+Li(α4), Ai(α17) = Ai(α28)+Li(α7),
Ai(α201) = Ai(α28) + Li(α5)
Ai(α9) = Ai(α201)+Li(α), Ai(α105)=Ai(α9)+Li(α5),
Ai(α19) = Ai(α105) + Li(α6)
Ai(α200) = Ai(α28)+Li(α2), Ai(α8)=Ai(α200)+Li(α0),
Ai(α32) = Ai(α8) + Li(α7)
Ai(α197) = Ai(α32)+Li(α4), Ai(α12)=Ai(α197)+Li(α6)
Ai(α23) = Ai(α12) + Li(α2).
In sequence 5, for a given initial vector α4 , the next vector
α29 differs from α4 in only one bit. Thus, Ai(α29) = Ai(α4) +
Li(α5).
In sequence 6, given an initial vector α5 , the 8-bit vectors
are in order such that the next vector changes only one bit from
the current vector, except that α203 /∈ S is chosen to be the next
symbol that differs from the preceding vector α30 ∈ S in only
one bit. From (1), one has
Ai(α30) = Ai(α5)+Li(α6), Ai(α202)=Ai(α30)+Li(α4),
Ai(α10) = Ai(α202) + Li(α2)
Ai(α106) = Ai(α10)+Li(α6), Ai(α20)=Ai(α106)+Li(α7),
Ai(α21) = Ai(α10) + Li(α0)
