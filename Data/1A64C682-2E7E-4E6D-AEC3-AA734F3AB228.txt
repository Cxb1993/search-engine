1Չࡹଣ୯ৎࣽᏢہ঩཮஑ᚒࣴزीฝ่ਢൔ֋
ว৖ъᏤᡏᐒѠᆛၡԄບᘐᆶႣٛߥᎦس಍ -- ηीฝ΋
ъᏤᡏᐒѠᆛၡԄບᘐᆶႣٛߥᎦس಍ϐ൪ΕԄࢎᄬ೛ीᆶჴբ(3/3)
Design and Implementation of an Embedded Architecture for e-Diagnostics and
e-Maintenance Systems for Semiconductor EquipmentȐ3/3ȑ
ी ฝ ጓ ဦǺ NSC-94-2212-E-006-006
୺ Չ ය ज़Ǻ 94/08/01 ~ 95/07/31
ी ฝ Ь ࡭ ΓǺ ᎄޱҖ ԋфεᏢᇙ೷πำࣴز܌௲௤
΋ǵύमЎᄔा
ύЎᄔा
ҁηीฝ܌ࣴวϐ൪ΕԄኳಔ (Embedded Agent) ϐЬाҞޑࣁᘏڗ٠ගٮъᏤᡏ೛ഢϐπำၗ਑ (EE
Data, Equipment Engineering Data) ๏ځѬηीฝ٬ҔǶҁ൪ΕԄኳಔஒа Embedded Linux ࣁ൪ΕԄ೬ᡏ
ѳᆵǴ٠٬ҔԾҗ೬ᡏ (Free Software) ว৖ှ،Бਢǹҁ൪ΕԄբ཰س಍ϐਡЈࣁ Device Communication
ManagerǴځϣ೽ᝩ܍ᕴीฝϐ Web Service Agent аගٮ΋ठ܄ϐᆛၡ೯ૻБԄǶᝩ܍ Web Service
Agent ೛ीϐ Device Communication Manager ёකΕ EEData Collector ϡҹǴ၀ϡҹୖྣ SEMI ϐ Data
Collection Management ᆶ Equipment Services Description ೕ਱ЎҹǴ٠ᔈҔނҹᏤӛǵϩණԄނҹǵ
OBEM ೕጄ຾Չ೛ीǴаၲډᘏڗᐒѠπำၗ਑ϐҞޑǶEEData Collector ܌ᘏڗϐъᏤᡏ೛ഢπำၗ
਑ёа೸ၸ Device Communication ManagerϣϐWeb Service Agentගٮ๏ᆛၡԄບᘐᆶႣٛߥᎦфૈࢎ
ᄬȐηीฝΒȑǵӃ຾ᇙำ௓ڋᆶӄय़ᐒѠਏ౗ໆෳس಍ȐηीฝΟȑǵ਑ଛҹނࢬᆅ౛ᐒڋȐηीฝѤȑǵ
ϷᆛၡԄບᘐᆶႣٛߥᎦϐёୀᒱ܄༟ኳᆶϩ݋Ȑηीฝϖȑǵᆶ೛ഢٮᔈ୘ᆄ (Supplier Side) ٬ҔǴ٠
Ъёа໺ଌԿකΕܭ Device Communication Manager ΢ϐځѬᔈҔኳಔǶࣁԵቾ҂ٰϐᘉк܄ᆶᔈҔǴ
ҁ೯Ҕࠠ൪ΕԄኳಔϣϐ Device Communication Manager ҭஒႣ੮ᔈҔኳಔϐ෌Εϟय़аٮ҂ٰᘉкф
ૈ܌ሡ;ӵஒηीฝΒϐ ODMSᆶηीฝΟϐ AOS фૈ౽෌Εҁ൪ΕԄኳಔ฻Ƕа΢܌ॊ᏾ঁس಍೿ࢂ
ӧ Embedded Linux ΢୺ՉǴ٠ЪΨ཮ࣴز௦Ҕ SoC (System-on-Chip) ϐࢎᄬ೛ीǴঈ৒ܰӼးܭъᏤ
ᡏᐒѠϣ೽Ƕ
ηीฝ΋ϐࣴزЬᚒӵΠǺ
1) ࣴز Embedded LinuxǵԾҗ೬ᡏϷ൪ΕԄس಍ᕉნᆶሡ؃ϩ݋ǹ
2) ೛ी೯Ҕࠠ൪ΕԄس಍ࢎᄬǹ
3) ࣴز Device Communication Manager ϐሡ؃٠຾Չ೛ीǹ
4) ࣴز EEDate Collector ϐሡ؃٠຾Չ೛ीǹ
5) ࣴزа OBEM ኱ྗᘏڗъᏤᡏᐒѠၗૻ (EEData) ٠຾Չ೛ीǹ
6) ࡌᄬ୷ܭ Embedded Linux ϐ൪ΕԄջਔբ཰س಍ѳᆵǹ
7) ࡌᄬᝩ܍Ծ Web Service Agent ϐ Device Communication Managerǹ
8) ࡌᄬ EEData Collectorǹ
9) ࡌᄬ୷ܭ OBEM ኱ྗϐᐒѠၗૻኳಔǹ
10) ຾ՉᕴीฝᆶӚηीฝ໔ϐӄس಍᏾ӝෳ၂ǹ
11) ຾Չஒ ODMSᆶ AOSϐфૈ౽෌Εҁ൪ΕԄኳಔޑёՉ܄ϩ݋ᆶֹԋ೽࿿ीฝǹ
12) ຾Չҁ೯Ҕࠠ൪ΕԄኳಔϐ SoC ࢎᄬޑ೛ीຑ՗ǹ
13) ΢ጕෳ၂Ϸ܄ૈຑ՗ᆶКၨǶ
3Βǵϩԃ໘ࢤ܄Ҟ኱
ҁीฝϐϩԃ໘ࢤ܄Ҟ኱ӵΠǺ
ಃ΋ԃǺֹԋ൪ΕԄբ཰س಍࣬ᜢሡ؃מೌϩ݋ᆶ೯Ҕࠠ൪ΕԄࢎᄬϐ೛ी
1) Embedded LinuxǵԾҗ೬ᡏϷ൪ΕԄس಍ᕉნᆶሡ؃ϩ݋Ƕ
2) Ҕࠠ൪ΕԄس಍ࢎᄬǶ
3) Device Communication Manager ϐሡ؃٠຾Չ೛ीǶ
4) EEDate Collector ϐሡ؃٠຾Չ೛ीǶ
5) а OBEM ኱ྗᘏڗъᏤᡏᐒѠၗૻ (EEData) ٠຾Չ೛ीǶ
ಃΒԃǺֹԋъᏤᡏᐒѠᆄ೯Ҕࠠ൪ΕԄኳಔϐჴբǺ
6) ୷ܭ Embedded Linux ϐ൪ΕԄջਔբ཰س಍ѳᆵǶ
7) ᝩ܍Ծ Web Service Agent ϐ Device Communication ManagerǶ
8) ࡌᄬ EEData CollectorǶ
9) ࡌᄬ୷ܭ OBEM ኱ྗϐᐒѠၗૻኳಔǶ
ಃΟԃǺֹԋس಍᏾ӝᆶ΢ጕෳ၂
10) ຾ՉᕴीฝᆶӚηीฝ໔ϐӄس಍᏾ӝෳ၂Ƕ
11) ຾Չஒ ODMSᆶ AOSϐфૈ౽෌Εҁ൪ΕԄኳಔޑёՉ܄ϩ݋ᆶֹԋ೽࿿ीฝǶ
12) ຾Չҁ೯Ҕࠠ൪ΕԄኳಔϐ SoC ࢎᄬޑ೛ीຑ՗Ƕ
13) ΢ጕෳ၂Ϸ܄ૈຑ՗ᆶКၨǶ
Οǵಃ΋ǵΒǵΟԃρֹԋ໨Ҟ
ᄒԿ 95.7.31ЗǴҁीฝρਥᏵϩԃ໘ࢤ܄Ҟ኱܌௨ۓϐਔำǴӵයֹԋಃ΋ǵΒǵΟԃࡋ܌టၲԋϐҞ
኱Ƕ౜ϩॊӵΠǺ
ಃ΋ԃ೽ҽ
Ьᚒ΋Ǻࣴز Embedded LinuxǵԾҗ೬ᡏϷ൪ΕԄس಍ᕉნᆶሡ؃ϩ݋
ҁηीฝஒଞჹ Embedded Linux ϐس಍ࢎᄬǴϩձࣴز (1) Embedded Linux (2) Ծҗ೬ᡏ (3) ൪ΕԄس
಍ᕉნᆶሡ؃Ƕ
1.1 Embedded Linux
Embedded Linux (܈ᆀࣁ Embedded Linux System) ࢂ΋
ঁଞჹ੝ۓฯᡏ (Hardware) ѳᆵ܌ໆيۓᇙޑ೬ᡏѳ
ᆵǴӵკ΋ϐ Embedded Linux ޑࢎᄬკ[3][4] ܌ҢǴ೭
ࢂ΋ঁϩቫޑࢎᄬǴനۭቫࣁ HardwareǴ۳΢߾ࣁ
Linux KernelǵSystem Shared Librariesǵᆶ ApplicationsǴ
౜ϩձᇥܴӵΠǶ
1.1.1 Linux Kernel
Linux kernel ࢂ΋ঁமεǵёߞᒘǵڀቸ܄ᆶᘉк܄ޑբ
཰س಍ਡЈ (OS Kernel)ǶLinux Kernel ჴբΑ೚ӭ౜ж
ϯբ཰س಍ޑ౛ፕǴ٠ЪЍජֹ᏾ޑฯᡏ᙮୏ำԄǵᆛ
ၡ೯ૻڐۓᆶӭೀ౛ᏔޑࢎᄬǴ೭ჹܭ΋ঁ൪ΕԄբ཰
س಍ਡЈԶقǴࢂߚதख़ाޑᒧ᏷٩Ᏽ [5]Ƕ
Linux ޑᔈҔ೬ᡏЍජ࣬྽ӭǴ٠ЪΨԖკ׎ϯޑᕉნǹӧำԄว৖Бय़Ǵጓ᝿ᏔǵନᒱπڀᆶำԄ৤
LinuxKernel
SystemShared Libraries
Applications
Hardware
Buttom
Layer
კ΋ǺEmbedded Linux س಍ࢎᄬ
5ԄǶӢԜҁηीฝޑख़ᗺϐ΋߾ࢂว৖ System
Shared Libraries ᆶ Linux Kernel ቫ฻ϐЍජᕉნǶ
1.2 Ծҗ೬ᡏ (Free Software)
ӵკΒǴ᏾ঁ Embedded Linux ޑس಍ว৖Бݤёа
ϩࣁΒঁቫय़Ǻ1. ଞჹ೬ᡏᆶфૈሡ؃଺س಍᏾ӝǹ
2. ଞჹฯᡏѳᆵ೛ۓ٠ጓ᝿ਡЈᆶس಍ำԄǶӧკ
Ο္ޑ຀ጕБ༧߾ࢂӈᖐр൳ঁж߄܄ޑ Open
Source ஑ਢ (΢ъ೽) ᆶதـޑฯᡏѳᆵ (Πъ
೽)Ǵ೭٤஑ਢीฝϐำԄዸᆶόӕޑฯᡏѳᆵ࿶த
೏٬ҔܭӚᅿ஑ਢࣴزीฝǶ
ճҔ Embedded Linux מೌว৖൪ΕԄး࿼ޑനε
ӳೀࢂǴךॺёаஒ᏾ঁว৖ኳԄ
வฯᡏᆶಔӝᇟقำԄϐ᏾ӝᄽ຾ډൂᐱว৖ᔈҔ
೬ᡏջёǶ೭Ψ಄ӝҁηीฝϐሡ؃ǴҭջճҔӚ
ᅿԾҗ೬ᡏٰว৖ҁηीฝ܌ሡϐӚᅿኳಔǶӢ
ԜǴҁηीฝޑख़Јஒ཮ࢂȨଞჹ೬ᡏᆶфૈሡ؃
଺س಍᏾ӝȩǴԶӧ೬ᡏБय़Ǵҁηीฝ௦ՉޑБԄ
߾ࢂ٬ҔȨԾҗ೬ᡏȩ଺ࣁس಍ว৖฼ౣǶ
1.2.1 ࣁϙሶा٬ҔԾҗ೬ᡏ
Ծҗ೬ᡏႴᓰࡲنǵঅׯǵࣴزᆶׯؼǴӢԜךॺࢂӧע፺η೷ள׳ӳǴԶόࢂӧ଺ख़೷ً፺ޑπբǴ
٠ЪԾҗ೬ᡏΨႴᓰஒׯؼࡕޑำԄӣ㎸๏Ծҗ೬ᡏޗဂ[2]Ƕ
Linux ࢂനԖӜޑԾҗ೬ᡏϐ΋ǴଛӝځѬԾҗ೬ᡏ଺ࣁว৖฼ౣਔǴ΋ҽჴҔޑ೬ᡏᙔკࢂࡐख़ाޑǴ
೬ᡏᙔკёаࡐܴዴӦӈрԾҗ೬ᡏޑϩᜪǵԖٗ٤೬ᡏёа٬Ҕǵᆶ҂ٰޑว৖ᖿ༈฻Ƕ୯ϣҞ߻җ
ύ๮҇୯Ծҗ೬ᡏڐ཮ (Software Liberty Association of Taiwan) ܌ጓᇙޑԾҗ೬ᡏᕴᙔკࢂගٮࡹ۬௢
ቶԾҗ೬ᡏޑख़ाЎҹ [7]Ƕҁηीฝஒ٩ᏵԜЎҹќѦ᏾౛΋ҽȨъᏤᡏᇙ೷ᆶᐒѠᆢঅȩϐ੝ਸҔ೼
Ծҗ೬ᡏᙔკǶӢԜǴҁηीฝஒаȨъᏤᡏᇙ೷ᆶᐒѠᆢঅȩϐ੝ਸҔ೼Ծҗ೬ᡏᙔკӣ㎸๏Ծҗ೬
ᡏޗဂǶ
1.2.2 Ծҗ೬ᡏޑހ៾ᖂܴ
ӧ٬ҔԾҗ೬ᡏਔǴჹܭހ៾ޑᖂܴБԄΨा੝ձݙཀǶLinux Kernel ᆶ FSF (Free Software Fundation)
ޑ GNU ஑ਢԋ݀೿ࢂа GPL (General Public License) ޑހ៾ᖂܴ܌ញрǶGPL ࢂ FSF ԾՉुۓޑచ
ЎǴ྽߃ࢂҗ Richard Stallman ک൳Տݤࡓ஑ৎ܌ᔕۓǴGPL ޑЬाҞޑࢂा਍ፁ FSF ޑᆒઓǴځύ
ԖΟঁЬाޑख़ᗺ[8]Ǻ
1)ҺՖڗள GPL ೬ᡏޑΓǴ೿Ԗ៾ڗள೬ᡏޑচۈዸǴԶЪόሡाᚐѦб຤ (ၮ຤ନѦ)Ƕ
2)ҺՖҗ GPL ೬ᡏঅׯǵว৖Զٰޑ೬ᡏǴख़ཥණ܀ਔǴϝ໪٩ൻ GPL ೚ёǶ
3)ᏱԖ GPL ೬ᡏޑঁΓǴԖ៾ӧόၴϸ GPL ೚ёΠǴख़ཥණթԜ೬ᡏǶ
GPL చЎύ٠คගډ೬ᡏሽ਱ୢᚒǴӢԜǴӧচۈዸόளќՉԏ຤ΠǴ؂ঁΓ೿ёааҺՖሽᒲஒ GPL
೬ᡏ፤๏៝࠼ǴхࡴԾՉঅׯၸޑ GPL ೬ᡏǹ៝࠼ӧ GPL ޑߥምΠǴΨёаӆஒ೭ঁ೬ᡏаҺՖሽᒲ
ӆ፤๏ځѬΓǶ
1.3 ൪ΕԄس಍ᕉნᆶሡ؃
ࣴز൪ΕԄس಍ᕉნᆶሡ؃ϐЬाҞޑࣁࡌ࿼΋ঁ೯Ҕޑ Embedded LinuxѳᆵǴӢԜۭΠஒӈрႣයஒ
཮٬ҔډޑԾҗ೬ᡏᆶჴᡍѳᆵǶ
1.3.1 Ծҗ೬ᡏ೽ҽ
Ծҗ೬ᡏ೽ҽஒҔډ Embedded Linux DistributionǵEmbedded Web ServerǵGNU Compiler Collection (GCC)
ᆶ GNU Debugger (GDB) ฻Ǵ౜ϩ௶ӵΠǶ
ಾኙຌ᧯ፖפ౨
Ꮑޣ೚ߓอᖞٽ
ಾኙ࿏᧯ؓፕ๻ࡳࠀ
ᒳ᤟ு֨ፖߓอ࿓ڤ
˘̀˵˸˷˷˸˷ ˼˟́̈̋
ߓอ࿇୶
Linux kernel
Apache
MySQL
PHP
X Window
System
KDE
Perl
IBM PC/IA32
MIPS
ARM
SBCs
SoC
კΒǺEmbedded Linux ว৖Бݤ
7Ҟ߻Ԗ೚ӭଯࡋ᏾ӝޑ SoC IC ှ،БਢǴаදၹ೏٬Ҕޑ Intel StrongARM SA-1110 ೀ౛ᏔࣁٯǴѬ൩
ගٮΑ Linux ࣬৒ᆶ൪ΕԄ೬ᡏ܌ሡޑฯᡏૈΚǶIntel StrongARM ࢂ΋ᗭ 32-bit StrongARM RISC ࢎ
ᄬޑೀ౛ᏔǴೲࡋёаၲډ 206 MHzǴ٠Ъ᏾ӝΑ MMUǵLCD ControllerǵSerial I/O ฻ [15][16]Ƕ
٬Ҕ Embedded Linux מೌޑӳೀӧܭךॺε೽ҽਔ໔೿ӧ຾Չ೬ᡏޑว৖πբǴӢԜࣁΑᕭอচࠠᐒ
ޑࣴวਔ໔ᆶ೛ीࢬำǴനӳૈ٬Ҕᜪ՟ IBM PC/IA32 ࢎᄬޑฯᡏѳᆵǶԜᖿ༈ԋࣁ Embedded Linux
מೌว৖ޑᜢᗖǶ
୷ܭ SoC ೀ౛Ꮤࢎᄬޑှ،Бਢ - SBC ࢂќѦ΋ঁόᒱޑᒧ᏷ǶSBC εӭᆶ PC ࣬৒ǴӢԜӧ PC ΢
ว৖ޑ Embedded Linux س಍ёаࡐ໩ճӦ౽෌ډ SBC ΢ǹӕਔǴSBC ΨԖӚᅿόӕೀ౛ᏔޑౢࠔǴ
ٯӵǺ PowerPCǵStrongARM ǵCrusoe ฻ǶSBC ޑќѦ΋ঁӳೀࢂᡏᑈλǴ೯தό཮К΋૓ޑӀᅷᐒ
εǴԶЪሽ਱ΨКπ཰ҔႝတեǴ೭ࢂҁηीฝ΋،ۓ٬Ҕ SBC ޑচӢǶ
Ҟ߻தـ٠࣬৒ܭ Linux מೌޑೀ౛ᏔԖǺ[17]
1) ARM
2) MIPS
3) PowerPC
4) x86
5)ځѬ
൩౜ݩԶقǴ୷ܭ x86 ೀ౛Ꮤࢎᄬޑ঺ҹ (packages)ᆶำԄ৤ (libraries)ǴLinux Kernel ᆶ Linux
Distributions ϝۚӭኧǴ٠Ъӧࣴว໘ࢤ٬Ҕ x86 ࢎᄬޑೀ౛ᏔϝฅԖځд೚ӭӳೀǴӢԜҁीฝஒа
x86 ࢎᄬޑೀ౛ᏔࣁЬǶ
Ҟ߻୷ܭ x86 ೀ౛Ꮤޑ SBC ౢࠔ࣬྽ӭǴ྽ฅΨԖځѬೀ౛Ꮤࢎᄬޑ SBC ౢࠔǶҁηीฝӧჴբ೽
ҽ߾ࢂᒧ᏷а ibase ܌ࣴวޑ IB755 SBC ଺ࣁฯᡏှ،БਢǶIB755 ࣁ٬Ҕ Transmeta Crusoe TM5x00
ೀ౛Ꮤϐ SBC ౢࠔǶTransmeta ޑ Crusoe ೀ౛ᏔΨࢂ x86 ࡰз໣ࢎᄬǴӢԜё࣬৒ܭךॺӧ΋૓ PC
΢܌ࣴวޑ Embedded Linux س಍ǴΨ൩ࢂஒس಍җ PC ౽෌Կ IB755 ΢ਔǴ٠όሡाӆ຾Չ
cross-compiling ޑ୏բ [18]Ƕ
ЬᚒΒǺ೛ी೯Ҕࠠ൪ΕԄس಍ࢎᄬ
೯Ҕࠠ൪ΕԄس಍ࢎᄬ೛ीϐሡ؃ԖΟ Ǻঁ(1) ٬Ҕᕴी
ฝ೛ीϐ Web Service AgentǴаගٮ಍΋ޑྎ೯
(Communication) ࣚय़ǹ(2) а OBEMೕጄڗளъᏤᡏ೛
ഢϐπำၗ਑ (Equipment Engineering Data, EE Data)Ǵ٠
೸ၸ Web Service Agent ໺ଌǹ(3) Ⴃ੮ำԄࣚय़Ǵа౽
෌ځѬηीฝϐᔈҔำԄǶҁηीฝ೛ीᆶჴբϐ೯Ҕ
ࠠ൪ΕԄኳಔᆀϐࣁ Embedded AgentǶ
ӵკΟϐ΢ъ೽ǴךॺޑᄬགྷࢂǴ೛ी΋ঁᝩ܍ᕴीฝ
ගٮޑ Web Service Agent ϐ Device Communication
Manager ٠කΕ EEData Collector ϡҹǶ EEData
Collector ϡ ҹ ஒ ୖ Ե SEMI ϐ Data Collection
Management[19] ᆶ Equipment Services Description [20]
ೕ਱ЎҹٰჴբǴ٠ᔈҔނҹᏤӛǵϩණԄނҹǵOBEM
኱ྗ຾Չ೛ीǴаၲډᘏڗᐒѠπำၗ਑ϐҞޑǶEEData
Collector ܌ᘏڗϐъᏤᡏ೛ഢπำၗ਑ёа೸ၸ
Device Communication ManagerǵWeb Service Agentǵ
SOAP ኱ ྗ ໺ ଌ Կ ᆛ ၡ ΢ Ǵ ܈ ࢂ ೸ ၸ Device
Communication Manager ໺ ଌ Կ ක Ε ܭ Device
Communication Manager ΢ϐځѬᔈҔำԄǶਥᏵკΟ΢ъ೽܌Ңޑ೯Ҕࠠ൪ΕԄس಍ࢎᄬǴۭΠஒϩձ
ᇥܴԜࢎᄬӵՖᅈى΢ॊ܌ගрޑΟঁሡ؃Ƕ
2.1٬Ҕᕴीฝ೛ीϐ Web-Service AgentǴаගٮ಍΋ޑྎ೯ࣚय़
ӵკΟϐ΢ъ೽Ǵךॺ೛ीΑ΋ঁ৒Ꮤ (container) ᆀϐࣁ Device Communication ManagerǴԜ৒Ꮤх֖
Web-Service Agent
Device Communication Manager
Data Collection
Plans
Data Collection
Manager
EEData Collector
Device Metadata
Appli-
cation
2
Appli-
cation
1
Em
be
dd
ed
Li
nu
x
Equipment
Resource
Equipment
Module
Proccess
Capability
Equipment
Material
Location
Carrier
PortClock
Port
Location
OBEM
IO
Device
კΟǺ೯Ҕࠠ൪ΕԄس಍ (Embedded Agent) ϐࢎᄬ
9܍ CommunicationKernelǴӢԜךॺѝाۓကӳଞჹόӕᔈҔኳಔޑำԄࣚय़ǹӧ౽෌ᔈҔኳಔਔǴѝा
ჴբ Device Communication Manager ࣁ೭٤ኳಔ܌ߥ੮ޑࣚय़Ǵ൩ёаஒԜᔈҔኳಔᙯԋࣁ Device
Communication Manager ޑ΋ঁس಍ϡҹǶ
ЬᚒѤǺࣴز EEData Collector ϐሡ؃٠຾Չ೛ी
ӵЬᚒΒ܌ॊǴEEData Collector ஒୖԵ SEMI ϐ Data Collection Management ᆶ Equipment Services
Description ೕ਱ЎҹٰჴբǴӢԜௗΠٰஒϩΟঁ೽ҽ຾Չ EEData Collector ϐሡ؃ϩ݋ᆶ೛ीǺ (1)
EE Data ޑᜪࠠǹ(2) ӵՖа OBEM ೕጄڗள EE Dataǹ(3) ӵՖᆅ౛ EE DataǶ
EEData Collector ޑЬाҔ೼ࣁڗள EE DataǴEEData Collector х֖Οঁ೽ҽǺData Collection Planǵ
Device Metadata ᆶ Data Collection ManagerǶData Collection Plan ЬाਥᏵ EE Data ϐᜪٰࠠ೛ीǴ
Device Metadata ஒ௦Ҕ OBEM ೕጄٰڗள EE DataǴԶ Data Collection Manager Ьाॄೢ EE Data ϐ
ԏ໣ᆶᆅ౛Ƕ౜ϩձᇥܴӵΠǶ
4.1 EE Data ޑᜪࠠ [19]
ਥᏵ SEMI Draft Doc. #3509 ϐۓကǴךॺளޕъᏤᡏ೛ഢϐπำၗૻёϩࣁѤεᜪӵΠ܌ॊǶ
4.1.1 Trace Data
Trace Data ឦܭຼය܄ϐᢀჸၗ਑Ǵ೭٤ၗ਑ޑ੝܄ࢂ཮࡭ុ܄Ӧᡂ୏ǴٯӵǺᓸΚǵྕࡋǵႝᓸ฻Ƕ
4.1.2 Events
྽΋ঁπբֹԋࡕǴ൩཮ଌр΋ঁ event (٣ҹ)Ǵ܈ࢂ྽ subsystemǵprocess jobǵ܈ځѬس಍วғୢᚒਔǴ
ҭ཮ଌр eventǶ
4.1.3 Exceptions
྽ᐒѠวғᒱᇤ (error)ǵ᝾֋ (warning)ǵ᝾Ң (alarm) ਔǴ཮а exceptions БԄଌрૻ৲ǶExceptions ᆶ
event ޑനεόӕೀࢂ exceptions ޑวғёૈ཮೷ԋό҅தύᘐǴ٠ЪόёႣයǶ
4.1.4 Data Collection Plan
Data Collection Plan ࣁ΋ঁ containerǴஒ trace dataǵeventsǵexceptions ໣ύଆٰǴӢԜёаஒ Data
Collection Plan ຎࣁᐒѠၗૻϐ໣ණೀǶ
4.2 ӵՖа OBEM ೕጄڗள EE Data [20]
SEMI Draft Doc. #3510 [20] ϐЎҹගрΑа OBEM ೕጄڗளჴᡏᐒѠ (physical equipment) ၗૻޑБ
ԄǴӢԜךॺਥᏵԜЎҹ೛ी Device Metadata ϡҹٰڗளᐒѠၗૻǶ
ךॺஒ SEMI܌ڋुϐ OBEMೕጄ (E98)྽բ΋ঁ Design Patternٰ٬ҔǴDevice Metadata ஒаނҹڥћ
(Object Invoke)БԄǴڥћ΋ঁа OBEM Design Pattern ჴբᔈҔኳಔٰڗள EE DataǴӵკѤΠъ೽܌
ҢǶ
4.3 ӵՖᆅ౛ EE Data [19]
೸ၸ Device Metadata ஒ EE Data ༤Ε Data Collection Plan ࡕǴௗΠٰ൩Ѹ໪ाԖᆅ౛೭٤ၗૻޑᐒ
ڋǴӢԜ SEMI Draft Doc. #3509 Ўҹ [19] ္܌ඔॊޑ Data Collection Manager ޑҞޑ൩ࢂӧᆅ౛ Data
Collection PlanǶ܌аҁηीฝҭୖྣԜೕጄٰ೛ी Data Collection ManagerǶ
ЬᚒϖǺࣴزа OBEM኱ྗᘏڗъᏤᡏᐒѠၗૻ (EE Data) ٠຾Չ೛ी
җЬᚒΎޑࣴزΑှǴDevice Metadata ࢂа OBEM ኱ྗٰڗள EE DataǶӧ೭္ךॺஒ OBEM ྽ԋ
Design Pattern ٰ٬ҔǴDevice Metadata ѝाڥћ೭ঁ Design Pattern ൩ёڗள EE DataǴฅᐒѠᆄ൩Ѹ
໪ჴբрԜ OBEM ϐᔈҔኳಔǶ౜ஒ OBEM ೕጄᆶځᔈҔኳಔϐ೛ीᇥܴӵΠǶOBEM ೕጄӵკѤ
ϐΠъ೽܈კΎϐ΢ъ೽܌ҢǺ
 EquipmentResource
EquipmentResource ࢂ Equipment ނҹޑ୷ۭᜪձ (base class)ǴEquipmentResource ӕਔΨࢂ IO Device
ޑ୷ۭᜪձǶ
11
1) ᒧҔ RTAI բࣁჴբջਔբ཰س಍ᔈҔำԄϐ౛җӵΠ܌ॊǺ
2) RTAI Ѝජӵ΢Ӆ 4 ᅿႝတࢎᄬǴӢԜёӧόӕࢎᄬޑ SBC ΢୺ՉǶ
3) RTAI ࣁᔈҔำԄࣚय़ǴӢԜёаӧ user space (٬ҔޣำԄޜ໔) ΢ว৖ڀഢջਔૈΚϐᔈҔำԄǶ
RTAI Ҟ߻ς೏ᔈҔܭࣴزջਔ௓ڋس಍΢ǴࣴزሦୱᔈҔၨԋዕ[23][24][25]Ƕ
6.2 ჴ଺ъᏤᡏ೛ഢϐฯᡏܜႽቫ
ฯᡏܜႽቫ (HAL - Hardware Abstraction Layer) ࣁ߈ԃٰӧ൪ΕԄس಍ሦୱ㚊೏ቶࣁᔈҔޑཷۺǴ༾೬
ѳᆵ΢ޑ DirectX ൩ࢂ΋ᅿ HAL ޑཷۺ [26]ǶHAL ࢂբ཰س಍ޑਡЈϐ΋Ǵᙁൂᖱࢂҗբ཰س಍ග
ٮҔٰኗቪᔈҔำԄ܈ၯᔍޑ΋ಔ APIǴճҔ HAL ޑӳೀࢂёа຾ՉᆶฯᡏคᜢޑำԄ೛ी
(device-independent programming)Ƕҗܭ RTAI ΨуΕΑ HAL ޑཷۺǴӢԜҁηीฝ΋ஒ๓Ҕ RTAI ٰ
ჴբ΋ಔ HAL ཷۺޑъᏤᡏ஑Ҕ APIǶ
ࣁΑଞჹъᏤᡏ೛ഢϐሡ؃Ǵҁηीฝ΋ஒ཮ჴբ΋ঁฯᡏး࿼ᔞܭ /dev ҞᒵΠ (/dev/semi)Ǵаගٮฯ
ᡏޑ I/O ӸڗૈΚǴ٠ᙖԜჴ౜ HAL ޑཷۺǶӵკϤǴᙖҗ /dev/semi ϐჴբǴIntermediate Component
ஒёа੿҅ᆶჴᡏъᏤᡏ೛ഢ (physical equipment) ຾Չྎ೯Ƕ
ЬᚒΎǺࡌᄬᝩ܍Ծ Web Service Agent ϐ Device Communication Manager
Web-Service Agent
SoapInterface
ServiceUrl : String
Namespace : String
SetMethodInfo()
<<control>>
UDDIRegistryMechanism
inquiryURL : String
publishURL : String
UserID : String
Password : String
MethodName : String
find_business()
delete_business()
save_business()
setUDDIinfo()
<<control>>
SecurityMechanism
HostUrl : String
CreateSSL()
Validate()
<<control>>
1
1
CommunicationKernel
MethodName : String
HostUrl : String
BusinessName : String
FindService()
DeleteService()
SaveService()
UsedXSLT()
SetMethod()
SetUDDI()
IsAuthenticated()
UseSSL()
SendSQLCommand()
<<boundary>>
1
11
XSLTMechanism
1
LocalDatabase
ServerName : String
SendSQLCommand()
GetAuthorization()
SaveXmlFile()
LoadXslFile()
<<entity>>
1 1
1
1
DeviceCommunicationManager
GetEEdata()
ReplyEEsolution()
ReplyMaintenanceSolution()
PassErrorMessage()
SendDiagnosticStatus()
<<control>>
ODMSInterface
DeliverEventMessage()
ReplyDiagnosticStatus()
<<boundary>>
LocalEEInterface
QueryDiagnosticSolution()
CreateNewCase()
<<boundary>>
1
1
EmbeddedDatabase
SaveEEdata()
SaveEEsolution()
SaveMaintenanceSolution()
QuerySolution()
SaveDiagnosticResult()
<<entity>>
1
1
0..n
(Web-Service Agent for Java)
(Web-Service Agent for Java)
(Web-Service Agent for Java)
(Web-Service Agent for Java)
(Web-Service Agent for Java)
(Web-Service Agent for Java)
(from Embedded Agent) (from Embedded Agent)
(from Embedded Agent)
(from Embedded Agent)
ReplyMaintenanceStatus()
DeliverExceptionMessage()
DeliverTraceData()
EEDCInterface
RequestEEData()
SendEQCommand()
EeliverError()
EeliverUnknowError()
ReplyDiagnosticsStatus()
(from Embedded Agent)
<<boundary>>
1
1 1
0..n
0..1
0..1
0..1
0..1
0..1
0..1
0..1
ReadXml()
<<control>>
კΎǺDevice Communication Manager ϐࣚय़
13
 ExceptionPlan
ExceptionPlan ނҹۓက Exception ૻ৲ޑڗள฼ౣǴ྽ ExceptionPlan ೏௴୏ਔ (activated) س಍൩໒ۈ
ڗள Exception ૻ৲ǶExceptionPlan ᜪձԖΒঁԋ঩ڄኧǴᇥܴӵΠǺ
z SetBufferTime() – ೛ۓૻ৲Ӹܫ୔ (buffer) ޑВයᆶਔ໔Ǵаዴۓ܌ᘏڗૻ৲ޑਔ໔҅ዴ܄Ƕ
z ActivateException() – ௴୏ Exception ᜪձǴаڗள׳຾΋؁ޑ Exception ૻ৲Ƕ
 Exception
Exception ނҹ߄ҢᐒѠϐ Exception ၗૻǶException ᜪձԖΒঁԋ঩ڄኧǴᇥܴӵΠǺ
z GetSourceID() – ڗள Exception ޑૻ৲ጓဦǶ
z GetExceptionDesc() – ڗள Exception ޑૻ৲ϣЎǶ
 EventPlan
EventPlan ނҹۓက Event ૻ৲ޑڗள฼ౣǴ྽ EventPlan ೏௴୏ਔ (activated)س಍൩໒ۈڗள Event
ૻ৲ǶEventPlan ᜪձԖΒঁԋ঩ڄኧǴᇥܴӵΠǺ
z SetBufferTime() – ೛ۓૻ৲Ӹܫ୔ (buffer) ޑВයᆶਔ໔Ǵаዴۓ܌ᘏڗૻ৲ޑਔ໔҅ዴ܄Ƕ
z ActivateEvent() – ௴୏ Event ᜪձǴаڗள׳຾΋؁ޑ Event ૻ৲Ƕ
 Event
Event ނҹ߄ҢᐒѠϐ Event ၗૻǶEvent ᜪձԖΒঁԋ঩ڄኧǴᇥܴӵΠǺ
z GetSourceID() – ڗள Event ޑૻ৲ጓဦǶ
z GetEventDesc() – ڗள Event ޑૻ৲ϣЎǶ
8.2 DataCollectionManager [19]
კΐࢂ DataCollectionManager ϐჴբǴ؂ঁނҹޑҔ೼ᇥܴӵΠǶ
setBufferTime()
ActivateException()
ExceptionPlan
TraceReport
traced : String
interval : Double
totalSamples : Long
startOnEvent : Event
stopOnEvent : Event
renewOnCompletion : Boolean
groupSize : Long
bufferAll : Boolean
1 1
n
0..n
1
1
1..n
0..n
n
0..n
1
n
1
1..n
DataCollectionPlan
planName : String
ActivateEventPlan()
ActivateExceptionPlan()
ActivateTraceReport()
bufferTime : Double
EventPlan
bufferTime : Double
setBufferTime()
ActivatePlan()
Event
sourceid : String
eventDescriptor : String
GetSourceID()
GetEventDesc()
SetBufferPolicy()
SetInterval()
SetRenew()
GetReport()
Exception
sourceid : String
code : String
severity : Integer
GetSourceID()
GetExceptionDesc()
Parameter
sourceid : String
parameterName : String
GetSourceID()
GetParameterName()
კΖǺDataCollectionPlan ϐჴբ
15
߄΋ǵ೽ϩೱុၗ਑ȐTraceDataȑ
߄ΒǵᐒѠᒱᇤжዸ
ћ OBEM ၗૻᐒѠǴฅࡕ OBEM ၗૻᐒѠӆ໺ӣჴᡏᐒѠၗૻǶ
ӵკΜǴDevicMetadata ϐ೛ीᇥܴӵΠǶ
 DeviceMetadata
ڥ ћ DeviceMetadata ϐ ԋ ঩ ڄ ኧ
ActivateDevice() ё௴୏ EE Data ϐᘏڗ୏
բǹڥћ DeactivateDevice() ёଶЗᘏڗ୏
բ Ƕ ActivateDevice() ё ӕ ਔ ڗ ள
DeviceStructure ǵ StatechartEvents ǵ
SoftwareState ᆶ Exceptions ᜪձ܌ᘏڗϐ
ၗ਑Ƕ
 Parameters
Parameters ᜪձճҔ SetType() ԋ঩ڄኧڥ
ћ ParameterTypes ᜪ ձ ϐ ࡌ ᄬ η Ǵ
ParameterTypes ᜪձӆճҔ SetName() ᆶ
SetDesc() ڄኧٰ೛ۓԜ ParameterTypes ᜪ
ձϐӜᆀ (name ឦ܄) ᆶᇥܴ (description
ឦ܄)Ƕӕ౛ǴSetDesc() ڄኧڥћ Units ᜪ
ձϐࡌᄬηǴUnits ᜪձӆճҔ SetName()
ᆶ SetDesc() ೛ۓԜ Units ᜪձϐӜᆀ
(name ឦ܄) ᆶᇥܴ (description ឦ܄)Ƕ
 DeviceStructure
DeviceStructure ᜪձϐ GetDevice() ڄኧڥ
ћ OBEM ᐒѠǴаڗளᐒѠϐ୷ҁၗૻǴ
ӵᐒѠҔ೼ǵ೛ഢጓဦ฻Ƕ
 SoftwareState
SoftwareState ᜪ ձ ϐ GetSoftwareState() ڄ ኧ ё ڗ ள
Embedded Linux ϐբ཰س಍ރᄊǴаΑှբ཰س಍ϐॄၩ฻
ၗૻǶ
 StatechartEvents
StatechartEvents ᜪձϐ GetEvent() ڄኧڥћ OBEM ᐒѠǴ
аڗளᐒѠϐ Event ၗૻǶԜڄኧ೏კΐϐ DataCollectionPlan
ᜪձύޑ TraceReport ᜪձޑ GetReport()ڄኧೱុڥћࡕǴஒ
໺ӣӵ߄΋܌Ңޑೱុၗ਑ॶǶ೭٤ೱុၗ਑߄ҢԾኳಔжဦ
ࣁ 5.1 ( M5.1 ) ܌ڗளޑ 3ঁ Sensorၗ਑Ǵಃ΋Չࣁၗ਑׬ڗ
ਔϐس಍ਔ໔૶ᒵȐਔǺϩǺࣾȑǹಃΒՉࣁπբႝࢬǴൂՏ Aǹ
ಃΟՉࣁπբႝᓸǴൂՏǺVǹಃѤՉࣁ௽ᙯπբೲࡋǴൂՏ
m/minǹӚೱុၗ਑ࠠᄊࣁੌᗺኧȐfloatȑǶ
 Exceptions
Exceptions ᜪձϐ GetException() ڄኧڥћ OBEM ᐒѠǴа
ڗ ள ᐒ Ѡ ϐ Exceptions ၗ ૻ Ƕ Ԝ ڄ ኧ ೏ კ ΐ ϐ
DataCollectionPlan ᜪձύޑ ExceptionPlan ᜪձύޑ Exception
ᜪձύޑ GetSourceID()ڥћǴঈڗளӵ߄Β܌ҢϐжዸǶ߄Β
ύϐжዸWࣁWarningǵFࣁ Fatal AlarmǶϩձᇥܴӵΠǴѰ
ᜐࣁኳಔжဦࣁ 5.1 ( M5.1 ) Ҟ߻ޑރᄊǴಃΒӈ W2Ǻ
VACUUM MODULE 5.1 วғ Warning жဦࣁ 2Ǵฅࡕёаჹྣѓᜐޑᒱᇤжዸ܌ж߄ޑཀࡘǶW2:No
Compressed AirǴԜжዸᇥܴኳಔ 5.1ޑ੿ޜး࿼วғςคޜ਻ᓸᕭޑ᝾֋ǴԿܭځѬޑжዸё٩ԜБԄ
ᜪ௢Ƕ
StatechartEventsDeviceStructureParameters
SoftwareState
name : string
description: string
GetSoftwareState()
name : string
description: string
GetDevice()
Exceptions
id : string
description: string
GetException()
name : string
description: string
GetEvent()
type : string
units: string
SetType()
SetUnits()
ParameterTypes
name : string
description: string
SetName()
SetDesc()
Units
name : string
description: string
SetName()
SetDesc()
DeviceMetadata
id : string
description: string
ActivateDevice()
DeactivateDevice()
კΜǺDeviceMetadata ϐჴբ
17
٩Ᏽᕴीฝ܌ೕჄϐૻ৲ྎ೯ࢬำ Ȑӵख़ᗺᇥܴϣϐკϤ~კΜ܌Ңȑ ٰ຾ՉǶ
ЬᚒΜ΋Ǻ຾Չஒ ODMSᆶ AOSϐфૈ౽෌Εҁ൪ΕԄኳಔޑёՉ܄ϩ݋ᆶֹԋ೽࿿ीฝ
ҁηीฝஒ຾ՉηीฝΒ(I)ϐቷϣບᘐᆶႣٛߥᎦ՛ܺᏔ ODMSȐOn-site Diagnostics/Maintenance
Serverȑ ᆶηीฝΟϐӃ຾ᇙำ௓ڋᆶӄय़ᐒѠਏ౗ໆෳ՛ܺᏔ AOSȐAPC/OEE Serverȑ фૈ౽෌Ε
ҁ൪ΕԄኳಔޑёՉ܄ϩ݋Ƕ
ODMS ᆶ AOS ஒ཮౽෌ԿӵკѤ΢ъ೽܌Ңϐ Embedded Agent ϣႣ੮ޑ Application 1 ᆶ
Application 2 ޑѦ೽ำԄޜ໔Ƕځ౽෌ϐ຾Չ؁ᡯӵΠǺ
1.ዴߥ ODMS ᆶ AOS ӧচس಍୺Չ҅தคᇤǶ
2.ஒ ODMS ᆶ AOS ϐ Java চۈำԄዸ࿼Ε Embedded AgentǶ
3.ᔠࢗ Embedded Agent ܌٬Ҕϐ JVM ϐހҁጓဦࢂց΋ठǴऩጓဦό΋ठǴሡӆ຾΋؁ᔠࢗٿঁό
ӕϐ JVM ހҁࢂցӧၗ਑ࠠᄊ (data types) ΢Ԗ܌ৡ౦ǶӢࣁ౦፦܄բ཰ѳᆵ໔ޑၗ਑ߏࡋ཮Ӣբ཰
س಍ᆶฯᡏόӕԶԖ܌ৡ౦ǴӢԜѸ໪଺ၗ਑ࠠᄊޑᔠࢗǶ
4.অׯ ODMS ᆶ AOS ϐচۈำԄዸǴஒ ODMS ᆶ AOS ܌ᝩ܍ϐচ Web Service Agent ׯԋᝩ܍Ծ
Device Communication Manager ܌ගٮϐϟय़Ǵ٠ख़ཥጓ᝿চۈᔞǶ
5.ჴբ Device Communicating Manager ϐ ODMSInterface ϟय़Ƕ
6.ෳ၂౽෌ࡕϐ ODMS ᆶ AOS ࢂցૈჹϣ࿶җ Device Communication Manager ޑ EE Data
Collection ϟय़ௗԏ EE DataǶ
7.ෳ၂౽෌ࡕϐ ODMS ᆶ AOS ࢂցૈჹѦ೸ၸ Device Communication Manager ϣޑ Web Service
Agent ϟय़ᆶᆛၡ΢ޑځѬኳಔҬೱǶ
ЬᚒΜΒǺ຾Չҁ೯Ҕࠠ൪ΕԄኳಔϐ SoC ࢎᄬޑ೛ीຑ՗
ҁηीฝ܌ࡌᄬᆶჴբֹԋϐ೯Ҕࠠ൪ΕԄس಍Ьाࢂӧ SBC ΢୺ՉǴ٠Ӹܫܭזଢ૶ᏫᡏύǶࣁΑ
ёаӧόӕೀ౛Ꮤࢎᄬύ୺Չҁس಍Ǵҁηीฝஒ຾ՉځѬ SoC ှ،Бਢޑࣴ᠐ᆶຑ՗Ǵа଺ࣁࡕុࣴ
زीฝޑୖԵ٩ᏵǶ
ऩሡाଞჹόӕ SoC ࢎᄬ଺س಍অׯǴΨஒ཮٩ྣΠӈѤ໨চ߾຾ՉǺ
1.а Web Service ࣁ୷ᘵϐ൪ΕԄس಍೛ीࣁ҂ٰ൪ΕԄس಍ޑᖿ༈ǴӢԜஒᆢ࡭а Web Service ࣁЬ
ϐࢎᄬ[27][28]Ƕ
2.Եໆаж౛ΓᏤӛำԄ೛ी (agent-oriented programming) ှ،ୢᚒǴж౛ΓᏤӛำԄ೛ीࢂှ،ϩණ
Ԅୢᚒޑ΋ঁᖿ༈ǴӢԜ҂ٰё൩೭Бय़຾Չ׳ుΕޑࣴز[29][30][31][32]Ƕ
3.คጕᆛၡ (wireless) ޑᔈҔςВᅌ੻ՉǴӕਔҁЬ࡭Γ܌ॄೢޑԋεᇙ೷܌Ծ୏ϯჴᡍ࠻ΨԖคጕᇻ
ᆄ௓ڋמೌޑڀᡏԋ݀ǴӢԜ҂ٰёԵໆуΕԜ೛ी[31]Ƕ
4. Embedded Web Server ޑᢀۺς໒ۈ೏ቶࣁௗڙǴӢԜ Embedded Agent ϝஒߥ੮চԖޑ Embedded
Web Server ೛ीǶᔈҔΑ Embedded Web Server ޑמೌǴஒё٬೛ഢᇙ೷୘׳ૈזೲӦว৖ᆶගٮܰ
Ҕޑკ׎ϯ٬Ҕޣϟय़๏࠼Њ[32]Ƕ
ЬᚒΜΟǺ΢ጕෳ၂Ϸ܄ૈຑ՗ᆶКၨ
ନΑֹԋ΢ॊϐπբѦǴҁीฝҭρֹԋΠӈයтᆶࣴ૸཮ፕЎϐว߄ᆶ׫ዺǺ
1. යтፕЎ
[1] F.-T. Cheng, G.-W. Huang, C.-H. Chen, and M.-H. Hung, "A Generic Embedded Device for Various
Customized Applications of Intelligent Maintenance Systems," submitted to Computers in Industry.
[2] F.-T. Cheng, S.-L. Wu, H.-C. Yang, P.-Y. Tsai, and Y.-T. Chung, "Application Cluster Service Scheme for
Near-Zero-Downtime Services," submitted to IEEE Transactions on Systems, Man, and Cybernetics, Part A.
[3] Y.-C. Su, F.-T. Cheng, M.-H. Hung, and H.-C. Huang, "Intelligent Prognostics System Design and
Implementation," IEEE Transactions on Semiconductor Manufacturing, vol. 19, no. 2, pp. 195-207, May
2006.
2. ࣴ૸཮ፕЎ
[1] F.-T. Cheng, G.-W. Huang, C.-H. Chen, and M.-H. Hung, "A Generic Embedded Device for Retrieving and
19
[20] SEMI Draft Doc.#3510, Provisional Specification for Equipment Services Description, U.S.A.,
2002.
[21] Open-source real-time Linux implementations.
http://www.linuxdevices.com/articles/AT8073314981.html
[22] RTAI. http://www.aero.polimi.it/projects/rtai
[23] E. Bianchi, L. Dozio, G.L. Ghiringhelli, P. Mantegazza, "Complex Control Systems, Applications of
DIAPM-RTAI at DIAPM," Realtime Linux Workshop Vienna 1999.
[24] E. Bianchi, L. Dozio, "Some Experiences in Fast Hard Realtime Control in User Space with RTAI-LXRT,"
Realtime Linux Workshop Orlando, 2000.
[25] G. Quaranta, P. Mantegazza, "Using MATLAB-Simulink RTW to Build Real Time Control Applications in
User Space with RTAI-LXRT," Realtime Linux Workshop Milano 2001.
[26] DirectX 8.0 (C/C++) HAL.
http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dx8_c/directx_cpp/graphics_understand_
6z3n.asp
[27] A. Rettberg and W. Thronicke, Embedded System Design based on Webservices, University Paderborn /
C-LAB, 2001.
[28] P. Marwedel, Embedded System Design: Future Trends, the Next Five Years, University of Dortmund, 1999.
[29] P. Steenekamp and J. Roos, "Implementation of Distributed Systems Management Policies: A Framework
for the Application of Intelligent Agent Technology," in Proc. of IEEE International Workshop on System
Management, pp.127-135, 1999.
[30] M. Wooldridge, "Agent-Based Software Engineering," IEEE Proc-Softw. Eng., vol. 144, NO. 1, pp 26-37,
Feb. 1997.
[31] Y.-C. Yang and F.-T. Cheng, "An Autonomous and Universal Remote Control Scheme," in Proc. of The 28th
Annual Conference of the IEEE Industrial Electronics Society (IECON'02), Sevilla, Spain, November 2002.
[32] B. Lloyd and M. Susnik, "Web Embedded Field Devices," Iris Power Engineering Inc., Canada, 2002.
[1] F.-T. Cheng, G.-W. Huang, C.-H. Chen, and M.-H. Hung, "A Generic
Embedded Device for Various Customized Applications of Intelligent
Maintenance Systems," submitted to Computers in Industry.
Re
vie
w 
Co
py
2
1. Introduction 
According to the history of remote control [1], the first radio-controlled motorboat was 
invented by German military in World War I. During World War II, remote-controlled 
weapons were widely used. In the post-war period, many American scientists researched on 
adopting electromagnetic wave in the application of remote control. In the late 40’s, the first 
remote-controlled lid of trashcan was come out into public. Afterward, the first 
infrared-controlled television was successfully made and commercialized by Zenith 
Electronic Co. in 1950. In 1952, Zenith further developed Lazy Bones, which is a long cord 
connecting to TV set. And then, the wireless remote controller with push buttons was 
developed.  
Nowadays, in the surrounding of our living, almost every IA has its own dedicated 
remote controller, such as air conditioner, TV, DVD player, audio player, etc. Likewise, 
with the development of IAs, people are going to have more and more remote controllers 
and have to make themselves familiar with more and more complicated operations. 
According to the description of traditional remote controllers mentioned above, one 
remote controller is for one device only. We would probably see some remote controllers 
that can control two or three different kinds of devices in the market. The design for this 
kind of controller is to implement all of the control codes and I/O hardware of different 
devices in the multi-functional remote controller. Therefore, due to the implementation 
constraints, the types of the devices controlled by this kind of multi-functional remote 
controller cannot be various, or the required storage capacity of the remote controller will 
be huge, and the I/O hardware setup will be difficult. To solve these problems, we propose 
the autonomous and generic remote control scheme, as depicted in Fig. 1, which provides a 
generic remote controller (GRC) and multiple generic embedded controllers (GECs) for 
being embedded into controlled devices. When someone would like to remotely control a 
device via Wireless Interface, he/she can use GRC to acquire the context information about 
I/O control template, and control codes from the desired device, then GRC will present 
them to I/O display panel. As such, users can remotely control the device through this I/O 
display panel. If users wish to apply GRC to remotely control another device, they can 
simply utilize GRC to download different set of context information from the designated 
device; meanwhile, the original context information will be wiped out. By this means, the 
storage device of GRC for reserving control codes will be no longer necessary; as well, the 
I/O hardware setup is easy to be implemented, and the devices can be various from types 
and numbers. 
The autonomous and generic remote control scheme contains two basic elements, the 
GRC and the device with an embedded GEC. The descriptions for these two elements are 
as follows. 
2 of 17
Monday , July  19, 2004
Elsevier
Re
vie
w 
Co
py
4
The rest of this paper is organized as follows. Section 2 describes the system 
requirements of the autonomous and generic remote control scheme. Section 3 presents the 
object-oriented analysis and design. Section 4 introduces the system implementation. The 
summary and conclusions are finally made in Section 5 followed by the abbreviation list 
and references.  
2. System Requirements  
The two key components of the autonomous and generic remote control scheme are 
Generic Embedded Controller (GEC) and Generic Remote Controller (GRC). Their 
functional requirements are described below.  
2.1 Functional Requirements of Generic Embedded Controller (GEC)
The main functions of GEC are: (1) to periodically publish universally unique 
identifier (UUID), (2) to deliver the context information, (3) to translate GRC commands 
and send them to the controlled device, and (4) to transmit controlled device’s responses to 
GRC. The key words, UUID and Context, used by GEC are defined as follows.  
 UUID 
UUID is a set of generic and unique codes for identifying a specific controlled device.  
GRC can locate GEC and utilize GEC’s internal services via UUID.  
 Context 
The context information describes GEC’s I/O template and the communication 
protocol to and from GRC. This context information is stored in GEC. GEC is able to pass 
the context information to GRC wirelessly based on GRC’s request.   
2.2 Functional Requirements of Generic Remote Control (GRC)
GRC is a portable and wireless device that possesses the autonomous and generic 
remote control scheme. The main functions of GRC are: (1) to recognize the UUID sent by 
GEC, (2) to request GEC to publish the context information, (3) to receive and translate the 
context information, (4) to receive commands input by the user and pass to GEC, and (5) to 
receive the responses from GEC and display them. 
4 of 17
Monday , July  19, 2004
Elsevier
Re
vie
w 
Co
py
6
Actors that interact with the autonomous and generic remote control scheme are: 
 User: the user of GRC, i.e. the one who operates GRC.
 Controlled Device: the information device that is controlled by GRC.
Use cases of the autonomous and generic remote control scheme include:  
1. Publish UUID: GEC possesses the capability of periodically publishing UUID for 
GRC recognition purpose.  
2. Recognize UUID: GRC can recognize the UUID.  
3. Load Context: After the recognition of UUID has been completed, GRC will make 
connection with GEC and send out the request for loading the context information.  
4. Publish Context: As receiving the request context message from GRC, GEC will 
publish the context information to GRC.
5. Send Command and Receive Reply: A user sends commands via GRC and GEC to the 
controlled device and receives replies through the connection interfaces.  
6. Receive Command and Send Reply: The device receives commands via GEC and 
GRC from users, and send replies through the connection interfaces.  
7. Communicate: Both GRC and GEC rely on wireless communication interface for 
message exchanging.  
According to the use cases described above, the associated sequence diagrams are designed 
as follows. 
3.2 Sequence Diagrams 
 Use Case 1: Publish UUID 
As shown in Fig. 3, when GEC is initiated, GEC publishes UUID by invoking 
publishUUID() of UUID Publisher, and then UUID is sent to GRC by calling 
sendUUID() of Communication Driver, passUUID() of Wireless Interface, and 
publishUUID() of GRC.
6 of 17
Monday , July  19, 2004
Elsevier
Re
vie
w 
Co
py
8
 Use Case 3웛Load Context 
Referring to Fig. 5, after receiving UUID form UUID Recognizer, Context Loader
sends the request-context message to GEC via Communication Driver and Wireless 
Interface by invoking sendRCMsg() and passRCMsg(). Then, GEC delivers the context 
information to Context Loader through Wireless Interface and Communication Driver by 
calling receiveContextInfo() and passContextInfo(). Finally, Context Loader processes the 
context information by invoking processContextInfo() and displays them on User Interface
by calling displayContext().
GRC: UUID
Recognizer
GRC: Context
Loader
GRC: Communication
Driver
GRC: Wireless
Interface
GRC: User
Interface GEC
sendUUID()
sendRCMsg()
passContextInfo()
processContextInfo()
displayContext()
passContextInfo()
passRCMsg()
receiveContextInfo()
sendRCMsg()
Figure 5: Load Context Sequence Diagram of GRC
 Use Case 4웛Publish Context 
As illustrated in Fig. 6, GRC sends the request-context message to GEC’s Context 
Publisher via GEC’s Wireless Interface and Communication Driver by invoking 
sendRCMsg() and passRCMsg(). Then, Context Publisher prepares the context information 
by calling prepareContextInfo() and sends them back to GRC.
8 of 17
Monday , July  19, 2004
Elsevier
Re
vie
w 
Co
py
10
 Use Case 6: Receive Command and Send Reply (GEC)
As shown in Fig. 8, GRC sends commands to GEC’s Device Interface via GEC’s
Wireless Interface and Communication Driver. Then, GEC’s Device Interface passes these 
commands to Controlled Device. Controlled Device, then, performs the associated process 
by invoking processCommand(). After the process, Controlled Device sends the reply 
message, if any, back to GRC via GEC’s Device Interface, Communication Driver, and 
Wireless Interface.
GEC: Wireless
Interface GEC: Communication Driver GEC: DeviceInterfaceGRC Controlled Device
sendReplyMsg()
passReplyMsg()
passReplyMsg()
processCommand()
sendReplyMsg()
passCommand()
passCommand()
passCommand()
sendCommand()
Figure 8: Receive Command and Send Reply Sequence Diagram of GEC
 Use Case 7: Communication
GRC and GEC communicate with each other via wireless communication interface. In 
this work, we adopt the technologies of IrDA [7] with IEEE802.11b wireless protocol 
Internet and bluetooth to build the prototypes of wireless communication interface.   
3.3 Class Diagrams 
The class diagrams of the autonomous and generic remote control scheme are depicts 
in Figs. 9 and 10 in accordance with the requirement analysis, use case diagrams, and 
sequence diagrams. Observing Fig. 9, UUID Publisher starts publishing UUID to GRC by 
invoking sendUUID() of Communication Driver and passUUID() of Wireless Interface
after GEC has been initiated. When receiving the request-context message sent by GRC via 
10 of 17
Monday , July  19, 2004
Elsevier
Re
vie
w 
Co
py
12
sendUUID()
passContextInfo()
processContextInfo()
Context Loader
passUUIDMsg()
recognizeUUID()
UUID Recognizer
passUUIDMsg()
sendRCMsg()
passContextInfo()
sendCommand()
passReplyMsg()
Communication Driver
publishUUID()
passRCMsg()
receiveContextInfo()
passCommand()
sendReplyMsg()
Wireless Interface
Send Request-Context
Message to
/ Receive Context Information from
Send Command to
/ Receive Reply form
Communicate with
Send UUID to
displayContext()
keyInCommand()
displayReplyMsg()
User Interface
Send UUID
message to
Keyin Command
Display Context on
User
Figure 10: Class Diagram of GRC
4. System Implementation 
Two wireless communication interfaces, IrDA and bluetooth, are used for prototype 
implementation in this work.  Please refer to [8][9] for the implementation of IrDA 
interface. The implementation of bluetooth interface is described as follows. 
The implementation of bluetooth interface follows the system-on-chip development 
procedure [10][11]. This system development procedure includes the development of 
software and hardware. Furthermore, the software portion consists of embedded operating 
system (OS) [12] and applications. 
4.1 System Architecture and Implementation 
The system layouts of GRC and GEC by applying bluetooth with embedded Linux 
[13] are shown in Fig. 11. As depicted in Fig. 11(a), the physical layer of GRC consists of 
Bluetooth, Display, and PS/2 Input. Among these, Bluetooth is the communication interface, 
Display is in charge of display and user interface, and PS/2 Input is for data input by means 
of using mouse or touch panel. As for the OS kernel layer, it is constructed by Linux Kernel 
2.4.x, which has a built-in protocol stack [14] of bluetooth. Then, in the J2ME profile & 
12 of 17
Monday , July  19, 2004
Elsevier
Re
vie
w 
Co
py
14
5. Summary and Conclusions
Owing to the development and innovation of information technologies and 
semiconductor manufacturing technologies, information devices can be easily found around 
us. Moreover, the technologies of wireless communication make the applications of 
information devices to an extreme. The autonomous and generic remote control scheme can 
be developed as a dedicated universal remote controller, or can be embedded into 
commercial wireless devices, such as PDAs or mobile phones. Only one autonomous and 
generic remote controller is needed for controlling various information devices, such as car 
[21], alarm system, television, air conditioner, manufacturing equipment, medical 
instrument, etc. 
Two prototypes of the autonomous and generic remote control scheme, using IrDA and 
bluetooth, have been successfully constructed and demonstrated at the Institute of 
Manufacturing Engineering, National Cheng Kung University, Tainan, Taiwan, R.O.C. 
Thus, the feasibility of this proposed scheme has been verified. We expect that the 
autonomous and generic remote control scheme can be applied to various fields of 
applications, such as IAs [22][23], manufacturing automation [24], medical automation [25], 
etc. In the future, we can further apply system-on-chip technology to implement many 
kernel functions into chips. Thus, GRC of different functions can be well developed for 
improving the degree of automation and convenience to various fields; by this way, the 
quality of human life can be widely improved.   
14 of 17
Monday , July  19, 2004
Elsevier
Re
vie
w 
Co
py
16
References 
[1] J. Moyer, P. Ott, and D. Pearson, “History of the Remote Control”, 
http://www.modellbahnott.com/tqpage/ihistory.html, Jan. 1999. 
[2] ANSI/IEEE Std. 802.11B, IEEE, 1999. 
[3] Bluetooth SIG, Specification of the Bluetooth System Profiles Version 1.1, Feb. 2001. 
[4] Bluetooth SIG, Specification of the Bluetooth System Core Version 1.1, Feb. 2001. 
[5] K.V.S.S.S.S. Sairam, N. Gunasekaran, and S.R. Redd, “Bluetooth in Wireless 
Communication,” in Communications Magazine, IEEE, vol. 40, issue 6, pp. 90-96, 
June 2002. 
[6] OMG, UML Home Page, http://www.uml.org/ , 1997.
[7] D. W. Suvak, P. J. Megowan, L. Young, T. Kondo, M. Esashi, M. Matsumoto, R. 
SAITO, and P. Nykanen, “Infrared Data Association - IrCOMM: Serial and Parallel 
Port Emulation over IR (Wire Replacement) ”, IrDA, Nov. 1995. 
[8] Y.-C. Yang and F.-T. Cheng, “An Autonomous and Universal Remote Control 
Scheme, ” in Proc. of The 28th Annual Conference of the IEEE Industrial Electronics 
Society (IECON’02), Sevilla, Spain, pp. 2266-2271, Nov. 2002. 
[9] Y.-C. Yang, “Autonomous and Universal Remote Control Scheme”, Master Thesis, 
National Cheng Kung University, Tainan, Taiwan, R.O.C., 2003. 
[10] ALTERA Nios Embedded Processor System Development, 
http://www.altera.com/products/devices/nios/nio-index.html
[11] Institute of Microelectronics, “SYSTEM DESIGN/SOC”, 
http://www.ime.org.sg/soc/soc_intro.htm, Jan. 2001. 
[12] “Real Time and Windows Embedded”, 
http://www.microsoft.com/windows/Embedded/community/experto/july2002/nframpto
n.asp
[13] The Linux Kernel Archives, http://www.kernel.org/
[14] Official Linux Bluetooth Protocol Stack, http://bluez.sourceforge.net/
[15] Sun MicroSystems, J2ME Technology, http://java.sun.com/j2me/
[16] JCP-EC, JSR-62 Personal Profile Specification, JSR, 18 Sep. 2002. 
[17] JCP-EC, JSR-82 Java APIs for Bluetooth, JSR, 22 Mar. 2002. 
16 of 17
Monday , July  19, 2004
Elsevier
[2] F.-T. Cheng, S.-L. Wu, H.-C. Yang, P.-Y. Tsai, and Y.-T. Chung, "Application
Cluster Service Scheme for Near-Zero-Downtime Services," submitted to IEEE
Transactions on Systems, Man, and Cybernetics, Part A.
21.  Introduction 
The international technology roadmap for semiconductors (ITRS) states that total 
allowable scheduled and non-scheduled down time of a factory information and 
control system (FICS) ranged from 240 min for 2003 to 120 min for 2007 [27]. This 
requirement means that the availability of the FICS should exceed 0.9998 (1-120 
min/(365x24x60 min)). That is, the services provided by FICS should have 
near-zero-downtime performance. Generally, the services include application 
programs and computer systems that provide operating environments for applications. 
Consequently, if continuous services of application programs are required, their 
supporting computer systems must also be healthy. 
This study proposes an application cluster service (APCS) scheme with the 
capabilities of failover and state recovery such that application programs under the 
control of the APCS can provide more reliable services. The APCS has an efficient 
and concise failure-detection mechanism (also known as a heartbeat mechanism). A 
software architecture scheme for state recovery is also provided by the APCS. If a 
backup application program requires state recovery to resume normal operations, then 
this program can simply inherent this scheme to gain the state recovery capability. 
Furthermore, a performance evaluator (PEV) that may detect performance 
degradation and predict time to failure of a node is developed in this work. To simply 
the computer-performance-monitoring problem, this work only considers the factors 
related to software aging [23]. Combining APCS with PEV and using the detection 
and prediction capabilities of the PEV, the APCS can perform the failover process 
before an application program or a node breakdown. Consequently, a distributed 
computer system can provide services with near-zero-downtime by applying 
APCS+PEV. 
The rest of this paper is organized as follows. Section 2 surveys some related 
work. Section 3 details the APCS scheme. Section 4 then introduces the PEV scheme. 
Next, Section 5 presents considerations for deploying the APCS and PEV. 
Subsequently, Section 6 shows comparisons of APCS+PEV with Microsoft cluster 
service (MSCS) and APCS. Section 7 then describes the availability analysis for 
applying APCS+PEV. Next, Section 8 introduces an illustrative example of 
implementing the APCS and PEV in a manufacturing execution system. Finally, 
conclusions are made in Section 9. 
4(OSCAR), Leangsuksun et al. [11] proposed adopting component redundancy and 
developing a detailed failure-repair model for predicting the availability. However, the 
proposed scheme has only one standby server to backup the primary server; and 
instead of the entire application level failover, this study only considers the failover of 
several key components. 
Several investigations [12] [13] [14] have developed methods and tools for 
increasing application program reliability and recoverability. These methods/tools can 
enhance the reliability of single application programs. 
In the field of improving overall distributed system reliability, Osman and 
Bargiela [15] proposed a fault tolerant environment for open distributed computing 
(FADI). FADI can detect the occurrence of errors by monitoring user-process failures 
and node crashes. FADI also presented a non-blocking checkpoint mechanism, 
combined with a selective message logging technique, to perform backup and 
recovery operations for distributed processes. However, the proposed system does not 
prepare spare nodes to replace the faulty ones. Therefore, if faulty nodes cannot be 
repaired, their mission may not be fulfilled. 
The Object Management Group (OMG) submitted a request for proposal (RFP) 
for fault-tolerant CORBA (FT-CORBA) using entity redundancy [16] for three 
detective levels (object, process, and host levels) in CORBA 3 specification [17]. This 
RFP addresses the need for standard CORBA functionality to support fault-tolerant 
applications, such that the clients of these applications are largely insulated from such 
details as managing redundant copies, masking failures, and recovery. The 
FT-CORBA specification defines a standard set of interfaces, policies, and services 
that robustly support highly reliable applications. Based on FT-CORBA, Natarajan et 
al. [18] devised the DOORS framework, which is implemented as a CORBA service, 
to provide end-to-end application-level fault tolerance. In FT-CORBA, FaultDetectors 
are CORBA objects that detect faults via either pull-based or push-based mechanisms. 
The pull-based monitoring mechanism periodically polls applications to determine 
whether their objects are alive. The push-based monitoring mechanism (also known as 
a heartbeat monitor) requests that applications send periodic heartbeats to the 
FaultDetector. However, neither mechanism can detect application performance 
degradation. Logging and recovery mechanisms in FT-CORBA enable the backup 
object to replace the primary object for failure recovery in the case of primary object 
malfunction. However, this scheme is a one-to-one backup scheme. The specific 
primary object can only be replaced with the dedicated backup object. In this case, n 
backup objects are required to ensure failure recovery with n primary objects. 
6will be explained in Section 3.1.1. Following N successive inquiries without response, 
most likely the Master is down. The Slave then notifies all of the other Slaves to also 
start investigating the existence of the Master. If more than half of the Slaves have the 
same result: “following N successive inquiries without response”, then it is considered 
certain that the Master is down. Subsequently, the failed Master is excluded from the 
cluster and all of the Slaves will enter a reconfiguring state to select a new Master.
Finally, the replacement process for the Master is launched. The entire failover 
scheme involves five steps as follows. 
Figure 1: Cluster Environment Using APCS. 
1) Establishing Cluster Environment 
All nodes to be included into the cluster environment must register at a specific 
group, after which their node IDs are assigned, and their APCS service data are stored 
in the shared storage. 
2) Invoking Applications and Commencing Detecting 
Users can invoke a local application via the local APCS, or can invoke a remote 
application by notifying the node that contains this specific application to do so. After 
invoking an application, the state of the application stored in the shared storage is 
updated as “UP”. The associated APCS then begins detecting the status of the 
application.
Other Nodes … 
Node 1 
Other Nodes … 
Cluster Environment
. .
CORBA ORB
Node 3 
. .
Node 2
. .
Node 4
. .
Shared
Storage
CORBA ORB
OS API OS API
OS API OS API
FSM
FSM
FSM
FSM
App N  
SASSR
App 1  
SASSR
App N  
SASSR
App 1  
SASSR
App N  
SASSR
App 1 
SASSR
App N  
SASSR
App 1 
SASSR
APCS
APCS APCS
APCS
85) Node Replacement 
Node replacement includes Slave replacement and Master replacement, as 
explained below. 
Slave Replacement
After a Slave breakdown is confirmed, the Master stops sending heartbeats to the 
Slave, notifies all of the other nodes about the breakdown of the Slave, updates the 
state of the Slave in the shared storage to “DOWN”, and excludes this failed Slave
from the cluster. Then, the Master selects a healthy Slave by checking the information 
in the shared storage and notifies the backup Slave to continue providing application 
services of the failed Slave.
Master Replacement
Once the failure of the Master is confirmed, the first Slave that discovered the 
failure updates the state of the failed Master to “DOWN” in the shared storage and 
excludes the failed Master from the cluster. Then, all of the Slaves will enter a 
reconfiguring state to select a new Master. During the reconfiguring state, each of the 
nodes checks its starting time, which is stored in the shared storage. The earliest 
starting node is selected as the Master. The new Master then starts sending heartbeats 
to all of the Slaves, and each Slave initiates its timer and waits for the arrival of 
heartbeats. Furthermore, the new Master checks the status stored in the shared storage 
for applications originally provided by the failed Master. Those applications are 
recovered by backup applications residing in other nodes via the application recovery 
process described in Step 3. 
The failover scheme of APCS is implemented by FSM that includes a node event 
listener, fault detector, application manger, and several Ap agents, as depicted in Fig. 
2. The functions of the FSM modules are outlined as follows. 
z The node event listener receives all of the messages sent from all of the other 
nodes, and distributes the messages to the fault detector or resource manager. 
z The fault detector mainly handles the tasks of fault detection and node 
replacement, as stated in Steps 4 and 5 of the failover scheme, respectively. After 
performing node replacement, the fault detector forwards a request to the 
application manager to execute the fault recovery process of applications. 
z The application manager is primarily concerned with the tasks of invoking 
applications and application replacement, as described in Steps 2 and 3 of the 
failover scheme. The application manager is in charge of the entire Ap agents 
10
Consequently, if we choose three for N, then the time required for replacing the 
Master is 10.705+4.397+3*2+3*2=27.102 < 30 sec. Therefore, for the above design 
considerations, the value of N is assigned to be three for this typical example. Of 
course, different design considerations will result in a different value of N. 
3.2 State Recovery Scheme and Its Software Architecture 
Two types of state recovery, namely independent state recovery and dependent 
state recovery, are considered here. These types of state recovery are defined below.  
z Independent State Recovery  
During initialization the backup application creates all of the objects that need 
state recovery. Therefore, this type of state recovery is independent of object creation.  
z Dependent State Recovery 
Following initialization, the backup application may not create all of the objects 
that require state recovery. Those objects may be created and/or deleted depending on 
the process state. Consequently, the dependent state recovery scheme must create 
related objects based on the status of the application before failure occurrence. In this 
case, the state recovery process may then proceed if a failure occurs.   
 A software architecture scheme for state recovery (SASSR) is developed to 
facilitate state recovery operations. Figure 3 shows that SASSR consists of a 
Command Pattern [22] [31] and a Memento Pattern [22] [32]. They are described 
below. 
Command Pattern [22] [31] is used to encapsulate a request as an object, thereby 
letting you parameterize clients with different requests, queue or log requests, and 
support undoable operations. Figure 3 shows that participants of the SASSR 
Command Pattern include: Application, StateMgr, SR_Object, aObject, and 
aMemento.
 Memento Pattern [22] [32] is used to achieve that backup and recover object’s 
internal state without violating encapsulation, capture and externalize an object's 
internal state so that the object can be restored to this state later. Figure 3 depicts that 
participants of the SASSR Memento Pattern include: Memento, aMemento, StateMgr, 
and aObject.
12
creates objects that exist prior to occurrence of failure and need state recovery based 
on the parameters stored in the shared storage. Besides, aStateMgr should also 
implement a virtual ToContiExe() that access the associated parameters stored in the 
shared storage and invoke the transition function of the backup application to enter 
the state where the failed application left off.   
aObject (of an Application) that needs the functions of state backup and recovery 
should inherit SR_Object, register at aStateMgr, and implement a virtual BackupState()
and a virtual RecoverState(). aStateMgr will invoke BackupState() to inform aObject
the backup states. BackupState() must construct its (aObject) own aMemento object, 
which inherits Memento to handle the packing functions of object states, and call 
aMemento::BackupStateValue() to pass the backup states to the aMemento object. 
Then, the aMemento object is sent to aStateMgr and aStateMgr invoke 
aMemento::SaveToFile() to save the backup states into the shared storage. 
 Similarly, aStateMgr will call RecoverState() to inform aObject the backup states. 
These backup states are retrieved from the shared storage by aStateMgr and stored in 
a newly-built aMemento object. This aMemento object is then passed to the aObject.
After receiving the aMemento object, the aObject invoke 
aMemento::RecoverStateValue() to retrieve the backup state values to recover 
aObject’s states.  
Each aObject in an Application must have its own specific aMemento object. For 
example, aObject_1 of an Application must have its corresponding aMemento_1
object:
class aMemento_1:public Memento 
{
    friend  aObject_1 ; 
};
As shown above, aObject_1 is aMemento_1’s friend class. It means that only 
aObject_1 can invoke aMemento_1’s private methods; and aMemento_1 must protect 
the stored state’s values from being accessed by the other aObjects. This preserves 
aObject_1’s encapsulation. When aObject_1 is informed by aStateMgr to backup its 
states, aObject_1 will construct aMemento_1 and store aObject_1’s states into 
aMemento_1. Then, aStateMgr and aMemento_1 will take over to proceed with the 
remaining backup process. Figure 4 illustrates the detailed state backup and recovery 
processes, which are described as follows. 
14
(a) Backup Process 
(b) Recovery Process 
Figure 4:  Sequence Diagrams of State Backup and Recovery. 
aObject 1 : aObject n : aMemento 1 : aMemento n : aStateMgr :  : Shared  : Application
SR_Object SR_Object Memento MementoStateMgr Storage
BackupObjState( )
BackupState( )
BackupState( )
BackupStateValue( )
Return aMemento_1
Return aMemento_n
SaveToFile( )
SaveToFile( )
Save Object States to Shared Storage
Save Object States to Shared Storage
BackupTFParamValue( )
Save Parameter Values to Shared Storage
BackupStateValue( )
…. ….
 : A pp l i c a ti on a O b je ct 1  :  
S R_ O b j e ct
a O b je ct n  : 
S R_ O b je ct
a M e m e nto  : 
M e m e n to
a S ta te M g r  : 
S ta te M g r
 : S h a re d  
S to ra g e
T o Cre a te S RO b j ( )
G e t Da ta  sto ra g e d  i n  S h a re d  S to ra g e  fo r cre a ti n g  O b j e cts
Re co ve rO b j S ta te ( )
Re a d Fro m Fi l e ( )
Cre a te  a O b je ct_ 1
Cre a te a O b je ct_ n
Re co ve rS ta te V a l u e ( )
Re a d  S ta te  V a lu e s fro m  S h a re d  S to ra g e
Re co ve rS ta te V a l u e ( )
T o Co n tiE xe ( ) Re a d  P a ra m e te r V a lu e s fro m  S h a re d  S to ra g e
Co n tiE xe ( )
R egis terO b jec t ( )
R eg is terO bj ec t ( )
Re co ve rS ta te ( )
Re co v e rS ta te ( )
Cre a te  a M e m e n to
….
16
Initial Active Sick Dead
Inactive
1 2 4
6
5
37
Figure 6: State Diagram of a Node. 
Table 1: State Transition Table of a Node. 
Number Current State Trigger  
New 
State 
1 Initial Initialization complete Active
2 Active Available resources being less than thresholds Sick 
3 Active Service being paused Inactive
4 Sick Available resources being exhausted Dead 
5 Dead Repair complete Initial 
6 Sick Available resources back to normal Active
7 Inactive Service being resumed Active
Fuzzifier Defuzzifier
XProcessor_Time
XPrivileged_Time
XPool_Nonpaged_bytes
XAvailable_Mbytes
YState_Index
Inference
Engine
Fuzzy Rule 
Base
μ(
Av
ai
lab
le_
M
by
te
s)
μ(
Pr
oc
es
so
r_
Ti
m
e)
μ(
Pr
ivi
le
ge
d_
Ti
m
e)
μ(
Po
ol_
No
np
ag
ed
_B
yt
es
)
μ(
St
at
e_
In
de
x)
 Figure 7: Fuzzy Logic Detection Module for Inferring the State_Index. 
Microsoft Windows 2000 technical information [24] states that computer 
performance monitoring includes evaluating memory and cache usage, analyzing 
processor activity, examining and tuning disk performance, and monitoring network 
performance. To simplify the computer-performance-monitoring problem, this work 
only considers the factors related to software aging [23]. Software aging describes the 
accumulation of errors during software execution, eventually resulting in crash/hang 
failure. Gradual performance degradation may also accompany software aging. The 
major factors related to software aging are processor and memory. According to the 
18
Figure 9: Output Membership Functions of State_Index. 
The fuzzy module shown in Fig. 7 converts four input parameters into a single 
State_Index. This fuzzy module contains 40 fuzzy rules to infer the value of the 
State_Index by the input values of available Mbytes, pool nonpaged bytes arising 
percentage, privileged time, and processor time. For example, one of the rules for 
inferring that a computer is in the sick state is listed below: 
IF Available MBytes is low and Pool Nonpaged Bytes Arising Percentage is high
and Privileged Time is high and Processor Time is high Then State_Index is sick.
z Prediction Module 
When the detection module detects that a node is in the sick state, the prediction 
module is launched to predict the time to failure. A typical example of a 
monotonic-decay failure mode is that virtual memory expands monotonically. If the 
symptom of virtual memory expansion cannot be cured, this computer will be crashed 
when the size of virtual memory reaches a certain threshold. If a failure mode of 
software aging with monotonic-decay property is assessed, then the corresponding 
mean time to failure (MTTF) can be evaluated as follows. 
 Figure 10 shows three curves for predicting the MTTF of a monotonic-decay 
software-aging system, where t and y denote time and remaining resources, 
respectively. Statistically, if the relationship between y and t can be represented by a 
simple linear-regression equation: 
ty  10 EE                               (1) 
where 0E  and 1E  are the coefficients in Eq. (1). Then, with enough samples: (ti, yi), 
i=1, 2, …, n, the first curve that represents the simple linear-regression relationship 
between the estimations of y, 0E , and 1E  (they are yˆ , 0Eˆ , and 1Eˆ , respectively),
and t can be formulated as [25]: 
20
ty 10 ˆˆˆ EE  
y
t
yS
LBDt ,ˆ MTTFDt ,ˆ UBDt ,ˆSt
yD
UByˆ
LByˆ
LBTˆ
MTTFTˆ
                                    
UBTˆ
0
),( SS yt
Figure 10: Estimation Curves for Predicting Mean Time to Failure. 
As mentioned in Section 3, the APCS possesses fault-detection and failover 
capabilities. However, the fault-detection scheme of APCS can only detect a failure 
when this failure has occurred. Therefore, the failover process can only proceed after 
a failure has been encountered. This results in a discontinuous service. Because the 
PEV has the capability of predicting the time-to-failure of a sick node, integrating 
PEV with APCS may provide continuous services, which is the subject of the 
following sub-section. 
4.1 Integrating PEV with APCS
Figures 1, 2, and 5 illustrated the cluster environment using the APCS, the block 
diagram of FSM in the APCS, and the architecture of the PEV, respectively. To 
integrate the PEV with the APCS, the PEV is to substitute for the Master and all the 
other nodes serve as Slaves. Each node implements a data collector of the PEV. 
Additionally, the functions of the heartbeat mechanism provided by the fault detector 
of FSM are no longer needed; while the other functions of FSM are still required. The 
deployment of the APCS and the PEV is demonstrated in Section 5. 
22
(a) With APCS 
(b) With APCS and PEV 
Figure 11: Deployment Considerations by Applying APCS and PEV. 
ClientsClientsClientsClient
Network
DataBase 
Shared 
Storage
SCSI
Applications Clients
Master 
Heartbeat
Applications
PEV
(Replace Master)
ClientsClients
Client
Network
DataBase 
Shared
Storage 
SCSI
Clients
Report 
Resource Parameters
'&'DWD&ROOHFWRU
'&
'&
'&
'&
24
7. Availability Analysis for Applying APCS+PEV 
The availability of the APCS+PEV, RA+P, is derived to evaluate the improvement 
of overall system availability. Suppose that a system has N similar nodes with the 
same availability, R, and the clustering system needs M nodes for the system to 
function properly. In this case, N-M backups are involved. Assume that the reliability 
of PEV is RPEV. Then, RA+P can be expressed as [19]: 
(2)
The availability of the original system without any backup is R0=RM. Therefore, the 
improvement of the availability is RA+P-R0.
Table 3 tabulates the availability improvement with M=1 and RPEV=1. Table 3 
shows that N=2 is required for R=0.99, N=3 for R=0.98, and N=4 for R=0.95 to 
guarantee that the RAPCS exceeds or equals 0.9999. If a mirror-type backup is prepared 
for the PEV and the reliability of each node of this mirror-type PEV is 0.99, then  
RPEV = 0.99Θ0.99 + (1-0.99)Θ0.99 + 0.99Θ(1-0.99) = 0.9999.
Consequently, we have:  
RA+P = RPEVΘRAPCS  = 0.9999Θ0.9999 = 0.9998. 
Table 3: Availability Improvement with M=1 and RPEV=1.
0.9 0.95 0.98 0.99
N=2 0.09 0.0475 0.0196 0.0099 
N=3 0.099 0.049875 0.019992 0.009999 
N=4 0.0999 0.04999375 0.01999984 0.00999999 
The international technology roadmap for semiconductors (ITRS) states that the 
scheduled and non-scheduled down time of a FICS ranges from 240 min for 2003 to 
120 min for 2007. The requirement mentioned above means that the availability of the 
FICS should exceed 0.9998. From the above analysis, if only one healthy node is 
required for proper FICS functioning, then for R=0.99 a total of four nodes (two for 
APCS, and two for PEV) are required to ensure that the FICS has 0.9998 availability. 
¦C N i (1-R)i RN-i ) =RPEVΘRAPCS
N - M
i=0
RA+P RPEV Θ (
26
Performance Evaluation of SASSR
Performance evaluation of SASSR is executed by using this illustrative example. 
The personal computers with memory sizes applied for Node 1, Node 2, and 
shared-storage servers are P4 1.4G (512M), P4 1.4G (512M), and P4 1.8G (512M), 
respectively. Initially, Node 2 serves as Master and Node 1 as Slave. Microsoft 
Windows 2000 SP4 is adopted as the operating system for Node 1, Node 2, and 
shared-storage servers. The shared-storage server also installs Microsoft SQL 2000. 
The network bandwidth is 100M bits per sec.  
WIP tracking (WT) application program is selected as the evaluation sample. The 
performance evaluation results of SASSR for WT are tabulated in Table 4. The file 
size for maintaining the state values of a typical WT object is about 1.6K bytes. 
However, in this evaluation, 10K bytes are assigned for tolerance consideration. The 
number of WT objects depends on the number of WIPs [33]. In general, WIPs of a 
production line may vary from 0 to 1000. Therefore, the numbers of objects are 
assigned to be 10, 250, 500, 750, and 1000 for evaluation. 
Table 4 shows that, the backup time increases linearly with the number of objects. 
Typically, for 500 objects, it takes about 10.705 sec to accomplish the entire backup 
process. Three cases are tested for evaluating recovery times. Case 1 assumes that 
only the WT application program is down, while Node 1 and Node 2 are still up. Case 
2 assumes that WT is installed and running in a Slave node and the Slave node is 
down. Case 3 assumes that WT is installed and running in the Master node and the 
Master node is down. As expected, the recovery time increases as the number of 
objects increases. The recovery time of Case 1 is less than that of Case 2 because 
Case 1 doesn’t need to swap the failed Slave node. The recovery time of Case 3 is 
higher than that of Case 2 because Case 3 needs to re-elect a new Master. Finally, the 
reason of the backup time is longer than the recovery time is mainly due to the fact 
that the data-storing time is longer than the data-retrieving time of the shared-storage 
server. 
Table 4: Performance Evaluation of SASSR. 
 No. of Objects 10 250 500 750 1000
Backup Time (S) WT Object State Size = 10 KB 0.21 5.298 10.705 16.150 21.591
 Case 1 (WT Down Only) 0.11 1.633 3.526 5.388 7.610
 Case 2 (Slave Node Down) 0.13 2.063 3.755 5.848 7.842Recovery Time (S) 
 Case 3 (Master Node Down) 0.35 2.504 4.397 6.309 8.342
28
failover and state recovery schemes. The second scheme applies both the APCS and 
the PEV. The PEV can detect whether a node is sick or not. Moreover, if a node is sick, 
the PEV may also forecast its time to failure. Consequently, the heartbeat mechanism 
is not required for the scheme applying the APCS+PEV. Because the PEV can predict 
the time to failure of a sick node and notify the APCS of the backup node to perform 
failover process before the node’s breakdown, near-zero-downtime services can be 
guaranteed.
References 
[1] E. Marcus and H. Stern, Blueprints for High Availability: Designing Resilient 
Distributed Systems, NY: John Wiley & Sons, February 2000. 
[2] F. Piedad and M. Hawkins, High Availability: Design, Techniques And 
Processes, NJ: Prentice Hall. 2001. 
[3] Clustering Center.com, PC Cluster, Clustering Center.com. [Online]. Available: 
http://www.clusteringcenter.com/
[4] HA Cluster, High Availability Center.com. [Online]. Available:  
http://www.highavailabilitycenter.com/
[5] W. Vogels, D. Dumitriu, K. Birman, R. Gamache, M. Massa, R. Short, J. Vert, J. 
Barrera, and J. Gray, “The Design and Architecture of the Microsoft Cluster 
Service—A Practical Approach to High-Availability and Scalability,”in Proc.
28th Symp. Fault-Tolerant Computing, CS Press, 1998, pp. 422-431. 
[6] R. Gamache, R. Short, and M. Massa, “Windows NT Clustering Service,” 
Computer, vol. 31, no. 10, pp.55-62, Oct. 1998. 
[7] PolyServe, Matrix HA/Server, PolyServe Corporation. [Online]. Available: 
http://www.polyserve.com/
[8] H. Sun, J. J. Han, and H. Levendel, “Availability Requirement for a 
Fault-Management Server in High-Availability Communication Systems,” 
IEEE Transactions on Reliability, vol. 52, no. 2, pp. 238-244, June 2003. 
[9] K. Shen, T. Yang, and L. Chu, “Clustering Support and Replication 
Management for Scalable Network Services,” IEEE Transactions on Parallel 
and Distributed Systems, vol. 14, no. 11, pp.1168-1179, Nov. 2003. 
[10] M.-S. Kim, M.-J. Choi, and J.-W. Hong, “Highly Available and Efficient Load 
Cluster Management System Using SNMP and Web,” in Proc. of the 
IEEE/IFIP Network Operations and Management Symposium (NOMS 2002),
30
Symposium on Software Reliability Engineering, pp. 282-292, Paderborn, 
Germany, November 1998. 
[24] Performance Monitoring, Microsoft. [Online]. Available: 
http://www.microsoft.com/resources/documentation/windows/2000/professiona
l/reskit/en-us/part6/proch27.mspx
[25] N. Draper and H. Smith, Applied Regression Analysis, USA: Wiley-Interscience, 
3rd edition, 1998. 
[26] P. J. Brown, Measurement, Regression, and Calibration. USA: Oxford University 
Press, 1994. 
[27] ITRS, Factory Integration - International Technology Roadmap for 
Semiconductors, 2003 edition, September 2003. 
[28] Microsoft Cluster Service Installation Resources, Microsoft. [Online]. Available: 
http://support.microsoft.com/default.aspx?scid=kb;en-us;Q259267&id=25926
7&SD=MSKB.
[29] G. Coulouris, J. Dollimore, and T. Kindberg, Distributed Systems Concepts and 
Design, Addison-Wesley, 2001. 
[30] Microsoft Development Network, Microsoft. [Online]. Available: 
http://msdn.microsoft.com/library/default.asp?url=/library/en-us/counter/count
ers1_zugs.asp
[31] Command Pattern, Design Pattern. [Online]. Available:  
http://www.dofactory.com/Patterns/PatternCommand.aspx
[32] Memento Pattern, Design Pattern. [Online]. Available:  
http://www.dofactory.com/Patterns/PatternMemento.aspx
[33] F.-T. Cheng, C.-F. Chang, and S.-L. Wu, “Development of Holonic 
Manufacturing Execution Systems,” Journal of Intelligent Manufacturing, vol.
15, no. 2, pp. 253-267, April 2004. 
[34] Microsoft Cluster Service 2003, Microsoft. [Online]. Available: 
http://www.microsoft.com/windowsserver2003/evaluation/overview/technolog
ies/clustering.mspx
[35] Internet Time Service, NIST. [Online]. Available: http://tf.nist.gov/service/its.htm







[1] F.-T. Cheng, G.-W. Huang, C.-H. Chen, and M.-H. Hung, "A Generic
Embedded Device for Retrieving and Transmitting Information of Various
Customized Applications," in 2004 IEEE International Conference on Robotics
and Automation, New Orleans, LA, USA, pp.978-983, April 2004.



Application Cluster Service Scheme for 
Near-Zero-Downtime Services1
Fan-Tien Cheng,2 Shang-Lun Wu, Ping-Yen Tsai, Yun-Ta Chung 
Institute of Manufacturing Engineering 
National Cheng Kung University 
Tainan, Taiwan, R.O.C. 
Haw-Ching Yang 
Institute of Systems and Control Engineering 
National Kaohsiung 1st U of Science and Technology
 Kaohsiung, Taiwan, R.O.C. 
Abstract - The required reliability in applications of a 
distributed computer system is continuous service for 24 
hours a day, 7 days a week. However, computer failures due 
to exhaustion of operating system resources, data corruption, 
numerical error accumulation, and so on, may interrupt 
services and cause significant losses. Hence, this work 
proposes an application cluster service (APCS) scheme. The 
proposed APCS provides both a failover scheme and a state 
recovery scheme for failure management. The failover scheme 
is designed mainly to automatically activate the backup 
application for replacing the failed application whenever it is 
sick or down. Meanwhile, the state recovery scheme is 
intended primarily to provide an inheritable design pattern to 
support applications with state recovery requirements. An 
application simply needs to inherit and implement this design 
pattern, and then can accomplish the task of state backup 
and recovery. Furthermore, a performance evaluator (PEV) 
that can detect performance degradation and predict time to 
failure is developed in this study. By using these detection and 
prediction capabilities, the APCS can perform the failover 
process before node breakdown. Thus, applying APCS and 
PEV can enable a distributed computer system to provide 
services with near-zero-downtime. 
Index Terms – Application cluster service (APCS), failover 
scheme, state recovery scheme, performance evaluator (PEV), 
near-zero-downtime service. 
I. INTRODUCTION
The international technology roadmap for semiconductors 
(ITRS) states that total allowable scheduled and non-scheduled 
down time of a factory information and control system (FICS) 
ranged from 240 min for 2003 to 120 min for 2007. This 
requirement means that the reliability of the FICS should exceed 
0.9998. That is, the services provided by FICS should have 
near-zero-downtime performance. Generally, the services include 
application programs and computer systems that provide 
operating environments for applications. Consequently, if 
continuous services of application programs are required, their 
supporting computer systems must also be healthy. 
To improve reliability, high availability cluster service 
schemes of computer systems are often proposed. High 
availability clustering technology [1] [2] was presented to 
automatically detect node failures during service processes. Upon 
detecting application program failure, the cluster service will 
launch a backup application program to continue providing 
application services from the point where the malfunctioning 
application program left off. Several commercial products, such 
                                                     
1 The authors would like to thank the National Science Council of the Republic of China for  
financially supporting this research under Contracts No. NSC-91-2622-E-006-019 and 
NSC-93-2212-E-006-022. 
2 The corresponding author. (e-mail: chengft@mail.ncku.edu.tw).
as Microsoft Cluster Service (MSCS)[3], Matrix HA and Matrix 
Server of PloyServe[4], etc., can provide such cluster service 
schemes. However, the failure detection mechanisms (also 
denoted as the heartbeat mechanisms) of the above schemes are 
complicated, and private networks are required for implementing 
these mechanisms. 
Shen et al. [5] designed and implemented the Neptune 
middleware system that provides clustering support and 
replication management for scalable network services. Neptune 
employs a loosely connected and functionally symmetric 
clustering architecture to achieve high scalability and robustness. 
This architecture shields the clustering complexities from 
application developers through simple programming interfaces. 
Additionally, Neptune provides replication management with 
flexible replication consistency support at the clustering 
middleware level. However, the replication management scheme 
of Nepture periodically replicates the state values to all of the 
nodes in the clustering system. Accordingly, the communication 
burden associated with the backup of state values will be rather 
high if the number of nodes exceeds three. 
Kim et al. [6] presented a Load Cluster Management 
System (LCMS). LCMS follows the client-server management 
paradigm of the simple network monitoring protocol (SNMP),
and consists of three managers with different roles, which 
distribute management functionality to all hosts in a cluster 
group. By using SNMP these managers can reduce the network 
bandwidth required in management operations. However, LCMS 
is only capable of fault detection and does not consider either 
application failover or state recovery. 
To improve the availability of Open Source Cluster 
Application Resources (OSCAR), Leangsuksun et al. [7] 
proposed adopting component redundancy and developing a 
detailed failure-repair model for predicting the availability. 
However, the proposed scheme has only one standby server to 
backup the primary server; and instead of the entire application 
lever failover, this study only considers the failover of several 
key components. 
Several investigations [8] [9] have developed methods and 
tools for increasing application program reliability and 
recoverability. Nevertheless, these methods/tools can only 
enhance the reliability of single application programs. These 
methods/tools cannot improve the reliability of computer systems 
that possess several object-oriented application programs, and nor 
are they capable of state recovery. 
In the field of improving overall distributed system 
reliability, Osman and Bargiela [10] proposed a fault tolerant 
environment for open distributed computing (FADI). FADI can 
detect the occurrence of errors by monitoring user-process 
failures and node crashes. FADI also presented a non-blocking 
checkpoint mechanism, combined with a selective message 
logging technique, to perform backup and recovery operations for 
distributed processes. However, the proposed system does not 
prepare spare nodes to replace the faulty ones. Therefore, if faulty 
Proceedings of the 2005 IEEE
International Conference on Robotics and Automation
Barcelona, Spain, April 2005
0-7803-8914-X/05/$20.00 ©2005 IEEE. 4062
z Ap agents are governed by the application manger. An Ap 
agent can only monitor and control an application. An Ap 
agent can invoke, detect, and close an application by using 
OS API, and then reports the application status to the 
application manger. 
2.2 State Recovery Scheme and Its Design Pattern 
A design pattern for state recovery (DPSR) is developed to 
facilitate state recovery operations,. Figure 3 shows that DPSR 
consists of one “Memento” pattern [15]: Memento, and two 
“Command” patterns [15]: SR_Object and StateMgr. These 
patterns are presented below. 
Figure 3 shows that, in the application layer, aStateMgr
should be implemented by inheriting StateMgr. aObject that 
needs the functions of state backup and recovery should inherit 
SR_Object and register at aStateMgr. When a state backup 
process is required, aStateMgr will ask aObject to create an 
aMemento object that inherits Memento to handle the packing 
functions of object states. aStateMgr then stores the object state 
values from aMemento to the shared storage. Meanwhile, when a 
state recovery process commences, aStateMgr first creates the 
necessary aObjects based on the status stored in the shared 
storage. Next, aStateMgr creates an aMemento to retrieve the 
object state values from the shared storage. Finally, the object 
state values are distributed to the corresponding aObjects by the 
aMemento. The detailed state backup and recovery processes are 
described in [20].   
III. PEV SCHEME
The PEV is designed to detect whether a node is in a sick 
state or not by monitoring and evaluating the system resource 
parameters of the node. If a node is in a sick state, the PEV can 
also predict the time to failure of the node. Figure 4 illustrates 
the architecture of the PEV, which consists of several data 
collectors, the detection module, and prediction module. These 
three modules are detailed below. 
z Data Collector 
A data collect resides at each node for collecting system 
resource parameters via OS API. These parameters are then 
passed to the PEV by CORBA specification. 
z Detection Module 
Before introducing the detection module, the state diagram 
of a node is presented, as shown in Fig. 5. The state diagram 
includes five states: initial, active, inactive, sick, and dead. Table 
1 lists the corresponding state transition table of the state 
diagram. Generally, a node is in the active state. However, when 
available resources are below the thresholds (due to software 
aging [16] for example), the node enters the sick state. The node 
returns to the active state if the available resources are recovered. 
On the contrary, if the available resources are exhausted, the node 
enters the dead state or, restated, the node is down. The above 
description demonstrates that the major purpose of the detection 
module is to detect whether or not a node is in a sick state. 
Therefore, as shown in Fig. 6, the fuzzy logic detection module is 
applied to infer a State_Index from the major resource 
performance parameters.  
Table 1: State Transition Table of a Node. 
Number Current State Trigger  
New
State
1 Initial Initialization complete Active
2 Active Available resources being less than thresholds Sick
3 Active Service being paused Inactive
4 Sick Available resources being exhausted Dead
5 Dead Repair complete Initial
6 Sick Available resources back to normal Active
7 Inactive Service being resumed Active
Failover Service Manager
Fault Detector
Ap Agent
1
Ap Agent
2
Ap Agent
N
Application Manager
Node Event Listener
...
App 1 App 2 App N
OS API
...
F
S
M
F
S
M
C
O
R
B
A
O
R
B
C
O
R
B
A
O
R
B
Figure 2: Block Diagram of Failover Service Manager. 
Performance   Evaluator
Prediction Module
Detection Module
Node
OS API
Data
Collector
Node
OS API
Data
Collector
C
O
R
B
A
C
O
R
B
A
Figure 4: Architecture of Performance Evaluator (PEV). 
Initial Active Sick Dead
Inactive
1 2 4
6
5
37
Figure 5: State Diagram of a Node 
Memento
SaveToFile()
ReadFromFile()
BackupStateValue()
RecoverStateValue()
SR_Object
BackupState()
RecoverState()
StateMgr
RegisterObject()
BackupObjState()
RecoverObjState()
BackupTFParamValue()
ContiExe()
ToCreateSRObj()
ToContiExe()
aMemento
aObject
1
1
create
aStateMgr
1
1
create
1..n 1Manage
Register
Design 
Pattern 
Application 
Layer 
Figure 3: Design Pattern for State Recovery Scheme. 
4064
Figure 8(b) illustrates that the Master node is replaced by 
the PEV and each of the other nodes still needs to implement the 
APCS due to failover and state recovery considerations. Besides, 
each node must own a data collector that obtains the required 
resource parameters and sends them to the PEV for health 
monitoring. 
V. COMPARISONS OF APCS+PEV WITH APCS AND MSCS 
 The traditional high availability clustering service was 
provided by MSCS. Table 2 lists the comparisons of APCS+PEV 
with APCS and MSCS. Basically the MSCS requires dedicated 
shared storage for each group of resources. This dedicated shared 
storage is different from the system database. On the other hand, 
the APCS and APCS+PEV do not require dedicated shared 
storage. The APCS and APCS+PEV can apply the system 
database to serve as the shared storage. Owing to this difference, 
MSCS is more costly to install. Each node using the MSCS 
broadcasts its heartbeat to all the other nodes in a group; while 
the heartbeat mechanism of the APCS only allows the Master
node to send a heartbeat to the Slave nodes. Clustering services 
utilizing the APCS+PEV do not require a heartbeat mechanism. 
The MSCS requires a private (node to node) network to support 
the heartbeat mechanism, while the APCS applies a public 
(cluster to client) network to send heartbeats. The APCS+PEV 
does not require a private network either. The MSCS has no state 
recovery scheme; while the APCS and APCS+PEV do have state 
recovery schemes. Both the MSCS and the APCS do not have the 
capabilities of node sickness detection and time-to-failure (TTF) 
prediction. If the clustering service integrates the PEV with the 
APCS, then the health of individual nodes can be monitored. 
Furthermore, if the PEV detects that a node is in the sick state, 
the PEV can also predict the time to failure of this sick node and 
ask the APCS to perform failover operations before node 
breakdown. Accordingly, continuous services with near-zero 
downtime can be assured. 
Table 2: Comparisons of APCS+PEV with APCS and MSCS. 
MSCS APCS APCS+PEV
Dedicated Shared 
Storage Needed No Need No Need
Heartbeat
Mechanism 
Broadcasting by 
 Each Node 
Only Send by 
Master No Need
Private Network Needed No Need No Need
State Recovery No Yes Yes 
Sickness Detection & 
TTF Prediction No No Yes 
VI. RELIABILITY ANALYSIS FOR APPLYING APCS+PEV 
The reliability of the APCS+PEV, RA+P, is derived to 
evaluate the improvement of overall system reliability. Suppose 
that a system has N similar nodes with the same reliability, R, and 
the clustering system needs M nodes for the system to function 
properly. In this case, N-M backups are involved. Assume that the 
reliability of PEV is RPEV. Then, RA+P can be expressed as [14]:  
(2)
The reliability of the original system without any backup is 
R0=RM. Therefore, the improvement of the reliability is RA+P-R0.
Table 3 tabulates the reliability improvement with M=1 and 
RPEV=1. Table 3 shows that N=2 is required for R=0.99, N=3 for 
R=0.98, and N=4 for R=0.95 to guarantee that the RAPCS exceeds 
or equals 0.9999. If a mirror-type backup is prepared for the PEV 
and the reliability of each node of this mirror-type PEV is 0.99, 
then Table 3 shows that the RPEV is 0.9999 (N=2). Consequently, 
we have: 
RA+P=RPEVΘRAPCS=0.9999Θ0.9999=0.9998. 
Table 3: Reliability Improvement with M=1 and RPEV=1. 
 0.9 0.95 0.98 0.99 
N=2 0.09 0.0475 0.0196 0.0099
N=3 0.099 0.049875 0.019992 0.009999
N=4 0.0999 0.04999375 0.01999984 0.00999999
The ITRS states that the scheduled and non-scheduled 
down time of a FICS ranges from 240 min for 2003 to 120 min 
for 2007. The requirement mentioned above means that the 
reliability of the FICS should exceed 0.9998. From the above 
analysis, if only one healthy node is required for proper FICS 
functioning, then for R=0.99 a total of four nodes (two for APCS, 
and two for PEV) are required to ensure that the FICS has 0.9998 
reliability. 
VII. ILLUSTRATIVE EXAMPLE
 Figure 9 presents an illustrative example for a 
IC-packaging factory involving two nodes, several pieces of 
¦C N i (1-R)i RN-i ) =RPEVΘRAPCS
N - M
i=0
RA+P RPEV (
ClientsClientsClientsClient 
Network 
DataBase  
Shared 
Storage 
SCSI 
Applications Clients
Master 
Heartbeat 
(a) With APCS 
Applications
PEV
(Replace Master) 
ClientsClients
Client 
Network 
DataBase  
Shared 
Storage 
SCSI 
Clients
Report 
Resource 
Parameters 
'& 'DWD&ROOHFWRU
'&
'&
'&
'&
(b) With APCS and PEV 
Figure 8: Deployment Considerations by Applying APCS and PEV. 
4066
[3] J. Chang and F.-T. Cheng, "Framework Development of an
Engineering-Chain-Management-System for the Semiconductor Industry," in
Proc. the 3rd International IEEE Conference on Industrial Informatics –
INDIN’05, Perth, Western Australia, August 2005.




2ഌǵ (΋ )ǵҁਢࡰۓж߄კࣁǺಃ 1 კ
(Β )ǵҁж߄კϐϡҹж߄಄ဦᙁൂᇥܴǺ
1 0 0Ǻ೯Ҕࠠ൪ΕԄး࿼
1 1 0Ǻၗૻ໺ᒡᆅ౛ޣ
1 1 2Ǻᘏڗϟय़
1 1 4Ǻ೯ૻж౛ޣ
1 1 6ǺᔈҔϟय़
1 2 0Ǻၗ਑ᘏڗޣ
1 2 2ǺᘏڗीჄϡҹ
1 2 4Ǻး࿼០୏Ꮤ
1 3 0ǺᔈҔኳಔ
1 4 0Ǻ೛ഢ !
1 5 0ǺѦ೽س಍
!
ࢠǵҁਢऩԖϯᏢԄਔǴፎඟҢനૈᡉҢวܴ੝ቻ
ޑϯᏢԄǺ
!
4Ⴃٛ܄ޑঅ҅ϷᆢៈǶฅԶǴඵችࠠᆢៈس಍ύЈ܌ගр
ϐ I M S ᘏڗ೛ഢၗૻޑࢎᄬ٠҂Եቾኳಔϯᆶฯᡏৡ౦
܄ǴӢԜჹܭೱ่όӕၗૻ೛ഢޑ౽෌ૈΚৡǴЪ҂மፓ
ၗૻϐᆅ౛ᆶ໺ଌᐒڋǹI M S!ϐ !D e v i c e - t o - B u s i n e s s  ( D 2 B )
ѳᆵ҂மፓჹѦуᔈҔኳಔޑᘉк܄ǴӢԶόܰᆶӚԄ೛
ഢฯᡏϟय़ҬೱǴᜤаཥቚѦуޑᔈҔኳಔǶԜѦǴඵች
ࠠ ᆢ ៈ س ಍ ύ Ј ٠ ҂ ග ٮ ኱ ྗ ϯ ޑ ၗ ૻ ᘏ ڗ ᆶ ໺ ଌ ᐒ
ڋǴ೷ԋ೛ी΢࣬྽εޑ֚ᘋǶ !
Ӣ ԜǴߚதሡाว৖р΋ᅿёᘏڗک໺ଌ࠼ᇙϯᔈҔ
ϐၗૻޑ೯Ҕࠠ൪ΕԄး࿼ᆶБݤǴᙖаᙁߡӦೱ่ܭӚ
ᅿόӕၗૻ೛ഢǹ٬ҔނҹϯБԄ೛ीޑ໒ܫϟय़Ǵаှ
، ᘉ к ܄ ޑ ୢ ᚒ ǹ а Ϸ ु ۓ ኱ ྗ ϯ ޑ ၗ ૻ ᘏ ڗ ᆶ ໺ ଌ Б
ݤǴа೯Ҕܭᘏڗک໺ଌӚᅿၗૻ೛ഢޑၗૻǶ !
Ȝ วܴϣ৒ȝ
ҁ ว ܴ ϐ ΋ Ҟ ޑ ൩ ࢂ ӧ ග ٮ ΋ ᅿ ё ᘏ ڗ ک ໺ ଌ ࠼ ᇙ
ϯᔈҔϐၗૻޑ೯Ҕࠠ൪ΕԄး࿼ᆶБݤǴᙖа٬ڀԖԖ
ጕ܈คጕϐҬೱϟय़ޑၗૻ೛ഢǴૈԖᘏڗᆶ໺ሀӚᅿ࠼
ᇙϯᔈҔϐၗૻޑૈΚǶ
ҁ ว ܴ ϐ Ξ ΋ Ҟ ޑ ൩ ࢂ ӧ ග ٮ ΋ ᅿ ё ᘏ ڗ ک ໺ ଌ ࠼
ᇙϯᔈҔϐၗૻޑ೯Ҕࠠ൪ΕԄး࿼ᆶБݤǴаှ،ಞޕ
ϐ ၗ ૻ ᘏ ڗ ำ Ԅ ѝ ૈ ፾ Ҕ ܭ ൂ ΋ ၗ ૻ ೛ ഢ ܈ ੝ ۓ ฯ ᡏ ޑ
લᗺǶ
ҁ ว ܴ ϐ Ξ ΋ Ҟ ޑ ൩ ࢂ ӧ ග ٮ ΋ ᅿ ё ᘏ ڗ ک ໺ ଌ ࠼
ᇙϯᔈҔϐၗૻޑ೯Ҕࠠ൪ΕԄး࿼ᆶБݤǴᙖаճҔނ
6Ҕϟय़Ƕ !
ќ ѦǴਥᏵҁวܴϐ΢ॊҞޑǴගр΋ᅿёᘏڗک໺
ଌ࠼ᇙϯᔈҔϐၗૻޑБݤǴᙖаᘏڗǵԏ໣ǵᆅ౛ᆶϩ
݋ၗૻ೛ഢϐၗૻǶ
٩ྣҁวܴϐၨ٫ჴࡼٯǴԜБݤԿϿхࡴǺගٮٯ
Ѧ೯ޕำׇǴځύԜٯѦ೯ޕำׇ߯җ೛ഢЬ୏วрٯѦ
( E x c e p t i o n )ૻ৲Ǵ٠࿶җ೯Ҕࠠ൪ΕԄး࿼ڗளࡕǴӆ໺
ଌ๏ᔈҔኳಔ܈Ѧ೽س಍ǹගٮۓයᔠᡍำׇǴځύԜۓ
යᔠᡍำׇ߯җᔈҔኳಔวрϐၗૻᘏڗፎ؃Ǵ೯Ҕࠠ൪
ΕԄး࿼ਥᏵၗૻᘏڗፎ؃ٰᘏڗ೛ഢϐၗૻࡕǴӆ໺ଌ
๏ᔈҔኳಔǹаϷගٮၗૻࢗ၌ำׇǴځύԜၗૻࢗ၌ำ
ׇ߯җѦ೽س಍วрϐၗૻࢗ၌ፎ؃Ǵ೯Ҕࠠ൪ΕԄး࿼
ਥᏵၗૻࢗ၌ፎ؃ٰᘏڗ೛ഢϐၗૻࡕǴ೸ၸ೯Ҕࠠ൪Ε
Ԅး࿼ϐ೯ૻж౛ޣӣᙟ๏Ѧ೽س಍Ƕ
ӢԜǴᔈҔҁวܴǴё೯Ҕܭᘏڗک໺ଌӚᅿၗૻ೛
ഢޑၗૻǹёڀԖཥቚߕуᔈҔኳಔޑᘉк܄ǹёᙁߡӦ
ᔈҔܭӚᅿၗૻ೛ഢ܈ฯᡏǹё٬Ҕ኱ྗϯޑၗૻᘏڗᆶ
໺ଌำׇǴٰᘏڗک໺ଌӚᅿၗૻ೛ഢޑၗૻǶ !
Ȝ ჴࡼБԄȝ
ҁวܴϐ೯Ҕࠠ൪ΕԄး࿼ ( G E D )х֖Βε೽ҽǺҗ
൪ Ε Ԅ ջ ਔ բ ཰ س ಍ ( E m b e d d e d  R e a l - T i m e  O p e r a t i n g  
S y s t e mǹ R T O S )܌ࡌᄬޑբ཰ᕉნǹаϷаނҹᏤӛᐒڋ
܌ኗቪЪڀഢၠѳᆵૈΚޑس಍೬ᡏǶҁวܴ߯ӧڀഢջ
ਔ܄ϐ൪ΕԄջਔբ཰س಍ύǴթ࿿س಍೬ᡏǴ٠Ъа΋
8วܴϐ೯Ҕࠠ൪ΕԄး࿼ޑس಍೬ᡏǺ !
ፎ ୖྣಃ 1 კǴಃ 1 კࣁᛤҢҁวܴϐ೯Ҕࠠ൪ΕԄ
း࿼ޑ่ᄬҢཀკǶҁวܴϐ೯Ҕࠠ൪ΕԄး࿼ 1 0 0 ԿϿ
хࡴၗ਑ᘏڗޣ 1 2 0ǹၗૻ໺ᒡᆅ౛ޣ 1 1 0ǹаϷᔈҔኳ
ಔ 1 3 0ǶځύᔈҔኳಔ 1 3 0 ࣁѦуϐ࠼ᇙϯᔈҔኳಔǴၗ
਑ᘏڗޣ 1 2 0 ࣁၗૻԏ໣ᆶᆅ౛ϡҹǴԶၗૻ໺ᒡᆅ౛ޣ
1 1 0 ࣁ೯ૻᆅ౛ϡҹǶၗ਑ᘏڗޣ 1 2 0 ߯җᘏڗीჄϡҹ
1 2 2 کး࿼០୏Ꮤ 1 2 4 ܌ಔԋǶځύᘏڗीჄϡҹ 1 2 2 ॄ
ೢᆅ౛җး࿼០୏Ꮤ 1 2 4 Ծ೛ഢ 1 4 0 ܌ڗளϐ೛ഢၗૻǴ
ᘏ ڗ ी Ⴤ ϡ ҹ 1 2 2 ߯ ᆶ ೛ ഢ 1 4 0 ค ᜢ
( E q u i p m e n t - I n d e p e n d e n t )ǴջᘏڗीჄϡҹ 1 2 2 ёᔈҔܭ
ҺՖၗૻ೛ഢǶး࿼០୏Ꮤ 1 2 4!߯ Ҕ ٰڗள೛ഢ 1 4 0 ޑ
ૻ৲ǴЪᆶ೛ഢ 1 4 0 ࣬ᜢ ( E q u i p m e n t - D e p e n d e n t )ǴջӚᅿ
όӕޑၗૻ೛ഢ໪೛ीԖόӕޑး࿼០୏ᏔǴ٠ёаୖྣ
೛ഢቷ୘ϐϟय़ೕ਱ٰ೛ीး࿼០୏Ꮤ 1 2 4!)ٯ ӵ Ǻًؓ
஑Ҕး࿼០୏ᏔǵъᏤᡏ೛ഢ஑Ҕး࿼០୏Ꮤ฻ *Ƕ җܭ
ၗ਑ԏ໣߯җၗ਑ᘏڗޣ 1 2 0 ϣޑး࿼០୏Ꮤ 1 2 4 ॄೢǴ
း࿼០୏Ꮤ 1 2 4 ߯Ҕٰှ،ᆶჴᡏ೛ഢ 1 4 0 ϐϟय़ྎ೯ୢ
ᚒǴ٠ڗள೛ഢ 1 4 0 ϐၗૻǴԶၗ਑ᘏڗޣ 1 2 0 ϣޑᘏڗ
ीჄϡҹ 1 2 2 ߯ॄೢᆅ౛җး࿼០୏Ꮤ 1 2 4 ܌ᘏڗӣٰޑ
ၗૻǴӢԜᘏڗीჄϡҹ 1 2 2 ёаόѸԵቾӵՖᆶჴᡏ೛
ഢ 1 4 0 ྎ೯Ƕ
ᘏڗीჄϡҹ 1 2 2 ϐϩᜪᆶᆅ౛೛ഢၗૻޑᐒڋё
ࣁٯӵǺਥᏵ೛ഢၗૻ଺фૈय़΢ϐϩᜪǴӵ٣ҹ ( E v e n t )
10
c l a s s  {  
ௗԏٯѦၗૻ ( )<!
ග р ၗ਑ሡ؃ ( )<!
ރ ݩ ൔ֋ ( )<!
ᘏ ڗ ၗ਑ ( )<!
}
ԶᆶᔈҔϟय़ 1 1 6 ࣬ჹᔈϐᔈҔኳಔ 1 3 0 ޑ኱ྗϟय़
фૈೕ਱ӵΠǺ
c l a s s  {  
ϩ݋ٯѦၗૻ ( )<!
ϩ ݋ ၗ਑ ( )<
}
ќѦǴၗૻ໺ᒡᆅ౛ޣ 1 1 0 ሡ೸ၸ೯ૻж౛ޣ 1 1 4Ǵ
ஒ೛ഢ 1 4 0 ޑၗૻ܈ᔈҔኳಔ 1 3 0 ޑϩ݋่݀໺ଌԿѦ೽
س಍ 1 5 0ǴԶѦ೽س಍ 1 5 0 ҭё೸ၸ೯ૻж౛ޣ 1 1 4 ஒࡰ
з໺ଌ຾ٰǶځύ೯ૻж౛ޣ 1 1 4!ё ௦ Ҕ !ٯ ӵǺᙁൂނ
ҹೱ่ڐۓ ( S i m p l e  O b j e c t  A c c e s s  P r o t o c o lǹ S O A P )ޑᆛ
ၡ୍ܺೕጄǴаԖጕ܈คጕޑБԄஒၗૻ໺ଌԿᆛၡϐќ
΋ ᆄ Ƕ ฅ Զ Ǵ ځ д ᆛ ၡ ڐ ۓ ӵ C O R B A  ( C o m m o n  O b j e c t  
R e q u e s t  B r o k e r  A r c h i t e c t u r e ) ǵ D C O M  ( D i s t r i b u t e d  
C o m p o n e n t  O b j e c t  M o d e l ) ܈ R M I  ( R e m o t e  M e t h o d  
I n v o c a t i o n )฻ҭё೏௦ҔǶ !
ӵ ಃ 1 კ܌ҢǴҁวܴϐ೯Ҕࠠ൪ΕԄး࿼ 1 0 0 ύϐ
ӚϡҹၮբࢬำӵΠǺၗ਑ᘏڗޣ 1 2 0 !࿶ җ ځϣ೽ϐး
12
೽س಍ 1 5 0ǴԜᐒڋᆀࣁȨٯѦ೯ޕำׇȩǹҗ೯Ҕࠠ൪
ΕԄး࿼ 1 0 0 ϐѦуޑᔈҔኳಔ 1 3 0 ܌ۓයวрϐၗૻࢗ
၌܈ᔠᡍፎ؃Ǵ೯Ҕࠠ൪ΕԄး࿼ 1 0 0 ਥᏵԜፎ؃ᘏڗ೛
ഢ 1 4 0 ϐૻ৲ࡕǴӆ໺ଌ๏ѦуޑᔈҔኳಔ 1 3 0ǴԜᐒڋ
ᆀࣁȨۓයᔠᡍำׇȩǹҗѦ೽س಍ 1 5 0 ܌วрϐၗૻࢗ
၌܈ᔠᡍፎ؃Ǵ೯Ҕࠠ൪ΕԄး࿼ 1 0 0 ਥᏵѦ೽س಍ 1 5 0
ϐፎ؃ᘏڗૻ৲ࡕǴ೸ၸ೯ૻж౛ޣ 1 1 4 ӣᙟ๏Ѧ೽س಍
1 5 0ǴԜᐒڋᆀࣁȨၗૻࢗ၌ำׇȩǶаΠஒ၁ಒᇥܴԜ
Οεำׇϐמೌಒ࿯Ǻ
1 . ٯѦ೯ޕำׇ !
ፎ ୖྣಃ 2 კǴಃ 2 კࣁᛤҢҁวܴϐٯѦ೯ޕำׇ
ޑࢬำҢཀკǶ྽೛ഢ 1 4 0 วғٯѦރݩਔǴҗ೛ഢ 1 4 0
Ь୏วрૻ৲Ǵ࿶җᘏڗीჄϡҹ 1 2 2 ϩᜪǴӆҗᘏڗ
ϟय़ 1 1 2 ᒧ᏷ஒૻ৲ଌԿᔈҔኳಔ 1 3 0 ೀ౛ࡕǴӆஒރݩ
೯ޕѦ೽س಍ 1 5 0ǹ܈ஒૻ৲ޔௗଌԿѦ೽س಍ 1 5 0Ƕᔈ
Ҕኳಔ 1 3 0 ܈Ѧ೽س಍ 1 5 0 ёଞჹԜૻ৲຾Չჹ೛ഢ 1 4 0
ޑᅱ௓ǵບᘐ܈ᆢঅπբǶځૻ৲ࢬำӵΠǺ !
೛ ഢ 1 4 0 วғٯѦރݩਔǴ೛ഢ 1 4 0 ཮Ь୏วрٯѦ
ૻ৲ (؁ᡯ 2 0 0 )Ƕௗ๱Ǵܭၗ਑ᘏڗޣ 1 2 0 ύǴး࿼០୏
Ꮤ 1 2 4!ᆶ ೛ ഢ 1 4 0 ϐჴᡏฯᡏ ( P h y s i c a l  H a r d w a r e )ϟय़Ҭ
ೱǴԶڗளԜٯѦૻ৲ǹᘏڗीჄϡҹ 1 2 2 ϩᜪᆶၸᘠٯ
Ѧૻ৲ (؁ᡯ 2 1 0 )ԋٯѦၗૻǴ٠ёૈԖΠӈٿᅿރݩǺ !
( 1 )ஒٯѦၗૻଌԿᔈҔኳಔ
!ᘏ ڗीჄϡҹ 1 2 2 ໺ሀٯѦၗૻ (؁ᡯ 2 2 0 )ǴԿၗૻ
14
ਔ໔ (؁ᡯ 3 3 4 )ޑ୏բǴ٠ཥቚᘏڗीฝ (؁ᡯ 3 4 0 )Ƕ !
ᔈ Ҕኳಔ 1 3 0 ֹԋ΢ॊϐሡ؃࣬ᜢૻ৲ޑ໺ሀࡕǴᒿ
ջ໒ۈፎ؃ᘏڗၗ਑ (؁ᡯ 3 0 2 )Ǵ٠೸ၸᔈҔϟय़ 1 1 6 ໺
ሀፎ؃ᘏڗၗ਑ (؁ᡯ 3 1 2 )Ƕௗ๱Ǵ೸ၸᘏڗϟय़ 1 1 2 Կ
ᘏڗीჄϡҹ 1 2 2Ǵ௴୏ၗ਑ᘏڗำׇ (؁ᡯ 3 3 6 )Ƕᘏڗ
ीჄϡҹ 1 2 2 ௗԏډ௴୏ၗ਑ᘏڗำׇϐፎ؃ࡕǴ೸ၸး
࿼០୏Ꮤ 1 2 4!໒ ۈ ᘏڗၗ਑ (؁ᡯ 3 4 2 )ǶฅࡕǴး࿼០୏
Ꮤ 1 2 4!ᆶ ჴ ሞϐ೛ഢ 1 4 0 ޑϟय़ҬೱǴаڗளၗ਑ (؁ᡯ
3 5 0 )ǶᘏڗीჄϡҹ 1 2 2!ڗ ள ೛ഢ 1 4 0 ޑၗ਑ࡕǴஒၗ
਑ϩᜪᆶၸᘠ (؁ᡯ 3 4 4 )Ǵ٠࿶җၗૻ໺ᒡᆅ౛ޣ 1 1 0 ӣ
໺๏ᔈҔኳಔ 1 3 0Ƕ !
ᔈ Ҕኳಔ 1 3 0!ڗ ள ೛ഢ 1 4 0 ޑၗ਑ࡕǴ຾Չ؁ᡯ 3 0 4
аϩ݋ၗ਑Ǵ٠ౢғރݩൔ֋ǴЪගрރݩൔ֋ (؁ᡯ 3 0 6 )
๏ၗૻ໺ᒡᆅ౛ޣ 1 1 0 ϐᔈҔϟय़ 1 1 6ǶฅࡕǴᔈҔϟय़
1 1 6!໺ ሀ ރݩൔ֋ (؁ᡯ 3 1 4 )๏೯ૻж౛ޣ 1 1 4Ƕௗ๱Ǵ
೯ૻж౛ޣ 1 1 4 ໺ሀރݩൔ֋ (؁ᡯ 3 2 0 )๏Ѧ೽س಍ 1 5 0Ƕ!
3 .!ၗ ૻ ࢗ၌ำׇ !
ፎ ୖྣಃ 4 კǴಃ 4 კࣁᛤҢҁวܴϐၗૻࢗ၌ำׇ
ޑࢬำҢཀკǶၗૻࢗ၌ำׇࢂҗѦ೽س಍ 1 5 0 Ь୏ӛ !
೯ Ҕࠠ൪ΕԄး࿼ 1 0 0 วрၗૻፎ؃Ǵ೯Ҕࠠ൪ΕԄး࿼
1 0 0 ᘏڗрѦ೽س಍ 1 5 0 ܌ሡޑૻ৲ࡕӆ໺ӣ๏Ѧ೽س಍
1 5 0Ƕځૻ৲ࢬำӵΠǺ !
Ѧ ೽ س಍ 1 5 0 ೸ၸԖጕ܈คጕᆛၡӛ೯Ҕࠠ൪ ΕԄ
း࿼ 1 0 0 ගрፎ؃ၗૻࢗ၌ޑၗ਑ሡ؃ (؁ᡯ 4 0 0 )Ƕ೯ૻ
16
( 2 )Ѧ೽س಍Ǻ໺ሀރݩൔ֋ ( )ǹ໺ሀٯѦၗૻ ( )Ƕ !
( 3 )ᔈҔϟय़ (ၗૻ໺ᒡᆅ౛ޣޑηϡҹ )ǺௗԏٯѦၗ
ૻ ( )ǹ ග р ၗ ਑ ሡ ؃ ( )ǹ ග р ރ ݩ ൔ ֋ ( )ǹ ፎ ؃ ᘏ
ڗၗ਑ ( )Ƕ !
( 4 )೯ૻж౛ޣ (ၗૻ໺ᒡᆅ౛ޣϐηϡҹ )Ǻ໺ଌሡ؃
࣬ ᜢ ၗ ૻ ( )ǹ ໺ ሀ ރ ݩ ൔ ֋ ( )ǹ ໺ ሀ ٯ Ѧ ၗ ૻ ( )ǹ
ගрၗ਑ሡ؃ ( )ǹ໺ሀፎ؃ᘏڗၗ਑ ( )Ƕ !
( 5 )ᘏڗϟय़ (ၗૻ໺ᒡᆅ౛ޣϐηϡҹ )Ǻ໺ሀٯѦၗ
ૻ ( )ǹ໺ଌሡ؃࣬ᜢၗૻ ( )ǹ໺ሀፎ؃ᘏڗၗ਑ ( )ǹ
يҽ᠘ۓ ( )ǹيҽᇡ᛾ ( )Ƕ !
( 6 )ᘏڗीჄϡҹ (ၗ਑ᘏڗޣϐηϡҹ )Ǻϩᜪᆶၸᘠ
ٯѦૻ৲ ( )ǹ೛ۓၗ਑਱Ԅ ( )ǹ௴୏ၗ਑ᘏڗำׇ
( )ǹ ၗ ਑ ϩ ᜪ ᆶ ၸ ᘠ ( )ǹ ཥ ቚ ᘏ ڗ ी ฝ ( )ǹ ೛ ۓ ኩ
Ӹ୔ ( )ǹ೛ۓଆۈਔ໔ ( )Ƕ !
( 7 )း࿼០୏Ꮤ (ၗ਑ᘏڗޣϐηϡҹ )ǺวрٯѦૻ৲
( )ǹ໒ۈᘏڗၗ਑ ( )Ƕ !
( 8 )ᔈҔኳಔǺϩ݋ٯѦၗૻ ( )ǹϩ݋ၗ਑ ( )Ƕ !
а ΢ ܌ ڋ ۓ ϐ ϟ य़ ф ૈ ೕ ਱ ࣁ Ӛ ϡ ҹ а ނ ҹ Ꮴ ӛ ϐ
БԄ࣬ϕҬೱਔ܌ᔈڀഢϐ୷ҁфૈǴ٠Ъӧόӕޑૻ৲
ᘏڗำׇύڥћǶ
ҁวܴёᔈҔӧӚᅿሦୱǴٯӵǺӧғౢᐒѠ೛ഢϣ
೽ӼးԜ൪ΕԄး࿼Ǵ٬ளёӧҁӦᆄ܈ࢂᇻᆄ຾Չ၀೛
ഢϐᅱ௓ǵࡺምບᘐ܈ᆢঅߥᎦǹӚԄ՛ܺᏔϣӼးԜ൪
ΕԄး࿼Ǵ٬ځҁي܈ࢂᇻᆄس಍ૈ຾ՉჹԜ՛ܺᏔϐࡺ
18
ጕ܈ԖጕᆛၡޑБԄǴӛ೯Ҕࠠ൪ΕԄး࿼ 1 0 0!ڗ ள ၗ
ૻǶҗܭᇙ೷୺Չس಍ 1 7 0ǵᇻᆄບᘐᆢঅ՛ܺᏔ 1 6 0!ᆶ
೛ ഢ 1 4 0 ϣϐ೯Ҕࠠ൪ΕԄး࿼ 1 0 0 ໔Ǵ߯٬Ҕ಍΋ϐٯ
ӵ !S O A P ޑ೯ૻڐۓǴࡺΟޣϐ໔ёа࣬ӕೕ਱ϐ೯ૻ
ж౛ޣ 1 1 4ǵ 1 6 4 ک 1 7 4Ǵ೸ၸҾ཰ϣᆛၡ 1 5 1ǵҾ཰ϣᆛ
ၡ 1 5 2 کᆛሞᆛၡ 1 5 3 ٰϕ࣬೯ૻǶΞǴ೛ഢ 1 4 0 ϐບᘐ
ᆶᆢঅᔈҔኳಔ (ջᔈҔኳಔ 1 3 0 )ё൪Εܭ೯Ҕࠠ൪ΕԄ
း࿼ 1 0 0 ޑϣ೽Ƕ٠ஒ೯Ҕࠠ൪ΕԄး࿼ ( G E D ) 1 0 0 Ӽး
ܭڀ O B E M ϟय़ϐ೛ഢ 1 4 0 ύǴԶԋࣁڀԖ G E D ޑ O B E M
೛ഢ 1 4 4Ƕ
း࿼០୏Ꮤ 1 2 4 ࣁڀഢ  O B E M!ϟ य़ ೕጄǴԶёӸڗ !
O B E M ϟय़ϐ೛ഢ 1 4 0 ϐၗ਑ޑ஑ҔኳಔǶ྽܌టೱ่ϐ
೛ഢ 1 4 0 ޑϟय़ೕ਱ׯᡂਔ (ٯӵǺׯ௦ S E M I ϐ H S M S
ೕጄ )Ǵ߾໻໪׳ඤး࿼០୏Ꮤ 1 2 4ǴԶ೯Ҕࠠ൪ΕԄး
࿼ 1 0 0 ϣ೽ϐځдኳಔࣣόѸख़ཥ೛ी܈׳ඤǶӢԶǴග
ٮ೯Ҕࠠ൪ΕԄး࿼ 1 0 0 ჹܭόӕၗૻ೛ഢ໔ޑଯࡋ౽
෌ૈΚǶ !
྽ ೛ഢ 1 4 0 (ъᏤᡏᐒѠ )วғᒱᇤ܈ٯѦૻ৲ਔǴ೛
ഢ 1 4 0 ൩཮٩ྣӵಃ 2 კ܌ҢϐٯѦ೯ޕำׇǴஒٯѦૻ
৲࿶җၗ਑ᘏڗޣ 1 2 0 ᆶၗૻ໺ᒡᆅ౛ޣ 11 0Ǵ໺ଌ๏ᔈ
Ҕኳಔ 1 3 0Ǵа୺Չບᘐᆶᆢঅޑϩ݋ǶฅࡕᔈҔኳಔ 1 3 0
཮ஒϩ݋ࡕϐރݩൔ֋Ǵ೸ၸၗૻ໺ᒡᆅ౛ޣ 11 0!ϐ ೯
ૻж౛ޣ 1 1 4 ک 1 7 4 ஒރݩ໺ሀ๏ᇙ೷୺Չس಍ 1 7 0 (Ѧ
೽س಍ )Ƕ !
20
ࡕǴ൩཮ᙯଌ๏ၗ਑ᘏڗޣ 1 2 0!ϐ ᘏ ڗीჄϡҹ 1 2 2 ຾
Չၗ਑਱ԄǵኩӸ୔ǵᆶଆۈਔ໔฻೛ۓǴᇻᆄບᘐᆢঅ
՛ܺᏔ 1 6 0 ൩ё໒ۈ೸ၸၗૻ໺ᒡᆅ౛ޣ 11 0!ᆶ ၗ ਑ᘏ
ڗޣ 1 2 0Ǵӛ೛ഢ 1 4 0 ڗள࣬ᜢၗ਑Ƕᇻᆄບᘐᆢঅ՛ܺ
Ꮤ 1 6 0 ӧֹԋၗ਑ԏ໣ࡕǴ൩ёܭບᘐϡҹ 1 6 6 ܈ᆢঅϡ
ҹ 1 6 8 ύ຾Չϩ݋Ƕ΢ॊϐำׇ൩ࢂ܌ᒏޑᆛၡԄບᘐ
( e - D i a g n o s t i c s )ᆶ ᆛ ၡ Ԅ ᆢ অ ( e - M a i n t e n a n c e )ϐ ၗ ૻ ࢗ ၌
ำׇǶ !
җ ΢ॊҁวܴၨ٫ჴࡼٯёޕǴᔈҔҁวܴϐёᘏڗ
ک ໺ ଌ ࠼ ᇙ ϯ ᔈ Ҕ ϐ ၗ ૻ ޑ ೯ Ҕ ࠠ ൪ Ε Ԅ း ࿼ ᆶ ᐒ ڋ ޑ
ᓬᗺࣁǺ௦ڗး࿼០୏ᏔᆶᘏڗीჄϡҹϐΒቫԄࢎᄬǴ
ځύး࿼០୏Ꮤࢂᆶၗૻ೛ഢ࣬ᜢޑኳಔǴԶᘏڗीჄϡ
ҹࢂᆶၗૻ೛ഢคᜢޑኳಔǶࡺ྽܌టೱ่ϐၗૻ೛ഢ׳
ඤਔǴ໻໪׳ඤ࣬ჹᔈϐး࿼០୏ᏔջёǴࡺڀԖόӕၗ
ૻ೛ഢ໔ޑଯࡋ౽෌ૈΚ <ό ӕ ೛ഢޑး࿼០୏Ꮤё٬Ҕ
಍΋኱ྗޑᘏڗीჄϡҹኳಔ <း ࿼០୏ᏔᆶᘏڗीჄϡ
ҹࣁނҹϯמೌ܌ᇙբޑኳಔǴΒঁኳಔ໔аБݤڥћ໺
ሀၗ਑Ǵ٠ЪڀԖ಍΋኱ྗޑϟय़ೕ਱ <း ࿼ ០୏Ꮤҭё
௦Ҕคጕϐ೯ૻೕጄ (ӵᙔ޵฻ )Ǵٰᆶڀഢคጕ೯ૻૈΚ
ϐၗૻ೛ഢҬೱǶ !
ᔈ Ҕ ҁ ว ܴ ϐ ё ᘏ ڗ ک ໺ ଌ ࠼ ᇙ ϯ ᔈ Ҕ ϐ ၗ ૻ ޑ ೯
Ҕࠠ൪ΕԄး࿼ᆶБݤޑΞ΋ᓬᗺࣁǺёБߡӦуΕᘉк
ᔈҔኳಔϐϟय़Ƕ !
ᔈ Ҕ ҁ ว ܴ ϐ ё ᘏ ڗ ک ໺ ଌ ࠼ ᇙ ϯ ᔈ Ҕ ϐ ၗ ૻ ޑ ೯
22
1 2 4Ǻး࿼០୏Ꮤ
1 3 0ǺᔈҔኳಔ
1 4 0Ǻ೛ഢ !
1 4 4ǺڀԖ G E D ޑ O B E M ೛ഢ !
1 5 0ǺѦ೽س಍ !
1 5 1ǺҾ཰ϣᆛၡ !
1 5 2ǺҾ཰ϣᆛၡ !
1 5 3Ǻᆛሞᆛၡ !
1 5 4ǺٛОᕅ !
1 5 5ǺٛОᕅ !
1 6 0Ǻᇻᆄບᘐᆢঅ՛ܺᏔ !
1 6 4Ǻ೯ૻж౛ޣ !
1 6 6Ǻບᘐϡҹ !
1 6 8Ǻᆢঅϡҹ !
1 7 0Ǻᇙ೷୺Չس಍ !
1 7 4Ǻ೯ૻж౛ޣ
2 0 0ǺวрٯѦૻ৲ !
2 1 0ǺϩᜪᆶၸᘠٯѦૻ৲ !
2 2 0Ǻ໺ሀٯѦၗૻ !
2 3 0ǺௗԏٯѦၗૻ !
2 3 2Ǻ໺ሀٯѦၗૻ !
2 4 0Ǻϩ݋ٯѦၗૻ !
2 4 2Ǻ໺ሀރݩൔ֋ !
2 4 4Ǻගрރݩൔ֋ !
24
4 2 0Ǻيҽᇡ᛾ !
4 2 2Ǻ೛ۓၗ਑਱Ԅ !
4 2 4Ǻ೛ۓኩӸ୔ !
4 2 6Ǻ೛ۓଆۈਔ໔ !
4 2 8Ǻ௴୏ၗ਑ᘏڗำׇ !
4 3 0Ǻཥቚᘏڗीฝ !
4 3 2Ǻ໒ۈᘏڗၗ਑ !
4 3 4Ǻၗ਑ϩᜪᆶၸᘠ !
4 4 0Ǻڗளၗ਑
26
၀Ѧ೽س಍ǹаϷ
΋ᔈҔϟय़ ( A p p l i c a t i o n  I n t e r f a c e )ǴҔаॄೢᆶ
၀ᔈҔኳಔҬೱǴځύ၀ᔈҔኳಔ೸ၸ၀ᔈҔϟय़Ǵ
ёڗளҗ၀ၗ਑ᘏڗޣ໺ଌϐ၀ၗૻǶ
2 .ӵҙፎ஑ճጄൎಃ 1 ໨܌ॊϐёᘏڗک໺ଌ࠼ᇙϯ
ᔈҔϐၗૻޑ೯Ҕࠠ൪ΕԄး࿼Ǵځύ၀ᔈҔኳಔ߯΋Ѧ
уϐ࠼ᇙϯޑᔈҔኳಔǶ
3 .ӵҙፎ஑ճጄൎಃ 1 ໨܌ॊϐёᘏڗک໺ଌ࠼ᇙϯ
ᔈҔϐၗૻޑ೯Ҕࠠ൪ΕԄး࿼Ǵځύ၀ᔈҔኳಔ߯Ӽး
ܭ၀೯Ҕࠠ൪ΕԄး࿼ޑϣ೽Ƕ
4 .ӵҙፎ஑ճጄൎಃ 1 ໨܌ॊϐёᘏڗک໺ଌ࠼ᇙϯ
ᔈҔϐၗૻޑ೯Ҕࠠ൪ΕԄး࿼Ǵځύ၀೯Ҕࠠ൪ΕԄး
࿼߯Ӽးܭ၀೛ഢޑϣ೽Ƕ
5 .ӵҙፎ஑ճጄൎಃ 1 ໨܌ॊϐёᘏڗک໺ଌ࠼ᇙϯ
ᔈҔϐၗૻޑ೯Ҕࠠ൪ΕԄး࿼Ǵځύ၀ၗૻ߯೸ၸ၀೯
ૻж౛ޣǴаԖጕ܈คጕϐБԄǴ࿶җ΋ᆛၡ໺ଌ๏၀Ѧ
೽س಍Ƕ
6 .ӵҙፎ஑ճጄൎಃ 5 ໨܌ॊϐёᘏڗک໺ଌ࠼ᇙϯ
ᔈҔϐၗૻޑ೯Ҕࠠ൪ΕԄး࿼Ǵځύ၀ᆛၡᒧԾܭҗ΋
28
ሡ؃ޑфૈǵ΋ගрރݩൔ֋ޑфૈک΋ፎ؃ᘏڗၗ਑ޑ
фૈ܌ಔԋޑ΋ᜪձ ( C l a s s )ኳಔǶ
!
11 .ӵҙፎ஑ճጄൎಃ 1 ໨܌ॊϐёᘏڗک໺ଌ࠼ᇙ
ϯᔈҔϐၗૻޑ೯Ҕࠠ൪ΕԄး࿼Ǵځύ၀ᔈҔኳಔޑ኱
ྗ ϟ य़ ф ૈ ೕ ਱ ࣁ җ ΋ ϩ ݋ ٯ Ѧ ၗ ૻ ޑ ф ૈ ک ΋ ϩ ݋ ၗ
਑ޑфૈ܌ಔԋޑ΋ᜪձኳಔǶ
!
1 2 .΋ ᅿ ё ᘏ ڗ ک ໺ ଌ ࠼ ᇙ ϯ ᔈ Ҕ ϐ ၗ ૻ ޑ Б ݤ Ǵ ᙖ
аᘏڗǵԏ໣ǵᆅ౛ᆶϩ݋΋೛ഢϐ΋ၗૻǴځύ၀ᐒڋ
ԿϿхࡴǺ
ගٮ΋ٯѦ೯ޕำׇǴځύ၀ٯѦ೯ޕำׇ߯җ၀೛
ഢЬ୏วр΋ٯѦ ( E x c e p t i o n )ૻ৲Ǵ٠࿶җ΋೯Ҕࠠ൪Ε
Ԅး࿼ڗளࡕǴӆ໺ଌ๏΋ᔈҔኳಔ܈΋Ѧ೽س಍ǹ
ගٮ΋ۓයᔠᡍำׇǴځύ၀ۓයᔠᡍำׇ߯җ၀ᔈ
Ҕኳಔۓයวрϐ΋ၗૻᘏڗፎ؃Ǵ၀೯Ҕࠠ൪ΕԄး࿼
ਥᏵ၀ၗૻᘏڗፎ؃ٰᘏڗ၀ၗૻࡕǴӆ໺ଌ๏၀ᔈҔኳ
ಔǴߩ၀ᔈҔኳಔஒ܌ᘏڗϐ၀ၗૻϩ݋ֹ౥٠ౢғ΋ϩ
݋่݀ࡕǴஒ၀ϩ݋่݀໺ଌ๏၀Ѧ೽س಍ǹаϷ
ගٮ΋ၗૻࢗ၌ำׇǴځύ၀ၗૻࢗ၌ำׇ߯җ၀Ѧ
೽س಍วрϐ΋ၗૻࢗ၌ፎ؃Ǵ၀೯Ҕࠠ൪ΕԄး࿼ਥᏵ
၀ၗૻࢗ၌ፎ؃ٰᘏڗ၀ၗૻࡕǴ೸ၸ၀೯Ҕࠠ൪ΕԄး
࿼ϐ΋೯ૻж౛ޣӣᙟ๏၀Ѧ೽س಍Ƕ
30
!
1 9 .ӵҙፎ஑ճጄൎಃ 1 2 ໨܌ॊϐёᘏڗک໺ଌ࠼ᇙ
ϯᔈҔϐၗૻޑБݤǴځύ၀೯Ҕࠠ൪ΕԄး࿼ڗள၀ၗ
ૻޑᐒڋࣁ٬Ҕ΋኱ྗޑฯᡏ  I / O!ϟ य़ ǵ ΋ !T C P / I P ϐ
Ԗጕ܈คጕ೯ૻᆛၡǵ΋ฯᡏ܌ගٮޑϟय़ǹ΋ᔞਢ໺ᒡ
ک΋཰ࣚޑ኱ྗೕጄځύϐ΋Ƕ !
2 0 .ӵҙፎ஑ճጄൎಃ 1 2 ໨܌ॊϐёᘏڗک໺ଌ࠼ᇙ
ϯᔈҔϐၗૻޑБݤǴځύ၀೯Ҕࠠ൪ΕԄး࿼߯΋ᚈӛ
೯ૻޑࢎᄬǶ
32
34
ߕҹѤ ऍ୯஑ճ
[1] F.-T. Cheng, G.-W. Huang, C.-H. Chen, M.-H. Hung, Generic Embedded Device
and Mechanism Thereof for Various Intelligent-Maintenance Applications,
USA Patent, Notice of Allowance issued on 08/29/2006 (10/846, 768), Patentee:
National Cheng Kung University.
1GENERIC EMBEDDED DEVICE AND MECHANISM THEREOF
FOR VARIOUS INTELLIGENT-MAINTENANCE APPLICATIONS
5
Field of the Invention
The present invention relates to a generic embedded device (GED) and a
mechanism thereof for various intelligent-maintenance (IM) applications, and more
particularly, to the extensible GED and the mechanism thereof for retrieving and
transmitting information of various IM applications.10
Background of the Invention
For a manufacturing factory, it is very important to collect and analyze process
information efficiently. In general, the manufacturing factory adopts a system
provided by an information vender or a special system developed by itself for15
collecting and analyzing the process information so as to perform various maintenance
applications, such as status-monitoring, fault-detection, diagnostics, and prognostics of
various kinds of information equipment. Either the system developed by the system
vendor or the special system developed by the manufacturing factory lacks standard
communication interfaces with respect to various kinds of equipment, different20
application modules and external systems. Thus, different kinds of programs for
collecting and analyzing the process information have to be developed for various
kinds of equipment, different maintenance application modules and external systems.
University of Wisconsin and University of Michigan in USA established an
3for various IM applications, thereby enabling the information equipment having a
wired or wireless linking interface to own the capability of retrieving and transmitting
the information of various IM applications.
Another object of the present invention is to provide a GED and a mechanism
thereof for various IM applications, thereby overcoming the shortcoming of the5
conventional data-retrieval program which is merely suitable for use in one single
information equipment or specific hardware.
Another object of the present invention is to provide a GED and a mechanism
thereof for various IM applications, wherein an open interface of object-oriented design
is adopted to resolve the expansibility problem, thus allowing R&D personnel to add10
various maintenance application modules easily.
Another object of the present invention is to provide a GED and a mechanism
thereof for various IM applications, wherein three standard processes for retrieving and
transmitting information are established for being generically applied in manipulating
the information of various kinds of information equipment.15
According to the aforementioned objects, a GED for various IM applications is
provided for retrieving, collecting, managing and analyzing information of information
equipment.
According to a preferred embodiment of the present invention, the GED
comprises a data collector and a communication manager. The data collector is used20
for collecting and managing the information of the information equipment, and further
includes a device driver and a collection plan, wherein the device driver is used for
retrieving the information of the information equipment, and is equipment-dependent,
and the collection pan is responsible for managing the information retrieved by the
device driver, and is equipment-independent. The communication manager further25
5information equipment is replied to the external system via the communication agent of
the GED.
Hence, the present invention can be generically applied for retrieving and
transmitting information of various kinds of information equipment; has the
expansibility of adopting various IM application modules; can be embedded to various5
kinds of information equipment or hardware; and can use standardized processes of
information acquisition and transmission to retrieve and transmit the information of
various kinds of information equipment.
Brief Description of the Drawings10
The foregoing aspects and many of the attendant advantages of this invention
will become more readily appreciated as the same becomes better understood by
reference to the following detailed description, when taken in conjunction with the
accompanying drawings, wherein:
Fig. 1 is a schematic structural diagram of a GED according to the present15
invention;
Fig. 2 is a schematic sequence diagram showing an exception notification
process of the present invention;
Fig. 3 is a schematic sequence diagram showing a periodic inspection process of
the present invention;20
Fig. 4 is a schematic sequence diagram showing a data inquiry process of the
present invention; and
Fig. 5 is a schematic structural diagram showing an integrated architecture of
applying the GED to e-diagnostics and e-maintenance of semiconductor manufacturing
equipment, according to an embodiment of the present invention.25
7board systems, personal computers without hard disk driver, and computer systems of
ARM/MIPS/PowerPC, etc. Hereinafter, the system software of the GED of the
present invention will be described.
Referring to Fig. 1, Fig. 1 is a schematic structural diagram of a GED according
to the present invention. The GED 100 of the present invention comprises a data5
collector 120, a communication manager 110 and an IM application module 130,
wherein the IM application module 130 is a pluggable customized application module
having intelligent-maintenance functions. The data collector 120 is an element used
for collecting and managing information, and is composed of a collection plan 122 and
a device driver 124, wherein the collection plan 122 is responsible for managing the10
information that is retrieved by the device driver 124 from equipment 140, and the
collection pan 122 is equipment-independent, i.e. the collection plan 122 can be used
for any kind of information equipment. The device driver 124 is used for retrieving
the information of the equipment 140, and is equipment-dependent, i.e. different kinds
of information equipment have different designs of device drivers, wherein the device15
driver can be designed with reference to the interface specification provided by an
equipment vendor (for example, a device driver for car usage, a device driver for
semiconductor equipment usage). The data collection is handled by the device driver
124 that is installed in the data collector 120, and the device driver 124 is used for
resolving the interface problem with the equipment 140 so as to obtain the information20
of the equipment 140. The collection plan 122 in the data collector 120 is responsible
for managing the information retrieved by the device driver 124, so that the collection
plan 122 does not need to worry about how to communicate with the equipment 140.
The scheme of the collection plan 122 for classifying and managing equipment
information can be, for example, to classify the information based on the functions of25
9Class {
receiveExceptionInfo();
submitRequest()Ι
submitStatus()Ι
requestforData();5
}.
The standard functional specification of the IM application module 130 can be
such as:
Class {
analyzeExceptionInfo();10
analyzeData()Ι
}.
Further, the communication manager 110 relies on the communication agent 114
to send the analysis result to the external system 150, and the external system 150 also
can send a command to the communication manager 110 via the communication agent15
114, wherein the communication agent 114 can adopt SOAP (Simple Object Access
Protocol) or Web Services specifications to transfer the information to another end of
Intranet/Internet via wired or wireless communication. Besides, other communication
specifications such as CORBA (Common Object Request Broker Architecture),
DCOM (Distributed Component Object Model), or RMI (Remote Method Invocation)20
are also adoptable.
Such as shown in Fig. 1, the operation process for each component of the GED
100 is explained as follows:
The data collector 120 obtains the information of the equipment 140 via the
device driver 124 installed therein. Thereafter, the collection plan filters and25
11
notification process, a periodic inspection process, and a data inquiry process. In the
exception notification process, the equipment 140 initiates an exception message
actively when an exception occurs, and the exception message is delivered to the IM
application module 130 or the external system 150 via the GED 100. In the periodic
inspection process, a data-retrieval request or an inspection request are submitted5
periodically by the IM application module 130 plugged to the GED 100, and, after the
GED 100 has retrieved the information of the equipment 140 in accordance with the
data-retrieval or inspection request, the information of the equipment 140 is replied to
the IM application module 130. Then, the IM application module 130 will run the
analytical process. After the analyzed result is obtained, it will then be sent to the10
external system 150. In the data inquiry process, the external system 150 submits a
data-inquiry request, and after the GED 100 has retrieved the information of the
equipment 140 in accordance with the data-inquiry request, the information is replied
to the external system 150 via the communication agent 114. Hereinafter, the detailed
scenarios of those three processes will be discussed.15
1. Exception Notification Process
Referring to Fig. 2, Fig. 2 is a schematic sequence diagram showing an
exception notification process of the present invention. When an exception occurs to
the equipment 140, the equipment 140 actively sends an exception message. The
exception message is classified by the collection plan 122, and then the collection20
interface 112 may choose to deliver the exception message to the IM application
module 130 for analysis and treatment. After the analysis and treatment is done, the
IM application module 130 informs the external system 150 of the analyzed results. If
the analysis by the IM application module 130 is dispensable, the collection interface
112 may choose to send the exception message directly to the external system 150.25
13
Referring to Fig. 3, Fig. 3 is a schematic sequence diagram showing a periodic
inspection process of the present invention. This process has three steps. The
periodic inspection process is activated by a periodic-inspection request sent by the IM
application module 130 plugged to the GED; if the request is granted, then the IM
application module 130 can start retrieving information from the equipment 140;5
thereafter, the IM application module 130 performs the inspection program and sends
the inspection result to the external system 150. Hereinafter, the detailed scenarios of
those three steps will be discussed.
The IM application module 130 actively submits the request for a periodic
inspection (step 300), and meanwhile, sends the request-related data for the periodic10
inspection. Via the application interface 116, the communication manager 110
receives the request-related data provided by the IM application module 130, and then
passes the request-related data to the collection interface 112 (step 310), thus passing
the request-related data to the data collector 120. Subsequently, the collection
interface 112 requests the collection plan 122 to set data type (step 330), buffer size15
(step 332), and start time (step 334) in accordance with the request-related data sent by
the communication manager 110. After these parameters are properly set, the
collection plan 122 then generates a data collection plan (step 340).
After the data collection plan is generated, the IM application module 130
begins to send the request for data (step 302), and transmits the request for data via the20
application interface 116 (step 312). Then, the collection interface 112 requests the
collection plan 120 to start a data collection plan (step 336). Thus, after receiving the
request for starting the data collection plan, the collection plan 122 starts to collect
equipment data via the device driver 124 (step 342). Thereafter, the device driver 124
is linked to the physical interface of the equipment 140 so as to obtain data (step 350).25
15
data-inquiry request to the data collector 120. At first, the collection plan 122 sets
data type (step 422), buffer size (step 424), and start time (step 426) in accordance with
the related data sent by the communication manager 110, and then generates a data
collection plan (step 430). After the data collection plan is generated, the external
system 150 sends the data-inquiry request to the communication agent 114 (step 404),5
and then the communication agent 114 sends the data-inquiry request to the collection
interface 112 (step 414). After receiving the data-inquiry request, the data collection
plan is activated (step 428), and the collection interface 122 starts collecting data via
the device driver 124 (step 432). Thereafter, the device driver 124 is linked to the
physical interface of the equipment 140 so as to get the information of the equipment10
140 (step 440). After obtaining the information of the equipment 140, the collection
plan 122 classifies and filters the information (step 434), and sends the treated
information back to the external system 150 via the communication manager 110.
To sum up, according to the present invention, the functional specification of the
interface of each component in the GED can be summarized as follows, wherein the15
functions to be introduced in the following are the method calls used for performing
the sequences shown in Fig.2 to Fig. 4.
(1) the equipment 140: getData();
(2) the external system 150: sendStatus(); sendExceptionInfo();
(3) the application interface 116 (a sub-module of the communication manager20
110) : receiveExceptionInfo(); submitRequest(); submitStatus(); requstforData();
(4) communication agent 114 (a sub-module of the communication manager
110): deliverRequestInfo(); sendStatus(); sendExceptionInfo(); submitRequest();
requstforData();
(5) collection interface 112 (a sub-modules of the communication manager 110):25
17
invention, wherein a plurality of GEDs are installed in respective equipments 140 (such
as manufacturing machines) which adopt the interface specification of CEM (Common
Equipment Model) defined by SEMI organization, and each GED therein is used for
retrieve the information of each equipment 140. The information of the equipment
140 is provided for use in a MES (Manufacturing Execution System) 170 located at a5
factory side of an Intranet 151; and in a remote diagnostics/Maintenance server 160
located at a supplier side of an Intranet 152, wherein the Intranet 151 and the Intranet
152 are linked to an Internet 153, and are guarded by using firewalls 154 and 156.
The IM application module 130 is an application program for
diagnosing/maintaining the equipment 140. A remote diagnostics/maintenance server10
(RDMS) 160 can retrieve the information of the equipment 140 via the Internet 153,
wherein the GED 100 supports wired/wireless communications. Hence, the external
system (such as the MES 170 or the RDMS 160) can get the information from the GED
via a wired or wireless network. Since a unified communication protocol (such as
SOAP) is used among the MES 170, the RDMS 160 and the GED 100 installed in the15
equipment 140, those three members can adopt the communication agents 114, 174 and
164 of the same specification to communicate with one another via the Intranet 151,
the Intranet 152 and the Internet 153. Further, the diagnostics/maintenance
application module (i.e. the IM application module 130) can be embedded in the GED
100, and the GED 100 is installed in the equipment 140 having the CEM interface, thus20
forming a CEM equipment 144 equipped with a GED.
A device driver 124 is a special module of CEM interface specification for
accessing the data of the equipment 140 having the CEM interface. When the
interface specification of the equipment 140 to be linked is changed, only the device
driver 124 has to be replaced and all the other modules in the GED 100 do not need to25
19
assistance. At this time, the supplier can follow the data inquiry process as shown in
Fig. 4 to submit a data-inquiry request to the unhealthy equipment 140 located at the
factory side from the RDMS 160 (external system) of the supplier side. Meanwhile,
since the RDMS 160 is located outside the factory and it needs to rely on the Internet
153 to submit the data-inquiry request, for the security considerations, a series of5
checkups (such as identity verification, etc.) have to be performed by the collection
interface 112 located in the communication manager 110. After authentication, the
RDMS 160 then is allowed to perform the process of submitting the data-inquiry
request. After receiving the data related to the data-inquiry request sent from the
RDM 160, the communication manager 110 transfers the request-related data to the10
collection plan 122 of the data collector 120 for generating the data collection plan.
Subsequently, the RDMS 160 can get the related information from the equipment 140
via the communication manager 110 and the data collector 120. After completing the
data collection, the RDMS 160 can perform analysis in a diagnostic module 166 or a
maintenance module 168. Accordingly, the process described above is the so-called15
e-diagnostics and e-maintenance data-inquiry process.
From the aforementioned embodiment of the present invention, it can be known
that the GED and the mechanism thereof for various IM applications have the
advantages of: (1) adopting two-tiered structure including a device driver and a
collection plan, wherein the device driver is equipment-dependent, and the collection20
plan is equipment-independent, so that only the corresponding device driver needs
replacing while the information equipment to be linked is changed, thus having high
migration capability among different kinds of information equipment; (2) enabling one
unified standard collection plan module to be applicable to different device drivers; (3)
using the object-oriented technology to fabricate the device driver and the collection25
21
What is claimed is:
1. A generic embedded device (GED) for various intelligent-maintenance (IM)
applications, wherein said GED is used for retrieving, collecting, managing and
analyzing information of equipment, said GED comprising:5
a pluggable IM application module used for providing said various IM
applications;
a data collector used for collecting and managing said information, said data
collector further comprising:
a device driver used for getting said information of said equipment,10
wherein said device driver is dependent on said equipment; and
a collection plan responsible for managing said information obtained by
said device driver, wherein said collection plan is independent of said equipment;
and
a communication manager used for establishing communication channels among15
said data collector, said pluggable IM application module and at least one external
system, said communication manager comprising:
a communication agent used for sending said information to said external
system, or for allowing said external system to send a command;
a collection interface used for linking to said collection plan so as to20
transmit said information to said pluggable IM application module or said
external system; and
an application interface responsible for linking to said pluggable IM
application module, wherein said pluggable IM application module uses said
application interface to get said information sent by said data collector.25
23
9. The GED of claim 1, wherein said GED is built in a bi-directional
communication infrastructure.
10. The GED of claim 1, wherein the standard functional specification of said5
application interface is a class module composed of a function of receiving exception
information, a function of submitting a request, a function of submitting a status report,
and a function of requesting for said information.
11. The GED of claim 1, wherein the standard functional specification of said10
pluggable IM application module is a class module composed of a function of
analyzing exception information, and a function of analyzing said information.
12. A mechanism of a generic embedded device (GED) for various
intelligent-maintenance (IM) applications, wherein said GED is used for retrieving,15
collecting, managing and analyzing information of equipment, said mechanism
comprising:
an exception notification, wherein said equipment initiates an exception message
actively, and said exception message is delivered to an pluggable IM application
module or an external system via said GED;20
a periodic inspection process activated by a data-retrieval request periodically
sent out by said pluggable IM application module, wherein, after said GED has
retrieved said information in accordance with said data-retrieval request, said
information is sent to said pluggable IM application module, and after said pluggable
IM application module has analyzed said information and generate an analysis result,25
25
19. The GED of claim 12, wherein the scheme of said device driver for
obtaining said information is to use one of a standard hardware I/O interface, a
standard TCP/IP-wired or wireless network protocol, an interface provided by
hardware, a file transfer and an industry-defined specification.5
20. The mechanism of claim 12, wherein said GED is built in a bi-directional
communication infrastructure.



[1] 2004 IEEE International Conference on Robotics and Automation (ICRA 2004)
Βǵᆶ཮ЈளǺ
Ϟԃ׫ዺԿ ICRA2004ϐፕЎǴҗ 1,176ጇε൯ගଯԿ 1,457ጇǴҗԜёـ
୯ሞ΢ჹԜࣴ૸཮ϐख़ຎǶฅך୯ᏢޣϞԃୖᆶ౰཮ޣǴࠅ෧ϿԿ 5ǵ6ঁΓѰ
ѓԶςǴԜ౜ຝዴჴॶளݙཀǶӢԜޱҖӧԜڥᢣ୯ϣᏢޣᔈᑈཱུୖᆶ୯ሞᏢ
ೌࢲ୏٠ว߄ፕЎǴаයගϲך୯ϐ୯ሞᏢೌӦՏǶ
Οǵࡌ᝼Ǻ
Ϧϡ 2003ԃޑ IEEE Robotics and Automation཮᝼ӧѠчᖐՉǴЪҗύ҅
εᏢᛥϘ៾ਠߏᏼҺ General Chair ᆶѠεၗૻسϐഡҥԋ௲௤ᏼҺ Program
ChairǶޱҖҭᕇငᏼҺ Finance ChairǶࣁගܹך୯ϐ୯ሞᏢೌӦՏǴޱҖࡌ᝼
ך୯ϐЬᏤൂՏૈӭӭႴᓰ٠ଛӝᏢࣚᑈཱུݾڗӚ໨୯ሞޕӜϐᏢೌ཮᝼ӧҁ
୯ᖐᒤǶ
Ѥǵឫӣၗ਑ӜᆀϷϣ৒Ǻ
1.Proceedings / Video Proceedings, 2004 IEEE International Conference on
Robotics and Automation.
2.Workshop M-WP-2 CD: Robot Fault Diagnosis
[2] 2005 IEEE International Conference on Robotics and Automation (ICRA 2005)
Βǵᆶ཮ЈளǺ
Ϟԃ׫ዺԿ ICRA2005ϐፕЎǴҗ 1,457ጇε൯ගଯԿ 1,700ጇǴҗԜёـ
୯ሞ΢ჹԜࣴ૸཮ϐख़ຎǶฅך୯ᏢޣϞԃୖᆶ౰཮ޣǴࠅ෧ϿԿ 4ǵ5ঁΓѰ
ѓԶςǴ೏ௗڙϐЎക໻ 7ǵ8ጇ(1%)ԶςǴჴӧϼϿǴԜ౜ຝዴჴॶளݙཀǶ
ӢԜޱҖӧԜڥᢣ୯ϣᏢޣᔈᑈཱུୖᆶ୯ሞᏢೌࢲ୏٠ว߄ፕЎǴаයගϲך
୯ϐ୯ሞᏢೌӦՏǶ
Οǵࡌ᝼Ǻ
Ϧϡ 2003ԃޑ IEEE Robotics and Automation཮᝼ӧѠчᖐՉǴЪҗύ҅
εᏢᛥϘ៾ਠߏᏼҺ General Chair ᆶѠεၗૻسϐഡҥԋ௲௤ᏼҺ Program
ChairǶޱҖҭᕇငᏼҺ Finance ChairǶࣁගܹך୯ϐ୯ሞᏢೌӦՏǴޱҖࡌ᝼
ך୯ϐЬᏤൂՏૈӭӭႴᓰ٠ଛӝᏢࣚᑈཱུݾڗӚ໨୯ሞޕӜϐᏢೌ཮᝼ӧҁ
୯ᖐᒤǶ
Ѥǵឫӣၗ਑ӜᆀϷϣ৒Ǻ
1.Proceedings / Video Proceedings, 2005 IEEE International Conference on
Robotics and Automation.
[3] 2006 IEEE International Conference on Robotics and Automation (ICRA 2006)
Βǵᆶ཮ЈளǺ
Ϟԃ׫ዺԿ ICRA2005ϐፕЎǴҗ 1,700ጇගଯԿ 1,756ጇǴҗԜёـ୯ሞ
΢ჹԜࣴ૸཮ϐख़ຎǶฅך୯ᏢޣϞԃୖᆶ౰཮ޣǴࠅ෧ϿԿ 10 ঁΓѰѓԶ
ςǴ೏ௗڙϐЎക໻ 8ጇ(1%)ԶςǴჴӧϼϿǴԜ౜ຝዴჴॶளݙཀǶӢԜޱ
ҖӧԜڥᢣ୯ϣᏢޣᔈᑈཱུୖᆶ୯ሞᏢೌࢲ୏٠ว߄ፕЎǴаයගϲך୯ϐ୯
ሞᏢೌӦՏǶ
Οǵࡌ᝼Ǻ
Ϧϡ 2003ԃޑ IEEE Robotics and Automation཮᝼ӧѠчᖐՉǴЪҗύ҅
εᏢᛥϘ៾ਠߏᏼҺ General Chair ᆶѠεၗૻسϐഡҥԋ௲௤ᏼҺ Program
ChairǶޱҖҭᕇငᏼҺ Finance ChairǶࣁගܹך୯ϐ୯ሞᏢೌӦՏǴޱҖࡌ᝼
ך୯ϐЬᏤൂՏૈӭӭႴᓰ٠ଛӝᏢࣚᑈཱུݾڗӚ໨୯ሞޕӜϐᏢೌ཮᝼ӧҁ
୯ᖐᒤǶ
Ѥǵឫӣၗ਑ӜᆀϷϣ৒Ǻ
1.Proceedings / Video Proceedings, 2006 IEEE International Conference on
Robotics and Automation.
ߕҹϤ ୯ሞӝբࣴزीฝࣴزൔ֋ਜ
[1] Industrial Advisory Board (IAB 7)
[2] 2005 IEEE International Conference on Automation Science and Engineering
(CASE 2005)
[3] 2006 IEEE International Conference on Automation Science and Engineering
(CASE 2006)
2ᕴीฝ: ว৖ъᏤᡏᐒѠᆛၡԄບᘐᆶႣٛߥᎦس಍ (1/3)
(NSC 92-2212-E-006-098) ϐ
ηीฝ΋: ъᏤᡏᐒѠᆛၡԄບᘐᆶႣٛߥᎦس಍ϐ൪ΕԄࢎᄬ೛ीᆶჴբ
(1/3) ( NSC 92-2212-E-006-099)
୯ ሞ ӝ բ ी ฝ р ୯ Ј ள ൔ ֋
୯ҥԋфεᏢ
ᇙ೷πำࣴز܌
ᎄ ޱ Җ
93.5.10
4Βǵᆶ཮ЈளǺ
Ԝԛ཮᝼ϐᆶ཮Γ঩ीԖMembers 29ΓǴNon-Members 18ΓǴIMS Team 21
ΓǴϷ IMS Collaborators 6ΓǶޱҖϝឦܭ IMS CollaboratorsϐဂǶ୯ϣϐπ
ࣴଣᐒఓ܌ᆶᆒஏᐒఓࣴزว৖ύЈឦܭ MembersဂǶ཮᝼ϣ৒Ьाൔ֋
Watchdog AgentǴ Device-to-Business PlatformǴ and Decision Support Tools฻
ЬᚒǶځύ߻ٿঁЬᚒWatchdog Agent ᆶ Device-to-Business (D2B) Platform
Ώࢂᆶҁ୯ሞӝբीฝ࣬ᜢϐЬाࣴز໨ҞǶ
Watchdog Agent܌௦Ҕޑ Smart Prognostics AlgorithmsЬाҭࢂࣁᐒѠϐ
ႣٛߥᎦس಍Զ೛ǶҞ߻ϐჴᡍጄٯ܈ѳѠԖ Harley-Davison ϐЬౢᐒѠǵ
KoneϐႝఊǵϷऍ୯ແֽϐނ਑ཚၮس಍฻ǶԜ೽ҽϐࣴزҞޑᆶҁ᏾ӝࠠी
ฝϣޑηीฝΒǵΟǵѤଛӝηीฝ΋(ջஒႣٛߥᎦس಍ǵAPC/OEEǵᆶ਑ଛ
ҹނࢬᆅ౛฻ࢎᄬ෌Ε൪ΕԄኳಔ)ϐҞޑ࣬ӕǴ܌аёаϕ࣬ᢀነᆶҬඤࣴز
ЈளǶ
ԿܭಃΒঁࣴวЬᚒ:D2B Platform, ЬाҞޑࢂૈעᐒѠϐᆢঅރݩᆶႣ
ٛߥᎦሡ؃ޔௗଌԿ ERPǵSCM܈ᇻᆄϐᐒѠٮᔈ୘ᆄǴঈගଯႣٛߥᎦϐԋ
ਏǶԜࣴวЬᚒϐҞޑᆶҁηीฝ΋ϐҞޑ:ȸᔈҔWeb Services מೌஒᐒѠπ
ำၗ਑ϷځѬᆶᆢঅߥᎦ࣬ᜢϐၗૻ໺ଌ๏ӚηीฝϐኳಔᆶᇻᆄޑᐒѠٮᔈ
୘٬Ҕ”όᒉԶӝǴ܌аҭёϕ࣬ᢀነᆶҬඤࣴزЈளǶ
6ϐמೌǴҭёᔈҔٰၲԋӵ຀ᔕໆෳᆶࠔ፦ႣෳϐҞ኱Ƕ
Ҟ߻୯ࣽ཮Ծ୏ϯᏢߐҭ҅ӧ௢୏ȨඵችࠠᆢঅߥᎦᆶႣෳس಍ȩ߻ᘳ
ख़ᗺࣴزीฝǴԜዴჴࣁ୯ϣౢ཰ࣚҞ߻ന໪ाࣴزޑᚒҞϐ΋Ǵࡌ᝼୯ࣽ
཮ૈዴჴ௢୏٠௢ቶǶ
Ѥǵឫӣၗ਑ӜᆀϷϣ৒Ǻ
IAB 7 ࣴ૸཮ၗ਑Ƕ
2ᕴीฝ: ว৖ъᏤᡏᐒѠᆛၡԄບᘐᆶႣٛߥᎦس಍ (2/3)
(NSC 93-2212-E-006-023) ϐ
ηीฝ΋: ъᏤᡏᐒѠᆛၡԄບᘐᆶႣٛߥᎦس಍ϐ൪ΕԄࢎᄬ೛ीᆶჴբ
(2/3) (NSC 93-2212-E-006-022)
୯ ሞ ӝ բ ी ฝ р ୯ Ј ள ൔ ֋
୯ҥԋфεᏢ
ᇙ೷πำࣴز܌
ᎄ ޱ Җ
94.8.23
4Βǵᆶ཮ЈளǺ
ԜԛޱҖ܌ୖᆶϐ୯ሞᏢೌ཮᝼ࣁ 2005 IEEE International Conference on
Automation Science and Engineering (CASE 2005)Ǵ཮൑Տܭу৾ε Edmonton
ѱǶҁԛ཮᝼ӅԖ 110ጇፕЎ׫ዺǴՠቩ่ࢗ݀Ǵ໻ௗڙځύϐ 69ጇȐऊ 63%ȑ
ܭҁε཮ว߄Ƕҁ୯ሞᏢೌ཮᝼Ǵ୯ϣޑ஑ৎᏢޣୖуޣԖǺѠεᐒఓس໳ᅇ
ٖ௲௤ǵੇ ࢩεᏢႝᐒسᎄኀቺ௲௤ǵύ҅౛πᏢଣႝᐒسࢫ௵໢ୋ௲௤฻ΓǶ
ҁԛε཮ճҔ 2Ϻϐਔ໔ஒ܌Ԗ 69ጇፕЎϩԋ 23ঁ Sessionsว߄ǶޱҖӧ཮
ύว߄൘ጇፕЎǴځᚒҞࣁȸDesign and Implementation of an Intelligent
Prognostics SystemȹǶ
ӧୖуҁࣴ૸཮ය໔Ǵමᆶऍ୯ Intel Ϧљϐ Staff Engineer: Dr. Mike
ZhangϷВҁ TEL (Tokyo Electron LTD.)Ϧљϐ Director of Factory Integration
Promotion Group: Mr. Terry AsakawaҬඤԖᜢటჴբъᏤᡏ཰ 12ә඲༝ቷ܌໪
ϐ EES (Equipment Engineering System)ޑЈளǴޱҖ᝺ளڙ੻ؼӭǶ
6ϐמೌǴҭёᔈҔٰၲԋӵ຀ᔕໆෳᆶࠔ፦ႣෳϐҞ኱Ƕ
Ҟ߻୯ࣽ཮Ծ୏ϯᏢߐҭ҅ӧ௢୏ȨඵችࠠᆢঅߥᎦᆶႣෳس಍ȩ߻ᘳ
ख़ᗺࣴزीฝǴԜዴჴࣁ୯ϣౢ཰ࣚҞ߻ന໪ाࣴزޑᚒҞϐ΋Ǵࡌ᝼୯ࣽ
཮ૈዴჴ௢୏٠௢ቶǶ
Ѥǵឫӣၗ਑ӜᆀϷϣ৒Ǻ
Proceedings, 2005 IEEE International Conference on Automation Science and
Engineering.
2ᕴीฝ: ว৖ъᏤᡏᐒѠᆛၡԄບᘐᆶႣٛߥᎦس಍ (3/3)
(NSC 94-2212-E-006-005) ϐ
ηीฝ΋: ъᏤᡏᐒѠᆛၡԄບᘐᆶႣٛߥᎦس಍ϐ൪ΕԄࢎᄬ೛ीᆶჴբ
(3/3) (NSC 94-2212-E-006-006)
୯ ሞ ӝ բ ी ฝ р ୯ Ј ள ൔ ֋
୯ҥԋфεᏢ
ᇙ೷πำࣴز܌
ᎄ ޱ Җ
95.10.14
4IEEE International Conference on Automation Science and Engineering (CASE)
ࣁIEEE Transactions on Automation Science and Engineeringޑᄡᝮࣴ૸཮
(Flagship Conference)ǶϞ(2006)ԃCASEԖ΋ “ Invited Session on Semiconductor
Manufacturing”ǴԜᆶҁ୯ሞӝբीฝ࣬ᜢǴЪε཮ҭᗎፎޱҖᝢᒤ΋ঁ
“e-Manufacturing for the Semiconductor Industry”ϐTutorial/WorkshopǶӢԜޱҖ
㜞ۓϞԃϐ୯ሞӝբीฝр୯ҭᒧۓԿӧ΢ੇᖐՉϐCASE 2006Ƕ
6Οǵࡌ᝼Ǻ
ъᏤᡏᆶ TFT-LCDౢ཰ࢂך୯Ҟ߻നख़ाޑٿᅿଯࣽמౢ཰ǴځύъᏤᡏ
жπ཰ך୯ς࿶ࢂۚܭሦᏤӦՏǴќ΋໨ TFT-LCDౢ཰ӧӄౚѱ൑ޑѱэ౗ҭ
ςၲډ 35ʘа΢Ƕࡹ۬٠ӧȨٿӂᚈࢃȩीฝύǴஒъᏤᡏᆶ TFT-LCD ౢ཰
ᇡۓࣁ୯ৎว৖ޑख़ᗺౢ཰ǶԜѦǴ׫ၗᚳεޑًؓ཰ǵҡϯ཰ǵᒳ៓཰ǵπ
ڀᐒ཰฻໺಍ౢ཰Ǵҭࢂ୯ৎว৖ޑख़ᗺౢ཰Ƕ
җܭ΢ॊౢ཰Ծ୏ϯሡ؃ଯЪ׫ၗೕኳᚳεǴӚৎቷ୘КޑࢂໆౢೕኳǴ
ౢૈຫεຫڀഢғౢਏ੻ǶӢԜǴӧӵԜଯޑ׫ၗԋҁϐΠǴӵՖᡣԾ୏ϯғ
ౢ೛ഢߥ࡭ 24λਔό໔ᘐӦၮᙯ൩ᡉளΜϩख़ाǶғౢ೛ഢޑࡺም܈౦தж߄
ޑࢂౢૈޑཞѨᆶၗҁޑੁ຤ǹӢԜගଯౢૈճҔ౗ᆶִ๓౗ȐAvailabilityȑ
ς࿶ԋࣁ΢ॊౢ཰ᕇճޑᜢᗖӢનϐ΋Ƕ
߈൳ԃٰǴҗܭၗૻࣽמᆶᆛሞᆛၡמೌޑጲࠁว৖ǴܭࢂߡԖᆛၡԄ
ᇙ೷ (e-Manufacturing)ǵᆛၡԄບᘐ (e-Diagnostics)ǵᆶᆛၡԄႣٛߥᎦ
Ȑe-Maintenanceȑ฻ᢀۺ೏ගрٰǴঈ೸ၸᆛሞᆛၡᆶၗૻמೌٰගٮჹ೛
ഢϷπڀϐᇻᆄೱ่ǵ௓ڋǵᏹբǵೕჄǵ܄ૈᅱ࿎ǵၗ਑ԏ໣ᆶϩ݋ǵᒱ
ᇤບᘐᆶᆢঅ฻ૈΚǴ٠ၲډԾךບᘐȐSelf-DiagnosticsȑǵႣෳ܄ᆢঅ
ȐPredictive Maintenanceȑǵࠔ፦Ⴃෳ(Quality Prediction)ǵᆶ຀ᔕໆෳ(Virtual
Metrology)฻ϐҞ኱ǶᙖҗᆛၡԄບᘐמೌǴஒёזೲӦບᘐᆶঅൺ೛ഢǵ
ε൯ᕭอѳ֡অൺਔ໔ȐMean Time To Repair, MTTRȑǴаϷफ़ե೛ഢޑᆢ
অ୍ܺԋҁǹ٠ЪǴӧᇻᆄ೛ഢᇙ೷୘ޑ஑ৎǴҭё೸ၸᆛሞᆛၡǴԏ໣೛
ഢޑπբၗ਑Ǵуаϩ݋ᆶ಍ीǴаճ೛ഢ܄ૈϐ࡭ុׯ຾Ƕќ΋Бय़Ǵ೸
ၸᆛၡԄႣෳߥᎦמೌǴஒё຾΋؁फ़ե೛ഢϐࡺም౗Ǵаයၲډ೛ഢ߈ܭ
႟ѨਏȐNear-Zero DowntimeȑޑҞ኱ǶӆޣǴᆛၡԄႣӂୀෳ(e-Prognostics)
