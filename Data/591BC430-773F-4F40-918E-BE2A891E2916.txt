ii 
Abstract 
A high-reliability control nucleus with fail-safe function used for train equipment is 
analyzed and designed in this project. The main functions of the train equipment include 
motor control, train control, signal and communication. Due to the design with 
fault-tolerant characteristic, the reliability and availability of the proposed control 
nucleus are improved. Since the Field Programmable Gate Array (FPGA) is on-line 
programmable, FPGA is adopted to design the proposed control nucleus and increase 
the flexibility of the proposed control nucleus. The accurate data is difficult to obtain, 
thus, Markov model and fuzzy logic are used to set up the reliability model for each 
module and analyze the reliability of the system. Besides the 
Proportional-Integral-Derivative controller used in the feedback path, the fuzzy 
controller is also used, such that the steady-state error will be decreased and the 
response time will be shortened, and then the reliability can be improved. In this project, 
under the assumption of the same failure rate, the reliability of the parallel redundant 
system, the 2-out-of-3 redundant system and the standby redundant system is analyzed 
and compared. The standby redundant system and the 2-out-of-3 redundant system are 
bound to form the dual 2-out-of-3 redundant system, and the fault-tolerant architecture 
is established in the dual 2-out-of-3 redundant system. Thus, the high-reliability and 
high-availability control nucleus is produced through the combination of the fuzzy 
controller and the dual 2-out-of-3 redundant system. Since the proposed control nucleus 
is implemented by FPGA, it also has the characteristic of the low-cost. Therefore, the 
proposed control nucleus can be used in the railway system effectively. Meantime, the 
high-reliability industrial controller can also be designed using the same technology, its 
use will be extended to the similar high-reliability system.   
!
!
Keywords fail-safe, reliability, Field Programmable Gate Array, redundant system, train 
control 
iv 
,$ # òó !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  &( 
,$ % uv#® !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  &( 
,$ & $%& !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  )# 
,$ ) '(_ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  )& 
,$ , )*+æ,)$ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  )) 
,$ ' $-./01$ª! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  )) 
,$ ( º»¼¸¹uv !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  )' 
5. 8 Ê!­"! ------------------------------------------------------------------------  49 
,$ + ­2! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  ,* 
é ê! ­ì(3! ---------------------------------------------------------------------  60 
'$ # ­ì !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  '- 
'$ % 3! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  '- 
4÷çî !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  '% 
5å!A! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  ', 
5å!B! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  ** 
2 
b:cd+/`eÈ.ðXf/g¤h÷wijQRY#
7·¿8k!lm0]R+R+nRopRqrXwstu^_S
<8/º\]¿ÏvÀ/Ë<8tu"w«HxNyz¿8Y7·¿8:{è
ABúw/O-\]{èAB¹,/7·¿8:{èABy|Nyz¿8j
R}~X\]¿8:UY7·¿8"wSlR5tuxw/Fß7·
¿8È*+nR+RÜRopRR¾p`qrX<8:
¦H/v>7·\]^_d`ï"<8tu/FË|}S¹/
:I<8/ËrÈYö5Ã7·\]m/£H;<*
vV/úöNvw;<xyq7·\]d*/£HöN5ü
\]ü^()/N\]<8¦Húö/ ÇN¡7<8¢t¦
H/£öï 9xY#
/ºGT½¾dÀ/7·d¤¥¦§¦H/³/0¨_m
m¶£©ªç/w´m$¿¾/w«Ã\ú$¾U\/0îÃ\¬­
m¶ú®+¯:¥*¿/À°+±Ã\w¶ú°²g³À/Z´7\]^_r
öµ`a_Sj¶¿·¸`}WaïMf/$ö¹º¼»
¼À½¾¿ÈÀ:ÁÀ+¯YÂÃTÄ7·\]^_:¥¿/¥ÅU\/
U\ï"#:ÆÇÈ9É|}YZ[/ÊË^_tuI5ü7·¿8:"ÌS
tu/*ÊË^_{7·^_:ÍÎÀÏ/Ð"^_U\xyjÑxYÒÓÔÕ
IÖ×ÊË^_tu/Øï"7·¿8tuzÓÔjÐ7Ti?@ÙIN<8
ÚaYTÄÃ\R0R`wXÛÜ:ÊË^_-ºËÝÞÛÜßà
ð/7Àï"áâüdãäå/HæçÊËdãTÄäå9è³ÊË+R
ÍÎb`ébXê/º ëìí­Ö/ØøÀîïNðñT[òîY9ºTÄ7
·\]^_<óôFõzñÉð/öàÀ÷ø`ÍÎ:ùdã^_/È{
|}()~Y Ç/%ùdãÍÎúû:()/£¯2¹,jd+!Ú
aNùdã:öFZøü÷ø:wÈý«ÍÎúû/°Vxþòùdã^
_`a/vÿTÄ:7·¿8tu/¡7<8¢t¦Hq9*ÈìíTÄ7·
\]^_: Ítu ë/vVh÷7·^_/!:¿" ë/vÿTÄº½¾
\]÷ø^_­Ö:T²?@=Y#
4 
f+Jg*+,&U#X `a|}~Ôáü"= UN]Ux¹,!,Naáü
jâü/1:Ý:;<^_:FZF=/°ÕÝ:;<^_÷ø"ÌS
:}/9°ÚaN7·\]^_Y#
º7·^_:ÊË¾p­Ö/ï":()¹&ð/6#
^#&J|ö"ÊË^_jw`^_:7/ËÀvÊË^_ &ÿJU
dT S#]+tOS#+,#YS,QRO),#(+^)+#¥ÅöÛM=:¿
Ê^_/! &ÿWJ ë¦H3+nw`ÊË^_/9«ö Í
27·\]^_{º &pUp ÷w`ÊË^_ ^,Q),mYÂÃ
Ý¦/`ÊË^_7jÜw`/*º &pQp«¥Å
`aqNÜ++¦H/`ÊË^_ø*j"«vw/r9ÈÈ¿=
(I*=/°vwU\xyY#
V))P#&Wv &pQe ò:Ð7ÍÎ^_èUT+,QS#Z+^,#]),O)#
NPtOS*RUZ]NêrItu¦H/¡`ÊË^_Èäaø¿Ü^_°
12Y#
x)+Q#&KiÍÎtuÝ}2IÕR ÍR MY
ºÕ­ÖW¡12"¢R¹£"¢Rm¤w`"¢R¥´Õ"
¢`j7· ¦"¢qº Í­ÖW¡´«°»¼"¢R§¨"¢R
©ÍÎ"¢Rª*"¢Yº M­ÖW¡ý"»j"¢Rm¤>¿"
¢RK¦"¢Rx2«"¢R¬­jFZ®¯"¢Y#
)QPS+#&Pv3 N[Z(U] M*èV)T^,°±²)Qê^_5ø*
ÍÎèUJO)*+O^Q#Z+^,#]),O)/UZ]ê`aN´7^_Yº N[Z(U]^_
ÀW¡>³y'k;]j7·dãÍÎè´]]’têRk; ÍjùÊË
è´µ²]êR¶k; ÍèNV]êY#
V^P+QR^#&Qv3O-ê··l¸():çÜ UZ]^_/°pqç¹¶v
ÿU\´º JKe*CRÇ/·»dãjùdã¾põyR¼xy`Àx
yX#Y#
V+OtJ*)O)&ÿ#X äa¹½=ÍÎ^_/°ªç¾¿:ø*ÍÎ
6 
xS^#UÿX v3èX=FZøü÷øw`^_/ºâüd+.`a@é
ï âüç1ïêÈãë/9ºÝ}­Ö`aÈìG:/ºáü­Ö£
ä@éï áüïêÈãëY'#
f^*Up#X ÆÇÛ!^_Rà|^_`à|í^_:Èý«/`aá
ü"= ([[î7ÀF¾¹,/éà|í^_öw:Èý«/knïäa
aÝ:;< V]Pÿeee è°IæY#
w)ð^+tJe#X `a YxIUIæ!öFZøü÷ø2:ìGS^_/
ÚaN¬½·ÍÎ</ Ç/®ñÈòó¹,^_:Èý«/é>?@AB
^_öw:Èý«Y#
&'J#()#
-+¯:k¹,jd+!ÚaNùdã:öFZøü÷ø:wÈý
«ÍÎúû/ùdã:Ý}2WXñºÍÎRÍÎRÊË¾pX2Y
-+¯(_:ÍÎúûöìGS:d+/°vÿËÈý«`Èa«/ôrÈ"
=»¼ÃÄõöö¶.È»¼S/F-+¯äaÈ"=»¼ÃÄõöe6
ÈIÍÎúû:,-e6/°ßèÍÎúû:÷SYÐ/raN/2^_Èý
«:øÕor{£Où/F-+¯®ñÈòF=jFúÃÄßû³F5
:Èý«FM/ï7ÀÍÎúû^_:Èý«¹,YºÍÎÔØ­Ö/Db`a
ü³±²¹±Ý¹ÍÎÈI«ÍÎ<:[/-+¯ú`aFúÍÎ</ý^_
:^ùHþ`ÿ¸^_: ÚÇ/vÿ^_:Èý«YºÍÎúû:01­
Ö/-+¯ºï FZy:!dðÐ-wAB^_R>?@AB^_R"Ó
=ãëAB^_7ÀÈý«¹,üË_S/Z[/-+¯ú5>?@AB
^_j"Ó=ãëAB^_Éj!í=>?@AB^_/`ËöìGS0
1Yrs/öFúÍÎ_S:ÍÎÔØ`í=>?@AB^_XÈÈÉ
j!öwÈý«`wÈa«:ÍÎúû/ôr-+¯`aÈ"=»¼ÃÄõö
e6Iæs!AB^_/9`ÍÎúû#Mj-:_SYs/-+¯/(
_:wÈý«:ÍÎúû£¯ÈÚaN7·+^_/úÈ`aï tu°d+
wÈý«¿8ÍÎ</9$HËÚaN%&:wÈý«ÏvY#
8 
ø*© ÈR¥§£¨@t^Ç#tO)ÇG2R=À@Q)+tO^,°G>2Üy
@ÇSg)*+,QS#STSGl°XY#
@UG#ø*Õ^_;Ü612R÷ø?Õ¤RÍÎ©R@
´ÕR4´12R=*12jÕR¼ÕaXY#
@JG#ø* ¦^_;vVj·»dãàB¾2/%jÀÍÀû
:A¶°ÍÎ¦R M\RÀ½ÍÎjæ±ÍÎR45ý§ÇR
m¤ÍÎRB&ä#@O+^,#ÙwG¨É`ÇCD45X2Y#
#
#
#
#
#
#
#
× 2.1#ø*ÍÎ^_01­E×J&#
Pùdã9T/ UZ] ^_È¹I UZxRUZµ ` UZN >ÁÜ^_Y
UZxÝ}ºÕadãFZÇ/z2FGüBHIdùYrs5³ UZx
2W¡;ÍÎÊR´«12R@´ÕR¼ÕaR4´
12R¨Õ`©ÍÎR£%J*12RKÕXâÏ2Y
UZµ#2Øò¨_¸+,¿È/ UZµ 2W¡¬LÍÎè
´Rý´Y UZN2º`2j§`7·dãÈàB¾p#@#Z+^,#O)#
M+Pt^S#])**J,^Q+O^),N#ZM]GYO UZN^_/ÀÍÀû UZN^_ë2>¾
p/°ºø*¦j Í2YÒP0îÃ\^_9T/ UZ]^_
Ü^_2ÈïP¹ðJU;#
#
#
#
#
#
#
#
#
#
#
]](#
UZµ# UZN#
NZUZÙµ# NZUZÙµ# NZUZÙµ#
ATO UZx# UZN# ATO ATP UZN# ATO ATP ATS
VEHICLE ´[Ù][#
ATP ATO ATS ATP ATO ATS
10 
´7#$%& '(& )!"#$*+& !,-.
/01 23& !,*4/56789:7;<.=>??@.A?B6C:7;8D'5=A1.
& EFG 5HI !"#$JKLMNOPQRS !"TUVWXY
Z [\]"^RS !,'_Q`abc!,defgh'ij&
  !*+k)l-& 5HI Emnopq& rs !'tJuv
!"FGwxyz&  !{|d't}~{|d I ^'
t I ^^%& '& )
d& i!!k^'T !k*+-.
/<1.KLMN.
Se H KLMN*4#$%& ' T*+&
 !"#$¡Sk¢£F-KLMN£j¤¥¦KLMN§'¨©
& Ruv!"dª« 5HI !"#$¬KLMN­'¨ ©& Ruv!
"dª« 5HI !"#$R ®¯°¦KLMN¤'¨©& Ruv!"dª
« 5HI !"#$R ±¯°-.
/@1.²SKL^.
²SKL^kyk³+´µ¶-·& S¸!,¹]ºk
f»²S¼L!,/½½¾9¿ÀÁ1Â'& E)²SÃÄÅÆÇÈ²
S-& Å H ÉÊSeËk²SÃÄ-²SÃÄÌ
Í& ÇÈ²SÎÏ/Ð7:Á7.<8:Ð7;DB.@;Ð7:D<?1Ufg²S!,
/9;D;969.<8:Ð7;DB.Ð>??@1-& §Ñ²SQ'& ÒÓÔÕ3¶-
Ö& ³²SkVe'& ¸!"#$»«fg²S!,R×Ø
ÙÚÂÛÜ& ZÝ²Sk3i')×ØÙÚ]ÞR!"#$*
+ !-Ö& ³²SßàÞ'& S¸!,»«fg²S!,'á
 !âãx I== !"[\Â'Ü& ZÝ²SkKL't} !*
+³fg²S!,änS¸-Ö&  !§åæç¹f»²S¼L
!,Â'Ü& ²SKLèEé3-ê³ëìÂíèî& ÅÆï³
²Sïðmfg²S!,z'§ÑÊxYèZ#$Â'& Ó
12 
23& ^no 5HIV 5Hõ cpKL'6qÌrÿ#\U a`'
MN OPi ]©R23& cdKLN'2e'5HI #\s4( ¤t­
uL'ê e`( ­t­ 5HI uL-.
N 2.3.23& cdKLN.
OPi. vw2xy_RKL.
jÿz{& | e`Rvwêx}~ßà'`vw2xy_R
ÜÅk'M~-LûcS y_'ên=S Un=S ,'
T@Ê'LnùêPp@Ryk-ôRvw2xy_R
KL'£MÞ]b.
/1.H6Ð.=]D<ÀÁ8D;:7;8D.
14 
/i1.VWHIÁ8BÁ:9.=]D<ÀÁ8D;:7;8D.
CPU A
CPU B
Input A
Input B
Output A
B
Output B
Power
D
a
ta
 L
in
k
N 2.6 VWHuLN
2j( » ¢J'¤JVW¡Svwpq[FGck¡SK
²'pqJ©ª¢Jkvw[}³§s4kË'J¼s4kËFG'
è§¼Â';½Ëµgkµ¾'}ËI³y_«[ ¿/1:<Á8.
=]D<ÀÁ8D86Ð1-W°öWk¨{-.
/À1.µòVWH;±±?Á?D7;:C.IÁ8BÁ:9.
Data A
Data B
Process A
Process B
O
u
tp
u
t V
e
r
ific
a
tio
n
In
p
u
t C
ir
c
u
it
CPU A
CPU B
O
u
tp
u
t V
e
r
ific
a
tio
n
In
p
u
t C
ir
c
u
it
N 2.7 µòVWHuLN
2j( s§¢J'­ÁKLºÛ¡S-WèR¤J/¦§ÂWÛ
 J $Û¥-W1[«ËÃFGVÄ 5 JVÄ R¡SK²'Ö­hè§¼
Â'Ü}ËI³y_«[|VÄ 5 JVÄ è³§ÂÚ¡SêzÇ°ö
16 
 !"#$%&'()*#
+,-# ./#
0123$%&456789:;<=>3?=@AB6C58DEFGH
I8JK9LM3NOP5QRSKTUI8JK9VW3XYZ[\]^8_
JK`abcde)QR9$%&fgDhijk3l7mno +,- pqr#
#
o 3.1 stuvo
6o 3.1 w30x t1 9Ehyz{|E3NOMgDhi}`3NO9$K
~z9N\w9N\D9N\D9N\\\
X9Nbt1x t29EhyzE3NOM83NO9$K~
z4\]\{|EST9mN\zN\ \¡
¢@:;bt2x t39Ehyz£¤E3NOMgDhi}¥3NO9$K~
z£¤\¦§\¨©\ª«b¬+­®c
+,¯ $%&)*#
6$%&'(w3NOLM°&±²³´µ¶·¸¹# º¸»¼´¼µ¶µ½¾# ¿¹ÀÁµ½¾#
Â·ÀÃ½µ»ÀÄÅÆzC5±3Ç#
tetf λλ −=)( ######################################²+,-Ä#
18 
- +,-#)*+Ê?9ø$ùVW-#
VW#
Ê?#
-# ¯# +# ­#
´# 0º¹¸´½µ»À# ³´µ¶# 0º¹¸´½µ»À# ³´µ¶#
¼# 0º¹¸´½µ»À# 0º¹¸´½µ»À# ³´µ¶# ³´µ¶#
o 3.2 )*+Ê?9VW./o
lw3 aλ -qABÈVW -./xVW ¯9./M3 bλ -qABÈVW -.
/xVW ¯9./M3'81/29LMz3\/49LMz53P$67VW
-\VW ¯\VW +\VW ­9LM)8z#
tbaetP
)(
1 )(
λλ +−
= # ²+,9Ä#
tt bab eetP
)(
2 )(
λλλ +−−
−= # ²+,:Ä#
tt baa eetP
)(
3 )(
λλλ +−−
−= # ²+,;Ä#
ttt baba eeetP
)(
4 1)(
λλλλ +−−− +−−= # ²+,-<Ä#
'=)Ê?4ËÎ3P$%&z#
tbaetR
)(
)(
λλ +−
= # ²+,--Ä#
'=)Ê?4àÎ3P$%&z#
ttt baba eeetR
)(
)(
λλλλ +−−−
−+= # ²+,-¯Ä#
20 
+,¯,+# >?@ABNO9CÎAB9$%&)*#
î@AB9NOMz º3ÓD9ø$ùVWn- +,+ pq3VWh9.
/Pno +,­ pqr#
- +,+>?@ABNO9CÎAB9ø$ùVW-#
VW#
Ê?#
-# ¯# +# ­#
´# 0º¹¸´½µ»À# ³´µ¶# 0º¹¸´½µ»À# ³´µ¶#
¼# 0º¹¸´½µ»À# 0º¹¸´½µ»À# ³´µ¶# ³´µ¶#


 
	
 	
	

o 3.4 >?@ABNO9CÎAB9VW./o
îHIÊ?6HIVW>]fNO3ÒÇHIÊ?]f6EFÊ?NO9
.TLNO3Z 0)(3 =tP cÓ3$67VW -\VW ¯\VW ­9LM)8z#
taetP
λ−
=)(1 # ²+,-9Ä#
][)1()(2
tt
ab
a ba eeptP
λλ
λλ
λ
−−
−
−
−=
# ²+,-:Ä#
])1()[(
1
1)(4
t
a
t
ab
ab
ba epeptP
λλ λλλλλ
−−
−−−
−
−=
# ²+,-;Ä#
Z=AB9$%&z#
])1()[(
1
)(
t
a
t
ab
ab
ba epeptR
λλ λλλλλ
−−
−−−
−
=
# ²+,¯<Ä#
22 
o +,-¯ -q6]T9@AABNOMVW>3EFÊ?NOMz <,<<-æ`¸
iHIÊ?NOMdòEFÊ?NOM áe3ñaZ[@AAB9$%&)*o3
$UTrgb@AABNOM9¥d3PAB9$%&Ôco +,-+-q6]
T9@AABNOMVW>3EFÊ?NOMz <,<<<áæ`¸ iHIÊ?NOMd
òEFÊ?NOM áe3ñaZ[@AAB9$%&)*o3$UTrgb@A
ABNOM9¥d3PAB9$%&Ôco +,-­-q6]T9@AABNOM
VW>3EFÊ?NOMz <,<<<¯`¸ iHIÊ?NOMdòEFÊ?NOM áe3
ñaZ[@AAB9$%&)*o3$UTrgb@AABNOM9¥d3P
AB9$%&Ôc\Èo +,-¯\o +,-+Go +,-­ 9WXÒ$TrEFÊ?
9NOMÔV3@AABNOM9cdÔd3Ç6ðT9@AABNOMVW>3
EFÊ?9NOMÔV3AB9$%&Ü9&Ôdc#
#
o 3.5 ËÎAB9$%&)*o
24 
o 3.8 EFÊ?NOMz 0.001/hrñaZ[@AAB9$%&)*o
o 3.9 EFÊ?NOMz 0.0005/hrñaZ[@AAB9$%&)*o
26 
o 3.12 EFÊ?NOMz 0.001/hrñHIÊ?NOMdòEFÊ?NOM 5%9
aZ[@AAB9$%&)*o
o 3.13 EFÊ?NOMz 0.0005/hr ñHIÊ?NOMdòEFÊ?NOM 5%
9aZ[@AAB9$%&)*o
28 
 !"#$%&'()*#
+,-# ./#
0."%123456789:;<2=>?@6%ABCDE>?@6%
ABFGH%AB6IJKLMN6OP2Q789RLST2UGVLOP=
WRXYZ[\2]NI^_`$%&'(abLcdKW[ef6%ABgh
i2jhJkl?@6%ABF#
+,m##=>kl?@6%AB)*#
n +,- opL=>kl?@6:qrsn2tu2λv789wσ v786
xy9w pµ vz{f|}9w cµ v~Zf|}9F2?@D:q 01 2
]:qU2?@78xy2?@rs:q 00 2~Zf|
}%?@}:q 01 ?@678xy2?@rs:q 10 2
Kz{f|}%?@}:q 01 F#
n +,-#=>kl?@6:qrsn#
$%&'(6:q+,-p#
)()( 111 tPAttP ⋅=∆+ # +,-#
tu2#
30 
n +,£#¤¥¦§kl?@:qrsn#
$%&'(6:q+,£p#
)()( 222 tPAttP ⋅=∆+ # +,£#
tu2#
[ ])()()()()()()(
010210 2110002
ttpttpttpttpttpttpttP
T ∆+∆+∆+∆+∆+∆+=∆+
#+,+##




















∆−∆∆
−∆∆−∆−∆∆
∆∆−∆−∆∆
−∆∆−
∆−∆∆−∆−
∆∆−
=
ttt
ttttt
ttttt
tt
tttt
tt
A
pc
ppc
cpc
p
cp
c
λµµ
σλλµµµ
σλµλµµ
σλµ
σλσλµµ
σλµ
21000
)1(21020
20102
0)1(02100
0)1(010
000021
2 ###+,¿#
[ ])()()()()()()(
010210 2110002
tptptptptptptPT = # +,À#
3e6<2 %¡¢ )(2 tP F#
32 
Ñ2ÒÓ)6ÔpF#
[ ])()()()()(
0210 30003
ttpttpttpttpttPT ∆+•••∆+∆+∆+=∆+
###+,Õ#
































∆−
•
•
•
•∆
•
•
−∆∆−∆−
••∆∆−
=
t
t
ttt
tt
A
c
cp
c
λ
µ
σλµµ
σλµ
31
3
00
00
)1(00210
00031
3
###+,Ö#
[ ])()()()()(
0210 30003
tptptptptPT •••= ############+,-×#
3e6<2 %¡¢ )(3 tP F#
+,¿##ØÙÁÂÃkl?@#
ØÙÁÂÃkl?@cd©ª45¨b6?@2tMNÚbnn +,¿ 
p2«Lª?@®cdÁÛ45¨b6'¯2«LÛ'¯5ÜÝ4562
ÁÛ'¯Þ tß¢àáâãäLÛåæàáu2GåæàáãçÁÛ'¯\
ßè2Ué0êëoåß¢\ìÒ2Á¯´µ²6¨í®v -2op Lw
 Ãî Á¯uï°±àá%]2Gð¶?@6]F·tuLª?@
¸]2Q¤¥ºLª?@2j»¼tC%AB6fF#
34 
0 1000 2000 3000 4000 5000 6000 7000 8000 9000 10000
0.82
0.84
0.86
0.88
0.9
0.92
0.94
0.96
0.98
1
Time(hr.)
P
ro
b
ab
il
it
y
 o
f 
su
cc
es
s
Repair rate is 0.5
Repair rate is 0.05
Repair rate is 0.005
n 4.6 789v 0.001/hrW5|}96%AB)*n
0 1000 2000 3000 4000 5000 6000 7000 8000 9000 10000
0.9
0.91
0.92
0.93
0.94
0.95
0.96
0.97
0.98
0.99
1
Time(hr.)
P
ro
b
ab
il
it
y
 o
f 
su
cc
es
s
Repair rate is 0.5 
Repair rate is 0.05
Repair rate is 0.005
n 4.7 789v 0.0005/hrW5|}96%AB)*n
36 
0 1000 2000 3000 4000 5000 6000 7000 8000 9000 10000
0.98
0.982
0.984
0.986
0.988
0.99
0.992
0.994
0.996
0.998
1
Time(hr.)
P
ro
b
a
b
ili
ty
 o
f 
s
u
c
c
e
s
s
Failure rate is 0.0002
Failure rate is 0.0005
Failure rate is 0.001
n 4.10 |}9v 0.05/hrW57896%AB)*n
0 1000 2000 3000 4000 5000 6000 7000 8000 9000 10000
0.995
0.9955
0.996
0.9965
0.997
0.9975
0.998
0.9985
0.999
0.9995
1
Time(hr.)
P
ro
b
a
b
ili
ty
 o
f 
s
u
c
c
e
s
s
Failure rate is 0.0002
Failure rate is 0.0005
Failure rate is 0.001
n 4.11 |}9v 0.5/hrW57896%AB)*n
###
38
#
#
#
#
#
#
#
#
#
#
#
#
#
#
} 5.1#AFGHNO}#
AFGHz9ÝÞßà(Pipeline)&'IRS¨Ô³(Fetch)Y(Decode)Y
ÀÁ(Execute):ÃÄ(Write)Ý4áâi=34VWBã²jVWÇÈä} 5.2 e
~IJKIFGHlmQ'H½QZ[\¾³VWIkåæçÄVW]^
H(Instruction register)AI©åQ'H(Program counter, PC)è 1IÐéÕ3
4VWB¾³jêëI½VW]^H³ìVWIíîÐceÆ×E
(ï^×+,BfØDðjdñIÔ³fØDðAB×EIòó×ÀÁ
×jÅIå×+,ï^ÂZ[\±]^HAj#

	


















 !

"#

$
"

%
%
40
E(Arithmetic logic unit , ALU)¨CDEB !I5Ð°Ñ²]^H
(Working register)AB:êK]^HLMABNÁ(B×I¡
×BOAIALU å×B+,<=PQ><=]^HyAjÑ²]^H|)
W ]^HI¨34CDEB]^HI9ñÛéE×89I®R>
Z[\jS27EAefB×´#9ÂW]^HI%W]^H¨
HI;ð^³I­bÛéVWñ89j&8ab]^H(Special function register , 
SFR)¨ 8 4CDEB]^HI¨9ñ^ùT÷×(ÇUab]^HB
úPI} 5.3e~ SFRe;V89B]^HabcDð3WXY
#
#
#
#
#
#
#
} 5.3#&8ab]^H#
} 5.4e~<=]^HDEab}ITZ[×+,B<=I6õ
(Reset)IÐcZ[\:>?DE_I¨5Ð,ÃÄc¿ìj
#
#
} 5.4#<=]^H#
êAIZYDCYC\X]`^_(Condition code flags)I#¶±`×
BVWÖ,a¥Ia9¨9ñb0VW¨cÀÁj
42
CLRF  f Clear f 
CLRW Clear W 
COMF  f, d Complement f 
DECF  f, d Decrement f 
DECFSZ  f, d Decrement f, Skip if 0 
INCF  f, d Increment f 
INCFSZ  f, d Increment f, Skip if 0 
IORWF  f, d Inclusive OR W with f 
MOVF  f, d  Move f 
MOVWF Move W to f 
NOP No operation 
RLF  f, d Rotate left f through Carry 
RRF  f, d Rotate right f through Carry 
SUBWF  f, d Subtract W from f 
SWAPF  f, d Swap f 
XORWF  f, d Exclusive OR W with f 
(2)ÐDE×EyVWzQ: 
           11             8   7           5   4                0 
opcode b f(FILE) 
b 3DEBDEDðIf 5DEB]^HDðj|}yVWäX 5.2e~Y
######X 5.2#ÐDE×EyVW
V#W# (#V#
BCF  f, b Bit clear f 
BSF  f, b Bit set f 
BTFSC  f, b Bit test, Skip if Clear  
BTFSS  f, b Bit test, Skip if Set  
(3)Ð¸3:×EyVWzQ: 
########## 11             8   7                                0 
opcode k(literal) 
44
(4) ;ð(Index addressing)  
Ð34S]^HBTZdè734]^HBTZIeB3×Ee¡
BDðI¨ÐQ'H(PC)Ò²S]^HIÑ²]^H(W)Ò²]^Hj
-.-#:A0&'#
yB¨9ñùõQAfA0±QIñQBDðI
BF¬®R>tZ[\I¨3«ÌÍBª«jV_B.3¹ºù¡
Z[\BI#¶Ä(Push):(Pop)B×Ö$è±jÒ
Q±A0p2I#Ä34DðÂBIÖfVWI"#
½B³Dðj
A0¨VFGHÀÁ34QIpìî00BÑ²IµFGH¹
º]ñÀÁBQIÖK5V;B/34QÀÁI_ÂÀÁiyÅId
 ¡ÀÁñBQj} 5.5 e~A0íîôõ}I&'[Ï9A0í
îI34¨mT÷'HoDe12BA0íîI/34¨m¢÷e12BA
0íîjÒA0p2Q'HåçÄA0*+I½0Q5ÂA0£¤
QIA0QÀÁi¥Å½³DðIÂñBQj
#
#
#
#
#
#
#
#
} 5.5#A0íîôõ}#
-.¦#'H§'H#
'H¨3¨|Ò6BabIa9¡>5ÐÌÍ'I®©ÀÁVW
Bª«j} 5.6 ¨345Q¬y'H/'HNO}I­p'H®è
B­p¯3üfÏ4I34¨2BÑ²°(Internal clock source)I/34¨ñ
46
-.Å#Æ>öst$%#
¡i=3FGHy&'ÅI2'vÓNÁÆ>öst$%y&'jÆ>ö
st+OyFGH$%Æ4|©+OyghIÐÇÈêÉ5Ê!y&Ëjÿ
34gh©ÀÁ|©yQIÆ4ghÊåêÌìEÍeÂ34sÎE
AIÖsÎEle©Æ4ghBÌÄI4ÅlmÏÐXsÌìBã²IÆ>ö
st+ObÑi»ÒnêA34Ó\ep2BÔÕIµ3+Oy&ÖIq¨®Æ
34ÔÕ×Ô(ØB$%jS27IÆ>öst+OyFGH$%ÙÐ
sBPQ¶ÂÉ5Ê!yBIêS2NOä} 5.7e~IÆhFGH
c°©áqr(ÏÐH(Voter)_IRSLMäÕY
} 5.7#Æ>öst+OFGH$%S2NO}#
} 5.8e~CDEopHqrS2NO}I2'v89hä} 5.8e~y
opHqrÐh=opHj¶opHyab¡>opFGHyÌì+,¨c
|©I[ÚnêÉ5Ê!IÛ2'v89|ÜèÐ)¿jP1 ( P2 RS
 3FGH( öFGHyÌìIå 3FGH( öFGHyÌì+,lm
XOR ×I5RSÂC4DEyop+,I{ÏFGHyÌì®|©IlÌì
 1IclIX~ÏFGHyÌì|©IlÌì 0j
#
#
48
#
#
#
#
#
#
#
#
#
} 5.9#ÏÐHyS2NO}#
#
#
#
#
#
#
} 5.10#©áqrNO}#
ÒFGHÀÁÂ outyVWI#gì34 reqîÂ34æç­p° 4D
EèD]^HyAI¡ 44°yÅIreq yíîå#,èDìñIéùÌìE
CsÎEIm>FGHÝÞßày+OI¡ 34°Ô³VWÅIdÂ 
Ý4°ÝçÉåVW+,gìj¶µIÓ8gìÍ¡ 24 outVWIÁ®#¥
¦y0ÌìEB+,jeÐ¡' 4 4°yÅI"5ÐÚnÌìENÄs
ÎEy0ê;yIÖë®¥¦êVWBÌì+,INÖÚnNÄsÎ
1( 10
1()( 1*)( 1()0 1*)0
!
*)+
!
()*
!
()+
00 0 000
( * ( +* +
&
50
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
} 5.11 FPGA&'£}
#
52
05HÃÄÑ²]^HWAj
} 5.14# ÆwS2VWygø}#
d*nR#5!VWI¡*n CALLYGOTO: RETLWVWICALLV
WabQIåÕ34Dð^ÄÒAIÒÀÁiQyÅI½
A³ìDðjGOTOVWabH]`5$µ kDðAÀÁVWIRETLW
VWab¨½3QQkå¸ KÃÄÑ²]^HWAI%VW
âÆ 2 4°ÇÈÀÁj} 5.15 e~ ÝwS2VWygø}¾IÒ PC
 040HIÔ³VWB¹H 94FIÀÁ CALLVWI¡ Ý4ÇÈIåÕ3
4ÀÁVWBDð 041HùÄÒAI¡ !4ÇÈ PC 04FHIÎ.ÀÁ
QBVWIi= CALLVWBã²j} 5.16e~ !wS2VWygø}
¾IÒ PC 052HIÔ³VWB¹H A57IÀÁ GOTOBVWI5$µ 057H
DðÀÁVWjmgø}¾5ù !4ÇÈ PC  057H IÔ³VWB¹H
803IÀÁ RETLWBVWIÀÁ½3QQkå¸ KÃÄÑ²]
^HWAImgø}¾5ù¡Æ4ÇÈÅIå¸3 03HÃÄÑ²]^HWAI
¡Ý4ÇÈÅIPC &½A³ìDð 041HIkÎ.ÀÁQIi=V
WBã²j  
#
54
#
#
#
#
#
#
#
#
#
#
#
} 5.17#'())*NO}#
#
#
###################} 5.18#'()yÌì}536#
#
} 5.19#'()yÌì}5ö6#
#
56
' 5.22 -./01234$pq' 
 
 
                 ' 5.23 FOPQHR34$0134%&' 
rstHR34$u7SvEw>?2xvyw>?2z& OUT T{|P7
}P)~$u70%&/T[\7' 5.24 N,JvEOBPQ
HR34$0134%&'7]%&'^8abSz&2J 026 T OUT {|
$u7rv)~PQP7vyw>?2{|56z&7Sv)~PQ
P701vEwvyw>?2%&$[\7]vEwvywT%&[\G
H70134 h %& 07+,[\GHMHP78_`TabfgbBd
e7Bh0134T%&mnoM' 5.25 N,JvyO
BPQHR34$0134%&'7]%&'^8abSz&2J026TOUT
{|$u7rv)~PQP7vEwvyw>?2{|56z&7Sv
)~PQP701vEwvyw>?2%&$[\7]vEwvyw
T%&[\FGH70134 h %& 17+,[\FGHM8_`Tabfg
58
¶·Tvw>?2T%&79§X¯~ T§¸M¹u7º»¼­ FPGA
¢9½¾¯~ T¿}M
 
' 5.26 y $%&' 
 
 
' 5.27 µ¶ $%&' 
ÀÁÂ 5Ã 
Ä}Å¿}y µ¶ =ÆÇÈ7¡¢7y 
ÇÈÉÊ>?2£0134ËÌ34~Íw7µ¶ 8pl>?2£
0134«¬/~ÍwMÎÏÐ Verilog ÑÒÓÔÃÕ¿}Ew>?27Ö
{|½¾x×Ø½¾7Ä}ÅN¿}T>?2JEwÙÚiT 7Ûu7Ü
Ý=wGHT>?27®l²vE~ÍwT¿}MºÞÐßTàá34¿}0
1347c]>?2T%&âãäåHR78ikl0134Tæm7çUè
é¿}EPQHR3479êë>?2Tìí%&[\70134TæmM
]' 5.24 ' 5.25 8±;îstHR34ï70134T%&Bfgðñ7st
HR34$u7de²fghVMr®l²vy~ÍwT¿}$ò7ºóÐ
ßTàá¿}ËÌ34«¬/7ÎwôõöTÍw79÷b®¯Ty
60 
 !"##$%&'(#
)*+#$%#
,-./01234&5-6789:/;<=>?@A;<=>BCDE
F789:GH;<1IJ?KL3MNOPQRSTUV&WXYZ[STU
V1\]LEFUV1^_`,-.ab5-Pcde1fghij?klmf
ghij1no`pq?5-6rstuth?Lvwxyz{?|}UV~x
1o`?5-6He?LmPcfghijz{1e?
Nrstuth/1A1?uth/z{A1`
?NO Verilog3MpUV\]?k Altera K
|}1 Quartus II ¡¢£?¡¢ki¤34pH¥?¦§¨8©Yª
«¬­®¯°±²lmp$³`l$³´µ?,-.K5-1;<=>?
¶%·¸6cij¹º»¼?½8¾1$³?¿À~x1o?kÁÂ
ÃÄGH;<1IJ?@ÅEFÆ789:/01` Quartus Ç¡¢£8
ÈÉ5-6jfgh^D 43865¬­®?ÊËHÌ(Critical path)A 24.3 ns?
PQRSTUV^D 150732¬­®?ÊËHÌ(Critical path)A 24.862 ns?
ÍZÎUV^D 148014¬­®?ÊËHÌ(Critical path)A 25.013 ns`
@,-.NO8©Yª«¬­®¯°±²Å6STUV?N;<=>
Ï¿Ð¢,/IJ`ÑÒÓ1ÔÕ5-Ö×AUVØÔÕ?ÙLEFÚÛÜÝ
Þ:ß1D_?@Å,-.K5-1;<=>8àáâ¡¨UVÔÕã?|}¿
À789:/äYUV`åÅ?,-.Kæç/789:/;<=>Âè8é
OÑêëÎUV?ì8NOdeíîL5-789:ïð;<h?ñòpé
OÑóô/789:õö`
)*÷#'(#
6ø?ùrs1»¼ú·ûÎüºk@ýþKÿ ?!"ýþ
#ºü$©ã%&Â'?èû(±²1)*Ý+F,-./101Â2'
*`@£Â3)*?»£»¼&4²¶5`eH?Ñ£$]678
9:?@Å£1;-ýþ8o8r?@ÿ £1»¼<r?6=
62
   !  "  #
1. $%&, “'()*+,-./”, 01234)*56789:;, pp. 1-12, 
2000. 
2. <=>89?@, “A534BCD=./EFGH”, 1999.  
3. L. Romano, Z. Kalbarczyk, R. K. Iyer, A. Mazzeo and N. Mazzocca, “Behavior 
of a computer based interlocking system under transient hardware faults”, Pacific 
Rim International Symposium on Fault-Tolerant Systems, pp. 174-179, 1997. 
4. Y. Yao and M. Cheng, “The application on dynamic fault tree analysis for 
dissimilar fault-tolerant flight control system”, Proceedings 18
th
 Digital Avionics 
Systems Conference, Vol. 1, pp. 3.B.1-1 - 3.B.1-6, 1999. 
5. J. Guo, Z. Huang and M. Liu, “Research on the Railway Safety Critical System 
with Petri nets”, 6th International Conference on ITS Telecommunications 
Proceedings, pp. 118-121, 2006. 
6. N. Stoytcheva, K. Christov and K. Mitev, “The use of CAD systems for 
investigation of electronic circuits reliability and safety and their application in 
education”, 26th International Spring Seminar on Electronics Technology: 
Integrated Management of Electronic Materials Production, pp. 163-168, 2003. 
7. Y. Min, Y. Zhou, Z. Li and C. Ye, “A fail-safe microprocessor-based system for 
interlocking on railways”, Proceedings Annual Reliability and Maintainability 
Symposium, pp. 415-420, 1994. 
8. N. Stoytcheva and M. Georgieva, “Special features in electronic circuits 
modeling for fail-safe use”, 26th International Spring Seminar on Electronics 
Technology: Integrated Management of Electronic Materials Production, pp. 
169-172, 2003. 
9. T. Kunifuji, Y. Mugiya and T. Iida, “Safety requirements about railway signaling 
system utilizing network and its implementation”, Proceedings of the 2002 IEEE 
International Symposium on Industrial Electronics, Vol. 2, pp. 579-582, 2002. 
10. Y. Min, Y. Zhou, Z. Li , C. Ye and Y. Pan, “Behavioral design and prototyping 
of a fail-safe system”, Proceedings of the Seventh International Conference on 
VLSI Design, pp. 159-162, 1994. 
11. A. K. Ghosh, B. W. Johnson and J. A. III Profeta, “Safety evaluation using 
behavioral simulation models”, International Symposium on Product Quality and 
Integrity, Reliability and Maintainability Symposium, pp. 82-89, 1996. 
64
Progress, pp. 76-79, 2005. 
24. D. Bied-Charreton, D. Guillon and B. Jacques, “The YATE fail-safe interface: 
the user's point of view”, Proceedings of the Eighth IEEE International On-Line 
Testing Workshop, pp. 233-237, 2002. 
25. A. Lewinski, “Fail-safe control method for programmable electronic systems in 
railway applications”, International Conference on Control 1991, pp. 440-442, 
1991. 
26. J. L. Dufour, “Safety computations in integrated circuits”, Proceedings of 14
th
VLSI Test Symposium, pp. 169-172, 1996. 
27. J. A. III Profeta, N. P. Andrianos, B. Yu, B. W. Johnson, T. A. DeLong, D. 
Guaspart  and D. Jamsck, “Safety-critical systems built with COTS”, Computer, 
Vol. 29, pp. 54-60, 1996. 
28. B. Pei and Y. Ming, “An Embedded Fail-Safe Interlocking System”, Proc. 1997 
Pacific Rim International Symposium on Fault-Tolerant Systems, pp. 22-27, 
1997. 
29. H. Kim, J. Lee, K Lee and H. Lee, “Design of dual-duplex system and evaluation 
of RAM”, Proceedings 2001 IEEE Intelligent Transportation Systems, pp. 
710-715, 2001. 
30. R. Dobias and H. Kubatova, “FPGA based design of the railway's interlocking 
equipments”, Euromicro Symposium on Digital System Design, pp. 467-473, 
2004. 
31. JKL, “MN/0OP)QRSTUV<EFWXYUZ[\]^_9?”, 
`a<=>87@bcd", 1996. 
32. Y. Hsu, J. W. Sheu, and K. B McQueen, “Technical Criteria of the Systemwide 
Electrical and Mechanical Design for the Mass Rapid Transit Systems of 
Taiwan”, 1993e`fg;hP)ST<i9:;, pp. 184-197, 1993. 
33. jkP)lm, “jkg;hnoP)STpqr(stuv”, 2002. 
34. wx5, “yz{<i|d”, }~, 2005. 
35. 1, “jyz{\ST_9”, `a>n7bcd", 2004. 
66
reg  [7:0] out_t; 
always @(op or s1 or s2 or mask or c_in) 
   begin 
    cout = 0; 
   case(op) // synopsys full_case parallel_case 
    ALU_ADD: {cout, out_t} = s1 + s2; 
    ALU_AND: out_t = s1 & s2; 
    ALU_CLR: out_t = 8'h00; 
    ALU_NOT: out_t = ~s1; 
    ALU_DEC: out_t = s1 - 1; 
    ALU_INC: out_t = s1 + 1; 
    ALU_IOR: out_t = s1 | s2; 
    ALU_MOV: out_t = s1; 
    ALU_MOVW: out_t = s2; 
    ALU_RLF: {cout, out_t} = {s1[7:0], c_in}; 
    ALU_RRF: {cout, out_t} = {s1[0], c_in, s1[7:1]}; 
    ALU_SUB: {cout, out_t} = s1 - s2; 
    ALU_SWP: out_t = {s1[3:0], s1[7:4]}; 
    ALU_XOR: out_t = s1 ^ s2; 
    ALU_BCF: out_t = s1 & ~mask; 
    ALU_BSF: out_t = s1 | mask; 
   endcase 
   end 
assign  rlf_out = {s1[7:0], c_in}; 
assign  rrf_out = {s1[0], c_in, s1[7:1]}; 
assign add_sub_sel = (op[3:2]==2'b0); 
mux4_8u2(.sel(op[3:2]),.in0(add_sub_out),.in1(out_next1),.in2(out_next2),.in3(out_n
ext3),.out(out)); 
mux4_8 u3(.sel(op[1:0]),.in0(s1&s2),.in1(8'h00),.in2(~s1),.in3(s1|s2),.out(out_next1)) 
mux4_8u4(.sel(op[1:0]),.in0(s1),.in1(s2),.in2(rlf_out[7:0]),.in3(rrf_out[7:0]),.out(out_
next2) ); 
mux4_8u5(.sel(op[1:0]),.in0({s1[3:0],.s1[7:4]}),.in1(s1^s2),.in2(s1&~mask),.in3(s1|m
ask),.out(out_next3)); 
mux2_8 u0(.sel(op[1]),.in0(s2),.in1(8'h01),.out(s2_a)); 
add_sub8_co u1(.sub(op[0]),.opa(s1),.opb(s2_a),.out(add_sub_out),.co(co)); 
assign c = add_sub_sel ? co : op[0] ? rrf_out[8] : rlf_out[8]; 
assign z = (out==8'h0); 
assign borrow_dc = s1[3:0] >= s2[3:0]; 
68
      7'b10_10XXX: wr_addr = {4'b0101, rf_wr_addr[2:0]}; 
      7'b10_11XXX: wr_addr = {4'b0110, rf_wr_addr[2:0]}; 
      // Bank #3 
      7'b11_10XXX: wr_addr = {4'b0111, rf_wr_addr[2:0]}; 
      7'b11_11XXX: wr_addr = {4'b1000, rf_wr_addr[2:0]};      
      default:     wr_addr = {4'b0000, rf_wr_addr[2:0]}; 
   endcase 
end 
always@(rf_rd_bnk or rf_rd_addr) begin 
   casex ({rf_rd_bnk, rf_rd_addr}) 
      // First, let's handle the locations that all get mirrored back 
      // into the bank #0 words from 8-15. 
      7'b00_01XXX: rd_addr = {4'b0000, rf_rd_addr[2:0]}; 
      7'b01_01XXX: rd_addr = {4'b0000, rf_rd_addr[2:0]}; 
      7'b10_01XXX: rd_addr= {4'b0000, rf_rd_addr[2:0]}; 
      7'b11_01XXX: rd_addr= {4'b0000, rf_rd_addr[2:0]}; 
      // Now, handle words in the upper halves of each bank. 
      // Bank #0 
      7'b00_10XXX: rd_addr = {4'b0001, rf_rd_addr[2:0]}; 
      7'b00_11XXX: rd_addr = {4'b0010, rf_rd_addr[2:0]}; 
      // Bank #1 
      7'b01_10XXX: rd_addr = {4'b0011, rf_rd_addr[2:0]}; 
      7'b01_11XXX: rd_addr = {4'b0100, rf_rd_addr[2:0]}; 
      // Bank #2 
      7'b10_10XXX: rd_addr = {4'b0101, rf_rd_addr[2:0]}; 
      7'b10_11XXX: rd_addr = {4'b0110, rf_rd_addr[2:0]}; 
      // Bank #3 
      7'b11_10XXX: rd_addr = {4'b0111, rf_rd_addr[2:0]}; 
      7'b11_11XXX: rd_addr = {4'b1000, rf_rd_addr[2:0]}; 
      default:     rd_addr = {4'b0000, rf_rd_addr[2:0]}; 
   endcase 
end 
// This logic is to bypass the register file if we are reading and 
// writing (in previous instruction) to the same register 
always @(posedge clk) 
 rd_wr_addr_equal <=  (rd_addr==wr_addr) & rf_we; 
assign rf_rd_data = rd_wr_addr_equal ? wr_data_tmp : rf_rd_data_mem; 
always @(posedge clk) 
70
input  wdt_en, wdt_clr; 
output  wdt_to; 
reg [7:0] prescaler; 
reg [7:0]  wdt; 
reg  tmr0_cnt_en; 
reg  tcki_r; 
reg  wdt_to; 
wire  tose; 
wire  tosc; 
wire  psa; 
wire [2:0]  ps; 
wire  tcki_a, tcki_b; 
wire  presclr_ce; 
wire  prsclr_clr; 
wire  wdt_to_direct; 
reg  presclr_out, presclr_out_r1; 
reg  presclr_out_next; 
wire [7:0]  presclr_plus_1, wdt_plus_1; 
wire [7:0] prescaler_next, prescaler_next1; 
wire [7:0] wdt_next, wdt_next1; 
// Inputs select 
assign ps = option[2:0]; 
assign psa = option[3]; 
assign tose = option[4]; 
assign tosc = option[5]; 
always @(posedge clk) 
 tcki_r <=  tcki; 
assign  tcki_a = tose ^ tcki_r; 
assign tcki_b = tosc ? tcki_a : 1'b1; 
assign presclr_ce = psa ? wdt_to_direct : tcki_b; 
always @(posedge clk) 
 tmr0_cnt_en <= psa ? tcki_b : presclr_out; 
// Prescaler 
assign prsclr_clr = psa ? wdt_clr : tmr0_we; 
always @(posedge clk) 
 if(rst | prsclr_clr) prescaler <= 8'h00; 
 else 
 if(presclr_ce)  prescaler <=  prescaler + 8'h01; 
72
output [7:0] portaout; 
output [7:0] portbout; 
output [7:0] portcout; 
output [7:0] trisa; 
output [7:0] trisb; 
output [7:0] trisc; 
input  tcki; 
input  wdt_en; 
// This should be set to the ROM location where our restart vector is. 
// As set here, we have 512 words of program space.
parameter PC_RST_VECTOR = 11'h000, // Should be: 11'h7FF, 
  STAT_RST_VALUE = 8'h18, 
  OPT_RST_VALUE = 8'h3f, 
  FSR_RST_VALUE = 7'h0, 
  TRIS_RST_VALUE = 8'hff; 
Parameter  ALU_ADD  = 4'h0, 
  ALU_SUB  = 4'h1, 
  ALU_INC  = 4'h2, 
  ALU_DEC  = 4'h3, 
  ALU_AND  = 4'h4, 
  ALU_CLR  = 4'h5, 
  ALU_NOT  = 4'h6, 
  ALU_IOR  = 4'h7, 
  ALU_MOV  = 4'h8, 
  ALU_MOVW = 4'h9, 
  ALU_RLF  = 4'ha, 
  ALU_RRF  = 4'hb, 
  ALU_SWP  = 4'hc, 
  ALU_XOR  = 4'hd, 
  ALU_BCF  = 4'he, 
  ALU_BSF  = 4'hf; 
parameter// Byte Oriented RF Operations 
  I_ADDWF  = 12'b0001_11??_????, 
  I_ANDWF  = 12'b0001_01??_????, 
  I_CLRF  = 12'b0000_011?_????, 
  I_CLRW  = 12'b0000_0100_0000, 
  I_COMF  = 12'b0010_01??_????, 
  I_DEC  = 12'b0000_11??_????, 
74
parameter// Source 1 Select 
  K_SEL  = 2'b10, 
  SFR_SEL  = 2'b00, 
  RF_SEL  = 2'b01; 
parameter// STATUS Register status bits we 
  STAT_WR_C = 3'b001, 
  STAT_WR_DC = 3'b010, 
  STAT_WR_Z = 3'b100; 
// Instruction Register 
reg  rst; 
reg  [11:0] instr_0, instr_1; 
reg  rst_r1, rst_r2; 
wire  valid; 
reg  valid_1; 
reg  [7:0] mask; 
reg  [7:0] sfr_rd_data; 
reg  [3:0] alu_op; 
reg    src1_sel; 
reg  [1:0] src1_sel_; 
wire [7:0]  dout;  // ALU output 
wire [7:0] src1;  // ALU Source 1 
reg  [2:0] stat_bwe; // status bits we 
wire  c_out, dc_out, z_out; 
reg  pc_skz, pc_skz_; 
reg  pc_bset, pc_bset_; 
reg  pc_bclr, pc_bclr_; 
reg  pc_call, pc_call_; 
reg  pc_goto, pc_goto_; 
reg  pc_retlw, pc_retlw_; 
wire  invalidate_1; 
wire  invalidate_0_; 
reg  invalidate_0; 
// stage 1 dst decode 
reg  w_we_; 
reg  rf_we_; 
reg  sfr_we_; 
reg  tris_we_; 
// stage 2 dst decode 
76
reg  [7:0] status;   // Status Register 
wire [7:0] status_next; 
reg  [6:0] fsr;   // fsr register ( for indirect addressing) 
wire [6:0]  fsr_next; 
reg  [7:0] tmr0;   // Timer 0 
reg  [5:0] option;   // Option Register 
// Tristate Control registers.  
reg [7:0] trisa; 
reg [7:0] trisb; 
reg [7:0] trisc; 
// I/O Port registers 
reg [7:0] porta_r; // PORTA input register 
reg [7:0] portb_r; // PORTB input register 
reg [7:0] portc_r; // PORTC input register 
reg [7:0] portaout; // PORTA output register 
reg [7:0] portbout; // PORTB output register 
reg [7:0] portcout; // PORTC output register 
//////////////////////////////////////////////////////////////////////// 
// External Reset is Synchrounous to clock 
always @(posedge clk) 
 rst <=  rst_in; 
//////////////////////////////////////////////////////////////////////// 
// Synchrounous Register File 
register_file u0(.clk(clk ),.rst(rst),.rf_rd_bnk(rf_rd_bnk),.rf_rd_addr(rf_rd_addr), 
.rf_rd_data(rf_rd_data),.rf_we(rf_we),.rf_wr_bnk(rf_wr_bnk),.rf_wr_addr(rf_wr_addr
),.rf_wr_data(rf_wr_data)); 
//////////////////////////////////////////////////////////////////////// 
// Always Fetch Next Instruction 
always @(posedge clk) 
 instr_0 <= inst_data; 
//////////////////////////////////////////////////////////////////////// 
// Instr Decode & Read Logic 
always @(posedge clk) 
   begin 
 rst_r1 <=  rst | wdt_to; 
 rst_r2 <=  rst | rst_r1 | wdt_to; 
   end 
assign valid = ~rst_r2 & ~invalidate_1; 
78
// ALU OP 
always @(posedge clk) 
   casex(instr_0) // synopsys full_case parallel_case 
     // Byte Oriented RF Operations 
      I_ADDWF: alu_op <=  ALU_ADD; // ADDWF 
      I_ANDWF: alu_op <=  ALU_AND; // ANDWF 
      I_CLRF: alu_op <=  ALU_CLR; // CLRF 
      I_CLRW: alu_op <=  ALU_CLR; // CLRW 
      I_COMF: alu_op <=  ALU_NOT; // COMF 
      I_DEC: alu_op <=  ALU_DEC; // DEC 
      I_DECFSZ: alu_op <=  ALU_DEC; // DECFSZ 
      I_INCF: alu_op <=  ALU_INC; // INCF 
      I_INCFSZ: alu_op <=  ALU_INC; // INCFSZ 
      I_IORWF: alu_op <=  ALU_IOR; // IORWF 
      I_MOV: alu_op <=  ALU_MOV; // MOV 
      I_MOVWF: alu_op <=  ALU_MOVW; // MOVWF 
      I_RLF: alu_op <=  ALU_RLF; // RLF 
      I_RRF: alu_op <=  ALU_RRF; // RRF 
      I_SUBWF: alu_op <=  ALU_SUB; // SUBWF 
      I_SWAPF: alu_op <=  ALU_SWP; // SWAPF 
      I_XORWF: alu_op <= ALU_XOR; // XORWF 
     // Bit Oriented RF Operations 
      I_BCF: alu_op <=  ALU_BCF; // BCF 
      I_BSF: alu_op <=  ALU_BSF; // BSF 
     // Literal & Controll Operations 
      I_ANDLW: alu_op <=  ALU_AND; // ANDLW 
      I_IORLW: alu_op <=  ALU_IOR; // IORLW 
      I_MOVLW: alu_op <=  ALU_MOV; // MOWLW 
      I_RETLW: alu_op <=  ALU_MOV; // RETLW 
      I_XORLW: alu_op <=  ALU_XOR; // XORLW 
   endcase 
// Source Select 
// This CPU source 1 can be one of: rf (or sfr) or k, 
// second source (if any) is always w 
always @(instr_0) 
   casex(instr_0) // synopsys full_case parallel_case 
      I_ANDLW: src1_sel_ = K_SEL; 
      I_CALL: src1_sel_ = K_SEL; 
80
     begin 
   rf_we_ = instr_0[5] & (instr_0[4] | instr_0[3]);
   sfr_we_ = instr_0[5] & ~instr_0[4] & ~instr_0[3]; 
     end 
    I_MOVWF, I_CLRF, I_BCF, I_BSF:  // only f 
     begin 
   rf_we_ = instr_0[4] | instr_0[3]; 
   sfr_we_ = ~instr_0[4] & ~instr_0[3]; 
     end 
    I_CLRW, I_IORLW, I_MOVLW, 
    I_ANDLW, I_RETLW, I_XORLW: w_we_ = 1; // only w
    I_TRIS:   tris_we_ = 1; // trisa or trisb or trisc 
 endcase 
   end 
assign indf_we_ = sfr_we_ & (instr_0[2:0] == INDF_ADDR); 
assign   pc_we_   = sfr_we_ & (instr_0[2:0] == PCL_ADDR); 
// Stage 2 destination encoder 
// write enable outputs are registered now 
always @(posedge clk) w_we <=  w_we_; // working register write 0 enable 
always @(posedge clk) w_we1 <=  w_we1_; // working register write 1 enable 
// Register File Write Enable is composed of thee conditions: 1) direct register writing 
(0x10-0x1f);// 2) Direct Global Register writing (0x08-0x0f), and 3) Indirect Register 
File Writing// The logic has been partitioned and balanced between the decode and 
execute stage ... 
assign rf_we = rf_we1 | (rf_we2 & rf_we3);// register file write enable Composite 
always @(posedge clk) 
 rf_we1 <=  valid & rf_we_;   // register file write enable 1 
always @(posedge clk) 
 rf_we2 <=  valid & (fsr_next[4] | fsr_next[3]);// register file write enable 2  
always @(posedge clk) 
 rf_we3  <=  indf_we_;    // register file write enable 3 
always @(posedge clk) 
 wdt_clr  <=  instr_0[11:0] == I_CLRWDT; 
always @(posedge clk) 
 opt_we  <=  instr_0[11:0] == I_OPTION; 
always @(posedge clk) 
 trisa_we <=  tris_we_ & (instr_0[2:0] == PORTA_ADDR); 
always @(posedge clk) 
82
 pc_skz   <=  valid & pc_skz_; 
 pc_bset  <=  valid & pc_bset_; 
 pc_bclr  <=  valid & pc_bclr_; 
 pc_call  <=  valid & pc_call_; 
 pc_goto  <=  valid & pc_goto_; 
 pc_retlw <=  valid & pc_retlw_; 
   end 
assign invalidate_0_ = (pc_call_ | pc_goto_ | pc_retlw_ | pc_we_); 
always @(posedge clk) 
    invalidate_0 <=  invalidate_0_; 
// Status bits WE 
always @(posedge clk) 
   begin 
 stat_bwe <=  0; 
 if(valid) 
 casex(instr_0) // synopsys full_case parallel_case
       // Byte Oriented RF Operations 
    I_ADDWF: stat_bwe <= STAT_WR_C | STAT_WR_DC | STAT_WR_Z; 
    I_ANDWF: stat_bwe <=  STAT_WR_Z; 
    I_CLRF: stat_bwe <=  STAT_WR_Z; 
    I_CLRW: stat_bwe <=  STAT_WR_Z; 
    I_COMF: stat_bwe <=  STAT_WR_Z; 
    I_DEC: stat_bwe <=  STAT_WR_Z; 
    I_INCF: stat_bwe <=  STAT_WR_Z; 
     I_IORWF: stat_bwe <=  STAT_WR_Z; 
    I_MOV: stat_bwe <=  STAT_WR_Z; 
    I_RLF: stat_bwe <=  STAT_WR_C; 
    I_RRF: stat_bwe <=  STAT_WR_C; 
    I_SUBWF: stat_bwe <= STAT_WR_C | STAT_WR_DC | STAT_WR_Z; 
    I_XORWF: stat_bwe <=  STAT_WR_Z; 
       // Literal & Controll Operations 
    I_ANDLW: stat_bwe <=  STAT_WR_Z; 
    //I_CLRWDT: // Modifies TO & PD   *** FIX ME *** 
    I_IORLW: stat_bwe <=  STAT_WR_Z; 
    //I_SLEEP:   // Modifies TO & PD   *** FIX ME *** 
    I_XORLW: stat_bwe <=  STAT_WR_Z; 
 endcase 
 end 
84
always @(posedge clk) 
 if(rst)   trisc <=  TRIS_RST_VALUE; 
 else 
 if(trisc_we & valid_1) trisc <=  w; 
always @(posedge clk) 
 if(rst)   option <=  OPT_RST_VALUE; 
 else 
 if(opt_we & valid_1) option <=  w[5:0]; 
always @(posedge clk) 
 if(porta_we & valid_1) portaout <=  dout; 
always @(posedge clk) 
 if(portb_we & valid_1) portbout <=  dout; 
always @(posedge clk) 
 if(portc_we & valid_1) portcout <=  dout; 
always @(posedge clk) 
   begin 
 porta_r <=  portain; 
 portb_r <=  portbin; 
 portc_r <=  portcin; 
   end 
/////////////////////////////////////////////////////////////////////// 
// Timer Logic 
//assign tmr0_next = tmr0_we ? dout : tmr0_cnt_en ? tmr0_plus_1 : tmr0; 
//assign tmr0_next = tmr0_we ? dout : tmr0_cnt_en ? (tmr0 + 1) : tmr0; 
mux2_8 u5( .sel(tmr0_we& valid_1),.in0(tmr0_next1), .in1(dout),.out(tmr0_next) ); 
mux2_8 u6( .sel(tmr0_cnt_en).,in0(tmr0), .in1(tmr0_plus_1),.out(tmr0_next1) ); 
inc8 u7( .in(tmr0), .out(tmr0_plus_1) ); 
always @(posedge clk) 
 tmr0 <=  tmr0_next; 
presclr_wdt u8(.clk(clk),.rst(rst),.tcki(tcki),.option(option[5:0]),.tmr0_we(tmr0_we & 
valid_1), .tmr0_cnt_en(tmr0_cnt_en),.wdt_en(wdt_en),.wdt_clr( wdt_clr & valid_1), 
.wdt_to(wdt_to)); 
//////////////////////////////////////////////////////////////////////// 
// Programm Counter Logic 
always @(posedge clk) 
 pc_r2 <=  pc_r; 
always @(posedge clk) 
 if(rst)  inst_addr <=  PC_RST_VECTOR; 
86
output [11:0] inst_data; 
output [7:0] w; 
input  tcki; 
input  wdt_en; 
//////////////////////////////////////////////////////////////////////// 
// Local Wires 
wire [7:0] w; 
wire [10:0] inst_addr; 
wire [11:0] inst_data; 
wire [7:0] portain; 
wire [7:0] portbin; 
wire [7:0] portcin; 
wire [7:0] portaout; 
wire [7:0] portbout; 
wire [7:0] portcout; 
wire [7:0]  trisa; 
wire [7:0] trisb; 
wire [7:0] trisc; 
//////////////////////////////////////////////////////////////////////// 
// IO Buffers 
assign porta[0] = trisa[0] ? 1'bz : portaout[0]; 
assign porta[1] = trisa[1] ? 1'bz : portaout[1]; 
assign porta[2] = trisa[2] ? 1'bz : portaout[2]; 
assign porta[3] = trisa[3] ? 1'bz : portaout[3]; 
assign porta[4] = trisa[4] ? 1'bz : portaout[4]; 
assign porta[5] = trisa[5] ? 1'bz : portaout[5]; 
assign porta[6] = trisa[6] ? 1'bz : portaout[6]; 
assign porta[7] = trisa[7] ? 1'bz : portaout[7]; 
assign portb[0] = trisb[0] ? 1'bz : portbout[0]; 
assign portb[1] = trisb[1] ? 1'bz : portbout[1]; 
assign portb[2] = trisb[2] ? 1'bz : portbout[2]; 
assign portb[3] = trisb[3] ? 1'bz : portbout[3]; 
assign portb[4] = trisb[4] ? 1'bz : portbout[4]; 
assign portb[5] = trisb[5] ? 1'bz : portbout[5]; 
assign portb[6] = trisb[6] ? 1'bz : portbout[6]; 
assign portb[7] = trisb[7] ? 1'bz : portbout[7]; 
assign portc[0] = trisc[0] ? 1'bz : portcout[0]; 
assign portc[1] = trisc[1] ? 1'bz : portcout[1]; 
88
 ! B))*+,-.%&'(!)
Delay_cntr =  0CH 
      org  =  00H              //%&/01 223 4567)
      goto   Start               //%&/ Start4589
Start   
bsf  03h,5          ;      //:;< 1=
movlw  #b>00000000? ; 
movwf  06h            ;   //:;@ BA RB0-RB7BCDE
bcf  03h,5          ;      //FG< 0=
      bcf  03h,0          ;      //HIJ0KL CB 0 
movlw  #b>11111111? ;   //:;M6$ 10HANOB FFH 
movwf  10h            ; 
Loop 
      rrf  10h,1            ;     //8P LEDQRSTUVWX 10HANOY
J0KL CZ[\]^_  
      movf   10h,0          ; 
      movwf  06h            ;   //` LEDM6$(10H)ANO/@ BEaA
LEDbcDd
      movlw  #H>5?        ; 
      movwf  Delay_cntr     ; 
      call   Delay          ;     //efghi%&Vgh 0.5j
      btfsc  10h,0          ;     //kl RB0EmnU(“0”)VompqrsZ
tuvw89
      goto   Loop         ;      //RB.0xB 0qy LOOP 89
      goto   Start          ;      //RB.0B 0qy Start89
////////////////////////////////////////////////////////////////////////////////////////// 
/////             ghi%&
////////////////////////////////////////////////////////////////////////////////////////// 
Delay 
D_1   movlw  #D>100?      ; 
      movwf  0dH            ; 
D_2   movlw  #D>200?      ; 
      movwf  0eH            ; 
 !"#$%&'()*+,-./012
34'(5678)*9:;<=>+?@ABCD='(+,EFGHIJK
LMNOPQ+,RS1ETU=KL=VWHXYZ[\E]^_ =`abc
deFG@f[1Hg3%h=iO[jHklmnKLopqYrd0st
1. 34'(5678)*9:;<=>+?@ABCDqYrd0s
u22>+AB
v w>+ABM3xypz 100{|}`
v ~2
v ~
v kl8
xy
2. '(+,eFG@f[1Hg3%hoC
u[12vw[1E2v2v2
%hv2vg32v2
v2v2v2
klMz 100{|}`2
3. 3FG+4=G="VWop0s'(+,EFGHIJK
LMNOPQ+,RS1ETU=KL=VWHXYZ[\E]^_ M`z
500{|}`
2
)*EG+,7 ¡¢;£¤¥¦m}§¨©ª«¬­®¯°
±1²³7´µ;¶E[\·¸Fdq)*p¹ºh»¼½+t2
¾¿pÀÁÂÃÄÅÆ'(+,ÇÀÁÈÉÊËÌÆÍÎpÏÐÑÒ¬Ò
ÓÔÕÖ×ØÙÚÛ=Ò¬Ü5Ö×ØÙÚÛpÝ$ØÙ¢qÞßàÊ
ËÌáâ¬­¢;ãEä3pÐÑ¬­¢;åæEçèÚÛpÝ$¢;åæ
Eé¢qt2
2
2
 
97 年度專題研究計畫研究成果彙整表 
計畫主持人：王文智 計畫編號：97-2221-E-235-007-MY3 
計畫名稱：軌道運輸系統之監控技術開發--子計畫二：高可靠度車載設備控制核心之分析與設計 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 1 1 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 2 2 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 1 1 50%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
