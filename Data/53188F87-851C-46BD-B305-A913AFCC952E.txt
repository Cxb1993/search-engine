 1
 
 
行政院國家科學委員會專題研究計畫成果報告 
 
無憑證公開金鑰密碼系統 
Certificateless Public-Key Cryptosystems 
 
計畫編號：NSC 95-2221-E-008-045-MY2 
執行期限：95 年 8 月 1 日至 97 年 7 月 31 日 
主持人：顏嵩銘  國立中央大學 資訊工程系 
e-mail address: yensm@csie.ncu.edu.tw 
http://www.csie.ncu.edu.tw/~yensm
 
一、中文摘要 
 
本計畫於兩年之執行期間，對無憑證
公開金鑰密碼系統進行深入分析與研
究。於第一年度，本計畫已對該類型密碼
系統所大量使用之雙線性函數進行研
究，並對植基於雙線性函數之簽章批次驗
證演算法提出了強大且可行之偽造攻
擊。本計畫本年度則將研究方向延伸至公
開金鑰密碼系統中之數個重要議題，包含
數位簽章所牽涉之隱私權問題，數位簽章
之公平交換問題，以及金鑰管理中之金鑰
恢復機制。 
於數位簽章之隱私權問題方面，本計
畫本年度對文獻中之提名式簽章及相關
攻擊，進行分析與證明，並以相當嚴謹的
方式指出了文獻中攻擊方式的錯誤之
處。此部份之成果與第一年度之研究成果
具有相當之連慣性，均使用了數位簽章中
一種較弱的驗證性定義。 
於簽章之公平交換部份，本計畫所提
出之成果可分為兩大部份。首先，本計畫
探討近期文獻中一種十分新穎之同步生
效簽章建構方式；除了指出該建構方式下
一個實際範例之錯誤外，亦以相當結構化
的模式對該建構方式之可能性做出分
析。本計畫亦將研究範圍推廣至多人環境
下之同步生效簽章；除了指出文獻中多人
同步生效簽章於安全性定義上之不足
外，也在實際的範例系統中找到相對應之
攻擊。此外，本計畫也提出了一個多人之
同步生效簽章系統，該系統於安全性、公
平性、效率及可行性上皆有優秀之表現，
且為目前文獻中唯一安全之多人同步生
效簽章。 
於金鑰恢復機制部份，本計畫亦將研
究範圍推廣至多人環境，討論由多人分享
之機密文件的金鑰恢復問題。此一問題雖
然可以藉由少數現存文獻中之金鑰恢復
機制所解決，但本計畫所提出之解決方案
於許多方面具有較佳之效率。上述之三大
主題皆為廣義之公開金鑰密碼系統研究
中相當關鍵且重要之主題，因此對於無憑
證公開金鑰系統之研究，亦有相當的參考
價值。 
 
關鍵詞：無憑證公開金鑰系統、提名式簽
章、同步生效簽章，多人同步生效
簽章、金鑰恢復系統。 
 
 3
[1] Hsi-Chung Lin, Sung-Ming Yen, and Yi- 
Hsiung Huang, “Security reconsideration 
of the Huang-Wang nominative 
signature,” Information Sciences, Vol.178, 
Elsevier, pp.1407-1417, 2008. 
[2] Huanzhong Huang, Hsi-Chung Lin, and 
Sung-Ming Yen, “On the possibility of 
constructing concurrent signatures from 
conditional signatures,” In Proc. of the 
18th Cryptology and Information Security 
Conference (CISC 2008), pp.97-107, 
Hualian, May 2008.  
[3] Chieh-Tai Shieh, Hsi-Chung Lin, and 
Sung-Ming Yen, “Fair multi-party 
concurrent signatures,” In Proc. of the 
18th Cryptology and Information Security 
Conference (CISC 2008), pp.108-118, 
Hualian, May 2008. (Received the Best 
Student Paper Award) 
[4] 簡嘉齡、林熙中、顏嵩銘，“金鑰恢復
系統之研究與實作”，2007年全國電信
研討會 （NST2007），48-52頁，台北，
2007年11月。 
 
3.1  提名式簽章之安全性分析 
論文[1]探討數位簽章所牽涉的隱私
權問題。簽章的可公開驗證性（public 
verifiability）為標準型之數位簽章系統的
關鍵特性之一。此一特性雖然使得許多應
用中所需的認證性或完整性等安全需求
得以滿足，卻也在許多應用中，侵害了使
用者的隱私權。以醫院之病歷系統為例，
對病歷進行簽署雖然可以使得病歷之完
整性與認證性獲得保障，但標準型之數位
簽章的可公開驗證性，確使得病人之隱私
權於病歷因某種原因而被揭露的同時，受
到了徹底之侵犯。 
於不可否認簽章（ undeniable sig- 
natures）中，欲驗證簽章之使用者必須與
簽章者進行一互動式的協定，方能驗證該
待驗簽章之正確性；十分類似地，於指定
確認者簽章（confirmer signatures）中，欲
驗證簽章之使用者必須與（由簽章者所指
定之）某一特定單位進行互動式的協定，
方能驗證該待驗簽章之正確性。另一方
面，於非互動之前提下，指定驗證者簽章
（designated verifier signatures）與暗門雜
湊簽章（chameleon signatures）均允許簽
章者於產生簽章時，指定特定之驗證者，
使得指定驗證者外之使用者，無法進行簽
章驗證（指定的方式大多將指定驗證者之
公開資訊加入簽署之演算法，使得驗證演
算法之輸入必須包含指定驗證者之私密
資訊）。 
上述之數種數位簽章變形均以某種
方式限制了簽章的可驗證性，也因此使用
者之隱私權受到了一定程度之保障。然
而，上述數種方式皆無法適用於前述之病
歷應用系統：上述方式之設計理念皆以簽
章者之隱私權為考量重點。而於病歷之應
用範例中，簽章之可公開驗證性所損害的
並非簽章者之隱私，而是某一特定使用者
（即病人）之隱私；因此，互動驗證協定
之執行與否，指定驗證者之指定，均不應
該由簽章者（即醫院）所決定。特別強調，
病歷系統之應用範例並非特例，於相當多
的應用環境中，都需要類似的隱私權考
量；並非所有待簽署之敏感資訊的管轄權
皆屬於簽章者。例如銀行之客戶信用紀錄
系統、學校之成績單管理系統等等。 
針對上述問題，文獻[17]首次提出了
提名式簽章（nominative signatures）的概
念，除了標準簽章所必須俱備之不可偽造
性（unforgeability）外，尚必須滿足以下
兩大需求： 
1. 僅被提名人（nominee，即範例中之病
人）有能力驗證提名人（nominator，
即範例中之醫院及簽章者）產生之簽
章；即使提名人亦無法自行驗證簽章
之正確性。 
2. 必要時，僅被提名人有能力說服（確
認及證明）第三者簽章之正確性；提
名人並無法說服第三者。 
除了指出文獻[17]中所提出之範例系
統並無法完全滿足上述兩需求外，文獻[12]
也提出了一個安全的提名式簽章。文獻[12]
與文獻[17]所提出之方法最主要的差異在
於前者簽署的過程已修正為一互動式的協
 5
1. 起始簽章者 A 傳送欲交換之簽章σA
的部份結果σA’予對應簽章者 B；並
將σA之其他部份保密，留作能使簽
章生效之關鍵值 keystone 使用。 
2. 對應簽章者 B 產生一條件式簽章
σB，並設定條件為σA 生效（即
keystone 公佈）。當 keystone 尚未
公佈前，σB並無法被任意第三者視
為對應簽章者 B 所簽署之合法簽
章。 
3. 參與者 A 公佈 keystone, 使雙方之
簽章σA、σB同時生效。 
本計畫於論文[2]中，探討以條件式簽
章建構同步生效簽章之不可能性，主要包
含了以下的數點觀察。首先，於文獻[5]中
所提出範例系統中所使用之條件式簽章，
並無法滿足文獻[7]所定義之條件式簽章
所須的安全性質—於條件成立之前，該條
件式簽章已經具有可公開驗證的特徵。此
一缺陷使得所建構出之同步生效簽章範例
中，對應簽章者於第二步驟所產生之條件
式簽章於起始簽章者公佈 keystone 前即具
有可公開驗證之特徵。對於此一觀察之正
確性，本計畫於論文 [2]中，利用一個 
Schnorr 簽章之變形，對該條件式簽章範例
進行安全性之推導與證明。 
再次強調，上述之觀察僅能說明文獻
[5]中所建構之範例不正確，並無法說明以
條件式簽章建構同步生效簽章之概念不可
行。對於此一進階研究問題，論文[2]提出
了嚴謹的討論與分析，詳細內容細節請參
考附錄之論文全文。茲就分析結論條列概
述如下： 
1. 文獻[5]中之同步生效簽章範例之所
以能確保對應簽章者B得以於σB被使
用時取得σA，乃由於其所使用之（錯
誤的）條件式簽章的“條件可回復性
（condition recoverability）＂。 
2. 條件可回復性與文獻[7]中定義之條
件式簽章相互矛盾，因此並不存在具
有條件可回復性之條件式簽章，所以
欲以該特徵建構同步生效簽章並不可
行。 
3. 是否存在另一類具有某些特殊性質之
條件式簽章得以用來建構同步生效簽
章？此一問題尚待後續研究。 
 
3.3  公平之多人同步生效簽章 
對於同步生效簽章之研究，除了建構
方式之探討，本計畫亦嘗試將同步生效簽
章推廣至多人之應用環境。多人之同步生
效簽章首次於文獻[10]中被討論，然而該
文獻系利用雙線性函數之特殊性質以達成
三人之同步生效簽章。 
真正的多人同步生效簽章於文獻[6]
中首次提出，該文獻使用環簽章做為主要
的建構元件。於兩人的同步生效簽章系統
中，環簽章之所以能夠不經額外修改便直
接做為建構元件的關鍵，在於兩人環境
下，非我即你之良好特徵。更精確地說，
於同步生效簽章之簽章交換過程中，在單
一同步生效簽章（即一個包含兩個環成員
之環簽章）未生效前，參與者甲可以輕易
的確認該簽章是否為參與者乙所產生。 
於多人之環境下，由於任何環成員皆
可能為簽章者之特性，使得狀況變得較為
複雜。以三人之同步生效簽章為例，當參
與者甲收到另外兩份未生效簽章時，並無
法確認其中包含一份參與者乙及一份參與
者丙之未生效簽章。面對此一問題，文獻
[6]將 Diffie-Hellman 金鑰交換結構大量地
加入簽署演算法中，使得任一參與者得以
檢驗未生效簽章之來源。 
此外，由於多人環境中的安全性考量
亦較為複雜，由單一參與者單獨持有關鍵
值 keystone 之方式已無法適用。因此，文
獻[6]中所提出之多人同步簽章使用了多
個關鍵值，包含了由起始參與者所獨立產
生持有之群體關鍵值，以及分別由各參與
者所分別產生持有之個人關鍵值。 
然而，文獻[6]所提出之多人同步生效
簽章不論在安全性定義上或是實際演算法
上，都存在嚴重的謬誤或缺陷，茲整理條
 7
文[4]中所提出之金鑰恢復系統也可以推
廣三人以上，甚至多個金鑰恢復主機之環
境。論文[4]之詳細內容與實作細節請參考
附錄之論文全文。 
 
 
四、計畫成果自評 
 
綜觀以上計畫緣由與目的及結果與
討論，我們可以清楚地看出本研究計畫於
本年度之研究成果確實有其重要性與實
用價值。 
於數位簽章的隱私權議題上，本計畫
本年度提出對提名式簽章之深入安全分
析。而於簽章的公平交換議題上，本年度
探討了同步生效簽章之建構方式，也將研
究推廣至多人之應用架構。最後，於公開
金鑰管理的主題上，本年度提出了一個適
用於多人分享文件之金鑰恢復機制 
整體而言，本年度在進度控制、研究
成果、達成目標等各方面均控制得當，且
激發了諸多未來可能的研究方向。 
 
 
 
五、參考文獻 
 
—本計畫所發表之論文— 
[1] Hsi-Chung Lin, Sung-Ming Yen, and Yi- 
Hsiung Huang, “Security reconsideration of 
the Huang-Wang nominative signature,” 
Information Sciences, Vol.178, Elsevier, 
pp.1407-1417, 2008. 
[2] Huanzhong Huang, Hsi-Chung Lin, and 
Sung-Ming Yen, “On the possibility of 
constructing concurrent signatures from 
conditional signatures,” In Proc. of the 18th 
Cryptology and Information Security 
Conference (CISC 2008), pp.97-107, 
Hualian, May 2008. 
[3] Chieh-Tai Shieh, Hsi-Chung Lin, and 
Sung-Ming Yen, “Fair multi-party 
concurrent signatures,” In Proc. of the 18th 
Cryptology and Information Security 
Conference, (CISC 2008), pp.108-118, 
Hualian, May 2008. 
[4] 簡嘉齡、林熙中、顏嵩銘，“金鑰恢復系
統之研究與實作”，2007 年全國電信研討
會（NST2007），48-52 頁，台北，2007
年 11 月。 
 
—其他參考文獻— 
[5] Y.C. Chen and S.M. Yen, “Balanced 
concurrent signature,” In Proc. of the 16th 
Information Security Conference (ISC 
2006), pp. 25-32, 2006. 
[6] D. Tonien, W. Susilo, and R. Safavi-Naini, 
“Multi-party concurrent signatures,” 
Information Security － ISC 2006, LNCS 
4176, Springer-Verlag, pp. 131-145, 2006. 
[7] M. Klonowski, M.Kutylowski, A.Lauks, 
and F. Zagόrski, “Conditional digital 
signatures,” Trust, Privacy and Security in 
Digital Business－TrustBus 2005, LNCS 
3592, Springer-Verlag, pp. 206-215, 2005.  
[8] K. Nguyen, “Asymmetric concurrent sig- 
natures,” Information and Communication 
Security － ICICS 2005, LNCS 3783, 
Springer-Verlag, pp. 181-193, 2005. 
[9] W. Susilo and Y. Mu, “On the security of 
nominative signatures,” Information 
Security and Privacy－ACISP 2005, LNCS 
3574, Springer-Verlag, pp. 329-335, 2005. 
[10] W. Susilo, and Y. Mu, “Tripartite 
concurrent signatures,” In Proc. of the 20th 
IFIP International Information Security 
Conference (IFIP/SEC 2005), Springer- 
Verlag , pp. 425-441, 2005. 
[11] L. Chen, C. Kudla, and K.G. Paterson, 
“Concurrent signatures”, Advances in 
Cryptology － EUROCRYPT 2004, LNCS 
3027, Springer-Verlag, pp. 287-305, 2004. 
[12] Z.J. Huang and Y.M. Wang, “Convertible 
nominative signatures,” Information 
Security and Privacy－ACISP 2004, LNCS 
3108, Springer-Verlag, pp. 348-357, 2004. 
[13] S. S. Al-Riyami, and K. G. Paterson, 
“Certificateless public key cryptography,” 
Advances in Cryptology － ASIACRYPT 
2003, LNCS 2894, Springer-Verlag, pp. 
452-473, 2003. 
[14] E. Bresson, J. Stern, and M. Szydlo, 
“Threshold ring signatures and applications 
to ad-hoc groups,” Advances in Cryptology
Author's personal copy
Security reconsideration of the Huang–Wang
nominative signature
Hsi-Chung Lin, Sung-Ming Yen *, Yi-Hsiung Huang
Laboratory of Cryptography and Information Security (LCIS), Department of Computer Science and Information
Engineering, National Central University, Chung-Li, Taiwan 320, Taiwan, ROC
Received 6 July 2007; received in revised form 18 October 2007; accepted 19 October 2007
Abstract
To prevent potential misuse and to enhance privacy, signatures with restricted veriﬁability have been recently exten-
sively discussed in the literature. Unlike undeniable signatures and designated veriﬁer signatures, nominative signatures
restrict the ability of signature veriﬁcation and conﬁrmation to a designated veriﬁer only. In this paper, security issues
of a nominative signature scheme proposed by Huang and Wang are reconsidered. The ﬁrst result obtained is that the
cryptanalysis reported recently by Susilo and Mu is shown to be incompletely correct; namely, the nominator in fact can-
not verify but can only screen signatures, and therefore any third party should not be convinced by the conﬁrmation done
by the nominator. The second observation is that the scheme proposed by Huang and Wang may not be as strong as orig-
inally claimed. Nevertheless, the overall result is optimistic that the security properties provided by the Huang–Wang nom-
inative signature scheme are suﬃcient for most applications.
 2007 Elsevier Inc. All rights reserved.
Keywords: Interactive conﬁrmation protocols; Nominative signatures; Privacy; Signature screening; Veriﬁcation
1. Introduction
By using digital signatures, many important cryptographic services, e.g., authentication, integrity, and non-
repudiation can be provided. Furthermore, privacy is also considered in many applications; for example, both
undeniable signatures [6,5] and designated veriﬁer signatures [9] are systems considering privacy requirements.
The main observation inspiring those researches is that the public veriﬁcation property (a.k.a. self-authenti-
cation) of traditional digital signatures jeopardizes the privacy of some participants. In undeniable signatures,
the signer can decide whether to conﬁrm an issued signature, thus his privacy is enhanced. Meanwhile he
cannot deny any signature that he has generated, thus keeps non-repudiation satisﬁed. In designated veriﬁer
signatures, the signer’s privacy is improved such that only those being designated by the signer can verify
signatures.
0020-0255/$ - see front matter  2007 Elsevier Inc. All rights reserved.
doi:10.1016/j.ins.2007.10.022
* Corresponding author.
E-mail addresses: hclin@csie.ncu.edu.tw (H.-C. Lin), yensm@csie.ncu.edu.tw (S.-M. Yen).
URL: http://www.csie.ncu.edu.tw/~yensm/ (S.-M. Yen).
Available online at www.sciencedirect.com
Information Sciences 178 (2008) 1407–1417
www.elsevier.com/locate/ins
Author's personal copy
sion due to a misunderstanding of the main theme of nominative signature schemes. Furthermore, the paper
[7] failed to address the nontrivial issue of screening that will be pointed out in our work.
1.2. Organization of the paper
The HW nominative signature scheme is reviewed in Section 2. In Section 3, a counter-example and recon-
sideration of the cryptanalysis proposed in [14] are given. Security proofs in the random oracle model and
security remarks of the HW scheme are given in Section 4. Finally, Section 5 includes a summary of the results
and conclusions.
2. Preliminaries
The HW nominative signature scheme [8] is reviewed in this section. The signer will be denoted as the nom-
inator s, and the veriﬁer as the nominee v.
The HW scheme [8] is a variant of the Schnorr signature scheme [13] for the signing process becomes an
interactive protocol. The cryptographic setting of the HW scheme is identical to the Schnorr signature scheme
where p is a large prime number and g is a generator of a subgroup with prime order q of Zp. Note that q is a
large prime factor of p  1. All of ðp; q; gÞ are system-wide public parameters and a collision free cryptographic
hash function H : f0; 1g ! Zq is available for all users as well. Each user u 2 fs; vg chooses a random num-
ber xu 2 Zq as his private signing key and the corresponding public key is gxu mod p which will be denoted as
yu hereafter.
2.1. Signature generation
The signature generation is an interactive protocol between the nominator s and the nominee v described as
follows.
• The nominee ﬁrst sends the nominator ða; cÞ where
a ¼gR1 mod p; R12RZq;
c ¼yR2v mod p; R22RZq:
• The nominator chooses r2RZq, then computes and sends ðb; e; r0Þ where
b ¼agr mod p;
e ¼HðyvjjbjjcjjmÞ;
r0 ¼r  xse mod q:
• The nominee accepts ðb; e; r0Þ if and only if
gr
0
yesb  a ðmod pÞ
for e ¼ HðyvkbkckmÞ. If ðb; e; r0Þ is accepted, then the nominee computes
r ¼ r0 þ R2  R1 mod q
and the resulting signature of message m is Rm ¼ ðyv; b; c; rÞ.
2.2. Signature veriﬁcation
Given a message–signature pair ðm;RmÞ, the nominee v computes e ¼ HðyvkbkckmÞ and accepts this signa-
ture if and only if
ðgryesbÞxv  c ðmod pÞ:
H.-C. Lin et al. / Information Sciences 178 (2008) 1407–1417 1409
Author's personal copy
Suppose now the cheating nominee v does not compute r normally. Taking a forged value r (let
r ¼ r0 þ D) instead of the correct r0, the nominee computes the forged value of the signature as
r^ ¼ r þ R2  R1
and the resulting signature would be cRm ¼ ðyv; b; c; r^Þ.
However, it is a surprise that from the nominator’s point of view this incorrectly produced (or forged) sig-
nature can still be valid by using the aforementioned Susilo and Mu veriﬁcation procedure. The reason is that
according to Eq. (1) now the related incorrect value of gR2 mod p will be computed as
cgR2 ¼ gr^  a  gr0 mod p
and it can be veriﬁed easily that cgR2 is equal to the following one
gr^  yes  b ¼ gr^  a  gr
0
mod p
since gr
0  yes  b  a ðmod pÞ.
Therefore, the incorrect (forged) signature cRm ¼ ðyv; b; c; r^Þ will now be recognized as valid by using Susilo
and Mu’s veriﬁcation procedure, and this of course violates the general design requirement of any signature
scheme. Furthermore, communication errors lead to exactly the same result shown in the counter-example as
well, even when the nominee is honest. We emphasize that the incorrectly produced signature is absolutely
invalid; it is deﬁnitely not another signature of m generated with diﬀerent random numbers. Note that the
invalid signature is not able to be conﬁrmed by the nominee to any third party, thus there is no explicit advan-
tage gained by the nominee. However, a sound and correct signature veriﬁcation procedure should never
accept an invalid signature as a valid one. Due to this fact, the nominator can not verify any HW signature
by using Susilo and Mu’s veriﬁcation procedure, and furthermore can not convince others of the correctness of
any HW signature.
We want to point out that other more general forgery scenarios are also possible. If the nominee does not
follow the design of the HW nominative signature scheme and randomly selects both a^ and c^ in the ﬁrst step as
well as randomly selects r^, then the forged signature becomes cRm ¼ ðyv; b^; c^; r^Þ where b^ ¼ a^  gr mod p com-
puted by the nominator. Evidently, using Susilo and Mu’s veriﬁcation procedure, this invalid signature will
still be recognized as a valid one because gr^  a^  gr0  gr^  yes  b^ ðmod pÞ where e ¼ Hðyvjjb^jjc^jjmÞ and
r0 ¼ r  xse mod q computed by the nominator.
3.2.1. Susilo and Mu’s claim on public veriﬁcation
Besides the nominator’s ability of veriﬁcation, Susilo and Mu also claimed that the nominator can convert
an HW nominative signature into a publicly veriﬁable one by publishing the corresponding value
c ¼ gR2mod p together with a signature of knowledge of R2 [14]. This claim tries to indicate that the HW
scheme does not satisfy the second requirement as well. However, it is apparently not the case when consid-
ering the counter-example presented previously. Any third party should not be convinced by merely seeing the
value of c and the signature of knowledge proof provided by the nominator. Moreover, the nominator is in
fact unable to provide the signature of knowledge proof since the lack2 of R2.
Finally, we wish to point out that Susilo and Mu misunderstood the conversion procedure of the HW
scheme which needs a non-interactive zero-knowledge proof of xv but not of R2 (refer to Section 2.3 of [8]).
3.3. Screening by the nominator
It is interesting to notice that although the nominator can not verify signatures successfully in the conven-
tional signature reasoning, he can achieve a related but weaker goal, namely, screening.
2 There is one exception where the nominator does possess R2, but any third party still should not be convinced in that case. Detailed
discussions will be given in Section 4.2.
H.-C. Lin et al. / Information Sciences 178 (2008) 1407–1417 1411
Author's personal copy
are chosen message attack adversaries against the existential unforgetability of signatures (for nominative sig-
natures and standard signatures, respectively).
According to the standard deﬁnition of chosen message attacks against standard signatures, FSr takes a
public key pks from C as input and is allowed to ask the hash oracle hashSr for qhashSr times and the signing
oracle sig
pks
Sr for qsigSr times. After receiving pks, FSr randomly chooses a public–private key-pair ðpkv; skvÞ of
some nominee v. Now, two types of chosen message attack adversaries should be taken into account.
Type I. This type simulates the case where an outsider, i.e., any third party other than the nominator and the
nominee, acts as the adversary FHW. In this case, FSr keeps the private key skv conﬁdential while
sending ðpks; pkvÞ to FHW as input. Similarly, FHW is allowed to ask the hash oracle hashHW for
qhash times and the signing oracle sig
pks;pkv
HW for qsig times. Since outsiders are not allowed to participate
in the interactive signing procedure, the signing oracle simply takes a message m as input and then
outputs the corresponding nominative signature Rm.
Type II. On the other hand, the second type reﬂects the possibility that the adversaryFHW is an insider, i.e.,
the nominee4. In this case, the adversary additionally possesses both the private key skv and the inter-
active signing oracle isig
pks;pkv
HW . A type II adversary is allowed to ask signing and interactive signing
queries for totally qsig times.
The goal of FSr is to produce a forgery of a Schnorr signature corresponding to pks, where in our proof
scenario pks ¼ ys ¼ gxs for some unknown xs ¼ sks. Meanwhile, for either type, the goal ofFHW is to output a
forgery of the HW instance corresponding to ðpks; pkvÞ, where pkv ¼ yv ¼ gxv for xv ¼ skv. Since FSr takes
FHW as a subroutine, the former has the obligation to provide (simulate) necessary oracles for the latter as
follows.
Simulate the hash oracle hashHWðÞ. The hash oracle hashHW is modeled as a random oracle. For each hash
query, FSr ﬁrst parses it to the format ykbkckm, then outputs the corresponding hash digest if this query has
already been made. For fresh queries with y 6¼ yv,FSr passes them directly to the hash oracle hashSr provided
by the Schnorr challenger C and records those responses. Otherwise, for some s5 randomly chosen from Zq,
FSr submits
cx
1
v
b
gsjjm
to the hash oracle hashSr. After receiving the response hashSr
cx
1
v
b g
sjjm
 
¼ e from C,FSr records and answers
FHW that
hashHWðyvjjbjjcjjmÞ ¼ e ¼ hashSr
cx
1
v
b
gsjjm
 !
:
s is also recorded in the same row of the table of the random oracle hashHW.
Simulate the interactive signing oracle isig
pks;pkv
HW ðÞ. For each isigpks;pkvHW query ða; c;mÞ made by a type II
adversary,FSr directly passes m to the sig
pks
Sr oracle provided by C. After receiving from sig
pks
Sr a valid Schnorr
signature ðR; rSrÞ,FSr computes b ¼ a=R and sets hashHWðyvjjbjjcjjmÞ ¼ e ¼ hashSrðRjjmÞ; ﬁnallyFSr answers
ðb; e; r0Þ where r0 ¼ rSr. Apparently, ðb; e; r0Þ passes the veriﬁcation since
grSryhashSrðRjjmÞs ¼ R
) gr0yesb ¼ a:
Then a type II adversary himself is able to produce the valid nominative signature Rm ¼ ðyv; b; c; rÞ.
4 See Section 4.2.
5 FHW could purposely cause hashHW collisions if s is absent; for example,FHW selects R2, R02, and D ﬁrst, then prepares two hashHW
queries ðyvkbkckmÞ and ðyvkb0kc0kmÞ where b ¼ gR2D, c ¼ yR2v , b0 ¼ gR
0
2D, and c0 ¼ yR02v . Clearly, the possibility of such a collision on
purpose is not negligible. In the abstract, if the output of a hashHW query is decided merely by yv, b, c, and m, which are all selected by
FHW, the output is controlled byFHW but notFSr. Thus, the random number s is necessary forFSr to simulate hashHWðÞ successfully.
H.-C. Lin et al. / Information Sciences 178 (2008) 1407–1417 1413
Author's personal copy
valid signatures can always be produced trivially. However, there is no way for the nominator to either con-
ﬁrm or convert signatures.
One of the most signiﬁcant diﬀerences between this work and the recent result [7] posted on IACR’s Cryp-
tology ePrint Archive is that the latter claimed the HW scheme is insecure as a cheating nominator can pro-
duce signatures all by himself and can also conﬁrm it to a third party since he himself chose R2. However, we
argued that any third party should not be convinced by such a conﬁrmation.
Firstly, please note that the knowledge of R2 is not suﬃcient for the standard conﬁrmation procedure
deﬁned in the HW scheme; but the standard one can only be done with xv. The conﬁrmation procedure men-
tioned in [7] simply follows the incorrect cryptanalysis proposed in [14].
Secondly, assuming the employed zero-knowledge proof system is secure, the ability of the nominator to
conﬁrm (via the non-standard and incorrect procedure) implies that he is in possession of R2. Further assum-
ing that the discrete logarithm problem is intractable, then the only possibility that the nominator is in pos-
session of R2 is that he cheats and produces the signature all by himself. This proves our claim clearly that
there is no reason for any third party to be convinced by such a conﬁrmation.
4.3. Veriﬁcation untransferability
In this section, veriﬁcation but not screening is considered. As shown in Section 3, by the cryptanalysis in
[14], the nominator can merely screen HW nominative signatures.
Deﬁnition 3. [Relaxed veriﬁcation untransferability]. Given the security parameter 1k, public system
parameters, public and private keys of the nominator, public key of the nominee, a message m, and the
presumed signature Rm, an adversary A, who is in possession of the hash oracle, will ﬁnally output either
accept or reject. Where for such A
Pr
Ahashð1k; pks; sks; pkv;m;RmÞ
¼ verð1k;m;Rm; pks; pkv; skvÞ
" #
 1
2

 < 1P ðkÞ
for every positive polynomial P and all suﬃciently large k. Ver and hash denote the veriﬁcation and hash ora-
cles, respectively.
Veriﬁcation untransferability corresponds to the requirement that no one other than the nominee can verify
signatures. Even the nominator is not capable of performing veriﬁcation. In other words, a successful veriﬁ-
cation done by the nominator without the assistance of the nominee is an eﬀective attack. Thus, the private
key of the nominator should be included in the adversary’s resources.
Note that the deﬁnition used here is diﬀerent from and weaker than the one used in [8] where conf and conv
oracle machines are available to the adversary.
However, this weaker deﬁnition is still reasonable as:
1. For those adversaries other than the nominator, the nominator’s private key sks is not available, and it is
impossible for them to produce valid signatures for either conﬁrmation or conversion. In this case, the conf
and conv oracles in fact exist while they always return reject.
2. From the point of view of applications, it is not easy to ﬁnd scenarios where the nominator is necessary to
act as a third party who is able to query conf and conv. For instance, in the aforementioned example of
transcript signatures, the school can simply search his own archive when he wants to know an alumnus’
record. Note that records of each student must be collected in the school’s archive; otherwise, the school
even can not sign transcripts. However, keeping that archive does not enable the school to verify signatures.
With help from the archive, the school can at most screen signatures.
Theorem 4. In the random oracle model, for anyone without the knowledge of skv and R2, signatures of the HW
scheme is not verifiable assuming that the Decisional Diffie-Hellman (DDH) problem [2] is hard.
H.-C. Lin et al. / Information Sciences 178 (2008) 1407–1417 1415
Author's personal copy
6. In the random oracle model, the HW scheme is proved to be relaxed veriﬁcation untransferable, assuming
that the DDH problem is intractable.
7. Without the nominee’s private key, the HW scheme is conﬁrmation untransferable.
In this paper, the security of the HW nominative signature scheme and its previous cryptanalysis are inten-
sively reconsidered. Brieﬂy, the conclusion is optimistic: although the HW scheme is not as strong as claimed
in the original proposal, the weaknesses reported by Susilo and Mu do not totally invalidate it. In most appli-
cations, the security guaranteed by the HW scheme is still suﬃcient. It is worth remarking that the subtle tax-
onomy of diﬀerent levels of veriﬁcation [1] is necessary, and in this paper another example is presented. Apart
from discussing the diﬀerent levels of security, more theoretical treatment of nominative signatures would be
necessary.
Acknowledgement
This research was supported in part by the National Science Council R.O.C. under contract NSC 95-2221-
E-008-045-MY2.
References
[1] M. Bellare, J. Garay, T. Rabin, Fast batch veriﬁcation for modular exponentiation and digital signatures, in: Advances in
Cryptology–EUROCRYPT’98, LNCS, vol. 1403, Springer-Verlag, 1998, pp. 236–250.
[2] D. Boneh, The decision Diﬃe-Hellman problem, in: Proceedings of the Third Algorithmic Number Theory Symposium, LNCS, vol.
1423, Springer-Verlag, 1998, pp. 48–63.
[3] J. Camenisch, Eﬃcient and generalized group signatures, in: Advances in Cryptology–EUROCRYPT’97, LNCS, vol. 1233, Springer-
Verlag, 1997, pp. 465–479.
[4] D. Chaum, Designated conﬁrmer signatures, in: Advances in Cryptology–EUROCRYPT’94, LNCS, vol. 950, Springer-Verlag, 1995,
pp. 86–91.
[5] D. Chaum, Zero-knowledge undeniable signature, in: Advances in Cryptology–EUROCRYPT’90, LNCS, vol. 473, Springer-Verlag,
1991, pp. 458–464.
[6] D. Chaum, H. Antwerpen, Undeniable signatures, in: Advances in Cryptology–CRYPTO’89, LNCS, 435, Springer-Verlag, 1990, pp.
212–216.
[7] L. Guo, G. Wang, D.S. Wong, Further discussions on the security of a nominative signature scheme, Cryptology ePrint Archive,
Report 2006/007, 2006.
[8] Z.J. Huang, Y.M. Wang, Convertible nominative signatures, in: Proceedings of Information Security and Privacy, ACISP 2004,
LNCS, vol. 3108, Springer-Verlag, 2005, pp. 348–357.
[9] M. Jakobsson, K. Sako, R. Impagliazzo, Designated veriﬁer proofs and their applications, in: Advances in Cryptology–
EUROCRYPT’96, LNCS, vol. 1070, Springer-Verlag, 1996, pp. 143–154.
[10] S.J. Kim, S.J. Park, D.H. Won, Zero-knowledge nominative signatures, in: Proceedings of PragoCrypt 96, International Conference
on the Theory and Applications of Cryptology, 1996, pp. 380–392.
[11] H.C. Lin, S.M. Yen, Y.H. Huang, Security of Huang–Wang nominative signature scheme-revisited, in: Proceedings of the 16th
Information Security Conference, Taichung, Taiwan, June 8–9 2006, pp. 85–92.
[12] M. Michels, M. Stadler, Eﬃcient convertible undeniable signature schemes, in: Proceedings of the 4th Annual Workshop on Selected
Areas in Cryptology–SAC’97, 1997, pp. 231–244.
[13] C.P. Schnorr, Eﬃcient identiﬁcation and signature for smart cards, in: Advances in Cryptology–CRYPTO’89, LNCS, 435, Springer-
Verlag, 1990, pp. 239–252.
[14] W. Susilo, Y. Mu, On the security of nominative signatures, in: Proceedings of Information Security and Privacy, ACISP 2005,
LNCS, vol. 3574, Springer-Verlag, 2005, pp. 329–335.
H.-C. Lin et al. / Information Sciences 178 (2008) 1407–1417 1417
constructed a concurrent signature scheme in a different way, the technique is to use a
conditional signature scheme as a building block [5].
Conditional signature [7] is a digital signature variant that allows a partyB to generate
a signature on some message, which is conditioned on another party A’s signature on
another message. Conditional signature is designed to solve problems such as business
negotiations, which may involves signing a document that whether the signature takes
effect will depends on some event that may or may not happen in the future. Earlier
solutions to this kind of problems are to include the conditions or clauses in the document
to be signed. However, in such a way the message to be signed will be altered and the
conditions will be made public—which are both what conditional signatures aim to avoid.
In a conditional signature scheme, in which B wants to create a signature on some
message conditioned on A’s signature on another message, B first gets from A a commit-
ment, then creates a pre-signature on the message to be signed. Before the generation
of A’s signature on the designated message, there is no way to get B’s binding signa-
ture. However, once the condition (A’s signature) is at hand, everyone can efficiently
convert B’s pre-signature to his binding signature. Informally speaking, we can view B’s
pre-signature as a ciphertext that the corresponding decryption key may not even exist
at the moment of generating the pre-signature; while when and whether to reveal the
decryption key are depending on some particular condition or event, and may be under
control by another party.
Through the above introduction to the concepts of concurrent signatures and con-
ditional signatures, one may has a feeling that those two notions seem to be similar.
A question may arise: can we use a conditional signature scheme as a building block
to construct a concurrent signature scheme? Indeed, the Chen-Yen concurrent signature
scheme [5] seems to be an example that gives us a positive answer, but after a more
detailed investigation, the answer will no longer be the same as we formerly believed.
Our Results. Starting from examining the Chen-Yen concurrent signature scheme, a
scheme that is claimed to be constructed from a conditional signature scheme, we re-
consider its correctness by separating the underlying conditional signature scheme from
the Chen-Yen concurrent signature scheme. One of our main observations is that, the
Chen-Yen conditional signature scheme is inherently flawed; the pre-signature which B
produces is actually an universally verifiable signature. Which means, there is no need to
get A’s signature so we can get B’s binding signature. In order to make a rigorous argu-
ment about this observation, a digital signature variant called the Schnorr-like signature
scheme, which is based on the Schnorr signature scheme [12], is introduced.
After showing that the Chen-Yen conditional signature scheme is inherently flawed,
which implies that the Chen-Yen concurrent signature scheme is also flawed inherently,
we go back to the original problem that is it possible to construct a concurrent signature
scheme from a conditional signature scheme. It is our another observation that a condi-
tional signature scheme can be a building block of a concurrent signature scheme only
if it has a special property, which we call it condition recoverability. So the problem of
whether a concurrent signature scheme can be constructed from a conditional signature
scheme has been changed to the problem of whether a conditional signature scheme can
have such a special property. Through formalizing such a property and making a reduc-
tion that leads to a contradiction, our answer to the question is negative—no conditional
signature schemes can have such a powerful property.
A party’s private key x is uniformly chosen from Zq, and the corresponding public
key is y = gx mod p.
COMMIT. This algorithm takes no input, picks a random value ki ∈ Zq, then outputs
ki and a commitment ai = g
ki mod p.
ISIGN. This algorithm takes as input (yi, xi, ai, ki,mi), where yi is a public key, xi is
the private key corresponding to yi, ai belongs to the subgroup of Z∗p generated by g,
ki ∈ Zq is the discrete logarithm of ai under the base g, and mi ∈ M is a message. The
algorithm calculates and outputs a keystone bi ∈ K, where bi = xih(mi||ai)+ki mod q.
We note that COMMIT and ISIGN together form a signing procedure of the Schnorr
signature scheme; (ai, bi) ∈ S is a Schnorr signature on mi, with respect to the key
pair (yi, xi).
FGEN. This algorithm takes as input (yi, ai,mi), where yi is a public key, ai belongs
to the subgroup of Z∗p generated by g, and mi ∈ M is a message. The algorithm
calculates and outputs a keystone fix Bi = y
h(mi||ai)
i × ai mod p, which is consistent
with KGEN(bi) = gbi ∈ F .
MSIGN. This algorithm takes as input (yj, xj, Bi,mj), where yj is a public key, xj is
the private key corresponding to yj, Bi ∈ F is a keystone fix, and mj ∈ M is a
message. The algorithm picks a random value kj ∈ Zq, then calculates and outputs a
pre-signature ωj = (aj, βj), where aj = g
kj ×Bi mod p, βj = xjh(mj||aj) + kj mod q.
MTRAN. This algorithm takes as input (ωj , bi), where ωj = (aj, βj) is a pre-signature
and bi ∈ K is a keystone. The algorithm calculates and outputs a Schnorr signature
σj = (aj, bj) ∈ S, where bj = βj + bi mod q.
ITRAN. This algorithm takes as input (ωj, σj), where ωj = (aj, βj) is a pre-signature
and σj = (aj, bj) ∈ S is a Schnorr signature, The algorithm calculates and outputs a
keystone bi = bj − βj mod q.
VERIFY. This algorithm is the same as the one with the same name in the Schnorr
signature scheme.
Protocol. A Chen-Yen concurrent signature protocol between an initial signer A and a
matching signer B works as follows.
First run SETUP to determine the system parameters. We assume A’s and B’s key
pairs are (yi, xi) and (yj, xj) respectively.
1. A runs COMMIT and obtains (ai, ki), then she sends ai to B as a commitment, along
with a message mi that she picks to sign.
2. Upon receiving ai andmi fromA,B first computes a keystone fixBi = FGEN(yi, ai,mi),
then picks a message mj to sign and computes his pre-signature to be
ωj = (aj, βj) = MSIGN(yj, xj, Bi,mj),
and sends ωj and mj to A.
3. Upon receiving ωj and mj from B, A first completes generating her signature bi on
mi (w.r.t. the commitment ai) by running ISIGN on input (yi, xi, ai, ki,mi). Then A
transforms B’s pre-signature into B’s binding signature to be
σj = (aj, bj) = MTRAN(ωj , bi).
After obtaining σj,A verifies the validity of σj by checking whether VERIFY(yj, σj,mj) =
accept. If not, A aborts, otherwise A sends the keystone bi to B.
3 The Chen-Yen Conditional Signature Scheme and Its
Flawed Nature
In this section, in order to justify the correctness of the Chen-Yen concurrent signature
scheme, we first separate the conditional signature scheme, which is used as a building
block of the Chen-Yen concurrent signature scheme, out of the scheme itself. We name the
conditional signature scheme as Chen-Yen conditional signature scheme and investigate
its correctness.
3.1 The Chen-Yen Conditional Signature Scheme
Algorithms of the Chen-Yen conditional signature scheme, in which a party B wishes
to generate a signature on mj conditioned on another party A’s signature on mi, are as
follows.
SETUP. This algorithm is the same as the one with the same name in the Chen-Yen
concurrent signature scheme.
COMMIT. A runs COMMIT of the Chen-Yen concurrent signature scheme and sends
one of the output ai, along with a message mi to B.
PRESGEN. Upon receiving ai and mi, B runs FGEN of the Chen-Yen concurrent sig-
nature scheme on input (yi, ai,mi) and gets Bi, then he picks a message mj, runs
MSIGN of the Chen-Yen concurrent signature scheme on input (yj, xj, Bi,mj) and
gets a pre-signature ωj = (aj, βj).
SRETRIVE. Once the condition (A’s signature on mi) σi = (ai, bi) is published, anybody
can perform MTRAN of the Chen-Yen concurrent signature scheme on input (ωj, bi)
and get from the output B’s binding signature σj on mj.
By comparing the definition in Sect. 2.3 and the Chen-Yen conditional signature
scheme, one can verify that the Chen-Yen conditional signature scheme is not of the
structure defined in [7]. In the Chen-Yen conditional signature scheme, B does not have
to generate a signature on mj so he can generate a pre-signature on mj; instead, B
directly creates a pre-signature on input (yj, xj, Bi,mj), making this step be comparable
to a signing procedure. Jumping ahead, we mention that the pre-signature generation
step in the Chen-Yen conditional signature scheme is indeed a signing procedure.
3.2 The Schnorr-like Signature Scheme
In order to point out the flawed nature of the Chen-Yen conditional signature scheme,
we introduce a digital signature variant called Schnorr-like signature. The Schnorr-like
signature scheme is comprised of the following algorithms.
SETUP. This algorithm is the same as the one with the same name in the Schnorr
signature scheme, except that the signature space S ′ is defined as Z∗p × Z∗p × Zq.
SIGN. This algorithm takes as input (y, x,m), where y is a public key, x is the private
key corresponding to y, and m ∈ M is a message. The algorithm first selects from
Zq two random numbers k1 and k2, then computes a1 = gk1 mod p, a2 = gk2 mod p,
a = a1 · a2 mod p, and b = xh(m||a) + k1 mod q respectively. The signature on m is
σ = (a, a2, b).
VERIFY. This algorithm takes as input (y, σ,m), where y is a public key, σ = (a, a2, b) ∈
S ′ is a Schnorr-like signature, and m ∈ M is a message. The algorithm outputs accept
if gb × a2 = yh(m||a) × a, otherwise, it outputs reject.
4 Further Investigation
In the previous section we have pointed out that the Chen-Yen conditional signature
scheme is inherently flawed. Although the flawed nature of the Chen-Yen conditional
signature scheme leads the failure of using it as a building block to construct a concurrent
signature scheme, it may still be worthwhile to do some investigations into the “special
property” that the Chen-Yen conditional signature scheme has and see if we can use the
same technique to construct a secure concurrent signature scheme.
4.1 Conditional Signature Schemes with Condition Recoverability
Although not stated in [5], the ability for the matching signer B to recover the initial
signer A’s signature, if A deviates from the protocol by not publishing her signature
(the condition), is the very fundamental property for the Chen-Yen concurrent signature
scheme to be operational. We name such a special property condition recoverability and
give a formal definition of it as follows.
Definition 1 (Condition Recoverability).We say that a conditional signature scheme
is condition recoverable if there exists a condition recovering algorithm CRECOVER such
that, on input (ωj, σj) (and probably some other public information), where ωj is a pre-
signature and σj is the binding signature transformed from ωj . CRECOVER reveals the
condition σi.
The algorithm ITRAN in the Chen-Yen concurrent signature scheme can be viewed as
its condition recovering algorithm.
Once with the property of condition recoverability, a conditional signature scheme can
almost unquestionably be used as a building block to construct a concurrent signature
scheme, since it provides a solution to the aforementioned malicious behavior. Conversely,
for a conditional signature scheme to be able to be a building block of a concurrent
signature scheme, the aforementioned problem has to be solved, so it is very likely that
the scheme has to be condition recoverable.
Recall our informal description of conditional signature schemes, pre-signatures and
conditions can be viewed as ciphertexts and decryption keys respectively. According to
this kind of relation, recovering of a condition may be viewed as deriving a decryption key
with a ciphertext and the corresponding plaintext, which seems to be quite unreasonable.
Now the question is: can such a powerful property be compatible with a conditional
signature scheme?
4.2 Impossibility of Conditional Signature Schemes Being Condition
Recoverable
In this section, we give a negative answer to the previous question. That is, conditional
signature schemes can never be condition recoverable. The reason is that, otherwise, it
contradicts the unforgeabiity of the underlying signature scheme, more specifically, it
contradicts the unforgeability of the signature scheme that A uses to generate signatures.
Proposition 1. A conditional signature scheme cannot be condition recoverable, given
that the underlying signature scheme is existentially unforgeable against no message at-
tacks.
performing the signature retrieval algorithm SRETRIVE by anyone once the condition
is at hand, the problem of whether such a conditional signature scheme can be used to
construct a concurrent signature scheme has to be reconsidered and cannot be answered
by Proposition 1.
Although neither the existence nor the non-existence of such type of conditional sig-
nature schemes has been justified yet, listed below are some properties such type of con-
ditional signature schemes must have. First, a pre-signature in such schemes is inevitably
a signature, i.e., someone’s pre-signature on some message cannot be produced by others.
Otherwise, from the fact that a pre-signature can be converted into a binding signature, it
contradicts the unforgeability of the underlying signature scheme. Second, a pre-signature
in such schemes cannot be universally verifiable. Otherwise, the pre-signature generation
algorithm, together with a universal verification procedure, constitute a secure signature
scheme just like the Chen-Yen conditional signature scheme. Clearly, whether such kind
of conditional signature schemes can be condition recoverable seems to be highly ques-
tionable, and inserting a condition into an unforgeable tuple with restricted verifiability
in an non-one-way manner is indeed non-trivial.
As for considering whether such type of conditional signature schemes can be used to
construct concurrent signature schemes, certainly there are additional requirements that
need to be achieved. Besides the need of a well designed condition recovering algorithm,
there is another requirement that, after having created a pre-signature on some message,
a party in such schemes has to be incapable of producing the corresponding binding signa-
tures. Otherwise, a polynomial time forger can again be made and leads a contradiction
to the unforgeability of the underlying signature scheme.
5 Conclusion
Starting from examining the Chen-Yen concurrent signature scheme, a concurrent sig-
nature scheme that is claimed to be constructed from a conditional signature scheme,
we show that the scheme is inherently flawed and thus fails to be a legitimate concur-
rent signature scheme. The technique is to separate the Chen-Yen conditional signature
scheme from the Chen-Yen concurrent signature scheme, and then make a comparison
between the Chen-Yen conditional signature scheme and a digital signature variant called
the Schnorr-like signature scheme. We point out that generating a pre-signature under
the Chen-Yen conditional signature scheme is actually generating an unforgeable and
universally verifiable signature, which leads violations of security requirements for both
a conditional signature scheme and a concurrent signature scheme.
As regards the more general problem of whether it is possible to construct a con-
current signature scheme from a conditional signature scheme, our answer is nagative.
Through formulating the possibility to a special property called condition recoverability
and making a reduction algorithm that leads to a contradiction, we show that no typ-
ical conditional signature schemes can be condition recoverable. As for the question of
whether there exist other types of conditional signature schemes, we also give our opinion.
Acknowledgment
This research was supported in part by the National Science Council R.O.C. under con-
tract NSC 95-2221-E-008-045-MY2.
Fair Multi-party Concurrent Signatures
Chieh-Tai Shieh, Hsi-Chung Lin, and Sung-Ming Yen
Laboratory of Cryptography and Information Security (LCIS)
Dept of Computer Science and Information Engineering
National Central University, Chung-Li, Taiwan 320, R.O.C.
E-mail: {955202019;hclin;yensm}@csie.ncu.edu.tw
Abstract. The concept of concurrent signature was introduced by Chen, Kudla, and Pasterson
at Eurocrypt 2004. A concurrent signature attempts to provide the similar functionality of a fair
exchange without assuming the existence of a trusted third party or comparable computing power
of the two parties. In the Chen-Kudla-Pasterson scheme, the signatures signed by the two parties
remain ambiguous until the additional information keystone is released. Tonien, Susilo, and Safavi-
Naini proposed the first multi-party concurrent signature scheme. In this paper, it will be pointed
out that the multi-party concurrent signature scheme proposed by Tonien et al. does not achieve
the goal of a concurrent signature. Furthermore, a fair multi-party concurrent signature scheme
will be proposed.
Keywords: Fair exchange, Ring signature, Concurrent signature.
1 Introduction
With the growth of electronic commerce, issues of guaranteeing fairness between the
transactors through the Internet is more and more important and the protocol of trans-
actions should avoid any involved party to take advantage of other parties via improper
behavior. Hence, the research on fair exchange protocols was extensively developed in the
last twenty years. But in early works, the fairness relies on the assumption that either
both parties have comparable computing power, i.e. [1][2], or a trusted third party is
involved, i.e. [3][4].
The concept of concurrent signature was first introduced by Chen, Kudla, and Paster-
son [6]. A concurrent signature achieves the similar functionality of a fair exchange be-
tween two parties by letting exchanged ambiguous signatures bind to their signer simul-
taneously. Chen et al. also introduce the notion of keystone which is held by the initial
signer, and without the keystone released, both signatures of two parties are ambiguous
from a third party’s point of view. With the keystone released, both signatures of two
parties are binding to their actual identities. Namely, two signatures are binding after
the keystone is released. In the following years, [7][8][9][10][11][13][14] propose some other
concurrent signature schemes, but the feature of these schemes is as the same as [6], which
is not so “fair” since the initial signer has full power to control the keystone releasing
time. And so, if there exists a method which lets not only the initial signer hold the
keystone but also another signer does, the concurrent signatures will be more “fair” than
before.
For letting the keystone be not hold by only one party, it is a method which let all
users have their own keystones. This method provides not only more fairness but also
a way to answer the open problem at the end of Chen et al.’s paper. In 2006, Tonien,
Susilo, and Safavi-Naini [12] proposed a multi-party concurrent signature scheme which
all users could select their own individual keystones. But Tonien et al.’s scheme do not
satisfy the original notion of concurrent signatures, which all signatures should bind to
their identities concurrently.
and
Vi = ski(hii +H4(iki))F ∈ G1.
It outputs σi = (Vi, Ui1, . . . , Uin) as the signature.
OutsiderVerify: The OutsiderVerify algorithm takes the parameters (mi, σi, PK,F ) as
the inputs, where mi ∈ M is a message, σi = (Vi, Ui1, . . . , Uin) is a signature to be
verified, PK is the public key tuple , and F ∈ F is a group keystone fix. It computes
hij = H3(mi||j||PK||F ||Uij) ∈ Zq for 1 ≤ j ≤ n, and outputs “accept” if and only if
eˆ(P, Vi) = eˆ(F,
n∑
j=1
(Uij + hijPj)).
InsiderVerify: The InsiderVerify algorithm takes the parameters (mi, σi, PK,F, i, skj)
as the inputs, where mi ∈ M is a message, σi = (Vi, Ui1, . . . , Uin) is a signature, PK
is the public key tuple , F ∈ F is the group keystone fix, i is the user who will be
verified, and skj is the private key of the user who will verify the user i. It outputs
“accept” if and only if
Uij = H2(mi||i||F ||eˆ(P0, Pi)skj )
and the tuple (mi, σi, PK,F ) passes the OutsiderVerify algorithm.
BindingVerify: The BindingVerify algorithm takes the parameters
(PK, gk, F, (ik1,m1, σ1), . . . , (ikn,mn, σn))
and outputs “accept” if and only if F = H1(gk) and for 1 ≤ j ≤ n,
eˆ(P, Vj) = eˆ(F,
n∑
i=1
(Uji + hjiPi))
and
eˆ(P, Vj) = eˆ(Pj , (hjj +H4(ikj))F ),
where hji = H3(mj||i||PK||F ||Uji) ∈ Zq.
And Tonien et al.’s protocol works as following.
1. All users run Setup together and get all system public parameters and their private
keys.
2. An initial user i picks a random group keystone gk and his own keystone iki. The
user i computes the group keystone fix F = H1(gk) and executes the algorithm
Sign(mi, PK,F, ski, iki) to get an anonymous signature σi on the message mi. The
user i keeps the group keystone gk and his own keystone iki secret and sends (mi, σi, F )
to other users.
3. Each user j, where 1 ≤ j ≤ n and j 6= i, use his private key skj to execute the
algorithm InsiderVerify(mi, σi, PK,F, i, skj).
4. If no users reject i signature, an user k, where k 6= i, selects his own keystone ikk and
executes Sign(mk, PK,F, skk, ikk) to get an anonymous signature σk on the message
mk. The user k sends (mk, σk) to other users.
5. As step 3 and 4, if no users reject k signature, another user l, where l 6= k 6= i, sends
(ml, σl) to other users. This process is repeated until all users sign their messages and
send their anonymous signatures to other users.
6. In this step, all users release their own keystones and the user i release the group
keystone gk. So, anyone can execute the algorithm
BindingVerify (PK, gk, F, (ik1,m1, σ1), . . . , (ikn,mn, σn))
to verify all the signatures.
SETUP: A probabilistic algorithm take security parameters and outputs the keystone
fix space F , the keystone space K, a function FGEN : K → F , and the message space
M. For key generation, the SETUP algorithm outputs the public key pki and the
corresponding private key ski for each user i.
FSIGN: A probabilistic algorithm takes the parameters
(ski, f1, . . . , fn,mi)
as the inputs, where ski is the private key, f1, . . . , fn ∈ F are keystone fixes, and
mi ∈ M is a message. And it outputs σ˜i, which contains f1, . . . , fn, as an ambiguous
signature.
FVERIFY: A deterministic algorithm takes the parameters
(σ˜i, pki,mi)
as the inputs, where σ˜i is an ambiguous signature, pki is the public key, and mi ∈ M
is a message. And it outputs “accept” or “reject”.
VERIFY: A deterministic algorithm takes the parameters
(σi, pki,mi)
as the inputes, where σi = (σ˜i, k1, . . . , kn) is a signature, pki is the public key,mi ∈ M
is a message, σ˜i is an ambiguous signature, and k1, . . . , kn ∈ K are keystones. And it
outputs “accept” or “reject”.
3.2 Protocol of Fair Multi-party Concurrent Signature
A fair multi-party concurrent signature protocol between n users will be described in this
section. The protocol works as follows.
For a user i, 1 ≤ i ≤ n, he runs SETUP first to get public parameters and a personal
private key and then processes the three phases, fixing phase, signing phase, and releasing
phase, sequentially.
1. Fixing phase
- Each user i selects his own random keystone ki ∈ K and runs FGEN (ki) to get a
keystone fix fi. He also keeps his own keystone ki secret and sends his keystone fix
fi to other users.
2. Signing phase
- For each user i, 1 ≤ i ≤ n, after he receives all f , he runs
FSIGN (ski, f1, . . . , fn,mi)
to sign a message mi and computes an ambiguous signature σ˜i. Then he sends
(mi, σ˜i) to other users.
3. Releasing phase
- For each user i, 1 ≤ i ≤ n, after he receives all (m, σ˜), he runs
FVERIFY (σ˜j, pki,mj)
for 1 ≤ j ≤ n and j 6= i to check an ambiguous signature σ˜j. If no results of
FVERIFY are “reject”, the user i release his keystone ki to other users.
For now, anyone can execute the algorithm
VERIFY (σi, pki,mi),
where σi = (σ˜i, k1, . . . , kn), after he gets all keystones k. If it outputs “accept”, the
message mi is affirmatively signed by the user i. And in fact, all (σ, pk,m) will now be
accepted by the VERIFY algorithm concurrently.
FSIGN: The FSIGN algorithm takes the parameters
(ski, f1, . . . , fn,mi)
as the inputs, where ski = di is the private key, f1, . . . , fn ∈ F are keystone fixes, and
mi ∈ M is a message. The FSIGN algorithm selects a random ri such that 1 ≤ ri ≤
l − 1, and then computes vi = h1(mi, ri) and xi = (vi ⊕ ri ⊕ f1 ⊕ . . .⊕ fn)di mod ni.
Finally, it outputs σ˜i = (vi, xi, f1, . . . , fn) as an ambiguous signature.
FVERIFY: The FVERIFY algorithm takes the parameters
(σ˜i, pki,mi)
as the inputs, where σ˜i = (vi, xi, f1, . . . , fn) is an ambiguous signature, pki = (ni, ei)
is the public key, and mi ∈ M is a message. The FVERIFY algorithm computes
zi = x
ei
i mod ni and v
′
i = h1(mi, zi ⊕ vi ⊕ f1 ⊕ . . . ⊕ fn). It outputs “accept” if and
only if v′i = vi. Otherwise the FVERIFY algorithm outputs “reject”.
VERIFY: The VERIFY algorithm takes the parameters
(σi, pki,mi)
as the inputs, where σi = (σ˜i, k1, . . . , kn) is a signature, pki = (ni, ei) is the public
key, mi ∈ M is a message, σ˜i = (vi, xi, f1, . . . , fn) is an ambiguous signature, and
k1, . . . , kn ∈ K are keystones. The VERIFY algorithm computes f ′j = h2(kj) for
1 ≤ j ≤ n. It outputs “accept” if and only if f ′j = fj for 1 ≤ j ≤ n and the
tuple (σ˜i, pki,mi) passes the FVERIFY algorithm. Otherwise the VERIFY algorithm
outputs “reject”.
4.2 All Schnorr signatures case
SETUP: The SETUP algorithm takes security parameters and selects two large primes
p and q depending on security parameters such that q|(p− 1), and let g is a generator
of the subgroup of order q in Z∗p. The SETUP algorithm outputs the message space
M = {0, 1}∗, the keystone space K = Z, and the keystone fix space F = Zq. The
SETUP algorithm also generates two cryptographic hash functions h1 : {0, 1}∗ → F
and h2 : K → F and defines the function FGEN as h2. For key generation, the SETUP
algorithm selects a random integer xi such that 1 ≤ xi ≤ q−1, and computes yi = gxi
for each user i. Let pki = yi be the public key and ski = xi be the private key.
FSIGN: The FSIGN algorithm takes the parameters
(ski, f1, . . . , fn,mi)
as the inputs, where ski = xi is the private key, f1, . . . , fn ∈ F are keystone fixes,
and mi ∈ M is a message. The FSIGN algorithm selects a random ri ∈ Zq and then
computes ci = h2(mi, g
ri mod p) and si = ri − xici
∏
fi mod q. Finally, it outputs
σ˜i = (ci, si, f1, . . . , fn) as the ambiguous signature.
FVERIFY: The FVERIFY algorithm takes the parameters
(σ˜i, pki,mi)
as the inputs, where σ˜i = (ci, si, f1, . . . , fn) is an ambiguous signature, pki = yi = g
xi
is the public key, and mi ∈ M is a message. The FVERIFY algorithm computes
ei = g
siy
ci
∏
fi
i mod p and c
′
i = h1(mi, ei). It outputs “accept” if and only if c
′
i = ci.
Otherwise the FVERIFY algorithm outputs “reject”.
Ambiguity. Before the releasing phase completed, namely there exists at least a user
i does not release his keystone ki yet, it is possible that someone forge an ambiguous
signature σ˜j
′, where 1 ≤ j ≤ n, by selecting a random r′j and calculating v′j = h1(m′j, r′j),
where m′j is a forged message, and a fix
fi = (x
′ei
j mod ni)⊕ v′j ⊕ f1 ⊕ . . .⊕ fi−1 ⊕ fi+1 ⊕ . . .⊕ fn ⊕ r′j,
where x′j is selected by him in the signing phase. The ambiguous signature σ˜j
′ = (v′j, x
′
j, f1, . . . , fn)
will pass the the FVERIFY algorithm but ki has not been released. So ambiguous sig-
natures do not bind to their signers if at least one keystone is not released yet.
Concurrent. After the releasing phase, there are two cases as follows.
1. Each fi is equal to FGEN (ki).
- Since each σ˜i is accepted by the FVERIFY algorithm, each signature σi will pass
the VERIFY algorithm. Due to each σi have unforgeability property, all signatures
σ would bind to their actual signers concurrently.
2. At least one fi is not equal to FGEN (ki).
- The situation is as the same as the ambiguity property, and all signatures do not
become binding.
Fairness. Due to the individual signature satisfies correctness and unforgeability, and
the protocol satisfies ambiguity and concurrent, the proposed scheme satisfies fairness
property.
Remarks
- In the Schnorr case, a forger could forge an ambiguous signature σ˜j
′ if at least a user
i does not release his keystone, too. He could select two random s′j ∈ Zq and c′′j ∈ Zq
and let c′j = h2(m
′
j, g
s′jy
c′′j
j mod p), where m
′
j is a forged message, and a fix
fi = c
′′
j (c
′
j
∏
k 6=i
fk)
−1 mod q.
The ambiguous signature σ˜j
′ = (c′j, s
′
j, f1, . . . , fn) will pass the the FVERIFY algo-
rithm.
- If a forger is inside of the users, he could forge any ambiguous signature before the
releasing phase completed, no matter that whether the corresponding keystone has
been released. But if a forger is outside of the users, he could only forge an ambiguous
signature which the corresponding keystone does not be released. This is why we call
the property is “ambiguity”, not “anonymity”.
- The ambiguity of the proposed scheme does not achieve the perfect notion in [7]. There
is only one ambiguous signature could be forged before the releasing phase completed
since there is only one result which could satisfy the calculating of h1 after operating
and modifying keystone fixes. But it is enough since if any user is doubted of signing his
message actually before the releasing phase completed, he could explain the signature
could be forged by any other users, and no one has methods to check it.
5.2 Performance Analysis
In this section, the performance of the proposed scheme is compared with Tonien et al.’s
scheme according to size of signatures and communication costs.
12. D. Tonien, W. Susilo, and R. Safavi-Naini, “Multi-party concurrent signatures” Information Security, 9th
International Conference, ISC 2006, LNCS 4176, pp.131–145, Springer-Verlag, 2006.
13. H. Hiwatari and K. Tanaka, “Fair exchange of signatures in the many-to-one model” The 2006 Symposium
on Cryptography and Information Security, SCIS 2006, 3a4-4, 2006.
14. Y. Komano, “Fair exchange of signatures with multiple singer” IEICE Trans. Fundamentals, Vol. e90, No.
5, pp.969–979, 2007.
   pVycpgc rs
r mod  ;  mod 22 21 ×==  (4) 
2.2   Nieto學者等人所提出的金鑰恢復系統 
        為降低利用金鑰封存方式的資料傳輸量與計算量，
Nieto 學者等人[5][6]於西元 2002 年，針對 IBM 所發表
的金鑰恢復系統[7]，提出如何利用金鑰託管與金鑰封存
兩種方式的結合，增強系統效率，達到減少系統資料計
算量和傳輸量。於該系統之註冊階段，使用者 Alice 先
傳送自己的公開金鑰 yA予 KRA，而 KRA則利用 yA與自
己的主密鑰 MK，額外產製及存放一個 Alice註冊相關之
秘密值 a，並傳送 ga予 Alice，以建立 Alice 和 KRA間
之 Diffie-Hellman(DH)共享秘密金鑰[8]αA=yAa。此外，
KRA 亦發佈相對於 αA 的公開資訊gA=gaA。若 Alice 與
Bob 欲進行秘密通訊，為了讓有權限之主管機構事後可
以恢復秘密通訊之內容，Alice 會利用 Bob 的公開資訊
gB，另外建立一把 DH 共享秘密金鑰 u=gBαA= gαA·aB，利
用 KEK=H(u, SID)加密通訊時將使用之交談金鑰 SK，其
中 SID為通訊識別字串。當 Alice或有權限的主管機關欲
恢復金鑰時，先向 KRA 提出要求，經身份確認後，
KRA 可以重新計算取得 αA，並利用公開資訊(gB, SID)計
算出 u和 KEK，進而恢復 SK並取得秘密通訊的明文。 
 
2.3   安全遠端密碼協定 
        學者 T. Wu於西元 2002年所發表之 Secure Remote 
Protocol(SRP-6)[9][10]，屬於具認證性之金鑰交換協定
Authenticated Key Exchange(AKE)；使用者在完成身份確
認的同時，也和主機完成秘密交談金鑰產生的程序，以
保護後續通訊內容之隱密性。SRP-6 認證交換協定在
IEEE P1363 Working Group 中被提議使用，並有開放原
始碼可供現有網路應用與安全通行碼認證的整合。 
        本論文利用 SRP-6[10]協定來完成使用者身份確認
(及保障金鑰恢復階段的資料私密性)，所以論文中不探
討使用者身份認證相關的細節與安全性議題。本文所提
出之系統也可以利用其他方式來完成使用者身份認證。 
三. 新提出之金鑰恢復系統 
        此節將說明本論文所提出之簡單且實用的金鑰恢復
系統。於本系統中，假設檔案由數位使用者所分享(本節
以兩位使用者為例，推廣至多位使用者之延伸將於第四
節討論)，則當任一檔案分享的擁有者遺失其私密金鑰
時，皆有能力恢復檔案之加密金鑰。Nieto等人的金鑰恢
復系統[6]雖提供相同的功能，但該系統設計中 KRA 掌
控了主要的機密值與秘密金鑰，且註冊階段顯得過於繁
雜。本文將針對上述缺失進行改善。 
        本文所提出的主要架構是，Alice 與 Bob 直接利用
彼此的金鑰對建立 DH共享金鑰，然後利用學者 Yen所
提出之 KRS-1[4] 系統中金鑰封裝的金鑰恢復方式，建立
金鑰恢復資訊，並產製加密交談金鑰的秘密金鑰，進而
避免 KRA 計算量過於大的缺點。本文所提出的金鑰恢
復機制可分為三個階段： 
(1)使用者註冊 User registration 
(2)金鑰加密 Session-key encryption 
(3)金鑰恢復 Key recovery 
        於系統初始化時，所有使用者和 KRA 各自擁有一
組金鑰對(x, y)，y=gx mod p。g和 p為公開資訊，x是自
己的私密金鑰，而 y則是相對於 x的公開金鑰。 
 
3.1   使用者註冊階段 
        本系統採用 SRP-6 [10]協定進行身份認證方法，因
此註冊階段的程序均符合 SRP-6 之步驟，另外再加上系
統所需要的使用者公開金鑰資訊。所以使用者 Alice 的
註冊資訊包含(IDA, yA, v, s)，其中有識別碼 IDA、公開金
鑰 yA，而(v, s)為 SRP-6的註冊資訊，分別為通行驗證碼
和種子(salt)。 
AA
svyIDz
AA
x
A
y
ysv IDsp  gv
PWIDsHz
gy
AA
A
s
 and  ),(, ave               mod
),,(
  ,
key        public sKRA'get    
KRA                                                                      Alice        
,,,
 key, public sKRA'
¾¾¾ ®¾=
=
=
¾¾¾¾ ¾¬
------------------------------
圖一：使用者註冊階段 
 
3.2  金鑰加密階段 
        此階段可細分為兩部分，加密交談金鑰和產製金鑰
恢復資訊。 
 
加密交談金鑰 
        本系統中〝目標金鑰〞 TK 的格式是根據文獻[4]延
伸而來。首先利用 DH 金鑰交換的方式，讓傳送者 Alice
和接收者 Bob 兩位各自利用自己的私密金鑰和對方的公
開金鑰，計算出共享金鑰 DHKAB「(5)」。然後利用
DHKAB與 KRA的公開金鑰 ys，再執行一次 DH金鑰交換
運算，產生目標金鑰 TK=ysDHKAB，並以其雜湊值「(6)」
EK加密交談金鑰 SK，計算出 ESK「(7)」。 其中交談金
鑰 SK 可以是傳送者所選取之亂數值(亦可以是雙方事先
協議之任意值)，將作為檔案加密金鑰使用；Ek(·)和 Dk(·)
分別為以 k為金鑰之對稱式加、解密函數。 
  pgDHK BA xxAB mod
×=  (5) 
  )mod( pyHEK ABDHKs=  (6) 
  )(SKEESK EK=  (7) 
  
----------------------
=
=
=
=
=
¾¾¾¾ ¾¬
¾¾¾¾¾¾ ®¾
----------------------
EDHKKRI
,ListgEEDHK
DHKHETK
SKEESK
yHEK
IDs
DHK
ETK
AS
EK
DHK
s
y
AB
AB
B
)||(
)(
)(
)(
                                       
                                   
KRA                                                       Alice       
Alice  toreturn 
key public sBob'request 
 
圖二：產製金鑰恢復資訊階段 
 
 
49
 認公開金鑰是否真為對方所擁有，如此一來即可以避免
中間人攻擊。 
 
4.2   複雜度分析 
        本文所提出之系統主要利用 DH 金鑰交換共享[8]為
設計概念，因此以較為著名的 Neito 等學者所發表之系
統[6]作為複雜度分析比較的標準。比較環境設定如下：
(a)使用者包含 Alice 與 Bob 兩位。(b)單一 KRA 服務系
統。(c)由於 Neito 等學者之方法[6]並未探討使用者身份
認證之問題，因此我們將忽略此方面的計算量分析。 
此外，由於金鑰恢復功能是提供使用者在金鑰遺失
或損壞時，可以藉由 KRA 的協助恢復加密檔案的金
鑰，因此本文於分析比較時，特別將使用者端和金鑰恢
復主機端的計算量分開計算，以突顯彼此的差異性。系
統複雜度分析所使用之符號定義如下：TSM－對稱式加/
解密演算法所需時間，TEM－模數指數運算所需時間，
TH－雜湊函數運算時間。 
表 I 
系統複雜度分析表 
本研究機制 Nieto et al. [6]   
階段 使用者端 金鑰恢復主機 使用者端 金鑰恢復主機 
使用者註冊 TEM  3TEM 3TEM+TH 
加密交談金
鑰(a) 
2TEM+TH 
+TSM 
 TEM+TH 
+TSM 
 
產製金鑰恢
復資訊 
2TEM+TH 
+TSM 
 TEM+2TH 
+2TSM 
 
金鑰恢復 TH+TSM 2TEM+TH+TSM TSM 2TEM+3TH+TSM 
(a) 文獻[6]未探討加密交談金鑰如何產生，假設使用者已知交談交鑰。 
(b) 此分析表沒有分析系統的使用者身份認證相關複雜度計算。 
 
4.3   架構分析 
        在金鑰恢復技術的使用方式上，本文所提出的系統
與學者 Yen的系統[4]相似，只利用到金鑰封存方法，並
沒有在 KRA 存放目標金鑰的任何明文相關資料，而是
將目標金鑰以密文的方式附加在檔案密文之後。但是
Nieto學者所發表[6]的架構中，使用者在向 KRA註冊階
段，KRA 就會另外計算存放一機密值，而此機密值可視
為目標金鑰的部份明文資訊，所以該方法中有使用到金
鑰託管的概念，如此一來使用者便必須高度信賴 KRA。
另一方面，本文所提出的金鑰恢復系統可以支援多位使
用者的檔案分享環境，有別於學者 Yen所提出[4]，只適
用於個人的檔案安全存放之金鑰恢復架構。 
 
表 II 
系統架構分析表 
  本研究機制 Yen [4] Nieto et al. [6] 
金鑰託管 
X 
KRA 無法直接得到
目標金鑰明文資
料。 
X 
KRA 無法直接得到
目標金鑰明文資
料。 
V 
使用者註冊時 KRA
計算機密值α，可
視為目標金鑰之部
分明文資訊存放在
KRA中。 
金鑰封存 
V 
使用者需傳送金鑰
恢復資訊給 KRA，
KRA 才可以正確恢
復目標金鑰。 
V 
使用者需傳送金鑰
恢復資訊給 KRA，
KRA 才可以正確恢
復目標金鑰。 
V 
KRA 需要知道金鑰
恢復資訊才可以正
確恢復目標金鑰。 
多使用者 V X V 
 
4.4   系統延伸工作 
多位使用者 
        就實際應用而言，限制使用者只可以和另外一人分
享檔案並不合理，相當可能會存在三位以上的使用者欲
分享檔案的應用需求。本文歸類下列兩種多人之資訊分
享模式，且兩種模式皆可適用於本文之金鑰恢復機制。 
(a)若 Alice想同時與 Bob及 Carol分享檔案 M，Alice可
以將 [ESK(M)||ESK||KRI||ListIDs]資料分別傳送給 Bob 及
Carol，但其中所包含之授權使用者列表 ListIDs 分別為
{Alice||Bob}和{Alice||Carol}。這樣的方式即使接收者不
在線上也可以正常運作；但是由於必須分別產製及傳送
資訊給 Bob 和 Carol，因此較無效率，尤其當分享之人
數增加時。 (b)可以利用  Conference Key Distribution 
Protocol[11]，讓所有檔案分享使用者共同合作產製一把
分享金鑰 DHK，然後利用 DHK 產製出用來加密交談金
鑰 SK 之金鑰 EK。這樣的方式需要所有檔案分享使用者
同時在線上，才得以進行會議金鑰建立協定，而其他運
作方式則與第三節所提出之金鑰恢復架構相同。 
 
多個金鑰恢復主機 
        在實際的應用中，為了讓系統更加安全、不用完全
信賴一部 KRA，部份應用中也會有多個 KRA 的需求，
而本文所提出之金鑰恢復架構也可以達到此需求。以下
簡要說明其步驟：(a)系統中包含 n 個 KRA， 分別為
KRA1,…KRAn，其金鑰對分別為(xsi, ysi)，i=1~n。(b)產
製 KRI 階段，EK 產生方式為「(11)」，KRI=EDHK1||…
||EDHKn「(13)」。(c)金鑰恢復階段，Bob將 EDHKi傳送
到 KRAi，KRAi利用私密金鑰計算出 ETKi，解密 EDHKi
取得 gDHKAB和 ListIDs，驗證 Bob 是否有金鑰恢復權限
後，計算出 Ti「(14)」。Bob 收到 Ti後，將 Ti解密便可
以恢復 ysiDHKAB，計算 EK。 
  )(
1
AB
n
AB DHK
s
DHK
s yyHEK ÅÅ=   (11) 
  )(
iASi
DHKHETK =  (12) 
  )||( IDs
DHK
ETK ListgEEDHK ABii =  (13) 
  ))(( isAB
B
xDHK
AKi gET =  (14) 
 
4.5   系統特色 
        本文所提出之系統與 Neito 等學者之方法[6]最大之
不同在於，方法[6]中使用者 Alice 在註冊階段，KRA會
為 Alice新產製一個相對於 yA的機密值存放在 KRA，然
後以此機密值取代 Alice 自己產製的私密金鑰 xA，進行
系統後續的金鑰恢復動作。而本文所提出的架構，KRA
不用額外產生使用者協助金鑰，直接利用使用者雙方的
金鑰產生共享金鑰，不但簡化系統流程、減少 KRA 的
運算負荷，而且更有效率的達到功能需求。此外，接收
者 Bob 若遺失私密金鑰，可以先向傳送者 Alice 求助，
要求 Alice協助恢復金鑰，不用向 KRA要求金鑰恢復。
除非 Alice 和 Bob 雙方都遺失私密金鑰，沒辦法重新自
行產生 DHK，才需要向 KRA 要求金鑰恢復動作。本文
所提出之系統亦提供一個完善的金鑰恢復權限管理，傳
51
