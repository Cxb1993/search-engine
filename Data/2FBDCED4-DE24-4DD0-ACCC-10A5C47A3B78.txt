行政院國家科學委員會專題研究計劃成果報告 
圖形標示演算法之設計分析與應用 
97-2221-E-002-094-MY3 
  (完整報告) 
執行期間:97 年 8 月 1 日至 100 年 7 月 31 日 
計畫主持人: 顏嗣鈞 教授 國立台灣大學電機工程系 
中文摘要: 
 
「圖形繪製」 (graph drawing)的研究重點，在於探討如何在一個平面或是三維空
間中，設計演算法將圖形作最完美的視覺化呈現。好的繪圖的呈現將有助於我們
對整個圖形所隱含的資訊有更清楚的瞭解。因此圖形繪製已成為「資訊視覺化」 
(Information Visualization) 研究中非常重要的一環。當我們想要視覺化一種資訊
時，我們經常必須使用文字標籤  (text label) 來連接圖形特徵  (graphical 
feature)。直到現在，絕大部分標籤位置的放置仍主要是用手動的，尤其是在繪
製地圖時。例如在地圖製作學  (Cartography)、地理訊息系統  (Geographic 
Information System; GIS)中，地圖的標示是必須要有效率地被執行的。因此，有
極大的需求來尋找自動地圖標示演算法。本計劃中 我們針對自動地圖標示研究
中之「邊界標示問題」、「圓形地圖標示問題」、「動態邊際標示問題」等等核心問
題進行演算法的設計與分析。除了在理論上探討以上相關問題的計算複雜度以及
演算法的設計之外 ，並將利用我們所推導的方法 ，應用到實際地圖視覺化的展
現上。 
 
在此三年期研究計畫中， 主持人以圖形理論以及演算法為基礎，探討圖形標示演
算法相關問題，獲得許多具體成果。在接下來的報告中，我們將對於研究成果逐一
敘述。 
4. C. Lin, H. Wu,  and H. Yen, Boundary Labeling  in Text Annotation,  in 
Proc.  of  13th  International  Conference  on  Information  Visualisation 
(IV09), IEEE CS Press, pp.110‐115, Barcelona, Spain, Jul. 14‐17, 2009.    
Figure 1: Examples of annotation label layouts in Taipei MRT maps: (a) A con-
ventional layout where image labels are placed closer to the corresponding sites.
(b) The proposed layout into which commonly used design in hand-drawn maps
is incorporated.
because the labeling space around the metro network often consists of multiple
non-rectangular regions including small ones, where we cannot directly apply the
conventional boundary labeling techniques neither.
In this paper, we present a new approach for placing textual and image annota-
tion labels on the metro maps while maintaining the above aesthetic arrangement
of such labels in the map domain. This is accomplished by segmenting the entire
map into content, internal, and external zones, so that we can arrange annotation
labels according to their label types. We compute such zone-based segmentation
by applying conventional image processing techniques to dilate the network of
metro lines on the map image. This segmentation also allows us to introduce the
potential field over the outermost external zone, where we can aesthetically align
the image annotation labels along the map boundaries by referring to the potential
values. Note that in our setup, we take a metro net3 work as input in which each
vertex of the underlying graph represents a station together with its geographical
position and each edge corresponds to the metro route between the correspond-
ing pair of adjacent stations. We also assume that textual and image annotation
labels correspond to each station of the metro network, and retain the name of the
station and a thumbnail photograph of the view around that station, respectively.
We formulate the optimal placement of textual and image annotation labels as
a combinatorial optimization and search problem, employing genetic algorithms
2
Rl2
(a) type-opo (b) type-po (c) type-s
l4
l5
track routing area 
l1
l2
l3
l4
l5
l2
l1
l3
l4
l5R R
l3
(b) type-do
R
l2
l1
l3
l4
l5
l1
Figure 2: Illustration of leaders.
straight-line and diagonal-orthogonal leader types, respectively, which can easily
be understood from the examples given in Figures 4 (a), (b), (c) and (d). It is as-
sumed that the parallel (i.e., ‘p’) segment associated with a type-opo leader lies in
a track routing area sandwiched between R and the label stack. See Figure 4(a). In
a recent article, the idea of the so-called indirect leaders was proposed for possibly
shortening the total leader length in one-side boundary labeling. Indirect leaders
utilize the left side of the map to route the parallel segments of type-opo leaders.
See the leader connecting to label #6 in Figure 3(b) as an example of an indirect
leader. Such a new type of boundary labeling is called 1.5-side boundary label-
ing with type-opo leaders, which is likely to find applications in, for example,
text annotation for word processing softwares (see Figure 3(c) for an illustrating
example).
#1
#2
#3
#4
#5
#6
(a)
indirect 
leader
#1
#2
#3
#4
#5
#6
(b) (c)
Figure 3: (a) One-side boundary labeling with type-opo leaders. (b) 1.5-side
boundary labeling with type-opo leaders. (c) Application to a word processing
annotation system.
In this paper, we consider, from a computational complexity viewpoint, the to-
tal leader length minimization (TLLM) problem and the total bend minimization
(TBM) problem for variants of 1.5-side boundary labeling with type-opo leaders,
4
3D physical models from 2D papercraft patterns is by itself an interesting en-
tertainment, especially for children and families to share pleasant experiences. A
variety of methods have been developed recently for this purpose both in the fields
of computational geometry and computer graphics.
Although existing techniques are effective, they usually decompose an input
3D model into a relatively large number of unfolded patches. This is a serious
problem in practice because we have to seek the correspondences between the
boundary edges of different patches when merging them, or even worse, we have
to fit a tiny piece, having a few faces only, to the remaining part of a 3D paper-
craft model tightly enough. Actually, facilitating simple search for the boundary
edge matching is crucial for accelerating the construction of the corresponding
papercraft model.
This paper presents a new heuristic approach for fully optimizing the 2D un-
folding of an input 3D mesh. The key ideas of our approach are inspired by the
concept of topological surgery, which allows us to encode the edge sequence on
the boundary of the unfolding using a symbolic representation. Furthermore, in
order to ease the papercraft construction process, we have developed a genetic-
based algorithm for unfolding the 3D mesh into one single patch. This formula-
tion allows us to construct the 3D papercraft model only through simple atomic
operations for merging boundary edges of the 2D unfolding, where we can always
find a pair of duplicated edges that are next to each other.
Our approach is distortion-free in the sense that we need not stretch and shrink
unfolded patterns to construct the papercraft models, unlike most conventional ap-
proaches. Actually, unfolding a polyhedron into a single unfolded patch without
any deformation is a well-known open problem and has intensively been studied
so far rather from a theoretical point of view. However, to our knowledge, the
only available solution to this problem is to check all the possible combinations
of edges to be cut over the input polyhedron until we find an acceptable solution,
which may lead to combinatorial explosion. On the other hand, our genetic-based
approach considerably accelerates the search for the overlap-free single connected
patch by adaptively sampling the search space of mesh unfoldings. This is accom-
plished by classifying mesh vertices into hyperbolic and elliptic ones by referring
to their surface curvatures, which lets us instantly reject local self-overlaps be-
tween a pair of neighboring faces without actually projecting them onto a 2D
plane. Our approach usually converts a 3D mesh into a single unfolded patch
6
Most of the research on map labeling has primarily focused on labeling point
features, and the basic requirement in this case is that all the labels should be
pairwise disjoint. It is clear that such a requirement is difficult to be achieved in
the case where large labels are placed on dense points. In practice, large labels are
usually used in technical drawings or medical atlases where certain site-features
are explained with blocks of texts. To address this problem, Bekos et al. proposed
the so-called boundary labeling, in which all labels are attached to the boundary
(four sides) of a rectangle R enclosing all sites, and each site is connected to a
unique label by a leader, which may be a rectilinear or straight line segment.
In such a setting, they assumed that there are no two sites with the same x- or y-
coordinates, and investigated how to place the labels and leaders in a drawing such
that there are no crossings among leaders and either the total leader length or the
bends of leaders are minimized under a variety of constraints. In a recent article,
Bekos et al. investigated a similar problem for labeling polygonal sites under the
framework of boundary labeling. Furthermore, Lin et al. investigated the multi-
site-to-one-label boundary labeling, in which more than one site is allowed to be
connected to a common label and each site is connected only by a leader.
Conventionally, boundary labeling is identified as k-side labeling with type-t
leaders (where k ∈ {1,2,4} and t ∈ {opo, po,s,do}) if the labels are allowed to
be attached to the k sides of the enclosing rectangle R by only type-t leaders. The
parameter t specifies the way a leader is drawn to connect a site to a label. The
opo, po, s, and do mean that the leader stand for orthogonal-parallel-orthogonal,
parallel-orthogonal, straight-line and diagonal-orthogonal, respectively, which
can easily be understood from the examples given in Figures 4 (a), (b), (c) and (d).
For each type-opo leader, we further assume that the parallel (i.e., ‘p’) segment
lies immediately outside R in the so-called track routing area, as shown in Figure
4 (a).
R
l2
(a) Type-opo (b) Type-po (c) Type-s
l4
l5
Track Routing Area 
l1
l2
l3
l4
l5
l2
l1
l3
l4
l5R R
l3
(b) Type-do
R
l2
l1
l3
l4
l5
l1
Figure 4: Illustration of leaders.
8
communication costs among the group members. Hence, the system is very help-
ful in practice. However, the current visualization interface for the text annotation
system is not admirable and has the following drawbacks:
• When the number of text comment labels is getting larger, or there exist
many large-size labels, the labels associated with the same text line may be
placed too far from the text line (e.g., see labels #3, #4 and #5 which are
associated with the second text line from the bottom in Figure 5). In this
case, the diagonal segments of the leaders connected to those labels would
be too close to be recognized easily.
• When the number of marked words grows larger, the number of text com-
ment labels also grows larger. In this case, the annotation of placing all the
labels on the same side is not admirable in visualization.
As a result, it is of importance and interest to develop better visualization interface
for the text annotation system.
In this paper, we develop two approaches to the visualization interface for the
text annotation system. One should notice that we still apply one-site-to-one-label
boundary labeling to the interface, and the only difference between the previous
work and our work is that two sites with the same y-coordinates are allowed in
our work. In our setting, since too dense type-od leaders may not be recognized
easily (see Figure 5), we prefer to apply type-opo leaders (see Figure 6). First, we
propose the so-called 1.5-side boundary labeling with type-opo leaders, as shown
in Figure 7, in which type-opo leaders can be classified into two categories: direct
leaders (as the original ones) and indirect leaders (i.e., we make use of the left side
of document to route type-opo leaders so that the leaders are connected to their
labels indirectly, e.g., see the leader connected to label #6 in Figure 7). Under
this setting, we show that there exists a polynomial time algorithm to place labels
and leaders such that the total leader length is minimized and there are no leader
crossings.
Second, we propose the two-side boundary labeling with type-opo leaders for
the annotation system, as shown in Figure 8, in which the labels placed on the two
sides of the document are not crowded so that we can observe them easily. Al-
though the two-side boundary labeling with type-opo leaders has been discussed
in the previous work, all of them assume that the number of labels on each of the
two sides of the document are given. In this paper, we consider that the number of
10
附錄 
 
1. H. Wu, S. Takahashi, C. Lin, and H. Yen, A Zone-Based Approach for Placing 
Annotation Labels on Metro Maps, in Proc. of 11th International Symposium 
on Smart Graphics (SG 2011),  (LNCS 6815), pp. 91-102, Bremen, Germany, 
July 18-20, 2011. 
 
 
2. C. Lin, S. Poon, S. Takahashi, H. Wu, and H. Yen, One-and-a-half-side 
Boundary Labeling,  in Proc. of 5th International Conference on 
Combinatorial Optimization and Applications (COCOA 2011),  (LNCS 6831), 
pp. 387-398, Zhangjiajie, Hunan, China, Aug. 4-6, 2011. 
 
 
3. S. Takahashi, H. Wu, S. Saw, C. Lin, and H. Yen, Optimized Topological 
Surgery for Unfolding 3D Meshes, in  Computer  Graphics  Forum, 
(Proceedings of Pacific Graphics 2011), Vol. 30, No. 7, pp. 2077‐2086, 2011.   
 
 
4. C. Lin, H. Wu,  and H. Yen, Boundary Labeling  in Text Annotation,  in 
Proc.  of  13th  International  Conference  on  Information  Visualisation 
(IV09), IEEE CS Press, pp.110‐115, Barcelona, Spain, Jul. 14‐17, 2009.    
2(a) (b)
Fig. 1. Examples of annotation label layouts in Taipei MRT maps: (a) A conventional
layout where image labels are placed closer to the corresponding sites. (b) The proposed
layout into which commonly used design in hand-drawn maps is incorporated.
small space around the map content. External labeling overcomes this problem
by seeking more labeling space away from the map content, but at the cost of
applying leaders that often disturb the visual quality of the annotated map.
In hand-drawn metro map illustrations, the mixture of internal and external
labels is effectively employed to apply textual and image annotation labels. How-
ever, the arrangements of such textual and image labels are quite different in that
the textual labels are placed in the vicinity of the corresponding site, while the
image labels are more likely to be aligned around the corner of the map domain
or along its boundaries, so that we can fully enhance the aesthetic arrangement
of such labels on the entire map as shown in Fig. 1(b). Indeed, conventional
approaches attach image labels in the same way as the textual ones, resulting in
a map that cannot maintain a visually plausible arrangement of image labels, as
seen in Fig. 1(a). Nonetheless, formulating this kind of aesthetic map design as
a computational algorithm is still a challenging task in the sense that we have to
solve a rectangle packing problem, which usually leads to a well-known combina-
torial NP-hard problem. Furthermore, the problem becomes more complicated
especially for annotating metro maps. This because the labeling space around
the metro network often consists of multiple non-rectangular regions including
small ones, where we cannot directly apply the conventional boundary labeling
techniques neither.
In this paper, we present a new approach for placing textual and image
annotation labels on the metro maps while maintaining the above aesthetic ar-
rangement of such labels in the map domain. This is accomplished by segmenting
the entire map into content, internal, and external zones, so that we can arrange
annotation labels according to their label types. We compute such zone-based
segmentation by applying conventional image processing techniques to dilate the
network of metro lines on the map image. This segmentation also allows us to
introduce the potential field over the outermost external zone, where we can
aesthetically align the image annotation labels along the map boundaries by
referring to the potential values. Note that in our setup, we take a metro net-
4by formulating the label layouts in hand-drawn illustrations [10], which were
followed by a real-time algorithm for annotating 3D objects [9]. However, these
schemes used the external labels as the replacements of internal ones when the
labels cannot be placed close enough to the corresponding sites, and always tried
to embed both types of labels as close as possible to the sites. (See Fig. 1(a).)
Bekos et al. [2] also presented the combined use of internal and external labels
while the external labels were expected to stay on the predefined boundary
margins only. Our proposed approach differs from the conventional ones in that
it also takes advantage of a set of small empty space around the given metro
network as the labeling space, while keeping the aforementioned aesthetic layout
of textual and image annotation labels on the entire map domain. Combinations
of internal and external labels have also been employed to annotate various
targets including column charts [17], 3D virtual landscapes [15], surfaces of 3D
bumpy objects [6], and 3D illustrations [7].
Metro map visualization itself is an interesting theme that has been inten-
sively researched recently [21]. In this category, the metro map was aesthetically
deformed first and the stations were then annotated by textual labels. Hong et
al. [11] presented an approach to visualizing metro maps based on the spring
models, Bo¨ttger et al. [4] developed a scheme for distorting metro maps for an-
notation purposes, Stott et al. [19] formulated multiple criteria for optimizing
metro map layout and placing textual labels and No¨llenburg and Wolff [18] em-
ployed mixed-integer programming to draw and label metro maps in a visually
plausible manner. In our approach, we respect the original geometry of the given
metro network and focus on the optimal placement of annotation labels only.
3 Zone-Based Segmentation of the Map Domain
Our approach begins by partitioning the metro map domain into three zones:
the content, internal, and external zones. The content zone tightly encloses the
metro network and we do not place any labels in that zone. The internal zone
is next to the content zone and we can place textural labels only there. The
external zone is the complement of the previous two zones and we can embed
any types of labels there. Note that in this zone-base map segmentation, we can
lay out textual labels on both the internal and external zones while image labels
can be placed within the external zone only, as shown in Fig. 3.
3.1 Dilating Metro Lines on the Map Image
For defining the three different zones over the metro map, we first generate the
metro network image by drawing the given metro lines, then apply the mor-
phological dilation operations to the image to synthesize dilated metro network
images. Note that, in our implementation, we employed the ordinary 3× 3 rect-
angular kernel mask, which is equipped with the OpenCV library by default.
Although Cipriano and Gleicher [6] applied both the dilation and erosion op-
erations to compute the scaffold surface over the input 3D bumpy objects, our
6(a) (b)
Fig. 3. (a) Zone-based segmentation on Taipei MRT map. White, orange, and gray
colors (with gradation) indicate the content, internal, and external zones, respectively.
In the external zone, black and white colors indicate high and low potential regions,
respectively. (b) Taipei MRT map with textual and image annotation labels.
map boundary rather than in the neighborhood of the corresponding site. We
also keep potential values rather uniform in the region away from the boundary
to make image labels freely move around in that region to avoid undesirable
conflicts with other labels. The potential field has been defined in our approach
again by applying dilation operations ne times, where ne > ni, to the binary
image in Fig. 2(b), so as to obtain the sufficiently dilated metro network image as
shown in Fig. 2(e). This dilated image is then blurred with the Gaussian filter to
obtain the potential field as shown in Fig. 2(f), where the black and white colors
indicate high and low potential regions, respectively. In our implementation,
ne = 64 by default.
3.3 Discretizing the Map Domain into Grid Square Cells
Basically, we can find good positions for each label by referring to the zone-based
map partition and potential field that we have obtained. However, allowing the
annotation labels to move over the map domain pixel by pixel leads to the
excessive degree of freedom in their position. In our approach we discretize the
map domain into a set of grid square cells in order to effectively limit the number
of available positions for each label, which allows us to reduce the search space
for optimized label placements. Note that in our implementation, we fixed the
side length of the grid square to be 16 pixels. This discrete representation of the
map domain can be easily obtained by dividing the side lengths of the image
by the grid square size. We then refer to each pixel value of the resized image
for retrieving the zone-based map segmentation and potential values. In our
implementation, we use the OpenCV library again to perform the image resizing
operations. Fig. 3(a) represents an example of the resulting set of grid square
cells together with the zone-based segmentation and potential field described
previously.
8Fig. 5. Greedy search for the best positions of labels in the order of closeness to the
sites.
(a) (b)
Fig. 6. Spatial distribution of the fitness values for placing (a) textual and (b) image
labels around the transfer station in circles. White color indicates the better positions.
This way, each textual label can be matched with its corresponding site
because they are close enough to each other in general. However, if their distance
exceeds the predefined threshold, we need to draw a leader between them to fully
clarify the correspondence between the station and its name in the metro map
visualization. Such a case can be found in Fig. 3(b). For the image annotation
labels, on the other hand, we use a different strategy to find the optimal positions.
As described earlier, we already synthesized the potential field in the external
zone, which allows us to align the image labels around the corner of the map
domain or along its boundaries. For finding the best position for an image label,
we compute the sum of the potential values on the square cells that will be
covered by the label at each possible position, and then employ the position
having the optimal sum while avoiding conflicts with other existing labels on
the map.
In our framework, we place textual and image annotation labels individually
using two different chromosome pools. Actually, we place textual labels first
and then image labels, where we try to avoid overlap between the textual and
image labels while allowing crossings between the textural labels and leaders
connected to the image labels. This is because we can considerably alleviate the
visual flickers due to such crossings, by assigning different colors to the texts and
leaders of the image annotation labels, as shown in Fig. 3(b).
Moreover, we also design the arrangement of annotation labels so that all the
labels are free of conflicts with the metro network itself. In our implementation,
10
(a) (b)
Fig. 7. (a) Uniform and (b) adaptive label size adjustment for Taipei MRT maps.
Important stations are emphasized by enlarging the text and image annotation labels.
(a) (b)
Fig. 8. Influence of different weight values λ1 and λ2 on the label layouts over Tokyo
subway maps. (a) λ1 = 0.8 and λ2 = 0.2. (b) λ1 = 0.2 and λ2 = 0.8. The number of
labels is maximized in (a) while the total sum of leader lengths is minimized in (b).
Fig. 3(a) shows the zone-based segmentation of Taipei MRT map calculated
in our system and Fig. 3(b) presents the finalized layout of textual and im-
age annotation labels on the map. The synthesized map clearly shows that we
can aesthetically align image annotation labels around the corner or along the
boundaries of the map domain, while textual labels are placed close enough to
the corresponding stations. Note here that we assign higher priority to transfer
stations and terminals by default in our system, thus annotation labels are more
likely to be applied to these stations. We can also emphasize such important
stations explicitly by enlarging the corresponding annotation labels as demon-
strated in Fig. 7(b), which successfully draw more attention to some specific
stations compared to Fig. 7(a). Moreover, the label layout can be controlled by
tweaking the weight values in the objective function for our genetic-based opti-
mization. Fig. 8 exposes such an example where we can increase the number of
embeddable labels (Fig. 8(a)) or minimize the total leader lengths (Fig. 8(b)).
Fig. 9 demonstrates that our system also provides a semantic zoom interface for
12
2. Bekos, M.A., Kaufmann, M., Papadopoulos, D., Symvonis, A.: Combining tra-
ditional map labeling with boundary labeling. In: Proc. 37th International Con-
ference on Current Trends in Theory and Practice of Computer Science (SOF-
SEM2011). Springer LNCS, vol. 6543, pp. 111–122 (2011)
3. Bekos, M.A., Kaufmann, M., Symvonis, A., Wolff, A.: Boundary labeling: Models
and efficient algorithms for rectangular maps. Computational Geometry: Theory
and Applications 36, 215–236 (2007)
4. Bo¨ttger, J., Brandes, U., Deussen, O., Ziezold, H.: Map warping for the annotation
of metro maps. IEEE Comptuer Graphics and Applications 28(5), 56–65 (2008)
5. Christensen, J., Marks, J., Shieber, S.: An empirical study of algorithms for point-
feature label placement. ACM Trans. Graphics 14(3), 203–232 (1995)
6. Cipriano, G., Gleicher, M.: Text scaffolds for effective surface labeling. IEEE Trans.
Visualization and Computer Graphics 14(6), 1675–1682 (2008)
7. Cˇmol´ık, L., Bittner, J.: Layout-aware optimization for interactive labeling of 3D
models. Computers and Graphics 34, 378–387 (2010)
8. do Nascimento, H.A.D., Eades, P.: User hints for map labeling. Journal of Visual
Languages and Computing 19, 39–74 (2008)
9. Go¨tzelmann, T., Hartmann, K., Strothotte, T.: Agent-based annotation of inter-
active 3D visualization. In: Proc. 6th International Symposium on Smart Graphics
(SG2006). Springer LNCS, vol. 4073, pp. 24–35 (2006)
10. Hartmann, K., Gotzelmann, T., Ali, K., Strothotte, T.: Metrics for functional and
aesthetic label layouts. In: Proc. 5th International Symposium on Smart Graphics
(SG2005). Springer LNCS, vol. 3638, pp. 115–126 (2005)
11. Hong, S.H., Merrick, D., do Nascimento, H.A.D.: Automatic visualisation of metro
maps. Journal of Visual Language and Computing 17, 203–224 (2006)
12. Lin, C.C.: Crossing-free many-to-one boundary labeling with hyperleaders. In:
Proc. IEEE Pacific Visualization Symposium 2010 (PacificVis 2010). pp. 185–192
(2010)
13. Lin, C.C., Kao, H.J., Yen, H.C.: Many-to-one boundary labeling. Journal of Graph
Algorithm and Appplications 12(3), 319–356 (2008)
14. Lin, C.C., Wu, H.Y., Yen, H.C.: Boundary labeling in text annotation. In: Proc.
13th International Conference on Information Visualization (IV2009). pp. 110–115
(2009)
15. Maass, S., Do¨llner, J.: Efficient view management for dynamic annotation place-
ment in virtual landscapes. In: Proc. 6th International Symposium on Smart
Graphics (SG2006). Springer LNCS, vol. 4073, pp. 1–12 (2006)
16. Mote, K.: Fast point-feature label placement for dynamic visualizations. Informa-
tion Visualization 6, 249–260 (2007)
17. Mu¨ller, S., Scho¨dl, A.: A smart algorithm for column chart labeling. In: Proc.
International Symposium on Smart Graphics (SG2005). Springer LNCS, vol. 3638,
pp. 127–137 (2005)
18. No¨llenburg, M., Wolff, A.: Drawing and labeling high-quality metro maps by mixed-
integer programming. IEEE Transactions on Visualization and Computer Graphics
17(5), 626–641 (2011)
19. Stott, J., Rodgers, P., Mart´ınez-Ovando, J.C., Walker, S.G.: Automatic metro map
layout using multicriteria optimization. IEEE Transactions on Visualization and
Computer Graphics 17(1), 101–114 (2011)
20. Wall, M.: GAlib: A C++ library of genetic algorithm components,
http://lancet.mit.edu/ga/
21. Wolff, A.: Drawing subway maps: A survey. Informatik - Forschung und Entwick-
lung 22, 23–44 (2007)
388 C.-C. Lin et al.
#1
#2
#3
#4
#5
#6
(a)
indirect
leader
#1
#2
#3
#4
#5
#6
(b) (c)
Fig. 1. (a) One-side boundary labeling with type-opo leaders. (b) 1.5-side boundary
labeling with type-opo leaders. (c) Application to a word processing annotation system.
diﬃcult to be achieved in the case where large labels are placed on dense points.
To address this problem, Bekos et al. [3] proposed the so-called boundary labeling,
in which all labels are attached to the boundary (four sides) of a rectangle R
enclosing all sites, and each site is connected to a unique label by a leader, which
may be a rectilinear or a straight-line segment. In such a setting, they assumed
no two sites with the same x- or y- coordinates, and investigated how to place the
labels and leaders in a drawing such that there are no crossings among leaders
and either the total leader length or the total number of bends of leaders is
minimized under a variety of constraints. Bekos et al. [2] investigated a similar
problem for labeling polygonal sites under the framework of boundary labeling.
Subsequently, Lin [7] used hyperleaders and multiple copies of the same label
to propose algorithms for crossing-free multi-site-to-one-label boundary labeling
[8], in which more than one site is allowed to be connected to a common label.
Boundary labeling [3,4,1] is characterized as k-side labeling with type-t leaders
(where k ∈ {1, 2, 4} and t ∈ {opo, po, s, do}) if the labels are allowed to attach to
the k sides of the enclosing rectangle R by only type-t leaders. The parameter
t speciﬁes the way in which a leader is drawn to connect a site to a label. The
opo, po, s, and do stand for orthogonal-parallel-orthogonal, parallel-orthogonal,
straight-line and diagonal-orthogonal leader types, respectively. It is assumed
that the parallel (i.e., ‘p’) segment associated with a type-opo leader lies in a
track routing area sandwiched between R and the label stack. See Figure 1(a).
In a recent article [9], the idea of the so-called indirect leaders was proposed for
possibly shortening the total leader length in one-side boundary labeling. Indirect
leaders utilize the left side of the map to route the parallel segments of type-opo
leaders (while the original ones that do not utilize the left side are called direct
leaders). See Figure 1(b) for an example. Such a new type of boundary labeling
is called 1.5-side boundary labeling with type-opo leaders, which is likely to ﬁnd
applications in, for example, text annotation for word processing softwares as
[9] suggests (see Figure 1(c) for an illustrating example). In general, the track
routing area is not wide, so too many direct leaders in this area would make it
diﬃcult to tell them apart (see Figure 1(a)). The introduction of indirect leaders
may lead to fewer direct leaders in this area, where the routing of those direct
leaders can be distinguished more easily (see Figure 1(b)).
390 C.-C. Lin et al.
#1
#2
#3
#3
#1
#2
(a)
#1
#2
#2
#1
(b)
#1
#2
#3
#4
#4
#1
#2
#3
(c)
Fig. 2. (a) TLLM with nonuniform labels; (b) TLLM with uniform labels and FP
ports; (c) TBM with uniform labels
Table 1. Time complexity for a variety of 1.5-side boundary labeling models. FR
denotes ﬁxed-ratio port, and FP denotes ﬁxed-position port.
(LabelSize, LabelPort, Objective) time reference
(uniform, FR/sliding, TLLM ) O(n log n) Thm 1
(uniform, FP , TLLM ) O(n5) Thm 2
(uniform, FR/FP/sliding, TBM ) O(n5) Thm 2
(nonuniform, FR/FP/sliding, TLLM ) NP-complete∗ Thm 3
(nonuniform, FR/FP/sliding, TBM ) NP-complete∗ Thm 4
∗ An O(n4h) pseudo-polynomial time algorithm is developed in Theorem 5, where h
is the height of the map. Furthermore, if labels are of k diﬀerent heights, an O(nk+4)
time algorithm is available as Theorem 6 shows.
2.2 Problem Setting
We consider the following labeling problem. Given a rectangular area R of height
h and width w whose left lower corner resides at the origin of the x-y plane (i.e.,
R = [0, w] × [0, h]), and a set of n points (called sites) pi = (xi, yi), 1 ≤ i ≤ n,
located inside R (i.e., 0 ≤ xi ≤ w, 0 ≤ yi ≤ h, 1 ≤ i ≤ n), each of which is
associated with a rectangular label li of width wi and height hi, the one-and-
a-half-side (1.5-side, for short) boundary labeling problem is to place the labels
along one side of the boundary of R, and connect pi to li, 1 ≤ i ≤ n using
rectilinear leaders that are either direct or indirect (or leaders, for short) so that
a certain criterion is met. As illustrated in Figure 1, a rectilinear leader consists
of horizontal and/or vertical line segments connecting a site to its corresponding
label. We assume that h,w, xi, yi, hi, wi, 1 ≤ i ≤ n, are all positive integers.
We further require that a leader has at most two bends, which occur only in
one of the two track routing areas denoted as Aleft and Aright (see Figure 3). A
leader bending in the area Aright (resp., Aleft) is called a direct (resp., indirect)
leader. Throughout the rest of this paper, we assume that there are no two sites
with the same x- or y- coordinate, and sites are labeled as p1, p2, · · · , pn in the
increasing order of their y-coordinates.
We assume that
∑n
i=1 hi = h, i.e., the label heights sum up to the height
of R. In this case, the y-coordinate of the top of the j-th label is
∑j
i=1 h
′
i,
where h′i is the height of the i-th label from the bottom of the label stack. Note
392 C.-C. Lin et al.
p
U
B
h
n|U|
leader l
(a) Labeling Li.
p
B
U
(b) Labeling Li−1.
p
B
lh
B
lv
B
(c)
p
B
(d)
Fig. 4. The inner-most indirect leader in labeling (a) is replaced by a direct leader in
labeling (b). (c) and (d) are respectively the labeling (a) and (b) where the total leader
length of (b) for those sites in U are removed. Note that the leader segments that occur
in (d) but not in (c) are represented by dotted-line segments in (c).
downward and all the sites located below q belong to group B, then q ∈ B;
otherwise, q ∈ U (see Figure 4(a)). That is, there exist sites with leaders going
downward but not belonging to group B. Let Δ = {p} ∪ U ∪B.
If Δ = {p} only, then indirect leader  can be changed to a direct one im-
mediately, and the modiﬁed labeling is our required labeling Li−1. Otherwise,
we establish a labeling Li−1 with (i − 1) indirect leaders which is almost the
same as labeling Li except all the sites in Δ are connected by direct leaders (see
Figure 4(b)). Let d(pj) (resp., d′(pj)) denote the length of the leader connected
to site pj in Li (resp., Li−1), for any j ∈ {1, · · · , n}. For any set of sites, let
d(A) =
∑
pj∈A d(pj), and deﬁne d
′(A) similarly. From Figures 4(a) and 4(b),
it is observable that d(U) + |U |hn ≥ d′(U). Since d(p) > |U |hn in labeling Li
(see Figure 4(a)), the lengths d(U) + |U |hn and d′(U) can be removed in Li and
Li−1, respectively. Figure 4(c) (resp., Figure 4(d)) is the labeling Li in (a) (resp.,
Li−1 in (b)) removing the length d(U)+ |U |hn (resp., d′(U)), i.e., the total leader
length of Li is decreased no less than that of Li−1. Note that in Figure 4, the
leader segments that occur in (d) but not in (c) are represented by dotted-line
segments in (c). It is easy to see that the remaining length of the indirect leader
 in (c) can be used to compensate those dotted-line segments in (c), in which
lengths Bh and 
B
v compensate dotted horizontal and vertical segments, respec-
tively. Even so, there still exists a nonnegative remaining length of the indirect
leader  in (c). Hence, φ(Li) ≥ φ(Li−1), as required.
Like the above, we can construct Lj−2 according to Lj−1 such that φ(Lj−1) ≥
φ(Lj−2), and so forth. Finally, we have φ(Li) ≥ φ(Li−1) ≥ · · · ≥ φ(L1) ≥ φ(δ),
as required. unionsq
According to Lemma 1 above and [3] (the boundary labeling with direct leaders
can be found in O(n log n) time), we have the following theorem.
Theorem 1. The 1.5-side boundary labeling of the model (uniform , FR/sliding ,
TLLM ) can be found in O(n log n) time.
394 C.-C. Lin et al.
pb
(a) S(a, b, c) when j < i.
pa+i+1
pa+i-1
pa+j
pa+j-1
pa
pa+i
(c+b-a)-th
(c+i)-th
(c+j-1)-th
c-th
(c+j+1)-th
(c+i+1)-th
map label
S(a+i+1, b, c+i+1)
S(a+j, a+i-1, c+j+1)
S(a, a+j-1, c)
(c+j)-th
pb
pa+j+1
pa+j
pa+i+1
pa+i-1
pa
pa+i
(c+b-a)-th
(c+i)-th
(c+j-1)-th
c-th
(c+i-1)-th
(c+j+1)-th
map label
S(a+j+1, b, c+j+1)
S(a, a+i-1, c)
(c+j)-th
(b) S(a, b, c) when j > i.
S(a+i+1, a+j, c+i)
Fig. 5. Illustration of a subproblem
As for the complexity of the algorithm, we construct n tables T1, · · · , Tn where
table Ti has (n− i+1)× (n− i+1) entries for i ∈ {1, · · · , n}; the entry (j, k) in
table Ti records the minimal total leader length when sites pj, pj+1, · · · , pj+i−1
are connected to the k-th, the (k + 1)-th, · · ·, and the (k + i − 1)-th labels in
the label stack by direct and indirect type-opo leaders. By doing so, the solution
of our problem can be found in the entry Tn(1, 1). In view of the dynamic
programming formula, each entry of Table Ti, 1 ≤ i ≤ n, can be computed in
O(i2) time. Hence, using a bottom up approach, Tn(1, 1) can be obtained in time
O(
∑n
i=1(n− i + 1)2i2) = O(n5). unionsq
4 Nonuniform-Label Cases
4.1 NP-Hardness
In this subsection, we show that the 1.5-side boundary labeling for non-uniform
labels is NP-complete for both TLLM and TBM .
Theorem 3. It is NP-complete to ﬁnd a 1.5-side boundary labeling of model
(non- uniform , FR/FP/sliding , TLLM ).
Proof (Sketch). We only consider the FR/FP-port model here. The NP-complete
proof for the sliding-port model can be shown along a similar line, and there-
fore, is omitted here. To see that the problem is in NP, since we assume that
h,w, xi, yi, hi, wi, 1 ≤ i ≤ n, are all positive integers. In order to show the NP-
hardness of our problem, we obtain a linear-time reduction from a single-machine
scheduling problem, called total discrepancy problem [6], to our problem. On one
machine, we plan to arrange the schedule for the non-preemptive execution of
a set J of 2n + 1 jobs J0, J1, . . . , J2n. Each job Ji has an execution time length
li ∈ Z+ such that l0 < l1 < . . . < l2n. For a planned schedule σ, the actual
execution midtime for job Ji is denoted by mi(σ). Each job has a preferred mid-
time, which corresponds to the time at which we would like the ﬁrst half of
the job to be completed. We assume that all the jobs share a single preferred
396 C.-C. Lin et al.
Proof (Sketch). We only discuss the sliding port case, because the ﬁxed-ratio
port case is similar. It is obvious to see that the problem is in NP. Hence, it
suﬃces to show that the problem is NP-hard. The proof of the NP-completeness
is based on the reduction from the following subset sum problem: Given A =
{a1, a2, · · · , an} and a number B, the objective of the problem is to ﬁnd a subset
A′ ⊂ A such that the sum of the elements in A′ is exactly B.
Given a set A = {a1, · · · , an} and a number B, we construct a map instance
as follows. There are n + 2 sites p1, p2, . . . , pn+2 in the map instance. The
height of the label connected with site pi is denoted by hi, in which hmin <
min{h1, · · · , hn} and hmin > n. Let {h1, · · · , hn} = {a1, · · · , an}, hn+1 = hn+2 =
k ≤ hmin, and a1 + · · · + an = 2B. Note that the y-coordinate of the bottom
side of the map is zero. For each i ∈ {1, · · · , n}, y(pi) ≤ hmin, y(pn+1) = h/2− 	,
and y(pn+2) = h/2 + 	, where h is the height of the map and 	 < hmin.
See also Figure 7. It is easy to see that the sum of the elements in A′ is exactly
B = (a1 + · · ·+ an)/2 if and only if the number of bends is 2n− 2. unionsq
4.2 Pseudo-polynomial Time Algorithm
An idea which parallels the one used in Theorem 2 is used to show the following:
Theorem 5. With respect to 1.5-side boundary labeling, both TLLM and TBM
can be solved in O(n4h) time when labels are of nonuniform height and ports are
either ﬁxed-ratio, ﬁxed-position, or sliding.
Proof. We only show how to solve the TLLM problem, since the TBM problem
can be solved similarly. Like in the proof of Theorem 2, our pseudo-polynomial
time algorithm is again based on the strategy of dynamic programming.
In the case of using ﬁxed-ratio or ﬁxed-position ports, we deﬁne γ(pi, t) (resp.,
(pi, t)), 1 ≤ i ≤ n, 0 ≤ t < t′ ≤ h, to be the length of a direct (resp., indirect)
type-opo leader from site pi to the ﬁxed port of li when the y-coordinate of the
bottom (resp., top) of the label is t (resp., t′) in the label stack, provided that
t′ − t = hi; if t′ − t 
= hi, then γ(pi, t) (resp., (pi, t)) = ∞. Note that t′ is
calculated in the dynamic programming procedure. In the case of using sliding
ports, γ(pi, t) and (pi, t) are deﬁned similarly except that a leader connects pi
to the closest point (as opposed to the ﬁxed point) on the boundary of li. We
let S(a, b, t) (where 1 ≤ a ≤ b ≤ n, 0 ≤ t ≤ h) denote the minimal total leader
length where sites pa, · · · , pb (1 ≤ a ≤ b ≤ n) are connected to their labels
la, · · · , lb which are placed in the label stack with t as the y-coordinate of the
bottom of the lowest label. In other words, labels la, · · · , lb occupy the area whose
y-coordinate ranges from t to t +
∑b
i=a hi. We deﬁne Ra,b to be the rectangle
[0, w]× [ya−1, yb+1].
Our dynamic programming formula for S(a, b, t) is as follows:
min{
b−a∑
i=0
γ(pa+i, t +
i−1∑
j=0
ha+j),
398 C.-C. Lin et al.
Theorem 6. With respect to 1.5-side boundary labeling, both TLLM and TBM
can be solved in O(nk+4) time when the labels are of constant k diﬀerent heights
and ports are either ﬁxed-ratio, ﬁxed-position, or sliding.
5 Conclusion
We have investigated the total leader length minimization problem and the bend
number minimization problem for one-and-a-half-side boundary labeling under
a variety of settings parameterized by the underlying label size (uniform vs.
nonuniform) and port type (ﬁxed-ratio, ﬁxed-position, vs. sliding). It turns out
the two problems under the uniform-label case are solvable in polynomial time,
whereas the problems become NP-complete under the nonuniform-label case. A
pseudo-polynomial time algorithm and a ﬁxed-parameter algorithm have been
proposed for those intractable problems. In addition, the case where indirected
leaders are not beneﬁcial was also identiﬁed.
References
1. Bekos, M., Kaufmann, M., No¨llenburg, M., Symvonis, A.: Boundary labeling with
octilinear leaders. Algorithmica 57(3), 436–461 (2010)
2. Bekos, M., Kaufmann, M., Potina, K., Symvonis, A.: Area-feature boundary label-
ing. The Computer Journal 53(6), 827–841 (2009)
3. Bekos, M., Kaufmann, M., Symvonis, A., Wolﬀ, A.: Boundary labeling: models and
eﬃcient algorithms for rectangular maps. Computational Geometry: Theory and
Applications 36(3), 215–236 (2006)
4. Benkert, M., Haverkort, H., Kroll, M., No¨llenburg, M.: Algorithms for multi-criteria
one-sided boundary labeling. In: Hong, S.-H., Nishizeki, T., Quan, W. (eds.) GD
2007. LNCS, vol. 4875, pp. 243–254. Springer, Heidelberg (2008)
5. Formann, M., Wagner, F.: A packing problem with applications to lettering of
maps. In: Proc. of the 7th Annual ACM Symposium on Computational Geometry
(SoCG 1991), pp. 281–288. ACM Press, New York (1991)
6. Garey, M., Tarjan, R., Wilfong, G.: One-processor scheduling with symmetric ear-
liness and tardiness penalties. Math. Oper. Res. 13, 330–348 (1988)
7. Lin, C.C.: Crossing-free many-to-one boundary labeling with hyperleaders. In:
Proc. of 3rd IEEE Paciﬁc Visualization Symposium (PaciﬁcVis 2010), pp. 185–
192. IEEE Press, Los Alamitos (2010)
8. Lin, C.C., Kao, H.J., Yen, H.C.: Many-to-one boundary labeling. Journal of Graph
Algorithms and Applications 12(3), 319–356 (2008)
9. Lin, C.C., Wu, H.Y., Yen, H.C.: Boundary labeling in text annotation. In: Proc. of
13th International Conference on Information Visualisation (IV 2009), pp. 110–115.
IEEE CS Press, Los Alamitos (2009)
10. Wagner, F.: Approximate map labeling is in Ω(n log n). Information Processing
Letters 52(3), 161–165 (1994)
11. Wagner, F., Wolﬀ, A.: Map labeling heuristics: Provably good and practically use-
ful. In: Proc. of the 11th Annual ACM Symposium on Computational Geometry
(SoCG 1995), pp. 109–118. ACM Press, New York (1995)
S. Takahashi, H.-Y. Wu, S. H. Saw, C.-C. Lin & H.-C. Yen / Optimized Topological Surgery for Unfolding 3D Meshes
(a) (b)
(c)
Figure 1: Unfolding a bunny model (348 faces). (a) A previous approach [SP05] unfolds the mesh into many patches including
small pieces. (b) Our approach converts the mesh into a single unfolded patch. (c) Steps for stitching boundary edges together
one by one for papercraft construction. The arrows of the same color indicate the correspondences between duplicated edges
together with their directions, while solid and broken lines on the patches represent mountain and valley folds, respectively.
rather from a theoretical point of view. However, to our
knowledge, the only available solution to this problem is
to check all the possible combinations of edges to be cut
over the input polyhedron until we find an acceptable so-
lution, which may lead to combinatorial explosion. On the
other hand, our genetic-based approach considerably accel-
erates the search for the overlap-free single connected patch
by adaptively sampling the search space of mesh unfoldings.
This is accomplished by classifying mesh vertices into hy-
perbolic and elliptic ones by referring to their surface cur-
vatures, which lets us instantly reject local self-overlaps be-
tween a pair of neighboring faces without actually projecting
them onto a 2D plane. As presented in Figure 1(b), our ap-
proach usually converts a 3D mesh into a single unfolded
patch for 3D meshes with up to 500 faces, which can be
considered as a size limit for hand-made papercrafts.
We assume that the input 3D mesh consists of triangular
faces only, while this is not a hard constraint because we
can easily partition a non-triangular face into a set of trian-
gles. There are no restrictions on the topological types of
the 3D meshes as long as they are orientable, which means
that topological tori and their connected sums can be suc-
cessfully unfolded without any extra cost. In our approach,
we also assume that the unfolded patches will be printed on
a single A3 sized sheet, to which the scale of the unfolded
patches is automatically adjusted to be fit compactly.
Our approach begins by partitioning a given 3D mesh into
a set of small unfolded patches. The unfolded patches are
then stitched together along boundary edges one by one us-
ing a genetic algorithm. The genetic-based optimization or-
dinarily transforms the initial set of small patches to a single
connected one, while we can optionally rearrange the config-
uration of the mesh unfolding to fully optimize the number
of unfolded patches. The boundary edges of the unfolded
patches are rendered using arrows having different colors,
so that we can easily identify the correspondence between
a pair of duplicated boundary edges together with their di-
rections as shown in Figure 1(c). In addition, mountain and
valley folds on the patches are explicitly rendered using solid
and broken lines, respectively, in our implementation.
The remainder of this paper is organized as follows: Sec-
tion 2 summarizes the previous approaches to 3D mesh un-
folding. Section 3 describes the basic ideas of the proposed
approach. The overall process is detailed from Section 4 to
Section 6, where Section 4 describes how we decompose
the input 3D mesh into a set of small unfolded patches,
Section 5 introduces an algorithm for stitching together un-
folded patches along boundary edges using a genetic algo-
rithm, and Section 6 presents an optional stage for rear-
ranging the mesh unfolding to fully minimize the number
of unfolded patches. After demonstrating several examples
of mesh unfoldings together with user studies in Section 7,
Section 8 concludes this paper.
2. Related Work
Unfolding 3D polyhedra has been intensively studied in the
field of computational geometry from a theoretical point of
view [She75]. A typical frequently asked question is whether
a polyhedron can be cut along its edges and unfolded onto a
2D plane without self-overlaps, while the only known so-
lution to this question is to try all the possible combina-
tions of edges to be cut. Readers can refer to recent surveys
(e.g. [DO05]) for further details.
From a practical point of view, on the other hand, unfold-
ing 3D models has been conducted after their shapes are fa-
c© 2011 The Author(s)
c© 2011 The Eurographics Association and Blackwell Publishing Ltd.
S. Takahashi, H.-Y. Wu, S. H. Saw, C.-C. Lin & H.-C. Yen / Optimized Topological Surgery for Unfolding 3D Meshes
(a) (b)
Figure 4: Self-overlaps on the mesh unfolding: (a) a local
self-overlap and (b) a global self-overlap.
craft models. For this purpose, we should unfold an input 3D
mesh into a single connected patch, or a few patches at most.
This is clear from Figure 2(c), where the tetrahedron is de-
composed into multiple patches. In this case, we have to con-
duct different operations where we find the correspondence
between a pair of boundary runs that are distributed to two
distinct patches such as {d,d−1}, {e,e−1}, and { f , f−1}.
This usually increases the total time of papercraft construc-
tion considerably, especially for naïve users, as the number
of unfolded patches becomes larger. However, if we can un-
fold the 3D mesh into a single connected component, we can
easily construct the papercraft model through the sequence
of atomic stitching operations of Type I only.
Indeed, Taubin et al. [TR98] studied how to unfold 3D
meshes in the context of topological surgery. Nonetheless,
their purpose is quite different from ours since they explored
high compression ratio of the 3D mesh representation, by
minimizing the number of bifurcations in the spanning tree
of cut edges. Furthermore, they did not consider anything
about the self-overlaps of the resulting 2D unfolding.
3.3. Classifying self-overlaps of mesh unfoldings
Our solution to this problem is to classify self-overlaps of
mesh unfoldings into two types: a local self-overlap that
causes an intersection between a pair of neighboring faces
in the same connected patch (Figure 4(a)), and a global self-
overlap where a pair of faces that are away from each other
has a mutual overlap (Figure 4(b)). We hope to identify these
self-overlaps before actually projecting the unfolded patches
onto the 2D plane because we need geometric computation
for that projection at the expense of relatively high compu-
tational cost. Actually, this is achievable especially for the
local self-overlaps in our approach, by taking into account
the surface curvature type at each vertex together with the
number of cut edges incident to that vertex.
According to [BDE∗03], we can classify the mesh ver-
tices into hyperbolic vertices having negative Gaussian cur-
vatures (Figure 5(a)) and elliptic vertices having positive
Gaussian curvatures (Figure 5(b)). Here, the Gaussian cur-
vature at each vertex is defined as the difference of 2pi (i.e.
360 degrees) and the sum of the angles spanned by adjacent
edges emanating from that vertex. It is obvious from Figure 5
that at each hyperbolic vertex we have to introduce at least
(a) (b)
Figure 5: (a) A hyperbolic vertex and (b) an elliptic vertex.
two cut edges to avoid local self-overlaps because the sum
of the corner angles around that vertex exceeds 2pi, while we
just require only one cut edge for an elliptic vertex.
The above observation implies that we can generally
avoid local self-overlaps by updating the number of cut
edges at each vertex whenever we split and merge the mesh
surface. As for the global self-overlaps, there are no effec-
tive means of detecting them and thus we just transform the
unfolded patches onto the 2D plane for detecting possible
self-overlaps. However, as a preprocess, we roughly check
the possible self-overlaps using the bounding boxes of the
unfolded patches, which accelerates the necessary geomet-
ric computation significantly.
3.4. Processing pipeline
In fact, there are two extreme choices for seeking an overlap-
free mesh unfolding: the first is to expand the spanning tree
of cut edges adaptively over the 3D mesh, and the second is
to compose the mesh unfolding by iteratively merging a set
of single triangular faces. The first choice can never find such
overlap-free unfoldings because we cannot evaluate how the
current set of cut edges is close to the optimal solutions. The
work by Straub et al. [SP05] is an example of this category.
On the other hand, the second choice is unlikely to reach
the optimal solutions due to excessive degrees of freedom
in merging mesh faces. This observation suggests that we
should explore the best tradeoff between the two extreme
choices so that we can find an optimal unfolding within a
certain period of time. This is why we decompose the in-
put 3D mesh into a set of small unfolded patches first, and
then stitch them together while avoiding undesirable self-
overlaps. In practice, the success of this approach depends
on how we control appropriate degrees of freedom in com-
posing the final mesh unfolding, as will be discussed later.
Thus, the overall processing pipeline of our approach con-
sists of three stages. The first stage of the pipeline is to seek
a set of clustered faces by computing a set of spanning sub-
trees of dual edges. The clustered faces are then stitched to-
gether along boundary edges while avoiding self-overlaps
in the second stage. As the final stage, we optionally rear-
range the configuration of the unfolded patches so that we
can avoid cases where the previous switching stage cannot
fully optimize the number of connected patches. These three
stages will be detailed in Sections 4-6.
c© 2011 The Author(s)
c© 2011 The Eurographics Association and Blackwell Publishing Ltd.
S. Takahashi, H.-Y. Wu, S. H. Saw, C.-C. Lin & H.-C. Yen / Optimized Topological Surgery for Unfolding 3D Meshes
unwanted self-overlaps. Here, at first glance, one might ex-
pect the technique of dynamic programming to give a satis-
factory solution, while a closer look reveals that various opti-
mization issues in 3Dmesh unfolding fail to comply with the
so-called “optimal substructure” property in general, which
is needed for dynamic programming to be applicable. On
the other hand, the GA will provide better local search in the
neighborhoods of the current solutions in the sense that the
child solutions share good partial orders of stitchable edges
with the parent solutions. In our setup, the order of stitchable
edges is encoded as a chromosome with a sequence of edge
IDs, as shown in Figure 8(a).
In the actual computation, we prepare an initial popula-
tion of such chromosomes by generating randomly ordered
edge IDs. However, we still need to rearrange the order of
edge IDs, according to whether the corresponding stitchable
edge can actually introduce a self-overlap-free combination
of unfolded patches or not. Suppose that we have a chromo-
some as shown at the top of Figure 8(a). The edge ID in a
white box corresponds to a stitchable edge along which we
can successfully merge a pair of unfolded patches, while a
gray box corresponds to a failure case due to self-overlaps.
In our algorithm, we move the IDs of successful edges to
the head of the chromosome while we push those of the fail-
ure cases to the back, as shown at the bottom of Figure 8(a).
Rearranging the edge IDs is usually conducted when evalu-
ating the fitness of the chromosome (Section 5.3), and helps
us conduct further evolutional computation using crossover
and mutation operations (Section 5.4). Note that a stitchable
edge can become unstitchable due to local self-overlaps dur-
ing the stitching stage, while this can be easily detected by
faithfully updating the numbers of cut edges at the corre-
sponding end vertices.
5.3. Function for evaluating the fitness
Another important factor is to define an objective function
that evaluates the fitness of each chromosome. In our ap-
proach, we formulate the objective function f to penalize
several factors of mesh unfoldings and minimize it to find
the best chromosome. In practice, f is defined as:
f = λpNp+λlRl +λmRm+λbRb. (1)
Here, Np is the number of unfolded patches, Rl = Fl/Ft ∈
[0,1] where Fl represents the number of faces excluded from
the largest patch and Ft represents the total number of faces,
Rm ∈ [0,1] is the relative ratio of the exterior margin around
the mesh unfolding on the sheet, and Rb = Eb/Et ∈ [0,1]
where Eb is the average number of edges between each pair
of the duplicated boundary edges and Et is the total num-
ber of boundary edges, respectively. λp, λl , λm, and λb are
weight values for the four terms, respectively.
Since our primary objective here is to minimize the num-
ber of connected components, we first introduce the number
as the first term of f . The second term is introduced due
#5#5#5#5 #5
#5#5#5#5#4 #2 3 #6 7 #1 0
#4 #6 2 3 7 0#1
(a)
#5
#5
#5
#5
#5
#5
#5#5#5#50 #1 2 3 7 #6#4
#5#5#5 #5#4 0 #6 2 3 7#1
#5#5#5#5 #5#4 #6 0 2 3 7#1
#5#5#5#5 #5#6 #1 2 3 7 0#4
#5#5#5#5 #5#0 #4 1 6 2 37
#5#5#5#5 #5#4 #0 6 7 2 31
#5#5#5#5 #5#4 6 #0 7 2 31
#5#5#5 #5 #56 #4 1 #0 2 37
p1
p2
p3
p4
q1
q2
q3
q4
(b)
#5 #5
#5#5#5#5 #5
#5#5#5#4 7 2 3 #6 0#1
#4 #6 2 3 7 0#1
(c)
Figure 8: Operations for chromosomes: (a) Reordering. (b)
Crossover. (c) Mutation. Edge IDs in white and gray boxes
correspond to successful and failure cases, respectively.
to the observation that the computation often converges to
an equilibrium solution if multiple patches share almost the
same number of faces. (See Section 7.3 also.) The third term
is employed just for maximizing the relative area of the un-
folded patches. Note that we use the approximate bin pack-
ing algorithm [IC01] in our approach, and freely change the
scale of the unfolded patches so that we can minimize the
area of the margin. The fourth term has been introduced to
make each pair of duplicated boundary edges close to each
other along the patch boundary. This certainly facilitates our
papercraft construction since we are more likely to find pairs
of corresponding boundary edges within a small neighbor-
hood along the patch boundary. Note that we set the weight
values as λp = λl = 10λm = 100λb by default in our im-
plementation, because minimizing the number of unfolded
patches is our first priority and maximizing the coverage of
the paper sheet is the next.
5.4. Crossover and mutation operations
Having prepared the initial population, we generally synthe-
size the next population by applying crossover and mutation
operations to existing chromosomes. In our GA setup, these
two operations are specifically designed for our problem so
that we can produce better child chromosomes effectively.
Suppose that, before applying the crossover operation, we
have two chromosomes p1 and q1, where the successful and
c© 2011 The Author(s)
c© 2011 The Eurographics Association and Blackwell Publishing Ltd.
S. Takahashi, H.-Y. Wu, S. H. Saw, C.-C. Lin & H.-C. Yen / Optimized Topological Surgery for Unfolding 3D Meshes
Figure 10: Examples of mesh unfoldings: horse (312 faces), dragon (344 faces), hand (336 faces), knot (480 faces), cat (702
faces), and fish (950 faces) from top left to bottom right. In each case, cut paths over the 3D mesh are indicated on the left and
its corresponding 2D unfolding is presented on the right. See Table 1 for the corresponding initial set of unfolded patches.
Table 1: Statistics and timing. f : Number of faces. n: Number of unfolded patches. t: Time for mesh unfolding (in seconds). r:
coverage of the sheet (in percentage). The arrow means that we employed the optional rearrangement stage as a post-process.
model f
MST Ours(65%) Ours(70%) Ours(75%)
n r n t r n t r n t r
bunny 348 13 36.6 1 31.8 30.9 1 19.0 20.5 1 40.8 27.6
horse 312 12 35.2 1 14.8 23.8 1 87.9 31.8 1 24.4 23.3
dragon 344 13 27.1 1 48.6 26.8 1 16.4 20.0 1 14.2 21.1
hand 336 18 32.5 1 54.3 30.9 2→1 18.3 20.4 1 24.0 16.6
knot 480 14 22.4 1 86.5 32.2 1 42.9 13.2 1 33.7 22.2
cat 702 28 32.2 1 332.2 32.0 4→1 202.3 14.1 2→1 244.5 20.1
fish 950 31 30.7 3→1 785.5 21.4 3→1 227.4 31.3 2→1 463.4 24.4
of the sheet. In practice, we can accomplish almost the same
coverage as that of the conventional MST-based method on
average. The computation time basically increases as the
number of mesh faces becomes large, while the time also de-
pends on the variation in the surface curvature of that mesh.
For example, articulated models such as the horse, dragon,
and hand meshes are harder to unfold because they have high
negative curvatures around the joint parts. Note that in our
GA computation, each population consists of 64 chromo-
somes and, at each generation update, half of them will be
replaced with those obtained by crossover and mutation op-
erations, where the probabilities of crossover and mutation
are set to be 0.9 and 0.1, respectively.
Figure 11 exhibits some of these models assembled as pa-
percrafts by hand together with the construction times.When
compared with existing techniques, these construction times
are significantly reduced to an acceptable period of time,
with the help of a commercially available cutting plotter. We
also equipped our system with an interface for specifying
a series of edges as a seam in the final mesh unfolding by
controlling the weights of the corresponding dual edges.
c© 2011 The Author(s)
c© 2011 The Eurographics Association and Blackwell Publishing Ltd.
S. Takahashi, H.-Y. Wu, S. H. Saw, C.-C. Lin & H.-C. Yen / Optimized Topological Surgery for Unfolding 3D Meshes
(a) (b) (c)
Figure 12: Failure cases where each unfolded patch is drawn in a different color. (a) We cannot compose a single patch from
multiple ones obtained by the MST-based approach. (b) Our genetic-based optimization is trapped in a equilibrium state without
the second term of the objective function. (c) We fail to unfold the mannequin model (1,376 faces) into a single connected patch.
8. Conclusion
This paper has presented a new heuristic approach to trans-
forming 3D meshes into an optimized layout of 2D un-
foldings. The key ideas have been inspired by the concept
of topological surgery, which allows us to construct paper-
craft models through atomic operations of stitching together
boundary edges of the mesh unfolding. For this purpose,
we have developed a genetic-based algorithm for optimizing
the number of 2D unfolded patches together with the cov-
erage of the paper sheet and the distance between each pair
of boundary edges around the 2D unfolding. Several experi-
mental results together with user studies and a discussion on
our framework are included to justify the present approach.
Acknowledgements
We are grateful to all the participants for taking part in the
user studies. This work has been partially supported by JSPS
under Grants-in-Aid for challenging Exploratory Research
No. 23650042, NSC 98-2218-E-009-026-MY3, Taiwan, and
NSC 97-2221-E-002-094-MY3, Taiwan.
References
[AKM∗06] ATTENE M., KATZ S., MORTARA M., PATANE G.,
SPAGNUOLO M., TAL A.: Mesh segmentation - a comparative
study. In Proc. Shape Modeling and Applications 2006 (2006),
pp. 14–25.
[BDE∗03] BERN M. W., DEMAINE E. D., EPPSTEIN D., KUO
E. H.-S., MANTLER A., SNOEYINK J.: Ununfoldable poly-
hedra with convex faces. Computational Geometry Theory and
Applications 24, 2 (2003), 51–62.
[DO05] DEMAINE E. D., O’ROURKE J.: A survey of fold-
ing and unfolding in computational geometry. In Combinato-
rial and Computational Geometry. Cambridge Univ. Press, 2005,
pp. 167–211.
[FH05] FLOATER M. S., HORMANN K.: Surface parameteriza-
tion: a tutorial and survey. In Advances in Multiresolution for
Geometric Modeling, Dodgson N. A., Floater M. S., Sabin M. A.,
(Eds.). Springer, 2005, pp. 157–186.
[GE04] GOPI M., EPPSTEIN D.: Single-strip triangulation of
manifolds with arbitrary topology. Computer Graphics Forum
23, 3 (2004), 371–379.
[GH97] GARLAND M., HACKBERT P. S.: Surface simplifica-
tion using quadric error metrics. In Proc. ACM SIGGRAPH 1997
(1997), pp. 209–216.
[Hos98] HOSCHEK J.: Approximation of surfaces of revolution
by developable surfaces. Computer-Aided Design 30, 10 (1998),
757–763.
[IC01] IGARASHI T., COSGROVE D.: Adaptive unwrapping
for interactive texture painting. In Proc. Symp. Interactive 3D
Graphics 2001 (2001), pp. 206–216.
[JKS05] JULIUS D., KRAEVOY V., SHEFFER A.: D-charts:
Quasi-developable mesh segmentation. Computer Grahics Fo-
rum 24, 3 (2005), 581–590.
[Mas80] MASSEY W. S.: A Basic Course in Algebraic Topology.
Springer, 1980.
[MGE07] MASSARWI F., GOTSMAN C., ELBER G.: Papercraft
models using generalized cylinders. In Proc. Pacific Grahics
2007 (2007), pp. 148–157.
[MS04] MITANI J., SUZUKI H.: Making papercraft toys from
meshes using strip-based approximate unfolding. ACM Trans.
Graphics 11, 3 (2004), 259–263.
[PF95] POTTMAN H., FARIN G.: Developable rational Bézier
and B-spline surfaces. ACM Trans. Graphics 12, 5 (1995), 513–
531.
[SCOGL02] SORKINE O., COHEN-OR D., GOLDENTHAL R.,
LISCHINSKI D.: Bounded-distortion piecewise mesh parameter-
ization. In Proc. IEEE Visualization 2002 (2002), pp. 355–362.
[SH02] SHEFFER A., HART J. C.: Seamster: Inconspicuous low-
distortion texture seam layout. In Proc. IEEE Visualization 2002
(2002), pp. 291–298.
[She75] SHEPHARD G. C.: Convex polytopes with convex nets.
InMathematical Proc. Cambridge Philosophical Society (1975),
vol. 78, pp. 389–403.
[SP05] STRAUB R., PRAUTZSCH H.: Creating optimized cut-
out sheets for paper models from meshes. In Proc. SIAM Conf.
Geometric Design and Computing 2005 (2005).
[SPR06] SHEFFER A., PRAUN E., ROSE K.: Mesh parameteri-
zation method and their applications. Foundations and Trends in
Computer Graphics and Vision 2, 2 (2006).
[STL06] SHATZ I., TAL A., LEIFMAN G.: Paper craft models
from meshes. The Visual Computer 22, 9 (2006), 825–834.
[TR98] TAUBIN G., ROSSIGNAC J.: Geometric compression
through topological surgery. ACM Trans. Graphics 17, 2 (1998),
84–115.
[YGZS05] YAMAUCHI H., GUMHOLD S., ZAYER R., SEIDEL
H.-P.: Mesh segmentation driven by gaussian curvature. The
Visual Computer 21, 8–10 (2005), 659–668.
c© 2011 The Author(s)
c© 2011 The Eurographics Association and Blackwell Publishing Ltd.
Figure 2: The annotation system
on a word processor.
Figure 3: One-side boundary la-
beling with type-opo leaders.
Figure 4: 1.5-side boundary la-
beling with type-opo leaders.
Figure 5: Two-side boundary label-
ing with type-opo leaders.
The text annotation system has the following merits: for indi-
vidual use, the system can be viewed as memorandums, which,
for example, users can apply to recording current and previous
progress; for group use, the system can reduce the communica-
tion costs among the group members. Hence, the system is very
helpful in practice. However, the current visualization interface for
the text annotation system is not admirable and has the following
drawbacks:
• When the number of text comment labels is getting larger, or
there exist many large-size labels, the labels associated with
the same text line may be placed too far from the text line
(e.g., see labels #3, #4 and #5 which are associated with the
second text line from the bottom in Figure 2). In this case,
the diagonal segments of the leaders connected to those labels
would be too close to be recognized easily.
• When the number of marked words grows larger, the number
of text comment labels also grows larger. In this case, the
annotation of placing all the labels on the same side is not
admirable in visualization.
As a result, it is of importance and interest to develop better visual-
ization interface for the text annotation system.
In this paper, we develop two approaches to the visualization in-
terface for the text annotation system. One should notice that we
still apply one-site-to-one-label boundary labeling to the interface,
and the only difference between the previous work and our work is
that two sites with the same y-coordinates are allowed in our work.
In our setting, since too dense type-od leaders may not be recog-
nized easily (see Figure 2), we prefer to apply type-opo leaders (see
Figure 3). First, we propose the so-called 1.5-side boundary label-
ing with type-opo leaders, as shown in Figure 4, in which type-opo
leaders can be classified into two categories: direct leaders (as the
original ones) and indirect leaders (i.e., we make use of the left side
of document to route type-opo leaders so that the leaders are con-
nected to their labels indirectly, e.g., see the leader connected to
label #6 in Figure 4). Under this setting, we show that there exists a
polynomial time algorithm to place labels and leaders such that the
total leader length is minimized and there are no leader crossings.
Second, we propose the two-side boundary labeling with type-
opo leaders for the annotation system, as shown in Figure 5, in
which the labels placed on the two sides of the document are not
crowded so that we can observe them easily. Although the two-side
boundary labeling with type-opo leaders has been discussed in the
previous work [1, 3, 4], all of them assume that the number of labels
on each of the two sides of the document are given. In this paper,
we consider that the number of labels on the two sides are unknown
to investigate the problem of how to allocate the labels on the two
sides and route only direct leaders such that both the total leader
length and the difference between the sums of heights of labels on
the two sides are minimized, while there are no leader crossings.
When the total leader length is smaller, each label would be placed
more near its corresponding site, so that users can easily trace the
leader between labels and their corresponding sites. In addition, if
the difference of the sums of the heights of labels on the two side
is smaller, then we can observe the labels on the two sides in a
more balanced way, and not too many labels are placed on the same
side. Therefore, the concerned problem makes sense in practice.
We show this problem to be NP-complete, and hence propose an
approach based on the well-known genetic algorithm (GA) [8] to
solve it.
The GA is a heuristic to find the solution of the problem by glob-
ally searching the feasible solution space, in which each feasible
solution can be represented by a binary string or integers. In our
problems for two-side boundary labeling, if we determine which
side each label is placed on, then there exists only a feasible leader
routing such that there are no leader crossings. Hence, we only con-
sider how to determine which side each label is placed on. Each la-
bel is assigned a state which is zero (resp. one) if the label is placed
on the right (resp., left) side of the document. By doing this, each
feasible solution can be modeled as a binary string. Hence, GA is
suitable to solve our problems for the two-side labeling. Finally,
we develop a prototype for our approaches, and the experimental
results look promising.
2 PRELIMINARIES
In this section, we first introduce the boundary labeling model, and
then the genetic algorithm.
2.1 Boundary Labeling Model
Based on Bekos et al.’s work [2], we extend their boundary labeling
model to be expressed as an 8-tuple (Side, LabelSize, LabelPort,
LabelPos, Leader, IndirectLeader, Site, Ob jective), where:
Side: Labels can be placed on the East, West, South and North
sides of the enclosing rectangle R, which are denoted by N,
E, W and S, respectively.
LabelSize: There are two states for LabelSize: UnifSize (all labels
are of the same size), MaxSize (all labels are of uniform max-
imal size) or NonUnifSize (each label li is associated with a
height hi and a width wi).
LabelPort: FixedPorts (points where a leader can touch a label
are predefined) or SlidPorts (points can slide along the label’s
edge).
LabelPos: FixedPos (labels have either to be aligned with a prede-
fined fixed set of points on the boundary of the rectangle) or
SlidePos (labels can slide along the rectangle’s sides).
Leader: Types of leaders (opo, po, s or do).
IndirectLeader: IndirectAllowed (Indirect leaders are allowed) or
IndirectNotAllowed (Indirect leaders are not allowed).
Site: Type of the sites. Each site is a 1-point, line, rectangle, a
polygon, etc.
Note that it is of interest to find an improved solution for the
above problem. Furthermore, if we consider a relaxed version
where the label size is set as NonUnifSize, then we do not know
how to solve this problem. That is, the problem of finding a le-
gal labeling for the model (E, NonUnifSize, FixedPort/SlidPorts,
FixedPos, opo, IndirectAllowed, 1-point, TLLM) is open.
3.2 Two-Side Boundary Labeling
In what follows, we consider the problem of how to allocate labels
on the two sides and route only direct type-opo leaders for the two-
side boundary labeling so that both the total leader length and the
difference of the sums of the heights of labels on the two side are
minimized, while there are no crossings among leaders.
We can show the problem of finding a labeling for the
model (EW, UnifSize/NonUnifSize, FixedPort/SlidPorts, Fixed-
Pos, opo, IndirectNonAllowed, 1-point, TLLMDSHM) to be NP-
hard. W.l.o.g., in this paper, we only show the NP-completeness of
the following decision problem:
The TLLMDSHM PROBLEM: Given an integer M and an annota-
tion system A of a document in which there are n marked words
and n comment labels l1, · · · , ln (where each label li has height
hi for i ∈ {1, · · · ,n}), is there a two-side boundary labeling (with
NonUnifSize and SlidePorts) for A in which the set of labels placed
on the East (resp., West) side is denoted L1 (resp., L2) such that the
total leader length is the minimum and |∑li∈L1 hi−∑li∈L2 hi|< M?
The TLLMDSHM problem can be shown to be NP-complete as
follows, whose proof is omitted due to page limitation.
Theorem 2 The TLLMDSHM problem is NP-complete.
Because the TLLMDSHM problem is NP-complete, we apply
the genetic algorithm to designing a heuristic for the problem in the
next section.
4 GENETIC ALGORITHM FOR THE TWO-SIDE LABELING
The implementation of each steps in designing our genetic algo-
rithm for the two-side labeling are detailed in this section.
4.1 Individual
The individual represents a candidate solution. In our problem, it
represents a legal label placement without any leader crossings. An
individual is stored as a binary string s1s2 · · ·sn, where for each i ∈
{1, · · · ,n}, if label li is placed on the West side, si = 0; otherwise,
si = 1. Such a representation is enough to determine a legal label
placement because there is only one boundary labeling without any
leader crossings once we know which side each label is placed on
[3, 4].
4.2 Initialization
At the beginning of the genetic algorithm, the individuals in the
population have to be initialized. Initially many individual solu-
tions are randomly generated to form an initial population. The
population size depends on the nature of the problem, but typically
contains several hundreds or thousands of possible solutions. Con-
ventionally, the population is generated randomly, covering the en-
tire range of possible solutions (the search space). Occasionally,
the solutions may be “seeded” in the areas where the optimal so-
lutions are likely to be found. In our case, this is done randomly.
We generate a label placement with restricted given area (including
rectangle R, track routing area, and space for labels) and let bad
offspring eliminated by selection.
4.3 Evaluation
The choice of the evaluation function plays a crucial role in the
design of a genetic algorithm. There is a big advantage of using
evaluation in genetic algorithm. One can measure desired criteria
on the resulting placement and weight these criteria to suit personal
preferences. Because genetic algorithm is always used in multi-
purpose problem, we can then analyze how important these criteria
are. Our concerned criteria are stated as follows: all the leaders
do not cross to each other; all the labels do not overlap each other;
labels should be placed evenly on East and West sides so that the
difference of the sums of the heights of the labels on the two sides is
as minimal as possible; the total leader length should be as minimal
as possible.
4.4 Selection
Selection is important to genetic algorithm, since only selection
drives the search towards more promising regions of the search
space. In our implementation, we select individuals for reproduc-
tion according to the common linear ranking selection scheme, i.e.,
individuals are selected according to their rank, with better indi-
viduals receiving a higher chance of being selected. So that, the
selective procedure of the actual fitness values would be important,
since beforehand we do not known the range of fitness values where
the optimal solution is located. The algorithm is of the steady state
type, i.e., the offspring is introduced into the population, and the
worst-fitted individual is deleted. In this way, the best solution so
far is never deleted. In addition, if there exists at least a leader
crossing in the solution resulting from a certain individual, the indi-
vidual should not be counted in the population. Our fitness function
is defined as follow:
fi = λ1 ×
(
T LL
n× (|tR −bR|+ |rR − lR|+ ε)
)
+λ2 ×
( |Rh−Lh|
Rh+Lh
)
(1)
where TLL denotes the total leader length; Rh (resp., Lh) is the
sum of the heights of the labels on the East (resp., West) side; ε
is the width of the track routing area; tR, bR, bR, and lR are top,
bottom, right, and left positions of rectangle R, respectively. In
order to normalize the function, we divide these parameters to their
intuitive maximum value. Thus, w.l.o.g., λ1 and λ2 can be chosen
in the range between 0 and 1 under the constraint of λ1 +λ2 = 1.
4.5 Recombination
In order to obtain a better result, we combine two good parents
into a new offspring which may become better or not. The pur-
pose of the crossover operator is to recombine sub-placements of
different individuals to produce an offspring. Since, we expect that
good parts of a placement are connected, we perform crossover by
choosing randomly a connected parts of the placement of two par-
ents and swapping the sub-placements. However, there is a problem
with this operator when using this method. A combination of two
good parents may yield a poor offspring. This poor offspring will
be deleted during the natural selection process.
4.6 Mutation
Mutation is a crucial step of genetic algorithm. While using recom-
bination, we can only find new combination of individuals that are
already present. We may lose some information forever while it is
not in the population. Another method, called mutation, can intro-
duce new material into the population, i.e., the slight changing of
individuals. It is necessary and reasonable to get new materials to
increase the probability of obtaining better answers. In out imple-
mentation, mutation is done by randomly changing binary vector
with a given small probability. We try to change one leader from
the East side to West side (or from the West side to the East side).
By doing so, we have a probability to obtain a better individual
Figure 7: A labeling using our GA algorithm
with λ1 = 1.0; λ2 = 0.0.
Figure 8: A labeling using our GA algorithm
with λ1 = 0.0; λ2 = 1.0.
Figure 9: A labeling using our GA algorithm
with λ1 = 0.5; λ2 = 0.5
Figure 10: The optimal solution for the example
of Figure 7.
Figure 11: The optimal solution for the example
of Figure 8.
Figure 12: The optimal solution for the example
of Figure 9.
Figure 14: Application to MS Word.
5.5 Comparison between one-side and two side label-
ings
The relationship between these two approaches is how we would
like to improve the text annotation system. Most of the time, we
hate to read articles on computers because we get tired easily. Some
people may used to print them out. Hence, it is good to consider
how to fill one paper with most information. By doing so, we should
consider not only the column space for labels, but also how large
they are. These two approaches have their own pros and cons that
are subjective. Thus, we may provide related parameters for users.
Even though there exists a document which can be applied on one-
side and two boundary labelings, it is hard to find objective criteria
to judge how good they are.
REFERENCES
[1] M. Bekos, M. Kaufmann, K. Potika, and A. Symvonis. Boundary la-
belling of optimal total leader length. In Proc. of the 10th Panhellenic
Conference on Informatics (PCI 2005), volume 3746 of LNCS, pages
80–89, 2005.
[2] M. Bekos, M. Kaufmann, K. Potina, and A. Symvonis. Area-feature
boundary labeling. The Computer Journal, 2008. To appear.
[3] M. Bekos, M. Kaufmann, A. Symvonis, and A. Wolff. Boundary la-
beling: models and efficient algorithms for rectangular maps. In Proc.
of the 12th International Symposium on Graph Drawing (GD 2004),
volume 3383 of LNCS, pages 49–59, 2004.
[4] M. Bekos, M. Kaufmann, A. Symvonis, and A. Wolff. Boundary la-
beling: models and efficient algorithms for rectangular maps. Compu-
tational Geometry: Theory and Applications, 36(3):215–236, 2006.
[5] M. Benkert, H. Haverkort, M. Kroll, and M. No¨llenburg. Algorithms
for multi-criteria one-sided boundary labeling. In Proc. of the 15th In-
ternational Symposium on Graph Drawing (GD 2007), volume 4875
of LNCS, pages 243–254, 2008.
[6] B. Chazelle and 36 co-authors. The computational geometry impact
task force report. In B. Chazelle, J. E. Goodman, and R. Pollack,
editors, Advances in Discrete and Computational Geometry, volume
223, pages 407–463. AMS, 1999.
[7] M. Formann and F. Wagner. A packing problem with applications to
lettering of maps. In Proc. of the 7th Annual ACM Symposium on
Computational Geometry (SoCG 1991), pages 281–288. ACM Press,
1991.
[8] J. Holland. Adaptation in Natural and Artificial Systems. University
of Michigan Press, Ann Arbor, 1975.
[9] E. Imhof. Positioning names on maps. The American Cartographer,
2(2):128–144, 1975.
[10] C. Iturriaga and A. Lubiw. NP-hardness of some map labeling prob-
lems. Technical Report CS-97-18, University of Waterloo, 1997.
[11] C.-C. Lin, K.-R. Kao, and H.-C. Yen. Many-to-one boundary labeling.
Journal of Graph Algorithms and Applications, 12(3):319–356, 2008.
[12] G. Neyer. Map labeling with application to graph drawing. In D. Wag-
ner and M. Kaufman, editors, Drawing graphs: Methods and models,
volume 2025 of LNCS, pages 247–273. 2001.
[13] F. Wagner. Approximate map labeling is in ω(n logn). Information
Processing Letter, 52(3):161–165, 1994.
[14] F. Wagner and A. Wolff. Map labeling heuristics: Provably good and
practically useful. In Proc. of the 11th Annual ACM Symposium on
Computational Geometry (SoCG 1995), pages 109–118. ACM Press,
1995.
[15] A. Wolff and T. Strijk. The map-labeling bibliography.
http://i11www.ira.uka.de/map-labeling/bibliography/, 1996.
最主要的國際會議之ㄧ。過去舉辦過的城市包括 Prague (1992), Antibes 
(1994), Edinburgh (1996), Cagliari (1998), Ghent (2000), Zaragoza (2002), 
Reims (2004), Ann Arbor, Michigan (2006) and Göteborg (2008) 。論文審查嚴
謹。本人的論文為今年國內學者在該會議發表的唯一論文。此會議的主軸結
合理論與實際，其中計算機理論在探討離散事件系統的行為方面，扮演關鍵
角色。此外，由於許多的系統均可以用圖形來描述，圖形標示演算法可以在
這方面扮演重要的角色。 
 
三、 建議 
離散事件系統，是目前國際上在計算機科學以及工程方面，相當重要的研究
方向，值得國內研究人員積極從事這方面的研究，參與國際活動，與國際上
頂尖研究機構從事學術交流。 
 
四、 攜回資料名稱及內容 
 會議論文集 
五、 其他 
十分感謝國科會補助。 
Tuesday, August 31, 2010
9:00 – 10:00
10:00 – 10:30 Coffee break
10:30 – 12:30
TuM1: TuM2:
Diagnosis, Identification and Testing Probabilistic Discrete Event Systems
An Identification Technique for Timed Event Systems (Donald E. Jarvis)
12:30 – 14:30 Lunch break
14:30 – 15:50
TuA1: TuA2:
15:50 – 16:10 Coffee break
16:10 – 17:10
TuE1: TuE2:
Applications I
20:30
TuP: 
Plenary: Coordination of Traffic Networks (René Boel)
Use of a Metric in Supervisory Control of Probabilistic Discrete Event Systems (Vera Pantelic 
and Mark Lawford)
On-line Detection and Sensor Activation for Discrete Event Systems (Shaolong Shu, Zhiqiang 
Huang and Feng Lin)
On Almost-Sure Properties of Probabilistic Discrete Event Systems (Hsu-Chun Yen)
SIC-Testability of Sequential Logic Controllers  (Julien Provost, Jean-Marc Roussel and Jean-
Marc Faure)
On the Construction of Probabilistic Diagnosers (Eric Fabre and Loig Jezequel)
Computation of Projections for the Abstraction-based Diagnosability Verification (Klaus Werner 
Schmidt)
A Geometric Approach for the Homothetic Approximation of Stochastic Petri Nets (Dimitri 
Lefebvre, Edouard Leclercq, Nabil El Akchioui, Eduardo Souza de Cursi, and Leila Khalij)
Robust Failure Diagnosis of Partially Observed Discrete Event Systems (Shigemasa Takai) Gradient Estimation for Quantiles of Stationary Waiting Times (Bernd Heidergott, Warren Volk-
Makarewicz and Felisa Vázquez-Abad)
What Topology Tells us about Diagnosability in Partial Order Semantics (Stefan Haar) A Rollout Method for Finite-Stage Event-Based Decision Processes (Qing-Shan Jia)
Invited Session (Part I): Towards Application of Supervisory Control - from Modeling, 
through Synthesis, to Implementation (Organisers: Rong Su and Walter Murray Wonham)
Modelling and Analysis of Max-Plus Systems
Applied Supervisory Control for a Flexible Manufacturing System (Thomas Moor, Klaus Schmidt 
and Sebastian Perk)
# 60: Linear Time-Varying (Max,+) Representation of Conflicting Timed Event Graphs (Boussad 
Addad, Said Amari, and Jean-Jacques Lesage)
Supervisory Control of Software Execution for Failure Avoidance: Experience from the Gadara 
Project (Yin Wang, Hyoun Kyu Cho, Hongwei Liao, Ahmed Nazeem, Terence P. Kelly, 
Stéphane Lafortune, Scott Mahlke and Spyros A. Reveliotis)
# 92: Comparison of different classes of service curves in Network Calculus (Anne Bouillard, 
Laurent Jouhet and Eric Thierry)
Optimal Deadlock Avoidance for Complex Resource Allocation Systems through Classification 
Theory (Ahmed Nazeem, Spyros Reveliotis, Yin Wang and Stéphane Lafortune)
# 31: Modeling of interval P-time Petri nets using dioid algebra (Pavel Spacek and Jan 
Komenda)
Supervisor Computation and Representation: A Case Study (Sajed Miremadi, Knut Åkesson, 
Bengt Lennartson and Martin Fabian)
#43: Synchronous composition of interval weighted automata (Jan Komenda, Sebastien Lahaye 
and Jean-Louis Boimond)
Invited Session (Part II): Towards Application of Supervisory Control - from Modeling, 
through Synthesis, to Implementation (Organisers: Rong Su and Walter Murray Wonham)
Automated Controllability and Synthesis with Hierarchical Set Decision Diagrams (Yan Zhang, 
Beatrice Bérard, Fabrice Kordon, and Yann Thierry-Mieg)
Rotary Wings UAV Mission Planning Aided by Supervisory Control (José Cerdeira Gonzalez, 
Roberto Ortiz Garrido and Antonio Eduardo Carrilho da Cunha)
Coordination of Resources using Generalized State-Based Requirements (Jasen Markovski, 
Koen Jacobs, Bert van Beek, Lou Somers and J. E. Rooda)
Augmenting Petri Nets to Model Health-Care Protocols (Sarah-Jane Whittaker, Karen Rudie, 
James McLellan and Stefan Haar)
Application of Supervisory Control Theory to Theme Park Vehicles (S. T.J. Forschelen, J. M. van 
de Mortel-Fronczak, R. Su and J. E. Rooda)
Fail-Safe Signalization Design for a Railway Yard: A Level Crossing Case (Mustafa Seçkin 
Durmus, Ugur Yildirim, Aysegul Kurşun and Mehmet Turan Söylemez)
Conference Dinner at Clärchens Ballhaus
 
Hsu-Chun Yen  
寄件者: <info@wodes2010.org>
收件者: <yen@cc.ee.ntu.edu.tw>
傳送日期: 2010年6月16日 上午 01:30
主旨: WODES2010 Paper Status
b頁 1 - 2(B)
2010/8/4
Dear Hsu-Chun Yen, 
 
paper number: #70 
Title: On  Almost-Sure Properties of Probabilistic Discrete Event Systems 
Authors: Hsu-Chun Yen 
Category: Oral 
 
We are pleased to inform you that your paper  
 
On  Almost-Sure Properties of Probabilistic Discrete Event Systems 
 
has been accepted for Oral presentation at WODES2010. 
 
Please log in at  
http://ti4.ee.tu-berlin.de 
to see your reviewers' comments. 
 
Reviewers have spent considerable time and effort, so please take their 
comments into account when revising your paper. Also, remember to upload 
the final version of your paper by July 13th. 
 
Your revised paper will be included in the preprints and the on-line 
proceedings on the IFAC-PapersOnLine.net website, provided that 
 
- the formatting requirements 
(http://www.ifac-control.org/events/information-for-ifac-authors) are met 
- the copyright form has been signed and sent back 
- at least one author has registered by July 13th and paid the regular 
(420/470 Euro) registration fee 
- if your final version exceeds 6 pages, an overlength fee of 100 Euro is 
charged. Note that papers may not exceed 8 pages. 
 
The registration site will open on June 21st. Please note that the early 
registration deadline is July 1st. 
 
If you experience any problems please contact info@wodes2010.org. 
 
We look forward to seeing you at WODES2010. 
 
Sincerely yours, 
 
J. Raisch, A. Giua, S. Lafortune and T. Moor 
WODES2010 - IPC chairs 
 
some controllable events if necessary. In a Markov decision
process, on the other hand, states are partitioned into
nondeterministic and stochastic states and a scheduler can
choose the next state from those nondeterministic states
to proceed. After resolving nondeterminism by assigning
probabilities to nondeterministic transitions, quantitative
analysis found in Markov chains can then be applied
to analyzing the behaviors of Markov decision processes.
More will be said about the differences between our work
and that of Markov decision processes as our discussion
progresses.
2. PRELIMINARIES
Let N denote the set of nonnegative integers, and Nk
the set of vectors of k nonnegative integers. A transition
system M is a 4-tuple (S, T, δ, q0), where S is a (possibly
infinite) set of states, T is a finite set of events, q0 ∈ S
denotes the initial state, and δ ⊆ S × T × S defines the
transition relation. Each (s, t, s′) of δ is called a transition.
For convenience, (s, t, s′) ∈ δ is also written as s t→ s′,
meaning that event t can lead the system from state s to
state s′. We define en(s) = {t | ∃s′ ∈ S, (s, t, s′) ∈ δ}
(resp., ent(s) = {(s, t, s′) | t ∈ T, s′ ∈ S, (s, t, s′) ∈ δ}) to
be the set of events (resp., transitions) enabled at state
s. Without loss of generality, we assume that en(s) 6= ∅,
∀s ∈ S. Such a requirement can easily be enforced by
adding a ”dummy” transition (s, a, s) to state s at which
en(s) is empty, without affecting the system’s behaviors
that are of interest to us. A computation pi is a sequence
s0
t1→ s1 t2→ s2 · · · tn→ sn such that ∀0 ≤ i ≤ n −
1, si
ti+1→ si+1. We write st(pi) (resp., ev(pi)) to denote the
sequence of states (resp., events) encountered along pi. We
also write s0
t1···tn→ sn (or s0 σ→ sn) to denote the existence
of a computation from s0 to sn resulting from taking the
event sequence σ : t1 · · · tn. We write s0 ∗→ sn to denote the
existence of a σ ∈ T ∗ such that s0 σ→ sn, and s0 6 ∗→ sn for
¬(s0 ∗→ sn). For an infinite string σ = t1t2 · · · ti · · · ∈ Tω,
we write s0
σ→ if ∀i ≥ 1 s0 σi→ si, for some si, where
σi = t1t2 · · · ti is a prefix of σ.
A controlled transition systemM is a 5-tuple (S, T, δ, q0, C),
where (S, T, δ, q0) is a transition system with its set of
events divided into two disjoint subsets Tc and Tu such
that Tc ∩ Tu = ∅ and Tc ∪ Tu = T , and C ⊆ 2Tc . Events in
Tc and Tu are called controllable and uncontrollable events,
respectively. Each element of C is called a control action.
For notational convenience, we always label the elements
of C as C1, . . . , Cm (i.e., C={C1, . . . , Cm}, for some m),
and we also assume that Tc =
⋃
i=1...m Ci throughout
the rest of this paper. A control policy is a mapping h :
{q0}S∗ → C from the set of possible computation histories
to C. With respect to a control policy h, a computation
pi = s0
t1→ s1 t2→ s2 · · · tn→ sn is legitimate under h (also
called h-computation) if it starts from the initial state
(i.e., s0 = q0) and for every 1 ≤ i ≤ n, either ti ∈ Tu,
or ti ∈ h(s0 · · · si−1) (i.e., controllable transition ti must
be enabled under h). We also write entpi(sn) to denote the
set {(sn, t, s′) | t ∈ Tu ∪ h(st(pi)), s′ ∈ S, (sn, t, s′) ∈ δ},
the set of transitions enabled with respect to history st(pi)
under h in state sn.
In this paper, we further require that control policies
be non-blocking or fair. Suppose M=(S, T, δ, q0, C), where
T = Tc∪Tu and C={C1, . . . , Cm}, is a controlled transition
system.
(1) Non-blocking policy: A policy h is non-blocking if
for every state s, if en(s) ⊆ Tc, then the control
policy must enable some control action C with en(s)∩
C 6= ∅ at state s. In words, if in a state from which
only controllable transitions are enabled, a control
policy is not allowed to ‘shut down’ the computation
by disabling all potentially executable controllable
transitions.
(2) Fair policy: A policy h is said to be fair if it is non-
blocking, and for every infinite computation s0
t1→
s1
t2→ · · · si−1 ti→ si ti+1→ · · · and for every 1 ≤ j ≤ m,
if there exist infinitely many i1, i2, ... such that Cj ∩
en(sil) 6= ∅ (∀l ≥ 1), then there exist infinitely many
k1, k2 · · · such that Cj is chosen by the control policy
at states skl , ∀l ≥ 1. In words, if without the presence
of the controller, a controllable transition is enabled
infinitely many times along an infinite computation,
then any control action involving the transition must
not be denied by the control policy forever.
A probabilistic controlled transition system is a 6-tuple
M=(S, T, δ, q0, C, w), where (S, T, δ, q0, C) is a controlled
transition system and w : S × T × S → N denotes the
weight function that associates each transition (s, t, s′) ∈ δ
with a nonnegative integer. With respect to a control
policy h : {q0}S∗ → C, the probability associated with
enabled transition α = (s, t, s′) in a reachable state s
with respect to an h-computation pi reaching s (i.e., α ∈
entpi(s)) is
ppi(α) =
w(α)∑
β∈entpi(s) w(β)
.
It should be noted that for any reachable state s and h-
computation pi, ∑
α∈entpi(s)
ppi(α) = 1.
For the sake of brevity, we simply use a system to refer to
a (probabilistic) controlled transition system if it is clear
from the context in our subsequent discussion.
Consider a system M=(S, T , δ, q0, C, w). Under a control
policy h, the probabilistic space (Ωs,∆s, P robs) associated
with a state s is defined as follows: Ωs is the set of all
infinite h-computations s τ→, where τ ∈ Tω, ∆s is the σ-
algebra generated by the basic cylindric set Dτ = {s ττ
′
→|
τ ′ ∈ Tω} (i.e., the set of infinite h-computations whose
prefix is τ), where τ ∈ T ∗, and the probability measure
Probs is defined by Probs(Dτ ) =
∏
i=1..n pτ (si, ti, si+1),
where τ = t1t2 · · · tn, s = s1 and ∀1 ≤ i ≤ n, si ti→ si+1,
for some states s2, ..., sn+1. In our subsequent discussion,
the subscript s is omitted if it is clear from the context.
It is not hard to see that a control policy h induces
a (possibly infinite) Markov chain Mh = ({q0}S∗, P ),
where P : {q0}S∗ × {q0}S∗ → [0, 1] is such that
P (pis, piss′)=
∑
(s,t,s′)∈entpis(s) ppis((s, t, s
′)), where pis ∈
{q0}S∗ and s′ ∈ S . Note that since the control action
at state s ∈ S \Q either an uncontrollable transition, or a
Cj in Hs, a non-blocking control policy is achieved which
avoids X with probability one.
(⇐) It suffices to show the forbidden property, which can
be proved by induction. 2
For finite state systems, Procedure FSP1 terminates in a
polynomial number of iterations in terms of the size of the
system. Hence, we have:
Theorem 2. NAFSP is solvable in polynomial time for
finite state systems.
We now turn our attention to NARP, the problem of given
a system M=(S, T , δ, q0, C, w) and X ⊆ S, deciding
whether there exists a non-blocking control policy h un-
der which the probability measure of all h-computations
reaching X is one.
The first attempt might be to consider the set X˜ = {s |
s 6 ∗→ X}, which is the set of states from which X is not
reachable. Clearly, if under a policy a state in X˜ is reached,
then the probability of reaching X is less than one. The
following procedure is a slight modification of Procedure
FSP1:
Procedure RP1:
Let Q0 =X˜ and
M0={(s,H) | s ∈ S,H = {Cj | ∃t ∈ en(s), t ∈ Cj , }}
For i ≥ 0,
Mi+1 = {(s,H) | s ∈ S \Qi,
H = H ′ \ {Cj | ∃t ∈ Cj ,∃s′ ∈ Qi, s t→ s′}
where (s,H ′) ∈Mi }
Qi+1 = Qi ∪ {s | s t→ s′, t ∈ Tu, s′ ∈ Qi} ∪
{s | s 6 ∗→Mi+1 X} where s 6 ∗→Mi+1 X
means X is not reachable from s via uncontrollable
events or control actions specified in Mi+1
Fig. 1. A path p along which X is continuously reachable.
Let Q =
⋃∞
i=0Qi. It is easy to observe that if any of
Qi is reached under a non-blocking policy h, then the
probability of reaching X is strictly less than one. Also
notice that for each state s in S \ Q, there exists a non-
blocking policy h such that f∗s,X(h) > 0, and f
∗
s,Q(h) = 0.
Such an h can be constructed using the strategy explained
in the proof of Theorem 1.
For Procedure RP1, one might expect to obtain ”q0 ∈ S\Q
⇔ ∃ non-blocking policy h, f∗q0,X(h) = 1” – an analogy
of Theorem 1. However, this may not be the case in
general, as Figure 1 explains. In this example, p represents
a computation along which X is always reachable but is
never reached. q0 ∈ S \Q (with respect to Procedure RP1)
only ensures that there is a non-blocking control policy
under which Q is avoided with probability one. However,
this is not the same as reaching X with probability one,
if the probability measure of computations such as p in
Figure 1 is nonzero.
For a result similar to Theorem 1 to work for NARP, we
require a stronger condition as the following indicates:
Theorem 3. Consider a system M=(S, T , δ, q0, C, w) and
X ⊆ S. If M has the following property:
∀ policy h,∃β ∈ R+,∀s ∈ S, f∗s,X(h) > 0 =⇒ f∗s,X(h) ≥ β,
then q0 ∈ S \
⋃∞
i=0Qi if and only if there exists a non-
blocking control policy h such that f∗q0,X(h) = 1.
Proof. (Sketch)
(⇐) Similar to the corresponding proof in Theorem 1.
(⇒) Again we apply a policy h like in the proof of Theorem
1. For each state s ∈ (S\⋃∞i=0Qi), clearly f∗s,X(h) > 0, and
hence, f∗s,X(h) ≥ β. Hence, the probability of not reaching
X from q0 under h is ≤ (1− β)∞ = 0.
2
The property stated in the above theorem is called global
coarseness (Abdulla et al. (2005)). The above proof is
along a similar line of that in Abdulla et al. (2005)
which shows global coarseness implies decisiveness, i.e., the
probability measure of all the computations along which
X is always reachable but is never reached is zero.
The following result is easy to show:
Theorem 4. If a system M=(S, T , δ, q0, C, w) is of finite
state, then ∀X ⊆ S, ∀ policy h,∃β ∈ R+, ∀s ∈ S,
f∗s,X(h) > 0 =⇒ f∗s,X(h) ≥ β.
Proof. If f∗s,X(h) > 0, we let σs be the shortest path
reaching X from s under h. Clearly, f∗s,X(h) ≥ Prob(s σs→
) > 0. We define β = min{Prob(s σs→) | s ∈ S, f∗s,X(h) >
0}. The result follows. 2
Following Theorems 3, 4 and Procedure RP1, we have:
Corollary 5. For finite state systems, NARP is solvable in
polynomial time.
Now we consider FAFSP and FARP. One should first note
that Procedures FSP1 and RP1 do not work if control
policies are required to be fair. This is mainly because
of the fact that removing a control action from H in an
extended state (s,H) in the construction of M1,M2, ...
may render the control policy unfair. To reason about fair
control policies, we require the notion of C-ergodicity.
A C-ergodic subsystem is such that once a state in
the subsystem is reached, there is a fair policy under
which the probability of staying in the subsystem is
one. With respect to a system M=(S, T , δ, q0, C, w)
a policy tree leading to those maximum fair-SCCs exists
is easy. This leads to the following:
Theorem 6. FAFSP for finite state systems is solvable in
polynomial time.
To solve FARP, we require the following result:
Lemma 7. If a C-ergodic subsystem M ′ contains a state
belonging to X, then from any s in M ′, the probability of
reaching X under any fair policy is one.
Based on Lemma 7, solving FARP boils down to checking
whether there exists a policy tree leading to some fair-
SCCs, each of which contains at least a state in X. Hence,
we have:
Theorem 8. FARP for finite state systems is solvable in
polynomial time.
4. INFINITE STATE SYSTEMS
This section is devoted to ARP and AFSP for systems of
infinite-state represented as Petri nets.
A labelled Petri net (or PN, for short) is a 5-tuple
(P, T,Σ, ϕ, l), where P is a finite set of places, T is a finite
set of transitions, Σ is a finite set of labels, ϕ is a flow
function ϕ : (P × T ) ∪ (T × P ) → N , and l : T → Σ is a
labeling function which assigns to each transition t a label
l(t) ∈ Σ. Traditionally, a state of a PN is called a marking,
which is a mapping µ : P → N (µ assigns tokens to each
place of the net). A marking can also be viewed as a k-
dimensional vector in Nk, where k = |P | (i.e., the number
of places in P ). A transition t ∈ T is enabled at a marking
µ iff ∀p ∈ P , ϕ(p, t) ≤ µ(p). We write µ t→ µ′ to denote
the firing of an enabled transition t at marking µ resulting
in a new marking µ′, where µ′(p) = µ(p)−ϕ(p, t) +ϕ(t, p)
∀p ∈ P . We define Tr(σ) to denote the set of transitions
used in σ ∈ T ∗. A marked PN is a pair ((P, T,Σ, ϕ, l), µ0),
where (P, T,Σ, ϕ, l) is a PN, and µ0 is called the initial
marking. A marked PN ((P, T,Σ, ϕ, l), µ0) can be regarded
as an infinite-state transition system (Nk,Σ, δ, µ0), where
δ(µ, a) = µ′ if there exists a t ∈ T with l(t) = a such that
µ
t→ µ′.
Probabilistic controlled PNs ((P, T,Σ, ϕ, l), µ0, C, w) can
be defined similarly, where Σ = Σu ∪ Σc (divided into
uncontrollable and controllable events), C defines the set
of control actions, and w represents the weight function.
A set U ⊆ Nk is said to be upward-closed if ∀x ∈ U, y ≥ x
implies y ∈ U . A set V ⊆ Nk is forward-closed with respect
to a PN (P, T,Σ, ϕ, l) if ∀µ ∈ V,∀t ∈ T, µ t→ µ′ implies
µ′ ∈ V .
Although checking containment and equivalence for PNs
is undecidable, the expressive power of PNs, however, is
strictly weaker than that of Turing machines. Decidable
problems concerning PNs include: reachability, coverabil-
ity, boundedness, among others.
Suppose P = ((P, T,Σ, ϕ, l), µ0, C, w) is a probabilistic
controlled PN. Let {t1, ..., tk} be the set of transtions
enabled in a marking µ under a control policy h. Viewing
P as a transition system, the probability associated with
ti under h is pµ(ti) =
w(ti)∑
1≤j≤k w(tj)
.
Unlike finite state systems for which the global coarseness
property always holds (Theorem 4), the following example
shows that probabilistic PNs in general need not necessar-
ily be globally coarse; and hence, may not be decisive.
Example. Consider a PN P with a place {p} and two
transitions {t1, t2} such that ϕ(p, t1) = 1;ϕ(t2, p) =
2;ϕ(p, t2) = 1. Note that the net effect of firing t1 (resp.,
t2) is to decrement (resp., increment) place p by a token.
Suppose w(t1) = 1 and w(t2) = 2. Then in a marking
n > 0, the probabilities of firing t1 and t2 are 13 and
2
3 ,
respectively. If we let X = {0}, then it is reasonably easy
to see that from the initial marking 1, the probability of
reaching X is
1
3
2
3
= 12 , although X˜ = ∅ (i.e., X is reachable
from every marking). Hence, the PN is not decisive. It
should be noted that the PN is not globally coarse, as
the probability of reaching X from marking n becomes
arbitrarily close to zero as n approaches infinity. 2
For a probabilistic PN with an upward-closed X, it was
shown in Abdulla et al. (2005) that the PN is always
globally coarse, and hence, decisive.
It was shown in Yen (2008) that FSP for controlled
labelled Petri nets (without probability) is undecidable
under both non-blocking and fair control policies. A simi-
lar argument works for probabilistic versions of controlled
labelled Petri nets, resulting in AFSP as well as ARP to
be undecidable. That is:
Theorem 9. ARP and AFSP are undecidable under both
non-blocking and fair control policies for infinite state
systems modelled as probabilistic controlled labelled Petri
nets.
In what follows, we consider ARP and AFSP for persistent
PNs, a subclass of PNs which are general enough to model
many systems of real-world interest.
An unlabelled PN (P, T, ϕ) with initial marking µ0 is
called persistent (Landweber and Robertson (1978)) iff
for every reachable marking µ (i.e., µ0
∗→ µ), if µ t→
and µ t
′
→ (t, t′ ∈ T ), then µ t t
′
→ . It should be noted that
marked graphs, a class of PNs popular in the study of
discrete event systems, correspond to a proper subclass of
persistent PNs.
Given a PN P =(P , T , ϕ), the idea behind the so-
called valuation method (Yen (2002)) is to devise a
valuation function f : Nk → N ∪ {∞}, which maps each
marking µ to a value in N ∪ {∞}. Such a value f(µ) is
called the valuation of the marking. Furthermore, if the
set of markings of zero valuation is forward-closed, then
the valuation along any Petri net computation is non-
increasing, and in many cases, has the tendency to move
towards the ground level (i.e., valuation zero). A valuation
function f is said to be monotone if for every marking µ,
if µ t→ µ′ (for some marking µ′ and transition t), then
f(µ) ≥ f(µ′). It is obvious that if f is monotone and
µ
σ→ µ′ (where σ ∈ T ∗), then f(µ) ≥ f(µ′).
Given a persistent PN P=(P, T, ϕ) and a set of markings
X, the following valuation function f will be used in our
subsequent discussion: f(µ) is defined to be the length of
the shortest path from µ to a marking in X; if µ cannot
techniques developed in this work can be extended to
assure almost-sure properties specified as formulas in some
temporal logic. In the model of probabilistic Petri nets,
we assume the notion of static probability in transition
firing, in the sense that at a marking, the probability of an
enabled transition only depends on the set of enabled tran-
sitions present at the marking, but is independent of the
number of times that the transition can fire in the marking.
In reality, however, it might be more realistic in some cases
to consider dynamic probability in that the probability of
firing a transition is marking-dependent (i.e., the more a
transition can fire, the higher the probability it has). As
the technique we developed for infinite-state systems is
limited to persistent Petri nets, it is important to devise
new techniques to be able to cope with other types of
infinite-state systems.
REFERENCES
P. Abdulla, N. Henda, and R. Mayr (2005). Verifying
infinite Markov chains with a finite attractor or the
global coarseness property, in Proc. 20th Annual IEEE
Symposium on Logic in Computer Science, 127-136.
C. Baier, M. Gro¨er, M. Leucker, B. Bollig, and F. Ciesinski
(2004). Controller synthesis for probabilistic systems,
in Proc. IFIP International Conference on Theoretical
Computer Science, J.-J. Le´vy, E. W. Mayr, and J. C.
Mitchell, Eds. Kluwer, 493-506.
T. Bra´zdil, V. Forejt, and A. Kucˇera (2008). Controller
synthesis and verification for Markov decision processes
with qualitative branching time objectives, in Proc. 35th
international colloquium on Automata, Languages and
Programming, 148-159.
V. Garg (1992). Probabilistic languages for modeling
of DEDS. in Proc. 26th Conference on Information
Sciences and Systems, volume 1, 198203.
A. Kucˇera and O. Strazˇovsky´ (2008). On the controller
synthesis for finite-state Markov decision processes,
Fundamenta Informaticae, Vol. 82, no. 1-2, 141-153.
L. Landweber, E. Robertson (1978). Properties of conflict-
free and persistent Petri nets, JACM 25(3): 352-364.
M. Lawford and W. Wonham (1993) Supervisory control of
probabilistic discrete event systems, in Proc. 36th IEEE
Midwest Symposium on Circuits and Systems, Vol. 1.
IEEE, 327-331.
D. Lehmann and M. Rabin (1981). On the advantages of
free choice: a symmetric and fully distributed solution
to the dining philosophers problem, in Proc. 10th Ann.
ACM Symp. on Principle of Programming Languages,
133-138.
V. Pantelic, S. Postma, and M. Lawford (2009). Proba-
bilistic supervisory control of probabilistic discrete event
systems, IEEE Transactions on Automatic Control, Vol.
54, No. 8, 2013-2018.
H. Yen (2002). A valuation-based analysis of conflict-free
Petri nets, Systems and Control Letters, Vol. 45, No. 5,
387 - 395.
H. Yen (2008). Decidability and complexity analysis of
forbidden state problems for discrete event systems,
International Journal of Foundations of Computer Sci-
ence, Vol. 19, No. 4, 999-1013.
97 年度專題研究計畫研究成果彙整表 
計畫主持人：顏嗣鈞 計畫編號：97-2221-E-002-094-MY3 
計畫名稱：圖形標示演算法之設計分析與應用 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 8 0 100% 完整三年期間 
博士生 1 0 100% 完整三年期間 
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 1 0 100% 國際合作成果 
研究報告/技術報告 0 0 100%  
研討會論文 3 0 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
■達成目標 
□未達成目標（請說明，以 100 字為限） 
□實驗失敗 
□因故實驗中斷 
□其他原因 
說明： 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：■已發表 □未發表之文稿 □撰寫中 □無 
專利：□已獲得 □申請中 ■無 
技轉：□已技轉 □洽談中 ■無 
其他：（以 100 字為限） 
3. 請依學術成就、技術創新、社會影響等方面，評估研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）（以
500 字為限） 
本計劃中 我們針對自動地圖標示研究中之「邊界標示問題」、「圓形地圖標示問題」、「動
態邊際標示問題」等等核心問題進行演算法的設計與分析。除了在理論上探討以上相關問
題的計算複雜度以及演算法的設計之外 ，並將利用我們所推導的方法 ，應用到實際地圖
視覺化的展現上。 
 
在此三年期研究計畫中， 主持人以圖形理論以及演算法為基礎，探討圖形標示演算法相
關問題，獲得許多具體成果。包括發表以下論文: 
 
1. H. Wu, S. Takahashi, C. Lin, and H. Yen, A Zone-Based Approach for Placing 
Annotation Labels on Metro Maps, in Proc. of 11th International Symposium on Smart 
Graphics (SG 2011),  (LNCS 6815), pp. 91-102, Bremen, Germany, July 18-20, 2011.
 
2. C. Lin, S. Poon, S. Takahashi, H. Wu, and H. Yen, One-and-a-half-side Boundary 
Labeling,  in Proc. of 5th International Conference on Combinatorial Optimization 
and Applications (COCOA 2011),  (LNCS 6831), pp. 387-398, Zhangjiajie, Hunan, 
China, Aug. 4-6, 2011. 
 
3. S. Takahashi, H. Wu, S. Saw, C. Lin, and H. Yen, Optimized Topological Surgery 
