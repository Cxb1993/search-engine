        —  2 — 
設計與實作智慧型服務無線感測網路－子計畫 (二 )  
網路初始化、繞徑協定與資料收集協定之設計與實作 ( 3 / 3 )  
Subproject 2 - IWSN: Design and Implementation of Network Initialization, Routing and Information 
Collection Mechanisms (3/3) 
計畫 編號：NSC 96-2221-E-032-005 
執行 期限：96/08/01 ~ 97/07/31 
主 持 人：張志勇  淡江大學資訊工程系教授 
E-mail: cychang@mail.tku.edu.tw 
   
一、中文摘要 
本計畫為三年期整合型計畫中的一子計畫。其主
要目的在設計並實作網路層中網路初始化、繞徑與資
訊收集、障礙物克服等通訊協定，以及應用層中的資
訊收集與毀損修復系統的實作，並與其他子計畫整合
以建構智慧型無線感測網路。在第一年的計畫中，我
們研發了網路初始化的通訊協定，並探討無線感應網
路之佈建及拓樸建構等重要議題，使無線感測網路能
有效的運作。在第二年的計畫中，我們研發資料儲存
管理方法(Data Centric)以及網路層中的繞徑(Routing)協
定，並探討錯誤的位置資訊對通訊協定的影響。在第
三年的計畫中，我們針對環境中存在障礙物的情況，
研發並實作克服障礙物的群播服務 (Obstacle-Free 
Multicasting)，並在無位置資訊及具有粗略位置資訊的
場景下，發展障礙物偵測的協定及克服障礙物的繞徑
(Obstacle-Free Routing)通訊協定，以達到提高網路感
測效能及延長感測網路的存活時間等目的。除了理論
的研究外，我們亦分別在TinyViz 模擬器及Mica 系列
的感應器實作我們所研發的許多協定。 
關鍵詞： 無線感測網路、網路佈建、繞徑協定、
廣播、地理位置廣播、資料收集協定、障礙物 
英文摘要 
This  repor t  proposes  a  subproject  of  a  
three-year  in tegrated project .  The main  goal  of  
th is  subproject  is  to  des ign and implement  
protocols  including network deployment ,  
rout ing,  informat ion col lect ion as  wel l  as  
obstacle  res is tance mechanisms.  Cooperat ing 
with  other  subprojects ,  the  des ign and 
implementat ion of  th is  project  provides  an 
in tel l igent  sensor  network.   
The fol lowing br ief ly descr ibes  the  
achievements  of  th is  sub-project .  In  the  f i rs t  
year ,  we developed a  network deployment  
mechanism and two topology control  
mechanisms to  cope with  the network 
ini t ia l izat ion problem.  In  the  second year ,  we 
developed a  data  centr ic  mechanism and 
several  rout ing protocols .  In  addi t ion,  we a lso  
invest igated the  impact  of  inaccuracy locat ion 
information on rout ing performance.  In  the  las t  
year ,  we cope with  the  obstacle  problem and 
aims to  remove the  impact  of  obstacles .  To 
achieve th is ,  we developed an obstacle-f ree  
mult icas t ing protocol  for  maintain ing the  
mult icas t  t ree .  In  addi t ion,  we developed 
obstacle  detect ion and obstacle-f ree  rout ing 
protocols  based on the  inaccuracy locat ion 
informat ion.  Besides ,  we also  implement  some 
of  the  developed protocols  on 
TinyViz-s imulator  and Mica ser ies  sensor  
nodes .   
Keywords: Wireless Sensor Networks, Network 
Deployment, Routing, Broadcasting, Information 
Collection, Obstacles. 
 
二、 前言、動機與研究目的 
無線感測網路(Wireless Sensor Network, WSN)是由
許多具有短距離無線通訊、低耗電量、低成本特性的
sensor node 所構成的網路。在一個戶外的環境中，可
佈建大量的 sensor node 以負責感測某區域中的環境品
質。在 Sensor Network 中扮演與使用者溝通的介面為
sink node，其專門負責傳達使用者所想追蹤的某區域
環境資訊的命令給該區的每個 sensor node，各 sensor 
node 收到此命令後，便開始依要求定期或不定期回傳
所感測的資料至 sink node，再由 sink node 經計算、整
理及分析後，將該區 sensor node 所傳回的資訊轉送給
使用者。 
(200,200)
(100,100)
GeoRegion Sink Node
Sensor Node
Flooding Direction
Data Collection Direction
(座標,屬性,條件,時間,頻率,精確度)
Attribute
圖(一)、 WSNs 的運作方式。 
如圖(一)所示，無線感測網路主要由 sensor nodes
和 sink nodes 所組成，在第一年的研究中，我們提出佈
        —  4 — 
為其它 sensor node 轉送資料，使得電量提早耗盡而死
亡，並進而造成網路中斷。 
在另一方面，有許多研究已將平衡 sensor nodes 的
電量消耗納入考量，[9]為了將 data source 收集的資料
經由穩定的路徑傳送給 sink node，作者在已知的 data 
sources 與 sink node 間加入特定個數的 relay nodes，這
些 relay nodes 將被擺放適當的位置，以期使 data 
sources 的電量消耗最少，藉此增加資料成功回傳的機
會與降低感測網路整體的耗電量。然而其 relay node
的擺放僅考慮平衡 data source 的電量消耗，並將 relay 
node 的電量平衡納入考慮，使得 relay Node 的耗電量
較高而提早死亡，甚至造成網路分割無法順利運作。 
研究[10]在一維的網路拓樸下考量 sensor nodes 的
代傳次數，並嘗試平衡各 sensor nodes 的耗電量，其所
研發的 node placement 技術依 sensor nodes 的代傳次數
來控制 sensor nodes 佈置的距離，代傳次數越多的
sensor nodes 將與下一步代傳者相距越小，在傳送資料
時，再利用 power control 的技術來減少傳送一次資料
所耗費的電量，以達到平衡電量消耗的目的。然而，
此論文僅針對一維的網路拓樸作深入探討，針對二維
的平面拓樸並無詳細討論平衡電量消耗之解決辦法。
此外，其所提出的方法僅適用於網路佈建，針對一給
定的隨機佈建網路而言，無法採用此方法來達到資料
傳送時的電量平衡目的。 
3.2 機器人佈建及修復監測區域之相關議題文獻探討 
利用機器人來佈置 sensors nodes，除了可以採用規
則的方式來佈置 sensors 外，更能達到使用最少的
sensors 數量且完全覆蓋欲監測區域之目的，並可藉由
機器人到達不適合人為佈點的地方，諸如有毒氣、化
學污染等區域佈點[11][14][15]。在 sensor nodes 佈建的
研究中， [11][12][13][14][15][16]利用機器人來進行
WSN 中許多重要的工作，包括佈建 sensors、巡邏或修
復毀損之 sensor 等任務。在[11][12][13]的研究中，機
器人隨南西北東四個方向的優先權逐步移動並佈置
sensors，在不需要位置資訊的條件下，使用已佈下的
sensors 來引導機器人在欲監測環境中行走與佈點，當
機器人其通訊範圍內不存在任何一個 sensors 時，機器
人即佈置新的 sensor node。而在機器人之通訊範圍內
的 sensors，能夠區域性地建議機器人最適當的探勘方
向，機器人將這些 sensors 的建議結合起來並選擇出一
個最適當的方向進行探勘，亦可不受障礙物的阻擋而
在 WSN 中完成佈點的工作，然而，當機器人遇到障礙
物時，將無法保證整個欲監測區域為 full coverage，可
能造成 hole 或 sensing range 之重疊。此外，此論文僅
將 robot 所擔負的任務局限於佈點及監控，沒有考慮到
robot 所配帶的 sensor nodes 會耗盡的問題。 
利用機器人在WSNs中佈滿了 sensor nodes後， 由
於 WSNs 在 sensors 的長期監測下，有些 sensors 可能因
傳送或代傳 sensing information 的機會較多，導致其有
限電量容易耗盡，許多 sensors 亦可能因發生故障而無
法正常運作，這些毀損的 sensors 甚至可能造成整個
WSNs 斷裂，縮短了 WSNs 的 lifetime，因此，為了維
持有效的環境偵測，針對無法運作的 sensors 進行再次
佈 建 是 必 要 的 。 在 這 方 面 的 研 究 中 ，
[11][12][13][14][15] 利用機器人進行網路的佈建，但
對於網路中的空洞不能有效地改善，需要等到機器人
走至此空洞，並發現沒有 sensor nodes 可以通訊後，才
放置 sensor node 填補此空洞，無法在空洞形成時即立
刻前往修補，因此，對於網路中有空洞的情形，欲完
成 full coverage 的要求是相當地耗費時間。研究[14]以
機器人來佈置 sensor nodes且監控 the networks，已佈置
的 sensor nodes 將用來導航機器人，機器人在此感測區
域內進行監控網路與修復故障或損毀 sensor nodes 的工
作，此外，其更探討機器人回復的問題，提供機器人
回 Home 的機制，讓機器人能夠回 Home 補充電量，然
而，其對多個毀損區的行走路線並未有效規畫，機器
人無法針對多個毀損區建構一最短行走路徑以達到節
省電量的目的，另一方面，由於毀損區旁的 sensor 無
法有效追蹤機器人的行走軌跡，加之機器人行走路徑
非最短路徑，因此造成毀損區無法即時修復與機器人
耗電過多等問題。 
本計畫第一年針對佈點方式、資料回傳的樹狀結
構建立、傳送資料排程等發展電量平衡的技術，並以
模擬程式來評量其對電量平衡的改善程度。此外，我
們亦針對 Mica 2 之 sensor node 實作感應模組、通訊模
組及在個人電腦上接收 sensor 以無線方式傳回的感應
資料並加以分析。在下一章節中，我們將描述這一年
來計畫執行的成果。 
3.3 傳輸繞徑及位置偵錯之相關議題文獻探討 
在以往的研究中，以感知位置資訊的mobile anchor
來協助 static sensor 定位，將可減少硬體所需的成本，
在[17][18]研究中，具有位置資訊的 mobile anchor，在
移動中定期廣播其位置資訊給週遭的 static sensors，當
static sensor 收到 mobile anchor 所傳送的訊息之後，
static sensor 便會計算自己所在的模糊位置區域，之後
再將其模糊位置區域廣播給週遭的 static sensors，以進
ㄧ步修正鄰近 sensors 的位置資訊。根據 mobile anchor
的幫助之後，每個 static sensor 亦可得到一矩形的模糊
位置區域，為了方便後面的解釋，本報告將此矩形區
域稱為估計位置區域 (Estimated Location Region 或簡
稱為 ELR)。 
當 sensor欲將其所感測的事件、地點以及時間傳回
至 Sink 或是 Data Centric 時，其可採用現存的 Location 
Aware Routing Protocol 將封包轉送至 Sink Node，如
GPSR[19]或是GFG[20]。在作法上，GPSR主要分成兩
種模式，一為 Greedy Forwarding 模式，在此模式下，
代傳封包的 sensor 會從自己所維持的鄰居列表當中挑
選一個距離目的地最近的 sensor 當作資料傳遞的下一
個 Forwarder；一旦 Greedy Forwarding 的模式失敗時，
也就是當傳遞的過程中有某個 forwarder 其無法找到更
近的鄰居時，這個 forwarder 會切換至另一種模式，稱
為 Perimeter Mode，這種模式主要是利用左手法則或者
是右手法則對以建立的 Face 進行繞徑，直到封包傳送
        —  6 — 
但並未探討障礙區域對Share Tree結構所產生的問題。
由於Share Tree可能因為障礙區域的產生而使其結構遭
受破壞並進而使其傳輸效能降低或更甚無法進行資料
收集工作，因此，如何針對 Share Tree 設計一 Tree 
Topology 維護的協定，以克服障礙物的影響將是一重
要的研究議題。 
不同於 GMP，GMR錯誤! 找不到參照來源。考量
到障礙區域的影響，並利用 GFG Face Routing錯誤! 找
不到參照來源。來克服障礙區域。在GMR的環境假設
中，Sink 擁有所有 Node 的位置資訊，其在開始建 Tree
前，將所有 Destinations 分割成多個 Subsets，在多組的
Subsets 中，先挑選出兩組 Subsets，並找出此兩組
Destinations 的共同代傳點後，再將此兩組 Subsets 
Merge 成一組 Subset，其中 GMR 定義了 Cost Over 
Progress Ratio 當作挑選哪兩組 Subsets 進行 Merge 的依
據。Merge 的動作會不斷的重複，直到整個 Partition 
Set 中的 Subset 都 Merge 成為同一組 Set 才完成 Tree 的
建構。在建立好Tree Topology後，GMR將封包傳遞模
式分為兩種 Mode，一種為 Greedy Mode，另一種為
GFG Mode。Greedy Mode 為一預設模式，在此模式下
轉送者將封包傳送到下一個最接近 Destination 代傳
點，直到封包傳送至 Destination Node 為止，在傳送的
過程中，若封包遇到障礙物，便無法以 Greedy Mode
找到下一個更靠近 Destination 的代傳點，此時，代傳
者會由 Greedy Mode 切換到 GFG錯誤! 找不到參照來
源。Perimeter Mode 進行 Face Routing，使封包避開障
礙區域，直到離開障礙區域時，代傳點才會恢復到
Greedy Mode 繼續運作。 
雖然 GMR 利用 Face Routing 來克服障礙區域的問
題，但其並未考慮到在有障礙區域的狀況下，是否仍
存在具有共享能力且可以減少封包傳遞成本的代傳
點，因此其所建立的資料收集路徑遇障礙物時並未開
發資料共享之能力。 
障礙區域的產生會影響通訊能力，所以克服障礙
區域是個相當重要的議題。在一些克服障礙物對
Routing 影響的相關研究中，對於障礙物的處理可分為
主動式與被動式兩類。在被動式的作法中錯誤! 找不
到參照來源。錯誤! 找不到參照來源。錯誤! 找不到
參照來源。錯誤! 找不到參照來源。錯誤! 找不到參
照來源。，當封包的傳遞遭遇到障礙區域的影響時，
才會利用事先定義好的處理規則來克服障礙區域；由
於缺乏障礙區域的資訊，因此被動式作法通常僅能克
服障礙區域，使封包順利的傳送到目的地，並無法依
循最短的路徑來傳送。反之，主動式的作法錯誤! 找
不到參照來源。，則是在封包尚未傳遞前，先以分散
式的方式找出與障礙物距離小於通訊半徑的 Sensor 
Node，其稱之為 Border Node，其所挑選出來之 Border 
Node 具有連續性且包圍住障礙物。透過 Border Node
計算，可以事先規劃封包的傳遞方向，以引導封包至
較有效率的路徑。 
這些克服障礙區域的繞徑協定雖然可以引導封包
至較有效率的路徑以到達目的端，但是這些協定並沒
有針對資料收集共享路徑的的議題進行設計，因此亦
不適用於建構可克服障礙物之資料收集共享樹。 
由上列敘述可知，這些相關的研究中，並沒有考
量到障礙區域的出現對於 Share-Tree Topology 影響及
結構的破壞。在本報告中，將克服障礙區域對於一給
定之Share Tree所產生的影響，並建構出繞開障礙區域
且仍具有共享路徑之資料收集樹，以維護共享樹的運
作，並達到減少封包傳輸成本的目的。 
3.6. 定位與克障之文獻探討 
位置資訊的精確度是影響繞徑策略設計和效率的
重要因素。A. Galstyan 等作者[40]提出位置資訊定位的
演算法，每個 Sensor node 收到機器人發出的 beacon 發
出維護自己的矩形位置估計區域。矩形區域表示
Sensor 自己可能的所在位置範圍。然而，此矩形區域
將會造成需要精確位置的繞徑策略失敗。 
在隨意網路(ad hoc)和無線感測網路，有位置資訊
的能克服障礙物繞徑策略已被大量研究。P. Bose 等作
者[41]提出一個以面(face)為基礎的繞徑策略─Greedy 
Face Greedy(GFG)，封包透過面(face)的邊來傳送。送
端會建立一條從送端到目的地虛擬的線，封包延著此
線在面之間傳遞到目的地。 
另外在研究[42]，作者提出 GPSR 繞徑方法來克服
空洞存在。每個轉送點選擇最接近目的地的鄰居成為
下一步代傳點。當轉送點在挑選下一步代傳點遇到障
礙物時或是場景中的凹洞區，此點稱為 local minimal，
則採用右手法則(Right-Hand Rule)來選擇第一個順時針
鄰居作為下一步代傳點，直到這個順時針鄰居比 local 
minimal 距離目的地近，挑選下一步代傳點的策略才恢
復到選擇最近的鄰居。 
研究[43]和[44]提出偵測障礙物的策略，並且傳遞
障礙物資訊到網路場景中的所有點。他們採用 Voronoi 
Diagram 來判別鄰近障礙物的 Sensor nodes，稱作
border nodes。Border nodes 會導引封包到目的地且避
開障礙物。但是，每個 Sensor node 需要精確的位置資
訊才能判斷出障礙物旁的 borader nodes。然而在無線
感測網路中 Sensor 要得到精確的位置資訊是一大挑
戰，且不精確的位置資訊會造成錯誤的判斷為 border 
nodes。 
另一方面，採用面(face)為基礎的繞徑演算法在不
精確位置資訊場景下會產生降低封包傳送成功率的
Cross link。雖然K. Seada等作者[45]提出使用兩部鄰居
資訊來改善 face 建立的缺點，但 cross link 還是無法解
決。S. Funke 等作者[46]發展類似 GPSR 的演算法搭配
地標來提高封包傳送成功率。地標來建構 face，然
而，當鄰近的地標太接近還是會產生 Cross link。 
研究[47]提出 PAGER 繞徑演算法在不精確位置資訊
環境下克服障礙物問題。網路場景開始，每個 Sensor 
node 有一個和監控中心距離的權重值，當鄰居的權重
值都比自己大，則該 Sensor node 稱之為死結點(dead 
        —  8 — 
具有辨識方向與角度的能力，所以能決定其行走的方
向與距離。以下，我們首先詳述機器人在欲監測區域
內其蛇行狀佈點的規則。 
蛇行佈點的規則主要分為兩個 States，分別為向東
行走(East Movement，簡稱 East)，與向西行走(West 
Movement，簡稱 West)，在 East 與 West States 中，皆
具有兩個行走方向的選擇權且依優先權先後決定機器
人應行走的方向，如 Table I 所示，其中 Prefer 
Direction 1的設計使機器人有能力東西向蛇行狀行走佈
點，而 Prefer Direction 2 的設計使機器人能在遇邊界時
能由北往南移動一步，再以東西向蛇行佈點： 
表格(一)、蛇行佈點 
States Prefer Direction 1 Prefer Direction 2
East Î Ð 
West Í Ï 
若單以表格(一)的蛇行佈點，需有機器人必須在其
欲監測區域最北方的限制，若機器人在其最北方的最
東邊邊界出發，機器人將先進入 West State，反之，若
機器人在其最北方的最西邊邊界出發，機器人將先進
入 East State。而機器人判斷行走方向的時機可隨時判
斷或是行走固定長度後才判斷，由於機器人佈點是以
圖(二)(a)中每點相距 sr3 來佈點，為簡化敘述，我們採
用機器人每佈下一 sensor 後再判斷下一行走方向來說
明；當機器人處於某一 State 時，機器人每次行走，皆
先嘗試往 Prefer Direction 1 的方向行走，亦即為欲行走
的方向，若遇到 Prefer Direction 1 的方向已有 sensor 
nodes存在或是遇到邊界時，表示往Prefer Direction 1方
向行走失敗，則機器人將會選擇 Prefer Direction 2 方向
行走，每執行 Prefer Direction 2 成功後，機器人將會切
換至另一個State，如此，East與West兩個 states交替執
行，形成蛇行狀佈點，如圖(二)(b)所示。 
我們所設計的 Snake-like deployment 若僅採用如圖
(一)的佈點準則，對於欲監測區域的邊界，將容易有
空洞的情形，因此在機器人執行蛇行移動時，遇到邊
界將會採用 Boundary rule 來解決邊界的空洞問題。 
在我們所設計的 Snake-like deployment，機器人放置
sensor nodes 是依據圖(二)中 sensor nodes 彼此之間相距
sr3 來佈點，但因邊界或障礙物的存在，機器人可能
無法行走其所需的距離後，在理想佈點位置放置 sensor 
nodes，因此，因機器人行走方向與障礙物或監測區域
邊界垂直，而行走不足所需行走的距離，導致在邊界
產生空洞的問題來討論。 
首先，當機器人在佈點時其行走方向為東向或西
向，若行走的距離因遇到障礙物或邊界而不足 sr3 ，
則機器人會判斷是否應該在此邊界旁多放置一個 sensor 
node 來避免空洞產生，如圖(三)所示，邊界右邊的點
及虛線分別代表 robot 下一次佈點的位置與其感應範
圍，然而 robot 遇邊界後便無法繼續右行走，導致行走
的距離因遇到邊界而不足 sr3 ，若邊界與上一佈點的
距離為 l，大於 sr)23( ，則機器人將在此邊界多放置
一個 sensor node，如圖(三)中a點所示，若距離 l小於或
等於 sr)23( ，則機器人不需在此邊界放置 sensor 
node，而由於 a 點是為解決邊界空洞所額外需放置的
sensor，機器人須在理想的位置來判斷下一佈點的位
置，因此，當機器人放置 a 點後，將退回 b 點重新執行
Snake-like Deployment。以下，我們以 BRule 來表示上
述之規則。 
BRule：若行走的距離因遇到邊界而不足 sr3 但大於
sr)23( ，則機器人將在此邊界多放置一個
sensor node，且放置完畢後回上一佈點的位
置；若小於或等於 sr)23( ，則機器人不需
在此邊界放置 sensor node。 
 
圖(三)、東南西北四個方向因邊界與機器人行走方向
垂直而產生空洞的情形。 
經由執行上述的方法，可以很有效率完成規則的
sensor node 佈建規畫。 
 
 (二) 不規則的 sensor node 佈建規畫 
Sink
Sensor
(1, 1)(2, 1)(3, 1)
(1, 2)(2, 2)(3, 2)
(1, 3)(2, 3)(3, 3)
 
圖(四)、一個 33× 的網路拓撲架構圖 
在這個議題方面，我們針對不規則的 sensor node 佈
建進行規畫，為簡化問題，我們首先假設網路環境是
架構在一 NN × 的 mesh topology 上，網路上的成員共有
一個 Sink Node 與 12 −N 個 Sensor Nodes。圖(四)代表一
33× 的mesh topology。每一個Sensor Node都知道自己的
初始座標。由於本研究成果的適用範圍為環境長期監
控，在無線感測網路中的每個 Sensor Nodes 均需定期
傳輸其所感應的資料至 Sink Node，在一段固定的時間
內，其所需傳輸的資料量均相同。此外，為方便討
論，我們假設 Sink Node 位於此 mesh topology 的右上
方，Sensor Nodes 則是規則分佈於此拓撲網路中，而
Sink Node 的初始座標為(1, 1)，在 mesh topology 中每
往 Sink 左方及右方位移一單位，其 x 座標與 y 座標將
分別加一。 
        —  10 — 
 
圖(九)、機器人針對所有待修復的 sensor nodes 建立
修復路徑的方法。 
在規則的 sensor node 佈建規畫研究中，我們使用
了機器人來完成佈建的工作。但是，經過一段時間的
運作後，有部分的 sensor node 會無法正常的運作。所
以在機器人佈點的同時，將會留下適當的軌跡，當
WSN 經過長時間的偵測之後，某些 sensor nodes 發生
故障或是即將耗盡電量需要修復時，偵測到故障區域
的 sensor nodes或是即將耗盡電量的 sensor nodes，將會
利用機器人所留下的軌跡以較短的路徑追蹤機器人，
並通知機器人至此區域進行修復，此過程稱之為
Repair 的演算法。若機器人收到許多 sensor nodes等待
修復的資訊時，為達到迅速修復及機器人省電的目
的，機器人將以Dynamic Programming的技巧來建立一
通過各毀損區的最短路徑，如圖(九)所示，nodes A、
B、C、D、E為待修復區的代表，藍色虛線是以greedy
的方法每次皆選擇離機器人最近之 sensor 來決定優先
行走而產生的路線，為 O→A→C→B→D→E，而紅色
路徑為經過我們設計的修復路徑所計算出行經所有待
修復區的最短路徑，為 O→C→A→B→D→E。扣除藍
色虛線與紅色實線相同的路徑長度，藍色虛線多出來
的路徑長度為OA 與OB ，紅色實線多出來的路徑長度
為 AB ，此三線段形成一個 OABΔ ，由三角形兩邊長必
大於第三邊的特性， ABOBOA >+ ，明顯可看出紅色
路徑比藍色路徑短，使機器人能以最省電的方式，走
最短路徑來快速修復這些待修復區，而毀損區亦可在
較短的時間內修復並正常運作。 
而機器人在WSN中行走時會留下軌跡讓 sensors追
蹤其位置，但執行多次的 Repair 路徑後，sensor nodes
追蹤機器人的路徑可能會過於崎嶇而有繞遠路的情
形，如圖(十)所示，假設機器人目前行走至 node B 的
位置，node A 其所追蹤機器人的路徑為藍色實線，此
路徑顯然有繞遠路的情形，node A 與 node B 存在有另
一條最佳的路徑，紅色虛線為此兩 nodes 間的最短路
徑。為了改善路徑過於崎嶇且有繞遠路的情形，機器
人需常發送 packet 來通知所有的 sensor nodes 修正路
徑，然而，在繞遠路的 path 與 packet overhead 的
tradeoff 考量下，我們將盡量使用較小的 packet 
overhead來修正繞遠路的path，使花費較小的封包成本
但卻可達到 sensor nodes 追蹤機器人的 path 能盡量為最
短路徑之目的。 
 
圖(十)、Sensor nodes 利用 robot 留下的軌跡來追蹤
robot，所歷經路徑過長的問題。 
最後，我們會擴充機器人 Repair 的演算法，使其
兼具考量機器人因電量耗盡或為補充 sensor node 而回
home 的機制。機器人有許多原因必須回 Home，首
先，機器人在執行修復與巡邏 sensor nodes 的過程中，
機器人本身也可能會耗盡電量，其次，機器人身上所
配帶的 health sensors 可能用完，再者，毀損 sensors 亦
需透過機器人回收以免影響環境，因此，我們在機器
人執行修復 sensor nodes 的過程中，將機器人回 Home
以充電、補充 health sensors 及回收毀損 sensors 之需求
加入考量，以防止機器人在執行修復與巡邏 sensor 
nodes 的過程中，因電量耗盡而來不及回 Home 補充電
量。 
以下我們用圖(十一)(a)來說明機器人考量回 Home
的行走路徑，nodes A、B、C、D、E為待修復的 sensor 
nodes，機器人根據本報告所設計的 Repair 演算法，計
算出能最快速修復此五個 nodes的路徑已由上述得知如
圖(九)中的紅色路徑所示，為 C→A→B→D→E，然
而，機器人所剩餘的電量不足夠走至 node E，機器人
在由 node A 走至 node B 的過程中電量已耗盡，因此，
為避免機器人的電量耗盡，我們將機器人回 Home 納
入排程，求得一條可通過 nodes A、B、C、D、E 且可
回 Home 的最短路徑，為 C→A→Home→B→D→E，然
而，雖然此路徑已將機器人回 Home 加入考量，但同
樣地，機器人在由 node A 走至 Home 的過程中，機器
人的電量耗盡，機器人的電量仍來不及走到 Home 補
充電量。因此，我們將設計一演算法，使機器人能在
來得及回 Home 補充電量的情況下，以最短路徑且最
快的方式來修復待修復的 sensor nodes。如圖(十一)(b)
所示，機器人計算出其剩餘電量足夠先修復 node A
後，再回 Home 補充電量，並在補充完電量後，依序
修復 node B、D、E、C，如此，機器人可以來得及補
充電量，並在最短的時間內修復待修復的 sensor 
nodes。同樣地，在有障礙物的環境中，機器人也能考
量其所剩餘的電量，將回 Home 的路徑納入演算法中
考量，使機器人在電量耗盡前能來得及回 Home 充
電。 
        —  12 — 
以圖(十二)(b)為例，左圖為機器人行走至 A 點的情
形，機器人是以A點的 di方向靠近A點，若此時機器人
發送 X-correction packet，圖中 A 點座標為(9, 3)，當 A
點發送 X-correction packet 時，此 packet 的資訊有 A 點
的位置資訊(9, 3)、Broadcast ID=1，Hops=63，其鄰居
均將 counter value 更正為 62，而收到此封包且 VCL 滿
足 )3()9( −−=− yx 的有 neighbor nodes (10, 2), (8, 4)，滿
足 3=y 的有 neighbor nodes (11, 3), (7, 3)，此四個
sensors 將把 Broadcast ID 改為 1，Hops 減 1 為
Hops=62，然後此四個 sensors再次將此封包廣播出去，
封包資訊為 A 點的位置資訊(9, 3)、Broadcast ID=1，
Hops=62 ， 其 鄰 居 中 收 到 此 封 包 且 VCL 滿 足
)3()9( −−=− yx 的有(11, 1), (7, 5)，滿足 3=y 的有(13, 
3), (5, 3)，此四個 sensors 也更新自己的 Counter value，
Broadcast ID 改為 1，Hops 改為 61，並再將此封包廣播
出去，依此類推。 
 
VCL of node a ： (s, t) 
Receiver：(x, y) 
If the direction that the robot lastly moved is
do,d3：if |x-s| = = |y-t| 
forward the packet
d1,d4：if (x-s) = = －(y-t) or y = = t 
forward the packet
d2,d5：if (x-s) = = (y-t) or y = = t
forward the packet  
(a) X-correction mechanism 的規則。 
A
<0,11> <0,10> <0,9>
<0,20> <0,21><0,18> <0,19>
<0,63> <0,24> <0,23><0,29> <0,30>
<0,62> <0,61><0,32>
<0,38> <0,37><0,39>
<0,41>
<x, y>：Counter value
(9,3)
(x, y)：VCL
(7,3) (11,3)
(8,2) (10,2)
(8,4) (10,4)
(9,1)(7,1) (11,1)
(12,2)(6,2)
(5,3) (13,3)
(6,4) (12,4)
(7,5) (9,5) (11,5)
 
A
<0,11> <0,10> <1,61>
<1,62> <0,21><0,18> <0,19>
<1,63> <1,62> <1,61><1,61> <1,62>
<0,62> <0,61><1,62>
<0,38> <0,37><1,61>
<0,41>
<x, y>：Counter value
(9,3)
(x, y)：VCL
(7,3) (11,3)
(8,2) (10,2)
(8,4) (10,4)
(9,1)(7,1) (11,1)
(12,2)(6,2)
(5,3) (13,3)
(6,4) (12,4)
(7,5) (9,5) (11,5)
 
(b) X-correction mechanism 的例子。 
圖(十二)、X-correction mechanism。 
 
 
4.2 第二年的研究方法以及成果 
(一) 模糊位置偵測、修正與繞徑演算法 
我們所假設的無線感測網路是由一個 Sink 以及 k 個
static sensor node 所組成 S1，S2…Sk，這些 sensor 被佈建
在 m×m 的環境中，m 為感測區域的長與寬。此外，我
們假設網路初始時，sensor Si已經由 mobile anchor 協助
定位，得到一矩形的區域，我們以 Si.ELR=(xil, yil, xir, yir)
表示之，其中 (xil, yil)與(xir, yir)分別表示其矩形的左上
角及右下角的位置資訊，而 sensor 所在的真正位置以
Si.real_loc 符號表示，其中 Si.real_loc∈Si.ELR。我們假
設 sensor 透過封包的交換，已得知一步鄰居的 ELR 之
值。 
由於 sensors 可能因為風吹、敵軍惡意散佈錯誤的位
置資訊，或是動物遷徙，而造成其記錄錯誤位置之問
題。使得其因移動而落點於其原有的 ELR 區域之外，
亦即其目前的真實位置 Si.real_loc∉Si.ELR，然而 sensor 
並未感知其移動，因此其所記錄之位置資訊仍為舊有
之 ELR 區域，造成其記錄錯誤位置之問題，進而影響
繞徑之正確性。因此，我們希望發展一分散式技術可
使記錄錯誤位置的 sensor能自我偵測及更正其錯誤之位
置資訊。以下我們以數學符號來表達此問題： 
已知在時間 t1 時， Si 所記錄正確之位置資訊
Si.ELR，在時間 t2時，因為 Si移動至其他位置，使得 Si
其真實位置不在所記錄的 ELR 之內，導致環境中存在
許多 sensor 其滿足 Si.real_loc ∉Si.ELR，其中 1 ≤ i ≤ k，
我們擬發展一錯誤偵測及錯誤修正之技術將 Si.ELR 修
正為 Si.ELR’使得 Si.real_loc∈Si.ELR’。 
A. 模糊位置偵測與修正演算法 
本章節介紹在模糊位置資訊之下的WSN應該如何以
分散式技術偵測並修正網路中因移動而記錄錯誤位置
資訊的 sensor。爲了以下的說明，在此將介紹下述會使
用到的符號與定義。針對任一 sensor Si 而言，其在在 t
時間點的鄰居記為Nt(Si)， R(Nt(Si))表示 Si利用 t時間點
鄰居的 ELR 區域做交集運算所得到的矩型區域，我們
利用下式求得此區域的運算： 
ELRj
SNS
it CSSNR
itj
.))((
)(∈
= I                  (1) 
我們觀察到網路中每個 sensor均具有ㄧ特性：當 Si的鄰
居皆記錄正確的 ELR 資訊，則 Si.real_loc∈R(Nt(Si))，若
Sa.real_loc ∉ Sa.ELR，則 sensor Sa至少會超出一個鄰居
其 CELR之外。 
根據這些特性，我們發展了此分散式的錯誤位置偵
錯及更正技術。首先，每個 static sensors 定期的與鄰居
交換資訊，其內容有自己的 id 與 ELR 資訊，讓 sensors
主動察覺不同時間點鄰居的變化，並利用這些變化來
達到錯誤位置偵錯及更正的目的。 
在作法上，我們先考量一個 Sensor 因移動而記錄錯
誤位置的問題，之後，再將此問題延伸至多個 Sensor 
同時因移動而記錄錯誤位置的問題。 
（A）單點移動發生之錯誤位置 
首先，我們假設 WSN 中同一時間只有ㄧ個 sensor Si
因移動而記錄錯誤的位置。我們所研發的錯誤位置偵
測與修正，乃基於下述兩個重要的 Lemma。 
Lemma 1：已知 sensors Sa 與 Sb 為可通訊的鄰居，且
sensors Sa與 Sb均記錄正確的位置區域，則 sensors Sa與
Sb會有以下特性： 
 (1) Sa.ELR ⊆ Sb.CELR 
 (2) Sb.ELR ⊆ Sa.CELR 
Lemma 2：若 Sa.real_loc ∉ Sa.ELR，則 sensor Sa至少會
超出一個鄰居之 CELR之外。 
以下，我們提出一程序來協助 Sensor Si 判斷其位置
記錄是否正確，並將可能記錄錯誤位置之資訊更正為
        —  14 — 
將使移動的 sensor也形成了Border，而扮演Border角色
的 sensor 亦可能是移動者，依上述方法將利用其所記
錄的錯誤資訊來修正別的 sensor。為使修正的結果仍維
持其正確性，Border node 將收集其兩步鄰居資訊，並
利用舊有鄰居的變化程度，來設定信任值(Confident 
Value)，而此信任值是用來決定自己是否需要修改位置
資訊。當 Border node 收集鄰居傳送的信任值封包後，
將會把自己為 Border node 角色的訊息傳給其兩步鄰居
知道，此訊息內容包含有 Border node 的 id 與其信任
值。當 sensors 收到 Border node 所發送的訊息之後，
Sensor 會將此信任值記錄下來，並且再發送給其一步鄰
居。一旦，此封包被懷疑自己為移動的 sensors Sj 收到
之後，其便會更正自己之位置並將取其信任值之倒數
當作 Random Backoff Timer。當此 Timer 倒數結束之
後，便會將修正訊息的封包傳送給新進的鄰居，以修
正其他記錄錯誤位置資訊的 sensors。而信任值較大表
示 Border node 的兩步鄰居內沒有變化的 sensors 較多，
也就是記錄正確 ELR 的 sensors 較多，反之，則代表記
錄正確 ELR 的 sensors 較少。因此，利用 Random 
Backoff 的機制將使得信任值較大者的 sensors 先發起修
正的封包以修正錯誤資訊的 sensors。 
圖(十七)為我們根據單點移動所延伸的多點移動錯
誤偵測與修正演算法，主要修改的部份在於Case 2。在
LEDC的作法中，針對鄰居變多且舊有鄰居變少的情
況，所給予的決策是排除新進的鄰居而利用舊有的鄰
居做重新運算，但由於群體移動我們無法判定是哪一
群sensors移動，若利用LEDC的作法會有無法修正錯誤
資訊的情況發生，故此給予GLEDC演算法，讓sensor Si
等待Border node的訊息已修正錯誤資訊。圖(十八)為我
們所提出的Border node修正之演算法。一旦sensor Si發
現自己為Case 2的情形，便會發送請求更正之封包，並
且等待Border node的訊息。而其鄰居Sj收到此訊息後便
會檢查其是否為Border node，若為Border node角色
時，則收集兩步鄰居的信任值，再將此訊息發送給自
己的鄰居，以嘗試更正記錄錯誤位置資訊的鄰居。 
GLEDC : Group Location-Error Detection and Correction Algorithm
1. Si compares its Nt(Si) and Nt+1(Si)
/* Case 1, the neighboring sets at time t and t+1 are identical*/
2. if  (Nt(Si) ==  Nt+1(Si))
3. Si do nothing;
/* Case 2, a new node is detected and the old neighbors do not 
disappear */
4. elsif (Nt(Si) ⊆ Nt+1(Si)){
5.    broadcast “error detection packet”;
6.    waiting for “border” message;
7.    if (Si received border message from Sj)
8.            }
/* Case 3, an old neighbor disappears, and no new node is 
detected */
9. elsif (Nt+1(Si) ⊆ Nt(Si))
10. 
/* Case 4, some new nodes are detected and some old 
neighbors disappear*/
11. else
12.
ELRj
BorderS
i CSELRS
j
..
∈
= I
ELRj
SNS
i CSELRS
itj
..
)(1+∈
= I
ELRj
SNSNS
i CSELRS
ititj
..
)()(1 −∈ +
= I
 
圖(十七)、GLEDC 演算法。 
LEDC_Border : The decision of border node
1. Sj compares its Nt(Sj) and Nt+1(Sj)
/*The neighboring sets at time t and t+1 are identical*/
2. if  (Nt(Si) ==  Nt+1(Si)){
/* Sj collects the number that neighboring sets are identical of 
its 2-hop neighbors */
3.        border:=true;
4.        if (Nt(Sk) ==  Nt+1(Sk)){
5.                CV:=CV+1;}
6. }
7. if (border == true)
8.        Sj broadcast the “border” message and its CV;  
圖(十八)、LEDC_Border 演算法。 
總結我們所提出的方法，不論環境中因移動而記錄
錯誤位置資訊的 sensors 個數為一個或是多個，所提出
的錯誤位置偵測及更正技術皆能讓 sensors 進行自我的
判斷並且加以更正成為記錄正確位置資訊的 sensor。 
B. 模糊位置下的繞徑演算法 
本章節將針對具有模糊位置資訊之WSN發展一分散
式繞徑技術使封包能在低轉送成本的條件下成功轉送
至 Sink。以下我們分別針對模糊位置資訊下如何挑選正
確的轉送者及如何減少轉送成本這兩個議題進行繞徑
協定的設計。 
（A）Forwarder Select Strategy 
在此，我們將設定許多封包代傳的規則，使封包自
Source sensor node傳送至Sink能盡量減少封包代傳量並
能成功地傳送至Sink node。令dis(x, y)表示空間上兩點x
與 y 的直線距離，由於環境中的每個 sensor 在傳遞封包
的過程中，皆希望封包傳送給比自己更靠近 Sink 的鄰
居，爲了達成此目標，sensor Si 在收到封包時，必須滿
足下列條件才可擔任代傳者並轉送封包： 
dis(Sink, Si.ELRcp) < dis(Sink, Sj.ELRfp)          (2) 
上式(1)是說明當 Si 收到 Sj 所傳送的封包之後，Si 判
斷自己的最佳點是否較傳送者 Sj的最差點要靠近 Sink，
給予此式子的原因如下，如果 Si的最近點較 Sj的最遠點
更遠離 Sink node，這表示 Si必定比 Sj更遠離 Sink。式子
(2)的主要目的在防止封包往 Sink 的反向傳送。 
Sink
S1
S2
S3
 
圖(十九)、模糊位置區域繞徑所面臨的問題。由於 S2
與 S3的最近點皆比 S1的最遠點靠近 Sink，因此 S2與
S3若傳送封包將會往反向傳送。 
式子(2)雖然依 ELR 之資訊減少封包往反向傳送的機
會，然而，這樣的判斷式依舊有機會將封包往反向傳
送，圖(十九)所示， sensors S1，S2與 S3其 ELR 有所交
集，實際上 S2與 S3的真正位置與 Sink 之間的距離皆遠
於 S1與 Sink 的距離，其中 S1為封包發起者，而 S2與 S3
會收到此封包，若我們只用式子(2)讓 S2 與 S3 決定自己
        —  16 — 
的位置資訊。一旦 ND node 有改變的話，則會對 HD 
Node 上的資訊做更新，使得後續 Sink Node 的查詢及
Sensor Node 的儲存資料得以根據 HD Node 上的最新資
訊來找到 ND node。而對於欲查詢事件或儲存資料的
Sink Nodes 跟 Sensor Nodes 而言，相同地會利用 Hash 
Table來取得HD Node的位置並發送 query及資料至HD 
Node，如圖(二十一) (b)。進入 Dynamic Phase 的 HD 
Node 收到這些封包時，因為有維護 ND Node 的位置資
訊，所以會將這些封包轉送至正確的ND Node。就Sink 
Node 而言，當ND Node收到HD Node轉送的封包時，
則會在回傳資料時對此Sink做Data-Centric Node資料更
新，而對 Sensor Node而言，亦會發送一個ACK封包來
更新此 Sensor Node 上的 Data-Centric Node 資料。 
利用轉送的更新機制是因為一旦 Data-Centric Node
發生改變後，如果我們利用Flooding的方式來更新所有
Sinks 及 Sensor Node 的 Data-centric node 資料，則每次
改變就必須對整個網路Flooding一次，將花費太高的成
本，而且有些 Sensor Nodes 可能這段時間內並沒有此事
件資料要儲存，而有些 Sinks 對此事件並沒有興趣收
集，所以這樣的更新方式沒有效率。所以只有當 Sensor 
Nodes 有資料要儲存或 Sink Node 提出查詢要求時，利
用 HD Node 轉送至 ND Node，再由 ND Node 來更新這
些Sensor 及Sink上的Data-centric node資訊，將可以有
效地減少 Data-centric node 資訊更新的成本。 
 
 
（a）Static phase  and dynamic phase operations 
 
（b）Dynamic phase operations 
圖(二十一)、Protocol architecture 
B. Data-Centric Routing Mechanism 
當一個 Data-Centric Node 同時對多個 Sink 回傳資料
時，我們希望能自動建立出 Share Path 的路徑來減少重
覆資料傳送的 Sensor Node，並減少頻寬與電量的浪
費。為了以下說明方便，我們先定義一些符號，我們
令 d(A, B)表示 Node A 與 Node B 之距離。而對於
Data-Centric Node回傳給n個Sink S1、S2、…、Sn之data 
packets 若能共享路徑，則我們定義此共享同一資料封
包的 Sinks 集合為 ShareGroup(S1, S2, …, Sn)。假設
Data-Centric Node D 目前負責回傳資料給 n 個 Sink S1、
S2、…、Sn，因為每個 Node 皆會收集鄰居的位置資
訊，故 Node D 會建立一個 Neighbor Information Table
（NIT）。假設Node D具有m的鄰居N1、N2、…、Nm，
NIT中會對每個Neighbor Ni紀錄透過Ni可有效地將資料
傳送至哪些 Sink Nodes，如圖(二十一)中所示。只要鄰
居 Ni與 Sink Node Si的距離 d(Ni，Si)小於 Node D 與 Si
的距離 d(D, Si)時，則可透過此 Ni 當作 Next Hop 之
forwarding node 將資料傳送給此 Sink Si。故當 Node D
欲傳送感測資料給 Sink Node 時則會根據以下演算法來
規劃傳送給不同 Sink 的封包要如何共享路徑： 
假設 NIT 中對於 Node D 的 m 個鄰居，皆有各自可
到 達 的 Sink 集 合 ， k1, k2,…, km 。 初 始 階 段 ，
ReplySink={ψ}且 SelectedNeighbor={ψ}。首先，Node D
將選取 kmax=max(|k1|, |k2|, …, |km|)，將 kmax加入ReplySink
集合中，並且將此鄰居加入 SelectedNeighbor 集合中。
若|ReplySink| < n，則將 kmax暫時從 NIT 中刪除，再重複
以 上 步 驟 ， 直 到 |ReplySink| = n 為 止 ， 此 時 ，
SelectedNeighbor集合即為回傳資料給所有 Sinks的Next 
Hop 代傳點。而收到這些資料的代傳點相同地會根據以
上演算法來判斷如何對這些回傳資料作共享路徑的規
劃。 
我們以圖(二十二)為例，在圖(二十二)（a）中，
Data-Centric Node D 有五個鄰居 N1、N2、N3、N4、N5。
此Node D欲回傳資料給四個Sinks A、B、C、Z (n=4)，
而每個鄰居對於能將資料有效傳送到的 Sink 集合為圖
中 NIT 所示。依照上面說明的演算法，初始階段，
ReplySink={ψ}且 SelectedNeighbor={ψ}，首先將選取 N3
加入 SelectedNeighbor 集合，因為 k3= max(|k1|, |k2|, …, 
|k5|)，而 ReplySink={A, B}。因為|ReplySink| < n=4，因
此從 NIT 中暫時將{A, B}刪除後，將會剩下 N2（C）、
N1（Z）、N5（Z）。接下來，依照相同的方式便會選取
N2 集合以及 N1 集合，此時因|ReplySink| = n 演算法結
束。所以最後 SelectedNeighbo={N3, N2, N1}，回傳資料
將分成三個封包分別由 N3、N2、N1來代傳，其中 Sinks 
A、B 可共享 N3的資料封包，我們將此次共享封包的規
劃表示為：ShareGroup(A, B)、（C）、（Z）。而接下
來每個代傳點又會以相同的方式來決定 Next Hop 代傳
點，所以最後當圖(二十二)（a）中代傳點 T 的鄰居無法
再繼續共享 A、B Sink 的封包時，則會分成兩個封包：
（A）、（B）分別傳給 A、B Sinks。 
 
        —  18 — 
路，探究如何維護已建立的資料收集樹，使其能克服
障礙物的阻撓，修復一受到破壞的資料收集樹，使其
仍可以高度共享的方式來繼續收集資料。 
我們考慮一給定的連接s個Source所構成一棵Binary 
Share Tree T = (V,E)，其中，V是Tree 中的點集合而E是
邊的集合。此Binary Tree，以Sink為Root並這些Source
我們以Destination Set DS={Sink,D1,D2,D3…Ds}，其中
∀ Di ∈V表示DS中的成員可能為Leaf或Internal Node。
在此Binary Tree中具有分枝的Internal Node，我們稱之
為Share Point，並以SP={SP1, SP2,SP3... SPm}來表示，
Source回傳的資料會在Share Point先進行資料整合，再
往Sink端回傳，因此，這個Share Point將有助於資料回
傳時減少資料傳送的封包數量。由於DS及SP的中的成
員無法保證以一步距離將封包傳送至目的地，因此，
必須透過網路上其他不屬於DS或SP的點，來幫忙轉送
封包至目的地，這些幫忙轉送封包的點，稱之為
Forwarding Node FN={FN1,FN2,FN3... FNk}，因此，這棵
樹將具有V=FN∪DS∪SP的關係。 
我們假設每個Node vi均有相同的最大傳輸距離r及
具有Power Control的能力，各個Sensor Node vi皆能以適
當的Power 控制適當的傳輸距離與Parent進行資料傳
輸， 並且，我們也假設每個Node vi 能夠對多個具有相
似資料的封包進行完整的資料整合，也就是多個封包
在進行資料整合後會變成只有一個封包需要進行傳
送。另外，Sensor Node是隨機均勻的散佈在整個感測
網路中，任兩個Sensor Nodes vi及 vj之間的距離以
dist(vi，vj)表示，換言之，在vi及vj之間若存在Edge則表
示此兩點具有dist(vi，vj)≦r的關係，而且我們假設連接
Share Tree的Edge為Bi-Directional的Link，及每個Node
可以知道自己的Parent、Left-Child及Right-Child。再
者，我們假設每個點vi都知道自己的位置資訊，位置資
訊的取得可以透過GPS定位或是利用其他定位方法。在
以往建立共享樹研究中，其所提出的方法均可滿足本
報告的假設。另外，針對封包能夠被完全整合，以往
進行資料整合的研究中，其運作的環境，也能滿足本
報告封包能被完全整合之假設。因此上述假設乃具有
其合理性。 
SP2
Sensor
Sink
Source
Border
Share Point
D2
D4
D3
D1
D5
D6
SP1
SP3
A
B
F
G
H
C
D
E
I
K
J
L M
Proxy Node
PN1
PN2
 
圖(二十四)：障礙區域產生破壞 Share Tree 的結構 
在網路初始時，Sensor Nodes採用GMP技術建構一
Share Tree T連接網路中S個Sources DS={Sink,D1, D2, 
D3…Ds}，以進行資料收集之任務。然而當障礙區域產
生時，Share Tree T將會被分割成n棵的子樹，同時，DS
也會被分割成n組的Sub Destination Set，也就是DS= 
DS1∪DS2∪DS3∪...∪DSn ，當Share Tree T被障礙區域
分割或Share Point無法繼續與其它Sensor Node通訊，則
Share Point會喪失其共享能力，使得Share Tree T無法再
以原本的Tree Structure中之Share Point，進行資料收集
及整合。因此，為維護Share Tree的運作，我們將透過
Tree重建的方式，來連接n個被分割的Destination Set，
以恢復資料收集與整合之服務，我們所重建的Share 
Tree除了要具有克服障礙區域之能力外，其所找出新的
Share Point也要具有最佳的共享特性，所以如何維護一
個具有高度共享能力的Share Tree將是本報告擬解決的
問題。由於我們假設在進行資料收集時，封包能夠被
完整的整合，因此進行資料收集的時候，Share Tree中
的任一條Edge只會有一次的封包傳遞，而Share Tree中
每個Edge傳遞封包時會有不同的Energy Cost，各個
Edge所要耗費的Energy Cost會與距離呈α次方的正比關
係，α可以等於2或4。因此，若要最小化整個Share Tree
進行資料收集所耗費的總電量，相當於最小化Share 
Tree的總路徑長度，在此，我們令TL是重建後Share 
Tree的總路徑長度，由於不同的Share Point會造成不同
的TL值，當TL為最短時，其Share Tree所耗費的電量為
最少，也代表找出的新Share Point具有最佳的共享能
力，因此我們的目標為 
∑= += ksi ii parentvvdistTL 1 ).,(Minimize  (1)
封包越早進行整合，也不一定具有最少的Energy 
Cost，在先前的研究中，已證明高度整合的Share Tree
乃具有較短的邊總合，且這樣的Share Tree將最節省傳
輸時的總電量，因此，重建後的Share Tree將以(1)式為
目標。 
我們在不失一般性的條件下，以圖一為例來描述
我們要克服的問題。在圖(二十四)中，我們有一棵已建
立好的Share Tree T，其DS = {Sink,D1,D2,D3,D4,D5,D6}，
SP={SP1,SP2,SP3} ， 及 FN 
={A,B,C,D,E,F,G,H,I,J,K,L,M}，當有一障礙區域產生
時，採用錯誤! 找不到參照來源。的研究將可以利用
分散式的機制產生圍繞障礙物的一組Border Node 
BN={BN1, BN2,BN3…BNl}。當障礙區域的產生影響或破
壞原本的Share Tree結構時，Tree Topology會被障礙區
域分割成幾個Sub-Tree，如圖一所示，Share Tree T被障
礙 區 域 分 割 成 5 個 Sub-Tree ： T1=(V1,E1) ，
DS1={Sink,D1,D2}且DS1⊆V1、T2=(V2,E2)，DS2={D3}且
DS2⊆V2、T3=(V3,E3)，DS3={D4}且DS3⊆V3、T4=(V4,E4)，
DS4={D5}且DS4⊆V4、T5=(V5,E5)，DS5={D6}且DS5⊆V5。
被分割的Share Tree將無法再利用原Share Tree Structure
進行資料收集之任務，因此，必須重新建立新的Share 
Tree Topology，以連接網路中所有被分割的Source，並
恢復資料收集之任務。 
A. 克障共享樹重建演算法 
我們所提出維護 Share Tree 的協定，將找出因障礙
區域的產生而受影響的Source，並將被障礙區域分割的
Source重新建立共享連結，以修復資料收集樹並達到高
度共享及克障的目的。 
我們所提出的的方法分為兩個階段，第一個階段
        —  20 — 
T2 、 T3...、Tn，因此 Destination Set 亦相對被分割成 n
個子集 DS1 ∪ DS2 ∪ DS3 ∪ DS4…∪DSn =DS，在這個步
驟中，我們擬找出新的 Share Point，將多組 Destination 
Set DS1、DS2、DS3…、DSn重新連接在一起中，使其成
為具有共享能力及連結性的 Share Tree。在每個 DSi 中
在 n 個子樹中，資訊收集者將另外選出兩個不同的子
樹，與自己所存在的子樹進行連結並建構 Share Tree 的
動作。在合併n個子樹時，我們必須考慮到(1)保持二元
樹的特性，使 Tree 中 Internal Node 的 Link 數最多不超
過三條，以方便我們利用 Steiner Point 的概念來維護
Share Tree，(2)任意重新連接被分割子樹，會打亂 Tree
中的 Parent 及 Child 的角色關係，造成已往 Sink 方向傳
的資料又往遠離 Sink 方向傳。由於上述兩點的考量，
我們限制每回合進行 Reconstruct 的子樹個數不得超過
三個，也就是說，在重建 Share Tree 的程序中，同一時
間只能有一個資訊收集者可進行重建 Share Tree 的運
算，以保持 Share Tree 為二元樹的特性。 
為達到此目的，我們以 Random 的技術來決定哪個
資訊收集者應進行 Tree Reconstruction 的運算。在 Share 
Tree中，各個Tree Node都有不同的Tree Level，越靠近
Sink 端的 Node ，其  Tree Level 越低，在 Tree 
Reconstruction 時，為維持原本 Share Tree 中 Parent 與
Child 角色的關係，我們讓 Tree Level 越低的資訊收集
者擁有較高的優先權起來進行 Reconstruct 及尋找 Share 
Point的動作，當資訊收集者的Tree Level相同時，其中
ID 較小的會先醒來運作。下式(2)為 Random Backoff 
Time 的計算式，整個 Random Backoff Time 是主要由
Node所處的 Tree Level及 Node ID 決定，公式前項主要
將不同 Tree Level 的Node安排在不同的 TimeInterval，
其中，而 MinLevel 等於障礙區域所分割產生的資料收
集者中，最小的 Tree Level Value，因此，越低 Tree 
Level 的資料收集者能越優先起來。然而，各個資料收
集者可能會因為有相同的 Tree Level，使得多個資料收
集者同時起來進行重建的狀況發生，因此，公式後項
利用 ID的獨特性分散具有相同Tree Level資料收集者的
Backoff Time，讓 ID 較小的資料收集者較早醒來。 
).().(
.
alTimeInterv
talNodeNumberOfTo
IDvalTimeIntervMinLevelLevelv
eBackoffTimv
i
i
i
×+×−
=  
(2) 
Random Backoff 先結束的資訊收集者，我們以 ICi
表示，ICi 擁有自己所屬子樹的資訊以及其他 Proxy 
Node 所分享的 Sub-Tree 資訊，在後續的動作中，ICi將
從其他分割的子樹中挑選出兩個分割子樹的 Root，ICi
所屬 Sub-Tree 中的 Leaf Node I 與這兩個 Root 計算出適
當的 Share Point，使這三個子樹的連結具有最小的
TL。然而，由於障礙物的影響，與 I 擁有較小夾角的兩
個分割的子樹不一定能建構最具共享能力的 Share 
Tree，因此，在這個程序中，ICi 會試以自己 Sub-Tree
中的所有 Leaf Node I 當作 Parent，分別與其他任意兩個
Sub-Tree的Root J 及K挑選最佳的Share Point，再找出
具有最小 TL 的重建組合後，ICi將透過 I 與所找出最佳
重建組合 J 及 K 進行連接的動作。 
以下我們進一步敘述 ICi以自己 Sub-Tree 中任意的
Leaf Node I 與兩個 Sub-Tree 的 Root J 及 K 其建構
Share Point 的程序。因為 Share Point 必須具有共享及
克服障礙區域的能力，所以我們先找出具有共享及克
障能力的區域，我們稱此區域為 Share Region，再從
Share Region中來挑選出最佳的Share Point來連接分割
的子樹。在 Share Region 中任意的幾何位置 P’皆具有
共享且避開障礙物之能力，皆能以假想的三直線分別
連接至三點，並避開 BN 所圍的區域。ICi 將會從
Share Region 中挑選最佳的 Share Point 來與其他重建
Share Tree組合所找的Share Point進行成本比較，挑選
最佳的重建組合。在計算 Share Region、Share Point 都
是以相同的 BN 資訊及 Sub-Tree 的資訊來進行計算，
從多組可能進行重建的組合中，挑選出最佳的組合來
進 行 Reconstruct 的 動 作 ， 因 此 所 找 出 來 的
Reconstruction 組合會是一致且唯一的，不會發生決策
衝突的問題。 
以下我們將描述找尋 Share Region 及挑選 Share 
Point 的方法，最後從眾多適合進行 Reconstruction 的組
合中，決定進行重建的組合。 
(a) Share Region 
Random Backoff 先結束的資料收集者 ICi 會利用
Faulty Tree Detection Phase 中， Proxy Node 所收集到
的資訊，來計算自己所屬子樹中各 Leaf Node I 與其他
任意兩個 Sub-Tree 的 Root J 、K 之間的 Share Region。
以下我們將詳述其建構 Share Region 的方法。  
J
I
K
LJ 1
LK 1
J 1
JK
K 1
K 2
JK’
J 2
LI 2
LI 1
I 2
I 1
 
圖(二十六)：Share Region 
如圖(二十六)所示，為了避開障礙區域，ICi將 J及
K 與 BN 圍繞區域畫切線，把切線當作障礙區域的分界
線，在切線的一邊會有障礙區域，另一邊則沒有障礙
區域，利用這些切線我們可以圍出一塊具有克障效果
的 Region，在這 Region 中，任意的位置都能以直線的
方式直接連接至 I、J 及 K。切線的計算方法如下，，
ICi可以利用 Proxy Node 中所收集到其他 Sub-Tree 的資
訊及 BN 資訊，來計算 J 、K 與 BN 所圍區域相切的切
線 LJ1、LK1，可得 LJ1、LK1 相交和交於三角形的交點：
LJ1與 IK 的交點 J1、LK1與 IJ 的交點 K1 及 LJ1與 LK1相
交的點 JK。以上所找出的三個點再加上 I點，我們可得
到一組頂點{I,J1,K2,JK}具有克障能力的 Region。然
而，在尋找J、K切線與BN的切線時，所產生兩切線的
相交點及兩切線與三角形的交點，除了{I,J1,K1,JK}也
可能會另外找出另一組面積比 {I,J1,K1,JK}更大的
Region{I,J2,K2,JK‘}，面積較大的那一組 Region 會將障
礙區域包含進去，並不是具有克障能力之 Region，因
此我們會保留面積較小的那一組 Region，以進行後續
找 Share Region 的動作。 
        —  22 — 
比到 P 點多了大於 dk ⋅ 的路徑長度，而從 C 點到 Pi會比
到 P 點少了 d 的距離，整體而言 Pi連接三點 A、B、C
的路徑長會大於 P 所連接 A、B、C 三點的路徑長，當
Pi遠離 P 點時，α 角度會變小，其總路徑長會增加。在
圖(二十九)(b)中，我們令 P1 及 P2 為 AC 直線上的任兩
點，且P1較P2更近於P點，以下，以P點為圓心及 iPP
的距離為半徑畫圓，然後讓 Pi 在圓周上移動，其所對
應Qi點的軌跡也會在以Q點為圓心及 iPP 距離為半徑的
圓周上移動。由於通過 P 點之 CA' 直線是連結 ABC 三
點最短之邊長和，線段是會通過圓心 Q 與圓心 P，因為
Pi 點與 Qi 點在圓周上相對的關係位置固定相差 3π 的角
度，因此，無論 Pi 在圓周上任意的位置，其從 A’到 C
途中經過Qi點和Pi點的路徑長度皆會相同。對於圖六(a)
的證明中，可知越遠離 Steiner Point 的 Share Point，其
所建構 Share Tree 的 TL 會越少，而在圖六(b)的証明
中，我們可知與 Steiner Point 相差相同距離的 Share 
Point，其所建構的Share Tree具有相同的TL。結合以上
兩個結論，我們可知，挑選重建 Share Tree 的 Share 
Point Pi 越接近 Steiner Point 時，其所建立之 Share Tree 
的 TL 會 越 少 。                                                             
 
Share Point 與 Steiner Point 的距離會反應出 Share 
Tree 的重建成本，由 Theorem 1 的結果得知，Share 
Point距離Steiner Point越近，則Tree Topology路徑成本
會越接近 Optimum，因此，ICi 可以根據定理一找出它
與另兩個 Sub-Tree 之 Root 所找出的 Share Point，並儲
存起來。對 I 而言，因為有多種 Sub-Tree 的組合可與其
進行 Reconstruction，所以 ICi 會將每種組合及其 Share 
Point與Steiner Point的距離儲存起來 ，選擇Share Point
離 Steiner Point 最近的組合，進行 Reconstruction。如圖
四所示，從三個 Share Region 中，最接近 P 點的位置在
P3，並找出最靠近 P3 且座落於 Share Region 的 Sensor 
Node 當作 A 與 B、C 重新連接的 Share Point。 
(2) 樹的重建 
當 ICi挑選好 I 要連接的組合 J 及 K 後，隨之也找
出三點之間的 Share Point SP。ICi所挑選欲進行重新連
接的三點 I 、J 及 K 與 SP 皆能以直線路徑建立連結並
繞開障礙區域，因此 ICi能通知 I 以 Source 端的角色，
利 用 Location-Aware Routing 的 技 術 ， 發 送
RECONNECT_REQ封包給SP，再藉由SP把封包傳送給
其他兩個 Destinations J 及 K，以進行 Share Tree 的重
建。在傳遞的過程中，每個代傳者必須記錄前一轉送
者的 ID ，以利後續程序中重建 Share Tree 。當
Destinations J 及 K 收到 RECONNECT_REQ 後，將依照
原 本 RECONNECT_REQ 封 包 傳 送 的 路 徑 ， 把
RECONNECT_REP 封 包 回 傳 給 Source ， 在 回 覆
RECONNECT_REP 的 時 ， 各 個 Node 在 回 傳
RECONNECT_REP 封包前，會將先前記錄的代傳者設
定為下一個目的端的 Node，並認定其為自己的
Parent，而接受到 RECONNECT_REP 的 Node，會設定
前個來源端的 Node 為自己的 Child，當 I 收到
RECONNECT_REP 封包後，分割的 Sub-Tree 也重新連
接完成，而J及K所屬的兩個Sub-Tree，也將隨著Share 
Tree重建，一起合併到 Sub-Tree Ti裡，合併後 Sub-Tree 
Ti裡的成員資訊會再更新Proxy Node所儲存的資訊，以
保持重建 Share Tree 時，所使用資訊的正確性，避免建
立錯誤的資料收集樹。而整個資料收集樹的重新建立
連結程序，會重複執行 Faulty Tree Detection Phase 及
Tree Reconstruction Phase ， 直 到 所 有 被 分 割 的
Sub-Tree 重新合併成為一棵 Share Tree 才結束。如果最
後剩下的 Sub-Tree 只剩下兩個獨立的群組時，I 不需要
再找其他兩組要連結的 Sub-Tree，I 只要找出與另一
Sub-Tree Root 距離最近的 Leaf Node 來連接，即可完成
Share Tree 重建的工作。  
Sensor
Sink
Source
Border
Share Point
D2
D4
D3
D1
D5
D6
SP1
P1
Proxy Node
P2
D S
P
Q
R
C
J
H
圖(三十)：Reconfiguration 
延續圖(二十四)中障礙區域分割 Share Tree 的結
果，我們以圖(三十)來說明重新連接的動作，並將演算
法表示如圖(三十一)。資訊收集者 C,D,E,G,H,J 會先進
入Random Backoff等待一段時間， C因為其Tree Level
最低且 ID 比 D 小，所以 C 會先醒來並計算出進行重建
的組合，資料收集者 C 會試以自己所屬 Sub-Tree 中的
Leaf Node D1、D2的任一點，在此我們以D1為例，並從
其他 Sub-Tree Root D3、D4、D5 及 D6任意選出兩點進
行配對組合併計算其 Share Point，，在此我們以 D4 與
D6為例，最後會在組合 {D1,D4,D6}中依上述Share Point
章節中所敘述的運算找出的Share Point P1，資訊收集者
C 會通知 D1發送 RECONNECT_REQ 給 P1，再透過 P1
發送RECONNECT_REQ給D6 及D4後，D6及D4將依照
原路徑回覆 RECONNECT_REP 封包給 D1，在回覆的過
程中，D4知道自己要回傳的下一個點為R，所以會先設
定 R 為 Parent ， 而 在 R 收 到 來 自 於 D4 的
RECONNECT_REP 封包時，R 點會設定 D4 為自己的
Child，R 會繼續將封包往 D1 的方向傳遞，途中也是以
相 同 的 方 式 建 立 Parent 與 Child 關 係 ， 當
RECONNECT_REP 封包送達 D1時，原本與 Sink 分離的
兩個點 D6及 D4會重建在同一棵 Share Tree 裡，資訊收
集者 C 重建的 Sub-Tree 資訊，會再利用 Proxy Node 更
新並分享給所有資訊收集者知道，在下個回合 C 在
Random Backoff 結束後，會以相同的方式先找出最佳
的重建組合 {D3, D4, D5}，並以共享點 P2將 D3、D4及
D5 連接起來，連接完畢後，所有受障礙區域影響的
Source 重新連接起成為一棵新的 Share Tree，可以繼續
進行資料收集的工作。 
        —  24 — 
A 1
A 2
s1
s2
圖(三十四)：以 A1為 Root 所形成的 Border Nodes。
A 1
A 2
s1
s2
圖(三十五)：以 A2為 Root 所形成的 Border Nodes。
A 1
A 2
圖(三十六)：最後形成的 Border Nodes 與其所組成
包圍障礙物的外框。 
B. 具Bounding Box位置資訊下的障礙物偵測與電量
平衡之繞徑協定 
在本章節中，我們將討論在一個 WSN 環境下，由
裝備方向性天線的 Mobile anchor 行走於感測網路中，
來賦予各個 Sensor 基本之位置資訊，亦即 Bounding 
Box。我們研發一可達到電量平衡之克障繞徑協定，並
在下面分成兩部份討論。 
 (A) 電量平衡之機制 
為了節省電量之消耗，我們擬將網路環境切割成
由多個區塊組成之場景，並且每個區塊在同一個時間
只會有一個當前電量最多之 Sensor 在活動，而其餘電
量較低之 Sensor 則不工作，如此將可延長網路之生命
週期。接下來，我們將討論分割網路場景的方法。 
考慮 Bounding Box 為一方形區域，若是我們可以
在替 Sensor 時，也可以順便將網路場景切割成由多個
區塊組成之環境，則將可以省下許多 Sensor 間之通訊
的成本。在先前關於 Bounding Box 的研究中，其作法
為使用裝備有GPS 的Mobile Anchor 在一塊佈有 Sensor 
的區域內活動，且在某些位置發送 beacon 以廣播其當
前的座標位置，beacon message 的發送可視為一個虛擬
的Static Anchor。若Sensor 接收到beacon 為(x, y) 的訊
號，且通訊半徑為 r，則此 Sensor 位於 Mobile Anchor 
的通訊圓中，因此 Sensor 便可定義出自己所在的區域
為(x-r, y+r) 、 (x+r, y+r) 、 (x-r, y-r) 和(x+r, y-r) 四個
點所圍成的矩形區域裡。當 Sensor 收到 Mobile Anchor
發送的不同座標的訊號時，又可以定義出另外一個區
域。於是，Sensor 便可計算出自己位於兩個區域的交
集區中。然而，為了簡化計算及表示方式，大部份的
研究將 Mobile Anchor 廣播的範圍由恰好包含住圓形區
域的最小方形來表示。而在我們所提出之演算法中，
我們將以上述方法搭配方向性天線，如此，可更加地
縮小 Sensor 所擁有之 Bounding Box Size 且 Mobile 
Anchor 之行走路徑也可減少。然而，用傳統方式賦予
Sensor 之 Bounding Box 之形狀並無法滿足我們欲將網
路環境切割的目標。但是，若是使用裝備方向性天線
之 Mobile Anchor 則可順利解決此問題。 
如圖(三十七)所示，Mobile Anchor b 配置方向性
天線將其傳輸範圍切成四個區域 R1, R2, R3, R4。以
Sensor s 來說，由於 Sensor s 位於 R3中，所以 R3即為
Sensor s 之 Bounding Box。然而，以 Mobile Anchor b 
目前的位置來看，Sensor s 無法接收到 Mobile Anchor b
所傳輸之訊息，因此，Mobile Anchor b 勢必在未來將
會移動置 p1, p2, p3, p4 四個位置以幫助位於灰色區域中
之 Sensor 定位。 
R 1 R 2
R 3 R 4
p1 p2
p3 p4
s
b
 
圖(三十七)：Mobile Anchor b 配備方向性天
線，將傳輸範圍切成四個 Regions，分別為 R1, 
R2, R3, R4。 
當 Mobile Anchor 以上述方式替 Sensor 定位之
後，每個 Sensor 都擁有自己的 Bounding Box，而這些
Bounding Box 將可以把監控區域均勻的切割成多個方
形區塊。我們令 Cu, Cd, Cr, Cl 為上、下、左、右四個鄰
居區塊。而封包傳遞的方式為由某個區塊傳遞至其鄰
居區塊，依此類推，最後可將資料傳遞至目的區塊。
其中，為了儘可能縮短資料傳輸路徑，代傳封包之
Sensor 將選擇離目的區塊最近的鄰居區塊為下一個傳
送對象。如圖(三十八)所示，若 s1欲傳送資料至 s2，則
s1 將有兩個區塊 C1 和 C2 可以選擇，因為此兩個區塊
均為 s1 鄰居區塊中離 s2 較近的區塊。再來，若 s1 欲
傳送資訊給 s3，則 s1 將選擇其鄰居區塊中唯一離 s3 最
近的區塊 C2。 
        —  26 — 
cell 而轉換成 Energy Balancing Mode。第二種情況，目
的地位於 Ci 旁之 Forbidden cell。在此情況下，Ci 和 Cj 
之 failure vector 是不相同的，代表Ci 和Cj 圍繞著同一
個 Forbidden cell。圖(三十九)中包含了上述兩種情況，
若 Sensor s1 欲傳送封包給 Sensor s2，則封包傳送路徑
遇到的第一個 dead end 為 C1，此時封包傳送狀態將轉
換成 Bypassing Mode。當封包接下來被傳送至第二個
dead end C2，此時條件符合上面所敘述之第一種情況，
因此此時封包傳送狀態將回復至 Energy Balancing 
Mode。當封包傳送狀態在 C2 時為 Energy Balancing 
Mode，則將會再次把狀態轉換成 Bypassing Mode。當
dead end C4在封包傳送狀態 Bypassing Mode 下收到封
包，此時符合上述第二種情況，C2 和 C4 之 failure 
vector 是不相同的。為了不增加封包大小，我們接下
來採取下面的處理方式。 
假設 Permitted cell Ci 在 Bypassing Mode 下傳送一
個封包至 dead end Cj。當 Cj 收到來自 Ci 之封包後，Cj 
檢查若以逆時針方向旋轉 i jC C 後，第一個遇到的區塊
是否為其候選區塊。若是，則 dead end Ci 之 failure 
vector 和發起 Bypassing Mode 之 dead end 的 failure 
vector 是不同的。如圖(三十九)所示，當 dead end C4 在
Bypassing Mode 下收到來自 C7 之封包，則 C4 以逆時
針方向旋轉 7 4C C ，因為第一個遇到的區塊為 dead end 
C4 之候選區塊，因此，C4 可判斷目的地位於其身旁之
Forbidden cell ，且此時將封包傳送狀態轉換成 Greedy 
Mode。 
在 Greedy Mode 中，區塊中必須至少包含一個
Sensor，如此才可視為一個 Permitted cell。因此，我們
定義 G-permitted cell 為在 Greedy Mode 狀態下的
Permitted cell，而 G-forbidden cell 代表沒有任何 Sensor 
位於其中的區塊。在 Greedy Mode 下的封包傳送類似
於 Energy Balancing Mode。若是所有的候選區塊均為
G-forbidden cell，則封包傳送狀態將從 Greedy Mode 轉
換成 Boundary Mode 且封包中紀錄轉換型態時的座標
位置。 
封包將在 Boundary Mode 下沿著 G-forbidden cell 
前進，如此可避開障礙物的阻礙。G-permitted cell 選
擇下一個代傳區塊的方式類似 Bypassing Mode。一旦在
Boundary Mode 下收到封包，G-permitted cell 會檢查
它是否比封包中紀錄的座標更為靠近目的地，若是，
則封包傳輸模式將轉回 Greedy Mode。 
圖(四十)為一封包傳輸路徑由 Permitted cell 至
Forbidden cell 之範例，Sensor s1 欲傳送資料給 Sensor 
s2，當封包傳至 C1 時將無法順利找到一個代傳區塊，
此時，封包傳輸模式將由 Energy Balancing Mode 轉換
為 Bypassing Mode。當 C2 接收到在 Bypassing Mode 狀
態下的封包時，會再次更改封包傳輸模式至 Greedy 
Mode，因為此時已經可以得知目的地位於 Forbidden 
cell 中。之後， C2 發現它所有的候選區塊均為
G-forbidden cell 。因此，封包傳輸模式將更改為
Boundary Mode 且會將 C2 所在之位置資訊紀錄至封包
內。當封包抵達 C3 後，封包傳輸模式將再次改回
Greedy Mode，因為 C3 比 C2 更加靠近目的地。 
C1
s1
C2
s2
C3
(G-)forbidden cell
(G-)permitted cell
Forbidden cell & G-permitted cell
 
圖(四十)：封包傳輸路徑為由 Permitted cell 至
Forbidden cell 之範例。 
(4) Forbidden Cell 至 Permitted Cell 之傳輸 
在接下來的 (4).和 (5).小節中，我們將討論起始
Sensor 均位於 Forbidden cell 中，這種情況一開始的封
包傳輸模式為 Greedy Mode。若所有的候選區塊均為
Permitted cell，此種情況我們定義為封包是由 Forbidden 
cell 傳遞至 Permitted cell。因此，封包傳輸模式將轉換
為 Energy Balancing Mode 且接下來就是 Permitted cell
至 Permitted cell 之間的問題。 
(5) Forbidden Cell 至 Forbidden Cell 之傳輸 
此種情況之處理方式與 (3). 當封包傳遞進入
Forbidden cell 相同。因此，在此我們就不在贅述。 
(6) 狀態轉換圖  
Energy
Balancing
Mode
Bypassing
Mode
Boundary
ModeGreedy Mode
(4)
(1) (2) or (3)
(5) (6)
(7)
(1) Arrives at a dead end
(2) All forwarding candidates are permitted cells and don’t contain the sender
(3) The failure vector is same as previous direction
(4) The failure vector is different from previous direction
(5) All forwarding candidates are permitted cells
(6) All forwarding candidates are G-forbidden cells
(7) The current location is closer to destination than the node which switches
the routing mode from Greedy to Boundary
圖(四十一)：本演算法之狀態轉換圖。 
 
圖(四十一)描繪出我們所提出之演算法的狀態轉換
圖。一開始封包傳輸模式根據起始點之所在位置而決
定是為Greedy Mode 或是Energy Balancing Mode。若起
始點位於 Forbidden cell，則封包傳輸模式由 Greedy 
Mode 開始，否則將從 Energy Balancing Mode 開始。
而 Bounding 和 Greedy Mode 是在 Forbidden cell 中傳
送封包時使用。在本演算法中，資料封包中必須有一
個 field 用以儲存當前封包傳輸模式。若封包傳輸模式
為 Boundary Mode，則另外一個需要增加的 field 為儲
存位置資訊的地方。其中所指之位置資訊為封包傳輸
模式由 Greedy Mode 轉換成 Boundary Mode 之位置。 
 
        —  28 — 
(→) 是定義 interfaces 間的關係，在箭號左邊的
Component 使用(uses)此 interface，位於箭號右邊的
component 則提供(provides)此 interface，假若箭號右邊
未將所 provides 的 interface 列出，則 nesC compiler 
default 值預設為與箭號左邊所使用的 interface 相同。
Configuration 完成後，開始著手撰寫 Module 部分的程
式 ， 亦 即 在 程 式 中 說 明 如 何 實 際 操 作 先 前 在
Configuration 所宣告的元件 (component)的程式碼，
nesC 使用 Module 的方法，為分別宣告此 Module 所提
供與使用的 interface，以便程式順利執行，在撰寫
Module 中 implementation 部分時，需先查看 Module 宣
告哪些 interface，而這些 interface 定義哪些函數
(function)，才能得知將要實作哪些函數，在圖(四十六)
的例子中，實作 init()、start()、stop()三個 command 是
由於此 Module 提供 "Std Control" interface，而實作
fired() event 是 由 於 這 個 Module 使 用  "Timer" 
interface，所以必須實作 fired() event。 
//Blink.nc
Configuration Blink {
}
implementation {
components Main, BlinkM, SingleTimer, LedsC;
Main.StdControl -> BlinkM.StdControl;
Main.StdControl -> SingleTimer.StdControl;
BlinkM.Timer -> SingleTimer.Timer;
BlinkM.Leds -> LedsC;
}
圖(四十五)、Configuration 程式實例片段。 
//BlinkM.nc
module BlinkM {
provides {
interface StdControl;
}
uses {
interface Timer;
interface Leds;
}
}
implementation {
command result_t StdControl.init() {
call Leds.init();
return SUCCESS;
}
command result_t StdControl.start() {
return call Timer.start(TIMER_REPEAT, 1000) ;
}
command result_t StdControl.stop() {
return call Timer.stop();
}
event result_t Timer.fired() {
call Leds.redToggle();
return SUCCESS;
}
}  
圖(四十 )、Module 程式實例片段。 
有了上述nesC的基本概念之後，利用這些 Interface，我
們可以快速編寫出我們所需之應用程式。在此說明幾
個重要之 interface—Clock為一種Hardware interface，其
主要之 command為 setRate，即為設定Clock每秒有幾次
之反應，一旦到達設定之間隔時間，便觸發這項事
件，如此我們在設計感測點數據收集之應用程式時，
將會實作此 Clock 之 interface，以達到定時取得環境變
化數據之目的。另外，在我們所使用 Mote 模組時，還
提供了三個分別為紅、黃、綠之 LED 燈，這三個 LED
燈也有相對的 interface可供實作使用，即為Leds，我們
可以實作此 interface，分別控制三個 LED 燈。而 Mote
模組中和無線通訊有關之功能，在此也有 interface 可以
使用，即為接收資料之 ReceiveMsg，和傳送資料之
SendMsg，在此較特別的是ReceiveMsg只有 events之函
數，沒有 command 之函數在其中。還有一個和感應器
有關之 interface 為 ADC，其意為 Analog to Digital 
Converter，一般感應器之感應動作是形成類比信號，
如此之數據不易使用來參考比對，因此要轉成數位信
號才易於傳送及處理。 
在此簡單的介紹一些本計畫使用的元件： 
A. 無線通訊程式實作 
1. IntToRfm：是一個從 IntOutput interface 中接收
Output 值，再經由無線傳輸將其值以廣播的方式傳輸
給其他 Mote 的元件。在 IntToRfm Module 中，nesC 將
傳送訊息的資料型態宣告為 IntMsg，包含兩個欄位，
一欄位用來放置資料值，另一欄位則放置此訊息的傳
送的來源端位址，在傳送資料的同時會以接收端位址
與資料大小以及資料值為參數呼叫 Send.send()函式，
將資料傳給接收端的 Mote。IntToRfm Module 使用一
個 pending flag 來檢視暫存區的狀態，假若前一個訊息
資料還處在傳送階段，我們不能更改暫存區內的值，
此時將不會送出新的訊息，並回傳 FAIL 值；假若目前
傳送暫存區是空的，則可以將訊息載入暫存區中並傳
遞此訊息。在 TinyOS 中，無線通訊傳輸採用 Active 
Message 的模式，即為在網路中每個封包都有一個
Handler ID 交給接收端的 Mote 處理，此 Handler ID 位
於封包內的標頭欄位中，我們可將此 Handler ID 視為
一個數字或是 Port Number，一旦訊息被接收端接收
後，根據不同的 Handler ID 將會有相異的 event 被觸
發，而不同的Motes收到相同的Handler ID亦有可能觸
發不同的 event。 
2. RfmToInt：我們利用 ReceiveMsg Interface 中宣
告的 receive()的 command 函數，透過一個指標觸發
event 來接收資料。在 TinyOS 中記憶體管理對於接收
進來的訊息將會以動態的方式管理，一個訊息抵達接
收端 Mote 後會被擺放至暫存區中，此時 Active 
        —  30 — 
的地方有很明顯的曲線差，表示 sensor node 因為光的
亮度不同，感測的資料也不同。再來，我們利用燈光
照射 sensor node，所以 sensor node 會感應到強烈的光
源，如圖中標示(2)的地方，這段的曲線數值會較高。 
我們在傳輸實作當中，利用 sink node 和 sensor 
node 來做距離的測試，我們讓 sensor node 慢慢遠離
sink node並且觀察傳輸的過程。如圖(五十一)所示，當
sensor node 與 sink node 在距離五公尺之內的範圍，
sensor Node 和 sink node 皆能夠傳輸資料，然而當超過
這個範圍後，如圖(五十一)中藍色標示的部份，sink 
node 就逐漸接收不到資料，甚到 sink node 已收不到資
料，表示 sensor node 已經無法將資料傳輸回給 sink 
node。 
1
2
 
圖(五十)、Oscilloscope 對光感應的實作。 
 
圖(五十一)、Oscilloscope 對 sensor node 傳輸實作。 
(二) 感測定位之實作 
此實作環境如下：我們利用 Mobile Sensor 採用隨機
的移動方式去幫助感測點定位，Mobile Sensor 從 GPS 
接收位置資訊並利用自己的通訊範圍去定義一個的位
置範圍，Mobile Sensor 會把這個位置範圍放在封包內
並定期發送給週遭的感測點進行定位，在 Mobile 
Sensor 進行完第一次的定位後，整個感測點的位置資訊
會如圖(五十二)所示。 
圖(五十二)、MicaZ 實作場景示意圖。 
為了達到上述目標，本計畫藉由多個 Mote MicaZ 模
組形成感測網路，並利用 Mote MicaZ 模組組裝而成的
自走車形成 Mobile Sensor。以下我們分別對 Mobile 
Sensor 以及 Static Sensor 的設計成果進行說明。 
A. Mobile Sensor 的程式實作 
我們利用具備 GPS 位置資訊的自走車作為 Mobile 
Sensor 來進行定位，其中 Mobile Sensor 的元件有
MicaZ 、MicaZ Connector、Motor Control Integrated 
Circuit、Motor、Power Unit、Location Generator 等元
件，如圖(五十三)所示。 
MicaZ MicaZ
Connector
Motor Control
Integrated Circuit
MotorPower UnitLocation 
Generator
圖(五十三)、自走車組成架構組件。 
 
圖(五十四)、自走車廣播模組設計架構圖。 
        —  32 — 
MICA2 作為無線電通訊的平台，MICA2 的中央處理器
是 ATmega128L，運算速度為 8 MHz。這個微處理器是
低電量的 AVR 8-bit 處理器，含有 128Kbytes 的快取記
憶體、4 Kbytes 的 EEPROM 與 4 Kbytes 內部 SRAM。
MICA2 使用 Chipcon 公司的 CC1000 單晶片無線電收發
器，有433MHz與915 MHz兩種的使用頻率可供選擇，
使用兩個 AA 電池供電，最長存活時間可達一年以上。 
而作為資料收集者的 Stargate Gateway 使用 Intel 公
司的 RISC 中央處理器：PXA255, Xscale 400MHz，並
且使用  StrongARM 晶片 SA1111，擁有 64MB 的
SDRAM 和 32MB 的 FLASH，對外的連接埠包括
Ethernet、Serial、 JTAG、USB、PCMCIA、Compact 
Flash 等等，使用鋰電池作為供電。至於我們所使用的
Serial Gateway：MIB510，不僅可將 Motes 的資料格式
轉換為 RS-232，我們也使用它來燒錄 MICA2 的韌體，
支援的 Mote 有 IRIS、MICAz 及 MICA2。 
另一方面，我們使用的視訊監控攝影機是 D-Link
公司所生產的無線網路攝影機 DCS-5300G，支援
802.11g 並且內建一埠 RJ-45 10/100Mbps 乙太網路介
面，充分保證了音頻、視頻等等，對時間敏感數據的
及時、穩定傳輸，確保遠程監控的同步性與實時性，
並且支援 HTTP、 FTP、 TCP/IP、UDP、 SMTP、
DHCP、Telnet、NTP、DDNS、UPnP、DNS 等多種通
訊協定，可以使用 FTP 或是 E-mail 定期將影像傳輸更
新至伺服器，還可使用 Web 介面得到即時監控的影像
畫面，若搭配監控軟體更可以同時控管 16 臺設備。 
A. 系統軟體架構 
在整個監控系統的實作中，最核心的部份有包括
Motes 光感應感測器中的感應及通訊、Stargate 中的資
料收集與接收、Stargate 的事件位置計算及 CCD 的轉動
與錄影操控。如圖(六十)所示，作為感測環境光度的
MICA2，使用其內部的計時器，每隔一固定的時間便
驅動光感應元件感測目前光度，並透過無線電發射器
傳送出去。而接收端感測器接收到來自無線電的資料
後，將資料內容轉換為 UART 格式輸出。在 Stargate 
Gateway 接收資料前，先透過 Serial Gateway 的硬體處
理，將 UART 資料以 RS-232 介面輸出。Stargate 
Gateway 便能接收來自 RS-232 的資料，進行資料分析
及計算處理後，決定攝影機的轉動或攝影等行為，並
透過 Ethernet 發送控制指令給予攝影機。 
 
圖(六十)無線感測網路監控系統軟體架構 
MICA2 是可程式化的單晶片平台。美國加州大學
柏克萊分校(UC Berkeley)針對 MICA2 設計 TinyOS[11]
這套嵌入式作業系統，與 nesC(network embedded 
system C)[12]程式語言， nesC 程式語言的架構與語法
跟一般我們使用的 C 語言擁有類似的架構與指令；而
Stargate 使用的作業系統為 Linux，核心版本為 2.4.19，
並且支援大多數的 Debian[13]公用程式，支援 jffs2、
ext2、ext3、vfat及msdos 檔案格式；由於是Linux的核
心，所以大多數的程式語言都能夠在此平台運行，而
我們選擇了執行速度較快速，適合嵌入式系統的 C 語
言。我們結合 C、nesC 和 TinyOS，分別開發我們所需
要的功能與協定，並載入到監控系統的硬體中。 
B. 光感應感測器中的感應及通訊 
在監控系統中，光感應感測器的任務是取得環境
光度，並以無線電的方式往 Stargate 傳送。 
在實作的過程中，我們預設光感應感測器一開始
是處於黑暗狀態。我們設計了一個模組 SenseToInt，其
作用是從感光器上取得光度的數值，並控制所有元件
的運作。我們為了達到省電及即時性，我們使用內部
的計時器 TimerC 元件，使其每 250ms 觸發一次事件發
生，當事件發生時，從 DemoSensorC 取得光度，並透
過 ADC(Analogue-to-Digital Converter)介面將類比訊號
數位化後，分析其數值大小；若數值超過黑暗與光亮
狀態的臨界值，便透過 IntOutput 將數值傳遞給
IntToLeds 及 IntToRfm 元件，並將目前狀態設定為光亮
狀態；若目前環境已處於光亮狀態，則是判斷環境是
否轉為黑暗狀態，若數值比黑暗臨界值來的小，則將
數值傳遞給 IntToLeds 及 IntToRfm元件，並將目前狀態
設定為黑暗狀態。 
顧名思義，IntToLeds 元件是取得數值的最大的
3-bits顯示於感測器的LED上，而 IntToRfm元件則是將
        —  34 — 
圖(六十三)、PC 端上所顯示的波形圖 
event TOS_MsgPtr DATAreceive.receive( TOS_MsgPtr m )
{
call Leds.greenToggle( ) ;
struct OscopeMsg *pack1 , *pack2 ; 
atomic
{
pack1 = ( struct OscopeMsg * )m -> data ;
pack2 = ( struct OscopeMsg * )mg . data ;
pack2 -> channel = pack1 -> channel ;        
pack2 -> lastSampleNumber = pack1 -> lastSampleNumber ;
pack2 -> x = pack1 -> x ;
pack2 -> y = pack1 -> y ;
pack2 -> sourceMoteID = pack1 -> sourceMoteID ;
for ( i = 0 ; i < 10 ; i++ ) {
pack2 -> data[i] = pack1 -> data[i] ;
}
call DataMsg.send ( source , sizeof ( struct OscopeMsg ) , &mg ) ;
return m;
}
圖(六十四)、Sensor 感測實作程式片段 
(B) Sensor Node 至 Sink 通訊協定實作 
圖(六十五)為當Sensor Node收到Sink Node的感測
命令後，將所感測的資料透過無線傳輸傳回至 Sink 
Node 的實作。為使 Sink node 可順利獲取 sensor node 所
感測的資料，我們利用NesC在 Sensor Components上所
提供的GET_DATA Command來讀取感測值，之後再透
過 ADC Interface 將類比感測資料轉換成數位感測資料
並儲存起來，最後當我們欲讀取感測資料時，則利用
Sensor Components 上的 DATA_READY Command 來讀
取感測資料。另外，我們也發展程式使 Sink Node 可週
期性地讀取 Sensor Node 的感測資料時，我們實作
CLOCK Component 來設定週期時間以作為啟動觸發感
測動作的事件。 
    當 Sensor Node 要將這些感測資料回傳給 Sink Node
時，便透過網路傳輸模組，如 IntToRfm Module、
RfmToInt Module及Broadcast Module，並搭配我們設計
的 Routing 協定來決定回傳資料的路徑。 
task void forwarder() {
call SendCmdMsg.send(TOS_BCAST_ADDR, 8, msg);
}
event result_t SendCmdMsg.sendDone(TOS_MsgPtr pmsg, result_t status) {
if (status == SUCCESS) bcast_pending = 0;
return status;
}
command result_t StdControl.init() {
msg = &buf;
bcast_pending = 0;
lastSeqno=0;
call CommControl.init();
return rcombine(call ADCControl.init(), call Leds.init());
}
command result_t StdControl.start() {
return call Timer.start(TIMER_REPEAT, 500);
}
command result_t StdControl.stop(){
return (rcombine(call CommControl.stop(),return call Timer.stop());
} 
inline char is_new_msg(struct SimpleCmdMsg *bmsg) {
if (bcast_pending) return 0;
return (((bmsg->seqno - lastSeqno)>0) ||((bmsg->seqno+127)<lastSeqno) ) ;
}
inline void remember_msg(struct SimpleCmdMsg *bmsg) {
lastSeqno = bmsg->seqno; 
bcast_pending = 1; 
}
event TOS_MsgPtr ReceiveCmdMsg.receive(TOS_MsgPtr pmsg){
TOS_MsgPtr ret = msg;
result_t retval;
struct SimpleCmdMsg *data= (struct SimpleCmdMsg *)pmsg->data;
if (is_new_msg(data)) {
remember_msg(data);
retval = call ProcessCmd.execute(pmsg) ;
ret = msg;
msg = pmsg;
}
msg=query(pmsg); 
retval = call ProcessCmd.execute(msg) ;
return ret;
}
event result_t ProcessCmd.done(TOS_MsgPtr pmsg, result_t status) {
msg = pmsg;
if (status) {
post forwarder();
} else {
bcast_pending = 0;
}
return SUCCESS;
} 
圖(六十五)無線傳輸實作 
(C) 控制 CCD 轉動實作 
圖(六十六)為建立與CCD的 socket連線程式片段，
連線到 CCD (IP:192.168.0.120)時，需要登入使用者帳
號密碼，故在每一筆封包所傳遞的內容中，都已經包
含帳號密碼的資訊。而控制 CCD 轉動的封包格式分為
依鏡頭向上、下、左、右、旋轉、擷取目前畫面等
等，均先寫為 Function 供程式呼叫使用。 
void HOME(int sock,struct sockaddr_in addr)
{
if((sock=socket(PF_INET,SOCK_STREAM,0))<0)
die("socket");
addr.sin_family=AF_INET;
addr.sin_addr.s_addr = inet_addr("192.168.0.120");
addr.sin_port=htons(80);
if(connect(sock,(struct sockaddr *)&addr,sizeof(addr))!=0)
die("connect");
write(sock,home,sizeof(home));
close(sock);
printf("HOME\n");
}
        —  36 — 
 
圖(六十七)、六種方法的 Network Lifetime 比較。 
 
圖(六十八)、三種 energy-balanced schemes 在不同
佈點 densities 的 network lifetime 比較。 
 
圖(六十九)、Hybrid 方法在不同佈點 densities 的
network lifetime 比較。 
 
B 模糊位置下繞境演算法的效能 
實驗模擬的部份，我們假設的環境是由 Sink與 Static 
sensor node 所組成，每個 sensor 可由[1][2]的方式得到
一模糊位置資訊ELR，並且定期的廣播自己的 id與ELR
資訊。爲了檢視本報告所提出的錯誤位置偵測與修正
技術及分散式繞徑技術的效能，在網路初始建立之
後，隨機的讓環境中的 sensor 將感測資料傳至 Sink。並
且利用所提出的方式與 GPSR、Flooding 等方法比較。 
 
圖(七十)、不同點數之下的 Packet delivery ratio。 
首先我們比較在不同點數的情況之下三種方法的
Packet Delivery Ratio。如圖(七十)所示，根據實驗我們
看到delivery ratio在點數300個點時因為網路有partition
的情況造成 99%的 delivery ratio 之外，其他點數的情況
皆能夠將封包正確的送達至 Sink。而 GPSR 是利用每個
sensor 的 ELR 區域中心點當成虛擬位置，因此在建立
Face 的過程會因為錯誤的虛擬座標建立錯誤的 Face，
造成 GPSR 在傳送封包的過程因為無法轉換到正確的
Face 而降低了傳送成功的機率。點數較多的情況之
下，可利用 Greedy Forwarding 的 sensors 也增多，因此
點數較多的情況之下，GPSR 的 delivery ratio 有提升的
效果，但由於建立錯誤的 Face，因此還是會傳送失
敗。 
 
圖(七十一)、不同點數之下的 End-to-end delay。 
圖(七十一)主要是比較三個方法的 End-to-End 
delay，同樣的，由於GPSR會因為建立錯誤的Face，導
致 sensor 必須繞較長的路徑才可將封包送達 Sink，繞徑
長度增加將使得封包傳送到的 hop 數與時間都相對的增
長， 而這種狀況在點數較多的情況中，GPSR 可以利
用 Greedy Forwarding 代傳的點數相對的提高，而不用
利用 Face Routing 進行封包的傳送，因此 GPSR 可以降
低傳送時的 delay time。而我們的方法不管任何點數，
可以找到跟Flooding相似的傳送路徑，因此我們的結果
跟 Flooding 的結果相似。 
C 礙物環境下克障廣播演算法的效能 
        —  38 — 
DCS-based 的方法，除了 Sink Node 不需利用 Flooding
的方式傳送Query Packet外，因為只有Sink Nodes 查詢
的 Data-Centric Nodes 會週期性回傳資料，因此 Total 
Messages 並不會受到查詢的事件型態數目影響太大。
其中，在 Query 的事件型態數目較少的情況下，因為每
個 Sink Node 查詢的事件型態一樣的機率低，因此
D-DCS 及 D-DCSS 效能將與 DCS 相同。但是，當每個
Sink Nodes 能 Query 的事件型態數目超過 3 個之後，因
為 Sink Query 的事件型態會相同，此時將會有
Data-Centric Nodes 開始收到兩個以上的 Queries。而
D-DCS 及 D-DCSS 則 會 開 始 評 估 是 否 要 改 變
Data-Centric Node至較佳的儲存位置。因此，D-DCS 及
D-DCSS在Query事件型態較多的情況下Total Messages
較 DCS 少。而 D-DCSS 因為在週期性回傳資料至 Sink 
Nodes 時，又採用 Data-Centric Routing Mechanism 的
Shared Paths，因此又可減少資料重複的傳送，所以
D-DCSS 的 Total Messages 在 DCS-based Mechanisms 中
表現最好。 
0
50000
100000
150000
200000
250000
300000
350000
400000
1 2 3 4 5 6 7 8 9
Queries (per sink)
To
to
al
 M
es
sa
ge
s
LS
ES
DCS
D-DCS
D-DCSS
 
圖(七十四)、Total messages, vary number of queried 
event types 
圖(七十五)為 Hotspot usage 的結果，因為週期性回
傳資料的關係，雖然 ES 在 Queried 事件型態較少的時
候，Hotspot usage 較高，但當 Queried 事件型態數目漸
漸增加時，在 LS 中，幾乎大部分的 Sensor Nodes 皆在
回傳資料，所以Hotspot usage將超越ES。而DCS-based 
Mechanisms 仍不受 Queried 事件型態數目的影響，而
D-DCS 及 D-DCSS 在 Queried 事件型態數目大於 3 之
後，因為將 Data-Centric Nodes 轉換至較好的儲存位
置，所以亦分散了 DCS 中的 Data-Centric Node Hotspot 
usage。另外，因D-DCSS在回傳資料時採用Shared path 
routing，因此對於多個 Sink Nodes 的資料封包可能共享
同一個資料封包，故可減少 Data-Centric Node Hotspot 
usage。 
 
0
1000
2000
3000
4000
5000
6000
7000
8000
1 2 3 4 5 6 7 8 9
Queries (per sink)
m
ax
 (m
es
sa
ge
s p
er
 li
nk
)
LS
ES
DCS
D-DCS
D-DCSS
 
圖(七十五)、Hopspot usage, vary number of queried 
event types 
圖(七十六)中，由所有 Sensor Nodes 的 Traffic
標準差來看，可看出整個網路的 Power Balance 狀
況。LS 在 Queried 事件型態數目小的情況下，整個
網路流量差異性會比 ES 小很多，但是當 Queried 事
件型態數目愈大時，則會因每個Sensor Node感測到
的事件資料不同而回傳資料的頻率亦不相同，因此
差異性愈大。而 ES並不受 Query的影響，所以差異
性始終保持水平線。對於 DCS-based Mechanisms 而
言，網路的 Power Balance 較佳，因為將流量分散在
各個 Data-Centric Nodes 上，而 D-DCS 及 D-DCSS
又因為會改變 Data-Centric Nodes，所以又將
Data-Centric Nodes 的流量分散。因此可達到更好的
Power Balance 效果。另外，因為 Data-Centric 
Routing Mechanism 能降低 Data-Centric Node 的重複
封包之流量，因此對 Power Balance 也有間接的效
果。 
0
50
100
150
200
250
300
350
400
1 2 3 4 5 6 7 8 9
Queries (per sink)
ST
D
EV
LS
ES
DCS
D-DCS
D-DCSS
 
圖(七十六)、STDEV, vary number of queried event 
types 
        —  40 — 
 
圖(八十二)、mobile sensor 以隨意移動的方式定位的
模擬成果。 
 
5.3. Lego Robot 實作 
   本計畫以 LEGO MINDSTORMS NXT 機器人進
行實作，以下將詳細講解實作內容。 
(一) LEGO MINDSTORMS NXT 介紹 
    LEGO MINDSTORMS NXT是知名玩具廠商樂高公
司在2006年推出的新一代智慧型機器人開發套件，能
讓使用者從組裝機器人結構開始，自行決定所需要元
件，再配合圖形介面的開發工 
具來撰寫操作的應用程式，並以此應用程式控制機器
人模型的動作。 
圖(八十三)、LEGO MINDSTORMS NXT 機器人元
件 
圖(八十三)為LEGO MINDSTORMS NXT上的各個元
件，其中包含了 
 NXT 可程式積木： 
   NXT可程式積木為LEGO MINDSTORMS NXT機器
人最重要的核心元件，其包含有四個輸入端（用來連接
感應器）、三個輸出端（用來連接伺服馬達），以及一
個USB 連接埠（連接電腦用）。除了使用USB 連線，
NXT 可程式積木也可以透過藍芽通訊協定連接至個人
電腦。表格(四)為NXT可程式積木的硬體規格: 
表格(四)、NXT 可程式積木硬體規格 
硬體項
目 說明 
微處理
器 
32 位元 ARM7 微處理器 
256 Kbytes FLASH, 64 Kbytes 記憶體 
輔助處
理器 
8 位 AVR 微控制器 
24 Kbytes FLASH, 512 Byte 記憶體 
通訊方
式 USB 與藍芽無線通訊傳輸 
輸入端 4 個 (可連接聲音、光源、超音波與觸碰感應器) 
輸出端 3 個 (可連接燈泡與馬達) 
顯示設
備 100×64 像素 LCD 面板 
聲音輸
出 
8 KHz音效品質。8位元解析聲音頻道，
2-16 KHz 取樣頻率。 
 伺服馬達： 
   LEGO MINDSTORMS NXT 的三個馬達可幫助機器
人移動，或執行某些動作。伺服馬達中還有內建角度
感應器，讓操作者能更精確地控制馬達運轉行為。 
 超音波感應器： 
   NXT 超音波感應器的作用相似於人類的眼睛，能
以英吋或公分為單位進行距離測量，(其有效測量距離
為 255 公分內)。 
 光源感應器： 
   光源感應器能用來偵測感應物的亮度。依顏色亮暗
不同回傳不等高低的感應數值。 
 聲音感應器： 
   聲音感應器可偵測機器人週遭環境的聲音大小，並
以 dB(分貝)及 dBA(調整分貝)為測量單位。 
 觸碰感應器： 
  此感應器可以做為機械模型的啟動/停止開關。當觸
碰感應器被壓下時，回傳值為 1；未按下的回傳值為
0。。 
(二) LEGO MINDSTORMS NXT 開發環境 
而要撰寫控制 LEGO MINDSTORMS NXT 機器人的
應用程式，必須透過開發平台來進行撰 
寫，我們採用的 Eclipse 是ㄧ個著名的跨平台的自由集
成開發環境（IDE）。主要以 Java 語言開發，現在也可
藉由外掛程式採用 C++和 Python 作為開發用的程式語
言。 
   Eclipse開發環境被稱作Workbench， 它主要由三個
部分組成： 視圖， 編輯視窗和觀察視窗。 
圖(八十四)為三個部份的關係架構圖: 
        —  42 — 
以下為 NXT 藍芽控制程式的運作原理： 
Step 1： 建立一條電腦與 LEGO MINDSTORMS NXT
機器人的藍芽連線。 
Step 2： 將控制指令透過藍芽協定傳送給 NXT 可程式
積木。 
Step 3： NXT 可程式積木接收到控制指令時執行。 
Step 4： NXT 可程式積木經由藍芽協定把資料回傳至
java 程式。 
  而要撰寫 NXT 藍芽控制程式前須先了解 iCommand 
函式庫的幾個重要類別，其中包含了下列兩個套件： 
 Icommand.nxtcomn 
 Icommand.plat form.nxt 
而在 icommand.nxtcomm 套件中較常用的類別為
NXTCommand、filelnfo 與 Deviclnfo，其中以
NXTCommand 類別最為重要。 
以下為常用的 NXTCommand 類別函式庫 
 getcurrentprogramName( )：取得 NXT 目前正在執
行的程式名稱。 
 set inputeMode( ):輸入端 1-4 個感應器種類以及運
作模式。 
 setVerify(Boolean verify) :要求NXT 確認所執行的
指令是否成功。 
 startprogram(java. lang.StringfileName) :要求 NXT 
執行程式。 
 stopprogram() :停止 NXT 正在執行的程式。 
 close() :在程式結束前必須呼叫此方法，否則下次
執行程式前必須重新啟動 NXT。 
而在 Icommand.platform.nxt 套件中較常用到的類別為
Sensor、Motor、Light、Touch、Sound、與Ultrasonic類
別 
Sensor 類別 
  Sensor 類別提供存取感應裝置的方法，例如： 
 setTypeAndMode( )：設定感應器種類與模式。 
 readNormalizedValue( ): 傳回感應器讀取的資料預
設為 0-1023。 
 readScaledValue( ): 根據感應器種類傳回條種過的
感應值。 
 readBooleanValue( ): 讀取感應資料回傳型別為
boolean。 
Motor 類別 
  Motor 類別內則包含控制伺服馬達的方法： 
 forward(): 啟動馬達以順時針方向旋轉直到呼叫
Stop()或 flt ()方法才會停止。 
 backward( ): 啟動馬達以逆時針方向旋轉直到呼
叫 Stop()或 flt ()方法才會停止。 
 setSpeed() : 設定馬達轉速有效傳入值為 0-100。 
 Stop(): 立刻停止馬達轉動。 
 flt (): 馬達不會立刻停止而是順勢轉動至完全停
止。 
Light 類別 
  Light 類別提供光源感應器的存取方式； 
 activate( ): 啟動光源感應器的反射光源。 
 getLightPercent ( ): 取得光源感應器的感應值百分
比。 
 getLightValue(): 取得光源感應器的值。 
 passivate( ): 關閉光源感應器的反射光源。 
Touch 類別 
  Touch 類別只有一個方法用來偵測感應器是否按下 
 isPressed( ): 呼叫 isPressed( )方法時如果碰觸感應
器剛好被按下則會回傳 TRUE。 
Sound 類別 
  Sound 類別提供聲音感應器的存取方式： 
 getdB( ): 讀取聲音感測器的感測值單位為 dB。 
 getdBA() : 讀取聲音感測器的感測值單位為
dBA。 
Ultrasonic 類別 
  Ultrasonic 類別提供超音波感測器的存取方式： 
 setMetric( ): 設定超音波偵測距離的測量單位預設
為公分。 
 getDistance( ): 取得超音波感測器針對最近物件的
偵測距離。 
  透過上述的函式庫與各個感應器不同的類別我們便
能進行藍芽控制程式的撰寫。 
以下為我們實際的開發程式，程式主要分成五個部份: 
MyTool
Toucher
Ultrasonic
MoverController
圖(八十五)、程式結構圖。 
   首先由 LEGO MINDSTORMS NXT 上的感應器收集
機器人前方的環境資訊，藉由超音波感應器判斷前方
可移動之距離並且以觸碰感應器來研判是否有障礙物
出現， 待感應器收集完資訊後將資料經由藍芽傳輸回
電腦上進行運算待計算完成後再將控制指令回傳至機
器人上執行。而程式運算的步驟如圖(八十五)程式結構
圖一般，而主要判斷的演算法是寫在 MyTool 這個部分
當中，決定機器人要如何從所得到環境資訊中決定下
一個執行動作，而以下將有各個部份的程式碼節錄。 
        —  44 — 
“BlueCube:Constructing a Hypercube Parallel 
Computing and Communication Environment over 
Bluetooth Radio Systems,” Journal of Parallel and 
Distributed Computing (JPDC), vol. 66, no. 10, pp. 
1243-1258, Oct. 2006. 
[3] C. Y. Chang and H. R Chang, “Adaptive Role 
Switching Protocol for Improving Scatternet 
Performance in Bluetooth Radio Networks,” IEEE 
Transactions on Consumer Electronics, vol. 52, no. 4, 
pp. 1229-1238, Nov. 2006. 
[4] C. Y. Chang, P. K. Sahoo, and S. C. Lee, “A 
Location-Aware Routing Protocol for the Bluetooth 
Scatternet,” Wireless Personal Communications, vol. 
40, no. 1, pp. 117-135, Jan. 2007. 
[5] C. Y. Chang, C. T. Chang, and T. S. Chen, H. R. 
Chang, “Hierarchical Management Protocol for 
Constructing a QoS Communication Path in Wireless 
Ad Hoc Networks,” Information Sciences : An 
International Journal, no.177, pp.2621-2641, March 
2007. 
[6] S. S. Wang, K. P. Shih, and C. Y. Chang, 
“Distributed Direction-based Localization in Wireless 
Sensor Networks,” Computer Communications, vol. 
30, pp. 1424-1439, April 2007. 
[7] C. Y. Chang and H. R. Chang, “Power Control and 
Fairness MAC Mechanisms for 802.11 WLANs,” 
Computer Communications, vol. 30, pp. 1527-1537, 
2007. 
[8] T. K. Shih, T. H. Wang, C. Y. Chang, T. C. Kao, and 
D. Hamilton, “Ubiquitous e-Learning with 
Multimodal Multimedia Devices,” IEEE 
Transactions on Multimedia (IEEE TM), vol. 9, no. 3, 
pp. 487-499, April 2007. 
[9] C. Y. Chang, K. P. Shih, C. H. Hsu, and H. C. Chen, 
“A Location-aware Multicasting Protocol for 
Bluetooth Location Networks,” Information Sciences : 
An International Journal, vol. 177, pp. 3161-3177, 
May 2007. 
[10] G. J. Yu, C. Y. Chang, K. P. Shih and S. C. Lee, 
“Relay Reduction and Disjoint Route Construction 
for Scatternet over Bluetooth Radio Systems,” 
Journal of Network & Computer Applications, vol. 30, 
pp. 728-749, June 2007. 
[11] G. J. Yu and C. Y. Chang, "An Efficient 
Cluster-based Multi-channel Management Protocol 
for Wireless Ad Hoc Networks," Computer 
Communication, vol. 30, pp. 1742-1753, July 2007. 
[12] C. Y. Chang and C. T. Chang, “A Traffic-Aware 
Restructuring Protocol for Bluetooth Radio 
Networks,” Computer Networks, vol. 51, issue 14, pp. 
4070-4091, Oct. 2007. 
[13] G. J. Yu and C. Y. Chang, “Congestion Control of 
Bluetooth Radio System by Piconet Restructuring,” 
Journal of Network and Computer Applications 
(JNCA), vol.31, pp. 201-223 Aug. 2008. 
[14] Y. S Chen, Y. W. Lin, and C. Y. Chang "An 
Overlapping Routing Protocol Using Improved 
Time-Slot Leasing in Bluetooth WPANs," to appear 
in Journal of Network and Computer Applications 
(JNCA), Nov. 2008 
[15] C. Y. Chang and H. R. Chang, "Energy-Aware Node 
Placement, Topology Control and MAC Scheduling 
for Wireless Sensor Networks," Computer Networks, 
vol.52, issue 11, pp. 2189-2204, August 2008. 
[16] C. Y. Chang, and S. W. Chang, "Novel Route 
Maintenance Protocols for the Bluetooth Ad Hoc 
Network with Mobility," to appear in Journal of 
Network and Computer Applications (JNCA), Nov. 
2008 
[17] S. W. Chang and C. Y. Chang, "A Location Aware 
Mobility based Routing Protocol for the Bluetooth 
Scatternet," to appear in Wireless Personal 
Communication, 2008. 
[18] C. Y. Chang, C. T. Chang and S. W. Chang "TMCP: 
Two-Layer Multicast Communication Protocol for 
Bluetooth Radio Networks," to appear in Computer 
Networks, 2007. 
[19] C. Y. Chang, H. R. Chang, and C. T. Chang, 
"Obstacle-Free Deployment Algorithm for Wireless 
Sensor Networks," to appear in IEEE Transactions on 
Vehicular Technology, 2008. 
 
國際會議論文(最近三年) 
[1] C. Y. Chang, C. T. Chang, S. C. Lee, and C. H. Tseng, 
“TARP: A Traffic-Aware Restructuring Protocol for 
Bluetooth Radio Networks,”in The IEEE 16th 
International Symposium on Personal Indoor and 
Mobile Radio Communication (IEEE PIMRC 2005), 
Berlin, Germany, Sep. 2005. 
[2] Y. S. Chen, Y. W. Lin, and C. Y. Chang, “An 
Overlapping Routing Protocol Using Improved 
Time-Slot Leasing in Bluetooth WPANs,” 
Proceedings of The 1st International Conference on 
Mobile Ad-hoc and Sensor Networks(MSN'05), 
Wuhan, China, Dec. 2005.  
[3] K. P. Shih, C. Y. Chang, C. M. Chou, S. C. Lee, Y. D. 
Chen, and H. R. Chang, "GUARD: A GUide, Alarm, 
Recovery, and Detection System on a Wireless 
Sensor Network for the Blind," Proceedings of the 
2005 International Workshop on Mobile Systems, 
E-Commerce, and Agent Technology (DMS' 2005), 
Canada, Sep. 2005.  
[4] C. Y. Chang, K. P. Shih, W. C. Huang, S. C. Lee, H. 
R. Chang, and K. J. Liao, “A Location-aware 
Multicasting Protocol for Bluetooth Location 
Networks,” Proceedings of the 2005 International 
Workshop on Mobile Systems, E-Commerce, and 
Agent Technology (MSEAT 2005), Canada, Sep. 
2005.  
[5] K. P. Shih, C. Y. Chang, H. C. Chen and C. W. 
Chang, "On Avoiding RTS Collisions for IEEE 
802.11-Based Wireless Ad Hoc Networks," The 20th 
IEEE International Conference on Advanced 
Information Networking and Applications (IEEE 
AINA 2006) , Vienna, Austria, April 2006.  
[6] C. Y. Chang, K. P. Shih, and H. R. Chang, “Some 
Studies on Technology Support for Outdoor Mobile 
        —  46 — 
[2] K. Sohrabi, J. Gao, V. Ailawadhi, G. Pottie, “Protocols 
for Self-organization of a Wireless Sensor Network,” 
in IEEE Personal Communications Magazine, pp. 16 – 
27, October 2000. 
[3] A. Woo and D. Culler, “A Transmission Control 
Scheme for Media Access in Sensor Networks,” in 
Proceedings of the 7th Annual International 
Conference on Mobile Computing and Networking, pp. 
221 – 235, July 2001. 
[4] B. Chen, K. Jamieson, H. Balakrishnan, and R. Morris, 
“Span: An Energy-Efficient Coordination Algorithm 
for Topology Maintenance in Ad Hoc Wireless 
Networks,” in Mobicom 2001, July 2001. 
[5] C. Barrett, A. Marathe, M. Marathe, and M. Drozda, 
“Characterizing the Interaction Between Routing and 
MAC Protocols in ad hoc Networks,” in Proceedings 
of the 3rd ACM International Symposium on Mobile ad 
hoc networking & computing (MobiHoc), pp. 92 – 103, 
June 2002. 
[6] J. Pan, Y. T. Hou, L. Cai, Y. Shi, and S. X. Shen, 
“Topology control for wireless Sensor networks,” in 
Proceedings of the 9th Annual International 
Conference on Mobile Computing and Networking, pp. 
286 - 299, September 2003. 
[7] Y.-C. Tseng, Y.-N. Chang, and P.-H. Tseng, 
“Energy-efficient topology control for wireless ad hoc 
Sensor networks,” in Proceedings of International 
Computer Symposium (ICS), 2002. 
[8] S. Ramanathan and R. Rosales-Hain, “Topology 
Control of Multihop Radio Networks using Transmit 
Power Adjustment,” in Proceedings of the Nineteenth 
Annual Joint Conference of the IEEE Computer and 
Communications Societies (Infocom), pp. 404 - 413, 
March 2000. 
[9] W. Li and C. G. Cassandras, “A Minimum-Power 
Wireless Sensor Network Self-Deployment Scheme,” 
in Proceedings of the IEEE Wireless Communications 
and Networking Conference (WCNC), pp. 1897 - 1902, 
March 2005. 
[10] P. Cheng, C. N. Chuah, and X. Liu, “Energy-aware 
Node Placement in Wireless Sensor Networks,” in 
Proceedings of IEEE Global Telecommunications 
Conference (GLOBECOM), pp. 3210 - 3214, 
November 2004. 
[11] Maxim A. Batalin and Gaurav S. Sukhatme, “Efficient 
Exploration without Localization,” in IEEE 
International Conference on Robotics and Automation 
(ICRA), Taipei, Taiwan, pp. 2714–2719, May 2003.  
[12] M. J. Mataric, “Behavior-based control: Examples from 
Navigation, learning, and group behavior,” Journal of 
Experimental and Theoretical Artificial Intelligence, 
special issue on Software Architectures for Physical 
Agents, Vol. 9, No. 2-3, pp. 323-336, 1997. 
[13] P. Pirjanian, “Behavior coordination 
mechanisms-state-of-the-eart,” Technic Report, 
Institute for Robotics and Intelligent 
Systems,University of Southern California, 
IRIS-99-375, October 1999. 
[14] Maxim A. Batalin and Gaurav S. Sukhatme, “Coverage, 
Exploration and Deployment by a Mobile Robot and 
Communication Network,” in Proceedings of the 
International Workshop on Information Processing in 
Sensor Networks (IPSN), Palo Alto, pp. 376-391, Apr 
2003. 
[15] Maxim A. Batalin, Gaurav S. Sukhatme and Myron 
Hattig, “Mobile Robot Navigation using a Sensor 
Network,” in Proceedings of the IEEE International 
Conference on Robotics & Automation (ICRA), New 
Orleans, LA, pp.636-642, April 2004. 
[16] Yi Zou and Krishnendu Chakrabarty, “Sensor 
deployment and Target Localization in Distributed 
Sensor Networks,” in ACM Transactions on Embedded 
Computing Systems (TECS), New York, Vol. 3, 
pp.61-91, February 2004. 
[17] Srinath T V, “Localization in Resource Constrained 
Sensor Networks using a Mobile Beacon with 
In-Ranging,” Proceedings of IEEE WOCN, April 2006. 
[18] A. Galstyan, B. Krishnamachari, and K. 
Lerman, ”Distributed Online Localization in Sensor 
Networks using a Moving Target,” The 3rd 
International Symposium on Information Processing in 
Sensor Networks (IPSN), April 2004. 
[19] B. Karp, and H. T. Kung, “GPSR: Greedy Perimeter 
Stateless Routing for Wireless Networks,” ACM 
MobiCom, pp. 243-254, August 2000. 
[20] P. Bose, P. Morin, Ivan Stojmenovic, and J. Urrutia, 
“Routing with Guaranteed Delivery in Ad Hoc 
Wireless Networks,” ACM Wireless Networks, pp. 
609-616, vol. 7, no. 6, Nov. 2001. 
[21] Z. Sun, R. Yu, and S. Mei, “A Robust Power-aware 
Routing Algorithm for Wireless Sensor Networks,” 
IEEE Military Communications Conference 
(MILCOM), pp. 1-5, Oct. 2006. 
[22] K. Seada, A. Helmy, and R. Govindan, “Modeling and 
Analyzing the Correctness of Geographic Face Routing 
under Realistic Conditions,” Ad hoc Networks, vol. 5, 
no. 6, pp. 855-871, August 2007. 
[23] W. H. Liao, Y. C. Tseng, and J. P. Sheu, ”GRID: A 
Fully Location-Aware Routing Protocol for Mobile Ad 
Hoc Networks,” The 6th Mobile Computing Workshop, 
pp. 1-8, March 2000. 
[24] S. Basagni, D. Bruschi, and I. Chlamtac, “A 
Mobility-Transparent Deterministic Broadcast 
Mechanism for Ad Hoc Networks,” IEEE/ACM 
Transactions on Networking, vol. 7, no. 6, December 
1999. 
[25] C. Y. Chang and C. T. Chang, "Hierarchical 
Cellular-Based Management for Mobile Hosts in 
Wireless Ad Hoc Networks," Computer 
Communications Journal, vol. 24, pp. 1554-1567, 
2001. 
        —  48 — 
可供推廣之研發成果資料表 
; 可申請專利  □ 可技術移轉                                   日期：97 年 10 月 6 日 
國科會補助計畫 
計畫名稱：設計與實作智慧型服務無線感測網路－子計畫(二) 
網路初始化、繞徑協定與資料收集協定之設計與實作(3/3) 
計畫主持人：張志勇 
計畫編號：NSC 96-2221-E-032-005       學門領域：資訊 
技術/創作名稱 克障之群播服務(Obstacle-Free Multicasting)、無位置資訊或具粗略位置資訊障礙物偵測與克障繞徑協定 
發明人/創作人 張志勇 
中文： 
此技術為以分散式的技術修復因障礙物產生而斷裂的 Multicasting 繞徑。當
網路中存在障礙物時，我們進一步提出兩分散式障礙物偵測技術使其可分別運
作在 Sensor 無位置資訊和具粗略基本位置資訊之環境。另外，提出ㄧ分散式繞
徑技術使其可運作於具粗略基本位置資訊之下，提升封包傳送成功率。 
技術說明 英文： 
The developed mechanism is able to repair the data collection tree for 
overcoming obstacles. In addition, two mechanisms were developed for detecting the 
existence of obstacles in an outdoor environment. The proposed mechanisms work 
well even though all sensors are not aware of their own location information. Besides, 
we also proposed a routing mechanism for resisting the obstacles and improving the 
success rate for packet transmissions.  
可利用之產業 
及 
可開發之產品 
可供現有 wireless sensor node 產品(如 Mica2, Mica2Dot, Mica Z 等)其硬體中
的通訊協定效能改善，使其於具障礙物存在之環境下，能提升繞徑的效能。 
技術特點 
(1) 分散式重建 Share Tree。 
(2) 可運作在 Sensor 無位置資訊和具粗略基本位置資訊之環境的障礙物偵
測。 
(3) 提高封包的成功到達率。 
(4) 提升繞徑的效能。 
推廣及運用的價值 
現有 Wireless Sensor Node 將可具更高的智慧並適用於具障礙物的環境下重
建 Share Tree，以及無位置或粗略基本位置的網路環境下的繞徑具有克障能力，
已商業化的現有設備如 Mica2, Mica2Dot, Mica Z 等產品將能在通訊時具有更好
的繞徑效能。 
 
 
