designers can design the service process, compose 
service data and configure widget-based user 
interfaces through developing a mashup document, 
which can be used as input of mashup engine to 
produce its corresponding mashup application and a 
new composite RESTful service. Based on Process-Data-
Widget mashup framework and mashup engine, this 
project also developed a GUI-based designer tool to 
let users easily design service process, data 
aggregation rules, and widgets to be rendered for 
constructing mashup services which meet user＇s 
requirements； and furnished multiple kinds of 
service recommendation functionalities, including 
service-network-based recommendation , recommendation 
for parallel and selective services, and mashup-
similarity-based recommendation to enhance usability.
英文關鍵詞： REST, RESTful Service, Service Composition, Service 
Recommendation, Widget, Software Framework 
 
 i 
目錄 
（一） 中文摘要 ............................................................................................................................................................ 1 
（二） 英文摘要(Abstract) ............................................................................................................................................ 2 
（三） 報告內容 ............................................................................................................................................................ 3 
（四） 計畫成果自評 .................................................................................................................................................. 17 
（五） 可供推廣之研發成果資料表 .......................................................................................................................... 18 
 2 
（二） 英文摘要(Abstract) 
Nowadays, service mashup techniques have attracted more and more attentions. However, reusable and 
reconfigurable composition models for construction of mashup applications are still lacking. Meanwhile, the 
REST (REpresentational State Transfer) architecture has been widely accepted by the public because of the 
usability and simplicity, and it is appropriate to be the foundation for developing components in mashup 
applications. Therefore, on the basis of REST architecture, we propose a software framework, called 
Process-Data-Widget, to assist designers with building mashup applications. The proposed approach aims to 
convert time-consuming and manual mashup-construction tasks into systematic, semi-automatic and 
configurable ones. Applying this approach, designers can design the service process, compose service data 
and configure widget-based user interfaces through developing a mashup document, which can be used as 
input of mashup engine to produce its corresponding mashup application and a new composite RESTful 
service. Based on Process-Data-Widget mashup framework and mashup engine, this project also developed a 
GUI-based designer tool to let users easily design service process, data aggregation rules, and widgets to be 
rendered for constructing mashup services which meet user’s requirements; and furnished multiple kinds of 
service recommendation functionalities, including service-network-based recommendation , recommendation 
for parallel and selective services, and mashup-similarity-based recommendation to enhance usability. 
 
Keywords: REST, RESTful Service, Service Composition, Service Recommendation, Widget, Software 
Framework
 4 
1. 參考 WS-BPEL 之概念，並考量 Web 2.0 服務特性，將透過 microformat 來設計 mashup service、
整合 RESTful service。 
2. 將 mashup 從 implementation-level 問題轉化為 design-level 之問題。 
3. 考慮 RESTful 服務與 SOAP service 存在之差異：RESTful 服務是資源導向(resource-oriented)
與使用者介面導向(UI-oriented)，這與 SOAP-based Web service 有相當程度的差異。 
4. 開發具圖形化使用者介面的設計工具，讓使用者可透過 GUI 便利地設計服務流程、資料串接
方法與 Widget 呈現方法，以建構出符合使用者需求的混搭服務 
5. 提供多種服務推薦功能，讓使用者在設計混搭服務過程中可以取得貼近其混搭目標之元件服
務或已建置之混搭服務。 
 
2. 文獻探討 
本章節說明與本研究相關之服務組合、混搭文件設計、混搭服務推薦等相關文獻： 
Battle [1]等學者提出Semantic Query Decomposer (SQD) Federation的Semantic bridge架構，以REST
為服務標準，並使用RDF對服務進行語意註解，最後透過SPARQL (SPARQL Protocol and RDF Query 
Language)進行內部服務查詢，或提供給外部使用者進行外部服務查詢。 
Sheth [11]等學者提出SA-REST方法來串接服務，由於服務所需之資料經常可由其他服務所提供，
但礙於不同服務之資料極可能內涵相同但描述不同，因此在SA-REST透過語意註解(semantic annotation)
與以XSLT資料轉介(data adaptation)等方式達成服務串接之目的。 
Kopecky [7]等學者提出hRESTS (HTML for RESTful Services)方法，以microformat對RESTful 
Services進行描述，由於許多API只用一般文字描述在HTML文件中，缺乏machine-readable的API描述，
透過hRESTS格式，可描述其服務之操作、輸入和輸出。 
Braga [2]等學者提出以圖形介面環境來組合服務之方式，其中服務的運作利用Parallelism及
Pipelining等方式去調整服務串接處理，並利用Merge-scan與Nested-loop等方式將資料進行排序(rank)，
最後由Chunking機制可將結果分段輸出。 
Zhang [13]等學者提出一個two layer架構，建立一個University-oriented的服務網站，藉以將常用的
資訊，如新聞、天氣、和課程等加以彙整，而為了能夠使資料能夠順利整合以及呈現，此方法透過Caching
機制查詢及更新資料，最後經由社群網站(如Facebook)之介面來呈現資訊。 
Boris Tapia [12] 等學者提出利用APIs的分類，幫助使用者提高服務的發現率，為了實現服務推薦
的功能，利用Searching functional-equivalent APIs尋找相同功能的APIs加以分類，並將APIs計分排名並
推薦給使用者。 
Elmeleeg [3, 4]等學者提出MashupAdvisor的系統，透過使用者建議產生的混搭庫(repository of 
mashups)，分析混搭資源，推薦給使用者建議配置與連接服務的調用，例如使用者加入商業新聞作為
資源，MashupAdvisor可能會建議相關的資料(公司的股票價格、公司地理位置、公司創始人資訊 等...
相關資訊)讓使用者選取並混搭。 
Jiawei [6]等學者亦提出一種推薦方法，幫助使用者找到合適的資料源，以便於使用者建構混搭。
使用方法是以CF (Collaborative Filtering)為基礎的Top-N推薦系統，借由分析歷史資料，找哪個服務經
常混搭使用，以判定這些服務應具有高相似度，利用此相似度來決定要推薦使用者哪些服務。 
開發系統需要長期的過程，為了減少開發的成本，利用重複使用與擴展現有混搭的概念，Nestler [8]
等學者在開發工具上提供了一種簡單，視覺化的介面，讓經常被使用到的功能設置成已準備好的組件，
使得使用者可以快速且便捷的選取，如此一來使用者可以集中精力在選擇與整合所需要的功能上。 
 
 6 
 
圖 2 服務串接樣式 (Service Process Pattern) 
 我們以 MRT、Flight、Hotel、以及 Weather 四個服務為例，當一個服務執行完時，依序執行後續
的服務(MRT→Flight→Hotel→Weather)，即為「循序樣式」；而「平行樣式」則是多個服務同時執行，
如圖 2 中 Flight、Hotel 與 Weather 三個服務會同時執行。而「選擇樣式」則是根據使用者輸入的資料
不同，會調用不同的服務，以 Weather 為例，使用者如果輸入的是台灣的都市，會導向 TaiwanWeather
服務，如果是國外的都市，會導向 ForeignWeather 服務。 
 ServiceProcessMashup 章節的 Service 資料層負責記錄內部多筆服務間輸出入資料介接之設定，包
含 ID (服務代號)、Input (輸入)、OutputDataName (檔案輸出名稱)，如圖 3 所示。服務混搭引擎將讀取
此設定擷取合適資料以呼叫服務。 
 
圖 3 Service Process Mashup 文件範例 
 
2.  服務資料組合 (Data Composition)設計 
服務混搭引擎會根據服務流程設計取執行個別服務，每個服務執行後均可產出服務資料集合
(Service Data Set)，因此，服務資料組合章節負責描述如何彙整各服務資料集合，CrossJoin 區塊指
定 Data Set Name (要處裡的資料集合名稱)、JoinKey (關鍵結合欄位)以及 Joined Data Set Name (輸
出的結合資料名稱)，Ranking 則指定資料集合名稱、Mode (排序機制)、Ranking Key (排序欄位)、
Output Ranking Data Set Name (已排序處理後的資料集合名稱)。(如圖 4 所示) 
 
 8 
 
圖 6 Nested loop & Merge-scan 
 
3. Widget 呈現(Widget Presentation)設計： 
最後需設計 Widget 的呈現方式，此章節包含以下設定：(1) Widget type：Widget 樣式。(2)Data 
Set Name：所需資料集合名稱。(3) Select：依照使用者需求依欄位篩選資料(如圖 7)所示。 
 
圖 7 Widget Presentation 文件範例 
3.2 服務混搭引擎 
 符合上述規格之混搭文件(Mashup Document)將透過本計畫研發之服務混搭引擎(Mashup Engine)
進行處理，主要分為三步驟： 
(1) 步驟一：為了要能夠將 Service 串接並且執行，先對文件內的 ServiceProcessMashup 區塊進行
解析，隨後依照內部所描述之串接樣式執行服務。 
(2) 步驟二：解析文件內的 DataMashup 區塊，將步驟一中各 Service 所回傳之資料文件進行彙整，
並依照 DataMashup 描述產出不同組合之資料集合，供最後顯示之 Widget 使用。 
(3) 步驟三：利用步驟 2 所產出之資料集合，進一步將資料集合的欄位進行篩選，並呈現結果。 
經過上述之處理，一個 RESTful 混搭服務即可產生，讓使用者進行服務調用與瀏覽。 
 
 10 
提出了以下三種推薦機制： 
(1) 以服務網絡(service network)為基礎之推薦：是以服務網絡為基礎之推薦，將根據使用者選擇
之服務推薦在網絡上關聯性較強的相關服務。 
(2) 平行式與選擇式服務之推薦：記錄使用者將服務用在選擇(select pattern)或平行(parallel pattern)
上的次數，加以統計，再將熱門的服務挑選出來，推薦給使用者。根據排名之後的結果，將
使用者最常使用的服務，推薦給使用者。 
(3) 以相似度為基礎的推薦：在使用者運用 editor 編輯混搭服務時，為達到更貼近使用者需求所
加入的功能。在 editor 編輯時，可以透過相似度上的推薦，獲取即時的推薦服務。如果使用
者編輯了一連串的服務，系統可以根據使用者到目前為止輸入的資料透過相似度的查詢，找
尋到之前的歷史記錄，推薦給使用者可增加的服務。 
 
3.4.1 以服務網絡為基礎之推薦 
此推薦模式是以服務網絡為基礎的推薦，它是將所有使用者建構的混搭服務資料編製成一個服務
網絡圖，服務在網絡圖為一個點(vertex)，服務與服務之間的關係為邊(edge)，在每個 edge 上會有權重
(weight)。我們將先分析所有混搭服務的結構後，建立服務網絡圖，再根據服務網絡圖對使用者進行服
務推薦。服務網絡建置流程與服務網絡推薦流程分別如圖 8 與圖 9 所示。 
 
圖 8 服務網絡建置流程圖 
 
圖 9 服務網絡推薦流程圖 
 
表 1 為關聯服務推薦範例，( )表示平行(parallel)的服務組合，[ ]表示選擇(selection)的服務組合，
每個英文字母代表一個服務，而 Weight 則記錄記錄兩服務關聯出現的次數(亦即 pair 出現的次數)。根
據資料，系統會先將每一筆 mashup 拆解成 pair，例如 id:1 的 mashup 為 ABC，將拆解成 AB、AC 2
 12 
 
圖 11 平行式與選擇式服務推薦流程圖 
  
表 2 平行式服務推薦範例 
ID Mashups Parallel Block 
1 (AB)DF AB 
2 (CAE)D CAE 
3 CB(AE) AE 
4 (ACD)F ACD 
5 B(ABC)D ABC 
 
3.4.3 以混搭服務相似度為基礎之推薦 
 
圖 12 混搭服務相似度為基礎之推薦流程圖 
  
混搭服務相似度為基礎之推薦用於整體混搭服務的推薦，在使用者完成或即將完成混搭流程設計
前，透過我們的系統，可以找出與使用者正在設計的混搭服務相類似的其他混搭服務，系統會依據相
似度結果由高到低排序推薦類似的備選混搭服務給使用作為參考。服務推薦流程如圖 12 所示，本計
畫設定兩個元件服務相似度之計分規則包含三種情況(實際給分亦可由管理者調整) 
(1) 完全相同之服務:1 分 
(2) 不同服務但同屬於分類(service type): 0.5 分 
(3) 分類上完全無關聯之服務:0 分 
 14 
 
圖 14 平行式服務推薦範例 
 
圖 15 相似混搭服務推薦範例 
 接著使用者可設定其想要的資訊輸出樣式，像是飛機航班資訊，含有「航空公司名稱」、「地址」、
「電話」等欄位，使用者亦可過濾欄位，舉例而言，使用者可選擇過濾地址的欄位，以增加檢閱的便
利性 (如圖 16)。 
 
圖 16 過濾服務欄位範例 
 在設定資料混搭的模式的程序中，由於混搭方式的不同會影響混搭資訊的順序性，在此範例中，
使用者決定以「Nested Loop」方式，並且以飯店房間欄位做為排序的鍵值(Key)，設定完成系統會提供
預覽功能，使用者設定簡略的輸入參數之後，並檢閱輸出的混搭資訊有無符合需求，確定完成，便進
行最後的「微件(Widget)設計」步驟。 
 在 Widget 設計的部分，系統會先推薦熱門的樣式套件，選擇自行設計，依序設定文字樣式、資訊
外框、標籤分頁樣式還有背景樣式，接著儲存頁面，就完成個人的混搭資訊頁面。透過使用者設計的
混搭頁面，可以直接瀏覽飛機航班、飯店、還有各地天氣的資訊，便於幫助使用者完成出外旅遊的計
 16 
4 結果與討論 
本研究是以使用者觀點提供服務混搭之相關技術支援，將服務混搭程序從一般的實作層級工作
(implementation-level task)轉變為設計層級之工作(design-level task)，並提供在服務串接、資料整合與使
用者介面之相關設計方法。本研究透過一份經由 microformat 格式所描述之 Mashup document 做為服務
組合依據，可個別設計其服務該如何串接、服務回傳資料之整合設計、以及以 Widget 為主之使用者介
面設計，且透過 microformat 格式之文件，不僅僅使得文件能被機器所讀取，亦可讓使用者觀看。而混
搭引擎所生成之 Mashup Service 將是一個新的 RESTful 服務，可提供使用者更進一步的使用或根據自
己偏好調整此混搭服務。除了混搭文件規格之設計與服務混搭引擎之設計與實作外，本研究計畫並開
發了具圖形化使用者介面的設計工具，讓使用者可透過 GUI 便利地設計服務流程、資料串接方法與
Widget 呈現方法，以建構出符合使用者需求之混搭服務；同時提供多種服務推薦功能，讓使用者在設
計混搭服務過程中可以取得貼近其混搭目標之元件服務或已建置之混搭服務。 
未來的研究方向是希望將整套服務混搭流程移植至行動式裝置，讓使用者可以隨時隨地透過行動式
裝置自行設計與使用混搭服務，達成行動混搭(Mobile Mashup)之目標。 
 
5 參考文獻 
[1]  R. Battle and E. Benson, Bridging the semantic Web and Web 2.0 with representational state transfer (REST). 
Web Semantics: Science, Services and Agents on the World Wide Web, 2008. 6(1): p. 61-69. 
[2]  D. Braga, S. Ceri, F. Daniel, and D. Martinenghi, Mashing up search services. Internet Computing, IEEE, 2008. 
12(5): p. 16-23. 
[3]  H. Elmeleegy, A. Ivan, R. Akkiraju, and R. Goodwin. Mashup Advisor: A Recommendation Tool for Mashup 
Development. in IEEE International Conference on Web Services, 2008. ICWS '08. . 2008. 
[4]  H. Elmeleegy, A. Ivan, R. Akkiraju, and R. Goodwin. Mashup Advisor: A Recommendation Tool for Mashup 
Development. in IEEE International Conference on Web Services, 2008. ICWS '08. 2008. 
[5]  R.T. Fielding, D. Software, and R.N. Taylor, Principled Design of the Modern Web Architecture. ACM 
Transactions on Internet Technology, 2002. 2: p. 115--150. 
[6]  C. Jiawei and X. Chunxiao. Data Source Recommendation for Building Mashup Applications. in Web 
Information Systems and Applications Conference (WISA), 2010 7th. 2010. 
[7]  J. Kopecky, K. Gomadam, and T. Vitvar. hRESTS: An html microformat for describing restful web services. 
2009: IEEE. 
[8]  T. Nestler, Towards a mashup-driven end-user programming of SOA-based applications, in Proceedings of the 
10th International Conference on Information Integration and Web-based Applications \& Services. 2008, 
ACM: Linz, Austria. p. 551-554. 
[9]  OASIS Web Services Business Process Execution Language (WSBPEL) TC. Web Services Business Process 
Execution Language Version 2.0. OASIS Standard  2007 11 April 2007; Available from: 
http://docs.oasis-open.org/wsbpel/2.0/OS/wsbpel-v2.0-OS.html. 
[10]  C. Pautasso, O. Zimmermann, and F. Leymann, Restful web services vs. "big"' web services: making the right 
 18 
（五） 可供推廣之研發成果資料表 
□ 可申請專利  ▓ 可技術移轉                        日期：102年 1月 31日 
國科會補助計畫 
計畫名稱：以語意網絡與 REST 架構為基礎之網際服務探索與混搭
機制研究 
計畫主持人：馬尚彬         
計畫編號：NSC 100-2221-E-019-037 學門領域：軟體工程 
技術/創作名稱 PAW (Process-dAta-Widget)服務混搭框架與引擎 
發明人/創作人 馬尚彬 
技術說明 
中文：Process-Data-Widget 軟體框架可讓讓終端使用者(end user)
自行混搭服務，希望能將服務混搭從耗時之人工程序，改進為半自
動化(semi-automatic)與可設定組態(configurable)之操作模式。使用
者可藉由混搭服務設計工具(mashup service designer)之協助發展混
搭文件(mashup document)來設計服務串接流程(service flow)、資料
組合方式(data composition)、以及以 widget 為主的使用者介面
(widget presentation)，而服務混搭引擎(mashup engine)會根據混搭
文件去產生相對應的混搭服務。 
英文： Process-Data-Widget framework aims to convert 
time-consuming and manual tasks of service mashup construction into 
systematic, semi-automatic and configurable ones. Applying this 
approach, designers can utilize mashup service designer to design the 
service process, to compose service data, and to configure 
widget-based user interfaces through developing a mashup document, 
which can be used as input of mashup engine to produce its 
corresponding mashup application and a new composite RESTful 
service. 
可利用之產業 
及 
可開發之產品 
可運用於任何產業領域之混搭應用的建置，預期產品將是特定領域
之 Web 服務遞送介面。 
技術特點 
本方法奠基於軟體工程之架構觀點，將混搭服務之建構透過流程、
資料整合與使用者介面三個不同觀點來探討其技術架構，並透過混
搭服務文件規格、混搭服務設計工具與服務執行引擎之搭配有效降
低混搭服務之建置難度，並可提升混搭服務之模組化程度與可調適
性。 
推廣及運用的價值 
相較於一般服務混搭方法，本方法提昇了混搭程序的自動化程度，
並確保建置出的混搭服務具可調適性，以便利日後的維護與再利
用。 
 
  
                           Shang-Pin Ma et al.: Process-Data-Widget: a REST-Based Software Framework… 
 
 
246 
can be utilized as the component standard for 
mashup construction. 
Web service composition is treated as a 
significant technology that can bring more benefits 
to users than a single service [9]. Web Services 
Business Process Execution Language (WS-BPEL) 
[11], which can interconnect multiple partner 
services based on process-based model and style, is 
accepted as the de facto language of service 
composition both in industrial and academia. As for 
mashup, there is no composition standard like WS-
BPEL. Hard-coding mashup applications are 
difficult to maintain and to reuse even using mashup 
tools. Accordingly, multiple mashup models or 
methodologies are proposed [2, 4, 10, 15] based on 
semantic web and rule-based reasoning techniques. 
However, these efforts do not provide an explicit 
REST-based service composition model. On the 
other hand, some efforts [3, 12] focus on REST-
based service composition by extending WS-BPEL 
or developing new markup languages, but these 
methods did not concern all necessary aspects of a 
complete mashup application, including system 
process, data manipulation and user interfaces.  
Therefore, in this paper, we propose a software 
framework, called Process-Data-Widget, to assist 
designers with building mashup applications along 
with a Mashup development lifecycle. We treat 
REST as the component model, and propose a 
mashup engine, that realizes the Process-Data-
Widget framework, to let users build and configure 
their mashup applications semi-automatically. The 
proposed approach aims to convert the mashup 
construction from an implementation-level work 
into a design-level task. Using this approach, 
designers can design the service process, compose 
service data and configure widgets for UI 
presentation through developing a mashup 
document, which can be used as input of mashup 
engine to produce its corresponding mashup 
service. Process-Data-Widget framework brings 
two kinds of reuse forms: (1) to treat the mashup 
RESTful services as a basic service for building a 
larger-scale composite application; (2) to slightly 
revise the mashup document for similar but 
different requirements. 
The rest of this paper is organized as follows: 
the Process-Data-Widget framework is described in 
Section 2. The system architecture and two 
examples are illustrated in section 3. The related 
work is presented in section 4, and the conclusion of 
this work is depicted in Section 5. 
 
2  Proposed Approach: Process-Data-Widget 
Framework 
This section describes the proposed approach: 
Process-dAta-Widget (abbreviated to PAW) 
framework. The design concepts of PAW 
framework and document specifications will be 
introduced in next sub-sections. 
  
2.1 Design Concepts 
By observing the current mashup applications 
and tools, we identified three significant themes for 
a mashup development lifecycle, including (1) 
service process design; (2) data composition design; 
and (3) widget presentation design. The conceptual 
diagram is shown in figure 1: 
 
Figure 1: Conceptual diagram 
 
Each part is fully explained below: 
(1) Service Process Design: due to the 
composition nature of mashup services, first, 
the mashup designer should design the 
execution sequence of multiple RESTful 
services, and decide how to interconnect 
input/output (I/O) data among these services. 
Accordingly, two kinds of documents are 
needed, the RESTful Service Description 
Document (SDD), to specify the service 
capability and I/O data for a RESTful service, 
and the Mashup document (MD), to specify 
the control flow and data assignment among 
multiple services. (in the “Service Process 
Mashup” section of MD) 
(2) Data Composition Design: in addition to 
service process design, how to manipulate 
service data to produce data sets that satisfy 
the user’s needs is another critical issue. 
During the execution of the Mashup service, 
service data (or called service result) will be 
generated after invoking each RESTful 
service. For example, in a travel mashup 
application, flight data, hotel data and weather 
  
                           Shang-Pin Ma et al.: Process-Data-Widget: a REST-Based Software Framework… 
 
 
248 
the parallel pattern and the selection pattern, as 
shown in figure 2. 
 
 
Figure 2: Service process patterns 
 
To illustrate these three styles of service process 
patterns, we use the travel service, integrating four 
RESTful services, MRT, Flight, Hotel and Weather 
(See figure 2), as examples. The sequence pattern 
can combine a number of services executed in a 
sequential order. As the example shown in figure 2 
(A), MRT, Flight, Hotel, Weather services will be 
invoked one by one. The parallel pattern allows 
multiple services execute simultaneously. As the 
example in shown figure 2 (B), Hotel, Weather and 
MRT service will run in parallel.  The Selection 
pattern can select exactly one branch from a set of 
choices. And as the example shown in figure 2 (C), 
whether the “Taiwan Weather” service or “Foreign 
Weather” service will be invoked depends on the 
location information. 
With respect to the content of the 
ServiceProcessMashup section in MD, it consists of 
a Process section and multiple ServiceBinding 
sections including information for binding real 
RESTful services and for storing service data. The 
Process section defines what services should be 
combined as well as which process pattern will be 
applied. Each ServiceBinding section describes the 
reference to the RESTful service description, the 
input parameters, and the name of service data set 
produced by invoking each participating service. 
Notably, multiple data sets may be produced since 
multiple RESTful services will be invoked during 
the execution of a Mashup service. Besides, the data 
set name will be referred in the “input” element for 
leveraging a generated data set from one service to 
invoke another service. The partial MD example is 
shown in figure 3. 
 
Figure 3: ServiceProcessMashup document example 
 
2.2.2.2 Data Mashup Section 
In addition to services execution, the service 
mashup document is also responsible for the 
integration of service output data. For designing the 
data composition mechanism, first, we can observe 
that output data of a RESTful service is usually a 
XML document or a JSON array that contains a 
number of data items (That is why we also called 
the service output data as service data set). Besides, 
each data item contains a number of data fields 
(Figure 4 is a service data set example). Second, 
originally, a SQL join clause can combine records 
from two or more tables in a database.  Since a 
service data set is similar to a database table, we can 
borrow the “join” concept to combine multiple 
service data sets that are produced by different 
RESTful services. A variety types of join, including 
inner join, left join, right join, and cross join, can be 
chosen. 
 
Figure 4: Service data set example 
 
How to rank data items in the joined data set is 
another issue for improving usability. Users always 
want to obtain the most useful data in the preceding 
data items. Here we apply two join strategies, 
including Nested-Loop (NL) and Merge Scan (MS) 
(also utilized in [4]). In the proposed approach, NL 
and MS strategies (See figure 5) are used to be the 
ranking mechanism, and do not affect the 
  
                           Shang-Pin Ma et al.: Process-Data-Widget: a REST-Based Software Framework… 
 
 
250 
3 Implementation  
 
Figure 9: Overall architecture 
 
The system architecture is shown in figure 9. As 
aforementioned, PAW mashup engine is responsible 
for parsing the MD and generating a corresponding 
mashup application (and a mashup RESTful 
service) for use. Therefore, the PAW mashup 
engine plays the role of a central bus that can link 
all participating RESTful services according to MD, 
and can provide two external interfaces: HTML 
embedding widgets and RESTful service supplying 
service data in XML, for end users and client 
programs respectively.  
 
 
Figure 10:  User interface for the travel service 
 
 
Figure 11:  User interface for the news retrieval service 
 
For demonstrating the feasibility of the proposed 
approach, two mashup applications are also 
developed. First application is travel service that 
combines flight, hotel and weather services. The 
final user interface is shown in figure 10; Second 
application is news retrieval service that connects 
the keyword extraction service and the news search 
service. The user can browse a news webpage and 
then click one of extracted keywords to browse 
other news related to the selected keyword. The 
final user interface for the news service is shown in 
figure 11. Both these two applications are generated 
by PAW mashup engine and the mashup designer 
merely develops required SDDs and MDs, and does 
not write any programs. The service process 
control, data combination, and GUI generation are 
automatically performed by PAW mashup engine. 
 
4  Related Work 
In what follows we introduce a number of 
representative related work with respect to RESTful 
service delivery and Mashup application 
construction. 
Sheth et al. [15] proposes a method which 
connects services by SA-REST since services 
usually can obtain needed data from other services. 
To achieve the service mashup process, SA-REST 
makes use of semantic annotation and XSLT data 
adaptation technique.  Kopecky et al. [8] define a 
model of RESTful Web services, and use the model 
to create the hRESTS microformat, a machine-
readable document format for existing Web APIs. 
The proposed hRESTS microformat describes main 
aspects of services, such as operations, inputs and 
outputs. Battle and Benson [1] proposes a 
framework to align the publication of semantic data 
with the existing web architectures, which is based 
on their distributed query architecture called 
Semantic Query Decomposer (SQD) and a java tool 
called Semantic Bridge for web services. This 
framework combines REST-based design and RDF 
data access, and supports internal service searching 
through SPARQL (SPARQL Protocol and RDF 
Query Language) and external service searching for 
external service users. Braga et al. [4] propose a 
service mashup language for graphically composing 
and automatically executing queries over online 
data-sharing services. This approach includes a 
variety of techniques, such as parallelism and 
pipelining methods that control the execution 
sequence, merge-scan and nested-loop methods that 
join different service data, and chunking mechanism 
that can return results in chunks. Zhang et al. [17] 
propose a two-layer mashup service model to 
establish a university integrated information service 
website that combines weather forecast sites, news 
sites, and course-related information. To improve 
efficiency and usability, this method can query and 
update data based on the caching mechanism and 
deliver information through the social network. 
Peng et al. [14] present a framework, namely 
REST2SOAP, to integrate SOAP services and 
RESTful services by wrapping RESTful services 
into SOAP services semi-automatically. 
REST2SOAP allow developers create a mashup 
  
                           Shang-Pin Ma et al.: Process-Data-Widget: a REST-Based Software Framework… 
 
 
252 
 
Shang-Pin Ma received his Ph.D. and 
B.S. degrees in Computer Science and 
Information Engineering from National 
Central University, Chungli, Taiwan, in 
2007 and 1999, respectively. He has 
been an assistant professor of Computer 
Science and Engineering Department, 
National Taiwan Ocean University, Keelung, Taiwan, 
since 2008. His research interests include web-based 
software engineering, service-oriented computing, and 
semantic web. 
 
Chun-Ying Huang received the B.S. 
degree in Computer Science from 
National Taiwan Ocean University in 
2000 and the M.S. degree in Computer 
Information Science from National 
Chiao-Tung University in 2002. He 
received the Ph.D. degree in Electrical 
Engineering from National Taiwan University in 2007. 
From August 2008, he joined the Computer Science and 
Engineering Department at National Taiwan Ocean 
University as an assistant professor. His current research 
interests focus on various aspects of computer networks 
and network security, including key management, attack 
mitigation, intrusion detection, and traffic analysis. Dr. 
Huang is a member of IEEE and ACM. 
 
Yong-Yi FanJiang received the BS 
degree in Computer Science and 
Information Engineering from 
Tamkang University, Taiwan, in 1994. 
He received his MS and PhD degree in 
Computer Science and Information 
Engineering from National Chiao Tung 
University, Taiwan, in 1998 and from National Central 
University, Taiwan, in 2004, respectively. Currently, he 
is an assistant professor in the Department of Computer 
Science and Information Engineering, Fu Jen Catholic 
University, Taiwan, from 2007. His research interests 
include mobile and pervasive computing, software 
engineering, semantic web, and human computer 
interaction. 
 
Jong Yih Kuo received his BS degree 
from National Tsing Hua University, 
Taiwan, Republic of China, in 1991, 
and his PhD degree from the National 
Central University, Taiwan, in 1998. 
He is now an associate professor in the 
Intelligent System Laboratory of the Department of 
Computer Science and Information Engineering at the 
National Taipei University of Technology in Taiwan. His 
research interests include agent-based software 
engineering and fuzzy logic. 
 2 
驗證議程(service composition and verification session)口頭發表，在約十五分鐘
的投影片簡報後回答了兩個與會者所提出的問題，在發表論文之外主要的活動
就是選擇有興趣的議程進行聆聽。與其他參加過的會議不同的是，此會議安排
了許多互動性的議程，讓演講者可以與聽眾進行討論，互相交換意見。 
主辦單位在會議第二天與第四天分別舉辦了招待派對與晚宴，在第二天的
招待派對上與在會議上結識的臺科大碩士班研究生做了許多研究相關的意見
與經驗交換。另外在會議晚宴上剛好同桌的參加者都是台灣人，分別來自許多
不同單位如財政部，國家高速網路中心，中央研究院，臺中教育大學等，在聊
天的過程當中得到了不少寶貴的經驗與知識，也稍為知道其他單位的研究情
況。 
二、與會心得 
    實際參與國際研討會實屬人生中的寶貴經驗，看著來自世界各地的研究生
或研究人員發表討論各自的論文，強烈的感受到自己真的是在與世界上所有的
研究人員競爭。而隨著論文的發表，有許多不同的想法或解法被提出，大部分
是學生想都沒想過的，使學生再次強烈的感覺到自己的不足與缺點。 
    這是學生第二次參加此會議，在會議的參加者中有許多是來自於世界知名
大學與研究機構的教授或研究員，藉此良機正好可以一窺這些人做的研究與自
己有何不同。此外，在會議所邀請的 keynote講者中，和去年相同這次再次邀
請到了出身台灣的陳品山教授(同時也是 conference chair之一)，能再次一睹大
師風采算是此行的最大收穫之一。 
三、考察參觀活動(無是項活動者略) 
A Survey on Automated Service Composition Methods and Related Techniques 
 
Yang Syu 
Department of Computer 
Science and Information 
Engineering 
National Taipei University of 
Technology 
Taipei, Taiwan 
a29066049@gmail.com 
Shang-Pin Ma 
Department of Computer 
Science and Engineering 
National Taiwan Ocean 
University 
Keelung, Taiwan 
albert@mail.ntou.edu.tw 
Jong-Yih Kuo 
Department of Computer 
Science and Information 
Engineering 
National Taipei University of 
Technology 
Taipei, Taiwan 
jykuo@ntut.edu.tw 
Yong-Yi FanJiang 
Department of Computer 
Science and Information 
Engineering 
Fu Jen Catholic University 
Taipei, Taiwan 
yyfanj@csie.fju.edu.tw 
 
 
Abstract—As a promising, low-cost, and agile way to develop 
software, in recent years automatic service composition has 
been a popular research topic receiving a lot of attentions. For 
this topic, upon our long-term study and paper reviewed, we 
present technical survey and observation in this paper, 
including indispensable background and preliminary 
knowledge. The survey assumes under traditional composition 
context. Moreover, following the survey and observation, we 
suggest two approach patterns and point out possible future 
challenge as well as direction, especially to the influence of the 
mature of mobile devices and environment. 
Keywords- Service-Oriented Architecture; Automatic Service 
Composition; Semantic Web Service; 
I.  INTRODUCTION 
In recent years, many researchers have concentrated on 
automatic service composition, as it is a remarkable and 
promising solution to software engineering.  The basic idea 
is depending on Service-Oriented Architecture (SOA) 
triangle model [1] and mostly implemented via Web Service 
(WS) related technologies, composing reusable off-the-shelf 
services into value-added composite service (CS) to satisfy 
requester. A exhausted introduction to SOA model, WS, and 
service composition can be found in [2]. Comparing with 
manual composition and conventional “programming from 
scratch” development, automatic composition has many 
benefits and advantages, such as low-cost, time-saving, risk-
reducing, and agility. Those motivate adopting automatic 
composition to fulfill software requirement.  
In traditional composition, an implicit assumption is 
that services are running on heavyweight enterprise servers 
and they usually supply computation-intensive functions. 
That is traditional context of service composition. However, 
the assumption and context may be broken by modern 
mobile devices equipped with various sensors and powerful 
computation-power, such as smart phones.  
Automatic composition is not a new topic; it has been 
studied for several years and already producing hard-to-
counted researches. Hence, systematic survey and analysis 
are doubtless required to construct this topic’s architecture 
and overview for people struggling or interesting in the 
topic to understand and refer to. The main contribution of 
this paper is to satisfy the demand. Because this is a large-
scoped topic involving in several branches and sub-concerns, 
researchers in this field can use this paper to position their 
works in the topic (what research concerns are considered 
by their efforts). Moreover, through this paper beginners can 
find their interested subject and understand the topic’s 
outline and basic knowledge. Otherwise, we also discuss 
possible future challenge and direction, suggesting two 
approach patterns. When mobile devices popularize, future 
service composition will not be limited under traditional 
context anymore, it should be more flexible and complex. 
The rest of this paper is organized as follows. Section 
II describes preliminary knowledge and background for 
following discussion. Section III is description in detail for 
each identified research concern. Ultimately, section IV 
states future challenges and directions of automatic 
composition as well as our approach patterns.      
II. PRELIMIRARY OF TRADITIONAL SERVICE 
COMPOSITION 
This section presents preliminary and background of 
traditional service composition, preparing for, in next 
section, our technical survey and observation to automatic 
service composition. Comparing with automatic 
composition, manual composition done by human 
composers is a mature technique and already has been 
applied universally. To compose services by labor force, 
traditionally there are two distinct design approaches: top-
down and bottom-up [3]. Bottom-up is that, at first, 
identifying potential partner WSs (they are concrete 
executable services) and then connecting them with specific 
process logic. Another one, top-down design, is entirely 
different. It starts from specifying business process 
(workflow) consisted of abstract non-executable activities 
and, subsequently, choosing a fittest concrete service for 
each activity [3]. As a fatal drawback, manual composition 
relatively demands for much higher cost. Therefore, 
currently a large proportion of research efforts are dedicated 
to automations instead of costly and time-consumed manual 
composition, trying to thoroughly eliminate human 
2012 IEEE Ninth International Conference on Services Computing
978-0-7695-4753-4/12 $26.00 © 2012 IEEE
DOI 10.1109/SCC.2012.91
28290
design-time stage. During CS’s runtime, a necessity is that 
the processing must be “react in real-time”. That is quite 
difficult to achieve by most automations since they target on 
really designing and composing CS from scratch, such as 
concretizing entire abstract workflow or generating CS 
(workflow) by connecting services one by one. These are 
hard to be real-time as some tasks, e.g. semantic reasoning 
on domain ontology, are time-consumed.  
III. CONCERNS OF TRADITIONAL SERVICE COMPOSITION  
As remarked in previous section, we separated and 
categorized whole automatic composition into three core 
research concerns (service classification, combination, and 
selection) as well as two crosscutting research concerns 
(service description and matchmaking). In this section, we 
present crosscutting concerns first and then core concerns. 
Crosscutting concerns cut across all core concerns, widely 
affecting and involving in them. For instance, how services 
are described and expressed (the concern of service 
description) extensively influences the rationales of how to 
match, classify, combine, and select services (another four 
concerns we identified). Thus, it is better to discuss 
crosscutting concerns prior to core concerns. 
Before starting the discussion for each concern, a 
crucial component in academic research of automatic 
composition, i.e. ontology, should be briefly introduced as it 
largely benefits this subject. It is a backbone of the Semantic 
Webthe second generation of the webtrying to share 
and reuse data (knowledge) across diverse boundaries. The 
term ontology is originally from philosophy, and in 
computer and information sciences it is used to model and 
represent knowledge within specific domain. By capturing a 
domain’s concepts and the relationships between them, it 
can for computer doing logical semantic reasoning. The 
readers can find more about it in Introduction of [25], along 
with exhausted introduction regarding its usage in software 
engineering. Considering theoretical researches of automatic 
composition, we have recognized that, in this field, ontology 
has two principal purposes. One is to enhance services with 
syntactic interoperability as semantic services having 
machine-processable interface, which facilitates automation. 
Another purpose is for generating workflow, upon domain 
knowledge modeled within it. We will explain them in 
service description and combination, respectively. 
A. Service Description 
As above explained, this concern widely twists with 
the others. Under SOA, services’ reusing is black-box, 
entirely different from component-based reusing that 
designers can alter and extend components through 
modifying their source code. The only way to understand 
services is via their descriptions of external specifications. 
That is the reason for why it vastly cuts across other four 
concerns and why we present it with top priority.  
For service description, currently most widely-accepted 
and de-facto standard is WSDL, but just like drawbacks 
remarked in section 2.2 of [1] and section 4 of [3], WSDL is 
barely enough to build syntactical interfaces for connecting 
and invoking services. WSDL lacks formal semantic [2] [26] 
and metadata [1] of service,  thus semantic community has 
provided service specification ontologies, such as OWL-S 
[27], WSMO, and SAWSDL [28] [3], for accurately and 
semantically describing service. Together with appropriate 
domain ontology defining the terms within applied domain, 
they enable and facilitate automatic manipulation of services.  
Both WSDL as well as semantic service ontologies 
have complex specifications and implementation detail but, 
in academia, that are not the primary concern of researchers. 
Hence, for simplicity researchers usually represent services 
in terms of tuple, neglecting trivial specifics. For example, 
in abstract level WSDL simply describes a service 
(operation) by Input and Output (IO) tuple, namely the 
SOAP messages intended and produced by the service. With 
semantic interface, the tuple could be richer including Input, 
Output, Pre-condition, Effect (IOPE), Capability (C), and 
Non-functional properties (NF). IOPEC are functional tuple 
that they together express the functionality of a service. 
Non-functional properties are service’s attributes like QoS. 
Their detailed definition can refer to [2] [4]. In addition, as 
mentioned by [29] and its related work, a recent trend, QoS-
aware WS, is widely followed. Hence, semantic 
specification for services’ QoS attributes is necessary and 
has been proposed. In [29] it defined a comprehensive 
ontology scheme for semantically describing classes, QoS, 
and domain knowledge of services. Ontology defining terms 
about services’ non-functional features will be more 
important when we consider more and more criteria in 
service selection.  
In these tuple, especially in functional tuple, an implicit 
assumption of most works is that a tuple, e.g. Output of a 
service, usually comprises only several coordinative simple 
elements. Each element refers to or is an instance of a 
concept (class) defined on applied domain ontology. 
However, in reality, this assumption does not work. In 
WSDL each IO element could be a complex SOAP message 
element having deep and nested structure definition. A 
corresponding semantic version of WSDL is SAWSDL [3], 
it is identical with WSDL in structure and component, with 
additional semantic annotation for each WSDL component. 
Although semantic services largely benefit automatic 
composition, it still has several serious problems, as 
remarked in [17], causing its unreality. One of the problems 
is that the semantic reasoning on ontology is quite time-
consumed task. Thus, to each tuple, most works did not 
assume containing complex and plethoric elements (for 
instance, in [5] simply the Input element of S8 only has 
“PID” and the Output is “Review”). That is a gap between 
academia and industry. Efforts like [17] [23] proposed using 
pre-processing to services as well as specific data structure 
to store services’ information, in order to accelerate 
semantic-related tasks and enhance the quality of 
composition. 
It is not true that every research works identically 
utilize all of the tuple abovementioned in their service 
description. Which tuple should be included in description 
is decided by what are a work’s core concerns. Automations 
do not need service information that is not concerned by 
them. For example, in [11] the authors came up with 
28492
variant of [3] addresses corresponding matchmaking 
considering realistically complex and nested IO structures. 
C.  Service Classification 
Although it does not directly attend composition, 
Service classification still is an important concern to the 
subject. Basically, it can be seen as a helper for service 
combination and selection. To the former, in bottom-up 
service combination (we will explain it in next subsection) it 
can help to improve the performance and efficiency of 
composer by decreasing the number of services. For 
example, in [5], it clusters and treats services having 
identical functionality as a single unit, and then the 
composition is to these units rather than services. To 
selection, for each abstract activity comprised in a workflow, 
classification can aggregate services having needed function 
but posing different non-functional features, and then 
selector can choose most appropriate service from them. 
Otherwise, for runtime environments and frameworks, it can 
prepare services for replacement [5] or substitution [3].  
Here we identify two classification types: coarse-
grained and fine-grained. The unit of coarse-grained 
classification is service and, to fine-grained, the unit is 
operation. For automatic composition, as we already 
discussed in section II, operation is most suitable function 
unit. In real world, each service usually offers plural 
operations they are, in terms of functionality, entirely 
independent and non-associated. For example, a service 
exposed by a bank may provide query of currency exchange 
rate, financial deal functions, and in-house operations 
internally used by bank’s employees. To assist automatic 
composition, fine-grained classification is fittest. Another 
difference is that the class labels are given in advance or not. 
In [29], user must pre-define class labels by self. Otherwise, 
some efforts adopt standard common taxonomy system such 
as [32] using UNSPSC. Yet, to automatic composition, the 
labels defined in taxonomy systems or by users are too 
coarse. To aid composition automations, in our opinion, a 
perfect classification is like functional clustering in [5]. 
Without pre-defined labels, it uses functional IO parameters 
to semantically cluster functionality-identical operations 
together (it is fine-grained, viewing an operation as a 
service).  
Most primitive classifications like [29] use only service 
name to classify. In example of [29], the user defines ten 
classes in advance and services are classified to proper class 
according to its name. In this way, the classification is quite 
inexact and coarse. Advanced approaches, like [32], rely on 
services’ text information (in WSDL and UDDI) as well as 
parameter terms. Many of them are variants of term-
frequency based manner.      
D. Service Combination 
In our opinion, toward automatic composition, most 
important concern is service combination because it works 
out skeleton of CS (workflow) to meet functional 
requirement of requester. In efforts concerning with service 
combination, despite each effort’s solution and algorithm 
detail is disparate, but roughly there are two different 
mechanisms. First mechanism is that a composer somehow 
creates abstract non-executable workflow template, and then 
forwarding the template to approaches concerning with 
service selection. Or, second mechanism, a composer 
directly synthesizes available and known component 
services as an executable CS implying a workflow. 
Comparatively, first mechanism is akin to top-down manual 
composition earlier mentioned and second mechanism is 
similar with bottom-up.  
In top-down process, designer receives composition 
request and then analyzes it relying on knowledge to applied 
domain and workflow design (sometimes, like requirement 
engineering, designer must work with domain expert as he 
does not have sufficient domain knowledge). Subsequently, 
based on domain know-how and professional sense, the 
designer works out a procedure to fulfill and match the 
request. The procedure is a collection of tasks in which 
every task must be done by something. The procedure in 
designer’s mind can be written via workflow definition 
language discussed in section II. In this way, as you can see, 
evidently the key in top-down design is domain knowledge. 
Therefore, to automate that, there must be a knowledge 
representation model, i.e. ontology, to capture domain 
knowledge from domain expert. The works belonging to 
first mechanism like [26] [2] ([2] is a special case, we will 
discuss it in detail later) leverage knowledge contained in 
domain ontology to generate an abstract workflow template. 
The biggest obstacle of approaches following this 
mechanism is the lack of a worth-to-trust domain ontology 
modeling sufficient domain knowledge. For the obstacle, 
[26] proposed borrowing well-defined ER-model to 
construct domain ontology to overcome the obstacle.   
In bottom-up process, designer definitely knows which 
services are available as well as the detailed specification of 
them. Those are stored in a service repository. When 
receiving a request, the designer struggles to filter, pick, and 
link appropriate services into a feasible service chain (CS) 
written by, for example, WS-BPEL. The linkages between 
component services depend on dataflow, connecting and 
matching by “junction matchmaking” introduced in service 
matchmaking. By this mechanism, workflow is implied in 
composed CS and it is called data-driven workflow because 
it is constructed by dataflow connections, a formal 
definition of data-driven workflow is in section 2 of [24]. 
According to our survey, most efforts concerning with 
service combination work with bottom-up mechanism as, in 
our opinion, it is more feasible than top-down mechanism. 
The construction of a domain ontology having 
comprehensive and sufficient coverage in applied domain is 
a great challenge, involving many stakeholders and 
exertions [17] [26] that hinders top-down mechanism. To 
automate handcrafted bottom-up process, many efforts 
following this mechanism exploit AI planning technique (a 
introduction to works employing AI planning can refer to 
section 3 of [2]), using forward or backward chaining [17] 
[23]. Complying with bottom-up mechanism, our previous 
work [4] and [30] leverage genetic algorithm to evolve CS. 
Contrast to top-down manner, a virtue of bottom-up 
mechanism is that the outcome of composition is a real 
workable CS.  
28694
messages). But in some application types (e.g. multimedia 
applications), the communications could be large data 
streams consuming machine’s CPU resource enormously. 
Long distance and overloading machine probably result in 
negative effect to the application, such as video delay. Thus, 
works like [35] consider distance between services (can be 
measured by number of routers passed) and machine 
loading (on a machine, how many services are running and 
how many data streams are being processed).  
Notices that the non-functional aspects discussed are 
not complete; there still are many other aspects, determined 
by requesters’ concerns and application characteristics. 
According to our observation, virtually every research 
work covers more than one concern because there are 
crosscutting concerns involving in all of them. For example, 
[17] concerns with not only service combination but also 
service description and matchmaking. Another example, [11] 
mainly focus on service selection, but it still has certain 
manner to describe services’ non-functional properties (in 
this case, QoS and transactional behavior) despite the 
manner is not the emphasis of this work. Other than 
crosscutting concerns, there are works trying to cover more 
than one core concern. For example, our previous work [4] 
simultaneously concerns with service combination and 
selection. In [5], it covers all of three core concerns. 
Nevertheless, upon our observation, most efforts only 
highlight one core concern. A large part of efforts belonging 
to this type is QoS-aware service selection such as [19] [16] 
[36] [37] [38] [40]. Otherwise, [18] purely concentrates on 
service selection.  
IV. FUTURE CHALLENGE AND DIRECTION 
In this section, we discuss future challenges and possible 
directions of automatic service composition, suggesting 
approach pattern for top-down and bottom-up composition 
design, respectively.  
At present, in our opinion, the biggest challenge of 
traditional composition is propose a comprehensively fully-
automated methodology. In section 3 of [2], it states that “In 
a fully-automated approach the role of a human is limited to 
formulation of a composition request which contains the 
specification of initial state, goal state and possibly 
optimization criteria”. As remarked in our previous work 
[4], mostly efforts concerning with service selection like [18] 
[11] [16] [15] assumed that the workflows are given in 
advance. In other words, they cannot generate workflows. 
The analysis of shortcomings of them can refer to section 
2.3.3 of [34]. On the other hand, efforts focusing on service 
combination did not consider non-functional aspects 
(optimization criteria), such as [17] [30]. Thus, as the 
quoted statement described, to become fully-automated 
inevitably an approach comprehensively covering 
combination and selection is required.  In [4] we have a 
genetic algorithm (GA) based approach covering workflow 
generation, QoS, and transactional properties, but it still is 
not good enough. First, it needs time to evolve (this is 
inevitably congenital defect of GA) and, as we introduced in 
service selection, there still are many other possible non-
functional properties. We think that a fully-automated 
methodology should be as flexible and automatic as possible, 
providing workflow generation as well as all possible 
combinations of non-functional properties. Requesters must 
be able to choose freely concerned properties.  
Here we suggest two approach patterns: For top-down 
design, after that abstract workflow had been created and 
classification for each activity was done by composer, it can 
use proper selection approach to concretize the workflow as 
a CS having desired non-functional features. For bottom-up 
design, suggested pattern is akin to [5]. First, it must cluster 
services with same function into same group unit and then 
properly chaining these units as a concrete workflow. 
Concrete workflow is distinct from abstract workflow in 
that every node comprised in concrete workflow already has 
several candidate services. Both of suggestions are three-
stage pattern (generation of abstract workflow, classification, 
and selection; clustering, chaining, and selection). Unsolved 
issue is at selection stage. When selecting services, there are 
“precedence rule” in non-functional properties. In [11] [4], 
the rule that the priority of transactional property is higher 
than QoS was proved. Nevertheless, there still are many 
other non-functional properties. Therefore, clarifying non-
functional properties and precedence rules between these 
properties are critical research issue to suggested patterns 
and fully-automated composition approaches.  
In the future, with advancement of technologies and 
newly emerging concepts, we predict that service 
composition will be quite different. Traditionally, services 
are mostly running on enterprise servers. But along with 
modern smart devices’ progress, now they can become 
service providers as well. They can provide certain services 
that cannot be supplied by traditional providers. Services 
provided by mobile providers will be quite different from 
conventional computation-intensive services. They could be 
moving location-based or context-aware services sensing 
and providing, through their sensors, immediate real world 
information. Furthermore, they also can act as 
intermediaries for people to enable them becoming movable 
“human provided services” [40]. Forced by these new trends, 
defining a new service model to substitute obsolete triangle 
SOA model [1] is required. Next, to composition, non-
functional aspects uniquely belonging to mobile devices or 
applications, such as mobility prediction [18], may be real 
concern of future mobile service composition, instead of 
QoS or transaction property that are interested by traditional 
composition works. Identifying and analyzing unknown 
mobile non-functional aspects is significant because, to 
modern software users, non-functional requirement usually 
is more important and prior than functional requirement [7]. 
In the future, a CS probably may blend traditional as well as 
mobile services, and the architecture of CS may not always 
be typical “pipe and filter”. Imaginably, how to define 
process and aggregate non-functional features will be 
baffling problem. 
ACKNOWLEDGMENT 
This research is partially sponsored by National Science 
Council (Taiwan) under the grant NSC 100-2221-E-030-017 
and NSC 100-2221-E-019-037.  
28896
國科會補助計畫衍生研發成果推廣資料表
日期:2013/01/30
國科會補助計畫
計畫名稱: 以語意網絡與REST架構為基礎之網際服務探索與混搭機制研究
計畫主持人: 馬尚彬
計畫編號: 100-2221-E-019-037- 學門領域: 程式語言與軟體工程
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
