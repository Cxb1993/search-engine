node x ∈ V representing a processor in the system and each edge {x, y} ∈ E representing the link
connecting processors x and y. In any distributed system considered in this project, each processor
has a set of shared registers (registers for short). For each register rx in a processor x, only x can
write values into it and only x and its neighbors can read values of it. Each processor is equipped
with a local algorithm that consists of one or more rules of the form:
condition part → action part.
The condition part (or guard) is a Boolean expression of registers of the processor and its neighbors,
and the action part is an assignment of values to some registers of the processor. If the condition
part of one or more rules in a processor is evaluated as true, we say that the processor is privileged
to execute the action part of any of these rules (or privileged to make a move). The local algorithms
of all the processors in a distributed system constitute a distributed algorithm. The local state of a
processor is specified by the values of all its shared registers. The local states of all the processors
in the system constitute a global configuration (configuration for short) of the system.
1.1 Three computational models
The central daemon model was first introduced by Dijkstra [1] in 1974. Under this computational
model, if the system starts with a configuration in which no node in the system is privileged, then
the system is deadlocked. Otherwise, the central daemon in the system will non-deterministically
select exactly one privileged processor and exactly one executable rule in the processor’s local
algorithm, and let the selected processor execute the action part of the selected rule. The local state
of the selected processor thus changes, which in the meantime results in the change of the global
configuration of the system. The system will repeat the above process to change configurations
as long as it does not encounter any deadlock situation. Thus the behavior of the system under
the action of the algorithm can be described by executions defined as follows: an infinite sequence
of configurations Γ = (γ1, γ2, . . .) of a distributed system is called an infinite execution (of the
algorithm in the system) under the central daemon model if for any i ≥ 1, γi+1 is obtained from γi
after exactly one processor in the system makes a move in the ith step γi → γi+1; a finite sequence
of configurations Γ = (γ1, γ2, . . . , γk) of a distributed system is called a finite execution (of the
algorithm in the system) under the central daemon model if (1) k = 1, or for any i = 1, 2, . . . , k−1,
γi+1 is obtained from γi after exactly one processor in the system makes a move in the i
th step
γi → γi+1, and (2) no node is privileged in the last configuration γk.
The distributed daemon model was later considered by Burns [2] in 1987. The difference between
the central daemon model and the distributed daemon model is the number of processors that make
moves in a step of an execution of the algorithm. Under the central daemon model, exactly one
privileged processor in the system is non-deterministically selected by the central daemon to make
a move in a step of an execution of the algorithm. Under the distributed daemon model, however,
an arbitrary number of privileged processors are non-deterministically selected by the distributed
daemon to simultaneously make moves in a step. Thus, we can also define executions for the
distributed daemon model as follows: an infinite sequence of configurations Γ = (γ1, γ2, . . .) of
a distributed system is called an infinite execution (of the algorithm in the system) under the
distributed daemon model if for any i ≥ 1, γi+1 is obtained from γi after a certain number of
2
the naturally-adapted version of the DFS algorithm in Collin and Dolev [5] can serve as a
counterexample to show it (see Appendix C of this report).
A self-stabilizing algorithm under a certain computational model is said to be silent if every
execution under that computational model ends up with a safe configuration in which no node is
privileged. Most of the existing self-stabilizing algorithms are silent [3], [6], [7], [8], [9], [10], [11],
[12].
1.3 Self-stabilizing bridge-finding algorithms
Three self-stabilizing bridge-finding algorithms have been proposed in the past: the SBF algorithm
in Karaata and Chaudhuri [3], Phase I of Algorithm A in Chaudhuri [8], and Algorithm UNNS in
Devismes [12]. In [3], under the assumption that a BFS tree has been constructed in a distributed
system, Theorem 13 shows that the SBF algorithm is a self-stabilizing bridge-finding algorithm
under the weakly fair daemon model. Under the assumption that a DFS tree has been constructed
in a distributed system, Lemma 4.17 in [8] and Lemma 2 in [12], respectively, show that the Phase
I part of Algorithm A and Algorithm UNNS are self-stabilizing bridge-finding algorithms under
the central daemon model.
In the Concluding Remarks in [3], it is mentioned that the SBF algorithm and the BFS tree
algorithm in Huang and Chen [6] can be combined to execute concurrently, to achieve the goal
of finding bridges in a self-stabilizing fashion. What this means is that the BFS tree assumption
for Theorem 13 in [3] can be dispensed with. Since the SBF algorithm is self-stabilizing under
the weakly fair daemon model and the BFS tree algorithm in [6] is self-stabilizing under the
distributed daemon model, the combining of the SBF algorithm with the BFS tree algorithm in [6]
indeed yields a self-stabilizing bridge-finding algorithm under the weakly fair daemon model (cf.
Concluding remarks of this report). Nevertheless, since the SBF algorithm is not self-stabilizing
under the central daemon model (see our disproof in Appendix B), the algorithm that results from
the combining of the SBF algorithm and the BFS tree algorithm in [6] cannot be self-stabilizing
under the central daemon model (and therefore not under the distributed daemon model).
Theorem 4.20 in [8] claims that the combining of Algorithm A with the DFS algorithm in Collin
and Dolev [5] produces a self-stabilizing algorithm under the central daemon model, which can find
all the bridge-connected components of the system. If the above claim is true, it implies that the
combining of Phase I of Algorithm A with the DFS algorithm in [5] produces a self-stabilizing
bridge-finding algorithm under the central daemon model. However, this last proposition cannot
be true because the naturally-adapted version of the DFS algorithm in [5] is not self-stabilizing
under the central daemon model (cf. Appendix C of this report).
Theorem 4 in [12] claims that the combining of Algorithm DFS with Algorithm UNNS produces
a self-stabilizing bridge-finding algorithm under the central daemon model, where Algorithm DFS
is any silent self-stabilizing DFS tree-finding algorithm under the central daemon model. However,
even if there may exist such a silent self-stabilizing DFS tree-finding algorithm under the central
daemon model, this claim is still incorrect (see our disproof of this claim in Appendix D).
The failures of all the above three combined algorithms to be self-stabilizing under the central
daemon model reaffirm our viewpoint (to be elaborated in Concluding remarks) that combining
4
meaning of legitimate configurations is clarified - explicitly, it is shown that in any legitimate
configuration, all the bridges in the system can be identified. In Section 4, an example illustrates
the execution of our proposed algorithm. In Section 5, a proof is given to show that the proposed
algorithm is self-stabilizing under the distributed daemon model. Moreover, assuming that a
shortest-path tree has been constructed, the worst-case stabilization time under the distributed
daemon model is computed. In Section 6, Concluding remarks, the issue concerning the combining
of two self-stabilizing algorithms, under different computational models, is discussed.
2 Preliminaries
In this section, some graph-theoretic concepts and properties needed in later discussion are listed.
Let G = (V,E) be a connected simple undirected graph. The removal of an edge {x, y} from G
results in the subgraph G−{x, y} that consists of all the nodes of G and all the edges of G except
{x, y}. An edge {x, y} in G is called a bridge in G if G− {x, y} is disconnected.
Property 1 An edge α is a bridge in a connected simple undirected graph G if and only if α does
not lie on any cycle in G.
Proof. Cf. [14].
Property 2 Suppose G′ = (V,E ′) is a shortest-path spanning tree rooted at a node r for a con-
nected simple undirected graph G = (V,E). If {x, y} ∈ E − E ′ (i.e., {x, y} is a non-tree edge),
then x is not a descendant of y and y is not a descendant of x in G′.
Proof. See Appendix A.
Property 3 Suppose G′ = (V,E ′) is a rooted spanning tree for a connected simple undirected
graph G = (V,E) and {x, y} is an edge in E ′ (i.e., {x, y} is a tree edge) with x being the parent
of y. If {x, y} is not a bridge in G, then there exists an edge {u, v} in E − E ′ (i.e., {u, v} is a
non-tree edge) such that u is a descendant of y and v is not a descendant of y in G′.
Proof. See Appendix A.
3 The proposed algorithm and legitimate configurations
In this section, our self-stabilizing algorithm for solving the bridge-finding problem is presented.
The distributed system in consideration has a general underlying topology, and thus can be mod-
elled by a connected simple undirected graph G = (V,E), with each node x ∈ V representing a
processor in the system and each edge {x, y} ∈ E representing the bidirectional link connecting
processors x and y. It is assumed that
(1) each node in the system has a unique identifier and there is a special node r in the system,
(2) each node x in the system maintains three shared registers dx, px and bx,
(3) N(x) denotes the set of all neighbors of x,
6
Proof. Cf. [10, Theorem 1].
Let Vγ = {x ∈ V | SPTx is true in γ}, Eγ = {{x, y} ∈ E | x, y ∈ Vγ and px = y in γ} and
Gγ = (Vγ, Eγ), a subgraph of G.
Lemma 1 For any configuration γ and any edge {x, y} ∈ Eγ, if px = y in γ, then dx = dy + 1 in
γ.
Proof. Since {x, y} ∈ Eγ, we have that x ∈ Vγ and hence SPTx is true in γ. This, combined
with px = y 6= ⊥ in γ, implies that x 6= r, dx = min
z∈N(x)
(dz + 1) and y = px = min{w ∈ N(x) |
dw = min
z∈N(x)
dz} in γ. Hence dy = min
z∈N(x)
dz in γ, and hence dx = dy + 1 in γ.
Note that for any configuration γ, if {x, y} ∈ Eγ , then either px = y or py = x in γ, but not
both (for if px = y and py = x in γ, it follows from Lemma 1 that dx = dy + 1 and dy = dx + 1 in
γ, which is impossible). If we consider every edge {x, y} ∈ Eγ with px = y in γ as a directed edge
from x to y, then Gγ becomes a directed graph. As usual, the outdegree od(x) of a node x is the
number of all the directed edges of Gγ whose initial nodes are x. Since there exists at most one
node y ∈ N(x) such that px = y in γ, we have that od(x) ≤ 1 in Gγ.
Lemma 2 For any configuration γ, Gγ = (Vγ, Eγ) is a forest (i.e., a graph with all its connected
components being trees) and each component of Gγ is a rooted tree.
Proof. First, we show that Gγ is a forest. Suppose Gγ is not a forest. Then Gγ contains a
cycle τ = (x1, x2, . . . , xk, x1), with k ≥ 3. Since x1, x2, . . . , xk are all in Vγ , SPTxi is true in γ for
all 1 ≤ i ≤ k.
Case 1. The special node r lies on τ . Without loss of generality, let x1 = r. Hence SPTx1 is true
and px1 = ⊥ in γ. Since {x1, x2} ∈ Eγ and px1 = ⊥ 6= x2 in γ, we have px2 = x1 in γ. By the
same token, px3 = x2 in γ. Arguing in this way, we eventually get that px2 = x1, px3 = x2, . . . ,
pxk = xk−1 and px1 = xk in γ, which contradicts the above condition that px1 = ⊥ in γ.
Case 2. The special node r does not lie on τ . Since {x1, x2} ∈ Eγ , either px1 = x2 or px2 = x1
in γ. Without loss of generality, let px2 = x1 in γ. Since {x2, x3} ∈ Eγ , px3 = x2 in γ. Arguing in
this way, we eventually get that px2 = x1, px3 = x2, . . . , pxk = xk−1 and px1 = xk in γ. By Lemma
1, we have that dx2 = dx1 +1, dx3 = dx2 +1, . . . , dxk = dxk−1 +1, and dx1 = dxk +1 in γ. It follows
that dx1 < dx2 < dx3 < · · · < dxk < dx1 in γ, a contradiction.
Therefore, Gγ is a forest.
Next, we show that any component T of Gγ is a rooted tree. As remarked previously, Gγ can be
considered as a directed graph. Hence the component T of Gγ is a directed tree. Also as remarked,
od(x) ≤ 1 for any x in V . Hence, to show that T is a rooted tree amounts to showing that there
exists a unique node u in T such that od(u) = 0 in T . (1) We first show that there is a node u
in T such that od(u) = 0 in T . Suppose not. Then for any node x in T , od(x) = 1 in T . Let x1
be any node in T . Since od(x1) = 1 in T , there exists a node x2 in T such that px1 = x2 in γ.
By the same token, there exist nodes x3, x4, . . . in T such that pxi = xi+1 in γ for i = 2, 3, . . ..
Hence, by Lemma 1, dx1 = dx2 + 1, dx2 = dx3 + 1, . . . in γ, which implies that dx1 > dx2 > · · · in
γ. Consequently, x1, x2, . . . must be all distinct, which causes a contradiction because T is a tree
with only a finite number of nodes. Therefore, there must be a node u in T such that od(u) = 0 in
8
common ancestor and the lowest common ancestor are as usual. Moreover, we shall call an edge
{x, y} in G a tree edge of G with respect to Gγ if {x, y} ∈ Eγ , and a non-tree edge of G with
respect to Gγ if otherwise. Note that for any two nodes x and y, the lowest common ancestor of x
and y exists and is unique, which we shall denote by lca(x, y). For any non-tree edge α = {u, v}
of G with respect to Gγ, let Pu be the unique simple path in Gγ connecting u and lca(u, v) and
Pv be the unique simple path in Gγ connecting v and lca(u, v). Then the simple paths Pu and Pv
and the edge {u, v} form a cycle in G. Let τu,v denote this cycle.
Lemma 4 Suppose the system is in a legitimate configuration γ. Then, for any node x, if α ∈ bx
or α ∈ bx in γ, then α is a non-tree edge of G with respect to Gγ, i.e., α /∈ Eγ.
Proof. Suppose α is a tree edge of G with respect to Gγ . Then α /∈ NT (x) in γ.
Case 1. α ∈ bx in γ. Since B3(x) = ∅ in γ, α /∈ B3(x) in γ. Then since α /∈ NT (x) ∧ α ∈ bx
∧ α /∈ B3(x) in γ, we have that α ∈ One(x) in γ. Hence there exists a child x1 of x in Gγ such
that α ∈ bx1 in γ. By the same token, there exists a child x2 of x1 in Gγ such that α ∈ bx2 in γ.
Arguing in this way, we eventually get infinitely many nodes x1, x2, . . . in the system such that
xi+1 is a child of xi in Gγ for any i = 1, 2, . . .. However, this causes a contradiction because Gγ is
a rooted tree with only a finite number of nodes.
Case 2. α ∈ bx in γ. Since B4(x) = ∅ in γ, α /∈ B4(x) in γ and hence α ∈ Two(x) in γ. Hence
there exist two children u and v of x in Gγ such that α ∈ bu and α ∈ bv in γ. By the same argument
as in Case 1 above, we will get a contradiction from the condition that α ∈ bu.
Therefore, α must be a non-tree edge of G with respect to Gγ .
Lemma 5 Suppose the system is in a legitimate configuration γ and α = {u, v} is a non-tree edge
of G with respect to Gγ. If x is not an ancestor of either u or v in the rooted tree Gγ, then α /∈ bx
in γ.
Proof. Suppose α ∈ bx in γ. Since x is not an ancestor of either u or v in Gγ, x 6= u and x 6= v.
Thus, α /∈ NT (x) in γ. Since B3(x) = ∅ in γ, we have that α /∈ B3(x). Since α /∈ NT (x), α ∈ bx
and α /∈ B3(x) in γ, we have that α ∈ One(x) in γ. Hence there exists a child x1 of x in Gγ such
that α ∈ bx1 in γ. Since x is not an ancestor of either u or v in Gγ and x1 is a descendant of x,
we have that x1 is not an ancestor of either u or v in Gγ . By the same token, there exists a child
x2 of x1 in Gγ such that α ∈ bx2 in γ, and x2 is not an ancestor of either u or v in Gγ . Arguing in
this way, we will eventually get infinitely many nodes x1, x2, . . . in the system such that xi+1 is a
child of xi in Gγ for any i = 1, 2, . . .. However, this causes a contradiction because Gγ is a rooted
tree with only a finite number of nodes. Therefore, α /∈ bx in γ.
Lemma 6 Suppose the system is in a legitimate configuration γ. Then, for any node x ∈ V and
any edge α ∈ E, bx cannot contain both α and α in γ.
Proof. Suppose both α ∈ bx and α ∈ bx in γ. Since B4(x) = ∅ in γ, α /∈ B4(x) in γ. Since
α /∈ B4(x) and α ∈ bx in γ, α ∈ Two(x) in γ and thus α /∈ One(x) in γ. Then, from condition
[α ∈ bx ∧ α /∈ One(x) ∧ B3(x) = ∅ in γ], it follows that α ∈ NT (x) in γ. Let the non-tree edge
α be {x, y}. Since α ∈ Two(x) in γ, there exists a child v of x in Gγ such that α ∈ bv in γ. By
10
Lemma 9 Suppose the system is in a legitimate configuration γ and α = {u, v} is a non-tree edge
of G with respect to Gγ. If node x lies on the unique simple path P in Gγ connecting lca(u, v) in
Gγ and the root r, then α /∈ bx in γ.
Proof. Let P = (x0, . . . , xt) with x0 = lca(u, v), xt = r and t ≥ 0. By Lemmas 6 and 8,
we have that α /∈ bx0 in γ. If t > 0, then x1 6= lca(u, v). Thus for any child y of x1 in Gγ such
that y 6= x0, y cannot be an ancestor of either u or v in Gγ . By Lemma 5, α /∈ by in γ. Hence
α /∈ One(x1) in γ. This together with the fact that α /∈ E(x1) and B3(x1) = ∅ in γ implies that
α /∈ bx1 in γ. By the same token, if t > 1 then α /∈ bx2 in γ. Arguing in this way, we will get that
α /∈ bxi in γ for i = 0, . . . , t. Hence the lemma is proved.
Corollary 1 Suppose the system is in a legitimate configuration γ and α = {u, v} is a non-tree
edge of G with respect to Gγ. Then, for any node x, α ∈ bx in γ if and only if x lies on the cycle
τu,v in G and x 6= lca(u, v) in Gγ.
Proof. The “if” part is exactly Lemma 7, while the “only if” part follows immediately from
Lemmas 5 and 9.
For presentation’s sake, we use b∗x to stand for the set {α ∈ E | α ∈ bx or α ∈ bx}.
Corollary 2 Suppose the system is in a legitimate configuration γ and α = {u, v} is a non-tree
edge of G with respect to Gγ. Then, for any node x ∈ V , α ∈ b
∗
x in γ if and only if x lies on the
cycle τu,v in G.
Proof. This follows immediately from Lemma 8 and Corollary 1.
The following theorem claims that in any legitimate configuration, all the bridges in G can be
identified.
Theorem 1 Suppose the system is in a legitimate configuration γ. Then
1) no non-tree edge of G with respect to Gγ can be a bridge in G, and
2) a tree edge {x, y} of G with respect to Gγ is a bridge in G if and only if b
∗
x ∩ b
∗
y = ∅ in γ.
Proof. 1) For any non-tree edge {u, v} of G with respect to Gγ, the simple paths Pu and Pv
and the edge {u, v} form a cycle τu,v in G. Thus, the edge {u, v} lies on a cycle in G. By Property
1, {u, v} cannot be a bridge in G.
2)(⇒) Suppose b∗x∩b
∗
y 6= ∅ in γ. Then there exists an edge β = {u, v} in G such that β ∈ b
∗
x∩b
∗
y
in γ. By Lemma 4, β is a non-tree edge of G with respect to Gγ . By Corollary 2, both x and y
lie on the cycle τu,v in G. Hence, x and y can be connected by a simple path in Gγ which lies on
τu,v. This simple path must be exactly the edge {x, y} because {x, y} is the unique simple path
in Gγ connecting x and y. Hence the edge {x, y} must lie on the cycle τu,v. By Property 1, {x, y}
cannot be a bridge in G.
(⇐) Suppose {x, y} ∈ Eγ is not a bridge of G. Without loss of generality, we assume that x
is the parent of y in Gγ . By Property 3, there exists a non-tree edge β = {u, v} such that u is a
descendant of y and v is not a descendant of y in Gγ. Let Pu,y be the unique simple path in Gγ
connecting u and y. For any node z lying on the path Pu,y, z 6= lca(u, v) (for if z = lca(u, v), then
v is a descendant of y, which causes a contradiction). Hence we have that lca(u, v) is an ancestor
of x in Gγ. By Lemma 8 and Corollary 1, β ∈ bx or β ∈ bx in γ, and β ∈ by in γ. Hence b
∗
x∩ b
∗
y 6= ∅
in γ.
12
Table 1: An execution of Algorithm 1 under the distributed daemon model for the system in Figure
1.
node 0 node 1 node 2 node 3 node 4 node 5 node 6
d  p   b   d p  b  d p  b  d p  b  d  p  b  d p  b  d p  b 
γ 1 2 {{0,1}} 3 3 {{1,3}} 0 4 {{5,6}} 1 2 {{5,6}} 3 5 {{4,6}} 2 4 {{4,5}} 2 ⊥ ψ
γ 1 2 {{0,1}} 2 3 {{1,3}} 2 4 {{5,6}} 1 2 ψ 1 5 {{4,6}} 2 4 {{4,5}} 2 ⊥ ψ
γ 0 2 {{0,1}} 2 0 {{1,3}} 2 0 {{5,6}} 1 2 ψ 3 5 {{4,6}} 2 4
{{4,6},
{5,6}}
2 ⊥ ψ
γ 0 ⊥ {{0,1}} 1 0 {{1,3}} 1 0 {{5,6}} 3 2 ψ 3 2 {{4,6}} 2 4
{{4,6},
{5,6}}
3 ⊥ ψ
γ 0 ⊥ {{0,1}} 1 0 {{1,3}} 1 0 {{4,6}} 3 2 ψ 3 2 {{4,6}} 4 4
{{4,6},
{5,6}}
3 5 ψ
γ 0 ⊥
{{1,3},
{4,6}}
1 0 {{1,3}} 1 0 {{4,6}} 2 2 ψ 2 2 {{4,6}} 4 4
{{4,6},
{5,6}}
3 5 ψ
γ 0 ⊥
{{1,3},
{4,6}}
1 0 {{1,3}} 1 0 {{4,6}} 2 1 ψ 2 2
{{4,6},
{5,6}}
3 4
{{4,6},
{5,6}}
3 4 ψ
γ 0 ⊥
{{1,3},
{4,6}}
1 0 ψ 1 0 {{4,6}} 2 1 {{2,3}} 2 2
{{4,6},
{5,6}}
3 4
{{4,6},
{5,6}}
3 4 {{5,6}}
γ	 0 ⊥
{{1,3},
{4,6}}
1 0 ψ 1 0 {{4,6}} 2 1 {{2,3}} 2 2
{{4,6},
{5,6}}
3 4
{{4,6},
{5,6}}
3 4 {{5,6}}
γ  0 ⊥
{{1,3},
{4,6}}
1 0 {{2,3}} 1 0 {{4,6}} 2 1 {{2,3}} 2 2
{{4,6},
{5,6}}
3 4 {{5,6}} 3 4 {{5,6}}
γ 0 ⊥
{{2,3},
{4,6}}
1 0 {{2,3}} 1 0
{{2,3},
{4,6}}
2 1 {{2,3}} 2 2
{{4,6},
{5,6}}
3 4 {{5,6}} 3 4 {{5,6}}
γ 0 ⊥
{{2,3},
{4,6}}
1 0 {{2,3}} 1 0
{{2,3},
{4,6}}
2 1 {{2,3}} 2 2 {{5,6}} 3 4 {{5,6}} 3 4 {{5,6}}
γ 0 ⊥
{{2,3},
{4,6}}
1 0 {{2,3}} 1 0 {{2,3}} 2 1 {{2,3}} 2 2 {{5,6}} 3 4 {{5,6}} 3 4 {{5,6}}
γ 0 ⊥ {{2,3}} 1 0 {{2,3}} 1 0 {{2,3}} 2 1 {{2,3}} 2 2 {{5,6}} 3 4 {{5,6}} 3 4 {{5,6}}
(6) A step γ → γ′ of Algorithm 1 is a b-step if it is neither a d-step nor a p-step. (Thus, any
node that makes a move in a b-step must make a b-move.)
Note that in all the rest of this section, we shall let “execution” mean “execution under the
distributed daemon model”, for brevity’s sake.
The following lemma is obvious in view of the definition of legitimate configuration, the defini-
tion of finite execution, and the definition that an algorithm is self-stabilizing under the distributed
daemon model.
Lemma 10 Algorithm 1 is self-stabilizing under the distributed daemon model if and only if any
execution of Algorithm 1 is a finite execution.
14
Proof of claim. Since the p-values of all the nodes in the system are fixed in Γ, the set
{y ∈ N(x) | py = x} does not change due to γ → γ
′. For any node y in {y ∈ N(x) | py = x} that
is not in G˜, y cannot make any move in any step in Γ by Claim 1. Hence y cannot make any move
in γ → γ′ and hence the b-set of y does not change due to γ → γ′. For any node y in {y ∈ N(x)
| py = x} that is in G˜, y is a child of x in G˜. By the assumption of this claim, y does not make
any move in γ → γ′. Hence the b-set of y does not change due to γ → γ′ either. Consequently,
the b-sets of all the nodes in {y ∈ N(x) | py = x} do not change due to γ → γ
′. This combined
with the fact that the set {y ∈ N(x) | py = x} does not change due to γ → γ
′ implies that the
sets One(x) and Two(x) do not change due to γ → γ′. Since the p-values of all the nodes in the
system do not change due to γ → γ′, the set NT (x) does not change due to γ → γ′.
Subclaim 1. B1(x) = ∅ in γ
′.
Proof of subclaim. Let α be any edge.
Case 1. α does not satisfy [α ∈ NT (x) ∨ (α ∈ One(x) ∧ α /∈ E(x)) in γ′]. Then α /∈ B1(x) in γ
′.
Case 2. α satisfies [α ∈ NT (x) ∨ (α ∈ One(x) ∧ α /∈ E(x)) in γ′]. Since as shown above the sets
NT (x), E(x) and One(x) do not change due to γ → γ′, α ∈ NT (x) ∨ (α ∈ One(x)∧ α /∈ E(x)) in
γ. Thus, α /∈ B2(x) ∪ B3(x) in γ.
Subcase 2.1. α ∈ bx in γ. Then, since α ∈ bx ∧α /∈ B2(x)∪B3(x) in γ, α ∈ bx − (B2(x)∪B3(x))
in γ. Hence α ∈ [bx − (B1(x)∪B2(x)∪B3(x)∪B4(x))]∪B1(x)∪B2(x) in γ. Since x executes R5
in γ → γ′, α ∈ bx in γ
′. Hence α /∈ B1(x) in γ
′.
Subcase 2.2. α /∈ bx in γ. Then, since α ∈ NT (x) ∨ (α ∈ One(x) ∧ α /∈ E(x)) in γ and α /∈ bx in
γ, α ∈ B1(x) in γ. Hence α ∈ [bx − (B1(x) ∪ B2(x) ∪ B3(x) ∪ B4(x))] ∪ B1(x) ∪ B2(x) in γ. Since
x executes R5 in γ → γ′, α ∈ bx in γ
′. Hence α /∈ B1(x) in γ
′.
From all the above, we can conclude that B1(x) = ∅ in γ
′.
Subclaim 2. B2(x) = ∅ in γ
′.
Proof of subclaim. Let α be any edge.
Case 1. α does not satisfy [α ∈ Two(x) ∧ α /∈ E(x) in γ′]. Then α /∈ B2(x) in γ
′.
Case 2. α satisfies [α ∈ Two(x) ∧ α /∈ E(x) in γ′]. Since the sets Two(x) and E(x) do not
change due to γ → γ′, α ∈ Two(x) ∧ α /∈ E(x) in γ. Thus, α /∈ B1(x) ∪ B4(x) in γ and hence
α /∈ B1(x) ∪B4(x) in γ.
Subcase 2.1. α ∈ bx in γ. Then, since α ∈ bx ∧ α /∈ B1(x) ∪ B4(x) in γ, α ∈ [bx − (B1(x) ∪
B2(x) ∪B3(x) ∪B4(x))] ∪B1(x) ∪B2(x) in γ. Since x executes R5 in γ → γ
′, α ∈ bx in γ
′. Hence
α /∈ B2(x) in γ
′.
Subcase 2.2. α /∈ bx in γ. Then, since α ∈ Two(x) ∧ α /∈ E(x) ∧ α /∈ bx in γ, α ∈ B2(x) in γ
and hence α ∈ B2(x) in γ. Thus, α ∈ [bx − (B1(x)∪B2(x)∪B3(x)∪B4(x))]∪B1(x)∪B2(x) in γ.
Since x executes R5 in γ → γ′, α ∈ bx in γ
′. Hence α /∈ B2(x) in γ
′.
From all the above, we can conclude that B2(x) = ∅ in γ
′.
Subclaim 3. B3(x) = ∅ in γ
′.
Proof of subclaim. Let α be any edge.
Case 1. α does not satisfy [α /∈ NT (x) ∧ α /∈ One(x) in γ′]. Then α /∈ B3(x) in γ
′.
Case 2. α satisfies [α /∈ NT (x) ∧ α /∈ One(x) in γ′]. Since the sets NT (x) and One(x) do not
change due to γ → γ′, α /∈ NT (x) ∧ α /∈ One(x) in γ. Thus, α /∈ B1(x) in γ.
Subcase 2.1. α ∈ bx in γ. Then, since α /∈ NT (x) ∧ α /∈ One(x) ∧ α ∈ bx in γ, α ∈ B3(x) in
γ. Hence α /∈ (bx − B3(x)) ∪ B1(x) in γ and hence α /∈ [bx − (B1(x) ∪ B2(x) ∪ B3(x) ∪ B4(x))] ∪
16
(2) Inductive step. Assume that k ≥ 1 and the claim is true for 1 ≤ m ≤ k. Let x be any node in G˜
that has k+1 descendants in G˜. Let x1, x2, . . . , xj be all the children of x in G˜ andmx1 , mx2 , . . . , mxj
be the number of descendants of x1, x2, . . . , xj in G˜, respectively. Then mx1 , mx2, . . . , mxj are all
less than or equal to k. By the induction hypothesis, x1, x2, . . . , xj can make a move in at most
mx1 , mx2 , . . . , mxj steps in Γ, respectively. Thus, the number of steps in Γ in which at least one
child of x in G˜ makes a move is q ≤ mx1 +mx2 + · · ·+mxj = k. By Claim 4, x can make a move
in q + 1 ≤ k + 1 steps in Γ.
By (1), (2) and the postulate of mathematical induction, the claim is proved.
For any node in G˜, since it has at most n descendants in G˜, by Claim 5 it can make a move in
at most n steps in Γ. For any node not in G˜, it cannot make any move in Γ by Claim 1. Hence,
the number of steps in Γ is at most n2 and the lemma is proved.
Lemma 12 Any execution of Algorithm 1 which does not contain any d-step is finite.
Proof. Let Γ be any execution of Algorithm 1 which does not contain any d-step. Then no
node can execute rule R1 or R2 in Γ. Thus, the d-value of each node is fixed in Γ. In view of the
rules R3 and R4, each node can make a p-move in at most one step in Γ. Thus, there exists a suffix
Γ′ of Γ such that Γ′ does not contain any d-step or p-step. Hence Γ′ is an execution containing
only b-steps. By Lemma 11, Γ′ is a finite execution. Thus Γ is a finite execution.
Lemma 13 Any execution of Algorithm 1 contains only a finite number of d-steps.
Proof. For any execution Γ = (γ1, γ2, . . .) of Algorithm 1, let γi1, γi2, . . ., where i1 < i2 < · · · ,
be all the configurations in Γ which result from the d-steps (i.e., for any k = 1, 2, ..., the step
γik−1 → γik is a d-step). If we ignore all the p-values and b-values in these configurations, then
S = (γ1 = γi0, γi1, γi2, . . .) becomes a segment of execution of the shortest path algorithm in [11]
under the distributed daemon model (i.e., for any k ≥ 0, γik → γik+1 is a step of the shortest path
algorithm in [11] under the distributed daemon model). Since, by Theorem 1 in [11], any execution
of the shortest path algorithm under the distributed daemon model must be finite, we have that
S is a finite segment. Therefore, Γ contains only a finite number of d-steps.
Theorem 2 Algorithm 1 is self-stabilizing under the distributed daemon model and solves the
bridge-finding problem.
Proof. This follows from Lemmas 10, 12, 13 and Theorem 1.
Corollary 3 Under the assumption that SPTx holds for all x in V (i.e., a shortest-path tree has
been constructed in the system), Algorithm 1 is a self-stabilizing bridge-finding algorithm under the
distributed daemon model and stabilizes in at most n2 steps, where n is the number of nodes in the
system.
Proof. Under the assumption that SPTx holds for all x in V , any execution of Algorithm 1
contains only b-steps. Thus the claim of this corollary follows immediately from Lemma 11 and
Theorem 2.
18
R2 : x 6= r ∧ dx 6= min
y∈N(x)
(dy + 1)→ dx := min
y∈N(x)
(dy + 1)
R3 : x = r ∧ dx = 0 ∧ px 6= ⊥ → px := ⊥
R4 : x 6= r ∧ dx = min
y∈N(x)
(dy + 1) ∧ px 6= min{z ∈ N(x) | dz = min
y∈N(x)
dy}
→ px := min{z ∈ N(x) | dz = min
y∈N(x)
dy}
With priorities properly set, the following combined algorithm was obtained:
Algorithm SP+02
{For any node x}
R1 : x = r ∧ dx 6= 0→ dx := 0
R2 : x 6= r ∧ dx 6= min
y∈N(x)
(dy + 1)→ dx := min
y∈N(x)
(dy + 1)
R3 : x = r ∧ dx = 0 ∧ px 6= ⊥ → px := ⊥
R4 : x 6= r ∧ dx = min
y∈N(x)
(dy + 1) ∧ px 6= min{z ∈ N(x) | dz = min
y∈N(x)
dy}
→ px := min{z ∈ N(x) | dz = min
y∈N(x)
dy}
R5 : SPTx ∧ [B1(x) 6= ∅ ∨B2(x) 6= ∅ ∨ B3(x) 6= ∅ ∨B4(x) 6= ∅]
→ bx := [bx − (B1(x) ∪ B2(x) ∪B3(x) ∪ B4(x))] ∪ B1(x) ∪B2(x),
where
NT (x) = {{x, y} ∈ E | py 6= x ∧ px 6= y},
One(x) = {α ∈ E | there is exactly one node u ∈ N(x) s.t. pu = x ∧ α ∈ bu},
Two(x) = {α ∈ E | there are exactly two nodes u, v ∈ N(x) s.t. pu = x∧pv = x∧α ∈ bu∧α ∈ bv},
and
SPTx represents the following predicate:
(x = r∧ dx = 0∧ px = ⊥)∨ [x 6= r∧ dx = min
y∈N(x)
(dy+1)∧ px = min{z ∈ N(x) | dz = min
y∈N(x)
dy}].
Note that this combined Algorithm SP+02 is exactly Algorithm 1, the algorithm proposed in
this report. For this combined algorithm, the presence of a rooted spanning tree is not assumed.
Hence for this algorithm, the shared register px needs to be introduced, and the definitions of
NT (x), One(x) and Two(x) need to be modified, in order to accommodate situations where a
shortest-path tree has not been constructed yet. Moreover, the predicate SPTx is used in R5 to
set priorities. With these standard manipulations in the combining process, Algorithm SP+02
allows Algorithm SP and Algorithm 02 to work concurrently, but gives the Algorithm SP part a
higher priority to execute than the Algorithm 02 part. If the computational model is the weakly
fair daemon, it ensures that the Algorithm SP part will lead the system to the environment in
which a shortest-path tree is always present. Once this is achieved, the Algorithm SP part stops
operating, and the Algorithm 02 part will then lead the system to a legitimate configuration in
which all the bridges of the system can be identified.
The above argument shows that Algorithm SP+02 is a self-stabilizing bridge-finding algorithm
under the weakly fair daemon model, which can dispense with the rooted spanning tree assumption.
Note that this argument has a general nature. That is, an argument such as this can show that
under the weakly fair daemon model, combining two self-stabilizing algorithms using the standard
manipulations as above always yields a self-stabilizing algorithm. (For example, the two-center-
finding algorithm in Huang et al. [9] can also be viewed as obtained from combining two weakly-fair-
20
connecting x and y. Since y ∈ Vy and x ∈ V −Vy, there is an edge {u, v} on the path P connecting
Vy and V − Vy (i.e., u ∈ Vy and v ∈ V − Vy). Since {u, v} is on P and P is in G − {x, y},
{u, v} 6= {x, y}. Since {x, y} is the only tree edge connecting Vy and V − Vy, {u, v} must be a
non-tree edge. Thus, we have shown that there exists a non-tree edge {u, v} such that u is a
descendant of y (for u ∈ Vy) and v is not a descendant of y (for v ∈ V − Vy) in G
′.
B The SBF algorithm in [3]
In this appendix, we show that the SBF algorithm in [3] is not self-stabilizing under the central
daemon model.
First recall the SBF algorithm in [3] as follows:
{For any node x}
VARIABLE s(x) : a subset of elements of the form α and {α} where α is an edge in G
PARAMETER α : an edge in G
ACTIONS
G1 : ((incident.α ∧ ¬one.α) ∨ (¬incident.α ∧ one.α)) ∧ α /∈ s(x)→ s(x) := (s(x)− {{α}}) ∪ {α}
G2 : two.α ∧ {α} /∈ s(x)→ s(x) := (s(x)− {α}) ∪ {{α}}
G3 : ¬incident.α ∧ ¬one.α ∧ α ∈ s(x)→ s(x) := s(x)− {α}
G4 : (¬incident.α ∨ ¬one.α) ∧ ¬two.α ∧ {α} ∈ s(x)→ s(x) := s(x)− {{α}}
where
incident.α : α is a non-tree edge incident on node x.
one.α : α is in the s-set of exactly one child of node x in the tree.
two.α : α is in the s-sets of exactly two children of node x in the tree.
The legal executions (of the SBF algorithm) under the weakly fair daemon model are designed to
be all those single-configuration executions (γ)’s, where γ is any configuration in which no node is
privileged. Hence the safe configurations under the weakly fair daemon model are precisely those
configurations in which no node is privileged.
The above SBF algorithm is shown in [3] to be a silent self-stabilizing algorithm under the
weakly fair daemon model for solving the bridge-finding problem. However, if legal executions and
safe configurations (of the SBF algorithm) under the central daemon model are also specified to be
the same as those under the weakly fair daemon model, the SBF algorithm is not self-stabilizing
under the central daemon model, as shown in the following:
Consider now a distributed system G consisting of 5 nodes, as illustrated in Figure 3. Assume
that a BFS spanning tree rooted at node r is already constructed for this system. In Figure 3, the
tree edges indicating the BFS spanning tree of the system are represented by solid lines, while the
non-tree edges are represented by dashed lines. In Figure 3, we exhibit an infinite cyclic central-
daemon-model execution of the SBF algorithm. As one can see, only two configurations appear
alternately in this execution and both configurations are not safe configurations under the central
daemon model. Thus, the SBF algorithm is not self-stabilizing under the central daemon model.
22
C The naturally-adapted version of the DFS algorithm in
[5] to the central daemon model
In this appendix, we show that the naturally-adapted version of the DFS algorithm in [5] to the
central daemon model is not self-stabilizing. Let G = (V,E) be any general network in which there
is a unique special node r, called root. Each node x orders its edges by some arbitrary ordering
αx. For any edge e = {x, y}, αx(y) is the edge index of e according to αx. It is also assumed that
every node x knows the value αy(x) of any of its neighbors y. Each node x maintains a variable
pathx. The value of pathx is a sequence of at most N items, where N ≥ n (the number of nodes
in G) is a constant positive integer and each item in the sequence is either a positive integer or a
special symbol ⊥. The following is the naturally-adapted version of the DFS algorithm in Collin
and Dolev [5]:
Algorithm ADV
{For the root r}
R0 : pathr 6= ⊥ → pathr := ⊥
{For any node x 6= r}
R1 : pathx 6= min≺lex{rightN(pathy ◦ αy(x)) | y ∈ N(x)}
→ pathx := min≺lex{rightN(pathy ◦ αy(x)) | y ∈ N(x)}
Note that in the algorithm,
(a) ≺lex is a lexicographical order over the set of all finite sequences of at most N items, and ⊥ is
the minimal character. For example, (⊥, 1) ≺lex (⊥, 1, 1) ≺lex (⊥, 2) ≺lex (1);
(b) the notation rightN(w) refers to the sequence of the N least significant item of w. For example,
right6(⊥, 3, 2, 1, 2, 1, 1) = (3, 2, 1, 2, 1, 1) and right6(2, 1, 2, 1, 1) = (2, 1, 2, 1, 1);
(c) pathy ◦ αy(x) is the concatenation of pathy with αy(x). For example, if pathy = (1, 2, 1) and
αy(x) = 3, then pathy ◦ αy(x) = (1, 2, 1, 3).
Since the DFS algorithm in [5] is self-stabilizing under the read/write atomicity model (cf.
Dolev et al. [15]), and since weakly fair executions have been checked for the self-stabilization
property of the DFS algorithm, it is not difficult to show that its adapted version, Algorithm ADV,
is self-stabilizing when it operates under the weakly fair daemon model. However, Algorithm ADV
is not self-stabilizing under the central daemon model, as we show now in the following:
According to [5], when pathx = pathy ◦ αy(x), node x is a child of node y, and y is a parent
of x. Consider now a distributed system G consisting of 6 nodes as illustrated in Figure 4. The
number N in Algorithm ADV is now set to 6, which is the number of nodes in G. Table 2
exhibits a beginning portion of an infinite cyclic execution of Algorithm ADV in G, under the
central daemon model, with period 13 (note that γ1 = γ13). The shaded grid in each configuration
indicates the privileged node selected by the central daemon to make a move. In configuration γ1,
since pathe ◦ αe(r) = (3, 3) 6= (⊥) = pathr, we have that node r is not a child of node e. On the
other hand, since pathr ◦ αr(e) = (⊥, 1) 6= (3) = pathe in γ1, we have that r is not the parent
of e in γ1. Thus, the edge {r, e} is not a tree edge in γ1. Hence no spanning tree and thus no
DFS tree of G can be identified in γ1. Consequently, the above algorithm is not a self-stabilizing
DFS-tree-finding algorithm under the central daemon model.
24
Table 2: A beginning portion of an infinite cyclic execution of Algorithm ADV under the central
daemon model for the system in Figure 4.
path 
 path  path  path  path  path 
γ  ⊥ (3) (1,1,1,1,1,1) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,1,1)
γ  ⊥ (3) (1,1,1,1,1,2) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,1,1)
γ  ⊥ (3) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,2,2) (1,1,1,1,1,1)
γ  ⊥ (3) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,1,1) (1,1,1,1,1,1)
γ  ⊥ (3) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,1,1) (1,1,1,1,1,2)
γ  ⊥ (3) (1,1,1,1,2,2) (1,1,1,1,2,2) (1,1,1,1,1,1) (1,1,1,1,1,2)
γ  ⊥ (3) (1,1,1,1,2,2) (1,1,1,1,1,1) (1,1,1,1,1,1) (1,1,1,1,1,2)
γ  ⊥ (3) (1,1,1,1,2,2) (1,1,1,1,1,1) (1,11,,1,1,2) (1,1,1,1,1,2)
γ  ⊥ (3) (1,1,1,1,2,2) (1,1,1,1,1,1) (1,1,1,1,1,2) (1,1,1,1,2,2)
γ  ⊥ (3) (1,1,1,1,1,1) (1,1,1,1,1,1) (1,1,1,1,1,2) (1,1,1,1,2,2)
γ  ⊥ (3) (1,1,1,1,1,1) (1,1,1,1,1,2) (1,1,1,1,1,2) (1,1,1,1,2,2)
γ  ⊥ (3) (1,1,1,1,1,1) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,2,2)
γ  ⊥ (3) (1,1,1,1,1,1) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,1,1)
γ  ⊥ (3) (1,1,1,1,1,2) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,1,1)
… … … … … … …
as Algorithm DFS+UNNS) is a silent self-stabilizing bridge-finding algorithm under the central
daemon model. However, this claim is incorrect, as we disprove it as follows:
Theorem 4 in [12] claims that the combined Algorithm DFS+UNNS stabilizes to PREDFS
and PREUNNS under the central daemon model, where PREUNNS denotes the predicate ∀x ∈
V −{r}, Backx = u(x). This means that the legitimate configurations are all those configurations
in which PREDFS and PREUNNS hold. It is also mentioned in [12] that if Children backx,
Nontree heightx, and Heightx contain the expected values (which is the case under the condition
PREDFS), u(x) is equal to min(Children backx ∪ Nontree heightx ∪ {Heightx}). Hence the
legitimate configurations for Algorithm DFS+UNNS are all those configurations in which the
following conditions hold:
PREDFS and ∀x ∈ V − {r}, Backx = min(Children backx ∪Nontree heightx ∪ {Heightx}.
In other words, the legitimate configurations are all those configurations in which no node in
the system is privileged with respect to Algorithm DFS+UNNS.
Consider now a distributed system G consisting of 4 nodes as illustrated in Figure 5. For this
system, we exhibit in Figure 6 an infinite cyclic execution of the combined Algorithm DFS+UNNS,
under the central daemon model, with period 6. Note that for each node x in the system, the
values of Parx, Cx and Heightx are all fixed in the whole execution, and the shaded nodes in each
configuration stand for the privileged nodes in that configuration. For brevity’s sake, any arrow
from a node i to another node j in Figure 6 indicates Pari = j and Cj = {i}. The existence of
this infinite execution shows that the combined Algorithm DFS+UNNS may not lead the system
to a configuration in which no node is privileged (i.e., a legitimate configuration). Hence it shows
that Algorithm DFS+UNNS is not self-stabilizing under the central daemon model.
26
