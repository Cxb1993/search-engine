 2
計畫中文摘要 
 
關鍵詞： 電腦象棋、象棋知識庫、自動化棋局整理分析、智慧型電腦輔助學習、
資料探勘，智慧型代理人 
 
本計畫內容為高等電腦象棋知識庫之設計、建構與應用，目標為利用我們現有
的工具，包括棋力接近七段的象棋程式、包含數十萬棋局的開局資料庫以及下棋網
站的發展經驗等等，來建立一套智慧型系統，以管理電腦對局及系統式教學，並利
用網路伺服器管理資料庫，並提供大眾化的棋局資料庫及教學系統。 
本計劃預計以兩年的時間完成，我們將在高等象棋知識庫之設計建構與應用
(I)計畫中完成棋局分析及管理系統，包括打譜工具、棋譜分類管理系統和資料庫
管理系統。在本計劃中，第一年將設計自動在網路上擷取棋局的代理人，並且可以
針對全局及殘局經由歸納、分析、推論等人工智慧方法，整理出具有相關性的棋局
資料，並進行正確著法的分析工作。而在第二年將進而設計智慧型電腦輔助學習系
統，製作互動性良好、便利性高的人機介面，呈現系統化的棋局資料，讓使用者以
循序漸進，由淺入深的方式學習象棋，使學習的過程更加生動有趣。 
這個高等電腦象棋知識庫完成之後，不但可以提供大眾化的棋局資料庫及教學
系統，讓人們可以學習象棋，而在發展過程中，也將發展新的資料探勘、資料庫處
理，智慧型電腦輔助學習及電腦對局等理論，預計可有四篇以上的論文發表。最後
這個知識庫更可幫助電腦象棋的發展，讓電腦象棋的棋力更上一層樓。 
 4
行政院國家科學委員會專題研究計畫成果報告 
 
高等象棋知識庫之設計建構與應用 
計畫編號：95-2221-E-309-016-MY2 
 
執行期限：  95 年 08 月 01 日至 97 年 10 月 31 日 
 
計畫主持人：許舜欽 
計畫共同主持人：顏士淨 
計畫參與人員：陳柏年、鄭明政、曾氏炫 
 
執行機構及單位名稱 
 
長榮大學資訊管理系 
 
 
一、前言 
本計畫內容為高等電腦象棋知識庫之設計建構與應用，我們利用以前的研究成果，
包括棋力七段的象棋程式、數十萬棋局的開局資料庫以及下棋網站的發展經驗等等，來
建立一套智慧型象棋知識庫系統，以管理電腦對局及系統式教學，並利用網路伺服器管
理資料庫，並提供大眾化的棋局資料庫及教學系統，這個高等電腦象棋知識庫不但可以
提供人們學習及研究象棋，另一方面，內容充實，結構完整的象棋知識庫也將是發展電
腦象棋的最大利器，將可幫助發展大師級的象棋程式，這些都是本計劃的目的。 
 
二、研究目的 
象棋為中國的國粹，在中國流傳已有數千年的歷史，近年來由於世界各國腦力運動
的推廣，以及大陸地區的改革開放，使得下象棋的人口越來越多，中日韓等國甚至有將
下棋運動加入奧林匹克運動會的提議。在近年來，國內由於教改的進行，使得國中小的
 6
高等電腦象棋知識庫，將可幫助完成此需求。 
電腦象棋的研究起步於 1980 年代初期，雖然比起電腦西洋棋大約晚了三十年，但
在參考其理論與經驗，並且不斷研究與改進的情況之下，成果卻是相當輝煌。程式的棋
力都已經有六段以上的棋力，與人類的高段棋士相去不遠。但是距離人類的世界冠軍級
的棋手，還有一步之遙。 
一般人下棋，通常推算不到六手。高段棋士的算度雖然較為深遠，但是最多也只能
推算到十多個著手。然而在開局階段，紅黑雙方要把棋子調動到重要的位置，為中局的
攻防作戰奠定基礎，至少也要在十個著手之後，陣形才能初見眉目，然後再經過四、五
個回合的開展，才能形成基本定型。[Yen 2004][陳 1998] 
在這十多個回合當中，如果任何一方下出緩著或是劣著，就極易受制於對方而處於
劣勢。但是僅僅依靠幾個著手的推算，卻是很難看出緩著或劣著的存在。從電腦對局的
理論而言，我們可以說是因為水平效應的緣故，使得利用搜尋方式的推論系統，無法應
付在開局階段所面臨的問題，在西洋棋方面，由於發展的較早，所以相關的討論甚多。
[Allis 1994] 
為了在中局戰鬥開始之前，能夠避免掉進對方所佈設的陷阱，或是為了布陣爭先，
以取得有利的形勢，幾百年來，象棋專家們就不斷地在對局樹上反覆推演各種可能的變
化。他們評估著手的利弊得失，然後去蕪存菁，把雙方較佳的攻擊與防禦方式，分類歸
納，集結成譜，以供後人作為研習的典範。 
但是目前的開局資料庫，只能倚賴開局樹來分析開局棋步[陳 1998]，事實上，棋譜
中還包含著許多其他有用的資訊，如對局者的棋力、所思考的時間和局後的檢討內容等
 8
3. 2007 年 2 月至 2007 年 4 月進: 
進行正確著法的分析工作，研究建立正確性高的知識庫 
4. 2007 年 5 月至 2007 年 7 月： 
殘局知識庫的建立 
第二年：智慧型電腦輔助學習系統 
製作互動性良好、便利性高的人機介面，以呈現系統化的棋局資料，讓使用者以循
序漸進，由淺入深的方式學習象棋，並且提供與主題相關的練習題、及棋力測驗題目，
使學習的過程更加生動有趣，並讓使用者融會貫通，進度如下： 
1. 2007 年 8 月至 2007 年 9 月：完成一象棋知識查詢及可配合象棋專家半自動輸
入專家知識和解說的系統 
2.  2007 年 11 月至 2008 年 1 月：研究及設計教學部分，主要目標為完成一單機
模式的智慧型象棋電腦輔助學習系統 
3.  2008 年 2 月至 2008 年 4 月：研究智慧型象棋電腦輔助學習系統 
4.  2008 年 5 月至 2008 年 7 月：建立象棋教學網站，轉換為網路模式，以方便
廣大的象棋學習者可以方便使用，並且網站上的內容可以不斷更新 
 
我們的成果如下： 
以人工方式產生棋譜，將會耗費許多人力，事實上，除了國內外各種比賽所產生的
棋譜之外，近年來網際網路蓬勃發展，各種網路應用不斷推出新的加值服務，網路象棋
對奕系統也隨著潮流應運而生。在國內有阿波羅、宏碁戲谷、棋侶等象棋網站、在國外
也有全球聞名的 ICCS 象棋網站、世界象棋聯盟網站、以及友誼象棋網站等，而全球最
大網站則是大陸的奕天網站，這些網站大都提供棋友上網下棋、觀棋、對談等功能。 
這些象棋網站，大部分都具有儲存棋局的功能，每天可產生數以千計的棋譜。使用
 10
評估函數，例如對局數中的子力權重表和棋子位置權重表，一般來說，都是以象棋基本
常識來設計的，若能透過知識庫來校正，將會有更正確而快速的靜態評估函數。知識庫
中資訊不夠完整的棋盤節點，亦可用來幫助搜尋之用。在對局樹中，由於 alpha-beta 
pruning 的效應，棋步的搜尋順序對於搜尋的速度會有很大的影響，若是已知某一盤面
有哪些棋步是較為合理而可先考慮的，有助於提昇搜尋的效率。這些都是本計劃的目前
的研究成果。 
除了全局棋譜的自動分析與整理之外，我們也針對殘局知識庫進行研究，由於複雜
度的增加，象棋程式在殘局的棋力只有不到五段的棋力，當與人類高手對奕時，如果沒
有在中局前取得優勢，則幾乎沒有機會取下勝利。西洋棋方面有鑑於此，包括 Ken 
Tompson 等學者，自 1980 年以來就投入西洋棋殘局的研究工作，而且也獲得了很好的
成績[Tompson 1986 1996][Herik 1985]，可說是西洋棋程式能打敗人類高手的主要原因ㄓ
ㄧ。而象棋程式近年來也開始針對殘局進行研究[陳 1995][Wu and Beal 2001a, 2001b, 
2001c][Fang, Hsu and hsu 2001]，但由於象棋複雜度較高，而且規則較為繁複，至今仍有
很大的進步空間。 
在計畫中，我們整理各種殘局譜，包括《夢入神機》、《金鵬十八變》（四卷本）、《適
情雅趣》、《韜略元機》、《淵深海闊》、《心武殘編》、《百變象棋譜》、《竹得齋象棋譜》、《棋
譜秘錄》、《爛柯神機》、《象戲譜》、《蕉竹齋》、《江湖秘譜》等等，並且以我們所發展出
的搜尋方法(如連將殺、停著殺等)和回溯分析法來做進一步的分析與校正，以建立一個
完整的殘局知識庫。 
下圖（圖 2）為觀看棋譜介面，使用者可利用此介面觀看棋譜，並且可以自行選擇
想要觀看的棋步或對棋譜做上下翻轉、左右翻轉等功能。 
 
 
圖 2：觀看棋譜介面 
 
下圖（圖 3）為棋譜搜尋介面，使用者可以選擇特定的項目或輸入關鍵字進行搜尋，
搜尋完成就會列出所有相關棋譜供使用者選擇。 
 
 12
 
 
圖 4：盤面搜尋介面 
 14
系統測試 
本系統將盤面搜尋資料表採用索引值加快搜尋效率，將測試有索引值與無索引值的
效能比較，並且比較搜尋時間的變化。以下將測試分為完全比對與模糊比對兩類： 
完整比對： 
下圖（圖 6）為測試用盤面，利用此盤面來測試，有索引值與無索引值的差別，並
且列出相關數據，因 SQL 會暫存搜尋過的相關資訊，所以每做一次測試會將搜尋暫存
清除，以求最正確數據。（資料數為 120 萬筆） 
 
 
圖 6：完整比對測試盤面 
 
 16
 18
四、結果及討論 
 
本計畫執行期間為兩年，成果如下： 
自動化棋局知識擷取系統及高等殘局知識庫，1. 研究如何歸納、分析棋局。2. 研
究建立可自動在網路上擷取棋局的代理人。3. 進行正確著法的分析工作，研究建立正確
性高的知識庫。4. 殘局知識庫的建立。5. 完成一象棋知識查詢及可配合象棋專家半自
動輸入專家知識和解說的系統。6. 研究及設計教學部分，主要目標為完成一單機模式的
智慧型象棋電腦輔助學習系統。7. 研究智慧型象棋電腦輔助學習系統。8. 建立象棋教
學網站，轉換為網路模式，以方便廣大的象棋學習者可以方便使用，並且網站上的內容
可以不斷更新。 
我們已經建立一個可自動在網路上擷取棋局的網站，可以歸納、分析、推論，而整
理棋局資料，並利用象棋程式進行正確著法的分析工作，執行全局棋譜的自動分析與整
理，並且建立正確性高的知識庫，達成計劃預定目標。 
五、計畫成果自評 
這個高等電腦象棋知識庫完成之後，不但可以提供大眾化的棋局資料庫及教學系
統，讓人們可以學習象棋，而在發展過程中，也將發展新的資料探勘、資料庫處理，智
慧型電腦輔助學習及電腦對局等理論，預計可有三篇以上的論文發表。這個知識庫更可
幫助電腦象棋的發展，讓電腦象棋的棋力更上一層樓。 
對於參與的工作人員，包括老師、博士生和碩士生，將在電腦象棋，知識庫設計，
智慧型電腦輔助學習，網路代理人等得到許多實作經驗及研究成果。 
綜合四、五兩節內容，本計劃確實達到預期的成果。 
 20
English 
1. Allis, L.V. (1994). Searching for Solutions in Games and Artificial 
Intelligence. Ph.D. Thesis, University of Limburg, Maastricht, The 
Netherlands. ISBN 90-9007488-0. 
2. Asian Xiangqi Federation. (2003). 
http://tysung.cjb.net/xq/index.html. 
3. Fang H.R., Hsu T.S., and Hsu S.C. (2001). Construction of Chinese Chess 
Endgame Databases by Retrograde Analysis. Computers and Games, Second 
International Conference, CG 2000 (eds. T.A. Marsland and I. Frank), 
pp. 96-114, Vol. 2063 of Lecture Notes in Computer Search. 
Springer-Verlag, Berlin. ISBN 3-540-43080-6. 
4. Herik, H.J., Herschberg, I.S. (1985). The construction of an 
omniscient endgame database. ICCA Journal Vol.8 NO. 2, pp. 66-87. 
5. Hiroyuki Iida, Makoto Sakuta, Jeff Rollason. (2002). Computer shogi. 
Artificial Intelligence 134, pp. 121-144. 
6. Hsu T.S. and Liu P.Y. (2002). Verification of endgame databases. ICGA 
Journal, Vol. 25 NO.3: 132-144 SEP 2002. 
7. Jacobs, N.J.D. (1989). XIAN, A Chinese Chess Program. Heuristic 
Programming in Artificial Intelligence. The first Computer Olympiad 
(eds. D.N.L. Levy and D.F. Beal), pp. 104-112. Ellis Horwood, 
Chichester. ISBN 0-7458-0778-X. 
8. Ke Y.F. (1995). A parallel hardware architecture for accelerating 
computer chess system. Ph. D. Thesis, Department of Electrical 
Engineering, National Taiwan University, Taiwan. (in Chinese) 
9. Thompson, K. (1986). Retrograde analysis of certain endgames, ICCA 
Journal, Vol. 9 No.3, pp. 131-139, ISSN 0920-234X. 
10. Thompson, K. (1996). 6-Piece endgames, ICCA Journal, Vol.19 No.4, 
pp.215-226. 
11. Ye, Chun and T.A. Marsland,(1992) Selective Extensions in Game-Tree 
Search, in Heuristic Programming in Artificial Intelligence 3, H.J. 
van den Herik and L.V. Allis (eds), Ellis Horwood, Chichester, UK, 
1992, 112-122. 
12. 38. Ye, Chun and T.A. Marsland, Experiments in Forward Pruning with 
Limited Extensions, ICCA Journal, Vol. 15, No. 2, 1992, 55-66. 
13. Tsao, K.M., Li, H. and Hsu, S.C. (1991). Design and Implementation 
of a Chinese Chess Program. Heuristic Programming in Artificial 
Intelligence. The second Computer Olympiad (eds. D.N.L. Levy and D.F. 
Beal), pp. 108-118. Ellis Horwood Ltd., Chichester, UK. ISBN 
0-13-382615-5. 
14. Tsao R.M. (1997). The Research of Distributed Searching Techniques 
of Chinese Chess. M.Sc. Thesis, Department of Computer Science and 
1. 出席國際學術會議心得報告 
                                                             
計畫編號  95-2221-E-309-016-MY2 
計畫名稱 象棋棋譜資訊檢索技術之研究 
出國人員姓名 
服務機關及職稱 
長榮大學資管系許舜欽教授 
會議時間地點 2007/9/4—2007/9/7, 日本熊本市 
會議名稱 ICICIC2007, International Conference on Innovative Computing, Information and Control
發表論文題目 Pattern matching in Go game Records 
 
一、參加會議經過 
 
參加ICICIC2007, International Conference on Innovative Computing, Information and Control國
際研討會，發表圍棋棋譜棋型比對論文。 
 
二、與會心得 
 
電腦科技日新月異，此會議中主題包括創新計算，資訊與控制，是目前資訊界最熱門的領域。
參加此次會議，感覺受益良多。 
 
三、考察參觀活動(無是項活動者省略) 
無 
 
四、建議 
 
無 
for finding game records containing a desired 
query pattern from a lot of game records. In 
this system, input is a query pattern and the 
output is game records containing this query 
pattern. From these output game records, game 
record information, such as the name of the 
game record, move sequences, player names 
and results, can be obtained.  
This article is organized as follows. The 
framework of proposed idea is shown in 
Section 2. Section 3 presents a novel Go pattern 
matching algorithm. Section 4 gives an index 
structure to increase the speed of Go pattern 
matching. Finally, Section 5 gives conclusions. 
2. Go Game Record Information Retrieval 
System 
The goal of this work was to develop an efficient Go 
game record information retrieval system that uses the 
proposed indexing structure. Figure 1 shows the system 
framework. Ability to process both pattern and text 
queries is a critical feature of the system, as it allows 
users to search information with more query forms. For 
example, a user may wants to identify the winning rate 
when a specific player uses a specific opening pattern, by 
sending a query contenting player name, result, and the 
opening pattern. The related game records will output, 
and the winning rate can be then be computed. It is 
practicable for the system to execute a pattern query with 
a logical operation such as and, or, not, etc. The 
proposed structure increases the speed of these 
operations. 
 
Fig. 1. Go game record information retrieval system. 
Figure 2 presents the procedure and major 
components of the proposed system. This 
approach is based on a sequential matching 
algorithm, which is used when construction the 
database and during searching. In addition to 
the searching algorithm, two principal factors 
affect system performance: feature patterns, 
and a feature 
tree.
 
 
Fig. 2. Constructing an index structure. 
 
3. A Go pattern matching algorithm 
Before pattern matching, each game board and 
n×m query pattern is transformed into a 19×19 
array and an n×m array, respectively. Each item 
in an array is represented by 3 bits. For 
example, Figure 3 shows a 5×5 query patterns. 
Each position denoted by A, B and C can be a 
black stone or empty. Three bits are used to 
express four possible states at every 
intersection. Bit 1 indicates that this point could 
be empty or not; bit 2 signifies that this point 
could be black stone or not; bit 3 denotes that 
this point could be white stone or not. Each 
number in the array is generated from 3 bits. 
For example, a number 3 in the array means 
that its relative binary number is 011, indicating 
that this point could be black stone or empty. 
 
11111 
14131 
21113 
14131 
11111  
   
Fig. 3. Format of a query pattern. 
The KMP string matching algorithm avoids 
unnecessary matching. [10] However, the KMP 
algorithm is a one-dimensional string matching 
algorithm. Hence, a 2-D pattern should be 
regarded as a set of 1-D patterns. The Go 
pattern matching algorithm is processed along 
time cost is too long for real applications. This 
problem is solved by indexing these game 
boards. 
Table 2. The environment of experiment. 
 
Relation between searching time and pattern size
0
10
20
30
3x3 5x5 7x7 9x9 11x
11
13x
13
15x
15
17x
17
19x
19
Sizes of query patterns
Se
arc
hin
g T
im
e(s
)
 
Fig. 6. Searching time at different query pattern sizes. 
4. Feature Patterns and Index Structure 
To construct index structure on the game record database, 
the features of many significant query patterns should be 
extracted and used as the index key. The proposed 
approach uses 400 featured patterns. Feature patterns are 
some patterns that appear frequently in Go games. These 
patterns are part of pattern database in the computer Go 
program JIMMY, which was developed from 1994[19]. 
The pattern database is maintained by S.J. Yen, who is a 
Taiwan amateur 6-dan Go player. Almost all significant 
moves can be recognized by the pattern database system. 
Each feature pattern has its own meaning in Go games 
and can be considered as jump, knight move, or diagonal 
move in a Go game; however, most of them are more 
complicated. 
These feature patterns are good indexing keys. 
Each has its own characteristics and meanings. 
By using them and a suitable indexing structure, 
game records can be classified systematically.  
The feature patterns are integrated by a popular 
index structure: the inverted list. [4] The 
proposed sequential matching algorithm is 
applied to find the game boards containing each 
feature pattern, and build an inverted file for 
our game records. (Fig. 7.) 
 
 
Computer Pentium 4, 3.0 G, 1GB RAM 
Operating System Windows XP 
No. of Game record 6,292 game records(6.7MB)  
No. of game board 1,341,801 game boards(790.3MB)
Programming language 
& Database 
C++ 
MySQL 4.0.15 
 
Fig. 7. Building inverted file using feature patterns. 
All game boards were classified according to 
the feature pattern(s) they contain. This will be 
a good characteristic for matching processing. 
Almost every reasonable query pattern contains 
at least one feature pattern, and it is easy to 
perform logical operations such like “AND” or 
“OR” under this structure. 
With a desired query pattern, we first check 
which feature patterns it contains. This can be 
done quickly by algorithm in [4]. Then we only 
need to apply the proposed Go pattern 
matching algorithm on this query pattern in 
those game boards containing the result feature 
patterns. For example, if the pattern matcher 
shows that the query pattern contains feature 
pattern 1 and feature pattern 3, we will only 
search those game boards in the set (1∩3). 
5. Conclusion 
This article presented a novel a Go pattern matching 
algorithm. If query patterns are edge patterns or corner 
patterns, game records containing this query pattern can 
  
Knowledge Inferencing
on Chinese Chess Endgames
Bo-Nian Chen1, Pangfeng Liu1, Shun-Chin Hsu2, and Tsan-sheng Hsu3,
1 Department of Computer Science and Information Engineering,
National Taiwan University, Taipei
{r92025,pangfeng}@csie.ntu.edu.tw
2 Department of Information Management,
Chang Jung Christian University, Tainan
schsu@mail.cjcu.edu.tw
3 Institute of Information Science, Academia Sinica, Taipei
tshsu@iis.sinica.edu.tw
Abstract. Several Chinese chess programs exhibit grandmaster playing
skills in the opening and middle game. However, in the endgame phase,
the programs only apply ordinal search algorithms; hence, they usually
cannot exchange pieces correctly. Some researchers use retrograde algo-
rithms to solve endgames with a limited number of attack pieces, but this
approach is often not practical in a real tournament. In a grandmaster
game, the players typically perform a sequence of material exchanges be-
tween the middle game and the endgame, so computer programs can be
useful. However, there are about 185 million possible combinations of ma-
terial in Chinese chess, and many hard endgames are inconclusive even to
human masters. To resolve this problem, we propose a novel strategy that
applies a knowledge-inferencing algorithm on a suﬃciently small database
to determine whether endgames with a certain combination of material are
advantageous to a player. Our experimental results show that the perfor-
mance of the algorithm is good and reliable. Therefore, building a large
knowledge database of material combinations is recommended.
1 Introduction
Several Chinese chess programs are playing at a par with human masters or
grandmasters [14]. Most algorithms that are incorporated in Western computer-
chess programs are also suitable for Chinese chess programs. In the opening
game, the most popular strategy involves building an opening book, either by
collecting a large number of games or by inputting only master-level opening
moves. The strategy is successful, in particular for general opening play. If a po-
sition is not in the book, the most important component, the search engine, takes
over and computes the best move by evaluating hundreds of millions of positions.
 Corresponding author.
H.J. van den Herik et al. (Eds.): CG 2008, LNCS 5131, pp. 180–191, 2008.
c© IFIP International Federation for Information Processing 2008
182 B.-N. Chen et al.
still in position and retrograde strategies cannot be applied to them; and (2) the
posterior phase, which can be solved completely by retrograde algorithms.
In particular, we propose a novel strategy that applies a knowledge-inferencing
mechanism on a small knowledge database of material combinations to generate
a database of material for the prior phase of a practical endgame.
The remainder of this paper is organized as follows. In Sect. 2, we describe the
knowledge database of material combinations and the implemented knowledge-
inferencing technique. In Sect. 3, we introduce a probabilistic model for predict-
ing unknown material states. In Sect. 4, we build a practical knowledge database
of material combinations. In Sect. 5, we take the data used by Contemplation
[15] as our experimental data and report the results of applying our model to it.
Then, in Sect. 6, we present our conclusions.
2 Constructing a Knowledge Database
To construct a practical knowledge database of material combinations, henceforth
called a material database, we ﬁrst need to construct a basic database. Instead
of adding all data manually, we utilize knowledge-inferencing techniques in the
construction phase to reduce the workload and the time required for the task.
2.1 Knowledge Database of Material Combinations
The word material denotes all pieces that appear in a speciﬁc position in both
Western and Chinese chess. The material state of a position is an evaluation
measurement that only considers material in the given position, not with respect
to diﬀerent locations.
For simplicity, we assume that two players in an endgame play either the
attacking role or the defending role. The attacking role, which is called the
attacking player, is deﬁned as the player that has more attack power than the
player with the defending role, who is called the defending player. We deﬁne 5
categories of material states for a material combination.
WIN: The score when the attacking player usually wins.
EASY WIN: The score when the attacking player wins in many cases, but
draws in some cases.
CHANCE WIN: The score that ends in a draw in most cases, but the attack-
ing player wins in some cases.
HARD WIN: The score when the attacking player seldom wins.
UNKNOWN: The score when the attack power of either side is strong enough
to capture the king of the opposite side; hence information about the material
is not very useful.
A knowledge database of material combinations consists of the defending ma-
terials that players use. Each item of defending material is mapped to an attack
ﬁle that includes all possible attack materials. Attack material is deﬁned as the
pieces that belong to the attacking player. The possible number of materials held
184 B.-N. Chen et al.
1. Top-pawn: the pawn stays behind the river line or the pawn line of the
opposite side and has yet to cross the river. It moves forward 3 steps at
most.
2. Low-pawn: the pawn moves forward 4 or 5 steps.
3. Bottom-pawn: the pawn reaches the ﬁnal rank. Note that a pawn must move
forward 6 steps to reach the ﬁnal rank.
In general, a top-pawn is more useful than a low-pawn and a low-pawn is more
powerful than a bottom-pawn. Furthermore, if we know the state of material with
one bottom-pawn, we cannot obtain a better result by adding more bottom-
pawns in all cases.
There is a similar rule for low-pawns. If we know the state of material with
two low-pawns, we cannot obtain a better result by adding more low-pawns
in most cases. There are two possible reasons for this. First, if low-pawns can
win, then, based on past experience, only two low-pawns are suﬃcient to win.
Second, if low-pawns cannot move into the palace or are lower than the king,
adding low-pawns will not solve the problem. For example, the results of the
material combinations KPPKGGMM and KPPPKGGMM are a CHANCE WIN
when all pawns are low-pawns. In our basic database, there are 16,705 material
combinations where the attacking player has two low-pawns, and there are only
361 combinations where the result of corresponding material with three low-
pawns is diﬀerent. However, when there is one top-pawn in the material, the
attacking player can always gain an advantage by adding another top-pawn.
The pawn-inferencing algorithm is a game-speciﬁc inferencing scheme that
is only suitable for Chinese chess. It uses the knowledge of bottom-pawns and
low-pawns. If we have the result of material containing one bottom-pawn or
two low-pawns, we can use the algorithm to copy the results to more bottom-
pawns or low-pawns until the number of bottom-pawns plus low-pawns equals
5. The algorithm reduces the work involved in creating the basic database by
almost half. This is because the combinations of materials with more than one
bottom-pawn or more than two low-pawns that can be generated automatically
are approximately equal to the combinations of materials with one bottom-pawn
or less than or equal to two low-pawns.
3 Predicting Unknown Material States
Although a large number of original unknown material states can be inferred
by methods stated in Sect. 2, we still need a systematic strategy for handling
arbitrary unknown materials. The algorithm that predicts arbitrary unknown
materials is called the unknown state predictor.
3.1 Human Evaluation of Unknown Positions
By exchanging pieces, human experts can accurately infer the results of material
combinations that were previously unheard of. For example, KHKGGMM is
generally a draw. When the result of the material combination KRHKRGGMM
186 B.-N. Chen et al.
exchanges result in the same material state, we choose the one with the highest
probability. If we cannot ﬁnd the result in the database, the material state of
the speciﬁed material remains UNKNOWN.
The algorithm computes two acceptable exchanges: (1) the attacking player
exchanges pieces actively, and (2) the defending player exchanges pieces actively.
Each exchange reaches its own material state. We deﬁne ﬁve numerical score
values, 0, 1, 2, 3, and 4, which correspond to UNKNOWN, WIN, EASY WIN,
CHANCE WIN, and HARD WIN, respectively. If the material states of both
sides are known, the ﬁnal score of the query material is computed by the formula
V = (Va + Vd)/2. The values Va and Vd represent the results of the attacking
player and the defending player exchanging pieces actively, respectively. V is
the ﬁnal score. If one of the material states is unknown, we choose the known
state as our result. If both are unknown, the result remains unknown. This
formula simply computes the average of the two results. It is worth noting that,
because we use division on integers, the result leans towards WIN rather than
HARD WIN, due to the setting of the numerical scores.
4 Constructing a Practical Knowledge Database of
Material Combinations
We use two algorithms, material state extension and unknown state predictor,
to determine the advantage of unknown materials.
To construct a knowledge database of material combinations, we simply gen-
erate each material pair as input for the material state extension algorithm,
which can only be applied to WIN and HARD WIN in the basic database. If the
algorithm cannot ﬁnd the answer, we input the material pair to the unknown
state predictor algorithm to retrieve an approximate result value.
However, the value of some materials may still be unknown after applying
the unknown state predictor algorithm. Finally, we use a heuristic algorithm
to identify the advantage or disadvantage of the input material. We compute
a player’s attack power by the formula 10 × Rook + 5 × (Horse + Cannon) +
1× Pawn. In the formula, Rook, Horse, Cannon, and Pawn are the numbers of
the attacking pieces. The diﬀerence between the attack power of the two players
is calculated as the formula D = RedPower − BlackPower. RedPower is the
attack power of the attacking player, and BlackPower is that of the defending
player. When D is more than or equal to 10, we reduce the value of the material
state by one. When D is less than 7 and the predicted result is UNKNOWN,
we set it to be CHANCE WIN. This simple algorithm is used to ﬁne tune the
materials when the attacking player has a clear advantage or the value of the
materials cannot be derived by the unknown state predictor algorithm.
The most practical usage of the knowledge database of material combinations
is to retrieve material scores as a part of the evaluation function during the
search phase. When a middle game position changes to an endgame position
due to piece exchange, the search algorithm can select better endgame positions
with the aid of our material database. However, there may be some positions
188 B.-N. Chen et al.
(2) unknown state predictor. The ﬁrst experiment demonstrates the result of
combining the two algorithms. The second experiment demonstrates the result
of only using the unknown state predictor algorithm.
5.2 Experimental Results
In our results, we denote UNKNOWN by U, WIN by 1, EASY WIN by 2,
CHANCE WIN by 3, and HARD WIN by 4. The descriptions and results are
shown in Table 2. We deﬁne the following variables to measure our model’s perfor-
mance: (1) total correct number, which records the number of cases where the out-
put scores are equal to the transformed answer; (2) tolerant correct number, which
ignores the error between WIN and EASY WIN and also between CHANCE
WIN and HARD WIN; and (3) slight error number, which records the errors be-
tween WIN and EASY WIN and also between CHANCE WIN and HARD WIN.
For our algorithm, we need to choose a suitable value of PLB, described in
Subsection 3.3. Table 1 shows the relationship between diﬀerent PLBs and the
ratio of tolerant correct number to the total number of data items, i.e., 4775.
This is the most important measurement, when using only the unknown state
predictor algorithm. As the results show, the value 10% is the best for our test
data. We suggest that users set the PLB value between 10% and to 30%.
The total correct number is 2,169 or 45.42%. The tolerant correct number is
4,200 or 87.96%. The slight error number is 2,031 or 42.53%.
In practical usage, themost importantmeasurement is tolerant correct number
because it identiﬁes the categories of either WIN and EASY WIN, which are
Table 1. The relationships between PLBs from 0 to 100 and the corresponding ratio
of tolerant correct number to the total number of data items
PLB 0 10 20 30 40 50 60 70 80 90 100
% 82.07 84.50 84.13 83.12 82.28 81.53 80.04 76.04 65.13 39.25 39.04
Table 2. Comparison of human annotated answers and the algorithm generated results
for END4775. The horizontal axis represents the number of human annotated material
states. The vertical axis represents the number of material states generated by the
algorithm. U represents an unknown state.
U 1 2 3 4 Sum
U 0 35 55 195 40 325
1 0 990 402 52 0 1444
2 0 1278 663 120 17 2078
3 0 31 30 233 330 624
4 0 0 0 21 283 304
Sum 0 2334 1150 621 670 4775
190 B.-N. Chen et al.
Table 3. Results using only the unknown state predictor algorithm
U 1 2 3 4 Sum
U 0 76 30 188 31 325
1 0 1302 30 112 0 1444
2 0 1615 281 158 24 2078
3 0 35 80 261 248 624
4 0 4 2 32 266 304
Sum 0 3032 423 751 569 4775
Note that the ratios of the tolerant correct numbers to the total number of
data items are similar among the two tests, and so do the slight error number
values. This shows that the data input to the unknown state predictor algorithm
in the ﬁrst experiment is really hard. The diﬀerence between the ratio of the
tolerant correct number to the total number of data items of the two experiments
is 3.46%. This indicates that the advantage predicted by our predictor algorithm
is still reliable, even for hard data.
The space used to store all defense materials up to one strong piece plus
a pawn and all combinations of defense pieces and their corresponding attack
materials is 2.44M bytes.
6 Conclusions
Endgame problems represent a diﬃcult issue in both Western chess and Chi-
nese chess. The largest Chinese chess endgame database built by a retrograde
algorithm currently contains only two strong attack pieces on each side. How-
ever, the endgame results show that many strong attack pieces exist. We have
designed a knowledge inferencing scheme to build a practical material database
for the initial phase of the endgame. In addition, we use the material state
extension algorithm and the unknown state predictor algorithm to construct
endgames with many strong attack pieces. Our experimental results show that
the performance of our algorithms is good and reliable. When predicting the
advantage of a material combination with a large number of pieces, we may
conclude from the results above that our material state extension algorithm is
an eﬀective approach. However, if the extension algorithm fails, the predictor
algorithm takes over and reports an inferred solution. This strategy can be used
to solve the problem when a complete knowledge database of an endgame with a
large amount of material cannot be built using conventional computer methods,
and only advantage information is required to know for the material state.
Acknowledgments. This research was partially supported by National Science
Council, Grants 95-2221-E-001-004 and 96-2221-E-001-004.
1. 出席國際學術會議心得報告 
                                                             
計畫編號  95-2221-E-309-016-MY2 
計畫名稱 象棋棋譜資訊檢索技術之研究 
出國人員姓名 
服務機關及職稱 
長榮大學資管系許舜欽教授 
會議時間地點 2007/9/4—2007/9/7, 日本熊本市 
會議名稱 ICICIC2007, International Conference on Innovative Computing, Information and Control
發表論文題目 Pattern matching in Go game Records 
 
一、參加會議經過 
 
參加ICICIC2007, International Conference on Innovative Computing, Information and Control國
際研討會，發表圍棋棋譜棋型比對論文。 
 
二、與會心得 
 
電腦科技日新月異，此會議中主題包括創新計算，資訊與控制，是目前資訊界最熱門的領域。
參加此次會議，感覺受益良多。 
 
三、考察參觀活動(無是項活動者省略) 
無 
 
四、建議 
 
無 
for finding game records containing a desired 
query pattern from a lot of game records. In 
this system, input is a query pattern and the 
output is game records containing this query 
pattern. From these output game records, game 
record information, such as the name of the 
game record, move sequences, player names 
and results, can be obtained.  
This article is organized as follows. The 
framework of proposed idea is shown in 
Section 2. Section 3 presents a novel Go pattern 
matching algorithm. Section 4 gives an index 
structure to increase the speed of Go pattern 
matching. Finally, Section 5 gives conclusions. 
2. Go Game Record Information Retrieval 
System 
The goal of this work was to develop an efficient Go 
game record information retrieval system that uses the 
proposed indexing structure. Figure 1 shows the system 
framework. Ability to process both pattern and text 
queries is a critical feature of the system, as it allows 
users to search information with more query forms. For 
example, a user may wants to identify the winning rate 
when a specific player uses a specific opening pattern, by 
sending a query contenting player name, result, and the 
opening pattern. The related game records will output, 
and the winning rate can be then be computed. It is 
practicable for the system to execute a pattern query with 
a logical operation such as and, or, not, etc. The 
proposed structure increases the speed of these 
operations. 
 
Fig. 1. Go game record information retrieval system. 
Figure 2 presents the procedure and major 
components of the proposed system. This 
approach is based on a sequential matching 
algorithm, which is used when construction the 
database and during searching. In addition to 
the searching algorithm, two principal factors 
affect system performance: feature patterns, 
and a feature 
tree.
 
 
Fig. 2. Constructing an index structure. 
 
3. A Go pattern matching algorithm 
Before pattern matching, each game board and 
n×m query pattern is transformed into a 19×19 
array and an n×m array, respectively. Each item 
in an array is represented by 3 bits. For 
example, Figure 3 shows a 5×5 query patterns. 
Each position denoted by A, B and C can be a 
black stone or empty. Three bits are used to 
express four possible states at every 
intersection. Bit 1 indicates that this point could 
be empty or not; bit 2 signifies that this point 
could be black stone or not; bit 3 denotes that 
this point could be white stone or not. Each 
number in the array is generated from 3 bits. 
For example, a number 3 in the array means 
that its relative binary number is 011, indicating 
that this point could be black stone or empty. 
 
11111 
14131 
21113 
14131 
11111  
   
Fig. 3. Format of a query pattern. 
The KMP string matching algorithm avoids 
unnecessary matching. [10] However, the KMP 
algorithm is a one-dimensional string matching 
algorithm. Hence, a 2-D pattern should be 
regarded as a set of 1-D patterns. The Go 
pattern matching algorithm is processed along 
time cost is too long for real applications. This 
problem is solved by indexing these game 
boards. 
Table 2. The environment of experiment. 
 
Relation between searching time and pattern size
0
10
20
30
3x3 5x5 7x7 9x9 11x
11
13x
13
15x
15
17x
17
19x
19
Sizes of query patterns
Se
arc
hin
g T
im
e(s
)
 
Fig. 6. Searching time at different query pattern sizes. 
4. Feature Patterns and Index Structure 
To construct index structure on the game record database, 
the features of many significant query patterns should be 
extracted and used as the index key. The proposed 
approach uses 400 featured patterns. Feature patterns are 
some patterns that appear frequently in Go games. These 
patterns are part of pattern database in the computer Go 
program JIMMY, which was developed from 1994[19]. 
The pattern database is maintained by S.J. Yen, who is a 
Taiwan amateur 6-dan Go player. Almost all significant 
moves can be recognized by the pattern database system. 
Each feature pattern has its own meaning in Go games 
and can be considered as jump, knight move, or diagonal 
move in a Go game; however, most of them are more 
complicated. 
These feature patterns are good indexing keys. 
Each has its own characteristics and meanings. 
By using them and a suitable indexing structure, 
game records can be classified systematically.  
The feature patterns are integrated by a popular 
index structure: the inverted list. [4] The 
proposed sequential matching algorithm is 
applied to find the game boards containing each 
feature pattern, and build an inverted file for 
our game records. (Fig. 7.) 
 
 
Computer Pentium 4, 3.0 G, 1GB RAM 
Operating System Windows XP 
No. of Game record 6,292 game records(6.7MB)  
No. of game board 1,341,801 game boards(790.3MB)
Programming language 
& Database 
C++ 
MySQL 4.0.15 
 
Fig. 7. Building inverted file using feature patterns. 
All game boards were classified according to 
the feature pattern(s) they contain. This will be 
a good characteristic for matching processing. 
Almost every reasonable query pattern contains 
at least one feature pattern, and it is easy to 
perform logical operations such like “AND” or 
“OR” under this structure. 
With a desired query pattern, we first check 
which feature patterns it contains. This can be 
done quickly by algorithm in [4]. Then we only 
need to apply the proposed Go pattern 
matching algorithm on this query pattern in 
those game boards containing the result feature 
patterns. For example, if the pattern matcher 
shows that the query pattern contains feature 
pattern 1 and feature pattern 3, we will only 
search those game boards in the set (1∩3). 
5. Conclusion 
This article presented a novel a Go pattern matching 
algorithm. If query patterns are edge patterns or corner 
patterns, game records containing this query pattern can 
  
Knowledge Inferencing
on Chinese Chess Endgames
Bo-Nian Chen1, Pangfeng Liu1, Shun-Chin Hsu2, and Tsan-sheng Hsu3,
1 Department of Computer Science and Information Engineering,
National Taiwan University, Taipei
{r92025,pangfeng}@csie.ntu.edu.tw
2 Department of Information Management,
Chang Jung Christian University, Tainan
schsu@mail.cjcu.edu.tw
3 Institute of Information Science, Academia Sinica, Taipei
tshsu@iis.sinica.edu.tw
Abstract. Several Chinese chess programs exhibit grandmaster playing
skills in the opening and middle game. However, in the endgame phase,
the programs only apply ordinal search algorithms; hence, they usually
cannot exchange pieces correctly. Some researchers use retrograde algo-
rithms to solve endgames with a limited number of attack pieces, but this
approach is often not practical in a real tournament. In a grandmaster
game, the players typically perform a sequence of material exchanges be-
tween the middle game and the endgame, so computer programs can be
useful. However, there are about 185 million possible combinations of ma-
terial in Chinese chess, and many hard endgames are inconclusive even to
human masters. To resolve this problem, we propose a novel strategy that
applies a knowledge-inferencing algorithm on a suﬃciently small database
to determine whether endgames with a certain combination of material are
advantageous to a player. Our experimental results show that the perfor-
mance of the algorithm is good and reliable. Therefore, building a large
knowledge database of material combinations is recommended.
1 Introduction
Several Chinese chess programs are playing at a par with human masters or
grandmasters [14]. Most algorithms that are incorporated in Western computer-
chess programs are also suitable for Chinese chess programs. In the opening
game, the most popular strategy involves building an opening book, either by
collecting a large number of games or by inputting only master-level opening
moves. The strategy is successful, in particular for general opening play. If a po-
sition is not in the book, the most important component, the search engine, takes
over and computes the best move by evaluating hundreds of millions of positions.
 Corresponding author.
H.J. van den Herik et al. (Eds.): CG 2008, LNCS 5131, pp. 180–191, 2008.
c© IFIP International Federation for Information Processing 2008
182 B.-N. Chen et al.
still in position and retrograde strategies cannot be applied to them; and (2) the
posterior phase, which can be solved completely by retrograde algorithms.
In particular, we propose a novel strategy that applies a knowledge-inferencing
mechanism on a small knowledge database of material combinations to generate
a database of material for the prior phase of a practical endgame.
The remainder of this paper is organized as follows. In Sect. 2, we describe the
knowledge database of material combinations and the implemented knowledge-
inferencing technique. In Sect. 3, we introduce a probabilistic model for predict-
ing unknown material states. In Sect. 4, we build a practical knowledge database
of material combinations. In Sect. 5, we take the data used by Contemplation
[15] as our experimental data and report the results of applying our model to it.
Then, in Sect. 6, we present our conclusions.
2 Constructing a Knowledge Database
To construct a practical knowledge database of material combinations, henceforth
called a material database, we ﬁrst need to construct a basic database. Instead
of adding all data manually, we utilize knowledge-inferencing techniques in the
construction phase to reduce the workload and the time required for the task.
2.1 Knowledge Database of Material Combinations
The word material denotes all pieces that appear in a speciﬁc position in both
Western and Chinese chess. The material state of a position is an evaluation
measurement that only considers material in the given position, not with respect
to diﬀerent locations.
For simplicity, we assume that two players in an endgame play either the
attacking role or the defending role. The attacking role, which is called the
attacking player, is deﬁned as the player that has more attack power than the
player with the defending role, who is called the defending player. We deﬁne 5
categories of material states for a material combination.
WIN: The score when the attacking player usually wins.
EASY WIN: The score when the attacking player wins in many cases, but
draws in some cases.
CHANCE WIN: The score that ends in a draw in most cases, but the attack-
ing player wins in some cases.
HARD WIN: The score when the attacking player seldom wins.
UNKNOWN: The score when the attack power of either side is strong enough
to capture the king of the opposite side; hence information about the material
is not very useful.
A knowledge database of material combinations consists of the defending ma-
terials that players use. Each item of defending material is mapped to an attack
ﬁle that includes all possible attack materials. Attack material is deﬁned as the
pieces that belong to the attacking player. The possible number of materials held
184 B.-N. Chen et al.
1. Top-pawn: the pawn stays behind the river line or the pawn line of the
opposite side and has yet to cross the river. It moves forward 3 steps at
most.
2. Low-pawn: the pawn moves forward 4 or 5 steps.
3. Bottom-pawn: the pawn reaches the ﬁnal rank. Note that a pawn must move
forward 6 steps to reach the ﬁnal rank.
In general, a top-pawn is more useful than a low-pawn and a low-pawn is more
powerful than a bottom-pawn. Furthermore, if we know the state of material with
one bottom-pawn, we cannot obtain a better result by adding more bottom-
pawns in all cases.
There is a similar rule for low-pawns. If we know the state of material with
two low-pawns, we cannot obtain a better result by adding more low-pawns
in most cases. There are two possible reasons for this. First, if low-pawns can
win, then, based on past experience, only two low-pawns are suﬃcient to win.
Second, if low-pawns cannot move into the palace or are lower than the king,
adding low-pawns will not solve the problem. For example, the results of the
material combinations KPPKGGMM and KPPPKGGMM are a CHANCE WIN
when all pawns are low-pawns. In our basic database, there are 16,705 material
combinations where the attacking player has two low-pawns, and there are only
361 combinations where the result of corresponding material with three low-
pawns is diﬀerent. However, when there is one top-pawn in the material, the
attacking player can always gain an advantage by adding another top-pawn.
The pawn-inferencing algorithm is a game-speciﬁc inferencing scheme that
is only suitable for Chinese chess. It uses the knowledge of bottom-pawns and
low-pawns. If we have the result of material containing one bottom-pawn or
two low-pawns, we can use the algorithm to copy the results to more bottom-
pawns or low-pawns until the number of bottom-pawns plus low-pawns equals
5. The algorithm reduces the work involved in creating the basic database by
almost half. This is because the combinations of materials with more than one
bottom-pawn or more than two low-pawns that can be generated automatically
are approximately equal to the combinations of materials with one bottom-pawn
or less than or equal to two low-pawns.
3 Predicting Unknown Material States
Although a large number of original unknown material states can be inferred
by methods stated in Sect. 2, we still need a systematic strategy for handling
arbitrary unknown materials. The algorithm that predicts arbitrary unknown
materials is called the unknown state predictor.
3.1 Human Evaluation of Unknown Positions
By exchanging pieces, human experts can accurately infer the results of material
combinations that were previously unheard of. For example, KHKGGMM is
generally a draw. When the result of the material combination KRHKRGGMM
186 B.-N. Chen et al.
exchanges result in the same material state, we choose the one with the highest
probability. If we cannot ﬁnd the result in the database, the material state of
the speciﬁed material remains UNKNOWN.
The algorithm computes two acceptable exchanges: (1) the attacking player
exchanges pieces actively, and (2) the defending player exchanges pieces actively.
Each exchange reaches its own material state. We deﬁne ﬁve numerical score
values, 0, 1, 2, 3, and 4, which correspond to UNKNOWN, WIN, EASY WIN,
CHANCE WIN, and HARD WIN, respectively. If the material states of both
sides are known, the ﬁnal score of the query material is computed by the formula
V = (Va + Vd)/2. The values Va and Vd represent the results of the attacking
player and the defending player exchanging pieces actively, respectively. V is
the ﬁnal score. If one of the material states is unknown, we choose the known
state as our result. If both are unknown, the result remains unknown. This
formula simply computes the average of the two results. It is worth noting that,
because we use division on integers, the result leans towards WIN rather than
HARD WIN, due to the setting of the numerical scores.
4 Constructing a Practical Knowledge Database of
Material Combinations
We use two algorithms, material state extension and unknown state predictor,
to determine the advantage of unknown materials.
To construct a knowledge database of material combinations, we simply gen-
erate each material pair as input for the material state extension algorithm,
which can only be applied to WIN and HARD WIN in the basic database. If the
algorithm cannot ﬁnd the answer, we input the material pair to the unknown
state predictor algorithm to retrieve an approximate result value.
However, the value of some materials may still be unknown after applying
the unknown state predictor algorithm. Finally, we use a heuristic algorithm
to identify the advantage or disadvantage of the input material. We compute
a player’s attack power by the formula 10 × Rook + 5 × (Horse + Cannon) +
1× Pawn. In the formula, Rook, Horse, Cannon, and Pawn are the numbers of
the attacking pieces. The diﬀerence between the attack power of the two players
is calculated as the formula D = RedPower − BlackPower. RedPower is the
attack power of the attacking player, and BlackPower is that of the defending
player. When D is more than or equal to 10, we reduce the value of the material
state by one. When D is less than 7 and the predicted result is UNKNOWN,
we set it to be CHANCE WIN. This simple algorithm is used to ﬁne tune the
materials when the attacking player has a clear advantage or the value of the
materials cannot be derived by the unknown state predictor algorithm.
The most practical usage of the knowledge database of material combinations
is to retrieve material scores as a part of the evaluation function during the
search phase. When a middle game position changes to an endgame position
due to piece exchange, the search algorithm can select better endgame positions
with the aid of our material database. However, there may be some positions
188 B.-N. Chen et al.
(2) unknown state predictor. The ﬁrst experiment demonstrates the result of
combining the two algorithms. The second experiment demonstrates the result
of only using the unknown state predictor algorithm.
5.2 Experimental Results
In our results, we denote UNKNOWN by U, WIN by 1, EASY WIN by 2,
CHANCE WIN by 3, and HARD WIN by 4. The descriptions and results are
shown in Table 2. We deﬁne the following variables to measure our model’s perfor-
mance: (1) total correct number, which records the number of cases where the out-
put scores are equal to the transformed answer; (2) tolerant correct number, which
ignores the error between WIN and EASY WIN and also between CHANCE
WIN and HARD WIN; and (3) slight error number, which records the errors be-
tween WIN and EASY WIN and also between CHANCE WIN and HARD WIN.
For our algorithm, we need to choose a suitable value of PLB, described in
Subsection 3.3. Table 1 shows the relationship between diﬀerent PLBs and the
ratio of tolerant correct number to the total number of data items, i.e., 4775.
This is the most important measurement, when using only the unknown state
predictor algorithm. As the results show, the value 10% is the best for our test
data. We suggest that users set the PLB value between 10% and to 30%.
The total correct number is 2,169 or 45.42%. The tolerant correct number is
4,200 or 87.96%. The slight error number is 2,031 or 42.53%.
In practical usage, themost importantmeasurement is tolerant correct number
because it identiﬁes the categories of either WIN and EASY WIN, which are
Table 1. The relationships between PLBs from 0 to 100 and the corresponding ratio
of tolerant correct number to the total number of data items
PLB 0 10 20 30 40 50 60 70 80 90 100
% 82.07 84.50 84.13 83.12 82.28 81.53 80.04 76.04 65.13 39.25 39.04
Table 2. Comparison of human annotated answers and the algorithm generated results
for END4775. The horizontal axis represents the number of human annotated material
states. The vertical axis represents the number of material states generated by the
algorithm. U represents an unknown state.
U 1 2 3 4 Sum
U 0 35 55 195 40 325
1 0 990 402 52 0 1444
2 0 1278 663 120 17 2078
3 0 31 30 233 330 624
4 0 0 0 21 283 304
Sum 0 2334 1150 621 670 4775
190 B.-N. Chen et al.
Table 3. Results using only the unknown state predictor algorithm
U 1 2 3 4 Sum
U 0 76 30 188 31 325
1 0 1302 30 112 0 1444
2 0 1615 281 158 24 2078
3 0 35 80 261 248 624
4 0 4 2 32 266 304
Sum 0 3032 423 751 569 4775
Note that the ratios of the tolerant correct numbers to the total number of
data items are similar among the two tests, and so do the slight error number
values. This shows that the data input to the unknown state predictor algorithm
in the ﬁrst experiment is really hard. The diﬀerence between the ratio of the
tolerant correct number to the total number of data items of the two experiments
is 3.46%. This indicates that the advantage predicted by our predictor algorithm
is still reliable, even for hard data.
The space used to store all defense materials up to one strong piece plus
a pawn and all combinations of defense pieces and their corresponding attack
materials is 2.44M bytes.
6 Conclusions
Endgame problems represent a diﬃcult issue in both Western chess and Chi-
nese chess. The largest Chinese chess endgame database built by a retrograde
algorithm currently contains only two strong attack pieces on each side. How-
ever, the endgame results show that many strong attack pieces exist. We have
designed a knowledge inferencing scheme to build a practical material database
for the initial phase of the endgame. In addition, we use the material state
extension algorithm and the unknown state predictor algorithm to construct
endgames with many strong attack pieces. Our experimental results show that
the performance of our algorithms is good and reliable. When predicting the
advantage of a material combination with a large number of pieces, we may
conclude from the results above that our material state extension algorithm is
an eﬀective approach. However, if the extension algorithm fails, the predictor
algorithm takes over and reports an inferred solution. This strategy can be used
to solve the problem when a complete knowledge database of an endgame with a
large amount of material cannot be built using conventional computer methods,
and only advantage information is required to know for the material state.
Acknowledgments. This research was partially supported by National Science
Council, Grants 95-2221-E-001-004 and 96-2221-E-001-004.
