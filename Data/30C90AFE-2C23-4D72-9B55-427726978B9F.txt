將它改成一種有效率的型式，使得所需要之蝶型運算級數能
減少，而且快速傅立葉轉換處理單元能夠最佳管線化。基底
16 處理單元由兩個基底 4之單元串接而成。這可以使得在實
現基底 16 快速傅立葉轉換演算法時因管線化之設計使得複雜
度降低且運算速度變快。而且我們提出了一種免於碰撞之記
憶體位置定址法， 可支援 16 路平行之正常順序輸入輸出資
料串。這種方法可達成高效能產出率且不需要緩衝器來改變
順序。經由合成軟體以 90nm 製成合成顯示，整個處理器面積
為 1.33 mm2，功率消耗為 65mW。在 12 位元下之訊雜比效能
為 57dB。此成果已經被 IEEE Transactions on Circuits on 
Systems I 所接受將發表。 
最後在通道編碼方面，本計畫針對低密度奇偶校驗碼(LDPC)
提出一個高效能且低複雜度的解碼演算法。傳統上有可接受
複雜度且高效能的 LDPC 解碼演算法 MP(Message Passing) 
algorithm family 的效能相較於其他演算法已有較佳的表
現，但仍與最大可能性解碼的解碼效能有段差距。因此，本
報告提出一個關於使用基因演算法的概念搭配 MP 演算法(GA-
MP)的創新演算法，根據我們的分析，它的解碼效能在不同的
parity check matrices 下都能逼近最大可能性解碼。目前
現存文獻中所提出的逼近最大可能性解碼的演算法皆難以在
可接受的硬體面積需求內實現。相較於這些文獻[8][9]我們
提出的 GA-MP 有著高效能與低複雜度的優點，且以 EG-LDPC 
(63, 37, 8, 8)為例，實現了一個 GA-MP 解碼器，在 UMC 90 
製程與 200MHz 時脈下，其 chip gate counts 為 379k，功率
消耗為 67.556mW。且其解碼效能十分接近 floating-point
之模擬結果。 
中文關鍵詞： 無線個人區域網路； 波束成形； 波束編碼簿； 通道估測； 
軟體無線電； 前端濾波運算； 低密度奇偶校驗碼； 基因演
算法； 最大可能性解碼； 訊息傳遞； 快速傅立葉轉換 
英 文 摘 要 ： During the past year, we have accomplished all the 
project goals and achieved various results. Since it 
is too lengthy to list all the results, we particular 
summarize some of the major results as follows. First 
of all, based on the beam codebook in IEEE 802.15.3c, 
we propose two symbol-wise beamforming schemes to 
estimate arrival directions of signals for 60GHz OFDM 
systems. Simulation results show that the proposed 
schemes have the lowest complexity compared with the 
existing techniques, with similar performance to 
popular hybrid beamforming schemes. 
Next, two techniques to enhance the estimation 
Maximum likelihood decoding； Message passing； SDR； 
FIR filter； Fast filtering algorithm； Channel 
estimation； FFT 
 
 I
目錄............................................................................................................................... I 
摘要.............................................................................................................................. II 
Abstract ...................................................................................................................... IV 
一. 前言........................................................................................................................ 1 
二. 研究目的................................................................................................................ 3 
三. 文獻探討................................................................................................................ 5 
三-1. 波束成型 ..................................................................................................... 5 
三-2. 通道估測 ..................................................................................................... 8 
三-3. 軟體無線電 ............................................................................................... 10 
三-4. 快速傅立葉 ............................................................................................... 11 
三-5. 通道編碼 ................................................................................................... 12 
四. 研究方法.............................................................................................................. 14 
四-1. 波束成型 ................................................................................................... 14 
四-2. 通道估測 ................................................................................................... 20 
四-3. 軟體無線電 ............................................................................................... 21 
四-4. 快速傅立葉 ............................................................................................... 29 
四-5. 通道編碼 ................................................................................................... 33 
五. 結果與討論.......................................................................................................... 37 
五-1. 波束成型 ................................................................................................... 37 
五-2. 通道估測 ................................................................................................... 41 
五-3. 軟體無線電 ............................................................................................... 43 
五-4. 快速傅立葉 ............................................................................................... 44 
五-5. 通道編碼 ................................................................................................... 45 
六. 研究成果.............................................................................................................. 49 
參考文獻..................................................................................................................... 52 
 
 
 III
處理器面積為 1.33 mm2，功率消耗為 65mW。在 12 位元下之訊雜比效能為
57dB。此成果已經被 IEEE Transactions on Circuits on Systems I 所接受將發表。 
最後在通道編碼方面，本計畫針對低密度奇偶校驗碼(LDPC)提出一個高效
能且低複雜度的解碼演算法。傳統上有可接受複雜度且高效能的 LDPC 解碼演算
法 MP(Message Passing) algorithm family 的效能相較於其他演算法已有較佳的表
現，但仍與最大可能性解碼的解碼效能有段差距。因此，本報告提出一個關於使
用基因演算法的概念搭配 MP 演算法(GA-MP)的創新演算法，根據我們的分析，
它的解碼效能在不同的 parity check matrices 下都能逼近最大可能性解碼。目前現
存文獻中所提出的逼近最大可能性解碼的演算法皆難以在可接受的硬體面積需
求內實現。相較於這些文獻[8][9]我們提出的 GA-MP 有著高效能與低複雜度的優
點，且以 EG-LDPC (63, 37, 8, 8)為例，實現了一個 GA-MP 解碼器，在 UMC 90 nm
製程與 200MHz 時脈下，其 chip gate counts 為 379k，功率消耗為 67.556mW。
且其解碼效能十分接近 floating-point 之模擬結果。 
 
關鍵詞:無線個人區域網路(WPAN); 波束成形  (Beamforming); 波束編碼簿
(Beam Codebook); 通道估測 (Channel estimation);軟體無線電 (SDR); 前端濾
波運算; 低密度奇偶校驗碼(LDPC); 基因演算法(GA); 最大可能性解碼(ML 
decoding); 訊息傳遞(Message passing); 快速傅立葉轉換 (FFT)。 
 
 V 
passing; SDR; FIR filter; Fast filtering algorithm; Channel estimation; FFT
 2
波器。平行處理主要是利用多套硬體同時計算多個輸入訊號且同時產生多個輸出
訊號，因此平行架構中所需達到的時脈率(clock rate)可遠低於要求的時脈率，舉
例來說在L倍平行架構中所需的時脈率僅為要求的1/L。 
 LDPC 解碼演算法已被視為通道編碼中效能最高的幾種演算法之一，也被廣
泛的運用在許多的系統中如 802.16e、802.15.3c、802.11n 等，近年來和 Turbo code
的優劣性也被廣泛探討。在現今高 throughput 與高解碼效能的要求之下，LDPC
解碼漸漸受到研究者的關注，目前已經有許多文獻探討[8][9]如何使 LDPC 解碼
演算法之解碼效能逼近 ML 解碼的效能。然而高效能的 LDPC 解碼演算法往往過
於複雜並難以以硬體實現，因此本計畫將會提出一個解碼效能逼近 ML 且能夠以
硬體實現的解碼演算法來解決此一問題。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 4
滿足這些標準中最大吞吐量2 Gb/s以上的要求我們選擇了以八倍平行的濾波器
架構為基礎並配合所提出架構之可重組性，在802.11ad、802.15.3c等標準之下所
提出架構將以八倍平行架構操作，在802.11ac、LTE等標準下則重組成四倍平行
架構。 
 最後在通道編碼部分，傳統的 LDPC 遞迴解碼演算法中，每個 bit node 的信
賴值(belief reliability) (也就是在做硬決定(hard-decision)前的 LLR 軟值(soft 
value))的絕對值大小通常被當作是判斷每個 bit 被正確解碼的可靠度的依據。也
就是說，若此 bit node 的信賴值(belief reliability)的絕對值越大，則此 bit node 在
經過硬決定後的 decoded bit 正確性也越高。但是也有可能出現當一個 bit node 的
信賴值(belief reliability)絕對值很高，其硬決定解碼後的結果依然為錯誤的情形。
根據我們觀察，通常此類問題即為造成即便經過再多次的 LDPC 遞迴解碼，仍然
無法獲得正確的解碼結果的原因。因此，我們認為若能事先找出這些可疑 bit node
並且修正他們的信賴值即有機會通過一般的 LDPC 遞迴解碼來獲得正確的解碼
結果。但此可疑 bit node 不容易被輕易挑出，因此如何有效率的挑出真的可疑的
bit node 來更新它的信賴值即為如何提升 LDPC 遞迴解碼效能的關鍵。本計畫也
會就此部分提出一個新的 LDPC 解碼演算法來解決此一問題，並且探討其解碼效
能與 ML 解碼的差距。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 6
其中 kH 代表第 k 個子載波的通道， kn 為第 k 個子載波上的雜訊。在經過接收端
波束成形器後的訊號 kz 為： 
k
H
k
t
k
kk
H
kk
H
kk
M
s
z ncwHcyc +==
     
 (2) 
此時必須計算每一個子載波的訊雜比： 
2
2
2
2
||
]|| [
]|| [
nrt
kk
H
k
k
H
k
t
k
kk
H
k
k
MME
M
s
E
σ
γ
wHc
nc
wHc
==      (3) 
子載波式波束成形的目的是要找出所有子載波最佳的權重向量使得所有子載波
的訊雜比有最好的效能，換句話說，就是要找出以下問題的最佳解： 
22
,
||max kk
H
k
kk
wHc
wc
−σ~      (4) 
其中 22 1 nrt MM σσ /~ =− 為一常數，不影響最佳權重向量的解。 
(4)式可以透過對通道矩陣做奇異值分解(singular value decomposition，SVD)
來得到最佳解，將通道矩陣分解成 
H
kkkk VDUH =         (5) 
其中 kU 和 kV 分別為 rr MM × 和 tt MM × 的么正矩陣(unitary matrix)； kD 為一
tr MM × 的矩陣，其第( j, j)個元素表示為 jk ,δ ，其他元素均為零，其中 jk ,δ 稱為奇
異值， ) ,min( , ,2 ,1 tr MMj K= 。在奇異值分解中假設奇異值在 kD 按照大小排列，
因此 ) ,min( 2max 1 tr MMkkkk ,,,, δδδδ ≥≥≥= L 。由於第一個奇異值最大，選擇權重向量
1 ,krk M uc ⋅= 和 1 ,ktk M vw ⋅= ，其中 1 ,ku 與 1 ,kv 分別為 kU 和 kV 中的第一列向
量。此時第 k 個子載波的訊雜比為： 
2
max ,
222
,
svd , ||
~max kkk
H
kk
kk
δσσγ −− == wHc
wc
      (6) 
由於每個子載波的訊雜比不盡相同，需要一個更有效的指標來評斷系統好
壞，指數有效訊雜比映射(exponential effective SNR mapping，EESM)便是其中一
個十分有效的方法。有效訊雜比是根據錯誤率近似而推導出來的[13]： 
    ∑
−
=
⋅−=⋅−≈
1
0
efferror )exp(
1
)exp(
N
k
k
N
P γβγβ       (7) 
其中β 是根據所使用的調變種類以及編碼方式變化的參數，在[13]中可以找到一
些β 的實際例子。由(7)式可推導出的有效訊雜比為： 
    





⋅−⋅





−= ∑
−
=
1
0
svd ,svd eff, )exp(
1
ln
1 N
k
k
N
γβ
β
γ     (8) 
二. 符元式波束成形 
符元式波束成形中訊號是在時域上乘上權重，因此其波束成形器在傳送端位
於IFFT運算器之後，在接收端時位於FFT運算器之前，如圖二。在符元式波束成
 8
圖三。與符元切換式波束成形法相法，此架構可以減少所需傳送訓練序列的次
數，且在接收端時可對每一個子載波乘上各自最佳的權重向量，因此可以提供相
對較佳的效能，雖然硬體複雜度比符元式高，但與子載波式波束成形相比仍少了
許多。 
 
 
圖三. 混合式波束成形架構 
假設在此架構中所使用於傳送端的波束編碼簿為 W，則根據有效訊雜比最
大化原則，此最佳化問題可表示為： 






−⋅





−= ∑
−
=
−
∈
1
0
22
hybrid eff, )||exp(
1
ln
1
 max 
N
k
k
H
k
N
wHc
Ww
σβ
β
γ ~    (12) 
在實際解此問題時，我們是先將接收端所有子載波的權重向量 ck 固定，而傳送
端進行波束搜尋流程，不同於符元切換式波束成形在進行搜尋流程時，接收端不
需要切換自己的方向，因此可以減低訓練序列傳送的次數。傳送端經過波束搜尋
流程從波束編碼簿找出最佳的傳送權重向量 w 後，對接收端來說，第 k 個子載
波上等效的通道就變成 Hkw，可以很簡單的利用科西 -舒瓦茲不等式
(Cauchy-Schwarz inequality)，取接收端最佳的權重向量為： 
1 , ,0  , −=⋅= NkM
k
k
rk K
wH
wH
c      (13) 
因此不需要對通道矩陣做奇異值分解，比起子載波式波束成形可以降低許多運算
複雜度。 
2.通道估測 (Channel estimation) 
 首先，我們先我們介紹有關於應用於毫微米通訊系統中的 IEEE 802.15.3c 的
先前訊號的格式。主要有包含三個部分，有同步(SYNC)、起始方框限制
(Start-Frame Delimiter, SFD)以及通道估測序列(Channel Estimation Sequence, 
CES)。在同步欄位中，主要是由不同的格雷 a128的重複序列所組成，其目的是希
ks
 10
 
127
2
0
1
[ ] ,
128
s
l
P H l
=
= ∑   (18) 
及 
 
127 1
2
0 0
1 1
[ ]
128
n g
l g
P W l
G = =
= ∑∑   (19) 
更進一步地，可以利用(18)和(19)得到訊雜比，其表示式如下 
 ˆ s
n
P
P
η =   (20) 
可是透過理論的分析(20)式中的估測準確度中，發現(20)的估測其實是有偏差值
的，表示如下式: 
 [ ]
,
,
,
8ˆ
1
8
n real
s real
n real
P
P
E
P
η
+
=   (21) 
其中，Ps,real 和 Pn,real 是表示理想估測到的訊號以及雜訊功率。因此可以看出利
用先前文獻[15][16]所提出的方法估測出來的訊雜比是不準確的。而不準確的雜
訊筆會造成整體效能的下降並造成通訊品質降低，本計畫即針對此一問題提出改
善之方法。 
3. 軟體無線電 (SDR Frond End Filter Architectures) 
一般的平行濾波器架構可藉由將輸入訊號、輸出訊號及濾波器函數做多相角
拆解成多個次訊號，得到的架構即為一個平行運算之架構。這種直接使用多相角
拆解得到的平行架構其運算複雜度會隨著平行度(block size)呈線性的增加，因此
在高平行度時會有很高之複雜度。[17]之作者提出了一種新的平行化架構，利用
數學堆導的方式得到的架構可以大幅降低平行架構之運算複雜度，簡介如下。 
( )( )


−−++=
+= −
110010101
11
2
000
HXHXHHXXY
HXzHXY
(22)
 
[17]所提出的兩倍平行濾波器架構可由(22)式中獲得，從此式中可發現此一架構
可用較少的次濾波器完成一個兩倍平行的濾波。其運算複雜度為 3N/4 個乘法和
(3N/4)+(1/2)個加法在計算每一點的濾波器輸出。其架構如下圖。 
 
圖五. 兩倍平行濾波器架構 
另外三倍平行之架構如下式 
 12
 
5. LDPC 通道編碼(Channel Coding) 
在 LDPC 解碼演算法的研究上，大部分的研究都是探討如何改進 MP 演算法
中 Min-Sum Algorithm(MSA) 的 效 能 [27-31] ， 使 其 逼 近 Sum-Product 
Algorithm(SPA)[32]。不過由於現在對解碼效能品質的需求，現在也有許多探討
如何增進 SPA 的效能使其逼近 ML 解的效能的研究被提出[8,9]。其中[8]是最先
將基因演算法運用於 LDPC 解碼上的文獻，它將所有 bit nodes 的視為一個群體
(population)，然後每個 bit node 做為一個個體(individual)。其中每個 bit node 傳
送至 check node 的 LLR 訊息做為此個體的其中一個基因(gene)，且每個個體的適
應值(fitness value)為此個體的信賴值(belief reliability)絕對值大小。在每次遞迴中
它會依據適應值的大小來突變每個基因如(24)所示。 
 
  (24) 
 
 此式中 m 為 parity check matrix 中平均每行中元素為 1的個數，n為平均每
列中元素為 1的個數，log(λ)為每個 bit node 的通道值(channel value)。在每次 BP
遞迴解碼中，當適應值高於 s(λ)的個體且其所包含的基因高於 m(λ)的話，就加
強此基因的訊息量。若適應值低於 s(λ)的個體且其所包含的基因高於 m(λ)的話，
則減弱此基因的訊息量。此方法可稍微增強 SPA 的解碼效能，不過此篇論文並
未真正用到基因演算法的概念，且主要還是使用信賴值(belief reliability)的大小作
為判斷的基準，因此只能小幅提升 SPA 解碼效能。 
[9]為目前文獻中真正能大幅提升 SPA 解碼效能並將其逼近 ML 解碼的文
獻。其採用多階段(multistage)的遞迴解碼方式，在每次進入 SPA 解碼前，會將最
可疑的 bit node 訊息更改。其中被更改的最可疑 bit node 會分別被改成+S 和-S，
且分別對被改過的 bit node 做 SPA 遞迴解碼。如圖七所示 
 
 14
四. 研究方法 
為了方便起見，我們將章節分成幾個小部分，分別是波束成型、通道估測、軟體
無線電、快速傅立葉與 LDPC 通道編碼五個部分。一一詳述如下。 
1.波束成型(Beamforming) 
由於子載波式與混合式硬體與計算的複雜度較高，因此我們主要想改良的為
符元式波束成形。本計畫中提出兩個低複雜度的方法，是利用搜尋波束時的訊雜
比資訊，估測出訊號的到達角以及離開角，將原先的符元切換式波束成形，可以
隨著通道情況改變對波束指向做調整，也就是所謂的符元適應性波束成形。使用
此一方法，在整個波束成形過程中只需要波束對的訊雜比資訊，完全不需要其他
任何的通道資訊，茲簡介如下。 
 
一. 提出的基於 802.15.3c 波束編碼簿之波束成形 
假設一組天線數 M 波束數 K 的編碼簿 ]   [  21 KKM wwwW K=, ，其中每一波
束向量最大增益對應到的角度為 ]   [  21 Kθθθ K=Θ 。編碼簿中第 k 個波束向量在訊
號方向θ 的波束場形的數學式可表示為： 
∑
=
−
==
M
m
d
mj
kmkk ewAP
1
)cos1)((2
  )( )(
θ
λ
π
θθ ,     (25) 
通常訊號實際的角度會落在效能最佳與次佳的波束場形之間，將其索引表示為
id1 以及 id2，並估測訊號的角度為 
)()(
 )()( 
id2id1
2idid2id1id1
θθ
θθθθ
θ
PP
PP
+
+
=ˆ       (26) 
必須注意到，訊號實際角度通常應該是落在效能最佳的波束場型附近，但在取效
能次佳的波束時，有可能會取到不是位於最佳波束的鄰近波束。這是因為波束的
旁辦(sidelobe)所造成，但在Θ 矩陣中指的都是主波辦(mainlobe)最大增益的方
向。因此在取次佳波束時，只從鄰近於最佳波束旁的波束做選擇，以避免因波束
旁辦所造成角度估測不準確的情形。在估測完角度後，產生一組指向θˆ 的波束向
量： 
Tcos1Mjcos2jcosj ]       1 [ θπθπθπ
ˆ)(ˆˆˆ ⋅−−⋅−⋅−= eeew L     (27) 
利用此波束向量可以在θˆ 方向得到最大的天線增益。 
 16
另外我們以兩個指標來評斷估測角度的精確率，平均角度誤差(Mean error)
以及方均根角度誤差(Root mean square error)。先定義角度的誤差為： 
  - iii θθθ ˆ=∆         (30) 
而平均角度誤差和方均根角度誤差分別為： 
,
S
 
ME 1
∑ = ∆=
S
i i
θ
       (31) 
S
   
RMSE 1
2∑ = ∆=
S
i i
θ
      (32) 
其中 S 代表所估測角度次數的總數。在經過第二次估測後可以發現雖然在低角度
時仍有誤差，但曲線比修改前平滑，如圖十。而在平均角度誤差及方均根角度誤
差，也都比只做一次估測來的小，如圖十一。 
0 10 20 30 40 50 60 70 80 90
0
10
20
30
40
50
60
70
80
90
100
desired angle(degree)
e
s
ti
m
a
te
d
 a
n
g
le
(d
e
g
re
e
)
 
 
M=K=4
M=K=8
M=K=16
M=K=32
M=K=64
 
圖十. 修改後估測法所估測角度 
0 10 20 30 40 50 60 70
0
1
2
3
4
5
6
7
8
9
Number of antenna element
e
rr
o
r 
a
n
g
le
(d
e
g
re
e
)
 
 
Esti. once ME
Esti. twice ME
Esti. once RMSE
Esti. twice RMSE
 
圖十一. 修改前後估測角度誤差 
 18
10 20 30 40 50 60
6
8
10
12
14
16
18
Number of antenna element
A
n
te
n
n
a
 G
a
in
 (
d
B
)
 
 
Bound
M beams
4 beams
8 beams
16 beams
32 beams
Codebook,K=M
 
圖十三. DEC 使用不同維度編碼簿估測角度天線增益 
二. 提出基於新編碼簿之波束成形 
在波束搜尋流程中有了各波束的訊雜比之後，其實可以利用其等效波束場型
來解出訊號實際的角度，如： 
∑
∑
=
=
==
M
m
d
j
m
M
m
d
j
m
i
i
ew
ew
P
P
P
0
)cos(2
id2 
0
)cos(2
id1 
d2
d1
12
 
   
)(
)(
θ
λ
π
θ
λ
π
θ
θ
,
,
    (33) 
但此為 M 次多項式不僅複雜度高，還必須從解出的 M 個解中找出一個正確的訊
號方向，也就是必須再做一次波束搜尋流程。為了簡化問題，本文提出一組新的
波束編碼簿使得(33)式的運算複雜度能夠降低，其中每一元素定義為： 
 ,1, ,               ,) , (
1)1)((
2
Mmkekm
mk
M
j
L==
−−
π
W    (34)
 
在此編碼簿中的波束數等於天線數，相位解析度為 2π/M。同樣地，先對此組編
碼簿做波束搜尋流程，假設找出效能最佳及次佳的波束索引為 id1、id2。由兩波
束的訊雜比計算出等效波束場型並帶入(34)式： 
∑
∑
=
−⋅−−⋅
=
−⋅−−⋅
==
M
m
d
mjm
M
j
M
m
d
mjm
M
j
ee
ee
P
P
P
0
)cos)(1(21)1)((id2
2
0
)cos)(1(21)1)((id1
2
id2
id1
12
 
   
)(
)(
θ
λ
π
π
θ
λ
π
π
θ
θ
 
 20
0 10 20 30 40 50 60 70
0
0.5
1
1.5
2
2.5
3
3.5
Number of antenna element
e
rr
o
r 
a
n
g
le
(d
e
g
re
e
)
 
 
DEC ME
DENC ME
DEC RMSE
DENC RMSE
 
圖十四. DEC 與 DENC 估測角度誤差 
10 20 30 40 50 60
6
8
10
12
14
16
18
Number of antenna element
A
n
te
n
n
a
 G
a
in
 (
d
B
)
 
 
Bound
M beams
4 beams
8 beams
16 beams
32 beams
Codebook,K=M
 
圖十五. DENC 使用不同維度編碼簿估測角度天線增益 
2.通道估測 (Channel estimation) 
為了增加估測到的通道響應以及更正訊雜比的偏差值。提出了兩個方法來改
善先前方法得不足。 
第一個方法主要就是利用互補格雷碼在通道估測序列欄位的特殊排列，能夠
在一組互補格雷碼中，得到兩組的互補格雷碼來進行通道估測。如圖十六所示，
其中 set 1 序列是如先前方法之中所用的序列。但是為了要避免區塊間干擾
(Inter-block interference, IBI)，而加入了 post-fix 和 pre-fix 的序列。其中 post-fix
和 pre-fix 序列分別為互補格雷碼得前面以及後面各 128 個取樣的複製。因此，
可以看到利用這個特性，可以得到 set 2 序列互補格雷碼。因此，在一組的通道
響應序列中可以得到兩組的互補格雷碼，再利用(14)式的特性可以求出兩得不同
的通道響應。因此可以增加偵測精準度。經由理論的推估，可以減少 25%得最小
 22
 
圖十七.升頻取樣示意圖 
' 
圖十八. 降頻取樣示意圖 
如上圖所示，使用多速率訊號處理技巧我們可以把訊號升頻取樣移到濾波器
之後如此可以增加運算效率且可以降低濾波器所需的吞吐量。相同的概念我們也
用在降頻濾波的架構上。拆解後的兩個多相角濾波器以所提出之可重組平行架構
實現且說明如下。 
三. 提出之可重組平行濾波器架構   
傳統的平行濾波器架構都是處理一組訊號的濾波，即將一組輸入訊號拆成多
個次訊號並經由平行架構之運算得到多個輸出訊號，每個時脈的輸出訊號數目由
平行架構的平行度即方塊大小(block size)所決定。由於在多標準之應用中，不同
的標準其資料率不盡相同使得其所需的平行度也有差異，我們利用數學推導得到
一種新的平行架構，提出之架構將可重組其平行度並可同時處理多組訊號之濾
波，  詳細概念以四倍平行訊號實現於八倍平行架構為例說明如下。 
首先一個四倍平行濾波器的四個輸出次訊號數學表示如下: 
( ) ( ) ( ) ( ) ( )
( ) ( )( ) ( ) ( )( )
( ) ( ) ( ) ( ) ]                           
 [                
4_34_34_14_1
4_34_14_34_1
1
4_24_2
1
4_04_04_0
zHzXzHzX
zHzHzXzXz
zHzXzzHzXzY
pppp
pppp
ppppp
−−
+++
+=
−
−
 
(41) 
 
( ) ( ) ( )( ) ( ) ( )( )
( ) ( )( ) ( ) ( )( )
( ) ( ) ( ) ( )( )
( ) ( ) ( ) ( )( )zHzXzzHzX
zHzXzzHzX
zHzHzXzXz
zHzHzXzXzY
pppp
pppp
pppp
ppppp
4_34_3
1
4_14_1
4_24_2
1
4_04_0
4_34_24_34_2
1
4_14_04_14_04_1
                
                
                
−
−
−
+−
+−
+++
++=
 
(42) 
( ) ( ) ( )( ) ( ) ( )( )
( ) ( ) ( ) ( )
( ) ( ) ( ) ( )( )zHzXzzHzX
zHzXzHzX
zHzHzXzXzY
pppp
pppp
ppppp
4_34_3
1
4_14_1
4_24_24_04_0
4_24_04_24_04_2
              
]                  
 [
−++
−−
++=
 
   
 24
( ) ( ) ( )( ) ( ) ( ) ( ) ( )( )
( ) ( ) ( )( ) ( ) ( ) ( )( )
( ) ( ) ( )( ) ( ) ( ) ( )( )
2 1 2 2 1 2
2_ 4 0 _ 4 2_ 4 0 _8 4_8 2_8 6_8
2 1 2 2 1 2
0_ 4 0_8 4 _8 2 _ 4 2_ 8 6_8
2 1 2 1 2 1 2
1_ 4 1_8 5_8 3_ 4 3_8 7 _8
[ 
                  ]
              [  ]
 
p p p p p p p
p p p p p p
p p p p p p
Y z X z X z H z z H z H z z H z
X z H z z H z X z H z z H z
X z H z z H z z X z H z z H z
− −
− −
− − −
= + + + +
− + − +
+ + + +
( ) ( )( ) ( ) ( )( )
( ) ( )( ) ( ) ( )( )
( ) ( ) ( ) ( )( )
( ) ( ) ( ) ( )( )
2 1 2
0 _ 4 2_ 4 0 _8 2_8
1 2 1 2
0 _ 4 2_ 4 4_8 6_8
2 1 2
0 _ 4 0 _8 0 _ 4 4_8
2 1 2
2_ 4 2_8 2 _ 4 6 _8
            [ 
                    ]
              
               
       
p p p p
p p p p
p p p p
p p p p
X z X z H z z H z
z X z X z H z z H z
X z H z z X z H z
X z H z z X z H z
−
− −
−
−
= + +
+ + +
− +
− +
( ) ( ) ( ) ( )( )
( ) ( ) ( ) ( )( )
2 1 2
1_ 4 1_8 1_ 4 5_8
1 2 1 2
3_ 4 3_8 3_ 4  7 _8
       
                                                        (48)
p p p p
p p p p
X z H z z X z H z
z X z H z z X z H z
−
− −
+ +
+ +
( ) ( ) ( ) ( ) ( )( ) ( ) ( ) ( ) ( )( )
( ) ( ) ( ) ( )( ) ( ) ( ) ( ) ( )( )
( ) ( )( ) ( ) ( )( ) ( )
2 2 2 2
3_4 0_4 1_4 2_4 3_4 0_8 1_8 2_8 3_8
1 2 2 2 2
0_4 1_4 2_4 3_4 4_8 5_8 6_8 7_8
2 2 1
0_4 1_4 0_8 1_8 0_4 1_4
{[
             
             [
p p p p p p p p p
p p p p p p p p
p p p p p
Y z X z X z X z X z H z H z H z H z
z X z X z X z X z H z H z H z H z
X z X z H z H z z X z X
−
−
= + + + + + +
+ + + + + + +
− + + + + ( )( ) ( ) ( )( )
( ) ( )( ) ( ) ( )( ) ( ) ( )( ) ( ) ( )( )
( ) ( )( ) ( ) ( )( ) ( ) ( )( ) ( ) ( )( )
( )
2 2
4_8 5_8
2 2 1 2 2
2_4 3_4 2_8 3_8 2_4 3_4 6_8 7_8
2 2 1 2 2
0_4 2_4 0_8 2_8 0_4 2_4 4_8 6_8
0_4 0_8
]
             [ ]}
             [ 
                 
p p p
p p p p p p p p
p p p x p p p p
p p
z H z H z
X z X z H z H z z X z X z H z H z
X z X z H z H z z X z X z H z H z
X z H
−
−
+
− + + + + +
− + + + + +
− ( ) ( ) ( )( ) ( ) ( ) ( ) ( )( )
( ) ( )( ) ( ) ( )( ) ( ) ( )( ) ( ) ( )( )
( ) ( ) ( ) ( )( ) ( ) ( )
2 1 2 2 1 2
0_4 4_8 2_4 2_8 2_4 6_8
2 2 1 2 2
1_4 3_4 1_8 3_8 1_4 3_4 5_8 7_8
2 1 2 2 1
1_4 1_8 1_4 5_8 3_4 3_8 3_4
 ]
              [ 
                 
p p p p p p
p p p p p p p p
p p p p p p p
z z X z H z X z H z z X z H z
X z X z H z H z z X z X z H z H z
X z H z z X z H z X z H z z X
− −
−
− −
+ − +
− + + + + +
− + − + ( ) ( )( )27_8  ]     
                                                                                                                                                                                (49) 
p
z H z
 
改寫後的數學式可發現有關濾波器次訊號的部份都以替換成八倍平行的型
式，這使得我們可以將四倍平行的訊號操作在八倍平行之架構上，詳細架構如下
圖十九所示。
 
 26
從前面的說明可知一組四倍平行訊號使用八倍架構來濾波僅用到其中之一
部份資源，因此我們想到是否可以利用剩下的部份來支援另一組訊號的濾波，詳
細概念說明如下。 
將第一組四倍平行訊號使用八倍平行架構實現的數學式改寫如下 
( ) ( ) ( ) ( )( )( )
( ) ( ) ( )( )( )
( ) ( )( ) ( ) ( )( ) ( ) ( )( )
( ) ( ) ( )( )( ) ( )
2 1 2
0_4 0_4 0_8 4_8
1 2 1 2
2_4 2_8 6_8
1 2 2 1 2 2
1_4 3_4 1_8 3_8 5_8 7_8
2 1 2
1_4 1_8 5_8 3_4 3_
 
              
              { [ ]
                      -  -
p p p p
p p p
p p p p p p
p p p p
Y z X z H z z H z
z X z H z z H z
z X z X z H z H z z H z H z
X z H z z H z X z H
−
− −
− −
−
= +
+ +
+ + + + +
+ ( ) ( )( )( )2 1 28 7_8  }    
                                                                                                                                                        (50)
p pz z H z
−+
( ) ( ) ( )( ) ( ) ( ) ( ) ( )( )( )
( ) ( )( ) ( ) ( ) ( ) ( )( )( )
( ) ( ) ( )( ) ( ) ( ) ( )( )
2 2 1 2 2
1_4 0_4 1_4 0_8 1_8 4_8 5_8
1 2 2 1 2 2
2_4 3_4 2_8 3_8 6_8 7_8
2 1 2 1 2 1 2
0_4 0_8 4_8 2_4 2_8 6_8
             
             -
            
p p p p p p p
p p p p p p
p p p p p p
Y z X z X z H z H z z H z H z
z X z X z H z H z z H z H z
X z H z z H z z X z H z z H z
−
− −
− − −
= + + + +
+ + + + +
 + + + 
( ) ( ) ( )( ) ( ) ( ) ( )( )2 1 2 1 2 1 21_4 1_8 5_8 3_4 3_8 7_8 -        (51)p p p p p pX z H z z H z z X z H z z H z− − − + + + 
( ) ( ) ( )( ) ( ) ( )( )
( ) ( )( ) ( ) ( )( )
( ) ( ) ( )( )( ) ( ) ( ) ( )( )( )
( ) ( ) ( )( )( )
2 1 2
2_4 0_4 2_4 0_8 2_8
1 2 1 2
0_4 2_4 4_8 6_8
2 1 2 2 1 2
0_4 0_8 4_8 2_4 2_8 6_8
2 1 2
1_4 1_8 5_8
 [ 
                    ]
              
              
p p p p p
p p p p
p p p p p p
p p p
Y z X z X z H z z H z
z X z X z H z z H z
X z H z z H z X z H z z H z
X z H z z H z
−
− −
− −
−
= + +
+ + +
− + − +
+ + ( ) ( ) ( )( )( )1 2 1 23_4 3_8 7_8        (52)p p pz X z H z z H z− −+ +
( ) ( ) ( ) ( ) ( )( ) ( ) ( ) ( ) ( )( )
( ) ( ) ( ) ( )( )
( ) ( )( ) ( ) ( )( ) ( ) ( )( )( )
2 2 2 2
3_4 0_4 1_4 2_4 3_ 4 0_8 1_8 2_8 3_8
1 2 2 2 2
4_8 5_8 6_8 7_8
2 2 1 2 2
0_4 1_4 0_8 1_8 4_8 5_8
{[ [
                           ]]
             [ ]
     
p p p p p p p p p
p p p p
p p p p p p
Y z X z X z X z X z H z H z H z H z
z H z H z H z H z
X z X z H z H z z H z H z
−
−
= + + + + + +
+ + + +
− + + + +
( ) ( )( ) ( ) ( )( ) ( ) ( )( )( )
( ) ( )( ) ( ) ( )( ) ( ) ( )( )( )
( ) ( ) ( )( )( ) ( ) ( ) ( )( )( )
2 2 1 2 2
2_ 4 3_4 2_8 3_8 6_8 7_8
2 2 1 2 2
0_4 2_ 4 0_8 2_8 4_8 6_8
2 1 2 2 1 2
0_4 0_8 4_8 2_4 2_8 6_8
        [ ]}
             [ 
                  ] 
        
p p p p p p
p p p x p p
p p p p p p
X z X z H z H z z H z H z
X z X z H z H z z H z H z
X z H z z H z X z H z z H z
−
−
− −
− + + + +
− + + + +
− + − +
( ) ( )( ) ( ) ( )( ) ( ) ( )( )( )
( ) ( ) ( )( )( ) ( ) ( ) ( )( )( )
2 2 1 2 2
1_4 3_ 4 1_8 3_8 5_8 7_8
2 1 2 2 1 2
1_4 1_8 5_8 3_4 3_8 7_8
      [ 
                  ]                  (53)
p p p p p p
p p p p p p
X z X z H z H z z H z H z
X z H z z H z X z H z z H z
−
− −
− + + + +
− + − +
 
  從改寫後的數學式可以發現我們可用第一組濾波訊號所沒使用到的次濾波器
進行第二組訊號之濾波，詳細架構如下圖二十一。 
 28
input
output
0
0
0
MUX MUX MUX MUX
D D D D D D
00  
圖二十二.修正型次濾波器架構 
四. 濾波器係數之重組 
為了應付多標準之需求，可重組架構必須包含係數之更新。為此我們以共同
式子消除法實現係數間之乘法並加入多工器形成一個可重組係數之乘法器方塊
介紹如下。首先我們已找出各標準所需之濾波器係數，以其中一個次濾波器為例
來說明。各標準的第一個次濾波器係數(做完定點數模擬之後)如下表一所示。 
 
表一. 各標準之次濾波器係數 
Coefficients 
Standard 
0C  1C  2C  
IEEE 802.11ad 111111011100 000001010100 000000111000 
   IEEE 802.11ac 000000011000 010000011000 000000011000 
IEEE 802.15.3c 000000010100 111110001100 111111100100 
LTE 000000011000 000101001000 000000011000 
在此我們定義兩個共同式子 12 >>+= xxx 、 23 >>+= xxx 以此兩個共同式
子並使用位移相加實現係數乘法，在不同標準的係數乘法間共同的運算部份可彼
此共享，不同的部分則使用多工器選擇需要的資料，控制這些多工器的控制訊號
即可重組出不同標準所需的係數。 
以上表實現可重組係數之乘法器方塊如圖二十三，控制各標準係數的多工器
控制訊號如表二所示。 
 
 30
1
0
( ) ( ) 0, ..., 1,   
N
n
kn
NX k x n W k N
−
=
= = −∑       (54) 
{
1 1 2 1 2 2
2 1
31 15
1 2 16 512 32
0 0
twiddle factor of stage 1
16-point DFT of the 1st stage
(32 )
n k n k n k
n n
x n n W W W
= =
= +
 
 
 
 
 
∑ ∑
442443
   (55) 
x(0)
W16
6
W16
9
x(1)
x(2)
x(3)
x(4)
x(5)
x(6)
x(7)
x(8)
x(9)
x(10)
x(11)
x(12)
x(13)
x(14)
x(15)
W16
1
W16
2
W16
3
W16
2
W16
4
W16
6
W16
3
1st radix-4 sub-stage 2nd radix-4 sub-stage
t_cnt = 0
BO4
(1,0)
BO4
(1,1)
BO4
(1,2)
BO4
(1,3)
BO4
(2,1)
BO4
(2,2)
BO4
(2,3)
(a) (b)
(c)
BO4
(2,0)
W16
6
W16
9
W16
1
W16
2
W16
3
W16
2
W16
4
W16
6
W16
3
1st radix-4 sub-stage 2nd radix-4 sub-stage
t_cnt = 1
BO4
(1,0)
BO4
(1,1)
BO4
(1,2)
BO4
(1,3)
BO4
(2,1)
BO4
(2,2)
BO4
(2,0)
W16
6
W16
9
W16
1
W16
2
W16
3
W16
2
W16
4
W16
6
W16
3
1st radix-4 sub-stage 2nd radix-4 sub-stage
BO4
(1,0)
BO4
(1,1)
BO4
(1,2)
BO4
(1,3)
BO4
(2,1)
BO4
(2,2)
BO4
(2,3)
BO4
(2,0)
t_cnt = 2 (d)
W16
6
W16
9
W16
1
W16
2
W16
3
W16
2
W16
4
W16
6
W16
3
1st radix-4 substage 2nd radix-4 sub-stage
BO4
(1,0)
BO4
(1,1)
BO4
(1,2)
BO4
(1,3)
BO4
(2,1)
BO4
(2,2)
BO4
(2,3)
BO4
(2,0)
t_cnt = 3
BO4
(2,3)
X(0)
X(1)
X(4)
X(5)
X(8)
X(9)
X(12)
X(13)
X(2)
X(6)
X(10)
X(14)
X(3)
X(7)
X(11)
X(15)
x(0)
x(1)
x(2)
x(3)
x(4)
x(5)
x(6)
x(7)
x(8)
x(9)
x(10)
x(11)
x(12)
x(13)
x(14)
x(15)
x(0)
x(1)
x(2)
x(3)
x(4)
x(5)
x(6)
x(7)
x(8)
x(9)
x(10)
x(11)
x(12)
x(13)
x(14)
x(15)
x(0)
x(1)
x(2)
x(3)
x(4)
x(5)
x(6)
x(7)
x(8)
x(9)
x(10)
x(11)
x(12)
x(13)
x(14)
x(15)
X(0)
X(1)
X(4)
X(5)
X(8)
X(9)
X(12)
X(13)
X(2)
X(6)
X(10)
X(14)
X(3)
X(7)
X(11)
X(15)
X(0)
X(1)
X(4)
X(5)
X(8)
X(9)
X(12)
X(13)
X(2)
X(6)
X(10)
X(14)
X(3)
X(7)
X(11)
X(15)
X(0)
X(1)
X(4)
X(5)
X(8)
X(9)
X(12)
X(13)
X(2)
X(6)
X(10)
X(14)
X(3)
X(7)
X(11)
X(15)
 
圖二十四. 基底 16 蝴蝶結構之執行順序 
 32
(1) 由於使用了改良式基底16快速傅立葉轉換演算法，所需要之蝴蝶運算級數能
減少，以512點為例， 我們只須2級的時間就可完成運算，而且快速傅立葉
轉換處理單元能夠最佳管線化。 
(2) 基底16處理單元由兩個基底4之單元串接而成。這可以使得在實現基底16快
速傅立葉轉換演算法時因管線化之設計使得複雜度降低且運算速度變快。 
整個電路之運算速度可達324MHz。 
我們提出之記憶體位置定址法， 可支援 16 路平行之正常順序資料輸入輸
出， 並且確保運算時不會有記憶體衝突之情況發生，可有效提高運算效能產出
使其符合 802.15.3c 標準之規範。 
 
dout_0
dout_1
dout_2
dout_3
din_0
CM16 Set
1/1/1/1
1/-j/-1/j
1/j/-1/-j
1/-1/1/-1
+
+
+
+
1/1/1/1
1/-j/-1/j
1/j/-1/-j
1/-1/1/-1
+
+
+
+
1/1/1/1
1/-j/-1/j
1/j/-1/-j
1/-1/1/-1
+
+
+
+
1/1/1/1
1/-j/-1/j
1/j/-1/-j
1/-1/1/-1
+
+
+
+
PE_R4_S2 Set
LU
din_1
din_2
din_3
0
1
2
3
t_cnt
2
16
mW
22
16
mW
23
16
mW
CM16_1
CM16_2
CM16_3
pipeline 
registers
Ra_0
Ra_4
Ra_8
Ra_12
Ra_1
Ra_5
Ra_9
Ra_13
Ra_2
Ra_6
Ra_10
Ra_14
Ra_3
Ra_7
Ra_11
Ra_15
M
U
X
1
6
_
4
(1)
(2)
(3)
(4)
D
S
S
U
 (D
etectio
n
 a
n
d
 S
ca
lin
g
 S
u
b
-u
n
it)
Expi
(to Scaling Unit)
P
E
_
R
4
_
S
1
S
A
U
 (S
ca
lin
g
 A
lig
n
m
en
t U
n
it)
(From Scaling Unit)Expj
t_cnt’
 
圖二十六. 基底 16 處理單元架構 
 34
圖二十七.提出的 GA-MP 流程圖 
首先，我們先介紹基因演算法中的各個定義和設定。 
一. 定義基因編碼(encoding representation)形式 
對 LDPC code 來說，一組 block 有 N 個 bit nodes，其中 N 為碼長(code length)。
每個 bit node 都會對應到一個 decoding symbol。我們利用 message passing 中的 N
個 belief reliabilities 作為一個個體，而每個個體都會有其對應的硬決定碼字。因
此個體的基因編碼定義為如圖二十八，左半部為 belief reliabilities set，而右半部
即為其對應的硬決定碼字。 
 
→  
圖二十八. 個體的基因編碼 
 
二. 定義初始族群(Initial Population) 
每次經過 LDPC 遞迴解碼的 belief reliabilities 即為一個初始的個體，而所有
初始個體即為初始群體。如圖二十九所示，假設 initial LDPC 遞迴數為 L0。即為
第 l 次遞迴的信賴值(belief reliability) set。 
 
 
圖二十九.初始群體 
 
三. 定義適應函數(Fitness Function) 
此適應函數是一個用來評估每個個體優劣性的指標，在這邊我們使用兩個評
估項目 
1.Syndrome-weight(S) 
2.調變碼字與接收值的歐式距離(D) 
對第一項來說一個碼字其 Syndrome-weight 越小代表越好，而其調變碼字接
收值的歐式距離越小越好。因此我們設定的適應函數為 S+D。 
 
四. 信賴值(belief reliability)之突變 
在有了評估標準後，我們藉由利用一連串的信賴值(belief reliability)突變機
( )l
bL
uuuv
 36
在信賴值(belief reliability) 和通道值(channel value)互為異號且它的通道值
(channel value)之大小小於 2 的 bit nodes。 
在低 syndrome-weight 的母代下(S<10)，我們定義可疑 bit node 為所有連接於
DCBS-1 的 bit nodes。 
每個母代經由 0.5 的機率將母代的可疑 bit node 的信賴值更新來產生子代，
因此會產生許多含有不同基因的子代，再經過一次 LDPC 遞迴後將此更新的訊息
傳遞到整個個體，最後挑出擁有最佳適應值的個體。 
六. 通道值(channel value)更新 
接著再依先前所提到的適應函數計算方法從新世代的基因池中挑出新世代
的菁英解之後，我們會利用菁英解每個 bit 的信賴值大小來決定是否更新某個 bit
的接收值再重做 LDPC 遞迴演算法。如圖三十二，對於菁英子代的較高信賴值的
bit node 我們會將之取代通道值如(-6.2,7.1)，其餘乃為原來通道值，在這樣的組
合產生更新的通道值。接著重新再做一次 MP 解碼，其結果是為下一世代的母代。
除此之外，我們會額外判斷此一解碼結果是否唯一合法碼字，若是，則紀錄之。 
 
圖三十二.通道值更新 
 
上述的步驟四到六稱為一個世代，整個 GA-MP 解碼過程會經過數個世代的演化
直到收集到足夠數量的正解或是演化世代數已到達最大演化世代數。當演化結束
時，我們將會從在步驟六中所記錄的合法解中挑出一個與接收到的 channel value
歐式距離最短的合法解當作我們的最終解碼結果。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 38
10 20 30 40 50 60
10
15
20
25
30
35
Number of antenna element
B
e
a
m
fo
rm
in
g
 G
a
in
 (
d
B
)
 
 
Bound
svd
hybrid
DEC
DENC
K=M
K=3M
 
圖三十五. Office NLOS(CM4.1)下各種波束成形增益 
 
10 20 30 40 50 60
10
15
20
25
30
35
Number of antenna element
B
e
a
m
fo
rm
in
g
 G
a
in
 (
d
B
)
 
 
Bound
svd
hybrid,K=M
hybrid,K=3M
hybrid+DEC
hybrid+DENC
K=3M
 
圖三十六. Residential LOS(CM1.1)下混合式波束成形增益 
 
 40
在住宅 NLOS 的環境下，雖然在天線數較少時效能增益較不明顯，但隨著
天線數增加，DEC 與 DENC 分別在天線數 16 和 32 以上時，就能提供比混合式
還要好的效能。在 64 根天線時，兩者分別比混合式高出 0.5 及 1 dB 的增益。而
在更差的通道環境辦公室 NLOS 下，隨著天線數增加，DEC 也能越來越趨近於
混合式的波束成形增益，在 64 根天線下只有不到 0.5 dB 的增益差，約比傳統符
元式波束成形高出了 2 dB 的增益。然而，在如此嚴苛的通道環境下，DENC 就
無法提供太好的增益，在天線數較低的時候甚至會比傳統符元式的表現還要差，
在天線數較高時也只能趨近於 K = 3M 編碼簿波束成形。或許可以將其解釋為，
利用 DENC 估測訊號方向時所需的等效波束場形需要比 DEC 精準，因此在惡劣
通道環境下 DENC 的表現較差。圖三十六到圖三十八是將提出的方法並結合混
合式的概念之效能比較。在 LOS 環境下，利用混合式的概念可以使 DEC 與 DENC
更加接近子載波式的增益；而在住宅及辦公室 NLOS 環境下，則分別可以再提
高約 1 和 1.5 dB 的平均波束成形增益。 
表三. 各式波束成形複雜度比較 
 
 
為了簡化問題，在表三中的訓練序列數是以做窮舉式(exhaustive)搜尋所需的
次數來表示其相對大小，若運用其他搜尋法可以將所需次數降低，但相對關係是
不變的。由於所提出的兩種波束成形都是基於 802.15.3c 中的符元切換式作改
良，因此在硬體複雜度上是一樣的，只需要一組 IFFT/FFT 運算器，且不需要對
通道進行任何估測，只需在波束訓練過程中估測訊雜比，即可推算出訊號的方
向。混合式雖然可以簡化傳送端的硬體架構，但在實際設計電路上 ADC 比 DAC
要複雜許多，其在接收端硬體實現上依舊困難；且其天線陣列仍必須對天線的權
重以及相位做同時作調整，而本文所提出的兩種符元式波束成形，皆只需對相位
做控制。另外在本文中對子載波式以及混合式的模擬，皆是假設完美的通道估測
以及無限相位解析度的權重向量，若再將這些因素考慮進去，混合式的效能表現
可能會更差。總結以上原因，本文所提出基於編碼簿之符元式波束成形可能會比
混合式更適用於 WPAN 系統當中。 
根據實際於 IEEE 802.15.3c 通道環境下的模擬結果，DEC 無論在什麼環境
下，隨著天線數增加效能都有可能超越硬體較複雜的混合式波束成形；而 DENC
 42
所估測出來的訊雜比比較，可以看出其估測值跟實際的理想訊雜比相差很大。但
是如果把本計畫所提出的關於通道估測改進的第二個方法套用到先有文獻所提
出的方法所得出的訊雜比時，可以看出其結果跟理論值就非常接近了。最後，如
果把本計畫關於通道估測改進方面所提出的第一個和第二個方法一併套用到系
統裡面的話，可以得出最準確估測出的訊雜比。 
0 5 10 15 20 25
0
5
10
15
20
25
30
35
Input SNR(dB)
E
s
ti
m
a
te
d
 S
N
R
(d
B
)
 
 
Previous Works
Previous Works, with BC
Proposed
Ideal
 
圖四十. 訊雜比估測結果比較 
在套用了所提出的兩個方法之後，可以由上面兩張圖看出其所增進之通道響
應以及訊雜比的估測準確度。最後，在圖四十一中，我們可以來比較這兩個提出
的方法與先前文獻方法相比較，對於整個系統的位元錯誤率的影響。我們可以看
出，在無直射路線(non-light-of-sight, NLOS)通道環境中，對於先前方法來說，有
應用所提出的第二個方法來改善訊雜比的估測效能得來說，可以改善約 2dB 的
效能。如果同時應用本計畫所提出的兩個方法的話，在無直射路線通道環境中，
相對於先前方法可以大大地改善 2.3dB 的效能。因此可以看出，訊雜比的估測精
準度對於 MMSE-FDE 的影響是很大的。 
另外，對於直射路線(Light-of-sight, LOS)通道響應中，同時應用本計畫所提
出的兩個方法，可以改善現有文獻所提之方法之效能大約 0.4dB 左右。 
 44
表六. 多訊號流平行濾波器架構面積和功率消耗 
Structure Power(mW) Area Throughput(MHz) 
Multi-stream 8P Filter Architecture 35.2 86628 340 
另外前面也提到可以用[33]中提出的演算法簡化運算複雜度，我們分析了結
合該演算法後計算每一點濾波器輸出所需要的運算量如表七所示。 
表七. 結合[33]之演算法的運算複雜度分析 
 Types 1 & 3 Types 2 & 4 
 multiplication addition multiplication addition 
8K+3 & 8k+5 
312
1240103 +N
 
8
65
312
40-329
+
N
 
128
27N
 
8
27
-
128
81N
 
8K+1 & 8k+7 
128
24826 +N
 
2
13
128
8-82
+
N
 
27
64
N
 
81 27
-
64 4
N
 
 
  上表為提出架構在結合[33]之演算法後計算每一點濾波器輸出所需之運算量
分析，使用的多速率訊號處理架構中的兩個多相角濾波器在 type1、type3 案例中
都仍為線性相角濾波器，其乘法運算量約為 25N/64，而在 type2、type4 案例中
則為非線性相角濾波器，其乘法運算量約為 27N/64。因此提出架構的運算複雜
度在 type1 和 type3 的案例中可減少約 50%之乘法量，其代價為 55%的加法增加
量。在 type2 和 type4 中則可減少約 45%之乘法量而代價為 33%的加法增加量。 
4.快速傅立葉( FFT) 
我們所提出之快速傅立葉轉換處理器以 90nm 製成實現，將其效能與其他處理器
比較，列於表八。可得知我們所提架構具有高速，低面積，低功耗之特性。 
 
 
 
 
 
 
 
 
 
 
 
 46
 
圖四十三. 不同 Ng值下之GA-MSA 效能 
 
由圖四十二和圖四十三可發現 GA 的特性在世代數上升後明顯的它的效能
也會隨之上升，當然整體執行時間也會變長，其中 GA-SPA 隨世代數上升解碼效
果上升的情形也比 GA-MSA 明顯。 
另外，為了比較 GA-MP 與 ML 的差距，在這邊我們提出了一個技巧來模擬
ML，我們稱為 Super ML。其做法是利用 GA-MP 所收集的合法解(valid codeword)
加入正確碼字所形成一個新的集合(Super ML set)(當然，若所收集的合法解包括
正確碼字就不需要額外加入正確碼字)，而其 Super ML 之解即為此集合中的碼字
中擁有與通道值最小的歐氏距離之碼字。顯然這個技巧只能在軟體模擬中實現而
不可能實際應用在解碼演算法中(因為我們實際應用是無法得知正確碼字)。因此
我們可以知道 Super ML 的解釋必比 ML 解更佳。其證明如下: 
1. 若 ML 解為正確碼字: 
此情況就是說正確碼字即為在所有合法解中其最小歐氏距離的合法解。由於
Super ML set 裡必定包含正確碼字，因此 Super ML 解必定也為正確碼字。 
2. 若 ML 解不為正確碼字: 
此情況發生於在所有合法解中，其正確碼字的歐式距離不為最小(即有其他合
法解距離小於正解)。但是由於 Super ML set 裡不一定包括最小歐式距離的碼
字，因此 Super ML 解有可能會是正確碼字(即只要 Super ML set 中正確碼字
的歐式距離是整個 Super ML set 中最小的)。 
因此我們可以保證 Super-ML 的解碼效能一定優於或等於 ML 之解碼效能。因此
我可以使用 Super-ML 解來取代運算不易的 ML 解，做為新的參考指標。GA-MP
與 Super ML 的效能比較如下圖所示。 
 48
因為[8]的做法只在每次遞迴後的bit node傳送訊息做更新，它處理每個block
的最大遞迴數與 LDPC 原本遞迴數量一致，從圖四十五中我們比較要求高吞吐量
(throughput)的情形(遞迴數 200)，以及考慮極限效能的情形(遞迴數約 30000)，發
現我們的 GA-MP 在各種情形都會優於[8]的演算法，其中最大的差異在於極限效
能上 GA-MP 可以隨世代數(Ng)上升而不斷提高，但是[8]的方法只要遞迴數高於
一定值(如 200)就無法繼續上升，代表它無法真正解決 MP 解碼的弊端(即會發生
高信賴值(belief reliability)但是其硬決定解碼卻是錯誤的字元)。 
 
圖四十六. GA-MP 與[9]效能比較 
圖四十六將 GA-MP 與[9]效能做比較，可發現此兩種演算法在遞迴數增大情
況下都能接近 ML 解，其中[9]的演算法中，處理每個 block 的最大遞迴數與 LDPC
為(L0+(2^(jmax+1))-2)*L。不過我們與此篇 paper 最大差異為在硬體實現上。從
表九可知我們在額外增加的記憶體上不隨遞迴數增加而上升，但是[9]卻是以指
數型是成長，且它的方法不太適用於 MSA，而我們提出的方法較易於實現。 
表九. GA-MP 與[8][9]複雜度比較 
 [8] [9] GA-MP 
最大遞迴數 L0   
額外增加記憶體 None   
支援的演算法 SPA/MSA  SPA  SPA/MSA  
0 ( ) gL n L N+ + ×
3
wordlength
N×
×
max 1
0 (2 2)
j
L L
++ × −
max 1(2 2)
wordlength
j
N
+ − ×
×
[9] with SPA jmax=4 Lo=100 L=10 
[9] with SPAjmax=11 Lo=100 L=10 
 50
TRANSACTIONS ON COMMUNICATIONS, VOL. 58, NO. 11, Nov. 2010. 
 
國際會議論文 
1. Jui-Hui Hung, Jin-Shun Shyu and Sau-Gee Chen, “A New High-Performance and 
Low-Complexity Turbo-LDPC Code,” Proceedings of the 2011 IEEE 
International Conference on Network Computing and Information Security, 14-15 
May 2011, Guilin, China.  
2. Jui-Hui Hung and Sau-Gee Chen, “A 16Gbps Real-Time BF-based LDPC 
Decoder for IEEE 802.3an Standard,” Proceedings of the 2011 IEEE International 
Conference on Network Computing and Information Security, 14-15 May 2011, 
Guilin, China. 
3. Jui-Hui Hung and Sau-Gee Chen, “A Fast Systematic Optimized Comparison 
Algorithm for CNU Designs of LDPC Decoders,” Proc. of 2010 International 
Workshop on Information Communication Technology, Aug. 24-25, KMITL, 
Bangkok, Thailand. 
 
國內會議論文 
1. Ying-Tsung Lin and Sau-Gee Chen, “Joint Estimation of Timing and 
Carrier-Frequency Offsets for SCBT Systems without Using Unique Words,” 
Proceedings of 2011 National Symposium of Telecommunications, 18-19 
November, 2011. 
2. Chih-Liang Chen, Sau-Gee Chen and Ying-Tsung Lin, “Efficient Non-Coherent 
PSS Detections and Analysis for LTE Systems,” Proceedings of 2011 National 
Symposium of Telecommunications, 18-19 November, 2011. 
3. Shen-Jui Huang and Sau-Gee Chen, “A High-Throughput Radix-16 FFT 
Processor with Normal Input/Output Ordering for IEEE 802.15.3c,” Proceedings 
of the 22nd VLSI Design/CAD Symposium, 2-5 August, 2011.  
 52
參考文獻 
[1] K. Kato, S. Kato, “60GHz applications and propagation characteristics,”IEEE 
802.15-08-0651-01-003c, Sep. 2008. 
[2] T.Baykas, C.S. Sum, Z. Lan, J. Wang, M.A Rahman., H. Harada, S. Kato, “IEEE 
802.15.3c: The first IEEE wireless standard for data rates over 1 
Gb/s,”Communications Magazine, IEEE, vol. 49, Issue 5, pp. 114-121, July 2011. 
[3] P. Xia, X. Qin, H. Niu, H. Singh, H. Shao, J. Oh, C. Kweon, S. Kim, S.Yong, C. 
Ngo, “Short range gigabit wireless communications systems: potentials, 
challenges and techniques,” ICUWB 2007,pp. 123-128, Sep. 2007. 
[4]A. Pollok, W. Cowley, and N. Letzepis, “Symbol-wise beamforming for 
MIMO-OFDM transceivers in the presence of co-channel interferenceand     
spatial correlation”, IEEE Transactions on Wireless Communications, vol.8, no. 
12, pp. 5755-5760, Dec. 2009. 
[5] S.Yoon, T. Jeon and W. Lee, “Hybrid beam-forming and beam-switch for OFDM 
based wireless personal area network”, IEEE Journal on Selected Areas in 
Communications, vol. 27, no. 8, pp. 1425-1432, Oct. 2009. 
[6] X. Zhu , A. Doufexi , and T. Kocak, “Beamforming performance analysis for 
OFDM based IEEE 802.11ad millimeter-wave WPANs”,International Workshop 
on Multi-Carrier Systems & Solutions, 2011 8th, pp.1-5, May 2011. 
[7]Mitola Joe. Software radio architecture[ J ]. IEEE CommunicationMagazine,May 
1995: 6～38. 
[8]Z. Deng,L. Xingcheng and T.Man , “Modified BP decoding algorithms Ccombined 
with GA for low-density parity check codes,” International Conference on 
Computational Intelligence and Security, 2008. 
[9]N. Varnica, P. C. Marc, and K. Aleksandar, “Augmented belief propagation 
decoding of low-density parity check codes,” IEEETrans. Commun., pp. 
1308–1317,2007. ed 
[10] G.Grosskopf, R. Eggemann, H. Ehlers,A. Kortke, B. Kuhlow, G.Przyrembel, D. 
Rohde,S.Zinal,“Maximum directivity beam-former at 60GHz with optical feeder,” 
 54
[20] S. Johansson, S. He, and P. Nilsson, “Wordlength Optimization of a Pipelined 
FFT Processor,” Proc. 42nd Midwest Symp. Circuits and Systems, pp. 501-503, 
1999. 
[21] Y.N. Chang and K. Parhi, “An Efficient Pipelined FFT Architecture,” IEEE 
Transaction on Circuit and Systems-II: Analog and Digital Signal Processing, vol. 
50, No. 6, June 2003. 
[22] D. Cohen, “Simplified control scheme of FFT hardware,” IEEE Transaction on 
Signal Processing, vol. ASSP-24, pp. 577-579, Dec. 1976. 
[23] L.G. Johnson, “Conflict Free Memory Addressing for Dedicated FFT Hardware,” 
IEEE Trans. Circuits Syst. II: Analog and Digital Signal Processing, vol. 39, no. 5, 
pp. 312-316, May. 1992. 
[24] Yutai Ma, “An Effective Memory Addressing Scheme for FFT Processors,” 
IEEE Transactions on Signal Processing, vol. 47 Issue: 3, pp. 907-911, March 
1999. 
[25] Y. Ma and L. Wanhammar, “A hardware efficient control of memory addressing 
for high-performance FFT processors,” IEEE Transactions on Signal Processing, 
vol. 48, No.3, pp. 917-921, March 2000. 
[26] S.J. Huang and Sau-Gee Chen, “A green FFT processor with 2.5-GS/s for IEEE 
802.15.3c (WPANs),” IEEE Int. Conf. Green Circuit and Systems, pp. 9-13, Jun, 
2010. 
[27] X. Y. Hu, E. Eleftheriou, D. M. Arnold, and A. Dholakia, 
“Efficientimplementation of the sum-product algorithm for decoding LDPC 
codes,”IEEE GLOBECOM’01, vol. 02, pp. 1036-1036E, Nov. 2001. 
[28] J.Chen and M. P.C. Fossorier, “Near optimum universal belief propagation based 
decoding of low-density parity check codes,”IEEE Trans. on Commun., vol. 50, 
pp. 583-587, NO.3 Mar. 2002. 
[29] M. Xu and J. Wu, “A modified Offset Min-Sum decoding algorithm for LDPC 
codes,”IEEE Trans. on Commun, Sep. 2010. 
[30] R. G. Gallager, “Low density parity check codes,” IRE Trans. Inform. Theory, 
vol. IT-8, pp. 21–28, Jan. 1962. 
 6
 
國科會補助專題研究計畫項下出席國際學術會議心得報告 
                                     日期：100 年 06 月 01 日 
一、參加會議經過 
此會議為近數年來職在大陸參加的第二個國際性會議，大陸近年來努力提升其研
究能量及國際知名度，因此積極主辦國際性學術會議，由於地利及時間之便因此投
稿於此會議。此次會議具大會資料顯示共約有來自全球約 20幾個國家 900 餘篇投稿
論文，最後僅約 150 篇論文被接受發表，因此能被接受發表可謂十分不易，職的研
究很榮幸受到肯定共有兩篇論文被揪受發表，且為口頭發表之論文。另來自台灣的
尚有中正大學資工系柳金章教授的論文。會議於 5/14-15 於山明水秀的桂林舉行。
計畫編號 NSC  99-2220-E-009-016- 
計畫名稱 使用 60GHz之室內十億級位元傳輸率之無線基頻傳收機--子計畫四：以 60GHz室內無線個人網路為核心之多標準基頻接收機處理器設計(3/3) 
出國人員
姓名 陳紹基 
服務機構
及職稱 交通大學電子工程系 
會議時間 100 年 5 月 14 日至 100 年 5 月 15 日 會議地點 中國大陸桂林 
會議名稱 
(中文)2011 年國際網路計算與資訊安全會議 
(英文)2011 International Conference on Network Computing & Information 
Security 
發表論文
題目 
(中文) 1. 一個新的高效能、低複雜度之渦輪-低密度奇偶碼 
2. 一個適用於 IEEE 802.3an標準之 16Gbps、可即時處理之位元翻轉式低
密度奇偶碼 
(英文) 1.  A New High-Performance and Low-Complexity Turbo-LDPC Code 
2.  A 16Gbps Real-Time BF-based LDPC Decoder for IEEE 802.3an 
Standard 
附件四 
 8
二、與會心得 
現在大陸舉辦國際會議十分頻繁，因此水準參差不齊，本會議亦然，雖然論文錄取
率極低，但主辦單位整體會場與活動安排較為不周到，有諸多缺失。另一問題為現
在大陸、台灣學術交流頻繁，因此雙方在名稱上會觸及敏感問題，特別是台灣學者
的單位名稱有被矮化之虞。 
 
三、考察參觀活動(無是項活動者略) 
無 
 
四、建議 
因此建議政府應更明確規範台灣大陸雙邊交流活動的相關準則以免被矮化。大陸學
界的積極與努力提升國際知名度非常值得我們學習 
 
五、攜回資料名稱及內容 
會議光碟一片 
 
六、其他 
無 
 
 
A 16Gbps Real-Time BF-based LDPC Decoder for IEEE 802.3an Standard 
 
Jui-Hui Hung1 and Sau-Gee Chen2  
Institute of Electronics & Department of Electronics Engineering  
National Chiao Tung University 
 Hsinchu, Taiwan 
e-mail: 1paholisi.nctu@gmail.com 2sgchen@mail.nctu.edu.tw 
 
Abstract—Existing LDPC decoders are mostly based on 
belief-propagation (BP) algorithms for high decoding 
performance but demand high hardware cost, especially for 
applications with very high throughputs. In order to 
alleviate the problem, this work proposes a high-throughput 
LDPC decoder based on the much simpler bit-flipping (BF) 
algorithms, for the (2048, 1723) RS-LDPC code adopted in 
the IEEE 802.3an standard. High decoding performances 
and low iteration numbers are achieved by introducing a 
strategy of flipping low-correlation bits and an additional 
syndrome vote scheme. As a result, the decoding 
performance is comparable to the most popular BP-based 
min-sum algorithm (MSA) but with much lower 
computational complexity. Besides, the decoder achieves 
high hardware utilization with real-time processing 
capability. Synthesized with UMC 90nm process, the 
decoder chip area, throughput and average power 
dissipation are 1.22M gates, 16Gbps and 315mW, 
respectively, at 500MHz clock rate. 
Keywords-channel coding; ldpc; hardware design; 802.3an 
standard 
I.  INTRODUCTION 
Low-density parity-check (LDPC) codes [1] were 
proposed in the early 1960’s, which have been shown to 
achieve BER performances very close to the Shannon 
bound, when operated with iterative belief propagation 
(BP) decoding algorithm and sufficiently long code length 
[2]. The sum-product algorithm (SPA) [3], a realization of 
the BP algorithm, has the best decoding performance 
among the existing BP-based algorithms. However, it is 
impractical for applications, due to its high complexity. In 
comparison, the popular min-sum algorithm (MSA) [4] 
and modified MSA [5] (all simplified from SPA) have 
lower complexities than SPA, but with comparable 
performances. Besides, to meet the demanding 
requirements of high-throughput applications, fully-
parallel LDPC decoders [6], [7] were proposed. However, 
those decoders are very area consuming, even though they 
use simplified SPA algorithms (i.e., MSA and modified 
MSA). 
In contrast to the mentioned BP-based algorithms (i.e., 
SPA, MSA and modified MSA), the bit-flipping (BF) 
algorithm in [1] adopts a much simpler bit-update scheme 
and hence has a much lower complexity than BP-based 
algorithms. However, its performance is much lower than 
all those BP algorithms. To remedy this problem, some 
improved BF techniques have been proposed, including 
the weighted bit-flipping (WBF) algorithm [8], the 
modified WBF (MWBF) algorithm [9], and the improved 
MWBF (IMWBF) algorithm [10]. Among those BF 
algorithms, IMWBF algorithm has the best decoding 
performance, with comparable complexity to those other 
BF algorithms. Nevertheless, all of them are still 
significantly inferior to SPA and MSA in terms of 
performance.  
All the mentioned BF-based algorithms only flip one 
bit in each iteration and demand high iteration counts to 
obtain satisfactory decoding results. To speed up decoding 
process, recently we proposed a multi-bit flipping 
decoding algorithm, called LCCBT-MBF algorithm [11] 
which achieves high decoding performances with low 
iteration counts. Since LCCBT-MBF algorithm has much 
lower complexities than the BP-based SPA and MSA 
algorithms, it is suitable for applications with very high 
throughputs. In this work, the algorithm has been applied 
to the decoder hardware realization of the (2048, 1723) 
RS-LDPC code [12] adopted in 10-Gbps IEEE 802.3an 
standard [13]. Such high data rate poses a stringent 
challenge to the LDPC decoder design. The proposed 
decoder not only satisfies the high throughput requirement, 
but also has much smaller chip area compared with the 
existing BP-based decoders. 
II. THE LCCBT-MBF ALGORITHM [11] 
LCCBT-MBF algorithm combines the most effective 
IMWBF algorithms with our two recently proposed 
performance-enhancement algorithms, termed Culprit Bit 
Test (CBT) algorithm [14] and Low-Correlation Multi-Bit 
Flipping (LCMBF) algorithm [15]. To speed up the LDPC 
decoding process, the most intuitive and simplest way is to 
flip more than one bit in each iteration, as done in LCMBF 
algorithm. Overall, LCCBT-MBF algorithm not only 
improves the BER performance, but also significantly 
reduces the iteration number of the existing BF decoding 
algorithms.  
The basic idea of the CBT algorithm is to find out and 
flip those potential culprit error bits which have more 1s 
than 0s in its associated syndrome bits of the syndrome 
vector. By doing so, the syndrome vector will get closer to 
the zero vector than before. One can simply identify a 
culprit bit by checking its reliability [8] and conducting the 
majority vote operation on the bit’s associated syndrome 
bits. 
By flipping more than one bit in each iteration, there is 
risk that one may induce additional error bits and 
propagate the errors to later iterations [15]. LCMBF 
algorithm further reduces the error probability by 
2011 International Conference on Multimedia and Signal Processing
978-0-7695-4356-7/11 $26.00 © 2011 IEEE
DOI 10.1109/CMSP.2011.19
63
 
Figure 1.  The proposed LDPC decoder architecture for IEEE 802.3an standard. 
generality. In this algorithm, given a check node cj, and the 
bit node set ( )jB c  composed of all the bit nodes 
connected to cj, all jc  nodes,
 
1 to 384,j =
 
need to 
compute the following so called reliability information 
which will be sent to all ib  nodes ( )jB c∈  
  min , ( )\
| | min ,  ( ),
k j i
i j k i jb B c b
y y b B c
−
∈
= ∈
 (1) 
where yk is the received channel value of the kth bit (i.e., bit 
node kb ), 
( )jB c  is the set containing all the bit nodes 
connected to cj, and ( ) \j iB c b  represents the set ( )jB c  
excluding ib  . According to (1), a p-input CNU (i.e., the 
check node is connected to p bit nodes) also needs to 
generate p outputs for all its connected bit nodes.  
In realizing (1), it is well known that a CNU only 
needs to find out the minimum and second minimum 
absolute values of its received channel values, and then 
pick one of these two values, depending on if the particular 
bit node’s message value is equal to the minimum value or 
not. Hence, the output number of a CNU can be reduce to 
two (i.e., the minimum and second minimum values) and 
use an index information to indicate which input has the 
minimum value. For convenience, we term this design as 
“two-minimum CNU” (i.e., TM-CNU for simplicity). 
For high throughput requirement, we propose a new 
CNU architecture which can get a shorter delay time and 
smaller hardware cost than conventional TM-CNU 
structures [17]. The new design is basically based on 
Priority Decoders (PD). A PD decodes its n-bit input value 
to an expanded 2n-bit output format, called PD 
representation, which has zero bit values in all its 2n bit 
positions, except the value of ‘1’ in the Mth bit position, 
where M is magnitude of the n-bit input.   
In the proposed CNU architecture, for finding out the 
minimum and second minimum values form a set of 
several n-bit values, we firstly use PDs to decode each 
element in the set, and then the minimum and second 
minimum values can be obtained by detecting the lowest 
and second lowest positions of ‘1’ from the bitwise OR 
operation result of all PD outputs. The operations are 
realized by a minimum decoder (Min1_Dec) and a second 
minimum decoder (Min2_Dec) which find out the 
minimum and the second minimum values, respectively. 
However, if there are two (or more) elements in the set 
have the same values with the minimum value, the second 
minimum value should be equal to the minimum value. 
Hence, we employ an Equality Checker (EC) to deal with 
this condition.  
2) Bit Node Unit 
Based on IMWBF algorithm, a BNU computes the 
following total reliability iE  of bit node ib  by using all 
the reliability information (1) it receives from its 
connecting check nodes: 
 min ,
: ( )
(2 1) | | , 1 to 2048,
j i
i j i j i
j c C b
E s y y iα
−
∈
= − ⋅ − ⋅ =∑  (2) 
where ( )iC b  denotes the set of check nodes connected to 
65
 
Figure 2.  The architecture of Max-8 Sorter. 
3 4 5 6 7 8 9 10 11
10-10
10-8
10-6
10-4
10-2
100
SNR
BE
R
 
 
BPSK
modified MSA Nitr=2
modified MSA Nitr=8
IMWBF Nitr=16
IMWBF with LCCBT-MBF Nitr=16
 
Figure 3.  The (4,2) fixed-point performance of the LCCBT-MBF 
algorithm combined with IMWBF and modified MSA algorithms at Nfb 
= 2 and Nitr = 16, for 802.3an standard. 
TABLE I.  COMPARISON OF THE PROPOSED LDPC DECODER WITH 
THE EXISTING ARCHITECTURES 
 [6] [7] Proposed  
Quantization bits 5 4 4 
Technology (nm) 180 90 90 
Clock rate (MHz) 52 250 500 
Iteration number N/A 8 16 
Throughput 7.1G 16G 16G 
Gate count ≈3.38M 2.23M 1.22M 
Power dissipation 
(mW) N/A N/A 315@0.9V 
Decoding 
performance  
(SNR @ BER=10-6) 
N/A N/A 5.3 
Architecture Split-row(a) fully parallel 
Bit-serial 
fully 
parallel 
Fully parallel 
Decoding algorithm MSA Modified MSA LCCBT-MBF 
V. CONCLUSION 
A high-throughput LDPC decoder, based on our 
recently developed LCCBT-MBF decoding algorithm, for 
IEEE 802.3an 10G standard has been proposed. The 
synthesized decoder throughput is about 16Gbps which is 
much higher than the requirement 10Gbps of the IEEE 
802.3an standard. Since the decoding algorithm is a BF-
based algorithm, it has much lower complexity than the 
designs based on the most popular BP-based decoding 
algorithms. As a result, with comparable decoding 
performance, the realized decoder has higher performance 
than existing BP-based decoders, in terms of speed, area 
and power consumption. 
ACKNOWLEDGMENT 
This work is supported in part by the grants NSC 98-
2220-E-009 -029 and NSC 98-2219-E-009 -010, Taiwan. 
REFERENCES 
[1] R. G. Gallager, “Low density parity check codes,” IRE Trans. 
Inform. Theory, vol. IT-8, pp. 21–28, Jan. 1962. 
[2] D. J. C. MacKay and R. M. Neal, “Near Shannon Limit 
Performance of Low Density Parity Check Codes,” Electronics 
Letters, vol. 32, no. 18, pp. 1645–1646, Aug. 1996. 
[3] D. J. C. Mackay, “Good Error-Correcting Codes Based on Very 
Sparse Matrices,” IEEE Trans. Inform. Theory, vol. 45, pp. 399-
431, Mar. 1999. 
[4] X. Y. Hu, E. Eleftheriou, D. M. Arnold, and A. Dholakia, 
“Efficient implementation of the sum-product algorithm for 
decoding LDPC codes,” in Proc. IEEE GLOBECOM’01, vol. 02, 
pp. 1036-1036E, Nov. 2001. 
[5] J. Chen and M. P. C. Fossorier, “Near optimum universal belief 
propagation based decoding of low-density parity check codes,” 
IEEE Trans. Commun., vol. 50, pp. 583-587, no.3 Mar. 2002. 
[6] T. Mohsenin and B. M. Baas, “High-Throughput LDPC Decoders 
Using a Multiple Split-Row Method,” IEEE ICASSP, vol. 2, pp. 
II–13–II–16, Apr. 2007. 
[7] A. Darabiha, A. C. Carusone, and F. R. Kschischang, “A 3.3-Gbps 
Bit-Serial Block-Interlaced Min-Sum LDPC Decoder in 0.13-μm 
CMOS,” IEEE CICC, pp. 459-462, 2007. 
[8] Y. Kou, S. Lin, and, M. P. C. Fossorier, “Low-Density Parity 
Check Codes Based on Finite Geometries: A Rediscovery and 
More,”IEEE Trans. Inform. Theory, pp. 2711-2736, 2001. 
[9] J. Zhang, M.P.C. Fossorier, “A Modified Weighted Bit-Flipping 
Decoding of Low-Density Parity-Check Codes,”IEEE Commun. 
Lett., vol. 8, pp. 165-167, Mar. 2004. 
[10] M. Jiang, C. Zhao, Z.Shi, and Y. Chen, “An Improvement on the 
Modified Weighted Bit Flipping Decoding algorithm for LDPC 
Codes,”IEEE Commum., Vol. 9, No.9, pp.814-816, Sept. 2005. 
[11] J. H. Hung and S. G. Chen, “A High-Performance Multibit-
Flipping Algorithm for LDPC Decoding,” IEEE Proceedings of 
ISIC, pp. 1-5, Dec. 2009.  
[12] I. Djurdjevic, J. Xu, K. Abdel-Ghaffar, and S. Lin, “Construction 
of Low-Density Parity-Check Codes Based on Shortened Reed-
Solomon Codes with Two Information Symbols,” IEEE Commun. 
Lettetters, No. 7, pp. 317-318, July 2003. 
[13] Carrier Sense Multiple Access with Collision Detection 
(CSMA/CD) Access Method and Physical Layer Specifications, 
IEEE Std. 802.3an, 2006. 
[14] J. H. Hung and S. G. Chen, “An Efficient BF LDPC Decoding 
Algorithm Based on A Syndrome Vote Scheme,” IEEE 
Proceedings of APCC, pp. 1-5, Oct. 2008.  
[15] J. H. Hung and S. G. Chen, “An Effective Multibit-Flipping 
Algorithm for LDPC Decoding,” IEEE Proceedings of ICSPCS, 
p.p. 15-17, Dec. 2008. 
[16] R. Tanner, “A Recursive Approach to Low Complexity Codes,” 
IEEE Trans. Inform. Theory, Vol. 27, pp. 533-547, Sept. 1981. 
[17] C. C. Lin, K. L. Lin, H. C. Chang and C. Y. Lee, “A 3.33Gb/s 
(1200,720) low-density parity check code decoder,” IEEE 
Proceedings of ESSCIRC, pp.211-214, Sept. 2005. 
67
Then P can be denoted as 1 2C C×  or 
2
1C , if 1 2C C= . 
The overall code rate of P  is 1 2R R R= × , where iR  is the 
code rate of iC . Thus, one can build very long block codes 
with large minimum Hamming distances based on the 
product code structure. According to the construction 
procedure, one can realize that all the rows and columns of 
the matrix are 1C  codewords and 2C  codewords, 
respectively.  
B. Decoding scheme [11] 
Consider product code P  transmitted in binary symbols 
of +1 and -1 on an AWGN channel (with a standard 
deviation σ ). The transmitted data is defined as a 1 2n n×  
matrix Y. After the BTC decoder receives channel values, 
which in turn are contained in the message matrix R=Y+Z, 
where Z is a 1 2n n×  AWGN matrix, the decoder 
interchangeably decode all the columns and then all the rows 
of R, and so on until a maximum number itrturbo of turbo 
iterations is reached. For convenience of further discussion, 
we denote a single run of all the column (or row) decoding 
operations as a turbo decoding operation and index it with 
integer notation i. Furthermore, a turbo iteration is defined as 
a pair of cascaded column (or row) turbo decoding operation 
and row (or column) turbo decoding operation. Therefore, 
the i/2-th turbo iteration comprises (i-1)-th and i-th turbo 
decoding operations, where i is an even integer without loss 
of generality.  
For the i-th turbo decoding operation of R, i=1 to 
2 turboitr× , the decoder first determines the suboptimal 
codeword matrix D(i) [11] from the soft input matrix (i.e., 
also called reliability matrix R(i)) by using Chase algorithm. 
Note that R(i) in the 1st turbo decoding operation (i.e., R(1)) 
is equal to R. Then, the decoder computes the reliabilities of 
the row (or column) vector of the suboptimal codeword 
matrix D(i) by using 
 
2 2( ) ( ) ( ) ( )
( ( 1)) ( )
4
r i d i r i d i
d i d i
′
− − −
Λ + =
⎛ ⎞⎜ ⎟⎝ ⎠
K KK KK K
, (1) 
where ( )r iK , ( )d iK  are codeword vectors of a row (or column) 
of R(i) and D(i), respectively, and function | f g−
K K | 
represents the Euclidean distance between codeword vectors 
f
K  and gK . Differing from ( )d iK  in the i-th turbo decoding 
operation, ( )d i′
K
is called the competing codeword, which is 
the codeword with the minimum Euclidean distance from 
( )r iK . If the competing codeword does not exist, the decoder 
should use the following equation to replace (1): 
 ( ( 1)) ( ) ( ) ( )d i r i i d iβΛ + = + ×K KK , (2) 
where ( )iβ  is a predefined reliability factor in the i-th turbo 
decoding operation[11]. Actually, ( )iβ  can be considered as 
an average reliability of those suboptimal codewords which 
have no corresponding competing codewords. After 
obtaining the reliabilities ( ( 1))iΛ +D  of D(i+1), the decoder 
generates the following extrinsic information matrix 
( 1)i +W :  
 ( 1) ( ( 1))i i+ = Λ + −W D R . (3) 
Next, since the standard deviation of absolute values of 
the elements in R and W(i+1) are different [11], the decoder 
obtains the soft output matrix by using the following 
equation: 
 ( ) ( )1 ( ) 1 ,i i iα+ = + +R R W  (4) 
where ( )iα  is a scaling factor used to reduce the standard 
derivation of W(i+1). ( )iα  should be initialized to a small 
value which will grow larger gradually as the iteration 
increases [11]. According to (4), one can find that the soft 
output matrix R(i+1) is the soft input matrix for the (i+1)-th 
turbo decoding operation. Hence, for each decoding 
operation, the decoder adjusts the received channel value 
matrix by adding the extrinsic information matrix generated 
in the previous turbo decoding operation. 
III. THE PROPOSED TURBO-LDPC CODES 
According to the decoding procedures for block turbo 
codes introduced in the previous section, the BTC decoder 
receives the extrinsic information matrix W(i+1) generated 
in the i-th turbo decoding operation, and determines the 
suboptimal codeword matrix D(i) by using Chase algorithm. 
However, Chase algorithm used in the SISO decoder is 
based on the algebraic decoder, and the propagation of 
extrinsic information is restricted due to the limited error 
correction capability of a common algebraic decoder. 
Besides, the computation complexity of Chase algorithm is 
proportional to the size of candidate set. If one decreases the 
size so as to reduce the computation complexity, the 
probability of missing the competing codewords will 
increase. Although we can utilize a predefined reliability 
factor ( )iβ for alleviating the problem, the improvement on 
the decoding performance is limited.  
To relax the limitation induced by Chase algorithm used 
in BTC decoding, this work proposes a new coding scheme 
named the Turbo-LDPC code which applies the LDPC codes 
to the block turbo coding scheme. Unlike other linear block 
codes, the error correction capability of the LDPC codes do 
not have the mentioned problem of restricted extrinsic 
information propagation found in common algebraic codes. 
The proposed Turbo-LDPC code is similar to BTC but 
employs the LDPC codes for the rows and columns encoding 
and decoding operations. It implies that the information 
network of each bit can cover the whole codes. Besides, it is 
69
other correct bit nodes with small values, those erratic bit 
nodes’ extrinsic information will dominate the correct bit 
nodes’ extrinsic information. Hence, eventually some 
originally correct bit nodes may be modified to incorrect 
values after LDPC decoding. This kind of local errors will 
globally propagate to the whole codes and significantly 
degrade the overall decoding performance. This problem can 
be significantly alleviated by introducing an extrinsic 
information normalization process as follows. 
3) Remedy for belief propagation distortion 
For reducing the belief propagation distortion in Turbo-
LDPC decoding caused by multiple LDPC decoding 
iterations, we propose an extrinsic information normalization 
(EIN) method which maps an extrinsic information to a more 
balanced value than without normalization. As a result, the 
belief propagation distortion can be reduced. The 
normalization is done by considering the propagation 
mechanism among all the absolute mean values of LLR 
values in each turbo decoding operation, as explained below.  
Since the value of extrinsic information grows with the 
number of LDPC decoding iterations, belief propagation 
distortion in Turbo-LDPC decoding will be increasingly 
severe due to the diverging extrinsic information as the 
number of LDPC decoding iterations increases. Thus, the 
key concept of the EIN is to map the extrinsic propagation 
information after multiple LDPC iterations to the extrinsic 
information after the single LDPC iteration.  
Since the normalization process is code-dependent, for a 
specific code, we first extensively simulate the mean 
absolute extrinsic values ys(i)s, i=1 to 2 turboitr× , of the single 
LDPC iteration (i.e., itrldpc=1) for each turbo decoding 
operation. Next, since the extrinsic propagation information 
of multiple LDPC iterations will be normalized to that of 
single LDPC iteration in each turbo decoding operation, in 
evaluating the mean absolute extrinsic values ym(i) , i=1 to 
2 turboitr× , due to multiple LDPC iterations, the LDPC 
iteration numbers in all the previous turbo decoding 
operations (i.e., from 1 to i-1) should be set to one.    
Next, one can form a piecewise linear curve on a 2-D 
coordinate, by linearly connecting all the consecutive 
coordinate point pair of (ym(i),ys(i)) and (ym(i+1),ys(i+1)), i=1 
to 2 turboitr× , where ym(i) and ys(i) are the horizontal and 
vertical coordinate components, respectively. Hence, when 
doing Turbo-LDPC decoding, one can interpolate and obtain 
the normalized extrinsic information value from the 
following piecewise linear mapping equation: 
 ( ) i iy x a x b= ⋅ + , (8) 
if the input extrinsic value x is in the i-th segment, where ia  
and ib  are the slope and offset of the i-th segment, 
respectively.  
The performance improvements by using EIN for EG 
2(63, 37,8,8) Turbo-LDPC codes with SPA and MSA are 
shown in Fig. 1, which indicates that the belief propagation 
distortion can be effectively eliminated. After EIN process, 
the soft output matrix R(i+1) of the Turbo-LDPC decoder in 
the i-th turbo decoding operation can be obtained by 
plugging W(i+1) into (8). 
IV. SIMULATION RESULTS AND COMPARISON  
In this section, we will discuss the performance of the 
Turbo-LDPC codes from three aspects. Note that all the 
simulations here are based on BPSK data modulation and 
AWGN channel environment, and all the Turbo-LDPC codes 
are decoded with the help of EIN method. 
A. Performance evaluation of Turbo-LDPC code  
As mention before, each turbo iteration of the Turbo-
LDPC code contains one row decoding and one column 
decoding, while each row (or column) decoding contains 
multiple LDPC iterations. Thus, the total LDPC iteration 
number is ( )2total ldpc turboitr itr itr= × × . There are many 
different iteration number settings (itrldpc,itrturbo) can be 
selected for a fixed itrtotal. All of them correspond to the 
same computational complexity (excluding the 
computational complexity of EIN method). Fig. 2 shows the 
performance comparisons of SPA when itrtotal is 24 for EG 
( )263,37,8,8  Turbo-LDPC code. One can see that the 
decoding performances of Turbo-LDPC codes are higher 
than that of the original LDPC codes by more than 3dB 
under the similar computational complexity. Besides, one 
can see that it leads to the best performance when 2ldpcitr = .  
B. Performance and computational complexity 
comparisons of Turbo-LDPC code with BCH BTC 
Before comparing the proposed Turbo-LDPC code with 
BCH BTC, we first compare the decoding performance of 
their component codes: original (63,37,8,8) EG-LDPC code 
employing MSA for decoding algorithm and (63,36,11) 
BCH code with Chase algorithm as shown in Fig. 3. One can 
see that the original (63,37,8,8) EG-LDPC code has better 
performance than (63,36,11) BCH code when 2ldpcitr ≥ . In 
the same figure, the performance comparisons of EG 
(63,37,8,8)2 Turbo-LDPC code employing MSA and 
(63,36,11)2 BCH BTC with different parameters are shown. 
Note that, for BCH BTC, the pattern codeword number is set 
to 52 32=  for the 5 least reliable positions, and ( )iα  and 
( )iβ  values are set to the same values suggested in [11].  
The comparison of computational complexities for 
Turbo-LDPC code and BCH BTC are shown in Table I. In 
the table, one can see that the Turbo-LDPC codes adopting 
EIN with parameters (itrldpc,itrturbo)=(4,3) needs more 
addition operations (i.e., 2493099-2262456=230643) but 
much less multiplication operations (i.e., 5506704-19845= 
5486859) than BCH BTC. It means that the proposed Turbo-
LDPC code not only has higher decoding performance, but 
also lower computational complexity than BCH BTC. Due to 
page limit, the detail derivations of the computational 
complexity of BCH BTC and Turbo-LDPC are omitted here. 
71
國科會補助計畫衍生研發成果推廣資料表
日期:2011/12/21
國科會補助計畫
計畫名稱: 子計畫四：以60GHz室內無線個人網路為核心之多標準基頻接收機處理器設計
(3/3)
計畫主持人: 陳紹基
計畫編號: 99-2220-E-009-016- 學門領域: 晶片科技計畫--整合型學術研究
計畫
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
