flow would travel to the lowest point of the terrain. 
Some water of the flow will evaporate to the 
atmosphere and return to the ground by precipitation. 
To elevate WFA one further step to cover the 
computational models for various optimization 
problems, the meta operational flow of the WFA has 
been rigorously designed to establish standard 
computation procedures. The software design pattern 
for implementing the WFA has been developed and 
modeled in UML models. In addition, the 
implementation framework has been developed in the 
object-oriented C# programming language, namely 
WFABOF for WFA-Based Optimization Framework. In 
addition, benchmarks from OR-LIB have been included 
in each individual solving system. 
Four operations research problems have been studied, 
including single and multi-objective continuous 
optimization problems, job-shop scheduling problems, 
and capacitated vehicle routing problems. Their WFA 
optimization models have been developed using the 
proposed WFA meta heuristic algorithm. Their problem 
solving systems were implemented by using the 
developed WAFBOF framework. Numerical experimental 
tests on various benchmarks have been conducted on 
the developed computational models and results have 
been compared with other heuristic methods. Results 
show that the WFA can be widely applied to solve 
various kinds of optimization problems and results 
were in general superior to those of other methods. 
 
英文關鍵詞： meat heuristic algorithm, water flow-like algorithm, 
design pattern, software framework, optimization 
problem, JSP, VRP, multi-objective 
 
i 
中文摘要 
仿水流優化演算法(Water Flow-like Algorithm；WFA)是一種動態調整代理人數量的啟發式
優化演算法。此法是以單一水流代理人為起始，演化過程視需要會分流進行廣域搜尋或匯流多
個水流成單一代理人，避免重覆搜尋。本研究的目的在使 WFA 能躋身萬用啟發式演算法(meta 
heuristics)之林，並應用於求解各類複雜的優化實務問題。本研究首先承續並擴展已發表的 WFA
求解離散優化問題的方法，研擬連續型優化問題的仿水流優化演算模式和實作求解系統。接著
綜合兩種類型的 WFA 演算法流程和實作經驗，完成 WFA 優化法的設計典樣(design pattern)分
析和模型建置。同時晚整規標準的 meta 演算流程，並據以開發各種求解系統實作共同使用的
WFABOF 軟體礎架(WFA-Based Optimization Framework)。後期分別進行並完成「多目標連續
型優化問題」、「工式生產排程問題」、「車輛途程問題」等不同優化類型議題的仿水流求解
模式開發並以此礎架實作求解系統。研究內容涵蓋 WFA 求解模式的建構，擴充泛用演算流程
的涵蓋性，提升 WFA 演算流程的 meta 層級；同時擴充 WFABOF 軟體礎架的覆用性、擴充性、
和維修姓。礎架的建構過程同時也完成了多種 ORs 標竿問題的類別庫建置，支援數值範例測
詴。各類優化問題的研究均進行多個標竿問題的數值範例測詴，並與其他啟發式演算法進行求
解效能比較。研究結果已具體提升並驗證 WFA 能廣泛適用於單目標、多目標、離散型、連續
型、一般型、多限制型等各種優化問題，且求解效能不亞於現有的各種啟發是演算法。 
關鍵詞：啟發式演算法、仿水流優化演算法、設計典樣、軟體礎架、優化問題、多目標、零工
生產排程、車輛途程問題 
  
iii 
目錄 
 
中文摘要 ................................................................................................................................ I 
ABSTRACT .......................................................................................................................... II 
目錄 ......................................................................................................................................III 
壹、 前言 .................................................................................................................... 1 
貳、 研究的目的 .......................................................................................................... 2 
參、 研究成果 ............................................................................................................. 3 
一、 連續優化問題之仿水流優化演算法 .................................................................. 3 
1. 演算流程 .............................................................................................................................................................................. 3 
2. 範例測詴 .............................................................................................................................................................................. 7 
3. 結果與討論 ........................................................................................................................................................................ 10 
4. 參考文獻 ............................................................................................................................................................................ 11 
二、 WFA 的 meta 架構和標準演算流程 .................................................................13 
1. WFA 的 meta 架構 ............................................................................................................................................................ 13 
2. WFA 的標準演算流程 ........................................................................................................................................................ 13 
3. WFABOF 軟體礎架 ............................................................................................................................................................ 17 
4. 結論與討論 ........................................................................................................................................................................ 17 
5. 參考文獻 ............................................................................................................................................................................ 19 
三、 求解車輛途程問題的仿水流演算法 .................................................................21 
1. 前言 .................................................................................................................................................................................... 21 
2. 車輛途程問題支仿水流演算模式和程序 ......................................................................................................................... 21 
3. 仿水流演算法求解系統 ..................................................................................................................................................... 38 
4. 範例測詴效能驗證............................................................................................................................................................. 40 
5. 結論與建議 ........................................................................................................................................................................ 46 
6. 參考文獻 ............................................................................................................................................................................ 46 
四、 求解零工式生產排程問題的仿水流優化演算法 ................................................48 
1. 緒論 .................................................................................................................................................................................... 48 
2. 文獻探討 ............................................................................................................................................................................ 48 
3. 零工式生產排程問題及其仿水流演算求解法 ................................................................................................................. 49 
4. 仿水流優化演算法系統及範例驗證 ................................................................................................................................. 78 
5. 結論與建議 ........................................................................................................................................................................ 82 
6. 參考文獻 ............................................................................................................................................................................ 83 
五、 多目標連續型仿水流優化演算法 .....................................................................84 
1. 簡介 .................................................................................................................................................................................... 84 
2. 多目標連續型仿水流優化演算法 ..................................................................................................................................... 84 
3. 多目標連續型仿水流優化演算法範例驗證 ..................................................................................................................... 92 
4. 結論與建議 ........................................................................................................................................................................ 99 
5. 參考文獻 .......................................................................................................................................................................... 100 
 
2 
係將代理人模擬成水流在解空間中搜尋最佳解。仿水流的分流和匯流特性，動態調整代理人的
數量，進行少數集中或多數分散搜尋。此外並模擬水流蒸發和降水特性，使搜尋能有機會跳脫
區域最佳解。WFA 在解搜尋過程中透過分流、匯流、蒸發、降水四個演化作業調整水流代理
人的數量，兼顧節空間的探索(Exploration)和探究(Exploitation)，避免搜尋過度或搜尋不足。
WFA 演算的主要流程與其他啟發式演算法類似，如圖 0-1 所示，主要的差異是代理人的數目
經水流分流、匯流、降水作業會動態變動。 
仿水流優化法首創代理人數量動態變化的模式。其中規劃的分流移動程序類似於蟻拓法的
解建構程序。不同的是並非重新建構一個解，而是參考母水流的解建構子水流的新解。其中會
參考母水流的位置和目標函數值改善量(梯度差類似目標函數的 gradient)，且可在移動演算程
序中考量問題的限制條件，確保移動後的合理解。當水流每代次的移動都朝最佳解移動時(梯
度大)無頇分流，當搜尋效果緩慢(梯度小)且動能充足時，進行分流作業產生多個子水流進行廣
域的探索。降水和匯流的機制可在陷入局部最佳解時有機會跳脫，避免重複搜尋的浪費。迄今
已提出的物件分群和物件排序的仿水流優化模式，  
WFA 自 2007 年提出後，皆應用於求解物件分群優化與一般物件排序優化的離散型變數問
題求解模式。在未參看問題啟發資訊下與其他方法比較成效絲毫不遜色。WFA 相較於現有的
啟發式法有更廣的優化問題型態涵蓋性、具能迎合限制條件的解建構法、有參看類似梯度資訊
的有向性搜尋、有廣泛探索功能的降水機制等優點。本研究目標期能更完善、更完整地研擬及
規劃 WFA 的啟發式演算各層面的演算規範和模式。使 WFA 繼 GA、ACO、PSO 成為新興的
啟發式優化法。本研究首在研擬求解一般連續優化問題(Continuous Optimization Problems)的
WFA 演算模式、規範標準演算作業的 meta 層級演算流程、開發具各種典型優化問題題型的
WFA 演算模式。目的在驗證 WFA 全方位的啟發式求解功能。研究對象涵蓋單目標和多目標
連續型優化問題、零工批量生產排程問題 (Job-shop Scheduling Problem)、車輛途程問題(Vehicle 
Routing Problem) 等，具特定限制條件的標竿問題的 WFA 求解模式和軟體系統。 
 
圖 0-1 仿水流優化的主要演算流程 
貳、 研究的目的 
4 
 
圖 1-2 分流移動作業下視目標函數值改善與否有不同的子水流流動分布 
1.1 連續型變數之仿水流優化演算法初始參數設定 
求解初始需設定演化代次上限 P、初始單股水流質量 0M 、初始速度 0V、分流之門檻值 、
水流分流上限 n 、動量因子(Momentent Factor) 、水流分流合併相似度 、質量蒸發率 、水
氣飽和度 S 、總水流數上限。演算法開始執行前首先隨機產生第一股水流之水流位置 0X ，  
0 01 02 0 pX X X   X  (1-1) 
   0 ~ 0,1 ,  u l lh h h hX U b b b h      (1-2) 
式中 uhb 和
l
hb 分別是維度 h的位置座標值上限和下限。接著同樣以隨機方式產生第一股水流的母
水流位置， 
   
0 01 02 0
0 ~ 0,1 ,  
p
u l l
h h h h
X X X
X U b b b h
   
    
X
 (1-3) 
。計算初始第一股水流的潛能水準 
   0 0 0H f f X X  (1-4) 
設定水流集合  0  
1.2 分流移步 
分流移步作業分為兩部份：首先決定當下水流集合內各股水流 i 可分出的分流數，再決
定各支流的質量、速度及位置。分流的股數 in ，原則上是以目標函數值變化的程度決定，目標
函數值變化越小會產生的子水流股數就愈多。因此 
   1
exp ln
i if f
Y n
n 
        
 
X X
。 (1-5) 
可分流數是一個分流數設定的參考，本研究設定分流結果得到的質量內定依照 minm , min 1m  ,
min 1im n  份數分配，且質量最小 min 1m  。因此若分成股數 in  
   1 1 1 (1 2) 1 1i iM n          (1-6) 
6 
多股水流位置的相似度衡量是以計算歐式距離，若多股水流位置之間的距離低於使用者所
設定之水流合併之臨界值，則視為鄰近而合併。匯流作業執行時由目前水流集合中由未執行
過匯流的水流 i作為基準水流，其位置向量 iX 和目前的水流集合中位置距離小於 的水流組
成新的匯流集合 iA ，則 
 ,i i iA i i    X X 。 (1-15) 
匯流後的水流 i時更新質量為 
i
i i ii A
M M M

   
   (1-16) 
在質量守恆下水流合併後速度 
i
i i i ii A
i
i
M M
M

   




V V
V
 (1-17) 
在能量不滅的原則下合併後的潛能水準 
i
i i i ii A
i
i
M H M H
H
M

   





 (1-18) 
匯流後的水流位置仍以 iX 為代表。更新目前水流集合 
iA   (1-19) 
1.4 蒸發 
蒸發作業是將目前地表上的每股水流蒸散一定比例的水氣(質量)到大氣中，待大氣中所含
之水氣達到飽和點(saturation point, S)再透過降水回到地表。水流 i 蒸發後的質量變化為 
 1i i i iM M M M      (1-20) 
式中 是水氣的蒸發率。蒸發後將蒸散的水氣加到大氣的水氣含量中 
i i
M 

   ， (1-21) 
 是大氣中的水氣含量。 
水氣蒸發扣減質量時，若剩餘質量小於 則判定該水流不足以繼續流動，將水流由目前集
合中刪除，並將剩餘質量蒸散於大氣之中 
 1.0ii M    (1-22) 
1.0i
ii M
M 
  
    (1-23) 
1.5 降水 
降水作業的目的是將大氣中的水氣再降於地面，開發新的搜尋區域以跳脫區域最佳解。降
水的情形分為自然降水和強制降水兩種。若大氣中的水氣含量相對於原始水流質量 0M 的比例
超過飽和點 S 即執行自然降水作業，意即 0S M   。降水後的水流總數頇在總水流數量上限
之內，因此降水的水流數 
8 
唯為顧及實驗執行之效率，區域搜尋的次數不宜太多，因此在本研究中限定每次執行區域搜尋
程序只會執行鄰近 10 個位置的搜尋，每一次搜尋的移動幅度為 0.005。 
 
圖 1-3 目標函數曲面具多個局部最佳解的二維標竿問題示意 
10 
Name Mass Velocity Velocity Point Merging of Split Threshold Factor 
Himmelblau 100 5 0.2 30 0.04 5 3 0.7 
Rastrigin 65 30 0.07 15 0.3 5 5 1 
Six Hump 
Camel 
65 25 0.12 20 0.3 5 3 0.4 
Schaffer 
Function #1 
65 35 0.12 15 0.2 3 3 0.4 
Stenger 65 30 0.1 15 0.1 5 5 0.7 
Spiky 100 20 0.05 45 0.05 2 2 0.3 
Bohachevsky 
Function #2 
50 3 0.3 30 0.1 10 5 0.1 
Davis 100 5 0.05 20 0.04 3 5 1 
Sine Envelope 50 30 0.1 15 0.2 5 5 1 
Levy function 50 30 0.12 20 0.2 5 5 0.8 
表 1-2  WFACOS系統執行實例測試之結果 
Function Name      ( ) SD       ( ) KnowOptimum 
Bohachevsky Function #2 2.88090072 2.06607810 0.27902228 0.00000000 
Davis 1.59613630 0.34196338 1.02692118 0.00000000 
Himmelblau 0.04100303 0.04153215 0.00327249 0.00000000 
Levy function -9.26079607 1.12894749 -10.99983316 -11.50440300 
Rastrigin -1.47768642 0.34120683 -1.87294618 -2.00000000 
Six Hump Camel -0.99297595 0.01857015 -1.02168385 -1.03160000 
Schaffer Function #1 0.07110583 0.03845879 0.01729543 0.00000000 
Stenger 0.01083505 0.01008665 0.00008898 0.00000000 
Spiky -37.86841072 0.28710879 -38.22481097 -38.85000000 
Sine Envelope 0.00976617 0.00007086 0.00971637 0.00000000 
 
表 1-3  WFACOS系統執行區域搜尋結果比較表 
 Only for Best flow For all Flow  
Function 
Name 
     ( ) SD       ( )      ( ) SD       ( ) 
KnowOptimu
m 
Bohachevs
ky Function 
#2 
0.10919 0.1091 0.00000 0.08740 0.106917 0.00001 0.00000 
Davis 0.15532 0.0790 0.06573 0.59463 0.95836 0.0601 0.00000 
Levy 
function 
-10.8957 0.3746 -11.304 -10.727 0.58234 -11.391 -11.50440 
3. 結果與討論 
從上述之實例測詴結果可歸納下列結論： 
12 
Modeling, Vol. 18, pp. 29–57. 
23.  Kan, A. H. G. R. and Timmer, G. T., 1987, “Stochastic global optimization methods, Part I: Clustering 
methods,” Mathematical Programming, Vol. 39, pp. 27–78. 
24.  Kennedy J. and Eberhart R., 1995, “Particle swarm optimization,” Proceedings of the 1995 IEEE 
International Conference on Neural NETworks, IEEE Press, pp. 1942–1948. 
25.  Kennedy, J., and Eberhart R., 1997, “A discrete binary version of the particle swarm optimization,” 
Purdue School of Engineering and Technology Indianapolis.  
26.  Liping Zhang, Huanjun Yu, and Shangxu Hu, 2003, “A new aproach to improve particle swarm,” 
College of Material and Chemical Engineering, Zhejiang University.  
27. Michalewicz, Z., 1994, “Genetic Aagorithms + Data Structures = Evolution Programs,” Springer, Berlin. 
28. Moustakas, C., 1990, “Heuristic research: design, methodology, and applications,” ADDISON WESLEY. 
29. Parsopoulos, K. E. and Vrahatis, M. N., 2004, “On the computation of all global minimizers through 
particle swarm optimization,” IEEE Transactions on Evolutionary Computation, Vol. 8, no.3, pp.211–
224. 
30. Parsopoulos, K. E. and Vrahatis, M. N.,2002, “Initializing the particle swarm optimizer using the 
nonlinear simplex Method,” Advances in Intelligent Systems, Fuzzy Systems, Evolutionary Computation, 
pp. 216–221. 
31.  Pearl, J., 1984, “Heuristics: intelligent search strategies for computer problem solving,”Addison-Wesley. 
32. Pulido, G. T. and Lechuga, M. S., 2004, “Handling multiple objectives with particle swarm optimization,” 
IEEE Transactions on Ransactions on Evolutionary Computation, Vol.8, no.3, pp. 256–279. 
33.  Shor, Naum Z. (1985). Minimization Methods for Non-differentiable Functions. Springer-Verlag. ISBN 
0-387-12763-1 34. Wang, K. P., Hung, L., and Zhou, C. G., 2003, “Particle swarm optimization for 
traveling salesman problem,” Proceeding of Second International Conference on Machine Learning and 
Cybernetics, pp. 1583–1585. 
35.  Xie, X., Zhang, W., and Yang, Z.. 2002, “Adaptive particle swarm optimization on individual level,” 
Proceedings of the 6th International Conference on Signal Processing,Beijing, China, pp. 1215–1218. 
36.  Yang, F.C. and Yuan-Peng Wang, Y.P. , 2007, “Water Flow-like Algorithm for Object Grouping 
Problems,” Journal of the Chinese Institute of Industrial Engineers, Vol. 24, No. 6, pp. 475-488. 
37.  Yasuda, K., Idl, A. and Iwasaki, N., 2003, “Adaptive particle swarm optimization,” Graduate School and 
Engineering Tokyo Metropolitan University. 
38.  Zhang, W. J. and Xie, X. F., 2003, “DEPSO: Hybrid particle swarm with differential evolution operator,” 
IEEE Int. Conf. on Systems, Man & Cybernetics (SMCC), Washington D C, USA. 
39.  楊烽正、潘嘉琪、張冠群，2008，”求解一般性排序優化問題的仿水流優化演算法”，中國工業工
程學會九十七年度年會暨學術研討會論文集 
  
14 
Water Flow-likeOptimization_Algorithm 
1  ResetAndInitializeParameters () 
2 repeat 
3   FlowSplittingAndMoving() 
4  FlowMerging() 
5  WaterEvaporation() 
6   if IsRainFallRequired() 
7   Precipitation() 
8   FlowMerging() 
9  end if 
10  EvaluateObjectives() 
11  BestSolutionUpdate () 
12 until IsStoppingConditionMet()  
圖 2-1  WFA的 meta演算流程 
ResetAndInitializeParameters()方法在重設仿水流演化過程的統計數據，如水氣質量和代次、
目標函數呼叫、連續無改進等次數。此外也初始化使用者設定的 WFA 演化參數，如：分流上
限、初始質量、初始速度、降水週期、蒸發率、降水水流比例、匯流近似率、最小水流質量等。
若有客製化相關參數定義在繼承的子類別時，除了在更迭方法內設定新增參數外，應呼叫本基
礎方法。此方法最後呼叫 CreateAndInitializeInitialFlow()產生初始水流以便進行解搜尋演化。 
FlowSplittingAndMoving()方法逐一進行各水流的移步和分流運算。過程是呼叫 WaterFlow
物件的 SplitAndMove()方法，進行移步並送回產生的子水流陣列。增生的子水流再逐一添加到
水流儲列內。 
FlowMerging()方法，透過水流旗標陣列的協助，由第一股水流開始遞迴地依序與後續水
流進行匯流條件檢查。檢查時是呼叫 WaterFlow 的 CanMergeAFlow()方法進行兩水流位置鄰近
的檢驗。符合匯流條件的後續水流透過旗標註記，於後續步驟刪除。不同問題型別，會有不同
的匯流作業，此時可完全更迭 FlowMerging()方法。此外通常不同問題各有不同的匯流條件設
計，因此均需更迭 CanMergeAFlow()方法，查驗兩水流是否符合該問題特性規範的合併條件。 
WaterEvaporation()方法依照設定的蒸發比例，逐一求算各股水流的蒸發量。當扣減後的水
流質量小於最小質量時，該水流質量全數蒸發並標註為乾涸水流。所有水流蒸發部分質量後，
刪除乾涸水流。本方法可由使用者更迭成不同的蒸發演算細節。 
虛擬的 IsRainFallRequired()方法使用設定的降水週期，查驗當代次是否頇執行降水作業。
內定是執行週期性降水。使用者可更迭內容進行不同方式的降水條件設定，譬如：當上空的水
氣質量達到初始水流質量的某個比例、或連續幾代次沒有解品質改善時等。 
Precipitation()方法依照設定的降水水流數比例計算水流數同時查驗水氣質量與最小水流
質量的限制，確定最終的降水水流數。然後隨機挑選地面水流複製降水水流同時進行位置擾動。
產生的降水水流再逐一添加到水流儲列。本虛擬方法會呼叫 WaterFlow 物件的 CloneAFlow()
和 PerturbPrecipitaionFlow()方法，分別進行水流複製和位置擾動。同樣地，本方法可由使用者
更迭內容，進行不同形式的降水作業。 
EvaluateObjectives()方法逐一呼叫各水流的 EvaluateObjectives()方法。一般而言，使用者
無需更迭本方法，惟必頇更迭實作 WaterFlow 的虛擬 EvaluateObjectives()方法。如前所述，該
16 
水流進行匯流演算時，需判斷兩水流的位置近似程度。虛擬方法 CanMergeAFlow()頇由子
類別更迭實作特定的鄰近程度檢驗程序。譬如：連續優化問題可設定各個座標值間的差異在設
定的鄰近距離時，視為可合併。 
進行降水作業時，由被選定的地面水流執行 PerturbPrecipitaionFlow()方法，對產生的降水
水流進行位置設定。一般而言，先複製地面水流的位置給降水水流，再進行部分擾動。 
CloneAFlow()方法和 CopyValuesToAFlow()方法支援水流的複製，以支援分流和降水作業。
細節內容牽涉使用者自訂的資料結構，頇由子類別更迭實作。另外 CreateACustomWaterFlow()
方法需由繼承的子類別實作各子類別物件的產生方法。 
EvaluateObjectives()方法進行水流位置資料的解碼，建構出優化問題的解。再以此解計算目標函數
值，完成解品質評估。內容與問題型態和資料結構相關，需由子類別更迭實作特定的目標函數值評估
法。 
使用柔性求解技術的啟發式優化演算法需進行各項參數的數值設定和求解詴驗，求解系統
需要高度互動的人機介面。WFAMainForm 物件功能在提供 WFA 演算物件參數設定、演化最
佳解展示、演化進展展示、和水流物件解碼後的問題解展示等。WFAMainForm 物件係繼承
自.NET Framework 內的 System.Windows.Forms.Form 物件。使用者得繼承此物件實作自設的人
機介面物件。同時，可以添加專屬的資料控制項(controls)以支援額外資料的設定和展示。譬如：
求解 TSP 問題時，可以添加 Panel 物件，以展現求得的最佳路徑和已知的全域最佳路徑。內定
的 WFAMainForm 物件提供的視窗介面如圖 2-2 所示。 
 
圖 2-2  WFAMailForm內定的視窗介面 
該人機介面物件內預設有四個展示求解歷程的線圖物件，分別展示迄今最佳目標函數值、
代次最佳目標值、代次目標值平均、和水流數目。本物件使用 third-party Steema 公司出品的
TeeChart 圖形物件。使用者可以任意產生各種 2D 和 3D 的圖形以支援問題解的展示。譬如：
18 
本年度已順利完成仿水流優化演算法的 meta 標準演算流程規範和標準演算程序的實作。
此外，也依循流程的規範以及設計典樣的引導，以 C#程式語言開發 meta 層級的 WFA 求解系
統開發軟體礎架 WFABOF。後續工作是應用該礎架，進行 JSP、VRP、及 VCP 三種 OR 標竿
問題的 WFA 求解模式開發。同時會將 OR LIB 內相關的標竿優化問題納入範例庫內，測詴及
驗證所提模式的可行性和效能。測詴具代表性的標竿問題，分析結果評估求解成效，並與文獻
已發表的求解結果比較，分析所提模式的求解成效。這些模式開發的目的在驗證所提 WFA 
Meta 標準演算流程的適用性和強韌性，使 WFA 能被認可為一個能求解連續和離散優化問題的
新興萬用啟發式演算法(meta heuristic)。 
 
圖 2-3  WFABOF的meta層級架構由三個類別組成。 
欄位
屬性
方法
欄位
屬性
方法
事件
欄位
方法
20 
College of Material and Chemical Engineering, Zhejiang University.  
14. Moustakas, C., 1990, “Heuristic research: design, methodology, and applications,” ADDISON 
WESLEY. 
15.  Parsopoulos, K. E. and Vrahatis, M. N.,2002, “Initializing the particle swarm optimizer using the 
nonlinear simplex Method,” Advances in Intelligent Systems, Fuzzy Systems, Evolutionary Computation, 
pp. 216–221. 
16. Pulido, G. T. and Lechuga, M. S., 2004, “Handling multiple objectives with particle swarm optimization,” 
IEEE Transactions on Ransactions on Evolutionary Computation, Vol.8, no.3, pp. 256–279. 
17. Wang, K. P., Hung, L., and Zhou, C. G., 2003, “Particle swarm optimization for traveling salesman 
problem,” Proceeding of Second International Conference on Machine Learning and Cybernetics, pp. 
1583–1585. 
18. Yang, F.C. and Yuan-Peng Wang, Y.P. , 2007, “Water Flow-like Algorithm for Object Grouping 
Problems,” Journal of the Chinese Institute of Industrial Engineers, Vol. 24, No. 6, pp. 475-488. 
19. Zhang, W. J. and Xie, X. F., 2003, “DEPSO: Hybrid particle swarm with differential evolution operator,” 
IEEE Int. Conf. on Systems, Man & Cybernetics (SMCC), Washington D C, USA. 
20 楊烽正、潘嘉琪、張冠群，2008，”求解一般性排序優化問題的仿水流優化演算法”，中國工業工
程學會九十七年度年會暨學術研討會論文集 
  
22 
 
 
圖 3-1 節省值概念示意圖 
另外，本車輛途程問題解空間龐大而仿水流演算法初始時僅以單一水流進行解搜尋，若初
始解採用隨機給定，會因初始解的品質不佳影響水流演化結果。因此研擬一有效的初始解產生
法，在演化初始時，以一品質良好的初始解進行演化。 
2.1 車輛途程問題解的編碼 
本研究修改 SR-1(Solution Representation-1)解編碼法，提出「實數型顧客偏好編碼(Real 
Number Customer Priority Code，RNCP)」和「排序型顧客偏好編碼」(Permutation Customer 
Priority Code，PCP)的車輛途程問題編碼格式。編碼均分為兩個部分：選車順位顧客序列和車
輛參考座標位置，並由此二者轉換得到顧客對車輛偏好矩陣。解碼時由選車順位顧客序列和車
輛偏好矩陣依序將顧客加入車輛途程。所有顧客逐一挑選完車輛並選擇適當位置插入途程後，
完成解碼程序。 
實數型顧客序列編碼法(RNCP) 
RNCP 法將n個顧客和m 台車輛的車輛途程問題解，以  mn 2 維度(dimension)的實數表
示，  mnzzzZ 221   ， Raz ， mna 2,,1   。 
 
圖 3-2 RNCP 及其解碼程序 
24 
 
Input: 
: 水流位置
 
Intermediate: 
: 選車順位顧客序列 
: 顧客對車輛的偏好順位矩陣 
Output: 
: 車輛途程
 
DECODING ( ) 
1. 產生選車順位顧客序列  
2. 設定車輛參考座標  
3. 計算顧客和車輛參考座標間的距離  
4. 產生顧客對車輛偏好順位矩陣  
5. for  to  do 
6.   for  to  do 
7.      
8.     if  then 
9.       if  then 
10.          
11.         break 
12.       else 
13.          
14.         break 
15.       end if 
16.     else 
17.       if  then 
18.          
19.          
20.       end if 
21.     end if 
22.   end for 
23. end for 
24. if  then 
25.    
26.   DECODING 
27. else 
28.   LOCAL_SEARCH 
29. end if 
30. Return  
26 
mQ時，解碼過程容易產生不合理解。此時若改讓需求量較大的顧客有較優先選車順位，可以
降低不合理解產生。 
RNCP 編碼的顧客選車順位序列以介於 0 到 1 的實數表示， i 代表顧客 i 的排序值，數值
愈小排序愈前。令最大顧客需求量 i
i
qq max ，顧客 i 選車順位值設為 
ni
q
qq i
i ,,1, 




 
 。 (3-3) 
式中讓較大需求量的顧客 i 會有較小的 i ，即有較優先的選車順位；分子利用最大顧客需求量
q 和顧客 i 的需求量 iq 之間的差：若顧客間的需求量差異愈大，在編碼空間的距離上相隔愈遠。
i 和 i 是車輛參考座標，分別代表平面空間點的 x和 y 座標值。前述的掃描演算法和兩階段法
都先將顧客依車輛分群，再將各車負責的顧客途程最佳化。這兩種方法僅能達成類最佳的分群
結果，且容易陷入區域最佳解，難以脫離。在車輛參考座標設定上，雖沿用掃描演算法進行初
始分群，但不完全採用其分群結果；僅用於計算群中心座標以設為車輛的參考座標。該法的分
群作法能有效將車輛的繞行途徑隔開，而此為最佳解的必要條件。將中央倉庫設為二維極座標
原點，令 ir 為顧客 i 的極座標半徑； i 為顧客 i 的極座標角度。極座標的零度角設為座標系 x 軸
正向。首先將顧客已知的卡氏平面座標  ii yx , 轉換成極座標  iir , ， ni ,,1 ，  20  i 。
因此 
   
 





00
2
0
2
0
,arctan xxyy
yyxxr
iii
iii

， ni ,,1  (3-4) 
式中運算式  xyc  ,arctan 為二維的 tangent 反函數運算，  
x
y
c


tan 。再依 i 由小到大將相
對應的顧客排序，得到一序列  niiiI  21 ，  nia ,,1 ，且 niii    21 。 
I 序列內的顧客系依照極座標角度由小到大排序，意即兩鄰接顧客相對於中央倉庫是角度
緊鄰的鄰居。顧客若依此序列順序分群，群內顧客的鄰接性得以保留。分群方式是任選一顧客
ai為車輛 1 的起始顧客，然後依序納入下一個顧客並確保總需求量不超過Q，完成車輛 1 的顧
客群指派。接著下一個顧客指定為車輛 2的第一個顧客，依序納入顧客進行車輛 2的顧客分群。
當依序執行到顧客 ni時回到第一個顧客 1i，再接續直到顧客 1ai 。當車輛 1m 的顧客群設定完
後，剩餘尚未挑選的顧客全部納為車輛m 的顧客。 
在標準的掃描演算法步驟中，每當一台車輛的顧客群指派完後，便對該車輛內的顧客群求
解 TSP 以規劃途程。而車輛m 將所有未挑選的顧客納入可能違反車輛容量限制Q，此時掃描
演算法將車輛m 的某一顧客移至別台車輛。可能滿足了車輛m 的容量限制，卻造成車輛 mk 
的容量限制無法被滿足，因此有繁複的遞迴運算來修補不可行解。但本研究僅要設定車輛參考
座標，在車輛繞行顧客途程規劃交由搭配顧客選車順位序列的解碼過程處理，故車輛m 若違反
容量限制Q亦不影響車輛參考座標的設定。 
當所有顧客依車輛別分成m 群後，求算各群群內顧客的位置座標中心並設為該車的參考座
標。假設陣列  mEE ,,1 E 是車輛負責的顧客索引集合陣列， kE 是車輛 k 負責的顧客索引集
28 
2  49,49  30  57.0,64.16  
3  64,52  16  95.0,41.29  
4  62,31  23  75.1,36.22  
5  33,52  11  89.5,38.18  
6  41,42  31  14.0,07.7  
以表 3-1 的車輛途程問題為例，依極座標角度 i 由小到大排序得到顧客排序陣列
   541326654321  iiiiiiI 。接著選定欲作為極座標平面上逆時針掃描起點的顧客。假設
選 4j ，即顧客 14 i 為車 1 的起始顧客，依序納入顧客 4 和顧客 5，此時車輛 1 負責的需求
量總合為 53112319
6
4

j
i j
q 。若再加進顧客 6 的需求量 31，車輛 1 所負責的需求量總合
成為 843153  將超過車輛的容量限制 70，因此車輛 1 所負責的顧客索引集合
   5,4,1,, 6541  iiiE 。接著因車輛 2 已是最後一台車，依序挑選顧客 6、顧客 2、和顧客 3 加
入車輛 2 負責的顧客索引集合    3,2,6,, 3211  iiiE 。最後得到車輛 1 和車輛 2 的參考座標分
別為 
   49,40
3
,
3
, 54154111 




 

yyyxxx
 和
  










 

3
154
,
3
143
3
,
3
, 32632622
yyyxxx
 。 
PCP 編碼法之初始水流位置 
在PCP編碼法部分，同樣要讓需求量較大的顧客有較優先選車順位以防止不合理解產生，
因此顧客選車順位序列逕以需求量由大到小設定之。意即依照顧客的需求量 iq 由大到小排序後，
將顧客索引依序設為 n ,,, 21  。因此 1,,2,1,1   niqq ii  。上例採用 PCP 編碼時，因為
531426 qqqqqq  ，所以 61  ， 22  ， 43  ， 14  ， 35  ，和 56   
PCP 編碼法的車輛參考座標設定上和 RNCP 編碼法完全相同。先依式(3-4)將所有顧客的
卡氏平面座標轉成以中央倉庫為原點的極座標表示。選定車輛 1 的起始顧客索引 a後，透過演
算程序 SET_VEHICLE_REFERENCE_LOCATIONS  a 設定車輛參考座標。設定完選車順位顧
客序列和車輛參考座標後，執行解碼程序得初始車輛途程問題解。本初始解產生法在設定顧客
選車順序時優先排定需求量較大的顧客避免不合理解產生，減少修補，提升解碼效率。此外在
車輛參考座標的設定上，利用掃描演算法在分群上的優勢，解碼過程再參考節省值插入顧客有
利途程的排序。介紹完初始水流位置的產生法後，接下來詳細說明仿水流演化的初始參數設定，
和分流移步、匯流、蒸發、和降水這四個仿水流演化的主要作業。 
2.3 初始參數設定 
求解初始需設定演化代次上限 t 、初始單股水流質量 0M 、初始速度 0V 、不分流門檻值 、
分流數上限 、變數 az 的上限值 az 和下限值 az 、水流合併相似度 、質量蒸發率 、水氣飽
和度 S ，以及初始水流位置產生法產生的第一股初始水流位置 0Z 及以亂數產生其母水流位置
30 
到愈多的質量  ghM ，且因動量均等而分配到愈小的速度
 g
hV 。此外計算子水流 g 相對於其母水
流 h的潛能水準       ghhgh ZfZfP  且子水流會記錄其母水流 h 的位置 hZ 。當代次 t 的所有水
流 h都完成分流移步後，水流集合由所有子水流取代。 
RNCP 編碼之分流移步作業 
水流 h的分流股數 h 由水流 h 的潛能水準    hhh ZfZfP 
~
、分流數上限 和不分流門檻
值 決定。此外還受限於依水流 h 的質量 hM 訂定的動態分流數上限。目的在避免當水流 h 的
質量 hM 較小時，分流後子水流質量太小結果會未經演化即完全蒸發至大氣中。 
水流 h的分流股數 h 和潛能水準 hP 有關。原則上 hP 愈高分流數應愈小，此外 h 也受限於
使用者設定的分流數上限 及不分流門檻值 。不分流門檻值 愈高愈容易分流。在此原則
下定義一個分流數縮減值  ， 
















hP1
lnexp 是設定分流股數 h 時所參考的變數。與
分流數有關的  值隨 hP 值愈大而愈小，意味改善量大時儘量少分流。圖 3-4 顯示分流數上限
5 時，不分流門檻值 3 、 5 、和 10 時的  值與潛能水準 hP 的關聯曲線。 
 
圖 3-4 分流數上限 5 時，不同的不分流門檻值和潛能水準 hP 和 值的關聯曲線圖 
另一方面水流 h的分流數 h 也與它的質量 hM 有關，原則上質量大者分流數會較多。連續
優化問題之仿水流演算法[6]是以  14  hhhM  訂定水流 h 的質量 hM 和分流數 h 的關係，
即 
11165.00  hh M 。 (3-6) 
因分流數 h 為自然數，修改式(3-6)為  11165.00  hh M 。令 11165.0  hM ，
圖 3-5 展示水流 h的質量和變數 的關係。 
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
0.10.5 1 1.5 2 2.5 3 3.5 4 4.5 5 5.5 6 6.5 7 7.5 8 8.5 9 9.5 10
  
  
      
α=3 
α=5 
α=10 
 
32 
和分流數 h 之間的關係折線圖 
RNCP 編碼中，子水流位置變數  gahz , ， mna 2,,1   均為實數。水流 h 分出的子水流 g 的
移位向量是         g mnhghghgh 2,2,1,    。移動量視其水流 h 的母水流位置和求解迄今最佳水流相
對水流 h的位置而定，可能正向也可能負向。設  mnoptoptopt zzZ 2,1,   是演算迄今有最佳目標
函數值的水流位置。若水流 h 的潛能水準 0hP ，代表水流 h 的目標函數值  hZf 較其母水流
的目標函數值  hZf
~
佳，指派水流 h 的子水流位置時承襲水流 h 的原移動方向。相反地，若
0hP ，則往反方向移動。此外，也讓子水流參考迄今最佳水流 optZ 方向移動。子水流移位向
量如圖 3-7 所示。 
 
圖 3-7分流移位方向示意圖 
為清楚說明移位向量設定，表 3-2 是水流 h 的潛能水準 hP 、變數 ahz , 、 ahz ,
~ 、和 aoptz , 之間
的關係真值表。當 0hP 、 ahah zz ,,
~ 、且 aoptah zz ,,  時，指派水流h 的子水流位置時承襲水流 h
的原移動方向，即往正向移動；此外參考迄今最佳水流 optZ 方向移動，同往正向移動。當 0hP 、
ahah zz ,,
~ 、且 aoptah zz ,,  時，因潛能水準是負的，往移動方向的反方向移動，又 ahah zz ,,
~ ，因
此指派水流 h的子水流位置時亦往正向移動；並參考迄今最佳水流 optZ 方向移動，同往正向移
動。此為表 3-2 中類型(i)的移動方式。依此類推，當承襲水流 h 的移動方向和朝迄今最佳水流
optZ 的移動方向是一正一負時，即表 3-2 中的類型(ii)。當兩移動方向均往負向移動時，是表 3-2
中的類型(iii)。 
表 3-2 水流 h潛能水準 hP 、變數
ahz ,
、
ahz ,
~
和
aoptz ,
間的關係真值表 
判斷式 真值 
0hP  
T F T F T F T F 
ahah zz ,,
~
 
T F T F F T F T 
aoptah zz ,,   
F F T T F F T T 
 
34 
 
 
 g
h
g
hg
h
M
V

 ， (3-12) 
其中動量
 
h
hg
h


  由水流 h的動量 hhh VM 依分流股數 h 平均分配。 
PCP 編碼之分流移步作業 
在 PCP 產生子水流位置的程序中，水流位置第 mnn 2~1  維仍為實數，故產生方法同
RNCP 編碼的分流移步作業：先由式(3-7)決定水流 h的分流股數 h ，經式(3-8)和(3-9)設定子水
流位置  ghZ ，再透過式(3-10)和(3-11)設定子水流
 g
hM 質量和速度。前 n維是自然數編碼。 
PCP 的分流是以母水流的顧客順序為基局部交換一些顧客的順序。分流時先複製水流 h 的
顧客序列，隨機選定一順位  1,,1*  nj  ，將順位 *j 的顧客和順位 1* j 的顧客交換。例如
水流 h的前 n維是    75324617,1, hh zz  ，先隨機選定一順位  6,,1* j ，假設順位 3* j ，
顧客是 43, hz ，則與順位 41
* j 的顧客 24, hz 互換位置，交換後得一子水流的顧客序列為
   7534261~~ 7,1, hh zz  。 
當顧客數量大時此鄰近交換次數頇提高讓子水流有明顯的移步。因此設定任一子水流分流
移步的顧客序列時頇隨機重覆交換程序











 
1,
2
2
max
h
mn

次。當水流 h 的分流數少時，其目標
函數值改善量大，交換較少次數以進行鄰近解的探究(exploitation)搜尋。反之，分流數 h 愈多，
頇較多次的鄰近交換程序，進行較廣的探索(exploration)搜尋。 
2.4 匯流 
演化過程中，若多股水流位置太過接近，結果僅代表一個車輛途程解。透過匯流作業，將
位置相近的多股水流合併成單股水流避免重覆搜尋。然採用的編碼在實數空間或自然數空間移
動，水流位置編碼值接近不能確保其車輛途程問題解相近，因此除了以編碼為基的匯流法
(Code-Based Merging, CBM)以外，另提出以解為基的匯流法(Solution-Based Merging, SBM)。
SBM 法判定兩水流位置代表相同的車輛途程問題解時才進行合併；CBM 法則以相似度判定兩
水流位置接近時，即進行合併。 
RNCP 編碼法的 SBM 匯流作業 
設水流 h的位置 hZ 解碼後代表的車輛途程問題解是  mhhh RR ,1, R ， khR , 是水流 h 代表
的車輛途程問題解中車輛 k 繞行的顧客序列。 khR , 是車輛 k 繞行的顧客數量。  nI ,,1 是顧
客集合。令
khRkhkhkh
rrR
,,,1,,,
 ； Ir jkh ,, ； khRj ,,,1 。匯流作業執行時由目前水流集合
依序挑選水流逐一比對水流 h 及其後序各水流 h的車輛途程問題解 hR 和 hR 。先比較目標函數
值，若目標函數值不同則判定兩車輛途程問題解不同。若目標函數值相同，再進一步比對各車
途程順序。設  hArc 是水流 h的位置 hZ 代表的車輛途程問題解 hR 中所有顧客間的鏈結集合，
       1,,1;,,1,max,,minArc ,1,,,,1,,,,   khjkhjkhjkhjkh Rjmkrrrrh  。當對 hR 中的任一台車
輛 k 的途程 khR , ，都可以找到 khR , 使得 khkh RR ,,  ，且    hh  ArcArc 時，便可判定兩車輛途
36 
若 hh , 小於使用者設定的合併臨界值，則水流 h 和h視為相似水流可以進行匯流。執行
時由目前水流集合依序挑選水流 h，並逐一檢查後序各水流 h與 h 間的相似度 hh , 。後序各水
流 h的  hh, 者，組成水流 h 的匯流集合 
 thhhh NhhhH ,,1,,,   A ， tNh ,,1 ， (3-18) 
被合併的水流 h其匯流集合為空集合， hA 。匯流時在動量平衡下依式(3-14)更新水
流 h的速度 hV 。匯合的水流新位置 hZ 依式(3-15)設定。更新速度和位置變數後，水流 h 的質量
hM 由匯聚集合 hA 內水流的質量依式(3-16)更新。最後更新水流集合   hhH AH 。 
PCP 編碼法的 SBM 匯流作業 
和 RNCP 編碼法的 SBM 匯流作業相同，比對水流 h 和 h代表的車輛途程問題解 hR 和 hR ，
若完全相同則進行合併。唯更新水流位置在前 n維為自然數編碼，若以加權平均更新位置時會
出現小數，此時保留水流 h的前 n個自然數位置，第 1n 至 mn 2 個實數位置仍以加權平均更
新。 
執行時先依式(3-13)組成水流 h 的匯流集合 hA 。在動量平衡下依式(3-14)更新水流的速度
hV 。匯合的水流新位置前 n個自然數位置以原水流 h 位置設定，第 1n 至 mn 2 個實數位置由
hA 內水流位置和原水流 h位置以質量大小為權重設定。各位置變數更新為 


















mnna
MM
zMzM
naz
z
h
h
h
hh
h
ahhahh
ah
ah
2,,1,
,,1,
,,
,
, 

A
A 。 (3-19) 
更新速度和位置變數後，水流 h 的質量 hM 由匯聚集合 hA 內水流的質量依式(3-16)更新。
最後更新水流集合   hhH AH 。 
PCP 編碼法的 CBM 匯流作業 
判斷水流 h和 h間的相似度作法和 RNCP 編碼法的 CBM 匯流作業相同，更新水流位置和
PCP 編碼法的 SBM 相同。執行時先依式(3-17)計算相似度 hh , 再依式(3-18)找出水流 h 的匯流
集合 hA 。在動量平衡下依式(3-14)更新水流 h的速度 hV 。匯合的水流新位置前 n個自然數位置
以原水流 h位置給定，第 mnn 2~1  個實數位置由 hA 內水流位置和原水流 h 位置以質量大小
為權重設定。各位置變數依式(3-19)更新。更新速度和位置變數後，水流 h 的質量 hM 由匯聚集
合 hA 內水流的質量依式(3-16)更新。最後更新水流集合   hhH AH 。 
2.5 蒸發作業 
蒸發作業是將目前地表上的每股水流蒸散一定比例的水氣到大氣中，待水氣達到飽和度後
再透過降水回到地表。蒸發僅調動水流質量，所以 RNCP 編碼法和 PCP 編碼法的蒸發作業完
全相同。水流h在每代次中蒸發的質量為 hM ，更新水流質量 hM 為 hhh MMM  ，並將所
有水流被蒸發的水氣加到大氣的水氣含量  airM 中，
    
h
h
airair MMM  。若某水流h 執行
38 
0VVh  。降水水流 h的位置向量 hZ 是複製原地表上的水流集合H中相對應水流 h 的位置向量
hZ ，保存其車輛參考座標，並倒轉其選車順位顧客序列，得 


 


otherwise,
if,
,
1,
,
ah
anh
ah
z
naz
z ， mna 2,,1   。 
降水後，添加新增的降水水流到目前的水流集合H， HHH  ，並重設大氣中水氣含量
 airM 為 0，完成降水作業。 
本研究將使用者可設定的水氣飽和度 S 範圍訂在  9.0,5.0 間。強制蒸發的設計，使演化過
程中所有水流的質量不會低於 1。若水氣飽和度 5.0S ，可能導致所有降水水流的質量均小於
1。舉例來說，令初始水流質量 100 M ，水氣飽和度 4.0S 。若代次 t 有 5 條質量均為 1.1 的
水流，此時大氣中的水氣含量
 
S
M
M air

10
5.4
0
，將執行降水作業。將降下 5tN 條降水水流，
平均分配大氣中的水氣含量  airM 給 5 條降水水流，將導致所有降水水流的質量為 0.9，並在
下一個代次全數被強制蒸發，無法進行搜尋。此外，若水氣飽和度設定過高，大部分的質量屯
積在大氣中僅留下少數水流在空間中搜尋，效率不佳。 
2.7 小結 
求解車輛途程問題之仿水流演算法以求解連續優化問題的仿水流演算法[6]為基，依照水
流的潛能水準和不分流門檻值設定分流數。當水流的潛能水準大時，以一股水流延續移動方向，
並參照迄今最佳水流位置向其移動；當水流目標函數值變動幅度較小時，分出多股水流進度探
索(exploration)。在編碼方面，引用並改自 SR-1 編碼[14]，提出 RNCP 仿水流編碼和 PCP 仿水
流編碼。PCP 編碼使用排序形式處理編碼中顧客選車順位序列的部分，較能符合其編碼的設計
概念，且能以分流數多寡定義其搜尋的鄰域範圍，分流時符合仿水流演算法動態調整分流移步
範圍的特性。本研究設計之初始解產生法，搭配了掃描演算法在分群上的優勢和節省值在排序
上的長處，能產生良好的初始水流位置作為仿水流演化的基礎。在以上框架下設計仿水流演化
細節，使分流移步、匯流、蒸發、和降水四個仿水流主要演化機制的功效均能完整發揮。 
3. 仿水流演算法求解系統 
為驗證所提演算法的效能，以 THE VRP WEB 中的標竿問題為測詴範例，測詴本研究提
出的初始解產生法的求解結果，和仿水流演算法的求解結果，並與粒子群演算法比較。 
3.1 仿水流演算法求解系統 
依據所提的仿水流演算流程，本研究使用 Microsoft Visual Studio 2010 開發工具，在
Microsoft .NET Framework 平台下，以 C#程式語言開發一套車輛途程問題求解系統名為
WFAOS4VRP(Water Flow-like Algorithm Optimization System for Vehicle Routing Problem)。 
圖 3-9 是求解系統介面，分三大區塊。區塊 A 有三個頁面。圖中顯示問題資訊頁面，包含
問題名稱、顧客數量、車輛容量、車輛數量、和顧客位置及需求量等。另有參數設定頁面和圖
表頁面圖 3-10 所示。參數設定包含初始水流質量、初始水流速度、質量蒸發率、分流數上限、
不分流門檻值、和水氣飽和率、匯流法的選擇及匯流相似度設定、三種區域搜尋法的啟用與否、
呼叫目標函數次數上限，和執行按鈕及批次執行按鈕。圖表頁面有兩幅折線圖。上圖的橫軸是
演化代次，縱軸是目標函數值。圖內有四條線：分別是代次最佳(iteration best)目標函數值、代
40 
 
圖 3-10 WFAOS4VRP求解系統的參數設定頁面和圖表頁面 
4. 範例測詴效能驗證  
4.1 系統驗證分析 
為驗證提出的仿水流演算法，以 WFAOS4VRP 求解 THE VRP WEB 內的標竿問題，分別
測詴初始解產生法的效能、比較 SBM 和 CBM 兩種匯流法、測詴 RNCP 和 PCP 兩種編碼法的
求解結果、和測詴仿水流演算法的求解成效。 
初始解效能分析 
本初始解產生法起始前會先亂數設定顧客索引並可能產生不同的車輛途程解。 
表 3-4 初始解效能和貪婪搜尋法比較 
Problem 
Known best 
obj. value 
Proposed initialization method with 
2-opt 
Greedy search with 2-opt 
Obj. value 
Error percentage 
(%) 
Obj. value 
Error percentage 
(%) 
An33k5 662.11 702.19 6.05 720 8.74 
An45k7 918.13 938.76 2.21 1102 19.98 
An60k9 1355.80 1483.28 9.40 1617 19.27 
Bn35k5 956.29 1029.13 7.62 1062 11.05 
Bn45k5 754.22 863.89 14.54 820 8.72 
42 
(%) (%) (%) (%) 
Vrpnc1 524.61 524.93 0.06 524.93 0.06 524.75 0.03 524.83 0.04 
Vrpnc2 835.26 865.68 3.63 867.03 3.80 869.29 4.07 865.64 3.64 
Vrpnc3 826.14 845.56 2.35 844.14 2.18 845.34 2.32 846.52 2.47 
Vrpnc4 1028.42 1085.86 5.59 1083.14 5.32 1083.77 5.38 1081.47 5.16 
Vrpnc5 1291.45 1414.82 9.55 1416.06 9.65 1420.64 10.00 1414.13 9.50 
Vrpnc11 1042.11 1104.54 5.99 1101.65 5.71 1101.00 5.65 1094.21 5.00 
Vrpnc12 819.56 829.78 1.25 828.68 1.11 828.20 1.05 829.45 1.21 
表 3-5 比較兩種匯流法的求解結果。表中列出各標竿問題的名稱、迄今已知最佳目標函數
值、兩種匯流法求解所得目標函數值和誤差率。圖 3-12 是兩種匯流法求解結果和迄今已知最
佳目標函數值的誤差百分比比較長條圖。由圖中可知，當 CBM 匯流法挑選到適當的合併相似
度 時，平均求解成效較 SBM 匯流法佳，但差距並不顯著。 
 
圖 3-12兩種匯流法的求解結果誤差率比較 
RNCP 編碼和 PCP 編碼比較 
本測詴以 RNCP 編碼和 PCP 編碼測詴 THE VRP WEB 內的標竿問題，比較求解結果。每
個標竿問題求解 10 次，以呼叫目標函數 50,000 次為停止條件，並以平均目標函數值展示求解
結果。演算參數為初始質量 40、初始速度 8、質量蒸發率 0.1、每股水流最大分流數 5、不分
流門檻值 3、和水氣飽和度 0.7，匯流採用 CBM 法，水流合併相似度是 0.05。演算過程啟用
2-opt、1-1 交換、和 1-0 交換等區域搜尋法。表 3-6 展示兩種編碼法的求解結果。表中列出各
標竿問題的名稱、迄今已知最佳目標函數值、兩種編碼法求解所得目標函數值和誤差率。圖
3-13 是兩種編碼法求解結果和迄今已知最佳目標函數值的誤差百分比比較。 
由圖3-13發現兩種編碼模式並無明顯優劣，因為兩種編碼模式搭配的分流方法截然不同：
RNCP 編碼法在分流時延續其流動方向並朝向求解迄今最佳水流位置移動，然而因移步距離的
隨機性，可能導致移動後子水流位置中代表顧客優先順序的部分雖與母水流不同，但卻有相同
的顧客優先順序，使搜尋效率降低；PCP 編碼法在顧客優先順序上採用排序型編碼，並使用數
0.00%
2.00%
4.00%
6.00%
8.00%
10.00%
12.00%
e
r
r
o
r
 p
e
r
c
e
n
ta
g
e 
benchmark problem 
SBM
CBM(合併相似度=0.04) 
CBM(合併相似度=0.05) 
CBM(合併相似度=0.06) 
44 
表 3-7 仿水流演算法和粒子群演算法的求解結果 
Problem 
Known best 
obj. value 
WFA (RNCP) WFA (PCP) PSO (SR-1) 
Obj. 
value 
Error 
percentag
e (%) 
Obj. 
value 
Error 
percentag
e (%) 
Obj. value 
Error 
percentage 
(%) 
vrpnc1 524.61 524.61 0.00 524.61 0.00 524.61 0.00 
vrpnc2 835.26 846.27 1.32 851.00 1.88 849.58 1.71 
vrpnc3 826.14 833.45 0.88 835.03 1.08 835.80 1.17 
vrpnc4 1028.42 1059.92 3.06 1059.49 3.02 1067.57 3.81 
vrpnc5 1291.45 1375.68 6.52 1348.83 4.44 1345.84 4.21 
vrpnc11 1042.11 1054.07 1.15 1053.75 1.12 1051.87 0.94 
vrpnc12 819.56 820.23 0.08 824.78 0.64 820.62 0.13 
由 3-14 圖可發現，在標竿問題 vrpnc1 上，採用 RNCP 編碼及 PCP 編碼的仿水流演算法
和粒子群演算法誤差百分比均為 0，都能找到最佳解。在標竿問題 vrpnc2、vrpnc3、vrpnc4、
和 vrpnc12這四個標竿問題中，本研究提出的仿水流演算法有較佳的表現。而在標竿問題 vrpnc5
和 vrpnc11 上，仿水流演算法求解結果雖較粒子群演算法略差，但也相去不遠。由表 3-8 可知
在標竿問題 An33k5、An45k7、Bn35k5、Bn45k5、Bn68k9、En51k5、和 Fn72k4 中，仿水流演
算法和粒子群演算法都能找到最佳解。在標竿問題 An60k9 和 En30k3 中，仿水流演算法表現
較粒子群演算法略好。在標竿問題 Pn101k5 中，粒子群演算法則有較好的表現。 
 
圖 3-14 仿水流演算法和粒子群演算法求解結果誤差百分比比較 
表 3-8 仿水流演算法和粒子群演算法的求解結果 
Problem 
Known best 
obj. value 
WFA (RNCP) WFA (PCP) PSO (SR-1) 
Obj. 
value 
Error 
percentag
Obj. 
value 
Error 
percentag
Obj. value Error 
percentage 
0.00%
1.00%
2.00%
3.00%
4.00%
5.00%
6.00%
7.00%
vrpnc1 vrpnc2 vrpnc3 vrpnc4 vrpnc5 vrpnc11vrpnc12
er
ro
r 
p
er
c
a
n
ta
g
e
 
benchmark problem 
WFA (RNCP)
WFA (PCP)
PSO (SR-1)
46 
PSO 表現較佳的問題數量 0 3 
5. 結論與建議 
本研究針對車輛途程問題設計解編碼格式 RNCP 和 PCP，提出有良好效能的初始解產生
法。並沿襲求解連續優化問題的仿水流演算法求解架構，建構符合車輛途程問題特性的演算模
式，提出求解車輛途程問題的仿水流演算法。同時開發 WFAOS4VRP 的仿水流演算系統，驗
證所提方法。使用 THE VRP WEB 內的標竿問題為測詴對象，和粒子群演算法求解結果比較
並分析，進行效能評估。本研究提出的初始解產生法與節省演算法[9]、掃描演算法[10]、和樹
狀搜尋法[13]等傳統啟發式演算法比較。本研究提出的初始解產生法求解結果能和各演算法不
相上下。搭配 2-opt 區域搜尋法後，和輔以 2-opt 區域搜尋的貪婪搜尋法[15]比較，在大多數問
題的求解結果均明顯較佳。因車輛途程問題解編碼空間的距離和車輛途程問題解的相似度無直
接相關。經測詴顯示當 CBM 匯流法挑選到適當的合併相似度 時，平均求解成效較 SBM 匯
流法佳，但差距並不顯著。RNCP 法直接承襲求解連續優化問題的仿水流演算法讓水流在實數
空間移動搜尋，PCP 法將編碼中代表顧客選車順位的位置以自然數排序表示。PCP 法較 RNCP
法不易發生重覆搜尋的情形以提升演化效率，但在搜尋上較缺乏方向性，難以確保水流往較佳
的方向移動。兩種編碼模式並無明顯優劣。 
 
6. 參考文獻 
1. Yang, F.-C. and Y.-P. Wang, WATER FLOW-LIKE ALGORITHM FOR OBJECT GROUPING 
PROBLEMS. Journal of the Chinese Institute of Industrial Engineers, 2007. 24(6): p. 475-488. 
2. Wang, Y.-P., Water Flow-like Algorithm for Object Grouping Problems, 2006, Industrial Engineering, 
National Taiwan University. 
3. Pan, C.-C., Water Flow-like Algorithm for Sequencing Problems, 2008, Industrial Engineering, National 
Taiwan University. 
4. Glover, F. and M. Laguna, Tabu search1997, Boston [etc.]: Kluwer Academic Publishers. 
5. Kennedy, J. and R. Eberhart. Particle Swarm Optimization. in Neural Networks. Proceedings., IEEE 
International Conference on. 1995. 
6. Yang, F.-C., Water Flow-like Algorithm for Solving Continuous Optimization Problems, in Chinese 
Institute of Industrial Engineers2011. 
7. Dantzig, G.B. and J.H. Ramser, The Truck Dispatching Problem. Management Science, 1959. 6(1): p. 
80-91. 
8. Fisher, M.L. and R. Jaikumar, A generalized assignment heuristic for vehicle routing. Networks, 1981. 
11(2): p. 109-124. 
9. Clarke, G. and J.W. Wright, Scheduling of Vehicles from a Central Depot to a Number of Delivery Points. 
Operations Research, 1964. 12(4): p. 568-581. 
10. Gillett, B.E. and R.M. Leland, A Heuristic Algorithm for the Vehicle-Dispatch Problem. Operations 
Research, 1974. 22(2): p. 340-349. 
11. Lin, S., Computer Solutions of the Traveling Salesman Problem. The Bell System Technical Journal, 
1965. 
12. Gaskell, T.J., Bases for Vehicle Fleet Scheduling. Operational Research Society, 1967. 18(3): p. 281-295. 
13. Christofides, N. and S. Eilon, An Algorithm for the Vehicle-Dispatching Problem. Operational Research 
Society, 1969. 20(3): p. 309-318. 
14. Ai, T.J. and V. Kachitvichyanukul, Particle swarm optimization and two solution representations for 
solving the capacitated vehicle routing problem. Computers & Industrial Engineering, 2009. 56(1): p. 
380-387. 
15. Shanmugam, G., P. Ganesan, and V. P T, A Hybrid Particle Swarm Optimization with Genetic Operator 
for Vehicle Routing Problem. Journal of Advances in Information Technology; Vol 1, No 4, 2010. 
48 
四、 求解零工式生產排程問題的仿水流優化演算法 
1. 緒論 
零工式生產排程問題(Job-Shop Scheduling Problem; JSP)是一個近年來非常重要的議題，因
為它可以反映出工廠內實際的作業情形。但問題的複雜度隨著科技發展的腳步也日益增加，而
如何在限定的時間之內提出最有效率的排程方法便也逐漸成為一門顯學。產學界都已投入相當
多的研究在 JSP 的議題上，而本研究則是希望透過導入最新的啟發式演算法 WFA，期能比較
和改善現今的求解品質。此外一般常見用於求解零工式生產排程問題的編碼方式是以加工步驟
排序的編碼法，此種編碼法雖然可使解碼的過程不會產生不合理解，但是卻會有重複搜尋的浪
費。本研究希望根據零工式生產排程問題的特性設計新的編碼法，使得求解效率能夠提升。 
WFA 一開始提出時，主要是用於求解物件分群優化的問題，而實驗結果也證實其求解結
果優於其他的啟發式演算法；另外雖然也曾嘗詴利用 WFA 來求解物件排序優化問題，但效果
不彰(楊烽正和王元鵬 2007)。而後繼研究者也曾詴著設計一套適合求解一般物件排序問題的
仿水流優化演算法，但結果仍有待加強(潘嘉琪 2008)。本研究希望承襲過往的經驗，並研擬
專門求解零工式生產排程問題的仿水流優化演算法。本研究所使用的仿水流離散優化演算法是
承襲楊烽正和王元鵬 (2007)共同提出的創新演算法，並欲藉由零工式生產排程問題的前行限
制關係和機器加工步驟排序編碼法開發求解零工式生產排程問題的仿水流優化演算求解法
(Water Flow-like Algorithm for Job-shop Scheduling Problems, 以下簡稱 WFA4JSP)。數值測詴將
使用 OR-Library 中的 JSP 標竿問題。為驗證所提演算法之可行性，本研究也實際開發一套專
門求解零工式生產排程問題的仿水流優化演算求解系統。 
2. 文獻探討 
仿水流演算法 
仿水流演算法(Water Flow-like Algorithm, WFA)是由楊烽正和王元鵬共同提出，主要的概
念是仿效水流在自然界中的物理行為設計其演化作業。仿水流演算法將解空間視為地理空間，
而每股水流即代表一個解的位置，而地理空間中的最低點則視為是解空間中的最佳解。演化初
期由單一解代理人開始進行演化，並可以隨著所設定的條件動態調整解代理人的數量，使得解
的搜尋不至於像單股解代理人的演算法一樣求解速度緩慢或是像固定解代理人數量的演算法
一樣常有沒效率的搜尋。 
水流具有分流移步、匯流、蒸發、和降雨等作業，分流移步即是仿照水流在自然界中的分
流、流動的行為，使得解代理人可以在解空間中進行搜尋的作業；流經同一位置的多股水流也
會匯集成一股水流，透過匯流作業使得多個代表相同解的代理人可以匯集在一起，提高求解的
效率；而蒸發作業則是啟動降雨作業的開關，一旦大氣中的水氣達到飽和點時，便會形成降雨
落到地面上，仿水流演算法藉由降雨作業增廣解代理人的搜尋範圍，也使得演化不至於長期困
在區域搜尋中。 
而仿水流演算法設計之初發現水流的特性使用於連續型問題的求解效能較佳，但是使用於
離散型問題則常落於區域搜尋。探究其原因發現是因為離散型問題的特性不適用仿水流演算法
最初的設計，導致解的演化過於保守，因此本研究希望能承襲仿水流演算法的架構，設計一有
效求解零工式生產排程問題的仿水流演算法。 
50 
JSP 是由m 台功能不同的機器(machine)與 j 件不同的工作(job)所組成的排序問題
(sequencing problems)。假設M 是所有機器的集合，且機器以索引m 表示，則  1,2, ,M m ，
m M 。同樣地，假設 J 是所有工作的集合，且工作以索引 j 表示，則  1,2, ,J j ， Jj 。
每一個工作 j 包含了 p 道加工步驟，分別由m 台機器加工，且 p m ，假設 p 是加工步驟的索
引， 1,2,...,p p ，則 jpo 代表工作 j 的第 p 道加工步驟， jro M ，且令O是所有加工步驟的集
合，則  1,2, , ; 1,2, ,jpO o j j p p   。每一道加工步驟 jpo 都有一個已知的加工時間 jpt ，
且 0jpt  ，而每一道加工步驟 jpo 都需要一台機器 jpw 來進行加工，且 jpw M 。舉例來說，假
設 3j  且 4p m  ，則令陣列 
4 1 2 3
3 2 4 1
3 2 1 4
jp j p
w

 
      
  
w
 
代表每一道加工步驟所需要的機器，且令陣列 
2 3 1 4
5 6 2 4
1 5 2 3
jp j p
t

 
      
  
t
 
代表每一道加工步驟所需要的加工時間。 
JSP 的排程優劣，可以不同的衡量法評估。本研究以最常見的最晚完工時間(makespan)，
或稱作總流程時間，來衡量排程優劣。令 jps 是加工步驟 jpo 的加工起始時間，則
 , 1,2, ,jpS s j J p p    代表一個 JSP 排程，故令最晚完工時間 
 
     max j p j p
j J
f S s t
 
  。 (4-1) 
因此 JSP 的目標便是在每一機器上尋找一個可行的加工順序，使得  f S 最小化。 
JSP 有許多的限制情形，包括：  
F. 一件工作在同一時間只能在一台機器上加工。 
G. 一台機器在同一時間只能加工一個作業。 
H. 加工過程中不允許插位事件發生。 
I. 每一件工作的加工序列及每一道加工步驟的加工時間已知。 
J. 每一個工作恰只經過每一台機器一次。 
K. 每一個工作都可以在任何時間開始加工，故不存在著加工起始時間的限制。 
L. 機器可以在任何時間開始進行加工作業，故沒有暖機前置時間的限制。 
M. 每一個工作必頇等待下一道加工步驟需要的機器閒置時才可開始加工。 
N. 每一種機器都只有一台。 
O. 所有的工作均同等重要，無優先順序之差別。 
52 
 
 
圖 4-2 OSC範例  2 3 2 1 3 1 x 其加工步驟排序及排程結果示意 
為了增加求解效率，本研究提出以機器為基的機器加工步驟排序編碼法
(Machining-Sequence Coding, MSC)。對一個m 台機器和 j 件工作的 JSP，每個工作都有 p 道加
工步驟且分別在m p 台機器上加工，換句話說，每台機器必頇要分別加工每一個工作的其中
一道加工步驟，共 j 道加工步驟，因此本研究提出的 MSC 是以工作索引 j 來代表每一台機器
上的加工步驟。MSC 以陣列  mc m jx x 代表一個 JSP 的解，且 mcx J 。因為每台機器必頇要
分別加工每一個工作的其中一道加工步驟，故對機器m而言， mc mcx x  ， ,c c J  ，而第m 列
的元素便是代表在機器m上加工的加工步驟其工作的索引序列。假設 4m  且 3n  ，則 
 
4 3
2 1 3
3 2 1
2 3 1
2 1 3
mcx 
 
 
  
 
 
 
x  (4-2) 
便是一個 MSC 的範例。在此範例中，第一行的元素 2 1 3 代表在機器 1 上加工的加工步
驟按照順序分別是屬於工作 2、工作 1、及工作 3 的加工步驟。因為 MSC 每一列即代表一台
機器上所有加工步驟的加工順序，不同的順序即有不同的排程結果，因此 MSC 並不會出現像
OSC 重複搜尋的情形。比較使用不同編碼法的求解效率，本研究使用的 MSC 有  !
m
j 個的獨
立的解，而 OSC 則有    !/ !
j
jm m 個。以此範例來舉例，則 MSC 有 1296 個獨立的解且每個解
的排程結果都不同，而 OSC 卻有 34650 個獨立的解但許多的解雖然排序不同但排程結果卻相
同，因此本研究使用 MSC 相較於其他編碼法的求解效率較佳。 
JSP 的階層特性 
階層(level)是 JSP 排程結果的一個特性，本研究藉此特性由母水流的 MSC 衍生出一股合
理的子水流 MSC。JSP 每一個工作 j 都有 p m 道加工步驟，而這些加工步驟彼此之間都存在
著前行限制(precedence constraints)關係，舉例來說， jpo 必頇在 , 1j po  完成加工後才可以進行加
工，本研究以由前行加工步驟指向後繼加工步驟的單向箭頭代表兩個加工步驟之間的前行限制
關係，因此便可得到一個以加工步驟為節點的前行限制關係圖。本研究定義同一工作不同加工
步驟之間的前行限制關係為加工步驟前行限制(operational precedence constraints)，並以實線箭
頭在圖中表示。圖 4-3 即是一個 3j  且 4p m  的 JSP 範例加工步驟前行限制階層關係圖。 
 
機器 1 
  
  
  
  
    
機器 2 
加工
54 
為了在圖 4-3 加工步驟前行限制關係圖中增加代表機器前行限制關係的箭頭，則必頇要知
道每台機上的加工步驟其在工作中的順位。令陣列q代表所有機器上的每個工作的加工步驟其
在工作中的順位，故 
 , 1,2, , ; 1,2, , ; 1,2, ,mj mjm jq m m j j q p     q ， (4-4) 
式中 mjq 代表工作 j 在機器m 上的加工步驟在工作 j 加工步驟中的順位，且 mj m jq q  。 mjq  可
以由 jpw  得到，因為加工步驟 jpo 必頇在機器 jpw 加工，且其加工的順位是 p ，則 ,jpw jq p 。
令 ConstructProcessingOrders()是建構q的程序，則其演算步驟如下。 
 
ConstructProcessingOrders(in w , out q ) 
1 for 1j   to j  
2 for 1p   to p  
3 jpm w  
4 m jq p   
5 end for 
6 end for 
 
範例的 
4 3
2 4 3
3 2 2
4 1 1
1 3 4
mjq 
 
 
      
 
 
q
。 
一旦知道每台機器上所加工的加工步驟其加工順位後，便可以根據加工順位來指派加工步
驟。舉例來說，工作 mcx 是在機器m 上加工且其代表的加工步驟加工順位 , mcm xq q ，則此加工
步驟便是 ,mcx qo 。上述範例在機器 1 上的工作索引序列是 2 1 3 ，則其代表的加工步驟是
 
12 11 132, 1, 3, 24 12 33
    q q qo o o o o o    ，因此便可以在前行限制關係圖中增加由 24o 指向 12o 以及由 12o 指
向 33o 的單向箭頭。而為了區分機器前行限制關係和加工步驟前行限制關係的不同，本研究以
單向虛線箭頭來表示機器上加工步驟間的機器前行限制關係，因此圖 4-3便可更新成如圖 4-4。 
56 
接著繼續加入機器 3 的前行限制關係。機器 3 上的工作索引序列是 2 3 1 ，其所代表的加
工步驟是  
32 33 312, 3, 1, 21 31 14
    q q qo o o o o o    ，因此必頇增加由 21o 指向 31o 以及由 31o 指向 14o 的單向箭
頭。因此圖 4-5 便可更新成如圖 4-6。 
 
圖 4-6加入代表機器 3的前行限制關係單向虛線箭頭結果 
最後加入機器 4 的前行限制關係。機器 4 上的工作索引序列是 2 1 3 ，其所代表的加工步
驟是  
42 41 432, 1, 3, 23 11 34
    q q qo o o o o o    ，因此必頇增加由 23o 指向 11o 以及由 11o 指向 34o 的單向箭頭。
因此圖 4-6 便可更新成如圖 4-7。 
 
圖 4-7加入代表機器 4的前行限制關係單向虛線箭頭結果 
從圖 4-7 可以看出所有增加代表機器前行限制關係的箭頭並沒有產生循環的情形，因此 x是一
個可行解且最後所有加工步驟的階層值 
6 7 8 9
1 4 5 6
2 3 8 9
 
 
 
  
l 。 (4-5) 
        
 
      
 
    
 
1 2 3 4 
Level 
5 6 7 8 9 
        
 
      
 
    
 
1 2 3 4 
Level 
5 6 7 8 9 
58 
7 if PropergateLevelUpdate( j po   , level , j po   ,a ,b ) = false 
8 return false 
9 end if 
10 end for 
11 end for 
12 return true 
 
演算程序中，第 4 行是代表機器m 上兩加工步驟之間的前行加工步驟 j po  ，第 5 行則是代
表後繼加工步驟 j po  ；而第 6 行是表示後繼加工步驟的階層值至少要比前行加工步驟的階層值
多 1；第 7 行是把相關參數放進 PropergateLevelUpdate()做階層值的更新計算。 
當加入代表機器前行限制關係的單向虛線箭頭時，兩加工步驟中的後繼加工步驟的階層值
必頇要大於前行加工步驟，假設前行加工步驟的階層值是 sl ，而後繼加工步驟的階層值是 tl ，
若 t sl l ，則 tl 必頇調整為 1sl  。而當一個後繼加工步驟的階層值更新的時候，也必頇同時更
新其後繼加工步驟的階層值，使其後繼加工步驟的階層值至少比前行加工步驟的階層值多 1。
因此階層值便是由加入的前行限制關係起始加工步驟逐層向後繼加工步驟更新。
CheckValidityAndSetLevels()演算程序第 7 行中的 PropergateLevelUpdate()便是更新一個加工步
驟的階層值和遞迴更新其後繼加工步驟階層值的程序。若解 x是一個合理解，則整個更新程序
會在最後一個節點終止，反之若是一個不合理解，則加入圖中的箭頭便會產生循環，使得演算
程序無限的執行。因此，當要加入代表機器前行限制關係的箭頭時，必頇同時傳入起始加工步
驟到遞迴的更新程序PropergateLevelUpdate()中，藉以判斷是否在更新過程中產生了無窮迴圈，
若是產生迴圈則傳回 false 並結束更新程序，詳細的演算程序如下。 
 
PropergateLevelUpdate( jpo , level , j po   ,a ,b ) 
1 if jpl level   
2 return true 
3 end if 
4 jpl level   
5 if jpa null  
6 if jp j pa o     
7 return false 
8 end if 
9 if PropergateLevelUpdate( jpa , 1level  , j po   ,a ,b ) = false 
10 return false 
11 end if 
12 end if 
13 if jpb null  
14 if jp j pb o     
15 return false 
16 end if 
17 if PropergateLevelUpdate( jpb , 1level  , j po   ,a ,b ) = false 
60 
 
第 1 行是將每台機器的可排程時間 MmT 初始化為 0，而第 2 行則是將每個工作的可排程時
間 JjT 初始化為 0。舉例前述的例子來說明，從式(4-5)已知的 l可以得知加工步驟 21o 的階層值是
1 表示是最早開始被排入排程的加工步驟，因此 21 0s  。而因為 21 3w  且 21 5t  ，故工作 2 的
可排程時間 2 21 21 0 5 5
JT s t     且機器 3 的可排程時間 3 5
MT  。接著排入階層值是 2 的加
工步驟，即 31o 。因為 31 3w  且 31 1t  ，故 31 3 3max( , ) max(5,0) 5
M Js T T   ，則可更新
3 3 31 31 5 1 6
J MT T s t      。逐層指派每個加工步驟的加工起始時間，則最後便可得到以機
器為基的排程結果甘特圖(Gantt chart)如圖 4-8，且最晚完工時間   31f S  。 
 
圖 4-8 範例 JSP其以機器為基的排程結果甘特圖 
本研究提出以 MSC 作為 WFA 求解 JSP 的編碼法。定義解  mc m jx x 代表一股水流的位
置，且 mcx J 。而在 WFA 的分流移步作業中，母水流會先複製自身的位置，接著朝不同的方
向移動產生不同的位置藉此衍生出其子水流。在連續型問題中，水流的移步可以透過加入速度
向量到位置陣列中而得到子水流的位置，但是因為 JSP 是屬於離散型問題，移步作業必頇要考
慮前行限制關係，所以不能使用一般的物理概念得到新的水流位置。因此，根據本研究定義的
MSC，分流移步作業若是要由水流位置 x移動到新水流位置 x ，則必頇要改變機器上工作序列
的排序，但任意改變排序則有可能形成不合理解，因此本研究首先提出機器加工序列交換法
(machining sequence swap)來說明產生不合理解的情況。在本研究使用的 MSC 編碼法中，一個
解 x中的每一列即代表一台機器上加工步驟的排序，而不同的排序會形成不同的解和不同的排
程結果，然而一個合理解的排序經過任意交換加工步驟的順序卻也有可能形成一個不合理解，
因此必頇使用上述提到的 CheckValidityAndSetLevels()程序來檢驗解的合理性。然而透過參考 l
中所有加工步驟的階層值便可避免因為任意改變加工步驟的順序所產生不合理解。 
成功交換一台機器上任兩個不同工作的加工步驟會改變機器上加工步驟的排序，如圖 4-7
所示，代表一台機器上加工步驟前行限制關係的單向虛線箭頭將會被改變且部分節點加工步驟
的階層值也會跟著更新。圖 4-9 是交換圖 4-7 中機器 4 上的工作 1 和工作 2，即將式(4-2)中的
4 行的元素從   4 2 1 3cx  變成   4 1 2 3cx  。 
 
 
Machine 1 
Machine 2 
Machine 3 
Machine 4 
  
 
5 10 15 
 
  
20 25 
   
  
 
 
 
  
  
    
    
    
    
0 30 
62 
 
加工步驟 33o 的階層值小於加工步驟 12o 的階層值 
 
加工步驟 32o 的階層值大於加工步驟 32o 的階層值 
圖 4-11 加工步驟 32o 和 13o 交換之前的機器加工步驟排序關係 
圖 4-11 中，(a)會產生迴圈因此是不合理解，而(b)則是產生合理解，如圖 4-12，且圖 4-12
中的(c)是(b)的階層值更新後的結果。 
    
    
Level 3 4 5 6 
  
    
    
Level 
3 4 5 6 
  
64 
假設c c  ，而工作 mcx 和 mcx 是在機器m 上加工的兩個工作且預備要交換此兩個工作的
加工順序，再假設這兩個工作在機器m 上加工的加工步驟分別是 ,mcx po  和 ,mcx po  。為了產生一
個合理解，加工步驟 , 1mcx po   的階層值必頇要大於或等於加工步驟 , 1mcx po   的階層值，因此可以
確保當工作 mcx 和 mcx 交換順序時，不會有由 , 1mcx po   到 , 1mcx po   代表前行限制關係的箭頭所形成
的迴圈。而當 ,mcx po  是工作 mcx 最後一道加工步驟(即 p p  )或是當 ,mcx po  是工作 mcx 第一道加工
步驟(即 1p  )時，交換程序結束後也不會產生任何的迴圈，因此交換加工步驟的結果便是一
個合理解。 
因此，根據所有加工步驟的階層值陣列 l，可以判斷交換解 x機器加工步驟排序中任一機
器上的兩個加工步驟後是否會形成一個合理解。令 IsAFeasibleJobSwap()是確認交換機器m 上
的工作
1mc
x 和工作
2mc
x 是否會形成合理解的程序，詳細的演算程序如下。 
 
IsAFeasibleJobSwap( x , l , m , 1c , 2c ) 
1 if 1 2c c  
2 
1 2
;mc mcj x j x    
3 else  
4 
2 1
;mc mcj x j x    
5 end if 
6 , ,;m j m jp q p q     
7 if    1p p p     
8 return true 
9 end if 
10 if , 1 , 1j p j pl l      
11 return true 
12 end if 
13 return false 
 
第 1 至 5 行是在確認兩個加工步驟的前行和後繼關係；第 7 至 9 行是檢查兩個待交換的加
工步驟中位於前面的加工步驟是否是其工作的最後一道加工步驟或位於後面的加工步驟是否
是其工作的第一道加工步驟，若滿足任何一個條件則表示交換的結果必然不會產生迴圈形成不
合理解，則傳回 true。 
然而以 MSC 作為編碼法，必頇要確保初始解是一個合理解才可以藉由
IsAFeasibleJobSwap()程序來確定每一次的交換程序都是合理的，而且若是交換程序產生不合理
解則必頇要反覆挑選合格的工作來進行確認，因此會造成演算資源的浪費。故根據階層的概念，
本研究另外提出以機器為基的前行階層(Machine Based precedence level, MBPL)來建構解 x。前
面提到的前行限制階層關係都是以工作為基的示意，如圖 4-7；而若是將圖 4-7 改以機器為基
來描述則結果如圖 4-13，圖中虛線箭頭代表每台機器加工步驟之間的前行限制關係，而實線箭
頭則代表同一工作加工步驟之間的前行限制關係。 
66 
14 , 1mm cx j   
15 1m mc c   
16 1j jp p    
17 1count count    
18 end if 
19 end for 
20 1level level   
21 end while 
 
令 jp 是工作 j 已被指派加工的加工步驟數且 mc 是機器m 上已被指派加工的加工步驟數，
則第 1 行中的集合 P 和C 分別是代表所有工作已被指派加工的加工步驟數集合和所有機器上
已被指派加工的加工步驟數集合；第 2 行是先將解 x中的元素初始化為 0。而因為在一個階層
中，同一台機器上可能有超過一個以上的加工步驟可以被指派加工，因此第 5 行中的 mz 是機
器m上候選加工步驟的集合，且在每一階層開始指派加工步驟前都需要初始化成空集合。而第
6 至 11 行則是判斷只要工作 j 尚有加工步驟未被指派加工，即 jp p ，則便是一個可以被指
派加工的加工步驟，故將 , 1jj po  排入 , 1j p jwz  的集合中成為候選加工步驟。第 12 至 19 行則是從機
器m的候選加工步驟集合 mz 中，使用 DrawAnElement()程序隨機選取 1 個加工步驟進行指派，
除此之外，也可以根據自行設定的篩選條件進行選取或是不選取，細節將在後續說明。而當選
取到的加工步驟是 , 1jj po  時，則 , 1mm cx j  ，且 1j jp p  、 1m mc c  。而第 20 行則表示當
一個階層中所有的機器皆完成選取加工步驟的作業後，則到下一階層反覆進行，直到所有加工
步驟皆被指派加工。 
3.4 JSP 的仿水流優化演算法 
本研究承襲仿水流優化演算法的概念開發求解零工式生產排程問題的仿水流優化演算求
解法，簡稱 WFA4JSP(Water Flow-like Algorithm for Job-shop Scheduling Problems)。首先介紹
初始參數和初始單股水流設定，接著再分別詳述 WFA4JSP 的四個主要作業，最後更新迄今最
佳解。 
本研究提出的 MSC 編碼技術，故令  mc m jx x 是一股水流的位置且代表最佳化問題的一
個解，則WFA4JSP 的演算模型是由一個代表所有水流位置的集合 X 所組成，  1 2, , , NX  x x x ，
N 是當代總水流股數。為了方便說明，在接下來的演算流程中本研究以索引 i 或位置 ix 來代表
一股水流。水流集合 X 會經由反覆的仿水流演算作業產生新的水流集合，同時改善以水流位置
所代表的解的目標函數值，且會經由分流和匯流作業更新其總水流股數和水流的位置。水流的
分流作業會根據水流現在的位置與其之前的位置的目標函數改善量來進行分流，因此，定義水
流 i 的母水流位置  i mc m jx x ，即 ix 可以視為是水流 i 之前的位置，且一股母水流可以分出多
股子水流；再令 if 是水流 i 的目標函數值，即  i if f S ；而 if 則是水流 i 其母水流的目標函數
值，即  i if f S 。 
JSP 是屬於最小化的問題，故當水流集合中的水流目標函數值小於迄今最佳目標函數值時，
便頇更新迄今最佳目標函數值。定義 f 是迄今最佳目標函數值，且集合 X 是記錄更新迄今最
68 
 
圖 4-14 水流 i的 MBPL和其 PMBPLOR區間的起始階層 i 及階層數 i 關係 
初始水流的位置 1x 是採用MBPL的技術逐層指派加工步驟建立而成，而根據MSC的定義，
解 x每一列的元素排序即代表一台機器上加工步驟的加工順序，而排程作業便是根據這個排序
進行排程。JSP 的排程結果分為有效排程(active schedule)和半有效排程(semi-active schedule)；
一個合理的排程結果若被稱為有效排程則代表此排程中沒有任何一道加工步驟可以提早開始
加工而不會延後其他加工步驟的加工起始時間，即一個有效排程若是可以減少最晚完工時間
 f S 則必然會增加某些加工步驟的加工起始時間；而半有效排程則是可以減少最晚完工時間
 f S 卻不增加其他加工步驟的加工起始時間，故一個 JSP最佳解的排程結果必定是有效排程。
圖 4-8即是一個半有效排程，在機器 4加工的加工步驟 11o 可以提前到其機器前行加工步驟 23o 之
前進行加工而不影響其他加工步驟的加工起始時間，使得機器 4 上的加工步驟排序由
   4 2 1 3cx  變成   4 1 2 3cx  ，結果則如圖 4-15。而圖 4-16 則是一個有效排程的範例，圖中
沒有任何一個加工步驟可以提前加工而不延後其他加工步驟的加工起始時間。 
 
 
  
 
 
  
   
  
 
Leve
l 
1 2 3 4 5 6 8
E
7 9 
  
  
70 
5 while count mj  
6  ; 1,2, ,mz m m     
7 for 1j   to j  
8 if jp p  
9 , 1jj pm w   
10 if 1mc m     
11 if  , 1CheckActive , , , , truej M Jj po T T P S    
12 , 1jm m j pz z o    
13 end if 
14 else 
15 , 1jm m j pz z o     
16 end if  
17 end if 
18 end for 
19 for 1m  to m  
20 if   , 1DrawAnElement jm j pz o   
21  , max ,j
M J
j p m js T T  
22 , ,j j
J
j j p j pT s t    
23 , 1mm cx j   
24 
M J
m jT T   
25 1m mc c   
26 1j jp p    
27 1count count    
28 end if 
29 end for 
30 1level level   
31 end while 
 
第 1 至 20 行和 ConstructAFeasibleSolution()程序相同；第 21 至 27 行表示加工步驟 , 1jj po  在
機器m上還有其他機器後繼加工步驟，因此必頇透過 CheckActive()程序來檢驗當加工步驟
, 1jj p
o  在階層 level 被指派時，是否會造成其機器後繼加工步驟產生半有效排程，而若 , 1jj po  已
經是機器m  。若 CheckActive()傳回 true，表示如果加工步驟 , 1jj po  在 level 被指派，則並不會
造成機器m上其他機器後繼加工步驟形成半有效排程，因此 , 1jj po  便是機器m上的候選加工步
驟。而第 36 至 38 行則是在建立水流位置的同時也同步進行排程作業。而檢驗加工步驟是否會
造成機器後繼加工步驟形成半有效排程的演算程序 CheckActive()細節如下。 
 
CheckActive( j po   ,
MT , JT , P , S ) 
1 Sˆ S  
72 
可藉由變動水流的位置產生子水流的位置。每條水流的分流數不可大於使用者設訂的分流數上
限 n，以防止水流無限制地增加。本研究設計當目標函數值變動量較小的水流會分出較多的子
水流進行較廣泛的搜尋；另一方面，目標函數值變動量較大的水流則應維持單股鄰域的搜尋。
而除了目標函數值變動量會影響分流股數之外，水流質量和使用者自行設定的水流股數上限
N 同樣也會對分流股數造成限制，當水流質量不足以使水流產生分流時，則維持單股流動。 
分流股數 
WFA 相較於其他優化演算法最大的不同便是在搜尋的過程中，可以動態調整解代理人的
數量。令 是目標函數值變動量門檻，而隨著演化代次的增加，門檻值必頇要適時的修正，
當水流目標函數值變動量超過門檻值時，應維持單股的鄰域搜尋，反之則是多股搜尋。本研究
設定 的初始值是 和 的下限 是由本研究依照每個標竿問題解的值域不同而設定不同的值，
且當每次更新迄今最佳解的時候便頇同時更新目標函數值變動量門檻 
,  if 
,  if <
,  otherwise
f f
f
f f f f
f f
 
  

 

   
 
 
 


  
  





， (4-8) 
式中 f 是迄今最佳解也是最佳解目標函數集合 F 中的最小值，即  1 2min , , , gf f f f    ，而
f 則是次小的目標函數值。因此令根據水流 i 目標函數值的變動量所分流的股數 
Round Pow , 1
i i i
i
f f f
n n

   
     
   
   
。 (4-9) 
WFA 另外設計當水流質量低於分流質量下限時便無法繼續分流，只能維持單股演化，令每股
水流質量下限是 Nn ，因此若根據水流 i 的質量，則水流 i 最多可以分出 i
Nn


 
 
 
股水流。 
由於水流的股數受到使用者設定的水流股數上限 N 的限制，所以在決定分流股數的時候
必頇要考慮當所有母水流都完成分流後的子水流總數是否會超過 N ，因此本研究設計在分流
開始時，需先將所有母水流依照其目標函數值由小至大排列，分流的順序則是由目標函數值最
小的母水流開始分流，若分流股數會導致子水流總數超過 N 則維持單股演化，故設代表分流
順位的水流陣列 1 2 n   X x x x 且水流 i 的目標函數值 1i if f   ，故本研究定義水流 i 的分流股
數 
1
1
1, if  
min , ,  otherwise
i i i
i ii
i
i
i
i
f f
n i n n N
f
n
n
Nn





 
      

 
  
  
  

。 (4-10) 
74 
上的候選加工步驟後，優先指派在母水流中階層值較小的加工步驟，目的是希望第三個區段內
的加工步驟可以繼承母水流中的機器加工步驟前行關係。舉例來說，在階層 level 時，若在第
三區段內機器m 上的候選加工步驟集合  12 33 24  mz o o o 且在母水流機器m 上的機器加工步驟
前行關係是 33 12 24o o o  ，則 33o 優先指派。令 SplittingAndMovingOperator()是分流移步的程
序，則程序的細節如下。 
 
SplittingAndMovingOperator(in ix , in k , in k , out ikx ) 
1    1 2 1 2, , ;  , , , mjP p p p C c c c   
2    1,2, ;  1,2, ,M M J Jm jT T m m T T j j      
3   , 0, 1,2, , , 1,2, ,ik mc mcm jx x m m c j     x   
4 0count    
5 for 1m  to m  
6 for 1c   to j   
7 mcj x   
8 mjp q    
9 if j p kl      
10 mc mcx x   
11 j p j pl l      
12 j p j ps s       
13 1m mc c   
14 1j jp p    
15 1count count    
16 end if 
17 end for 
18 end for 
19  max 1,2, , , 1,2, ,Jj jpT s p p j j    
20  max ; 1,2, , ; , 1,2, ,Mm jp jpT s j J p p w m m m       
21 for klevel   to 1k k    
22  , 1,2, ,mz m m     
23 for 1j   to j   
24 if jp p  
25 , 1jj pm w   
26 if 1mc m     
27 if  , 1CheckActive , , , , truej M Jj po T T P S    
28 , 1jm m j pz z o    
29 end if 
30 else 
31 , 1jm m j pz z o     
76 
72 
J
j j p j pT s t       
73 
M J
m jT T   
74 1count count      
75 exit 
76 end if 
77 end for 
78 end for 
79 1level level   
80 end while 
 
第 3 行中 ikx 代表是水流 i 第 k 股子水流的位置；第 5 至 18 行是將母水流第一個區段的加
工步驟複製到子水流，式中 j pl   和 j ps   分別是子水流加工步驟 j po  的階層值和加工起始時間，且
j p j pl l     、 j p j ps s     。而第 21 至 46 行則是重新指派母水流階層 k 至 1k k   之間的加工
步驟，其中第 36 行 DrawAnElementByRules()是本研究使用一些常見的派工法則來選取加工步
驟的程序，分別最多未加工的加工步驟優先指派法、最長剩餘加工時間優先指派法、隨機指派
法，本研究則採取混合策略來指派加工步驟；而第 48 至 80 行則是指派階層 k k  之後的加
工步驟，而機器m 上候選加工步驟的指派原則是根據母水流 i 中機器m 上的機器加工步驟前行
限制的關係來選取加工步驟，假設 ,jp j p mo o z  ，且 jp j pl l   ，表示在母水流中， jpo 是 j po  在機
器m 上的前行加工步驟，則在指派的時候加工步驟 jpo 將優先於 j po  被指派。 
分流移步作業的最後一個步驟是分配子水流質量和指定其母水流的相關屬性。本研究設計
的質量分配方法是按照子水流的目標函數值改善量的比例作分配，因為 JSP 是屬於望小的優化
問題，故目標函數值改善量越大的水流則分配越多的質量，越小的則分配越少的質量，設水流
i 所分出的第 k 股水流的目標函數值是 ikf ， 則第 k 股子水流的目標函數值改善量即是 i ikf f ，
且目標函數值改善量有可能是負的。本研究定義改善量最大的水流所分配到的質量是改善量最
小的水流的兩倍，因此水流 i 的子水流最大改善量和最小改善量分別是 
 1,2, ,max ik n i ikf f     (4-13) 
 1,2, ,min ik n i ikf f   。 (4-14) 
因此第 k 股子水流所分配到的質量比例是 
   k i ikf f        ， (4-15) 
則第 k 股子水流從母水流 i 所分配到的質量 
1
i
k
ik in
kk
m m

 


。 (4-16) 
在質量分配完之後，水流 i 的目標函數值 if 便轉換成其子水流的母代屬性資料，即 ik if f ，
1,2, , ik n 。若 1in  ，則水流 i 將直接經由分流移步作業直接改變原先的位置形成子水流。
當所有水流都完成分流作業後，子水流便可形成新的水流集合 
 1 21 , , , i
n
i i ini
X

 x x x ， (4-17) 
78 
WFA 設定降雨產生的水流數與當代水流股數 n相同，但是當代水流股數受到水流股數上
限 N 的限制，且降雨產生的水流質量也不可小於 N ，因此本研究設定降雨產生的水流股數 
 min , ,n n N n N       ， (4-24) 
且降雨產生新水流位置分為隨機新水流位置和過去最佳解鄰近移動的水流位置，每股水流以隨
機的方式決定其降雨後的位置位置。令  1 2, , , nX     x x x 是由降雨產生的水流集合，設
 0,1U 是均勻分布於 0,1 之間的隨機亂數，本研究定義當  0,1 0.7U  時，降雨產生的水
流位置 ix 是隨機新水流的位置，產生的方法和初始解產生法一樣使用
ConstructAnActiveFlowAndSchedule()程序來建構一股水流的位置；而當  0,1 0.7U  時，則降
雨產生的水流位置 ix 是由過去最佳解的水流位置移動到鄰近的水流位置，首先隨機從迄今最
佳解的水流集合中選取一股水流位置成為新水流 ix 其母水流 ix ，即  DrawAnElementi X x ，
然後令  1, 2i iRandom L   且 1i  ，接著使用與分流移步相同的程序由母水流位置 ix 移動到
新的水流位置 ix 。而降雨產生的水流質量採取平均分配的方式，令 i是水流 ix 的質量，故
i n   。降雨作業完成後，大氣中的水氣含量 0  ，且更新水流集合 X X X   和水流
數n n n  。若降雨作業有產生新的水流，則必頇再執行匯流作業。 
更新迄今最佳解 
WFA 在一個演化代次的最後一個步驟是評估當代水流所代表的目標函數值和更新迄今最
佳解。假設水流 i 是當代水流集合中的目標函數值最小的水流，即  1 2min , , ,i nf f f f ，若
if F ，則 iX X
   x ， 1g g  ， iF f 。 
4. 仿水流優化演算法系統及範例驗證 
4.1 WFA4JSP 系統 
本研究為實作所提的 WFA4JSP 的演算流程並使用 Microsoft Visual Studio 2010 作為開發
工具，在 Microsoft .NET Framework 平台下以 C#語言開發以仿水流演算法求解零工式生產排
程問題(Water Flow-like Algorithm for Job-shop Scheduling Problems, WFA4JSP)系統。 
4.2 WFA4JSP 標竿問題求解效能分析 
經過本研究的測詴，建議由使用者數設定的 WFA4JSP 參數如表 4-1。 
表 4-1 WFA4JSP參數設定 
參數名稱 參數值 
總水流質量  60 
水氣蒸發率  0.05 
降雨因子    0.3 
分流股數上限n   5 
水流股數上限 N   30 
80 
 
圖 4-17 WFA4JSP和優加劣減螞蟻擇段系統的演化最佳求解結果相對誤差比較 
除了比較演化最佳之外，優加劣減螞蟻擇段系統也有提出平均的求解數據，經本研究比較
的結果如表 4-3，在 10 個標竿問題中，WFA4JSP 有 3 個問題的演化平均解較優於優加劣減螞
蟻擇段系統，但有 6 個問題則較差，另有 1 個問題是持平。而圖 4-18 是 WFA4JSP 和優加劣減
螞蟻擇段系統演化平均求解結果相對誤差比較。 
表 4-3 WFA4JSP和優加劣減螞蟻擇段系統演化平均求解結果比較 
Problem size BKS 優加劣減螞蟻擇段系統 WFA4JSP 
演化平均 相對誤差 演化平均 相對誤差 
LA16 10 10   945 974 3.1 965 2.1 
LA17 10 10   784 787 0.4 791 0.9 
LA18 10 10   848 853 0.6 859 1.3 
LA19 10 10   842 853 1.3 883 4.9 
LA20 10 10   902 907 0.6 931 3.2 
LA21 15 10   1046 1091 4.3 1082 3.4 
LA22 15 10   927 976 5.3 972 4.9 
LA23 15 10   1032 1032 0 1032 0 
LA24 15 10   935 986 5.5 998 6.7 
LA25 15 10   977 1022 4.6 1046 7.1 
0
1
2
3
4
5
6
相
對
誤
差(
%)
 
標竿問題 
優加劣減螞蟻擇段系統 
WFA4JSP
82 
LA27 20 10   1235 1308 5.9 1308 5.9 
LA28 20 10   1216 1256 3.3 1279 5.2 
LA29 20 10   1152 1251 8.6 1283 11.4 
LA30 20 10   1355 1387 2.4 1405 3.7 
LA32 30 10   1850 1857 0.4 1850 0 
LA33 30 10   1719 1719 0 1734 0.9 
LA34 30 10   1721 1766 2.6 1759 2.2 
LA35 30 10   1888 1888 0 1912 1.3 
LA36 15 15   1268 1311 3.4 1347 6.2 
LA37 15 15   1397 1473 5.4 1446 3.5 
LA38 15 15   1196 1282 7.2 1253 4.8 
LA39 15 15   1233 1283 4.1 1301 5.5 
LA40 15 15  1222 1290 5.6 1279 4.7 
由表 4-4 可以看出，在 23 個標竿問題中，WFA4JSP 有 13 個問題的相對誤差較 2ST-PSO
高，而有 10 個問題的相對誤差較 2ST-PSO 低。整體看來，WFA4JSP 和 2ST-PSO 的求解結果
不相上下，但是 2ST-PSO 在其系統中設計當演算到達設定的代次便會執行 CB 區域搜尋法
(Yamada 和 Nakano 1995)，而本研究並沒有使用任何的區域搜尋法。圖 4-19 是 WFA4JSP 和
2ST-PSO 的標竿問題求解結果相對誤差比較。 
 
圖 4-19 WFA4JSP和 2ST-PSO的標竿問題求解結果相對誤差比較 
4.3 小結 
根據標竿問題測詴的結果顯示，WFA4JSP 演化求解的效果在大多數的問題上與已知最佳
解的誤差都不至於太大，即便沒有使用任何的區域搜尋法，求解問題的收斂效果都能達到頗佳
的水準，且因為使用 MSC 編碼法搭配有效排結果程篩選機制而在分流移步作業中能更有效率
的進行解的搜尋，並透過降雨作業使得演化不至於長期困在區域最佳解中。 
5. 結論與建議 
仿水流演算法是近年所提出的創新演算法，主要是仿照水流在自然界流動循環的特性設計
而成。而在開發之初，由於連續型問題與自然空間較為相似，故其在求解連續型問題的效能都
0
2
4
6
8
10
12
FT
1
0
LA
1
6
LA
1
8
LA
1
9
LA
2
0
LA
2
1
LA
2
2
LA
2
4
LA
2
5
LA
2
6
LA
2
7
LA
2
8
LA
2
9
LA
3
0
LA
3
2
LA
3
3
LA
3
4
LA
3
5
LA
3
6
LA
3
7
LA
3
8
LA
3
9
LA
4
0
相
對
誤
差(
%)
 
標竿問題 
2ST-PSO
WFA4JSP
84 
五、 多目標連續型仿水流優化演算法 
1. 簡介 
優化問題的發展複雜化，讓近數十年來許多學者致力於開發有效率的求解技術。其中以演
化式演算法來解決多目標優化問題一直是許多研究中很重要的議題，也是許多研究領域所必需
的解決方法。由於不同的問題和不同的領域並不是都能用同一種方法來解決，因此目前有許多
的演算法被應用於解決多目標問題，這些演算法包括了基因演算法(genetic algorithm)、粒子群
最佳化演算法(particle swarm optimization)和蜂群演算法(honeybee algorithm)等。但是這些演算
法大部分都一個共同問題，即是過多的固定求解群體，這會使解在趨近於收斂時，產生許多相
似度極高的解，所造成的運算資源的浪費。 
Yang and Wang [2]所提出的仿水流優化演算法(Water Flow-like Algorithm, WFA)的起始為
單一解，視演化過程分為一個以上的解進行廣域搜尋。當兩個以上的解所搜尋到位置相鄰時即
合併成單一解，避免造成無效率的重複搜尋。仿水流優化演算法以模擬自然界中水流流動現象
為主要概念，水流會受地心引力吸引而流動，且因地理空間規範而漸趨流向地面的最低點。
WFA 演算中反覆進行分流移步、匯流、蒸發、和降水四個作業。每個解由一股水流代表，進
行數量變動的求解搜尋。水流具有質量和速度，形成的動能足夠時即可依地形變化分支出多股
子水流進行搜尋。當多股水流匯集至相同時便結合成單一股水流，並且匯聚新的速度與質量。
水流的質量在流動過程中會逐漸散發於大氣中，當大氣中的水氣到達飽和程度時即會落下雨水，
產生新水流或增加質量到既有的水流中。WAF 發展的初期，證實 WFA 求解物件分群優化問
題的成果較 GA、EM、及 PSO 等啟發式演算法較佳。而在近幾年也有相關論文研究證實 WAF
在一般性排序優化問題的求解成果較 GA 優越，但是目前尚未在多目標最佳化領域上有所突破，
因此本研究致力於發展能有效節省求解資源的多目標仿水流演算法。 
2. 多目標連續型仿水流優化演算法
 
仿水流優化演算法(Water Flow-Like Algorithm, WFA)模擬大自然中水流流動的物理行為，
由單一股水流為起始，求解各種型態的優化問題。本研究即在開發求解多目標連續型優化問題
的仿水流優化演算模式和方法，簡稱 WFA4MC(Water Flow-like Optimization Algorithm for 
Multi-objective Optimization Problems)。求解模式將運用 WFA4MC 動態調整代理人(即水流)數
量的特性，在目標空間及解空間中進行移步搜尋，有效求得非臣服解。以下逐一說明多目標連
續型優化問題的基本概念、WFA4MC 的演算內容及 WFA4MC 的演算程序。
 
2.1 多目標連續優化問題 
現今決策問題的日益複雜，優化問題已不能只考慮單一目標問題，而是多個目標需同時被
滿足。因此單目標已無法滿足現今工業需求與應用，多目標優化問題變成工程及研究方面的重
要議題。假設 p 為正整數且是多目標優化問題的解維度，一個解以向量
1 2x px x x   表示。x
的變數 kx 限制在給定的下限 kx 和變數上限 kx 間，因此 k k kx x x  ； , ,k k kx x x ，
1,2, ,k p   。
若此多目標優化問題的目標函數個數為 g ，解 x的目標函數值則定義為 g 維的目標值向量
     1 2 1 2f x x xg gf f f f f f       且   :x
p
jf  ，
1,2, ,j g ，而每個目標函數值的
優化目標可能是最大或最小化。不同於單一目標問題求解最後得一個最佳解，多目標規劃問題
86 
置   1 ~ 0,1k k k kx U x x x   ， 1,2, ,k p 。令
1 1 1 1
1 2f gf f f   和
1 1 1 1
1 2f gf f f   是解
1
x 和 1x
的目標向量，經目標函數值計算，再執行臣服與否驗算後可組成初代非臣服解，故 
   
   
 
1 1 1
1 1 1
1 1
, if Dominated , true
ˆ ,else if Dominated , true
, ,otherwise
x x x
x x x
x x
X
 


 


 (5-2) 
目標函數值的改善量會影響水流的移動和數目，為了估計目標函數值改善量，頇記錄並更新演
化至目前所獲得的最大和最小目標函數值。令
jf 和 jf 是目標函數值  xjf 目前所搜尋到的最大
和最小值。初代演化時  1 1min ; 1,2, ,,j j jf j gf f   而  1 1max ; 1,2, ,,j j jf j gf f   。由於
多目標最佳化問題有多個目標函數，因此使用權重法將水流 i 的 g 個目標函數值 ijf ，
1,2, ,j g ，轉化成單一目標函數值 iF 以方便評估水流改善率。使用權重法時頇考量不同目
標函數值的單位問題，所以水流 i 的目標函數值在轉化成單一值之前頇先行將 ijf 標準化成單位
化目標函數值 
i
j ji
j
j j
f f
f
f f

 

。 (5-3) 
接著以權重法加總目標函數值成單一目標函數值 
1 1
i
g g j ji i
j j jj j
j j
f f
F w f w
f f 

 

  ， (5-4) 
式中
1
1.0
g
jj


 ，0 1.0j  。 j 是  jf  的權重，同樣地水流 i 的母水流也頇計算單位化目
標函數值 
i
j ji
j
j j
f f
f
f f

 

， (5-5) 
並使用權重法得到合併後的目標函數值 
1
i
g j ji
jj
j j
f f
F w
f f



 。 (5-6) 
進行分流作業時，各水流的分流數由目標函數值改善量來決定。為了評估改善量，設 是
分流與否的門檻。當改善量超過分流門檻 則不進行分流，以單一股水流進行演化。目標值改
善量會隨著演化代次趨緩，為避免形成高分流門檻，無法不進行分流，因此將累計每代次所有
水流的目標值改善量並取其平均設為當下演化代次的分流門檻。設門檻值隨代次演化為 
F
N


 。  (5-7) 
式中 F 是水流的改善量，N 是累積分流數。每代次完成時更新一次。因此第一代次時
1 1F F F   且 1N  因為  1xX  。 
88 
 
, if ~ (0,1) 0.5
RandomReal , ,otherwise
i
qk
U
x

 

 

 ， (5-12) 
 ~ RandomReal min,max 是介於 min 和 max 之間且均勻分布的亂數值。而所有子水流的位置
向量會依據位置順序一一的指派。 
本研究研擬多目標連續優化仿水流演算法提供兩種不同的匯流模式：一種是以水流位置的
接近程度當作匯流標準，另一種為以水流目標函數值的相似度為匯流標準。分流的最後一個步
驟是子水流質量的分配和指定其母水流，本研究依據不同的匯流模式分別使用不同的質量分配
法。第一種質量分配法是平均地分配質量給子水流，設 iqm 是水流 i 所分流出的第 q 條子水流之
質量；於是 
1i i
q i
m m
n
  (5-13) 
， 1,2, ,
iq n 。第二種質量分配需先計算子水流的目標函數值。設水流 i 所分支出的第 q 條子
水流之目標函數值是    1 1 2f x xi i i i i iq gq q q q qgf f f f f         ，而權重加總後的目標函數值是
1
i
g qj ji
q jj
j j
f f
F w
f f



 ， 1,2, ,
iq n 。公式中的最大值 jf 和最小值 jf 需在每次計算過所有子水
流的目標函數值後更新。質量會依據各子水流的目標值改善量進行分配。以水流 i 所分流出的
第 q條子水流為例，第 q條子水流的改善量即是 i iqF F ，但是改善量可能為負值。本研究讓有
改善量最大的子水流所分配到的質量是改善量最小的子水流的兩倍。首先求得子水流的最大和
最小目標值改善量，分別是  
1,2, ,
max i
i i
qq n
F F

  和  
1,2, ,
min i
i i
qq n
F F

  。子水流 q 的質
量分配比例為 
   i iq qF F        (5-14) 
，水流 i 的子水流的質量 
1
i
qi i
q n
qq
m m

 


，
1,2, , iq n
。 (5-15) 
在所有質量皆分配完畢後，水流 i 的位置、目標函數值和加權後的目標函數值轉變為子水流的
母代屬性資料，即 
1,2, ,
x x
f f
i i
q
ii i
q
i i
q
q n
F F


 

 
。 
若 1
in  ，則將水流 i 經由移步轉換成該水流的唯一子水流。最後更新當下水流集合 X 為所有子
水流所構成，即  1 21 , , ,x x x i
n i i i
ni
X


 ，同時更新水流數 1
n i
i
n n

 。 
匯流 
90 
值域為0 1  。令 是大氣中的累積的水氣量，演化初始時歸零， 0  。在蒸發作業中蒸
發後的水氣質量會加到大氣的水氣量  內，即 
1
n i
i
v v m

   。  (5-18) 
經過蒸發後， X 中每條水流的質量更新為 
 1 ; 1,2, ,i im m i n   。 (5-19) 
水流的質量關係到水流是否能繼續參與下個代次的演算流程，蒸發後若水流的質量小於質
量下限則刪除該水流。總水流數由使用者自行設定，令 z 是總水流上限；則水流的最小質量限
定是m z，m 是使用者所設定的水流初始質量。當水流質量小於m z 表示水流質量小於演化環
境中每條水流應有的平均質量，判定水流的質量不足以使水流繼續進行演化，因此並刪除質量
不足的水流並將其質量全數蒸散於大氣之中
, /i
i
i m m z
v v m
 
  ，同時更新水流集合 
 | /xi iX X m m z   。 
降水 
降水作業的功能在於將大氣中的水氣降於地面成新水流。求解過程有助於開發新的搜尋區
域以跳脫區域最佳解。當大氣中的水氣含量達使用者設定的水氣飽和度即自動進行降水作業。
降水的水氣質量下限是： m ；值域0 1  的  是水氣飽和度。因此水氣質量v m 時大氣
中水氣達飽和狀態，執行降水作業。 
降水產生的水流數設定是目前 X 內的水流數 n，但是水流總數被 z 所限制。另一方面，在
每條水流最小質量是m z 的限制下，依照m z 的比例分配水氣質量 時，最多可產生 vz m  條
水流，因此降水的水流數是 
 min , ,n n z n vz m      。 (5-20) 
令  1 2, , ,x x x nX     是由降水作業產生的水流，而 X 裡每條水流的質量由大氣中的水氣質
量 來分配。令 im 是降水水流 x i 的質量，於是 i vm
n
  。每條降水水流的位置是以現有水流
集合中隨機抽出一股水流的位置為基礎隨機偏離一範圍。在派定
1 2x
i i i i
px x x      的位置時首
先頇從 X 中隨機選出一條水流 i，接下來在每個元素 i
kx
上給定一個介於位置變數上限和下限
之間的隨機距離 i
k ；即
i
kx 是
i
kx
隨機向正向或負向偏移，再隨機距離偏移。偏移結果若 i
kx 超
出變數的上下界 , kkx x 時，則指定
i i
k kx x

 否則設成偏移結果，因此得到 
, if ( )
,else if ~ (0,1) 0.5 1,2, ,
,otherwise
RandomInteger(1, )
~ (0,1)( )
i i i i i
k k k k k k k
i i
k k
i i i
k k k
i
k k k
x x x x x
x U k p
x x
i n
U x x
 



  


     
 
   
 
   
  
 
  
 
，
1,2, ,i n
，  (5-21) 
92 
   
1, ,1, ,
ˆ ˆmax mini ij j ji si s
r f f
 
 
  ， 1,2, ,j g ， (5-24)  
 非臣服解 i 的擁擠距離是 
11, , ;
1 ˆ ˆmin
g i ii
j jji s i i
j
f f
r


  
   
   
   
 。 (5-25) 
在反複執行的過程中
i 和
jr 會不斷的更新，每刪除一個非臣服解後需更新現有非臣服解的
i 且更新目前 Xˆ  內目標 j 的最大值和最小值計算新的
jr 。擁有最小
i 值的非臣服解會從 Xˆ 剔
除；即  *ˆ ˆ xˆiX X  ，式中
*
1, ,
arg min i
i s
i 

 。 
分流移步的程序需參看現有非臣服解來因引領水流動，為了讓子水流朝目標函數值空間中
較分散的位置前進，而非過於擁擠的位置。因此每代次結束後若繼續保留過多在目標函數空間
分布過於緊密的解並非有意義的事。為了讓分散性較佳的非臣服解來領導後續產生的水流，在
每一代次結束後若 s s ，則刪除較擁擠的 s s 個非臣服解，保留 s 個在目標函數值空間分布
較分散的非臣服解。 
2.3  WFA4MC 整體演算程序 
圖 5-1 展示的流程圖是仿水流優化演算法在多目標連續型優化問題的運算程序。停止條件
可設定演化時間上限、演化代次上限，和目標函式呼叫上限，使用者可依需求從中選擇其中一
項。由水流初始化開始依序進行分流移步、匯流作業，和蒸發作業。蒸發作業執行完畢後大氣
中所累積的水氣達到飽和執行降水作業，否則對直接對非臣服解進行更新。非臣服解更新完成
後，會對多餘的非臣服解進行裁減。執行一代次水流演化作業後，檢查是否符合停止條件。若
是則完成水流演化，以迄今最佳解作為求解最終結果。否則以現有水流再次由分流作業開始進
行下一代次水流演化程序。 
 
[大氣中水氣達飽和] 
[else] 
[達停止條件]  
降水 
[else] 
非臣服解更新 
 
水流初始化 
蒸發 
匯流 
分流移步 
非臣服解集合裁減 
 
圖 5-1 仿水流優化演算法於多目標連續型優化問題的演算流程 
3. 多目標連續型仿水流優化演算法範例驗證 
94 
1,2, ,
1
ˆ ˆmin f f
g
i i i
i s i i
j
d

  

 
   
 
 ， 1,2, , 1i s   (5-29) 
1
1
( 1)
s
i
i
d
d
s






 ，  (5-30) 
式中 s 是非臣服解個數， g 是目標值數目，
id  是 xˆi 和在目標函數值空間中最鄰近非臣服解間
的距離，d 是所有 id  的平均。 id  與 d 的差距越小表示解的分佈狀況越均勻，因此當非臣服解
分布越平均時， S 會趨近於零。 
收斂距離然可以非臣服解和柏拉圖解之間的相近程度，但並未考量非臣服解的正確性，即
非臣服解能否成為柏拉圖的一員。因此為了衡量最終求得的非臣服解集合 Xˆ 內的非臣服解與
已知的柏拉圖前緣線解集合 X 隸屬程度，本研究研擬正確率(Correctness)為求解品質評量指標。
令正確率 
ˆ
1 ˆ100% 100%
ˆ
X
C X
sX

     ， (5-31) 
  ˆ ˆˆ ˆ and Dominated ˆ ,
x
x x x x
i
i i i i
X
X X


 
      (5-32) 
，C 是百分比定義成 Xˆ 內的非臣服解也是柏拉圖解的比例百分比，而式中 Xˆ 是 Xˆ  內未臣服
於任何一個柏拉圖解的非臣服解組成的集合。 100%C  時，表示求得的非臣服解均是柏拉圖
前緣解，因此C 越大表示演算法的可信度越高。 
任何多目標演算法最主要的目的是提供決策者完整的決策資訊，即使所求的收斂距離和正
確程度再好，若非臣服解的廣度不佳，則所的到的資訊也只是局部的。而均勻變異指標雖然可
評估非臣服解之間的均勻性，但是無法表示非臣服解在目標函數值空間的涵蓋度，即所求的非
臣服解分布的廣度。因此本研究提出涵蓋度(Coverness)來表示非臣服解的廣度。令 是解的涵
蓋度， 
 
u
X
 ， (5-33) 
式中u 表示非臣服解所涵蓋的柏拉圖解鄰近區域的個數。 
令 是區域半徑(Radius for Pareto Neighbourhood)，為使用者設定，為了平均分配目標函數
值空間，建議
1
X
  。且令  1 2, , nQ Q Q 是柏拉圖鄰近區域是否被非臣服解所占有的辨識
集合， n是柏拉圖解數，初始化時 0iQ   ， 1,2, ,i n  。當 越大，代表非臣服解的分散性越
好；若 越小則分散性越差。頇注意在使用此指標的時候為了比較的公平性，n s 為必要條件。
因為當 n s  ，就算所有非臣服解皆平均地分散在柏拉圖解鄰域，但是分母 n 較大，會讓涵蓋
的數值過小不足以表達分散度。因此柏拉圖解數頇等於非臣服解數才能在涵蓋度指標中表示 Xˆ
的分散度。 
96 
表 5-1 WFA4MC在五個標竿問題參數設定內容 
 
3.3 匯流模式的比較 
第一組實驗為 WFA4MC 在兩種匯流模式下比較解的品質，為了比較兩種匯流法的差異，
在此實驗中將 L 和 o 皆等於0.01。過去的仿水流優化演算法會在分流出子水流後計算目標函
數值，如同 OM 法，由目標函數值的優劣分配質量，因此匯流作業時可以直接使用目前擁有
的目標函數值作為匯流的參看資訊。但是此方法有缺點，若所分出的子水流在經目標函數計算
後相發現與其他水流的目標函數值相近，爾後跟其他水流結合成一條水流，對運算資源造成無
謂的浪費。基於結構相似的代理人其目標函數可能極為接近，因而另外設計 LM 法，經由匯流
後再判別是否需計算目標函數值，來節省運算資源。為了比較兩種匯流模式的求解效能差異，
參數設定如表 5-1 說明，每題執行 30 次並設所有問題求解的非臣服解數 100s  ，選用 Zitzler et 
al. (2000)所提供如附錄 A 所表示的 100 個柏拉圖解執行非臣服解的品質評量。在停止條件的
設定上選用目標函數呼叫次數為停止條件，ZDT1、ZDT2、 ZDT3 和 ZDT6 的目標函式呼叫
上限是 30000， ZDT4 是 250000，並求得G、C 和 值平均值，說明兩種匯流方式的求解效能。 
表 5-2WFA4MC在五個標竿問題的收斂距離(G)平均值 
標竿問題 LM 法 OM 法 目標函式呼叫上限 
ZDT1 0.000508 0.000715 30000 
ZDT2 0.000427 0.000487 30000 
ZDT3 0.000501 0.000504 30000 
ZDT4 0.000438 0.000476 250000 
ZDT6 0.000991 0.001069 30000 
表 5-3 WFA4MC在五個標竿問題的涵蓋度( )平均值 
標竿問題 LM 法 OM 法 目標函式呼叫上限 
ZDT1 0.973333 0.971333 30000 
ZDT2 0.954483 0.965333 30000 
ZDT3 0.853103 0.861724 30000 
ZDT4 0.978621 0.965423 250000 
ZDT6 0.903561 0.918946 30000 
98 
表 5-2、5-3、和 5-4 是 WFA4MC 在兩種匯流法下三種評量指標的平均值，圖 5-2、5-3、
和 5-4 為其評量指標的平均值直條圖。圖 5-2 和 5-3 顯示 LM 法對柏拉圖解的收斂距離和正確
率較 OM 法出色。因為 LM 法先對水流做相似性評估，再進行運算，可省去不必要的目標函
式運算次數，較有機會搜尋到與柏拉圖解較接近的非臣服解。而 OM 法的優點在於匯流時是
根據非臣服解彼此在目標函數值空間的位置，能較準確刪除在目標函數值空間較擁擠的解，有
所求得的非臣服解有較佳的分散性。因此可以從圖 5-4 和表 5-3 觀察到 OM 法在涵蓋度的表現
略優於 LM 法。在以上三項評量指標中 LM 法在其中兩項表現比 OM 法好，因此以本研究所
解決的題目類型而言，LM 法較 OM 法適用。 
3.4  WFA4MC 成效結果分析 
第二組實驗在相同的停止條件下將 WFA4MC 和多目標粒子群演算法 MOEPSO，AMOPSO
和 NSGA-Ⅱ兩種方法進行求解結果比較。除了兩種匯流法的匯流相似度外，其它參數和目標
函式呼叫上限停止條件的設定和前面測詴相同。經實驗設計後，OM匯流法的相似度 L 和 o 設
定上，而在使用LM  法時，ZDT1、和 ZDT4 的 0.01L   ，ZDT3 的 0.05L   ，ZDT2 和 ZDT6
的 0.1L  。OM法除了 ZDT2 在 0.1o   時表現較佳，其他題目皆在 0.01o   。使用收錄於
附錄 B 中 Huband, et al. [11]所提供 500 個柏拉圖解，非臣服解數為 100，每標竿問題執行 50
次後取各衡量指標的平均值和上述四種演算法比較結果。表 5-5 中 WFA4MC(LM)是 WFA4MC
使用 LM 法執行匯流的情境而 WFA4MC(OM)代表 WFA4MC 使用 OM 法進行匯流。 
由於本研究認為 S 值無法表達非臣服解集合的廣度。當非臣服解之間分布極為平均，但全
體非臣服解過度集中在目標函數值空間的某個區塊時，單討論非臣服解集合之間分布的平均性
是沒有意義的，所以本研究只參看 MOEPSO 的 G 值來和其他演算法進行績效。表 5-5 是 ZDT
標竿問題中 G 值的平均值而圖 5-6 是其 G 值的平均值的直條圖。但是圖 5-6 可以看到 ZDT1
和 ZDT2 在非臣服解對柏拉圖解的趨近性上， WFA4MC 的成效較雖然較 MOEPSO 差，但是
相對於 AMOPSO 和 NSGA-Ⅱ兩種演算法和 MOEPSO 的差異，WFA4MC 和 MOEPSO 的差異
是相對較小的。 
表 5-5 WFA4MC和三種啟發式演算法收斂距離(G)的平均值 
標竿問題 WFA4MC(LM) WFA4MC(OM) AMOPSO NSGA-Ⅱ MOEPSO 
ZDT1 0.0004 0.0004 0.0215 0.0243 0.0002 
ZDT2 9.71E-05 9.88E-05 0.0083 0.0214 9.43E−05 
ZDT3 0.0002 0.0002 0.0058 0.0126 0.0005 
ZDT4 0.0002 0.0002 0.0224 0.0217 0.0185 
ZDT6 0.0009 0.0010 0.0167 0.0195 0.0177 
ZDT3、ZDT4和ZDT6問題的求解績效表現上，WFA4MC的G值明顯較AMOPSO和NSGA-Ⅱ優
越，甚至優於MOEPSO。可以看出WFA4MC依然有機會與多群體解代理人演算法一樣有較高
的機會搜尋到逼近柏拉圖解的非臣服解。由以上數據資料可說明在大部分的問題中，對非臣服
解的趨近性也勝於AMOPSO、NSGA-Ⅱ和MOEPSO。 
100 
水流在分流或移步時，為能有效率地朝柏拉圖解移動，除了參看水流和母水流的資訊外，
也藉由現有非臣服解的參與，讓水流的位置向量作為微量變動，使產生的解能往目前非臣服解
邁進。若是所有水流皆在非臣服解做鄰近搜尋，就會產生過多相似的非臣服解，因此藉由降水
防止水流位置過於集中，讓水流可以廣域流動。 
兩種匯流方法 WFA4MC(OM)和 WFA4MC(LM)經過實驗後，證明 WFA4MC(LM)雖然可
以節省不必要的多餘運算，得到較逼近柏拉圖前緣線解的非臣服解，但是在涵蓋度的估計上，
WFA4MC(OM)對於解的涵蓋度評估較 WFA4MC(LM)準確。因為有時水流彼此的位置變數極
為相近但是在目標函數值空間的分布上位置極為分散，因此在解的分散性上，WFA4MC(OM)
會略勝於 WFA4MC(LM)。 
WFA4MC 的非臣服解在分散性上有相當好的表現，這是由於水流在分流時會在不同的範
圍內，抽出一值作為該位置的變數，能產生較多樣的解。加上匯流作業會防刪除相似的解節省
運算資源，增加了非臣服解的廣度。 
WFA4MC 以 WFA 為基，針對連續型多目標問題的求解環境來規劃演算流程，經實驗驗
證 WFA4MC 所求的非臣服解有極佳的分散性及不錯非臣服解趨近性，顯示 WFA 可用於求解
連續型多目標問題 
5. 參考文獻 
1. J. Andersson and P. Krus, "Multiobjective Optimization of Mixed Variable Design Problems 
Evolutionary Multi-Criterion Optimization." vol. 1993, 2001, pp. 624-638. 
2. F. C. Yang and Y.P. Wang, "WATER FLOW-LIKE ALGORITHM FOR OBJECT GROUPING 
PROBLEMS," Journal of the Chinese Institute of Industrial Engineers, vol. 24, 2007, pp. 475-488. 
3. A. Kaveh and K. Laknejadi, "A novel hybrid charge system search and particle swarm optimization 
method for multi-objective optimization," Expert Systems with Applications, vol. 38, 2011, pp. 
15475-15488. 
4. E. Zitzler, K. Deb, and L. Thiele, "Comparison of Multiobjective Evolutionary Algorithms: Empirical 
Results," Evol. Comput., vol. 8, 2000, pp. 173-195. 
5. C. Shih-Yuan, S. Tsung-Ying, H. Sheng-Ta, and L. Cheng-Wei, "Cross-searching strategy for 
multi-objective particle swarm optimization," in Evolutionary Computation, 2007. CEC 2007. IEEE 
Congress on, 2007, pp. 3135-3141. 
6. D.-b. Chen, F. Zou, and J.-t. Wang, "A multi-objective endocrine PSO algorithm and application," 
Applied Soft Computing, vol. 11, 2011, pp. 4508-4520. 
7. D. A. V. Veldhuizen, "Multiobjective evolutionary algorithms: classifications, analyses, and new 
innovations," Air Force Institute of Technology, 1999. 
8. E. Zitzler, L. Thiele, M. Laumanns, C. M. Fonseca, and V. G. da Fonseca, "Performance assessment of 
multiobjective optimizers: an analysis and review," Evolutionary Computation, IEEE Transactions on, 
vol. 7, 2003, pp. 117-132. 
9. K. Deb, "Multi-objective genetic algorithms: Problem difficulties and construction of test problems," 
Evol. Comput., vol. 7, 1999, pp. 205-230. 
10. X. Li, "A non-dominated sorting particle swarm optimizer for multiobjective optimization," presented at 
the Proceedings of the 2003 international conference on Genetic and evolutionary computation: PartI, 
Chicago, IL, USA, 2003. 
11. S. Huband, P. Hingston, L. While, and L. Barone, "An evolution strategy with probabilistic mutation for 
multi-objective optimisation," in Evolutionary Computation, 2003. CEC '03. The 2003 Congress on, 2003, 
pp. 2284-2291 Vol.4. 
12. P. K. Tripathi, S. Bandyopadhyay, and S. K. Pal, "Adaptive mufti-objective particle swarm optimization 
algorithm," in Evolutionary Computation, 2007. CEC 2007. IEEE Congress on, 2007, pp. 2281-2288. 
13. B. Yagmahan and M. M. Yenisey, "A multi-objective ant colony system algorithm for flow shop 
scheduling problem," Expert Systems with Applications, vol. 37, 2010, pp. 1361-1368. 
 1 
國科會補助專題研究計畫項下出席國際學術會議心得報告 
日期：101年 10月 4日 
 
一、參加會議經過 
本次與會學者專家發表論文約 150篇，分由三天兩個場地、上下午各一
場次發表。因帛琉本地並無高等學術機構，故無學者參與。與會學者、學生
泰半來自國內；少數來自亞洲其他國家；如俄羅斯、香港、泰國、馬來西亞
等。本人發表的 A2場次，安排有七篇文章。全部作者都蒞臨發表。當天參與
的學者人數約在 15來位左右。宣讀論文會後，有三位提出問題相互討論，氣
氛熱絡。會後主持人宣布本人該篇論文榮獲本會議 Best Paper Award。由主
持人頒發獎狀一紙並合影留念。 
二、與會心得 
計畫編號 NSC 98-2221-E-002 -066 -MY3 
計畫名稱 仿水流萬用啟發式優化演算法 
出國人員 
姓名 
楊烽正 
服務機構及
職稱 
台大工業工程學研究所 
副教授 
會議時間 
101年 7月 13日至 
101年 7月 17日 
會議地點 
帛琉共和國 
柯洛州,柯洛市 
會議名稱 
(中文) IAM 2012, 創新與管理國際研討會 
(英文) IAM 2012, International Conference on Innovation 
and Management  
發表論文 
題目 
(中文)創新的護士公帄性排班法 
(英文) Feng-Cheng Yang and Wei-Ting Wu, 2012, 
“Innovative Nurse Scheduling Method for Impartial 
Schedules,” Proceedings of IAM 2012, The International 
Conference on Innovation and Management, July 15-18, 
Koror, Republic of Palau. 
 IAM 2012 
International Conference on 
Innovation and Management 
Date: July 15‐18, 2012    Venue: Republic of Palau 
 
 
Acceptance Letter 
 
Dear Feng‐Cheng Yang, Wei‐Ting Wu: 
 
It  is our pleasure  to  inform you  that your paper has passed  through  the 
review  process  and  been  accepted  by  the  IAM2012.  This  is  the  formal 
acceptance  letter  of  your  paper  submission,  "Innovative  Nurse  Scheduling 
Method for Impartial Schedules” (Paper ID: P0216). 
 
Thanks  for your participation and contributing to  IAM2012  in Republic of 
Palau. 
 
 
 
 
 
Sincerely, 
 
 
Kuang Hui Chiu 
Conference Chair 
 
Feng-Cheng Yang and Wei-Ting Wu 
International Conference on Innovation and Management, Republic of Palau, July 15-18, 2012. 
1. Introduction 
Scheduling problems for ordinary employees are to find pertinent or fixed working 
schedules that can evenly and fairly distribute the manpower to the routine jobs or tasks. 
Usually, the schedule is stable since the employment has a relatively stable working schedule 
and routine. In this case, most employees work on day shifts in week days and rest on 
weekends. In contrast, the nursing job in hospitals is quite dynamic, shifting, and in particular 
day-and-night. Nurses on the same care or attention unit need to evenly share the workload of 
the unit day and night, week days or weekends. 
Nowadays, the nurse scheduling is usually a routinely, challenging, and laborious task 
for the head or chief nurse in a nursing unit. Complaints, scores, and criticisms on the 
schedule maker usually dominate the compliments once a schedule is announced. To evenly 
and fairly distribute the workload and impartially granting leave request for the nurses in a 
nursing unit, an optimal and automatic scheduler is required. The goal of this article is to 
define a complicated nurse scheduling problem in a domestic hospital and seek for 
developing a meta heuristic algorithm based method that can generate impartial and optimal 
schedules. 
 
2. Literature Review 
Dowsland (1998) studied a variety of scheduling requirements on nurse scheduling 
problems including several critical criteria applied to day and night shifts. Burke (1999) has 
proposed several solving models and methods for nurse scheduling problems. His work 
including solving systems had been posted on the Web for benchmarking and tests. Dowsland 
and Thompson (2000) proposed a three-stage solving method to deal with the complicated 
problem. The first stage treats the human resource requirements as a Knapsacks Problem to 
insure resource fulfillments. Then Tabu Search method is applied in the second stage to yield 
a preliminary schedule for day and night shifts. The final stage further distributes the day 
shifts into daylight and evening shifts.  
Li and Aickelin (2006) adopted and enhanced the three-stage method by using the 
Bayesian Optimization Algorithm for finding the schedule in the second stage. They used 
four scheduling rules to generate feasible schedules and showed numerical results of 52 
testing cases. Burke et al. (2007) proposed a Time Variable Depth Search method 
implemented in C# programming language. The achieved numerical results on benchmarks 
outperformed others. Their models and systems had been posted on the Web for 
benchmarking. Chiaramonte (2008) proposed a CNR algorithm that deploys agents for nurses 
to bid the leaves and shifts. A preliminary schedule is generated first and then negotiations 
between agents are started until all of the nurses are satisfied with their schedule. Brucker et 
al. (2010) investigates an adaptive constructive method for solving nurse rostering problems. 
Greedy local search was conducted during and after the roster construction. 
Feng-Cheng Yang and Wei-Ting Wu 
International Conference on Innovation and Management, Republic of Palau, July 15-18, 2012. 
In normal cases, an employee should have eight day-offs per month. However, a nursing 
unit might ask a nurse to forfeit the day-off to cover unexpectedly increased caring needs. 
Conversely, a nurse might be forced to take more days off for a low need of caring service in 
the unit. Sometimes, the nurse might have a leave plan granted and the number of leaves 
exceeds eight in a month. Therefore, the numbers of exceeding or shorting leaves should be 
cumulated and referenced in monthly scheduling. Let i  be the cumulated shortages of 
leaves for nurse i . If the value of i is positive, the nursing unit owe the nurse i day-offs. 
Otherwise, the nurse is in debt of - i working days. Both of i  and i  for all nurses should 
be updated in advance before scheduling for the next month.  
There are three working shifts operated in the nursing unit: day shift from 8 am to 5 pm, 
evening shift from 3 pm to 11 pm, and night shift from 11 pm to 8 am. Let these shits be 
sequentially indexed by 1, 2, and 3;  1, 2,3K   be the set of all of the shifts. Since working 
on the night shift would likely to dislocate one’s biological clock, it is regarded as an 
unfavorable choice. A good scheduler should assign night shifts to nurses impartially. 
Fortunately, the monthly shift taken by a nurse has been predetermined based on his/her 
seniority and the regulations of the hospital. Assume that the dedicated shift of nurse is i , 
then i K  . Assume that there are q days in the scheduling month and  1,2, ,Q q   is the 
set of these indexed days. Let weekdays be indexed sequentially from Monday. Assuming 
that jR is the weekday index of day j , then  1, 2, ,7jR   . Therefore, day j  is Monday if
1jR  or Sunday if 7jR  . 
Before scheduling, nurses submit their leave plans for the next month by filling up a 
leave request on the day planned for leave. The request is classified into 11 cases, indicated 
by indices starting from 1 to 11. Among them, case 1 is for a regular leave; 2 is annual 
vocation; 3 is medication leave; 4 is wedding vocation; 5 is maternity leave; 6 is miscarriage 
medication; 7 is funerary leave; 8 is personal leave; 9 is official affair leave; 10 is official 
injury; and 11 is official in-service training. Let    0 1, 2, ,11U     be the set of all cases of 
the leave request and the case of no leave request, which is represented by 0. Therefore, the 
leave request on day j  of nurse i  is ijH  and ijH U .  
Before the scheduling the nursing resource required on each day and each shift is known 
or predetermined. Let jk  be the number of nurses needed on shift k of day j , the number of 
nurses allowable for absence on day j  is 3 1 jkkp  . When the number of nurses 
submitting for a leave on day j exceeds the allowable number, the head nurse or the scheduler 
will decide who takes the leave, based on the request case of ijH  and the recorded values of
i . Let ijx  be the scheduling result for nurse i on day j . Initially ijx  are all set to -1. In the 
stage of leave granting, ijx  is set to 0 if nurse i  has planned a leave on day j and the request 
is granted. Otherwise, ijx remains -1. Therefore, a rule-based leave-granting algorithm is 
proposed to thoroughly refer values of i , i , and ijH  to approve or decline the leave 
requests. 
Feng-Cheng Yang and Wei-Ting Wu 
International Conference on Innovation and Management, Republic of Palau, July 15-18, 2012. 
where day j is scheduled for a leave but the days before and after j are all working days. On 
the other hand, if a two-day leave is broken by a working day, the leave is interrupted and is 
unable to bring enough relaxation to the nurse. Therefore, the count of a working day 
surrounded by two leaves is 
    4 1 1; =2,3,..., 1 0 0 0ij i j i ji j qf Count x x x        , (4) 
where the working day j interrupts the two-day leave. 
From the viewpoint of the nurse, the best schedule is the one that meets all their leave 
requests. The approval ratio of the leave request is the number of granted leaves divided by 
the number of total requests. Usually, a nursing unit has a targeted ratio for the head nurse or 
the scheduler to yield a schedule that has the approval ratio as closer as possible to the target. 
The difference between the targeted and the actual approval ratios to be minimized is  
 
 5
0 0
max 0.0,100
0
ij iji j
iji j
Count H x
f
Count H
  
 
            
. (5) 
Note that values of 1f  to 5f  are evaluated from a schedule and are then regarded as 
the minimization targets for the nurse scheduling problem.  
Hard Constraints 
A feasible schedule must satisfy daily nursing power requirements of the unit while not 
violating any regulation of the local labor law. Optimization techniques of soft computing 
typically do not treat hard constraints directly. Instead, the violating “degree” or “amount” is 
calculated or the violation instances are detected and counted to add penalty to the objective 
evaluation. The added value of penalty to the objective value is significant enough to 
downgrade the quality of the solution. The number of nurses dispatched to each shift on each 
day must equal to the prescribed number. The number of violations can be counted as 
  1 , ij jkj k iv Count Count x k     .  (6) 
Same as an ordinary labor worker, the workload of a nurse is legitimately confined by 
the labor law. Suppose the law or the hospital restricts the upper limit of the number of 
consecutive working days to D days for the nurse. A feasible schedule must assure that no 
any nurse is assigned with consecutive working days more than D days. The count of an 
occurrence that violates the D-day regulation is 
  2 , 1,...,, 1,2,..., 0ijj r r r Di r q D xCount Dv Count        , (7) 
where each combination of D consecutive days (day r to day r+D) is checked for count 
violations. In general, a nursing unit deploys fewer nurses to night shifts than evening or day 
shift, since caring service requirement is significantly reduced. Usually, junior nurses are 
assigned for night shifts since they are young, inexperienced, and in general unmarried. 
Feng-Cheng Yang and Wei-Ting Wu 
International Conference on Innovation and Management, Republic of Palau, July 15-18, 2012. 
1 1; ,ijB i j   
2 for  j←1 to q 
3  for  k←1 to 3 
4    
1,2, , i jki p
allowed Count k 

  

 
5    0 ;ij ii H k i    V  
6   if allowedV  
7    Sort nurses in V in descending orders of i and ascending orders of i  
8     
1 1 11 2
, ,... , , if 
k k k k k kv v v v v v
v v            V  
9     1 20; , ,...,ij allowedB i v v v     
10   else 
11    0;ijB i  V  
10   end if 
11  end for 
12 end for 
Notice that if the number of requests on a shift exceeds the number of leaves allowed, 
the nurses are sorted by their cumulated shortages of leaves and numbers of leave granted for 
request approving. The larger number of leave shortages and the lesser leave granted earns a 
higher priority for leave approval. Once B  is obtained, the item ijx in a given schedule x  
will not participate any GA operation if 0ijB  , since it has been granted a leave in advance.  
GA Population Initialization 
Let the set of chromosomes be  (1) (2) ( ), ,..., x x x , where size   is specified by the user. 
Operation Chromosome_Initialization() is designed to initialize the chromosome values to 
generate an initial schedule, whose details are listed as follows. 
Chromosome_Initialization  ( ), ,cρ x B  
1 for  j←1 to q 
2  Assignment_Shfits  ( ), , ,cj ρ x B  
3 end for 
Note that operation Assignment_Shfits() is iteratively executed to assign shifts for all of 
the days, whose processes are as follows. 
Assignment_Shfits  ( ), , ,cj ρ x B  
1 for k←1 to 3 
Feng-Cheng Yang and Wei-Ting Wu 
International Conference on Innovation and Management, Republic of Palau, July 15-18, 2012. 
Mutation  ( ) ˆ, , , ,c ρ x B x  
1    1 2, ,..., , Random ; 1,2,...,ma a a a Q m   A  
2 for j←1 to q 
3  if jA  
4   Assignment_Shfits  ˆ, , ,j ρ x B  
5  else  
6   
( )ˆ , 1,2, ,cij ijx x i p     
7  end if 
8 end for 
Line 4 reassigns the schedules of the randomly selected days, while others are directly 
copied from parent to offspring. 
Selection Operation 
Our selection targets include the parent and offspring chromosomes. To exercise 
different strategies for performance evaluations, four selection modes are proposed: (1) 
Deterministic, (2) Stochastic, (3) Hybrid, and (4) Grouped Stochastic modes. Suppose the 
aggregated set of parent and children chromosomes is  1,2,...,mG , where m  and 
chromosomes are represented by their indices. Let cT be the objective value of chromosome c 
in G, where1 c m  . Since the optimization goal is to minimize the objective value, the 
fitness of chromosome c is therefore defined as the inverse of cT . In the first selection method, 
the Deterministic mode, chromosomes with the highest fitness are directly selected. The 
algorithm used to obtain the set of chromosomes U  for next generation is as follows. 
Deterministic_Selection() 
1 Sort chromosomes in G in descending orders of their fitness as 
 
1
1 2
1 1, ,..., , , 1, , 1
c c
m
G G
G G G c m
T T 
        G 
 
2  1 2, ,...,G G G   U
 
Among these selection modes, a stochastic method is a probability proportional selection. 
Let operation Stochastic_Selection(U,n) be the operation that selects n chromosomes from U 
based on their probabilities, where U is likely a subset of G. The selection probability for 
chromosome c in set U is computed from the objective value as 
1 , 1, 2, ,1c
c c
c
p c
T
T  
  U
U . (12) 
The operation details of the stochastic selection are as follows. 
Stochastic_Selection  ,nU  
1 
,1c
c c
c
np c
T
T  
   U
U
 
Feng-Cheng Yang and Wei-Ting Wu 
International Conference on Innovation and Management, Republic of Palau, July 15-18, 2012. 
10  
 
 
 
(1)
(2)
(3)
Stochastic _ Selection , if 0 0.6,1
Stochastic _ Selection , else if 0.6 0.9,1
Stochastic _ Selection ,otherwise,1


      
G
U U G
G
 
11 end for  
Lines 4 to 6 divide the chromosome set into three groups based on their objective 
achievements. Notice that the superior group rounds in 60% of the chromosomes, while 
ordinary group takes 30% and inferior group takes 10%. In addition, a stochastic group 
selection process is conducted prior to the chromosome selection.  
Stopping Conditions 
Various performance evaluations or numerical result comparisons are conducted with 
different stopping conditions. Iteration limits, elapsed CPU execution time, and number of 
objective function calls are provided to exit the evolution process. At the end of the GA 
evolution, the best solution (schedule) so far is exactly the best chromosome so far, * *ijx   x . 
Once the schedule is applied to the coming month, the counts of planned leaves granted i and 
cumulated shortages of leaves i for nurses i will be subsequently updated as 
*1,if  0 0
,
,otherwise
i ij ij
i
i
x H
i
 
     
;   *8 0 ,i i ijjCount x i      
.
 
 
4. Numerical Tests and Result Discussion 
The proposed method has been implemented in a software system and the scheduling 
problem of a nursing unit of a domestic hospital has been testes. The developed system, 
called GA-Based Impartial Schedule Targeted Nurse Scheduling System (ISTNSS for short), 
was implemented in C# programming language on MS .Net platform. To generate an optimal 
schedule for the coming month, the system requires updated information about nurses, 
requirements of the nursing unit, and chronologic data. This information may be directly 
accessed from databases or separately entered by the user.  
Two kinds of numerical tests were conducted. The first test is to identify which selection 
mode is the best among the four modes. Then, the best mode was applied to the second kind 
of tests that compare the generated schedules from ISTNSS, Variable Depth Search, and 
Modified Hill Climbing methods.  
Numerical Sample 
The targeted nursing unit consists of 15 nurses, whose servicing attributes are listed in 
Table 1. Table 2 outlines the weekly nursing manpower requirements, which will be applied 
to obtain jk , and Table 3 illustrated the leave requests filed by the nurses for the coming 
month. 
Feng-Cheng Yang and Wei-Ting Wu 
International Conference on Innovation and Management, Republic of Palau, July 15-18, 2012. 
seconds. In the first test, ten runs were executed for each selection mode and the best and 
averaged objective values obtained are listed in Table 4. 
 
Table 4. Objective values obtained from 10 runs on each selection mode. 
 Deterministic Stochastic Hybrid Grouped-Stochastic 
Best Objective 37 143 39 112 
Objective Average 45.2 236.6 56 197.6 
 
Figure 1 illustrates the progress of the objective values of a run in each mode. 
Apparently, the deterministic mode outperforms others and was then used in the second kinds 
of tests. The second part of the numerical tests used the same sample data to execute our 
method and Variable Depth Search method for ten runs each. Since the Modified Hill 
Climbing method is a deterministic heuristic method, only one run was executed. Objective 
values obtained are listed in Table 5 for comparison.  
Notably, the results generated from our method (ISTNSS) are better than others. Since 
the objective values obtained in our method never exceed 100, which means no any 
constraint is violated since the penalty value M for constraint violation was set to100. Table 6 
postulates the best schedule with the minimal objective value 37, among the 10 runs of our 
method. 
 
 
Figure 1. The objective value progress for different selection modes.  
 
Evaluating this schedule one may found 1 2 3 4 50, 7, 23, 7, 0f f f f f     and
0, 1, 2, ,5sv s   . The objective value is simply 2 3 4 7 23 7 37f f f      . Although this 
seems to be a good schedule, it is not a perfect one. There are still 7 nurses cannot have at 
least one full weekend leave, seven working shifts breaking two successive leaves and 23 
single-day leaves between two working shifts. Nevertheless, the ISTNSS has tried to leverage 
0
50
100
150
200
250
300
350
400
0 50 100 150 200 250 300 350
O
bj
ec
tiv
e 
V
al
ue
菁英篩選
輪盤篩選
混合篩選
分群輪盤篩選
Deterministic
Stochastic
Hybrid
Deterministic
Stochastic
Hybrid
Grouped‐stochastic
Feng-Cheng Yang and Wei-Ting Wu 
International Conference on Innovation and Management, Republic of Palau, July 15-18, 2012. 
   j 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
jR  2 3 4 5 6 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7 1 2 3
i i i i i        
*
ijx
     
13 3 3 -1 14 3 3 3 0 0 3 3 3 0 3 3 3 0 0 0 3 3 3 3 0 0 3 0 3 3 0 0 0 3 3
14 4 3 -1 5 3 3 3 3 3 0 0 3 3 3 3 0 3 3 3 3 3 0 0 3 3 0 3 3 3 3 3 3 0 0
15 1 3 -2 3 0 0 0 3 3 3 3 0 3 0 0 3 3 3 3 0 0 3 3 3 3 3 3 0 0 3 3 3 3 3
 
References 
Azaiez, M. & Al Sharif, S. (2005). A 0-1 goal programming model for nurse scheduling. 
Computers and Operations Research, 32(3), 491-508. 
Brucker, P., Burke, E. K., Curtois, T., Qu, R. & Vanden Berghe, G. (2010). A shift sequence 
based approach for nurse scheduling and a new benchmark dataset. Journal of 
Heuristics, 16(4), 559-573. 
Burke, E., Curtois, T., Qu, R., & Berghe, G. (2007). A time pre-defined variable depth search 
for nurse rostering. Computer Science Technical Report, No. NOTTCS-TR-2007-6. 
University of Nottingham, Jubilee Campus, UK. 
Burke, E., Curtois, T., Qu, R., & Berghe, G. (2009). A scatter search methodology for the 
nurse rostering problem. Journal of the Operational Research Society, 61, 1667-1679. 
Burke, E., De Causmaecker, P., & Vanden Berghe, G. (1999). A hybrid Tabu search algorithm 
for the nurse rostering problem. Simulated Evolution and Learning, 187-194. 
Chiaramonte, M. V., & Chiaramonte, L. M. (2008). An agent-based nurse rostering system 
under minimal staffing conditions. International Journal of Production Economics, 114(2), 
697-713.  
Dowsland, K., & Thompson, J. M. (2000). Solving a nurse scheduling problem with 
knapsacks, networks and tabu search. Journal of Operational Research Society, 51(7), 
825-833. 
Dowsland, K. (1998). Nurse scheduling with tabu search and strategic oscillation. European 
Journal of Operational Research, 106(2-3), 393-407. 
Li, J. & Aickelin, U. (2004). The application of Bayesian optimization and classifier systems 
in nurse scheduling. In: Yao X et al. (Eds). Parallel Problem Solving from Nature. 
Springer Lecture Notes in Computer Science, 3242, 581-590.  
Yih, Y. (2010). Handbook of Healthcare Delivery Systems. CRC Press. 
98 年度專題研究計畫研究成果彙整表 
計畫主持人：楊烽正 計畫編號：98-2221-E-002-066-MY3 
計畫名稱：仿水流萬用啟發式優化演算法 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 3 3 100%  
研討會論文 2 4 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 6 6 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 1 1 100% 
人次 
 
期刊論文 0 2 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 3 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
