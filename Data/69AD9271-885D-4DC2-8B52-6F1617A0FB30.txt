3 
 
 
目錄 
一、中、英文摘要 ……………………………………………………………  1
二、研究計畫之背景與目的 …………………………………………  3 
三、研究方法 ………………………………………………………………………  5 
 3.1 SiP Partitioning 
  3.1.1 Thermal Model 
  3.1.2 Problem Definition 
  3.1.3 ILP Based Approach 
   3.1.3.1 Evaluate Bonding Wire Length 
   3.1.3.2 Evaluate Number of I/O Pads 
   3.1.3.3 Evaluate the Temperature of SiP 
   3.1.3.4 Final ILP for SiP Partitioning 
  3.1.4 Simulated Annealing Based Approach 
  3.1.5 Experimental Results 
3.2 3-D IC Partitioning 
  3.2.1Statistical Wire Length Estimation Model 
  3.2.2 Thermal Models 
  3.2.3 Problem Definition 
  3.2.4 ILP Based Approach 
   3.2.4.1 Uniqueness and Layer Area Constraints 
   3.2.4.2 Evaluate On-chip Wire Length 
   3.2.4.3 Evaluate Number of TSVs 
   3.2.4.4 Thermal Constraint Using Thermal Models 
  3.2.5 Experimental Results 
四、計畫成果自評 …………………………………………………………… 19 
五、參考文獻…………………………………………………………………………19
5 
 
We note that in SiP partitioning, there is one thing completely opposite to the standard 
graph/hypergraph partitioning problem. The standard formulation of partitioning typically targets 
to minimize the number of cut nets. As such a standard partitioning tool will favor the partition in 
Fig.2 instead of Fig.3 because there is only one signal net being cut across multiple dice in Fig.3 
while there are two signals being cut in Fig.2. Thus, in SiP partitioning we should not be 
minimizing the number of nets being cut but to minimize the required number of inter-die 
connections. 
 
(3) Aerial Congestion of Vertical Interconnection 
Minimizing the total vertical interconnection length is necessary but not sufficient. Imagine that 
there are many vertical interconnections passing through a particular horizontal plane, and there 
may not be enough clearance between them. In this case, realizing these vertical interconnections 
will be much harder. What’s more, this can also cause noise problem during operation. Therefore, 
aerial congestion of vertical interconnection is also one of the important considerations in SiP 
partitioning. 
 
(4) Thermal Consideration 
Thermal problems are a major concern for SiP design [4-6]. Thermal problems get much more 
serious in 3-D structure than in the 2-D case due to the vertical stacking of multiple dice. A good 
partitioning can lead to a better and more even temperature distribution among the dice that 
alleviates this problem.  
 
To have a good SiP partitioning result, we must take all these differences into consideration. In this 
paper, we propose a multi-objective integer linear programming (ILP) model, which can optimize total 
pad number and total inter-die connection length under specific temperature constraints, to solve the 
SIP partitioning problem. For comparison, we also develop a simulated-annealing approach based on 
the same problem formulation. Since design of 3-D IC is very similar to design of SiP, we even derive 
a ILP-based approaches to do 3-D IC partitioning effectively. 
 
三、研究方法 
3.1 SiP Partitioning 
In this section, we will first describe our thermal model since we need to consider temperature of dice 
during SiP partitioning. Second, a problem definition is proposed, and then we can start developing our 
ILP model to solve SiP partitioning problem. Third, a simulated- annealing approach based on the same 
problem formulation is briefly described. At the last subsection, we will show the experimental results. 
 
3.1.1 Thermal Model 
In general, the current thermal models can be divided into three kinds, (i) numerical computing 
methods such as finite element method (FEM) [19] and finite difference methods (FDM) [20,21], (ii) 
compact resistive network [22] and (iii) simplified closed-form formula [14,16]. Among them 
FEM-based and FDM-based method is the most accurate and time-consuming, closed form formula is 
the fastest but inaccurate. We chose to use the close form formula as [14]. There are two reasons. One, 
if we want to estimate temperature accurately, we need the information about the related position of 
blocks. But, we do not know the information of the related position of blocks in a partitioning phase. 
We only knew that each block is assigned to which layer. Thus, we cannot use the thermal models 
[19-22] in a partitioning phase. Two, we hope to get a good partitioning fast but thermal models [19-22] 
are very time-consuming. Therefore, a closed form formula is suitable for SiP partitioning. In the 
thermal model of [14] (see figure 4), it only considers the heat flow in the vertical direction. In the 
thermal model of [14], each layer has the same area. However, in SiP, each layer has different area and 
higher layer has less area than lower layer (see figure 5). The modified closed form can be expressed in 
the following equation 
(1)   
1
∑ ∑
= =
⎥⎦
⎤⎢⎣
⎡
⎟⎟⎠
⎞
⎜⎜⎝
⎛⋅=Δ
l
i
L
ik k
k
il A
PRT  
△Tl denotes the temperature rise above ambient temperature of the l-th layer. Ri denotes the thermal 
resistance between the i-th and (i-1)-th layer. Pk denotes the power dissipation in the k-th layer. Ak 
denotes the area of layer k. 
 
7 
 
 
Figure 6: Imaginary planes. 
 
Next, we make an assumption about the bonding wire connection mode: 
Assumption 1: For a netj, there exists a bonding wire from the highest layer that any block of netj 
resides to the second highest layer that any block of netj resides, and a bonding wire from the second 
highest layer that any block of netj resides to the third highest layer that any block of netj resides, etc. 
 
According to the above assumption, we can now explain how to model the problem of computing total 
bonding wire length of SiP. We will define some notations to help us to model this problem: 
⎩⎨
⎧=
otherwise.0,
layer on  is block  if1,
,
ki
x ki  
⎪⎩
⎪⎨
⎧
=
otherwise.0,
. planeimaginary    
 aboveor on  is net  ofblock any  if1,
k
j
Pj,k  
⎪⎩
⎪⎨
⎧
=
otherwise.0,
.imaginary    
 below is net  ofblock any  if1,
k
j
Q j,k  
k planeimaginary rough         th
 pass  wiresbonding ofnumber   =kC  
 
Using the variables defined above, we can evaluate the bonding wire length by the following formula: 
(2)    length  bonding- wireTotal
L
1k
∑
=
= kC  
where 
( )∑
=
−+=
N
j
kjkjk QPC
1
,, 1  
∑
≥
∈≥
kk
jkikj netiXP
'
' ,,,  
∑
<
∈≥
kk
jkikj netiXQ
'
' ,,,  
 
3.1.3.2 Evaluate Number of I/O Pads 
Besides the variables defined in the previous subsection, we have to define two new variables to model 
this problem: 
⎩⎨
⎧=
otherwise.0,
layer on  is jnet  ofblock any  if1,
,
k
E kj  
klayer on  jnet           
for  inserted pads I/O ofnumber   , =kjI  
To evaluate number of I/O pads, an assumption about I/O pad distribution mode is made: 
Assumption 2: 
(1) If a layer does not contain any block of netj, no I/O pad is allocated for netj in that layer. 
 
9 
 
∑
<
∈≥
kk
jkikj netiXQ
'
' ,,,  
( )22 ,,)1(,, −++≥ + kjkjkjkj QEPI  
0, ≥kjI  
 
The objective is to minimize the total wire-bonding length and total I/O pad count. α and β are user 
defined parameters. 
 
3.1.4 Simulated Annealing Based Approach 
The second partitioning method we implemented is based on simulated annealing (SA). We define two 
kinds of operations to perturb a partitioning result: 1) Swap two blocks in two different layers and 2) 
Select a block from a layer and move it to another layer. When we perform these moves, we must 
guarantee the area constraint of each layer is not violated. 
 
The objective of SIP partitioning problem is to minimize the total pad number, total bonding 
wire-length and the temperature of the highest layer, so the cost function is define as below. 
(6)   CBACost ⋅+⋅+⋅= γβα  
Where A is the summation of normalized bonding wire length of each net, B is the summation of 
normalized pad count, and C is the normalized temperature of the highest layer. α,β, and γ are user 
defined parameters. 
 
3.1.5 Experimental Results 
In this section, we compare the results of SiP partitioning using three different methods: hmetis , ILP 
and SA. Then we will analyze the results and give some comments in using two different methods to 
achieve our goal. The algorithm of SA based method is implemented in C++ language on a Sun 
workstation with a Sun sparcv8 CPU and 1GB memory. We use CPLEX as our ILP solver and ILP 
solver is executed on a Sun workstation with a Sun sparcv8 CPU and 1GB memory. We tested our two 
methods on GSRC benchmarks [23]. The GSRC benchmarks information are listed on a Table 5.1. 
Table 5.2-Table 5.4 show the 3-layers partitioning results of the three benchmarks respectively. Table 
5.5-Table 5.7 show the 4-layers partitioning results of the three benchmarks respectively. 
 
GSRC benchmark N100 N200 N300 
#blocks 100 200 300 
#nets 885 1585 1893 
#pins 1873 3599 4358 
External I/O 334 564 569 
Area 179501 175696 273170
Table 5.1: GSRC Benchmarks 
 
For each case, we ran hmetis 50 times and ordered the dies from the smallest to the largest each time to 
get the bonding wire length. The best bonding wire length out of the 50 trials are reported in the 
wire-bonding length column of Table 5.2 - Table 5.7. In Table 5.2-Table 5.7, we also display the result 
of comparison of total I/O pad count, and temperature of highest layer. As for the ILP method, we set a 
time bound of 30 minutes (CPU time) when solving each ILP. The best results obtained within 30 
minutes are reported in Table 5.2 -Table 5.7. As for the SA method, we report the best solution out of 
the 50 trials in Table 5.2 - Table 5.7. 
 
About the power information of blocks, we use the power values in [23]. As we ran hmetis 50 times 
and select the best bonding wire length, we also simultaneously compute total I/O pad count and 
temperature of highest layer for the solution with the best bonding wire length. In Table 5.2 - Table 5.7, 
ILP(1)’s objective function is to minimize total wire bonding length under the thermal constraint, 
ILP(2)’s objective function is to minimize the total I/O pads under the thermal constraint and ILP(3)’s 
objective function is to minimize the sum of total bonding wire-length and total I/O pads according to 
user defined weights of bonding wire-length and I/O pads individually. The thermal constraint of 
ILP(1), ILP(2) and ILP(3) is given according to highest layer temperature of hmetis partitioning result. 
Area constraint of each layer of ILP is given according to 1.05 time of area of each layer of hmetis 
partitioning result. 
 
We find that the total wire bonding length of ILP(1) is the best. But the total I/O pads of ILP(1) is more 
than hmetis. Because ILP(1) uses more I/O pads, ILP(1) has higher probability to make on chip 
wire-length longer than hmetis. Because we want to use fewer I/O pads and get shorter on-chip wire 
length than hmetis, we try to only minimize I/O pads ( ILP(2)). But we find that ILP(2)’s result is bad 
compared with ILP(1). (see the I/O pads column of Table 5.2 - Table 5.7). We analyze this result and 
11 
 
 Bonding wire length I/O pads temperature
hmetis 1564 2238 65.6079 
ILP(1) 1556 2376 61.65 
ILP(2) 1927 2638 63.84 
ILP(3) 1800 2604 63.5857 
SA 1739 1794 66.173431
Table 5.4: N300 3-layer result comparison of hmetis, ILP and our SA 
 
 Bonding wire length I/O pads temperature
hmetis 1261 1162 79.0092 
ILP(1) 960 1250 72.85 
ILP(2) 1407 1354 76.8314 
ILP(3) 995 1242 77.566 
SA 1029 878 80.7784 
Table 5.5: N100 4-layer result comparison of hmetis, ILP and our SA 
 
 Bonding wire length I/O pads temperature
hmetis 2053 2206 78.9743 
ILP(1) 1986 2450 73.54 
ILP(2) 2394 2596 77.8182 
ILP(3) 2354 2650 77.6566 
SA 2009 1834 81.5401 
Table 5.6: N200 4-layer result comparison of hmetis, ILP and our SA 
 
 Bonding wire length I/O pads temperature
hmetis 2272 2362 83.2483 
ILP(1) 2078 2674 78.40 
ILP(2) 2925 3822 79.1668 
ILP(3) 2563 3036 79.1973 
SA 2446 2282 82.8939 
Table 5.7: N300 4-layer result comparison of hmetis, ILP and our SA 
 
3.2 3-D IC Partitioning 
Since 3-D IC partitioning problem is similar to SiP partitioning problem in many aspects, we also 
propose a ILP based approach to solve 3-D IC partitioning problem. One major difference between 3-D 
IC and SiP is that 3-D IC use through-the-silicon vias (TSVs) to connect blocks on different layers 
rather than bonding wires used in SiP design. Thus, the objective of our 3-D IC partitioning method is 
to minimize on-chip wire length and number of TSVs under thermal consideration. 
 
In this section, we will first describe the wire length estimation model used in our partitioning method. 
Second, we explain two different thermal models for temperature estimation. Third, a problem 
definition is proposed, and then we can start developing our ILP model to solve 3-D IC partitioning 
problem. At the last subsection, we will show the experimental results. 
 
3.2.1 Statistical Wire Length Estimation Model 
As the positions of blocks remain unknown during the partitioning stage, the total wire length cannot 
be calculated without packing. [24] proposed a statistical wire length estimation model for inter-layer 
partitioning. We use this model for estimating the wire length during 3-D partitioning stage. 
 
The total wire length depends on the positions of connected pins, which are decided by the position of 
each block. As the horizontal positions of all blocks are not decided during the partitioning stage, we 
cannot calculate the wire length between blocks accurately. To cope with this problem, [24] proposed a 
statistical wire length estimation model to calculate the average distance between interconnected pins 
and the expectation of wire length in a statistical way. For two interconnected blocks, there are two 
cases for them. One is they are on the same layer as shown in figure 7 (a), and the distribution becomes 
dependent because they cannot overlap. The other is they are on the different layers, and they may 
overlap as shown in figure 7 (b). 
 
Figure 7(a): Bi and Bj on the same layer 
 
13 
 
With the same method, the average Manhattan distance between connected pins on them is 
(11)    
3
252
3
2
2
2
121
2
11
2 W
WWWWWL +−+=  
 
3.2.2 Thermal Models 
We surveyed the existing literature on thermal analysis of 3D integrated circuits [14-18]. 
 
In practice, there are two scenarios of die-stacked 3-D IC as shown in figure 9 and figure 10. Figure 9 
shows a multi-die stack with a heat sink attached to the silicon substrate. The heat is conducted through 
the silicon substrate to the package and then to the ambient by a heat sink. The devices in each die will 
generate heat. Hence, each die acts as a heat source. The heat flow is from the top to the bottom 
because the heat sink is at the bottom. 
Cu + ILD
Cu + ILD
Cu + ILD
Cu + ILD
package
Heat Sink
Si_1
Si_2            
Si_(n-1)
Si_n
Si_3
R1
R2
Rn
T1
T2
Q1
Q2
Qn
heat flow
 
 
 
An equivalent thermal resistance network [14] can be constructed as shown on the right hand side in 
figure 9. It assumes that there is no heat removal from the top of the die-stack to the ambient. The 
temperature rise above the ambient temperature of active layer j (△Tj) is given by the following 
equation:  
(12)   
1
∑ ∑
= =
⎥⎦
⎤⎢⎣
⎡
⎟⎟⎠
⎞
⎜⎜⎝
⎛=Δ
j
i
D
ik i
k
ij A
QRT  
where Ri represents the thermal resistance between ith and (i-1)th layers , Qk  is the power dissipation of 
k th layer and Ai is the area of the ith layer. 
Package
Q1
Qj
Rhs
R1
Rj
Rpk
T1
Tj
primary
heat  flow
Secodary
heat flow  
 
 
 
An alternative package solution using ceramic ball grid array (CBGA) is shown in figure 10. In this 
case, the heat sink is located at the top. The bottom die is attached to the substrate with I/O bumps. This 
new scenario is helpful for heat dissipation because the I/O bumps between the bottom die and the 
substrate also provide a low thermal resistance path for heat removal. So the heat generated by the dies 
can flow to the ambient through both the heat sink at the top and the package at the bottom. This is 
quite different from the first scenario. The equivalent thermal resistance network can be constructed as 
on the right hand side of figure 10. 
 
A simple, one-dimensional heat transfer model for the multi-die stacking scenario in figure 10 is 
presented in [15]. It assumes uniform heat generation in the device layers and neglect heat spreading by 
assuming heat flow only normal to the device layers. Each strata and interface is characterized by the 
Figure 9: Heat sink attached to silicon substrate.
Figure 10: CBGA package with heat sink at the top.
 
15 
 
⎩⎨
⎧=
otherwise.0,
layer on  is block  if1, li
xil  
⎩⎨
⎧=
otherwise.0,
llayer  above is net ofblock any 1, j
jlP  
⎩⎨
⎧=
otherwise.0,
llayer  belowor on  is net ofblock any 1, j
jlQ  
⎪⎩
⎪⎨
⎧
=
otherwise.0,
nlayer    
at jblock  and mlayer at  iblock 1,
, jnimX  
lΔTl layer  ofambient  above rise re temperatu =  
IC D-3  theof re temperatumaximum max =T  
nlayer at             
is B and mlayer at  is B if B and B            
between distanceManhattan  average
jiji
, =jnimL
 
nlayer at  B and mlayer at  Bbetween               
distanceManhattan  horizontal estimated
ji
, =jnimEL
 
3.2.4.1 Uniqueness and Layer Area Constraints 
∑
=
=∀=
L
l
il BiX
1
,...,2,1,1  
A block can be assigned to one and only one layer. We use the above constraint to guarantee this 
nature. 
∑
=
=∀≤
B
i
iil LlAAX
1
max ,...,2,1,  
This constraint assures that the total area of the blocks assigned to layer l must be less than or equal to 
the maximum area of a layer. 
3.2.4.2 Evaluate On-chip Wire Length 
We re-write L1 and L2 to Lim,jm and Lim,jn from the equation 9 and equation 10 for our ILP formulation: 
23
2
,
jjiim
jmim
hwhwW
L
++++= [ ] [ ] (14)   
),max(3
),min(25),max(3 22
nm
nmnmm
WW
WWWWWW +−+  
where Wm and Wn are the widths of layer m and layer n. 
 
As the wire length-oriented floor planner tends to place blocks that have more interconnections 
together, the expected horizontal Manhattan distance between connected pins would be smaller than 
the average Manhattan distance between the uniformly distributed blocks within the die space. Based 
on the average Manhattan distance, we modify the formula for the estimated horizontal Manhattan 
distance between connected pins proposed in [24] to fit our ILP formulation: 
(1) if Bi and Bj are both on the layer m, 
 
(2) if Bi and Bj are on the layer m and layer n, respectively, 
 
where |N(Bi,Bj)| is the total number of connected nets between Bi and Bj, N(Bi,Bj) is the set of 
connected nets between them, and |Nk| is the number of terminals of net Nk. Here, we use 
1/(|N(Bi,Bj)|+1) to form the characteristic of wire length driven floorplanner which tends to place 
modules with more interconnections closer. The weighting factor |Nk|/2 is used to scale the impact by 
nets with different number of terminals. The estimated wire length of multi-pin net by the weighting 
17 
 
3.2.5 Experimental Results 
We implemented our algorithm by C++ programming language on a 4.3GHz Linux CentOS release 4.4 
workstation with 32G memory and used CPLEX to solve our ILP formulations. We applied our 
algorithm on GSRC benchmarks and set the searching time of CPLEX to 1800 seconds. The power 
dissipation of each block is assigned to the same value as [25]. The specifications of the benchmarks 
are shown in Table 4.1. 
 
GSRC benchmark N100 N200 N300 
#blocks 100 200 300 
#nets 885 1585 1893 
#I/O pads 334 564 569 
Area 179501 175696 273170
Table 4.1: GSRC Benchmarks 
 
We fed our layer assignment results to a 3-D floorplanner. The floorplans of all layers are generated 
using an SA engine with Sequence Pair [26] as the representation. Each block is assigned to a layer 
according to our 3-D partitioning result, and the blocks cannot be swapped between layers during 
floorplanning. Because our estimation just considers the interconnections between blocks, the modified 
3-D floorplanner excludes the connections between blocks and I/O pads as well. Here, we use the 
half-perimeter wire length (HPWL) as our wire length model. Note that our 3-D floorplanner is thermal 
unaware under fix-outline constraint. 
 
To compare the formulations with [24], we also implemented their formulations with ILP. The 
objective is to minimize the estimated wire length under area constraint. The area of all blocks in each 
partition must be between 23.04%-28.09% of the total area of blocks, where the bound is calculated 
according to the Ubfactor = 2 used in hMETIS. Experimental results are listed in the following tables. 
 
As list in table 4.2, the items below the ILP column are the results of ILP, where “Esti. WL” is the 
estimated wire length, “TSV” is the total number of TSVs after layer assignment, and “Area” denotes 
the maximum area of blocks among all layers, and the items below the 3-D floorplanner are the results 
after 3-D floorplanning, where “Area” is the maximum area among all layers, and “WL” is the total 
wire length between blocks excluding the connections between blocks and I/O pads. The total wire 
length after 3-D floorplanning with our formulations is improved by 3%, and the total number of TSVs 
is improved by 0.7% compared to [24]. The area is just 1% larger than [24]. The results show that our 
modification for estimated wire length is more accurate. 
 
Table 4.3 compares the results obtained by using different objective functions. “min. TSV” means the 
objective function is to minimize the number of TSVs under are constraint. “min. WL with TSV 
constraints” means the objective function is to minimize wire length under area and TSV constraints, 
where the TSV bound is equal to the objective value of “min. TSV” multiplied by 1.3. Comparing with 
the objective function which is to minimize number of TSVs, the result is a 26% inflation in TSV, but a 
4% reduction in wire length. If we set the TSVs bound too tight, our algorithm of “min. WL with TSV 
constraint” cannot find feasible solution in 1800 seconds. Since our algorithm for evaluating number of 
TSVs is slow, we need to relax the bound of TSVs if we want to find a feasible solution in a specific 
time. 
 
hMETIS is a famous 2-D partitioner. To compare with it, we reordered the layers according to the 
outputs of hMETIS and chose the best solution after reordering. Because hMETIS is a thermal unaware 
partitioner, we evaluated the temperature from the ouput of hMETIS. This temperature would be the 
bound for our algorithm under thermal constraint. Note that the runtime of hMETIS is less than 1 
second. 
 
The objective function of our ILP is to minimize total number of TSVs by using equation 3.10 under 
area constraints. Table 4.4 shows the results of the total number of TSVs from three to four layers. 
Comparing with hMETIS, our algorithm can improve the number of TSVs by 4%-5% for using 
UBfactor 2 and 7% for using UBfactor 5. This shows our algorithm of objective is to minimize number 
of TSVs can find the better solution than hMETIS. 
 
Table 4.5 is the comparison of number of TSVs between hMETIS and our algorithm, where our 
algorithm is under thermal constraint using thermal model 1. Under the thermal constraint, our 
algorithm objective function is to minimize the number of TSVs. The table shows our algorithm can 
obtain better partitions with 3% to 9% less TSVs compared with hMETIS under the same temperature 
constraint. 
 
We also compare hMETIS with our algorithm under the thermal constraint using thermal mode 2, and 
table 4.6 shows that our algorithm can result in 2% less TSVs in three-layer design and 7% less TSVs 
in four-layer design compared with hMETIS. 
 
19 
 
 Ubfactor=2 
 #Layers=3 #Layers=4 
 hMetis ILP hMetis ILP 
N100 457 434 729 657 
N200 999 986 1466 1464 
N300 1108 1099 1586 1489 
ratio 1.02 1 1.07 1 
Table 4.6: Comparison of the number of TSVs between hMETIS and our algorithm, where our 
algorithm is under thermal constraint by using thermal model 2 
四、計畫成果自評 
We have thoroughly investigated the SiP partitioning problem and developed a SiP partitioning tool 
which matches the target of our project. To solve SiP partitioning problem effectively, we developed an 
integer linear programming based method and a simulated annealing based method. We have also 
performed extensive experiments to study the performance of the ILP based approach under different 
design objectives. Our partitioner can yield better layer assignment solution for SiP design compared to 
state-of-the art circuit partitioning tool, hmetis, in terms of estimated total bonding wirelength, pad 
count, and estimated temperature. Since partitioning of 3-D IC is very similar to partitioning of SiP, we 
also developed an integer linear programming based method to solve the 3-D IC partitioning problem. 
Our proposed 3-D IC partitioner targets to reduce the number of TSVs and the post-floorplanning 
wirelength. 
 
Finally, this project has resulted in two theses [34, 35]. In addition, under the support of this research 
grant, seven conference papers [27-33] have been published. 
 
參考文獻 
[1] B.W.Kernighan and S.Lin, “An efficient Heuristic Procedure for Partitioning Graphs”,Bell Syst. 
Tech.Journal,49(2),pp.291-307,1970 
[2] C.M.Fiduccia and R.M. Mattheyses, “A Linear Time Heuristic for Improving Network 
Partitions”,in Proc. Design Automation Conference,pp.175-181,1982 
[3] D.S.Johnson, C.R. Aragon, L.A. McGeoch,and C.Schevon, “Optimization by Simulated Annealing: 
An Experimental Evaluation Part I. Graph Partitioning”, Operations Research,37,pp.865-892,1898 
[4] L.Hargen, A.B. Kahng, F.L. Kurdahi, and C. Ramachandran, “On the Intrinsic Rent Parameter and 
Spectra-based Partitioning Methods”, in IEEE Trans. On CAD,vol.13,pp.27-37,1994. 
[5] C.J. Alpert and S.Z.Yao, “Spectral Partitioning: The More Eigenvectors the Better”, in 
Proc.DAC,pp.195-200,1995 
[6] H.H. Yang and D.F.Wong, “Efficient Network Flow based Min-Cut Balanced Partitioning”, IEEE 
Trans. On CAD, vol.15(12),Dec.1996,pp.1533-1540 
[7]H.Liu and D.F.Wong, “Network-Flow-Based Multiway Partitioning with Area and Pin 
Constraints”,IEEE Trans. On CAD, vol .17(1),Jan 1998,pp.50-59 
[8]Y.C.Wei and C.K.Cheng,”Towards efficient hierarchical designs by ratio cut partitioning”, in 
Proc.IEEE/ACM ICCAD,1989,pp.298-301. 
[9] M.Shih and E.S. Kuh ,”Quadratic Boolean programming for performance-driven system 
partitioning”, in Proc.ACM/IEEE Design Automation Conference, 1993,pp.761-765. 
[10] M.Shih and E.S. Kuh , “Circuit Partitioning under Capacity and Signal Constraints”, in Proc. 
Custom Integrated Curcuits Conf.,pp.659-662,1994. 
[11] B.M. Riess, K.Doll, and F.M. Johnnes, “Partitioning Very Large Circuits Using Analytical 
Placement Techniques”, in Proc. DAC, pp.646-651,1994. 
[12] S.Khan and V.Madisetti, “Yield-based System Partitioning Strategies for MCM and SEM Design”, 
in Proc.Int’l Symp. Circuits and Systems, pp.144-149,1994. 
[13] C.J. Alpert and A.B.Kahng, “Multi-way partitioning via spacefilling curves and dynamic 
programming”, in Proc. ACM/IEEE Design Automation Conference,1994,pp.652-657. 
[14] S. Im and K. Banerjee, “Full chip thermal analysis of planar (2-d) and vertically integrated (3-d) 
high performance ics,” in Electron Devices 
Meeting, 2000. IEDM Technical Digest. International, 2000, pp. 727–730. 
[15] A. Jain, R.E. Jones, R. Chatterjee, S. Pozder and Z. Huang“Thermal Modeling and Design of 3D 
Integrated Circuits,” Proc. ITherm conference, IEEE, May, 2008. 
[16] T.-Y. Chiang, S. J. Souri, C. O. Chui, and K. C. Saraswat, “Thermal Analysis of Heterogeneous 
3-D ICs with Various Integration Scenarios,” IEEE International Electron Devices Meeting (IEDM) 
2001 Technical Digest, pp. 681--684, Dec. 2001. 
[17] A. Rahman and R. Reif,, “Thermal Analysis of Three-Dimensional (3-D) Integrated Circuits 
(ICs)”, Proc. IEEE Int’l Interconnect Technology Conf., IEEE Press, 2001, pp. 157-159. 
[18] Wei Huang , Mircea R. Stan , Kevin Skadron , Karthik Sankaranarayanan , Shougata Ghosh , 
Sivakumar Velusam, “Compact thermal modeling for temperature-aware design”, Proceedings of the 
41st annual conference on Design automation, June 07-11, 2004, San Diego, CA, USA . 
 5
 
國科會補助專題研究計畫項下出席國際學術會議心得報告 
                                     日期：99 年 10 月 25 日 
一、參加會議經過 
二、與會心得 
One main characteristic of recent ISPDs is that its technical program includes a strong lineup of invited talks 
from research labs of big companies and leading CAD vendors. This year there were 13 invited talks which 
complemented the 22 regular paper presentations. In this way, it did not only reveal the current state-of-the-art 
but also gave a glimpse of potential future research directions in physical design of VLSI and other analogous 
system. For example, the keynote talk was on physical design of biological systems. One invited talk talked 
about the pervasive chips found inside in modern automobiles. Three invited talked focused on different 
aspects of 3D IC technology. 
三、考察參觀活動(無是項活動者略) 
計畫編號 NSC 98－2220－E－007－012 
計畫名稱 在 SiP 設計下的元件分配最佳化之研究 
出國人員
姓名 麥偉基 
服務機構
及職稱 清華大學資訊工程系 
會議時間 
 99年 3月 14日
至 
 99年 3月 17日 
會議地點 San Francisco, CA, U.S. 
會議名稱 
(中文) 
(英文)  ACM International Symposium on Physical Design 
發表論文
題目 
(中文) 
(英文)1.  FOARS: FLUTE Based Obstacle-Avoiding Rectilinear Steiner 
Tree Construction 
2.  SafeChoice: A Novel Clustering Algorithm for Wirelength-Driven 
Placement 
附件四 
FOARS: FLUTE Based Obstacle-Avoiding Rectilinear
Steiner Tree Construction∗
Gaurav Ajwani
Department of Electrical and
Computer Engineering
Iowa State University
Ames, IA 50011
gajwani@iastate.edu
Chris Chu
Department of Electrical and
Computer Engineering
Iowa State University
Ames, IA 50011
cnchu@iastate.edu
Wai-Kei Mak
Department of Computer
Science
National Tsing Hua University
Hsinchu, Taiwan 300 R.O.C.
wkmak@cs.nthu.edu.tw
ABSTRACT
Obstacle-avoiding rectilinear Steiner minimal tree (OARSMT)
construction is becoming one of the most sought after prob-
lems in modern design flow. In this paper we present FOARS,
an algorithm to route a multi-terminal net in the presence
of obstacles. FOARS is a top down approach which includes
partitioning the initial solution into subproblems and using
obstacle aware version of Fast Lookup Table based Wire-
length Estimation (OA-FLUTE) at a lower level to gen-
erate an OAST followed by recombining them with some
backend refinement. To construct an initial connectivity
graph FOARS uses a novel obstacle-avoiding spanning graph
(OASG) algorithm which is a generalization of Zhou’s span-
ning graph algorithm without obstacle [1]. FOARS has a
run time complexity of O(n log n). Our experimental re-
sults indicate that it outperforms Lin et al. [2] by 2.3% in
wirelength. FOARS also has 20% faster run time as com-
pared with Long et al. [3], which is the fastest solution till
date.
Categories and Subject Descriptors
B.7.2 [Hardware, Integrated Circuits, Design Aids]:
Placement and Routing
General Terms
Algorithms, Design, Performance, Theory
Keywords
Physical Design, Routing, Spanning Graph, RSMT
1. INTRODUCTION
∗This work was partially supported by National Science
of Council of Taiwan under grant NSC 98-2220-E-007-031,
IBM Faculty Award, and NSF under grant CCF-0540998.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee.
ISPD’10, March 14–17, 2010, San Francisco, California, USA.
Copyright 2010 ACM 978-1-60558-920-6/10/03 ...$10.00.
With the advent of re-usability using Intellectual Property
(IP) sharing, the chip in today’s design is completely packed
with fixed blocks such as IP blocks, macros, etc. Routing of
multi-terminal nets in the presence of obstacles has become
a quintessential part of the design and has been studied by
many (e.g., [2–12]). As pointed out by Hwang [13], in the
absence of obstacles multi-terminal net routing corresponds
to the rectilinear Steiner minimal tree problem which is NP-
complete. The presence of obstacles in the region makes
multi-terminal routing problem even harder.
In this work, we develop a new O(n log n) time algorithm
called FOARS for OARSMT generation by leveraging FLUTE
[14]. FLUTE is a very fast and robust tool for the rectilinear
Steiner minimal tree problem without obstacle. It is widely
used in many recent academic global routers. FLUTE by
its design cannot handle obstacles. A simple strategy to
generate an OARSMT would be to call FLUTE once and le-
galize the edges intersecting with obstacles. Unfortunately,
the OARSMT obtained by such a simple strategy can be
far from optimal. A better strategy is to break the Steiner
tree produced by FLUTE on overlapping obstacles, recur-
sively call FLUTE for local optimization, and then combine
all locally optimized subtrees at the end. However, as the
number of pins increases or if the routing region is severely
cluttered with obstacles, the quality of the solution produced
will degrade because it lacks a global view of the problem.
To tackle this, we propose a partitioning algorithm with a
global view of the problem at the top level to divide the
problem into smaller instances that can be effectively han-
dled.
To guide the partitioning algorithm, we propose to use a
sparse obstacle-avoiding spanning graph (OASG) to capture
the proximity information amongst the pins and corners of
obstacles. Three categories of graph have been used to cap-
ture the proximity information during OARSMT construc-
tion in the past. [4, 6, 7, 11] all use the escape graph. [10]
utilizes a Delaunay triangulation based graph. Both the
escape graph and Delaunay triangulation based graph con-
tain O(n2) edges, where n is the total number of pins and
obstacle corners. [2, 3, 5, 8, 9] are based on various forms of
obstacle-avoiding spanning graphs. Shen et al. [5] proposed
a form of OASG that only contains a linear number of edges
which is also adopted in [8]. Later Lin et al. [2] proposed
adding missing “essential edges” to Shen’s OASG. Unfortu-
nately, it increases the number of edges to O(n2) in the worst
case (O(n log n) in practice) and hence the time complexity
of later steps of OARSMT construction is increased to a
Definition 1 Given an edge e(u, v) and an obstacle b, e is
completely blocked by b if every monotonic Manhattan path
connecting u and v intersects with a boundary of b.
Definition 2 Given a set of m pins and k obstacles, an
undirected graph G = (V, E) connecting all pin and corner
vertices is called an OASG if none of its edges is completely
blocked by an obstacle.
Although Definition 2 does not necessitate a linear num-
ber of edges for an OASG, in order to have a fast run time
it is desired to limit the solution space. In the past, there
have been a couple of efforts to construct an OASG with a
linear number of edges. Shen et al. [5] suggested a quadrant
approach in which each point can connect in four quadrants
in the plane formed by horizontal and vertical line going
through the point. Shen did not clearly explain their algo-
rithm in the paper.
Long et al. [9] recently described a novel quadrant ap-
proach which is a modified version of [1] for OASG genera-
tion with a linear number of edges in O(n log n) time. They
suggested scanning along ±45◦ lines and maintaining an ac-
tive vertex list, a set of vertices in the graph which are not
yet connected to their nearest neighbor, similar to [1]. After
scanning any vertex v, they search for its nearest neighbor
u in the active vertex list, such that the edge (u, v) is not
completely blocked by any obstacle in the graph. This is
followed by deletion of u from the list and addition of v in
the list.
We found that their algorithm has certain shortcomings.
First, their algorithm is not symmetric, i.e., the nearest
neighbor for any vertex in a quadrant is contingent upon
the direction of scanning which means they have to scan
along all four quadrants of a vertex in order to capture its
connectivity information. Second, unlike [1] in the absence
of obstacles, their algorithm cannot guarantee the presence
of at least one MST in the plane. Third, their algorithm
cannot handle abutting obstacles due to minor mistakes in
the inequality conditions.
3.2 Our Approach for OASG
Looking at the above mentioned issues we conceived that
rather than modifying Zhou et al’s [1] approach, it will be
best to simply build on their idea. Therefore, we propose an
algorithm based on octant partition exhibiting uniqueness
property similar to their algorithm. We reiterate the defi-
nition given in their paper. The notation ||pq|| represents
rectilinear distance between p and q.
Definition 3 [1] Given a point s, a region R has the unique-
ness property with respect to s if for every pair of points p,
q ∈ R, ||pq|| <max(||sp||,||sq||). A partition of space into a
finite set of disjoint regions is said to have the uniqueness
property if each of its regions has the uniqueness property.
Fig. 2(a) and Fig. 2(b) describes octant partition for a
pin vertex and an obstacle corner, respectively. It is proved
in [1] that octant partition exhibits the uniqueness property.
Imagine three points s, p and q such that ||sp|| < ||sq|| where
points p and q lie in Ri of s. As Ri has the uniqueness
property, it implies ||pq|| < ||sq||. Since the longest edge
(a) Pin vertex (b) Obstacle corner
Figure 2: Octant partition for a pin vertex and an
obstacle corner
of any cycle should not be included in a MST, we can still
guarantee that a MST exists in an OASG that does not
include edge (s, q).
Another interesting property of octant partition is that a
contour of equidistant points from any point forms a line seg-
ment in each region. In regions R1,R2,R5,R6, these segments
are captured by an equation of the form x+y = c; in regions
R3,R4,R7,R8, they are described by the form x − y = c.
Now this property can be exploited when we generate an
obstacle-avoiding spanning graph.
Algorithm: OASG generation for R1
1 Aactive = Abottom = Aleft = ∅
2 for all v ∈ V in increasing (x + y) order
3 S(v) = ∅
4 for all u ∈ Aactive which have v in their R1 do
5 Add u to S(v)
6 end for
7 Connect v to the nearest point u∗ ∈ S(v) such that
e(u∗, v) is not completely blocked
by obstacle boundaries in Abottom and Aleft
8 Delete all points in S(v) from Aactive
9 if v is a bottom left corner then
10 Add the bottom boundary containing v to Abottom
and the left boundary containing v to Aleft
11 else if v is a top left corner then
12 Delete the left boundary containing v from Aleft
13 else if v is a bottom right corner then
14 Determine the bottom boundary B containing v
15 Delete B from Abottom
16 Delete from Aactive all points which are
completely blocked by B
17 end if
18 Add v to Aactive
19 end for
Figure 3: Pseudo code for OASG generation algo-
rithm
The pseudo code for OASG generation for R1 is provided
in Fig. 3. As R1 and R2 both follow the same sweep se-
quence we process them together in one pass. It is worth
noting that our algorithm is exactly symmetrical as it does
not depend on the direction of scanning. If any point v is
the nearest neighbor of u in R1, it implies that u is the near-
est neighbor of v in R5 which reduces our sweep iterations.
For any point, we only need to sweep twice to determine
its connectivity information once for R1/R2 and once for
In this paper, we adopt the approach based on the ex-
tended Dijkstra’s algorithm and the extended Kruskal’s al-
gorithm as defined in [3]. For every corner vertex in the
OASG, we want to connect it with the nearest pin vertex.
This can be easily done using Dijkstra’s shortest path algo-
rithm considering every pin vertex as a source. After run-
ning the extended Dijkstra’s algorithm we are left with a
forest of m trees, m being the number of pin vertices. The
root of every tree in the forest obtained above is a pin ver-
tex. In order to connect all disjoint trees we use the extended
Kruskal’s algorithm on the forest. A priority queue Q is used
to store the weights of all possible edges termed as bridge
edges in [3] which can be used for linking the trees.
Definition 4 [3] An edge e(u, v) is called a bridge edge
if its two end vertices belong to different terminal trees.
From Definition 4, it can be deduced that if each tree was
a single vertex in the graph then bridge edges will be the
edges connecting these vertices and we can use Kruskal’s al-
gorithm to obtain a MST in such a graph. The extended
Kruskal’s algorithm is simply an extended version of the
original Kruskal’s algorithm tailored to obtain a MST in
a forest. It is important to note that in case we do not
have any obstacle, the extended Dijkstra’s algorithm will
not make any change in the graph and the extended Kruskal
will simply work on a spanning graph.
4.2 OPMST Construction
We note that a sparse OASG does not always have direct
connections between the pin vertices even if one is allowed.
This is due to a neighboring corner vertex being nearer than
the other pin vertex in the same region. These indirect de-
tour paths are unnecessary and if not taken care of can lead
to a significant loss of quality. We note that the algorithm
proposed by [3] failed to address this issue. On the other
hand, we address this problem by constructing an obstacle
penalized minimal spanning tree (OPMST) from the MTST
by removing all the corner vertices and storing detour infor-
mation as the weight of an edge.
To construct an OPMST, we follow a simple strategy. For
any corner vertex v, we find the nearest neighboring pin ver-
tex u. We connect all the pin vertices originally connected
with v to u and delete v. We update their weights as their
original weight plus the weight of e(u, v). This method guar-
antees that in case we have a major detour between two pin
vertices due to an obstacle, the weight of that edge will cor-
roborate this fact. In other words we can say that the edge
would be penalized for the obstacles in its path.
5. OAST GENERATION
This step differentiates our algorithm from [2,3,5,9]. We
exploit the extremely fast and efficient Steiner tree genera-
tion capability of FLUTE [14] for low degree nets. In order
to embed FLUTE in our problem we designed an obstacle
aware version of FLUTE, OA-FLUTE. As OA-FLUTE is
less efficient for high degree nets and dense obstacle region,
we partition a high degree net into subnets guided by the
OPMST obtained from the previous step. The subproblems
obtained after partitioning are passed on to OA-FLUTE for
obstacle aware topology generation. It is termed as obsta-
cle aware because the nodes of the tree are placed in their
appropriate location considering obstacles around them.
Function: Partition(T)
Input: An OPMST T
Output: An OAST
1 If(∃ a completely blocked edge e)
2 /∗ Refer to Fig. 7 ∗/
3 e(u, v) is to be routed around obstacle edge e(a, b)
4 Let T = T1 + e(u, v) + T2
5 T1 = T1 + e(u, a)
6 T2 = T2 + e(u, b)
7 T ′ = Partition(T1) ∪ Partition(T2)
8 Else if(|T | > HIGH THRESHOLD)
10 /∗ Refer to Fig. 8(a) ∗/
11 Let e(u, v) be the longest edge s.t.
T = T1 + e(u, v) + T2 with |T1| ≥ 2 and |T2| ≥ 2
12 T ′ = Partition(T1) ∪ Partition(T2)
13 /∗ Refer to Fig. 8(b) ∗/
14 Refine T’ using OA-FLUTE(N”) where,
15 N” is a set of pin vertices around e(u, v) in T’
16 Else
17 T ′ = OA-FLUTE(N) where,
18 N is set of all pin vertices in T’
19 Return T’
Figure 5: Pseudo code for the Partition function
Fig. 5 and Fig. 6 describe the pseudo codes for the Par-
tition and OA-FLUTE functions. It is evident that both
functions are recursive functions. Let us first explain the
Partition function.
5.1 Partition
The input to the Partition function is an OPMST ob-
tained from the last step and the output is an obstacle-aware
Steiner tree (OAST). An OAST is a Steiner tree in which
the Steiner nodes have been placed considering the obstacles
present in the routing region to minimize the overall wire-
length. The following two criteria are set for partitioning
pin vertices. The first criterion is to determine if any edge
is completely blocked by an obstacle. The second criterion
is to check if the size of OPMST is more than the HIGH
THRESHOLD defined.
As can be clearly seen in Fig. 7 that for an overlap free
solution, we have to route around the obstacle. Therefore, it
seems logical to break the tree at edge (u, v). We know that
OA-FLUTE can efficiently construct a tree when the number
of nodes is less than the HIGH THRESHOLD value. If the
size of the tree is still more than the HIGH THRESHOLD
after breaking at the blocking obstacles, we need to break
the tree further. In this case, we look for the edge with the
largest weight on the tree and delete that edge, refer to Fig.
8(a).
Based on the above mentioned criterion, if we break an
obstacle edge, we simply include corner vertices in the tree
and divide the two trees as shown in Fig. 7. Else, if we
break at the edge with largest weight, we delete that edge
and make sure that it does not contain any leaf of the tree
as shown in Fig. 8(a).
After breaking an edge, we make recursive calls to the
Partition function using two subtrees. When the size of the
tree becomes less than the HIGH THRESHOLD, we pass
the nodes of the tree to OA-FLUTE function. The OA-
FLUTE function returns an OAST. After returning from
Wirelength Run time(s)
Benchmark m k Lin [2] Long [3] Liang [11] Liu [12] Ours Lin [2] Long [3] Liang [11] Ours
RC01 10 10 27790 26120 25980 26740 25980 0.00 0.00 0.01 0.00
RC02 30 10 42240 41630 42010 42070 42110 0.00 0.00 0.02 0.00
RC03 50 10 56140 55010 54390 54550 56030 0.00 0.00 0.00 0.00
RC04 70 10 60800 59250 59740 59390 59720 0.00 0.00 0.01 0.00
RC05 100 10 76760 76240 74650 75430 75000 0.00 0.00 0.01 0.00
RC06 100 500 84193 85976 81607 81903 81229 0.10 0.08 0.50 0.03
RC07 200 500 114173 116450 111542 111752 110764 0.18 0.09 0.60 0.04
RC08 200 800 120492 122390 115931 118349 116047 0.31 0.15 1.16 0.07
RC09 200 1000 117647 118700 113460 114928 115593 0.40 0.22 1.53 0.09
RC10 500 100 171519 168500 167620 167540 168280 0.20 0.03 0.18 0.02
RC11 1000 100 237794 234650 235283 234097 234416 0.74 0.06 0.83 0.04
RC12 1000 10000 803483 832780 761606 780528 756998 55.09 3.80 186.3 2.65
RT01 10 500 2289 2379 2231 2259 2191 0.03 0.06 0.19 0.01
RT02 50 500 48858 51274 47297 486884 48156 0.05 0.06 0.55 0.02
RT03 100 500 8508 8554 8187 8347 8282 0.10 0.06 0.21 0.03
RT04 100 1000 10459 10534 9914 10221 10330 0.22 0.23 0.37 0.09
RT05 200 2000 54683 55387 52473 53745 54598 0.96 0.66 3.18 0.26
IND1 10 32 632 639 619 626 604 0.00 0.00 0.00 0.00
IND2 10 43 9700 10000 9500 9500 9500 0.00 0.00 0.00 0.00
IND3 10 59 632 623 600 600 600 0.00 0.00 0.00 0.00
IND4 25 79 1121 1130 1096 1095 1129 0.00 0.00 0.00 0.00
IND5 33 71 1392 1379 1360 1364 1364 0.00 0.00 0.00 0.00
RL01 5000 5000 492865 491855 481813 - 483027 106.66 3.58 27.14 3.01
RL02 10000 500 648508 638487 638439 - 637753 159.09 1.27 29.45 1.07
RL03 10000 100 652241 641769 642380 - 640902 153.95 1.08 23.35 1.04
RL04 10000 10 709904 697595 699502 - 697125 195.25 0.97 22.00 1.39
RL05 10000 0 741697 728585 730857 - 728438 217.88 0.96 33.64 1.5
(1.023) (1.027) (0.995) (1.004) (1) 891.25(78.45) 13.36(1.196) 331.235(30) 11.36(1)
Table 1: Wirelength and run time comparison. m is the number of pin vertices and k is the number of
obstacles. The values in the last row are normalized over our results for both wirelength as well as run time
Figure 10: OA-FLUTE: Steiner node is on top of an
obstacle
both L-paths are blocked by the same obstacle 3) only one
L-path is blocked 4) both L-paths are blocked but not by
the same obstacle. We discuss these scenarios one by one in
the following paragraphs.
For the first case, even though we can rectilinearize using
any L-path, we instead create a slant edge at this stage to
leave the scope for improvement in V-shape refinement. For
the second case, we have no option but to go outside the
bounding box and pick the least possible detour.
For the third case, we route inside the bounding box, since
there exists a path. We break the edge into two sub problems
on the corner of an obstacle along the blocked L-path. We re-
cursively solve these sub problems to determine an obstacle-
avoiding path. If the wirelength of this path is same as the
Manhattan distance between the pins, we accept the solu-
tion, else we route along the unblocked L-path. It is note-
worthy that for this case we could have directly accepted the
unblocked L-path. In order to create more slant edges, and
hence, further scope for V-shape refinement, we searched
for a route along the blocked L-path avoiding obstacles. For
the last case where both L-paths are blocked but not by the
same obstacle, we determine obstacle-avoiding routes using
the same recursive approach as mentioned above for both
L-paths and pick the smallest one.
7. REFINEMENT
We perform a final V-shape refinement to improve total
wirelength. This refinement includes movement of Steiner
node in order to discard extra segments produced due to
previous steps. The concept of refinement is similar to the
one that determines a Steiner node for any three terminals.
The coordinates of the Steiner node are the median value
of the x-coordinates and median value of the y-coordinates.
Fig. 11 illustrates a potential case for V-shape refinement
and output after refinement. This refinement comes handy
in improving the overall wirelength by 1% to 2%.
Figure 11: V-shape refinement case and refined out-
put
8. EXPERIMENTAL RESULTS
We implemented our algorithm in C. The experiments
were performed on a 3GHz AMD Athlon 64 X2 Dual Core
machine. We requested for binaries from Long et al. [3], Lin
et al. [2], Liang et al. [11] and ran them on our platform.
We could not get binary from Liu et al. [12], which is the
most recent work, on time to include in the paper. We report
their results as provided in their paper. Table 1 shows Wire-
length and CPU run time comparison with them. There
SafeChoice: A Novel Clustering Algorithm for Wirelength-Driven Placement∗
Jackey Z. Yan
Department of ECE
Iowa State University
Ames, IA 50010 USA
zijunyan@iastate.edu
Chris Chu
Department of ECE
Iowa State University
Ames, IA 50010 USA
cnchu@iastate.edu
Wai-Kei Mak
Department of CS
National Tsing Hua University
Hsingchu 300, Taiwan
wkmak@cs.nthu.edu.tw
ABSTRACT
This paper presents SafeChoice (SC), a novel clustering algorithm
for wirelength-driven placement. Unlike all previous approaches, SC
is proposed based on a fundamental theorem, safe condition which
guarantees that clustering would not degrade the placement wire-
length. To derive such a theorem, we first introduce the concept of
safe clustering, i.e., do clustering without degrading the placement
quality. To check the safe condition for pair-wise clustering, we pro-
pose selective enumeration technique. SC maintains a global priority
queue (PQ) based on the safeness and area of potential clusters. Iter-
atively the cluster at the top of the PQ is formed. SC automatically
stops clustering when generating more clusters would degrade the
placement wirelength. To achieve other clustering objectives, e.g.,
any target clustering ratio, SC is able to perform under three different
modes. Comprehensive experimental results show that the clusters
produced by SC consistently help the placer to achieve the best wire-
length among all other clustering algorithms.
Categories and Subject Descriptors
B.7.2 [Hardware, Integrated Circuits, Design Aids]: Placement
and routing
General Terms
Algorithms, Design, Performance
Keywords
Hypergraph Clustering, VLSI Placement, Physical Design
1. INTRODUCTION
For modern VLSI designs, placement is the most critical stage in
the physical synthesis flow. It has significant impacts on timing, rout-
ing and even manufacturing. In the nanometer scale era, a circuit
typically contains millions of objects. It is extremely challenging for
a modern placer to be reasonably fast, yet still be able to produce
good solutions. Clustering cuts down the problem size via combin-
ing highly connected objects, so that the placers can perform more
∗This work was partially supported by IBM Faculty Award, NSF under grant
CCF-0540998 and NSC under grant NSC 98-2220-E-007-031.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee.
ISPD’10, March 14–17, 2010, San Francisco, California, USA.
Copyright 2010 ACM 978-1-60558-920-6/10/03 ...$5.00.
efficiently and effectively on a smaller problem. It is an attractive so-
lution to cope with the ever-increasing design complexity. Therefore,
as an essential approach to improve both the runtime and quality of
result, various clustering algorithms have been adopted in the state-
of-the-art placement algorithms [1–7].
1.1 Previous Work
Clustering is a traditional problem in VLSI CAD area. The cluster-
ing algorithms proposed long time ago were described in [8]. In the
last several years, various new algorithms were proposed to continue
improving the clustering quality. In [9] Karypis et al. proposed edge
coarsening (EC) clustering. In EC objects are randomly visited. Each
object is clustered with the most highly-connected unvisited neighbor
object. The connectivity between two objects is computed as the total
weight of all edges connecting them with hyperedges represented by
a clique model. FirstChoice (FC) clustering was developed in [10]
and is very similar to EC. The only difference between them is that
for each object in FC, all of its neighbor objects are considered for
clustering. FC has been used in placers NTUplace3 [1] and Capo [2].
However, neither EC nor FC considers the impact of cluster size on
the clustering quality. Alpert et al. [11] and Chan et al. [12] im-
proved EC and FC respectively, by considering the area of clusters,
i.e., clusters with smaller area are preferred to be generated. Cong
et al. [13] proposed an edge separability-based clustering (ESC). Un-
like previous methods, ESC uses edge separability to guide the clus-
tering process. To explore global connectivity information, all edges
are ranked via a priority queue (PQ) based on the edge separability.
Without violating the cluster size limit, the two objects in the highest
ranking edge are clustered. Hu et al. [14] developed fine granular-
ity (FG) clustering. The difference between FG and ESC is that for
FG the order in the PQ is based on edge contraction measured by a
mutual contraction metric. FG has been used in placer mFAR [3].
Nam et al. [15] proposed BestChoice (BC) clustering which has been
widely used in the top-of-the-line placers APlace [4], mPL6 [5], Fast-
Place3 [6], and RQL [7]. Instead of ranking the edges, BC maintains
a PQ based on a pair of objects, i.e., each object and its best neigh-
bor object. A score function considering both hyperedge weight and
object area is derived to calculate the score between two objects. For
each object, the best neighbor object is the neighbor object with the
highest score. The two objects at the top of the PQ are clustered it-
eratively. But updating such a PQ is quite time-consuming. Hence,
the authors proposed a lazy-update technique to make a trade-off be-
tween the clustering runtime and quality.
All of the above clustering algorithms either explicitly or implicitly
transform a hyperedge into a clique model, so that they can handle
pair-wise clustering, i.e., cluster two objects at each time. Recently,
Li et al. [16] presented NetCluster (NC) that can handle hyperedges
directly and cluster more than two objects at one time. In NC, initial
clusters are first generated by FM algorithm. Then a score is assigned
to each net. The objects in the net with the highest score are clustered.
DEFINITION 5. Total wirelength Gradient Function: Given a
placement p ∈ P and Vc = {a, b}, we define
Fab(p) = min(
X
e∈Ea
Δa(p, e),
X
e∈Eb
Δb(p, e))
In p if both a and b move towards each other, Fab(p) first calculates
the total wirelength change of all hyperedges for moving a and b,
respectively. Then it returns the one with smaller change. For exam-
ple, ifFab(p) =
P
e∈Ea Δa(p, e) ≤ 0, it means moving a towards b
would not increase the total wirelength; if Fab(p) > 0, then moving
either a or b towards each other would increase the total wirelength.
Next, we use this function to derive the safe condition for a and b.
THEOREM 1. Safe Condition for Vc = {a, b}
It is safe to cluster a and b if ∀p ∈ P,Fab(p) ≤ 0
PROOF. Given an initial placement p0 ∈ P with total wirelength
l0. Because ∀p ∈ P,Fab(p) ≤ 0, we have Fab(p0) ≤ 0. Suppose
Fab(p0) =
P
e∈Ea Δa(p
0, e) ≤ 0. This means by moving a a small
distance towards b, the total wirelength of all hyperedges would not
increase. After such movement, we get another placement p1 with
total wirelength l1, where l0 ≥ l1. For p1 we still haveFab(p1) ≤ 0.
Suppose this time Fab(p1) =
P
e∈Eb Δb(p
1, e) ≤ 0. This means
moving b a small distance towards a would not increase the total
wirelength. Again, after such movement, we get another placement
p2 with total wirelength l2, where l1 ≥ l2. We keep moving either a
or b towards each other until they reach the same location. Suppose
the final total wirelength is ln. Because after each movement we
always have Fab(p) ≤ 0, which means the total wirelength would
not increase, eventually we have l0 ≥ ln.
As a result, given any initial placement p0 we can gradually move
a and b to the same location without increasing the wirelength. So
based on Definition 2, it is safe to cluster vertices a and b.
2.3 Selective Enumeration
To check whether it is safe to cluster a and b, Theorem 1 shows
that we need to generate all placements in P . To do so, we have to
enumerate all possible positions for all vertices in V . Apparently this
is not a practical approach. In this section, we show that in order to
check Theorem 1, it is sufficient to consider only a small subset of
placements. Selective enumeration technique is proposed to enumer-
ate such necessary placements.
Selective enumeration is motivated by the following principle: Given
two placements p1, p2 ∈ P , if we know Fab(p1) ≤ Fab(p2), then
p1 can be ignored in the enumeration. This is because Theorem 1
shows that the safe condition is only determined by the placement
with the maximum Fab(p) value. So the basic idea of selective enu-
meration is to find out the relationship of Fab(p) values among dif-
ferent placements, so that in the enumeration process we can ignore
the placements with smaller or equal Fab(p) values. Placements in
P are generated by different positions of different vertices. Our goal
is to identify some vertices in V , such that some or even all of their
possible positions can be ignored.
We first classify the vertices in V into two categories Va¯b¯ and Vab
(Va¯b¯ ∪ Vab ∪ {a, b} = V ). Then we discuss the enumeration of their
positions separately. ∀v ∈ V , xv denotes the x coordinate of v.
1. Va¯b¯: vertices connecting with neither a nor b.
2. Vab: vertices connecting with at least one of a and b.
LEMMA 1. Given a placement p ∈ P , by moving vertex v ∈ Va¯b¯
to any other position, another placement p′ ∈ P is generated. We
have Fab(p) = Fab(p′).
PROOF. Since ∀v ∈ Va¯b¯, v connects with neither a nor b, chang-
ing the position of v would not change the leftmost or rightmost ver-
tex of any hyperedge connecting with a or b. Therefore,
∀e ∈ Ea, Δa(p, e) = Δa(p′, e)
∀e ∈ Eb, Δb(p, e) = Δb(p′, e)
Thus, Fab(p) = Fab(p′).
Based on Lemma 1, in the enumeration we can simply ignore all
vertices in Va¯b¯.
LEMMA 2. Given a placement p ∈ P , vertex v ∈ Vab and xv =
k1. After moving v to xv = k2, another placement p′ ∈ P is gen-
erated. We have Fab(p) = Fab(p′) if any one of the following con-
ditions is satisfied: (1) k1 ≤ xa and k2 ≤ xa; (2) k1 ≥ xb and
k2 ≥ xb; (3) xa < k1 < xb and xa < k2 < xb.
PROOF. Suppose condition (1) holds, i.e., v is on the left of a
in both p and p′. ∀e ∈ Ev , we consider two1 possible values of
Δa(p, e):
• Δa(p, e) = we
This means a is the rightmost vertex of e in p. After moving v
to k2, because k2 ≤ xa, a is still the rightmost vertex of e in p′.
Thus, Δa(p′, e) = we = Δa(p, e).
• Δa(p, e) = 0
This means a is neither the only leftmost nor the rightmost vertex
of e in p. After moving v to k2, because k2 ≤ xa, v is still on the
left of a in p′. Thus, Δa(p′, e) = 0 = Δa(p, e).
So ∀e ∈ Ev , Δa(p, e) = Δa(p′, e). Similarly we have ∀e ∈ Ev ,
Δb(p, e) = Δb(p
′, e). Therefore,
∀e ∈ Ea,Δa(p, e) = Δa(p′, e)
∀e ∈ Eb,Δb(p, e) = Δb(p′, e)
Thus, Fab(p) = Fab(p′). Analogically, the cases for conditions (2)
and (3) can be proved as well.
Lemma 2 shows that ∀v ∈ Vab, instead of enumerating all possible
positions, we only need to consider three possibilities: (1) v is on the
left of a (xv ≤ xa); (2) v is on the right of b (xv ≥ xb); (3) v is
between a and b (xa < xv < xb).
Based on Lemma 1 and 2, we need to enumerate 3|Vab| different
placements rather than all placements in P . Next, we will further
cut down this number from 3|Vab| to 2|Vab|, by ignoring all positions
between a and b.
LEMMA 3. Given a placement p ∈ P , such that vertex v ∈ Vab
is between a and b (xa < xv < xb). After moving v either to the left
of a or to the right of b, another placement p′ ∈ P is generated. We
have Fab(p) ≤ Fab(p′).
PROOF. Suppose v is moved to the left of a.
For a, after the movement, a might become the rightmost vertex of
some hyperedge. So we have
∀e ∈ Ev,Δa(p, e) ≤ Δa(p′, e) (1)
For b, after the movement, v is still on the left of b. So we have
∀e ∈ Ev,Δb(p, e) = Δb(p′, e) (2)
Based on Equations 1–2, we have
∀e ∈ Ea,Δa(p, e) ≤ Δa(p′, e)
∀e ∈ Eb,Δb(p, e) = Δb(p′, e)
Thus, Fab(p) ≤ Fab(p′). Similarly, we can prove the case for v is
moved to the right of b.
1Because v is on the left of a, a would not become the only leftmost vertex of e. Thus,
Δa(p, e) = −we.
Table 1: Differences among three modes (SC is the default mode).
Mode Clustering Objective S∗ Stopping Criterion
SC-G safe clusters guarantee smax no more safe clusters is in PQ
SC-R target clustering ratio s target clustering ratio is reached
SC best placement wirelength s threshold cost Ct is reached
3. ALGORITHM OF SAFECHOICE
In the previous section, we have described a practical method of
checking the safe condition for pair-wise clustering. Here, we apply
this method in a PQ-based algorithm flow and propose SafeChoice
algorithm. To satisfy various clustering objectives, we present three
operation modes for SafeChoice.
3.1 Priority-Queue Based Framework
Previous work [11, 12] show that the cluster size has significant
impacts on the clustering quality. If two potential clusters have the
same connectivity information, the one with the smaller area is pre-
ferred to be formed first. So in SafeChoice to balance the safeness
and area, we use the following cost function to calculate the cost C
for clustering two objects a and b.
C(a, b) = S∗ + θ × Aa + Ab
As
(3)
where θ = 4 by default, Aa and Ab denote the area of a and b re-
spectively, As is the average standard cell area in a circuit, and S∗ is
a term describing the safeness of clustering a and b. S∗ is calculated
based on different modes of SafeChoice (see Section 3.2).
In SafeChoice we maintain a global PQ similar to that in [15]. But
we rank each pair of objects based on the cost obtained by Equa-
tion 3. For SafeChoice, it is time-consuming to consider all possible
pairs in V . So for each object, we only consider its neighbor objects
connected by the nets containing at most β objects (β = 7 by de-
fault). Iteratively, SafeChoice clusters the pair of objects at the top of
the PQ, and then update the PQ using lazy-update. For different oper-
ation modes, SafeChoice stops clustering based on different stopping
criteria, which will be addressed in Section 3.2.
3.2 Operation Modes of SafeChoice
Given a circuit, some algorithms (e.g., FC and BC) can reach any
clustering ratio γ 3, while others (e.g., FG and NC) can only reach a
certain γ. None of previous work is able to automatically stop clus-
tering when the γ for the best placement wirelength is reached. By
default SafeChoice automatically stops clustering when generating
more clusters would degrade the placement wirelength. Additionally,
to achieve other clustering objectives, e.g., any target γ, SafeChoice
is capable of performing under various modes (see Table 1):
• Safety Guarantee Mode [SC-G]
SC-G aims at producing the completely safe clusters. Under this
mode, S∗ = smax in Equation 3. In each iteration, we cluster the
pair of objects at the top of the PQ only if its S∗ ≤ 0. Based on
Theorem 1, we guarantee that the formed clusters are safe. SC-G
terminates when there is no such safe clusters in the PQ.
• Clustering Ratio Mode [SC-R]
The SC-G mode may not achieve low clustering ratio in prac-
tice, because the number of safe clusters in a circuit is usually
limited. Sometimes if clustering cannot significantly reduce the
circuit size, even though all clusters are safe, the placer may not
perform efficiently and produce better result. So to make a trade-
off between safeness and circuit size reduction, SC-R produces
some unsafe clusters, besides the safe ones. We derive the fol-
lowing function to evaluate the safeness of each cluster:
s =
PL
i=1 si
L
(4)
3The clustering ratio γ is defined as the ratio of the number of objects in the clustered
circuit to the number of objects in the original circuit.
Unclustering
Flat-mPL6
Placement
Detailed Placement
Clustered Netlist
Clustering
Original Netlist
Figure 2: Experimental flow for clustering algorithm.
Basically, for a pair of objects a and b Equation 4 calculates the
average score s over the L enumerated placements. Under SC-R
mode, S∗ = s in Equation 3. Iteratively, SC-R clusters the pair
of objects at the top of the PQ until the target γ is reached.
• Smart Mode [SC] (default mode)
The smart mode heuristically stops the clustering process when
a typical placer achieves the best placement wirelength. None of
previous clustering algorithms is able to do this. For different cir-
cuits, the γ for the best placement wirelength may be different. In
SC, we set a threshold cost Ct (Ct = 21 by default), and use the
same cost function as in SC-R. During the clustering process, SC
would not terminate until the cost reaches Ct. With this simple
heuristic, SC is able to automatically stop when generating more
clusters starts to degrade the placement wirelength.
4. EXPERIMENTAL RESULTS
Experiments are run on a Linux server with Intel Xeon 2.83 GHz
CPU and 32 GB memory. We compare SC with three clustering algo-
rithms FC [12], BC [15] and NC [16]. We implemented FC and BC
by ourselves and obtained the binary of NC from the authors in [16].
For BC the lazy-update [15] is used to speed up its runtime. ISPD
05/06 placement benchmarks [17, 18] are used as the test circuits.
In the experiments, the clustering algorithm is applied as a pre-
processing step before placement (see Fig. 2). We adopt mPL6 [5] as
the placer. mPL6 is based on a multilevel framework, and uses BC
as its internal clustering algorithm. Without turning off BC inside
mPL6, we cannot fairly compare the effectiveness of various cluster-
ing algorithms, because the internal clustering process will produce
some noise to the results. So we add “-cluster_ratio 1” to the com-
mand line, such that mPL6 performs only one-level placement with-
out any clustering inside, i.e., flat-mPL6. As far as we know, mPL6
is the only placer that can turn off the internal clustering without
modifying the source code. In Fig. 2 after unclustering, we arrange
the objects inside each cluster in one row. The order among those
objects are random. Subsequently the locations of all objects are sent
to flat-mPL6 for detailed placement. Because of the random order
of objects within each cluster, we believe there is still room for im-
provement even after the flat-mPL6 detailed placement. So we apply
the detailed placer FastDP [6] to further refine the layout.
We normalize the results of flat-mPL6 with various pre-processing
clustering to the results of flat-mPL6without any pre-processing clus-
tering. For fair comparison, FastDP is applied to further refine the
output layouts from the flat-mPL6 without pre-processing clustering.
We conduct four sets of experiments.
I. Clustering Targeting at Safe Cluster: We compare SC-G with
FC and BC. FC’s and BC’s target γ is set the same as SC-G’s. Table 2
shows that SC-G’s HPWL is 2% worse than BC’s and 1% better than
FC’s. For both clustering time and total time, SC-G is the fastest.
Note that the cost C of some unsafe (i.e., Smax > 0) clusters may be
better than some safe clusters. But unfortunately SC-G does not form
any unsafe clusters. This makes SC-G’s HPWL worse than BC’s.
Table 4: Comparison with FirstChoice and BestChoice on target γ = 0.2, 0.3, 0.4, 0.5, 0.6 (* comparison of scaled HPWL).
Circuit Flat-mPL6 Clustering Clustering Time (s) Normalized HPWL to Flat-mPL6 Normalized Total Time to Flat-mPL6
HPWL (×10e6) Time (s) Ratio (γ) FC BC SC-R FC BC SC-R FC BC SC-R
0.2 4 8 187 1.12 1.06 1.03 0.94 0.80 0.88
0.3 3 6 121 1.05 1.02 1.00 0.90 0.80 0.92
adaptec1 78.91 1197 0.4 2 5 51 1.01 1.00 0.99 0.93 0.86 1.00
0.5 2 4 35 1.00 1.00 0.99 0.95 0.92 0.91
0.6 2 3 24 1.00 0.99 0.99 1.04 1.02 1.04
0.2 8 16 238 1.08 1.02 1.00 1.03 0.82 1.01
0.3 5 12 144 1.05 0.99 0.98 1.35 1.20 1.22
adaptec2 90.71 1241 0.4 4 9 59 1.03 1.01 0.98 1.38 1.19 1.23
0.5 3 7 39 1.01 1.00 0.98 1.43 1.19 1.28
0.6 3 6 26 1.00 0.99 0.98 1.45 1.24 1.20
0.2 19 46 572 1.15 1.02 1.02 0.77 0.70 0.76
0.3 14 38 390 1.08 1.00 0.99 0.79 0.72 0.81
adaptec3 210.34 3923 0.4 11 32 162 1.04 1.00 0.99 0.94 0.74 0.73
0.5 9 26 114 1.04 1.00 0.98 1.28 1.16 1.17
0.6 7 23 80 1.01 1.00 0.98 1.35 1.21 1.23
0.2 16 49 403 1.08 0.99 0.99 0.81 0.70 0.79
0.3 13 42 276 1.04 0.98 0.98 0.82 0.74 0.77
adaptec4 188.39 3463 0.4 11 35 130 1.02 0.99 0.98 0.83 0.75 0.85
0.5 9 30 89 1.01 0.99 0.98 1.28 1.26 1.18
0.6 7 22 59 1.00 0.99 0.99 1.16 1.29 1.18
0.2 8 15 297 1.05 1.01 1.02 0.86 0.68 0.98
0.3 5 12 179 1.02 0.98 0.99 0.85 0.95 0.98
bigblue1 96.73 1424 0.4 4 9 66 1.01 0.98 0.98 0.91 0.86 0.91
0.5 3 7 39 1.00 0.97 0.98 1.01 0.85 0.89
0.6 2 6 23 1.00 0.98 0.98 1.09 1.17 1.18
0.2 395 1749 1162 1.15 1.07 1.05 0.84 1.05 0.92
0.3 344 1516 667 1.07 1.01 1.01 0.86 1.16 0.91
bigblue2 146.98 3988 0.4 302 1295 359 1.04 1.00 0.99 0.88 1.14 0.90
0.5 244 1005 226 1.03 0.99 0.99 0.95 1.18 0.92
0.6 194 796 159 1.01 1.00 0.99 1.09 1.11 0.99
0.2 69 264 800 0.92 0.82 0.85 0.52 0.49 0.57
0.3 55 221 492 0.92 0.87 0.83 0.78 0.76 0.75
bigblue3 419.56 9486 0.4 46 174 241 0.92 0.84 0.85 0.90 0.81 0.82
0.5 36 146 158 0.93 0.88 0.88 0.93 0.95 0.91
0.6 30 116 89 0.91 0.88 0.89 1.00 1.01 0.91
0.2 633 2907 3262 1.12 1.01 1.02 1.06 1.17 1.19
0.3 534 2576 2220 1.06 1.00 0.99 1.19 1.44 1.24
bigblue4 812.89 10543 0.4 451 2169 1145 1.03 0.99 0.99 1.16 1.45 1.14
0.5 368 1819 733 1.01 0.99 0.99 1.24 1.35 1.23
0.6 288 1453 434 1.01 0.99 0.99 1.27 1.38 1.22
0.2 165 569 1424 0.77 0.63 0.62 0.52 0.56 0.66
0.3 139 503 984 0.83 0.66 0.63 0.52 0.52 0.62
adaptec5* 731.47 7892 0.4 114 419 456 0.84 0.68 0.65 0.61 0.58 0.59
0.5 93 358 324 0.86 0.72 0.69 1.07 1.29 1.07
0.6 73 311 204 0.88 0.73 0.70 1.23 1.32 1.15
0.2 169 806 781 0.91 0.88 0.81 0.13 0.24 0.23
0.3 149 718 527 0.91 0.86 0.80 0.23 0.49 0.41
newblue1* 109.85 17305 0.4 127 630 226 0.91 0.87 0.81 0.30 0.57 0.39
0.5 104 538 141 0.93 0.89 0.84 0.91 1.30 0.96
0.6 84 434 93 0.94 0.90 0.86 1.05 1.31 1.04
0.2 43 200 415 2.16 1.58 1.44 0.74 0.69 0.81
0.3 37 181 278 1.29 1.11 1.11 0.86 0.88 0.76
newblue2* 197.44 4396 0.4 32 164 155 1.07 1.03 1.03 0.82 0.89 0.86
0.5 26 128 116 1.02 1.01 1.01 1.04 0.88 0.97
0.6 21 65 84 1.01 1.00 1.00 0.90 0.89 0.90
0.2 931 3789 1010 0.98 0.89 0.89 0.50 0.76 0.50
0.3 783 3480 692 0.93 0.89 0.90 0.90 1.60 1.00
newblue3* 320.63 10200 0.4 630 3041 407 0.92 0.90 0.91 0.95 1.56 1.14
0.5 487 2546 326 0.92 0.93 0.93 1.00 1.34 1.15
0.6 362 2299 256 0.94 0.95 0.95 1.05 1.41 1.23
0.2 77 334 981 0.94 0.88 0.81 0.46 0.57 0.49
0.3 66 302 643 0.91 0.88 0.80 0.50 0.64 0.60
newblue4* 438.99 7779 0.4 55 267 275 0.91 0.86 0.81 0.59 0.72 0.62
0.5 46 221 188 0.92 0.86 0.81 0.53 0.61 0.57
0.6 37 168 114 0.93 0.85 0.83 0.62 0.59 0.63
0.2 1093 3948 1483 0.94 0.70 0.78 0.64 1.02 0.62
0.3 877 2863 935 0.95 0.73 0.74 0.71 0.95 0.69
newblue5* 836.62 10124 0.4 693 2124 392 0.96 0.77 0.77 1.09 1.10 1.01
0.5 532 1903 237 0.94 0.78 0.77 1.04 1.10 0.98
0.6 399 1713 155 0.92 0.82 0.80 1.04 1.10 0.94
0.2 1941 8229 4058 1.05 0.99 0.97 1.16 1.95 1.19
0.3 1641 7415 2793 1.01 0.97 0.96 1.11 1.77 1.31
newblue6* 520.95 7575 0.4 1343 6558 1378 1.00 0.97 0.96 1.27 1.88 1.28
0.5 1082 5391 890 0.99 0.97 0.97 1.14 1.64 1.07
0.6 824 4535 639 0.99 0.98 0.97 1.17 1.66 1.16
0.2 290 948 2704 1.07 0.99 1.00 0.90 0.98 0.81
0.3 238 738 1774 1.02 0.97 0.97 0.78 0.80 0.93
newblue7* 1076.36 19219 0.4 197 605 891 1.00 0.97 0.97 0.79 0.74 0.95
0.5 159 472 596 0.99 0.97 0.97 0.76 0.72 1.00
0.6 126 380 422 0.98 0.97 0.97 0.93 1.00 1.03
無衍生研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
