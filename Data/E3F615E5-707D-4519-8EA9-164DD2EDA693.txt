to maximize the volumes of nowadays databases thus 
becomes a critical key issue. Previous databases 
adopt vertical scaling to achieve the goal, but it is 
now infeasible as SQL will have problems managing 
today＇s exponentially growing data items. A new 
query technique, NoSQL (Not only SQL) using elastic 
scaling and free data format, is introduced to meet 
the current needs in cloud computing. Based mainly on 
the distributed structures of Google Bigtable and 
Amazon Dynamo, NoSQL can well fit today＇s IT 
developing trend – if such issues as data 
consistency, data replication, and database 
scalability can be fully addressed. 
As cloud computing maintains high availability to 
serve large numbers of users through replication, we 
need to replicate a service on multiple servers, to 
make sure when some replicas fail, the service can 
still be performed by operational nodes. But, when a 
service is replicated, it is not easy to ensure 
consistency of all replicas because conflicting 
requests sent simultaneously to different nodes can 
lead to inconsistent states in the replicas and also 
meaningless replies to clients. Atomic broadcast 
algorithms, such as libPaxos (based on the message-
passing model of consistency) can help ensure such 
service transmission consistency.  
In our comprehensive performance survey on libPaxos, 
Mencius and RingPaxos, we find that libPaxos uses a 
two-phase commit protocol (2PC) to ensure 
consistency, Mencius improves libPaxos by using a 
rotating mechanism to distribute the load of every 
server, while RingPaxos uses the ring topology to 
improve the tree topology of libPaxos. To further 
improve the performance of libPaxos, we present a new 
scheme which divides regions to process messages in a 
distributed way and uses a rotating mechanism to 
effectively balance the loads of servers. Our 
experimental evaluation shows that besides yielding 
high throughput under heavy client loads and high 
scalability due to more desirable utilization of 
scaled server resources, our proposed scheme also 
produces low latency.  
 1
行政院國家科學委員會專題研究計畫成果報告 
雲端資料庫 NoSQL技術之探討與開發 
Research and Development on NoSQL Techniques  
for Cloud Databases 
計畫編號：NSC 100-2221-E-032-063 
執行期限：100年 8月 1日至 101年 7月 31日 
主持人：莊博任   淡江大學電機系  
計畫參與人員：徐偉銘、林志信、周稚淵 
淡江大學電機系 
 
一、中文摘要 
 
常見的傳統關聯式資料庫， 採用 SQL
資料查詢技術，但是近年來由於社群網路
和雲端資料庫的興起，讓資料庫面對的不
再只是少量的寫入資料，因此亟需突破容
量的限制。以往資料庫的擴充都是以垂直
擴充為主，但現今資料的使用量成指數上
升，讓以往的 SQL技術遇上了瓶頸。這時
雲端資料庫方面興起的 NoSQL（Not only 
SQL）技術，提倡以彈性擴充、資料型態
自由化來因應現有之問題及限制，已快速
竄升為未來發展應用的大趨勢。NoSQL 的
主要架構以 Google 提出的 Bigtable 和 
Amazon 提出的 Dynamo 所代表之分散式
架構為基本依據，但現行 NoSQL技術需要
面對幾項重要議題，如資料一致性、資料
備份、及資料庫的延伸性等。 
Chubby是 2007年 Google提出來的一
個分散式容錯系統實現於雲端運算架構
中，也是 Yahoo 釋出的 Hadoop 軟體中的
Zookeeper，實現方式是通過對檔案的建立
操作來實現“加鎖”，系統方面主要是能支
持多個 Google 的系統，如 Google File 
System(GFS)和 Bigtable 等系統。Chubby
利用備份的方式來達到容錯的功能，其架
構本身主要參考 Paxos 演算法來實現，主
要是利用訊息傳遞的方式，來維護各個伺
服器在雲端運算下的各個資料一致性。 
基於 Paxos 的方法，本計畫提出一個
新的機制，可以應用於雲端運算的架構
上。我們利用劃分區域的方式來分配各個
伺服器需要處理的任務，採用輪替的方式
來平衡處理的伺服器的負載，以有效提升
方法的效能，並且利用 consistent hashing
的方式來維護伺服器配置，讓我們的方法
更可以實現於雲端架構上。 
實驗證明，我們提出的機制，比既有
機制可以更有效率的處理訊息並且用維持
著低延遲的方式處理。對於伺服器的擴充
方面，相較於其他既有機制更可以維持高
效能，有效利用各個伺服器擴充的資源。 
 
關鍵詞：雲端資料庫、社群網路、SQL、
NoSQL、彈性擴充、容錯性、資料一致性、
資料備份、資料庫延伸性、高併發性資料、
加鎖廣播、兩階段達成協定。 
 
Abstract 
 
SQL, the data query technique for 
traditional relational databases, can no longer 
satisfy the fast rising processing needs of 
today’s computing developments or 
applications, such as the highly popular 
social networks or hotly pursued cloud 
databases which need to handle massive 
quantities of data, including large amounts of 
write-in data. How to maximize the volumes 
of nowadays databases thus becomes a 
critical key issue. Previous databases adopt 
vertical scaling to achieve the goal, but it is 
now infeasible as SQL will have problems 
managing today’s exponentially growing 
data items. A new query technique, NoSQL 
(Not only SQL) using elastic scaling and free 
data format, is introduced to meet the current 
needs in cloud computing. Based mainly on 
the distributed structures of Google Bigtable 
and Amazon Dynamo, NoSQL can well fit 
today’s IT developing trend – if such issues 
 3
Only SQL)[3]型式的資料庫，此資料庫型式
的特色是具備高可擴充性，並且對於存儲
的格式是具備彈性化的，相對於以往的關
聯式資料庫，更可以處理大量訊息、彈性
的資料儲存格式以及伺服器的擴充方面更
顯的優異。 
當伺服器損毀的時候，對於要處理大
量資料的情況下，NoSQL需要考量的問題
是如何確保服務的可用性。在這分散式的
架構下，如何確保每一台資料庫都可以保
有訊息的最新值並且維護每一台資料庫的
訊息都擁有一致性，而不會衝突到彼此之
間的資訊。對於此項重要議題，Google 提
出了 NoSQL 系統，在這大量的資料結構
中，Google 利用 Chubby 來維護伺服器資
訊，Chubby本身主要利用一致性演算法來
維護各個伺服器之間的資料一致性。如何
在大量的訊息傳遞下，讓每個伺服器之間
都能保有訊息的一致性是很重要的，所以
本計畫主要是針對雲端運算下的一致性問
題。 
一致性問題主要是在一個分散式系統
中，如果各伺服器的初始狀態都保持一
致，在每個伺服器都執行相同的操作序
列，那麼他們最後會得到一個一致性的狀
態。為了保證每個伺服器執行相同的命令
序列，需要在每一個指令上執行一個一致
性演算法以保證每個伺服器看到的指令都
是一致。 
我們先對既有的一致性演算法
Paxos[4,5]、Mencius[6]和 RingPaxos[7]做了
一番比較。Paxos對於一致性的處理，分為
兩階段式的傳遞，並且採用會議的方式來
投票表決現階段的資料處理最新值的問
題，此主要乃使用者與伺服器之間的溝
通。有鑒於在大量的資料量修改下，會導
致於接收訊息的伺服器頻寬壅塞問題導致
於整個協定的處理效率降低，所以Mencius
針對此問題做解決，採用的是主伺服器輪
流替換，藉此來解決主伺服器頻寬壅塞的
問題。對於做決議完要傳送訊息給每個伺
服器時，鑒於主伺服器擁有的頻寬有限，
仍需廣播給每個底下的伺服器去修改，由
於當前對於一致性問題的解決方法中，主
要都是採用樹狀的形式來傳送，會讓最上
層的伺服器負載過大導致於在傳送的訊息
掉落的問題抑或者傳送效率不佳，
RingPaxos 對此方法採用環狀的形式來做
傳送，讓伺服器傳送的訊息的時候可以分
擔主伺服器的負載量。 
我們的協定結合 Mencius 的輪替性和
RingPaxos 的負載平衡的架構，主要利用
consistent hashing 的方式來做出環狀架
構，依照 hash的方式來配置伺服器位置，
讓在分配伺服器的時候可以更加的快速，
並且儲存伺服器配置的位置。在執行方
面，採用主伺服器輪替處理的方式，藉此
來分擔主伺服器的負載運算，其他的子伺
服器負責接受使用者訊息後，傳送給順時
針最靠近的主伺服器做決議，藉此達到分
區的處理的方式，可以更加提升我們協定
的擴充性。 
 
三、結果與討論 
 
libPaxos[8]在分散式架構下，可以保持
資料的高一致性並可以產出一定的效能，
但 是 可 以 發 現 proposer-acceptor 和
proposer-client之間訊息傳遞頻繁，當資料
量逐漸增加的時候，訊息會過度集中於
proposer，導致於 client和 acceptor在等待
proposer 做處理進而影響到整體協定的效
能；Mencius考慮到這項問題，為了減緩過
度集中於 proposer 伺服器而影響到整體效
能，所以它採用 multi-proposer的機制來輪
流給每個伺服器處理，來避免整體協定上
單一伺服器的負載量的情況，使得整體效
能提升。 
我們機制的概念，利用分區的概念來
處理各個訊息的方式，可以減少過度集中
於單一伺服器上面的問題，更可以在伺服
器損毀的時候，把影響的區域減少到最
小，進而增加整體協定的效能。由於是利
用分區的環狀拓樸的方式處理，所以我們
將此機制命名為 Area-based RingPaxos 
(ARP)。 
ARP採用Mencius的multi-proposer[9]
的方式來減少訊息集中於單一伺服器上
面，並且更進一步採用 consistent hashing
的概念來實現出分區處理的概念，利用三
個 proposer 來畫分三個區域來分別實現
Paxos ， 每 個 區 域 都 有 各 自 所 屬 的
 5
去 做 決 議 (discuss message) ， 
leader-proposer 會去比較每個區域的
proposer傳送過來的訊息是否有衝突，如果
有衝突到的話，會再比較回合編號和訊息
編號是否最新值再來執行下一個步驟；如
果不衝突的話，會繼續執行下一個步驟。 
在 Phase 2a的階段，leader-proposer會
傳送最後決議的訊息(agree message)給各
區域的 proposer 做處理，可以藉由此訊息
來達到各區域之間訊息的一致性。當
proposer收到最後決議訊息(agree message)
之後，會比較回合編號、訊息編號是否相
同，並且去把最後決議的 client訊息(result 
message)傳送給各個 acceptor，acceptor 接
收到訊息之後，便可以傳送給 client，得到
最終決議的訊息。 
以下我們比較各個協定的優劣勢： 
libPaxos：（優）解決一致性的方法，
利用樹狀的拓樸運行開會投票的方式，來
保證每個訊息處理的完整性；（劣）大部
分處理訊息過度集中於 Proposer，導致於
頻寬以及負載量過大，造成效能降低。 
Mencius：（優）為了避免 Proposer的
負載量過大以及頻寬壅塞，採用輪流處理
的方式來減緩 Proposer 的處理效能的瓶
頸；（劣）對於 Proposer 而言，處理訊息
的負載量和頻寬是不變的，利用輪替的方
式來避免過度集中的問題，這樣的方式讓
效能改善是有限的。 
RingPaxos：（優）改變以往處理訊息
的 tree 方式，利用環狀拓樸的方式來有效
減緩 Proposer 過度集中的問題，有效的改
善頻寬消耗的問題；（劣）當 Acceptor 失
效的時候，整個 round的需要等待 Acceptor
去修復而導致整體傳輸效率降低。 
ARP：（優）利用 consistent hashing
的方法維持 Proposer和 Acceptor之間傳遞
的方式，對於區域分工的方式可以有效的
提升整體協定的擴充性以及避免伺服器失
效的時候，可以不影響到整體效能來做處
理；（劣）由於整體協定運作的方式，需
要有一定的數量的伺服器才能運行 ARP，
所以在使用伺服器上面的消耗較其它協定
許多。 
在一個龐大的分散式架構下，需要的
是大量伺服器，在這環境下去實行各個協
定，我們的協定在這個環境下所見的劣勢
會比較那麼不明顯並且在效能上也會有明
顯的提升。  
我們藉由緊密的模擬實驗來驗證下述
問題：不論是為了伺服器端的輸出效能或
者為了增加資訊的可靠性進而去擴充伺服
器時，對於伺服器端是否可以持續維持著
高效能？對於客戶端而言，當面臨一項熱
門的網路服務的時候，是否可以快速的完
成？不論是當訊息量變大或者是伺服器擴
充的時候，是否能持續的維持低延遲的效
率？ 
藉由實驗結果可以得知本機制處理大
量訊息下，不論訊息的大小，相較於其它
機制都可以維持著高效能的輸出，並且當
伺服器擴增的時候，更可以維持低延遲的
回應效率。 
 
四、計畫成果自評 
 
本計畫中，我們提出一個在雲端運算
下維護資訊一致性的演算法，當各個網路
服務面臨大量訊息的時候，如何維護每個
伺服器之間的資訊的一致性，避免資訊傳
遞之間的衝突。 
本計畫提出的機制主要是採用
Mencius的輪替性和RingPaxos的負載平衡
的特色，並且利用 consistent hashing 的方
式來做出環狀拓樸，依照 hash的方式來配
置伺服器位置，讓在分配伺服器的時候可
以更加的快速，並且儲存伺服器配置的位
置。在執行方面，採用三組固定的伺服器
或者當運行架構龐大的時候可以採用多組
伺服器來做為主要處理的主伺服器，主伺
服器採用輪替處理的方式，藉此來分擔主
伺服器的負載運算，其他的子伺服器負責
接受使用者訊息後，傳送給順時針最靠近
的主伺服器做決議，藉此達到分區的處理
的方式，可以更加提升本機制的擴充性。 
藉由模擬證明了我們的機制，在大量
訊息下，也可以維持著高輸出和低延遲的
效能，並且對於伺服器的擴充上，也可以
維持著整體的高效能，優於其他機制。 
本研究計畫所預計達成之目標皆如期
圓滿達成，其所設計出之 Area-based 
RingPaxos (ARP)已整理成篇，準備投付知
 1
出席國際會議報告 
 
第26屆IEEE進階資訊網路及應用國際會議 
 
莊博任 
 
淡江大學電機工程學系 
 
 
一、參加會議經過 
 
    IEEE進階資訊網路及應用國際會議（IEEE International Conference 
on Advanced Information Networking and Applications） 為一年一度之國
際性學術研討會，今年已是第26屆，由日本福岡工業大學（Fukuoka 
Institute of Technology）所主辦。來自世界各國之投稿論文計有四百四
十五篇，經審查結果有一百二十六篇被接受於會中發表，錄取率為百分
之二十八。 
 
    筆者很榮幸被接受兩篇論文，題目分別為「行動隨意網路中有效率
之路徑探尋與修護」（Efficient Route Discovery and Repair in Mobile 
Ad-hoc Networks）與「跨網域用戶間有效率且安全之密碼認證金鑰交換」
（ Efficient and Secure Cross-Realm Client-to-Client 
Password-Authenticated Key Exchange），前者於第一天隨意網路與路由
（Ad Hoc Networks and Routing AINA-S3B）、後者於第三天認證與安全
系統（Authentication and Secure Systems AINA-S8C）議程中發表。 
 
 
二、與會心得與建議 
 
    此一研討會之議程安排為三月二十六日至二十九日共四天，由於與
會者皆相當重視此次議程，準備充分，因此每一場次的演講說明都很受
肯定，可惜礙於流程緊湊無法盡興聆聽。會中每個人除宣讀自己的論文
外，亦踴躍聆聽他人之解說並熱烈討論發問，成功地達到汲取新知、傳
道解惑，並互相認識結誼的學術交流目的。筆者發表論文時，聽眾發問
相當踴躍，而筆者亦一一切題回答。筆者十分珍惜此次參與研討會時與
AINA-2012 
The 26th IEEE International Conference on 
Advanced Information Networking and Applications 
Fukuoka Institute of Technology (FIT), Fukuoka, Japan, March 26-29, 2012 
 
February 20, 2012 
Prof. Po-Jen Chuang 
Department of Electrical Engineering 
Tamkang University 
No. 151, Yingzhuan Rd., Tamsui Dist., New Taipei City 25137, Taiwan (R.O.C.) 
25137, Taiwan 
 
 
 
Dear Prof. Po-Jen Chuang, 
 
 It is my pleasure to invite you officially to participate in the 26th IEEE International Conference on 
Advanced Information Networking and Applications (AINA-2012) to be held in Fukuoka Institute of 
Technology (FIT), Fukuoka, Japan, during March 26-29, 2012. We would like you to present your papers 
“Efficient Route Discovery and Repair in Mobile Ad-hoc Networks” and “Efficient and Secure Cross-Realm 
Client-to-Client Password-Authenticated Key Exchange” in the session of the AINA-2012. We hope that you 
will be able to join the conference and look forward to seeing you shortly. 
 
Sincerely yours, 
 
 
 
 
 
Makoto Takizawa 
Steering Committee Chair 
AINA-2012  
 
 
 
 
 
 
 
AINA 2012 Conference Secretariat 
2-7-15 Ichigaya tamachi, Shinjuku-ku, Tokyo 162-0843, JAPAN 
Tel : +81-3-5562-3677   Fax : +81-3-5562-3666 
E-mail: aina2012@ilcc.com 
  
In sending a RREQ, if there is a valid route to the 
destination in the routing table of a middle node, the middle 
node will return a RREP to the source; otherwise, the 
destination must return the RREP by the end. Different from 
a RREQ, a RREP is transmitted in unicast, i.e., the middle 
nodes will build a forward route to the destination. After the 
source receives the RREP, it then transmits the data packet 
by the built forward route to the destination. 
z Route maintenance 
Route maintenance includes maintaining information 
in the routing table and managing the route breaking 
problem. Maintaining the information in the routing table 
can be easy: When a path is not used or updated in a period 
time, simply remove it from the table. When a route breaks, 
two measures can be taken.  One is to return a RERR (route 
error) to the source and clear the information of the broken 
route along the way. Receiving such a RERR, the source 
will attempt to rebuild a new route to the destination. The 
other is to make use of the local repair concept. If the 
broken point nears the destination node, the middle node (at 
the broken point) will broadcast the RREQ to search for an 
alternative route. If the destination finally gets the RREQ, it 
will send back a RREP and meanwhile complete the route 
repair job, to save route reconstruction time. 
2.2 Multi-path Routing Protocols 
A multi-path routing protocol is designed to balance 
the overhead of each route so as to maintain the quality of 
service. It uses the concept of fault tolerance to handle the 
route information change/destruction problem which results 
from node mobility in a MANET. The main idea is to build 
multiple paths between a pair of source-destination nodes 
during route searching and replying. Thus, when a current 
path fails, packets can be sent via an alternative path – to 
save the cost of searching for a new route. A number of 
multi-path routing protocols have been introduced in recent 
years [4-11]. The Ad-hoc On-demand Multipath Distance 
Vector routing (AOMDV) [4] stands as a major example. 
AOMDV searches a route by the sequence number in 
a RREQ – like AODV – but aided by two more parameters, 
the hop counts and the id of the first adjacent node to 
receive the RREQ first. Besides, the next hop in the routing 
table is replaced by a path table. When a node sends a 
RREQ, the first receiving neighbor node will put its own id 
into the RREQ and broadcast further on. When a middle 
node receives the RREQ, it will compare the hop counts in 
the RREQ with its own hop counts to see if it has ever 
received this RREQ from the source. If not and its hop 
counts are bigger than the hop counts in the RREQ: The 
middle node will record this path information and transfer 
the RREQ to the next hop. Otherwise, the hop counts will 
be changed by the smaller hop counts. Through this process, 
a middle node will be able to record many loop-less paths. 
Meanwhile, the destination node will reply a RREP to all 
received RREQ and eventually to the source node by these 
different paths – a multi-path route is then completed.  
After the route is built, the path with the least hops 
will be taken as the main transmission path. If a node 
detects that it gets off the transmission range from an 
adjacent node, it will check if there exist any paths with 
invalid next hops in the routing table: If yes, it will delete 
such paths. When a node realizes the alternative paths of a 
transmission route are all deleted, it will broadcast a RERR 
packet together with the destination id. Any node receiving 
the RERR will check if it has the route items specified in 
the message. If yes and the next hop of any path in the route 
item is also the source node of a RERR, delete the path. The 
same approach will be employed to see if any other route 
runs out of valid alternative paths: If so, send out a RERR 
again.  
AOMDV is able to pick up an alternative path from 
the built multiple paths to continue packet transmission 
when encountering path damages. It reduces packet drop 
ratios and route repair time. There are also disadvantages. 
For instance, the destination node needs to reply a RREP to 
each RREQ, consuming more control packets than AODV 
in a single route search. It also produces higher network 
congestion because each node needs to save multiple (but 
mostly unused) paths for alternative routing and for sending 
a RERR when detecting any invalid path (to prevent upper 
nodes from using it). Besides, its required RERR packet is 
longer and the delivery ratio is higher. 
2.3 Local Route Repair Mechanisms 
Route repair is another way to restore a transmission 
path which fails due to node mobility. AODV has an 
original but simple route repair mechanism: If a node 
detects the next hop of a transmission path breaks, it will 
start route repair only when the hop counts in the routing 
packet exceeds the hop counts between itself and the 
destination. The repair process is as follows. The node 
rebroadcasts a RREQ to the destination: If not receiving a 
RREP in a certain period of time, it will drop the packet and 
send a RERR to the source node. This process has apparent 
problems. By flooding a RREQ, all nodes (except the 
destination and the node that replies the RREP) will receive 
and transfer the RREQ. The needed bandwidth comes close 
to that for route reconstruction. Such a route repair approach 
may raise packet arrival ratios in some circumstances but 
 
Fig. 1. An MPR set selection example. 
392
  
in the Hello message of node B, as D is the 1-hop tuple for 
A, A will record only <B, C>. 
3.2 Route Searching and Replying  
Our RREQ is basically similar to that of AODV, except 
that ours encloses the previous two-hop IP address and the 
forward node IP addresses. When a source node issues a 
new RREQ, it will record NULL in the previous two-hop IP 
address and add its ID into the originator and the previous 
hop IP addresses, calculate the nodes which need to 
rebroadcast with MPR and the 2-hop neighbor table, and 
add these nodes into the forward node IP addresses. Any 
node receiving the RREQ will check if this sender is in its 
routing table: If not, update by the information and build a 
reverse route. After updating route information, a node 
checks the ID: If having received the same RREQ or its 
own ID is not in the forward node IP addresses, drop the 
packet; otherwise, record the sender ID into the previous 
two-hop IP address, generate new forward node IP 
addresses and rebroadcast the RREQ until the destination 
node receives it or until TTL≦0 in the RREQ.  
After the destination receives the RREQ, RREP will be 
sent back to the source by unicast. Our RREP resembles 
that of AODV except an additional field – the previous two-
hop IP address. That is, the destination will record NULL in 
the previous two-hop IP address and add its ID into the 
destination and the previous hop IP addresses before 
forwarding the RREP packet.  
3.3 Route Maintenance and Repair 
Each node will periodically maintain the already-built 
routes. Besides the original items of AODV, we have two 
more items – last_time_used and largest_hops_forwards. 
Nodes learn about route damage by two ways: the return 
report of link layers and the periodical update of neighbor 
tables. Our routing protocol deals with the link layer issue 
only – because the return report of the link layer carries 
more instant and urgent message: An invalid node appears 
right here in this very spot of this transmission route. 
In our protocol, when a node receives ACK from a link 
layer and realizes the current packet transmission fails, it 
will check the ID of the next hop, delete it from its 1-hop 
and 2-hop neighbor tables, and check if the packet is a data 
packet. If not, drop it; if yes, return it to the route layer and 
start to repair the route. Conditions for repairing a route: 
(1) The current route does not expire or is not under repair. 
(2) The next 2-hop neighbor (N) must be valid and at least 
one of the 1-hop neighbors connecting to N must be valid. 
(3) The next-hop node is not the destination node. 
(4) The value of last_time_used must be less than 1.5 times 
packet delivery period earlier than the current time. 
If a damaged route fits all the conditions, start the 2-hop 
repair process. Otherwise, check the largest_hops_forwards:  
If the value is bigger than the hop counts to the destination, 
employ the AODV repair mechanism; if smaller, invalidate 
the route, generate a RERR packet which records all invalid 
destinations and broadcast the packet (same as AODV). 
To conduct a 2-hop repair, we (1) get a 1-hop neighbor 
which has the longest expiration time and connects to the 2-
hop neighbors (based on the next 2-hop neighbor tables), (2) 
generate a RPRQ carrying the destination ID and the node’s 
sequence number, and (3) send the packet to the next 2-hop 
node via the picked 1-hop neighbor. Receiving such a 
RPRQ, a node will check if the destination is itself. If not, 
add its ID into the previous hop IP address and broadcast 
the packet. If yes, generate a RPRP, fill in route repair 
information and send the packet to the RPRQ originator via 
the next-hop nodes. When facing interrupted transmission 
or invalid route repair information (in the RPRQ), a node 
will return a RPF (repair failure) – not a RPRP – to the 
source.  
Receiving a RPRP, a node will check if the destination 
ID matches its own. If not, update route information based 
on the route repair information in the packet, add its ID into 
the previous hop IP address and broadcast the packet. If yes, 
the node recorded in the previous hop IP address of this 
RPRP becomes the new next-hop node, update this route 
following the route repair information in the RPRP and 
generate a RTCH (route change) packet. Add the failing 
next-hop node, the new next-hop node and the updated 
route information into the packet. Broadcast it to notify 
neighbors that this route has been fixed. After neighbors 
receive the RPRP, the 2-hop repair operation is completed.  
If a node sends out a RPRQ but receives no RPRP or 
RPF in a period time, it will look into the hop counts: If the 
value of largest_hops_forwards exceeds the hop counts 
between itself and the destination, repair the route as AODV; 
otherwise, generate a RERR and broadcast it. 
A complete 2-hop repairing process of our protocol is 
given in Fig. 3. As we can see from the original network 
state, there is a connection between nodes S and D (a), and 
this connection breaks when node E moves (b). Node B 
detects this disconnection and starts the 2-hop repair 
mechanism. It first searches the 2-hop neighbor table to 
locate the next 2-hop node G and sends a RPRQ to G by F 
(c). After receiving the RPRQ, G returns a RPRP to B by F 
(F then records the new route to D). When B receives the 
RPRP, it updates F as the new next 1-hop neighbor to D, 
and broadcasts a RTCH to notify A of this change. Node A 
then picks F (instead of E) as its next 2-hop neighbor to D 
(d), and completes the 2-hop route repair (e). 
 
394
  
z Packet delivery ratios (PDR)  
PDR = the total CBR packets received by all destinations 
÷ the total CBR packets delivered from all sources (i.e., the 
ratio that a packet is successfully sent from the source to its 
destination). Figs.4 and 5 depict PDR of each protocol for 
different CBR session counts and maximum mobility. In 
Fig. 4, when CBR session counts increase, PDR decreases 
for protocols not incorporated with MPR because the 
rapidly increased RREQ amount congests the network. Our 
protocol produces higher PDR than MPRDV and MMDV 
because our 2-hop repair mechanism can repair all current 
routes.  In Fig.5, all protocols yield nearly the same PDR at 
node mobility = 0. When node mobility increases, the 
advantage of employing MPR appears: Significantly 
reduced control packet amounts and route searching time – 
along with shorter new routes – brings higher PDR. Our 
protocol performs the best due to its ability to repair most 
damaged routes at small cost. In fact, our 2-hop neighbor 
tables can fix route damages even if all original nodes of a 
route run out of the communication range of the to-be-
repaired node.  
z Average hop counts (AHC) 
AHC = total hop counts travelled by all packets that reach 
destinations successfully ÷ the number of these packets.  
Figs.6 and 7 give AHC at different session counts and 
mobility. At session count = 100, protocols using MPR take 
fewer AHC than those not using it – because original routes 
built by MPR broadcast are usually shorter than those built 
by flooding. When session counts increase, AHC decreases 
for AODV and AOMDV because packet congestion results 
in packet dropping in longer routes. By contrast, AHC 
decreases in a lesser way for protocols using MPR 
broadcast as they suffer less from congestion and packet 
dropping. In Fig.7, protocols using MPR broadcast yield 
quite close results and so are protocols without MPR. When 
mobility grows, AOMDV, MMDV and our protocol depict 
higher AHC due to higher packet arrival rates, whereas 
AODV and MPRDV keep lower AHC because they are 
more likely to rebuild routes which get close to the shortest 
paths. 
z Delay per hop (DPH) 
DPH = the average end-to-end delay of a successfully 
delivered packet ÷ the average number of hop counts the 
packet has travelled. Packet delay evaluation usually refers 
to the average time for completing a successful packet 
transmission. This is nevertheless an unfair measure for 
protocols with good route repair ability and high PDR – 
because protocols able to fix routes rapidly usually take 
longer to transmit the rearranged packets (which tend to 
have larger hop counts). To attain better evaluation, we 
mind also the total hop counts, i.e., we take into account 
both the end-to-end delay and DPH.  
Fig.8 gives the end-to-end delay at varied session counts. 
It shows that AODV and AOMDV yield shorter delay time 
at smaller session counts, but when the counts grow, delay 
 
Fig. 4. PDR vs. session counts. 
 
Fig. 5. PDR vs. maximum mobility. 
 
Fig. 6. AHC vs. session counts. 
 
Fig. 7. AHC vs. maximum mobility. 
 
Fig. 8. The end-to-end delay vs. session counts. 
396
  
to send RERR. Fig.14 displays CO at varied mobility, with 
bandwidth = 54Mbps. Here, the overhead difference for 
AOMDV and AODV lessens (in Fig.13, AOMDV faces 
worse congestion and more RERR). For MMDV and 
MPRDV, the overhead difference remains the same – 
because, with MPR, MMDV can efficiently reduce network 
congestion. When mobility increases, our cost comes closer 
to that of MPRDV. This is expectable as increased mobility 
will generate more broken routes and our protocol tends to 
repair all emerging broken routes, hence consuming more 
bandwidth. For MPRDV, there are more chances to rebuild 
a new route – with fixed cost – when facing route damages, 
which makes  its CO less affected by mobility change. 
V. CONCLUSIONS 
This paper presents a desirable new routing protocol to 
attain efficient transmission for a highly active MANET. 
Based on MPR broadcast and a 2-hop route repair 
mechanism, our protocol can reduce the bandwidth cost due 
to route searching and perform efficient local repair by 2-
hop neighbor tables. As route repair is carried out by unicast 
transmission, we can repair routes rapidly and efficiently – 
to handle the frequent recurrence of route damages in high-
mobility networks. Simulation results show that when 
compared with other routing protocols such as AODV, 
AOMDV, MPRDV and MMDV, ours performs constantly 
better in packet delivery ratios, average hop counts, delay 
per hop and control overhead.  
ACKNOWLEDGMENT 
This work was supported in part by the National Science 
Council, Taiwan, R. O. C., under Grant No. NSC 100-2221-
E-032-063. 
 
REFERENCES 
[1] L. Liang, Y. A. Sekercioglu, and N. Mani, “A survey of multipoint 
relay based broadcast schemes in wireless ad hoc networks,” IEEE 
Communications Surveys and Tutorials, vol. 8, no. 1-4, pp. 30-46, 
Dec. 2006. 
[2] C. E. Perkins and E. M. Royer, “Ad hoc on-demand distance vector 
(AODV) routing,” Internet Draft, Mobile Ad Hoc Networking 
Working Group, Mar. 2001. 
[3] G. Allard, P. Jacquet, and L. Viennot, “Ad hoc routing protocols with 
multipoint relaying,” 5eme Rencontres Francophones sur les aspects 
Algorithmiques des Telecommunications, 2003. 
[4] M. K. Marina and S. R. Das, “On-demand multipath distance vector 
routing for ad hoc networks,” Proc. 2001 International Conference on 
Network Protocols, Nov. 2001, pp. 14-23. 
[5] A. Mtibaa and F. Kamoun, “MMDV: multipath and MPR based 
AODV routing protocol,” Proc. IFIP 5th Annual Mediterranean Ad 
Hoc Networking Workshop, 2006, pp. 137-144. 
[6] S. Mueller, R.P. Tsang, and D. Ghosal, “Multipath routing in mobile 
ad hoc networks: issues and challenges,” Proc. 11th International 
Symposium on Modeling, Analysis and Simulation of Computer and 
Telecomm. Systems Tutorials, 2003, pp. 209-234. 
[7] S. J. Lee and M. Gerla, “AODV-BR: Backup routing in ad hoc 
networks,” Proc. 2000 IEEE Wireless Communications and 
Networking Conference, 2000, pp.1311-1316. 
[8] J. Cai and W. Wu, “Degraded link-disjoint multipath routing in ad 
hoc networks,” Proc. 4th International Symposium on Wireless 
Pervasive Computing, 2009, pp. 1-5. 
[9] B. Xue, P. Y. Ren, and S. C. Yan, “Link optimization ad hoc on-
demand multipath distance vector routing for mobile ad-hoc 
networks,” Proc. 5th International Conference on Wireless 
Communications, Networking and Mobile Computing, 2009, pp .1-6. 
[10] J. J. Galvez, P. M. Ruiz, and A. Skarmeta, “Achieving spatial 
disjointness in multipath routing without location information,” Proc. 
2009 Wireless Communications and Networking Conference, 2009, 
pp. 5-8. 
[11] S. Wang, Q. Li, Y. Jiang, and H. Xiong, “Stable on-demand 
multipath routing for mobile ad hoc networks,” Proc. 2009 Asia-
Pacific Conference on Computational Intelligence and Industrial 
Applications, 2009, pp. 318-321. 
[12] G. Liu, K. J. Wong, B. S. Lee, B. C. Seet, C. H. Foh, and L. J. Zhu, 
“PATCH: a novel local recovery mechanism for mobile ad hoc 
networks,” Proc. 2003 IEEE Vehicular Technology Conference, Oct. 
2003, vol. 5, pp. 2995-2999. 
[13] W. K. Lai, S. Y. Hsiao, and Y. C. Lin, “Adaptive Backup Routing for 
Ad Hoc Networks,” Computer Communications, vol. 30, issue. 2, pp. 
453-464, Jan. 2007. 
[14] W. Ge and P. W. Li, “(OPTAODV) An optimized AODV protocol 
for ad hoc network,” Proc. 4th International Conference on  Wireless 
Communications, Networking and Mobile Computing, 2008, pp. 1-4. 
[15] M. Pan, S. Y. Chuang, and S. D. Wang, “Local repair mechanisms 
for on-demand routing in mobile ad hoc networks,” Proc. 11th Pacific 
Rim International Symposium on Dependable Computing, December 
2005, pp. 1-8. 
[16] J. Singh, P. Singh, and S. Rani, “Enhanced local repair AODV 
(ELRAODV),” Proc. 2009 International Conference on Advances in 
Computing, Control, and Telecommunication Technologies, Dec. 
2009, pp. 787-791. 
[17] J. Sirilar and K. Rojviboonchai, “OHO: overhearing on-demand route 
repair mechanism for mobile ad hoc networks,” Proc. 2010 
International Conference on Electrical Engineering/Electronics 
Computer Telecommunications and Information Technology, May 
2010, pp. 66-70. 
[18] S. Y. Ni, Y. C. Tseng, Y. S. Chen, and J. P. Sheu, “The broadcast 
storm problem in a mobile ad hoc network,” Proc. 1999 International 
Conference on Mobile Computing and Networking, 1999, pp. 151-
162. 
[19] B. Williams and T. Camp, “Comparison of broadcasting techniques 
for mobile ad hoc networks,” Proc. 3rd ACM International 
Symposium on Mobile Ad Hoc Networking and Computing, 2002, 
pp, 194-205. 
[20] “The VINT project: the network simulator - ns-2,” Available: 
http://www.isi.edu/nsnam/ns.
 
 
Fig. 14. CO vs. maximum mobility with 54Mbps. 
398
II. BACKGROUND STUDY 
2.1 Possible Attacks  
*dictionary attacks (DAs): An attacker continues to guess 
the password and verify the correct one through the return 
message. There are  
(1) online DAs: An attacker guesses the password directly 
using key authentication with the server, and successfully 
interpret the return message when guessing right. 
(2) undetectable online DAs: Similar to online DAs 
except that the server can not detect the ongoing attack. 
(3) offline DAs: An attacker collects the client 
authentication packet by eavesdropping and calculates the 
client's password from the collected packet. (Both offline 
DAs and undetectable online DAs can lead to the more 
serious impersonation attacks.) 
*man-in-the-middle attacks: An attacker can join 
communication between two parties by tampering the 
authentication information, without being detected. 
*unknown key-share attacks: An attacker can authenticate 
with the server by modifying a client’s identity and when the 
client thinks he is communicating with a fixed target, he is 
actually communicating with the attacker. 
*known-key attacks: An attacker fetching a communication 
key from a specific communication (e.g., by Denning-Sacco 
attacks) can actually use it to snatch information of other 
communications. A protocol able to resist such attacks is 
said to satisfy forward security. 
*Denning-Sacco attacks: When an (insider) attacker knows 
how to make a communication key, he can use the key and a 
target client's information (such as ID) to produce the 
client’s communication key. 
*replay attacks: An attacker may intercept a client’s 
authentication packet and use it to re-authenticate with the 
server. If passing certification, he can impersonate the client. 
*denial-of-service attacks: An attacker can paralyze a 
server by sending lots of meaningless messages to it. 
*impersonation attacks: An attacker obtains a client's 
password and uses the fake identity to attack other clients or 
the server. Without advanced identity checking mechanisms, 
such an attack is hard to resist.  
*password-compromise impersonation attacks: An 
attacker obtains the password of a client (say A), uses it to 
masquerade as other clients and communicate with A. It may 
happen to clients of general protocols who communicate 
based only on passwords. (Both password-compromise 
impersonation attacks and impersonation attacks are 
key-compromise impersonation (KCI) attacks). 
 
2.2 Existing C2C PAKE Protocols 
  Some C2C PAKE protocols perform/support 
authentication (i.e., verify identity) by smart cards which 
can modify data by physical contact or induction, store 
clients’ authentication information and perform 
encryption/decryption operations. A basic C2C PAKE 
protocol operates as follows. To initiate communication, 
client A first sends a communication request to the server. 
The server will send A a Ticket packet after verifying his 
identity. A then passes the Ticket to his target client at this 
communication attempt (say B). B will, in turn, send his 
authentication information along with the Ticket to the 
server. The server then verifies the identity of B by the 
received information and sends A negotiation information 
for him to negotiate a communication key with B. To 
facilitate later discussions, a brief introduction on major 
C2C PAKE protocols is provided below.   
*Byun’s Protocol [6]: Being the first C2C PAKE protocol, 
it (Fig. 4) has two major problems:  
(i) As a large number of packets contain password 
information, an adversary can grab Epwa(gx), Epwa(gy), 
Epwb(gx’) and Epwb(gy’) from communication (Fig. 4 (A)) 
and use the information to conduct offline DAs.  
(ii) An adversary can also use Ticket B which contains 
gpwa · r (Fig. 4 (B)) and subsequent negotiation information 
to conduct offline DAs. 
*Feng’s Protocol [11]: To solve the problems, this protocol 
lets packets carry less password information and adds 
asymmetric encryption in Tickets and certification (Fig. 5 
(A), involving both private and public keys). This protocol 
uses the password only once for authentication between the 
server and client, and because the packet comes from the 
server to the client (Fig. 5 (B)), an adversary can not guess 
the password by it, largely reducing possible offline DAs. 
Feng’s Protocol has its own problems: 
(i) Asymmetric encryption increases the operation cost. 
(ii) In order to pass a packet that contains the password 
Fig. 4. Byun’s Protocol. 
702
 As Fig. 9 exhibits, our protocol can resist off-line DAs 
because (1) RA’ = RA” = h1(IDA)αx mod p (the value of Mod 
Calculation remains equal after addition, multiplication and 
exponentiation – see the following calculation details), and 
(2) the transmission packets containing RA’ and WA also 
contain random numbers and never use passwords after this 
phase.  
RA’ = (RA - h1(PWA))α mod p = ((h(IDA)x + h(PWA) mod 
p) - h1(PWA))α mod p 
RA” = WAx mod p = (h1(IDA)α mod p)x mod p 
RA’ = RA” = h1(IDA)αx mod p 
3.2 Employing the Diffie-Hellman Operations 
Our protocol uses a set of Diffie-Hellman operations to 
enhance transmission security (Fig. 9) because  
(1) an adversary with no password can not launch attacks 
(to intercept a transmission packet, it needs the password to 
get the result of the Diffie-Hellman operations), and  
(2) the number of packets containing passwords will not 
grow, reducing the risk of DAs. (In Fig. 9 (E), (A) adds a 
Diffie-Hellman operation and uses G to encrypt packets. For 
easier cross-reference, the original Smart Card 
authentication packet [12] is shown in Fig. 10.) 
By adding the Diffie-Hellman calculation and using 
parameters obtained from such a calculation to encrypt the 
authentication packet, our protocol can keep an adversary 
with no passwords from launching attacks. The involved 
additional cost will be 2 Diffie-Hellman calculations and 4 
times of symmetric encryption. 
3.3 Exchanging Parameters 
Our protocol uses the same way as Ding’s Protocol to 
exchange parameters. In Fig. 9 (D), the parameters that 
Ding's Protocol broadcasts are placed in the initial Smart 
Cards, reducing two times of extra transmissions when 
compared with Feng’s Protocol (Fig. 11).  
3.4 Using Asymmetric Encryption 
Our protocol adds asymmetric encryption in both the 
authentication packet (Fig. 9 (B)) and the Ticket (Fig. 9 (C)) 
to ensure that, without the private key, an adversary can not 
crack the safety. In the Ticket, PubSB makes sure only server 
B can decrypt the packet, while PriSA guarantees the packet 
is sent from server A and an attacker can not decrypt it even 
when the shared key between servers (k) is compromised. 
Fig. 8. Ding's Protocol. 
Fig. 9. Our new Smart Card Protocol. 
Fig. 10. The original Smart Card authentication packet. 
 
Fig. 11. Reducing extra transmissions.
704
breaking  the encryption and decryption qStaticKey ．
AdvccaSE(Tse,qe,qd).  
 Case2: The attacker gets K → the probability of 
successfully verifying k = the probability of breaking the 
asymmetric encryption qStaticKey．Advcca2G(Tcca2). 
As the Ticket is used 3 times, we have  
|Pr[Succ2]− Pr[Succ3] 3qStaticKey．(AdvccaSE(Tse,qe,qd)+ 
Advcca2G(Tcca2))         (4) 
Exp3 may verify the probability that an attacker can crack 
the Ticket. In Case1, the attacker gets the private key by 
qStaticKey and cracks the symmetric encryption of K by 
AdvccaSE(Tse,qe,qd). In Case2, the attacker gets K by qStaticKey 
and cracks on asymmetric encryption Advcca2G(Tcca2). 
Exp4: Used to verify the probability that an attacker can 
counterfeit MAC, which will be AdvcmaMAC(Tmac,qt,qv). 
MAC is used 2 times (Ea and Eb), so we get  
 |Pr[Succ3]−Pr[Succ4]|2AdvcmaMAC(Tmac,qt,qv)   (5) 
Exp5: Replace DDH by U=gu, V=gv and Z=gr. The 
probability that an attacker can distinguish DDH from U, V 
and Z equals the probability he can crack DDH, i.e., 
AdvddhG(Tddh). Thus                
 |Pr[Succ4]−Pr[Succ5]|AdvddhG(Tddh)    (6) 
The probability that Exp5 succeeds actually equals the 
probability that the attacker guesses sk by ways not 
mentioned above – including at least the probability of using 
Corrupt(Ci,2) and online DAs qsend/2|D|. Thus, 
 Pr[Succ5] ≤ (qSendClient +qSendServer)/2|D|+1/2   (7) 
By(1)~(7), we have  
AdvakeD(t,R)≤(qE2+qh12+ qh22+qh32)/(q−1)+ qStaticKey．
AdvdlG(Tdl)．(AdvddhG(Tddh)+Advcca2G(Tcca2))+3qStaticKey．
(AdvccaSE(Tse,qe,qd)+Advcca2G(Tcca2))+ 
2AdvcmaMAC(Tmac,qt,qv)+ AdvddhG(Tddh)+ (qSendClient 
+qSendServer )/2|D|+1/2. 
In ideal conditions, the chance for an attacker to break 
down all encryption mechanisms is nearly none.  Note that 
both the dictionary/password length and the number of 
oracles the attacker uses are as large as infinite. When q and 
D approach infinite while AdvdlG(Tdl), AdvddhG(Tddh), 
Advcca2G(Tcca2), AdvccaSE(Tse,qe,qd) and AdvcmaMAC(Tmac,qt,qv) 
are approximately zero, Advpaket,D(A) = 2．1/2-1 – a near zero 
value, indicating an attacker has almost no chance to break 
this protocol under ideal conditions. According to this 
security model, an attacker can eavesdrop, send packets and 
obtain sk to launch a general attack or break BR security, or 
obtain a static key (that also contains the server’s private key) 
to reach KCI and LEP attacks. That is, this model can verify 
if a protocol is tough enough to maintain BR+ KCI+LEP 
security, not just the general BR security. 
4.3 The Security of Other Protocols 
AidkeyC2C attains BR but not KCI security as password 
leakage may cause attacks (an attacker can counterfeit X” by 
the password – Fig. 12), and so does Ding’s Protocol (an 
attacker can use the obtained password to decrypt EX and 
ER – Fig. 13). Jin’s Protocol can reach KCI security only if 
its Smart Card is secure; if not (e.g., password leakage), it is 
vulnerable to KCI attacks. For Feng’s Protocol, a safe 
 
Fig. 12. AidkeyC2C Protocol’s weakness. 
 
Fig. 13. Ding’s Protocol’s weakness. 
 
Fig. 14. Feng’s Protocol’s weakness. 
Table I. Calculation times and security comparisons 
Table II. Calculation cost comparison – complexity 
Table III. Cost comparison among protocols – complexity 
706
involving commercial transactions or medical practices. For 
instance, when clients are engaging banking or medical 
activities, they can meanwhile create or update the Smart 
Card to ensure security passage.  
 
0
100
200
300
400
500
600
4 8 16 32 64
Password length
(bits)
Co
mp
lex
ity
Asymmetric
encryption(O((log2e)(log2
n)2))
Asymmetric
decryption(O((log2d)(log2
n)2))
Symmetric encryption、
Hash、MAC(O(log2n))
Mod(O(log3n))
Diffie-Hellman(O(√p))
Fig. 16. Calculation cost comparison – complexity. 
Fig.17. Complexity comparison among various protocols 
V. CONCLUSIONS 
To fight against the ever-growing malicious attacks in 
today’s wireless environments, i.e., to attain more desirable 
communication security for wireless networks, this paper 
presents a new and advanced cross-realm C2C PAKE 
protocol – based on Jin’s Protocol that allows clients to 
exchange Smart Card information and attain authentication 
by Mod Calculation. Aided by Mod Calculation, a set of 
Diffie-Hellman operations, Ding’s parameter exchange 
approach and asymmetric encryption, our new protocol 
employs client passwords, Smart Card information and 
server private keys to form a strong security protection 
mechanism. The key advantage of our protocol is, when 
both client passwords and server private keys are snatched 
by adversaries, communication security can still be 
sustained. Security evaluation (by Yoneyama’s Model) and 
cost comparison (in terms of calculation times and 
complexity) show that, at reasonable cost, our C2C PAKE 
protocol outperforms related protocols in security gain – 
being able to defend BR, KCI and even LEP attacks.  
ACKNOWLEDGMENT 
This work was supported in part by the National Science 
Council, Taiwan, R. O. C., under Grant No. NSC 
100-2221-E-032-063. 
REFERENCES 
[1]. M. Abdalla, P.-A. Fouque, and D. Pointcheval, “Password-based 
authenticated key exchange in the three-party setting,” Proc. Public 
Key Cryptography’05, 2005, LNCS 3386, pp. 65-84. 
[2]. M. Bellare, D. Pointcheval, and P. Rogaway, “Authenticated key 
exchange secure against dictionary attacks,” Proc. Advances in 
Cryptology - EUROCRYPT 2000, May 2000, LNCS 1807, pp. 
140-156. 
[3]. M. Bellare, and P. Rogaway, “Entity authentication and key 
distribution,” Proc. Advances in Cryptology - CRYPTO '93, 1994, 
LNCS 773, pp. 232-249. 
[4]. M. Bellare, and P. Rogaway, “Provably secure session key 
distribution - the three party case,” Proc. 28th Annual ACM Symp. 
on Theory of Computing, May 1996, pp.57-66. 
[5]. D. Boneh, “The decision Diffie-Hellman problem,” Proc. 3rd 
Algorithmic Number Theory Symposium, 1998, LNCS 1423, pp. 
48-63. 
[6]. J. W. Byun, I. R. Jeong, D. H. Lee, and C.-S. Park, 
“Password-authenticated key exchange between clients with 
different passwords,” Proc. 4th Information and Communications 
Security, Dec. 2002, LNCS 2513, pp.134-146. 
[7]. R. Canetti and H. Krawczyk, “Analysis of key-exchange protocols 
and their use for building secure channels,” Proc. 2001 Advances 
in Cryptology - EUROCRYPT 2001, 2001, pp 451-472. 
[8]. T. Coffee, “Best kept secrets: elliptic curves and modern 
cryptosystems,” MIT 18.704, Fall 2004. 
[9]. J. Daemen and V. Rijmen, The Design of Rijndael: AES-The 
Advanced Encryption Standard, Springer-Verlag, 2002. 
[10]. X. Ding and C. Ma, “Cryptoanalysis and improvements of 
cross-realm C2C-PAKE protocol,” Proc. 2009 WASE Int’l Conf. 
on Information Engineering, 2009, pp. 193-196.   
[11]. D.-G. Feng and J. Xu, “A new client-to-client 
password-authenticated key agreement protocol,” Proc. 2009 Int’l 
Workshop on Coding and Cryptology, 2009, LNCS 5557, pp. 
63–76. 
[12]. W. Jin and J. Xu, “An efficient and provably secure cross-realm 
client-to-client password-authenticated key agreement protocol 
with smart cards,” Proc. 2009 Int’l Conf. on Cryptology and 
Network Security, 2009, LNCS 5888, pp. 299-314. 
[13]. H. Krawczyk, “HMQV: a high-performance secure Diffie-Hellman 
protocol,” Proc. Advances in Cryptology - CRYPTO’05, 2005, 
LNCS 3621, pp. 546-566. 
[14]. R. L. Rivest, “RFC 1321: The md5 message-digest algorithm,” 
Technical Report, Internet Activities Board, April 1992. 
[15].  X. Wang, Y. Yin, and H. Yu, “Finding collisions in the full 
SHA-1,” Proc. Advances in Cryptology - CRYPTO’05, 2005, 
LNCS 3621, pp. 17-36. 
[16]. W. P. Wardlow, “The RSA public key cryptosystem,” Proc. 1991 
Coding Theory and Cryptography, 1991, pp. 101-124.   
[17]. K. Yoneyama, "Efficient and strongly secure password-based 
server aided key exchange," Proc. INDOCRYPT 2008, 2008, 
LNCS 5365, pp. 172–184.
 
708
100年度專題研究計畫研究成果彙整表 
計畫主持人：莊博任 計畫編號：100-2221-E-032-063- 
計畫名稱：雲端資料庫 NoSQL 技術之探討與開發 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 0 1 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 1 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 2 2 100%  
博士生 1 1 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
