for security protocols. Their logic has much influence in
the study verification; however, there are still flaws that es-
capes their logic. Previously, we proposed an exhaustive
testing method for security protocols [17].
The rest of the paper is organized as follows: The next
section summarizes the terms and notations used in this pa-
per. The third section discusses message-exchange forms.
The fourth section infers knowledge of the attackers as well
as the legitimate participants. The last section concludes
this paper.
2 Preliminaries
In this paper, we will use the following Needham-
Schroeder protocol [11, 13] as an example.
1. A→ S : A,B,Na
2. S → A : {Na,B,Kab, {Kab,A}Kbs}Kas
3. A→ B : {Kab,A}Kbs
4. B → A : {Nb}Kab
5. A→ B : {Nb− 1}Kab
The key Kas is a shared key between A and S, which is
established before a session of the Needham-Shroeder pro-
tocol starts. Similarly, Kbs is a pr-established shared key
between B and S. After a session of the Needham-Schroder
protocol, the new key Kab would be known exactly to A,
B, and S.
A security protocol consists of an partially ordered se-
quence of messages and a specification. Each message con-
sists of an ordered sequence of items. An item could be ei-
ther un-encrypted (which is called atomic) or encrypted. An
encrypted item consists of an ordered sequence of subitems
and an encryption key.
The specification of a security protocol include (1) the
keys and other relevant secrets each participant knows be-
fore a session of a security protocol, (2) public information
that everybody (including the attacker) knows before a ses-
sion of a security protocol, and (3) the information each
participant and the attacker know and do not know after a
session of the security protocol completes.
The legitimate communicating participants have some
previously established secrets, such as shared secret keys
and public keys. We assume that these previously estab-
lished keys are well kept away from attackers. A security
protocol cannot protect secrets once these keys are lost.
A session of a security protocol is made up of two ore
more participants, who send and receive messages. The
sender of the first message is the initiator of the session. In-
tuitively, the initiator is the participant who intends to com-
municate with other participants.
The purpose of (a session of) a security protocol is to es-
tablish a new key between communicating parties (the ini-
tiator of a session and a responder). This new key is called
the jewel of the session. For example, Kab is the jewel
in the above Needham-Schroeder Protocol. Some security
protocols may be capable of establish multiple new keys
among three or or communicating parties. Our technique
can be easily extended to these more capable protocols. The
intended holders of the jewel are called propositi. For in-
stance, in the above Needham-Schroeder Protocol, A and
B are the propositi whereas S, who knows the jewel, is not.
3 How can a receiver R believe in a message
that he receives?
For a receiver to believe in the authenticity and freshness
of a piece of information, the information must be properly
enclosed in messages. The messages of a security protocol
must consist of message-exchange forms. (We can guaran-
tee the secrecy of a piece of information only by examining
the whole security protocol and inferring what an attacker
can know. We will study secrecy guarantee in the next sec-
tion.)
The message-exchange form is either a basic form or its
variations. The basic form (from the perspective of the re-
ceiver R), shown below, consists of a pair of messages: a
challenge and a response. The challenge need not be en-
crypted; however, the response is usually encrypted.
R→ . . . : tokenr — a challege
. . .→ R : {jewel, tokenr}Kp — a reply
Here tokenr is generated by the receiver R and Kp is
the key that is agreed upon between R and (1) the intended
producer of the jewel or (2) a participant who has already
believed in jewel. Kp could be a shared that is established
before the current session of the security protocol starts or
it could be a key that is established in previous steps of the
current session.
These two messages guarantee, to R, the freshness and
authenticity of the jewel under the provision that the at-
tacker does not know jewel and Kp and the receiver R
must be able to know Kp. (There is a provision in every
form discussed in this section. In the next section, we will
show a method to check the provisions.)
To R, the freshness of jewel is guaranteed by tokenr,
which is generated by R. The authenticity of jewel is guar-
anteed by Kp, which is assumed to be a well-kept secret
between R and the legitimate participant who creates the
encrypted item {jewel, tokenr}Kp. Note that the two mes-
sages guarantees the authenticity and freshness of jewel
only to R, but not to other participants of the security pro-
tocol. Usually, R must present a proof of his identity addi-
tionally.
tokenr can be viewed as a passport announced by R.
Then R will treat whatever is bound with token (by a
behaved. When an attacker tries to fool others, he never
uses his real identity (so as to avoid being caught in the fu-
ture). The attacker always impersonates as someone else.
This is not a severe limitation. Most security protocols also
make such an assumption.
4 What does an attacker know?
The information contained in the messages of a security
protocol may belong to one of the two categories:
a. transient information those that is used only in the cur-
rent session
b. sustained information those that may be used in subse-
quent sessions.
Example. Consider the following protocol:
A→ B : {Ksession,Knew}Kold
In this protocol, Ksession is the key for the current ses-
sion and Knew will replace Kold in the next session. Thus,
Ksession is a piece of transient information while Knew
is sustained. (In this case, Ksession is the jewel while
Knew is just a piece of information transmitted in the cur-
rent session.)
Since sustained information gathered from one session
might be useful in subsequent sessions, an attacker may
quietly observe several sessions of the security protocol to
obtain sufficient sustained information before launching his
attack. Thus, we first infer what an attacker can know af-
ter he observes enough sessions and then we infer what the
attacker can know immediately before each message of the
attacked session is sent out.
4.1 What an attacker canknowbefore he launches
an attack
We assume that the attacker does not know any secrets
initially. The legitimate parties knows suitable keys before
a session of the security protocol starts. We also assume
that the transmission media is subject to eaveasdropping.
This implies that an attacker is able to collect all messages,
though he probably could not decrypt the encrypted items.
It is easy to infer what the attacker could know at the end
of the whole session. There are two rules concerning the
inference:
1. If an item is transmitted in plain text, the attacker is
assumed to know the item right away.
2. If the attacker knows a keyK and items encrypted with
K, then the attacker can decrypt the encrypted items.
This rule is based on the generally accepted assump-
tion that the encryption algorithm itself is known to
the public.
Example. Consider the following protocol:
A→ B : K
B → C : {Q}K
C → D : {R,S}Q, {T}Kcd
At the end of a session of the protocol, the attacker would
know K, {Q}K , Q, {R,S}Q, R, S, and {T}Kcd, but he
knows neither Kcd and T .
4.2 What the attacker can know immediately be-
fore a message is sent
A common, but implicit property of a security protocol
is that there is an initiator (who is usually the sender of
the first message). When a participant receives a message,
he will send another message to another participant. We
say the first message triggers the second. We may draw
a trigger-graph in which each vertex represents a message.
If message A triggers another message B, there will be an
edge A → B. Usually the trigger-graph is a linear graph.
However, sometimes a message may trigger two or more
messages. In Protocol 4 in Section 3, the second message
triggers the third and the fourth messages. In that case the
trigger-graph is an acyclic directed graph.
On a trigger-graph, we may derive topological orders of
the vertices. Among the topological orders, we wish to find
the latest topological order.
Definition. Let G be a directed acyclic graph G. A topo-
logical order is a linear order of the vertices of G such that
if there is an edge X → Y in G, then X appears before Y
in the linear order.
Note that a directed acyclic graph may have more than
one topological order. In a topological order, the first vertex
is assigned the sequence number 1; the second is assigned
2. Similarly for other vertices.
Definition. Let A be a vertex in a directed acyclic graph
G, a latest topological order with respect to A is a topolog-
ical order in which the sequence number of A is no smaller
than that in any other topological order.
Example. Consider the graph in Figure 1. The orders
[C,D,B,E,A, F ] and [C,D,E,B,A, F ] are latest topo-
logical orders with respect to vertex A because in both or-
ders, the sequence number of A is 5. However, the topo-
logical order [C,B,D,A,E, F ] is not a latest topological
order with respect to A because the sequence number of A
is 4.
In terms of the trigger-graph, the latest topological or-
der with respect to a vertex (i.e., a message) A indicates the
message A is delayed as much as possible. From the lat-
est topological order with respect to vertex A, we may in-
fer what an attacker can possibly know immediately before
message A is sent out.
It is quite easy to compute a latest topological order with
respect to a vertex A in a directed acyclic graph. We par-
Example. We use two tables to summarize the p-knows
and n-knows relations for the Needham-Schroeder protocol.
Here is the p-knows relation:
pre-established inferred
p-knows atomic items atomic items
S Kas,Kbs Na,Kab
A Kas Na,Kab,Nb
B Kbs Kab,Nb
The p-knows table is good for checking if a security
protocol successfully distribute the relevant keys to the in-
tended participants. Usually, this is not a problem. The
major problem in analyzing a security protocol is to decide
what an attacker could know. This problem can be analyzed
with the help of the n-knows table, shown below.
pre-established inferred
n-knows atomic items atomic items
S Kas,Kbs Na,Kab, Nb
A Kas Na,Kab,Nb
B Kbs Kab,Nb, Na
D (a by-stander) Na
The n-knows table is more useful in estimating what at-
tacker could know if he is one of the participants of the pro-
tocol or if he is just a by-stander (by passively eavesdrop-
ping on the communication lines).
5 Conclusion
We have proposed four requirements of a correct se-
curity protocol—no-intrusion, authenticity, freshness, and
secrecy. The first three can be guaranteed with message-
exchange forms while the fourth can be guaranteed with p-
knows and n-knows, which are inferred from the latest topo-
logical orders of the trigger-graph.
References
[1] M. Abadi and R. Needham, “Prudent engineering
practice for cryptographic protocols,” IEEE Transac-
tions on Software Engineering, Vol. 22, No. 1, pp. 6-
15, January 1996.
[2] M. Burrows, M. Abadi, and R. Needham, “A logic of
authentication,” ACM Trans. Computer Systems, Vol.
8, No. 1, pp. 18-36, 1990.
[3] S.H. Brackin, “Automatically detecting most vulnera-
bilities in cryptographic protocols,” Proc DARPA In-
formation Survivability Conference and Exposition
2000 (DISCEX 00), Vol. 1, pp. 222-236, January 25-
27, 2000.
[4] J. Clark and J. Jacob, “A survey of authentication
protocol literature, Version 1.0,”, technical report,
York Univ., November 1997, available at http://www-
users.cs.york.ac.uk/ jac/.
[5] J. Heather, G. Lowe, and S. Schneider, “How to pre-
vent type flaw attacks on security protocols,” In Pro-
ceedings of 13th IEEE Computer Security Founda-
tions Workshop, 255-268, 2000.
[6] P. Janson, G. Tsudik and M. Yung, “Scalability and
flexibility in authentication services: The KryptoK-
inght Approach,” Proceedings of INFOCOM’97, Vol.
2, pp. 725 -736, 1997.
[7] A. Kehne, J. Schonwalder, and H. Langendorfer, “A
nounce-based protocol for multiple authentication,”
AMC Operating Systems Review, Vol. 26, No. 4, pp.
84-89, October 1992.
[8] C. Laferriere and R. Charland, “Authentication and
authorization techniques in distributed systems,” In
Proceedings of IEEE 1993 International Carnahan
Conference on Security Technology, pp. 164-170,
1993.
[9] Y. Li, W. Yang, and C.W. Huang, “Preventing type
flaw attacks on security protocols with a simplified
tagging scheme,” Journal of Information Science and
Engineering (accepted), July 2004.
[10] G. Lowe, “A hierarchy of authentication specifica-
tions,” In Proceedings of 10th Computer Security
Foundations Workshop, pp. 31-43, June 1997.
[11] R.M. Needham and M.D. Schroeder, “Using encryp-
tion for authentication in large networks of comput-
ers,” Communications of ACM, Vol. 21, No. 12, pp.
993-999, December 1978.
[12] B.C. Neumann and S.G. Stubblebine, “A note on the
use of the timestamps as nounces,” ACM Operating
Systems Review, Vol. 27, No. 2, pp. 10-14, April 1993.
[13] B.C. Neumann and Theodore Ts’o, “Kerberos: An
authentication service for computer network,” IEEE
Communications Magazine, Vol. 32, No. 9, pp. 33-38,
September 1994.
[14] L.C. Paulson, “Proving security protocols correct.” In
Proceedings of 14th Symposium on Logic in Computer
Science, 370-381, 1999.
[15] J.G. Steiner, C. Neumann, and J.I. Schiller, “An au-
thentication service for open network systems,” In
Proceedings of the Winter 1988 USENIX Conference,
pp. 191-202, 1988.
