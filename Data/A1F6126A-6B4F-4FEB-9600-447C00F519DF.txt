  
 
1 
行政院國家科學委員會專題研究計畫成果報告 
 
社交網路延遲感知同儕式好友群播技術 
Latency-Aware Peer-to-Peer Friendcast for Social Networks 
 
計畫編號 ：NSC 99-2628-E-008-011- 
執行期限 ：99 年 8 月 1 日至 100 年 7 月 31 日 
主持人  ：江振瑞    國立中央大學資訊工程系 
共同主持人 ：黃興燦   國立中央大學資訊工程系 
 
中文摘要 
本計畫提出一個同儕式頻寬及延遲感知好友群播(FriendCast, FC)的方法，可以讓線上社交
網路中的每個使用者利用同儕式的方法對所有的好友進行即時訊息的發佈。方法中每個使用
者對所有的朋友建立好友群播樹(FriendCast Tree, FCT)，首先系統仍會存在一個伺服器用來提
供註冊和登入功能以及輔助好友群播樹快速的建立。而新的使用者加入系統時會先向伺服器
註冊並擁有自己的網路座標(Network Coordinate, NC)，由於任兩個使用者間的資料傳送延遲和
彼此的網路座標距離成比例關係，所以我們可以藉由他們的座標點來預估任兩點間的延遲時
間，並作為建立好友群播樹的依據。我們在計畫中提出 Degree-Adapted Greedy Tree Algorithm 
(DATGA)，以可用外分支度預估(available out-degree estimation)方法來估計每個好友在好友群
播樹中合理的外分支度，並利用網路座標系統上座標點距離的關係，配合貪婪法則(greedy 
method)建立好友群播樹，達成資料發佈至所有朋友能有較小的網路延遲總和。藉著好友群播
樹，使用者只需對合理數量的鄰居以較低的延遲時間轉送訊息，因此具有高擴充性、頻寬及
延遲感知的特點。 
 
關鍵詞：社交網路、同儕式、朋友群播、擴展性、網路座標、朋友清單、異質網路環境 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
3 
一、前言 (Introduction) 
 
隨著網際網路的發達和普及，人與人之間的互動行為慢慢演變成利用網路的方式來取代
一般的信紙甚至是面對面交流。目前相當火紅的社交網站(Online Social Network, OSN)
不僅擁有與朋友之間交流的平台，更是提供了認識新朋友的窗口，並藉由 Flash小遊戲來增強朋
友們之間的鏈節，像 Facebook和 MySpace等。我們將這些利用網路應用程式與朋友的互動稱
為網路社交行為，而這些程式則稱作網路社交應用程式。 
現今一般的網路應用程式主要都是建構在主從式(Client-Server，C/S)的架構上，在這種架
構下，伺服器必頇儲存所有的資料、狀態，並處理所有用戶端的請求或行為，如下載、搜尋、
發佈或訂閱使用者的訊息。由於伺服器所擁有的頻寬和計算能力都是有限的，因此當使用者
人數超過伺服端所能負載的上限時，就會造成整體效能的衰退，雖然可以採用伺服器叢集
(server-cluster)來增加伺服端的效能，但還是無法改善可用資源的受限和使用者數量擴展(scale)
的問題。另外論文[3]提到當使用者將所有的訊息及資料存放在系統伺服器上，意味著每個人
可能會將自己比較私密的資料透露給系統的擁有者，難免就會存在著隱私性(privacy)和導致廣
告訊息氾濫的缺點；另一方面有些系統擁有者為了防止不當的檔案分享和訊息的散佈，因而
對於所有訊息的發佈做審查，間接限制了使用者發言的自由度。因此，為了解決擴充性、隱
私性和發言自由的限制，許多研究提出以同儕式架構的網路社交應用程式。 
PeerSoN[5][35]提出一個同儕式的網路社交應用程式，利用 DHT 的方式建立一個社交網
路系統，提供人名和檔案搜尋的服務，以及同步(如交談)和非同步(如離線留言)的訊息傳遞的
功能。但作法上需要利用 DHT 的朋友搜尋分別去取得每一個朋友的最新狀態如 IP、上線與
否等，再透過同步或非同步的方式分別將訊息傳送出去。當訊息的發佈很頻繁時，每次都要
對每一個朋友做搜尋的動作，是很不切實際的。而同步交談功能雖然是以即時的直接連線方
式，但是眾多的朋友數量或者受限的頻寬可能會導致猛發性(burst)上傳超載。考慮到上述問
題，論文[32]指出當多個傳送者(senders)和接收者(receivers)做一對多(one-to-many)、多對多
(many-to-many)或多對一(many-to-one)的資料傳遞時，群播(multicast)是一個有效率且實用的
方法，例如 videoconference，real-time multimedia 等皆應用於此。 
近年來有許多研究針對不同的需求提出了不同的群播演算法[6][19][21][22][24][29][37]，
這些方法各有其優缺點。但我們認為網路社交應用程式中使用者的每一個訊息發佈，主要的
目的是要主動地將最新狀態或檔案傳給他所認定的朋友們，對於不在朋友清單的其他人，沒
必要甚至也不想讓他們知道，因此我們覺得朋友間的訊息傳播最好只會傳給需要的人，甚至
每一個訊息轉傳也只要透過需要的人再往下傳遞，不希望經由多餘不相干的人身上，這樣可
以確保資料的隱私性，也能避免整個系統的頻寬消耗以及多餘的資料流動。上述的方法中並
沒有考慮到這些因素，所以在這此計畫中我們想要探討一個基於同儕式網路社交應用程式下
朋友間訊息傳遞的架構，我們將這種在朋友們之間做訊息的發佈以及訂閱所有的朋友訊息的
行為稱作朋友群播(FriendCast, FC)。 
我們提出一個 Degree-Adapted Greedy Tree Algorithm(DAGTA)來建立好友群播樹，首先建
立一個 2 維度的網路座標系統(Network Coordinate System, NCS)，讓每位好友對應到座標平面
中的一個座標節點，接著利用所提出的可用外分支度預估(available out-degree estimation)對於
異質性頻寬分佈環境中去估計好友群播樹中每個節點合適的外分支度數(即子節點數)。根據所
評估的每個節點的外分支度和座標系統中與自己的座標距離這兩個參數，利用貪婪法則
(greedy method)做父節點的選取以建立一棵好友群播樹使得由自己到所有朋友有較小的總延
遲量。而在實驗模擬方面我們分別對頻寬的限制與否去和數個群播樹演算法做比較，結果顯
  
 
5 
別以這些距離和地標的座標點來計算出一個座標，使得座標到每個地標的距離與測量的
網路距離差值最小。而論文[43]中的作者發現在 LBA 中地標的分佈對於座標預測的準確
性有很大的影響，如果要提高準確度時，就要針對這些節點的網路距離範圍大小來選取
不一樣的地標集合，才能夠提高系統預測的準確性。 
b) Simulation-Based Algorithm (SBA)，如 Vivaldi[12]、[36]。將每個網路節點跟其他節點的距
離對應到一個物理彈簧系統(physical spring system)，而每個節點的座標可以由最小化這個
spring system 的能量來決定。Pharos[9]中發現距離較短的節點相連所求出的網路座標的
相對誤差會大於距離較長的節點相連，並根據此觀察設計一個分散式且階層式的 NCS，
讓每個節點會根據與其它節點的網路距離做群組而擁有兩組以上的座標系統，並依照群
組關係來選擇使用何種座標因而提高網路距離範圍較小的預測精準度。而 Myth[11]則是
在 churn rate 很高的情況下探討並設計一個 LBA 結合 SBA 的混合式網路座標系統。 
 
3.群播樹繞徑演算法（Multicast Routing Algorithm） 
 
論文[32]提到不同型態的群播樹適用於不同的用途。Share tree algorithm 建立單一的群播
樹，資料的傳送可以是單向或雙向的，此樹適合少量的資料來源(source)情況，其好處是每個 
router 所需的維持資訊較少，但會存在集中的網路流量，也由於樹根或 core 或 Rendezvous 
Point(RP)到許多 receiver 的路徑長度較長，所以不適用於 delay-sensitive 的應用上。Source tree 
algorithm 對每個 source 個別建立群播樹，而 receiver 利用 reverse shortest path 連接到
source，所以可以提供較少的延遲花費，且平均的分散傳遞需求使得網路流量有較小的集中
性。Steiner tree 可以最小化一個群播樹的延遲花費，但建立此樹已經被證明是 NP-Complete 
的問題，所以有許多近似解的求法被提出來，如論文[23]。Reduced tree 是用來提高群播樹的
擴充性，作法是不使用 relay node，如論文[24]，它指出可以降低約 80%的 狀態資料維護。 
Pharos[9]、[45]利用三種建構 tree overlay 的演算法用來在網路座標系統上分析 NCS 的準
確度，而這三種演算法分別為 Minimal Spanning Tree (MST)、modified ESM[7]和 LGK[8]，他們
指出這三種演算法可以包括大多數  overlay multicast protocols 的兩個必要的基礎方式 
(building blocks)：shortest link selection 和 proximity-based clustering。本計畫的實驗模擬也實
作出此三個演算法並與本篇所提的作法做比較。 
VoroCast[20]將 2 維平面上的座標點做 Voronoi diagram[1]切割，此動作會將平面依照座
標點的位置分成好幾個相同數量的 Voronoi  region，如圖 1.中的每個 convex hull 即為一個 
Voronoi region。根據每個 region 的相對關係，相鄰的 region 節點稱作 enclosing neighbor，
如 VON[16]。建立群播樹的父節點選擇依循以下規則：1)  當為根節點的 enclosing neighbors 
時，則根節點即為父節點。2)  對於不為根節點的 enclosing neighbor 節點，則選擇所有其 
enclosingneighbors 中距離根節點最近者為父節點。 
  
 
7 
統的特性，產生一個有利於自己發佈訊息時擁有延遲感知的作用，而所有訊息發佈的傳遞方
式皆用推(push)的形式，是主動的將每個使用者發佈的訊息直接傳送給其朋友，而新登入的朋
友則會利用拉(pull)的方式主動去取得應該知道的資料。 
 
2. 好友群播樹建立 
 
使用者在登入系統後，會擁有並持續維護著目前已登入在線上的朋友清單，清單中儲存
著每位好友的資訊，包括 ID、IP 及 NCS 上的座標等資訊。而我們的目的就是要藉著朋友清
單的資訊去建立一個好友群播樹，以便可以有效率的去對好友做檔案發佈。有效率的發佈除
了考慮傳送延遲之外，還需要考慮每個使用者能力的不同。對於現實網路來說，每個人皆有
上傳頻寬的限制，因此直接連線的作法對於可能會造成某個節點上傳頻寬的超載。所以建立
有效的 FCT 時不僅只考慮傳送的延遲，更需要考量到每個朋友的上傳能力以便轉傳時不會超
過負載。 
在異質性網路下，朋友清單中還需要額外去紀錄每個朋友的上傳頻寬能力，根據頻寬來
設定每個朋友在 FCT 上的外分支度：上傳頻寬越大，就越有能力可以幫忙轉傳。假設 0n 欲發
佈一個大小為 S 的檔案給所有朋友，而其某個朋友 in 的上傳頻寬為 iC ，則 in 最多可以幫忙 0n
對 





S
Ci
個朋友轉傳，故 0n 可以將此值視為 in 在其 FCT 中的外分支度。而另一方面當 in 在時間
t 時的朋友數為 tif , ，在此我們假設 t 為一個離散時間或是系統的時間戳記，而每個人發佈的
檔案大小為 S，則 in 最多會被要求對 tif ,  





S
Ci
  S 個使用者做轉傳，但是 tif ,  iC  > iC 已經
超出 in 的上傳頻寬，因此只考慮檔案大小及上傳頻寬能力來估計朋友在 FCT 上的外分支度是
不夠的。所以計畫中我們提出 Degree-Adapted Greedy Tree Algorithm(DATGA)用來建立好友群
播樹，方法中為了決定每個樹節點的外分支度，我們提出一個可用外分支度預估(Available 
Out-Degree Estimation, AODE)用來估計每個朋友在 FCT 上的外分支度， tiAODE , 表示 0n 在時
間 t 時所預估 in 的外分支度，則 tiAODE , 如下所示： 
 
在此 tip , 為 in 在時間 t 之前估計其被朋友要求做檔案傳送的頻率，所以 tip ,  tif , 表示預估 in 在
時間 t 時會接收到多少個朋友要求轉傳的請求，這樣子可以避免 in 使用過多的上傳頻寬。假
設 tiu , 表示 in 在時間 t 時被要求做檔案傳送的次數，則 tip , 如下所示： 
 
DAGTA 使用貪婪(Greedy)法則循序地求得 FCT 使得演算法中每一個樹節點在決定父節點
  
 
9 
 
 
圖 3：King 資料的所有網路延遲百分比 
首先我們說明本計劃的實驗環境，並進行結果分析。我們利用 King[15]資料所提供的 1740
筆實際 round-trip latencies 來當作模擬每個使用者與其他人的網路狀態，圖 3.為所有網路延遲
以 100ms 為區間的百分比分佈，平均延遲為 181.759689 ms。模擬中我們假設一個資料大小為
1500bytes。總共模擬步數 1000，每一步假設為 100ms，但因為資料在傳遞時的延遲是依照實
際網路的延遲數據，因此為了判斷每次的封包轉傳會在哪個 timestamp 收到，則是用封包在
上一個 hop 的總實際延遲花費加上這次傳遞的延遲的大小後除以 100 ms 來與目前的
timestamp 相比來判斷是否已經傳到，所以我們假設使用者利用一個以 100ms 為 time slot 來收
集所有的轉傳要求，在 time slot 的最後再將欲發佈的資料和需要轉傳資料封包做傳送，而每
次封包的接收以及運算所產生的延遲為 30ms[44]。模擬中針對每個使用者平均的朋友數分別
就 20、30 及 40 來討論，且我們假設每個人對朋友發佈的機率為 0.2。而使用者的登入/登出
的機率以 churn rate=20%情況討論。在網路座標系統方面我們實作出 Vivaldi，而其 cc 和 ce 兩
個參數根據 Pharos[9]我們設定為 0.25。全部的環境參數如表 1.。此外我們想要在異質性網路
的上傳頻寬做探討，故參考論文[4]的上傳頻寬分佈，如表 2.所示。 
 
Node Sizes 300 
Simulation Steps 1000 
Average Friend 
Numbers (AFN) 
20, 30, 40 
Churn Rate 20% 
Behavior Rate 2 times/10s 
cc and ce 0.25 
Data Size (DS) 1500 bytes 
Channel Size 500 bytes 
Buffer Size AFN*DS (bytes) 
Process Delay 30 ms 
Exchange Period 100 steps 
表 1：環境參數 
 
  
 
11 
Average Reachability 
 
 而在平均到達率方面，我們的方法在 churn rate=20%時皆為 90%以上，顯示出即使在有
頻寬限制及節點的離開上皆可以保持很高的封包到達率。 
 
圖 5：churn rate=20%且無頻寬限制的平均到達率 
 
圖 6：churn rate=20%且有頻寬限制的平均到達率 
 
六、計畫成果自評 (Self Evaluation) 
 
 本計畫提出的 Degree-Adapted Greedy Tree Algorithm (DATGA) ，以可用外分支度預估
(available out-degree estimation)方法來估計每個好友在好友群播樹中合理的外分支度，並利用
網路座標系統上座標點距離的關係，配合貪婪法則(greedy method) 建立好友群播樹。系統架
構中我們保留住伺服器，但只負責少量的工作如當整個系統的 Gateway，以及儲存使用者於
系統中的基本資料如 ID、IP 和朋友清單等，以協助使用者可以快速登入系統。模擬中也呈現
出利用外分支度預估所建立的好友群播樹與許多的群播樹演算法比起來無論對於頻寬限制與
否和節點離開與否下，在平均延遲和封包到達率都有很好的表現。 
 本計畫共參與一個國際合作研究計畫，並發表四篇相關研討會論文與一篇碩士論文(研究
生: 洪兆緯, 論文標題: 線上社交網站頻寬及延遲感知同儕式好友群播)，以下是本計畫所發表
國際會議論文和參與國際合作研究計畫的報告。我們認為本計畫的研究成果符合計畫之預期。 
 
  
 
13 
1. 七、參考文獻 (References) 
 
[1] F. Aurenhammer, “Voronoi Diagrams: A Survey of a Fundamental Geometric Data Structure,” 
ACM Comp. Surveys, vol. 23, no. 3, 1991, pp. 345–405. 
[2] M. Albano, R. Baraglia, M. Mordacchini, L. Ricci, “Efficient Broadcast on Area of Interest in 
Voronoi Overlays,” in Proc. of Computational Science and Engineering (CSE’09), 2009. 
[3] S. Buchegger and A. Datta, “A case for P2P infrastructure for social networks– opportunities 
and challenges,” in Proc. of 6th International Conference on Wireless On-demand Network 
Systems and Services (WONS 2009), Snowbird, Utah, USA, February 2009. 
[4] A. R. Bharambe, C. Herley, and V. N. Padmanabhan, “Analyzing and Improving a BitTorrent 
Networks Performance Mechanisms,” in Proc. of IEEE INFOCOM, Barcelona, Spain, Apr. 
2006. 
[5] S. Buchegger, D. Schi o¨berg, L. H. Vu, Anwitaman Datta, “PeerSoN: P2P social networking – 
early experiences and insights,” in Proc. of ACM Workshop on Social Network Systems (2009). 
[6] M. Castro, P. Druschel, A. Kermarrec, and A. Rowstron, “SCRIBE: A large-scale and 
decentralized application-level multicast infrastructure,” IEEE Journal on Selected Areas in 
Communications, 20(8):100–110, 2002. 
[7] Y. H. Chu, A. Ganjam, T. E. Ng, S. G. Rao, K. Sripanidkulchai, J. Zhan, and H. Zhang, “Early 
Experience with an Internet Broadcast System Based on Overlay Multicast,” in Proc. of 
USENIX, June-July, 2004. 
[8] K. Chen, K. Nahrstedt, “Effective Location-Guided Tree Construction Algorithms for Small 
Group Multicast in MANET,” in Proc. of IEEE INFOCOM 2002, 2002. 
[9] Y. Chen, Y. Xiong, X. Shi, J. Zhu, B. Deng, X. Li, ”Pharos: Accurate and Decentralized Network 
Coordinate System,” IET Comm., Vol. 3, Iss. 4, pp. 539–548, 2009. 
[10] L. Chen, Z.Y. Yang, and Z.Q. Xu, “A degree-delay-constrained genetic algorithm for multicast 
routing tree,” in Proc. of the Fourth International Conference on Computer and Information 
Technology, pp. 1033–1038, 2004. 
[11] Y. Chen, G. Zhao, A. Li, B. Deng, X. Li, ”Myth: An Accurate and Scalable Network 
Coordinate System under High Node Churn Rate,” in Proc. of ICON2007,pp. 143-148, 19-21 
Nov., 2007. 
[12] F. Dabek, R. Cox, F. Kaashoek, and R. Morris, “Vivaldi: A Decentralized Network Coordinate 
System,” in Proc. ACM SIGCOMM, August 2004. 
[13] Y. K. Dalal and R. Metcalfe, “Reverse path forwarding of broadcast packets,” Communications 
  
 
15 
[28] T. S. E. Ng, H. Zhang, “Predicting Internet Network Distance with Coordinates-based 
Approaches,” in Proc. of IEEE INFOCOM, June 2002. 
[29] M. Pandey, S. M. Ahmed, B. D. Chaudhary, “2T-DHT: A Two Tier DHT for Implementing 
Publish/Subscribe,” in Proc. of Computational Science and Engineering, 2009. 
[30] M. Pias, J. Crowcroft, S. Wilbur, T. Harris, and S. Bhatti, “Lighthouses for Scalable Distributed 
Location,” in Proc. of IPTPS, February 2003. 
[31] P. Pietzuch, J. Ledlie, M. Mitzenmacher, M. Seltzer, “Network-aware Overlays with Network 
Coordinates,” in Proc. of IWDDS, July 2006 
[32] P. Paul and S. V. Raghavan, “Survey of Multicast Routing Algorithms and Protocols,” in Proc. 
of the Fifteenth International Conference on Computer Communication (ICCC 2002), 2002. 
[33] S. Rhea, B. Godfrey, B. Karp, J. Kubiatowicz, S. Ratnasamy, S. Shenker, I. Stoica, and H. Yu., 
“OpenDHT: a Public DHT Service and its Uses,” in Proc. of SIGCOMM’05, August 2005. 
[34] G.R. Raidl, B.A. Julstrom, “Greedy Heuristics and an Evolutionary Algorithm for the 
Bounded-Diameter Minimum Spanning Tree Problem,” in Proc. of the 2003 ACM Symposium 
on Applied Computing, Melbourne, FL, USA, 2003, pp. 747–752. 
[35] D. Schi o¨berg, “A peer-to-peer infrastructure for social networks,” Diploma Thesis, TU Berlin, 
Berlin, Germany, December 17, 2008. 
[36] Y. Shavitt and T. Tankel, “Big-bang Simulation for Embedding Network Distances in 
Euclidean Space,” in Proc. of IEEE INFOCOM, April 2003. 
[37] S. Tarkoma, M. Ain, and K. Visala, “The Publish/Subscribe Internet Routing Paradigm 
(PSIRP): Designing the Future Internet Architecture,” Towards the Future Internet, pp. 
102-111, 2008. 
[38] D. N. Tran, F. Chiang, and J. Li, “Friendstore: cooperative online backup using trusted nodes,” 
in Proc. of the 1st Workshop on Social Network Systems, Glasgow, Scotland, April 2008. 
[40] S.Y. Tseng, Y.M. Huang, and C.C. Lin, “Genetic algorithm for delay- and degree-constrained 
multimedia broadcasting on overlay networks,” Computer Communications, 29(17), pp. 
3625-3632, 2006. 
[41] A. Tawfig, Z. Taieb, “Delay-Constrained, Low-Cost Multicast Routing in Multimedia 
Networks,” Journal of Parallel and Distributed Computing, 61(9), 1307-1336, 2001. 
[42] Z. Wang, B. Shi, and E. Zhao, “Bandwidth-Delay-Constrained Least-Cost Multicast Routing 
based on Heuristic Genetic Algorithm,” Computer Communications, vol. 24, pp. 685-692, 
2001. 
[43] R. Zhang, Y. C. Hu, X. Lin, and S. Fahmy, “A Hierarchical Approach to Internet Distance 
出席國際學術會議心得報告 
報告撰寫人: 江振瑞 
本次至盧森堡參加 ICWMC 2011 會議 (The Seventh International 
Conference on Wireless and Mobile Communications, June 19-24, 2011 at  
Luxembourg) 發 表 一 篇 論 文 (Title: Sink-Connected Barrier Coverage 
Optimization for Wireless Sensor Networks, by Yung-Liang Lai and Jehn-Ruey 
Jiang)。此會議在盧森堡金融會議中心區域的 NOVOTEL Luxembourg 
Kirchberg 舉行，以下為會議進行的概況。 
ICWMC 2011 第一日為兩場 tutorials，第一場為 Tutorial I: “Future 
Internet Trends: Networked Media, Content and Services Orientation” by Prof. 
Dr. Eugen Borcoci, University Politehnica Bucharest, Romania。Borcoci 教授
年約 60 歲，是一位經驗老到，著作豐富的教授，此 tutorial 針對新的 virtual 
network 的概念進行精闢的闡述，讓人獲益良多。第二場為 Tutorial II: 
“Algorithm and Experiment Design with HeuristicLab: An Open Source 
Optimization Environment for Research and Education” by Prof. Dr. Stefan 
Wagner, Upper Austria University of Applied Sciences, Austria。Wagner 教授
領導 HeuristicLab，撰寫許多 heuristic algorithm open source codes，對於從
事最佳化研究的我們，這些 open source codes 極有價值。 
ICWMC 2011 第二日正式開幕，舉行 keynote speech，由 Prof. Dr. 
Damien Magoni 主講。Magoni 教授任職於 University of Bordeaux, France，
講述最新的 Virtual Networking Architecture 概念，令人印象深刻。第二日
下午以後是所有與會人員發表論文的場次，因為 conference 的 acceptance 
rate 為 30%，因此被接受發表的論文皆有不錯的品質。印象比較深刻的有
馬來西亞 Tharek 教授發表的論文(“The Mathematical Relationship Between 
Maximum Access Delay and the R.M.S Delay Spread” by Khalid Hassan, 
Tharek Abd Rahman, M. Ramlee Kamarudin, Faizah Nor)與荷蘭 Lo 教授發表
的論文 (“Adaptive Cross Layer Approach for Video Transmission Over 
Cognitive UWB Network” by Norazizah Mohd Aripin, Norsheila Fisal, Rozeha 
A. Rashid, Anthony C.C. Lo)。在會議進行期間，報告撰寫人與 Tharek 教授
及 Lo 教授討論許多概念，並論及未來可能的國際合作計畫案，本次參加
國際會議的收穫非常豐碩。 
«¬­®¯5&cC¡°±²X<"#Y³´¨µ¶=>·r
s¸¹º»¼#Y£½¾AAB²"#
X<¿ÀÁÂÃÄA
ÅC¡cÆÇÈÉeÊÁËÌÍ¨ABÎ¶=>?tC¡ÏÐ£
"#ÑÒ¦ÓÔÕÖ×ØÙÚÛ/ILI03/--LMI  2ILp/K-LJÜMP
Ý/MK0L,  m,LÞo(4K,ßIL, àáâã¨½"#Yäåæç"#è
é£Ñêë/ÜIMJ/-Û//QG  3Û/,U/K  ì,pLÞ+MK0/í,KI,- àáÃ 
Hîîî14O[ïð ñ/NNMTÄâã¨òóôõöu÷øujùyú
C¡#Y£¦~¬Ñûêë/ÜIMJ/-Û//QG  3Û/,U/KÃ  Hîîî14O[1 Â
4443ïð ñ/NNMT ínKÞn/2ILp/K-LJÜ  în0/I/m(3Û,PPMKÞ àáÃâ
ãüýrsòóþYDC¡÷£Ñê3,IÞ//Û
OG,JJ/K// Ãâãòb±	
ô÷øb£Ñê
 L,IIL-3,0L, ÃâãZº:òC¡uÕu
÷i£
"#ÑûÒµ¬­2ILp/K-LJÜMPÚJJ,T,1O,I,Þ, C¡c Mn-LP4N
oLÞG,TL 
« 4ìÜI,LQmÜßKLÞ3/KpLQ/Úp/KN,ÜS/JTMKUPMK3/KpLQ/
OMÛM-LJLMI- X<«X<ÃâãxÚp/KN,Ü
S/JTMKU n,NLJÜMP3/KpLQ/ ùyÃ !¾÷øÂÌ"#tÁâ
ã¨Ã$%&ø'(¬­+Hí)12í[Oí,KL-2ILp/K-LJ,-1OSo3í,KL-1
ñK,IQ/  3/ß,-JL/IìMLKL/n àá
«ì/N,ÜQMI-JK,LI/ÞìL/I-LMILI0MP

ûuÆ"c

½"#¹`­AcÄXC¡þYd`e$¼
C¡fÍC¡gBCEFN+'C¡÷89C¡ÃC¡\]h
fCi-jóVÎkk.lmr=DnoC¡pq\]
rs£'÷t½.l¾AVWX<u~d(Acv2~
.lÌw­xyøBCÆu~cz-{\]¹|"ÆY}
\]~>àáuÂDÕ9£

u#

~.-"Ç"Æ½ABCD"£Æ½CD"Ù~Í²
CD"g+¼CD" QÍvóC¡÷BCÁQÆ¿
AÅC¡cz.l¹-"uÇÆAB"#au.
Æ5A².-z"£


Dear Drs. Yung-Liang Lai and Jehn-Ruey Jiang:  
 
I am pleased to inform you that the following paper which you submitted 
to: 
The 2011 International Conference on Wireless Networks (ICWN'11: July 
18-21, 2011, USA) 
has been accepted as a Regular Research Paper (RRP) - ie, 
accepted for both, publication in the proceedings and oral formal 
presentation. Please see below for the categories of accepted papers. 
 
Paper ID #: ICW4609 
Title: Heuristic Resource Allocation with Satisfaction for WiMAX 
Services 
Author(s): Yung-Liang Lai and Jehn-Ruey Jiang 
 
 
Note: The "paper ID #" shown above is composed of three letters 
(conference prefix) followed by four numeral/digits. You will 
need to have this "Paper ID #" at the time of registration and 
final paper submission (for publication). 
 
(The evaluation of this paper is arranged by Track Chair # 29) 
 
General comments to authors of accepted papers: 
  1. Each paper was peer-reviewed by two experts in the field for 
     originality, significance, clarity, impact, and soundness. 
     In cases of contradictory recommendations, a member of the 
     conference program committee was charged to make the final 
     decision (accept/reject) - often, this involved seeking help 
     from additional referees by using a double-blinded review process. 
     In addition, all papers whose authors included a member of the 
     conference program committee were evaluated using the 
     double-blinded review process. Chairs of approved sessions were 
     responsible in evaluating the papers that were submitted to them. 
  2. Authors of accepted papers are strongly encouraged to enhance 
     the organization and the quality of the English writeup of 
     their papers before uploading them to the publication web site 
     for the preparation of the printed books/proceedings. 
-> ICWN'11 paper acceptance rate has been 22% (as of April 15); 
   this does not yet reflect the data for all individual sessions (ie, 
   the acceptance rate is likely to change significantly). 
-> See the appended text for useful information about the conference. 
-> If at least one author of an accepted paper registers for the 
   conference but for some reason he/she is unable to attend the 
   conference, then his/her paper will be published and arrangements 
   would be made to ship the proceedings to the registered author 
   after the conference. However, the registered author MUST inform 
   us by no later than May 15 that he/she will not be able to attend. 
-----------------------auto e.sig: 
H. R. Arabnia, PhD. 
Professor, Computer Science, The University of Georgia, USA 
Coordinator, WORLDCOMP'11 
    http://www.world-academy-of-science.org/ 
Editor-in-Chief, The Journal of Supercomputing (Springer) 
Associate Editor, IEEE Transactions on IT in Biomedicine (T-ITB; 
2007-2010) 
Co-Editor/Board, Journal of Computational Science (Elsevier) 
Elected Fellow, Int'l Society of Intelligent Biological Medicine 
(ISIBM) 
Member, Advisory Board, IEEE Technical Committee on Scalable Computing 
(TCSC) 
URL: http://www.cs.uga.edu/~hra/ 
Tel: (706) 542-3480 /   Cell/Mobile: (706) 340-4707 
email: hra@cs.uga.edu 
The 2011 International Conference on Wireless Networks 
 
satisfaction problem is formulated in Section III for QoS 
resource allocation in the WiMAX network. The proposed 
heuristic genetic algorithm is introduced and evaluated in 
Section IV and Section V, respectively. And finally, some 
concluding remarks are drawn in Section VI.  
 
II. REALTED WORK 
 
In this section, we introduce the related work of QoS Model 
of WiMAX, User Satisfaction Model, and Resources allocation 
schemes. 
 
A. QoS Model of WiMAX 
 
The WiMAX is an IP based mobile network, which 
provides a well-defined framework to support the QoS based 
services. Some examples are the Voice over IP (VoIP) 
telephony service, Internet Access service, and Multimedia 
Broadcast Multicast Service (MBMS), etc. Based on the 3GPP 
Rel. 5 specification [11], the network is consists of multiple 
mobile bearers (e.g. mobile phones, notebooks) to provide end-
to-end quality of services, where the WiMAX base station (BS) 
allocates the spectrum resources for providing the wireless 
services in mobile bearers. The BS can provide a diversity 
classes for different QoS services, which are unsolicited grant 
service (UGS) class, real-time-polling-services (rtPS) class, 
non-real-time-polling services (nrtPS) class, and best effort 
(BE) class. 
Based on the framework, the operator can design and sale 
the products of combining different QoS services.  As shown in 
Fig. 1, the subscribers equipped with different wireless devices 
to access the WiMAX networks, thus base station need to 
provide differential services for subscribers. 
 
 
Figure 1.  Illustration of WiMAX Services 
 
B. User Satisfcation Model 
 
The satisfaction of subscriber is important for the operators. 
Without sufficient resources allocation, the subscriber will 
unsubscribe the services, which will damage the operator’s 
revenue. For example, the acceptable one-way (speaker’s 
mouth to listener’s ear) delay of voice communication for VoIP 
applications recommended by ITU [12] is at most 150 ms. The 
subscriber uses VoIP service will feel unsatisfied if 
transmission delay is more than 150 ms. Such dissatisfactions 
will lead to “user churn” problem reported in [6]. In [6], a 
Sigmoid function is used to approximate the subscriber’s 
satisfaction of resource allocations. The Sigmoid is useful for 
modeling natural processes or system learning curves shown in 
Fig. 2, since it can represent a history dependent progression to 
approaches a limit over time. The Sigmoid distribution 
function depends on a random variable x to represent the 
occupation of resources for the subscriber, which is the utility 
function formulated as: 
 
                      ( )  
 
     (   )
                 (1) 
                
Where α and β are steepness and middle of the curve. In the 
subscribers’ point of view, the α is the sensitivity of the QoS 
and the β is the tolerable limit of failure of QoS.  
 
 
Figure 2.  Curves of Sigmod Function with =0 and different  
 
C. Resource allocation Schemes 
 
The resource allocation is one of most important research 
topics in the WiMAX technology. In [7], the authors proposed 
a pricing model for providing unsolicited grant services (UGS) 
and real time services (rtPS). They proposed a valuation 
0
0.2
0.4
0.6
0.8
1
1.2
-40 -30 -20 -10 0 10 20 30 40
Si
gm
o
d
 F
u
n
ct
io
n
 
=0.2
=0.4
=0.6
=0.8
WiMAX Base Station (BS) 
Internet 
Subscriber 1 
Subscriber 2 
Subscriber 3 
The 2011 International Conference on Wireless Networks 
 
A. Chromosome representation 
 
We use the chromosome (CH) to represent one feasible 
solution to allocate B resources into S services. Each 
chromosome contains (B-S) genes. Each gene is a binary string, 
which contains          bits. The S is the number of services 
and     is the celling function. Each gene represents the 
identities of services, whose value range is in [0, S-1]. In such 
design, we can allocate B resources and the allocation solution 
is without violating constraint (4). In addition, each service will 
add one resource in the Decode step for the constraint (3). 
According to the above-mentioned design, each feasible 
solution is without violating constraints (3)(4). 
For example, we have to allocate B(=7) resources for 3 
services, if we have the following chromosome. 
 
CH= [  1,  2,  2,  2 ] 
 
In the Decode step, the above CH represents that the 
operator need to allocate 2 units for the service 1 and allocate 4 
units for the service 2. 
 
B. Initialization population 
 
The population is randomly assigned. It is notable that 
setting of initial population is fairly simple to our algorithm; 
according to studies in [13], the population can have good 
resilience for randomly setting of initial population. 
 
C. Fitness Function 
 
The fitness function is used to evaluate the performance of 
individuals of the objective. In our design, the performance is 
the revenue, which implies only the individuals with higher 
revenue can survival. It is notable that we use the penalty term 
in (7) to enforce the constraint (5). The λ is the plenty weight, 
which is very large value. Thus, we have the fitness function as 
following: 
 
F = R – PLT                              (7) 
 
The PLT is the plenty function deified as following, where the 
s is the minimum required satisfaction level: 
 
    ∑    *
   
    (   )  +                                        ( ) 
 
V. PERFORMANCE EVALUATIONS 
 
In this section, we evaluate the performance of our 
proposed heuristic resource allocation algorithm. Our 
evaluation objective is to evaluate the revenue and subscribers’ 
satisfactions. We implement our algorithm on the Matlab 
platform [14]. The problem set for testing our algorithm 
contains four testing cases from 18, 19, .., to 24 resources. The 
number of services is 16 services. The setting parameters used 
in the simulation are listed in the table I. 
 
TABLE I.  SIMULATION SETTING PARAMETERS 
Parameter Setting Value 
Crossover Rate 0.7 
Mutation Rate 0.0175 
Generations 1000  
Genre Representation Scheme Bit string 
Plenty weight  () 1000 
Satisfaction level  0.4  
Cost, Price parameters Pstatic = 3 Units, Pdynamic =2 
Units, Cres = 10 Units 
 
The simulation results show the operator’s revenue is 
increased when the number of resources is increased, as 
shown in Fig. 3. Moreover, the users’ satisfactions are more 
than satisfaction level (0.4), which implies that the solution in 
our algorithm does not violate the subscribers’ satisfaction 
constraints, as shown in Fig. 4. 
 
 
Figure 3.  Simulation results in Reveneue on the proposed algorithm 
 
0
20
40
60
80
100
120
18 19 20 21 22 23 24
O
p
e
ra
to
r'
s 
R
e
ve
n
u
e
 
No. of Resources 
Revenue
國際合作研究計畫國外研究報告書 
出國日期: 2011/6/17~2011/6/28 
報告撰寫人: 江振瑞 
 
本次至法國巴黎第六大學與 Maha Abdallah 教授及其博士班研究生
Eliya Buyukkaya 及博士後研究員 Romain Cavagna 進行討論，討論與計畫
相關的 wireless ad hoc games 研究，並共同撰寫論文(Title: “SYMA: A 
Synchronous Multihop Architecture for Wireless Ad Hoc Multiplayer Games” 
by Ta-Yu Huang, Chih-Ming Lin, Jehn-Ruey Jiang, Wei Tsang Ooi, Maha 
Abdallah, Khaled Boussetta)的細節，該篇論文即將發表於 The 5th Workshop 
on Peer-to-Peer Networked Virtual Environments (P2PNVE 2011)。 
 
本篇論文討論如何在 wireless ad hoc network 環境中，建構一個稱為
SYMA 的 self-organizing network architecture，使得各個設備節點的使用者
可以共同參與一個線上遊戲。SYMA 可以分為三個 phases: invitation phase、 
construction phase、gameplay phase。在各個 phase 中的動作如以下所述: 
“In SYMA, devices are assumed to have one-hop neighbor device information, as well 
as timers synchronized with good accuracy. A player, called game initiator, broadcasts 
an invitation message to invite other players to join a new game in the invitation 
phase. A joining player issues a message along with its neighborhood information, 
including the expected transmission time (ETT) for each neighbor node, to reply to 
the invitation so that the initiator can derive the topology of the participating players. 
In the construction phase, the initiator applies Floyd–Warshall shortest path 
algorithm, taking the topology and ETT values as input to construct the shortest path 
spanning tree rooted at each player (or node). It then calculates the expected 
broadcast time (EBT) for each tree, which is useful to estimate the time for the root 
node of a tree to broadcast a game state to all tree nodes. Finally, the tree with the 
smallest EBT is selected as the communication tree and its root is designated as the 
coordinator, which collects timestamped actions of each player, executes the game 
logic, and then broadcasts the new game state in the gameplay phase. By exploiting 
synchronized timers, the game state consistency is guaranteed, and each node can be 
scheduled to send/receive game messages without causing collisions.” 
 
除了合作撰寫論文之外，我們也與 Maha 教授討論 SYMA 架構的實作
事宜。討論的結論為由我方先進行模擬實驗以驗證 SYMA 架構的可行性與
效能，待此部份完成之後，再由我方、巴黎第六大學與另一個合作夥伴 — 
新加坡國立大學 Prof. Wei Tsang Ooi 的團隊共同實施實作。 
  
construct the FCT according peers’ NCS coordinates and 
estimated out-degrees. We conduct simulation for the proposed 
scheme and other related multicast schemes and find that the 
proposed scheme outperforms others. 
 The rest of this paper is organized as follows. In Section 2, 
we review some related work. We elaborate the proposed 
scheme in Section 3 and show the simulation results of it and its 
related schemes in Section 4. And finally we conclude the paper 
with Section 5. 
II. RELATED WORK 
In this section, we review some related work regarding P2P 
OSNs, the NCS and P2P multicast schemes.  
A. P2P OSNs 
Most of popular OSN applications, such as ICQ, MSN 
Messenger, EtherPad, Facebook, MySpace, Twitter and Plurk 
are established on legacy C/S architecture. The paper [20] 
shows that existing centralized OSNs have some non-trivial 
limitations, such as limited bandwidth and computation 
resources, and that decentralized OSNs may hence be 
promising in the future. The P2P architecture is decentralized; 
the paper [1] advocates using the P2P architecture to implement 
OSNs so that users can store their data in a P2P manner to keep 
privacy and can use data even when Internet access is not 
available. The paper [17] suggests the implementation of a P2P 
OSN called PeerSon based on the distributed hash table (DHT), 
a well-known efficient structure of P2P networking. Shifting 
from the C/S to the P2P architecture has advantages; however, 
it also raises new problems. For example, system coordination 
becomes difficult when peers join and leave the system 
frequently. 
The paper [19] proposes to use the hybrid architecture to 
overcome the problems. In such an architecture, servers are 
deployed in the system to assist in the bootstrapping and the 
tracking of the system, while other participating entities also 
assist with running the system in a P2P manner. The system 
coordination hence becomes easy and the system resources 
become abundant. In other words, the advantages of the C/S 
and P2P architectures coexist in the hybrid system. The paper 
[19] states that hybrid ﬁle-sharing systems have better 
performance than pure P2P systems because some tasks (e.g., 
searching) can be done much more efficiently in a centralized 
manner. We believe that OSNs could also benefit from the 
hybrid architecture.  
B. NCS 
The NCS assigns synthetic coordinates to Internet peers, so 
that the Euclidean distance between two peers' coordinates can 
be used to predict the network latency between them. Through 
the NCS, topology-aware applications can be established to 
achieve more responsive system behaviors, such as shorter data 
transmission latency and faster request response. Two classes 
of algorithms can be used to generate network coordinates for 
peers. They are landmark-based algorithms and 
simulation-based algorithms [6][13].  
Landmark-based algorithms, such as GNP [14] and 
Lighthouse [15], involve centralized components and require 
global knowledge of peer latency measurements. Such 
algorithms use a set of infrastructure hosts called landmarks for 
calculating peers’ coordinates. The key idea of GNP [14] is to 
model Internet as a geometric space. Some hosts specified as 
landmarks compute their own coordinates first and altogether 
serve as a frame of reference for any participating peers. Peers 
contact multiple landmarks to calculate their coordinates 
relative to those of landmarks. GNP is an absolute coordinate 
system; the accuracy of peers’ coordinates depends on the 
choice of landmarks. Besides, landmarks are apt to become 
bottlenecks of networks and incur the single-point-of-failure 
problem [21]. Lighthouse [15] tries to eliminate the bottlenecks 
and the single-points-of-failure problem, and intends to be 
more scalable. It uses multiple sets of local bases with their 
own relative coordinate systems. Joining peers may select any 
of these local bases to contact with and determine their local 
coordinates. These local coordinates are then mapped into a 
global coordinates. Lighthouse is more scalable and accurate 
than GNP due to its localized coordinate design.  
In simulation-based algorithms, every peer calculates its 
coordinate according to the network measurements between 
itself and its communication peers. Vivaldi [6] models peers as 
entities in a spring system. It determines peers’ coordinates 
using spring relaxation simulation. The prediction error of the 
network distance measurement between a pair of peers is 
treated as the potential energy stored in a spring which connects 
these two peers. Peers attract and repel each other according to 
network distance measurements. In the other words, peers tune 
their coordinates to minimize the prediction error. The 
low-energy state of the spring system corresponds to the 
coordinates with the minimum error [6]. Vivaldi is widely used 
since it is fully distributed. Based on Vivaldi, Pharos [3] is fully 
decentralized and hierarchical. It seeks to eliminate the 
phenomenon that long distance scales of peers largely affect the 
prediction accuracy. In Pharos, each peer holds two sets of 
coordinate systems for long distance and short distance, 
respectively. According to the distance scale of interest, peers 
can choose the proper set of coordinate systems to achieve 
higher prediction accuracy.  
C. Multicast Algorithms 
Paul and Raphavan indicate that “multicast” is an efficient 
scheme suitable to one-to-many or many-to-many 
communications paradigm [16]. They make a survey of 
multicast algorithms working in the network layer, whose 
overall features and constraints are quite different from those of 
P2P algorithms working in the application layer. However, the 
analysis of topologies and efficiency are still valuable for 
reference. In practice, most multicast algorithms rely on 
constructing multicast trees to improve transmission efficiency, 
since the trees minimize duplication of forwarding messages.  
Three tree construction algorithms, namely MST, Modified 
ESM [5], and LGK [2], are used to examine the performance of 
the NCS in [3] and [22]. The MST (Minimum Spanning Tree) 
  
      
    
 
TL is the sum of the latency that n0 transmits a message to all 
of its friend peers. The goal of the proposed scheme is to keep 
TL as small as possible. The scheme first maps friend peers into 
Vivaldi NCS so that the transmission latency of any two peers 
can be estimated by the distance of their coordinates. It then 
tries to construct a FCT to span all friend peers such that the 
summation of the accumulated distances from all friend peers’ 
coordinates to n0’s coordinate is minimized. At the first glance, 
if n0 sends the message to all friend peers directly, TL is 
minimum due to the triangle inequality of NCS which is based 
on to estimate the latency between peers. However, when the 
bandwidth of n0 is very limited and the message consumes a lot 
of bandwidth (e.g., messages for instant voice or video 
messaging), the directly sending approach will use up the 
peer’s bandwidth and is thus not feasible. We therefore should 
take the available outgoing bandwidth of peers into 
consideration when constructing the FCT. 
In the proposed scheme, Available Out-Degree Estimation 
(AODE) is used to evaluate the proper out-degree of each node 
in the FCT. AODE of a peer ni is denoted as AODEi, which is 
defined as follows. 
       
  
  
       
                           
                       
             
In Eq. (1), S is the size of the message, Ci is the outgoing 
bandwidth of ni, fi is the current number of friend peers of ni, 
and pi is the estimated probability that ni is asked by its friend 
peers to forward messages (refer to Eq. 2 for pi). Hence pi×fi 
denotes the estimated number of forwarding requests that ni 
will receive from its friend peers in the meanwhile. Therefore, 
pi×fi×S means the current estimated traffic load shared by ni. 
The out-degree of ni is set to 1 if Ci is less than pi×fi×S; 
otherwise, it is set to   
  
       
  .  
Eq. (2) shows how to derive the estimated probability pi of 
peer ni to be asked by its friend peers to forward messages. 
    
  
  
                                                              (2)                       
In Eq. (2), Ri is the accumulated number of forwarding requests 
that ni receives from its friend peers, and Fi is the accumulated 
number of friend peers during the last specified estimation 
period. It is noted that Ri is increased by 1 and Fi is increased by 
the number of friend peers of ni every time when peer ni 
receives a request during the last specified estimation period. 
The value of pi is the ratio of Ri to Fi. 
The proposed scheme uses the greedy algorithm DAGTA to 
construct FCT. Since a FCT with a small height is preferred, the 
peer with the highest AODE is first selected to be the child node 
of the root. If there are many nodes with the same AODE, then 
the one with the shortest Euclidean distance in NCS is selected. 
We show the pseudo code of DAGTA in Fig2. Given the 
friendcast source peer (node) n0 and its m friend peers n1,…,nm, 
the algorithm can generate the FCT rooted at n0 to span n1,…,nm. 
Without loss of generality, we suppose that n1,...,nm are listed in 
the order of their AODE values. In the algorithm, ODi keeps the 
number of child peers of ni; li stores the current accumulated 
latency that n0 transmits a message to ni directly or indirectly; 
dk,i stands for the latency measured by the distance of NCS 
coordinates of peers nk and ni. The algorithm selects nk which 
satisfies ODk＜AODEk and has the minimum lk+dk,i for 0ki1 
as the parent node of ni in the FCT. However, if ODk  AODEk 
holds for 0ki1, the algorithm randomly selects a peer from 
n0,n1,…,ni-1 as the parent node of ni.  
 
Fig 2. The pseudo code of DAGTA 
A parent selection example of DAGTA is illustrated in 
Figure 3, where five nodes n0,...,n4 are depicted and the 
parameters of a peer ni, 0i4, are represented as a 4-tuple: 
(AODEi, d0,i, ODi, li) after n1, n2 and n3 have selected their 
parent nodes. Peer n4 will takes n1 as its parent peer since n1,n2 
and n3 all meet the requirement of ODi＜AODEi (1i3),  and 
l1+d1,4 is the smallest among l1+d1,4, l2+d2,4 and l3+d3,4. 
 
Fig 3. An example of DAGTA for the parent node selection  
IV. PERFORMANCE EVALUATION 
A. Simulation settings 
We evaluate the performance of the proposed friendcast 
scheme by simulation experiments using MIT King [8] data set 
as the reference of network latency between arbitrary peers. 
n3(2, 4, 0, 9) 
n1(3, 5, 1, 5) 
n2(3, 9, 0, 9) 
n0(2, 0, 2, 0) 
n4(2, 8, 0,l4)  
5 6 
8 l4=min 
d1,4+5=11 
d2,4+9=17 
d3,4+9=14 
Algorithm DAGTA 
Input: node n0 and its m friend peers n1,…,nm sorted according to their AODEs 
Output: FCT rooted at n0 
l0=0; //the latency from n0 to n0 is 0 
ODi=0 for 0im;  //ODi stores the current out-degree of peer i 
FOR i = 1 .. m  // for peer ni to select its parent node 
li=∞; //li records the latency from n0 to ni, which is initially  
pi=null; // pi is the parent node of ni, 
FOR k = 0 .. i-1  // parent node selection from n0,n1,n2…,ni-1 
IF ODk< AODEk THEN 
IF li  > lk+di,k THEN 
li = lk+di,k 
pi = nk 
    IF p i= = null THEN // if no nodes satisfy ODk< AODEk 
       Select an arbitrary peer from {n0,n1,…,ni-1} and assign it to pi 
RETURN  FCT rooted at n0 and spanning n1,…,nm with parent pointers p1,…,pm 
  
 
Fig 6. Average reachability for churn rate=0% 
 
Fig 7. Average reachability for churn rate=20% 
V. CONCLUSION 
This paper proposes a new bandwidth- and latency-aware 
P2P instant friendcast scheme for OSNs. This scheme 
constructs an efficient FCT with a greedy DAGTA algorithm 
on the basis of Vivaldi NCS coordinates and AODE of 
out-degree estimation. All in all, the scheme takes the physical 
network topology and the capacity of the underlying network 
into account for the purpose of shortening the latency and 
increasing the reachability of message delivery. As shown by 
the simulation results, the proposed scheme outperforms other 
related schemes in terms of the latency and reachability. 
This paper focuses on the bandwidth and latency aspects of 
the instant friendcast scheme. We plan to discuss the 
consistency and fault-tolerance issues about the scheme in the 
future to deal with peers frequently leaving and joining the 
system. Furthermore, we have found that the proposed scheme 
is also suitable for bandwidth-hungry and time-constrained P2P 
applications, such as P2P audio streaming, video streaming and 
3D streaming [4]. In practice, we have been planning to apply 
the proposed scheme to the above-mentioned applications. 
REFERENCES 
[1] S. Buchegger and A. Datta, “A Case for P2P Infrastructure for Social 
Networks – Opportunities and Challenges,” Proc. 6th International 
Conference on Wireless On-demand Network Systems and Services 
(WONS 2009), Snowbird, Utah, USA, February 2009. 
[2] K. Chen, K. Nahrstedt, “Effective Location-Guided Tree Construction 
Algorithms for Small Group Multicast in MANET,” Proc. INFOCOM 2002, 
2002. 
[3] Y. Chen, Y. Xiong, X. Shi, J. Zhu, B. Deng, X. Li, “Pharos: Accurate and 
Decentralized Network Coordinate System,” IET Comm., Vol. 3, Iss. 4, pp. 
539-548, 2009.  
[4] C. H. Chien, S. Y. Hu, J. R. Jiang, “Bandwidth-Aware Peer-to-Peer 3D 
Streaming,” Proc. 8th ACM NetGames Workshop, Paris, 2009. (also 
International Journal of Advanced Media and Communication, to appear) 
[5] Y. H. Chu, A. Ganjam, T. E. Ng, S. G. Rao, K. Sripanidkulchai, J. Zhan, and 
H. Zhang, “Early Experience with an Internet Broadcast System Based on 
Overlay Multicast,” Proc. of USENIX, June-July 2004. 
[6] F. Dabek, R. Cox, F. Kaashoek, and R. Morris, “Vivaldi: A Decentralized 
Network Coordinate System,” Proc. ACM SIGCOMM, August 2004. 
[7] Y. Feng, Z. Yu, Y. Pan, “Heuristic Genetic Algorithm for Degree 
Constrained Multicast Routing Problem,” Proc. 2004 International 
Conference on Machine Learning and Cybernetics, Shanghai, China, pp. 
2448-2452, 2004. 
[8] K. P. Gummadi, S. Saroiu, and S. D. Gribble, “King: Estimating Latency 
between Arbitrary Internet End Hosts,” Proc. of SIGCOMM IMW 2002, pp. 
5-18, November 2002. 
[9] S. Y. Hu, J. F. Chen and T. H. Chen, “VON: A Scalable Peer-to-Peer 
Network for Virtual Environments,” IEEE Network, vol. 20, no. 4, pp.22-31, 
Jul.-Aug. 2006. 
[10] http://www.wireshark.org/ 
[11] J. R. Jiang, Y. L. Huang, and S. Y. Hu, “Scalable AOI-Cast for 
Peer-to-Peer Networked Virtual Environments,” Proc. IEEE ICDCS 
Workshop on Cooperative Distributed Systems (CDS), Jun. 2008. 
[12] S. Keshav, S. Paul, “Centralized Multicast,” Computer Science 
Department, Cornell University, USA, Technical Report TR98-1688, 1998. 
[13] J. Ledlie, P. Gardner, and M. Seltzer, “Network Coordinates in the Wild,” 
Proc. NSDI, April 2007. 
[14]T. S. E. Ng and H. Zhang, “Predicting Internet Network Distance with 
Coordinates-based Approaches,” Proc. INFOCOM, June 2002. 
[15] M. Pias, J. Crowcroft, S. Wilbur, T. Harris, and S. Bhatti, “Lighthouses for 
Scalable Distributed Location,” Proc. IPTPS, February 2003. 
[16] P. Paul and S. V. Raghavan, “Survey of Multicast Routing Algorithms and 
Protocols,” Proc. 5th International Conference on Computer 
Communication (ICCC 2002), pp. 90-102, 2002. 
[17] D. Schi o¨berg, “A Peer-to-Peer Infrastructure for Social Networks,” 
Diploma thesis, TU Berlin, Berlin, Germany, December 17, 2008. 
[18] A. Tawfig, and Z. Taieb, “Delay-Constrained, Low-Cost Multicast 
Routing in Multimedia Networks,” Journal of Parallel and Distributed 
Computing, Vol. 61,  No. 9, pp. 1307-1336, 2001. 
[19]Beverly Yang and Hector Garcia-Molina, “Comparing Hybrid Peer-to-Peer 
Systems,” Proc. 27th International Conference on Very Large Data Bases, 
pp. 561-570, 2001.  
[20] Ching-man Au Yeung, Ilaria Liccardi, Kanghao Lu, Oshani Seneviratne, 
and Tim Berners-Lee, “Decentralization: The Future of Online Social 
Networking,” Proc. Workshop on the Future of Social Networking, 
Barcelona, Jan 2009.  
[21] R. Zhang, Y. C. Hu, X. Lin, and S. Fahmy, “A Hierarchical Approach to 
Internet Distance Prediction,” Proc. IEEE ICDCS, July 2006. 
[22] R. Zhang, C. Tang, Y. C. Hu, S. Fahmy, and X. Lin, “Impact of the 
Inaccuracy of Distance Prediction Algorithms on Internet Applications – an 
Analytical and Comparative Study,” Proc. IEEE INFOCOM, May 2006. 
 
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
20 30 40
Star
mESM
VoroCast
Dijkstra
DAGTA
DCPrim
LGK-15
LGK-2
Number of friends
A
v
erag
e   reach
ab
ility
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
20 30 40
Star
mESM
VoroCast
Dijkstra
DAGTA
DCPrim
LGK-15
LGK-2
Number of friends
A
v
erag
e   reach
ab
ility
A point from the first path and a point from the second path 
are regarded as corresponding points if they have the same 
index. The distance of every pair of corresponding points is 
measured and accumulated for calculating the average 
distance of the two paths to measure their similarity. ADCP 
is sensitive to noise (e.g., zigzag segments in a path), so 
some pre-processes are needed to eliminate the noise by 
merging data points that are too close. Furthermore, since 
ADCP requires that two paths for measuring have close 
beginnings and stops, paths should be aligned by padding 
additional points to path heads and tails until they reach the 
boundary.  
The other path similarity measuring method is the 
Longest Common Subsequence (LCSS) [5], which regards a 
path as a sequence of points for matching. Given two 
sequences S1 and S2, the LCSS method can return the longest 
subsequence L of matched points of the two sequences, 
where matched points are points that are close enough 
(within  distance) and a subsequence of a sequence S is 
derived by deleting from S any number of points that are not 
necessary consecutive (e.g., sequences <A, C, E> and <B, C, 
D> are both subsequences of the sequence <A, B, C, D, E>). 
The path similarity is then measured by the ratio |L| / min(|S1|, 
|S2|). Compared with the ADCP method, LCSS can cope 
with the problems caused by noises and path un-alignment 
by allowing some points not to be included in the returned 
subsequence. 
2.2 Data Clustering 
In this subsection, we describe some research work about 
data clustering which may be used to cluster motion paths. 
As described in [9], data clustering partitions numerous data 
objects into clusters (or groups) according to their similarity. 
A cluster is a collection of data objects that are similar to one 
another within the same cluster and are dissimilar to the 
objects in other clusters. There are many data clustering 
methods proposed in the literature. Below, we introduce 
three categories of them: partitioning, hierarchical, and 
density-based methods. 
2.2.1 Partitioning Methods 
Given a set of n data objects, a partitioning method 
constructs k partitions of the data, where each partition 
represents a cluster and kn. To be more precise, the method 
classifies the data into k clusters satisfying the following 
requirements: (1) each cluster must contain at least one 
object, and (2) each object must belong to exactly one cluster. 
After partitioning data objects into k initial clusters, the 
method uses an iterative relocation technique attempting to 
improve the partitioning by moving objects from one cluster 
to another. The general criterion of a good partitioning is that 
data objects in the same cluster are similar to each other, 
whereas data objects of different clusters are dissimilar.  
The famous k-means algorithm [11] is one of the 
partitioning methods. It first randomly selects k of the data 
objects, each of which initially represents a cluster mean. 
Each of the remaining data objects is then assigned to the 
cluster to which it is the most similar on the basis of the 
distance between the data object and the cluster mean. 
Afterwards, the new mean for each cluster is re-computed 
and data objects are re-assigned to clusters. This process 
iterates until the criterion function, typically defined as the 
sum of square errors, converges. The k-medoids algorithm [8] 
is analogous to the k-means algorithm; however, it uses the 
medoid, the data object that is closest to the mean of the 
cluster, instead of the mean as the reference of the cluster. 
Furthermore, it uses the sum of absolute errors as the 
criterion function. The k-medoids algorithm is thus more 
robust to noise and outliers (i.e., the data objects that do not 
comply with the general object behavior) than the k-means 
algorithm. 
2.2.2 Hierarchical Methods 
Hierarchical methods seek to build a hierarchy of clusters 
of data objects, and they are either agglomerative ("bottom-
up") or divisive ("top-down"). Agglomerative methods, such 
as BIRCH (Balanced Iterative Reducing and Clustering) 
algorithm [10], begin by taking each element as a separate 
cluster and then merge them into successively larger clusters. 
They are convenient to find and handle the outlier values. On 
the contrary, the divisive methods begin with the whole data 
objects in a cluster and proceed to split it into successively 
smaller clusters. They need more memory than its 
counterparts to process the clustering. Since a pure 
hierarchical clustering method cannot perform adjustment 
once a merging or splitting operation has been executed, its 
performance may suffers. Some studies try to embed the data 
relocation concept into hierarchical agglomerative clustering 
methods to ease the suffering. 
2.2.3 Density-based Methods 
Density-based methods typically regard clusters as dense 
regions of data objects in the data space that are separated by 
regions of low density. In these methods, a cluster is 
regarded as a region satisfying a certain criterion (e.g., the 
density of data objects exceeds a threshold). DBSCAN 
(Density-Based Spatial Clustering of Applications with 
Noise) [12] and OPTICS (Ordering Points to Identify the 
Clustering Structure) [13] are two typical methods of this 
kind. DBSCAN [12] processes data objects one by one and 
regards an object as a core object to be grown into a cluster 
of arbitrary shape in a spatial database with noise if the 
number of the object’s nearby objects within a specified 
radius R exceeds a threshold T. After processing all data 
objects, those not belonging to any cluster are regarded as 
noises. A disadvantage of DBSCAN is that it is hard to find 
proper parameters, such as R and T, for clustering. To 
eliminate the drawback, OPTICS [13] computes the cluster 
ordering, instead of the explicit data clustering, for 
automatically and interactively extracting clustering 
information like cluster centers, etc. 
2.3 Path Clustering 
Some papers address the problem of path clustering for 
paths in different applications, such as hurricane (or typhoon) 
tracks [14], animal movements [14] and vehicular 
trajectories [15]. The paper [14] proposes a method called 
TRACLUS using the partition-and-group concept for 
are of distance less than 2R will have some similar view and 
can be regarded as similar paths. 
In ADCP-DC algorithm, two paths are regarded as 
similar paths if their ADCP value is less than R, which is set 
to be the AOI radius. If the total number of the similar paths 
of a path exceeds M, the path is regarded as a core path and 
is associated with a similar path set (SPS). The core path, say 
p1, with the most similar paths is first elected as the first 
representative path, and SPS1 is regarded as the first cluster, 
where SPS1 is the set containing p1 and all its similar paths. 
All members of SPS1 are then excluded from the SPS of 
every remaining core path. Afterwards, the remaining core 
path with the most similar paths is selected as the second 
representative path, and its associated SPS is the second 
cluster. The procedure proceeds until no core path exits.  
Algorithm: ADCP-DC 
Input: path set PS, similar path radius R (set to be AOI radius), 
minimum number M of paths in a cluster 
Output: path cluster collection PCC and representative paths 
Var: 
CPS=;  //CPS: core path set 
RPS=;  //RPS: representative path set 
SPSi={Pi}, for 1in;  //SPSi: similar path set of path Pi 
FOR each unordered pair of distinct paths Pi and Pj in PS 
   Compute ADCPij of Pi and Pj 
IF ADCPij < R THEN 
SPSi=SPSi{Pj};  
SPSj=SPSj{Pi};  
FOR each path Pi 
    IF |SPSi|  M THEN CPS=CPS{Pi};   
WHILE CPS  
Select from CPS path Pi with the largest SPSi 
CPS=CPS  {Pi}; 
IF |SPSi|  M THEN 
//SPSi is a path cluster and Pi is a representative path 
PCC=PCC  {SPSi}; 
FOR each path Pj in CPS 
           SPSj = SPSj – SPSi; 
RETURN PCC and associated representative paths 
Figure 2.   ADCP-DC Algorithm 
3.3 LCSS-DC 
In LCSS-DC algorithm shown in Figure 3, the entire 
virtual world is first divided into numbered square cells 
whose length is of the AOI diameter. According to the cell 
numbers that the sample points of a path resides in, the path 
is represented by a sequence of cell numbers. Note that 
consecutive identical cell numbers in the sequence will be 
merged to be one number. For example, in Figure 3(a), path 
A is represented as <60, 61, 62, 63, 55, 47, 39, 31, 32>, and 
path B, <60, 61, 62, 54, 62, 63, 64>.  
The similarity of two paths is measured by the longest 
common subsequence (LCSS) of the cell number sequences 
of the paths. Each cell number in the sequence is associated 
with the location of the sample data residing within the cell; 
a merged cell number is associated with the centroid of the 
locations of the sample data residing within the cell. Two 
cell numbers are regarded common if they are identical or 
their associated cells are adjacent in the virtual world and 
their associated locations are with the distance less than the 
AOI radius. For example, paths A and B in Figure 3(a) have 
the LCSS of <60, 61, 62, 63>. 
After calculating the LCSS of two paths, clustering is 
then performed. LCSS-DC uses a pair of similar path 
thresholds THa and THb, instead of the similar path radius R 
used in ADCP-DC, as parameters of clustering. Path Pi takes 
path Pj as its similar path if Eqs. (3) and (4) are satisfied. 
           ij
a
i
LCSS
TH
Seq
                                        (3) 
 ij
b
ji
LCSS
TH
SSeq
                                       (4) 
In Eqs. (3) and (4), Seqi and Seqj are the cell number 
sequences of Pi and Pj, respectively, LCSSij is the longest 
common subsequence of Seqi and Seqj, and SSeqji is the 
shorted subsequence of path Pj containing the whole LCSSij. 
Algorithm: LCSS-DC 
Input: path set PS, similar path thresholds THa and THb,  
minimum number M of paths in a cluster 
Output: path cluster collection PCC and representative paths 
Var: 
CPS=;  //CPS: core path set 
SPSi={Pi}, for 1in;  //SPSi: similar path set of path Pi 
FOR each ordered pair of distinct paths Pi and Pj in PS 
    Compute LCSSij of Pi and Pj 
IF (|LCSSij|/|Seqi|)  THa) and (|LCSSij|/|SSeqji|)  THb) 
SPSi =SPSi {Pj};  
FOR each path Pi 
    IF |SPSi|  M THEN CPS=CPS{Pi};   
WHILE CPS  
Select from CPS path Pi with the largest SPSi 
CPS=CPS {Pi}; 
IF |SPSi| M THEN 
//SPSi is a path cluster and Pi is a representative path 
PCC=PCC{SPSi};  
FOR each path Pj in CPS 
      SPSj = SPSj – SPSi; 
RETURN PCC and associated representative paths 
Figure 3.   LCSS-DC Algorithm 
Unlike ADCP-DC, LCSS-DC checks the similarity for 
each ordered pair of paths. Like ADCP-DC, LCSS-DC also 
adopts the density-based clustering mechanism for 
clustering paths. When a path has many enough similar 
paths, it is regarded as a core path and becomes a candidate 
As shown in Figures 6 and 7, when the number of 
corresponding points increases, the silhouette of ADCP-DC 
algorithm slightly increases and the coverage slightly 
decreases. In addition, when the minimum number M of 
paths in a cluster increases, the silhouette increases but the 
coverage decreases. This is because when M grows, it 
requires more paths to form clusters and some paths thus 
cannot be included in any clusters, leading to the higher 
silhouette and lower coverage. Based on the experiment 
results, when the minimum number of paths in a cluster is 
150, the silhouette is greater than 0.7, the suggested value 
mentioned in [8], and the coverage is about 0.41. 
4.3  LCSS-DC Performance 
Experiment results reveals that when the minimum 
number M of paths in a cluster is less than 200, the silhouette 
of LCSS-DC algorithm is below the suggested value 0.7. 
Therefore, only the results for M=200 and M=300 are shown 
in the paper. By Figures 8 and 9, it can be observed that 
when similar path thresholds THa and THb grow, the 
silhouette increases but the coverage decreases. As shown in 
Figure 8, when the minimum number M of paths in a cluster 
is set to be 200, and THa is set to be over 0.74, and THb is set 
to be over 0.50, the silhouette is over the suggested value 0.7 
and the coverage is about 0.54 or less. As shown in Figure 9, 
when M is set to be 300, and THa is set to be over 0.68, and 
THb is set to be over 0.65, the silhouette is over 0.7 and the 
coverage is about 0.41 or less. 
 
  
Figure 8. The silhouette and coverage of LCSS-DC algorithm when the 
minimum number M of paths in a cluster is 200 
  
Figure 9. The silhouette and coverage of LCSS-DC algorithm when the 
minimum number M of paths in a cluster is 300 
V. CONCLUSION 
This paper proposed two algorithms, namely Average 
Distance of Corresponding Points-Density Clustering 
(ADCP-DC) and Longest Common Subsequence-Density 
Clustering (LCSS-DC), to cluster avatar motion paths in 
NVEs. Avatar paths are first divided into segments by 
hotspots and then processed by the proposed algorithms to 
derive a collection of path clusters and associated 
representative paths, which can be used to observe avatar 
behavior or to improve the NVE design. The proposed 
algorithms are applied to process the avatar path data of SE 
to demonstrate their applicability and quality in terms of 
silhouette and coverage. At present, we are planning to apply 
them to avatar path data of other NVEs like WoW. We are 
also planning to design other clustering algorithms to cluster 
avatar paths in NVEs. 
 
REFERENCES 
[1] D. C. Miller, and J. A. Thorpe, ―SIMNET: the Advent of Simulator 
Networking,‖ Proc. IEEE, pp. 1114-1123, 1995 
[2] Secnod Life, http://secondlife.com/. 
[3] World of Warcraft, http://www.worldofwarcraft.com/. 
[4] Z. Fu, W. Hu, and T. Tan, ―Similarity Based Vehicle Trajectory 
Clustering and Anomaly Detection,‖ Proc. 5th ICIP, pp. 602-605, 
2005. 
[5] M. Vlachos, G. Kollios, and D. Gunopulos, ―Discovering Similar 
Multidimensional Trajectories,‖ Proc. 18th Intl. Conf. on Data 
Engineering (ICDE’02), pp. 673-685, 2002. 
[6] H. Liang, I. Tay, M. F. Neo, W. T. Ooi, and M. Motani, ―Avatar 
Mobility in Networked Virtual Environments: Measurements, 
Analysis, and Implications,‖ Multimedia Tools and Applications, Vol. 
45, pp. 163-190, 2009. 
[7] R. Ng, and J. Han, ―Efficient and Effective Clustering Method for 
Spatial Data Mining,‖ Proc. 20th VLDB Conference, pp. 144-155, 
1994. 
[8] L. Kaufman, and P. J. Rousseeuw, Finding Groups in Data: An 
Introduction to Cluster Analysis, Wiley, 1990. 
[9] J. Han, and M. Kamber, Data Mining: Concepts and Techniques,  
Morgan Kaufmann, 2000. 
[10] T. Zhang, R. Ramakrishnan, and M. Livny, ―BIRCH: An Efficient 
Data Clustering Method for Very Large Databases,‖ Proc. ACM 
SIGMOD Conference on Management of Data, pp. 103-114, 1996. 
[11] J. MacQueen, ―Some Methods for Classification and Analysis of 
Multivariate Observations,‖ Proc. 5th Berkeley Symp, pp. 281-297, 
1967. 
[12] M. Ester, H.P. Kriegel, and X. Xu, ―A Density-Based Algorithm for 
Discovering Clusters in Large Spatial Databases with Noise,‖ Proc. 
2th International Conference on Knowledge Discovery and Data 
Mining (KDD 96), pp. 226-231, 1996. 
[13] M. Ankerst, M. Breunig, H.P. Kriegel, and J. Sander, ―Optics: 
Ordering Points to Identify the Clustering Structure,‖ Proc. ACM 
SIGMOD International Conference on Management of Data, pp. 49-
60, 1990. 
[14] J. Lee, J. Han, and K. Whang, ―Trajectory Clustering: A Partition-
and-Group Framework,‖ Proc. SIGMOD International Conference on 
Management of Data, pp. 593-604, 2007. 
[15] C. Piciarelli, and G. L. Foresti, ―On-line Trajectory Clustering for 
Anomalous Events Detection,‖ Pattern Recognit. Lett., Vol. 27, No. 
15, pp. 1835-1842, 2006. 
 
Silhouette 
Silhouette 
Range 
Coverage 
Coverage 
Range 
Silhouette 
Silhouette 
Range 
Coverage 
Coverage 
Range 
                                                                             
transmission latency between them. Owning to NSC, we can 
plan efficient ways to transmit voice data on the overlay 
network. IVC is thus latency aware. On the other hand, IVC 
is also bandwidth aware. We design an AK-tree (adaptive 
k-ary tree) algorithm, which evolves from the LGK (location 
guided k-ary tree) algorithm [3], to construct a multicast tree, 
in which the speaking peer is the root node of the multicast 
tree, and its voice data is recursively transmitted to all nodes 
on the tree in a recursive parent-to-children manner. In the 
algorithm, each peer first evaluates its available outgoing 
bandwidth and then takes as many as possible child nodes to 
form the multicast tree to completely utilize the outgoing 
bandwidth and reduce the queuing delay caused by 
insufficient outgoing bandwidth for outward data. 
Even with the above-mentioned mechanisms adopted by 
IVC, when a player has too many AIO neighbors, network 
congestion may still occur, increasing voice transmission 
latency and voice data dropping rate. To avoid this, network 
traffic should be reduced. Some previous studies [13] [21] 
proposed voice-mixing schemes to reduce the network traffic. 
The schemes may lessen users’ immersive experience since 
the mixed voice prevents a user from differentiating the 
orientation and position of each original voice. IVC 
prioritizes voice data and uses a voice masking scheme based 
on the theory of the masking effect of sound [15]. In some 
situations an otherwise clearly audible sound can be masked 
by another sound. A weaker sound is said to be masked if it 
is made inaudible in the presence of a louder sound. Base on 
the theory of the sound masking effect, IVC filters out data 
of inaudible overhearing voice to reduce the network traffic. 
The rest of this paper is organized as follows. In Section 
II, we review some related work. We elaborate the proposed 
scheme in Section III and show the simulation results and 
comparisons of it and its related schemes in Section IV. And 
finally we conclude the paper with Section V. 
II. RELATED WORK 
In this section, we review some related work regarding 
MMOGs, human auditory behavior patterns, and multicast 
algorithms. 
A. MMOGs 
Massively Multi-Player Online Game (MMOG) is one 
of the most popular Internet applications. The paper [8] 
indicated that MMOGs have the following requirements: 
consistency, scalability, load balancing, fault tolerance, 
cheat avoidance, security and persistency. Most MMOGs 
were based on the client/server architecture or model, 
which has good performance in consistency, security, 
resources management and cheat avoidance. However, 
insufficient scalability is the critical constraint in 
client/server model. Although server-clustering technique is 
applied to strengthen the scalability of the client/server 
architecture or model, problems such as synchronization 
and load balance among multiple servers are not yet solved 
perfectly. The peer-to-peer model was also proposed to 
solve the scalability constraint of the client/server model. 
For example, VON [9] is a creative peer-to-peer solution 
for networked virtual environments and MMOGs. It is 
advantageous to shift from the client/server to the 
peer-to-peer model; however, it also raises new problems. 
For example, system coordination becomes difficult when 
peers join and leave the system frequently. Furthermore, 
problems such as consistency, security, resources 
management and cheat avoidance are still challenges for 
the peer-to-peer model. In practical business operations, 
most MMOGs were thus founded on the client/server 
model. 
B. Human auditory behavior patterns 
The behavior of human talk can be classified into 4 
types: single talk, double talk, pause and mutual silence [10]. 
By the statistics in [10], when making a conversation, people 
spend about 40% of time in talk (single talk or double talk) 
and about 60% of time in silence (pause or mutual silence).  
Sound masking effect [15] is the nature of human 
auditory sensation. In some situations an otherwise clearly 
audible sound can be masked by another sound. A weaker 
sound is masked if it is made inaudible in the presence of a 
louder sound. There are two types of sound masking effect, 
temporal masking effect and spectral masking effect. A 
louder sound or distinctive sound will make other sound 
around it difficult to be recognized, and the unrecognized 
sound is called masked sound. Many audio encoding 
algorithms exploit the sound masking effect to reduce the 
size of sound data. For example, the well-known MP3 format 
uses the sound masking effect to cut out some 
unrecognizable sound beyond the specific threshold 
frequency to enhance the performance of compression.  
C. Multicast algorithms 
In this subsection, we introduce some related multicast 
algorithms; the first one introduced [3] is for mobile ad hoc 
networks (MANETs), though. The LGK (Location-Guided 
k-ary tree) [3] algorithm aims for group communication in 
MANETs in which the location of each participating node is 
known. It constructs a k-ary tree with the following two steps 
for a node (i.e., the root node) to perform group 
communication. (Step 1) The root node selects the closest k 
nodes as its child nodes. (Step 2) the remaining nodes are 
grouped into k clusters according to the geometric proximity 
to the k child nodes. Each child node then takes itself as the 
root node and executes the two steps in the corresponding 
cluster to form a subtree. In this recursive manner, the k-ary 
tree is formed. As the example in Fig. 1 illustrates (k=2), 
peer A selects the 2 nearest neighbors B and F as its child 
nodes; B and F then select their respective child nodes to 
form the final k-ary tree. 
                                                                             
The relation model scores player i’s AOI neighbor j with 
three parameters:  
a) Distance:  
,dist
max
R 1
i j
ij
dist
dist
       (1), 
where distmax is the maximal distance at which i can see 
players (i.e., the radius of AOI) and disti,j is the distance 
between player i and player j. In general, the closer is j, 
the more important is j.  
b) Orientation:  
1
ori
,
cos
R
180
i j
i j
i j
Ori Ori
Len Len

 
  
 
    (2), 
where Orii and Orij are the orientations of player i and 
player j, respectively. People usually talk face to face 
with each other, so the bigger the difference of the 
orientations between two players is, the more likely they 
talk with each other. 
c) Social relationship:  
social
,
1, if player  has social relation to  player  
R
0, otherwise
i j
i j
 

 (3) 
People usually prefer to have a conversation with friends, 
partners, or teammates in a game. If player j has some 
specific relations to player i, then j will get a higher score. 
 
We can get the relation score Ri,j of players i and j by 
combining R
dist
i,j, R
ori
i,j, and R
social
i,j with respective weight, 
w
dist
, w
ori 
and w
social
, as shown in Eq. 4. 
dist dist ori ori social social
, , , ,R R R R
1
i j i j i j i j
dist ori social
w w w
w w w
  
  
  (4) 
B. Adaptive k-ary tree (AK-tree) construction 
The LGK tree algorithm [3] constructs a k-ary tree with a 
fixed k value. As peers usually have heterogeneous 
capacities of delivering data, the k-ary tree with fixed k 
might not properly utilize the outgoing bandwidth of peers. 
In IVC, the parameter k is set adaptively according to a 
player’s available bandwidth to utilize bandwidth 
completely.  
IVC constructs an adaptive k-ary tree (AK-tree) as 
follows: (1) A peer first estimates its capacity and the total 
demand of outgoing bandwidth, and then sets a proper 
out-branch parameter l. (2) The peer assumes itself as the 
root node and selects the closest l nodes as its child nodes 
according to the distance calculated by the NCS coordinates. 
Due to the limitation of space, we do not show the details of 
calculating NCS coordinates. The readers are referred to [6] 
for the details. (3) The unselected nodes are clustered to the l 
child nodes according to geometric proximity. Afterwards, 
each child node recursively applies the three steps to its 
associated cluster members for further child selection and 
clustering. As a result, an AK-tree is constructed. As 
illustrated in the example of Fig. 3, peer A selects the 2 (kA=2) 
nearest neighbors B and F as its child nodes, and B and F 
then follow the three steps to select their respective child 
nodes (kB=3, kF=1). Finally, the AK-tree is formed. In this 
example, we can see that the height of the left subtree will 
increase and congestion will occur at F of the right subtree if 
we do not adapt the out-branch parameter according with 
peers available outgoing bandwidth. 
 
Fig 3. An example of adaptive k-ary tree construction 
C. Voice masking mechanism 
As explained in Section II, overhearing voices are 
relatively unimportant to people. In IVC, some unimportant 
overhearing voice data can be dropped if the capacity of a 
peer cannot afford the data delivery. In practice, IVC 
prioritizes voice data to determine the order of voice data 
dropping. The following criterion is used to calculate the 
priority value of overhearing voices: 
2
,
,
V i j
i j
Volume
alue
dist
        (5), 
where Valuei,j is the priority value between player i and 
player j, Volume is the volume of the voice, and disti,j is the 
distance between i and j.  
IV. PERFORMANCE EVALUATION  
We evaluate the performance of IVC by simulations and 
compare the simulation results with those of related schemes, 
Node Capacity  Node Capacity Node Capacity 
A 2 D 3 G 2 
B 5 E 1 H 3 
C 2 F 1 I 1 
                                                                             
k-ary tree algorithm to be bandwidth aware and uses the 
voice masking mechanism to further reduce the network 
traffic.  
 
Fig 6. The average dropping rate in delivering listening voice data 
 
Fig 7. The average dropping rate in delivering overhearing voice data 
V. CONCLUSION 
In this paper, we propose a peer-to-peer voice 
communication scheme, called IVC, to provide MMOG 
players with the immersive experience to hear the voice of 
neighbor players within AOI. IVC uses a relation model to 
classify the voices of AOI neighbor players into the listening 
voice and the overhearing voice, in which the latter 
consumes much less bandwidth than the former to reduce the 
traffic load. IVC also adopts the network coordinate system 
(NCS) to reduce the voice transmission latency and 
constructs the adaptive k-ary tree (AK-tree) to utilize the 
complete bandwidth. As shown by the simulation results, the 
proposed IVC scheme outperforms other related schemes.  
REFFERENCES 
[1]  A. R. Bharambe, C. Herley, and V. N. Padmanabhan, “Analyzing and 
Improving a BitTorrent Networks Performance Mechanisms,” In 
Proceedings of IEEE INFOCOM, 2006. 
[2]  Ashwin Bharmbe, John R. Douceur, Jacob R. Lorch, Thomas 
Moscibroda, Jeffrey Pang, Srinivasan Seshan, Xinyu Zhuang, 
“Donnybrook: Enabling Large-Scale, High-Speed, Peer-to-Peer 
Games,” In Proceedings of SIGCOMM, 2008.  
[3]  K. Chen, K. Nahrstedt, “Effective Location-Guided Tree Construction 
Algorithms for Small Group Multicast in MANET,” In Proceedings 
of INFOCOM, 2002. 
[4] Cisco Web Site, http://www.cisco.com/en/US/tech/tk652/tk698/ 
technologies_tech_note09186a0080094ae2.shtml 
[5]  Nelson Cowan, “The Magical Number 4 in Short-Term Memory: A 
Reconsideration of Mental Storage Capacity,” Behavioral and Brain 
Science, pp. 87-185, 2001. 
[6]  F. Dabek, R. Cox, F. Kaashoek, and R. Morris, “Vivaldi: A 
Decentralized Network Coordinate System,” In Proceedings of 
SIGCOMM, August 2004. 
[7]  K. P. Gummadi, S. Saroiu, and S. D. Gribble, “King: Estimating 
Latency between Arbitrary Internet End Hosts,”In Proceedings of 
SIGCOMM Workshop on Internet Measurment, November 2002. 
[8]  Shun-Yun Hu, Shao-Chen. Chang and J. R. Jiang, “Voronoi State 
Management for Peer-to-Peer Massively Multiplayer Online Games,” 
In Proceeding of IEEE Consumer Communication and Networking 
Conference (CCNC), pp.1134-1138, 2008. 
[9]  Shun-Yun Hu, Jui-Fa Chen and Tsu-Han Chen, “VON: A Scalable 
Peer-to-Peer Network for Virtual Environments,” IEEE Network, 
vol.20, no. 4, pp. 22-31, Jul./Aug. 2006. 
[10]  International Telecommunication Union, ITU-T Recommendation 
P.59: Artificial Conversational Speech, 1993. 
[11] International Telecommunication Union. ITU-T Recommendation 
G.114: One-Way Transmission Time, 2003. 
[12]  Jehn-Ruey Jiang, Chao-wei Hung, and Jih-Wei Wu, “Bandwidth- and 
Latency-Aware Peer-to-Peer FriendCast for Online Social Network,” 
In Proceedings of P2PNVE, 2010. 
[13]  Jehn-Ruey Jiang, Hung-Shiang Chen, “Peer-to-Peer AOI Voice 
Chatting for Massively Multiplayer Online Games,” In Proceeding of 
ICPADS, 2007. 
[14]  L. Valente, A. Conci, and B. Feijó, “Real Time Game Loop Models 
for Single-Player Computer Games,” In Proceedings of the IV 
Brazilian Symposium on Computer Games and Digital Entertainment, 
2005. 
[15]  R. L. Wegel, and C. E. Lane, “The Auditory Masking of One Sound 
by Another and Its Probable Relation to the Dynamics of the Inner 
Ear,” Phys. Rev., Vol. 23, pp. 266-285, 1924.  
[16]  Skype, http://www.skype.com/. 
[17]  Teamspeak, http://www.goteamspeak.com/. 
[18]  Tonio Triebel, Benjamin Guithier, Thomas Plotkowiak, Wolfgang 
Effelsberg, “Peer-to-peer Voice Communication for Massively 
Multiplayer Online Games,” In Proceeding of the 6th IEEE Consumer 
Communication and Networking Conference (CCNC), 2009. 
[19]  Ventrilo, http://www.ventrilo.com/. 
[20]  World of Warcraft, http://us.battle.net/wow/en/. 
[21]  Roger Zimmermann and Ke Liang, “Spatialized Audio Streaming for 
Networked Virtual Environments,” In Proceeding of the 16th ACM 
International Conference on Multimedia, p.209-308, 2008. 
 
IVC 
IVC 
The number of nodes 
The number of nodes 
player using the Floyd-Warshall algorithm [4].  For each 
of these trees, we estimate the time taken to broadcast a 
packet from the root of the tree to all other nodes, 
assuming there is no collision.  We call this estimated time 
the Estimated Broadcast Time, or EBT.  The tree with the 
smallest EBT is chosen as the communication tree for 
disseminating game traffic, and the root of this tree is 
designated as the coordinator.  The coordinator is 
responsible for collecting events from other nodes, 
calculates the game logic, and then announces the new 
game state to all other nodes. We address the interference 
issue by synchronizing the clock on all nodes (using, for 
instance, MBS protocol [10]).  The nodes divide their time 
into fixed size slots.  Based on the structure of the 
communication tree, the coordinator then and assign 
transmission time slots to each node in a collision-free 
schedule, consider transmissions in both directions (nodes 
reporting actions to the coordinator, and the coordinator 
updates the nodes with new states). The remainder of this 
paper is organized as follows. We present the related work 
in section 2. In section 3, we describe the proposed 
synchronous multihop architecture, SYMA, for wireless ad 
hoc multiplayer games. Section 4 shows the design details 
of SYMA. Finally, section 5 concludes the paper. 
II. RELATED WORK 
Wi-Fi is nowadays a very common and affordable 
technology. This technology can operate on infrastructure 
mode or on ad hoc mode. The former requires an access 
point (AP) while the latter allows nodes to communicate 
directly without any intermediate network equipment. 
Recent portable consoles, like the Sony PSP or Nintendo 
DSi, support the ad hoc mode, allowing gamers to 
improvise multiplayer sessions anywhere. Unfortunately, 
as of the time of this writing, the ad hoc mode on these 
consoles relies on a single hop.  
This restrictive operational mode leads to several 
issues. Indeed, in IEEE 802.11 standards, the CSMA/CA 
mechanism is employed to solve the radio channel 
contention problem. Any node that wants to transmit a 
data has to sense the radio channel to check if the channel 
is currently carrying another transmission. If the channel is 
sensed as idle for a predefined period of time, the node can 
attempt a transmission. Unfortunately, a collision resulting 
from a simultaneous transmission with another node, 
which has also sensed that the channel is idle, can occur. 
In this case, each node can reattempt a new transmission 
after choosing a random period of time. The chosen period 
is obtained thanks to the Binary Exponential Back-off 
algorithm [17]. A node might have to reattempt a 
transmission of the same data frame several times before it 
succeeds. However, the maximum number of attempts is 
limited. Once this threshold number is reached, the data 
frame is discarded and is thus considered as lost. 
The paper [12] considered the support of a First Person 
Shooter (FPS) games in an IEEE 802.11 infrastructure 
LAN scenario. The authors used the Bianchi’s model [2] 
to show how the game MOS (Mean Opinion Score) drops 
when the number of players increases. To improve the 
MOS metric, the authors recommended using the IEEE 
802.11e standard, and giving a high priority to the 
downlink traffic (from server to clients) at the AP.  
Some papers addressed the support of gaming in 
multihop ad hoc networks, which are usually called mobile 
ad hoc networks (MANETs).  In [3], the authors discussed 
and evaluated by simulation possible extensions of 
MANET routing protocols (like AODV) to support QoS 
mechanisms. Typical evaluated mechanisms include 
RTS/CTS and queuing strategies. The game traffic was 
modeled and only network metrics were derived (no 
gaming experience). The support of gaming in MANET 
environment, with an assessment of the game play 
experience was discussed in [5], where the authors 
evaluated the performance of the OLSR routing protocol 
in terms of energy consumption and delay, while 
considering an FPS multiplayer game. The evaluation was 
conducted over a MANET emulation platform, while 
considering a real time game (IoQuake 3) with 
autonomous bots. The performance, in terms of players 
score, fairness, and game duration highlighted the 
inefficiency of OLSR routing protocol with hop count 
metric to support such application. To overcome this 
limitation, the authors presented in [6] a combination of 
the energy and delay metrics that can be considered in 
OLSR. Moreover, to address the disconnection problem 
that can occur due to players’ mobility, the same authors 
proposed in [7] a multi path routing protocol combined to 
a game traffic-balancing algorithm. 
III. SYMA OVERVIEW AND ASSUMPTIONS 
In this section, we describe the synchronous multihop 
architecture (SYMA) for ad hoc wireless multiplayer 
games. We assume that each player is equipped with a 
mobile device with wireless communication ability. Two 
nodes are assumed to have a communication link between 
them and called neighbor nodes if they can communicate 
with each other directly. The communication links are 
assumed to be symmetric. Nodes can form an ad hoc 
wireless network in which a node can send a message to 
any other node through a multihop path. All nodes are 
assumed to have timers that are synchronized with good 
accuracy by some existing mechanism, such as MBS 
protocol [10], a low overhead protocol that works at the 
application layer to achieve an average synchronization 
error around tens of microseconds. Moreover, we assume 
that the players will become semi-stationary to concentrate 
on playing the game once they join a game.  
A game has three phases in SYMA: the invitation 
phase, the construction phase and the gameplay phase. In 
the invitation phase, a node, called initiator, starts a new 
game and invites players to join the game. In the 
construction phase, the initiator constructs the 
communication tree, a game information gathering and 
dissemination tree rooted at a node called the coordinator. 
The initiator also produces a collision-free schedule for all 
nodes to exchange game information. The schedule 
assigns time slots to nodes; its goal is to eliminate 
collisions to speed up the gameplay. In the gameplay 
vj is at the same level as vis parent node. To take the 
scenario in Fig. 3 for an example, node v6 is a fake parent 
node of node v10. The estimated number of extra time slots 
for tree T(vi), ETSi, is defined as: 
                {   
  
  2
    , 
where hi is the height of the tree, Lj is the set of all nodes 
in tree level j, and NFP(v) is the number of the fake parent 
nodes of node v. The EBT of tree T(vi), EBTi, is defined as: 
EBTi = hi + ETSi 
(Step 5) Choose the communication tree: the tree with 
the smallest EBT is selected as the communication tree. If 
two or more trees have the same smallest EBT value, we 
randomly select one of them as the communication tree. 
The root of the selected tree is designated as the 
coordinator to control the game execution. 
 
 
Figure 3.  The shortest path spanning tree rooted at v3 
2) Scheduling: The initiator decides the schedule  
after the communication tree is constructed. As shown in 
Fig. 4, the gameplay phase is divided into several rounds, 
and each round is further divided into three periods: 
action reporting, logic computing and state updating 
periods. Every node sends its parent node all the reports 
received from its children nodes along with its own action 
report in the action reporting period. After gathering all 
action reports sent by its children nodes, the coordinator 
computes the new game state in the logic computing 
period. Then, the coordinator disseminates the new game 
state to all players in the state updating period. 
 
Figure 4.  Game execution in the gameplay phase 
Several time slots are needed to finalize action 
reporting and state updating. The length of a time slot is 
defined to be the maximum expected transmission time for 
transmitting one action report message in a tree edge, that 
is, the longest length of the edge in the tree. The time slots 
for action reporting are assigned in a bottom-up manner, as 
shown in the pseudo code in Fig. 5.  
To sum up, all time slots are marked as idle initially. 
Then, the time slots are assigned to nodes to transmit or 
receive messages. A leaf node is assigned time slot 0 to 
deliver its own action report. A non-leaf node v needs 
|T(v)|1 time slots to receive the reports from all nodes in 
T(v), and needs |T(v)| time slots to deliver the |T(v)|1 
reports along with its own report, where T(v) stands for the 
subtree rooted at v. Therefore, |T(v)| contiguous assignable 
time slots are needed for a node to pack all reports in one 
message. A time slot can be assigned to node v for action 
reporting if it is not assigned to any node vjN(v) or p, 
where N(v) is the set of neighboring nodes of v and p is v’s 
parent node. Note that a time slot can still be assigned to 
node v for action reporting if the time slot has only been 
assigned to p’s neighbor node for receiving messages. Fig. 
6 shows the result of time slot assignment for action 
reporting on the basis of the tree of Fig. 3. 
 
Algorithm ActionReportScheduling 
Input: The communication tree T of height h 
Output: The time slot scheduling of action reporting for each node on T 
FOR each node v in T  //Every node sets each time slot as idle initially 
FOR x in 1..s   //s: the number of time slots 
                        //s should be large enough to accommodate all traffic 
v.slot[x] = IDLE;  //x: the index of time slots 
FOR each leaf node v of T 
       v.slot[0] = TX; 
       parent(v).slot[0] = RX;  //parent(v): the parent node of node v 
FOR l = h1..2  //scheduling in a bottom-up manner 
FOR each node v in SortedSIZE(l) 
//SortedSIZE(l) returns the list of nodes in tree level l sorted increasingly by the size of the 
subtree rooted at each node 
p=parent(v);   //p is the parent node of node v 
sic = 1+ MaxSlotUsed(Child(v)); 
//sic: starting index of contiguous idle slots 
//sic is set to be one plus the maximum index of slots used by all node v’s child nodes 
cur = sic;  //cur: the index of the current slot for checking  
cont = 0;  //cont: the number of contiguous assignable slots 
WHILE cont < |T(v)|  //T(v) is the subtree of T rooted at node v 
IF (uN(v): u.slot[cur]RX) and (uN(p): u.slot[cur]TX) 
cont ++;   
ELSE //collision may occur, current slot is not assignable  
sic = cur + 1;  //set sic to be one plus the current index 
cont = 0;  //reset the number of contiguous idle slots 
cur ++; 
FOR x = sic .. sic + |T(v)|  1 //slot assignment for nodes v and p 
v.slot[x] = TX; 
p.slot[x] = RX; 
Figure 5.  Pseudo code of action report scheduling 
In the state updating period, the new game state is 
disseminated from the coordinator to all other players. 
Therefore, we assign the time slots for state updating in a 
top-down manner. The pseudo code of the state update 
scheduling is shown in Fig 7. The number of slots needed 
for new game state updating is calculated as: 
NSU=DA/DS, where DA is the maximum size of the 
action reporting message and DS is the maximum size of 
the state updating message. The time slots 0 to NSU-1 are 
first assigned to the root node r for transmitting update 
messages, and assigned to rs children nodes for receiving 
the messages. Afterwards, time slots are assigned to other 
nodes, level by level, in a top-down manner. The nodes at 
the same tree level can be assigned the same time slots if 
none of their children nodes has fake parent nodes. 
Otherwise, some nodes must postpone their transmission 
… … Action Reporting State Updating 
 
Time 
Round 
 
Logic Computing 
V. CONCLUSION 
In this paper, we propose SYMA, a synchronous 
multihop network framework for wireless ad hoc 
multiplayer games. Due to the specific characteristics of 
wireless ad hoc networks, we apply Floyd–Warshall 
algorithm and estimate the “expected broadcast time 
without collision (EBT)” value to find a good 
communication tree. We also design a time slot based 
transmission scheduling to avoid collisions of exchanged 
game messages, under the assumption that all player 
devices’ timers are synchronized with an existing time 
synchronization mechanism, MBS protocol, which 
achieves an average synchronization error of tens of 
microseconds. In this way, game messages can be 
efficiently transmitted without collisions to satisfy the 
game timeliness requirement. 
The length of a round should not be too large (usually 
less than 100ms) to guarantee game playability. As we 
have mentioned, if the timer synchronization error is much 
smaller than the round length, the gameplay fairness and 
game state consistency can be guaranteed. Therefore, 
using MBS protocol in SYMA can at the same time satisfy 
game playability, fairness and consistency. Furthermore, 
the length of a round in SYMA is proportional to the 
number of players and the length of time slots, which is 
defined as the maximum time for transmitting one action 
report message through a wireless link. SYMA is thus 
suitable for FPS games that have a small action report 
message size and a small number (e.g., 8 to 64) of players. 
Due to noise of the environment, package loss or delay 
may occur, and game messages may not reach the 
coordinator on time (in the specified round). These 
messages will be transmitted and processed in next rounds 
with higher priority if they are not stale; otherwise, they 
will be dropped. Since the length of a round is much less 
than the reaction time of humans, the case of a message 
delayed for few rounds may still be tolerable. This makes 
SYMA applicable to games like FPS with a small number 
of players. In the future, we plan to implement a wireless 
ad hoc FPS game using SYMA to demonstrate its 
applicability. 
 
REFERENCES 
 
[1] Tom Beigbeder, Rory Coughlan, Corey Lusher, John Plunkett, 
Emmanuel Agu, and Mark Claypool, “The effects of loss and 
latency on user performance in Unreal Tournament,”  
In Proceedings of 3rd ACM SIGCOMM workshop on Network 
and system support for games (NetGames '04), ACM, New York, 
NY, USA, pp. 144-151, 2004. 
[2] G. Bianchi, L. Fratta, and M. Oliveri, “Performance Evaluation 
and Enhancement of the CSMA/CA MAC Protocol for 802.11 
Wireless LANs,” In Proceeding of PIMRC’96, Vol.2, pp.392-396, 
1996. 
[3] D. Budke, K. Farkas, O.Wellnitz, and L. Wolf, “Real-Time 
Multiplayer Game Support Using QoS Mechanisms in Mobile Ad 
Hoc Networks,” In Proceedings of 3rd Annual Conference on 
Wireless on Demand Network Systems and Services (WONS’06 , 
2006. 
[4] Robert W. Floyd, “Algorithm 97: Shortest Path,” Communications 
of the ACM, Vol. 5, Issue 6, pp. 345, 1997. 
[5] Arnaud Kaiser, Nadjib Achir, and Khaled Boussetta, “Multiplayer 
Games over Wireless Ad Hoc Networks: Energy and delay 
analysis,” In Proceedings of International Conference on Ultra 
Modern Telecommunications & Workshops (ICUMT’09 , pp. 1-7, 
2009. 
[6] A. Kaiser, N. Achir, and K. Boussetta, “Improving Energy 
Efficiency and Gameplay Fairness for Time-Sensitive Multiplayer 
Games in MANETs,” IEEE International Conference on 
Communication Workshops,  May 2010 
[7] A. Kaiser, N. Achir, and K. Boussetta, “Improving Quality of 
Gaming in MANETs using a Multipath Approach”, IFIP Wireless 
Days conference, October, 2010. 
[8] J. H. Kim and K. K. Lee, “Throughput and Packet Delay Analysis 
of IEEE 802.11 MAC Protocol for Wireless LAN’s,” Wireless 
Personal Communications, Kluwer academic Publishers, Vol.11, 
No.2, pp.161-183, 1999. 
[9] Yugo Kaneda, Mika Minematsu, Masayo Saito, Hirotp Aida, and 
Hideyuki Tokuda, “ANGEL: A Hierarchical State Synchronization 
Middleware for Mobile Ad hoc Group Gaming,” In Proceedings of 
International Workshop on Pervasive Gaming Applications at 
Pervasive (Pergames), pp. 30-35, 2004. 
[10]  Á lvaro Marco, Roberto Casas, José Luis Sevillano Ramos, 
Victorián Coarasa, Angel Asensio, Mohammad S. Obaidat, 
“Synchronization of Multi-hop Wireless Sensor Networks at the 
Application layer,” IEEE Wireless Communications, Vol. 18, Issue 
1, pp. 82-88, 2011. 
[11] M. Mock, R. Frings, E. Nett, and S. Trikaliotis, “Continuous clock 
synchronization in wireless real-time applications,” In Proceedings 
of the 19th IEEE Symposium on Reliable Distributed Systems, pp. 
125-132, 2000. 
[12] H. Qi, D. Malone, and D. Botvich, “802.11 Wireless LAN 
Multiplayer Game Capacity and Optimization,” In Proceedings of 
the 8th Annual Workshop on Network and Systems Support for 
Games (NetGames’09 , pp. 1-6, 2009. 
[13] K. Römer, “Time Synchronization in Ad Hoc Networks,” ACM 
International Symposium on Mobile Ad Hoc Networking and 
Computing (MobiHoc’01 , pp. 173-182, Long Beach, USA, 
October 2001. 
[14] Kaliappa Ravindran, Ali Sabbir, and Balachandran Ravindran, 
“Impact of Networks Loss/Delay Characteristics on consistency 
Control in Real-Time Multi-Player Games,” In Proceedings of the 
5th IEEE Consumer Communications and Networking Conference, 
pp. 1128-1133, 2008. 
[15] Bharath Sundararaman, Ugo Buy , and Ajay D. Kshemkalyani, 
“Clock Synchronization for Wireless Sensor Networks: A Survey,” 
Ad Hoc Networks, Vol. 3, Issue 3, pp. 281-323, 2005. 
[16] Alf Inge Wang, Eivind Sorteberg, Martin Jarret, and Anne Marte 
Hjemås, “Issues Related to Mobile Multiplayer Real-time Games 
over Wireless Networks,” In Proceedings of International 
Symposium on Collaborative Technologies and Systems, pp. 237-
146, 2008. 
[17] H. Wu and Y. Pan, “Medium Access Control in Wireless Networks 
(Wireless Networks and Mobile Computing ”, Nova Science 
Publishers, 2008. 

nodes can remain inactive to save energy and detecting 
nodes can also help forward event notifications of other 
detecting nodes. The first goal is to maximize the degree of 
WSN barrier coverage while minimizing the number of the 
detecting nodes. The second goal is to make detecting nodes 
sink-connected (i.e., to make sure that every detecting node 
can find a path to send intruding event notification to a sink 
node) by adding a minimum number of forwarding nodes. 
When the number of forwarding nodes decreases, the 
collision probability goes down, and the energy 
consumption in transmissions is thus reduced. 
The remainder of this paper is organized as follows. In 
Sections 2, we introduce some related work. In Section 3, we 
present the network model and problem definitions. The 
proposed algorithm is described in Section 4 and simulation 
results are reported in Section 5. Finally, conclusion is drawn 
in Section 6. 
 
II. RELATED WORK 
 
The notion of barrier coverage was first introduced by 
Gage in [6] aiming at sensor-based surveillance of the 
boundary barrier to minimize the probability of undetected 
enemy penetration through the boundary barrier. In [10], 
Liu and Towsley defined detectability to be the probability 
that no path exists for an object to penetrate a barrier. They 
also characterize the detectability and showed that if the 
sensor node density is below a critical density, an intruder 
can almost surely find a path to cross the barrier without 
being detected. Wang and Cao in [12] also studied how to 
construct barrier coverage to monitor moving objects in 
camera sensor networks. 
Kumar et al. [9] defined the notion of k-barrier coverage 
for precisely representing a WSN’s ability of intruder 
detection. A WSN is said to have the k-barrier coverage 
property if any intruder crossing the barrier is detected 
successful by at least k sensor nodes. The authors developed 
theorems and proposed a centralized scheme using the 
maximum flow algorithm to determine whether a belt 
boundary region is k-barrier covered or not. Besides, they 
showed that the individual sensors cannot locally decide 
whether a network can form barrier coverage due to the lack 
of the global information. Unlike the algorithm in [9] that 
returns either true or false (0 or 1) for measuring the quality 
of barrier coverage, the method proposed by Chen et al. in 
[4] returns a non-binary value for the measurement. They 
also proposed a method to identify local regions whose 
qualities do not reach the desired level of quality.  
Chen et al. [3] proposed a localized algorithm that 
guarantees the detection of intruders whose trajectory is 
confined to a slice of a belt boundary region. Saipulla et al. 
in [11] studied the barrier coverage of WSNs with line-
based deployment, in which sensors are deployed along a 
line (e.g., sensors are dropped from an aircraft along a given 
path). Balister et al. [2] estimated the reliable node density 
that achieves barrier coverage with s-t connectivity in a thin 
strip with finite length, where s-t connectivity means that a 
connected path exists between the two far ends of the thin 
strip. 
 
III. NETWORK MODEL AND PROBLEM 
FORMULATION 
 
In this section, we first describe the network model and 
then formulate the sink-connected barrier coverage 
optimization problem to be solved in this paper. 
 
A. Network Model 
 
Consider a WSN consisting of many sensor nodes and 
few sink nodes, in which sensor nodes are to form a virtual 
sensor barrier for monitoring a belt region to detect and send 
intruding events to one of the sink nodes. The sensor nodes 
are assumed to be randomly deployed; for example, they 
can be dropped from an aircraft as described in [11]. Each 
sensor node is equipped with a sensing module with a fixed 
sensing range to sense intruders and a communication 
module with a fixed communication range to communicate 
with other sensor nodes or sink nodes. Initially, a sensor 
node performs a bootstrapping task to pin point its location, 
discover its neighboring nodes, and report its information, 
such as the identification and the location, to one of the sink 
nodes. The sink nodes are more powerful than sensor nodes. 
They have more energy, memory, computing power and 
communication capacity. They can communicate with each 
other and with sensor nodes; they can also communication 
with the backend system, which is assumed to have 
unlimited power supply and enormous computing power to 
gather all WSN nodes’ information and perform the 
optimization computation. 
Let Vs and Vk denote the set of sensor nodes and the set 
of sink nodes, respectively. Below, we define a coverage 
graph Gc to represent the sensing area coverage 
relationships of nodes. Moreover, we define a transmission 
graph Gt to represent the nodes’ wireless transmission 
reachability relationships.  
 
(1) Coverage Graph 
 
A coverage graph Gc(Vs{S,T}, Ec) is an undirected 
graph, in which Vs is the sensor node set, Ec is the edge set, 
and {S,T} are two virtual nodes. The edge set Ec represents 
the sensing area coverage overlap relationships. For two 
nodes Ni and Nj in Vs, there exists an edge (Ni, Nj) in Ec if 
Ni’s coverage and Nj’s coverage have overlap. As shown in 
Fig. 2, the monitored belt region has the outer side, inner 
side and lateral sides. Intruders are supposed to cross the 
belt region from outer side to inner side. The virtual nodes S 
and T are associated the lateral sides; an edge (Ni, S) or (Ni, 
IV. OPTIMAL NODE SELECTION ALGORITHM (ONSA) 
 
In this section, we propose an algorithm, called optimal 
node selection algorithm (ONSA), to solve the sink-
connected barrier coverage optimization problem. Given the 
sensor nodes Vs, sink nodes Vk, coverage relationship Ec, 
and transmission relationship Et, ONSA can find the 
detecting node set Vr and the forwarding node set Vt. 
ONSA has three main tasks. The first task is to construct the 
coverage graph Gc and then perform the node-disjoint 
transformation to generate the graph Gc* such that Gc* is a 
flow network [5]. The second task is to find the minimum 
cost maximum flow in Gc*. The third task is to construct 
the transmission graph Gt based on Gc* and to find a flow 
plan by executing the maximum flow minimum cost 
algorithm. The nodes selected in the flow plan will be 
activated for constructing sink-connected barrier coverage. 
The details of ONSA are described below. 
 
Optimal Node Selection Algorithm (ONSA) 
 
Input: Vs, Vk, Ec, Et 
 
Output: Vr and Vt 
 
Step 1: Construct a coverage graph Gc(Vs{S,T}, Ec), 
where S and T are virtual nodes. Each edge in Ec is 
associated with one capacity and zero cost. 
 
Step 2: Execute node-disjoint transformation to transfer Gc 
into the new graph Gc*.  
 
Step 3: Execute the maximum flow minimum cost algorithm 
on Gc* to decide the minimum cost flow plan (FPMinCt), and 
let node set Vr contain the selected nodes in FPMinCt. 
 
Step 4: Construct a transmission graph Gt(VsVk, Et). Add 
a virtual source node S and a virtual target node T into Gt.  
 
Step 5: For each node in Vr on graph Gt, add an edge from 
the virtual source node S it to. For each sink node, add an 
edge from it to the virtual target node. 
 
Step 6: Execute node-edge transformation to convert Gt into 
Gt*.  
 
Step 7: Execute the maximum flow minimum cost algorithm 
to find the minimum cost flow (FPT) on Gt*. Let Vb be the 
set of the nodes selected in FPT. 
 
Step 8: Set Vt=Vb-Vr and return Vr and Vt 
 
In step 1, ONSA constructs a coverage graph Gc with a 
virtual node S and a virtual node T. In step 2, ONSA 
executes the node-disjoint transformation to convert each 
node with multiple inbound flows and multiple outbound 
flows into another form. The purpose of the transformation 
is to make the generated graphs node-disjoint. In the 
transformation, a node X will be transformed into a pair of 
nodes X' and X'' with one capacity and one unity cost (refer 
to Fig. 4 (a) ). 
 
 
 
(a) Node-Disjoint Transformation 
 
(b) Node-Edge Transformation 
Figure 4.  Two transformations of ONSA 
In step 3, ONSA executes the well-known maximum 
flow minimum cost algorithm, which has two procedures. 
The first procedure is to find a maximum flow by executing 
the maximum flow algorithm. The second procedure is to 
execute the minimum cost flow algorithm. The readers are 
referred to [5] and [8] for the procedure details. After 
executing the two procedures on Gc*, a set Vr of detecting 
nodes is obtained. Since the flow is maximized, the number 
of node-disjoint traversable paths is also maximized. 
Moreover, since the cost is minimized, the number of nodes 
in Vr is also minimized. 
In step 4, ONSA constructs a transmission graph 
Gt(VsVk, Et) and adds a virtual source node S and a 
virtual target node T into Gt. In step 5, ONSA adds arcs for 
connecting the virtual source node S and the nodes in Vr. 
Each newly added arc is associated with Cost=0 and 
Capacity=∞. 
In step 6, ONSA converts each node (excluding S and T) 
into two nodes with one arc of Cost=1 and Capacity= by 
the node-edge transformation. Please refer to the Fig. 4(b). 
In step 7, ONSA executes the maximum flow minimum 
cost algorithm on Gt* to decide the minimum cost flow 
(FPT). In this step, the nodes containing in FPT will be added 
into the node set Vb. Since FPT has the minimum cost, the 
number of nodes in Vb will also be minimized. 
In step 8, ONSA returns Vr as the set of detecting nodes 
and returns Vt=Vb-Vr as the set of forwarding nodes. 
Below, we take the WSN in Fig. 3 as an example to 
illustrate the execution of ONSA. In step 1, a coverage 
graph Gc will be constructed. After step 2, the nodes with 
multiple inbound flows and multiple outbound flows are 
transformed by the node-disjoint transformation. The 
transformation results are shown in Fig. 5. 
cost=1 
X 
X'' 
X' 
cost=1 
X 
X'' 
X' 
capacity=1 
capacity=∞ 
sink-connected property, we again use the maximum flow 
algorithm for GDA to select extra sensor nodes to serve as 
forwarding nodes to make GDA satisfy the property. In this 
way, GDA and ONSA can both achieve the highest-degree 
property and sink-connectivity property of barrier coverage. 
We develop a simulator based on the MATLAB 
software [13] to solve the optimization problem. The 
simulations are conducted in the following settings. The 
sensing area coverage radius is 10m. The wireless 
transmission radius is equal to the coverage radius. All the 
sensors are randomly deployed by different number of 
sensors in a rectangle-shaped area of 100m x 10m. The 
number of sink nodes is 2 and their locations are 
respectively at (
   
 
m, 5m) and (
     
 
m, 5m) relative to the 
left-most and lowest position of the rectangle. 
We compare ONSA and GDA in terms of the number of 
nodes selected to achieve the highest-degreed and sink-
connected barrier coverage. As shown in Fig. 8, ONSA 
selects fewer nodes than GDA for all cases. It implies that 
ONSA needs fewer nodes than GDA to achieve the highest-
degreed and sink-connected barrier coverage. 
 
 
Figure 8.  Comparisons of ONSA and GDA in terms of the number of 
selected nodes 
VI. CONCLUSION 
In this paper, we studied the sink-connected barrier 
coverage problem to achieve two goals: (1) to maximize the 
degree of barrier coverage using the minimum number of 
detecting nodes and (2) to minimize the number of 
forwarding nodes to hold the sink-connected property. To 
the best of our knowledge, this is the first paper to consider 
the sink-connected property and the barrier coverage quality 
optimization at the same time. An optimal network flow 
planning algorithm, called optimal node selection algorithm 
(ONSA), is proposed to solve the problem. ONSA is based 
on the well-known maximum flow minimum cost algorithm. 
We also perform simulation experiments for ONSA and a 
related algorithm called global determination algorithm 
(GDA), which uses the maximum flow algorithm to find out 
the maximum degree of barrier coverage and does not 
consider the sink-connected property. For the sake of 
comparison, the maximum flow algorithm is again used to 
make GDA satisfy the sink-connected property. The 
simulation results show that ONSA is better than GDA in 
terms of number of selected nodes. 
In the future, we plan to study the optimization of barrier 
coverage with sink-node connectivity under the lifetime 
constraint. The lifetime is usually deﬁned as the time span 
from the time of network deployment to the time when a 
certain fraction of sensor nodes run out of their energy. If 
the lifetime of a wireless sensor network is too short, it is 
likely that the network will soon be partitioned and fail to 
deliver the sensed data to sink nodes. The lifetime constraint 
is thus an important factor to be addressed. 
REFERENCES 
[1]  R. K. Ahuja, T. L. Magnanti, and J. B. Orlin, Network Flows: 
Theory, Algorithms, and Applications, Prentice Hall, Upper 
Saddle River, New Jersey, 1993. 
[2] P. Balister, B. Bollobas, A. Sarkar, and S. Kumar, “Reliable 
density estimates for coverage and connectivity in thin strips 
of finite length,” Proceedings of ACM Mobicom, pp. 75-86, 
2007. 
[3] A. Chen, S. Kumar, and T.-H. Lai, “Designing localized 
algorithms for barrier coverage,” Proceedings of ACM 
Mobicom, pp. 63-74, 2007. 
[4] A. Chen, T.-H. Lai, and D. Xuan, “Measuring and 
guaranteeing quality of barrier-coverage in wireless sensor 
networks,” Proceedings of The ACM International 
Symposium on Mobile Ad Hoc Networking and Computing 
(MobiHoc), pp. 421-430, 2008. 
[5] T.-H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein. 
Introduction to Algorithms (Second Edition), MIT Press and 
McGraw-Hill, 2001. 
[6] D. Gage. “Command control for many-robot systems,” 
Proceedings of the Nineteenth Annual AUVS Technical 
Symposium (AUVS-92), pp. 28-34, 1992. 
[7] M. R. Garey and D. S. Johnson, Computer and Intractability, 
W. H. Freeman and Co., 1979. 
[8] A. V. Goldberg,” An efficient implementation of a scaling 
minimum-cost flow algorithm,” Journal of Algorithm, vol. 22, 
pp. 1-29, 1997. 
[9] S. Kumar, T.-H. Lai, and A. Arora, “Barrier coverage with 
wireless sensors,” Wireless Networks, vol. 13, pp. 817–834, 
2007. 
[10] B. Liu and D. Towsley, “A study on the coverage of large-
scale sensor networks,” in The 1st IEEE International 
Conference on Mobile Ad-hoc and Sensor Systems, pp. 475-
483, 2004. 
[11] A. Saipulla, C. Westphal, B. Liu and J. Wang, “Barrier 
Coverage of Line-Based Deployed Wireless Sensor 
Networks,” IEEE INFOCOM 2009, pp. 127-135, Brazil, 2009. 
[12] Y. Wang, G. Cao, “Barrier Coverage in Camera Sensor 
Networks,” to be presented at ACM MobiHoc’11, Paris, 
France, 2011. 
[13] MathWorks Inc, Matlab Software, URL: 
http://www.mathworks.com. (Accessed at January 8, 2011). 
 
0
50
100
150
200
100 150 200 250
N
u
m
b
er
 o
f 
Se
le
ct
ed
 N
o
d
es
Number of Deployed Sensor Nodes
ONSA
GDA
«¬­®¯5&cC¡°±²X<"#Y³´¨µ¶=>·r
s¸¹º»¼#Y£½¾AAB²"#
X<¿ÀÁÂÃÄA
ÅC¡cÆÇÈÉeÊÁËÌÍ¨ABÎ¶=>?tC¡ÏÐ£
"#ÑÒ¦ÓÔÕÖ×ØÙÚÛ/ILI03/--LMI  2ILp/K-LJÜMP
Ý/MK0L,  m,LÞo(4K,ßIL, àáâã¨½"#Yäåæç"#è
é£Ñêë/ÜIMJ/-Û//QG  3Û/,U/K  ì,pLÞ+MK0/í,KI,- àáÃ 
Hîîî14O[ïð ñ/NNMTÄâã¨òóôõöu÷øujùyú
C¡#Y£¦~¬Ñûêë/ÜIMJ/-Û//QG  3Û/,U/KÃ  Hîîî14O[1 Â
4443ïð ñ/NNMT ínKÞn/2ILp/K-LJÜ  în0/I/m(3Û,PPMKÞ àáÃâ
ãüýrsòóþYDC¡÷£Ñê3,IÞ//Û
OG,JJ/K// Ãâãòb±	
ô÷øb£Ñê
 L,IIL-3,0L, ÃâãZº:òC¡uÕu
÷i£
"#ÑûÒµ¬­2ILp/K-LJÜMPÚJJ,T,1O,I,Þ, C¡c Mn-LP4N
oLÞG,TL 
« 4ìÜI,LQmÜßKLÞ3/KpLQ/Úp/KN,ÜS/JTMKUPMK3/KpLQ/
OMÛM-LJLMI- X<«X<ÃâãxÚp/KN,Ü
S/JTMKU n,NLJÜMP3/KpLQ/ ùyÃ !¾÷øÂÌ"#tÁâ
ã¨Ã$%&ø'(¬­+Hí)12í[Oí,KL-2ILp/K-LJ,-1OSo3í,KL-1
ñK,IQ/  3/ß,-JL/IìMLKL/n àá
«ì/N,ÜQMI-JK,LI/ÞìL/I-LMILI0MP

ûuÆ"c

½"#¹`­AcÄXC¡þYd`e$¼
C¡fÍC¡gBCEFN+'C¡÷89C¡ÃC¡\]h
fCi-jóVÎkk.lmr=DnoC¡pq\]
rs£'÷t½.l¾AVWX<u~d(Acv2~
.lÌw­xyøBCÆu~cz-{\]¹|"ÆY}
\]~>àáuÂDÕ9£

u#

~.-"Ç"Æ½ABCD"£Æ½CD"Ù~Í²
CD"g+¼CD" QÍvóC¡÷BCÁQÆ¿
AÅC¡cz.l¹-"uÇÆAB"#au.
Æ5A².-z"£


Dear Drs. Yung-Liang Lai and Jehn-Ruey Jiang:  
 
I am pleased to inform you that the following paper which you submitted 
to: 
The 2011 International Conference on Wireless Networks (ICWN'11: July 
18-21, 2011, USA) 
has been accepted as a Regular Research Paper (RRP) - ie, 
accepted for both, publication in the proceedings and oral formal 
presentation. Please see below for the categories of accepted papers. 
 
Paper ID #: ICW4609 
Title: Heuristic Resource Allocation with Satisfaction for WiMAX 
Services 
Author(s): Yung-Liang Lai and Jehn-Ruey Jiang 
 
 
Note: The "paper ID #" shown above is composed of three letters 
(conference prefix) followed by four numeral/digits. You will 
need to have this "Paper ID #" at the time of registration and 
final paper submission (for publication). 
 
(The evaluation of this paper is arranged by Track Chair # 29) 
 
General comments to authors of accepted papers: 
  1. Each paper was peer-reviewed by two experts in the field for 
     originality, significance, clarity, impact, and soundness. 
     In cases of contradictory recommendations, a member of the 
     conference program committee was charged to make the final 
     decision (accept/reject) - often, this involved seeking help 
     from additional referees by using a double-blinded review process. 
     In addition, all papers whose authors included a member of the 
     conference program committee were evaluated using the 
     double-blinded review process. Chairs of approved sessions were 
     responsible in evaluating the papers that were submitted to them. 
  2. Authors of accepted papers are strongly encouraged to enhance 
     the organization and the quality of the English writeup of 
     their papers before uploading them to the publication web site 
     for the preparation of the printed books/proceedings. 
-> ICWN'11 paper acceptance rate has been 22% (as of April 15); 
   this does not yet reflect the data for all individual sessions (ie, 
   the acceptance rate is likely to change significantly). 
-> See the appended text for useful information about the conference. 
-> If at least one author of an accepted paper registers for the 
   conference but for some reason he/she is unable to attend the 
   conference, then his/her paper will be published and arrangements 
   would be made to ship the proceedings to the registered author 
   after the conference. However, the registered author MUST inform 
   us by no later than May 15 that he/she will not be able to attend. 
-----------------------auto e.sig: 
H. R. Arabnia, PhD. 
Professor, Computer Science, The University of Georgia, USA 
Coordinator, WORLDCOMP'11 
    http://www.world-academy-of-science.org/ 
Editor-in-Chief, The Journal of Supercomputing (Springer) 
Associate Editor, IEEE Transactions on IT in Biomedicine (T-ITB; 
2007-2010) 
Co-Editor/Board, Journal of Computational Science (Elsevier) 
Elected Fellow, Int'l Society of Intelligent Biological Medicine 
(ISIBM) 
Member, Advisory Board, IEEE Technical Committee on Scalable Computing 
(TCSC) 
URL: http://www.cs.uga.edu/~hra/ 
Tel: (706) 542-3480 /   Cell/Mobile: (706) 340-4707 
email: hra@cs.uga.edu 
The 2011 International Conference on Wireless Networks 
 
satisfaction problem is formulated in Section III for QoS 
resource allocation in the WiMAX network. The proposed 
heuristic genetic algorithm is introduced and evaluated in 
Section IV and Section V, respectively. And finally, some 
concluding remarks are drawn in Section VI.  
 
II. REALTED WORK 
 
In this section, we introduce the related work of QoS Model 
of WiMAX, User Satisfaction Model, and Resources allocation 
schemes. 
 
A. QoS Model of WiMAX 
 
The WiMAX is an IP based mobile network, which 
provides a well-defined framework to support the QoS based 
services. Some examples are the Voice over IP (VoIP) 
telephony service, Internet Access service, and Multimedia 
Broadcast Multicast Service (MBMS), etc. Based on the 3GPP 
Rel. 5 specification [11], the network is consists of multiple 
mobile bearers (e.g. mobile phones, notebooks) to provide end-
to-end quality of services, where the WiMAX base station (BS) 
allocates the spectrum resources for providing the wireless 
services in mobile bearers. The BS can provide a diversity 
classes for different QoS services, which are unsolicited grant 
service (UGS) class, real-time-polling-services (rtPS) class, 
non-real-time-polling services (nrtPS) class, and best effort 
(BE) class. 
Based on the framework, the operator can design and sale 
the products of combining different QoS services.  As shown in 
Fig. 1, the subscribers equipped with different wireless devices 
to access the WiMAX networks, thus base station need to 
provide differential services for subscribers. 
 
 
Figure 1.  Illustration of WiMAX Services 
 
B. User Satisfcation Model 
 
The satisfaction of subscriber is important for the operators. 
Without sufficient resources allocation, the subscriber will 
unsubscribe the services, which will damage the operator’s 
revenue. For example, the acceptable one-way (speaker’s 
mouth to listener’s ear) delay of voice communication for VoIP 
applications recommended by ITU [12] is at most 150 ms. The 
subscriber uses VoIP service will feel unsatisfied if 
transmission delay is more than 150 ms. Such dissatisfactions 
will lead to “user churn” problem reported in [6]. In [6], a 
Sigmoid function is used to approximate the subscriber’s 
satisfaction of resource allocations. The Sigmoid is useful for 
modeling natural processes or system learning curves shown in 
Fig. 2, since it can represent a history dependent progression to 
approaches a limit over time. The Sigmoid distribution 
function depends on a random variable x to represent the 
occupation of resources for the subscriber, which is the utility 
function formulated as: 
 
                      ( )  
 
     (   )
                 (1) 
                
Where α and β are steepness and middle of the curve. In the 
subscribers’ point of view, the α is the sensitivity of the QoS 
and the β is the tolerable limit of failure of QoS.  
 
 
Figure 2.  Curves of Sigmod Function with =0 and different  
 
C. Resource allocation Schemes 
 
The resource allocation is one of most important research 
topics in the WiMAX technology. In [7], the authors proposed 
a pricing model for providing unsolicited grant services (UGS) 
and real time services (rtPS). They proposed a valuation 
0
0.2
0.4
0.6
0.8
1
1.2
-40 -30 -20 -10 0 10 20 30 40
Si
gm
o
d
 F
u
n
ct
io
n
 
=0.2
=0.4
=0.6
=0.8
WiMAX Base Station (BS) 
Internet 
Subscriber 1 
Subscriber 2 
Subscriber 3 
The 2011 International Conference on Wireless Networks 
 
A. Chromosome representation 
 
We use the chromosome (CH) to represent one feasible 
solution to allocate B resources into S services. Each 
chromosome contains (B-S) genes. Each gene is a binary string, 
which contains          bits. The S is the number of services 
and     is the celling function. Each gene represents the 
identities of services, whose value range is in [0, S-1]. In such 
design, we can allocate B resources and the allocation solution 
is without violating constraint (4). In addition, each service will 
add one resource in the Decode step for the constraint (3). 
According to the above-mentioned design, each feasible 
solution is without violating constraints (3)(4). 
For example, we have to allocate B(=7) resources for 3 
services, if we have the following chromosome. 
 
CH= [  1,  2,  2,  2 ] 
 
In the Decode step, the above CH represents that the 
operator need to allocate 2 units for the service 1 and allocate 4 
units for the service 2. 
 
B. Initialization population 
 
The population is randomly assigned. It is notable that 
setting of initial population is fairly simple to our algorithm; 
according to studies in [13], the population can have good 
resilience for randomly setting of initial population. 
 
C. Fitness Function 
 
The fitness function is used to evaluate the performance of 
individuals of the objective. In our design, the performance is 
the revenue, which implies only the individuals with higher 
revenue can survival. It is notable that we use the penalty term 
in (7) to enforce the constraint (5). The λ is the plenty weight, 
which is very large value. Thus, we have the fitness function as 
following: 
 
F = R – PLT                              (7) 
 
The PLT is the plenty function deified as following, where the 
s is the minimum required satisfaction level: 
 
    ∑    *
   
    (   )  +                                        ( ) 
 
V. PERFORMANCE EVALUATIONS 
 
In this section, we evaluate the performance of our 
proposed heuristic resource allocation algorithm. Our 
evaluation objective is to evaluate the revenue and subscribers’ 
satisfactions. We implement our algorithm on the Matlab 
platform [14]. The problem set for testing our algorithm 
contains four testing cases from 18, 19, .., to 24 resources. The 
number of services is 16 services. The setting parameters used 
in the simulation are listed in the table I. 
 
TABLE I.  SIMULATION SETTING PARAMETERS 
Parameter Setting Value 
Crossover Rate 0.7 
Mutation Rate 0.0175 
Generations 1000  
Genre Representation Scheme Bit string 
Plenty weight  () 1000 
Satisfaction level  0.4  
Cost, Price parameters Pstatic = 3 Units, Pdynamic =2 
Units, Cres = 10 Units 
 
The simulation results show the operator’s revenue is 
increased when the number of resources is increased, as 
shown in Fig. 3. Moreover, the users’ satisfactions are more 
than satisfaction level (0.4), which implies that the solution in 
our algorithm does not violate the subscribers’ satisfaction 
constraints, as shown in Fig. 4. 
 
 
Figure 3.  Simulation results in Reveneue on the proposed algorithm 
 
0
20
40
60
80
100
120
18 19 20 21 22 23 24
O
p
e
ra
to
r'
s 
R
e
ve
n
u
e
 
No. of Resources 
Revenue
國際合作研究計畫國外研究報告書 
出國日期: 2011/6/17~2011/6/28 
報告撰寫人: 江振瑞 
 
本次至法國巴黎第六大學與 Maha Abdallah 教授及其博士班研究生
Eliya Buyukkaya 及博士後研究員 Romain Cavagna 進行討論，討論與計畫
相關的 wireless ad hoc games 研究，並共同撰寫論文(Title: “SYMA: A 
Synchronous Multihop Architecture for Wireless Ad Hoc Multiplayer Games” 
by Ta-Yu Huang, Chih-Ming Lin, Jehn-Ruey Jiang, Wei Tsang Ooi, Maha 
Abdallah, Khaled Boussetta)的細節，該篇論文即將發表於 The 5th Workshop 
on Peer-to-Peer Networked Virtual Environments (P2PNVE 2011)。 
 
本篇論文討論如何在 wireless ad hoc network 環境中，建構一個稱為
SYMA 的 self-organizing network architecture，使得各個設備節點的使用者
可以共同參與一個線上遊戲。SYMA 可以分為三個 phases: invitation phase、 
construction phase、gameplay phase。在各個 phase 中的動作如以下所述: 
“In SYMA, devices are assumed to have one-hop neighbor device information, as well 
as timers synchronized with good accuracy. A player, called game initiator, broadcasts 
an invitation message to invite other players to join a new game in the invitation 
phase. A joining player issues a message along with its neighborhood information, 
including the expected transmission time (ETT) for each neighbor node, to reply to 
the invitation so that the initiator can derive the topology of the participating players. 
In the construction phase, the initiator applies Floyd–Warshall shortest path 
algorithm, taking the topology and ETT values as input to construct the shortest path 
spanning tree rooted at each player (or node). It then calculates the expected 
broadcast time (EBT) for each tree, which is useful to estimate the time for the root 
node of a tree to broadcast a game state to all tree nodes. Finally, the tree with the 
smallest EBT is selected as the communication tree and its root is designated as the 
coordinator, which collects timestamped actions of each player, executes the game 
logic, and then broadcasts the new game state in the gameplay phase. By exploiting 
synchronized timers, the game state consistency is guaranteed, and each node can be 
scheduled to send/receive game messages without causing collisions.” 
 
除了合作撰寫論文之外，我們也與 Maha 教授討論 SYMA 架構的實作
事宜。討論的結論為由我方先進行模擬實驗以驗證 SYMA 架構的可行性與
效能，待此部份完成之後，再由我方、巴黎第六大學與另一個合作夥伴 — 
新加坡國立大學 Prof. Wei Tsang Ooi 的團隊共同實施實作。 
player using the Floyd-Warshall algorithm [4].  For each 
of these trees, we estimate the time taken to broadcast a 
packet from the root of the tree to all other nodes, 
assuming there is no collision.  We call this estimated time 
the Estimated Broadcast Time, or EBT.  The tree with the 
smallest EBT is chosen as the communication tree for 
disseminating game traffic, and the root of this tree is 
designated as the coordinator.  The coordinator is 
responsible for collecting events from other nodes, 
calculates the game logic, and then announces the new 
game state to all other nodes. We address the interference 
issue by synchronizing the clock on all nodes (using, for 
instance, MBS protocol [10]).  The nodes divide their time 
into fixed size slots.  Based on the structure of the 
communication tree, the coordinator then and assign 
transmission time slots to each node in a collision-free 
schedule, consider transmissions in both directions (nodes 
reporting actions to the coordinator, and the coordinator 
updates the nodes with new states). The remainder of this 
paper is organized as follows. We present the related work 
in section 2. In section 3, we describe the proposed 
synchronous multihop architecture, SYMA, for wireless ad 
hoc multiplayer games. Section 4 shows the design details 
of SYMA. Finally, section 5 concludes the paper. 
II. RELATED WORK 
Wi-Fi is nowadays a very common and affordable 
technology. This technology can operate on infrastructure 
mode or on ad hoc mode. The former requires an access 
point (AP) while the latter allows nodes to communicate 
directly without any intermediate network equipment. 
Recent portable consoles, like the Sony PSP or Nintendo 
DSi, support the ad hoc mode, allowing gamers to 
improvise multiplayer sessions anywhere. Unfortunately, 
as of the time of this writing, the ad hoc mode on these 
consoles relies on a single hop.  
This restrictive operational mode leads to several 
issues. Indeed, in IEEE 802.11 standards, the CSMA/CA 
mechanism is employed to solve the radio channel 
contention problem. Any node that wants to transmit a 
data has to sense the radio channel to check if the channel 
is currently carrying another transmission. If the channel is 
sensed as idle for a predefined period of time, the node can 
attempt a transmission. Unfortunately, a collision resulting 
from a simultaneous transmission with another node, 
which has also sensed that the channel is idle, can occur. 
In this case, each node can reattempt a new transmission 
after choosing a random period of time. The chosen period 
is obtained thanks to the Binary Exponential Back-off 
algorithm [17]. A node might have to reattempt a 
transmission of the same data frame several times before it 
succeeds. However, the maximum number of attempts is 
limited. Once this threshold number is reached, the data 
frame is discarded and is thus considered as lost. 
The paper [12] considered the support of a First Person 
Shooter (FPS) games in an IEEE 802.11 infrastructure 
LAN scenario. The authors used the Bianchi’s model [2] 
to show how the game MOS (Mean Opinion Score) drops 
when the number of players increases. To improve the 
MOS metric, the authors recommended using the IEEE 
802.11e standard, and giving a high priority to the 
downlink traffic (from server to clients) at the AP.  
Some papers addressed the support of gaming in 
multihop ad hoc networks, which are usually called mobile 
ad hoc networks (MANETs).  In [3], the authors discussed 
and evaluated by simulation possible extensions of 
MANET routing protocols (like AODV) to support QoS 
mechanisms. Typical evaluated mechanisms include 
RTS/CTS and queuing strategies. The game traffic was 
modeled and only network metrics were derived (no 
gaming experience). The support of gaming in MANET 
environment, with an assessment of the game play 
experience was discussed in [5], where the authors 
evaluated the performance of the OLSR routing protocol 
in terms of energy consumption and delay, while 
considering an FPS multiplayer game. The evaluation was 
conducted over a MANET emulation platform, while 
considering a real time game (IoQuake 3) with 
autonomous bots. The performance, in terms of players 
score, fairness, and game duration highlighted the 
inefficiency of OLSR routing protocol with hop count 
metric to support such application. To overcome this 
limitation, the authors presented in [6] a combination of 
the energy and delay metrics that can be considered in 
OLSR. Moreover, to address the disconnection problem 
that can occur due to players’ mobility, the same authors 
proposed in [7] a multi path routing protocol combined to 
a game traffic-balancing algorithm. 
III. SYMA OVERVIEW AND ASSUMPTIONS 
In this section, we describe the synchronous multihop 
architecture (SYMA) for ad hoc wireless multiplayer 
games. We assume that each player is equipped with a 
mobile device with wireless communication ability. Two 
nodes are assumed to have a communication link between 
them and called neighbor nodes if they can communicate 
with each other directly. The communication links are 
assumed to be symmetric. Nodes can form an ad hoc 
wireless network in which a node can send a message to 
any other node through a multihop path. All nodes are 
assumed to have timers that are synchronized with good 
accuracy by some existing mechanism, such as MBS 
protocol [10], a low overhead protocol that works at the 
application layer to achieve an average synchronization 
error around tens of microseconds. Moreover, we assume 
that the players will become semi-stationary to concentrate 
on playing the game once they join a game.  
A game has three phases in SYMA: the invitation 
phase, the construction phase and the gameplay phase. In 
the invitation phase, a node, called initiator, starts a new 
game and invites players to join the game. In the 
construction phase, the initiator constructs the 
communication tree, a game information gathering and 
dissemination tree rooted at a node called the coordinator. 
The initiator also produces a collision-free schedule for all 
nodes to exchange game information. The schedule 
assigns time slots to nodes; its goal is to eliminate 
collisions to speed up the gameplay. In the gameplay 
vj is at the same level as vis parent node. To take the 
scenario in Fig. 3 for an example, node v6 is a fake parent 
node of node v10. The estimated number of extra time slots 
for tree T(vi), ETSi, is defined as: 
                {   
  
  2
    , 
where hi is the height of the tree, Lj is the set of all nodes 
in tree level j, and NFP(v) is the number of the fake parent 
nodes of node v. The EBT of tree T(vi), EBTi, is defined as: 
EBTi = hi + ETSi 
(Step 5) Choose the communication tree: the tree with 
the smallest EBT is selected as the communication tree. If 
two or more trees have the same smallest EBT value, we 
randomly select one of them as the communication tree. 
The root of the selected tree is designated as the 
coordinator to control the game execution. 
 
 
Figure 3.  The shortest path spanning tree rooted at v3 
2) Scheduling: The initiator decides the schedule  
after the communication tree is constructed. As shown in 
Fig. 4, the gameplay phase is divided into several rounds, 
and each round is further divided into three periods: 
action reporting, logic computing and state updating 
periods. Every node sends its parent node all the reports 
received from its children nodes along with its own action 
report in the action reporting period. After gathering all 
action reports sent by its children nodes, the coordinator 
computes the new game state in the logic computing 
period. Then, the coordinator disseminates the new game 
state to all players in the state updating period. 
 
Figure 4.  Game execution in the gameplay phase 
Several time slots are needed to finalize action 
reporting and state updating. The length of a time slot is 
defined to be the maximum expected transmission time for 
transmitting one action report message in a tree edge, that 
is, the longest length of the edge in the tree. The time slots 
for action reporting are assigned in a bottom-up manner, as 
shown in the pseudo code in Fig. 5.  
To sum up, all time slots are marked as idle initially. 
Then, the time slots are assigned to nodes to transmit or 
receive messages. A leaf node is assigned time slot 0 to 
deliver its own action report. A non-leaf node v needs 
|T(v)|1 time slots to receive the reports from all nodes in 
T(v), and needs |T(v)| time slots to deliver the |T(v)|1 
reports along with its own report, where T(v) stands for the 
subtree rooted at v. Therefore, |T(v)| contiguous assignable 
time slots are needed for a node to pack all reports in one 
message. A time slot can be assigned to node v for action 
reporting if it is not assigned to any node vjN(v) or p, 
where N(v) is the set of neighboring nodes of v and p is v’s 
parent node. Note that a time slot can still be assigned to 
node v for action reporting if the time slot has only been 
assigned to p’s neighbor node for receiving messages. Fig. 
6 shows the result of time slot assignment for action 
reporting on the basis of the tree of Fig. 3. 
 
Algorithm ActionReportScheduling 
Input: The communication tree T of height h 
Output: The time slot scheduling of action reporting for each node on T 
FOR each node v in T  //Every node sets each time slot as idle initially 
FOR x in 1..s   //s: the number of time slots 
                        //s should be large enough to accommodate all traffic 
v.slot[x] = IDLE;  //x: the index of time slots 
FOR each leaf node v of T 
       v.slot[0] = TX; 
       parent(v).slot[0] = RX;  //parent(v): the parent node of node v 
FOR l = h1..2  //scheduling in a bottom-up manner 
FOR each node v in SortedSIZE(l) 
//SortedSIZE(l) returns the list of nodes in tree level l sorted increasingly by the size of the 
subtree rooted at each node 
p=parent(v);   //p is the parent node of node v 
sic = 1+ MaxSlotUsed(Child(v)); 
//sic: starting index of contiguous idle slots 
//sic is set to be one plus the maximum index of slots used by all node v’s child nodes 
cur = sic;  //cur: the index of the current slot for checking  
cont = 0;  //cont: the number of contiguous assignable slots 
WHILE cont < |T(v)|  //T(v) is the subtree of T rooted at node v 
IF (uN(v): u.slot[cur]RX) and (uN(p): u.slot[cur]TX) 
cont ++;   
ELSE //collision may occur, current slot is not assignable  
sic = cur + 1;  //set sic to be one plus the current index 
cont = 0;  //reset the number of contiguous idle slots 
cur ++; 
FOR x = sic .. sic + |T(v)|  1 //slot assignment for nodes v and p 
v.slot[x] = TX; 
p.slot[x] = RX; 
Figure 5.  Pseudo code of action report scheduling 
In the state updating period, the new game state is 
disseminated from the coordinator to all other players. 
Therefore, we assign the time slots for state updating in a 
top-down manner. The pseudo code of the state update 
scheduling is shown in Fig 7. The number of slots needed 
for new game state updating is calculated as: 
NSU=DA/DS, where DA is the maximum size of the 
action reporting message and DS is the maximum size of 
the state updating message. The time slots 0 to NSU-1 are 
first assigned to the root node r for transmitting update 
messages, and assigned to rs children nodes for receiving 
the messages. Afterwards, time slots are assigned to other 
nodes, level by level, in a top-down manner. The nodes at 
the same tree level can be assigned the same time slots if 
none of their children nodes has fake parent nodes. 
Otherwise, some nodes must postpone their transmission 
… … Action Reporting State Updating 
 
Time 
Round 
 
Logic Computing 
V. CONCLUSION 
In this paper, we propose SYMA, a synchronous 
multihop network framework for wireless ad hoc 
multiplayer games. Due to the specific characteristics of 
wireless ad hoc networks, we apply Floyd–Warshall 
algorithm and estimate the “expected broadcast time 
without collision (EBT)” value to find a good 
communication tree. We also design a time slot based 
transmission scheduling to avoid collisions of exchanged 
game messages, under the assumption that all player 
devices’ timers are synchronized with an existing time 
synchronization mechanism, MBS protocol, which 
achieves an average synchronization error of tens of 
microseconds. In this way, game messages can be 
efficiently transmitted without collisions to satisfy the 
game timeliness requirement. 
The length of a round should not be too large (usually 
less than 100ms) to guarantee game playability. As we 
have mentioned, if the timer synchronization error is much 
smaller than the round length, the gameplay fairness and 
game state consistency can be guaranteed. Therefore, 
using MBS protocol in SYMA can at the same time satisfy 
game playability, fairness and consistency. Furthermore, 
the length of a round in SYMA is proportional to the 
number of players and the length of time slots, which is 
defined as the maximum time for transmitting one action 
report message through a wireless link. SYMA is thus 
suitable for FPS games that have a small action report 
message size and a small number (e.g., 8 to 64) of players. 
Due to noise of the environment, package loss or delay 
may occur, and game messages may not reach the 
coordinator on time (in the specified round). These 
messages will be transmitted and processed in next rounds 
with higher priority if they are not stale; otherwise, they 
will be dropped. Since the length of a round is much less 
than the reaction time of humans, the case of a message 
delayed for few rounds may still be tolerable. This makes 
SYMA applicable to games like FPS with a small number 
of players. In the future, we plan to implement a wireless 
ad hoc FPS game using SYMA to demonstrate its 
applicability. 
 
REFERENCES 
 
[1] Tom Beigbeder, Rory Coughlan, Corey Lusher, John Plunkett, 
Emmanuel Agu, and Mark Claypool, “The effects of loss and 
latency on user performance in Unreal Tournament,”  
In Proceedings of 3rd ACM SIGCOMM workshop on Network 
and system support for games (NetGames '04), ACM, New York, 
NY, USA, pp. 144-151, 2004. 
[2] G. Bianchi, L. Fratta, and M. Oliveri, “Performance Evaluation 
and Enhancement of the CSMA/CA MAC Protocol for 802.11 
Wireless LANs,” In Proceeding of PIMRC’96, Vol.2, pp.392-396, 
1996. 
[3] D. Budke, K. Farkas, O.Wellnitz, and L. Wolf, “Real-Time 
Multiplayer Game Support Using QoS Mechanisms in Mobile Ad 
Hoc Networks,” In Proceedings of 3rd Annual Conference on 
Wireless on Demand Network Systems and Services (WONS’06 , 
2006. 
[4] Robert W. Floyd, “Algorithm 97: Shortest Path,” Communications 
of the ACM, Vol. 5, Issue 6, pp. 345, 1997. 
[5] Arnaud Kaiser, Nadjib Achir, and Khaled Boussetta, “Multiplayer 
Games over Wireless Ad Hoc Networks: Energy and delay 
analysis,” In Proceedings of International Conference on Ultra 
Modern Telecommunications & Workshops (ICUMT’09 , pp. 1-7, 
2009. 
[6] A. Kaiser, N. Achir, and K. Boussetta, “Improving Energy 
Efficiency and Gameplay Fairness for Time-Sensitive Multiplayer 
Games in MANETs,” IEEE International Conference on 
Communication Workshops,  May 2010 
[7] A. Kaiser, N. Achir, and K. Boussetta, “Improving Quality of 
Gaming in MANETs using a Multipath Approach”, IFIP Wireless 
Days conference, October, 2010. 
[8] J. H. Kim and K. K. Lee, “Throughput and Packet Delay Analysis 
of IEEE 802.11 MAC Protocol for Wireless LAN’s,” Wireless 
Personal Communications, Kluwer academic Publishers, Vol.11, 
No.2, pp.161-183, 1999. 
[9] Yugo Kaneda, Mika Minematsu, Masayo Saito, Hirotp Aida, and 
Hideyuki Tokuda, “ANGEL: A Hierarchical State Synchronization 
Middleware for Mobile Ad hoc Group Gaming,” In Proceedings of 
International Workshop on Pervasive Gaming Applications at 
Pervasive (Pergames), pp. 30-35, 2004. 
[10]  Á lvaro Marco, Roberto Casas, José Luis Sevillano Ramos, 
Victorián Coarasa, Angel Asensio, Mohammad S. Obaidat, 
“Synchronization of Multi-hop Wireless Sensor Networks at the 
Application layer,” IEEE Wireless Communications, Vol. 18, Issue 
1, pp. 82-88, 2011. 
[11] M. Mock, R. Frings, E. Nett, and S. Trikaliotis, “Continuous clock 
synchronization in wireless real-time applications,” In Proceedings 
of the 19th IEEE Symposium on Reliable Distributed Systems, pp. 
125-132, 2000. 
[12] H. Qi, D. Malone, and D. Botvich, “802.11 Wireless LAN 
Multiplayer Game Capacity and Optimization,” In Proceedings of 
the 8th Annual Workshop on Network and Systems Support for 
Games (NetGames’09 , pp. 1-6, 2009. 
[13] K. Römer, “Time Synchronization in Ad Hoc Networks,” ACM 
International Symposium on Mobile Ad Hoc Networking and 
Computing (MobiHoc’01 , pp. 173-182, Long Beach, USA, 
October 2001. 
[14] Kaliappa Ravindran, Ali Sabbir, and Balachandran Ravindran, 
“Impact of Networks Loss/Delay Characteristics on consistency 
Control in Real-Time Multi-Player Games,” In Proceedings of the 
5th IEEE Consumer Communications and Networking Conference, 
pp. 1128-1133, 2008. 
[15] Bharath Sundararaman, Ugo Buy , and Ajay D. Kshemkalyani, 
“Clock Synchronization for Wireless Sensor Networks: A Survey,” 
Ad Hoc Networks, Vol. 3, Issue 3, pp. 281-323, 2005. 
[16] Alf Inge Wang, Eivind Sorteberg, Martin Jarret, and Anne Marte 
Hjemås, “Issues Related to Mobile Multiplayer Real-time Games 
over Wireless Networks,” In Proceedings of International 
Symposium on Collaborative Technologies and Systems, pp. 237-
146, 2008. 
[17] H. Wu and Y. Pan, “Medium Access Control in Wireless Networks 
(Wireless Networks and Mobile Computing ”, Nova Science 
Publishers, 2008. 
99 年度專題研究計畫研究成果彙整表 
計畫主持人：江振瑞 計畫編號：99-2628-E-008-011- 
計畫名稱：社交網路延遲感知同儕式好友群播技術 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 4 4 100%  
博士生 2 2 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 6 2 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
