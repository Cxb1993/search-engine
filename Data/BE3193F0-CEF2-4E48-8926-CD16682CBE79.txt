of automotive electronic system toolkits and ESL tools. It includes 5 
subprojects and they are system toolkits for automotive electronics, 
automotive communication architecture, system-level power-
thermal tools, automotive real time operating system, automotive 
image application, and independent verification and validation for 
automotive electronic software systems.Subproject 1 is led by Prof. 
Jen-Kuen Lee. The important research topics to investigate include: 
AUTOSAR RTE implementation and optimizations, Modular 
development toolkits, ESL system simulation, OpenCL for 
embedded automotive applications and multi-core optimizations. 
Subproject 2 is led by Prof. Yarsun Hsu. The research team will 
take charge of researching and designing the automotive 
communication systems part, in order to support any needs during 
the development of simulation platform in the main project. The 
main research items include studying automotive network 
communications protocols and the design and implementation of the 
AUTOSAR compatible communication models. Our project aims at 
the most commonly used communication protocols, including 
conventional LIN/CAN buses and emerging FlexRay/MOST high-
speed protocols. Subproject 3 is led by Prof. Shi-Yu Huang. This 
team will focus on the research and development of a system-level 
power-thermal co-simulation software tool for heterogeneous multi-
core-based car electronics applications. Subproject 4 is led by Prof. 
Wei-Kuan Shih and Prof. Shang-Hong Lai. This subproject will 
focus on the research and development of automotive real-time 
operating system and high performance image processing software. 
The real-time operating system provides the basic software and 
services for the automotive electronic systems. The image 
processing software is aimed for active safety driving application. 
Subproject 5 is led by Prof. Chin-Yu Huang. We both broadly and 
deeply study how to provide standardized independent verification 
and validation solutions for automotive electronic and software 
systems. In the first-year of this project, we will study Automotive 
Software Engineering. Thus in the second-year project, we will 
focus on the approach and challenges faced by engineers developing 
AUTOSAR-compliant production code using Model-Based design. 
 
II 
 
Abstract 
In this project, we propose to develop the system toolkits for the development of automotive electronic 
systems. As the demand of automotive electronic systems keeps growing. The automotive electronic 
systems include multi-purpose ECU/MCU for car control、Active & Passive Safety systems、In-Dash 
Navigation, and In Vehicle Infotainment. That increased the design complexity of automotive electronic 
systems. It is an important issue for all the car manufacturers and automotive electronic system suppliers. 
The innovations for the system toolkits will play an important role to meet these challenges. 
This is an advanced technology integration project for development of automotive electronic system 
toolkits and ESL tools. It includes 5 subprojects and they are system toolkits for automotive electronics, 
automotive communication architecture, system-level power-thermal tools, automotive real time operating 
system, automotive image application, and independent verification and validation for automotive 
electronic software systems. 
Subproject 1 is led by Prof. Jen-Kuen Lee. The goal of this sub-project is to investigate research issues 
and challenges ahead for developing automotive electronic systems toolkits compliant to international 
standard. The important research topics to investigate include: AUTOSAR RTE implementation and 
optimizations, Modular development toolkits, ESL system simulation, OpenCL for embedded automotive 
applications and multi-core optimizations, compiler and language support framework for soft errors 
detection.  
Subproject 2 is led by Prof. Yarsun Hsu. The research team will take charge of researching and 
designing the automotive communication systems part, in order to support any needs during the 
development of simulation platform in the main project. The main research items include studying 
automotive network communications protocols and the design and implementation of the AUTOSAR 
compatible communication models. Our project aims at the most commonly used communication 
protocols, including conventional LIN/CAN buses and emerging FlexRay/MOST high-speed protocols. 
We plan to build their modeling, write drivers, and make optimization studies with requirements and 
constraints. Then we will finish the AUTOSAR compatible communication models, i.e. buses and 
gateways, and to integrate them into the simulation platform with other subprojects and eventually 
implement these proposed communication architectures by FPGAs. 
Subproject 3 is led by Prof. Shi-Yu Huang. This team will focus on the research and development of 
a system-level power-thermal co-simulation software tool for heterogeneous multi-core-based car 
electronics applications. Furthermore, this subproject will also develop a panoramic video system (which 
combines 4 to 6 distributed cameras’ video to provide a continuous panoramic view to the car driver) as 
an example application to assess the tool to be developed. 
Subproject 4 is led by Prof. Wei-Kuan Shih and Prof. Shang-Hong Lai. This subproject will focus 
on the research and development of automotive real-time operating system and high performance image 
processing software. The real-time operating system provides the basic software and services for the 
automotive electronic systems. The image processing software is aimed for active safety driving 
application. 
Subproject 5 is led by Prof. Chin-Yu Huang. In this 3-years project, we will both broadly and deeply 
study how to provide standardized independent verification and validation solutions for automotive 
1 
 
報告內容 
壹、前言 
汽車電子化的發展已經數十載，汽車內所搭載的電子系統從與行車控制相關的電子元件(ECU)
以及微控制元件(MCU)到行車安全防護、車載導航(In-Dash Navigation)和車用資訊娛樂系統
(In-Vehicle Infotainment)，這些電子系統提高了行車的安全、便利以及滿足了資訊娛樂的需求，但
是電子系統整合所帶來的製造以及後續維護成本已經逐漸超過製造一輛汽車的百分之五十，這對
於各大車廠以及各個車用電子元件製造商來說是一個非常重要以及需要解決的議題。
AUTOSAR(AUTomotive Open System Architecture)是由世界個大車廠以及汽車電子晶片和相關電
子軟硬體製造商所成立的聯盟，主要在推行一個開放式的車用電子軟體標準來解決車用電子系統
軟硬體整合的問題。 
 
AUTOSAR 將車用電子系統的關鍵功能加以標準化和模組化，同時制定了汽車電子等控制系
統模組軟體開發的開放式標準，以促進車輛平台、車用電子系統間軟硬體的共用。目前主流的全
球各大車廠以及車用電子系統製造商、嵌入式軟體和車載資訊系統開發公司皆依循此標準來開發
其相關軟體，對於要切入主要車用 ECU 以及相關車用電子系統的國內廠商，依照此趨勢來開發其
車用電子系統軟硬體是必需要考量的議題。 
 
本計畫將力主於開發一個符合國際標準的『車用電子系統開發平台』，這個開發平台將會由下往上
整合了車用匯流排網路的連結設計與車用電子元件功耗與溫度的驗證，並且進行車用即時作業系統以
及安全駕駛影像辨識軟體的開發，最後是加入重要的車用電子與軟體獨立驗證與確認的機制。此符合
國際標準的開發平台對於國內許多優秀嵌入式系統軟硬體的廠商，將協助其開發與驗證車用電子軟體
來快速進入封閉的車用電子系統市場，本計畫的執行將可培育相關 SoC 人才增進其有關車用電子系統
的 domain know-how，與國際接軌增進競爭力。 
 
 
 
 
 
3 
 
組軟體開發的開放式標準，以促進車輛平台、車用電子系統間軟硬體的共用。目前主流的全球各大
車廠以及車用電子系統製造商、嵌入式軟體和車載資訊系統開發公司皆依循此標準來開發其相關軟
體，對於要切入主要車用 ECU 以及相關車用電子系統的國內廠商，依照此趨勢來開發其車用電子
系統軟硬體是必需要考量的議題。 
 
II. 子計畫各關鍵技術其背景資訊及其他國內外相關之研究發展茲敘述如下： 
(a) 車用電子系統開發平台工具組 
一套符合國際標準的車用電子系統開發平台工具組，對於車電系統供應商來說是非常重要的，藉
由此模組化的開發工具，幫助車電系統製造商從上描述 ECU 的硬體規格，以及定義共同的軟體溝
通介面，最後產生與硬體控制相關的基礎軟體 (OS, ECU abstraction, drivers, services, 
communication, …)以及相關的 runtime 環境(APIs, data types, … )、跟應用程式，縮短整個車電元件
的軟硬體開發時程，遵循國際標準的車電元件軟體介面，可在不同汽車平台上運作，同時可重複使
用，將大大降低汽車電子軟體整合成本，提高車廠採購意願提昇其產值。目前國外相關車電軟體開
發供應商已紛紛推出支援 AUTOSAR 標準的開發工具，提供需求管理、相關系統描述、ECU 規格
配置以及基礎軟體和作業系統等服務。隨著車用安全系統功能的擴增，影像處理器的負載也將隨之
加重，如何善用影像處理器多核多執行緒的特性來減輕負載會是一個很重要的議題，目前使用者在
多核心、多執行緒的程式開發上仍面臨許多困難，因此在此計畫中我們提出以加入 OpenCL 語法來
控制此影像處理器，使處理器中的多核多執行緒以及 Long-SIMD 的特性可以充分的發揮。OpenCL
基於 C99 語法為 C 語言的擴充，定義了底層平行運算單元的程式語法，利用此語法所撰寫的程式
稱之為 Kernel，此外 OpenCL 亦提供了許多控制平台的 API，可方便使用者控制底層運算單元，在
平行運算機制方面，OpenCL 提供了基於 Tasks 分割和 Data 分割的並列運算機制，在撰寫平行程式
時具有相當大的彈性。本計畫也將針對 Compiler and Language supports for soft error 進行相關研
究，進幾月來發生了多起某知名車廠爆衝以及電子油門與煞車的問題，造成多起車安意外危及駕駛
人生命安全，而該車廠也大量回收有問題的車種，面臨了龐大的檢修費用與消費者的求償，在初步
的調查階段中發現可能是相關的電子元件軟體出了問題，車電系統是一個特殊的嵌入式系統環境，
需要非常高的軟體可靠度，所以這項研究中我們將從編譯器以及程式語言的角度來建立一個車用軟
體錯誤偵測框架(Compiler and Language support framework for soft errors detection)，用以幫助偵測車
用軟體開發時可能發生的錯誤，提高其可靠度。 
 
(b) 車用電子系統連結排網路架構之研究 
為了能夠滿足新款車種的安全、舒適與娛樂的需求，車用電子系統的數目也快速增加，它們之間
需要彼此大量快速的傳遞交換資訊，更加複雜、講求效能的車用通訊網路便應運而生，以目前最豪
華的轎車來說，內部便具有高達 2500 個訊號在 70 個電子控制單元間相互傳遞。基於車內各系統的
需求考量，所採用的通訊網路便有所不同，例如以安全性考量的操控與輔助系統，便是以 FlexRay
之類的高速網路作為骨幹；其他如僅需要低速交換訊息的系統，便會採用更通用低廉的 CAN 匯流
排，甚至更不重要的部份是用更低速但成本更低的 FIN 匯流排；針對最近出現結合通訊與多媒體的
應用，也出現類似 MOST 這種針對大量資料傳輸、講求品質的通訊協定；另外由於車內同時存在
如此多種架構的網路比需彼此連結，因此如何安排各車內電子的連結與橋接器的設計將大大地影響
到整體效能。本計畫目的在於建立協助車用電子軟體開發的模擬平台，因此本研究團隊將負責提供
符合 AUTOSAR 所制定的統一規格相關的各種車用通訊協定研究與設計，包括模組化與最佳化的架
構實現。由於汽車產業競爭激烈，各車廠以往都是各自訂立及採用不同的通訊協定，不過目前已逐
5 
 
狀態、駕駛人行為預估、警告駕駛人行車偏離車道、引導駕駛人等等。在這些目的中，如何在各種
環境下正確地偵測車道的位置便是很重要的課題。為了更加保護駕駛者的安全，車輛偵測技術將從
車用攝影機裡偵測出行駛中的車輛並估測其距離，進一步持續追蹤每一部車輛的行駛軌跡，可以幫
助駕駛者行車上的安全並即時提醒與前一輛車是否有保持適當的距離、是否有危險發生。 
 (e)車用電子與軟體系統之獨立驗證與確認 
汽車內的電子控制單元(ECU)隨著電子系統的增加而增加， ECU過多易引起部件故障；ECU軟
體構造各異，不易控制ECU聯合工作。1980 年代的汽車電子程式，若換算成C語言的行數來計算，
約是 2,000 行。然而到了 2000 年，已經暴增到 200 萬行。也就是說在 20 年之間成長了 1,000 倍，
據了解Lexus LS460 的車載電子系統，軟體部份的程式碼已達一億行程式碼，ECU軟體數量龐大，軟
體開發難以為繼。因此在汽車製造業裡，車輛軟體工程(Automotive Software Engineering，ASE)的
研究便扮演了非常重要的角色，其包括了汽車電子系統和軟體的核心開發過程、用戶需求分析和系
統邏輯結構的確定、邏輯功能結構分析和系統技術結構的確定、軟體的需求分析和軟體結構的確
定、軟體元件的描述、軟體元件設計和實現、軟體元件測試、軟體元件整合、軟體整合測試、系統
元件整合、系統測試和驗收測試、軟體功能描述和有效性驗證、工具和電子控制單元間之非車載介
面、邏輯系統結構分析和技術系統結構描述、軟體功能描述和有效性驗證、資料模型描述、軟體函
數的設計及實現、軟體功能，校正等等。軟體故障問題通常會導致非常嚴重的代價，輕則車輛回收、
損害名譽，重則乘車生命消失因此在這些產業中，獨立驗證與確認(Independent Verification and 
Validation，IV&V)是必要的步驟，因其可提高產品的可靠度，這是非常重要的度量指標。對車用模
組類可靠度驗證而言，目前除各大車廠自行訂定規範外(如NISSAN：NDS01、FIAT/ALFA ROMEO 
9.90110、VOLKSWAGEN VW 801 01、GMW3172、HYUNDAI NO.ES 91500-00、FORD 00.00EA- 
D11-1 等)，美國則以汽車工程師協會(Society of Automotive Engineers)為主要標準，歐洲則以
ISO16750 系列為汽車電子可靠度驗證標準，其中包括了part 1~part 5 均有做詳細規格說明，日本則
以日本自動車組織(Japanese of Automobile Organization)為主要標準，國際間則有IEC EN 60721 以及
IEC 605 做為車用電子模組可靠度參考標準等等。最後，汽車屬耐久財，講求高可靠度，其生命週
期也相對較長，對於品質與可靠度要求相當高，產品使用環境惡劣，相對於資訊電子產業，產業投
資回收期相當長，資訊電子產業切入車輛電子領域，需要在經營文化作調適。然而值得注意的是在
汽車電子與軟體系統中，IV&V是非常耗時的程序。當軟體開發初期、測試個案(Test Case)產生、實
際測試和分析測試結果皆會包含此過程。當然，進行越多的測試對提高軟體的可靠度有很大幫助。
不過一旦考慮到開發時間和花費，則必須進行有限度的測試，且在複雜的軟體系統中，徹底地測試
是不太可行。因此在本三年期的研究計畫裡，我們將針對汽車電子與軟體系統IV&V來進行兼具深
度與廣度的研究。 
送端錯誤包含 ACK 錯誤、格式錯誤、位元錯誤，接收端錯誤包含 CRC 錯誤、填充位元錯誤。 
z 錯誤狀態： 
 CAN 藉由在3個不同錯誤狀態(如圖2所示)中更改端點對匯流排的
控制能力，來避免錯誤的端點消耗所有匯流排的頻寬，或是終止整
個系統。 
7 
 
 主動錯誤狀態（Error active）：端點可以傳送，可以接收。 
 被動錯誤狀態（Error passive）：端點可以接收，不可以傳送。 
圖 2 CAN 匯流排錯誤狀態示意圖 
 匯流排關閉（Bus off）：端點不可以接收，不可以傳送。 
 但是 CAN 這類的使用總線架構(Bus topology)的通訊協定來
說，最大的弱點就是所有的原件都是直接透過 BUS 互相連接，並沒
有適當的錯誤抑制來防止錯誤的傳播。 
 圖 3 CAN bus 上可能會發生錯誤
 
要抑制錯誤首先要能夠分辨錯誤的種類，下面是 CAN BUS 上五種常見的錯誤情況: 
z 節點錯誤(Stuck-at node fault):此類錯誤發生在節點本身損壞時，常見的兩種情況是:不斷的輸出高
準位訊號、不斷的輸出低準位訊號，由於 CAN 的特性是低準位支配，因此不斷的輸出低準位訊號
將會造成整個通訊網路的嚴重錯誤。 
z 短路錯誤(Shorted medium fault):此類錯誤發生在當通訊的介質因為電路短路被連接到電池或接地
時。當這類錯誤發生時通訊網路將無法傳送資料。 
z 開路錯誤(Medium partition fault):此類錯誤發生的原因是通訊的介質被斷開為數個子網路。當此錯
誤發生時在不同網路的節點將無法通訊，而且因為開路訊號反射的關係，在同一子網路的節點也
可能無法通訊。 
z 位翻轉錯誤(Bit-flipping fault):此類錯誤是當通訊網路中的某些元件，存在著無法正確控制的行為，
會隨機的送出錯誤的訊號，干擾正確的訊息。常見發生的原因包括:節點損壞、連接器不良，都有
可能會隨機的送出錯誤訊號。 
z 混串音錯誤(Babbling-idiot fault):次類錯誤發生時代表有節點錯誤的送出訊息，佔用了珍貴的網路
資源，使的真正需要傳送的訊息無法被及時送出。此類的錯誤通常肇因於軟體的設計不良，例如
陷入了一個會不斷重送訊息的無限迴圈。 
 
許多論文提出了不同的方法來抑制上述的錯誤，例如使用雙重的通訊通道；或是使用可重新組態
的通訊通道，像是 RedCAN；或使使用總線監控(bus-guardian)的方法。 
 但是這些方法都無法避免因為總線架構(bus topology)所帶來的缺點，也就是任一個原件上發生的
錯誤都可能造成整個通訊系統嚴重錯誤。使用雙重通訊通道可能會有共模故障(common mode failure)
的問題，因為兩條通訊通道距離很接近會受到同一干擾源的影響。使用 RedCAN 處理當錯誤都發生在
相鄰的節點時的情況，而且需要額外的硬體來支援這個方法。使用總線監控(bus-guardian)只可以抑制
由節點所發出的錯誤，若錯誤發生在通訊網路的其他部分則沒有效果，而且也可能會有共模故障
z 錯誤診斷機制: 
 
圖 6 Enabling/Disabling 的內部設計 
偵測錯誤的機制是藉由計算各種可能是錯誤情況的數據模式(data pattern)當這些數據模式發生的次數
超過預設的門檻值(threshold)時，錯誤治癒模組便會發出禁用(disable)的訊號，讓錯誤的節點被隔離開
來。 
可能的發生錯誤的數據模式有三類: 
 持續輸出低準位錯誤(Stuck-at-Dominant Faults):由 DBC Manager Module 來計算連續送出的高
準位位元數，當超過門檻值時判定為錯誤。 
 持續輸出高準位錯誤(Stuck-at-Recessive Faults):由 NACKC Manager Module 來觀察那些節點
沒有在應該發出 ACK 訊號時正確行為，當超過門檻值時判定為錯誤。 
 位翻轉錯誤(Bit-Flipping Faults):由 BFC Manager 來觀察那些節點送出來的訊號有位翻轉錯
誤，當超過門檻值時判定為錯誤。 
 
 這項設計實作出來的重要結果有:Hub 所造成的額外延遲為 155ns(由輸入輸出模組所造成的額外
延遲為 120ns)。實作時提供了 8 和 16 個連接埠的方案，最大的傳輸速率為 690 kbit/s，在這個速率下可
接受的最大延遲大約為 1267nsm。由收發器所造成的延遲為(4 * 60ns = 240 ns )，由 hub 內部所產生的
延遲為 35ns，若使用 70m 長的電纜線會有(70m * 4.5 ns =315 ns)的延遲，因此總延遲時間(240*2 + 315*2 
+35*2 =1180 ns )仍在可接受範圍內，但是一旦把電纜線加長到 80m 就超出了 CAN 通訊協定的安全規
範，可能會發生錯誤。 
 
二、 時間觸發與餘備匯流排 
在CAN匯流排系統中，每個節點都包括兩個控制器(如圖七
所示)，分別是主控制器(HC) (Host Controller)和CAN協定通訊控
制器(CC) (Communication Controller)，主控制器是由控制應用端
的微處理器(microcontroller)所組成，負責處理應用端收到的資料
再將其傳送給通訊控制器，通訊控制器將收到的訊息包裝成CAN
圖 7 CAN 匯流排節點架構圖 
9 
 
建立一個擁有j條餘備匯流排的標準CAN bus，在傳送訊息時，每一條訊息餘備匯流排上都傳送一樣的
資料但傳送時間與前一條匯流排相差一個時間延遲D，另外增加要求傳送位元(TXRQ)，以及新資料旗
幟 (NEWDAT)來做對系統的控制。 
訊息傳送步驟： 
在傳送開始時，先暫停中斷功能(interrupt)，並準備需要傳送的訊息，從第一個匯流排開始傳送訊息，
在傳送的過程中會預先設定一段時間，超過這段時間懷無法接到完整訊息，則判斷此傳送失敗，會寄
利錯誤旗幟(error flag)，再等了一個時間延遲D之後，會在下一個餘備匯流排上傳送一模一樣的訊息，
直到在每一個餘備匯流排傳送完畢後，才會結束傳送步驟。(如圖10所示) 
訊息接收步驟 
當節點在某一個頻道中收到中斷指令(表示接受到新訊息)，頻道會立即暫停中斷功能並標記時間印記
(time stamp)，將之前的所有餘備匯流排標記錯誤旗幟，並繼續收接下來的餘備匯流排裡的餘備訊息，
直到收到最一個餘備匯流排所傳送的訊息，或是等到一個時間延遲，才會在開啟中斷功能，結束接收
步驟。(如圖十一所示) 
 
圖 10 訊息傳送步驟流程圖  圖11 訊息接收步驟流程圖 
 
在時間觸發的系統中，時間同步(clock synchronization)佔了非常重要的角色，時間同步做得好可以
獲得明顯較好的效能以及任務同步，在標準CAN協定中有一項填充編碼功能（bit stuffing）會造成訊息
長度不同，提高系統不可預測性，並進而影響時間的準確性，此種問題可使用軟體上的填充編碼來改
善，此外在系統一開始，或是節點剛加入系統時，可能會有部分節點沒有得到同步的時間，在此段時
間內，沒有達成同步的節點可以傳送任何訊息。 
這個通訊系統由於增加了餘備匯流排，在一個匯流排上訊息的錯誤或遺失，可以在一段時間延遲
後另一個匯流排上接收到該訊息，大大提升了系統錯誤容忍度，舉例如圖12：假設一個有三條匯流排
的系統(一條主匯流排，兩條餘備匯流排)，若每條匯流排都成功傳送訊息(如圖十二左)，則其他節點可
接收到三份相同的訊息，不會有錯誤產生，如果匯流排一(如圖12中)或匯流排一二(如圖12右)傳送失
敗，都仍可藉由剩下正常傳送的匯流排獲得所需接收的資料。 
11 
 
在TTBR-CAN系統中存在兩種節點，一為非常規節點(SN)(super node)，一為常規節點(NN)(normal 
node)，非常規節點(SN)負責所有保存或是製造系統網路同步的行為，此外，它們也接收並傳送各種與
系統或應用端相關的資料。常規節點(NN)傳送並接收應用端資料，但只能接收同步訊息或對該訊息做
出相對應動作，無法產生同步訊息。 
TTBR-CAN系統使用三種不同的訊息型態(如圖14所示)，分別為同步訊息
(SYNCs)(SYNChronization messages)、心跳訊息(HBs)(Heart Beat messages)以及資料訊息(MSGs) (data 
MeSsaGes)，同步訊息只包含認證碼(id)的部分，沒有後面資料區域(data field)，其中前面5個位元用來
表示訊息種類，接著8位元用來表示節點標籤，再來8個位元做為表示此次傳送是在第幾個循環(cycle)(在
有新節點加進來時，新節點可靠著個數字知道系統現在是在第幾個循環，並將自己與系統做同步)，最
後的位元保留給未來使用。心跳訊息是用來做同步確認，除了部分資料區域用來傳送用以調整同步時
間的資訊，其餘部分用來傳送節點所需傳送的正常資料。資料訊息完全使用在傳送節點須傳送的資料。 
 
圖 14 TTBR-CAN 訊息型態 
在進行同步動作時，每個非常規節點(SN)都會計算一個時間延遲D，傳送同步資料的時機是在循環
週期(Tcom)扣掉個別的延遲時間(D)，節點會在全度的匯流排上傳送牠的同步訊息，當送出同步訊息在
匯流排上可能會遭遇三種狀況，第一種是匯流排為空閒狀態，此時非常規節點可以順利的將同步訊息
在匯流排上進行傳輸，第二種為產生碰撞情形，這種情況下訊息會自動在匯流排上進行仲裁，第三種
強況為匯流排上已有一訊息再傳送，此時同步訊息會自動取消掉。由於在不同匯流排上可能會由時間
延遲，造成裁定的結果不盡相同，但系統只會選擇第一個成功出現在任一匯流排上的同步訊息當作下
一個通訊循環的開始。在一個非常規節點打開的時候，它會等待任何匯流排上同步訊息的接收來讓自
己與系統同步，若等待了兩個通訊循環都沒有收到同步訊息，非常規節點就會送出自己的同步訊息，
這表示當一個節點沒有成功的送出同步訊息，另一個節點便會立刻取代它發出同步訊息，不會有延遲
出現在下一個通訊循環的開始。但這個同步不走有兩個問題，第一是只傳送同步訊息的非常規節點若
產生錯誤會無法被偵測(不確定是仲裁失敗或傳送失敗)，第二是時間頻率的不匹配可能造成通訊循環週
期時間縮短。要解決這兩個問題，每個非常規節點都被分配一個時間用來傳送心跳訊息，心跳訊息包
含了可以用來調整節點時間頻率的資訊，藉由這些資訊可以減少節點間頻率的不匹配。此外，心跳訊
息也可用來監控節點以及頻道是否正常執行，當只有一個頻道上的心跳訊息遺失，則表示是這個頻道
出了問題；若所有頻道上的心跳訊息都遺失，則表示是節點發生錯誤。 
節點可以在每個時間預先指定執行某些程序，程序種類包含同步訊息傳送(SendSYNC)、心跳訊息
傳送(SendHB)、資料訊息傳送(SendMSG)、心跳訊息讀取(ReadHB)、資料訊息讀取(ReadMSG)、時間
調整(AdjTCK)、和開始任務(StartTSK)，前面三個程序表示三種訊息的傳送，心跳訊息讀取處理最後收
到的心跳訊息，資料訊息讀取將從最後接收到的資料訊息上讀取到的資料傳送給應用端，時間調整計
13 
 
 圖 19 應用端任務執行的同步性測試結果 圖 18 程序執行的同步性測試結果 
第二部分的測試是針對錯誤容忍率進行測試，在這
部分的是利用偵測傳送同步訊息時網路上產生的節點錯誤或是頻道錯誤，第一種錯誤是頻道錯誤(如圖
20(a)所示)，在第三個循環時加入錯誤，在第三個循環之前，在兩個頻道上都可順利傳送同步訊息，在
第三個循環後，只剩一個頻道可成功傳送同步訊息，而產生錯誤的頻道被另一節點的同步訊息取代。
第二部分測試是假設目前節點無法成功傳送同步訊息的情況(如圖20(b)所示)，在第三個循環後，兩個
頻道都被另一節點的同步訊息取代。 
 
 圖 20 錯誤容忍率測試結果(a)頻道錯誤 (b)節點錯誤 
 
TTBR-CAN系統可以成功實行餘備匯流排機制，此外可以減少各節點間的頻率不匹配，也可以增加錯
誤偵測能力以及容忍度。 
 
 Power and thermal Design： 
15 
 
System-on-a-Chip (SoC) designs consist of heterogeneous design components such as processors, DSPs, 
memories, bus, bridges, and other IPs with various functions as well as software components. As predicted 
in [45] , the SoC power consumption will continue to grow rapidly for the next decade due to the 
ever-increasing size and complexity in a SoC. The issues induced by power consumption are also becoming 
17 
 
事故類型統計資料，全世界每年因車禍受傷的人數高達了 2,000 萬人，而死亡人數為 120 萬人，因車
禍造成的財產損失也佔了全球國民生產毛額 2%。根據 WHO（世界衛生組織）的資料估計，全球的車
禍死亡率在 2020 年將提高至 67%；而德國與美國的研究數據顯示，有 93%的交通意外事故發生，導
因是駕駛人的行為因素，而未注意車前狀態皆排名首位。因此為了提升交通安全，車用攝影機將扮演
重要角色，幫助駕駛人分析道路狀況與提供附加警示，而行人偵測更是有絕對的必要性需要被應用在
車用影像處理中的技術之一。 
安全性的要求如此的重要，但以車用電子系統的角度來看，安全性重視的就是系統能夠及時的判
斷外界的危險信號，並且即時的反應。此外安全性確保的工作，必定得確認他的最優先性。而車用電
子系統為了達成這樣的目標，定然需要採用即時系統。在這樣的考慮之下，了解 AUTOSAR 架構中即
時作業系統將是我們研究的主軸。 
對於即時系統而言，每一個即時性工作能在多核心處理器的電腦上都能夠被正確的執行是相當重
要的。根據即時系統的定義[64][65][66][67]，每個即時性的工作都有其各自的規定完成時間(Deadline)，
而即時系統則必頇保證每一個即時性工作都能在此規定時間內完成[68][69]。因此我們必頇能夠預測即
時性工作將於何時完成，以決定目前該採取何種排程策略。 
除此之外，即時系統是一個明確的或可能性的對時間有所需求的系統。在過去，即時系統是利用
循環方式，一次又一次的反覆執行。在 1970 年代到 1980 年代，大家逐漸發現及體會利用循環式所產
生的系統是非常沒有彈性且不易維護，因此在 1980 年代開始研究各種可能的排程策略。此外在即時
排程理論中，優先權是用來對工作做排程的一個規則，並讓系統內的工作能有順序地去存取電腦資源。
系統中的每個工作都有一個被釋放時間、執行時間、及一個結束時間，其中結束時間可為一個絕對時
間或是一個相對於被釋放時間的相對時間。在優先權排程中，則可根據某一策略去給定每個工作一個
優先權，擁有較高優先權且已經預備好的工作才有優先權力去使用系統資源。基本上，若一個任務有
一個規律性被釋放的時間，則稱此任務是周期性任務，其中的每個工作被釋放的時間間隔長度為一固
定值 Ti，稱此任務的周期。反之若是一個任務沒有一個規律性被釋放的時間，稱為一非周期性任務，
每個任務含有兩個固定值，分別為每個工作執行時間的上界 Ci 及每一釋放時間的最小間隔 Ti。在固定
優先權任務的排程中，同一個任務的所有工作將有相同的優先權，通常用τi 來表示一個任務，其中 i 值
即為優先權，且 i 值越小所代表的優先權越高。在有關優先權的任務上，通常會利用一些決定任務的
時間限制下，觀察任務是否在其執行時間內可順利完成執行的可行性分析，來預測任務的執行時間的
行為。 
在 1973 年，Liu 及 Layland [70]所發表有關週期性任務排程的研究中，最具洞察力的貢獻在於
Critical instant theory。此理論提到，對於一個有固定優先權的週期性任務集合而言，Critical instant 發
生在當所有擁有較高優先權的任務同時發生執行時，因為是固定優先權的任務，所以在前 i-1 個較高
優先權任務執行時，加入第 i 個時，此任務不知是否可以順利的完成執行。除此之外，Liu 及 Layland 
還證明Rate-Monotonic(RM) policy 是一個最佳化的靜態任務優先權分配法則，其中Rate-Monotonic(RM) 
policy 是當一個任務的週期越短，其優先權越高的規則，因為每個任務的週期是固定不變的，所以是
任務間的優先權關係也是固定不變的。一組利用 Rate-Monotonic(RM) policy 的 n 個任務集合，若所有
任務的效能和小於等於 n(21/n－1)，此任務集合則可被成功的排程完成，當 n 趨近於無限大時，n(21/n
－1)會趨近於 ln2。此 n(21/n－1)，趨近於 ln2 是一個 tight bound，即為在小於 n(21/n－1)，時可保證此
課題，因為車用的影像常常是在車輛高速移動下所擷取而來，因此背景的快速移動與車外場景的轉換
是重要的問題之一，監視影像系統常用的背景影像去除前處理(background subtraction)顯然不適用於車
用攝影系統；另外，外在環境光源的不確定性，也會造成行人偵測的困難，烈日強光下的高度反光及
過度曝光，夜間行車時因大燈照射造成的高對比亮度變化，以及光線未投射處的低光源，都會使影像
擷取系統因成像環境不佳而無法產生清晰的行人影像，更進一步增加行人偵測的難度。我們這個計畫
主要目的就是開發出一套夜間行人影像增強技術，輔助駕駛人克服夜間能見度差及視覺死角多的問
題，以電腦視覺技術增進行車安全性。 
傳統的電腦視覺系統多使用單張影像或是連續影片，而為了克服上述困難，目前已發表的車用行
人偵測系統，多利用立體視覺技術 (stereo vision technique) [51][52][55][56]或紅外線影像處理技術
[59][62]，以較多的輸入資訊來達到準確且快速運算的目的。Broggi et al.[52]在視覺實驗自動車輛 ARGO 
中，在車頭裝設了兩個平行的同步照相機，並設計了一套簡單的行人偵測演算法。這套系統先各自針
對左右圖像套入垂直、水平 edge 偵測，再利用簡單的對稱性檢測粗略找出一些可能的行人圖像區域，
接著使用立體視覺方法更新物體深度資訊，藉以判別行人與車子的距離。 
Zhao 與 Thorpe[51]提出了一套以立體視覺與類神經網路建構而成的行人偵測系統，如下頁左圖所
示，同一物體會分別投影於左右影像不同的位置上，而物體間也會因為距離投影平面的深度不同，而
有不同的位移。所以我們可以利用左右兩具經校準得知參數的攝影機，反推求得物體深度，並建構如
同下圖右(b)的 disparity map，再將影像依深度切割成幾個區塊，套入類神經網路人型分類器中判別。
這套系統宣稱可以處理多種光源、多種姿勢的人型，並且達到即時運算的速度。 
 
圖 21、立體視覺與類神經網路建構 
Grubb et al.[55]和 Gavrila et al.[56]也依類似的觀念，利用 stereo vision 的技術還原前方物體深度，
並依物體 3D 深度而在左右影像對應區域上做行人偵測，因此兩套系統建構於影片攝影機上，故在後
處理時加入時間軸上的追蹤資訊，進一步增進系統準確率。 
19 
 
Suard et al. [62]則使用自然影像行人偵測中廣為使用的 Histogram of Oriented Gradients(HOG)特徵
值，套用在紅外線影像上，以 SVM 為基礎發展了一套行人偵測演算法。實驗測試顯示，使用 1000 筆
學習資料訓練偵測器，在偵測率為 90%的設定下，誤判機率只有約 2X10-2，應用於真實紅外線影像時，
同樣準確率設定下，每 330 張影像只會出現一個多餘的誤判。 
車用電子與軟體系統之獨立驗證與確認： 
車用軟體對於安全性和可靠性的要求是不同於一般軟體。以一般桌上型電腦而言，突然的當機使
用者只需重新啟動，損失有限，然對於車用軟體系統，當機是絕對不允許的。在車用軟體開發過程
中，為了讓產品儘快上市，往往是寫個程測試一下，功能完成了，開發過程就算完成。然而在軟體開
發過程中倘沒經過充分且且完整的測試，隱藏的軟體錯誤就在蟄伏在程式之中。一般而言，車用軟體
的開發通常是由相關行業或協力廠商中富有經驗的工程師來完成的，他們對相關產品富有經驗，但對
於車用電腦的認識恐尚達不到職業級的水準，寫出的程式碼可能存在一些平時會忽略的問題。另外，
一些車用應用系統，往往是從功能簡單的系統發展而來的。例如現今的汽車黑盒子的駕駛紀錄器產
品，往往部份僅僅記錄一個時段的車速等狀態，算不上嚴格的安全性系統。開發者可能使用一層迴圈
加上中斷就完成基本功能的開發。後來，用戶端提出了更多的功能要求，於是新功能逐一被加上去，
程式變得越來越大，越來越難以維護。為了保證車用軟體的安全性，除了在整個軟體開發過程中要一
邊開發、一邊自我檢查、測試之外，對於嚴格的安全性系統，更需要有專門的程式測試人員，甚至一
支與開發隊伍並列的測試隊伍來保證代碼的安全性。隨著汽車電子在車輛控制方面的高速發展，汽車
電子用嵌入式軟體的安全可靠性變得越來越重要。在汽車製造業裡，車輛軟體工程(Automotive 
Software Engineering，ASE)的研究便扮演了非常重要的角色。 
ASE 具體的定義了非常切確的標準(ISO/IEC 12207，IEC 61508 標準)和使用的成熟度模型
(ISO/IEC 15504)。ASE 的研究包括了汽車電子系統和軟體的核心開發過程、用戶需求分析和系統邏輯
結構的確定、邏輯功能結構分析和系統技術結構的確定、軟體的需求分析和軟體結構的確定、軟體元
件的描述、軟體元件設計和實現、軟體元件測試、軟體元件整合、軟體整合測試、系統元件整合、系
統測試和驗收測試、軟體功能描述和有效性驗證、工具和電子控制單元間之非車載介面、邏輯系統結
構分析和技術系統結構描述、軟體功能描述和有效性驗證、資料模型描述、軟體函數的設計及實現、
軟體功能，校正等等。圖一則為車輛軟體與系統工程主要研究架構。  
 
 
 
車輛軟體與系統工程架構 
另一方面，由於汽車應用軟體大都用 C 語言寫成，很多寫法在 ANSI 的 C 以及相應的 C 編譯器看
來並沒有什麼問題，但對汽車軟體而言，安全可靠性方面存在著隱藏的問題。例如 MISRA(Motor 
21 
 
 圖 25.  AUTOSAR 軟體架構圖 
z AUTOSAR Software :  
在 RTE 之上的 AUTOSAR 軟體階層包含著所有之後要形成 ECU 裡的各個 AUTOSAR 軟體元件，
所有的 AUTOSAR 軟體元件與不可分割的軟體元件(包含其它 AUTOSAR 軟體元件、AUTOSAR 
Services、ECU Abstraction、Complex Device Drivers)之間的連接與通訊都是透過 AUTOSAR RTE
層來幫忙，而軟體元素之間的連接都是藉由 AUTOSAR 介面來確保它們在 RTE 層的連接性。 
z AUTOSAR Runtime Environment, RTE :  
在AUTOSAR RTE層，它幫忙ECU與ECU之間、ECU裡交換資訊與溝通，提供給上層的AUTOSAR
軟體元件相同的介面與服務來做互相溝通。對於同個 ECU 裡的溝通，RTE 提供 IOC 模組來實作，
例如函式呼叫的方式；當軟體元件與其它 ECU 裡的軟體元件溝通時，RTE 使用 COM message 來
實作，例如透過 CAN 來幫忙與其它 ECU 溝通，從 RTE 層經由 BSW 中 Communication 軟體模組、
ECU Abstraction 軟體模組連接到 Microcontroller Abstraction 軟體模組裡面的溝通管道(如 CAN、
LIN、FlexRay、MOST )，進而來與其它 ECU 互相溝通。為了讓資源使用較有效率以及得到較好
的效能，通常每顆 ECU 裡的 RTE 並不完全相同。  
z AUTOSAR Basic Software, BSW :  
提供 AUTOSAR 軟體元件所需要的服務，將會執行應用軟體中功能性的部分，分為標準元件(前四
項)和特定 ECU 元件(後二項)，如下： 
1. Services: 系統提供的服務，如診斷協定、NVRAM、flash、記體管理等。 
2. Communication: 包含溝通的機制(CAN、LIN、FlexRay等)、I/O管理以及NETWORK管理。 
23 
 
25 
 
如圖二十六所示，RTE、BSW Scheduler、AUTOSAR OS 之間的連接方式是透過 AUTOSAR 所定
義的標準介面 (Standardized interface) - AUTOSAR OS API 來溝通。在 RTE 配置的階段會使
RunableEntitys 和 BSW Schedulable Entities 對應到 OS tasks，RTE generator 階段則是負責產生 OS task
的內容，包含對 RunableEntitys 和 BSW Schedulable Entities 的呼叫。因為此二種 Entities 和 OS 並無關，
所以並不可以直接使用到 OS 的服務，必須透過 RTE 的 RTE API 和 Basic Software Scheduler 的 Basic 
Software Scheduler API 來幫忙呼叫 RunableEntitys 和 BSW Schedulable Entities 起來執行。以下分別對
OS Objects、RunableEntitys 和 BSW Schedulable Entities 做介紹： 
z OS Objects 
1. Tasks 
9 由RTE generator產生TASK的內容，為一段程式碼，用來描述OS object的配置內容。 
9 在OS配置的時候，RTE configurator必須生成所分配的tasks。 
9 RTE和Basic Software Scheduler負責控制TASK的活動與中止，可選擇 (1)直接呼叫OS 
services 像 是 SetEvent() 或 ActivateTask() 、 (2) 間 接 地 初 始 化 OS alarms 、 (3) 使 用
Schedule-Tables來讓RunableEntitys起來執行；當task要結束時，在TASK的內容裡會呼叫
TerminateTask()或ChainTask()。 
2. OS applications 
9 AUTOSAR OS在4.0版本稱作Inter-OS-Application Communication(IOC)。OS applications
在OS產生後給RTE使用來將TASK和runnable對應起來。 
3. Events 
9 OSEvents: RTEEvents、BswEvents 
9 OS service function: SetEvent()、WaitEvent()、GetEvent()、ClearEvent() 
9 使用到的OS Events為RTE generator要輸入資訊的一部分。 
9 在OS配置階段，RTE generator必須分配需要的events。 
4. Resources 
9 RTE和Basic Software Scheduler可能使用OS Resources來實作資料一致性的機制。 
9 OS services function: GetResource()、ReleaseResource() 
9 使用到的OS Resources為RTE generator要輸入資訊的一部分。 
9 在OS配置階段，RTE generator必須分配需要的Resources。 
5. Interrupt Processing 
9 AUTOSAR OS提供不同的服務函式來處理中斷的enabling/disabling。RTE可以使用這些函
式而不能使用編譯器和處理器相關的函式來處理中斷。 
z Basic Software Schedulable Entities ( BasicSchedulableEntitys ) 
BasicSchedulableEntitys 由 BSW Scheduler 所控制，其實作內容為主要的處理函式。
BasicSchedulableEntitys可允許被map為basic tasks以及 extended tasks二種型別。BasicSchedulableEntitys
也可以選擇要不要 map 為 RunableEntitys，如果會使用到 AUTOSAR Services、ECU Abstraction、Complex 
Device Drivers 則必須 map 為 RunableEntitys。如果不 map 到 RunableEntitys 則會被分類到 Runnable 
Entities 中的 Category 1。 
C.  RTE層中元件(Components)之間的通訊與排程機制 
AUTOSAR 之核心架構 RTE 層為 AUTOSAR VFB 中對於某顆 ECU 介面的實現，提供軟體元件間
或軟體元件與 BSW 元件之間互相溝通的介面，下圖二十七為 RTE 的服務的對象以及主要的概念，幫
助軟體元件之間的通訊以及軟體元件之間的運行活動(concurrency)或稱之為排程。 
 
圖 27.  AUTOSAR 軟體架構圖 
z Concurrency 
在 AUTOSAR 裡每個元件之間的運行都是透過 RTE 呼叫 RunableEntity 起來執行，每一個元件都
必須包含一個以上的 RunableEntitys， 
RTE 觸發 RunableEntitys 起來執行的事件稱為 RTEEvent，每個 RunableEntitys 都必須定義好為屬於
何種 RTEEvents，不然將不可被 RTE 觸發起來執行。RTEEvents 包含以下幾種情況： 
1. TimingEvent 
2. BackgroundEvent 
3. SwcModeSwitchEvent 
4. AsynchronousServerCallReturnsEvent 
5. DataReceiveErrorEvent 
6. OperationInvokedEvent 
7. DataReceivedEvent 
8. DataSendCompletedEvent 
27 
 
 圖 29.  VFB 中 Client-Server 通訊介面之呈現 
2. Sender-Receiver 
Sender-Receiver 用於非同步的分散式系統。在 Sender-Receiver 的通訊介面裡，發送端不會被
block 住也不需要得到接收端的回覆，發送端只負責提供資訊給接收端，接收端則自行決定要如何
處理這個資訊。而當傳送資訊時，發送端不需要知道接收端的個數及身份。下圖三十為
Sender-Receiver 通訊機制的介面，它提供一對多的溝通方式，讓一個發送端可以同時與多個接收
端連接。 
 
圖 30.  VFB 中 Sender-Receiver 通訊介面之呈現 
Sender-Receiver 的資料傳輸的模式分為 Implicit 與 Explicit 二種，前者 RTE 會在 runnable 被執行之
前讀一段特定的資料區塊並在 runnable 被結束後自動的寫一段不同的特定資料區塊，而不是 runnable
自行初始傳輸的動作；若為 Explicit 傳輸模式，元件將使用明確的 RTE API 的呼叫來傳送資料區塊。
下表為較詳盡 Implicit 與 Explicit 的接收與傳送比較。 
29 
 
車用電子系統連結網路架構之研究： 
CAN 控制器設計與模擬 
從 OpenCores 這個團體的專案中取用了 CAN 控制器的硬體描述語言(Verilog)，在經過一些修改後初步
完成我們的 CAN 網路模擬，這項實驗是在友晶科技的 DE2-70 FPGA 平台開發版上完成，軟體和其他
元件利用的是 Altera 的 SOPC 平台，訊號的測量和驗證使用的是孕龍科技的邏輯分析儀。 
首先我們要對 CAN 控制器的設計有深入的了解，可以分為幾個重要的區塊: 
 
圖 31  
 BaudratePrescaler:把整個系統統一提供的時鐘(System Clock)訊號，經過使用者設定的參數調
整之後做除頻，產生一個較慢的時鐘訊號(Scaled Clock)提供給 BSP 和 BTL 使用。 
 Shift Register:用來存放要要送出去和收進來的資料。 
 Bit Stream Processor(BSP):負責與使用者端溝通，提供控制器的狀態，同時讓使用者透過讀寫
暫存器的方式來控制整個 CAN 控制器。另外還要負責決定要如何處理待送和已收入的資訊。 
 Bit Timing Logic(BTL): 整個控制器的物理層級(physical layer)就由 BTL 來做精準地控制，必
須要負責在正確的時機送出資訊，和在正確的時機取樣(sample)來讓整個通訊的行為完成。 
在利用硬體語言模擬器(NC Verilog)跑過一些測試(testbench)以後，初步確定這個通訊器的行為正確。因
此我們需要一個更真實的平台來測試這個 CAN 控制器。由於要控制 CAN 通訊控制器本身就是一件複
雜的行為，因此我們需要一個處理器來幫我們完成這個任務。 
為了快速地建立出整個平台，決定採用SOPC作為我們的設計平台。SOPC為系統在可程式的晶片上
(System on-a-programmable-chip)的簡稱。此設計方式將邏輯電路、記憶體、IP與嵌入微處理器放在一個
可程式的邏輯元件上。 
31 
 
 圖 34 Wishbone Bus 的的架構 
 NiosII軟體發展環境叫做NiosII整合發展環境(IDE)。NiosII IDE是建構在GNU C/C++ 組譯器和
Eclipse IDE，以提供一個軟體發展的環境。利用NiosII IDE，設計者可以立即的開發和模擬NiosII軟體
應用。並在模擬板上驗證雛型設計的正確性。Nios系統週邊允許NiosII嵌入式軟體FPGA內部邏輯和Nios
模擬板上的外接硬體做連接與溝通。利用SOPC Builder來設定名稱、型態、記憶體位址、和系統週邊
的中斷。 
透過SOPC 和Nios開發環境的結合我們可以順利的在友晶科技DE2-70這塊板子上模擬CAN通訊控
制器的使用情況。驗證的方法我們透過孕龍科技的LAP-C(322000)邏輯分析儀來收集CAN Bus上的訊
號，並使用該公司提供的匯流排協定分析軟體來做為驗證的工具，若該匯流排協定分析軟體能更成功
解析我們架構的CAN通訊網路上的訊號，則代表這次的模擬是成功的。 
 
 
圖 35 邏輯分析儀收集到的訊號和分析結果  
透過上圖我們可以看到分析軟體成功的解析了 CAN 傳送出來的訊號，依序可以看到藍色部分為 ID 
field，橘色部分為 Control field，綠色部分為 Data field，灰色部分為 CRC，粉紅色部分為 ACK。這項
模擬平台的建立有助於未來在建立更完整的車用電子網路時的參考，一旦透過類似的方法，將可以很
快地建立起一個實體的實驗機制，來驗證我們對於車用電子網路的提出的想法和改進。 
 
 
 
33 
 
PowerMixer
RTL
VCD file
Netlist
PowerBrick
Standard Cells/
Memory Macros
Co‐Program
Verilog‐XL
Power
Library
Co‐Program
HSPICE/
NanoSim
Power Consumption
Report
(Application Dependent)
Load
file
Delay
file
PVT
Setting
 
Fig. 37: PowerMixer works with PowerBrick. 
 
PowerMixer: RTL/Gate‐level Power Estimation 
 
PowerMixer can perform either gate-level or RTL power simulation. For RTL power simulation, as 
depicted in Fig. 37, a Verilog simulation co-program is invoked to construct the power model for the design 
using gate-level simulation results by applying some training input vectors extracted from RTL VCD. During 
this process, PowerMixer takes the design files, including netlist, value change simulation dump file in a 
format such as VCD, delay file and loading file, and based on the power libraries generated by PowerBrick to 
calculate the power consumption and then generate the power report. If the physical information files in 
Design Exchange Format (DEF) and Library Exchange Format (LEF) are further provided, PowerMixer is 
able to generate physical power map, which links the power profile of each cell with its location information 
ity map of the design. in the physical layout to visually display the power dens
PowerMixerIP: IP‐based Power Analysis 
 
PowerMixerIP can build an IP-based power model for a given IP design, and integrate this IP-based power 
model easily into a SoC platform to perform IP-based power analysis. In the IP-based power modeling 
process, PowerMixerIP can build the power models for various kinds of IPs such as processor cores, SRAM, 
bus, bridges, EMDMA, and so on. As shown in Fig. 38,  PowerMixerIP first invokes PowerMixer to perform 
gate-level or RTL power simulation to produce accurate power waveform of the IP under modeling with some 
user-specified training VCD files, and then builds operation-mode-based power model for a general IP or 
instruction-level or even pipeline-stage-accurate model for a processor [40] . The input files of PowerMixerIP 
include the training VCD files for charactering the power models, and some configuration files, i.e., 
operational-mode file (.OMF) and key signal file, used to describe the operation modes, such as active mode, 
idle mode when modeling general IPs, or to indicate some key parameters of the processor, such as pipeline 
depth, instructions per fetch, instruction type registers, and program counter register when modeling 
processors. 
 
35 
 
PowerDepot
Power
Monitors
IP Power
Models
ESL Platform
Power 
Monitor 
Generation
Power 
Monitor 
Insertion
Name Map File
ESL  Re-
SimulationPower Profile
 
Fig. 40: ESL power analysis flow. 
二、Quick Power Estimation of Application SW 
Instead of integrating the IP-based power models into the ESL platform as we discussed in Sec 
(PowerDepot: ESL Power Analysis), we can also generate a standalone C program to do the power estimation 
of some application software running on a virtual multi-core SoC. As shown in Fig. 41, after the IP power 
modeling stage is done, then in the system-level power profiling stage, we integrate all the IP power models 
into a power estimation program written in C language and compile the program into a standalone executable, 
which can be further linked with the system-level virtual platform of the underlying multi-core SoC to 
generate the power profile. There are two input files needed for invoking the power estimation program: (1) 
the platform configuration file and (2) each IP’s execution trace. The first file indicates the system 
configuration of the platform, including the number of each type of IPs, and the characteristics of each IP, e.g., 
operating voltage, operating frequency, and memory size. According to the configuration file, the system 
architecture of the platform is then recognized by the power estimation program, which can thus dynamically 
allocate the memory needed for generating the power profile of the platform efficiently. 
 
Power Estimation Program
Generation
Execution
Trace
System‐Level Platform
Of a 
IP Power
Models
Multi‐core SoC
Power 
Estimation 
Program
Platform 
Configuration File Power Profile
of Target Application SW
 
Fig. 41: Power estimation flow of application SW on SoC. 
 
In addition to the configuration file, the execution trace of each IP is also required for the power estimation 
program at the power profiling stage. The execution trace contains the information of some key signals 
needed to identify the operation mode of each IP in the platform. During the simulation process, the whole 
simulation time is divided into a number of segments. At each time segment, the number of operation modes 
of each IP is computed by recognizing the key signals reported in the execution trace. Then the power 
estimation program can accumulate the power consumption of each IP at each time segment and generate the 
37 
 
車用即時作業系統與高效能影像處理軟體設計與開發： 
我們需要研究的是OS 所在的層次。也就是屬於AUTOSAR的Basic software 層。實際上，Basic 
softwar 層還可以做如下圖的細分： 
 
圖 43、AUTOSAR O.S. Layer 
由顏色來區分可以看出有三個不同的區域 
1. 紅色部分是Microcontroller Abstraction Layer簡而言之，本層負責的是內部硬體元件的驅動，能夠
直接存取這一個microcontroller 或是他的匯流排。包括了Microcontroller Drivers 、Memory 
Drivers 、Communication Drivers、 I/O Drivers。 
2. 綠色部分是ECU Abstraction Layer。與紅色部分不同的是，這一層包含著硬體元件的驅動API。除
了驅動內部硬體元件的API、亦能夠進一步的驅動外部的硬體元件；如外插的FLASH、ROM 等等
的元件。包括了Onboard Device Abstraction 、Memory Hardware Abstraction、Communication 
Hardware Abstraction、I/O Hardware Abstraction、Complex Driver。 
3. 紫色部分是Services Layer。要特別注意的是它是真正提供OS 服務的一個子層，包括了System 
Services、Memory Services、Communication Services。 
由上圖可知，對於RTOS 的建置在AUTOSAR 架構上的分析必然要先從Services Layer 著手。更進
一步而言，System Services 這個區塊又是這一個子層需要優先熟悉的規格。以下是此區塊的一個功能
39 
 
量，本研究決定參考並研究由ArcCore AB組織所維護並開發的ARCTIC CORE( 或稱ARC CORE)專案
為基礎做未來的相關RTOS之研究。ARC CORE 不僅有上述之特點，另外，專案開發小組也開發了一
基於Eclipse開發環境的開發工具—ARCTIC STUDIO。這個工具將可以協助軟體的開發者開發出適用於
AUTOSAR標準並且基於ARCCORE OS的車用電子軟體。有這樣的開發工具支援，可想而知對於本研
究有相當大的幫助。不僅提供了核心開發元件，也提供了如上述產生敘述檔軟體或是開發的環境。如
下圖所示，包括了SWC Builder、EXT Builder、BSW Builder、RTE Builder、CORE Builder。由下圖可
知，ARCCORE STUDIO提供了從上層SWC以至於RTE、BSW層的CONFIGURATION功能，此外他也
提供了許多ECU的支援敘述檔。以利軟體開發，最後在以CORE Builder來編譯出目的執行檔。 
 
圖 45、Toolchain Workflow 
ARC CORE 至今已經更新至2.6.0版本，支援PPC以及ARM架構。其中最主要支援的平台描述檔採
用的是FreeScale公司的MPC5516，也是現今車用電子市場經常採用的晶片。經過ARCTIC STUDIO編譯
後所輸出的為ELF檔，能夠利用市面上的虛擬平台軟體來驗證軟體並協助除錯。 
以下為ARTCORE針對於AUTOSAR 3.1標準的ROAD MAP： 
41 
 
 轉載: http://www.cnblogs.com/autosar/archive/2010/03/16/1687567.html 
圖 47、ARC CORE 的原始碼架構 
其中system資料夾，也就是OS kernel實作的部分，也就是本研究的主要對象所屬的區域。更詳細
的組成如下圖所示： 
43 
 
45 
 
Event.c等等檔案之中。 
ARCCORE 系統維護了一份資料結構sys_s簡述如下 
typedef struct sys_s { 
 /* Current running task*/ 
 OsPcbType *curr_pcb; 
 /* List of all tasks */ 
 OsPcbType *pcb_list; 
 
 OsPcbType *chainedPcbPtr; 
 /* Interrupt nested count */ 
 uint32 int_nest_cnt; 
 /* The current operation */ 
 uint8_t op; 
 /* Ptr to the interrupt stack */ 
 void *int_stack; 
 // The os tick 
 TickType tick; 
 // 1-The scheduler is locked (by GetResource() or something else) 
// int scheduler_lock; 
 /* Hooks */ 
 TAILQ_HEAD(,OsPcb) pcb_head; 
 /* Ready queue */ 
 TAILQ_HEAD(,OsPcb) ready_head; 
} 
圖49、struct sys_s 
sys_s 資料結構主要是維護著os當下的變數如tick以及指向現在正在運行的task以及pcb指標，代表
現在的作業系統之狀態，也指向了所有的task的link list開頭節點。此外還指向了ready queue 以及 pcb 
等link list 結構的起始端。 
接下來我們來看看另一個結構： 
我們有可能可以實作出一種定時啟動預先定義的task機制。而這需要使用到OS的counter tick以及一
些自動的alarm。最簡單的方法是預先制定好alarm，而且自啟動開始就不再去更改它。但這種作法相對
的也沒有辦法在runtime期間修改。 如果要能夠想進一步地在runtime期間修改，除非系統能夠保證alarm
 圖51、ScheduleTable 
接著看到schedule table 的狀態變化圖如下： 
 
圖52、狀態圖 
假如schedule table並沒有啟動，那麼他就處於SCHEDULETABLE_STOPPED的狀態 ，啟動之後便
轉換成SCHEDULETABLE_RUNNING的狀態。當要轉換SCHEDULETABLE的時候會先成為
SCHEDULETABLE_NEXT的狀態。 
本研究利用相關的資料結構來剖析ARCTIC CORE 排程的思考方向，更進一步利用與排程相關的
ARCTIC CORE OS API來修改以符合本研究所提出之排程法構想。 
47 
 
系統晶片之功耗建模與分析工具  子計畫三  
功耗與溫度共同模擬平台  子計畫三  
AUTOSAR 之 RTOS 研究  子計畫四  
行人偵測系統  子計畫四  
車輛軟體工程研究  子計畫五  
車用軟體開發指南  子計畫五  
表 5. 完成之軟硬體規格 
 
 
Thermal Analysis
netlist
VCD
DEF
Temperature‐aware 
Power Library
Each Cell’s 
Temperature
Temperature 
Iteration=0?
Yes
No
Converged?
Power Profile
49 
 
 
  圖 53. 計畫關聯圖
Yes
No
LEFInitial 
Temperature
Thermal Profile
Thermal Library
Temperature‐
aware Power 
Estimation
Thermal Analysis
Thermal 
Runaway?
Each Cell’s PowerPowerMixer
No
Yes
Interrupted
51 
 
Using CAN” IEEE TRANSACTIONS ON INDUSTRIAL INFORMATICS, VOL. 3, NO. 2, MAY 2007 
[25]  K. Turski, “A global time system for CAN networks,” in Proc. 1st Int.CAN Conf., 1994, pp. 31–36. 
[26]   I. Broster, “Flexibility in dependable real-time communication,” Ph.D.dissertation, University of York, 
York, U.K., 2003. 
[27]   B. Donnelly and J. Cosgrove, “Achieving microsecond accuracy with32 bit microcontrollers using the 
controller area network (CAN),” inProc. Irish Signals and Systems Conf., Belfast, U.K., Jun./Jul. 
2004,pp. 508–513. 
[28]  I. Broster and A. Burns, “Timely use of the CAN protocol in criticalhard real-time systems with faults,” 
in Proc. 13th Euromicro Conf.Real-Time Systems (ECRTS 2001), Delft, The Netherlands, Jun. 
13–15,2001, pp. 95–102. 
[29]  T. Fuhrer, B.Muller,W. Dieterie, F. Hartwich, R. Hugel, and H.Weiler,Time triggered communication on 
CAN,” in Proc. 7th Int. CAN Conf.,Amsterdam, The Netherlands, Oct. 24th–26th, 2000. 
[30]  M. J. Pont, Patterns for Time Triggered Embedded Systems. Reading,MA: Addison Wesley, 2001. 
[31]  D. Ayavoo, M. J. Pont, M. Short, and S. Parker, “Two novel sharedclockscheduling algorithms for use 
with CAN-based distributed systems,”Microprocess. Microsyst., to be published. 
[32]  J. R. Pimentel and J. A. Fonseca, “FlexCAN: A flexible architecture forhighly dependable embedded 
applications,” in Proc. 3rd Int. WorkshopReal-Time Networks, Catania, Italy, Jul. 2004. 
[33]   G. Buja, A. Zucollo, and J. Pimentel, “Overcoming babbling-idiot failuresin the FlexCAN architecture: 
A simple bus-Guardian,” in Proc.IEEE Int. Workshop Emerging Technologies in Factory 
Automation(ETFA05), Catania, Italy, Sep. 2005. 
[34]   M. Bertoluzzo, G. Buja, and J. Pimentel, “Design of a safety-criticaldrive-by-wire system using 
FlexCAN,” in Proc. SAE World Congr.,Detroit, MI, Apr. 2006, SAE Paper No. 2006-01-1026. 
[35]  ManueleBertoluzzo and Giuseppe Buja, IEEE, Fellow “A high-performance application protocol for 
fault-tolerant CAN networks” International Symposium on Industrial Electronics (ISIE), 2010 IEEE 
[36]  R. B. Atitallah, S. Niar, and J.-L. Dekeyser, “MPSoC Power Estimation Framework at Transaction Level 
Modeling,” Proc. of Int'l Conf. on Microelectronics, pp. 245-248, Dec. 2007. 
[37]  N. Bansal, K. Lahiri, A. Raghunathan, S.T. Chakradhar, “Power Monitors: a Framework for 
System-Level Power Estimation Using Heterogeneous Power Models,” in Proc. of Int. conf. VLSI 
Design, pp. 579-585, 2005. 
[38]  A. Bogliolo, L. Benini, and B. Ricco, “Power Estimation of Cell-Based CMOS Circuits,” in Proc. of 
33rd Design Automation Conf., pp. 433-438, 1996. 
[39]  Sudodh Gupta, Farid N. Najm, “Analytical Models for RTL Power Estimation of Combinational and 
Sequential Circuits,” IEEE Trans. on CAD, vol. 19, pp. 808-814, July 2000. 
[40]  C.-W. Hsu, J.-L. Liao, J.-C. Yeh, J.-J. Chen, S.-Y. Huang, and J.-J. Liou, “Memory-aware Power 
Modeling for PAC DSP Core,” Proc. of Asia Symp. on Quality Electronic Design , pp. 319-324, July 
2009. 
[41]  S.-Y. Huang, K.-T. Cheng, and T.-C. Lee, “A Novel Methodology for Transistor-level Power 
Simulation,” in Proc. of Int’l Symposium on Lower Power Electronic Design, pp. 67-72, 1996. 
53 
 
[65]  J. Blazewicz and G. Finke, ``Minimizing mean weighted execution time loss on identical and 
uniform processors'', Information Processing Letters, Vol. 24, pp. 259-263, March 1987. 
[66]  Liu, Jane W. S., Kwei-Jay Lin, W. K. Shih, A. C. Yu, J.Y. Chung and W. Zhao, “Algorithms for 
Scheduling Imprecise Computations”, Computer magazine, pp. 58-68, May 1991. 
[67]  S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha and F. Wang, “On 
the competitiveness of on-line real-time task scheduling,” Proc. of the 12th Real-Time Systems 
Symposium, San Antonio, Texas, pp. 106-115, December 1991. 
[68]  A. L. Liestman and R. H. Campbell, “A fault-tolerant scheduling problem,” IEEE Transactions on 
Software Engineering, vol. SE-12, No. 10., pp. 1089-1095, Oct. 1986. 
[69]  Shih, Wei-Kuan, Jane W. S. Liu, and Jen-Yao. Chung, “Fast Algorithms for Scheduling Imprecise 
Computations,” SIAM J. on Computing, Vol. 20, No. 3, 1991. 
[70]  C. L. Liu and J. W. Layland, “Scheduling algorithms for multiprogramming in a hard real-time 
environment,” Journal of the ACM, 20(1), pp. 40-61, 1973. 
[71]  Harald Heinecke, el at , AUTOSAR – Current results and preparations for exploitation, 7th 
EUROFORUM conference „Software in the vehicle 3-4 May 2006, Stuttgart, Germany 
[72]  Scharnhorst, Thomas et al.: AUTOSAR – Challenges and Achievements 2005, Electronic Systems 
for Vehicles 2005, VDI Congress, Baden-Baden, 2005 
[73]  D. Kum, G.M. Park, S. Lee, W. Jung, “AUTOSAR Migration from Existing Automotive Software,” 
Proceedings of IEEE International Conference on Control, Automation, and System, pp. 558-562, Oct. 
2008. 
[74]  AUTOSAR consortium: www.autosar.org, 2006. 
[75]  AUTOSAR Development Partnership. www.autosar.com 
[76]  A. Bauer, M. Broy, J. Romberg, B. Schätz, P. Braun, U. Freund, N. Mata, R. Sandner, and D. 
Ziegenbein, “Auto-MoDe—Notations, Methods, and Tools for Model-Based Development of 
Automotive Software,” Proceedings of the SAE 2005 World Congress, Detroit, MI, Apr. 2005.   
[77]  J. Botaschanjan, L. Kof, Ch. Kühnel, and M. Spichkova, “Towards Verified Automotive Software,” 
Proceedings of the 27th International Conference on Software Engineering (ICSE 2005), SEAS 
Workshop, St. Louis, Missouri, USA May 2005. 
[78]  M. Broy, “Automotive Software Engineering,” Proceedings of the 25th International Conference on 
Software Engineering (ICSE 2003), May 2003, Portland, Oregon, USA. 
[79]  M. Broy, A. Pretschner, C. Salzmann, and T. Stauner, “Software Intensive Systems in the 
Automotive Domain: Challenges for Research and Education,” Proceedings of the SAE 2006, Detroit, 
USA, April 2006. 
[80]  M. Broy, “Engineering Automotive Software,” Proceedings of the IEEE, Vol. 95, No. 2, February 
2007. 
[81]  D. Wild, “Concretization and Formalization of Requirements for Automotive Embedded Software 
Systems Development,” Proceedings of the 10th Australian Workshop on Requirements Engineering 
(AWRE), Melbourne, Australia, K. Cox, J.L. Cybulski et.al (ed.), 2005. 
[82]  K. Grimm, “Software Technology in an Automotive Company—Major Challenges,” Proceedings of 
the 25th International Conference on Software Engineering (ICSE 2003), May 2003, Portland, Oregon, 
USA. 
[83]  B. Hardung, T. Kölzow, and A. Krüger, “Reuse of Software in Distributed Embedded Automotive 
55 
 
in Component-Based Software Systems”, Software Quality Journal, Vol. 10, Iss. 2, pp. 115-133, Sep. 
2002. 
[98]  J. M. Voas and K. W. Miller, “Software Testability: The New Verification”, IEEE Software, Vol. 12, 
No. 3, pp. 17-28, 1995. 
[99]  M. Harman, L. Hu, R. Hierons, J. Wegener, H. Sthamer, A. Baresel, and M. Roper, "Testability 
Transformation,” IEEE Transactions on Software Engineering, Vol. 30,  No. 1,  pp. 3-16,  Jan.  2004. 
[100]  J. Gao and M. C. Shih, "A Component Testability Model for Verification and Measurement", 29th 
Annual International Computer Software and Applications Conference (COMPSAC'05), Vol. 2, pp. 
211-218, 2005. 
International Research Cooperation Report 
 
Francois Bodin, Albert Cohen 
Jenq-Kuen Lee 
Feb. 25, 2010 
 
Summary 
 
In this report, we present our international research cooperation results on 
OpenCL research. This joint research project tries to develop a compiler and 
programming environment for heterogeneous multi-processor SoC environments 
under the OpenCL compilation framework. Basically, under the consideration to both 
of static and dynamic adaptive compilation schemes for embedded automotive 
applications. We plan to enhance the programming environment for the target 
heterogeneous multi-processor SoC. The OpenCL framework covers programming 
models defining compiler directives and possible language abstractions to accelerate 
parallel programs. Besides, this plan includes aggressive compiler optimization 
techniques such as partitioning methods for multi-cores, polyhedral transformation for 
GPGPU, probabilistic point-to analysis for locality optimizations and SIMD 
optimizations with OpenCL. As a result, the preliminary of this work has been 
published in the poster session of LCPC 2011 with the title “OpenCL Compiler for 
embedded multicore DSP systems”.  
 
Contact Information 
Francois Bodin            Albert Cohen  
Professor     Professor       
Irisa      INRIA Saclay - Île-de-France 
Campus de Beaulieu  Parc Club Orsay Université, ZAC des vignes, 
35042 Rennes    4 rue Jacques Monod,  91893 Orsay 
France     France 
Email: bodin@irisa.fr  Email: Albert.Cohen@inria.fr 
Tel: +33299847332   Tel: +33/0172925940 
Fax: +33299847171  Fax: +33/0174854229 
Jenq Kuen Lee 
Professor 
Department of Computer Science, National Tsing Hua University 
Hsinchu 300 
Taiwan 
Email: jklee@cs.nthu.edu.tw 
Tel: +886-3-5715131 ext. 33519 
Fax: +886-3-5723694
will be executed in sequence of local ID in a loop on a DSP. When the DSP completes 
the loop execution, all the work-items in the same group are completely executed as 
well. As a result, the barrier synchronizations which cause context switch do not take 
effect after WIC. Third, we also try to exploit DSP SIMD features for OpenCL 
programs. In that, we try to utilize the SIMD intrinsic functions [2]. A vector intrinsic 
mapping phase is employed to scan through the whole kernel program for expressions 
being composed of vector data type whose types are char2, uchar2, char4, uchar4, 
short2, or ushort2,. We will replace the expression with corresponding intrinsic 
functions. In addition, vector data types that are not supported by SIMD intrinsics will 
then be implemented with the structure manner. Fourth, since C language does not 
support OpenCL built-in functions, built-in function overloading has to transform 
such functions to appropriate ones for PAC DSP. Finally, with the preparations above, 
we can perform cluster-aware work-item dispatching (CWD) optimization to convert 
data-level parallelism of OpenCL into instruction-level parallelism of VLIW DSPs for 
multiple register clusters. The CWD starts with identifying work-item dependent 
variables (WDVs). These variables vary from work-item to work-item, and would be 
duplicated to allow the two processing elements (PEs) of the PAC DSP to access them 
simultaneously. The second step of CWD is to increase the kernel loop step in the 
factor of two. Because cluster 0 of PAC DSP is in charge of managing control flow, 
we only dispatch work-items to cluster 1 and cluster 2 of DSP function units. The 
final step of CWD scans the kernel loop body for statements containing WDVs. If a 
statement defines or uses WDVs, CWD duplicates the statement and inserts the new 
statement right after the original statement. Each WDV in the new statement is 
renamed by appending a special suffix to maintain the correctness of dependency. 
Finally, we annotate both statements (the original one and the duplicated one) with 
cluster information to explicitly assign each statement to a specific PE. 
 
 
Figure 1 OpneCL compilation flow for PAC DSP 
 
 
3. Experimental Result 
 
We now introduces our compiler flow. The compiler flow is first with CL-to-C 
compilation flow on Cetus, a compiler infrastructure for the source-to-source 
transformation of software programs [4]. The flow is also with WIC design. We then 
 3
 5
with distributed register files. In: 15th 
3. Workshop on Compilers for Parallel Computing (2010) 
4. 3. Lee, J., Kim, J., Seo, S., Kim, S., Park, J., Kim, H., Dao, T.T., Cho, Y., 
Seo, S.J., Lee, S.H., Cho, S.M., Song, H.J., 
5. Suh, S.B., Choi, J.D.: An OpenCL framework for heterogeneous multicores 
with local memory. In: Proceedings of the 
6. 19th international conference on Parallel architectures and compilation 
techniques. pp. 193–204. PACT ’10, ACM, New 
7. York, NY, USA (2010) 
8. 4. ik Lee, S., Johnson, T.A., Eigenmann, R.: Cetus - an extensible compiler 
infrastructure for source-to-source transformation. 
9. In: Languages and Compilers for Parallel Computing, 16th Intl. Workshop, 
College Station, TX, USA, Revised 
10. Papers, volume 2958 of LNCS. pp. 539–553 (2003) 
11. 5. Lin, Y.C., Tang, C.L., Wu, C.J., Hung, M.Y., You, Y.P., Moo, Y.C., 
Chen, S.Y., Lee, J.K.: Compiler supports and 
12. optimizations for PAC VLIW DSP processors. In: Proceedings of the 18th 
International Workshop on Languages and 
13. Compilers for Parallel Computing (2005) 
99 年度專題研究計畫研究成果彙整表 
計畫主持人：李政崑 計畫編號：99-2220-E-007-017- 
計畫名稱：先進車用電子系統軟體開發平台--總計畫(I) 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 3 0 100%  
研究報告/技術報告 4 0 100%  
研討會論文 12 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100% 無 專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件 無 
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 12 0 100%  
博士生 15 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 2 0 100% 
人次 
 
