II
目錄
一、中文摘要及關鍵詞 .................................. iii
二、英文摘要及關鍵詞 ................................... iv
三、報告內容 ............................................ 1
1. 前言 .............................................. 1
2. 研究目的 .......................................... 2
3. 文獻探討 .......................................... 2
4. 研究方法 .......................................... 5
5. 結果與討論 ........................................ 6
四、參考文獻 ............................................ 9
五、計畫成果自評 ....................................... 11
六、附錄 ............................................... 13
附錄一 ............................................. 14
附錄二 ............................................. 21
附錄三 ............................................. 26
IV
二、英文摘要及關鍵詞
Permutation codes, or permutation arrays (PAs) have been studied from the 1970s, and
they are applied to various applications, such as trellis code modulations, power line
communications, etc. Among all the applications, power line communication is one of the
most interesting to many researchers, since transmitting signals in power lines will save
the cost for building up many data lines. However, the development of permutation codes
is relatively very slow to the development of binary codes. Since the structures of
permutation codes are very different to those of binary codes, many theoretical results
of binary codes could not directly be applied to permutation codes.
We know that codeword length, size, and minimum codeword distance (minimum distance)
are three most important measures for a code. Especially, the minimum distance is closely
related to the capabilities of error detection and error correction. Since 2000, research
about distance preserving mappings (DPMs) or distance increasing mappings (DIMs) has
become more popular and some nice results have been discovered. By applying distance
preserving mappings or distance increasing mappings, any binary code can be easily
transformed into a permutation code with the same length and size, and all codeword
distances are preserved or even increased such that the minimum distance of the code is
also preserved or even increased. These research results make many theoretical results
of binary codes can be applied to permutation codes and thus improve many lower bounds
of permutation code construction. Though some of these results are given from us, we know
that the optimal limits or bounds of many problems about permutation codes, distance
preserving or increasing mappings are still undiscovered.
In this project, our research has focused on the following subjects. (1) To design
algorithms of distance preserving mappings and distance increasing mappings. (2) To study
the bounds on the optimum (maximum) of minimum distance increasing in distance increasing
mappings. (3) To find generalized distance preserving mappings or distance increasing
mappings from q-ary codes to permutation codes for q > 2 in order to further improve lower
bounds of permutation code construction. (4) To find efficient encoding and decoding
algorithms for the permutation codes that we constructed. According to the schedule of
the project, we have some results for each of the above subjects now.
Key word: permutation arrays, distance preserving mappings, distance increasing mappings,
decoding algorithms, binary codes
2[LEE04], [LEE05], [LEE06], [LIN06], [SWA05], [SWA06]已經確實可以將許多二進位編碼的理
論移植到排列編碼來，也因此改善了排列編碼建構理論的許多已知的下限(Lower Bounds)。雖然
這些成果中有一部分些是由我們發表的，但是我們也知道許多有關排列編碼、保距對應、增距對
應問題的真正最好的極限值(Bounds, or Limits)尚未被發掘。
此外，運用保距對應或增距對應建構出來的更好的排列編碼，一定也要有良好的編碼演算法與
解碼演算法才能實際使用。雖然排列編碼的編碼演算法(Permutation Code Encoding Algorithms)
可以借用原來二進位編碼的編碼演算法來與保距或增距對應的演算法合成，但若我們在固定編碼
長度(Length)與最小碼距(Minimum Distance)之前提下，繼續增加編碼的大小(Size)，則排列編
碼演算法就必須重新設計。至於這些新建構的排列編碼的解碼演算法(Permutation Code Decoding
Algorithms)，因為無法借用二進位編碼的解碼演算法，所以需要重新設計，這也是一項重要的研
究課題。
2.研究目的
在本計畫中，我們的研究項目包括：
1. 保距對應(DPMs)或增距對應(DIMs)演算法(Algorithms)的設計。
2. 增距對應(DIMs)中最小碼距的最佳(最大)增距量的極限(Bounds)研究。
3. 研究對於任何 q > 2 能夠將基於 GF(q)的編碼(q-ary Codes)轉換成排列編碼的保距對應或
增距對應，以便讓更多已知的編碼理論能夠移植到排列編碼來，更進一步改善排列編碼建
構理論的下限。
4. 排列編碼的編碼演算法(Encoding Algorithms)與解碼演算法(Decoding Algorithms)的設
計。
3.文獻探討、
在我們所搜尋到的參考文獻中，我們對每一篇論文逐一研讀，團隊討論，針對其研究成果
的優點與不足之處詳加分析，得到許多寶貴的結果。其中一些重點摘要評述如下。
[DEZ78] M. Deza and S. A. Vanstone, “Bounds on permutation arrays,” J. Statist.
Planning and Inference, vol. 2, pp. 179-209, 1978.
本論文提出了一些排列編碼建構理論的上限(Upper Bounds)與下限(Lower Bounds)。
4的 GF(q)上的傳統編碼與一個已知一樣長度的排列編碼合併，來產生一個編碼長度、
大小、最小碼距都比原來大的排列編碼。這些建構也得到了新的排列編碼下限。
[LEE04] K. Lee, “New distance-preserving maps of odd length,” IEEE Trans. Inform.
Theory, vol. 50, no. 10, pp. 2539-2543, Oct. 2004.
本論文提出一種新的保距對應的演算法，但是只能用在編碼長度為奇數時。
[CHA05] J. C. Chang, “Distance increasing mappings from binary vectors to
permutations,” IEEE Trans. Inform. Theory, vol. 51, no. 1, pp. 359-363, Jan.
2005.
本論文證明只要長度不低於 4，一定存在增距對應，而且可以有系統的用演算法描述
這些增距對應。這些增距對應保證經過對應後，碼距(Codeword Distance)一定會增
加至少 1，除非原來的碼距已經到達上限(Upper Bound)，也就是等於編碼的程度。這
樣的結果建立了新的排列編碼的下限(Lower Bound)。
[SWA05] T. G. Swart, I. De Beer, H. C. Ferreira, “On the distance optimality of
permutation mappings,” Proc. IEEE Int. Symp. Information Theory, Adelaide,
Australia, pp. 1068-1072, Sep. 2005.
本論文研究從二進位向量對應到排列的增距對應其增距的極限。除了數學分析外，也
運用程式模擬來預測，結論是現有的保距或增距對應距離最佳的增距對應仍有一段距
離，不過作者也建議與其花太多時間去搜尋最佳增距對應，不如使用現有的增距對應
演算法。
[LEE06] K. Lee, “Distance-increasing maps of all length by simple mapping
algorithms,” IEEE Trans. Inform. Theory, vol. 52, no. 7, pp. 3344-3348, Jul.
2006.
本論文提出了所有長度不低於 4 的新的增距對應，其增距對應演算法比[CHA05]更簡
單更有效率。
[CHA06] J. C. Chang, “Distance increasing mappings from binary vectors to
permutations that increase Hamming distances by at least two,” IEEE Trans.
Inform. Theory, vol. 52, no. 4, pp. 1683-1689, Apr. 2006.
以前保距對應只保證最小碼距會保持住不會減少，而增距對應則保證最小碼距一定會
增加，意即至少會增加 1，除非最小碼距已經達到編碼的長度。本論文中提出了 k增
距對應（k-Distance-Increasing Mappings），是更新的突破。對於任意不小於 2的 k
值，k增距對應可以把長度為 n的二進位編碼轉換成長度為 n的排列編碼，且保證最
小碼距至少會增加 k或已經達到極限 n。同時，本論文也證明對任意不小於 2的 k值，
一定存在一個最小的正整數 nk，使得對於所有不小於 nk的正整數 n，皆可以建構出一
個 長度為 n 的 k 增距對應。這種 k 增距對應可以改進一些排列編碼建構的已知下限
（Lower Bounds）。此外，對於任意 k值的對應 nk的值，論文也證明了一個上限（Upper
Bound），只是精確的 nk值還不知道。
62.3. 研究方法
2.3.1. 撰寫相關搜尋程式、驗證程式。
2.3.2. 蒐集並研讀相關書籍、論文資料。
2.3.3. 定期輪流簡報研究結果並互相討論。
2.3.4. 演算法或相關編碼理論之推導與證明。
2.4. 研究方法說明
在尋找適用於從 GF(q)上的編碼對應到排列編碼的保距或增距對應時，由於計算複雜度迅速提
高，所以搜尋程式可能幫不上忙。但驗證程式仍可協助驗證人工設計出來的演算法有沒有漏
洞，當然最後 GF(q)上的增距演算法正確性還是需要數學理論來證明。過程中，若增距對應很
難找到，也可以放寬長度的限制，讓 GF(q)上長度為 n的向量可以對應到長度比 n大一個固定
值的排列序列。這樣的增距對應雖然不是最理想的情況，但對於目前排列編碼的下限還是會
有改善。
第三年：
3.1. 研究目標
3.1.1. 設計排列編碼的解碼演算法。
3.1.2. 盡可能增加 Codewords 擴充排列編碼的 Size，再設計編碼演算法。
3.2. 參與人力
3.2.1. 計畫主持人 1名、博士生 1名、碩士生 3名。
3.3. 研究方法
3.3.1. 撰寫相關搜尋程式、驗證程式。
3.3.2. 蒐集並研讀相關書籍、論文資料。
3.3.3. 定期輪流簡報研究結果並互相討論。
3.3.4. 演算法或相關編碼理論之推導與證明。
3.4. 研究方法說明
排列編碼也要有良好的編碼演算法與解碼演算法才能實際使用。設計編碼演算法與解碼演算
法時，可以嘗試使用遞迴(Recursive)與非遞迴(Nonrecursive)版本。可以運用的程式技巧包
括 Devide-and-Conquer, Dynamic Programming, Greedy method 等都可以嘗試。最後的演算
法必須實際寫成程式，對於不太大的編碼長度，程式必須經過所有可能輸入的檢驗，才能確
定其正確性。
5. 結果與討論
在本計畫中，我們的研究項目包括：
1.保距對應(DPMs)或增距對應(DIMs)演算法(Algorithms)的設計。
2.增距對應(DIMs)中最小碼距的最佳(最大)增距量的極限(Bounds)研究。
3.研究對於任何 q > 2 能夠將基於 GF(q)的編碼(q-ary Codes)轉換成排列編碼的保距對應或
增距對應，以便讓更多已知的編碼理論能夠移植到排列編碼來，更進一步改善排列編碼建
構理論的下限。
4.排列編碼的編碼演算法(Encoding Algorithms)與解碼演算法(Decoding Algorithms)的設
8IGI Global, December 2009.
已發表之技術報告
[8] J.-S. Lin, Jen-Chun Chang, R.-J. Chen, T. Klove, "Distance-preserving mappings from
ternary vectors to permutations," arXiv: 0704.1358v1 [cs.DM], Dec 13, 2007.
在我們的研究成果中，最主要的結果是前面所列第[1],[2],[3]項。這三項的論文內容將放在
附錄中。在此簡單敘述這些成果的摘要。
[1] Jyh-Shyan Lin, Jen-Chun Chang, Rong-Jaye Chen, Torleiv Klove, "Distance-preserving
and distance-increasing mappings from ternary vectors to permutations," IEEE
Transactions on Information Theory, Vol. 54, March 2008, pp. 1334-1339.
排列編碼(permutation codes)在電力線傳輸(powerline communication)上有重要的應用。而
運用 DPM(distance preserving mappings)或 DIM(distance increasing mappings)可以將好的傳
統的二進位編碼轉變為排列編碼。保距對應(distance preserving mappings)是一種從長度為 m
的 p 進位向量對應到長度為 n 的 q 進位向量的一對一函數，使得原來任意兩個相異向量之間的距
離(Hamming distance)經過對應之後都能夠保持(preserving)或增加。而增距對應(distance
increasing mappings)是一種特殊的保距對應(distance preserving mappings)，它使得原來任
意兩個相異向量之間的距離(Hamming distance)經過對應之後都能夠增加(increasing)，除非距
離已經達到最大值 n。
在這篇論文中，我們提出了一些遞迴(recursive)演算法，這些演算法可以建構出 DPM(distance
preserving mappings)或 DIM(distance increasing mappings)，將三進位向量對應到排列。這些
結果改善了一些關於排列編碼的已知下限(lower bounds)，使得一些排列編碼的已知最大 size 又
增加了。
[2] Jen-Chun Chang, Hsin-Lung Wu, "A simple construction of distance-increasing
mappings from ternary vectors to permutations," submitted to IEEE Transactions on
Information Theory.
從三進位向量 (ternary vectors) 對應到排列 (permutations) 的增距對應 (distance
increasing mappings)的明顯建構(explicit, non-recursive, constructions)過去並沒有被發
現。我們提出了一種簡單而直接的建構演算法，這種新的發現與我們以前發表的結果結合，可以
產生增加距離的增距對應，甚至可以找出將距離增加 2 以上的增距對應。這些結果提供了對於建
構排列編碼(permutation codes)的更好的下限。說得更精確一點，對於任意的 k，只要長度 n夠
大，我們都可以找到距離增加至少為 k的增距對應。
[3] Jen-Chun Chang, Hsin-Lung Wu, "Constructing Constant Composition Codes via
10
arrays,” IEEE Trans. Inform. Theory, vol. 48, pp. 977-980, Apr. 2002.
[FER00] H. C. Ferreira and A. J. H. Vinck, “Inference cancellation with permutation
trellis arrays,” Proc. IEEE Vehicular Technology Conf., pp. 2401-2407, 2000.
[FRA77] P. Frankel and M. Deza, “On the maximum number of permutations with given
maximal and minimal distance,” J. Comb. Theory, Ser A, vol. 22, pp. 352-360,
1977.
[FU04] F. W. Fu and T. Klove, “Two constructions of permutation arrays,” IEEE Trans.
Inform. Theory, vol. 50, pp. 881-883, May 2004.
[HUA06] Y. Y. Huang, S. C. Tsai, H. L. Wu, “On the construction of permutation arrays
via mappings from binary vectors to permutations,” Designs, Codes and
Cryptography, vol. 39, pp. 139-155, 2006.
[KLO00] T. Klove, “Classification of permutation codes of length 6 and minimum
distance 5,” Proc. Int. Symp. Information Theory and Its Applications, pp.
465-468, 2000.
[LEE04] K. Lee, “New distance-preserving maps of odd length,” IEEE Trans. Inform.
Theory, vol. 50, no. 10, pp. 2539-2543, Oct. 2004.
[LEE05] K. Lee, “Cyclic constructions of distance-preserving maps,” IEEE Trans.
Inform. Theory, vol. 51, no. 12, pp. 4292-4396, Dec. 2005.
[LEE06] K. Lee, “Distance-increasing maps of all length by simple mapping
algorithms,” IEEE Trans. Inform. Theory, vol. 52, no. 7, pp. 3344-3348, Jul.
2006.
[LIN06] J. S. Lin, J. C. Chang, R. J. Chen, “New simple constructions of
distance-increasing mappings from binary vectors to permutations,”
Information Processing Letters, vol. 100, no. 2, pp. 83-89, Oct. 2006.
[MAT02] R. Mathon and A. P. Street, “Overlarge sets of 2 (11, 5, 2) designs and related
configurations,” Discr. Math., vol. 255, pp. 275-286, 2002.
[PLE98] V. S. Pless and W. C. Huffman, Eds., Handbook of Coding Theory, Amsterdam,
The Netherlands: Elsevier, 1998.
[SWA05] T. G. Swart, I. De Beer, H. C. Ferreira, “On the distance optimality of
permutation mappings,” Proc. IEEE Int. Symp. Information Theory, Adelaide,
Australia, pp. 1068-1072, Sep. 2005.
[SWA06] T. G. Swart, and H. C. Ferreira, “A multilevel construction for mappings from
binary sequences to permutation sequences,” Proc. IEEE Int. Symp.
Information Theory, Seattle, USA, pp. 1895-1899, July 2006.
[TAR99] H. Tarnanen, “Upper bounds on permutation codes via linear programming,”
Europ. J. Combin., vol. 20, pp. 101-114, 1999.
[VIN00] A. J. H. Vinck, “Coded modulation for power line communications,” AEU Int.
J. Electron. Commun., vol. 54, no. 1, pp. 45-49, 2000.
[VIN00a] A. J. H. Vinck and J. Haring, “Coding and modulation for power-line
communications,” Proc. Int. Symp. Power Line Communication, Limerick,
Ireland, Apr. 5-7, 2000.
12
國科會補助專題研究計畫成果報告自評表
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估
■ 達成目標
□ 未達成目標（請說明，以 100 字為限）
□ 實驗失敗
□ 因故實驗中斷
□ 其他原因
說明：
2. 研究成果在學術期刊發表或申請專利等情形：
論文：■已發表 ■未發表之文稿 ■撰寫中 □無
專利：□已獲得 □申請中 □無
技轉：□已技轉 □洽談中 □無
其他：（以 100 字為限）
14
附 錄 一 ： Jyh-Shyan Lin, Jen-Chun Chang, Rong-Jaye Chen, Torleiv Klove,
"Distance-preserving and distance-increasing mappings from ternary vectors to
permutations," IEEE Transactions on Information Theory, Vol. 54, March 2008, pp.
1334-1339.
For N > n, let In,N be the set of functions in Fn,N such
that
dH(f(x), f(y)) > dH(x,y) (1)
for all distinct x,y ∈ Zn3 . These mappings are called distance-
increasing mappings (DIM).
An (N,D) permutation array (PA) is a subset of SN
such that the Hamming distance between any two distinct
permutations in the array is at least D. An (n, d; q) code is a
subset of vectors (codewords) of length n over an alphabet of
size q and with distance at least d between distinct codewords.
One construction method of PAs is to construct an (N,D)-PA
from an (n, d; q) code using DPMs or DIMs. More precisely,
if C is an (n, d; q) code and there exists a DPM f from Znq
to SN , then f(C) is an (N, d)-PA. If f is a DIM, then f(C)
is an (N, d + 1)-PA. This has been a main motivation for
studying DPMs. Let P (N,D) denote the largest possible size
of an (N,D)-PA. The exact value of P (N,D) is still an open
problem in most cases, but we can lower bound this value by
the maximal size of a suitable code provided a DPM (or DIM)
is known. Let Aq(n, d) denote the largest possible size of an
(n, d) code over a code alphabet of size q. In [5], Chang et al.
used this approach to show that for N ≥ 4 and 2 ≤ D ≤ N ,
we have P (N,D) ≥ A2(N,D − 1). In [4], Chang further
improved the bound to P (N,D) ≥ A2(N,D − δ) for any δ
such that 3 ≤ δ + 1 ≤ D ≤ N and any N ≥ Nδ, where Nδ
is a positive integer determined by δ, e.g. N2 = 16.
Our main result is the following theorem.
Theorem 1: a) For N ≥ 5 and 2 ≤ D ≤ N , we have
P (N,D) ≥ A3(N − 2, D − 1).
b) For N ≥ 10 and 2 ≤ D ≤ N , we have
P (N,D) ≥ A3(N − 1, D).
c) For N ≥ 13 and 2 ≤ D ≤ N , we have
P (N,D) ≥ A3(N,D).
Bounds on A2(n, d) and A3(n, d) have been studied by
many researchers, see e.g. [16, Ch.5] and [1]. In gen-
eral, the lower bounds on P (N,D) obtained from use
of ternary codes are better than those obtained from bi-
nary codes. For example, using Chang’s bound [4], we get
P (16, 5) ≥ A2(16, 3) ≥ 2720, whereas Theorem 1 gives
P (16, 5) ≥ A3(16, 5) ≥ 19683. Similarly, Chang’s bound
gives P (16, 9) ≥ A2(16, 7) ≥ 36 whereas the new bound
gives P (16, 9) ≥ A3(16, 9) ≥ 243.
The proof of the theorem is done by explicit construction of
DPMs and DIMs. More precisely, we give constructions that
show the following lemma which in turn implies the theorem.
Lemma 1: a) In,n+2 is non-empty for n ≥ 3.
b) Pn,n+1 is non-empty for n ≥ 9.
c) Pn,n is non-empty for n ≥ 13.
A relatively simple recursive method is given (in the next
section) to construct a mapping of length n+1 from a mapping
of length n. Explicit mappings that start the recursion in the
three cases are given in last part of the paper.
III. THE GENERAL RECURSIVE CONSTRUCTION
For any array u = (u1, u2, . . . , un), we use the notation ui
to denote the element ui in position i.
We start with a recursive definition of functions from Zn3 to
SN . For f ∈ Fn,N , define g = H(f) ∈ Fn+1,N+1 as follows.
Let
x = (x1, x2, . . . , xn) ∈ Z
n
3 and f(x) = (ϕ1, ϕ2, . . . , ϕN ).
Suppose that the element N − 4 occurs in position r, that is
ϕr = N − 4. Then
g(x|0)i =
{
N + 1 for i = N + 1
ϕi, for i 6= N + 1
g(x|1)i =


N − 4 for i = N + 1
N + 1 for i = r
ϕi, for i 6∈ {r,N + 1}
If n is even and xn = 2, then
g(x|2)i =


N + 1 for i = N − 1
ϕN−1 for i = N + 1
ϕi, for i 6∈ {N − 1, N + 1}
otherwise (n is odd or xn < 2), then
g(x|2)i =


N + 1 for i = N
ϕN for i = N + 1
ϕi, for i 6∈ {N,N + 1}
We note that g(x|a)i 6= f(x)i for at most one value of
i ≤ N .
For f ∈ Fm,M , we define a sequence of functions fn ∈
Fn,n+M−m, for all n ≥ m, recursively by
fm = f and fn+1 = H(fn) for n ≥ m.
Lemma 2: If fm ∈ Pm,M where M ≥ m, m is odd, and
fm(x)M 6∈ {M − 4,M − 3} for all x ∈ Zm3 ,
then fn ∈ Pn,n+M−m for all n ≥ m.
Lemma 3: If fm ∈ Im,M , where M > m and m is odd,
and
fm(x)M 6∈ {M − 4,M − 3} for all x ∈ Zm3 ,
then fn ∈ In,n+M−m for all n ≥ m.
Proof: We prove Lemma 3; the proof of Lemma 2 is similar
(and a little simpler). The proof is by induction. First we prove
that g = fm+1 ∈ Im+1,M+1. Let x,y ∈ Zm3 and
f(x) = (ϕ1, ϕ2, . . . , ϕM ), ϕr = M − 4,
f(y) = (γ1, γ2, . . . , γM ), γs = M − 4.
We want to show that
dH(g(x|a), g(y|b)) > dH((x|a), (y|b))
if (x|a) 6= (y|b).
First, consider x = y and a 6= b. Since ϕM 6= M − 4, it
follows immediately from the definition of g that
dH(g(x|a), g(x|b)) ≥ 2 > 1 = dH((x|a), (x|b)).
IV. CONSTRUCTION OF A MAPPING IN Pn,n+1 FOR n ≥ 9
To prove Lemma 1 b), using Lemma 2, we need some f ∈
P9,10 such that
f(x)10 6∈ {6, 7} for all x ∈ Z93 . (6)
An extensive computer search has been unsuccessful in com-
ing up with such a mapping. However, an indirect approach
has been successful. The approach is to construct f from two
simpler mappings found by computer search. We describe this
construction.
For a vector ρ = (ρ1, ρ2, . . . , ρn) and a set
X ⊂ {1, 2, . . . , n},
let ρ\X denote the vector obtained from ρ by removing the
elements with subscript in X . For example,
(ρ1, ρ2, ρ3, ρ4, ρ5, ρ6)\{1,5} = (ρ2, ρ3, ρ4, ρ6).
By computer search we have found mappings G ∈ F5,7 and
H ∈ F4,6 that satisfy the following conditions
a) for every x ∈ Z53 , 6 ∈ {G(x)1, G(x)2, G(x)3},
b) for every x ∈ Z53 , 7 ∈ {G(x)4, G(x)5, G(x)6},
c) for every distinct x,y ∈ Z53 ,
dH(G(x)\{7}, G(y)\{7}) ≥ dH(x,y),
d) for every u ∈ Z43 , 1 ∈ {H(u)1, H(u)2, H(u)3},
e) for every distinct u,v ∈ Z43 ,
dH(H(u)\{5,6}, H(v)\{5,6}) ≥ dH(u,v).
Explicit listing of the mappings G and H have been omitted
for space reasons (page limitation on correspondences), but it
has been included in an early version of the manuscript stored
in arXiv, [14]. We will now show how these mappings can be
combined to produce a mapping f ∈ P9,10 satisfying (6).
Let x ∈ Z93 . Then x = (xL,xR), where xL ∈ Z53 and
xR ∈ Z
4
3 . Let
(ϕ1, ϕ2, ϕ3, ϕ4, ϕ5, ϕ6, ϕ7) = G(xL),
(γ1, γ2, γ3, γ4, γ5, γ6) = H(xR) + (4, 4, 4, 4, 4, 4).
We note that Condition d) implies that γ5 ≥ 6 and γ6 ≥ 6.
Similarly, Conditions a) and b) imply that ϕ7 ≤ 5.
Define ρ = (ρ1, ρ2, . . . , ρ10) as follows.
ρi = γ5 if 1 ≤ i ≤ 3 and ϕi = 6,
ρi = γ6 if 4 ≤ i ≤ 6 and ϕi = 7,
ρi = ϕi if 1 ≤ i ≤ 6 and ϕi ≤ 5,
ρi = ϕ7 if 7 ≤ i ≤ 9 and γi−6 = 5,
ρi = γi−6 if 7 ≤ i ≤ 10 and γi−6 ≥ 6.
In ρ, swap 1 and 6 and also swap 2 and 7, and let the
resulting array be denoted by pi. More formally,
pii = 1 if ρi = 6,
pii = 2 if ρi = 7,
pii = 6 if ρi = 1,
pii = 7 if ρi = 2,
pii = ρi otherwise.
Then define
f(x) = pi.
We will show that f has the stated properties. We first show
that pi ∈ S10. We have ϕ ∈ S7 and γ is a permutation of
(5, 6, 7, 8, 9, 10). In particular, 5, 6, and 7 appear both in ϕ
and γ. The effect of the first line in the definition of ρ is
to move another element (γ5) into the position where ϕ has
a 6. Similarly, the second line overwrites the 7 in ρ, and the
fourth line overwrites the 5 in γ. The definition of ρ is then the
concatenation of the six first (overwritten) elements of ϕ and
the five first (overwritten) elements of γ. Therefore, ρ contains
no duplicate elements, that is, ρ ∈ S10.
The element 1 in ρ must be either in one of the first six
positions, coming from ϕ, or in one of the positions 7− 9 (if
ϕ7 = 1). Similarly, the element 2 must be in one of the first
nine positions of ρ. Therefore, both 6 and 7 must be among
the first nine elements of pi, that is pi10 6∈ {6, 7}.
Finally, we must show that f is distance-preserving. Let
x 6= x′, and let the arrays corresponding to x′ be denoted by
ϕ′, γ′, ρ′ and pi′. By assumption,
dH(x,x
′) = dH(xL,x
′
L) + dH(xR,x
′
R)
≤ dH(ϕ\{7}, ϕ
′
\{7}) + dH(γ\{5,6}, γ
′
\{5,6}).(7)
For 1 ≤ i ≤ 6 we have
dH(ϕi, ϕ
′
i) ≤ dH(ρi, ρ
′
i). (8)
If ϕi = ϕ′i this is obvious. Otherwise, we may assume without
loss of generality that ϕ′i < ϕi and we must show that ρi 6= ρ′i.
If ϕi ≤ 5, then
ρ′i = ϕ
′
i < ϕi = ρi.
If ϕi = 6, then
ρ′i = ϕ
′
i ≤ 5 and ρi = γ5 ≥ 6.
If ϕi = 7, then 4 ≤ i ≤ 6 and so ϕ′i 6= 6. Hence
ρ′i = ϕ
′
i ≤ 5 and ρi = γ6 ≥ 6.
This completes that proof of (8). A similar arguments show
that for 7 ≤ i ≤ 10 we have
dH(γi−6, γ
′
i−6) ≤ dH(ρi, ρ
′
i), (9)
and that for 1 ≤ i ≤ 10 we have
dH(ρi, ρ
′
i) ≤ dH(pii, pi
′
i). (10)
Combining (7)–(10), we get
dH(x,x
′) ≤ dH(ϕ\{7}, ϕ
′
\{7}) + dH(γ\{5,6}, γ
′
\{5,6})
≤ dH(ρ, ρ
′) ≤ dH(pi, pi
′).
Hence, f is distance-preserving.
V. CONSTRUCTION OF A MAPPING IN Pn,n FOR n ≥ 13
The construction of a mapping f ∈ P13,13 which proves
Lemma 1 c) is similar to the construction in the previous sec-
tion. However, the construction is more involved and contains
several steps. We will describe the constructions and properties
of the intermediate mappings. The details of proofs are similar
to the proof in the previous section and we omit these details.
We start with three mappings R,S ∈ F3,5 and T ∈ F4,6.
These were found by computer search and are listed explicitly
Define ρ = (ρ1, ρ2, . . . , ρ9) as follows.
ρi = γ6 if 1 ≤ i ≤ 4 and ϕi = 5,
ρi = ϕi if 1 ≤ i ≤ 4 and ϕi 6= 5,
ρi = ϕ5 if 5 ≤ i ≤ 9 and γi−4 = 4,
ρi = γi−4 if 5 ≤ i ≤ 9 and γi−4 6= 4.
In ρ, swap 2 and 5, and let the resulting array be V (x). It
has the following properties:
• for every x ∈ Z73 , 1 ∈ {V (x)1, V (x)2, V (x)3},
• for every x ∈ Z73 , 2 ∈ {V (x)5, V (x)6, V (x)7},
• for every distinct x,y ∈ Z73 ,
dH(V (x)\{4,9}, V (y)\{4,9}) ≥ dH(x,y).
Construction of f ∈ P13,13
Let x ∈ Z133 and let
(ϕ1, ϕ2, . . . , ϕ8) = U(x1, x2, . . . , x6),
(γ1, γ2, . . . , γ9) = V (x7, x8, . . . , x13) + (4, 4, . . . , 4).
Define ρ = (ρ1, ρ2, . . . , ρ13) as follows.
ρi = γ4 if 1 ≤ i ≤ 3 and ϕi = 7,
ρi = ϕi if 1 ≤ i ≤ 3 and ϕi 6= 7,
ρi = γ9 if 4 ≤ i ≤ 6 and ϕi+1 = 8,
ρi = ϕi+1 if 4 ≤ i ≤ 6 and ϕi+1 6= 8,
ρi = ϕ4 if 7 ≤ i ≤ 9 and γi−6 = 5,
ρi = γi−6 if 7 ≤ i ≤ 9 and γi−6 6= 5,
ρi = ϕ8 if 10 ≤ i ≤ 13 and γi−5 = 6,
ρi = γi−5 if 10 ≤ i ≤ 13 and γi−5 6= 6.
In ρ, swap 1 and 9 and also swap 2 and 10, and let the
resulting array be f(x). Then
f ∈ P13,13 and f(x)13 6∈ {9, 10}.
VI. CONCLUSIONS
We have given a recursive construction method for DPMs
and DIMs from ternary vectors. In three cases we have found
DPMs that can be used to start off the recursion, in one of
the cases the DPMs are DIMs. Hence, in one case we get
an infinite class of DIMs and in the other two cases we
get infinite classes of DPM. The most important result is
the construction of DPM from ternary vectors of lengths at
least 13 to permutations of the same length. Using the DPMs
(or the DIMs) and known ternary codes, we get new larger
permutation arrays in many cases; a couple of examples are
gives as illustrations.
REFERENCES
[1] A.E. Brouwer, H.O. Ha¨ma¨la¨inen, P.R.J. ¨Osterga˚rd, N.J.A. Sloane,
“Bounds on mixed binary/ternary codes”, IEEE Trans. on Inform.
Theory, vol. 44, no. 1, pp. 140–161, Jan. 1998.
[2] J.-C. Chang, “Distance-increasing mappings from binary vectors to
permutations”, IEEE Trans. on Inform. Theory, vol. 51, no. 1, pp. 359–
363, Jan. 2005.
[3] J.-C. Chang, “New algorithms of distance-increasing mappings from
binary vectors to permutations by swaps”, Designs, Codes and Cryp-
tography, vol. 39, pp. 335–345, Jan. 2006.
[4] J.-C. Chang, “Distance-increasing mappings from binary vectors to
permutations that increase Hamming distances by at least two”, IEEE
Trans. on Inform. Theory, vol. 52, no. 4, pp. 1683–1689, April 2006.
[5] J.-C. Chang, R.-J. Chen, T. Kløve, and S.-C. Tsai, “Distance-preserving
mappings from binary vectors to permutations”, IEEE Trans. on Inform.
Theory, vol. 49, pp. 1054–1059, Apr. 2003.
[6] H. C. Ferreira and A. J. H. Vinck, “Inference cancellation with per-
mutation trellis arrays”, Proc. IEEE Vehicular Technology Conf., pp.
2401–2407, 2000.
[7] H. C. Ferreira, A. J. H. Vinck, T. G. Swart, and I. de Beer, “Permutation
trellis codes”, IEEE Trans. on Communications, vol. 53, no. 11, pp.
1782–1789, Nov. 2005.
[8] H. C. Ferreira, D. Wright, and A. L. Nel, “Hamming distance-preserving
mappings and trellis codes with constrained binary symbols”, IEEE
Trans. on Inform. Theory, vol. 35, no. 5, pp. 1098–1103, Sept. 1989.
[9] Y.-Y. Huang, S.-C. Tsai, H.-L. Wu, “On the construction of permutation
arrays via mappings from binary vectors to permutations”, Designs,
Codes and Cryptography, vol. 40, pp. 139–155, 2006.
[10] K. Lee, “New distance-preserving maps of odd length”, IEEE Trans. on
Inform. Theory, vol. 50, no. 10, pp. 2539–2543, Oct. 2004.
[11] K. Lee, “Cyclic constructions of distance-preserving maps”, IEEE Trans.
on Inform. Theory, vol. 51, no. 12, pp. 4292–4396, Dec. 2005.
[12] K. Lee, “Distance-increasing maps of all length by simple mapping
algorithms”, IEEE Trans. on Inform. Theory, vol. 52, no. 7, pp. 3344-
3348, July 2006.
[13] J.-S. Lin, J.-C. Chang, and R.-J. Chen, “New simple constructions
of distance-increasing mappings from binary vectors to permutations”,
Information Processing Letters, vol. 100, no. 2, pp. 83–89, Oct. 2006.
[14] J.-S. Lin, J.-C. Chang, R.-J. Chen, T. Kløve, “Distance-preserving
mappings from ternary vectors to permutations”, arXiv: 0704.1358v1
[cs.DM]
[15] T.-T. Lin, S.-C. Tsai, H.-L. Wu, “Distance-preserving mappings from
ternary vectors to permutations”, Manuscript 2007.
[16] V. S. Pless and W. C. Huffman, Eds., Handbook of Coding Theory.
Amsterdam, The Netherlands: Elsevier, 1998.
[17] T. G. Swart and H. C. Ferreira, “A generalized upper bound and a
multilevel construction for distance-preserving mappings”, IEEE Trans.
on Inform. Theory, vol. 52, no. 8, pp. 3685–3695, August 2006.
1A Simple Construction of Distance-Increasing
Mappings from Ternary Vectors to Permutations
Jen-Chun Chang and Hsin-Lung Wu
Abstract—We give the first explicit construction of distance-
increasing mappings from ternary vectors to permutations (3-
DIM). Our construction is a simple and one-pass algorithm, that
is, it only reads the input once. Combining with the result of
[2], we obtain DIM constructions which can increase distance by
at least two. As a result, we achieve a better lower bound for
permutation arrays, i.e., P (n, d) ≥ A3(n, d− k), for any k, if n
is greater than some constant depending on k.
Index Terms—Code constructions, permutation arrays, ternary
codes, distance-increasing mappings.
I. INTRODUCTION AND NOTATIONS
A distance-preserving mapping (q-DPM) is a one-to-one
function from q-ary vectors of length n to permutations
on {1, · · · , n} such that any two distinct q-ary vectors are
mapped to two different permutations with an equal or greater
Hamming distance. In [4], [5], [7], [8], [13], the authors gave
systematic ways for constructing 2-DPMs. For q = 3, Lin et.
al. [11] and Lin. et. al. [12] independently gave the 3-DPM
constructions. In particular, the 3-DPM of [12] is a two-pass
algorithm, that is, it reads the input only twice. Moreover, the
approach of [12] indicates an approach to construct general
q-DPMs. One may require more conditions for q-DPM. A
natural way is to demand that q-DPMs increase more distance.
This leads to the so-called distance-increasing mappings. A
distance-increasing mapping (q-DIM) is a special DPM which
maps any two q-ary vectors of length n with Hamming
distance d to two permutations with Hamming distance at least
min{d+ 1, n}. In [1]–[3], [6], [9], [10], the authors proposed
several algorithms for constructing 2-DIMs. To construct q-
DIMs for general q ≥ 3 is an open problem (see [12]). In
this paper, we propose the first algorithmic construction of 3-
DIM. Our construction has two advantages. First, our 3-DIM
is a one-pass algorithm. It only needs to read the input once.
This improved the 3-DPM in [12] which is required to read the
input twice. Second, our approach gives a scheme to construct
general q-DIMs.
Construction Idea: To construct a one-pass 3-DIM, we
consider the following conceptual procedure. Since we require
it to be one-pass, suppose the DIM reads the input from the
first digit to the last one once. Initially we start from the trivial
permutation, that is, identity function. When the first input
digit is zero, we do nothing. When it is either 1 or 2, then
we rotate some positions in the initial permutation vector. The
Department of Computer Science and Information Engi-
neering, National Taipei University, Taipei, Taiwan, Email:
({jcchang,hsinlung}@mail.ntpu.edu.tw). The work was supported in part by
the National Science Council of Taiwan under contracts NSC-96-2221-E-305-
006-, NSC-96-2628-E-305-002-MY3, and NSC-97-2218-E-305-001-MY2.
process can be executed sequentially. In round k, the procedure
reads the k-th digit, then depending on the value of the k-
th digit it rotates the corresponding positions of the resulting
permutation vector obtained after the first k− 1 rounds. How
can one require this conceptual algorithm to be a DIM? An
idea is to construct a graph G = (V,E) with the vertex
(position) set V = {1, · · · , n} and the edge set E composed
of n triangles T1, · · · , Tn with some additional requirements.
First, we require the collection of triangles ”uniformly” covers
the set V . That is, every vertex is contained in exact three
triangles. Second, we would like to separate these triangles
into three parts. Every two triangles in each part are vertex-
disjoint. Once given such a collection of n triangles, say, one
might follow the above conceptual procedure to construct a
DIM. Precisely, when the k-th digit read by the algorithm is 0,
1, and 2, we do nothing, cyclically rotate right, and cyclically
rotate left, respectively, the positions in Tk of the permutation
vector obtained after the first k− 1 rounds. Note that, for any
two inputs, if their k-th digits are different, the triangle Tk
seems to contribute Hamming distance 3. For any two input
vectors, suppose the number of the first k input digits that are
different is dk. One may hope that the resulting permutations
in the k-th round have distance larger than dk. However, in
general, this is not true. For example, when the algorithm
reads the first part of input and rotates the positions of some
triangles in the first part, the resulting distance is 3dk at that
time due to the vextrex-disjointness. Because of the uniformity,
the distance will be greater than dk when the algorithm reads
the second part of input. Nonetheless, it may be the case that
the distance is equal to or less than dk when the algorithm
reads the last part of input, that is, k = n. This is due to the
fact that the algorithm may swap some value which locates
in different positions of that two resulting permutations in the
first two round into the same position when it processes the
last part of two different inputs. Our main contribution is to
give a good design to avoid this problem. For convenience, let
n = 9m. We design the three families of triangles as follows.
The triangle in the first and second family is of the form
{3i− 2, 3i− 1, 3i} and {3i− 2, 3i+ 2, 3i+ 6}, respectively.
Note that the algorithm obtained from these families owns
the ”local” property, that is, every value in the permutation
vector will never be far away from its initial position during
the executing of the algorithm. So, due to the localness of
our algorithm, we can divide the positions of the permutation
vector into three blocks. When the algorithm processes the
first two parts of input digits, every value, no matter where it
is swaped to, is always within the same block. Now the third
family of triangles of the form {3i − 2, 3i + 11, 3i + 24} is
3be in ∆(k)s . To summarize it, we have the following lemma.
Lemma 2: For any k ∈ [2], s ∈ [9m], and x ∈ Z9m3 ,
pi
(k+1)
sk+1(x)
(x) ∈ ∆(k)s .
The next lemma states that, for any two distinct input vectors
x and y, if the values in the position s ∈ SHIFT(k+1)i are
different after running the step k, then, in positions ps,k+1(x)
and ps,k+1(y), the corresponding values must be unequal after
executing the step k + 1. In fact, we obtain the following.
Lemma 3: Given any k ∈ [2], s ∈ [9m], and any x, y ∈
Z9m3 , suppose that pi
(k)
s (x) 6= pi(k)s (y) and s ∈ SHIFT(k+1)i
for some i ∈ [3m]. Then pi(k+1)ps,k+1(x)(x) 6= pi
(k+1)
ps,k+1(x)
(y) and
pi
(k+1)
ps,k+1(y)
(x) 6= pi(k+1)ps,k+1(y)(y).
Proof: The lemma holds trivially provided that
ps,k+1(x) = ps,k+1(y) since pi
(k+1)
ps,k+1(x)
(x) = pi(k)s (x) 6=
pi
(k)
s (y) = pi
(k+1)
ps,k+1(y)
(y). Now, fixed any k ∈ [2],
ps,k+1(x) ∈ SHIFTk+1i for some i ∈ [3m]. For the case
that ps,k+1(x) 6= ps,k+1(y), there must exist t ∈ SHIFTk+1i
such that pt,k+1(y) = ps,k+1(x) and t 6= s. By Lemma 2,
pi
(k+1)
ps,k+1(x)
(x) ∈ ∆(k)s and pi(k+1)ps,k+1(x)(y) = pi
(k+1)
pt,k+1(y)
(y) ∈
∆(k)t . Now, by Lemma 1, the corresponding sets ∆
(k)
s and ∆
(k)
t
are disjoint. This implies that pi(k+1)ps,k+1(x)(x) 6= pi
(k+1)
ps,k+1(x)
(y).
Similarly, we have pi(k+1)ps,k+1(y)(x) 6= pi
(k+1)
ps,k+1(y)
(y).
Now we are going to prove the distance-increasing property
of W9m.
Theorem 1: W9m is a 3-DIM for all m ≥ 3.
Proof: Given two distinct ternary vectors x =
(x(1), x(2), x(3)) and y = (y(1), y(2), y(3)) where x(k) and y(k)
are all in Z3m3 , let d
(k) = d(k)x,y = dH(x(k), y(k)) for k ∈ [3].
The proof will be divided into three cases.
• [There is some k ∈ [3] s.t. d(k) 6= d(h) for all h 6= k.]: Let
d = max{d(1), d(2), d(3)}. By Lemma 1 and Lemma 3,
dH(pi(x), pi(y)) ≥ 3d > d(1) + d(2) + d(3) = dH(x, y).
• [d(1) = d(2) = d(3) = d where 0 < d < 3m]:
It is clear that dH(pi(1)(x), pi(1)(y)) = 3d. Suppose
S = {i1, i2, . . . , id(1)} is the set of indices i’s such that
x
(1)
i 6= y(1)i . First of all, note that if there exists some
i /∈ S such that x(2)i 6= y(2)i and 3i − 2 /∈ 3S − 2,
then pi3i−2(x) 6= pi3i−2(y) by Lemma 1. In this case,
dH(pi(x), pi(y)) ≥ 3d + 1. So we may assume that
x
(2)
i 6= y(2)i for any i ∈ S. Under this assumption, there is
some i ∈ S such that i+ 1 /∈ S since 1 ≤ |S| ≤ 3m− 1.
In STEP 2 of W9m, pi
(2)
3i+2(x) 6= pi(2)3i+2(y). Again,
by Lemma 3, we have pi3i+2(x) 6= pi3i+2(y). Thus
dH(pi(x), pi(y)) ≥ 3d+ 1 > dH(x, y).
• [d(1) = d(2) = d(3) = 3m]: It is easy to check that
dH(pi(x), pi(y)) = dH(pi(1)(x), pi(1)(y)) = 9m.
B. 3-DIM for all input length ≥ 216
In this section, we extend our algorithm W9m such that it
can work well for all length at least 216. To obtain it, we need
the ”locality” of the algorithm W9m shown in the following
lemma which can be derived easily. Let Im(W9m) be the image
set of the algorithm W9m. For any t ∈ [8], let s(i, t) = 27i+
3t− 29.
Lemma 4: Let m ≥ 24 and t ∈ [8]. Then, for any pi, τ ∈
Im(W9m) and for any i, j ∈ [8] with i 6= j, we have pis(i,t) 6=
τs(j,t).
Proof: Fixed any t, note that ∆(3)s(i,t) = {27i + 3t −
29, 27i+3t−28, · · · , 27i+3t−3} and ∆(3)s(j,t) = {27j+3t−
29, 27j+3t−28, · · · , 27j+3t−3}. Obviously, if i 6= j, then
∆(3)s(i,t)∩∆(3)s(j,t) = ∅. Finally, the fact that pis(i,t) ∈ ∆(3)s(i,t) and
pis(j,t) ∈ ∆(3)s(j,t) follows the lemma.
To succinctly represent our extended DIM, we introduce some
notations as follows.
Definition 4: Let Ord : Z3 × Z3 → {0, 1, · · · , 8} be a
bijective function defined as Ord(x, y) = 3x + y such that
Ord(x, y) < Ord(x′, y′) if x < x′ or x = x′ and y < y′.
For example, Ord(0, 0) = 0, Ord(1, 2) = 5, and Ord(2, 2) =
8.
Definition 5: For any set S and positive integer `, let
Cyci : S` → S` be the function that shifts the input `-
tuple vector by i positions. That is, Cyci(a1, · · · , a`) =
(a`−i+1, · · · , a`, a1, · · · , a`−i) for any a = (a1, · · · , a`) ∈
S`.
For example, if a = (1, 2, 3, 4, 5), then Cyc2(a) =
(4, 5, 1, 2, 3).
Definition 6: Given any permutation σ ∈ S9m+k and any
t ∈ [k], let ~σt = (σs(1,t), σs(2,t), · · · , σs(8,t), σ9m+t).
For instance, if σ = (1, 2, · · · , 9m + k), m = 25
and t = 1, then s(i, 1) = 27i − 26 and
~σ1 = (σs(1,1), σs(2,1), · · · , σs(8,1), σ9m+1) =
(1, 28, 55, 82, 109, 136, 163, 190, 226). Using above notations,
we give our extended 3-DIM W9m+k shown as follows.
Algorithm W9m+k
(m ≥ 24, 1 ≤ k ≤ 8, s(i, t) = 27i+ 3t− 29):
Input: (z1, · · · , z9m, w1, · · · , wk) ∈ Z9m+k3
(σ1, · · · , σ9m)←W9m(z1, z2 · · · , z9m);
(σ9m+1, · · · , σ9m+k)← (9m+ 1, · · · , 9m+ k);
for t = 1 to k do;
compute h = Ord(z1, wt) and set ~σt = Cych(~σt);
Output: (σ1, · · · , σ9m+k) ∈ S9m+k
Next we show the correctness proof of W9m+k.
Theorem 2: W9m+k : Z9m+k3 → S9m+k is a 3-DIM for all
m ≥ 24 and k ∈ {0, · · · , 8}.
Proof: Given two distinct ternary vectors (x,w), (y, v) ∈
Z9m3 × Zk3 , suppose that pi = W9m+k(x,w) and τ =
W9m+k(y, v). Let pi′ = (W9m(x), 9m + 1, · · · , 9m + k) and
τ ′ = (W9m(y), 9m+ 1, · · · , 9m+ k). For the first 9m digits,
note that the set of the indices in which pi and pi′ (τ and τ ′)
might be different is {s(i, t) : i ∈ [8], t ∈ [k]}. To see the
variation of the Hamming distance, we discuss it as following
two cases:
• [dH(x, y) < 9m]: Since dH(x, y) < 9m and W9m is
distance-increasing, we have dH(pi′, τ ′) > dH(x, y). If
dH(w, v) = d and x1 = y1, for each t with wt 6= vt,
by Lemma 4, we have dH(~pit, ~τt) ≥ dH(~pi′t, ~τ ′t)+1. Note
that, for any t and t′ with t 6= t′, {s(i, t) : i ∈ [8]}
and {s(i, t′) : i ∈ [8]} are disjoint. So dH(pi, τ) ≥
dH(pi′, τ ′) + d > dH(x, y) + dH(w, v). Moreover, if
26
附錄三：Jen-Chun Chang, Hsin-Lung Wu, "Constructing Constant Composition Codes via
Distance-Increasing Mappings," submitted to IEEE Transactions on Information Theory.
2II. PRELIMINARY
For any natural number q, let Zq denote the set
{0, 1, · · · , q − 1}. Let Znq denote the set of all q-ary vectors
of length n. Given a binary vector s ∈ Zn2 , we denote s as the
vector 0i11i20i3 · · · 1ik where i1 + i2 + · · · + ik = n. Given
a function f , let Im(f) be the image set of f . Given a vector
s ∈ [q]n and a vector w = (w1, . . . , wq) with
∑
i wi = n,
we say s has constant composition w = (w0, . . . , wq−1) if
each symbol i ∈ Zq appearing in s has wi occurrences.
Moreover, we call a composition w = (w0, . . . , wq−1) non-
zero if, for every i ∈ Zq, wi 6= 0. Let CC(n, [w0, · · · , wq−1])
(or CC(n,w)) be the set of vectors in Znq which have constant
composition w = (w0, . . . , wq−1). Given two vectors a =
(a0, a1, · · · , an−1) and b = (b0, b1, · · · , bn−1), the Hamming
distance d(a, b) between them is the number of positions
where they differ, i.e. d(a, b) = |{j ∈ Zn : aj 6= bj}|.
We give the definition of distance-preserving (and distance-
increasing) mappings from p-ary vectors to constant compo-
sition q-ary vectors as follows.
Definition 1: A mapping f : Zmp → Znq is called a distance-
preserving mapping for composition w = (w0, · · · , wq−1) if,
for any x, y ∈ Znp , d(f(x), f(y)) ≥ d(x, y) and Im(f) ⊆
CC(n,w). Furthermore, f is a distance-increasing mapping
for composition w if d(f(x), f(y)) ≥ min{d(x, y) + 1, n}.
III. DISTANCE-INCREASING MAPPINGS FOR CONSTANT
COMPOSITION VECTORS
Here we show an algorithm W4n for a distance-increasing
mapping f : Z4n2 → CC(4n, [n, n, n, n]).
Algorithm W4n:
Input: b = (b0, b1, · · · , b4n−1) ∈ Z4n2
Output: pi = (pi0, pi1, · · · , pi4n−1) ∈ CC(4n, [n, n, n, n])
INITIALIZATION:
for k = 0 to n− 1
(pi4k, pi4k+1, pi4k+2, pi4k+3) ← (0, 1, 2, 3)
PHASE ONE:
For k = 0 to n− 1
if b3k = 1, then swap(pi4k, pi4k+1)
if b3k+1 = 1, then swap(pi4k+2, pi4k+3)
if b3k+2 = 1, then swap(pi4k+1, pi4k+2)
PHASE TWO:
For k = 0 to n− 1
if b3n+k = 1, then swap(pi4k+3, pi(4k+4 mod 4n))
Output (pi0, · · · , pi4n−1)
For reader’s comprehension, the result of the initialization
part of Algorithm W4n is shown in Fig. 1. Before showing
the correctness of the Algorithm W4n, we give some useful
definitions and lemmas.
Given x, y ∈ Z4n2 , let W4n(x) = pi(x) and W4n(y) = pi(y).
We partition x and y into two parts (x(1), x(2)) and (y(1), y(2))
respectively where x(1), y(1) ∈ Z3n2 and x(2), y(2) ∈ Zn2 .
0 1
b0
2
b2
3
b1
0 1
b3
2
b5
3
b4
…
.
b3n
n
b4n-1
 !0 !1 !2 !3
!4 !5 !6 !7
0 1
b3n-3
2
b3n-1
3
b3n-2
!4n-4 !4n-3 !4n-2 !4n-1
b3n+1
0 1
b6
2
b8
3
b7
!8 !9 !10 !11
b4n-2
0 1
b3n-6
2
b3n-4
3
b3n-5
!4n-8 !4n-7 !4n-6 !4n-5
Fig. 1. The initialization of the Algorithm W4n
Definition 2: Let pi(1)(x) be the resulting vector after run-
ning PHASE ONE in Algorithm W4n with input x ∈ Z4n2 .
Furthermore, let pi(1)s (x) be the s-th entry of the vector pi(1)(x),
pis(x) be the s-th entry of the vector pi(x), and xi be the i-th
entry of the vector x, respectively.
We would like to show that, for each row, the
execution of PHASE ONE of Algorithm W4n results
in a distance-increasing mapping. Given z ∈ Z32 ,
let z(k) = 03kz04n−3k−3. Define gk+1(z) =
(pi
(1)
4k+1(z(k)), pi
(1)
4k+2(z(k)), pi
(1)
4k+3(z(k)), pi
(1)
4k+4(z(k))) for
each k ∈ Zn. It is easy to verify the following lemma.
Lemma 1: For each i ∈ [n], gi : Z32 → [4]4 is a distance-
increasing mapping, i.e. d(gi(x), gi(y)) ≥ d(x, y) + 1 for any
distinct x, y ∈ Z32 .
Next, we need a lemma which will help to prove the
distance-increasing property.
Lemma 2: For any x, y ∈ Z4n2 and k ∈ Zn, if x3n+k 6=
y3n+k, then pi4k−1(x) 6= pi4k−1(y) and pi(4k mod 4n)(x) 6=
pi(4k mod 4n)(y).
Proof: It is easy to check that pi(1)4k−1(x) ∈ {3, 4},
pi
(1)
4k−1(y) ∈ {3, 4}, pi
(1)
(4k mod 4n)(x) ∈ {1, 2}, and
pi
(1)
(4k mod 4n)(y) ∈ {1, 2}. Since x3n+k 6= y3n+k, without loss
of generality, we can assume x3n+k = 0 and y3n+k = 1. After
executing PHASE TWO, pi(1)4k−1(y) and pi
(1)
(4k mod 4n)(y) are
swapped. Therefore, pi4k−1(x) ∈ {3, 4}, pi4k−1(y) ∈ {1, 2},
pi(4k mod 4n)(x) ∈ {1, 2}, and pi(4k mod 4n)(y) ∈ {3, 4}. This
completes the proof.
Now we are going to prove the distance-increasing property
of W4n.
Theorem 1: W4n realizes a distance-increasing mapping f :
Z4n2 → CC(4n, [n, n, n, n]) for any positive integer n.
Proof: Given two distinct binary vectors x = (x(1), x(2))
and y = (y(1), y(2)), let d′ = d(x(2), y(2)). Furthermore,
we divide x(1) and y(1) into n parts {x[3i,3i+1,3i+2] :
i ∈ Zn} and {y[3i,3i+1,3i+2] : i ∈ Zn}. Let di =
d(x[3i,3i+1,3i+2], y[3i,3i+1,3i+2]). The proof is divided into two
4In addition, it is impossible to have an edge (u, v) such that
their labeled values are the same. See Fig. 2(a) as an example.
Otherwise, suppose the edge is labeled as bi. Then consider
the two input vector x = 0m and y = 0i−110m−i. Then we
have d(x, y) > d(P (x), P (y)) and get a contradiction.
2 0
bi
1
bj
1
bk
1 2
bi
1
bj
1 1
bi
(a) (b)
(c)
1 2
bi
0
bj
(d)
1
bk
Fig. 2. Possible swapping graphs GP for the function f : Zm2 → Zn3 .
Next, it is also impossible to have a path (u1, u2, u3) such
that the labels of u1 and u3 are the same. See Fig. 2(b) as an
example. Otherwise, suppose the two edges in this path are
labeled as bi and bj , respectively and i < j. Then consider the
two input vector x = 0i−110m−i and y = 0i−110j−i−110m−j.
Then we have d(x, y) > d(P (x), P (y)) and get a contradic-
tion.
Furthermore, GP cannot have a vertex whose degree
is at least 3. Otherwise, we can find a set of vertices
{u1, u2, u3, u4} with edges (u1, u2), (u1, u3), (u1, u4) la-
beled bi, bj , and bk. Since the labels of u2, u3, and u4 must
be different from u1’s, at least two vertices of {u2, u3, u4}
must have same labels. See Fig. 2(c) as an example. In
this case, without loss of generality, let j < k and con-
sider x = 0j−110m−j, y = 0j−110k−j−110m−k. We have
d(x, y) > d(P (x), P (y)) and get a contradiction.
Moreover, suppose GP has a path u1 ↔ u2 ↔ u3 ↔ u4
where (u1, u2), (u2, u3), and (u3, u4) are labeled bi, bj , and
bk respectively and the vertices u1 and u4 are labeled the same
value. See Fig. 2(d) as an example. If j > i or j > k, then
P cannot be a distance-preserving mapping. Otherwise, we
consider the following cases. In the first case that j > k > i,
consider the two input vector x = 0i−110k−i−110m−k and
y = 0i−110k−i−110j−k−110m−j . The second case that j >
i > k is similar to the previous case. In the third case that i >
j > k, consider the two input vector x = 0i−110j−i−110m−j
and y = 0i−110j−i−110k−j−110m−k. The fourth case that
k > j > i is also similar to the third case. Among these
cases, we all have d(x, y) > d(P (x), P (y)). Hence we get a
contradiction.
By previous discussion, since GP contains at least 3n/4+1
edges and P is supposed to be a distance-preserving mapping,
GP must have a path u1 ↔ u2 ↔ u3 ↔ u4 ↔ u5 where
(u1, u2), (u2, u3), (u3, u4), and (u4, u5) are labeled bi, bj , bk,
and bh, respectively. Furthermore, u1 and u4 are labeled the
same value and so are u2 and u5. See Fig. 3 as an example.
1 2
bi
0
bj
1
bk
2
bh
Fig. 3. Possible swapping graph GP for the function f : Zm2 → Zn3 .
Since P realizes a distance-preserving mapping, it must be
the case that j = min{i, j, k} and k = min{j, k, h} from our
previous discussion. However, this implies that j < k < j.
It’s also a contradiction. Thus P cannot realize a distance-
preserving mapping if m > 3n/4. This proves the theorem.
A natural question is whether the bound 3n/4 + 1 is
optimal. Here we show it indeed is optimal by giving
a swapping algorithm C3m that implements a distance-
preserving (and also distance-increasing) mapping f : Z3m2 →
CC(4m, [m,m, 2m]).
Algorithm C3m:
Input: b = (b0, b1, · · · , b3m−1) ∈ Z3m2
Output: pi = (pi0, pi1, · · · , pi4m−1) ∈ CC(4m, [m,m, 2m])
INITIALIZATION:
for k = 0 to n− 1
(pi4k, pi4k+1, pi4k+2, pi4k+3) ← (0, 1, 2, 0)
PHASE ONE:
For k = 0 to n− 1
if b3k = 1, then swap(pi4k+1, pi4k+2)
if b3k+1 = 1, then swap(pi4k, pi4k+1)
if b3k+2 = 1, then swap(pi4k+2, pi4k+3)
Output (pi0, · · · , pi4m−1)
The result of the initialization part of Algorithm C3m is
shown in Fig. 4. It is not hard to verify C3m indeed realizes
the expected distance-preserving (in fact, distance-increasing)
mapping.
m
1 2
b0
0
b2
0
b1
1 2
b3
0
b5
0
b4
1 2
b3m
00
b3m-1b3m-2
…
.
1 2
b3m-3
00
b3m-4b3m-5
Fig. 4. A DPM (DIM) f : Z3m
2
→ CC(4m, [m, m, 2m]).
V. CONCLUSION AND OPEN PROBLEMS
We give the first swapping construction of distance-
increasing mappings from binary vectors to quaternary con-
stant composition vectors. As an application, we obtain the
lower bound A(4n, d, [n, n, n, n]) ≥ A2(n, d− 1). Our result
1行政院國家科學委員會補助參與國際會議報告
98 年 9 月 20 日
報告人姓名 張仁俊
服務
機構
國立台北大學資訊工程學系 職稱 教授
中文：2009 IEEE 第五屆資訊隱藏與多媒體信號處理國際研討會
會議正式名稱
英文：2009 IEEE Fifth International Conference on
Intelligent Information Hiding and Multimedia Signal
Processing
會議時間
自 98 年 09 月 12 日
至 98 年 09 月 14 日
地點（國、州、城市） 日本、京都
報告內容：
一、 參加會議經過：
會議的前一天(9 月 11 日)中午我們由桃園機場出發前往日本京都
(Kyoto, Japan)，參加 2009 IEEE 5th International Conference on
Intelligent Information Hiding and Multimedia Signal Processing
(2009 IIH-MSP) 國際會議。此行我們主要的目的是發表論文『A Hybrid RFID
Protocol against Tracking Attacks』。因為到達關西機場時已是傍晚，
我們立刻搭乘 JR 特快火車(費時約 90 分鐘)到京都車站，趕在會議前一晚
先到會場去認識一下環境。
正式會議之議程於 9 月 12 日開始，每日議程開始均有一場 Keynote
3 A02 Techniques and Algorithms for Multimedia Security
 A08 Steganography and Watermarking
 A15 Recent Technologies and Applications of Audio Data Hiding
 B01 Coding and Protocols in Security and Applications
 B06 Intelligent Watermarking Techniques, Image
Authentication and Visual Cryptography (I)
 B11 Intelligent Watermarking Techniques, Image
Authentication and Visual Cryptography (II)
 C01 Advanced Data Hiding and Coding Techniques for Audio
Signals
 C04 Advances in Multimedia Signal Processing and
Communications
 C07 Multimedia Signal Processing for Plasma Diagnostics
以上每一個 session 均有 8至 9篇論文發表。我們的論文『A Hybrid RFID
Protocol against Tracking Attacks』被排在 B01 Coding and Protocols
in Security and Applications 這個 session 的第 3 順位，大約有 15 分
鐘讓我們進行簡報發表論文並與其他學者互相討論。
因為會議最後一天 9 月 14 日的議程排到晚上 6 點 20 分，所以我們是
在 9月 15 日離開議場，結束了日本京都之 2009 IEEE 第五屆資訊隱藏與多
媒體信號處理國際研討會的行程，回到台灣。
5五、 其他
此次攜回物品為 Final Program Handbook (紙本)、Conference
Proceedings CD (電子檔之會議論文集，內容為所有 IIH-MSP 2009 會議所
收錄之論文)，相當具有參考價值。
96年度專題研究計畫研究成果彙整表 
計畫主持人：張仁俊 計畫編號：96-2628-E-305-002-MY3 
計畫名稱：保距(或增距)對應與排列編碼建構演算法之研究 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 3 3 100%  
博士生 1 1 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 1 1 100%  
研究報告/技術報告 1 1 100%  
研討會論文 3 2 100% 
篇 
 
論文著作 
專書 1 1 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
 
