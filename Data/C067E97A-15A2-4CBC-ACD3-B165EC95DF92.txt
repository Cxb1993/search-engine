I 
 
摘  要 
 
本二年期計畫將提出可以處理大型網絡(large Boolean network)以模擬(simulation)與
布林滿足(Boolean SATisfiability)為核心之布林比對(Boolean matching)演算法及相關之
CAD 工具。Boolean Satisfiability (SAT) 的問題就是針對一個以 CNF (Conjunction Normal 
Form) 表示之布林函數 f(X)，使得 f(X)可為真 (Ture)，或者證明 f(X)為 constant 0。即使
SAT 是一個 NP-complete 的問題，近年來已經有相當多的研究族群投入此研究領域，所
提出之技術使得 SAT 搜索引擎 (SAT solver)之效能有極大的改進 [2-6]。在過去十年裏，
包括電子設計自動化(EDA - Electronic Design Automation) 公司、國際知名之大專院校及
研究機構利用 SAT Models 及演算法來處理很多不同的 EDA 問題 [1]，主要之應用有測試
(testing)、正規驗證(formal verification)、邏輯最佳化(logic optimization)、FPGA繞線(routing)
及實體設計(physical design)等問題。  
布林比對用來檢查兩個具有相同輸入個數的布林函數在輸入排列(input permutation)
及輸入/輸出相設定(input/output phase assignment)是否相等(稱為 NPN-class)，可應用在技
術映成(technology mapping)及正規驗證上。到目前為止，已經有很多相關的研究成果及
應用[68-80,82,83]。根據我們的瞭解，以往所提出之方法大多以 SOP (Sum of Products)或
二元決策圖作為布林函數的表示法，但是這些表示法對於超大型函數會有記憶體爆滿
(memory explosion)的問題，所以無法使用。 
根據以上所述，有鑑於 S&S 技術及布林比對在 EDA 問題之應用日益增廣，本計畫
已研究 S&S 相關技術，將布林比對轉換成 SAT 問題，並提出可以處理大型網絡(large 
Boolean network)以 S&S 為核心技術之布林比對演算法及相關之 CAD 工具。 
 
關鍵詞：模擬&布林滿足，布林比對，大型網絡，電子設計自動化 
III 
 
 
報 告 內 容 索 引 
 
目錄 
第一章 序論 .......................................................................................... 1 
1.1 前言 .................................................................................................................... 1 
1.2 研究目的 ............................................................................................................ 1 
1.3 研究方法 ............................................................................................................ 3 
第一年 .............................................................................................................. 3 
第二年 .............................................................................................................. 5 
第二章 漸近式比對 ................................................................................... 6 
2.1 可處理 Don’t care 之布林比對問題 ................................................................ 6 
2.2 多值函數之對應 ............................................................................................... 6 
2.3 漸進式學習之布林比對 .................................................................................... 8 
2.3.1 學習階段 ................................................................................................ 8 
2.3.2 應用階段 ................................................................................................ 9 
2.4 布林比對演算法 ...............................................................................................11 
2.4.1 函數對稱性 ...........................................................................................11 
2.4.2 單變數對稱特徵值 .............................................................................. 12 
2.4.3 我們的比對演算法 .............................................................................. 13 
2.5 布林比對之 SAT 模型..................................................................................... 14 
2.5.1 全合法對應(Totality)之 SAT 模型..................................................... 15 
2.5.2 布林比對之 SAT 模型......................................................................... 15 
第三章  以模擬與 SAT 為主可處理大型布林網絡之布林比對技術.17 
3.1 背景說明 .......................................................................................................... 17 
3.1.1 布林比對(Boolean Matching) ............................................................ 17 
3.1.2 布林滿足-Boolean Satisfiability (SAT) ............................................. 18 
V 
 
 
圖 例 索 引 
 
圖 2.1 Partial-Mapping之演算法………………………………………………………….14 
 
圖 3.1 Boolean Matching範例……………..………………………………………………17 
圖 3.2 AIG (And-Invert Graph)…………………………….……………………………...18 
圖 3.3以模擬為主搭配 SAT之解題演算法…………...…………………………………..22 
圖 3.4 以 ix 以及 }{ ixX − 來分組之 K-map…………………..……………………..……..24 
圖 3.5 模擬向量產生範例………………………………………….………………………24 
圖 3.6 AIG以及 Implication supergate…………………..……………..………………….26 
圖 3.7 f 之 K-map 以及輸入模擬向量…………………………………………………….27 
圖 3.8 Single variable symmetry 模擬範例……………………………………….………28 
圖 3.9 f(X)之K-map、輸入向量集合V 及模擬之輸出向量O………………………….…30 
圖 3.10 可用來切割Gi之Type 1模擬向量集合………………………………………….32 
圖 3.11多群組之模擬向量集合………………………………..................………………..32 
圖 3.12 f(X)及 g(Y)之 K-map、輸入向量集合V 及模擬之輸出向量 Of與 Og…………..33 
圖 3.13 Vj之Type 2模擬輸入向量.......................................................................................34 
圖 3.14範例 3.7之模擬輸入、輸出向量以及輸出權重…………………………….……..34 
圖3.15 Gi的Type 3模擬向量...............................................................................................35 
圖 3.16範例 3.8之模擬輸入以及輸出向量…………………………………………….…36 
圖 3.17以模擬為主搭配 SAT驗證之布林比對方法……………………………………...38 
VII 
 
 
表 格 索 引 
 
表 2.1函數對稱性總表………………………………………………………..……………11 
表 3.1 布林函數的對稱關係……………………………………….………………………19 
表 4.1 35 個完全描述函數之實驗數據………………………………….………………...43 
表 4.2 不完全描述函數之實驗數據………………………………………….……………44 
表4.3測試電路之binate與unate特性偵測結果與偵測時間…………………..………..47 
表 4.4測試電路之E與NE對稱情形與偵測時間…………………………………….…..48 
表 4.5測試電路之 single variable對稱情形與偵測時間………..………………………..48 
表 4.6布林比對之結果及執行時間(Threshold = 1000)………………..…………………49 
表4.7輸入數大於50之布林比對之結果及執行時間(Threshold = 1000)……...………..51 
表4.8改變Threshold後布林比對執行時間之比較…………………………………..…..52 
表4.9輸入數大於50之電路找第一組解的時間(Threshold = 1000)…………………….53 
表 4.10 使用特徵值於布林比對之比較…………………………….……………………..54 
表4.11 s系列電路之輸入輸出數目以及整體NE對稱情形……………..……………….55 
表 4.12 s系列電路之布林比對結果……………………………………………..………...56 
表 4.13 s系列電路使用不同Threshold臨界值的比較………………………………..….57 
 
 
2 
Form) 表示之 Boolean Formula f(X)，然後去 Search 是否存在一組 variable assignment，
使得 f(X)可為真 (Ture)，或者證明 f(X)為 constant 0。近年來已經有相當多的研究族群
包括 EDA (Electronic Design Automation) 公司、國際知名之大專院校及研究機構利用
SAT Models 及 Algorithms 來處理很多不同的 EDA 問題 [1]。之所以如此，主要的原
因在於近來 SAT 演算法有極佳之改進 [2-5]，使用之技術有 local search ，
non-chronological backtracking [2]、conflict driven clause learning [2]、recursive learning 
[6]、 restarts [5] 與 watch literals [5]，而較著名之 SAT Solver 有 GRASP [2]、 ZChaff 
[3]、BerkMin [4] 及 SATO [5]，使得 SAT 可以處理不同應用 domains 裏非常大(超過數
百萬之 variables 及 clauses)之 problem instances。 
目前 SAT 在 EDA 領域的應用相當廣泛，茲簡單分類描述如下： 
z 測試 (Testing)  
有 ATPG (Automatic Test Pattern Generation) [7-13]、delay fault testing [14-16]及
redundancy identification and removal [17-20]。 
z 電路驗證 (Circuit Verification)  
有 Boolean reasoning [21-23] 、combinational equivalence checking [6,24-26,85]、
processor verification [27,28] 及  unbounded modeling checking [30-33] 及 
bounded model checking [34-40]。 
z 邏輯合成 (Logic Synthesis) 
有 logic optimization [41-43,84]、fault diagnosis and logic debugging [44,86]、
symmetry detection [45]、covering problem [29]、switching activity estimation [46] 
及 multi-clock path analysis [47]。 
z 實體設計合成 (Physical Design Synthesis) [48] 
有 routing [49,51]、wavelength assignment [49] 及 layout synthesis [50] 。 
z FPGA 繞線 (FPGA Routing) [52-57]  
其他應用還包括系統合成  (System Synthesis [57-60]、漏電流之降低  (Leakage 
Reduction)[61]、雜訊分析 (Crosstalk Noise Analysis)[62]、智財保護(Intellectual Property 
Protection – IPP)[63,64] 及延遲計算 (Delay Computation)[65-67] 。 
除了將以上 EDA 問題 Model 成 SAT instances，並以 SAT Solver 來求解外，所謂
S&S (Simulation and Satisfiability) 技術就是整合 Simulation 及 SAT 之技術，目前主要
是應用在 formal verification 及 ATPG 之問題，近年來也有將 S&S 技術應用在 logic 
synthesis 的問題上 [45,88-91]。其中，[45] 提出用於偵測大型函數(無法用 BDD - Binary 
Decision Diagram [94] 表示)對稱性技術；[88] 將 S&S 技術用於 SPFDs (Sets of Paris of 
4 
如果只考慮 permutation of inputs，則 },...,,...,,{ 21 mk vvvvV = 包含 m 個
variables，其中 m=n*n 而且 n is the number of variables in X (Y)。 Xxi ∈ 對
應到 Yy j ∈ 之 mapping 以 1=kv  代表，其中 k=(i-1)*n+j。 
 
範例 1.1： Let n = 3. 下表為其對應關係，表中數字為變數 kv 之索引值。 
 1y  2y  3y  
1x  1 2 3 
2x  4 5 6 
3x  7 8 9 
至於 clauses (DNF – Disjunction Normal Form) 之產生將以根據之前的研究
成果為基礎 [82]，制定轉換規則。此部分之 Modeling 不僅可以適用於 CSF 
(Completely Specified Functions) 也可用在  ICSF (Incompletely Specified 
Functions)，而且可以很容易地擴充為同時考慮 input / output phase 
assignment。 
z 特徵值技術 - 加速轉換過程及減小 SAT instance 
此部分工作將利用函數對稱性 (functional symmetry) [82] 與特徵值 
(signature) [83]來刪除 redundant clauses 及降低 clause size (number of literals 
in this clause)，進而加速 SAT engine 處理的速度。 
z SAT Engine 之選擇與修正 
此部分工作將選擇現存之SAT Solver 之open source 如GRASP [2]、 ZChaff 
[3]、 BerkMin [4] 或 SATO [5]作為我們 Boolean Matching 工具之核心，除
此之外，將進一步修改使此工具核心可以找出所有的 mapping 解。 
z 考慮最佳 cost 之 mapping 解  
此部分工作必須發展相關之演算法及還修改 SAT engine，使得找到 mapping
解具有最佳 cost，其重要的應用如 technology mapping 過程中將 delay and 
power 考慮進去，作法將參考目前已知類似研究[96]進行研發工作。 
z ABC 系統開發平台之研究與設置 
ABC (A System for Sequential Synthesis and Verification) [98]是由 UC. 
Berkeley 近年來針對 binary sequential logic circuits 所開發之 synthesis and 
verification 系統，採用此系統為開發環境的原因是 SIS, VIS and MVSIS 等
系統無法提供 flexible programming environment，加上 AIG (And-Inver-Graph)
6 
 
 
第二章 漸近式比對 
 
2.1 可處理 Don’t care 之布林比對問題 
 一個不完全描述函數是一個布林函數具有以下三個集合，on-set( onf )、off-set( offf )
及非空的 don't care set( dcf )；於本報告中一個不完全描述函數將記作 ),( offon fff = 。
兩個函數 f 和 g相對於同一組輸入之下，我們說他們相等若且唯若 =∩ offon gf Ø 且
=∩ onoff gf Ø，記作 gf ≅ 。 
給 定 任 意 兩 個 不 完 全 描 述 函 數 )(Xf 和 )(Yg 且 },...,,{ 21 nxxxX = 、
},...,,{ 21 nyyyY = 。布林比對用來檢查不同輸入的排列或輸入/輸出相設定下，函數
f~ (由 f 導出)和 g是否相等。換句話說，不完全描述函數的布林比對是在尋找是否具
有一個對應關係ψ 可以將每一個 ix 對應至唯一的 iy (或是 iy )使得 gf ≅~ ，且
))((~ Xff ψ= 或 ))((~ Xff ψ= 。 
 
2.2 多值函數之對應 
 一個具有多重值的輸入及二元值的輸出的函數 F (之後簡稱多值函數)為一個映射
BPPPF n →×⋅⋅⋅×⋅⋅⋅×× 21: ，其中 }1,0{=B 且 },...,2,1{ ii pP = 表示變數 i 可設定的值
ip。我們稱F 具有 n 個多重值的輸入而且每個變數 i都可以有 ip 種不同值。令 ix 為從 iP
取值之變數且 iS 為 iP 之子集。符號 iSix 是變數 ix 的一個字元(literal)，其中 iSix 定義為若
ii Sx ∈ 則 1=iSix ；否則 0=iSix 性質的布林函數。舉例來說， }3,2,1{=iP 且 3=ix 則
1}3,1{1 =x 和 0}2,1{1 =x 。一個積項(或稱為積或 cube)為多個字元的布林積(AND)。一個
sum-of-products(或稱作 cover)為積項的布林和(OR)。 
 考慮兩布林函數 )(Xf 和 )(Yg 且它們的輸入集合分別為 },...,,{ 21 nxxxX = 和
},...,,{ 21 nyyyY = 。我們可以將多重值函數F 用映射的方式的定義如下。 
8 
321 yyyv = 。對於每個多重值輸入 i， }6,5,4,3,2,1{=P 且對所有 Pj ∈ 都對應至一組對應
ji yx → (或 3−jy ， 3>j )。則 ),( vuMvCube 為 BA +=ψ ，其中 }2,1{3}3{2}2,1{1 xxxA ++= 和
}6{
3
}5,4{
2
}6{
1 xxxB ++= 分別由規則一和規則二所導出。 
2.3 漸進式學習之布林比對 
一般來說，搜尋系統的機器學習分成兩階段，也就是學習階段(learning phase)和應
用階段(applying phase) [13]。學習階段是從目前輸入或是局部解中學習並儲存知識，
應用階段為使用已知的知識來將解空間縮小以達到減少重複的運算，藉此提升搜尋的
效率。接下來我們將介紹一些定義及名詞，接著更深入的介紹學習階段以及應用階段。 
令ψ 為對應過程中現階段所得到的局部對應解。考慮 cubes )( offoni ffu ∈ 和
)( offonj ggv ∈ 。 若 ψψ ≠⋅),( ji vuMvCube 則 我 們 稱 ),( ji vu 相 對 於 ψ 為 有 效 的
(effective)；反之，我們稱它為多餘的(redundant)。假設 cover C 和 cube s 具有相同的
多值輸入集合，若 Cci ∈∀ 都保證 sci ⊆ 則我們稱 cube s 為 cover C 的一 supercube。
若不存在其它 cover C 的 supercube 且 sp ⊂ ，則我們稱 s 為C 的最小 supercube 記作
)(Cξ 。令 c 為多重值輸入集合 X 的一 cube 且由 Xxi ∈ ，函數 ),( ixcMap 定義成 cube C
中 ix 的指定值。 
由我們的實驗分析，大部分的比對時間都花在重複之 cube 的 anding 運算上。所
以我們希望能迅速地方式偵測多餘的部分解( ),( ji vuMvCube )並將這些多餘的 anding
運算移除。 
 
2.3.1 學習階段 
在我們的布林比對演算法的學習階段，我們討論以下的相關議題。 
z 從何而學？(What do we learn from?) 
假設初始的對應解ψ 為 totality，對於每對 cube ),( ji vu ，我們產生局部對應解
),( ji vuMvCube=ω ，並且藉由 ωψψ ⋅= 將ψ 更新，所以我們學習的來源有
二，ψ 和 cube pair ),( ji vu (或 ),( ji vuMvCube )。 
z 學什麼？(What to learn?) 
10 
)(0),( vlitxMap i −⊆ξ (或 )(1),( vlitxMap i −⊆ξ )，則 ),( vu 為ψ 中多餘之 cube pair。  
證明：不失一般性，考慮一個輸入 )(1 ulitxi −∈ ( )(0 ulitxi −∈ )。假設 R ),( ixMap ξ
和S為 )(0 ulit− ( )(1 ulit− )。由命題條件可得知 SR ⊆ 。考慮任意 cube ψ∈c 且令Q 為
),( ixcMap 。既然ξ 為ψ 的最小之 supercube，很明顯地 RQ ⊆ ，由先前已知之 SR ⊆ ，
可推導出 SQ ⊆ 。由規則一， ),( vuMvCubex Si ∈ 為局部對應的 cube 表示法。既然
QxcMap i =),( 且 SQ ⊆ ，顯然 cxc Si =⋅ 。因此 ψψ =⋅ ),( vuMvCube ，也就是說 ),( vu 為
ψ 中的多餘之 cube pair。                                                    ■ 
範例 2.3：給定 cubes 321 xxxu = 和 421 yyyv = 。假設 }3,1{4}4,3,2{3}3,2{2}4,1{1)( xxxx=ψξ 為ψ
的最小之 supercube。以 )(1 ulitxi −∈ 做例子。既然 }4,2,1{)(0}4,1{),( 1 =−⊆= vlitxMap ξ
符合定理 3.2 的情況。所以 ),( vu 相對於 ψ 為多餘元素。直觀的，輸入
},{),( 411 yyxMap =ξ 中無論哪個輸入對應至 ix ，恆具有同一解，也就是說對於所有由π
至ψ 之合法的對應 =⋅ vu)(π  Ø。                                            ■ 
 給定一最小 supercube ξ 和任意輸入 ix 。令 ),(1 ixMap ξ 和 ),(0 ixMap ξ 分別為 ix 對
變數 jy 和 jy 的對應。考慮 cube pair ),( ji vu ，其中 )( offoni ffu ∈ 、 )( offonj ggv ∈ 。藉由
研究ξ 我們可以導出以下兩條規則。 
規則四：對於每個 )(1 ii ulitx −∈ ，我們可以將 ix 對應至 ),(1)(0 ijj xMapvlity ξ∩−∈ 。
對於每個 )(0 ii ulitx −∈ ，我們可以將 ix 對應至 ),(1)(1 ijj xMapvlity ξ∩−∈ 。 
規 則 五 ： 對 於 每 個 )(1 ii ulitx −∈ 我 們 可 以 將 ix 對 應 至 jy ， 其 中
),(0)(1 ijj xMapvlity ξ∩−∈ 。對於每個 )(0 ii ulitx −∈ 我們可以將 ix 對應至
jy ，其中 ),(0)(0 ijj xMapvlity ξ∩−∈ 。 
在應用階段，我們討論以下的相關議題： 
z 有用的知識有哪些？(How to detect applicable knowledge?) 
可應用的知識包括最小 supercube ξ 和 cube pairs ),( vu 所生成的局部對應解
ω 。 
z 如何運用知識？(How to apply knowledge?) 
以定理 3.1、定理 3.2 規則四和規則五為基礎，我們開發一個可以對 cube pair 
),( ji vu 產生局部對應解ω 的函數“ ),,( ψji vueSmartMvCub ”。若 ),( vu 相對於ψ
12 
 
2.4.2 單變數對稱特徵值 
令 ix 為 f 的輸入， ix 在 f 中的單變數對稱(SVS)之特徵值為包含六個值的變數值
組 ),,,,,( 654321 pppppp 。其中 ip 的定義如下： 
z 1p ( 2p )： jx 只具有 ),( ji xxSV ( ),( ji xxSV )特性之數量； 
z 3p ： jx 同時具有 ),( ji xxSV 和 ),( ji xxSV 特性的數量； 
z 4p ( 5p )： jx 只具有 ),( ij xxSV ( )( , ij xxSV )特性之數量； 
z 6p ： jx 同時具有 ),( ij xxSV 和 )( , ij xxSV 特性之數量； 
我們現在來探討 S.V.對稱( ),( ji xxSV )，因為 jiji xxxx ff = ，可明顯地看出 ix 為函數
jx
f 之 non-support 輸入；同理也適用於不同之對稱上，所以我們可以導出 1p 和 2p 分別
等於
jx
f 和
jx
f 餘因子的數量，其中 ix 為 jxf 和 jxf 之 non-support 輸入，同時 4p 和 5p 分
別等於
jx
f 和
jx
f 之 non-support 輸入的數目。 
給定任意兩個不完全描述函數 )( Xf 和 )(Yg ，其中 Xxi ∈ 和 Yy j ∈ 。假設 f 之於 ix
的 SVS 特 徵 值 和 g 之 於 jy 的 SVS 特 徵 值 分 別 為 ),,,,,( 654321 pppppp 和
),,,,,( 654321 pppppp ′′′′′′ ，則 ix 可以對應至 jy (或 jy )的必要關係如下： 
z 3p = 3p′和 6p = 6p′； 
z 2121 pppp ′+′=+ ； 
14 
 
 
 
 
2.5 布林比對之 SAT 模型 
給定任意兩輸入集合 },...,{ ni xxX = 及 },...,{ ni yyY = ，我們定義集合V 為具有 22n
個輸入之布林變數集合來表示由 ix 到 jy (或 jy )的對應關係。對於每個變數
1, ,, =∈ jiji vVv 若 nj ≤ (或 nj > )則 ix 到 jy (或 njy − )的對應關係為真，若 0, =jiv 表示對
應失敗。 
 
圖 2.1 Partial-Mapping 之演算法 
16 
規則六和規則七可對每組 cube pair ),( vu 產生一個 clause，而規則八可保證兩目標
函數的一致性可以成立。 
18 
對成功，但是此方法在計算標準式時仍需大量的計算時間，目前有許多的研究重點都放
在如何將布林函數表示成一個標準式[17]。在邏輯合成(logic synthesis)應用方面，布林比
對技術常常被用在正規驗證以及技術映成上。 
 
3.1.2 布林滿足-Boolean Satisfiability (SAT) 
布林滿足問題的定義為：給定一個以 CNF (Conjunctive Normal Form)表示的布林
函數，希望能找出一組輸入變數的設定值使得這個函數的輸出為 1(SAT)，或是證明它
的輸出永遠為 0(UNSAT)。此技術常常使用在組合電路的相等驗證(CEC - Combinational 
Equivalence Checking) [18]上。所謂的 CEC，就是檢查給定的兩個組合電路的功能是否
相等，可用來驗證實作出來的組合電路是否與原本給定的規格書相等，或是驗證經由
邏輯合成後所產生出的新電路是否與原本的電路功能性相同。 
在近幾年來 SAT 解題之演算法有很大之改進 [22-25]，所使用之技術有
non-chronological backtracking [22]、conflict driven clause learning [22]、restarts [24]與
watch literals [24]等，目前較著名之 SAT 解題工具有 GRASP [22]、ZChaff [23]、SATO [24]
及 MiniSat [25]。 
3.1.3 And-Inverter Graph 
AIG(And-Inverter Graph) [13]是一種有方向性且非環式的圖形(DAG - Directed 
Acyclic Graph)，AIG 可以作為一個邏輯網路、邏輯函數或是邏輯電路其結構實作的方
式。如圖 3.2 所示，一個 AIG 由許多只有兩個輸入的節點所組成，這些節點代表的是
邏輯上的 AND。終端節點的標籤記錄著變數的名稱，節點與節點之間有邊(edge)相連，
每一條邊記錄邏輯正或負的屬性。 
要將一般的組合電路轉換成 AIG 時，只要將每一個邏輯閘改成使用 AND 閘以及
Inverter 表示，就可以快速的轉換成以 AIG 形式表示的網路。這樣的轉換並不會造成
e
d
cb
a
圖 3.2：AIG(And-Inverter Graph) 
20 
( )nix xxxff i ,,0,,1 LL == 。對於輸入集合 X 內的任意兩個輸入 ix 與 jx 的 cofactor，有
許多不同形式的相等關係，如表 3.1 所示，non-equivalence symmetry 其定義為
jiji xxxx
ff = ，表示法為 ),( ji xxNE ，而 equivalence symmetry (E)與 single variable symmetry 
(S.V.)的定義則為
jiji xxxx
ff = 與
jiji xxxx
ff = ，分別以 ),( ji xxE 與 ),( ji xxSV 表示。 
有了這些對稱資訊後，我們可以使用這些資訊來算出一些特徵值，再利用特徵值
來排除掉不可能的對應關係，以降低布林比對時的搜尋空間，進而減少所需要的執行
時間。相關之特徵值內容請參考[11]，以下僅將特徵值計算方法列出。 
(1) Equivalence & Non-Equivalence Symmetric(ENES) Signature 
給定一個函數 f(X)，對於每一個輸入 Xxi ∈ ，其 ENES 特徵值為一個具有三個數
值之值組(tuple)，表示為(p1, p2, p3)，每個數值分別如下所述： 
z p1(p2)：當只有 ),( ji xxE ( ),( ji xxNE )成立時 jx 的個數； 
z p3：當 ),( ji xxE 與 ),( ji xxNE 同時成立時 jx 的個數； 
對於每一個值組來說，若 p3 > 0，則 p1 = p2 = 0。當要比對函數 f(X)與 g(Y)時，假
設 Xxi ∈ 與 Yy j ∈ 之特徵值分別為(p1, p2, p3)以及 ),,( 321 ppp ′′′ ，則必須滿足 11 pp ′= ，
22 pp ′= 以及 33 pp ′= 這三個條件。 
(2) Single Variable Symmetric(SVS) Signature 
給定一個函數 f(X)，對於每一個輸入 Xxi ∈ ，其 SVS 特徵值為一個具有六個數值
之值組，表示為(p1, p2, p3, p4, p5, p6)，每個數值分別如下所述： 
z p1(p2)：當只有 ),( ji xxSV ( ),( ji xxSV )成立時 jx 的個數； 
z p3：當 ),( ji xxSV 與 ),( ji xxSV 同時成立時 jx 的個數； 
z p4(p5)：當只有 ),( ij xxSV ( ),( ij xxSV )成立時 jx 的個數； 
z p6：當 ),( ij xxSV 與 ),( ij xxSV 同時成立時 jx 的個數； 
當要比對函數 f(X)與 g(Y)時，假設 Xxi ∈ 與 Yy j ∈ 之特徵值分別為(p1, p2, p3, p4, p5, p6)
以及 ),,,,,( 654321 pppppp ′′′′′′ ，則必須滿足 6~1, =′= kpp kk 的條件。 
3.1.4.2 Unateness 特徵值 
給定一個布林函數 f(X)，對於每一個輸入 Xxi ∈ ，我們可以簡單的將 ix 歸類成四
個群組，分別是 positive unate、negative unate、binate、以及 non-support。當 ix 為 positive 
22 
在。 
在使用 SAT 檢查時，若所給定要檢查的函數特性 p 不存在，則 SAT 工具會回傳
true 並產生出一組 SAT 反例(counter examples)，也就是經由 SAT 檢查時所找到會違反
給定之函數特性 p 的 F 輸入向量。對於模擬來說，反例則是指可以移除掉不可能解的
輸入向量。 
若完全使用 SAT 解題工具來檢查時，不管結果是否驗證成功都需要花費較多的執
行時間，而對一個使用 AIG 來儲存的布林網路做功能模擬則是非常的快速，因此我們
可以將 SAT 與對函數做功能模擬搭配使用，使用模擬把不可能的狀況排除掉來節省使
用 SAT 驗證的次數，演算法如圖 3.3 所示，步驟說明如下： 
Algorithm Simulation-and-SAT (F, p) 
Input: F is a Boolean Network; 
p is the functional property to be checked; 
Output: S is the solution set with property p; 
Begin 
S = Φ;                       /* Initially, S is an empty set */  
Add all possible solutions into T;  /* T is the target set for SAT based 
checking */ 
Perform random simulation on F to remove impossible solutions in T; 
while (T≠Φ) do 
do 
Take a possible solution ti away from T; 
flag = SAT-Based-Checking (F, p, ti );    /* false, i.e., 
unsatisfiable */ 
if (flag is false) Add ti into S;  /* ti is a true solution with property 
p */ 
while (flag is false); 
Perform guided simulation based on the counter examples of SAT and 
remove impossible solutions in T; 
end while 
return S; 
End 
 
圖 3.3：以模擬為主搭配 SAT 之解題演算法 
24 
透過模擬來檢查並移除掉不可能的特性之後，由於只由模擬並無法確定這個特性
是否真的存在，所以我們必須搭配使用 SAT 技術來確認剩下的沒有被移除之狀況是否
真的成立，要使用 SAT 工具檢查 ix 是否為 positive unate 的時候所使用的原理為：
≡⊆
ii xx
ff ( )1=+
ii xx
ff ( )0=⋅≡
ii xx
ff ，因此，我們使用 SAT 工具來檢查
ii xx
ff ⋅ 是否有
解存在，若存在一組解則代表
ix
f 與
ix
f 有交集，也就是說 ix 為非 positive unate 的輸入；
若要使用 SAT 來檢查 ix 是否為 negative unate 輸入，檢查方法則改為： ixf 與 ixf 是否有
交集 ( )0=⋅
ii xx
ff 。 
在 3.2.1 節介紹的模擬步驟 4 中，我們把輸入向量修改為與目前所找到的反例距離
為 1 的輸入向量，如圖 3.5 所示，假設 P0 為所找到的反例，P1 則是由 P0 對第一個輸
入 x1 的值作反向後所產生出來，依此類推直到所有的輸入都處理過為止，因此會有 n
組的輸入向量，其目的是希望以此為搜尋的出發點藉此能夠快速地找到更多不可能存
在的特性，並將其移除以減少之後使用 SAT 檢查的次數。 
依照上述的這些步驟，我們可以快速的找出輸入 ix 的特性，最後所找出的結果會
1
0
1
0
ix
0
1
1
0
P1
P2
P3
P4
圖 3.4：以 ix 以及 }{ ixX − 來分組之 K-map
negative unate 特性不可能存在 
positive unate 特性不可能存在 
1  0}{ ixX −
1
1
1
0
.
1
1
1 
0 
1 
1 
. 
1 
1 
0 
0 
1 
0 
. 
0 
0 
1x 2x nx
1
1
1
1
.
1
0
…
P1 
P2 
Pn-1 
圖 3.5：模擬向量產生範例 
找到的反例 
產生的輸入向量集合 
1−nx
0
0
0
0
.
1
0
3x
Pn 
P0 
26 
以圖 3.6 為例，圖中在黑實線上之小圓點為一個反向閘(Inverter)，大圓點是一個
具有兩個輸入的 AND 閘，而橢圓形的點則是具有多個輸入的 AND 閘，也就是所謂的
supergate。我們可以將圖 3.6(a)的 AIG 轉換為使用圖 3.6 (b)的 supergates 來表示，以
S1 來說，其正的輸入群為{b, c, e}，負的輸入群為{a}，其他的輸入群則為{S2}。 
在圖 3.6 (b)中，我們觀察 S1，可知相同輸入群內的輸入可能存在有 NE 的對稱關
係，而不同輸入群組內的輸入則可能存在有 E 的對稱關係，也就是說 a 與 b、a 與 c
及 a 與 e 之間可能存在有 E 的對稱關係，而 b, c, e 之間則可能互相存在有 NE 的對稱
關係，因此我們可以對 implication supergate 作結構分析來找出一些對稱關係，詳細的
分析方法請參考[12]。 
(2) 模擬分析方法 
我們以一個範例來說明[12]原本提出的模擬方法，欲了解較詳細的步驟以及原理
說明，請參考[12]。在本論文中加入了對於 E 對稱的模擬向量檢查方法。 
範例 3.2： 給定 )(),,,( bccadabdcbaf ++= ，其 K-map 如圖 3.7(a)所示，模擬的步驟
為： 
1. 假設給定的模擬向量為 P = 1011； 
2. 將 P 複製四份後產生模擬的輸入向量矩陣，並將對角線的值反向，如圖 3.5(b)
所示； 
3. 以步驟 2 中所產生之輸入向量作模擬，可得到輸出結果為 R = 0110 (圖 3.7(a)
中圓圈處) 
(a) AIG           (b) Implication supergate
e 
d 
c b 
a
S1
S2
S3
a b
b
c
c
d
e
圖 3.6：AIG 以及 Implication supergate 
28 
經由上面所介紹新加入的 E 對稱結構分析方法、E 對稱的模擬分析方法以及新加
入的推導規則，我們可以快速的分析並同時找出函數中的 E&NE 對稱關係。 
 
3.2.3.2 Single Variable 對稱偵測 
給定一個函數 f(X)及 },,{ 1 nxxX L= ，對於任意兩個輸入 Xxx ji ∈, ，可能存在四種
single variable symmetry (S.V.)的對稱關係，分別是：
jiji xxxx
ff = 、
jiji xxxx
ff = 、
jiji xxxx
ff =
及
jiji xxxx
ff = 。以
jiji xxxx
ff = 為例，我們可以用 ),( ji xxSV 來表示其關係。由此可得當 ji xxf
與
ji xx
f 不相等時則 ),( ji xxSV 這組關係不存在。因此我們一樣可以使用模擬的方式，先
假設所有的對稱關係都存在，再依據輸入向量與模擬輸出結果來移除掉不可能的對稱
關係。 
範例 3.3：圖 3.8 為一個 SV 對稱檢查的範例，步驟如下： 
(1) 先隨機產生一組輸入向量 v1，將 xi反向得到輸入向量 v2，假設 v1 與 v2 如圖 3.7
所示。 
(2) 當模擬之輸出值不相等時，則 ),( 1xxSV i ， ),( 2xxSV i ，…， ),( ni xxSV 等對稱
性均不成立，可全部移除掉。                   ■ 
使用模擬去除不可能的對稱關係之後，我們必須使用 SAT 來驗證留下的 S.V.對稱
關係是否真的存在，以 ),( ji xxSV 為例，我們需要檢查 jiji xxxx ff = ，因此可以先產生 ji xxf
與
ji xx
f 兩個函數，再對這兩個函數使用 SAT 驗證技術來檢查是否相等，若找到一組解
則代表此對稱關係不存在。  
在本章說明了如何使用 S&S 來找出給定函數的一些輸入特性，這些特性可以用來
計算出此函數的特徵值，以提供給下一章的使用 S&S 的布林比對技術使用。 
 
3.3  以模擬與 SAT 為主之布林比對技術 
在本章節中，首先在第一節介紹我們使用的定義以及表示法，第二節則開始介紹
我們所提出的一個使用 S&S 技巧的布林比對演算法，而在模擬時所使用的三種不同的
輸入向量是如何產生以及用於比對上將在第三節中說明，第四節介紹我們所提出的以
1
0
1
0
ix
1 
1 
0
0
1x 2x nx
1
1… …
v1 
v2 
圖 3.8：Single variable symmetry 模擬範例 
 f
30 
Definition 3.6: Input Weight 
給定一個輸入集合 X 以及一個輸入向量 vi，我們把 vi中輸入值為 1 的輸入個數稱為輸
入權重(Input Weight)，以標記 ),( Xviρ 表示， ||),(0 XXvi ≤≤ ρ 。 
Definition 3.7: Output Weight 
給定一個函數 f(X) 及其一組輸入向量(Input Vector)集合 },,{ 1 mvvV L= ，對 f 作功能模
擬(functional simulation)後，其輸出結果為 1 的個數稱為輸出權重(Output Weight)，以
標記 ),( Vfσ 表示， mVf ≤≤ ),(0 σ 。 
範例 3.5: 給定一個布林函數 )()( 3231421 xxxxxxxXf ++= 及其輸入向量集合
},,,{ 4321 vvvvV = ，圖 3.9 所示為其 K-map 及模擬輸出向量 1010=O ，其輸入向量權重
41,3),( K== iXviρ ，而輸出向量權重 2),( =Vfσ 。                         ■ 
 
3.3.2 演算法說明 
到目前為止，並沒有任何使用模擬技巧的布林比對方法被提出來，因此我們希望
能夠藉由一些具有特殊性質之輸入向量，經過功能模擬後的輸出結果，來找出兩個函
數的輸入對應關係，最後以 SAT 驗證技術確認兩函數能夠比對成功。 
我們的方法主要分為三個階段，在第一個階段裡，首先使用第三章中所提出的函數特
性偵測方法對電路做分析，並使用第二章所提到的特徵值將函數做初步的比對，若在
這個階段裡無法完成比對時，則會進入第二個階段，也就是以模擬為主之比對方法。 
給 定 兩 個 布 林 函 數 f(X) 、 g(Y) 以 及 到 目 前 為 止 所 找 到 之 對 應 關 係
},,,,{ 1 cm GGGR LL= ，其中 mGG ~1 為非獨特對應群組，而 cm GG ~1+ 為獨特對應群組。
每一個輸入向量 cvvv ||1 L= ， cvv ~1 為 v 的部份輸入向量，分別對應到 kXX ~1 (或
 0  1  0  0
 0  1  1  1
 0  1  1  0
 0  1  0  0
00 01 11 10
00 
01 
11 
10 
x3x4  
圖 3.9：f(X)之 K-map、輸入向量集合V 及模擬之輸出向量 O 
    x1x2x3x4     O 
v1:  0 1 1 1    1 
v2:  1 0 1 1    0 
v3:  1 1 0 1    1 
v4:  1 1 1 0    0 
x1x2  
32 
經由功能模擬過後，我們可以根據其輸出值來將群組 iG 分割成兩個群組： 0iG 以
及 1iG ， 1iG 為模擬後輸出 1 的部分，而 0iG 為輸出 0 的部分；當兩個函數在比對時則函
數 f 輸出 1 的群組必需與函數 g 輸出 1 的群組作配對，輸出 0 的部份也是相同的做法，
若輸出的值剛好全部為 1 或是全部為 0 的時候則無法對 iG 做分割的動作。 
我們的方法可以同時處理多個群組，如圖 3.11 所示，圖中 mVV ~1 為針對 mGG ~1
所產生之輸入向量集合，其檢查步驟如下： 
1. 隨機產生 cGG ~1 的輸入向量 vi，再針對對應關係 R 內所有的非獨特對應群組
mGG ~1 ，產生 mVV ~1 之輸入向量集合，每一組 Vi可用來檢查並分割一個非獨特
對應群組 iG 。 
2. 模擬後依據 mVV ~1 各組的輸出結果將 mGG ~1 中的每一個對應群組切割成兩個部
份。 
範例 3.6： 給定兩個布林函數 f(X)、g(Y)，初始的輸入對應關係 },{ 21 GGR = ，其中
1
11
YXG = ， { }311 , xxX = ， { }321 , yyY = ， 222 YXG = ， { }422 , xxX = ， { }412 , yyY = ，當我
們要切割 G1 以及 G2 時，其 K-map，輸入向量集合 21 VVV ∪= 及模擬後之輸出向量
1110=fO 與 1101=gO ，如圖 3.12 所示。 
     A1   . . . . . . . . . . . . . .   Ai     . . . . . . . . . .   Ac 
  
     
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢
⎣
⎡
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢
⎣
⎡
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢
⎣
⎡
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢
⎣
⎡
c
c
v
v
or
v
v
MLLL
L
O
L
L
O
L
LLLM
1011
1101
0100
0010
1
1
 
1||),( −= ii GAvρ1),( =iAvρ
圖 3.10：可用來切割 Gi之 Type 1 模擬向量集合 
iV
          G1      Gi     Gm   Gc 
,,,~,,,,
,,,,,~,,
         
,,,,,,,~
1
1
1
cmi
cmi
cmi
vvvv
vvvv
vvvv
LLLLLL
M
LLLLLL
OM
LLLLLL
 
 
圖 3.11：多群組之模擬向量集合 
V1 
Vm 
34 
Type 2 模擬向量的產生方式，以群組 iYii XG = 為例作說明，對於 )( ii YX 中每個輸
入 )( jj yx 需要產生一組包含 1|| −iG 個向量的向量集合 Vj，而 Vj中的每一個向量代表輸
入 )( jj yx 與其他輸入 }{ jik xXx −∈ ( }{ jik yYy −∈ )的某種關係。如圖 3.13 所示，所產生
的 Vj 向量集合必須包含以輸入值 )1(1 == jj yx 為主，輸入權重為 2 的所有輸入向量集
合，或者以輸入值 )0(0 == jj yx 為主，輸入權重為 2|| −iG 的所有輸入向量集合。 
當 Vj產生之後，我們以 Vj為輸入模擬向量集合，對 f (g)做模擬後所得到之輸出
權重，即 ),( jVfσ ( ),( jVgσ )，代表輸入 )( jj yx 之特徵值。當兩個輸入具有不同之特徵
值(輸出權重)就可以將其切割置入不同的群組。除此之外，當某個輸入 )( jj yx 確定為獨
特輸入時，我們可以利用 Vj向量模擬後之結果，繼續將輸入集合 }{ ji xX − ( }{ ji yY − )切
割成兩個群組，分別代表輸出模擬結果為 1 和 0 的群組，我們以範例 3.7 說明以上步
驟。 
範例 3.7： 給定兩個布林函數 f(X)、g(Y)與初始的輸入對應關係 },{ 21 GGR = ，假設
 Vj : 
(m-1) 
2),( =iXvρ 2),( −= mXv iρ
xj   Xi – {xj}         xj   Xi - {xj} 
1 100000…0   0 011111…1 
or 
1 0…000001   0 1…111110 
 
 
圖 3.13：Vj之 Type 2 模擬輸入向量 
x1x2x3  x4                     Output Weight 
y2y3y4  y1     Of  Og 
1 1 0  1     0  1    0),( 1 =Vfσ ， 1),( 1 =Vgσ   x1、y2 
1 0 1  1     0  0     
0 1 1  1     1  0    1),( 2 =Vfσ ， 0),( 2 =Vgσ  x2、y3 
1 1 0  1     0  0     
0 1 1  1     0  0    0),( 3 =Vfσ ， 0),( 3 =Vgσ  x3、y4 
1 0 1  1     0  0     
V1 
 
V2 
 
V3 
圖 3.14：範例 3.7 之模擬輸入、輸出向量以及輸出權重 
36 
將欲作切割的 NE 群組之輸入權重做一些調整，使其與其他的 NE 群組不同，而其他
的對應群組 jG 則產生權重為 0 或 || jG 的輸入向量。 
假設非獨特對應群組 Gi內有 e 個尺寸為 m 的 NE 對稱群，則需要有 e 個輸入向
量。產生這種模擬向量的做法如圖 3.15 所示，圖中的 v1 ~ ve為用來區分這 e 個相同尺
寸的 NE 對稱群之輸入向量，S1 ~ Se代表 )( ii YX 內的 NE 對稱群，而 w1 與 w2 代表 2 種
具有不同輸入權重的輸入向量，其中 mSw i ≤≤ ),(0 1ρ ， mSw j ≤≤ ),(0 2ρ ，且
),(),( 21 ji SwSw ρρ ≠ 當 ji ≠ 時。 
作完功能模擬後，依據模擬輸出之結果可以將這 e 個 NE 群組切割成兩部份，分
別是函數輸出值為 1 的 NE 群組，與函數輸出值為 0 的 NE 群組，我們以範例 4.5 來說
明。 
範例 3.8： 給定兩個布林函數 f(X)與 g(Y)，及其初始的輸入對應關係 },{ 21 GGR = ，假
設 111 YXG = 及 222 YXG = ， 其 中 },,,,,{ 7653211 xxxxxxX = ， },{ 842 xxX = ，
},,,,,{ 7654321 yyyyyyY = 及 },{ 812 yyY = ，X1 中有三個尺寸為 2 的 NE 對稱群{x1, x2}、{x3, 
x5}與{x6, x7}，而 Y1 中有三個 NE 對稱群{y2, y3}、{y4, y5}與{y6, y7}，圖 3.16 所示為一
組輸入模擬向量及其輸出模擬結果，輸入模擬向量產生方式如下，我們先將所有的對
稱群輸入向量設為 01(輸入權重為 1)後，再將每個欲檢查之對稱群的輸入向量設成
11(輸入權重為 2)。 
根據模擬輸出結果，我們可將輸出相同的對稱群放入同一個群組，因此可以將
X1 分割成輸出為 0 的群組 },{~ 211 xxX = ，以及輸出為 1 的群組 },,,{~ 76532 xxxxX = ；同理，
1Y 也可被分成兩個群組，分別是 },{
~
541 yyY = 以及 },,,{~ 76322 yyyyY = ，所以新產生的對
應關係為 }~,~,~{ 321 GGGR = ，其中 1
~
11
~~ YXG = ， 2~22 ~~ yXG = 及 23~ GG = ，而且 1~G 已成為獨特對
應群組。                                                                 ■ 
介紹完所使用的三種模擬向量以後，在下一節裡我們將說明使用的布林比對演算
法其運作的方式，以及整個比對的流程。 
 
 
x1x2  x3x5  x6x7  x4 x8        Output 
y2y3  y4 y5  y6 y7  y1 y8      Of  Og 
1 1  0 1  0 1    1 1     0  1    
0 1  1 1  0 1    1 1     1  0 
0 1  0 1  1 1    1 1      1  1 
v1 
v2 
v3 
圖 3.16：範例 3.8 之模擬輸入以及輸出向量 
38 
當到達給定的 Threshold，或者是已經到達最大可分割的群組 MaxSize 時，則結束
整個以模擬來比對的過程。若跳出迴圈時，函數之輸入對應關係已經被確定，我們就
使用 SAT 技術來驗證找到的輸入對應關係是否真的存在，SAT 驗證的方法為：依照所
找到的輸入對應關係 π，檢查 f(π(X))與 g(Y)是否相等。如果相等代表所找到的輸入對
應關係 π是合法正確的；而不相等則代表 π是一個不合法的對應關係。 
當純粹使用功能模擬且在既定的 Threshold 下無法找到確定的對應關係時，我們
Algorithm S&S-Boolean-Matching ( f(X), g(Y), Threshold ) 
Input: f and g are two functions to be matched; 
     Threshold is the maximum number of simulation round; 
Output: π is the mapping relation of f and g. 
Begin 
count = 0; 
R = Initial-Mapping (f, g);               // Stage 1 
MaxSize = #NE classes + #Non symm. inputs. 
while ( |R| <MaxSize and count < Threshold ) do      // Stage 2 
    NewR = Simulate-And-Update ( f, g, R ); 
    if ( NewR is Φ )    return Φ;  
    if ( |R| == |NewR| )   then  
        count++; 
    else           
        count = 0; 
        R = NewR; 
    endif 
endwhile  
if ( |R| < MaxSize )   then 
    π = Recursive-Matching (f, g, R, MaxSize);    // Stage 3 
else 
    π = R; 
    Verify π by SAT-based equivalence checking; 
endif 
return π; 
End 
 
圖 3.17：以模擬為主搭配 SAT 驗證之布林比對方法 
40 
若只想要找出一組確定的對應關係，則可修改成只要遞迴時有回傳一組對應關係
時，則直接回傳這組對應關係即可，在這裡我們使用了一個簡單的經驗法則來加速找
第一組對應關係的時間，方法為：首先對 G 能產生的所有可能對應關係 ri模擬一次後，
再依據模擬後所產生的群組數對這些可能的對應關係做排序，之後從能夠產生最大群
組數的 ri先挑，因此可以加快找第一組對應關係的時間。 
 
Algorithm Recursive-Matching (f(X), g(Y), R, Max) 
Input: f and g are two functions to be matched; 
R is the current mapping relation; 
Max is the maximum size of mapping relation; 
Output: π is the mapping relation of f and g. 
Begin 
if ( |R| == max ) then 
    if ( SAT-Verify( f, g, R ) is true )  return R; 
    return Φ; 
endif  
π = Φ; 
Gi = the smallest non-unique mapping group in R; 
tmpR = R - {Gi} 
for each possible mapping relation ri for Gi  do 
    NewR = Simulate-And-Update ( f, g, tmpR∪ri )  
    if ( NewR ≠Φ ) then 
        π = Recursive-Matching( f, g, NewR, Max ); 
    endif 
    // if we only need one mapping result, uncomment the following line;
    // if (π ≠  Φ )  return π 
endfor 
return π; 
End 
 
圖 3.18：搭配 SAT 驗證之遞迴式布林比對方法 
42 
會很容易導致模擬時因為模擬的廣度不夠而無法繼續對群組作切割，變成要靠第二階
段的遞迴式演算法來繼續比對，因而增加了使用 SAT 工具來驗證的次數。 
3.3.5.3 降低模擬時間 
為了要降低模擬時所需之時間，我們在模擬前會先找出與所有非獨特對應群組有
關聯之主要輸出(dependent primary outputs)，並根據這些輸出來找出所有的相關主要輸
入(dependent primary inputs)，在產生輸入向量時，只給定這些相關輸入節點的模擬向
量值，對於其他無關的輸入則不產生，因此可以降低產生輸入模擬向量的時間。除此
之外，在作功能模擬時則只對與這些主要輸入有關之節點(transitive fanouts)作模擬，
因此可以減少功能模擬時所花費的時間，當使用遞迴式比對時，由於非獨特對應群組
的數量非常少，所以此方法對於遞迴式比對時有很好的效果。 
 
44 
 
 
第二組實驗測試了 Learn 演算法對於不完全描述函數與使用特徵值的表現。由於
篇幅限制，表 4.2 只顯示了 15 組電路的測試結果。平均而言，相對於移除 10%、20%
和 40% cube 數目之電路其有效 cube pairs 數的比例分別為 0.09%、0.10%和 0.12%。
表 6.2 中 10%(no)一欄，顯示了移除 10% cube 且不使用特徵值方法的實驗數據。由實
驗數據顯示，15 組電路中有 3 組在不使用特徵值方法和 1 組在移除 40% cube 的情況
下沒有辦法於 5000 秒內完成。移除 10%、20%和 40% cube 之組別和不使用特徵值方
法的執行時間比率分別為 6.37%、5.75%和 47.46%，由以上可看出使用特徵值方法可
以大幅提升比對效率。 
圖 4.1 以 SAT 討論完全描述函數
表 4.2 不完全描述函數之實驗數據
46 
4.2 以模擬與 SAT 為主可處理大型布林網絡之布林比
對技術 
 
4.2.1 實驗環境 
我們實驗所使用的硬體平台為 64 位元架構的主機，具有兩個四核心的 Intel Xeon 
5450 3.0 GHz 處理器、以及 16 GB 的系統記憶體，使用的作業系統為 Linux CentOS 5.0 
x86_64，軟體平台則是使用 UC Berkeley 的邏輯合成工具 ABC [20]。ABC 使用 C 語言
為主要開發的程式語言，由於 ABC 對於 64 位元環境的支援度不足，有部分的命令會
有出錯的可能性，在本實驗中我們已經找出 ABC 系統中對於 64 位元的錯誤並且加以
修正，並將本論文中所提到的各種以 S&S 為基礎的方法實作出來且已整合入 ABC 系
統內。 
實驗中使用的 benchmark 為 MCNC 以及 ISCAS 這個兩在邏輯合成領域中最常被
使用的測試組合，其中包含了一些序向電路，因此在處理這類型的電路時我們會使用
ABC 內的 comb 指令將序向電路中的組合電路部份抽取出來做實驗。為了使實驗順利
的進行，我們先使用一個 script 檔案如圖 4.3 所示，將輸入的函數 f 經過一些邏輯合成
的步驟將 AIG 化簡，經由隨機改變其輸入順序產生出一個新的函數 g 後，再使用我們
所提出的布林比對方法來做實驗，因此可以確保至少有一組的對應關係存在。 
 
 
 
 
strash
rr 
resub 
refactor 
rewrite 
rr 
resub 
rewrite 
refactor 
rr  
resub 
rewrite 
圖 4.3：Script 檔案內容 
48 
 
(2) E & NE Symmetries 
測試電路的 E&NE 對稱資訊偵測結果如表 4.4 所示，其中之欄位#E 與#NE 分別
代表這些電路中所包含之平均 E 對稱以及 NE 對稱的數量，其餘的欄位則與表 4.3 相
同。由實驗結果來看，在輸入數為 31~40 的群組中，C6288 這個測試電路整體的偵測
時間為 996.10 秒，其中花費在使用 SAT 驗證對稱情形時所花費的時間太長(993.10 秒)，
對於其他的測試電路而言我們所使用的對稱偵測方法所花費的時間皆非常短，而且這
些電路中所包含的對稱資訊量也很多，所以我們可以使用這些函數輸入的 E 對稱以及
NE 對稱資訊來加速布林比對的過程。 
 
(3) Single Variable Symmetries 
測試電路的 single variable 對稱資訊偵測結果如表 4.5 所示，其中之#Pos 與#Neg
欄位分別是這些電路中所包含之平均 ),( ji xxSV 以及 ),( ji xxSV 對稱的數量，其餘的欄位
表 4.4：測試電路之 E 與 NE 對稱情形與偵測時間 
Average Time(sec.) 
#Input #Circuit #Solved
#E #NE Min. Avg. Max. 
1~10 31 31 21 32 0.00 0.02 0.12 
11~20 21 21 37 76 0.00 0.88 17.61 
21~30 14 14 250 292 0.00 0.05 0.36 
31~40 10 10 35 122 0.00 99.83 996.90 
41~50 8 8 106 145 0.01 0.38 0.75 
51~257 28 28 476 2287 0.04 1.28 12.65 
表 4.5：測試電路之 single variable 對稱情形與偵測時間 
Average Time(sec.) 
#Input #Circuit #Solved
#Pos. #Neg. Min. Avg. Max. 
1~10 31 31 63 46 0.00 0.02 0.18 
11~20 21 21 327 177 0.00 0.50 8.06 
21~30 14 14 862 849 0.02 0.42 4.57 
31~40 10 10 351 165 0.02 7.80 74.28 
41~50 8 8 1221 1017 0.06 1.28 2.51 
51~257 28 28 5812 2391 0.13 9.12 81.47 
50 
外的測試電路在 71 秒內都可以完成比對，有部分的測試電路雖然需要花費額外的時間
計算 single variable 特徵值，但是卻可以藉由 single variable 特徵值的資訊直接完成函
數的比對過程，由此可看出我們的布林比對方法非常有效率的，且特徵值也發揮了加
速比對的作用，而經過 E&NE 對稱特徵值比對後若存在有一組以上的對應關係時，代
表電路中含有 G-Symmetry [9]的關係。 
52 
使其變成 500，5000 及 10000 後再重新執行比對，由於 Threshold 改變因此模擬的次
數也會因此改變，在布林空間裡被測試到的輸入向量點也就會增加，我們希望能夠藉
由較多次的模擬來改善整體的比對時間，實驗結果如表 4.8 所示，第一欄列出測試之
電路名稱，第二~四欄則分別為在不同的 Threshold 下使用 ENE 對稱特徵值與 unateness
特性做比對所需之時間，我們以 Threshold=1000 為比較的基準，由實驗結果可看出，
當模擬的次數越多時，對於少數的測試電路可以有較好的改進效果，但是對於其他的
測試電路，由於模擬也需要耗費時間，因而導致比對的時間變長，i2 就是一個很明顯
的例子，若只考慮對稱以及輸入之 unateness 特性，當模擬次數增加 10 倍時，則 i2 的
比對時間變為 4.54 倍，由此可見模擬次數對於比對時間的影響是非常大的。 
表 4.9 展示出我們的布林比對演算法找出第一組解時所需要的時間，第四大欄中，
Orig.、+Supp、+UB、+Symm 與+SVS 這四個欄位分別為不使用任何特徵值、加上考
慮函數之 support 資訊、加上考慮 binate 與 unate 資訊、加上考慮 ENE 對稱特徵值與
再加上 SVS 特徵值所需之布林比對找第一組解所花費的時間，這些是逐層累加的，而
時間的總和及平均皆不包含超過 5000 秒的案例，由結果可知，在不使用 ENE 對稱特
徵值的情況下總共有 2 個案例無法被解出，若考慮 ENE 對稱資訊則全部的案例皆可以
在 31 秒內解出。在 2 個無法被解出的案例中，C2670 我們只要增加 Threshold 為 5000
後即可在 34 秒內完成比對，而 i4 使用 SVS 資訊以後 
 
 
表 4.8：改變 Threshold 後布林比對執行時間之比較 
Threshold Circuit 
500 1000 5000 10000 
C7552 30.47 27.91 26.62 29.77 
dalu 7.74 7.39 7.59 7.67 
i2 3.88 5.19 15.43 28.14 
i10 31.70 30.63 32.66 32.77 
pair 4.70 4.69 4.68 4.70 
Total 78.49 75.81 86.98 103.05 
Average 15.70 15.16 17.40 20.61 
Normalize 103.54% 100.00% 114.73% 135.93% 
 
54 
接下來我們以 C7552 為例，使用所有的特徵值來作布林比對，我們藉由改變
Threshold 臨界值後來觀察臨界值與比對時間的關係，其結果如圖 4.4 所示，x 軸為給
定之不同的臨界值，而 y 軸為布林比對所需的時間，由實驗結果可知，當臨界值給的
太小時，則可能在第一階段使用模擬來比對時即無法繼續切割，以致於第二階段使用
遞迴式比對演算法的時間大幅增加，因此 SAT 驗證次數也會增加，若臨界值給的較大，
則會增加模擬所需的時間，其增加的幅度則視函數的複雜度而定。 
表 4.10 為使用特徵值之布林比對比較，第一列#Circuit 中，第一欄+Unate、第二
欄+Symm 與第三欄+SVS 分別代表使用了 unate 特徵值、加上 E&NE 特徵值後以及再
加上 single variable 特徵值後能解出的電路數量，第四欄則是使用特徵值無法完全切開
時，在第一階段的模擬就可找出對應關係的電路數，最後一欄則是使 
 
 
圖 4.4：C7552 根據不同 Threshold 之比對時間比較 
表 4.10：使用特徵值於布林比對之比較 
 +Unate +Symm +SVS +Sim. +Rec. 
#Circuit 19 49 71 94 109 
#Inc. 19 30 22 23 15 
% 17.43% 44.95% 65.14% 86.24% 100.00% 
56 
(2) s 系列電路之布林比對結果 
為了測試更大型的布林函數，我們也使用了 ISCAS 的序向電路，其命名是以 s 為
開頭，針對這些電路，我們使用 ABC 系統中的 comb 指令先將電路轉換成組合電路後
再做比對，測試結果顯示所有的電路都可以成功地完成比對，我們只擷取其中找第一
組解時所需之時間較大的 10 個測試電路，表 4.11 為這些電路之輸入輸出數目以及整
體 NE 對稱的情形，欄位 Symmetry，我們以 s4863 為例，( 1(8), 1(9) )代表電路中含有
1 組尺寸為 8 的對稱群及 1 組尺寸為 9 的對稱群，而符號-代表不存在任何 NE 對稱關
係。 
這些電路的布林比對實驗結果如表 4.12 所示，第四欄 Orig.為不考慮任何特徵值
的比對時間，第五欄+Symm 為增加考慮 ENE 對稱以及 unateness 特性後的比對時間，
第六欄+SVS 則是再增加考慮 SVS 對稱後所需的比對時間，其中 First 與 All 分別代表
找第一組解與找全部解所需的比對時間。由表 4.3 的實驗結果可知，在不考慮對稱的
情形下有 3 個案例無法完成比對，而且總共有 6 個案例無法找出所有的解，在加入了
ENE 特徵值之後則全部的案例都可以找出對應關係。 
 
表 4.12：s 系列電路之布林比對結果 
#Sol Orig. +Symm +SVS 
Circuit Orig. Symm. First All First All First All 
s4863 - 4 * * 4.78 4.79 12.03 12.04 
s3384 - 1 40.29 * 5.02 5.02 5.34 5.34 
s5378 - 1 17.50 * 5.35 5.35 24.37 24.37 
s938 1 1 8.10 18.31 6.73 14.99 9.06 9.06 
s838.1 1 1 8.24 18.60 7.44 15.27 8.97 8.97 
s6669 - 4 230.52 * 14.29 54.26 57.05 72.50 
s9234.1 1 1 95.75 95.75 19.09 19.09 66.36 66.36 
s838 1 1 67.40 144.33 580.94 1037.24 2.41 2.41 
s38584.1 - 1 * * 600.08 600.08 2208.38 2208.38 
s38417 - 1 * * 1381.98 1381.98 4936.96 4936.96 
Total    >15467.80 >30276.99 2625.70 3138.07 7330.93 7346.39 
Average     >1546.78 >3027.70 262.57 313.81 733.09 734.64 
*：CPU time > 5000 sec.        -：解的數目未知 
58 
 
 
第五章 結論 
5.1 漸進式比對 
 本報告提出以漸進式學習為主的布林比對技術，我們的技術不只可以處理完全描
述函數也能處理不完全描述函數。學習式比對演算法可以在比對過程中有效偵測並移
除多餘的運算，除此之外，我們也提出了以 SAT 為主的布林比對技術。由實驗結果證
明，我們所提出的漸進式學習和以 SAT 為主之比對演算法可以很有效地解決布林比對
問題。 
 
5.2  以模擬與 SAT 為主可處理大型布林網絡之布林比對技術 
本論文提出只考慮輸入排列(input permutation)的布林比對演算法，我們的方法以
模擬及布林滿足(Simulation and SAT)技術為主，其中包含了函數 unateness 特性及函數
對稱性之偵測，三種不同類型之輸入模擬向量產生及比對方法與遞迴式的布林比對方
法，我們已實作出這個比對演算法並且已經整合到由 UC Berkeley 所開發的邏輯合成
工具 ABC 中。在實驗中，我們測試了 MCNC 及 ISCAS 之電路，由實驗結果中，可以
證明我們所提出的布林函數輸入特性偵測方法以及布林比對方法都是有效且非常快速
的，對於大部分的案例都能夠在極短的時間內成功完成比對。 
目前本論文所提出的比對方法對於含有輸入相設定(input phase assignment)變化
的布林函數依然無法處理，若要比對含有輸入相設定變化的布林函數時，則可以使用
函數的特徵值再搭配含有漸進式學習技巧的 SAT 解題工具來完成，這個部份將是我們
未來努力的目標；另外，在模擬時隨機輸入向量的產生方式，也會影響對函數作功能
模擬所需要的次數，進而影響布林比對時所需的時間，因此，要如何隨機產生有效的
輸入向量也是未來可以探討的方向。
60 
non-separable RTL controller-datapath circuits,”  IEEE Transactions on 
Computer-Aided Design, Vol. 25,  No. 3,  pp.544-557 March 2006. 
[12] Feng Lu; Wang, L.-C., Cheng, K.-T, Moondanos, J. Hanna, Z.; “A Signal Correlation 
Guided ATPG Solver and Its Applications for Solving Difficult Industrial Cases,” in 
Proc. of Design Automation Conference, pp. 436-441, June 2003. 
[13] Gizdarski, E.; Fujiwara, H, “SPIRIT: a Highly Robust Combinational Test Generation 
Algorithm,” IEEE Transactions on Computer-Aided Design, Vol. 21,  No. 
12,  pp.1446-1458, March 2006. 
[14] K. Chandrasekar, and M.S. Hsiao, “Integration of Learning Techniques into 
Incremental Satisfiability for Efficient Path-Delay Fault Test Generation,” in Proc. of 
the Design and Test in Europe Conference (DATE-05), pp. 1002 -1007, 2005. 
[15] C.-A. Chen and S. K. Gupta, “A Satisifability-Based Test Generator for Path Delay 
Faults in Combinational Circuits,” in Proc. of the Design Automation Conference, pp. 
209-214, June, 1996. 
[16] Joonyoung Kim, Whittemore, J.,  Marques-Silva, J.P., and  Sakallah, K., “On 
Applying Incremental Satisfiability to Delay Fault Testing”, in Proc. of the Design and 
Test in Europe Conference (DATE-00), pp. 380 – 384, March 2000. 
[17] L. A. Entrena and K.-T. Cheng, “Sequential Logic Optimization by Redundancy 
Addition and Removal, “ in Proc. of the International Conference on 
Computer-Aided-Design, pp. 310–315, Nov. 1993. 
[18] L. A. Entrena and K.-T. Cheng, “Combinational and Sequential Logic Optimization by 
Redundancy Addition and Removal,” IEEE Transactions on Computer-Aided Design, 
Vol. 14, No. 7, pp. 909-916, July 1995. 
[19] J. Kim, J. Marques-Silva, H. Savoj and K. A., Sakallah, “RID-GRASP: Redundancy 
Identification and Removal Using GRASP,” in International Workshop on Logic 
Synthesis, May 1997. 
[20] Radecka, K.R.; Zilic, Z., “Identifying Redundant Gate Replacements in Verification by 
Error Modeling”, in Proc. of Test Conference, pp. 803-812, Nov. 2001. 
[21] W. Kunz and D. Stoffel, Reasoning in Boolean Networks, Kluwer Academic Publishers, 
1997. 
[22] Guanghui Li; Xiaowei Li, “Circuit-Width Based Heuristic for Boolean Reasoning” in 
Internaional Test Symposium, pp. 336-341, Nov. 2004. 
[23] Kuehlmann, A., Ganai, M.K., Paruthi, V., “Circuit-based Boolean Reasoning,” in Porc. 
Of Design Automation Conference, pp. 232-237, 2001 
62 
243-248, Jan. 2003. 
[36] Cabodi, G.,  Nocco, S and  Quer, S., “Improving SAT-based Bounded Model 
Checking by Means of BDD-based Approximate Traversals, “ in Proc. of the Design 
and Test in Europe Conference (DATE-03), pp. 898-903,  2003. 
[37] Liang Zhang, Prasad, M.R., and  Hsiao, M.S. “Incremental Deductive & Inductive 
Reasoning for SAT-based Bounded Model Checking,” in Proc. of International 
Conference on Computer-Aided-Design (ICCAD-04), pp.502-509, Nov. 2004. 
[38] Ganai, M.K., Gupta, A. and Ashar, P., “Beyond Safety: Customized SAT-based Model 
Checking,” in Porc. Of Design Automation Conference, pp.738–743, June 2005. 
[39] Cabodi, G.; Camurati, P. and Quer, S., “Can BDDs compete with SAT solvers on 
Bounded Model Checking?,” in Proc. of Design Automation Conference, pp. 117-122, 
June 2002. 
[40] Katz, J.; Hanna, Z.; Dershowitz, N., “Space-Efficient Bounded Model Checking,” in 
Proc. of the Design and Test in Europe Conference (DATE-05), pp. 686-687, 2005. 
[41] Sapra, S.; Theobald, M.; Clarke, E., “SAT-Based Algorithms for Logic Minimization,” 
in Proc. of International Conference on Computer Design, pp. 510-517, Oct. 2003.  
[42] Qi Zhu; Kitchen, N.; Kuehlmann, A.; Sangiovanni-Vincentelli, A., “SAT Sweeping 
with Local Observability Don't-cares,” in Proc of Design Automation Conference, pp. 
229-234, July 2006. 
[43] Mishchenko, A.; Zhang, J.S.; Sinha, S.; Burch, J.R.; Brayton, R.; Chrzanowska-Jeske, 
M.;, “Using Simulation and Satisfiability to Compute Flexibilities in Boolean 
Networks,” IEEE Transactions on Computer-Aided Design, Vol. 25, No. 5, pp. 
743-755, May 2006. 
[44] A. Smith, A. Veneris, M. F. Ali, and A. Viglas, “Fault Diagnosis and Logic Debugging 
Using Boolean Satisfiability,” IEEE Transactions on Computer-Aided Design, Vol. 24, 
No. 10, pp. 1606-1621, Oct. 2005. 
[45] J. S. Zhang, A. Mishchenko, R. Brayton, and M. Chrzanowska-Jeske,”Symmetry 
Detection for Large Boolean Functions using Circuit Representaiton, Simulation, and 
Staisfiability,” in Proc. of Design Automation Conference, pp. 510-515, July 2006.  
[46] Aloul, F.A.; Sagahyroon, A., “Estimation of The Weighted Maximum Switching 
Activity in Combinational CMOS Circuits,” in Proc. of International Symposium on 
Circuits and Systems (ISCAS-06), May 2006. 
[47] Nakamura, K.; Maruoka, S.; Kimura, S.; Watanbe, K., “Multi-Clock Path Analysis 
Using Propositional Satisfiability,” in Proc. of the Asia and South Pacific Design 
64 
[60] Zhihong Zeng; Kalla, P.; Ciesielski, M., “LPSAT: A Unified Approach to RTL 
Satisfiability,” in Proc. of the Design and Test in Europe Conference (DATE-01), pp. 
398-402, March 2001.  
[61] Abdollahi, A.; Fallah, F.; Pedram, M., “Leakage Current Reduction in CMOS VLSI 
Circuits by Input Vector Control,” IEEE Transactions on Very Large Scale Integration 
(VLSI) Systems, Vol. 12, No. 2, pp. 140-154, Feb. 2004. 
[62] P. Chen and K. Keutzer, “Towards True Crosstalk Noise Analysis,” in Proc. of the 
International Conference on Compuer-Aided-Design, pp. 132-137, Nov. 1999. 
[63] Wong, J.L.; Gang Qu; Potkonjak, M., “Optimization-Intensive Watermarking 
Techniques for Decision Problems,” IEEE Transactions on Computer-Aided Design, 
Vol. 23, No. 1, pp. 19-127, Jan. 2004. 
[64] Wong, J.L.; Majumdar, R.; Potkonjak, M., “Fair Watermarking Using Combinatorial 
Isolation Lemmas,” IEEE Transactions on Computer-Aided Design, Vol. 23, No. 11, 
pp. 1566-1574, Nov.  2004. 
[65] P. McGeer, A. Saldanha, P. R. Stephan, R. K. Brayton and A. L. 
Sangiovanni-Vincentelli, “Timing Analysis and Delay-Test Generation Using Path 
Recursive Functions,”in Proc. of the International Conference on 
Computer-Aided-Design, Nov. 1991 
[66] L. G. Silva, J. P. Marques-Silva, L. M. Silveira and K. A. Sakallah, “Satisfiability 
Models and Algorithms for Circuit Delay Computation,” in Workshop on Timing 
Issues in the Specification and Synthesis of Digital Systems, Dec. 1997. 
[67] Kukimoto, Y.; Gosti, W.; Saldanha, A.; Brayton, R.K., “Approximate timing analysis 
of combinational circuits under the XBDO model,” in Proc. of International 
Conference on Computer-Aided-Design (ICCAD-97), pp. 176-181, Nov. 1997. 
[68] F. Mailhot and G. De Micheli. “Technology Mapping Using Boolean Matching and 
Don't care Sets,” in Proc. of  European Design Automation Conerence, pp. 212-216, 
1990. 
[69] H. Savoj, M. J. Silva, R K. Brayton, and A. Sangiovanni-Vincentelli, “Boolean 
Mathcing in Logic Synthesis,” in  Proc. of  European Design Automation Conerenc. 
pp. 168-174,1992. 
[70] U. Hinsberger and R. Koll, “Boolean Matching for Large Libraries.” in Proc. of Design 
Automation Confernece., pp. 206-211,1998. 
[71] J. Cong and Y.-Y. Hwang., ”Boolean Matching for LUT-based Logic Blocks with 
Applications to Architecture Evaluation and Technology Mapping,” IEEE Trans. 
66 
[85] A. Mishchenko, S. Chatterjee, R. Brayton, and N. Een, “Improvements to 
Combinational Equivalence Checking,” in Proc. of International Conference on 
Computer-Aided-Design, Nov. 2006. 
[86] G.  Li,  M. Shao, and X. Li , “Design Error Diagnosis Based on Verification 
Techniques,” in Porc. of Asian Test Symposium (ATS-2003), pp. 474-477, Nov. 2003. 
[87] S. Safarpour, A.. Veneris, G. Baeckler, R. Yuan, “Efficient SAT-based Boolean 
Matching for FPGA Technology Mapping,” in Proc. of Design Automation Conference, 
pp.466-471, July 2006. 
[88] J. Zhang, S. Sinha, A. Mishchenko, R. Brayton, and M. Chrzanowska-Jeske, 
"Simulation and Satisfiability in Logic Synthesis", in Proc. of  IWLS '05. 
[89] S. Plaza, K. Chang, I. Markov, and V. Bertacco, “Node Mergers in the Presence of 
Don’t Cares,” to appear in Proc. of Asia and South Pacific Design Automation 
Conference (ASP-DAC-07), Jan. 2007. 
[90] Y-S. Yang, S. Sinha, A. Veneris, and R. K. Brayton, “Automating Logic Rectification 
by Approximating SPFDs,” to appear in Proc. of Asia and South Pacific Design 
Automation Conference (ASP-DAC-07), Jan. 2007. 
[91] P. H. Ho, T. Shiple,  K. Harer,  J.  Kukula, R. Damiano,  V. Bertacco,  J. Taylor, and 
Jiang Long , “Smart Simulation Using Collaborative Formal and Simulation Engines,” 
in Proc. of International Conference on Computer-Aided-Design, pp. 120-126, Nov. 
2000. 
[92] S. Yamashita, H. Sawada, and  A. Nagoyam “SPFD: A New Method to Express 
Functional Flexibility,” IEEE Transaction on Computer-Aided-Design of Integrated 
Circuits and Systems, Vol. 19,  No. 8., pp. 840-849, Aug. 2000. 
[93] A. Mishchenko, S. Chatterjee, R. Jiang, and R. K. Brayton, “FRAIGS: A Unifying 
Representation for Logic Synthesis and Verification,” ERL Technical Report, EECS 
Dept., UC Berkeley, March 2005. 
[94] R. Bryant, “Graph Based Algorithm for Boolean Function Manipulation,” IEEE 
Transactions on Computers, pages C-35(8):667-691, 1986. 
[95] E. Sentovich, et al, “SIS: A System for Sequential Circuit Synthesis,” Tech. Report. 
UCB/ERI, M92/41, ERL, Dept. of CSIE, Univ. of California, Berkeley, 1992.  
[96] Z. Fu, and S. Malik, “Solving the Minimum-Cost Satisfiability Problem Using SAT 
Based Branch-and-Bound Search,” in Proc. of International Conference on 
Computer-Aided-Design, Nov. 2006. 
[97] F. A. Aloul, K. A. Sakallah, and I. L. Markov, “Efficient Symmetry Breaking for 
