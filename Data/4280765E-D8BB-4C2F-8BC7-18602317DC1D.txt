ii  
Content 
Content..........................................................................................................................ii 
Content of Tables.........................................................................................................iv 
Content of Figures........................................................................................................v 
Abstract.........................................................................................................................1 
Part I: Hybrid Algorithm for Minimizing Total Cost of the Resource Constrained 
Project Scheduling Problem Subject to a Deadline ..................................................2 
Part I abstract .........................................................................................................2 
1. Introduction........................................................................................................3 
2. Problem description ...........................................................................................4 
2.2 Problem definition ...................................................................................5 
3. Problem solving method ....................................................................................6 
3.1 BBMA algorithm .....................................................................................7 
3.2 BBMABB Algorithm...............................................................................9 
4. Experimental results...........................................................................................9 
4.1 Generation of benchmark instances .........................................................9 
4.2 Numerical results .....................................................................................9 
4.3 Effects of the threshold test....................................................................11 
5. Conclusions......................................................................................................12 
Acknowledgement ...............................................................................................12 
Reference .............................................................................................................12 
Part II: Scheduling Jobs under Constant Period-by-Period Resource Availability 
to Maximize Project Profit at a Due Date................................................................14 
Part II abstract ......................................................................................................14 
1 Introduction.......................................................................................................15 
2 Problem descriptions.........................................................................................17 
2.1 An example ............................................................................................17 
2.2 Mathematical model...............................................................................19 
iv  
 
Content of Tables 
Table 1 Global deviations of BBMA1 for j.10 - j.20mm test sets ................10 
Table 2 Global deviations of BBMA2 for j.10 - j.20mm test sets ................11 
Table 3 Number and percentage of optimal solutions reached by BBMAs.11 
Table 4 Impact of threshold test in BBMA1.................................................11 
Table 5. Two feasible job lists of the project ...............................................18 
Table 6. Future NPVs of the two schedules in Figure 2 with discount rate 
0.05.......................................................................................................19 
Table 7. Example of a 2-swap operation......................................................23 
Table 8. Example of left move and enhanced left move operations ............23 
Table 9. New job list obtained using FV rule on schedule A.......................24 
Table 10. New job list obtained using BF method on schedule B ...............24 
Table 11. Average CPU time by CPLEX on problem parameters ...............26 
Table 12. Computational times by CPLEX for all test instances.................26 
Table 13. Performance comparisons of VNS for j.20 test set ......................27 
Table 14. Performance comparisons of VNS for j.30 test set ......................28 
Table 15. Performance comparisons of VNS for j.60 test set ......................28 
Table 16. Computational results of D-VNS-f and CPLEX for j.20 test set .28 
Table 17. Performance of GA for 480 j.60 test set.......................................30 
Table 18. Performance of TS for 480 j.60 test set........................................31 
Table 19. Performances of GA, TS and D-VNS for j.20, j.30 and j.60 test 
sets........................................................................................................31 
Table 20. C measure on the four algorithms (in %).....................................41 
Table 21 Convergence performance of the four algorithms ........................42 
Table 22 Spread measure of the algorithms.................................................42 
 
 
 
 
 
 
 
 
 
1  
Abstract 
This report is composed of three parts, each of which focuses on one resource constrained project 
scheduling problem. Part I proposes a hybrid approach and an optimization method to minimize the total 
cost of the resource constrained project scheduling problem subject to a deadline; part II applies several 
variable neighborhood search algorithms to schedule activities under constant period-by-period resource 
availability to maximize the future present value of project at due date; part III develops several hybrid 
algorithms to solve the time/cost trade-offs resource constrained project scheduling problem. The three 
problems, along with developed algorithms and performance evaluations, are described in a detailed and 
well organized manner in this report. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
3  
1. Introduction 
  The resource-constrained project scheduling problem (RCPSP) involves the activity scheduling of a 
project subject to zero time lag finish-start precedence constraints, as well as resource constraints. The 
RCPSP has been widely used in diverse contexts such as construction engineering, software systems, and 
product development processes. There has been a great deal of research on the RCPSP with various 
objectives. These objectives can be classified into two categories: (1) project makespan and (2) financial 
aspects such as payment scheduling, resource availability, and project execution cost. For more information 
about the classification and the algorithm performance of the RCPSP, we will refer to [1-4]. 
  When executing a project, management concerns include makespan and cost minimizations. Usually, the 
makespan minimization objective is associated with a budget limit, and the cost minimization objective is 
coupled with a deadline constraint. To achieve cost minimization, the contractor can construct one or more 
modes worth considering for each project activity. The durations of the modes can be estimated based on 
resource/resource and resource/duration tradeoffs. A multi-mode resource constrained project scheduling 
problem (MRCPSP) involves resource constraints that are renewable, nonrenewable, or both. A 
project-mode (PM) or mode assignment is a mode vector, (m1, …, mj, …, mJ), in which activity j will be 
executed with mode mj. In the problem with nonrenewable resources, Kolisch and Drexl [5] have shown 
that finding a feasible project-mode (or mode assignment) for the MRCPSP with at least two 
non-renewable resource constraints is NP-complete. Given a feasible project-mode, the remaining problem 
will be a single-mode resource constrained project scheduling problem (SRCPSP), in which the 
minimization of the makespan is NP-hard in the strong sense [6]. 
  This paper studies an MRCPSP with the objective of minimizing cost, subject to a deadline constraint. 
The total cost of executing the project involves fixed costs and variable costs. The fixed cost concerns the 
availability setup of every renewable resource (machines, workforce), whereas the variable costs are 
usually associated with each activity. Such may include consumed renewable resources, nonrenewable 
resources (fuel, raw material, money), and indirect cost for the mode selected. 
  Hsu and Kim [7] introduced a priority rule heuristic for a multi-mode resource investment problem. The 
problem attempts to find a precedence-, renewable resource- and deadline-feasible schedule with the 
minimum resource investment per period.  Such resource investment is defined as the total cost given the 
availability setting for all renewable resources per period. Yamashita et al. [8] proposed a scatter search 
algorithm to solve the SRCPSP with the objective of minimizing resource availability costs per period, 
subject to a project deadline. Ranjbar et al. [9] solved the same problem with a scatter search and a genetic 
algorithm. Their computational results using benchmark instances in [8] shows their path relinking is 
superior to the genetic algorithm.  
  As mentioned earlier, the SRCPSP with the objective of minimizing makespan is NP-hard. Such a result 
implies that finding a feasible project schedule of the SRCPSP satisfying a committed deadline is 
NP-complete. This feasibility problem becomes as difficult as the optimization problem when the 
committed deadline is near the minimum makespan. The SRCPSP with makespan minimization objective 
has been intensively studied over the last decade. Kolisch and Hartmann [10] provided a survey and 
investigation on algorithms that effectively and efficiently solve the SRCPSP. The survey indicates that 
justification (or forward/backward improvement method, FBI) [11] is one of the best local search to refine 
RCPSP schedules. Some most recent studies on this problem include the following. Xu et al. [12] 
developed a competitive method which uses priority rule in the rollout procedure. During the rollout, FBI is 
5  
NR
jmrq   requirement of nonrenewable resource r for activity j with mode m 
djm  duration of activity j under mode m 
T  project deadline 
ω  project mode in which each activity has been assigned a mode 
Ω  the set of all possible project modes in the problem 
C(ω)  variable cost of project mode ω 
EFω,,j  earliest finish time of activity j under project mode ω 
LFω,,j  latest finish time of activity j under project mode ω 
Decision variables: 
Xj,ω(j),,t   its value is 1 if the finish time of activity j under ω is t, and is zero if otherwise. 
Yj,ω(j),,t  its value is 1 if activity j is in execution at time t, and is zero if otherwise. This decision  
       variable is used to ensure non-preemption during execution of activity. 
2.2 Problem definition 
  The problem to be addressed is as follows. A project consists of J activities which are labelled from 1 to 
J. Activities 0 and J+1 represent the events of project starting time and completion time, respectively. The 
finish-start precedence relations with zero-time lags between activities can be represented by an acyclic 
activity-on-node (AON) network. An activity j cannot start unless all of its immediate predecessors are 
finished. All activities are assumed to be non-preemptive. The problem considers two types of resources, 
renewable and non-renewable. For each renewable resource r∈R, its availability per period is restricted by 
a certain quantity RrQ . Such a setup will incur a fixed cost. Likewise, for each nonrenewable resource type 
r∈NR, there is a restriction on the total amount of the entire project, denoted as NRrTQ .  Each activity j can 
be executed in one of the modes indexed m = 1, …, Mj. Each mode m specifies the corresponding duration, 
djm, the requirement for each renewable resource type r∈R per period, Rjmrq , and the requirement for each 
nonrenewable resource type r∈NR, NRjmrq , during activity execution. Finally, a project deadline, T, is 
defined. 
Given a project mode ω, the MRCPSP is reduced to a SRCPSP with activity j using mode ω (j) and consumption 
cost C(ω (j)). A project mode is feasible if it contains at least one project schedule satisfying: (1) precedence 
constraints; (2) renewable and nonrenewable resource constraints; (3) deadline feasibility. Let Ω  denote the set of 
all project modes in the problem. The aim of the problem is to identify a feasible project mode (FPM) which has 
minimum cost among Ω. 
The resource availability setup of each renewable type per period is treated as a fixed cost. We assume a general 
cost model in which each activity comprises three variable costs. The total cost of project mode ω is as follows. 
7  
algorithms. 
3.1 BBMA algorithm 
  Figure 3 shows the pseudo code of the BBMA algorithm. In this algorithm, each iteration consists of a 
BB step and a possible MA step. The BB step attempts to find a PM; then three conditions are examined to 
decide whether the MA will be applied to investigate this PM’s deadline feasibility. If the PM is deadline 
feasible, then it becomes the current best; otherwise, we proceed to the next BB step and find another PM. 
More details on the BB step, the threshold test, and MA step will be elaborated in the following 
subsections. 
3.1.1 Branch and bound search for PM  
  The BB algorithm searches for all necessary project modes in an MRCPSP instance. The BB uses the 
depth-first search as the branch selection rule. In the search tree, a node represents an activity and an arc 
reflects a mode. In the algorithm, the nodes are processed stage-by-stage in the same order as the activity 
indices.  If activity j contains Mj modes, then at the jth stage the node has Mj branches. Let m(j) = {m1, 
m2,…, mj} be the partial project mode formed at stage j of the current iteration, )( jQNRr  the consumed 
amount of nonrenewable resource type r using the project mode m(j) and the minimum amount required to 
accomplish the remaining activities j+1, …, J, CT(j) the sum of the cost based on m(j) and the minimum 
cost to complete the rest of the activities, and CPM(j) the makespan computed by employing the critical 
path method on the project mode {m(j) ∪ minimum duration modes of the remaining activities}. The BB 
algorithm fathoms a branch at stage j < J if one of the following three conditions is met: 
(1) CT(j) ≥ C*, (2) CPM(j) > T, (3) )( jQNRr  > NRrTQ  for r ∈ NR. 
When the algorithm successfully ends at stage J, a PM is found. 
 
Figure 1 Pseudo code of BBMA algorithm 
9  
Next, the precedence feasibility of the offspring is examined.  Violated activities are shifted leftward one 
by one to their first feasible positions. 
3.2 BBMABB Algorithm 
  This algorithm differs from BBMA in two aspects: (1) no threshold test is used and MA is directly 
applied to investigate the deadline feasibility of a new PM, and (3) when MA has failed to provide an exact 
answer for the deadline feasibility, the BBMABB uses T as the initial upper bound, and employs a 
precedence tree branch and bound algorithm [17] to verify the deadline feasibility. 
4. Experimental results 
  Several experiments were conducted to evaluate the performance of the proposed algorithms. Section 4.1 
introduces the benchmark instances. Section 4.2 presents the numerical results. Section 4.3 discusses the 
effect of the threshold test when used in BBMA. 
4.1 Generation of benchmark instances  
  In this paper, computational tests are performed on the MRCPSP benchmark instances in the PSPLIB 
[20]. The files with these instances, as well as the code of ProGen, are available at 
http://129.187.106.231/psplib/. We use the benchmark sets for problems with 10, 12, 14, 16, 18, 20 
non-dummy activities. In these sets, each activity can be executed in one of three modes. These instances 
are subject to two renewable resource and two non-renewable resource constraints. An activity’s duration 
may vary from one to ten among the three modes. Originally, 640 instances were generated for each 
problem size, but some of them had no feasible solutions and were eliminated. Table 1 displays the number 
of feasible instances in test sets from j10 to j20. All instances between j10 and j20 have optimal makespan 
schedules. 
  The cost of a mode consists of three types (see equation 1). For each type of renewable resource, a unit 
variable cost is randomly generated from the interval [10, 20]. For the first and second types of 
non-renewable resource, the unit costs are from [20, 100] and [30, 150], respectively. In addition, we 
assume that other than the resource cost, each execution mode contains an additional cost randomly 
generated from [50, 200].  Finally, the deadline of a project is specified as a multiplier of the minimum 
makespan. This multiplier is randomly generated from the interval [1.1, 1.3]. 
4.2 Numerical results 
  In the experiment, BBMA1 chooses SPT with FBI for the threshold test, whereas BBMA2 choose 20 
trials of biased SPT sampling with FBI. In BBMABB, threshold test is not used. BBMA1 and BBMABB 
were coded in Visual Studio C#. NET and run on a computer with Intel core dual, 1.8GHz and 1 Giga bytes 
DDR566. For all algorithms, the termination conditions of MA are as follows: either the deadline feasibility 
has been confirmed or the maximum of 1000 solutions have been attained. If the latter occurs, there will be 
no conclusion as to whether a feasible schedule exists for this PM. However, the BBMABB can deliver the 
exact answer to the feasibility problem. 
  We define dev(i, k) as the deviation from the optimum of instance i when the algorithm is at the kth run. 
In the experiment, each test set were run ten independent times. To evaluate the performance of the 
proposed algorithms, the following measures are utilized: 
11  
Table 2 Global deviations of BBMA2 for j.10 - j.20mm test sets 
     BBMA2 
Test  
set Gmin (%) Gavg (%) Gmax (%)
CPU 
time(s) 
j.10 0.0000% 0.0016% 0.0079% 0.27 
j.12 0.0000% 0.0011% 0.0046% 0.31 
j.14 0.0000% 0.0009% 0.0023% 0.84 
j.16 0.0000% 0.0003% 0.0009% 1.71 
j.18 0.0000% 0.0011% 0.0023% 3.36 
j.20 0.0000% 0.0002% 0.0006% 6.15 
Table 3 Number and percentage of optimal solutions reached by BBMAs 
   BBMA1   BBMA2  
 Test set 
 
min max % of reaching optimality min max 
% of reaching
 optimality
j.10  517 516 (96.10, 95.91)  536 532 (100, 99.25)
j.12  534 533 (97.62, 97.44)  547 543 (100, 99.27)
j.14  534 526 (96.37, 95.46)  551 545 (100, 98.91)
j.16  524 523 (95.27, 95.09)  550 546 (100, 99.27)
j.18  536 535 (97.10, 96.92)  552 547 (100, 99.09)
j.20  540 537 (94.57, 94.02)  554 551 (100, 99.46)
4.3 Effects of the threshold test 
  An experiment was conducted to observe the impact of the threshold test. Table 9 presents the 
experimental results using BBMA1. The threshold test can reduce the computational time considerably, and 
the difference grows as problem size increases. The discrepancy is extremely significant for j18 and j20. 
Nevertheless, the solution quality will be greatly improved without the threshold test. In this case, type 1 
error risk is smaller, since the algorithm will apply MA directly to investigate the deadline feasibility 
whenever a new PM is found. 
Table 4 Impact of threshold test in BBMA1 
  CPU time Gavg 
Threshold test? yes no yes no 
j10 0.202 1.542 0.0504% 0.0012% 
j12 0.241 3.076 0.0138% 0.0001% 
j14 0.620 6.742 0.0172% 0.0018% 
j16 1.329 12.589 0.0338% 0.0002% 
j18 2.415 41.789 0.0106% 0.0003% 
j20 4.170 38.915 0.0111% 0.0009% 
13  
Springer’s International Series, p.249-274. 
[16] Krasnogor N. and Smith J. (2005). A tutorial for competent memetic algorithms: Model, taxonomy, 
and design issues, IEEE T Evolut Comp 9(5):474-488. 
[17] Sprecher A.  (1994), Resource-constrained project scheduling – exact methods for the multi-mode 
case. Lecture Notes in Economics and Mathematics No 409, Springer, Berlin, Germany, 1994. 
[18] Moscato P. (1989). On evolutions, search, optimization, genetic algorithms and martial arts: toward 
memetic algorithms. Technical Report, Caltech Concurrent Computer Program Report, California 
Institute Technology, Pasadena, CA, 1989. 
[19] Merz P. and Freisleben B. (1999). A comparison of memetic algorithm, tabu search, and ant colonies 
for quadratic assignment problem. Proceedings of the congress on evolutionary computation, 
p.2063-2070. 
[20] Kolisch R. and Sprecher A. (1996). PSPLIB–A project scheduling problem library, Eur J Oper Res 96: 
205-216. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
15  
1 Introduction 
  The resource-constrained project scheduling problem (RCPSP), a generalization of the job shop 
scheduling, has been an important area in the research of project management and has applications in many 
situations such as aircraft maintenance, plant construction, new technology or product development, etc. 
Profitability and committed due date are two significant factors for both client and contractor to agree on a 
project. When the profit term and payment schedule of executing a project have been negotiated and 
determined, the contractor usually attempts to accomplish the project within the specified deadline with two 
objectives: (1) maintaining cash availability for payment to suppliers and subcontractors, and (2) 
maximizing total profit. Thus, the payment schedule to the contractor is an important issue in project 
management because of its potential impact on project finances and job schedules. 
  The financial aspect of the project scheduling problem is the cash inflows and outflows associated with 
the jobs and/or events. Cash inflows are the payments received from the client, whereas cash outflows 
correspond to the cost of executing jobs. There has been plenty of research dealing with the problem of 
minimizing the resource availability or total cost incurred in accomplishing the assigned project [1-3], but 
there has also been ample research focused on the problem of maximizing the total profit. To evaluate the 
profitability of a project, time value of money is frequently taken into consideration with discount rate. The 
most commonly used financial objective is the maximization of the net present value (NPV) of the cash 
inflows and outflows during the time intervals from the beginning to the end of the project. These problems 
are often collectively referred to as resource constrained project scheduling problem with discounted cash 
flows (RCPSPDCF) [4-5]. 
  Generally speaking, three payment models are of particular interest in practice and often discussed in the 
literature: (1) Lump-sum payment, (2) Payments at node/event occurrences, and (3) Progress payments. 
Lump-sum payment is the condition in which the client remits the entire payment to the contractor at a 
specified time after the project has been successfully accomplished. Payments based on node/event 
occurrences imply that the contractor will receive a payment when a job or a pre-specified set of jobs has 
been accomplished. Finally, a progress payment model means that the contractor receives payment from the 
client on a regular time interval basis until the project is completed. An example of progress payments is 
that the contractor receives a payment at the end of each month with an amount equal to the reward of the 
work accomplished in that month. 
  The project payment scheduling problem was first introduced by Russell [6]. He presented an 
event-based payment model with the objective of maximizing the NPV of all cash inflows and outflows 
that occur during the project life without violating the precedence constraints. Grinold [7] modified 
Russell’s model by adding a project deadline, and transformed the problem into a linear program. Talbot [8] 
modeled time-cost trade-offs in the resource constrained project scheduling problem as a binary integer 
program. 
  Icmeli and Erenűuc [9] investigated a progress payment model for RCPSP with discounted cash flows 
occurring at the completion times of jobs. The objective was to schedule the jobs subject to a fixed deadline 
so that the NPV would be maximized. They proposed a branch and bound algorithm using the concept of 
“minimal delaying alternatives” to resolve resource conflicts. Vanhoucke et al. [10] introduced a depth-first 
branch and bound algorithm to solve the same problem. The algorithm uses the same concept to resolve 
resource conflicts, and a fast recursive search method for solving max NPV problem without resource 
constraints is applied to compute upper bounds. Vanhoucke et al. [11] further investigated a progress 
payment model for the unconstrained project scheduling problem where the cash outflows occur when a job 
17  
2 Problem descriptions 
   The resource-constrained project scheduling problem (RSPSP) can be stated as follows: A project 
consists of a set N = {0, 1,…, J+1} of jobs (nodes), where jobs 0 and J+1 are dummies, and represent the 
start time and the completion time events of the project, respectively. A set of precedence relationships 
(directed arcs) between pairs of jobs must be specified for the project. These jobs and their associated 
precedence relationships can be represented by an acyclic directed network G = (N, A), where A is the set of 
directed arcs. A job list (JL) is a sequence of the jobs that follows the precedence constraints. Job 
preemption is not allowed. The processing time (duration) of a job j is denoted by dj, and its request for 
renewable resource type k is rjk, k = 1,…, K. The availability of a resource type k in each time period is Rk 
units. 
  A lump-sum payment model for the RCPSP is proposed. In the model, a payment date or project due date 
T which comes after the project completion time is predetermined before the project begins. The monetary 
value of the total payment received by the contractor will equal the sum of the future net present value 
(NPV) of all jobs at due date T. The future NPV of each job paid by the client to the contractor is calculated 
with a simple discount rate from the job completion time to due date T. The cost of each job is assumed to 
be a constant expense in the contractor’s company or to be responsible by the client. A schedule S is 
feasible if it is completed before the time T and if it satisfies both precedence and resource constraints at 
any execution time period. The objective of the RCPSP is to determine a feasible schedule that maximizes 
the future NPV at the time T. 
  As commonly known, the optimal solution to the RCPSP with the objective of minimizing the makespan 
is an active schedule. The same conclusion holds for the problem considered in this paper. An active 
schedule in project scheduling is defined as a feasible schedule where none of the activities in the project 
can be locally left shifted or globally left shifted, i.e., no activity can start earlier without changing the start 
times of the other activities [28]. The result can be reasoned as follows: Suppose an optimal schedule is not 
active, then there exists an activity of which the start time can be made earlier without changing the start 
times of the other activities. The new schedule that has this activity start earlier will have a better future 
NPV value than that of the original schedule, which was assumed to be optimal. Thus, it is a contradiction. 
A feasible schedule obtained by forward serial scheduling method is an active schedule [29]. In the 
proposed algorithms, all job lists are decoded using the forward serial scheduling method. 
  A simple upper bound on the studied problem can be obtained by computing the total future NPV 
corresponding to the schedule obtained by the critical path method (CPM). A CPM schedule is constructed 
without considering the resource constraints, and therefore the starting time of any job can not be later than 
that of any schedule for the problem with resource constraints. 
2.1 An example 
  This section presents an example with a single renewable resource type for the problem under study. 
Figure 4 shows the precedence relations of the project network. The first number in the parenthesis is 
duration, and the second is resource demand. The resource availability is eight units per period. Table 10 
exhibits two feasible schedules of the project corresponding to the two job lists shown in Figure 5, 
respectively. Both schedules are obtained using forward serial scheduling method [29], which schedules 
each job in the JL at the earliest possible time without violating the resource constraints. Table 11 displays 
19  
Table 6. Future NPVs of the two schedules in Figure 2 with discount rate 0.05 
Job Profit 
Future NPV of 
schedule A at due 
date T 
T – finish time 
of schedule A
Future NPV of 
schedule B at due 
date T 
T – finish time 
of schedule B
1 4.5 6.075 7 6.075 7 
2 6.0 7.800 6 7.800 6 
3 4.5 5.175 3 5.625 5 
4 1.5 1.725 3 1.575 1 
5 3.0 3.750 5 3.450 3 
6 7.5 9.375 5 9.375 5 
7 6.0 6.300 1 6.900 3 
Sum 33.0 40.200 30 40.800 28 
2.2 Mathematical model 
  The following are the notation and the formulation of the proposed payment model. 
Notation 
j : Index of job, j = 1, 2,…, J + 1 
t : Index of time, t = 1,…, T 
T  : Due date of the project 
k : Index of renewable resource type, k = 1,…, K 
dj  : Duration of job j 
Pj  : Profit for executing job j 
rjk  : Per period usage of resource k by job j 
Rk  : Availability level of resource k per period 
DPj : Directed predecessors of job j 
ESj  : Earliest start time of job j 
LSj  : Latest start time of job j 
EFj  : Earliest finishing time of job j 
LFj  : Latest finishing time of job j 
α  : Discount rate 
Decision variables 
21  
case of the problem under study [30]. Alternatively, this problem can also be viewed as a generalization of 
the job shop problem to minimize the total weighted completion time. 
 Minimize ∑ ∑
= =
⋅⋅⋅
J
j
LF
EFt
jtj
j
j
xtP
1
α   (9)     
3 Variable Neighborhood Search Algorithms 
  The variable neighborhood search (VNS) was first discussed by Mladenović and Hansen [25-26]. The 
authors pointed out three problem specific questions that must be considered while designing a VNS 
algorithm: (a) What neighborhood structures should be used and how many of them? (b) What should be in 
their local search? (c) What strategy should be used in changing neighborhoods? In this paper, we present 
several VNS algorithms which differ in two characteristics: (1) the design of local search; (2) the choice of 
movement to the next-stage neighborhood. 
3.1 The VNS algorithms 
  Based on the first characteristic as mentioned above, the proposed VNS algorithms can be classified into 
two types: (1) using backward/forward scheduling (BF) or future value scheduling (FV); (2) using a short 
term VNS, i.e., a VNS with a small number of neighborhood structures. We refer to the VNS that uses a 
short term VNS as the local search method as D-VNS (double VNS). 
  Based on the second characteristic, the proposed VNS can be further classified into another two types: (1) 
moving back to first-stage neighborhood if an improvement of the current best solution is made; (2) moving 
forward to the next-stage neighborhood regardless of whether an improvement is obtained or not. A 
notation “b” is attached to a proposed algorithm if it selects the first type neighborhood movement; 
otherwise, a notation “f” is used. As a cumulative result, four variable neighborhood search algorithms are 
presented: VNS-b, D-VNS-b, VNS-f, and D-VNS-f. 
  Figure 6 presents the framework of the VNS-b algorithm. In the case that the project makespan is equal 
to that computed by the critical path method (CPM), the algorithm can be terminated and the corresponding 
schedule will be optimal to the instance of the RCPSP under study. In the VNS-b, the current best solution 
x* will be replaced whenever a better solution was found in the current iteration of the loop. The VNS-b 
always selects the best solution x” of the current iteration to begin next stage neighborhood iteration. Since 
a local search will be applied to each neighboring solution in the iteration, the strategy that keeps on 
changing the center solution x in the iteration will sustain the search diversity as well as intensity. The 
VNS-b chooses to move back to N1 if and only if an improvement was made in the iteration; otherwise, it 
goes ahead to the next stage neighborhood. Algorithm VNS-f, on the other hand, moves to the next stage 
neighborhood regardless of whether or not an improvement was made in the iteration. The VNS-f will 
return to N1 only if it has completed the Kmax neighborhood search and has not used out 5000 solutions. 
23  
Table 7. Example of a 2-swap operation 
Job list (JL) 0 2 3 6 1 5 4 7 8 
2-swap 0 2 3 7 1 5 4 6 8 
  Table 13 illustrates an example of the left move and the enhanced left move operations. In this example, 
the selection of job 4 is random. The leftmost possible position that it may be inserted is after job 1. For a 
left move operation, we place job 4 at this position and shift jobs 6 and 5 one position to the right. For an 
enhanced left move, we bundle jobs 4 and 1, and move them leftward together to the foremost positions of 
the job list. 
Table 8. Example of left move and enhanced left move operations 
 Job list (JL) 0 2 3 1 6 5 4 7 8 
2-swap 0 2 3 1 4 6 5 7 8 
Enhanced left move 0 1 4 2 3 6 5 7 8 
3.3 Initial solution 
  An initial solution is constructed by the forward serial generation scheme method with future value (FV) 
priority rule. The FV of a job is defined as its profit discounted at a simple rate from the job’s finish time to 
the project due date. The following describes the construction of an initial solution of VNS algorithm: at 
each step, select a job from the candidate set and arrange it into the current partial schedule; then the future 
value of this job is calculated; choose and schedule the job with the maximum future value among the 
candidate set; update the candidate set. Repeat the above steps until all jobs of the project have been 
scheduled. 
3.4 Local search 
  Two types of local search are used in the algorithms: FV method and backward/forward (BF) scheduling 
method [31] [14]. In the FV local search, the future values of all jobs at the project due date based on the 
current project schedule are calculated and sorted in decreasing order. A job list is then constructed based 
on the job precedence relationships and the sorted FV order. 
  We use schedule A in Figure 14 as an example to illustrate the FV method. Table 14 displays the future 
NPV for each job, which is computed according to the formula, ))(1( ii fTP −⋅+⋅ α , with α = 0.05. Each 
future NPV is treated as the priority value for the job and a new job list can be obtained sequentially by 
selecting the job which has the maximum priority value among the candidates at each step. For example, in 
the first step, the candidates are jobs 1, 2, and 3. Job 2 is selected since its priority value is the maximum 
among the three jobs. In the next step, the candidate list contains jobs 1, 3, 6, and job 6 is selected. 
Following this rule we obtain a new job list as shown in Table 14. We apply the forward serial scheduling 
method to the new job list and obtain schedule B. The total objective value is improved from 40.2 to 40.8 as 
shown in Table 11. 
  Another local search, BF method, is described as follows: Process the activities according to their finish 
times in decreasing order. Based on this order, shift the finish times of the activities one by one to the latest 
25  
 
Figure 5 Illustration of BF method 
  In algorithm D-VNS, the local search is replaced by a VNS with five neighborhood structures, N1 to N5, 
as defined in section 3.2. The effects of these local search methods will be investigated and discussed in 
section 4. 
4 Computational experiments 
  In this section, we will evaluate the performance of the proposed VNS algorithms for the RCPSP under 
study, and the results are compared with two famous metaheuristics, TS and GA. A set of test instances was 
generated using ProGen [32-33], which generates instances based on the following three parameters: (1) 
Network complexity (NC) with three levels, 1.5, 1.8, 2.1; (2) Resource factor (RF) with four levels, 0.25, 
0.5, 0.75, 1.0; (3) Resource strength (RS) with four levels, 0.2, 0.5, 0.7, 1.0. Parameter NC is the average 
number of successors of each job, RF is the average number of resource types used by a job, and RS is in 
regard to the strength of resource availability. There are a total of 48 parameter combination levels, and 
each level generates one instance containing 20 jobs along with four renewable resource types. In addition 
to these ProGen generated test instances, the proposed algorithms are also tested through instances of larger 
problem sizes, 30 and 60 jobs, respectively. These larger problem size instances are taken from PSPLIB, 
where each set contains 480 instances with each parameter combination level having 10 instances. The 
project due date of each instance is set as 1.5 times its minimum makespan. All algorithms are coded in 
Visual Studio C#. NET, and run on a computer with Intel core dual, 1.8GHz and 1 Giga bytes DDR566. 
  Given an RCPSP instance, network complexity is the average number of immediate successors of a job, 
the resource factor reflects the average number of resource types requested by a job, and the resource 
strength measures the resource scarcity in a project. A low RS value implies a weak resource availability of 
the project. As pointed out in [32], an RCPSP instance with high RF and/or low RS is difficult to be solved 
optimally, even when the number of jobs is small; an instance with high RS and/or low RF, on the other 
hand, is much easier. 
4.1. Generation of job profits 
  The unit cost of resource type k, denoted Ck, was calculated as follows: Generate a value b at random 
from (1000, 1300) and set Ck = b/Rk. The larger the resource limit, the cheaper the unit cost. The cost of job 
j is j
k
jkk drC ⋅⋅∑
=
4
1
, and the net profit of job j is a multiplier of its cost, where the multiplier is in turn 
27  
neighboring solution with an effective refinement method will perform better than continuing to search 
intensively for solutions in the nearby areas. 
  In general, a 2-swap operation takes a longer computational time than a left-move operation, but the 
former will make a bigger change on the current solution structure. Thus, a neighbor generated by using 
2-swap k times will take a longer computational time and make a bigger change on the solution structure 
than those generated by using 2-swap k-1 times or less. Additionally, the bigger the problem size is, the 
larger the disturbance effect and computational time taken for a 2-swap operation. 
  In the proposed VNS algorithm, a local search terminates whenever no further improvement is made. 
While applying the VNS-f algorithm, the number of solutions used is at least ⋅⋅ 2030 )11( + = 1200 for 
adopting the FV rule as the local search, and at least ⋅⋅ 2030 )21( + = 1800 for using the BF method. Note 
that each local search will terminate if no further improvement has been made. On the other hand, the 
D-VNS-f with FV rule will search at least ⋅⋅ 2030 (1+5+1) = 4200 solutions, whereas the D-VNS-f with 
BF method will find at least ⋅⋅ 2030 (1+5+2) = 4800 solutions, which is very close to 5000 limit. This may 
explain the experimental results shown in Tables 18-20, where the CPU time of using BF method is on 
average longer than using FV rule, and D-VNS-f is longer than VNS-f. The numerical results take the 
average of five replication runs on each test set. 
  Nevertheless, it is difficult to count the number of solutions used in VNS-b and D-VNS-b, since each 
time an improvement is made, the algorithm returns to the first-stage neighborhood which will restart with 
a new sequence of 2-swap operations. All VNS algorithms adopt 2-swap operations to construct 
neighborhoods before left-move operations. For an instance with large problem size, e.g. 60 activities, 
D-VNS-f has a much bigger chance of approaching k = 20 than D-VNS-b. This may explain why D-VNS-f 
takes a longer time than D-VNS-b. The superior performance of D-VNS-f is due to its capability of widely 
exploring in the whole solution space as well as intensively searching local areas that may contain good 
solutions. 
Table 13. Performance comparisons of VNS for j.20 test set 
Local search: FV rule VNS-b D-VNS-b VNS-f D-VNS-f CPLEX 
Dev. from CPM schedule (%) 1.56 1.52 1.51 1.50 1.40
Dev. from opt. schedule (%) 0.09 0.02 0.01 0.01 0.00 
Opt. reached (%) 64.00 85.33 81.33 90.67 100.00 
CPU time (s) 0.101 0.205 0.053 0.214 3451.94
Local search: BF method VNS-b D-VNS-b VNS-f D-VNS-f 
Dev. from CPM schedule (%) 1.54 1.51 1.50 1.50 
Dev. from opt. schedule (%) 0.05 0.01 0.01 0.01 
Opt. reached (%) 66.67 87.11 84.89 91.56 
CPU time (s) 0.179 0.305 0.135 0.320 
 
29  
1.5 0.75 0.2  102250 102251 0.00 0.00 0.519 102251 16094.02
1.5 0.75 0.5  65683 65683 0.00 0.00 0.466 65683 5.406
1.5 0.75 0.7  44066 44066 0.00 0.00 0.425 44066 2.921
1.5 0.75 1.0  22324 22324 0.00 0.00 0.000 22324 0.265
1.5 1.00 0.2  99920 99920 0.00 0.00 0.444 99920 12892.469
1.5 1.00 0.5  59529 59529 0.00 0.00 0.394 59529 8.109
1.5 1.00 0.7  48008 48011 0.01 0.00 0.409 48011 11.313
1.5 1.00 1.0  57602 57602 0.00 0.00 0.003 57602 0.171
1.8 0.25 0.2  36796 36796 0.00 0.00 0.447 36796 1.578
1.8 0.25 0.5  25075 25075 0.00 0.00 0.388 25075 1.922
1.8 0.25 0.7  34796 34796 0.00 0.00 0.475 34796 1.875
1.8 0.25 1.0  30966 30966 0.00 0.00 0.000 30966 0.203
1.8 0.50 0.2  66543 66543 0.00 0.00 0.441 66543 40.810
1.8 0.50 0.5  57397 57397 0.00 0.00 0.441 57397 1.781
1.8 0.50 0.7  48973 48973 0.00 0.00 0.413 48973 10.296
1.8 0.50 1.0  32826 32826 0.00 0.00 0.003 32826 0.250
1.8 0.75 0.2  87371 87371 0.00 0.00 0.520 87371 7411.437
1.8 0.75 0.5  53192 53192 0.00 0.00 0.406 53192 9.719
1.8 0.75 0.7  69877 69891 0.08 0.06 0.456 69934 23.609
1.8 0.75 1.0  37385 37385 0.00 0.00 0.000 37385 0.281
1.8 1.00 0.2  88489 88489 0.01 0.01 0.428 88495 8754.160
1.8 1.00 0.5  59838 59838 0.27 0.27 0.422 60002 31.671
1.8 1.00 0.7  69011 69011 0.00 0.00 0.456 69011 7750.234
1.8 1.00 1.0  34717 34717 0.00 0.00 0.000 34717 0.203
2.1 0.25 0.2  37999 37999 0.00 0.00 0.000 37999 0.203
2.1 0.25 0.5  27228 27228 0.00 0.00 0.450 27228 0.344
2.1 0.25 0.7  29162 29162 0.00 0.00 0.403 29162 0.281
2.1 0.25 1.0  26592 26592 0.00 0.00 0.003 26592 0.203
2.1 0.50 0.2  53516 53516 0.00 0.00 0.450 53516 6357.750
2.1 0.50 0.5  50081 50081 0.00 0.00 0.447 50081 10.828
2.1 0.50 0.7  39408 39408 0.00 0.00 0.428 39408 0.640
2.1 0.50 1.0  43750 43750 0.00 0.00 0.000 43750 0.234
2.1 0.75 0.2  84677 84677 0.00 0.00 0.447 84677 49159.030
2.1 0.75 0.5  36098 36098 0.00 0.00 0.372 36098 5.328
2.1 0.75 0.7  45184 45184 0.00 0.00 0.394 45184 0.344
31  
Meanwhile, each neighborhood search has its own tabu list and the movement that is in tabu will not be 
performed. The 2-swap tabu list keeps the memory of those pairs of positions in recent steps, and the 
left-move tabu list only keeps in memory those positions recently chosen. The stopping criterion is set to 
5,000 schedules. Table 23 shows the numerical results for different parameter settings: tabu length with two 
levels, (5, 10); the number of neighborhood solutions at each iteration with three levels, (5, 10, 20). 
Experimental results indicate that the performance of the TS is insensitive to these parameter settings and 
they all are inferior to other algorithms. 
Table 18. Performance of TS for 480 j.60 test set 
Tabu length 5 10 
Number of neighbors in 
each iteration 
5 10 20 5 10 20 
Dev. from CPM 
schedule (%) 
2.36 2.37 2.36 2.36 2.37  2.36  
CPU time 0.901 0.775 0.813 0.764 0.729 0.769 
4.2.4 Performance comparison 
  Table 24 presents a comparison between the performance of the D-VNS, GA, and TS for problems of 20, 
30, and 60 jobs, based on the average of five replication runs for each test set. In the comparison, GA and 
TS with the best parameters setting are selected, and the D-VNS with the BF method is chosen. As 
perceived from the table, the D-VNS-f outperforms all others in terms of effectiveness, but it takes a little 
more computational effort. The D-VNS-b and GA perform roughly the same, but are better than TS. The 
computational times of these algorithms do not deviate much since all of them are set to compute at most 
5,000 thousand solutions. 
Table 19. Performances of GA, TS and D-VNS for j.20, j.30 and j.60 test sets 
  
No. of 
Jobs
D-VNS-b D-VNS-f TS GA 
Dev. (%) 1.51  1.50  1.74 1.61  
CPU time (s) 
20 
0.305 0.320 0.271 0.247  
Dev. (%) 1.67 1.63 1.86 1.67 
CPU time (s) 
30 
0.392 0.360 0.371 0.338  
Dev. (%) 1.99  1.95  2.36 2.05  
CPU time (s) 
60 
0.698 1.035 0.764 0.679 
5. Conclusion 
  This paper presents a new lump-sum payment project scheduling problem that has application in 
software companies, R&D companies, facility design companies, etc. A mathematical formulation of the 
problem is presented and the CPLEX 9.0 software is used to optimally solve the test instances. Several 
variable neighborhood search algorithms are also proposed in order to solve the payment project scheduling 
33  
[16] Hartmann S. (2002). A self-adapting genetic algorithm for project scheduling under resource 
constraints, Nav Res Log 45: 443-448. 
[17] Reddy J.R., Kumanan S. and Chetty O.V.K. (2001). Application of petri nets and a genetic algorithm 
to multi-mode multi-resource constrained project scheduling, Int J Adv Manuf Technol 17:305-314. 
[18] Kumanan S., Jegan G. and Raja K. (2006). Multi-project scheduling using an heuristic and a genetic 
algorithm, Int J Adv Manuf Technol 31: 360-366. 
[19] Merkle D., Middendorf M. and Schmeck H. (2002). Ant colony optimization for resource-constrained 
project scheduling, IEEE T Evolut Comput 6:, 333-346. 
[20] Agarwal R., Tiwari M.K. and Mukherjee S.K. (2007). Artificial immune system based approach for 
solving resource constraint project scheduling problem, Int J Adv Manuf Technol 34: 584-593. 
[21] Debels D, Reyck BD, Leus R, Vanhoucke M (2006) A hybrid scatter search/electromagnetism 
meta-heuristic for project scheduling, Eur J Oper Res 169: 638-653. 
[22] Shukla K.S., Son Y.J. and Tiwari M.K. (2008). Fuzzy-based adaptive sample-sort simulated annealing 
for resource-constrained project scheduling, Int J Adv Manuf Technol 36: 982-995. 
[23] Ying K.C., Lin S.W. and Lee Z.J. (2008). Hybrid-directional planning: improving improvement 
heuristics for scheduling resource-constrained projects, Int J Adv Manu Technol DOI 
10.1007/s00170-008-1486-5. 
[24] Kolisch R. and Hartmann S. (2006). Experimental evaluation of state-of-the-art heuristics for the 
resource-constrained project scheduling: An update, Eur J Oper Res 174: 23-37. 
[25] Mladenović N. and Hansen P. (1997). Variable neighborhood search, Comput Oper Res 24: 
1097-1100. 
[26] Hansen P. and Mladenović N. (2001). Variable neighborhood search: Principles and applications, Eur 
J Oper Res 130: 449-467. 
[27] Freszar K. and Hindi K.S. (2004). Solving the resource-constrained project scheduling problem by a 
variable neighborhood search, Eur J Oper Res 155: 402-413. 
[28] Sprecher A., Kolisch R. and Drexl A. (1995). Semi-active, active, and non-delay schedules for the 
resource-constrained project scheduling problem, Eur J Oper Res 80: 94-102. 
[29] Kolisch R. (1996). Serial and parallel resource-constrained project scheduling methods revisited: 
Theory and computation, Eur J Oper Res 90: 320-333. 
[30] Gary M.R. and Johnson D.S. (1979). Computers and intractability: A guide to the theory of 
NP-Completeness. W H Freeman and Company, New York. 
[31] Li K.Y. and Willis R.J. (1992). An iterative scheduling technique for resource-constrained project 
scheduling. Eur J Oper Res 56: 370-379. 
[32] Kolisch R., Sprecher A. and Drexl A. (1995). Characterization and generation of a general class of 
resource-constrained project scheduling problems, Manage Sci 41: 1693-1703. 
[33] Kolisch R. and Drexl A. (1996). PSPLIB–A project scheduling problem library, Eur J Oper Res 96: 
205-216. 
[34] Holland J.H. (1976). Adaptation in nature and artificial systems. Univ Michigan Press, Ann Arbor. 
[35] Goldberg D.E. (1989). Genetic algorithms in search, optimization, and machine learning. 
Addison-Wesley, Reading, MA. 
[36] Glover F (1986). Future path for integer programming and links to artificial intelligence, Comput Oper 
Res 13: 533-549. 
[37] Glover F. and Laguna M. (1997). Tabu search. Kluwer Academic, Publisher, Norwell. 
 
 
 35
1. INTRODUCTION 
  The objective of a project that project management planning to achieve should be clear and 
measurable. Generally, there are three fundamental objectives of the project management: time, cost 
and quality (Demeulemeester and Herroelen, 2002). The relative importance of each objective will 
differ for different projects. In many cases, especially for product innovation and new product 
development projects, time is often considered to be the first priority among performance objectives. 
However, in other cases such as plant construction and software system projects, resource 
availability, normally referring to renewable resources, may become the most concern of the project 
management because it comprises the major cost of the project. Some examples of renewable 
resources are equipments, technicians, etc. The project quality is usually measured by the degree to 
which a project’s outcome conforms to the customer’s requirements and the degree to which the 
project completes within budget and on schedule (Erenguc and Tukel, 1999). 
  Over the past few decades, a great deal of research effort in project scheduling has been devoted 
to the development of exact and heuristic procedures for the generation of a workable pre-schedule, 
of which the objective is to minimize the project completion time (makespan) given a specified 
constant resource availability for each type of resource utilized throughout the project execution 
period, as well as a specified consumption for each type of resource in executing each activity. Such 
a problem is often referred to as resource constrained project scheduling problem (RCPSP) with the 
objective of minimizing the project completion time (makespan). Blazewicz et al. (1983) has shown 
that this optimization problem is NP-hard in the strong sense. 
  Many solution approaches have been proposed to solve the RCPSP with makespan minimization 
objective, including branch and bound algorithm (B&B), biased sampling with local search (LS), 
genetic algorithm (GA), ant colony optimization (ACO), and hybrid metaheuristic approaches, such 
as scatter search/electromagnetism (Debels et al. 2006), etc. Kolisch and Hartmann (2006) provided 
a valuable survey and investigation on algorithms for this problem. The survey indicates that hybrid 
approach with the forward/backward improvement (FBI; Li and Willis 1992, Valls et al. 2005) 
method is one of the most efficient and effective solution approach to this problem. Tormos and 
Lova (2003) presented a hybrid multi-pass method that combines a biased random sampling 
procedure with a FBI method, along with an illustrative example with two resource types of the FBI 
method. 
  On the other hand, compared to the minimizing makespan problem, relative few studies have 
been focused on the RCPSP with the objective of minimizing resource availability. Yamashita et al. 
(2006) proposed a scatter search algorithm for solving the SRCPSP with the objective of 
minimizing total resource availability cost per period, subject to a project deadline. Hsu and Kim 
(2005) introduced a priority rule heuristic for a multi-mode resource investment problem. The 
problem attempts to find precedence, renewable resource- and deadline-feasible schedule with the 
minimum resource investment cost per period. The cost of each resource type per period is unit cost 
times the amount available per period, and the resource investment cost per period is defined as the 
total cost given the availability setting for all resource types. 
  Recently, considerable research efforts have been spent on RCPSP considering the duration/cost 
tradeoff relations for each activity of the project. Erenguc et al. (2001) brought forward a branch 
and bound method for the RCPSP with multiple crashable modes, in which the duration/cost of an 
activity is determined by the mode selection and the duration (crashing) within the mode. 
Vanhouche et al. (2002) focused on the discrete duration/cost trade-offs problem in project 
scheduling with time-switch constraints, and proposed a branch and bound algorithm, as well as a 
heuristic procedure, to solve this particular problem. The problems of continuous duration/cost 
trade-off with linear, convex, and concave cost-duration functions had been discussed in 
Demeulemeester and Herroelen (2002). These problems did not take resource constraints into 
consideration, and the piecewise-linear approximation solution method was introduced. A 
discrete-continuous duration/cost trade-off problem with makespan minimization objective was 
 37
= 1maxR + … + KRmax , as well as the minimum total quantity of resource required for executing 
every activity, MinRsum = 1minR + … + KRmin , where KRmin  is the minimum quantity required 
of resource type k to implement all activities, i.e., kRmin  = Max{rjk | j = 1,…, J}. 
Step 2: Randomly select one of resource types from {1,…, K} and decrease its available amount by 
one unit. If this type has been consecutively chosen for four times, give up the choice and 
begin another selection. Whenever a resource type k has declined to its minimum 
amount kRmin , remove type k from the candidate list. 
Step 3: Employ an efficient algorithm to find the minimum or a near minimum makespan of the 
RCPSP with the resource availability obtained in Step 2. 
Step 4: If all resource types have reached its minimum required amount, go to Step 5; otherwise, go 
to Step 2. 
Step 5: Construct the near Pareto front by comparing all the best solutions obtained. 
In Step 3, four algorithms are proposed to solve the RCPSP with minimum makespan: (1) 
Combining multiple pass method (Boctor, 1990) with parameterized regret-based biased random 
sampling (Kolisch and Drexl, 1996), abbreviated as (MP-RBRS); (2) Genetic local search (GLS); (3) 
Particle swarm optimization with local search (PSO-LS); (4) Population learning algorithm (PLA). 
Whenever the total quantity of resource is decreased by one unit, the selected algorithm computes 
five thousand solutions (in Step 3) to find a best makespan. The four algorithms are described 
below. 
3.1 MP -RBRS 
In this algorithm, five priority rules are used: shortest process time (SPT), minimum slack time 
(MST), earliest start time (EST), earliest finish time (EFT), and latest finish time (LFT). At each 
step, one of the five rules is firstly chosen at random. Then the RBRS scheme based on the selected 
priority rule is applied to choose an activity from the candidate list. The same procedure is repeated 
until an AL has been attained. Afterwards, the serial schedule generation scheme (S-SGS) is 
employed to decode this AL to an active schedule, and then the FBI is applied to refine this 
schedule. The MP-RBRS algorithm computes five thousand solutions and return with the best one. 
The following describes the RBRS procedure: 
Let D be the candidate list of activities at the current step. The regret value (ρi) for each 
activity i in D compares the priority value of activity i, v(i), with the worst priority value v(j) of the 
activities of D and is calculated as follows: 
ρi = max{v(j) | j∈D} – v(i), and the parameterised probability (φi) is calculated as follows: 
φ i= ( )( )i jj D
ρ ε
ρ ε∈
+
+∑ , whereεis a predetermined parameter value. 
3.2 Genetic local search (GLS) 
The GLS adopts an elitist strategy to maintain good quality solutions in each generation. In 
this algorithm, roulette wheel is used for reproduction, one point crossover is for producing 
offspring, two-swap operation is for mutation, and then the FBI is for further improvement. The 
algorithm terminates when five thousand solutions has been attained. The population size is set to 
50, the crossover rate is 0.9, and the mutation rate is 0.1. 
3.3. Particle swarm optimization with local search (PSO-LS) 
 Kennedy and Eberhart (1995) proposed PSO, which was inspired by the choreography of a 
bird flock. The idea of this approach is to simulate the movement of a group (or population) of birds 
 39
 
 
 
 
Figure 10. RKL of the schedule after FBI 
 
Step 0: Set population size M = 30; initialize the speed of particle i, V[i] = 0; initial weight w = 0.3; 
two constants c1 = 2, c2 = 2.1; 
Step 1: For i = 1 to M 
         Randomly generate a particle P[i]; 
         Evaluate P[i] (apply converting process to obtain a schedule); 
      End for 
      GLbest = PObest = Best{P[i]: i = 1,…, M} 
Step 2: Repeat the following procedure until 5000 solutions have been attained. 
       Begin 
For i = 1 to M 
V[i] = [ ]w V i⋅ + . .11C R (PObest – P[i]) + 2 2c R⋅ ⋅ (GLbest – P[i]); 
(Calculate speed of each particle, w = Inertial weight, R1 & R2 are random numbers in 
[0, 1]) 
P [i] = P[i] + V[i];   Evaluate P[i]; 
If P[i] is better than PObest, then PObest = P[i]; 
If PObest is better than GLbest,  
then GLbest = PObest; 
End For 
       End (begin). 
3.4 Population learning algorithm (PLA) 
 PLA was originally introduced by Jedrzejowicz (1999). The PLA is a population-based method 
inspired by analogies to a phenomenon of social education process in which a diminishing number 
of individuals enter more and more advanced learning stages. It possesses the following 
characteristics: (1) A huge number of individuals enter the system, (2) Individuals learn through 
organized environment as well as self study, (3) Learning processes is inherently parallel (different 
learning environments), (4) Learning process is divided into stages, (5) More advanced stages are 
entered by a diminishing number of individuals from the initial population, (6) At higher stage more 
advanced learning and improvement techniques are used, and (7) A final stage is reached by only a 
fraction of the initial population. 
 The proposed PLA consists of an initial stage and three learning stages: 
1. In the initial stage, RBRS-MP is employed to generate a large number of diversified individuals. 
Select the best half of individuals in the population and enter the first stage. 
2. The learning process in the first stage adopts an elitist hybrid evolutionary algorithm. At each 
1.11 2.56 2.43 2.95 3.68 4.33 3.72 6.23 00
0 1 2 3 4 5 6 7 8 9
Random key 
list
 41
4.1 Pairwise Comparison 
C measure (Zitzler and Thiele, 1999) compares two sets directly and indicates coverage of one 
set over another. It does not require any reference points to compute the measure and hence, is not 
sensitive to any external input. Let A and B be the nondominated solutions sets computed by 
algorithms PA and PB, respectively. The measure C(PA, PB) maps the ordered pair (A, B) to the 
interval [0,1], is given by  
||
|     :|),(
B
baAaBbPPC BA
p∋∈∃∈= , 
where ba   p  means that solution a is not dominated by b. If C(PA,PB) equals 1, it would implies 
that all representative solutions found by algorithm PB are covered by those found by algorithm PA. 
In other words, algorithm PB does not produces any solution that is not dominated or not the same 
as any solution produced by PA. Table 25 displays the pairwise comparison results. Apparently, the 
PLA outperforms the others in this metric, and the MP-RBRS ranks the second. 
Table 20. C measure on the four algorithms (in %) 
C measure j.30 j.60 C measure j.30 j.60 
C(PLA,GLS) 88.00 83.93 C(GLS, PSO-LS) 44.00 25.53 
C(GLS,PLA) 11.54 13.21 C(PSO-LS,GLS) 52.00 60.71 
C(PLA, PSO-LS) 88.00 74.47 C(GLS, MP-RBRS) 52.00 26.67 
C(PSO-LS,PLA) 15.38 26.42 C(MP-RBRS,GLS) 40.00 76.79 
C(PLA,MP-RBRS) 100 57.78 C(PSO-LS,MP-RBRS) 44.44 37.78 
C(MP-RBRS,PLA) 0.00 41.51 C(MP-RBRS,PSO-LS) 40.00 53.19 
4.2 Convergence Measure 
 Three metrics are proposed to measure the closeness of a solution set to a Pareto set or a 
reference set. 
The first metric is error ratio (ER), proposed by Veldhuizen (1999). It is defined as the ratio of 
the number of solutions not contained in the reference set over the number of representative 
solutions found by the algorithm. The drawback of this measure is that it will not reflect a true 
performance when the reference set is not large and dense enough. The second metric is overall 
nondominated vector generation ratio (ONVGR; Van Veldhuizen, 1999), which is similar to the first 
one, except that the denumerator is replaced with the number of solutions in the reference set. The 
third one is generational distance (GD; Deb, 2002), which is defined as follows: 
GD(A)=
| |
1
| |
A
i
i
d
A
=
∑
, where 
 
2
2
| *|
1
1 max min
P
i j
k
i j
k kd Min
k k
f f
f f
=
=
=
⎛ ⎞−∑⎜ ⎟−⎝ ⎠
 
In the above mathematical expressions, A is the representative solution set found by a proposed 
algorithm, maxkf  and minkf  are the maximum and minimum function values, respectively, of kth 
 43
5. CONCLUSIONS AND FUTURE RESEARCH 
  This paper studies the discrete makespan/cost tradeoffs RCPSP with an aim to provide the project 
management with a set of competitive alternatives when negotiating projects with clients. The 
problem solving approach comprises two phases: (1) construct a main algorithm framework, and (2) 
select an algorithm that will work efficiently and effectively under this framework. Four algorithms 
are proposed to solve the RCPSP with the objective of minimizing project makespan. An 
experiment was conducted to test which composite algorithm will provide the most satisfactory 
result to the project management. The experimental results show that the new hybrid approach, 
population learning algorithm, performs better than the other three algorithms, particle swarm 
optimization, genetic local search, regret-based biased random sampling multi-pass, in terms of 
pairwise comparison as well as convergence measure. However, the spread metric does not reveal 
any significant difference in diversity between the four algorithms. 
  This study is focused on developing a promising algorithm for solving the single-mode time/cost 
tradeoffs RCPSP. A more attractive research work would be to extend the current study to a 
multi-mode case; i.e., each activity has two or more execution options due to resource/resource and 
resource/duration tradeoffs. Such problems, regardless of whether the resource types are discrete, 
continuous, or mixed, are much more challenging and useful in practice. 
ACKNOWLEDGMENT 
This research was supported by the National Science Council in Taiwan under grant NSC 
95-2221-E-155-045. 
APPENDIX 
30 jobs
30
40
50
60
70
80
90
100
50 60 70 80 90 100 110 120 130 140
Makespan
Re
so
ur
ce
 C
os
t GA
PSO
MP
PL
 
Figure 11. Time/cost tradeoff curve of a 30-job example 
60 jobs
35
45
55
65
75
85
95
105
115
125
135
145
155
165
175
185
195
205
215
50 65 80 95 110 125 140 155 170 185 200 215 230 245 260 275 290 305
Makespan
Re
so
urc
e C
os
t PL
MP
PSO
GA
 
Figure 12. Time/cost tradeoff curve of a 60-job example 
 45
Vanhoucke, M., Demeulemeester, E. and Herroelen, W. (2002). Discrete time/cost trade-offs in 
project scheduling with time-switch constraints. J Oper Res Soc, 53(7): 741-751. 
Waligóra, G. (2008). Discrete-continuous project scheduling with discounted cash flow – A tabu 
search approach. Comput Oper Res, 35: 2141-2153. 
Yamashita, D.S. and Armentano, V.A. (2006). Laguna M. Scatter search for project scheduling with 
resource availability cost. Eur J Oper Res, 169: 623-637. 
Zitzler, E. and Thiele, L. (1999). Multiobjective evolutionary algorithms: a comparative case study 
and the strength pareto approach, IEEE T Evolut Comp, 3(4): 257-271. 
 
