tablets, are gaining strong demands recently with the 
advances in processors, memories, storages, 
communication networks, and software applications. 
However, due to their limited form factors and 
battery capacities, the current generation of smart 
mobile devices cannot yet fulfill the requirements of 
sophisticated applications. Leveraging a cloud 
service to offload the application 
workload can potentially overcome these limitations. 
In the report, we enhance our previous works on 
mobile-cloud computing by extending the programming 
model on Android smartphones with a flow-based 
programming paradigm to provide more flexibility for 
application migration. For properly provisioning the 
resources and making smart decisions based on the 
performance gain, we add a profile-based policy 
manager and profiling service into our framework to 
enable a dynamic offload scheme. 
 
英文關鍵詞： pervasive computing, smartphone, virtualization, 
cloud services, security, privacy 
 
安全無縫之虛擬化行動雲端運算-子計畫二：行動應用軟體之虛擬化雲端執行環境(I) 
 2 
一、計畫成果摘要 
近年來，由於處理器、記憶體、存儲裝置、通訊網路及應用軟體技術的演進，智慧型裝置如智慧型手
機及平板電腦正取得用戶強勁需求。然而，受限於其體積大小及有限的電池容量，現有的智慧型裝置
仍然無法滿足複雜應用的要求，利用雲端服務來移轉智慧型裝置的應用負載可以克服這樣的限制。 
針對行動應用的需求，雲端服務必須具備高動態、高彈性、安全及高效能等特性，才能進一步提昇行
動應用的品質。本子計畫提出的行動應用的虛擬化以及安全的雲端執行環境，即是對於上述問題的解
決方案。為了做到協同分工模式，我們建立一種基礎架構，讓用戶得以完全控制其行動應用程式，做
到在任何時間、任何地點都能迅速地透過行動網路和虛擬化技術來轉移到雲端執行環境，讓既有及新
的應用程式均可自動化地運用雲端運算的優勢來強化行動應用。所需的技術，包括快速應用程式轉移
機制、高效率的虛擬化應用執行環境，讓用戶得以在雲端使用基礎架構服務建立其個人虛擬手機，並
可以在實體及虛擬手機間轉移各種應用程式，幫智慧型手機節省電源的消耗。 
在本計畫中，我們開發一種利用 Android 應用程式特性及基於資料流(Flow Based)的程式設計模式來提
供更具彈性的應用負載移轉方法。另外，為達到有效率的動態移轉決策(Dynamic Code-offloading)，我
們利用資源監控(Resource Monitor)及主機、應用程式性能剖析服務(Profiling Service)，透過決策管理模
組(Policy Manager)來運算其最佳移轉計畫(Migration Plan)。 
在第一年的計畫中，我們已經開發上述虛擬化雲端執行環境所需的技術，包括快速的應用程式轉移
(application migration)機制以及高效率的虛擬化應用執行環境，使得 Android 智慧型手機上的應用程
式，可以不經過修改，即可快速地轉移到雲端上執行。從計畫開始迄今，我們陸續發表了五篇國際期
刊和國際會議論文，其中包含兩份 SCI 期刊。此外，我們以虛擬化和應用轉移技術初步實作成果參加
嵌入式系統研究最負盛名的 ESWEEK 國際會議所舉辦的 Android Competition，打進決賽，在會議中發
表成果；還有以合作式應用為主題的實作成果參加經濟部工業局舉辦之「2011 通訊大賽-Android 使用
者介面設計競賽」，獲得 Qualcomm 企業獎。 
註記: 由於本子計畫所屬之整合計畫在第二年申請時因為審查通過之子計畫件數未達子計畫總數之三
分之二而未通過，因此本子計畫的第二年申請案在初審時雖獲通過，終究未獲得補助，遺憾之餘，本
人希望藉此機會感謝國科會的補助與評審委員的寶貴意見。 
 
安全無縫之虛擬化行動雲端運算-子計畫二：行動應用軟體之虛擬化雲端執行環境(I) 
 4 
三、計畫得獎成果 
本計畫所產出之成果除學理創新之外，亦以在實際系統上完成實作、測試、評估，具有實用價值。因
此，我們已計畫成果參與國際與國內競賽，得到相當不錯的成績。 
1. 我們以虛擬化和應用轉移技術初步實作成果參加嵌入式系統研究最負盛名的 ESWEEK 國際會議所
舉辦的 Android Competition，打進決賽，在會議中發表成果，作品內容相關資料請參考附件 6。 
Shih-Hao Hung, Jeng-Peng Shieh, Yong-Wei Chen, Hung-Rei Chen, and Cheng-Lei Tan, Virtualizing 
and Migrating Android Applications, Final Teams of Android Competition in Embedded Systems Week 
(ESWEEK) 2011, Oct. 2011, Taipei, Taiwan. http://estimedia.itec.uka.de/ContestProgram.html 
2. 以合作式應用為主題的實作成果參加經濟部工業局舉辦之「2011 通訊大賽-Android 使用者介面設計
競賽」，獲得 Qualcomm 企業獎，作品內容相關資料請參考附件 7。 
洪士灝指導陳勇偉、陳泓叡、陳清禮參加經濟部工業局舉辦之「2011 通訊大賽-Android 使用者介面
設計競賽」作品「智慧型裝置合作系統」，入圍決賽並獲得 Qualcomm 企業獎，2011 年十月。
http://www.mobilehero.com/ 
 
安全無縫之虛擬化行動雲端運算-子計畫二：行動應用軟體之虛擬化雲端執行環境(I) 
 6 
2. Related Work 
Many previous works upon code offloading focused their research on different issues, for examples, 
migration levels, program partitioning, and network bandwidth. Process migration and VM migration are two 
different levels of migration by transferring the memory image of process or VM. The ISR system [20] 
emulated the capabilities of suspend/resume functions in a computer system and migrated the system by 
storing the snapshot image of a virtual machine in a distributed storage system. Live VM migration [7] enables 
rapid movement of interactive workloads within clusters and data centers by integrating live OS migration 
into the Xen virtual machine monitor, and allows migration to proceed with minimal impact on running 
services by dynamic network-bandwidth adaptation. Duo to the cost of communication overhead, the 
approach does not fit to the mobile network.  
To reduce the drawback of migrating whole memory image, many prior works researched on the methods 
of partitioning or re-designing applications for offloading parts of the application workload remotely. MAUI 
[8] adopted a fine grained offloading by shipping the methods to the cloud infrastructure. Developers are 
involved to annotate methods offloaded. ThinkAir [15] is a framework that makes it simple for developers to 
migrate their smartphone applications to the cloud. It focuses on the elasticity and scalability of the cloud and 
enhances the power of mobile cloud computing by parallelizing method execution using multiple virtual 
machine images. Giurgiu [11] uses AlfredO [18] to carry out the physical distribution of an application’s 
modules between a mobile phone and a server. They discuss how to model applications as a consumption 
graph, and how to process it with a number of novel algorithms to find the optimal distribution of the 
application modules. CloneCloud [5] envisioned five categories of augmented execution for transforming the 
execution on a weak device into a distributed execution so that computation intensive tasks could be run in the 
cloud. The offloading decision is based on cost policies concerning optimization of execution time, energy 
consumption, monetary cost with the schemes such as static program analysis, dynamic program profiling and 
optimization solver.  
Cuckoo [14] simplifies the development of smartphone applications that benefit from computation 
offloading by a java stub/proxy model and provides a dynamic runtime system, which can, at runtime, decide 
whether a part of an application will be executed locally or remotely. Cloudlet [19] lets mobile users 
seamlessly utilize nearby computers to obtain the resource benefits of cloud computing without incurring 
WAN delays and jitter. A mobile user exploits virtual machine technology to rapidly instantiate customized 
service software on a nearby cloudlet. Spectra [9] [4] proposed to monitor the current resource availability 
and dynamically determine the best remote execution plan for an application. Cyber foraging [4] used 
surrogates to improve the performance of interactive applications and distributed file systems on mobile 
clients.  
Compared to these related works, VPaaS [13] provides a live migration scheme that is both transparent and 
lightweight, and supports remote execution of existing Android applications on a personal cloud. To further 
support dynamic offloading, we incorporate our VPA tools [12] to estimate and analyze the execution time 
and energy consumption of applications with the virtual machines in the cloud.  
安全無縫之虛擬化行動雲端運算-子計畫二：行動應用軟體之虛擬化雲端執行環境(I) 
 8 
 
Figure 1: Architecture of profile-based application migration 
3.2. The Agents 
User Agent (UA) is a program running as a deamon on the Linux OS. As Figure 2 shows, UA is in charge 
of offloading workload, maintaining a secure environment, monitoring the device, and collecting the profiling 
data. And it provides an interface to help the user to control the deployment of the cloud environment and to 
migrate the execution of applications onto the cloud environment.  
 
Figure 2: The architecture of User Agent 
 
We provide a GUI which is shown in Figure 3 to the UA that is provided to the user to manually migrate 
Android applications. The framework should take care of the burden of securing the data stored in the cloud 
environment and protecting the communication traffics between the cloud environment and the mobile device.    
We also provide an API which is provided to the developer for automatic, dynamic offload. Android 
applications may contact the UA via the socket to migrate itself to another Android system or to see if the 
hotspots can be accelerated. All in all, UA is responsible for communicating with the cloud site. The tasks 
include sending the data message and inquiring the cloud environment to determine whether migrate or not. 
And it also supports service discovery, and resource management with the framework. 
安全無縫之虛擬化行動雲端運算-子計畫二：行動應用軟體之虛擬化雲端執行環境(I) 
 10 
from the policy manager. If the kernel function is migrated, the method will be invoked on the cloud site by 
using Java reflection and serialization mechanism, else the method will be executed on the local. For 
receiving the results, assume the method return an integer array, we just use the API as int[] GetResult() to 
receive the return value from the cloud. 
3.5. Flow-Based Programming 
Flow-Based Programming is a new/old approach to application development, based on a completely 
different way of thinking about building applications. Some of its roots can be traced all the way back to the 
early days of computing, yet it offers solutions to many of the most pressing problems facing application 
development today. In Flow-Based Programming (FBP), applications are defined as networks of ”black box” 
processes, which exchange data across predefined one-way connections. These black box processes can be 
reconnected endlessly to form different applications without having to be changed internally. It is thus 
naturally component-oriented, and this component-oriented feature is suitably for migration. The high level 
schematic diagram is shown in Figure 4. The main declarations of FBP are network declaration and 
component declaration. Network declaration specifies the connectivities between boxes, and component 
declaration specifies the input/output of each box. To define a component, the developers can develop the 
Java application as usual and only remember to declare the annotation. In our work, we extended the 
programming model on Android smartphones with JavaFBP [17], which is a Java implementation of 
Flow-Based Programming. 
To declare a FBP network, JavaFBP provides the following methods: 
 component: define an instance (an FBP ”process”) of a component. 
 connect: define a connection between components. 
 initialize: define a connection with an initial data. 
 port: define a port on a process (component). 
 
Figure 4: The schematic diagram of FBP network 
 
For example, assume we develop an application, Object Recognition, we can design the workflow as  
Figure 4. The details of the Object Recognition application are described in section 4.2.  
To illustrate the features, in the initial, component Shot Detection receives the message from the port IN. 
安全無縫之虛擬化行動雲端運算-子計畫二：行動應用軟體之虛擬化雲端執行環境(I) 
 12 
based on the candidates, the framework determines the execution flow by integrating the ADSET. After 
making the migration plan, the PM sends the plan back to the UA, and then the application will be executed 
on the local or the cloud site according to this plan. Finally, the real profile is fed back to the cloud after the 
offloading tasks are completed. Note that when PM is given a set of available servers, it checks the PD. If PD 
has a previously optimized plan which matches the demand of the user, it will send the migration plan to the 
UA, Otherwise, the PM determines the plan in the runtime using a conservative algorithm based on 
worst-case execution time and network bandwidth.  
 
Figure 7: The flowchart of mechanism for making the migration plan 
 
When the user requests a service to offload the jobs from the physical phone, the PM will select the proper 
servers in the cloud as the candidates. In our framework, we monitor the available resources of the machines 
in the cloud, include CPU utilization, available memory, available bandwidth, network latency, and file 
access.  
4. Experimental Results and Evaluation 
In this section, we develop an application as a case study to show the scenario that how the mobile devices 
interact with the cloud, and demonstrate the benefits if the application developer uses our proposed 
framework. And we design three experiments to illustrate the feasibility of the framework. The experiments 
are refactoring and accelerating an object recognition (OR) program with VPaaS, profiling the OR program 
with VPA, and optimizing the execution flow with ADSET.  
4.1. Application Scenario 
There is a typical scenario as follows. Today, people use mobile devices to take pictures and make videos 
all the time. In any tourist attractions and occasion, it is convenient to use mobile devices to record and 
commemorate the moment, and it will produce more and more data and files. Then we will find that the 
storage is exile very soon. Moreover, if we want to discover the video fragments or the pictures from the large 
amount of files, or search the objects which appear in the films and pictures, we will spend a lot of time to 
inquiry, and it may not be able to find the targets.  
安全無縫之虛擬化行動雲端運算-子計畫二：行動應用軟體之虛擬化雲端執行環境(I) 
 14 
 
Figure 8: The workflow of object recognition application 
4.3. Evaluation 
In this section, we prototype the object recognition (OR) application for evaluation, as Figure 8 shows, the 
input is a query image, and the output is the target images which has the object. We measure the proposed 
framework by using two experiments. In the first experiment, we compare the execution time between local 
and remote execution. And in the second experiment, we profile the OR program with VPA. On the client site, 
we use different physical phones as the experimental platforms. On the cloud site, we use VM-based 
(VirtualBox [3]) Android x86 [1] server and native Linux x86 server as the execution environment for remote 
execution. The details of the experimental platform configurations are shown in Table 1. And we measure the 
networks for three configurations, Wi-Fi 802.11g, Wi-Fi 802.11n, and 3G networks. Wi-Fi 802.11g is 
measured by HTC G1; Wi-Fi 802.11n and 3G network are measured by Nexus S. And the TCP window size 
is 16KB by default. Table 2 shows the network conditions in our experiment environment. 
Table 1: The Experimental Platform Configurations 
 
Table 2: The Network Conditions 
 
安全無縫之虛擬化行動雲端運算-子計畫二：行動應用軟體之虛擬化雲端執行環境(I) 
 16 
B. The comparison of Local and Remote execution 
At first, we set up our experiment as follow. For the application input, it is originally on the physical phone 
and sent to the Virtual Phone. We take an image of 200*200 pixels, 13.7KB as the query image, and we 
down-sized the target image (one key frame) to 235*176 pixels, 20.9KB. For the output, the Virtual Phone 
sends back the coordinate of the object (the size of the output is about 40 Byte), and the object of target image 
is tagged.  
The reason for why we only use small images to evaluate is every different Android smartphone that has 
different heap size. It may happen the out of memory error for the Android smartphone with small heap size. 
In the other words, it is an obvious advantage that we offload the heavy workloads to the cloud which the 
physical phones cannot afford.  
Next, In order to compare the performance between local and remote execution and discuss the factors (e.g., 
network, server configuration, etc.) which may affect the execution time, we run the OR program with a 
different search window size on each platform for 20 times respectively. For the cloud site with Android x86, 
Figure 11 shows the evaluation results, we are able to find that when increase the range of search window size, 
the differences in performance will become more and more obvious. For practicality, each physical phone has 
different performance, and most of the physical phones are only capable of executing the simple tasks. It 
shows that migrating the works to the cloud is a feasible approach. And we also add the factor of the network 
conditions, in this case, the network overhead only hurts the performance slightly, and it still works under the 
3G networks. Due to the performance of Android x86 is still not fast enough when the range of window size is 
bigger, so we consider migrate the workload to the native machine.  
 
Figure 12: The evaluation results of the OR program by VPaaS with the Native Machine 
Figure 12 is the evaluation results when using native machine as the execution environment in the cloud. It 
shows that executing on the native machine improves performance significantly in most cases. The reason for 
why the native machine improves the performance much better than physical phones and Android x86 is that 
except for the computing power and the virtual machine overhead, there are much difference between Java 
Virtual Machine and Dalvik Virtual Machine. Dalvik VM is register-based architecture, designed to run on 
安全無縫之虛擬化行動雲端運算-子計畫二：行動應用軟體之虛擬化雲端執行環境(I) 
 18 
[16] LAMPERT, C. Detecting objects in large image collections and videos by efficient subimage retrieval. In 
Computer Vision, 2009 IEEE 12th International Conference on (29 2009-oct. 2 2009), pp. 987 –994. 
[17] MORRISON, J. P. Flow-Based Programming, 2nd Edition: A New Approach to Application 
Development. CreateSpace, 2010. 
[18] RELLERMEYER, J. S., RIVA, O., AND ALONSO, G. Alfredo: an architecture for flexible interaction 
with electronic devices. In Proceedings of the 9th ACM/IFIP/USENIX International Conference on 
Middleware (2008), Middleware ’08. 
[19] SATYANARAYANAN, M., BAHL, P., CACERES, R., AND DAVIES, N. The case for vm-based 
cloudlets in mobile computing. Pervasive Computing, IEEE 8, 4 (oct.-dec. 2009), 14 –23. 
[20] SATYANARAYANAN, M., GILBERT, B., TOUPS, M., TOLIA, N., SURIE, A., O’HALLARON, D. 
R., WOLBACH, A., HARKES, J., PERRIG, A., FARBER, D. J., KOZUCH, M. A., HELFRICH, C. J., 
NATH, P., AND LAGAR-CAVILLA, H. A. Pervasive personal computing in an internet suspend/resume 
system. IEEE Internet Computing 11, 2 (2007), 16–25. 
[21] SIVIC, J., AND ZISSERMAN, A. Video google: a text retrieval approach to object matching in videos. 
In Computer Vision, 2003. Proceedings. Ninth IEEE International Conference on (oct. 2003), pp. 
1470 –1477 vol.2. 
[22] ZHANG, L., TIWANA, B., DICK, R., QIAN, Z., MAO, Z., WANG, Z., AND YANG, L. Accurate 
online power estimation and automatic battery behavior based power model generation for smartphones. 
In Hardware/Software Codesign and System Synthesis (CODES+ISSS), 2010 IEEE/ACM/IFIP 
International Conference on (oct. 2010), pp. 105 –114. 
 
安全無縫之虛擬化行動雲端運算-子計畫二：行動應用軟體之虛擬化雲端執行環境(I) 
 20 
 
 
 
 
附件1 
Developing Collaborative Applications with Mobile Cloud YS Chang and SH Hung
cloud-based Internet services. On the other side, it is a heavy burden for a service provider to ensure that
user data are absolutely secure, when the user data are frequently replicated and populated all over the
cloud infrastructure. For example, Facebook has long been criticized for privacy risks.
So far, we have yet to see collaborative mobile cloud applications which could dynamically migrate
the workload to efficiently take advantage of the resources in the cloud. On the system side, the software
infrastructure of today’s mobile cloud computing environment is not sophisticated enough to mitigate the
problems mentioned above. Application migration schemes, workload offloading mechanisms, efficient
distributed file access/sharing, and trust models are among the active research topics for improving the
software infrastructure. The related technologies will be discussed in Section 2.
On the application side, it is difficult for developers to come out of innovative collaborative ap-
plications due to the lack of experiences, programming tools, paradigms, and examples. Traditional
client-server models have been successfully used for mobile applications to leverage the services in the
cloud, but we hope to do better in the age of mobile cloud computing. First, application partitioning and
deployment of services should dynamically adapt to the resources available in the set of mobile devices
and the cloud servers (a.k.a. mobile cloud). The users should be able to deploy their own personal cloud
services on-demand on the computer nodes that they can trust with personal data. In addition to shar-
ing data conveniently and securely, applications may be migrated or distributed from one computer to
another to encourage close collaboration.
In Section 3, we discuss the kernel-offload paradigm for collaborative mobile cloud applications. We
attempt to come out of a paradigm to guide us in the design of the following: the system architecture, the
principle for partitioning applications, the method for offloading computation, and the control policy for
data access.
In Section 4, we illustrate the paradigm with a case study. We first show the design of our cloud-
assisted speech recognition (CSR) service and then we explain the implementation of the CSR based
on the collaborative application paradigm. Performance evaluation is critical to the application of a
paradigm, so we characterize the performance of the CSR by analyzing the latency, the power cost, and
the privacy issues associated with the service. Finally, in Section 5, we conclude this paper and discuss
the potential future work.
2 Related Work
It was shown in earlier work that remote execution saved a large amount of power for mobile computers
[10, 21, 17]. While there were different approaches proposed, program partitioning for remote execution
has been a challenge for researchers. Spectra [12] proposed to monitor the current resource availability
and dynamically determine the best remote execution plan for an application. Cyber foraging [7] used
surrogates to improve the performance of interactive applications and distributed file systems on mobile
clients. MAUI [11] proposed to reduce the programming efforts by automating program partitioning
with the combination of code portability, serialization, reflection, and type safety.
Without application partitioning, methods have been developed to migrate the entire application ex-
ecution to a remote server. Process migration and virtual machine migration have been two common
approaches to migrate execution across the network. The ISR system [23] emulated the capabilities
of suspend/resume functions in a computer system and migrate the system by storing the snapshot im-
age of a virtual machine in a distributed storage system. Zap [20] introduced a pod (PrOcess Domain)
abstraction, which provided a collection of processes with a host-independent virtualized view of the
operating system, so as to support a general-purpose process migration functionality, but it did not allow
live migration. Live VM migration [16] achieved rapid movement of workloads within clusters and data
centers with minimal service downtime by continuously pre-copying page changes in a virtual machine
19
Developing Collaborative Applications with Mobile Cloud YS Chang and SH Hung
• The kernel functions perform the work specified by the work flow in each step. Each kernel
function may apply one or multiple algorithms to carry out the computation with one or multiple
processors and access the data available on the mobile device or on the cloud. The local variables
declared in a kernel function as well as the temporary buffers used by the kernel function compose
the local state of the kernel function.
In today’s mobile applications, the main program running on the mobile device controls the UI and
the work flow. The application may perform one kernel function at a time or perform multiple kernel
function simultaneously with multiple processes and threads. Multithreaded applications are common for
the Android systems. On the other hand, cloud applications often refer to those applications which utilize
cloud services to carry out part of the application workload. The partitioning of the application workload
is usually fixed in a typical cloud application, where the programmer has to partition the applications and
work with a service provider to deploy the cloud service in advance. Often, a cloud-based applications
simply has the UI running on the mobile device and have the rest of the application handled by a cloud
service, which is essentially a client-server model.
Moreover, many of today’s cloud applications merely use existing services available in the cloud.
Thanks to the infrastructure technologies of cloud computing, there are more and more services available
to the users for low or no charges. Application developers also benefit from such services as they simply
need to follow the API’s created by the provider to leverage the services. In practice, some service
providers require or encourage the users to register their own accounts before using the services. This
has raised privacy issues. Even when registration is not required, the service provider may still record the
transactions with information collected by client program. For example, Google Maps APIs [2] allow the
programmers to embed the functionality of the Google Maps service into their applications. The use of
Google Maps is free, but the location information of the user along with other personal information are
exposed to Google unless the user explicitly takes actions to forbid the client program from collecting
and sending the information out. Even if we trust Google for now, there are numerous examples for
mobile applications like the above, so what can we do besides not to use those services?
We believe that some of the public services are important and should be operated by trustworthy
providers to reduce the security and privacy risks, but some users would still be hesitate to trust the
providers. To further prevent the leak of personal information, proxy or firewall can be invoked by the
user to filter the outbound information or block the entire service. However, it is tedious for the user to
configure the filtering mechanism, especially when mobile applications and cloud services are frequently
updated.
On the other hand, when a developer decides to offload a kernel function to the cloud, the developer
first need to define and create an interface for the service to offload the function, i.e. offload service.
Then, the developer needs to implement the offload service and packages it as a server program. The
developer can work with a service provider to deploy the server program. Cloud computing technologies,
such as the Google App Engine (GAE) [1], speed up the deployment and management of such services
for individual developers, so that we see new cloud-based services coming out everyday. In the case
of GAE, in addition to Google, the developers also participate in the operation of the service and have
access to the user’s personal information. Again, this has raised privacy issues.
Of course, the developer can also distribute the server program as a part of the application to the user,
so that the user may install the service on their own. However, how many users have the resources and
are capable of installing the service on their own? First, the user needs to find a trusted computer on
the network to host the service. Finding a computer would be the easy part, but establishing a trusted
relationship between two computers are not easy, as security mechanisms are needed to protect the
data storage in the remote computer and communications between the two computers. Today, trusted
computing technologies [19] are available, but they are not widely used by mobile cloud applications
21
Developing Collaborative Applications with Mobile Cloud YS Chang and SH Hung
• The accesses to file storage are handled by a user-space distributed filesystem. The use of a dis-
tributed filesystem allows the application on the client and the kernel functions on the server to
access to the same files coherently in the same name space conveniently without modifications.
The offloading advisor may query the distributed filesystem to check the location of a file when
it tries to make a offloading decision. The performance of the distributed filesystem may benefit
from techniques such as caching recently accesses files, prefetching files in advance, or allowing
the offloading advisor or the request handler to control the coherence protocol for specific files.
We believe that the modified client-server architecture paves the road and serves as a paradigm for
the future collaborative mobile cloud applications. There are many research issues in the architecture,
but from application developer’s point of view, this is a viable paradigm.
3.2 Performance Issues and Solutions
For a collaborative application which follows the aforementioned paradigm to deliver good performance
in light of the obstacles mentioned in Section 1, several practical issues need to be resolved. We will
focus on the performance issues in this subsection and leave the privacy and security issues to the next
subsection.
Instead of asking the system infrastructure to handle everything automatically, we believe that appli-
cation developers can contribute significantly in the optimization of application performance by provid-
ing a few hints to guide the system in offloading kernel functions and synchronizing files.
It is critical to have an efficient mechanism for migrating the kernel functions over the network.
Many previous works attempted to migrate the process/thread [23, 20] or the virtual machine [16], but
the overhead of migration can be prohibitively high, especially for mobile networks, since these works
target at migrating the execution at any time.
First, we believe that the ability to migrate an application execution at any time is desirable, but is
unnecessary for developing collaborative applications. Second, it may be overkill and waste of network
bandwidth to migrate the entire application to carry out part of the application remotely.
To reduce the network traffic for remote execution, our paradigm requires that the application de-
veloper to explicitly mark the kernel functions, so that the system may focus on the offloading of a
kernel function at the beginning of the function. The offloading advisor only needs to transfer the input
of the kernel function and the global application state associated with the kernel function to the server,
which can be far less than the migrating the entire application at the middle of a memory-hungry kernel
function.
As far as the file access is concerned, in order to efficiently migrate the data which are needed
immediately, the offloading advisor could give a list of files to the distributed filesystem, so that the
server can try to prefetch the files in advance. Take an Android application for example. We have
designed a set of heuristics for the offloading advisor to prioritize and control the synchronization of
files in the course of application migration. The application developer may override the arrangement if
necessary.
While an Android application is migrated from one machine to another machine, it is necessary
to clone its application states and data in the storage system. A brute-force way for synchronizing
data between two environments is to maintain identical data for all files in their file systems. For that,
the data must be updated as soon as one environment makes changes to any file, which incur network
traffics, and the applications need to wait for the completion of any synchronization operation if a strict
synchronization protocol [8] is used, which would cause a long delay with a mobile network. To mitigate
this problem, we need to look further into the policies for synchronization.
23
Developing Collaborative Applications with Mobile Cloud YS Chang and SH Hung
• The traditional approach refers to the classic design flow for creating an well partitioned appli-
cations with customized protocol and servers for offloading the computation. This approach is
considered to have the best performance and the lowest offloading overhead because the developer
can optimize the protocol with the domain knowledge and the use case, but it takes the most efforts
for developer to design the application.
• The terminal approach has the mobile device performing the UI and the rest of the application
running on the server. As shown in Figure 2, one could easily establish such collaborative scheme
using the Virtual Network Computing (VNC) [4] to display the application’s UI screen and receive
user’s input on the mobile device. Unfortunately, the latencies of wide-area mobile networks
impact the user experience significantly. It is possible to utilize a higher-level event-based display
protocol to improve the performance. While this approach saves the cost of the mobile device,
the user needs to find a trustworthy server to perform the application, and the performance heavily
depends on the quality of the network.
Figure 2: The terminal approach
• The suspend/resume migration approach [15] aims to dynamically migrate the whole process with
its state from the smartphone phone to the cloud. At the server side, a virtualized environment,
a.k.a. virtual phone, is used to support remote execution of Android applications on x86-based
server, as shown in 3. The user may deploy a virtual phone and then migrate applications over to the
virtual phone. For migrating an application, the framework first suspends the current application
on the smartphone, which forces the application to save its state, and then transfers the state to
resume the application in the virtual phone. The size of the state varies, but can be minimized
by the application developer. The main advantage is that the developers do not have to re-design
the application, and it requires one-time deployment cost. However, the software infrastructure is
more complex for the server, and it has to integrate additional mechanisms to deal with interactive
applications.
In summary, each approach has its advantages and disadvantages. While most of today’s mobile
cloud applications belong to the traditional and terminal categories, we believe the suspend/resume ap-
25
Developing Collaborative Applications with Mobile Cloud YS Chang and SH Hung
system is most convenient to the end users, since they need not to participate in the initial training
process. However, the performance of the system is the worst of the three systems.
• Speaker-adaptation ASR (SA-ASR) system: There is a built-in SI HMM template in the system,
and the voice samples of a user can be adopted to fine-tune the configuration of the template
specifically for the user. To the user, one SA-ASR system with a fine-tuned model may have better
accuracy than an SI-ASR system. The major disadvantage is that the user has to provide the system
with their voices, which could be a sensitive privacy issue. Nevertheless, without any fine-tuning,
the performance of the system is exactly as same as an SI-ASR system.
• Speaker-dependent ASR (SD-ASR) system: Each user is required to supply his/her voice for train-
ing a HMM specifically to the user. The SD-ASR system takes time (from a few minutes to half
an hour) to acquire user’s voice and generate a HMM. For a SD-ASR system to support multiple
users, it also requires significantly more data storage space to store the HMM for each user. In
general, the performance of a SD-ASR system is better than the other two systems [14].
Today, most commodity ASR systems favor SI technologies for the convenience of the users, since
they can start using the ASR system without any previous training. While SA/SD-ASR technologies
may be used to improve the recognition accuracy, the user experience is often affected because a time-
consuming training process is needed for the user to apply this method for each device.
On a mobile device of limited resources, a full-strength ASR engine often takes too much time and/or
memory space. While a lightweight ASR engine may be used for recognizing voice commands with
a limited vocabulary within seconds on a low-end mobile phone, demanding interactive applications
such as dictation or gaming require instant responses. Thus, researchers have attempted to improve
the efficiency and accurate of current ASR systems for mobile devices, but sometimes the efficiency
improvement hurts the accuracy, which is a tradeoff in this case [9].
Another factor effecting the accuracy of ASR system on smartphone is to handle the background
noise. In order to deal with the background noise, it increases the computation complexity and computa-
tional resources needed on the mobile device. Thus, it is hard for a mobile device to provide a PC-quality
speech recognition service. While many smartphones today offer some sort of voice recognition capabil-
ities, they work on limited application areas, such as voice dial, voice command, and phonebook search.
It can be beneficial for a mobile device to offload speech recognition onto a server machine to save
execution time and conserve energy [21]. Today, many cloud-based services are offered to with low
amortized operation costs [6]. This client-server model has worked quite successfully over the years. A
well-know example is Google Voice Search [5], which was initially a tool developed by Google Labs
for mobile phone to make a Google query. It has been integrated into Google Maps and Google Mobile
App for the user to interact with the applications using voice. For Google Voice Search to work in an
application, the mobile device records a voice message from the user and sends the recorded message to
the Google’s cloud service. The speech recognition is done completely on the server side to offload the
burden from the mobile device. For the convenience of users, the speech recognition is performed by
SI-ASR, so the users do not need to train their models before using the service.
In order to improve the accuracy, SA/SD-ASR system is considered to be adopted for better user
experience, if users spend time for training their own model. However, it is a time-consuming effort for
users, and we believe they would not be glad to perform it again. In order to address this inconvenience,
we designed an ASR service which allows the applications on a mobile device to offload portions of a
speech recognition task, model training/generation, and the data storage for storing the SA/SD models
the cloud. It also allows multiple devices of the same user to share and populate one stored SA/SDmodel,
so that the user no longer needs to repeat the lengthy training process on each device. This encourages
the use of SA/SD-ASR on mobile devices for better recognition accuracy.
27
Developing Collaborative Applications with Mobile Cloud YS Chang and SH Hung
runtime for data transmission, Tlatency is the latency of the network, and StcpWindowSize is the window size
of TCP. The reduction of execution time Gp due to offloading kernel K is calculated by Equation 3. If
Gp(K)< 1, then offloading kernel K is beneficial to the performance.
Plocal(K) = Tlocal (1)
Po f f load(K) = Tremote+
Srx/tx
Bnetwork
+Tlatency×⌈(1+
Srx/tx
StcpWindowSize
)⌉ (2)
Gp(K) =
Po f f load(K)
Plocal(K)
(3)
Energy consumption is another important factor on the mobile devices. The energy consumption for
executing kernel K locally is expressed in Equation 4, by multiplying the execution time and the averaged
power WCPU−work consumed by the processor during the kernel function. In the case of offloaded exe-
cution, the energy consumption is evaluated by Equation 5, which sums the needed energy to exchange
the data with the server Wnetwork, which usually depends on how many traffic via the network, and the
energy WCPU−idle consumed by processor on the mobile device when it is idle, waiting for the results.
The energy saving rate Gw in Equation 6 denotes the normalized energy consumption of the offloaded
kernel to the one running on local. Gw(K) < 1 indicates that less energy is needed by using offloading
scheme.
Wlocal(K) = Tlocal×WCPU−work (4)
Wo f f load(K) = Tremote×WCPU−idle+Wnetwork(Srx/tx) (5)
Gw(K) =
Wo f f load(K)
Wlocal(K)
(6)
Since both performance and energy consumption affect the user experience, we may combine these
two factors to decide if a kernel function should be offloaded. A model shown in Equation 7 could
be used for modeling the cost-benefit of the offloading operation. Since there is sometimes a tradeoff
between the power consumption and the performance, the user may adjust the weight ρ to favor energy
saving or performance.
D(ρ ,K) = Gρw(K)×G(1−ρ)p (K), where 0≤ ρ ∈ℜ≤ 1 (7)
4.3.1 Performance Impact
Both the traditional and the kernel-offload versions of the recognition client are optimized in the process-
ing logic for overlapping the voice recording process and the voice transmission to shorten the latency,
as shown in Figure 4. The end detector, which is used to detect if the user begins to speak, was started
at first. When the user started to speak, the first segment would be saved in the internal buffer. The
buffer was transmitted to the server after it was filled. After the server received the segment, it passed
to the ASR engine immediately for processing. After all segments were processed, the server checked
the grammar rules and the lexical candidates. Finally, it returned the results to the client. The time used
to process the voice segment and to lexicon/grammar check on the server was very short. In practice,
the latency is dominated by the network time. In our testing environment, the results were shown on the
screen almost immediately after the speaker said a 0.5-second-length word. The delay was less than 0.1
second in both versions. If not to offload the computation burden, the results were shown after about 1.5
29
Developing Collaborative Applications with Mobile Cloud YS Chang and SH Hung
0.3×⌈(1+ 15.7/64)⌉ = 1.17 seconds. Based on the proposed application paradigm, the transmission
could be overlapped by the user’s speaking (0.5 second), so the total execution time for offloading kernel
To f f load would be 1.17−0.5+0.1= 0.77 seconds. For the suspend/resume migration approach, it would
be (15.7+ 0.249)/30.375+ 0.3×⌈(1+(15.7+ 0.249)/64)⌉+ 0.1 = 1.23 seconds. And for terminal
version, it would be (15.7+35.0)/30.375+0.3×⌈(1+(15.7+35.0)/64)⌉+0.1= 2.37 seconds.
4.3.2 Power Consumption Impact
We characterize the power consumption on the client device when the client device switches from the
local ASR engine to the remote ASR engine. Based on the power model of Android smartphone derived
in [27], we derived an equation by considering CPU utilization, and WiFi utilization only as Equation 8,
where ∆cpu and ∆wi f i are the active time (in second) for CPU and WiFi respectively, and the meaning of
other variables are shown in Table 1. To apply the equation, we actually measured the parameters listed
in the table.
We found that the state of the WiFi network is a major factor which affected the power consumption.
There are four states for WiFi: low transmit, high transmit, low state (ls), and high state (hs), and the
state diagram is illustrated as Figure 6. According to the figure, we can find that the WiFi state changes
dynamically by the number of network packets. Once the network packets are less than 8, theWiFi would
change from high state to low state. If the packets are more than 15, it change from low state to high one.
Both of hs and ls state enter the transmit state, which consumes 1000 mW, for 10-15 microseconds per
second if there are data to send, and then return to the original state immediately. Because the time to
transmit less than 15 packets is very short in low state, the power consumption when transmitting packets
in low state is ignored. The WiFi state is controlled by the operating system at runtime.
Figure 6: WiFi Power State Diagram
W (∆cpu,∆wi f i) = ∆cpu× (δutil×βcpu+δon×βbase)
+∆wi f i× (δls×βw f ls+δhs×βw f hs)+δhs× fwi f i(δspeed ,Σpacket) (8)
fwi f i(δspeed ,Σpacket) = Σpacket × (48−0.768×δspeed) (9)
Based on our observation, the number of transmitted network packets in the whole offloading process
was about 9 to 11 for both traditional and our kernel-offload versions, which would not make the WiFi
change the state. In other words, the power consumption depended on the current state of WiFi for using
31
Developing Collaborative Applications with Mobile Cloud YS Chang and SH Hung
performance in this case, which totals the processing time of remote server and the network transmission
time, and then takes away the overlap time of user’s speaking, as shown in Equation 13.
To f f load−ASR = 0.1+
15.7
Bnetwork
+Tlatency× (1+ ⌈ 15.7StcpWindowSize ⌉)−min(
15.7
Bnetwork
,0.5) (13)
The power consumption of 3G UMTS network modeled in previous work [27] depends on only the active
time only with a consuming rate 570 mW per second. Hence, the power model in the ASR case via 3G
network can be expressed by Equation 14.
Wo f f load−ASR = 0.5× (30×4.34+1×121.46)+570× 15.7Bnetwork (14)
Thus, the offloading evaluation model could be calculated by Equation 15, and the relation between the
network bandwidth Bnetwork and the weight ρ of power saving is illustrated as Figure 7 according to the
given equation, where the TCP window size StcpWindowSize is 64 KB, the network latency Tlatency is 300
milliseconds, the network bandwidth Bnetwork is evaluated from 1 Kbps to 128 Kbps, and the weight rho
is from 0 to 1. According to the result, the offloading process is always taken when ρ > 0.700 even the
bandwidth is only 4 Kbps, which causes extreme high latency about 31 seconds for the results, which
we guess this is an unacceptable latency for users which would hurt the user experience. In practice, in
order to control the latency would not be lengthened exceeding 20%, we recommended limited user to
adjust ρ only from 0 to 0.1.
D(ρ ,K) = (
Wo f f load−ASR
Wlocal
)ρ × (To f f load−ASR
Tlocal
)(1−ρ), where Tlocal = 1.5 (15)
Figure 7: The relation between the weight of power saving and the network bandwidth for the ASR case
33
Developing Collaborative Applications with Mobile Cloud YS Chang and SH Hung
[11] Eduardo Cuervo, Aruna Balasubramanian, Dae-ki Cho, Alec Wolman, Stefan Saroiu, Ranveer Chandra, and
Paramvir Bahl. MAUI: making smartphones last longer with code offload. In Proc. of the 8th International
Conference on Mobile Systems, Applications, and Services (MobiSys’10), New York, NY, USA, pages 49–62.
ACM Press, June 2010.
[12] Jason Flinn, Dushyanth Narayanan, and M. Satyanarayanan. Self-tuned remote execution for pervasive com-
puting. In Proc. of the 8th Workshop on Hot Topics in Operating Systems (HotOS’01), Elmau/Oberbayern,
Germany, pages 61–66. IEEE, May 2001.
[13] Scott Garriss, Ra´mon Ca´ceres, Stefan Berger, Reiner Sailer, Leendert van Doorn, and Xiaolan Zhang. Trust-
worthy and personalized computing on public kiosks. In Proc. of the 6th International Conference on Mobile
Systems, Applications, and Services (MobiSys’08), New York, NY, USA, pages 199–210. ACM Press, June
2008.
[14] X. Huang and K.F. Lee. On speaker-independent, speaker-dependent, and speaker-adaptive speech recogni-
tion. IEEE Transactions on Speech and Audio Processing, 1(2):150–157, April 1993.
[15] Shih-Hao Hung, Tei-Wei Kuo, Chi-Sheng Shih, Jeng-Peng Shieh, Chen-Peng Lee, Che-Wei Chang, and Jie-
Wen Wei. A cloud-based virtualized execution envrionment for mobile applications. ZTE Communications,
9(1):15–21, 2011.
[16] Christopher Clark Keir, Christopher Clark, Keir Fraser, Steven H, Jacob Gorm Hansen, Eric Jul, Chris-
tian Limpach, Ian Pratt, and Andrew Warfield. Live migration of virtual machines. In Proc. of the 2nd
ACM/USENIX Symposium on Networked Systems Design and Implementation (NSDI’05), Boston, Mas-
sachusetts, USA, pages 273–286. ACM Press, May 2005.
[17] K. Kumar and Yung-Hsiang Lu. Cloud computing for mobile users: Can offloading computation save energy?
Computer, 43(4):51–56, April 2010.
[18] C. Lattner and V. Adve. LLVM: a compilation framework for lifelong program analysis transformation. In
Proc. of the International Symposium on Code Generation and Optimization (CGO’04), Palo Alto, Califor-
nia, USA, pages 75–86, March 2004.
[19] Chris Mitchell, editor. Trusted Computing. The Institution of Engineering and Technology, 2008.
[20] Steven Osman, Dinesh Subhraveti, Gong Su, and Jason Nieh. The design and implementation of Zap: A
system for migrating computing environments. In Proc. of the 5th Symposium on Operating Systems Design
and Implementation, Boston, Massachusetts, USA, pages 361–376, December 2002.
[21] Alexey Rudenko, Peter Reiher, Gerald J. Popek, and Geoffrey H. Kuenning. Saving portable computer
battery power through remote process execution. ACM SIGMOBILEMobile Computing and Communications
Review, 2(1):19–26, January 1998.
[22] Mahadev Satyanarayanan, Paramvir Bahl, Ramo´n Caceres, and Nigel Davies. The case for VM-based
cloudlets in mobile computing. IEEE Pervasive Computing, 8(4):14–23, October 2009.
[23] Mahadev Satyanarayanan, Benjamin Gilbert, Matt Toups, Niraj Tolia, Ajay Surie, David R. O’Hallaron,
Adam Wolbach, Jan Harkes, Adrian Perrig, David J. Farber, Michael A. Kozuch, Casey J. Helfrich, Partho
Nath, and H. Andres Lagar-Cavilla. Pervasive personal computing in an Internet suspend/resume system.
IEEE Internet Computing, 11(2):16–25, 2007.
[24] J.E. Stone, D. Gohara, and Guochun Shi. OpenCL: A parallel programming standard for heterogeneous
computing systems. Computing in Science Engineering, 12(3):66–73, May-June 2010.
[25] Michael Stonebraker, editor. Readings in database systems. Morgan Kaufmann Publishers Inc., San Fran-
cisco, CA, USA, 2nd edition, 1994.
[26] Li Xiong and Ling Liu. PeerTrust: supporting reputation-based trust for peer-to-peer electronic communities.
IEEE Transactions on Knowledge and Data Engineering, 16(7):843–857, July 2004.
[27] Lide Zhang, Birjodh Tiwana, Zhiyun Qian, ZhaoguangWang, Robert P. Dick, ZhuoqingMorleyMao, and Lei
Yang. Accurate online power estimation and automatic battery behavior based power model generation for
smartphones. In Proc. of the 8th IEEE/ACM/IFIP International Conference on Hardware/Software Codesign
and System Synthesis (CODES/ISSS’10), Scottsdale, Arizona, USA, pages 105–114. ACM Press, Octoboer
2010.
35
安全無縫之虛擬化行動雲端運算-子計畫二：行動應用軟體之虛擬化雲端執行環境(I) 
 21 
 
 
 
 
 
附件2 
 
 
 
applications, we used Android [6] as our case study and 
developed several strategies. Being able to support live 
migration of existing Android applications without code 
modifications was a challenge for us. Section II overviews the 
Android development framework, outlines the lifecycle for 
Android applications, and discusses the related research 
works. 
First, an innovative coarse-grain application migration 
mechanism was developed based on application-level 
state-saving mechanisms available on the Android operating 
environment. Second, we further categorized the types of 
application data to decide on the necessity and the priority for 
data synchronization. In addition to offloading workload from 
a physical environment, the virtual environment presents 
opportunities to enhance the functionalities of the execution 
environment. For example, file sharing, automatic data 
backup and virus checking are additional functions that could 
be performed by the virtual environment in the background. 
Section III discusses the framework and the virtual 
environment that we proposed to enhance Android 
applications. 
For mobile devices and cloud servers to work 
collaboratively without jitter, being aware of the quality of 
communication channels and providing the quality-of-service 
(QoS) guarantee on that is one of the fundamental 
requirements. Toward collaborative computing [7], we 
believe that the execution framework can be enhanced by a 
QoS guaranteed communication framework in our approach. 
To provide better compatibility to the operating systems and 
application, the communication framework creates several 
virtual network devices in the virtualized framework. Each of 
the virtual network devices provides a specific QoS 
guaranteed communication channel. Hence, the control 
messages can be transmitted over a low-bandwidth channel 
with high transmission probability. We will cover the system 
architectures and design of the probabilistic QoS gurantted 
communication framework in Section IV. Finally, we 
summarize our findings and conclude this paper in Section V. 
II. BACKGROUND AND RELATED WORKS 
A. The Android Development Framework 
By July of 2010, there had been more than 100000 
applications developed for Android as claimed by AndroLib 
[8]. As an optimization for smartphone applications, the 
Android operating environment manages applications 
differently from traditional operating environments. An 
important aspect is that the Android system may kill a process 
when the system falls short of memory. To decide which 
processes to kill, Android places each process into an 
importance hierarchy with the running components and its 
states. The five levels in the hierarchy are listed in the 
following, with their importance from high to low: (1) A 
foreground process interacts with the user, and they would be 
killed only when the available memory on the system is too 
low. (2) A visible process does not have any components, but 
affects what the user sees. It is still important to keep it alive 
unless necessary to free resource for foreground one. (3) A 
service process is a running service that does not belong to the 
above two categories. They will be killed to favor two higher 
processes. (4) A background process holds an activity 
invisible to the user, which does not have any direct impact on 
the user experience. It would be killed to reclaim resource for 
the above three types of processes with an LRU list to ensure 
that the most recent activities would not be killed. (5) An 
empty process does not associate with active components, 
which are often killed to balance the system workload.  
 Figure 1 Illustration of the lifecycle for an Android 
application activity 
The life cycle of an activity is illustrated in Figure 1, where 
seven methods are involved with three nested loops: 
• The entire lifetime of an application begins with the 
onCreate() method to perform initialization and ends with 
the onDestroy() method to release allocated resources.  
• The visible lifetime is between onStart() and OnStop(), 
where the user can see the activity on-screen, whether the 
application is in the foreground or not.  
• The foreground lifetime is between onResume() and 
onPause(), where is the point we are interested at. During 
this time, the activity is active and shown on the screen and 
is interacting with the user. 
To conserve the energy on a smartphone, the Android 
operating environment suspends an application when the 
smartphone goes to sleep or when a new activity is issued. 
21
 
 
 
environment and create a virtual one? How to minimize the 
time required to migrate an application over a mobile 
network? How to minimize the costs for sharing and 
synchronization of data between two environments? How to 
secure the virtual environment?  
In this section, we introduce the framework that we 
developed for Android users to offload applications to virtual 
environments in the cloud. The framework automates the 
creation of a virtual environment and migrates live Android 
application faster than traditional methods. Compared to a 
conventional scheme, our approach does not require the 
developers to redesign their applications, and we offer several 
effective techniques to migrate applications and data over a 
mobile network, with security measures included to address 
security and privacy issues.  
 
 
Figure 2 Creating a Virtual Environment 
A. Our Proposed Framework 
In our migration framework, as illustrated in Figure 2, we 
proposed the following procedures for creating such a virtual 
environment on a server machine with an infrastructure as a 
service (IaaS) provider: 
1. Installing our agent program: The user simply installs 
and runs our agent program, which automates the rest of 
the procedures. The agent also provides the interface for 
the user and applications to interact with the virtual 
environment. 
2. Allocation of a delegate system: The agent allocates a 
delegate system to host the virtual environment by 
subscribing to a virtual machine from an IaaS provider. 
The delegate system may host multiple virtual 
environments to save the operation cost. 
3. Setting up a virtual environment: The agent sets up a 
virtual environment (a.k.a. virtual phone) on the delegate 
system to emulate an Android phone. For compatibility, 
the virtual phone needs to emulate the details of a physical 
Android device as much as possible.  
4. Cloning of the operating environment: The agent uses a 
standard image stored in the delegate system to create a 
fresh virtual environment and copies the applications and 
data from the physical phone. An exact clone of the 
operating environment should increase the compatibility 
for applications that requires vendor-specific libraries or 
system services.  
5. Migration of applications: The agent on the physical 
phone takes commands from the user and communicates 
with the agent on the virtual environment to control the 
operation of the virtual environment. The user of an 
application (or the application itself) may request the 
agent to migrate the application between two phones. 
6. Synchronization of applications and user data: The agent 
programs on both phones collaborate to keep the 
application packages and user data consistent and 
coherent on both phones. Since continuous mirroring of 
files would generate a large amount of network traffics, 
the policies and protocols of synchronization are critical. 
Note that the virtualized execution environment can be 
hosted by a personal computer as well. A cloud-based 
environment would offer better cost/performance by hosting 
many virtualized environments on the same server machine to 
amortize the costs. A personal server could be used in cases 
the privacy of the application is very critical. As we will 
discuss later in Section III-E, the performance of a low-end 
personal computer can outperform the fastest smartphones by 
several times, finding a suitable computer to host a virtual 
environment would heavily depend on the applications and 
network conditions in practice, which was why our 
framework would like to address both practice issues.   
B. Migrating an Application 
Our application migration mechanism leverages on the 
Android Framework to minimize the amount of data needed 
to migrate a live application. Basically, we pause an 
application on one device, send the state data files saved by 
the application as it enters the pause state, and resume the 
application on another device. As the state data files are 
usually small, it results in a low migration overhead. 
The procedure for migrating an application is illustrated in 
Figure 3. On the left-hand side: (1) The agent sends a signal to 
the application and has the application enter the OnPause 
function. (2) The application saves its states in the OnPause 
function and (3) informs the agent when the states are saved. 
(4) The agent reads the states and (5) sends the states to the 
agent on the other side. Then, on the right-hand side: (6) The 
agent saves the states and (7) starts the application (or copies 
the application from the other side if it does not exist). (8) The 
application resumes by calling the OnResume function and (9) 
resumes the execution after restoring the application state. 
IaaS Provider
Virtual Env. 1
Droid 
App1
Local Storage1
Delegate System (VM)
Android 1
AgentDroid App1
Local  Storage 1
Agent Agent Droid App2
Local Storage2
Virtual Env.2
(2) Server Machine
(3)
(4)
(5)
(6)
(1) Android 2
AgentDroid App1
Local  Storage 1
23
 
 
 
TABLE I 
THE SIZES OF THE FILES IN TESTED ANDROID APPLICATIONS 
synchronized immediately via the shared storage. For 
example, Contact Provider is part of the Android middle- 
ware that maintains a database for applications to find contact 
information, and it is important to synchronize the database 
files even though Contact Provider is not running on the 
virtual phone. The cache buffers are primarily used by 
streaming multimedia applications, such as YouTube, to 
prefetch multimedia contents, which can be discarded and 
reloaded by the application.  Finally, the state files for an 
application need to be synchronized only when the 
application is being suspended and migrated onto another 
phone. 
As shown in Table I, the size of a program package varies 
from 92KB to 951KB, which would take a few seconds to 
transfer via a mobile network. As the configuration files are 
quite small and the contact database should not be updated 
frequently by a typical application, the communication costs 
for synchronizing files in these two categories are usually not 
an issue. Since the contents in cache buffers are constantly 
changing and can be re-fetched after being thrown away, our 
framework label these files as no-need-for-synchronization to 
reduce the communication costs. Finally, the costs for 
transferring state files are minimal. Web-based applications 
such as Google Translate, Android MMS, and Gmail are 
state-less without any state files at all, while the other 
applications have small state files that are less than 1.5KB, 
which means our approach can migrate the execution of any 
tested application onto a virtualized environment in as fast as 
sending 1.5KB over the network. 
Finally, we show that a virtualized execution environment 
accelerate the execution of mobile applications. In our 
experiment, we used the Intel Atom-based system host 
Android-x86 as virtual environment in the cloud. As shown in 
Figure 4 the 1.6GHz Intel Atom processor was already 4.9 to 
6.4 times faster than the 528MHz ARM processor on the 
Android phone. The results suggested that the virtual 
environments powered by servers equipped with low-end 
processors still provided sufficient performance for average 
applications. Migrating an application via a traditional 
approach, such as [4], would need to transfer the state of the 
entire environment by taking a snapshot of the memory. 
Assuming an Android environment with 512MB of system 
memory, it would take more than one hour to transfer the 
snapshot. With our approach, it would only take milliseconds 
to transfer the state files saved by Android applications. 
 
 
Figure 4 Performance Comparison between a Physical Device 
and a Virtualized Environment 
IV. PROBABILISTICALLY GUARANTEED COMMUNICATION 
Reliable communication between mobile devices and 
server plays an important role in the framework. Due to the 
dynamics of wireless network and communication networks, 
we designed a probabilistic-guaranteed connection via virtual 
devices. In our framework, the reliable communication is 
realized with virtualization technology. The rationales are 
twofold: one is to integrate different QoS services in a 
virtualized execution framework and the other one is that 
different types of communication, even in one application, 
have different QoS requirements. For example, control 
messages for application migration should be transmitted 
without fault but usually consist of small amount of data; a 
video/data streaming transmission can tolerate certain data 
lost but consist of great amount of data. To meet all of these 
different QoS requirements is not trivial. To provide better 
compatibility and programming interface, we implement the 
QoS controlling mechanism in virtualization layer. So we 
could manage all the QoS requirements using bandwidth 
management mechanism.  
Figure 5 illustrates the operation of virtual network 
devices. The user thread layer provides services to users or 
manages hardware resource in this system. The threads refer 
to the programs providing services to users such OS and 
stand-alone programs. The user thread layer includes all the 
user threads. For transmitting, we provide a network 
bandwidth allocation mechanism according to the bandwidth 
requirements from services. Due to the dynamics of 
networking environment, the QoS framework for transmitting 
provides a bandwidth guarantee with probability. For 
receiving, we provide a resource protection mechanism to 
bound the maximum data receiving size for services. To 
verify and evaluate our framework, we conduct extensive 
experiments in this work.  
0.00
1.00
2.00
3.00
4.00
5.00
6.00
7.00
Google‐G1 Phone, 528MHz ARM Acer D255, 1.6GHz Intel Atom
25
 
 
 
environments,” in Proceedings of the Fifth Symposium on 
Operating Systems Design and Implementation, 2002, pp. 
361–376. 
[6] Android Developers website. [Online]. Available: 
http://developer.android.com/. 
[7] R.T. Kouzes, J.D. Myers, W. A. Wulf, "Collaboratories: doing 
science on the Internet," IEEE Computer, vol.29, no.8, 
pp.40-46, Aug 1996. 
[8] “100,000 Android Applications Submitted To Date, AndroLib 
Claims,” techCrunch web site. [Online].  Availaible on: 
http://techcrunch.com/2010/07/30/android-market-100000/. 
[9] J. Flinn, D. Narayanan, and M. Satyanarayanan, “Self-tuned 
remote execution for pervasive computing,” in Proceedings of 
Hot Topics in Operating Systems, 2001, pp. 61–66. 
[10] R. Balan, J. Flinn, M. Satyanarayanan, S. Sinnamohideen, and 
H.-I. Yang, “The case for cyber foraging,” in Proceedings of 
the 10th ACM SIGOPS European Workshop, 2002, pp. 87–92. 
[11] E. Cuervo, A. Balasubramanian, D. ki Cho, A. Wolman, S. 
Saroiu, R. Chandra, and P. Bahl, “MAUI: Making 
smartphones last longer with code offload,” in Proceedings of 
ACM MobiSys, 2010, pp. 49–62. 
[12] C. C. Keir, C. Clark, K. Fraser, S. H, J. G. Hansen, E. Jul, C. 
Limpach, I. Pratt, and A. Warfield, “Live migration of virtual 
machines,” in Proceedings of the 2nd ACM/USENIX 
Symposium on Networked Systems Design and 
Implementation, 2005, pp. 273–286. 
[13] P. E. Sevinc¸, M. Strasser, and D. Basin, “Securing the 
distribution and storage of secrets with trusted platform 
modules,” in Proceedings of the First IFIP TC6 /WG8.8 
/WG11.2 International Conference on Information Security 
Theory and Practices: Smart Cards, Mobile and Ubiquitous 
Computing Systems, 2007, pp. 53–66. 
[14] T. Garfinkel and M. Rosenblum, “When virtual is harder than 
real: security challenges in virtual machine based computing 
environments,” in Proceedings of the 10th conference on Hot 
Topics in Operating Systems - Volume 10, 2005, pp. 20–20. 
[15] J. Smith and R. Nair, Virtual Machines: Versatile Platforms 
for Systems and Processes. Morgan Kaufmann Publishers Inc., 
2005.  
[16] C.-C. Chen, S.-H. Hung, and C.-P. Lee, “Protection of buffer 
overflow attacks via dynamic binary translation,” in 
Proceedings of the International Conference on Reliable and 
Autonomous Computational Science, 2010, pp.305-316. 
[17] L. Zhang, S. Deering, D. Estrin, S. Shenker, D. Zappala, 
“RSVP: a new resource ReSerVation Protocol,” IEEE 
Networks Magazine, vol.7, no.5, pp.8-18, Sep 1993. 
[18] I. Mahadevan, K. M. Sivalingam, “Architecture and 
Experimental Results for Quality of Service in Mobile 
Networks using RSVP and CBQ”, ACM/Baltzer Wireless 
Networks Journal, Vol.6, No.3, 2000. 
[19] A. K. Talukdar, B. R. Badrinath, A. Acharya, “MRSVP: A 
Resource Reservation Protocol for an Integrated Services 
Network with Mobile Hosts”, ACM Journal of Wireless 
Networks, Vol. 7, 2001. 
[20] D. de Niz, R. Rajkumar, "Chocolate: a reservation-based 
real-time Java environment on Windows/NT," in Proceedings 
of the Real-Time Technology and Applications Symposium, 
2000, pp.266-275. 
[21] P. A. Bernstein, V. Hadzilacos, and N. Goodman, 
Concurrency Control and Recovery in Database Systems. 
Addison-Wesley, 1987. 
[22] J. N. Gray, R. A. Lorie, G. R. Putzolu, and I. L. Traiger, 
“Granularity of locks and degrees of consistency in a shared 
data base”, in Readings in database systems (2nd ed), pp. 
181–208, Morgan Kaufmann Publishers Inc., 1994. 
[23] Google Code Project. [Online] Available: 
http://code.google.com/. 
 
27
Computing and Informatics, Vol. , 2011, ??–??, V 2011-Oct-1
VIRTUALIZING SMARTPHONE APPLICATIONS TO
THE CLOUD
Shih-Hao Hung, Jeng-Peng Shieh, Chen-Pang Lee
Department of Computer Science and Information Engineering,
National Taiwan University,
No. 1, Sec. 4, Roosevelt Rd., Taipei 10617, Taiwan
e-mail: {hungsh, d97026, d97039}@csie.ntu.edu.tw
Abstract.
Smartphone technologies have enabled sophisticated pervasive applications for
mobile users. Still, many intensive applications perform poorly on smartphones
due to the shortage of resources for computation, data storage, network bandwidth,
and battery capacity. While such applications can be re-designed with client-server
models to benefit from subscribed cloud services, the users are no longer in full con-
trol of the entire application execution, which has raised a serious concern. Mean-
while, privacy and security are also important issues, and it is an ongoing debate if
public cloud services could be trusted with sensitive data. For mobile users to take
full advantage of cloud services, these issues need to be resolved.
In this paper, we propose an innovative framework for mobile users to execute
existing Android applications on a personal virtual phone safely in the cloud. In-
stead of using a client-server model, the entire virtual phone is mostly controlled
by the user to minimize the intervention from the service provider. Virtualization
and encryption are employed to protect against eavesdropping from cloud providers
and network attackers. To quickly migrate an Android application between the
physical phone and the virtual phone, we use a new application-level checkpointing
mechanism and minimize the state of the application.
Keywords: pervasive computing, smartphone, virtualization, cloud applications,
information privacy, information security, operating system
1 MSC 2000 symbol: 68N25
2 This work was supported in part by a grant from the National Science Council (98-
2220-E-002-020) and a grant from Ministry of Economic Affairs (98-EC-17-A-01-S1-034).
Virtualizing Smartphone Applications to the Cloud 3
Network in April 2011, and put the information of 77 million registered accounts
at risk.
To address the above issues, we propose a framework for a user to create a
personal virtual phone in the cloud and allow the user to migrate the execution of
an existing application between the user’s phone and the virtual phone. The idea is
to utilize the personal virtual phone to eliminate the need for creating unnecessary
public cloud services to oﬄoad computationally intensive smartphone applications.
Unlike the client-server model, application redesign is not needed and since the
virtual phone is created and controlled by the user, the privacy/security risk is
significantly reduced by excluding the service providers.
Since the communication cost for migrating a process [17] or a virtual machine
[21] over a mobile network can be prohibitively high, we discuss several strategies
to reduce this communication overhead. Then, we further categorize the types of
application data to determine on the necessity and the priority of data synchro-
nization. Since the Android platform is relatively new, we have not seen a similar
approach in any previous publications. We are not aware of any application-level
migration scheme which can migrate existing Android application without re-writing
the application code. In addition to oﬄoading workload from the physical phone,
the framework gives the user the control of the virtual phone and can work with
security measures to protect the information on the virtual phone. It also offers the
opportunity to augment the capability of the physical phone, file sharing service,
automatic data backup, and virus checking, etc.
The rest of this paper is organized as the following. The proposed framework is
described in Section 2. The migration scheme and the communication overhead are
evaluated in Section 3. The security of the virtual phone and the implementation of
potential value-add features of the virtual phone are covered in Section 4. Section
5 surveys the recent related works and compared them with our work. Section 6
concludes this paper by summarizing our findings.
2 VIRTUAL PHONES IN THE CLOUD
Imagine a personal virtual phone which is connected to high-speed network, has a
large storage space, and is capable of performing Android applications several times
faster than any physical phone. The owner of the virtual phone may benefit from
this virtual phone in many ways. The virtual phone may oﬄoad intensive workload
from the physical phone to speed up the computation, data access, and network op-
erations. The same application may run on both the virtual phone and the physical
phone, so the user may launch the application on either phone or has the applica-
tion migrated between the two phones. The data of the two phones are synchronized
with a cloud storage. As Android applications become the main stream, the user
may even use the virtual phone to have server or peer-to-peer applications executed
continuously in the background. Since the application is executed in an environ-
ment owned by the user, it greatly reduces the risks of sending sensitive data to a
Virtualizing Smartphone Applications to the Cloud 5
system to create a fresh virtual phone. An exact clone of the operating envi-
ronment should increase the compatibility between the virtual phone and the
physical phone. For applications which requires vendor-specific libraries or sys-
tem services, a full clone is necessary. For other (standard Android) applications,
a standard image would be recommended to save the communication costs for
cloning the physical phone and accelerate the creation of the virtual phone.
5. Migration of applications: The agent on the physical phone takes the commands
from the user and relays the commands to the virtual phone. The user may
request the agent to migrate a running application from the physical phone to
the phone, or vice versa. To migrate an application, the state of the application
and the working file set have to migrated. As the latency for migrating a live
(executing) application may affect the user experience, it is critical to reduce
the latency by minimizing the size of the application state and identifying the
working file set .
6. Synchronization of applications and user data: As the physical phone and the
virtual phone may operate on the same set of files in parallel, the agent pro-
grams on both phones need to collaborate to keep the application packages and
user data consistent and coherent on both phones. Since continuous synchro-
nizing modified files generate a large amount of network traffics and is often
unnecessary, we should pay attention to the policies and protocols for the syn-
chronization of files.
Procedures 1 to 4 are performed once to set up a virtual phone initially. De-
pending on the need of the user, the actual construction of the framework, and the
network condition, the set up time for a virtual phone ranges from a few seconds
to a few hours. Setting up a virtual phone with a standard Android OS image to
oﬄoad portable Android application written in Dalvik is very quick, which makes
it practical to locate a nearby server and create a virtual phone on demand.
On the other hand, Procedures 5 and 6 are involved in the daily use of the
virtual phone. The latencies caused by these two procedures are important to user’s
experience, but the issues are more sophisticated. We shall further address the
performance issues in the next section.
3 MIGRATION OF ANDROID APPLICATIONS
For migrating a server application, it is commonly done by transferring the snapshot
image of the virtual machine that runs the application. Unfortunately, this would
be impractical to the migration of a mobile application. Given the fact that a
snapshot image can easily reach 256 MBytes for today’s entry-level Android phones,
transferring the image over a wireless network should take a long time (e.g. roughly
10 minutes via a 7.2Mbps HSDPA network). Obviously, it is an overkill instead of
migrating the entire system, if what the user wants is to migrate an application.
Process migration is an alternative approach [19]. Unfortunately, process mi-
gration is practically too complicated, as it requires an extensive support from the
Virtualizing Smartphone Applications to the Cloud 7
copies the application from the other side if it does not exist). (8) The application
resumes by calling the OnResume function and (9) resumes the execution after
restoring the application state.
Our first case study is a peer-to-peer (P2P) file exchange application program,
called androidtorrent [4]. The purpose is to illustrate the application migration
procedure and the capability of our framework. P2P is a distributed network for
participants to share their resources without a centralized coordinator [23]. The
working set in androidtorrent can be quite large when the user exchanges many files
with many peers. In practice, while P2P network is popular on personal computers
(PC), most smartphone users would not run this application since it is relatively
slow to exchange files over a mobile network and the application constantly consumes
processor/memory/network/battery resources on the phone.
As we enter the so-called post-PC era, like androidtorrent, many PC applications
face the same challenge on smartphones. While there are proxy services in the cloud
which would like to replace the P2P client program, as we mentioned in the beginning
of this paper, the user would need to subscribe to a service, and the service provider
may be aware of the activities and the files processed by the server. So far, we cannot
find a proxy program to install the same service on a private server by ourselves.
Even if we found one, it would not be an elegant solution for an average user. It is
a dilemma: on one hand, it would take some effort and cost for the user to maintain
a private server; on the other hand, if a public service is chosen, the privacy of the
data may be a concern.
Obviously, this type of workload would be best handled by a virtual phone in the
cloud. In our experiment, we created a virtual phone, started androidtorrent in a
physical phone, select the files to exchange on the physical phone, and then migrate
androidtorrent to the virtual phone. During the migration, the agent transferred
the states saved by androidtorrent, approximately 320 Kbytes of data, to the virtual
phone over a 3G mobile networkand resumed execution in 3.8 seconds.
As androidtorrent proceeded its execution on the virtual phone, it constantly
created new files and modified existing files. If our framework were to enforce
continuous synchronization of the filesystems between the physical phone and the
virtual phone, a lot of unnecessary network traffics would be generated, since the
user has no need for those temporary files. In our framework, we adopt a version of
lazy synchronization policy to address this problem. When a file is modified on one
phone, the copy on the other phone is invalidated. It is not until the invalidated
file is accessed, the file would not be synchronized by the framework. On the other
hand, there are system data and files shared with other applications that need to be
synchronized immediately, for example, contact (addressbook). Since most Android
applications are well structured, it is relatively straightforward for the framework
to identify the system data and shared files. The agents on both phones monitor
and synchronize these files as soon as possible, and work jointly to ensure that no
race condition occurs in the synchronization. The details are discussed later in this
section.
As shown in Table 1, androidtorrent performed significantly better on the virtual
Virtualizing Smartphone Applications to the Cloud 9
as the configuration files are quite small, and the contact database should not be up-
dated frequently by the user. Since the contents in such cache buffers are constantly
changing and can be re-fetched after being thrown away, our framework label these
files as no-need-for-sychronization to reduce the communication costs. As shown in
Table 2, the cost for transferring state files are minimal. Web-based applications
such as Google Translate, Android MMS, Gmail are state-less without any state files
at all, while the other applications have small state files which are less than 1.5KB.
Finally, our framework can be used to migrate applications from one physical
phone to another physical phone or computer for a user who would like to continue
his/her work after switching to a new phone/computer. The user could use a virtual
phone to bridge the migration. In our experiment, we were able to migrate Android
applications from a physical phone to a virtual phone, and from the virtual phone to
an Android-based notebook computer. For applications which are written entirely
in Dalvik, we executed the application natively without translating the binary code
and resulted in significantly better performance on the computer. Figure 3 shows
the benefit of migrating computer-intensive applications to a faster device. Even
with an entry-level Intel Atom processor, the Acer D255 netbook still outperformed
the Google G1 phone by 4.9 to 6.4 times.
Fig. 3. Normalized Benchmark Performance
4 SECURITY ENHANCEMENT FOR VIRTUAL PHONES
While a variety of secure threats are raised by virtual computing environments
[14], we believe the operations on a virtual phone hosted by an IaaS provider should
still be more secure than having personal data processed and stored on a software
as a service (SaaS) provider. As the two layers of virtual machines help protect the
Virtualizing Smartphone Applications to the Cloud 11
attacks (BoA) in our virtual phone framework. In our framework, we added a mech-
anism into the dynamic binary translation scheme [10] into QEMU to protect the
applications running on the virtual phone. The mechanism is capable of recovering
corrupted data structures on the stack at runtime by dynamically inserting codes
to guard the return address and stack frame pointer, with no need to modify the
source code or the OS. Using a similar approach, other security measures such as
virus scan, malware detection, isolation, etc. can also be introduced into the virtual
phone.
5 RELATED WORKS
It was shown that remote execution saved a large amount of power for mobile com-
puters [20][11], but partitioning of applications for remote execution has been a
challenge for researchers. Spectra [13] [7] proposed to monitor the current resource
availability and dynamically determine the best remote execution plan for an appli-
cation. Cyber foraging [7] used surrogates to improve the performance of interactive
applications and distributed file systems on mobile clients. MAUI [12] proposed to
reduce the programming efforts by automating program partitioning with the com-
bination of code portability, serialization, reflection, and type safety.
Without application partitioning, methods have been developed to migrate the
entire application execution to a remote server. Process migration and virtual ma-
chine migration have been two common approaches to migrate execution across
the network. The ISR system [21] emulated the capabilities of suspend/resume
functions in a computer system and migrate the system by storing the snapshot
image of a virtual machine in a distributed storage system. Zap [17] introduced a
pod (PrOcess Domain) abstraction, which provided a collection of processes with
a host-independent virtualized view of the operating system, so as to support a
general-purpose process migration functionality, but it did not allow live migration.
Live migration [15] achieved rapid movement of workloads within clusters and data
centers with minimal service downtimes by continuously transmitting the changes
in a virtual machine to another system, but at the cost of communication overhead.
6 CONCLUSIONS
In this paper, we presented a framework to automate the creation of a virtual phone
and migrates live Android application faster than traditional methods. Compared
to a conventional client-server model, our approach does not require the developers
to redesign their applications and offers an effective method for the user to control
remote execution.
Our preliminary experimental results showed that our virtual phones were capa-
ble of intensive workloads and our efficient application-level migration method was
suitable for mobile network. The strategies that we developed to reduce the network
traffics for application migration and data synchronization are important to the user
Virtualizing Smartphone Applications to the Cloud 13
[14] Garfinkel, T., Rosenblum, M.: When virtual is harder than real: security chal-
lenges in virtual machine based computing environments. In: Proceedings of the 10th
conference on Hot Topics in Operating Systems - Volume 10. pp. 20–20 (2005)
[15] Keir, C.C., Clark, C., Fraser, K., H, S., Hansen, J.G., Jul, E., Limpach,
C., Pratt, I., Warfield, A.: Live migration of virtual machines. In: Proceedings
of the 2nd ACM/USENIX Symposium on Networked Systems Design and Implemen-
tation. pp. 273–286 (2005)
[16] Oberheide, J., Veeraraghavan, K., Cooke, E., Flinn, J., Jahanian, F.:
Virtualized in-cloud security services for mobile devices. In: Proceedings of the First
Workshop on Virtualization in Mobile Computing. pp. 31–35 (2008)
[17] Osman, S., Subhraveti, D., Su, G., Nieh, J.: The design and implementation of
Zap: A system for migrating computing environments. In: Proceedings of the Fifth
Symposium on Operating Systems Design and Implementation. pp. 361–376 (2002)
[18] Qin, F., Wang, C., Li, Z., Kim, H.s., Zhou, Y., Wu, Y.: Lift: A low-overhead
practical information flow tracking system for detecting security attacks. In: Proceed-
ings of the 39th Annual IEEE/ACM International Symposium on Microarchitecture.
pp. 135–148 (2006)
[19] Riggs, R., Waldo, J., Wollrath, A.: Pickling state in the JAVA system. In:
Proceedings of the 2nd USENIX Conference on Object-Oriented Technologies. pp.
241–250 (1996)
[20] Rudenko, A., Reiher, P., Popek, G.J., Kuenning, G.H.: Saving portable com-
puter battery power through remote process execution. SIGMOBILE Mob. Comput.
Commun. Rev. 2, 19–26 (1998)
[21] Satyanarayanan, M., Gilbert, B., Toups, M., Tolia, N., Surie, A.,
O’Hallaron, D.R., Wolbach, A., Harkes, J., Perrig, A., Farber, D.J.,
Kozuch, M.A., Helfrich, C.J., Nath, P., Lagar-Cavilla, H.A.: Pervasive
personal computing in an internet suspend/resume system. IEEE Internet Comput-
ing 11(2), 16–25 (2007)
[22] Schmidt, A., Kuntze, N., Kasper, M.: On the deployment of mobile trusted
modules. In: Proceedings of the Wireless Communications and Networking Confer-
ence, IEEE. pp. 3169 –3174 (2008)
[23] Schollmeier, R.: A definition of peer-to-peer networking for the classification of
peer-to-peer architectures and applications. In: Proceedings of the First International
Conference on Peer-to-Peer Computing. pp. 101–102 (2001)
[24] Sevinc¸, P.E., Strasser, M., Basin, D.: Securing the distribution and storage of
secrets with trusted platform modules. In: Proceedings of the First IFIP TC6 /WG8.8
/WG11.2 International Conference on Information Security Theory and Practices:
Smart Cards, Mobile and Ubiquitous Computing Systems. pp. 53–66 (2007)
[25] Suh, G.E., Lee, J.W., Zhang, D., Devadas, S.: Secure program execution via
dynamic information flow tracking. In: Proceedings of the 11th International Confer-
ence on Architectural Support for Programming Languages and Operating Systems.
pp. 85–96 (2004)
Computers and Mathematics with Applications 63 (2012) 573–587
Contents lists available at SciVerse ScienceDirect
Computers and Mathematics with Applications
journal homepage: www.elsevier.com/locate/camwa
Executing mobile applications on the cloud: Framework and issues
Shih-Hao Hung, Chi-Sheng Shih, Jeng-Peng Shieh ∗, Chen-Pang Lee, Yi-Hsiang Huang
Department of Computer Science and Information Engineering, National Taiwan University, Taipei 106, Taiwan
a r t i c l e i n f o
Keywords:
Smartphone
Cloud computing
Mobile network
Virtualization
Collaborative computing
Quality-of-service
a b s t r a c t
Modern mobile devices, such as smartphones and tablets, have made many pervasive
computing dreams come true. Still, many mobile applications do not perform well due
to the shortage of resources for computation, data storage, network bandwidth, and
battery capacity. While such applications can be re-designed with client–server models
to benefit from cloud services, the users are no longer in full control of the application,
which has become a serious concern for data security and privacy. In addition, the
collaboration between a mobile device and a cloud server poses complex performance
issues associated with the exchange of application state, synchronization of data, network
condition, etc. In this work, a novel mobile cloud execution framework is proposed to
executemobile applications in a cloud-based virtualized execution environment controlled
by mobile applications and users, with encryption and isolation to protect against
eavesdropping from cloud providers. Under this framework, several efficient schemes have
been developed to deal with technical issues for migrating applications and synchronizing
data between execution environments. The communication issues are also addressed in
the virtualization execution environment with probabilistic communication Quality-of-
Service (QoS) technique to support timely application migration.
© 2011 Elsevier Ltd. All rights reserved.
1. Introduction
Mobile and cloud computing technologies have enabled sophisticated pervasive applications. Yet, the applications on the
latest generation of mobile devices today, e.g. smartphones and tablets, are still constrained by power consumption, speed
of computation, size ofmemory, bandwidth of wireless network, etc. [1]. Since the Internet became popular, amobile device
might overcome the constraints by offloading portions of application workload onto a server machine via the network to
save execution time and conserve energy [2]. Recently, cloud computing has changed software infrastructures and business
models of Internet services with technologies to provide and manage abundant resources of computation and data storage
over the network at relatively low amortized operation costs [3].
Today, the popularity of smart devices andmobile networks has substantially changed the way people access computers
and network services. While the combination of cloud computing and mobile computing, termed mobile cloud computing
has started to show its effects with many seemingly innovative smartphone applications and cloud services surfacing in the
market today, we believe that the true potential of mobile cloud computing is yet to be explored. The following outlines the
issues in today’s mobile cloud computing environment from the viewpoints of the users and application developers:
• Application re-design and deployment: Traditional client–server models have been successfully used for mobile applica-
tions to leverage the resources in the cloud, but additional efforts, such as application partitioning and deployment of
services, are required to enable dynamic, fine-grain client–server collaboration, where the client may decide to offload
∗ Corresponding author.
E-mail address: jpshieh@gmail.com (J.-P. Shieh).
0898-1221/$ – see front matter© 2011 Elsevier Ltd. All rights reserved.
doi:10.1016/j.camwa.2011.10.044
S.-H. Hung et al. / Computers and Mathematics with Applications 63 (2012) 573–587 575
Fig. 1. Illustration of the lifecycle for an Android application activity.
QoS guaranteed communication channel. Hence, the control messages can be transmitted over a low-bandwidth channel
with high transmission probability.
The rest of the paper further elaborates our approach and discusses the issues we observed in our work. Section 2 covers
the background of our work by introducing the Android development framework and discussing the related researchworks.
Section 3 discusses the framework and the virtual environment that we proposed to enhance Android applications. The
system architectures and design of the probabilistic QoS guaranteed communication framework are covered in Section 4.
Finally, we summarize our findings and conclude this paper in Section 5.
2. Background and related works
2.1. The Android development framework
By July 2010, there were more than 100,000 applications developed for Android as claimed by AndroLib [9]. As an
optimization for smartphone applications, the Android operating environment manages applications differently from
traditional operating environments. An important aspect is that the Android system may kill a process when the system
falls short of memory. To decide which processes to kill, Android places each process into an importance hierarchy with the
running components and its states. The five levels in the hierarchy are listed in the following, with their importance from
high to low: (1) A foreground process interacts with the user, and they would be killed only when the available memory on
the system is too low. (2) A visible process does not have any components, but affects what the user sees. It is still important
to keep it alive unless necessary to free resource for foreground one. (3) A service process is a running service that does not
belong to the above two categories. They will be killed to favor two higher processes. (4) A background process holds an
activity invisible to the user, which does not have any direct impact on the user experience. It would be killed to reclaim
resource for the above three types of processes with an LRU list to ensure that themost recent activities would not be killed.
(5) An empty process does not associate with active components, which are often killed to balance the system workload.
The life cycle of an activity is illustrated in Fig. 1, where seven methods are involved with three nested loops:
• The entire lifetime of an application begins with the onCreate() method to perform initialization and ends with the
onDestroy()method to release allocated resources.
• The visible lifetime is between onStart() and OnStop(), where the user can see the activity on-screen, whether the
application is in the foreground or not.
• The foreground lifetime is between onResume() and onPause(), which is the point we are interested at. During this time,
the activity is active and shown on the screen and is interacting with the user.
S.-H. Hung et al. / Computers and Mathematics with Applications 63 (2012) 573–587 577
Fig. 2. Creating a virtual environment.
usage in the system. In a virtual network devices model, we will provide a programmer friendly interface to bridge QoS
requirements on the application layer and those on the MAC layer.
3. A virtual environment for Android applications
Imagine a cloud-based virtual environment that is capable of running the same set of applications as the mobile device
in a user’s hand and shares data storage. The user may use either the mobile device or the virtual environment to execute
an application or have the application migrate between two environments. The virtual environment helps offload intensive
workload from the mobile device as it accelerates computation, data access, and network operations. The user may even
migrate an application from the virtual environment to a personal computer, so that certain interactive tasks can be
done more quickly on a large display. However, there are several key issues in designing a framework to facilitate the
aforementioned scenario: How to clone the physical environment and create a virtual one? How to minimize the time
required to migrate an application over a mobile network? How to minimize the costs for sharing and synchronization of
data between two environments? How to secure the virtual environment?
In this section, we introduce the framework that we developed for Android users to offload applications to virtual
environments in the cloud. The framework automates the creation of a virtual environment and migrates live Android
application faster than traditional methods. Compared to a conventional scheme, our approach does not require the
developers to redesign their applications, and we offer several effective techniques to migrate applications and data over a
mobile network, with security measures included to address security and privacy issues.
3.1. Our proposed framework
In our migration framework, as illustrated in Fig. 2, we proposed the following procedures for creating such a virtual
environment on a server machine with an infrastructure as a service (IaaS) provider:
1. Installing our agent program: The user simply installs and runs our agent program, which automates the rest of the
procedures. The agent also provides the interface for the user and applications to interact with the virtual environment.
2. Allocation of a delegate system: The agent allocates a delegate system to host the virtual environment by subscribing to a
virtualmachine from an IaaS provider. The delegate systemmay hostmultiple virtual environments to save the operation
cost.
3. Setting up a virtual environment: The agent sets up a virtual environment (a.k.a. virtual phone) on the delegate system to
emulate an Android phone. For compatibility, the virtual phone needs to emulate the details of a physical Android device
as much as possible.
4. Cloning of the operating environment: The agent uses a standard image stored in the delegate system to create a fresh
virtual environment and copies the applications and data from the physical phone. An exact clone of the operating
environment should increase the compatibility for applications that requires vendor-specific libraries or system services.
5. Migration of applications: The agent on the physical phone takes commands from the user and communicates with the
agent on the virtual environment to control the operation of the virtual environment. The user of an application (or the
application itself) may request the agent to migrate the application between two phones.
S.-H. Hung et al. / Computers and Mathematics with Applications 63 (2012) 573–587 579
Fig. 4. Illustration of event replay architecture.
event occurring on the Android system (e.g. out of memory, out of battery, etc.). Without saving the state, it will have to
restart from the beginning. (2) When an application is terminated unexpectedly, the application would lose the input data
from the user, which could be a much worse problem than wasting time. These are inherent issues which applications on
many resource-constrained mobile devices have to face, and therefore we believe that more and more mobile applications
will follow Android’s design guideline and perform application-level checkpointing during the course of execution.
3.3. Input events and application replay
As mentioned in the previous section, losing input data from the user could be much worse than wasting time. This
problem can be implicitly solved by application-level checkpointing when the input data are saved as part of the application
state. However, what if an input event occurs in the middle of a memory-intensive task, when the cost would be too high to
save the entire application state? To deal with this dilemma, we further enhance the aforementioned state-saving scheme
and integrate application replay techniques [14,16,17] into our framework.
Many applications are organized in phases, and it would be wise for such an application to save its state in between the
phases when the state is less. For example, a computer game usually saves its state when the player finishes a stage. If the
game crashes in the middle of a stage, the player has to start from the beginning of the stage. Another example is when
an application makes a function call to a linear equation solver, the local variables and the matrices dynamically allocated
in the function would significantly increase the size of the application state. When the function call ends, the size of the
application state is reduced as those variables are freed. If the application iteratively calls this solver, it would be a good
option to save the application state between the function calls.
In these examples, the programmer may separate the application state into two parts: A global state which defines the
domain of the problem and control the flow of the application, and a local state which consists of the local data structures
needed by a function. Usually, the global state is formed by global data structure, and the programmer should be able to
identify these data structures. Hence, to reduce the cost of state saving, the programmer may choose to save the global
state, but not the local state, in the OnPause function of an Android application. Thus, when the application is suspended,
the applicationmay restore its global state and resume to the last checkpoint. However, the work done by the user since the
last checkpoint is lost. Therefore, it is desirable to have a record/replay mechanismwhich records the input events from the
user in between the checkpoints and feeds the input events to the application in case the application resumes from the last
checkpoint.
As shown in Fig. 4, we instrumented the EventHubmodule in the Android Framework to assist the application migration
agent in monitoring and recording the input events from the user. If an input event is non-deterministic, then the agent
records the location of the event in the program, the input data, and the time stamp in a buffer. Non-deterministic input
events refer to those input events which cannot be reproduced later deterministically, e.g. keyboard input, click of a window
button, voice input, camera input, etc. [16]. On the other hand, input events such as reading a file or retrieving a message
from the network server can be considered as deterministic events, and the agent need not record these events because the
same file or message can be obtained in the future.
For the replay scheme to work, the application has to explicitly notify the agent about a pseudo checkpoint, so that the
agent knowswhen to start recording the input events. Unlike a real checkpoint, a pseudo checkpoint is simply a place holder
which marks the location of resumption without actually saving the state. Instead of saving the state immediately at the
pseudo checkpoint, the application defers saving of the global state until its OnPause function is called. If the application is
paused and resumed, it will resume from the pseudo checkpoint. The purpose of pseudo checkpointing is for the agent to
identify the input events needed to be replayed when the application resumes. The agent flushes the input events recorded
prior to the pseudo checkpoint and start recording new events. The use of pseudo checkpointing helps reduce the overhead,
since the application does not have to save its state unless it is suspended.
S.-H. Hung et al. / Computers and Mathematics with Applications 63 (2012) 573–587 581
phone by the user. After a while, a window is popped up by the application to ask the user for input. The remote agent
detects this input event and migrates the application back to the physical phone. After the application gets an input from
the user, it is again migrated back to the virtual phone. This method works best when the application state is small and/or
when non-deterministic input events occur infrequently.
The second solution requires the agent on the virtual phone to send the data structures which describes the UI window
to the physical phone. In this case, the agent displays the same UI window to the user only to receive the input for the
application. Once the input event is received from the user, the agent transfers the input event to the virtual phone and uses
the replay scheme described in the previous subsection to feed the input event to the application. By transferring only the
high-level objects and events, this solution avoids transferring the application state, which could significantly reduce the
network traffic, but its implementation is highly dependent on the display protocol and cannot be easily ported to another
system.
The third solution is similar to the second solution except that it uses an open remote display protocol. There is an open-
source Android-based VNC server project, called android-vnc, which could serve the purpose. The advantage of using the
popular VNC protocol is the ability to display the input window as well as the results on a variety of platforms. However,
since the physical phone acts as a display terminal in this case, the responsiveness of the UI window depends heavily on the
latency of the network, which can be an issue over a slow mobile network.
3.5. Native code and performance
Although Google has intended to keep Android applications platform-independent by offering a JAVA application
framework, some Android applications are linked to proprietary C or assembly functions for performance reasons. These
proprietary C functions become platform-specific as they are compiled intomachine binaries and ship with the applications
as native libraries. This phenomenon causes incompatibility issues for Android applications across platforms. In our study,
we downloaded 2317 Android application packages and found that 5.82% of the applications were linked to proprietary
native libraries. The average size for these native libraries was about 630 kB.
How would this phenomenon impact the performance of a virtualized environment? First, since x86-based servers are
the current de facto standard in the cloud, we have the virtualized environment runs on x86-based servers with an Android
environment built for x86, a.k.a. Android-x86. Since x86-based servers aremuch faster than themobile devices built with less
powerful processors, those 94.18% Android applications which are not linked to proprietary libraries should be effectively
accelerated on the virtualized environment.
For the other 5.82% applications which are linked to proprietary native libraries, we may execute them via a processor
emulator, such as QEMU [27], on the x86-based server. Or, we may find a server of the same instruction-set architecture
and deploy a virtualized environment on that server. Either way, these applications would benefit less from the virtualized
environment. Since the speed is very important to the application, the best solution is to have a version of the native library
built for the x86 platform by the developer, so that the application can benefit from an x86-based virtual environment This
somewhat complicates the distribution and management of application packages and libraries, but this may overcome the
performance issue.
3.6. Synchronizing data
While an Android application is migrated from one machine to another machine, it is necessary to clone its application
states and data in the storage system. A brute-force way for synchronizing data between two environments is to maintain
identical data for all files in their file systems. For that, the datamust be updated as soon as one environmentmakes changes
to any file, which incurs network traffics, and the applications need to wait for the completion of any synchronization
operation if a strict synchronization protocol [28] is used,whichwould cause a long delaywith amobile network. Tomitigate
this problem, we need to look further into the policies for synchronization.
First, we divide the data storage into three categories: system image, system-wide data, and application data. When a
virtual environment is initialized, its filesystem is loaded with the system image and application packages that are on a
standard operating environment image. Synchronizing system image and application packages happens infrequently and
should not be an issue for the virtual environment in the cloud as it may download the image from a high-bandwidth
network. System-wide data refers to those files that record system-wide information and/or would affect the operations
of the system and applications. Libraries are examples of system data. Modifying a library may affect multiple applications
running on the system.When a physical environment makes a change to its system data, it often stops the applications that
might be affected and sometimes requires the system to reboot. Similarly, its virtual environment counterpart should follow
the same procedure.
Application data refers to the files owned by applications, and the synchronization of application data can be done on per-
application basis during the course of applicationmigration. Thus,we apply lazy and on-demand policies [29] to synchronize
the data upon the request of an applicationwithout keeping application data updated all the timewith a coherence protocol.
Running a collaborative application that executes simultaneously on multiple devices requires the application developer to
design the data communication or synchronization scheme specifically for the application. We are working to provide an
application programming interface to support collaborative applications in our framework.
S.-H. Hung et al. / Computers and Mathematics with Applications 63 (2012) 573–587 583
Fig. 7. Performance comparison between a physical device and a virtualized environment.
Tomigrate a new application to the virtual phone, the package has to be transferred only once. The configuration files and
the database files are monitored closely in our framework, so anymodifications to these files are synchronized immediately
via the shared storage. For example, Contact Provider is part of the Android middle-ware that maintains a database for
applications to find contact information, and it is important to synchronize the database files even though Contact Provider
is not running on the virtual phone. The cache buffers are primarily used by streaming multimedia applications, such as
YouTube, to prefetch multimedia contents, which can be discarded and reloaded by the application. Finally, the state files
for an application need to be synchronized only when the application is being suspended andmigrated onto another phone.
As shown in Table 1, the size of a program package varies from 92 to 951 kB, which would take a few seconds to transfer
via a mobile network. As the configuration files are quite small and the contact database should not be updated frequently
by a typical application, the communication costs for synchronizing files in these two categories are usually not an issue.
Since the contents in cache buffers are constantly changing and can be re-fetched after being thrown away, our framework
label these files as no-need-for-synchronization to reduce the communication costs. Finally, the costs for transferring state
files are minimal. Web-based applications such as Google Translate, Android MMS, and Gmail are state-less without any
state files at all, while the other applications have small state files that are less than 1.5 kB, which means our approach
can migrate the execution of any tested application onto a virtualized environment as quickly as sending 1.5 kB over the
network.
Next, we show that a virtualized execution environment accelerates the execution of mobile applications. In our
experiment, we used the Intel Atom-based system host Android-x86 as virtual environment in the cloud. As shown in Fig. 7
the 1.6 GHz Intel Atom processor was already 4.9–6.4 times faster than the 528 MHz ARM processor on the Android phone.
The results suggested that the virtual environments powered by servers equipped with low-end processors still provided
sufficient performance for average applications. Migrating an application via a traditional approach, such as [6], would need
to transfer the state of the entire environment by taking a snapshot of thememory. Assuming an Android environment with
512 MB of system memory, it would take more than one hour to transfer the snapshot. With our approach, it would only
take milliseconds to transfer the state files saved by Android applications.
Finally, Fig. 8 shows the results of a Face Recognition application running between a HTC Desire Android phone and
an Intel i7-2600 with Android-X86 virtual machine, migrating via the WiFi network. The program matches a human face
against the faces stored in a database file and find the bestmatches. The curves represent three cases of execution: standalone
execution on themobile phone, standalone execution on the server, and collaborative execution. The application runs 4x–8x
faster on the server, depending on the size of the face image and the size of the database file. For the collaborative execution,
the database file is resident on both machines, so the mobile phone only needs to transfer the face image file taken from
the camera on the phone. The transfer of the face image adds little overhead in this case, and the collaborative execution
performs closely to the execution on the server.
4. Probabilistically guaranteed communication
Reliable communication between mobile devices and server plays an important role in the framework. Due to the
dynamics of wireless network and communication networks, we designed a probabilistic-guaranteed connection via
virtual devices. In our framework, the reliable communication is realized with virtualization technology. The rationales
S.-H. Hung et al. / Computers and Mathematics with Applications 63 (2012) 573–587 585
Fig. 10. Probabilistic QoS guarantee by virtual network devices for transmitting.
Fig. 11. Probabilistic QoS guarantee by virtual network devices for receiving.
will transmit at lower bandwidth. VNIC3 can only transmit when there is remaining bandwidth. With this mechanism, the
application and operating system can be notified if a communication channel can be transmitted at its requested QoS level.
Fig. 11 shows the results with three VNIC devices for receiving. The maximum receiving data rates are 300 kb/s for VNIC1,
400 kb/s for VNIC2 and 200 kb/s for VNIC3. For each VNIC, the actual data rates arriving at the VNIC and the forwarded data
rates after theQoS control are shown. OurQoSmechanismdrops data packetswhen themaximum receiving rate is exceeded
for each VNIC. Note that, to evaluate the capability of bandwidth guarantee, the available bandwidth of the network changes
from time to time. As shown in Figs. 10 and 11, the available bandwidth ranges from 500 to 1200 kpbs. In our experiments,
VNIC1 has the highest priority. The results show that VNIC1 always transmits at its desired bandwidth when available. The
data size on each virtual network interface has no impact on the results because the protocol aims to allow priority data to
be transmitted using this approach and the bandwidth is guaranteed in a moving time window.
S.-H. Hung et al. / Computers and Mathematics with Applications 63 (2012) 573–587 587
[24] A.K. Talukdar, B.R. Badrinath, A. Acharya, Mrsvp: a resource reservation protocol for an integrated services network with mobile hosts, Wirel. Netw.
7 (2001) 5–19.
[25] D. de Niz, R. Rajkumar, Chocolate: a reservation-based real-time java environment on Windows/NT, in: Proceedings of the Sixth IEEE Real Time
Technology and Applications Symposium (RTAS 2000), RTAS’00, IEEE Computer Society, 2000, p. 266.
[26] RealVNC website. [online]. Available: http://www.realvnc.com/, 25-03-2011.
[27] QEMU open source processor emulator website. [online]. Available: http://wiki.qemu.org/, 23-04-2011.
[28] P.A. Bernstein, V. Hadzilacos, N. Goodman, Concurrency Control and Recovery in Database Systems, Addison-Wesley, 1987.
[29] J.N. Gray, R.A. Lorie, G.R. Putzolu, I.L. Traiger, Readings in Database Systems, second ed., Morgan Kaufmann Publishers Inc., 1994, 181–208.
[30] android-openvpn-settings website. [online]. Available: http://http://code.google.com/p/android-openvpn-settings//, 26-07-2011.
[31] OpenVPN-Open Source VPN website. [online]. Available: http://openvpn.net/, 23-07-2011.
[32] Google Code Project website. [online]. Available: http://code.google.com/, 08-03-2011.
A Profile-Driven Dynamic Application Offloading
Scheme for Android Systems
Shih-Hao Hung, Jeng-Peng Shieh, Yong-Wei Chen
Performance Application Security (PAS) Lab
Department of Computer Science and Information Engineering
National Taiwan University, Taipei, Taiwan 106, R.O.C.
Email: {hungsh, d97026, r99922129}@csie.ntu.edu.tw
Abstract—Smart mobile devices, such as smartphones and
tablets, are gaining strong demands recently with the advances
in processors, memories, storages, communication networks,
and software applications. However, due to their limited form
factors and battery capacities, the current generation of smart
mobile devices cannot yet fulfill the requirements of sophisticated
applications. Leveraging a cloud service to offload the application
workload can potentially overcome these limitations. In the paper,
we enhance our previous works on mobile-cloud computing by
extending the programming model on Android smartphones
with a flow-based programming paradigm to provide more
flexibility for application migration. For properly provisioning the
resources and making smart decisions based on the performance
gain, we add a profile-based policy manager and profiling service
into our framework to enable a dynamic offload scheme.
Index Terms—pervasive computing, smartphone, virtualiza-
tion, cloud services, security, privacy, Android
I. INTRODUCTION
Computing technologies have rapidly changed human lives.
At one end, smart mobile devices are widely used in everyday
applications. With the advances in processors, memories,
storages, communications, and software applications, smart
mobile devices can handle sophisticated applications, but are
still limited by its hardware resources and battery capacities
[1]. At the other end, cloud computing enables novel services
and new business models over the recent years, which have
resulted in a paradigm shift in IT service delivery [2].
In our previous work, we have shown that existing Android
applications can be efficiently accelerated by virtualizing the
applications to the cloud. In this paper, we would like to
enhance the previous work to provide an automatic, dynamic
application offloading scheme. By extending the programming
model on Android smartphones with the flow-based program-
ming (FBP) [5] paradigm, our framework may partition an
application into processes and provision the requirements of
each process.
In situations where workloads and environments change
over time, a comprehensive performance monitoring and mod-
eling scheme is needed to make the decision of offloading
during the runtime. Thus, we add a profile-based policy
manager and profiling service into our framework to make
smart decisions based on the available computing and net-
work resources during the runtime. The runtime libraries will
collaborate with the framework to decide how to offload the
Android Framework
Application
User Interface
Workflow
Kernel Function
User Agent Power  
model/estimate
Performance 
model/estimate
Policy Manager
Android Virtual Platforms
Android Phone
(1)
(5)
Profile
Database
(3)
(2)
VPaaS #1
VPaaS
(4)
Virtual Phone
(6)
(7)
VPA
QEMU
Android 
Applications
Fig. 1. Architecture of profile-based application migration
hotspot components. By default, our framework aims to reduce
the execution time of the application, but user may override
the default goal on demand.
II. PROFILE-BASED DYNAMIC OFFLOADING
As shown in Figure 1, agent programs are distributed on
the devices and the cloud to coordinate application migration,
service discovery, and resource management of the framework.
To further enhance the framework, we integrate VPA tools [3]
as a profiling mechanism to further explore the possibility of
dynamically offloading the FBP-based application workload
to the virtual phone. The results of analysis are stored in the
profile database for the policy manager to make a dynamic
offloading decision on behalf of the user.
The procedures of the proposed framework in Figure 1 are
described as the following: (1) The user agent inquiries the
policy manager. (2) Then the policy manager checks the profile
database for offloading. (3) Estimate the execution time and
the power consumption with VPA profile data. (4) The policy
manager uses these profile data to make the migration plan.
(5) Then send the migration plan back to the user. (6) The user
executes the kernel function in the light of the migration plan.
(7) After the work is done, the user agent feedbacks actual
execution results to the policy manager to train the profile
database.
III. EXPERIMENTAL RESULTS
We developed the object recognition(OR) application based
on [4], which detects objects in large image collections or
The 1st IEEE Global Conference on Consumer Electronics 2012978-1-4673-1501-2/12/$31.00 ©2012 IEEE 545
安全無縫之虛擬化行動雲端運算-子計畫二：行動應用軟體之虛擬化雲端執行環境(I) 
 25 
 
 
 
 
 
附件6 
velopment and management efforts and costs. Partitioning
an application to accelerate its execution by a remote server
is a challenging task even for experienced programmers [4].
Secondly, with a service provider performing the computa-
tion, the users are no longer in full control of the applica-
tions. The developers and users can be trapped by propri-
etary interfaces without any option. Though cloud appli-
cation services are available in the form of Software as a
Service (SaaS) and Platform as a Service (PaaS), but com-
patibility between services has been known as a serious is-
sue. Once a cloud application is deployed using one of these
services, it is difficult for the users and the developers to mi-
grate the application to another service provider. Thirdly, as
more and more cloud services are intended to collect per-
sonal information from the users, the user community starts
to pay more attention to the privacy/security of the data that
are sent and stored in the server. However, in most cases,
the users can only decide to accept the terms of service, and
it is very hard for a user to verify if the service provider
is honest, or to protect his/her own data when the service is
hacked. A recent attack has put the 70 million user accounts
of the PlayStation Network at risk.
In light of the above issues, we would like to propose a
framework as an alternative solution to enable heavy-weight
applications on the Android platform. Our framework al-
lows the user to create a virtualized execution environment
(virtual environment in short) in the cloud to perform An-
droid applications with far more resources than a mobile
device. We provides an agent program as an Android ap-
plication to help the user to control the deployment of the
virtual environment and migrate the execution of applica-
tions onto the virtual environment. The framework should
take care of the burden of securing the data stored in the vir-
tual environment and protecting the communication traffics
between the virtual environment and the mobile device.
The proposed framework may also be used by an
infrastructure-as-a-service (IaaS) provider to handle the
subscription and creation of the virtual environment. We
envision a new type of cloud services, e.g. Virtual Phone
as a Service (VPaaS), based on the proposed framework.
We believe hardware-based security mechanisms such as
the Trusted Platform Module (TPM) [11] are critical for en-
hancing the security of the service. Having a virtualized
hardware mechanism, such as vTPM [2], to store the en-
cryption keys and perform cryptographic operations is key
to avoid data theft from the personnel working for the ser-
vice provider.
For mobile applications, the communication cost for mi-
grating a process [7] or a virtual machine [9] can be pro-
hibitively high. To save the efforts of rewriting existing
applications and the overhead of migrating applications
to the virtual environment, we utilize the internal pause-
resume interface provided by the Android Framework to
support live migration of applications across Android sys-
tems. Since many existing Android applications already use
the pause-resume interface to store application persistent
states, our solution provides a live migration scheme that
is both transparent and lightweight. In addition, we further
embedded a checkpoint-restart and an event replay mech-
anism in the application layer to support more application
migration scenarios. The scheme serves to virtualize the ex-
ecution of an Android application as our work can migrate
the workload of the application to an Android-based server
for accelerating the execution, or have multiple Android de-
vices collaborate on the same application simultaneously.
The rest of the paper further elaborates on the design of
the proposed framework and discusses the issues we tack-
led in our implementation with observations from our case
studies. Section 2 covers the system design and architec-
ture. Section 3 presents our case studies. Section 4 con-
cludes this paper.
2. SYSTEM DESIGN AND ARCHITEC-
TURE
Imagine a personal virtual environment running on a
server which is connected to high-speed network, has a
large storage space, and is capable of performing Android
applications several times faster than any mobile device.
The goal of our proposed framework is to enable the user
to quickly set up the virtual environment on the server and
offload intensive workload from a mobile device to the vir-
tual environment, while the virtual environment and the per-
sonal data of the user are controlled and protected by the
framework.
One key concept here is not to explicitly divide an ap-
plication into the client and the server. Instead, we would
like to have the same application run on both the virtual
environment and the mobile device. The user may launch
the application on either the mobile device or has the appli-
cation migrated between the mobile device and the virtual
environment. The key technical challenges here are the fol-
lowing:
• Dynamic creation of the virtual environment allows the
user to create a virtual environment any time anywhere
would enable the user to find the most efficient way
to virtualize/migrate Android applications. For exam-
ple, migrating the application workload onto a nearby
computer over a local WiFi connection would save the
communication overhead. Sending an application to a
server in the cloud would take advantage of the low-
cost IaaS.
• Efficient schemes for live application migration reduce
the communication costs associated with the migration
chine which is capable of running Android, including PC,
tablet, or smartphone. Using cloud servers to host the vir-
tual environments would offer better cost/performance by
having many virtualized environments sharing on the same
server machine to amortize the costs. However, the service
provider needs to ensure that the virtual environments are
properly isolated and implement hardware security mecha-
nisms to eliminate potential security risks. The virtual en-
vironment also allows the user to migrate applications be-
tween personal Android devices, which would be conve-
nient for the users who own multiple Android devices.
2.2 The Basic Migrating Scheme
Compared to the migration schemes based on virtual ma-
chines, our application migration mechanism is more effi-
cient as the state of a live application is far smaller than the
state of the entire system. Basically, we use Android’s in-
ternal application management framework to pause an ap-
plication on one device, send the state data files saved by
the application as it enters the pause state, and resume the
application on another device. In addition to migrating the
application state, we need to synchronize the files used by
the application. The procedure is illustrated in Figure 3. On
the left-hand side: (1) The agent sends a signal to the appli-
cation and has the application enter the OnPause function.
(2) The application saves its states in the OnPause function
and (3) informs the agent when the states are saved. (4)
The agent reads the states and (5) sends the states to the
agent on the other side. Then, on the right-hand side: (6)
The agent saves the states and (7) starts the application (or
copies the application from the other side if it does not ex-
ist). (8) The application resumes by calling the OnResume
function and (9) resumes the execution after restoring the
application state.
2.3 Application Checkpoint and Event
Replay
The aforementioned scheme serves as a coarse-grain mi-
gration mechanism, which allows the application pause and
resume at certain checkpoints defined arbitrarily by the ap-
plication developer. The input data or the results after a
checkpoint would be discarded, which may or may not be
an issue to the user. For gaming or multimedia applications,
re-starting from a previous point in the execution should be
fine. For business application, it not only waste time, but
losing the input data could be much worse. While adding
more checkpoints would solve this problem, it would be te-
dious for the application developers. One solution is to have
the operating system save the input events so our framework
may replay the input events after the application resumes at
the checkpoint. While it is possible to integrate research
Figure 3. Migrating an Android Application
works from [6][12], the existing works target the migration
of an entire Linux system and would require extensive mod-
ification of the Linux kernel. For our purpose, we simply
need to modify the Dalvik and Android Framework slightly
to implement an event replay scheme for Android applica-
tions.
In practice, many applications are organized in phases,
and it would be wise for such an application to save its state
in between the phases when the state is less. For exam-
ple, when an application makes a function call to a linear
equation solver, where the local variables and the matrices
dynamically allocated in the function would significantly
increase the size of the application state. When the func-
tion call ends, the size of the application state is reduced
as those variables are freed. For an application which it-
eratively calls this solver, the overhead of saving applica-
tion state could be reduced if it is performed between the
function calls. Another example is that a typical computer
game saves its state when the player finishes a stage. In
these examples, the programmer may separate the applica-
tion state into two parts: persistent or global state which
defines the domain of the problem and control the flow of
the application, and temporary or local state which consists
of the local data structures needed by a function. Usually,
the global state is formed by global data structure, and the
programmer should be able to identify these data structures.
Hence, to reduce the cost of state saving, the programmer
may choose to save the global state, but not the local state,
in the OnPause function of an Android application. Thus,
when the application is suspended, the application may re-
store its global state and resume to the last checkpoint.
As shown in Figure 4, we instrumented the EventHub
module in the Android Framework to assist the applica-
tion migration agent in monitoring and recording the input
ical phone and migrated to the virtual phone by the user.
After for a while, a window is popped up by the applica-
tion to ask the user for input. The remote agent detects this
input event and migrates the application back to the phys-
ical phone. After the application gets input from the user,
it is again migrated back to the virtual phone. This method
works best when the application state is small and/or when
non-deterministic input events occur infrequently.
2.5 Security and Privacy Measures
While a variety of secure threats are raised by virtual
computing environments [5], we believe the operations on a
virtual environment hosted by an IaaS provider should still
be more secure than having personal data processed and
stored on a software as a service (SaaS) provider. As the
two layers of virtual machines help protect the virtual en-
vironment, it is far more difficult for an employee working
for the service provider to peek into the virtual environment.
Having a hardware mechanism to store the encryption keys
and perform cryptographic operations is key to avoid data
theft from the personnel working for the service provider.
Even with a hardware mechanism, the initial set of en-
cryption keys have to be distributed to the user securely. If
the provider of VPaaS happens to be the provider of the
mobile network, it would be convenient for the provider to
stores in the SIM card the unique initial keys correspond-
ing to a set of virtualized TPM’s. With the keys in the SIM
card, the agent on the physical phone may establish a using
the virtual private network (VPN) [10] with the agent on
the server to protect the communications between the two
agents. By default, we chose the L2TP/IPsec PSK (Pre-
SharedKey) protocol and distribute the pre-shared keys to
the user via a separate secure channel. The scheme is trans-
parent to application and works with SIM cards or exist-
ing authentication devices on mobile phones. For maxi-
mum security, we may opt to distribute certificates of the
servers/virtualized phones to the users via SSL.
Regarding to the storage on the virtual phone, our proto-
type includes an encrypted virtual storage to both the physi-
cal phone and the virtual phone over a FUSE-based [1] user-
space encrypted filesystem, i.e. encfs - encrypted filesystem
for FUSE . Since the files are encrypted and hashed, attack-
ers from another virtual machine on the same host or in the
middle of the network will be unable to retrieve and ma-
nipulate the contents in the files. As mentioned above, it is
critical to employ a hardware mechanism such as vTPM [2]
to store the master encryption keys and perform the encryp-
tion procedure.
Figure 6. A Cost Model for Android Applica-
tion Migration
2.6 Cost Models
Migrating an application to a virtual environment may
or may not speed up the application execution, as the cost
for migration can offset the benefit of migration. Thus, we
define a cost model to facilitate making a migration decision
at the mobile device, as shown in Figure 6.
Assuming the application is already deployed at both a
mobile device and a cloud server in advance. CTotal is de-
fined as the total cost of the combination of execution and
state transmission, where P is defined as total execution of
the application, Pd as partial execution of the application at
device end, and Pc as partial execution of the application
at cloud end such that P = Pd ∪ Pc. Three cost functions
are defined for the mobile device, cloud, and networking:
Cd(Pd, i) models the cost of execution for input i at device
end, Cc(Pc, i) models the cost of execution for input i at
the cloud server, and Cn(t, i, s) models the cost of com-
munication over network t for input i and application state
s. Heuristically, we have upper bound of cost function as
Cd(P, i), which means to execute the application at device
end only, and lower bound as Cc(P, i) without any trans-
mission overhead. The user can have preference on mi-
gration to the cloud if Cc(Pc, i) + Cn(t, i, s) is less than
Cd(Pd, i) with an feasible threshold. When multiple cloud
servers are available, the cost functions would help the user
make a choice. The goal could be to accelerate the appli-
cation, to save energy consumption on the mobile device,
or to find a balance between execution time and power con-
sumption.
3 Case Studies
In this section we demonstrated how our framework pro-
visions for the end user to build a virtual environment, de-
ploy and migrate Android applications under his control.
We also showed two collaborative migration modes, namely
Figure 10. Performance Comparison with a
Face Recognition Application
same application across the devices. You can play the
Angry Birds game on an Android phone on your way
home. As soon as you arrive at home, you may open
your Android tablet and use our framework to continue
the game. Simply pressing a few buttons, you can mi-
grate the game between devices easily within a few
seconds. Our framework synchronizes the latest game
state and the data files. If you like, you can migrate the
game to your friend’s Android phone and see if your
friend can break your record.
4. Conclusions
In this work, we describe a framework to execute mo-
bile applications in a cloud-based virtualized execution en-
vironment controlled by the user. Our approach over-
comes some important limitations imposed by the tradi-
tional client-server model. Our framework supports many
existing applications and encourages developers to design
highly migratable and collaborative applications to take ad-
vantage of computing resources available in the network.
Our prototype proves the concept and shows the efficiency
of our migration scheme. With the framework, we hope
to provide researchers, users and developers with a new
paradigm and insights to make use of mobile cloud com-
puting technologies.
References
[1] Filesystem in Userspace web site. Availaible on:
http://fuse.sourceforge.net/.
[2] S. Berger, R. Ca´ceres, K. A. Goldman, R. Perez, R. Sailer,
and L. van Doorn. vtpm: virtualizing the trusted platform
module. In Proceedings of the 15th conference on USENIX
Security Symposium - Volume 15, Berkeley, CA, USA, 2006.
USENIX Association.
[3] B.-G. Chun and P. Maniatis. Augmented smartphone appli-
cations through clone cloud execution. In Proceedings of the
12th Workshop on Hot Topics in Operating Systems, pages
8–8. USENIX Association, 2009.
[4] B.-G. Chun and P. Maniatis. Dynamically partitioning ap-
plications between weak devices and clouds. In Proceed-
ings of the 1st ACM Workshop on Mobile Cloud Computing
& Services: Social Networks and Beyond, MCS ’10, pages
7:1–7:5. ACM, 2010.
[5] T. Garfinkel and M. Rosenblum. When virtual is harder than
real: security challenges in virtual machine based comput-
ing environments. In Proceedings of the 10th conference on
Hot Topics in Operating Systems - Volume 10, pages 20–20.
USENIX Association, 2005.
[6] O. Laadan and J. Nieh. Transparent checkpoint-restart of
multiple processes on commodity operating systems. In
2007 USENIX Annual Technical Conference on Proceedings
of the USENIX Annual Technical Conference, pages 25:1–
25:14, Berkeley, CA, USA, 2007. USENIX Association.
[7] S. Osman, D. Subhraveti, G. Su, and J. Nieh. The de-
sign and implementation of zap: A system for migrating
computing environments. In Proceedings of the 5th ACM
Symposium on Operating System Design and Implementa-
tion (OSDI-02), Operating Systems Review, pages 361–376.
ACM Press, Dec. 9–11 2002.
[8] A. Rudenko, P. Reiher, G. J. Popek, and G. H. Kuenning.
Saving portable computer battery power through remote
process execution. SIGMOBILE Mob. Comput. Commun.
Rev., 2:19–26, January 1998.
[9] M. Satyanarayanan, B. Gilbert, M. Toups, N. Tolia, A. Surie,
D. R. O’Hallaron, A. Wolbach, J. Harkes, A. Perrig, D. J.
Farber, M. Kozuch, C. Helfrich, P. Nath, and H. A. Lagar-
Cavilla. Pervasive personal computing in an internet sus-
pend/resume system. IEEE Internet Computing, 11(2):16–
25, 2007.
[10] A. Schmidt, N. Kuntze, and M. Kasper. On the deployment
of mobile trusted modules. In Proceedings of the Wireless
Communications and Networking Conference, IEEE, pages
3169 –3174, 2008.
[11] P. E. Sevinc¸, M. Strasser, and D. Basin. Securing the distri-
bution and storage of secrets with trusted platform modules.
In Proceedings of the First IFIP TC6 /WG8.8 /WG11.2 In-
ternational Conference on Information Security Theory and
Practices: Smart Cards, Mobile and Ubiquitous Computing
Systems, pages 53–66, 2007.
[12] A. Surie, H. A. Lagar-Cavilla, E. de Lara, and M. Satya-
narayanan. Low-bandwidth vm migration via opportunis-
tic replay. In Proceedings of the 9th workshop on Mobile
computing systems and applications, HotMobile ’08, pages
74–79. ACM, 2008.

除了學術討論之外，大會的重頭戲是晚宴。主辦單位很用心安排與會學者在渡輪
上晚宴，這是大家彼此認識的好機會。渡輪上有相當舒服的環境與餐點，窗外港
邊風景絕佳，傍晚觀賞到著名的雪梨歌劇院，也認識到澳洲政府對於環境與藝術
的重視。返回時的夜景，更是引人入勝。一圖勝千文，請參考以下照片。 
 
 
 
不過，由於澳幣幣值近年不斷上升，物價相當高，甚至高過於美國和歐洲。在與
當地人員談論後發現，澳洲有豐富的資源，政府也除了計劃開發，也重視教育和
人才訓練，甚至積極吸引各國人來澳洲移民。在雪梨看到許多東方面孔的移民，
在此似乎相處頗為融洽，政府的政策似乎帶來不錯的成績。 
100年度專題研究計畫研究成果彙整表 
計畫主持人：洪士灝 計畫編號：100-2219-E-002-028- 
計畫名稱：安全無縫之虛擬化行動雲端運算--子計畫二：行動應用軟體之虛擬化雲端執行環境(I) 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 3 3 100%  
研究報告/技術報告 0 0 100%  
研討會論文 2 2 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 3 3 100%  
博士生 2 2 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
