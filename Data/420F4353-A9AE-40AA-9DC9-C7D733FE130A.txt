 2
 
目錄： 
 
研究成果發表--------------------------------------------------------------------------- 3 
報告內容--------------------------------------------------------------------------------- 4 
計畫成果自評---------------------------------------------------------------------------27 
 
 4
報告內容 
 
摘要 
 
過去以 Apriori 為基礎的循序樣式探勘方法，皆單純採用由下而上的方式從長度較短的頻繁樣
式逐步成長至較長的候選樣式，一直到沒有更長的候選樣式產生為止。在很多應用中，常需探
勘 “不為其它任一頻繁樣式的子樣式” 之最長頻繁樣式。這些應用如依傳統方式，找出所有的
頻繁樣式探勘候再刪除頻繁子樣式，會進行許多不必要的運算。本研究提出一個優先探勘最長
頻繁樣式之演算法，PMSPM (Pincer Maximal Sequential Patterns Mining)，採取由下而上以及由
上而下兩種方向輪流探勘的方式，提早於每次由上而下探勘時，找出該階段的最長頻繁樣式，
使得後續由下而上探勘時，不需逐步成長，進而避免大量不需要的候選樣式測試，減少探勘時
間。此外，交易的發生時間是決策者考量的重要因素之一，如果能在探勘時加上時間間隔的限
制，產生的樣式將會更有意義，更具決策參考價值。本研究擴充項目之間只是相鄰和非相鄰的
關係之 PMSPM 循序樣式探勘演算法，提出加上樣式項目之間的相關時間限制因素之
PMSPMTC (Pincer Maximal Sequential Patterns Mining with Time Constraint) 演算法，使得探勘出
來的樣式更有意義且有彈性。本研究除了證明以上演算法之正確性與完整性，並以模擬實驗驗
證其效能及可行性。 
 
關鍵詞：循序樣式(sequential pattern)、資料探勘(data mining) 、最長循序樣式 (maximal sequential 
pattern)、時間限制 (time constraint) 
 
 
1. 前言 
 
循序樣式探勘可運用於顧客交易行為研究、網站日誌探勘、DNA 基因定序等等。以交易
資料庫為例，可將交易的發生時間作為前後次序的依據，將顧客的所有交易依序排成一個序列，
其目的是計算符合循序樣式要求的交易序列之出現次數，找出所有超過門檻值(即最小支持度)
的頻繁循序樣式。以顧客交易資料為例，若發現許多顧客在購買了 A 物品之後，會再購買 B 物
品，這就是一種頻繁循序樣式，目前循序樣式探勘的資料型別，主要是以交易型的資料庫為主，
而由於電子商務市場的成熟，這種交易型資料量大幅增加，如何利用這些交易資料找出潛藏的
資訊，也因此越來越受到重視。 
 
循序樣式探勘的概念，最早是由 Agrawal 和 Srikant[5]提出，以原本運用於從資料庫中找出
頻繁項目集合 (frequent itemset) 探勘的 Aprior 演算法[4]為基礎，以項目集合時間前後為順序依
據，採取廣度優先且由下而上 (bottom-up) 的方式，由短的循序樣式逐步增加長度，產生較長
的候選循序樣式，然後再從交易資料庫中找出符合項目集合順序的樣式，以最小支持度做為門
檻值，過濾得到頻繁循序樣式。 
 
一般的循序樣式探勘演算法都是探勘所有的頻繁樣式，因此可能會產生大量的頻繁子樣
式，尤其是在探勘長的樣式時，其樣式數量非常龐大。因而便有研究提出探勘封閉式循序樣式
(closed sequential pattern)，可以減少許多頻繁子樣式的產生，而探勘出來的樣式具有相同的表達
意義。 
 
然而當決策者想要探勘的結果只需為最長頻繁樣式(即不為其它任一頻繁樣式的子樣式)，
且不需要詳細記錄其子樣式的支持度時，不論是一般探勘出所有頻繁樣式的方法或者是探勘封
閉式循序樣式演算法，皆會產生大量非最長的頻繁循序樣式。本研究提出 PMSPM (Pincer 
Maximal Sequential Patterns Mining) 演算法，使用由下而上以及由上而下 (top-down) 兩種方向
輪流探勘的方式，提早探勘出最長循序樣式，避免此樣式的大量子樣式探勘，省下其支持度之
 6
一般的循序樣式探勘都是要找出所有的頻繁序列，因此當存在較長的頻繁序列時，會產生
數量龐大的頻繁子序列，於是 Yan 等人提出了探勘封閉式循序樣式的演算法 CloSpan[13]，當一
個頻繁樣式 I 為封閉時，代表在此資料庫中不存在一個 I 的超樣式且和 I 有著相同的支持度。不
再探勘所有的頻繁子序列，探勘封閉式循序樣式可以減少許多頻繁子序列的產生，而探勘出來
的樣式也一樣具有相同的表達意義。本研究探討之最長循序樣式為封閉式循序樣式的一種，但
封閉式循序樣式不一定是最長循序樣式。 
 
2.2.3 增加時間限制資訊之循序樣式 
為了讓循序樣式更能應用於實務上， GSP[6]、cSPADE[14]、Prefix-growth[10] 等演算法均
曾考慮過加入相關時間限制，以找出符合時間限制條件之所有頻繁項目集合或循序樣式。 
 
    張耕[2] 則提出一個結合 PrefixSpan 演算法[12]與時間機率觀念的演算法 PCTP 
(PrefixSpan Considering Time Probability)，在原有的最小支持度門檻值以外，新加入間隔時間和
最小機率門檻值兩個參數，用來計算與篩選出使用者感興趣的時間機率頻繁樣式。 
 
    顏志祐[3] 提出 E-PrefixSpan 演算法，運用樣式成長方法的特性，利用每次已找出的頻繁
循序樣式往後增長的同時，加入信賴度的篩選規則，讓每次新產生的樣式與其父樣式間的比值
都要大於等於由使用者設定的最小信賴度，通過信賴門檻值才進一步計算項目間所代表的時間
間隔關係，以找到符合最小支持度之最小時間間隔。 
 
    Chen 和 Hu[8] 提出 CFR-PostfixSpan 演算法，除了傳統的頻繁 (frequency) 度條件，在樣
式裡加上交易最近的時間 (recency) 以及樣式的最大時間間隔區間 (compact) 等時間因素，也
就是除了最小支持度 (minimum support) 外，利用交易最近時間確認過去常出現的頻繁樣式在
最近的時間點是否不再出現，利用樣式的最大時間間隔區間 (max_length) 觀察符合樣式的交易
第一個項目和最後一個項目之時間差是否超出最大時間間隔區間。 
 
 
3. PMSPM 演算法 
 
3.1 背景 
以Apriori為基礎的演算法，其在探勘長度較長的樣式時，候選樣式數量皆會大量的增加造
成沉重的運算成本。假設在第 k 回合的探勘時，得到 n 個長度為 k 的 k-階頻繁樣式，則在
第 k+1 回合時則會產生 n×n+n×(n-1)/2 個長度為 k+1 的 (k+1)-階候選樣式。例如 k 階頻繁樣
式有1000個，則 k+1 階候選樣式就有 1499500 個，其數量是呈指數型的成長。而且每一回合
皆需掃描原始資料庫來計算支持度。當最後探勘出的最長頻繁樣式的長度為 L 時，這些演算法
必需掃描 L 次原始資料庫。有鑒於 Apriori 為基礎的演算法皆有著上述的瓶頸，本研究提出了
一個夾擊式探勘、提早找出最長循序樣式的演算法 PMSPM (Pincer Maximal Sequential Patterns 
Mining)，不需由下而上逐步執行至最後一回合，就可找出所有的最長循序樣式，掃描資料庫的
次數也會比較小，因此可避免後續產生大量的候選樣式，以及減少掃描資料庫來測試支持度的
成本。  
 
3.2 演算法定義 
本研究採用交易資料庫為範例，包含全部顧客的所有交易資料，一個顧客的所有交易依照
交易時間先後順序，視為一個交易序列  (sequence)，而每一筆序列至少包含一筆交易
(transaction)，一筆交易包含由至少一個項目 (item) 所組成的一個項目集合 (itemset)。在此先定
 8
若有一交易序列 〉〈 nTTTS  ,..., , 21= ，滿足 11 PTi = 、 22 PTi = 、 … 、 qPq Ti = 且
nPPP q ≤<<<≤ ...1 21 ，則稱此顧客交易序列 S 支持循序樣式 P 。 
 
而為了後續說明方便，往後討論將循序樣式簡稱樣式，交易序列簡稱序列。 
 
為了盡量提早找到最長頻繁樣式，本論文設計了兩個主要的資料結構，候選最長序列集合
(Candidate Maximal Sequence Set，以下簡稱 CMS)及候選最長頻繁循序樣式集合(Candidate 
Maximal Frequent Pattern Set，以下簡稱 CMFS)，其說明如下： 
 
候選最長序列集合：此集合中的序列有可能在往後各回合的探勘，成為最長頻繁樣式。 
 
候選最長頻繁循序樣式集合：此集合中的樣式皆為當下已知的最長頻繁樣式，當演算法結
束後，CMFS 即為所有最長循序樣式的集合。 
 
PMSPM 演算法如圖 1 所示： 
圖 1. PMSPM 演算法 
 
PMSPM 演算法包含了下列五個步驟： 
 
1. 掃描資料庫，以產生一階候選樣式，將所有顧客的原始序列組成 CMS，接著將一階頻
繁樣式加入 CMFS，此步驟即圖 1 中的 Gen_1st_Pattern 函數。 
2. 產生目前所執行第 k 回合的 k-階候選樣式，建立候選樹 (candidate tree) 結構來測試
支 持 度 ， 並 將 所 有 k 階 頻 繁 樣 式 加 入 CMFS ， 此 步 驟 即 圖  1 中 的
Gen_Candidate_k_Pattern 及 Count_Candidate_Sup 函數。 
3. 利用於步驟 2 中得到的非頻繁樣式來更新 CMS 中的序列，並計算得到的 CMS 各序
Algorithm PMSPM(D, minSup) 
// D 為交易資料庫 
// minSup 為最小支持度 
// CMS 為候選最長序列集合、 CMFS 為候選最長頻繁樣式集合 
// k 為目前所成長的樣式長度 
// Ck為長度為 k 的候選樣式集合 
// Fk為長度為 k 的頻繁樣式集合、Nk為長度為 k 的非頻繁樣式集合 
1 begin 
2  k = 1; 
3  Gen_1st_Pattern()；  //產生一階頻繁、非頻繁樣式及 CMS 
4  while ( CMS !=∅ )   //CMS 若為空集合則結束演算法 
5  { 
6   k++;  //開始第 k 階之探勘 
//由下而上方向之探勘過程 
7   Ck = Gen_Candidate_k_Pattern(Fk-1);  //合併產生 k 階候選樣式 
8   Count_Candidate_Sup(Ck);  //計算 k 階候選樣式的支持度 
//由上而下方向之探勘過程 
//以 k 階非頻繁樣式來更新 CMS 中的序列 
9   CMS = UpdateCMS(CMS, Nk);  
    //計算 CMS 中所有序列的支持度,滿足最小支持度則加入至 CMFS 
10   Count_CMS_Sup(CMS); 
11   Del_Sub(CMFS);  //刪除 CMFS 中的子樣式 
12  } 
13  Output CMFS; 
14 End 
 10
圖 2. 計算候選樣式支持度函數 
 
3.5 由上而下方向的探勘 
在此階段主要是利用在第 3.4.2 節所探勘出的 Nk中的樣式，裂解 CMS 中的序列，以更新
CMS，提早找出長度大於 k 的頻繁樣式。 
 
3.5.1 更新 CMS 
CMS 為候選最長序列集合，其中的序列皆有可能在每一次更新後成為最長頻繁樣式，因此
在此階段是利用已知的 Nk中的樣式，依據“非頻繁樣式的超樣式也必定是非頻繁樣式＂定理，
裂解 CMS 中的序列，目的是將 CMS 中的序列更新成非任何「已知」非頻繁樣式的超序列，使
其序列更有可能成為最長頻繁樣式，而每一次裂解皆會使原本的序列長度減一。 
 
此步驟詳細做法如圖 3 所示。對於 Nk中的每一個樣式 SN＝〈T1…Tk〉，若 CMS 中存在一
長度為 m 的 SN之超序列 SC，且存在整數 I1…Ik 分別表示 T1…Tk 在 SC中的索引位置。此處之
m 必須大於 k+1，因為若 m 小於等於 k+1，則裂解後的序列長度必小於等於 k，皆為已知樣式，
因而不須要再更新。根據“非頻繁樣式的超樣式也必定是非頻繁樣式＂定理，SC 必定不是頻繁
樣式，必須將 SC更新成有可能是最長頻繁樣式的序列，同時將 SC從 CMS 中移除。由於 SN是
由 k-1 階頻繁樣式〈T1…Tk-1〉跟〈T2…Tk〉合併而成，且〈T1…Tj-1 Tj+1…,Tk〉(2≤ j≤ k-1) 有可
能是頻繁樣式，因此必須將原本 SC中的 k 階非頻繁樣式 SN的部分，更新成下述三種 k-1 階頻繁
樣式後成為新的 SC，再加入 CMS。依照移除交易項目位置的不同，更新規則分為下列三種情形： 
 
(1) 移除 SC中索引位置在 I2前的交易 T1，如圖 3 中第 6 行。 
(2) 移除 SC中索引位置在 Ik-1後的交易 Tk，如圖 3 中第 11 行。 
(3) 當〈T1…Tj-1 Tj+1…Tk〉(2≤ j≤ k-1)是 k-1 階頻繁樣式時(若為非頻繁樣式，則更新後亦必
定非頻繁樣式，因此不需進行更新)，移除 SC中索引位置在 Ij-1及 Ij+1中間的交易 Tj，如
圖 3 中第 7 至 10 行。 
 
若無完整的考慮此三種情形的更新，將會導致演算法結束時 CMFS 遺失部分的最長頻繁樣
式。 
 
Function Count_Candidate_Sup(Ck) 
1 begin 
  // CTree 為候選樹 
2  CTree =∅ ;  //重新建立一個空的候選樹 
3  for ( each S∈Ck ) { 
  //若候選樣式 S 尚未確定為頻繁或非頻繁，則加入候選樹 
4   if ( S∉Fk && S∉Nk ) CTree.add(S); 
5  } 
//讀入交易序列走訪候選樹計算支持度 
6  Traverse(D, CTree);  
7  for ( each leaf node O in CTree){ 
8   if ( O.counter ≥  minSup){ 
9    Fk.add(O.pattern);  
10    CMFS.add(O.pattern); 
11   }else{  
12    Nk.add(O.pattern); 
13   } 
14  } 
15 end 
 12
3.7 刪減 CMFS 中的子樣式並產生未被刪除樣式的長度 k+1 子頻繁樣式 
PMSPM 演算法的目的是在求最長頻繁樣式，因而必須刪除 CMFS 中滿足以下條件的樣式： 
“為另一 CMFS 樣式之子樣式”。詳細做法如圖 5，說明如下：對於 CMFS 中的每一個序列 S1，
若在 CMFS 中亦存在一序列 S2，且 S1為 S2的子序列，則將 S1從 CMFS 中移除；而未被刪除
的樣式即為候選最長頻繁樣式，接著使用 Generate_sub 函數來產生長度大於 k+1 的最長頻繁樣
式其長度為 k+1 的所有子樣式，並將這些子樣式加入至 k+1 階頻繁樣式集合，這樣在第 k+1
階測試候選樣式支持度時，就不需再去測試已知的樣式，減少測試的成本。 
 
Function Del_Sub(CMFS) 
1 begin 
2  for ( each S1∈CMFS ) { 
3   if ( ∃ S2∈CMFS ∋ S1 is a subsequence of S2 ){ 
4    Remove S1 From CMFS; 
5   }else if ( S1.length＞k+1 ){ 
6    SubS = Generate_sub(S1, k+1);     
7    for ( each s∈SubS ) Fk+1.add(s);     
8   } 
9  } 
10 end 
圖 5. 刪除 CMFS 的子樣式函數 
 
3.8 結束演算法 
當 CMS 為空不存在任何序列時，則表示已無任何候選最長序列在等待更新，此時 CMFS
即為所有的最長頻繁樣式。 
 
 
4. PMSPMTC 演算法 
 
4.1 背景 
 
    在循序樣式探勘的實務上，樣式中相鄰的兩項目之時間間隔可能早就超過行銷的時效性，
對於了解顧客購物行為的重要性，反而不如次序上不相鄰但時間間隔較短的兩項目。因此，我
們提出一個 PMSPMTC (Pincer Maximal Sequential Patterns Mining with Time Constraint) 演算
法，擴充 PMSPM 演算法，加上時間限制因素現，使得項目之間不再只是相鄰和非相鄰的關係，
而是有具體的時間限制。在作法上我們參考 Chen and Hu [7]，除了原有之最小支持度作為頻繁
循序樣式之門檻值，另外加上樣式最前與最後項目的最大時間間隔限制、交易時間不能過久的
條件，使得探勘出來的樣式更具意義。例如可找出：「顧客在某一天買項目A，二天後買項目B，
再三天後買項目C」的樣式。 
 
4.2 演算法定義 
 
    在 PMSPMTC 演算法中，除了原本採用的交易資料庫，本研究同時也建立一個對應交易序
列的交易時間資料庫，包含全部顧客的所有交易時間，因此新增了交易時間資料庫，並修改頻
繁循序樣式的定義: 
 
z 交易時間資料庫：由一筆或多筆交易時間序列組成。以下令交易時間資料庫
 14
Function Count_CMS_sup(CMS) 
1 begin 
2  // CTree 為候選樹 
3  CTree =∅ ;    //重新建立一個空的候選樹 
4  for ( each S∈CMS ) {        
5   if ( S∉CMFS ) CTreeCMS.add(S);  //將 S 加入候選樹 
6  } 
7  Traverse(D, T, CTree);  //讀入交易序列和交易時間序列走訪候選樹計算支持度 
8  for ( each node O in CTree){ 
9   if ( (O.counter ≥  minSup)&&( O.counter ≥  C_minSup)){ 
10    Remove O.pattern From CMS; 
11    CMFS.add(O.pattern); 
12    Fpattern.length.add(O.pattern); 
13   }else if (O.pattern.length == k+1 ){ 
14    Remove O.pattern From CMS; 
15    Npattern.length.add(O.pattern); 
16   } 
17  } 
18 End 
圖 7. PMSPMTC 計算 CMS 中序列支持度函數 
 
 
5. PMSPM 系統實作 
 
5.1 實驗環境和模擬資料庫產生 
本節敘述我們進行的 PMSPM 演算法實驗，在不同資料庫參數下，取得本演算法的執行時
間長短，並與 Apriori-based 演算法做比較。實驗機器是使用 Intel Core 2 Duo T2300e 處理器，
2048MB DDRII 667 主記憶體，實驗環境是在 Windows XP 作業系統下進行，使用 Java (JDK 1.6.0) 
程式語言開發。 
 
我們實驗使用的資料集，是與 Agrawal 等人[4]相同的產生方式， 
 
表 1 為參數說明。由於本研究是對於頻繁樣式長度較長的資料做探勘，根據我們觀察產生
的資料集，模擬資料集中產生的序列雖然較長，但序列中項目之間的次序過於混亂無一定順序
性，無法形成較長的頻繁樣式，因此需將序列間的信賴度參數設為 1，使得序列中的項目之間
較具有一定或相似的順序性。接著設定最長樣式種類數(S)，此參數簡述如下，假使設定最長樣
式種類數為 100，交易序列數量為 25000，則模擬資料庫會產生約 100 種左右相異的序列，且其
每一種的數量平均約 250 筆序列左右，而這 250 筆之間彼此的相似度較高。因此，我們利用設
定序列間的信賴度以及設定最長樣式種類數這兩種參數的方式，使得模擬資料庫能存在較長的
頻繁樣式。 
 
表 1. PMSPM 實驗參數說明 
參數 參數說明 
T 交易序列平均交易數量 
D 交易序列數量 
S 最長樣式種類數量 
N 項目數量 
 
 16
5.2 實驗結果與討論 
第一部分，於圖 8 中可發現一開始在長度較短時，由於頻繁樣式的平均長度較短，
Apriori-based 的效率比 PMSPM 較佳，但是隨著平均交易數量的增加，在圖 9 中可明顯看出頻
繁樣式的平均長度也相對增長，導致在由下而上方向中的候選樣式數量開始呈指數型增加，使
用 Apriori-based 方法則需耗費大量的運算，而相對於 PMSPM 雖然在初期時需比 Apriori-based
額外耗費更新最長候選序列集的成本，但是之後卻能早一步的將最長頻繁樣式找出，進而優先
完成探勘動作，節省中間大量的候選樣式檢查與測試。 
 
0
3000
6000
9000
12000
15000
7 8 9 10
交易序列平均交易數量
執
行
時
間
(秒
)
Apriori-based
PMSPM
 
圖 8. PMSPM 交易序列平均交易數量在不同方法下執行時間的比較 
 
0
200
400
600
800
1000
1200
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
樣式長度
最
長
頻
繁
樣
式
個
數
T7
T8
T9
T10
 
圖 9. PMSPM 各長度的最長樣式個數在不同交易序列平均交易數量下的分佈 
 
第二部分，於圖 10 中可以看出 PMSPM 演算法在不同的支持度下，隨著交易序列數的增
加，在執行時間上並沒有大幅地增加的情形，具有良好的加速比；並由圖 11、12、13 中最長樣
式個數的分佈情形也發現，當交易序列數增加的同時，由於較長的交易序列數量也隨之增多，
因而最長頻繁樣式主要的分佈長度也會越長，例如在圖 12 中，當 D10k 時最主要分佈在長度為
6，而 D25k 跟 D50k 時主要集中在交易序列平均交易數附近的長度 9，且 D50k 分佈在大於長度
9 的最長頻繁樣式數量又比 D25k 來得更多。 
 
另一方面，由圖 11、12、13 可明顯得知，最長頻繁樣式的最長長度會隨著門檻值的增加
而呈反向減少，符合我們預期的結果。 
 18
0
30
60
90
120
150
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
樣式長度
最
長
樣
式
個
數
D10k
D25k
D50k
 
圖 13. PMSPM 各長度的最長樣式個數在支持度為 0.15%下的分佈 
 
第三部分，在此預期增加最長樣式種類數，將會造成執行時間增加的結果。圖 14 中顯示
當最長樣式種類數增加時，PMSPM 的執行時間會相對的提高，原因是種類增多的同時，顧客交
易序列符合門檻值的機率也相對降低，造成最長頻繁樣式的平均長度減少，因而需要耗費較多
的更新成本；反之當最長樣式種類數較少時，交易序列為頻繁樣式的機率會大大的提高，同時
資料庫中會存在著長度較長的頻繁樣式，如圖 15、16、17 所示，在不同最長樣式種類數下，
當最小支持度相同時，S50 通常會比 S100 及 S150 有著較多、較長的最長頻繁樣式；因而本方
法在由上而下的階段中，候選最長序列不需做太多次的更新便可得到最長頻繁樣式，所以能比
Apriori-based 方法優先找出所有最長頻繁樣式以結束探勘，但若當 S 太大時亦會導致運算時間
減少，其原因是頻繁的樣式過少，而樣式長度也相對減少，導致在探勘初期時於由下而上方向
成長就可完成探勘，但此種情形較為極端，故於此不加以實驗討論。 
 
0
2000
4000
6000
8000
10000
0.05 0.10 0.15
最小支持度(%)
執
行
時
間
(秒
)
S50
S100
S150
 
圖 14. PMSPM 最長樣式種類數和執行時間的比較 
 20
於受到最長樣式種類數參數的影響，因為當項目個數減少時，模擬資料庫產生的交易序列會以
較少的項目個數來組成樣式，其頻繁的可能性也隨之增高，因此使得在由上而下方向的處理不
需太多更新的次數即可完成探勘。 
 
另外，由圖 19、20、21 可發現當項目個數越大時，最長頻繁樣式的最長長度也有著隨之
增加的趨勢，對於此現象的解釋，在觀察模擬資料庫後發現，當項目個數參數設定較大時，所
產生的模擬資料庫中交易序列平均長度同時也隨著增加，因而造成有長度較長的最長頻繁樣式
產生。 
0
2000
4000
6000
8000
10000
0.05 0.10 0.15
最小支持度(%)
執
行
時
間
(秒
)
N500
N1000
N1500
 
圖 18. PMSPM 項目數量和執行時間的比較 
0
200
400
600
800
1000
1200
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
樣式長度
最
長
頻
繁
樣
式
個
數
N500
N1000
N1500
 
圖 19. PMSPM 各長度的最長樣式個數在支持度為 0.05%下的分佈 
 22
確實比 Apriori-based 演算法要來的好。 
 
而在第三部分及第四部分的實驗中，我們也發現當最長樣式種類數較多，或是項目個數增
加時，會使得所產生的模擬資料庫所產生的序列較混雜不容易產生較長頻繁樣式，因此便需要
較多由上而下的更新成本來更新候選最長序列集合，使得執行的效能變差，同時其產生的最長
頻繁樣式的長度也會相對減少。 
 
因此我們可以得知 PMSPM 演算法較不適用於當序列過於混雜時，造成最長樣式長度較短
的資料庫；反之，PMSPM 演算法則非常適合處理資料庫中存在著較長的最長樣式且序列較不混
雜時的情形。 
 
 
6. PMSPMTC 系統實作 
 
6.1 實驗環境 
 
本節敘述我們進行的 PMSPMTC 演算法實驗，在不同資料庫參數下，本演算法的執行時間
長短，並與 PMSPM 演算法做比較。實驗機器是使用 Intel Core 2 Quad Q9550 處理器，2048MB 
DDRII 800 主記憶體，實驗環境是在 Windows XP 作業系統下進行，使用 Java (JDK 1.6.0) 程式
語言開發。交易資料庫產生方式與 第 5.1 節相同，而時間資料則假設各交易之相鄰項目之間
隔時間符合 卜瓦松分佈 (Poisson Distribution)，我們假設單位時間平均出現次數 (λ) 為 3。 
 
6.2 實驗結果與討論 
 
第一部分實驗在相同交易序列的平均交易數量(T)與三組不同支持度的情形下，以 10000 筆
交易序列來比較 PMSPM 與加上時間限制的 PMSPMTC 演算法以顯示其 CMFS 個數和探勘總時
間之差異，模擬資料庫參數如表 6 和表 7 所示。實驗結果可以由圖 22 發現以 10000 筆交易序列
在 PMSPM 以及 PMSPMTC 演算法中的探勘時間其實是相近的，並未因為加上時間條件而有太
大的差距。 
 
在表 6 和表 7 中，我們發現以 PMSPMTC 演算法實驗所得到的 CMFS 個數比以 PMSPM 演
算法得的 CMFS 個數多出幾倍數量。一般直覺會認為在加入時間限制條件後，條件較多，CMFS
個數應該會比原本未加入時間條件時來得少。我們在詳細檢視其探勘過程後，發現在 PMSPM
演算法中，因為沒有時間條件的限制，因此能產生較長的頻繁樣式，在每一階的過程中，藉由
更新 CMFS 的動作，會刪除掉很多 CMFS 中的子序列，當最長頻繁樣式長度越大，就會刪除越
多的子序列。相對來說 PMSPMTC 演算法，由於有時間條件的限制所獲得的最長頻繁樣式會比
PMSPM 演算法中來的短，因此刪除的子序列較少，所以留下的 CMFS 個數也較多，但這些子
序列在有時間限制的 PMSPMTC 演算法中是相對重要的樣式，因此 PMSPMTC 保留了更多子序
列使得探勘出來的資訊更顯得有意義且有彈性。 
 
表 6. PMSPMTC 實驗之第一部份參數  
資料集名稱 CMFS 個數 探勘總時間(分)
D10I1T10S10_ms5 4457 68.70722 
D10I1T10S100_ms10 960 26.81907 
D10I1T10S100_ms15 563 18.94326 
 
 
 24
 
 
          圖 23. PMSPM 與 PMSPMTC 之探勘時間比較(50000 筆序列) 
 
表 10. PMSPM 與 PMSPMTC 之探勘結果比較 
 
 
 
 
 
 
 
 
 
 
表 11. PMSPM 與 PMSPMTC 演算法各步驟執行時間比較(單位:分) 
 
 
 
 
 
 
 
 
第三部份，實驗在交易序列的平均交易數量(T)不同但支持度相同的情形下，以 10000 筆、
25000 筆以及 50000 筆交易序列在 PMSPMTC 演算法顯示其 CMFS 個數和探勘總時間，模擬資
料庫參數 10000 筆交易序列如表 6 所示、模擬資料庫參數 25000 筆交易序列如表 12 所示、模擬
資料庫參數 50000 筆交易序列如表 13 所示。比較結果顯示在圖 24，可以看出 PMSPMTC 演算
法在相同的支持度下，以支持度為 0.15%和 0.1%下顯示隨著交易序列數量的增加，探勘時間只
有些微的提升，但在支持度為 0.05%下顯示交易序列數量到達 50000 筆時探勘時間會大幅增加。 
 
表 12. PMSPMTC 實驗之第三部份參數 (1) 
資料集名稱 CMFS 個數 探勘總時間(分) 
D25I1T10S100test2.txt_ms13.txt 3323 188.9238 
D25I1T10S100test2.txt_ms25.txt 933 92.75805 
D25I1T10S100test2.txt_ms38.txt 548 63.90104 
 
 PMSPMTC PMSPM
1 階頻繁樣式個數 128 194 
1 階非頻繁樣式個數 72 6 
2 階頻繁樣式個數 645 2148 
2 階非頻繁樣式個數 15739 35488 
2 階 CMS 個數 21222 2725 
 PMSPMTC PMSPM
bottomup_time 0.131778101 0.129504
CMS_updatetime 53.88708941 9.141991
CMS_countingTime 0.176819807 0.087782
CMFS_delsubtime 0.000396189 0.000699
gen_subTime 6.29087E-06 0.000245
 26
 
1. 進一步改進演算法的執行效率，使探勘時間減少。 
2. 針對醫學上或商業上的資料集，使用 PMSPMTC 演算法進行實驗與測試，以對演算
法做進一步的修正與改進。 
 
 
參考文獻 
[1] 許俊傑，MIHSPM：一個多項目集的混合循序樣式探勘演算法，淡江大學資訊管理研究所
碩士論文，2007 年。 
[2] 張耕，考量時間機率之循序樣式探勘方法，淡江大學資訊管理研究所碩士論文，2008 年。 
[3] 顏志祐，一個能發掘更具意義循序樣式的探勘流程，淡江大學資訊管理研究所碩士論文，
2008 年。 
[4] R. Agrawal and R. Srikant, “Fast algorithm for mining association rules”, In proceeding of the 
20th international conference on VLDB, Santiago, 1994, 487-499. 
[5] R. Agrawal and R. Srikant, “Mining Sequential Patterns”, In proceedings of the 17th 
international conference on Data Engineering, Taipei, Taiwan, 1995, 3-14. 
[6] R. Agrawal and R. Srikant, “Mining Sequential Patterns: Generalizations and Performance 
Improvements”, Proc. of the Fifth International Conference on Extending Database Technology, 
1995. 
[7] Y. L. Chen, S. S. Chen, Y. H. Hu, “Mining hybrid sequential patterns and sequential rules”, 
Information Systems, Vol. 27, No. 5, 345-362. 
[8] Y. L. Chen, Y. H. Hu, “Constraint-based sequential pattern mining: The consideration of recency 
and compactness”, Decision Support Systems, Vol. 42, No. 2, pp. 1203-1215, 2006. 
[9] D. Lin and Zvi M. Kedem, “Pincer-Search: An Efficient Algorithm for Discovering the 
Maximum Frequent Set”, IEEE Transactions on Knowledge and Data Engineering, MAY 2002, 
Vol. 14 Issue 3, pp553-566. 
[10] J. Pei, J. Han, and W. Wang, “Mining sequential patterns with constraints in large databases,” 
Proceedings of the Eleventh International Conference on Information and Knowledge 
Management, 2002, 18-25. 
[11] J. Pei, J. Han and Y. Yin, “Mining frequent patterns without candidate generation”, In proceeding 
of the 2000 ACM SIGMOD international conference on Management of Data, New York: ACM 
Press, 2000, 1-12. 
[12] J. Pei, J. Han, B. Mortazavi-Asl, H. Pinto, Q. Chen, U. Dayal and M.C. Hsu, “PrefixSpan: 
Mining Sequential Patterns Efficiently by Prefix Projected Pattern Growth”, Proceedings of the 
17th International Conference on Data Engineering, Heidelberg, Germany, 2001, pp. 106-115. 
[13] X. Yan, J. Han and R. Afshar, “CloSpan: Mining Closed Sequential Patterns in Large Datasets”, 
In proceeding of 2003 SDM conference, San Franciso, CA, May 2003. 
[14] M.J. Zaki, “Sequence Mining in Categorical Domains: Incorporating Constraints,” Proceedings 
of the 9th International Conference on Information and Knowledge Management, pp. 422-429, 
Nov. 2000. 
