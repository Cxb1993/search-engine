可供推廣之研發成果資料表 
▓ 可申請專利  □ 可技術移轉                                      日期： 年 月 日 
國科會補助計畫 
計畫名稱：有限場算數運算理論 : 通用與展延的乘法演算法與其
容錯電路設計 
計畫主持人：李秋瑩 副教授  
計畫編號：NSC 96-2221-E-262 -008 -MY2 
 學門領域：E0805 計算機方法與計算理論 
技術/創作名稱 
GF(2m)乘法器的容錯電路設計 
發明人/創作人 
李秋瑩 
技術說明 
近些年來，有限場算術運算被廣泛應用在編碼理論與電腦密碼上，
在有限場的各種運算之中，GF(2m)乘法演算法及其電路架構設計可
說是有限場算術運算最核心之運算，乃成重要的研究主題。由於橢
圓曲線密碼系統（elliptic curve cryptosystem， ECC）ECC 的
金鑰長度可遠較諸如 RSA 等其他公鑰密碼系統為小就可以達到相
同的安全強度，這使得 ECC 非常適合在行動通訊(如手機)等資源
有限環境下使用。在橢圓曲線密碼系統，有限場 GF(2m)之 m 值須要
使用很大的數值， m 通常是選擇介於 160~200 的質數，但也可選
擇超過 500 的 m 值。最近文獻中，許多學者提出很大的 m值之有
限場 GF(2 m)的乘法演算法，但其架構是缺乏效率及實用性。此外，
為了解決及防止植入錯誤破解密碼術的攻擊，最好的方法就是輸出
正確的密文，也就是說加解密電路在輸出前先檢查無誤後再輸出，
因此，GF(2m)乘法器提供即時偵測錯誤的功能，也成目前最新的研
究主題。為了提升乘法運算的執行速度、降低其複雜度、及即時錯
誤更正能力，本研究擬發展通用式與展延式乘法器並具有容錯功
能，且適合應用於計算功率與記憶體受到限制的元件如智慧卡
（smart card）與手機。 
 
Cryptographic applications in encryption/decryption 
algorithms heavily rely on computations in very large finite 
fields. Their hardware implementations may require millions 
of logic gates. Recently, many researchers have proven that 
cryptosystems can be easily broken by the fault based 
side-channel cryptanalysis. To fight against such fault 
有限場算數運算理論 : 通用與展延的乘法演算法與其容錯電路設計 
The finite field arithmetic algorithm: unified and scalable multiplication algorithm 
and its fault tolerant architecture 
 
Abstract 
Successful implementation of elliptic curve cryptographic systems depends primarily on the 
efficient and reliable performance of arithmetic circuits for finite fields of very large orders those 
being necessary to realize robust encryption/decryption algorithms. Multiplication is the most 
important of the finite field arithmetic operations. It is much more complex compared to finite 
field addition, and frequently encountered in performing point operations in elliptic curve groups. 
In hardware implementations, the structure of multiplication could be built by serial/parallel, 
hybrid or systolic architectures, and by using different bases of representation. These 
architectures, in most of the cases, require millions of logic gates, and it is highly possible to have 
erroneous output values when some of the transistors do not function properly or are attacked by 
fault based cryptanalysis. To have reliable cryptosystems, the existing multipliers using three 
different basis representations have been implemented with concurrent error detection/correction 
capability. Experimental results are reported for comparing the performance of time and space 
overhead in these architectures. 
 
 
Keywords: Finite field multiplier, stuck-at fault, RESO, parity prediction scheme 
  
employs the same hardware circuit to repeatedly carry out an operation. Since the same hardware 
circuit is used, repeated operations will also produce the same erroneous results in the presence of 
faults. The erroneous results therefore cannot be successfully identified by this approach. To 
overcome such problem, repeated operations using shifted operands are then proposed, in [24, 25]. 
Another commonly used approach is based on the augmentation of finite field multipliers over 
GF(2m) with a parity prediction scheme [16,18,19]. Fenn et al. [16] have proposed an on-line 
fault detection method for a bit-serial multiplier in GF(2m). And, Reyhani-Masoleh and Hasan [18] 
have also provided a generic parity prediction scheme for both bit-parallel and bit-serial 
polynomial basis multipliers. Lee et al. [19] have then proposed a bit-parallel systolic dual basis 
multiplier with CED capability.  
All these abovementioned techniques, however, do not make use of the feature of rich 
mathematical structures, which constitute the foundation of many cryptographic schemes, in the 
normal basis representation of GF(2m). Apart from that, these architectures cannot be used for 
detecting even-multiple number of errors. The major advantage of the normal basis (NB) 
representation is that the squaring of an element can be simply performed by cyclic-shifting its 
binary form. Normal basis multiplication was firstly invented by Massey and Omura [11]. 
Various efficient bit-parallel and bit-serial architectures for normal basis multiplication over 
GF(2m) have been developed in [56,12]. In [57,59], we have addressed the issue of error detection 
in a normal basis multipliers. Moreover, traditional multipliers with CED capability can detect 
only odd number of faults in the results because they use only one parity bit in the design. This 
scheme is sometimes called a word-level parity prediction scheme. However, by using this 
scheme, fault-based multipliers can only detect odd number bits in the results. To overcome such 
problem, from the simulated experiments for a polynomial basis multiplier over GF(2163) [58], it 
has shown that, if a parity prediction scheme is chosen by 8 parity bits, the error detection rate is 
about 0.996. The objective of this chapter is to provide a brief overview of finite filed multipliers 
of different basis of representation and the state of the arts of their error detection/correction 
provisions.   
The rest of this chapter is organized as follows. Design of finite field multipliers with 
1. T=0 
2. For i=1 to m do 
3.     T=T+bm-iA 
4. Endfor 
5. Return C=T 
 
Algorithm 2:(LSB-first multiplication) 
Input: A,B∈GF(2m) 
Output: C=AB 
1. C=0 
2. T=A 
3. For i=1 to m do 
4.      C=C+bm-iT  
5.      T=Tα 
6. Endfor 
7. Return C 
 
Based on Algorithm 1, Figs. 1 and 2 show the bit-parallel and bit-serial polynomial basis 
(PB) multipliers, respectively. In Fig. 1, the bit-parallel multiplier consists of an α module and a 
product-sum module. Each α module utilizes calculates αA according to (2). The circuit 
complexity of α module depends on the choice of field polynomial F(x). As F(x) is the 
polynomial with hamming weight W, the structure of each α module needs (W-1) AND gates and 
(W-1) XOR gates. When ( )i iA Aα=  for 0 ≤ i ≤m-1, are computed in α modules, the structure of 
the product-sum module requires m2 AND gates and m(m-1) XOR gates to compute 
)1(
1
)1(
1
)0(
0
−
−+++= mm AbAbAbC L . It is noted that Algorithm 1 is efficiently suited for realizing 
bit-parallel systolic architectures [1,2,3,4,5]. Generally, traditional systolic array multipliers 
depend on the irreducible polynomial F(x). By using an interleaved method, Lee [8] has recently 
proposed low-complexity bit-parallel multiplier for general field, which saves about 50% space 
complexity as compared to traditional systolic array multipliers. Another approach to MSB-first 
bit-serial multiplier is shown in Fig. 2. Both of these bit-serial multipliers have the latency of m 
clock cycles while traditional bit-serial systolic multipliers [6,7] using MSB-first algorithm 
require the latency of 3m clock cycles.  
 
where, ai and *ia  are the coordinates of A∈GF(2m) with respect to the polynomial basis and its 
dual basis, respectively. Assume that the field GF(2m) is constructed from 
mm
m xxfxffxF ++++= −− 1110)( L  over GF(2), and a field element could be determined by 
A=a0+a1α+…+am-1αm-1. The corresponding DB element then can be represented as 
.)()()( 1
1
10 −
−+++= mm AtrAtrAtrA βγαβγαβγ L  
Since F(α)=0, we have 
,
,)( 
,
1
0
)2(22
1
0
)1(
1
1
)0()0()0()0()0(1
1
0
)0(1
1
0
)0(
1
0
1101
i
m
i
mm
i
m
i
i
m
i
i
m
i
m
i
m
i
i
m
i
m
i
iimimi
ii
f
fffffff
ff
αα
αααα
ααα
∑
∑∑∑
∑∑
−
=
−−
−
=
−
=
+−
=
+
−
=
−
=
=
=++==
==
−−−
M
    
where all the coefficients are elements of GF(2). Let B=b0β0+ b1β1+…+ bm-1βm-1 be represented 
in the dual basis. Applying the linear function to both sides of each identity in the above 
equations, one can get 
i
i bBtr =)(γα , for i=0,1,…,m-1,         (7) 
and  
j
m
j
mi
j
i bfBtr ∑−
=
−=
1
0
)()(γα , for i=m,m+1,…,2m-2.      (8) 
Given the above assumptions, let a pair of elements A and B in GF(2m) be represented by 
and ,
1
0
∑−
=
=
m
i
i
iaA α  
.
1
0
*∑−
=
=
m
i
iibB β  
Let us define bi=tr(γαiB), for i=0,1,…,2m-2, and let the element ∑−
=
=
1
0
m
j
jjcC β  be the product of 
A and B. In form of matrix-vector representation, the product C can thus be represented as 
follows: 
al. [9] and is suitable for implementing in VLSI. However, such a multiplier is not able to detect 
any existing single-cell faults. To overcome this drawback, we have modified this multiplier by 
enhancing its concurrent error detection capability simply using a parity prediction scheme. We 
shall discuss the modified multiplier in the next Section. 
 
 
 
 
 
 
 
 
 
 
 
 
 
Fig. 3. The bit-parallel systolic DB multiplier over GF(2m) 
 
0
0
0
0
a0 
a1
ai 
am-1 
f0 f1 fi fm-1 0 0 0 0b0 b1 bi bm-1 
ci cm-c0 c1 
C=(c₀,c₁,ڮ,cm-1) א GF(2m) represent their product, i.e., C=AB. The ith component of C can then 
be represented by 
ci=A(i)ڄMڄ(B(i))T             (14) 
where A(i) denotes a cyclic right-shift of the element A by i positions. The computation of 
multiplication matrix M, is described in [12]. Once the multiplication matrix M is obtained, the 
NB multiplication can be performed according to the following algorithm: 
 
Algorithm 4: (Conventional NB multiplication) 
Input: A=(a₀,a₁,ڮ,am-1) and B=(b₀,b₁,ڮ,bm-1)∈GF(2m) 
Output: C=(c₀,c₁,ڮ,cm-1)=AB 
1. initial : C=0 
2. for k = 0 to m − 1 { 
3.  ck=AڄMڄBT 
4.  A=A<<1 and B=B<<1 
5. } 
6. output C=(c₀,c₁,ڮ,cm-1) 
A<<1(=(a1,a2,ڮ,a0)) denotes a cyclic left-shift of the coordinates of A=(a₀,a₁,ڮ,am-1). 
Applying Algorithm 4, Massey and Omura [11] proposed the first bit-serial NB multiplier. The 
complexity of multiplication in the normal basis N1, represented by CN, is dominated by the 
number of nonzero μi,j values in M, and is measured by the gate count and time delay of the NB 
multiplier. It is shown in [13] that CN for any normal basis of GF(2m) is greater or equal to 2m-1. 
For simple and efficient implementation, a normal basis is so chosen that CN is as small as 
possible. Two types of optimal normal basis (ONB), type-I and type-II, exist in GF(2m) if CN 
=2m-1. However, such ONBs do not exist for all m. 
 
Definition 2.[14] Let p =mt +1 be a prime number and gcd(mt/k,m)=1, where k denotes the 
multiplicative order of 2 module p. Let γ be a primitive (mt+1)th root of unity in some extension 
field of Fp. A Gauss period of type (m,t) over Fp is defined as 
( 1)2 2m m tα γ γ γ −= + + +L . 
By employing Definition 2, we use 
( 1)2 2m m tα γ γ γ −= + + +L  to generate a normal basis 
12 2
1 { , , , }
m
N α α α −= L . This normal basis is called the Gaussian normal basis (GNB) of type (m,t), 
denoted by GNB of type t which exists for GF(2m) whenever m is not divisible by 8. Each 
element 
12 2
0 1 1
m
mA a a aα α α −−= + + +L  of GF(2m) can also be given by  
( 1)
1 ( 1) 1
1 2 1 1
2 2
0
2 2 2
1
2 2 2
1
( )
( )
( )
m m t
m m t
m m mt
m
A a
a
a
γ γ γ
γ γ γ
γ γ γ
−
+ − +
− − −
−
= + + +
+ + + +
+
+ + + +
L
L
L
L
          (15) 
Using the above equation, the normal basis N1 can be converted to the set 
( 1) 1 ( 1) 1 1 2 1 12 2 2 2 2 2 2 2
2 { , , }
m m t m m t m m mt
N γ γ γ γ γ γ γ γ γ− + − + − − −= + + + + + + + + + + +L L L L . From γp=1, the 
set N2 can also be translated into the redundant basis 2 13 { , , , }
pN γ γ γ −= L . For example, type-1 
Applying the basis conversion from the redundant basis to the NB, αB can be represented by 
 
1
2
0, (0)0, (2 )
0
( )
i
i
m
FF
i
B b bα α−
=
= +∑           (20) 
Note that, for t being an even number, one can obtain that 0, (0) 0Fb = . Using the same way, 2iBα  
can be obtained as 
  
12 2 2
1 1
1
2
, (2 )
0
( )
i m
m m m
j
j
i i m i
m
i F
j
B b b b
b
α α α α α
α
−
<− > < − > < − − >
−
=
= + + +
=∑
L
      (21) 
where 
  ( 1), ( ) ( 1) ( 2 ) ( 2 )
...m m ti F j F j i F j i F j ib b b b −< − − > < − − > < − − >= + + + . 
Example 1. Let B=(b0,b1,b2,b3,b4) be the NB element of GF(25), and let 10α γ γ= +  be used to 
generate the NB. We have 
2 2
3 3
4 4
2 10 2 2 9
2 10 2 4 7
2 10 2 8 3
2 10 2 5 6
( )
( )
( )
( )
α γ γ γ γ
α γ γ γ γ
α γ γ γ γ
α γ γ γ γ
= + = +
= + = +
= + = +
= + = +
 
Thus, 
2 3 42 2 2 2
0 1 2 3 4B b b b b bα α α α α= + + + +  in GF(25) can be also represented by 
2 3 4 5 6 7 8 9 10
0 1 3 2 4 4 2 3 1 0B b b b b b b b b b bγ γ γ γ γ γ γ γ γ γ= + + + + + + + + + . 
Then, αB is obtained by 
10
(1) (10)
( )B B
B B
α γ γ= +
= +
 
where 
(1) 2 3 4 5 6 7 8 9 10
0 0 1 3 2 4 4 2 3 1B b b b b b b b b b bγ γ γ γ γ γ γ γ γ= + + + + + + + + +  
(10) 2 3 4 5 6 7 8 9
0 1 3 2 4 4 2 3 1 0B b b b b b b b b b bγ γ γ γ γ γ γ γ γ= + + + + + + + + +  
 
Therefore, by converting the redundant basis to the NB, one obtains 
1 0 3 3 4 2 1 2 4( , , , , )B b b b b b b b b bα = + + + + . In hardware implementation, four XOR gates are 
required to compute αB. 
Remark 2. Let two types of an optimal normal basis (ONB), type-I and type-II, exist in GF(2m). 
Then, the complexity of αB is required by (m-1) XOR gates. 
As stated above, the normal basis multiplication is addressed as follows: 
 
Algorithm 5. 
Fig
Fig.
 
Fig.
 
3. Fault
word-le
A fa
.5: Sequen
6. The deta
7. Bit-paral
 detection
vel parity
ult general
tial norm
iled circuit 
lel normal 
 architec
 predicti
ly results d
al basis m
of a U-cell 
basis multip
tures in f
on schem
ue to the 
ultiplier o
in Fig. 5 
lier over G
inite field
e 
change of 
ver GF(2
 
F(2m) 
 multipli
state in a f
 
m) 
cation us
aulty circu
 
ing the 
it component. Some 
pre-calcul
the predic
Fig.8. The
 
In F
generator
parity pre
field mul
ˆˆC Ce P= +
 
3.1. Not
In t
be used in
Definition
0 += aA α
0 +=A aP
 
ation of th
ted parity w
 functional
ig. 8, the 
 unit uses a
diction uni
tiplication. 
1CP = , ind
ations 
his subsect
 the parity 
 3. L
2
1 +aα L
1 ++ maa L
e resulting 
ith a real p
 block for c
circuit und
 XOR-tree 
t calculates
A mismatc
icates the p
ion, the par
prediction f
et a 
2
1
−
−+
m
ma α
2  mod  1−
parity for a
arity can ea
oncurrent e
er test (CU
to produce
 the predic
h on the a
resence of a
ity of field
or finite fie
field ele
1
. The par
. 
n arithmeti
sily detect
rror detect
T) is the o
 a real parit
ted parity b
ctual parity
n error in t
 elements i
ld multipli
ment A
ity bit PA o
c operation
 single stuc
ion architec
riginal mu
y bit CP  o
it CˆP , and
 CP  and t
he multiplic
n GF(2m) w
cation of G
in GF
f field elem
. Performin
k-at fault, a
ture  
ltiplier arc
f the CUT
 its archite
he predicte
ation of C=
ill be defin
F(2m) will t
(2m) be 
ent A coul
g a simple 
s shown in 
 
hitecture. T
. The struct
cture relies
d parity bi
AB. 
ed and a th
hen be dev
represen
d then be d
check for 
Fig. 8. 
he parity 
ure of the 
 on finite 
t CˆP ,e.g., 
eorem to 
eloped. 
ted by 
efined as 
 
 Remark 3. Let the field GF(2m) be constructed from an irreducible 
1
0 1 1( )
m m
mF x f f x f x x
−
−= + + + +L , then the Hamming weight of an irreducible polynomial F(x) 
is an odd number. Since ( ) 0F α = , we have 1
0
0m
m
i
i
P pα
−
=
= =∑ . 
Theorem 4. Let the field GF(2m) be constructed from an irreducible polynomial 
F(x)=f0+f1x+…+fm-1xm-1+xm over GF(2). For any filed element A=(a0,a1,…,am-1) in polynomial 
basis representation, the parity prediction of αA could be obtained as  
AmA PaP += −1α .             (23) 
Proof. In finite field GF(2m), the Hamming weight of an irreducible polynomial F(x) is still an 
odd number. For instance, the field GF(25) is constructed from an irreducible polynomial 
F(x)=x5+x2+1. Let α be the root of F(x), we have im
i
i
m fαα ∑−
=
=
1
0
. Note that, the polynomial F(x) 
is irreducible, then f0=1, that is, 1
1
1
=∑−
=
i
m
i
if α . Assume that the field GF(2m) is built by the 
irreducible polynomial F(x), then αA can be computed as 
2
0 1 1
2 1
1
0 0
m
m
m m
i i
i m i
i i
A a a a
a a f
α α α α
α α
−
− −
−
= =
= + + +
= +∑ ∑
L
 
Thus, the parity prediction of αA is given by 
2 1
1
0 0
2 1
1 1
0 1
1
1
0
1
m m
A i m i
i i
m m
i m m i
i i
m
i m
i
A m
P a a f
a a a f
a a
P a
α
− −
−
= =
− −
− −
= =
−
−
=
−
= +
= + +
= +
= +
∑ ∑
∑ ∑
∑
 
■ 
Let us define that 
(3m-2) XO
the corres
Fig. 9. Fa
 
3.3. Nor
In th
All the m
will then 
 
3.3.1. Par
By 
over GF(
t=even an
Case 1: p
Let 
α γ γ= +
(0)FB b γ=
R gates. W
ponding err
ult detectio
mal basis
e previous
ultiplier arc
investigate 
ity predict
employing
2) could be
d t=odd. 
arity predic
a field ele
2 2m mγ+ +L
2
(1)Fb γ+ +
hen the in
or will be d
n architectu
 multipli
 section, bit
hitectures i
the parity p
ion of α m
2mα γ γ= +
 generated
tion in Bα
ment B of 
( 1)t−
with an
( 1)F pb γ−+L
put signal i
etected by
re in bit-pa
er with th
-parallel an
nclude regi
rediction sc
odule 
(2m tγ −+ +L
. The pred
2i with an e
GF(2m) be
 even t. 
1p− . From
n a PB mul
 the XOR-2
rallel PB m
e CED
d sequentia
ster, α, and
heme for n
1)
, a norma
icted parity
ven t 
 represente
Applying 
 the basis
tiplier is af
 gate, i.e., 
ultiplier ov
l normal b
 the produc
ormal basis
l basis N
 of αB wi
d by B b=
the redun
 conversio
fected by a
ˆ 1Ce = . 
er GF(2m) 
asis multipl
t-sum mod
 multiplica
2
1 { , ,α α= L
ll be consi
2
0 1bα α+ +
dant repre
n of the n
 single stuc
iers were in
ules. This s
tion over G
12, }
mα −  fo
dered for t
2
1mb α−+L
sentation, 
ormal bas
k-at fault, 
 
troduced. 
ubsection 
F(2m). 
r GF(2m) 
wo cases: 
1m−
, where 
we have
is to the 
Observing the above equation, αB has four terms for each of bi,1≤i ≤6 , and three terms for b0. 
Therefore, the parity prediction of αB is equal to 0BP bα = . 
 
Table 1. The sequence of F(k) for type-4 GNB over GF(27) 
 
 
As 
mentioned above, for type-2 normal basis, the parity prediction of αB is also the same as 
0BP bα = , as seen in Example 2. Generally, we can conclude that the result 0BP bα = 　 is the parity 
prediction of αB for the normal basis of GF(2m) with t=even. This is an important rule to derive 
the parity prediction of normal basis multiplication over GF(2m), because αB is the core operation 
of the normal basis multiplication in (18). 
Since the field element B is a normal basis of GF(2m), the squaring of B can be easily 
performed by a cyclic right-shift, i.e., 2 1 1( , , , )
i
m i m i m iB b b b− − + − −= L . According to the rule from 
(18), the LSB-first bit of 2
i
B  is bm-i, and the parity prediction of 2
i
Bα  can then be obtained as  
2i m iB
P bα −=              (31) 
Case 2: Parity prediction in αB with odd t 
Let 
( 1)2 2m m tα γ γ γ −= + + +L with an odd t generate the normal basis of GF(2m). Applying 
the redundant basis representation, 
1
2
0, (0)0, (2 )
0
( )
j
j
m
FF
j
B b bα α−
=
= +∑ in (21) can also find that there 
exists t terms for bj ,1≤j≤m-1, and (t-1) terms for b0 in the coefficient 0, ( )F ib , for 1≤ i≤ p-1. When t 
is an odd number, we obtain the following properties: 
1) If the field GF(2m) exists an odd-type normal basis, then m must be an even number since 
mt+1 is a prime. 
k 1 2 3 4 5 6 7 8 9 10 11 12 13 14 
F(k) 0 1 5 2 1 6 5 3 3 2 4 0 4 6 
k 15 16 17 18 19 20 21 22 23 24 25 26 27 28 
F(k) 6 4 0 4 2 3 3 5 6 1 2 5 1 0 
In Sub-sections 3.3.1 and 3.3.2, the parity prediction functions for α and product-sum 
modules were presented. Using these parity functions in (19) and (20), the parity prediction of 
multiplication for the even-type normal basis, denoted by CˆeP , can be computed by 
12 2 20 1 1
0 0 1 1 1 1
ˆ ˆ ˆ ˆ
m mCe mB B B
m m
P a P a P a P
a b a b a b
A B
α α α− −
− −
= + + +
= + + +
= ⊗
L
L         (38) 
where ⊗  denotes the inner-product operation. Moreover, the parity prediction of multiplication 
for the odd-type normal basis, denoted by CˆoP , can be obtained by 
0 0 1 1 1 11 1
2 2 2
1
0 2
( )
2
ˆ ( ) ( ) ( )
m m m
m
Co m B m B m m m Bm
m
i m A Bii
m
A B
P a b a P a b a P a b a P
a b P P
A B P P
− −< > < − > < − + >
−
< − >=
= + + + + + +
= +
= ⊗ +
∑
L
 (39) 
Assume that the actual parity of C in (18) is calculated by 0 1 1C mP c c c −= + + +L . Thus, the 
parameter ˆCe  could be defined with the following function for detecting C computations. 
ˆ
ˆ
ˆ
Ce C
C
Co
P P for t even
e
P P for t odd
⎧ + =⎪= ⎨ + =⎪⎩
         (40) 
The result ˆ 1Ce =  indicates presence of a faulty C computation. Applying the bit-parallel 
multiplier in Fig.7, Fig.10 shows the proposed bit-parallel NB multiplier with CED capability. In 
Fig.10, the parity prediction unit is composed of m+1 AND gates and m-1 XOR gates to generate 
the parity prediction bit CˆP . The XOR-1 gate is responsible for the actual parity PC of the 
original NB multiplication. The XOR-2 gate is used for comparing to PC and CˆP . Fig.10 shows 
the ways to detecting errors in the bit-parallel multiplier for the even-type normal basis of GF(2m). 
When both input signals of the AND-3 gate are replaced by signals PA and PB, and the signals 
b0,b1,…,bm-1 are replaced by the signals 
1 1
2 2 2
, , ,m m mb b b+ −L , the architecture in Fig.10 can then be 
3.4 Concu
In th
basis mul
fault mod
bm+i (for 
algorithm
Case 1: E
Let 
+imb
In the fo
commonl
Theorem
correspon
as 
= 00ˆ B fbPα
Fi
rrent erro
is subsecti
tiplication 
el is assum
0≤i≤m-2) an
 are discuss
rror detec
us consider
10 ++= i bfb
llowing, w
y used mod
 5. Let =B
ding parity
∑−
=
+
1
1
m
i
ii fb   
g.11. Seque
r detection
on, we will
over GF(2m
ed. The dua
d the origi
ed as follow
tion in com
 the compu
1 ++ mi bf L
e assume 
el for logic
∑−
=
1
0
m
i
iib β an
 bit of B, re
  
ntial NB m
 in a bit-p
 investigate
) proposed
l basis mul
nal multipl
s. 
puting bm
tation of bm
11 −+− mi f  
that the fa
al faults. 
d ∑−
=
=
1
0
m
i
BP
spectively. 
 
ultiplier ov
 
arallel syst
 a concurre
 in [19]. I
tiplication i
ication. He
+i (for 0≤i≤
+i: 
ult model 
ib be the du
The predict
 
er GF(2m) w
olic multip
nt error det
n the follo
nvolves tw
nce, the tw
m-2) 
is the stuc
al basis rep
ed parity b
  
ith the CE
lier for du
ection (CED
wing discu
o operation
o error dete
k-at fault 
resentation
it of αB can
 (4
 
D 
al basis of 
) algorithm
ssion, the s
s: the comp
ction schem
since it is 
 and the 
 then be re
1) 
GF(2m) 
 for dual 
ingle-cell 
utation of 
es in the 
the most 
presented 
Case 2: Error detection on original multiplication 
Let the product of αi and B be obtained as αiB =biβ0+ bi+1β1+…+ bi+m-1βm-1. The predicted 
parity bit of αiB is the same as j
m
j
jiiB fbfbP i ∑−= −+− +=
1
1
101α and could be easily computed. Thus, the 
predicted parity bit of the product BaBaBaC mm
1
110
−−+++= αα L  can be calculated by 
∑−
=
=
1
0
ˆˆ
m
i
BiC iPaP α             (47) 
The parity bit of the original product C is ∑−
=
=
1
0
m
i
iC cP , where ji
m
j
ji bac +
−
=
∑= 1
0
. Finally, the error 
detection of the product C can be signaled by comparing with the actual parity CP  and the 
predicted parity CPˆ , that is, CCC PPe += ˆˆ . The result 1ˆ =Ce  indicates an existing single-cell 
fault. 
As stated above, both (45) and (47) are used to detect errors on the multiplier output. If the 
computations of bm+i are error-free, then 0ˆ =+ imbe , and 1ˆ =+imbe  indicates an existing single-cell 
fault. Note that when a single-cell fault occurs on bm+i computations, this fault does not affect the 
output of bm+j computations, where i≠j. Based on (45), we can detect all single-cell faults 
occurred in the computations of bm+i. When single-cell fault occurs on ci computations, this fault 
does not affect the output of cj computations, where i≠j. Therefore, for detecting all single-cell 
faults in the entire multiplier, 1ˆ =Ce  indicates presence of a single-cell fault. Since (45) and (47) 
are over GF(2), the values of 
1
ˆ
+mbe  and Ceˆ  would detect not only a single-cell fault, but also all 
odd-number single-cell faults. With a similar argument, it is clear that any even-number 
single-cell faults in cells of the ith row cannot not be detected by 
imb
e +ˆ . Similarly, the value Ceˆ  
cannot detect any even-number single-cell faults in cells of the ith column. 
A modified bit-parallel systolic dual basis multiplier with concurrent error detection is 
shown in Fig.12. The modified multiplier consists of (m+1)×m identical cells, including m×(m-1) 
U-cells, (m+1) V-cells and (m-1) W-cells. The detailed circuits for U, V and W cells are depicted 
in Figs.13, 14 and 15, respectively.  
 Fig.13. The detailed U-cell circuit 
 
Fig.14. The detailed W-cell circuit 
bin2 
bout2 
ain
bin1 
Error detection
P
arity  
com
putation
imbe +ˆ
CPˆ
CPˆ
BiP 1
ˆ +α
BiPαˆ
BiP 1
ˆ +α
fin
foutbout1 cout 
ain 
bin2 
cin bin1 
aout 
bout2 
in
f
BiP 1
ˆ +α B
iP 1ˆ +α
1
2
3 
4
5
6 
Parity 
computation 
outf
is easily detected.  
5) Error on cout  
   If an error occurs on cout of the faulty cell Ui,j. This error will infect output cj. That is, this 
error influences the final results on cj. Therefore, computing the parity bit of C in V-cells can be 
calculated using ∑−
=
=
1
0
m
j
jC cP . The predicted parity bit of C in W-cells is performed using 
∑−
=
=
1
0
ˆˆ
m
i
BiC iPaP α . After comparing the actual parity CP  and the predicted parity CPˆ  at 
Vm-1,m-cell, this error is then detected. 
6) Error on bout2 or BiP 1
ˆ +α  
   If an error occurs on bout2 of the faulty cell Ui,j. This error will infect only the bm+i’s output. 
Therefore, 
imbe +ˆ  in the Wi,m-cell can become the logical one, that is, this error has been detected. 
Similarly, the error on BiP 1
ˆ +α  in cell Ui,j can also be detected. 
7) Errors on CPˆ  or CP  
   If an error occurs on CPˆ  in the cell Wi,m, then Ceˆ  in the cell Vm-1,m will become the logical 
one. That is, this error can be detected. Similarly, the output of CP  in the Vm-1,j-cell is faulty. 
This error in the Vm-1,m-cell can also be detected. 
  As stated above, the proposed concurrent error detection scheme uses two parity predictions, 
CPˆ  and BiPαˆ , to detect errors in the entire multiplier. The advantages of the proposed multiplier 
are described as follows: 
1) All single-cell faults can be detected. 
2) The proposed multiplier with concurrent error detection takes only one extra clock cycle 
compared with the dual basis multiplier in [9] without concurrent error detection. 
 
4. Fault detection/correction architecture in dual basis multiplier using 
bit-level parity prediction scheme 
 
Patel and Fung [21, 22] firstly utilized the Re-computing with Shifted Operands (RESO) 
systolic DB multiplier using the bit-level parity prediction scheme. Firstly, according to 
Algorithm 3, a modified DB multiplier is addressed as follows. 
 
4.1. Modified bit-parallel systolic DB multiplier 
 
Let  
),,,( 11
)(
−++= miiii bbbB L , 
),,,( 110 −= mfffF L , 
),,,( 110 −= maaaA L . 
Therefore, we have  
,)( FBb iim ⊗=+  
.)( BBc ii ⊗=  
where "" FX ⊗  denotes the inner-product multiplication of X and F. Based on the computation 
of both imb +  and ic , the DB multiplication can be carried out by the following algorithm. 
 
Algorithm 6: 
Input: A= (a0,a1,…,am-1), B= (b0,b1,…,bm-1) and F=(f0,f1,…,fm-1) 
Output: C=(c0,c1,…,cm-1) 
Step 1. C=(0,0,…,0) 
Step 2. For i=0 to m-1 
{ 
step 2.1. ( )im ib B F+ = ⊗  
step 2.2 ABc ii ⊗= )(  
} 
Step 3 return C=(c0,c1,…,cm-1) 
 
Given Algorithm 6, the DB multiplication needs m-time of loop computations. Each iteration 
involves two steps, steps 2.1 and 2.2. Step 2.1 performs am+i computation and Step 2.2 computes 
the original multiplication. Both steps are based on the inner product operation. Fig.16 shows the 
bit-parallel systolic multiplier, consisting of m2 U-cells, over GF(2m). Each U-cell, as shown in 
Fig. 17, is performed by the following operations 
ci=ci+ajbi+j, 
bm+i=bm+i+fjbi+j. 
FBb iim ⊗=+ )(  and ABc ii ⊗= )( . We will then check for the parity predictions of imb +  and ic  
as follows: 
Case 1. Parity prediction in bm+i 
Let an irreducible polynomial mmm xxfxffxF ++++= −− 1110)( L  be used for generating 
the field GF(2m) and α be the root of )(xF . Then, we have 
αm=f0+f1α + … +fm-1αm-1          (48) 
αm+1=α(f0+f1α + … +fm-1αm-1) 
= fm-1f0+(f0+ fm-1f1)α+ (f1+ fm-1f2)α2 + … +(fm-2+ fm-1fm-1)αm-1 
=f’0+f’1α + … +f’m-1αm-1 .         (49) 
Let )',,','(' 110 −= mfffF L , and FBfbfbfbb imimiiim ⊗=+++= −−+−−−+ )1(121011 L  could then 
be performed in the (i-1)th computing loop, the parity prediction of imb +  is thus performed by 
computing 
'.
'''
)()(
)(
ˆ
)1(
12101
2112011011
121011
22110
11110
FB
fbfbfb
fffbfffbffb
fbfbfbf
fbfbfb
fbfbfbP
i
mimii
mmmimmimi
mimiim
mimii
mimiib im
⊗=
+++=
+++++=
++++
+++=
+++=
−
−−+−
−−−−+−−−
−−+−−
−−++
−−+++
L
L
L
L
L
   (50) 
It is shown that 
imb
P +ˆ can be calculated in the (i-1)
th computing loop, because )1( −iB  and 'F  
are both the input signals of the (i-1)th computing loop. In this way, imb +  and 1ˆ ++imbP at the i
th 
computing loop can be calculated by  
FBb iim ⊗=+ )(  
and 'ˆ )(
1
FBP ib im ⊗=++ , respectively. 
 
Case 2: Parity prediction in ci 
Since i
m
i
i
m fαα ∑−
=
=
1
0
, we have  
. '''
)()(
)(mod
)(mod'
1
110
1
11211001
1
2
10
−
−
−
−−−−−
−
+++=
+++++=
+++=
=
m
m
m
mmmmm
m
m
aaa
faafaafa
Faaa
FAA
αα
αα
αααα
αα
L
L
L
     (51) 
Given (9), the coefficient 1−ic  in the (i-1)
th computing loop is performed by 
.)1(211101 ABbababac
i
immiii ⊗=+++= −−+−−− L  
step 2.1. ),(),( )()( ABFBcb iiiim ⊗⊗=+  
step 2.2 )','()ˆ,ˆ( )()(
11
ABFBPP iicb iim ⊗⊗=+++  
step 2.3. )ˆ,ˆ()ˆ,ˆ( icimbcb cPbPee iimiim ++= +++  
} 
Step 3 return C=(c0,c1,…,cm-1) 
 
In Algorithm 7, it should be noted that, in the ith computing loop, the two steps (2.1 and 2.2) have 
the same inner-product operations in carrying out the two pairs, ),( iim ca +  and )ˆ,ˆ( 11 +++ iim ca PP , 
respectively. And, four input signals: ',, FAF and 'A , are used in each iteration. According to 
Algorithm 7, Fig. 18 shows the proposed fault detection architecture for DB multiplication. The 
proposed architecture consists of one DB multiplier and m V-cells. Applying repeated computation 
method, we can use only one DB multiplier to realize the computations of both steps (2.1 and 2.2), 
because these two steps have the same operations. Each V-cell is composed of two XOR gates, two 
SWs, one 1-bit latch and one AND gate to perform Step 2.3, as shown in Fig.19. In the V-cell, the 
signal k is for controlling the severance of two signals bm+i and imbP +ˆ . 
From the four steps (2.1~2.2) in Algorithm 7, a Ui,j-cell is performed by the following 
computations:  
First cycle: bm+i=bm+i+bi+jfj  
ci=ci+bi+jaj 
Second cycle:
1
ˆ
++imbP = 1ˆ ++imbP +bi+jf’j 
1
ˆ
+icP = 1ˆ +icP +bi+ja’j 
Notably, in the V-cell, SW1 is used to separate two signals ic  and 1ˆ +icP , in which the signal 
ic  goes through SW1 for comparing the predicted parity bit icPˆ , such that ii cic Pce ˆˆ += . When 
1ˆ =
ic
e , it indicates that the computation of ic  in the i
th row-cells is incurred by a stuck-at fault. 
The signal 
1
ˆ
+icP is provided to compare the value ci+1 in the Vi+1-cell with XOR-2 gate. Similarly, 
SW2 is used for separating two signals imb +  and 1ˆ ++imbP . Signal imb +  goes through SW2 and 
will be used to compare the predicted parity bit 
imb
P +ˆ  with XOR-1 gate, such as 
mimi bmib
Pbe ++ += + ˆˆ . Therefore, the proposed DB multiplier with CED capability uses two 
 
Fig. 19.  The detailed circuit of a V-cell in Fig.18 
 
From Algorithm 7, the DB multiplication in each computing loop involves four operations: imb + , 
1
ˆ
++imbP , ic  and 1ˆ +icP . Suppose that the Ui,j cell is faulty. Since imb +  and imbP +ˆ  are performed in the 
results of the (i-1)th and ith row-cells, respectively, the actual value imb + at the Vi-cell is compared 
with the predicted parity 
imb
P +ˆ using a single XOR gate through the computation imbb bPe imim ++= ++ ˆˆ . 
Similarly, in the Vi-cell, the result ci , for 0≤i≤m-1, can also be detected if a stuck-at fault occurred at 
the corresponding Ui,j-cell. Table 2 shows the output of two pairs (bi+m, ci) and (
1
ˆ
++imbP , 1ˆ +icP ) from the 
ith row U-cells. As shown in Table 1, in the (m+1)th iteration, (
1
ˆ
+mbP , 1cˆP ) and  (bm+1, c1) are 
produced from first and second row-cells, respectively. The V1-cell can then detect faults for signals 
bm+1 and c1. Similarly, the V2-cell in the (m+2)th iteration can detect faults for signals bm+2 and c2, 
and so on. From Table 2, as c1 and c2 are the consecutive error bits in the results; errors in the V1 and 
V2 cells can thus be detected, because the parity prediction of 
1cˆ
P  and 
2cˆ
P in the first and the second 
row-cells are not faults. When c1 and c3 have errors, V1 and V3 cells can detect these errors. Therefore, 
it can be shown that the advantage of the proposed fault-based multiplier is its ability to detect both 
even-multiple and odd-multiple faults. Notably, traditional fault-based multipliers [16,17] are based 
on a word-level parity prediction scheme; their architectures have the capability of detecting only 
0101 k
ic
eˆ
imb
e +ˆ
ic
ic
Pˆ
imb
P +ˆ
ic cP i 1ˆ +
imb bP im +++ 1ˆ
imb +
imb +
sw2
sw1
1
2
22 3 1
0 1 1
2 3 1
0 1 3
1
2 0 1 1
1
1 0 1 1
1
0 1 1
'' mod ( )
mod ( )
( )
( ' ' ' )
'' '' ''
m
m
m
m
m
m m
m
m m
m
m
A A F x
a a a F x
a a a
a f f f
a f f f
a a a
α
α α α
α α α
α α
α α
α α
+
−
−
−
−
− −
−
− −
−
−
=
= + + +
= + + +
+ + + +
+ + + +
= + + +
L
L
L
L
L
 
where 
2 1
2 1 2
' 0,1
''
' 2 1
m i m i
i
m i m i i
a f a f for i
a
a f a f a for i m
− −
− − −
+ =⎧= ⎨ + + ≤ ≤ −⎩
 
Thus, from 2 2 0 3 1 1 1i i i m i mc b a b a b a+ + + + + −= + + +L  in (9), the predicted parity bit 2icP + can also be 
performed by 
'.'
''''''
)'(
)'()'(
)(
)'''(
ˆ
)(
11110
1
2
221
121110201
111102
111101
311302
1113022
AB
ababab
afafab
fafabfafab
fbfbfba
fbfbfba
ababab
abababP
i
mimii
m
j
jjmjmji
mmimmi
mimiim
mimiim
mimii
mimiici
⊗=
+++=
+++
+++=
++++
++++
+++=
+++=
−+−+
−
=
−−−+
−−+−−
−−++−
−−++−
−+−++
−++++
∑
+
L
L
L
L
L
      (56) 
Fig. 20 shows the proposed DB multiplier with concurrent error correction capability, based on 
(50),(52),(55) and (56). This architecture consists of m×m Q-cells and m W-cells. A W-cell is 
comprised of one voting element, one AND gate, two 1-bit latches and one SW1×3, as shown in 
Fig.21. When the data pairs ( , , )F A B , ( ', ', )F A B  and ( '', '', )F A B  are fed to the designed array 
multiplier in a top-down manner, as shown in Fig. 20, we can find that three value pairs, 
( , )m i ib c+ , 1 1
ˆ ˆ( , )
m i ib c
P P+ + +  and 2 2
ˆ ˆ( , )
m i ib c
P P+ + + can be performed in the U-cells of i
th row. The pair of 
values 
1 1
ˆ ˆ( , )
m i ib c
P P+ + + is used to predict the result of the (i+1)
th row U-cells; the value pair 
2 2
ˆ ˆ( , )
m i ib c
P P+ + + is used for predicting the result of the (i+2)
th row of a U-cells. From Fig.20, if the 
output result of the ith row of U-cells is the value ci, the (i+1)th and (i+2)th rows of U-cells will 
collectively form the output of ˆ
ic
P . Notably, if ˆ
ic
P is correct, then we have ˆ
ic i
P c= . Therefore, 
by using the “triple modular redundancy” technique, three corresponding values ci for the ith, the 
(i-1)th and the (i-2)th row U-cells, respectively, are fed into a voting element of a Wi-cell. A voting 
element receives the outputs from three values ci and delivers the majority vote as its output.  
 
 
PB multiplier is shown in Fig.9. The bit-parallel and sequential circuits of NB multipliers could 
be seen in Figs.10 and 11. Lastly, Fig. 12 shows the DB multiplier with CED capability. Table 3 
lists various bases multipliers with CED capability for comparison of time and space 
complexities. In bit-serial and bit-parallel architectures, finite field multipliers require time 
overhead of 2log 1m +⎡ ⎤⎢ ⎥  XOR gate delays. In the case of bit-parallel systolic architecture, we 
can obtain a minimum time overhead. For example, DB multiplier in Fig. 12 demands only one 
cycle clock of time overhead. For the space overhead, NB multipliers have lower space overhead. 
To enhance the CED feature for a PB multiplier, the major drawback results from the fact that the 
input signal of the parity prediction circuit depends on the MSB-first bit generated in each 
computing loop in the original multiplier. If the MSB-first bit in CED PB multipliers produces a 
single fault, this error will then propagate throughout the computation of parity prediction CˆP . 
That is, in such condition, PB multiplier architecture will lose the CED feature. 
 
Table 3. Comparison of various finite field multipliers with CED capability 
multipliers Basis architecture Fault detection 
scheme 
Fault 
coverage
space overhead Time 
overhead 
RMH [17] 
in Fig.5 
PB Bit-parallel Word-level 
parity 
prediction 
50% XOR: 2m 
AND: m 
TA+(⎡log2m⎤
+2)TX 
RMH [17] 
in Fig.8 
PB Bit-parallel Word-level 
parity 
prediction 
50% XOR:2m+2 
AND: 1 
Latch: 2 
⎡log2m⎤TX 
Fenn et al. 
[16] 
PB Bit-serial Word-level 
parity 
prediction 
50% MUX: 1 
XOR: 2 
AND: 1 
Latch: 2 
⎡log2m⎤TX 
Chiou et al. 
[25] 
MB Semi-systolic RESO 100% XOR: 3m 
AND: 2m 
Latch: 5m+1 
MUX:2m 
Converter:3 
4 clock 
cycles 
Fig.9 PB Bit-parallel Word-level 
parity 
prediction 
50% XOR: 3m-1 
AND: m 
⎡log2m⎤TX 
Fig.10 NB Bit-parallel Word-level 
parity 
prediction 
50% XOR: 2m-1 
AND: m+1 
⎡log2m⎤TX 
Fig.11 NB sequential Word-level 
parity 
prediction 
50% XOR: m+3 
AND: 2 
Latch: 1 
⎡log2m⎤TX 
Fig.12 DB Bit-parallel Dual parity 100% XOR: m2+4m 1 clock 
errors in bit-parallel systolic DB multipliers. It is shown that, by using a word-level parity 
prediction scheme, less time and space overhead could be achieved in DB multipliers than that of 
CED multipliers. Interestingly, CED multipliers using word-level parity prediction scheme can 
detect only old number of faults in the results, while in the case of bit-level parity prediction 
scheme, the proposed CED multiplier can detect both odd-multiple and even-multiple faults in 
results of multiplications. Moreover, by using the “triple modular redundancy” technique, we also 
present the DB multiplier with concurrent error capability. It has been shown that bit-level parity 
prediction is an efficient on-line error detection/correction method for bit-parallel DB multipliers 
over GF(2m). Furthermore, the proposed architecture has some attractive features, such as 
regularity, modularity, and concurrency, for high-speed VLSI system design. The proposed 
multiplier could have numerous potential applications, for example, error correction codes and 
public-key cryptography. 
 
7.References 
 
[1] C.Y. Lee, C.W. Chiou and J.M. Lin, "Unified Parallel Systolic Multiplier over GF(2m)," 
Journal of Computer Science and Technology, Vol. 21, No.6, Nov. 2006 
[2] C.Y. Lee, C.W. Chiou, A.W. Deng and J.M. Lin, "Low-Complexity Bit-parallel systolic 
architectures for computing A(x)B2(x) over GF(2m)," IEE Proceeding Circuits and Systems, 
Vol. 153, Issue 4, pp. 399–406, Aug. 2006. 
[3] C.Y. Lee and C.W. Chiou, "Efficient design of low-complexity bit-parallel systolic Hankel 
multipliers to implement multiplication in normal and dual bases of GF(2m)," IEICE Trans. 
Fund., vol. E88-A, no.11, pp. 3169–3179, Nov. 2005. 
[4] C.Y. Lee, J.S. Horng and I.C. Jou, "Low-complexity bit-parallel systolic Montgomery 
multipliers for special classes of GF(2m)," IEEE Trans. Computers, vol. 54, no. 9, pp. 
1061–1070, Sep. 2005. 
[5] H. Wu, "Bit-parallel finite field multiplier and squarer using polynomial basis," IEEE Trans. 
Computers, Volume 51,  No. 7, PP. 750 – 758, July 2002.  
[6] S.M. Park, K.Y. Chang and D. Hong, "Efficient Bit-Parallel Multiplier for Irreducible 
Pentanomials Using a Shifted Polynomial Basis," IEEE Trans. Computers, Volume 55,  No. 9, 
PP. 1211 - 1215, Sep. 2006.  
[7] M. Diab and A. Poli, "New bit-serial systolic multiplier for GF(2m) using irreducible 
trinomials," Electronics Letters, Volume 27,  Issue 13, Pp.1183 - 1184 , June 1991   
[8] C.Y. Lee, "Low-complexity bit-parallel systolic multipliers over GF(2m)," Integration, the 
VLSI Journal , Volume 41, Issue 1, PP. 106-112, January 2008. 
[9] S.T.J. Fenn, M. Benaissa, and O. Taylor, "Dual basis systolic multipliers for GF(2m)," IEE 
Computers and Digital Techniques, Vol. 144, No. 1, PP. 43 -46, Jan 1997. 
[10] C.Y. Lee, J.S. Horng and I.C. Jou, "Low-Complexity Bit-Parallel Systolic multiplier over 
GF(2m) Using Dual Basis representation," Journal of Computer Science and Technology, Vol. 
[28] B. Sunar and C.K. Koc, "Mastrovito multiplier for all trinomials," IEEE Trans Computers, 
vol. 48, no. 5, pp. 522–527, May 1999. 
[29] T. Zhang and K.K. Parhi, "Systematic design of original and modified mastrovito multipliers 
for general irreducible polynomials," IEEE Trans Computers, vol. 50, no. 7, pp. 734–749, 
July 2001. 
[30] J. L. Imana, J. M. Sanchez, and F. Tirado, "Bit-parallel finite field multipliers for irreducible 
trinomials," IEEE Trans Computers, vol. 55, no. 5, pp. 520–533, May 2006. 
[31] A. Reyhani-Masoleh and M.A. Hasan, "Low complexity bit parallel architectures for 
polynomial basis multiplication over GF(2m)," IEEE Trans. Computers, vol. 53, no. 8, pp. 
945–959, Aug. 2004. 
[32] H. Fan and Y. Dai, "Fast bit-parallel GF(2m) multiplier for all trinomials," IEEE Transactions 
on Computers, vol. 54, no. 4, pp. 485–490, Apr. 2005. 
[33] H. Fan and M.A. Hasan, "Fast bit parallel-shifted polynomial basis multipliers in GF(2n)," 
IEEE Transactions on Circuits and Systems I:Regular Papers, vol. 53, no. 12, pp. 2606–2615, 
Dec. 2006. 
[34] H. Wu, "Low complexity bit-parallel multiplier for a class of finite fields," in Proc. 2006 
International Conference on Communications, Circuits and Systems, vol. 4, June 2006, pp. 
2565–2568. 
[35] S. Moon, J. Park, and Y. Lee, "Fast VLSI arithmetic algorithms for high-security elliptic 
curve cryptographic applications," IEEE Trans. Consumer Electronics, vol. 47, no. 3, pp. 
700–708, Aug. 2001. 
[36] W.C. Tsai and S.J. Wang, "Two systolic architectures for multiplication in GF(2m)," IEE 
Proceedings-Computers and Digital Techniques, vol.147, no. 6, pp. 375–382, Nov. 2000. 
[37] S. Kwon, C.H. Kim, and C.P. Hong, "A systolic multiplier with LSB first algorithm over 
GF(2m) which is as efficient as the one with MSB first algorithm," in Proceedings of the 2003 
International Symposium on Circuits and Systems ISCAS ’03, vol. 5, May 2003, pp. 
633–636. 
[48] C.H. Kim, S. Kwon, and C.P. Hong, "A fast digit-serial systolic multiplier for finite field 
GF(2m)," in Proc. 2005 Asia and South Pacific Design Automation Conference 
(ASP-DAC-2005), vol. 2, Jan. 2005, pp.1268–1271.  
[49] J.H. Guo and C.L. Wang, "Digit-serial systolic multiplier for finite fields GF(2m)," IEE 
Proceedings-Computers and Digital Techniques, vol. 145, no. 2, pp. 143–148, Mar. 1998.  
[50] L. Song and K.K. Parhi, "Low-energy digit-serial/parallel finite field multipliers," Journal of 
VLSI Digital Processing, vol. 19, pp. 149–166,1998.  
[51] W. Tang, H. Wu, and M. Ahmadi, "VLSI implementation of bit-parallel word-serial 
multiplier in GF(2233)," in The 3rd International IEEENEWCAS Conference, June 2005, pp. 
399–402.  
[52] IEEE Standard 1363-2000, "IEEE Standard Specifications for Public-Key Cryptography," 
Jan. 2000. 
[53] Nat'l Inst. of Standards and Technology, Digital Signature Standard, FIPS Publication 186-2, 
Jan. 2000. 
[54] K. H. Huang and J. A. Abraham, "Algorithm-based fault tolerance for matrix operations," 
IEEE Trans. Computers, Vol.33, No.6, pp.518-522, June 1984. 
[55] D.P. Agrawal and V.K. Agarwal, "On-line bus fault diagnosis in microprocessor systems," J. 
Digital Syst., vol. 4, pp. 337-391, Winter 1980. 
[56] C.C. Lu, "A Search of Minimal Key Functions for Normal Basis Multipliers," IEEE Trans. 
Computers, vol. 46, no. 5, pp. 588-592, May 1997. 
[57] C.Y. Lee, P.K. Meher and  C.W. Chiou, "Concurrent error detection in bit-serial normal 
basis multiplication of GF(2m) using multiple parity prediction scheme," Submitted to IEEE 
Trans. Computer. 
[58] S. Bayat-Sarmadi and M.A. Hasan, "On Concurrent Detection of Errors in Polynomial Basis 
Multiplication," IEEE Trans. VLSI, Vol. 15,  No. 4, pp. 413-426 , April 2007. 
[59] C.Y. Lee, "Concurrent Error Detection Digit-Serial Normal Basis Multiplication over 
計畫成果自評部份 
在本計畫中，我們研究內容與原計畫相符、達成預期的目標-提出乘法具偵測錯誤能力。依
據本計畫所提出的理論概念，目前已經接18篇期刊論文，研究內容含括乘法具偵測錯誤能
力、低複雜度乘法及展延式乘法等架構。這些研究成果將有助於發展及設計成VLSI晶片，
且很適合應用於橢圓曲線密碼系統。 
1. Chiou-Yng Lee, Pramod Kumar Meher and Jagdish Chandra Patra, "Concurrent error 
detection in bit-serial normal basis multipliers over GF(2m),"(accepted) IEEE Trans. VLSI 
(SCI)  
2. Chiou-Yng Lee,Che Wun Chiou, and Jim-Min Lin, "Concurrent Error Detection in 
Multiplexer-Based Multiplier for Normal Basis of GF(2m) Using Double Parity Prediction 
Scheme," (accepted) The Journal of Signal Processing Systems (SCI)  
3. Chiou-Yng Lee , "Scalable and Systolic Gaussian Normal Basis Multipliers over GF(2m) 
Using Hankel Matrix-Vector Representation,"(accepted) VLSI in IN-TECH, Sep. 2009.  
4. Che Wun Chiou, Chiou-Yng Lee, Jim-Min Lin,"A Dual-Field Multiplier in GF(P) and 
GF(2m),"(accepted) IET Information Security. (SCI)  
5. Jenn-Shyong Horng, I-Chang Jou and Chiou-Yng Lee,"Low-complexity 
multiplexer-based normal basis multiplier over GF(2m)," Journal of Zhejiang 
University-SCIENCE A, Vol.10, No.6, pp.834-842, June 2009(SCI)  
6. Che Wun Chiou, Chin-Cheng Chang, Chiou-Yng Lee, Jim-Min Lin, Ting-Wei 
Hou,"Concurrent Error Detection and Correction in Gaussian Normal Basis Multiplier 
over GF(2m)," IEEE Transactions on Computers, VOL. 58, NO. 6,pp.851-857, June 2009 
(SCI)  
7. Chiou-Yng Lee, "Low-Complexity Parallel Systolic Architectures for Computing 
Multiplication and Squaring over GF(2m)," Journal of Computers, Vol.19, No.4, pp.20-30, 
Jan. 2009.  
8. Che Wun Chiou, Chiou-Yng Lee, Jim-Min Lin, Ting-Wei Hou, Chin-Cheng Chang, 
"Concurrent Error Detection and Correction in Dual Basis Multiplier over GF(2m)," IET 
Circuits, Devices & Systems. Vol. 3, No. 1, pp. 22–40, Jan. 2009, (SCI)  
9. Guo-Ming Fang, Jim-Min Lin, Wen-Gung Cheng, and Chiou-Yng Lee, "Integrating 
Legacy Software Applications with Audio Stream Wrapper Technique,"JOURNAL OF 
CYBERNETICS AND SYSTEMS, Vol.1, No.2, pp.97-105, Dec. 2008.  
10. Chiou-Yng Lee, "Low-Complexity Linear Array Multipliers for Optimum Normal 
Bases," JOURNAL OF CYBERNETICS AND SYSTEMS, Vol.1, No.2, pp.71-76, Dec. 
2008.  
11. Chin-Chin Chen, Chiou-Yng Lee, and Erl-Huei Lu, "Scalable and Systolic Montgomery 
Multipliers Over GF(2m)," IEICE Transactions on 
Fundamentals,Vol.E91-A,No.7,pp.1763-1771, July 2008 (SCI)  
12. Chiou-Yng Lee, "Low-Complexity Parallel Systolic Montgomery Multipliers Over 
GF(2m) Using Toeplitz Matrix-Vector Representation," IEICE Transactions on 
Fundamentals ,Vol.E91-A,No.6,pp.1470-1477,June 2008 (SCI)  
13. Chiou-Yng Lee and Che Wun Chiou, "New bit-parallel systolic architectures for 
computing multiplication, multiplicative inversion and division in GF(2m) under the 
出席國際學術會議心得報告 
                                                             
計畫編號 NSC 96-2221-E-262 -008 -MY2 
計畫名稱 有限場算數運算理論 : 通用與展延的乘法演算法與其容錯電路設計 
出國人員姓名 
服務機關及職稱 
李秋瑩副教授 
龍華科技大學資訊網路工程系 
會議時間地點 98 年 4 月 28 日~ 98 年 4 月 29 日 
會議名稱 2009 IEEE Circuits and Systems International Conference on Testing and Diagnosis，ICTD09 
發表論文題目 Fault Tolerant Dual Basis Multiplier Over GF(2m) 
 
一、參加會議經過 
（一） 行程及工作記要 
日期 地點 行程說明 
98 年4 月27 日 台北→ 中國四川成都市 搭機啟程 
98 年4 月28 日 四川成都市電子科技大學 參與研討會 
98 年4 月29 日 四川成都市電子科技大學 參與研討會 
98 年4 月30 日 中國四川成都市→ 台北 搭機返程 
（二） 會議內容 
2009 年 IEEE 電路與系統測試與診斷國際會議(2009 IEEE Circuits and Systems 
International Conference on Testing and Diagnosis，ICTD09)在中國大陸四川成都
市電子科技大學召開。來自中國、美國、印度、塞爾維亞、馬來西亞、中國臺灣等多個
國家或地區近百名學者參加了此次盛會。大會主席由美國聖母大學劉瑞文教授、電子科
技大學副校長王厚軍教授共同擔任。  
  ICTD09 是由 IEEE 電路與系統(CASS)新發起的國際會議，大會主旨是為 IC/PCB/系統
設計、測試、診斷與可測性設計研究人員提供一個學術交流平臺。美國聖母大學劉瑞文
教授、我校副校長王厚軍、我校自動化工程學院院長田書林在開幕式上分別代表 IEEE、
大會主席和承辦單位致詞。IC 測試專家、IEEE Fellow、美國加州大學 K.-T. Tim Cheng
教授作“Test's Changing Role in the Late-Silicon Era＂特邀報告，電子科大王厚
軍教授、臺灣成功大學劉濱達教授、哈工大彭宇教授分別作了題為“Testability for 
為各國著名大學教授，亦是建立國際合作關係之重要場合，應持續派員參與，以提供
國內研擬參採與實施之參考；唯由於討論之類別與議題眾多，參加者應事前規劃對混
合資訊技術趨勢之瞭解與相關議題之準備，始能在與會過程中汲取經驗並參與討論。 
（二） 面對日新月異的科學發展，我國亦應對有關混合資訊技術領域進行研究與開發。同時，
應積極與其他國家大學建立合作關係，合作機制可涵蓋研討會、視訊會議、科學性建
議等。 
（三） 透過國際會議，可爭取國際上對我混合資訊技術領域的研究，並可藉由議題之討論，
提升多邊或雙邊合作契機，亦可提升台灣於區域合作中，扮演主導性之角色或重要議
題參與或推動者。 
(四) 此等盛大會議有助於學生們對於研究領域更了解其廣博與精深，此外在會議中有許多來
自不同地方的研究人員，更能引發學生們對於測試與診斷理論與技術的興趣。因此若
能盡量提供有意願參與國際研討會的學生經費，使學生藉與國際人員交流之際，增加
研究視野與看法，將有助於學生的國際觀與更完整的思考邏輯，進而帶動國內學術界
熱潮。 
 
Fault Tolerant Dual Basis Multiplier Over GF(2m) 
Chiou-Yng Lee 
dept. Computer Information and Network Engineering 
Lunghwa University of Science and Technology 
Taoyuan County 333, Taiwan 
PP010@mail.lhu.edu.tw 
 
Pramod Kumar Meher 
dept. School of Computer Engineering 
Nanyang Technological University 
Nanyang Avenue, Singapore
 
 
Abstract—To fight against fault based side-channel cryptanalysis, a 
bit-parallel systolic dual basis multiplier using a time redundancy 
scheme is presented. This scheme is based on the extended dual 
multiplication to achieve the concurrent error correction (CEC) in 
the results. Analytical results reveal that our proposed CEC 
multiplier demands 1.87% space overheads, while the existing 
multipliers using parity prediction and time/hardware redundancy 
schemes demand at least 45% space overheads. Moreover, the time 
overhead of the proposed scheme amounts to only two clock cycles. 
Keywords-Finite fields, cryptography, concurrent error 
correction, dual basis 
I.  INTRODUCTION  
    Arithmetic operations in finite (Galois) fields GF(2m) 
have received much attention because of their important and 
practical applications in areas of error correcting code and 
cryptography. Among these, multiplication is the most 
important, complex, and time consuming finite field arithmetic 
operations. Various efficient multipliers have been proposed in 
the literature [1,2,3]. For implementing high performance 
cryptosystems, a multiplier may require a million transistors, 
which increases the potential problem of computational faults. 
Therefore, an efficient multiplier with the concurrent error 
correction (CEC) capability is required to improve the reliable 
operation of cryptographic schemes. 
    Most of the fault-tolerant techniques [4,5] either use the 
time-redundancy or hardware-redundancy to tolerate both 
permanent and transient faults during the system operation. 
Duplication and comparison for single error detection and 
Triple Modular Redundancy (TMR) for error correction are 
two well known hardware redundancy techniques. But, these 
methods for detecting/correcting errors in the systems demand 
about 100% and 200% space overheads, respectively. Using 
time redundancy schemes, Patel and Fung [6] have utilized the 
REcomputing with the Shifted Operands (RESO) method to 
achieve concurrent error detection capabilities in multiply-and-
divide arrays. Finite field multipliers using this method are also 
proposed in [7,8]. Their architectures require only one 
arithmetic circuit for testing, but demand large hardware 
overheads for performing the basis conversion at the input and 
output of the system. 
    Since the field element in GF(2m) can be represented by a 
dual basis (DB) representation, various DB multiplier 
architectures are reported in the literature. Based on the basic 
concept of the DB multiplication, this paper investigates a new 
time redundancy scheme to correct errors in bit-parallel 
systolic multiplier over GF(2m). This method is based on the 
extended DB multiplication to achieve systolic array 
architectures with CEC. Analytical results indicate that the 
proposed architectures have low-space overheads compared to 
traditional CED multipliers [10,11]. The time overheads for the 
proposed CEC architecture is only two clock cycles. 
II. PRELIMINARIES 
The basic concepts of the DB multiplication and the time 
redundancy scheme are discussed in the following subsections. 
A. Dual basis multiplication over GF(2m) 
It is commonly known that the finite field GF(2m) can be 
viewed as a vector space of dimension m over GF(2), where 
the field is generated by the irreducible polynomial 
F(x)=f₀+f₁x+…+fm-1xm-1+xm of degree m over GF(2). 
Supposing α to be a root of an irreducible polynomial F(x) of 
degree m, any element A in the Galois field GF(2m) can be 
represented as ܣ ൌ ܽ₀ ൅ ܽ₁ߙ ൅ ܽ₂ߙ² ൅ ڮ ൅ ܽ௠ିଵߙ௠ିଵ , 
where the coordinates ܽ௜∈GF(2) for 0≤i≤m-1 and the set 
{1,α,α²,…,αm-1} is the polynomial basis (PB) of GF(2m). 
Definition 1. Let Tr(x) be denoted by the trace function of x, 
we have ܶݎሺݔሻ ൌ ∑ ݔଶ೔௠ିଵ௜ୀ଴ .  
Definition 2 [9]. Let {αi} and {βi} be two bases for GF(2m) 
and γ∈GF(2m). Then, the dual basis (DB) {βi} to the PB is 
defined as 
⎩⎨
⎧
≠
=
=
jiif
jiif
Tr j
i
0
1
)( βγα           (1) 
Let ܣҧ, ܤ, ܥ  be three elements in GF(2m), where ܣҧ ൌ
ሺ തܽ₀, തܽ₁, . . . , തܽ௠ିଵሻ  and ܥ ൌ ሺܿ₀, ܿ₁, . . . , ܿ௠ିଵሻ  are represented 
by the DB, and  ܤ ൌ ሺܾ₀, ܾ₁, . . . , ܾ௠ିଵሻ is represented by the 
PB, where ܥ is the multiplication of ܣ and ܤ. From Definition 
2, every component c୧ of ܥ is obtained as 
ܿ௜ ൌ ܶݎሺߛܣҧܤሻ ൌ ܶݎሺߛ ෍ ܾ௜ߙ௝
௠ିଵ
௝ୀ଴
ܣҧሻ ൌ ෍ ܾ௜ܶݎሺߙ௝
௠ିଵ
௝ୀ଴
ܣҧሻ     ሺ2ሻ 
Let us define that 
ܣሺ௜ሻ ൌ ሺܽ௜, ܽ௜ାଵ, ڮ , ܽ௠ିଵା௜ሻ                                       (3a) 
ܥԢ ൌ ሺܿԢ₋₁, ܿԢ₀, . . . , ܿԢ௠ିଵሻ  if ܣሺିଵሻ  is pre-computed. Then ܥҧԢ 
and ܥԢ  could be included by all components of ܥ  since 
ܿԢ௜ ൌ ܿҧԢ௜ିଵ ൌ ܿ௜ . Using the method of the extended DB 
multiplication, the next section we will derive the CEC DB 
multiplication architecture. 
IV. PROPOSED CEC DB MULTIPLICATION ARCHITECTURE 
 
    Applying the extended multiplication of the previous 
section, the three multiplications ܥҧ ൌ ߙܣܤ , ܥҧҧ ൌ ߙ²ܣܤ  and 
ܥ ൌ ܣܤ can be extended as 
Cധ ᇱ ൌ  ቀcധԢିଶ, cധԢିଵ , . . . , cധԢ୫ିଵቁ ൌ ෍ Aሺ୨ሻ ٖ BԢԢβ୨
୫ିଵ
୨ୀ଴
            ሺ13aሻ 
Cത ᇱ ൌ  ቀcതԢିଶ, cതԢିଵ , . . . , cതԢ୫ିଵቁ ൌ ෍ Aሺ୨ሻ ٖ BԢβ୨
୫ିଵ
୨ୀ଴
            ሺ13bሻ 
Cᇱ ൌ  ቀcԢିଶ, cԢିଵ , . . . , cԢ୫ିଵቁ ൌ ෍ Aሺ୨ሻ ٖ BԢβ୨
୫ିଵ
୨ୀ଴
            ሺ13cሻ 
Each multiplication of (13) requires ሺ݉ ൅ 2ሻ computational 
loops, and all components have the relation of ܿӖԢ௜ିଶ ൌ ܿҧԢ௜ିଵ ൌ
ܿԢ௜ ൌ ܿ௜ . Thus, these three multiplications  ܥӖᇱ, ܥҧᇱ and ܥᇱinclude 
all components of ܥ. We use three multiplications to realize the 
concurrent error correction in the original multiplication. Fig. 1 
shows the functional blocks of the proposed DB multiplier with 
CEC capability. This architecture consists of one multiplier, 
two α modules, one 4×1 MUX and one voter. Fig. 2 shows the 
combined circuit for implementing the multiplier and the voter. 
The multiplier is extended by ሺ݉ ൅ 2ሻ ൈ ݉  systolic array 
multiplier. The voter is composed of ሺ݉ ൅ 2ሻ W-cells. Each 
W-cell is composed of one 1×3 SW and one voting element, as 
shown in Fig. 3(a). The 4×1 MUX is used to control three 
multiplications in (13). Based on the configuration of Fig.1, at 
first it computes ܥᇱ  according to (13c); next it calculates ܥҧԢ 
according to (13b); lastly ܥӖᇱ is computed according to (13a). 
The data pairs ሺܨ, ܣሺିଶሻ, ܤሻ, ሺܨԢ, ܣሺିଶሻ, ܤԢሻ and ሺܨԢԢ, ܣሺିଶሻ, ܤԢԢሻ 
are fed to the array multiplier in a top-down manner, the 
multiplier produces three values ሺܿԢ₋₂, ܿԢ₋₁, . . . , ܿԢ௠ିଵሻ , ሺܿҧԢ₋₂, ܿҧԢ₋₁, . . . , ܿҧԢ௠ିଵሻ, and ሺܿӖԢ₋₂, ܿӖԢ₋₁, . . . , ܿӖԢ௠ିଵሻ, respectively. 
From ܿԢ௜ ൌ ܿҧԢ௜ିଵ ൌ ܿӖԢ௜ିଶ ൌ ܿ௜, if the output of the ith rows of 
U-cells (as seen in Fig.3(b)) is the value ܿӖԢ௜ିଶ, the (i-1) th and (i-
2)th rows of U-cells will collectively form the output of ܿҧԢ௜ିଵ 
and ܿԢ௜ . Therefore, by using the "triple modular redundancy" 
technique, three corresponding values for the ith, the (i-1)th and 
the (i-2)th rows of U-cells, respectively, are fed into a voting 
element of the ௜ܹ -cell. The voting element performs ܿ௜ ൌܿԢ௜ܿҧԢ௜ିଵ ൅ ܿԢ௜ܿӖԢ௜ିଶ ൅ ܿҧԢ௜ିଵܿӖԢ௜ିଶ to correct the component ܿ௜  of ܥ. Therefore, each voting element needs three AND gates and 
two XOR gates. As mentioned above, the proposed multiplier 
in Fig. 1 can perform the DB multiplication with CEC 
capability. 
     
 Fig. 1. The functional blocks for implementing CEC 
DB multiplier over GF(2m) 
     
 Fig.2. The proposed DB multiplier with CEC 
capability     
V. TIME AND SPACE COMPLEXITY 
    From Section 3, the proposed CEC multiplier in Fig. 1 
consists of one multiplier module, two α modules, one 4×1 
MUX and ሺ݉ ൅ 2ሻ  W-cells. The multiplier is identical of 
ሺ݉ ൅ 2ሻ ൈ ݉ U-cells. Each W-cell includes one 1×3 SW and 
one voting element. Each voting element needs three XOR 
gates to realize the correction function. The α module requires 
the space complexity of 2ሺݓ െ 2ሻ XOR gates. The proposed 
CEC multiplier requires only two extra clock cycles compared 
to the original multiplier in Fig. 1. 
(m+2)×m systolic  
array multiplier 
A(-2) 
A
4  to 1 MUX 
B
voter 
'C
ctr 
α 
)2(−A ''B  
'C  
C
α 
'B  B
'C
0 
 
U-2,0 U-2,1 U-2,j U-2,m-1 
U-1,0 U-1,1 U-1,j U-1,m-1 
U0,0 U0,1 U0,j U0,m-1 
U1,0 U1,1 U1,j U1,m-1 
0
0
0
0
0
0
0
0
W0 
W1 
0c
1c
1−mc
ic
W-2
W-1 
( 2)
0 0 0
( 2)
0 0 0
( 2)
0 0 0
'' ''
' '
    
f a b
f a b
f a b
−
−
−
( 2)
1 1 1
( 2)
1 1 1
( 2)
1 1 1
'' ''
' '
    
f a b
f a b
f a b
−
−
−
( 2)
( 2)
( 2)
'' ''
' '
 
i i i
i i i
i i i
f a b
f a b
f a b
−
−
−
( 2)
1 1 1
( 2)
1 1 1
( 2)
1 1 1
'' ''
' '
  
m m m
m m m
m m m
f a b
f a b
f a b
−
− − −
−
− − −
−
− − −
0
Ui,0 Ui,1 Ui,j Ui,m-1 
Um-1,0 Um-1,1 Um-1,j Um-1,m-1 
0
0
0
0
0 0
Wi 
Wm-1
FAULT TOLERANT DUAL BASIS MULTIPLIER 
OVER GF(2M)
Dr. Chiou-Yng Lee
LungHwa university,  Taiwan
DUAL BASIS REPRESENTATION
´ Let Tr(x) be denoted by the trace function of x, 
we have 
1
L t { i} d {β } b  t  b  f  GF(2m) d 
2
0
( )
i
m
i
Tr x x
−
=
= ∑
´ e α an i e wo ases or anγ∈GF(2m). Then, the dual basis (DB) {βi} to the 
PB is defined as
⎩⎨
⎧
≠
==
jiif
jiif
Tr j
i
0
1
)( βγα
CLASSICAL FAULT TOLERANT METHODS
´ Time redundancy scheme
« It is a simple and regular implementation to 
detect/correct combinational logic circuits
« The architecture is involving the basis conversion circuit
´ Parity prediction scheme
« It only provide the detected function in the system.
« The probability of error detection can obtain 100%
´ Linear code
« It can provide the detect/correct function in the 
architecture
« The capability of the detect/correct function is limited.
EXTENDED DUAL BASIS MULTIPLICATION
´ From the basic concept of the dual basis 
multiplication, the component of the product C 
is computed by
´ Thus, we have
PROPOSED CEC DB MULTIPLICATION 
ARCHITECTURE
´ Applying the extended 
multiplication, the three 
multiplications can be extended 
as
COMPARISON OF VARIOUS CED/CEC 
MULTIPLIERS OVER GF(2M)
