optimally solve them in polynomial time. Some may try 
to develop approximation algorithms or heuristic 
algorithms, but some may just give up finding the 
optimal solution of the problem. Every NP-complete 
problem can be solved by exhaustive search. It is 
upset that when the size of input grows, the running 
time becomes forbiddingly large. For some problems, 
it is possible to design algorithms that are 
significantly faster than exhaustive search, though 
still not polynomial time. We call the algorithms 
designed for solving NP-hard or NP-complete problems 
exactly exact algorithms. During recent years, there 
are many clever strategies and exact algorithms for 
solving NP-hard problems discussed and published in 
very top international journals. 
The strategy {\em branch and reduce} is one of the 
algorithmic techniques to design exact algorithms. 
The {\em measure-and-conquer} approach is used to 
analyze the worst case running time of branch-and-
reduce algorithms. The idea is that the more we 
understand the behavior of branch-and-reduced 
algorithms, the less redundancy may occur when we 
analyze the complexity. By using accurate analysis, 
even some simple algorithms can be shown its powerful 
efficiency. 
In this project, we take the {\sc Maximum Bounded-
Degree-1 Set} ({\sc Max 1-bds}) problem and the {\sc 
Maximum Induced Matching} ({\sc MIM}) problem as 
examples and achieve the following results: 
(i) We design an exact algorithm for solving the {\sc 
Maximum Bounded-Degree-1 Set} problem. 
(ii) We design an exact algorithm for solving the 
{\sc Maximum Induced Matching} problem. 
(iii) We implement a program to analyze branch-and-
reduce algorithms by using the measure-and-conquer 
approach. 
(iv)We analyze the exact algorithm for the {\sc 
Maximum Bounded-Degree-1 Set} problem by the measure-
and-conquer approach and show that the running time 
of the exact algorithm is $O^{\ast}(1.4834^n)$. 
(v)We analyze the exact algorithm for the {\sc 
Maximum Induced Matching} problem by the measure-and-
行政院國家科學委員會補助專題研究計畫
 成 果 報 告
期中進度報告
衡量征服 - 分析分支化約演算法時間複雜度的新方法
Measure and Conquer–A New Approach to Analyzing Time Conplexities
of Branch-and-Reduce Algorithms
計畫類別 : 個別型計畫  整合型計畫
計畫編號 : NSC 99—2221—E—241—015–MY3
執行期間 : 9 9年 8月 1日 至 102 年 7月 3 1日
計畫主持人 :張 貿 翔
共同主持人 :
計畫參與人員 : 陳立軒、 劉奕志、 雷興怡、 蕭凱倫、 陳維祥、 林孟姚、 陳紀良、 廖哲昱、 劉彥緯
成果報告類型 (依經費核定清單規定繳交) :  精簡報告  完整報告
本成果報告包括以下應繳交之附件 :
赴國外出差或研習心得報告一份
赴大陸地區出差或研習心得報告一份
出席國際學術會議心得報告及發表之論文各一份
國際合作研究計畫國外研究報告書一份
處理方式 : 除產學合作研究計畫、 提升產業技術及人才培育研究計畫、 列管計畫
及下列情形者外, 得立即公開查詢
涉及專利或其他智慧財產權, 一年 二年後可公開查詢
執行單位 :弘 光 科 技大 學 資 訊工 程 系
中 華 民 國 102 年 1 0 月 3 1 日
Abstract
For a long time, people avoid solving NP-hard problems exactly because it seems hopeless
to optimally solve them in polynomial time. Some may try to develop approximation
algorithms or heuristic algorithms, but some may just give up finding the optimal solution
of the problem. Every NP-complete problem can be solved by exhaustive search. It is upset
that when the size of input grows, the running time becomes forbiddingly large. For some
problems, it is possible to design algorithms that are significantly faster than exhaustive
search, though still not polynomial time. We call the algorithms designed for solving NP-
hard or NP-complete problems exactly exact algorithms. During recent years, there are
many clever strategies and exact algorithms for solving NP-hard problems discussed and
published in very top international journals.
The strategy branch and reduce is one of the algorithmic techniques to design exact
algorithms. The measure-and-conquer approach is used to analyze the worst case running
time of branch-and-reduce algorithms. The idea is that the more we understand the
behavior of branch-and-reduced algorithms, the less redundancy may occur when we
analyze the complexity. By using accurate analysis, even some simple algorithms can be
shown its powerful efficiency.
In this project, we take the MAXIMUM BOUNDED-DEGREE-1 SET (MAX 1-BDS) prob-
lem and the MAXIMUM INDUCED MATCHING (MIM) problem as examples and achieve the
following results: (i) We design an exact algorithm for solving the MAXIMUM BOUNDED-
DEGREE-1 SET problem. (ii) We design an exact algorithm for solving the MAXIMUM
INDUCED MATCHING problem. (iii) We implement a program to analyze branch-and-
reduce algorithms by using the measure-and-conquer approach. (iv)We analyze the ex-
act algorithm for the MAXIMUM BOUNDED-DEGREE-1 SET problem by the measure-and-
conquer approach and show that the running time of the exact algorithm is O∗(1.4834n).
(v)We analyze the exact algorithm for the MAXIMUM INDUCED MATCHING problem by the
measure-and-conquer approach and show that the running time of the exact algorithm is
O∗(1.4658n). Parts of our achievements were presented in the proceedings of the interna-
ii
Contents
1 前言 1
2 研究目的 2
2.1 The maximum bounded-degree-1 set problem . . . . . . . . . . . . . . . . 2
2.2 The maximum induced matching problem . . . . . . . . . . . . . . . . . . 3
3 文獻探討 4
3.1 The maximum bounded-degree-1 set problem . . . . . . . . . . . . . . . . 4
3.2 The maximum induced matching problem . . . . . . . . . . . . . . . . . . 5
4 研究方法 6
4.1 The maximum bounded-degree-1 set problem . . . . . . . . . . . . . . . . 6
4.1.1 An exact algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
4.1.2 Measure and Conquer Analysis . . . . . . . . . . . . . . . . . . . . 18
4.2 The maximum induced matching problem . . . . . . . . . . . . . . . . . . 30
4.2.1 An exact algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2.2 A more efficient exact algorithm . . . . . . . . . . . . . . . . . . . 37
4.2.3 A more efficient and simpler exact algorithm . . . . . . . . . . . . 38
5 結果與討論 46
6 計畫成果自評 47
7 參考文獻 47
8 Appendix 53
8.1 Maw-Shang Chang, Ling-Ju Hung, Ping-Chen Su, Exact and fixed-parameter
algorithms for problems related to 2-plex, Proceedings of ICSEC 2011, pp. 203–
208. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
iv
1 前言
The technique Branch and Reduce is one of the major techniques used to design exact
algorithms. It is a recursive procedure consisting of reduction rules and branching rules.
The reduction rules are used to reduce the problem size, and the branching rules are used
to branch the original problem into subproblems having smaller input sizes. Branch-and-
reduce algorithms always find optimal solutions. Search trees are often used to illustrate
the execution of a branching algorithm. Let T(n) be the maximum number of leaves in any
search tree where n is the input size. We analyze each branching rule and use the worst-
case time complexity over all branching rules as an upper bound of the running time. Let
b be any branching rule. When rule b is applied, the current instance is branched into
r > 2 instances of size at most n− t1,n− t2, . . . ,n− tr. Note that n > ti and ti ∈ R
+ for
i = 1, 2, . . . , r. We call b = (t1, t2, . . . , tr) the branching vector of branching rule b. This
can be formulated in a linear recurrence
T(n) 6 T(n− t1) + T(n − t2) + · · · + T(n − tr).
For functions f and gwe write f(n) = O∗(g(n)) if f(n) = O(g(n)poly(n)), where poly(n)
is a polynomial. Then T(n) = O∗(τn) where τ is the unique positive real root of
xn − xn−t1 − xn−t2 − · · · − xn−tr = 0.
We call τ the branching number1 of branching rule b [22]. If a branch-and-reduce algo-
rithm has several branching rules, then the running time of it is O∗(αn) where α is the
maximum branching number among all branching rules.
Recently measure and conquer is used to obtain tighter bounds on running time of
many branch-and-reduce algorithms [15, 4, 19, 16, 20, 21, 7, 22]. Traditionally the
size of a graph problem is measured by the number n of vertices in the input graph. In
measure-and-conquer analysis, each vertex is assigned a weight in the range [0, 1] and the
1To compute the branching number of a branching vector, please visit the following webpage:
http://210.240.226.131/BranchingNumber.html
1
Input: A graph G = (V ,E) and a positive integer s.
Question: Is there a vertex set S ⊆ V of size at least s such that S is bounded-degree-d?
MAXIMUM BOUNDED-DEGREE-d SUBSET (MAX d-BDS)
Input: A graph G = (V ,E).
Output: A vertex set S ⊆ V of maximum cardinality such that S is bounded-degree-d set.
BOUNDED-DEGREE-d VERTEX DELETION (d-BDD)
Input: An undirected graph G = (V ,E) and a positive integer p.
Question: Is there a vertex set X ⊆ V of size at most p making V \X a bounded degree-d
set?
MINIMUM BOUNDED-DEGREE-d VERTEX DELETION (MIN d-BDD)
Input: An undirected graph G = (V ,E).
Output: A vertex set X ⊆ V of minimum cardinality such that V \X is a bounded degree-d
set.
A k-plex of a graph G = (V ,E) is a vertex set S ⊆ V such that every vertex in G[S]
has degree at least |S| − k. The model k-plex is defined as a degree based relaxed model
for finding cohesive subgroups in social networks [41]. Notice that a 1-plex is a clique.
The maximum k-plex problem in a given graph G is to find a k-plex in G with maximum
cardinality. By definition, a k-plex in G is a bounded-degree-(k−1) set in the complement
graph of G, say G¯. Thus a graph G with n vertices has a k-plex of size s iff G¯ has a
bounded-degree-(k− 1) set with s vertices. Also G¯ has a bounded-degree-(k− 1) deletion
set of size (n − s). Suppose that the minimum bounded-degree-(k− 1) deletion set of G¯
is p. It is easy to see that the maximum k-plex in G is of size (n − p).
2.2 The maximum induced matching problem
An induced matching M ⊆ E in a graph G = (V ,E) is a matching such that no two
edges inM are joined by any third edge of the graph. The MAXIMUM INDUCED MATCHING
problem is to find an induced matching of maximum cardinality. We give the formal
3
gave an algorithm to enumerate all maximal k-plexes [44].
3.2 The maximum induced matching problem
The MAXIMUM INDUCED MATCHING is NP-complete in general graphs [42] and even
when restricted to bipartite graphs [32], planar graphs [28], r-regular graphs, r > 5,
line graphs and Hamiltonian graphs [29]. It is polynomial-time solvable for trees [23,
45], chordal graphs [9], weakly chordal graphs [10], HHD-free graphs [31], and 2P3-
free graphs [33]. The MAXIMUM INDUCED MATCHING problem is W[1]-hard in general
graphs [36] and is FPT in planar graphs [35, 17, 27]. Binkele-Raible et al. [8] showed
that the problem to compute the upper irredundance number can be reduced to solve the
MAXIMUM INDUCED MATCHING problem in bipartite graphs. They gave a fixed-parameter
algorithm running in time O∗(1.6957k) for solving the MAXIMUM INDUCED MATCHING
problem in bipartite graphs where k denotes the number of vertices to be deleted for
obtaining an induced matching [8]. The MAXIMUM INDUCED MATCHING problem is APX-
hard even on 4r-regular graphs for r > 1 [26, 14]. Orlovich et al. [39] showed that if
P 6= NP, for any ǫ > 0, the MAXIMUM INDUCED MATCHING problem cannot be approxi-
mated to within a factor of n1/2−ǫ in polynomial time. Cygan et al. [13] gave a branch-
and-reduce algorithm running in time O∗(1.40202n) time and polynomial space for the
MAXIMUM INDUCED MATCHING problem in bipartite graphs. By using memorization on
the exact algorithm, they showed that the MAXIMUM INDUCED MATCHING problem in bi-
partite graphs can be solved in O∗(1.3592n) time and in exponential space [13]. Gupta
et al. [25] gave an o(2n) time algorithm for solving the MAXIMUM r-REGULAR INDUCED
SUBGRAPH problem. When r = 1 (Maximum Induced Matching Problem), the running
time of the algorithm is O∗(1.6957n).
We close this section with some notation. Given a graph G = (V ,E), we use n to
denote the number of vertices in G. Two vertices u and v are called true twins in G if
N[u] = N[v]. Two vertices u and v are called false twins in G if N(u) = N(v). A vertex
v is called an isolated vertex if |N(v)| = 0 and is called a degree-one vertex if |N(v)| = 1.
5
Lemma 1 (Disconnected Rule). If G is disconnected and C is a component of G, then
β1(G) = β1(G[C]) + β1(G \ C).
Proof. Since G is disconnected and C is a component of G and β1(G) is the optimum
solution of the MAX 1-BDS problem in G, we see that β1(G) > β1(G[C]) + β1(G \ C).
Since β1(G[C]) and β(G \ C) are both optimum solutions of the MAX 1-BDS problem on
graphs G[C] and G \ C respectively, we have β1(G[C]) + β(G \ C) > β1(G). This shows
that β1(G) = β1(G[C]) + β1(G \ C). ✷
Lemma 2 (Isolated-Vertex Rule). Let v be an isolated vertex of G. Then there is a solution
of the MAX 1-BDS problem that v is selected from G. That is β1(G) = 1 + β1(G \ {v}).
Proof. Suppose that there exists a solution S of the MAX 1-BDS problem not containing v.
Since v is an isolated vertex, S ∪ {v} is also a solution, a contradiction to the assumption
that S is a bounded-degree-1 set of maximum size. Thus v must be a member of any
solution of the MAX 1-BDS problem. ✷
Lemma 3 (Isolated-Edge Rule). Let (u, v) be an isolated edge of G. Then there is a solution
of the MAX 1-BDS problem that u and v are selected from G. That is β1(G) = 2 + β1(G \
{u, v}).
Proof. Suppose that there exists a solution S of the MAX 1-BDS problem not containing u
and v. Since (u, v) is an isolated edge, S ∪ {u, v} is also a solution, a contradiction to the
assumption that S is a bounded-degree-1 set of maximum size. Suppose that one of u and
v is not contained in S, say u. It is easy to see that S ∪ {u} is also a bounded-degree-1 set
since (u, v) is an isolated edge. Thus u and v must be selected in any solution of the MAX
1-BDS problem. ✷
Lemma 4 (Degree-One Edge Rule). Let G = (V ,E) be a graph and (u, v) be a degree-one
edge of G satisfying one of the following conditions.
1. u is of degree two and v is of degree one;
2. Both u and v are of degree two, and w is the common neighbor of u and v, deg(w) = 3.
7
By computing all cases, we obtain that
β1(Ch) =


2ℓ if h = 3ℓ;
2ℓ if h = 3ℓ + 1;
2ℓ + 1 if h = 3ℓ + 2.
This shows that for graphs of maximum degree at most two, the MAX 1-BDS problem can
be solved in polynomial time. ✷
Lemma 6 (Degree-One Vertex Rule 1). Let G = (V ,E) be a graph and v be a vertex of G
having at least two degree-one neighbors. Then β1(G) = |X| + β1(G \ (X ∪ {v})) where X is
the set of all degree-one neighbors of v.
Proof. Let S be an optimal solution selecting v. At most one vertex inN(v) can be selected
in S. Let X ⊆ N(v) be the collection of vertices of degree one. Note that |X| > 2. Suppose
that S does not contain any vertex in X. We see that (S∪X)\ {v} is also a solution of larger
size, a contradiction to the assumption that S is an optimal solution. Thus S contains a
vertex in X. In this case, we get another solution (S∪X)\ {v}. Thus there exists an optimal
solution discarding v and selecting all vertices in X. This completes the proof. ✷
Lemma 7 (True Twin Rule 1). Let G = (V ,E) be a graph having a pair of true twins v and
z. If both of v and z are of degree three, then
β1(G) = 2 + β1(G \N[v]).
Proof. There are three cases, both v and z are discarded; only one of v and z is selected; or
both v and z are selected. LetN(v)\{z} = {x,y}. Suppose that S is an optimal solution that
selects v and discards z. It is easy to see that one of x and y must be selected, otherwise
z ∈ S. Assume that x ∈ S and y 6∈ S. We obtain that S ∪ {z} \ {x} is an optimal solution.
Thus either both of v and z are selected or both of v and z are discarded. Suppose that
both of v and z are discarded. If S is an optimal solution that both x and y are discarded,
then S ∪ {v, z} is a solution of larger size, a contradiction. Thus at least one of x and y is
9
Lemma 10 (Degree-One Vertex Rule 2). Let G = (V ,E) be a graph and v be a vertex of G
having a degree-one neighbor z. Then
β1(G) = max


1 + β1(G \ {v, z}),
2 + β1(G \N[v]).
Proof. Let S be an optimal solution of the MAX 1-BDS problem in G. There are two cases
that either v is discarded or v is selected. If v is discarded, v 6∈ S, we see zmust be selected
otherwise S is not maximal. Thus β1(G) = 1 + β1(G \ {v, z}). If v is selected in S and z
is discarded, a vertex x ∈ N(v), x 6= z, must be selected in S otherwise S is not maximal.
We see that S ∪ {z} \ {x} is also an optimal solution. Thus β1(G) = 2 + β1(G \N[v]). This
completes the proof. ✷
Lemma 11 (Domination Rule 1). Let v be a vertex of G and u be a neighbor of v with
N[u] ⊂ N[v]. Then there is a solution of the MAX 1-BDS problem that either v is discarded
or both v and u are selected from G. That is
β1(G) = max


β1(G \ v),
2 + β1(G \N[v]).
Proof. Suppose that v is selected and all neighbors of v are discarded in some solution.
Assume that V \ X is a solution of MAX 1-BDS problem where X is the set of vertices
discarded from G. Let X′ = X \ {u}. We can verify that G[V \ X′] is bounded-degree-1.
Hence V \ X′ is also a solution. Suppose v is selected and all neighbors of v other than w,
u 6= w, are discarded in some solution. Let Y be the set of vertices discarded from G in
this solution and Y′ = (Y\{w})∪{u}. We also can verify that G[V \Y′] is bounded-degree-1.
Thus either v is discarded or both v and u are selected. This completes the proof. ✷
Lemma 12 (Degree-Two Vertex Rule 1). There is a degree-two vertex z in G satisfying
the condition that the degree of one of its two neighbors is two and the degree of the other
neighbor is at least three. Let x ∈ N(z) that deg(x) = 2 and v ∈ N(z) that deg(v) > 3.
11
y ∈ X, then we obtain a solution by deleting vertices in X \ {z}. Hence there is a solution
that either v is discarded or v and one of its neighbors are selected from G. Suppose that
there exists an optimal solution S that v,y ∈ S. Then for all u ∈ N(x)∩N2(v), u 6∈ S since
N(x)∩N2(v) ⊆ N(y)∩N2(v). We obtain that S∪ {x} \ {y} is also an optimal solution. This
completes the proof. ✷
Lemma 14 (Difference Rule 2). Let v be a vertex of G and z be a neighbor of v such that
|N[z] \N[v]| = 1. Then there is a solution of MAX 1-BDS problem that either v is discarded
or v and one of its neighbors are selected from G. That is
β1(G) = max


β1(G \ v),
maxU∈U(2 + β1(G \N[U])
where U = {{u, v} | u ∈ N(v)}.
Proof. Suppose v is selected and all neighbors of v are discarded in some solution and
let V \ X be the solution and X be the set of vertices discarded from G, G \ X is bounded-
degree-1. By definition, for all u ∈ N(v) u ∈ X. Let x be the only vertex in N[z] \ N[v].
If x /∈ X, then we obtain a solution by deleting the set of vertices in (X \ {z}) ∪ {x} from
G. If x ∈ X, then we obtain a solution by deleting vertices in X \ {z}. Hence there is a
solution that either v is discarded or v and one of its neighbors are selected from G. This
completes the proof. ✷
Lemma 15 (Domination Rule 2). Let v be a vertex of G and u and z are two neighbors of
v satisfying (N(u) \N[v]) ⊆ (N(z) \N[v]). Then there is a solution of MAX 1-BDS problem
that either v is discarded or v and one of vertices in N(v) \ {z} are selected from G. That is
β1(G) =


β1(G \ v),
1 + β1(G \N[v]),
maxU∈U(2 + β1(G \N[U])
where U = {{p, v} | p ∈ N(v) \ {z}}.
13
3. Isolated-Edge Rule. There is an isolated edge and let X be the set of all isolated
edges. Then β1(G) = 2 · |X|+ β1(G \ V(X)).
4. Degree-One Edge Rule. There is an edge (u, v) of degree one and let X = N[{u, v}].
Then β1(G) = 2+ β1(G \ X).
5. Degree-One Vertex Rule 1. There is a vertex v having at least two degree-one
neighbors and let X be the set of all degree-one neighbors of v. Then β1(G) =
|X| + β1(G \ (X ∪ {v})).
6. True-Twin Rule 1. There are two vertices v and z such that N[z] = N[v], i.e., v and
z are true twins and dG(v) = dG(z) = 3. The algorithm selects {v, z} and discards
N(v) \ {z}. Hence β1(G) = 2 + β1(G \N[v]).
7. True-Twin Rule 2. There are two vertices v and z such that N[z] = N[v], i.e., v and
z are true twins as Fig. 1(a). Since Degree-One Edge Rule and True-Twin Rule 1 are
not applicable, the degrees of v and z are at least four. The algorithm either discards
{v, z} or selects {v, z} and discards N[v] \ {v, z}. Hence β1(G) = max{β1(G \ {v, z}), 2+
β1(G \ N[v])}. The worst branching vector is (2, 5) and its branching number is
1.2366.
8. False-Twin Rule. There exist two vertices u and v that are false twins in G as shown
in Fig. 1(b). The algorithm either discards both u and v or selects both u and v. That
is β1(G) = max{β1(G \ {u, v}), 2 + β1(G \ (N[v] ∪ {u}))}. Since dG(u) = dG(v) > 2,
the worst branching vector is (2, 4) and its branching number is 1.2721.
9. Degree-One Vertex Rule 2. There is a vertex v having a degree-one neighbor z
as Fig. 1(c). Since Degree-One Vertex Rule 1 and Degree-One Edge Rule are not
applicable, the degree of v is at least three and the neighbors of v other than z are of
degree at least two. Otherwise (v, z) is an edge of degree at most one. In this case
the algorithm either discards v and selects z or selects {v, z} and discards N[v]\ {v, z},
i.e., β1(G) = max{1+ β1(G \ {v, z}), 2+ β1(G \N[v])}. The worst branching vector is
(2, 4) and its branching number is 1.2721.
10. Domination Rule 1. Let v be a vertex of G and u be a neighbor of v satisfying that
15
rithm is an induced subgraph of the input graph of the original problem. Hence any
branching rule applied to d-regular graphs, for some fixed d, can only increase the
number of leaves by a multiplicative constant. Hence we may neglect the branching
rules needed for d-regular graphs in the time analysis. Therefore we neglect the
case when G is 3-regular. If G is not 3-regular and the maximum degree is three,
then one of the above rules applies. In the following rules, we may assume that the
maximum degree of the input graph is at least four.
14. Difference Rule 1. There is a maximum-degree vertex v of G and there exist y, z ∈
N(v) satisfying that |N(z) \N(v)| = 1 and N(z)∩N2(v) ⊆ N(y)∩N2(v) as Fig. 1(g).
The algorithm either discards v or selects v and one of vertices in N(v) \ {y}. Hence
β1(G) = max{β1(G\{v}), 2+maxU∈U(β1(G\N[U])}where U = {{v,p} | p ∈ N(v)\{y}}.
The worst case time complexity happens when the degree of v is four. The branching
vector is (1, 6, 6, 6) and its branching number is 1.4570.
15. Difference Rule 2. There is a maximum-degree vertex v of G, a neighbor z of
v, and |N[z] \ N[v]| = 1 as Fig. 1(h). Since Domination Rule is not applicable,
|N[u] \ N[v]| > 1 for any u ∈ N(v). In this case the algorithm either discards v
or selects v and one of its neighbor. Let U = {{v,u} | u ∈ N(v)}. Then β1(G) =
max{β1(G\{v}),maxU∈U(2+β1(G\N[U])}. The worst case time complexity happens
when the degree of v is four. The branching vector is (1, 6, 6, 6, 6) and its branching
number is 1.5099.
16. Domination Rule 2. There is a maximum-degree vertex v of G and u and z are
two neighbors of v satisfying (N(u) \ N[v]) ⊆ (N(z) \ N[v]) as Fig. 1(i). Then the
algorithm either discards v, or selects v and discards all its neighbors, or selects v
and one of vertices in N(v) \ {z}. Let U = {{v,p} | p ∈ N(v) \ {z}}. Then β1(G) =
max{β1(G \ v), 1 + β1(G \ N[v]),maxU∈U(2 + β1(G \ N[U])}. The worst case time
complexity happens when the degree of v is four. The branching vector is (1, 5, 7, 7, 7)
and its branching number is 1.4852.
17. Maximum-Degree Rule. Let v be a vertex of maximum degree of G as Fig. 1(j).
17
All reduction rules are done in polynomial time. Hence we can focus on branching
rules in the analysis. We will analyze all branching rules one by one. A branching rule may
incur several recurrence relations. In Table 2, we list all recurrence relations associated
with each branching rules.
Now we are ready to analyze branching rules. Consider True-Twin Rule 2 first.
True-Twin Rule 2. The algorithm recursively solves two MAX 1-BDS problems on graphs
G1 = G \ {v, z} and G2 = G \ N[v], respectively, in this case. The recurrence relation for
this rule is T(w) = T(wG1) + T(wG2) = T(w − t1) + T(w − t2) where t1 = w − wG1 and
t2 = w−wG2 and the branching vector is (t1, t2). For vertex u, use ∆1(u) for the weight of
u in G minus the weight of u in G1 and ∆2(u) for the weight of u in G minus the weight
of u in G2. By definition,
t1 = wdG(v) +wdG(z) +
∑
u∈N(v)\{z}
∆1(u);
t2 =
∑
u∈N[v]
wdG(u) +
∑
u∈N2(v)
∆2(u).
Since Degree-1-Edge Rule and True-Twin Rule 1 are not applicable, dG(v) = dG(z) = 4
and |N[v] \ {z}| > 2.
t1 >
∑
x∈{v,z}
wdG(x) +
∑
u∈N(v)\{z}
(wdG(u) −wdG(u)−2) > 2w4;
t2 >
∑
u∈N[v]
wdG(u) +
∑
u∈N2(v)
∆wdG(u) > 3w2 + 2w4.
False-Twin Rule. Suppose that the degree of v is d, N(v) = {u1,u2, . . . ,ud}, and u and
v are false twins, i.e., u ∈ N2(v) and N(u) = {u1,u2, . . . ,ud}. Define G1 = G \ U1 and
G2 = G \ U2 where U1 = {v,u} and U2 = N[{v,u}]. The algorithm recursively solves two
MAX 1-BDS problems on graphs G1 and G2 respectively. Hence
T(w) = T(wG1) + T(wG2)
and
T(w) = T(w− (w−wG1)) + T(w− (w −wG2)).
19
and
T(w) = T(w− (w−wG1)) + T(w− (w −wG2)).
Define ti = w − wGi . Then the branching vector is (t1, t2) in this case. Use ∆i(q) for
the weight of vertex q in G minus the weight of q in Gi. Then we have
ti =
∑
p∈Ui
wdG(p) +
∑
q∈N(Ui)
∆i(q).
Since True-Twin Rule is not applicable, v has a private neighbor with respect to u. Note
that 3 6 d(v) 6 4.
t1 > w3 + 3 min
26i64
∆wi,
t2 > 3w2 +w3 + min
26i64
∆wi.
Degree-Two Vertex Rule 1. Suppose that d(x) = 2, the degree of v is d, andN(v) = {u1 =
z,u2, . . . ,ud}. For 1 6 i 6 d+ 1, define Gi = G \ Ui where U1 = N[{x, z}], U2 = N[{v, z}],
and for 2 < i 6 d + 1, Ui = N[{x,y, v,ui−1}]. The algorithm recursively solves d + 1 MAX
1-BDS problems on graphs G1,G2, . . . ,Gd+1, respectively. Hence
T(w) =
d+1∑
i=1
T(wGi)
and
T(w) =
d+1∑
i=1
T(w− (w−wGi)).
Define ti = w−wGi . Then the branching vector is (t1, t2, . . . , td+1) in this case. Use ∆i(u)
for the weight of vertex u in G minus the weight of u in Gi. Then we have
ti =
∑
p∈Ui
wdG(p) +
∑
q∈N(Ui)
∆i(q).
Since Domination Rule and False-Twin Rule are not applicable, every uj, 1 6 j 6 d,
has a private neighbor with respect to v. Note that 3 6 dG(v) 6 4. Hence
t1 > 3w2 +w3,
t2 > 4w2 +w3,
21
For dG(v) = 4,
t1 > w2 +w3 +w4 + 3 min
26i64
∆wi,
t2 > 3w2 +w3 +w4 + min
26i64
∆wi,
t3 > 4w2 +w3 +w4 + min
26i64
∆wi,
t4 = t5 = t6 > 4w2 +w3 +w4 + min
36i64
∆wi.
Difference Rule 1. Suppose the degree of v is d and N(v) = {u1,u2, . . . ,ud = y}. For
1 6 i 6 d, define Gi = G \ Ui where U1 = {v} and for i > 1, Ui = N[{v,ui−1}]. The
algorithm recursively solves dMAX 1-BDS problems on graphsG1,G2, . . . ,Gd, respectively.
Hence
T(w) =
d∑
i=1
T(wGi)
and
T(w) =
d∑
i=1
T(w − (w−wGi)).
Define ti = w − wGi . Then the branching vector is (t1, t2, . . . , td) in this case. Use
∆i(q) for the weight of vertex q in G minus the weight of q in Gi. Then we have
ti =
∑
p∈Ui
wdG(p) +
∑
q∈N(Ui)
∆i(q).
Since Domination Rule 1 is not applicable, every uj, 1 6 j 6 d, has a private neighbor with
respect to v. Since False-Twin Rule and Domination Rule 1 are not applicable, |N2(v)| > 1.
Note that d(v) = 4. Let ∆wmin = min{∆w3,∆w4}.
t1 > w4 + 4∆wmin,
and for 2 6 i 6 4,
ti > 5w3 +w4 + ∆wmin.
23
T(w) =
d+1∑
i=1
T(wGi)
and
T(w) =
d+1∑
i=1
T(w− (w−wGi)).
Define ti = w − wGi . Then the branching vector is (t1, t2, . . . , td+1) in this case. Use
∆i(q) for the weight of vertex q in G minus the weight of q in Gi. Then we have
ti =
∑
p∈Ui
wdG(p) +
∑
q∈N(Ui)
∆i(q).
Since Difference Rules are not applicable, every uj, 1 6 j 6 d, has two private neighbors
with respect to v. Note that d(v) = 4. Let ∆wmin = min{∆w3,∆w4}. Then
t1 > w4 + 4∆wmin,
t2 > 4w3 +w4 + 8∆wmin,
and for 3 6 i 6 5,
ti > 6w3 +w4 + ∆wmin.
Maximum-Degree Rule. In this case the algorithm applies Standard Branching Rule.
Suppose that the degree of v is d and N(v) = {u1,u2, . . . ,ud}. For 1 6 i 6 d + 2, define
Gi = G \ Ui where U1 = {v}, U2 = N[v], and for i > 2, Ui = N[{v,ui−2}]. The algorithm
recursively solves d + 2 MAX 1-BDS problems on graphs G1,G2, . . . ,Gd+2, respectively.
Hence
T(w) =
d+2∑
i=1
T(wGi)
and
T(w) =
d+2∑
i=1
T(w− (w−wGi)).
25
Table 1: The weight vector w
w weights
w0 0.000000
w1 0.500000
w2 0.851306
w3 0.925947
w4 1.000000
Proof. Suppose that the maximum degree of the input graph is at least five. By comput-
ing the branching vector of each branching rules as Section 4.1.1, the worst case happens
when the Maximum-Degree Rule is applied and its branching number is (1, 6, 8, 8, 8, 8, 8)
and the branching number is 1.474151. Due to the maximum degree condition of Maximum-
Degree Rule, the algorithm ensures that at some stage all input instances are bounded
degree-4. Suppose that the maximum degree of the input graph is at most four. By using
measure and conquer approach, we see that the worst case happens when the Maximum-
Degree Rule is applied and its branching vector is
(1.296212, 5.296212, 6.777841, 6.777841, 6.777841, 6.777841)
with respect the weight vector
(w0,w1,w2,w3,w4) = (0, 0.5, 0.851306, 0.925947, 1)
and the corresponding branching number is 1.483369. Hence all branching numbers of
the algorithm are bounded by 1.483369. Thus the MAX 1-BDS problem can be solved in
time O∗(1.4834n). ✷
27
Table 3: Using measure and conquer analysis, we obtain a weight vector (w0,w1,w2,w3,w4) =
(0, 0.5, 0.851306, 0.925947, 1). Substitute the weight vector to the recurrences in Table 2, we see that the worst
branching number happens when the Maximum-Degree Rule is applied and the branching number is 1.483369.
True-Twin Rule 2
Branching Vector: (2.000000, 4.553918)
Branching number: 1.250845
False-Twin Rule
Branching Vector: (1.998824, 3.553918)
Branching number: 1.292776
Degree One Vertex Rule 2 Branching Vector: (1.574053, 3.276665)
Branching number: 1.348520
Domination Rule 1
Branching Vector: (1.148106, 3.553918)
Branching number: 1.386664
Degree Two Vertex Rule 1
Branching Vector: (3.479865, 4.331171, 6.033783, 6.033783, 6.033783)
Branching number: 1.381010
Degree Two Vertex Rule 2
Branching Vector: (2.925359, 4.479865, 4.479865, 4.480453, 4.480453)
Branching number: 1.483064
Difference Rule 1
Branching Vector: (1.296212, 5.703788, 5.703788, 5.703788)
Branching number: 1.439118
Difference Rule 2
Branching Vector: (1.296212, 5.851894, 5.851894, 5.851894, 5.851894)
Branching number: 1.482352
Domination Rule 2
Branching Vector: (1.296212, 5.296212, 6.629735, 6.629735, 6.629735)
Branching number: 1.455888
Maximum-Degree Rule
Branching Vector: (1.296212, 5.296212, 6.777841, 6.777841, 6.777841, 6.777841)
Branching number: 1.483369
29
We present a branch-and-reduce algorithm for the MAXIMUM INDUCED MATCHING
problem and analyze the running time of the algorithm using the number n of vertices in
the input graph as the size of the input.
For simplicity, we denote the size of a maximum induced matching of an undirected
graph G by mim(G). When the algorithm puts a vertex v into the solution set, we say
that it selects v. When the algorithm decides that a vertex v is not in the solution set, we
say that it discards v. Before we present the algorithm, we define a rule called Standard
Branching Rule: When the algorithm applies this rule, it selects a vertex v of degree d and
recursively solves d + 1 MAXIMUM INDUCED MATCHING problems on graphs Gi = G \ Ui,
respectively, where 1 6 i 6 d + 1, N(v) = {u1,u2, . . . ,ud}, U1 = {v} and for i > 2,
Ui = N[{v,ui−1}]. And then
mim(G) = max{mim(G1), max
26i6d+1
(2 +mim(Gi))}.
In the first branch of standard branching rule, it discards v. In each of the other
branches, it selects v and a neighbor u and discards N({v,u}). We give the following
observations.
Lemma 19 (Disconnected Rule). If G is disconnected and C is a component of G, then
mim(G) = mim(G[C]) +mim(G \ C).
Proof. Since G is disconnected and C is a component of G and mim(G) is the optimum
solution of the MAXIMUM INDUCED MATCHING problem in G, we see that mim(G) >
mim(G[C])+mim(G\C). Sincemim(G[C]) andmim(G\C) are both optimum solutions
of the MAXIMUM INDUCED MATCHING problem on graphs G[C] and G \ C respectively, we
have mim(G[C]) +mim(G \ C) > mim(G). This shows that mim(G) = mim(G[C]) +
mim(G \ C). ✷
Lemma 20 (Isolated-Vertex Rule). Let v be an isolated vertex of G. Then v is not in any
solution of the MAXIMUM INDUCED MATCHING problem. That is mim(G) = mim(G \ {v}).
31
Lemma 24 (Maximum-Degree-Two Rule). If the maximum degree of G is at most two, then
the MAXIMUM INDUCED MATCHING problem can be solved in polynomial time.
Lemma 25 (Degree-One Vertex Rule). Let G = (V ,E) be a graph, u be a degree-one vertex
in G, v ∈ N(u) and deg(v) > 3. Then
mim(G) = max{mim(G \ {u, v}), 2 +mim(G \N[v])}.
Proof. If v is discarded, u is also discarded since u can be matched only with v. Let S
be an optimal solution selecting v and x ∈ N(v) \ {u} be the vertex matched with v. We
see that (S ∪ {u}) \ {x} is also a solution of the same size. Thus either both u and v are
discarded or both u and v are selected. This completes the proof. ✷
Lemma 26 (True Twin Rule). Let G = (V ,E) be a graph and v and z be a pair of true twins
in G. Then
mim(G) = max{mim(G \ {v, z}), 2 +mim(G \N[v])}.
Proof. There are three cases, both v and z are discarded; only one of v and z is selected;
or both v and z are selected. Let S be an optimal solution that selects v and discards z.
It is easy to see that a vertex x ∈ N(v) \ {z} must be selected in S, otherwise S is not
optimal. Thus we obtain that S∪ {z} \ {x} is also an optimal solution. This shows that if an
optimal solution selects one of v and z, it selects both of them. Thus either both v and z
are discarded or both v and z are selected. This completes the proof. ✷
Lemma 27 (Domination Rule). Let v be a vertex of G and u be a neighbor of v with
N[u] ⊂ N[v]. Then there is a solution of the MAXIMUM INDUCED MATCHING problem that
either v is discarded or both v and u are selected from G. That is
mim(G) = max{mim(G \ v), 2 +mim(G \N[v])}.
Proof. Suppose that S is an optimal solution that v is selected and vertex x ∈ N(v) \ {u}
is the vertex matched with v. We see that S ∪ {u} \ {x} is a solution of the same size. Thus
there is a solution of the MAXIMUM INDUCED MATCHING problem that either v is discarded
or both u and v are selected. This completes the proof. ✷
33
1. Maximum Degree-Two Rule. All vertices are of degree at most two. In this case we
solve the problem in polynomial time.
2. Isolated-Vertex Rule. There is an isolated vertex and let X be the set of all isolated
vertices. Then mim(G) = mim(G \ X).
3. Isolated-Edge Rule. There is an isolated edge and let X be the set of all isolated
edges. Then mim(G) = 2 · |X| +mim(G \ V(X)).
4. Disconnected Rule. If G is disconnected (let C be a component of G), solve the
problem recursively in G[C] and G \ C.
5. False-Twin Rule. There exist two vertices u and v that are false twins in G. Then
mim(G) = mim(G \ {v}).
6. Degree-One Edge Rule. There is an edge (u, v) of degree one and let X = N[{u, v}].
Then mim(G) = 2 +mim(G \ X).
7. Degree-One Vertex Rule. There is a degree-one vertex u, v ∈ N(u), and deg(v) > 3.
Then the algorithm either discards both u and v or selects both u and v. That
is mim(G) = max {mim(G \ {u, v}), 2 +mim(G \N[v])}. The worst case happens
when deg(v) = 3. The worst case branching vector is (2, 4) and its branching number
is 1.2721.
8. True-Twin Rule. There are two vertices v and z such that N[z] = N[v], i.e., v and z
are true twins. Since Degree-One Edge Rule is not applicable, the degree of v and
z are at least three. The algorithm either discards {v, z} or selects {v, z} and discards
N[v] \ {v, z}. Hencemim(G) = max{mim(G \ {v, z}), 2 +mim(G \N[v])}. The worst
branching vector is (2, 4) and its branching number is 1.2721.
9. Domination Rule. Let v be a vertex of G and u be a neighbor of v satisfying that
N[u] ⊂ N[v]. The degree of v is at least 3. The algorithm either discards v or selects
{v,u} and discardsN[v]\{v,u}. Hencemim(G) = max {mim(G \ v), 2 +mim(G \N[v])}.
The worst branching vector is (1, 4) and its branching number is 1.3803.
10. Degree-Two Vertex Rule 1. There is a degree-two vertex z satisfying the condition
that the neighbor v with larger degree between the two neighbors of z is of degree
35
case happens when the degree of v is four. The branching vector is (1, 6, 6, 6, 6) and
its branching number is 1.5099 in this case.
Theorem 30. The MAXIMUM INDUCED MATCHING problem can be solved in timeO∗(1.5099n).
Proof. The worst case happens when the Maximum-Degree Rule is applied on graphs of
maximum degree four and its branching number is 1.5099. Thus the running time of the
branch-and-reduce algorithm is O∗(1.5099n). ✷
4.2.2 A more efficient exact algorithm
In this section, we give a more efficient algorithm for solving the MAXIMUM INDUCED
MATCHING problem by adding a new rule called Sparse Graph Rule as the boundary con-
dition of the algorithm. If the input graph does not satisfy the boundary condition, a rule
in the branch-and-reduce algorithm must be applied. We have the following algorithm.
1. Apply reduction rules: (i) Isolated-Vertex Rule, (ii) Isolated-Edge Rule, (iii) Dis-
connected Rule, (iv) False-Twin Rule, (v) Degree-One Edge Rule, if one of them is
applicable
2. Sparse Graph Rule. |E| 6 2.044 × |V |. In this case, we construct H = L2(G) and
compute α(H) where α(H) is the size of a maximum independent set in H. By
Lemma 18,mim(G) = 2× α(H).
3. Degree-One Vertex Rule. The worst branching vector is (2, 4) and its branching
number is 1.2721.
4. True-Twin Rule. The worst branching vector is (2, 4) and its branching number is
1.2721.
5. Domination Rule. The worst branching vector is (1, 4) and its branching number is
1.3803.
6. Degree-Two Vertex Rule 1. The worst branching vector is (4, 5, 5, 5) and its branch-
ing number is 1.3413.
37
For a vertex subset S ⊆ V , let E(S) be the set of edges in G[S]. Use NG(v) to be the set of
vertices adjacent to v in G andNG[v] = NG(v)∪{v}. For S ⊆ V , letNG(S) =
⋃
v∈SNG(v)\S.
We use deg(v) = |NG(v)| to denote the degree of v. Use ∆(W) = maxv∈W deg(v) to denote
the maximum degree of vertices inW ⊆ V .
Now we define some related problems of the MAXIMUM INDUCED MATCHING prob-
lem and show that if theses problems can be solved in time O∗(cn), then the MAXIMUM
INDUCED MATCHING problem can be solved also in time O∗(cn).
MAXIMUM EDGE BOUNDED-DEGREE-1 SET (MAX 1-EBDS)
Input: A simple graph G = (V ,E).
Output: A bounded-degree-1 set S ⊆ V such that the number of edges inG[S] is maximum
among all bounded-degree-1 sets in G.
MAXIMUM VERTEX CONSTRAINED BOUNDED-DEGREE-1 SET (MAX 1-VCBDS)
Input: A simple graph G = (V ,E) and a bounded-degree-1 set S ′ in G.
Output: A bounded-degree-1 set S ⊆ V such that S ′ ⊆ S and the number of edges in G[S]
is maximum among all bounded-degree-1 sets that contain S ′ in G.
Definition 3. Let G = (W ∪O,E) be a 2-colored graph whereW and O are sets of white
vertices and orange vertices, respectively. A bounded-degree-1 set S ⊆ W ∪ O is called
partially independent if every v ∈ S ∩O is of degree-0 in G[S].
MAXIMUM COLOR CONSTRAINED BOUNDED-DEGREE-1 SET (MAX 1-CCBDS)
Input: A 2-colored graph G = (W ∪O,E).
Output: A partially independent bounded-degree-1 set S ⊆ W ∪ O such that ξ(S) =
|E(S)| + |S ∩ O| is maximum among all partially independent bounded-degree-1 set in G
where |E(S)| is the number of edges in G[S].
Lemma 32. Let G = (V ,E) be a simple graph. A vertex set S is an optimal solution of the
MAX 1-EBDS problem in G if and only if E(S1) is a maximum induced matching in G where
S1 ⊆ S is the set of degree-1 vertices in G[S].
39
is a degree-1 vertex in G[S ′], then all vertices in NG(v) \ S
′ are not in S∗. If there is a
vertex x in V \S ′ having at least two neighbors in S ′ then x is not in S∗. We then construct
G ′ = (V ′ = W∪O,E ′) as the input of the MAX 1-CCBDS problem according to G and S ′ by
letting V ′ = V \ (S ′∪D∪NG(S1)), O = NG(S
′)\ (NG(S
′
1)∪D),W = V
′ \O. We see that in
G every vertex in O has exact a neighbor in S ′ and every vertex in W has no neighbor in
S ′. For x,y ∈ O, if in G they have a common neighbor in S ′, add an edge between x and y
in G ′. Let E ′ = {(u, v) | u, v ∈ V ′, (u, v) ∈ E} ∪ {(x,y) | x,y ∈ O,NG(x) ∩NG(y) ∩ S
′ 6= ∅}.
Let X be an optimal solution of the MAX 1-CCBDS problem. Since X∩O is an independent
set and every v ∈ X ∩O has exact a neighbor in S ′, X ∪ S ′ is a bounded-degree-1 set. We
obtain that
|E(X ∪ S ′)| = |E(S ′1)| + |E(X)| + |X ∩O|
6 |E(S∗)|
where S∗ is an optimal solution of the MAX 1-VCBDS problem in G. Since S∗ and S ′ are
both bounded-degree-1 sets in G, S∗ \ S ′ is bounded-degree-1 in G. Notice that every
v ∈ S∗ ∩NG(S
′) is orange and |NG(v) ∩ S
′| = 1. If S∗ ∩NG(S
′) is not an independent set
in G ′, then S∗ is not bounded-degree-1, a contradiction. Thus S∗ \S ′ is a feasible solution
of MAX 1-CCBDS problem in G ′, we obtain that
|E(S∗)| = |E(S ′1)| + |E(S
∗ \ S ′)| + |S∗ ∩O|
6 |E(S ′1)| + |E(X)| + |X ∩O|
= |E(X ∪ S ′)|.
Therefore, X∪ S ′ is an optimal solution of the MAX 1-VCBDS problem. Suppose that there
exists an algorithm that solves the MAX 1-CCBDS problem in time O∗(cn). Let G = (V ,E)
and S ′ be an input of the MAX 1-VCBDS problem. It takes polynomial time to construct
G ′ = (V ′,E ′) and it takes O∗(c|V
′ |), |V ′| 6 |V |, to find an optimal solution X of the MAX
1-CCBDS problem in G ′. Since X∪ S ′ is an optimal solution of the MAX 1-VCBDS problem,
this shows that the MAX 1-VCBDS problem can be solved in time O∗(cn) where n is the
number of vertices in G. ✷
Theorem 35. MAX 1-CCBDS 6P MAXIMUM INDEPENDENT SET.
41
For any two edges (x,y)(z,w) ∈ E(S), their corresponding vertices xy, zw ∈ L2(G[W]) are
not adjacent in H. It is easy to see that any two orange vertices o,o ′ ∈ S are not adjacent
in H. For any edge (x,y) ∈ E(S) and any orange vertex o ∈ S, since o is not adjacent to x
and y, o is not adjacent to xy in H. Thus, we obtain an independent set I ′ in H according
to S and
|I ′| = |S1|/2 + |S \ S1| = |E(S)| + |S ∩O| = ξ(S).
Since I∗ is a maximum independent set in H, we see that
ξ(S) = |I ′| 6 |I∗|.
This completes the proof. ✷
Let G = (W ∪ O,E) be an input of the MAX 1-CCBDS problem and S be an optimal
solution of the MAX 1-CCBDS problem in G. A vertex v ∈W ∪O is called selected if v ∈ S
and is called discarded if v 6∈ S.
Lemma 36. Let G = (W ∪ O,E) be an input graph of the MAX 1-CCBDS problem. If there
exists a vertex v ∈W having no white neighbors, then v must be discarded.
Proof. Assume that S is a feasible solution of the MAX 1-CCBDS problem in G such that
ξ(S) is maximized. Suppose that v ∈ S. Since all vertices in NG(v) are orange, all vertices
in NG(v) are not selected in S. We obtain that S \ {v} is also a feasible solution satisfying
ξ(S \ {v}) = ξ(S). This completes the proof. ✷
Now we give a branch-and-reduce algorithm for the MAX 1-CCBDS problem. This
algorithm consists of a boundary condition, a reduction rule, and a branching rule. In
the branching rule, the algorithm removes v from G after it decides to discard v. If the
algorithm selects a white vertex v in S, then the algorithm proceeds with the following four
steps, called selecting steps, to obtain a new input graph G ′ of the MAX 1-CCBDS problem
after selecting v.
1. Remove all orange neighbors of v from G.
43
if W = ∅ or wo 6
2
3 .
Branching Rule. There exists a vertex v ∈ W of degree at least four. The algorithm
either (i) selects v or (ii) discards v. Suppose that v has p white neighbors and q orange
neighbors. We have
T(wG) = T(wG − t1) + T(wG − t2)
where t1 = 1 and t2 = 1 + q ·wo + p · ∆wo. It is easy to see that the worst case happens
when the degree of v is four. Due to the Reduction Rule, there is no white vertex having
only orange neighbors. Suppose that deg(v) = 4, we have the following cases.
1. All vertices in N(v) are white. Then t2 = 1 + 4 · ∆wo.
2. There are three white vertices in N(v). Then t2 = 1+wo + 3 · ∆wo.
3. There are two white vertices in N(v). Then t2 = 1 + 2 ·wo + 2 · ∆wo.
4. There is only one white vertex in N(v). Then t2 = 1 + 3 ·wo + ∆wo.
With the best choice of weightwo = 0.50035, we obtain that the worst case applied the
Branching Rule is a degree-4 white vertex having no orange neighbors. Its corresponding
branching vector is (1, 1 + 4 · ∆wo) = (1, 2.9986) and branching number is 1.4658. For
instance satisfying the boundary condition, the algorithm constructs the auxiliary graph
H and applies Robson’s algorithm [40] to find a maximum independent set in H and it
takes
O∗(20.276·
wG
wo ) = O∗(20.276·
n
wo ) = O∗(20.276·
n
0.50035 )
= O∗(1.4658n)
time to solve the problem. Thus, the running time of the algorithm is O∗(1.4658n).
Theorem 37. The MAX 1-CCBDS problem can be solved in time O∗(1.4658n).
Corollary 38. The MAX 1-VCBDS problem, the MAX 1-EBDS problem, and the MAXIMUM
INDUCED MATCHING problem can be solved in time O∗(1.4658n).
45
6 計畫成果自評
在這三年的研究中, 我們設計了分支化約演算法解最大有限分支度一集合問題 (maximum
bounded-degree-1 set problem) 和最大導出配對問題 (maximum induced matching prob-
lem), 我們實作出衡量征服分析分支化約演算法的工具3, 用這個分析工具來分析我們所設計的演
算法, 得到最大有限分支度一集合問題 (maximum bounded-degree-1 set problem) 和最大導
出配對問題 (maximum induced matching problem)可以分別在O∗(1.4834n)和O∗(1.4658)時
間被解決。
我們將在未來的研究中利用衡量征服 (measure and conquer)這個分析工具來分析解決其他
問題的分支化約演算法 (branch-and-reduce algorithm)。本計畫研究內容與原計畫相符, 目前已
發表在國際研討會ICSEC 2011、第二十九屆組合數學與計算理論研討會和國際研討會 ICS 2012
(詳見附錄), 可以說達成預期目標, 研究成果具學術價值, 將陸續將其整理成論文發表於國際性學
術期刊。
7 參考文獻
References
[1] B. Balasundaram, Cohesive subgroup model for graph-based text mining, Proceed-
ings of the 2008 IEEE Conference on Automation Science and Engineering, pp. 989–
994, 2008.
[2] B. Balasundaram, S. Butenko, and I. V. Hicks, Clique relaxations in social network
analysis: The maximum k-plex problem, Operations Research, 59 (2011), pp. 133–
142.
[3] B. Balasundaram, S. Chandramouli, and S. Trukhanov, Approximation algorithms
for finding and partitioning unit-disk graphs into co-k-plexes, Optimization Letters,
4 (2010), pp. 311–320.
3http://210.240.226.131/qca.php
47
[13] M. Cygan, M. Pilipczuk, and J. O. Wojtaszczyk, Irredundant set faster than O(2n),
Proceedings of CIAC 2010, LNCS 6078, pp. 288–298.
[14] W. Duckworth, D. F. Manlove, M. Zito, On the approximability of the maximum
induced matching problem, Journal of Discrete Algorithms 3 (2005), pp. 79–91.
[15] D. Eppstein, Quasiconvex analysis of backtracking algorithms, Proceedings of
SODA 2004, pp. 781–790, 2004.
[16] D. Eppstein, Quasiconvex analysis of multivariate recurrence equations for back-
tracking algorithms, ACM Transactions on Algorithms 2 (2006), pp. 492–509.
[17] R. Erman, Ł. Kowalik, M. Krnc, and T. Walen´, Improved induced matching in sparse
graphs, Discrete Applied Mathematics 158 (2010), pp. 1994–2003.
[18] M. R. Fellows, J. Guo, H. Moser, and R. Niedermeier, A generalization of Nemhauser
and Trotter’s local optimization theorem, Journal of Computer and System Sciences,
77 (2011), pp. 1141–1158.
[19] F. V. Fomin, F. Grandoni, and D. Kratsch, Measure and conquer: domination – a case
study, Proceedings of ICALP 2005, LNCS 3580 (2005), pp. 191–203.
[20] F. V. Fomin, F. Grandoni, and D. Kratsch, Measure and conquer: a simple O(20.288n)
independent set algorithm, Proceedings of SODA 2006, pp. 18–25, 2006.
[21] F. V. Fomin, F. Grandoni, and D. Kratsch, A measure & conquer approach for the
analysis of exact algorithms, Journal of the ACM 56 (2009) Article No. 25.
[22] F. Fomin and D. Kratsch, Exact Exponential Algorithms, Springer, 2010.
[23] G. Fricke and R. Laskar, String matching in trees, Congressum Numeratium 89
(1992), pp. 239–243.
[24] J. Guo, C. Komusiewicz, R. Niedermeier, and J. Uhlmann, A more relaxed model
49
[34] B. McClosky and I.V. Hicks, Combinatorial algorithms for the maximum k-plex prob-
lem, Journal of Combinatorial Optimization, 23 (2012) pp. 29–49.
[35] H. Moser, S. Sikdar, The parameterized complexity of the induced matching problem
in planar graphs, Discrete Applied Mathematics 157, 715–727 (2009)
[36] H. Moser, D.M. Thilikos, Parameterized complexity of finding regular induced sub-
graphs, Journal of Discrete Algorithms 7, 181–190 (2009)
[37] H. Moser, R. Niedermeier, and M. Sorge, Exact combinatorial algorithms and ex-
periments for finding maximum k-plexes,Journal of Combinatorial Optimization 24
(2012), pp. 347–373.
[38] N. Nishmura, P. Ragde, D. M. Thilikos, Fast fixed-parameter tractable algorithms for
nontrivial generalizations of vertex cover, Discrete Applied Mathematics, 152 (2005),
pp. 229–245.
[39] Y. Orlovich, G. Finke, V. Gordon, and I. Zverovich, Approximability results for the
maximum and minimum maximal induced matching problems, Discrete Optimiza-
tion 5 (2008), pp. 584–593.
[40] J. M. Robson, Algorithms for maximum independent sets. Journal of Algorithms, 7
(1986), pp. 425–440.
[41] S. B. Seidman and B. L. Foster, A graph-theoretic generalization of the clique con-
cept, The Journal of Mathematical Sociology, 6 (1978), pp. 139–154.
[42] L. J. Stockmeyer and V. V. Vazirani, NP-completeness of some generalizations of the
maximum matching problem, Information Processing Letters 15 (1982), pp. 14–19.
[43] S. Trukhannov, Novel approaches for solving large-scale optimization problems on
graphs, PhD Thesis, A&M University, Texas, 2008.
51
8 Appendix
8.1 Maw-Shang Chang, Ling-Ju Hung, Ping-Chen Su, Exact and fixed-parameter
algorithms for problems related to 2-plex, Proceedings of ICSEC 2011, pp. 203–208.
8.2 Maw-Shang Chang, Ling-Ju Hung, Ping-Chen Su, Measure and conquer: analy-
sis of a branch-and-reduce algorithm for the maximum bounded-degree-1 set prob-
lem, Proceedings of the 29th Workshop on Combinatorial Mathematics and Compu-
tation Theory, pp. 136–145, 2012.
8.3 Maw-Shang Chang, Ling-Ju Hung, and Chau-An Miau, An O∗(1.4786n)-time al-
gorithm for the maximum induced matching problem, Proceedings of ICS 2012: Al-
gorithms and Bioinformatics Workshop, R. S. Chang, L. C. Jain, and S.-L. Peng (Eds.):
Advances in Intelligent Systems & Application, SIST 20, pp. 49–58, 2012
53
maximum k-plex in G is of size (n− p).
Known results. Balasundaram et al. proved that
the maximum k-plex problem is NP-complete [3].
They gave a 0/1 integer program for the prob-
lem [1, 3]. It is known that the maximum k-plex
problem is W[1]-hard with respect to the parame-
ter s being the size of k-plexes [9]. Some branch-
and-bound algorithms were given for solving the
maximum k-plex problem based on different upper
bounds and lower bounds found by some heuris-
tics algorithms [15, 10]. Some graph editing prob-
lems are studied on finding a disjoint union of k-
plexes [8, 4]. In [16], Wu and Pei gave an algorithm
to enumerate all maximal k-plexes [16].
A series of fixed algorithms were developed for
solving the d-BDD problem [13, 9, 6]. For the spe-
cial case 1-BDD, in [11], Moser et. al. provided a
fixed-parameter algorithm running inO(2.31p+pn)
time based on bounded search trees and gave an
iterated-compression algorithm for the same prob-
lem with running time O(2p · p2 + pn). The fixed-
parameter algorithm based on bounded search tree
in [11] can be modified to be an exact algorithm
for solving the MIN-1-BDD problem with run-
ning time O∗(1.8637n). Chen et al. gave a fixed-
parameter algorithm running in time O∗(3.24p) for
solving the 2-BDD problem. Fellows et al. showed
that for unbounded d values, the d-BDD problem is
W[2]-complete [6]. In [2], Balasundaram et al. re-
ferred that the MAX-d-BDS problem is as the prob-
lem of finding maximum-cardinality co-(d + 1)-
plexes.
In this paper, we give some new reduction rules
to improve the running time of the fixed-parameter
algorithm in [11] for solving the maximum 1-BDS
problem and obtain an exact algorithm for solving
the same problem. The running time of the fixed
parameter algorithm is O∗(1.7964p) where p is the
number of vertices to be removed such that the re-
maining graph is BOUNDED-DEGREE-1 and the
running time of the exact algorithm is O∗(1.5171n)
where n is the number of vertices in the given
graph. We can easily use this algorithm to find a
2-plex of maximum size for a graph.
2. Preliminaries
A modified O-notation, O∗, is used here to bound
the running time of exponential time algorithms
asymptotically. For functions f and g, f(n) =
O∗(g(n)) if f(n) = O(g(n) · poly(n)) where poly(n)
is a polynomial. For more description about theO∗-
notation, we refer to the book [7].
Branching is one of the algorithmic techniques to
design exact algorithms. A typical branching algo-
rithm consists of a collection of reduction rules and
branching rules. Reduction rules are used to reduce
the input size. Branching rules are used to recur-
sively solve the smaller instances of the problem.
Search trees are often used to illustrate the execu-
tion of a branching algorithm. The root of a search
tree represents the input of the problem, every child
of the root represents a smaller instance reached by
applying a branching rule associated with the in-
stance of the root. One can recursively assign a
child to a node in the search tree when applying a
branching rule. Notice that we do not assign a child
to a node when applying a reduction rule. The run-
ning time of a branching algorithm is usually mea-
sured by the maximum number of leaves in its cor-
responding search tree. Let T (n) be the maximum
number of leaves in any search tree where n is the
input size. We analyze each branching rule and use
the worst-case time complexity over all branching
rules as an upper bound of the running time. Let b
be any branching rule. When rule b is applied, the
current instance is branched into r ≥ 2 instances
of size at most n − t1, n − t2, . . . , n − tr. Note that
n ≥ ti for i = 1, 2, . . . , r. We call b = (t1, t2, . . . , tr)
the branching vector of branching rule b. This can be
formulated in a linear recurrence
T (n) ≤ T (n− t1) + T (n− t2) + · · ·+ T (n− tr).
Theorem 1 ([7]). Let b be a branching rule with branch-
ing vector (t1, t2, . . . , tr). Then the running time of
the branching algorithm using only branching rule b is
O∗(αn), where α is the unique positive real root of
xn − xn−t1 − xn−t2 − · · · − xn−tr = 0
Remark 1. The positive real rootα is called the branch-
ing number. One can apply the above theorem to ana-
lyze the running time of a branching algorithm. Com-
pute αi for each branching rule bi. An upper bound of
the number of leaves in the search tree is O∗(cn) where
c = maxi αi. If the running time of the algorithm corre-
sponding to one node of the search tree is polynomial, the
running time of a branching algorithm is O∗(cn). For
more details about branching algorithms, please refer to
the book [7].
A problem is fixed-parameter tractable (FPT) if
given any instance of size n and a positive integer
p, one can give algorithms to solve it in time f(p) ·
nO(1) where f(p) is a computable function only
depending on p. We call those algorithms fixed-
parameter algorithms. There are many results about
fixed parameter algorithms introduced in [12].
204
© ICSEC 2011, September 2011, Bangkok, Thailand.
The standard branching of a maximum bounded-
degree-1 subset algorithm chooses a vertex v of
maximum degree and then either it discards v from
the solution and solves the problem recursively on
G \ {v}, or for every vertex set U ∈ U = {{v}} ∪
{{v, u} | u ∈ N(v)}, it selects U for the solution and
solves the problem recursively on G \N [U ]. Hence
β1(G) = max
{
β1(G \ v),
max
U∈U
(|U |+ β1(G \N [U ])).
Our algorithmwill apply the standard branching
rule when none of the other rules can be applied.
The description of the algorithm consists of a se-
quence of cases and subcases. To avoid a confusing
nesting of if-then-else statements let us use the fol-
lowing convention: The first case which applies is
used in the algorithm. Thus, inside a given case, the
hypothesis of all previous cases are assumed to be
false. Algorithm β1(G) computes for a given graph
G = (V,E) the maximum size of a vertex set S in-
ducing a bounded-degree-1 subgraph.
1. Maximum Degree-Two Rule. All vertices are
of degree at most two. In this case we solve the
problem in polynomial time and return the so-
lution. In the following the maximum degree
of G is greater than two.
2. Isolated-Vertex Rule. There is an isolated ver-
tex and let X be the set of all isolated vertices.
Then
β1(G) = |X |+ β1(G \X).
3. Isolated-Edge Rule. There is an isolated edge
and let X be the set of all isolated edges. Then
β1(G) = 2 · |X |+ β1(G \ V (X)).
4. Degree-OneEdgeRule. There is an edge (u, v)
of degree at most one and let X = N [{u, v}].
Then
β1(G) = 2 + β1(G \X).
5. Degree-One Vertex Rule 1. There is a vertex v
having at least two degree-one neighbors and
let X be the set of all degree-one neighbors of
v. Then
β1(G) = |X |+ β1(G \ (X ∪ {v})).
6. Degree-One Vertex Rule 2. There is a ver-
tex v having a degree-one neighbor w. Since
Degree-One Edge rule is not applicable, the de-
gree of v is at least three. Otherwise (v, w) is
an edge of degree at most one. In this case the
algorithm either discards v and selects w or se-
lects {v, w} and discardsN [v] \ {v, w}.
β1(G) = max
{
1 + β1(G \ {v, w}),
2 + β1(G \N [v]).
The worst branching vector is (2, 4) and its
branching number is 1.2721.
7. True-Twin Rule. There are two vertices v and
w such that N [w] = N [v], i.e., v and w are true
twins. Since Degree-One Edge rule is not ap-
plicable, the degrees of v andw are at least two.
The algorithm either discards {v, w} or selects
{v, w} and discardsN [v] \ {v, w}. Hence
β1(G) = max
{
β1(G \ {v, w}),
2 + β1(G \N [v]).
The worst branching vector is (2, 3) and its
branching number is 1.3248.
8. Domination Rule. There is a maximum-
degree vertex v of G, a neighbor u of v, and
N [u] ⊂ N [v]. The degree of v is at least 3.
The algorithm either discards v or selects {v, u}
and discardsN [v] \ {v, u}. Hence
β1(G) = max
{
β1(G \ v),
2 + β1(G \N [v]).
The worst branching vector is (1, 4) and its
branching number is 1.3803.
9. Degree-Two Vertex Rule. There is a degree-
two vertex w satisfying the condition that the
neighbor v with larger degree between the two
neighbors of w is of degree at least three. Let x
be the neighbor of w other than v. Since Dom-
ination rule is not applicable, x and v are not
adjacent and |N [u]\N [v]| ≥ 1 for any u ∈ N(v).
There are two cases:
(a) the degree of x is two. If we discard v
then (w, x) becomes a degree-one edge
and hence there is an optimal solution
that selects {w, x} and discards the neigh-
bor of x other than w. On the other hand,
if v is selected, then there is an optimal so-
lution that also selects one neighbor of v.
Let U = {{v, u} | u ∈ N(v)}. Hence
β1(G) = max
{
2 + β1(G \N [{x,w}]),
2 + maxU∈U β1(G \N [U ]).
The worst case happens when degree of v
is three. The branching vector is (4, 5, 5, 5)
and its branching number is 1.3413.
206
© ICSEC 2011, September 2011, Bangkok, Thailand.
{
T (p) = T (p− t1) + T (p− t2) + · · ·+ T (p− tr),
T (1) = 1.
The following branching vectors and branching
numbers are associated with branching rules listed
in Section 3 and the parameter p.
• Degree-One Vertex Rule 2: the branching vec-
tor is (1, 2) and the branching number is
1.6181.
• True-Twin Rule: the branching vector is (2, 1)
and the branching number is 1.6181.
• Domination Rule: the branching vector is (1, 2)
and the branching number is 1.6181.
• Degree-Two Vertex Rule: (a) the branch-
ing vector is (2, 3, 3, 3) and the branching
number is 1.6717; (b) the branching vector
is (2, 3, 3, 3, 3) and the branching number is
1.7964.
• Difference Rule: the branching vector is
(1, 4, 4, 4, 4) and the branching number is
1.7485.
• Standard Branching Rule: the branching vec-
tor is (1, 4, 5, 5, 5, 5) and the branching number
is 1.6930.
Theorem 3. The 1-BDD problem can be solved in time
O∗(1.7964p).
References
[1] B. Balasundaram, Cohesive subgroup model
for graph-based text mining. Proceedings of the
2008 IEEE Conference on Automation Science and
Engineering, pp. 989–994.
[2] B. Balasundaram, S. Chandramouli, and S.
Trukhanov, Approximation algorithms for
finding and partitioning unit-disk graphs
into co-k-plexes, Optimization Letters 4 (2010),
pp. 311–320.
[3] B. Balasundaram, S. Butenko, I. V. Hicks,
Clique relaxations in social network analysis:
The maximum k-plex problem, Operations Re-
search 59 (2011), pp. 133–142.
[4] R. van Bevern, H. Moser, and R. Niedermeier,
Approximation and tidying–a problem kernel
for s-plex cluster vertex deletion. To appear in
Algorithmica (Doi 10.1007/s00453-011-9492-7).
[5] Z. Z. Chen, M. Fellows, B. Fu, H. Jiang, Y. Liu,
L. Wand, and B. Zhu, A linear kernel for co-
path/cycle packing, Proceedings of AAIM 2010,
LNCS 6124, pp. 90–102.
[6] M. R. Fellows, J. Guo, H. Moser, R. Nieder-
meier, A generalization of Nemhauser and
Trotter’s local optimization theorem. To ap-
pear in Journal of Computer and System Sciences
(DOI 10.1016/j.jcss.2010.12.001).
[7] F. V. Fomin and D. Kratsch, Exact Exponential
Algorithms, Springer, 2010.
[8] J. Guo, C. Komusiewicz, R. Niedermeier, and
J. Uhlmann, A more relaxed model for graph-
based data clustering: s-plex cluster editing,
SIAM Journal on Discrete Mathematics 24 (2010),
pp. 1662–1683
[9] C. Komusiewicz, F. Hu¨ffner, H. Moser, and
R. Niedermeier, Isolation concepts for effi-
ciently enumerating dense subgraphs, Theoret-
ical Computer Science 410 (2009), pp. 3640–3654.
[10] B. McClosky and I.V. Hicks, Combinatorial al-
gorithms for the maximum k-plex problem, To
appear in Journal of Combinatorial Optimization
(DOI 10.1007/s10878-010-9338-2).
[11] H. Moser, R. Niedermeier, and M. Sorge,
Exact combinatorial algorithms and experi-
ments for finding maximum k-plexes, To ap-
pear in Journal of Combinatorial Optimization
(DOI 10.1007/s10878-011-9391-5).
[12] R. Niedermeier, Invitation to Fixed-Parameter
Algorithms, Oxford University Press, 2006.
[13] N. Nishmura, P. Ragde, D. M. Thilikos, Fast
fixed-parameter tractable algorithms for non-
trivial generalizations of vertex cover, Discrete
Applied Mathematics 152 (2005), pp. 229–245.
[14] S. B. Seidman and B. L. Foster, A graph-
theoretic generalization of the clique concept,
The Journal of Mathematical Sociology 6 (1978),
pp. 139–154
[15] S. Trukhannov, Novel approaches for solving
large-scale optimization problems on graphs, PhD
thesis, A&MUniversity, Texas.
[16] B. Wu and X. Pei, A parallel algorithm for enu-
merating all the maximal k-plexes. Proceedings
of PAKDD 2007, LNAI 4819 (2007), pp. 476–
483.
208
© ICSEC 2011, September 2011, Bangkok, Thailand.
Traditionally the size of a graph problem is mea-
sured by the number n of vertices in the input
graph. In measure and conquer analysis, each ver-
tex is assigned a weight in the range [0, 1] and the
size of the problem is measured by the total weight
w of all vertices. Usually the weight of a vertex de-
pends on its degree in the graph and the higher its
degree the heavier its weight. Hence the weight of
a vertex is reduced while its degree is reduced dur-
ing the execution of the algorithm. The key issue
in measure and conquer analysis is how to assign
weights to vertices to obtain a tighter bound on
the running time of the algorithm. The problem
of assigning weights to vertices to obtain a tighter
bound on the running time was formulated as a
quasiconvex program [9]. Eppstein showed how
to solve the quasiconvex program by a greedy al-
gorithm [8, 9]. We implemented this algorithm
and used it to analyze the running time of our
branch-and-reduce algorithm for the MAX-1-BDS
problem defined as follows.
Let G = (V,E) be a simple undirected graph.
Use G[X ] to denote the graph induced by X in G.
For a vertex v in G, use N(v) for the set of vertices
adjacent to v and let N [v] = N(v) ∪ {v}. We
call |N(v)| the degree of v, denoted by dG(v). Let
∆(G) denote the maximum degree of G. We call
a graph G BOUNDED-DEGREE-d iff ∆(G) ≤ d.
A vertex subset S of G is called a BOUNDED-
DEGREE-d Set of G if ∆(G[S]) ≤ d.
Maximum Bounded-Degree-d Set
(MAX-d-BDS)
Input: A graph G = (V,E).
Output: A vertex set S ⊆ V of maximum cardi-
nality such that G[S] is BOUNDED-DEGREE-d.
A k-plex of a graph G = (V,E) is a vertex set
S ⊆ V such that every vertex in G[S] has degree
at least |S| − k. By definition, a k-plex in G is a
(k − 1)-BDS in the complement graph of G, say
G¯. Thus a graph G with n vertices has a k-plex
of size s iff G¯ has a (k − 1)-BDS with s vertices.
The model k-plex is defined as a degree based re-
laxed model for finding cohesive subgroups in so-
cial networks [19]. Notice that a 1-plex is a clique.
The maximum k-plex problem in a given graph G
is to find a k-plex in G with maximum cardinal-
ity. Balasundaram et al. proved that the max-
imum k-plex problem is NP-complete [2]. They
gave a 0/1 integer program for the problem [1, 2].
It is known that the maximum k-plex problem is
W[1]-hard with respect to the parameter s being
the size of k-plexes [15]. Some branch-and-bound
algorithms were given for solving the maximum
k-plex problem based on different upper bounds
and lower bounds found by some heuristics algo-
rithms [20, 16]. A series of fixed algorithms were
developed for solving the MAX-d-BDS problem by
taking the size of vertices being deleted as the in-
put parameter [18, 15, 17, 10]. When parame-
terized by treewidth the MAX-1-BDS problem is
W[1]-hard [5]. In [3], Balasundaram et al. re-
ferred the MAX-d-BDS problem as the problem
of finding maximum-cardinality co-(d+ 1)-plexes.
Chang et al. gave an O∗(1.5171n)-time exact algo-
rithm to solve the MAX-1-BDS problem where n
is the number of vertices in the input graph [7]. In
this paper, we modify the algorithm in [7] and an-
alyze the new algorithm by the measure and con-
quer approach. We show that the running time of
the new algorithm is O∗(1.4834n).
We close this section with some notation. Given
a graph G = (V,E), we use n to denote the num-
ber of vertices in G. Two vertices u and v are
called true twins in G ifN [u] = N [v]. Two vertices
u and v are called false twins in G if N(u) = N(v).
A vertex v is called an isolated vertex if |N(v)| = 0
and is called a degree-one vertex if |N(v)| = 1. For
an edge (u, v) ∈ E, define the degree of (u, v) to be
deg(u, v) = |N(u) ∪N(v) \ {u, v}|. An edge (u, v)
is called an isolated edge if deg(u, v) = 0 and is
called a degree-one edge if deg(u, v) = 1. We use
G\X to denote G[V \X ]. Let W ⊆ E be a subset
of edge set, use V (W ) = ∪(u,v)∈W {u, v}. For a
vertex subset U ⊆ V , let N(U) = ∪u∈UN(u) \ U
and N [U ] = N(U) ∪ U . We use N i(v) to denote
the set of vertices at distance i from v. A vertex
u has private neighbors with respect to vertex v if
N(u) \ N [v] 6= ∅ and p is a private neighbor of u
with respect to v if p ∈ N(u) \N [v].
2 An exact algorithm for the MAX-
1-BDS problem
In this section, we present a branch-and-reduce
algorithm for the MAX-1-BDS problem and ana-
lyze the running time of the algorithm using the
number n of vertices in the input graph as the size
of the input.
When the algorithm puts a vertex v into the so-
lution set, we say that it selects v. When the algo-
rithm decides that a vertex v is not in the solution
set, we say that it discards v. Before explaining
the algorithm in detail, we describe the main rules
that the algorithm will apply. Some proofs are
omitted due to the space limit. For simplicity, we
denote the size of a maximum bounded-degree-d
set of an undirected graph G by βd(G).
The 29th Workshop on Combinatorial Mathematics and Computation Theory
137
s s s
ss
 
 
@
@
@
@
HHHH
z
(a)
v
s s
s s
@
@
 
 
v u
(b)
s s s
s
 
 
@
@
v
z
(c)
s s s
s
 
 
@
@
v
zu
(d)
s s s
s s
s
 @
 HH
z
x
y
v
(e)
s s s s
s s
s
 @  @
 HH
z
x v
(f)
s s s s
s s s s
s



Q
Q
Q


A
A
 
 
z y
v
(g)
s s s s
s s s s
s



Q
Q
Q


A
Az
v
(h)
s s s
s s s s
s



Q
Q
Q


A
A
@
@
 
 
@
@
u z
v
(i)
s s s s s s s s
s s s s
s



Q
Q
Q


A
A


C
C


C
C


C
C


C
C
u z
v
(j)
Figure 1: Worst cases of (a) True-Twin Rule 2; (b) False-Twin Rule; (c) Degree-One Vertex Rule 2; (d) Domina-
tion Rule 1; (e) Degree-Two Vertex Rule 1; (f) Degree-Two Vertex Rule 2; (g) Difference Rule 1; (h) Difference
Rule 2; (i) Domination Rule 2; and (j) Maximum-Degree Rule. Edges with both endvertices in N(v) are omitted.
12. Degree-Two Vertex Rule 2. There is a
degree-two vertex z satisfying the condition
that the neighbor v with larger degree be-
tween the two neighbors of z is of degree
at least three. Let x be the neighbor of
z other than v. Since Domination Rule is
not applicable, x and v are not adjacent and
|N [u] \N [v]| ≥ 1 for any u ∈ N(v). The de-
gree of x is at least three as Fig. 1(f). If we
discard v then z becomes a degree-one ver-
tex and hence there is an optimal solution
that either selects z and discards x or selects
{z, x} and discards N(x) \ {z}. On the other
hand, if v is selected, then there is an op-
timal solution that also selects one neighbor
of v. Let U = {{v, u} | u ∈ N(v)}. Hence
β1(G) = max{1 + β1(G \ N [z]), 2 + β1(G \
N [{x, z}]), 2 + maxU∈U β1(G \ N [U ])}. The
worst case happens when degree of v is three.
The branching vector is (3, 5, 5, 5, 5) and its
branching number is 1.4336.
13. Disconnected Rule. If G is discon-
nected (let C be a component of G), return
β1(G[C]) + β1(G \ C).
Note that for any d ≥ 3 there is at most
one d-regular graph assigned to a node of the
search tree from the root to a leaf, since ev-
ery instance generated by the algorithm is an
induced subgraph of the input graph of the
original problem. Hence any branching rule
applied to d-regular graphs, for some fixed d,
can only increase the number of leaves by a
multiplicative constant. Hence we may ne-
glect the branching rules needed for d-regular
graphs in the time analysis. Therefore we ne-
glect the case when G is 3-regular. If G is not
3-regular and the maximum degree is three,
then one of the above rules applies. In the fol-
lowing rules, we may assume that the maxi-
mum degree of the input graph is at least four.
14. Difference Rule 1. There is a maximum-
degree vertex v of G and there exist y, z ∈
N(v) satisfying that |N(z) \ N(v)| = 1 and
N(z) ∩ N2(v) ⊆ N(y) ∩ N2(v) as Fig. 1(g).
The algorithm either discards v or selects v
and one of vertices in N(v) \ {y}. Hence
β1(G) = max{β1(G\{v}), 2+maxU∈U(β1(G\
N [U ])} where U = {{v, p} | p ∈ N(v) \
{y}}. The worst case time complexity hap-
pens when the degree of v is four. The branch-
ing vector is (1, 6, 6, 6) and its branching num-
ber is 1.4570.
15. Difference Rule 2. There is a maximum-
degree vertex v of G, a neighbor z of v, and
|N [z] \N [v]| = 1 as Fig. 1(h). Since Domina-
tion Rule is not applicable, |N [u] \N [v]| ≥ 1
for any u ∈ N(v). In this case the algorithm
either discards v or selects v and one of its
neighbor. Let U = {{v, u} | u ∈ N(v)}. Then
β1(G) = max{β1(G\{v}),maxU∈U(2+β1(G\
N [U ])}. The worst case time complexity hap-
pens when the degree of v is four. The branch-
ing vector is (1, 6, 6, 6, 6) and its branching
number is 1.5099.
16. Domination Rule 2. There is a maximum-
degree vertex v of G and u and z are two
neighbors of v satisfying (N(u) \ N [v]) ⊆
(N(z) \ N [v]) as Fig. 1(i). Then the algo-
rithm either discards v, or selects v and dis-
cards all its neighbors, or selects v and one of
vertices in N(v) \ {z}. Let U = {{v, p} | p ∈
The 29th Workshop on Combinatorial Mathematics and Computation Theory
139
vertex q in G minus the weight of q in Gi. Then
we have
ti =
∑
p∈Ui
wdG(p) +
∑
q∈N(Ui)
∆i(q).
Note that 2 ≤ d(v) ≤ 4.
t1 ≥ 2w2 + 4 min
2≤i≤4
∆wi,
t2 ≥ 3w2 + w3 + min
1≤i≤4
∆wi.
Degree-One Vertex Rule 2. In this rule, the al-
gorithm recursively solves two MAX-1-BDS prob-
lems on graphs G1 = G\{v, z} and G2 = G\N [v],
respectively. The recurrence relation for this rule
is T (w) = T (wG1)+T (wG2) = T (w−t1)+T (w−t2)
where t1 = w − wG1 and t2 = w − wG2 and
the branching vector is (t1, t2). For vertex u, use
∆1(u) for the weight of u in G minus the weight of
u in G1 and ∆2(u) for the weight of u in G minus
the weight of u in G2. By definition,
t1 = wdG(v) + wdG(z) +
∑
u∈N(v)\{z}
∆1(u);
t2 =
∑
u∈N [v]
wdG(u) +
∑
u∈N2(v)
∆2(u).
Notice that 3 ≤ dG(v) ≤ 4, dG(z) = 1, dG(u) ≥ 2
for u ∈ N(v) \ {z}, |N2(v)| > 1, and dG(u) ≥ 1
for u ∈ N2(v). Hence
t1 ≥ w1 + w3 + 2 min
2≤i≤4
∆wi;
t2 ≥ w1 + 2w2 + w3 + 2 min
1≤i≤4
∆wi.
Domination Rule 1. Suppose the degree of v is
d and N(v) = {u1 = u, u2, . . . , ud}. Define G1 =
G \ {v} and G2 = G \ N [{v, u}]. The algorithm
recursively solves two MAX-1-BDS problems on
graphs G1 and G2 respectively. Hence
T (w) = T (wG1) + T (wG2)
and
T (w) = T (w − (w − wG1)) + T (w − (w − wG2)).
Define ti = w−wGi . Then the branching vector
is (t1, t2) in this case. Use ∆i(q) for the weight of
vertex q in G minus the weight of q in Gi. Then
we have
ti =
∑
p∈Ui
wdG(p) +
∑
q∈N(Ui)
∆i(q).
Since True-Twin Rule is not applicable, v has a
private neighbor with respect to u. Note that 3 ≤
d(v) ≤ 4.
t1 ≥ w3 + 3 min
2≤i≤4
∆wi,
t2 ≥ 3w2 + w3 + min
2≤i≤4
∆wi.
Degree-Two Vertex Rule 1. Suppose that
d(x) = 2, the degree of v is d, and N(v) =
{u1 = z, u2, . . . , ud}. For 1 ≤ i ≤ d + 1, define
Gi = G\Ui where U1 = N [{x, z}], U2 = N [{v, z}],
and for 2 < i ≤ d + 1, Ui = N [{x, y, v, ui−1}].
The algorithm recursively solves d + 1 MAX-1-
BDS problems on graphs G1, G2, . . . , Gd+1, re-
spectively. Hence
T (w) =
d+1∑
i=1
T (wGi).
And
T (w) =
d+1∑
i=1
T (w − (w − wGi)).
Define ti = w − wGi . Then the branching vector
is (t1, t2, . . . , td+1) in this case. Use ∆i(u) for the
weight of vertex u in G minus the weight of u in
Gi. Then we have
ti =
∑
p∈Ui
wdG(p) +
∑
q∈N(Ui)
∆i(q).
Since Domination Rule and False-Twin Rule
are not applicable, every uj , 1 ≤ j ≤ d, has
a private neighbor with respect to v. Note that
3 ≤ dG(v) ≤ 4. Hence
t1 ≥ 3w2 + w3,
t2 ≥ 4w2 + w3,
and for 3 ≤ i ≤ d+ 1,
ti ≥ 6w2 + w3.
Degree-Two Vertex Rule 2. Suppose that
d(x) ≥ 3, the degree of v is d, and N(v) = {u1 =
z, u2, . . . , ud}. For 1 ≤ i ≤ d + 2, define Gi =
G \ Ui where U1 = N [{z}], U2 = N [{x, z}], U3 =
N [{v, z}] and for 3 < i ≤ d+2, Ui = N [{v, ui−2}].
The algorithm recursively solves d + 2 MAX-1-
BDS problems on graphs G1, G2, . . . , Gd+2, re-
spectively. Hence
T (w) =
d+2∑
i=1
T (wGi).
The 29th Workshop on Combinatorial Mathematics and Computation Theory
141
T (w) =
d+1∑
i=1
T (wGi)
and
T (w) =
d+1∑
i=1
T (w − (w − wGi)).
Define ti = w−wGi . Then the branching vector
is (t1, t2, . . . , td+1) in this case. Use ∆i(q) for the
weight of vertex q in G minus the weight of q in
Gi. Then we have
ti =
∑
p∈Ui
wdG(p) +
∑
q∈N(Ui)
∆i(q).
Since Difference Rules are not applicable, every
uj , 1 ≤ j ≤ d, has two private neighbors with
respect to v. Note that d(v) = 4. Let ∆wmin =
min{∆w3,∆w4}. Then
t1 ≥ w4 + 4∆wmin,
t2 ≥ 4w3 + w4 + 8∆wmin,
and for 3 ≤ i ≤ 5,
ti ≥ 6w3 + w4 +∆wmin.
Maximum-Degree Rule. In this case the algo-
rithm applies Standard Branching Rule. Sup-
pose that the degree of v is d and N(v) =
{u1, u2, . . . , ud}. For 1 ≤ i ≤ d + 2, define
Gi = G \ Ui where U1 = {v}, U2 = N [v], and
for i > 2, Ui = N [{v, ui−2}]. The algorithm re-
cursively solves d + 2 MAX-1-BDS problems on
graphs G1, G2, . . . , Gd+2, respectively. Hence
T (w) =
d+2∑
i=1
T (wGi)
and
T (w) =
d+2∑
i=1
T (w − (w − wGi)).
Define ti = w − wGi . Then the branching vector
is (t1, t2, . . . , td+2) in this case. Use ∆i(u) for the
weight of vertex u in G minus the weight of u in
Gi. Then we have
ti =
∑
p∈Ui
wdG(p) +
∑
q∈N(Ui)
∆i(q).
Since Difference Rules are not applicable, every uj ,
1 ≤ j ≤ d, has two private neighbors with respect
to v. Since Domination Rules are not applicable,
every uj has a private neighbor in N
2(v) with re-
spect to any other ui ∈ N(v). Note that d(v) = 4.
Let ∆wmin = min{∆w3,∆w4}. Then
t1 ≥ w4 + 4∆wmin,
t2 ≥ 4w3 + w4 + 8∆wmin,
and for 3 ≤ i ≤ 6,
ti ≥ 6w3 + w4 + 3∆wmin.
In Table 2, we list branching rules and its worst
case branching vectors – using measure and con-
quer analysis. For finding the weight vector
w = (w0, w1, w2, w3, w4),
we develop a program 2 for solving the quasicon-
vex programming. In Table 1, we list the result
returned by the program.
Table 1: The weight vector w
w weights
w0 0.000000
w1 0.500000
w2 0.851306
w3 0.925947
w4 1.000000
By substituting the weight vector w for the
corresponding variables in the collections of re-
currence functions, we can compute the branch-
ing number for each branching rule with respect
to the weight vector w. The worst case happens
that when the Maximum-Degree Rule is applied
and its branching number 1.483369.
Theorem 2. The MAX-1-BDS problem can be
solved in time O∗(1.4834n).
Proof. Suppose that the maximum degree of
the input graph is at least five. By comput-
ing the branching vector of each branching rules
as Section 2, the worst case happens when the
Maximum-Degree Rule is applied and its branch-
ing number is (1, 6, 8, 8, 8, 8, 8) and the branch-
ing number is 1.474151. Due to the maximum
degree condition of Maximum-Degree Rule, the
algorithm ensures that at some stage all in-
put instances are bounded degree-4. Suppose
that the maximum degree of the input graph
is at most four. By using measure and con-
quer approach, we see that the worst case hap-
pens when the Maximum-Degree Rule is applied
2http://ufo.cs.ccu.edu.tw/qca.php
The 29th Workshop on Combinatorial Mathematics and Computation Theory
143
Table 2: We generate those worst cases of some specific branching rules, and then finds the weight
vector w such that the corresponding quasiconvex programming reaches its infimum. This table lists the
branching rules and the corresponding worst case branching vectors – using measure and conquer analysis.
The weight vector w = (w0, w1, w2, w3, w4) = (0, 0.5, 0.851306, 0.925947, 1). Substitute the weight vector
to the collection of recurrence functions, we obtain that the worst branching number happens when the
Maximum-Degree Rule is applied and the branching number is 1.483369.
True-Twin Rule 2
Branching Vector: (2.000000, 4.553918)
Branching number: 1.250845
T (w) = T (w − 2w4) + T (w − 3w2 + 2w4)
False-Twin Rule
Branching Vector: (1.998824, 3.553918)
Branching number: 1.292776
T (w) = T (w − (2w2 + 4 min
2≤i≤4
∆wi)) + T (w − (3w2 + w3 + min
1≤i≤4
∆wi))
Degree One Vertex Rule 2
Branching Vector: (1.574053, 3.276665)
Branching number: 1.348520
T (w) = T (w − (w1 + w3 + 2 min
2≤i≤4
∆wi)) + T (w − (w1 + 2w2 + w3 + 2 min
1≤i≤4
∆wi))
Domination Rule 1
Branching Vector: (1.148106, 3.553918)
Branching number: 1.386664
T (w) = T (w − (w3 + 3 min
2≤i≤4
wi)) + T (w − (3w2 + w3 + min
2≤i≤4
∆wi))
Degree Two Vertex Rule 1
Branching Vector: (3.479865, 4.331171, 6.033783, 6.033783, 6.033783)
Branching number: 1.381010
T (w) = T (w − (3w2 + w3)) + T (w − (4w2 + w3)) + 3T (w − (6w2 + w3))
Degree Two Vertex Rule 2
Branching Vector: (2.925359, 4.479865, 4.479865, 4.480453, 4.480453)
Branching number: 1.483064
T (w) = T (w − (w2 + 2w3 + 3 min
2≤i≤4
∆wi)) + 2T (w − (3w2 + 2w3 + min
2≤i≤4
∆wi)) + 2T (w − (3w2 +
2w3 +∆w3))
Difference Rule 1
Branching Vector: (1.296212, 5.703788, 5.703788, 5.703788)
Branching number: 1.439118
T (w) = T (w − (w4 + 4 min
3≤i≤4
∆wi)) + 3T (w − (5w3 + w4 + min
3≤i≤4
∆wi))
Difference Rule 2
Branching Vector: (1.296212, 5.851894, 5.851894, 5.851894, 5.851894)
Branching number: 1.482352
T (w) = T (w − (w4 + 4 min
3≤i≤4
∆wi)) + 4T (w − (5w3 + w4 + 3 min
3≤i≤4
∆wi))
Domination Rule 2
Branching Vector: (1.296212, 5.296212, 6.629735, 6.629735, 6.629735)
Branching number: 1.455888
T (w) = T (w−(w4+4 min
3≤i≤4
∆wi))+T (w−(4w3+w4+8 min
3≤i≤4
∆wi))+3T (w−(6w3+w4+ min
3≤i≤4
∆wi))
Maximum-Degree Rule
Branching Vector: (1.296212, 5.296212, 6.777841, 6.777841, 6.777841, 6.777841)
Branching number: 1.483369
T (w) = T (w − (w4 + 4 min
3≤i≤4
∆wi)) + T (w − (4w3 + w4 + 8 min
3≤i≤4
∆wi)) + 4T (w − (6w3 + w4 +
3 min
3≤i≤4
∆wi))
The 29th Workshop on Combinatorial Mathematics and Computation Theory
145
50 M.-S. Chang, L.-J. Hung, and C.-A. Miau
An induced matching M ⊆ E in a graph G = (V,E) is a matching such that no
two edges in M are joined by any third edge of the graph. The MAXIMUM INDUCED
MATCHING problem is to find an induced matching of maximum cardinality.
MAXIMUM INDUCED MATCHING [20]
Input: A graph G = (V,E).
Output: A vertex set S ⊆ V of maximum cardinality such that the edge set of G[S] is
an induced matching of G.
The problem for finding a maximum r-regular induced subgraph is NP-complete for
any r ≥ 0 [2]. Notice that when r = 0, the MAXIMUM r-REGULAR INDUCED SUB-
GRAPH problem is equivalent to the MAXIMUM INDEPENDENT SET problem. When
r = 1, it is exactly the MAXIMUM INDUCED MATCHING problem.
Known results. The MAXIMUM INDUCED MATCHING problem was introduced by
Stockmeyer and Vazirani [20]. It is NP-complete in general graphs [20]. It is even NP-
complete in bipartite graphs [15], planar graphs [12], r-regular graphs, r ≥ 5, line
graphs and Hamiltonian graphs [13]. This problem can be solved in polynomial time
for trees [8, 21], chordal graphs [3], weakly chordal graphs [4], HHD-free graphs [14],
and 2P3-free graphs [16]. The MAXIMUM INDUCED MATCHING problem is W[1]-
hard in general graphs [18] and is FPT in planar graphs [17,6,11]. Binkele-Raible et al.
showed that the problem to compute the upper irredundance number can be reduced to
solve the MAXIMUM INDUCED MATCHING problem in bipartite graphs [1]. They gave
a fixed-parameter algorithm running in time O∗(1.69563k) for solving the MAXIMUM
INDUCED MATCHING problem in bipartite graphs where k denotes the number of ver-
tices to be deleted for obtaining an induced matching [1]. The MAXIMUM INDUCED
MATCHING problem is APX-hard even on 4r-regular graphs for r ≥ 1 [10, 5]. Gupta
et al. gave an o(2n) time algorithm for solving the MAXIMUM r-REGULAR INDUCED
SUBGRAPH problem [9]. When r = 1 (Maximum Induced Matching Problem), the
running time of the algorithm is O∗(1.6957n).
In this paper, we show that the MAXIMUM INDUCED MATCHING problem can be
reduced to the MAXIMUM INDEPENDENT SET problem. This implies that one can take
advantage of exact algorithms for solving the MAXIMUM INDEPENDENT SET problem
to solve the MAXIMUM INDUCED MATCHING problem. Moreover, we design a branch-
and-reduce algorithm for the MAXIMUM INDUCED MATCHING problem. For solving
the problem more efficiently, we combine the branch-and-reduced algorithm and an
exact algorithm for solving the MAXIMUM INDEPENDENT SET problem together to
obtain an exact algorithm running in time O∗(1.4786n). This paper is organized as
follows. In Section 2, we define some notation and show that the MAXIMUM INDUCED
MATCHING problem can be reduced to the MAXIMUM INDEPENDENT SET problem.
In Section 3, we give a branch-and-reduce algorithm running in time O∗(1.5099n) for
the MAXIMUM INDUCED MATCHING problem. Finally, we present a more efficient
algorithm running in time O∗(1.4786) in Section 4.
2 Preliminaries
In this paper, we use a modified O-notation, O∗ to bound the running time of expo-
nential time algorithms asymptotically. For functions f and g, f(n) = O∗(g(n)) if
f(n) = O(g(n) · poly(n)) where poly(n) is a polynomial [7].
52 M.-S. Chang, L.-J. Hung, and C.-A. Miau
Definition 1. For a graph G = (V,E), L(G) = (E,E′), with for (u, v), (x, y) ∈ E,
(u, v) = (x, y), ((u, v), (x, y)) ∈ E′ if and only if u = x or u = y or v = x or v = y,
is called the line graph of G.
Definition 2. Let G = (V,E) be a graph and L(G) = (E,E′) be the line graph of G.
Define L2(G) = (E,E′′) to be the square graph of L(G), i.e.,
E′′ = E′ ∪ {(e1, e2) | e1, e2 ∈ E, dL(G)(e1, e2) = 2}.
Lemma 1. Let G = (V,E) be a graph and H = (E,E′) = L2(G) be the square
graph of the line graph of G. Then M is an induced matching of G if and only if M is
an independent set of H .
Proof. Suppose that M is an induced matching of G. Then all edges in G[M ] have no
common endvertices and there is no edge in G incident to any two vertices in V (M).
Thus M forms an independent set in H . Conversely, suppose that I is an independent
set in H . Notice that every vertex in H represents an edge in G. Since no two vertices
in I are adjacent in H , by definition their corresponding edges, say (u, v) and (x, y),
in G satisfy that u = x, u = y, v = x, and v = y, and dL(G)((u, v), (x, y)) > 2, i.e.,
(u, x), (u, y), (v, x), (v, y) ∈ E. Thus I is an induced matching in G. This completes
the proof. unionsq
3 A Branch-and-Reduce Algorithm
We present a branch-and-reduce algorithm for the MAXIMUM INDUCED MATCHING
problem and analyze the running time of the algorithm using the number n of vertices
in the input graph as the size of the input.
For simplicity, we denote the size of a maximum induced matching of an undirected
graph G by mim(G). When the algorithm puts a vertex v into the solution set, we say
that it selects v. When the algorithm decides that a vertex v is not in the solution set, we
say that it discards v. Before we present the algorithm, we define a rule called Standard
Branching Rule: When the algorithm applies this rule, it selects a vertex v of degree
d and recursively solves d + 1 MAXIMUM INDUCED MATCHING problems on graphs
Gi = G \ Ui, respectively, where 1 ≤ i ≤ d + 1, N(v) = {u1, u2, . . . , ud}, U1 = {v}
and for i ≥ 2, Ui = N [{v, ui−1}]. And then
mim(G) = max{mim(G1), max
2≤i≤d+1
(2 + mim(Gi))}.
In the first branch of standard branching rule, it discards v. In each of the other branches,
it selects v and a neighbor u and discards N({v, u}). We give the following observa-
tions. Due to the space limitation, some proofs are omitted.
Lemma 2 (Disconnected Rule). If G is disconnected and C is a component of G, then
mim(G) = mim(G[C]) + mim(G \ C).
Lemma 3 (Isolated-Vertex Rule). Let v be an isolated vertex of G. Then v is not in
any solution of the MAXIMUM INDUCED MATCHING problem. That is mim(G) =
mim(G \ {v}).
54 M.-S. Chang, L.-J. Hung, and C.-A. Miau
Proof. There are three cases, both v and z are discarded; only one of v and z is selected;
or both v and z are selected. Let S be an optimal solution that selects v and discards z.
It is easy to see that a vertex x ∈ N(v) \ {z} must be selected in S, otherwise S is not
optimal. Thus we obtain that S ∪ {z} \ {x} is also an optimal solution. This shows that
if an optimal solution selects one of v and z, it selects both of them. Thus either both v
and z are discarded or both v and z are selected. This completes the proof. unionsq
Lemma 10 (Domination Rule). Let v be a vertex of G and u be a neighbor of v with
N [u] ⊂ N [v]. Then there is a solution of the MAXIMUM INDUCED MATCHING prob-
lem that either v is discarded or both v and u are selected from G. That is
mim(G) = max{mim(G \ v), 2 + mim(G \N [v])}.
Proof. Suppose that S is an optimal solution that v is selected and vertex x ∈ N(v) \
{u} is the vertex matched with v. We see that S ∪ {u} \ {x} is a solution of the same
size. Thus there is a solution of the MAXIMUM INDUCED MATCHING problem that
either v is discarded or both u and v are selected. This completes the proof. unionsq
Lemma 11 (Degree-Two Vertex Rule 1). There is a degree-two vertex z in G satisfy-
ing the condition that the degree of one of its two neighbors is two and the degree of
the other neighbor is at least three. Let x ∈ N(z) that deg(x) = 2 and v ∈ N(z) that
deg(v) ≥ 3. Then either both x and z are selected or v and p, p ∈ N(v), are selected.
That is
mim(G) = max{2 + mim(G \ (N [x] ∪N [z])), 2 + max
U∈U
(mim(G \ (N [U ])}
where U = {{v, p} | p ∈ N(v)}.
Proof. If v is discarded from G, then (z, x) is a degree-one edge. We may applied
degree-one edge reduction rule to select both z and x. Thus, if v is selected, then there
is an optimal solution that also selects one neighbor of v. This completes the proof. unionsq
Lemma 12 (Degree-Two Vertex Rule 2). There is a degree-two vertex z in G satisfy-
ing the condition that the degree of its two neighbors is at least three. Let x, v ∈ N(z)
that deg(x) ≤ deg(v). Then either all vertices in N [z] are discarded, or both x and z
are selected, or v and p, p ∈ N(v), are selected. That is
mim(G) = max{mim(G \N [z]), 2 + max
U∈U
(mim(G \ (N [U ])}
where U = {{x, z}} ∪ {{v, p} | p ∈ N(v)}.
Proof. If v is discarded from G, then z is a degree-one vertex. We may apply degree-one
vertex rule to discard both z and x or select both z and x. Conversely, if v is selected,
then there is an optimal solution that also selects one neighbor of v. This completes the
proof. unionsq
The description of the algorithm consists of a sequence of cases and subcases. To avoid
a confusing nesting of if-then-else statements let us use the following convention: The
first case which applies is used in the algorithm. Thus, inside a given case, the hypothe-
ses of all previous cases are assumed to be false. The following algorithm computes for
a given graph G = (V,E) the maximum size of an induced matching.
56 M.-S. Chang, L.-J. Hung, and C.-A. Miau
N(v)}. The worst case happens when degree of v is three. The branching vector is
(3, 5, 5, 5, 5) and its branching number is 1.4336.
Note that for any d ≥ 3 there is at most one d-regular graph assigned to a
node of the search tree from the root to a leaf, since every instance generated by
the algorithm is an induced subgraph of the input graph of the original problem.
Hence any branching rule applied to d-regular graphs, for some fixed d, can only
increase the number of leaves by a multiplicative constant. Hence we may neglect
the branching rules needed for d-regular graphs in the time analysis. Therefore we
neglect the case when G is 3-regular. If G is not 3-regular and the maximum degree
is three, then one of the above rules applies. In the following rules, we may assume
that the maximum degree of the input graph is at least four.
12. Maximum-Degree Rule. Let v be a vertex of maximum degree of G. In this
case we apply Standard Branching Rule. With simple calculations we see that
the worst case happens when the degree of v is four. The branching vector is
(1, 6, 6, 6, 6) and its branching number is 1.5099 in this case.
Theorem 1. The MAXIMUM INDUCED MATCHING problem can be solved in time
O∗(1.5099n).
Proof. The worst case happens when the Maximum-Degree Rule is applied on graphs
of maximum degree four and its branching number is 1.5099. Thus the running time of
the branch-and-reduce algorithm is O∗(1.5099n). unionsq
4 A More Efficient Algorithm
In this section, we give a more efficient algorithm for solving the MAXIMUM INDUCED
MATCHING problem by adding a new rule called Sparse Graph Rule as the boundary
condition of the algorithm. If the input graph does not satisfy the boundary condition,
a rule in the branch-and-reduce algorithm given in Section 3 must be applied. We have
the following algorithm.
1. Apply reduction rules: (i) Isolated-Vertex Rule, (ii) Isolated-Edge Rule, (iii) Dis-
connected Rule, (iv) False-Twin Rule, (v) Degree-One Edge Rule, if one of them is
applicable
2. Sparse Graph Rule. |E| ≤ 2.044 × |V |. In this case, we construct H = L2(G)
and compute α(H) where α(H) is the size of a maximum independent set in H .
By Lemma 1, mim(G) = 2× α(H).
3. Degree-One Vertex Rule. The worst branching vector is (2, 4) and its branching
number is 1.2721.
4. True-Twin Rule. The worst branching vector is (2, 4) and its branching number is
1.2721.
5. Domination Rule. The worst branching vector is (1, 4) and its branching number
is 1.3803.
6. Degree-Two Vertex Rule 1. The worst branching vector is (4, 5, 5, 5) and its branch-
ing number is 1.3413.
58 M.-S. Chang, L.-J. Hung, and C.-A. Miau
10. Hosono, K.: Induced forests in trees and outerplanar graphs. Proceedings of the Faculty of
Science of Tokai University 25, 27–29 (1990)
11. Kanj, I., Pelsmajer, M.J., Schaefer, M., Xia, G.: On the induced matching problem. Journal
of Computer and System Sciences 77, 1058–1070 (2011)
12. Ko, C.W., Shepherd, F.B.: Bipartite domination and simultaneous matroid cover. SIAM Jour-
nal on Discrete Mathematics 16, 327–346 (2003)
13. Kober, D., Rotics, U.: Finding maximum induced matching in subclasses of claw-free and
P5-free graphs, and in graphs with matching and induced matching of equal maximum size.
Algorithmica 37, 327–346 (2003)
14. Krishnamurthy, C.M., Sritharan, R.: Maximum induced matching problem on hhd-free
graphs. Discrete Applied Mathematics 160, 224–230 (2012)
15. Lozin, V.V.: On maximum induced matchings in bipartite graphs. Information Processing
Letters 81, 7–11 (2002)
16. Lozin, V.V., Mosca, R.: Maximum regular induced subgraphs in 2P3-free graphs. In: Theo-
retical Computer Science (2012), doi:10.1016/j.tcs.2012.06.014
17. Moser, H., Sikdar, S.: The parameterized complexity of the induced matching problem in
planar graphs. Discrete Applied Mathematics 157, 715–727 (2009)
18. Moser, H., Thilikos, D.M.: Parameterized complexity of finding regular induced subgraphs.
Journal of Discrete Algorithms 7, 181–190 (2009)
19. Robson, J.M.: Algorithms for maximum independent sets. Journal of Algorithms 7, 425–440
(1986)
20. Stockmeyer, L.J., Vazirani, V.V.: NP-completeness of some generalizations of the maximum
matching problem. Information Processing Letters 15, 14–19 (1982)
21. Zito, M.: Linear time maximum induced matching algorithm for trees. Nordic Journal of
Computing 7, 58–63 (2000)
出國報告
赴德國 RWTH Aachen University
移地研究成果報告
服務機關:弘光科技大學資訊工程系
姓名職稱: 張貿翔特聘教授、洪綾珠博士
派赴國家: RWTH Aachen University, Germany
出國期間: 102年 7月 6日至
102年 7月 14日
Figure 1: RWTH Aachen University資訊科學系系館入口。 攝影: 洪綾珠
我們在過去三年期間, 在這兩個問題上發表過四篇論文 [1, 2, 3, 4], 利用分支與化
約(branch and reduce) 的技巧設計出解決最大有限分支度一集合問題 (maximum
bounded-degree-1 set problem) 的演算法, 並利用衡量征服法 (measure and con-
quer)分析它,得到這個演算法所需的時間為O∗(1.4831n)。 在最大導出配對問題 (max-
imum induced matching problem) 上, 我們也設計了一個分支與化約演算法, 其執
行時間為O∗(1.4786n)。
在本次移地研究期間,透過和 Rossmanith教授團隊密集討論,我們獲得以下成果:
• 設計出解決最大有限分支度一集合問題 (maximumbounded-degree-1 set prob-
lem)的正確解演算法,其執行時間為 O∗(1.4742n)
• 設計出解決最大導出配對問題 (maximum induced matching problem)的正
確解演算法,其執行時間為 O∗(1.4602n)
我們這次所改進的演算法, 尚未利用衡量征服 (measure and conquer) 的分析方
法, 如能利用衡量征服 (measure and conquer) 的方法套用在分析我們的演算法上,
可望得到我們演算法執行時間是O∗(cn), c < 1.4742 (maximum bounded-degree-1
set problem)或 c < 1.4602 (maximum induced matching problem)。 我們會陸續
整理這些結果,並撰寫成論文格式,投稿到國際研討會或期刊上。
2
Figure 3: Rossmanith教授在家撰寫在海報紙上的證明, 帶到學校與大家討論。 攝影:
洪綾珠
參考文獻
[1] Maw-Shang Chang, Ling-Ju Hung, Moderately exponential time approx-
imation algorithms for the maximum bounded-degree-1 set problem, in
proceedings of the 30th Workshop on Combinatorial Mathematics and Computa-
tion Theory, pp. 23–30, 2013.
[2] Maw-Shang Chang, Ling-Ju Hung, and Chau-An Miau, An O∗(1.4786n)-
time algorithm for the maximum induced matching problem, Proceedings
of ICS 2012: Algorithms and Bioinformatics Workshop, R. S. Chang, L. C. Jain,
and S.-L. Peng (Eds.): Advances in Intelligent Systems & Application, SIST 20,
pp. 49–58, 2012.
[3] Maw-Shang Chang, Ling-Ju Hung, Ping-Chen Su, Measure and conquer:
analysis of a branch-and-reduce algorithm for the maximum bounded-
degree-1 set problem, in proceedings of the 29th Workshop on Combinatorial
Mathematics and Computation Theory, pp. 136–145, 2012.
[4] Maw-Shang Chang, Ling-Ju Hung, Ping-Chen Su, Exact and fixed-
parameter algorithms for problems related to 2-plex, Proceedings of IC-
SEC 2011, pp. 203–208, 2011.
4
gave a branch-and-reduce algorithm for theMax 1-bds problem and applied
measure-and-conquer approach to show that the running time is O∗(1.4834n).
It was proved that unless P = NP the Max 1-bds problem can not be ap-
proximated to a ratio greater than nǫ−1 in polynomial time for all ǫ > 0 [6].
The model k-plex is defined as a degree based relaxed model for finding
cohesive subgroups in social networks [15]. The Max k-plex problem can
be formulated in 0/1 integer programming [1, 2]. It is shown W[1]-hard with
respect to the parameter s being the size of k-plexes [11]. Some branch-and-
bound algorithms were given for solving the Max k-plex problem based on
different upper bounds and lower bounds found by heuristics algorithms [17,
12]. Some graph editing problems are studied on finding a disjoint union
of k-plexes [10, 5]. Balasundaram et al. [3] referred the Max d-bds problem
as the problem of finding maximum-cardinality co-(d + 1)-plexes. Wu and
Pei [18] gave an algorithm to enumerate all maximal k-plexes.
2 A branching algorithm
We design a simple branching algorithm based on coloring strategy for the
Max 1-bds problem. The algorithm only has two branches, to select a
vertex in the solution set S or to discard a vertex.
Suppose that we are given a four-colored graph G = (V = B ∪W ∪ O ∪
R,E) where B,W,O,R are the sets of vertices colored black, white, orange,
and red, respectively. We say that G is feasible if the following conditions
are satisfied.
(i) At most one of the neighbors of a red vertex is red,
(ii) At least one of the neighbors of an orange vertex is red,
(iii) All white vertices are not adjacent to any red vertices.
(iv) At least a neighbor of a black vertex is not black.
Now we define the Max 1-bds problem on a four-colored graph G.
Max 1-bds problem on four-colored graphs
Input: A feasible four-colored graph G = (V = B ∪W ∪ O ∪R,E).
Output: A vertex set S ⊆ V of maximum cardinality such that R ⊆ S,
S ∩ B = ∅, and S is a bounded-degree-1 set.
Let β(G) denote the size of S.
The description of the algorithm consists of a sequence of cases and sub-
cases. To avoid a confusing nesting of if-then-else statements let us use the
following convention: The first case which applies is used in the algorithm.
2
(a) Color v black. Define the graph obtained from G by recoloring u
black as G′. Then β(G) = β(G′).
(b) Color v red. Define the graph obtained from G by recoloring u
red as G′. Then β(G) = β(G′).
The strategy of choosing a vertex v to branch on is various. For example,
we can choose a white vertex of maximum degree first. If there is no white
vertex, we choose an orange vertex of maximum degree.
Suppose that the branching priority of white vertices is higher than orange
vertices. At some stage the input graph has no white vertices. If the input
graph has no white vertices then the Max 1-bds problem can be reduced to
the maximum independent set problem by the following steps.
• For any red vertex v having more than one orange neighbor, we add
edges between its orange neighbors. Call the new graph G′
• Find a maximum independent set I in G′[O]. Return |R|+ |I|.
3 Expected results
It is easy to see that this branching algorithm runs in time O∗(2n). We
believe that it is possible to prove that the running time of the algorithm is
much better than O∗(2n). The reason is that for a white vertex v has at least
two orange neighbors when selecting v, all its orange neighbors are removed
(colored black). In this case, the branching vector is (1, 3) and the branching
number is 1.4656. So far, we have no idea how to prove it.
The expect results of this project are
• Prove the running time of the coloring branching algorithm.
• Design an algorithm running in time O∗(cn), c < 1.4834, for the Max
1-bds problem.
The Maximum Induced Mathching problem (see the following def-
inition) is similar to the Max 1-bds problem. Suppose that we obtain an
efficient exact algorithm for the the Max 1-bds problem. Can we extend
this algorithm for the Maximum Induced Mathching problem? Note
that the Maximum Induced Mathching problem can be solved in time
O∗(1.4786n) [7]. An induced matching M ⊆ E in a graph G = (V,E) is a
matching such that no two edges in M are joined by any third edge of the
graph.
4
[9] M. R. Fellows, J. Guo, H. Moser, and R. Niedermeier, A generaliza-
tion of Nemhauser and Trotter’s local optimization theorem, Journal of
Computer and System Sciences 77 (2011), pp. 1141–1158.
[10] J. Guo, C. Komusiewicz, R. Niedermeier, and J. Uhlmann, A more
relaxed model for graph-based data clustering: s-plex cluster editing,
SIAM Journal on Discrete Mathematics 24 (2010), pp. 1662–1683.
[11] C. Komusiewicz, F. Hu¨ffner, H. Moser, and R. Niedermeier, Isolation
concepts for efficiently enumerating dense subgraphs, Theoretical Com-
puter Science 410 (2009), pp. 3640–3654.
[12] B. McClosky and I.V. Hicks, Combinatorial algorithms for the maxi-
mum k-plex problem, Journal of Combinatorial Optimization 23 (2012),
pp. 29–49.
[13] H. Moser, R. Niedermeier, and M. Sorge, Exact combinatorial algo-
rithms and experiments for finding maximum k-plexes, Journal of Com-
binatorial Optimization 24 (2012), pp. 347–373.
[14] N. Nishmura, P. Ragde, and D. M. Thilikos, Fast fixed-parameter
tractable algorithms for nontrivial generalizations of vertex cover, Dis-
crete Applied Mathematics 152 (2005), pp. 229–245.
[15] S. B. Seidman and B. L. Foster, A graph-theoretic generalization of
the clique concept, The Journal of Mathematical Sociology 6 (1978),
pp. 139–154.
[16] L. J. Stockmeyer and V. V. Vazirani, NP-completeness of some gener-
alizations of the maximum matching problem, Information Processing
Letters 15 (1982), pp. 14–19.
[17] S. Trukhannov, Novel approaches for solving large-scale optimization
problems on graphs, PhD Thesis, A&M University, Texas, 2008.
[18] B. Wu and X. Pei, A parallel algorithm for enumerating all the maximal
k-plexes, Proceedings of PAKDD 2007, LNAI 4819 (2007), pp. 476–483.
6
出國報告
赴德國 RWTH Aachen University
移地研究成果報告
服務機關:弘光科技大學資訊工程系
姓名職稱: 張貿翔特聘教授、洪綾珠博士
派赴國家: RWTH Aachen University, Germany
出國期間: 102年 7月 6日至
102年 7月 14日
Figure 1: RWTH Aachen University資訊科學系系館入口。 攝影: 洪綾珠
我們在過去三年期間, 在這兩個問題上發表過四篇論文 [1, 2, 3, 4], 利用分支與化
約(branch and reduce) 的技巧設計出解決最大有限分支度一集合問題 (maximum
bounded-degree-1 set problem) 的演算法, 並利用衡量征服法 (measure and con-
quer)分析它,得到這個演算法所需的時間為O∗(1.4831n)。 在最大導出配對問題 (max-
imum induced matching problem) 上, 我們也設計了一個分支與化約演算法, 其執
行時間為O∗(1.4786n)。
在本次移地研究期間,透過和 Rossmanith教授團隊密集討論,我們獲得以下成果:
• 設計出解決最大有限分支度一集合問題 (maximumbounded-degree-1 set prob-
lem)的正確解演算法,其執行時間為 O∗(1.4742n)
• 設計出解決最大導出配對問題 (maximum induced matching problem)的正
確解演算法,其執行時間為 O∗(1.4602n)
我們這次所改進的演算法, 尚未利用衡量征服 (measure and conquer) 的分析方
法, 如能利用衡量征服 (measure and conquer) 的方法套用在分析我們的演算法上,
可望得到我們演算法執行時間是O∗(cn), c < 1.4742 (maximum bounded-degree-1
set problem)或 c < 1.4602 (maximum induced matching problem)。 我們會陸續
整理這些結果,並撰寫成論文格式,投稿到國際研討會或期刊上。
2
Figure 3: Rossmanith教授在家撰寫在海報紙上的證明, 帶到學校與大家討論。 攝影:
洪綾珠
參考文獻
[1] Maw-Shang Chang, Ling-Ju Hung, Moderately exponential time approx-
imation algorithms for the maximum bounded-degree-1 set problem, in
proceedings of the 30th Workshop on Combinatorial Mathematics and Computa-
tion Theory, pp. 23–30, 2013.
[2] Maw-Shang Chang, Ling-Ju Hung, and Chau-An Miau, An O∗(1.4786n)-
time algorithm for the maximum induced matching problem, Proceedings
of ICS 2012: Algorithms and Bioinformatics Workshop, R. S. Chang, L. C. Jain,
and S.-L. Peng (Eds.): Advances in Intelligent Systems & Application, SIST 20,
pp. 49–58, 2012.
[3] Maw-Shang Chang, Ling-Ju Hung, Ping-Chen Su, Measure and conquer:
analysis of a branch-and-reduce algorithm for the maximum bounded-
degree-1 set problem, in proceedings of the 29th Workshop on Combinatorial
Mathematics and Computation Theory, pp. 136–145, 2012.
[4] Maw-Shang Chang, Ling-Ju Hung, Ping-Chen Su, Exact and fixed-
parameter algorithms for problems related to 2-plex, Proceedings of IC-
SEC 2011, pp. 203–208, 2011.
4
gave a branch-and-reduce algorithm for theMax 1-bds problem and applied
measure-and-conquer approach to show that the running time is O∗(1.4834n).
It was proved that unless P = NP the Max 1-bds problem can not be ap-
proximated to a ratio greater than nǫ−1 in polynomial time for all ǫ > 0 [6].
The model k-plex is defined as a degree based relaxed model for finding
cohesive subgroups in social networks [15]. The Max k-plex problem can
be formulated in 0/1 integer programming [1, 2]. It is shown W[1]-hard with
respect to the parameter s being the size of k-plexes [11]. Some branch-and-
bound algorithms were given for solving the Max k-plex problem based on
different upper bounds and lower bounds found by heuristics algorithms [17,
12]. Some graph editing problems are studied on finding a disjoint union
of k-plexes [10, 5]. Balasundaram et al. [3] referred the Max d-bds problem
as the problem of finding maximum-cardinality co-(d + 1)-plexes. Wu and
Pei [18] gave an algorithm to enumerate all maximal k-plexes.
2 A branching algorithm
We design a simple branching algorithm based on coloring strategy for the
Max 1-bds problem. The algorithm only has two branches, to select a
vertex in the solution set S or to discard a vertex.
Suppose that we are given a four-colored graph G = (V = B ∪W ∪ O ∪
R,E) where B,W,O,R are the sets of vertices colored black, white, orange,
and red, respectively. We say that G is feasible if the following conditions
are satisfied.
(i) At most one of the neighbors of a red vertex is red,
(ii) At least one of the neighbors of an orange vertex is red,
(iii) All white vertices are not adjacent to any red vertices.
(iv) At least a neighbor of a black vertex is not black.
Now we define the Max 1-bds problem on a four-colored graph G.
Max 1-bds problem on four-colored graphs
Input: A feasible four-colored graph G = (V = B ∪W ∪ O ∪R,E).
Output: A vertex set S ⊆ V of maximum cardinality such that R ⊆ S,
S ∩ B = ∅, and S is a bounded-degree-1 set.
Let β(G) denote the size of S.
The description of the algorithm consists of a sequence of cases and sub-
cases. To avoid a confusing nesting of if-then-else statements let us use the
following convention: The first case which applies is used in the algorithm.
2
(a) Color v black. Define the graph obtained from G by recoloring u
black as G′. Then β(G) = β(G′).
(b) Color v red. Define the graph obtained from G by recoloring u
red as G′. Then β(G) = β(G′).
The strategy of choosing a vertex v to branch on is various. For example,
we can choose a white vertex of maximum degree first. If there is no white
vertex, we choose an orange vertex of maximum degree.
Suppose that the branching priority of white vertices is higher than orange
vertices. At some stage the input graph has no white vertices. If the input
graph has no white vertices then the Max 1-bds problem can be reduced to
the maximum independent set problem by the following steps.
• For any red vertex v having more than one orange neighbor, we add
edges between its orange neighbors. Call the new graph G′
• Find a maximum independent set I in G′[O]. Return |R|+ |I|.
3 Expected results
It is easy to see that this branching algorithm runs in time O∗(2n). We
believe that it is possible to prove that the running time of the algorithm is
much better than O∗(2n). The reason is that for a white vertex v has at least
two orange neighbors when selecting v, all its orange neighbors are removed
(colored black). In this case, the branching vector is (1, 3) and the branching
number is 1.4656. So far, we have no idea how to prove it.
The expect results of this project are
• Prove the running time of the coloring branching algorithm.
• Design an algorithm running in time O∗(cn), c < 1.4834, for the Max
1-bds problem.
The Maximum Induced Mathching problem (see the following def-
inition) is similar to the Max 1-bds problem. Suppose that we obtain an
efficient exact algorithm for the the Max 1-bds problem. Can we extend
this algorithm for the Maximum Induced Mathching problem? Note
that the Maximum Induced Mathching problem can be solved in time
O∗(1.4786n) [7]. An induced matching M ⊆ E in a graph G = (V,E) is a
matching such that no two edges in M are joined by any third edge of the
graph.
4
[9] M. R. Fellows, J. Guo, H. Moser, and R. Niedermeier, A generaliza-
tion of Nemhauser and Trotter’s local optimization theorem, Journal of
Computer and System Sciences 77 (2011), pp. 1141–1158.
[10] J. Guo, C. Komusiewicz, R. Niedermeier, and J. Uhlmann, A more
relaxed model for graph-based data clustering: s-plex cluster editing,
SIAM Journal on Discrete Mathematics 24 (2010), pp. 1662–1683.
[11] C. Komusiewicz, F. Hu¨ffner, H. Moser, and R. Niedermeier, Isolation
concepts for efficiently enumerating dense subgraphs, Theoretical Com-
puter Science 410 (2009), pp. 3640–3654.
[12] B. McClosky and I.V. Hicks, Combinatorial algorithms for the maxi-
mum k-plex problem, Journal of Combinatorial Optimization 23 (2012),
pp. 29–49.
[13] H. Moser, R. Niedermeier, and M. Sorge, Exact combinatorial algo-
rithms and experiments for finding maximum k-plexes, Journal of Com-
binatorial Optimization 24 (2012), pp. 347–373.
[14] N. Nishmura, P. Ragde, and D. M. Thilikos, Fast fixed-parameter
tractable algorithms for nontrivial generalizations of vertex cover, Dis-
crete Applied Mathematics 152 (2005), pp. 229–245.
[15] S. B. Seidman and B. L. Foster, A graph-theoretic generalization of
the clique concept, The Journal of Mathematical Sociology 6 (1978),
pp. 139–154.
[16] L. J. Stockmeyer and V. V. Vazirani, NP-completeness of some gener-
alizations of the maximum matching problem, Information Processing
Letters 15 (1982), pp. 14–19.
[17] S. Trukhannov, Novel approaches for solving large-scale optimization
problems on graphs, PhD Thesis, A&M University, Texas, 2008.
[18] B. Wu and X. Pei, A parallel algorithm for enumerating all the maximal
k-plexes, Proceedings of PAKDD 2007, LNAI 4819 (2007), pp. 476–483.
6
99 年度專題研究計畫研究成果彙整表 
計畫主持人：張貿翔 計畫編號：99-2221-E-241-015-MY3 
計畫名稱：衡量征服 - 分析分支化約演算法時間複雜度的新方法 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 1 1 30%  
研究報告/技術報告 0 0 100%  
研討會論文 2 2 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 1 1 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
■達成目標 
□未達成目標（請說明，以 100 字為限） 
□實驗失敗 
□因故實驗中斷 
□其他原因 
說明： 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：■已發表 □未發表之文稿 □撰寫中 □無 
專利：□已獲得 □申請中 ■無 
技轉：□已技轉 □洽談中 ■無 
其他：（以 100 字為限） 
本計畫發表三篇學術會議論文，分別發表於： 
Proceedings of ICSEC 2011, pp. 203--208. 
Proceedings of the 29th Workshop on Combinatorial Mathematics and Computation 
Theory, pp. 136-145, 2012. 
Proceedings of ICS 2012: Algorithms and Bioinformatics Workshop, In: R. S. Chang, 
L. C. Jain, and S.-L. Peng (Eds.): Advances in Intelligent Systems & Application, 
SIST 20, pp. 49-58, 2012. 
 
3. 請依學術成就、技術創新、社會影響等方面，評估研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）（以
500 字為限） 
在這三年的研究中,我們設計了分支化約演算法解最大有限分支度一集合問題 (maximum 
bounded-degree-1 set problem)和最大導出配對問題 (maximum induced matching 
problem), 我 們 實 作 出 衡 量 征 服 分 析 分 支 化 約 演 算 法 的 工 具
http://210.240.226.131/qca.php,用這個分析工具來分析我們所設計的演算法,得到最
大有限分支度一集合問題 (maximum bounded-degree-1 set problem)和最大導出配對問
題  (maximum induced matching problem) 可 以 分 別 在 $O^{\ast}(1.4834^n)$ 和
$O^{\ast}(1.4658)$時間被解決。我們將在未來的研究中利用衡量征服 (measure and 
conquer)這個分析工具來分析解決其他問題的分支化約演算法 (branch-and-reduce 
algorithm)。本計畫研究內容與原計畫相符，目前已發表在國際研討會 ICSEC~2011、第二
十九屆組合數學與計算理論研討會和國際研討會 ICS~2012 (詳見附錄),可以說達成預期
目標，研究成果具學術價值，將陸續將其整理成論文發表於國際性學術期刊。 
 
