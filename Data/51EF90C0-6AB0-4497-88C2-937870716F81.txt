tool is provided in ARCATS, which allows randomly walk-
ing in the state space to detect violation of safety properties.
The random walks in state space may not necessarily detect
the violations but if more time is spent, more confidence is
gained.
If the degree of confidence needed is high, results of the
compositional analysis can be used to enhance the simula-
tion coverage. In this phase, ARCATS’s simulation tool can
walk from individual processes (in a form of control flow
graph) into the interface processes which represent the ob-
servational behaviors of a subsystem. In principle, the walk
into the states of an interface process is equivalent to the
walk of states in a subsystem. In a subsystem, many inter-
nal states are of no interests to the subsystem’s environment.
As a result, the depths or steps to find the violations can be
reduced. Much more confidence can be gained from the
simulation.
In this paper, the techniques in each phase will be de-
scribed respectively.
2. Architecture and Meta Data Structure of
ARCATS
ARCATS consists of a set of tools. These tools read and
write files to communicate and cooperate. Fig. 1 shows the
overall architecture of ARCATS. ARCATS starts with input
languages on the top. Currently, ARCATS support Promela,
SPIN’s modeling language, as input language. In the future,
it is planned to support Java-like modeling language. The
boxes in gray color are the tools of ARCATS.
The parser to parse a Promela file is called a ADT-
promela parser. ADT stands for Abstract Data Type. More
higher level language constructs such as queue and set are
supported by ADT-Promela to address the automatic refac-
toring problem[2].
2.1 Control Flow Graph
The most important files generated by the language
parsers are the control flow graph (CFG) files. One CFG
file will be generated for each process/thread specified in
input files. Each directed edge is attached with an abstract
syntax tree (AST) of the statement that makes the transi-
tion. The statement AST may contain variables or constant.
Their types or values can be referred by the symbol tables,
which are also generated by the parsers.
The CFG is meant to be executable. Tools like simu-
lation engine may set up a symbol table and work as an
interpreter to run the CFG. When a CFG edge is executed,
the statement’s AST is evaluated and variables in the sym-
bol table are modified. A statement in CFG can be a reg-
ular statement or a communication/synchronization state-
ment. Statements such as assignment statements are regular
Figure 1. The architecture of ARCATS.
statements. Their executions only change the values of vari-
ables in symbol table. A communication/synchronization
statement involves interactions across processes/threads. In
Promela, a communication/synchronization statement is ei-
ther “ch?msg” or “ch!msg”, where ’ch’ is a channel name,
’msg’ is the message to be transmitted, ’?’ stands for re-
ceiving end, and ’!’ stands for sending end. When these
statements are evaluated, the simulator establishes a chan-
nel data structure in the symbol table and shares it between
processes.
This statement AST, unfortunately is language depen-
dent, but the CFG execution algorithms should be language
independent. Some object-oriented efforts have been made
to address the extension and evolution problem.
2.2 CCS State Graph
Control flow graph can not be used as a formalism for
verification. A control flow graph is still equivalent to a
program. The behaviors are still parameterized by vari-
ables. Verification relies on some forms of communication
finite state machines such as CCS [11] or CSP. In ARCATS,
Minler’s CCS (with two-way rendezvous synchronization)
is adopted.
In a CCS state graph, an edge label is a constant label
called action which is paired with another constant label in
other processes. Two paired labels are denoted by a and a¯
in CCS. When two paired actions are fired in two processes,
they communicate. CCS’s synchronization is equivalent to
cess in the incremental analysis. Besides, the processes in a
component must not yield intractable analysis. Otherwise,
we need to recursively divide the component into smaller
loosely coupled components until every subsystem in the
composition hierarchy can be analyzed. However, an ideal
structure like that seldom exists in practice. Designers of-
ten structure their systems to meet other requirements with
higher priority. It is impractical to ask designers to struc-
ture a design in the beginning for the purpose of obtaining
correctness.
If it is difficult to prove the correctness of a program un-
der its original design, one may need to prove the correct-
ness on a transformed, equivalent version of the program.
This is a notion known as program transformation, which
has been widely studied in the area of functional and logic
languages. In object-oriented design, the “refactoring” is
a technique which gradually change the system structure
through refactoring steps but without destroying original
program behaviors.
Here, we apply the idea to transform finite-state models
to aid automated finite-state verification. In general, the pur-
pose of our transformations is for obtaining, starting from
a model P , a semantically equivalent one, which is “more
amenable to compositional analysis” than P . It consists in
building a sequence of equivalent models, each obtained by
the preceding ones by means of the application of a rule.
The rules are aimed for restructuring the as-built structures
which are not suitable for compositional techniques. The
goal is to obtain a transformed model whose structure con-
tains loosely coupled components, where processes in each
component do not yield state explosion.
In this subsection, we use a simple example to briefly
show how refactoring is generally work. In Fig. 2(a) and
Fig. 2(b), we show the state graphs of three example pro-
cesses X,Y, and S in CCS semantics [11] (where synchro-
nization actions are matched in pairs) and their synchroniza-
tion structure. Such kind of structure, a star-shape structure,
appears very often in practice, for example, a stateful server
which communicates with clients via separate (or private)
channels. Many systems can even have structures of multi-
ple stars.
We say S is tightly coupled to its environment (which
consists of X and Y) because it has complicated interfaces
to its environment. Suppose S is a server and X,Y are clients.
Image the number of clients is increased to a larger number.
Any attempt to include S as a subsystem is bound to fail
because of the complicated interfaces to its environment.
That is, no feasible subsystems and composing hierarchies
exist in this structure, particularly when client number is
large.
The key transformations are to decompose centralized,
complicated behaviors of a process into several small new
processes while behavioral equivalence is preserved. In [3],
Figure 2. (a) A simple example with 3 pro-
cesses X, Y, and S. (b) The synchronization
structure of the example.
we described the basic tool support1 for refactoring and
showed that a refactored elevator system can be analyzed
up to hundreds of elevators but global analysis and com-
positional analysis (without refactoring) can only analyze
up to 4 elevators. A refactored Chiron user interface sys-
tem can be analyzed up to 14 artists (17 processes in total),
whereas non-refactored one can only be analyzed up to 2
artists (5 processes in total).
For instance, we show the refactored X,Y, and S in Fig.
3(a) and the new synchronization structure in Fig. 3(b). In
Fig. 3(a), the behaviors related to channel x (or to process
X) is removed and wrapped into a new process Sx. Sim-
ilarly, the behaviors related to channel y is removed and
wrapped into a new process Sy. So, the rendezvous of x!a,
x!c, and x!d are now redirected to Sx. However, Sx and Sy
are now two individual processes which can execute con-
currently, but their original joint behaviors in S can not. So,
extra synchronizations (e!lock and e!release) are inserted
to maintain behavioral equivalence; that is, before invoking
x!a and y!a, X and Y are forced to invoke e!lock first. Then,
at the end of Sx and Sy, e!release is used to free S.
The idea of refactoring equivalence is easy to explain.
Let’s image the modified processes (X,Y, and S) are con-
tained in a black box. Image you are an external observer of
the black box. The external behaviors of the black box are
defined by z!b and w!b. In Fig. 2(b), the black box (which
1The tool support can successfully refactor many systems in an auto-
mated fashion, particularly the behavioral patterns which do not involve
complicated data structures.
Figure 5. The average depth of deadlock de-
tection using simulation and compositional
analysis.
visiting the deadlock states. When a deadlock state is vis-
ited, the steps (depth) of this walk is recorded. We let the
simulation run for 10 times and then compute the average
depth.
In Fig. 5, the example has 100 philosophers. The Y-Axis
is the average depth for the simulation to visit the deadlock
states. The X-axis is the degree of compositional analysis.
For example, degree is 5 means 50% of the philosophers
and chopsticks are composed into a subsystem. When there
are no compositional analysis, average depths in 10 times
run is close to 800. When the degree of compositional anal-
ysis is increased, the average depths of random walk de-
creased significantly. As a result, the time spent to detect
the deadlock is also reduced proportional to this declining
rate.
3.6 Simulation + Compositional Analysis + Refac-
toring
When the as-built architecture of a system does not con-
tain good subsystems to be used for the combined approach,
refactoring again can come into play. However, refactoring
modify the communication structure of the system at the
CCS levels but CFG remains in the as-built architecture.
Many problems need to be solved. This is not yet a sup-
ported phase. It is a future research.
4. Discussions and Conclusions
The worst-case complexity of reachability analysis is P-
SPACE hard. In general, any approaches that attempt to
analyze the whole system at once (a.k.a., global analysis)
may only work for systems of small scale or of a partic-
ular class. To increase the scalability of verification tech-
niques for industrial usage, pragmatic approaches such as
the multi-phased solutions combined with compositional
analysis and simulation have been proposed. From one
phase to next phase, however, properties of interest may
be compromised. For example, absence of deadlock can
be compromised into high confidence in absence of dead-
lock. This confidence can be increased by investing more
time in simulation, which is a practical and commonly used
approach in hardware industry.
In the future, ARCATS plans to automate the transition
from one phase to another and produce warnings to explain
how properties of interest are compromised so that a tool
user does not need to take care the manual steps between
phases. To achieve this goal, much work remains to be
done. Hopefully, a practical verification tool can be pro-
duced from ARCATS’s research results in the foreseeable
future.
References
[1] A. Bouali and R. de Simone. Symbolic bisimulation mini-
mization. In Fourth Workshop on Computer-Aided Verifica-
tion, Volumne 663 of LNCS, pages 96–108. Springer-Verlag,
1992.
[2] Y.-P. Cheng. Crafting a promela front-end with abstract data
types to mitigate the sensitivity of (compositional) analysis
to implementation choices. In LNCS, volume 3639, pages
139–153, 2005.
[3] Y.-P. Cheng, M. Young, C.-L. Huang, and C.-Y. Pan. To-
wards scalable compositional analysis by refactoring design
models. In Proceedings of the ACM SIGSOFT 2003 Sym-
posium on the Foundations of Software Engineering, pages
247–256, 2003.
[4] S. C. Cheung and J. Kramer. Context constraints for compo-
sitional reachability analysis. 5(4):334–377, October 1996.
[5] E. R. Gansner, E. Koutsofios, S. C. North, and K.-P. Vo. A
technique for drawing directed graphs. IEEE Transactions
on Software Engineering, 19(3):214–230, 1993.
[6] P. Godefroid, D. Peled, and M. Staskauskas. Using partial-
order methods in the formal validation of industrial concur-
rent programs. In Proceedings of 1996 International Sympo-
sium on Software Testing and Analysis, pages 261–269, San
Diego, California, USA, January 1996.
[7] S. Graf and B. Steffen. Compositional minimization of fi-
nite state systems. In Proceedings of the 2nd International
Conference of Computer-Aided Verification, pages 186–204,
1990.
[8] G. J. Holzmann. Design and Validation of Computer Proto-
cols. Prentice-Hall, Englewood Cliffs, NJ 07632, 1991.
[9] G. J. Holzmann. The model checker SPIN. Software Engi-
neering, 23(5):279–295, 1997.
[10] K. L. McMillan. Symbolic model checking. Kluwer Aca-
demic Publishers, Massachusetts, 1993.
[11] R. Milner. A Calculus of Communicating Systems, vol-
ume 92. New York, 1980.
[12] W. J. Yeh and M. Young. Compositional reachability analy-
sis using process algebra. pages 49–59, Oct. 1991.
