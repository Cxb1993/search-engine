these organizations are both blessings and curses. On 
the one hand, the huge amount of data 
and the powerful computer technologies make these 
databases potential resources for research and 
living improvements； on the other hand, the 
vulnerability and seriousness of these sensitive data
seriously threaten human privacy. Therefore, we aim 
to provide a solution for balancing data sharing and 
data privacy through secure computation technology. 
The ultimate goal of this research is to implement a 
platform, that allows multi-party secure 
computations. 
      In this research, we have achieved developed a 
series of protocols for commonly used operations, 
such  as  function calls, fixed loop expressions, 
branch expressions, arithmetic expressions, logic 
operations, comparison operations, shifting 
operation, rotate operation, and a number of  
protocols for statistical evaluation. The performance 
and the complexity of the protocol suite is also 
measured and analyzed in detail. Also by using 
exponentiation protocol as an example, we 
demonstrated the balance between privacy and 
performance. 
       The practicality of our platform are 
demonstrated by applications in collaborated 
computation between government bureaus and also in 
privacy-preserving collaborative recommender systems.
        In the course of our research, we have came 
across a lot practical applications that require 
computations in real numbers, but current methods are 
mainly based upon integer computations. Therefore, we 
have also made some initial investigation into secure 
computation with floating point numbers. 
英文關鍵詞： secure multi-party computation, scalar product, 
empirical study 
 
	
BBBBBB	ABCDADCEFCABACCCEDAFCEAFCE
AEC	ABCFEDCECEB	EDDEBCEBCFEEA
C	ECBCEFCEFBCEACA	FAEBCEEA
AA	AAEAEBCECCCA
CEA CAECAABE!ACAAFCACD
ACEDBCFEBACCFCAECEBDCEEEBA
	AFEC	FA"CACEA	AEAECACDA	
ECEAFAE	BEDCEFCEC	CCADCEABA
EAAE	BECBEBCFCABACCFCCDEEB
CFFADCEFCF#EBEBCFCA
BBBBBBAEEB	B		CECDECCBCDCEBCFFCA
CECABDABCABDCCECAEABECAEFB
ECACBCECABCFECACECADACECAECCECAA
AFECDECCBCDCEB	CAEDCEFABABCFCDECCBC
CFEAA A$CACAACAECCBCAF
FCAEABAE	BAEDCEFAB
BBBBBBBEBBCDCEDCEFEFCAEBCAABCCE
BCFCAAC	EAFAEACAE	B#EE	ABCCE	
EBCFFAEF
BBBBBBBBABCECDCEEEB	BFBECCEBBBCAE%E
BCFCAAEAFEBEEAFCEFACAAEBCFCA
EDCE	CFCFAA	CAACBEBCFCADCACA
AFE
	ABCADCEFFABDCFFABEACBFADBEAFC
BBBBBBBBBBB
öp7p÷;øùú²û üý9:cæþÿ2
@B7.
B
BBBBQ§ÿðÐp2àá	½ïiÕÒF§¶é2
BBBBg§%R" $%:igÿºìÎÄÉíÄ»½¿½ÄÌî`t=CÄÂ9
:kls²tÉ;%ó$%:iÿºhgklÿ	Aÿ9
:cæÔÿA7óWã56ïmBBgF*vdÞR"g§~h
gA~C4$ÆF*DEF9:Fkl2BhIklOfFhg	
±¡g§~F JKfh2
BBBB)g%R" CÈPÂs ÿF$%:iÈà
á	iÕÿ5BÐJKð+Ôëz·,f012)g§ÿvºW
`R"süfçaHqÔUóÇÑ+fðõ`àå/2(F
ÒC4ÆÎÄÉÉÆÃÎÆvºPÈá×*õöL2
R"f7.ÞNs«A
{sAg§%R"F§ï|}W$%:iàÿºUÈ
W9:c ¨Õ©«2%éï§Ù!àá	½ïF§ÒÓÔ¶
"g{sp/g#i§$%a%6&2
gF*vd%R"A~$ÆDE'Bkl¢%dï§
Ù!ÿð(Ðpàá	½ï¶éyÚd'B$Æ
DE9:µ¶%é2
P{sÔWï$%:i§|}f(aC8]NØ hï(|{
§Ù¥)Þ|}2g³	|}àCa·,f0
12
sAg§%R"F§ï|}W$%:iàÿºUÈ9:
òc 2PÂR" aïc ÿº|WÈ¢9:cîÔ*n»I±¡W	
±¡s²tÉ;+8ô*n»I±¡	Aÿº|ÿC»ÇÔc 2
gF*vdA~$ÆDE'BklR" {ØVdhgW,2hb
ï|E{sÚ-.C4JKÙ¥)7,¥¦v2Ðg_`R
"ðòðÈ2
P{sÔ$%:i§|}òJKÙ¥f/: #0ð§|}2
ghb|}W~R"õö ðõï1ÞUð 2
2
sAg§%R"F§ï|}W$%:iàÿºUÈW9:
c ïQc N	±¡f»I3aÙ ]2s²tÉR"c{I34¥
ÕBüýþï|}W9:cæÿF%R"NgÞ	%A
BBBBìîBABCfDEcCF*Fïg%F*3CÞ
B7fF*FJ_ç2
B B B ìÕî B   %   R "   : i     íÃ½ÍÅÎíÃÆ»ÆÃÍ½ÌÏBÎÄ  Å!ÄÃÅ¿½ÍÆB
ÃÆÎÄÉÉÆÌ"ÆÃB»»¿ÆÉ»2
s]W½¼y
BBBgs|}~OP§òQ¥Ù2gh4R"#ðõ
´$ûgð%´~)#C§È'ûg´ð%´³ïÛsÒR
STTUï#&VW2OPð%´:iX§g
§fð(~'Cp	ýþYR"U-P{%6ò{I0Eà7v;Þ4
gZ[./%ì¾ ÄÅ¿½ÌÏBíÄ½Ì¿BÌËÉ!ÆÃ»îòïð%ì#´ïyz¢ó¼\]
'Ð^ywjø___­ª©zBï`a2#CKáÂ"CN%bÛìcé
ìÃÅ¿½ÄÌÅ »î @ ­  / ì cé ì¾½ÊÆ"BíÄ½Ì¿BÌËÉ!ÆÃ»î f  % ì cé ì ÄÏÅÃ½¿¼É½ÎB
ÃÆíÃÆ»ÆÌ¿Å¿½ÄÌîH)hI%égdÙ@BbÔ@jÙH%é'3./%ìcé2
ÕWà:i%´fòï/g¢~./%´àáW
2P{#yÒ0t#ïºJW%éO./%÷ï8%à%ÿ2
yà¡e{Z[./%gça~"37ðõÔ)g6 
ðR"gça~LLf}óYð./%aÙ[Ú2
ê{IÈ´;'þìÉÆÅÌî5>g%ìÍÅÃ½ÅÌÎÆî@fÍÙhaBì ½ÌÆÅÃB
ÃÆÏÃÆ»»½ÄÌîHù./%´BbÔfça2hI%×òï{=2çaH
{Ö×2
QJ5\]iàìJ5Ì5BÐji?2
²@Bv§ÿ>
BBBB:i´gÒ*õöp7p÷k¢gjlfmnY&oh
b#pp	2Q§ð(h	8%6º q$
ïÒR[\Rr N%6faÙ2
BBBBh¼)	y²t	F*çaSo_`cî8!9:2RY*s6t
u)<=v)8!äÞWwpïtu)<={LÚxÛsU9:äy>P+z
{R"CDE|9:W}â2_`¡~üï~z)¢Ö
QW	×ïÚWF2gEFWF*wCÚr²tDEcCF*R"
aïEcCF*3UC_`oa7fF*FJ_ç2hI
aCóLÞ2áÂgmn´fl¥¦WKÞR"
#t gN\F*´F_`cC9:%ô2
390ACA-4<+$3//'***4CFE+CB
&''(AA-A,B$2E	B#EE	ABCCE	BAA
$4+$4./'12ECBACD'9$AA4CFE+BE$BCA4CADEAB
'/37''/ACA-4<+$3//'***4CFE+CB
&'3(AA-ADEADA=ABCAEBDECAE	A4)2
.'>12ECBACD***AEACABCADEABCA2E	BBEAFAA
'75-EAE$E$E3//3$EA4CFE+CBAB
&'0(AA-ADEADA$EBBECBCC	BEF#EBCFCA
ECFA:+2./312ECBACD3//3CECCA:BEEF
'397'0?:;CE:;<+$3//3$4,2E
&'>(,EAAA,C;AFECDBEEBCFAA2ECBA
CD+%AB,CA4CFFABCA+BEA4CFE+BAB'888
&'?()CECAAEC,B!)AA)A+FD	AD#EBFE
BCFCABCACECBECEA2!-4.8512ECBACD
	AAAA$4,FCFCA2EABCDEBCFA'/'7'''
:;CE:;<+$'885$4,
&'6(!CEB+	C,BA$	ECACCC$:;FAFA+!4
.5912ECBACD:AA$AA$4,+FCFCACECD4CFA
3'57338:;CE:;<+$'859$4,2E
&'9(A#+AC4EA#BAAA-#A$CBFCDCEE	BECBCA
A+4./'12ECBACD>AEACA4CADEABCAADCEFCA+BE
''/7'3>ACACA<@3//'+EAE#FE
1Towards Empirical Aspects of
Secure Scalar Product
I-Cheng Wang, Chih-hao Shen, Justin Zhan, Tsan-sheng Hsu, Churn-Jung Liau, and Da-Wei Wang
Abstract—There is a fair amount of research about privacy,
but few empirical studies about its cost have been conducted. In
the area of secure multiparty computation, the scalar product has
long been reckoned as one of the most promising alternatives to
classic logic gates. The reason for this is that the scalar product
is not only complete, which is as good as logic gates, but also
much more efficient than logic gates. As a result, we set out to
study the computation and communication resources needed for
some of the most well-known and frequently referenced secure
scalar-product protocols, including the composite-residuosity, the
invertible-matrix, the polynomial-sharing, and the commodity-
based approaches. In addition to the implementation details
of these approaches, we analyze and compare their execution
time, computation time, and memory and random number
consumption. Moreover, Fairplay, the benchmark approach that
implements Yao’s circuit evaluation protocol, is also included in
our experiments in order to demonstrate the potential for the
scalar products to replace logic gates.
Index Terms—Secure multiparty computation, composite resid-
uosity, scalar product, empirical survey.
I. INTRODUCTION
THE core issue of secure multiparty computation is howpotentially distrustful parties can cooperate to conduct
certain computations over their private data without compro-
mising their privacy. After Yao’s [1] first general solution to
secure two-party computation, Goldreich et al. [2] gave the
first general solution to secure multiparty computation. Both
proposals provide secure two-party/multiparty protocols for
binary AND and XOR gates, which can be further generalized
to all computable functions. However, despite their academic
significance, the computation costs of both solutions are too
prohibitive to be practical.
A function f is complete if a secure protocol for f implies
the existence of secure protocols for all functions. Yao and
Goldreich et al. propose the idea for solving the secure
multiparty computation problem by giving secure protocols for
complete functions. Extended from the idea, the scalar product
has gathered more and more attention because of its complete-
ness and integer-based computing power. To demonstrate this
completeness, we show that scalar product is more powerful
than the oblivious transfer, which is the complete function
adopted in Goldreich et al.’s solution. Recall that there is a
sender and a receiver in the oblivious transfer. The sender has
a set of numbers [x1, . . . , xn] and is willing to reveal only
one of them to the receiver, while the receiver has the index i
indicating exactly which number he wants. After the receiver
transforms his input from a single index number i to a 1× n
This work was conducted while I-Cheng Wang and Chih-hao Shen visited
Carnegie Mellon University, CyLab Japan.
vector that has most elements zero and the i-th element one,
the oblivious transfer is reduced to scalar product problem. As
a result, not only is the scalar product at least as powerful as
the oblivious transfer, it is also proven to be complete.
Moreover, proposals for the secure scalar product are plen-
tiful. Du and Zhan [3] proposed the invertible-matrix and
the commodity-based approaches. While the former approach
enables the tradeoff between efficiency and privacy, the latter
is based on Beaver’s commodity model [4]. Goethals et
al. [5] proposed the computationally secure scalar-product
protocol, the security of which depends on the intractability
of the composite residuosity class problem. The information-
theoretically secure polynomial-sharing approach proposed
by Ben-Or et al. [6] is also one of the most significant
solutions. Furthermore, Fairplay [7], the benchmark approach
implementing Yao’s circuit based solution, is also included in
our experiments in order to evaluate the performance of all
the aforementioned solutions.
Despite the mass of secure scalar-product protocols, few
empirical studies have been conducted. Numerous approaches
propose the feasibility of secure scalar product, but to construct
a practical application for secure multiparty computation, the
execution and CPU time is crucial. The typical issues that we
may have are as follows:
1) What is the exact execution time for high-dimensional
inputs? How long does it take to compute the 100, 1000,
or 10000 dimensional scalar products?
2) If the approach is computationally secure, what is its
throughput under the typical security parameters (e.g.
1024-bit composite numbers)?
3) If the approach is theoretically secure, there must be a
third party. What is the workload of the third party?
4) What is the performance of a specific approach com-
pared with Fairplay?
In this work, we implement the four most frequently refer-
enced secure scalar product protocols, including the invertible-
matrix, the composite-residuosity, the polynomial-sharing, and
the commodity-based approaches. With our results, application
developers can implement secure protocols painlessly, and
protocol designers can estimate the performance of their
scalar-product-based designs more precisely.
This paper is organized as follows: Section II discusses the
related works. Section III briefly introduces the mentioned
approaches realizing secure scalar-product computation. Sec-
tion IV then gives implementation remark and analyzes the
resources needed for each approach, including computation
cost, memory complexity, and random number consumptions.
After that, Section V shows the specific data about the total
3D. Composite-residuosity Approach
The composite-residuosity approach utilizes Paillier’s cryp-
tosystem [19]. The cryptosystem not only has the additive
homomorphism, it is also easy to multiply in the encrypted
domain. As a result, the scalar product, which is composed
of addition and multiplication, can be straightforwardly im-
plemented upon the Paillier cryptosystem.
Key Generation:
1) Alice generates two large primes p and q. She then
computes m = p · q and λ = lcm(p− 1, q − 1).
2) Alice randomly selects g ∈ Z∗m2 such that
gcd(L(gλ mod m2),m) = 1,
where L(u) = u−1
m
, ∀u ∈ {u < m2|u = 1 mod m}.2
3) Alice publicizes (m, g) as the public key and keeps
(p, q, λ) secret as the private key.
Protocol:
1) Alice randomly selects ri ∈ Z
∗
m2 and computes
cAi = g
xAi · rmi mod m
2, for i = 1, . . . , n.
Then Alice sends [cA1 , . . . , cAn ] to Bob.
2) Bob randomly selects his output yB(0 ≤ yB < m) and
computes cB = g
m−yB mod m2.
3) Bob computes the scalar product in encrypted domain
by t =
(∏n
i=1 c
xBi
Ai
)
· cB mod m
2 and sends t to Alice.
4) Alice computes her output yA by
yA =
L(tλ mod m2)
L(gλ mod m2)
mod n.
E. Fairplay
Fairplay includes a compiler that automatically converts
a program written in a high-level language into a secure,
constant-round, two-party protocol proposed by Yao [1]. In
the Fairplay approach, Bob first generates k different garbled
circuits computing the same function described by the input
program and sends all the garbled circuits to Alice. Then Alice
chooses one of the circuits and asks Bob to reveal the rest of
the circuits in order to reduce the risk of being cheated. After
oblivious transfer protocols with Bob for the inputs, Alice can
evaluate the chosen garbled circuit by herself and eventually
get the function result.
Circuit Generation: Every computable function can be
converted into a circuit, and the circuit is composed of logic
gates, the input-output relation of which can be represented
by a truth table. After every wire is given two random bit-
strings representing its 0 and 1 value, and truth-table outputs
are garbled after being encrypted by their corresponding input
bit-strings, the logic gate becomes a garbled gate, and the
circuit becomes a garbled circuit.
1) Bob converts the scalar product into a circuit.
2) For each circuit wire wi, Bob randomly generates two
l-bit strings w0i and w
1
i representing 0 and 1 of wi.
2It is proven that gλ = 1 mod m, for any g ∈ Z∗
m2
, thus the input to
function L in Step 2. of key generation is always valid.
3) For each gate Gi,j of input wires wi and wj , the
output wire wk, and the truth table fi,j(·, ·), the gate
is encrypted such that
E(Gi,j) =


Ew0
i
(Ew0
j
(w
fi,j(0,0)
k ))
Ew0
i
(Ew1
j
(w
fi,j(0,1)
k ))
Ew1
i
(Ew0
j
(w
fi,j(1,0)
k ))
Ew1
i
(Ew1
j
(w
fi,j(1,1)
k ))


,
where Ex(y) is y’s ciphertext encrypted with the key x.
Oblivious Transfer: After Bob generates the garbled circuits
and Alice verifies the correctness of the circuit, Alice needs the
bit-strings for input wires that are known to Bob exclusively.
For the bit-strings representing Bob’s own inputs, he can give
them to Alice without revealing his inputs. However, Alice
does not know her input bit-strings, and neither is she willing
to reveal her inputs to Bob. Therefore, they collaboratively
execute the oblivious transfer so that Alice can have her
input bit-strings from Bob obliviously. Two approaches are
implemented in Fairplay, and we introduce the efficient one
proposed by Naor and Pinkas [20].
1) Alice and Bob agree on a large prime p and an integer
g < p as the group generator.
2) Bob chooses integer C, r ∈ Zp, publicizes C, and
computes Cr and gr.
3) For every bit σ of Alice’s input, assuming σ is the j-th
wire wj of the circuit, repeat Step 4 to 6:
4) Alice randomly generates k ∈ Zp, computes PKσ = g
k
and PK1−σ = C ·PK
−1
σ , and then sends PK0 to Bob.
5) After receiving PK0, Bob computes
M0 = H(PK
r
0)⊕ w
0
j
M1 = H(PK
r
1)⊕ w
1
j = H(C
r · (PK−10 )
r)⊕ w1j
where H(·) is a random oracle function implemented
with the SHA-1 hash function, and ⊕ is the bit-wise
XOR operation. Then (gr,M0,M1) is sent to Alice.
6) Alice computes wσj = Mσ ⊕H((g
r)k).
Circuit Evaluation: Since Alice now has a garbled circuit
computing the scalar product and bit-strings representing both
Alice’s and Bob’s inputs, she can evaluate the circuit alone.
The evaluation is in the order such that only the correct output
bit-strings will be deciphered, and the output bit-strings of
current gates will be the input bit-strings to the next gates until
the final outputs come out. Though Alice has the intermediate
bit-strings, she cannot get extra information from them because
the semantics of these bit-strings are exclusive to Bob.
IV. ANALYSIS AND IMPLEMENTATION
Secure protocols are usually designed in an ideal case or
under certain assumptions. To implement a protocol in the
real world, the situation is no longer ideal, and neither are the
assumptions easily satisfied. In this section, we list potential
obstacles during the implementation of secure scalar-product
protocols and propose feasible solutions. At the end of this
section, the summary of the analysis is presented.
5E. Fairplay
Fairplay system includes a compiler that automatically
converts an SFDL3 program into a secure, constant-round,
two-party protocol proposed by Yao [1]. More specifically,
Bob generates a garbled circuit, and then Alice evaluates it
according to Yao’s circuit evaluation protocol, the security of
which depends on the underlying cryptosystem. In the case of
Fairplay, the SHA-1 hash function is adopted for encryption
and decryption. However, because of the implementation limit,
Fairplay cannot generate a garbled circuit that correctly han-
dles integers of more than 32 bits, and neither can it compile
a scalar-product program with input vectors of more than 70
dimensions on the Java Virtual Machine of 1GB heap size. An
“OutOfMemoryException” will be thrown.
Finally, we summarize the analysis in Table I for better
readability. Note that even the composite-residuosity approach
is on the same complexity order as the commodity-based
and polynomial-sharing approaches, the computationally in-
tractable nature of the composite-residuosity approach, e.g. big
integer requirement, always results in a large constant factor
in their complexity. The disadvantage of the computational
approach will be later illustrated in our experiment results.
V. EXPERIMENTAL RESULTS
According to the instructions elaborated in Section III, we
implement all the aforementioned approaches in Ruby (1.8.6)
programming language. Not only is Ruby well-supported on
the functionalities we need, Ruby has shortened the devel-
opment cycle so that various ideas can be realized efficiently.
Nonetheless, while Fairplay is an existing system implemented
in Java, one may attribute the outperformance of our scalar-
product-based proposal to the advantage of the implementation
method. In fact, this really is not the case since Ruby codes,
as an interpreted language, run slower than Java programs,
compiled language. In other words, the superiority of our
proposals over Fairplay could have been even more significant.
In our experiments, we have two machines, the specifi-
cations of which are an AMD Opteron 2.8 GHz processor
with 4GB DDR2 RAM and an Intel Xeon 3.0 processor with
4GB DDR2 RAM. To minimize the probabilistic variation
and to balance the different computing power, our experiment
results are the average of 50 effective executions. An effective
execution is the average of two protocol executions, each of
which has Alice’s code run on different machines and Bob’s
code run on the other. Our experiments focus on different
resources for secure multiparty computation: random number
consumption, execution time, and CPU time. Note that the
execution time and the CPU time are the aggregation results
by summing up Alice’s and Bob’s execution and CPU time.
Limited by Fairplay’s 32-bit precision, we define D as
the finite field GF (231 − 1) for the invertible-matrix, the
commodity-based, and the polynomial-sharing approaches. For
the composite-residuosity approach, we define D as the ring
3Secure Function Definition Language is a programming language defined
in Fairplay system. The language intends for end users to program their
applications with high-level descriptions.
100 101 102 103 104 105
0
0.5
1
1.5
2
2.5
3
3.5
4 x 10
6
Vector Dimension
R
an
do
m
 B
it 
Co
ns
um
pt
io
n 
(bi
t)
 
 
Fairplay Res. Poly. & Comm.
Fig. 1. Random number consumption: the labels “Res.”, “Poly.”, and
“Comm.” indicate the composite-residuosity, the polynomial-sharing, and the
commodity-based approaches respectively. The invertible-matrix approach is
not included because of its deterministic nature.
Zm, where m = (2
521 − 1)(2607 − 1).4 Moreover, the
experiment inputs to five approaches are all randomly selected
from GF (231− 1), and the possible overflow is ignored since
we care about execution time solely.
A. Random Number Consumption
We first compare the random number consumption between
Fairplay and the aforementioned approaches. Fig. 1 shows
the random bits used by different approaches. Recall that in
Fairplay the scalar product is compiled into a garbled circuit
composed of logic gates and wires. Each wire needs two 80-
bit random strings representing 0 and 1 value. Therefore, the
curve of Fairplay comes from the function F (n) = 160 ·f(n),
where f(n) is the number of wires of the n-dimensional scalar-
product circuit produced by Fairplay compiler. The curve of
the composite-residuosity approach comes from the function
R(n) = 1128 · (2n + 1), where 1128 is the bit length of m,
2n accounts for n random numbers ri ∈ Z
∗
m2 , and 1 comes
from the randomly chosen yB ∈ Zm. Similarly, the curve of
the polynomial-sharing and the commodity-based approaches
comes from the function P (n) = 31 · (2n+ 1).
B. Different Invertible Matrices
Fig. 2 shows the results of the invertible-matrix approach
with different invertible matrices. It seems that the protocols
with normal nonsingular matrices are about one order of
magnitude better than those with invertible Vandermonde
matrices in efficiency, but it is difficult for the former to
compute the scalar product of more dimensions than 215 on
our machines because of its O(n2) space complexity. To
adopt the identity matrix, the invertible-matrix approach is
equivalent to that Alice and Bob disclose half of their secrets to
each other. Obviously, with the identity matrix, the invertible-
matrix approach is very efficient, albeit revealing half the
secrecy. However, with other nonsingular matrices, the entropy
is reduced to half, but none of the secrets is clearly disclosed.
4For simplicity purpose, we use Mersenne primes 231 − 1, 2521 − 1, and
2607 − 1 in our experiments.
7100 102 104 106
0
20
40
60
80
100
120
Vector Dimension
To
ta
l E
xe
cu
tio
n 
Ti
m
e 
(se
c.)
 
 
Fairplay Res. Inv. Poly. Comm.
(a) Execution time comparison
100 102 104 106
0
20
40
60
80
100
120
Vector Dimension
To
ta
l C
PU
 T
im
e 
(se
c.)
 
 
Res. Inv. Poly. Comm.
(b) CPU time comparison
Fig. 3. The labels “Res.”, “Inv.”, “Poly.”, and “Comm.” stand for the composite-residuosity, the invertible-matrix, the polynomial-sharing, and the commodity-
based approaches respectively. The composite-residuosity and the invertible-matrix approaches spend most of the time in CPU computing whereas the
commodity-based approaches have significant efforts in communication.
[6] M. Ben-Or, S. Goldwasser, and A. Wigderson, “Completeness theorems
for non-cryptographic fault-tolerant distributed computation,” in STOC
’88: Proceedings of the Twentieth Annual ACM Symposium on Theory
of Computing. New York, NY, USA: ACM Press, 1988, pp. 1–10.
[7] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella, “Fairplay — a secure
two-party computation system,” in Proceedings of the 13th Symposium
on Security, Usenix, 2004, pp. 287–302.
[8] J. Kilian, “Founding crytpography on oblivious transfer,” in STOC ’88:
Proceedings of the twentieth annual ACM symposium on Theory of
computing. New York, NY, USA: ACM, 1988, pp. 20–31.
[9] ——, “A general completeness theorem for two party games,” in STOC
’91: Proceedings of the twenty-third annual ACM symposium on Theory
of computing. New York, NY, USA: ACM, 1991, pp. 553–560.
[10] W. Du, “A study of several specific secure two-party computation
problems,” Ph.D. dissertation, Purdue University, August 2001.
[11] M. J. Atallah and W. Du, “Secure multi-party computational geometry,”
Lecture Notes in Computer Science, vol. 2125, pp. 165–179, 2000.
[Online]. Available: citeseer.ist.psu.edu/du01secure.html
[12] W. Du and M. J. Atallah, “Privacy-preserving cooperative statistical
analysis,” in ACSAC ’01: Proceedings of the 17th Annual Computer
Security Applications Conference. Washington, DC, USA: IEEE
Computer Society, 2001, pp. 102–110.
[13] ——, “Privacy-preserving cooperative scientific computations,” in
CSFW ’01: Proceedings of the 14th IEEE workshop on Computer
Security Foundations. Washington, DC, USA: IEEE Computer Society,
2001, p. 273.
[14] P. Bunn and R. Ostrovsky, “Secure two-party k-means clustering,” in
CCS ’07: Proceedings of the 14th ACM conference on Computer and
communications security. New York, NY, USA: ACM, 2007, pp. 486–
497.
[15] Y.-T. Chiang, D.-W. Wang, C.-J. Liau, and T.-S. Hsu, “Secrecy of two-
party secure computation,” Lecture Notes in Computer Science, vol.
3654, pp. 114–123, 2005.
[16] D.-W. Wang, C.-J. Liau, Y.-T. Chiang, and T.-S. Hsu, “Information theo-
retical analysis of two-party secret computation,” Data and Applications
Security XX, Lecture Notes in Computer Science, vol. 4127, pp. 310–
317, 2006.
[17] C.-H. Shen, J. Zhan, D.-W. Wang, T.-S. Hsu, and C.-J. Liau,
“Information-theoretically secure number-product protocol,” 2007 Inter-
national Conference on Machine Learning and Cybernetics, vol. 5, pp.
3006–3011, 19-22 Aug. 2007.
[18] O. Goldreich, Foundations of Cryptography, Volumne II Basic Applica-
tions, 1st ed. Cambridge University Press, 2004.
[19] P. Paillier, “Public-key cryptosystems based on composite degree resid-
uosity classes,” Advances in Cryptology–EUROCRYPT’99, 1999.
[20] M. Naor and B. Pinkas, “Efficient oblivious transfer protocols,” in
SODA ’01: Proceedings of the twelfth annual ACM-SIAM symposium
on Discrete algorithms. Philadelphia, PA, USA: Society for Industrial
and Applied Mathematics, 2001, pp. 448–457.
[21] L. R. Turner, “Inverse of the vandermonde matrix with applications,”
Glenn Research Center, NASA, Tech. Rep. NASA-TN-D-3547, Aug
1966.
I-Cheng Wang received a B.S. in computer science
and information engineering from National Taiwan
University in 2005. Since December 2007 he joined
the Institute of Information Science, Academia
Sinica, Taiwan as a research assistant. His research
interests include security, financial computation and
applied economics.
Chih-hao Shen is a PhD student of the Computer
Science Department at the University of Virginia.
He received a B.S. and a M.S. degree of Computer
Science in 2002 and 2004 respectively both from
National Taiwan University. His research interests
are theory of computer science and cryptography.
His current research is mainly focus on the secure
computation.
Justin Zhan is a faculty member at Carnegie Mellon
University and a research leader at privacy, security,
social computing and cyber-physical systems re-
search group. His research interests include Informa-
tion Privacy, Security, Trust, and Risk, Social Com-
puting, Service Computing, Data Mining, Cyber-
Physical Systems, etc. He is a founding steering
chair of IEEE International Conference on Social
Computing (SocialCom), IEEE International Confer-
ence on Privacy, Security, Risk and Trust (PASSAT),
and International Symposium on Cyber-Physical In-
telligence (CPI). He has been the editor-in-chief of International Journal of
Mathematics and Statistics. He is currently an editor-in-chief of International
Journal of Privacy, Security and Integrity and International Journal of Social
Computing and Cyber-Physical Systems.
An Empirical Study on Privacy and Secure
Multi-party Computation using Exponentiation
I-Cheng Wang∗, Chih-Hao Shen†, Kung Chen‡, Tsan-sheng Hsu∗, Churn-Jung Liau∗, and Da-Wei Wang∗
Institute of Information Science,
Academia Sinica, Taiwan
Email: {icw, tshsu, liaucj, wdw}@iis.sinica.edu.tw∗
Department of Computer Science,
University of Virginia, USA
Email: shench@email.virginia.edu†
Department of Computer Science,
National Chengchi University, Taiwan
Email: chenk@cs.nccu.edu.tw‡
Abstract—Protocols for secure multi-party computation allow
participants to share a computation while each party learns only
what can be inferred from their own inputs and the output of the
computation. However, the execution time of a secure protocol
may be too high so that it is not practical unless some tradeoffs
being made between data access and confidentiality. This paper
aims to provide some empirical basis for making such tradeoffs
in computing exponentiation. We design exponentiation protocols
for secure two-party computation using scalar products as the
basic building blocks. A detailed performance evaluation was
carried out by taking advantage of the compositional nature
of our protocols. We come up with a time function which
provides good prediction of the execution time of the proposed
exponentiation protocols based on the execution time of scalar
products. Using the time function, we obtain several interesting
tradeoffs between execution time and privacy. In particular,
compromising some private information enables a reduction in
the execution time from years, if not centuries, to days or
even minutes. Based on our results, we argue that there are
indeed reasonable tradeoffs between privacy and execution time.
Furthermore, our study indicates that a system intelligently
offering users possible tradeoff options will make secure multi-
party computation a more attractive approach to enhance privacy
in practice.
I. INTRODUCTION
In reality, privacy cannot be absolute. Other values, includ-
ing security and social welfare, compete with it. Therefore,
compromise has to be made. In the report [1], the data access
and confidentiality tradeoff is well articulated. The value of
data-intensive research is highly variable, and it is impossible
to specify a universally applicable optimal tradeoff between
privacy and data access. The report calls for the development
of tools that, on a case-by-case basis, would increase data
access without compromising data protection or conversely,
increase confidentiality without compromising data access.
Our goal is to develop such tools via protocols for secure
multi-party computation (SMC).
Loosely speaking, SMC involves computing functions with
inputs from two or more parties in a distributed network while
ensuring that no additional information, other than what can be
inferred from each participant’s input and output, is revealed to
parties not privy to that information. In this paper, we present
a protocol that computes the exponentiation–one of the most
important functions in mathematics–in a two-party setting. In
the development of this protocol, we used a compositional
approach with the scalar product protocols serving as building
blocks. The research of Shen et al. [2] demonstrated that we
can use scalar products as building blocks for SMC. A full
description of these scalar-product protocols along with a time
complexity analysis can be found in the technical report [3].
Based on the performance data of our protocol, we argue
that the tradeoff between confidentiality and execution time
is a real issue by demonstrating various tradeoff points of
the exponentiation. The performance data shows that it might
either take a very long time or not even be possible to keep
both the base and the exponent values absolutely secret and
complete the computation. Revealing some information about
the base and/or the exponent allows the computation to be
completed in radically different time bounds. Our protocol
was carefully implemented, and furthermore, a thorough per-
formance evaluation was carried out to ensure the accuracy of
these results.
The paper is organized as follows. We give a short review
of related works in Section II. In Section III, notations and
the scalar-product based specifications are described in detail.
Next, Section IV lists several scenarios of SMC in which
the exponentiation had concrete tradeoffs between privacy and
efficiency. Besides that, the experimental results and how to
estimate the time cost for each scenario or each of our protocol
are shown here as well. Finally, we conclude this paper and
lay out the future work in Section V.
does not come until after computation is completed. It is
unnecessary to combine intermediate variables.
As far as we know, there is no systematic approach to con-
struct all computable functions directly from scalar products.
Hence we specified some more building blocks to facilitate
solving more SMC problems. In the remainder of this section,
we summarize the specifications of those building blocks that
we will employ to develop protocols for exponentiation. The
readers are referred to [25] for the details of those building
blocks.
Specification 3.2 ({k′} Zn-to-Z2): Party 1 and Party 2
share a number in Zn, and they want to securely convert
the Zn sharing into bitwise Z2 sharing. More specifically,
Party 1 and Party 2 want to collaboratively execute the secure
protocol (x1, x2){k′} 7→ ((y01 , . . . , yk
′
1 ), (y
0
2 , . . . , y
k′
2 )) such
that (yk
′
yk
′−1 · · · y1y0)2 = x1 +x2, where n = 2k+1, k′ ≤ k,
x1, x2 ∈ Zn, yi1, yi2 ∈ Z2, and yi = yi1 + yi2 (mod 2), for
i = 0, 1, · · · , k′.
Specification 3.3 ({k′} Z2-to-Zn): Party 1 and Party 2
share a number in Z2, and they want to securely convert
the bitwise Z2 sharing into the Zn sharing. More specif-
ically, the two parties want to execute the secure proto-
col ((x01, . . . , x
k′
1 ), (x
0
2, . . . , x
k′
2 )){k′} 7→ (y1, y2) such that
y1 + y2 = (x
k′xk
′−1 · · ·x1x0)2, where n = 2k+1, k′ ≤ k,
y1, y2 ∈ Zn, xi1, xi2 ∈ Z2, and xi = xi1 + xi2 (mod 2), for
i = 0, 1, · · · , k′.
Specification 3.4 (Product): Party 1 and Party 2 share the
multiplicand and the multiplicator. They want to securely
execute the protocol ((x1, y1), (x2, y2)) 7→ (z1, z2) such that
z1 + z2 = (x1 + x2)(y1 + y2).
Specification 3.5 (If-Then-Else): Party 1 and Party 2 ad-
ditively share the predicate, IF-clause value, and the ELSE-
clause value. They want to securely execute the protocol
((b1, x1, y1), (b2, x2, y2)) 7→ (z1, z2) such that
z1 + z2 =
{
x1 + x2 if b1 + b2 = 1,
y1 + y2 if b1 + b2 = 0.
Here, we introduce the Square protocol, which is very
similar to the Product protocol specified in [25] and employs
the same strategy, namely dividing the computation into the
part which can be done individually and the rest which must
be performed collaboratively. However, the Square protocol
reduces the dimension of the scalar product from two to one.
Specification 3.6 (Square): Party 1 and Party 2 share a
number in Zn, and they want to collaboratively execute the
secure protocol (x1, x2) 7→ (y1, y2) such that y1 + y2 =
(x1 + x2)
2.
The protocol details are as follows:
PROTOCOL Square
1) Party 1 and Party 2 jointly execute the Scalar Product protocol
(x1, x2) 7→ (t1, t2) such that t1 + t2 (mod n) = x1 · x2.
2) Party j individually computes yj = x
2
j + 2tj , for j = 1, 2.
We view the Product, Square, {k′}Zn-to-Z2, and {k′}Z2-
to-Zn as primitive building blocks while the If-Then-Else is
a useful building block based on primitive ones. Since every
building block is composed of other ones and based on the
Scalar Product, Table I lists the constituents of these building
blocks. We further break those constitutive building blocks in
Table I into Scalar Product protocols of which Table II shows
the domain, dimension, and times.
Protocol Domain Constituents Times
Product Zn Scalar Product 1
Square Zn Scalar Product 1
{k′}Zn-to-Z2 Z2 Scalar Product k
′
{k′}Z2-to-Zn Zn Scalar Product 1
If-Then-Else Zn Product 1
TABLE I
CONSTITUENTS OF PROTOCOLS
Protocol Domain Dimension Times
Product Zn 2 1
Square Zn 1 1
{k′}Zn-to-Z2 Z2 3 k
′
{k′}Z2-to-Zn Zn k
′ + 1 1
If-Then-Else Zn 2 1
TABLE II
THE COMPLEXITY OF PROTOCOLS
IV. EXPONENTIATION AND PERFORMANCE EVALUATION
In order to show tradeoffs between privacy and efficiency,
in this section we take the exponentiation f(x, y) = xy
as a concrete example, list possible tradeoffs, analyze the
information leaking out according to publicized variables,
present the experimental results, and estimate the time cost
for each tradeoff helping make a reasonable tradeoff decision.
Party 1 and Party 2 share the base x and the exponent y.
Let the positive integers nx and ny be the range of x and the
range of y respectively, where x < nx ≤ n, y < ny ≤ n,
nx = 2
kx+1, ny = 2
ky+1, and kx, ky ∈ N. As we can see
in the discussion below, if tighter bounds are/is known for x
and/or y, i.e., nx and/or ny are/is much smaller than n, the
execution time needed would be much smaller. We argue that
in cases where the users know or can derive tighter upper
bounds for x and/or y due to the nature of the problem, and
this knowledge can greatly improve computational efficiency.
In some other cases, we envision that the computational cost
is prohibitively high, so that the parties would agree to reveal
some information about x and/or y in order to get the results
in reasonable time. Nielsen and Schwartzbach define three
variable types which are secret, public, and private [26].
Here we only define two variable types: secret and public.
The secret type of variable indicates the value of which is
shared between Party 1 and Party 2 , while the public type
of variable means the value of which resides in plain view on
these two parties. For simplicity, hereafter we set sb = secret
base, se = secret exponent, pb = public base, and pe = public
exponent.
5) Party j individually sets v1j = Xj , for j = 1, 2.
6) For i = 1, 2, · · · , k, repeat from Step 6a to Step 6d.
a) The two parties jointly execute the Square proto-
col (vi1, v
i
2) 7→ (v
i+1
1 , v
i+1
2 ) such that v
i+1
1 +
vi+12 (mod n) = (v
i
1 + v
i
2)
2.
b) The two parties jointly execute the Product proto-
col ((ui1, v
i
1), (u
i
2, v
i
2)) 7→ (w
i
1, w
i
2) such that w
i
1 +
wi2 (mod n) = (u
i
1 + u
i
2)(v
i
1 + v
i
2).
c) Party 1 and Party 2 jointly execute the {0}Z2-to-Zn
protocol (bi1, b
i
2) 7→ (d
i
1, d
i
2) such that (b
i)2 = d
i
1 + d
i
2,
where di1, d
i
2 ∈ Zn, b
i
1, b
i
2 ∈ Z2, and b
i = bi1 +
bi2 (mod 2).
d) The two parties jointly execute the If-Then-Else protocol
((di1, w
i
1, u
i
1), (d
i
2, w
i
2, u
i
2)) 7→ (u
i+1
1 , u
i+1
2 ) such that
u
i+1
1 +u
i+1
2 (mod n) =
{
wi1 + w
i
2 if d
i
1 + d
i
2 = 1,
ui1 + u
i
2 if d
i
1 + d
i
2 = 0.
7) Party j individually sets zj = u
k+1
j , for j = 1, 2.
For some other situations where either the value of x or y
can be revealed completely, we can then take full advantage
of it and have much faster protocols.
1) Exp(pb x, se) ∈ Zxn : Since the base resides in plain
view on these two parties as x and the exponent is still
securely shared in Zn, the answer of x
y is in Zxn . We
can omit the step transforming the base from Zn shares
to Zxn ones. At the same time, securely executing the
Square protocol for x2 is not necessary anymore.
2) Exp(sb, pe y) ∈ Zny : Since the exponent resides in
plain view on these two parties as y and the base is
still securely shared in Zn, the answer of x
y is in Zny .
Party 1 and Party 2 can individually transform y to
a bit string. Details of this protocol are provided as
followings.
Specification 4.3 (Exp(sb, pe y) ∈ Zny ): Party 1 and
Party 2 share the base while the exponent is public. They
want to securely execute the protocol (x1, x2){y} 7→
(z1, z2) such that z1 + z2 = (x1 + x2)
y, where z1, z2 ∈
Zny .
PROTOCOL Exp(sb, pe y) ∈ Zny
a) Party 1 and Party 2 collaboratively execute the {k}Zn-
to-Z2 protocol followed by the {k}Z2-to-Zny protocol,
(x1, x2) 7→ ((e
0
1, . . . , e
k
1), (e
0
2, . . . , e
k
2)) 7→ (X1, X2),
where X1 + X2 (mod n
y) = x1 + x2 (mod n).
b) Party 1 and Party 2 individually turn the public exponent
y from Zn into Z2 such that (b
ky bky−1 · · · b1b0)2 =
y, where ky = blog2 yc, y ∈ Zn, b
i ∈ Z2, for i =
0, 1, · · · , ky.
c) Party 1 sets u11 = b
0X1 + (1 − b
0), while Party 2 sets
u12 = b
0X2, such that
u
1
1 + u
1
2 (mod n
y) =
{
X1 + X2 if b
0 = 1,
1 if b0 = 0.
It is clear from the context that + represents addition in
Zny .
d) Party j individually sets v1j = Xj , for j = 1, 2.
e) For i = 1, · · · , ky , repeat Step 2(e)i and Step 2(e)ii.
i) The two parties jointly execute the Square pro-
tocol (vi1, v
i
2) 7→ (v
i+1
1 , v
i+1
2 ) such that v
i+1
1 +
vi+12 (mod n
y) = (vi1 + v
i
2)
2. It is clear from the
context that + represents addition in Zny .
ii) If bi = 1, the two parties jointly execute the Product
protocol ((ui1, v
i
1), (u
i
2, v
i
2)) 7→ (u
i+1
1 , u
i+1
2 ) such
that ui+11 + u
i+1
2 (mod n
y) = (ui1 + u
i
2)(v
i
1 + v
i
2).
If bi = 0, Party j individually sets ui+1j = u
i
j , for
j = 1, 2. It is clear from the context that + represents
addition in Zny .
f) Party j individually sets zj = u
ky+1
j , for j = 1, 2.
There are other tradeoffs. For example, keep the exponent in
shares; at the same time reveal the base and the upper bounds
of the exponent. Or on the one hand, keep the base in shares;
on the other hand, disclose both the exponent and the upper
bounds of the base. The former and the latter are represented
as Exp(pb x, se, ny) ∈ Zxny and Exp(sb, pe y, nx) ∈ Znxy
respectively.
1) Exp(pb x, se, ny) ∈ Zxny : This is quite the same
as Exp(pb x, se) ∈ Zxn except the domain of the
computation reduced from Zxn to Zxny .
2) Exp(sb, pe y, nx) ∈ Znxy : This one is supposed have
better performance than Exp(sb, pe y) ∈ Zny since the
domain of the computation reduced from Zny to Znxy .
Then we enumerate two situations which may indirectly
disclose some information.
1) Exp(pb x, se) ∈ Zn: Once the base x is not a secret and
the answer of xy is guaranteed in Zn, the range of y is
no longer in n but limited to logx n, if x 6= 1.
xy < n ⇒ y < logx n.
2) Exp(sb, pe y) ∈ Zn: Much the same, when it comes to
a public exponent y and a guaranteed answer in Zn, the
range of x is constrained to b y√nc rather than supposed
n.
xy < n ⇒ x < b y√nc.
Note that hereafter in this paper, we present the worst cases
of those protocols with pe. More specifically, we view every
bit of the public exponent y as 1. That is y = 2ky+1−1, where
ky = blog2 yc. We break the aforementioned exponentiation
protocols into their constitutive building blocks of which
Table III lists the domain and times. Based on Table I and
Table II, we further break the constitutive building blocks of
those exponentiation protocols in Table III into Scalar Product
protocols of which Table IV lists the domain, dimension, and
times. More other protocols and details are in [3].
No doubt, there are tradeoffs between privacy and efficiency.
Nevertheless, making an adequate decision is never an easy
task without more evidence. Below we provide methods esti-
mating the time cost for each protocol based on Scalar Product.
We adopt the secure scalar product protocol that Du and
Zhan proposed, namely, commodity-based approach [9], which
is based on Beaver’s commodity model [10]. This approach
has extraordinary performance among several secure scalar
product ones, though a neutral third party, the commodity
server, is needed [12]. We implemented this scalar product pro-
tocol and all of our building blocks in Ruby(1.8.6 patchlevel
111). Table V shows the environment of our experiments. To
minimize the probabilistic variation, our experimental results
Dimension
k 1 2 3 4 5 8 16 32
0 0.0027 0.0028 0.0035 0.0029 0.0030 0.0030 0.0033 0.0037
15 0.0028 0.0029 0.0029 0.0029 0.0030 0.0030 0.0033 0.0038
255 0.0028 0.0030 0.0031 0.0031 0.0032 0.0031 0.0035 0.0042
4095 0.3099 0.3098 0.3099 0.3100 0.3099 0.3100 0.3106 0.3111
65535 1.0598 1.0599 1.0618 1.0627 1.0726 1.0612 1.0604 1.0612
131071 4.2073 4.2026 4.2080 4.2186 4.2222 4.2114 4.2212 4.2219
262143 16.9002 16.8916 16.8791 16.8730 16.9086 16.8971 16.8941 16.8636
TABLE VI
THE TIMINGS(SECONDS) OF THE COMMODITY-BASED SCALAR PRODUCT PROTOCOL WITH DIFFERENT k AND DIFFERENT DIMENSIONS
k 12 15 17 19 20 22 24
Exp(sb,se) ∈ Znn 2minutes 3 hours 3 days 2months 1 year 2 decades 4 centuries
Exp(sb,se,nx) ∈ Znxn 45 seconds 58minutes 21 hours 20 days 1 season 5 years 1 century
Exp(pb x,se) ∈ Zxn 22 seconds 28minutes 10 hours 9 days 1month 2 years 5 decades
Exp(pb x,se,ny) ∈ Zxny 11 seconds 13minutes 5 hours 4 days 25 days 1 year 3 decades
Exp(sb,se,ny) ∈ Znny 7 seconds 8 seconds 10 seconds 14 seconds 28 seconds 1minute 7minutes
Exp(sb,pe y) ∈ Zny 4 seconds 5 seconds 5 seconds 7 seconds 14 seconds 48 seconds 3minutes
Exp(sb,pe y, nx) ∈ Znxy 3 seconds 3 seconds 4 seconds 6 seconds 13 seconds 46 seconds 3minutes
Exp(sb,se,nx, ny) ∈ Znxny 6 seconds 7 seconds 8 seconds 10 seconds 14 seconds 34 seconds 2minutes
Exp(sb,se) ∈ Zn 10 seconds 12 seconds 14 seconds 15 seconds 16 seconds 18 seconds 20 seconds
Exp(sb,se,ny) ∈ Zn 5 seconds 6 seconds 6 seconds 7 seconds 8 seconds 9 seconds 10 seconds
Exp(sb,pe y) ∈ Zn 1 second 2 seconds 2 seconds 2 seconds 3 seconds 3 seconds 3 seconds
Exp(sb,pe y, nx) ∈ Zn 1 second 2 seconds 2 seconds 2 seconds 3 seconds 3 seconds 3 seconds
Exp(sb,se,nx) ∈ Zn < 1 second < 1 second < 1 second < 1 second < 1 second < 1 second < 1 second
Exp(sb,se,nx, ny) ∈ Zn < 1 second < 1 second < 1 second < 1 second < 1 second < 1 second < 1 second
Exp(pb x,se) ∈ Zn < 1 second < 1 second < 1 second < 1 second < 1 second < 1 second < 1 second
Exp(pb x,se,ny) ∈ Zn < 1 second < 1 second < 1 second < 1 second < 1 second < 1 second < 1 second
TABLE VIII
THE TIME COST OF THE TRADEOFF EXPONENTIATION PROTOCOLS WITH GIVEN k
Fig. 2. The timings of the commodity-based Scalar Product protocol with
different k and different dimensions.
helps estimate the execution time of protocols composed
of the Scalar Product. Again, we use Table IV and EF (·)
to construct Table VIII, showing the estimated time
of almost all possible tradeoffs of the exponentiation.
Recall that nx = 2
kx+1, ny = 2
ky+1, n = 2k+1;
for simplicity, we set x = 2kx+1, y = 2ky+1, where
kx, ky = bk2 c. We can see that the time to compute
the exponentiation may range from seconds to centuries,
depending on the degree of information one is willing
to reveal.
k Experimental Time Estimated Time
9 5.08 4.02
10 7.50 7.88
11 27.65 26.50
12 129.21 119.66
TABLE VII
EXPERIMENTAL AND ESTIMATED TIME (SECONDS) OF THE EXP(SB, SE)
∈ Znn PROTOCOL
V. CONCLUSION AND FUTURE WORK
Although the pursuit of efficient general solutions to SMC
problems is admirable, a more modest but likely, more suc-
cessful pursuit is to carefully consider tradeoff options during
the protocol design phase. In this paper, protocols for secure
two-party computation of exponentiation were designed based
on the repeated squaring algorithm using scalar products as
building blocks. A careful performance evaluation was carried
out in which an analysis of the execution time for our pro-
tocols was conducted by breaking them into their constitutive
building blocks and estimating the execution times using the
performance evaluation results of our implemented Scalar
  
TR-IIS-09-005 
Protocols for Secure Multi-party 
Computation: Design, Implementation 
and Performance Evaluation 
 
 
 
 
 
 
 
   
 
 
 
 
 
 
 
I-Cheng Wang, Kung Chen, Tsan-sheng Hsu,  
Churn-Jung Liau, Chih-Hao Shen, and Da-Wei Wang  
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
December 1,  2009  ||  Technical Report No. TR-IIS-09-005 
http://www.iis.sinica.edu.tw/page/library/LIB/TechReport/tr2009/tr09.html 
5 Examples in Statistics 12
5.1 Split Database . . . . . . . . . . . . . . . . 12
5.1.1 (secret) Range . . . . . . . . . . . 12
5.1.2 (secret) Mean . . . . . . . . . . . . 13
5.1.3 (secret) Variance . . . . . . . . . . 13
5.2 Shard Database . . . . . . . . . . . . . . . 14
5.2.1 (private) Range . . . . . . . . . . . 14
5.2.2 (private) Mean . . . . . . . . . . . 15
5.2.3 (private) Variance . . . . . . . . . . 15
6 Tradeoffs 15
6.1 Tradeoffs: Exponentiation . . . . . . . . . 16
6.2 Tradeoffs: Division . . . . . . . . . . . . . 18
7 Performance Evaluation 19
8 Conclusions and Future Works 20
List of Figures
1 Shift-Left . . . . . . . . . . . . . . . . . . 7
2 Shift-Right . . . . . . . . . . . . . . . . . 7
3 Rotate-Left . . . . . . . . . . . . . . . . . 8
4 Rotate-Right . . . . . . . . . . . . . . . . . 8
5 The hierarchy of the Square-root protocol. . 10
6 Split database architecture(secret shares) . . 12
7 Shard database architecture(Horizontal par-
titioning) . . . . . . . . . . . . . . . . . . 14
8 The Composition of the Exponentiation
protocol . . . . . . . . . . . . . . . . . . . 17
9 The timings of the commodity-based
Scalar-Product protocol with different k
and different dimensions. . . . . . . . . . . 20
List of Tables
1 Constituents of our protocols . . . . . . . . 22
3 Constituents of the statistic protocols . . . . 23
4 The Complexity of the statistic protocols . . 23
5 Constituents of the Exponentiation tradeoff
protocols . . . . . . . . . . . . . . . . . . 24
6 Constituents of the Exponentiation tradeoff
protocols . . . . . . . . . . . . . . . . . . 24
7 The Complexity of the Exponentiation
tradeoff protocols . . . . . . . . . . . . . . 25
8 The Complexity of the Exponentiation
tradeoff protocols . . . . . . . . . . . . . . 25
9 Constituents of the Div/Rem tradeoff proto-
cols . . . . . . . . . . . . . . . . . . . . . 25
10 The Scalar-Product Complexity of the
Div/Rem tradeoff protocols . . . . . . . . . 26
13 Experimental and estimated time (seconds)
of the Exp(sb, se) ∈ Znn protocol . . . . . 26
2 The Complexity of our protocols . . . . . . 27
11 The environment of our experiments . . . . 28
12 The timings(seconds) of the commodity-
based Scalar-Product protocol with differ-
ent k and different dimensions . . . . . . . 28
14 The time cost of the tradeoff exponentiation
protocols with given k . . . . . . . . . . . 29
2
lyzed various scalar-product approaches. They proved that
the invertible-matrix approach discloses at least half the in-
formation whereas the commodity-based approach is per-
fectly secure. Wang et al. [17] proved that no information-
theoretically secure two-party protocol exist for scalar prod-
ucts. Moreover, the closure property of the commodity-
based approach is preliminarily verified according to the se-
curity definition based on information theory [18].
Regarding the secure computation of exponentiation and
the discussion of tradeoffs, Algesheimer et al. [19] pre-
sented a protocol for exponentiation with a shared expo-
nent modulo a shared secret. Damga˚rd et al. [20] gave more
efficient constant round protocols for securely computing
the exponentiation with respect to public/shared exponents
and moduli. Recently, Nielsen and Schwartzbach [21] have
given tradeoff examples of SMC problems and shown the
timing results.
3 Preliminaries
In this section, we introduce the notations used hereafter
and specifications of the building blocks.
For a secure two-party problem, the two parties hold
private inputs X1, X2 respectively. After the execution of
some protocol, they hold private outputs Y1, Y2. The sub-
script of a variable denotes the party who owns the variable.
There might be a list of public variables, plist, and we use
(X1, X2){plist} 7→ (Y1, Y2) to denote it. The domain Zn
denotes a ring consisting of elements {0, . . . , n−1}, and the
results of addition and multiplication in Zn are the modular
summation and the modular product. If not stated other-
wise, the computations of our proposals are over Zn, where
n is two’s power, namely, n = 2k+1, k ∈ N. Moreover, to
extend the domain from natural number to integer, elements
{1, . . . , bn−12 c} remain positive numbers, while elements
{n−1, . . . , n−bn−12 c} are interpreted as negative integers
analogous to the binary system in modern computers. As
a result, the subtraction to p is equivalent to the addition to
(n− p).
x− p (mod n) = x + n− p (mod n).
In this paper, there are two different concepts of the
“scalar product.” When it comes to lower case letters, it
means all secure scalar product approaches; when it comes
to capitalized words (Scalar-Product), it means one of these
secure scalar product approaches. The formulation for the
Scalar-Product protocol follows Goldreich’s principle [22],
namely that the intermediate results during protocol execu-
tion are always shared among participants. In a protocol pi
composed of Scalar-Products, current outputs can be inputs
to the next Scalar-Product, which are actually the interme-
diate results of pi and should be shared. Moreover, the inter-
mediate results are shared by addition rather than multipli-
cation. In ring Zn, the multiplicative sharing reveals infor-
mation when either of the values of the shares is zero, while
the additive sharing has been proven to be perfect [18]. The
secure Scalar-Product protocol is specified as
Specification 3.1 (Scalar-Product) Party 1 and Party 2
want to collaboratively execute the secure protocol
((x[1]1, . . . , x[d]1), (x[1]2, . . . , x[d]2)) 7→ (y1, y2)
such that y1 + y2 = x[1]1 · x[1]2 + · · · + x[d]1 · x[d]2 and
x[i]1, x[i]2, y1, y2 ∈ Zn, for i = 1, . . . , d.
Here we merely specify Scalar-Product instead of pro-
viding a concrete approach because we focus on building
more protocols on top of Scalar-Product. Similar to the soft-
ware specification, as long as a new subroutine matches the
interface, it can replace the old one and work perfectly. In
our scalar-product based protocols, as long as a new solu-
tion matches the specification 4.16, it can be used as the
building block of our proposed protocols. A scalar-product
based composition theory is proved for semi-honest adver-
sary models [23], so our protocols preserve the entropy of
the secret inputs as strong as the underlying scalar product
protocol preserves the entropy of its inputs.
In passing, it should be noted that we do not deal with the
problem of combining the shared output variables to pro-
duce the final results, for we are designing building blocks
which can be used to build even larger protocols. The step
of combining shared variables to produce the final results
does not come until after computation is completed. It is
unnecessary to combine intermediate variables.
As far as we know, there is no systematic approach
to construct all computable functions directly from scalar
products. Hence we specified some more building blocks
to facilitate solving more SMC problems. In the remainder
of this section, we summarize the specifications of those
building blocks that we will employ to develop protocols
for exponentiation. The readers are referred to [24] for the
details of those building blocks.
4 Building Blocks
We separate this section into four subsections proposing
primitive, useful building blocks, building blocks for fixed
point numbers, and general solutions.
4.1 Primitive building blocks
Four primitive building blocks are specified, which are
Zn-to-Z2, Z2-to-Zn, Product, and Square.
4
4.1.3 Square
The Square protocol, which is very similar to the Product
protocol and employs the same strategy, namely dividing
the computation into the part which can be done individu-
ally and the rest which must be performed collaboratively.
However, the Square protocol reduces the dimension of the
scalar product from two to one.
Specification 4.4 (Square) Party 1 and Party 2 share a
number in Zn, and they want to collaboratively execute the
secure protocol (x1, x2) 7→ (y1, y2) such that y1 + y2 =
(x1 + x2)
2.
The protocol details are as follows:
PROTOCOL Square
1. Party 1 and Party 2 jointly execute the Scalar-Product proto-
col (x1, x2) 7→ (t1, t2) such that t1 + t2 (mod n) = x1 ·x2.
2. Party j individually computes yj = x
2
j + 2tj , for j = 1, 2.
4.2 Useful building blocks
Based on primitive building blocks introduced in Sec-
tion 4.1, several useful protocols are proposed here, includ-
ing Comparison, Zero, If-Then-Else, Shift, Rotation, Loga-
rithm, Division/Remainder, and Exponentiation.
4.2.1 Comparison
There are many variations of binary comparison: less
than (<), greater than (>), less than or equal to (≤), grater
than or equal to (≥), and equal to (=). However, all of them
are reducible to the less than operator (<). In order to com-
pare x and y, it is intuitive to compare (x−y) and 0 since we
share the intermediate results additively; at the same time,
it is effortless to subtract under additive sharing. Our pro-
posal to compare x and y is to compute the most significant
bit of (x − y). According to the binary system on modern
computers, if the most significant bit of (x−y) is 1, (x−y)
is a negative number inferring that x is less than y.
Specification 4.5 (Comparison) Party 1 and Party 2 share
a number in Zn, and they want to know the sign of the num-
ber. In other words, they want to collaboratively execute the
secure protocol (x1, x2) 7→ (y1, y2) such that
y1 + y2 =
{
1 if x1 + x2 < 0,
0 otherwise.
Recall that we compute the comparison by checking
whether the shared number is negative, i.e., whether the
most significant bit of the shared number is 1. The protocol
details are as follows:
PROTOCOL Comparison
1. Two parties collaboratively execute the Zn-to-Z2{k} pro-
tocol (x1, x2) 7→ ((b
0
1, . . . , b
k
1), (b
0
2, . . . , b
k
2)), such that
bi = bi1 + b
i
2 (mod 2), and (b
k · · · b0)2 = x1 + x2.
2. Party 1 and Party 2 collaboratively execute the Z2-to-Zn{0}
protocol (bk1 , b
k
2) 7→ (y1, y2), such that y1 + y2 = (b
k)2 and
bk = bk1 + b
k
2 (mod 2).
4.2.2 Zero
To test if two additively shared numbers are equal to each
other is equivalent to test if the difference of these two num-
bers is zero, and the Zero protocol does the job. More
specifically, the Zero protocol examines whether a shared
number is zero or not. The straightforward idea is to test if
it is neither less nor greater than zero. As mentioned, this is
one of the variations of binary comparison.
Specification 4.6 (Zero) Party 1 and Party 2 share a num-
ber in Zn, and they want to know if the number is equal to
zero. In other words, they want to collaboratively execute
the secure protocol (x1, x2) 7→ (y1, y2) such that
y1 + y2 =
{
1 if x1 + x2 = 0,
0 otherwise.
The protocol details are as follows:
PROTOCOL Zero
1. Two parties collaboratively execute the Comparison protocol
(x1, x2) 7→ (t1, t2), such that
t1 + t2 =
{
1 if x1 + x2 < 0,
0 otherwise.
2. Party 1 and Party 2 collaboratively execute the Comparison
protocol (−x1,−x2) 7→ (s1, s2), such that
s1 + s2 =
{
1 if − (x1 + x2) < 0,
0 otherwise.
3. Party 1 and Party 2 collaboratively execute the Product pro-
tocol ((1 − t1, 1 − s1), (−t2,−s2)) 7→ (y1, y2) such that
y1 + y2 = (1− t1 − t2)(1− s1 − s2).
4.2.3 If-Then-Else
The If-Then-Else protocol is useful for functions with alter-
natives.
Specification 4.7 (If-Then-Else) Party 1 and Party 2 addi-
tively share the predicate, IF-clause value, and the ELSE-
clause value. They want to securely execute the protocol
((b1, x1, y1), (b2, x2, y2)) 7→ (z1, z2) such that
z1 + z2 =
{
x1 + x2 if b1 + b2 = 1,
y1 + y2 if b1 + b2 = 0.
6
Specification 4.10 (Shift{s}) Party 1 and Party 2 want to
collaboratively execute the secure protocol (x1, x2){s} 7→
(y1, y2) such that y1 + y2 = bx1+x22s c.
The protocol details are as follows:
PROTOCOL Shift{s}
1. Party 1 and Party 2 jointly execute the Zn-to-Z2{k} pro-
tocol (x1, x2){k} 7→ ((b
0
1, . . . , b
k
1), (b
0
2, . . . , b
k
2), such that
(bk · · · b0)2 = x1 + x2, and b
i = bi1 + b
i
2 (mod 2), for
i = 0, 1, . . . , k.
2. Party j individually sets [d0j , d
1
j , . . . , d
k−s−1
j , d
k−s
j ] =
[bkj , b
k−1
j , . . . , b
s+1
j , b
s
j ], for j = 1, 2.
3. Party 1 and Party 2 collaboratively run the Z2-to-Zn{k− s}
protocol
((d01, . . . , d
k−s
1 ), (d
0
2, . . . , d
k−s
2 )){k − s} 7→ (y1, y2)
such that y1 + y2 = (d
k−sdk−s−1 · · · d1d0)2.
4.2.5 Rotation
Specification 4.11 (Rotate-Left) Party 1 and Party 2
want to collaboratively execute the secure proto-
col ((x01, x
1
1, . . . , x
k
1 , s1), (x
0
2, x
1
2, . . . , x
k
2 , s2)) 7→
((y01 , y
1
1 , . . . , y
k
1 ), (y
0
2 , y
1
2 , . . . , y
k
2 )) such that y
i =
x(i−r) (mod k+1) where r = [(s1 + s2) (mod n)] (mod k +
1), for i = 0, 1, . . . , k.
Figure 3. Rotate-Left
Let bi ∈ Z2 for i = 0, 1, · · · , k, and the design idea of
the Rotate-Left protocol is as Figure 3 shown.
PROTOCOL Rotate-Left
1. Party 1 and Party 2 collaboratively execute the the Z2-to-
Zn2{k} protocol
((x01, . . . , x
k
1), (x
0
2, . . . , x
k
2)) 7→ (X1, X2)
such that X1 +X2 (mod n
2) = (xkxk−1 · · ·x1x0)2, where
xi = xi1 + x
i
2 (mod 2), for i = 0, 1, · · · , k.
2. Party j individually computes Tj = Xj · (2
k+1 +
1) (mod n2), for j = 1, 2.
3. Party 1 and Party 2 jointly run the Exp(pb, se, ny) ∈ Zn
protocol (s1, s2){2, k +1} 7→ (u1, u2) such that u1 +u2 =
2s1+s2 .
4. These two parties collaboratively run the Zn-to-Z2{k} pro-
tocol followed by the Z2-to-Zn2{k} protocol
(u1, u2){k} 7→ ((d
0
1, . . . , d
k
1), (d
0
2, . . . , d
k
2)) 7→ (U1, U2)
such that U1 + U2 (mod n
2) = u1 + u2 (mod n).
5. These two parties jointly run the Product protocol
((T1, U1), (T2, U2)) 7→ (V1, V2) such that V1 +
V2 (mod n
2) = (T1 + T2)(U1 + U2) (mod n
2).
6. Party 1 and Party 2 jointly execute the Zn2 -to-Z2{2k + 1}
protocol
(V1, V2){2k + 1} 7→ ((f
0
1 , . . . , f
2k+1
1 ), (f
0
2 , . . . , f
2k+1
2 ))
such that (f2k+1f2k · · · f1f0)2 = V1+V2 (mod n
2),where
f i = f i1 + f
i
2 (mod 2), for i = 0, 1, · · · , 2k + 1.
7. Party j individually sets [y0j , y
1
j , . . . , y
k−1
j , y
k
j ] =
[fk+1j , . . . , f
2k+1
j ].
Specification 4.12 (Rotate-Right) Party 1 and Party 2
want to collaboratively execute the secure proto-
col ((x01, x
1
1, . . . , x
k
1 , s1), (x
0
2, x
1
2, . . . , x
k
2 , s2)) 7→
((y01 , y
1
1 , . . . , y
k
1 ), (y
0
2 , y
1
2 , . . . , y
k
2 )) such that y
i =
x(i+r) (mod k+1) where r = [(s1 + s2) (mod n)] (mod k +
1), for i = 0, 1, . . . , k.
Figure 4. Rotate-Right
Let bi ∈ Z2 for i = 0, 1, · · · , k, and the design idea of
the Rotate-Right protocol is as Figure 4 shown.
PROTOCOL Rotate-Right
1. Party j individually sets [d0j , d
1
j , . . . , d
k−1
j , d
k
j ] =
[xkj , x
k−1
j , . . . , x
1
j , x
0
j ], for j = 1, 2.
2. Party 1 and Party 2 collaboratively execute the Rotate-
Left protocol ((d01, d
1
1, . . . , d
k
1 , s1), (d
0
2, d
1
2, . . . , d
k
2 , s2)) 7→
((f01 , f
1
1 , . . . , f
k
1 ), (f
0
2 , f
1
2 , . . . , f
k
2 )) such that f
i =
d(i−r) (mod k+1) where r = [(s1 + s2) (mod n)] (mod k +
1), for i = 0, 1, . . . , k.
8
Algorithm 2 Calculate y = b√xc
(bkbk−1 · · · b1b0)2 ← x
if k + 1 (mod 2) = 1 then
bk+1 ← 0
end if
d, g, y ← 0
for i ← dk+12 e to 1 do
d = 4d + 2b2i−1 + b2i−2
if d ≥ 2g + 1 then
f ← d− (2g + 1)
g ← 2g + 2
y ← 2y + 1
else
g ← 2g
y ← 2y
end if
end for
4. For i = d k+1
2
e, · · · , 1, repeat from Step 4a to Step 4f.
(a) Party 1 and Party 2 jointly run the Z2-to-Zn{0} proto-
col (b2i−11 , b
2i−1
2 ) 7→ (t
2i−1
1 , t
2i−1
2 ), such that t
2i−1
1 +
t2i−12 (mod n) = (b
2i−1)2.
(b) Party 1 and Party 2 jointly run the Z2-to-Zn{0} proto-
col (b2i−21 , b
2i−2
2 ) 7→ (t
2i−2
1 , t
2i−2
2 ), such that t
2i−2
1 +
t2i−22 (mod n) = (b
2i−2)2.
(c) For j = 1, 2, Party j individually sets dij = 4d
i+1
j +
2t2i−1j + t
2i−2
j .
(d) Two parties jointly execute the Comparison protocol
(di1 − 2g
i
1 − 1, d
i
2 − 2g
i
2) 7→ (c1, c2), where
c1+c2 =
{
1 if (di1 + d
i
2)− 2(g
i
1 + g
i
2)− 1 < 0,
0 otherwise.
(e) Party 1 and Party 2 collaboratively run the If-Then-
Else protocol ((c1, d
i
1, d
i
1 − 2g
i
1 − 1), (c2, d
i
2, d
i
2 −
2gi2)) 7→ (d
i−1
1 , d
i−1
2 ) such that
d
i−1
1 + d
i−1
2 =
{
di if c1 + c2 = 1,
di − 2gi − 1 if c1 + c2 = 0,
where di = di1 + d
i
2, g
i = gi1 + g
i
2.
(f) Party 1 sets gi−11 = 2g
i
1+2−2c1, y
i−1
1 = 2y
i
1+1−c1
while Party 2 sets gi−12 = 2g
i
2−2c2, y
i−1
2 = 2y
i
2−c2
such that
g
i−1
1 + g
i−1
2 =
{
2gi if c1 + c2 = 1,
2gi + 2 if c1 + c2 = 0,
y
i−1
1 + y
i−1
2 =
{
2yi if c1 + c2 = 1,
2yi + 1 if c1 + c2 = 0,
where yi = yi1 + y
i
2.
5. Party j individually sets yj = y
0
j , for j = 1, 2.
Figure 5. The hierarchy of the Square-root
protocol.
4.2.8 Logarithm
Specification 4.15 (Logarithm) Party 1 and Party 2 want
to collaboratively execute the secure protocol (x1, x2) 7→
(y1, y2) such that y1 + y2 = blog2 (x1 + x2)c.
Algorithm 3 Calculate t = blog2 xc
(bkbk−1 · · · b1b0)2 ← x
t ← b1
for i ← 2 to k do
if bi = 1 then
t ← i
end if
end for
PROTOCOL Logarithm
1. Party 1 and Party 2 collaboratively execute the Zn-to-
Z2{k} protocol (x1, x2){k} 7→ ((b
0
1, . . . , b
k
1), (b
0
2, . . . , b
k
2))
such that (bkbk−1 · · · b1b0)2 = x1 + x2 where x1, x2 ∈
Zn, b
i
1, b
i
2 ∈ Z2, and b
i = bi1 + b
i
2 (mod 2), for i =
0, 1, · · · , k.
2. Party 1 and Party 2 collaboratively execute the Z2-to-Zn{0}
protocol (b11, b
1
2){0} 7→ (t
1
1, t
1
2) such that t
1
1 + t
1
2 = (b
0)2
where t11, t
1
2 ∈ Zn.
3. For i = 2 to k, repeat Step 3a and Step 3b.
(a) Party 1 and Party 2 collaboratively run the Z2-to-
Zn{0} protocol (b
i
1, b
i
2){0} 7→ (d
i
1, d
i
2) such that
di1 + d
i
2 = (b
i)2 where d
i
1, d
i
2 ∈ Zn.
(b) These two parties jointly run the If-Then-Else protocol
((di1, i, t
i−1
1 ), (d
i
2, 0, t
i−1
2 )) 7→ (t
i
1, t
i
2) such that
t
i
1 + t
i
2 =
{
i if di1 + d
i
2 = 1,
ti−11 + t
i−1
2 if d
i
1 + d
i
2 = 0.
4. Party j locally sets yj = t
k
j , for j = 1, 2.
10
4.4.2 Function(x, y){s, f(·)}
Specification 4.20 (Function(x, y)) Party 1 and Party 2
share some x and y. They want to securely execute the
protocol ((x1, y1), (x2, y2)){s, f(·)} 7→ (zˆ1, zˆ2) such that
zˆ1 + zˆ2 = [2
s · f(x1 + x2, y1 + y2)] where s is the num-
ber of bits after the decimal point and f(·) is some function.
(For example, f(x, y) = logy x or f(x, y) =
y
√
x where
x = x1 + x2 and y = y1 + y2.)
PROTOCOL Function(x, y)
1. For i = 0, · · · , n− 1, repeat from Step 1a to Step 1c.
(a) For j = 0, · · · , n− 1, repeat Step 1(a)i.
i. Party 1 individually sets tˆ[j] = [2sf(x1 + i, y1 +
j)] while Party 2 individually sets
w[j] =
{
1 if j = y2,
0 if j 6= y2.
(b) Party 1 and Party 2 collaboratively execute the Scalar-
Product protocol
((tˆ[0], . . . , tˆ[n−1]), (w[0], . . . , w[n−1])) 7→ (uˆ[i]1, uˆ[i]2)
such that uˆ[i]1 + uˆ[i]2 = tˆ[0] ·w[0] + · · ·+ tˆ[n− 1] ·
w[n− 1].
(More specifically, uˆ[i]1 + uˆ[i]2 = tˆ[y2] = [2
sf(x1 +
i, y1 + y2)].)
(c) Party 1 individually sets vˆ[i] = uˆ[i]1 while Party 2
individually sets
q[i] =
{
1 if i = x2,
0 if i 6= x2.
2. Party 1 and Party 2 collaboratively execute the Scalar-
Product protocol ((vˆ[0], . . . , vˆ[n − 1]), (q[0], . . . , q[n −
1])) 7→ (rˆ1, rˆ2) such that rˆ1 + rˆ2 = vˆ[0] · q[0] + · · · +
vˆ[n− 1] · q[n− 1].
(More specifically, rˆ1 + rˆ2 = vˆ[x2] = uˆ[x2]1.)
3. Party 1 individually sets zˆ1 = rˆ1, and Party 2 computes zˆ2 =
uˆ[x2]2 + rˆ2.
Since every building block is composed of other ones
and based on the Scalar-Product, Table 1 lists the con-
stituents of these building blocks.
We further break those constitutive building blocks in
Table 1 into Scalar-Product protocols of which Table 2
shows the domain, dimension, and times.
5 Examples in Statistics
In this section, we give examples for SMC problems in
statistics and design protocols solving them. Two scenar-
ios of a shared database are considered. The secret type
of database indicates the data of which are shared between
Party 1 and Party 2 ; the private type one means each party
privately owns their database, and a view with a union is
created over both of them to provide a complete view. Fig-
ure 6 and Figure 7 show the split and the shard database ar-
chitecture(aka horizontal partitioning) relatively. Based on
these two different scenarios, (secret) and (private) types
of protocols are proposed, including Range, Mean, and Var.
With these protocols, we can securely compute the range,
the mean, and the variance of the linked database.
5.1 Split Database
Figure 6. Split database architecture(secret
shares)
5.1.1 (secret) Range
Before introducing the (secret) Range protocol, we first de-
sign the (secret) Max and the (secret) Min protocols.
Specification 5.1 ((secret) Max) Party 1 and Party 2
want to collaboratively execute the secure protocol
((x[1]1, x[2]1, · · · , x[d]1), (x[1]2, x[2]2, · · · , x[d]2)){d} 7→
(y1, y2) such that y1 + y2 = the maximum of
(x[1], x[2], · · · , x[d]) where x[i]1, x[i]2, y1, y2 ∈ Zn,
for i = 1, 2, · · · , d.
Algorithm 4 Calculate max = the maximum of
(x[1], x[2], · · · , x[d])
max ← x[1]
for i ← 2, 3, · · · , d do
if max < x[i] then
max ← x[i]
end if
end for
Based on Algorithm 4, the (secret) Max protocol details
are as follows:
PROTOCOL (secret) Max
12
Algorithm 7 Calculate var = the variance of
(x[1], x[2], · · · , x[d])
s ← SquareSum(x[1], x[2], · · · , x[d])
t ← Sum(x[1], x[2], · · · , x[d])
var = (d · s− t2)/d2
1. Party 1 and Party 2 collabora-
tively run the Scalar-Product protocol
((2x[1]1, 2x[2]1, · · · , 2x[d]1), (x[1]2, x[2]2, · · · , x[d]2)) 7→
(u1, u2) such that u1 + u2 = 2x[1]1 · x[1]2 + · · ·+ 2x[d]1 ·
x[d]2.
2. Party j individually computes sj =
∑d
i=1 x[i]
2
j + uj , for
j = 1, 2.
3. Party 1 and Party 2 collaboratively run the Square protocol
(t1, t2) 7→ (v1, v2) such that v1 + v2 = (t1 + t2)
2.
4. Party j computes zj = p · sj − vj , for j = 1, 2.
5. Party 1 and Party 2 jointly execute the Div/Rem{divisor}
protocol (z1, z2){d
2} 7→ ((q1, r1), (q2, r2)) such that q1 +
q2 =
⌊
z1+z2
d2
⌋
.
5.2 Shard Database
Figure 7. Shard database architec-
ture(Horizontal partitioning)
5.2.1 (private) Range
Before introducing the (private) Range protocol, we first de-
sign the (private) Max and the (private) Min protocols.
Specification 5.6 ((private) Max) Party 1 and Party 2
want to collaboratively execute the secure protocol
(x, y) 7→ (z1, z2) such that
z1 + z2 =
{
y if x− y < 0,
x otherwise,
where x, y, z1, z2 ∈ Zn.
Algorithm 8 Calculate max = the maximum of (x, y)
if x > y then
max ← x
else
max ← y
end if
Based on Algorithm 8, the (private) Max protocol details
are as follows:
PROTOCOL (private) Max
1. Party 1 and Party 2 jointly run the Comparison protocol
(−x, y) 7→ (t1, t2) such that
t1 + t2 =
{
1 if y − x < 0,
0 otherwise.
2. Party 1 and Party 2 jointly run the If-Then-Else protocol
((t1, x, 0), (t2, 0, y)) 7→ (z1, z2) such that
z1 + z2 =
{
x if t1 + t2 = 1,
y if t1 + t2 = 0.
Specification 5.7 ((private) Min) Party 1 and Party 2
want to collaboratively execute the secure protocol
(x, y) 7→ (z1, z2) such that
z1 + z2 =
{
x if x− y < 0,
y otherwise,
where x, y, z1, z2 ∈ Zn.
Algorithm 9 Calculate min = the minimum of (x, y)
if x < y then
min ← x
else
min ← y
end if
Based on Algorithm 9, the (private) Min protocol details
are as follows:
PROTOCOL (private) Min
1. Party 1 and Party 2 jointly run the Comparison protocol
(x,−y) 7→ (t1, t2) such that
t1 + t2 =
{
1 if x− y < 0,
0 otherwise.
14
6.1 Tradeoffs: Exponentiation
Party 1 and Party 2 share the base x and the exponent
y. Let the positive integers nx and ny be the range of
x and the range of y respectively, where x < nx ≤ n,
y < ny ≤ n, nx = 2kx+1, ny = 2ky+1, and kx, ky ∈ N. As
we can see in the discussion below, if tighter bounds are/is
known for x and/or y, i.e., nx and/or ny are/is much smaller
than n, the execution time needed would be much smaller.
We argue that in cases where the users know or can derive
tighter upper bounds for x and/or y due to the nature of the
problem, and this knowledge can greatly improve computa-
tional efficiency. In some other cases, we envision that the
computational cost is prohibitively high, so that the parties
would agree to reveal some information about x and/or y
in order to get the results in reasonable time. Nielsen and
Schwartzbach define three variable types which are secret,
public, and private [25]. Here we only define two vari-
able types: secret and public. The secret type of variable
indicates the value of which is shared between Party 1 and
Party 2 , while the public type of variable means the value
of which resides in plain view on these two parties. For
simplicity, hereafter we set sb = secret base, se = secret
exponent, pb = public base, and pe = public exponent.
Since the performance of the protocol is dependent on
the number of bits necessary to represent the final results, a
very effective way to improve the performance is to reveal
the upper bounds of the base and/or the exponent. Below
is the description of the exponentiation protocol with nx
and ny . Note that nx = ny = n is the case where no
information about x, y is revealed.
Algorithm 12 is a simple repeated squaring algorithm to
compute the exponentiation [26]. Note that in this algo-
rithm the exponent y has to be treated as a sequence of bits.
It is apparent that a secure two-party protocol based on the
algorithm must first invokes the Zn-to-Z2{ky} protocol to
transform an additive shared y to a shared bit string which is
the binary representation of y. Because of x < nx, y < ny,
the answer of xy is in Znxny . Therefore, to ensure the cor-
rectness all the steps of the protocol must be done in Znxny .
More specifically, we need Zn-to-Z2{kx} and {kx}Z2-to-
Znn protocols to transform the base x from Zn shares to
Znx
ny shares. Besides that, ky + 1 times of the Z2-to-
Znx
ny {0} protocol are necessary to transform the shared
bits of the exponent y from Z2 to Znxny shares. The If-
Then-Else, Square, and Product protocols are required as
well to complete this algorithm. Figure 8 is the construc-
tion of the Exp(sb, se, nx, ny) ∈ Znxny protocol.
Specification 6.1 (Exp(sb, se, nx, ny) ∈ Znxny )
Party 1 and Party 2 share the base and the expo-
nent. They want to securely execute the protocol
((x1, y1), (x2, y2)){nx, ny} 7→ (z1, z2) such that
z1 + z2 = (x1 + x2)
y1+y2 , where z1, z2 ∈ Znxny ,
Algorithm 12 Calculate u = xy
(bkbk−1 · · · b1b0)2 ← y
u ← 1
if b0 = 1 then
u ← x
end if
v ← x
for i = 1, 2, · · · , k do
v = v2
if bi = 1 then
u = u · v
end if
end for
nx, ny are public ranges of x and y respectively. More
specifically, x < nx ≤ n, and y < ny ≤ n.
PROTOCOL Exp(sb, se, nx, ny) ∈ Znxny
1. Party 1 and Party 2 collaboratively execute the Zn-to-
Z2{kx} protocol followed by the Z2-to-Znxny {kx} proto-
col,
(x1, x2){kx} 7→ ((e
0
1, . . . , e
kx
1 ), (e
0
2, . . . , e
kx
2 )) 7→ (X1, X2),
where X1 + X2 (mod nx
ny ) = x1 + x2 (mod n).
2. Party 1 and Party 2 jointly execute the Zn-to-Z2{ky} pro-
tocol (y1, y2){ky} 7→ ((b
0
1, . . . , b
ky
1 ), (b
0
2, . . . , b
ky
2 )) such
that (bky bky−1 · · · b1b0)2 = y1 + y2, where y1, y2 ∈ Zny ,
bi1, b
i
2 ∈ Z2, and b
i = bi1+b
i
2 (mod 2), for i = 0, 1, · · · , ky.
3. Party 1 and Party 2 jointly execute the Z2-to-Znxny {0}
protocol (b01, b
0
2){0} 7→ (d
0
1, d
0
2) such that (b
0)2 = d
0
1 +
d02 (mod nx
ny ), where d01, d
0
2 ∈ Znxny , b
0
1, b
0
2 ∈ Z2, and
b0 = b01 + b
0
2 (mod 2).
4. Party 1 and Party 2 jointly execute the If-Then-Else proto-
col ((d01, X1, 1), (d
0
2, X2, 0)) 7→ (u
1
1, u
1
2) such that u
1
1 +
u12 (mod nx
ny ) =
{
X1 + X2 if d
0
1 + d
0
2 = 1,
1 if d01 + d
0
2 = 0.
It is clear from the context that + represents addition in Z
n
ny
x
.
5. Party j individually sets v1j = Xj , for j = 1, 2.
6. For i = 1, 2, · · · , ky , repeat from Step 6a to Step 6d.
(a) The two parties jointly execute the Square proto-
col (vi1, v
i
2) 7→ (v
i+1
1 , v
i+1
2 ) such that v
i+1
1 +
vi+12 (mod nx
ny ) = (vi1 + v
i
2)
2.
(b) The two parties jointly execute the Product proto-
col ((ui1, v
i
1), (u
i
2, v
i
2)) 7→ (w
i
1, w
i
2) such that w
i
1 +
wi2 (mod nx
ny ) = (ui1 + u
i
2)(v
i
1 + v
i
2).
(c) Party 1 and Party 2 jointly execute the Z2-to-
Znx
ny {0} protocol (bi1, b
i
2){0} 7→ (d
i
1, d
i
2) such that
(bi)2 = d
i
1 +d
i
2 (mod nx
ny ), where di1, d
i
2 ∈ Znxny ,
bi1, b
i
2 ∈ Z2, and b
i = bi1 + b
i
2 (mod 2).
16
(c) Party 1 sets u11 = b
0X1 + (1− b
0), while Party 2 sets
u12 = b
0X2, such that
u
1
1 + u
1
2 (mod n
y) =
{
X1 + X2 if b
0 = 1,
1 if b0 = 0.
It is clear from the context that + represents addition in
Zny .
(d) Party j individually sets v1j = Xj , for j = 1, 2.
(e) For i = 1, · · · , ky , repeat Step 2(e)i and Step 2(e)ii.
i. The two parties jointly execute the Square pro-
tocol (vi1, v
i
2) 7→ (v
i+1
1 , v
i+1
2 ) such that v
i+1
1 +
vi+12 (mod n
y) = (vi1 + v
i
2)
2. It is clear from the
context that + represents addition in Zny .
ii. If bi = 1, the two parties jointly execute the Prod-
uct protocol ((ui1, v
i
1), (u
i
2, v
i
2)) 7→ (u
i+1
1 , u
i+1
2 )
such that ui+11 + u
i+1
2 (mod n
y) = (ui1 +
ui2)(v
i
1 + v
i
2). If b
i = 0, Party j individually sets
ui+1j = u
i
j , for j = 1, 2. It is clear from the con-
text that + represents addition in Zny .
(f) Party j individually sets zj = u
ky+1
j , for j = 1, 2.
There are other tradeoffs. For example, keep the expo-
nent in shares; at the same time reveal the base and the upper
bounds of the exponent. Or on the one hand, keep the base
in shares; on the other hand, disclose both the exponent and
the upper bounds of the base. The former and the latter are
represented as Exp(pb x, se, ny) ∈ Zxny and Exp(sb, pe y,
nx) ∈ Znxy respectively.
1. Exp(pb x, se, ny) ∈ Zxny : This is quite the same as
Exp(pb x, se) ∈ Zxn except the domain of the compu-
tation reduced from Zxn to Zxny .
2. Exp(sb, pe y, nx) ∈ Znxy : This one is supposed have
better performance than Exp(sb, pe y) ∈ Zny since the
domain of the computation reduced from Zny to Znxy .
Then we enumerate two situations which may indirectly
disclose some information.
1. Exp(pb x, se) ∈ Zn: Once the base x is not a secret
and the answer of xy is guaranteed in Zn, the range of
y is no longer in n but limited to logx n, if x 6= 1.
xy < n ⇒ y < logx n.
2. Exp(sb, pe y) ∈ Zn: Much the same, when it comes to
a public exponent y and a guaranteed answer in Zn, the
range of x is constrained to b y√nc rather than supposed
n.
xy < n ⇒ x < b y√nc.
Note that hereafter in this paper, we present the worst
cases of those protocols with pe. More specifically, we
view every bit of the public exponent y as 1. That is
y = 2ky+1 − 1, where ky = blog2 yc. We break the afore-
mentioned exponentiation protocols into their constitutive
building blocks of which Table 6 lists the domain and times.
Based on Table 1 and Table 2, we further break the con-
stitutive building blocks of those exponentiation protocols
in Table 6 into Scalar-Product protocols of which Table 8
lists the domain, dimension, and times.
6.2 Tradeoffs: Division
Specification 6.4 (Div/Rem {kx, ky}) Two parties share
the dividend and the divisor in Zn, and they want to jointly
execute the secure protocol ((x1, y1), (x2, y2)){kx, ky} 7→
((q1, r1), (q2, r2)), where nx = 2
kx+1 > (x1 + x2) =
(y1 + y2)(q1 + q2) + (r1 + r2) and 0 ≤ (r1 + r2) <
(y1 + y2) < 2
ky+1 = ny.
PROTOCOL Div/Rem {kx, ky}
1. Party 1 and Party 2 collaboratively execute the Zn-to-
Z2{kx} protocol followed by the Z2-to-Znx·ny{kx} proto-
col
(x1, x2) 7→ ((b
0
1, . . . , b
kx
1 ), (b
0
2, . . . , b
kx
2 )) 7→ (X1, X2)
such that X1 + X2 (mod nx · ny) = x1 + x2 (mod n).
2. Party 1 and Party 2 collaboratively execute the Zn-to-
Z2{ky} protocol followed by the Z2-to-Znx·ny{ky} proto-
col
(y1, y2) 7→ ((c
0
1, . . . , c
ky
1 ), (c
0
2, . . . , c
ky
2 )) 7→ (Y1, Y2)
such that Y1 + Y2 (mod nx · ny) = y1 + y2 (mod n).
3. Party j sets Xkxj = Xj , for j = 1, 2.
4. For i = kx − 1, . . . , 1, 0, repeat Step 4a to Step 4d.
(a) Party j computes tij = X
i+1
j − Yj · 2
i (mod nx · ny),
for j = 1, 2.
(b) Party 1 and Party 2 jointly run the Comparison proto-
col (ti1, t
i
2) 7→ (s
i
1, s
i
2) such that
s
i
1 + s
i
2 (mod nx · ny) =
{
1 if ti1 + t
i
2 < 0,
0 otherwise.
(c) Party j individually computes qij = 1 − s
i
j (mod nx ·
ny), for j = 1, 2, such that
q
i
1 + q
i
2 (mod nx · ny) =
{
0 if si1 + s
i
2 = 1,
1 if si1 + s
i
2 = 0.
(d) Party 1 and Party 2 run the If-Then-Else protocol
((si1, X
i+1
1 , t
i
1), (s
i
2, X
i+1
2 , t
i
2)) 7→ (X
i
1, X
i
2) such
that Xi1 + X
i
2 (mod nx · ny) =
{
Xi+11 + X
i+1
2 if s
i
1 + s
i
2 = 1,
ti1 + t
i
2 if s
i
1 + s
i
2 = 0.
18
1. We focus on the execution time of the Scalar-Product
protocol with different dimensions and a different
number of bits of domain. Table 12 shows the experi-
mental results. Recall that 2k+1 = n, and with given k
in this table, timings are not apparently different when
it comes to different dimension d ≤ 32. Therefore, we
simply set d = 1 and find the time estimation function
EF (·) which is a polynomial curve fitting our experi-
mental results (see Figure 9).
EF (k) = 2 · 10−10k2 − 5 · 10−8k + 0.0566,
R2 = 0.9993.
Then, given two necessary parameters for the Scalar-
Product, dimension d and the number of bits of n (that
is k + 1), we have two ways to estimate the time cost.
First, with extrapolation we can look up the prepared
experimental data, like Table 12. Second, when d ≤
32, we can easily use EF (k) to estimate the time.
Figure 9. The timings of the commodity-
based Scalar-Product protocol with different
k and different dimensions.
2. We concentrate on the execution time of the Exp(sb,
se) ∈ Znn protocol with a different number of bits of
n. At the same time, we estimate the time cost by using
Table 8 and EF (·). Both the experimental results and
the estimated time are listed in Table 13. As this table
shown, it is convincing that EF (·) is a useful function
which helps estimate the execution time of protocols
composed of the Scalar-Product.
Again, we use Table 8 and EF (·) to construct Ta-
ble 14, showing the estimated time of almost all pos-
sible tradeoffs of the exponentiation. Recall that nx =
2kx+1, ny = 2
ky+1, n = 2k+1; for simplicity, we set
x = 2kx+1, y = 2ky+1, where kx, ky = bk2 c. We can
see that the time to compute the exponentiation may
range from seconds to centuries, depending on the de-
gree of information one is willing to reveal.
8 Conclusions and Future Works
A set of information theoretically secure two-party pro-
tocols have been developed based on scalar product. The
ultimate goal to design such protocols is to build a com-
piler for secure multiparty computation environments. The
protocols presented in this paper is part of protocol along
this line. More protocols need to be designed to achieve the
ultimate goal.
Although the pursuit of efficient general solutions to
SMC problems is admirable, a more modest but likely more
successful pursuit is to carefully consider tradeoff options
during the protocol design phase. In this paper, protocols
for secure two-party computation of exponentiation were
designed based on the repeated squaring algorithm using
scalar products as building blocks. A careful performance
evaluation was carried out in which an analysis of the execu-
tion time for our protocols was conducted by breaking them
into their constitutive building blocks and estimating the ex-
ecution times using the performance evaluation results of
our implemented Scalar-Product protocol. We noted that
the estimated execution times were comparable to those we
measured in the experimental runs of the protocols. This
suggests that using scalar products as building blocks may
make execution time estimation easier.
The results of this evaluation shed some light on the
tradeoffs between necessary execution time and the amount
of private information revealed as well as suggest future
research directions. Within the commodity-based secure
scalar product protocol, the results demonstrated that cer-
tain kinds of calculations, exponentiation using the repeated
squaring algorithm in this case, become infeasible if no in-
formation of the shared base and the exponent, except they
are in Zn, is provided. Future research directions include
designing more efficient protocols for cases where such se-
crecy is mandatory. Other kinds of calculations should also
be considered. Exponentiation was discussed in this paper
since it is widely used for various applications in many dis-
ciplines. Lastly, the proposed protocols can handle only in-
tegers. Hence we are also eager to extend them to handle
floating point numbers so that we can apply our work to
more real world applications.
References
[1] A. C. Yao, “Protocols for secure computation,” in
Proceedings of the 23rd Annual IEEE Symposium on
Foundations of Computer Science, November 1982,
pp. 160–164.
[2] O. Goldreich, S. Micali, and A. Wigderson, “How to
play any mental game,” in STOC ’87: Proceedings of
the 19th Annual ACM Symposium on Theory of Com-
20
[23] R. Canetti, “Security and composition of multi-
party cryptographic protocols,” Journal of Cryptology,
vol. 13, pp. 143–202, 2000.
[24] C.-H. Shen, J. Zhan, T.-S. Hsu, C.-J. Liau, and D.-W.
Wang, “Scalar-product based secure two-party com-
putation,” in GrC ’08: IEEE International Conference
on Granular Computing, Aug. 2008, pp. 556–561.
[25] J. D. Nielsen and M. I. Schwartzbach, “A domain-
specific programming language for secure multiparty
computation,” in PLAS ’07: Proceedings of the 2007
Workshop on Programming Languages and Analysis
for Security. New York, NY, USA: ACM, 2007, pp.
21–30.
[26] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and
C. Stein, Introduction to Algorithms, 2nd ed. Cam-
bridge, Massachusetts: The MIT Press, 2001.
Protocol Domain Constituents Times
Zn-to-Z2{k
′} Z2 Scalar-Product k
′
Z2-to-Zn{k
′} Zn Scalar-Product 1
Product Zn Scalar-Product 1
Square Zn Scalar-Product 1
Comparison
Z2 Zn-to-Z2{k} 1
Zn Z2-to-Zn{0} 1
Zero
Zn Product 1
Zn Comparison 2
If-Then-Else Zn Product 1
Shift-Left
Zn Exp(pb, se, ny) ∈ Zn 1
Zn Z2-to-Zn{k} 1
Zn Product 1
Z2 Zn-to-Z2{k} 1
Shift-Right Zn Shift-Left 1
Shift{s}
Z2 Zn-to-Z2{k} 1
Zn Z2-to-Zn{k − s} 1
Rotate-Left
Zn Exp(pb, se, ny) ∈ Zn 1
Zn2 Z2-to-Zn2{k} 2
Zn2 Product 1
Z2 Zn-to-Z2{k} 1
Z2 Zn2 -to-Z2{2k + 1} 1
Rotate-Right Zn Rotate-Left 1
Log
Zn Zn-to-Z2{k} 1
Zn Z2-to-Zn{0} k
Zn If-Then-Else k − 1
Div/Rem
Z2 Zn-to-Z2{k} 2
Zn2 Z2-to-Zn2{k} 2
Zn2 Comparison k
Zn2 If-Then-Else k
Function(x) Zn Scalar-Product 1
Function(x, y) Zn Scalar-Product 2
k+1 + 1
(flo) Scalar-Product
Zn Scalar-Product 1
Zn Shift 1
(flo) Square
Zn Scalar-Product 1
Zn Shift 1
(flo) Product
Zn Scalar-Product 1
Zn Shift 1
Table 1. Constituents of our protocols
22
Protocol Domain Constituents Times
Exp(sb, se, nx, ny)
Z2 Zn-to-Z2{kx} 1
Z2 Zn-to-Z2{ky} 1
Znx
ny Z2-to-Znxny {kx} 1
∈ Znxny
Znx
ny Z2-to-Znxny {0} ky + 1
Znx
ny If-Then-Else ky + 1
Znx
ny Square ky
Znx
ny Product ky
Exp(sb, se)
Z2 Zn-to-Z2{k} 2
Znn Z2-to-Znn{k} 1
Znn Z2-to-Znn{0} k + 1
∈ Znn Znn If-Then-Else k + 1
Znn Square k
Znn Product k
Exp(sb, se, nx)
Z2 Zn-to-Z2{kx} 1
Z2 Zn-to-Z2{k} 1
Znxn Z2-to-Znxn{kx} 1
∈ Znxn
Znxn Z2-to-Znxn{0} k + 1
Znxn If-Then-Else k + 1
Znxn Square k
Znxn Product k
Exp(sb, se, ny)
Z2 Zn-to-Z2{k} 1
Z2 Zn-to-Z2{ky} 1
Znny Z2-to-Znny {k} 1
∈ Znny
Znny Z2-to-Znny {0} ky + 1
Znny If-Then-Else ky + 1
Znny Square ky
Znny Product ky
Exp(pb x, se)
Z2 Zn-to-Z2{k} 1
∈ Zxn
Zxn Z2-to-Zxn{0} k + 1
Zxn If-Then-Else k
Exp(sb, pe y)
Z2 Zn-to-Z2{k} 1
Zny Z2-to-Zny{k} 1
∈ Zny Zny Square ky
Zny Product ky
Exp(pb x, se, ny)
Z2 Zn-to-Z2{ky} 1
∈ Zxny
Zxny Z2-to-Zxny {0} ky + 1
Zxny If-Then-Else ky
Exp(sb, pe y, nx)
Z2 Zn-to-Z2{kx} 1
Znxy Z2-to-Znxy{kx} 1
∈ Znxy Znxy Square ky
Znxy Product ky
Table 5. Constituents of the Exponentiation
tradeoff protocols
Protocol Domain Constituents Times
Exp(sb, se, nx, ny)
Z2 Zn-to-Z2{ky} 1
∈ Zn
Zn Z2-to-Zn{0} ky + 1
Zn If-Then-Else ky + 1
Zn Square ky
Zn Product ky
Exp(sb, se)
Z2 Zn-to-Z2{k} 1
∈ Zn
Zn Z2-to-Zn{0} k + 1
Zn If-Then-Else k + 1
Zn Square k
Zn Product k
Exp(sb, se, nx)
Z2 Zn-to-Z2{ky} 1
∈ Zn
Zn Z2-to-Zn{0} ky + 1
Zn If-Then-Else ky + 1
Zn Square ky
Zn Product ky
Exp(sb, se, ny)
Z2 Zn-to-Z2{ky} 1
∈ Zn
Zn Z2-to-Zn{0} ky + 1
Zn If-Then-Else ky + 1
Zn Square ky
Zn Product ky
Exp(pb x, se)
Z2 Zn-to-Z2{ky} 1
∈ Zn
Zn Z2-to-Zn{0} ky + 1
Zn If-Then-Else ky
Exp(sb, pe y) Zn Square ky
∈ Zn Zn Product ky
Exp(pb x, se, ny)
Z2 Zn-to-Z2{ky} 1
∈ Zn
Zn Z2-to-Zn{0} ky + 1
Zn If-Then-Else ky
Exp(sb, pe y, nx) Zn Square blog2 yc
∈ Zn Zn Product blog2 yc
Table 6. Constituents of the Exponentiation
tradeoff protocols
24
Protocol Domain Dimension Times
Div/Rem
Z2 3
kx
2 + kxky+
{kx, ky}
2kx + ky
Znx·ny 1 kx
Znx·ny 2 kx
Znx·ny kx + 1 1
Znx·ny ky + 1 1
Div/Rem
Z2 3 k(k − ky)
{divisor ky}
Zn 1 k − ky
Zn 2 k − ky
Div/Rem
Z2 3
kx
2 + kkx+
{dividend kx}
k + kx
Zn·nx 1 kx
Zn·nx 2 kx
Zn·nx k + 1 1
Table 10. The Scalar-Product Complexity of
the Div/Rem tradeoff protocols
k Experimental Time Estimated Time
9 5.08 4.02
10 7.50 7.88
11 27.65 26.50
12 129.21 119.66
Table 13. Experimental and estimated time
(seconds) of the Exp(sb, se) ∈ Znn protocol
26
Role CPU Operating System RAM
Commodity Server
Two AMD Opteron™ 2220 SE FreeBSD DDR2 667
2.81GHz (Dual-Core) 7.0-STABLE 20GB
Party 1
Two Intel® Xeon® X5365 FreeBSD DDR2 667
3.00GHz (Quad-Core) 7.0-STABLE 48GB
Party 2
Two Intel® Xeon® X5482 Ubuntu DDR2 800
3.20GHz (Quad-Core) 2.6.24-16-server 64GB
Table 11. The environment of our experiments
Dimension
k 1 2 3 4 5 8 16 32
0 0.0027 0.0028 0.0035 0.0029 0.0030 0.0030 0.0033 0.0037
1 0.0027 0.0028 0.0031 0.0029 0.0029 0.0030 0.0033 0.0037
2 0.0027 0.0028 0.0029 0.0028 0.0028 0.0030 0.0033 0.0036
3 0.0027 0.0028 0.0029 0.0030 0.0030 0.0031 0.0032 0.0036
4 0.0027 0.0028 0.0029 0.0030 0.0030 0.0030 0.0032 0.0036
7 0.0027 0.0028 0.0029 0.0030 0.0029 0.0030 0.0034 0.0036
15 0.0028 0.0029 0.0029 0.0029 0.0030 0.0030 0.0033 0.0038
31 0.0027 0.0027 0.0028 0.0030 0.0029 0.0032 0.0031 0.0040
63 0.0027 0.0029 0.0029 0.0029 0.0030 0.0031 0.0034 0.0046
127 0.0027 0.0030 0.0029 0.0030 0.0030 0.0031 0.0034 0.0041
255 0.0028 0.0030 0.0031 0.0031 0.0032 0.0031 0.0035 0.0042
511 0.0029 0.0030 0.0030 0.0032 0.0033 0.0033 0.0036 0.0042
1023 0.0033 0.0034 0.0034 0.0034 0.0034 0.0037 0.0039 0.0046
2047 0.3066 0.3063 0.3064 0.3063 0.3067 0.3067 0.3068 0.3076
4095 0.3099 0.3098 0.3099 0.3100 0.3099 0.3100 0.3106 0.3111
8191 0.2205 0.2205 0.2203 0.2204 0.2204 0.2205 0.2215 0.2215
16383 0.1823 0.2305 0.2647 0.2058 0.2253 0.2205 0.2645 0.2310
32767 0.3956 0.3898 0.3943 0.4198 0.4010 0.4098 0.4395 0.4270
65535 1.0598 1.0599 1.0618 1.0627 1.0726 1.0612 1.0604 1.0612
131071 4.2073 4.2026 4.2080 4.2186 4.2222 4.2114 4.2212 4.2219
262143 16.9002 16.8916 16.8791 16.8730 16.9086 16.8971 16.8941 16.8636
Table 12. The timings(seconds) of the commodity-based Scalar-Product protocol with different k and
different dimensions
28
Towards Efficient Privacy-Preserving Collaborative Recommender
Systems
Justin Zhan+, I-Cheng Wang∗, Chia-Lung Hsieh+,
Tsan-Sheng Hsu∗, Churn-Jung Liau∗, Da-Wei Wang∗
+The Heinz School,
Carnegie Mellon University, USA
Email: {justinzh, chialunh}@andrew.cmu.edu
∗Institute of Information Science,
Academia Sinica, Taiwan
Email: {icw, tshsu, liaucj, wdw}@iis.sinica.edu.tw
Abstract
Recommender systems use various types of informa-
tion to help customers find products of personalized in-
terest. To increase the usefulness of recommender sys-
tems in certain circumstances, it could be desirable to
merge recommender system databases between compa-
nies, thus expanding the data pool. This can lead to
privacy disclosure hazards that this paper addresses by
constructing an efficient privacy-preserving collabora-
tive recommender system based on the scalar product
protocol.
1 Introduction
A recommender system [9] is a web-based applica-
tion best known for its usage on e-commerce websites,
with the aim of helping customers in the decision mak-
ing and product selection process by providing a list
of recommended items. The most prominent exam-
ple is the online bookstore Amazon.com, where col-
laborative filtering techniques are used to find similar-
ities in users’ profiles based on their navigation and
buying history. The goal is to identify users who pre-
sumably have similar preferences and recommend items
that were bought by these related users. Another tech-
nical approach is content-based filtering, which builds
on the hypothesis that the preferred items of a sin-
gle user can be extrapolated from their preferences in
the past. The third approach is to use domain knowl-
edge to base the recommendations on a thorough un-
derstanding of the user’s current needs, comparable to
real-life sales situations. The recommendations are the
result of a reasoning process on domain knowledge that
also forms the basis for explaining to the user why an
item is proposed. Knowledge-based recommender sys-
tems explicitly elicit user preferences, i.e., they provide
dynamic personalized, and potentially persuasive, sales
dialogues.
Recommender systems can help consumers find the
most valuable items by calculating the similarities
among other consumers with collaborative filtering al-
gorithms. From the business point of view, recom-
mender systems have the potential to increase sales,
because purchasing decisions are often strongly influ-
enced by people who the consumer knows and trusts.
In the networked virtual world, consumers also need
some word of mouth to support their purchasing deci-
sions, thus, the best source will be recommender sys-
tems. Recommender systems can integrate informa-
tion from product rating matrices and user preference
similarity matrices to generate personalized recommen-
dations. It can also help corporations maximize the
precision of targeted marketing.
Im and Hars [6] have claimed that the accuracy of
a recommender system increases as the total number
of users increases. This implies that accuracy of a rec-
ommender system decreases when the total number of
users is limited. One way to solve this problem is to
join recommender systems if they have similar product
sets. By joining recommender systems, the user sets
are enlarged, which means more accurate recommenda-
tion can be made and the precision of targeted market-
ing is enhanced. In combining recommender systems,
consumers and companies may worry about the risk of
privacy disclosure.
Schafer et al. [10] have come up with a detailed
Authorized licensed use limited to: ACADEMIA SINICA COMPUTING CENTRE. Downloaded on April 12, 2009 at 03:15 from IEEE Xplore.  Restrictions apply.
In the n-dimensional item space, we can view dif-
ferent users as feature vectors. A user vector con-
sists of n feature slots, one for each available item.
The values used to fill those slots can either be
the rating rij that a user ui provided for the cor-
responding item, ij, or 0, if no such rating exists.
Now we can compute the proximity between two
users, ui and uk, by calculating the similarity be-
tween their vectors as the cosine of the angle is
formed between them.
Based on the results of Breese et al. [2], Pearson
Correlation is considered a better metric for similarity
calculations in recommender systems. Thus, we will
use Pearson correlation similarity.
2.3 Recommendation Generation
The final step in the recommendation process is to
produce either a prediction, which will be a numerical
value representing the predicted opinion of the active
user, or a recommendation that will be expressed as a
list of the top-N items that the active user will appre-
ciate. In both cases, the result should be based on the
neighborhood of users.
3 Problems
Let us assume there are two e-commerce entities, for
example, online bookstores, both of which have simi-
lar product sets, but with different customer sets. Also,
both of them already have their own recommender sys-
tems with some data records. These two entities want
to cooperate with each other to strengthen their rec-
ommender system databases and improve the precision
of their recommendations for their own customers. For
merging the recommender databases while not disclos-
ing the actual commercial data, we have to check the
recommender system algorithm to find the vulnerabil-
ity of potential privacy disclosure.
Among the three steps in the recommender system
algorithm, representation and recommendation gener-
ation are only related to the accuracy of recommenda-
tions provided to customers. The neighborhood forma-
tion step is the source of possible privacy disclosure. In
the neighborhood formation step, we measure the prox-
imity between two customers by calculating the Pear-
son correlation similarity. For example, let us assume
that, for item(product) j, the ratings of rij and rkj are
made by users ui and uk from different e-commerce
entities. While joining these two recommender system
databases, we have to share the values (rij − ri) and
(rkj − rk) with each other. But with value (rij − ri),
others can see how much user i prefers item j compared
to their average rating, ri.
4 Privacy-Preserving Collaborative
Recommender System
The database is separated into two parts, A and B,
which both need each other’s data to compute the cor-
relation coefficient without disclosing their own data.
The privacy issue is on the numerator of the Pearson
correlation coefficient, which is a scalar product. A has
−→
Xa and B has
−→
Xb. We want to know the scalar prod-
uct of
−→
Xa and
−→
Xb without disclosing
−→
Xa or
−→
Xb. We
will introduce two approaches: the homomorphic en-
cryption based approach and the scalar product based
approach.
4.1 Homomorphic Encryption Approach
Within the homomorphic encryption framework, we
introduce two approaches: one is based on ElGamal ho-
momorphic encryption [4]; the other is Paillier homo-
morphic encryption [7]. ElGamal encryption provides
the multiplicative homomorphism that works as fol-
lows: the multiplication of two cypher texts equals the
encryption of the multiplication of the plain texts. Pail-
lier encryption provides the additive homomorphism,
where the multiplication of two encrypted pieces of
data equals the encryption of the addition of the plain
text.
To compute the Pearson correlation similarity, we
need the operators of (rij − ri) from one party and
(rkj − rk) from the other one. Let us assume that
no party wants to take the risk of disclosing customer
preferences. Because the computations are multipli-
cations, we can use the homomorphic property of the
ElGamal encryption. Two parties can encrypt their
data on their own with a public key, and then after the
multiplication computation, the multiplication of two
encrypted pieces of data will become the encryption of
the multiplication of data. Thus, the private data of
two parties can be preserved during the similarity com-
putation. Through any of the above approaches, the
privacy of user preference can be preserved throughout
the computation of similarities.
4.2 The Scalar Product Approach
The problem of Secure Multiparty Computation
(SMC) was first addressed by Yao in his seminal pa-
per, ”Protocols for Secure Computations” [13]. The
security of these solutions is based on cryptographic as-
sumptions, such as the existence of trapdoor permuta-
3
Authorized licensed use limited to: ACADEMIA SINICA COMPUTING CENTRE. Downloaded on April 12, 2009 at 03:15 from IEEE Xplore.  Restrictions apply.
(a) Commodity Approach (b) ElGamal Approach (c) Revised Commodity Approach
(d) Transportation Time Comparison (e) CPU Time Comparison (f) Total Execution Time Comparison
Figure 1. Experimental Results
• Commodity Approach
We use Commodity Approach to stand for the orig-
inal commodity server based scalar product ap-
proach. Each round can compute a scalar prod-
uct. In other words, if there are N scalar products
needed to be computed, simply run this protocol
N times. Figure 1(a) shows the total execution,
transportation and CPU time of this approach. As
expected, all of them are linear.
• ElGamal Approach
We implemented the same algorithm as that
of Hsieh et al.[5] to compare the performance
of privacy-preserving recommender systems with
that of others. A neutral third party is unneces-
sary in this approach since only two random num-
bers are needed for Alice and Bob’s private keys.
Figure 1(b) shows the total execution, transporta-
tion, and CPU time of this approach.
• Revised Commodity Approach
It is much more reasonable to make sure that all
the needed pieces of data are ready before execut-
ing any multi-party computation. As a result, we
pre-produce and transport the random numbers
to A and B before executing the tasks. In other
words, the commodity server, which is the neutral
third party producing only random numbers, is
not necessarily included in computing transporta-
tion, CPU, and total execution time. Both A and
B know that they are going to do N scalar prod-
ucts, so they exchange all the needed information
in one round, rather than in N rounds. Figure
1(c) shows the total execution, transportation, and
CPU time of this approach.
6 Discussion
Figures 1(d), 1(e), and 1(f) compare the results
of transportation, CPU, and total execution time
among the aforementioned approaches. The revised
commodity-based approach has the lowest time cost
and needs the least computing resources among the
three approaches. Therefore, we can conclude that
the revised commodity-based approach has the best
performance. However, additional storage is needed
for random numbers. At the same time, the stored
random numbers must not be disclosed to each
party. In Figure 1(d), the ElGamal’s transportation
time line is not linear. A possible reason for this
is that Ruby uses a fixed-size buffer for IO. It may
become non-linear once the transportation data
5
Authorized licensed use limited to: ACADEMIA SINICA COMPUTING CENTRE. Downloaded on April 12, 2009 at 03:15 from IEEE Xplore.  Restrictions apply.
On Applying Secure Multi-party Computation: A Case
Report
I-Cheng Wanga, Kung Chenb, Jen-Hsiang Chuangc, Tsan-sheng Hsua,
Churn-Jung Liaua, Da-Wei Wanga
aInstitute of Information Science, Academia Sinica, Taiwan
bDepartment of Computer Science, National Chengchi University, Taiwan
cNational Health Command Center, Centers for Disease Control, Taiwan
Abstract
Secure multi-party computation, which was once a pure theoretical curiosity
has become one of the important tools for privacy enhancing technologies.
Many practical protocols have been proposed in numerous research articles.
However, until recently there is no real world application. We study how to
apply secure multi-party computation to a real medical research problem-
the measurement of dengue burden. We document the processes and report
our results. We also carry out performance evaluation so that the costs and
re-sources can be estimated for other applications. We find out that al-
though the technology is useful to preserve individual privacy, it alone is not
enough to transform all the medical researches into privacy preserving ones.
The reason is that researchers usually have to see some intermediate results
before they can decide the next step. However, the reveal of intermediate
results can be a threat to privacy. Finally, we present a list of questions and
steps that should be answered and carried out by medical experts and secure
multi-party computation engineers so that they can collaboratively accom-
plish their research goals via secure multi-party computation approaches.
Keywords: SMC, secure multi-party computation
1. Introduction
Many medical studies require statistical analysis that ’aggregate’ data
stored in multiple, distributed databases. For example, conducting a sur-
vival analysis on the discharged heart failure patients may require linking the
claims data and mortality data using personal identifiers. However, privacy
Preprint submitted to Nuclear Physics B July 23, 2010
different parties in Section 3. After that, we report the lessons we learned
from applying SMC to the case and the performance evaluation of our code
in Section 4. Lastly, we present our concluding remarks and future works in
Section 5.
2. Case of Measurement of Dengue Burden
Dengue fever (DF) has become a major international health issue [4]. In
Taiwan, outbreaks of indigenous dengue fever usually occur in the beginning
of summer in recent years. Especially in 2002, the outbreak in southern
Taiwan caused 5,388 cases of dengue fever, among which 242 cases were
dengue hemorrhagic fever (DHF) and 21 cases were deaths.
To measure the disease burden, CDC used the personal identifiers to link
the claims data of NHI to the notified dengue cases of CDC in the time pe-
riod from 2000 to 2007. The aggregated data were analyzed to estimate the
duration of the illness for calculating DALYs (disability-adjusted life years)
loss caused by dengue [5] [6]. Although the better designs to measure the
dengue disease burden may be the prospective cohort study or the retrospec-
tive study with chart review of medical records, these two approaches are
expensive and rarely ready for data linkage. National Health Insurance pro-
gram in Taiwan covers over 99% of the population. Although using claims
data for clinical research are frequently criticized by their questionable ac-
curacy, completeness, clinical scope, and meaningfulness, they are ready to
use, relative inexpensive, and computer readable. For these reasons, CDC
decided to use claims data to link with notified dengue data for studying
national dengue burden in Taiwan.
Although both NHI and CDC are affiliated to the Department of Health,
Taiwan, they operate in a rather independent manner. Hence, it took CDC
a lot of efforts to get the claims data of NHI. To implement the study, CDC
first contacted the Deputy CEO of NHI and invited him to participate in
the study as a co-principal investigator. The study later was approved by
the institutional review board at CDC. To protect patient privacy, they en-
crypted the personal identifiers before linking the data between these two
organizations. Admittedly, for public accessible data, encrypting ID alone is
not sufficient for privacy protection purpose [7]. But the data to link together
are limited to these two government agencies rather than open to the pub-
lic. Thus, to get better data quality, CDC and NHI did not take additional
privacy protection measures.
3
ID Visit Date Cure End Date ICD9-CM(Outpatient Service)
1 2007.08.30 2007.08.30 41401
2 2001.06.28 7806
3
2005.08.27 4659
2005.08.28 2005.08.28 53550
...
...
...
...
22999998 2002.11.12 061
22999999 2002.10.31 2002.11.02 53540
23000000
2001.12.04 2419
2002.09.18 2002.09.18 061
2006.11.17 2006.11.17 38612
Table 3: An example of raw data from NHI (Outpatient Service)
The measurement period is from 2000 to 2007, during which there were
9,939 patients confirmed with dengue or dengue hemorrhagic fever in Taiwan.
After removing the invalid personal identifiers, CDC used the 9,772 records
(including 9,470 DF and 302 DHF) to link the NHI data (Table 4). Finally,
CDC identified the 9,286 patients (95%) using the medical services during the
specific period. After retrieving the outpatient and hospitalization records,
CDC started to design the algorithm for calculating the duration of illness
and then calculated the DALYs for each DF and DHF patient.
CDC
DF DHF Total
(N=9,470) (N=302) (N=9,772)
N
H
I Outpatients 8,920 300 9,220
Admissions 5,689 288 5,977
Patients 8,986 300 9,286
Table 4: One of results of the study
3. Using SMC to compute Dengue Burden
In this section, we discuss the problem of database alignment, provide
solutions to overcome this problem, and give concrete examples that help
readers understand our approach. Besides that, we expatiate how we apply
5
Table 6: Well-aligned datasets for Alice and Bob
Table 7: The imagined, integrated dataset
3. If the common set U is very small, Alice and Bob can easily guess that
each other’s number of records (IDs) is not greater than the size of U,
which may infringe upon their privacy.
4. If there is no common set of universal IDs, it will be difficult to align
the data sets since Alice and Bob do not know how to sort their records
(IDs).
For the CDC and NHI case as mentioned in Section 2, the database is both
vertically and horizontally partitioned. Firstly, CDC and NHI have different
columns (categories) of records for each ID, so we can view it as a vertically
partitioned database. Secondly, CDC has records for all patients, including
7
ID Disease
1 DF
2 DF
3
...
...
22999998 DHF
22999999
23000000 DF
Table 8: An example database transformed from raw data in CDC
ID Outpatient service Hospitalization
1 Yes No
2 No No
3 No Yes
...
...
...
22999998 No Yes
22999999 Yes No
23000000 No No
Table 9: An example database transformed from raw data in NHI
”HOS.” If the person (ID) has an outpatient service/hospitalization record
as Table 9 shown, the ”OUT”/” HOS” bit will be ”1”; otherwise it will
be ”0”. Table 10 and Table 11 show the data prepared by CDC and NHI
respectively. Let Alice have vector , and let Bob have vector ; a secure scalar
product protocol would enable the two parties to compute the scalar product
of A and B without revealing any information about or [8] [9].
Let U be an universal set, and , be the characteristic functions for two
sets respectively, then it is easy to see that after the ”and” operation on the
two vectors, we will get the characteristic function of the intersection of the
two sets. Therefore, the scalar product of these two vectors would be the
size of the intersection. By executing a secure scalar product protocol for
6 times, they can get the same results as Table 4 shown without merging
their databases. (Table 12) For instance, the summation of the product of
the ”DF” bit and the ”OUT” bit for each person will be equal to the number
of people who have DF and outpatient service records. That is the scalar
9
4. Findings and performance evaluation
The process and the approach described in Section 3 are derived after
several rounds of discussions. Here we summarize the steps we would take if
we will work on a similar project again. We believe this can be of practical
values for other researchers.
4.1. Problem analysis phase
1. List formulae and computation steps. What are the final results that
you want to get? Imagine that databases are merged, and try to write
the pseudo code or draw a flow chart to get your final results.
2. List all data involved in the study, data types (integer, floating number,
string, etc.) and which parties they belong to. Among these data,
which are secrets not to be revealed to each other? A sample outcome
of this step is Table 13.
Data Data Type Owner Secret
ID String CDC and NHI No
Disease String CDC Yes
On Set Date,
String CDC No*
Report Date
Admission Date,
String NHI Yes
Discharge Date,
ICD9-CM(Hospitalization),
Function Date,
Cure End Date,
ICD9-CM(Outpatient Service)
Table 13: Information of the involved data
3. Find out the maximum and minimum values of every kind of involved
data. If the maximum or minimum values are secrets, what are their
natural ranges?
4. Describe available computing resources. In our example, CDC and
NHI can either provide or designate computers to execute the SMC
protocols. If a trusted third party, serving as a commodity server, is
necessary, identify an institution to serve for that purpose.
11
the average of 100 effective executions. It costs about 390 seconds to do one
secure scalar product and less than 40 minutes to get the same results (when
the domain = 216). Moreover, with the same hardware environment and the
same operating systems, we can properly estimate the execution time with
arbitrary number of people (arbitrary dimension of the scalar product) [12].
Table 15: Simulated data for CDC and NHI
Table 16: The environment for our experiments
In addition, with 4 secure scalar products, we can get the DHF results in less
than 30 minutes, as shown in Table 17. Lastly, with 6 secure scalar products,
we can get the DF results in less than 40 minutes, as shown in Table 18.
13
Table 18: The classification of DF patients
for programmers. We feel that it might be possible to employ a compilation
approach to translate high level protocols to SMC modules, e.g. using the
secure scalar product as the building block.
Other important aspects include the acceptance and adoption of such
technology by experts in ethics and laws. With more studies on apply-
ing SMC to real applications reported and by continuously communicating
among computer scientists, medical researchers, and ELSI experts, we might
be able to economically carry out researches which conceptually demand link-
ing sensitive data sets in a way that no real data aggregation is executed.
References
[1] A. C. Yao, Protocols for secure computations, in: SFCS ’82: Proceedings
of the 23rd Annual Symposium on Foundations of Computer Science,
IEEE Computer Society, Washington, DC, USA, 1982, pp. 160–164.
doi:http://dx.doi.org/10.1109/SFCS.1982.88.
[2] O. Goldreich, S. Micali, A. Wigderson, How to play any mental game,
in: STOC ’87: Proceedings of the nineteenth annual ACM symposium
on Theory of computing, ACM, New York, NY, USA, 1987, pp. 218–229.
doi:http://doi.acm.org/10.1145/28395.28420.
15
and Reviews, IEEE Transactions on 39 (4) (2009) 440 –447.
doi:http://dx.doi.org/10.1109/TSMCC.2009.2016430.
[12] I.-C. Wang, C.-H. Shen, K. Chen, T. sheng Hsu, C.-J. Liau, D.-
W. Wang, An empirical study on privacy and secure multi-party
computation using exponentiation, Computational Science and En-
gineering, IEEE International Conference on 3 (2009) 182–188.
doi:http://doi.ieeecomputersociety.org/10.1109/CSE.2009.374.
17
 2
 1:00 PM – 4:00 PM Keynote Session 參與 
07/20  8:00 AM – 12:00 PM Keynote Session 參與 
 1:00 PM – 6:00 PM Keynote Session 參與 
07/21  8:00 AM – 12:00 PM Keynote Session 參與 
 1:00 PM – 3:00 PM Keynote Session 參與 
二、與會心得 
這次我參加的 GCA 研討會是第一次參加國際性研討會，The 2011 World Congress in 
Computer Science Computer Engineering and Applied Computing 是由 22 個 joint 
conferences，每個研討會都有它不同的 Topics，GCA 是其中的一個。在這次的會議
上收取到了不少的專業知識，在會議中聽取了許多在 Grid 環境的新應用，例如：在
Grid 環境中利用 Matrix 來做 resource discovery，這是篇伊朗的研究論文，是個
效率及簡單方法，可以降低 discovery cost 及 update cost，除此之外，希望藉由
此行中，可以激盪出未來可以的增進方法，進而達到增強監控系統的功能。我們的研
究是基於 Nagios 所發展出的監控系統，在這此的會議中和與會者進行討論與心得交
換後，發現可以與現在熱門的 cloud computing 做進一步的結合，或許考慮其他 grid 
system 的結合。如此一來就可以將我們所提出監控系統的優點推廣等多不同的應用。
因此，這此的會議聽取別人的報告及討論交換意見後讓我們可以思考如何將整個監控
系統達到更健全。 
這次研討會行除了聽取 Grid computing 應用之外，我們也聽了不少的 Keynote，
印象最深的就由 Dr. Sandeep Chatterjee 所報告的 Topic，演講內容是說明現今的 
 4
研討會論文集及光碟片 
六、其他 
無 
  
32                                                                                                            Int’l Conf. Grid Computing and Applications |  GCA’ 11 |     
thus, special mechanisms must be designed and incorporated 
into the system to satisfy the specific requirements of the 
environment.  
Some researchers, such as Zanikolas [6] and Massie [14], 
have observed that designers typically need to consider 
several features before implementing a monitoring system.  
According to our survey, the key design features of 
monitoring systems include scalability, extensibility, 
portability, robustness, manageability, reasonable overhead, 
and security. After conducting a thorough survey, we chose 
the Nagios open source program for our implementation. 
Nagios is utilized by several monitoring systems, such as 
GridICE and EGEE [15][16][17], and is supported by a 
strong open source community, e.g. NRPE, NDOUtils, and 
PNP [17][18][19]. However, Nagios does not support the 
SRB/iRODS system or the graphical visualization of the 
Nagios front-end website; instead it just provides regular 
notifications via E-mail. Besides, the Nagios monitoring 
system causes malfunctions and stops entirely if an error 
occurs in one of the monitoring hosts. This problem could be 
avoided if the system contained an effective backup 
mechanism, because a backup monitoring host would take 
over immediately and the service would not be interrupted.  
Nagios is integrated with the monitoring architecture, 
which oversees the SRB/iRODS system and servers in the 
distributed environment. The SIAM system, which works 
independently of the computing system, tracks the activities 
of servers and the computing system, and uses several real-
time notification services to inform system administrators 
when faults occur. Since SIAM utilizes Nagios open source 
software, it can be extended and maintained based on the 
requirements of the system components and services. As well 
as being extendable, it is readily available, efficient, and easy 
to integrate. SIAM provides an appropriate infrastructure for 
monitoring a data system environment; hence, it can easily 
detect the real-time status of the servers and systems. It also 
contains a fully tested fault-tolerance mechanism and only 
incurs a small additional overhead. When a system 
malfunctions suddenly or shuts down, SIAM prevents a total 
failure by enabling the system to reboot and continue 
operations immediately. In this paper, we implement a 
monitoring system based on Nagios for a grid environment, 
and test its ability to extend the monitoring function.  
The remainder of this paper is organized as follows. In 
Section 2, we review existing monitoring system architectures. 
In Section 3, we describe the proposed extension of the 
Sinica SRB/iRODS Monitoring System; and in Section 4, we 
evaluate the system’s performance. Section 5 contains some 
concluding remarks. 
2 Survey of related software 
 In this section, we compare four widely used monitoring 
systems, and discuss their limitations. We discuss Nagios in 
more detail because it provides the basis for our system. 
Three known extensions of Nagios are also considered. 
Monitoring systems like Ganglia, Cacti, Hawkeye, and 
Nagios provide basic functionality for monitoring hosts, 
services, and resources. We describe those systems below. 
 
 
Monitoring 
System 
Advantages 
Ganglia 
Scalable architecture (clusters in particular) 
Graphic support 
Basic historical data analysis 
Cacti 
Excellent graphic displays 
Web management interface  
Hawkeye 
Notification mechanism 
Multiplatform  
Possible custom-made sensors 
Nagios 
Excellent extensibility  
Notification mechanism  
Low overload 
Monitoring 
System 
Disadvantages 
Ganglia 
No web management interface  
Complicated system settings  
Cacti 
Poor extensibility 
No notification mechanism 
Hawkeye 
Poor front-end 
The system is under-developed 
Nagios 
No graphic display support 
No web management interface 
Monitoring 
System 
Key Design Features  
Ganglia 
Scalability 
Robustness 
Reasonable Overhead 
Portability 
Cacti 
Manageability 
Robustness 
Overhead 
Hawkeye 
Scalability  
Extensibility 
Overhead 
Nagios 
Scalability 
Extensibility 
Robustness 
Security 
Overhead 
Ganglia, an open source distributed monitoring system 
developed by the UC Berkeley Millennium Project [11][14], 
has a hierarchical architecture and relies on a multicast-based 
announce protocol to monitor the states of systems. It also 
uses technologies like XML for data representation, PHP for 
web development, and RRDTool (Round Robin Database) for 
data visualization. RRDTool is a popular application for 
storing time series data in graphic form [9][20]. 
Cacti is a network monitoring system that presents the 
system performance in graphic form [12]. It utilizes the 
SNMP protocol to collect information from various 
monitoring machines, RRDTool for the graphical 
presentation of monitoring information on web homepages, 
and a MySQL database for data storage.  
Hawkeye, developed by the Condor group, is designed to 
monitor distributed systems [8][13]. It is implemented in two 
stages. First, using the Condor ClassAd Language, Hawkeye 
identifies problems based on the attribute values of the 
resources, namely, a ClassAd. Second, the manager can 
Table 1. The comparison of different monitoring system. 
  
34                                                                                                            Int’l Conf. Grid Computing and Applications |  GCA’ 11 |     
monitoring application will wait for a period of time and then 
try to perform the login operation again. The process is 
repeated up to three times, after which the monitoring system 
immediately notifies the system administrators of the failed 
login attempt. 
3.1.2 System error detections 
 The data preservation system keeps track of error 
messages and system processes and stores the information in 
log files. SIAM parses the files so that the monitoring system 
can identify important messages about the computing system 
and related components in the preservation system. When 
SIAM finds error messages, it identifies the relevant 
information and notifies the system administrators. Thus, the 
parser tool helps system administrators trace faults in the 
system and take remedial action immediately. The parser tool 
also allows users to define the rules to specify the tasks that 
should be executed if an error occurs. In summary, the parser 
tool is responsible for: periodically parsing the log files 
created by the systems and servers on the monitoring host; 
filtering out error messages or error strings in the log files; 
and recording detected errors or error strings, and sending 
warning messages to the system administrators. 
3.1.3 Resource management  
 The data preservation system provides users with a logic 
space resource to store data. It uses a disk array as a storage 
space, and SIAM monitors the used capacity of all disk 
partitions simultaneously. The number of monitoring disks in 
the SIAM system depends on the size of each disk array. If 
the used disk space exceeds a pre-defined limit, the system 
will display a “Warning” or “Critical” signal. Users can 
customize the threshold value of each used disk space and the 
displayed signals according to their needs. 
3.2 Advanced features of SIAM system  
3.2.1 Real-time notification services  
 In general, Nagios does not support the SRB/iRODS 
system, and it only provides notifications via E-mail message. 
In contrast, our monitoring system utilizes various 
communication protocols to provide a notification service, 
e.g., e-mail, mobile phones, web pages, and other on-demand 
services. SIAM can track the status of all systems and servers 
in the cloud, and detect errors that occur in the data 
preservation system. It then alerts system administrators via 
real-time cloud notification services. SIAM enhances the 
notification mechanism by supporting other real-time cloud 
notification services, such as Windows Live Messenger 
(MSN) and Short Message Service (SMS) on mobile phones.  
As defined in the system configuration file, when SIAM 
discovers an error message, the monitoring system orders the 
MSN robot to transmit a message to the Microsoft MSN 
server via the Microsoft Notification Protocol (MSNP), and 
send a message to the specified MSN account. It can also use 
Perl script to send a message to the system administrator’s 
mobile phone. SIAM ranks the levels of error messages by 
their importance, and sends corresponding notification 
messages to the system administrators. For example, when a 
system server fails or shuts down unexpectedly, SIAM 
dispatches a critical message to the administrator’s mobile 
phone immediately. At the same time, the system 
administrator will receive an error message vial MSN or e-
mail. These real-time notification services help administrators 
manage their systems effectively. 
3.2.2 Fault-tolerance scheme  
 The SIAM monitoring system works independently of 
grid systems and provides a fault-tolerance mechanism to 
improve the reliability of monitoring services. Since the 
Nagios system does not support such a mechanism, SIAM 
implements a failover handler as the fault-tolerance scheme, 
as shown in Figure 2. The failover handler operates as 
follows. First, all files are backed up from the SIAM master 
host to the slave host, which is monitored by the SIAM 
monitoring system, as shown in steps 1 and 2. After installing 
the MySQL database between the master host and the slave 
host, both hosts execute their MySQL replication applications 
via the database. This ensures that the information backed up 
between the two hosts is consistent (step 3). If SIAM detects 
a critical fault or the master host fails, the slave host will send 
notification messages to the system administrators by e-mail, 
MSN, or SMS (step 4). The SIAM backup file is then 
decompressed automatically, and the slave host is substituted 
for the master host. Specifically, the slave host reboots and 
takes over as the new master host (steps 6 and 7). In this way, 
the failover handler ensures that 1) the monitoring service is 
not interrupted; 2) system administrators receive warning 
messages immediately so that they can take remedial action; 
and 3) data is not lost in the event of a serious system failure. 
The use of master and slave hosts results in a lower overhead 
and enhanced scalability in the distributed system. 
 
Figure 2. The SIAM fault-tolerance framework 
3.3 SIAM system components  
 SIAM is designed for an SRB/iRODS-based data 
preservation system. In this subsection, we present the 
components of SIAM by mapping each one to a specific 
monitoring phase. The system contains five levels, and 
utilizes the Nagios Core and the standard interface to display 
data about various resources, services, and hosts (Figure 3).  
  
36                                                                                                            Int’l Conf. Grid Computing and Applications |  GCA’ 11 |     
 
Figure 4.  Services availability checks. 
 
Figure 5.  SMS, MSN and E-mail notification dialogue. 
 
Figure 6.  Real-time notification message dialogue. 
 
Figure 7.  Resource management. 
 
 
Figure 8.  (a) The web page provided by the master host.  
(b) The web page provided by the slave host after failover. 
4.3 Performance evaluation  
Several important factors must be considered when 
evaluating the performance of SIAM, including resource 
utilization, error notification time, and system robustness. 
Resource utilization means the amount of the monitoring 
host’s operating space that SIAM occupies while executing 
tasks. The notification time, which is set by the SIAM system, 
is the time required to dispatch notification messages when a 
system server fails. Robustness refers to a slave host’s ability 
to take over from a master host in the event of a failure. 
The first experiment considers the resource utilization of 
SIAM. In the event that the master host generates an 
unexpectedly large number of CRITICAL messages (such as 
50,100, 200, or 300, as shown in Table 2), the operation 
consumes less than 1.0% of the CPU resources and 0.1% of 
the memory. In Figure 9, we plot the percentage average CPU 
usage and memory usage against the number of messages. 
The graph shows that, although the volume of messages 
increases significantly, the average resource consumption is 
relatively small.  Furthermore, since monitored nodes use the 
Nagios NRPE command, SIAM occupies less system space, 
which in turn reduces the system overhead. 
Table 2.  The simulation results of resource utilization. 
Monitoring 
Host 
Resource Utilization  
50 
Critical 
Messages  
100 
Critical 
Messages 
200 
Critical 
Messages 
300 
Critical 
Messages 
CPU 
Utilization 
0.3% 0.3% 0.5% 0.7% 
Memory 
Utilization 
0.1% 0.1% 0.1% 0.1% 
 
 
Figure 9. SIAM resource utilization. 
The second experiment considers the notification time. 
One advantage of SIAM is that it can be customized to send 
out messages at different rates. In this experiment, the 
monitoring time interval is set at 60 minutes; that is, the 
system only checks for errors every 60 minutes. When the 
SIAM host detects a system failure in a monitored host, 
depending on the severity of the error, SIAM should notify 
the system administrators as user’s required after the failure is 
detected. For example, if SIAM is configured to notify system 
administrators within 3 minutes of detecting a failure and the 
monitoring time interval is 60 minutes, then, in the worst case, 
SIAM will dispatch an alert message 62 minutes and 59 
seconds (3779 seconds) after an error occurs. In the best case, 
where an error occurs exactly at the beginning of an interval, 
SIAM will respond within three minutes (180 seconds). When 
SIAM dispatches an alert, system administrators are notified 
immediately (in less than one minute) via real-time cloud 
services, such as MSN, SMS and e-mail. Generally, these 
three methods are equally fast. SMS is particularly convenient 
since mobile devices are portable, so administrators can 
receive notifications anytime, anywhere. Table 3 summarizes 
the notification times and notified service transfer times in the 
experiment. 
The third experiment examines the robustness of the 
failover scheme in terms of the failover time (Table 3). Here, 
we assume that the monitoring time interval is ten minutes, 
國科會補助計畫衍生研發成果推廣資料表
日期:2011/11/25
國科會補助計畫
計畫名稱: 多方私密計算應用於隱私保護之理論與實務
計畫主持人: 王大為
計畫編號: 97-2221-E-001-013-MY3 學門領域: 資訊安全
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
