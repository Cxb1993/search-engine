行政院國家科學委員會補助專題研究計畫 
■成果報告   
□期中進度報告 
 
在無線感測網路一種利用虛擬座標容錯可靠及保證封包送達的繞徑
方法（3/3） 
 
 
計畫類別：■個別型計畫   □整合型計畫 
計畫編號：NSC 97－2221－E－007－042－MY3 
執行期間：97年 08月 01日至 100年 07月 31日 
 
執行機構及系所：國立清華大學資訊工程學系（所） 
 
計畫主持人：蔡明哲 
計畫參與人員：博班研究生-兼任助理：林佳宏、柯崴傑、董育萍、鄭元博 
郭建志、湯曜任、陳以雷 
碩班研究生-兼任助理：許書豪、郭桐惟、游振威、許倍源 
大學畢業生-專任助理：劉晉榮 
 
成果報告類型(依經費核定清單規定繳交)：□精簡報告  ■完整報告 
 
本計畫除繳交成果報告外，另須繳交以下出國心得報告： 
□赴國外出差或研習心得報告 
□赴大陸地區出差或研習心得報告 
■出席國際學術會議心得報告 
□國際合作研究計畫國外研究報告 
 
 
處理方式：除列管計畫及下列情形者外，得立即公開查詢 
            □涉及專利或其他智慧財產權，□一年■二年後可公開查詢 
 
中   華   民   國  100年 10月 19日 
II 
 
Abstract 
A wireless sensor network is composed of multiple wireless sensors. Each sensor is able to collect, 
process, and store environmental information as well as communicate with others via inter-sensor 
communication. Routing is an important issue that affects wireless sensor networks. Many routing protocols 
based on virtual coordinates are proposed in wireless sensor networks without GPS assistance. In these 
works, some cannot guarantee packet delivery in discrete domain and some need to memorize a graph 
having the global topological features, consuming, in the process, a great deal of message broadcast 
overhead. We have proposed ABVCap and ABVCap_Uni which are the first routing protocols, in the 
literature, able to guarantee packet delivery in discrete domain without computation and storage of the 
global topological features in wireless sensor networks with bidirectional and unidirectional links, 
respectively. However, both of ABVCap and ABVCap_Uni assume that no node switches off or runs out of 
batteries (no faulty node) and there is no packet loss due to the link quality and interference, which is 
impractical in real environment. In this project, we develop an approach, ABVCap maintenance, to 
reconstruct an ABVCap virtual coordinate system in a network with node failures. In addition, we develop a 
method capable of augmenting virtual-coordinate-based routing protocols to guarantee packet delivery. The 
virtual face construction and naming protocols are developed to construct and name virtual faces, 
respectively. To route a packet from a dead-end node to a progress node, the VirtualFace algorithm is 
presented by traversing the boundaries of the virtual faces from face to face. 
 
Keywords: wireless sensor networks, routing protocol, fault tolerant, guaranteed delivery 
 
 
 
  
1 
 
報告內容 
一、前言 
A wireless sensor network is composed of multiple wireless sensors. Each sensor is able to collect, 
process, and store environmental information as well as communicate with others via inter-sensor 
communication. The rapid development of wireless communications and embedded micro-sensing 
technologies facilitate the use of wireless sensor networks in our daily lives; a wide range of applications 
exist for wireless sensor networks, including environmental monitoring, battle-field surveillance, health care, 
nuclear, biological, and chemical (NBC) attack detection, intruder detection, etc. Recently, studies of 
wireless sensor networks have received considerable attention 0, [2], [3]. In wireless sensor networks, 
routing is an important issue that has a significant impact on the network performance. In this project, we 
undertake the development of routing protocols in wireless sensor networks. 
 
二、研究目的 
In geographic routing, the physical location is used as the node address. The source node determines 
the destination address by looking it up from the location server [4], or by computing it using a hash 
function in a data-centric storage scheme [5]. The node usually forwards the packet to a neighbor closer to 
the destination. This, however, may bring the packet to a dead-end node, a node with no neighbor closer to 
the destination. GPSR [6] and GFG [7] routing use the FACE algorithm on a planar graph to deal with the 
dead-end node problem. In addition, GSR routing [8] and a combination of the FACE algorithm and the 
shortcut-based procedure [9] are proposed to improve routing efficiency. GSR routing builds a planar 
routing subgraph RDG (Restricted Delaunay Graph) so that there exists a path whose distance, in terms of 
Euclidean distance or hop distance, in RDG is only the constant times to the minimum distance between any 
pair of nodes. In Fang et al. [10] and Kuhn et al. [11], methods for mapping holes and routing around holes 
are proposed. In geographic routing, nodes are required to have accurate geographic information that is 
difficult to obtain because GPS devices are expensive, do not work indoors, and has measurement error.  
Routing protocols based on virtual coordinates are proposed in wireless sensor networks without GPS 
assistance. Through an iterative procedure, a relaxation algorithm [12] assigns virtual coordinates to nodes 
that are close to their physical locations, consuming, in the process, a great deal of message broadcast 
overhead. This method does not guarantee packet delivery because the FACE algorithm cannot be used to 
solve the dead-end node problem due to the local error of the virtual coordinate assignment [13]. A survey of 
methods for assigning virtual coordinates to nodes similar to the real ones can be found in [14]. GLIDER 
[15] is a landmark-based routing scheme, in which all nodes are divided into cells by the landmark Voronoi 
complex. The connections between neighboring cells are represented as combinatorial Delaunay 
3 
 
maximum hop distance from W, Y is the node with the maximum hop distance from X, and Z is the node 
with the maximum hop distance from W among all nodes whose x and y coordinates each satisfy the 
relationship, 𝑥 =  𝑦 ± 1. In case of a tie, the node with the maximum ID is selected. 
VCap proceeds in a four-phase process. In the first phase, each node is assigned a w coordinate that 
denotes the hop distance from W by the following method. Once the network is deployed, W assigns its w 
coordinate to 0 and generates a W_SET message containing a hop counter that is initially set to 1 and 
advanced in increments by the forwarding nodes. The other node broadcasts the W_SET message and 
assigns its w coordinate to the hop counter contained in the W_SET message received. If a node receives 
more than one W_SET message, the node assigns the w coordinate to the smallest hop counter and 
broadcasts the message containing the smallest hop counter. The second phase initiates after the w 
coordinates have been assigned to all nodes. Each node first broadcasts the ID and the w coordinate of the 
node with the maximum w coordinate in the 1-hop neighborhood, or, in case of a tie, the node with the 
maximum ID, which is obtained in the first phase. Subsequently, each node with the maximum w coordinate 
in the 2-hop neighborhood, or, in case of a tie, the node with the maximum ID, assigns its x coordinate to 0 
and generates an X_SET message containing its ID, its w coordinate, and a hop counter that is initially set to 
1 and advanced in increments by the forwarding nodes. The node broadcasts the X_SET message and 
assigns its x coordinate to the hop counter contained in the X_SET message received that was generated by 
the node with the maximum w coordinate, or, in case of a tie, the node with the maximum ID. If a node 
receives more than one X_SET message generated by a node, the node assigns the x coordinate to the 
smallest hop counter and broadcasts the message containing the smallest hop counter. The y and z 
coordinates are assigned in a manner analogous to that for the x coordinate in the third and fourth phases, 
which initiates after all nodes have been assigned the x and y coordinates, respectively.  
In VCap routing, each node forwards the packet to a neighbor with closer and the minimal distance 
from the destination. The distance between two nodes with the virtual coordinates (x1, y1, z1)  and 
(x2, y2, z2) is defined as a √(x2 − x1)2 + (y2 − y1)2 + (z2 − z1)2. When the packet is routed to a node in 
the zone of the destination, the packet is forwarded to the destination using proactive routing, in which a 
zone denotes a set of nodes with the same virtual coordinate. Because many zones are disconnected, 
proactive routing cannot always route a packet to the destination even if the packet reaches the zone of the 
destination. In addition, the state in which each node has at least one neighbor with a closer distance from 
the destination of any packet is difficult to achieve; therefore, VCap routing may convey the packet to a 
dead-end node. Consequently, packet delivery is not guaranteed. 
四、研究方法 
In this project, we first develop an approach, ABVCap maintenance, to reconstruct an ABVCap virtual 
coordinate system, and then develop an algorithm, VirtualFace, to route a packet from a dead-end node to a 
progress node by traversing the boundaries of the virtual faces from face to face. The approaches of 
ABVCap maintenance and VirtualFace are described in subsections A and B, respectively. In subsection C, 
we analyze the message overhead encountered using proposed protocols, the route stretch of ABVCap 
5 
 
the shortest path to the longitude head that has the smallest longitude distance from 𝐿𝐻(𝑘) among all 
longitude heads generating the Equator_REP messages and having a smaller longitude coordinate than 
𝐿𝐻(𝑘). In addition, if new anchor X is not in the 1-hop neighborhood of 𝐿𝐻(1), the shortest path is 
established between new anchor X and 𝐿𝐻(1). 
Once the shortest path between 𝐿𝐻(𝑗) and 𝐿𝐻(𝑘) is established, nodes on the path create virtual 
nodes that are assigned the longitude coordinates in an increasing order, as implemented in the following. 
The Equator_RESET message generated by 𝐿𝐻(𝑘) contains the ratio of the longitude distance between 
LH(j) and 𝐿𝐻(𝑘) to the hop distance between 𝐿𝐻(𝑗) and 𝐿𝐻(𝑘) (the longitude distance per hop). Each 
node that receives the Equator_RESET message creates a new virtual node with the latitude coordinate equal 
to 0 and the longitude coordinate equal to the longitude coordinate of 𝐿𝐻(𝑗) plus the multiplication of the 
longitude distance per hop and the hop distance from 𝐿𝐻(𝑗). The ripple, up, and down coordinates of the 
new virtual nodes are initially set to ∞. Note that if the longitude distance per hop is larger than 1, a 
longitude head is not assigned to every longitude region. In this case, the longitude distance per hop 
contained in the Equator_RESET message is set to 1, and 𝐿𝐻(𝑘) creates i virtual nodes to be longitude 
heads 𝐿𝐻(𝑘 − 𝑖), … , 𝐿𝐻(𝑘 − 1), where i denotes the longitude distance between 𝐿𝐻(𝑗) and 𝐿𝐻(𝑘) minus 
the hop distance between 𝐿𝐻(𝑗) and 𝐿𝐻(𝑘). 
After the reconstruction of the equator, the longitude coordinate of a virtual node on the equator could 
be a non-integer. In this project, the virtual node with the longitude coordinate equal to i is said to be in 
longitude region ⌊𝑖⌋. A virtual node on the equator is the longitude head 𝐿𝐻(𝑖) and the cell head 𝐶𝐻(𝑖, 0), 
if it has the smallest longitude coordinate among all virtual nodes on the equator in longitude region i. A 
virtual node resets the ripple coordinate to 0 if it is a longitude head.  
Furthermore, if 𝐿𝐻(𝑖) fails, a new 𝐿𝐻(𝑖) is first generated in the reconstruction of the equator. 
Subsequently, each of the i-th meridians from 𝐿𝐻(𝑖) to anchor Z and the i-th meridian from 𝐿𝐻(𝑖) to 
anchor Z’ are reconstructed in a manner analogous to that for the reconstruction of the equator from anchor 
X to anchor Y. Each virtual node with the latitude coordinate equal to j on the i-th meridian is the cell head 
𝐶𝐻(𝑖, 𝑗), where j could be a non-integer. The ripple coordinate of each cell head is set to 0, and the up and 
down coordinates are initially set to ∞. 
 
A.3 Update of Ripple, Up, and Down Coordinates  
If a virtual node that is not a cell head has no neighbor with a smaller ripple coordinate in the same cell 
region, it updates the ripple coordinate to ∞. Once a virtual node updates the ripple coordinate, it 
broadcasts a RP_CHANGE message containing its longitude, latitude, and updated ripple coordinates. A 
virtual node that is not a cell head checks if it has a neighbor with a smaller ripple coordinate in the same 
cell region as it detects the failure of any neighbor or receives a RP_CHANGE message. For each period of 
time, the virtual node with the ripple coordinate equal to ∞ resets the ripple coordinate to one plus the 
smallest ripple coordinate of the neighbors, if exists, having the ripple coordinates not equal to ∞ in the 
same cell region. In addition, if a virtual node has the ripple coordinate equal to ∞ for t periods of time 
because the cell region of the virtual node is not connected, it resets the longitude and latitude coordinates to 
join another cell region. If a virtual node joins another cell region, it broadcasts a CELL_CHANGE message 
containing its updated and original longitude, updated and original latitude, and updated ripple coordinates. 
7 
 
B.1.1 Generation of a Triangle-Free Subnetwork 
There are two steps in this phase. The connected dominating set is first generated by the pruning 
algorithm. Subsequently, the triangle-free subnetwork is constructed by removing each edge between two 
nodes with the largest two IDs in a triangle in the subnetwork induced by the connected dominating set. 
 
B.1.2 Evaluation of Hop Distances 
Let S be the pre-programmed node or the node with the largest ID dominating the pre-programmed 
node. Each node, u, evaluates 𝑢. ℎ𝑝(𝑆), as implemented in the following. Firstly, S broadcasts an S_SET 
message containing a hop counter initially set to 1. Once a node, u, receives an S_SET message, u sets 
𝑢. ℎ𝑝(𝑆) to the hop counter contained in the message and broadcasts the message containing the hop 
counter increased by 1. If u receives more than one S_SET message, u broadcasts the S_SET message 
containing the smallest hop counter and sets 𝑢. ℎ𝑝(𝑆) according to the message. 
 
B.1.3 Computation of Shortest Down-Up Cycle Lengths 
A tail node, u, evaluates the lengths of shortest down-up cycle, as implemented in the following. Each 
neighbor, v, of u with 𝑣. ℎ𝑝(𝑆)  =  𝑢. h𝑝(𝑆) − 1 generates a DUCYCLE_SET message containing the ID 
of v, a hop counter initially set to 1, and a state status initially set to down; subsequently, the message is 
forwarded to all neighbors y with 𝑦. ℎ𝑝(𝑆)  ≤  𝑣. ℎ𝑝(𝑆). Once a node, x, receives a DUCYCLE_SET 
message generated by v, x sets 𝑥. ℎ𝑝(𝑣) to the hop counter contained in the message, and forwards the 
message containing the ID of v, the hop counter increased by 1, and a state status equal to up to all neighbors 
y with 𝑦. ℎ𝑝(𝑆) ≥ 𝑥. ℎ𝑝(𝑆). In addition, if the state status contained in the received DUCYCLE_SET 
message equals down, x also forwards the message containing the ID of v, the hop counter increased by 1, 
and a state status equal to down to all neighbors y with 𝑦. ℎ𝑝(𝑆) ≤ 𝑥. ℎ𝑝(𝑆). If x receives more than one 
DUCYCLE_SET message generated by v, x forwards the DUCYCLE_SET message containing the smallest 
hop counter, and sets 𝑥. ℎ𝑝(𝑣) according to the message. After u receives the DUCYCLE_SET message 
generated by v from w with 𝑤. ℎ𝑝(𝑆) ≤ 𝑢. ℎ𝑝(𝑆), the length of the shortest down-up cycle containing u, v, 
and w is evaluated as 2 + 𝑤. ℎ𝑝(𝑣). 
 
B.1.4 Construction of Virtual Faces 
A tail node, u, constructs a virtual face, 𝑣𝑓, with a boundary containing u, v, and w, where v and w are 
two neighbors of u, with 𝑣. ℎ𝑝(𝑆)  =  𝑢. ℎ𝑝(𝑆) − 1 and 𝑤. ℎ𝑝(𝑆) ≤ 𝑢. ℎ𝑝(𝑆), as implemented in the 
following. u sets 𝑣𝑓. 𝑠𝑖𝑧𝑒 as its sequence number in 𝑣𝑓 (𝑢. 𝑠𝑒𝑞(𝑣𝑓)), generates a FACE_SET message 
containing the ID of v, the ID of 𝑣𝑓 (𝑣𝑓. 𝑖𝑑) which is a random number chosen in a large enough interval to 
break a tie, and the size of 𝑣𝑓 (𝑣𝑓. 𝑠𝑖𝑧𝑒) equal to 2 + 𝑤. ℎ𝑝(𝑣), and forwards the message to w. If a node, 
x, receives a FACE_SET message, x stores 𝑣𝑓. 𝑠𝑖𝑧𝑒 and 𝑣𝑓. 𝑖𝑑, sets 𝑥. 𝑠𝑒𝑞(𝑣𝑓) to 𝑥. ℎ𝑝(𝑣) + 1, and 
forwards the message by backtracking the shortest down-up cycle containing u, v, and w. If a node, x, is not 
contained in the boundary of a virtual face, a virtual face with a boundary containing x is constructed. 
 
B.2 Virtual Face Naming Protocol (VFNP) 
9 
 
VFNP is implemented as follows. Let u be a node in the boundary of virtual face 𝑣𝑓. If 𝑢𝑣𝑓 has a 
smaller ID than any 𝑢-neighbor in 𝐺𝑣𝑓, u assigns 𝑣𝑓𝑝 . 𝑖𝑑, 𝑣𝑓. 𝑟𝑎𝑑𝑖𝑎𝑙, and 𝑣𝑓. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 to 𝑣𝑓. 𝑖𝑑, 0, and 
[0, 2π), respectively, and then generates and broadcasts to neighbors a NAME_SET message containing 
𝑣𝑓𝑝. 𝑖𝑑, 𝑣𝑓. 𝑠𝑖𝑧𝑒, 𝑣𝑓. 𝑖𝑑, 𝑣𝑓. 𝑟𝑎𝑑𝑖𝑎𝑙, 𝑣𝑓. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟, 𝑢. 𝑠𝑒𝑞(𝑣𝑓), and the IDs of u-neighbors of 𝑢𝑣𝑓. If u 
receives a NAME_SET message containing 𝑣𝑓. 𝑖𝑑 and 𝑣𝑓. 𝑠𝑖𝑧𝑒, u broadcasts the message to the neighbors 
in the boundary of 𝑣𝑓, and assigns 𝑣𝑓𝑝. 𝑖𝑑, 𝑣𝑓. 𝑟𝑎𝑑𝑖𝑎𝑙, and 𝑣𝑓. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 to 𝑣𝑓𝑝 . 𝑖𝑑, 𝑣𝑓. 𝑟𝑎𝑑𝑖𝑎𝑙, and 
𝑣𝑓. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 contained in the message, respectively. If u receives from a node, v, a NAME_SET message 
containing 𝑣𝑓1. 𝑖𝑑 and 𝑣𝑓1. 𝑠𝑖𝑧𝑒 (𝑣𝑓1 ≠ 𝑣𝑓), u broadcasts the message to the neighbors in the boundary of 
𝑣𝑓 , assigns 𝑣𝑓𝑝 . 𝑖𝑑  to 𝑣𝑓𝑝 . 𝑖𝑑  contained in the message, assigns 𝑣𝑓. 𝑟𝑎𝑑𝑖𝑎𝑙  to 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 + 1 , and 
assigns 𝑣𝑓. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟  to [a + (i − 1)(b − a)/c + (j − 1)(b − a)/(c ∙ n), a + (i − 1)(b − a)/c + j ∙ (b −
a)/(c ∙ n)), in which interval [a, b) is the angular coordinate of 𝑣𝑓1 , i equals 𝑢. 𝑠𝑒𝑞(𝑣𝑓1), c equals 
𝑣𝑓1. 𝑠𝑖𝑧𝑒, n is the number of v-neighbors of 𝑢𝑣𝑓1 in 𝐺𝑣𝑓, and j is the number of v-neighbors of 𝑢𝑣𝑓1 with a 
smaller or an equal ID than 𝑢𝑣𝑓 in 𝐺𝑣𝑓. In addition, if at least one u-neighbor of 𝑢𝑣𝑓 exists, u also 
generates and broadcasts to neighbors a NAME_SET message containing 𝑣𝑓𝑝. 𝑖𝑑 , 𝑣𝑓. 𝑠𝑖𝑧𝑒 , 𝑣𝑓. 𝑖𝑑 , 
𝑣𝑓. 𝑟𝑎𝑑𝑖𝑎𝑙, 𝑣𝑓. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟, 𝑢. 𝑠𝑒𝑞(𝑣𝑓), and the IDs of u-neighbors of 𝑢𝑣𝑓 after u receives a NAME SET 
message. If u receives more than one NAME_SET message, u assigns (𝑣𝑓. 𝑟𝑎𝑑𝑖𝑎𝑙, 𝑣𝑓. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟) to the 
smallest pair of numbers (𝑣𝑓. 𝑟𝑎𝑑𝑖𝑎𝑙, 𝑣𝑓. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟) according to the message containing the smallest 
𝑣𝑓𝑝. 𝑖𝑑. 
 
B.3 VirtualFace Algorithm 
We assume that the routed packet carries the name of the virtual face, 𝑣𝑓𝑑, with a boundary containing 
the destination or the dominating node of the destination. Once a message encounters a dead-end node, the 
VirtualFace algorithm routes the message toward 𝑣𝑓𝑑 until a progress node is reached. The following 
notations are necessary for the description of the VirtualFace algorithm. 
 
Definition 9. Let [𝑎, 𝑏) and [𝑐, 𝑑) be the angular coordinates of virtual faces 𝑣𝑓1 and 𝑣𝑓2, respectively. 
The angular distance from 𝑣𝑓1 to 𝑣𝑓2 denoted by 𝑑𝑖𝑠𝑡𝑎𝑛𝑔(𝑣𝑓1, 𝑣𝑓2), equals 𝑐 − 𝑏 + 1 if [𝑎, 𝑏)  <  [𝑐, 𝑑), 
equals 𝑎 − 𝑑 + 1 if [𝑐, 𝑑) < [𝑎, 𝑏), and equals 0 otherwise. The radial distance from 𝑣𝑓1 to 𝑣𝑓2, denoted 
by 𝑑𝑖𝑠𝑡𝑟𝑎𝑑(𝑣𝑓1, 𝑣𝑓2), equals |𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 − 𝑣𝑓2. 𝑟𝑎𝑑𝑖𝑎𝑙| if 𝑑𝑖𝑠𝑡𝑎𝑛𝑔(𝑣𝑓1, 𝑣𝑓2) = 0, and equals 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 
otherwise. 
 
Definition 10. The distance between virtual faces 𝑣𝑓1 and 𝑣𝑓2, denoted by 𝑑𝑖𝑠𝑡(𝑣𝑓1, 𝑣𝑓2), is a pair of 
numbers (𝑑𝑖𝑠𝑡𝑎𝑛𝑔(𝑣𝑓1, 𝑣𝑓2), 𝑑𝑖𝑠𝑡𝑟𝑎𝑑(𝑣𝑓1, 𝑣𝑓2)). 𝑣𝑓1 is said to be closer to virtual face 𝑣𝑓3 than 𝑣𝑓2 if 
𝑑𝑖𝑠𝑡(𝑣𝑓1, 𝑣𝑓3) < 𝑑𝑖𝑠𝑡(𝑣𝑓2, 𝑣𝑓3). 
 
If a packet with the destination, d, encounters a dead-end node, the VirtualFace algorithm routes the 
packet to a progress node, as described in the following. If the forwarding node, u, is not in 𝐺𝐷, u forwards 
the packet to the dominating node of u. Otherwise, if one neighbor, v, of u in 𝐺 is a progress node, the 
packet is forwarded to v. Otherwise, if u is contained in the boundary of 𝑣𝑓𝑐𝑙𝑜𝑠𝑒𝑠𝑡, the packet is forwarded to 
the successive node of u in the boundary of 𝑣𝑓𝑐𝑙𝑜𝑠𝑒𝑠𝑡, where 𝑣𝑓𝑐𝑙𝑜𝑠𝑒𝑠𝑡 denotes the virtual face closest to 
11 
 
C.1.2 Expected Routing Path Length 
Theorem 1 shows the route stretch of ABVCap routing in a boundless 2D space in a continuous domain, 
where nodes are assumed to be infinitely dense in a boundless 2D space.  
 
 
Fig. 1 Locations of the source s, the intermediate node i, and the destination d. 
 
Theorem 1: Given the source s and the destination d, the expected ratio of the ABVCap routing path length 
to the shortest path length is 4
π
 in a boundless 2D space in a continuous domain. 
Proof: Assume that s and d are located on (0, 0) and (𝑟cos𝜃, 𝑟sin𝜃), respectively. Using ABVCap 
routing, the packet is first routed to an intermediate node i, located on (𝑟cos𝜃, 0), in longitude routing, and 
then routed to d in latitude routing, as shown in Fig. 1. Since the probability density function of 𝜃 is 1
2𝜋
, the 
expected ratio of the ABVCap routing path length to the shortest path length equals 
∫ (|𝑟 cos 𝜃|+|𝑟 sin 𝜃|
𝑟
)( 1
2𝜋
)𝑑𝜃 = 4
𝜋
2𝜋
0
.  
 
C.2 Analysis of the VirtualFace Algorithm 
We show the VirtualFace algorithm can always route a packet from a dead-end node to a progress node. 
 
Lemma 1: For any virtual face 𝑣𝑓1 ≠ 𝑣𝑓𝑝 , there exists a virtual face, 𝑣𝑓2 , such that 𝑣𝑓2. 𝑟𝑎𝑑𝑖𝑎𝑙 =
𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 − 1 and 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 ⊆ 𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟. 
Proof: Assume that 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 and 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 are assigned when a node, u, contained in the 
boundary of 𝑣𝑓1 receives a NAME_SET message from a node, v, contained in the boundary of 𝑣𝑓2. By 
VFNP, 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 equals 𝑣𝑓2. 𝑟𝑎𝑑𝑖𝑎𝑙 + 1, and 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 equals the j-th smallest equal sub-interval 
of the i-th smallest equal sub-interval of 𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 if the sequence number of v in 𝑣𝑓2 is i and the 
number of v-neighbors of 𝑢𝑣𝑓2 with a smaller or an equal ID than 𝑢𝑣𝑓1 in 𝐺𝑣𝑓 is j. 
 
Lemma 2: Let 𝑣𝑓
1
 and 𝑣𝑓2  be two virtual faces. If 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 = 𝑣𝑓2. 𝑟𝑎𝑑𝑖𝑎𝑙 , then 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 <
𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 or 𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 < 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟. 
Proof: It suffices to show the statement S, there exists no virtual faces, 𝑣𝑓1 and 𝑣𝑓2, with radial 
coordinate k such that neither of 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 < 𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟  and 𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 < 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟  is 
satisfied, holds for all 𝑘 ≥ 0. S holds for 𝑘 = 0 because there is only one virtual face with radial 
coordinate 0; therefore, a basis for the proof exists. We prove S holds for 𝑘 ≥ 1 by induction on k. As an 
induction assumption, we take S holds for 𝑘 ≤ 𝑚 − 1. If 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 = 𝑣𝑓2. 𝑟𝑎𝑑𝑖𝑎𝑙 = 𝑚, according to 
13 
 
𝑣𝑓5. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 , and there exists virtual faces, 𝑣𝑓4  and 𝑣𝑓6 , such that 𝑣𝑓4. 𝑟𝑎𝑑𝑖𝑎𝑙 = 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 + 1 , 
𝑣𝑓6. 𝑟𝑎𝑑𝑖𝑎𝑙 = 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 , and 𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 ⊆ 𝑣𝑓4. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 ⊆ 𝑣𝑓6. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 . It suffices to show 
𝑣𝑓1 = 𝑣𝑓5 = 𝑣𝑓6  to complete the proof. Assume that 𝑣𝑓1 ≠ 𝑣𝑓5 . Because 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 = 𝑣𝑓5. 𝑟𝑎𝑑𝑖𝑎𝑙 , 
𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 < 𝑣𝑓5. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 or 𝑣𝑓5. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 < 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 according to Lemma 2, resulting in the 
impossibility that 𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 ⊆ 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟  and 𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 ⊆ 𝑣𝑓5. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 . In addition, 
𝑣𝑓1 = 𝑣𝑓6 can be proved in a manner analogous for that of 𝑣𝑓1 = 𝑣𝑓5. 
 
Theorem 3: If G is connected, then for any virtual face 𝑣𝑓1 ≠ 𝑣𝑓𝑑 , there exists a neighboring virtual face, 
𝑣𝑓2, such that 𝑑𝑖𝑠𝑡(𝑣𝑓2, 𝑣𝑓𝑑) < 𝑑𝑖𝑠𝑡(𝑣𝑓1, 𝑣𝑓𝑑). 
Proof: According to Theorem 2, we have to discuss five cases: c1) 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 < 𝑣𝑓𝑑 . 𝑎𝑛𝑔𝑢𝑙𝑎𝑟; c2) 
𝑣𝑓𝑑 . 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 < 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟; c3) 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 ⊂ 𝑣𝑓𝑑 . 𝑎𝑛𝑔𝑢𝑙𝑎𝑟; c4) 𝑣𝑓𝑑 . 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 ⊂ 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟; c5) 
𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 = 𝑣𝑓𝑑 . 𝑎𝑛𝑔𝑢𝑙𝑎𝑟. We adhere to the proofs of c1 and c3 and omit the proofs of the other cases 
due to the similarities. For c1, because 𝑣𝑓1 = 𝑣𝑓𝑝 is impossible to hold, there exists a virtual face, 𝑣𝑓2, 
such that 𝑣𝑓2. 𝑟𝑎𝑑𝑖𝑎𝑙 = 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 − 1, and c1.1) 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 ⊂ 𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 or c1.2) 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 =
𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟  according to Lemma 1. For c1.1, neither of 𝑣𝑓𝑑 . 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 < 𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟  and 
𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 ⊆ 𝑣𝑓𝑑 . 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 holds because 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 < 𝑣𝑓𝑑 . 𝑎𝑛𝑔𝑢𝑙𝑎𝑟. Therefore, two cases need to 
be discussed: c1.1.1) 𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 < 𝑣𝑓𝑑 . 𝑎𝑛𝑔𝑢𝑙𝑎𝑟; c1.1.2) 𝑣𝑓𝑑 . 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 ⊂ 𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟. For c1.1.1, 
according to Definition 9, 0 < 𝑑𝑖𝑠𝑡𝑎𝑛𝑔(𝑣𝑓2, 𝑣𝑓𝑑) ≤ 𝑑𝑖𝑠𝑡𝑎𝑛𝑔(𝑣𝑓1, 𝑣𝑓𝑑) , and 𝑑𝑖𝑠𝑡𝑟𝑎𝑑(𝑣𝑓2, 𝑣𝑓𝑑) <
 𝑑𝑖𝑠𝑡𝑟𝑎𝑑(𝑣𝑓1, 𝑣𝑓𝑑) because 𝑣𝑓2. 𝑟𝑎𝑑𝑖𝑎𝑙 < 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 . This implies 𝑑𝑖𝑠𝑡(𝑣𝑓2, 𝑣𝑓𝑑) < 𝑑𝑖𝑠𝑡(𝑣𝑓1, 𝑣𝑓𝑑) 
according to Definition 10. For c1.1.2, 𝑑𝑖𝑠𝑡𝑎𝑛𝑔(𝑣𝑓2, 𝑣𝑓𝑑) = 0 < 𝑑𝑖𝑠𝑡𝑎𝑛𝑔(𝑣𝑓1, 𝑣𝑓𝑑) , implying 
𝑑𝑖𝑠𝑡(𝑣𝑓2, 𝑣𝑓𝑑) < 𝑑𝑖𝑠𝑡(𝑣𝑓1, 𝑣𝑓𝑑). c1.2 can be proved in a manner analogous for that of c1.1.1, completing 
the proof of c1. For c3, 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 > 𝑣𝑓𝑑 . 𝑟𝑎𝑑𝑖𝑎𝑙 according to Lemma 3. Therefore, there exists a virtual 
face, 𝑣𝑓2 , such that 𝑣𝑓2. 𝑟𝑎𝑑𝑖𝑎𝑙 = 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 − 1  and 𝑣𝑓1. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 ⊆ 𝑣𝑓2. 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 ⊆ 𝑣𝑓𝑑 . 𝑎𝑛𝑔𝑢𝑙𝑎𝑟 
according to Lemma 4. Clearly, 𝑑𝑖𝑠𝑡𝑎𝑛𝑔(𝑣𝑓2, 𝑣𝑓𝑑) = 0 = 𝑑𝑖𝑠𝑡𝑎𝑛𝑔(𝑣𝑓1, 𝑣𝑓𝑑). In addition, 𝑣𝑓1. 𝑟𝑎𝑑𝑖𝑎𝑙 >
𝑣𝑓2. 𝑟𝑎𝑑𝑖𝑎𝑙 ≥ 𝑣𝑓𝑑 . 𝑟𝑎𝑑𝑖𝑎𝑙. Therefore, 𝑑𝑖𝑠𝑡𝑟𝑎𝑑(𝑣𝑓2, 𝑣𝑓𝑑) <  𝑑𝑖𝑠𝑡𝑟𝑎𝑑(𝑣𝑓1, 𝑣𝑓𝑑), and thus 𝑑𝑖𝑠𝑡(𝑣𝑓2, 𝑣𝑓𝑑) <
𝑑𝑖𝑠𝑡(𝑣𝑓1, 𝑣𝑓𝑑), completing the proof of c3. 
 
Theorem 4: If G is connected, the VirtualFace algorithm can always route a packet to a progress node. 
Proof: Let u be a forwarding node in the boundary of a virtual face, 𝑣𝑓. Using the VirtualFace algorithm, 
u forwards a packet to the successive node in the boundary of 𝑣𝑓, if no neighbor is in the boundary of a 
virtual face closer to 𝑣𝑓𝑑; otherwise, u forwards a packet to a neighbor in the boundary of the virtual face 
closest to 𝑣𝑓𝑑. It implies the packet traverses the boundaries of virtual faces in a decreasing order of the 
distance to 𝑣𝑓𝑑. Because any virtual face except for 𝑣𝑓𝑑 has a neighboring virtual face closer to 𝑣𝑓𝑑 
according to Theorem 3, the packet can be always routed to 𝑣𝑓𝑑, and thus to the destination if no progress 
node is encountered during the routing process. Because the destination is a progress node, the proof is 
completed. 
 
D. Performance Evaluation 
We evaluate, by simulation, our proposed protocols ABVCap maintenance and the VirtualFace algorithm in 
subsections D.1 and D.2, respectively.  
15 
 
 
Fig. 2 Packet delivery rate of GLIDER, Hop ID, GLDR, VCap, and ABVCap routing on the packet level simulator. The side 
length of the square region is 50 in (a) and (b), and 10 in (c); the number of voids in the square region is 0 in (a) and (c), and 10 in 
(b). 
 
Fig. 3 Routing path length of GLIDER, Hop ID, GLDR, VCap, and ABVCap routing on the packet level simulator. The side 
length of the square region is 50 in (a) and (b), and 10 in (c); the number of voids in the square region is 0 in (a) and (c), and 10 in 
(b). 
 
D.1.1.2 Routing Path Length 
Fig. 3 demonstrates that ABVCap routing has a longer routing path than GLIDER, Hop ID, GLDR, and 
VCap routing. Two reasons exist to explain this observation: 1) ABVCap routing routes the packet similarly 
to using the L1 norm while GLIDER, Hop ID, GLDR, and VCap routing route the packet similarly to using 
the L2 norm, and 2) ABVCap routing has a longer average distance of source-destination pairs because 
many source-destination pairs separated by long distances are unreachable in GLIDER, Hop ID, GLDR, and 
VCap routing. In addition, the higher the network density, the shorter the routing path because the progress 
distance is larger. For a source-destination pair, the more voids exist, the longer the routing path will be 
because the longer path is set to bypass voids. In a small-scale network, the short routing path results from 
the small average distance of source-destination pairs. 
 
D.1.1.3 Number of Next Hop Neighbors 
Fig. 4(a) illustrates that a node has few next hop neighbors in Hop ID or VCap routing because it can 
only forward a packet to the neighbor having the smallest distance from the destination. In Hop ID routing, 
most nodes have only one next hop neighbor because a node is addressed by the hop distances from 30 
landmarks. In VCap, many nodes share a virtual coordinate because a node is addressed by the hop distances 
from 3 anchors. Thus, in VCap routing, a node has more next hop neighbors compared to Hop ID routing. In 
GLIDER or GLDR routing, a node has many next hop neighbors because it can forward a packet to any 
17 
 
D.1.2 Simulation Results on a Network Simulator 
In ns-2, the MAC layer protocol is IEEE 802.11, and the signal propagation model is the two-ray 
ground reflection model. In the simulation, 100 connected networks were generated in square regions with 
side lengths equal to 10. We investigated the average packet delivery rate and the average routing path 
length of GLIDER, Hop ID, GLDR, VCap, and ABVCap routing in networks without node failures. We also 
studied the average packet delivery rate and the average routing path length of ABVCap routing in networks 
with node failure percentages of 5% or 10%. Empirical data were obtained by averaging data of 500 
source-destination pairs from 100 networks. In addition, we studied the average number of messages 
broadcast by a node in constructing or reconstructing the virtual coordinate system using GLIDER, Hop ID, 
GLDR, VCap, ABVCap, and ABVCap maintenance.  
 
D.1.2.1 Packet Delivery Rate 
Compared to Fig. 2(c), GLIDER, Hop ID, GLDR, VCap, and ABVCap routing in Fig. 5(a) have the 
approximately equal packet delivery rates. This implies that each protocol must achieve coordinate 
assignment robustness, in practice. In ABVCap routing, the higher the node failure percentage, the lower the 
packet delivery rate, a result considered to be reasonable. 
 
D.1.2.2 Routing Path Length 
As shown in Fig. 5(b), in ABVCap routing, the higher the node failure percentage, the longer the 
routing path because the network density is reduced. Compared to Fig. 3(c), GLIDER, Hop ID, GLDR, 
VCap, and ABVCap routing in Fig. 5(b) have the approximately equal routing path lengths.  
 
D.1.2.3 Number of Broadcasts 
As shown in Fig. 5(c), the higher the network density, fewer messages are broadcast by a node in VCap 
and ABVCap because fewer X_SET, Y_SET, and Z_SET messages are generated due to the higher 
probability of being the 2-hop neighbors of two nodes. In Hop ID and GLDR, the number of broadcasts is 
slightly greater than the number of landmarks because each node needs to obtain the minimum hop distances 
from all landmarks, where Hop ID selects less than 30 landmarks due to packet loss. As the network density 
increases, the number of landmarks changes slightly, resulting in a negligible difference in the number of 
broadcasts in Hop ID and GLDR. Each node in GLIDER is required to obtain the minimum hop distances 
from all neighboring landmarks. The higher the network density, the greater the broadcasts because of the 
greater neighboring landmarks. In ABVCap maintenance, as expected, the higher the node failure 
percentage, the greater the broadcasts. 
 
19 
 
number of broadcasts per node, and the packet delivery rate in networks with node failures, in which the 
load imbalance factor denoted the ratio of the maximum number of packets routed by a node (the maximum 
load) to the average number of packets routed by a node (the average load). The existence of a node routing 
many packets was indicated by a large load imbalance factor. In GLIDER and GLIDER+VF, 23 landmarks 
were randomly selected. In Hop ID and Hop ID+VF, the peripheral landmark selection of 30 landmarks was 
implemented. In GLDR and GLDR+VF, 10-sampling was used to select landmarks. The flooding 
mechanism in GLIDER, Hop ID, and GLDR was not implemented because it required a great deal of route 
overhead and suffered from the broadcasting storm problem [36]. Empirical data were obtained by 
averaging data of 1000 source-destination pairs from 100 networks. 
 
D.2.1 Packet Delivery Rate 
Fig. 6(a) illustrates the simulation results for the packet delivery rate. GLIDER+VF, Hop ID+VF, 
GLDR+VF, VCap+VF and ABVCap each successfully set a path for every sourcedestination pair. In 
GLIDER, Hop ID, GLDR, and VCap, the greater the network density, the higher the packet delivery rate 
because more dead-end nodes exist in a network with lower density due to the occurrence of more holes. 
GLIDER and VCap each have a lower packet delivery rate than Hop ID and GLDR, which results from the 
introduction of more dead-end nodes because large cells exist in GLIDER and multiple nodes share a virtual 
coordinate in VCap.  
 
D.2.2 Routing Path Length 
Fig. 6(b) illustrates the simulation results for the routing path length. GLIDER+VF, Hop ID+VF, 
GLDR+VF, and VCap+VF have longer routing paths than GLIDER, Hop ID, GLDR, and VCap, 
respectively, because many sourcedestination pairs separated by long distances are unreachable in GLIDER, 
Hop ID, GLDR, and VCap. The differences between Hop ID and Hop ID+VF and between GLDR and 
GLDR+VF are negligible because Hop ID or GLDR has a high packet delivery rate. Hop ID+VF, 
GLDR+VF, and VCap+VF each have a shorter routing path in most cases, as compared to ABVCap. By 
contrast, GLIDER+VF has a longer routing path than ABVCap. This observation results from the fact that 
GLIDER has a long routing path and a low packet delivery rate. Additionally, the greater is the network 
density the shorter is the routing path because the progress distance is larger.  
 
D.2.3 Number of Next Hop Neighbors 
Fig. 6(c) illustrates the simulation results for the number of next hop neighbors. In Hop ID and VCap, a 
node only forwards a packet to the neighbor closest to the destination; therefore, Hop ID and VCap have 
smaller numbers of next hop neighbors than GLIDER, GLDR, and ABVCap. In Hop ID, most forwarding 
nodes have only one next hop neighbor because a node is addressed by the hop distances to 30 landmarks. 
Compared to Hop ID, a forwarding node in VCap has more next hop neighbors because more neighbors, 
which are addressed by the hop distances to 3 landmarks, share a virtual coordinate. In GLIDER, GLDR, 
VCap, and ABVCap, the greater the network density, the larger will be the number of next hop neighbors. In 
addition, because Hop ID and GLDR each have a high packet delivery rate, the differences between Hop ID 
and Hop ID+VF and between GLDR and GLDR+VF are minor. GLIDER+VF and VCap+VF have smaller 
21 
 
 
Fig. 6 Performance simulation results: (a) packet delivery rate; (b) routing path length; (c) number of next hop neighbors; (d) load 
imbalance factor; (e) number of broadcasts; (f) packet delivery rate in networks with node failure equal to 10%. 
 
五、結果與討論 
In this report, we describe a protocol, ABVCap maintenance, to reconstruct an ABVCap virtual 
coordinate system so that ABVCap routing guarantees packet delivery in a network with node failures. We 
also describe the protocols, VFCP and VFNP, to construct virtual faces with boundaries closely surrounding 
23 
 
參考文獻 
REFERENCES 
[1] T. Park and K. G. Shin, “Soft tamper-proofing via program integrity verification in wireless sensor 
networks,” IEEE Transactions on Mobile Computing, vol. 4, pp. 297−309, 2005. 
[2] H. Sabbineni and K. Chakrabarty, “Location-aided flooding: an energy efficient data dissemination 
protocol for wireless sensor networks,” IEEE Transactions on Computers, vol. 54, pp. 36−46, 2005. 
[3] Y. Zou and K. Chakrabarty, “A distributed coverage- and connectivity-centric technique for selecting 
active nodes in wireless sensor networks,” IEEE Transactions on Computers, vol. 54, pp. 978−991, 
2005. 
[4] J. Li, J. Jannotti, D. DeCouto, D. Karger, and R. Morris, “A scalable location service for geographic 
ad-hoc routing,” in IEEE/ACM MOBICOM, 2000, pp. 120−130. 
[5] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker, “GHT: a geographic hash 
table for data-centric storage,” in ACM WSNA, 2002, pp. 78−87. 
[6] B. Karp and H. T. Kung, “GPSR: greedy perimeter stateless routing for wireless networks,” in 
IEEE/ACM MOBICOM, 2000, pp. 243−254. 
[7] P. Bose, P. Morin, I. Stojmenovic, and J. Urrutia, “Routing with guaranteed delivery in ad hoc wireless 
networks,” Wireless Networks, vol. 7, pp. 609−616, 2001. 
[8] J. Gao, L. J. Guibas, J. Hershberger, L. Zhang, and A. Zhu, “Geometric spanners for routing in mobile 
networks,” IEEE Journal on Selected Areas in Communications, vol. 23, pp. 174−185, 2005. 
[9] S. Datta, I. Stojmenovic, and J. Wu, “Internal node and shortcut based routing with guaranteed delivery 
in wireless networks,” Cluster Computing, vol. 5, pp. 169−178, 2002. 
[10] Q. Fang, J. Gao, and L. J. Guibas, “Locating and by passing routing holes in sensor networks,” in IEEE 
INFOCOM, 2004, pp. 2458−2468. 
[11] F. Kuhn, R. Wattenhofer, Y. Zhang, and A. Zollinger, “Geometric ad-hoc routing: of theory and 
practice,” in ACM PODC, 2003, pp. 63−72. 
[12] A. Rao, S. Ratnasamy, C. Papadimitriou, S. Shenker, and I. Stoica, “Geographic routing without 
location information,” in IEEE/ACM MOBICOM, 2003, pp. 96−108. 
[13] K. Seada, A. Helmy, and R. Govindan, “On the effect of localization errors on geographic face routing 
in sensor networks,” in IEEE/ACM IPSN, 2004, pp. 71−80. 
[14] J. Hightower and G. Borriello, “Location systems for ubiquitous computing,” Computer, vol. 34, pp. 
57−66, 2001. 
[15] Q. Fang, J. Gao, L. J. Guibas, V. D. Silva, and L. Zhang, “GLIDER: gradient landmark-based 
distributed routing for sensor networks,” in IEEE INFOCOM, 2005, pp. 339−350. 
[16] J. Bruck, J. Gao, and A. Jiang, “MAP: medial axis based geometric routing in sensor networks,” in 
IEEE/ACM MOBICOM, 2005, pp. 88−102. 
[17] A. Nguyen, N. Milosavljevic, Q. Fang, J. Gao, and L. J. Guibas, “Landmark selection and greedy 
landmark-descent routing for sensor networks,” in IEEE INFOCOM, 2007. 
[18] Y. Liu, L. M.Ni, and M. Li, “A geography-free routing protocol for wireless sensor networks,” in IEEE 
25 
 
network,” in ACM MOBICOM, 2002. 
[37] Y. W. Hong and A. Scaglione. “A scalable synchronization protocol for large scale sensor networks and 
its applications,” IEEE Journal on Selected Areas in Communications, vol. 23, pp. 1085–1099, 2005. 
[38] W. Su and I. F. Akyildiz. “Time-diffusion synchronization protocol for wireless sensor networks,” 
IEEE/ACM Transactions on Networking, vol. 13, pp. 384–397, 2005. 
 
□ 赴國外出差或研習 
□ 赴大陸地區出差或研習 
■ 出席國際學術會議 
□ 國際合作研究計畫出國 
心得報告 
計 畫 名 稱  計 畫 編 號  
報 告 人 
姓 名 
陳以雷 
服 務 機 構 
及 職 稱 
國立清華大學資訊工程系 
會議/訪問時間 
 地點 
Brussels, Belgium, September 11-14, 2011 
會 議 名 稱 IEEE International Conference on Image Processing 
發表論文題目 Time-variant modeling for general surface appearance  
 
一、主要任務摘要（五十字以內） 
 
參加國際影像處理會議，除發表著作論文外，同時學習目前學術領域內關注的主
題與技術，並吸收與會者對未來發展多媒體應用的前瞻看法。 
 
二、對計畫之效益（一百字以內） 
 
  近年來針對多媒體領域發展的各種技術，包括電腦視覺、圖形辨識等傳統方法的
延伸，皆有助於計劃中對於數位人臉影像之分析。而ICIP更是數位影像處理技術上最
重要的一個會議，藉由此行的觀摹與討論，可以反思自身研究，獲得許多啟發。 
 
三、經過 
 
  此次會議舉辦於比利時首都布魯塞爾的square meeting center。由於國內線沒有直達
班機，故先於香港轉機，飛抵荷蘭首都阿姆斯特丹後入境，之後再搭約五小時的火車
前往會場。不過抵達荷蘭時離會議日期尚早，筆者與教授沿路遊訪荷蘭城鎮，感受當
地與單車交通密不可分的生活民情，風景如畫，十分愜意。九月十日，即會議正式開
始前一天，我們方搭車南下。由於投宿旅館位於市區中心，距會場僅數分鐘路程，一
行人便立即至會場報到。九月的布魯塞爾天氣陰晴不定，時有陣雨，主辦單位也非常
貼心地贈送與會者人人一把折傘，讓人感受這次大會的誠摯心意。市區中心的大廣場
(Grand place)為世界著名景點，曾獲文豪雨果盛譽「歐洲最華美的廣場」，故筆者一行
人也偷閒前往朝聖。廣場幅員遼闊，四周皆矗立巴洛克風格建築，巍峨壯麗，名副其
實，使人身處其中不時興嘆渺小之感。而幾條街外的尿尿小童也適逢節日身披華服，
不少異國與會者有幸恭逢其盛，鎂光燈此起彼落，好不熱鬧。之後，筆者即回旅館休
息，養足精神以待隔日的會議。 
   
  由於發表論文安排於第一天(2011/09/11)下午，第一日筆者全程待在會場。早上的
plenary talk是與自身研究較不相關的醫學影像分析，收獲較少，然而之後進行的數場
lecture session，筆者選擇參與討論structural model相關論文，聽到不少分析人類姿勢與
行為的研究主題，頗有助益。下午筆者負責張貼海報報告的session是Image & video 
synthesis，不少研究影像編修或合成的有趣題目都包含其中。筆者本身研究部分是討論
數位影像拍攝的物體外觀隨著時間增長所產生的變化，提出之外觀模型可以直接在二
IEEE COPYRIGHT AND CONSENT FORM
 
 
To ensure uniformity of treatment among all contributors, other forms may not be substituted for this form, nor may any wording of the form be
changed. This form is intended for original material submitted to the IEEE and must accompany any such material in order to be published by the
IEEE.Please read the form carefully and keep a copy for your files.
 
 
 
TITLE OF PAPER/ARTICLE/REPORT, INCLUDING ALL CONTENT IN ANY FORM, FORMAT, OR MEDIA (hereinafter, "The
Work"):Time-Variant Modeling For General Surface Appearance 
 
COMPLETE LIST OF AUTHORS:Yi-Lei  Chen and Chiou-Ting  Hsu 
 
IEEE PUBLICATION TITLE (Journal, Magazine, Conference, Book):2011 IEEE International Conference on Image Processing
(IEEE ICIP2011) 
 
COPYRIGHT TRANSFER
 
1. The undersigned hereby assigns to The Institute of Electrical and Electronics Engineers,Incorporated (the "IEEE") all rights under copyright that
may exist in and to: (a) the above Work,including any revised or expanded derivative works submitted to the IEEE by the undersigned based on the
Work; and (b) any associated written or multimedia components or other enhancements accompanying the Work.
 
CONSENT AND RELEASE
2. ln the event the undersigned makes a presentation based upon the Work at a conference hosted or sponsored in whole or in part by the IEEE, the
undersigned, in consideration for his/her participation in the conference, hereby grants the IEEE the unlimited, worldwide, irrevocable permission to
use, distribute, publish, license, exhibit, record, digitize, broadcast, reproduce and archive, in any format or medium, whether now known or hereafter
developed: (a) his/her presentation and comments at the conference; (b) any written materials or multimedia files used in connection with his/her
presentation; and (c) any recorded interviews of him/her (collectively, the "Presentation"). The permission granted includes the transcription and
reproduction ofthe Presentation for inclusion in products sold or distributed by IEEE and live or recorded broadcast ofthe Presentation during or after
the conference.
 
3. In connection with the permission granted in Section 2, the undersigned hereby grants IEEE the unlimited, worldwide, irrevocable right to use
his/her name, picture, likeness, voice and biographical information as part of the advertisement, distribution and sale ofproducts incorporating the
Work or Presentation, and releases IEEE from any claim based on right of privacy or publicity.
 
4. The undersigned hereby warrants that the Work and Presentation (collectively, the "Materials") are original and that he/she is the author of the
Materials. To the extent the Materials incorporate text passages, figures, data or other material from the works of others, the undersigned has obtained
any necessary permissions. Where necessary, the undersigned has obtained all third party permissions and consents to grant the license above and has
provided copies of such permissions and consents to IEEE.
 
   [ ] Please check this box ifyou do not wish to have video/audio recordings made ofyour conference presentation.   
 
   See below for Retained Rights/Terms and Conditions, and Author Responsibilities.
 
 
AUTHOR RESPONSIBILITIES
 
 
The IEEE distributes its technical publications throughout the world and wants to ensure that the material submitted to its publications is properly
available to the readership of those publications. Authors must ensure that their Work meets the requirements as stated in section 8.2.1 of the IEEE
It is the formal policy of the IEEE to own the copyrights to all copyrightable material in its technical publications and to the individual contributions
contained therein, in order to protect the interests of the IEEE, its authors and their employers, and, at the same time, to facilitate the appropriate re-
use of this material by others.The IEEE distributes its technical publications throughout the world and does so by various means such as hard copy,
microfiche, microfilm, and electronic media.It also abstracts and may translate its publications, and articles contained therein, for inclusion in various
compendiums, collective works, databases and similar publications. 
 
Author/Employer Rights
 
If you are employed and prepared the Work on a subject within the scope of your employment, the copyright in the Work belongs to your employer
as a work-for-hire. In that case, the IEEE assumes that when you sign this Form, you are authorized to do so by your employer and that your
employer has consented to the transfer of copyright, to the representation and warranty of publication rights, and to all other terms and conditions of
this Form.If such authorization and consent has not been given to you, an authorized representative of your employer should sign this Form as the
Author.
 
GENERAL TERMS
 
1. The undersigned represents that he/she has the power and authority to make and execute this form.
2. The undersigned agrees to indemnify and hold harmless the IEEE from any damage or expense that may arise in the event of a breach of any of the
warranties set forth above.
3. In the event the above work is not accepted and published by the IEEE or is withdrawn by the author(s) before acceptance by the IEEE, the
foregoing grant of rights shall become null and void and all materials embodying the Work submitted to the IEEE will be destroyed.
4. For jointly authored Works, all joint authors should sign, or one of the authors should sign as authorized agent for the others.
 
Yi-Lei Chen 27-04-2011
Author/Authorized Agent For Joint Authors Date(dd-mm-yy)
 
THIS FORM MUST ACCOMPANY THE SUBMISSION OF THE AUTHOR'S MANUSCRIPT.
Questions about the submission of the form or manuscript must be sent to the publication's editor.Please direct all questions about IEEE copyright
policy to:
IEEE Intellectual Property Rights Office, copyrights@ieee.org, +1-732-562-3966 (telephone)
 
 
 
 
  
                                                                                                                                                        
 
 
and analyze the four types independently. Since different 
time-variant sequences have different time duration and 
image resolution (from 180x180 to 512x512), in our 
experiments, we use bilinear interpolation to normalize each 
time-variant sequence into 25 time steps and resize to the 
same resolution (i.e. size of 128x128).  
   
    
    
(a) (b) (c) (d) 
Figure 1. Released data from [7]: (a) burning; (b) corrosion; (c) 
decaying; and (d) drying. 
2.2. Time-variant appearance model via tensor 
representation 
Multi-linear algebra, also called tensor, indicates a 
generalization of vector or a multi-dimensional array. Using 
multi-linear analysis, we first construct a data tensor  T  to 
represent our database 
pixelcolortimelightmaterial IIIIIT ××××∈R , (1)
where materialI and lightI  indicate the number of different 
materials and lighting directions (details please see [7]), and 
timeI , colorI  and pixelI  indicate the number of time steps, color 
channels and image pixels, respectively. In our experiment, 
25=timeI , 3=colorI , and 128128×=pixelI . In order to 
characterize the appearance variation, we construct another 
tensor, called the aging tensor A , by calculating the 
difference of the data appearance in T between the initial 
time step and all the other time steps.  
To further analyze T  and A  in different factors, we 
decompose the two tensors by high order singular value 
decomposition (HOSVD) and obtain 
pixelcolortimelightmaterial
pixelcolortimelightmaterial
YA
XT
VVVVV
UUUUU
54321
54321
×××××=
×××××= . (2)
With the data tensor T , we could represent any sample t  
by 
T
color
T
time
T
light
T
materialT cccct 4321 ××××= . (3)
In equation (3), we use least square error (LSE) method and 
rank-1 approximation algorithm [16] to estimate the 
unknown coefficients materialc , lightc , timec and colorc . The 
coefficients materialc , lightc , colorc  relate to surface properties, 
and the coefficient timec  indicates the appearance similarity 
between input sample and the training data along time axis. 
If we use the global bases timeV in equation (2) to project 
timec , although timetimecV  could characterize the time-variant 
appearance change, the important surface-specific 
information (including  material, lighting direction and color) 
is  missing. Therefore, with materialc , lightc , and colorc obtained 
in equation (3), we propose to construct surface-specific 
aging bases to characterize both the time-variant and 
surface-specific properties. 
Below we describe how we construct the surface-
specific aging bases. We first use the surface coefficients 
materialc , lightc , and colorc  to obtain a sub-tensor Aˆ  
T
color
T
light
T
materialAA ccc 421ˆ ×××= . (4)
Then we unfold Aˆ  and decompose the matrix Aˆ  by  SVD 
TVUA ˆˆˆ Σ= . (5)
Now the projection basis Uˆ  only depends on the sub-
database, which possesses the same surface properties as the 
input sample. Using Uˆ , we obtain the time coefficients timeα  
))((ˆ 4210
T
color
T
light
T
material
T
time Tunfold ccctUα ×××−=  , (6)
where )(⋅unfold  indicates a matrix unfolding operation to 
unfold a multi-dimensional array into a vector, and 0T  is a 
sub-tensor of T with data appearance at the initial time step. 
2.3. Aging degree estimation 
Given an unknown sample, once we obtain its surface 
coefficients TTcolorTlightTmaterialsurface ],,[ cccc =  and the time 
coefficients timeα  by equations (3) and (6), an intuitive 
approach is to concatenate surfacec  and timeα  as low-level 
features and to learn a regression function along time axis. 
However, since the time-variant appearance change is very 
complicate, these features tend to distribute discontinuously 
in temporal domain. Therefore, instead of using regression-
based methods, in our approach, we model the aging degree 
estimation as a classification problem. Classification-based 
methods are generally more feasible for discontinuous 
distributions in lower dimensional space. In addition, since 
the class number (i.e. 25 time steps) is limited, our 
classification approach often involves no ambiguity in 
multi-class estimation. 
We use Fig. 2 to show that classification-based is more 
feasible than regression-based method in our problem. Fig. 
2 shows the two estimation results, where the x axis is the 
data index and the y axis indicates the aging degree. Here 
we use the state-of-the-art techniques, support vector 
machine (SVM) and support vector regression (SVR), for 
demonstration. In Figure 2(a), SVM achieves better 
estimation than SVR in higher and lower aging degrees. 
Since SVR attempts to minimize the total estimation error, 
the estimated results usually close to average. Nevertheless, 
our other experiment (as shown in Fig. 3 (a)) shows that 
even SVM achieves poor estimation for intricate appearance 
2011 18th IEEE International Conference on Image Processing1102
we combine the two existing texture synthesis techniques to 
synthesize realistic appearance changes on general object 
surface. With this framework, in the future, we attempt to 
extend our approach to facial images, which can be seen as 
a special case of time-variant appearance. 
5. REFERENCES 
[1] H. W. Jensen, J. Legakis and J. Dorsey, “Rendering of Wet 
Materials,” Proc. Rendering Techniques Conf., pp. 273-282, 1999. 
[2] J. Dorsey, H. K. Pedersen and P. Hanrahan, “Flow and Chan-
ges in Appearance,” Proc. SIGGRAPH, pp. 411-420, Aug. 1996. 
[3] J. Dorsey, A. Edelman, H. W. Jensen, J. Legakis, and H. K. 
Pedersen, “Modeling and Rendering of Weathered Stone,” Proc. 
SIGGRAPH, vol. 33, pp.  225-234, Aug. 1999. 
[4] O. Clement, J. Benoit, and E. Paquette, “Efficient Editing of 
Aged Object Textures,” Proc. the 5th international conference on 
AFRIGRAPH, pp. 151-158, 2007. 
[5] B. Sun, K. Sunkavalli, R. Ramamoorthi, P. N. Belhumer, and S. 
K. Nayar, “Time-Varying BRDFs,” IEEE Trans. Visualization and 
Computer Graphics, vol. 13, No. 3, 2007. 
[6] J. Wang, X. Tong, S. Lin, M. Pan, C. Wang, H. Bao, B. Guo, H. 
Y. Shum, “Appearance Manifolds for Modeling Time-Variant 
Appearance of Materials,” ACM Trans on Graphics, 2006. 
[7] J. Gu, C. Tu, R. Ramamoorthi, P. Belhumeur, W. Matusik, and 
S. Nayar, “Time-Varying Surface Appearance: Acquisition, 
Modeling and Rendering,”  Proc. SIGGRAPH, pp. 762-771, 2006. 
[8] M. A. O. Vasilescu, D. Terzopoulos, “Multilinear analysis of 
image ensembles: TensorFaces,” Proc. ECCV, 2002. 
[9] Hyung-Soo Lee and Daijin, “Tensor based AAM with 
continous variation estimation: application to variation-robust face 
recognition,” IEEE Tran. PAMI, 2009. 
[10] Y. Fu and T. S. Huang, “Image Classification Using 
Correlation Tensor Analysis,” IEEE Tran. Image Processing, 2008. 
[11] Dacheng Tao, Xuelong Li, Xindong Wu and S. J. Maybank, 
“General tensor discriminant analysis and gabor features for gait 
recognition,” IEEE Tran. PAMI, 2007. 
[12] M. A. O. Vasilescu, and D. Terzopoulos, “Multilinear 
projection for appearance-based recognition in the tensor 
framework,” Proc. ICCV, 2007. 
[13] T. G. Kolda, “Orthogonal tensor decompositions,” SIAM 
Journal on Matrix Analysis and Applications, 2001. 
[14] L. de Lathauwer, B. de Moor, and J. Vandewalle, “On the 
Best Rank-1 and Rank-(R1;R2;…;RN) Approximation of Higher-
Order Tensors,” SIAM J. Matrix Analysis and Applications, vol. 21, 
no. 4, pp. 1324-1342, 2000. 
[15] A. A. Efros and W. T. Freeman, “Image quilting for texture 
synthesis and transfer,” Porc. of 28th annual conf. on Computer 
graphics and  interactive techniques, pp. 341-346, 2001. 
[16] A. A. Efros and T. K. Leung, “Texture synthesis by non-
parametric sampling,” Proc. ICCV, 1999. 
 
Figure 4. Average MAE of estimated aging degree. 
 
(a) (b) 
 
 
 
 
 
(c) 
Figure 5. Synthesized example: (a) brick wall image; (b) a random 
patch cropped from (a); and (c) the synthesized appearance at 25 
different aging degrees. 
 
(a) (b) 
(c) (d) 
Figure 6. Appearance synthesis of an old door: (a) original image; 
(b) binary mask; (c) synthesized appearance change; and (d) the 
synthesized result. (Note that, to visualize the synthesized 
appearance change in (c), we multiply the value by five.) 
 
2011 18th IEEE International Conference on Image Processing1104
97 年度專題研究計畫研究成果彙整表 
計畫主持人：蔡明哲 計畫編號：97-2221-E-007-042-MY3 
計畫名稱：在無線感測網路一種利用虛擬座標容錯可靠及保證封包送達的繞徑方法 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 1 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 1 0 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
