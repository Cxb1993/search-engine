中文摘要 
 
自我們發表全世界第一篇六子棋論文至今僅五年多，六子棋的歷史與其他
棋種如象棋、圍棋、西洋棋有數百年、甚至上千年歷史相比，仍屬相當年輕的，
因此專家的詰棋題目與開局定石的數量仍相對較為缺乏。 
 
為了加速六子棋的推廣與普及，本計畫（目前正在執行中）除了持續研發
新的六子棋搜尋技術外，我們已發展出開局定石自動產生之系統與技術，此系
統提供 GUI介面供棋士便於建立開局庫，並可用來大量產生開局定石，提供六
子棋高段棋士研究更深入的各種開局下法。由於開局定石產生系統相當耗時，
我們使用平行處理技術來加快處理速度，並計劃將原本的 Proof Number 
Search 演算法改進成適用於平行化的架構上。此結果發表於 IEEE 
Transactions on Computational Intelligence and AI Games 期刊，以及本
領域最重要的國際會議 International Conference on Computers and Games 
2010。 
 
此外，為了瞭解每手棋下 p子的必勝、必敗、必和的結果，我們發展新的
技巧算出許多新的結果，例如每手棋下 2 子，則 11 子棋必和，此結果遠優於
現有結果(15子棋必和)，並發表於 Theoretical Computer Science 期刊。 
 
關鍵字詞：六子棋、詰棋、開局定石、詰棋產生器、開局定石產生器、搜尋技
術、迫著策略。 
  
 一、計畫說明 
 
本計畫主持人除了第一個正式提出六子棋下法，並研發許多新的六子棋搜
尋技術，及棋力強大的六子棋程式「交大六號」。除了獲得國際奧林匹亞六子
棋組賽局競賽的冠軍外，最近亦曾有擊敗某次六子棋公開賽冠軍棋士的記錄。 
 
然而自我們發表全世界第一篇六子棋論文至今僅四年多，六子棋的歷史與
其他棋種如象棋、圍棋、西洋棋有數百年、甚至上千年歷史相比，仍屬相當年
輕的，因此專家的詰棋題目與開局定石的數量仍相對較為缺乏。 
 
為了加速六子棋的推廣與普及，此計畫（三年期計畫，目前是第二年）除
了持續研發新的六子棋搜尋技術外，我們已發展出開局定石自動產生之系統與
技術，此系統提供 GUI介面供棋士便於建立開局庫，並可用來大量產生開局定
石，提供六子棋高段棋士研究更深入的各種開局下法。由於開局定石產生系統
相當耗時，我們使用平行處理技術來加快處理速度，並計劃將原本的 Proof 
Number Search演算法改進成適用於平行化的架構上。 
 
在六子棋搜尋技術方面，我們持續改良我們的六子棋程式「交大六號」，
其中一項是，提出一種是以關連區域(Relevance Zones)為主的搜尋技術，這
是利用對手下出的空著(Null Move)或半空著(Semi-Null Move)所獲勝後的關
連區域，來去做迫著空間搜尋(Threat Space Search)。 
 
 
圖一  Null move的關連區域 
 
 
 圖三  TX-d21開局 
 
 
圖四  Semi-null move的關連區域 
 
例如對上圖圖三，在處理 Semi-null-move 時，若白下一子於白４的右方
一格，此時黑無法用雙迫著追四勝，必頇用單迫著追四勝才能獲勝。甚至，如
圖四中的棋型（註︰此棋型是在討論若黑５只下一子時的狀況），若黑下於白
６右上及右下一格時，白連單迫著都無法獲勝，必頇是無迫著才能得勝。然而
單迫著追四勝及無迫著追四勝的關連區域，並不容易找出。 
 
本計畫發展出一套新的演算法稱為 Threat Proof Search (TPS)，算出這
個關連區域。此 TPS演算法對關連區域，會依照不下的子數來發展出不同的區
域。例如，若一子不下的關連區域稱為 Z1; 若二子不下的關連區域稱為 Z2; 若
三子不下的關連區域稱為 Z3。利用這些區域，我們可以證明出圖三及圖四的
棋型是黑必勝。 
 
在開局定石產生系統方面，我們除了利用 TPS的搜尋技術外，我們亦使用
Proof Number Search (PNS)技巧來加速開局的驗證。由於我們無法預期各個
盤面是必勝或必敗或和，便使用 PNS技巧找出如何搜尋能最快達成目標。此目
標可能是驗證出必勝，也可能是驗證出必敗，甚至是某種程度上證明黑白雙方
已經接近和局。目前正在發展中，並已有初步成果。 
 
在開局庫系統中最常使用到的 AI功能之一即是 AI搜尋。當我們在建立開
局庫的過程中遇到困難的盤面，不知道如何著手時，可以呼叫後端的 NCTU6
程式做運算，如圖六中按下 ab 按紐，此時開局庫系統會將盤面丟到 NCTU6 並
啟動 NCTU6 的 alpha-beta 搜尋，當 NCTU6 搜尋完之後會將結果傳回前端並即
時地在 GUI介面中呈現 AI搜尋的最佳著手(如圖六的第 4步驟，搜尋結果會以
樹狀方式展現)。 
 
 
圖七 呼叫 Verifier做驗證 
 
而當我們走到一個盤面，希望驗證此盤面是否已經必勝時(如圖七，黑 3
剛下完，我們希望能驗證此盤面是否是黑必勝)，則可以啟動 Verifier功能。
Verifier 會列出下一步白的所有可能擋法，若白存在有一個以上擋法則代表
此盤面黑方仍未必勝，必頇繼續深入做驗證。反之，若 Verifier 驗證完沒有
顯示任何擋法，則代表此盤面所有白色著手都擋不住，也就是此棋局黑必勝。 
 
因此我們的自動化開局定石產生系統則是利用這兩個功能，當我們需要建
立黑方開局庫時，就利用 ab的功能找出一手黑方最佳著手，在使用 Verifier
驗證白方所有可能的擋法，黑方再針對這些所有可能的擋法，利用 ab 功能找
出最佳的一個攻擊著手。如此反覆循環，當任何白方可能的走法黑都可以必勝
時，一個黑方的開局庫已建立完成，此開局庫同時也包含了各種黑的必勝下
法。 
 
由於建立開局系統非常費時，許多棋局需要花費數十天甚至數個月或數年
之久，因此我們使用平行化系統來加速運算。在原本的 GUI介面上，只要資源
充足，我們可以呼叫數個以上的 NCTU6 或 Verifier 程式來做運算。比如說圖
七的盤面在經過 Verifier 驗證之後產生了數個白方的擋法，我們可以在同時
   
圖十  使用 Broker做協調 
 
除了預設由 Broker自動分配之外，每個 Connect6Lib可以透過 Broker看
到目前 Worker的使用情形，也可以透過 Broker設定自己希望使用幾台電腦做
運算，或設定希望固定用哪幾台 Worker等等。這些設定及運作都會由 Broker
做協調，避免錯誤的發生。 
 
由於原本的 Proof Number Search只適用在單一台電腦的運算上面，不適
用於平形化系統，因此接下來我們要研究的是如何開平行化的架構上發展出一
個類似 Proof Number Search 的演算法，來加快我們的平行化效率。 
 
而在詰棋搜尋方面，我們首先利用我們六子棋程式「交大六號」找出大部
分必勝棋型的必勝下法。進而利用一般的 Iterative deepening 技巧找出最短
的必勝下法。此計畫亦研究分析詰棋的品質，及難易度。例如︰即使可以找出
某個棋型的必勝法則，然而還需要找出最短必勝下法；即使可以找出最短的必
勝下法，還需要找對棋友最感到艱困的必勝下法。此外，若這個棋型可能有很
多必勝下法，這樣個棋型，也不一定適合成為詰棋，必頇過濾，以確保詰棋品
質。 
 
 
二、研究成果 
 
如上所述，我們發展一套新的演算法稱為 Threat Proof Search (TPS)。
此 TPS演算法被用於提升了「交大六號」的搜尋能力，這同時也大幅提升了「交
大六號」棋力，戰績如下。 
 在 2008年 10月的國際奧林匹亞賽局競賽中的六子棋程式比賽中，在眾多
隊伍中脫穎而出，獲得金牌。這為我國獲得唯一的一面金牌及獎牌。 
三、結論 
 
我們發展一套 TPS演算法，這除了對程式的搜尋能力有大幅的提升外，亦
可用於開局及詰棋自動產生系統。並設計了平行化開局庫自動產生系統，可自
動建立開局庫。目前的研究成果顯示此計畫的可行性及效果。我們不僅提出全
世界第一篇六子棋玩法的論文，本計畫亦對六子棋發展出許多重要的研究，如
開局及詰棋。由於六子棋的規則簡單、遊戲公平、及玩法複雜，有機會成為一
項由台灣研究發展出而普及全世界的遊戲。本計畫的成功將有助於六子棋的發
展與推廣，及提升國家形象及知名度。 
 
四、計畫成果自評部份 
 
從上述的研究成果，我們可以了解此計畫有相當豐碩的成果如下： 
 獲得第十三屆國際奧林匹亞賽局競賽冠軍，為我國獲得唯一的一面金牌及
獎牌，同時也擊敗台灣許多六子棋高段棋士。 
 我們發展出許多令目前高段棋士十分震驚的六子棋開局定石（如圖十一），
我們預期加上完全平行化的自動開局產生系統，將會有更多前所未見的開
局定石。 
 許多成果發表於重要期刊與會議如: IEEE Transactions on Computational 
Intelligence and AI Games 期刊, Theoretical Computer Science 期刊, 
ICGA Journal 期刊 , 以及本領域最重要的國際會議 International 
Conference on Computers and Games 2010.  
因此，我們很確信地自評︰此計畫的執行成果相當優異。我們附上以下論文: 
 I-Chen Wu and Ping-Hung, Lin, "NCTU6-Lite Wins Connect6 Tournament", 
ICGA Journal (SCI), Vol.31, No.4, December 2008. 
 Ping-Hung Lin and I-Chen Wu, "NCTU6 Wins in the Man-Machine Connect6 
Championship 2009", ICGA Journal (SCI), vol. 32(4), 2009. 
 I-Chen Wu, H.-H. Lin, P.-H. Lin, D.-J. Sun, Y.-C. Chan and B.-T. Chen, 
"Job-Level Proof-Number Search for Connect6", The International Conference on 
Computers and Games (CG 2010), Kanazawa, Japan, September 2010. 
 I-Chen Wu and Ping-Hung Lin, "Relevance-Zone-Oriented Proof Search for 
Connect6", the IEEE Transactions on Computational Intelligence and AI in 
Games (SCI), Vol. 2, No. 3, pp. 191-207, September 2010. 
 Sheng-Hao Chiang, I-Chen Wu, Ping-Hung Lin, "Drawn K-In-A-Row Games", 
Theoretical Computer Science (SCI), Vol. 412, pp. 4558-4569, August 2011. 
points and the gold of the 13th Computer Olympiad. BITSTRONGER, the second in 2007 Chinese Computer 
Games Championship, won 17 points and the silver. NEUCONN6, the first in 2007 Chinese Computer Games 
Championship, won 13 points and the bronze. Both programs, NCTU6-LITE and BITSTRONGER, were close 
and won one game against each other. However, BITSTRONGER lost one more game to ML. Hence, 
NCTU6-LITE obtained one more point, winning the gold. The cross table is listed in Table 2. In the 
tournament, eight games in total drew. Note that the two games between NTNU C6 and CV6 are both drew. 
 
Program NCTU BIT NEUC BCCC KAV NEUS ML CV6 DRM NTNU 
NCTU6-LITE  - 1 2 2 2 2 2 2 2 2 
BITSTRONGER  1 - 2 2 2 2 1 2 2 2 
NEUCONN6 0 0 - 2 1 2 2 2 2 2 
BCCC 0 0 0 - 1 1.5 1.5 1.5 2 1.5 
KAVALAN 0 0 1 1 - 0.5 2 1 1 1.5 
NEU6STAR  0 0 0 0.5 1.5 - 1 2 1 2 
ML 0 1 0 0.5 0 1 - 1 2 1 
CV6 0 0 0 0.5 1 0 1 - 2 1 
DREAM 6 0 0 0 0 1 1 0 0 - 2 
NTNU C6 0 0 0 0.5 0.5 0 1 1 0 - 
Table 2: The cross table.  
This report comments the two games between NCTU6-LITE and BITSTRONGER, as well as the game that 
BITSTRONGER lost to ML. Since Connect6 is draw-ish due to balancing, strong Connect6 programs should 
play aggressive in the sense that they do not want to draw too many games to get high points in a 
tournament. Therefore, both NCTU6-LITE (the gold) and BITSTRONGER (the silver) played aggressively. 
However, on the other hand, playing aggressively also takes high risks of exposing weakness. Figure 1 
shows the record of the first game, NCTU6-LITE (B) vs. BITSTRONGER (W). In this game, NCTU6-LITE made 
a blunder at 5 and BITSTRONGER immediately caught the blunder by playing at 6, verified as a winning 
move by NCTU6. Interestingly, the situation was reversed for the second game, BITSTRONGER (B) vs. 
NCTU6-LITE (W), shown in Figure 2. BITSTRONGER also made a blunder at 5 and NCTU6-LITE immediately 
caught the blunder by playing at 6, also verified as a winning move by NCTU6. Subsequently, NCTU6-LITE 
made no similar blunders and won all of the rest of games. In contrast, while playing aggressively, 
BITSTRONGER sometimes offered some chances for opponents’ winning. Figure 3 shows the record of the 
game that BITSTRONGER lost to ML. In this game, ML defended well without blunders and grew stronger 
potential outside. For Move 46, W should have played at (E11, L15) to win. On the other hand, for Move 
47, B should have played at (E11, G11) to defend. E11 was the key place for both players. Since 47, B had 
been losing. A similar situation happened in the game, BITSTRONGER played against BCCC. However, BCCC 
was not able to find some winning moves in that game and lost to BITSTRONGER finally.  
 
     
Figure 1: Black: NCTU6-LITE, White: 
BITSTRONGER, Moves 1 – 20. 
Figure 2: Black: BITSTRONGER, White: 
NCTU6-LITE, Moves 1 – 16. 
 
NCTU6 Wins in the Man-Machine Connect6 Championship 2009 
 
Ping-Hung Lin
1
 and I-Chen Wu
1
  
 
Taiwan 
 
The Man-Machine Connect6 Championship 2009, sponsored by some organizations and industrial 
companies, was held in Hsinchu, Taiwan, on October 11, 2009. Four of top Connect6 players from Taiwan, 
listed in Table 1 below, attended this contest and played against NCTU6, the program developed by the team 
led by I-Chen Wu, including Ping-Hung Lin and Hung-Hsuan Lin.  
 
Player Player Points NCTU6 Points 
Round 1 Round 2 Total Round 1 Round 2 Total 
Wen-Ching Hsu 0 0 0 2 2 4 
Cheng-Guo Chen 0 0 0 2 2 4 
Wei-Han Chen 0 0 0 2 2 4 
Shi-Wen Lee 0 0 0 2 2 4 
Table 1: The participants and final standings. 
 
The game Connect6, a kind of six-in-a-row game, was first introduced by Wu and Huang (Wu and Huang, 
2005) and then described in more detail by Wu, Huang, and Chang (Wu, Huang, and Chang, 2005). The 
rules of Connect6 are very simple. Two players, henceforth represented as Black (designated as the first 
player) and White, alternately place two stones, black and white respectively, on one empty intersection of 
an 1919 board, except for that Black places one stone initially. The player who first obtains six 
consecutive stones (horizontally, vertically or diagonally) wins the game. When all intersections on the 
board are occupied without connecting six, the game is drawn.  
 
In this contest, four of top Connect6 players from Taiwan, Wen-Ching Hsu, Cheng-Guo Chen, Wei-Han 
Chen and Shi-Wen Lee, were invited to play against NCTU6. The first three are the top four in the Fourth 
Annual NCTU-Cup Connect6 Open Tournament (whose web pages are in www.connect6.org), which were 
held on August 23, in 2009. NCTU-Cup Connect6 Open Tournament is the most important annual 
Connect6 tournament held in Taiwan that usually attracts about a hundred players each year. The winners 
in this tournament are usually ones of the top players in Taiwan. Shi-Wen Lee is the head of Taiwan 
Connect6 Club, who could also be the first player who posted Connect6 openings and puzzles over the 
Internet (namely posted in November, 2005).  
 
The Connect6 program, NCTU6, attended the 11
th
 and 13
th
 Computer Olympiad in both 2006 (Wu and Yen, 
2006) and 2008 (Wu and Lin, 2008), and won gold both. NCTU6 also beat Chou Chun-Hsun (also 
transliterated as Zhou Junxun), an ever Go Champion, in invited competition events between NCTU6 and 
Chou, sponsored by National Science Council in Taiwan and some other organizations.  
 
In this championship, the games were played in two rounds. NCTU6 played first against each human player 
in the first round, while playing second in the second round. In each game, every player freely played 
during the initial 80 minutes. After the period, each player had at most 10 times to play moves that took 
more than one minute, or lost the game. For each game, the winner scored 2 points and the loser scored 
nothing. For a draw game, both scored 1. NCTU6 won all games and the final points for human players are 
listed in Table 1. The winner was awarded NT$6000, roughly US$180.  
 
This report comments four games between NCTU6 and human players. First, two of the games in the first 
round are commented. Figure 1 shows the record of the game, NCTU6 (Black) vs. Shi-Wen Lee (White). 
Moves 2 to 5 are a popular opening that is also played in the game shown in Figure 2. Lee made a good 
shape at Move 8. However, NCTU6 also successfully made a counter move at 9 that forced White back to 
                                                 
1
 Dept. of Computer Science, National Chiao Tung University, Hsinchu, Taiwan, Email: bhlin@csie.nctu.edu.tw and 
icwu@csie.nctu.edu.tw. 
 In general, human players are good at making good shapes to win games. NCTU6 still needs to be improved 
to make better shapes. On the other hand, human players do not search winning moves as accurately as 
NCTU6 does, especially under time pressures. NCTU6 can easily catch any blunders made by human players. 
Unanimously, the four players thought that they might be able to win some games, if played with more 
times. After the games, a common agreement that was reached is to allow much more times in the 
championship next year.  
 
F.l.t.r. Ping-Hung Lin, Shi-Wen Lee, Cheng-Guo Chen, I-Chen Wu, Wei-Han Chen, Shun-Ji Guo (the 
referee), and Wen-Ching Hsu. 
 
 
References 
 
Wu, I-C. and Huang, D.-Y. (2005) A New Family of k-in-a-row Games. The 11th Advances in Computer 
Games (ACG11) Conference, Taipei, Taiwan. 
 
Wu, I-C., Huang, D.-Y., and Chang, H.-C. (2005) Connect6, ICGA Journal, Vol. 28, No.4, pp. 234-241.  
 
Wu, I-C., and Yen, S.-J. (2006) NCTU6 Wins Connect6 Tournament, ICGA Journal, Vol. 29, No.3, pp. 
157-158.  
 
Wu, I-C., and Lin, P.-H. (2008) NCTU6-Lite Wins Connect6 Tournament, ICGA Journal, Vol. 31, No. 4, pp. 
244-247.  
 
weight jobs for Connect6. NCTU6 is a Connect6 program which won the gold of 
Connect6 Tournaments in Computer Olympiad [26,27,30] in 2006 and 2008 and also 
won 8 games and lost nothing against top Connect6 players [12] in Taiwan in 2009, 
and is used to generate a move (a node) and also evaluate the generated node. Verifier 
is a verifier modified from NCTU6, and is used to generate all the defensive moves 
(on the other hand, the moves not generated are proved to be losing). The JL-PN 
approach has the following advantages.  
 
 Develop jobs (well-written programs) and the JL-PN search independently, 
except for a few efforts required to support JL-PN search from these jobs. As 
described in this paper, these required efforts are relatively low.  
 Dispatch jobs to remote processors in parallel. Such JL-PN search is well suited 
for parallel processing, since these jobs are allowed to be performed by remote 
processors independently.  
 Maintain the JL-PN search tree inside the client memory without much problem. 
Since well-written programs also support accurate domain-specific knowledge 
to a certain extent, the search trees require less nodes to solve the game 
positions (when compared with PN search). In our experiments for Connect6, 
the search tree usually contains no more than one million nodes, which can fit 
process (client) memory well. Assume that it takes one minute (60 seconds) to 
run NCTU6. Then, a parallel system with 60 processors takes about 11 days to 
build a tree up to one million nodes. In such cases, we can manually split one 
JL-PN search into two.  
 Easily monitor the search tree. Since the maintenance cost for the search tree is 
relatively low when compared with the heavy-weight jobs, the client that 
maintains the JL-PN search tree can support more GUI utilities to let users 
easily monitor the running of the whole JL-PN search tree real time. For 
example, let users look into the search tree during the running time.  
 
Using JL-PN search with the two jobs NCTU6 or Verifier on desktop grids, a kind 
of volunteer computing systems [4,7,20,25], this paper solved several Connect6 
positions including several 3-move openings as shown in Figure 6 (below). For some 
of these openings, none of professionals had been able to find the winning strategies 
before. These solved openings include the popular one as shown in Figure 6 (i), 
named Mickey-Mouse Opening [21] (since White 2 and Black 1 together look like a 
face of the Mickey Mouse).  
This paper is organized as follows. Section 2 reviews Connect6 applications 
including the jobs for Connect6. Section 3 describes JL-PN search and discusses some 
related issues. Section 4 does experiments for JL-PN search. Section 5 makes 
concluding remarks.  
2 Connect6 Applications 
Connect6 [28,29] is a kind of six-in-a-row game that was introduced by Wu et al. 
Two players, named Black and White in this paper, alternately place two black and 
white stones respectively on empty intersections of a Go board (a 1919 board) in 
is based on an AND/OR search tree where each node n is associated with 
proof/disproof numbers, p(n) and d(n), which represent the minimum numbers of 
nodes to be expanded to prove/disprove n. The values p(n)/d(n) are 0/ if the node n 
is proved, and /0 if it is disproved. PN search repeatedly chooses a leaf called the 
most-proving node (MPN) to expand, until the root is proved or disproved. The details 
of choosing MPN and maintaining the proof/disproof numbers can be found in [1,3] 
and therefore is omitted in this paper. If the selected MPN is proved (disproved), the 
proof (disproof) number of the root of the tree is decreased by one.  
Our JL-PN search is parallel PN search with the following two features. First, well-
written programs such as NCTU6 and Verifier are used to expand and generate MPNs. 
These programs are viewed as jobs, sent to and done by free workers in a desktop grid. 
Second, multiple MPNs are allowed to be chosen simultaneously and therefore can be 
done by different workers in parallel.  
In the rest of this section, Subsection 3.1 briefly describes the initializations of the 
proof/disproof numbers that help guide the search. Subsection 3.2 discusses the first 
feature, node expansion and generation, using NCTU6 and Verifier. Subsection 3.3 
describes a very important algorithm of choosing the next MPN for parallelism for the 
second feature.  
3.1 Proof/Disproof Number Initialization 
This subsection briefly describes how to apply the domain knowledge given by 
NCTU6 to initialization of the proof/disproof numbers. Since it normally takes one 
minute or even more to execute a NCUT6 or Verifier job, it becomes critical to 
choose a good MPN carefully to expand, especially when there are many candidates 
with 1/1 as the standard initialization. In [1], Allis suggested several methods such as 
the use of the number of nodes to be expanded, the number of moves to the end of 
games, or the depth of a node.  
 
  Status Bw B4 B3 B2 B1 W1 W2 W3 W4  Ww stable unstable1 unstable2 
p(n)/d(n)  0/∞ 1/18 2/12 3/10 4/8 8/4 10/3 12/2 18/1 ∞/0 6/6 5/5 4/4 
Table 1: Game status and the corresponding initializations.  
Our approach is simply to trust NCTU6 and use its evaluations on nodes (positions) 
to initialize the proof/disproof numbers in JL-PN search as shown in Table 1. The 
status Bw indicates that Black has a sure win, so the proof/disproof numbers of a node 
with Bw are 0/∞. The status B1 to B4 indicates that the game favors Black with 
different levels, where B1 indicates to favor Black least and B4 most (implicitly 
Black has a very good chance to win for B4) according to the evaluation by NCTU6. 
Similarly, the status W* are for White. The status stable indicates that the game is 
stable for both players, while both unstable1 and unstable2 indicate unstable, where 
unstable2 is more unstable than unstable1.  
Surely, there are many different kinds of initializations other than those in Table 1. 
Our philosophy is simply to pass the domain-specific knowledge from NCTU6 to JL-
PN search. Different programs or games surely have different policies on 
initializations from practical experiences.  
 Assume that for a node n NCTU6 already generates the i-th move, ni, but not 
yet for the (i+1)-st, ni+1. When the node ni is chosen as the MPN for expansion, 
expand ni and generate ni+1 simultaneously. For generating ni+1, NCTU6 
expands n with an exclusive list of moves, n1, n2, …, ni (using the first 
functionality as described in Section 2). For example, when the node n3 is 
chosen as the MPN, expand n3 and expand n (to generate n4) simultaneously. 
On the other hand, if the branch n1 or n2 is chosen, do not generate n4 yet. In 
addition, assume that the move to n4 is a sure loss, reported by NCTU6. From 
the second functionality as described in Section 2, all the moves except for n1, 
n2 and n3 lose. Then, the node n is no longer expanded. In this case, n4 behaves 
as a stopper.  
 
The postponed sibling generation method fits parallelism well, since both 
generating n4 and expanding n3 can be performed simultaneously. Some more issues 
are described as follows.  
One may ask what if we choose to generate n4 before expanding n3. Assume that 
one player, say Attacker, is to move in the OR node n. Let Defender indicate the 
opponent. From the first additional functionality described in Section 2, the move n3 
is supposed to be better for Attacker than n4 (according to the evaluation of NCTU6). 
Assume that it is indeed. Then, the condition p(n3)  p(n4) holds. Thus, the node n3 
must be chosen as the MPN to expand earlier than n4. Thus, it becomes insignificant 
to generate n4 before expanding n3. In addition, the above condition also implies that 
the proof numbers of all the ancestors of node n remains unchanged. As for the 
disproof numbers of all the ancestors of n, these values are the same as or higher. 
Unfortunately, higher disproof numbers discourage the JL-PN search to choose n3 as 
MPNs to expand. Thus, the behavior becomes awkward, especially if the node n3 will 
be proved eventually.  
One may also ask what if we expand n3, but generate n4 later. In such a case, it 
may make the proof number of n fluctuated. An extreme situation is that the value 
becomes infinity when all nodes, n1, n2 and n3, are disproved.  
3.3 Most Proving Nodes in Parallelism 
This subsection discusses the key issue, choosing the MPNs to expand in parallel. 
When no MPNs are being expanded yet, we simply follow the traditional PN search 
to find an MPN and then use the method of postponed sibling generation (described in 
the previous subsection) to expand the MPN and generate its new sibling, if necessary. 
The node expansion and sibling generation form jobs which are respectively 
dispatched to free workers in the desktop grid. Whenever jobs are completed in 
workers, the results are returned back to the client. Then, the client updates the 
proof/disproof numbers of all nodes in the tree accordingly.  
When some more free workers in the desktop grid are available, more MPNs are 
chosen for execution on these workers. However, if we do not change the 
proof/disproof numbers of the chosen MPNs being expanded, named the active MPNs 
in this paper, we would choose the same node obviously, as shown in Figure 2 (a) 
below. The issue is solved by the following policies.  
 
 
 (a) 
 
(b) 
Figure 3: (a) Speedups Sk and (b) efficiencies Ek of the 35 positions for k = 1, 2, 4 or 8.  
 
 (a) 
 (b) 
Figure 4: Normalized logarithmic time scales with 8 cores (a) for the first 20 
positions and (b) for last 15.  
Our next experiment is to investigate the three policies, virtual-win, virtual-loss 
and greedy policies, as proposed in Subsection 3.3. For these policies, we measured 
their computation times with 8 cores only, normalized to those for the virtual-loss 
            
(a)             (b)              (c)            (d)             (e) 
              
  (f)             (g)             (h)      (i)      (j) 
Figure 6: Ten openings in our benchmark. 
Now, re-investigate the 35 positions in the benchmark. Among them, ten are 3-
move openings shown in Figure 6. The winning strategies for the first three were also 
found in [27]. In these openings, White wins in the sixth one, while Black wins in 
others. For many of them, their winning strategies were not found before. Especially, 
the Mickey-Mouse Opening (the ninth one) had been one of popular openings before 
we solved it. The tenth one, also called Straight Opening, is another difficult one.  
5 Conclusion 
The contributions of this paper are summarized as follows.  
 This paper proposes a new approach, JL-PN (job-level proof-number) search, to 
help solve the openings of Connect6. In this approach, some techniques are 
used, such as the method of postponed sibling generation and the policies of 
choosing MPNs. In this paper, JL-PN search was successfully used to solve 
several positions of Connect6 automatically, including several 3-move openings, 
such as Mickey-Mouse Opening and Straight Opening, which none of Connect6 
human experts had been able to solve before.  
 Our experiments also demonstrated roughly linear speedup, even superlinear 
speedups in some cases. Based on JL-PN search, we expect to solve and 
develop more Connect6 openings.  
 From our experiments, we observed that the virtual-loss policy seemed slightly 
better for small tree sizes. However, for large tree sizes, we observed that none 
of the policies had clear advantages over any others.  
In addition, the approach of JL-PN search has several advantages as indicated in 
Section 1. We expect to apply it to many other games in the near future.  
Acknowledgments.  
The authors would like to thank anonymous reviewers for their valuable comments, 
and thank the National Science Council of the Republic of China (Taiwan) for 
[18] Schaeffer, J., Burch, N., Björnsson, Y., N., Kishimoto, A., Müller, M., Lake, R., Lu, P., 
and Sutphen, S., Checkers is solved. Science, Vol. 5844(317), pp. 1518-1552, 2007. 
[19] Seo, M., Iida, H., and Uiterwijk, J., The PN*-search algorithm: Application to 
Tsumeshogi. Artificial Intelligence, Vol. 129(1-2), pp. 253-277, 2001. 
[20] SETI@home Project. available at http://setiathome.ssl.berkeley.edu. 
[21] Taiwan Connect6 Association, Connect6 homepage, available at 
http://www.connect6.org/. 
[22] Thomsen, T., Lambda-search in game trees - with application to Go. ICGA Journal, Vol. 
23(4), pp. 203-217, 2000. 
[23] Winands, M. H. M., Uiterwijk, J. W. H. M., and Herik, H. J. van den, PDS-PN: A new 
proof-number search algorithm: Application to Lines of Action. In J. Schaeffer, M. 
Müller, and Y. Björnson, editors, Computers and Games 2002, Vol. 2883 of LNCS, pp. 
170-185. Computers and Games, Springer, Heidelberg, 2003. 
[24] Wu, I-C., Hsu, S.-C., Yen, S.-J., Lin, S.-S., Kao, K.-Y., Chen, J.-C., Huang, K.-C., 
Chang, H.-Y., and Chung, Y.-C., A Volunteer Computing System for Computer Games 
and its Applications, an integrated project proposal submitted to National Science 
Council, Taiwan, 2010.  
[25] Wu, I.-C., Chen, C.-P., Lin, P.-H., Huang, K.-C., Chen, L.-P., Sun, D.-J., Chan, Y.-C., 
and Tsou, H.-Y., “A Volunteer-Computing-Based Grid Environment for Connect6 
Applications”, the 12th IEEE International Conference on Computational Science and 
Engineering (CSE-09), August 29-31, Vancouver, Canada, 2009. 
[26] Wu, I.-C., and Lin, P.-H., NCTU6-Lite Wins Connect6 Tournament, ICGA Journal, Vol. 
31(4), pp. 240–243, 2008.  
[27] Wu, I.-C., and Lin, P.-H., Relevance-Zone-Oriented Proof Search for Connect6, to 
appear in the IEEE Transactions on Computational Intelligence and AI in Games, 2010. 
[28] Wu, I.-C., Huang, D.-Y., and Chang, H.-C., Connect6. ICGA Journal, Vol. 28(4), pp. 
234-242, 2006. 
[29] Wu, I.-C., and Huang, D.-Y., A New Family of k-in-a-row Games. The 11th Advances in 
Computer Games Conference (ACG'11), pp. 180-194, Taipei, Taiwan, 2005.  
[30] Wu, I.-C., and Yen, S.-J., NCTU6 Wins Connect6 Tournament, ICGA Journal, Vol. 
29(3), pp. 157-158, September 2006.  
[31] Wu, I.-C., et al. Benchmark for Connect6, available at 
http://www.connect6.org/articles/JL-PNS/.  
 
192 IEEE TRANSACTIONS ON COMPUTATIONAL INTELLIGENCE AND AI IN GAMES, VOL. 2, NO. 3, SEPTEMBER 2010
Fig. 1. Sequence of winning moves by White.
Fig. 2. (a) Black’s winning move in Connect(6,2,3). (b) VCDT for a null move
in (a). (c) VCDT for a seminull move 2.
moves are mixed (before ending with a triple-or-more-threat
move). This type of winning strategy is herein called victory by
continuous single-threat-or-more moves (VCST). For example,
Lee [13], a Renju 3-dan player, found and claimed in late
2005 that White won starting from move 8 (both 8 and 10 are
single-threat moves) in the game as shown in Fig. 1. Similarly,
the type of winning strategy with additional non-threat moves
involved is called victory by continuous nonthreat-or-more
moves (VCNT).
Although VCST was unknown then, Wu et al. [30], [31] were
already able to solve a simple VCNT case, when Black wins
Connect(6,2,3). This clearly is a case of VCNT, since Black’s
first winning move, as shown in Fig. 2(a), must be a nonthreat
move. To solve it, they used a simple threat proof search method
involving null or seminull moves and relevance zones, as briefly
described in the following. Let White place no stones, called a
null move in [30] and [31]. Obviously, Black wins by VCDT 3–9
as shown in Fig. 2(b). Then, a relevance zone , the area of gray
squares in Fig. 2(b), can be derived to indicate that White must
place at least one of the two stones inside this zone, or Black
Fig. 3. (a) Position with Black winning. (b) VCDT for the null move in (a). (c)
Winning single-threat move 9 for the seminull move 8.
wins by simply replaying the same VCDT. Next, all squares
in are verified as follows. Let White place one stone on only,
called a seminull move in [30] and [31]; for example, move 2 in
Fig. 2(c). Again, Black is able to win by another VCDT 3–11.
Thus, another relevance zone , the gray area in Fig. 2(c), can
be derived again to indicate that White must place another stone
inside , or Black wins by replaying the same VCDT. Finally,
all are verified such that Black wins over all moves placed at
and , where is in the corresponding to the seminull move
at . Hence, Black was proved to win.
In the above search method for solving the case Con-
nect(6,2,3) with VCNT, both winning strategies for the null
move [3–9 in Fig. 2(b)] and the seminull move [3–11 in
Fig. 2(c)] must be VCDT. However, with more and more win-
ning Connect6 positions investigated, we found that winning
strategies for null and seminull moves may be VCSTs or even
VCNTs, thus making these positions much more difficult to
solve.
For example, consider the two winning nonthreat moves
(proved in this paper): moves 7 in Fig. 3(a) and 6 in Fig. 4(a),
respectively. The former, found in 2006 [20], was the key used
to help prove that Black wins at move 3 in Fig. 3 [see also the
opening in Fig. 22(a)]; that is, the opening move 2 is solved. In
this case, for the null move in Fig. 3(a), Black wins by a VCDT
as shown in Fig. 3(b). However, for the seminull move 8 in
Fig. 3(c), Black has no double-threat moves to win by a VCDT,
though Black wins by a VCST starting at 9 in Fig. 3(c).
The latter, the position in Fig. 4(a) found by Huang [11],
was investigated to see whether the seminull move 5 was safe
enough, since the position at 5 was popular in the following
sense. Among all the first-five-move positions of Connect6
games played by the players ranked above 1800 in [14], about
2% covered (or superset) the position according to the statistics
discussed in [20]. The proof for this position is extremely
complicated. Even for a null move by Black, White has no
194 IEEE TRANSACTIONS ON COMPUTATIONAL INTELLIGENCE AND AI IN GAMES, VOL. 2, NO. 3, SEPTEMBER 2010
Fig. 5. (a) Search tree. (b) Solution tree.
Fig. 6. (a) Marking squares of moves by inserting small boxes. (b) Combining the same edges from (a).
A strategy of the attacker is viewed as a move-generating
function of positions that are in the attacker’s turn. Namely,
indicates the move that the attacker chooses to make ac-
cording to the strategy . In a search tree following , each
position expands at most one move . A strategy of an
attacker is called a winning strategy for position , if and only
if the value of the search tree rooted at is 1 following and
all defender’s legal moves are generated in the tree. Thus, we
obtain Corollary 1. A tree as shown in Fig. 5(b) is called a solu-
tion tree in [5] and [17].
Corollary 1: The attacker wins in a position if and only if
there exists at least one winning strategy of the attacker in .
In order to investigate more closely squares of defensive
moves, insert small rectangles onto the corresponding edges
that are broken into two, marked and , respectively, as
shown in Fig. 6(a). Furthermore, the edges are combined with
the same , as shown in Fig. 6(b). Note that null stones are
marked as and the corresponding edges are indicated by
dashes.
A verifier (for the attacker) is to verify whether the at-
tacker wins in a position by following a strategy . Specifi-
cally, if returns the value 1, then the attacker wins in
and is a winning strategy for . A straightforward verifier
is to verify it by traversing exhaustively the whole solution tree.
Clearly, it is infeasible in most cases, especially in case of very
large boards or even infinite boards. Fortunately, in Connect
games, the traversal of the search tree for proof can be greatly
reduced according to threats, as described in Section III-C. The
traversed search tree for proof by a verifier is called a proof
search tree.
196 IEEE TRANSACTIONS ON COMPUTATIONAL INTELLIGENCE AND AI IN GAMES, VOL. 2, NO. 3, SEPTEMBER 2010
Fig. 10. A   -strategy.
moves are -moves, so it is a -strategy for Connect6(6,2,3).
In Fig. 3(a), move 7 is a -move, and the rest of the attacker
moves are -moves or -moves, so it is a -strategy. Fig. 10
shows a general -strategy. However, it is more complicated
in Fig. 4(a), where move 6 is a -move. Section V shows that
it is a -strategy.
From Definition 2, a -strategy, , also implies that
for a move with null stones the attacker has a -strategy.
For example, in the -strategy in Fig. 10, the attacker has
a -strategy for the null move and -strategies for all the
seminull moves.
E. Relevance Zones
As seen in Section III-E, the lambda search is a powerful
method for proving the winning positions with different orders
of threat sequences. The next important issue for lambda search
is to construct relevance zones to reduce greatly the search
space. In general, different applications construct relevance
zones in different ways. In Connect games, it is critical to
construct relevance zones in order to propagate relevance zones
across different orders of threat sequences. For example, in
Fig. 10, the relevance zones derived in the VCDT ( -strategy)
or VCSTs ( -strategies) can be used in the whole search tree
( -strategy).
This section defines such relevance zones, which are ele-
gantly employed to solve Connect games. A set of squares
on the board is called a zone. A sequence of zones with size
, , is incremental, if the condition
holds. In the rest of this paper, sequences
of zones with different sizes are all incremental and are thus not
explicitly specified. In addition, these zones usually indicate
the squares to be chosen for stones to be placed on, so only
unoccupied (or empty) squares are of interest.
In a position , its unoccupied zone, denoted by ,
is the zone that comprises all the unoccupied squares. That
is, , where is the zone for
the whole board and is the set of all occupied squares
in . Let denote and indicate the set of
unoccupied squares outside . Consider a sequence of zones
in . A sequence of unoccupied squares
, where , is said to be outside
or irrelevant to , if all or . Let
denote the relation that is irrelevant to in .
Fig. 11. Sequence of zones         .
Fig. 12. Sequence of relevance zones          for the winning position
in Fig. 2(a).
Implicitly, denotes .
For example, in Fig. 11, , , , ,
, and even the empty sequence are all irrelevant to
, while , , , ,
, and are not. For simplicity, let denote
. Similarly,
.
Definition 3: A sequence of zones is called a sequence
of relevance zones for the attacker in a position , if and only
if the attacker wins in for all irrelevant ; that is,
. Let denote the set of all the sequences of
relevance zones for the attacker in . (Use the notation
instead of , since only relevance zones for the attacker
are discussed in this paper).
From Definition 3, if is not empty, there must exist
some in . This implies that the attacker wins in by
choosing the empty sequence of squares for , since is ir-
relevant to as described above. Thus, Corollary 2 is obtained.
Corollary 2: If there exists at least one sequence of zones
in , then the attacker wins in .
For the winning sequence in Fig. 2(b), Fig. 12 illustrates rele-
vance zones , where is the set of empty squares
marked with a small “1,” and marked “1” and “2.” Note that
in the rest of this paper, a sequence of zones is shown in this
manner. Interestingly, is the same as in Fig. 2(b). From
198 IEEE TRANSACTIONS ON COMPUTATIONAL INTELLIGENCE AND AI IN GAMES, VOL. 2, NO. 3, SEPTEMBER 2010
“1” or “2” are in , and so on. For example, segment has
only one unoccupied square that is in or higher order zones,
while segment has two unoccupied squares that are in or
higher order zones. It is observed that placing one white stone
on the square in forms a counter win segment (e.g., ) or
an inversion that may prevent the attacker from winning. Note
that if the defender has an inversion, this position is unreach-
able since neither can have win segments simultaneously (as de-
scribed in the previous section); who wins first is thus unknown.
On the other hand, the attacker still wins if one white stone is
placed in square , where . Similarly, the attacker still
wins if one white stone is placed on , where , and the
other on , where . The above can be generalized to
higher orders, and to all lines (or segments) on a board. An ex-
ample of constructing zones on a board is illustrated in
Fig. 13(b). Note that move 10 in the figure is simply one of all
the defenses and is chosen for an illustration. In addition, since
move 9 clearly wins already, Section IV-D will describe how to
speed up the establishment of relevance zones.
From the above observation, it can be derived that the con-
structed in operation EP-1 is in . This implies that
satisfies Property RZV in the case of endgame , as
shown in Lemma 4.
Lemma 4: Assume to be an endgame position. Property
RZV is satisfied for .
Proof: Omitted.
In Connect6, all with , are nearly the same as
, except for those unoccupied squares covered by none
of the active segments of the defender. For example, if an unoc-
cupied square is surrounded by the attacker’s squares, it is clearly
covered by none of the active segments of the defender and is not
included in these . However, there are normally not many
such squares, especially when board sizes are large and only a
small number of stones are in positions. Practically, we simply
ignore all with or use whenever needed.
B. Positions in the Attacker’s Turn
In such positions, the attacker simply follows strategy to
make the move in . Let denote . This ver-
ifier first performs recursively. If re-
turns the value 0, this verifier also returns 0. On the
other hand, if returns 1, this verifier re-
turns 1 as well, and constructs in the following operation.
AT-1) Let , where .
Intuitively, placing any stones on the squares in by the de-
fender in advance may block the attacks and prevent the attacker
from winning. In this sense, the squares in are relevant and
are therefore contained in all (or ).
In fact, the above operation AT-1 also implies the property
for the following reason. From the op-
eration, the condition holds for all . In
addition, since , it is clear that
or . Thus, for all , we
derive
From this property, Lemma 5 shows that this verifier
satisfies Property RZV if satisfies Property RZV.
Lemma 5: Assume a position in the attacker’s turn. From
the above, assume that satisfies Property RZV,
where . This verifier satisfies
Property RZV.
Proof: Assume that this verifier returns the
value 1. For this lemma (this verifier satisfies Property RZV), it
suffices to prove that the constructed is in . From
the above operation, must also return 1. Since
satisfies Property RZV from the lemma, is
in .
Consider all irrelevant , where . It suffices
to prove that the attacker wins in . Since the prop-
erty is satisfied as described above, the
condition holds as well. Since is in
from the above, the attacker wins in due
to . Since the attacker wins in
, the attacker wins in by
choosing the move .
C. Positions in the Defender’s Turn
For positions in the defender’s turn, Lemma 6 shows a
very important property used in this section as well as in the
Appendix.
Lemma 6: Assume a position in the defender’s turn. For a
given sequence of zones , assume that for all defender moves
there exists some such that and is in
. Then, is in .
Proof: Consider all irrelevant . For this lemma,
it suffices to prove that the attacker wins in .
Now, consider all defender moves in . From
this lemma, there exists some such that and
is in . Since , the condition
implies . Since squares in and are mu-
tually exclusive, also implies .
Since is in from the above, the attacker
wins in due to . Since
, the attacker also
wins in . From the above, since the attacker
wins in over all defender moves , the
attacker wins in .
A straightforward verifier is to verify whether the attacker
wins for all defender moves, as follows. The verifier
returns value 1, if the recursive returns 1 for all
defender moves ; otherwise, it returns 0. In the case that this
verifier returns 1, the zones are constructed in
the following operation.
DT-1) Initialize all zones in to be empty. Then, for all
defender moves , let .
From the above operation, the condition
clearly holds for all . Assume that all the recursive
satisfy Property RZV. Then, all
are in for all defender moves . From Lemma
6, we obtain that is in ; and therefore, the verifier
satisfies Property RZV. By induction, the above straightforward
verifier satisfies Property RZV in all cases.
200 IEEE TRANSACTIONS ON COMPUTATIONAL INTELLIGENCE AND AI IN GAMES, VOL. 2, NO. 3, SEPTEMBER 2010
Fig. 15. Winning position with two threats for Black (the attacker) and the
constructed    .
T2-2) Continue to construct zones by both operations T3-1 and
T3-2, and return 1.
For example, for position in Fig. 15 [the grandparent of the
position in Fig. 14(b)] where Black has two threats, White has
three defensive moves at (B,C), (A,C), and (B,D). Obviously,
since Black still wins for each of the three moves, Black wins
in . From the above operations, this verifier returns value 1
and constructs as shown in Fig. 15. Lemma 8 shows that
this verifier satisfies Property RZV if the verifier satisfies Prop-
erty RZV for all the defensive moves as well. From this lemma,
in Fig. 15 is in .
Lemma 8: From the above, assume that the defender is to
move and the attacker has two threats in . Assume that all
the recursive in operation T2-1 satisfy Property
RZV. Then, the verifier satisfies Property RZV as
well.
Proof: Assume that this verifier returns 1. For
this lemma (this verifier satisfies Property RZV), it suffices to
prove that the constructed is in . Since
returns 1, all the recursive in operation T2-1 must
return 1. Since these satisfy Property RZV from
this lemma, all constructed are in .
To prove , it suffices to prove from Lemma
6 the following. For all defender moves , there exists some
such that is in and . All
defender moves are classified into the following cases.
1) All defender moves that block both threats. From the
above, are in . In addition, since these
are merged into in operation T2-1b, we ob-
tain . Thus, is the .
2) All defender moves that leave some threat segment
unblocked. The attacker wins by connecting six on the
Fig. 16. Combining three defensive moves into one with four stones.
segment, like strategy . Since operation T2-2 follows
those steps in T3-1 and T3-2, we simply follow the proof
of Lemma 7 to prove that there exists some such that
and is in .
Assume that the subsequent winning moves of the attacker
are the same for all the defensive moves. Then, we can optimize
the construction of zones by combining these defensive moves
together. For example, in Fig. 15, the three defensive moves,
(B,C), (A,C), and (B,D), can be combined into a macromove
(A, B, C, D) as shown in Fig. 16. Since the subsequent winning
sequences of the attacker are the same, the sizes of relevance
zones are relatively smaller and the threat-based search is also
greatly reduced. However, note that the segment containing
both A and B (the same for C and D) in Fig. 15 should be
considered to have one white stone only for zone construction.
Since the winning sequences in Fig. 2(b) are the same for all
defensive moves, the relevance zones are constructed as shown
in Fig. 12.
3) One Threat: When the attacker has one threat, the de-
fender must defend by blocking the threat. In this case, the ver-
ifier performs the following operations.
T1-1) For each normal critical defense (defined in
Section III-C), , where square blocks the
threat, perform the operation of seminull-move proof
search as follows.
a) Return value 0, if the recursive returns
0 where .
b) Let .
c) For each defensive move , where
, perform both operations T2-1a and T2-1b.
T1-2) For all relaxed critical defenses , perform both
operations T2-1a and T2-1b.
T1-3) Perform both operations T3-1 and T3-2, and return 1.
202 IEEE TRANSACTIONS ON COMPUTATIONAL INTELLIGENCE AND AI IN GAMES, VOL. 2, NO. 3, SEPTEMBER 2010
Lemma 10: Assume that the defender is to move and the at-
tacker has no threats in . From the above, assume that all re-
cursive in both operations T0-1 and T0-3 satisfy Property
RZV. Then, the verifier also satisfies Property RZV.
Proof: Assume that this verifier returns 1. For
this lemma, it suffices to prove that the constructed is
in . Since returns 1, all the recursive in
both operations T0-1 and T0-3 must also return 1. Since these
recursive , say for position , satisfy Property RZV from
this lemma, the constructed zones are in .
To prove , it suffices to prove from Lemma
6 the following: for all defender moves , there exists some
such that is in and . All
defender moves are classified into the following cases.
1) All defender moves where
and . From the first paragraph in this
proof, is in . Since and
, is in
from Lemma 3. Since
, is also in .
In addition, from operation T0-2.
Thus, is .
2) All defender moves where . By
following the proof for case 1 (including subcases 1a and
1b) in Lemma 9, we obtain that there exists some in
for all such that . The details
are omitted.
D. Conclusion
Theorem 2 concludes that the verifier in all cases
satisfies Property RZV. Therefore, if returns value 1,
the constructed is in , and the attacker wins in
from Corollary 2.
Theorem 2: The verifier satisfies Property RZV in
all cases.
Proof: By induction, the verifier satisfies Prop-
erty RZV in all cases from Lemma 4 to Lemma 10.
V. SOLVING CONNECT6 POSITIONS
In Section IV, we present a verifier to verify
whether the attacker wins in a Connect6 position by fol-
lowing strategy . However, in order to solve positions, we still
need to provide the verifier with winning strategies . Winning
strategies can be provided in the following three ways.
1) Let human experts offer the winning strategies manually.
2) Let programs find the winning strategies automatically.
3) Find the winning strategies by mixing the above two.
Traditionally, experts used the first way to claim that some po-
sitions are winning, e.g., Go-Moku and Renju [18]. However, it
becomes complicated and tedious for human players to traverse
all positions to prove it thoroughly. Hence, it is more feasible to
solve these positions by programs using the second way. How-
ever, programs may not be smart enough sometimes to find the
correct winning moves. Therefore, some researchers chose the
third way by following experts’ suggestions for some opening
moves and then letting programs solve the subsequent moves.
For example, Allis [1], [2] solved Go-Moku in the free style, and
Wágner and Virág [23] solved Renju. In Section V-A, we devel-
oped some assistant programs to help find the winning strategies
for Connect6. In Section V-B, we illustrate our new proof search
method in Section IV by solving the positions in Figs. 3(a) and
4(a). Finally, we give more results in Section V-C.
A. Assistant Programs
This section describes some assistant programs developed for
solvers and verifiers. Given a position in the attacker’s turn,
a solver is to return a winning move as well as the relevance
zones, if found; and, otherwise, a null move is returned to in-
dicate failure of finding a winning move. A solver of finding a
VCDT strategy, denoted by , is described as follows.
1) If there exist connect-six moves or triple-threat-or-higher
moves, simply choose one of them to win.
2) Evaluate all the double-threat moves and choose some
good ones for further expansion (according to the evalu-
ations).
3) For each chosen move , return if
returns 1.
4) Return the null move to indicate failure of finding a win-
ning move.
A solver of finding a VCST (VCNT) is similar to the above,
except that single-threat (nonthreat) moves are also evaluated
and chosen at step 2. Actual solvers are implemented in a more
complicated way to reduce the size of a search tree and control
the timing. For example, the techniques of iterative deepening
and transposition table are normally incorporated.
In this paper, we implemented a solver with VCDT,
named VCDT-Solver, and another solver with VCST, named
VCST-Solver. More accurately, the VCDT-Solver is to find a
-strategy, while the VCST-Solver is to find a -strategy.
Our VCST-Solver also tends to find VCDTs, if any, unless
some single-threat moves are evaluated to be much better.
Currently, this solver is able to find a -strategy up to depth
25 where the size of the longest path with -moves is 13.
This solver was also incorporated into our Connect6 program
NCTU6, which won the gold at the 11th and 13th Computer
Olympiads [26], [33] in 2006 and 2008, respectively; and also
won eight games and lost none against top Connect6 players
in Taiwan in 2009 [12]. From our experience, VCST-Solver is
able to find -strategies, if any, in most cases accurately.
Regarding solvers for -strategies or strategies of higher or-
ders, the time complexities become much higher, since the num-
bers of defensive moves to be verified grow much higher. There-
fore, we did not implement it directly.
First, we implemented a verifier, named NCTU6-Verifier, to
verify whether the attacker wins for all defender moves. In other
words, given a position in the defender’s turn as shown in
Fig. 18(a), the verifier uses VCDT-Solver for null moves and
VCST-Solver for all seminull moves and nonnull moves. If null
and seminull moves are all solved, then move (from the
parent of to ) in Fig. 18(a) is an attacker -move. If some
nonnull moves are not solved by VCST-Solver, these moves are
reported or generated. Note that the defender -moves must
be reported. Since our VCST-Solver can find -strategies ac-
curately in most cases, most reported moves are the defender
-moves in our experiments.
204 IEEE TRANSACTIONS ON COMPUTATIONAL INTELLIGENCE AND AI IN GAMES, VOL. 2, NO. 3, SEPTEMBER 2010
Fig. 20. Proof search tree for the position in Fig. 4(a).
TABLE I
STATISTICS OF SOLVING POSITIONS
Fig. 21. Sequence of   -moves starting from 7.
helped find 26 winning nonthreat moves, including move 6 dis-
covered by Huang [11].
Table I shows the number of nodes as well as the computa-
tion times used by our system to solve the positions in Figs. 2(a),
3(a), and 4(a) on an Intel Pentium Dual 2.00-GHz machine. The
positions in Figs. 2(a) and 3(a) are solved without experts’ as-
sistance, while the position in Fig. 4(a) is solved with the help
of experts, as above. All the above experiments were performed
on 19 19 boards that most current Connect6 tournaments use.
We also used a simple tool to verify that the above example is
still winning even in an infinite board. The details are omitted.
C. More Results
In addition to the two positions illustrated in Section V-B,
we investigated more positions. Initially, we had experts use the
integrated system to help us solve about ten more positions. Wu
et al. [28] had recently automated with success the proof process
by developing a new search algorithm, called job-level proof-
number (JL-PN) search. Using the JL-PN search together with
our RZOP search, we solved many more positions, up to 65
positions in total, with -strategy, within a couple of months.
The details of the 65 positions were listed in [27].
Among the 65 positions, 34 were not solved by the scheme,
called the VCDT-for-null scheme. The scheme uses VCDTs
(not VCSTs) after seminull moves in proof search trees such as
the one in Fig. 2(c). If no VCDTs were found for the seminull
moves as the one in Fig. 3(c), then the scheme failed to solve
positions. In brief, the proof search trees in our RZOP search
are as in Fig. 18(a), while those in the scheme are as in Fig. 8.
Many positions were not solved by the VCDT-for-null
scheme illustrated below. For the three openings in
Fig. 22(c), (d), and (f), the winning moves are live threes
at 3. For the seminull moves that use the only stones to block
Black’s live threes, Black has no more double-threat moves to
make. That is, Black cannot win by VCDTs. However, Black
actually wins by VCSTs for these seminull moves. Hence, it is
important that the proposed RZOP can solve them correctly.
206 IEEE TRANSACTIONS ON COMPUTATIONAL INTELLIGENCE AND AI IN GAMES, VOL. 2, NO. 3, SEPTEMBER 2010
Proof: The proof is similar to that of Lemma 7 and there-
fore omitted.
In the second case that the number of attacker threats is at
most , the verifier performs the following operations.
Tp-1) For each of critical defenses (both normal and re-
laxed), perform the following.
a) Return 0 if the subverifier returns
0. Note that the subverifier is described below.
b) Let .
Tp-2) Continue to construct relevance zones in operation
Tp1-1, and return 1.
In operation Tp-1a, a subverifier is used to
verify whether the attacker wins for all defender moves
dominated by in , where has squares (but
may have less than squares). By dominate, we mean that all
squares in must also be in , but not vice versa. For the
subverifier , the constructed zone is denoted by
, where
. In addition, the subverifier satisfies the following property
(proved in Lemma 12).
Property RZS: If returns 1, the following
condition holds. For all defender moves dominated by ,
there exists some such that and is in
.
The subverifier performs the following op-
erations.
Par-1) Assume that has exactly defender stones,
where is the number of null stones in and
. In the case that , move is a null or a
seminull move.
Par-2) Return 0 if returns 0, where
.
Par-3) Let .
Par-4) Return 1 if , i.e., the move is not a null or a
seminull move.
Par-5) For each of unoccupied square , per-
form the following.
a) Let the defender move be .
b) Return 0 if returns 0.
c) Let , where
.
Par-6) Return 1.
Lemma 12 shows that the subverifier satisfies Property RZS,
if all the recursive in Par-5b satisfy Property RZS and the
verifier in Par-2 satisfies Property RZV.
Lemma 12: For a subverifier as described
above, it satisfies Property RZS by assuming that all the recur-
sive in Par-5b satisfy Property RZS and that the verifier
in Par-2 satisfies Property RZV.
Proof: Assume that returns 1. Consider
all defender moves (including stones) that are dominated
by . Namely, let , where has addi-
tional unoccupied squares. For this lemma, it suffices to prove
that there exists some such that and is
in . All of these defender moves are classi-
fied into the following cases.
1) All defender moves in which all additional squares
in are in . The proof for this case is
similar to that for case 1 in Lemma 10 as follows. Since
this subverifier returns 1, the verifier in Par-2
returns 1. Since the verifier returns 1 and also satisfies
Property RZV (from this lemma), is in .
Since all additional , we obtain from
Lemma 3 that is in . Since
is also in . In addition, since
from Par-3 in , is the .
2) All defender moves where some additional square
in is in . Since this subverifier returns 1, the
recursive at Par-5b returns 1 as well,
and therefore, satisfies Property RZS. From Property RZS,
there exists some such that and is in
. Since from operation
Par-5c, we obtain . Thus, is the .
From Lemma 12, we derive Lemma 13 as follows.
Lemma 13: Assume that the defender is to move and the
number of attacker threats is at most in . The verifier de-
scribed above satisfies Property RZV by assuming that all the
recursive subverifiers in operation Tp-1a satisfy Property RZS.
Proof: Assume that this verifier returns 1. For this lemma,
it suffices to prove that the constructed is in . Since
the verifier returns 1, all the recursive subverifiers in operation
Tp-1a returns 1 as well. Assume that these subverifiers satisfy
Property RZS. For proving , it suffices to prove
from Lemma 6 the following: for all defender moves , there
exists some such that is in and
. All defender moves are classified into the following
two cases.
1) All defender moves that block all the threats. There
must exist some critical defense (either normal or re-
laxed) dominating . Since returns 1
and satisfies Property RZS from the above, there exists
some from the property such that
and is in .
2) All defender moves that leave some threat unblocked.
The attacker wins by connecting up to on some un-
blocked threat segment, like . From the proof in
Lemma 11, we obtain that there exists some such that
and is in .
Theorem 3 concludes that the verifier in all cases
satisfies Property RZV. Therefore, if returns 1, the
constructed is in , and the attacker wins in
from Corollary 2. It can also be observed that the operations
in Section IV-D are special cases of the operations described in
this Appendix.
Theorem 3: The verifier satisfies Property
RZV in all cases.
Proof: By induction, the verifier satisfies Prop-
erty RZV in all cases from the above lemmas.
ACKNOWLEDGMENT
The authors would like to thank anonymous reviewers for
their valuable comments.
Theoretical Computer Science 412 (2011) 4558–4569
Contents lists available at ScienceDirect
Theoretical Computer Science
journal homepage: www.elsevier.com/locate/tcs
Drawn k-in-a-row games
Sheng-Hao Chiang a, I-Chen Wu b,∗, Ping-Hung Lin b
a National Experimental High School at Hsinchu Science Park, Hsinchu, Taiwan
b Department of Computer Science, National Chiao Tung University, Hsinchu, Taiwan
a r t i c l e i n f o
Article history:
Received 12 July 2009
Received in revised form 20 January 2011
Accepted 21 April 2011
Communicated by G. Ausiello
Keywords:
k-in-a-row games
Connect6
Hypergraphs
a b s t r a c t
Wu and Huang (2005) [12] and Wu et al. (2006) [13] presented a generalized family of
k-in-a-row games, called Connect(m, n, k, p, q). Two players, Black and White, alternately
place p stones on anm×n board in each turn. Black plays first, and places q stones initially.
The player who first gets k consecutive stones of his/her own horizontally, vertically, or
diagonally wins. Both tie the gamewhen the board is filled upwith neither player winning.
A Connect(m, n, k, p, q) game is drawn if neither has any winning strategy. Given p, this
paper derives the value kdraw(p), such that Connect(m, n, k, p, q) games are drawn for all
k ≥ kdraw(p), m ≥ 1, n ≥ 1, 0 ≤ q ≤ p, as follows. (1) kdraw(p) = 11. (2) For all
p ≥ 3, kdraw(p) = 3p + 3d − 1, where d is a logarithmic function of p. So, the ratio
kdraw(p)/p is approximately 3 for sufficiently large p. The first result was derived with the
help of a program. To our knowledge, our kdraw(p) values are currently the smallest for all
2 ≤ p < 1000.
© 2011 Elsevier B.V. All rights reserved.
1. Introduction
A generalized family of k-in-a-row games, called Connect(m, n, k, p, q), [12,13], was introduced and presented by Wu
et al. Two players, Black andWhite, alternately place p stones on empty squares1 of anm× n board in each turn. Black plays
first, and places q stones initially. The player who first gets k consecutive stones of his/her own horizontally, vertically, or
diagonally wins. Both players tie the game when the board is filled up with neither player winning. For example, Tic-tac-toe
is Connect(3, 3, 3, 1, 1), Go-Moku in the free style (a traditional five-in-a-row game) is Connect(15, 15, 5, 1, 1), and Connect6
[13], played on the traditional Go board, is Connect(19, 19, 6, 2, 1).
In the past, many researchers have been engaged in solving Connect(m, n, k, p, q) games. One player, either Black orWhite,
is said to win a game, if he/she has a winning strategy such that he/she wins for all the subsequent moves. Allis et al. [1,2]
solved Go-Moku with Black winning. Herik et al. [9] and Wu et al. [12,13] also mentioned several k-in-a-row games with
Black winning.
A game is said to be drawn if neither player has anywinning strategy. For simplicity of discussion in this paper, Connect(k,
p) refers to the collection of Connect(m, n, k, p, q) games for all m ≥ 1, n ≥ 1, 0 ≤ q ≤ p. Connect(k, p) is said to be
drawn if all Connect(m, n, k, p, q) games in Connect(k, p) are drawn. Given p, this paper derives the value kdraw(p), such that
Connect(kdraw(p), p) games are drawn. Since drawn Connect(k, p) games also imply drawn Connect(k+1, p), the value kdraw(p)
should be as small as possible.
In the past, Zetters [15] derived that Connect(8, 1) is drawn. Pluhar [11] derived tight bounds kdraw(p) = p +Ω(log2 p)
for all p ≥ 1000 (see Theorem 1 in [11]). However, the requirement that p ≥ 1000 is unrealistic in real games. Thus, it is
∗ Corresponding author. Tel.: +886 3 5731855; fax: +886 3 5733777.
E-mail addresses: jiang555@ms37.hinet.net (S.-H. Chiang), icwu@csie.nctu.edu.tw, icwu@cs.nctu.edu.tw (I.-C. Wu), bhlin@csie.nctu.edu.tw (P.-H. Lin).
1 Practically, stones are placed on empty intersections of Renju or Go boards. In this paper, when we say squares, we mean intersections.
0304-3975/$ – see front matter© 2011 Elsevier B.V. All rights reserved.
doi:10.1016/j.tcs.2011.04.033
4560 S.-H. Chiang et al. / Theoretical Computer Science 412 (2011) 4558–4569
Fig. 1. The game board B2 .
Fig. 2. (a) Partitioning the infinite board into disjoint B2 . (b) Covering one complete solid line for each segment of 11 consecutive squares.
The gameMBBoard(B, p) is said to be a drawn game if Black has no winning strategy, that is, White has some strategy to
prevent Black from winning in all cases.
In the above game, the game board B can be viewed as a kind of hypergraph G [4,8]. All squares in B are vertices in G, while
all (solid) lines in B are edges, or so-called hyperedges in G, covering a set of vertices. For example, the board in Fig. 1 includes
6× 4 squares with 4 horizontal, 3 vertical, and 6 diagonal lines (from the lower left to the upper right). The corresponding
hypergraph includes 24 vertices and 13 (i.e., 4 + 3 + 6) edges, accordingly. In the rest of this paper, we still use the terms
game boards, lines, and squares, instead of graphs, edges, and vertices.
3. Proof of Theorem 1
The infinite board is partitioned into an infinite number of disjoint B2 (without overlap and vacancy) as shown in Fig. 2(a),
where B2 is the game board shown in Fig. 1. From Lemma 1 (below), sinceMBBoard(B2, 2) is drawn,White has some strategy
S such that none of the solid lines are occupied by Black. LetWhite follow S to play inside each B2. Observed from Fig. 2(b), all
segments of 11 consecutive squares vertically, horizontally, and diagonally must cover entirely one solid line among these
B2. Since none of these solid lines are occupied by Black from Lemma 1, none of the segments contain all 11 black stones.
Thus,MBConnect(11, 2) is drawn. From Corollary 1, Connect(11, 2) is drawn. 
Lemma 1. MBBoard(B2, 2) is drawn.
Proof. A program was written to verify that none of the solid lines in B2 are occupied by Black. The program is briefly
described in Section 3.2. An intuition is given in Section 3.1. 
3.1. Intuition for Lemma 1
This subsection gives an intuition for the correctness of Lemma 1. Move 1 (by Black) is classified into the following cases.
1. Black only places one stone in the board, as illustrated in Fig. 3(a).
2. Black places two stones.
2.1 Both are placed on the two squares marked ‘‘1’’ in Fig. 3(b), calledmiddle squares for this game board.
2.2 One of the two stones is placed on either of the two middle squares.
2.3 Neither of the two stones is placed on the two middle squares.
In Case 2.1, White replies by placing two stones, as shown in Fig. 3(b); and in all the other cases, White replies by placing
one stone on one of the twomiddle squares. Here, only Case 1 in Fig. 3(a) and Case 2.1 in Fig. 3(b) are illustrated. Intuitively,
it is hard for Black to occupy a horizontal line, since the horizontal lines contain two more squares than the vertical and
diagonal lines. Therefore, let us ignore and remove the horizontal lines for simplicity of analysis.
After Move 2 (by White), Fig. 4 shows the boards with active vertical and diagonal lines only. Let an active line be a line
that does not yet contain a white stone. Since Black is never able to cover all the squares of some inactive line (not active),
4562 S.-H. Chiang et al. / Theoretical Computer Science 412 (2011) 4558–4569
(a) BZ (L).
(b) BN (L).
Fig. 5. Two game boards: (a) BZ (L) and (b) BN (L).
Fig. 6. Partitioning the infinite board into disjoint BZ (L).
in Fig. 5(a), where each (solid) line covers L squares and the game board extends infinitely to both sides. The game B−Z (L)
is a horizontal mirror of BZ (L). Fig. 5(b) also shows another similar game board BN(L), which will be used in this section.
Let MBBoardZ(L, p) denote the game MBBoard(BZ (L), p), and MBBoardN(L, p) denote MBBoard(BN(L), p), for simplicity of
discussion. This proof will show that the following three properties are satisfied.
Property 1. If MBBoardZ(L, p) is drawn, then MBConnect(3L− 1, p) is drawn.
Property 2. If MBBoardN(L, p) is drawn, then MBConnect(3L− 1, p) is drawn.
Property 3. Consider all p ≥ 1. Let P(d − 1) < p ≤ P(d), where P(d) = 2d − d − 2. Then, MBBoardN(p + d, p) games are
drawn.
First, Property 1 is satisfied for the following reason. As observed in Fig. 6, all segments of 3L − 1 consecutive squares
vertically, horizontally, and diagonally must contain one whole solid line among these BZ (L) and B−Z (L). Assume that the
game MBBoardZ(L, p) is drawn. Then, White has some strategy S such that Black cannot occupy any solid lines inside each
BZ (L) and B−Z (L). Thus, by following the strategy S inside each BZ (L) and B−Z (L), White prevents Black from occupying any
segment of 3L− 1 consecutive squares completely. Thus,MBConnect(3L− 1, p) is drawn.
Then, both Properties 2 and 3 are shown in Sections 4.1 and 4.2, respectively. Section 4.1 shows that the game board
BZ (L) is isomorphic to BN(L), in the sense of hypergraphs [4,8], and that Property 2 is satisfied from the isomorphism and
Property 1. Section 4.2 proves that Property 3 is satisfied for all MBBoardN games listed in Property 3. Thus, Theorem 2 is
satisfied from Corollary 1, Property 2 and Property 3. 
4564 S.-H. Chiang et al. / Theoretical Computer Science 412 (2011) 4558–4569
Fig. 8. Three game boards with exclusive squares (solid bullets). (a) BrecX (m, n). (b) BrecX−(m, n). (c) BNX (L).
Fig. 9. An illustration. (a) The original game board. (b) Partitioned game boards with exclusive squares.
The gameMBBoardX(B, b) is said to be a drawn game if White has some strategy to prevent Black winning in all cases.
The motivation of using exclusive squares is to partition a game board into two or more game boards with exclusive
squares and then to use Lemma 4 (below) to derive some properties from the partitioned game boards. Let us illustrate it by
a simple gameMBBoard(B, 9) as follows. Let the board B contain disjoint lines each with 10 squares (which are not covered
by any other lines), as shown in Fig. 9(a). Then, partition the board B into two, one named Bleft containing 5 squares of each
line and the other Bright containing the other 5, and add exclusive squares to all lines as shown in Fig. 9(b). Clearly, both
games MBBoardX(Bleft , 0) and MBBoardX(Bright , 0) are drawn, for the following reason. Whenever Black places one or more
stones on some line, White places one stone on the exclusive square of the line to defend. From Lemma 4, we obtain that
MBBoard(B, 10 − (0 + 0) − 1) is drawn; that is, MBBoard(B, 9) is drawn. Obviously, it is true that MBBoard(B, 9) is drawn,
from the following observation. Whenever Black places one or more stones on some active line, White places one stone on
that line in the next move to make it inactive. Note that Black must leave one square unoccupied in an active line, so White
is allowed to place a stone on that line.
Lemma 4. Consider a game board B, where each line covers at least L squares. Partition3 the game board B into two disjoint game
boards, B1 and B2. Assume that both games MBBoardX(B1, b1) and MBBoardX(B2, b2) are drawn and that L − (b1 + b2) > 1.
Then, White has some strategy in MBBoard(B, L− (b1 + b2)− 1) such that each active line in B contains at most b1 + b2 black
stones at all times t2i (when Black is to play), where i ≥ 0. Implicitly, MBBoard(B, L− (b1 + b2)− 1) is drawn.
Proof. It suffices to prove by induction thatWhite has some strategy such that each active line in B contains at most b1+ b2
black stones at all times t2i, where i ≥ 0. This implies thatMBBoard(B, L− (b1+b2)−1) is drawn, since Black cannot occupy
any active line (at most b1+ b2 black stones) in the next move (at most L− (b1+ b2)− 1 black stones), and each line covers
at least L (≥(b1 + b2)+ L− (b1 + b2)− 1 = L− 1) squares.
It is trivial that the induction hypothesis is true initially.
Assume that the induction hypothesis is true at t2i, when Black is to move. Consider Black’s next move. Since Black can
place atmost L−b1−b2−1 stones in amove, each active linemust leave one square unoccupied. Now, investigate the black
stones of this move in B1. SinceMBBoardX(B1, b1) is drawn according to the assumption, White must has some strategy for
the game such that each active line contains at most b1 black stones in B1 at t2i+2. Thus, White simply follows the strategy to
place stones at the edge of B1. In the case that White needs to place a stone on the exclusive square in one active line in B1,
White uses the following strategy. If the corresponding line in B is inactive (e.g., the line contains a white stone at the edge
of B2), simply ignore this line. Otherwise, if it is active, White simply places one stone on the unoccupied square of the line
3 In the partitioning, we assume that each square belongs to either B1 or B2 and that each pair of squares in either B1 or B2 is covered by one line if they
are also covered by the same line in B.
4566 S.-H. Chiang et al. / Theoretical Computer Science 412 (2011) 4558–4569
Fig. 11. (a) and (b): Two cases for BrecX−(m, n) in and (c) another case for the board missing two corner squares.
Fig. 12. The case that Black already occupies L− p stones on an active line.
the same horizontal line as shown in Fig. 11(b). Similarly, since the variable σ is only 1, simply follow the strategy described
in Lemma 5 to maintain σ ≤ 1. Thus, White is able to maintain σ ≤ 1 in all cases. That is, MBBoardX(BrecX−(m, n), 1) is
drawn. (Note that we may not maintain σ ≤ 1 when two corner squares are missing, as illustrated in Fig. 11(c).) 
Lemma 7. As described above, assume that the game MBBoardN(L, p) is drawn. Then, MBBoardNX(L, L− p− 1) is drawn.
Proof. SinceMBBoardN(L, p) is drawn, White has a strategy S such that all active lines have at most L− p− 1 black stones
at all times t2i (when Black is to play). Otherwise, if an active line contains at least L− p black stones, Black wins by simply
placing p stones on this line, as illustrated in Fig. 12.
In the gameMBBoardNX(L, L− p− 1), assume that Black still places at most p black stones in Move 2i+ 1, where i ≥ 0.
Then, White simply follows strategy S (without placing stones on exclusive squares) such that all active lines in BNX (L)
contain at most L− p− 1 black stones at all times t2i+2 (when Black is to play).
Assume that Blackmakes amovewithmore than p black stones.We separate themove into several submoves, eachwith
at most p black stones. Then, White pretends that Black makes submoves one by one, and for each submove simply follows
S to play, but with the following exceptional case. By following S, assume that White needs to make a submove on some
empty squares, but some subsequent Black submoves will place stones on these empty squares. Without loss of generality,
assume that White makes a submove M on an empty square s, but some subsequent Black submove M ′ will place a stone
on s. Then, the strategy is changed as follows.
1. Place two white stones respectively on the exclusive squares of the two lines containing s, instead. The reason is similar
to that in Case 5 in Lemma 5. Both lines containing s are no longer active. Let the black stone at s be added into M and
removed from M ′. Thus, the reply to M still prevents Black from having active lines with more than L − p − 1 black
stones. Although the reply toM uses one more stone,M has one more stone on s too.
Thus, all active lines in the gameMBBoardNX(L, L− p− 1) have at most L− p− 1 black stones at all t2i (when Black is to
play). That is,MBBoardNX(L, L− p− 1) is drawn. 
4.2.2. Initial drawn games
In this subsection, initial MBBoardN(4, 1), MBBoardNX(2, 1) and MBBoardNX(3, 2) games are shown to be drawn in
Lemma 8, Lemma 9, and Lemma 10 respectively.
Lemma 8. MBBoardN(4, 1) is drawn.
Proof. Let us transform BN(4) into BN−(4) by shortening the solid lines, as shown in Fig. 13. Since BN−(4) is a tree and there
are no black stones initially, BN−(4) is drawn, from Lemma 2. Obviously, this implies that BN(4) with extra longer lines is
drawn too. 
Lemma 9. MBBoardNX(2, 1) is drawn.
4568 S.-H. Chiang et al. / Theoretical Computer Science 412 (2011) 4558–4569
Fig. 17. (a) Half of the dark gray game board. (b) Squeezing the game board in (a) into a BN (L).
Fig. 18. Partitioning BN (2L+ 2) into light gray and dark gray zones.
Table 1
List of drawnMBBoardN games derived from Property 4, where 2 ≤ p ≤ 4.
Drawn games Drawn games derived from Lemma 11 or Lemma 12.
MBBoardNX(2, 1) → MBBoardN(5, 2) andMBBoardN(6, 3)
MBBoardNX(3, 2) → MBBoardN(7, 3) andMBBoardN(8, 4)
Table 2
List of drawnMBBoardN games derived from Property 5, where 5 ≤ p ≤ 13.
Drawn games Drawn games derived from Lemmas 13 and 14.
MBBoardN(4, 1) → MBBoardN(9, 5) andMBBoardN(10, 6)
MBBoardN(5, 2) → MBBoardN(11, 7) andMBBoardN(12, 8)
MBBoardN(6, 3) → MBBoardN(13, 9) andMBBoardN(14, 10)
MBBoardN(7, 3) → MBBoardN(15, 10) andMBBoardN(16, 11)
MBBoardN(8, 4) → MBBoardN(17, 12) andMBBoardN(18, 13)
Proof. This proof is similar to that in Lemma 11, except that BrecX−(L + 2, L + 2) is used (instead of BrecX ) and some lines
marked in dashed boxes in Fig. 18 are covered by two BrecX−(L+ 2, L+ 2). For the lines covered by two BrecX−(L+ 2, L+ 2),
since each active line in BrecX−(L+ 2, L+ 2) contains at most one black stone, each of these lines, if active, contains at most
two black stoneswhen Black is to play. For the other lines, we can still use Lemma4 to derive that each line, if active, contains
at most b+ 1 black stones when Black is to play. Since b+ 1 ≥ 2, all lines contain at most b+ 1 black stones when Black is
to play. Thus, the gameMBBoardN(2L+ 2, (2L+ 2)− (b+ 1)− 1) = MBBoardN(2L+ 2, 2L− b) is drawn. 
Lemma 13. Assume that MBBoardN(L, p) is drawn. Then, MBBoardN(2L+ 1, L+ p) is drawn too.
Proof. SinceMBBoardN(L, p) is drawn,MBBoardNX(L, L−p−1) is drawn from Lemma 7. From Lemma 11,MBBoardN(2L+1,
2L− (L− p− 1)− 1) = MBBoardN(2L+ 1, L+ p) is drawn. Thus, this lemma holds. 
Lemma 14. Assume that MBBoardN(L, p) is drawn. Then, MBBoardN(2L+ 2, L+ p+ 1) is drawn too.
Proof. SinceMBBoardN(L, p) is drawn,MBBoardNX(L, L−p−1) is drawn from Lemma 7. From Lemma 12,MBBoardN(2L+2,
2L− (L− p− 1)) = MBBoardN(2L+ 2, L+ p+ 1)) is drawn. Thus, this lemma holds. 
4.2.4. The proof for Property 3
This subsection concludes in Lemma 15 that Property 3 is satisfied.
Lemma 15. Property 3 is satisfied.
Proof. Initially, the three games, MBBoardN(4, 1), MBBoardNX(2, 1) and MBBoardNX(3, 2), are shown to be drawn in
Lemma 8, Lemma 9, and Lemma 10, respectively. From Lemma 11 or Lemma 12, we obtain the drawn MBBoardN games,
for all 2 ≤ p ≤ 4, as shown in Table 1. Then, from Lemmas 13 and 14, we obtain the drawn MBBoardN games, for all
5 ≤ p ≤ 13, as shown in Table 2. By induction, all the remaining drawnMBBoardN games in Property 3 can be derived from
Lemmas 13 and 14. 
表 Y04 
出席國際學術會議心得報告 
                                                            
計畫編號 
NSC97-2221-E-009-126-MY3 
計畫名稱 六子棋詰棋及開局定石之自動產生系統之研究與設計 
出國人員姓名 
服務機關及職稱 
吳毅成；國立交通大學資訊工程學系教授。 
會議時間地點 
地點：Shiinoki Cultural Complex, Kanazawa City, Japan （日本金澤市） 
時間: 2010-09-24 to 2010-09-28 
會議名稱 The International Conference on Computers and Games 2010 
 
一、參加會議經過，依事件順序分述如下： 
 此次研討會由 Prof. Herik 主持的主辦機構 ICGA 協同日本北陸先端科學
技術大學 (Japan Advanced Institute of Science and Technology, JAIST) 單位
主辦，一共維持三天的會議 (Sept. 24~Sept. 26)。在同一時間，第十五屆國
際電腦奧林比亞比賽 (15th Computer Olympiad) 也一起進行。 
 本人於九月廿三日從台北搭機，並於九月廿三日當地時間晚上抵達日本金
澤市。 
 隔日（廿四日）早上抵達會場，今天一整天進行研討會。 
 在 Opening 中，邀請 IBM Thomas J. Watson Research Center 的 
Richard Segal 演講「On the Scalability of Parallel UCT」，針對目前最熱
門的 Monte-Carlo UCT 如何做平行化做相關發表。 
 廿四日，同一天 Session 3，我們發表了一篇「Job-Level Proof-Number Search 
for Connect6」論文，這是一篇大量運算應用於六子棋開局庫的重要發展，
現場引起不少的討論及興趣，是一次很成功的論文發表。 
 廿五、廿六日持續進行論文發表的議程，主要包括幾個方面的發表。 
 有關於 Monte-Carlo 改善演算法、建立開局庫或者各種遊戲 (比如 
Amazons, Havannah) 的應用。 
 日本提出一種 Voting 演算法，用來改善電腦人工智慧能力。 
 一些小遊戲的介紹，比如 Yahtzee, Pickmino 等。 
 其他一些比較獨立的議題發表。 
 此次國際電腦奧林比亞比賽 (15th Computer Olympiad) ，本人帶領的團隊 
參加三種比賽，成績如下： 
 Nurikabe 冠軍：與第二名的 Cpuzzle 相比較，我們 100 題在 38 秒
內全解出，他們在 1800 秒內只有解出 8 題。 
 象棋︰ 銅牌（輸給象棋世家＆天馬行空）。輸天馬行空的一場，是由
於和局的步數算法錯誤，否則和局的話，同分。 
 九路圍棋︰十四隊第八名(8/14)。台灣隊伍只輸給第三名的 Erica。 
 
 
 
 
 
國科會補助計畫衍生研發成果推廣資料表
日期:2011/10/26
國科會補助計畫
計畫名稱: 六子棋詰棋及開局定石之自動產生系統之研究與設計
計畫主持人: 吳毅成
計畫編號: 97-2221-E-009-126-MY3 學門領域: 人工智慧
無研發成果推廣資料
報告 
研討會論文 1 0 100%
1.I-Chen Wu, H.-H. Lin, P.-H. Lin, 
D.-J. Sun, Y.-C. Chan and B.-T. 
Chen, ’’’’Job-Level Proof-Number 
Search for Connect6’’’’, The 
International Conference on Computers 
and Games (CG 2010), Kanazawa, Japan, 
September 2010. 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 9 0 100% 陳柏廷、鄒忻芸、王智功、陳俊嶧、楊景元、蔡心迪、林正宏、康浩華、陳干越 
博士生 3 0 100% 林秉宏、孫德中、林宏軒 
博士後研究員 0 0 100%  
參與計畫人
力 
（外國籍） 
專任助理 0 0 100%
人
次
 
其他成果 
(無法以量化表
達之成果如辦
理學術活動、獲
得獎項、重要國
際合作、研究成
果國際影響力
及其他協助產
業技術發展之
具體效益事項
等，請以文字敘
述填列。) 
此計畫有相當豐碩的成果如下： 
1.獲得第十三屆國際奧林匹亞賽局競賽冠軍，為我國獲得唯一的一面金牌及獎牌，同
時也擊敗台灣許多六子棋高段棋士。 
2.我們發展出許多令目前高段棋士十分震驚的六子棋開局定石（如圖十一），我們預
期加上完全平行化的自動開局產生系統，將會有更多前所未見的開局定石。 
3.許多成果發表於重要期刊與會議如: IEEE Transactions on Computational 
Intelligence and AI Games期刊, Theoretical Computer Science期刊, ICGA Journal
期刊, 以及本領域最重要的國際會議 International Conference on Computers and 
Games 2010.  
因此，我們很確信地自評︰此計畫的執行成果相當優異。 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人
數 0 
 
 
