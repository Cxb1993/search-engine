6.2.3.2 插入Wait State的 AHB 傳輸時序 ........................................................................................ 42 
6.3 Opencore 10/100 Ethernet MAC匯流排介面訊號修改........................................................................ 43 
6.3.1 WISHBONE的 Handshake協定 .................................................................................................... 43 
6.3.2 Remove unused WISHBONE of Ethernet MAC ............................................................................. 45 
6.4 AHB Master BIU Design ........................................................................................................................ 47 
6.4.1 Step1：定義Master BIU的訊號 .................................................................................................... 47 
6.4.2 Step2：畫出Master BIU的電路行為波形圖 ................................................................................ 47 
6.4.3 Step3：設計Master BIU的狀態機 ................................................................................................ 48 
6.5 AHB Slave BIU Design........................................................................................................................... 49 
6.5.1 Step1：定義 Slave BIU的訊號 ...................................................................................................... 49 
6.5.2 Step2：畫出 Slave BIU的電路行為波形圖 .................................................................................. 50 
6.5.3 Step3：設計 Slave BIU的狀態機 .................................................................................................. 50 
6.6 實際將電路整合到系統中 .................................................................................................................... 51 
7. 10/100 ETHERNET MAC軟體驅動程式開發 ............................................................................................... 55 
7.1 Boot Loader............................................................................................................................................. 55 
7.1.1 Boot Loader的工作......................................................................................................................... 55 
7.1.2 使用 Altera Library為系統加入 Boot Loader............................................................................... 55 
7.2 PHY Device Driver ................................................................................................................................. 55 
7.3 MAC Device Driver ................................................................................................................................ 56 
7.3.1 訊框描述者(Buffer Descriptor) ...................................................................................................... 56 
7.3.2 Ethernet MAC控制暫存器 ............................................................................................................. 59 
8.SOPC驗證及實驗結果 ................................................................................................................................. 62 
8.1 Opencore 10/100 Ethernet MAC的 RTL行為驗證 .............................................................................. 63 
8.1.1 Rx RTL行為驗證 ............................................................................................................................ 63 
8.1.2 Tx RTL行為驗證 ............................................................................................................................ 63 
8.2 MAC SIP與 AHB BIU結合之 RTL行為驗證 .................................................................................... 64 
8.2.1 Slave的 RTL行為驗證................................................................................................................... 64 
8.2.2 Master的 RTL行為驗證 ................................................................................................................ 64 
8.3 ARM-based Excalibur SOPC發展板上驗證 ......................................................................................... 64 
8.3.1 Verify PHY....................................................................................................................................... 65 
8.3.2 Verify MAC + PHY.......................................................................................................................... 66 
8.3.3 Verify S/W + MAC + PHY .............................................................................................................. 66 
8.3.4 電路面積與電路速度 ..................................................................................................................... 69 
9. PC 端的測試/存取控制的發展環境 ............................................................................................................. 70 
9.1 設計目標 ................................................................................................................................................ 70 
9.2 關於模組的 Protocol Verification 部份 ................................................................................................. 70 
9.2.1 Bus Model (Bus-functional Model) & Protocol checker ................................................................. 71 
9.3 與硬體平台連接，作存取控制 ............................................................................................................ 74 
10. 利用本平台整合技術，完成一顆 SOC TEST CHIP .................................................................................. 77 
10.1 己經實際下晶片的簡易版  SoC Test Chip ....................................................................................... 77 
三.結果與討論 ...................................................................................................................................................... 83 
四.計畫成果自評 .................................................................................................................................................. 87 
參考文獻 ............................................................................................................................................................... 88 
附錄 A  使用MEGAWIZARD設定 EPXA1 STRIPE ..................................................................................... 89 
 
 
 
 
FPGA 介面卡示意圖 
 
 左圖中是一般常見的發展板，將CPU Chip 接在板子上。右圖是使用FPGA 介面卡的示意圖，右
圖中CPU Chip 先透過FPGA 中的Wrapper 與介面卡連接，FPGA 中內建了晶片匯流排，所以還可以加
入其他的Master/Slave IP。介面卡的底部，則可以透過插槽再連接發展板，使介面卡與發展板整合在一
起。 
 
(4) 缺乏針對平台作測試及存取控制的發展環境 
 SoC 系統建構完成後，需要有一套軟體幫助我們對系統作測試以及存取控制。所以我們也為我
們的平台整合技術，規劃一套在PC 端的測試/控制軟體，當使用者完成系統後，該軟體會以圖形化的
方式將系統呈現。使用者可以用點選的方式，任意選擇要觀察的模組或某條訊號線，軟體就會執行
Protocolverification 的動作。 
 
 
 另外，還可以將軟體透過與上述的硬體平台作連接，作存取的控制。舉例來 說，使用者在軟體
中點選圖形化系統的模組或某個Scan Chain Register，並輸入想寫入的值，軟體就會自動產生對應的
JTAG 指令，將Test/Debug Pattern 送到FPGA 中。同樣的，也能將想觀察的值從硬體平台讀取回PC
端。 
 本計畫的目的是，設計並實做出一個SoC 平台開發的整合技術，使學術界擁有研究SoC 所需要
的開發暨驗證用平台，而針對目前平台設計所需解決的問題，我們將上述的解決方法簡略總結如下： 
(1)平台基礎建設(Platform Infrastructure)取得不易。 
(2)平台基礎架構的參數變化大。我們以AMBA 匯流排產生器(AMBA Generator)來提供解決方法。 
(3)缺少經濟的FPGA 平台，可讓使用者整合IP 到系統中作開發與驗證。我們使用了FPGA 介面卡，內
建晶片匯流排，讓使用者可以在匯流排上加入自己的IP，此介面卡也可接上外部晶片，以及與低成本的
發展板連接使用。 
(4)缺乏針對平台作測試及存取控制的發展環境規劃開發一套在PC 端的測試/控制軟體，提供圖形化並
自動化的方式，來幫助使用者對平台作測試以及對電路作存取的控制動作。我們提供一套完整、具驗
證環境、低成本硬體、並可以與現有發展板結合的整合技術。 
 
 
下面我們略為介紹上面三種不同 AHB 架構，並討論其參數化還項 
 
　● AHB 第一種架構---AHB 
 
AMBA 系統是由 Master、Slave 及 Infrastructure 所組成。匯流排上的傳輸都是由 Master 所發動， 
而 Slave  根據 master  的需求做出相對應的回應。 Infrastructure  則包含了 :arbiter、master  to  
slave multiplexer、slave to master multiplexer、decoder、default slave。 
下圖為一個擁有三個 master、四個 slave、一個 arbiter 和一個 decoder  的 AMBA AHB  匯流排。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
圖-1 AMBA AHB  主要元件 
 
各個元件的功能描述於下表： 
 
名稱 功能描述 
Master 能主動要求匯流排傳輸者。 
Slave 對 master 要求做出相對應的回應者。 
Arbiter 確保在特定時間點上只能有一個 master 有匯流排的使用權。 
Decoder 將 master 的位址訊號做解碼，並產生匯流排上相對應的 Slave 的 
選擇訊號。 
 
Master to slave 
multiplexer 
AMBA 系統內所有的 master 都是連接到 Master to slave 
multiplexer，然後使用仲裁器所輸出 HMASTER 訊號來選取目前
被允許存取匯流排的 master。 
 
Slave to master 
multiplexer 
輸入連接各個 slave 的資料(read data)和回應(response)訊號，然後 
根據 Decoder 所產生的 HSELx 訊號來選取其中一組訊號，輸出至
各個 master。 
 
Default Slave 
不存在或未定義的記憶體位址都被規劃成 Default Slave。Default 
Slave 會對 master 做出 Error 的 Response，並通知 master 處理。 
 
 
 
 
 
 
針對以上的元件，我們實現的參數化如下： 
●  AHB 第二種架構---AHB-Lite 
 
某些 AHB  系統中可能只有只一個 master，此時系統中仍使用 arbiter  就顯得不必要了，因此 ARM 
在 AMBA 2.0  之外推出 AHB  的變化型 AHB-Lite。它只採用了原來 AHB 的部份內容，主要是最初 
AHB 規範中的仲裁協議。那些仲裁協議與解碼器、多工器等互連元件一起簡化了系統互連設計。 
 
 
Interconnect M atrix  
Slave 
 
 
Master 
 
Slave 
 
 
 
 
Slave 
 
 
Master 
 
Slave 
 
 
 
在 Multi-layer 的文件中介紹了各種不同的 bus configuration，例如在同一層 layer 中可能有許多低頻 
寬(low-bandwidth)的 master，或是將 AHB  分成不同的子系統(sub-system)，每一個子系統彼此不能互 
相存取，只有一個 slave 可以讓 master 透過 Interconnect matrix 去做彼此之間的共享等。當系統中的 
master 和 slave 的個數增加時，互連的 matrix 的複雜度就會更重要。 
● 將 slave 放置到特定的 layer 層 
● 在互連的 matrix 上的多個 slave 視為單一的 slave，多個 master 只在單一 layer 上。 
1.2.3 AMBA 元件可以設定的參數  
下面簡單以表格整理各元件可作參數化的部份： 
 
名稱 提供的參數選擇 
(1)  能讓使用者設定系統中會有幾個 master。 Arbiter 
(2)  提供優先權及 Round-Robin 兩種仲裁方式。 
(1)  能設定系統中 Slave 的個數，而產生相對應的 HSEL 訊號。 Decoder 
(2)  可根據使用者的需求對系統加入 Remap 的機制，因此 Slave 
可以具有兩個位址:Remap 前的位址和 Remap 後的位址。 
Master to slave 
multiplexer 
設定此多工器為 m 選一多工器(m 為正整數)，由此決定 Master 的
通道數有幾個。 
Slave to master 
multiplexer 
設定此多工器為 n 選一多工器(n 為正整數)，由此決定 Slave 的通
道數有幾個。 
Default Slave 能讓使用者設定哪些記憶體區段屬於不存在的 I/O 位址。 
 
1.3 產生器的設計規劃 
 
我們欲實作的匯流排基礎架構之自動化產生器，預計提供兩種操作模式。一是以開啟描述(script) 
檔為基礎，另一個是以 Wizard 為基礎的方式來產生 RTL code  和 Test bench。提供兩種操作模式是為 
了滿足使用者的操作習慣，最終目的都是一致的。 
1.3.1 以 Script 檔為基礎的產生器  
首先在這一個小節內將介紹以設定描述(script)檔為基礎的操作方法，以及說明設定語法的使用方 
式。在使用者執行 On-Chip Bus Infrastructure Generator 後，隨即出現一個 GUI 面板。開啟 Script 檔如 
  
以 Form 為基礎的
自動產生器 
當使用者執行 On-Chip Bus Infrastructure Generator 後，出現如的 GUI。首先使用者能根
據應用需 求選擇 AHB 2.0、AHB-Lite 或是 Multi-layer AHB 為 On-Chip Bus 的基礎架構後，
再根據所選的架構可 以進一步的設定。例如選定 AHB 2.0 後，可以設定 bus 的寬度、arbiter 的
仲裁方式、系統上有幾個 master和 slave、slave 在系統中的位址、是否須要有 Remap 的 
Decoder。選擇 Multi-layer AHB 後，除了基本 設定外還可以對前面所介紹的架構做設定，如 
local slave、Multiple slaves on one slave port、Separate AHB subsystems 等等。假如選擇了 AHB-
Lite 的型式後，因為 AHB-Lite 只有一個 Master，所以沒有仲裁器。 因此設定仲裁機制的選
項會變為灰階，讓使用者無法選擇。當使用者選擇 AHB-Lite 後，首先設定資 料匯流排的
寬度如所示，接著設定系統中 slave 的個數，如。針對每一個 slave 設定其在系統中的位址
及 Remap 後的位址，設定的方法是在 GUI 的文字編輯區依序輸入 Slave 的記憶體位址。選擇 
AHB 2.0 後，則是需額外設定系統中 master 的個數及仲裁器的仲裁機制。而 Multi-layer AHB 
除了前述設定外， 尚須設定系統中會有幾層的 layer，每層 layer 中各有幾個 master 和 
slave，然後再對細節詳加設定，等 設定完成後產生匯流排基礎架構的 RTL 模組。 
不管是使用以 Form 為基礎的自動產生器或是以 Script 檔為基礎的自動產生器，都只是要
讀取設定 參數，然後程式自動把參數填至 verilog 的 RTL 模組檔以及 Testbench 測試檔中。
我們使用 verilog 語 法中的`define 一個變數，自動產生器則負責填入後面的數值，這個數
值即是使用者根據需求而設定  的。其中會用到這個  define 的模組有 :MuxM2S.v、
MuxS2M.v、Decoder.v，如以下範例則是將 Data bus 
和 Address bus 都是設定為 32 位元寬度。 
 
`define DataWidth 32 // data width 
`define AddrWidth 32 // address width
 
 然後 Arbiter 的產生方式，我們事前實作兩個 RTL 模組。一個是 Priority 的優先權的機
制、另一個為 Round Robin 的機制。自動產生器則根據使用者的選擇來產生一個 Arbiter 模組
出來。我們在參數化Slave 的記憶體位址的方式，我們使用 verilog 語言的 case 語法，自動產
生器根據使用者的設定來填入RTL 模組中。如下列範例，使用者有兩個 Slave 裝置，一個 
Slave1 設定位址為 0x03F30000、另一個為0x03FF0000，假如沒有用到的記憶體空間定義給 
Default Slave。這些 Verilog 語言的描述就是用在Decoder 模組，讓 Decoder 來定出 Slave 的
記憶體位址。 
 
 
 
 
 
 
 
基礎架構模組符合 AMBA 規格有助於 使用者快速進行系統整合設計與驗證。 
 
我們使用 ACT 來證明匯流排基礎架構模組其 protocol 介面驗證已經達到預先定義的品
質與相容性 水準，讓使用自動產生器的使用者確信其模組功能正常，並且在做系統單晶
片的整合時會更有信心。 Synopsys 的 ACT 特色如下: 
● Certifies compliance with the AMBA 2.0 specification 
● Generates compliance certificate as defined by ARM and Synopsys 
● Multiple components may be certified during a single session 
● Programmable coverage to reflect user configuration 
● Re-certifies in customer environment without requiring an ACT license 
● Coverage API enables self-checking from the testbench 
● Checks for protocol violations 
 
 所以我們使用 ACT 所提供的 Checks for protocol violations 來清楚定義 AMBA 2.0 協
定，同時偵測  違反協定的部分。他可以驗證的功能有  Arbitration Requests、Arbitration 
Ownerships、HTRANS States and Transitions、Burst Transfer Types、Transfer Sizes 和 Response 
Types Received 等 AHB 訊號是否有違反協 定。因此我們使用 DesignWare  verification  
model:  AHB  Monitor，其功能和 SDV 的 AHB  Slave-side Monitor  類似且更具說服
力。連接方式如下圖所示，也是在我們整合好的系統中額外加入 AHB Monitor。
AHB  Monitor 就會確認上述功能，在 AMBA 上訊號皆符合 AMBA 所規定。我們把 
AMBA 上的可能傳輸情況產生出來，當系統在進行模擬時，AHB Monitor 會偵測匯流排上
的訊號並加以判斷， 而判斷的條件及根據便是 AMBA  上的資料傳輸種種可能行為。此
監視器會負責觀察匯流排的執行狀 況，並且同時在模擬的執行期間它會回報觀察到那些 
AMBA 規定必要的情形。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Synopsys 
AHB 
Monitor 
 
 
我們使用兩種的匯流排監視器為 Synopsys 的 AHB bus monitor 及 SDV 的 AHB bus 
Monitor 作為與 我們的比較，主要目的是要以具有高可靠度的匯流排監視器來監視匯流排
的訊號傳輸是否符合 AMBA 規格。若和這兩者完全沒有任何違反，則我們的驗證正確性
就有很高可的靠度及信心程度。 
 
 
◆ Bridge 
圖中(C)的部份，是一個 Bridge，它主要的功能是作為 AHB 和 APB 連接的橋樑。可以由第一小 節的
匯流排產生器來產生，如果 AHB 上的 Master 要存取 APB 的 Slave，就會通過 Bridge 送到 APB 
上 
 
2.3 連結外部的 Chip 結合運作 
 
■ CPU Chip 
 
如果使用者沒有自己的 CPU Core 的 RTL Design 可以加入到介面卡上的大容量 FPGA 之中，那 
麼就需要與外部的 CPU Chip 連接，常見的 CPU Chip 有 ARM 系列，及 PIC 等等，都是普遍的 
嵌入式處理器。將 CPU Chip 置於介面卡上之後，需要將其接腳接到 FPGA 內，並在 FPGA 內中 
設計一個 Wrapper，使得 Chip 接腳訊號能轉成晶片匯流排的標準訊號。 
 
■ External FPGA1 
 
若是使用者想將自己的 IP 獨立編譯，不想與大容量 FPGA 中的電路一起編譯，曠日費時。此 
介面卡也可以再與其他的 FPGA 連接，將使用者的 IP 另外置於外接的 FPGA 中，這樣可以節省 
編譯時間，這樣的設計也提昇擴充性。 
 
■ ASIC 
 
除了 CPU Chip 與 FPGA，其他的 ASIC 也可以與本介面卡連接在一起，比如 DSP ASIC ， 但
需 注意的是將其接腳接到 FPGA 內後，仍需在 FPGA 內中設計一個 Wrapper，使得 Chip 接腳訊
號 能轉成晶片匯流排的標準訊號。 
 
■ External FPGA2 
 
除了 AHB Bus 上可以接外部的 FPGA 之外，APB Bus 也可以外接 FPGA，這樣可以增加慢速週邊 
的擴充性。 
 
2.4 FPGA 介面卡與發展板的連接 
 
 
本介面卡除了獨立運作外，一個具附加價值的設計，是可以與現成的發展板結合運作。下面 
我們舉兩個例子，說明如何將介面卡與發展板連接。 
 
2.4.1 與低價發展板結合的例子----新華電腦公司的 Creator 發展板 
0x03F2FFFF 
 
0x03F00000 
 
External I/O 
 
 
 
 
0x011FFFFF 
 
 
0x01000000 
 
Flash ROM 
 
 
2M Bytes 
 
 
0x00FFFFFF 
 
 
 
 
0x00000000 
 
 
圖 -4 Remap 後的記憶體分佈 
 
2.4.2 與高價發展板結合的例子----ARM 公司的 Integrator/AP 發展板SDRAM 16M Byte
ARM922T InterruptController
Watchdog
Timer
Dual-Port
SRAM
Single-Port
SRAM PLL
Reset
Module Timer
Configuration
Logic
AHB1
AHB2
PLD
Stripe
PLD
 Slave(s)
User Modules Requiring Direct 
Access to Large Dual-port or 
Single-port RAM(s)
ARM-based Excalibur SOPC Architecture
PLD-to-Stripe
Bridge
EBI UARTSDRAMController
AHB 1-2
Bridge
Stripe-to-PLD
Bridge
PLD
 Master(s)
 
圖 -1  ARM-based ExcaliburTM SOPC Architecture 
在圖圖 -1中，可以看見 ARM-based ExcaliburTM系統分成上方 Stripe與下方 PLD兩個部份。Stripe
中有許多元件，PLD則保留給使用者使用。底下分別對它們作介紹： 
 3.1.1 Stripe 
 Stripe就是 SOPC晶片中的 ASIC電路，在 ARM-based ExcaliburTM SOPC晶片中將 ASIC的部份
稱為 Stripe(條紋)。在上圖中可以看到 Stripe 包含了許多由 Altera 所提供的元件可以使用者直接使用，
茲將圖中各個元件介紹於下： 
 ARM922T Microcontroller：ARM922T 微控器，是整個系統的運算核心。ARM922T 微控制器
是以 ARM9 微處理器為核心並且整合了 Cache 和 MMU 而成的微控制器，最高工作時脈可以到達
200MHz[16]。本研究中將它的工作時脈設定在 120MHz。(設定方法詳見附錄 B) 
 Interrupt Controller：中斷控制器，用來管理週邊裝置所發出的中斷要求。週邊裝置包括 Stripe
中的 UART、Timer和 EBI所連接的外部元件，以及 PLD中的電路等。(Interrupt Controller提供了六個
中斷源給予 PLD中的電路使用。) 
 Watchdog Timer：看門狗計時器，用來防止系統不正常工作。看門狗計時器的工作原理是：當
系統處於正常工作時，每隔一段時間就會去重置看門狗計時器。當系統發生嚴重的硬體或軟體錯誤的
時候，看門狗計時器超過時限仍未被重置，就會將整個晶片重置(Reset)。 
 AHB1 & AHB2：ARM-based ExcaliburTM晶片中，使用 AMBA AHB匯流排作為晶片匯流排。並
且為了得到更高的效能，實作了兩條匯流排 AHB1 和 AHB2。AHB1 匯流排上只有 ARM922T 一個
Mater元件，Stripe中的其它 Master元件則連接到 AHB2匯流排上。這樣可以使 ARM922T不需與其它
元件爭奪匯流排而得到更大的頻寬。 
 AHB1的匯流排工作時脈通常會設定的比 AHB2匯流排的工作時脈更高。在本研究中，AHB1匯
流排的工作時脈設定為 120MHz，而 AHB2 匯流排的工作時脈則設為 60MHz。要將匯流排的時脈達到
120MHz 與 60MHz，乃是藉 PLL 對石英振盪器所輸入的時脈訊號作加速後，再送給 AHB1 與 AHB2
的。(AHB1與 AHB的時脈頻率設定方法詳見附錄 B) 
 
 3.1.2 PLD 
在圖 -1中的下方，可以見到 ARM-based ExcaliburTM 的 PLD 部分，這是提供給使用者規劃電路的
空間。使用者將自己電路放到 PLD 中，並且將電路與 PLD-to-Stripe Bridge(或是 Stripe-to-PLD Bridge)
連接後，就可以使電路在 SOPC 的匯流排上工作。因此，對要在 SOPC 整合矽智產的使用者而言，了
解電路如何規劃到 PLD 中，以及了解 Bridge 與 PLD 電路之間的訊號並作適當的連接，乃是最重要的
事。 
本研究計劃使用 ExcaliburTM 型號 EPXA1 晶片，其內部所提供的 PLD 空間大小為 100K Gate 
(4,160 Logic Elements 和 53,428 Memory Bits)。ExcaliburTM SOPC 晶片中的 PLD 空間也可以獨立使
用，此時與一般的 PLD 裝置完全相同。PLD 空間獨立使用時，Stripe 的電路沒有動作。在 SOPC 硬體
開發的初期，這是很有用的功能。因為使用者可以先不考慮軟體與 Stripe 中的電路，單獨對 PLD 中的
硬體作驗證，以釐清系統的問題發生在硬體(PLD電路)或軟體(ARM程式)。 
上述 ARM-based Excalibur晶片中的元件，簡短整理成下表： 
Stripe 
種類 元件 
微控器相關元件 ARM922T、中斷控制器與看門狗計時器 
On-Chip SRAM Dual Port、Single Port RAM 
外部記憶體控制器 SDRAM Controller(連接 Off-Chip SDRAM記憶體) EBI(連接 Off-Chip Flash ROM與其他裝置) 
時脈相關元件 PLL 
通訊相關元件 UART 
使 PLD 電路與 Stripe
彼此溝通的元件 
橋 接 器 (PLD-to-Stripe Bridge & Stripe-to-PLD 
Bridge)。 
PLD 
PLD 100K Gate的空間 (118 Programmable I/O Pins) 
  ARM-based ExcaliburTM 元件 
3.2 Create ARM922T-EPXA1 Development Kit 
介紹完 SOPC 晶片內部硬體架構，接下來也對其發展板作介紹。因為發展板上的一些元件，也是
構成系統的重要元件。包括 SOPC的外部記憶體(Flash ROM與 SDRAM)以及通訊元件(Ethernet PHY)都
位在發展板上。所以本節簡短地對發展板作介紹。 
128*128
LCD
4*4
Key Pads
System
Reset
7 Segment
LED
CMOS 
Camera 
Connector
Microphone
Connector
Speaker
Connector
USB
Port
Power
Switch
+5V DC
Power 
LED &
DIP Switch
Ethernet
Port
JTAG
Connector
UART
Ports
FPGA
Connector
CF Card
Slot
Creator Mother Board
FPGA
Connector
SOPC
Create ARM922T-EPXA1
Daughter Board
 
Figure 3  Creator Mother Board 
4. SOPC平台使用方法及工具 
本節對 SOPC 平台的使用方法作介紹。包括：如何設定 Stripe 的參數、如何將使用者的硬體加入
到 PLD中、以及如何將軟體與硬體結合，產生燒錄到外部 Flash ROM的系統影像檔(Flash Image)等工
作。SOPC 通常採用「Boot from flash」的模式，也就是在開機時從外部 Flash Memory 讀取指令及資
料，然後執行初始化、PLD 電路規劃、以及執行程式等工作。因此使用者需要了解如何將自己設計的
硬體與軟體整合並生成 Flash Image。 
本節以流程圖說明將使用者硬體與軟體轉換成為 Flash Image 的過程，並對使用到的工具作介紹。
按照本節所介紹的流程進行，使用者就可以將自行設計的軟硬體整合到 SOPC平台上。 
 
4.1  SOPC的開發流程：以流程圖介紹 ARM-based ExcaliburTM SOPC的開發過程。將開發的過程
分成硬體開發、軟體開發、以及軟硬體結合三個部份，作概括的介紹。 
4.2  硬體開發工具：詳述 4.1 中與硬體開發相關的工作及工具。包括系統組態參數的設定方法以
及加入使用者的電路和電路合成等工作和工具的介紹。 
4.3  軟體開發工具：說明軟體開發所使用的工具--編譯器的使用。 
4.4  軟硬體結合工具：詳述將軟硬體結合的工作及工具。軟硬體結合階段包括了兩項工作：將軟
硬體整合成物件檔，以及將物件檔轉換成 Flash影像檔。 
4.5  燒錄 Flash 影像檔的工具：介紹如何將 4.4 所產生的的 Flash 影像檔(整合了軟硬體與系統組
態參數設定值的 Image)燒錄到 SOPC發展板上的 Flash記憶體中的方法。 
4.1 SOPC的開發流程 
MegaWizard也會將 Stripe的參數記錄下來，存成.sbd檔(System Build Descriptor)。.sbd檔記錄了使用者
對系統的參數設定，在軟硬體整合階段會被使用。關於硬體開發階段的工具將於 4.2小節中作進一步的
介紹。 
 S/W Development：軟體開發階段。這個階段主要的工作是使用 ARM Compiler 編譯程式。常
見的 ADS、EW或 GNU Compiler都可以使用。軟體工程師在撰寫系統底層的控制程式時，所需要知道
的硬體資訊—硬體的 Memory Map基底位址(Base Address)配置資訊，由 MegaWizard所產生的 Stripe.h
檔案所提供。另外在 ExcaliburTM SOPC 進行程式開發時，使用者要留意的是，必須要將程式編譯成
Intel Hex (.hex)格式。因為之後還需要在「軟硬體結合階段」時使用 Linker將軟體與硬體資訊連結，產
生 Flash Image(.bin or .hexout)。關於軟體開發階段的工具將於 3-3小節中作進一步的介紹。 
 Integration：軟硬體結合階段。這個階段分成兩個步驟：先使用 Altera Utilities將軟硬體及系統
參數結合成物件檔(.o)，作為系統的 Boot Data。然後使用 Linker將 Boot Data與 Boot Library(.A)連結
起來，成為 Flash Image。Boot Library是 Altera為 ARM-based ExcaliburTM所提供的 Library檔案(副檔
名.A)。它可以自動為使用者加入 Boot Loader 程式，這樣使用者就不需要撰寫 Boot Loader。Linker 連
結後所產生的 Flash Image 檔案(.bin/.hexout)，是可以燒錄到 Flash ROM 的系統影像檔。軟硬體結合的
工作將於 5.4小節中進一步的介紹。 
下表是 SOPC開發流程之工具與檔案的說明與整理： 
性質 工具名稱 公司 功用 
MegaWizard Altera 設定 Stripe參數以及產生 Stripe Symbol 
硬體開發 
QuartusⅡ Altera 提供電路的合成、佈局功能。 
軟體開發 ADS 1.2 Compiler ARM 將應用程式編譯成 Intel Hex檔。 
makeprogfile Altera 將軟硬體資訊整合成 Boot Data。 
軟硬體結合 
ADS 1.2 Linker ARM 將 Boot Data 檔與 Boot Library 連結產生Flash 影像檔。 
  SOPC開發工具整理 
 
工作階段 檔案名稱 功用 
.v/.vhd Verilog/VHDL File. 使用者以硬體描述語言設計的電路。 
.bsf Block Symbol File. MegaWizard產生的 Stripe電路符號。 
.sbd 
System Build Descriptor. 
MegaWizard產生的 Stripe參數設定值記錄。 
硬體開發 
.sbi Slave Binary Image. QuartusⅡ合成後的電路組態檔。 
Stripe.h Header File. MegaWizard產生給 S/W用的系統資訊頭檔。 
軟體開發 
.hex Intel Hex. ARM Compiler編譯程式後的輸出檔。 
當參數設定完成之後，Mega Wizard精靈會產生 Stripe的電路符號(.bsf, Block Symbol File)，如下
圖圖 -6所示。使用者就可以在 QuartusⅡ電路圖中引入 Stripe 元件並進行電路編輯。(關於 MegaWizard
的操作詳見附錄 B) 
 
圖 -6  Block Symbol of Stripe 
4.2.2 使用 QuartusⅡ編輯及合成電路 
完成 Stripe 的設定並產生其電路符號之後，使用者接著需要為「使用者電路」創造其電路符號，
為的是在 QuartusⅡ中的電路圖編輯器中將使用者的電路與 4.2.1小節所產生的 Stripe進行接線。下面介
紹如何為使用者自行設計的電路創造電路符號的方法： 
在 QuartusⅡ的 Project 中，使用者先開啟自行設計的電路之最上層(Top Module)電路設計檔(.v
或.vhd檔)。接著從功能表「File」->「Create/Update」，執行「Create Symbol Files for Current File」功
能。完成後就會產生使用者的電路的電路符號元件，讓使用者可以在電路圖編輯器中加入此元件。使
用者只要在 QuartusⅡ的電路圖空白處連點滑鼠兩下，就可以加入使用者電路的符號元件，如下圖圖 -8
所示。 
 
圖 -7  使用 QuartusⅡ為 HDL創造 Block Symbol 
 
圖 -10  QuartusⅡ電路編譯功能的執行 
電路合成後會在工作目錄下產生硬體的 Configuration Data--Slave Binary Image(.sbi)檔案。至此，關
於硬體的工作就告一段落。接下來介紹軟體的開發的工具。 
4.3 軟體開發工具(S/W Development Related Tools) 
4.3.1使用 ARM Compiler編譯程式 
ARM-based ExcaliburTM SOPC軟體開發的工作，需要 ARM Compiler來編譯使用者所撰寫的程式。
常見的 ARM Compiler有 ADS，GNU，與 EW等，在本研究計畫中，使用 ARM公司的 ADS v1.2 [18]
編譯器進行程式的編譯。 
 
圖 -11  ADS1.2 Code Warrior 
在軟體開發階段，使用者要特別注意的是編譯程式時要將輸出格式選擇為 Intel Hex 格式，而非預
設的 Plain Binary。這是因為在軟體開發階段編譯程式之後，還要在軟硬體結合階段將程式編譯後的檔
案與硬體資訊結合起來。而 Altera所提供的軟硬體結合的工具要求軟體必須編譯成 Intel Hex格式。 
 圖 -13  使用者自製批次檔—呼叫 makeprogfile 
如上圖圖 -13，點選批次檔 makeboot.bat執行之後，就會在當前目錄下產生出 Boot Data檔。 
 
圖 -14  makeprogfile產生的 Boot Data 
4.4.2使用 ARM Linker產生 Flash Image 
接下來，介紹如何產生系統的 Flash Image。因為系統啟動的時候，需要有 Boot Loader執行系統初
始化的動作。為了節省使用者為 SOPC 平台撰寫 Boot Loader 的時間，Altera 提供了一個
Library(libboot_xa_ads.a)，可以自動為使用者加入 Boot Loader 程式區段。 libboot_xa_ads.a 位於
QuartusⅡ的安裝目錄\libraryies\software\boot 使用的方法就是將 Boot Data(.o)與 libboot_xa_ads.a 一起在
Linker中進行連結。 
 
圖 -15  使用 Linker產生 Flash Image 
5.2 Opencore 10/100 Ethernet MAC介面訊號 
圖圖  -17是 Opencore 10/100 Ethernet MAC 矽智產的介面訊號圖。左邊是匯流排相關訊號
(WISHBONE Bus Interface)，右邊是與 PHY連接的訊號(MII, Media Independent Interface)。 
mtx_clk_i
mrx_clk_i
mrx_pad_i[3:0]
mrxdv_pad_i
mrxerr_pad_i
mcoll_pad_i
mcrs_pad_i
md_pad_i
mtxd_pad_o[3:0]
mtxen_pad_o
mtxerr_pad_o
mdc_pad_o
md_pad_o
int_o
wb_clk_i
wb_rst_i
wb_dat_i[31:0]
wb_adr_i[11:2]
wb_sel_i[3:0]
wb_we_i
wb_cyc_i
wb_stb_i
m_wb_dat_i[31:0]
m_wb_ack_i
m_wb_err_i
wb_dat_o[31:0]
wb_ack_o
wb_err_o
m_wb_adr_o[31:0]
m_wb_sel_o[3:0]
m_wb_we_o
m_wb_dat_o[31:0]
m_wb_cyc_o
m_wb_stb_o
Opencore 
10/100 Ethernet
 MAC
W
IS
H
B
O
N
E 
 B
us
  I
nt
er
fa
ce
M
ed
ia
  I
nd
ep
en
de
nt
  I
nt
er
fa
ce
  (
M
 I 
I)
md_padoe_o
 
圖 -17  Opencore 10/100 Ethernet MAC訊號方塊圖 
Opencore 10/100 Ethernet MAC被整合到系統中時，其一端與匯流排連接，另一端則與晶片外部的
PHY連接，如圖圖 -18所示： 
以正常進行收送網路封包的工作。這是因為 Opencore 10/100 Ethernet MAC 的 MII 訊號是依照
IEEE802.3所定義的訊號實作的。因此與 PHY連接的時候只要直接連接就可以正常工作。 
但是 Opencore 10/100 Ethernet MAC的匯流排相關訊號，在本研究中則需要加以修改。這是因為本
研究計畫中要將 Opencore 10/100 Ethernet MAC 矽智產整合到 ExcaliburTM SOPC 系統中，而
ExcaliburTM SOPC 系統中的晶片匯流排不是 WISHBONE 匯流排，而是 AMBA 公司的 AHB 匯流排架
構。因此在進行整合的工作時就需要對 Opencore 10/100 Ethernet MAC的匯流排訊號作修改。本章中介
紹 Opencore 10/100 Ethernet MAC原本的WISHBONE匯流排訊號，如下表所示。下一章則介紹如何修
改 Opencore 10/100 Ethernet MAC 的匯流排訊號，使 Opencore 10/100 Ethernet MAC 矽智產能從
WISHBONE匯流排移植到 AHB匯流排上工作。 
Opencore 10/100 Ethernet MAC的WISHBONE匯流排訊號如下表： 
WISHBONE匯流排相關訊號 
System Input (Clock & Reset) 
編號 訊號名稱 I/O 意義 
1 wb_clk_i I Clock Input 
2 wb_rst_i I Reset Input 
WISHBONE Slave Signals 
3 wb_adr_i[11:2] I Address Input 
4 wb_dat_i[31:0] I Data Input 
5 wb_dat_o[31:0] O Data Output 
6 wb_sel_i[3:0] I Indicates Data Bus Width. (2’b1111=32bit width) 
7 wb_we_i I Write Input 
8 wb_stb_i I Indicates the beginning of a valid bus cycle. 
9 wb_cyc_i I Indicates that a valid bus cycle is in progress. 
10 wb_ack_o O Indicates that a normal bus cycle is terminated. 
11 wb_err_o O Indicates an abnormal cycle termination. 
WISHBONE Maser Signals 
12 m_wb_adr_o[31:0] O Master Address Output (to WB bus). 
13 m_wb_dat_i[31:0] I Master Data Input 
14 m_wb_dat_o[31:0] O Master Data Output (to WB bus). 
15 m_wb_sel_o[3:0] O Indicates Data Bus Width (to WB bus). 
16 m_wb_we_o O Write Output.(to WB bus) 
17 m_wb_stb_o O Indicates the beginning of a valid bus cycle.(to WB bus). 
18 m_wb_cyc_o O Indicates that a valid bus cycle is in progress.(to WB Bus). 
19 m_wb_ack_i I ACK Input (from WB bus). 
20 m_wb_err_i I Error Input(from WB bus). 
Interrupt Signal 
21 int_o O Interrupt Output 
  Opencore 10/100 Ethernet MAC WISHBONE Signals 
 
 
 
藉由與匯流排連接，矽智產可以向系統中其它元件發出傳輸要求，也可以被其它元件所存取。由
匯流排將所有元件連接在一起，彼此進行傳輸。 
在 ARM-based ExcaliburTM SOPC中，使用者在 PLD中所加入的矽智產要如何整合到系統的匯流排
上呢？在 ARM-based ExcaliburTM SOPC 中，使用了橋接器(Bridge)的機制，讓使用者在 PLD 中所加入
的矽智產可以與 Stripe內的匯流排進行傳輸。示意圖如下： 
PLD
Stripe
Bridge
User Defined 
SIP
On-Chip Bus
Bus Signals
BIU
SOPC
 
圖 -20  ARM-based ExcaliburTM 中矽智產的連接方式示意圖 
上圖圖 -20中，晶片匯流排的訊號透過 Bridge拉到 PLD中，使 PLD中的矽智產電路藉由與 Bridge
的連接而得與 Stripe中的晶片匯流排進行傳輸，因此矽智產就被整合到系統中工作了。 
圖中可以看見，要將矽智產與匯流排作連接，「匯流排介面電路」(BIU, Bus Interface Unit)非常重
要。匯流排介面電路介於矽智產與匯流排訊號之間，是兩者的橋樑，負責兩項工作[24]： 
¾ 替矽智產處理匯流排協定的動作。 
¾ 使資料順利在匯流排與矽智產之間傳輸。 
當系統開發者取得一個矽智產後，要將它整合到系統中工作，最重要的工作就是為矽智產設計匯
流排介面電路。因此本章MAC硬體整合工作最主要就是為MAC設計匯流排介面電路。 
要設計匯流排介面電路的工作，可以按下列三個步驟進行： 
先了解欲整合到的系統內部採用的匯流排協定(6.2節) 
分析矽智產本身提供的介面訊號(6.3節) 
進行匯流排介面電路的設計(BIU, Bus Interface Unit)(6.4節~6.5節) 
(1)先了解欲整合到的系統內部採用的匯流排協定: 
首先，使用者必須了解 SOPC 晶片其內部所使用的匯流排的協定，了解 SOPC 的晶片匯流排的運
作方式。包括矽智產在匯流排上的角色(Master 或 Slave)、Master 與 Slave 訊號的定義、以及匯流排進
行傳輸時的行為與時序。 
(2)分析矽智產本身提供的介面訊號： 
了解目標系統所採用的匯流排協定後，接下來使用者需要分析自己的矽智產所提供給匯流排的介
面訊號，了解矽智產本身所設計用來與匯流排溝通的傳輸機制，並儘量將訊號簡單化，只保留最基本
的溝通訊號。在本研究中，因為 Opencore 10/100 Ethernet MAC本來是設計在WISHBONE匯流排上工
作，因此其匯流排訊號相當複雜，因此在移植到 AHB 匯流排上時，需要先移除它的 WISHBONE 匯流
Control/Status
 Register(s)
DMA
Opencore Ethernet 
MAC SIP
Slave Port
Master Port
Slave
BIU
Master
BIU
& RAM
 
圖 -21  MAC在匯流排上的 Slave與Master角色說明圖 
因此在本研究中要將 Opencore Ethernet MAC 放到 AHB 匯流排中工作，就需要為 MAC 設計
Master 與 Slave 兩個匯流排介面電路。Master 匯流排介面電路要與 PLD-to-Stripe Bridge 連接，Slave 
匯流排介面電路則與 Stripe-to-PLD Bridge連接。7-2-2 Bridge與 PLD之間的訊號 
接下來使用者需要認識在 ARM-based ExcaliburTM SOPC中，PLD與 Bridge之間的訊號，下面分別
PLD-to-Stripe Bridge和 Stripe-to-PLD Bridge的訊號。 
 
6.2.2.1 PLD-to-Stripe Bridge的訊號 
使用者加到 PLD 的矽智產若為 Master，就需要透過 PLD-to-Stripe Bridge 與 Stripe 溝通。此時
Bridge對Master BIU而言是一個 Slave元件，因此 PLD-to-Stripe Bridge的訊號都以 SLAVE為開頭來命
名，下面是 PLD-to-Stripe Bridge的訊號。 
 
SLAVE_HCLK
SLAVE_HADDR [31:0]
SLAVE_HWRITE
SLAVE_HTRANS [1:0]
SLAVE_HSIZE [1:0]
SLAVE_HBURST [2:0]
SLAVE_HWDATA [31:0]
SLAVE_HRESP [1:0]
SLAVE_HRDATA [31:0]
SLAVE_HMASTLOCK
SLAVE_HRADYO
SLAVE_HREADYI
SLAVE_HSEL
SLAVE_HSELREG
Master BIU
SLAVE_BUSERRINT
PLD-to-Stripe
Bridge
Stripe
A
H
B
  B
U
S
PLD
 
圖 -22  PLD-to-Stripe Bridge訊號方塊圖 
圖圖 -22中每個訊號的說明如下表： 
PLD-to-Stripe Bridge與 AHB Master BIU之間的的訊號 
編號 訊號名稱 來源 意義 
¾ 新增了一個 SLAVE_HSEL，當Master BIU向 Stripe發出要求時拉為高電位 
¾ 新增了 SLAVE_HSELREG 與 SLAVE_BUSERRINT 匯流排訊號。用來處理匯流排出錯的情
形。若使用者在匯流排出錯時不欲作任何處理。那麼把 SLAVE_HSELREG 設成恆為低電位，
並忽略 SLAVE_BUSERRINT即可。 
6.2.2.2 Stripe-to-PLD Bridge的訊號 
使用者加到 PLD 的矽智產若為 Slave 時需要透過 Stripe-to-PLD Bridge 被 Stripe 電路存取。此時
Bridge對 PLD中的 Slave BIU而言是一個Master元件，因此 Stripe-to-PLD Bridge的訊號都是以Master
為開頭命名，下面是 Stripe-to-PLD Bridge的訊號。 
MASTER_HCLK
MASTER_HADDR [31:0]
MASTER_HWRITE
MASTER_HTRANS [1:0]
MASTER_HSIZE [1:0]
MASTER_HBURST [2:0]
MASTER_HWDATA [31:0]
MASTER_HRESP [1:0]
MASTER_HRDATA [31:0]
MASTER_HLOCK
MASTER_HRADY
MASTER_HBUSREQ
MASTER_HGRANT
Slave BIUStripe-to-PLD
Bridge
Stripe
A
H
B
  B
U
S
PLD
 
圖 -23  Stripe-to-PLD Bridge訊號方塊圖 
圖圖 -23中每個訊號的意義列於下表： 
Stripe-to-PLD與 AHB Slave BIU之間的訊號 
編號 訊號名稱 來源 意義 
1 MASTER_HCLK PLD 
電路時脈。由 PLD 輸入腳輸入，用
來驅動 PLD 中的電路並提供給
Bridge作 Stripe與 PLD之間電路的同
步。 
2 MASTER_HADDR[31:0] Stripe 匯流排傳來的 32位元位址訊號。 
3 MASTER_TRANS[1:0] Stripe 
標示出傳輸的型別。若此控制訊號等
於 2’b10，表示目前這筆資料是連續
傳輸的第一筆；若是 2’b11，表示是
傳輸中間的一筆。Slave 以此訊號判
斷新的一筆傳輸何時開始。 
4 MASTER_HWRITE Stripe 
讀 /寫控制訊號。高電位表示進行
「寫」傳輸；低電位元示進行「讀」
傳輸。 
5 MASTER_HSIZE[1:0] Stripe 
標示傳輸的資料寬度。(*與 AHB 標
準規定的 HSIZE[2:0]不同，因為只支
援到 32位元資料寬度)。 
6 MASTER_HBURST Stripe 標示 Burst Transfer 的類型。進行Burst 傳輸時，此訊號用來告知 Slave
A B
Control
(A)
Control
(B)
Data  (A)
Data  (A)
HCLK
HADDR[31:0]
Control
HWDATA[31:0]
HREADY
HRDATA[31:0]
Address Phase Data Phase
1st
 post-edge 
2nd
 post-edge 
3rd
post-edge 
 
圖 -24  AHB Pipelined Operation—Basic Transaction 
圖圖 -24的傳輸行為說明如下： 
1°首先 Master 在 HCLK 的第一個正緣觸發(1st post-edge)時，偵測到 HREADY 訊號為高電位，表
示 Slave能接受傳輸。並且此時Master也有傳輸的需求，於是Master就進入 Address Phase狀態，並在
Address Phase期間送出位址 A和其它的控制訊號 Control (A)。 
2°在第二個正緣觸發(2nd post-edge)時，Master又偵測到 HREADY訊號為高電位，表示 Slave己經
取得Master在 Address Phase送出的訊號，於是Master就進入 Data Phase狀態，並在此 Phase期間送出
要寫到 Slave的資料 Data(A)，或是等待所要讀取的資料回傳。 
3°在第三個正緣觸發(3rd post-edge)時，Master繼續偵測到 HREADY訊號為高電位，表示 Slave己
經成功完成 Data(A)的寫入動作，或是所要讀取的資料 Data(A)己經傳回來了。至此完成一次成功的傳
輸行為。 
AHB 匯流排協定最大的特色是採用 Pipelined Operation 的傳輸時序—將 Address Phase 與 Data 
Phase 重疊進行。在上圖中，可以看見 Pipelined Operation 的行為--每相鄰兩筆傳輸，後面一筆傳輸的
Address Phase會與前一筆傳輸的 Data Phase重疊進行。因此，當第一筆傳輸進到 Data Phase期間時，
第二筆傳輸的 Address Phase 也開始了。這樣傳輸的方式是為了達到更高的效能。這種傳輸行為就稱之
為 Pipelined Operation。 
6.2.3.2 插入Wait State的 AHB 傳輸時序 
如果 Slave 不能立刻完成 Master 所要求的讀/寫動作，就會插入等待的狀態(Wait State)。下圖圖 -
25與上頁的圖圖 -24相似，只是當 Master 偵測到 HREADY 降下時，表示 Slave 插入 Wait State。於是
Master就將位址與資料 Hold住，直到 HREADY重新拉起。 
Data
(A)
 
A
Data 
(A)
bus_clock
stb_o
adr_o[31:0]
ack_i
rdat_i[31:0]
wdat_o[31:0]
1st
 post-edge 
2nd
 post-edge 
3rd
post-edge 
4th
post-edge 
 
圖 -27  Handshake傳輸協定波形圖 
Handshake協定的傳輸方式很簡單，說明如下： 
1. 當傳送端要求進行傳輸時，首先將 stb_o 訊號升起，同時送出位址與欲寫出的資料，傳輸
過程中這些訊號會維持不變。 
2. 直到收到接收端傳回來 ack_i 訊號，表示傳輸己完成。於是傳送端將 stb_o 與其它訊號降
下。 
由於WISHBONE匯流排協定是由 Handshake協定加上擴充的其他控制訊號所產生的，因此我們可
以保留 WISHBONE 協定中的 Handshake 訊號，以維持矽智產與匯流排溝通的功能，然後將其餘
WISHBONE相關的訊號移除，如此就可以得到乾淨的MAC匯流排介面。再將MAC與 AHB BIU連接
起來，就完成將 Opencore MAC移植到 AHB匯流排上的工作。 
下圖圖 -28是將 Opencore 10/100 Ethernet MAC由WISHBONE匯流排介面移植到 AHB匯流排的方
法示意圖。 
m_wb_stb_o
m_wb_we_o
m_wb_adr_o[31:0]
m_wb_dat_o[31:0]
m_wb_ack_i
m_wb_dat_i[31:0]
wb_stb_i
wb_we_i
wb_adr_i[31:0]
wb_dat_i[31:0]
wb_ack_o
wb_dat_o[31:0]
Master 
Port
Slave
Port
Modified 
10/100 Ethernet 
MAC SIP
Master
BIU
Slave
BIU
 
圖 -29  移除WISHBONE之後的MAC訊號 
Slave與Master Port，MAC與匯流排介面電路之間都以單純的 Handshake協定作溝通。圖圖 -29中
訊號的說明如下表： 
編號 訊號名稱 來源 意義 
1 wb_stb_i BIU 
傳輸啟動訊號。當此訊號拉起時，
表示要進行資料傳輸，並且在整個
傳輸期間，此訊號都維持高電位。
傳輸結束時才降為低電位。 
2 wb_we_i BIU 
讀 /寫控制訊號。高電位表示進行
「寫」傳輸；低電位元示進行
「讀」傳輸。 
3 wb_adr_i[31:0]   BIU 由匯流排傳來的 32位元位址。 
4 wb_wdata_i[31:0] BIU 進行「寫」傳輸時，欲寫入 MAC的資料。 
5 wb_ack_o MAC 
MAC的回應訊號。當 MAC完成被
讀/寫的傳輸後會將此訊號拉起，通
知 BIU傳輸己完成。 
6 wb_rdata_o MAC 進行「讀」傳輸時，MAC 回傳的資料。 
  MAC Slave Port與 Slave BIU之間的訊號 
 
編號 訊號名稱 來源 意義 
1 m_wb_stb_o MAC 
傳輸啟動訊號。MAC 將此訊號
拉起時，表示要向匯流排要求傳
輸，並且整個傳輸期間，此訊號
都維持高電位，直到傳輸結束時
才降為低電位。 
2 m_wb_we_o MAC 
讀/寫控制訊號。高電位表示要進
行「寫」傳輸；低電位元示進行
「讀」傳輸。 
3 m_wb_adr_o[31:0]   MAC MAC送到 BIU的 32位元位址訊號。 
4 m_wb_wdata_o[31:0] MAC 進行「寫」傳輸時，MAC 欲寫到記憶體的資料。 
5 m_wb_ack_i BIU 
BIU 的回應訊號。當 Slave 完成
傳輸後，BIU 會將此訊號拉起，
通知MAC傳輸己完成。 
2°HREADY 為 1，表示 Slave 完成傳輸(若 HREADY=0，Master 需將訊號維持住，等候 Slave 將
HREADY拉成 1。 
3°當 HREADY為 1的同時，BIU回傳 ack訊號通知 Ethernet MAC。MAC就將 stb訊號降下。 
Data (A) Data (B)
Data (A+4)Data (A) Data (A+8)
(A+4)(A)
DataAddr Addr WaitWaitDataAddr State
Data (A) Data (A+4)
Data (A)
(A) (A+4) (A+8)
Ctrol (A) Ctrol (A+4) Ctrol (A+8)
NONSEQIDLENONSEQIDLENONSEQ
SLAVE_HREADYO
State
SLAVE_HADDR[31:0]
SLAVE_HWDATA[31:0]
m_wb_ack_i
SLAVE_HTRANS
SLAVE_HCLK
m_wb_stb_o
m_wb_adr_o [31:0]
m_wb_wdat_o[31:0]
m_wb_rdata_i [31:0]
SLAVE_HRDATA [31:0]
SLAVE_Control
From 
MAC
To 
MAC
1
2
3
Data (A+4)
(A+8)
Master BIU  Waveform (with HREADY always high)
1
 
圖 -31  AHB Master BIU的波形圖 
6.4.3 Step3：設計Master BIU的狀態機 
根據上面的波形圖圖 -31，狀態轉移的情形在圖中可以清楚看到。當系統閒置時處於 Address 
State。當 MAC 發出傳輸要求時(stb=1)，狀態轉移到 Data State。如果 HREADY=0 就維持在 Data 
State，當 HREADY後狀態轉移到Wait State。Wait State是為了讓訊號恢復而插入的緩衝 State，下一個
Cycle就回到 Address State等待下一筆傳輸。 
Master BIU的有限狀態機如下圖所示，畫出有限狀態機之後就可以完成 HDL的設計工作。關於使
用 HDL設計有限狀態機的方法，可以參考 SNUG論壇 2000年的一份 Coding Style文件。[22] 
圖圖 -33中的訊號都己經在前面 6.2.2 節與 6.3.2 節說明，在此不再重述。確定 Slave BIU 的訊號
後，接下來畫出 Slave BIU的電路波形圖。 
 
 
6.5.2 Step2：畫出 Slave BIU的電路行為波形圖 
BIU 必須負責兩個工作：(1)滿足匯流排協定的要求，以及(2)與矽智產之間進行傳輸。因此必須畫
出符合匯流排協定與 HandShake協定的波形圖。如下圖圖 -34所示： 
NONSEQ 
(A)
Addr State
Data 
(A+4)Data (A)
Data 
(A+4)
Data(A+4)Data(A)
(A+4)(A)
Data(A+4)Data(A)
(A+8)(A+4)(A)
Control(A+8)Control(A+4)Control(A)
SEQ (A+8)SEQ (A+4)
Addr StateWait StateData State
Data (A)
Addr State Wait StateData State
MASTER_HTRANS[1:0]
FSM State of BIU
MASTER_HADDR[31:0]
MASTER_HWDATA[31:0]
wb_dat_i[31:0]
MASTER_HREADY
MASTER_HCLK
wb_stb_i
wb_adr_i [31:0]
wb_ack_o
Slave BIU  Waveform
wb_dat _o[31:0]
MASTER_HRDATA [31:0]
MASTER_Control
1
2
3
To
 MAC
From 
MAC
 
圖 -34  AHB Slave BIU的波形圖 
圖中虛線上方是 Master BIU 與匯流排之間的訊號，虛線下方則是 Master BIU 與 MAC 之間的
Handshake訊號。波形圖圖 -34的傳輸行為說明如下： 
1° Slave BIU偵測到 HTRANS訊號為 NONSEQ，表示 Stripe-to-Bridge傳來傳輸的要求。 
2° 承 1°，Slave BIU將 stb訊號升起，通知MAC接受傳輸要求。 
3° MAC完成傳輸工作後將 ack訊號升起，通知 Slave BIU傳輸己完成，Slave BIU經過 1個 Cycle
延遲後將 HREADY升起，通知 Bridge傳輸己完成。 
6.5.3 Step3：設計 Slave BIU的狀態機 
從波形圖中，我們可以看 Slave BIU 的有限狀態機的狀態轉移情形。當 Slave BIU 閒置時處於
Address State。如果 HTRANS 訊號變為 NONSEQ，表示傳輸開始，於是狀態轉移到 Data State 並通知
MAC 接受傳輸。等到 MAC 回覆 ack 訊號後(ack=1)，表示 MAC 處理傳輸完成，狀態轉移到 Wait 
State。Wait State是為了讓訊號恢復的緩衝 State，下一個 Cycle就回到 Address State。 
Slave BIU的有限狀態機如下圖圖 -35所示，畫出有限狀態機之後就可以完成 HDL的設計工作了。 
 
圖 -37  建立 AHB Master BIU的 Block Symbol 
 
圖 -38  將 Slave BIU轉換成電路 Symbol元件 
完成後，回到電路圖編輯器，將 Opencore 10/100 Ethernet MAC，Master BIU與 Slave BIU三者的
電路符號引入到電路圖中。圖圖 -39是在電路圖中引入電路符號的畫面。圖圖 -40則是三個使用者設計
的電路符號被加到電路圖編輯器後的畫面。 
 
圖 -39  在 QuartusⅡ電路圖編輯器中加入 Block Symbol 
 
 
 
圖 -42  Block Symbols Connection 
 
圖 -43  執行電路編譯 
 
圖 -44  生成 Configuration Data 
至此，就完成了將矽智產整合到 SOPC上的工作了。 
 
 
 
 
 
MAC 需要透過實體層的 PHY 晶片才能與網路線路上的電氣訊號溝通。通常 PHY 晶片在系統啟動
後需經過初始化設定以及一些操作模式的設定(如網路速度，全/半雙工模式等)才能正常運作，因此就
需要為 PHY 撰寫驅動程式。但是在本篇論文中則無此需求，因為本篇論文中使用新華電腦公司的
Creator發展板，板上配置的是 DAVICOM公司型號 DM9161的 PHY晶片[9]。 
當此 PHY 晶片重置時，控制暫存器會自動設定一組預設值的操作值將 PHY 晶片自動設定成一般
通用的操作模式，以此預設值就可以正常動作，所以在此也不需要為 PHY撰寫驅動程式。 
7.3 MAC Device Driver 
7.3.1 訊框描述者(Buffer Descriptor) 
接下來介紹使用者的程式與 10/100 Ethernet MAC溝通進行封包收送工作的機制---藉由「訊框描述
者」來溝通[25][26]。 
無論是系統接收到的封包和系統所要傳送的封包，都必須要放在記憶體中。用來存放傳送與接收
封包的記憶體空間，稱為「訊框緩衝區(Frame Buffer)」。當 MAC 接收到封包時，會將封包放到記憶體
中，然後程式再到記憶體讀取封包；而當程式要傳送封包時，也是先將封包寫到記憶體中，再呼叫
MAC到記憶體中讀取封包然後執行傳送的動作。在整個網路工作的過程中，因為接收/傳送的封包數量
很多，所以需要對緩衝區的使用提供一個機制，使得整個嵌入式系統能對接收和傳送的封包作有效的
管理。 
在 Opencore 10/100 Ethernet MAC 中，程式要規劃 MAC 將所收到的封包放到緩衝區中的哪個位
置、以及通知 MAC 在傳送封包時到緩衝區中的何處讀取封包，是藉由下圖「訊框描述者(Buffer 
Descriptor 或 Frame Descriptor)」的運作機制來管理。每一個緩衝區中的封包都有自己專屬的一個訊框
描述者。訊框描述者記錄封包在記憶體中存放的位址(Frame Pointer)，另外也記錄了封包的長度(Frame 
Length)和相關的狀態資訊(Status)。訊框描述者與訊框緩衝區的關係如下圖圖 -46所示。 
Frame #1
Frame #2
Frame #N
Frame Buffer
Memory
Frame Pointer #1
Frame Length Status
Frame Pointer #2
Frame Length Status
Frame Pointer #N
Frame Length Status
Buffer 
Descriptors
 
圖 -46  乙太網路訊框描述者示意圖 
訊框描述者分為 Rx Buffer Descriptor和 Tx Buffer Descriptor兩種，分別用來管理接收的封包和要
傳送的封包。當網路程式初始化的時候，會先在每個 Rx 訊框描述者中規劃一個位址(Frame Pointer)。
當 MAC 收到一筆封包時，MAC 會先去讀取 Rx Buffer Descriptor，並根據其中的位址，將封包儲存到
的。 
[2] LC – Late Collision 發生 Late collision。傳送停止並且此位元被設成 1。Late 
collision 在 COLLCONF控制暫存器中定義。 
[1] DF – Defer Indication The frame was deferred before being sent successfully, i.e. 
the transmitter had to wait for Carrier Sense before sending 
because the line was busy. This is not a collision indication. 
Collisions are indicated in RTRY. 
[0] CS – Carrier Sense 
Lost 
傳送中，若失去 Carrier Sense。則在傳送完成後將此位元
設成 1。 
  Tx Buffer Descriptor的欄位意義 
 
 ADDR = Offset + 0 
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 
LEN 
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
E IRQ WR Reserved CF M OR IS DN TL SF CRC LC
 
ADDR = Offset + 4 
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 
RXPNT 
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
RXPNT 
圖 -48  Rx Buffer Descriptor 
 
位 元
位置 
位元名稱 說明 
[31:16] LEN – Length 記錄接收到的訊框長度(多少 Byte) 
[15] E – Empty 0 = 與這個 buffer descriptor對應的訊框儲存記憶體空間己經
被填滿(或是因錯誤而中止了)。當此位元為 0時，RISC可以
來讀或寫此 BD.只要這個位元是 0，此 BD 就不會被 Rx 
MAC所使用。 
1 = 與這個 buffer descriptor對應的訊框儲存記憶體空間是空
的(準備好可以接收資料或是正在接收資料中)。 
[14] IRQ – Interrupt Request 
Enable 
0 = 接收完成後不產生中斷。 
1 = 當此訊框描述者所對應到的資料被接收完畢。RXF中斷
會被拉起。(見 INT_SOURCE 控制暫存器的更多細節). 
[13] WR – Wrap 0 = 標明此 buffer descriptor 還不是訊框描述者陣列的最後
一個。 
1 = 標明此 buffer descriptor 己是訊框描述者陣列的最後一
個。在這個訊框描述者被使用完之後，會回到第一個訊框描
述者繼續使用。 
[12:9] Reserved 保留 
[8] CF – Control Frame 0 = 收到一般的 frame 
1 = 收到 Control frame 
[7] M – Miss 0 = The frame is received because of an address recognition hit. 
1 = The frame is received because of promiscuous mode. 
[6] OR – Overrun 當接收 frame 時，若來不及將 FIFO 中的資料寫到記憶體
中，發生 FIFO滿溢(overrun)時，此位元就會被設為 1。 
[5] IS – Invalid Symbol IS – Invalid Symbol 
This bit is set when the reception of an invalid symbol is 
detected by the PHY. 
[4] DN – Dribble Nibble 當接收到的訊框總長度不是剛好為 8bit 的整數倍時(收到多
餘的 nibble)，這個位元就會被設成 1。 
[3] TL – Too Long 當收到的訊框長度太長時，此位元會被設成 1 (比
PACKETLEN 控制暫存器中所設的值更大) 
下面是本篇論文提供的一個簡單的例子，對本論文所整合的矽智產作控制。首先需要宣告 PLD
電路的基底位址。(位址為 0x80000000，詳見附錄 B)。然後宣告控制暫存器的位址，並進行程式的撰
寫。 
 
圖 -49  在程式中宣告 PLD電路的基底位址 
 
圖 -50  在程式中對 Ethernet MAC的控制暫存器作宣告 
 
 
圖 -51  主程式 
 
 
 
 
8.SOPC驗證及實驗結果 
本節介紹 SOPC 在開發的整個過程中的驗證工作。首先使用者取得矽智產整後，先對矽智產的
RTL 行為作驗證。之後在為矽智產設計好匯流排介面電路後，將矽智產與介面電路整合，再觀察匯流
排介面電路與矽智產後的 RTL 行為是否正確。以上工作完成後，才將電路放到 SOPC 系統中進行整合
的工作。 
下圖圖 53是 SOPC開發工作的驗證流程： 
START
Verify 
SIP Behavior (in RTL)
Behaves 
Correctly ?
Verify
SIP Bus Behavior (in RTL)
Behaves 
Correctly ?
Verify System on SOPC 
Development Board
W ork as wished ?
RETURN
1.
2.
3.
Verification Flow of SOPC Development
Check SIP Design
Check BIUs Design
 Check the synthesized design or 
check the User-designed S/W
yes
yes
yes
no
no
no
 
圖 53  SOPC開發的系統驗證策略 
1. Verify SIP Behavior：對矽智產的行為作驗證。在 SOPC開發中，使用者在將矽智產整合到系統
之前，必須先對矽智產本身的功能作 RTL 行為的驗證。如果行為不正確，則必須檢查矽智產的設計
(Check SIP Design)是否有誤，直到這個步驟正確，再進行下一步。 
2. Verify SIP Bus Behavior：對矽智產在匯流排上的角色作驗證。使用者為矽智產設計好匯流排介
面電路後，必須檢查矽智產與匯流排介面電路結合後，在匯流排上的 RTL 行為是否正確。Verify SIP 
 圖 56  Waveform of Opencore 10/100 Ethernet Tx MAC (1) 
 
圖 57  Waveform of Opencore 10/100 Ethernet Tx MAC (2) 
8.2 MAC SIP與 AHB BIU結合之 RTL行為驗證 
8.2.1 Slave的 RTL行為驗證 
 
圖 58  AHB Slave BIU的波形驗證圖 
8.2.2 Master的 RTL行為驗證 
 
圖 59  AHB Master BIU的波形驗證圖 
8.3 ARM-based Excalibur SOPC發展板上驗證 
SOC 開發中，驗證是相當困難的一部分。在 SOPC 中，雖然驗證的問題大大減低了，但是在軟硬
體整合的時候，仍然需要適當的將驗證切割成幾個部分分別進行，這樣可以在功能不正確的時候，快
速釐清問題發生在矽智產本身，或是於平台中才出錯，或是軟體撰寫的功能有問題。 
RJ45
ARM
(IDLE)
Creator-Excalibur子板
Stripe PLD
PHY
FSMFSM
 
圖 61  只對 PHY功能作測試 
8.3.2 Verify MAC + PHY 
接下來我們要在 PLD放入 Opencore 10/100 Ethernet MAC矽智產，但是不由程式控制，而是透過
一個有限狀態機模擬匯流排的訊號，來控制 MAC 矽智產。以證實 MAC 電路在 PLD 中能正常動作，
示意圖如圖 62。有限狀態機 FSM 控制 MAC 進行傳送封包的動作。並以 ROM 存一個封包讓 MAC 從
ROM讀取封包內容並送出。 
 
圖 62  測試MAC在 PLD中能否正常工作 
此工作結果，PC 端正常收到由 MAC 所送來的封包，因此證實 MAC 矽智產可以在 PLD 中正常工
作。經過以上測試，可以證 PHY 與 MAC 的硬體電路都可以正常工作。接下來就可以將問題專注在軟
體的開發，若之後系統有問題，可以知道是軟體需要進行除錯。因此，這樣的驗證策略可以快速的釐
清，當系統功能出現問題時錯誤發生在哪裡。 
8.3.3 Verify S/W + MAC + PHY 
在第一步與第二步的驗證工作完成後，就可以確定 PHY 與 MAC 硬體都是正常工作的。現在我們
再將軟體與硬體整合測試，利用 ARM以程式來控制矽智產。如果這個步驟也順利的話，那整個系統就
驗證完成了，若是這個步驟如果發生問題，那麼我們也能夠判斷問題在於軟體本身出錯。 
如圖圖 63，我們要在 PLD中整合一個 Ethernet IP，並且為它設計 Slave與 Master Wrapper。並且
透過驅動程式與應用程式的撰寫，使得此 SOPC 平台能與外部網路溝通。讓 ARM 以程式控制 MAC，
正常收/送封包。 
 
 
圖 65  系統實體電路—SOPC發展板 
 
 
 
 
 
 
 
 
 
 
 
 
 
MAC TX合成後的電路速度 
 
AHB BIUs合成後的電路速度 
 
9. PC 端的測試/存取控制的發展環境 
9.1 設計目標 
 
SoC 系統建構完成後，需要有一套軟體幫助我們對系統作測試以及存取控制。所以我 們也為我們的
平台整合技術，規劃一套在 PC 端的測試/控制軟體，當使用者完成系統 後，該軟體會以圖形化的方式
將系統呈現。使用者可以用點選的方式，任意選擇要觀察  的模組或某條訊號線，軟體就會執行 
Protocol verification 的動作。另外，還可以將 軟體透過與上述的硬體平台作連接，作存取的控制。舉例
來說，使用者在軟體中點選圖 形化系統的模組或某個 Scan Chain Register，並輸入想寫入的值，軟體
就會自動產生 對應的 JTAG 指令，將 Test/Debug Pattern 送到 FPGA 中。同樣的，也能將想觀察的值 從
硬體平台讀取回 PC 端。 
9.2 關於模組的 Protocol Verification 部份 
使用模擬器來進行電路的模擬、驗證、及除錯是最節省成本的一種方式。一般來說，當我們的電 
路在設計之初，我們會先根據我們硬體的規格用高階的程式語言（例如 C++）來描述我們的硬體行為。 
這樣的作法有助於我們在早期就可以對我們要設計、開發的硬體有初步的驗證環境。此外，我們可以 
透過模擬器所產生的結果來判斷這樣的硬體規格是否符合實際的應用。 
此外，當我們初步完成我們的硬體設計時，我們可以使用模擬器執行出來的結果與我們實際 設計
出來的硬體電路作比對，這樣便可以驗證我們的設計是跟當初的要求是相符合的。而若是兩 個出來的
結果不相符，我們就必須針對不同的地方去檢查是否在我們硬體的設計有錯誤的地方。 
 .
 
 
 
 
 
 
 
 
 
 
 
 
圖 72 Bus Model & Protocol checker Verification block diagram 
 
 
 
 
AHB 
 
Master  
0 
 
Master  
1 
 
 
 
. . . . . . 
. 
 
 
 
 
Master 15 
 
 
 
 
 
 
 
 
 
Arbiter 
& 
Decoder 
 
Memory 
Controller 
(AHB Slave BIU) 
 
APB 
 
 
 
APB Bridge 
(AHB Slave) 
(APB Master) 
 
 
 
 
 
AHB Slave  2 
 
 
AHB Slave  15 
 
 
RAM 
( behavoral model) 
 
 
 
APB Slave 0 
 
APB Slave  1 
. . 
 
APB Slave  15 
 
 
 
Protocol 
Monitor 
 
 
 
 
 
 
 
 
 
 
Bus 
Model 
 
 
 
  
圖 73 Bus Model & Protocol checker Verification detail block diagram 
 
圖 72是 Bus model & Protocol checker驗證方塊圖，圖73 是 Bus model & Protocol checker詳細驗證方塊
圖，AMBA 主體是 arbiter & decoder、APB bridge、記憶體控制器(Memory Controller) & behavioral 
model RAM，其餘 AHB Master 0~15、AHB Slave 2~15、APB Slave 0~15 均為 Bus-functional Model， 模
擬所有可能 master/slave 行為來驗證 AMBA，Bus-functional Model 是用 Verilog code 編寫成的 
behavoral model，以下是各種狀況的模擬列表。 
 
Verification Type Event Case 
 
Bus Contest 1.  lock transfer 2.  split transfer 
 
Transfer Type 
1. Basic transfer (no wait state), transfer with wait state 
2. Multiple transfer 
3. Split transfer 
 
Burst Type 
1. Single/undefined-length burst 
2. Incr,4,8,16 burst 
3. Wrap 4,8,16 burst 
AHB/APB 
slave response 
 
OK, error, split response 
 
Bus handover 
 
Bus handover with split, handover after burst 
 
   Bus-functional Model verification type 
   ck that HTRANS must be IDLE on second clock of 2 cycle response 
  ck for 1KB protection violations for bursts 
  ck that HTRANS never transfers from IDLE to BUSY 
  ck that HTRANS never transfers from IDLE to SEQ 
 
    AHB Protocol Monitor Check items 
 
下表是 Protocol Monitor 對 AHB 及 APB 的檢查項目，主要都是在檢查一些會造成違反 AMBA 匯流
排協定(bus protocol)的狀況,是根據 AMBA specification 2.0及參考 cadence 網站關於 AMBA 驗證資料編
寫而成。 
 
  Protocol Monitor Check item description (APB Bus) 
 eck all the APB bus state sequence for reset，IDLE，Setup，and Enable 
 eck for only IDLE and setup to be allowed，if the previous state was a reset 
  ies that reads followed by writes require an additional cycle per AMBA 2.0 
 
APB Protocol Monitor Check items 
 
 
9.3 與硬體平台連接，作存取控制 
 
針對一個大型的、複雜的數位電路而言，設計工程師必須要能夠快速、有效率的對於生產的第一 
個晶片進行除錯及驗證的工作。 
我們將針對我們已經分析好的架構著手進行軟體的實作。我們首先會將析好的硬體電路特性條
列 出來，然後分別針對不同的特性設計不同的硬體資訊參數讓軟體能夠針對不同的參數產生不同的
測試 資訊來控制硬體進行除錯。在這裡，我們必須謹慎的定義我們每個模組所負責的功能以及每個
層次模 組之間溝通的參數傳遞。如此一來，未來我們若是需要開發出新的除錯功能或者是新的除錯
介面，設 計者可以很輕易的增加或替換某些模組來達到。在我們將模組化的實作設計完成之後，我
們會分別對 於這些功能模組進行功能的驗證。針對單一個功能模組進行完整的功能驗證將會降低往
後將一個個功 能模組整合成完整的程式時發生問題的機率，並且在問題發生時也比較容易找出問題
之所在。當所有 的模組的功能都正確無誤之後我們就會著手加以整合，並且將整合完畢的除錯軟體
實際接到不同的微 處理器以及內嵌式電路擬真器進行實際的電路除錯功能驗證，用以證明我們設計
的模組化軟體功能是 正確的。 
 
 
◆ JTAG Architecture 
 
 
IEEE  Std.  1149.1  Boundary  Scan  Architecture（或稱之為  JTAG）是由  Joint  
European  Test Action Group 於 1985 年所發表。隔年，此組織將北美的研究團隊納入其中，正式改
名為 Joint Test Action Group。 
 
 
JTAG  最主要的目的是要制訂一個標準化的測試連接埠以及邊界掃瞄(Boundary  Scan)的架 
構。透過 IEEE  1149.1  Boundary  Scan  Architecture 的實現，我們針對一個電路板要進行測試的 
 去 TRST 的腳位。當此 TAP 有限狀態機進入到在圖中靠左邊的那一排狀態時代表目前除錯者從 
TDI 輸入的是除錯的資料，而當進入到在右邊的那一排狀態時則是表示目前除錯者從 TDI 所輸 
入的是除錯的指令。 
 
 
 
 
 
 
1 Test- Logic- Reset 
0  
1 1 1 
0 Run- Test / Idle 
Select- DR- Scan 
0 1 
Capture- DR 
0 
0
 
Shift- DR 
1 
 
Exit1- DR 1 
0 
Select-IR- Scan 
1 
0 
Capture-IR 
0 
0
 
Shift-IR 
1 
 
Exit1-IR 1 
0 
 
Pause- DR 
1 0 
0 0 
Exit2- DR 
1 
 
Pause-IR 
1 0 
 
Exit2-IR 
1 
 
Update- DR 
1 0 
 
Update-IR 
1 0 
 
 
 
圖  76  TAP Finite State Machine 
 
 
 
 
由於 IEEE  Std.  1149.1 的架構相當的簡單，並且在設計上面不會對電路造成太大的負
擔， 不管是面積上、速度上亦或是耗電上。因此目前大部分的測試及除錯的機制都是採用 
JTAG 作 為測試及除錯資料的基礎傳輸介面。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Step 2、 表示為圖中實線路徑。在此階段中，我們將整合完的 SoC RTL code 中的 Master 來執行 
verification program。在 RTL 模擬時，因為驗證程式會讀取上一步驟所產生的 Result vector， 故
驗證程式會把實際模擬所產生的結果做比較。如果比較結果一致，送出訊息通知 Testbench 中的 
Verification Monitor 讓 RTL 繼續模擬，若比較結果有誤，則 Verification Monitor 則停止 
RTL 模擬讓使用者進行除錯。 
 
 
 
 
下表列出驗證無誤之自動驗證比對程式和 RTL 波形驗證所用之 Test Pattern。以下針對每一個驗證 程
式的流程提出說明: 
 
 
Program Description Verification
sdram.s 驗證 memory controller 是否能正確存取 
SDRAM。 
 
○ 
TestOnChipRAM.s 驗證 On Chip RAM 加上 Wrapper 後，是否能正 
確地被 Master 存取。 
 
○ 
uart.s 將 uart 做 loopback 測試，藉以驗證 uart 功能的正 
確性。 
 
○ 
timer.s 驗證系統的計時器(Timer)是否能根據使用者的 
設定產生中斷，進而驗證中斷控制器是否能正確 
地對 Master 發出中斷，而 Master 也能正確地處 
理中斷向量。 
 
○ 
fpga.s 將系統 download 至 FPGA 做實體電路驗證，證 
明系統能在 prototyping 系統能正確存取 I/O 裝 
置。 
 
○ 
 
自動驗證比對程式 
圖 77 sdram 驗證流程 
 
 
 
● TestOnChipRAM.s: 
對於內部記憶體的測試的方法為對同一內部記憶體位址做 0x55555555、0xAAAAAAAA 的 讀、
寫，來驗證記憶體每一個 bit 是否有 struck-at-fault，以及加上 wrapper 後 master 對內部記憶體 做存取
的動作是否有誤，圖 78 為驗證 On Chip RAM 的流程，當我們把 0x55555555 寫入內部記憶體後，在
讀回來跟 Result vector 做比較是否一致。接 
著 0xAAAAAAAA 寫入內部記憶體後，在讀回來跟 Result vector 做比較是否一致。當兩者結果都 
是正確，RTL 模擬持續對內部記憶體的下一個位址做相同的驗證，否則停止驗證，讓使用者來
進 行除錯。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
圖 78 On Chip RAM 的驗證流程 
 
 
 
● uart.s 
UART 的測試採用 loopback 的方式，也就是將傳送出去的資料由自己再自行收回，然後比較 送
出及收到的資料是否一致。此方法可以驗證 UART 傳輸、接收以及全雙工的功能是否有誤。圖 79 為 
UART 驗證流程，其中的 i 表示從 0x00 至 0xFF 也 是驗證 UART 每一個傳送接收的 case。也就是
說我把資料 i 送出後，再接收回來跟 Result 做比較 是否一致。 
取，例如七段顯示器、LED 燈、4x4 Key Pad 和 LCD 做控制，藉以用來展示及驗證系統功能的正 確
性。錯誤!  找不到參照來源。為 FPGA 的實際執行的流程，也就是說整個系統在跑的時候、在 
LCD 上我們可以看見”ESLab”的字樣、LED 在做 Running light 的效果、七段顯示在一開始時顯示 0 
然後隨著按下 Key Pad 來改變顯示的數值。若沒有觀察到以上的結果則表示系統有問題，使用者則 根據
那個 I/O 有問題來進行除錯。 
 
 
AMBA
system
8-Bit LED 
Display
C
2M Bytes Flash ROM
16M Bytes SDRAM
Creator BoardFPGA Development System
Camera Module Interface
Control & 
Decoder
4x4 
KeyPad
128x128 
LCD
Power 
Supply
Xilinx  XC2V 1000 
fg456 
Control Signal
Reload 
Circuit
Control 
Signal
Address Bus
Data Bus
Clock 
Generator
UART
 
圖 錯誤! 所指定的樣式的文字不存在文件中。-1 FPGA之系統方塊圖 
    左半部為 FPGA Virtex-II Prototype Platform，可以容納系統範例。FPGA板上使用導線及轉接板連
接至 Creator板，系統的程式或資料在開機時在置 2M bytes的 Flash ROM裡。為了驗證系統上的各個
周邊裝置的功能(如 UART、Interrupt Controller)，針對每一個周邊撰寫測試程式。然後在 RTL 做最嚴
謹的模擬驗證後，如功能模擬結果符合預期，則將 RTL code 放到 FPGA 的合成軟體上。當軟體
synthesis完時，確認 timing是否符合 Specification，符合則繼續下一步驟。接著做 Place and Route完成
後，軟體產生 bit stream檔。在將 bit檔 download至 FPGA上，在實體電路上做 Debug。以上步驟在軟
體一有 warning 或 error 得馬上修改 RTL code，修改完整個流程再跑一變，直到所有功能符合 Spec.為
止。 
    我們所建立的系統雛形，其操作為:在 PC 設計的程式，組合語言或 C 語言，經由 assember 或
compiler翻譯成可以燒 ROM的影像檔。再由個人電腦透過 PC 的 Printer Port經由 Creator的 ICE下載
至 Flash ROM。然後我們所整合的系統皆可以透過 AHB 的 slave 裝置，Memory Controller，來讀取
Flash ROM中的程式。 
 
 
 
系統實體電路—SOPC發展板 
 由上面的範列我們已經將實現了AMBA 匯流排產生器(AMBA Generator)，並且將由本實驗室設
計的IP(SYS32TME、乙太網路介質存取控制器)，分別實現在Xilinx Virtex2 XC2V1000 FG456晶片、新
華電腦Create EPXA1的FPGA上，如下圖。並在這樣的發展平台上驗證成功，功能正常。 
 
 面對SOC 的時代，我們的設計觀念不能在只放在設計某些特定元件上就好，我們必須將眼光擴
大到以系統的角度來看。如何利用現有的IP 配合軟硬體資源來設計出實用而又成本低廉的產品，是需
要我們去學習的。我們也可以從本計畫的執行過程中學習到如何協調不同模組的結合，以及當軟硬體
資源不足或有衝突時，我們該如何去解決問題。同時，如何能在最短的時間內完成以一On-Chip Bus 
為平台的系統設計，快速整合具重複使用的周邊及系統巨集元件容易被整合進去無論是全客戶、標準
元件和邏輯陣列為技術的設計流程中；且要讓模組化的設計很容易的被整合進去一個以On-Chip Bus 
為平台的系統發展環境。以我們發展ASIC 和Soft IP design 的經驗，我們有信心可以完成此計畫，並
將此計畫研究成果整合進未來其他整合型SOC(System-On-A-Chip)設計中，以達到改善Platform-based 
Design 的目的。 
參考文獻 
 
[1]. Vesa Lahtinen, Erno Salminen, Kimmo Kuusilinna, Timo Hämäläinen, “Comparison of Synthesized 
Bus and Crossbar Interconnection Architectures”, ISCAS IEEE International Symposium on Circuits 
and Systems, May 25 - 28, 2003 Magazine, Volume: 17, Issue: 2, March 2000, pp. 43 – 51 
[2]. M. Hunt and J. A. Rowson, ““Blocking in A System On a Chip”, IEEE Spectrum, Vol. 33, pp. 35-41, Nov. 
    1996. 
[3]. 資策會資訊市場情報中心, http://mic.iii.org.tw/intelligence/. 
[4]. P. Lysaght, R. Chapman, and T. Durrani, “System Level Integration, Intellectual Property, and the 
Education of a New Generation of System Designers”, IEE Colloquium on Systems on a Chip, Vol. 2, 
pp.1-5, 1998. 
[5]. AMBA Specification, Rev. 2.0, ARM Inc, 1999. 
http://www.arm.com/armtech/AMBA_Spec?OpenDocument 
[6]. Overview of the CoreFrame Architecture, Rev. 1.01, Palmchip Inc., Jan. 2002. 
    http://www.palmchip.com/pdf/CP-9152W-1.01.pdf. 
[7]. Virtual Socket On-chip Bus Attributes Specification, Rev. 0.9.6, VSIA Org.,1999 
[8]. WISHBONE Specification, Rev. B.2, Silicore Inc., Oct. 2001. 
    Applications”, Proceeding of IEEE International Conference on Computer Design: VLSI in Computers 
and Processors, pp. 230-235, Oct. 1998. 
[9]. S. Simon, “The ARM9 Family – High Performance Microprocessors for Embedded Applications”, 
Proceeding of IEEE International Conference on Computer Design: VLSI in Computers and Processors, 
pp. 230-235, Oct. 1998. 
[10]. AMBA AHB-Lite Overview, 
http://www.arm.com/miscPDFs/1744.pdf 
[11]. AMBA AXI Specification,  
http://www.arm.com/products/solutions/AMBAAXI.html 
[12]. AMBA Multi-layer AHB Overview 
    http://www.arm.com/miscPDFs/1745.pdf 
[13]. http://www.instat.com/ 
[14]. http://www.sipa.gov.tw/1/in7/development-91/a407.html 
[15]. http://www.altera.com, “Excalibur EPXA1 Devices”. 
[16]. http:// www.altera.com, “AN177: Using the Excalibur Stripe PLLs” 
[17]. http://www.microtime.com.tw/English/PreSOC.htm 
[18]. http://www.arm.com/products/DevTools/ADS.htm 
[19]. IEEE Std 802.3, 2000 Edition 
[20]. “WISHBONE System-on-Chip (SOC) Interconnection Architecture for Portable IP Cores,” OpenCore 
organization, 2003 
[21]. “AMBA Specification, Rev2.0,” ARM Inc, 1999. 
[22]. C.E.Cummings,“Coding And Scripting Techniques For FSM Designs With Synthesis-Optimized, Glitch-
Free Outputs” SNUG, 2000 
[23]. Quartus Handbook, Altera Inc, 2005 
[24]. Marc Bertola, Guy Bois, “A methodology for the design of AHB bus master wrappers,” Proceedings of 
the Euromicro Symposium on Digital System Design, 2003 
[25]. “Ethernet IP Core Specification,” OpenCore organization. 
[26]. “Ethernet IP Core Design Document,” OpenCore organization. 
 
 
 
 
 
 
  Stripe的參數設定—Page1 
 
 
  Stripe的參數設定—Page2 
-- Select Excalibur family 
請選擇「Excalibur_ARM」 
-- Select available device 
選擇「 EPXA1 」       
-- Reset Operation 
選擇「Boot from Flash」 
-- Byte order 
選擇「Little endian」 
-- Reserve pins 
將「SDRAM」和「UART」
打勾 
--Bridges 
將「Do you want to use the 
STRIPE-TO-PLD bridge」打
勾 
將「Do you want to use the 
PLD-TO-STRIPE interrupt 
sources」打勾 
--Interrupts 
PLD interrupt mode選擇
「Mode 3 – Six individual 
requests」 
--Trace/Debug 
不打勾 
--General Purpose IO 
不打勾 
完成後請按「Next」
 
Figure 67  Stripe的參數設定—Page4 
 
 EBI0 EBI1 EBI2 EBI3
Prefetch OFF OFF OFF OFF
Byte Enable ON ON ON ON 
Wait Cycles 8 0 0 0 
CS Polarity L L L L 
Data Width 16 16 16 16 
Bus Clk Divide 6 6 6 6 
Timeout 200 200 200 200 
Enable E-Clk ON ON ON ON 
Enable S-Reads OFF OFF OFF OFF
 
 
 
Memory Map 
Registers 
7FFFC00
0 
16K 
SRAM0 08000000 16K 
SRAM1 08004000 16K 
DPRAM0 08100000 16K 
SDRAM0 00000000 32M 
EBI0 40000000 8M 
EBI1 10000000 32M 
EBI2 30000000 64K 
EBI3 40C00000 4M 
PLD0 80000000 2G 
Other Options set OFF 
--SDRAM port width 
記得寬度要設為「16-bits」，否則不能正常工作。 
