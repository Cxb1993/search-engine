1 
中文摘要 
 本計畫為三年整合型計畫中的子計畫一，本子計畫之主要目的為設計與實作智慧
型感測器、媒體存取控制之協定與個人化的室內服務跟隨 (Context-Aware Service)應
用，來提供其它子計畫所需要的軟、硬體應用。在第一年的計畫中，我們結合無線感
測器、無線網路與自走車，實作出智慧型行動感測器。我們同時設計了一個導航協定，
利用上述發展出的智慧型行動感測器，實現在無線感測網路進行感測節點的置換。在
第二年的計畫中，我們設計一個簡單且準確的時間同步方法，利用簡單的計算，少量
的封包傳送，達到 Multi-hop 時間同步；同時針對無線感測網路在資料收集過程中，
可能產生的擁塞問題，我們提出一個分散式的演算法來減少網路擁塞，並且適當分配
感測器到匯集節點的資料流量。我們提出的混合式擁塞控制協定不僅考慮在無線感測
網路中感測器封包的傳遞速率，也同時考慮感測器緩衝器剩餘的空間，來有效地分配
感測器資料流的速率而避免網路擁塞發生。在第三年的計畫中，為達成有限電量的感
測器有效且持續運作，進而延長網路壽命，我們設計了一個分散式的拓樸演算法。此
演算法不需節點的位置資訊，即可建出有效利用電量之樹狀拓撲架構。另外，我們提
出一個分散式的協定，以感測節點間的跳步計數(hop count)來建立一個虛擬座標系統
稱之為 HVC。在網路中的感測節點可以透過 HVC 來得知地標間的相對座標。然後起
始點可以找到一條輔助的繞徑路徑來指引從起始點到目的地旅程之方向。 
 
關鍵詞: 擁塞控制、地理繞徑、行動感測器、時間同步、拓樸控制、無線感測網路 
3 
1. The Research Achievement 
(1) The research achievement of the first year 
A. Design and Implement a Smart Mobile Robot 
 In the first year, we designed a smart mobile robot and implemented an application of 
nodes replacement to demonstrate its use, via our nodes replacement algorithm. In this 
algorithm, the mobile robots can navigate towards low-energy sensor nodes and replace 
them automatically, with new sensor nodes, having no location information. The navigation 
algorithm is based on received signal strength between the mobile robot and the 
communicating node. The experimental results confirm that the mobile robots successfully 
achieved their assigned tasks. 
 (a) Architecture of Mobile Robot 
Mobile robots are built from off-the-shelf components offered by Motes. Motes are a 
series of products for WSNs, designed by UC Berkeley, and produced by Crossbow 
Technology, Inc [1]. UC Berkeley also designed an event driven operating system, TinyOS 
[2], and a new language, nesC for embedded sensor networks. We used the Motes MICA2 
and MICA2DOT to implement our mobile robots and sensor networks, which can provide 
the functions of computation, communication, and sensing. In order to imbue the sensor 
nodes with mobility, we designed a single circuit board to drive the motors. Fig. 1 shows 
the block diagram of our system architecture. MICA2 was the main component supporting 
computation and communication capabilities for the mobile robots. It could process sensing 
data from the sensor boards and control motors through a motor board. We used separate 
power units to supply the MICA2 and the motors, in order to increase the stability of the 
system.  
 
Figure 1: Hardware architecture of mobile robot. 
Our mobile robot used a MICA2 platform as its central processing and radio unit. Our 
motor board was designed to control the motors in the mobile robot. The output control 
5 
sensor node. It will send a “Help” packet to the sink node through the created routing path. 
The “Help” packet will record the path from node F to node A that is <F, E, D, C, B, A>. 
Thus, a navigation path from the sink node to node F has been created.  
Figure 3: Creating a routing path from each 
sensor node to the sink node. 
Figure 4: Creating navigation path from sink 
to the low-energy node F. 
 
The mobile robot used the received signal strength to navigate from one node to 
another; it could, therefore, move to the next sensor node by continuously monitoring the 
signal strength of the beacons sent from the node at the next hop. Eventually, the mobile 
robot was able to reach its destination. The received signal strength decreased as the 
distance increased. On average, signal strength decreases with distance according to the 
following equation [3]: 
αx
constPP transmitreceive =  
where Preceive and Ptransmit are the power of the received and transmitted signals, respectively. 
The distance between the receiver and transmitter is x meters and α is an exponent that 
characterizes the steepness of the decrease. The value α depends on the propagation 
environment. The value of α is 2 when radio waves propagate in free space. There is usually 
additional attenuation in wireless networks, which brings α > 3 with the precise value 
dependent on terrain and other environmental factors, such as buildings. In metropolitan 
areas, α = 4 is often used in this expression. According to this equation, the mobile robot 
will receive weaker and weaker signal strength as it gradually moves away from the sender, 
just as the received signal strength will become stronger as it approaches the sender. We can 
use this feature to determine whether the mobile robot is approaching or retreating from the 
sender. The mobile robot can use the received signal strength to navigate towards the 
sender.  
Here, we illustrate how the signal strength is used to navigate from one sensor node to 
another. First, we have defined a turning point to be used in our navigation protocol. The 
7 
 
Figure 5: Turning point of a straight line L. Figure 6: The moving steps of a mobile 
robot 
from the sink node to its neighboring 
node A. 
In our navigation protocol, we adopted two transmission power levels for the sensor 
nodes to navigate the mobile robot. Using low transmission power not only saves energy for 
the sender, but can also allow the mobile robot to navigate close to the sender. This is 
because the received signal strength is more sensitive to low-power levels. In our protocol, 
we changed maximum-power transmission to a low-power level as the received signal 
strength was equal to the maximum value. An example is shown in Fig. 7. When a mobile 
robot senses that the received signal strength is equal to the maximum value of the 
maximum-power transmission, it will ask the sender to change the transmission power to 
low-power level. As the mobile robot senses that the level of received signal strength is 
equal to the maximum value in the low-power level, this means that the mobile robot has 
approached the target sensor node. 
9 
Note that, in order to reduce the navigation time, the mobile robot can move toward the 
next hop node and bypass the current guiding node if it can receive the signal sent from the 
next hop node. In our protocol, the mobile robot will send the “Notify” packet in every few 
seconds to the next hop node during it approaches the current sensor node by using the 
low-power level. This is because the mobile node is near by the current guiding node and 
has possibility near to the next hop. If the mobile robot can receive the acknowledgement 
from the next hop node, it asks the current sensor node to stop sending the beacon packets 
and then moves to the next hop node directly. Therefore, the mobile robot can directly 
navigate to the next sensor node, without moving hop by hop from sink to the destination 
node.  
 (c) Experiment Results 
In our experiment, we used a single mobile robot to find the location of a 
three-hops-away target node. We evaluated the distance accuracy and navigation time of the 
mobile robot moving towards the destination node In order to allow the mobile robot to 
easily receive the beacon packets from the beacon node; we used the maximum-power level 
to guide the mobile robots in the beginning of navigation. When the degree of RSSI 
received by the mobile robot reached 7, this indicated that the distance between the mobile 
robot and beacon node was about 1 meter. In the meantime, the mobile robot notified the 
beacon node to send the beacon using low transmission power, to save energy and so that 
the mobile robot could navigate closer to the beacon node. Finally, the mobile robot would 
approach the beacon node, if the received RSSI was 7, under low transmission power.  
In the experiment, we used a single mobile robot to navigate from the sink node to a 
target node three hops away from the sensor node. The static sensor nodes were randomly 
deployed and any two adjacent nodes were fixed at 1 or 2 meters. Our experiment observed 
the distance accuracy and navigation time of the mobile robot moving to its destination 
node. The distance accuracy was the distance between the target sensor node and the mobile 
robot after the mobile robot had arrived at the target sensor node. The navigation time was 
the average time taken for navigating from one sensor node to another. We performed 10 
experiments for two different distances − 1 meter and 2 meters − between two adjacent 
nodes. In each experiment, we randomly chose a sensor node three-hop-away. In these 
experiments, there was no obvious difference in distance accuracy for the different 
distances between two adjacent nodes. The average distance accuracy for two adjacent 
nodes at a distance of 1 meter and 2 meters was 7.2 centimeters and 7.5 centimeters, 
respectively. This was because the termination condition of the mobile robot was dependent 
only on the received signal strength. The variances of distance accuracy for 1 meter and 2 
meters were 1.35 and 1.49, respectively. However, the navigation time was proportional to 
the distance between any two adjacent nodes. The average navigation time was 28 seconds 
and 70 seconds, in the case of 1 meter and 2 meters, respectively. The variance of 
navigation time for 1 meter and 2 meters was 5.33 and 17.11, respectively.  
11 
synchronization messages. Consequently, those nodes collect four time-stamps information 
as shown in Fig. 9. Then, each node can calculate the clock drift ratio between the reference 
node and itself from the four time-stamps, which isθ = (T3 - T1) / (T4 - T2). 
 
Figure 9: Timing diagram for synchronization procedure of RSP 
According to the ratio, each node can estimate the local time of reference node in the 
following way. 
(3) .
)()()(
)(:)(0)(:)(
0
24
13
13240
24130
T
TT
TΤTT
TTTTTTT
TTTTTTT
SR
SR
SR
+−
−×=⇒
−×=−×−⇒
−−=−−
 
where TS represents the local time of sensor node and TR represents the corresponding 
local time of the reference node. Additionally, T0 (=φ ) is the initial offset between reference 
node and sensor node. In other words, the T0 is the local time of reference node when the 
local time of senor node is 0. It can be calculated using linear interpolation with the four 
time-stamps as shown in Fig. 10. Thus, the T0 can be derived as follows. 
 
)4(.-
)()(
)(:)(0)(:0)(
24
3241
0
032014
010324
TT
TTTTT
TTTTTT
TTTTTT
−
××=⇒
−×=−×⇒
−−=−−
 
 
Figure 10: Expression of linear interpolation with the four time-stamps 
Therefore, we can derive (5) from the (3) and (4): 
 
24
3241
24
13
TT
TTTT
TT
TTTT SR −
×−×+−
−×=  (5) 
By (5), each sensor node can estimate the local time of reference node, that is, the 
13 
Algorithm: Ratio-Based Time Synchronization 
Input: 
msg; /* time synchronization message */ 
α , β ; /* thresholds for time synchronization */ 
T = {(Tx, Ty)|(Tx, Ty) : the recent received k pairs of time-stamps };  
Output: 
θ ,φ ; /* the relative drift ratio and offset to the synchronization root */ 
Main()  
{ My_root_ID = My_ID; /* declare myself as the synchronization root */ 
Broadcast time synchronization message msg periodically; 
Loop: 
if (Receive any synchronization message msg) 
{if (My_root_ID > msg.Sync_root ) /* Check if a more suitable root exists. */ 
{if (My_root_ID == My_ID) stop the broadcast of time synchronization message 
msg; 
T1 = msg.Time_stamp; /* the transmitter’s clock time */ 
T2 = My_local_timestamp; /* the receiver’s clock time */ 
My_root_ID = msg.Sync_root;  
My_parent = msg.Send_ID;  
My_sync_seq = msg.Seq_num;  
T ← Φ; T ← T∪(T1, T2) ;} 
else if (My_Parent == msg.Send_ID and My_sync_seq < msg.Seq_num ) 
{T3 = msg.Time_stamp; T4 = My_local_timestamp; 
My_sync_seq = msg.Seq_num;  
if (T3 – T4 α> ) 
{Find a timestamp pair (Tx, Ty) from T such that T3 – Tx β> ; 
T1 = Tx; T2 = Ty ;} 
θ = (T3 – T1) / (T4 – T2); 
φ = (T1 ×T4 –T2 ×T3) / (T4 – T2) 
T ← T∪(T3, T4); 
Broadcast a new synchronization message msg;} 
else  
Discard msg; } 
go to Loop; 
} 
 
 
We implement RSP and FTSP on the MICAz platform based on TinyOS. The FTSP 
protocol was designed by Vanderbilt University [4]. Based on our best knowledge, FTSP 
15 
generated by node i. The total data rate ( itr ) of i through the network layer to MAC layer are 
converged both irr and
i
sr . So that, the
i
r
i
s
i
t rrr += . The forward data rate ( ifr ) is the total rate 
that all of its downstream neighbors allow it to pass. A packet could be queued at buffer at 
network layer when the forward rate ifr  is smaller than the total rate
i
tr . If 
i
tr  is continuously 
bigger than ifr , the buffers will fill up quickly. Finally, the buffers will overflow, and the 
congestion will take place. In order to avoid the congestion, we can reduce the isr ,
i
rr  or both. 
 
Figure 12: Packets flow model of sensor i. 
 
We assume each link is symmetric. Each sensor node has two type neighbor nodes: one 
is a group of upstream neighbors and another is a group of downstream ones. Let Ui be the set 
of upstream neighbors of node i, which pass through i and forward to the sink. Let Di be the 
set of downstream neighbors of node i, which are the next hop on the routing path from i to 
the sink. We assume that each sensor node has a counter that can calculate the data rate from 
upstream neighbors and recode the data rate to downstream neighbors. An upstream neighbor 
must be its parent and a downstream neighbor must be its children. 
The remaining buffer size of i is represented by RBi and the net flow size of i is 
represented by NSi. Assume that the packet length is fixed. Each sensor node i has a 
congestion degree CDi, which is the index of congestion level. According to the congestion 
degree, we can classify the current traffic load of each node into light-load state and 
heavy-load state. Sensor nodes have a neighbor table to record the congestion degree and 
traffic information of neighbors. 
In the following, we present our Hybrid Congestion Control Protocol (HCCP), which 
mitigates congestion and allocates appropriate source rate to the sink node for sensor 
networks. HCCP comprises two phases: congestion detection phase and data rate adjustment 
phase. HCCP does not maintain the global flow information. Each node makes use of its 
current remaining buffer size and net flow size to calculate its congestion degree. And the 
congestion degree is exchanged periodically between neighbors. Therefore, each node can use 
its congestion degree and its neighbors’ congestion degree to prevent congestion.  
17 
on a packet-by-packet basis. Then a net flow size NSi is the source traffic rate of sensor i ( isr ) 
plus all flows from upstream neighbors of sensor i and minus all flows that sensor i can 
forward to downstream neighbors during a time period T as follows: 
 NkjiTRRrNS
ii Dk
ki
Uj
ij
i
si ∈∀×−+= ∑∑
∈∈
,,,)( ,,  (6) 
In order to indicate the index of congestion, we define a congestion degree CDi, which is 
the remaining buffer size minus the net flow size of each sensor i during a time period T as 
follows: 
 iii NSRBCD −=  (7) 
If the CDi is smaller than 0, the buffer state of i will become heavy and congestion may 
happen in the next time period. The sensor i will broadcast a suppressive message to advertise 
its neighbors to slow down their data rates.  For sensors to know the congestion degrees of 
their neighboring nodes, they will advertise their congestion degrees to each other. For each 
sensor, the advertisement is triggered by either of the following two events: (1) in the 
beginning of each time period T and (2) the buffer state from light-load to heavy-load. In 
order to reduce the control message overhead, if a sensor has the data traffic, we piggyback 
the congestion degree in the header of the data packet. 
 
(b) Data Rate Adjustment Phase 
Assume that the sensors will forward the data packets to the downstream neighbors as 
fast as possible. When sensor i obtains the congestion degrees of its upstream and 
downstream neighbors, it will calculate the value of itr  and 
i
fr , and updates its congestion 
degree. Once the CDi of sensor i is larger than or equal to 0, it means that the buffer state of i 
is light, and therefore, it will do nothing. On the other hand, if the CDi of sensor i is smaller 
than 0, it will suppress the data rate of upstream neighbors of i. In order to allocate effectively 
data rates to upstream neighbors, the upstream neighbors that tend to congest will be allocated 
more data rate. Sensor i can estimate each upstream neighbor’s tendency towards congestion 
by CDx and Rx,i. We define a tendency congestion degree )(xiα  represents the degree of 
congestion probability of x if the total traffic from x to i is prohibited in a time period T. Then 
we have 
 iixxi UxTRCDx ∈∀×−= ,)( ,α  (8) 
If )(xiα  less than 0, it represents if sensor i suppress the data rate Rx,i, sensor x may 
congestion in the next time period. Otherwise, if )(xiα  is larger than or equal to 0, it 
represents congestion will not happen in the next time period even if sensor i suppresses the 
data rate Rx,i. Therefore, the more negative the value of )(xiα is, the more data rate will be 
19 
these nodes will further suppress their upstream neighbors in the same way. This process 
repeats hop-by-hop towards the source node or leaf nodes. The whole network will reach 
the most effective congestion free. 
 
The HCCP Algorithm 
For each sensor i in every time period T: 
Each sensor broadcasts its congestion degree to neighboring nodes. 
Phase 1: Congestion detection 
1. Sensor i calculates its own CDi. 
2. Sensor i estimates whether congestion will happen or not in the next time period T. 
3. When congestion will happen in the next time period is detected, sensor i broadcasts a suppressive 
massage to suppress the data rate of its upstream neighbors.  
Phase 2: Data Rate Adjustment 
1. Sensor i calculates its own PCi, 'iPC , )(xiα , and iSUM . 
2. If 0' ≥iPC , sensor i will allocate new data rate to the upstream neighbors according to Equation (11). 
3. Otherwise, sensor i will allocate the new data rate to the upstream neighbors according to Equation (12).
 
We compare the performance of HCCP with the previous rate-based and buffer-based 
congestion avoidance schemes. The packet collision caused by random media access is 
resolved by the MAC layer protocols. We use ns-2 simulator for our simulations. The 
simulation time is 200 seconds. We compare our HCCP scheme with rate-based scheme 
AFA [5] and buffer-based scheme BB [6]. 
 
The total source rate is defined as the total number of data packets generated by the data 
sources per second. Fig. 14 compares the total source rates of three schemes with respect to 
simulation time. The HCCP scheme combines the advantages of buffer-based and rate-based 
schemes. HCCP considers the packets delivery rate and remaining buffer size of each node at 
the same time. It can allocate effectively the data rate of upstream neighbors according to 
their tendency of congestion degrees. These simulations show that our congestion protocol 
HCCP is able to adjust effectively the proper data rate for sensors and obtains the better total 
data rate than other schemes. 
21 
assumed that the sink is within communication range of at least one node of the network. 
The connectivity holes in the network may occur due to small physical gaps among 
different group of nodes at the time of deployment or due to gap among the nodes of the 
same region, as they are unable to be connected with minimum transmission power level 
(Pmin). However, initially all nodes either from the same or different groups use a fixed 
transmission power level for communication and form a connected network without any 
power control. This fixed transmission power level could be assumed as the maximum (Pmax) 
or in between the minimum and maximum power levels. As per our experimental results 
performed using Mica mote [7] with RF frequency 866 MHz and given in Table 1, 0 is 
considered as the minimum (Pmin) and 3 as the maximum (Pmax) transmission power level 
for communicating among nodes and we consider this value throughout our paper. Before 
proceeding to the next section of the paper, we define few technical terms that are used in 
our protocol. 
 
Figure 16: Randomly deployed sensor nodes with connectivity holes among different group 
of nodes. 
Definitions 
z Upstream and Downstream Groups: Let {G1, G2, G3, . . .} be the set of group of nodes 
distributed over certain area. If ∃  two groups Gi and Gj, for i ≠ j, such that a control 
packet is forwarded from any node of Gi to Gj, then Gi is known as the upstream group 
with respect to Gj and Gj is the downstream group with respect to Gi.  
z Local Hop Counts (LHC): It is a counter, which represents the number of hops that a 
control packet traverses locally within a group, when it is forwarded from one node to 
other.  
z Group Hop Counts (GHC): It is a counter, which represents the number of hops that a 
control packet passes, when it is transmitted from one group to other. The value of 
GHC is unique for all nodes of a particular group and it is incremented by 1, if the 
packet is transmitted from one group to other. Value of GHC is initialized to 0 and in 
23 
= Sink’s ID, PGID = Sink’s ID, NEL = Sink’s power level, LHC = 0, GHC = 0, PGPL = 0. 
Since, sink node generally receives the data, its PGPL is assigned to 0, which is different for 
other parent gateways of the network. Upon receiving the construct packet, the neighbors of 
the sink within its minimum transmission power range (Pmin = 0), scan all parameters of the 
packet. They wait for the random time Wi, as defined in Eq. (13), and get connected with the 
sink. Let Ni, be the number of neighbors of ith node, out of N nodes in the network. Upon 
receiving a construct packet, the waiting time of the ith node can be considered as:  
 NiNW iii ,...,3,2,1, =∀+= α  (13) 
where iα  is a small random number compatible with CSMA-CA mechanism [8]. Then, 
each of them rebroadcasts the construct packet using the same minimum power level Pmin = 
0 to their neighbors with necessary increments to the parameters of the construct packet and 
waits for time Ti units, as defined in Eq. (14). 
 NiET iii ,...,3,2,1, =∀= β  (14) 
where Ei is the current energy level of ith node and bi is a very small random number such 
that 0.00001 ≦ iβ  ≦ 0.0001. 
In order to avoid the packet collision among group of nodes in a dense network, we 
propose that the sink also waits for Ti units after broadcasting the construct packet and then 
goes to the information phase. It is to be noted that sink must be within at least one of the 
sensor node’s minimum or maximum transmission power range. However, if the sink does 
not find any neighbor with Pmin = 0, it goes to the information phase to construct the link 
with its neighbors, after the waiting time Ti has elapsed. 
Upon receiving the construct packets, the nodes scan all parameters in it and consider 
the node having least LHC as its source. The receiver nodes wait for Wi units, get connected 
with its source and then follow the same procedure, as described above. This process 
continues till a node does not receive any construct packet further and the first tree topology 
is constructed among the nodes of a group, as shown in Fig. 18(b) with sink as the root and 
other nodes within minimum transmission power level to it as the children of the sink. Since, 
we assume that there are connectivity holes among different group of nodes or some nodes 
are unable to construct link using Pmin, the construction phase is terminated after a finite 
interval of time. The next group of tree topology is formed after the information phase is 
executed. It is to be noted that the construct packet is always transmitted using minimum 
transmission power level and each time LHC is incremented by 1, when it hops from one 
node to another. In a group, it could be possible that some nodes might have received the 
same construct packets from other neighbors, too. Then, how a node decides its own source 
node? We have discussed this part of the problem in the maintenance phase. 
 
Figure 17: Format of the construct packet. 
25 
group could be estimated as follows. Let,  
 S = {Si/∀ i =1,2,…,m; and m < N} (16) 
be the set of senders who broadcast inform packets. Considering N as the total number 
nodes in the network, let, 
 S = {Si/∀ i =1,2,…,m; and m < N} (17) 
be the set of nodes who receive the inform packets. After getting the inform packet and 
using Eq. (15), let {dij} be the estimated distance between the sender Si and receiver Rj, ∀ i 
= 1, 2,. . ., m; and ∀ j = 1, 2,. . ., n. Let, 
 Dij = min({dij}), for i = 1,2,…,m; and j = 1,2,…,n (18) 
 
Figure 19: Format of the inform packet. 
It is to be noted that a node of one group might have received several inform packets 
from the nodes of another one. So, each node uses Eq. (18) to find the shortest distance i.e. 
Dij = min({dij}), among all nodes (senders) of a group with itself (receiver). After 
calculating the value of {Dij}, a node again uses Eq. (15) to estimate the effective 
transmission power between the closest sender (i) and itself (j), which is denoted as PTx(ij). 
As evidenced from our simulation results, we find that probability of using maximum 
transmission power level is very small for the high density network. So, it is worth to 
mention here that a few number of nodes may use maximum power (Pmax = 3) as the 
effective transmission power to communicate with a node of an upstream group. 
Accordingly, in our protocol, the effective power level PTx(ij) may be 1 or 2. However, in 
the worst case, PTx(ij) = 3 may be used as the possible effective transmission power level.  
After the random time has elapsed, the nodes who have already received the inform 
packets, broadcast the construct packets using the minimum transmission power level as 
described in the construction phase. The effective power level with which a node can be 
connected with the upstream group is given in the PGPL field of the packet. The value of 
GHC is copied from the inform packet to the respective field of the construct packet. The 
nodes add their own ID to the PGID field, declaring itself as the parent gateway and other 
parameters like SID, LHC, GHC and NEL are also added to the respective fields of the 
construct packet according to the definitions.  
Upon receiving multiple construct packets, a node has to first select the parent gateway 
for the group from the values of the GHC, PGPL and NEL based on the following rules.  
i. If value of GHC in the received construct packets are different, the sender whose 
construct packet contains the least value of GHC is selected as the parent 
gateway. 
ii. If value of GHC for all the packets are same, the sender having least value of 
PGPL is selected as the parent gateway. 
iii. If value of GHC and PGPL for all the received packets are same, sender having 
27 
this part of the protocol describes how a node decides whether to accept or reject either a 
construct or an inform packet and recover from the collision.  
a). Algorithm for accepting or rejecting the construct packets: 
z Initially, receiving buffer of all nodes is empty. 
z If a node receives multiple construct packets, it scans all parameters in it. 
z If value of (GHC) for all the construct packets are same, packet having least value of 
(LHC) is accepted, else the receiver accepts the packet having least value of GHC. 
z If value of GHC and LHC are same for all the construct packets, packet having least 
value of PGPL is accepted. 
z If value of GHC, LHC and PGPL are same for all the construct packets, packet having 
highest value of NEL is accepted. 
z Other than the above steps, the construct packet is rejected by the receiver. 
In each of the above cases, ID of the sender (SID) is noted down by the receiver and then 
it is connected with the sender. 
b). Algorithm for accepting or rejecting the inform packets: 
z Initially, receiving buffer of all nodes is empty. 
z If a node receives multiple inform packets with different values of (GHC), packet 
having least value of GHC is accepted. 
z If value of GHC are same for all the inform packets, packet having ID of the sink in 
the PGID field is accepted. 
z If value of GHC is same for all the inform packets without having the sink ID in the 
PGID field, packet having least value of PGID is accepted. 
z If value of GHC and PGID are same for all the inform packets, packet having least 
value of SID is accepted. 
In each of the above cases, the value of GHC and PGID are copied to the respective 
fields of the construct packet, which is later broadcast to the neighboring nodes with Pmin. 
c). Post-collision recovery scheme: 
This part of the protocol describes how a node recovers from the collision during the 
broadcast of either construct or inform packets. In certain situations, a node may not receive 
the construct packet due to collision or interference in the channel. For each node of the 
network, though we define different waiting time before broadcasting any type of packet to 
avoid collision, the construct packet may be lost due to some other reasons. For example, 
the nodes may not receive construct packets, if they are not within the minimum 
transmission range (Pmin = 0) of the sink. So, this scheme proposes how to overcome such 
problems, as described below.  
C-1: Node does not receive construct packet, but receives the inform packet: 
z Upon receiving an inform packet, a node executes the information phase and estimates 
the effective transmission power PTx . 
z If PTx is equal to the minimum transmission power level, destination node is connected 
29 
z Else, the child node having the highest energy level (NEL) is chosen as the next parent 
gateway. 
Finally, the dying parent gateway broadcasts a packet containing ID of its child gateway, 
ID of the would be parent gateway and its own timeout to die to its one-hop neighbors. 
Upon receiving this packet, the one-hop child nodes can know whether it is selected as the 
next parent gateway or not. The node that is selected as the next parent gateway broadcasts 
a search packet using the higher transmission power level (power level 1, 2 or finally 3) to 
be connected with the child gateway of the dying parent gateway or the closest node 
selected by it from another group. 
(c) Performance evaluation 
In order to evaluate the impact of our transmission power control protocol of energy 
consumption and network lifetime, it is simulated using Tiny OS (TOSIM) [8] 
Energy consumption 
The most important performance metric of the distributed wireless sensor networks is 
the average energy consumption due to data transmission with different power levels. Since, 
the computational component is a small fraction as compared to the communication, energy 
consumption due to computation is not considered in our simulation. We have simulated the 
average energy consumption for different node numbers of the network for different power 
levels, as shown in Fig. 21. As for a typical wireless sensor network with time slotted MAC 
protocol [14], nodes are assigned time slots to wake up and several nodes are considered 
backups of each other with respect to traffic forwarding and maintaining the time 
synchronization. Based on this implementation strategy, it is found that the energy 
consumption of our protocol for the higher node densities attains the optimal condition.  
.  
Figure 21: Average energy consumption for different node densities with transmission 
power control. 
Network lifetime 
Generally, network lifetime is defined as the time until the network no longer able to 
fulfill the tasks it is designed for. So, in our simulation, we define the network lifetime when 
31 
some specific value to make routing efficient. Thus, we define two specific values in our 
protocol. The first one is R, which indicates the hop distance between the two adjacent 
landmarks we wish to find, and the value of it will influence the number of landmarks in the 
network. The second one is X, which indicates the maximum hops of forwarding control 
packets to assign virtual coordinates to nodes by landmarks. 
To route the source node to the destination node, we flood the HVC chart to every node 
in the network to show them the global topology. Each node can find a shortest path, called 
the Auxiliary Routing Path (ARP), from it to the landmark nearest to destination node in the 
HVC chart to indicate the direction to the destination. The landmarks in the ARP will guide 
the packet to be greedy forwarded to its destination hop by hop. The landmarks in the ARP 
are similar to the pharoses; while we navigate in the dark ocean, they guide us to reach our 
destination sequentially. The HVC chart is similar to the nautical chart, which indicates 
where the pharoses are, as well as the ARP, which shows us the shortest path in the journey 
to the destination. For example, the network in Fig. 23 has a large hole within it. The blue 
triangle is the sink node, which initiates constructing the virtual coordinate system. The red 
node is the landmark, and the black line represents the distance between two closer 
landmarks. The HVC chart is composed of the landmarks and the black links between them. 
 
Figure 23: The HVC chart is constructed by the landmarks and black lines. 
(b) HVC Construction Protocol 
Here, we present our HVC construction protocol. In Fig. 24, we can see that the vertices 
of a hexagon with radius R are the intersection points of circles centered at each 
corresponding vertices with the same radius R. We can construct a number of hexagons 
from a specific point, such as point P in Fig. 24. Note that each vertex of a hexagon is the 
center of a circle. If we choose the centers of circles to be the landmarks of the network, we 
can obtain many landmarks which are uniformly distributed in the network. 
33 
with its ID in this ring-shaped area. Each node which has lm_hop = R assigned by the sink 
node receives this control packet, and will forward it if the ID in the packet is larger than the 
ID for itself. Otherwise, the control packet will be dropped. Finally, the control packet with 
the maximum ID will go back to the initiated node, and this node will become the second 
landmark. For example, assuming node P is the first landmark, as shown in Fig. 26, and the 
maximum ID in the ring-shaped area is node A, and node A will become the second 
landmark of the network. 
 
Figure 25: (a) The simulation results of nodes located at the R’th hop centered on nodes A 
and P. (b) The ring-shaped areas are drawn as two perfect rings. 
 
 
Figure 26: The perfect rings with radius = R hops. The landmarks are elected from the 
intersection regions of the ring areas. 
When the second landmark is elected, the landmark records the second pair of (lm_id, 
lm_hop) in its VCV with lm_id = the ID of itself and lm_hop = 0. The second landmark then 
sends a control packet including lm_id = the ID of itself and lm_hop = 1 to nodes within X 
hops. Each node receives the control packet, records the received (lm_id, lm_hop) in its 
VCV, and forwards the control packet with an increasing lm_hop to the other nodes in its 
communication range. Each node that receives the control packet will forward it if the 
lm_hop in the control packet is less than or equal to X.  
After the second landmark floods over R hops, the two rings centered at the first and 
second landmarks will have two intersection regions. For example, in Fig. 26, the 
intersection regions of the two rings with centers P and A are R3 and R4. Two nodes which 
have maximum ID within regions R3 and R4 will be elected as the third and fourth 
landmarks, respectively. A two-hop local flooding can be used to elect the landmark in each 
region. When the two landmarks are elected from regions R3 and R4, each landmark floods a 
35 
coordinates between the landmarks through the HVC chart. The HVC chart can point out 
where the destination is and where the landmarks are. We introduce an Auxiliary Routing 
Path (ARP) to indicate the direction in the journey from source to destination, so finally we 
can find a routing path to the destination with the ARP support. In our protocol, source node 
S will make greedy forwarding to destination node D. The landmarks shown in the ARP are 
merely to guide the packet to its destination, and we do not necessary to forward a packet to 
reach any landmark as long as the next node is closer to the destination than the current one. 
Each landmark is treated as a general node after the virtual coordinate system HVC is 
constructed. Note that the last landmark in the ARP is the one nearest the destination node. 
 The ARP is a path made up by the source node, destination node, and some landmarks 
to indicate the direction of packet transmission. The neighboring landmarks of the source 
and destination nodes can be thought of as the outlets and inlets in which packets can 
deliver out and receive from, respectively. Through intuition, we may find the shortest path 
from source to destination to be the ARP. However, we assume the inlet for the packet to 
receive from is the landmark nearest to the destination node to increase the success rate of 
forwarding packets while the packet was forwarded to the destination directly. We only add 
one direction to guide the packet to be received accurately, but this does not increase the 
routing path. Thus, we can apply the shortest path algorithm, like Dijkstra’s algorithm [17], 
to find the shortest path in HVC chart from the source node to a landmark nearest to the 
destination node as the ARP. For example, in Fig. 27, if T5 is the nearest landmark of the 
destination node D, we can find the shortest path from S to T5 by using Dijkstra’s shortest 
path algorithm.  
 
Figure 27: A diagram to demonstrate how to route source S to destination D. The ARP of 
this routing path is S→T1→T2→T3→T4→T5→D. 
 
 Since the distance between any pair of adjacent landmarks found by our protocol is 
almost equal, the ARP found by the source node may have many different choices due to the 
same path length. For example, in Fig. 27, there are six different paths from source node S 
to destination node D. The six paths aside from S and D are T1→M→N→O→T5, 
T1→M→T3→O→T5, T1 → M → T3 → T4 → T5, T1 → T2 → T3 → O → T5, 
T1→T2→T3→T4→T5, and T1→T2→P→T4→T5, respectively. Thus, we can randomly choose 
37 
transmitter to Tk becomes less than R hops, this means that the destination node D is close. 
We can then deliver the packet to D directly. For example, in Fig. 27, while the packet is 
forwarded to the circle centered at T5 with radius = R hops, the temporary destination T5 
will be replaced by destination D, and the packet will be forwarded to node D directly. 
 
(d) Simulations 
We used JAVA to implement our simulations. Our simulations do not consider the packet 
loss and packet delay but these simulations can verify the feasibility of the protocols. In all 
the figures, the sink node and landmarks are marked as blue triangle and red circles, 
respectively, and the sensor nodes are shown as small gray circles. 
Irregular Network Shapes 
To validate if our protocol is resilient to various network shapes, we did simulations for 
different scenarios. We chose 10,000 pairs of sources and destinations randomly to evaluate 
the packet delivery ratio. In all the simulations, the communication range of each node is 10 
m. In the first scenario, there are 2,500 nodes randomly distributed in a triangle area with 
one large hole = 50 m, where the base of this triangle is 500 m and altitude is 400 m. We set 
R = 9 hops. In our simulations, the packet delivery ratio from source to destination is 
96.23%. From our simulations, we found out that nodes located near the vertices of a 
triangle network leads to routing failure due to the existence of only one landmark. If we 
elect the node which has the maximum hop distance to the sink as an extra landmark in each 
region of vertex, the packet delivery ratio can reach up to 99.68%. 
The second scenario is shown in Fig. 28. There are 5,000 nodes randomly distributed in a 
500 m x 400 m rectangle area with four large holes in four corners, respectively, and three 
different shaped holes within the network. We set R = 8 hops. The packet delivery ratio is 
99.28%. The third scenario is shown in Fig. 29. There are 1,500 nodes distributed randomly 
in an irregular network with a large circle hole = 60 m. The width and length of the network 
are 320 m and 300 m, respectively. We set R = 8 hops. The packet delivery ratio is 99.56%. 
We found that the virtual coordinate system constructed by our protocol is resilient to 
various network shapes with a packet delivery ratio higher than 99%. 
 
Figure 28: A rectangle network with four large holes in the corner and three large holes 
within the network. 
39 
Reference 
[1] Crossbow Technology Inc., http://www.xbow.com. 
[2] TinyOS, http://www.tinyos.net. 
[3] D. J. Goodman, Wireless Personal Communications Systems, Addison Wesley, USA, 
1998. 
[4] M. Maróti, B. Kusy, G. Simon, and Á. Lédeczi, “The Flooding Time Synchronization 
Protocol.” in Proceedings of the 2nd International Conference on Embedded 
Networked Sensor Systems, pp. 39-49. 
[5] S. Chen and Z. Zhang. “Localized algorithm for aggregate fairness in wireless sensor 
networks,” in Proceedings of the ACM International Conference on Mobile 
Computing and Networking (MobiCOM), pp. 274-285, September 2006. 
[6] S. Chen and N. Yan, “Congestion avoidance based on lightweight buffer management 
in sensor networks,” in Proceedings of the IEEE International Conference on Parallel 
and Distributed Systems (ICPADS), September 2006. 
[7] Xbow. MPR/MIB Mote Hardware Users Manual. <http://www.xbow.com>, 
December 2003. 
[8] P. Levis, N. Lee, “TOSSIM: accurate and scalable simulation of entire TinyOS 
applications,” in Proceedings of First ACM Conference on Embedded Networked 
Sensor Systems (SenSys), USA, November 2003, pp. 126-137. 
[9] <http://www.ieee802.org/3/>. 
[10] A. Boulis, S. Ganeriwal, M. Srivastava, “Aggregation in sensor networks: an 
energy-accuracy trade-off,” in Proceedings of IEEE International Workshop on 
Sensor Network Protocols and Applications, USA, May 2003, pp. 128-138. 
[11] W. Du, J. Deng, Y.S. Han, P.K. Varshney, “A witness-based approach for data fusion 
assurance in wireless sensor networks,” in Proceedings of IEEE GLOBECOM, vol. 3, 
December 2003, pp. 1435–1439.  
[12] D. Petrovic, R. Shah, “Data funneling: routing with aggregation and compression for 
wireless sensor networks,” in Proceedings of Sensor Network Protocols and 
Applications, USA, May 2003, pp.156-162. 
[13] Q. Wu, N.S.V. Rao, J. Barhen, S.S. Iyengar, V.K. Vaishnavi, H. Qi, K. Chakrabarty, 
“On computing mobile agent routes for data fusion in distributed sensor networks,” 
IEEE Transactions on Knowledge and Data Engineering, Vol.16, No.6, pp. 740-753, 
2004. 
[14] K. Sohrabi, J. Gao, V. Ailawadhi, G. Pottie, “Protocols for selforganization of a 
wireless sensor network,” IEEE Personal Communication Magazine, Vol.7, No. 5,pp. 
16-27, 2000. 
[15] R. Ramanathan, R.R. Jain, “Topology control of multihop wireless networks using 
transmit power adjustment,” in Proceedings of IEEE INFOCOM, Tel-Aviv, Israel, vol. 
2, March 2000, pp. 404–413. 
41 
The self-evaluation of the achievement (計畫成果自評) 
 In the past three years, we design several protocols and these protocols are published 
or accepted by the international journals or conferences. All the achievements are listed in 
the following. 
 
International Journals 
 
[1] J.-P. Sheu, C.-S. Hsu, and  Y.-J. Chang, “Efficient Broadcasting Protocols for 
Regular Wireless Sensor Networks,” Journal of Wireless Communications & 
Mobile Computing, Vol. 6, No. 1, pp. 35- 48, Feb. 2006.  
[2] C. –M. Chao, J.-P. Sheu, and I. –C. Chou, “An Adaptive Quorum-Based Energy 
Conserving Protocol for IEEE 802.11 Ad Hoc Networks,” IEEE Trans. on Mobile 
Computing, Vol. 5, No. 5, pp. 560- 570, May 2006. 
[3] J.-P. Sheu, K.-P. Shih, S.-C. Tu, and C.-H. Cheng, “A Traffic-Aware Scheduling 
for Bluetooth Scatternets,” IEEE Trans. on Mobile Computing, Vol. 5, No. 7, pp. 
872 – 883, July 2006. 
[4] C.-S. Hsu, Y.-C. Tseng, and J.-P. Sheu, "An Efficient Reliable Broadcasting 
Protocol for Wireless Mobile Ad Hoc Networks," Journal of Ad Hoc Network, 
Vol. 5, No. 3, pp. 299-312, April 2007.  
[5] J.-P. Sheu, S.-C. Tu, and C.-H. Yu, “A Distributed Query Protocol in Wireless 
Sensor Networks," Wireless Personal Communications, Vol. 41, No. 4, pp. 
449-464, June 2007. 
[6] J.-P. Sheu and J.-C. Cheng, “Pair-Wise Path Key Establishment in Wireless 
Sensor Networks,” Computer Communications (Special issue on Security on 
Wireless Ad Hoc and Sensor Networks), pp. 2365-2374, Vol. 30, Sep. 2007. 
[7] J.-P. Sheu, C.-M. Chao, W.-K. Hu, and C.-W. Sun, “A Clock Synchronization 
Algorithm for Multihop Wireless Ad Hoc Networks,” Wireless Personal 
Communications, Vol. 43, No. 2, pp. 185-200 Oct. 2007. 
[8] P. K. Sahoo, J.-P. Sheu, and K.-Y. Hsieh, “Power Control Based Topology 
Construction for Distributed Wireless Sensor Networks," Computer 
Communications (Special Issue on Network Coverage and Routing Schemes for 
Wireless Sensor Networks) pp. 2774-2785, Vol 30, Nov. 2007. 
[9] J.-P. Sheu, Y.-C. Chang, and G.-H. Song, “Logical Coordinate Assignment for 
Geographic Routing in Wireless Sensor Networks,” International Journal of 
Pervasive Computing and Communication, pp. 274- 288, Vol. 3, No. 3, 2007. 
43 
[2] P. K. Sahoo, J.-P. Sheu, and W.-S. Lin, “Dynamic Coverage and Connectivity 
Maintenance Algorithms for Wireless Sensor Networks,” Proceedings of the 
Second IEEE/Create-Net/ICST International Conference on COMmunication 
System softWAre and MiddlewaRE (COMSWARE), Bangalore, India, Jan. 2007. 
[3] J.-P. Sheu and H.-F. Lin, “Probabilistic Coverage Preserving Protocol with 
Energy Efficiency in Wireless Sensor Networks,” Proceedings of the IEEE 
Wireless Communications and Networking Conference (WCNC), Hong Kong, 
March 2007. 
[4] J. P. Sheu, S.-C. Tu, and C.-H. Hsu, “Location-Free Topology Control Protocol in 
Wireless Ad Hoc Networks,” Proceedings of the IEEE Wireless Communications 
and Networking Conference (WCNC), Hong Kong, March 2007. 
[5] J.-P. Sheu, M.-L. Ding, and K.-Y. Hsieh “Routing with Hexagonal Virtual 
Coordinates in Wireless Sensor Networks,” Proceedings of the IEEE Wireless 
Communications and Networking Conference (WCNC), Hong Kong, March 2007. 
[6] Y.-D. Cheng and J.-P. Sheu, “A Group-Based Multi-Channel MAC Protocol for 
Wireless  Ad Hoc Networks,” Proceedings of the 13th International Conference 
on Parallel and Distributed Systems (ICPADS), Hsinchu, Taiwan, Dec. 2007. 
[7] J.-P. Sheu, L.-J. Chang, and W.-K. Hu, “Hybrid Congestion Control Protocol in 
Wireless Sensor Networks,” Proceedings of the IEEE 67th Vehicular Technology 
Conference: VTC 2008-Spring, May 2008, Singapore. 
[8] J.-P. Sheu, J.-R. Jiang, C. Tu, “Anonymous Path Routing in Wireless Sensor 
Networks,” Proceedings of the IEEE International Conference on 
Communications (ICC 2008), May 2008, Beijing, China. 
[9] P. K. Sahoo and J.-P. Sheu, “Modeling IEEE 802.15.4 based Wireless Sensor 
Network with Packet Retry Limits,” Proceedings of the 2nd ACM International 
Workshop on Performance Evaluation of Wireless Ad Hoc, Sensor, and 
Ubiquitous Networks (PE-WASUN 2005), Oct. 2008, Montreal, Canada. 
[10] Y.-C. Chang, J.-R. Jiang, J.-P. Sheu, and H.-Y. Shih, “ADCA: An Asynchronous 
Duty Cycle Adjustment MAC Protocol for Wireless Sensor Networks,” 
Proceedings of the IEEE Global Communications Conference (GLOBECOM), 
Nov. 2008, New Orleans, USA 
[11] J.-P. Sheu, G.-Y. Chang, and Y.-T. Chen, “A Novel Approach for k-Coverage 
Rate Evaluation and Re-deployment in Wireless Sensor Networks,” Proceedings 
of the IEEE Global Communications Conference (GLOBECOM), Nov. 2008, 
New Orleans, USA. 
 
III. BOUNDARY NODE SELECTION PROTOCOL
In this section we propose the sequential (SBNS) and
distributed (DBNS) algorithms to select the boundary nodes
out of all deployed nodes along the border of the network. It is
to be noted that our SBNS algorithm can find boundary nodes
along the border area of the monitoring region, and it cannot
find boundary nodes around the sensing holes and user-defined
regions. Hence, we propose the DBNS algorithm to find out
boundary nodes along the border of the monitoring region.
A. Sequential Boundary Node Selection (SBNS) Algorithm
Initially, we assume that the sink node is assigned as a
starting node in the border area of the monitoring region,
which will be the first node to execute the SBNS algorithm.
Hence, the sink sets itself as a BN, and broadcasts the Re-
quest Info packet to its one-hop neighbors, which contains the
location information, sensing range and unique ID of the sink
and waits for the response. Upon receiving that packet, each
of its one-hop neighbors responds with a Reply Info packet,
which includes their location information, sensing range and
unique ID. Upon receiving the neighbor’s information, the sink
compares its location with location of its one-hop neighbors.
Since, sink is present along the border area of the monitoring
region, it has either maximum or minimum value in its x or y
coordinates. We assume that each node has a turning line to
find a BN among its neighbors. The turning line is assumed
to be horizontal on the right or left side of the sink, if it
has maximum (x0=Xmax) or minimum (x0=Xmin) value in
its x-coordinate, respectively or vertical on its top or bottom
side of the sink, if it has maximum (y0=Ymax) or minimum
(y0=Ymin) value in its y-coordinate, respectively.
The sink uses the right-hand rule [3] and rotates the turning
line along clockwise direction. The first node whose sensing
range intersects with the rotating turning line is selected as the
next BN. The selected BN is included in the Ack Info packet
and is broadcast by the sink. Besides, each BN that wants
to select a new BN assumes a turning line through the line
connecting to the previous BN and itself. This procedure is
repeated until the starting node is revisited. Thus, the nodes
those are initially selected as BNs change their role to Non-
BNs, thereby reducing the number of BNs. To maintain the
integrity among the BNs, each BN periodically sends a beacon
packet to its previous BN. If any BN cannot receive the beacon
packet from its related BNs, it executes the SBNS algorithm
to select a new BN among the existing neighbors.
B. Distributed Boundary Nodes Selection (DBNS) Algorithm
Normally, the DBNS algorithm is used to select the BNs
along the border of the sensing holes. It has three phases as
described below.
1) Initial Phase: In this phase, the sink broadcasts a
BN Start packet to its one hop neighbors with its location
information, sensing range and unique ID. Upon receiving
this packet, each node includes the same information and
rebroadcasts it to their one-hop neighbors. Then, each node
determines whether it is an extreme node or not based on its
maximum or minimum value in its x or y or both coordinates
as compared to its neighboring nodes. Those extreme nodes
declare themselves as BNs. Thus, each sensor node in the
monitoring region could be classified as BNs or Non-BNs after
the initial phase is executed.
2) Selection Phase: In this phase, each BN collaborates
with its neighbors to check the presence of a BN on its
left, another BN on its right side and selects some more
BNs out of the Non-BNs. To achieve this purpose, each
BN broadcasts a BN Msg packet to its one-hop neighbors.
However, there is possibility that the Non-BNs might have
received zero to multiple number of BN Msg packets from the
BNs. Accordingly, we classify our protocol into several cases,
as discussed below.
Case 1: If a Non-BN cannot receive any BN Msg packet
from the BNs within certain predefined time, the Non-BN goes
to power saving mode. This type of situation may happen for
the nodes located within the central region of the monitoring
area.
Case 2: If a Non-BN receives BN Msg packets from two
different BNs, the Non-BN chooses itself either to be a new BN
or still remains as a Non-BN, or becomes a forwarding node
between those two BNs. If those two BNs can communicate
and their sensing range overlaps with each other, the Non-BN
will not change it’s role.
If two BNs cannot communicate and their sensing range
overlaps with each other, the Non-BN directly sets itself as a
new BN. It is to be noted that if more than one Non-BN satisfy
this condition, those Non-BNs will exchange their location
information with their one-hop neighbors and the Non-BN
having shortest vertical distance between its position and the
line connecting to both BNs will set itself as the new BN.
If those two BNs can communicate with each other without
overlapping their sensing range, and that Non-BN’s sensing
range overlaps with either of those two BNs, then that Non-
BN sets itself as a new BN. If sensing range of those two
BNs overlaps, but they cannot communicate with each other,
the Non-BN having shortest vertical distance from the line
joining those two BNs, becomes the forwarding node between
them.
Case 3: If a Non-BN receives more than two BN Msg
packets from the BNs, the Non-BN considers each pair of its
nearby BNs to decide its own role.
Case 4: If any of the Non-BNs receives the BN Msg packet
from one of the BNs, the Non-BN responds to it with a
Non BN ID packet that contains its ID, sensing range and loca-
tion information. Upon receiving one to multiple Non BN ID
packets from the Non-BNs, the BN checks the current number
of BNs with whom it’s sensing range overlaps. If the BN has
already two BNs in its left and right hand side, whose sensing
range overlaps with it and both are connected to it, then it
ignores that Non BN ID packet and the corresponding sender.
If the BN finds only one BN with whom it’s sensing range
overlaps, it has to find out another one BN, whose sensing
range overlaps with it in its left or right side. Hence, it selects
one Non-BN sender as a new BN out of those Non-BN senders.
the monitoring region, it transmits the Entering Time(Te, ID)
packet to the sink.
Fig. 3. Illustration of the target detection algorithm
Similarly, if BN detects the target leaving the monitoring
region, it will send Leaving Time(Tl, ID) packet to the sink.
Since, each sensor node has the location information of the
sink, it can utilize some geographic routing protocols [4] to
transmit the Entering Time and Leaving Time packets to the
sink. As shown in Fig. 3, when the tiger enters into the
monitoring region, the BN X, first detects the target at time
Te, and it broadcasts the Detect(X) message to its neighbors.
Besides, it checks and finds its recording table is empty,
and then sends the Entering Time(Te, X) to the sink. After
the target leaves the BN X’s sensing range, it broadcasts the
Leave(X) packet and checks its recording table again. The time
during BN X broadcasts the Leave(X) packet to its neighbors;
Non-BN Y has already sent the Detect(Y) packet to the BN
X. So, BN X finds a non-empty field in its recording table
and therefore does not transmit the Leaving Time(Tl, X) to
the sink. Later, when the target turns back and leaves the
monitoring region, BN Z receives the Detect(Y) packet from
the Non-BN Y, and finds its recording table is non-empty.
Hence, when the BN Z detects the target, it does not transmit
the Entering Time(Te, Z) to the sink. Prior to leaving the BN
Z’s sensing range, the target must have received the Leave(Y)
packet from the Non-BN Y. Since, the Detect(Y) packet and
Leave(Y) packet coexist in the BN Z’s recording table, it
removes them form its recording table. After the target leaves
BN Z’s sensing range, it broadcasts the Leave(Z) packet to its
neighbors, and finds its recording table empty. Therefore, the
BN Z transmits the Leaving Time(Tl, Z) to the sink, as it is
the last sensor that detects the target leaving.
V. PERFORMANCE ANALYSIS
To evaluate the performance of the proposed boundary node
selection algorithms, the simulation is implemented in JAVA
programming language. Nodes are randomly deployed over
a monitoring region of different area, such as 100m×100m,
150m×150m, 200m×200m, and 250m×250m. The number of
deployed nodes varies from 1000 to 2500 nodes. Communi-
cation range for every sensor nodes is fixed at 8m, though the
sensing range of each node varies from 4m to 12m. Then, our
DBNS and SBNS algorithms are implemented for different
node numbers, area of the deployed region and compared
with the centralized algorithm, considering the control packets
overhead of our algorithms. In the centralized algorithm, we
assume that the sink has the locations of all nodes in the
network. It can find the nodes on the border area of the
monitoring region and chooses the nodes with larger sensing
range as the BNs. The performance metrics such as the number
of BNs is defined as the number of selected BNs to enclose the
monitoring region, the control packets overhead is defined as
the number of control packets to find and select the BNs and
the BN selection time is defined as the total time of finding
the entire BNs.
Fig. 4 represents a simulated final constructed boundary
using DBNS algorithm, when 2500 nodes are deployed ran-
domly over the monitoring region of size 100m×100m. The
gray dot represents the finally selected boundary nodes and
the black circle represents their corresponding sensing range.
Fig. 5 shows the possible number of boundary nodes those can
be selected by the centralized, SBNS and DBNS algorithms.
Here, the monitoring region is assumed to be 100m×100m,
and the communication range is fixed at 8m. The simulation
result demonstrates that when we increase the number of nodes
in the network, the number of selected BNs is decreased. This
is because increasing the number of nodes will increase the
probability of selecting the nodes with higher sensing range
and thereby decreasing the number of BNs. Therefore, the
monitoring region can be enclosed by fewer BNs with larger
sensing ranges.
Fig. 4. Simulated boundary nodes using DBNS algorithm
Fig. 5. Number of BNs using SBNS, DBNS, and centralized algorithm
Comparing the SBNS and DBNS algorithms, it is found
 WSNTB: A Testbed for Heterogeneous Wireless 
Sensor Networks  
 
Jang-Ping Sheu1, Chia-Jen Chang2, Chung-Yueh Sun2, and Wei-Kai Hu2 
1Department of Computer Science, National Tsing Hua University 
2Department of Computer Science and Information Engineering, National Central University 
sheujp@cs.nthu.edu.tw 
 
 
Abstract—In this paper, we design and implement a testbed to 
realize various experiments in heterogeneous wireless sensor 
networks. Our implementation includes hardware 
infrastructure and software framework. The hardware 
infrastructure consists of servers, gateways with converters, 
and sensor nodes in three-tier. Our testbed can support 
different sensor nodes with USB or RS232 interface. Users can 
experiment with real hardware resources and interactive with 
our testbed in real-time. Here, we deploy two kinds of 
self-designed sensor nodes, Octopus I and Octopus II, in our 
testbed. The Octopus sensor nodes are compatible with IEEE 
802.15.4/ZigBee standard for experiments. The software 
framework composes with three main layers: services 
interface layer, testbed core layer, and resource access layer. 
Our testbed allows users to customize their applications for 
specific sensor nodes and experiments locally with remote 
hardware resource. Users can freely choose the number of 
nodes and assign a period of processing time through our 
testbed website. By using our testbed, users can save lots time 
from creating an experiment environment, reduce the 
hardware expense, enhance the devices utilization rate, and 
fasten on the verification of experiment results. 
Keywords: Testbed, wireless sensor networks, Zigbee 
I. INTRODUCTION 
Wireless sensor networks (WSNs) consist of many 
sensing devices which can run individual applications and 
communicate with each other. Usually, we verify our 
network protocols by using simulations or experiments in 
real WSNs. In simulations, we cannot control precise packet 
timing, hardware interrupts, and real PHY/MAC layer 
events. Not all simulation results are equal to the real 
experiments. In real experiments, we have complex 
environment settings and resource sharing problems. Not 
every user has enough hardware devices to experiment on 
large-scale WSNs. In this paper, we propose a 
reconfigurable heterogeneous WSNs testbed called WSNTB. 
We divided the testbed architecture into three layers. The 
first layer is servers. The second layer is gateways with 
converters. The third layer is sensor nodes.  
In hardware infrastructure, our testbed provides 
connectors and gateways for sensor nodes. We use the 
standard interfaces to avoid the hardware binding problems. 
The converters help sensor nodes to convert serial data into 
TCP/IP packets. The gateways, a bridge between Internet 
and WSNs, have their own physical Internet Protocol (IP) 
address to communicate with sensor nodes. The gateways 
and converters are controlled by servers. Thus the WSNTB 
with gateways can support multiple WSNs over the Internet. 
In the sensor nodes, we use two kinds of self-designed 
sensor nodes in our testbed. The first one is called Octopus I 
based on the Atmel AVR architecture[1], and the other one 
is called Octopus II based on the Texas Instruments 
MSP430 architecture[15]. We deploy 34 sensor nodes 
(Octopus I and Octopus II) in WSNTB. The nodes are 
distributed over two laboratory rooms of our department 
building and the passage. In the WSNTB, the average cost of 
each node is about 50 US dollars. Since the cost is cheap, 
expending the testbed scale is easily. In software framework, 
our testbed supports the famous sensor operating system 
TinyOS [4] and our implemented operating system LOS 
[14]. We develop a middleware to help users to process their 
individual experiments within different sensor nodes and 
heterogeneous WSNs. Readers can find more information 
about WSNTB on the web at http://testbed.wsn.tw. 
The remainder of this paper is organized as follows. 
Section 2 describes the related works of WSN testbeds. 
Section 3 involves the design and implementation details of 
our testbed. The system operation and evaluation results are 
shown in Section 4. Section 5 concludes this paper. 
II. RELATED WORKS 
The WSN testbeds are useful and flexible to realize 
experiments for researchers. Users can use the testbeds to 
verify and prove their protocols such as power control, time 
synchronization, object tracking, routing, and security etc. 
Over the past few years, users usually create and setup the 
WSN environment by themselves. Then many complex 
steps and various environment factors will confuse users. In 
order to make users focus on their research, a number of 
testbeds are proposed by researchers. 
Emulab [9] is a network emulation testbed developed by 
Utah University. Users can develop, debug, and evaluate 
their own systems. They can do a wide range experiments 
such as pure emulation, 802.11 wireless experiments, 
sensor networks experiments, mobile wireless experiments, 
and NS-2 Simulation[11]. The testbed consists of 25 
MICA2 motes [4] connected with a serial port. Users can 
full control and debug these nodes. 
EmStar [6] is developed by University of California. 
This is a software platform for WSN experiments. They 
deployed a CENS heterogeneous testbed to prove and test 
their platform. The Linux-based framework consists of 39 
nodes. There are 26 Mica2 motes with MIB510 [2] 
programming board, and 13 Mica2 motes with the 
Stargate[2]. The server is connected to the MIB510 with 
serial port and the Stargate with Ethernet. They not only 
provide an integrated TinyOS environment but also a 
service protocol to run experiments easily. 
This work was supported by the National Science Council  under 
grant NSC 96-2218-E-007-016. 
338
_____________________________________ 
978 -1-4244-1866-4/08/$25.00 © 2008IEEE 
 Internet with IP address. Several testbeds use the 
customized hardware as the gateway, such as the Crossbow 
Stargate [2]. But the Stargate cannot run the usual PC 
program. If users want to develop their own applications on 
Stargate, they need to be training again. In order to solve the 
problem, we adopt the Soekris Engineering’s products with 
the standard x86 PC CPU and port PC operating system 
directly. We use the two versions of PC compatible single 
board computers: Soekris Engineering single board 
computers net4501 and net4801 as our gateways. Thus, it is 
flexible to use net4501 and net4801 to provide a whole 
range of different functions and run communication 
applications. 
We install the operating system either by preloading the 
Compact Flash storage, or by booting over the network 
using the PXE boot code in the standard BIOS. While we 
have a new experiment, we reinstall them via the Ethernet 
to avoid any security risks. They are not expensive but 
support standard protocol, common interfaces, and popular 
operating systems. That using the gateway will help users to 
develop their programs fast and easily. Finally, we use the 
ZyXEL ES-108A Ethernet switch as LAN switch to build 
our testbed Ethernet backbone. The ZyXEL Ethernet Switch 
offers advanced VIP ports to provide high priority 
bandwidth. So we can let sensor nodes use normal port and 
the backbone lines use the VIP ports. The network for 
expansion becomes very rapidly and handily. 
B. Software Implementation 
In this section, we want to describe the software 
framework of WSNTB. The software framework of WSNTB 
includes services interface layer, testbed core layer, and 
resource access layer as shown in Fig.2. 
 
Figure 2. The software framework of WSNTB  
The service interface layer let users access our web 
services from the website. We allow users to control and 
interactive with the testbed via web services. The service 
interface layer consists of web services and TCP/IP 
redirector. Web services will dispatch the jobs in testbed 
core layer. TCP/IP redirector is the kernel of local mode. In 
the testbed core layer, there are real-time control protocol, 
local mode, and background agents. The real-time control 
protocol and local mode are very important components in 
WSNTB we developed. Real-time control protocol is a new 
process in our testbed. In the past, users can only load 
program into sensor nodes by schedule and waiting the 
experiment results. But we allow users to assign a period of 
time for their experiments. During the experiment period, 
users still receive packets form individual notice and have 
the domination of controlling our testbed, including sending 
commands, getting response, or uploading files into sensor 
nodes in real-time. Background agents are dealing with 
users’ requirements in running experiments. Users can 
interactive with sensor nodes under TinyOS and collect 
experiment results just like that users have the whole 
hardware infrastructure to themselves. The function of local 
mode can help users to access hardware resources directly. 
Users can develop their programs and even collect results at 
their original TinyOS environment. In the resource access 
layer, we provide the data access controller to save files and 
database records. In security, we adopt the private IP 
address in communication with database and storage. 
Hardware controller can assist the testbed core layer to 
detect the living hardware, its status, and reset it. The 
software framework in WSNTB also has event notification. 
We can detect existing events and response events correctly. 
When users do their experiments, they can get real-time 
messages and interactive with the devices. 
Mapping to the real WSN environment, the 
implementation detail is shown in Fig.3. We divide the 
WSNTB into 3-tier architecture. The first tier of WSNTB 
consists of the web server, emulating server, and database 
server. The three servers are connected with the Ethernet 
backbone. But only the web server has its public IP address 
for public access, the others own their private IP address for 
security. Internet users can only connect to web server to 
avoid any illegal access. 
We have installed Apache with PHP as web and MySQL as 
database in all three servers. They are open source software 
and can execute in cross operating systems. These servers 
are following HTTP protocol. Then, we deploy different 
software packages into individual server. In web server, we 
use WYSIWYG Editor as the basic text editor and 
phpMyAdmin as database management interface for 
MySQL. We developed the following modules: 
management system and user interface. In the management 
system module, we provided the online experiment, 
environment status, feedback functions, and the map. In the 
user interface, we provided the testbed documents, data 
downloads, and the user register functions. WSNTB is public 
for operation and users can register their accounts via web 
server. 
The emulating server plays an important role in online 
experiment, especially in local mode and real-time control 
protocol. We install Microsoft VB and Java runtime library 
in the emulating server. The Java runtime library supports 
TinyOS and Cygwin environment and the VB library 
supports windows GUI applications. The Virtual COM is 
software for users to create virtual serial port in local 
computer. By using the software, users can use local mode 
to access sensor nodes directly in WSNTB. AVR tools are 
used for writing the image of AVR series and 
reprogramming the boot loader program for our sensor 
nodes. We also deploy two modules, system control and 
hardware control, in the emulating server. In system control 
modules, we provide the local mode, job queue, result 
340
 are the Internet and Ethernet backbone, Ethernet switches, 
and the gateways with converters. The third tier of WSNTB 
means the terminal nodes. In security issue, we build three 
firewalls on the Internet and Ethernet backbone. The first 
firewall built in front of the Internet router to block the 
illegal incoming connections from remote users. Then the 
two firewalls built on each WSN backbone to protect 
network environment.  
The gateways are the bridges over our network 
environment. In our testbed, we deploy the gateway with 
public IP address and allow users to access the gateway via 
the direct connections. We use the single board computer as 
our gateway. The single board computer can replace the 
specific Ethernet gateway hardware such as Stargate. 
Gateways can communicate with WSNs and Internet. We 
installed Linux as our operating system and porting TinyOS 
on the gateway. We assign private IP address for each 
converter. Through the Ethernet connections, the server can 
control individual converter directly and avoid the Internet 
illegal access. This solution can make sure receiving the 
experiment data correctly. The nodes execution environment 
is composed of self-made hardware, firmware, and software. 
We developed a boot loader to receive programs form the 
gateways or converters. The library of sensor operating 
system will pack with applications.  
In this section, we present the main system architecture, 
hardware infrastructure and software framework, and the 
implementation details. The detail system operations will 
describe in next section. 
IV. SYSTEM OPERATIONS 
A. System Menu 
We design and implement several menu items on 
WSNTB. Users can use these menu functions from our 
website as shown in Fig.4. We display the users’ menu 
according to their permission. For example, the guest users 
just can see the basic menu items. The authorized users not 
only see the basic menus but also their own menu. In 
addition, the administrator can see the administrator menu. 
Our testbed has the top level menus and submenus. The top 
level menus consist of system architecture, environment, 
information, services, my workspace, experiments, 
configuration, device maintain, information maintain, and 
system maintain. After users login, they will get their own 
menus. Each normal user has basically four top level menus: 
system architecture, environment, information, and services. 
The authorized user has additional my workspace menu for 
experiments. The administrator has the extra five menus in 
top level for administrative purpose. 
In system architecture, we introduce WSNTB and show 
the hardware infrastructure and software framework. In 
environment menu, we give the environment status of 
WSNTB. Users can view the location of testbed map and 
status of hardware devices. And we will show the detail of 
hardware devices. Users can check anytime as they want to 
use them. The hardware devices include nodes, converters, 
gateways, and the servers. In information menu, users can 
obtain the latest news of WSNTB. There are references to 
WSNTB and publications. Users can contact with our 
testbed project director and staffs. 
In service menu, there is a service center for users. If 
users have any question about WSNTB, users can use the 
feedback item to tell us their problems. We will help users 
to solve the problems. Also users can subscribe our e-letter 
to get the news immediately. 
My workspace menu is only for authorized users. When 
user’s register is legal, user can do his/her experiment. In 
my workspaces menu, it is the core applications of WSNTB. 
Especially for the experiments menu, there is an experiment 
flow for users. First, users need to create a new experiment 
task or choose the existed experiment one from the code 
box, and choose which nodes and gateways they want to use. 
Users can use the code box to create and maintain their 
program. If users want to use the program again in the new 
experiments, they can load the programs form the code box. 
Finally users have to decide when to run the experiments. 
 
Figure IV. The screenshot of WSNTB 
As experiments finished, users can retrieve and download 
results. If users use the local mode, we allow users to 
configure the TCP port setting and access testbed’s 
hardware resource directly. There is a space for java code 
saving. We usually use the TOSBase to listen packets. The 
listen program is a java program in TinyOS. So we provide 
the java code in the java box. Then users can modify and 
compile the code. When a new experiment starts, users can 
choose the code to run from java box. Besides, users can 
interactive with sensor nodes in real-time by using the 
real-time control protocol. 
A sysadmin can retrieve the experiment files, control the 
job schedule, and modify the testbed’s structure. There is a 
342
出席國際學術會議心得報告 
                                                             
計畫編號 NSC 95-2221-E-008-019 
計畫名稱 設計與實作智慧型服務無線感測網路--子計畫一:智慧型感測點與媒體存取控制協定之設計與實作(2/3) 
出國人員姓名 
服務機關及職
稱 
姓名:許健平 
服務機關:國立中央大學資訊工程學系 
職稱:教授 
會議時間地點 時間:96/7/2 日-96/7/5 日 地點:新加坡 
會議名稱 Fourth International Conference on Wireless and Optical Communications and Networks (WOCN 2007) 
發表論文題目 Boundary Node Selection and Target Detection in Wireless Sensor Network 
 
一、 參加會議經過 
    第四屆國際無線與光學通訊暨網路年會（WOCN 2007）於今年的七月一日
至七月五日在新加坡的 Grand Hyatt 飯店會議中心舉行。該會議由 IEEE 
Computer Society 所主辦，主要目的是聚集世界各地大學、產業界、及政府單位
從事有關網路通訊研究的專家學者於一堂，共同切磋，並交換其在無線網路通
訊領域中的研究心得以及最新知識。今年會議一共收到兩百多篇論文，經過評
審之後一共接受了約一百篇論文。這些論文涵蓋了無線網路技術中 Phy/MAC、
Networking 與 Applications and Services 等領域。 
會議分三天舉行，總共 2 個 technical sessions，每個 session 各有 1 個議題
同時舉行，有 2 個 keynote speeches 及 1 個 Panel Session。這些題目包含了未來
無線通訊技術的介紹、比較、應用與趨勢走向。每一個演講者都邀請了該領域
□ 赴國外出差或研習 
□ 赴大陸地區出差或研習 
■ 出席國際學術會議 
□ 國際合作研究計畫出國 
心得報告 
計 畫 名 稱 無線隨意及感測網路技術 計 畫 編 號 94B5003SB 
報 告 人 
姓 名 許健平 
服 務 機 構
及 職 稱清大資訊工程學系教授 
會議/訪問時間 
 地點 
時間: 15 July, 2008 ~ 16 July, 2008 
地點: 蘭州、大陸 
會 議 名 稱 The First IEEE International Conference on Ubimedia Computing and Workshops (Umedia 2008) 
發表論文題目 WSNTB: A Testbed for Heterogeneous Wireless Sensor Networks 
 
一、主要任務摘要（五十字以內） 
 
本人於此國際學術會議發表研究計畫之論文成果，並擔任相關領域議程主席，與各
國專家學者進行討論與分享研究成果，並考察中國大陸在資訊產業方面的發展及其基
礎建設。 
 
二、對計畫之效益（一百字以內） 
 
此研討會的主題，主要在於資訊領域方面的技術及其應用，包含無線網路、無所不
在計算、影像處理與人機介面、網路安全與管理、多媒體與軟體工程等。此次會議除
了發表研究成果外，也可以趁機了解中國大陸在此一領域的研究進展，對於促進未來
海峽兩岸學術方面的交流有很大的幫助。 
 
三、經過 
 
Umedia 2008於今年的七月十五日至七月十六日，在中國大陸的蘭州大學會議中心舉
行。該會議由IEEE Computer Society所主辦，主要目的是聚集世界各地從事有關無線
網路、影像處理與人機介面、多媒體等的專家學者於一堂，共同切磋，並交換其在這
些領域中的研究心得以及最新知識。今年會議經過評審之後一共接受了約一百篇論
文。這些論文涵蓋了無線網路、無所不在計算、影像處理與人機介面、網路安全與管
理、多媒體與軟體工程等領域。此次大會一共邀請六位國內外著名學者，給予專題演
講。此外共有24個sessions分別進行，每個session 報告4篇論文。我們的論文是在第
一天的上午，論文題目為” WSNTB: A Testbed for Heterogeneous Wireless Sensor 
Networks”，參與會議者皆聚精會神的聽取報告，演講者報告完畢後，聽眾與演講者互
相討論。本人亦主持下午的一場會議。在第一天的晚上7:00大會亦安排了一場晚宴，所
有參與會議者，可在晚宴上自由討論及彼此交換意見。 
 
四、心得 
 
本次大會兩天共發表96篇會議論文及六場Keynote Speech，主辦單位從邀稿到開會場
