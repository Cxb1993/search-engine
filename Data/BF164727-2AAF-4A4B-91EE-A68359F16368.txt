超長指令集處理器的看門狗處理器的設計，所以在
本研究將提出完整的超長指令集處理器標號監督
機制（VLIW Signature Monitoring）完整架構。 
2.超長指令集處理器技術 
圖 1 為與本研究整合的超長指令集處理器的
長指令格式（long instruction format）: 一道長指令
總共包含六個短指令以及六個旗標，I1~I6 均為 32
位元短指令，長指令內的旗標大小皆為 1 位元，旗
標是用來決定指令平行運算程度。 
圖 1：超長指令集處理器的長指令格式 
本研究所引用的超長指令集處理器技術將處理器
分為 IF&ID、DRF、EXE、MEM、WB 五級，其
硬體架構如圖 2 所示。圖 2 所示的超長指令
集處理器架構，為一顆含有容錯技術的超長指令集
處理器。超長指令集處理器之容錯技術是針對運算
邏輯單元加入容錯保護機制。超長指令集處理器之
一道長指令可包含三道運算邏輯指令與三道記憶
體存取指令，而超長指令集處理器於 EXE 級，加
入一個額外的 ALU 單元，並且利用比較器與 TMR
觀念進行錯誤偵測。當一個時脈週期只有一道運算
邏輯短指令時，利用 TMR 觀念來進行錯誤偵測;
二道運算邏輯短指令時，利用比較器觀念; 三道運
算邏輯短指令必須分成兩個時脈週期完成三道運
算邏輯短指令運算以達到容錯目的。 
 
圖 2 超長指令集處理器硬體架構 
3.超長指令集看門狗處理器 
3.1 參考標號格式 
 超長指令集看門狗處理器的參考標號格式
（reference signature format）如圖 3所示，其中 BL
欄位為指令區塊長度（Block Length, BL），其意義
是告知看門狗處理器該指令區塊總共有幾道短指
令。因為 BL 欄位為 5 位元，所以當指令區塊長度
大於 32 道短指令必須進行硬切動作。而垂直參考
標號（Vertical Reference Signature）欄位大小為 11
位元，垂直標號的產生是將指令區塊透過垂直標號
演算法計算所得。最後一個欄位為 16 位元的水平
參考標號（Horizontal Reference Signature），水平
標號其目的在於即時錯誤偵測。由於水平參考標號
欄位大小有限，所以只對指令區塊前 16 道短指令
I1 Flag I2 Flag I3 Flag I4 Flag I5 Flag I6 Flag
 2
指令記憶體資料保護與控制流程錯誤偵測。但是這
對看門狗處理器的錯誤偵測潛伏時間會過長，因此
提出水平標號演算法以降低錯誤偵測潛伏時間。水
平標號是利用過渡垂直標號（intermediate vertical 
signature），結合parity來達到同步偵測的觀念。在
一個參考標號內，沒有增加記憶體的情況下，大大
的縮短了錯誤偵測潛伏時間。 
3.4看門狗處理器 
 在超長指令集看門狗處理器設計上必須特別
注意指令平行技術特性、如何取得每一個指令區塊
的參考標號、長指令型態所組成的指令區塊與如何
將長指令裡面的短指令正確的分配到垂直與水平
標號產生器，來計算出垂直與水平的標號並與參考
標號作比較來偵測出錯誤的發生。本研究所提出的
看門狗處理器為了配合超長指令集處理器的平行
高速運算能力，使用了管線技術也使用兩組垂直標
號產生器V1,V2，來提升看門狗處理器的運算速
度，這裡的V1,V2表示的是3.2節的垂直標號狀態轉
換函式。 
3.5看門狗處理器短指令分配及標號計算
演算法 
在說明超長指令集看門狗處理器短指令分配及標
號計算演算法之前要先定義以下的符號： 
dis_v：所代表的意義為，所要運算的指令區塊，
其第一道長指令中有幾道短指令需要做指令分配。 
sig_number：所代表的意義為此長指令內含有幾個
參考標號，如為一個則 sig_number 設為 0，兩個則
設為 1。 
fref_sig：所代表的意義為如果長指令中的第六道短
指令為參考標號則fref_sig＝1，否則為0。 
sbl：所代表的意義為指令區塊還有多少短指令還
沒被執行。 
In,p：指令區塊中第n道長指令的第p道短指令，
1≦p≦6。 
H（I）：水平標號產生函式。 
In, 1 Sig I1, 1 I1, 2 I1, 3 I1, 4
(a) 
In, 1 Sig1 I1, 1 I1, 2 I1, 3 Sig2
(b) 
圖4：符號說明示意圖 
 透過圖4說明如何正確使用先前定義之符
號。假設圖4（a）為正在運算指令區塊的最後一道 
圖 5：指令分配流程圖
長指令，則sbl=1，而且此最後一道短指令一定是
跳躍指令。假設其為｀conditional branch＇指令，
因為VLIW處理器處理｀conditional branch＇指令
是先猜測不跳，所以其它的符號將被設為：
dis_v=4、fref_sig=0、sig_number=0。圖4（b）為
一道長指令被嵌入兩個參考標號; 假設圖4（b）為
上一個指令區塊的跳躍指令，所跳躍到的長指令。
我們會先檢查第一個指令區塊，從In,3開始，符號
 4
        V1（I2,5，I2,6），V2（idle，idle）        
        H （I
         V1（I
2,6） 
            sbl = sbl – 6 
        end case； 
      fref_sig Å 0； 
      Jump to step2； 
    Else /* fref_sig =0*/ 
      case sbl is/*指令分配從In-1,6開 
                    始＆update sbl */ 
       when 1 
        V1（In-1,6，In,1），V2（idle，idle）        
        H（I
     step3：If vertical signature check is ok then 
n,1） 
        sbl = sbl – 1 
       when 2 
        V1（In-1,6，In,1），V2（In,1，In,2）         
        H（In,1），H（In,2） 
        sbl = sbl – 2 
       when 3 
        V1（In-1,6，In,1），V2（In,1，In,2）         
        H （In,1），H（In,2） 
        V1（In,2，In,3），V2（idle，idle）         
        H （In,3）                          
        sbl = sbl – 3 
       when 4 
        V1（In-1,6，In,1），V2（In,1，In,2）         
        H（In,1），H（In,2）                  
        V1（In,2，In,3），V2（In,3，In,4）         
        H（In,3），H（In,4） 
        sbl = sbl – 4 
       when 5 
        V1（In-1,6，In,1），V2（In,1，In,2）         
        H（In,1），H（In,2） 
        V1（In,2，In,3），V2（In,3，In,4）         
        H（In,3），H（In,4） 
        V1（In,4，In,5），V2（idle，idle）         
        H（In,5）                 
        sbl = sbl – 5 
       when others 
n-1,6，In,1），V2（In,1，In,2）         
        H（In,1），H（In,2）  
        V1（In,2，In,3），V2（In,3，In,4）         
        H（In,3），H（In,4） 
        V1（In,4，In,5），V2（In,5，In,6）         
        H（In,5），H（In,6） 
        sbl = sbl – 6 
      end case 
      Jump to step2； 
    End If；/* fref_sig */ 
            error signal Å 0； 
                Jump to step1； 
              Else 
                error signal Å 1； 
          End If； 
End If；} 
 為了簡化上面的演算法，我們省略了在每一
個H（I）：水平標號檢查後面需加上判斷水平標號
的結果，如果有錯則error signal Å 1 的式子。指令
分配及標號計算演算法必須得知第一道長指令內
含有幾個參考標號（如果含有 2 個參考標號，必須
對同一道長指令內不同的指令區塊進行指令分配
及檢查）；判斷長指令中的第六道短指令是否為參
考標號（假設參考標號在第六道短指令，則下一道
長指令分配將從I2,1開始分配，假設在其他位置從
In-1,6開始分配）；利用dis_v符號進行指令分配與設
定sbl符號（假設長指令含有 2 個參考標號則必須
進行 2 次指令分配與設定sbl符號）。在完成第一道
長指令分配，利用判斷sbl符號來判斷指令區塊是
否結束，結束則比對垂直標號，未結束則以fref_sig
符號選擇指令分配與更新sbl符號。在完成指令分
配後，利用已更新過的sbl符號判斷指令區塊是否
結束。因為本研究整合的超長指令集處理器對
branch指令是預測不跳，所以當sbl符號歸 0 必須比
對標號與利用同一道長指令進行下一個指令區塊
的運算，而如果程式區塊未結束，則持續指令分配
直到sbl符號變成 0 為止。 
 6
I6
I5
I4
I3
I2
圖 6：看門狗處理器短指令分配電路 
 
                                圖 7:垂直標號運算單元及檢查電路 
 8
觸發訊號。 
5.模擬實驗與結果分析 
 本章節將單獨對不同測試程式做相同灌錯模擬
實驗，最主是要探討不同程式特性對偵錯涵蓋率、偵
錯潛伏時間與記憶體空間花費的影響。並且提供完整
看門狗處理器的面積與速度，作為往後設計參考依據。 
5.1程式指令區塊長度分析與測試程式選擇 
我們選擇兩種不同型態測試程式： 
型態一：所需要的特性為程式指令區塊長度特別短，
且 branch 指令跳躍情況非常平凡的程式特性。選用
heapsort 測試程式 
型態二：型態二之測試程式所要的特性為指令區塊長
度特別長，且branch指令很少出現在測試程式中的程式
特性。選用IDCT測試程式 
5.2記憶體空間花費 
 由於系統加入了看門狗處理器，系統必須將參考
標號嵌入至記憶體中，進而造成記憶體空間負擔。由
表1可知，因為heapsort程式區塊長度都很短，相對地，
必須嵌入較多的參考標號。而IDCT測試程式因為程式
區塊長度都比較長，所以會嵌入較少的參考標號。 
18.18%heapsort
4.5%IDCT
Memory overheadprogram
 
表1：記憶體空間負擔結果 
5.3硬體空間花費 
由於系統加入了標號監督機制，必須負擔看門狗
處理器硬體面積，表2為硬體空間花費結果表，表中
VLIW數據是沒有容錯系統的超長指令集處理器的面
積跟速度。製程為UMC 0.18μm。表中看門狗處理器
數據包括標號產生電路與解決超長指令集標號監督機
制的特定電路，共花費7.44%的硬體空間，來達到控制
流程錯誤與指令記憶體的容錯機制。 
7.44%overhead
1.87815457Watchdog 
7.8510948196VLIW
SpeedAreaprogram (ns)(um2)
 
表2：硬體空間花費結果表 
5.4效能下降 
 在過去管線式看門狗處理器一遇到參考標號，系
統就必須閒置，因此造成系統效能下降。而此種情況
並不會出現在超長指令集看門狗處理器，因為超長指
令集處理器一次擷取一道長指令，所以系統可以直接
分配其他的短指令給超長指令集處理器運算，因此超
長指令集看門狗處理器並不會造成電腦系統效能下
降。 
5.5偵錯涵蓋率、偵錯潛伏時間實驗規劃 
 在硬體實現部分，是透過硬體描述語言實現，模
擬灌錯平台建立在RTL層級。每次的模擬實驗只灌一
個錯，一個錯持續5個VLIW時脈週期。超長指令集看
門狗處理器能偵錯範圍，包括：偵測控制流程錯誤與
指令記憶體資料保護，所以在程式灌錯模擬實驗，細
分成為二個不同目標：目標1（target 1）：指令記憶體
資料保護模擬實驗，直接透過硬體描述語言將多重位
元錯誤（multiple-bit error）注入在指令記憶體的輸出
端，模擬指令記憶體內部資料出錯。 
目標2（target 2）：偵測控制流程錯誤模擬實驗，將單
一位元錯誤（single-bit error）注入在有可能造成超長
指令集處理器控制流程錯誤之訊號線或位址產生元
件，如程式位址計數器和位址產生器。 
5.6不同灌錯地點模擬實驗比較 
 本節將探討，當錯誤發生在指令記憶體與控制流
程以及程式特性，對看門狗處理器偵錯涵蓋率與偵錯
潛伏時間的影響與差別，表3表示實驗的模擬結果。 
35NDET
1.632.23EDL
0.9960.992EDC
target2target1heapsort
013NDET
1.974.2EDL
10.981EDC
target2target1IDCT
 
表3:綜合實驗模擬結果 
表3的上方是針對heapsort，執行1500次灌錯實
驗，所得到的結果。因為heapsort測試程式指令區塊都
很短，所以每道短指令可分得較多的水平參考標號位
元，進而有較理想的偵錯潛伏時間與偵錯涵蓋率，且
別名（aliasing）發生的機會也會較低。但是另一方面
發生跳到不正確的指令區塊起頭如4.1節所描述的情況
也會比較高。我們先從Target2的EDC(error-detection 
coverage)欄位開始看起，Target2為模擬控制流程錯
誤。在表3中，3次未偵測到的錯誤(Not Detect, NDET)
都是發生在超長指令集處理器跳躍發生，且剛好跳到
不正確的指令區塊起頭，而此時4.1節所用的技術也恰
巧查不到這種錯誤。接下來探討heapsort測試程式的
Target 2的偵錯潛伏時間，在EDL（ error-detection 
latency）欄位所顯示數據是以VLIW時脈週期為單位，
指令區塊長度短，其水平標號技術分得較多水平參考
標號，因此EDL較短。 
 表3的Target1灌錯模擬實驗裡，灌錯位置位於指
令記憶體的輸出端，而在指令記憶體的資料保護模擬
實驗注入最多5位元多重位元錯誤，在700次灌錯模擬
實驗，結果顯示偵錯涵蓋率EDC為0.992，從表3得知錯
誤被漏掉的5次，都是發生在別名情況。 
 接下來將探討為何Target1偵錯潛伏時間會大於
Target2偵錯潛伏時間？Target2的錯誤為控制流程錯
誤，所以錯誤的長指令一進來就馬上可以透過水平標
號技術來偵測，而在Target1是一定要等到長指令中有
錯誤的短指令進到超長指令集標號監督機制才有可能
被查到，所以Target1的偵錯潛伏時間會比Target2還要
長一點。 
 10
