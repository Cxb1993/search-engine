析、惡意行為分析、雲端虛擬化技術、實驗觀測網路 
英 文 摘 要 ： With the growth of Internet and mobile devices, cloud 
service had become a key point of networking 
technologies. The trend makes security issues more 
and more important. This project proposes an 
integrated solution including four sub-projects to 
research and design a secure cloud platform. Prof. 
Wen-Guey Tzeng leads the sub-project to design a 
secure muti-functional cloud storage system. Prof. 
Shiuhpyng Shieh leads the sub-project to develop a 
dynamic analyzing cloud against complex malwares. 
Prof. Yu-Lun Huang leads the sub-project to develop 
an observation cloud for security experiments. Prof. 
Yu-Sung Wu leads the sub-project to integrate IDS/IPS 
into Xen Hypervisor. The integrated solution proposed 
by this project not only provides correctness, 
privacy, and other security functions for cloud 
storage. Its IPS also provides a first line of 
defense against incoming attacks. Moreover, it has 
the ability to dynamically analyze complex malicious 
behaviors using the computing power of a private 
cloud and feed the signature of the attacks back to 
the IPS. Furthermore, the complex attacks can be 
securely experimented in the observation cloud. 
In conclusion, this project constructs a cloud 
platform with four main sub-systems: a set of 
efficient solutions to the security problems in cloud 
storage systems, a malware analysis system based on 
cloud computing, an IDS/IPS-integrated Xen 
Hypervisor, and an observation cloud for security 
experiments. New theories were proposed and the 
related systems were implemented. This project also 
directly contributed to various cooperative plans 
between the industry and the academic. The 
cooperative plans also show that this project is 
valuable and feasible. 
 
英文關鍵詞： cloud computing, cloud storage, intrusion detection, 
intrusion prevention, malware analysis, taint 
analysis, virtualization 
 
II 
 
摘 要 
 
在網路與行動裝置的催化下，雲端服務已是 IT 產業的重點技術，因此雲
端的安全問題就顯得格外重要。本計畫延續之前與美國柏克萊大學研究團隊在
虛擬機器資安跨國合作研究之經驗與成果為基礎，提出創新的方法並建構前瞻
性雲端安全儲存、防護、行為分析與觀測平台。此平台包含四個子計畫：曾文
貴教授所主持的子計畫「支援多樣功能之雲端資料安全儲存」、謝續平教授所
主持的子計畫「基於機器碼之 Windows 惡意程式行為分析雲端平台」、黃育綸
教授所主持的子計畫「設計與實作基於雲端技術之安全實驗觀測網路」、與吳
育松教授所主持的子計畫「基於 Xen Hypervisor 之即時雲端環境入侵偵測與反
制」。本平台不但能提供雲端儲存的安全性、正確性及其他功能性，亦可透過
即時入侵偵測及反制系統確保整個雲端平台不會受到一般的網路攻擊，並能利
用雲端的運算能力動態分析經過變形、隱匿、加殼等處理的複雜攻擊行為。本
計劃更提供一個具有仿真性與即時性的實驗觀測網路平台，不但可直接取得接
近硬體層級的網路流量資訊、模擬受到攻擊的網路狀態、更能讓需要改變的網
路拓樸即時生效。 
本系統整體運作方式簡述如下：來自於 Internet 的連線將會先經過即時
雲端環境入侵偵測與反制子系統，由此子系統負責針對已知的攻擊類型進行防
阻，以提供一個安全的雲端平台環境。而建構在此雲端平台之上的雲端資料安
全儲存子系統可保證儲存資料的正確性與私密性，並可提供加密後資料的比對
搜尋與再授權，並藉此提供各種應用功能。針對已儲存在此雲端儲存系統中的
各類型檔案，本系統亦提供惡意程式行為分析子系統。有別於傳統的特徵式分
析，此子系統著重在惡意程式動態執行階段的行為模式分析，以找出可能惡意
行為之特徵，並回饋至第一線的即時雲端環境入侵偵測與反制子系統。較為複
雜的攻擊行為也可利用本計畫所開發的實驗觀測網路平台進行實驗與觀測，不
但有助於針對複雜行為提供進一步的分析，其高度隔離的環境亦可確保具危險
性的實驗不會干擾到其他系統的正常運作。 
綜合來看，本計畫建構一個包含多面向的雲端安全服務平台，針對雲端
資料安全儲存、即時雲端環境入侵偵測與反制、惡意程式行為動態分析、仿真
性網路實驗觀測平台等領域提出理論與實務創新的構想與設計，且相關研究成
果已與多家知名廠商與政府機構簽訂技術合作與產學計畫，足見其實用價值。 
 
 
關鍵詞：雲端計算、雲端儲存、入侵偵測、入侵預防、動態汙染分析、惡意行為分析、
雲端虛擬化技術、實驗觀測網路 
 
IV 
 
 
目 錄 
 
壹、 計畫內容及目的 .................................... 1 
一、 前言及背景說明 .................................. 1 
二、 文獻探討與相關研究 .............................. 7 
三、 計畫目的 ....................................... 14 
四、 研究方法 ....................................... 18 
貳、 計畫項目完成度 ................................... 35 
參、 計畫成果 ......................................... 40 
一、 產學合作計畫 ................................... 40 
二、 學術貢獻 ....................................... 42 
三、 系統建置 ....................................... 45 
肆、 技術方案優越性 .................................. 111 
伍、 結論與展望 ...................................... 118 
陸、 參考文獻 ........................................ 122 
 
VI 
 
圖表三十八：虛擬碼列表 ................................................. 82 
圖表三十九：secmap.rb 之虛擬碼 .......................................... 82 
圖表四十：startNUTCH.sh 之虛擬碼 ........................................ 84 
圖表四十一：NUTCH 之原始碼物件以及 NUTCHSLAVE.rb ........................ 85 
圖表四十二：putToRedis.rb 之虛擬碼 ...................................... 86 
圖表四十三：putToCassandra.RB 之虛擬碼 .................................. 87 
圖表四十四：AnalyzerInvoker 之虛擬碼 .................................... 87 
圖表四十五：invokeAnalysis.rb 之虛擬碼 .................................. 88 
圖表四十六：getTaskID.rb 之虛擬碼 ....................................... 89 
圖表四十七：common.rb 之內容 ............................................ 90 
圖表四十八：getFileContent.rb 之虛擬碼 .................................. 90 
圖表四十九：getReportFromCassandra.rb 之虛擬碼 .......................... 91 
圖表五十：saveToCassandra.rb 之虛擬碼 .................................. 92 
圖表五十一：每 50 分鐘分析個數直方圖。 .................................. 93 
圖表五十二：時間-分析個數關係圖。 ...................................... 94 
圖表五十三：分析過程之紀錄檔案截圖 ..................................... 95 
圖表五十四：放分析工做至惡意程式分析雲端平台 ........................... 95 
圖表五十五：網頁爬取子系統之紀錄截圖 ................................... 96 
圖表五十六：實際的惡意樣本分析報告 ..................................... 96 
圖表五十七：攔截系統呼叫流程圖 ......................................... 97 
圖表五十八：linux/arch/x86/kernel/entry_64.S ........................... 97 
圖表五十九：xen/arch/x86/mm/p2m.c ...................................... 98 
圖表六十：xen/arch/x86/hvm/vmx/vmx.c ................................... 98 
圖表六十一：監控系統呼叫(NtOpenFile)執行結果 ........................... 99 
圖表六十二：記憶體內容物件讀取流程圖 .................................. 100 
圖表六十三：Guest VM 部分記憶體區塊內容 ................................ 101 
圖表六十四：Guest VM 部分記憶體內容轉換結果 ............................ 101 
圖表六十五：利用 Xen API進行 EPT Entry 權限管理 ........................ 102 
圖表六十六：未限制 Guest VM存取 memroy block ........................... 102 
圖表六十七：取得目標 process資訊(name$pid$cr3) ........................ 103 
圖表六十八：透過 guest pagetable找到 process 所屬 gfn資訊 .............. 103 
圖表六十九：限制 Guest VM存取 memroy block ............................. 103 
圖表七十：qemu監控磁區流程圖 .......................................... 104 
圖表七十一：tools/ioemu-qemu-xen/vl.c ................................. 104 
圖表七十二：tools/ioemu-qemu-xen/fs-ntfs.c ............................ 105 
圖表七十三：tools/ioemu-qemu-xen/fs-ext2.c ............................ 105 
圖表七十四 Xen Hypervisor 結合 Snort架構圖 ............................. 106 
圖表七十五：ClamAV 即時防護系統概念圖 .................................. 107 
圖表七十六：ClamAV 即時防護系統架構圖 .................................. 107 
圖表七十七：前端 Web操控介面 .......................................... 108 
1 
 
壹、  計畫內容及目的  
一、  前言及背景說明 
在技術發展史上來看，分散式系統已經有初期的雲端概念，然而當時並沒有普及的網
路架構與隨身可上網的裝置作為基礎，現今完善的網路環境則啟動了雲端技術的蓬勃發
展。整個雲端的架構可以說是將早期的大型主機與終端機架構中主機到終端機的連線改為
網路媒介，另外將單一主機改為大型伺服器群組。雲端議題之所以倍受關注，它表彰的精
減成本精神是最切合企業需要的部份，更呼應了當前全球節能減碳的大趨勢。 
雲端帶來了許多好處，技術瓶頸慢慢被突破，雲端服務已經開始充斥在一般民眾的日
常生活之中。但是當資料大量集中到雲端裡面的時候，就衍生了許多安全議題。有別於以
往個人電腦的安全問題，在雲端裡面若發生安全性的問題，後果可能是影響到所有在雲端
活動的使用者。因此，安全性要求是雲端系統必備的條件之一，而除了保障使用者儲存的
資料不會在未經許可下被窺視和竄改外，若系統能提供多樣性的功能（如錯誤修正、內容
分享、存取控制等）將使得雲端基礎建設功能性更加完備。 
除此之外，由於現今的網路環境充斥著各種攻擊行為，傳統的做法是由各主機或服務
自行建構入侵偵測及防護系統，這樣的做法在雲端環境並不可行，其理由是雲端平台上的
服務與虛擬主機所建構的各式入侵偵測及防護系統不但功能上互相重複，且也會浪費大量
的資源並明顯的拖累整體的系統效能。相較之下，將入侵偵測與防護系統建構在底層的雲
端平台是一個較有效率的設計，由於底層的雲端架構已將網路中已知的一般攻擊隔絕，其
上層的各系統可以專注於提供各自的服務，不但可以省下大量的投資，亦可解決運算資源
被浪費在重複架設的入侵偵測防護系統之上。 
不同於已知的一般攻擊，傳統透過特徵偵測或靜態分析的技術對垃圾郵件與數量更為
龐大且變化更為快速的病毒成效不彰，新型的攻擊手法亦使傳統病毒碼的偵測效益降低。
先進的惡意程式撰寫技術，加殼（Packing）、多型（Polymorphism）、變形（Metamorphism）、
核心等級匿蹤技術（Kernel Level Rootkit）等，會讓同一種行為的惡意程式有不同的病毒
特徵。故國內外學者在近年來皆朝著動態分析方式來萃取惡意程式的行為特徵，而不再是
靜態的二進位執行檔案之特徵。 
目前分析技術可分成靜態分析（static analysis）與動態分析（dynamic analysis）兩大
類，靜態分析將能夠針對檔案的內容做檢測，希望能夠找出不應該存在於該檔案的內容，
或是能夠判斷該檔案是否有可疑的加殼或加密行為。而動態分析而是直接模擬運行時的狀
態，利用已知的動態堆疊資訊取得技術，來檢測該檔案是否在執行時期，有取得堆疊資訊
的能力。由於動態分析需要耗費大量的運算能力，故如何利用雲端的運算彈性來進行動態
分析亦為一個相當有價值得研究課題。 
此外，雲端計算的基礎技術強調如何利用虛擬化及自動化技術，以實現運算資源最佳
化與資源共享等概念，例如利用虛擬機器 Xen 或 KVM，依使用者需求配置運算資源等。
然而，目前雲端計算所採用之基礎技術卻尚不足以支援即時性（real-time）與仿真性
（fidelity），也很難滿足某些特定應用或服務的需求，在網路測試服務上面更是無法提供所
需的種種特性。 
 
3 
 
錯編碼後分散儲存到系統中的各儲存伺服器中。然而容錯編碼技術只處理了維持
整個儲存系統的不間斷服務，並沒有全然修復系統的功能。 
(3) 資料完整性授權驗證機制 
在使用者儲存在雲端的資料相當大量的情況下，便需要一個有效率的方法進行資
料的完整性驗證來防止資料毀損等情況。最簡單的方法即是將資料從雲端下載回
來和原始資料進行比對，但是這樣做不僅會耗費掉大量的頻寬，使用者也需耗費
大量的空間來儲存原先的資料，如此一來，便失去了雲端儲存的優勢了，所以我
們需要一個更有效率的方法來進行雲端資料的完整性驗證。另一方面，使用者有
時候需要向他的親朋好友或是工作夥伴分享他的資料，被分享人也必須要能夠對
資料進行完整性驗證的動作，這些資料只流通於他們之間，資料完整性驗證的能
力也限定於他們之間擁有而已，這意味著使用者不僅僅是能夠授權驗證能力給他
的親朋好友及工作夥伴，還必須能夠註銷授權出去的驗證能力，以及防止被授權
人將驗證能力轉授權給他人，進而達到控制管理可授權的驗證能力。 
 
 基於機器碼之 Windows 惡意程式行為分析雲端平台 
由於雲端計算能有效利用實體機器的運算資源，藉著聯集所有相連接的運算節點來增
加安全分析的產量。防毒軟體公司早在進行郵件過濾時便發現，以傳統的方式如透過特徵
偵測或靜態分析技術，對系統中的檔案或是網路上的封包進行掃瞄比對，對於已知的惡意
程式與攻擊偵測十分準確且快速，但因為垃圾郵件相較病毒的數量更為龐大、變化又快，
病毒碼擷取特徵的方式來處理垃圾郵件成效不彰，所以需要重新設計一套分析架構，去收
集大量的樣本並進行資料探勘以找出有用資訊，於是便想到利用雲端運算的架構來快速分
析大量的資料，其目的主要在解決病毒防疫空窗期與防毒軟體日益肥大的問題。 
除此之外，新型的攻擊手法使傳統病毒碼的偵測效益降低。先進的惡意程式撰寫技
術，加殼（Packing）、多型（Polymorphism）、變形（Metamorphism）、核心等級匿蹤技術
（Kernel Level Rootkit）等，會讓同一種行為的惡意程式有不同的病毒特徵。故國內外學
者在近年來皆朝著動態分析方式來萃取惡意程式的行為特徵，而不再是靜態的二進位執行
檔案之特徵。我們將整合修改先前開發的惡意檔案檢測模組來進行一系列分析。惡意檔案
檢測系統要提供一個全面性的分析。目前分析技術可分成兩大類：一）靜態分析（static 
analysis）、二）動態分析（dynamic analysis）。靜態分析將能夠針對檔案的內容做檢測，希
望能夠找出不應該存在於檔案內容，或是能夠判斷該檔案是否有可疑的加殼加密行為。此
部分主要以特徵比對（signature-based）來做判斷。此外，動態分析而是直接模擬運行時的
狀態，若該檔案為可執行檔時，我們將利用已知的動態堆疊資訊取得技術，來檢測該檔案
是否在執行時期，有取得堆疊資訊的能力。由於動態分析能夠彌補靜態分析不具有執行狀
況的資訊之缺點，所以本子系統將結合兩大分析技術，已達到較完整的檔案檢測分析。 
本子系統架設在一個不對外公開的區域網路之內，屬於一種「內部雲 (private cloud)」
的雲端應用。不同於國內大部分雲端系統，業者或是系統管理員只能夠提供 Hadoop 運算
的帳號，其「公開雲 (public cloud)」的系統架構並不適用於惡意樣本分析平台，原因有下
列敘述。第一點，動態程式分析不能夠利用 MapReduce 來平行化其動態分析的流程，因為
程式被執行的控制流程是相互關係的，在不同的系統狀態，即使給予相同的指令也會有不
同的結果產生，所以不能把動態程式分析分散處理。第二點，提供虛擬環境來讓租用者分
5 
 
受制於人（如直接使用 Amazon 或微軟所提供的雲），那我們勢必得發展出自己的
infrastructure。有鑑於台灣本身資源有限，顯然我們不可能指望有心從事雲端發展的企業皆
各自去建設自己的 infrastructure（如 Google 有自己龐大的 infrastructure 在支撐自己其 search 
engine、Gmail、YouTube等SaaS）。也因此，發展 IaaS Cloud以提供國內企業一個 infrastructure
應是我們的首要目標。  
台灣的硬體能力舉世聞名。對於建置 IaaS 雲所需要的硬體我們有絕對的能力可以掌
握，而這也可視為我們發展 IaaS 雲的優勢之一。再者以國家安全的角度而言，掌握自身 IT 
Infrastructure 亦是一個沒有討價還價空間餘地的議題。而這也是為何即便 Amazon EC2 已
很成熟，微軟也在推他們的 Azure Cloud Platform，我們卻仍必需要投入力量在 IaaS Cloud
上面的研究與發展。 
 
 計與實作基於雲端技術之安全實驗觀測網路 
「雲端運算」又可細分為「雲端服務」與「雲端技術」。前者著重於透過網路連線取
的遠端主機所提供的服務，如 Amazon EC2 是 SaaS 概念的實現。「雲端技術」則強調如
何利用虛擬化及自動化技術來實現運算資源最佳化與資源共享等概念，例如利用虛擬機器 
Xen 依使用者需求配置運算資源（運算核心與記憶體）。然而，目前的雲端技術卻尚不足
以支援即時性（real-time）與仿真性（fediality），也很難滿足這些即時應用與仿真應用的需
求。 
以網路測試平台為例，研究人員或網路應用開發人員常需建置實驗網路，用此測試其
新開發之產品或新提出技術的可行性與穩定度等。為了要提供高擴充性、可重置實驗、高
仿真度的環境，在過去幾年，國內外知名大學紛紛投入研究分散式的網路架構與測試平
台，包括 Emulab、ORBIT、APE （Ad Hoc Protocol Evaluation）、Roofnet、MiNT（Miniaturized 
Wireless Network Testbeds）、WHYNET（Wireless HYbrid NETwork）、Netbed、
TESTBED@TWISC 等等。這些網路測試平台有些更延伸支援網路安全測試或無線網路測
試，如 DETER、SWOON 等。 
不論是哪一種測試平台，其設計宗旨與雲端運算不謀而合，都是期望將實驗所需的運
算能力放置在遠端主機上，本機端僅透過瀏覽器或簡單的操控介面，即可配置、操控實驗，
並讀取實驗結果。然而，以目前的雲端技術而言，雖然能夠隱藏平台硬體、作業系統的異
質性，也能夠隔絕各運算叢集之間的干擾，但是，運算叢集的安全性、仿真性等卻不在考
慮之內。 
參考國內外目前雲端技術與網路測試平台之設計，本計劃設計了一套應用雲端技術之
安全實驗觀測網路，使用者能在此雲端安全實驗觀測網路中，配置其所需之測試拓樸，並
進行其實驗。以下稱所有配置之節點為「運算叢集」。除了應用現有雲端運算之虛擬化與
自動化技術外，同時兼顧網路實驗與觀測時的必備條件，包括隔離性、仿真度、重複性、
擴增性、資源共享、擴充性等。 
 隔離性（Isolation）： 
預防運算叢集之外的封包有意或無意地對其內之測試節點造成影響；同時，也必
須避免運算叢集中實驗用之惡意程式碼或病毒流出至雲端其他主機或外部公用
網路。此外，亦必須考慮不同實驗之間的干擾問題，包括動態執行期間的記憶體
資料干擾或執行結束後殘留記憶體之資料遭到側錄等問題。 
7 
 
 
二、  文獻探討與相關研究 
本計畫包含四大研究主題，茲將各主題之相關文獻探討與目前研究狀況說明如下： 
 支援多樣功能之雲端資料安全儲存 
一般入侵偵測系統通常會使用「關鍵字比對」的技巧來分析和檢查系統資訊是否遭受
到惡意的攻擊，然而這些方法都是直接使用原始資料(明文)進行比對。所以，當我們將這
些入侵偵測系統移到雲端上來執行運作時，便有可能會造成使用者的隱私資料洩漏的問
題。Song, Wanger, Perrig [14] 提出了一個用來解決關鍵字搜尋加密資料的方法。使用者將
資料加密儲存在不可完全信任的遠端伺服器上，接者使用者可以透過關鍵字找回其對應的
資料。 
在針對容錯編碼分散式儲存系統設計的修復機制中，Dimakis 的研究是以修復單一錯
誤為目標[17]。當系統中有一個儲存伺服器發生錯誤的時候，系統會新增一個儲存伺服器，
新的伺服器會向其他伺服器索取資料，當正常運作的伺服器收到要求後，會針對自己儲存
的資料進行處理之後再回傳給新伺服器，在新伺服器收到足夠多的資料時，便進行運算，
最後將運算結果儲存起來。一個修復機制必須使得新的伺服器在功能上取代發生錯誤的伺
服器。當時學者們提出在衡量修復機制的效率時，以每個儲存伺服器的儲存量與修復一個
錯誤時所耗費的網路傳輸量來評估，爾後，有學者研究定義出兩個評量值之間的權衡關係
(tradeoff)，並將其定義為一個曲線。一個修復機制的兩個衡量值若落在該曲線上，則被稱
為 Regenerating code[18][19]。在修復機制中，若新增的儲存伺服器完全還原了發生錯誤的
伺服器中儲存的資料，此類的修復方法稱為 exact repair，與之相對的方法則被稱為
functional repair。Rashmi 等學者提出 exact repair 的修復機制並且證明其效率衡量值落在
regenerating code 的曲線上[20]。Shah 等人則考慮網路狀況為不對稱的系統模型進行研究
[21]。其他學者紛紛考慮不同的系統模型演化出不同修復機制[22][23][24]。若系統只能修
復單一錯誤，那麼只要有錯誤發生，系統就要馬上進行修復，這對系統造成了過大的負擔。
Hu 等人提出針對兩個以上錯誤進行的修復機制[25]，讓系統可以一次修復多個錯誤。當系
統中出現 a 個錯誤時，就新增 a 個儲存伺服器，並讓 a 個伺服器詢問所有的伺服器取得既
有的資料，再對得到的資料進行運算後儲存下來。Oggier 與 Datta 則提出了一個高效率可
以修復多個錯誤的機制[26]，但是能夠應用的儲存系統必須是集中式的結構，也就是要有
一個中央控制單位。在儲存系統發生錯誤的相關議題中，Dikaliotis 等學者考慮偵測資料錯
誤(faulty error)的存在[27]。Rashmi 等人則提出可以結合兩個容錯編碼來提供更好的修復功
能[28]。Pawar 等人討論當修復機制在執行的時候，網路上的竊聽者是否會破壞資料隱私性
的問題[29]。Papailiopoulos 與 Dimakis 則證明了在最大化資料隱私性與最小化修復網路頻
寬問題中間的對等關係[30]。無論是修復單一錯誤或者多個錯誤，我們發現到的是在效率
評估的既有方法上，沒有考慮到兩個伺服器之間建立連線的成本，在網路傳輸資料總量相
同時，若需要的連線數量較多，則建立連線的成本就會對傳輸成本造成影響。令系統中伺
服器的總量為 n，既有的方法中，每修復一個錯誤都需要 n-1 個連線，我們認為這個成本
有很大的改進空間。另一方面，我們特別針對非集中式容錯編碼儲存系統進行研究。此種
儲存系統首先由 Dimakis 等學者提出，我們將資料隱私安全性加入儲存系統中，並在早期
的研究中提出了具有安全性的非集中式容錯編碼儲存系統[32][33]。有別於一般的容錯編碼
9 
 
比，還可以輕易的擴充儲存節點，非常適合用來儲存惡意樣本。儲存在資料庫中的惡意樣
本除了可以供研究使用，也可以利用分群的技術來實作未知樣本的惡意行為偵測
[57][58][59][60]。 
結合分析以及樣本蒐集的惡意樣本分析平台，並非本系統的獨特創新[64][66][69]。這
也驗證了此系統的可行性之高，並且可以實際的運用在病毒分析與偵測的領域。本系統的
創新在於如何簡易的掛載不同種類的分析工具，甚至往後可以推廣到其他相關研究或是提
供樣本給學術界研究分析。我們評估了不同種的工具系統，並且修改和整合其原始碼至此
子系統。除了整合現有的工具，還實作一些機器管理機制以及節點間通訊協定，讓此系統
更加有彈性。在實作部分，我們利用高階語言來物件化功能、提高可讀性和簡易化偵錯以
縮短開發時程，預計能在計畫期間內前完成。 
 
 基於 Xen Hypervisor 之即時雲端環境入侵偵測與反制 
IaaS 雲目前市場的領導者是 Amazon。Amazon 的 EC2 (Elastic Compute Cloud) 提供客
戶透過網際網路配置虛擬機器[70]。 
例如三家公司 A、B、C 分別在 EC2 上配置虛擬機器，底層是由四台實體機器所構成。
每台實體機器上有安裝 Xen Hypervisor[71] 來提供虛擬化的服務。用戶可以在所配置到的
虛擬機器上安裝各自所需的作業系統 (如 Linux、 OpenSolaris、Windows Server 等) 以及
所需的應用服務程式（比如說資料庫系統、網站伺服器等）。用戶更可以自己去設定這些
虛擬機器間的網路，以及配置各台機器所對應的實體 IP 位置等網路設定[72]。對於用戶來
說，透過 Amazon EC2 所建立的虛擬機房所需的成本一般來說會比搭建實體機房來得更為
便宜。另一方面，底層系統的可靠度以及安全性的部分亦可交給 Amazon 來負責處理。 
IaaS 雲最關鍵的技術之一是機器以及網路的虛擬化。透過虛擬化，我們可以在一台實
體機器上執行多個作業系統，也因此可以達到更高的底層硬體資源的利用率。另一方面虛
擬化也讓系統佈建變得更為快速。虛擬化一般分為兩種類行。其一是直接在實體的機器上
面裝一個 Hypervisor，然後可於上面配置多個虛擬機器，每個虛擬機器上面安裝各自的作
業系統（Guest Operating System）。這稱為 Type-1 的虛擬化。如 VMWare ESX、Citrix Xen 
[74]、Microsoft Hyper-V[73]均屬於此類。另一種型態的虛擬化是在一台已經裝好作業系統
(Host OS)的機器上裝上一個 Hypervisor，然後再於 Hypervisor 內運行虛擬機器。Hypervisor
必須要透過 Host OS 的系統 API 才能跟底層硬體溝通。Type-2 Hypervisor 本身受到 Host OS
所加諸的一些限制，也因此在執行需要特殊權限的程式碼的時候，需要輔以 emulation 或
binary rewriting 等技巧來處理。Type-2 Hypervisor 包括了如 VMWare Fusion、VMWare 
Workstation、Microsoft Virtual PC、Oracle VirtualBox 、HXEN (Hosted Xen)等。對於 IaaS 
Cloud 來說，使用 Type-1 Virtualization 是一個比較常見的作法。主要原因不外乎因為系統
的主要目的就是提供虛擬化環境，也因此底層先放個 host OS 也就顯得多此一舉，更遑論
這對虛擬機器的執行性能會有所減損。 
 
 基於雲端技術之網路安全實驗觀測平台 
本系統將結合網路測試平台與雲端運算的虛擬化技術，意圖在單一台實驗主機上建立
多台虛擬機器，並利用這些虛擬機器作為網路實驗中的實驗節點。因此，在本節中，我們
將具體呈現現有雲端平台與網路測試平台的研究狀況。 
11 
 
一直以來，微軟都是以本機端的視窗軟體為其根基。然而，這卻與雲端運算的宗
旨（不需安裝額外的本機端軟體，所有資源都在雲端，本機端只需能連上雲端的
設備與瀏覽程式即可）相違背。為了因應雲端的流行趨勢，不落人後的微軟也開
始推出免費的雲端服務，搭配其本機端軟體，可以讓使用者在熟悉的環境中，享
受這些免費的雲端服務。 
 
Windows Azure Platform 是微軟新推出的雲端服務平台（含有 Windows Azure 作業
系統、.NET 服務與 SQL 資料庫），可提供開發人員一套更有彈性的視窗環境，
使其能快速地開發雲端應用與服務。Windows Azure 是一套雲端服務的作業系
統，除了開發之外，也能提供管理服務的機制與環境，開發人員可以透過 Azure 平
台提供使用者所需要的計算與儲存能力，甚至能透過網路管理其網站應用。由於 
Windows Azure 整合了 Visual Studio，也支援多種標準與協定，如 SOAP、XML、
PHP 等，因此，能使開發人員過去的開發經驗繼續傳承與延伸。 
 
 
圖表二：Windows Azure Platform 之架構 
 
 
 網路測試平台 
在網路測試平台方面，本節主要介紹目前較為知名的幾個國內外測試平台，包括 
Emulab、DETER、TESTBED@TWISC 等。 
 
 Emulab 
Emulab 是猶他大學所研發設計之網路測試平台，利用分散式系統與網路建置出一
套研究用的仿真平台。在此平台中，使用者可以利用 NS 語法，將平台內的各實
驗節點任意連接成一個網路拓樸。平台可以支援多組實驗同時進行，每個實驗網
路均以 VLAN 隔開。 不管實際接線情況為何，配置在同一個 VLAN 下的網路
13 
 
需。此測試平台中的實驗節點皆為實體機器，如前所述，使用者進行實驗之前，
必須先配置得實驗節點。爾後，使用者便可以任意控制整個實驗節點（實體機器），
包括 root 權限、作業系統與軟體安裝等。 
 
 
15 
 
此項目的目的是希望提供一個模式來保護使用者上傳資訊的隱私且依然能夠將這
些保護過的資訊交給雲端來處理。我們將這個方法應用在入侵偵測系統中。藉此方法
達到保護上傳的資訊的隱私且又能夠提供入侵偵測的能力。 
 非集中式雲端儲存系統中系統修復機制 
此項目的目的是為 (n,k) 分散式容錯編碼分散式儲存系統提供具有更好效率的修
復機制，且該機制能一次修復多個錯誤。 
 資料完整性授權驗證機制 
此項目的目的是希望能提出一個可授權驗證的資料完整性檢查方法，進行驗證時
不需下載完整的使用者資料，使用者也可以將驗證能力授權給信賴的代理人，進行授
權的資料完整性驗證。另一方面，使用者還可以防止被授權人轉授權驗證能力給他人，
或是註銷已經授權的驗證能力，達到控制管理可授權的驗證能力。 
 
 基於機器碼之 Windows 惡意程式行為分析雲端平台 
本研究執行之目的有二：（一）提供雲端服務平台檔案之安全分析（二）開發與設計
雲端架構分析平台以提高安全分析產能。以下對此兩大目的加以說明： 
 提供雲端服務平台檔案之安全分析 
由於雲端計算在應用上提供平台服務（PaaS），不管是客戶或是終端使用者皆有可
能放置檔案到此平台，並藉由此平台進行傳遞、交換、散播等動作，這些方式與傳統
網際網路上檔案交換並無太大不同，造成雲端平台上也有傳統網路攻擊的疑慮。對於
雲端提供商與雲端平台客戶來說，若是在雲端上發生類似傳統網路的蠕蟲攻擊，營運
上的損失與對商譽的傷害將是無法想像的巨大。因此，放置在雲端平台上的檔案安全
與否變得格外重要。而如背景所述，傳統靜態分析對於雲端平台上千變萬化的檔案已
經不夠及時，必須等待特徵碼產生後才能提供為判斷的依據。 
因此本研究計畫之首要目標為，開發與整合多項檔案安全分析技術，並將其融合
至雲端分析平台以顧及多面向的雲端檔案。首先，分析雲端平台上的目標檔案是否內
藏加殼程式來躲避分析。若目標檔案為可執行檔，則進一步利用全系統層次的動態汙
染行為分析技術來詳細分析該執行檔是否可能對使用者系統造成危害。有了以上的安
全分析，可保護雲端服務平台，降低使用者上傳的未知檔案傷害風險。 
 開發與設計雲端架構分析平台以提高安全分析產能 
檔案分析的方式眾多，越來越多不同面向的分析工具大量的產出。但因為分析的
方法不同，而有互補的作用。靜態分析與動態分析各有其優缺點，靜態分析雖然運算
負擔較動態分析小，但卻無法得知執行時期的資訊，所以在分析應用上較適合特徵式
偵測。另一方面，動態分析除了負擔較大的運算開銷以外，分析範圍需要大量的運算
時間搭配，故並沒有一種方法是完美的。如果能夠簡易的整合市面上各種分析工具而
達到互補作用，又可有效且平均的分配至多台電腦，則可以加強分析能力又可縮短分
析時間。 
為了增加分析的效率與產出，本研究計畫的第三項大目標，就是開發一個雲端架
構式的分析平台，把目前現有的分析工具模組化，依使用者需求掛載分析模組且動態
的去管理。這個平台必須具備有：可擴充性、可自動化、與高容錯性。可擴充性可以
讓本分析平台藉著增加運算節點來達到效能的提升，有效的利用運算資源。然而，管
17 
 
不需要在實體網路上佈建網路安全匝道器。此構想最早是由 Stanford 大學的 Mendel 
Rosenblum 教授提出[77]。透過 VMM 監控上層 Guest OS 是一個非常重要且具實際應
用價值的技術。目前仍存在的障礙是只能對底層(實體層)的記憶體、I/O 資訊的存取。
也就是說 VMM 監控所看到的是底層的低階、缺乏結構性的狀態或事件，這與上層應
用中的狀態或事件間存一個 semantic gap，直觀地來說，由於 Hypervisor 掌控了虛擬機
器對底層硬體包括 CPU、記憶體、磁碟機、網路、周邊設備等的存取，所以我們可以
透過 Hypervisor 來達到傳統 IDS/IPS 所進行的偵測、防護以及制動。 
 
 基於雲端技術之網路安全實驗觀測平台 
本研究著重於將虛擬機技術導入網路安全實驗觀測平台之建構，其具體研究方向
如下： 
 虛擬機資源管理分析： 
此技術將虛擬機技術導入網路測試平台，可依照各別的測試需求自動建立虛擬節
點與網路連結。  
 虛擬機安全性分析技術： 
此技術可確保虛擬節點之間的隔離性，防止運行中的惡意程式污染其他虛擬節點
或是測試平台。 
 虛擬機安全資源管理機制： 
此技術可建立自動化之虛擬機管理機制，測試平台可依照各別測試的需求管理各
虛擬機之資源。 
 
 
19 
 
各子計畫人員各有不同的專長背景，總計畫執行過程中常態性的舉辦經驗交流與
進度會議，可縮短整體計畫團隊學習時間的效果。 
 建立各子計畫設備資源共享機制： 
計畫設備資源有限，總計畫已將各子計畫設備資源分類，並增加資源的可共用性，
可最大化所有設備的使用效率。 
 協調整合系統之基礎軟硬體架構： 
總計畫向各子計畫調查軟硬體需求，並協調所需要的整合式平台，避免可能的系
統衝突，以確保研究成果之整體性。 
 撰寫總成果報告： 
總成果報告除了實際系統的各種說明文件以外，也包含所有相關的發表論文，最
後並把整體系統設計理念文件化，以便相關研究者可以在這個基礎上繼續更深入
的研究。 
 
各子計畫之個別研究方法規畫如下: 
 支援多樣功能之雲端資料安全儲存 
本計畫的研究方法可依研究成果分成以下三項分別說明： 
 保護隱私的雲端入侵偵測  
我們採用前面所提到的 Song, Wanger, Perrig 之關鍵字搜尋加密資料的方法來保護
使用者上傳資訊的隱私。我們利用候選者名單來讓雲端提供者無法確定使用者上傳的
資訊確切為何，其中加密金鑰雜湊部分的長度會影響到候選者名單的大小，藉由調整
加密金鑰雜奏部分的長度來改變候選者名單大小來達到保護隱私能力的強度。除此之
外，我們會先將事先定義好的關鍵字放在雲端上，使用者只要上傳可疑的資訊到雲上，
則我們會比對這資訊和事先定義好的攻擊來判斷使用者是否有遭受到惡意攻擊。在系
統實作上我們以 Linux 來當作我們系統的平台，使用 Hadoop 來建立雲端環境，並利
用 SNORT 來建立出我們要比對的關鍵字資料庫。藉由上述的技巧及環境來開發我們
的雲端安全服務：Privacy-Preserving Cloud IDS。總括來說，我們利用下表中所列出的
工具來建立我們實驗的環境，最後根據這個環境做隱私、偵測率和效能的評估和實驗。 
 
 使用工具清單 
雲端環境 Ubuntu + Hadoop + Java + OpenSSH 
關鍵字資料庫 SNORT rule 
保護隱私方法 jpcap library + client-server program 
圖表八：使用工具清單 
 
本系統分為兩大部分：使用者端和服務者端。使用者端是一個 java 程式，用來收
集使用者電腦的資訊，經過隱私處理後，傳到雲端服務上做分析處理，在做最後的判
斷，來判斷使用者的電腦是否安全無疑。服務者端採用 MapReduce 的程式架構來完成
hidden keyword search 的功能，用來比對使用者的上傳。除此之外，針對比對的資料庫，
我們事先做好隱私處理，將這些資料放在 Datanode 上(HDFS)，用來做比對處理 
 
21 
 
 基於機器碼之 Windows 惡意程式行為分析雲端平台 
本分析平台主要由三個部分所組成：檔案來源子系統、儲存子系統、以及分析器管理
子系統，以下將分部介紹之： 
 檔案來源子系統 
本系統需要接收大量的檔案作為分析的對象，而此系統必須具備以下特色：(1)處
理大量檔案的能力、(2)各種不同的檔案來源，例如：網際網路、檔案系統、P2P 網路、
E-mail…等，以分析並取得各種不同型態的惡意軟體、(3)適用於各種不同的使用方式，
例如：網路爬取、使用者上傳。為滿足以上需求，本系統實做一個 PushTask 之函式庫，
此 API 可將任意檔案輸入本系統進行分析，並指定該檔案的優先權。此 PushTask 函式
庫先產生檔案的工作識別（UID），在將此 UID 放入 Redis 中，並將檔案內容存入
Cassandra 中，將檔案輸入我們的系統中。利用此 API 為基礎，我們實做了兩種檔案來
源系統：網頁爬取系統和批次檔案輸入。 
在網頁爬取部分，我們使用了 Nutch 為爬取的開發工具基礎。Nutch 為 Apache 
Fundation 名下的開放原始碼計畫，是一套由 Java 建構的網路搜尋引擎軟體，具有相
當良好的跨平台特性。並且支援 hadoop 系統，具有良好的可擴充性。Nutch 也提供了
許多 API 可以使用，分便於系統的架構開發。 
 
圖表九：Nutch 系統架構 
 
上圖為 Nutch 的系統架構，如圖中所示 Nutch 可以分為網頁爬取（Crawler）以及
搜尋引擎（Searcher）兩部分。網頁爬取部分由一組使用者定義好的初始網頁（seed）
做為搜尋的起點，搜尋與起始網頁相關聯的網頁，並將網頁的連結資料取出（update）
建構成新的初始網頁（web db）進行下一輪的搜索。在本系統中，只需要對網頁做抓
取（上圖左半部）的動作，而不需要進行索引以及搜尋的部分，因此我們利用 Nutch
提供的 API 進行網頁爬取並省略做索引搜尋的部分以增加系統效能。並透過 hadoop 系
統，藉由 mapreduce 將運算分散至各節點進行運算，增加整體產出。 
在 Nutch 爬取大量網頁時，會抓取許多不同格式的檔案，如：exe、jpg、zip、html…
等，而我們系統目前主要是以分析可執行檔為主，因此在爬取網頁檔案時，僅保留系
統可以分析的檔案格式（exe、zip、rar），過濾掉其他無法分析的檔案格式。在 Nutch
抓取檔案後，會執行 PushTask 函式，將檔案輸入到我們的系統中做分析儲存。Crawler
部分為此系統一長期穩定的檔案來源，僅具有最低程度的優先權。 
23 
 
Redis 本身支援 List（有序） 和 Set（無序）兩種資料結構，同時也有實作排序
的功能，因此在本系統的開發過程中就運用到其 List 功能以及不同的檔案來源來
實作出工作優先權佇列（Priority Queue），將其運用在工作識別號碼的分配。將
在下面詳述。 
 
本子系統在 Redis 部份實作了工作優先權佇列，架構如圖表十，其主要目的是為
了因應不同的檔案來源而給予不同執行順序的安排。分析器 A 到 D 代表不同種類的分
析器，每種分析器都有三個佇列，佇列則是用 Redis 的 List 資料結構實作而成，每個
佇列分別代表不同的檔案來源:  
使用者上傳、硬碟讀取和 Crawler 取得。當分析器拿取工作識別號碼時就由優先序高
（越小越高）的拿起。 
   
圖表十：工作優先權佇列於 REDIS內的實作概況 
 
 分析器管理子系統 
在本系統中，可以掛載多個分析器。藉由多個分析器的分析結果，以取得更準確
的結果。因此我們需要建構一套分析器管理子系統來管理各種不同的分析器，讓各種
不同輸入輸出的分析器能正常運作於本系統中。分析器管理子系統具有以下功能： 
(1) 自動化管理分析輸入輸出 
透過將輸入輸出流程自動化，可以降低分析器開發者測試所需時間，也可為此系
統取得大量分析結果可供使用比較。本子系統會自動從資料庫抓取分析檔案，並
在執行完成後自動將結果存回資料庫，可以達成自動化管理分析輸入輸出。 
(2) 快速方便，易於管理： 
藉由快速安裝分析器，可以將分析器快速的安裝在新節點之上，增進系統可擴充
性。而快速啟動停止分析器，可以增加本系統運作上的彈性，進而達到分析器的
動態調整。本子系統會自動讀取分析器開發者所撰寫的設定檔，根據該設定檔可
以讓我們快速的安裝起動分析器。而在起動時，系統會記錄分析器執行時的 PID，
系統便可依此停止分析器。 
(3) 整合各種不同形式的分析器： 
由於惡意軟體的種類眾多，並無任何可以偵測所有惡意軟體之技術。因此需要使
用多種不同形式之分析技術，以取得最完整的結果報告及準確的偵測率。本子系
統透過一個統一的設定檔，來記錄不同形式分析器的使用方式，讓系統可以整合
各種不同形式的分析器。 
(4) 執行多個分析器於單一節點，以增進系統產量 
25 
 
 偵測登錄機碼修改行為(REG)： 
此子系統會精準地列出所有被更動過之登錄機碼。因為惡意程式往往會修改系統
上的登錄檔，在開機時啟動惡意程式。除此之外，內核權限的惡意樣本還會竄改
Win32 函式庫或系統呼叫（system call），以避免某些新增之機碼被發現。本系統
直接讀取硬碟中用以儲存這些登錄檔的 Hive 檔案，並透過自己的程式加以解析。 
 偵測網路通訊修改行為(NET)： 
為找出程式是否會開啟網路通訊阜並隱藏其行為，需要比對不同時間先後的通訊
阜列表。列出系統中所有被打開的通訊阜，透過篩選出最近新增的通訊阜，這些
新增的通訊阜即是該程序所開啟的。 
 偵測驅動程式植入行為(DRV)： 
為找出程式是否會動態載入可疑的驅動程式，本子系統需要比對不同時間先後的
載入列表。列出系統中所有被使用的驅動程式，透過篩選出最近新增的，可把可
疑的惡意驅動程式找出。 
 
本分析系統的關鍵技術在於汙染源資訊流動追蹤技術上。在一般的動態分析研究
中，所分析的目標大多為單一的、運行於使用者層次的程式，因此分析系統所需提供
的模擬環境較簡易。但全系統層次行為分析系統卻是追蹤整體作業系統運行該程式的
資訊流動。 
本系統採用的動態污染分析具有高度的研究價值與應用性，尤其針對現今多變的
攻擊與惡意程式，必需依賴此技術以準確分析出它們的動態執行時期行為，以補足傳
統分析方法的弱點。所謂的動態分析乃透過實際運行程式以獲得更多更深入執行時期
的動態資訊，而動態汙染源分析乃眾多動態分析技術之一。在進行動態分析時，分析
者必須提供一虛擬的運行環境，並在此虛擬出的環境中執行欲分析的目標。這樣的虛
擬運行環境一來使分析者能完全掌握目標程式的執行過程，並使目標程式與真正的主
機隔離。因此，為了大量地建置該分析系統，本計畫需要建立一虛擬環境以利進行分
析。這也是本子計畫的規劃原因，在第一年度實作一個可擴充的惡意程式分析平台，
而在第二年度加強其平台的分析能力。 
 
27 
 
來，在系統呼叫發生的時候的前一剎那，會產生一個 page fault。這會導致 CPU 將執行
權從 guest VM 轉回至 Hypervisor。如此便能攔截透過 INT 0x2E 進行的系統呼叫[80]。 
另一方面，假若系統是使用 SYSENTER 或 SYSCALL 等指令來進行系統呼叫的叫
用的情況，由於這兩個指令會直接跳至 Ring 0。如果是 PV Guest，這會導致一個 General 
Protection Fault[93]，執行權也就自動會轉進 Hypervisor（因為 guest kernel 不在 Ring 
0)，也因此可以輕易攔截住系統呼叫。 
如果是在 HVM(Hybrid VM with Hardware-assist)的 Guest 底下使用 SYSENTER 或
SYSCALL，由於 Guest Kernel 本身就是位於 Ring 0，也因此並不會造成 General 
Protection Fault。在 Ether[80]中，他們提出一個解決方法是將 SYSENTER_EIP_MSR 設
向一個不存在的 page 而導致 page fault，然後執行權自動又會轉進 Hypervisor，如此便
能攔截到系統呼叫。 
 
 
圖表十三：Intel EPT 
 
4.0 版的 Xen 開始支援所謂的 Intel Extended Page Table (EPT) [96] 或 AMD 
RVI/NPT [94]這些硬體對於虛擬 page tables 上的支援。因此，當 Hypervisor 配置好
machine page tables，將各 Guest VM 分配至不同區段的記憶體空間後，剩下的就完全
交給 Guest VM 以及硬體去處理。 
針對這種狀況，我們提出的方式是使用一般 Guest VM 無法執行特權指令的特性，
將特定的特權指令塞到 Guest VM 處理系統呼叫函式的記憶體位置之前，因為 Guest 
VM 並不是在 root mode 執行，所以一旦嘗試要執行特權指令時，就會因為權限不足而
產生 VMExit 進入 Hypervisor，而此時控制權就交到了 Hypervisor 的手裡，因此能夠達
到攔截系統呼叫的功能。 
但是在 Linux kernel 中，我們不能保證系統呼叫函式所在的記憶體位置前有足夠的
空間來放置我們所要插入的特權指令，為了不影響 Guest VM 系統呼叫的正常執行並且
成功塞入特權指令到系統呼叫處理函式之前，我們的做法是去修改 Guest VM 的
kernel，在處理系統呼叫函式之前插入兩個 nop 的指令，產生兩個 byte 的額外空間，
以便我們之後插入特權指令(0x0fa2)。 
 
 系統記憶體內容物之定位 
傳統 IDS/IPS 是與 Host OS 共處的形式存在的，其在攔截系統呼叫後可以透過 OS
所提供的 API 如 GetProcessImageFileName、ReadProcessMemory 、OpenProcess 等方
29 
 
來的慢。另外對於 online 的磁碟影像備份上無法利用現有的 LVM Snapshot 來協助維持
備份過程中磁碟上資料的一致性(consistency)。 
對於 Guest VM 之磁碟存取，Xen 本身已提供一些工具如 qemu-xen-nbd 可將磁碟映
象檔模擬成系統上的裝置檔。再透過其他的系統工具如 kpartx 來辨識出該裝置檔的分
割情況進而把分割區 mount 起來，這樣一來即可在 Domain 0 的環境下讀取 Guest VM
上的檔案達到 offline 的存取虛擬磁碟。 
 
 
圖表十四：虛擬磁碟之監控 
 
但是光有 offline 的虛擬磁碟存取是不夠的，在 online 形式的即時監控部份，目前
已針對 HVM 形式之 Guest 有初步的成果，我們將 Qemu 與 debug-fs 及 ntfs-3g 的函式
庫結合，讓 Qemu 不只看到 block level 也可以看得到 file level 的資訊，如此一來就可
以在 Guest VM 運作的同時也能在 Domain 0 中動態地存取虛擬磁碟中的檔案，未來會
再試著針對 paravirtualized 形式的 Guest VM 支援此功能。 
當然另一方面，以 IPS 應用來說，很重要的一個功能是必需要提供對於 Guest VM
在存取磁碟動作上的控管。比如說當發覺某個檔案已感染病毒，必需要能夠阻擋對該
檔案的存取。這方面我們可以從我們在 Xen Hypervisor 層中的 VMM Detection & 
Response 模組來達到控管效果。從上圖中我們可以清楚地看到，對於 Paravirtualize 的
Guest VM，他的磁碟存取是透過 split device driver經由Xen Hypervisor然後轉至Domain 
0 上面另一半的 split device driver 來達成對實體磁碟(block device)的存取。另外如果是
HVM 形式的 Guest，磁碟存取則是經由 Xen Hypervisor 去存取位於 Domain 0 內部的模
擬(emulated)的磁碟 driver (qemu-dm[90])來達成對實體磁碟的存取。也因此，在控管的
31 
 
 
上圖是 Xen 虛擬網路的架構，對於 Paravirtualization (PV) Guest，其網路裝置的驅
動程式是透過 split driver 的方式實現，而對於 HVM 形式的 Guest，網路則是透過
qemu-dm 去模擬硬體網卡（比如 Realtek 8139)來供 Guest OS。這樣的方式都會藉由虛
擬網卡連到實體網卡，虛擬機就能夠透過虛擬網卡(vif0)對外聯絡。所以當虛擬機間要
互相通訊的時候，就要透過虛擬網卡做溝通。 
在這方面的話，既然要透過實體網卡，掌握 Dom 0 這部分所有的虛擬網卡和流量，
就能全盤了解虛擬機之間的內部網路流量(Intro-Hypervisor Network Traffic)，但在這方
面就必須修改 Dom 0 核心內部相對應網路配置的部分。可把問題改動成 Liunx Kernel
的重新編譯。只求觀測的情況下，那就是相對於處理 Linux 中 packet filter 所對應到的
地方做出修正和功能性的延伸。原則上來說，流量經過 Dom 0 的時候都會被 Monitor
所攔截進行檢測和紀錄，軟體方面可以透過 libpcap 進行內部封包的抓取處理。 
第二種 IaaS 流量是跨實體機器但仍在一朵雲內的網路流量（Inter-Hypervisor 
Network Traffic），這種流量就是跨越個別實體機器但仍屬於同朵雲內。而第三種是跨
過雲邊界的網路流量（Cross-Cloud Network Traffic）也就是對雲端未知的外部進行連
接。這兩種流量共通點就是都會經過實體網路(Physical Network)。這方面的對外網路
流量，所有的 Guest 依樣都是透過虛擬網路卡連線到 Dom0 的實體網路，接著藉由實
體網路卡連線到外部的網路，這樣的話所有的流量都會經過實體網路卡，只要能掌握
Dom 0 實體網路上面相對應的流量就能夠針對每個 Guest 的網路狀況達到監測和反制
的作用。 
 
	
 
（圖片來源：Microsoft） 
33 
 
路均以 VLAN 隔開。 不管實際接線情況為何，配置在同一個 VLAN 下的網路
拓樸彼此之間可以互相通訊，就好似連接在同一個區網之內。此隔絕性可以保證
各實驗之間彼此不會互相干擾。在 Emulab 中，使用者建置新實驗的步驟包括： 1) 
配置實驗節點；2) 配置 VLAN，以建構所需的拓樸；3) 將映像檔載入所指定的
實驗節點中。然後，使用者就可以開始進行其測試實驗。 
 
 DETER 
以 Emulab 為基礎，DETER 測試平台更進一步地提供安全保護機制，避免測試平
台本身遭到外部攻擊，同時也保證測試平台內部的實驗資料（尤其是含有惡意程
式碼的實驗）不會流入外部公用網路。此平台的特色在於提供「安全」的測試環
境。其設計已經整合於目前的 Emulab 中，並有眾多使用者以此平台作為測試其
新方法的依據。 
 
 TESTBED@TWISC 
Testbed@TWISC 由國內成功大學所建置之網路測試平台。此平台以猶他大學所授
權的 Emulab 為基礎，具備網路測試所需的隔離性、仿真度等特性。由於國內外
硬體規格差異，成功大學研發團隊在取得 Emulab 授權之後，便積極尋找可替代
之國產硬體（包括實體實驗節點、電源控制器、交換器等設備），並自行研發相關
軟、韌體，利用簡單的網頁操作介面，以因應國內資訊安全研究與實驗之測試所
需。此測試平台中的實驗節點皆為實體機器，如前所述，使用者進行實驗之前，
必須先配置得實驗節點。爾後，使用者便可以任意控制整個實驗節點（實體機器），
包括 root 權限、作業系統與軟體安裝等。 
 
 SWOON 
SWOON 是國內交通大學與柏克萊大學專家學者共同開發研究之無線網路測試平
台。以 DETER 為基礎，研發團隊設計各種不同的方法能仿真、模擬無線訊號，
並實作 802.11 a/b/g、802.16d（WiMAX）等無線網路技術，能提供無線網路安全
研究人員所需之實驗與觀測環境。此平台的設計挑戰在於無線訊號的飄移性與存
取特性，因此，在訊號傳遞與隔離上採取以有線模擬無線的方式來實作。此外，
802.11、802.16 及 802.15 等異質性的網路技術支援，也讓相關研究人員得以探索
異質無線網路環境整合時所可能衍生的問題。此平台目前已實作一套簡易使用者
操作介面，讓使用者可以透過 GTK+ 圖形化介面，簡易地配置其所需的無線網路
拓樸，進行並觀察實驗結果。 
 
比較上述兩個著重網路安全實驗的測試平台，DETER 與 SWOON，下表列出這兩
個測試平台所能仿真之網路攻擊行為： 
35 
 
 
貳、  計畫項目完成度  
本計畫執行完成，總計畫及各子計畫已完成之具體項目如下： 
 已完成整合系統的整體架構設計與系統執行流程規劃。 
 已完成保護隱私雲端入侵偵測子系統之設計與雛型系統之實做。 
 已設計出一個可抵擋 chosen plaintext attack 之公開金鑰加密系統。 
 已完成非集中式雲端儲存系統修復機制之背景研究，並已針對現行的技術提
出改良方案。 
 已完成使用者端資料加密容錯編碼之雛型系統之實作。 
 已提出一項可授權驗證的資料完整性檢查方法。 
 已完成網路檔案蒐集子系統之設計與雛型系統之實作。 
 已完成分散式資料儲存子系統之設計與雛型系統之實作。 
 已完成文件 Call/Pop分析子系統之設計與雛型系統之實作。 
 已完成惡意程式分析子系統之設計與雛型系統之實作。 
 已完成全系統層次的行為分析系統之設計與雛型系統之實作。 
 已完成 Hypervisor 層系統呼叫攔截子系統之設計與雛型系統之實作。 
 已完成記憶體內容物件的讀取、解析與制動子系統之設計與雛型系統之實
作。 
 
 
以下將上述完成項目與本計畫所規劃之工作完成度，依總計畫以及子計畫分別列出說明： 
 總計畫工作項目完成度: (完成度：100%) 
總計畫執行完成並符合進度規劃，其具體工作項目及進度如下： 
 規劃整體計畫研究架構 (完成度：100%) 
總計畫已規劃完成整合系統的完整架構，特別是與子系統間溝通介面的部份以及
功能性的畫分。 
 建立各子計畫經驗交流機制 (完成度：100%) 
總計畫已安排常態性的進度會議與經驗交流活動，可有效避免各子計畫在功能設
計上的衝突，研發人員之間亦可收到截長補短的效果。 
 設計整合系統之基礎軟硬體架構 (完成度：100%) 
總計畫已完成針對各子計畫所使用的軟硬體設備進行調查與統合。 
 技術成果整合 (完成度：100%) 
各子計畫已有成果產出，總計畫已完成各項技術成果與整體系統架構的比對與整
合，並確認各子計畫的技術產出與原規畫之進度相符。 
 撰寫成果報告 (完成度：100%) 
各子計畫已回報各項研究成果與技術細節資料，總計畫完成成果整理與報告撰寫
工作。 
 
 
37 
 
路連結關係，擴大搜索整個網路上的檔案，與搜尋引擎類似。而每擷取到一個
URL，將檔案下載，除放置分散式資料庫中。本項目利用現有的搜尋引擎客製化
系統 Nutch，來達到上述之功能。Nutch 是一款基於 Hadoop 時實作出的網路搜尋
引擎，該系統可以爬取網路上的資料，透過分析建檔來提供資料搜索的服務。但
本模組並不需要後續對網頁分析的部分，並且有實作與後端資料庫存取的部分。 
 分散式的資料儲存(完成度：100%) 
NoSQL 資料庫提供了 Key-Value 的存取方式，利用特殊的雜湊函式來保證讀取和
寫入為常數時間。本子系統結合分散式資料庫 Cassandra 與集中式 Key-Value Redis
來實現分散式分析資料儲存。由於 Cassandra 是分散式的資料庫，在存取的時間與
存取的能力較傳統 Sql 系統來的有優勢。但是其缺點是無法快速地列舉其儲存的資
料。為了依序處理分析平台內待處理的分析工作，我們使用了 Redis 內所提供的
List 資料結構來實現佇列的功能，依序地從工作佇列取出欲分析的工作識別（tasd 
ID）。在按照取出的工作識別去 Cassandra 資料庫內尋找更多的檔案資訊。 
 惡意程式分析(完成度：100%) 
本子系統分析程式模組化，藉由著制定的介面來達到有彈性的掛載分析工具。由
於分析工具可能會有數種，需要統一化其分析工具的 I/O。提供一套組態設定來讓
此分析平台可以掛載和移除分析模組。對於本系統與分析模組的銜接部分，會定
義各種分析工具的 I/O 要如何導入與輸出資料，藉著一套統一的機制來方便管理不
同實作出的分析工具，來達到本分析平台可擴充的能力，讓使用者可以新增自己
的分析工具，讓本平台的分析功能多樣化。 
 文件 Call/Pop 分析器(完成度：100%) 
本分析模組會檢查可執行檔是否具有堆疊位址取得的技術。給予一個欲檢測的執
行檔，本分析模組能夠判斷該程式是否會刻意的存取堆疊的內容。如果該執行檔
試圖取出堆疊的內容，會被此系統偵測出。此分析模組會包含一個模擬的 x86 
CPU，來模擬堆疊與 CPU 暫存器的狀況。而我們透過這 CPU 模擬器，可以完全觀
測此程式會不會取出事先寫入在記憶體中的魔法數值(magic number)。不同於虛擬
機器，此分析模組不用模擬所有的硬體裝置，只要簡單的模擬 CPU 暫存器與堆疊，
故能減少其他較不必要的運算開銷。由於 CPU 模擬器的實作較複雜冗長，我們已
結合利用 libemu 來縮短此分析模組的開發時間。藉由著修改 libemu 的系統，觀測
模擬運算時記憶體的狀態，來實作出偵測取得堆疊位址資訊的可疑檔案。 
 全系統層次的行為分析系統(完成度：100%) 
本分析系統採用動態污染分析技術(Tainting Analysis)，乃透過追蹤電腦運作時
程式與資料間的相互影響關係，以找出程式的異常行為。每當 CPU 執行一行指令
後，某些變數便會受到其他某些變數的影響，使其數值發生變化，這些變化常代
表某些重要事件的發生。本系統運用一個汙染源分析引擎，來追蹤一個惡意程式
樣本在本系統中所造成的資訊流動。透過整合工作，本系統提供一個微軟視窗作
業系統為基礎的作業系統環境，來檢驗該程式。而在此，本系預先設定好汙染源
（Taint Source）和汙染目標（Taint Sink），自動地分析雲端惡意程式分析平
台上所蒐集到的樣本。此系統會蒐集汙染源分析引擎所標記的所有二進位檔案。
而這些二進位檔案即是因目標惡意程式對系統所產生的影響。將上面步驟所蒐集
39 
 
擊很可能會造成異常的磁區讀寫情況，我們的系統透過磁區讀寫的觀測、記錄並
解析其是否有異常狀況發生，進而能夠對惡意的攻擊行為進行阻擋。 
在磁區觀測的部份，由於Xen Hypervisor對Guest VM的週邊裝置大多是藉由Qemu
模擬，特別是 HVM 形式的 Guest VM，因此所有的磁區操作最後都會經由 Qemu
來讀寫該系統的區塊裝置(像是映像檔或者是硬碟上的某一個分割區)。我們藉由修
改 Xen 中 Qemu 的程式碼(位於 tools/ioemu-qemu-xen/，主要是 block.c 及 aio.c 這兩
個檔案)，對負責磁區讀取和寫入函式的呼叫做監控來達到我們所想要的目的，在
Qemu 收到 Hypervisor 所轉換的磁區存取請求後，我們即可在函式中得知其磁區存
取的位置，每一次磁區寫入的位置都會被記錄下來。 
而關於制動的部分，我們在偵測到系統受攻擊時，可即時地在 Qemu 中將所有磁
區存取做過濾的動作，這樣便能將惡意的存取動作擋下來，而過濾的機制則透過
我們修改過結合 debug-fs 及 ntfs-3g 函式庫的 Qemu，得知關於檔案及使用者權限
等其他有關檔案系統的資訊，以及需受保護的檔案實際上是存在磁區的哪些位
置，整合至 Dom0 的控制中心後就能在過濾時判斷哪些存取請求該擋下來哪些則
不該擋，我們也可以主動透過 Qemu 把可疑檔案內容讀取出來，並掃描這些檔案
的內容，根據掃描的結果決定是否透過 Qemu 將該檔案刪除。 
 網路觀測與制動技術(完成度 100%) 
透過 Xen Hypervisor 對 Guest VM 進行網路封包系統防護與惡意流量監測，主要著
手於攔截 Guest VM 的封包、監測 Guest VM 封包的流量，以及針對 Guest VM 的
網路封包系統進行 online 式的觀測與解析，並將 Snort 整合進 Xen Hypervisor 大架
構中。由於 Guest VM 的網路封包在對外或對內的流通時，最終都需要經過 Dom 0，
所以我們將擷取 Guest VM 的封包，接這對於不同目的地不同目標的封包都進行監
控與防護，使用適切的 snort rules 達到防護與效能堅固的目的。 
 
 基於雲端技術之安全實驗觀測網路(完成度 100%)  
 研究現有雲端技術與雲端服務(完成度 100%) 
現有雲端技術與雲端服務之研究，請參考本文壹-四-基於雲端技術之網路安全實驗
觀測平台。 
 研究現有網路測試與觀測技術(完成度 100%) 
現有網路測試與觀測技術之研究，請參考本文壹-四-基於雲端技術之網路安全實驗
觀測平台。 
 結合雲端技術與網路觀測，設計新的雲端安全實驗觀測網路(完成度 100%) 
結合雲端技術與網路觀測，設計新的雲端安全實驗觀測網路。請參考本文請參考
本文壹-四-基於雲端技術之網路安全實驗觀測平台-vSWOON 說明 
 利用虛擬機技術，設計並實作雲端安全實驗觀測網路之管理機制(完成度 100%) 
利用虛擬機技術，設計並實作建置雲端安全實驗觀測網路之管理機制。使用者不
需要強大運算功能的裝置或設備，將複雜的運算工作或實驗交給雲端處理。 
 請參考本文第三節 E項說明。 
 本計劃建置虛擬機效能評測實驗，實驗結果可提供雲端安全實驗觀測網路之
建置參考，以及其資源管理機制的參考依據。 
41 
 
虛擬機效能瓶頸之非侵入式偵測 工業技術研究院 499,500 
雲端行動的安全及時分析可行性評估先期探討 工業技術研究院 600,000 
圖表十八：產學合作計畫表 
 
43 
 
(3) Shiuan-Tzuo Shen and Wen-Guey Tzeng."Delegable Provable Data Possession for 
Remote Data in the Clouds." Accepted by International Conference on Information 
and Communications Security (ICICS), 2011 
(4) Bing-Han Li, Shiuhpyng Shieh, "RELEASE: Generating Exploits Using Loop-Aware 
Concolic Execution," IEEE Conference on Secure Software Integration and Reliability 
Improvement, June 2011 
(5) Wei Shi-Sue, Shiuhpyng Shieh, Bing-Han Li, Michael Cheng Yi Cho and Chin-Wei 
Tien, "A Framework Using Fingerprinting for Signal Overlapping-Based Method in 
WLAN," in Proceedings of the International Computer Symposium on Computer 
Networks and Web Technologies (ICS 2010), Tainan, Taiwan, Dec. 16-18, 2010. 
(6) Yen-Ru Liu, C.W. Wang, J.W. Hsu, T.C. Tseng, S.P. Shieh, "Extracting Hidden Code 
from Packed Malware based on Virtual Machine Memory Comparison," 21th 
Cryptology and Information Security Conference (CISC), 2011. 
(7) Mung-Lu Tsai, Yen-Chun Hsu and Yu-Sung Wu, "An IaaS Cloud for Attack and 
Defense Experiments," 21th Cryptology and Information Security Conference (CISC), 
2011. 
(8) Hsiao-Ying Lin, Shiuan-Tuzo Shen, Wen-Guey Tzeng, Bao-Shuh Lin."Toward Data 
Confidentiality via Integrating Hybrid Encryption Schemes and HDFS." In the 26th 
IEEE International Conference on Advanced Information Networking, (IEEE AINA 
2012), March, 2012 
(9) Hsiao-Ying Lin, Wen-Guey Tzeng, Shiuan-Tzuo Shen and Bao-Shuh P. Lin. A 
Practical Smart Metering System Supporting Privacy Preserving Billing and Load 
Monitoring." In the10th International Conference on Applied Cryptography and 
Network Security (ACNS 2012), June 2012. 
(10) Hsiao-Ying Lin, John Kubiatowicz and Wen-Guey Tzeng."A Secure Fine-Grained 
Access Control Mechanism for Networked Storage System." In the Sixth IEEE 
International Conference on Software Security and Reliability (IEEE SERE 2012), 
June 2012. 
(11) Yi-Ruei Chen, Wen-Guey Tzeng."Efficient and Provably-Secure Group Key 
Management Schemes Using Key Derivation." In the 11th IEEE International 
Conference on Trust, Security and Privacy in Computing and Communications (IEEE 
TrustCom-2012), June 2012. 
(12) Kuei-Yi Chou, Yi-Ruei Chen, Wen-Guey Tzeng, "An Efficient and Secure Group Key 
Management Scheme Supporting Frequent Key Updates on Pay-TV systems," In 
the13th Asia-Pacific Network Operations and Management Symposium (APNOMS 
2011), September, 2011. 
(13) Chia-Ming Fan, Shiuhpyng Shieh, Bing-Han Li, "On the security of password-based 
pairing protocol in Bluetooth." APNOMS 2011: 1-4 
(14) Yun-Min Cheng, Bing-Han Li, Shiuhpyng Winston Shieh, "Accelerating Taint-Based 
Concolic Testing by Pruning Pointer Overtaint." SERE 2012: 187-196 
45 
 
 
三、  系統建置 
本計畫所建構出之各子系統簡述如下： 
 支援多樣功能之雲端資料安全儲存 
此部份之研究主題包含以下三項成果： 
 保護隱私的雲端入侵偵測 
(1) 建立雲端環境 
本實驗中我們採用三台筆記型電腦當作我們的雲，每一台電腦是雙核心 1.4GHz，
記憶體 2GB，硬碟 320GB，作業系統是 Ubuntu。安裝 Hadoop 來建立雲的環境，其
中一台電腦為 Master，另外兩台為 Slaver。 
在安裝 Hadoop 之前，要先將每一台電腦的網路給設定好。這個網路設定是為了
確保每一台電腦可以正確的通訊，在本實驗中，我們將三台電腦分別設定為
192.168.0.161, 192.168.0.162, 192.168.0.164。可以利用"ping"或"telnet"來測試每一台電
腦是否可以正確的通聯。因為 Hadoop 必須執行在 Java 虛擬機器上且版本必須為第 6
版以上，所以我們要安裝 Sun Java 6 的套件，可用"apt-get install sun-java6-jre"來完成
Java 的安裝。安裝完 Java 後，我們必須確認 Java 安裝的路徑，在本實驗中為
"/usr/lib/jvm/java-6-sun"，這個路徑是要用來設定 Hadoop 的設定檔，以確保 Hadoop
可以正確地找到 Java 安裝的位置。因為 Hadoop 是採用 SSH 當作每一個節點彼此的
通訊方式，因此我們安裝 OpenSSH 以及設定每一個節點用來認證彼此的金鑰。安裝
及設定完後可用"ssh ip"來確認安裝及設定是否成功。 
完成好上述準備工作後(網路設定→安裝 Java→安裝設定 SSH)，接著我們才可以
開始安裝 Hadoop。Hadoop 的安裝只要注意到其安裝的位置和使用者權限即可，在本
實驗中我們的安裝路徑為"/opt/hadoop-0.20.2"(其版本為 0.20.2)，使用者為"hadoop"。
安裝為後要設定"hadoop-env.sh"、"core-site.xml"、"hdfs-site.xml"、"mapred-site.xml"、
"master"、"slaver"等相關檔案。完成其相關設定後我們可以開啟瀏覽器輸入：
http://node1:50030 來檢查 Hadoop 是否可以運行。其運行圖如下圖所示。 
 
47 
 
一個封包內 ttl 這個 header 是否其內容為 64。而比對的部份我們只關心 Payload 和
Non-payload 的部分，所以我們將我們要比對的關鍵字做成 Keyword List(KL)來過濾
分析 的內容。將取出的 中的 的部分我們使用 SHA-1 雜湊函數來固定其長度和格
式，表示為 ，然後將原先的 = || 轉換為 || 。將每一個收集起來成為對應 的 ，然後
將 || 放到雲端上儲存，當作是先定義好的特徵值。 
 
(3) 保護隱私方法 
我們利用 Song, Wanger, Perrig 的方法和 Java 撰寫出對應的 client-server 程式來達
到保護使用者上傳資訊的隱私。這個程式分為兩個部分：client 和 server。 
Client 這程式具有以下能力：收集使用者電腦的封包、分析和轉換收集來的封包、
加密收集來的封包、儲存收集來的封包、上傳資訊到雲端、比對候選者名單和儲存收
集過的封包來判斷是否遭受惡意攻擊。以下針對上述功能做一個簡單的介紹(以下含
有程式碼的地方，其內容和參數為本實驗所設定的值)。 
 
Client 端功能 
 收集使用者電腦的封包 
  我們使用"jpcap"這個 library 來完成收集封包的功能。首先找到相
對應的網卡" JpcapCaptor captor =  
JpcapCaptor.openDevice(devices[Integer.parseInt("4")], 2048, false , 10); "， 
然後開始收集流經這張網卡的封包" captor.loopPacket(-1, ps); "。 
 分析和轉換收集來的封包 
  由於我們是採用 SNORT rule，而 SNORT 目前只支援 ip, tcp, udp, 
icmp 等協定，所以我們針對這幾個協定收集及封包" p = ps.getPacket(); 
"，" if( p != null && p instanceof IPPacket ) "，" if( p != null && p 
instanceof TCPPacket ) "，" if( p != null && p instanceof UDPPacket ) "，" 
if( p != null && p instanceof ICMPPacket ) "，上述功能就可將封包 header
的部份給收集起來；因為 SNORT 並不是每一個 header 都有比對，所以
我們根據我們分析 SNORT 的結果，將 SNORT rule 有可能比對得 header
給找出來，" tcp.sequence "，" icmp.code "，etc..。另一方面，由於 SNORT 
rule 有很大的部分都是比較 payload 的部分，所以我們還必須收集封包
內 payload 的部分" byte[] PData = p.data; "，將收集來的 payload 轉換成
16 進位的 ASCII 的格式表示。 
 加密收集來的封包 
  為了保護上傳到雲端上的封包的隱私，我們對這些封包做一個加密
的動作。一般而言，一個封包裡面會含有許多的 header，而我們只對
header 的內容做加密，然後將 header 轉換成我們是先定義好的關鍵字。
舉例來說，假設我們先前收集到的封包含有 header "icode"且其內容是
"15"，則我們後將"15"做加密並且保留"icode"這個關鍵字；假設我們先
前收集到的封包的 payload 為"47 48 49"(16 進位 ASCII 表示法)，則我們
49 
 
 
圖表二十二：封包加密上傳示意圖 
 
圖表二十三：收到候選者名單示意圖 
 
Server 這程式具有以下能力：讀取和儲存關鍵資料庫、做關鍵字比對來分析上傳
的封包是否為可能的惡意攻擊、回傳候選者名單給使用者做最後的判斷。 
Server 在收到 client 的 request 時，Server 會先將收到的 request 做一個前置處理，
這個處理主要是要取出從 client 端傳來封包的時間序號，我們將這個時間序號當作
index 來識別每一個上傳的封包；接著我們將其他上傳的資訊寫入一個檔案裡面，用
這個 index 當作檔名，上傳到 Hadoop 的 HDFS 上面" Process p =  
run.exec("/opt/hadoop-0.20.2/bin/hadoop dfs -moveFromLocal " + name + " ."); "；最
後我們在 Hadoop 上寫一個 www 的程式來做關鍵字比對的功能，當 Server 收到 client
的 request 時，就會去執行 www 這個程式來完成關鍵字比對的工作。 
www 這個程式的功能是讀取和儲存關鍵資料庫以及做關鍵字比對且 使用
Hadoop 自動地將工作分配給 slaver 這些 nodes 去執行。首先 www 要先找到儲存在
HDFS 上的關鍵字資料庫" FileInputFormat.setInputPaths(conf, new 
Path("/user/hadoop/sig")); "，接著取出其內容" map(LongWritable key, Text value, 
OutputCollector<Text, IntWritable> output, Reporter reporter) "，" String line = 
value.toString(); "，另一方面，我們還必須將前面所提到的 index 這個檔案從 HDFS 中
找出來" patternsFiles = DistributedCache.getLocalCacheFiles(job); "， 
" BufferedReader fis =  
new BufferedReader(new FileReader(patternsFile.toString())); "；找出來之後我們利
用下面流程來和關鍵字資料庫的資料做比對如下圖所示。 
 
圖表二十四：關鍵字比對流程 
 
51 
 
 
圖表二十六：Client-Server執行流程 
 
 非集中式雲端儲存系統中系統修復機制 
我們提出的非集中式修復機制架構如下圖所示： 
 
圖表二十七：非集中式修復機制架構 
 
我們考慮當 n 個伺服器中的(1-α)n 個發生錯誤，系統新增了 α 個儲存伺服器進來。
每個新的伺服器隨機地向 u 個舊的伺服器索取資料，舊的伺服器收到要求後會直接以
儲存的資料回覆，新的伺服器為每份收到的資料隨機取一個係數並對所有收到的資料
進行線性組合，最後僅將組合的值儲存下來。下圖為一個簡單的示意圖。 
 
53 
 
 
圖表三十：證明的方法 
 
我們要探討的是資料能夠正確取回的機率，於是我們將一個使用者詢問的 k 個伺
服器轉換為 k 個圖中的點，分別落在兩個點集合中的子集合 S1 與 S2，且將子集合的
大小表是為 n1 與 n2，若此 k 點都落於 V1，則依賴原本系統的容錯能力能夠保證資料
可以被取回，但是當部份的點落到 V2 時，要怎麼找到好的條件來使資料可以被取回
呢? 令 N(S2)表示 S2 點集合在 V1 中的鄰居點集合，我們觀察到一個充分與必要的條
件來保證資料可以被取回:N(S2)\S1 與 S2 有 maximal matching。觀察到這個條件之後，
我們就可以使用著名的 Hall’s Theorem 來分析此隨機圖中滿足該條件的機率。我們使
用本文中的符號重新詮釋 Hall’s Theorem 如下圖所示。 
 
 
圖表三十一：Hall’s Theorem 
 
按照重新詮釋的 Hall’s Theorem，我們要估計的是不存在任何一個點集合 B 的機
率，於是我們使用 union bound 高估存在任何一個點集合 B 的機率，再計算出不存在
任何一個點集合 B 的機率的低估值，我們將 B 的角色表示於下圖中。對於存在任何
一個點集合 B 的機率，我們則再次運用到對 B 的鄰居(A)個數進行 union bound 的技
巧。我們將 A 的角色表示於下圖中。 
 
  
55 
 
當熱門，例如：Dropbox 和 SkyDrive，使用者可以上傳他的資料，並且在其他電腦上
存取同步資料。雲端儲存服務通常只提供儲存空間，不具有資料運算能力，使用者只
能自行保護資料的隱私性與可靠性，我們的系統利用 AES 加密技術保護資料隱私
性，並且利用分散式的容錯編碼保障資料的可靠性。 
 
 
 
 如上圖，我們系統在各類別執行的流程，主要的 main function 在 ccis.java 裡，由
ccis 去新增 Main_UI 的 thread 來產生使用者介面，讓使用者在系統一開始時可以編輯
包括像系統資料夾路徑，共享資料夾路徑，還有一個隨機的字串。如果使用者需要的
話，會產生 Edit_syn_dir_UI 的 thread 來編輯共享資料夾的路徑。 
 當使用者正確輸入了三個參數之後，我們系統會進入下個階段，呼叫
Dec_download_thread.java 類別的裡面的 function 來進行檔案的解密與解碼。當進行檔
案的解密與解碼時，會需要利用五個不同的類別，Base64, Gauss, AES, group_gau_eli
所提供的 function 來進行檔案還原的計算。如果解密過程中發生了例外或是錯誤，這
會產生一個 UI 的 thread 來通知使用者。當全部的檔案運算完畢之後，無論成功或失
敗，會進入下一個階段。 
 接著系統會產生一個 Dec_upload_thread 的 thread 來執行無限迴圈，用來偵測是
否以系統資料夾內的檔案需要上傳或刪除。在這個物件中，需要用到七個類別，分別
是 Base64, Gauss, AES, group_gau_eli, File_delete_thread, upload_info, CloseHandler。在
這個階段我們系統就是依需求來呼叫不同類別的 function，但在這階段開始時，我們
系統也會產生一個 UI 的 thread upload info，告知使用者目前系統的狀況。並且處理
upload_info 裡的 exception listener 讓使用者關閉此 UI 後，我們系統將會關閉。 
 
[class ccis] 
 首先，先從 main()內部來看，系統一開始會進行一些前置作業，先將一些上次執
行的紀錄檔案刪除，目的只是為了降低後續系統執行時產生 bug 的機率。接著我們系
統會產生 main_UI 的物件，名稱為 a，此時系統的 main thread 會用一個無限迴圈來
等待使用者在執行 UI 後寫入一個隨意的字串到"Authenticate.txt"。 
 
57 
 
成功的還原資料。所以如果要更精簡運算時間的話，這部分是可以省略的，檔案
codewode symbol 數量低於 threashold 的將直接省略。 
 當系統整理出系統資料夾子子資料夾內的 file_record 與 dir_record，我們先依據
file_record 的內容依序處理，將處理的檔名，系統資料夾內相對路徑，還有共享資料
夾內的相對路徑丟給 Dec_download_thread 類別內的 decrypt_a_file() function 運算。 
 
[class Dec_download_thread] 
 當執行到這個類別時，我們系統已經確定要處理哪個檔案，所以在這個類別主要
是處理如何將檔案的 codeword 轉換成原始檔案。 
系統再還原檔案的做法是，根據使用者所指定的共享資料夾內檔案來還原檔案，
所以當初加密檔案時使用者指定了若干個共享資料夾，如果要還原時，使用者必須指
定"相同的"共享資料夾，包括數量。因為在一開始 main_UI 指定的共享資料夾個數會
影響到後續的運算參數，所以即使可以允許 k 個 codeword symbol 遺失，使用者還是
必須完整的指定出當初加密編碼檔案時所指定的共享資料夾，但是順序是可以不一樣
的。基於這個特性我認為可以做得更佳的有彈性，看是否有需要可以讓使用者少指定
一個共享資料夾，我們系統可以判斷是其中一個 symbol 遺失，依然可以將檔案還原。 
 那麼在 Dec_download_thread 類別還原檔案的主要計算在 decrypt_a_file() function
內，依需求去呼叫 base64, AES, Gauss, group_gau_eli 內的 function()來計算，如果有計
算錯誤發生的話，會新增一個 download_warn 物件 UI 來提示使用者，詳細的內容會
在後面的段落闡述。 
在還原檔案的計算過程，在系統資料夾內的檔案是不可被開啟的，這問題會出現
在 office 的系列。這問題目前我沒有辦法解決，只能用錯誤訊息來通知使用者。 
 
 
 
上圖是錯誤訊息的 UI，內容會依據不同的原因而顯示給使用者。目前仍未將可能
的錯誤原因做完，所以 UI 訊息的補充也是可以加強的部分。 
 在 decrypt_a_file()內，執行的順序是先將當初加密檔案的 encryption key 還原，然
後再利用 encryption key 來還原原本的資料。所以為了還原該檔案的 encryption key 的
資訊，系統會先去使用者指定的共享資料夾內搜尋相關的 codeword symbols，也就是
在該路徑的資料夾內，找尋 原始檔名+".$#_2"+"原始副檔名。 
59 
 
   */ 
  Element[] w = new Element[share_count] , 
            A = new Element[share_count] , 
            B = new Element[share_count] , 
      numerator = new Element[share_count] ,  //分子 
            denominator = new Element[share_count] ;  //分母 
  //初始 
  for( int k=0 ; k<share_count ; k++ ) 
  { 
   w[k] = pairing.getGT().newElement() ; 
   A[k] = pairing.getG1().newElement() ; 
   B[k] = pairing.getGT().newElement() ; 
   numerator[k] = pairing.getGT().newElement() ; 
   denominator[k] = pairing.getGT().newElement() ; 
  } 
   
  for( int k=0 ; k<share_count ; k++ ) 
  { 
   byte[] A_temp = new byte[152] ; 
   byte[] B_temp = new byte[152] ; 
    
   for( int l =0; l<152 ; l++ ) 
   { 
    A_temp[l] = codeword[k][l] ; 
    B_temp[l] = codeword[k][304+l] ; 
   } 
   A[k].setFromBytes(A_temp) ; 
 
   numerator[k].setFromBytes(B_temp) ; 
   denominator[k] =  pairing.pairing(A[k], hidx); 
   w[k] = numerator[k].add(denominator[k].invert()) ; 
  }   
     
  /** 
   * 現階段的 w[i] 是 session key 的 linear combination 
   * 所以跟反矩陣做運算。 
   */ 
  Element[] result_temp = new Element[share_count] ; 
  for( int k=0 ; k<share_count ; k++ ) 
   result_temp[k] = pairing.getGT().newZeroElement() ; 
61 
 
 我們系統會依造 codeword 的編號去將整個檔案還原，從 0 到 -1，將 codeword
還原成子檔案，再將每個子檔案組合起來。所以針對每個 codeword，先透過 BigInteger
函示將 codeword symbol 檔案從 byte array 轉成 BigInteger 
for( int k=0 ; k<_k ;k++ ) 
codeword_temp[k] = new BigInteger (data_shares[k]); 
 
接著進行矩陣相乘的動作來達成 decoding： 
BigInteger[] word = Gauss.matrix_mul(codeword_temp, inv) ; 
將 word 再轉回 byte array 並做 base64 decode 
for( int k=0 ; k<_k ; k++ ) 
{ 
data_shares[k] = word[k].toByteArray() ; 
 data_shares[k] = Base64.decode(data_shares[k]) ; 
} 
 
再來將每個 data_shares 組合成一個較大的 byte array file，並利用 AES-128 來解密 
file = AES.getdecrypt(EncryptionKey, file) ; 
在這個步驟做完之後，我們已經完成了每個檔案的子檔案的還原動作了，接著我
們在系統資料夾內產生一個資料夾叫做 tmp2 的資料夾，將之前計算出來的 file 寫入
tmp2 資料夾內存成 tmp 檔，最後將所有檔案利用 FileChannel 組合起來並寫到系統資
料夾內相對應的位置。所以我們系統是利用這個方式來處理檔案太大的問題。 
 
[class ccis] 
 當處理完一個檔案的時候，會看 file_record 內是否還有尚未處理的檔案，並依
上述的方法完成之後，接著要處理 dir_record。dir_record 裡面紀錄的是共享資料夾內
有的出現的子資料夾名稱。因此針對每個 dir_record 裡的紀錄，我們系統處理的方式
是依造 dir_record 紀錄的名稱在系統資料夾內相對路徑也產生相同名稱的資料夾，並
遞迴執行 search_data_dec()進到子資料夾內，利用同樣的方式將共享資料夾內的檔案
與資料夾還原到系統資料夾內。 
 最後是執行，sync_log()，利用系統資料夾內還原過後的檔案進行紀錄檔的編譯，
利用遞迴的方式將系統資料夾內的檔案與資料夾資訊都編寫到對應的紀錄檔。 
 當系統完成了所有檔案的還原並編寫好紀錄檔之後，此時後產生一個 thread 來執
行偵測的動作，我們系統便進入下一個階段。。 
     Thread det_up = (Thread) new Dec_upload_thread() ; 
     det_up.start() ; 
 
[class Dec_upload_thread] 
 當 main thread 產生了新的 thread det_up，在這新的 thread 會執行 run() function
的內容。在 run()裡面，首先會先物件 upload_info 的 UI，名稱是 a。產生這個 UI 的
63 
 
1. check_log() 
這個函式主要的目的是要偵測是否有新檔案新增到系統資料夾。 
2. auto_recovery()  
這個函式主要的目的在於偵測系統執行時，共享資料夾內是否有 symbol 檔案遺
失。 
3. File_delete_thread.det_del() 
偵測系統資料夾內原始的檔案是否有遺失。 
4. det_edit() 
偵測系統資料夾內原始檔案是否有被修改過。 
5. check_at_ccis_folder()  
為了避免共享資料夾內"@ccis_repository"的資料夾發生遺失導致後續處理的路
徑不一致，所以利用這個函式來檢查共享資料夾內"@ccis_repository" 
6. clean_tmp2() 
這個函式主要是在處理在解密與解碼的過程，我們系統會產生 tmp 檔案，而計算
結束之後，理應會將 tmp 檔給刪除。但有時候不知原因刪除會失敗，所以透過這個函
示來不斷的檢測，如果還有暫存的 tmp 檔，就一直執行刪除的動作。直到將 tmp 檔都
刪除完畢為止。 
 而在處理檔案的加密與編碼的部分，是在函式 encrypt_a_file()內執行，因為運算
的需要，還需要利用函示 data_share_compute()，gama_compute()，alpha_compute()，
generator_matrix()，generate_session_key()等的函式，這在後面的部分會詳細的說明。 
 我們接下來的報告會詳細介紹關於 encrypt_a_file()函式的內容，接著再補充說明
各種偵測是如何實做出來的。 
 encrypt_a_file()函式需要若干的參數，包括即將要進行加密編碼的檔案的 File 
class 物件，還有系統資料夾內的相對路徑，以及還有共享資料夾的路徑。在一開始
完成了前置的動作之後，接下來要運算檔案的大小： 
String src_file = new String(upload_file.getAbsolutePath()) ;      
int split_num=0 , remain_len=0;  // 計算總共要切割的長度與最後一塊的長度 
     
try{ 
FileInputStream src = new FileInputStream(src_file) ; 
     split_num = src.available()/10485760+1 ; 
     remain_len = src.available()%10485760; 
     src.close() ; 
}catch(IOException s) 
{ 
return false; 
} catch (Exception e) {  
 return false; 
} 
 
65 
 
update_key += "." ; 
} 
update_name =  update_name + "$#_1." + ame_temp[name_temp.length-1]; 
update_key =  update_key + "$#_2." + key_temp2[key_temp2.length-1]; 
這邊設計得邏輯是，檔案的 codeword 就是編號 1，encryption key 的 codeword 就
是編號 2。 
 接下來要處理檔案的部分，我們接下來要處理的部分是要利用 JAVA File class 的
file channel 的方法來達到切割大檔案的目的。我們將一個大的檔案以約 10MB 的大小
來切割檔案，將每個檔案切割成若干個 tmp 檔的小檔案，每個 tmp 檔都會有編號，從
0 到 split_num-1： 
for( int j=0 ; j<split_num ; j++ ) 
{ 
tmp_file_dir[j] = new String(tmp_dir) ; 
tmp_file_dir[j] = tmp_file_dir[j] +String.valueOf(j) +".tmp" ; 
} 
try{ 
FileInputStream src = new FileInputStream(src_file) ;  
 FileOutputStream[] write = new FileOutputStream[split_num] ; 
 for( int j=0 ; j<split_num ; j++ ) 
  write[j] =  new FileOutputStream(tmp_file_dir[j]) ; 
    
 FileChannel read_src = src.getChannel() ; 
 FileChannel[] write_tmp = new FileChannel[split_num] ; 
 for( int j=0 ; j<split_num ; j++ ) 
  write_tmp[j] = write[j].getChannel() ; 
    
 MappedByteBuffer[] mbuf = new MappedByteBuffer[split_num]; 
 for( int j=0 ; j<split_num ; j++ ) 
 { 
  if(j<split_num-1) 
 mbuf[j] = read_src.map(FileChannel.MapMode.READ_ONLY ,j*10485760 , 
10485760) ; 
  else 
 mbuf[j] = read_src.map(FileChannel.MapMode.READ_ONLY ,j*10486760 , 
remain_len) ; 
    write_tmp[j].write(mbuf[j]) ; 
 } 
    
 src.close() ; 
 read_src.close() ; 
67 
 
} 
}} 
 當完成了 encryption 初始的部分之後，接著就是要處理檔案的加密與編碼，我們
依序將每個 tmp 檔讀取出來，針對每個 tmp 檔，透過 AES-128 的加密：  
byte[] ciphtext = AES.getencrypt(Encryption_key, data) ;   
 
關於 AES 的使用我們系統還有使用 CBC 以及 PKCS5 的 padding，所以檔案加密
過後的檔案的大小膨脹會比較大，如果再加上後續的 Base64 編碼，則檔案會膨脹約
原本的 4/3 倍，關於這點可以研究是否還有需要使用。 
 接著將檔案透過 Base64 encode 過後，再轉換成 BigInteger 來跟 BigInteger 版本的
生成矩陣進行矩陣相乘的動作，來達到編碼的運算。最後將 n 個 symbol 轉換成 Byte 
array。 
 最後的動作，是要將檔案的 codeword 與 encryption key 的 codewords symbols 依
序寫到使用者指定的共享資料夾內。使用者在 UI 所輸入的共享資料夾從上至下依序
是 0 到 n-1，而所計算出來的 n 個 sumbols 也依造共享資料夾的順序寫入，E.G.第 0
個 symbol 寫到使用者指定的第一個共享資料夾內。而為了之後可以順利將正確的檔
案取回，寫入檔案會有一定的命名規則，其中每個檔案只有一個 encryption codeword，
命名規則是 file name.$#_2. Extension ，我們保留了原始檔案的檔名與副檔名，只在
中間加上了".$#_2"，由於每個 symbol 要寫到不同的共享資料夾內，所以每個 symbol
可以檔名都一樣。而檔案的 codeword symbol 命名規則是 file name.$#_1_ . 
Extension，其中  是編號，從 0 到 split_num-1。 
 結果如下圖： 
 
 
69 
 
另一個是"B_.txt"。我們紀錄檔的命名規則就是利用系統資料夾內相對路徑來作為命
名。 
 
 
 
上圖是系統資料夾內的檔案跟資料夾，其中有三個資料夾，分別是"123"，"a"，a
裡面還有一個資料夾"b"。 
 
 
如上圖所以會產生四個紀錄檔。無名紀錄檔就是紀錄系統資料夾最上層的資訊。
而"123.txt"，"a.txt"， "b.txt"就是紀錄相關的子資料夾的資訊。 
 
71 
 
  for( int i=0 ; i<content.length ; i++ ) 
  {    
   if(dir_content[i].getName().equals("tmp2") || dir_content[i].isHidden() || 
(dir_content[i].getName().startsWith("~") && dir_content[i].getName().endsWith(".tmp")) 
     || (dir_content[i].getName().endsWith("00")) 
     || (dir_content[i].getName().endsWith("tmp")) 
     || (dir_content[i].getName().startsWith("ppt") && 
dir_content[i].getName().endsWith(".tmp"))) 
    continue ; 
   content[i] = dir_content[i].getName() ; 
  } 
 當系統資料夾裡子資料夾內的檔案的個數比紀錄檔還多時，parse 出是哪個新增
的檔案或資料夾，並執行 directory_recur()。directory_recur()主要是針對使用者新增了
資料夾或是檔案到系統資料夾，如果是資料夾的話，那麼我們系統的執行邏輯是，在
使用者指定的共享資料夾內，也產生相同名稱的資料夾，然後在遞迴執行
directory_recur()，找到其子資料夾內的檔案，並將該檔案進行加密與編碼，結果將會
寫到各個共享資料夾內其跟原始檔案相同相對路徑的資料夾內。所以當 check_log()
偵測出新增的檔案與資料夾時，就會來執行 directory_recur()將資料夾內的所有檔案與
資料夾做適當的處理。 
 在 directory_recur()內，要處理的是檔案，則直接執行 encrypt_a_file()，並且重新
編輯紀錄檔。如果是資料夾的話，則先編輯紀錄檔，然在各個共享資料夾內的相對路
徑上產生相同名稱的資料夾，最後在遞迴到該子資料夾內。 
 接著要進行的是下一個偵測項目，是檢查共享資料夾內存放的各個檔案的
codeword symbol 檔案數量是否是有減少。檢測的方式是讀取系統資料夾的子資料夾
內的所有檔案，根據檔案的大小我們可以算出正確的 codeword symbol 的個數，所以
再依序去各個使用者指定的共享資料夾內統計檔案的個數。一旦有少的話，則會重新
加密與編碼該檔案一次。 
 下一個測試的項目是檢查系統資料夾內的檔案數量比紀錄檔的少，這種案例我們
設定是使用者想要刪除在雲端上的檔案，而又不想逐一地去各個共享資料夾內刪除檔
案，所以直接透過我們的系統就可以將所有雲端上的相關檔案刪除。我們是在
File_delete_thread 的類別中實作將檢測檔案刪除的動作。檢測的方式與判斷是否有檔
案新增的方法類似，只是這邊檢查是系統資料夾的子資料夾內的檔案數量比對應的紀
錄檔的內容數量少時，我們就會判定使用者刪除了系統資料夾內的檔案，所以系統會
去使用者指定的共享資料夾刪除相關的 codeword symbol 檔案。 
雖然對整體影響些微，但也可以將 File_delete_thread 類別內的函示寫到類別
Dec_upload_thread 內。會分開寫其實沒有特別的涵義，只是當初設計後來有經過多次
修改，才會出現變數名稱迥異與多餘類別的情況。 
 最後是偵測系統資料夾內的檔案是否有被修改過，判斷的方式依然是讀取系統資
料夾內的各個子資料夾，然後再讀取其對應的紀錄檔，我們偵測系統資料夾內的檔案
是否有修改過，是根據 JAVA File class 的函示 lastmodified()，此函式會 return 一個類
73 
 
 
 
 加密編碼時每個動作的花費比例 
 
 
 解密解碼時每個動作的花費比例 
75 
 
 
圖表三十三：授權驗證流程圖 
 
我們提出的可授權資料完整性驗證機制包含了三個階段：設定階段，授權階段，
以及驗證階段。設定階段包含了三個演算法：Setup，KeyGen，以及 TagGen。分別敘
述如下： 
 
 Setup(1k)→π：由系統管理者執行，用來設定整個系統環境。管理者輸入安全參數
k，Setup 產生系統的公開參數 π。 
 KeyGen(π)→(sk, pk, kt)：由使用者執行，用來產生使用者的金鑰組。使用者輸入
系統公開參數 π，KeyGen 產生使用者的公開金鑰 pk，私密金鑰 sk，以及授權用
的 key token kt。 
 TagGen(π, sk, m)→(σ, t)：由使用者執行，用來產生資料的 tag 和 tag 的辨識碼。
使用者輸入系統公開參數 π，私密金鑰 sk，以及使用者的資料 m，TagGen 產生可
驗證 m 的 tag σ，以及辨識 tag σ 的識別碼 t。在實際建置中，識別碼 t 為使用者
所挑選之字串。 
 
授權階段包含了兩個演算法：GenDK 以及 VrfyDK。分別敘述如下： 
 GenDK(π, skU, ktV)→dkU→V：由使用者執行，用來產生對應於被授權人的delegation 
key。使用者Ｕ（授權人）收到被授權人Ｖ的 key token ktV後，輸入系統參數 π，
自己的私密金鑰 skU，以及被授權人Ｖ的 key token ktV，GenDK 產生對應於Ｕ授
權給Ｖ的 delegation key dkU→V。 
 VrfyDK(π, dkU→V, pkU, pkV)→{true, false}：由儲存伺服器執行，用來驗證收到的
delegation key 是否正確。儲存伺服器收到使用者Ｕ傳來的 delegation key dkU→V
後，輸入系統參數 π，收到的 delegation key dkU→V，使用者Ｕ的公開金鑰 pkU，
以及被授權人Ｖ的公開金鑰 pkV，VrfyDK 驗證 delegation key dkU→V 是否正確。 
 
驗證階段包含三個演算法：GenChal，GenProof，以及 VrfyProof。分別敘述如下： 
 GenChal(π, t)→chal：由使用者或是被授權人執行，用來產生資料完整性驗證的
chalenge。使用者或是被授權人輸入系統參數 π，以及要驗證的資料區塊識別碼 t，
77 
 
 
 
  我們提出的可授權資料驗證方法經過正規的安全性證明，證明我們的方法是
Proof unforgeability，Proof indistinguishability，以及 Delegation key unforgeability。
Proof unforgeability 代表著儲存伺服器若能產生正確的 PDP response，則儲存伺服
器一定擁有正確的資料區塊。 
 
  Proof indistinguishability 代表著未被授權的第三方，無法分辨判斷儲存伺服器回
傳的 PDP response 是否是正確的，也就是未被授權的第三方無法驗證資料的完整
性。 
 
  Delegation key unforgeability代表未被授權的第三方無法偽造delegation key給自
己，即使是跟被授權人共謀，也就是被授權人無法轉授權驗證能力給第三方。 
 
 
 基於機器碼之 Windows 惡意程式行為分析雲端平台 
以下將分別介紹此雛型系統之實際佈建狀況、系統架構、工作流程、系統實作與效能
分析。可顯示本計畫除新興技術的研究之外，亦注重務實的系統開發可行性。 
79 
 
 
圖表三十五：網頁資料爬取子系統，可蒐集網頁上的資料進行分析 
81 
 
 工作流程 
本系統的主要流程可分為兩種，彼此間連繫的管道是透過儲存子系統，詳細如下： 
1.由檔案來源子系統至儲存子系統:負責將檔案存入系統中，同時產生後續分析所
需的工作識別。此處的檔案來源目前有三種:使用者上傳、硬碟讀取和Ｃrawler。 
2. 由儲存子系統至分析器管理子系統:負責處理未分析的檔案。首先至儲存子系統
中的 Redis 拿取工作識別後，再去向 Cassandra 拿取檔案來進行分析，之後儲存結果。 
 
 
圖表三十七：基於機器碼之 Windows惡意程式行為分析雲端平台工作流程 
83 
 
本平台的運行主要下的指令如圖表三十八，我們將所有系統指令包裝成一個執行檔
案。並且會有許多個元件，可以互相的配合執行。./secmap 是整合本系統個元件主要執行
程式，透過此介面可以快速啟動、停止下列四個系統主要元件(role)：1.)cassandra，本系統
中用來儲存大量資料的分散式資料庫、 2.)dispatcher，用於儲存工作與分配的佇列、
3.)nutch，為本系統來爬取網路資料的元件及 4.)各種 analyzer，掛載於本系統的不同分析
器。starttable 和 stoptable 是兩個 Hash 資料結構，將系統元件的名稱對應到一字串值。此
介面利用 starttable 將啟動系統儲存及網路爬取元件的所需執行的動作儲存，並利用
stoptable 將停止系統儲存及網路爬取元件的動作儲存，並根據所取得的參數執行相對應的
動作。透過使用 starttable 和 stoptable，可以同時啟動多個不同的元件。例如: ./secmap start 
cassandra redis，便可以一次將 cassandra 和 redis 運行起來。   
說明如下: 
 參數介紹： 
cmd：代表所要執行的動作，分為 start 和 stop兩種指令。 
roles[] ：執行指令的目標元件的陣列，共有 cassandra、nutch、dispatcher、
analyzer(以名稱區別) 
 判別執行指令是’start’或是’stop’。 
 對 roles裡面的各個元件，根據所要執行的指令(stop或 start)，查詢並執行其
對應(starttable 或 stoptable)的指令。 
 
85 
 
 
圖表四十一：NUTCH之原始碼物件以及 NUTCHSLAVE.rb 
 
當我們在主節點執行 nutch 後，主節點(nutch master)便會自動將所需執行的工作分配
至附屬節點(slave)做網頁爬取的動作。我們改寫 nutch 的程式碼，在做網頁爬取的部分我們
加入了 NutchSlaveCrawler()，此函數利用 JAVA 提供的 Runtime 及 Process 函式庫去執行
NutchSlave.rb，並將爬取下來的網頁檔名做為其參數。NutchSlave.rb 負責將檔案上傳至我
們系統。 
以下將做說明: 
參數介紹： 
 filename：Nutch 所抓取下來的檔案名稱。  
 首先呼叫 generateSecmapUID，計算出檔案的 MD5以及 SHA1值，再加上檔案本身
大小作為其唯一識別(UID)回傳。 
 接著利用 loadCommandsTable()取得各個函式庫的位置。 
 透過 commandsTable，NutchSlave.rb先執行 putToCassandra將檔案內容及屬性
存入分散式惡意樣本資料庫內。 
 最後利用 putToRedis 將檔案的唯一識別輸入特定優先權的工作佇列，等待分析器
處理。
87 
 
 
圖表四十三：putToCassandra.RB 之虛擬碼 
 
此程式 putToCassandra.rb 的作用是將取得的檔案名稱、取得的時間、檔案的來源以
及檔案內容存入資料庫中。 
以下將按步驟解說，如上圖所示: 
(一) 首先，透過 parseToHashTable 先從 ARGV[] 內取出檔案的基本資料，有檔案名稱、
來源和取得時間。 
(二) 再來，連線至資料庫，其中 CassandraHosts.pickAtRandom()是用來連到不同的資
料庫，回傳的值是任一資料庫的 IP地址，目的是為了流量能夠均勻分到每一台分
散式的資料庫上。 
(三) 取出檔案資料。 
(四) 針對檔案內容透過 generateSecmapUID()產生相對應的 ID，而產生方法則是將檔
案內容作 MD5以及 SHA1，並將兩者相連最後再連上檔案大小而得。 
(五) 最後透過 client.insert 來對資料庫的相對應欄位(super column:SUMMARY 和
column name:content…etc)填入相對的值(value)。 
 
 
圖表四十四：AnalyzerInvoker 之虛擬碼 
89 
 
(五) 當行程執行超時候，作業系統會自動發出 SIGXCPU 訊號並結處該行程，SIGXCPU是當
一個行程資源使用量超過系統規範實，用來通知該行程的訊號。我們利用
Singnal.trap()去抓取 SIGXCPU訊號，並執行 timeout()紀錄分析器運行的狀況。 
(六) 執行 command將分析器運行起來。 
 
 
圖表四十六：getTaskID.rb 之虛擬碼 
 
此程式 getTaskID.rb 是從 Redis 中取出一組 TaskID。其中，Redis 為一 Queue 的資
料結構，在此基礎上實作出優先序(priority)的功能;而 TaskID 則是一組用來查詢資料庫的
key，key 的產生法法於 putToCassandra.rb 處有說明。 
以下將對上圖做詳述: 
(一) 首先，透過 parseToHashTable 先從 ARGV[] 內取出分析器名稱(analyzerName)。 
(二) 連線到 Redis server，其中的變數 REDIS_ADDR 和 REDIS_PORT 分別代表 IP 以及
port，EX:1.2.3.4 和 10001。 
(三) 在 For 迴圈內部則是藉由 redis.lpop()來內取出 Redis 中的一筆資料，從優先序高
的先取，取得後離開迴圈。 
(四) 最後結果，回傳 taskID 或是提示 Redis內已無 taskID並顯示工作完畢。
91 
 
(一) 首先，連線至資料庫，其中 CassandraHosts.pickAtRandom()是用來連到不同的資料
庫，回傳的值是任一資料庫的 IP 地址，目的是為了流量能夠均勻分到每一台分散式
的資料庫上。 
(二) 透過 client.get()函式以及 taskID 從資料庫中取得相對應的檔案。 
(三) 設定分析器的路徑，由 ANALYZER_HOME 和 analyzerName 組成，之後儲存檔案的資料
夾就在此路徑下。 
(四) 設定檔案的儲存路徑，由 analyzerPath 和 outfile組成。 
(五) 將檔案寫入(四)的路徑中。 
 
 
圖表四十九：getReportFromCassandra.rb 之虛擬碼 
 
此程式 getReportFromCassandra.rb 是藉由 taskUID 和 ANALYZER_TYPE 來從資料
庫中取得相對應的報告。 
以下將對上圖做詳述: 
(一) 參數介紹: 
taskUID: 由分析檔案產生的 ID，產生方法則是將檔案內容作 MD5以及 SHA1，並將兩
者相連最後再連上檔案大小而得。 
ANALYZER_TYPE: 分析器的種類名稱，依據此參數來區別報告。 
(二) 連線至資料庫，其中 CassandraHosts.pickAtRandom()是用來連到不同的資料庫，回
傳的值是任一資料庫的 IP 地址，目的是為了流量能夠均勻分到每一台分散式的資料
庫上。 
(三) 透過 client.get()再加上 taskUID 以及 ANALYZER_TYPE 來取得相對應的報告。 
(四) 回傳報告的結果。 
 
93 
 
 效能分析 
為了確認本系統的效能及可行性，我們設計了一套簡單的實驗。測試此系統在不
同配置下實際運行的狀態，並與單獨分析器做比較。在此實驗中，系統採用的分析器
皆 ClamAV。ClamAV 為一套開放原始碼的防毒軟體，用來偵測惡意軟體，普遍用於
郵件伺服器。實驗所使用的機器皆使用 Intel(R) Core(TM) i7 CPU 搭配 16G 的記憶體。
在此實驗中，本系統分別掛載執行一組 ClamAV 及四組 ClamAV，並與單獨執行
ClamAV 相比較。實驗分析目標為我們預先收集的惡意軟體樣本約 22000 隻，主要以
windows 的可能執行檔(exe)和動態連結函式庫為主(dll)。 
如圖表五十一，此次實驗先以單獨執行 ClamAV 分析樣本，共需 992 分鐘處理完
22,000 個檔案。與單獨執行 ClamAV 相比較，本系統在掛載單一組 ClamAV 時，共需
要 1,110 分鐘處理完 22,000 個檔案，整體效率約為單獨執行 ClamAV 的 0.89 倍。工作
分配及結果儲存約種體時間的 10%，對系統負擔不大。而本系統掛載四組 ClamAV 時，
只需花 282 分鐘，便可處理完全部 22,000 個檔案，整體效率為單獨執行 ClamAV 的 3.5
倍、系統掛在單一組 ClamAV 的 3.9 倍，相當接近原先的期望值 4 倍，可以說明系統
對於檔案分配、結果儲存的額外負擔小於整體執行的 0.1 倍。 
下圖為此實驗每 50 分鐘處理個數的直方圖，根據此圖可說明此系統的效能並不會
因為時間或處理個數的增加而減少，維持穩定的產出，足以說明系統的可行性，也可
以說明系統的效能會隨著分析器的增加而上升，具有相當高的可擴充性。 
 
圖表五十一：每 50分鐘分析個數直方圖。 
95 
 
 運行截圖 
 
圖表五十三：分析過程之紀錄檔案截圖 
 
圖表五十四：放分析工做至惡意程式分析雲端平台 
97 
 
Guest 中我們製作一個 Monitor & Control Center 來統籌該台實體機器上之虛擬環境整體的
入侵偵測與反制工作。以下是每部份具體系統建置內容： 
 系統呼叫之攔截 
在系統呼叫這部分，我們提出的方式是使用特權指令(privileged instruction)來達到
攔截的效果。特權指令是指 x86 架構下一些需要在 root mode 才能夠被執行的指令，因
為這些指令會洩漏或是變更到系統底層硬體的資訊，這些資訊必須透過 Hypervisor 模
擬，不能讓他們於硬體上直接執行，例如 cpuid 就是特權指令的一種(cpuid 會回傳 cpu
的相關硬體規格參數)。 
 
 
圖表五十七：攔截系統呼叫流程圖 
 
 
圖表五十八：linux/arch/x86/kernel/entry_64.S 
99 
 
 
 
圖表六十一：監控系統呼叫(NtOpenFile)執行結果 
 
填入特權指令之後，一但 Guest VM 要執行系統呼叫，就會執行到我們所填入的特
權指令(步驟 4)，而因為 Guest VM 不在 root mode，所以就會產生 VMExit 而進入位於
Xen 的 VMExit_handler。我們在 VMExit_handler 中會去判斷是否為系統呼叫所引起的
cpuid VMExit，如果這種情況，就會通知 Dom 0(步驟 7)，這樣就能達到監控攔截系統
呼叫的功能。為攔截 NtOpenFile 的結果，紅色框框內為開啟的檔案路徑。 
 
 
101 
 
 
圖表六十三：Guest VM部分記憶體區塊內容 
 
 
圖表六十四：Guest VM部分記憶體內容轉換結果 
 
存取完記憶體後接下來的一大挑戰是對於所讀取到的記憶體區塊的內容必須要進
行解析，memory 裡的資料是屬於 low level information，因此我們必須將 low level 
information 轉換成 high leve information，但在解析部分對於可疑的指令和程式流程轉
移，我們還需要進一步開發相應的技術。另一方面，IDS/IPS 會需要對於記憶體空間有
即時的監控能力。也就是說需要能即時掌握記憶體中的資料變化。 
 
103 
 
 
 
圖表六十七：取得目標 process 資訊(name$pid$cr3) 
 
 
圖表六十八：透過 guest pagetable 找到 process所屬 gfn 資訊 
 
 
圖表六十九：限制 Guest VM 存取 memroy block 
 
解析完記憶體區塊內容後，根據解析的結果來決定每個 memory page 在 EPT Entry
中的權限，透過權限管理的方式讓惡意軟體無法使用記憶體資源，藉此達到阻止惡意
軟體的目的。接下來以圖表七十搭配實際範例操作截圖來進行說明，範例程式為一個
 
105 
 
 
圖表七十二：tools/ioemu-qemu-xen/fs-ntfs.c 
 
 
圖表七十三：tools/ioemu-qemu-xen/fs-ext2.c 
 
在磁區觀測的部份，我們可以很清楚看到，從 Guest VM 來的磁區存取請求經由
Hypervisor 轉換後會送交給 Qemu 處理，因此所有的磁區操作最後都會經由 Qemu 來讀
寫該系統的區塊裝置(像是映像檔或者是硬碟上的某一個分割區)。我們藉由修改 Xen
中 Qemu 的程式碼(位於 tools/ioemu-qemu-xen/)，在 qemu-dm 運行的主迴圈 main_loop
之外新增一個執行緒來做為監控中心與 Qemu 的介面聆聽及回覆監控中心的存取請
求，檔案系統層級的存取部份，我們結合了 debug-fs 及 ntfs-3g 兩套函式庫來分別支援
ext 和 ntfs 檔案系統，在 Qemu 的程式碼加入了兩個檔案 fs-ext2.c 及 fs-ntfs.c，遵循該
函式庫寫出底層 I/O 的對應函式，如此一來該函式庫即可透過這些函式直接使用 Qemu
中的 block I/O 函式存取底層的磁區。 
而關於制動的部分，我們使用 Qemu 將可疑檔案內容讀取出來做掃描，若該檔案
含有病毒或其他惡意內容，我們便透過 Qemu 將該檔案刪除或將含有惡意內容的部份
107 
 
在阻擋對內的網路攻擊時，同時我們將透過一個反向 Network Intrusion 
Prevention System 來阻擋雲端平台上的攻擊實驗，可能在無意間影響到外部跨
實體機器雲端網路或是純粹的外部網路的安全。並且，將在此設計用在各個區域
的雲端網路之間，因此不同雲端間的網路或是雲端間的內部網路都有相對應的機
制防禦與反制網路攻擊，以提供高安全性的實驗。 
 
 ClamAV 即時防護系統 
 
 
圖表七十五：ClamAV即時防護系統概念圖 
 
 
圖表七十六：ClamAV即時防護系統架構圖 
 
109 
 
 
圖表七十八：Guest VM使用者開啟病毒檔案 
 
 
圖表七十九：ClamAV存取 Guest VM 病毒檔案畫面 
111 
 
 
肆、  技術方案優越性  
相較於現有之系統，本計畫所開發各項技術與雛型系統之技術方案優越性如下： 
 
 支援多樣功能之雲端資料安全儲存 
 保護隱私的雲端入侵偵測 
(1) 隱私性評估 
我們針對單一關鍵字做隱私評估，其中，使用者上傳資訊的隱私和加密金鑰雜湊
部份的長度有關，長度越長會讓候選者名單變小；反之長度越短會讓候選者名單
變大，更能保護上傳資訊。實驗結果如下圖所示。 
 
 
圖表八十二：單一關鍵字"content"之隱私評估 
 
橫軸代表加密金鑰雜湊部分的長度分別為1～8bits，縱軸代表包含關鍵字"content"
的 rule 在候選者名單中所占的比率，即 
 
我們可以藉由調整加密金鑰雜奏部分的長度來改變候選者名單的大小，來決定保
護上傳資訊的隱私。 
(2) 偵測率評估 
我們使用 DARPA98 當作資料集來測試 SNORT 和我們所建立的實驗，DARPA98
是一個收集網路封包的集合，它使用區域網路去模擬出真實網路的環境去蒐集裡
面一段時間內的封包，其中在這段時間內，它會產生一些假攻擊，散佈在這個網
路環境中。DARPA98 可以被用來當作訓練的資料來訓練網路型的入侵偵測系
統，再藉由分析網路封包來判斷此訓練的結果成效如何。 
我們發現 SNORT 和我們建立的實驗所產生的警告數目一樣多，由此我們可知，
藉由這個方法轉換 SNORT 規則並不會影響到原來的偵測能力。若要加強其偵測
能力，則我們必須擁有更佳偵測率的 SNORT 規則，才有辦法增加偵測能力。 
(3) 效能評估 
113 
 
 
 
圖表八十四：Computation cost of each algorithm 
 
使用者以及被授權者只需儲存常數般的儲存量，儲存伺服器則因為需要儲存資料
區塊，所以需要跟資料量一樣級數的儲存量。 
 
圖表八十五：Computation cost 
 
授權階段的通訊量也是常數大小，設定階段因為包含上傳資料的傳輸量，所以跟
資料量相關，資料驗證階段因為需要傳送挑選哪些資料區塊做完整性檢驗，所以
傳輸量最多也會跟資料區塊數量有關。如果使用隨機亂數產生器來決定哪些資料
區塊要做檢驗，則只需要傳送亂數種子給儲存伺服器，這可以將資料驗證階段的
傳輸量降低到常數大小。 
 
圖表八十六：Computation cost 2 
 
115 
 
 利用 Priority Queue 工作分配排程與記憶體儲存系統大幅改善分析速度 
此平台包含各種功能性節點，例如：蒐集檔案節點、惡意程式分析器節點、資料
庫節點等，從建立分析工作到分析結果出現，中間透過了許多的網路溝通。而這些工
作分配是否能有效率地傳輸，是本平台提高分析產能的重要技術之一。為了節省空間
使用，盡量避免分析相同的檔案或是多餘的檔案複製等。同時，減少硬碟讀寫次數和
系統輸入輸出能夠大量的增加檔案分析的速度。為了達到以上的目的，本系統將會把
部分的資料保存在記憶體中，以減少讀寫的時間開銷。 
分析工作的排程能夠縮短反應時間。每個被產生的分析工作都有它的優先權，以
實行不同的反應時間。例如，背景執行的網路擷取的檔案可以隨時被暫停，空出資源
來回應使用者查詢的檔案檢測。優先權的高低差異讓本系統可以有彈性的去管理分析
工作，動態地調動運算資源給較緊急的分析工作。 
 
 提供掛載介面以彈性擴充分析模組，相較於傳統封閉式設計有更高的開發潛力 
程式分析可以用許多不同面向的分析技術來判別該樣本是否為惡意。又隨著攻擊
手法的日新月異，要持續地維護這些分析工具才能符合時下的需求。一旦有新的分析
技術的產生，系統開發人員必須花費時間在機器環境的更新以及架設，十分耗費人力。
本子系統欲設計一個可擴充式掛載介面，可以輕易地安裝新形態的分析工具，移除較
為老舊的版本。為了達到此目的，我們需要制定一套惡意程式分析的框架，來幫助系
統知道各分析工具的運行方式、初始化和資源需求等，利用一個通用的方式來描述分
析工具的作業流程。其部分包含如何運行的指令、傳入的參數、套件的安裝、環境需
求和結束時資源歸還等。設計好這個可擴充式掛載介面，往後就可以供相關的學術研
究使用，掛載自行開發的分析工具，以驗證分析方法的正確性。 
 
 
 基於 Xen Hypervisor 之即時雲端環境入侵偵測與反制(ICP) 
 
  Ether XenAccess 本平台 
Xen版本支援性 Xen3.1 Xen3.0~Xen3.3 Xen4.0 
GuestVM支援性 32 bits hvm 
guest 
32 bits pv / hvm 
guest 
64 bits hvm 
guest 
Extended Page Table 
Support 
× × ✓ 
系統呼叫之攔測 ✓ × ✓ 
記憶體內容物件之讀
取、解析與制動 
∆ (只監測是否對
memory有寫入的
動作，並無讀
取、解析和制動
記憶體內容物件
功能) 
∆（只有讀取與解
析記憶體內容物
件，無制動功能） 
✓ 
117 
 
 
攻擊行為 Emulab DETER 
TESTBED 
@TWISC 
vSWOON 
War Driving  N N Y 
MAC Spoofing N N Y 
IP Spoofing Y Y Y 
Eavesdropping Y Y Y 
Wireless Eavesdropping N N Y 
Man-in-the-Middle Y Y Y 
Evil Twin N N Y 
DDoS Y Y Y 
 
 
 
 
 
 
Not Emphasized 
119 
 
提供大量的分析產能。由於國內學術界內尚未有相關的惡意程式分析平台，故本研究
將著力於研究雲端分析平台之系統架構，以及實際地開發出一套可結合不同分析模組
的雲端系統。開發完成的雲端系統，可以提供龐大的運算資源，供惡意程式研究之相
關單位使用，或是提供實際的惡意樣本分析服務。 
本平台也整合了網頁爬取子系統，該系統將會持續性的蒐集網路上可連結之資
料，並且下載可執行檔案至分析平台內進行分析。不同以往被動式的誘捕系統，此方
式可以更主動地去尋找可能受感染的網站，以搜尋最新的惡意程式樣本。目前有架設
兩台網頁爬取節點，單日可瀏覽約二十萬筆的網路連結。藉著 Map-Reduce 的運算技
術，可以過濾重複之檔案連結，以減少重複的檔案爬取。 
目前此平台已整合本實驗室所開發之動態惡意程式分析模組。此分析技術因需要
動態地運行惡意程式樣本，所以需要耗費大量的運算資源和記憶體。也因此，上述之
分析模組不適合安裝在一般的個人電腦之中。透過本計畫所開發之惡意程式分析雲端
平台，將要檢驗的可疑樣本，全數放到雲端分析伺服器上。再由系統自動分配其分析
工作，以快速地達成分析的目的。除此之外，惡意程式研究人員，也可自行開發其特
有的分析模組，透過分析模組掛載介面，安裝於此平台上，以驗證其分析效果。經由
在本報告內的效能分析驗證，利用多核心運算單元可以提供與預期相似的運算效能（理
想值為 4 倍，實驗結果為 3.9 倍）。由此可證，本系統整合多台分析模組並不會產生過
大的運算項能負荷。 
在惡意樣本儲存方面，利用雲端儲存技術，可以提供常數時間的樣本存取。不同
於以往傳統關聯式資料庫，可能會因為資料庫內容變大，而查詢的時間變長。同時，
將單一個檔案分散儲存在不同機器內，可以方便做備份且加速讀取速度。目前已經蒐
集有約兩萬隻的惡意程式樣本，並且儲存在惡意樣本資料庫內，並且皆有其動態程式
行為分析報告。 
除此之外，本計畫透過多方面的管道爭取到豐富的產學交流機會。此『基於機器
碼之 Windows 惡意程式行為分析雲端平台』提供惡意樣本分析服務，正與法務部調查
局、中華電信、趨勢科技、交通大學資訊服務中心等單位，做惡意樣本的知識交流。
未來將持續透過與最前線的資安單位合作，讓本研究計畫可貼近真實的資安攻防事
件。並透過合作交流擴大樣本蒐集並藉此調整分析引擎，以開發出更貼近目前實務需
求的惡意程式分析系統。 
 
 與基於 Xen Hypervisor 之即時雲端環境入侵偵測與反制 
我們將自己開發出的 Xen Hypervisor 模組搭配 ClamAV 組合成一個基於 Xen 
Hypervisor 的即時雲端環境入侵偵測系統，本系統管理者可透過前端 Web Interface 來
監控在 Xen Hypervisor 中運行的 Guest VM，而監控方式又分為兩種，第一種是線上即
時監控，使用者在使用 Guest VM 時開啟的所有檔案都會即時的傳送給位於 Dom0 的
ClamAV 進行掃描，掃描結果亦會即時的顯示在網頁介面上。第二種是離線掃描，管
理者可透過 Web Interface 將指定掃描的路徑傳給 ClamAV，ClamAV 將路徑下所有檔案
掃描完成後，便會把掃描結果顯示在網頁介面上。 
本系統雖能以 ClamAV 病毒引擎掃瞄出病毒檔案，但仍有許多可以改進的空間。
以偵測的面向來說，目前僅提供系統呼叫、記憶體和檔案系統監測，但就使用現況而
121 
 
導入虛擬機技術之網路測試平台可能衍生相對的安全性問題，諸如：實驗隔離性
(Isolation)、虛擬機安全漏洞防護等問題。本計畫將開發對應的安全防護機制，避
免惡意的使用者藉由虛擬化技術之漏洞破壞網路測試平台。 
 虛擬機 QoS 管理 
本計畫將利用今年產出的虛擬機效能評估報告，發展出一套配置虛擬化實驗節點
的佈署機制，以確保每台虛擬節點擁有足夠的資源進行網路實驗，並提升實驗結
果的仿真性。 
 開發適用於虛擬機環境之無線網路測試工具 
本計畫將利用 QEMU 的 I/O 模擬機制來模擬新的無線網路介面，提供更多元的
網路測試環境。 
 
 
綜合以上所述，本計畫除達成所規劃之各項研究目標與具體的學術與產學合作成果，
並完成多項雛型系統之研發。各研究項目將在未來進行更深入的研究與更廣泛的產業合作
與推廣，可望能對目前雲端安全技術的發展現況做出貢獻。 
123 
 
[19] Alexandros G. Dimakis, Brighten Godfrey, Yunnan Wu, Martin J. Wainwright, and Kannan Ramchandran. 
Network coding for distributed storage systems. IEEE Transactions on Information Theory, 6(9):4539–4551, 2010.  
[20] K. V. Rashmi, Nihar B. Shah, P. Vijay Kumar, and Kannan Ramchandran. Explicit construction of optimal exact 
regenerating codes for distributed storage. In Proceedings of the 47th annual Allerton conference on 
Communication, control, and computing, Allerton’09, pages 1243–1249. IEEE Press, 2009. 
[21] Nihar B. Shah, K. V. Rashmi, and P. Vijay Kumar. A flexibile class of regenerating codes for distributed storage. In 
Proceedings of IEEE symposium on Information Theory 2010, pages 1943–1947. IEEE Press, 2010. 
[22] Soroush Akhlaghi, Abbas Kiani, and Mohammad Reza Ghanavati. A fundamental trade-off between the download 
cost and repair bandwidth in distributed storage systems. In Proceedings of IEEE International Symposium on 
Network Coding 2010 – NetCod, pages 1–6, 2010. 
[23] Salim El Rouayheb and Kannan Ramchandran. Fractional repetition codes for repair in distributed storage systems. 
In Proceedings of the 48th annual Allerton conference on Communication, control, and computing, Allerton’10. 
IEEE Press, 2010. 
[24] Alessandro Duminuco and Ernst W. Biersack. Hierarchical codes: A flexible trade-off for erasure codes in 
peer-to-peer storage systems. Peer-to-Peer Networking and Applications, 3(1):52–66, 2010. 
[25] Yuchong Hu, Yinlong Xu, Xiaozhao Wang, Cheng Zhan, and Pei Li. Cooperative recovery of distributed storage 
systems from multiple losses with network coding. Selected Areas in Communications, IEEE Journal on, 
28(2):268–276, 2010 
[26] Frederique Oggier and Anwitaman Datta. Self-repairing homomorphic codes for distributed storage systems. In 
Proceedings of the 30th IEEE international conference on Computer communications 2011. IEEE Press, 2011. 
[27] Theodoros K. Dikaliotis, Alexandros G. Dimakis, and Tracey Ho. Security in distributed storage systems by 
communicating a logarithmic number of bits. In Proceedings of IEEE symposium on information theory 2010. 
IEEE Press, 2010.  
[28] K. V. Rashmi, Nihar B. Shah, and P. Vijay Jumar. Enabling node repair in any erasure code for distributed storage, 
2011. 
[29] Sameer Pawar, Salim El Rouayheb, and Kannan Ramchandran. On secure distributed data storage under repair 
dynamics. Technical Report UCB/EECS-2010-18, University of California Berkeley, EECS, 2010. 
[30] Dimitris S. Papailiopoulos and Alexandros G. Dimakis. Distributed storage codes meet multiple-access wiretap 
channels. In Proceedings of the 48th Annual Allerton Conference on Communication, Control, and Computing, 
Allerton’10, pages 1420–1427, 2010. 
[31] Alexandros G. Dimakis, Vinod Prabhakaran, and Kannan Ramchandran. Decentralized erasure codes for distributed 
networked storage. IEEE/ACM Transactions on Networking, 14:2809–2816, 2006. 
[32] Hsiao-Ying Lin and Wen-Guey Tzeng. A secure decentralized erasure code for distributed network storage. IEEE 
transactions on Parallel and Distributed Systems, 21:1586–1594, 2010. 
[33] Hsiao-Ying Lin and Wen-Guey Tzeng. A secure erasure code based cloud storage system with secure data 
forwarding. manuscript. 
[34] Hsiao-Ying Lin, Wen-Guey Tzeng, and Bao-Shuh Lin. A Decentralized Repair Mechanism for Decentralized 
Erasure Code based Storage Systems. IEEE International Conference on Trust, Security and Privacy in Computing 
and Communications, 2011. 
[35] Ateniese, G., Burns, R., Curtmola, R., Herring, J., Kissner, L., Peterson, Z., Song, D.: Provable data possession at 
125 
 
(2010)  
[51] Wang, Q., Wang, C., Li, J., Ren, K., Lou, W.: Enabling public verifiability and data dynamics for storage security 
in cloud computing. In: Proceedings of the 14th European conference on Research in computer security. pp. 
355–370. ESORICS’09 (2009) 
[52] R. Perdisci, A. Lanzi, and W. Lee, "McBoost: Boosting Scalability in Malware Collection and Analysis Using 
Statistical Classification of Executables," in Computer Security Applications Conference, Annual, Los Alamitos, CA, 
USA, 2008, vol. 0, pp. 301-310. 
[53] P. Baecher, M. Koetter, M. Dornseif, and F. Freiling, "The nepenthes platform: An efficient approach to collect 
malware," IN PROCEEDINGS OF THE 9 TH INTERNATIONAL SYMPOSIUM ON RECENT ADVANCES IN 
INTRUSION DETECTION (RAID, p. 165--184, 2006. 
[54] Y. Ye, T. Li, Y. Chen, and Q. Jiang, "Automatic malware categorization using cluster ensemble," Proceedings of the 
16th ACM SIGKDD international conference on Knowledge discovery and data mining, p. 95–104, 2010. 
[55] S. Muhlbach and A. Koch, "A Dynamically Reconfigured Network Platform for High-Speed Malware Collection," 
Proceedings of the 2010 International Conference on Reconfigurable Computing and FPGAs, p. 79–84, 2010. 
[56] C. Leita and M. Dacier, "SGNET: A Worldwide Deployable Framework to Support the Analysis of Malware Threat 
Models," Proceedings of the 2008 Seventh European Dependable Computing Conference, p. 99–109, 2008. 
[57] M. Bailey, J. Oberheide, J. Andersen, Z. M. Mao, F. Jahanian, and J. Nazario, "Automated classification and analysis 
of internet malware," Proceedings of the 10th international conference on Recent advances in intrusion detection, p. 
178–197, 2007. 
[58] G. Wicherski, "peHash: a novel approach to fast malware clustering," Proceedings of the 2nd USENIX conference on 
Large-scale exploits and emergent threats: botnets, spyware, worms, and more, p. 1–1, 2009. 
[59] Y. Ye, T. Li, Q. Jiang, Z. Han, and L. Wan, "Intelligent file scoring system for malware detection from the gray list," 
Proceedings of the 15th ACM SIGKDD international conference on Knowledge discovery and data mining, p. 
1385–1394, 2009. 
[60] Y. Ye, T. Li, Y. Chen, and Q. Jiang, "Automatic malware categorization using cluster ensemble," Proceedings of the 
16th ACM SIGKDD international conference on Knowledge discovery and data mining, p. 95–104, 2010. 
[61] V. Mulukutla, "Wolfsting: Extending Online Dynamic Malware Analysis Systems by Engaging Malware.," 2010. 
[62] M. F. Zolkipli and A. Jantan, "Malware Behavior Analysis: Learning and Understanding Current Malware Threats," 
in 2010 Second International Conference on Network Applications, Protocols and Services, 2010, p. 218–221. 
[63] X. Jiang, Z. Hao, and Y. Wang, "A Malware Sample Capturing and Tracking System," in 2010 Second WRI World 
Congress on Software Engineering, 2010, p. 69–72. 
[64] D. Cavalca and E. Goldoni, "An Open Architecture for Distributed Malware Collection and Analysis," Open Source 
Software for Digital Forensics, p. 101–116, 2010. 
[65] Z. Tzermias, G. Sykiotakis, M. Polychronakis, and E. P. Markatos, "Combining Static and Dynamic Analysis for the 
Detection of Malicious Documents," 2011. 
[66] M. Apel, J. Biskup, U. Flegel, and M. Meier, "Early Warning System on a National Level–Project AMSEL," in 
Proceedings of the First Workshop on Early Warning and Network Intelligence (EWNI), Hamburg, Germany, 2010. 
[67] B. J. Nabholz, "Design of an Automated Malware Analysis System," College of Technology Directed Projects, p. 4, 
2010. 
[68] Y. M. Wang, D. Beck, X. Jiang, and R. Roussev, "Automated web patrol with strider honeymonkeys: Finding web 
127 
 
[95] D. Ott,"Virtualization and Performance: Understanding VM Exits," (http://itknowledgehub.com/tag/vm-exit/) 
[96] VMWare,"Performance Evaluation of Intel EPT Hardware Assist," 
(http://www.vmware.com/pdf/Perf_ESX_Intel-EPT-eval.pdf) 
[97] B. Cogswell and M. Russinovich, "RootkitRevealer," Available online as www. sysinternals. 
com/ntw2k/freeware/rootkitreveal. shtml. 
[98] S. Sparks and J. Butler, ""Shadow Walker :¨ Raising the bar for rootkit detection," in Black Hat Japan, 2005, p. 
504¡V533. 
[99] B. Payne, M. Carbone, and W. Lee, "Secure and flexible monitoring of virtual machines," in ACSAC, 2007, pp. 
385-397. 
[100] S. Jones, A. Arpaci-Dusseau, and R. Arpaci-Dusseau, "VMM-based hidden process detection and identification using 
Lycosid," in Usenix International Conference On Virtual Execution Environments, 2008, pp. 91-100. 
[101] Tripwire.com,"Tripwire," (http://www.tripwire.com/) 
[102] tcpdump.org,"LibPcap Library," (http://www.tcpdump.org/) 
[103] Snort,"Snort Network IDS," (http://www.snort.org/) 
[104] ClamAV,"ClamAV AntiVirus," (http://www.clamav.net/lang/en/) 
[105] TrendMicro,"Trend Micro Accelerates Dynamic Datacenter Security Strategy with Acquisition of Third Brigade," 
(http://trendmicro.mediaroom.com/index.php?s=43&item=714) 
[106] TrendMicro,"Trend Micro Deep Security," 
(http://us.trendmicro.com/us/solutions/enterprise/security-solutions/virtualization/deep-security/) 
[107] T. Benzel et al., "Experience with DETER: A Testbed for Security Research," in Proceedings of Tridentcom. IEEE, 
2006, pp. 10–10. 
[108] C. Neuman, C. Shah, and K. Lahey, "Running Live Self-Propagating Malware on the DETER Testbed," in 
Proceedings of the DETER Community Workshop on Cyber Security Experimentation and Test, June 2006. 
[109] B. White et al., "An Integrated Experimental Environment for Distributed Systems and Networks," in Proc. of the 
Fifth Symposium on Operating Systems Design and Implementation. Boston, MA: USENIX Association, Dec. 2002, 
pp. 255–270. 
[110] Eide et al., "Integrated Scientific Workflow Management for the Emulab Network Testbed," in Proceedings of the 
2006 USENIX Annual Technical Conference, June 2006, pp. 363–368. 
[111] R. Bajcsy et al., "Cyber Defense Technology Networking and Evaluation," Commun. ACM, vol. 47, no. 3, pp. 58–61, 
2004. 
[112] C. Yu and H. Kai, "Collaborative Detection and Filtering of Shrew DDoS Attacks using Spectral Analysis," Journal 
of Parallel and Distributed Computing, vol. 66, no. 9, pp. 1137–1151, June 2006. 
[113] C. Yu, H. Kai, and K. Wei-Shinn, "Collaborative Detection of DDoS Attacks over Multiple Network Domains," 
IEEE Transactions on Parallel and Distributed Systems, June 2007. 
[114] B. White et al., "An Integrated Experimental Environment for Distributed Systems and Networks," ACM SIGOPS 
Operating Systems Review, vol. 36, pp. 255–270, 2002. 
[115] T. Benzel et al., "Design, Deployment, and Use of the DETER Testbed," in DETER: Proceedings of the DETER 
Community Workshop on Cyber Security Experimentation and Test 2007. USENIX Association, 2007, pp. 1–1. 
[116] K. Sklower and A. D. Joseph, "Very Large Scale Cooperative Experiments in Emulab-Derived Systems," in DETER: 
Proceedings of the DETER Community Workshop on Cyber Security Experimentation and Test 2007. USENIX 
國科會補助計畫衍生研發成果推廣資料表
日期:2012/10/30
國科會補助計畫
計畫名稱: 總計畫(2/2)
計畫主持人: 曾文貴
計畫編號: 100-2218-E-009-003- 學門領域: 資訊
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
本年度已邀請多位國際知名學者至國內進行技術交流與演講。 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
