Introduction 
Since graphs that arise in information or software visualization usually involve 
thousands or perhaps millions of nodes and it is often desirable to be able to 
efficiently and dynamically manage (interact with or navigate through) structures in 
such graphs, developing a visualization system to cope with such huge graphs 
presents a great challenge in graph drawing research. In order to satisfy those demand 
and applications, this search focuses on devising graph drawing algorithms for 
clustered graphs, developing corresponding theory, and furthermore, proposing a total 
solution including an information visualization platform. The notion of `clustered 
graphs’ is critical in the process of drawing general huge graphs, in which three main 
stages are involved: clustering (or partitioning), drawing, and dynamically operations. 
To improve the drawing efficiency, when the given graph is hierarchical or sparse, 
tree drawing algorithms (which are more efficient than their general counterparts) can 
be applied to drawing the associated spanning tree as a good starting point. As a result, 
we will also investigate how to draw various kinds of trees to better support 
applications in information visualization.  
 
Our investigation in the three years of this research project has led to the following 
publications: 
 
1. C. Lin, Y. Lee, and H. Yen, Mental Map Preserving Graph Drawing Using 
Simulated  Annealing,  accepted  with  minor  revision  for  publication  in 
Journal of Visual Languages and Computing,    2008 
2. C. Lin and H. Yen, J. Chuang, Drawing Graphs with Nonuniform Nodes 
Using Potential  Fields,  accepted with minor  revision  for publication  in 
Journal of Visual Languages and Computing ,    2008. 
3. C. Lin, H. Kao, and H. Yen, Many-to-One Boundary Labeling, accepted for 
publication in Journal of Graph Algorithms and Applications, (special issue for 
APVIS 2007), Vol. 13, No. 3, pp. 319‐356, 2008. 
Main contributions
• C. Lin, Y. Lee, and H. Yen, Mental Map Preserving Graph
Drawing Using Simulated Annealing, accepted with minor revi-
sion for publication in Journal of Visual Languages and Com-
puting, 2008.
Using graphs to represent real-world concepts has been widely used in
many areas, such as social relationship, interactive systems, database, au-
tomata theory, and so on. By observing the drawings of graphs, users are
capable of looking into the structures and the information of graphs. As
drawing graphs manually becomes infeasible for graphs of high complexity
in structure and size, many efficient automatic graph drawing methods have
been developed (e.g., see the survey of [100]). In order to find nice drawings,
graph drawing algorithms often is designed to optimize one or a few of the
graphical structures and the properties of drawings, called aesthetic criteria
(e.g., see also [2], which gives the formal metrics for measuring some common
aesthetic criteria), such as minimizing number of edge crossings or bends,
minimizing area, and so on, but the problem of simultaneously optimizing
those criteria is, in many cases, NP-hard. In addition to the computational
efficiency of algorithms and the extent to which the output drawings conform
to common aesthetic criteria, more and more studies focus on the quality of
drawings from the perspective of human comprehension and use (e.g., see
[3]). Among them, the problem of preserving human’s mental map for the
interactive graph drawings gets more and more attention.
In many applications, users can interact with the graphs, such as adding/deleting
one or more nodes/edges, on a regular basis. Most of the automatic drawing
strategies apply an existing static graph drawing algorithm to redrawing each
modified graph from scratch. Although such strategies are convenient and
simple, those strategies have a drawback, which is explained as follows. Since
users are familiarized with the original drawing and some information of the
original drawing may be formed in users’ mind after users view the drawing,
applying an existing static graph drawing algorithm to drawing the modi-
fied graph may not preserve the users’ “mental map” (i.e., the information
formed in users’ mind from the original drawing). That is, the drawing of the
modified graph may differ a lot in structure from the original drawing, even
1
among a set of orthogonal drawings. Finally, they used a statistical method
to find the relationship between these measurements and users’ feelings, and
concluded the best measures evaluated as follows: ranking, orthogonal order-
ing, λ-matrix, unweighted nearest neighbor within, average distance, weighted
nearest neighbor between, shape, and relative distance.
In this paper, we propose a mental map preserving graph drawing al-
gorithm for straight-line drawings of general undirected graphs, based upon
the simulated annealing graph drawing algorithm of [21] with the energy cost
function incorporating six criteria of [14] to reflect users’ mental map. Our
evaluation is divided into three stages. The first stage uses the original sim-
ulated annealing graph drawing algorithm to draw graphs. The second stage
is to modify the graph slightly. Like the work of [14], we add two nodes, one
with two edges and the other with four edges. In the third stage, our new
approach is applied to redrawing the modified graph nicely while preserving
the mental map. The experimental results suggest this new approach to be
promising. To a certain extent, our approach is capable of preserving the
drawing contour of a graph and the relative positions of nodes when a se-
quence of operations are applied. Similar to [21], our approach allows users to
adjust the relative weights of criteria among various parameters, and hence
is very flexible. In addition, we can see from the experimental results that
there exists a trade-off between drawing graphs nicely and preserving mental
map.
The contributions of this paper are summarized as follows:
1. The previous work of preserving the mental map focused on how to pre-
serve the orthogonal ordering and adding additional constraints to the
input graph. To our understanding, no graph drawing algorithms aim-
ing at preserving the mental map on straight-line drawings of general
undirected graphs while using more sophisticated criteria simultane-
ously have been reported in the literature.
2. Our approach allows users to adjust the relative weights of criteria
among various parameters, and hence is very flexible.
3. By taking samples among a group of students with basic knowledge of
graphs and graph drawing, Bridgeman and Tamassia [14] suggested a
number of good criteria suitable for capturing the notion of the mental
3
conventional drawing algorithms by plugging in objects of nonzero size for
point nodes in the drawing is unlikely to produce a high quality drawing. In
view of this, it becomes apparent that a new line of research has to be carried
out in hope of narrowing the gap between the conventional force-directed al-
gorithms and graphs consisting of nodes of various sizes and shapes that are
frequently encountered in the real world.
In this paper, we present a new approach, combining the force-directed
strategy as well as the theory of potential fields, for drawing graphs with
nonuniform nodes. Although there exist other conventions (e.g., like hierarchical-
layered drawing [30] and orthogonal drawing [31]) for drawing graphs with
nonuniform nodes, we for the first time take node rotations into account
when implementing our force-directed-based drawing algorithm. The con-
cept of potential fields has already found applications in a variety of areas
in computer science and engineering, such as path planning [32, 33], among
others. In our setting, each edge is modelled by a spring (like in conventional
force-directed methods) and the boundary of every nonuniform node is uni-
formly charged. We consider both 2-dimensional and 3-dimensional drawings
of nonuniform nodes, each of which is represented by a polygon (in 2-D) or
polyhedron (in 3-D). Other shapes of objects can be approximated by their
enclosing polygons (or polyhedrons). For a given nonuniform node, the forces
on the node come from two sources: one resulting from being connected by
springs, and the other is caused by being present in the potential field in-
duced by the remaining nodes. From the efficiency viewpoint, it turns out
that computing the repulsive force and torque of a node in the potential field
induced by the remaining nodes is analytically tractable, as our subsequent
discussion indicates.
The work of [34] extended the conventional force directed methods to de-
velop three new algorithms to draw graphs with either elliptic or rectangular
nodes. In comparison with [34], our approach differs in the following. First,
we deal with graphs in both 2-D and 3-D, whereas in [34], only 2-D graphs
with either elliptical or rectangular nodes are investigated. Second and per-
haps a more significant difference is that when measuring the movement of
a nonuniform node, rotation is taken into account rather naturally in our
framework, while the work of [34] lacks this capability. In the process of
reaching equilibrium, the degree of inclination of a nonuniform node can be
adjusted while moving from one position to another. By doing so, the final
5
In information visualization, cartography, geographic information systems
(GIS), and graph drawing, map labeling is an important task which is con-
cerned with efficiently placing extra information, in the form of text labels,
next to features (such as points, lines, or areas) in a drawing (map). In order
to ensure readability, unambiguity and legibility, it is suggested that the la-
bels be pairwise disjoint and close to the features to which they belong [62].
A detailed bibliography and survey on map labeling can be found in [70],
[66], respectively. ACM Computational Geometry Impact Task Force [56]
has identified label placement as an important area of research. The major-
ity of map labeling problems are known to be NP-complete [60, 63] in general.
(The interested reader is also referred to [68, 69] for various approximations
and heuristics for map labeling.)
Map labeling problems are classified by the following three kinds of graph-
ical features according to their dimensions, namely, point features, line fea-
tures, and area features. For example, in a geographical map, a city (resp.,
river and lake) is typically represented by a point (resp., line and area) fea-
ture. Note that a point or a line feature label is normally located next to
the associated object, while an area feature label is usually placed within the
boundary of the feature to be labeled.
Most of the research on map labeling has primarily focused on labeling
point features, and the basic requirement in this case is that all the labels
should be pairwise disjoint. It is clear that such a requirement is difficult
to be achieved in the case where large labels are placed on dense points. In
practice, large labels are usually used in technical drawings or medical atlases
where certain site-features are explained with blocks of texts. To address this
problem, Bekos et al. proposed the so-called boundary labeling [50, 52, 53],
in which all labels are attached to the boundary (four sides) of a rectangle R
enclosing all sites, and each site is connected to a unique label by a leader,
which may be a rectilinear or straight line segment. In such a setting, they
investigated how to place the labels and leaders in a drawing such that there
are no crossings among leaders and either the total leader length or the bends
of leaders are minimized under a variety of constraints. In a recent article,
Bekos et al. [51] investigated a similar problem for labeling polygonal sites
under the framework of boundary labeling.
For the work reported in [50, 51, 52, 53] regarding boundary labeling,
each label is uniquely associated with a site (point feature). In practice,
7
such that it becomes easier to comprehend the assignment from sites to labels.
Intuitively, the model of type-do leaders can obtain shorter total leader length
than that of type-po. Therefore, they investigated the problem of minimizing
the total leader length, without any crossings of leaders.
As listed in Table 1, the main contributions of this paper include:
1. Crossing minimization problems for both one-side and two-side many-
to-one labeling with type-opo leaders are proved to be NP-complete.
We also design approximation algorithms to cope with such intractable
problems.
2. Crossing minimization problems for one-side and two-side many-to-one
labeling with type-po leaders are proved to be NP-complete. Heuris-
tic algorithms with satisfactory experimental results are also given for
these problems.
3. We discuss the many-to-one labeling with the objective of minimizing
the total leader length to be solvable in polynomial time, along a similar
line of the work of [50].
Table 1: The main contributions of this paper.
number leader time solution
objective of sides type complexity
Minimize the crossing number one opo NPC approximation
Minimize the crossing number two opo NPC approximation
Minimize the crossing number one po NPC heuristic
Minimize the crossing number two po NPC heuristic
Minimize total leader length any opo, po P following [50, 53]
A wide variety of variants of one-to-one boundary labeling have been
proposed and studied from an algorithmic viewpoint in the literature. Table
2 summarizes those that are related to our work. By comparing Table 1
with Table 2, it is interesting to note that in the one-to-one case, minimizing
the total leader length while respecting the no-crossing constraint is always
9
the two subtrees one level up between their roots. Different from the con-
ventional ‘triangular’ tree drawing of [105], radial drawings [93] and balloon
drawing [89, 97, 99, 102, 104] with respect to cone trees1[106] are also popu-
lar for visualizing hierarchical graphs. The interested reader is also referred
to [80, 81, 82] for graph drawing techniques based on the idea of embedding
trees/graphs in hyperbolic geometry to automatically obtain a deformation
resulting in a focus+context navigation. Since the majority of algorithms
for drawing rooted trees take linear time, rooted tree structures are suited
to be used in an environment in which real-time interactions with users are
frequent.
A balloon drawing [89, 99, 102] of a rooted tree is a drawing having the
following properties:
(P1) all the children under the same parent are placed on the circumference
of the circle centered at their parent,
(P2) there exist no edge crossings in the drawing, and
(P3) for the two edges on any path from the root node, the farther from the
root an edge is, the shorter its drawing length becomes.
Each subtree in the balloon drawing of a tree is enclosed entirely in a circle,
which resides in a wedge whose end-point is the parent node of the subtree.
Along any path from the root node, the radius of each circle reflects the
number of descendents associated with the root node of the subtree. The
ray from the parent to the root of the subtree divides the wedge into two
sub-wedges. Depending on whether the two sub-wedge angles are required to
be identical or not, a balloon drawing can further be divided into two types:
drawings with even angles and drawing with uneven angles. Another way to
differentiate the two is that for the former (i.e., the even angle case), it is
required that the position of the root of a subtree coincide with the center
of the enclosing circle of the subtree.
The main aesthetic criteria on balloon drawing are angular resolution
and aspect ratio. The angular resolution refers to the smallest angle between
1Given a rooted tree, the cone tree method places the root of every subtree on the
vertex of a cone and its children on the circumference of the base of the cone in 3-D space
such that there are no cones overlapping each other. A balloon drawing can be viewed as
the projection of a cone tree on a plane.
11
under a slightly modified version of balloon drawing, in which properties
(P1) and (P3) of balloon drawing are relaxed by coloring the edges at the
same level with the same color, i.e., the level of an edge can be determined
by observing its color [87]. We are able to formulate the problem as a specific
type of nonconvex nonlinear programming, for which there exist many robust
algorithms in the literature for practical applications.
In addition, minor extensions to the balloon drawing facilitate several
interesting applications, including galaxy systems, H-trees, sparse graphs,
among others. Our balloon drawing approach to galaxy systems gives an ab-
stract layout of the related positions of bodies instead of their real positions
and hence enjoys the advantage that the hierarchical structure of a galaxy
system can be easily observed in such a layout. For more about visualizing
the dynamic movements of bodies in a galaxy system due to their mutual
forces, the reader is referred to [72] for the gravitational n-body problem.
• C. Lin, and H. Yen: Balloon Views of Source Code and Their
Multiscalable Font Modes, in Proc. of the 11th Int’l Confer-
ence on Information Visualisation (IV 2007), pp. 53-58, Zurich,
Switzerland, July 4-6, 2007.
In developing a huge and complicated program, the programmer often
not only applies the text editor to writing the program, but also observes
a variety of views of the program source code to comprehend the program.
Suppose we consider the program source code as a hierarchical structure.
With this feature, programmers can show on the screen only the lines that
they concern, which preserve the outline of the source code. In addition, in
object-oriented programming, the class view, which gives the visual directory
explorer of the hierarchical relation of classes and variables, makes it easy
for programmers to navigate, understand, and manipulate the classes and
variables.
Designing a source code view which fits the needs of programmers (i.e.,
allowing them to easily understand and navigate through the codes) is of
increasing importance, especially for those writing new codes based upon
existing codes possibly created by other programmers. Previous work along
this line of research includes the following. Furnas [96] proposed the fisheye
view of source code, in which a focus line is selected and each source code
line is assigned a value, called degree of interest (DOI), calculated by its a
13
the circumference of the circle centered at their parent; there exist no edge
crossings in the drawing; for the two edges on any path from the root node,
the farther from the root an edge is, the shorter its drawing length becomes.
Note that there exist two models in the literature for generating balloon
drawings of trees. Given a node v, let r(v) be the radius of the drawing
circle centered at v. If we require that r(v) = r(w) for arbitrary two nodes
v and w that are of the same depth from the root of the tree, then such a
drawing is called a balloon drawing under the fractal model [102]. Unlike the
fractal model, the subtrees with nonuniform sizes (abbreviated as SNS) model
[89, 99] allows subtrees associated with the same parent to reside in circles
of different sizes, and hence, the drawing based on this model often results
in a clearer display on large subtrees than that under the fractal model.
Inspired by the multiscalable font mode of the fractal view of source code,
and noticing that the balloon drawing of a tree structure involves the fractal
model and the SNS model, in this paper we devise the multiscalable font
mode of the SNS view of source code, in which the font size of each source
code line is proportional to a value that is derived from the balloon drawing
under the SNS model for the tree structure representing the program source
code. Similarly, the multiscalable font mode of the fisheye view of source code
also can be defined. In addition to helping users to understand the relation
between the views before and after they change their focus lines [101], the
multiscalable mode also has the advantage that the size of the value of each
source code line is visible to users by observing its font size, as compared to
the original view of the directory-explorer style.
Generally speaking, we refer the fractal and the SNS views of source
code as the balloon view of source code. In this research, we implement
the multiscalable font modes of the fisheye, the fractal, and the SNS views,
and compare their characteristics qualitatively. The experimental results re-
veal that the multiscalable font mode of each of the above three views has
its pros and cons, and hence, we suggest that in practice the programmers
should consider the multiscalable font modes of all the three views for com-
prehending the program deeply. Other work concerning the visualization of
source code includes the XML approaches reported in [90, 91], which attach
some information to the source code for storing and representing the source
code. The results of this paper are not compared with those work because
we are concerned only with the source code without attaching additional
15
required height, a visibility representation ofG with height no more than n−1
was reported in [114, 116]. Zhang and He [117, 119, 120] reduced the required
height to b15n/16c, then b5n/6c, and finally b(4n− 1)/5c. Recently, He and
Zhang [109] proved that every plane graph has a visibility representation with
height at most 2n/3+2d
√
n/2e and a visibility representation with width at
most 4n/3 + 2d√ne.
As for the required size, Zhang and He [119] showed that any visibility
representation of a planar graph requires a size at least b2n/3c×(b4n/3c−3),
which provides a positive answer to Kant’s open question [110] about whether
there exists a plane graph such that all of its visibility representations require
width greater than c× n, where c > 1.
In this paper, we devise an O(n)-time algorithm to obtain a visibility
representation of a given plane graph with its width no wider than b4n/3c−
2. Since the bound differs from the lower bound b4n/3c − 3 (reported in
[119]) only by a unit, the visibility representations produced by our algorithm
achieve optimality in terms of the width of the drawing area. In addition,
our result improves upon the previously known upper bound 4n/3 + 2d√ne,
answering in the affirmative a conjecture (by Lin et al. [111]) about whether
an upper bound 4n/3 + O(1) on the required width can be achieved for an
arbitrary plane graph.
The basic idea of our algorithm is stated as follows. Rather than conven-
tionally using canonical ordering, st-numbering, or Schnyder’s realizer as the
initial input, our algorithm applies a new kind of ordering, called construc-
tive ordering, of G to constructing visibility representations. A constructive
ordering of a plane triangulation G is an ordering of all the nodes in G such
that G can be constructed by iteratively inserting a node in this ordering
into a plane triangulation, and each inserted node must be of degree three,
four or five. In our algorithm, each triangle face in G is drawn as an L-shape,
so we defines all the possible operations of inserting nodes with degree three,
four and five. According to these defined operations, each iteration of our
algorithm maintains all (six) possible visibility representations, and inserts a
node to each of those visibility representations in the constructive ordering.
Finally, the width of each of the six visibility representations is compressed
as much as possible, and then the visibility representation with the narrowest
width among all is selected as the output of our algorithm.
17
[12] H. C. Purchase, E. Hoggan, C. Go¨rg, How important is the “mental
map”? – an empirical investigation of a dynamical graph layout algo-
rithm, in: Proceedings of Graph Drawing 2006, Vol. 4372 of Lecture
Notes in Computer Science, 2007, pp. 184–195.
[13] R. Davidson, D. Harel, Drawing graphs nicely using simulated annealing,
ACM Transactions on Graphics 15 (4) (1996) 301–331.
[14] S. Bridgeman, R. Tamassia, A user study in similarity measures for
graph drawing, Journal of Graph Algorithms and Applications 6 (3)
(2002) 225–254.
[15] S. Kirkpatrick, C. D. Gelatt Jr., M. P. Vecchi, Optimization by simulated
annealing, Science 220 (1983) 671–680.
[16] H. C. Purchase, Which aesthetic has the greatest effect on human under-
standing?, in: Proceedings of Graph Drawing 1997, Vol. 1353 of Lecture
Notes in Computer Science, 1997, pp. 248 – 261.
[17] S. L. Franconeri, A. Hollingworth, D. J. Simons, Do new objects capture
attention?, Psychological Science 16 (2005) 275–281.
[18] R. A. Rensink, Change detection, Annual Review of Psychology 53
(2002) 245–277.
[19] K. Kaufmann, D. Wagner (Eds.), Drawing Graphs: Methods and Mod-
els, Vol. 2025 of LNCS, Springer, 2001.
[20] F. Bertault, A force-directed algorithm that preserves edge crossing
properties, in: Graph Drawing 1999, Vol. 1731 of LNCS, Springer, 1999,
pp. 351–358.
[21] R. Davidson, D. Harel, Drawing graphs nicely using simulated annealing,
ACM Transactions on Graphics 15 (1996) 301–331.
[22] P. Eades, A heuristic for graph drawing, Congress Numerantium 42
(1984) 149–160.
[23] A. Frick, A. Ludwig, H. Mehldau, A fast adaptive layout algorithm for
undirected graphs, in: Graph Drawing ’94, Vol. 894 of LNCS, Springer,
1995, pp. 388–403.
19
[36] U. Dogruso¨z, E. Giral, A. Cetintas, A. Civril, E. Demir, A compound
graph layout algorithm for biological pathways, in: Graph Drawing 2004,
Vol. 3383 of LNCS, Springer, 2004, pp. 442–447.
[37] T. C. Biedl, M. Kaufmann, Area-efficient static and incremental graph
drawings, in: ESA’97, Vol. 1284 of LNCS, Springer, 1997, pp. pp. 37–52.
[38] Q. Feng, R. Cohen, P. Eades, Planarity for clustered graphs, in: ESA’95,
Vol. 979 of LNCS, Springer, 1995, pp. pp. 213–226.
[39] Q. Feng, Algorithms for drawing clustered graphs, Ph.D. thesis, Univer-
sity of Newcastle, Australia (1997).
[40] P. Eades, M. L. Huang, Navigating clustered graphs using force-directed
methods, Journal of Graph Algorithms and Applications 4 (3) (2000)
157–181.
[41] W. T. Tutte, Convex representations of graphs, Proceedings of the Lon-
don Mathematical Society 10 (1960) 304–320.
[42] W. T. Tutte, How to draw a graph, Proceedings of the London Mathe-
matical Society 13 (1963) 743–768.
[43] C.-C. Lin, H.-C. Yen, A new force-directed graph drawing method based
on edge-edge repulsion, in: IV 2005, IEEE CS Press, 2005, pp. 329–334.
[44] S. Kirkpatrick, C. D. Gelatt, M. P. Vecchi, Optimization by simulated
annealing, Science 220 (1983) 671–680.
[45] X. Huang, W. Lai, Force-transfer: a new approach to removing overlap-
ping nodes in graph layout.
[46] E. Gansner, S. North, Improved force-directed layouts, in: Graph Draw-
ing ’98, Vol. 1547 of LNCS, Springer, 1998, pp. 364–373.
[47] H. Purchase, Which aesthetics has the greatest effect on human under-
standing, in: Graph Drawing ’97, Vol. 1353 of LNCS, Springer, 1997,
pp. 248–261.
[48] H. Purchase, J.-A. Allder, D. Carrington, Graph layout aesthetics in
UML diagrams: user preferences, Journal of Graph Algorithms and Ap-
plications 6 (3) (2002) 255–279.
21
[59] U. Feige and O. Yahalom. On the complexity of finding balanced oneway
cuts. Information Processing Letter, 87(1):1–5, 2003.
[60] M. Formann and F. Wagner. A packing problem with applications to
lettering of maps. In Proceedings of the 7th Annual ACM Symposium
on Computational Geometry (SoCG 1991), pages 281–288. ACM Press,
1991.
[61] M. R. Garey and D. S. Johnson. Computers and Interactability. A Guide
to the Theory of NP-Completeness. A Series of Books in the Mathemat-
ical Sciences. Freemann And Company, 1979.
[62] E. Imhof. Positioning names on maps. The American Cartographer,
2(2):128–144, 1975.
[63] C. Iturriaga and A. Lubiw. NP-hardness of some map labeling problems.
Technical Report CS-97-18, University of Waterloo, 1997.
[64] B. W. Kernighan and S. Lin. An efficient heuristic procedure for par-
titioning graphs. The Bell System Technical Journal, 49(2):291–307,
1970.
[65] X. Munoz, W. Unger, and I. Vrt’o. One sided crossing minimization
is NP-hard for sparse graphs. In Proceedings of the 9th International
Symposium on Graph Drawing (GD 2001), volume 2265 of LNCS, pages
115–123, 2002.
[66] G. Neyer. Map labeling with application to graph drawing. In D. Wagner
and M. Kaufman, editors, Drawing graphs: Methods and models, volume
2025 of LNCS, pages 247–273. 2001.
[67] P. M. Vaidya. Geometry helps in matching. SIAM Journal on Comput-
ing, 18(6):1201–1225, 1989.
[68] F. Wagner. Approximate map labeling is in ω(n log n). Information
Processing Letter, 52(3):161–165, 1994.
[69] F. Wagner and A. Wolff. Map labeling heuristics: Provably good and
practically useful. In Proceedings of the 11th Annual ACM Symposium
on Computational Geometry (SoCG 1995), pages 109–118. ACM Press,
1995.
23
[82] T. Muzner and P. Burchard. Visualizing the structure of the world wide
web in 3D hyperbolic space. In VRML 1995, pages 33–38. ACM Press,
1995.
[83] C. Papadimitriou and K. Steiglitz. Combinatorial Optimization. Pren-
tice Hall, Englewood Cliffs, New Jersey, 1982.
[84] E. Reingold and J. Tilford. Tidier drawing of trees. IEEE Trans. Soft-
ware Eng., SE-7(2):223–228, 1981.
[85] G. Robertson, J. Mackinlay, and S. Card. Cone trees: Animated 3D
visualizations of hierarchical information. In CHI ’91, pages 189–194.
ACM Press, 1991.
[86] Y. Shiloach. Arrangements of planar graphs on the planar lattices. PhD
thesis, Weizmann Instite of Science, 1976.
[87] S.-T. Teoh and K.-L. Ma. Rings: A technique for visualizing large
hierarchies. In GD 2002, volume 2528 of LNCS, pages 268–275. Springer,
2002.
[88] E. Welzl. Smallest enclosing disks (balls and ellipsoids). In H. Maurer,
editor, New Results and New Trends in Computer Science, volume 555
of LNCS, pages 359–370. Springer, 1991.
[89] J. Carrie`re and R. Kazman. Research report: Interacting with huge
hierarchies: Beyond cone trees. In IV 95, pages 74–81. IEEE CS Press,
1995.
[90] M. L. Collard, J. I. Maletic, and A. Marcus. Supporting document and
data views of source code. In DocEng ’02, pages 34–41. ACM Press,
2002.
[91] A. Cox and M. L. Collard. Working session: Textual views of source
code to support comprehension. In IWPC ’05, pages 109–112. IEEE
Press, 2005.
[92] G. Di Battista, P. Eades, R. Tamassia, and I. G. Tollis. Graph Drawing:
Algorithms for the Visualization of Graphs. Prentice-Hall, 1999.
[93] P. Eades. Drawing free trees. Bulletin of the Institute for Combinatorics
and its Applications, pages 10–36, 1992.
25
[106] G. Robertson, J. Mackinlay, and S. Card. Cone trees: Animated 3D
visualizations of hierarchical information, human factors in computing
systems. In CHI ’91, pages 189–194. ACM Press, 1991.
[107] M. Sarkar and M. H. Brown. Graphical fisheye views. Communications
of the ACM, 37(12):73–83, 1994.
[108] G. Di Battista, R. Tamassia, and I. G. Tollis. Constrained visibility
representations of graphs. Inf. Process. Lett., 41(1):1–7, 1992.
[109] X. He and H. Zhang. Nearly optimal visibility representations of planar
graphs. In ICALP 2006, volume 4051 of LNCS, pages 407–418, 2006.
[110] G. Kant. A more compact visibility representation. Internat. J. Com-
put. Geom. Appl., 7:197–210, 1997.
[111] C.-C. Lin, H.-I. Lu, and I.-F. Sun. Improved compact visibility rep-
resentation of planar graph via schnyder’s realizer. SIAM J. Discrete
Math., 18(3):19–29, 2004.
[112] J. Nummenmaa. Constructing compact rectilinear planar layouts us-
ing canonical representation of planar graphs. Theoret. Comput. Sci.,
99:213–230, 1992.
[113] R. Otten and J. van Wijk. Graph representations in interactive layout
design. In IEEE Internat. Sympos. on Circuits and Systems, pages 914–
918, 1978.
[114] P. Rosenstiehl and R. E. Tarjan. Rectilinear planar layouts and bipolar
orientations of planar graphs. Discrete Comput. Geom., 1(4):343–353,
1986.
[115] M. Schlag, F. Luccio, P. Maestrini, D. T. Lee, and C. K. Wong. A
visibility problem in VLSI layout compaction. In F. P. Preparata, editor,
Advances in Computing Research, volume II, pages 259–282. JAI Press,
Greenwich, CT, 1985.
[116] R. Tamassia and I.G.Tollis. An unified approach to visibility represen-
tations of planar graphs. Discrete Comput. Geom., 1:321–341, 1986.
27
附錄 
 
1. C. Lin, Y. Lee, and H. Yen, Mental Map Preserving Graph Drawing Using 
Simulated  Annealing,  accepted  with  minor  revision  for  publication  in 
Journal of Visual Languages and Computing,    2008 
2. C. Lin and H. Yen, J. Chuang, Drawing Graphs with Nonuniform Nodes 
Using Potential  Fields,  accepted with minor  revision  for publication  in 
Journal of Visual Languages and Computing ,    2008. 
3. C. Lin, H. Kao, and H. Yen, Many-to-One Boundary Labeling, accepted for 
publication in Journal of Graph Algorithms and Applications, (special issue for 
APVIS 2007), Vol. 13, No. 3, pp. 319‐356, 2008. 
4. C. Lin and H. Yen, On Balloon Drawings of Rooted Trees, Journal of Graph 
Algorithms and Applications, (special issue for GD 2005), Vol. 11, No. 2, pp. 
431-452, 2007. 
5. J. Fan, C. Lin, H. Lu, and H.Yen, Width-Optimal Visibility Representation of 
Plane Graphs, in Proc. of the 18th International Symposium on Algorithms and 
Computation (ISAAC 2007),  (LNCS 4835), pp. 160-171, Sendai, Japan, Dec. 
17-19, 2007. 
6. C. Lin, and H.  Yen: Balloon Views of Source Code and Their Multiscalable 
Font Modes, in Proc. of the 11th Int'l Conference on Information Visualisation 
(IV 2007), pp.  53-58, Zurich, Switzerland, July 4-6, 2007. 
looking into the structures and the information of graphs. As drawing graphs
manually becomes infeasible for graphs of high complexity in structure and
size, many eﬃcient automatic graph drawing methods have been developed
(e.g., see the survey of [1]). In order to ﬁnd nice drawings, graph drawing al-
gorithms often is designed to optimize one or a few of the graphical structures
and the properties of drawings, called aesthetic criteria (e.g., see also [2], which
gives the formal metrics for measuring some common aesthetic criteria), such
as minimizing number of edge crossings or bends, minimizing area, and so on,
but the problem of simultaneously optimizing those criteria is, in many cases,
NP-hard. In addition to the computational eﬃciency of algorithms and the
extent to which the output drawings conform to common aesthetic criteria,
more and more studies focus on the quality of drawings from the perspective
of human comprehension and use (e.g., see [3]). Among them, the problem of
preserving human’s mental map for the interactive graph drawings gets more
and more attention.
In many applications, users can interact with the graphs, such as adding/deleting
one or more nodes/edges, on a regular basis. Most of the automatic drawing
strategies apply an existing static graph drawing algorithm to redrawing each
modiﬁed graph from scratch. Although such strategies are convenient and
simple, those strategies have a drawback, which is explained as follows. Since
users are familiarized with the original drawing and some information of the
original drawing may be formed in users’ mind after users view the drawing,
applying an existing static graph drawing algorithm to drawing the modiﬁed
graph may not preserve the users’ “mental map” (i.e., the information formed
in users’ mind from the original drawing). That is, the drawing of the modiﬁed
graph may diﬀer a lot in structure from the original drawing, even in the case
when only a slight modiﬁcation is made to the original drawing. In this case,
users often have to spend a considerable amount of extra time to recognize
the new drawing. Furthermore, if the frequency of modiﬁcations increases, this
problem may become more serious.
For instance, suppose that Figure 1(a) is the drawing of a graph produced by
the well-known spring algorithm [4]. We add node 4 to the graph and connect
it to the remaining nodes of the graph, and Figures 1(b) and 1(c) are two
possible drawings of the modiﬁed graph produced by the spring algorithm
under diﬀerent settings of spring lengths. Clearly, Figure 1(c) is a better one
for preserving the mental map since it inherits more information from the
original drawing (i.e., Figure 1(a)) in comparison with Figure 1(b). Figure 2,
from [5], is another example illustrating the importance of the preservation of
the mental map. The initial graph consists of a chain of quadrangles, which
are displayed nicely by the layout algorithm “Circular with Radial” (see [6]).
Adding a single edge to the initial graph is going to harm the mental map
considerably. As shown in Figure 2(a), when we connect the two outermost
quadrangles by a single edge which is marked by the thick curve connecting
2
Drawing graph nicely means placing nodes and edges in a pleasing way. There
are diﬀerent aesthetic criteria in diﬀerent areas. In Davidson and Harel’s work
[13], a nice-looking graph drawing refers to a drawing which: (1) distributes
nodes evenly, (2) makes edge-lengths uniform, (3) minimizes edge-crossings,
and (4) keeps nodes from coming too close to edges. To draw graphs nicely,
a simulated annealing method was used in [13] with the energy cost function
designed to respect the above requirements. The implementation of their work
allows the user to adjust the relative weights of criteria in the energy cost
function among various parameters, although some of these criteria may be
in conﬂict with each another. The simulated annealing method oﬀers a more
ﬂexible way of drawing graphs than many other algorithms.
In fact, there are many intuitive factors that aﬀect the mental map, and
Bridgeman and Tamassia [14] formally deﬁned those intuitive factors for or-
thogonal drawings and presented some statistical results to evaluate their ef-
fects on human perception of similarity. They used many measurements to
measure the similarity between diﬀerent drawings, and then asked respon-
dents to evaluate the best measures that reﬂect their perception of similarity
among a set of orthogonal drawings. Finally, they used a statistical method
to ﬁnd the relationship between these measurements and users’ feelings, and
concluded the best measures evaluated as follows: ranking, orthogonal order-
ing, λ-matrix, unweighted nearest neighbor within, average distance, weighted
nearest neighbor between, shape, and relative distance.
In this paper, we propose a mental map preserving graph drawing algorithm
for straight-line drawings of general undirected graphs, based upon the simu-
lated annealing graph drawing algorithm of [13] with the energy cost function
incorporating six criteria of [14] to reﬂect users’ mental map. Our evaluation is
divided into three stages. The ﬁrst stage uses the original simulated annealing
graph drawing algorithm to draw graphs. The second stage is to modify the
graph slightly. Like the work of [14], we add two nodes, one with two edges
and the other with four edges. In the third stage, our new approach is applied
to redrawing the modiﬁed graph nicely while preserving the mental map. The
experimental results suggest this new approach to be promising. To a certain
extent, our approach is capable of preserving the drawing contour of a graph
and the relative positions of nodes when a sequence of operations are applied.
Similar to [13], our approach allows users to adjust the relative weights of
criteria among various parameters, and hence is very ﬂexible. In addition, we
can see from the experimental results that there exists a trade-oﬀ between
drawing graphs nicely and preserving mental map.
The contributions of this paper are summarized as follows:
(1) The previous work of preserving the mental map focused on how to pre-
serve the orthogonal ordering and adding additional constraints to the
4
system becomes ordered.
SA is ﬂexible and has successfully been applied to solving various combina-
tional optimization problems. It allows “uphill” moves – moves that spoil,
rather than improve, the temporary solution. This unique feature allows SA
to escape from a local minimal solution, although there is no guarantee that
a global minimum can be reached eventually.
The ﬁrst step of SA is to generate an initial conﬁguration (either randomly or
heuristically constructed) and initialize the so-called temperature parameter
T . Then the following is repeated until the termination condition is satisﬁed.
A new solution from the neighborhood of the current solution is randomly
selected. The energy cost of the new solution is calculated over the objective
function and T is decreased. Let φ and φ′ denote the current and new energy
costs, respectively. If φ′ < φ, the new solution will be accepted. If φ′ > φ,
this solution will be accepted with a probability which is a function of T
and (φ′ − φ). This probability is from the Boltzmann distribution: e−(φ′−φ)/kT
where k is the Boltzmann constant. (We assume k = 1 in the subsequent
discussion.) This kind of “uphill” moves will be fewer as SA proceeds because
T is decreased after each iteration.
The following are the basic steps of SA:
Algorithm 1. SA
1: generate an initial conﬁguration δ and an initial temperature T ;
2: repeat the following until the termination condition is satisﬁed:
(a) choose a new conﬁguration δ′ from the neighborhood of δ;
(b) let φ and φ′ be the values of the energy cost function at δ and δ′
respectively; if φ′ − φ < 0 or random < e−(φ′−φ)/kT then set δ ← δ′;
3: decrease the temperature T ;
4: if the termination condition is satisﬁed, stop; otherwise go to step 2.
2.2 The Graph Drawing Algorithm Using Simulated Annealing
The input to the DH algorithm is a graph G = (V,E) stored in an adjacency
list, where V is the set of nodes and E is the set of edges. Each node in V has
a unique index. In what follows, we give the main components of SA needed
to carry out the simulation of the physical annealing process, used in the DH
algorithm.
6
nodes evenly. For each node i, the term:
mi = λ2(
1
r2i
+
1
l2i
+
1
t2i
+
1
b2i
)
is added to the energy cost function, where ri, li, ti, bi stand for the dis-
tances between node i and the right, left, top and bottom sides of the
drawing frame, respectively; λ2 is the normalizing factor, and, intuitively,
increasing λ2 relative to other normalizing factors makes the graph to-
wards the center of the drawing frame.
(3) Edge lengths: The previous two components are related to nodes. Now we
discuss the criteria about edges. This component is slightly diﬀerent from
that used in the DH algorithm. They used the term ck = λ3d
2
k, where dk
is the length of edge k and λ3 is the normalizing factor. In our setting,
we add the term
σ = λ3s
2
to the energy cost function, where s is the standard deviation of edge
lengths. The reason why we use σ instead of ck is that using ck in design-
ing the energy cost function tends to produce the drawing with shorter
edge lengths that may not be desirable in some cases of preserve the men-
tal map (it often is in conﬂict with our mental map criteria). Our new
criterion ensures that edge lengths do not vary too much, though it takes
more time than using ck.
(4) Edge crossings: Minimizing the number of crossings is one of the most
important criteria of obtaining a nice graph drawing, but it is in general
diﬃcult to achieve. Too many crossings degrade the quality of a drawing,
which often causes unnecessary confusions when users view the drawing.
Although the output of the SA-based graph drawing algorithm may not
reach the minimal number of crossings theoretically, it produces a quite
pleasing drawing in most cases as our experimental results indicate. To
incorporate this component, we simply add to the energy cost function
the term:
ekl = λ4fkfl
where fk is the weight attributed to edge k; λ4 is a normalizing factor
that deﬁnes the relative importance of this criterion compared to others.
In this case, the normalizing factor, λ4, is deﬁned as
λ4 =
λ5
g2min
where λ5 is the normalizing factor of the next component (Node-edge
Distance), and gmin is given as the minimum distance between nodes and
8
(2) Temperature reduction: The temperature reduction stage determines when
to change the temperature and how to change it. This stage aﬀects the
number of moves at each temperature and the range of each move. Typical
applications set the number of trials at each temperature to be polynomial
in the size of the input. We set the moves at each temperature to be
30|V |, which the DH algorithm suggested. The cooling schedule rule is
geometric. If Ti is the temperature at the p-th stage, then the temperature
at the next stage is
Ti+1 = γTi,
with γ is a real number between 0.6 and 0.95. We set γ = 0.75, which
the DH algorithm suggested. The range of each move decreases when the
temperature reduces. Given the range of movement at the i-th stage is
R; the range of movement serving for the next temperature is γR, which
accelerates the convergence of the algorithm.
(3) Termination condition: This is to decide when to stop the algorithm.
Commonly used termination conditions include: stopping the algorithm
when the solution is not modiﬁed after several consecutive stages, or ﬁxing
the number of stages to be a constant. All of our experimental results are
obtained by running ten stages of our algorithm, in which the number of
stages is used the same as that used in the DH algorithm. Experimental
results have shown that, in many cases, substantial changes only happen
in some of the former stages, and the following stages yield marginal
improvement.
About the time complexity, the algorithm runs in time O(|V |2|E|) because
the number of stages is constant, the number of trials in each stage is 30|V |,
and every term in the energy cost function can be computed in O(|V ||E|).
3 Preserving the Mental Map
Recently, there are more and more studies on preserving the mental map in
graph drawing. However, most of these work focused on how to preserve the
orthogonal ordering or adding additional constraints to the input graph. To
our understanding, no algorithm aiming at preserving the mental map on
straight-line drawings of general undirected graphs while using more sophisti-
cate criteria simultaneously has been reported in the literature. We feel that
the orthogonal ordering is not the only factor aﬀecting users’ mental map.
Seeking additional factors regarding the preservation of the mental map plays
an important role in drawings of graphs, especially, in dynamic graphs. In
addition, adding additional constraints by users becomes infeasible as the size
of the graph increases. Regarded as the most complete work about the mea-
10
are chosen as the measures of preserving the mental map in our work.
3.2 Redrawing Graphs while Preserving the Mental Map
In our work, we use the simulated annealing method to produce the modiﬁed
drawings of graphs. Most of the settings in our algorithm are the same as
those discussed in the previous section. We only explain the diﬀerences in the
following.
3.2.1 The Mental Map Cost Function
In order to preserve the mental map, we deﬁne themental map cost M between
the original drawing D and the modiﬁed drawing D′, which consists of some of
the components designed to reﬂect the critical factors regarding the similarity
of drawings based on the experiments reported in [14]. Note that the value of
each component in M is nonnegative, and hence M = 0 implies that the two
drawings are viewed as the same drawings. The larger magnitude of M means
a higher degree of diﬀerence between the two drawings.
Note that all the measures proposed in [14] except the the “Shape” measure
are deﬁned in terms of point sets which are derived from the edges and nodes of
the graph instead of the edges and nodes themselves. Each point in the original
drawing has a corresponding point in the modiﬁed drawing. Although there
are a variety of ways to select the point sets, we easily choose that the point
set of a drawing includes all the nodes of the graph in this paper because there
is at most a node moving in every trial of our simulated annealing algorithm
– it suﬃces to compute only the values related to the moved node.
For the consistency with the original work in [14], we use the same notations
as follows. P and P ′ always refer to the point sets for drawings D and D′, re-
spectively. Since only one point moves in each trial of our simulated annealing
algorithm, we denote the moved point by p, and p′ ∈ P ′ is the corresponding
point for p (and vice versa). The number of nodes in V is n. Let d(p, q) be the
Euclidean distance between points p and q.
In the following, every component of M is introduced.
(1) Ranking: Considering the fact that the relative horizontal and vertical po-
sitions of a node should not vary too much, we add to M the component,
rank(P, P ′), deﬁned as follows:
η1
UB
min{|right(p)− right(p′)|+ |above(p)− above(p′)|, UB}
12
where η5 is the normalizing factor; UB = |E|; edits(e, e′) is deﬁned as
follows:
edits(e, e′) =
⎧⎪⎨
⎪⎩
1, if the angle included between e and e′ is small;
0, otherwise.
, in which e′ is the corresponding edge of e in D′.
(6) Average relative distance: The average relative distance is the average of
the distances from p to the other nodes. Therefore, we add the term
rdist(P, P ′) =
η6
n(n− 1)
∑
q∈P
|d(p, q)− d(p′, q)|
where η6 is the normalizing factor.
Note that the work of [14] suggested eight best similarity measures for orthog-
onal drawings, but here only six of them are included in our mental map cost
function. Among them, the measures of preserving the orthogonal ordering
(called Orthogonal Ordering in [14]) of nodes and minimizing the distance of
the movement of the selected node (called Average Distance in [14]) are ex-
cluded in our work. In addition to improving the computationally eﬃciency of
our algorithm, our reasons are given as follows. If we arbitrarily add some new
nodes and edges to an interactive drawing so that some new edge crossings are
introduced, then the new edge crossings cannot be eliminated by an algorithm
of preserving the orthogonal ordering of nodes. But also the minimization of
edge crossings is usually viewed as the most important aesthetic criteria in
graph drawing [16]. Therefore, we exclude the measure of preserving the or-
thogonal ordering of nodes. In fact, we observe that our experimental results
without this measure still preserve a high degree of orthogonal order of nodes.
On the other hand, the measure of minimizing the distance of the movement
of the selected node is excluded because it has been implied by the selection
of the neighborhood of a conﬁguration in the simulated annealing algorithm.
In addition, it also can be viewed as being achieved in part by the edge length
component in the energy cost function.
3.2.2 Our algorithm
Our algorithm is given in Algorithm 2, which is almost the same as the DH
algorithm except the if condition at step 2(b) is replaced as the conjunction of
the original condition and M < 	M , where 	M is the maximal tolerance of the
mental map cost M that accepts the new drawing D′. Note that the energy
cost and the mental map cost are considered independently in Algorithm 2,
because the main goals of the two costs are diﬀerent: the former one is used
for drawing graph nicely; the latter one is used for preserving the mental map.
We observe that each component in the mental map cost can be normalized
14
one with two edges and the other with four edges. The locations of the two
nodes are decided randomly, and the other end points of the six edges are
connected to arbitrary nodes of the original graph. Finally, we compare the
drawings of the modiﬁed graph produced by our algorithm and the DH algo-
rithm, respectively.
Our prototype system runs on an Athlon 64 X2 Dual Core 1.99 GHz PC with
1.25 GB memory. The statistics of the running time for three experimental
results by using the DH algorithm and our algorithm is given in Table 1. It is
not unexpected that our algorithm runs slower than the DH algorithm since
our algorithm considers more criteria than the DH algorithm. Therefore, like
the DH algorithm, it is concluded that our algorithm are only suitable for
handling moderate-sized graphs.
Table 1
The statistics of the running time by using the DH and the our algorithms.
Problem |V | |E| DH our
Figure 3(c) 8 15 0.2182 sec 0.3064 sec
Figure 5(c) 23 26 1.1030 sec 1.8252 sec
Figure 7(c) 65 68 8.7124 sec 16.0220 sec
Consider the ﬁrst simple experiment shown in Figure 3. A initial random
drawing is given in Figure 3(a). After applying the DH algorithm under diﬀer-
ent settings of parameter λ4 , three possible nice-looking drawings are given in
Figure 3(b), where the degrees of penalizing edge crossings in (i)–(iii) are from
high to low. Subsequently, as shown in Figure 3(c), we arbitrarily add two new
nodes 7 and 8 to each of the three drawings, where node 7 is connected to
nodes 4 and 5; node 8 is connected to nodes 1, 3, 4, and 5. The modiﬁed graph
is redrawn by our algorithm, as shown in Figure 3(d). In order to compare
with the drawings without taking into account the mental map, we show two
additional drawings for each of the three drawings in Figure 3(c): each of the
three drawings in Figure 3(e) (resp., Figure 3(f)) shows the drawing produced
by applying the DH algorithm to the corresponding drawing in Figure 3(c)
(resp., a random drawing of the modiﬁed graph under the same setting of
parameter as the corresponding drawing).
In comparing Figure 3(d) with Figure 3(c), we observe that our algorithm has
the capacity of drawing graph nicely. In comparing Figure 3(d) with Figure
3(b), it is not hard to see that the drawing contour of the graph and the relative
positions of nodes are very similar, and therefore, it deserves to say that our
algorithm can preserve a high degree of mental map for this experiment. On
the other hand, the drawings in Figures 3(e) and 3(f) produced by the DH
algorithm share little similarity with those in Figure 3(b).
16
13
4
5
6
2
1
2
3
4
56
1 2
3
4
5
6
1
2
3
4
5
6
1
2
3
4
5
6
1
2
3
4
5
6
1
2
3
4
5
6
1 2
3
4
5
6
1
2
3
4
5
6
1
2
3
4
5
6
1
2
3
4
5
6 1
2 3
4
5 6
(a) Figure 3(c) without nodes 7 and 8. 
(i) (ii) (iii)
(b) Figure 3(d) without nodes 7 and 8. 
(i) (ii) (iii)
(d)  Figure 3(f) without nodes 7 and 8. 
(i) (ii) (iii)
(c)  Figure 3(e) without nodes 7 and 8. 
(i) (ii) (iii)
Fig. 4. Removing nodes 7 and 8 from Figures 3 (c)–(f).
Furthermore, in order to manifest the eﬀects of preserving the mental map,
if we remove the additional nodes 7 and 8 and their adjacent edges from the
drawings in Figures 3(c)-(f), it becomes clearer why the drawings Figure in
3(d) preserve better mental maps (see Figure 4). Since the mental map criteria
and the aesthetic criteria are often in conﬂict with one another, there is a
trade-oﬀ between preserving a high degree of mental map and achieving some
aesthetic criteria such as minimizing the number of edge crossings. Fortunately,
our algorithm allows users to adjust the weights between diﬀerent criteria, in
order to ﬁt their drawing requirements. For example, we observe that node 5
in Figure 4(b)(i) (which is produced by our algorithm) does not preserve its
18
drawing in Figure 5(f), which achieves the minimum number of edge crossing
among all possible drawings of the modiﬁed graph.
Figure 6(a)–(d) simply displays the drawings after removing the additional
nodes 22 and 23 from Figures 5(c)-(f), respectively. In comparing Figure 6(b)
with Figure 6(a), we can observe that the drawing in Figure 6(b) almost
preserves the shape and structure of the drawing in Figure 6(a) except the
orderings of node pairs (6,7) and (18, 20) are diﬀerent. As mentioned earlier,
preserving the mental map and optimizing some aesthetic criteria may not
be achieved simultaneously. The reason why the orderings of the two pairs
of nodes are diﬀerent is that the drawing in Figure 6(b) corresponds to the
drawing Figure 5(d) which induces fewer edge crossings than the case when
the orderings are not modiﬁed. In comparing Figure 6(c) with Figure 6(a),
assuming node 1 as the root of the tree, although the counterclockwise ordering
of the children of node 1 is preserved, the subtrees rooted at nodes 2, 3, and
4 look diﬀerent. In comparing Figure 6(d) with Figure 6(a), it is obvious that
the mental map is not preserved.
1
2 3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
1
2
3
4
5
6
78
9
10
11
12
13
14
15 16
17
18
19
20
21
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
(a) Figure 5(c) without nodes 22 and 23. (b) Figure 5(d) without nodes 22 and 23.
(c) Figure 5(e) without nodes 22 and 23. (d) Figure 5(f) without nodes 22 and 23.
1
2 3
4
5
6
7
8
9
10
11
12
13
14
15
16
1718
19
20
21
Fig. 6. Drawings obtained from Figures 5 by deleting nodes 22 and 23.
Finally, we present the experiment of a complete binary tree with 63 nodes
and 62 edges. Similar to the previous experiments, Figures 7(a)–(f) show a
random drawing of the initial graph, the nice drawing produced by the DH al-
gorithm, the drawing of the modiﬁed graph by adding two nodes, the modiﬁed
20
12
3
4 5
6
7
8
9
10 11
12
13
14
1516
17
18
19
20 21
22
23
24
25
26
27
28
29
30
31
3233
34
35
36
37
3839
40
41
42
43
4445
46
47
48
49
50
51
5253
54
55
56 57
58
59
60
61
62
63
1
2
3
4 5
6
7
8
9
10 11
12
13
14
1516
17
18
19
20 21
22
23
24
25
26
27
28
29
30
31
3233
34
35
36
37
3839
40
41
42
43
4445
46
47
48
49
50
51
5253
54
55
56 57
58
59
60
61
62
63
64
65
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
1819
20
21
22
23
24
25
26
27
28
29
30
31
3233
34
35
36 3738
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60 61
62
63
64 65
(a) the initial drawing. (b) applying the DH algorithm to (a).
(c) adding nodes 64 and 65 to (b). (d) applying our algorithm to (c). 
(f) applying the DH algorithm to a random
     drawing of the graph in (c). 
(e) applying the DH algorithm to (c). 
23
1
2
3
5
7
8
9
10
11
13
14
15
18
19
20
21
22
25
26
27
29
31
32
33
34
35
36
37
38
3940
41
42
43 45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
0
61
62
63
4
6
12
16
17
24
28
30
44
1
2
3
4
5
6
7
8
9
10
11
1213
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29 30
3132
33
3435
36
37
38
39
40
41
42
43
4445
46
47
4849
50
51
52
53
54 55
56
57
58
59 60
61
62
63
64
65
1
2
3
4
6
7
8
9 10 11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29 30
31
32
33
34
35
36
37
3839
40
41
42
43
4445
4647
4849
50
51
52
53
54
55
56 57
58
59
6061
6263
64
65
Fig. 7. The experiment for an initial complete binary tree with 63 nodes.
22
in comparing the vertical axes in Figure 9 (by using the DH algorithm) and
Figure 10(a) (by using our algorithm), the value of the energy cost in Figure
9 is larger than that in Figure 10(a) by about 4 billion. This is because the
weight of the measure of penalizing the number of edge crossings (as one of the
most important measures of a nice drawing) is set as a huge value. In order
to preserve the mental map, our algorithm produces the drawing in Figure
10(d) with three more edge crossings than the drawing in Figure 10(e), which
reﬂects in part the value of 4 billion.
˅
˅ˁ˄
˅ˁ˅
˅ˁˆ
˅ˁˇ
˅ˁˈ
ˇ˃˃˃ ˉ˃˃˃ ˋ˃˃˃ ˄˃˃˃˃ ˄˅˃˃˃ ˄ˇ˃˃˃ ˄ˉ˃˃˃ ˄ˋ˃˃˃ ˅˃˃˃˃
˄˅ʳ˵˼˿˿˼̂́ʳʾ
́̈̀˵˸̅ʳ̂˹ʳ˼̇˸̅˴̇˼̂́̆
̇˻˸ʳ˸́˸̅˺̌ʳ˶̂̆̇
(a)
˃
˃ˁ˄
˃ˁ˅
˃ˁˆ
˃ˁˇ
˃ˁˈ
˃ˁˉ
˃ˁˊ
ˇ˃˃˃ ˉ˃˃˃ ˋ˃˃˃ ˄˃˃˃˃ ˄˅˃˃˃ ˄ˇ˃˃˃ ˄ˉ˃˃˃ ˄ˋ˃˃˃ ˅˃˃˃˃
́̈̀˵˸̅ʳ̂˹ʳ˼̇˸̅˴̇˼̂́̆
̇˻˸ʳ̀
˸́̇˴˿ʳ̀
˴̃ʳ˶̂̆̇ʳˠ
(b)
˅ˁˆˈ
˅ˁˆˉ
˅ˁˆˊ
˅ˁˆˋ
˅ˁˆˌ
˅ˁˇ
ˊ˄˃˃ ˊ˅˃˃ ˊˆ˃˃ ˊˇ˃˃
˄˅ʳ˵˼˿˿˼̂́ʳʾ
́̈̀˵˸̅ʳ̂˹ʳ˼̇˸̅˴̇˼̂́̆
̇˻˸ʳ˸́˸̅˺̌ʳ˶̂̆̇
(c)
˃
˃ˁ˄
˃ˁ˅
˃ˁˆ
˃ˁˇ
˃ˁˈ
˃ˁˉ
ˊ˄˃˃ ˊ˅˃˃ ˊˆ˃˃ ˊˇ˃˃
́̈̀˵˸̅ʳ̂˹ʳ˼̇˸̅˴̇˼̂́̆
̇˻˸ʳ̀
˸́̇˴˿ʳ̀
˴̃ʳ˶̂̆̇ʳˠ
(d)
Fig. 10. The plots of the costs versus the number of iterations by applying our
algorithm to transforming Figure 7(c) into Figure 7(d).
5 Conclusion and Future Works
In this paper, we presented a simulated-annealing-based graph drawing algo-
rithm, taking the preservation of the mental map into account. Our algorithm
helps us better preserve the drawing contours of graphs and the relative po-
sitions of nodes when a slight modiﬁcation is made to the original graph.
By using our algorithm, users may spend less time to relearn the modiﬁed
drawing. However, preserving the mental map and optimizing some aesthetic
criteria are often in conﬂict with one another. Fortunately, our implementation
allows users to adjust the weights of diﬀerent criteria.
In addition to the factors considered in this paper, graph features (such as
color, node size, shape or line width) also may play a key role in the preser-
24
[13] R. Davidson, D. Harel, Drawing graphs nicely using simulated annealing, ACM
Transactions on Graphics 15 (4) (1996) 301–331.
[14] S. Bridgeman, R. Tamassia, A user study in similarity measures for graph
drawing, Journal of Graph Algorithms and Applications 6 (3) (2002) 225–254.
[15] S. Kirkpatrick, C. D. Gelatt Jr., M. P. Vecchi, Optimization by simulated
annealing, Science 220 (1983) 671–680.
[16] H. C. Purchase, Which aesthetic has the greatest eﬀect on human
understanding?, in: Proceedings of Graph Drawing 1997, Vol. 1353 of Lecture
Notes in Computer Science, 1997, pp. 248 – 261.
[17] S. L. Franconeri, A. Hollingworth, D. J. Simons, Do new objects capture
attention?, Psychological Science 16 (2005) 275–281.
[18] R. A. Rensink, Change detection, Annual Review of Psychology 53 (2002) 245–
277.
26
1 Introduction
As graphs are known to be one of the most important abstract models in
various scientiﬁc and engineering areas, graph drawing (or information visu-
alization in a broader sense) has naturally emerged as a fast growing research
topic in computer science (e.g., see [1]). In visualizing graphs associated with
real-world entities, it is common to annotate each node with some labels (such
as name, attribute), and a good way to display such information (in the form
of text or icon) is to ﬁll the information inside the drawing of the node. As
a result, it is of importance and interest to be able to cope with nodes of
diﬀerent sizes and shapes in graph drawing.
Among various graph drawing techniques reported in the literature, the so-
called force-directed methods (see, e.g., [2–9]) have received much attention
and have become very popular for drawing undirected graphs. In such a frame-
work, a graph is viewed as a system of particles with forces acting between the
particles, and then a good conﬁguration or drawing of the particles could be
generated with locally minimal energy, i.e., the sum of the forces on each par-
ticle is zero. According to the experimental and theoretical results of [10,11],
graph drawing methods based on the force-directed strategy usually enjoy
the merit of producing graph layouts with a high degree of symmetry and
uniformity of the edge length.
Unfortunately, most of the conventional force-directed graph drawing algo-
rithms only deal with graphs with zero-sized nodes. A naive extension of con-
ventional drawing algorithms by plugging in objects of nonzero size for point
nodes in the drawing is unlikely to produce a high quality drawing. In view of
this, it becomes apparent that a new line of research has to be carried out in
hope of narrowing the gap between the conventional force-directed algorithms
and graphs consisting of nodes of various sizes and shapes that are frequently
encountered in the real world.
In this paper, we present a new approach, combining the force-directed strat-
egy as well as the theory of potential ﬁelds, for drawing graphs with nonuniform
nodes. Although there exist other conventions (e.g., like hierarchical-layered
drawing [12] and orthogonal drawing [13]) for drawing graphs with nonuniform
nodes, we for the ﬁrst time take node rotations into account when implement-
ing our force-directed-based drawing algorithm. The concept of potential ﬁelds
has already found applications in a variety of areas in computer science and
engineering, such as path planning [14,15], among others. In our setting, each
edge is modelled by a spring (like in conventional force-directed methods) and
the boundary of every nonuniform node is uniformly charged. We consider
both 2-dimensional and 3-dimensional drawings of nonuniform nodes, each of
which is represented by a polygon (in 2-D) or polyhedron (in 3-D). Other
2
has already been drawn nicely, our idea (motivated by [17]) is to view the
convex hull (polygon) of each nicely drawn cluster as a nonuniform node ﬁrst.
The next step is to produce a nice drawing for the graph with its constituent
clusters represented by nonuniform nodes. In the ﬁnal phase of the drawing
procedure, the details of each cluster are then plugged into the corresponding
nonuniform node. The drawing approach by abstracting out the details of each
cluster runs very eﬃciently, making the method suitable for graph drawing in
dynamic scenarios (see, e.g., [18]).
We develop a prototype system to compare our new graph drawing method
with other existing approaches empirically. Our experimental results look
promising as our subsequent discussion indicates. However, our method is
executed slower than the previous methods for moderate-sized graphs with-
out rotations of nonuniform nodes, and hence our method is only suitable
for moderate-sized interactive graphs or larger-sized static graphs (note that
graph drawing algorithms may be designed for the static or dynamic scenarios,
e.g., the work of [19] presented algorithms for generating orthogonal drawings
in the static and dynamic scenarios). Therefore, ﬁnding a more eﬃcient algo-
rithm for drawing graphs with nonuniform nodes remains open. In addition,
note that the rotations of nonuniform nodes are not necessarily allowed for any
application. Therefore, we give an example applied to a UML class diagram
by using our approach in this paper.
The rest of this paper is organized as follows. Section 2 gives some prelim-
inaries. In Section 3, the theory behind potential ﬁelds in graph drawing is
developed in depth. Section 4 gives some experimental results in 2-D and 3-D,
and Section 5 gives an application. Finally, a conclusion is given in Section 6.
2 Preliminaries
In this section, we deﬁne graphs with nonuniform nodes as well as the con-
cerned problem, and brieﬂy introduce force-directed methods.
2.1 Basic deﬁnitions
A graph is a pair G = (V,E) where V is the set of nodes and E ⊆ V × V is
the set of edges. A drawing of a graph G on the plane is a mapping D from
V to R2, where R is the set of real numbers. That is, each node v is placed at
point D(v) on the plane, and each edge (u, v) is displayed as a straight-line
segment connecting D(u) and D(v).
4
2.2 Deﬁning the problem
The drawing problem considered in this paper is addressed as follows. Sup-
pose we begin with an initial drawing of a GNN, one is required to produce
a nice drawing of the GNN with respect to the following aesthetic criteria:
no overlapping between any two nonuniform nodes, no overlapping between
any pair of nonuniform node and edge, symmetry, uniform edge length, and
minimizing the size of the drawing. In addition, the eﬃciency of the drawing
algorithm is also factored into our design.
2.3 Previous work on force-directed methods
The graph drawing algorithm of [23,24] described by pure mathematics can
be regarded as the earliest force-directed method. In the Tutte model, the set
of nodes is divided into two sets, a set of ﬁxed nodes and a set of free nodes.
By nailing down the ﬁxed nodes as a strictly convex polygon and then placing
each free node at the barycenter of its neighbor in each iteration, the model
can yield a nice drawing.
Furthermore, since the introduction of the simple force-directed method by
Eades in [4] (a.k.a. spring algorithm), there has been a number of variants of
force-directed approaches reported in the literature. Generally speaking, such
modiﬁcations fall into the following two categories. One has to do with altering
the repulsive force and the spring force models, while the other attempts to
manipulate the local minima problem resulting from the equilibrium between
attractive and repulsive forces.
The model introduced by Eades uses logarithmic strength springs in place
of Hooke’s Law for spring forces fa, and the inverse square law for repulsive
forces fr as follows:
fa(duv) = (ca ∗ log(|duv|/l))duv/|duv| (1)
fr(duv) = −
(
cr/|duv|2
)
duv/|duv|
where ca and cr are scaling constants, l is the given spring natural length,
and duv is the vector from node u to node v. Besides above considering repul-
sive forces between every node-node pair, the models of considering repulsive
forces between every node-edge pair [2] and every edge-edge pair [25] also were
developed to preserve the edge crossing property and handle the zero angular
resolution problem respectively.
Subsequently, a number of variations of spring algorithms have been proposed
6
In each iteration of our algorithm, each nonuniform node moves and rotates
respectively according to the force (consisting of repulsive and spring forces)
and the torque (consisting of repulsive and spring torque) acting at that node.
In what follows, since we use Eq. (1) as the spring force formula, we mainly fo-
cus on deriving the repulsive forces as well as the repulsive and spring torques.
Note that the torque acting at each nonuniform node is a measure to cause
that node to rotate counterclockwise about an axis, called pivot point of that
node, i.e., the rotation center of the node.
In what follows, we only consider the style of S2 (the remaining styles are
similar and simpler) and elaborate on the foundations of the theory behind
the use of potential ﬁelds in graph drawing. The reader is referred to [14,15]
for more about potential ﬁelds as well as some of the detailed derivations of
formulas involved in our subsequent discussion.
3.1 2-D model
Consider two polygons (representing two nonuniform nodes) A and B in 2-D
connected by two edges a1b2 and a3b2 as shown in Figure 2(a). A has vertices
a1, ..., a6, and B has b1, b2, and b3 along their boundaries. Each polygon is asso-
ciated with a pivot point exerted by repulsive and attractive forces, and shifts
and rotations are carried out with respect to this pivot point. For instance, in
Figure 2 ea and eb are the pivot points of A and B, respectively. In xy-plane,
for any two points of unit charge and of distance r apart, the Newtonian po-
tential is deﬁned as V = 1/r and the Newtonian potential of a point q with
respect to a uniformly charged line segment a1a2 is V =
∫ a2
a1
1/r(x)dx where
r(x) is the distance between q and x. Figure 3 shows uniformly charged edges
along with the equi-potential contours.
A
Bea
b2 = eb
a6
b3
b1
y
x
v
u
ea
A
B
(a) (b)
u1
v = au + b
a1
a2
a3
a4
a5
b1
u2
a1 a2
),(Q
b2 = eb
Fig. 2. Coordinate transformation of a 2-D graph with two nonuniform nodes A
and B where ea and eb are the pivot points. (a) The original coordinate system
(xy-plane). (b) The new coordinate system (uv-plane) after the transformation.
Consider two line segments a1a2 and b1b2 on the new coordinate system (uv-
plane), placing a1 on the original point and a1a2 on the positive u-axis (v-
8
+√
1 + a2
a
(f
1/2
1 (u)− f 1/22 (u)) (4)
whose direction is iz = iu× iv, in which iu and iv are the unit vectors of u-axis
and v-axis, respectively.
In addition, the torques due to the spring forces should be considered. For
example, in Figure 2, suppose the attractive force on the point b2 due to the
spring edge b2a1 is equal to fa(
−−→
b2a1), from Eq. (1), and B rotates with respect
to the pivot point eb. The torque with respect to point eb due to the attractive
force fa(
−−→
b2a1) from spring b2a1, on point b2, is equal to the cross product
(b2 − eb)× fa(−−→b2a1). (5)
Note that it is inappropriate to choose the center of shape as the pivot point
of a polygon because the forces and torques due to springs are computed by
the spring lengths and each spring is not connected to the center of shape.
Instead, the mean of the coordinates of the vertices connected by springs is
selected as the pivot point. Take Figure 2 for instance. A has vertices a1 and
a3 connected by springs, and the midpoint of a1 and a3 is the pivot point of
A. B only has a single vertex b2 connected by a spring, and hence b2 is the
pivot point of B.
In view of the above derivations, the force between two polygons can be de-
rived. For example, in Figure 2, the total repulsive force on polygon B due to
polygon A is equal to
Fr =
∑
i∈B(B)
∑
j∈B(A)
f ijr (6)
where B(X) is the set of border lines of polygon X, and f ijr = (f ijru , f ijrv) is
the repulsive force on border line segment i due to j in which f ijru (resp., f
ij
rv)
is the component along the u-axis (resp., v-axis) computed by Eq. (2) (resp.,
Eq. (3)).
On the other hand, the total spring force on polygon B due to all of the springs
is equal to
Fa =
∑
p∈P(B)
∑
(p,q)∈E
fa(−→pq) (7)
where P(B) is the set of vertices of B, E is the edge set, p is a vertex of B, q
is a vertex of some polygon, and fa is the spring force deﬁned in Eq. (1).
10
(b)
(a)
B
eb
q
A
ea
C1
C2
C4
C3
S
q
R Q
P10 C1
C2
C4
S
l1-
l1+
C3
P10^
n^
u1
^
q’q
d
l1
^
l1
{
ix = l1
^
iz = n^
iy = - u1^
Fig. 4. A 3-D graph consisting of two polyhedrons. (a) Uniformly selected sampling
points on the surfaces of the right polyhedron B. (b) Geometric quantities associated
with a sampling point q from B and a surface S of A, where Q is the plane containing
S.
In 3-D, the repulsive force between two polyhedrons A and B is the sum of
the repulsive forces of every possible pair of polygonal surfaces in A and B.
However, the repulsive force between two polygonal surfaces is a complicated
four-order integral. In order to reduce the complexity of computing repulsive
forces between A and B, we uniformly select sampling points on the surfaces
of each polyhedron. Hence the repulsive force on B due to A is the sum of the
repulsive forces at each sampling point q due to every polygonal surface of B.
See Figure 4(a) for an illustrating example. The complexity of computing the
forces between two polyhedrons can be reduced because the forces at a single
point due to polygons is a two-order integral.
Assume that SP(X) is the set of sampling points of polyhedron X and S(X)
is set of polygonal surfaces of polyhedron X. The repulsive force at a sampling
point pi on B due to A is the sum of the repulsive forces at pi due to n (all)
polygonal surfaces on A. Thus, the repulsive force Fr, standing for the force
at B due to A, is the sum of the repulsive forces for all sampling points on B,
as follows:
Fr =
∑
i∈SP(B)
∑
j∈S(A)
F ijr (10)
where the repulsive force at pi due to the j-th polygonal surface of A is denoted
12
4.1 Algorithm
Our drawing algorithm, based upon the theory of potential ﬁelds, is presented
in Algorithm 1, which has a structure similar to those found in conventional
force-directed methods. The algorithm operates iteratively to generate a con-
tinuous process from the initial drawing to the ﬁnal drawing, as shown in
Figure 7. It is worthy of pointing out that the process allows the user to pre-
dict the dynamics of the drawing, which meets the requirement in information
visualization.
Algorithm 1 Potential Spring (graph G)
1: assign the initial locations of nonuniform nodes of G according to a given
(or random) initial drawing
2: while converged = 1 or the maximal number of iterations is reached do
3: converged← 1
4: oldPosn← newPosn
5: for each nonuniform node Ni in G do
6: Calculate the total force Fi of node Ni, consisting of:
(a) the repulsive force due to the other nonuniform nodes located
within the neighborhood of node Ni (the circle in 2-D (ball in 3-D)
with center Ni and a small radius γ) according to spring force
formula (1), and
(b) the spring force due to its adjacent springs according to repulsive
force formulas (2) and (3) in 2-D or (9) in 3-D;
7: Calculate its total torque Ti according to 2-D formulas (4) and (5)
or 3-D formulas (13) and (14);
8: Save Fi and Ti;
9: end for
10: for each nonuniform node Ni in G do
11: Simultaneously move and rotate every nonuniform node Ni according
to min(c1×Fi, t1) and min(c2×Ti, t2), respectively,and then save new
positions to newPosn;
12: if ‖c1Fi‖ > 1 or ‖c2Ti‖ > 2 then
13: converged← 0
14: end if
15: end for
16: end while
In Algorithm 1, c1 and c2 (resp., t1 and t2) are constants used to control the
magnitudes (resp., upper bounds) of movement and rotation of every nonuni-
form node, NewPos and OldPos are data structures used to record the new
and old positions of vertices of all nonuniform nodes in N respectively, and 1
(resp., 2) in line 12 is the tolerance of convergence for force (resp., torque)
which is usually a very small positive number. In addition, by using the ﬂag
converged, the while loop in lines 2–16, especially lines 2–4 and 12–14, stops
14
then it implies that the value of γ should be incremented.
The way of rotating a nonuniform node in line 11 is by taking the pivot
point as the center of rotation and rotating with an angle with degree c2×Ti
counterclockwise.
As for the time complexity, since line 6(a) in Algorithm 1 needs to enumerate
all pairs of nonuniform nodes, one can easily check that each iteration of
Algorithm 1 takes time O(|N |2+ |E|). Line 6(a) in Algorithm 1 may take time
O(|N |) if nonuniform nodes are uniformly distributed in the 2-D plane (note
that the situation often occurs in the drawings generated by force-directed
methods). In this case, each iteration of Algorithm 1 taking time O(|N | +
|E|) may be executed eﬃciently. In order to evaluate the total number of
iterations experimentally, we execute our algorithms on a number of GNNs
with moderate sizes (|N | ≤ 100), which are generated randomly, under our
setting of parameters. The experimental evaluation shows the total number of
iterations to be at most about 1000.
Intuitively, our approach with repulsive forces between nonuniform nodes
would handle the problem of node-node overlapping 1 , except for the case
when the pivot point of a small-size node falls inside a large node. If there is
no overlapping in the initial drawing, the case occurs only when the small-size
node moves too fast such that it rushes into the big-size node, and hence the
problem can be solved by setting c1 smaller. An alternative strategy is that
each iteration checks out this case and add a repulsive force between the two
nodes.
Aside from the problem of node-node overlapping, the problem of node-edge
overlapping also needs to be taken into account. The work of [16] has detailed
the problem for the case when using force-directed methods to draw GNNs.
In [16], it was proven that a drawing is free from edge-node overlapping if the
distance between any two nonuniform nodes is at least half of the maximal
edge length. If we also consider uniform edge lengths, it is required that the
ratio between the maximal edge length and the minimal edge length is less
than two. Hence, in practice edges rarely intersect with nodes if the deviation
between the edge lengths is not too large. Moreover, a post-processing strategy
may be applied to remove node-edge overlapping, e.g, adding repulsive forces
between nodes and edges [3] or drawing edges as curves [28], bypassing the
intersected nodes.
Since our approach needs expensive computational costs to obtain repulsive
forces in each iteration, applying an extension of the conventional spring algo-
rithms (viewing each nonuniform node as a zero-size point) as the preprocess-
1 Without considering edges, the approach of [27] produces the drawing of style S3
without the overlapping between the rectangular nodes.
16
initial weak springs medium springs strong springs
Fig. 5. A variety of drawings of style S2 for the same GNN with respect to diﬀerent
kinds of springs. (average running time per iteration: 0.00452 sec.)
iteration 500iteration 10 iteration 20 iteration 30intial
Fig. 6. Continuous process from initial drawing to ﬁnal drawing of style S2 with
multiple edges for a bird structure. (average running time per iteration: 0.108374
sec.) Note that in this case each spring has diﬀerent strength for yielding good
drawing.
random
drawing
final drawing
(iteration 50)iteration 1 iteration 2 iteration 3 iteration 4 iteration 10
(a) A simple case makes us easy to realize how to follow the dynamic drawing.
(b) Bigger nodes walk along a collision-free path.
random
drawing
final drawing
(iteration 244)
iteration 5
iteration 10
iteration 15
iteration 20
iteration 25
iteration 30
Fig. 7. Continuous process from initial drawing to ﬁnal drawing.
Figure 8 gives some 2-D drawings for various graphs with rectangular nodes,
where the graphs of (a)–(d) comes from the analogies of the examples of [16]
in which we initially give every nonuniform node a certain angle of inclina-
tion, and the experimental statistics is given in Table 1. For comparison, ﬁve
drawings for each graph are given in Figure 8. That is, the initial drawing
18
displays graphs by randomly assigning the location and the inclination degree
of every nonuniform node, while the classical, HK, our drawings with stronger
and weaker springs display graphs by respectively using the naive extension of
[4] 2 , [16], and Algorithm 1 with respect to the initial drawing. The criteria of
displaying smaller drawing area and more symmetries may be conﬂicting with
each other, and hence in Figure 8 our approaches using stronger springs and
weaker springs are applied to respectively display smaller drawing area and
more symmetries. Note that we only give the classical and HK drawings with
stronger springs in Figure 8 because those with weaker springs occupy larger
area and cannot generate any symmetry. It is obvious from Figure 8 to see
that the rotations of nonuniform nodes play an important role in the drawing
area and symmetries.
In Table 1, the term ‘area’ measures the rectangular region bounding the graph
drawing, and the area value is calculated by viewing the smallest (square) node
of graph as one unit. The degree of uniform edge length is measured by the
term ‘standard deviation of edge length’ [16], and obviously a drawing with
more uniform edge length has lower deviation. The symmetries of generic 2-D
graph drawings involve reﬂectional and rotational symmetries, and the rela-
tionship between force-directed methods and symmetries has been formally
deﬁned in [11]. Nevertheless, the symmetries of the drawings for GNNs has
a little diﬀerence. A drawing for GNNs has reﬂectional symmetry if it can
be folded in half along a reﬂection axis and the two halves line up with each
other, while the drawing has k-rotational symmetry if it can be rotated around
degrees 2π/k and still look the same. Table 1 records the number of reﬂec-
tion axes and k in the columns ‘reﬂection axes’ and ‘k-rotational symmetries’
respectively. That is, the higher both the two values are, and the more sym-
metric the drawing appears. In addition, Figures 8(b) and 8(d) reveal that
the drawings of some subgraphs in the drawings generated by our approach
display a high degree of symmetries.
In what follows, we observe and analyze the entries in Table 1 in greater detail.
As for running time, the total running time and total iterations 3 depend on
many complicated factors, e.g., movement magnitude parameter c1, rotation
magnitude parameter c2, force convergence tolerance 1, torque convergence
tolerance 2, nature length of spring, and so on, and hence in Table 1 ‘average
time per iteration’ and ‘number of iterations’ are measured under the setting
c1 = 0.1, c2 = 0.01, t1 = 10, t2 = π/2, 1 = 0.1, 2 = π/1800 = 0.1
◦, γ = 40
2 The classical spring algorithm is carried out by ﬁrst assuming all nodes to be of
zero size. Once the drawing using a spring algorithm is done, each of the point node
is replaced by its actual structure (a small or a large ball).
3 After trying many examples of moderate-size graphs, we ﬁnd that our approach
can generate nice drawing by taking about two or three times of the number of
iterations of HK approach.
20
our procedure. As for symmetries, both Figure 8 and Table 1 suggest that our
approach using weaker springs enjoys the merit of a high degree of symmetries.
(a) classical (b) HK (c) our
Fig. 9. The drawing of a mesh GNN with 10× 10 nodes produced by our approach.
Table 2
Statistics of the experimental result for the mesh GNN shown in Figure 9.
mesh 10× 10 (|N | = 100)
method average time per number of total running
iterations (sec.) iterations time (sec.)
classical .00200 2267 4.531
HK .01187 1316 15.625
Algorithm 1∗ .20775 753 156.438
∗Applying the classical approach as the preprocessing procedure of our ap-
proach (i.e., applying the output of the classical approach as the input of
our approach) costs only about 95.406 sec.
In order to estimate the number of nodes that our algorithms can handle,
Figures 9(a)–(c) give the drawings of a mesh GNN with 100 nodes produced
by the classical approach, the HK approach, and Algorithm 1, respectively,
and their experimental statistics is given in Table 2. In view of Tables 1 and
2, our algorithm can still be considered tractable for handling moderate-sized
graphs, although it runs slower than the others, as expected. On average, for
the GNNs in Table 1, our algorithm runs 263 – 505 times slower than the
classical approach, whereas from Table 2 our algorithm runs about 34.5 times
slower than the classical approach for a 100-node mesh GNN. It implies that,
as far as a larger-sized GNN is concerned, the aﬀect of computing only the
local repulsive forces is getting more obvious, and the gap of time complexity
between Algorithm 1 and the classical approach is getting narrower. Although
Algorithm 1 still run slower than the classical approach by a large multiple,
Algorithm 1 takes about 156.438 seconds (≈ 2.6 minutes) to handle such a 100-
node GNN. This leads us to a conclusion that our algorithm is mostly suitable
for either moderate-sized GNNs or the larger-sized GNNs in the static scenario.
Note that applying the classical approach as the preprocessing procedure of
our approach may reduce the total running time (in the example, this strategy
costs only about 95.406 seconds ≈ 1.6 minutes). It is of interest to see whether
the multi-scale technique [7,8] could be applied and incorporated into our
algorithm to improve the time complexity.
22
Figure 10(d) are oblique, they still can be observed more clearly than those in
Figure 10(a), under the same display screen. If text labels are too oblique to
be observed, we may further restrict every nonuniform node to rotating under
a range of inclination angles.
4.3 3-D experimental results
Now we turn our attention to drawing GNNs in 3-D. Figures 11 shows some
experimental results of our algorithm on pyramid, cube, mesh, ﬂower, and
sphere. As one can easily see, each of the ﬁnal drawings displays a high de-
gree of symmetry and is reasonably ‘nice’. In Figure 11 (e), we compare our
approach with a naive extension of the classical spring algorithm [4] using an
example of a 3-D sphere structure. In this graph, a large ball is surrounded
by a number of small balls. Our potential ﬁelds approach produces a nicer
drawing as Figure 11 (e) indicates. This is because our approach can detect
the large ball and consider it to draw the GNN.
weaker
spring
stronger
spring approximation classical our 
(a) (b) (c) (d) (e) 
Fig. 11. 3-D graph drawing. (a) For the same structure, using diﬀerent springs show
two diﬀerent layouts. (b) Cube structure. (c) Mesh structure. (d) Flower struc-
ture. (e) Sphere structure (our approach uses polyhedrons to approximate spherical
nodes). (Respectively average running time per iteration (sec.): 0.00015, 0.00453,
0.00593, 0.02203, 0.02375)
It should be noticed that the nonuniform nodes (polyhedrons) in each graph of
Figure 11 do not display symmetrically. The reason is that our 3-D approach
uses sampling points to approximate each polyhedron for reducing the run-
ning time, and hence it may easily result in local minimal problems between
polyhedrons.
5 Applications
Aside from the fact that natural objects tend to be of nonzero size, another
motivation behind the need of handling GNNs has to do with drawing clus-
tered graphs. Consider the scenario of drawing a graph with millions of nodes.
Applying a drawing algorithm to the huge graph directly suﬀers from a num-
ber of drawbacks. Disregarding the ineﬃciency of the method, the outcome of
24
can be abstracted out by regarding its convex hull as a nonuniform node. See
Figure 12(c)(d). The next step is to apply our approach to producing a layout
of the GNN such as Figure 12(e) shows. Finally, a nice drawing of the original
clustered graph is obtained by restoring the details of all the clusters as Figure
12(f) illustrates. Now suppose new nodes are added to or deleted from Figure
12(a). Instead of running the drawing algorithm on the new (possibly huge)
graph all over again, our approach allows us to keep the internal drawings of
those unaﬀected (due to insertion/deletion of nodes) clusters intact, while the
redrawing need only be applied to a much smaller graph, giving rise to a much
better performance.
With respect to hierarchical clustered graphs, the superiority of our approach
is two-fold. First, by taking advantage of the cluster structure, our method
requires a much lesser amount of computation than the EH method as pointed
out in the above discussion. Furthermore, the drawing quality of our approach
is also better than the EH method with respect to the example shown in Figure
13. To see this, the drawings of clusters C2 and C5 are somewhat distorted
by using the EH method; on the other hand, these two clusters are nicely
displayed by ours. (See the left-most drawings of Figures 13 (b) and (c).)
Now if we add two edges to the graph (see the middle drawings of Figures 13
(b) and (c)), and re-draw the graph using the two methods, we end up with
the right-most drawings of Figures 13 (b) and (c). Comparing the left-most
drawing with the right-most drawing in Figure 13 (b), the embedding (see
the C3 and C4 clusters) and the contour (see the C2 cluster) have changed.
Our approach, on the other hand, does not have this problem as Figure 13 (c)
shows.
Note that our approach, however, may have a disadvantage as follows. By
using our approach, the inter-cluster edge incident to a node that is not drawn
on the boundary of a cluster (polygon) induces unavoidable edge crossings
(see the thick edge in the right-most of Figures 13 (c)). This is because the
drawings of clusters which are generated in earlier stages and will not be
changed afterwards are not aware of whether the nodes drawn inside the cluster
drawings are connected by inter-cluster edges in later stages.
Although the graph used in Figures 12 and 13 is a hierarchical clustered graph
with a 3-level inclusion tree, our approach can easily be applied to more com-
plicated hierarchical clustered graphs. Figure 14(a) gives an example of the
drawing of a 4-level hierarchical clustered graph. In comparison with Figure
14(b) which is generated by using the classical embedder [4] (regardless of its
cluster structure), our approach performs about 13 times more eﬃciently than
the classical approach. Figure 14(a) in fact displays the cluster structure of
the hierarchical clustered graph. What makes our approach run faster than
the classical one is that our drawing method need not re-draw the clusters at
the lower levels when processing the clusters at the higher levels. As the size
26
instances for our approach such that users may decide whether our approach
suits their practical needs.
References
[1] K. Kaufmann, D. Wagner (Eds.), Drawing Graphs: Methods and Models, Vol.
2025 of LNCS, Springer, 2001.
[2] F. Bertault, A force-directed algorithm that preserves edge crossing properties,
in: Graph Drawing 1999, Vol. 1731 of LNCS, Springer, 1999, pp. 351–358.
[3] R. Davidson, D. Harel, Drawing graphs nicely using simulated annealing, ACM
Transactions on Graphics 15 (1996) 301–331.
[4] P. Eades, A heuristic for graph drawing, Congress Numerantium 42 (1984) 149–
160.
[5] A. Frick, A. Ludwig, H. Mehldau, A fast adaptive layout algorithm for
undirected graphs, in: Graph Drawing ’94, Vol. 894 of LNCS, Springer, 1995,
pp. 388–403.
[6] T. Fruchterman, E. Reingold, Graph drawing by force-directed placement,
Software-Practice and Experience 21 (1991) 1129–1164.
[7] S. Hachul, M. Ju¨nger, Drawing large graphs with a potential-ﬁeld-based
multilevel algorithm, in: Graph Drawing 2004, Vol. 3383 of LNCS, Springer,
2004, pp. 285–295.
[8] D. Harel, Y. Koren, A fast multi-scale method for drawing large graphs, in:
Graph Drawing 2000, Vol. 1984 of LNCS, Springer, 2000, pp. 183–196.
[9] T. Kamada, S. Kawai, An algorithm for drawing general undirected graphs,
Information Processing Letters 31 (1989) 7–15.
[10] F. J. Brandenburg, M. Himsolt, C. Rohrer, An experimental comparison of
force-directed and randomized graph drawing algorithms, in: Graph Drawing
’95, Vol. 1027 of LNCS, Springer, 1995, pp. 76–87.
[11] P. Eades, X. Lin, Spring algorithms and symmetry, Theoretical Computer
Science 240 (2) (2000) 379–405.
[12] H. Eichelberger, Sugibib, in: Graph Drawing 2001, Vol. 2265 of LNCS, Springer,
2002, pp. 467–468.
[13] C. Gutwenger, M. Ju¨nger, K. Klein, J. Kupke, S. Leipert, P. Mutzel, A new
approach for visualizing UML class diagrams, in: SOFTVIS 2003, ACM Press,
2003, pp. 179–188.
[14] J.-H. Chuang, Potential-based modeling of three-dimensional workspace for
obstacle avoidance, IEEE Transactions on Robotics and Automation 14 (5)
(1998) 778–785.
28
Journal of Graph Algorithms and Applications
http://jgaa.info/ vol. 12, no. 3, pp. 319–356 (2008)
Many-to-One Boundary Labeling
Chun-Cheng Lin 1 Hao-Jen Kao 1 Hsu-Chun Yen 1,2
1Department of Electrical Engineering
National Taiwan University, Taipei, Taiwan 106, ROC
2Department of Computer Science
Kainan University, Taoyuan, Taiwan 338, ROC
Abstract
In boundary labeling, each point site is uniquely connected to a label
placed on the boundary of an enclosing rectangle by a leader, which may
be a rectilinear or straight line segment. To our knowledge, all the results
reported in the literature for boundary labeling deal with the so-called
one-to-one boundary labeling, i.e., different sites are labelled differently.
In certain applications of boundary labeling, however, more than one site
may be required to be connected to a common label. In this case, the
presence of crossings among leaders often becomes inevitable. Minimiz-
ing the total number of crossings in boundary labeling becomes a critical
design issue as crossing is often regarded as the main source of confu-
sion in visualization. In this paper, we consider the crossing minimiza-
tion problem for multi-site-to-one-label boundary labeling, i.e., finding the
placements of labels and leaders such that the total number of crossings
among leaders is minimized. We show the crossing minimization problem
to be NP-complete under certain one-side and two-side labeling schemes.
Subsequently, approximation algorithms or heuristics are derived for the
above intractable problems.
Submitted:
June 2007
Reviewed:
September 2007
Revised:
February 2008
Accepted:
April 2008
Final:
August 2008
Published:
October 2008
Article type:
Regular Paper
Communicated by:
S.-H. Hong
H. Yen is the corresponding author of this paper. Research supported in part by NSC Grant
96-2221-E-002-027, and Research Grant 95-EC-17-A-02-S1-049, Taiwan.
E-mail addresses: sanlin@cobra.ee.ntu.edu.tw (Chun-Cheng Lin) khr@cobra.ee.ntu.edu.tw (Hao-
Jen Kao) yen@cc.ee.ntu.edu.tw (Hsu-Chun Yen)
JGAA, 12(3) 319–356 (2008) 321
is to find the placements of labels and leaders such that the total number of
crossings among leaders is minimized. Aside from minimizing the total number
of crossings, we also consider the issue of minimizing the total leader length
under the framework of many-to-one boundary labeling in this paper.
Labeling key components of a motherboard is an example used in [5] for
illustrating the usefulness of the technique of one-to-one boundary labeling.
For motherboards used in servers or parallel computers, it is common to find
multiple copies of components such as CPUs, chipsets, memory DIMMs, I/O
ports, expansion slots, and so on, on the same motherboard. In this case,
placing labels along the sides of a motherboard involves connecting multiple
sites to a single label, suggesting an example to which many-to-one boundary
labeling can apply. Figure 1 gives the boundary labeling of the ASUS KFN5-
Q/SAS motherboard in a many-to-one fashion. For comparison purpose, the
motherboard is also labeled by two other approaches in Figure 2, where area
labeling in Figure 2(a) places a text label within the boundary of each object,
and legend labeling in Figure 2(b) attaches an assigned number to each object
of the same component, and places a legend table with those numbers as well
as the text information of their corresponding components on the right side of
the motherboard.
8 DIMMs 
ATX Power Supply 
2 LAN Ports 
Battery
BIOS
2 Chipsets 
6 SATA Connectors IDE Slot 
PS2 Port 
USB Port 
COM Port 
VGA Port 
4 CPUs 
6 Expansion Slots 
Figure 1: An example of many-to-one boundary labeling.
In comparison with Figure 2(a) (where text labels are of different sizes caus-
ing some of them to be too tiny to read), Figure 1 displays clearer and more
readable text labels on such a dense motherboard, though more space is re-
quired. If the motherboard is colored (as shown in Figure 1), then the area
labeling which places lots of redundant texts inside the motherboard tends to
cause unnecessary confusion in visualization. As for Figure 2(b), the legend
labeling can be viewed as an alternative to many-to-one boundary labeling. In
practice, choosing the right labeling scheme often depends on the application,
and an integrated solution might turn out to be better in some cases.
Conventionally, boundary labeling is identified as k-side labeling with type-t
leaders (where k ∈ {1, 2, 4} and t ∈ {opo, po, s}) if the labels are allowed to be
JGAA, 12(3) 319–356 (2008) 323
(a) Type-po leaders (b) Type-do leaders 
RR
l2
l3
l4
l5
l1 l1
l2
l3
l4
l5
Figure 4: Comparison between type-do and type-do leaders in one-to-one bound-
ary labeling.
As listed in Table 1, the main contributions of this paper include:
1. Crossing minimization problems for both one-side and two-side many-to-
one labeling with type-opo leaders are proved to be NP-complete (Sec-
tions 3 and 4). We also design approximation algorithms to cope with
such intractable problems.
2. Crossing minimization problems for one-side and two-side many-to-one
labeling with type-po leaders are proved to be NP-complete (Sections 5
and 6). Heuristic algorithms with satisfactory experimental results are
also given for these problems.
3. In Section 7, we discuss the many-to-one labeling with the objective of
minimizing the total leader length to be solvable in polynomial time, along
a similar line of the work of [1].
Table 1: The main contributions of this paper.
number leader time solution
objective of sides type complexity
Minimize the crossing number one opo NPC approximation
Minimize the crossing number two opo NPC approximation
Minimize the crossing number one po NPC heuristic
Minimize the crossing number two po NPC heuristic
Minimize total leader length any opo, po P following [1, 4]
A wide variety of variants of one-to-one boundary labeling have been pro-
posed and studied from an algorithmic viewpoint in the literature. Table 2
summarizes those that are related to our work. By comparing Table 1 with
Table 2, it is interesting to note that in the one-to-one case, minimizing the to-
tal leader length while respecting the no-crossing constraint is always tractable,
whereas in the many-to-one case, minimizing the crossing number becomes in-
tractable. Also note that the total leader length minimization problem remains
solvable in polynomial time even in the many-to-one case.
JGAA, 12(3) 319–356 (2008) 325
function, the slight abuse of notation is simply for convenience of understanding.
For simplicity, we assume that there are no two sites with the same x- or y-
coordinates, and the locations of ports of each label are predefined (see label l3
with three ports in Figure 3 (a)). Note that if part of a leader is overlapped
with a certain other leader in a boundary labeling, then the overlapping can
be removed by slightly adjusting the location of port of one of the two leaders.
Therefore, it is reasonable to assume that leaders never overlap. In addition,
the leader connecting site u to label l is denoted by ul.
A boundary labeling of a map M is a sequence of labels (l11, ..., l
n1
1 , l
1
2, ...,
ln22 , l
1
3, ..., l
n3
3 , l
1
4, ..., l
n4
4 ) such that ∀1 ≤ i ≤ 4, 0 ≤ j ≤ ni, l
j
i ∈ L. W.l.o.g., we
assume that all the labels are different. Intuitively speaking, l1i , ..., l
ni
i is the
sequence of labels along the i-th side. W.l.o.g., for i = 1 and 2 (i.e., East and
West sides, resp.) a top-down ordering is assumed; for i = 3 and 4 (i.e., South
and North sides, resp.) a left-to-right ordering is assumed. Figure 5 illustrates
a 4-side type-s boundary labeling. For simplicity, we assume labels (drawn as
rectangles) along the same side to be of uniform and maximum size; hence, the
ordering of labels along each side is sufficient to determine the exact positions
of labels. As f is a many-one function in general, there might be several sites
connecting to the same label. For example, three sites are connected to label l3
in Figures 3(a) and 3(b). It is easy to observe from that to minimize the number
of crossings (or the total leader length) in the case of type-opo leaders show in
Figure 3(a) (resp., type-po leaders show in Figure 3(b)), the ordering of ports
at which the three leaders touch label l3 (drawn as a rectangle) must respect
the ordering (in increasing order) of the y-coordinates (resp., x-coordinates) of
the three sites connected to label l3. The crossing number is the number of
crossings among leaders in a drawing.
R l4
l2
l5
l8
l10
l1
l3 l7 l12
l11 l6
l9
n1n2
n4
n3
Figure 5: A four-side many-to-one labeling with type-s leaders.
One of the optimization problems considered in this paper is as follows:
JGAA, 12(3) 319–356 (2008) 327
3 The Crossing Problem for One-Side Many-to-
One Labeling with Type-opo Leaders
In this section, we show that the crossing problem for one-side many-to-one
labeling with type-opo leaders (CP1ML-opo) is NP-complete (Subsection 3.1).
We also give an approximation algorithm guaranteed to yield a solution which
is less than or equal to three times the optimal solution (Subsection 3.2). Note
that in the restricted case in which each label is associated with at most two
sides, an analysis used in [16] can be applied to showing the algorithm presented
in Subsection 3.2 to be optimal.
3.1 CP1ML-opo is NP-complete
Consider the case where all the labels are placed on the East side of rectangle R
which encloses all the sites in the given map. Recall that we assume that there
are no two sites with the same x- or y- coordinates. In addition, since every
leader goes from a site through the right borderline of rectangle R orthogonally,
there is no crossing between leaders inside rectangleR. We can arbitrarily adjust
the x-coordinate of the bend of every type-opo leader in the track routing area
(see Figure 3 (a)) so that two leaders cross only when the y-coordinate order
of their corresponding sites is different from that of their corresponding labels.
That is, the crossing number is affected only by the y-coordinate orders of sites
and labels, not by their x-coordinate orders. As a result, if every type-opo
leader is replaced by a straight line segment and all the sites are on a vertical
line, then the problem under consideration is similar to the DCP except our
problem allows more than one site to be connected to a common label. In what
follows, we show the concerned problem to be NP-complete. In the case where
every leader is replaced by a straight line segment and every site is placed on a
vertical line, the decision version of the problem can be captured by the decision
many-to-one crossing problem (DMCP) as follows:
The Decision Many-to-One Crossing Problem (DMCP)
Instance: A two-layered networkG = (L0, L1, E) where the mapping from nodes
in L0 to nodes in L1 is a many-to-one function, an ordering y0 of L0, an integer
M .
Question: Is there an ordering y1 of L1, so that cross(G, y0, y1) ≤M?
Theorem 1 DMCP is NP-complete.
Proof: It is clear that DMCP is in NP because we can guess an ordering of L1
and then check if the crossing number is no more than M in polynomial time.
It remains to show the NP-hardness, which is established by a reduction
from DCP as follows.
DCP differs from DMCP only in the restriction that each node in L0 is
connected only by an edge. From a DCP instance G = (L0, L1, E), M (note
thatM refers to both a part of the instance of DCP and the number of crossings
JGAA, 12(3) 319–356 (2008) 329
of DCP), we construct a DMCP instance G′ = (L′0, L
′
1, E
′), M ′ as follows. Let
L′1 = L1. We denote the node with the i-th maximal y-coordinate in L0 by pi,
and {l1i , l
2
i , ..., l
k
i } is the set of the nodes in L1 to which pi is connected, i.e., there
are k edges connecting pi to k nodes in L1. For each node pi in L0, we create a
set of 2k nodes, say Pi = {p
1
i , p
2
i , ..., p
2k
i }, in L
′
0, where p
j
i has the j-th maximal
y-coordinate among all. Then for j = 1 to k, we connect pji and p
2k−j+1
i to l
j
i .
That is, we connect p1i and p
2k
i to l
1
i , p
2
i and p
2k−1
i to l
2
i , ... , and p
k
i and p
k+1
i
to lki . An example is illustrated in Figure 6.
We denote the cardinality of Pi by |Pi| and the number of the nodes in L0
by |L0|. Let M
′ be
|L0|∑
i=1
2
(
|Pi|/2
2
)
+ 4M
We show that there exists an ordering y′1 of L
′
1 such that cross(G
′, y′0, y
′
1) ≤M
′
if and only if there exists an ordering y1 of L1 such that cross(G, y0, y1) ≤M .
The crossings in G′ can be divided into the following two categories: the
edge incident to a node in Pi crosses the edge incident to a node 1) in the
same Pi or 2) in Pj for i 6= j. For the first category of crossings, as shown in
Figure 7, for i = 1, ..., |L0|, for any two pairs of nodes in Pi, (p
s
i , p
2|pi|−s+1
i ) and
(pti, p
2|pi|−t+1
i ), s 6= t, there are two crossings regardless of the order of qs and qt,
and hence there are 2
(
|Pi|/2
2
)
crossings for all permutations of selecting 2 from
{p1i , p
2
i , ..., p
|Pi|
i }. So the crossing number for the first category is
∑|L0|
i=1 2
(
|Pi|/2
2
)
.
For the second category of crossings, as shown in Figure 8, the edge piqt
crosses the edge pjqs in G if and only if there are the four crossings shown in
the right of Figure 8 in G′, regardless of the order of qs and qt. Therefore, there
are 4M crossings for the second category in G′ if and only if G hasM crossings.
2
Based on the above, we have the following corollary.
Corollary 1 CP1ML-opo is NP-complete.
Proof: (Sketch) To yield the lower bound, it suffices to show a reduction from
DMCP to CP1ML-opo.
Consider an instance of DMCP, i.e., a two-layered network G = (L0, L1, E),
ordering y0 of L0. With those information, Algorithm 1 constructs a one-side
type-opo map M.
In what follows, we discuss all the possible cases of whether any two leaders,
say palb and pcld, cross inM. W.l.o.g., we assume that the y-coordinate of pa is
greater than that of pc; leaders palb and pcld are not straight-line segments (i.e.,
there are bends on palb and pcld). Note that, in a boundary labeling for type-opo
leaders, we only need to consider the crossings of leaders in track routing area
because all the type-opo leaders go from a site through the right borderline of
rectangle R orthogonally so that there are no crossings inside rectangle R. We
discuss the following two cases: the bends of type-opo leaders palb and pcld are
drawn in 1) the same category; 2) different categories. In the first case, w.l.o.g.,
JGAA, 12(3) 319–356 (2008) 331
we assume the bends of type-opo leaders palb and pcld to be drawn in region
T1. Since from Step 5 of Algorithm 1 the x-coordinate increasing order of the
bends of leaders palb and pcld respects the y-coordinate increasing order of sites
pa and pc, hence, the two leaders must be drawn as Figure 10(a1) or 10(a2).
In the second case, w.l.o.g., we assume the bends of leaders palb and pcld to be
drawn in regions T1 and T2, respectively. By Step 5 of Algorithm 1, the two
leaders must be drawn as Figure 10(b1), 10(b2), or 10(b3). We observe from
Figure 10 that there is one crossing between leaders palb and pcld if and only if
the y-coordinate increasing order of sites pa and pc differs from that of labels lb
and ld. Note that by Algorithm 1 there is at most one crossing between leaders
palb and pcld.
(a2)(a1)
pa
lb
pc
ld
T2 T1
pa
lb
pc
ld
T2 T1
(b2)(b1) (b3) 
pa
lb
pc
ld
T2 T1
pa
lb
pc
ld
T2 T1
pa
lb
pc
ld
T2 T1
Figure 10: (a) All the possible cases where bends of two leaders are drawn in
region T1. (b) All the possible cases where the bend of leader palb (resp., pcld)
is drawn in region T1 (resp., T2).
In light of the above, two edges (leaders) palb and pcld in G (in M) cross if
and only if the y-coordinate increasing order of nodes (sites) pa and pc differs
from that of nodes (labels) lb and ld. Hence, we obtain that two edges palb and
pcld in G cross if and only if there is one crossing between two leaders in M. 2
3.2 An approximation algorithm
Our approximation algorithm is similar to the so-called median algorithm pro-
posed by Eades and Wormald in [8]. The idea of the median algorithm is to
place the labels in “median order”. For convenience and simplicity, we view
the labeling problem as finding an ordering y1 of L1 in a two-layered network
G = (L0, L1, E) such that the crossing number is as small as possible. Define
Nu of u ∈ L1 as the nodes {v1, v2, ..., vj} ∈ L0 incident to u. The median or-
der is, for each node u ∈ L1, to choose the median of the y-coordinates of the
neighbors of u as the y-coordinate of u. Precisely, if Nu = {v1, v2, ..., vj} with
y0(v1) < y0(v2) < y0(v3) < ... < y0(vj), then define med(u) = y0(v⌊j/2⌋). The
median algorithm sets y1(u) = med(u) for each node u ∈ L1, and separates the
two nodes with the same median by an infinitesimal amount.
The crossing number in the output of the median algorithm is denoted by
med(G, y0), while the crossing number in the output of the optimal labeling is
denoted by opt(G, y0).
JGAA, 12(3) 319–356 (2008) 333
a =
du + 1
2
, d =
du − 1
2
, b =
dv + 1
2
, c =
dv − 1
2
⇒ cuv ≤ ac+ bd+ cd
=
du + 1
2
×
dv − 1
2
+
dv + 1
2
×
du − 1
2
+
dv − 1
2
×
du − 1
2
≤
3
4
(du + 1)(dv + 1),
cvu ≥ ab =
du + 1
2
×
dv + 1
2
=
1
4
(du + 1)(dv + 1)
⇒ cuv ≤ 3cvu
Therefore,
med(G, y0) =
∑
med(u)≤med(v);y1(u)<y1(v)
cuv
≤
∑
u,v∈L1
3min{cvu, cuv} (Since cuv ≤ 3cvu and cuv ≤ 3cuv)
≤ 3
∑
u,v∈L1
min{cvu, cuv} ≤ 3opt(G, y0)
2
It should be noticed that finding improved approximation algorithms for the
CP1ML-opo problem remains an interesting open question.
An experimental result using the approximation algorithm described earlier
is given in Figure 12, which illustrates the distribution of some wildlife animals
in Taiwan, where leaders are drawn by Algorithm 1. Intuitively many-to-one
boundary labeling is more suitable for static maps, for which the leaders allow
the user to easily trace the corresponding label of each site. When the number
of labels gets larger, such an advantage becomes more obvious.
4 The Crossing Problem for Two-Side Many-to-
One Labeling with Type-opo Leaders
From our previous result that the crossing problem is NP-complete for CP1ML-
opo, the intractability result clearly holds for CP2ML-opo as well. (CP1ML-opo
is a special case of CP2ML-opo with n2 = 0.) In this section, we consider
CP2ML-opo under the restriction that n1 = n2 (i.e., the East and West sides
contain the same number of labels). The reason why such a restriction makes
sense is given as follows. Recall that we assume labels along the same side to be
of equal size. If n1 = n2 (e.g., see Figure 13(a)), then labels on both sides are
of equal size, which may give us a high degree of balance in visibility because
labels on two sides can be viewed as a reflectional symmetry along a vertical
axis, regardless of leaders and sites. On the other hand, if there is a significant
JGAA, 12(3) 319–356 (2008) 335
difference in the number of labels on the two sides, then the texts inside the
labels along the denser side may not be readable as Figure 13(b) shows.
R
(a) n1 = n2 = 5 (b) n1 z n2 (n1 = 8, n2 =2) 
l6
l7
l8
l9
l10
l8
l9
R
l1
l2
l3
l4
l5
l2
l3
l10
l4
l1
l5
l7
l6
Figure 13: Two boundary labeling layouts with type-opo leaders for the same
map.
Note that if the number of labels is not even, we can just add a dummy label
to make the number even. In this section, we first show the concerned crossing
problem to be NP-complete, and then provide an approximation algorithm for
the intractable problem.
4.1 CP2ML-opo is NP-complete even when n1 = n2
Since the labeling in this section applies type-opo leaders (which is the same
as the previous section), hence the crossing number is influenced only by the
differences between the y-coordinate orderings of sites and either the labels in
the right side or the labels in the left side, respectively. Therefore, the problem
can be modeled as an analogy of three-layered network, of which definition is
given as follows. A three-layered network G = (L0, LL, LR, E) consists of three
disjoint sets L0, LL, and LR of nodes and a set E ⊆ L0 × LL ∪ L0 × LR of
edges. Assume that the nodes in L0, LL, and LR appear in the vertical lines
x = 0, x = −1, and x = 1, respectively. Similar to the definition of two-layered
network, y0, yL, yR can be defined. Notice that the crossing number in a three-
layered network is influenced by altering the orderings yL and yR or swapping
the nodes in LR with those in LL. In what follows, we show the concerned
labeling problem to be NP-complete. The decision version of the problem can
be stated as follows:
The Decision Three-Layered Many-to-One Crossing Problem with
|LL| = |LR| (D3MCP)
Instance: A three-layered network G = (L0, LL, LR, E) with |LL| = |LR| where
the mapping from the nodes in L0 to the nodes in LR ∪ LL is a many-to-one
function, an ordering y0 of L0, an integer M .
Question: Can we find the orderings yL of LL and yR of LR and swap some
nodes in LR with those in LL, so that the crossing number is no more than M?
Theorem 3 D3MCP is NP-complete.
Proof: It is clear that D3MCP is in NP; to prove its NP-hardness, the reduction
from the DMCP (mentioned in Theorem 1) is established as follows. Starting
JGAA, 12(3) 319–356 (2008) 337
In what follows, we prove that G(L0, L1, E) has at most M crossings if and
only if G′(L′0, L
′
L, L
′
R, E
′) has at most M crossings.
Suppose that G has at most M crossings. From the above construction of
G′ (see also Figure 14), we observe that crossings in G′ only occur on the right-
hand side (i.e., between L′0 and L
′
R), so the crossing number of G
′ is equivalent
to that of G. That is, the crossing number of G′ is also at most M .
Conversely, suppose that G′ has at most M crossings. If M >
(
n
2
)
, then the
crossing number of G with arbitrary ordering y0 must be less than M , because
it must be no more than
(
n
2
)
.
If M ≤
(
n
2
)
, it implies that in G′ the edges incident to a type-l node cannot
cross those incident to any other type-l node as well as those incident to a type-r
node; otherwise, it leads to at least
(
N
2
)
+1 ≥
(
n
2
)
+1 crossings – impossible. Note
that in the converse direction each type-l node in G′ may be placed in either
L′L or L
′
R. No matter how the type-l nodes in G
′ are placed, the y-coordinate
ordering of the nodes in {l1, l2, ..., ln} cannot be modified; otherwise, w.l.o.g.,
assuming that the y-coordinate of li is less than that of lj for i < j, there are at
least
(
N
2
)
+1 crossings between the edges incident to li and either those incident
to lj (if li and lj are placed on the same side) or those incident to rj (if li and lj
are placed on different sides) – impossible. Therefore, w.l.o.g., we assume that
the nodes consecutively appear from the topmost to the bottommost in L′R and
L′L, respectively, are
l1, l2, ..., li1 , r[i1+1], r[i1+2], ..., r[i2], li2+1, li2+2, ..., li3 , ..., ri[2k] , ..., li2k+1 , ...
and
r[1], r[2], ..., r[i1], li1+1, li1+2, ..., li2 , r[i2+1], r[i2+2], ..., r[i3], ..., li2k , ..., ri[2k+1] , ...,
where r[1], r[2], ..., r[n] is a permutation of {r1, r2, ..., rn} (in which r[i] is the i-
th node of the permutation) so that li and r[i] have the same y-coordinate on
different sides in G′, for every i ∈ {1, ..., n}. Define Rj = {r[ij−1+1], r[ij−1+2],
..., r[ij−1], r[ij ]}. Note that the edges incident to every type-r node in Rj
only cross those incident to the other type-r nodes in Rj ; otherwise, at least(
N
2
)
+ 1 crossings are generated – impossible. As a result, we can swap all the
type-l nodes in L′R with their same y-coordinate type-r nodes in L
′
L, without
producing new crossings. Now we obtain a new three-layered network where
all the type-l nodes are placed in L′L, and it has the same crossing number as
the original three-layered network G′. That is, the crossing number of the new
three-layered network is at most M . After deleting all the type-l nodes of the
new three-layered network and their adjacent edges, a two-layered network with
at most M edge crossings can be obtained.
2
Similar to Algorithm 1, we can draw the bends of leaders in the two track
routing areas on two sides so that two edges in G cross if and only if there is
one crossing between two leaders (corresponding to the two edges in G) in M.
As a result, we have the following corollary.
Corollary 2 CP2ML-opo is NP-complete even when n1 = n2.
JGAA, 12(3) 319–356 (2008) 339
Algorithm 2 Approx-CP2ML-opo
1: Consider a boundary labeling where all the n labels {l1, l2, ..., ln} are placed
in the median order on the East side of R, and the leaders are drawn by
Algorithm 1.
2: Construct a complete weighted graph G = (V,E) where each node i in V
corresponds to a label li; the weight wi,j of edge (i, j) equals the number
of crossings of the leaders connected to li and lj in the boundary labeling
constructed in Step 1.
3: Check if w(S) =
∑
i,j∈S wi,j +
∑
i,j∈V \S wi,j is zero as follows. Let G
′ = G.
Delete the edges with wi,j = 0 in G
′. Check if G′ can be partitioned into
some bipartite graphs (where the number of these bipartite graphs is denoted
by m, m ≥ 1). If not (i.e., w(S) 6= 0), then do Step 4; otherwise, call
Procedure 3 to check if the m bipartite graphs can be combined into a new
bipartite graph consisting of two disjoint sets with equal cardinality n/2. If
Procedure 3 returns false (i.e., w(S) 6= 0), then do Step 4; otherwise (i.e.,
w(S) = 0), denote the two disjoint node sets of the combined bipartite graph
by S and V \ S, and then do Step 5.
4: Using G as the input, run the 1.431-approximation algorithm of the Max-
Bisection Problem to partition V into two sets S and V \ S.
5: Output a labeling where the labels corresponding to nodes in S (resp., V \S)
are placed in the median orders of their adjacent sites on the East (resp.,
West) side; the leaders are drawn by Algorithm 1.
Procedure 3 Combine Bipartite(G′)
Input: an n-node graph G′ consisting of m bipartite graphs.
Output: return true if the m bipartite graphs can be combined into a new
bipartite graph consisting of two disjoint sets with equal cardinality n/2; else
return false.
1: We construct an n × n × m table T . Every entry in table T is initially
assigned to zero. Note that each entry only can be 0 or 1.
2: We give the m bipartite graphs in G′ an arbitrary ordering. For j ∈
{1, · · · ,m}, let the j-th bipartite graph be denoted by Aj × Bj (i.e., Aj
and Bj are the two disjoint sets of the j-th bipartite graph) and the number
of nodes in Aj (resp., Bj) be denoted by n
j
A (resp, n
j
B). Initially, in table T ,
both entries T (n1A, n
1
B, 1) and T (n
1
B, n
1
A, 1) are assigned to 1.
3: For j = 2, 3, ...,m, entry T (p, q, j) = max{T (p − njA, q − n
j
B, j − 1), T (p −
njB, q − n
j
A, j − 1)} for any p, q ∈ {1, 2, ...n}. That is, T (p, q, j) = 1 iff the
first to the j-th bipartite graphs can be combined into a new bipartite graph
of two disjoint sets with sizes p and q, respectively.
4: If entry T (n/2, n/2,m) is 1, then return true; otherwise, return false.
JGAA, 12(3) 319–356 (2008) 341
2. In the case where
∑
i,j∈V ;wi,j>0
1 > (n2 )
2, MSOPT only can cut at most
(n2 )
2 edges, so
MSOPT ≤
n2/4∑
k=1
wk
=⇒
∑
i,j∈V wi,j
MSOPT
≥
∑
i,j∈V wi,j∑n2/4
k=1 wk
= c
Obviously, c > 1. Denote the output of Step 4 of Algorithm 2 by cAPX , and
the minimal crossing number by cOPT . Then
cAPX
cOPT
≤
∑
i,j∈V wi,j −
MSOP T
1.431∑
i,j∈V wi,j −MSOPT
= 1+
0.301∑
i,j∈V wi,j
MSOP T
− 1
≤ 1 +
0.301
c− 1
Recall that we place all the labels in the median order on the East side in
Step 1 of Algorithm 2. Since the median algorithm is a 3-approximation algo-
rithm for one-side many-to-one labeling with opo-leaders, we get a 3(1+ 0.301c−1 )-
approximation algorithm. 2
It should be noticed that finding improved approximation algorithms for the
CP2ML-opo problem remains an interesting open question.
With respect to the Taiwan map with the same sites and labels as in Fig-
ure 12, we consider the CP2ML-opo in the case where n1 = n2, i.e., we require
that the numbers of labels on both sides are the same. The experimental result
of Algorithm 2 is given in Figure 15, which gives us a higher degree of balance
in visibility in comparison with Figure 12.
5 The Crossing Problem for One-Side Many-to-
One Labeling with Type-po Leaders
In this section, we investigate the crossing problem for one-side many-to-one
labeling with type-po leaders (CP1ML-po).
5.1 CP1ML-po is NP-complete
Different from Section 3, the x-coordinate ordering of sites plays an important
role in the problem discussed in this section, and hence the problem cannot be
represented as a two-layered network. The decision version of this problem is
stated as follows:
JGAA, 12(3) 319–356 (2008) 343
l2
ln
l1
Figure 16: A special case of DCP1ML-po where the y-coordinate of any site is
smaller than that of the lowest port of the lowest label. Note that some of the
edges are not shown in the figure.
port positions also can be decided such that the crossing number is the smallest).
Recall that in DMCP, two edges cross only when the y-coordinate increasing or-
der of any two nodes in L0 is different from the y-coordinate increasing order of
their corresponding nodes in L1. Obviously, the special case of DCP1ML-po and
DMCP are equivalent as counting the crossing number. Therefore, DCP1ML-po
is NP-hard. 2
5.2 A heuristic
We give a polynomial time heuristic for the labeling problem CP1ML-po. Con-
sider a one-side type-po map M = (P,L, n, 0, 0, 0, f), where L = {l1, l2, ..., ln}
and f−1(li) is the set of the sites connected to the common label li. Our
greedy-based heuristic is described in Algorithm 4. As we are concerned about
the reduction of crossings of type-po leaders and the placements of labels on the
East side of R, it is more natural to start the algorithm from the x-coordinates
of sites rahter than from the y-coordinates of sites. Therefore, Steps 1 and 2
preprocess the coordinates of all the sites, and record the leftmost site of those
connected to each label.
Recall that we assume the labels along the same side to be of uniform and
maximum size; the sizes and possible positions of the n labels on the East side
are known. We can image that there are n possible label positions on the East
side of the map to which we allocate the n labels, and the y-coordinate ordering
of the n labels is sufficient to determine the exact positions of the n labels.
The idea behind our algorithm is that ideally the type-po leader between
the leftmost site and the topmost or bottommost label leads to fewer crossings
with the leaders connected to other labels. Thus, each iteration of Step 3 places
the label with the leftmost unconnected sites at the topmost or bottommost
unallocated label position on the East side according to whichever situation
leads to fewer crossings, while the leaders are drawn by Procedure 5. Note that
the leaders connected to a common label do not cross if they are drawn by
Procedure 5.
In order to better understand the algorithm, some immediate steps of Algo-
rithm 4 for an example are given in Figure 17. In the leftmost map of Figure 17,
Step 2 records the leftmost site in f−1(l′i) as p
1
i
′
for i = 1 to 4; Step 3(a) con-
JGAA, 12(3) 319–356 (2008) 345
nects the sites in f−1(l′1) to the bottommost label position on the East side of
the map. Subsequently, if the sites in f−1(l′2) are connected to the topmost la-
bel position (resp., the second label position to the bottom) and their adjacent
leaders are drawn by Procedure 5, then they induce no (resp., one) crossing.
Therefore, as shown in the second map of Figure 17, label l′2 is placed at the
topmost label position, and their adjacent leaders are drawn by Procedure 5.
Similarly, labels l′3 and l
′
4 are placed, and their adjacent leaders are drawn, as
shown in the rightmost map of Figure 17.
Step 2 & Step 3(a). Step 3(b)-i. Step 3(b)-ii. Step 3(b)-iii.
1'
1p
1'
2p
1'
3p
1'
4p
1'
1p
1'
2p
1'
3p
1'
4p
1'
1p
1'
2p
1'
3p
1'
4p
1'
1p
1'
2p
1'
3p
1'
4p
'
1l '1l
'
3l
'
4l
'
2l
'
1l
'
3l
'
2l
'
1l
'
2l
Figure 17: An example of executing Algorithm 4, where the sites connected to
a common label are represented by the same icon.
In order to understand how to use Procedure 5 to draw the type-po leaders
between the sites and the ports with fixed positions, we give an example shown
in Figure 18. In the first iteration of Step 2 of Procedure 5, y(a1) ≥ y(b1) and
y(a2) ≥ y(b1), but we have x(a1) > x(a2), so that we connect a1 to b1 (Step 2(a)
of Procedure 5). By using the same discussion, the leaders of b2 – b5 are drawn.
Subsequently, while b6 is concerned, since there is no unconnected site ai for
any i so that y(ai) ≥ y(b6), we connect to port b6 the leftmost unconnected site
a6 (Step 2(b) of Procedure 5). As for b7, y(a7) ≥ y(b7) and y(a8) ≥ y(b7), but
we have x(a7) > x(a8), so that we connect a7 to b7. Similarly, the leaders of b8
and b9 can be drawn.
li
b9
b8
b7
b6
b5
b4
b3
b2
b1
a9
a8 a7
a6
a5
a4
a3
a2 a1
Figure 18: An example of illustrating the type-po leaders drawn by Procedure 5.
One can easily verify the correctness of Procedure 5 by considering the fol-
JGAA, 12(3) 319–356 (2008) 347
Number of labels: 8
0
200
400
600
800
1000
1200
1400
23 26 28 28 36 40 44 45 53 53 54 55 57 60 90
number of sites
number of
crossings
optimal
ALG
Number of labels: 9
0
200
400
600
800
1000
26 31 33 33 37 49 55 56 58 60 61 63 64 65 83
number of sites
number of
crossings
optimal
ALG
Number of labels: 10
0
200
400
600
800
1000
1200
1400
1600
1800
29 34 36 38 47 54 56 59 66 68 69 73 73 74 108
number of sites
number of
crossings
optimal
ALG
our
our
our
Figure 19: The experimental results for DCP1ML-po.
JGAA, 12(3) 319–356 (2008) 349
l2
l1
2n
l 2 1nl
2 2nl
2 1n nl
Figure 20: A special case of DCP2ML-po where the y-coordinate of any site is
smaller than that of the lowest port among the ports of all labels. Note that
some of the edges are not shown in the figure.
l4
l3
l2
l5
l6
l7
l1 l8
l4
l3
l2
l5
l6
l7
l1 l8
l4
l3
l2
l5
l6
l7
l1 l8
(a) (b) (c) 
Figure 21: A crossing is produced when the x-coordinate increasing order of
two sites does not respect the circular ordering of their corresponding labels, in
the case where the two sites are connected to (a) the West side, (b) different
sides, and (c) the East side.
In this case, we observe that two leaders cross only when the x-coordinate
increasing order of any two sites is different from the circular ordering of their
corresponding labels, as shown in Figure 21. Recall that in DMCP, two edges
cross only when the y-coordinate increasing order of any two nodes in L0 is
different from that of their corresponding nodes in L1. Obviously, the special
case of DCP2ML-po and DMCP are equivalent as counting the crossing number.
Therefore, DCP2ML-po is NP-hard even when n1 = n2. 2
6.2 A heuristic
In this subsection, we devise a polynomial time heuristic for the labeling problem
CP2ML-po. Our heuristic needs the algorithm for solving the Min-Bisection
Problem for directed graphs, which is not approximable [10]. To our knowledge,
so far there has not been any heuristic for solving the Min-Bisection Problem
for directed graphs. Our heuristic is based on the K-L heuristic [15], which
was designed for solving the Min-Bisection Problem for undirected graphs in
practice. Consider a two-side type-po map M = (P,L, n1, n2, 0, 0, f), where
L = {l1, l2, ..., ln} and f
−1(li) is the set of the sites connected to the common
label li. Our heuristic is described in Algorithm 6. In order to better understand
how Algorithm 6 works, see also an example shown in Figure 22.
JGAA, 12(3) 319–356 (2008) 351
As for the time complexity of Algorithm 6, Step 1 can be implemented in
time O(N2) in the following way. Initially, an N × N table is used to record
all the wi,j values. We iterate each site pa, of which label is called li, so the
total number of iterations is N . In each iteration, we consider each of the
sites rather than pa, which is denoted by pb and its corresponding label is
called lj. If x(pa) > x(pb), then w(i, j) := w(i, j) + 1. If x(pb) > x(pa), then
w(j, i) := w(j, i) + 1. Therefore, Step 1 can establish the weighted directed
graph in time O(N2).
In addition, Step 2 runs in time O(N2 logN) [15], and Step 3 (Algorithm 4)
runs in time O(N2). As a result, Algorithm 6 runs in time O(N2 logN).
In what follows, we implement the algorithm and give some experimental
results to compare the minimal crossing number and the output of Algorithm 6.
The experimental setting is the same as that used in Subsection 5.2. The ex-
perimental results of two problem sets are given in Figure 23, where the top
(resp., bottom) bar chart shows the minimal crossing numbers and the crossing
numbers of the outputs of our algorithm for the problems with fixed ten (resp.,
eleven) labels and random numbers of sites. In view of the figure, our algorithm
outputs a layout of good quality.
7 Discussions and Conclusions
In this section, we discuss the problem with the objective of minimizing the total
leader length in Subsection 7.1, as well as the problems for type-s leaders in
Subsection 7.2. Some conclusions with future work are given in Subsection 7.3.
7.1 The leader length problem
In our earlier discussion, we have investigated the many-to-one boundary label-
ing with the objective of minimizing the crossing number, regardless of the total
leader length. An alternative objective might be to minimize the total leader
length, regardless of the total crossing number. The concerned problem can be
stated as follows:
The Leader Length Problem for Many-to-One Labeling (LLPML):
Given a k-side type-t map M = (P,L, n1, n2, n3, n4, f), where t ∈ {po, opo},
find a boundary labeling for M such that the total leader length is as small as
possible, regardless of the total crossing number.
In what follows, we show LLPML to be solvable in polynomial time using
an approach originally used in [1]. The algorithm works regardless of the leader
type (opo or po) and the boundary type (one-side, two-side, or four-side).
As crossings among leaders are allowed, leaders can be routed arbitrarily.
Consider a representative label li for some i ∈ {1, · · · , n}. It is easy to see that
if the position of labels li is determined, then routing the leaders connected
to labels li never affects the length of any other leader. It implies that in the
LLPML solution the sum of lengths of the leaders connected to label li must be
JGAA, 12(3) 319–356 (2008) 353
boundary labeling (where each port of label li is viewed a label in the one-to-
one boundary labeling), and hence can be solved in time O(Ni logNi) (resp.,
O(N2i )) [4]. Note that the leaders connected to label li never cross one another
when the sum of their lengths is the minimal [4].
Subsequently, we consider how to determine the position of each label. Since
the number of labels placed on each side is given, the sizes of labels on each side
are known (fixed). Hence, there are n possible fixed label positions around the
map, in which each position just accommodates one of the n labels. In order
to allocate the n labels to the n possible label positions around the map, we
construct a weighted bipartite graph A×B in which
• each node ai, i ∈ {1, · · · , n}, in A represents label li;
• each node bi, i ∈ {1, · · · , n}, in B represents a possible label position
around the map;
• for any i, j ∈ {1, · · · , n}, the weight of edge aibj is the sum of lengths
of the leaders connected to li in the case where label li is placed at the
position represented by bj .
In the case of type-opo (resp., type-po) leaders, the weighted bipartite graph
can be constructed in time O(nN logN) (resp., O(nN2)). In what follows,
we explain the case of type-opo leaders; the other case is similar. Recall that
the sum of lengths of the leaders connected to label li can be computed in
time O(Ni logNi). Since label li has n possible label positions, the weights
of the n edges in A × B connected to node ai in A can be computed in time
O(nNi logNi). Hence, the weights of all the edges in A×B can be computed in
time O(n×(N1 logN1+· · ·+Nn logNn)) ≤ O(n×(N1 logN+· · ·+Nn logN)) =
O(n× (N1 + · · ·+Nn) logN) = O(nN logN).
Finally, like the work in [1], the LLPML solution can be obtained by find-
ing the minimum weighted matching in A × B, which can be solved in time
O(n2 log3 n) [18]. As a consequence, LLPML can be solved in polynomial time.
It is interesting to compare and contrast the results for LLPML under type-
po leaders with those listed in Table 2, which deals with one-to-one boundary
labeling. LLPML for all cases are tractable; however, only the one-side and
two-side one-to-one boundary labeling problems (i.e., excluding the four-side
one) are tractable. The disparity comes from the fact that unlike one-to-one
boundary labeling which requires crossing-free leaders, LLPML allows crossings
among leaders.
7.2 The problems for type-s leaders
About the problems for type-s leaders, one may guess that our NP-hardness
proofs of the problems for type-opo leaders (which are reduced from two- or
three- layered networks) might be used to show the intractable problems for
type-s leaders. However, it is impossible because in the case of type-s leaders
both the x- and y- coordinates of the sites matter, but in the case of type-opo
leaders only the y-coordinates of the sites matter.
JGAA, 12(3) 319–356 (2008) 355
References
[1] M. Bekos, M. Kaufmann, K. Potika, and A. Symvonis. Boundary labelling
of optimal total leader length. In Proceedings of the 10th Panhellenic Con-
ference on Informatics (PCI 2005), volume 3746 of LNCS, pages 80–89,
2005.
[2] M. Bekos, M. Kaufmann, K. Potika, and A. Symvonis. Polygons labelling
of minimum leader length. In Proceedings of Asia Pacific Symposium on
Information Visualisation 2006 (APVIS2006), volume 60 of CRPIT, pages
15–21, 2006.
[3] M. Bekos, M. Kaufmann, A. Symvonis, and A. Wolff. Boundary labeling:
models and efficient algorithms for rectangular maps. In Proceedings of the
12th International Symposium on Graph Drawing (GD 2004), volume 3383
of LNCS, pages 49–59, 2004.
[4] M. Bekos, M. Kaufmann, A. Symvonis, and A. Wolff. Boundary label-
ing: models and efficient algorithms for rectangular maps. Computational
Geometry: Theory and Applications, 36(3):215–236, 2006.
[5] M. Bekos and A. Symvonis. BLer: a boundary labeller for technical draw-
ings. In Proceedings of the 13th International Symposium on Graph Drawing
(GD 2005), volume 3843 of LNCS, pages 503–504, 2006.
[6] M. Benkert, H. Haverkort, M. Kroll, and M. No¨llenburg. Algorithms for
multi-criteria one-sided boundary labeling. In Proceedings of the 15th Inter-
national Symposium on Graph Drawing (GD 2007), volume 4875 of LNCS,
pages 243–254, 2008.
[7] B. Chazelle and 36 co-authors. The computational geometry impact task
force report. In B. Chazelle, J. E. Goodman, and R. Pollack, editors,
Advances in Discrete and Computational Geometry, volume 223, pages 407–
463. AMS, 1999.
[8] P. Eades and N. C. Wormald. Edge crossings in drawings of bipartite
graphs. Algorithmica, 11:379–403, 1994.
[9] U. Feige and R. Krauthgamer. A polylogarithmic approximation of the
minimum bisection. SIAM Review, 48(1):99–130, 2006.
[10] U. Feige and O. Yahalom. On the complexity of finding balanced oneway
cuts. Information Processing Letter, 87(1):1–5, 2003.
[11] M. Formann and F. Wagner. A packing problem with applications to let-
tering of maps. In Proceedings of the 7th Annual ACM Symposium on
Computational Geometry (SoCG 1991), pages 281–288. ACM Press, 1991.
[12] M. R. Garey and D. S. Johnson. Computers and Interactability. A Guide
to the Theory of NP-Completeness. A Series of Books in the Mathematical
Sciences. Freemann And Company, 1979.
Journal of Graph Algorithms and Applications
http://jgaa.info/ vol. 11, no. 2, pp. 431–452 (2007)
On Balloon Drawings of Rooted Trees
Chun-Cheng Lin1 Hsu-Chun Yen1,2,∗
1Department of Electrical Engineering
National Taiwan University, Taipei, Taiwan 106, ROC
sanlin@cobra.ee.ntu.edu.tw yen@cc.ee.ntu.edu.tw
2Department of Computer Science
Kainan University, Taoyuan, Taiwan 338, ROC
Abstract
Among various styles of tree drawing reported in the literature, bal-
loon drawing enjoys a desirable feature of displaying tree structures in a
rather balanced fashion. Each subtree in the balloon drawing of a tree is
enclosed in a circle. Along any path from the root node, the radius of each
circle reflects the number of descendants associated with the root node of
the subtree. In this paper, we investigate various issues related to balloon
drawings of rooted trees from the algorithmic viewpoint. First, we design
an efficient algorithm to optimize the angular resolution and the aspect
ratio for the balloon drawings of rooted unordered trees. For the case of
ordered trees for which the center of the enclosing circle of a subtree need
not coincide with the root of the subtree, flipping the drawing of a subtree
(along the axis from the parent to the root of the subtree) might change
both the aspect ratio and the angular resolution of the drawing. We show
that optimizing the angular resolution as well as the aspect ratio with
respect to this type of rooted ordered trees is reducible to the perfect
matching problem for bipartite graphs, which is solvable in polynomial
time. In addition, a related problem concerning the optimization of the
drawing area can be modelled as a specific type of nonlinear programming
for which there exist several robust algorithms in practice. With a slight
modification to the balloon drawing, we are able to generate the draw-
ings of galaxy systems, H-trees, and sparse graphs, which are of practical
interest.
Article Type Communicated by Submitted Revised
Regular paper P. Eades and P. Healy January 2006 January 2007
* Corresponding author. Research supported in part by NSC Grant 94-2213-E-002-
086, and Research Grant 95-EC-17-A-02-S1-049, Taiwan.
C. Lin and H. Yen, Balloon Drawings, JGAA, 11(2) 431–452 (2007) 433
(a) (b)
38o
43o
38o
60o
45o
45o
45o
45o
Figure 1: Illustration of balloon drawings with (a) even angles and (b) uneven
angles.
adjacent edges incident to the common node in straight-line drawing, whereas
the aspect ratio is defined as the ratio of the largest angle to the smallest angle
formed by two adjacent edges incident to the common node in straight-line
drawing. A tree layout with a small aspect ratio often enjoys a very balanced
view of a tree.
It is not hard to observe that with respect to a rooted unordered tree, chang-
ing the order in which the children of a node are listed affects the angular reso-
lution as well as the aspect ratio of the drawing. Hence an interesting question
arises: How to find an embedding of a rooted unordered tree such that the bal-
loon drawing of the tree has the maximum angular resolution and the minimum
aspect ratio? The first part of this paper is devoted to answering the above
question. We demonstrate an efficient algorithm which is guaranteed to yield
an optimal balloon drawing in terms of the (maximum) angular resolution and
the (minimum) aspect ratio. Here we assume the balloon drawing to be of the
even angle type.
Now consider the case when the balloon drawing is of the uneven angle
type. Allowing uneven angles introduces another dimension of flexibility as far
as optimizing the angular resolution and the aspect ratio is concerned. Even if
the embedding (ordering) of a tree is given, flipping the drawing of a subtree
along the axis going through the parent and the root of the subtree might change
the angular resolution as well as the aspect ratio of the drawing. Notice that
in the uneven angle case, the angles on the two sides of the axis might not be
equal. A related question is: How to flip uneven angles in the balloon drawing
of a rooted ordered tree to achieve optimality in angular resolution and aspect
ratio? Notice that in the above, the embedding of the underlying tree is fixed.
As it turns out, we are able to reduce the above problem to that of perfect
matching of bipartite graphs, which admits a polynomial time solution.
In fact, the balloon drawing of the uneven angle case is derived from a
process of minimizing the drawing area of balloon drawing of the even angle
case subject to preserving properties (P1)-(P3) of balloon drawing (this will be
illustrated in Section 4). There is, however, some work (e.g., [5, 8]) suggesting
C. Lin and H. Yen, Balloon Drawings, JGAA, 11(2) 431–452 (2007) 435
be the radius of the drawing circle centered at v. If we require that r(v) = r(w)
for two arbitrary nodes v and w that are of the same depth from the root of the
tree, as shown in Figure 3 (a), then such a drawing is called a balloon drawing
under the fractal model [7]. The fractal drawing of a tree structure means that
if lm and lm−1 are the lengths of edges at depths m and m − 1, respectively,
then lm = γ × lm−1 where γ is the predefined ratio (0 < γ < 1) associated with
the drawing under the fractal model. Clearly, edges at the same depth have the
same length in a fractal drawing.
Unlike the fractal model, the subtrees with nonuniform sizes (abbreviated
as SNS) model [3, 6] allows subtrees associated with the same parent to reside
in circles of different sizes, as shown in Figure 3 (b), and hence, the drawing
based on this model often results in a clearer display on large subtrees than that
under the fractal model. Given a rooted ordered tree T with n nodes, a balloon
drawing under the SNS model can be obtained in O(n) time in a bottom-up
fashion (see [3, 6]) with the edge length and the angle between two adjacent edges
according to r = C/(2pi) ∼= (2
∑
j Rj)/(2pi) and θj
∼= (Rj−1 + free arc+Rj)/r
(see Figure 2) respectively, where r is the radius of the inner circle centered at
node O, C is the circumference of the inner circle, Rj is the radius of the outer
circle enclosing all subtrees of the j-th child of O, and RO is the radius of the
outer circle enclosing all subtrees of O. Since there exists a gap between C and
the sum of all diameters, we can distribute to every θj the gap between them
evenly, denoted by free arc.
(a) (b)
free_arc
r
li
li-1
wedge ici
r
Rj
Rj-1
O
vparent
RO
free_arc
R1
Rj+1
Rmin
j
w’i
wi
O = c0
1
Figure 2: The SNS model. (a) Node O is not the root, and the edge between
O and its parent goes through a circle with radius Rmin; (b) is a star graph
centered at c0. Assume that node O has n children. When computing r and θj
in (a), one should notice that Rmin is viewed as Rn+1, and hence, (a) can be
viewed as (b) where node O has n+1 children. In general, it suffices to consider
the case of (b) when computing r and θj .
Note that the trees considered in [3, 6] are ordered. Since the fractal model
assumes that all the angles between neighboring edges emanating from a com-
C. Lin and H. Yen, Balloon Drawings, JGAA, 11(2) 431–452 (2007) 437
and
AspRatioσ = {
max1≤i≤n{
θσi+θσi⊕1
2 }
min1≤i≤n{
θσi+θσi⊕1
2 }
}
Let Σ be the set of all permutations of {1, ..., n}. In what follows, we shall
design an efficient algorithm to find a permutation that returns
optAngResl = maxσ∈Σ{AngReslσ}
and
optAspRatio = minσ∈Σ{AspRatioσ}
The optAngResl is said to involve angles θσi and θσi⊕1 if i is the value that
minimizes AngReslσ with respect to the optimal permutation σ. It should be
noticed that the permutation witnessing optAngResl or optAspRatio may not
be unique.
For notational convenience, we order the set of wedge angles θ1, ..., θn in
ascending order as either
m1,m2, ...,mk−1,mk,Mk,Mk−1, ...,M2,M1 (1)
if n is even, or
m1,m2, ...,mk−1,mk,mid,Mk,Mk−1, ...,M2,M1 (2)
if n is odd, for some k where mi (resp. Mi) is the i-th minimum (resp. maxi-
mum) among all, and mid is the unique median. We define αij =
Mi+mj
2 , 1 ≤
i, j ≤ k.
Recall from Figure 2 (a) that the drawing of the subtree rooted at a node O
is enclosed in a circle centered at O. By abstracting out the details of each of the
subtrees associated with the children of O, the balloon drawing of the subtree
at O can always be viewed as a balloon drawing of a star graph with children
of nonuniform size rooted at O, regardless of the depth at which O resides. In
addition, even if we alter the ordering of the children of O, the size of the outer
circle bounding all the children of O remains the same; hence, the optimization
of each of the subtrees at depth k does not affect the optimization of their
parent at depth k − 1. In view of the above, optimizing the angular resolution
as well as the aspect ratio of a balloon drawing of a rooted unordered tree can
be carried out in a bottom-up fashion. As a result, it suffices to investigate how
to optimize the angular resolution and the aspect ratio of balloon drawing with
respect to star graphs.
We give the drawing algorithm in Procedure 1 that achieves optimal angular
resolution and aspect ratio under the SNS balloon drawing model.
Theorem 1 Procedure 1 achieves optimality in angular resolution as well as in
aspect ratio for star graphs.
C. Lin and H. Yen, Balloon Drawings, JGAA, 11(2) 431–452 (2007) 439
Suppose δ is the permutation that witnesses optAngResl. From Property
(2), the minimum angular resolution of σ must be either αi,i−1, for some 2 ≤
i ≤ k, or (mid +mk)/2. In what follows, we only consider the case when the
minimum angular resolution of σ is αi,i−1 = (Mi +mi−1)/2; the other case can
be proved similarly.
Now if Mi is a neighbor of mi−1 in δ (i.e., the optimal permutation), then
δ and σ have the same angular resolution and optAngResl = αi,i−1. Because,
otherwise,
• if optAngResl < αi,i−1 (which is the angular resolution of σ), then this
contradicts that δ is the optimal.
• if optAngResl > αi,i−1, then this is impossible because δ has an angle of
size αi,i−1 = (Mi +mi−1)/2.
Hence, σ is optimal as well.
On the other hand, suppose x and y (x < y) are the two neighbors ofmi−1 in
δ and neither one is Mi, then both x and y must be greater than Mi; otherwise,
the angular resolution of δ is smaller than (Mi + mi−1)/2 – contradicting δ
being optimal. Also note that optAngResl ≥ (mi−1 + x)/2. Now if we look at
a partition of the set of wedge angles of S as follows:
m1 < ...︸ ︷︷ ︸ < mi−1 < ...︸︷︷︸ < Mi < ... < x < ... < y < ...M1︸ ︷︷ ︸ .
RA RB RC
RA contains i− 2 elements, which must be connected to at least i− 1 elements
of RC ; otherwise, the angular resolution in δ becomes less than (Mi +mi−1)/2
– a contradiction. RC originally contains i − 1 elements. However, x and y
are the two neighbors of mi−1, meaning that together with mi−1 they are tied
together and cannot be separated. So effectively only ‘i−2’ elements of RC can
fill the i − 1 neighbors of RA, which is not possible. We have a contradiction.
What the above shows is that for a permutation δ to be optimal, a neighbor
of mi−1 is Mi. Hence, the angular resolution of δ is ≤ (Mi +mi−1)/2. Since
δ witnesses optAngResl, optAngResl = (Mi + mi−1)/2, meaning that σ also
produces optAngResl.
The above implies that optAngResl must be either (mid+mk)/2 or αi(i−1)
for some i ∈ {2, ..., k}, which is always included in the circular permutation σ
produced by Procedure 1. Similarly, we can prove that the minimum size of
the largest angle of any drawing must be (Mk + mid)/2 or α(j−1)j for some
j ∈ {2, ..., k}, which is also always in σ. Since σ simultaneously possesses both
the maximum size of the smallest angle and the minimum size of the largest
angle of any drawing, σ also witnesses the optimum aspect ratio. 2
Using Procedure 1, the drawing of a rooted unordered tree which achieves
optimality in angular resolution and aspect ratio can be constructed efficiently
in a bottom-up fashion.
C. Lin and H. Yen, Balloon Drawings, JGAA, 11(2) 431–452 (2007) 441
in Section 5 (dealing with optimizing the drawing area) and certainly deserves
to be compared with our technique in greater detail in the future.
4 Balloon drawing with uneven angles
The area of a balloon drawing can be measured by the size of the circle en-
closing the balloon drawing. Minimizing the area of a drawing is an important
issue because any drawing needs to be rendered on a limited region. A careful
examination of the approach investigated in Section 3 suggests that the area of
balloon drawing generated by the SNS model may not be minimal. Part of the
reason is the involvement of the so-called free arc described in the SNS model
and Figure 2 (b), serving for the purpose of separating the enclosing circles of
two neighboring subtrees. A more subtle point regarding the ‘waste’ of drawing
space is illustrated in Figure 4, in which Figure 4 (a) shows the drawing of a
tree under the SNS model. Let Tv be the subtree rooted at v. Based on the
approach discussed in Section 3, Tv resides in a circle centered at v and the
circle is included in a wedge in which the ray from O to v cuts the wedge into
two sub-wedges of identical size (i.e., ω1 = ω2). By limiting the drawing to the
area formed by two lines (see t1 and t2 in Figure 4 (a)) tangent to the drawing of
Tv, the drawing area is reduced. That is, the new wedge (in which the drawing
of Tv resides) is now spanned by lines t1 and t2 with the size of the wedge angle
equals ω3+ω4. Furthermore, the ray
−→
Ov cuts this new wedge into two possibly
uneven parts (i.e., ω3 need not be equal to ω4).
v
(a) Original drawing (b) (c)
m1
m2
mid
M1
M2
m1
m2
M1
m1
m2
mid
M1
M2
O
t2
t1
free_arc
3
4
1
2
3
4
mid
M2
5
6
v
v
Figure 4: An approach for minimizing the drawing area where each shaded circle
is a star graph.
Allowing uneven angles tends to release extra space between the drawings of
neighboring subtrees, in comparison with the case discussed in Section 3 when
only even angles are permitted. The presence of such extra space allows us to
move the position of each subtree inwards (i.e., towards the root node O) which,
in turn, reduces the drawing area as Figure 4 (b) shows. The drawing area can
C. Lin and H. Yen, Balloon Drawings, JGAA, 11(2) 431–452 (2007) 443
(a) (b)
c1
c2
c4
c3
c1
c2
c4
c3
0
w31
w3
0
w31
w3
w1
0
w1
1
w2
1w2
0
w4
1
w4
0
w1
0
w1
1
w2
1
w2
0
w4
1
w4
0
Figure 5: Illustration of the balloon drawing with uneven angles.
In what follows, we show how the above two problems can be reduced to
perfect matching for bipartite graphs. A matching M on a graph G is a set of
edges of G such that any two edges in M share no common node. A maximum
matching of G is a matching of maximum cardinality. The largest possible
matching on a graph with n nodes consists of n/2 edges, and such a matching
is called a perfect matching. It is known that the maximum matching problem
for bipartite graphs with n nodes and m edges can be found in O(
√
mn) time
[12].
Theorem 2
Both the Aspect Ratio Problem and the Angular Resolution Problem
can be solved in O(n1.5 log n) time.
Proof: We consider the Aspect Ratio Problem first. Let r be the bound of the
desired aspect ratio. Suppose the set of sub-wedge angles of the star graph is
specified as
{b1, b
′
1︸ ︷︷ ︸, b2, b
′
2︸ ︷︷ ︸, ..., bi, b
′
i︸︷︷︸, ..., bn, b
′
n︸ ︷︷ ︸}
c1 c2 ... ci ... cn.
Notice that bi and b
′
i are the sizes of the two angles associated with the wedge
in which the drawing of the subtree rooted at ci resides. bi (b
′
i) can be the
neighbor of one of bi−1, b
′
i−1, bi+1, and b
′
i+1, depending on where ci−1, ci and
ci+1 are positioned in the drawing. (For instance, if bi is paired with b
′
i+1, the
angle between
−−→
Oci and
−−−→
Oci+1 becomes bi + b
′
i+1.) As a result, to determine
whether it is feasible to realize a drawing for which the aspect ratio is less than
or equal to r, our algorithm iteratively selects a pair (x, y) where x ∈ {bi, b
′
i}
and y ∈ {bi⊕1, b
′
i⊕1} so that x + y is assumed to be the ‘smallest’ angle in a
drawing respecting the aspect ratio r, if such a drawing exists. Then a bipartite
graph G(x,y) is constructed in such a way that a drawing respecting the aspect
ratio r exists iff G(x,y) has a perfect matching.
C. Lin and H. Yen, Balloon Drawings, JGAA, 11(2) 431–452 (2007) 445
other sub-wedge of node c2) in M . Since b2 has been matched with b
′
1, b
′
2 only
can be matched with either b3 or b
′
3. W.l.o.g, we assume that b
′
2 is matched with
b3 inM , i.e., the other sub-wedge b
′
2 of node c2 is placed next to sub-wedge b3 of
node c3 in the balloon drawing. Next we consider the matching of b
′
3 in M . In
the similar way, we can construct a balloon drawing with respect to M . By the
setting of G(b1,b′n), and the fact that the edges which violate AngResl = b1+ b
′
n
and AspRatio ≤ r are not included in G(b1,b′n), these edges do not appear in M .
Therefore, for this balloon drawing, AngResl = b1 + b
′
n, and AspRatio ≤ r.
Conversely, suppose that there exists a drawing D for which AngResl =
b1 + b
′
n, and AspRatio ≤ r. Since every bi (b
′
i) can be the neighbor of one of
bi−1, b
′
i−1, bi−1, and b
′
i−1 in any balloon drawing for the aspect ratio problem,
and AngResl for drawing D is formed by sub-wedges b1 and b
′
n (i.e., we can
imagine that b′n has been matched with b1), hence, the adjacency relation of
sub-wedges in balloon drawing D must be a perfect matching of G(b1,b′n) (see
Figure 6). In what follows, we show the existence of such a perfect matching.
Consider node c1. Since for the drawing, AngResl = b1 + b
′
n, i.e., sub-wedge
b′n of node cn is the neighbor of sub-wedge b1 of node c1 in D, hence, the other
sub-wedge b′1 of node c1 must be placed next to either b2 or b
′
2 in D. W.l.o.g., we
assume that sub-wedge b′1 is placed next to sub-wedge b2 in D. Since for drawing
D, AngResl = b1+ b
′
n and AspRatio ≤ r, hence, b1+ b
′
n ≤ b
′
1+ b2 ≤ r(b1+ b
′
n),
which guarantees that edge (b′1, b2) must appear in G(b1,b′n) according to the
setting of G(b1,b′n). In a similar way, we can guarantee that all of the edges
representing the adjacency relation of sub-wedges in drawing D must appear in
G(b1,b′n). Consequently, by navigating the circular permutation of sub-wedges
in D, a perfect matching for G(b1,b′n) corresponding to D can be obtained.
In view of the above, G(b1,b′n) has a perfect matching iff there exists a drawing
for which AngResl = b1 + b
′
n, and AspRatio ≤ r. Hence, for each i, 1 ≤ i ≤ n,
by examining the pair (x, y), x ∈ {bi, b
′
i} and y ∈ {bi⊕1, b
′
i⊕1}, that contributes
to AngResl (i.e., the smallest angle), whether a drawing with an aspect ratio
≤ r exists or not can be determined.
As for the executing time, since every node in the constructed bipartite graph
is adjacent to at most four edges (see Figure 6), the total number of possible
values of φ is O(n). We first sort the O(n) values. Each iteration during the
binary search of these values constructs its corresponding bipartite graph and
checks whether a perfect matching exists. For a given m-edge n-node bipartite
graph, the perfect matching problem can be solved in O(
√
mn) time. As a
result, the Aspect Ratio Problem can be solved in O(n log n + log n ×
√
nn) =
O(n1.5 log n) time. The solution for the Angular Resolution Problem can be
carried out along a similar line of the proof for the Aspect Ratio Problem. 2
5 Optimizing the drawing area
In the work of [16], a graph visualization style was introduced in which edges
at the same level are colored using the same color and the color brightness
of an edge is proportional to the distance from the root. Using this kind of
C. Lin and H. Yen, Balloon Drawings, JGAA, 11(2) 431–452 (2007) 447
to minimizing the area. This kind of an optimization problem with a linear ob-
jective function and quadratic constraints is known as quadratically constrained
linear program (QCLP), which can be solved effectively when the feasible set is
convex. Unfortunately, the problem is nonconvex in our formulation due to the
presence of Inequality (5). Although solving a QCLP exactly is often difficult,
in practical applications there exist many robust algorithms (see, e.g., [2]) for
QCLPs, a well-structured subclass of the more general and difficult nonlinear
programming.
As for the uneven angle case, solving the area problem for an ordered star
graph can be formulated as the following instance of nonlinear programming, in
which the angle between c0ci and c0ci⊕1 is denoted as θi⊕1 (see Figure 7 (b)):
Minimize z
subject to di sin(θi) ≥ Ri,
di sin(θi⊕1) ≥ Ri,
d2i + d
2
i⊕1 − 2didi⊕1 cos(θi⊕1) ≥ (Ri +Ri⊕1)
2,
z ≥ Ri + di
for each i ∈ {1, 2, ..., n}
where z, di, and θi are variables.
The work by Grivet et al. [5] is related to the area problem. Their method of
generating balloon drawings with bends on edges involves two stages. The first
stage includes three procedures: with the objective of increasing the angular
resolution, the first procedure determines the positions of nodes at the lower
level (related to their parent); then the second procedure applies either Welzl’s
randomized algorithm [17] in expected linear time (average polynomial time)
or their proposed linear time heuristics to finding the smallest circle enclosing
these nodes with fixed positions; the third procedure determines the positions
of bends on edges when considering the layout of the whole tree. Finally, the
second stage generates the final layout without edge crossings. Although the
first two procedures of their first stage are related to our problem, their objective
is still different from ours. As opposed to finding the smallest circle enclosing
the nodes with fixed positions (after determining the distance of nodes from
their parents) in the first stage of the algorithm in [5], our nonlinear programs
are designed for determining both the drawing area size and the distance of each
node from the root node simultaneously.
It should be noticed that finding improved solutions for the area problem
remains an interesting open question.
6 Applications
In this section, we explain how the balloon drawing can be tailored to cop-
ing with the drawing of a number of graphs of interest in real-world applica-
tions. Three applications, namely, sparse graphs, galaxy system, and H-trees,
are demonstrated in this section.
C. Lin and H. Yen, Balloon Drawings, JGAA, 11(2) 431–452 (2007) 449
to display the ages of stars (or distances of stars away from us). When a star
or a galaxy dies, the corresponding node (nodes), edge(s), and subtree(s) are
deleted.
To draw a galaxy system, the style of a balloon drawing has to be altered
slightly as Figure 9 (a) indicates. The modification is to reflect the phenomenon
of stars rotating around their parent on different orbits. Although the calcu-
lation of circumference is the same as originally derived, each node should be
placed on its orbit instead of the circumference. Besides, each node needs to
record the distance to its parent instead of the radius, and the maximum radius
of subtrees on each orbit Rmax[·] also needs to be recorded to compute the radius
of each orbit because there probably exist at least two nodes rotating around
the same orbit. All of those specific settings can be preprocessed in linear time.
Figure 9 (b) is an example of our experimental result.
(b) Simulation on a galaxy
      system with 200 stars.
(c) Simulation on
      an H-tree.
vparent
(a) Illustration of some galaxy
      (subtree) in a galaxy system.
Rmax [2]
Rmax,O
Rmax [0]
Rmax [1]
O
Figure 9: Applications to galaxy systems and H-graphs.
Again, one can see that balloon drawing serves as a foundation upon which
an interesting application of visualizing a galaxy system is built. In practice, it
is of interest to display galaxy systems with real data.
6.3 H-tree
If we let Rmin be zero in Figure 2 (a) and adjust the angles slightly, then we
end up with Figure 9 (c) as the output drawing, which is an example of the
so-called H-tree [15].
7 Conclusion
An efficient algorithm for optimizing the angular resolution as well as the aspect
ratio of balloon drawings of rooted unordered trees with even angles has been
proposed and implemented. As for the case of uneven angle type, the problem
of optimizing the angular resolution and the aspect ratio for ordered trees can
be solved in O(n1.5 log n) time. The problem is open for unordered trees at
this moment. Aside from the above theoretical results, we have also shown
C. Lin and H. Yen, Balloon Drawings, JGAA, 11(2) 431–452 (2007) 451
References
[1] J. Barnes and P. Hut. A hierarchical O(N logN) force-cacluation algo-
rithm. Nature, 324:446–451, 1986.
[2] D. Bertsekas. Nonlinear programming. Athena Scientific, Belmont, MA,
2nd edition, 1999.
[3] J. Carrie`re and R. Kazman. Research report: Interacting with huge hier-
archies: Beyond cone trees. In InfoVis ’95, pages 74–81. IEEE CS Press,
1995.
[4] P. Eades. Drawing free trees. Bulletin of the Institute for Combinatorics
and its Applications, pages 10–36, 1992.
[5] S. Grivet, D. Auber, J. Domenger, and G. Melanc¸on. Bubble tree drawing
algorithm. In Proc. of International Conference on Computer Vision and
Graphics 2004, pages 633–641, 2004.
[6] C.-S. Jeong and A. Pang. Reconfigurable disc trees for visualizing large
hierarchical information space. In InfoVis ’98, pages 19–25. IEEE CS Press,
1998.
[7] H. Koike and H. Yoshihara. Fractal approaches for visualizing huge hier-
archies. In VL ’93, pages 55–60. IEEE CS Press, 1993.
[8] G. Melanc¸on and I. Herman. Circular drawing of rooted
trees. Technical report, Reports of the Centre for Mathemat-
ics and Computer Sciences. Report number INS-9817, available at:
http://www.cwi.nl/InfoVis/papers/circular.pdf, 1998.
[9] T. Munzner. H3: Laying out large directed graphs in 3D hyperbolic space.
In INFOVIS 1997, pages 2–10. IEEE Press, 1997.
[10] T. Muzner. Drawing large graphs with H3Viewer and site manager. In GD
1998, volume 1547 of LNCS, pages 384–393. Springer, 1998.
[11] T. Muzner and P. Burchard. Visualizing the structure of the world wide
web in 3D hyperbolic space. In VRML 1995, pages 33–38. ACM Press,
1995.
[12] C. Papadimitriou and K. Steiglitz. Combinatorial Optimization. Prentice
Hall, Englewood Cliffs, New Jersey, 1982.
[13] E. Reingold and J. Tilford. Tidier drawing of trees. IEEE Trans. Software
Eng., SE-7(2):223–228, 1981.
[14] G. Robertson, J. Mackinlay, and S. Card. Cone trees: Animated 3D vi-
sualizations of hierarchical information. In CHI ’91, pages 189–194. ACM
Press, 1991.
Width-Optimal Visibility Representations of
Plane Graphs
Jia-Hao Fan1, Chun-Cheng Lin1, Hsueh-I Lu2, and Hsu-Chun Yen1,3
1 Dept. of Electrical Engineering, National Taiwan University, Taipei, Taiwan, ROC
{grant,sanlin}@cobra.ee.ntu.edu.tw, yen@cc.ee.ntu.edu.tw
2 Dept. of Computer Science and Information Engineering, National Taiwan
University, Taipei, Taiwan, ROC
hil@csie.ntu.edu.tw
3 Dept. of Computer Science, Kainan University, Taoyuan, Taiwan, ROC
Abstract. Given an n-node plane graph G, the visibility representation
of G is concerned with drawing each node of G using a horizontal line
segment such that the line segments associated with any two adjacent
nodes of G are vertically visible to each other. Finding most compact
visibility representations of plane graphs is not only of theoretical im-
portance but also of practical interest, and has received much attention
in the community of algorithmic graph theory. In this paper, we give a
linear-time algorithm to ﬁnd a visibility representation of G no wider
than  4n
3
 − 2. Our result improves upon the previously known upper
bound 4n
3
+ 2√n, providing a positive answer to a conjecture sug-
gested in the literature about whether an upper bound 4n
3
+ O(1) on
the required width can be achieved for an arbitrary plane graph. In fact,
our visibility representation achieves optimality in the upper bound of
width because the bound diﬀers from the previously known lower bound
 4n
3
 − 3 only by one unit.
1 Introduction
Let G be an n-node plane graph. A visibility representation of G represents each
node of G as a horizontal line segment, called a node segment, such that the
node segments representing any two adjacent nodes of G are vertically visible to
each other (see Figure 1). Computing compact visibility representations of planar
graphs gets a lot of attention in the literature because it has many applications
in algorithmic graph theory [1,10] as well as VLSI layout design [8]. As far as the
area size of a visibility representation is concerned, one may apply the convention
of locating the endpoints of node segments on the grid points of an integer grid.
The compactness of a visibility representation is typically measured in terms
of the width and the size of the smallest bounding rectangle of the visibility
representation on the grid.
Otten and van Wijk [6] gave the ﬁrst known algorithm for visibility repre-
sentations of planar graphs, although their algorithm reveals no bound for the
T. Tokuyama (Ed.): ISAAC 2007, LNCS 4835, pp. 160–171, 2007.
c© Springer-Verlag Berlin Heidelberg 2007
162 J.-H. Fan et al.
the boundary of each face, including the outer face, is a triangle. In a visibility
drawing (a.k.a., visibility representation) of G, every node of G is represented by a
horizontal line segment, called a node segment, such that the node segments rep-
resenting any two adjacent nodes of G are connected by a vertical line segment,
called an edge segment. The visibility embedding of a drawing of G associates
to each node v a circular counterclockwise ordering of the incidence list (set of
neighbors) Adj(v) of v which is divided into two sublists: one is for the neighbor
nodes which are visible to v from the down side (denoted by Adj1(v)); the other
sublist includes the other nodes (denoted Adj2(v)). For example, in Figure 1(b),
Adj1(node 4) = nodes 2, 8, 3 and Adj2(node 4) = nodes 7, 6, 9, 5. Throughout
the paper, the degree of a node v is denoted deg(v); the x-coordinate of the left
(resp. right) endpoint of the node segment representing v in a visibility draw-
ing is denoted x−(v) (resp. x+(v)); and the y-coordinate of the node segment
representing v in the visibility drawing is denoted y(v).
For ease of explanation, we deﬁne the so-called coalescing and splitting oper-
ations of vk+1 with degree three, four, and ﬁve as follows. It suﬃces to deﬁne
the operations for degree ﬁve; the other operations are similar and simpler. In
Figure 2 (c), we say that the case when Gk+1 becomes Gk is due to coalescing
two nodes vk+1 and u, whereas the case when Gk becomes Gk+1 is due to split-
ting node vk+1 from the common node u of faces Fk,1, Fk,2, and Fk,3. Note that
a splitting operation also can be regarded as either attaching two new faces to
node u or inserting a node at faces Fk,1, Fk,2, and Fk,3. We denote by α3(vk+1, u)
the operation of coalescing vk+1 and u, whereas the operation of splitting vk+1
from u at faces Fk,1, Fk,2, Fk,3 is denoted by β3(vk+1, Fk,1, Fk,2, Fk,3). In a sim-
ilar way, α1(vk+1, u), β1(vk+1, Fk,1) for deg(vk+1) = 3 as well as α2(vk+1, u),
β2(vk+1, Fk,1, Fk,2) for deg(vk+1) = 4 are deﬁned.
in Gk+1 in Gk in Gk+1 in Gk in Gk+1 in Gk
(b) deg(vk+1) = 4 in Gk+1(a) deg(vk+1) = 3 in Gk+1 (c) deg(vk+1) = 5 in Gk+1
1
1
vk+1
vr
vp = u
vq
Fk,1
vr
vp = u
vq 2
2
3
3
vr
vp = u
vs
vq
Fk,2 Fk,1
vr
vp = u
vs
vq
vk+1
vr
vp = u
vt vq
Fk,2
Fk,1Fk,3
vs
vk+1
vr
vp = u
vt vq
vs
Fig. 2. Illustration of the coalescing and splitting operations
Let π = (v1, v2, ..., vn) be an ordering of all nodes in G, in which v1, v2, v3
are the three nodes of the outer face of G counterclockwise. For each integer k,
3 ≤ k ≤ n−1, the plane graph Gk+1 involving the k+1 nodes v1, v2, ..., vk, vk+1
is produced by splitting vk+1 from some node in Gk. Let Gn = G. We call π a
constructive ordering of a plane triangulation G if the following conditions hold
for each k, 3 ≤ k ≤ n:
(c1) Gk is a plane triangulation with outer edges v1v2, v2v3, v3v1;
164 J.-H. Fan et al.
Algorithm Visibility
Input: a plane triangulation G
Output: a width-optimal visibility drawing of G
1. A constructive ordering π = (v1, v2, ..., vn) of G is obtained by Lemma 1.
2. Initially, we draw all the (six) possible (L-shaped) visibility drawings of G3
as shown in Figure 4 (b)(i), where (vp, vq, vr) = (v1, v2, v3). Note that the
six drawings can be classiﬁed into three pairs, where each of the three nodes
v1-v3 serves as a bottom node segment in turn in each pair. Also note that
every drawing has the narrowest width (i.e., two).
3. For each node vk+1, k = 3, 4, ..., n − 1, we maintain six drawings of Gk+1 by
doing the following:
(a) If Deg(vk+1) = 3, then we execute the β1 operation shown in Figure 5.
(b) If Deg(vk+1) = 4, then we execute the β2 operation shown in Figure
6, depending on the shapes of drawings of Fk,1 and Fk,2 in each of six
drawings of Gk.
(c) If Deg(vk+1) = 5, then we execute the β3 operation shown in Figure 7,
depending on the shapes of drawings of Fk,1, Fk,2, and Fk,3 in each of
six drawings of Gk.
Appropriately adjust the drawings of the other faces on the left, right, top,
and bottom of the drawings transformed from the drawings of Fk,1, Fk,2,
and Fk,3.
4. Compress the width of each of the six drawings of Gn = G as much as
possible. Then output the drawing of G with the narrowest width.
Note that each of Figures 6 (a) and (b) includes four possible cases depending
on that the two input L-shapes are left (denoted l) or right (denoted r) L-shape,
e.g., Figure 6(a)(1-ii) is the case when the conﬁguration of the two input L-
shapes is rl, which means that from the left to the right the ﬁrst input L-shape
is a right L-shape and the second input L-shape is a left L-shape. According to
this classiﬁcation, we demonstrate all possible cases of the β2 operation in Figure
6. In a similar way, all possible cases of the β3 operation are demonstrated in
Figure 7. As a result, we have the following observation, upon which Step 3 of
Algorithm Visibility is based.
Observation 1. If every inner face in Gk is drawn as an L-shape, then Fig-
ure 5 (resp., Figure 6 and Figure 7) illustrates all the possible cases of the β1
(resp., β2 and β3) operation. Furthermore, the bottom node segment of each of
the six drawings of any face rather than Fk,1–Fk,3 is not modiﬁed in executing
the operation.
Before showing the proof of the main theorem in detail, some notations are
given as follows. Recall that, in Figure 3, the width of L-shape D(F ) of an
inner face F is determined by that of its bottom node segment, so we denote
by wb(D(F )) the width of the bottom node segment of D(F ). Note that each
166 J.-H. Fan et al.
(2-viii) lll: This case is a reflectional
                      symmetry of case (2-i).
(2-iv) rll: This case is a reflectional
                   symmetry of case (2-ii).
(2-v) lrr
(2-vii) llr: This case is a reflectional
                    symmetry of case (2-v).
3
(2-iii) rlr: This case is a reflectional
                    symmetry of case (2-vi).
vt
vp
vqvs
Fk,2 Fk,1Fk,3
vr
vt
vp
vq
vs
Fk,1Fk,3 Fk,2
vr
vp
vq
vs
vt
Fk,2
Fk,1
Fk,3
vr
vk+1
vq
vs
vt
vp
vr
vr
vs
vt
vq
Fk,2
Fk,3Fk,1
vp
vk+1
vt
vq
vs
vr
vr
vs
vtvq
Fk,2
Fk,3
Fk,1
vp
vr
vs
vtvq
vp
vk+1
vt
vk+1
vqvs
vp
vr
vr
vs
vtvq
Fk,2
Fk,3
Fk,1
vp
vr
vs
vp
vq
Fk,2
Fk,3
Fk,1
vt
vr
vs
vk+1
vq
vt
vp
vr
vs
vtvq
vp
vk+1
(2-i-a) rrr (2-i-b) rrr (2-ii-a) rrl (2-ii-b) rrl
vp
vq
vr
vt
Fk,2
Fk,1
Fk,3
vs
vp
vq
vr
vt
vp
vs
(2-ii-c) rrl (2-vi-a) lrl (2-vi-b) lrl
vr
vs
vt
vq
vk+1
vp
(3-vi) lrl(3-ii) rrl (3-v) lrr(3-i) rrr
(3-iii) rlr: This case is a reflectional symmetry of case (3-vi).
(3-iv) rll: This case is a reflectional symmetry of case (3-ii).
(3-vii) llr:  This case is a reflectional symmetry of case (3-v).
(3-viii) lll: This case is a reflectional symmetry of case (3-i).
vk+1
vq
vr
vt
vs
vp
vk+1
vqvs
vt
vp
vr
vp
vqvs
vt
vk+1
vr
vp
vq
vrvt
vk+1
vs
vp
vqvs
vt
Fk,2
Fk,1
Fk,3 vr
vp
vq
vr
vt
Fk,2
Fk,1
Fk,3
vs
vp
vq
vrvt
Fk,2
Fk,1
Fk,3
vs
vp
vqvs
vt
Fk,2
Fk,1
Fk,3
vr
(2v-iii) lr: This case is a reflectional symmetry of case (2v-ii).
(2v-iv) ll: This case is a reflectional symmetry of case (2v-i).
vr
vs
vt
vq
Fk,2
Fk,3
Fk,1
vp
vr
vs
vt
vq
Fk,2
Fk,3
Fk,1
vp
vk+1
vr
vs
vt
vq
vp
vr
vs
vt
vq
vp
vk+1
vr
vs
vt
vqFk,2
Fk,3
Fk,1
vp
vr
vs
vt
vq
vp
vk+1
vr
vs
vt
vq
vp Fk,2
Fk,3
Fk,1
vr
vs
vt
vq
vp
vk+1
(2v-i-a) rr (2v-i-b) rr (2v-ii-a) rl (2v-ii-b) rl
(b) Two of the three input L-sahpes share the same bottom node segment.
(c) The three input L-sahpes share the same bottom
      node segment.
(a) None of the three input L-shapes shares the same bottom node segment.
(d) Only two input L-sahpes are visible
      from the down side.
(1-vi) lrl: This case does not exist.
(1-viii) lll: This case is a reflectional symmetry of case (1-i).
(1-iv) rll: This case is a reflectional symmetry of case (1-ii).
(1-vii) llr: This case does not exist.
(1-i) rrr
(1-iii) rlr: This case does not exist.
(1-v) lrr: This case does not exist.
vr
vs
vt
vq
vp
vk+1
vr
vs
vt
vq
Fk,2
Fk,3
Fk,1
vp
vp
vq
vr
vt
Fk,2
Fk,1
Fk,3
vs
vr
vs
vt
vq
vk+1
vp
vk+1
vq
vr
vt
vs
vp
(1-ii-a) rrl (1-ii-b) rrl
vr
vs
vt
vq
Fk,2
Fk,3
Fk,1
vp
3 3 3
33 3333 3
3 33 3333 3
Fig. 7. The splitting operation of node vk+1 with degree ﬁve
iteration of Step 3 in our algorithm maintains six visibility drawings of Gk+1. Let
L denote a face or a subgraph in Gk+1. The L-shapes of L appearing in the six
drawings are denoted by D1(L)-D6(L), and D(L) = {D1(L), D2(L), ..., D6(L)}.
168 J.-H. Fan et al.
Table 1. The three pairs of the input L-shapes (the six drawings) of the β1, β2, and
β3 operations
1st pair 2nd pair 3rd pair
β1 Figure 5: vp = u1 Figure 5: vp = u2 Figure 5: vp = u3
or μ1
β2 Figure 6(b): vp = u1 Figure 6(a): vr = u3, vq = u4 Figure 6(a): vr = u3, vq = u2
or μ2
β3 Figure 7(c): vp = u1 Figure 7(a) excluding (1-ii-b): Figure 7(a) excluding (1-ii-b):
or μ3 (vq, vr , vs) = (u2, u3, u4) (vq, vr, vs) = (u5, u4, u3)
Figure 7(b) (2-i-b), (2-ii-c): Figure 7(d) (2v-ii-a), (2v-ii-b): Figure 7(b) (2-i-a), (2-ii-a),
β3 (vp, vt) = (u1, u5); (vp, vq, vr) = (u1, u2, u3) (2-v), (2-vi-a):
Figure 7(b) (2-ii-b), (2-vi-c): {vr, vs} = {u3, u4}
(vp, vq) = (u1, u5)
β3 Figure 7(d) (2v-i-a), (2v-i-b): Figure 7(d) (2v-i-a), (2v-i-b): Figure 7(a)(1-ii-b):
(vp, vr) = (u1, u4) (vp, vr) = (u1, u3) vp = u1, {vq, vt} = {u2, u5}
(b) 1st pair (c) 2nd pair or 3rd pair
a3
a1
ai+2 a2Fk,1Fk,i
ai+1
...
...
in Gk
in Gk+1
a2
a1
ai+2 a1
ai+1
...
ai+3
f1’f2’
i
(a)
a1
...
...
x
y ai+3...
a1
...
x
y
ai+3
i i
...
i
a1
a2
a3
Fk,1Fk,i
ai+2
...
ai+1
...
a1
a2
a3
ai+2
ai+3
...
ai+1
...
f1’f2’
All configurations of i adjacent
L-shapes with the same bottom
node segment exist. Here illust-
rates only the configuration rr...r.
No two L-shapes share the same bottom node segment;
otherwise, it violates Observation 2. Thus, there exist
only four possible configurations rr...r, rr...rl, ll...l, rll...l.
Here illustrate configurations rr...r, rr...rl.
a1
...
......
a1
...
or
Fig. 8. Illustration of the μi operation
With respect to D(G), a constructive ordering is called U-shaped construc-
tive ordering if a drawing in D(G) is constructed only by U-shaped insertions.
Fortunately, we have the following observation.
Observation 3. There exists a U-shaped constructive ordering with respect to
D(G), produced by Step 3 of Algorithm Visibility.
From Figure 5(ii), the drawing width is increased by two units after executing
a μ1 operation ( β1 operation) at an L-shape with wb = 1. Therefore, if the μ1
operation is executed at a face F where the number of pairs of the L-shapes
with wb = 1 is at least two, then s(Gk+1) − s(Gk) ≥ 10 > 8, which is not our
required result. As a result, in order to guarantee that s(Gk+1) − s(Gk) = 8,
we require to adjust the edge segments such that every μ1 operation is always
170 J.-H. Fan et al.
(a) (b)
D3 in 2nd pair
D1 in 1st pair
A unit is
retruned
to v2v3v4.
v4
v3
v1
v2
v5
F2
D5 in 3rd pair
v5
v1
v2
v3
v4
v6F3
v4
v3
v1
v2
v5
v6
F3
v4
v3
v1
v2
v5
v6
F3
v4
v2
v3
v1
v5v6
F3
v5
v1
v2
v3
v4 F2
F2 borrows
a unit
from v2v3v4.
v4
v2
v3
v1
v5
F2 v4
v2
v3
v1
v5F2
D1 in 1st pair
D3 in 2nd pair
D5 in 3rd pair
1
Fig. 9. Illustration of borrowing and lending a unit of width
Lemma 3. Given a good graph g (associated with six visibility drawings D(g)),
a graph g′ transformed by executing a U-shaped insertion at g is a good graph.
In addition, s(g′) = s(g) + 8.
Based on the above, we are ready to present the proof of Theorem 1 as follows:
(Proof of Theorem 1) We claim that there exists a visibility drawing Dopt
with width  4n3  − 2 which has the same visibility embedding Δ as the visibility
drawing Dour produced by Algorithm Visibility. Since Dour is the visibility
drawing with the minimum width under the visibility embedding Δ by Step 4
of Algorithm Visibility, Dour must be no wider than  4n3  − 2.
Now we show the claim. By Observation 3, we have a U-shaped constructive
ordering with respect to D(G), produced by Step 3 of Algorithm Visibility.
With respect to the U-shaped constructive ordering π = (v1, v2, ..., vn) for D(G),
we proceed by induction on k = 3, 4, ..., n to show that Gk is a good graph;
s(Gk) = s(Gk−1) + 8 for k 
= 3. Initially, the six drawings of G3 is produced by
Step 2 of Algorithm Visibility, as shown in Figure 4(b)(i), i.e., G3 is a good
face. By Lemma 2, G3 is a good graph. Suppose that Gk is a good graph. By
Lemma 3, Gk+1 is a good graph and s(Gk) = s(Gk−1) + 8.
Since G3 is a good face whose drawings are shown in Figure 4(b)(i), s(G3) =
6×2 = 12. Since there are (n−3) U-shaped insertions, each of which contributes
8 units of width, hence, s(Gn) = 12 + (n − 3) × 8 = 8n − 12. As a result, the
Balloon Views of Source Code and Their Multiscalable Font Modes
Chun-Cheng Lin, Hsu-Chun Yen∗
Department of Electrical Engineering, National Taiwan University, Taipei, Taiwan 106, ROC
sanlin@cobra.ee.ntu.edu.tw, yen@cc.ee.ntu.edu.tw
Abstract
The majority of program editors available on the mar-
ket support the view of a directory-explorer style to display
only those code lines of interest. Among them, the fisheye
and the fractal views of source code (in which each line has
a value reflecting the degree of interest and importance)
have received a lot of attention in the literature. In infor-
mation visualization, drawing trees based on fractal theory
also plays an interesting role as the so-called balloon draw-
ing of hierarchical data includes two models: the fractal
and the SNS (subtrees with nonuniform sizes) models. It is
therefore natural to consider a new source code visualiza-
tion style based on the SNS model of balloon drawing. A
main feature of the SNS view is that the value of each line
reflects the number of its descendants when the source code
is viewed as a tree structure. Unlike the view of a directory-
explorer style, the multiscalable font mode (which was orig-
inally utilized in the fractal view of source code) displays all
the lines in such a way that each line has the font size pro-
portional to its value. In this paper, we investigate various
issues concerning the multiscalable font modes of the fish-
eye, the fractal, and the SNS views of source code, in hope
of providing guidelines for the programmer to better com-
prehend the program code in practice.
1. Introduction
In developing a huge and complicated program, the pro-
grammer often not only applies the text editor to writing the
program, but also observes a variety of views of the program
source code to comprehend the program. Suppose we con-
sider the program source code as a hierarchical structure.
The source code view in some common program editors,
like a directory explorer, allows the programmer to hide
or show the source code lines of lower levels by clicking
the line of the upper level. With this feature, programmers
can show on the screen only the lines that they concern,
∗Corresponding author. Research supported in part by Grants 95-EC-
17-A-02-S1-049 and NSC 95-2221-E-002-074.
which preserve the outline of the source code. In addition,
in object-oriented programming, the class view, which gives
the visual directory explorer of the hierarchical relation of
classes and variables, makes it easy for programmers to nav-
igate, understand, and manipulate the classes and variables.
Designing a source code view which fits the needs of
programmers (i.e., allowing them to easily understand and
navigate through the codes) is of increasing importance,
especially for those writing new codes based upon exist-
ing codes possibly created by other programmers. Previ-
ous work along this line of research includes the follow-
ing. Furnas [6] proposed the fisheye view of source code,
in which a focus line is selected and each source code line
is assigned a value, called degree of interest (DOI), calcu-
lated by its a priori importance and its distance from the
focus line; the lines with DOI less than a certain threshold
are hidden, i.e., only the interesting lines are shown. Re-
cently, the work of [7] presented an empirical evaluation
of the fisheye view that emphasizes both the measures of
usability and the analysis of interaction patterns (as com-
pared to the linear view of source code). As programs of
a huge size are not uncommon in practice, navigating the
source code line by line in the fisheye view may cause the
amount of the displayed information to grow beyond any
reasonable scale that can be handled by a programmer. To
overcome this shortcoming, Koike [9] proposed the fractal
view of source code, in which every source code line is as-
signed a value calculated according to fractal theory, and
he showed that the amount of the displayed information is
always kept nearly constant no matter where the focus line
is located. In order to demonstrate the effect of the frac-
tal view, a multiscalable font mode of the fractal view was
given, showing all the source code lines each of which has
the font size proportional to its associated value. It was sug-
gested in [9] that this mode helps the user to understand the
relation between the views before and after a change of the
focus line.
The fisheye view is successful in the visualization of not
only the source code but also the graphical data [5, 13],
which gets a lot of attention in the society of graph draw-
ing (or information visualization in a broader sense). Graph
11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00  © 2007
the focus line (focus node) at every moment, and every ap-
proach to generating a view of source code considers the
tree structure taking the focus node as a new root.
1  #include <iostream.h>
2  void main() {
3      int i, sum = 0;
4      for ( i = 1 ; i <= 10 ; i++ ) {
5          sum += i;
6      }
7      cout << sum << endl;
8  } 5
43 6
21 8
7
0
root (initial focus)
Figure 2. The relationship between a program
source code and a tree structure.
2.2. Fisheye view of source code
In the fisheye view of source code [6], each line is as-
signed a degree of interest (DOI), which is computed by
its a priori importance and its distance from the focus line.
That is, given the focus line y, the generalized fisheye DOI
at line x is expressed as
DOIfisheye(x|. = y) = API(x)−D(x, y)
where API(x) is the global a priori importance of x and
D(x, y) is the distance between x and the focus line y. Here
we are concerned with the DOI for tree structures. Given the
focus line y in a tree structure representing certain source
code, the DOI at line x can be computed as
DOIfisheye(tree)(x|. = y) = −dtree(x, root)−dtree(x, y)
(1)
where dtree(x, y) is denoted as the path length distance
between x and y in the tree structure, i.e., D(x, y) =
dtree(x, y). Intuitively, it is fair to assume that the nodes at
the levels closer to the root are more important, and hence,
we let API(x) equal −dtree(x, root), i.e., the distance of
x from the root.
2.3. Fractal view of source code
The theory behind the fractal view of source code is ba-
sically from Koike’s work [9]. Consider a tree structure of
source code. By viewing the focus line as a new root, we
assign each node of the tree a so-called fractal value in a
top-down fashion. Initially, the fractal value of the focus is
assigned to 1. The fractal values of the other nodes are prop-
agated by multiplying a ratio correlated with their branch
numbers. That is, the formulas for computing the fractal
values can be expressed as follows:{
Fvfocus = 1
Fvchild of x = γx × Fvx (2)
γx = CN−1/Dx = N
−1
x
where Fvx is the fractal value of node x; C is a constant
for 0 < C ≤ 1; Nx is the number of branches of node
x; D is the fractal dimension. For convenience, throughout
this paper we assume that C = D = 1, i.e., the ratio γx
of each node x is correlated only with its branch number.
(In fact, the modification of C and D does not affect our
conclusion.) Koike also gave the multiscalable font mode
of the fractal view of source code [9], in which the font size
of each source code line is proportional to its fractal value
(see the right subfigures of Figures 4 (c) and (d)).
2.4. Balloon drawings of rooted trees
There exist two models in the literature for generating
balloon drawings of trees: the fractal model and the SNS
model. The balloon drawing of a tree structure under the
fractal model means that if rm and rm−1 are the lengths of
edges at depths m and m− 1, respectively, then
rm = γ × rm−1
where γ is the predefined ratio (0 < γ < 1) associated with
the drawing under the fractal model. Clearly, edges at the
same depth have the same length in a fractal drawing.
(a) (b)
O = c0
free_arc
r
wedge ici
r
Rj
Rj-1
O
vparent
RO
free_arc
R1
Rj+1
Rmin
1 w0(i)
w1(i)
j
Figure 3. The SNS model. (a) Node O is not
the root, and the edge between O and its par-
ent goes through a circle with radius Rmin;
(b) is a star graph centered at c0.
Given a rooted ordered tree T with n nodes, a balloon
drawing under the SNS model [1, 8] can be obtained in
O(n) time in a bottom-up fashion with the edge length and
the angle between two adjacent edges respectively by:
RO ∼= max(
2
∑
j Rj
2π
,Rmin) + max
j
{Rj} (3)
θj ∼= Rj−1 + free arc + Rj
r
where Rj is the radius of the outer circle enclosing all sub-
trees of the j-th child of O, and RO is the radius of the outer
11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00  © 2007
1 # d e f i n e  DI G 4 0  
2 # i n c l u d e  <s t d i o . h > 
3 ma i n ( )  
4 {  
5 i n t  c ,  i ,  x [ DI G/ 4 ] ,  t [ DI G/ 4 ] ,  k  = DI G/ 4 ,  n o p r i n t  =  0 ;  
6 wh i l e ( ( c =g e t c h a r ( ) )  ! = EOF) {  
7 i f ( c  >= ’ 0 ’  && c  <= ’ 9 ’ ) {  
8 x [ 0 ]  = 1 0  *  x [ 0 ]  + ( c - ’ 0 ’ ) ;  
9 f o r ( i =1 ; i <k ; i ++) {  
1 0 x [ i ]  =  1 0  *  x [ i ]  +  x [ i - 1 ] / 1 0 0 0 0 ;  
1 1 x [ i - 1 ]  %= 1 0 0 0 0 ;  
1 2 }  
1 3 }  e l s e  {  
1 4 s wi t c h ( c ) {  
1 5 c a s e  ’ +’ :  
1 6 t [ 0 ]  =  t [ 0 ]  + x [ 0 ] ;  
1 7 f o r ( i =1 ; i <k ; i ++) {  
1 8 t [ i ]  =  t [ i ]  +  x [ i ]  +  t [ i - 1 ] / 1 0 0 0 0 ;  
1 9 t [ i - 1 ]  %= 1 0 0 0 0 ;  
2 0 }  
2 1 t [ k - 1 ]  %= 1 0 0 0 0 ;  
2 2 b r e a k ;  
2 3 c a s e  ’ - ’ :  
2 4 t [ 0 ]  =  ( t [ 0 ]  + 1 0 0 0 0 )  -  x [ 0 ] ;  
2 5 f o r ( i =1 ; i <k ; i ++) {  
2 6 t [ i ]  =  ( t [ i ]  +  1 0 0 0 0 )  -  x [ i ]  -  ( 1  -  t [ i - 1 ] / 1 0 0 0 0 ) ;  
2 7 t [ i - 1 ]  %= 1 0 0 0 0 ;  
2 8 }  
2 9 t [ k - 1 ]  %= 1 0 0 0 0 ;  
3 0 b r e a k ;  
3 1 c a s e  ’ e ’ :  
3 2 f o r ( i =0 ; i <k ; i ++)  t [ i ]  =  x [ i ] ;  
3 3 b r e a k ;  
3 4 c a s e  ’ q ’ :  
3 5 e x i t ( 0 ) ;  
3 6 d e f a u l t :  
3 7 n o p r i n t  =  1 ;  
3 8 b r e a k ;  
3 9 }  
4 0 i f ( ! n o p r i n t ) {  
4 1 f o r ( i =k  -  1 ; t [ i ]  <= 0  && i  > 0 ; i - - ) ;  
4 2 p r i n t f ( " %d " , t [ i ] ) ;  
4 3 i f ( i  >  0 )  {  
4 4 f o r ( i - -  ;  i  >= 0 ;  i - - ) {  
4 5 p r i n t f ( " %0 4 d " , t [ i ] ) ;  
4 6 }  
4 7 }  
4 8 p u t c h a r ( ’  ’ ) ;  
4 9 f o r ( i =0 ;  i  >  k ; i ++)  x [ i ]  =  0 ;  
5 0 }  
5 1 }  
5 2 n o p r i n t  =  0 ;  
5 3 }  
5 4 }
(a) Fisheye view (focus node on line 0). (b) Fisheye view (focus node on line 24).
(c) Fractal view (focus node on line 0). (d) Fractal view (focus node on line 24).
1 # d e f i n e  DI G 4 0  
2 # i n c l u d e  <s t d i o . h > 
3 ma i n ( )  
4 {  
5 i n t  c ,  i ,  x [ DI G/ 4 ] ,  t [ DI G/ 4 ] ,  k  = DI G/ 4 ,  n o p r i n t  =  0 ;  
6 wh i l e ( ( c =g e t c h a r ( ) )  ! = 
7 i f ( c  >= ’ 0 ’  && c  <= ’ 9 ’ ) {  
8 x [ 0 ]  = 1 0  *  x [ 0 ]  + ( c - ’ 0 ’ ) ;  
9 f o r ( i =1 ; i <k ; i ++) {  
1 0 x [ i ]  =  1 0  *  x [ i ]  +  x [ i - 1 ] / 1 0 0 0 0 ;  
1 1 x [ i - 1 ]  %= 1 0 0 0 0 ;  
1 2 }  
1 3 }  e l s e  {  
1 4 s wi t c h ( c ) {  
1 5 c a s e  ’ +’ :  
1 6 t [ 0 ]  = t [ 0 ]  +  x [ 0 ] ;  
1 7 f o r ( i =1 ; i <k ; i ++) {  
1 8 t [ i ]  =  t [ i ]  +  x [ i ]  +  t [ i - 1 ] / 1 0 0 0 0 ;  
1 9 t [ i - 1 ]  %= 1 0 0 0 0 ;  
2 0 }  
2 1 t [ k - 1 ]  %= 1 0 0 0 0 ;  
2 2 b r e a k ;  
2 3 c a s e  ’ - ’ :  
2 4 t [ 0 ]  = ( t [ 0 ]  +  1 0 0 0 0 )  -  x [ 0 ] ;  
2 5 f o r ( i =1 ; i <k ; i ++) {  
2 6 t [ i ]  =  ( t [ i ]  +  1 0 0 0 0 )  -  x [ i ]  -  ( 1  -  t [ i - 1 ] / 1 0 0 0 0 ) ;  
2 7 t [ i - 1 ]  %= 1 0 0 0 0 ;  
2 8 }  
2 9 t [ k - 1 ]  %= 1 0 0 0 0 ;  
3 0 b r e a k ;  
3 1 c a s e  ’ e ’ :  
3 2 f o r ( i =0 ; i <k ; i ++)  t [ i ]  =  x [ i ] ;  
3 3 b r e a k ;  
3 4 c a s e  ’ q ’ :  
3 5 e x i t ( 0 ) ;  
3 6 d e f a u l t :  
3 7 n o p r i n t  =  1 ;  
3 8 b r e a k ;  
3 9 }  
4 0 i f ( ! n o p r i n t ) {  
4 1 f o r ( i =k  -  1 ; t [ i ]  <= 0  && i  >  0 ; i - - ) ;  
4 2 p r i n t f ( " %d " , t [ i ] ) ;  
4 3 i f ( i  >  0 )  {  
4 4 f o r ( i - -  ;  i  >= 0 ;  i - - ) {  
4 5 p r i n t f ( " %0 4 d " , t [ i ] ) ;  
4 6 }  
4 7 }  
4 8 p u t c h a r ( ’  ’ ) ;  
4 9 f o r ( i =0 ;  i  >  k ; i ++)  x [ i ]  =  0 ;  
5 0 }  
5 1 }  
5 2 n o p r i n t  =  0 ;  
5 3 }  
5 4 }
1 # d e f i n e  DI G 4 0  
2 # i n c l u d e  <s t d i o . h > 
3 ma i n ( )  
4 {  
5 i n t  c ,  i ,  x [ DI G/ 4 ] ,  t [ DI G/ 4 ] ,  k  =  DI G/ 4 ,  n o p r i n t  = 0 ;  
6 wh i l e ( ( c =g e t c h a r ( ) )  ! = EOF) {  
7 i f ( c  >= ’ 0 ’  && c  <= ’ 9 ’ ) {  
8 x [ 0 ]  =  1 0  *  x [ 0 ]  + ( c - ’ 0 ’ ) ;  
9 f o r ( i =1 ; i <k ; i ++) {  
1 0 x [ i ]  =  1 0  *  x [ i ]  + x [ i - 1 ] / 1 0 0 0 0 ;  
1 1 x [ i - 1 ]  %= 1 0 0 0 0 ;  
1 2 }  
1 3 }  e l s e  {  
1 4 s wi t c h ( c ) {  
1 5 c a s e  ’ +’ :  
1 6 t [ 0 ]  =  t [ 0 ]  +  x [ 0 ] ;  
1 7 f o r ( i =1 ; i <k ; i ++) {  
1 8 t [ i ]  =  t [ i ]  +  x [ i ]  +  t [ i - 1 ] / 1 0 0 0 0 ;  
1 9 t [ i - 1 ]  %= 1 0 0 0 0 ;  
2 0 }  
2 1 t [ k - 1 ]  %= 1 0 0 0 0 ;  
2 2 b r e a k ;  
2 3 c a s e  ’ - ’ :  
2 4 t [ 0 ]  = 
2 5 f o r ( i =1 ; i <k ; i ++) {  
2 6 t [ i ]  =  ( t [ i ]  +  1 0 0 0 0 )  -  x [ i ]  -  ( 1  -  t [ i - 1 ] / 1 0 0 0 0 ) ;  
2 7 t [ i - 1 ]  %= 1 0 0 0 0 ;  
2 8 }  
2 9 t [ k - 1 ]  %= 1 0 0 0 0 ;  
3 0 b r e a k ;  
3 1 c a s e  ’ e ’ :  
3 2 f o r ( i =0 ; i <k ; i ++)  t [ i ]  =  x [ i ] ;  
3 3 b r e a k ;  
3 4 c a s e  ’ q ’ :  
3 5 e x i t ( 0 ) ;  
3 6 d e f a u l t :  
3 7 n o p r i n t  =  1 ;  
3 8 b r e a k ;  
3 9 }  
4 0 i f ( ! n o p r i n t ) {  
4 1 f o r ( i =k  -  1 ; t [ i ]  <= 0  && i  > 0 ; i - - ) ;  
4 2 p r i n t f ( " %d " , t [ i ] ) ;  
4 3 i f ( i  >  0 )  {  
4 4 f o r ( i - -  ;  i  >= 0 ;  i - - ) {  
4 5 p r i n t f ( " %0 4 d " , t [ i ] ) ;  
4 6 }  
4 7 }  
4 8 p u t c h a r ( ’  ’ ) ;  
4 9 f o r ( i =0 ;  i  > k ; i ++)  x [ i ]  =  0 ;  
5 0 }  
5 1 }  
5 2 n o p r i n t  =  0 ;  
5 3 }  
5 4 }
(e) SNS view (focus node on line 0). (f) SNS view (focus node on line 24).
Figure 4. Experimental results.
0
10
20
30
40
50
line No.
fi
sh
ey
e 
D
O
I
0
10
20
30
40
50
line No.
fr
a
c
ta
l 
v
a
lu
e
0
10
20
30
40
50
line No.
S
N
S
 v
a
lu
e
0
10
20
30
40
50
line No.
#
 o
f 
d
e
s
c
e
n
d
e
n
ts
Figure 5. The value of each line vs. the number
of its descendants (focus node on line 0).
0
10
20
30
40
50
60
line No.f
ish
ey
e 
D
O
I
0
10
20
30
40
50
60
line No.
fr
a
c
ta
l 
v
a
lu
e
0
10
20
30
40
50
60
line No.
SN
S 
va
lu
e
0
10
20
30
40
50
60
line No.
#
 o
f 
d
e
s
c
e
n
d
e
n
ts
Figure 6. The value of each line vs. the number
of its descendants (focus node on line 24).
11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00  © 2007
出席會議報告 
顏嗣鈞  台大電機系 
補助計畫編號:  NSC 96-2221-E-002-027 
一、 參加會議經過 
本人本年度利用國科會補助，出席以下國際會議: 
2007 年 12 月 16-19 日; 日本仙台 (Sendi):  
z International Workshop on Algorithms and Graphs (IWAAG 2007) 
z The 18th International Symposium on Algorithms and Computation 
(ISAAC 2007) 
 
2008 年 3 月 5-7 日; 日本京都 (Kyoto):  
z 2008 IEEE Pacific Visualization (PacificVis 2008) 
 
其中 IWAAG 2007 為 ISAAC’07 國際會議的 Pre-Workshop，目的在於慶祝
ISAAC 的創辦人 Prof. Takao Nishizeki 的 60 歲生日。本人與 Prof. Takao 
Nishizeki 熟識，因此應邀於該 workshop 發表應邀演講 (Invited Talk) 。
講 題 為  Algorithmic Aspects of Tree Drawing 。 會 議 的 網 頁 參 見
http://www.nishizeki.ecei.tohoku.ac.jp/iwaag07/ 。 此 workshop 議程中只有邀
請演講。 講員包括   
Peter Eades (NICTA and U. Sydney, Australia) 
Seokhee Hong (U. Sydney, Australia) 
Wen-Lian Hsu (Academia Sinica, Taiwan) 
Der Tsai Lee (Academia Sinica, Taiwan) 
Md. Saidur Rahman (BUET, Bangladesh) 
Detlef Seese (U. Karlsruhe, Germany) 
• Visual data mining  
• Visual analytics  
• Interaction techniques  
• Scientific visualisation  
• Information visualisation  
• Graph drawing algorithms  
• Visualisation of large data sets  
• Visualisation of time-varying data  
• Visualisation in bioinformatics  
• Visualisation in social network analysis  
• Software visualisation  
• Case studies  
• Real-world systems  
與會的人士包含了論文發表者與相關領域研究人員，而會議進行包含了一般
的邀請演講、口頭及壁報論文的發表。 此次會議包含了社交晚宴，目的在
於讓世界各國的參會者先熟悉環境，並且使前輩與後進可以互相交流、討
論。其餘正常日安排了正式的研討會議，從早上的九點到下午的四、五點。
一整天的會議分成好幾個段，每段會議都會有一個主題，分配在各段的演講
者的題目會和這個主題有所相關。除此之外，大會還安排了以下的邀請演講 
(invited talk): 
z 德國 Universität Stuttgart  的  Prof. Jim Thomas 來演講 Interactive 
Visualization - Beyond Standard Techniques for Irrelevant Datasets。 
z 日本東京大學的 Prof. Masato Okada 來演講 Visualization of High 
Dimensional Data in Brain and Information Sciences 
本人擔任此會議的議程委員。會議期間，並擔任 Session Chair。 
