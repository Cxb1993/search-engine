行政院國家科學委員會專題研究計畫成果報告 
運用切割技術於驗證不可切割性之研究   
Verifying Atomicity using Chopping Analysis 
 計畫編號：NSC 94-2213-E-006-091        
執行期限：94 年 08 月 01 日至 95 年 10 月 31 日 
主持人：徐立群    國立成功大學會計學系 
          
shulc@mail.ncku.edu.tw 
 
一、中文摘要 
 
近年來確保同步程式碼能夠不被切割
的執行愈來愈受到重視。然而，驗證一組
methods 一定會不被切割的執行不是一件
容易的工作。本研究利用並改造資料庫領
域發展出之異動處理切割技術來驗證不可
切割性。我們所設計的方法較型態推論技
術產出較準確的結果，但較模式檢驗代價
為低。 
 
關鍵辭: 多執行緒、不可切割性、異動處理
切割、至多一次特性。 
 
Abstract 
 
Ensuring atomic execution for 
concurrent code segments is gaining more 
and more attention in the past few years. 
However, verifying that a set of methods 
always execute atomically is not an easy task. 
The work reported here makes use of and 
adapts a transaction chopping technique 
originally developed in the database area in 
verifying atomicity. The goal is to design a 
technique that produces more accurate results 
than those generated by type inference, and 
incurs less cost than those incurred by model 
checking. 
 
Key Words ： Multithread programs 、
Atomicity、Transaction Chopping、At Most 
Once Property. 
 
二、緣由與目的 
 
驗證多執行緒程式的正確性是一項相
當困難的工作，因為多執行緒可以有太多
不同的執行組合，吾人很難去考量所有可
能情形。然而如果一組多執行緒彼此有所
謂不可切割性(atomicity)，驗證的工作將大
大的簡化，這是因為 atomicity 代表一組
多執行緒雖然同步執行，效果卻與順序
(sequential)執行相同。因此對一組 atomic
執行的多執行緒，我們僅需要驗證每一執
行緒是否符合其 specification，而無需考量
多執行緒間可能產生之干擾，因此大大簡
化驗證工作之困難度。 
Atomicity 在資料庫領域稱為 isolation
或 serializability，有許多成熟之技術被發展
出來，本計畫與九十二年度之計畫⎯「並
行程式分析與並行控制」，以及九十三年
度之計畫⎯「植基於切割技術之程式分析」
即是探討源自於資料庫之異動處理
(transaction)切割技術，如何可以正確並合
理代價用來驗證多執行緒之 atomicity 特
性。 
 
三、結果與討論 
 
利用並行技術來滿足系統需求在軟體
設計上可說是相當普遍。在過去，「軟體
分析」與「資料庫系統」兩大領域各自進
行並行技術相關課題的研究，甚少有交
集。前者稱此項研究為「並行程式分析」，
而後者稱為「並行控制」。值得注意的是
 2
們的 chopping graph 沒有 SC-cycle 的話，
則每一個 method 皆是 atomic。 2. 我們克
服了一個應用 chopping analysis 難題：一個
Java method 可以同時被許多其它 thread 
invoke，我們無法在 chopping graph 中對每
一個 method 繪製無限多 instance。我們證
明了以下的定理： In doing chopping 
analysis, each method needs at most two 
instances to be represented in the chopping 
graph. 3. 探討如何在 chopping graph 中表
示 typical program constructs，如 conditional 
branches，loop iterations，procedure calls
與 recursions 等。 4. 探討如何 summarize 
effects of processes. 5. 撰寫工具程式針對
Java library classes 進行 atomicity 分析。 
 
由於前兩年計畫成果漸臻成熟，我們繼
之提出九十四年度的計畫⎯「運用切割技
術於驗證不可切割性之研究」。我們解決
了 chopping analysis 應用於驗證 Java 
method 之剩餘但依然重要的課題，同時進
行了廣泛的實驗評估。除了前述已有結果
外，本年度新的成果為：1. Representing 
typical program constructs in the chopping 
graph：我們確定了如何在 chopping graph
中表達 conditional branches, loop iterations, 
procedure calls 等 常 見 的 program 
constructs. 
2.將理論結果納入 chopping analysis工具程
式之撰寫，着手進行廣泛實驗評估。我們
已經跟另一頗受學術界重視的方法 type 
system approach [4,5]作了比較。我們發覺
chopping analysis 較 type system 分析為準
確，一些 chopping analysis 確認為 atomic
的 examples ， type system 卻 錯 認 為
non-atomic，亦即發出了 false alarm。這是
因為 type system 是屬於 local analysis，為
了避免錯誤，它只能做較保守的推估。反
之 chopping analysis 屬於 global analysis，
因此較可以看到全貌。當然 global analysis
付出的分析代價一定比 local analysis 為
大，不過 chopping analysis 用到一些 good 
property，使其分析的 cost 相當合理。3. 除
了驗證 Java library classes，我們也針對其
它相關論文所使用的實例做驗證，得到了
正面的結果。 
 
四、計畫成果自評 
本計畫最重要的目標是研究結果必須
具有實用價值，因此進行之工作除了包含
理論的推導與原則的分析，我們也探討推
導出之理論與原則應用在目前主要並行軟
體案例時，所獲得實際效益有多大。 
利用並行物件導向語言如 Java 所撰寫
之並行程式，要推論其正確性時，必須考
量指令間之交錯執行，這個問題一直是研
究人員認為極富挑戰之議題。Atomicity 是
建構並行程式之重要根基，當一個 Java 
method 被驗証為 atomic 後，則該 method
與其它method任何交錯執行的結果與沒有
任何交錯執行之結果相同。這意味我們推
論一個 atomic method 之正確性時，可將其
看成一段 sequential 程式碼，驗証的複雜度
將大為降低。我們經過三年的研究，克服
將 chopping analysis 運用到程式分析的一
些關鍵問題，實驗結果也看出這個方法的
潛力。我們目前正在將成果整理並將投稿
至適當的會議。 
另外，我們也在發展 compositional 
chopping analysis 之技術，chopping graph 
analysis 是一種以單一分析步驟來廣域分
析所有的的程式中的 process。如果當
 4
出席國際學術會議心得報告 
                                                             
計畫編號 NSC 94-2213-E-006 -091 
計畫名稱 運用切割分析於驗證不可分割性之研究 
出國人員姓名 
服務機關及職稱
徐立群 
國立成功大學會計學系 
會議時間地點 
2006 年 8 月 30 日至 2006 年 9 月 1 日 
Grand Canyon, Arizona 
會議名稱 第十二屆分散式多媒體系統國際會議出國報告 
發表論文題目 Frame Dropping Control by Video Content Characteristics under Limited Bandwidth 
 
 
一、參加會議經過 
多媒體應用在我們日常生活愈來愈普遍，包括隨選視訊、視訊監控、影像電
話與即時新聞等。然而建構多媒體應用系統依然有許多問題待解決。本會議主要
專注在分散式多媒體系統 (distributed multimedia systems) 之相關技術、理論，
與應用，它提供學界與產業界分享最新研究成果很好的平台。主要的議題包括: 
audio and video compression, MPEG, Quicktime, Windows API standards, image, video, 
audio content analysis and indexing/retrieval, image, video and audio watermark, 3D audio 
and video, computer graphics and animation, modeling and analysis of distributed 
multimedia systems, OS support for distributed multimedia systems, distributed 
multimedia databases and computing, Large Real-Time Multimedia Systems, Human-GIS 
interaction,  Media Streaming , Multimedia Representation and Indexing.  
本次會議已是DMS的第十二屆，參加的學者來自全球有美國、義大利、日本、
印度、南韓、中國與台灣等國，主要以美國與亞洲居多，這個會議投稿的接受率
在近 4 年都維持在 50%以下，並具有獨立審查制度確保其論文品質，三天的會議
除了DMS主題外，還包含Visual Languages and Computing, Mobile Systems，
的video編碼標準，是由ITU-T視頻編碼專家組（VCEG）和ISO/IEC運動圖像專家
組（MPEG）聯合組成的聯合視頻組（JVT，Joint Video Team）提出的高度壓縮數
位視頻編解碼器標準。而H.264 較現存已知的video編碼標準省下 50%的bit-rate，
但是需要額外的計算複雜度，而此篇提出一motion detection 演算法可以減少寫
入時間，其目的是依本篇提出的motion detection 演算法為基礎，結合ISO/IEC於
H.264 提出的 1/4 pel displacement resoiution 技術。 
DMS session I-B 是有關於 Wireless Networking 的議題，其中一篇名為“An 
Evaluation of Two Policies for Placement of Continuous Media in Multi-hop Wireless 
Networks,” 由 Shahram Ghandeharizadeh, Tooraj Helmi, Taehee Jung, Shyam 
Kapadia, Shahin Shayandeh 合著。本篇著墨在網狀網路的點對點設施下，對於
stream continuous 多媒體，audio、video clip 的 greedy data 置換策略。此 greedy data
置換策略，是要最大化被本地端服務的參照(reference)數目，作者分析二種方法
來實現此策略，分別為 frequency-based 和 byte-hit。此二種方法擁有相同的複雜
度和幾乎相同的建置，根據模擬的結果，byte-hit 比 frequency-based 表現的好，
其理由有二個，第一它可以最大化同時展現參照的 clips 的數目，第二它在存取
經常性上的表現有較低的錯誤，就我們研究來說，byte-hit 可以說是最佳的 greedy 
data 置換策略。 
本人所發表的論文被安排在第二天下午 3:15 DMS session VI，主題為
“Frame Dropping Control by Video Content Characteristics under The Limited 
Bandwidth＂。目前較先進的多媒體視頻編碼為 MPEG-4 (H.264)，主要是以呈
現虛擬世界的影像處理為目標的技術，MPEG-4 規格將目標放在多種不同的傳
輸架構（區域存取，遠端互動，廣播及多點傳輸）及其資料傳輸技術。但考量
網路傳送的不確定性和頻寬的受限制性，如何在不影響播放的品質前提下
(Quality of Service)，可針對特定的視訊框(frame)採取捨棄的方法，是我們此次
發表論文的主要焦點。 
DMS session VI 另一篇論文名為“Packet and Frame Rate Control Methods 
色，有賴年輕有潛力的學者持續投入，並能作出夠份量的作品。另外更多國內產
官學研界的一同投入，才能在此重要領域達到國際領先的地位。 
 
frame rate when the bandwidth is not sufficient for transmitting
all the packets. Our scheduling algorithm will dynamically
control frame dropping by our weighted assignment scheme
for the MPEG-4 FGS framework.
The paper is organized as follows. Section 2 presents the
related work. Section 3 states our system model and problems.
We make use of the unit time tasks scheduling algorithm
to solve the problem for maximizing total weights including
the packets of the base layer in Section 4. Results of the
experiment are shown in Section 5. The conclusions are drawn
in Section 6.
II. RELATED WORKS
A network with limited bandwidth may not be able to
deliver all the multimedia requests and fulfill all the QoS
requirements. The dropping policy adopted by most research
drops some data packets in order to satisfy the schedula-
bility requirements. The dropping mechanism saves up the
bandwidth utilization to satisfy the requests with the real-
time constraints [6], [7], [8]. These researchers discover that
discarding the frames of incurring peak rate can save the
bandwidth.
Furini and Towsley[6] propose several frame dropping
mechanisms to reduce bandwidth consumption subject to a
QoS constraint. The proposed algorithms are evaluated by
the JPEG and MPEG videos under the proposed bandwidth
allocation mechanism.
Zhang et al.[7] propose an efficient selective frame discard
algorithm for stored video delivery across resource constrained
networks. They attempt to minimize the discarded frames to
meet the constraints in JPEG videos.
Besides, reducing the frame rate can also save the bandwidth
utilization. Pejhan et al.[9] propose a dynamic frame rate
control mechanism. The scheme is to encode and store the
sequence at different frame rates. It stores only the motion
vectors for the lower frame rates, but this will take up a lot of
space on the server. This way all motion estimation is done
off-line. When re-encoding, motion vectors can be read from
the motion files instead of being computed. The advantage
of the scheme is that the motion files are much smaller
than the corresponding compressed streams. The dynamic
frame rate control, used in conjunction with dynamic bit-rate
control, allows clients to solve the rate mismatch between the
bandwidth available to them and the bit-rate of the pre-encoded
bitstream.
Song and Chun[10] present a virtual frame rate control
algorithm and a bit allocation algorithm at frame level for
efficient MPEG-2 video encoding. The proposed frame rate
control scheme is composed of three steps. At the first stage,
the scan format of an input video sequence is converted
into progressive scan format before video encoding. At the
second stage, an average motion activity of the frames within
a previous temporal window of a pre-defined size is examined,
and a proper frame rate of a current temporal window is
adaptively determined based on the computed average motion
activity. At the final stage, the frames located at particular
positions in a current temporal window are virtually skipped
according to the determined frame rate. The scheme can skip
the selected frames by deliberately fixing the coding types of
all the macroblocks in those frames to skipped macroblocks.
Chan et al.[11] propose a structured Rate-Quantization base
rate-control framework for low-delay video coding which con-
tains three processing stages: the control of encoding frame-
rate, bit-allocation for frame-level and the decision of quan-
tization parameters for macroblock-level. At the first stage,
the proposed framework decides the encoding frame-rate per
group of pictures (GOPS) for better motion continuity. At
the second stage, target-bit per frame is effectively estimated
with the frame texture and buffer fullness. At the final stage,
based on an adaptive Rate-Quantization model modified by
the Kalman filter for each cluster of macroblocks, a suitable
quantization parameter of each macroblock can be confirmed.
Song et al.[12] propose a new H.263+ rate control scheme
which supports the variable bit rate (VBR) channel through
the frame rate adjustment. In particular, a fast realization
of encoding frame rate control based on motion information
within a sliding window is developed to efficiently determine
the tradeoff between spatial and temporal qualities.
Yang and Hemami[13] propose a frame rate-control scheme
with a MINMAX distortion criterion in the framework of a
rate-distortion (RD) optimized motion compensated embedded
wavelet coder. The MINMAX criterion aims to minimize
the maximum distortion in a group of pictures (GOP) for
a given bit rate. The proposed frame level bit allocation
scheme combined with RD optimized within frame allocation
allows precise rate control up to the exact bit. A simplifying
fast algorithm is developed using an initial prediction of
the operating distortion and adaptive adjustment during GOP
coding.
Lee and Kim[14] propose an adaptive video frame rate
control method for the network of time-varying rate channel
with explicit rate feedback. It consists of a prediction module
of future channel rate and an adaptive frame discarding and
skipping module. They derive an encoder buffer constraint
which guarantees an end-to-end delay bound of video frames.
Recursive Least-Squares(RLS) method is used as a tool to
predict the low frequency component of channel rate. The
adaptive frame discarding method prevents delay violation of
frames due to the channel rate prediction error. Also, the frame
skipping method adapt the encoder output rate to the channel
rate while keeping the constant level of video quality.
III. SYSTEM MODEL
A. System Model
Our system model based on MPEG-4 FGS framework is as
Fig. 1. The hybrid temporal-SNR scalability with an all FGS
structure supports both the temporal and the SNR scalabili-
ties through a single enhancement layer[1]. Each multimedia
streaming is made up of encoded frames such as Intra frame (I
frame), Bidirectional frame (B frame) and Predicted frame (P
frame). At the encoding time, the frame is coded using DCT
for compressing the base layer and the enhancement layer.
IV. SCHEDULING ALGORITHM
A. The weighted assignment scheme
According to the prior information of the characteristics
for the sequences, we can assign the weight to packets so
as to control the frame dropping during the transmission. For
example, we assign the weight to the packets of the frames
shown in Fig. 5 when the sequence prefers 20 fps during
some consecutive frames. The smaller number represents the
higher priority. To illustrate the scheme, we consider 12 frames
as a GOP and denote 6 frames as a half of GOP, called
the HGOP. Then, 30 frames are divided into 5 HGOPs. Our
original frame rate is set to 30 fps, so the number of the
decoded frames is usually 20 fps if drops 2 frames per HGOP.
When the bandwidth is not sufficient for transmitting most of
data, the packets of the lower priority are always dropped.
Therefore, the scheme can control the frame rate according to
drop frames. Based on the weighted assignment scheme, the
frame rate can be controlled by 30, 25, 20, 15, and 10 fps if
drops 0, 1, 2, 3, and 4 frames per HGOP, respectively.
Fig. 5. The weighted assignment scheme for the preference of 20 fps
B. Satisfying the schedulability of the base layer
To solve the packets schedule problem, we employ a known
scheduling algorithm, called the unit time tasks scheduling.
The problem of scheduling unit time tasks with deadlines and
weights has the following inputs: a set T = T1, T2, . . . , Tn
of n unit-time tasks; A set of n integer deadlines such that
each di satisfies 1 ≤ di ≤ n ; And a set of n nonnegative
weights w1, w2, . . . , wn such that wi is offered for task Ti
only if it is finished before the time di. This well-defined
problem can find a schedule for T that maximizes the total
weight and meets deadlines. This has been proved using the
greedy algorithm of running time O(n2) to find the optimal
schedule [15]. Table I shows an example of the unit time tasks
scheduling. We use the unit time tasks scheduling algorithm
to get the optimal schedule. Therefore, we can select tasks
1, 2, 3, 4 and 6 according to the algorithm, and then reject
task 5. This optimal schedule has a total weight of 275.
Table I. An example for the unit time tasks scheduling
task i 1 2 3 4 5 6
di 4 2 4 3 1 5
wi 80 70 60 50 40 15
However, our problem is both to maximize the total weight
and to satisfy the schedulability of the base layer. We define
the problem as follows.
Problem 1. Follow the above definitions, we consider that
the set of tasks is classified into the mandatory set of tasks and
the optional set of tasks. This problem is to find a schedule
including all the mandatory tasks for T that maximizes the
total weight and meets deadlines.
We make use of the unit time tasks scheduling algorithm
to solve Problem 1 by the theorems which have been proved
in our previous study[5]. Therefore, the set of the optimal
solution, S, found by the algorithm including the given set M
if there exists at least a solution including the given set M and
the weights of all the elements in M is added by a constant y.
This problem is proved in Theorem 1. We define a new set T ′
based on the set T . The weights set T ′ is similar to the weights
set T except that the weights of all the elements in a given
set M , M ⊆ T , are added by a constant y where y is defined
as
∑
t∈T
W (t) . The weight of tasks in M can be expressed as
W ′(t) = W (t) + y, if t ∈M , and W ′(t) = W (t), otherwise.
Secondly, Problem 1 for the set T is equivalent to Problem
1 for the set T ′ in Theorem 2. This means OPT ′ = OPT +
y ∗ |M | where OPT ′ and OPT are an optimal solution for
Problem 1 in the set T ′ and T , respectively.
Finally, Problem 1 for the set T ′ is equal to Problem 1 in
Theorem 3. Therefore, according to Theorem 2 and 3 under
the condition that there exists at least a solution including the
given set M , this optimal solution of Problem 1 in the set T is
equal to subtract a constant value, y ∗ |M |, from the solution
of Problem 1 in the set T ′.
Theorem 1: A set of the optimal schedule solution, S,
found by the algorithm for the set T ′ exist that the given set
M is belong to S if there exists at least a solution including
the given set M in the set T .
Theorem 2: Problem 1 for set T is equivalent to Problem
1 for set T ′, where W ′(t) = W (t) + y if t ∈ M otherwise
W ′(t) = W (t).
Theorem 3: The unit time scheduling problem for the set
T ′ is equal to Problem 1 for the set T ′.
Theorem 4: The unit time scheduling problem for the set
T ′ is equivalent to Problem 1 for the set T .
V. EXPERIMENT RESULTS
In our experiments, we use the Microsoft MPEG-4 software
encoder/decoder with FGS functionality[16]. We encode the
videos using 30 frames per second with the CIF(352×288 pix-
els) format. Every sequence has 300 frames, then the encoded
stream of a frame is divided into hundreds of tasks(packets).
The data size of each task is set to 64 bytes. The videos are
processed in the Y UV format(Y is the luminance component,
U and V are color components of a frame). The test sequence
after encoding and scheduling under the limited bandwidth is
made up of the truncated encoded file. We compute the PSNR
of luminance for each test sequence. The sequences employed
in our evaluation are well-known MPEG-4 test sequences.
