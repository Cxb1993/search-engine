2a number of keys that are randomly selected from a large key
pool. After deployment, two neighbors can establish a secure
communication if they share a common key. Otherwise, they
need to exchange a secret key via a multi-hop secure path.
Reference [2] extended the technique into q-composite random
key establishment technique which forces two neighbors to
establish a secure communication only when they share q
common keys, where q ≥ 2. Based on [1], two similar random
key pre-distribution techniques that used multi-space key pool
to improve network resilience and memory usage efficiency
were developed independently in [3], [4].
A multi-path key reinforcement technique was proposed
in [2] to enable two nodes to establish secure communication
even if they do not share enough common keys (with the use of
the q-composite technique). These two neighbors first identify
all secure paths between themselves. Then one node generates
a set of random numbers (of the same size) for all the paths and
send one number to the other node through each of the paths.
After the destination receives all the numbers, it exclusive-ORs
all of them to obtain the secret link key. The multi-path key
reinforcement scheme significantly improves the protection of
the secret link key from being disclosed to the adversary.
This scheme takes care of only information disclosure to the
adversary but not information modification. It fails if any of
the paths is compromised by the adversary and the number is
modified or dropped.
In [8], [9], combinatorial set was used to distribute keys
to sensors prior to deployment. Such a deterministic combi-
natorial set technique allows each key in the key pool to be
assigned to a constant number of sensor nodes. Therefore, the
number of nodes that each sensor shares a common key is
fixed.
A Secure Routing Protocol (SRP) was proposed in [10]
to send additional information to protect routing information
from being dropped. To combat the problem of topology
instability in wireless networks, a multi-path routing scheme
was proposed and investigated in [11]. The scheme allows
the sender to add extra overhead to each packet that is to be
transmitted over multiple paths. The goal is to find the optimal
way to fragment the packet into smaller blocks and deliver
them over multiple paths. The focus of [10], [11] is on the
problem of missing some of the messages but not modification
of them.
In [12], an efficient information dispersal mechanism was
developed to provide security, load balance, and fault tol-
erance for communication networks. The mechanism uses
Reed-Solomon codes to recover link faults and to provide
security. In this technique, all redundancy is sent along with
the information symbols, increasing transmission overhead
significantly.
Reed-Solomon codes were used in a similar way for the
key establishment of wireless sensor networks by Huang and
Mehdi [13]. The technique was proposed to combat Byzantine
attacks on the multi-hop paths. With the use of the (n, k) Reed-
Solomon codes, the proposed scheme is resilient to t = (n−
k)/2 faulty paths, which may drop or alter the information sent
through. Furthermore, the receiver can identify faulty paths as
long as their number is not greater than t. In this scheme,
k(2t + 1) symbols need to be transmitted, limiting its appli-
cations of Reed-Solomon codes for large k or t.2 Compared
with the work by Huang and Mehdi [13], our scheme employs
an efficient incremental information transmission technique
that lowers the expected overall overhead significantly and it
can also be performed with RS codes of large k or large t.
Extra symbols are transmitted only when they are necessary.
We argue that, with the source and the destination being
direct neighbors, the cost of acknowledgment transmission
is low. We further take advantage of the fact that different
paths have different probability of being compromised or
becoming faulty. Therefore, different amounts of symbols are
sent through paths of different lengths in the JERT scheme.
MDS codes have been used in the Automatic-Repeat-
reQuest (ARQ) protocols to reduce the transmission overhead
on communication systems [16], [17]. In [16], Reed-Solomon
codes were used in a type-II hybrid ARQ protocol. In the first
transmission, a relatively high rate Reed-Solomon code with
fewer redundancy is used. When an additional transmission
is needed, only the redundant symbols are sent. With such
a technique, the overall code rate is reduced. This scheme
increases the system throughput by reducing the transmission
overhead. In [17], punctured MDS codes were used for the
type-II hybrid ARQ protocol and a modified version (with
fewer decoding operations) of the scheme proposed in [16]
was presented.
III. PROBLEM FORMULATION
We explain the link key establishment problem in WSNs in
more details in this section. The key pre-distribution schemes
such as [1], [3], [4], [18] provide memory-efficient and re-
silient ways to establish secret link keys for a fraction of
potential communication links. The rest of the communication
links need to establish their secret keys by other means such
as multi-hop delivery.
S
T
B
A
C F
E
D
G
Fig. 1. Illustrations of multi-hop key establishment.
A few sensor nodes are shown in Fig. 1. Each line segment
connecting two nodes represents that these two nodes share at
least a common key, e.g., nodes E and F share at least a key.
Note that nodes S and T do not share any common key. Now
2The (n, k) codes are used to share secrets among n users, any k of which
can recover the secret cooperatively. Shamir’s scheme [14] is one of such
schemes. As pointed out in [15], a Reed-Solomon code may be treated as a
special (n, k) secret-sharing scheme with tamper-resistant capability because
it can correct errors. Also pointed out in the same work, the complexity of the
decoding algorithm of the Reed-Solomon code is similar to that of Shamir’s
scheme.
4MDS codes are optimal in the sense that they provide the
largest possible minimum Hamming distance between code-
words and hence can correct most number of errors. The
most famous family of MDS codes are Reed-Solomon (RS)
codes. Efficient decoding algorithms for MDS codes have been
studied extensively in [19], [20]. In the following, we give a
brief description of the encoder and the decoder of RS codes.
Let GF (2τ ) be the finite field of order 2τ such that each
element in GF (2τ ) can be represented by τ bits. An (n, k)
RS code is a linear code, where each symbol is in GF (2τ ),
with following parameters:
n = 2τ − 1
and
n− k = 2t ,
where n is the total number of symbols in a codeword, k is
the total number of information symbols, and t is the symbol-
error-correcting capability of the code. Let the sequence of k
information symbols in GF (2τ ) be m = (m0,m1, . . . ,mk−1)
and m(x) be the information polynomial of m represented as
m(x) = m0 +m1x+ · · ·+mk−1xk−1 .
The codeword polynomial, c(x), corresponding to m(x) can
be encoded as
c(x) = m(x)g(x) ,
where g(x) is a generator polynomial of the RS code. It is
well-known that g(x) can be obtained as
g(x) = (x+ β)(x+ β2) · · · (x+ β2t)
= g0 + g1x+ g2x2 + · · ·+ g2tx2t , (1)
where β is a primitive element in GF (2τ ) and gi ∈ GF (2τ ).
Note that g(x) has β, β2, . . . , β2t as roots.
Another way to encode c(x) is to use polynomial division
as
c(x) = x2tm(x) + p(x) ,
where
p(x) = x2tm(x) mod g(x) .
Since each symbol is represented by τ bits, an (n, k) RS
code can be expanded to an (τn, τk) binary linear block code.
For example, a (1023, 255) RS code with 384 symbol-error-
correcting capability is of 10× 255 = 2550 information bits.
The computational cost of the encoder is roughly k(n − k)
additions and k(n− k) multiplications.3
The decoding processes of RS codes are more complex.
Let r(x) be the received polynomial and r(x) = c(x) + e(x),
where e(x) =
n−1∑
j=0
ejx
j is the error polynomial. Since g(x)
(and hence c(x)) has β, β2, . . . , β2t as roots, the syndromes
Si can be calculated as
Si = r(βi) = e(βi) =
n−1∑
j=0
ejβ
ij for i = 1, . . . , 2t . (2)
3The addition and multiplication are performed on GF (2τ ) which can be
implemented by table look-up method.
Assume that v ≤ t errors occur in unknown locations
j1, j2, . . . , jv of the received polynomial. Then
e(x) = ej1x
j1 + ej2x
j2 + · · ·+ ejvxjv ,
where ej` is the value of the `-th error, ` = 1, · · · , v. The
decoding process is to find all j` and ej` . Instead of solving
the set of the above 2t syndrome equations, an intermediate
polynomial, called error-locator polynomial, is introduced as
Λ(x) =
v∏
`=1
(1− xβj`) = 1 + Λ1x+ · · ·+ Λvxv .
The coefficients of error-locator polynomial can be determined
by the Berlekamp-Massy algorithm or Euclid’s algorithm that
are of time complexity O(t2) [19]–[21]. Once all coefficients
of the error-locator polynomial are found, βj` can be deter-
mined by successive substitution through Chien search [21].
Finally, ej` can be calculated by the Forney’s formula [21].
Each of the RS decoding processes can be implemented in
either hardware or software. Hardware implementations with
moderate/high speed but small/large hardware have been pro-
posed [19]–[21]. Software implementation of the RS decoding
process can be programmed on a general-purpose processor
[21]. The first step in the decoding of an RS code is to
compute the 2t syndromes. Combining with Horner’s rule,
this step requires (n − 1)t additions and nt multiplications.
Finding the coefficients of error-locator polynomial requires
roughly 2t2 additions and 2t2 multiplications. In the worse
case, Chien search needs to substitute n field elements into the
error-location polynomial of degree t to determine its roots.
This requires nt multiplications and nt additions in software
implementation. The computational complexity of Forney’s
formula calculation, the final step of the decoding process,
is similar to that of finding the coefficients of error-locator
polynomial. In total, (2n− 1)t+ 4t2 additions and 2nt+ 4t2
multiplications are needed to complete the decoding process.
When the table look-up technique is implemented, the
additions and multiplications on GF (2τ ) have roughly the
same complexity. Let β be a primitive element of GF (2τ )
and all elements in this field can be expressed as powers of β.
Each multiplication calculation takes modular addition of two
exponents on 2τ − 1. The addition calculation is implemented
by Zech’s logarithms [22] and takes one subtraction, one mod-
ular addition on 2τ − 1 and one memory access. The memory
usage is then τ2τ bits to implement Zech’s logarithms. For
GF (210) used in our simulations, the memory required is only
1.25 kilobytes.
The MDS codes have several nice properties that make
them very useful. Two of such properties are given as follows
without proof.
Property 1: Punctured (shortened) MDS codes are MDS.
A code is punctured when some parity symbols are deleted
from each codeword in the code. Similarly, a code is short-
ened when some information symbols are deleted from each
codeword in the code. For instance, an (n, k, n−k+1) MDS
code can be punctured (shortened) to an (n−j, k, n−j−k+1)
((n−j, k−j, n−k+1)) MDS code by deleting j corresponding
parity (information) symbols from each codeword.
6D. Multi-hop Paths
Before we present our analysis of the JERT scheme, we
discuss the path selection process and its effect on the perfor-
mance of the JERT scheme. In this report, we assume that a
source node identifies m multi-hop paths between itself and
the destination. Such m paths could be chosen from the node-
disjoint paths, in which none of the multi-hop paths shares any
common node other than the source and the destination [23]–
[25]. Another option is to allow the source node to randomly
select among all available paths. The result is that some paths
may have common nodes and thus the security performance
worsens. The benefit of such a selection technique is that it
does not rely on the availability of node-disjoint multi-hop
paths and eliminates the cost of identifying such paths.
As suggested by Chan et al. [2], it is always beneficial to
choose short multi-hop paths instead of long multi-hop paths.
As the length of a multi-hop path increases, the possibility
of path compromise is higher. As we limit ourselves to short
multi-hop paths, however, the number of available paths may
be limited. We evaluate the values of m under various network
conditions and the effect of such m paths on the security
performance of our scheme in Section VI. The proposed JERT
scheme works with any set of multi-hop paths and node-
disjoint multi-hop paths.
V. ANALYSIS
In this section, we derive formulas for the fractions of
symbols to be transmitted through each path, qj , 1 ≤ j ≤ m,
and the number of additional symbols to be transmitted in
each round, ri, 0 ≤ i ≤ e, for the JERT scheme. We
will also investigate three performance aspects of the JERT
scheme and the SP scheme, which sends the secret link key
through a single multi-hop path: secret information disclosure,
transmission overhead, and computation overhead.
A. Selection of q1, q2, . . . , qm
Due to the lack of the knowledge of which paths may be
compromised, the source node has the following best option:
make sure that the expected number of symbols compromised
on each path is more or less the same.
Let hj be the hop-count of path j, 1 ≤ j ≤ m, and x the
probability of nodes being compromised. Then the probability
that path j is compromised, given that the source and the
destination are not compromised,7 is
Pr[at least one router in between is compromised|
source and destination are not compromised]
= Pr[at least one router in between is compromised]
= 1− Pr[none of the routers is compromised]
= 1− (1− x)hj−1 ,
where 1 ≤ j ≤ m.
The expected number of symbols being compromised for
path j is
qj · [1− (1− x)hj−1]
7A compromised source or destination makes the key exchange meaning-
less.
and the source node needs to make sure that
qj · [1− (1− x)hj−1] = C for all j . (4)
Since
∑m
j=1 qj = 1, the constant C should satisfy
C =
1
m∑
i=1
1
1− (1− x)hi−1
.
When x is small, 1− (1− x)hj−1 may be approximated as
1− (1− x)hj−1 ≈ 1− [1− (hj − 1)x] = (hj − 1)x .
Therefore, C becomes
C ≈ xm∑
i=1
1
hi − 1
,
and we have
qj ≈ C(hj − 1)x =
1
hj−1
m∑
i=1
1
hi − 1
. (5)
Thus, we have derived a closed form for qj , 1 ≤ j ≤ m,
that is unrelated to x, when x¿ 1.
B. Selections of r1, r2, . . . , re
The values of r1, r2, . . . , re can be determined as follows. In
order to reduce the total number of symbols to be transmitted,
in each transmission we should add as little as possible redun-
dancy that can correct errors due to one more compromised
path.
In general, when one round of the JERT scheme fails, the
next round of transmission should provide the receiver just
enough symbols so that it can correct the errors due to one
more compromised path. In our JERT scheme, however, each
path transmits different amount of symbols. While providing
better security performance, such a transmission technique
makes the determination of r1, r2, . . . , re rather complex.
In this subsection, however, we determine r1, r2, . . . , re
with the help of the average number of the symbols transmitted
on all routes. Thus, we assume that, in the next round of trans-
mission, each route carries the same amount of information.
This makes our analysis tractable. In Section VI, we will show
the effectiveness of our simplified model.
Let qavg be the average value of qj , 1 ≤ j ≤ m. Since∑m
j=1 qj = 1, we have
qavg =
1
m
. (6)
In the following, we derive a set of r1, r2, . . . , re such that,
when up to i − 1 rounds of transmission fail to allow the
receiver to regenerate the secret link key, the i-th round of
symbol transmission corrects the errors caused by one more
path, 0 < i ≤ e.
8compromised, nj2 paths of length j2 compromised, · · · , njg
paths of length jg compromised. Then we need to consider
all possibilities to select xc compromised nodes from xn =∑g
i=1 nji(ji− 1) nodes on the mx compromised paths. Since
all these mx paths are compromised, at least one node on each
path must be compromised. Hence,
Pr[Dn2,...,nL |Bxc ∩ S]
=

∑
y1,1+···+y1,nj1
+y2,1+···+y2,nj2
+···
+yg,1+···+yg,njg =xc
∏g
i=1
∏nji
`=1 (ji−1yi,` )
(nTxc )
if xn ≥ xc
0 otherwise
(17)
where 1 ≤ yi,` ≤ ji − 1 for 1 ≤ i ≤ g.
We now derive the secret disclosure probability, px, which
is defined as the probability of disclosing enough symbols to
the adversary so that it can obtain the key with relative ease
when node compromised probability is x.
In the SP scheme, the γ symbols are transmitted through
one randomly chosen path among the m available paths. If the
SP scheme selects a compromised path to transmit, then all γ
symbols are revealed. Hence, when there are mx compromised
paths, the secret disclosure probability is mx/m. The overall
secret disclosure probability can be calculated as
p(SP )x =
∑
S
{
Pr[Ps2,s3,...,sL ]
nT∑
xc=1
[(
nT
xc
)
xxc
·(1− x)nT−xc
m∑
mx=1
(
Pr[Amx |Bxc ∩ S]
mx
m
)]}
(18)
where nT is given by (14).
When the JERT scheme is used, the source transmits only
r0 = k symbols and the destination gets all of these symbols
successfully because no information is modified. Such k
symbols are transmitted through the m paths with qj fraction
for path j, 1 ≤ j ≤ m, where qj is given by (5). For a fair
comparison between the JERT scheme and the SP scheme, we
define the secret disclosure probability of the JERT scheme as
the probability of at least αk symbols being disclosed to the
adversary, where 0 < α ≤ 1. Therefore, the secret disclosure
probability can be calculated as
p(JERT )x
=
∑
S
Pr[Ps2,s3,...,sL ]
{
nT∑
xc=1
(
nT
xc
)
xxc(1− x)nT−xc[
m∑
mx=1
Pr[Amx ∩ Eα|Bxc ∩ S]
]}
, (19)
where Eα is the event that the fraction of symbols transmitted
through the compromised paths are greater than or equal to α
and is given by
L∑
i=2
niqi
L∑
i=2
siqi
=
L∑
i=2
ni
i− 1
L∑
i=2
si
i− 1
≥ α . (20)
Pr[Amx ∩ Eα|Bxc ∩ S] is given as
Pr[Amx ∩ Eα|Bxc ∩ S] =∑
n2+n3+···
+nL=mx
Eα
L∏
i=2
(
si
ni
)
Pr[(Amx ∩Dn2,...,nL |Bxc ∩ S] ,
(21)
where 0 ≤ ni ≤ si for 2 ≤ i ≤ L. Note the additional
condition of Eα in (21) compared to (16).
The value of α depends largely on how the γ symbols of the
secret link key information are encoded into the k symbols.
Therefore, it depends on the selection of function f in the
scheme.
D. Transmission Overhead
In this subsection, we reuse some of the analysis in Sec-
tion V-C to evaluate the transmission overhead (cost) of the
JERT and the SP schemes. We assume that all compromised
nodes modify the symbols passing through in our analysis in
this section.
For the SP scheme, only the mxm term in (18) needs to
be modified in order to derive the transmission overhead.
When there are mx out of m paths that are compromised, the
chance of successful transmission in the first round is m−mxm .
The chance of successful transmission in the second round
is m−mxm−1 · mxm (recall that the sender randomly picks a path
other than the failed path). The process continues until either
the transmission becomes successful or all paths are found to
be compromised. The expected extra number of transmitted
symbols given m and mx is then
δ(SP )(m,mx) = [1− 1(mx < m)] · γ · (m− 1) +
1(mx < m) · γ ·
mx+1∑
i=1
(i− 1) · m−mx
m− (i− 1) ·
j=i−2∏
j=0
mx − j
m− j
 , (22)
where 1(mx < m) returns 1 when the condition mx < m is
true, and 0 otherwise.
So the expected number of transmitted symbols of the SP
scheme is
δ(SP ) = γ +∑
S
Pr[Ps2,s3,...,sL ]
{
nT∑
xc=1
(
nT
xc
)
xxc(1− x)nT−xc ·[
m∑
mx=1
Pr[Amx |Bxc ∩ S]δ(SP )(m,mx)
]}
, (23)
where nT is given by (14), Pr[Amx |Bxc ∩S] is given by (16),
and δ(SP )(m,mx) is given by (22).
For the JERT scheme, a failed i-th, 1 ≤ i < e, transmission
leads to additional ri symbols to be transmitted. In order
to simplify our analysis, we assume that, when a path is
compromised, the average number of symbols are modified
(instead of the qj fraction of symbols transmitted through the
path in the current round). Such a simplification makes our
analysis tractable while maintains its validity.
10
0.3 0.35 0.4 0.45 0.5 0.55 0.6 0.65 0.7 0.75 0.8
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Local connectivity, plocal
Pr
ob
ab
ilit
y 
of
 fi
nd
in
g 
se
cu
re
 p
at
h,
 p
s
1−hop path
up to 2−hop paths
up to 3−hop paths
up to 4−hop paths
Fig. 3. Probability of finding secure paths between two physical neighbors
with up to 1, 2, 3, 4-hop paths.
0.3 0.35 0.4 0.45 0.5 0.55 0.6 0.65 0.7 0.75 0.8
10−1
100
101
102
103
104
Local connectivity, plocal
N
um
be
r o
f p
at
hs
 o
f e
xa
ct
ly 
h−
ho
p,
 m
N=200, h=5
N=200, h=4
N=200, h=3
N=200, h=2
N=400, h=5
N=400, h=4
N=400, h=3
N=400, h=2
Fig. 4. Number of paths with exactly h-hops from source and destination.
(assuming that they do not share a common key). The average
number of paths is presented corresponding to various plocal.
We also present the number of paths for a similar network
with half of the nodes (N = 200) for comparison purposes.
As can be observed from Fig. 4, the number of available paths
increases with local connectivity, plocal. When node density
increases, there are more paths as well. The number of h-hop
paths also increases with h. Note that these paths may have
common nodes other than the source and the destination.
We show the number of node-disjoint paths in Fig. 5. Note
that we chose 2-hop paths first and then eliminated all other
paths with nodes that have appeared in the previously counted
paths. The total available node-disjoint paths are rather limited,
as shown in Fig. 5. One interesting observation from Fig. 5 is
that the number of exactly h-hop node-disjoint paths decreases
as h increases after 3. This could be due to our path selection
process and the larger number of nodes needed in h-hop
0.3 0.35 0.4 0.45 0.5 0.55 0.6 0.65 0.7 0.75 0.8
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
Local connectivity, plocal
N
um
be
r o
f n
od
e−
di
sjo
int
 ro
ute
s o
f e
xa
ctl
y h
−h
op
, m
N=200, h=5
N=200, h=4
N=200, h=3
N=200, h=2
N=400, h=5
N=400, h=4
N=400, h=3
N=400, h=2
Fig. 5. Number of node-disjoint paths with exactly h-hops from source and
destination.
0.3 0.35 0.4 0.45 0.5 0.55 0.6 0.65 0.7 0.75 0.8
0
2
4
6
8
10
12
Local connectivity, plocal
N
um
be
r o
f n
od
e 
di
sjo
int
 pa
ths
, m
 
 
N=800
N=400
N=200
Fig. 6. Total number of node-disjoint routes.
node-disjoint paths in the neighborhood of the source and the
destination when h is larger.
The total number of node-disjoint routes from a source
toward a destination is shown in Fig. 6. Based on this figure,
it can be concluded that the available node-disjoint paths in-
creases with plocal and N . An example of these results is that,
when plocal = 0.6 and N = 800, there are roughly 6 node-
disjoint paths. Note that the JERT schemes uses all available
node-disjoint routes from a source toward a destination. When
the number of such routes is larger, the JERT scheme can
tolerate more compromised routes.
In order to gain more insights on the neighbors of the source
node serving in the node-disjoint multi-hop secure paths, we
investigated the probability of secure neighbors serving in the
transmission paths, Pt, and showed the results in Fig. 7. Since
the insecure neighbors will not serve in the transmission paths,
we only count the secure neighbors. As can be observed in
12
0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.1 0.11
0
0.02
0.04
0.06
0.08
0.1
0.12
0.14
0.16
0.18
Node compromised probability, x
Se
cr
et
 d
isc
lo
su
er
 p
ro
ba
bi
lity
, p
x
 
 
SP
JERT, α=0.375
JERT, α=0.5
JERT, α=0.625
JERT, α=0.75
JERT, α=0.875
SP, numerical
JERT, α=0.375, numerical
JERT, α=0.5, numerical
JERT, α=0.625, numerical
JERT, α=0.75, numerical
JERT, α=0.875, numerical
Fig. 10. The flexible secret disclosure probability of the JERT scheme (N =
400, plocal = 0.5). Numerical results are compared with simulation results.
All cases with m ≥ 1 paths are studied.
According to this figure, the extra symbol transmission of the
JERT scheme is much smaller than that of the scheme given
in [2].
C. Security Performance
The flexibility of secret disclosure probability of the JERT
scheme is presented in Fig. 10. In this figure, we vary the value
of α and show secret disclosure probability, px, for different
node compromised probability, x. It can be observed that the
JERT scheme has a much lower px than the SP scheme when
α < 1. As α increases within the range between 0 and 1, the px
value is smaller. For a fixed γ, α may be lowered by increasing
k and n. Therefore, the JERT scheme provides a nice property
of flexibility: a pre-defined threshold of probability of secret
key disclosure can be guaranteed by varying (n, k). Numerical
results of (18) and (19) are compared with simulation results
in Fig. 10 as well. The numerical results (curves) match with
the simulation results (symbols) quite well.
We present the secret disclosure probability from another
angle in Fig. 11, where we show px as a function of α for
different x. The stepped curves shown in Fig. 11 suggest
that px does have some abrupt changes when α varies. This
is because each path sends an integer number of symbols
and, when one path is compromised, all these symbols are
disclosed. So the ratio of disclosed symbols is not continuous
when α varies. When this value is compared with secret ratio,
step functions may appear.
In Fig. 12, we compare the expected number of transmitted
symbols in the JERT scheme, the IRT scheme, and another
related scheme termed JERTe. The JERTe scheme is similar
to the JERT scheme except that qj = 1/m for all paths. The
performance of the JERTe scheme is presented to show the
effectiveness of the technique of sending different amount of
symbols to paths of different lengths. Based on Fig. 12, we
conclude that the JERT scheme out-performs the IRT scheme
and the JERTe scheme, with much lower transmission cost.
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
Secret Ratio, α
Se
cr
et
 D
isc
lo
su
re
 P
ro
ba
bi
lity
, p
x
x=0.1
x=0.07
x=0.05
x=0.02
x=0.01
Fig. 11. Secret disclosure probability as a function of secret ratio, α, for
different compromised probability, x, for the JERT scheme.
0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.1 0.11
260
280
300
320
340
360
380
400
420
Node compromised probability, x
Ex
pe
ct
ed
 n
um
be
r o
f t
ra
ns
m
itt
ed
 s
ym
bo
ls,
 δ
JERT
JERTe
IRT
Fig. 12. Comparing the expected number of transmitted symbols in the JERT
scheme and related schemes, (n, k) = (1023, 255).
We can further conclude that the selection of qj has major
effects on transmission overhead in the JERT scheme.
We present the secret disclosure probability of the JERT
scheme, the IRT scheme, and the JERTe scheme in Fig. 13. In
order to distinguish the performance of different schemes, we
artificially increased γ to 128 and 192. Such values of γ result
in higher secret disclosure probabilities. Based on Fig. 13, it
can be concluded that the JERT scheme out-performs the IRT
scheme and the JERTe scheme, with lower secret disclosure
probability.
VII. CONCLUSIONS AND SELF EVALUATION
Key pre-distribution techniques for security provision of
Wireless Sensor Networks (WSNs) have attracted significant
interests recently. One class of such key pre-distribution
schemes load a relatively small number of keys randomly
chosen from a large key pool prior to deployment. After being
14
[26] T. K. Truong, W. L. Eastman, I. S. Reed, and I. S. Hsu, “Simplified
procedure for correcting both errors and erasures of Reed-Solomon code
using Euclidean algorithm,” IEE Proceedings, vol. 135, no. 6, pp. 318–
324, Nov. 1988.
[27] S.-L. Shieh, S.-G. Lee, and W.-H. Sheen, “A low-latency decoder for
punctured/shortened Reed-Solomoncodes,” in Proc. of IEEE INterna-
tional Symposium on Personal, Indoor and Mobile Radio Communica-
tions, Berlin, Germany, September 11-14 2005, pp. 2547–2551.
[28] G. J. Pottie and W. J. Kaiser, “Wireless integrated network sensors,”
Communications of the ACM, vol. 43, no. 5, pp. 51–58, May 2000.
[29] J. Deng and Y. S. Han, “Using MDS codes for the key establishment
of wireless sensor networks,” in Proc. of the International Conference
on Mobile Ad-hoc and Sensor Networks (MSN ’05), X. Jia, J. Wu, and
Y. He, Eds., Wuhan, P. R. China, December 13-15 2005, vol. 3784
of Lecture Notes in Computer Science (LNCS), pp. 732–744, Springer-
Verlag.
Babel: Using a Common Bridge Node to Deliver
Multiple Keys in Wireless Sensor Networks
Jing Deng
Department of Computer Science
University of New Orleans
New Orleans, LA 70148, USA
jing@cs.uno.edu
Yunghsiang S. Han
Graduate Institute of Communication Engineering
National Taipei University
Sanhsia, Taipei, 237 Taiwan
yshan@mail.ntpu.edu.tw
Abstract In Wireless Sensor Networks (WSNs), symmetric
key schemes may be used to provide security. Recently, a class of
random key pre-distribution techniques have been proposed and
investigated. Such techniques usually only guarantee to establish
keys for some pairs of physically connected sensors. In this work,
we investigate the issue of delivering secret link keys to each of
the source’s neighbors in wireless sensor networks. We propose a
scheme called Babel that nds a common bridge node to deliver
one key to each of the to-be-connected neighbors. In the process,
the source node broadcasts the challenges based on Message
Authentication Codes (MACs) of all keys stored on itself and the
to-be-connected neighbors. The novelty of our scheme is to deliver
multiple keys with the use of a common bridge node and regular
paths instead of multi-hop secure paths. Since the delivered keys
are only disclosed to one node, the common bridge node, key
compromise probability of the Babel scheme is signicantly lower
compared to other delivery techniques. Analytical and simulation
results are presented to support the claim of the superiority of
the proposed technique.
I. INTRODUCTION
Wireless Sensor Networks (WSNs) have been the focus
of active research over the past few years. Some researchers
investigated efficient data delivery, energy conservation, and
other related issues [1]. Network security has also been a
research focus mainly due to the fragility of the sensor nodes
against node capture and modification.
In order to provide security for communication and data
collection in WSNs, security keys need to be delivered and
used. Since public/private encryption and decryption tech-
niques are believed to be computation intensive for resource
constrained wireless sensors, secret key schemes should be
employed. The question is how to deliver such secret keys to
the communicating nodes.
In 2002, Eschenauer and Gligor proposed a random key
pre-distribution technique allowing sensors to preload a subset
of keys (key ring) from a large key pool. It has been shown
that, when the size of the key ring and the size of the key
pool are chosen carefully, the neighboring sensors will have
a relatively large probability of sharing a common key. With
such a shared key, the neighboring nodes can establish secret
link key securely [2]. The scheme has been extended by
researchers in several research groups [3]–[5].
It has been shown that there are still some local links
that are disconnected on the security plane. The lack of such
secure links can be thought as intentional. This is because
an extremely high local connectivity (on the security plane)
would mean higher vulnerability and lower network resilience,
as shown in [2], [4].
In this work, we focus on the issue of delivering secret link
keys from a source to multiple neighbors. Random key pre-
distribution techniques may only connect some neighbors to
the source with common keys. Other neighbors are still dis-
connected from the source on the security plane. Eschenauer
and Gligor suggested to use the secure multi-hop path scheme
to deliver such secrets [2]. In their scheme, the secret is
declosed to all the nodes on the path. If any of these nodes is
compromised, the secret is disclosed to the adversary. Instead,
we propose a new technique called Babel that tries to find
a common bridge node to deliver secret link keys to these
neighbors. The novelty of our scheme is to deliver multiple
keys with the use of a common bridge node and regular paths
instead of multi-hop secure paths. Since the delivered keys
are only disclosed to one node, the common bridge node, key
compromise probability of the Babel scheme is significantly
lower compared to other delivery techniques.
We expect our scheme to be implemented in the networks
where the source node needs to communicate with all its
physical neighbors securely. Disclosure of any information
sent from the source poses a security threat. An example is the
cluster-based wireless sensor networks where the cluster head
needs to communicate with the sensors in its neighborhood.
II. RELATED WORK
Besides the related work discussed above [2], [4], [5], Chan
et al. presented a technique to establish secure link keys for
two neighboring nodes if they do not share enough common
keys [3]. These two neighbors first identify all secure paths
between themselves. Then one node generates a set of random
keys (of the same size) for all the paths and send one key to
the destination through each of the paths. After the destination
receives all the numbers, it exclusive-ORs all of them to obtain
the secret link key. The multi-path key reinforcement scheme
significantly improves the protection of the secret link key
from being disclosed to the adversary.
Li et al. proposed to use k intermediate nodes between
two sensors to establish a link key [6]. Two methods were
that node Z does share a key with itself. After each node
verifies node Z’s claim of sharing a key, node S sends the
secret link keys (for nodes B, E, and G) to node Z. Upon
receiving the message, Node Z encrypts the secret link keys
with the shared keys with nodes B, E, and G, respectively. For
example, the secret link key between nodes S and B will be
encrypted at node Z with the common key between nodes Z
and B. Such encrypted secret link keys are then returned to
node S. Node S forwards the encrypted secret link keys to the
to-be-connected neighbors, which decrypt the secret link keys.
Note that all message transmissions between nodes S and
Z, except the first broadcast message, are encrypted with the
shared key between these two. This will protect the transmitted
information from being disclosed to a third party. Even though
node Z can send all information to nodes B, E, and G directly,
transmission through node S is preferred in order to protect the
scheme from nodes, especially the non-common-bridge-nodes,
faking common keys. The transmission overhead is slightly
higher but the scheme is more secure [7], [8].
The pseudocode of the Babel scheme is shown through
Algorithms 1, 2, and 3. In particular, Algorithm 1 finds a
common bridge node. Algorithm 2 verifies the responses from
the common bridge node. Algorithm 3 is then used to send
secret link keys through the common bridge node.
We use the following notations in our pseudocodes:
• Time-To-Live (TTL): a predefined number of hops for
the request message to travel
• λ: the number of keys carried by each node
• S: source node
• Ntbc: set of to-be-connected neighbors of S
• Ki,t: keys on node i, i ∈ {S} ∪ Ntbc, 1 ≤ t ≤ λ
• ti: the index of the shared key between the common
bridge node and node i, i ∈ {S} ∪ Ntbc
• LKS,i: secret link key between nodes S and i, i ∈ Ntbc
B. Discussions
Due to the page limit, we provide the following brief
discussions of the Babel scheme in this subsection.
Note that a node lying about its keys either cannot decrypt
the message from node S or its responses for the challenges
from the to-be-connected neighbors fail.
It is possible that such a node Z cannot be found to share
a key with each of these nodes. Then multiple nodes may
be used to deliver secret link keys for all these nodes. For
instance, node Z1 may be used to deliver secret link keys
toward nodes B and E. Node Z2 may be used to establish a
secret link key toward node G. When each common bridge
node is only required to connect the source node and one to-
be-connected neighbor, the scheme is similar to the scheme
in [6] with k = 1.
Multiple bridge nodes may be used to deliver partial or
encoded link key information from node S to nodes B, E, and
G. In fact, assuming a large number of sensors in the network,
we can find many nodes similar to node Z. Assuming that we
find ` such nodes, nodes Z1, Z2, · · · and Z`. MDS scheme
given in [7] may be used to encode the link keys. When ` is
Algorithm 1 Pseudocode to Find Common Bridge Node
1: S obtains MAC(i, t) based on Ki,t for each (i, t), i ∈
{S} ∪ Ntbc, 1 ≤ t ≤ λ
2: S broadcasts a msg with MACs and TTL
3: for each z receiving the msg do
4: if ∀i ∈ {S} ∪ Ntbc, ∃ti, such that MAC(z, ti) =
MAC(i, ti) then
. A common bridge node is found
5: z prepares responses to MAC(i, ti), i ∈ {S} ∪
Ntbc
6: z encrypts responses with Kz,tS
7: Msg and MAC(S, tS) are sent from z to S
8: else
9: TTL ← TTL-1
10: if TTL > 0 then
11: z adds its ID to the end of msg
12: z forwards the msg
13: else
14: z discards the msg
15: end if
16: end if
17: end for
Algorithm 2 Pseudocode to Verify Common Bridge Node
1: S verifies response from z on claimed common key Kz,tS
2: if response is valid then
3: S decrypts msg with KS,tS
4: S forwards responses from z to each i ∈ Ntbc
5: for each i ∈ Ntbc do
6: i verifies response from z on claimed common key
Kz,ti
7: if response is valid then
8: i sends confirmation to S
9: end if
10: end for
11: if S receives confirmation for each i ∈ Ntbc then
12: S accepts z as the common bridge node
13: else
14: S rejects z as the common bridge node
15: end if
16: else
17: S discards msg
18: end if
Algorithm 3 Pseudocode to Send Secret Link Keys
1: S encrypts LKS,i, i ∈ Ntbc, with KS,tS
2: S sends encrypted msg to z
3: z decrypts msg with Kz,tS , recovering LKS,i, i ∈ Ntbc
4: ∀i ∈ Ntbc, z encrypts LKS,i with Kz,ti
5: z encrypts encrypted link keys with Kz,tS
6: z sends msg to S
7: S receives msg from z, decrypts msg with KS,tS
8: S sends encrypted link keys to i ∈ Ntbc
9: i ∈ Ntbc decrypts link key with Ki,ti
3
0.4 0.45 0.5 0.55 0.6 0.65 0.7 0.75 0.8
1
2
3
4
5
6
7
Connectivity probability, plocal
Av
er
ag
e 
Ho
p 
Co
un
t, 
h
 
 
N=300
N=500
N=800
Fig. 3. The average hop count from the common bridge node toward the
source.
A. Transmission Cost
Since the transmission overhead of our scheme depends
largely on how far the common bridge node is away from
the source node, we measured the average hop count as the
transmission cost. In Fig. 3, we show such average hop count
as a function of key sharing connectivity, plocal. Curves for
networks with different total number of sensors are shown to
represent the effect of different node density.
It is interesting to see from Fig. 3 that the number of hops
toward the closest common bridge node is roughly the same
for various N values when plocal is either large or small. This
might have been caused by the opposite effects of more nodes
and more to-be-connected neighbors. When plocal is in the
middle, larger N leads to longer hops because of more to-be-
connected neighbors.
B. Compromise Probability
We have also measured the chance of secret link keys
being compromised and disclosed. The comparisons were
made between the Babel scheme and the secure multi-hop
path scheme [2]. In the secure multi-hop path scheme, the
source node finds a secure multi-hop path, on which every
two consecutive nodes share at least a key, to deliver a secret
link key. We first counted the occurrences of having j unique
intermediate bridge nodes and calculated the compromise
probability based on (4). We have omitted the term of pe(xc)
in our comparisons.
Based on the results shown in Fig. 4, we can see that the
Babel scheme has a lower compromise probability for all xc
values. As plocal increases, the compromise probability of the
secure multi-hop path scheme lowers. This is because of the
smaller hop and smaller number of intermediate bridge nodes
when plocal increases.
0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Compromise probability, x
c
Se
cr
et
 c
om
pr
om
ise
 p
ro
ba
bi
lity
, P
c
 
 
Babel
plocal=0.5, N=300
plocal=0.5, N=500
plocal=0.5, N=800
plocal=0.8, N=300
plocal=0.8, N=500
plocal=0.8, N=800
Fig. 4. The relative value of compromise probability for Babel and the secure
multi-hop path scheme [2]. We neglect the term pe(xc) in both (2) and (4).
Note that the compromise probability shown for the secure multi-hop path
scheme is a lower bound.
VII. CONCLUSIONS
We have proposed the Babel scheme that delivers secret link
keys toward multiple to-be-connected immediate neighbors.
The Babel scheme makes use of a remote node that shares at
least a key with the source and each of its to-be-connected
neighbors. With the use of this common bridge node, the
chance of secret link key compromise is lower compared to
other schemes for multiple secret delivery. The novelty of
our scheme is to deliver multiple keys with the use of a
common bridge node and regular paths instead of multi-hop
secure paths. Since the delivered keys are only disclosed to one
node, the common bridge node, key compromise probability of
the Babel scheme is significantly lower compared with other
delivery schemes. Naturally, more transmission overhead is
needed in the Babel scheme, as demonstrated by our study on
transmission cost.
Our preliminary analysis and performance evaluation show
that Babel outperforms existing schemes such as the secure
multi-hop path scheme in security performance. In future
work, we will focus on analyzing the security performance of
the Babel scheme and its comparison with related techniques.
REFERENCES
[1] I. F. Akyildiz, W. Su, Y. Sankarasubramaniam, and E. Cayirci, “A survey
on sensor networks,” IEEE communications Magazine, pp. 102–114,
August 2002.
[2] L. Eschenauer and V. D. Gligor, “A key-management scheme for
distributed sensor networks,” in Proc. of the 9th ACM conference
on Computer and communications security, Washington, DC, USA,
November 18-22 2002, pp. 41–47.
[3] H. Chan, A. Perrig, and D. Song, “Random key predistribution schemes
for sensor networks,” in Proc. of IEEE Symposium on Security and
Privacy, Berkeley, California, May 11-14 2003, pp. 197–213.
[4] W. Du, J. Deng, Y. S. Han, and P. K. Varshney, “A pairwise key
pre-distribution scheme for wireless sensor networks,” in Proc. of
ACM Conference on Computer and Communications Security (CCS ’03),
Washington, DC, USA, October 27-31 2003, pp. 42–51.
5
