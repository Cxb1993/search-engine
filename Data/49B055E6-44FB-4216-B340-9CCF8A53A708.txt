merit of [6, 7] scheme is no need to modify the SystemC 
source code for each fault injection campaign once the 
FIMs have been inserted into the simulation model. The 
only source to be prepared for each injection campaign is 
the fault injection controller that implements the injection 
script commands. 
Several interesting issues deserved to be explored 
further are described as follows. One is the control 
complexity of the centralized injection control 
methodology and its effect on the simulation time. As 
system is getting more complex, the injection control 
complexity rises too. Consequently, the simulation 
performance could be degraded significantly. Another is 
how to inject the faults into the systems modeled using 
mixed levels of abstraction. Since it is rare that all 
modules within a system are modeled at the same level of 
abstraction, the injection approach developed should 
possess the ability to inject the faults into different levels 
of abstraction. Third is how to generate the fault injection 
script file at higher levels of abstraction in SystemC 
design platform, which represents the fault scenario for 
each injection campaign. The last issue is the feasibility of 
fault/error model employed at high level of abstraction. 
The precision of fault/error model will affect the accuracy 
of the results of injection campaign. Paper [9] presents a 
preliminary study of this fault/error modeling issue.  
In this work, we propose an effective system-level 
simulation-based fault injection framework in SystemC 
design platform to assist the dependability assessment. The 
framework of fault injection proposed consists of the 
following modeling levels of abstraction: bus-cycle 
accurate (BCA) level, untimed functional transaction-level 
modeling (TLM) with primitive channel sc_fifo, and timed 
functional transaction-level modeling with hierarchical 
channel. We devise a distributed injection control approach 
instead of using one centralized control unit to control the 
injection activity. The proposed distributed injection 
control approach is capable of injecting single or multiple 
faults with diverse fault types into different abstraction 
levels. Our scheme can inject the faults into a system 
modeled at mixed levels of abstraction in SystemC. As we 
see, the control of injection activity is distributed to the 
fault injection modules (FIMs), which may lower the 
control complexity of fault injection and the simulation 
time compared to the centralized control approach. 
However, our approach needs to construct the source code 
of SystemC simulation model for each fault injection 
campaign because the fault injection script commands are 
distributively implemented in each FIM. The comparison 
of our distributed approach with the centralized control 
method in terms of experiment setup, compiling time, fault 
injection efficiency and simulation time will be discussed 
in the future.  
The remaining report is organized as follows. In 
Section 2, the fault injection framework is presented. We 
demonstrate the feasibility of our fault injection approach 
in Section 3. The conclusions and future work appear in 
Section 4. 
II. FAULT INJECTION FRAMEWORK IN SYSTEMC 
In this section, we consider the fault injection into the 
communication channels at the following abstraction levels. 
The first one is sc_signal at BCA level; the second one is 
the primitive channel sc_fifo at untimed functional 
transaction level and the last on is the hierarchical channel 
[5, 10] at timed functional transaction level. The principal 
idea of our approach is based on the insertion of FIMs into 
the interconnections of the functional blocks, where a FIM 
is to control the fault injection activity for the selected fault 
target. Since we distribute the injection control to each FIM, 
the FIMs are responsible for the determination of the fault 
injection activity including when to inject a fault, what the 
fault value and its duration. The core of the FIM design is 
how to decide when to activate a fault injection.  
A. Fault injection at BCA level 
Fig. 1 shows the fault injection structure for BCA level 
that includes a FIM used for the control of fault injection. 
The FIM contains an injection list of the faults, which 
depicts the injection activity for each fault collected in the 
injection list. Since the BCA level is clock-cycle accurate, 
the FIM can use the sc_simulation_time ( ) to get the time 
instant of the beginning of each clock cycle. Then, the FIM 
checks the current time instant obtained with the injection 
time list of the faults pre-specified in the FIM. If the time 
instant is equal to the injection time of a fault, FIM will 
activate the fault injection by generating the desired fault 
type/value to the ‘MUX’ input port and keep the fault 
stayed active for a pre-defined length of time; otherwise, 
the original signal is delivered.  
 
Fig. 1. Fault injection structure for BCA level. 
B. Fault injection at untimed functional transaction level 
As no clock exists in this level of abstraction, the 
event-driven method is utilized to trigger the FIM as 
illustrated in Fig. 2. An event is used to represent a 
condition that may occur during the course of simulation 
and to control the triggering of fault injection. We create 
the ‘Event Check’ module to monitor the occurrence of a 
specific event to control the FIM when to trigger the fault 
injection. The event could be, for example, a particular 
instruction address or a counter whose value reaches to a 
specific count. When the declared event occurs, the ‘Event 
Check’ module will send a trigger signal ‘Enable’ to FIM to 
activate the fault injection. 
Fig. 2(b) exhibits the circuit diagram of ‘Event Check’ 
block. The ‘Data Check’ module can check the data-related 
events, such as a particular address and data. The ‘Count 
Check’ can check, for example, whether the number of data 
read out from the FIFO channel has reached to a specific 
count. Table I presents the operation of ‘Event Check’. 
‘Event Check’ is expandable if more types of events need 
to check.  
first three faults are count-triggered faults and sustain one, 
two and three transactions, respectively. The last fault is 
data-triggered fault and maintains two transactions long. 
The simulation outcomes of Fig. 9 confirm the feasibility 
of event-triggered injection approach for untimed 
functional transaction level. 
C. Experiment at timed functional transaction level 
In this experiment, we employ the AMBA bus to 
demonstrate the injection of faults into the hierarchical 
channels modeled at timed functional transaction level. 
Since hierarchical channel plays an important role in SoC, 
offering the injection capability of faults into the 
hierarchical channels is imperative in SystemC design 
platform. We utilize the AMBA bus library [12] and AMBA 
bus API [13] furnished by CoWare Platform Architect to 
implement the circuit diagram shown in Fig. 10. The 
‘Driver (master)’ and ‘Display (slave)’ modules in Fig. 10 
are responsible for sending data to AHB and receiving plus 
printing data from AHB respectively. The concept of FIM 
module is like ‘AHB to AHB Bridge’ except FIM is able to 
pollute the bus data during the fault injection campaign. 
The count of data transaction in AHB is used in FIM to 
decide the injection time of faults. In this demonstration, 
two faults are injected into the AHB channel. The first fault 
occurs at the second data transaction and lasts the length of 
two data transactions. The second fault happens at the tenth 
data transaction and sustains one data transaction. The 
simulation results of fault-free and fault injection 
experiments are exhibited in Fig. 11. 
D. Experiment at mixed levels of abstraction 
SystemC, as a system-level design platform, employs 
the concepts of intellectual property (IP) reuse and 
hierarchical channel to reduce the SoC design complexity, 
effort and time. However, the provided IP modules may be 
modeled at various levels of abstraction such that a system 
is often modeled at mixed abstraction levels. Therefore, the 
inclusion of fault injection at mixed levels of abstraction is 
important in the development of system-level fault 
injection framework. The goal of this experiment is to 
show the feasibility of our fault injection framework, which 
is capable of injecting the faults into a system modeled at 
mixed levels of abstraction.  
Fig. 12 demonstrates a fault injection structure at 
mixed levels of abstraction. In Fig. 12, ‘Driver_1’ module 
modeled at RTL provides the augend data for ‘Adder’; 
‘Driver_2’ module modeled at timed functional transaction 
level offers the addend data through the AHB channel to 
‘Adder’, and right part of Fig. 12 including ‘Adder’ and 
‘Monitor’ modules is modeled at untimed functional 
transaction level with primitive channel sc_fifo. ‘Driver_1’ 
sends out an augend every 5 ns following the data sequence 
0 ~ 14. ‘Driver_2’ sends out an addend every 10 ns 
following the data sequence 0 ~ 14. The ‘Adder’ module 
synchronizes the input sequences of augend and addend, 
and therefore, the results of ‘Adder’ are .14  to0    ,2 =× ii  
The fault scenario for this experiment is as follows: ‘FIM’ 
in ‘Driver_1’ part injects faults into augend at time 15ns 
and 25 ns; ‘FIM’ in ‘Driver_2’ part injects faults into 
addend at transaction count 6 and 9; ‘FIM’ in ‘Monitor’ 
part injects faults into ‘Monitor’ input at transaction count 
11 and 12, and at ‘Adder’ output data equal to 28. Fig. 13 
illustrates the simulation results of fault-free and fault 
injection experiments. As can be seen from Fig. 13(a), a 
situation of multiple faults occurs when augend is 55 and 
addend is 200. This confirms the multiple fault injection 
ability of our mechanism. 
 
Fig. 5. A common circuit structure for injection 
experiments. 
Driver Adder Monitor
select
FIM
MUX
 
Fig. 6. Fault injection structure of Fig. 5 circuit modeled at 
BCA level. 
 
Fig. 7. Simulation results of fault-free (left side) and fault 
injection (right side) experiments at BCA level. 
 
Fig. 8. Fault injection structure at untimed functional 
transaction level. 
 
 
 
 
(b) 
 Fig. 13. (a) Fault injection scenario. (b) Simulation results of fault-free and fault injection experiments. 
IV. CONCLUSIONS AND FUTURE WORK 
In this report, a system-level fault injection framework 
in SystemC design platform is presented. The proposed 
fault injection framework provides the methodologies for 
injecting the faults into various levels of abstraction. Three 
modeling levels considered in the framework are BCA 
level, untimed functional transaction level, and timed 
functional transaction level. The experiments based on 
CoWare Architect Platform were conducted to validate the 
feasibility of our fault injection approach. Contributions of 
this work are first to present the idea of distributed fault 
injection control to lower the control complexity of the 
fault injection compared to the centralized fault injection 
control; to develop the methodologies, including the 
time-triggered and event-triggered concepts, to inject the 
faults into different abstraction levels, and importantly to 
provide a solution for injection of faults into a system 
modeled at various levels of abstraction.  
In the future, we will further explore the approach of 
distributed control of fault injection and compared to the 
method of centralized control of fault injection in terms of 
the complexity of experiment setup, compiling time, fault 
injection efficiency and simulation time. In addition, we 
will implement the proposed fault injection framework in 
the EDA tool of CoWare Architect Platform.  
REFERENCES 
[1] C. Constantinescu, “Impact of Deep Submicron 
Technology on Dependability of VLSI Circuits,” IEEE 
Intl. Conf. On Dependable Systems and Networks 
(DSN), pp. 205-209, 2002. 
[2] P. Shivakumar et al., “Modeling the Effect of 
Technology Trends on the Soft Error Rate of 
Combinational Logic,” DSN, pp. 389-398, 2002. 
[3] T. Karnik, P. Hazucha, and J. Patel, “Characterization 
of Soft Errors Caused by Single Event Upsets in 
CMOS Processes,” IEEE Trans. on Dependable and 
Secure Computing, Vol. 1, No. 2, pp. 128-143, 
April-June 2004. 
[4] A. Fin, F. Fummi and G. Pravadelli, “AMLETO: a 
Multilanguage environment for functional test 
generation”, 2001 International Test Conference, pp. 
821-829, Nov. 2001. 
[5] Grotker Thorsten et al., “System Design with 
SystemC,” Kluwer Academic Publishers, 2002. 
[6] K. Rothbart et al., “High Level Fault Injection for 
Attack Simulation in Smart Cards,” 13th Asian Test 
Symposium, pp. 118-121, Nov. 2004. 
[7] K. Rothbart et al., “A Smart Card Test Environment 
Using Multi-Level Fault Injection in SystemC”, 6th 
IEEE Latin-American Test Workshop, pp. 103-108, 
March-April 2005. 
[8] K. Rothbart et al., “Power Consumption Profile 
Analysis for Security Attack Simulation in Smart 
Cards at High Abstraction Level,” EMSOFT, pp. 
214-217, Sept. 2005. 
[9] Kuen-Long Leu, Yung-Yuan Chen, and Jwu-E Chen, 
“A Comparison of Fault Injection Experiments under 
Different Verification Environments”, IEEE Fourth 
International Conference on Information Technology 
and Applications, pp. 582-587, Jan. 2007. 
[10] Open SystemC Initiative (OSCI), “SystemC 2.0 
Language Reference Manual,” Revision 1.0, 
www.systemc.org, 2003. 
[11] Bhasker Jayaram and J. Bhasker, “A SystemC 
Primer,” Star Galaxy Publisher, 2004. 
[12] CoWare Model Library, “AMBA Bus Library,” 
Product Version V2005.2.2. 
[13] CoWare Model Library, “TLM API Manual,” Product 
Version V2005. 
 
 
possible errors which could occur in the data flow paths 
for a particular operation under a specific error model. For 
each operation, we can inject the desired errors from the 
error model into the corresponding data flow paths and 
check whether the detection and recovery schemes 
embedded in the system can tolerate the errors or not. To 
support the validation of system robustness, the proposed 
system model must have the capability to propagate the 
errors while the system is executed. 
Based on the above discussion, we develop a 
high-level abstract model to modeling the fault-robust 
systems. The simulation model of systems comprises the 
following three parts:  
1. the interconnection structure of the functional units; 
2. the propagation tables expressing the relationship 
between inputs and outputs for each functional unit; 
3. the Petri net structure [15] to model the functional 
behavior of the fault-tolerant systems.  
More specifically, the propagation tables can be 
utilized to propagate the errors from the inputs to the 
outputs of each functional unit. And through the 
interconnections of the functional units, the effect of errors 
will be propagated. An abstract error model is exploited to 
generate the desired error patterns for the system under 
validation. The function of Petri net model is to control the 
operations of the system. For each operation represented 
by a place in the Petri net graph, we also need to store its 
control signals for the corresponding functional units 
which are responsible for the execution of the operation. 
We can count on the Petri net model and the control 
signals for each operation to derive the corresponding data 
flow paths for a particular operation. Then, all possible 
errors which could happen in those data flow paths for a 
specific operation can be located. In that way, we can 
generate the error list for each operation. In other words, 
our verification approach can produce the propagation 
paths for each error to see whether the paths of error 
propagation have the detection and recovery protection or 
not. Therefore, we can examine the error patterns one by 
one for a particular operation to acquire the dependability 
data for robustness validation. Finally, the error coverage 
of a system can be derived from the detailed analysis of 
the error coverage related to each operation. In addition to 
the error coverage evaluation, the analysis can also 
discover the single failure points or weak points of the 
systems that can be utilized to improve the system 
dependability further.  
CASE STUDY 
A fault-tolerant VLIW core [16] is used to demonstrate the 
concept of our approach. For simplicity of demonstration, 
we adopt the portion of the execution stage of VLIW core 
as shown in Figure 1 to illustrate the modeling 
methodology and the fault-robust verification process. In 
Figure 1, ‘CP’ and ‘TMR_MV’ denote the ‘comparator’ 
and ‘triple modular redundancy majority voter’, 
respectively. The fault-tolerant scheme employed in [16] is 
briefly described as follows: 
while (not end of program) 
{switch (Number of instructions in an execution packet 
for ALU.)  
{case ‘1’: TMR_MV(ALU_1, ALU_2, ALU_3); if 
(TMR_MV detects more than one ALU 
failure) then the “Error-recovery process” 
is activated to recover the failed 
instruction. 
case ‘2’: the execution packet contains two 
instructions: I1 and I2. 
I1: CP1(ALU_1, ALU_2);  
I2: CP2(ALU_3, ALU_4); 
if (I1 fails) then the “Error-recovery 
process” is activated to recover I1. 
if (I2 fails) then the “Error-recovery 
process” is activated to recover I2. 
case ‘3’:the packet is divided to two packets and 
executed sequentially.  
}} 
Error-recovery process: 
1←i ; 
While (number of retries ) 0_ >nor
{TMR_MV(ALU_i, ALU_ , ALU_1+i 2+i ); 
  if (TMR_MV succeeds) then the error recovery 
succeeds Æ exit;  
  else { 1__ −← nornor ; 1+← ii ; if 
( ) then 3≥i 1←i ;}} 
recovery failure and the system enters the fail-safe 
state. 
Figure 2 exhibits the simulation model of the system 
illustrated in Figure 1, where . In this case 
study, there are two normal system operations: an 
execution packet containing one ALU instruction or two 
ALU instructions. As can be seen from Figure 2(b), these 
two operations termed as target operations are notated by 
the places of ‘P1inst’ and ‘P2inst’, respectively. The other 
places are used to model the operations/functions of the 
fault-tolerant scheme presented above. We now exploit 
Figure 2 to explain the modeling methodology and 
fault-robust verification approach. 
2_ =nor
Modeling methodology:  
1. The interconnection description of the functional units; 
we create a file to describe the interconnection 
relationship among the functional units. 
2. Figure 2(a) shows the propagation tables for the 
functional units, where ‘eq’ and ‘neq’ represent 
‘equal’ and ‘not equal’, respectively. 
3. Figure 2(b) shows the Petri net graph created to model 
the system as exhibited in Figure 1. The control 
signals for target operation ‘P1inst’ and its associated 
operations ‘Prc1’ and ‘Prc2’ are provided in the 
control table as displayed in Figure 2(c). For example, 
when the operation ‘P1inst’ is executed, the control 
table is employed to produce the corresponding 
control signals, such as Sch_control = ‘000’ and 
mux_a = ‘0’, to perform the execution of one ALU 
instruction with TMR protection. Figure 2(d) gives 
the conditions for firing the transition from the input 
place to the output place.  
 
 8
applied in the following demonstration of path 
generation).  
z Schedule: Since Sch_control = ‘000’, according to the 
propagation table of Schedule, I1_in1 (data1) is 
propagated to Sch_A1_Out, Sch_B1_Out and 
Sch_C1_Out, and I1_in2 (data2) is propagated to 
Sch_A2_Out, Sch_B2_Out and Sch_C2_Out. 
z ALU: Based on the propagation table of ALU, 
ALU_A_Out, ALU_B_Out and ALU_C_Out are all 
equal to ‘data1 op data2’. 
z Mux: mux_a = ‘0’, and therefore, ‘data1 op data2’ is 
propagated to Mux_Out1, Mux_Out2 and Mux_Out3. 
z TMR_MV: According to the propagation table of 
TMR_MV, TMR_Out is ‘data1 op data2’ and 
TMR_Error is 0. 
Step 2: In Step 1, we have collected the data flow paths for 
the operation ‘P1inst’. Then, find out all possible errors 
which could occur in the data flow paths for ‘P1inst’ under 
a selected error model. Here, we adopt the following error 
model to generate the error patterns that will be used to 
check the system robustness while ‘P1inst’ operation is 
executed.  
Error model: To simplify the modeling complexity and 
reduce the simulation time, we omit the details of the 
functional units in the system modeling. However, there is 
no way to inject the faults into the inside of the functional 
units. Therefore, the errors only can be injected in the 
outputs of the units. We consider the errors either 
occurring in a single output port or in the two different 
output ports.  
According to the above error model, we can create the 
possible errors, which could happen in the data flow paths 
of the operation ‘P1inst’. So, if an error occurs in the 
‘P1inst’ paths and meanwhile the system is executing the 
operation of ‘P1inst’, then this error could affect the 
execution result. For each operation, we can inject the 
possible errors from the error model into the 
corresponding data flow paths and investigate whether the 
detection and recovery schemes built in the system can 
tolerate the errors or not.  
Case 1: A single output port error; an error is injected into 
the Sch_A1_out port as shown in Figure 2(a), propagation 
table of Schedule unit. As can be seen from Step 1, ‘data1’ 
is changed to ‘wrong_data’. Clearly, the error will be 
propagated to Mux_Out1, then TMR1. So, TMR1 
becomes ‘wrong_data op data2’. In the meantime, TMR2 
and TMR3 contain the expression ‘data1 op data2’. As a 
result, TMR_Out is ‘data1 op data2’ and TMR_Error is 0. 
It means that the error can be overcome. Next, there are 
two output places, ‘Prc1’ and ‘Ptmrs’, for input place 
‘P1inst’, where the outcome of TMR_Error decides which 
transition will be enabled. Since TMR_Error is 0, from 
Figure 2(d), the transition ‘Ttmrs’ is fired and the place is 
transited from ‘P1inst’ to ‘Ptmrs’. There is no more 
transition when the place is in ‘Ptmrs’. Record the result 
and activate the next error injection. 
Case 2: Two output port errors; an error is injected into the 
Sch_A1_out port and the other into Sch_B1_out port. 
Similarly, the errors will be propagated to TMR_MV 
inputs, and they are ‘wrong_data1 op data2’, 
‘wrong_data2 op data2’, and ‘data1 op data2’, respectively. 
Consequently, TMR_MV fails to produce the correct 
answer, and sets TMR_Error is one. Next, the transition 
‘Ttmrf’ is fired and the place ‘Prc1’ is executed. The 
operation ‘Prc1’ is the first error recovery, and if it 
succeeds, then the transition ‘Trc1s’ is fired; else, the 
operation of second recovery ‘Prc2’ will be activated. 
Finally, if error recovery succeeds, then the system enters 
the place ‘Prc2s’; else, the system goes into the fail-safe 
state. 
Figure 3 illustrates the complete fault-robust verification 
process. A platform based on the verification process is 
developed and used to evaluate the error coverage of the 
fault-tolerant systems.  
 
Figure 3. The complete fault-robust verification process. 
SIMULATION RESULTS 
In this section, we use the proposed verification platform 
to assess the error coverage of system as shown in Figure 
1. The design metrics as described below are exploited to 
justify our approach: 
z : Error-detection coverage, i.e. probability of 
errors detected; 
det−eC
z : Error-recovery coverage, i.e. probability of 
errors recovered given errors detected; 
receC −
z : Error coverage, i.e. probability of errors detected 
and recovered; 
eC
z : Probability of system entering the 
fail-unsafe state; 
unsfP −
z : State transition probability from 
‘detected’ state to ‘fail-safe’ state. 
sftP −−− det
Table 1 presents the simulation results of the design 
metrics. The data shown in Model1 are derived from the 
assumption that the occurring probability is the same for 
 10
 12
Self-Evaluation of Research Results: 
z The above report summarizes the first-year 
results accomplished from this three-year 
research project. It is evident that 99% of the 
work has been achieved and the preliminary 
results have been published. The extended 
versions of the results will be submitted to be 
considered for journal publication. However, the 
subjects described in our proposal are big and 
deserve to be further explored. We definitely 
achieve the first-year goals set in the proposal. 
z We are going to develop a system-level 
fault-injection tool, which exploits the 
simulation-based fault injection scheme proposed 
in this research and can be installed in the 
CoWare Architect Platform. The tool takes the 
fault scenario description from the user and then 
automatically generates the system platform 
supplemented with the fault injection capability. 
This kind of fault injection tool can not only 
facilitate the failure mode and effect analysis 
(FMEA) and the fault-tolerant validation process, 
but raise the validation efficiency. The embedded 
fault-tolerant systems have found fertile ground 
in intelligent system applications, such as 
intelligent driver assistance system or intelligent 
robot system, which require a stringent 
dependability while the systems are in operation. 
Since more works depend on the intelligent 
machines, the reliability issue becomes more 
important than ever. The fault-tolerant 
verification platform developed from this 
research can be applied to the design and 
analysis of the fault-tolerant systems modeled at 
high level of abstraction to enhance the overall 
system dependability. The previous study for the 
fault injection approach mainly focuses on the 
VHDL modeling level and rarely discusses the 
fault injection in system-level design. We want to 
fulfill this lack. 
Publications associated with this research: 
z Kuen-Long Leu, Yung-Yuan Chen and Jwu-E 
Chen, “A Comparison of Fault Injection 
Experiments under Different Verification 
Environments”, IEEE Fourth International 
Conference on Information Technology & 
Applications, pp. 582-587, Jan. 2007. (EI)  
z Yung-Yuan Chen and Geng-Wei Wu, 
“Fault-Tolerant Verification Platform for 
Systems Modeled at High Level of Abstraction”, 
1st IEEE Systems conference, pp. 1-7, April 2007. 
(EI) 
z Kun-Jun Chang and Yung-Yuan Chen, 
“System-Level Fault Injection in SystemC 
Design Platform,” 8th International Symposium 
on Advanced Intelligent Systems, pp. 354-359, 
Sept. 2007. 
III. ERROR INJECTION METHODOLOGY IN 
SYSTEMC 
A basic simulation model of SystemC involves three 
blocks including “Stimulus”, “HW/SW” and “Monitor” [11]. 
The “Stimulus” is responsible for reading the test input file 
and passing the test patterns at each clock cycle to “HW/SW” 
which contains the system description and the “Monitor” 
records systems’ outputs. Because all of the three blocks are 
established upon the C/C++ platform, every signal and 
input/output port in real hardware can be viewed as a variable 
in high-level language. If a certain signal is selected to be the 
fault or error injection target, its value can be altered 
arbitrarily by declaring its scope as global. According to this 
principle, we append another block called “Error injection 
file” to construct our error simulation model as shown in Fig. 
1. This file specifies the information for each error injection 
including the injection time instant, injection target, error 
type and the error duration. Once the simulation time reaches 
the injection time of an error, the erroneous value will replace 
the content of the corresponding port or signal. 
Test input
file
Fault
Injection
File 
stimulus HW/SW Monitor
clk
clk
clk clk
SystemC main
Output
files
Error
 
Fig. 1: Error simulation model. 
A. Timing Model of SystemC 
In SystemC, each process will be triggered by certain 
events. Each event is assigned to a virtual time delay ∆. 
10ns 30ns20ns 40ns 50ns
1Δ
2Δ
1Δ
 
Fig. 2: Virtual timing model and ∆ delay of SystemC. 
The ∆ is used to illustrate the relation between cause and 
effect of real hardware components. As Fig. 2 depicts, there is 
an event triggered at 20ns, and this event will activate the 
second event at 20+1∆ ns. Then the second event further 
activates the third event at 20+2∆ ns, and so on. Such ripple 
effect will persist until no more events happen for current 
iteration.  
Due to the ∆ delay, the following situation will result in 
the error injection fail: Assume an error is injected into an 
ALU output at 20 ns and this error will be propagated to the 
next stage at 30 ns. However, ALU is triggered until 20+2∆ 
ns such that the error injected at 20 ns will be overwritten by 
the new result. Thus, the error injected becomes ineffective. 
To solve this problem, each component that could be an 
injection target needs modifying as illustrated in Fig. 3. 
ALU_in_A
ALU_in_B ALU M
U
X
Erroneous 
value
aluout
flag
M
U
X
 
Fig. 3: A modified ALU block for error injection. 
We declare the ‘flag’ and ‘Erroneous value’ in Fig. 3 as 
global variables so that we can control their values easily. Fig. 
4 is an error injection file with flag insertion. Once the 
simulation time reaches 90 ns, the flag will be set to one, and 
the multiplexer will choose the erroneous value as the output. 
The flag will return to zero at 110 ns and at that time the ALU 
block restores to its normal operation. In this case, the error 
duration is 20 ns. 
#include “error_injection_file.h"
#include “system_top.h"
extern systemc_top S1 ;
void Error_in::prc_error_in() {
run_time = sc_simulation_time() ;
switch(run_time) {
case 90 : {
S1.ALU_top_unit->ALU->flag.write(1) ;
S1.ALU_top_unit->ALU->erroneous_value = 1001987144 ;
} break ;
case 110 : {
S1.ALU_top_unit->ALU->flag.write(0) ;
} break ;
}
}
 
Fig. 4: An error injection file example. 
Although this methodology will modify the original 
component description, the modification is very slight. 
Furthermore, the insertion of flags and multiplexers can be 
performed automatically due to its regularity, thus there is no 
additional burden to designers. In addition, this methodology 
can apply to not only ALU but also any other functional 
blocks and storage elements. We have integrated this error 
injection process into our development and verification 
framework for the validation of the fault-tolerant systems. We 
describe the framework next.  
B. Development and Verification  framework  
SystemC code
(Original)
Verified ?
SystemC code
(Fault tolerant)
Insert error-injection-
assisted flag and multiplexer 
to specified components
Error simulation Error free simulation
Error coverage
analysis
Use error injection 
tool to generate
error injection files
Testbench
Modify 
fault-tolerant
algorithm 
Desired ?
Synthesize to
RTL
Failure sensitivity
analysis
Yes
No
Yes
No
 
Fig. 5: Development and Verification framework. 
Fig. 5 shows the framework to develop and validate the 
fault-tolerant systems based on SystemC platform. After the 
 14
 ;;1;
det
det
det
det
det
det
−
−−−−−−−−−− =−===
e
rece
receunsf
e
e
e
e
esce
unsf
N
NCP
N
NC
N
NP     (1) 
;detdet
det
det
det
det ;; unsfterecunsf
e
unsfnrece
unsft
e
sfnrece
sft PCP
N
NP
N
NP −−−−−−
−
−−−−−−
−
−−−−−− ×===
 (2) 
;;; detdetdetdet receeerecunsfunsfunsfsftesf CCCPPPPCP −−−−−−−−−−−− ×=+=×=
unsfnrecesfnrecereceeesceee NNNNNNN −−−−−−−−−−− ++=+= detdetdet ;     (3) 
errors detected correct
fail-safe
Ce-det
Pf-uns-det
fail-unsafe
Pt-det-f-uns
Ce-rec
Pt-det-f-s
          
OR
Out
F
B
A 5
-1
-
2
1
5
+
4
3
7
7
Fault duration
Error duration
20ns 30ns 40ns 50ns 60ns  
Fig. 8: Predicate graph of fault-tolerant mechanism.     Fig. 9: Fault duration and error duration for an ALU example. 
 
Fig. 8 illustrates the error handling process in our 
fault-tolerant system. From Fig. 8, if errors occur, the system 
could enter one of the following states: ‘correct’, ‘fail-safe’ 
and ‘fail-unsafe’ states. 
C. Experimental Setup 
Three benchmarks including N! (N = 10), 5×5 matrix 
multiplication, and  have been applied to generate 
the testbench by copying each benchmark program four times 
and then combine the twelve programs in random sequence. 
We first perform the fault simulation based on VHDL 
simulation platform comprising a simulated fault injection 
tool, ModelSim VHLD simulator and data analyzer. The 
common rules of fault injection campaigns are: 1) value of a 
fault is selected randomly from the s-a-1 and s-a-0; 2) 
injection targets cover the entire ‘EXE’ stage as shown in Fig. 
7. The common data of fault injection parameters are: α=1 
(useful-life), failure rate (λ) = 0.001, probability of permanent 
fault occurrence = 0, fault duration = 5 clock cycles. To 
generate various fault scenarios, we inject 100, 500, 1000, 
1500 and 2000 faults for each injection campaign to represent 
from slight to serious fault environments. Likewise, various 
error scenarios are also generated similarly. There are still 
two parameters required to be determined; one is the 
 and the other is error duration. For the former we 
give an initial value 0.6. For the latter, each error will choose 
one value between one and four clocks. The reason is 
described as follows: 
∑
=
×5
1
2
i
ii BA
etofP −−
Fig. 9 shows an ALU waveform and the notations ｀A＇, 
｀B＇ and ｀F＇ represent the inputs involving two 
operands and specified operation respectively, and ｀Out＇ 
represents the operating result. As exhibited in Fig. 9, a fault 
is injected into the adder at 30 ns; therefore, the operating 
result is incorrect because the addition operation is affected 
by this fault. However, the OR operation is still correct 
because no fault is injected into the logical operator. This 
situation causes the un-equivalence between the fault duration 
and error duration. It is worthy to note that the error duration 
will be always equal to or smaller than the fault duration. 
That’s why we don’t apply the error duration to a constant.  
D. Analysis and Discussion of Simulation Results 
Table 1 illustrates the difference in error coverage between 
VHDL and System C simulation results. The difference is 
represented as the deviation calculated by the following 
expression: 
%100(%) ×−=
VHDL
VHDLSystemCDeviation    (4) 
Table 1: The deviation between SystemC and VHDL design 
environments. 
 16
and  for their own error simulation to gain a better 
quality of simulation results.  
etofP −−
ACKNOWLEDGEMENTS 
The authors would like to thank Shang-Yu Tao for his help 
in generating experimental results and acknowledge the 
support of the National Science Council, Republic of China, 
under Contract No. NSC 95-2221-E-216-015. 
REFERENCES 
[1] C. Constantinescu, “Impact of Deep Submicron 
Technology on Dependability of VLSI Circuits,” IEEE Intl. 
Conf. On Dependable Systems and Networks (DSN’02), pp. 
205-209, 2002. 
[2] P. Shivakumar et al., “Modeling the Effect of Technology 
Trends on the Soft Error Rate of Combinational Logic,” 
DSN’02, pp. 389-398, 2002. 
[3] T. Karnik, P. Hazucha, and J. Patel, “Characterization of 
Soft Errors Caused by Single Event Upsets in CMOS 
Processes,” IEEE Trans. on Dependable and Secure 
Computing, Vol. 1, No. 2, pp. 128-143, April-June 2004. 
 
[4] D. M. Blough et al., “Fault Tolerance in Super-scalar and 
VLIW Processors,” IEEE Workshop on Fault Tolerant 
Parallel and Distributed Systems, pp. 193-200, 1992. 
[5] N. Saxena et al., “Error Detection and Handling in a 
Superscalar, Speculative Out-of-Order Execution 
Processor System,” 25th IEEE FTCS, pp. 464-471, 1995. 
[6] A. P. Pawlovsky and M. Hanawa, “A Concurrent Fault 
Detection Method for Superscalar Processors,” IEEE 
ATS’92, pp.139-144, 1992. 
[7] N. Quach, “High Availability and Reliability in The 
Itanium Processor,” IEEE Micro, Vol. 20, issue: 5, pp. 
61-69, September-October 2000. 
[8] Ward, P.C.; Armstrong, J.R.;” Behavioral fault simulation 
in VHDL”, Design Automation Conference, 1990. 
Proceedings. 27th ACM/IEEE 24-28 June 1990 
Page(s):587 – 593 
[9] A. L. White, “Transient Faults and Network Reliability”, 
IEEE Aerospace Conference, pp. 78-83, 2004. 
[10] Ejlali, A.; Miremadi, S.G.; Zarandi, H.; Asadi, G.; Sarmadi, 
S.B.; “A Hybrid Fault Injection Approach Based on 
Simulation and Emulation Co-operation”, Dependable 
Systems and Networks, 2003. Proceedings. 2003 
International Conference on 22-25 June 2003 
Page(s):479 – 488. 
[11] Open SystemC Initiative (OSCI), “SystemC 2.0 Language 
Reference Manual”, Revision 1.0, www.systemc.org, 
2003. 
[12] Rothbart, K.; Neffe, U.; Steger, Ch.; Weiss, R.; Rieger, E.; 
Muehlberger, A.;” High level fault injection for attack 
simulation in smart cards”, Test Symposium, 2004. 13th 
Asian 15-17 Nov. 2004 Page(s):118 – 121 
[13] A. Fin, F. Fummi, G. Pravadelli, “AMLETO: a 
Multilanguage environment for functional test generation”, 
Test Conference, 2001. Proceedings. International , 30 
Oct.-1 Nov. 2001, Pages:821 – 829. 
[14] S. Chiusano, S. Di Carlo, P. Prinetto, “Automated 
synthesis of SEU tolerant architectures from OO 
descriptions”, On-Line Testing Workshop, 2002. 
Proceedings of the Eighth IEEE International , 8-10 July 
2002, Pages:26 – 31. 
[15] Yung-Yuan Chen, Kuen-Long Leu, and Chao-Sung Yeh, 
“Fault-Tolerant VLIW Processor Design and Error 
Coverage Analysis”, International Conference, EUC 2006 
Seoul, Korea, August 2006 Proceeding, pp. 754-765. 
 18
行政院國家科學委員會補助國內專家學者出席國際學術會議報告 
                                                             95 年 08 月 17 日 
報告人姓名  陳永源 
 
服務機構
及職稱 
 
中華大學資訊工程學系 
副教授 
 
     時間 
會議 
     地點 
08 月 01-04, 2006 
韓國首爾 
本會核定
補助文號
 
NSC 95-2221-E-216-015 
會議 
名稱 
 (中文) 
 (英文) The 2006 IFIP International Conference on Embedded And 
Ubiquitous Computing 
發表 
論文 
題目 
 (中文) 
 (英文) Fault-Tolerant VLIW Processor Design and Error Coverage Analysis 
附件三
 
表 Y04 
E. Sha et al. (Eds.): EUC 2006, LNCS 4096, pp. 754 – 765, 2006. 
© IFIP International Federation for Information Processing 2006 
Fault-Tolerant VLIW Processor Design and Error 
Coverage Analysis 
Yung-Yuan Chen, Kuen-Long Leu, and Chao-Sung Yeh 
Department of Computer Science and Information Engineering 
Chung-Hua University, Hsin-Chu, Taiwan 
chenyy@chu.edu.tw 
Abstract. In this paper, a general fault-tolerant framework adopting a more rigid 
fault model for VLIW data paths is proposed. The basic idea used to protect the 
data paths is that the execution result of each instruction is checked immediately 
and if errors are discovered, the instruction retry is performed at once to 
overcome the faults. An experimental architecture is developed and implemented 
in VHDL to analyze the impacts of our technique on hardware overhead and 
performance degradation. We also develop a comprehensive fault tolerance 
verification platform to facilitate the assessment of error coverage for the 
proposed mechanism. A paramount finding observed from the experiments is 
that our system is still extremely robust even in a very serious fault scenario. As a 
result, the proposed fault-tolerant VLIW core is quite suitable for the highly 
dependable real-time embedded applications.  
1   Introduction 
In recent years, VLIW processor has become a major architectural approach for 
high-performance embedded computing systems. Several notable examples of VLIW 
are Intel and HP IA-64 [1], TI TMS320C62x/67x DSP devices and Fujitsu FR500. As 
processor chips become more and more complicated, and contain a large number of 
transistors, the processors have a limited operational reliability due to the increased 
likelihood of faults or radiation-induced soft errors especially when the chip fabrication 
enters the deep submicron technology [2]. Also indicated specifically in [3], it is 
expected that the bit error rate in a processor will be about ten times higher than in a 
memory chip due to the higher complexity of the processor. And a processor may 
encounter a bit flip once every 10 hours. Thus, it is essential to employ the fault-tolerant 
techniques in the design of high-performance superscalar or VLIW processors to 
guarantee a high operational reliability in critical applications. Recently, the reliability 
issue in high-end processors is getting more and more attention [3-9].  
The previous researches in reliable microprocessor design are mainly based on the 
concept of time redundancy approach [3-9] that uses the instruction replication and 
recomputation to detect the errors by comparing the results of regular and duplicate 
instructions. The instruction replication, recomputation schedule and result comparison 
of regular and duplicate instructions can be accomplished either in software level − 
source code compilation phase to generate redundant code for fault detection [4], [7], 
[8] or in hardware level [3], [5], [6], [9]. In [7], [8], the authors adopted software 
756 Y.-Y. Chen, K.-L. Leu, and C.-S. Yeh 
efficiency to recover the errors. Overall, the design concern here is to propose a 
fault-tolerant VLIW core for the highly dependable real-time embedded applications. 
However, we note that due to the more rigid fault model and severe fault situations 
considered, it requires developing a more powerful fault-tolerant scheme to raise the 
system reliability to a sound level. 
A VLIW processor core may possess several different types of functional modules in 
the data paths, such as integer ALU and load/store units. A couple of identical modules 
are provided for a specific functional type. We assume that the register file is protected 
by an error-correcting code. In the following, we present the main ideas employed in 
our scheme to detect and recover errors occurring in the data paths and then use three 
identical modules to demonstrate our fault-tolerant approach.  
2.1   Concurrent Error Detection and Real-Time Error Recovery 
We note that the length of error recovery time mainly depends on the error-detection 
latency. Hence, the error-detection scheme has a significant impact on the efficiency of 
the error recovery. Most of the previous studies may suffer the lengthy error recovery 
because the execution results of each instruction cannot be checked immediately. 
Therefore, to achieve the real-time error recovery, the execution results of each 
instruction must be examined immediately and if errors are found, the erroneous 
instruction is retried at once to overcome the errors. So, the error-detection problem can 
be formalized as how to verify the execution results instantly for each instruction, i.e. 
how to achieve no error-detection latency. We develop a simple concurrent 
error-detection (CED) scheme, which combines the duplication with comparison, 
henceforth referred to as comparison, and majority voting methodologies to solve the 
above error-detection problem. 
CED Scheme. The following notations are developed 
z n : Number of identical modules for a specific functional type (we call it type x). n  
is also the maximum number of instructions that can be executed concurrently in the 
modules of type x; 
z s : Number of spare modules added to the type x, s ≥ 0; 
z m : Number of instructions in an execution packet for type x, m ≤ n . 
An execution packet is defined as the instructions in the same packet can be 
executed in parallel. There are sn +  modules for type x. As we know, if 
snm +>× 2 then it is clear that the system won’t have the enough resources to check 
the instructions of an execution packet concurrently. Under the circumstances, the 
current execution packet needs to be partitioned into several packets that will be 
executed sequentially. Given an execution packet, there are three cases to consider: 
Case 1: snm +=× 2 . In this case, each instruction can be checked by the comparison 
scheme.  
Case 2: snm +<× 2 . We can divide the instructions into two groups: G(1) and G(2). 
There are 1m instructions and 2m
 
instructions in G(1) and G(2) respectively, where 
mmm =+ 21 , 0, 21 ≥mm . Each instruction in G(1) and G(2) can be examined by the 
758 Y.-Y. Chen, K.-L. Leu, and C.-S. Yeh 
represented as {TMR_x(1, 2, 3), …, TMR_x(1, 2, sn + ), …, TMR_x(1, 1−+ sn , 
sn + ), TMR_x(2, 3, 4), …, TMR_x(2, 1−+ sn , sn + ), …, TMR_x( 2−+ sn , 
1−+ sn , sn + )}, where 3≥+ sn . It is clear that selecting the TMR_x(1, 2, 3) 
constantly for each retry, for example, is the simplest approach, which has the 
advantage of simple implementation but can only tolerate one faulty module during  
the recovery process. In contrast to that, selecting elements one by one based on the 
element sequence in S_TMR for the retries is the highly complicated approach. Such an 
approach suffers from the high implementation cost, but on the other hand it can 
tolerate 2−+ sn  faulty modules if we set ≥nor _ ⎟⎟⎠
⎞
⎜⎜⎝
⎛ +
3
sn
. The remaining question in 
the design of selection policy for TMR retry is how to compromise between the 
implementation complexity and the number of faulty modules being tolerated. A sound 
selection policy for TMR retry is presented next. 
Selection Policy. On the basis of the above discussion, a set named SS_TMR, a subset 
of S_TMR, is created to guide the instruction-retry process. SS_TMR is given below: 
SS_TMR= {TMR_x( i , 1+i , 2+i ), where 21 −+≤≤ sni }. As seen from 
SS_TMR, the proposed retry process possesses a high regularity in its selection policy. 
So, it is easy to implement the SS_TMR policy compared to the S_TMR. 
After the analyses for some values of n and s, we decide to adopt the SS_TMR 
selection policy due to the following reasons: first, we note that the probability of three 
or more modules failed concurrently should be low; second, most of the faults are 
transient type, which may disappear during the recovery process; and last one is the low 
implementation complexity compared to the S_TMR policy. From the first two 
reasons, we can infer that both selection policies have the similar fault tolerance 
capabilities. It is evident that the SS_TMR selection policy can utilize the module 
resources efficiently so as to recover the errors in a short time. Thus, the program 
execution can continue without lengthy error-recovery process. In summary, our 
error-recovery scheme can provide the capability of real-time error recovery, which is 
particularly important for the applications demanding the reliable computing as well as 
real-time concern. 
2.2   Reliable Data Path Design: Case Study 
In the following illustration, without loss of generality, we assume only one type of 
functional module, namely ALU, in the data paths. In this case study, the original 
VLIW core contains three ALUs ( 3=n ) and therefore, three ALU instructions can be 
issued at most per cycle. A spare ALU ( 1=s ) is added to prevent the severe 
performance degradation as explained below. From CED scheme described in Section 
2.1, we note that if no spare is added then 2=m  or 3 execution packets will fall into 
Case 3. Consequently, the performance may be degraded significantly. Hence, the cost 
of a spare is paid to lower the performance degradation. Clearly, adding three spares in 
order to eliminate the performance degradation completely is not a feasible choice.  
According to CED scheme with 3=n  and 1=s , 1=m  falls into Case 2. The 
( 21,mm ) can be (1, 0) or (0, 1). Clearly, (1, 0) is selected as the final solution. So, if an 
execution packet contains only one ALU instruction then it will be checked by TMR 
760 Y.-Y. Chen, K.-L. Leu, and C.-S. Yeh 
of demonstration, the proposed approach does not apply to the load/store units; • a 
register file containing thirty-two 32-bit registers with 12 read and 6 write ports is 
shared with modules and designed to have bypass multiplexors that bypass written data 
to the read ports when a simultaneous read and write to the same entry is commanded; • 
data memory is 1K x 32 bits. The structure consists of five pipeline stages: ‘instruction 
fetch and dispatch’, ‘decode and operand fetch from register file’, ‘execution’, ‘data 
memory reference’ and ‘write back into register file’ stages. This experimental 
architecture can issue at most three ALU and three load/store instructions per cycle. 
Note that the ‘Error Analysis’ block in execution stage, which was created only to 
facilitate the measurement of the error coverage during the fault injection campaign, is 
not a component for the VLIW processor displayed in Figure 1.  
A fault-tolerant VLIW processor based on the architecture of Figure 1 and the 
features mentioned previously was realized in VHDL. The implementation data by 
UMC 0.18μm process are shown in Table 1. The area does not include the instruction 
memory as well as the ‘Error Analysis’ block. For performance consideration, we 
require that the clock frequency of the fault-tolerant VLIW processor must retain the 
same as that of non fault-tolerant one. It is worth noting that the overhead of 
‘ALU_Control’ unit is only 0.26 percent compared to the area of the non fault-tolerant 
VLIW core. This implies that the control task of our scheme is simple and easy to 
implement. The performance degradation caused from the CED demand is between 
0.6% and 34.3% for eight benchmark programs, including heapsort, quicksort, FFT, 
5×5 matrix multiplication and IDCT (8×8) etc.. 
Instruction D
ispatch
Shared R
egister File
Select
D
ata M
em
ory
Sel
Sch_sel
Func_2
Func_4
Func_3
Select_sel
Safe failure
Func_1
Instruction Partition
Forw
arding
Error_signal
N
ext sequential
Jum
p address
B
ranch address
Extra-slot Idle
 
Fig. 1. Fault-tolerant VLIW architecture 
762 Y.-Y. Chen, K.-L. Leu, and C.-S. Yeh 
The design metrics as described below are exploited to justify our approach: 
z unsfP − : Probability of system entering the fail-unsafe state; 
z det−eC : Error-detection coverage, i.e. probability of errors detected; 
z receC − : Error-recovery coverage, i.e. probability of errors recovered 
given errors detected; 
z eC : Error coverage, i.e. probability of errors detected and recovered; 
z sfP − : Probability of system entering the fail- safe state; 
z sftP −−− det : State transition probability from ‘detected’ state to 
‘fail-safe’ state. 
z unsftP −−− det : State transition probability from ‘detected’ state to 
‘fail-unsafe’ state. 
z det−− unsfP : Probability of system entering the fail-unsafe state due to the 
detection defects stated earlier; 
z recunsfP −− : Probability of system entering the fail-unsafe state due to the 
recovery defects stated earlier; 
The parameters eN , det−eN , det−− esceN , receN − , sfnreceN −−−  and 
unsfnreceN −−−  (called the error-related parameters) represent the total number of 
errors occurred, the number of errors detected, the number of errors escape being 
detected, the number of errors recovered, the number of errors not recovered and 
system enters the ‘fail-safe’ state and the number of errors not recovered and system 
enters the ‘fail-unsafe’ state, respectively. The design metrics can be expressed as 
follows 
.;1;
det
det
det
det
det
det
−
−
−−−
−
−
−−
−− =−===
e
rece
receunsf
e
e
e
e
esce
unsf
N
NCP
N
NC
N
NP      (1) 
.detdet
det
det
det
det ;;
unsfterecunsf
e
unsfnrece
unsft
e
sfnrece
sft
PCP
N
NP
N
NP
−−−−−−
−
−−−
−−−
−
−−−
−−−
×=
==
      (2) 
.det
detdetdet
detdetdet
;;
;;
unsfnrecesfnrecerecee
esceeereceee
recunsfunsfunsfsftesf
NNNN
NNNCCC
PPPPCP
−−−−−−−−
−−−−−
−−−−−−−−−−
++=
+=×=
+=×=
        (3) 
errors detected correct
fail-safe
Ce-det
Pf-uns-det
fail-unsafe
Pt-det-f-uns
Ce-rec
Pt-det-f-s
 
Fig. 2. Predicate graph of fault-tolerant mechanism 
764 Y.-Y. Chen, K.-L. Leu, and C.-S. Yeh 
0.955
0.96
0.965
0.97
0.975
0.98
0.985
0.99
0.995
1
100 500 1000 1500 2000
Number of faults
Ce-det
Ce-rec
Ce
0
0.0025
0.005
0.0075
0.01
0.0125
0.015
0.0175
0.02
0.0225
0.025
100 500 1000 1500 2000
Number of faults
Pf-s
Pf-uns
 
   (a)          (b) 
Fig. 3. Fault-tolerant metric analysis. (a) coverage. (b) probabilities of fail-safe and fail-unsafe. 
5   Conclusions 
This paper presents a new fault-tolerant framework for VLIW processors that focuses 
mainly on the reliable data path design. Based on a more rigid fault model, a CED and 
real-time error recovery scheme is proposed to enhance the reliability of the data paths. 
Our approach provides the design compromise between hardware overhead, 
performance degradation and fault tolerance capability. This framework is quite useful 
in that it can give the designers an opportunity to choose an appropriate solution to meet 
their need. Several significant contributions of this study are: 1. Integrate the error 
detection and error recovery into VLIW cores with reasonable hardware overhead and 
performance degradation. It is worth noting that the proposed fault-tolerant framework 
can achieve no error-detection latency and real-time error recovery. Consequently, our 
scheme is suitable for the real-time computing applications that demand the stringent 
dependability. 2. Conduct a thorough fault injection campaigns to assess the 
fault-tolerant design metrics under a variety of fault environments. Importantly, we 
provide not only the error-detection and error-recovery coverage, but also the fail-safe 
and fail-unsafe probabilities. Acquiring the fail-unsafe probability is crucial for us to 
understand how much possibility the system could fail without notice once the errors 
occur. Moreover, a couple of fault environments, which represent the various degrees of 
fault’s severity, were constructed to validate our scheme so as to realize the capability of 
our scheme in different fault scenarios. So, such experiments can give us more realistic 
and comprehensive simulation results. The effectiveness of our mechanism even in a 
very severe fault environment is justified from the experimental results.  
Acknowledgments. The authors acknowledge the support of the National Science 
Council, Republic of China, under Contract No. NSC 92-2213-E-216-005 and NSC 
93-2213-E-216-019. 
References 
1. Huck, J. et al.: Introducing the IA-64 Architecture. IEEE Micro, Vol. 20, issue: 5, pp. 12-23, 
Sep.-Oct. 2000. 
2. Karnik, T., Hazucha, P., Patel, J.: Characterization of Soft Errors Caused by Single Event 
Upsets in CMOS Processes. IEEE Trans. on Dependable and Secure Computing, Vol. 1, 
issue: 2, pp. 128-143, April-June 2004. 
