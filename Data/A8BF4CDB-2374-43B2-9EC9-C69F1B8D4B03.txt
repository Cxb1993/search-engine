行政院國家科學委員會專題研究計劃成果報告 
加權式自動機平台開發及應用應用 
97-2221-E-002-095-MY3 
  (完整報告) 
執行期間:97 年 8 月 1 日至 100 年 7 月 31 日 
計畫主持人: 顏嗣鈞 教授 國立台灣大學電機工程系 
中文摘要: 
 
「加權式自動機」(Weighted Automata)為「有限自動機」 (Finite Automata)
的延伸. 它的歷史十分悠久, 文獻中也可發現許多理論方面的結果. 近年來加
權式自動機的各種應用逐漸出現, 使得它的相關領域又開始熱門起來, 同時也
顯示出此一研究課題的重要性. 為了更有效地支援加權式自動機的各式應用, 
對於加權式自動機的軟體實驗平台的需求,也與日俱增.我們規劃的工作項目包
括探討加權式自動機的本質與特性, 並能對這個數學模型加以延伸加強.同時提
供例如應用在自動化驗證、離散事件系統分析等現實議題,展現加權式自動機在
解決上述問題中,所能扮演的角色. 
 
 
在此三年期研究計畫中， 主持人探討加權式自動機相關問題，獲得許多具體成果。
在接下來的報告中，我們將對於研究成果逐一敘述。 
Main contributions
• Publication # 1:
O. Ibarra, H. Yen, On the Containment and Equivalence Problems
for Two-way Transducers, accepted for publication in Theoretical
Computer Science, 2011.
Equivalence and containment are two fundamental problems that have been
investigated extensively over the years for a wide variety of automata. These
two problems are not only of interest and importance theoretically, they play
equally critical roles in various application areas, including formal verification of
hardware/software systems, supervisory control of discrete event systems, among
many others.
For finite transducers, it is known that the equivalence problem for two-way
deterministic finite transducers (2DFTs, for short) is decidable. However, if non-
determinism is allowed, the problem becomes undecidable even for one-way non-
deterministic finite transducers (1NFTs, for short). Such an undecidability result
was shown to hold even for 1NFTs operating on a unary input (or output) alpha-
bet. For single-valued 1NFTs, the problem becomes decidable, and the decid-
ability result was later extended to finite-valued 1NFTs. A complexity bound of
deterministic double exponential time was subsequently derived for finite-valued
1NFTs.
In this paper, we generalize previous results for some models of two-way
transducers with auxiliary memory. We consider two-way transducers, i.e., two-
way finite automata (with input end markers # and $) augmented with reversal-
bounded counters and a one-way output tape. Call the nondeterministic (resp.,
deterministic) version 2NCMT (resp., 2DCMT). The relation defined by such a
transducer A is R(A) = {(x,y) | A, when started in its initial state on the left end
marker of #x$, outputs y and falls off the right end marker in an accepting state}.
The transducer is finite-crossing if there is some fixed k such that in every accept-
ing computation on any input #x$, the number of times the input head crosses
the boundary between any two adjacent symbols of #x$ is at most k. Note that
the number of turns (i.e., changes in direction from left-to-right and right-to-left
and vice-versa) the input head makes on the input may be unbounded. Also note
that the requirement is only for accepting computations. So if R(A) = /0, then A
1
2DPCMT A, whether R(A) = /0, even when A makes only two turns on the input.
However, we show:
5. It is decidable to determine, given two finite-crossing 2DPCMTs whose
inputs come from a bounded language (i.e., fromw∗1 · · ·w∗k for some non-null
strings w1, . . . ,wk) A1 and A2, whether R(A1)⊆ R(A2). (Hence, equivalence
is also decidable.)
The proofs for the results above use the decidability of emptiness for a large
class of acceptors, called 3-phase finite-crossing 2NPCMs, which we introduce
in this work. We show that it is decidable to determine, given a 3-phase finite-
crossing 2NPCM M, whether the language it accepts is empty.
It should also be noted that, as we shall see later, the assumption of A2 being
“deterministic” in (1) - (4) above is required. In fact, the equivalence problem
is known to be undecidable even for one-way nondeterministic finite transducers
(1NFTs).
As “single-valuedness” is a natural extension of the notion of determinism and
equivalence of single-valued 1NFTs (i.e., 1NFTs that output at most one value
for every input) is decidable, we also study containment and equivalence between
single-valued finite-crossing two-way nondeterministic finite transducers (2NFTs)
and various finite-crossing two-way transducers with auxiliary memory. We show
the following to be decidable:
6. Given a finite-crossing 2NCMT (or a 1NPCMT) A1 and a single-valued
finite-crossing 2NFT A2, is R(A1)⊆ R(A2)?
7. Given a single-valued finite-crossing 2NFT A1 and a finite-crossing 2DCMT
(or a 1DPCMT) A2, is R(A1)⊆ R(A2)?
8. Given a single-valued finite-crossing 2NFT A1 and a finite-crossing 2DCMT
(or a 1DPCMT) A2, is R(A1) = R(A2)?
• Publication # 2:
H. Yen, On Almost-Sure Properties of Probabilistic Discrete Event
Systems. Fundam. Inform. 110(1-4): 343-359, 2011.
3
able amount of work focusing on Markov chains and Markov decision processes.
As our control policy is history-dependent, our model can be viewed as an infinite
Markov chain imposed with a scheduler picking some controllable events if nec-
essary. In a Markov decision process, on the other hand, states are partitioned into
nondeterministic and stochastic states and a scheduler can choose the next state
from those nondeterministic states to proceed. After resolving nondeterminism by
assigning probabilities to nondeterministic transitions, quantitative analysis found
in Markov chains can then be applied to analyzing the behaviors of Markov de-
cision processes. More will be said about the differences between our work and
that of Markov decision processes as our discussion progresses.
• Publication # 3:
O. Ibarra, I. Potapov, H. Yen, On Decision Problems for Parame-
terized Machines, Theoretical Computer Science, Vol. 411, 1192-
1201, 2010.
It is well-known that for deterministic pushdown automata, the equivalence
problem (given machines M1,M2, is L(M1) = L(M2)?) is decidable; hence the
universe problem (given a machine M, is L(M) = Σ∗?) is also decidable. For
nondeterministic pushdown automata, even the universe problem is undecidable
(we assume that at each step, the pushdown can only pop the top of the stack
or replace the top of the stack by at most two symbols). What if, for any fixed
positive integers s, t, we consider only machines with at most s states and at most
t symbols in the stack alphabet and the operation on the stack at each step can only
pop the top of the stack or replace the top of the stack by at most two symbols, but
the cardinality of the input alphabet is unrestricted? We are able to show that for
this class, the containment, equivalence, disjointness, as well as other common
problems are decidable. In fact, this result holds for two-way nondeterministic
pushdown automata.
The example above can be generalized. For any fixed positive integers s,m, t,
let C(s,m, t) be the class of nondeterministic multitape Turing machine (TM) ac-
ceptors with a two-way read-only input, at most s states, at most m read-write
worktapes, and at most t symbols in the worktape alphabet. Note that there is no
restriction on the cardinality of the input alphabet. The input tape has left and
right end markers, and on any input, the machine starts on the left end marker and
accepts if there is a computation that brings the input head to the right end marker
and the machine in an accepting state. We show the following:
5
problem undecidable. For example, if d is not a fixed parameter but varies for
different machines, the universe problem becomes undecidable, even for nonde-
terministic 5-state 1-counter machines with a one-way input whose counter makes
only one reversal (once the counter decrements, it can no longer increment). We
are then able to show that the universe problem is undecidable for one-way 6-
state 2-counter machines, where increments (resp., decrements) are not fixed but
decrements (resp., increments) are restricted to 1 and the counters make only one
reversal.
We also give a simple characterization of the languages defined by C(s,m, t).
Finally, we investigate the applicability of our techniques to machines with multi-
ple input heads or multiple input tapes.
As far as we know, this is the first paper that deals with decision questions
concerning parameterized machines. Many of the reductions for showing decid-
ability/undecidability results are subtle variations of classical techniques in com-
putability theory. As Turing machines and their variants are basic models upon
which many reductions in computability theory rely, we feel that our techniques
and (un)decidability results are not only of interest in their own right, but perhaps
more interestingly, may find applications in refining existing results and deriving
new results as well. As an example along a similar line of work, it is known
that the undecidability result holds even if one restricts the Diophantine equation
to have a fixed order and a fixed number of variables. Using this parameterized
version of the Diophantine equation, one can show the containment and equiva-
lence problems to be undecidable for vector addition systems (equivalently, Petri
nets) even if the dimension of the vector addition system (equivalently, the num-
ber of places of the Petri net) is fixed, which can be thought of as a refinement
of the Rabin’s undecidability results of the Petri net containment and equivalence
problems.
7
On the Containment and Equivalence Problems for
Two-way TransducersI
Oscar H. Ibarra1,∗
Dept. of Computer Science, Univ. of California, Santa Barbara, CA 93106, USA
Hsu-Chun Yen2
Dept. of Electrical Engineering, National Taiwan Univ., Taipei, Taiwan 106, ROC
Abstract
We look at some classes of two-way transducers with auxiliary memory and
investigate their containment and equivalence problems. We believe that our
results are the strongest known to date concerning two-way transducers.
Keywords: Two-way transducer, containment problem, equivalence problem.
1. Introduction
Equivalence and containment are two fundamental problems that have been
investigated extensively over the years for a wide variety of automata. These
two problems are not only of interest and importance theoretically, they play
equally critical roles in various application areas, including formal verification
of hardware/software systems, supervisory control of discrete event systems,
among many others.
For finite transducers, it is known that the equivalence problem for two-way
deterministic finite transducers (2DFTs, for short) is decidable [5]. However, if
nondeterminism is allowed, the problem becomes undecidable even for one-way
nondeterministic finite transducers (1NFTs, for short) [4]. Such an undecidabil-
ity result was shown to hold even for 1NFTs operating on a unary input (or
output) alphabet [10]. For single-valued 1NFTs, the problem becomes decidable
[7], and the decidability result was later extended to finite-valued 1NFTs in [3].
A complexity bound of deterministic double exponential time was subsequently
IA preliminary version of this work was presented at the 15th International Conference on
Developments in Language Theory, Milan, Italy, July 19-22, 2011.
∗Corresponding author.
Email addresses: ibarra@cs.ucsb.edu (Oscar H. Ibarra), yen@cc.ee.ntu.edu.tw
(Hsu-Chun Yen)
1Research supported in part by NSF Grants CCF-1143892 and CCF-1117708.
2Research supported in part by NSC Grant NSC-97-2221-E-002-095-MY3, Taiwan.
Preprint submitted to Theoretical Computer Science November 2, 2011
4. Given a finite-crossing 2DCMT A1 and a 1DPCMT A2, is R(A1) =
R(A2)?
We believe that these results are the strongest known to date concerning
containment and equivalence of transducers. We note that in the above results,
the “finite-crossing” assumption is necessary, since when the two-way input is
unrestricted, the equivalence problem becomes undecidable, as we shall see. We
also note that the 1NPCMT and 1DPCMT in (2), (3) and (4) above cannot be
generalized to be two-way, since we can show that it is undecidable to determine,
given a 2DPCMT A, whether R(A) = ∅, even when A makes only two turns
on the input. However, we show:
5. It is decidable to determine, given two finite-crossing 2DPCMTs whose
inputs come from a bounded language (i.e., from w∗1 · · ·w
∗
k for some non-
null strings w1, . . . , wk) A1 and A2, whether R(A1) ⊆ R(A2). (Hence,
equivalence is also decidable.)
The proofs for the results above use the decidability of emptiness for a large
class of acceptors, called 3-phase finite-crossing 2NPCMs, which we introduce
in Section 3. We show that it is decidable to determine, given a 3-phase finite-
crossing 2NPCM M , whether the language it accepts is empty.
It should also be noted that, as we shall see later, the assumption of A2
being “deterministic” in (1) - (4) above is required. In fact, the equivalence
problem is known to be undecidable even for one-way nondeterministic finite
transducers (1NFTs) [4, 10].
As “single-valuedness” is a natural extension of the notion of determin-
ism and equivalence of single-valued 1NFTs (i.e., 1NFTs that output at most
one value for every input) is decidable [3, 13], we also study containment and
equivalence between single-valued finite-crossing two-way nondeterministic fi-
nite transducers (2NFTs) and various finite-crossing two-way transducers with
auxiliary memory. We show the following to be decidable:
6. Given a finite-crossing 2NCMT (or a 1NPCMT) A1 and a single-valued
finite-crossing 2NFT A2, is R(A1) ⊆ R(A2)?
7. Given a single-valued finite-crossing 2NFTA1 and a finite-crossing 2DCMT
(or a 1DPCMT) A2, is R(A1) ⊆ R(A2)?
8. Given a single-valued finite-crossing 2NFTA1 and a finite-crossing 2DCMT
(or a 1DPCMT) A2, is R(A1) = R(A2)?
2. Preliminaries
A one-way nondeterministic reversal-boundedmulticounter machine (1NCM)
M is a one-way NFA augmented with multiple 1-reversal counters which are
initially set to zero. At each step, every counter can be incremented by 1,
decremented by 1, or left unchanged, and can be tested for zero. A zero counter
cannot be decremented. M is 1-reversal in that it has the property that once a
counter is decremented, it can no longer be incremented. A 1NCM augmented
3
Theorem 2. We can effectively construct, given a finite-crossing 2NCM M , a
1NCM M ′ such that L(M ′) = L(M). Hence, the emptiness problem for finite-
crossing 2NCMs is decidable.
Proof. Let M be k-crossing. Every accepting computation of M can be de-
scribed by a time-input graph which shows the sequence of transition rules used
during the computation (see Figure 1(a)). A node is at coordinate (ζ, µ) in the
graph if and only if it corresponds to the transition rule associated with the ζ-th
move in the computation and just before this move, the input head of M was
at the µ-th symbol of the string.
Now consider any accepting computation of M . Then a linear tree, say,
T , which describes the computation, can also be constructed (see Figure 1(b)).
Each move in T corresponds to an ordered set of at most k transition rules.
The i-th node in T is associated with the i-th symbol of the input string, say
ai, where the ordered set of transition rules are exactly those used to move the
input head from ai (in the given order).
Thus, in simulating an accepting computation of M , the 1NCM M ′ need
only nondeterministically determine a sequence of ordered sets of transition
rules, where the sequence (of these sets) corresponds to the linear tree which
describes the desired computation. Clearly, the number of distinct nodes in T
does not exceed sk, where s is the number of transition rules of M .
Note that if on an input symbol, e.g., on input a3 in Figure 1(a), the input
head stays on the symbol a finite (but an unbounded) number of times before
moving, e.g., in the figure, when the head returns to a3 from the right, it stays
on a3 with associated transition rule α9, and stays on this symbol and finally
moving right of symbol a3 with transition rule α10, M
′ need only guess and
keep α10 in the ordered set. This is because M
′ can nondeterministically guess
and verify that α10 is a successor of (i.e., came from) some α9 and can simulate
the changes in the states and in the counters (in a backward simulation) before
guessing the next ordered set of transition rules and when it does, it verifies
that α9 is compatible with new ordered set.
So, for example, when M ′ first reaches input symbol a3, it guesses the or-
dered set of transition rules α = (α3, α10, α14, α16). Before it can move to the
next input symbol a4, M
′ needs to stay on input symbol a3 and nondeterminis-
tically simulate backwards the computation of M while on symbol a3 (guessing
the predecessors and verifying and updating the appropriate counters as it goes
from predecessors to predecessors). Thus, the second component of α will keep
on changing until M ′ guesses to stop the backward simulation at transition rule
α9. (Note that the number of “stay” moves on input symbol a3 from α9 to
α10 can be unbounded.) When α9 is reached, α becomes α
′ = (α3, α9, α14, α16)
and the simulation can proceed to symbol a4, checking the compatibility of α
′
with the new guessed ordered set of transition rules β = (α4, α8, α11, α13, α17)
on input symbol a4.
Corresponding to each counter, say C, of M , the 1NCMT M ′ uses two
counters C1 and C2. Counter C1 is used to record the increases in C while C2 is
used to record the decreases in C. M ′ makes sure that in the simulation of M
5
then 5-crossing. However, as noted in [6], L cannot be accepted by any 1DCM or
by a 2DCM which makes a fixed number of turns on the input. Clearly, we can
construct a 5-crossing 2DCMT A from the 5-crossing 2DCM which outputs ε
on every move. The relation defined by A is then R(A) = L×{ε}, which cannot
be defined by any 1DCMT. Hence, finite-crossing 2DCMTs can define more
relations than 1DCMTs. Note that L can easily be accepted by a 1NCM (with
one 1-reversal counter) by just guessing and verifying, as it moves left-to-right
on the input x, the locations of the substrings of the form ayb in x.
Corollary 1. It is decidable to determine, given a finite-crossing 2NCM M1
and a 1NPCM M2, whether L(M1) ∩ L(M2) = ∅.
Proof. From Theorem 2, we construct a 1NCMM ′1 from finite-crossing 2NCM
M1 such that L(M
′
1) = L(M1). Then we construct a 1NPCM M which, on a
given input, simulates M ′1 and M2 in parallel. Then L(M1)∩L(M2) = ∅ if and
only if L(M) = ∅, which is decidable by Theorem 1. 2
3. 3-Phase Finite-Crossing 2NPCMs
We can generalize Theorems 1 and 2. Define a 3-phase finite-crossing 2NPCM
M which operates in three phases: In the first phase, M operates as a finite-
crossing 2NCM without using the stack. In the second phase, with the config-
uration (state, input head position, and counter values) the first phase left off,
M operates as a 1NPCM where the head can only move right on the input.
Finally, in the third phase with the configuration (state, head position, counter
values but not the stack) the second phase left off, M operates again as a finite-
crossing 2NCM without using the stack. It is possible that the machine has
only one or two phases. So, e.g., M can accept with only Phase 1, or with only
Phases 1 and 2. A 3-phase finite-crossing 2DPCM is one in which all phases are
deterministic.
We will need the following result for the proofs in the next section.
Theorem 3. It is decidable to determine, given a 3-phase finite-crossing 2NPCM
M , whether L(M) = ∅.
Proof. Assume that M has disjoint state set and input alphabet. Suppose M
has n counters. Let 0, 1 be new symbols. Define the following languages:
1. L1 = {q1
i01j10 · · · 01jnxp1s01k10 · · · 01kn | in Phase 1, M on input x
ends the phase in state q with the input head on position i of x and the
1-reversal counters with values j1, . . . , jn}.
2. L2 = {q1
i01j10 · · · 01jnxp1s01k10 · · · 01kn | in Phase 2, M when started in
state q with the input head on position i of x and the counters with values
j1, . . . , jn, ends the phase in state p with the input head on position s of
x and the 1-reversal counters with values k1, . . . , kn}.
7
at each step). When kn has been stored in C, M2 increments C by 1 (hence C
will have value kn+ 1) and moves the input head back to the left end marker.
Then M2 simulates M1 keeping track of the following situations:
1. If the input head remains on a symbol more than s steps without a counter
being decremented, then M1 is in an infinite loop. M2 moves the input
head to the right and falls off the right end marker in a rejecting state.
2. If the input head remains on a symbol more than k steps but with at least
one counter getting decremented during this time period, the simulation
continues.
3. Every time the input head moves right of a symbol or left of a symbol
(different from the left end marker a1), M2 decrements C.
4. If during the simulation C becomes zero, then M1 is in an infinite loop.
M2 moves the input head to the right and falls off the right end marker
in a rejecting state.
5. If M1 attempts to move left of a1 (the left end marker) or enters a con-
figuration where there is no next move, M2 moves the input head to the
right and falls off the right end marker in a rejecting state.
Since the counters are 1-reversal, when a counter becomes zero, it remains zero.
It follows that only the 5 situations above can happen. 2
Theorem 5. The following problems are decidable:
1. Given a finite-crossing 2NCMT A1 and a finite-crossing 2DCMT A2, is
R(A1) ⊆ R(A2)?
2. Given two finite-crossing 2DCMTs A1 and A2, is R(A1) = R(A2)?
Proof. Clearly, we only need to prove (1). We may assume (by adding extra
states if necessary) that A1 and A2 output ε or a single symbol per move. Let
M1 be the underlying finite-crossing 2NCM of A1 and M2 be the underlying
finite-crossing 2DCM of A2. Thus, L(M1) = domain(R(A1))
3 and L(M2) =
domain(R(A2)). By Lemma 1, we may assume that M2 always accepts or
rejects a given input. Clearly, R(A1) * R(A2) if and only if there exists an x
such that the following two conditions are satisfied:
(a) For some y, (x, y) is in R(A1), and
(b) x is not in domain(R(A2)), or x is in domain(R(A2)) and the only z such
that (x, z) is in R(A2) is different from y.
GivenA1,M1, A2,M2, we construct a finite-crossing 2NCMM such that L(M) 6=
∅ if and only if the conditions above are satisfied.
1. M stores a nondeterministically chosen number r in two special coun-
ters C1 and D1. (Thus, M increments these counters simultaneously r
times.) Then M simulates an accepting computation of A1 (suppressing
3For a binary relation R, domain(R) = {x | (x, y) is in R for some y}.
9
computation ofA and stores in counter C2 a position (again nondeterministically
selected) of a symbol b in this second accepting computation and makes sure
that a 6= b. When A accepts, M checks that counters C1 and C2 have the same
values by decrementing C1 and C2 simultaneously.
Clearly the above idea generalizes for any k. In this case, M nondeterminis-
tically simulates k + 1 accepting computations, say T1, . . . , Tk+1 of A on input
#x$ and verifies that these computations produce pair-wise distinct outputs
(without actually generating the outputs). M uses two 1-reversal counters to
check that two computations give different outputs (i.e., disagree on the output
symbols in some position). Thus, M uses a total of k(k+1) 1-reversal counters.
Then A is not k-valued if and only if L(M) 6= ∅, which is decidable by Theorem
2. 2
We also note that Theorem 5 cannot be generalized to the case when A1
or A2 has an unrestricted counter, even when the input head is constrained to
make only 2 turns, as the following result shows:
Proposition 4. There is a fixed 2DCAT (i.e., a 2DFA transducer with one
unrestricted counter) A which makes only 2 input head turns such that it is
undecidable to determine, given an arbitrary positive integer d, whether R(Ad) =
∅, where Ad is A with initial counter value d. (Thus, d is the only parameter
to the decision problem.)
Proof. It was shown in [11] (Theorem 9) that there is a fixed deterministic real-
time counter machineM and a fixed deterministic real-time counter machineM ′
such that it is undecidable to determine, given an arbitrary positive integer d,
whether L(Md) ∩ L(M
′) = ∅, where Md is M with initial counter value d.
(M ′ always starts with counter value 0.) The counters of the machines are
unrestricted.
Clearly, we can construct a fixed 2DCAT A that outputs ε at every step
which, with initial counter value d, simulates A and when it accepts, zeros out
the counter, returns the head to the left end marker and simulates M ′. Then
R(Ad) = (L(Md)∩L(M
′))×{ε}. It follows that it is undecidable to determine,
given Ad, whether R(Ad) = ∅. 2
We can generalize Theorem 5. A finite-crossing 2UDCMT A is a finite union
of finite-crossing 2DCMTs. Thus, R(A) = R(A1)∪· · ·∪R(An) for some n, where
Ai is a finite-crossing 2DCMT. We assume that the state sets of A1, . . . , An are
disjoint. Note that A is a special case of a 2NCMT in that the only nondeter-
ministic move of A is at the start of the computation: With its input head on
the left end marker, A outputs ε, remains on the end marker, and has a choice
of entering the initial state qi0 of A
i, i = 1, . . . , n.
Theorem 7. The following problems are decidable:
1. Given a finite-crossing 2NCMT A1 and a finite-crossing 2UDCMT A2, is
R(A1) ⊆ R(A2)?
11
(ii) z1 has the smallest stack height among all configurations in σ.
With respect to σ, consider the following two cases.
1. (Case 1): M1’s stack grows unbounded. In this case, consider a subse-
quence along which the height of the stack increases by at least r · s · t
symbols. Then a sub-computation σ′ : [q,Xα, c1, c2, ..., cm]
∗
⊢ [q,Xβα, c1+
∆1, c2+∆2, ..., cm+∆m] must exist, along which the stack never falls be-
low Xα. If test-for-zero is never applied to a counter with a positive gain
in its counter value along σ′, then the transition sequence of σ′ will repeat
forever, witnessing an infinite sequence of ε-moves.
2. (Case 2): M1’s stack remains bounded. As explained in Case 1, the in-
crease in stack height between two configurations along σ cannot exceed
rst; otherwise, M1’s stack grows unbounded. With t stack symbols, s
states, and the starting configuration z1 of σ having the smallest stack
height, from z1 any sequence of length longer than s(1+ t+ t
2+ · · ·+ trst)
(≤ s(t+1)rst) must contain a sub-computation σ′ : [q,Xα, c1, c2, ..., cm]
∗
⊢
[q,Xα, c1 + ∆1, c2 + ∆2, ..., cm +∆m], whose transition sequence can re-
peat forever provided that test-for-zero is never applied to a counter with
a positive gain in its counter value.
In view of Cases 1 and 2 above, an infinite sequence of ε-moves is guaranteed
if from configuration z1 one witnesses (i) the difference in stack height exceeds
rst (i.e., Case 1), or (ii) the length of the computation is longer than s(t+1)rst
(i.e., Case 2). The new 1DPCM M2 incorporates two finite counters X and Y
(initially set to rst and s(t+1)rst, resp.) in its finite state control to keep track
of the difference in stack height as well as the computation length, resp. The
values of X and Y are updated as the computation proceeds. During the course
of the computation, X and Y are ”reset” back to their initial values rst and
s(t + 1)rst, resp., if one of the following takes place: (1) a real input symbol
is read, (2) a counter is decremented, (3) a test-for-zero and subsequently an
increment are applied to the same counter, and (4) the stack height decreases.
The above ”resetting” is to ensure that checking the presence of the condition
in Case 1 or 2 begins with the proper suffix computation σ. If either X or
Y becomes zero, an infinite loop of ε-moves is detected. M2 then enters a
designated ”dead” (rejecting) state to consume the rest of the input symbols
before halting.
The above strategy is similar to that of showing the class of languages ac-
cepted by deterministic pushdown automata (DPDA) to be closed under com-
plementation (see pp. 235-239 in [8] for a proof). To complete our proof, one
also has to take care of the case when M1 gets stuck (i.e., without any legal
next moves) before consuming the entire input string, or after reading the input
string, M1 takes several ε-moves some of which reach accepting states while
others reach non-accepting states. Either case is easy to handle. 2
Lemma 3. We can effectively convert a 3-phase finite-crossing 2DPCM M1 to
an equivalent 3-phase finite-crossing 2DPCM M2 that always accepts or rejects
a given input.
13
3. Given a finite-crossing 2UDCMT A1 and a 1DPCMT A2, is R(A1) =
R(A2)?
Proof. Again, (3) follows from (1) and (2). The proof of (1) is similar to the
proof of part 1 of Theorem 7, but now M would be a 3-phase finite-crossing
2NPCM operating only with phases 2 and 3, and noting that emptiness of 3-
phase finite-crossing 2NPCM is decidable (Theorem 3). A similar construction
applies to (2), noting that, according to Lemma 2, the underlying 1DPCM of a
1DPCMT can always be converted to one that always accepts or rejects a given
input. The finite-crossingM will be a 3-phase finite-crossing 2NPCM operating
only with phases 1 and 2. We omit the details. 2
Parts (2) and (3) of Theorem 9 cannot be strengthened by generalizing the
1DPCMT to be a finite-crossing 2DPCMT as the following shows.
Proposition 5. There is a fixed 3-reversal 2DPDT (i.e., the stack makes only
3 reversals) which makes only 2 input head turns such that it is undecidable
to determine, given an arbitrary non-null string z, whether R(Az) = ∅, where
Az is A with initial stack content z. (Thus, the only parameter to the decision
problem is the initial stack content z.)
Proof. Theorem 5 in [11] showed that there is a fixed deterministic real-time
1-reversal 1DPDA M (i.e., the stack makes 1 reversal) and a fixed deterministic
real-time 1-reversal 1DPDA M ′ such that it is undecidable to determine, given
an arbitrary non-null string z, whether L(Mz) ∩ L(M
′) = ∅, where Mz is M
with initial stack content z. (M ′ always starts with a fixed stack symbol.) As
in Proposition 4. we can construct a fixed 3-reversal 2DPDA which with initial
stack content z, simulates M and when it accepts returns the head to the left
end marker and simulatesM ′. Then R(Az) = (L(Mz)∩L(M
′))×{ε}. It follows
that is undecidable to determine, given Az, whether R(Az) = ∅. 2
However, Theorem 9 generalizes for the case when the pushdown transducers
are 3-phase finite-crossing:
Theorem 10. The following problems are decidable:
1. Given a 3-phase finite-crossing 2NPCMT A1 and a finite-crossing 2UD-
CMT A2, is R(A1) ⊆ R(A2)?
2. Given a finite-crossing 2NCMT A1 and a 3-phase finite crossing 2DPCMT
A2, is R(A1) ⊆ R(A2)?
3. Given a finite-crossing 2UDCMT A1 and a 3-phase finite-crossing 2DPCMT
A2, is R(A1) = R(A2)?
Proof. Part (3) follows from parts (1) and (2). Part (2) has already been shown
in Theorem 8. Part (1) follows the ideas in the proof of part 1 of Theorem 9
(which, in turn, uses the ideas in the proof of part (1) of Theorem 7). 2
15
(2NFTs) in terms of the expressiveness, although they are more expressive than
1-way nondeterministic finite transducers (1NFTs).
As “variables” used in SSTs can be regarded as a form of auxiliary mem-
ory, it would be of interest to further investigate the relationship between two-
way (finite-crossing) transducers augmented with auxiliary memory and SSTs
with respect to the expressiveness as well as various decision problems. As was
pointed out earlier, the relation T = {(xdk, y) | x ∈ Σ+, k > 0, |x| ≥ 2k, x =
x1x2x3, |x1| = |x3| = k, y = x3x2x1}, where d is a symbol not in alphabet Σ
can be implemented on a finite-crossing 2DCMT, but cannot be implemented on
a 2DFT. Hence, finite-crossing 2DCMTs are more expressive than deterministic
SSTs, as the latter are equivalent to 2DFTs. The relationship between nonde-
terministic SSTs and various 2-way (finite-crossing) transducers with auxiliary
memory remains unknown.
Acknowledgment: The authors thank the anonymous referees for comments
that improved the presentation of this paper.
References
[1] R. Alur and P. Cerny. Expressiveness of streaming string transducers. Proc.
30th Annual Conf. on Foundations of Software Technology and Theoretical
Computer Science, pp. 1-12, 2010.
[2] R. Alur and J. Deshmukh. Nondeterministic streaming string transducers.
Proc. 38th International Colloquium on Automata, Languages, and Program-
ming, LNCS 6756, pp. 1-20, 2011.
[3] K. Culik and J. Karhumaki. The equivalence of finite valued transducers (on
HDTOL languages) is decidable. Theoret. Comput. Sci., 47, 71-84, 1986.
[4] T. Griffiths. The unsolvability of the equivalence problem for Λ-free nonde-
terministic generalized sequential machines. J. Assoc. Comput. Mach., 15,
409-413, 1968.
[5] E. Gurari. The equivalence problem for deterministic two-way sequential
transducers is decidable. SIAM J. Comput., 11, 448-452, 1982.
[6] E. Gurari and O. H. Ibarra. The complexity of decision problems for finite-
turn multicounter machines. J. Comput. Syst. Sci., 22, 220-229, 1981.
[7] E. Gurari and O. H. Ibarra. A note on finite-valued and finitely ambiguous
transducers. Math. Systems Theory, 16, 61-66, 1983.
[8] J. Hopcroft and J. Ullman, Introduction to Automata Theory, Languages,
and Computation, Addison-Wesley, 1979.
[9] O. H. Ibarra. Reversal-bounded multicounter machines and their decision
problems. J. Assoc. Comput. Mach., 25, 116-133, 1978.
17
Fundamenta Informaticae XXI (*) 1–17 1
IOS Press
On Almost-Sure Properties of Probabilistic Discrete Event Systems∗
Hsu-Chun Yen†
Department of Electrical Engineering, National Taiwan University,
Taipei, Taiwan 106, R.O.C.
yen@cc.ee.ntu.edu.tw
Abstract. Although randomization often increases the degree of flexibility in system design, ana-
lyzing system properties in the probabilistic framework introduces additional difficulties and chal-
lenges in comparison with their nonprobabilistic counterparts. In this paper, we focus on prob-
abilistic versions of two problems frequently encountered in discrete event systems, namely, the
reachability and forbidden-state problems. Our main concern is to see whether there exists a (or for
every) non-blocking or fair control policy under which a given finite- or infinite-state system can
be guided to reach (or avoid) a set of goal states with probability one. For finite-state systems, we
devise algorithmic approaches which result in polynomial time solutions to the two problems. For
infinite-state systems modelled as Petri nets, the problems are undecidable in general. For the class
of persistent Petri nets, we establish a valuation approach through which the convergence behavior
of a system is characterized, which in turn yields solutions to the reachability and forbidden-state
problems.
Keywords: Forbidden-state avoidance, Petri net, probabilistic controlled transition system, reach-
ability.
1. Introduction
As randomization often increases the degree of flexibility in system design, it is not surprising that
randomization also plays an important role in supervisory control of discrete event systems. It was
shown in [7] that probabilistic supervisory control is capable of generating a richer class of probabilistic
languages than its deterministic counterpart. Previous work along the line of supervisory control of
∗A preliminary version of this paper was presented at the 10th International Workshop on Discrete Event Systems (WODES
2010), Berlin, Germany, August 30 - Sept. 1, 2010.
†Supported in part by NSC Grant NSC-97-2221-E-002-095-MY3, Taiwan.
H. Yen / On Almost-Sure Properties of Probabilistic Discrete Event Systems 3
2. Preliminaries
Let N denote the set of nonnegative integers, and Nk the set of vectors of k nonnegative integers. A
transition system M is a 4-tuple (S,Σ, δ, q0), where S is a (possibly infinite) set of states, Σ is a finite
set of events, q0 ∈ S denotes the initial state, and δ ⊆ S × Σ × S defines the transition relation. Each
(s, t, s′) of δ is called a transition. For convenience, (s, t, s′) ∈ δ is also written as s t→ s′, meaning that
event t can lead the system from state s to state s′. We define en(s) = {t | ∃s′ ∈ S, (s, t, s′) ∈ δ} (resp.,
ent(s) = {(s, t, s′) | t ∈ Σ, s′ ∈ S, (s, t, s′) ∈ δ}) to be the set of events (resp., transitions) enabled at
state s. Without loss of generality, we assume that en(s) 6= ∅, ∀s ∈ S. Such a requirement can easily be
enforced by adding a ”dummy” transition (s, a, s) to state s at which en(s) is empty, without affecting
the system’s behaviors that are of interest to us. A computation pi is a sequence s0
t1→ s1
t2→ s2 · · ·
tn→ sn
such that ∀0 ≤ i ≤ n − 1, si
ti+1
→ si+1. We write st(pi) (resp., ev(pi)) to denote the sequence of states
(resp., events) encountered along pi. We also write s0 t1···tn→ sn (or s0 t1···tn→ , if sn is not important) to
denote the existence of a computation from s0 to sn resulting from taking the event sequence t1 · · · tn.
We write s0
∗
→ sn to denote the existence of a σ ∈ Σ∗ such that s0
σ
→ sn, and s0 6
∗
→ sn for ¬(s0
∗
→ sn).
For an infinite string σ = t1t2 · · · ti · · · ∈ Σω, we write s0
σ
→ if ∀i ≥ 1 s0
σi→ si, for some si, where
σi = t1t2 · · · ti is a prefix of σ.
A controlled transition system M is a 5-tuple (S,Σ, δ, q0, C), where (S,Σ, δ, q0) is a transition system
with its set of events divided into two disjoint subsets Σc and Σu such that Σc∩Σu = ∅ and Σc∪Σu = Σ,
and C ⊆ 2Σc . Events in Σc and Σu are called controllable and uncontrollable events, respectively. Each
element of C is called a control action. For notational convenience, we always label the elements of C as
C1, . . . , Cm (i.e., C={C1, . . . , Cm}, for some m), and we also assume that Σc =
⋃
i=1...mCi throughout
the rest of this paper. A control policy is a mapping h : {q0}S∗ → C from the set of possible computation
histories to C. With respect to a control policy h, a computation pi = s0
t1→ s1
t2→ s2 · · ·
tn→ sn is
legitimate under h (also called h-computation) if it starts from the initial state (i.e., s0 = q0) and for
every 1 ≤ i ≤ n, either ti ∈ Σu, or ti ∈ h(s0 · · · si−1) (i.e., controllable transition ti must be enabled
under h). We also write entpi(sn) to denote the set {(sn, t, s′) ∈ δ | t ∈ Σu ∪ h(st(pi)), s′ ∈ S}, the set
of transitions enabled with respect to history st(pi) under h in state sn.
In this paper, we further require that control policies be non-blocking or fair. SupposeM=(S,Σ, δ, q0, C),
where Σ = Σc ∪ Σu and C={C1, . . . , Cm}, is a controlled transition system.
1. Non-blocking policy: A policy h is non-blocking if for every state s and every computation se-
quence σ leading to s, if en(s) ⊆ Σc, then h(σ) must be a control action such that en(s)∩h(σ) 6=
∅. In words, if in a state from which only controllable transitions are enabled, a control policy
is not allowed to ‘shut down’ the computation by disabling all potentially executable controllable
transitions.
2. Fair policy: A policy h is said to be fair if it is non-blocking, and for every infinite computation
s0
t1→ s1
t2→ · · · si−1
ti→ si
ti+1
→ · · · and for every 1 ≤ j ≤ m, if there exist infinitely many
i1, i2, ... such that Cj ∩ en(sil) 6= ∅ (∀l ≥ 1), then there exist infinitely many k1, k2 · · · such that
h(s0 · · · skl) = Cj , ∀l ≥ 1. In words, if without the presence of the controller, a controllable
transition is enabled infinitely many times along an infinite computation, then any control action
involving the transition must not be denied by the control policy forever.
H. Yen / On Almost-Sure Properties of Probabilistic Discrete Event Systems 5
Before proceeding further, it is worth elaborating in greater detail the differences between our work
and work (such as [3, 5]) involving Markov decision processes (MDPs). In an MDP, states are differen-
tiated as nondeterministic (or called controllable) states and stochastic (or called environmental) states,
The fundamental design issue in MDP is to resolve nondeterminism for controllable states. Unlike MDP,
being controllable/environmental is imposed on transitions rather than on states as in our model. That
is, both controllable and environmental (i.e., uncontrollable) transitions can be defined in a single state
in our setting. The majority of work in MDP dealt with four basic types of strategies, depending on
whether they are deterministic or randomized, and Markovian or history-dependent. A deterministic
strategy picks a single enabled event to proceed, whereas a randomized strategy chooses from the set
of enabled events following some probabilistic distribution. The event to be taken next in a Markovian
strategy depends only on the current state, whereas in a history-dependent strategy, it depends on the
history of reaching the current state. Our control policy is in principle a randomized one as it chooses a
control action Ci which contains possibly multiple events. However, in our setting the actual probability
distribution is dynamic in nature, as it depends not only on the events involved in Ci but also the set of
uncontrollable events enabled in a given state.
The controller synthesis problem in [3, 5] is to design a control strategy so that a given property
specified in probabilistic computation tree logic (PCTL) is satisfied for every strategy of the environment.
The main differences between our work and [3] include the following. We study ”almost-sure properties”
of reachability and forbidden-state avoidance for finite or infinite systems, while those in ([3, 5]) deal
with PCTL for finite-state systems. Also, as we explained earlier, the probabilistic distribution in our
randomized control policy is dynamic in nature, which differs from those used in [3, 5]. In addition, our
strategy is further required to be either non-blocking or fair.
3. Finite State Systems under Non-blocking Policies
We start with the forbidden state problem for finite state systems under non-blocking policies.
Theorem 3.1. ∃-NAFSP and ∀-NAFSP are solvable in polynomial time for finite state systems.
Proof:
Let M=(S, Σ, δ, q0, C, w) be a given system and X ⊆ S be the set of forbidden states.
We first consider ∃-NAFSP. Our strategy is to construct a sequence of subsets of states Q0 ⊂
Q1 ⊂ · · · ⊂ Qi ⊂ · · · so that the following property holds: For every non-blocking policy h, if an
h-computation reaches a state in Qi, then the probability of reaching X under h is greater than zero.
Then we claim that q0 ∈ S \
⋃∞
i=0Qi if and only if there exists a non-blocking policy h under which
f∗q0,X(h) = 0.
To proceed further, we define an extended state as a pair (s,H), where s ∈ S and H ⊆ C, such
that during the course of the iterative procedure, H intuitively keeps track of the set of ”enabled” control
actions that remain safe to be taken at state s up to a given point without getting into a situation that X
is reachable inevitably.
Now we show how Qi+1 is obtained from Qi (i ≥ 0) inductively.
Procedure FSP :
Let Q0 = X and
H. Yen / On Almost-Sure Properties of Probabilistic Discrete Event Systems 7
We now turn our attention to the two versions of NARP, the problem of given a system M=(S, Σ,
δ, q0, C, w) and X ⊆ S, deciding whether the probability measure of all h-computations reaching X is
one, for some (or every) non-blocking control policy h.
We consider ∃-NARP first. The first attempt might be to consider the set X˜ = {s | s 6 ∗→ X}, which
is the set of states from which X is not reachable. Clearly, if under a policy a state in X˜ is reached,
then the probability of reaching X is less than one. The following procedure is a slight modification of
Procedure FSP :
Procedure RP :
Let Q0 =X˜ and
M0={(s,H) | s ∈ S,H = {Cj | ∃t ∈ en(s), t ∈ Cj, }}
For i ≥ 0,
Mi+1 = {(s,H) | s ∈ S \Qi,
H = H ′ \ {Cj | ∃t ∈ Cj,∃s
′ ∈ Qi, s
t
→ s′}
where (s,H ′) ∈Mi }
Qi+1 = Qi ∪ {s | s
t
→ s′, t ∈ Σu, s
′ ∈ Qi} ∪
{s | s 6
∗
→Mi+1 X} where s 6
∗
→Mi+1 X
means X is not reachable from s via uncontrollable
events or control actions specified in Mi+1
Figure 1. A path p along which X is continuously reachable.
Let Q =
⋃∞
i=0Qi. It is easy to observe that if any of Qi is reached under a non-blocking policy h,
then the probability of reaching X is strictly less than one. Also notice that for each state s in S \Q, there
exists a non-blocking policy h such that f∗s,X(h) > 0, and f∗s,Q(h) = 0. Such an h can be constructed
using the strategy explained in the proof of Theorem 3.1.
For Procedure RP , one might expect to obtain ”q0 ∈ S \Q⇔ ∃ non-blocking policy h, f∗q0,X(h) =
1” – an analogy of Theorem 3.1. However, this may not be the case in general, as Figure 1 explains. In
this example, q0 is a state not in Q, and p represents a computation from q0 along which X is reachable
through some computations infinitely many times but is never reached under the chosen control policy.
H. Yen / On Almost-Sure Properties of Probabilistic Discrete Event Systems 9
4. Finite State Systems under Fair Policies
Now we consider FAFSP and FARP. One should first note that Procedures FSP and RP do not work if
control policies are required to be fair. This is mainly because of the fact that removing a control action
from H in an extended state (s,H) in the construction of M1,M2, ... may render the control policy
unfair. To reason about fair control policies, we require the notion of C-ergodicity.
A C-ergodic subsystem is such that once a state in the subsystem is reached, there is a fair policy
under which the probability of staying in the subsystem is one. With respect to a system M=(S, Σ, δ, q0,
C, w) with C={C1, . . . , Cm}, a subsystem M ′ = (S′,Σ, δ′, C, w′), where S′ ⊆ S, δ′ ⊆ (S′×Σ×S′)∩ δ
and w′ is the restriction of w on δ, is called C-ergodic if the following conditions are satisfied:
1. ∀s, s′ ∈ S′, s σ→ s′ in M ′, for some event sequence σ ∈ Σ∗. That is, states and transitions in M ′
form a strongly connected component.
2. ∀s ∈ S′, ∃Js ⊆ {1, ...,m},
(
⋃
t∈Σ
δs,t) ∩ δ
′ = (
⋃
t∈Σu
δs,t) ∪ (
⋃
j∈Js
⋃
t∈Cj
δs,t)
where δs,t = {(s, t, s′) | (s, t, s′) ∈ δ}, i.e., all the transitions from state s using event t. (In words,
in state s ∈ S′ the subsystem’s transitions (i.e., the left-hand side of the equality) are exactly those
using uncontrollable events, or events that are in
⋃
j∈Js
Cj .)
3. ∀s ∈ S′, if t ∈ Σc ∩ en(s) and t ∈ Ci, then there exists s′ ∈ S′ such that i ∈ Js′ . (In words, if a
controllable event t (in Ci) is enabled in some state s in the subsystem, then somewhere (i.e., s′)
in the subsystem all the events associated with Ci must be included in the subsystem.)
In what follows, we develop a graph-theoretic approach (similar to the one used in [11] for nonprob-
abilistic finite state systems) for capturing the essence of C-ergodic subsystems.
p
q r
1 0
2
3
2
p
q r
1 0
2
3
0
p
q r
1 0
2
3
3
p
q r
2 0
2
3
1
3 3 3 3
(A) (B) (C) (D)
s s s s
Figure 2. Examples of fair and unfair SCCs.
We associate a graph GM to a finite state system M=(S, Σ, δ, q0, C, w) with C = {C1, ..., Cm}. The
edge-labelled graph GM =(V,E) (with possibly self-loops and parallel edges) is such that
• V = S, and
H. Yen / On Almost-Sure Properties of Probabilistic Discrete Event Systems 11
Lemma 4.1. Let M ′=(S′, Σ, δ′, C, w′) be a C-ergodic subsystem of M=(S, Σ, δ, q0, C, w) with C =
{C1, ..., Cm}. From any state q ∈ S′, there is a fair policy h under which f∗q,{S′}(h) = 1 in M
′
, i.e.,
from q the probability of staying in M ′ is one.
Proof:
Our proof parallels a strategy used in [9] for the fair termination problem of probabilistic concurrent finite
state programs. Let S′ = {q1, ..., qk}, for some k. For every qj ∈ S′, we first show how to construct a
fair policy σqj so that starting from any state q in S′, f∗q,{qj}(σqj ) = 1.
Given an i, 1 ≤ i ≤ k, let K(i) = {r | ∃(qi, t, q′) ∈ δ′, t ∈ Cr, q′ ∈ S′}, i.e., K(i) is the set of
control actions with at least one event enabled in M ′ in state qi. We partition S′ into Ej1, ..., E
j
mj , where
E
j
1 = {qi ∈ S
′ | ∃(qi, t, qj) ∈ δ
′, t ∈ Σu or t ∈ Cr, r ∈ K(i)}
E
j
2 = {qi ∈ S
′ \Ej1 | ∃(qi, t, q
′) ∈ δ′, q′ ∈ Ej1, t ∈ Σu or t ∈ Cr, r ∈ K(i)}
...
E
j
l = {qi ∈ S
′ \ (
⋃l−1
n=1E
j
n) | ∃(qi, t, q
′) ∈ δ′, q′ ∈ Ejl−1, t ∈ Σu or t ∈ Cr, r ∈ K(i)}
...
The finiteness of the system guarantees that the above partition is finite. The policy σqj can now be
described as follows:
Policy σqj : Upon reaching state qi ∈ E
j
l (i 6= j) ,
Case 1 (K(i) = ∅): disable all control actions. Note that in this case, there is some t ∈ Σu,
(qi, t, q
′) ∈ δ′ and q′ ∈ Ejl−1.
Case 2 (K(i) 6= ∅): activate some Cr, r ∈ K(i) such that ∃(qi, t, q′) ∈ δ′, t ∈ Cr and q′ ∈ Ejl−1.
The above policy has the tendency to move the computation toward Ej1 (and hence, state qj) with nonzero
probability. We now show that the probability of reaching qj under σqj is one.
Let α > 0 be smallest probability associated with the execution of a transition in any control policy.
(Note that M being finite guarantees the existence of such an α.) Clearly f∗
qi,{qj}
(σqj ) ≥ α
mj > 0,
for every state qi ∈ S′. Let B = min{f∗qi,{qj}(σqj ) | qi ∈ S
′}. Suppose B = f∗
qr,{qj}
(σqj), for some
1 ≤ r ≤ k. Then there must exist an integer c such that B = f∗
qr,{qj}
(σj)=γc +
∑
qi∈S′
sigi, where
γc (the probability of reaching qj under σqj in no more than c steps) > 12B > 0, si is the probability of
reaching state qi from state qr in c steps without visiting qj , and gi is the probability of reaching qj from
state qi. Hence, B ≥ γc +
∑
qi∈S′
siB = γc + (1− γc)B= B + (1−B)γc, which holds only if B = 1.
Let A = {[q, d] | q ∈ S′, (q, t, q′) ∈ δ′, for some t ∈ Cd, 1 ≤ d ≤ m, q′ ∈ S′}, i.e., A
consists of all the pairs [q, d] such that some transition in Cd is enabled in q. Since A is finite, we let
A = {[p1, d1], ..., [pz , dz]}, for some z. Now we are in a position to design a fair policy σ such that from
any state q ∈ S′, f∗q,S′(σ) = 1. The σ is the following:
(1) use policy σp1 until state p1 is reached; activate Cd1 ; proceed according to (2)
(2) use policy σp2 until state p2 is reached; activate Cd2 ; proceed according to (3)
H. Yen / On Almost-Sure Properties of Probabilistic Discrete Event Systems 13
5. Infinite State Systems
This section is devoted to ∃ versions of ARP and AFSP for systems of infinite-state represented as Petri
nets.
A labelled Petri net (or PN, for short) is a 5-tuple (P, T,Σ, ϕ, l), where P is a finite set of places, T
is a finite set of transitions, Σ is a finite set of labels, ϕ is a flow function ϕ : (P × T ) ∪ (T × P ) → N ,
and l : T → Σ is a labeling function which assigns to each transition t a label l(t) ∈ Σ. Traditionally,
a state of a PN is called a marking, which is a mapping µ : P → N (µ assigns tokens to each place
of the net). A marking can also be viewed as a k-dimensional vector in Nk, where k = |P | (i.e., the
number of places in P ). A transition t ∈ T is enabled at a marking µ iff ∀p ∈ P , ϕ(p, t) ≤ µ(p). We
write µ t→ µ′ to denote the firing of an enabled transition t at marking µ resulting in a new marking µ′,
where µ′(p) = µ(p) − ϕ(p, t) + ϕ(t, p) ∀p ∈ P . We define Tr(σ) to denote the set of transitions used
in σ ∈ T ∗. A marked PN is a pair ((P, T,Σ, ϕ, l), µ0), where (P, T,Σ, ϕ, l) is a PN, and µ0 is called the
initial marking. A marked PN ((P, T,Σ, ϕ, l), µ0) can be regarded as an infinite-state transition system
(Nk,Σ, δ, µ0), where δ(µ, a) = µ′ if there exists a t ∈ T with l(t) = a such that µ
t
→ µ′.
Probabilistic controlled PNs ((P, T,Σ, ϕ, l), µ0, C, w) can be defined similarly, where Σ = Σu ∪ Σc
(divided into uncontrollable and controllable events), C defines the set of control actions, andw represents
the weight function. A set U ⊆ Nk is said to be upward-closed if ∀x ∈ U, y ≥ x implies y ∈ U . A
set V ⊆ Nk is forward-closed with respect to a PN (P, T,Σ, ϕ, l) if ∀µ ∈ V,∀t ∈ T, µ t→ µ′ implies
µ′ ∈ V .
Although checking containment and equivalence for PNs is undecidable, the expressive power of
PNs, however, is strictly weaker than that of Turing machines. Decidable problems concerning PNs
include: reachability, coverability, boundedness, among others.
Suppose P = ((P, T,Σ, ϕ, l), µ0, C, w) is a probabilistic controlled PN. Let {t1, ..., tk} be the set
of transitions enabled in a marking µ under a control policy h. Viewing P as a transition system, the
probability associated with ti under h is pµ(ti) = w(ti)∑
1≤j≤k w(tj)
.
Unlike finite state systems for which the global coarseness property always holds (Theorem 3.3), the
following example shows that probabilistic PNs in general need not necessarily be globally coarse; and
hence, may not be decisive.
Example 5.1. Consider a PN P with a place {p} and two transitions {t1, t2} such that ϕ(p, t1) =
1;ϕ(t2, p) = 2;ϕ(p, t2) = 1. Note that the net effect of firing t1 (resp., t2) is to decrement (resp.,
increment) place p by a token. Suppose w(t1) = 1 and w(t2) = 2. Then in a marking n > 0, the
probabilities of firing t1 and t2 are 13 and
2
3 , respectively. If we let X = {0}, then it is reasonably easy
to see that from the initial marking 1, the probability of reaching X is
1
3
2
3
=
1
2 , although X˜ = ∅ (i.e., X
is reachable from every marking). Hence, the PN is not decisive. It should be noted that the PN is not
globally coarse, as the probability of reaching X from marking n becomes arbitrarily close to zero as n
approaches infinity. ¶
For a probabilistic PN with an upward-closed X, it was shown in [1] that the PN is always globally
coarse, and hence, decisive.
It was shown in [11] that FSP for controlled labelled Petri nets (without probability) is undecidable
under both non-blocking and fair control policies. A similar argument works for probabilistic versions
H. Yen / On Almost-Sure Properties of Probabilistic Discrete Event Systems 15
The proof of the above parallels that of a similar result ([10]) for conflict-free PNs, a class of PNs
strictly weaker than persistent PNs.
Now we consider NARP and FARP for persistent PNs. We require the following definition. For
β, β′ ∈ Σ∗, β′ = b1 · · · bn, let β . β′ be inductively defined as follows: Let β0 be β. If bi ∈ βi−1, let βi
be βi−1 with the leftmost occurrence of bi deleted; otherwise let βi = βi−1. Finally, let β . β′ = βn. For
instance, if σ = t1t2t3t4t5 and σ′ = t1t3t4, then σ . σ′ = t2t5.
Theorem 5.2. Suppose P = ((P, T,Σ, ϕ, l), µ0, C, w) is a probabilistic controlled persistent PN and
X ⊆ Nk is forward-closed. There exists a non-block (or fair) control policy h such that f∗µ0,X(h) = 1
iff µ0
∗
→ X in PN (P, T,Σ, ϕ, l) (i.e., some marking in X is reachable from µ0 in the absence of any
control policy).
Proof:
The only-if part is trivial. We now show the if-part. Assume that µ0
τ
→ µ′, (µ′ ∈ X). For every µ such
that µ0
δ
→ µ, it is not difficult to see that µ τ
.
δ
→ µ′′, where µ′′ is such that µ′ δ
.
τ
→ µ′′. The above follows
from a basic property (called the diamond rule) of persistent PNs. Since X is forward-closed, µ′′ ∈ X;
hence, X is reachable from µ. Let τ = t1 · · · tm be a shortest path reaching X from µ0.
For µ such that µ0
δ
→ µ, we let i be the smallest such that ti is not in δ (i.e., t1, ..., ti−1 are all in
δ). Since the PN is persistent, ti is enabled at µ. We let the control policy h be such that at µ, if ti is an
uncontrollable transition (i.e., l(ti) ∈ Σu), disable all control actions in C; otherwise, enable a Cj ∈ C
such that l(ti) ∈ Cj . Note here that the firing of ti at µ will decrement the potential. Since there is a
constant β > 0 such that min{pµ(t) | µ ∈ Nk, t ∈ T, µ
t
→} ≥ β, from every reachable marking µ the
probability of entering a marking with a smaller potential is ≥ β under h. In other words, under h the
probability of staying at the same potential is < β. The set of all infinite computations without reaching
the zero potential has a probability measure ≤ (1 − β)∞. It follows immediately that f∗µ0,X(h) = 1.
Note that h is both non-blocking and fair. uunionsq
Let R(µ0,P) = {µ | µ0
σ
→ µ, σ ∈ T ∗}, i.e., the reachability set of P with respect to µ0. Since the
reachability set of a persistent PN is always effective semilinear, we have the following:
Corollary 5.1. NARP and FARP are decidable for persistent PNs when the query R(µ0,P) ∩X 6= ∅ is
decidable, where X is a forward-closed set of goal markings.
Now we turn our attention to NAFSP and FAFSP for persistent PNs with respect to forward-closed
forbidden sets.
First observe that under a fair policy h, if µ0
σ
→ X, then all control actions in D = {Cj | l(t) ∈
Cj, t ∈ Tr(σ)} must eventually be chosen along any infinite path under h. Taking a control action in D
will induce a nonzero probability (> β, for the β specified in the proof of Theorem 5.2) of decreasing the
potential. Hence, the probability of reaching X is nonzero under any fair policy if µ0
∗
→ X. We have:
Theorem 5.3. Suppose P = ((P, T,Σ, ϕ, l), µ0, C, w) is a probabilistic controlled persistent PN and
X ⊆ Nk is forward-closed. There exists a fair control policy h such that f∗µ0,X(h) = 0 iff µ0 6
∗
→ X in
PN (P, T,Σ, ϕ, l) (i.e., X is not reachable from µ0 even when no control policy is present).
H. Yen / On Almost-Sure Properties of Probabilistic Discrete Event Systems 17
[5] Kucˇera, A., Strazˇovsky´, O.: On the controller synthesis for finite-state Markov decision processes, Funda-
menta Informaticae, Vol. 82, No. 1-2, 141-153, 2008.
[6] Landweber, L., Robertson, E.: Properties of conflict-free and persistent Petri nets, JACM 25(3): 352-364,
1978.
[7] Lawford, M., Wonham, W.: Supervisory control of probabilistic discrete event systems, in Proc. 36th IEEE
Midwest Symposium on Circuits and Systems, Vol. 1. IEEE, 327-331, 1993.
[8] Pantelic, V., Postma, S., Lawford, M.: Probabilistic supervisory control of probabilistic discrete event sys-
tems, IEEE Transactions on Automatic Control, Vol. 54, No. 8, 2013-2018, 2009.
[9] Rosier, L., Yen, H.: On the complexity of deciding fair termination of probabilistic concurrent finite-state
programs, Theoretical Computer Science, Vol. 58, No. 1-3, 263-324, 1988.
[10] Yen, H.: A valuation-based analysis of conflict-free Petri nets, Systems and Control Letters, Vol. 45, No. 5,
387-395, 2002.
[11] Yen, H.: Decidability and complexity analysis of forbidden state problems for discrete event systems, Inter-
national Journal of Foundations of Computer Science, Vol. 19, No. 4, 999-1013, 2008.
universe problem undecidable. We also give a simple characterization of the
languages defined by C(s,m, t). Finally, we investigate the applicability of
our techniques to machines with multiple input heads or multiple input tapes.
Keywords: Parameterized machines, decision problems, Turing machines,
pushdown automata, counter machines.
1. Introduction
It is well-known that for deterministic pushdown automata, the equiv-
alence problem (given machines M1,M2, is L(M1) = L(M2)?) is decidable
[11, 12]; hence the universe problem (given a machine M , is L(M) = Σ∗?)
is also decidable. For nondeterministic pushdown automata, even the uni-
verse problem is undecidable (we assume that at each step, the pushdown
can only pop the top of the stack or replace the top of the stack by at most
two symbols). What if, for any fixed positive integers s, t, we consider only
machines with at most s states and at most t symbols in the stack alphabet
and the operation on the stack at each step can only pop the top of the stack
or replace the top of the stack by at most two symbols, but the cardinality of
the input alphabet is unrestricted? We are able to show that for this class,
the containment, equivalence, disjointness, as well as other common prob-
lems are decidable. In fact, this result holds for two-way nondeterministic
pushdown automata.
The example above can be generalized. For any fixed positive integers
s,m, t, let C(s,m, t) be the class of nondeterministic multitape Turing ma-
chine (TM) acceptors with a two-way read-only input, at most s states, at
most m read-write worktapes, and at most t symbols in the worktape al-
phabet. Note that there is no restriction on the cardinality of the input
alphabet. The input tape has left and right end markers, and on any input,
the machine starts on the left end marker and accepts if there is a computa-
tion that brings the input head to the right end marker and the machine in
an accepting state. We show the following:
1. The emptiness, disjointness, and universe problems are decidable for
C(s,m, t). Membership is undecidable because of the existence of uni-
versal TMs.
2. Let HC(s,m, t) be machines in C(s,m, t) that always halt (i.e., on
every input, any computation halts in either accept or reject). Then the
2
for one-way 6-state 2-counter machines, where increments (resp., decrements)
are not fixed but decrements (resp., increments) are restricted to 1 and the
counters make only one reversal. In addition, we are able to prove some
rather unexpected results, which are stated in Theorems 9, 10, 11 of Section
4.
We also give a simple characterization of the languages defined by C(s,m, t).
Finally, we investigate the applicability of our techniques to machines with
multiple input heads or multiple input tapes.
As far as we know, this is the first paper that deals with decision questions
concerning parameterized machines. Many of the reductions for showing de-
cidability/undecidability results are subtle variations of classical techniques
in computability theory. As Turing machines and their variants are basic
models upon which many reductions in computability theory rely, we feel
that our techniques and (un)decidability results are not only of interest in
their own right, but perhaps more interestingly, may find applications in re-
fining existing results and deriving new results as well. As an example along
a similar line of work, it is known that the undecidability result holds even
if one restricts the Diophantine equation to have a fixed order and a fixed
number of variables [3]. Using this parameterized version of the Diophan-
tine equation, one can show the containment and equivalence problems to be
undecidable for vector addition systems (equivalently, Petri nets) even if the
dimension of the vector addition system (equivalently, the number of places
of the Petri net) is fixed, which can be thought of as a refinement of the Ra-
bin’s undecidability results [1] of the Petri net containment and equivalence
problems.
The paper has six sections and an appendix, in addition to this Introduc-
tion. Section 2 shows the decidability of the emptiness, disjointness, universe,
and other problems for the class C(s,m, t). Section 3 proves the decidabil-
ity of the containment and equivalence problems for machines in C(s,m, t)
satisfying certain conditions. To demonstrate the parameterization in Sec-
tions 2 and 3 to be tight, we show in Section 4 that universe and emptiness
become undecidable for machines with their worktapes replaced by counters
(resp., pushdown stacks), and on each move, the changes made on the coun-
ters (resp., pushdown stacks) are not parameterized. Section 5 gives some
simple characterizations of the languages defined by machines in C(s,m, t).
Section 6 deals with multihead and multitape machines and shows that the
techniques used to get the decidability results in Sections 2 and 3 are not
applicable for these types of machines. Section 7 is a brief conclusion.
4
The estimate on k0 is derived as follows. Each instruction is of the form
(q, x, s1, . . . , sm) → (p, d, e1, . . . , em, d1, . . . , dm). Clearly, there are at most
s·3·(3·t)m possible choices for the right-hand side (RHS) of each rule. Since
the machine is nondeterministic, there can be at most 2s·3·(3·t)
m
possible sub-
sets of choices for the RHS. Since there are s·tm tuples (q, s1, . . . , sm), k0 is
at most 2s·3·(3·t)
m·s·tm.
Now, by definition, since Ck0(s,m, t) is finite, all decision problems involving
only machines in this class (e.g., the emptiness problem) are decidable, since
the problems have only a finite number of instances. We can now use this fact
to show the decidability of problems for C(s,m, t), which is an infinite class
of machines, since the input alphabet for these machines has no restriction
on the cardinality.
Theorem 1. For any fixed positive integers s,m, t, the class C(s,m, t) has
decidable emptiness, disjointness, and universe problems.
Proof. Let M ′ be a machine in C(s,m, t), with k input symbols, where
where k ≥ k0. Then M ′ is program-wise equivalent to a machine M in
Ck0(s,m, t). We can find M in Ck0(s,m, t) that is program-wise equivalent
toM ′. Then, clearly, L(M ′) = ∅ (resp., L(M ′) = Σ∗k) if and only if L(M) = ∅
(resp., L(M) = Σ∗k0). It follows that the emptiness and universe problems
for C(s,m, t) are decidable. As for disjointness, let M1 and M2 be machines
in C(s,m, t). Clearly, we can construct a machine M such that L(M) =
L(M1)∩L(M2): M simulatesM1 and when it accepts, “cleans” the worktapes
and simulates M2. M can be constructed to be in the class C(2s+ 1,m, 2t).
Hence, disjointness is decidable, since we can decide emptiness in C(2s +
1,m, 2t). 
It should be noted, however, that the decision procedures for C(s,m, t) are
not effective in the sense that there is no algorithm capable of generating the
procedure for deciding, for instance, the universe problem, for given s,m, t.
Other problems can be shown to be decidable. For example:
Corollary 2. It is decidable to determine given a machine in C(s,m, t),
whether it is regular (resp., context-free, context-sensitive, etc).
Proof. Similar to the proof of Theorem 1, using the fact that it is decidable
to determine, given a machine in Ck0(s,m, t), whether it is regular (resp.,
context-free, context-sensitive, etc). 
6
3. M simulates M2 guided by the string in the special work tape: To
simulate the j-th step, M looks at the j-th symbol, say ij, in the
special worktape and simulate the ij-th choice in the nondeterministic
move of M2. If the ij-th choice leads to acceptance, M rejects and
halts. If there is no ij-th choice or if the ij-th choice leads to reject, M
goes to step 4.
4. M generates the lexicographically next string in the special worktape
and goes to step 2.
During the simulation, M keeps track of the following: If for some k, all
simulations of M2 on all lexicographically generated strings of length k lead
to reject or no next move, then M accepts and halts. Clearly L(M) = ∅ if
and only if L(M1) ∩ L¯(M2) = ∅.
It follows from the construction thatM is in class C(s′,m+1, t′) for some
effectively computable s′ and t′. Hence, the emptiness of L(M) is decidable,
and the result follows. 
Actually in the proof of the above result, to show that L(M1) ⊆ L(M2)
is decidable, we only need M2 to be halting; M1 need not be halting.
Open Question: Can Theorem 3 be generalized to hold for C(s,m, t)?
For machines for which we have a bound on the length of any accept-
ing computation, the assumption that any computation always halts can be
removed.
Corollary 4. Let f(n) be any recursive function, and C(s,m, t, f) be ma-
chines in C(s,m, t) with the property that any accepted input of length n has
an accepting computation of length at most f(n). Then the containment and
equivalence problems are decidable for C(s,m, t, f).
Proof. Since f is recursive it can be computed by a multitape TM U with
s′ states, m′ worktapes, and t′ worktape symbols.
Then we can modify the procedure in the proof of Theorem 3 as follows.
M first computes f(n) in unary, using U . Then it enumerates all strings over
{1, . . . , r} of length f(n) in lexicographic order and proceeds as above. M
will be in some class C(s′′,m′′, t′′) for some effectively computable s′′,m′′, t′′
and hence, emptiness of L(M) is decidable. 
8
(independent of the machine), on each move, the pushdown can pop at most
the top d symbols of the stack or rewrite the top of the stack by at most
d symbols. Similarly, if the counter can be incremented/decremented by
at most d. However, if d is not a fixed parameter but varies for different
machines, the universe problem is undecidable. This follows from the result
in [4], which we describe below.
Consider the case when the worktapes are counters: each counter can
be incremented/decremented by at most d, which varies for different ma-
chines. Thus increments and decrements are not fixed. Call this class
COUNTER+−(s,m).
In [4], the authors considered the class of nondeterministic 4-state 1-
counter machines with a one-way read-only input which is real-time (i.e, the
input head moves right at each step). The counter can be incremented by i or
decremented by j or left unchanged, but the transition depends only on the
state and input symbol (and not on the amount of increment/decrement).
Moreover, the counter is 1-reversal in that once it decrements, it can no
longer be incremented. The machine starts on the leftmost symbol of the
input in the initial state with the counter zero. Also, the counter is partially
blind in that during the computation, it is never tested for zero and aborts if
there is an attempt to decrement it when it is zero. The input is accepted if
after reading the last symbol, the counter has value zero. Since our definition
of acceptance is by accepting state, we need to add another (accepting) state
to the Halava-Harju 4-state 1-counter machine and get:
Theorem 7. The universe problem is undecidable for COUNTER+−(5, 1),
even if the input is one-way real-time and the counter is 1-reversal.
Now consider only machines in COUNTER+−(s,m), where increments
are not fixed but decrements are restricted to 1. Call this class COUNTER+(s,m).
Similarly, consider only machines in COUNTER+−(s,m), where decrements
are not fixed but increments are restricted to 1. Call this class COUNTER−(s,m).
Corollary 8. The universe problem is undecidable for COUNTER+(6, 2)
and COUNTER−(6, 2), even if the input is one-way and the two counters
are 1-reversal. (However, the input is no longer real-time.)
Proof. Clearly, any Halava-Harju 4-state 1-counter machine can be con-
verted to a machine M ′ in COUNTER+(6, 2) (with two counters). M ′ sim-
ulatesM using counter 1. WhenM decrements, M ′ continues the simulation
10
the sumulation of the halting computation to completion without its
input head reaching the right end marker. If U ′ does does not halt,
then for any input an, A will reach the right end marker during the
simulation. It follows that it is undecidable to determine if there is an
input an such that A, when given the unary encoding < M > on its
counter c and its input head is on the left end marker, halts on an. For
brevity, we say that it is undecidable if A halts on d.
4. Let d denote the unary encoding of an arbitrary DTM < M >. We
construct from A, a counter machine Cd which operates as follows,
when given a two-way read-only unary input an (with end markers)
for some n. On the first step, Cd increments its counter by d. Then
Cd simulates A. Note that in the simulation, at each step, Cd only
increments/decrements its counter by 1 or leave it unchanged, and can
test it for zero. (Thus, only the first step increments by d.) If during
the simulation of A, the input head of Cd reaches the right end marker
before A halts, Cd accepts and halts; otherwise (i.e., A halts before Cd’s
input head reaches the right end marker), Cd rejects and halts. Note
that Cd halts for all inputs.
It follows that Cd accepts a
∗ if and only if A does not halt on d, which is
undecidable.
For the undecidability of the emptiness problem, we modify Cd as follows:
If during the simulation of A, the input head of Cd reaches the right end
marker before A halts, Cd rejects and halts; otherwise, Cd accepts and halts.
Hence Cd accepts ∅ if and only if A does not halt on d, which is undecidable.

Theorem 10. For some fixed s, universe is undecidable for nondetermin-
istic one-way s-state 1-counter machines with binary input alphabet, where
increments are not fixed but decrements are restricted to 1. (It is known that
emptiness is decidable.)
Proof. The proof that the universe problem is undecidable is a modification
of the construction of the machine Cd in the proof of Theorem 9.
A close look at the proof of the undecidability of the halting problem for
2-counter machines, where initially one counter has value d1 and the other
counter is zero in [10] reveals that the counters behave in a regular pattern.
The 2-counter machine operates in phases in the following way. Let c1 and
c2 be its counters. Then machine’s operation can be divided into phases,
12
Cd reaches the end marker before A halts, Cd accepts. It follows that
Cd will accept all binary strings if A does not halt.
Finally, we note that emptiness is decidable. This follows from the well-
known result that emptiness for nondeterministic one-way one-counter ma-
chines (or even pushdown automata) is decidable, even if the number of states
is not a fixed parameter. 
Theorem 11. For some fixed t, both universe and emptiness are undecidable
for stateless nondeterministic two-way pushdown automata over unary input
alphabet with at most t stack symbols (the number of symbols that can be
pushed in the stack at each step is not fixed, but only one symbol can be
popped at each step), even when the stack is 1-reversal. Note that since the
machines are stateless (i.e., have only one state), acceptance is by null stack.
Proof. We first modify the construction of machine Cd in the proof of
Theorem 10. Cd, when given a two-way unary input a
n, operates as follows:
1. Cd pushes in the stack a string of the form #b
dkadk . . . bd2ad2bd1ad1
(where # is the bottom of the stack symbol) for some odd k ≥ 1
and integers 1 ≤ d1, d3, . . . , dk ≤ n. Cd can do this nondeterministi-
cally, using the two-way input an. This process can be done by Cd by
pushing no more than one symbol at each step.
2. Then Cd pushes b
d (where d = [unary encoding of < M >]) on top of
the stack in one step. Then it moves the two-way input head to the left
end marker and pops this bd from the stack (symbol by symbol) while
moving the input head to the right, so that when bd has been popped,
the input head is on position d of the input. If the input head of Cd
reaches the end marker before all of bd have been popped, Cd accepts.
3. Cd then simulates Cd as in the proof of Theorem 10, but using the
contents of the stack like the one-way input c2 in that proof, where
popping the top of the stack corresponds to reading an input symbol.
Thus Cd makes exactly one reversal on the stack (from pushing to
popping). The unary input is used as counter c1 in the proof of Theorem
10.
We may assume that when Cd accepts, it also erases the bottom of the stack
#. If during the simulation of A, the input head of Cd reaches the right end
marker before A halts, Cd accepts and halts, corresponding to the case when
14
2. In the simulation of invalid computations of a TM, if the input has
k symbols, we use 3 ∗ ⌈log2k⌉ 1-reversal counters to encode and “re-
member” the symbols of discrepancies and one 1-reversal counter to
remember the point of discrepancies. By adding additional 1-reversal
counters, we can make the machine stateless.
3. This follows from item 1 and the fact that an NPDA can be simulated
by a stateless NPDA by encoding the states in the stack (by enlarging
the number of symbols in the stack alphabet), see Appendix. 
5. Characterizations
Let L(s,m, t) be the class of languages accepted by machines in C(s,m, t).
First we observe that there are unary regular sets that are not in L(s,m, t).
In fact, let k be the number of distinct machine programs in C(s,m, t) over
the unary alphabet {a}. Then there exists 1 ≤ i ≤ k + 1 such that the
regular singleton language {ai} is not in L(s,m, t).
We can give a simple characterization of L(s,m, t). A substitution h over
an input alphabet Σ is simple if for each a ∈ Σ, h(a) is a finite set of symbols.
The following three propositions are easily verified:
Proposition 13. Let s,m, t be any fixed positive integers. Then there exists
a finite set of languages F (s,m, t) ⊆ L(s,m, t) (whose cardinality depends
only on s,m, t) such that L(s,m, t) is the closure of F (s,m, t) under simple
substitutions.
Proposition 14. The above result holds for the class L(s,m, t) of languages
accepted by nondeterministic (one-way, two-way) machines, where the work-
tapes are pushdown stacks or counters.
Proposition 15. Let s, t be fixed positive integers, and L(s, t) be the class
of languages accepted by one-way nondeterministic pushdown automata (with
only one stack) with at most s states and at most t stack symbols. Then there
exists a finite set of context-free languages F (s, t) (which depends only on s
and t) such that L(s, t) is the closure of F (s, t) under simple substitutions.
6. Multihead and Multitape DFAs
In this section, we investigate whether the“program-equivalence” tech-
nique we used in Section 2 is applicable to machines with multiple input
heads or multiple input tapes.
16
most k one-way read-only input tapes, at most s states, at mostm worktapes,
and at most t worktape symbols.
Theorem 18. The emptiness problems is decidable for 1C(s,m, t, k).
Proof. Given a machine M in 1C(a,m, t, k), we construct a machine M ′
in 1C(s,m, t, 1) = C(s,m, t) (i.e., it has only one input tape). M ′, when
given input x1, simulates M on input (x1, . . . , xk) for some x2, . . . , xk by
guessing the symbols that the k − 1 heads are reading on their respective
tapes. Clearly, L(M ′) = ∅ if and only if L(M) = ∅. Since M ′ has only one
input tape), we can decide if L(M ′) = ∅ and, consequently, if L(M) = ∅. 
However, the disjointness and containment problems are undecidable:
Corollary 19. The disjointness and containment problems for one-way 2-
tape DFAs with 2 states is undecidable.
Proof. We first consider the disjointness problem. Let M1 be a one-way
2-tape DFA with 1 state, which operates as follows The heads (one on each
tape) read the tapes simultaneously and accept if the tapes are identical.
Let M be a one-way 2-head DFA with 2 states, see Theorem 16 item 2 (note
that the two heads are on the same tape). Construct a one-way 2-tape DFA
M2 which simulates M . In the simulation, M2 uses its 2 heads (one on each
tape) to simulate the movements of the two heads of M . It follows that
L(M1) ∩ L(M2) = ∅ if and only if L(M) = ∅, which is undecidable.
Now we look at the containment problem. Let M2 be the one-way 2-tape
DFA constructed in the proof for the disjointness problem above. Construct
a 2-tape DFA M3 with states q0, q1, q2. On input (x, y) M3 starts in state
q0 and enters the accept state, q1 (reject state, q2) if x ̸= y (x = y). Then
L(M2) ⊆ L(M3) if and only if L¯(M3) ∩ L(M2) = L(M1) ∩ L(M2) = ∅, which
is undecidable. 
We note that the equivalence (and, hence, the universe problem) is decidable
for deterministic multitape finite automata with states [5].
7. Conclusion
In this paper, we looked at (nondeterministic, deterministic) machines
with a (one-way, two-way) read-only input and multiple storage units (read/write
18
[8] O. H. Ibarra, J. Karhumaki, and A. Okhotin. On stateless multihead automata:
hierarchies and the emptiness problem. Proc. of LATIN 2008: Theoretical
Informatics, LNCS 4957, 94-105, 2008.
[9] M. Kutrib, H. Messerschmidt, and F. Otto. On stateless two-pushdown au-
tomata and restarting automata. Proc. of Automata and Formal Languages
(AFL 2008), 257-268, 2008.
[10] M. Minsky. Recursive unsolvability of Post’s problem of Tag and other topics
in the theory of Turing machines, Ann. of Math., (74)437-455, 1961.
[11] G. Senizergues. Complete formal systems for equivalence problems. Theoret.
Comput. Sci., 231(1), 309-334, 2000.
[12] C. Stirling. Deciding DPDA equivalence is primitive recursive. Proc. of the
International Conference on Automata, Languages, and Programming (ICALP
2002), LNCS 2380, 821-832, 2002.
[13] L. Yang, Z. Dang, and O. H. Ibarra. On stateless automata and P systems.
Pre-Proc. of Workshop on Automata for Cellular and Molecular Computing,
August 2007.
20
2. k-head one-way (resp., two-way) NPDA with states can be simulated by
a stateless k-head one-way (resp., two-way) NPDA.
The above results preserve “r-turn” boundedness on the pushdown stack.
Now suppose M is a one-way (two-way) nondeterministic machine with
states and k pushdown stacks, initial state q0, and initial stack contents
Z0, Z1, . . . , Zk−1, respectively. Again assume that acceptance is by accepting
state f with all stacks null. (Note that this means that in the last step of
M , all stacks contain exactly one symbol which are popped with M entering
state f .) Using a similar construction ofM ′ in the proof of Theorem 20 where
the states are encoded in the first stack, and the other stacks are operated
as in M , we have:
Corollary 22. Let k ≥ 1. Any one-way (two-way) nondeterministic (r-
turn) k-pushdown machine with states can be simulated by a stateless (r-turn)
k-pushdown machine without time loss.
Remarks:
1. The above corollary strengthens a result in [9], where the simulation
for 2-pushdown machine was with time loss. The model studied in [9]
had two pushdown stacks but no separate input tape, since the input
was initially given in one of the stacks. However, the simulation using
the construction above can be done without time loss for the model
studied in [9].
2. A counter is a special case of a pushdown stack in that there are only
two symbols in the stack alphabet: a bottom of the stack symbol (which
is only used to mark the bottom of the stack and is never rewritten)
and another symbol to push on the stack. Hence, we can also think
of a counter as being able to hold a nonnegative integer. It can be
incremented by 1, decremented by 1, or let unchanged. Moreover, it
can be tested for zero (corresponding to the bottom of the stack). In
the above corollary, stacks 2, . . . , k can be (reversal-bounded) counters
and the result still holds. It follows that any one-way NPDA with
one pushdown stack and k reversal-bounded counters can be simulated
(without time loss) by a similar machine that is stateless.
3. It is known that a language can be accepted by a nondeterministic one-
way linear-time multipushdown automaton M with states if and only
22
國科會補助計畫衍生研發成果推廣資料表
日期:2011/11/06
國科會補助計畫
計畫名稱: 加權式自動機平台開發及應用
計畫主持人: 顏嗣鈞
計畫編號: 97-2221-E-002-095-MY3 學門領域: 計算機理論與演算法
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
爭取到 2012 年台大電機系舉辦 16th International Conference on 
Developments in Language Theory (DLT 2012)此重要國際會議  參考網址
http://cc.ee.ntu.edu.tw/~dlt2012/ 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
