2壹、研究動機與目的
網際網路的出現改變了我們原有的行為模式，將人類的行為帶向電子商務
（E-Commerce）的消費時代。正當電子商務方興未艾之際，電信自由化的開放
加上無線網路的潮流，新ㄧ波稱之為行動商務（M-Commerce）所帶來的效應也
正發酵中，行動商務和電子商務雖然都存在著個人化服務（Personalization），但
卻有著程度上的差異，行動商務必須考量到行動地點及時間的多變性，所提供的
服務樣式要能貼近使用者於當時當下所可能產生的需求，如商品、交通資訊需求
等，也就是說使用者對於服務樣式的需求很有可能是隨時隨地起意的，或是依照
特定的間隔時間及地點而規律地出現，這些知識的發現都將有助於個人化目標的
達成，其中資料探勘（Data Mining）便是用來協助找尋此種規則的一項重要技術。
在過去針對無線網路環境下的資料探勘部份，主要集中在使用者的移動樣式
探勘，利用探勘出來的結果可以成功的進行使用者行進路線的預測[JWH02]
[WJHK01]；但是在使用者的服務樣式探勘部份，則尚未見到諸多的研究發表，
[TT03][崔青福]雖然在其研究中利用了二維多層級的關聯規則進行使用者服務樣
式的探勘工作，但仍對移動及服務樣式先後發生順序的描述能力不足，且缺乏對
移動及服務樣式間隔時間的掌控，這些都是在行動環境下不可缺少的重要資訊。
有鑑於此，本研究藉由改良傳統資料探勘技術中的序列型樣（Sequential
Pattern）形成二維度序列型樣演算法，來協助找尋行動服務環境下使用者潛藏的
一些行為，並藉以做為未來行動商務環境中服務推薦的依據。在實作方面，則提
出了兩個適用在行動環境下的使用者行為探勘演算法，分別為 M-PrefixSpan 和
M-Spade，此兩種方法除了將行動環境下地點與服務間所隱含的各種可能使用者
行為樣式進行一個完整的探勘；另外也將時間資訊透過計算最近距離的方式給群
集起來，使得挖掘出來的序列樣式其時間資訊更富有彈性。
貳、文獻探討
在本章中將分為二個小節陸續進行說明，分別是第一節的行動網路環境架構
介紹，透過了解現有行動網路的架構以及使用者的移動和點選服務樣式的步驟，
將有助於我們對相關記錄產生的來源有更清楚的概念；其次是第二節的傳統序列
型樣探勘方法的介紹，描述了現今序列型樣的探勘方式，隨後並介紹有時間間隔
的序列型樣探勘，探討如何挖掘出不同於傳統序列型樣具有時間長短的資訊。
4到找出所有的序列型樣為止。
 SPADE 演算法
Zaki 於 2001 年提出 SPADE 演算法[Zak01]，其可以快速的找出序列型樣，
其主要的特色為在掃瞄一次資料庫後，隨即將所有項目的 Customer-ID(CID)和
Transaction-Time(TID)保留下來，形成一 ID-list，用以紀錄每一項目的相對位置，
接著使用了 lattice 階層式理論來將原來的問題分解成小問題，最後則採用了兩種
高頻序列的搜尋方式：BFS（Breadth-First Search）和 DFS（Depth-First Search）
來完成序列型樣的探勘。
 PrefixSpan 演算法
Jiawei Han 等學者在 2001 年提出了 PrefixSpan 演算法[PHMA＋01]，此方法
主要是利用將資料庫分割成數個小部份的方式來快速計算支持度的工作，並且藉
由不斷的產生與縮減投射資料庫（projected database）的做法來完成序列型樣的
找尋，此方法不但可以找出完整的序列型樣，而且也大大的減低了候選序列的產
生成本，經過實驗的比較可以發現此方法比起 Apriori-based、GSP 和 FreeSpan
等方法都要來的快速許多。
從以上相關文獻的討論可以發現，以往有關序列型樣的探勘方法，多是以「由
較短的序列組成較長的序列」的觀念來進行序列探勘，Apriori-based 演算法採用
重覆的掃瞄資料庫，而 PrefixSpan 演算法採用分割資料庫的方式，SPADE 演算
法則用 ID-list 做交集運算，各自都有其特色也都適用於處理特定類型的資料集。
本研究在考量上述各種方法的優缺點及行動環境下的資料紀錄特性後，將針對
PrefixSpan 和 SPADE 這兩種目前較為快速的序列型樣探勘法進行改良。
此外，在以往的循序挖掘樣式研究當中，[SA96]、[WPC01]、[江美靜]都是
屬於有對時間間隔做處理的研究，大致上的作法是會先給定滑動時間視窗
（Sliding Time Window）和時間限制（Time Constraint）兩個參數值，用以界定
交易資料庫中的各交易紀錄其發生的間隔時間為多久，以及所挖掘出來的頻繁序
列型樣具有何種時間特徵，下面將針對這些文獻中的作法做一介紹。
在[SA96]的研究中針對了以往序列型樣中缺乏時間限制式、過於嚴格的交易
算法和缺乏分類的三項問題進行了改進，透過預先給定視窗大小
（window-size）、最大時間間隔（max-gap）和最小時間間隔（min-gap）三項參
數值來進行頻繁序列樣式的探勘，雖然說這樣探勘出來的資訊可以告訴我們產品
項目間的交易間隔週期為多長，但這並無法告訴我們究竟哪一個產品項目會被先
購買，而且事先設定 window-size 的方式也只能找出特定視窗大小的交易頻繁樣
6在表 3-1 中，A, B, C, D, … 皆代表地點(亦即使用者於某個地點使用行動服
務)；甲, 乙, 丙, 丁,.. 皆代表使用者使用某類服務(亦即使用者使用某類行動服
務，例如: 股市查詢服務，路況查詢服務，天氣查詢服務…等，相信不久的將來，
行動服務業者會提供愈來愈多不同的服務，因此本研究應有相當的前瞻性與應用
價值)；數字1, 2, 3, 4,…皆代表時間點。
例如: 序列 (A,乙,2), (B,丁,7), (D,甲,14), …，代表使用者於第 2 個時間點，
在 A 地點要求乙服務，然後，第 7 個時間點，在 B 地點要求丁服務，然後，第
14 個時間點，在 D 地點要求甲服務，…。
本研究期望藉由表 3-1 的使用者資料，能探勘出類似下列之序列型樣:
(B,乙: 12～26 : C,丁)
此序列型樣代表: 使用者於 B 地點並要求乙服務，經過了 12 到 26 個時間單位之
後，通常會到 C 地點並要求丁服務。
若我們能探勘出以上之序列型樣，我們便能預測行動服務的使用者可能的
下一步行蹤與需求，進而提供更貼近使用者的個人化服務或行銷活動。
因為我們探勘出的序列型樣含有地點維度與服務維度，而且含有彈性的時間
間隔，因此我們可稱為: 二維度的時間間隔序列型樣探勘（2-Dimensional Time
Interval Sequential Pattern Mining）
我們的作法精神可簡略的說明如下: 若要找尋(B,乙)→(C,丁)的時間序列，可
以發現一共在範例資料庫中出現五筆記錄，如下表 3-2。
表 3-2：序列型樣探勘範例
序列 ID 事件 1 事件 2 時間間隔
2 (B,乙,17) (C,丁,64) 64-17=47
3 (B,乙,19) (C,丁,45) 45-19=26
3 (B,乙,19) (C,丁,86) 86-19=67
4 (B,乙,15) (C,丁,91) 91-15=76
5 (B,乙,19) (C,丁,31) 31-19=12
8接著則是對每一筆 prefix 序列所對應的投射資料庫中的 postfix 序列進行頻
繁時間間隔序列的找尋，也就是在所有的 postfix 序列中找尋頻繁項目及事件，
並且紀錄其相差的時間資訊值，待搜尋完全部的 projected database 後，可以得到
對應項目及事件的所有時間差值，之後便可按照設定的分群數目(k)進行群集的
步驟，其分群的做法是使用最近距離連結法的原理來進行，分群後可以得到每群
內的最小及最大值 mint 、 maxt ，再將此最小值與最大值和原本的 1F 頻繁序列相結
合，就形成了 2C 的候選時間序列樣式，如
min max{ , : : , }i i i j i j j jb c t t b c  。
再來則是對所有的 2C 候選集合進行支持度的計算，在過濾掉低於支持度門
檻值的候選序列後，可以得到長度為 2 的頻繁序列型樣 2F，再將此樣式放入 prefix
序列中，並且從上一階段所得到的投射資料庫中將每一筆 postfix 序列過濾掉
min max( : , )t t b c ，並且產生對應的 projected database，最後則是不斷的重
覆進行分割投射找尋的步驟，直到找出所有的時間間隔序列型樣為止。
10
縮減序列長度；然後將步驟 1 所得到的 1F 放入各自的 prefix 序列中，並建立出對
應的 projected database。其中會記錄所對應的序列 ID 及開始時間，如表 4-1 所示。
步驟 3：產生 2C 的候選時間間隔區間，並找出 2-時間間隔序列型樣 2F
掃描每個 prefix 所對應的 projected database，記錄與每個 1F 間的時間差值，
之後便可利用最近距離連結法來進行時間的分割；待分割後即可進行 2C 候選鍵
樣式的組合，將原本的 prefix 加上剛得到的時間區間和 1F 頻繁序列，如
(B)+47~76+(C,丁) = (B:47~76:C,丁)，其結果如表 4-2。接著則是再次掃描 projected
database 一次，判斷此 2C 候選鍵樣式是否為一頻繁序列型樣 2F，其結果如表 4-3。
步驟 4：針對 2F 進行分割資料庫，產生相對應的 projected database
將步驟 3 中所得到的 2F 分別放入 prefix 序列中，然後進行資料庫的分割，
依序建立出對應於 prefix 序列的 projected database。在 projected database 中的每
個序列會記錄其 prefix 序列所相對應的序列 ID 及開始時間，如表 4-4 所示。
步驟 5：在每個 projected database 中找尋符合 2F 的時間區間樣式，據以找出 3F
將上一階段得到的所有頻繁序列樣式作為搜尋 projected database 時的依
據，計算的過程要比對該筆資料的時間差值是否介於 2F 的時間區間樣式內，待
掃瞄完畢後若符合最小支持度，則可得到 3-時間間隔序列型樣 3F，結果如表 4-5。
步驟 6：重複進行步驟 4 及 5 的動作，直到找出所有的時間間隔序列型樣為止
12
表 4-4： 2F 的 projected database
Prefix 序列 ID 開始時間 Projected(postfix) database
(B:7~14:B)
1
2
14
31
(C,丙,25),(A,戊,46),(D,丙,80)
(C,丁,64),(D,甲,72),(D,丙,94)
… … … …
表 4-5： 3F 的時間區間序列樣式
Prefix 3-時間區間序列樣式-(次數)
(B:12~47:丁) (B:12~47:丁:13~30:丙)-4
4.2 M-Spade演算法
M-Spade 是屬於 lattice-based 的演算法，此演算法主要是將原本水平的資料
庫轉換成垂直資料庫的方式，可以得到所有項目的 Customer-ID(CID)和
Transaction-Time(TID)，形成一 ID-list，用以紀錄每一項目的相對位置，以表示
每個項目曾經在那些序列中出現過，以及交易的時間。下面將針對 M-Spade 演
算法的探勘流程及範例作一說明。
演算法流程：
在探勘過程的第一步驟中，會先掃瞄資料庫一次，算出每個項目及混合項目
所形成的事件的 support 值後可以得到頻繁序列型樣 1F 。第二步則是利用 1F 的結
果來產生 2C 候選集合，其產生方式可以透過<演算法 3>來作一說明，對任意兩
個 1F 集合內的頻繁序列進行 CID 的比對工作，若找到相同的則繼續進行 TID 的
比較，將兩者 TID 相減所得的差值放入一時間暫存區，隨後再將時間暫存區內
的值依照最近距離連結法的原理進行分群，可以得到 t 種時間區間。然後將這兩
個長度為 1 的頻繁序列分別結合這 t 種時間區間，並將此結果加入 2C 候選集合。
接著進行計算 support 的工作，其計算方式是將欲進行計算任務的 2C 候選鍵
拆解成 1( ) ( ) 1( )i i j m jf t f  的型式，然後進行 1( )if 和 1( )jf 兩者資料庫的交集比
對，在比對到相同的 CID 和其 TID 差值介於 ( )i j mt  範圍內後，可以將該候選鍵
的 support 值加 1，如此進行直到比對結束，最後再將該候選鍵的 support 值回傳。
14
演算法範例：
步驟 1：轉換資料庫並找出 1-時間間隔序列型樣 1F
首先在計算整個交易資料庫過程中將原本水平式的交易資料庫轉換成
垂直式以項目及混合項目為主的資料庫，在轉換過程中需紀錄每筆交易的
序列 ID(CID)和時間單位(TID)，藉由掃描整個交易資料庫一次來計算可能
出現的項目以及混合項目，可以找出所有頻繁時間間隔序列 1F ，(B)：5,(C)：
5,(D)：3,(乙)：5,(丙)：5,(丁)：5,(B,乙)：5,(C,丁)：4。如表 4-6 所示。
步驟 2：產生 2C 的候選時間間隔區間，並找出 2-時間間隔序列型樣 2F
將任意兩個 1F 集合內的頻繁時間間隔序列進行 join 的動作，藉以產生
具有時間先後關係的序列資料庫，在 join 的過程中需要紀錄後者的 TID 以
及兩者 TID 的差值，其結果如表 4-7 所示。
Join 後的資料庫便可以決定時間間隔區間的大小，其方式是使用最近
距離法的方式進行合併，按照事先設定的 2 群來進行群集，可以得到一時
間區間樣式如(B:47~76:C,丁)，此樣式即為一個 2C 候選時間間隔區間，相關
範例結果如表 4-7 所示。
步驟 3：將所有的 2C 候選序列進行 2-時間間隔序列型樣 2F 的找尋
將任意兩個 2F 集合內的頻繁時間間隔序列進行 join 的動作，其 join 的
前提為兩者的候選序列可以相結合，在 join 之後可以得到 2F 的頻繁序列型
樣，其結果如表 4-8 所示。
步驟 4：不斷重複進行步驟 3 的動作，直到找出所有的時間間隔序列型樣為
止
16
表 4-8：候選鍵結合範例
伍、實驗
在此章節中將針對本研究所提出的兩種二維度的時間間隔型樣演算法進行
各項實驗，並據以驗證此兩種方法在精確性（Accurancy）、完整性（Completeness）
及效率性（Efficiency）各項指標上的表現。
由於行動網路環境下的相關資料取得較為困難，所以本研究採用了[LT02]
所贊助提供的資料產生器（Data Generator）輔以隨機加入時間資訊的方式來進
行資料的模擬。實驗的系統環境如下：Intel Pentinum-4 2.4GHz，2GB memory，
Windows 2003 system，以及 Visual.Net C++。
5.1 資料產生器基本設定
為了模擬行動網路環境下的真實情況，我們將資料產生器（Data Generator）
[LT02]介紹於後並且將相關參數設定如下表 5-1。在資料產生器的模擬環境下，
使用者會有停留原地或是往某個方向移動的機率，在到達每個地點後則會有使用
或是不使用各種服務樣式的可能，而每位使用者停留在網路環境下的時間長短則
不盡相同。在設定基本資料組的參數部分，參考到以往相關研究所採用的參數
B:12~47:丁
CID TID Dist.
2 64 47
2 64 33
3 45 26
4 59 44
4 91 19
5 31 12
丁:13~30:丙
CID TID Dist.
1 25 18
2 94 30
3 75 30
4 72 13
5 84 22
B:12~47:丁:13~30:丙
CID TID Dist.
2 94 30
2 94 30
3 75 30
4 72 13
18
表 5-2：各項實驗組合參數表
實驗項目 參數
最小支持度 Min=0.08、0.06、0.04
網路節點數量 |W|=4、6、9
服務數量 N=62、93、125
使用者行為 Ua=5、10、15
使用者數量 |U|=10k、20k、30k
時間區間數量 5、10、15
5.3 最小支持度實驗(Minimum Support)
此項實驗的主要目的在於評估給定的最小支持度高低是否會對演算法的執
行時間以及序列型樣的長度及數量挖掘造成影響。
從圖 5-1 和 5-2 的實驗結果可以發現，當 minimum support 從 8%遞減到 4%
時，其相對所產生出來的頻繁項目集合(Frequent itemsets)數量會變多，且規則長
度也較長；在執行時間方面，M-PrefixSpan 所需的時間遠小於 M-Spade，這是由
於 M-Spade 對大量候選序列需要多次比對資料庫的原因，而 M-PrefixSpan 則不
需如此，所以有較高的效能。
0
300
600
900
1200
1500
1800
8 6 4
Min. Support(%)
Fr
eq
ue
nt
Ite
m
se
ts
L4
L3
L2
L1
圖 5-1：The Large Itemsets of“Min. Support“
20
4500
5500
6500
7500
4 6 9
Width of Network
R
un
Ti
m
e(
Se
c.
)
M-Spade
M-PrefixSpan
圖 5-4：The Run Time of“Width of Network“
5.5 服務數量實驗(Number of Services)
此項實驗的主要目的在於評估服務種類數量的多寡是否會對演算法的執行
時間以及序列型樣長度的挖掘造成影響。
從圖 5-5 和 5-6 的實驗結果可以發現，當服務種類數量由 62、93 到 125 增
加的過程中，使用者點選各項服務的機率也會較為平均，相對其產生的頻繁序列
型樣的數量會少一些，長度會短一些；而執行時間來說 M-Prefix 和 M-Spade 則
也相似的變化幅度。
0
300
600
900
1200
62 93 125
Number of Services
Fr
eq
ue
nt
Ite
m
se
ts L4
L3
L2
L1
圖 5-5：The Large Itemsets of“Number of Services“
22
4000
5000
6000
7000
8000
9000
5 10 15
User alive time units
R
un
Ti
m
e(
Se
c.
)
M-Spade
M-PrefixSpan
圖 5-8：The Run Time of“User alive time units“
5.7 使用者數量實驗(Number of Users)
此項實驗的主要目的在於評估整個行動網路中的使用者人數多寡是否會對
演算法的執行時間以及序列型樣長度的挖掘造成影響。
從圖 5-9 和 5-10 的實驗結果可以發現，當使用者人數從 10k、20k 到 30k 的
過程中，代表整個資料庫中的資料記錄數量也愈多，但觀察其產生的序列型樣數
量與長度並沒有因此而變多及增長，顯示使用者的行為表現會隨著使用者數量的
增加而愈趨平均；但就執行時間方面則呈現非常大幅度的增加，不論
M-PrefixSpan 或是 M-Spade 來說，都花費了相當多的時間，呈現線性成長的趨勢。
0
300
600
900
1200
1500
10k 20k 30k
Number of Users
Fr
eq
ue
nt
Ite
m
se
ts
L4
L3
L2
L1
圖 5-9：The Large Itemsets of“Number of Users“
24
4000
5000
6000
7000
8000
5 10 15
Number of Time Cluster
R
un
Ti
m
e(
Se
c.
)
M-Spade
M-PrefixSpan
圖 5-12：The Run Time of“Number of Time Cluster“
陸、結論
本論文針對行動服務環境下提出了一種新型態的序列挖掘樣式，其主要的特
色是將時間點可能非常分散的特性透過分群的原理給區分出來，不若以往固定區
間的序列挖掘方式，其只能挖掘出事先設定區間範圍內的資訊，讓挖掘出來的序
列樣式其時間資訊更富有彈性，為傳統序列型樣的挖掘型態帶來新的變化，在實
際應用來說，也較適用於行動環境下的時間多變複雜特性。
另外，本論文同時也針對地點與服務這二維資訊所產生的交互關係進行完整
的探勘，其所探勘出來的規則除了充分表達行動環境下使用者行為的多元性之
外，也為多維度的序列型樣挖掘帶來新興的研究議題。
參考文獻
[江美靜] “有時間區間的循序挖掘,“ 國立中央大學資訊管理研究所碩士論
文, 2002。
[崔青福] “行動網絡環境下之服務樣式探勘機制,“ 國立成功大學資訊工程
研究所碩士論文, 2002。
[AMHU＋99] I. F. Akyildiz, J. Mcnair, J. S. M. Ho, H. Uzunalioglu, and W. Wang,
“Mobility Management in Next-Generation Wireless System,“ Proc.
