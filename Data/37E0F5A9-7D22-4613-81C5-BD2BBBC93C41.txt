Several service-oriented computing issues, including 
service discovery, composition, elicitation, and 
evaluation, will be resolved in medical domain. With 
the proposed service-oriented architecture, large 
scale medical services can be composed by reusing 
local medical related services, which implies that 
the complexity can be handled locally and the cost 
can be lowered. 
英文關鍵詞： Service-Oriented Software Development, Service-
Oriented Architecture, Medical Services, Healthcare 
Information System. 
 
domain. With the proposed service-oriented 
architecture, large scale medical services can 
be composed by reusing local medical related 
services, which implies that the complexity 
can be handled locally and the cost can be 
lowered. 
 
Keywords：Service-Oriented Software 
Development, Service-Oriented Architecture, 
Medical Services, Healthcare Information 
System. 
 
二、計畫背景 
 
近二十年來，資訊科技在醫療領域以及健
康照護領域展現了相當大的應用。在醫療
領域方面，包含心電圖，醫療影像分析，
生物辨識系統，醫院資訊系統，電子病歷
系統 等等，分別用於降低在醫療上的支出
成本，以及克服醫院進行醫療行為時的效
率瓶頸 。而在健康照護領域上，過去需要
由醫院配置專業的照護人員居家照顧，或
是由家庭自行聘僱合格的照護人員，兩者
對於病人來說，都需要較高的支出成本，
同時較難以所需的服務為根據來支付合理
的支出成本，而必須以照護人員的工作時
間為單位付費。這樣的結果使得一般家庭
較難以負擔必要的健康照護。而隨著無線
網路，環境感知系統以及自動化智慧家庭 
相關應用的研究，部分健康照護行為可以
使用部署在家庭內的醫療感應器以及搭配
鄰近醫院提供的服務達成，使得一般家庭
有較佳的機會使用必要的健康照護服務。 
 
然而目前在醫療領域以及健康照護領域的
資訊科技應用，受限於資訊系統本身的架
構限制，大多僅限於區域化的系統建構，
也就是醫院醫療系統自成一體，而健康照
護系統也自成一體，期間的溝通仍舊由醫
院的服務人員進行轉換及處理。而在這兩
者之外，其實還有很多與醫療或是健康照
護相關的服務系統存在，但是缺乏適當的
標準，介面以及平台讓這些服務彼此之間
進行合作，以達成全域化的醫療相關服務
整合。這樣的服務包含在食衣住行育樂的
各種方面，例如: 
 
 對於現代人的飲食提供建議的服務
系統 : 雖然日常生活中的飲食選擇
很多，但是大部分人並無法針對食
物的成分，以及對於自身健康的影
響之角度對於飲食的選擇進行評
估，而大多只根據自身的飲食慾望
作選擇。這對於健康的人較無妨，
但是對於身體有隱疾的病人可能會
是極須小心的。 
 
 音樂或遊戲治療系統 : 音樂可以引
發病人的各種不同情緒反應，利用
音樂對於病人進行治療歷史已有長
久的歷史，然而利用資訊科技協助
建立音樂治療系統，以便較有效率
地提供音樂治療師以及一般使用者
使用，卻是近十年隨著多媒體研究
的發展，才有較多成果的領域。但
無論如何，音樂治療在醫療領域已
有部分成果，因此可以期望地，藉
由電腦的能力，讓音樂治療系統可
以在醫療以及健康照護行為上提供
服務。另外遊戲也是有類似的效
果。在本計畫中，除了音樂服務之
外，也改進本實驗室過往開發的遊
戲學習環境，建製成醫療服務 
[4]，可供兒童或心智類醫療使用。 
 
 緊急交通控管系統 : 當緊急的事故
發生時，如何幫助病人或是救護
車，在最短的時間內到達可以獲得
醫療支援的醫院或是救護站，對於
交通擁擠的城市來說，是極為重要
的醫療相關訊息支援服務系統。通
常會與緊急醫療回應系統有相當的
合作關係。 
 
患者朋友可以透過緊急交通控管系統，迅
速的到達該醫院進行相關的療程。 
 
然而過去由於醫療相關的軟體架構以及軟
體開發哲學之限制，使得如此多相關的系
統難以進行有效的整合，而要把這些相關
的系統共同合併建構，軟體開發複雜度 更
是幾乎無法處理。 然而隨著無線網路和嵌
入式系統相關技術的提升，讓醫療儀器品
質得以提升並且能夠融入日常生活之中帶
來更多便利的情況下，如何把這些分散的
醫療領域以及健康照護領域相關的服務進
行整合，以便提供完整的醫療及健康照護
解決方案，是我們必須面對以及解決的問
題。 
 
 
三、計畫願景 
 
本計畫提出一個因時因地制宜的醫療服務
整合，病人提供其位置與對於醫療服務的
需求給“醫療服務整合系統”，其所預期的
醫療服務的使用權將會被“醫療服務整合
系統”所遞交給病人。透過這個整合，病
人可以隨時隨地使用所需要的醫療服務。 
 
以精神病患的劇本為例，介紹為何“因時
因地制宜的服務整合”：當一個輕/中度精
神病患離家出遊，過程中精神受到外界的
影響而導致情緒失控。因為有此計畫提出
之 “醫療服務整合系統”的存在，就可以立
刻找到此人的位置，並在周遭的伺服器中
找到此病人需要安撫情緒的治療音樂，傳
送給病人，立刻降低病人發病的機率。同
時通知相關醫療體系及醫護人員進行後續
之必要治療。病人所能使用的醫療資源都
以醫療服務的方式呈現。 
 
在醫療服務整合系統的情境中，包含以下
的系統跟角色。 
 
 醫療服務整合系統 : 醫療服務整合
系統是這次計畫主要完成的項目，
其接收病人的醫療服務需求及相關
的資訊(地理位置及病人概況)進而
依據環境狀況以及既有服務進行評
估並整合出適合該項醫療服務需求
的服務給病人使用。 
 
 醫療服務彙整系統 : 醫療服務彙整
系統彙整了目前現有的醫療服務。
醫療服務整合系統可以透過對醫療
服務彙整系統提出需求而得到相關
的醫療服務以及服務的描述。 
 
 環境觀察服務系統 : 環境觀察系統
觀察某個特定位置的環境之下有什
麼可以使用的運算資源。醫療服務
整合系統可以對使用者目前所在的
位置進行可用的運算資源的觀察。
在提供整合性資源之前，可已將該
整合性資源佈署到可用的運算資源
之上。其中，醫療服務整合系統會
向環境觀察服務系統詢問某地相關
的運算資源。環境觀察服務系統會
給予其相關的硬體組態以及佈署的
策略。 
 
 病人需求的醫療服務: 病人要求的
醫療服務在被醫療服務整合系統整
合之後，如何取得該項服務的方法
會透過醫療服務整合系統地交給病
人。借由該方法，病人可以取得該
項他需求的整合性服務。 
 
 病人: 病人並不一定具備足夠的知
識以提供醫療服務整合系統整合出
他所需要的服務。因此透過醫療服
務整合系統的協助，病人將其需
求、所在的位置、病人的概況提供
出來。醫療服務整合系統可以藉此
整合出適合的醫療服務。 
 
療服務來達成，也就可以解決患者
無法整合醫療服務的問題。 
 
 患者無法確切認知在醫療環境所應
該進行或是被禁止的行為 : 此議題
的癥結仍然在於患者由於不具備醫
療環境中進行醫療服務所需要的背
景知識，因此由患者來啟動醫療服
務的利用會出現如何判斷醫療環境
中可否進行該行為的問題存在。因
此這樣的問題改由醫療服務提供人
員來判斷在患者所處在的環境中可
否進行該醫療服務，藉由具有醫療
服務背景知識人員來提供醫療服務
可否進行的判斷，而患者本身則可
根據患者本身的使用者概況保留由
彈性來決定醫療服務的進行方式
等。 
 
 服務提供者如何能有效描述其服務
的各項特性 : 醫療服務的提供廠
商，可以透過註冊於一個醫療整合
系統來提供他們的服務給系統的使
用者。但是要使該服務被找到然後
使用的前提是須要對該服務進行一
個好的描述。一個醫療整合系統對
於其下的服務應該會提供一個通用
的服務描述語言，這樣的語言的設
計是適合的服務能不能被正確且快
速找到的關鍵。 
 
 醫療人員建議患者可以進行的醫療
服務該怎麼被描述 : 前面的議題提
到患者不懂得該發出什麼樣的服務
需求，他可能須要醫療人員或是系
統的醫療知識協助才能發出有效的
服務請求。因此，另一個議題是，
醫療人員或是系統的醫療知識該如
何對需求的醫療服務進行描述。因
為需求的醫療服務跟廠商提供的醫
療服務通常不是一對一的直接應
對，而可能是多個廠商提供服務的
協同運作。這樣的高階需求該如何
被描述以及轉化成低階服務的組合
是一個醫療整合系統所需面對的議
題。 
 
 新進的醫療服務或是整合後新產生
的整合型醫療服務該如何被測試與
驗證 : 醫療服務通常比一般性的居
家服務更要要求服務的品質，因此
對於服務選擇的標準，以及服務如
何被測試及驗證的流程都會關係以
後系統所能提供出來的整合性醫療
服務的品質。 
 
 廠商所提供的服務與服務之間的整
合 : 服務與服務之間須要進行整
合，現有的網路服務(WEB 
SERVICE)有一些以流程(PROCESS)
觀點的服務整合語言。考量現有的
整合語言以及醫療服務整合的特殊
需求，定義適合醫療服務整合系統
的整合語言是一個需要思考的議
題。 
 
 服務執行的問題 : 醫療服務整合系
統可以依據使用者需求整合出適當
的服務，這樣的整合服務須要被安
裝以及執行。如何利用可用的運算
資源，提供有品質的服務是服務整
合系統須要考慮的議題。 
 
 
五、服務運算架構 
 
服務導向運算的願景要能實現，主要依賴
於其底層的服務導向架構。 服務導向架構
定義了不同的服務之間，進行合作的機制
以及溝通介面。同時在服務導向運算內，
把執行環境以及部署問題留在各個軟體系
統中，使得軟體開發複雜度可以被分散處
理。而以服務的角度來建構與組合軟體，
使得系統的彈性增加，允許各種本質差異
向原型組合中所產生的快速原型，都須要
在回到軟體服務測試及驗證子任務中進行
測試與驗證，測試及驗證的資料可以做為
該複合式服務分類的依據。換句話說，這
個服務整合架構可以支持一般的服務與複
合性服務的重用，所有開發中產生的複合
性服務都可以貢獻到之後的服務重用上。 
應用於醫療服務整合之中，因時因地的服
務整合可以分為兩大部分，分別為 1)資訊
的累積以及資訊知識的轉換與 2)知識的使
用。透過輸入測試及驗證模組的資訊可以
累積到許多關於醫療服務的資訊，同時可
以得知這些服務的品質與正確性，並且可
以依據功能性及其他屬性作分類，這些都
是相關於醫療服務的知識。這些知識會在 
服務管理中被管理。 而服務整合則是同時
運用軟體工程的知識以及醫療服務的知識
來進行醫療服務的組合。我們採取演化示
的方式進行醫療服務組合的快速原產生。
舉例來說，最高優先的一個子須求構成了
進行第一次快速原型的需求，因而產生了
第一版的複合性醫療服務。接著分析前兩
個子需求之後，演化性的服務開發流程以
第一版的複合性服務為材料加上其他的服
務進行快速原型開發，進而產生了第二版
的複合性服務。 直到所有的需求都被滿足
之後，最後版本的複合性服務將會遞交給
病人。透過病人對於醫療服務的需求進行
的分解，以及分解後的子需求之間的重要
性的排序之後，決定陸續產生不同演化版
本的醫療服務組合。透過提供病人所處環
境的相關資訊，在演化的過程中，非功能
性的需求在每個演化版本上都需要能夠符
合才有機會進入下一階段的演化，否則會
需要進行醫療服務的重新建置已達成病人
所需要的醫療服務品質。 
 
五、一 醫療需求規格及需求分析 
 
醫療服務描述上可以以醫療服務需求者所
在地域、醫療服務需求者資料、醫療服務
需求者病歷、醫療服務需求者生物訊號資
訊以及醫療服務需求者所處環境這五個元
素來組成： 
 
 醫療服務需求者所在地域資訊 ：地
域性的資訊主要描述包含 了該醫療
服務需求者所在的地理位置、國
家、甚至是都市。依據所在的地域
不同文化、語言、社群活的型態也
不同，這些最後都會影響到醫療服
務的選擇。 
 
 醫療服務需求者資料 ：醫療服務需
求者資料主要包含醫療服務需求者
個人的背景資料，包括工作、教
育、經歷、社會地位等等，依據醫
療服務需求者背景資料不同，對於
醫療服務的要求也會不一樣。Hall 
[75] 等人的研究為例子，該研究針
對描述對象的行為來作為描述的基
準，作者的研究在本計畫就是為患
者行為作為醫療服務需求者資料的
描述。 
 
 醫療服務需求者病歷 ：在醫學領域
中為了避免引發併發症，常常會依
據病歷來判斷患者需要什麼醫療服
務，所以我們必須考量醫療服務需
求者的病歷資訊。 
 
 醫療服務需求者生物訊號資訊 ：詢
問生物訊號常常是醫學領域判斷病
症的開始，依據生物訊號的優先
度，常常也是醫生用以判斷實行醫
療服務的優先順序。 
 
 醫療服務需求者所處環境資訊：醫
療服務需求者所處環境的資訊可以
用來幫助醫生調整醫療服務的實行
優先順序。 
 
來自於醫療需求者的醫療軟體服務需求敘
述包含各領域的不同需求，而且十分有可
  
和隱私亦是計畫進行中需要去處理的議題
之一；除了 Zhu 等人的研究[106][107][108]
之外，Chakraborty等人[25]則利用 Web 
Ontology Language（OWL）來描述服務進
行幫助服務探索，並且宣稱在行動運算的
環境中，作者的方法可以較有效率的進行
服務探索，因此亦可以用來作為計畫參考
關於效率方面的考慮該如何進行。根據解
法概念、應用領域（環境醫療服務）和過
去相關研究顯示，本計畫在醫療服務探索
方面，雖然觀點轉變的關係使得服務探索
並不強調由使用者觀點來進行醫療服務探
索，而是針對醫療相關行為的必要條件
（例如：特定患者狀態）來達成，藉此達
到和「醫療行為」以及「患者」和醫療服
務之間的整合。除此之外，根據觀察過往
研究發現服務探索應用在醫療環境中還需
要考慮安全和隱私問題，除此之外由於可
能利用在行動運算的環境中，服務探索的
效率亦是在計畫計型中需要注意的議題之
一。 
 
五、三 醫療服務選擇子系統 
 
在醫療的領域中，服務選擇就更為複雜
了。因為在醫療的領域中，每個服務的選
擇都不可逆。所以會以下的考量： 
 
 從選擇的滿意度來看：由於醫療相
關服務的選擇可能相當緊急，或是
其最後的結果關係重大，會直接在
人體上造成影響，並非可以在不滿
意時選擇重來，因此使用者的滿意
度是很重要的指標。 
 
 從環境的限制的觀點來看：緊急交
通管控類型的服務是需要搭配載送
病患，因此也需要考慮到提供服務
的地點與病患目前的距離及病患本
身的狀況來決定要選擇那一個服
務，因此在進行服務選擇的時候所
考量的令人滿意的因素的優先順序
也要因此而改變。例如：對於急診
病患而言，能夠最快到達醫院進行
治療是最重要的；對於一些骨折的
病患而言，選擇地形較平坦的路以
避免二度傷害是比較重要的考量。
此外，在提供飲食建議的時候，也
要考慮天氣及季節的因素。 
 
 從服務消費者所能提供的資訊來
看：對於服務消費者而言，他們希
忠實的記錄下來，所以服務消費者就可以
根據這些經驗來判斷服務提供者所提供的
服務是不是滿足自己需求的，而不需要透
過別人主觀的認為服務提供者所提供的服
務是他們滿意的。例如：透過別人對於某
個提供旅遊資訊的服務提供者的經驗 (提供
多久期限內的旅遊計畫，旅遊景點可能包
含那些地方)，服務消費者就能夠很輕易的
判斷那個服務提供者所提供的服務才是自
己想要的。 
 
 
 
此外，作者將原本的本體論分成兩個部
分：基礎層級本體論和領域層級本體論。
基礎層級本體論具有一般性的特性，也就
是只要有需要服務選擇就需要具備的部
分。而領域層級本體論就是針對不同領域
而有所不同的本體論。分成了基礎層級本
體論及領域層級本體論後，遇到不同領域
只需要更換領域層級本體論，而在建立領
域相關的本體論也不再需要考慮一些和為
了服務選擇所需要考慮的本體論 (所以可以
用已經發展好的該領域的本體論即可)。由
於醫療系統中仍存在異質性的問題，而且
目前在醫療領域中有以下這些類型的服
務：對現代人的飲食提供建議的系統、音
樂治療系統、緊急交通控管系統、遠距居
家看護系統、醫藥盒子系統與藥局系統
等。為了能夠針對醫療服務能夠提供更令
人滿意的服務選擇。 
 
本體論是用來表示服務。本體論分成基礎
層級本體論及領域層級本體論。基礎層級
本體論不會隨著服務的種類不同而有所差
異；領域層級的本體論則會。因此圖中領
域層級中依照服務類型的不同而有緊急醫
療回應服務的本體論和緊急交通管控服務
的本體論等。當一個服務被發起時，就會
有相對應的本體論的實體產生。圖中就有
緊急醫療回應服務及緊急交通控管服務兩
個服務。 
 
聚合的服務是由兩個以上的服務所組成，
圖中手術服務就是由緊急醫療回應服務及
緊急交通控管服務所組成。兩個服務會有
兩個不同基礎層級本體論的實體，組合之
後只能有一個基礎層級本體論的實體，所
以兩個服務的基礎層級本體論需要進行整
合。至於該如何整合則是我們接下來要克
服的問題。此外，在 [91], [105], [106] 提到
了一些醫療相關的本體論是可以被拿來參
考的。 
 
而在此計畫中，我們必須要能夠在相似的
服務中作出選擇。因此我們完成一個協助
進行服務選擇的子系統，能夠基於不同領
域的本體論，紀錄使用者的使用經驗之回
楚，也因此更容易利用相關技術來幫助服
務整合的進行，例如 Ardagna [103]等人研
究。除了以功能性作為服務整合的依據以
外，服務的品質也是整合的重點之一。服
務整合必須是服務品質感知 ( QoS-Aware ) 
的 [107]，舉凡不同使用者所持的政策 
(Policy)，所需的效能，對於安全性的要
求，軟體層級協議 (Service-level Agreement) 
[116] 等等，都需要被納入考量。而考慮到
服務整合可能的進行方式，在過去研究中
有 Bhiri等人[120]進行過，在他們的研究中
利用各種已經定義完成的執行模式
（Transactional Patterns）來作為服務整合的
基礎，倘若應用到醫療服務整合上，也可
以嘗試藉由找出醫療領域中的執行模式來
作為醫療服務整合的基礎。 
 
在本計畫執行中，考量到業界開發醫療服
務以及進行整合時的設計問題，特別以軟
體工程中的物件類別設計問題為對象，開
發以範本為基礎的自動設計編排工具 
[1][6]。AUTLE (AUTomatic Layout by 
Example) 的目的在於建立一個可以根據開
發人員給予的範例(Examples) 協助重排
(rearrange) Class Diagram 上的 Classes, 以協
助決策的工具. 此 task 提出的原由在於, 觀
察到開發人員 在進行 Design Inspection 時, 
會依據自己的喜好調整 Classes 在 Class 
Diagram 上的位置. 而同一位開發人員 對於
特定的設計結構 (Design Structure) 往往有特
定的喜好. 因此 AUTLE 希望可以協助 
開發人員 表達對於特定設計結構的排列喜
好, 作為排列範本(Layout Template), 以 
便節省未來遇到類似設計結構時需要重新
排列 Classes 的時間花費. 同時, 由於排列 
圖: 利用 API 做醫療服務選擇 
 
範本由開發人員自訂, 因此具有開發人員 所
賦予的意義(Semantics), 在複雜的 Class 
合它的醫療服務規格，能否正確地執行其
功能。 
 
六、醫療資料保護 
 
在本計畫中也考量了醫療資料於雲端的安
全性問題 [7]。傳統上在雲端對於資料擁有
者的資料隱私保護多採用加密 (Encryption) 
的方式，只有資料擁有者本身才能解密取
回這些資料。然而以下幾項特性使得使用
資料加密確保資料隱私性的方式並不適用
於雲端運算的情境： 
 
 為了使用雲端醫療運算服務，雲端
上的資料需可被雲端醫療運算服務
進行處理：由於資料擁有者會透過
雲端醫療運算服務操作、修改或分
析所上傳至雲端的資料，若資料被
加密，雲端運算服務本身將無法存
取 或 了 解 資 料 所 代 表 的 含 意 
(Semantic)，進而無法解讀其所包含
的內容，在此情況下雲端醫療運算
服務並無法提供資料擁有者有效的
資料操作或分析服務。而對資訊反
饋雲端運算服務而言，加密的資料
對於雲端運算服務來說無法理解，
等同於無效資料，自然便無法提供
有效的資訊反饋。 
 
 單一雲端醫療應用服務往往牽涉到
一群基礎雲端醫療運算服務的使
用：雲端醫療運算服務處在動態環
境 (Dynamic Environment) 中，一個
雲端運算應用服務可由其他雲端醫
療運算服務動態組成，並可隨著資
料擁有者的需求或是雲端服務提供
者的策略而改變[13]。以旅遊即時導
覽雲端算應用服務為例，資料擁有
者的個人位址資料會先被個人定位
雲端服務取得，再由定點導覽雲端
服務提供相關定點導覽資訊給資料
擁有者。因此資料擁有者的雲端醫
療資料會在不同的雲端運算應用服
務提供者間流動[13][14]，資料擁有
者難以預先知道資料會被哪些雲端
服務提供者存取。 
 
基於以上分析，加密方式並無法在兼顧雲
端醫療運算服務的正常使用之下對資料隱
私進行嚴密防護。因此我們轉而考慮透過
有效地檢驗、控制並察覺醫療資料在雲端
上的保存、流向與存取情形，並在資料擁
有者能充分使用所需雲端服務的情況底下
與資料隱私保護達成平衡。為達此目的，
本研究將提出以有效監控與重點式資訊模
糊的方式達到在雲端醫療運算服務中資料
控管與醫療資料隱私的保護，透過提供醫
療資材擁有者對於雲端資材更多的監管與
控制權，以及對應的自動化的監控機制，
達到更進一步保護雲端醫療資料隱私的效
果。 
 
六、一 主動式雲端醫療資料隱私防護機制 
 
本主動式雲端醫療資料隱私防護機制由
雲端醫療資料前置處理模組  (Cloud Data 
Preprocessing Module)、雲端醫療資料追蹤
與即時反應模組 (Cloud Data Tracking and 
Reacting Module)以及雲端醫療資料行為規
範 設 定 模 組  (Cloud Data Specification 
Configuration Module) 三個部分組成，如圖 
1 所示。 
 
 
 
圖: 雲端醫療資料行為規範設定模組架構圖 
由圖 2 可知，雲端醫療資料行為規範設
定 模 組 主 要 由 規 格 書 產 生 子 系 統 
(Specification Generating Subsystem)以及合
法 條 件 與 即 時 反 應 選 項 管 理 子 系統 
(Condition & Reaction Managing Subsystem) 
兩者所組成。其中，資料擁有者透過規格
書產生子系統挑選和配置其預期雲端醫療
資料能被進行特定動作的各式條件，以及
當有不符預期的動作發生時，資料擁有者
預計進行的即時反應。由於在不同狀況或
不同使用情境下，針對不同雲端運算服務
或不同類型的資料，合理的雲端醫療資料
使用條件與即時反應的選項都會不同。為
了因應這些情形，且降低資料擁有者描述
合法使用條件暨即時反應規格書時的難
度，合法條件與即時反應選項管理子系統
將會因地制宜地提供規格書產生子系統在
特定使用情境中，根據不同考量而產生的
合法使用條件與即時反應選項組合加上各
種預設條件值給規格書產生子系統，供資
料擁有者依照其實際情況進行挑選及微
調。 
為了能適應動態且時常推陳出新的雲端
運算環境，並隨時提供資料擁有者最適宜
的各式規格定義選項，合法條件與即時反
應選項管理子系統需能提供第三方雲端資
訊 安 全 性 控 制 專 家  (Cloud Security 
Controlling Expert) 根據最新現實情況對可
能的合法雲端醫療資料使用條件與即時反
應選項進行補充更新。合法條件與即時反
應選項管理子系統並提供一套合理的評估
認證機制，針對第三方雲端資訊安全性控
制專家提供的各式選項內容進行評估與控
管，以確保合法條件與即時反應選項管理
子系統提供給規格書產生子系統用以產生
合法使用條件暨即時反應規格書的內容隨
時都處在最佳狀態。 
 
六、三 雲端醫療資料前置處理模組 
 
圖 3 描述的是雲端醫療資料前置處理模
組的架構圖，雲端醫療資料前置處理模組
主要由資料分析與模糊化處理子系統 (Data 
Analyzing & Fuzzifying Subsystem)以及資料
存取保護層包覆子系統 (Data Coat Packing 
Subsystem) 所組成。 
 
圖: 雲端醫療資料前置處理模組架構圖 
在雲端醫療資料前置處理模組中，資料
擁有者先透過資料分析與模糊化處理子系
統自動化地針對上傳資料的特性、使用情
境、資料擁有者偏好設定與資料擁有者的
使用者概述  (User Profile) 等要素進行分
析，因地制宜地選擇最佳模糊化演算法在
不影響雲端服務使用的前提之下，對資料
 
圖: 雲端醫療資料追蹤與即時反應模組架構
圖 
 
六、四、一 雲端醫療資料行為自動監控與
即時反應 
 
在雲端醫療資料追蹤與即時反應模組
中，所有來自不同雲端醫療資料封包的雲
端醫療資料存取保護層中所回報的各項雲
端醫療資料行為信息將匯集至雲端醫療資
料監控子系統進行判讀，並由雲端醫療資
料監控子系統將這些雲端醫療資料行為信
息儲存在雲端醫療資料行為記錄管理子系
統中。雲端醫療資料監控子系統接著會進
一步比對資料擁有者透過雲端醫療資料行
為規範設定模組所制定的合法使用條件暨
即時反應規格書中的定義，判斷雲端醫療
資料的行為是否超出資料擁有者所預期的
使用條件或使用情境。若有上述情況發
生，雲端醫療資料監控子系統將根據合法
使用條件暨即時反應規格書中的定義，要
求即時反應觸發子系統產生相關反應動作
信號以執行資料擁有者的預設反應動作。
反應動作信號將會傳達給包覆在雲端醫療
資料外層的資料存取保護層，由資料存取
保護層實際執行相關反應行為，例如對資
料進行必要的鎖定或修改。而在此同時雲
端醫療資料監控子系統也會要求雲端醫療
資料異常行為警告產生子系統產生各式警
告訊息提醒資料擁有者有異常情況的發
生，協助資料擁有者採取下一步動作。 
透過上述子系統的通力合作，雲端醫療
資料追蹤與即時反應模組將能自動監控雲
端醫療資料活動的性質，並根據資料擁有
者預先的設定自動且快速地決定相對應措
施，不需資料擁有者一一檢視雲端活動通
知再一一回應，因此將有效減低資料擁有
者的負擔。 
 
六、四、二 使用者警告層級的設計 
 
當有非法雲端醫療資料存取行為被發現
時，除了根據資料擁有者的預先定義立即
採取行動之外，雲端醫療資料異常行為警
告產生子系統需能發出警告通知資料擁有
者，協助資料擁有者了解目前雲端上資料
違反預期的使用情況及其嚴重性。由於針
對不同的嚴重層級、警告類別，以及針對
不同類型的資料擁有者 (如入門級、進階級) 
將導致在不同情況下，資料擁有者所需要
及想要知道的警告訊息描述內容詳細程度
與希望得到的輔助訊息種類、豐富度等均
有不同。因此有效的警告描述、分類與產
生策略是必要的。雲端醫療資料異常行為
警告產生子系統的警告描述、分類與產生
策略會根據資料擁有者的使用者概述 (User 
Profile) 先行對資料擁有者的特質進行有效
的分類，再視非預期雲端醫療資料行為的
嚴重性與類別，產生能讓資料擁有者一目
瞭然快速了解關於 (1) 嚴重性層級、(2) 目
前實際狀況、(3) 已採取之立即反應行為 (4) 
資料擁有者可立即更進一步採取之反應行
為等的警告內容。為了幫助資料擁有者快
速理解警告內容，雲端醫療資料異常行為
警告產生子系統將依照資料擁有者之特性
產生最能協助資料擁有者理解警告內容描
述的相對應輔助內容，幫助資料擁有者了
解此種非預期雲端醫療資料行為的各項特
質、可能造成的影響、損害以及資料擁有
者個人可採取的後續處理方式等資訊。 
者，協助資料擁有者快速反應，減少異常
雲端活動情況所可能造成的損失。 
 
由於網路與各式行動上網裝置的普及帶
動了雲端運算應用服務的發展，雲端運算
應用服務發展至今，不管在種類多樣化或
普及率也皆取得相當的發展，並且雲端運
算應用服務的類別現今也更趨生活化，並
實際對於現代人的生活提供不同層面的協
助。但資料擁有者在使用雲端運算應用服
務前需要將自己所擁有的資料先行上傳至
雲端運算服務中。一旦資料被上傳至雲端
運算應用服務，資料擁有者將喪失對於雲
端醫療資料的隱私保護能力，只能相信雲
端運算服務提供者單方面宣稱的雲端醫療
資料隱私保護果效。另由於失去對於雲端
醫療資料的隱私保護能力，使得部分資料
擁有者對於雲端運算服務的使用存在著疑
慮與不信任，進而發展成對雲端運算服務
蓬勃發展的阻礙。本研究建立一套主動式
雲端醫療資料隱私防護機制，協助資料擁
有者追蹤雲端醫療資料的動向與在雲端中
被進行的各種動作，提昇資料擁有者對於
雲端醫療資料的掌握度。一旦發現有不符
資料擁有者預期的行為發生，此機制也將
協助資料擁有者對於雲端醫療資料採取即
時行動，確保資料擁有者對於雲端醫療資
料的隱私保護。 
 
為達成這些目標，我們的主動式雲端醫
療資料隱私防護機制擁有以下特性： 
 
 積極主動的 (Proactive) 雲端醫療資
料行動回報，即時掌控雲端醫療資
料所受到的各種雲端存取操作行
為。 
 
 先發制人的雲端醫療資料監控，當
雲端醫療資料有超出預期的行為發
生，可在第一時間內採取動作，以
最快速度讓情況回到資料擁有者的
掌控之中。 
 
 快速簡便的雲端醫療資料使用條件
設定，協助資料擁有者更容易地針
對 (1) 合法的雲端醫療資料使用條
件，及 (2) 面對異常情況的第一時間
反應進行設定，以量身訂造最佳的
資料監控模式。 
 
 有效的資料動向歷史紀錄管理，協
助資料擁有者對於雲端醫療資料的
動向有更精確的掌握。 
 
 因地制宜的資料隱藏模糊化方式，
在不影響雲端運算服務的使用之
下，減低資料擁有者暴露在雲端中
的資訊，減少雲端運算服務出現不
可預期情況時所可能造成的資料隱
私傷害。 
 
此本研究的主動式雲端醫療資料隱私防
護機制可以雲端運算服務的形態提供，也
可直接實作在本機端。以雲端運算服務的
形態提供的好處是可配合資料擁有者操作
一般雲端運算服務的使用習慣，讓資料擁
有者可在不受時間地點的限制之下，隨時
隨地使用雲端運算服務的同時也能達成資
料監控與資訊保護的效果。 
 
七、計畫相關文獻 
 
七、一 服務導向運算 
 
服務導向運算是近來國內外研究的焦
點。有別於既有的軟體發展紀律，例如物
件導向紀律 (Object Orientation Paradigm)，
服務導向運算並非著眼於協助軟體開發
者，在有限的時間內建立高品質以及高度
可維護性的軟體，而是改以服務的角度看
待軟體，將軟體所具有的各種能力皆以服
務的角度進行包裝，然後再引入使用者的
一般生活中。 
 
國外對於服務導向的相關集中研究已經
開始了大約五年的時間，所含括的方向也
用相符經驗或者在相同的認知條件下，得
到一致的服務評量，作為更精準地選擇服
務的機制。[79] 則認為，當服務的需求者
在尋求服務的時候，希望能夠觀察服務實
際運行的行為，利用行為是否符合預期與
需要來做為服務的選擇。因此作者們提出
了一個行為模型 (Behavior Model) 作為服務
的描述，幫助這樣的需求者能夠利用行為
的觀點選擇服務。[80] 認為，在服務提供
者身上描述對於功能使用的情境，將能夠
幫助服務在比對時的精準度，始搜尋的服
務更能夠符合需求。對於服務導向架構 
(Service Oriented Architecture) 的描述 [79] 
提出以 UML 為基礎為服務的描述來增加新
的 profile，服務找尋與選擇階段能夠更順利
的進行。 
 
服務雖然就是一個完整功能的個體，但
是一項服務是可能由許多小的服務所構
成，利用服務與服務間的低偶合性質，讓
許多服務的合成物，貼切的提供醫院裡病
患適切的協助，勢必將大大提升對醫療品
質的滿意與信任程度。[76] 中說明了在經
過服務的選擇之後，面對使用者的需求，
服務導向架構要做的就是讓服務之間彼此
溝通協調，利用這樣子的方式讓這群服務
天衣無縫的包住使用者的需求。功能的整
合 (Functional Composition)、服務間相依性
管理 (Management of Dependencies) 與協商
聚合 (Negotiation Convergence) 將會是這個
階段的重點。[109] 指出，服務在聚合的時
候，可能會遭遇依些不可分割的衝突 
(Atomicity Violation)，他們提出了一套機制
去偵測衝突的可能性，並且利用分析來將
解決衝突點。[56] 則是發現服務的聚合中
存在著依些固定的樣板 (Pattern)，讓他們可
以藉由要求特定的服務規格與品質時，找
到某些樣板來解決問題。當這些事情都能
夠被掌控並且良好的溝通之後，[66] 說明
對於一個具有適應性的系統能夠被很靈活
的程序產生出來。 
 
面對聚合的服務 (Composite Service)，
[57] 提供了數個模型將規劃的服務架構模
型與實際的服務架構模型比對分析，驗證
其正確性。[83] 則是探討甚麼樣的服務使
用甚麼樣的品質屬性 (Quality Attribute)，將
能夠幫助衡量在服務完成的過程中之取捨
與幫助做出好的決定。 
 
七、二 醫療與健康照護資訊系統 
 
在醫療領域中，主動的醫療服務系統正
逐漸的被重視，人本的醫療行為與看護逐
漸地在引領著改變過去被動式的醫療型
態。在變化的過程中，傳統的集中式架構
逐漸的無法適應因為環境快速變化而造成
的服務需求的變化。類似 Wu, et al. [77] 對
智慧型居家進行的研究，Wu 他們認為，傳
統的智慧型居家是以一個中央伺服器 
(server-centric) 為主，以一個集中提供服務
的伺服器 (Service Provider)，作為固定服務
的來源，而居家中的智慧型設備  (Smart 
Devices) 根據環境的資訊，項服務伺服器要
求服務，但是這樣的架構經常發生問題。
在智慧型居家的環境裡，智慧型設備會隨
著居家的成員、隨著時間而快速的變化，
對於服務的需求也不斷的改變，集中架構
的服務伺服器必須經常得重新設定來符合
新的需求，在這過程中容易發生問題。藉
由服務導向架構的引入，智慧型居家所提
供的服務能夠依據環境的資訊，在服務的
組成上選擇較合適的元素來達成，讓新的
需求能夠快速而且輕鬆的被滿足。在醫療
系統中，不同的病患因為病徵、病況、性
別、文化…等因素，造成每個人對於「服
務」的需求有很大的差異。又面對相同的
病人，不同的時間不同的環境與情境，提
供給病人的服務也應該因時制宜。 
 
Hashmi, et al. [113] 建立了一個基於感應
器以及網路服務的緊急醫療回應系統 
( Emergent Medical Response System )，能夠
與醫院交換溝通關於正送往急救中的病人
驗發現經常聽音樂的組別相較於對照組有
顯著的血壓下降均值，因此建議音樂治療
可以為高血壓病患的一項療程。 
 
急救交通控制系統 
 
當有緊急事況發生的時候，緊急疏散將
是一項對大眾的保護。在疏散的過程中，
時間是一項重要的因素，越是迅速且有效
的疏散人群，越是能夠達到疏散的目的。
Rathi , et al. [125] 提出了一套局部交通模擬
系統，讓使用者能夠在特定的部分描述疏
散的策略，用來模擬事況發生時的疏散管
理是否有效。因為 9/11 的恐怖事件，Brady, 
et al. [126] 也提出了一套模擬系統，用來模
擬當事況發生的時候，資訊的傳遞與資訊
的整合並且對應在醫療單位、警力單位與
消防單位的反應情況。 
 
遠距居家看護系統 
 
Caceres, et al. [127] 為 了 慢 性 地 
HIV/AIDS 病患提出了一個遠端醫療系統，
這個系統將一個具有各種知識的醫療團隊
安插在原本的治療流程中，透過以網路為
基礎的遠端醫療介面，讓病患能夠在家來
增進自我的健康管理與追隨遠端專業醫療
人員的醫療指導。Haan, et al. [128] 利用代
理人機制幫助追蹤居家的糖尿病患者，透
過病患的設備來獲取身體的相關資料。而
病患本身也能夠利用這個代理人來獲得醫
療方面的相官資訊。在醫師的診療之後，
醫療相關的技術人員也能夠透過代理人提
供相關維持健康的設備，幫助居家的糖尿
病患者能夠有完善的醫療照護。Joseph, et 
al. [129] 他們創造了一個新的方法，讓原本
存在於醫院系統中能夠被一般人所負擔的
並且容易使用的醫療服務搬移到居家中，
透過網路與通訊的技術與根據使用者的需
要打造智慧型居家醫療系統，讓病患能夠
在家隨處記錄身體資訊與使用需要的醫療
服務。 
 
七、四 雲端運算資料安全性 
 
由於網路基礎建設與各式行動上網設備
的普及，隨時隨地與網路連結已非難事，
甚至成為一種普遍現象。藉由網路普遍化
的便利性，再加上虛擬化 (Virtualization) 技
術的成熟，自 2006 年亞馬遜 (Amazon) 率
先推出彈性雲端運算服務 (Amazon Elastic 
Compute Cloud；Amazon EC2) [23] 以來，
各式各樣的雲端運算服務 (Cloud Computing 
Services) 正蓬勃發展。除一般常見的雲端
醫療資料儲存 (Data Storage) 服務外，更多
生活應用導向的雲端運算服務正協助使用
者在日常生活中進行各項資料處理、存
取，甚至是信息提供與反饋 (Feedback)。例
如 Google 文件 (Google Docs) [24] 雲端運算
服務提供相關資源讓資料擁有者  (Data 
Owner) 可透過其建置於雲端的服務，觀看
與編輯資料擁有者已上傳至該雲端服務中
的文件  (Documents)。又如 salseforce.com 
[25] 的「銷售雲」(Sales Cloud) 雲端運算服
務讓資料擁有者可透過雲端存取、操作及
分析各種業務相關資料，此外，像是 IBM 
的 LotusLive iNotes [26] 提供結合電子郵件 
(E-mail) 的行事曆系統，讓資料擁有者能將
行程資料上傳至雲端，並隨時隨地透過行
動電話等設備存取，更方便地安排生活上
的大小事。Google 地圖 (Google Map) [27] 
除了單純的地圖索引，更提供了有效的路
況導航資訊。此外，目前雲端運算服務提
供者 (Cloud Computing Service Providers) 正
預計讓資料擁有者提供更多的個人資料以
供應為資料擁有者量身訂做，更適切不同
場合的協助資訊，例如 Google 便預計推出
因地制宜 (Context-Aware) 的雲端資訊回饋
服務 (Contextual Discovery) [28]，透過主動
取得更多的個人資料，像是藉由個人行動
裝置  (Mobile Device) 上的全球定位系統 
(Global Position System，GPS) 取得資料擁
有者目前所在的位置，以提供如所在地附
保雲端服務的可信度與資料隱私性。但實
際上雲端運算服務的各項內部量測數據在
目前資料擁有者是無法取得的，更遑論能
進而評估；目前的雲端運算服務也沒有提
供相關服務讓資料擁有者能追蹤其上傳至
雲端的資料。[10] 認為為了取得資料擁有
者對於雲端運算服務的信任，雲端運算服
務提供者應時常釋出各項量測數據給資料
擁有者或是第三方團體作評估，以提升資
料擁有者信任度。但 [9] 也指出，基於商業
利益，以及問題數據可能對雲端運算服務
提供者造成的商業傷害與打擊，部分雲端
運算服務提供者必然會對資料擁有者隱瞞
一些如資料遭竊、資料隱私防護出現漏洞
等不利事實。 
總結來說，由於資料擁有者需將大量資
料暴露在雲端運算服務中，但卻對這些雲
端醫療資料有極少的掌握度與控制權，因
此造成資料擁有者在使用雲端運算服務時
對於資料隱私的保護有所顧慮與恐懼，甚
至可能阻礙雲端運算服務的發展  [8-10, 
14]。目前的研究大都將重點放在雲端服務
提供者端，協助雲端服務提供者改善其資
料存放與保護方式，避免遭到外部惡意攻
擊。但目前尚無研究協助資料擁有者針對
雲端醫療資料進行主動式控制以保護雲端
醫療資料隱私。事實上，提昇資料擁有者
對於雲端醫療資料掌控度的重要性是不容
置疑的，提昇資料擁有者對於雲端醫療資
料掌握度與控制權對於資料擁有者來說是
一種對於雲端醫療資料隱私的主動防護，
將有助於提昇資料擁有者對雲端運算服務
的信心與信任，進而增加雲端運算服務的
使用率，促使雲端運算服務的發展。 
 
八、學術成就、技術創新與社會影響 
 
現存的醫療服務系統在發展初期大多沒有
考慮其互通性，因為大多數的系統都是獨
立被開發的，且當初的目的也不是為了支
援整合性醫療服務，而是針對特殊醫療服
務的需求。因此，在許多醫療服務系統陸
續被提出之後，服務間整合才漸漸浮上檯
面成為一個新的問題。在目前現有技術
中，服務導向運算 在近年來已大量地被用
來解決異質性系統整合不易的問題。因為
在服務導向運算之下，所有系統所對外提
供的功能全部被包裝成服務 ，透過這個封
裝，所有存在於不同的實現程式語言、執
行環境、設計等等異質性都被恰當的隱
藏，只單純留下功能性的服務。服務導向
運算這個願景要能實現主要依賴於其底層
的服務導向架構 。服務導向架構定義了不
同的服務之間，該以什麼樣的機制以及什
麼樣的溝通介面，透過網路進行合作。同
時在服務導向運算內，把執行環境以及部
署問題留在各個軟體系統中，使得上述的
軟體開發複雜度可以被分散處理。而以服
務的角度來建構與組合軟體，使得系統的
彈性增加，允許各種本質差異性大的軟體
服務，能夠在執行時期動態地參與系統運
作，滿足在使用者端，以及隨著環境變
化，所不斷有所改變的需求。本計畫針對
在醫療看護領域，將服務導向運算的概念
引入到醫療服務的需求表達，找尋，篩
選，以及整合，其中對於數種軟體工程領
域的工程技巧，投射到醫療服務軟體領域
加以檢視改進。其中包含軟體介面的設
計，軟體需求規格訂製，軟體品質的保證
以及重構技巧的使用，以及從系統層級考
量資料安全的機制等等。亦發表多篇各主
題相關的會議論文。 
 
本計畫提出一個因時因地制宜的醫療服務
整合，病人提供其位置與對於醫療服務的
需求給“醫療服務整合系統”(Medical Service 
Adapter)，其所預期的醫療服務的使用權將
會被“醫療服務整合系統”所遞交給病人。透
過這個整合，病人可以隨時隨地使用所需
要的醫療服務。 
 
相對於此，既存的技術偏重於被動式的醫
療服務提供。無論是基於位置導向之室內
服務探索，以及基於本體論 (Ontology) 的服
實上都需要對於服務進行衡量與測試，以
驗證所找尋到的服務，以及整合而成的服
務可以符合需求，並且不會因為發生錯誤
的導致醫療行為上無可挽回的損失。在醫
療服務的測試與驗證上，同樣是基於已日
趨成熟的軟體元測試概念。此應用於醫療
服務整合的服務導向架構並非僅僅是一個
軟體架構，而是包含了一個服務導向軟體
開發流程。此服務導向軟體開發流程是基
於傳統的軟體開發流程，希望延續過去分
為軟體分析，設計，實作以及測試等各階
段，以降低開發複雜度的優點，同時採用
軟體重用的重要觀念，使得在整合區域化
服務的過程中，能夠同時堅守以合理的時
間以及成本，完成整合型服務的產生之基
本原則。是故，能夠以有效率的方式完成
醫療相關服務整合，並且得到具有高品質
的整合型醫療服務。 
 
十、參考文獻 
 
[1] W.-C. Hu and H. C. Jiau, “Class Diagram 
Layout by Design Pattern Examples,” The 20th 
Workshop on Object-Oriented Technology and 
Applications, Nov. 2009.  
 
[2] L. W. Mar, K. C. Wu, and H. C. Jiau, “A 
Scripting Environment for Refactoring Process 
Execution,” 2011 Joint Conference on Taiwan 
Software Engineering and Object-Oriented 
Technology and Applications, pp. 176-181, 
July 2011  
 
[3] K. C. Wu, H. C. Jiau, and L. W. Mar, 
“Guiding API Utilization by Usage Patterns,” 
2011 Joint Conference on Taiwan Software 
Engineering and Object-Oriented Technology 
and Applications, pp. 189-194, July 2011 
 
[4] C.-W. Hu, L. W. Mar, and H. C. Jiau, “A 
Game-Based Programming Learning 
Environment,” 2011 Joint Conference on 
Taiwan Software Engineering and Object-
Oriented Technology and Applications, pp. 
201-206, July 2011 
 
[5] L. W. Mar, M. L. Lee, and H. C. Jiau, 
“MAVIS: A Visualization Tool for Cohesion-
based Bad Smell Inspection,” 2011 Joint 
Conference on Taiwan Software Engineering 
and Object-Oriented Technology and 
Applications, pp. 401-406, July 2011. 
 
[6] W.-C. Hu and H. C. Jiau, “A Visualization-
based Middleware Architecture in Supporting 
UML Design Tool Interoperation,” 2011 Joint 
Conference on Taiwan Software Engineering 
and Object-Oriented Technology and 
Applications, pp. 472-477, July 2011. 
 
[7] 胡倩瑋, 焦惠津, “主動式雲端資料隱私保
護機制,” 2011 Symposium on Digital Life 
Technologies, July 2011 
 
[8]  K. Miller, J. Voas, and P. Laplante, “In 
Trust We Trust,” Computer, vol. 43, no. 10, pp. 
85-87, Oct. 2010. 
 
[9] N. Kshetri, “Cloud Computing in 
Developing Economies,” Computer, vol. 43, 
pp. 47 -55, 2010. 
 
[10] L. M. Kaufman, “Data Security in the 
World of Cloud Computing,” IEEE Security 
and Privacy, vol. 7, no. 4, pp. 61-64, Jul. 2009. 
 
[11] C. Wang, Q. Wang, K. Ren, and W. Lou, 
“Privacy-Preserving Public Auditing for Data 
Storage Security in Cloud Computing,” 
Proceedings of the 29th Conference on 
Information Communications, pp. 525-533, 
2010. 
 
[12] M. Jensen, J. Schwenk, N. Gruschka, and 
L. L. Iacono, “On Technical Security Issues in 
Cloud Computing,” Proceedings of the 2009 
IEEE International Conference on Cloud 
Computing, pp. 109-116, 2009. 
 
[32] Michael N. Huhns and Munindar P. Singh, 
"Service-Oriented Computing: Key Concepts 
and Principles," IEEE Internet Computing, vol. 
9, no. 1, pp.75-81, 2005 
 
[33] Gavran, A Milanovic and S Srbljic, “End-
User Programming Language for Service-
Oriented Integration,” Proceedings of the 
Workshop on Distributed Data and Structures, 
January 2006 
 
[34] 劉建宏, 林修儀, “一個支援網際服務監
督及測試的工具,” 全國計算機會議(NCS)論
文集, 2005 
 
[35] 廖慶榮, 戚玉樑, 歐陽芳泉, “以格網服務
為導向之行動學習架構,”全國計算機會議
(NCS)論文集, 2003 
 
[36] 潘志勝, 古東明, 卓忠志, “位置導向之室
內服務探索系統,” 全國計算機會議(NCS)論
文集, 2003 
 
[37] 李允中, 馬尚彬, 張文芳, 謝禎冏, 賀光
鵬, “整合網際服務與 OSGi 服務,” 全國計算
機會議(NCS)論文集, 2003 
 
[38] 杜勇進, 蔡尚榮, 李嘉銘, 陳志達, 姚岦
昕, "引用網絡服務技術之位置感知資訊服
務," 全國計算機會議(NCS)論文集, 2005 
 
[39] Jonathan Lee, Shang-Pin Ma, Shin-Jie 
Lee, Yao-Chiang Wang, Yin-Yan Lin, 
"Discovery-Based Service Composition," 
Proceedings of the International Computer 
Symposium, 2006 
 
[40] Hau-Wei Chang, Chiung-Wei Huang, and 
Hahn-Ming Lee, "Service-Oriented Search: A 
Ranking and Retrieval Model based on 
Ontology of Service Relation," Proceedings of 
the International Computer Symposium, 2006 
 
[41] Irene Y.L. Chen, Stephen J.H. Yang, Jeff 
J.S. Huang, and Blue C.W. Lan, "Ubiquitous 
Provision of Context Aware Web Services," 
Proceedings of the International Computer 
Symposium, 2006 
 
[42] Hung-Ta Lu and Chua-Huang Huang, "A 
Service Oriented Execution Model of 
Financial Online Transactions," Proceedings of 
the International Computer Symposium, 2006 
 
[43] Jing-Ying Chen and Chun-Han Lin, 
"Scenario-Based Service Specification and 
Testing," Proceedings of the International 
Computer Symposium, 2006 
 
[44] Manoj Paul and S. K. Ghosh, "An 
Approach for Service Oriented Discovery and 
Retrieval of Spatial Data," Proceedings of the 
International Workshop on Service-Oriented 
Software Engineering, pp.88-94, 2006 
 
[45 Ling Ye, Yungang Li and Jiaao Zhao, 
"Research of Service-Oriented and Event-
Driven Teleconsultation Platform," 
Proceedings of the 24th IASTED International 
Conference on Biomedical Engineering, pp.75-
80, 2006 
 
[46] S. Krishnan, K. K. Baldridge, J. P. 
Greenberg, B. Stearn, and K. Bhatia, "An End-
to-End Web Services-Based Infrastructure for 
Biomedical Applications," Proceedings of the 
6th IEEE/ACM International Workshop on 
Grid Computing, pp.77-84, 2005 
 
[47] Xiaolin Lu, "An Investigation on Service-
Oriented Architecture for Constructing 
Distributed Web GIS Application," 
Proceedings of the 2005 IEEE International 
Conference on Services Computing, vol.1, 
pp.191-197, 2005 
 
[48] Declan Dagger, Alexander O'Connor, 
Seamus Lawless, Eddie Walsh, and Vincent P. 
Wade, "Service-Oriented E-Learning 
[62] M. Stal, "Using Architectural Patterns and 
Blueprints for Service-Oriented Architecture," 
IEEE Software, vol.23, no.2, pp.54-61, March-
April 2006 
 
[63] B. A. Malloy, N. A. Kraft, J. O. Hallstrom, 
and J. M. Voas, "Improving the Predictable 
Assembly of Service-Oriented Architectures," 
IEEE Software, vol.23, no.2, pp.12-15, March-
April 2006 
 
[64] N. Gold, A. Mohan, C. Knight, and M. 
Munro, "Understanding Service-Oriented 
Software," IEEE Software, vol.21, no.2, pp.71-
77, March-April 2004 
 
[65] S. Jones, "Toward An Acceptable 
Definition of Service," IEEE Software, vol.22, 
no.3, pp.87-93, May-June 2005 
 
[66] D. Ardagna and B. Pernici, "Adaptive 
Service Composition in Flexible Processes," 
IEEE Transactions on Software Engineering, 
vol.33, no.6, pp.369-384, June 2007 
 
[67] M. Perepletchikov, C. Ryan, K. Frampton, 
and Z. Tari, "Coupling Metrics for Predicting 
Maintainability in Service-Oriented Designs," 
Proceedings of 18th Australian Software 
Engineering Conference, pp.329-340, April 
2007 
 
[68] Jing Dong, Sheng Yang, D. S. Lad, and 
Yongtao Sun, "Service Oriented Evolutions 
and Analyses of Design Patterns," Proceedings 
of Second IEEE International Workshop on 
Service-Oriented System Engineering, pp.11-
18, 2006 
 
[69] F. Chen, S. Li, H. Yang, Ching-Huey 
Wang, and W. Cheng-Chung Chu, "Feature 
Analysis for Service-Oriented Reengineering," 
Proceedings of 12th Asia-Pacific Software 
Engineering Conference, 2005 
 
[70] A. M. S. Filho, H. K. E. Liesenberg, and 
R. S. M. Barros, "Interaction Pattern Gathering 
in Service-Oriented Applications," 
Proceedings of IEEE International Workshop 
on Service-Oriented System Engineering, 
pp.129-134, 2005 
 
[71] T. C. Shan, "Building a Service-Oriented 
ebanking Platform," Proceedings of Second 
IEEE International Conference on Service 
Computing, pp.237-244, 2004 
 
[72] M. Perepletchikov, C. Ryan, K. Frampton, 
H. W. Schmidt, "A Formal Model of Service-
Oriented Design Structure," Proceedings of 
18th Australian Software Engineering 
Conference, pp.71-80, April 2007 
 
[73] Manfred Broy, Ingolf H. Krüger, and 
Michael Meisinger, "A Formal Model of 
Services," ACM Transactions on Software 
Engineering and Methodology, vol.16, no.1, 
February 2007 
 
[74] Brenda Dietrich, "Resource Planning for 
Business Services," Communications of the 
ACM, vol.49. no.7, pp.62-64, July 2006 
 
[75] Roland T. Rust and Carol Miu, "What 
Academic Research Tells Us about Service," 
Communications of the ACM, vol.49. no.7, 
pp.49-54, July 2006 
 
[76] Ahmed Elfatatry and Paul Layzell, 
"Negotiating in Service-Oriented 
Environments" Communications of the ACM, 
vol.47. no.8, pp.103-108, August 2004 
 
[77] Fabio Casati, Eric Shan, Umeshwar Dayal, 
and Ming-Chien Shan, "Business-Oriented 
Management of Web Services," 
Communications of the ACM, vol.46, no.10, 
pp.55-60, October 2003 
 
[78] Ioana Manolescu, Marco Brambilla, 
Stefano Ceri, Sara Comai, and Piero Fraternali, 
Quality and Its Implications for Future 
Research,” Journal of Marketing, vol. 49, pp. 
41-50, 1985 
 
[94] A. Parasuraman, V. A. Zeithaml, and L. L. 
Berry, “SERVQUAL: A Multiple-item Scale 
for Measuring Consumer Perceptions of 
Service Quality,” Journal of Retailing, vol. 64, 
pp. 12-40, 1988 
 
[95] A. Parasuraman, V. A. Zeithaml, and L. L. 
Berry, “Communication and Control Process 
in the Delivery of Service Quality,” Journal of 
Marketing, vol. 52, Apr. 1988 
 
[96] Nitin Nayak, Anil Nigam, Jorge Sanz, 
David Marston, and David Flaxer, "Concepts 
for Service-Oriented Business Thinking," 
Proceedings of the IEEE International 
Conference on Services Computing, pp.357-
364, 2006 
 
[97] P. Yolum and M.P. Singh, "Engineering 
Self-Organizing Referral Networks for 
Trustworthy Service Selection," IEEE Trans. 
Systems, M and Cybernetics, Part A: Systems 
and Humans, vol. 35, no. 3, pp. 396-497, 2005. 
 
[98] B. Yu and M.P. Singh, “Emergence of 
Agent-Based Referral Networks,” Proc. First 
Int’l Jo9int Conf. Autonomous Agents and 
Multi-Agent Systems (AAMAS ’02), pp. 
1268-1269, 2002. 
 
[99] T. D. Huynh, N.R. Jennings, and N. 
Shadbolt, “Fire: An Integrated Trust and 
Reputation Model for Open Multiagent 
Systems,” Proc. 16th European Conf. Artificial 
Intelligence (ECAI ’04), pp. 18-22, 2004. 
 
[100] M. Sensoy and P. Yolum, "Ontology-
Based Service Representation and Selection," 
IEEE Transactions on Knowledge and Data 
Engineering, vol. 19, no. 8, pp. 1102-1115, 
August 2007. 
 
[101] Y. Lee, C. Patel, and S.A. Chun, 
"Towards Intelligent Web Services for 
Automating Medical Service Composition," 
Proceedings of the IEEE International 
Conference on Web Services (ICWS'04), pp. 
384-391, 2004. 
 
[102] Christian Zirpins, Winfried Lamersdorf, 
and Toby Baier, "Service Composition: 
Flexible Coordination of Service Interaction 
Patterns," Proceedings of the 2nd International 
Conference on Service Oriented Computing, 
pp.49-56, 2004. 
 
[103] D. Ardagna and B. Pernici, "Adaptive 
Service Composition in Flexible Processes," 
IEEE Transactions on Software Engineering, 
vol.33, no.6, pp.369-384, June 2007. 
 
[104] Robert J. Hall and Andrea Zisman, 
"Behavioral Models as Service Descriptions," 
Proceedings of the 2nd International 
Conference on Service Oriented Computing, 
pp.163-172, November 2004. 
 
[105] Islam Elgedawy, Zahir Tari, and Michael 
Winikoff, "Exact Functional Context Matching 
for Web Services," Proceedings of the 2nd 
International Conference on Service Oriented 
Computing, pp.143-152, November 2004. 
 
[106] C. L. Wu, C. F. Liao, and L. C. Fu, 
“Service-Oriented Smart-Home Architecture 
Based on OSGi and Mobile-Agent 
Technology,” IEEE Transactions on Systems, 
Man, and Cybernetics, Vol. 37, No. 2, pp. 193-
205, March 2007. 
 
[107] Brenda Dietrich, "Resource Planning for 
Business Services," Communications of the 
ACM, vol.49, no.7, pp.62-64, July 2006 
 
[108] Rafik Amir, Amir Zeid, "A UML Profile 
for Service Oriented Architectures," 
Conference on Object Oriented Programming 
Therapy,” ACM Journal of Computing 
Sciences in Colleges, vol. 21, no. 2, pp. 250-
257, 2005 
 
[123] H. W. Chiu, L. S. Lin, M. C. Kuo, H. S. 
Chiang and C. Y. Hsu, “Using Heart Rate 
Variability Analysis to Assess the Effect of 
Music Therapy on Anxiety Reduction of 
Patient,” IEEE Computers in Cardiology, pp. 
496-472, Sept. 2003 
 
[124] X. F. Teng, M. Y. M. Wong and Y. T. 
Zhang, “The Effect of Music on Hypertensive 
Patients,” Engineering in Medicine and 
Biology Society, pp. 4649-4651, Aug. 2007 
 
[125] A. K. Rathi and R. S. Solanki, 
“Simulation of Traffic Flow During 
Emergency Evaluations: A Microcomputer 
Based Modeling System,” Proceedings of the 
1993 Writer Simulation Conference, pp. 1250-
1258, Dec. 1993 
 
[126] T. F. Brady, “Emergency Management: 
Capability Analysis of Critical Incident 
Response,” Proceedings of the 2003 Writer 
Simulation Conference, vol. 2, 1863-1867, 
Dec. 2007 
 
[127] C. Caceres, E. J. Gomez, F. Garcia, J. M. 
Gatell and F. D. Pozo, “An Integral Care 
Telemedicine System for HIV/AIDS patients,” 
ELSEVIER International Journal of Medical 
Informatics, vol. 75, no. 9, pp. 638-642, Sep. 
2006 
 
[128] G. Haan, O. B. Henkemans and A. 
Aluwalia, “Personal Assistants for Healthcare 
Treatment at Home”, ACM International 
Conference Proceeding Series, vol. 132, pp. 
225-231, 2005 
 
[129] V. C. Joseph, S. H. Ahn, K. Jiyong, K. H. 
Lee and D. H. Kim, “Intelligent Healthcare 
Systems: Re-defining Personal Healthcare 
Solutions, ” Advanced Communication 
Technology 2005, vol. 1, pp. 424-427, July 
2005 
 
[130] Jin-Ling Lo, Tung-yun Lin, Hao-hua 
Chu, Hsi-Chin Chou, Jen-hao Chen, Jane 
Yung-jen Hsu, and Polly Huang, "Playful Tray: 
Adopting Ubicomp and Persuasive Techniques 
into Play-based Occupational Therapy for 
Reducing Poor Eating Behavior in Young 
Children," International Conference on 
Ubiquitous Computing, 2007 
 
[131] Keng-hao Chang, Shih-yen Liu, Hao-hua 
Chu, Jane Yung-jen Hsu, Cheryl Chen, Tung-
yun Lin, Chieh-yu Chen and Polly Huang, 
"The Diet-Aware Dining Table: Observing 
Dietary Behaviors Over a Tabletop Surface," 
Proceedings of International Conference on 
Pervasive Computing, 2006 
 
 2 
使用者與網路，並在系統後端保存此龐大的社會資料，使得此方向的研究充滿可能性。 Alfred Spector 
副總裁並提到，如果我們能夠得到真正足夠大量的資料，我們將有可能直接就資料來解釋某些現象發
生的原因，進而即時做出決策判斷。 人們將可以從系統 (搜尋引擎或是 E-Science 系統) 得到知識，
而得到的知識促使人們產生更多的資料給系統，系統藉此推論出更多的知識 ( People learn from the 
System，and the System learns from the Data) 在這樣的願景下，其實還有諸多難題需要直接結合 
Software Engineering & Knowledge Engineering 兩個領域進行研究。 例如最受關心的隱私權問題 
( Privacy Issue )，目前尚缺乏真正具影響力的研究成果。 另外極大的系統規模必然會使得一些關於規
模的議題更加重要，例如目前 iPhone 上有超過 22000 項應用軟體可以選擇，其中最少也會有一項軟
體在實際運作時，產生對於資料的安全性問題。 而在系統內，透過各種方法所搜集的大量資料，又要
如何被重新用來預測可行的決策，回答各種可能的問題等等，都有待進一步的研究。 
 
    而 Josephine Cheng 針對建立更聰明的世界 (Smarter World) 與軟硬體電腦系統以及綠能環境的關
聯為主體作演講。Josephine Cheng 副總裁主要透過 IBM 目前在世界各地所進行的各種計畫以及其成
效為主題，以計畫帶動演講內容。 比較令人訝異的是，IBM 的各項計畫並非以電腦系統為主體，而
是以各種社會面向為出發，從 Socio-Technical System 的角度在經營計畫，並從中找出可以利用電腦系
統來輔助計畫進行的方式。 因此從 Josephine Cheng 副總裁的介紹之中，其實內容涵蓋了許多看似跟
電腦系統無關，或是跟綠能環境無關的計畫主題。 但若深入細想，會發現 IBM 在此議題上的主張其
實並不是一味地要求節省能源，而是在進行各項先端的未來研究，或是大型社會計畫的過程中，儘量
做到節省能源。 
 
    Keynote 結束後可以取用一些點心飲料，準備上下午的各領域的議程，同一時間通常有 3-4 個議程
同時進行，我都選擇有興趣的議程去參與。 
參與議程 
SEKE 2010 會議包含以下 Sessions:  
1. Machine Learning with Value-Based Software Engineering  
2. Software Requirement Engineering I  
3. Software Validation  
4. Interoperability and Semantic Web Technologies  
5. Software Requirement Engineering II  
6. Software Quality Assurance I  
7. Software Measurement  
8. Software Architectures  
9. Software Test Automation, Practice, and Standardization  
10. Software Engineering with Computational Intelligence and Machine Learning  
11. Web Services I  
12. Software Regression Testing I  
13. E-Commerce and Mobile Commerce  
14. Web Services II  
15. Software Framework and Application Tools  
16. Knowledge Engineering I  
 4 
 
二、與會心得 
    美國對我而言不是一個陌生的地方，之前求學以及工作都待過很久。但是參加此次會議實為
我個人的全新經驗，對於 SEKE 舉辦一個國際會議所需之組織、根據主題所需邀請的人員、場地
的準備、會議流程的安排、以及對於貴賓、論文作者之招待，都面面俱到。在這次會議的過程裡，
也認識了其他參與會議的朋友，有久未碰面的老朋友，有朋友的朋友，有新結交的朋友，有會議
負責的同學，也有許多同是前來進行報告的同學，彼此分享經驗彼此交流，感覺非常的棒。 
我認為舉辦國際性會議時，好的論文議題與好的講者能夠吸引與留下有素養的聽眾，使得會議在
實質面上有活絡的活動，讓研究彼此激盪知識彼此交流，我期許自己能夠參與更多國際會議，累
積閱覽與經驗並觀摩相關的做法。 
三、考察參觀活動(無是項活動者略) 
    本次會議我並無參加其他考察參觀活動。 
四、建議 
    此行參與會議，在美國生活數日，再度觀察美國人的都市建設與生活習慣，又有一番不同的
體會。綜觀來說，舊金山地區普遍環境整潔，車站周邊的行人都穿戴得宜，對待外國人也相當的
親切。細部地觀察，我發現以下幾點值得台灣效法： 
1. 人民的品德教育：因此雖為大城市但街道不擁擠，空氣乾淨，相當適合人們居住。 
2. 公共設施考量周全：印象深刻的是在舊金山的十字路口，除了有導盲磚之外，更設有蜂鳴
裝置，提醒盲胞現在紅綠燈的狀態，在樓梯的入口也設置有類似裝置告知阻礙。以聲音
提醒盲胞點字位置，使得盲障設施不會變成空有其表的建設。 
 
 
 
April 21, 2010 
 
 
Wei-Chung Hu 
Institute of Computer and Communication Engineering, National Cheng Kung University 
No.1, Daxue Rd., East Dist., Tainan City 701, Taiwan (R.O.C.) 
Tainan 70101 
Taiwan 
 
Dear Wei-Chung Hu: 
 
This letter is to confirm that the paper “VESTA: A View-based Software Quality Assessment Model for 
Software Evolution Management” by  Wei-Chung Hu is officially accepted. You are cordially invited to 
attend the Twenty-Second International Conference on Software Engineering and Knowledge 
Engineering (SEKE2010) which will be held at the Hotel Sofitel, Redwood City, San Francisco Bay, 
USA from July 1 to July 3, 2010. The conference aims at bringing together experts in software 
engineering and knowledge engineering to discuss on relevant results in either software engineering or 
knowledge engineering, or both. Special emphasis will be put on the transference of methods between 
both domains. 
 
 The conference is organized by researchers and scholars all over the world, dedicated to 
software & knowledge engineering. This is the official conference founded in 1989. We expect scholars 
from many countries will attend this conference. We look forward to meeting you there. 
  
 
 
Sincerely,  
 
 
 
Shi-Kuo Chang, Chair 
Steering Committee 
SEKE 2010 Conference
Figure 2. The internal structure of VESTA.
needed when stakeholders acquire an OSS product built
with multiple programming languages. Unfortunately, cur-
rent assessment tools cannot be used directly to investi-
gate an OSS product built with multiple programming lan-
guages. In this study, a View-basEd Software qualiTy
Assessment model (VESTA) is proposed to conquer such
an issue. In VESTA, the views from stakeholders can be
expressed by (1) the quality assessment context and (2) the
quality assessment heuristic. Based on the expressed views,
the selected metrics, quality models, and quality assessment
processes will be associated and configured to a new inte-
gral assessment process in VESTA. The integral assessment
process will be performed to generate required quality data
for stakeholders.
2. VESTA
Figure 1 shows the context diagram of VESTA. The in-
puts of VESTA come from the Stakeholders and the Soft-
ware Artifacts Repository. The output of VESTA is the
Software Quality Assessment Report to the stakehold-
ers according to the given software quality view. To es-
tablish the quality assessment context, stakeholders specify
the quality assessment context and select quality assessment
heuristics in the software quality view. The internal struc-
ture of VESTA is shown in Figure 2, which constitutes of
four major elements: (1) Software Quality View, (2) Met-
ric Suites Repository, (3) Configurable Quality Models,
and (4) Assessment Process Template.
Software quality view includes the quality assessment
context and the quality assessment heuristic. The quality
assessment context defines the context in which the stake-
holders are going to observe software quality evolution. The
measurement subjects, granularity, and the weight of di-
verse measurement subjects will be specified in the quality
assessment context. On the other hand, the quality assess-
ment heuristic represents the heuristic configuration of as-
sessment process in the specified quality assessment con-
text. For example, the quality assessment heuristic may
include (a) metrics that will be used, (b) quality attributes
and models with specific statistics methods, and (c) the
metrics measurement results correlated with high-level soft-
ware qualities. Various software metrics are implemented in
the metric suites repository. According to specified software
quality views, VESTA will match corresponding metrics
from it to perform quality assessment. New metrics could
be implemented and added into it to support more software
quality assessment tasks. Most commonly used quality
models are all implemented in VESTA. Configurable tun-
ing points are identified and exposed during the implemen-
tation. Through these tuning points, specific configurations,
such as the replacement of metrics and the folk of measure-
ment process, can be made.
The assessment process template defines a series of ac-
tivities to generate an integral assessment process. First,
the quality assessment context provides the context config-
uration to the assessment process template through tuning
points (Figure 2). The tuning points are exposed by the
assessment process template to allow configuration from
stakeholders’ quality views. Second, through the context
configuration, the software artifact processing components
inside the template can be selected and tuned. The responsi-
bility of software artifact processing components is to pre-
pare the software artifacts for quality assessment. Third,
the quality assessment heuristic also provides the heuristic
configurations to the assessment process template. By inter-
preting the heuristic configuration, metrics and configurable
quality models will be selected. Fourth, the selected metrics
and quality models will be integrated with connectors. The
connectors are components inside the template, which can
control the data flow in integral assessment process. Finally,
the integral assessment process will then be generated ac-
cording to the assessment process template, context config-
urations and heuristic configurations for quality assessment
in VESTA.
2.1. Utilization of VESTA under the Multi-
Languages View
In this study, the software quality assessment template
is instantiated with Bansiya and Davis’s hierarchical qual-
ity model [8]. The leveling and the identified tuning points
are depicted in Figure 3. There are four levels: the compo-
nent level (L4), the metrics level (L3), the properties level
(L2) and the quality attributes level (L1). Figure 4 demon-
strates the flow of an assessment process under multi-
languages view while assessing the ANTLR open source
project (http://www.antlr.org). As the developers consider
assessing different implementations of ANTLR in Java and
Figure 4. An instantiated software quality assessment process with the multi-languages view.
Figure 5. The quality evolution of ANTLR project in the multi-languages view.
heuristic, available quality models and metrics can be se-
lected and adapted to perform the corresponding quality as-
sessment under the specified quality assessment context.
References
[1] H. Ogasawara, A. Yamada, and M. Kojo, “Experi-
ences of Software Quality Management Using Metrics
through the Life-Cycle,” Proc. 18th Int’l Conf. on Soft-
ware Engineering, pp. 179–188, Mar. 1996.
[2] H. Gall, M. Jazayeri, R. R. Klo¨sch, and G. Trausmuth,
“Software Evolution Observations Based on Product
Release History,” Proc. 13rd Int’l Conf. on Software
Maintenance, pp. 160–166, Oct. 1997.
[3] M. W. Godfrey and Q. Tu, “Evolution in Open Source
Software: A Case Study,” Proc. 16th Int’l Conf. on Soft-
ware Maintenance, pp. 131–142, Oct. 2000.
[4] X. Franch and J. P. Carvallo, “Using Quality Models in
Software Package Selection,” IEEE Software, vol. 20,
no. 1, pp. 34–41, Jan./Feb. 2003.
[5] G. Robles, J. M. Gonzalez-Barahona, M. Michlmayr,
and J. J. Amor, “Mining Large Software Compilations
Over Time: Another Perspective of Software Evolu-
tion,” Proc. Int’l Workshop on Mining Software Repos-
itories, pp. 3–9, May 2006.
[6] F. Deissenboeck, S. Wagner, M. Pizka, S. Teuchert,
and J. F. Girard, “An Activity-Based Quality Model
for Maintainability,” Proc. 23rd Int’l Conf. on Software
Maintenance, pp. 184–193, Oct. 2007.
[7] H. C. Jiau and C. H. Kao, “Assessing the Efficacy of
User and Developer Activities in Facilitating the Devel-
opment of OSS Projects,” Journal of Software Mainte-
nance and Evolution: Research and Practice, vol. 21,
no. 5, pp. 287–314, Sept./Oct. 2009.
[8] J. Bansiya and C. G. Davis, “A Hierarchical Model
for Object-Oriented Design Quality Assessment,” IEEE
Trans. Softw. Eng., vol. 28, no. 1, pp. 4–17, Jan. 2002.
 2 
 Neural Networks 
 Information Assurance and Intelligent 
 Distributed Intelligent Systems 
 Robotic Systems 
 Infrastructure Systems and Services 
 Expert and Knowledge-based Systems 
 Smart Sensor Networks 
 Intelligent Auto Surgery 
 Fault Monitoring and Diagnosis 
 Modeling, Systems and Control 
 Biometrical Applications 
 Image Processing 
 Intelligent Devices 
 Surveillance 
 Bioinformatics 
 Intelligent Home Environments 
 Human-Computer Interaction 
 Multimedia Application 
 High Performance Computing 
 Biomedical Applications 
 Computer Network and Architecture 
 Information Retrieval 
 Content-Based Retrieval 
 Distance Learning 
 IT Governance 
 Formal methods 
 
 
1. 會議中的 keynote speech 與 special presentation 
    這次會議中總共有 16 場的 keynote speech 與 special presentation。主講者都是國內外
世界一流的優秀學者，主要都跟最近在電腦科學與軟體工程領域相關的熱門研究方向與主
題，像是：流程方法(Workflow Approach)、運算與交流(Computing and Communication)、雲端
運算 (Cloud Computing) 、人機互動 (Human-Machine Interaction) 、手勢辨識  (Gesture 
Recognition)、電子學習系統(E-Learning Systems)，以及嵌入式系統發展與應用(Embedded 
System Development and Application)。藉由這些 keynote speech 與 special presentation，我可
以從中了解目前學術界以及業界最新的研究動態，以及相關可使用的科技與技術，進而增加
研究的能量。Keynote speech 與 special presentation 的相關資料如表一所示。 
 
 
 4 
立具有 user-centric automation 以及 assistance 性質的 devices 以及 systems。藉由目
前現有規範 workflow 的標準語言，使得 domain expert 可以使用這類型的語言來自行
定義以及規範相關的 business workflow。 
B. 第二個 keynote speech 的題目是：Computing and Communication: There's so much that 
we share in a flat and small world。該主講者也是來自於台灣的優秀學者--劉炯朗教授 
(Prof. C. L. Liu)。該主題主要是提到目前因為電腦與網路的普及，使得 computing 以
及 communication 變得頻繁，間接使得我們可以容易地進行分享，讓整個世界變得更
平也縮短了彼此間的距離。因此，劉炯朗教授提出以及討論如何應用現有的 
communication technologies 來建立一個祥和與繁榮的社會。 
在這兩個 keynote speech 中引起與會者的熱烈迴響以及討論，而兩位在軟體界大師級的學者
的妙語如珠，也使得整個會議氣氛輕鬆。他們長遠的眼光以及不凡的研究精神，更讓人領會
其大師風範，更有如沐春風之感。 
2. 會議中的 Sessions 
    會議中有很多的 sessions，都是與軟體和資訊相關的。Sessions 的資料如下所示。 
 High Performance Computing and Computer Networks 
 Advanced Topic in Computer Science 
 Geographic Information Systems & Image Processing 
 Natural Language Processing & Information Retrieval 
 Image Processing and Pattern Recognition 
 Software Engineering 
 Robotics 
 Bioinformatics 
 Information Systems & IT-Governance 
 E-Government, Knowledge Management, & Enterprise Resource Planning 
3. 論文報告的參與 
    本次報告的論文名稱是：Providing Direct Document Links for Framework Extension 
Tasks，所屬的 session 是 Advanced Topics in Computer Science。在報告中，我先提及這篇論
文的 context，告訴大家為何目前在 framework extension tasks 中需要 direct document links，
接著告訴大家關於我所提出建立 direct document links 的方法，以及成效的評估。在報告中，
與會者展現對於這篇論文高度的興趣，這充分表現出這篇論文在該軟體領域的重要性。此
外，這也充分展現出國立成功大學電機工程學系在軟體研發與應用出色的研究表現與潛力，
因此獲得國外學者的一致好評。在結束論文報告後，由於在報告時傑出的表現，因此獲得 Best 
presentation award。關於該 award 的資料，如圖一所示。另外，參與該會議也得到參與證明，
該參與證明的資料，如圖二所示。此外，我也在會議會場附近留影紀念。主要照了兩張照片，
分別在本報告中的圖三以及圖四。 
 6 
 
 
圖三：會場留影 (一) 
 
 8 
二、攜回資料名稱及內容 
2010 年先進電腦科學與資訊系統國際會議所有議程資料，其中包含： 
1. 會議名牌，代表參與會議之身份識別。 
2. 會議論文集，內容為會議宗旨、會議組織、會議地點資訊、會議流程資訊、Keynote Speech 
作者與內容簡介、會議議程與參與論文列表資訊。 
3. 會議論文光碟，內容為會議資訊、會議收集之論文本文 
4. 會議註冊收據。 
5. 會議周邊觀光與交通資訊。 
三、其他 
  無 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Providing Direct Document Links for
Framework Extension Tasks
Dung-Feng Yu
Institute of Computer and Communication Engineering
National Cheng Kung University
Tainan, Taiwan
Email: dfyu@nature.ee.ncku.edu.tw
Hewijin Christine Jiau
Department of Electrical Engineering
National Cheng Kung University
Tainan, Taiwan
Email: jiauhjc@mail.ncku.edu.tw
Abstract—When developing framework-based applica-
tions, application developers have to extend frameworks
into the specific tasks. Many online articles are provided
to support framework extension tasks. Those online
articles are one of the major resources that application
developers can get help with. Commonly many examples
are demonstrated in different viewpoints in those articles.
Application developers have to adapt those examples to
their specific framework extension tasks. During example
adaptation, more detailed information is still needed
to be abstracted from documents of many different
types. Searching for those documents takes application
developers a lot of efforts. In this paper, an approach
is proposed to eliminate the efforts by providing direct
document links between articles and documents. Besides,
a tool named ExDoc4U is developed to implement the
approach. The evaluation shows that the approach is
effective to provide direct document links for framework
extension tasks.
I. INTRODUCTION
Frameworks have been proven to provide develop-
ment advantages, such as improving software quality
and increasing software productivity, for application
developers using frameworks [1]. Because of those
advantages, many application developers build their
applications by using frameworks. For the two most
well-known frameworks, Eclipse and Firefox, there
have been more than 1000 Eclipse plug-ins which are
developed based on Eclipse and officially collected in
the Eclipse Marketplace [2]. More than 10,000 Fire-
fox add-ons are built based on Firefox and officially
released on the web site [3].
Applications which are developed by extending
frameworks are called f-extenders in this paper. F-
extenders (e.g. Eclipse plug-ins, Firefox extensions,
and Firefox plug-ins) are built by extending framework
slots, which are designed to allow future framework
extension. For example, extension points are frame-
work slots for Eclipse plug-ins [4], merge points are
framework slots for Firefox extensions [5], and plug-
in methods are framework slots for Firefox plug-ins
[6]. The tasks of extending framework slots are defined
as framework extension tasks in this work.
During framework extension tasks, one of the major
resources that f-extender developers can use is online
articles about f-extender development [7], [8]. These
articles often contain illustrative examples which f-
extender developers need to perform their framework
extension tasks. The following three types of examples
are common in the articles.
Type 1: Examples of f-extender configuration.
Examples of this type are for configuring f-extenders
so that f-extenders can fit in the framework slots. Dif-
ferent types of f-extenders require different methods
to configure. For instance, Eclipse plug-ins require
a plug-in manifest file named plugin.xml as a
configuration file [4]. Firefox extensions need an XUL
Overlay document as a configuration file [5], and
Firefox plug-ins require implementation of a specific
plug-in method.
Type 2: Examples of framework API usage.
Examples belonging to this type show the mechanisms
of calling the framework APIs. F-extenders can call
framework APIs to utilize functionalities of frame-
works.
Type 3: Examples of f-extender API usage. Ex-
amples in type 3 reveal f-extender APIs that should
be exposed to frameworks to make the call back. F-
extender API is the API that f-extender developers
should implement to support the callback mechanism
of frameworks. With the implementation of f-extender
APIs, new functionalities of f-extenders can be inte-
grated into frameworks.
To perform framework extension tasks, f-extender
developers have to adapt examples belonging to these
three types. During example adaptation, more detailed
information is still needed to be abstracted from the
1) configuration documents, 2) framework API docu-
ments and 3) f-extender API documents. To get more
detailed information, f-extender developers have to
spend a lot of efforts searching for necessary docu-
ments of three types. To eliminate the efforts for f-
extender developers, an approach is proposed in this
paper to provide direct document links between articles
and necessary documents. The direct document links
are further classified in three types according to the
type of the necessary documents they connect. With
the direct document links, f-extender developers can
easily find necessary documents during example adap-
tation. Besides, a tool named ExDoc4U is developed to
includes three web crawlers. Each of the web crawlers
is responsible for getting documents of one type and
extracting document information. The extracted docu-
ment information is classified into three categories.
Category 1: configuration information. The doc-
ument information extracted from configuration doc-
uments is configuration information. The document
information in category 1 contains the identifier of
the framework slot and the URL of the configuration
document.
Category 2: framework API information. Frame-
work API information is the document information ex-
tracted from framework API documents. It comprises
the identifier of the framework API and the URL of
the framework API document.
Category 3: f-extender API information. The
document information extracted from f-extender API
documents is called f-extender API information. The
document information belonging to category 3 consists
of the identifier of the f-extender API and the URL of
the f-extender API document.
B. Article Information Extractor
Taking the article URL as input, Article Information
Extractor extracts article information from the online
article. To get the online article and extract article
information, Article Information Extractor includes a
web crawler.
The article information contains keywords which
may be identifiers of framework slots, identifiers of
framework APIs, or identifiers of f-extender APIs. All
of the keywords can be extracted from the textual
description and code examples in the online article.
To extract keywords from the textual description, the
analysis of the HTML file content of the online article
is performed. The analysis result reveals that the key-
words are often enclosed by a set of particular HTML
tags, such as <pre></pre>, <code></code>, and
<em></em>, etc. Based on the analysis result, the
extraction rules are developed. More extraction rules
can be extended. Extracting keywords (e.g. identifiers
of framework APIs or identifiers of f-extender APIs)
from code examples is achieved through code analysis.
C. Document Link Constructor
After receiving the article information, Document
Link Constructor validates whether the keywords in
the article information exist in the Document Infor-
mation Storage or not. If a keyword exists in the
Document Information Storage, the keyword must be
an identifier of a framework slot, an identifier of a
framework API, or an identifier of an f-extender API.
Once a keyword passes the validation, Document Link
Constructor builds a direct document link. The direct
document link comprises the identifier and the URL of
a certain document of one type. All direct document
links are classified into different types according to
the type of documents they connect. As a result, there
are three types of direct document links. They are 1)
direct document links between articles and configu-
ration documents, 2) direct document links between
articles and framework API documents, and 3) direct
document links between articles and f-extender API
documents. The direct document links of three types
are returned to the f-extender developer as the result.
IV. TOOL IMPLEMENTATION
A tool named ExDoc4U is developed to implement
the approach. ExDoc4U is a web-based tool which
receives an article URL from f-extender developers
and returns direct document links to f-extender de-
velopers. The direct document links are classified and
appear in the sidebar of the web page of the online
article. ExDoc4U includes web crawlers to get content
of online articles and documents. Furthermore, the
web crawlers are used to extract information from
online articles and documents. The web crawlers are
implemented based on Scrapy [18], which is an open
source web scripting framework for python. Moreover,
code examples in the online articles are often provided
in the form of zipped files, so ExDoc4U automatically
download the zipped files and unzip them to get
code examples. Code analysis is performed on code
examples to extract identifiers of framework APIs and
identifiers of f-extender APIs.
V. EVALUATION
With respect to evaluation, an experiment described
in Section V-A is performed to evaluate the effective-
ness of the approach. Furthermore, a case study is
conducted in Section V-B to evaluate the usefulness
of ExDoc4U during example adaptation.
A. Experiment
The experiment setting involves the subject frame-
work, the subject f-extender, the subject necessary
documents, and the subject articles. Each of them is
described as follows:
Subject framework. Eclipse is chosen as the sub-
ject framework because it is popular and mature.
Subject f-extender. As to the subject f-extender,
Eclipse plug-ins are chosen because at least 1000
Eclipse plug-ins are developed and collected in the
Eclipse Marketplace [2].
Subject necessary documents. Necessary docu-
ments of three types (i.e., configuration documents,
framework API documents and f-extender API docu-
ments) are retrieved from Eclipse online documenta-
tion [19].
Subject articles. The articles about Eclipse plug-in
development are Eclipse articles posted in the Eclipse
Corner Articles [20]. Those articles are chosen be-
cause they are officially released articles about Eclipse
plug-in development. Hence, they are reliable and
mainly referenced by Eclipse plug-in developers.
TABLE I
THE EFFECTIVENESS EVALUATION OF THE APPROACH
True Positive False Positive False Negative Precision Recall F-Measure
2645 42 882 0.98 0.75 0.85
Fig. 6. Action Display of the Code Example in the Article.
Fig. 7. Execution Result of the Code Example in the Article.
Fig. 8. Adapted Configuration Example.
style for the action display (i.e., IR 2) instead of
an icon for the action display. As described in the
step 3 of the usage scenario, f-extender developers
know that an extension point with id popupMenus2
is used in the configuration example. They find a direct
document link to the extension point document of
popupMenus, which plays the role of configuration
documents. After clicking on the direct document
link, f-extender developers view the extension point
document and get more detailed information about
making a checked style for the action display. Then,
they adapt the configuration example. The adapted
configuration example is displayed in Fig. 8, in which
the lines enclosed by rectangles are the adapted parts3.
Step 5: Adapt the f-extender API usage in
the code example. Fig. 7 shows the name of
2Hereafter, popupMenus is used to represent
org.eclipse.ui.popupMenus for simplicity.
3In Fig. 8, each rectangle has its own label. The “(0)” label means
that the adapted part is for f-extender specific setting, such as id and
class name. The “(2)” label means that the adapted part is to fulfil
IR 2.
the class being executed. However, IR 1 requires
to detect the selected string in the text editor.
From the code example shown in Fig. 5, f-extender
developers guess that the f-extender API named
IEditorActionDelegate4 may provide support
for getting the selected string. Hence, they find the
direct document link to the f-extender API docu-
ment of IEditorActionDelegate. After read-
ing the f-extender API document, they find that
IEditorActionDelegate interface has a method
selectionChanged, which supports getting the se-
lected string. As a result, they adapt the code example
to get the selected string. The adapted code example
is shown in Fig. 9. The adapted part in this step is the
lines enclosed by rectangles with a “(1)” label which
means the adapted part is to fulfil IR 1.
Step 6: Adapt framework API usage in the
code example. As displayed in Fig. 7, the icon in
the message box is an information icon. However,
IR 3 requires a question icon in the message box.
From the code example shown in Fig. 5, f-extender
developers find that the message box is constructed by
instantiating an object of MessageBox5 class. Thus,
they guess that the framework API, MessageBox,
may allow change of the icon of message box. To
confirm the guess, they find a direct document link to
MessageBox framework API document. F-extender
developers read the framework API document and
know that another constructor of MessageBox class
supports displaying a question icon in the message
box. In this step, the adapted part in the adapted code,
as shown in Fig. 9, is the lines enclosed by rectangles
with a “(3)” label6 which means to fulfil IR 3.
Step 7: Run the adapted configuration example
and code example. After adapting the configuration
example and code example, f-extender developers can
run them. When running the adapted examples, f-
extender developers select a string “test file” and
trigger the action. As shown in Fig. 10, the action
display of the adapted code example appears with the
checked style (i.e., IR 2 is fulfilled). Then, f-extender
developers execute the action. A message box with
a question icon, as shown in Fig. 11, is displayed to
post a question about the detected string selection. The
execution result fulfills IR 1 and IR 3.
4Hereafter, IEditorActionDelegate is used to represent
org.eclipse.ui.IEditorActionDelegate for simplicity.
5Hereafter, MessageBox is used to represent
org.eclipse.swt.widgets.MessageBox for simplicity.
6In addition to the “(1)” and “(3)” labels explained previously,
there are also the “(0)” and “(4)” labels. The “(0)” label means the
adapted part is for f-extender specific package name and class name,
while the “(4)” label means the adapted part is to fulfil IR 4.
 1 
國科會補助專題研究計畫項下出席國際學術會議心得報告 
                                   日期： 100 年 12 月 12 日 
                                 
一、參加會議經過 
    亞太地區軟體工程學術研討年會是軟體工程領域的年度盛事，該年會吸引眾多亞太地區的
研究者以及業界開發人員參與並進行交流，本屆年會是第 18 屆年會，舉辦的地點為越南胡志
明市的麗仕酒店 (Rex Hotel)。下圖為開會地點 Rex Hotel 以及會議開始註冊時所拍攝照片。 
  
    本屆年會主題 「Software Engineering and Emerging Technologies」 (軟體工程與新興技術)，
計畫編號 NSC 97－2221－E－006－177－MY3 
計畫名稱 植基於醫療看護需求之情緒管理與促進服務運算系統 － 應用服務整
合與篩選運算架構於醫療看護運作體系 
出國人員
姓名 
馬  立  偉 
服務機構
及職稱 
國立成功大學電腦與通信工程研
究所博士班五年級學生 
會議時間 
100年 12月 5日至 
100年 12月 8日 
會議地點 越南胡志明市 
會議名稱 
(中文) 第 18 屆亞太地區軟體工程學術研討年會 
(英文) The 18th Asia-Pacific Conference on Software Engineering 
發表論文
題目 
(中文) 推薦適切的應用程式編程介面程式範例以協助軟體文件的產生 
(英文) Recommending Proper API Code Examples for Documentation Purpose 
 3 
以嘗試表示、分析、執行和改善其他領域所遇到之程序問題。在列出軟體程序語言能夠幫助
其他領域改善程序問題的佐證之後，Professor Osterweil 更期勉在座聽眾能夠以更宏觀的角度
看待軟體工程議題，並以軟體工程所提供之原則為本，幫助不同領域的人解決實際的軟體問
題。下圖為 Professor Osterweil 演講照片。 
  
2. 議程參與 
    本次年會之議程安排採取多議程並行制，在仔細規劃時間後，我參與了其中的五場議
程，分別為： 
A. 專案管理和軟體工程教育 (Project Management & Software Engineering Education) 
B. 軟體架構 (Software Architecture) 
C. 軟體測試 (Software Testing) 
D. 軟體維護以及演進 (Maintenance and Evolution)  
E. 程式分析 (Program Analysis)。 
在我參加的各場議程中，每場議程皆包含 3 至 4 組來自不同國家的研究人員，報告針對該
項議題，他們所發現的問題以及挑戰，並提出自身所發展之方法論 (Methodology)、進程 
(Approach) 或是技術 (Technique) 以解決這些問題以及挑戰。每一組人員的報告時間為 25 
分鐘。在每組的報告後，與會人員皆有十分熱烈且聚焦的討論，除了釐清研究的問題以及相
對應的解決方案外，亦有份量頗豐的討論著重於探討後續的可能改進發展和未來方向的展
望。下圖為各議程之參與照片。 
 5 
  
二、與會心得 
    參加此次會議所得甚豐，我將以「專題演講」、「議程參與」、「與會人士交流」以及「自身
口頭報告」四個部份分別講述參與心得。 
1. 專題演講 
    Professor Barry Boehm 所主講的專題演講對軟體工程領域給予一個宏觀的藍圖，讓我更
能夠以較為巨觀的角度了解自身研究的問題所處的情境，以及這個研究問題與其他議題的
連結關係。同時，演講的內容也讓我更能抓住軟體工程研究的未來發展軌跡，以期許自己
能在未來的軟體工程領域中，在實際且關鍵的議題上，有更多的實質貢獻。 
    Professor Leon J. Osterweil 所主講的專題演講則演示了軟體工程領域如何幫助其他領
域的人員解決軟體相關議題。這讓我意識到軟體工程的研究是更為基礎而影響巨大的，身
為軟體工程領域的研究人員，所需要考量解決的問題並不能侷限在某一個特定的框架之
中，而必須進一步思考要如何建立問題之間的連結對應，推廣自身的解決方案，進而在不
同的領域中產生實質效益。 
2. 議程參與 
    在參與的五個議程中，報告的議題皆屬軟體工程領域前沿的研究議題，在議程中我看
到許多實際的研究問題，以及相對應新方法論 (Methodology) 、進程 (Approach)、以及技
術 (Technology)，這對我在尋找研究題目的敏感度以及針對研究問題找出相對應解決方案
兩方面皆有莫大的助益。 
    議程進行時的會後討論，我皆嘗試積極發言參與討論，除希望能讓自身對報告者的內
容更加清楚聚焦之外，也希望能夠透過與其他參與人員進行腦力激盪，共同找出更深層的
問題核心，以及可能的未來解決方案。 
    除此之外，報告者的報告投影片以及口頭陳述內容多經過精心準備，身為聽眾的我在
聆聽的同時，也仔細觀察各個報告者的報告投影片、報告邏輯鋪陳、報告的英文口語發音
 7 
讓我受益良多，這也讓我更有信心能夠將目前的研究問題處理得更臻完善，並讓之後的研究
成果更加豐碩成熟。 
三、考察參觀活動(無是項活動者略) 
  本次會議我並無參加其他考察參觀活動。 
四、建議 
    非常感謝國科會能提供經費協助我參加此次會議，此行成果對我幫助甚大，除了讓我更切
身了解國際上軟體工程領域的前沿議題外，也就自己的研究問題得到許多的迴響。而與各國學
者的密切討論交流，也讓我對相同領域的學者們有的更實際的連結。因此，希望貴會能夠持續
提供機會補助研究生出國參與國際會議，甚至鼓勵研究生在早期的研究生涯即積極參與國際會
議，以讓研究生能及早拓展自己的視野，修正確立自己的研究方向，進而產出實際而不脫軌的
研究成果回饋社會。 
五、攜回資料名稱及內容 
第 18 屆亞太地區軟體工程學術研討年會所有議程資料，其中包含： 
1. 大會議程時間表 
2. Professor Barry Boehm 專題演講投影片 
3. Professor Leon J. Osterweil 專題演講投影片 
4. 會議論文集 CD 
六、其他 
  無 
author of an accepted paper is required to register for the conference at the full rate 
and the paper must be presented at the conference.  Non-refundable registration 
fees must be paid prior to uploading the final CPS formatted, publication-ready 
version of the paper. 
 
Information on registration, conference venue, accommodation, transportation, 
conference program, social program, tours, visa, etc will be found soon on the 
conference web site at http://www.apsec2011.org  
 
Please feel free to let us know (apsec2011@fit.hcmus.edu.vn) for any need on 
technical assistance regarding the preparation of your camera-ready copies and 
copyright release forms. 
 
Congratulations on this fine achievement!  We are looking forward to seeing you in 
Vietnam in December 2011. 
 
Sincerely, 
BACH Hung Khang and DUONG Anh Duc, Conference Chairs TRAN Dan Thu and Karl 
LEUNG, Program Committee Chairs The Eighteenth Asia-Pacific Software Engineering 
Conference (APSEC 2011) 
Email: apsec2011@fit.hcmus.edu.vn , URL: http://www.apsec2011.org 
 
 
----------------------- REVIEW 1 --------------------- 
PAPER: 53 
TITLE: Recommending Proper API Code Examples for Documentation Purpose 
AUTHORS: Lee Wei Mar, Ye-Chi Wu and Hewijin Christine Jiau 
 
OVERALL RATING: 2 (accept) 
Novelty: 4 (good) 
Technical Quality: 3 (fair) 
Clarity of Presentation: 3 (fair) 
Significance to / Impact  on Advancement of Software Engineering Knowledge: 3 
(fair) 
 
This paper presents a set of post-processing algorithms to make the results of the 
code search engine easier for the programmers to comprehend by clustering them 
and ranking them with some heuristics. Two case studies are presented to evaluate 
pros: 
- Recommending API code examples is a good approach for API users. 
- The procedure of the proposed technique seems reasonable. 
 
cons: 
- Several limitations of the technique. 
 
The authors should clarify the limitation of the proposed technique. I think the one 
of the important limitation is that the technique assumes some API usages can be 
obtained from CSEs. This means the technique cannot be applied to newly developed 
APIs that needs documentation. Other limitations I think are: 
- Signifiant efforts are required for selecting proper code examples recommended. 
- Usually, "Proper" API usages are widely known in the Web. So, the usefulness of the 
proposed method is unclear. 
 
 
I don't understand several terms used in pseudo codes of Algorithm 1 and 2. 
Please explain or define the follwing terms: 
- AnnotatedCalls() 
- ReturnType() 
- InvokingType() 
- ParameterTypes() 
 
 
----------------------- REVIEW 3 --------------------- 
PAPER: 53 
TITLE: Recommending Proper API Code Examples for Documentation Purpose 
AUTHORS: Lee Wei Mar, Ye-Chi Wu and Hewijin Christine Jiau 
 
OVERALL RATING: 2 (accept) 
Novelty: 3 (fair) 
Technical Quality: 4 (good) 
Clarity of Presentation: 3 (fair) 
Significance to / Impact  on Advancement of Software Engineering Knowledge: 3 
(fair) 
 
Summary 
  This paper presents an approach in extracting the different API usage 
Recommending Proper API Code Examples for Documentation Purpose
Lee Wei Mar∗, Ye-Chi Wu∗, Hewijin Christine Jiau†
∗Institute of Computer and Communication Engineering
†Department of Electrical Engineering
National Cheng Kung University, Taiwan
{lwmar, yechiwu}@nature.ee.ncku.edu.tw, jiauhjc@mail.ncku.edu.tw
Abstract—Code examples are important resources for ex-
pressing correct application programming interface (API) us-
ages. However, many framework and library APIs fail in
offering sufficient code examples in corresponding API docu-
mentations. This is because constructing proper code examples
for documentation purpose takes significant developers’ efforts.
To reduce such effort, this work proposes a methodology,
PropER-Doc, that recommends proper code examples for
documentation purpose. PropER-Doc accepts queries from
API developers and utilizes code search engines (CSEs) to
collect corresponding code example candidates. The structural
and conceptual links between API elements are captured
from the API implementation and available API documents
to guide candidate recommendation. During recommendation,
PropER-Doc groups collected candidates based on involved
API types for distinguishing different API usages. To assist
API developers in selecting proper candidates, a diagrammatic
presentation and three code example appropriateness metrics
are also developed in PropER-Doc. Two case studies on Eclipse
JDT framework are conducted to confirm the effectiveness of
PropER-Doc.
Keywords-framework; documentation; API usage; code ex-
ample;
I. INTRODUCTION
During object-oriented software applications develop-
ment, programming with existing Application Programming
Interfaces (APIs) becomes a common practice. As existing
object-oriented frameworks become more and more pow-
erful, the complexity of offered APIs increased accord-
ingly. Such complexity put barriers for correctly using of
APIs [1]. To guide programmers to use a framework API
correctly, API developers provide an API documentation
as the programming reference. The API documentation is
an important resource for programmers while learning and
using an API [14]. Therefore, making an API documentation
effective for guiding programmers using API correctly is a
critical job for API developers.
One feasible method for ensuring the effectiveness of API
documentation is to augment documentation with credible
code examples [13], [14]. With the credible code examples,
programmers can learn correct API usage by imitation [8],
[15]. In practice, some frameworks, such as SWT GUI
framework [19], do provide API documentation with rich
set of credible code examples. Nevertheless, most existing
APIs still fail to provide sufficient code examples in cor-
responding documentation [7]. To construct code examples
for documentation purpose, huge human effort is required
for confirming correct API usages and constructing corre-
sponding code examples from scratch. Therefore, there is an
urgent need to reduce API developers’ effort in such process.
To eliminate developers’ effort on constructing proper
code examples for documentation purpose, Kim et al. [7] de-
veloped a technique that automatically extracts code exam-
ples from API client code and adds them to API documents.
However, applying the technique, as a trade off of automa-
tion, developers are not involved in checking the extracted
code examples. Consequently, improper code examples may
be added to API documents and contradictorily downgrade
the correctness of API documents. Furthermore, this tech-
nique reports code examples that demonstrate the use of
single API method. While these reported code examples are
good references for fine-grained API call adaptation, they
do not explain the whole object interaction scenarios for
assisting programmers in learning typical API usages.
In this work, a methodology named PropER-Doc (Proper
Example Recommendation for Documentation), is proposed.
Considering that an API type is a basic manipulation unit
during using API, PropER-Doc aims to recommend code
examples that demonstrate whole object interaction scenario
during using a specific API type. Given an API type,
PropER-Doc collects code example candidates from code
search engines (CSEs) [10], [2] and recommends candi-
dates that meet correct API type usages to developers. To
guarantee the effectiveness of the recommendation, PropER-
Doc constructs structural and conceptual links based on the
API implementation and available API documents. These
links capture implicit API element usage dependencies and
are served as recommendation bases in PropER-Doc. In
addition, to incorporate with developers in navigating and
selecting candidates, three recommendation assistants are
offered in PropER-Doc:
1) a candidate grouping algorithm that groups candidates
for distinguishing different API usages;
2) a diagrammatic presentation technique that summa-
rizes object interaction of a specific API type usage;
3) three code example appropriateness metrics for assess-
ing the quality of a specific candidate.
Figure 2. Process overview of PropER-Doc.
Table I
DIFFERENT KINDS OF LINKS BETWEEN API ELEMENTS. THE NOTATION
T, I, E REPRESENTS API TYPE, API INVOCATION UNIT (METHOD AND
FIELD), AND API ELEMENT, RESPECTIVELY. E = {T, I}.
Link Type Description
def(t, i) T × I t defines i as a method or field
ext(t1, t2) T × T t1 is a descendent of t2
use(i, t) I × T signature of i refers to t
con(e1, e2) E × E document content of e1 refers to e2
type that needs code examples (referred as targetType) as
a query. Then, the code example candidates of targetType
are collected from CSEs. These candidates are annotated
based on API element links constructed in advance. Finally,
candidates of different API usages are recommended to the
API developer.
A. Constructed Links between API Elements
The links between API elements are constructed to indi-
cate API elements expected to be used together from API
developers’ viewpoint. A link between two API elements
is defined as a tuple (x, y), where x and y are structurally
or conceptually relevant API elements. Table I lists four
different kinds of links between two API elements.
In Table I, the top three kinds of links are the structural
links. Structural links are API element structural relations
maintained in the API implementation, such as type hier-
archy and containment relationship. The last one kind of
link is the conceptual link. Conceptual links are constructed
based on the descriptive content of available API documents.
If the document description of an API element x refers to
another API element y, then a conceptual link from x to y is
created. These conceptual links capture structurally hidden
but important relations between API elements.
B. Candidate Collection and Annotation
PropER-Doc delegates the code search responsibility to
CSEs for collecting potential source files with code exam-
ples. For a long lived API with rich set of client code on web,
web-based CSEs such as Google code search and Koder4 can
4http://www.koders.com/
Table II
SIGNIFICANT LEVELS FOR ANNOTATING API CALLS IN A CANDIDATE C.
Lv. Formulation
6 {call | ∀ call ∈ C, def(targetType, call)}
5 {call | ∀ call ∈ C, con(targetType, t) ∧ def(t, call)}
4 {call | ∀ call ∈ C, use(call, targetType)}
3 {call | ∀ call ∈ C, def(targetType, i) ∧
(con(i, call) ∨ (con(i, t) ∧ def(t, call)))}
2 {call | ∀ call ∈ C,
AccessingType(call) = targetType ∧
ext(targetType, t) ∧ def(t, call)}
1 {call | ∀ call ∈ C,
targetType ∈ ParameterTypes(call) ∧
ext(targetType, t) ∧ use(t, call) }
be directly utilized for code search. On the contrary, if the
API is used within private organizations or it is in the early
stage of promotion, API developers can construct a dedicated
CSE with the available code search infrastructure [10] for
efficient client code collection, management and search.
Once a targetType is accepted as a query, it is delegated to
a CSE (or several CSEs). The CSE searches in the available
open source software on the web and return relevant source
files. PropER-Doc parses each source file and checks the
invoked API calls inside. For each method implementation
of a source file, if it invokes API calls defined within
targetType, then that method implementation is extracted as
a code example candidate.
After collecting candidates from the CSE, important API
calls for demonstrating targetType within each candidate are
captured and annotated based on API element links. At first,
all API calls in a candidate are extracted. For each API
call, its relevance to targetType will be evaluated. If the API
call is considered relevant to targetType, it is annotated with
a level as an indicator of its importance on demonstrating
targetType usage. The higher the level, the more important
the API call.
Table II lists the formulations for different levels. An API
call defined in targetType is considered as most important
one and is annotated with level 6. If an API call is defined
in an API type t which is referred by document content of
targetType, it is annotated with level 5. Such API call gains
higher level because t is important and intended to be used
together with targetType. If the signature of an API call takes
targetType as parameter type or return type, it is annotated
with level 4 because of the structural dependency. For an
API call referred by document content of API elements, it
is annotated with level 3. An inherited API call invoked on
an object of targetType is annotated with level 2. Finally, an
API call is annotated with level 1 while it takes an object
of targetType as parameter by upcasting.
C. Candidate Recommendation
According to annotated API calls in candidates, the code
example candidates are reorganized and presented to the de-
Figure 3. Code example candidates recommendation. (a) grouping result
based on interacted API types, (b) API type interaction diagram of group
1, (c) selected candidates with appropriateness metrics ranking, (d) code
presentation for a given candidate.
If the developer chooses those frequently used API calls in
Figure 3 (b), corresponding candidates that invokes all those
API calls would be listed (Figure 3 (c)).
3) Ranking based on Appropriateness Metrics: PropER-
Doc performs ranking during presenting the candidate list to
assist developer in picking candidates. Three appropriateness
metrics: significance, density, and cohesiveness, are defined
to evaluate the quality of a candidate for ranking. The formu-
lation of appropriateness metrics is based on the annotated
API calls in candidates. The range of these metrics are
between 0 to 1. All the metrics are positive correlated with
the quality of a candidate. The higher the metric value, the
more appropriate the candidate for documentation purpose.
• Significance. The significance metric evaluates the im-
portance of all referred API calls in a candidate with
respected to correct targetType usages. A candidate
with higher significance is tended to be more repre-
sentative for demonstrating a specific targetType usage.
The significance metric for a candidate C is formulated
using annotated levels of referred API calls.
significance(C) =
∑
call∈C Level(call)
6× CallNum(C)
• Density. The density metric evaluates the portion of
code lines that refers annotated API calls in a candidate.
A candidate with higher density is tended to be more
comprehensible. This is because the effort required in
filtering out noisy information during code inspection
can be reduced.
density(C) =
AnnotatedLineNum(C)
LineNum(C)
,
• Cohesiveness. The cohesiveness metric models aggre-
gation level of annotated API calls within a candidate.
For a candidate with higher cohesiveness, the developer
can extract code example from it with less effort. In
computing cohesiveness metric of a candidate C, the
API dense blocks are identified from C. An API dense
block is a code block in C and every code line in that
block contains annotated API calls. A block weight
function is defined to evaluate the aggregation degree
of annotated API calls in a block. The weight of a block
is proportional to the line number of the block and the
number of annotated API calls inside it.
Weight(b) = LineNum(b)× AnnotatedCallNum(b)
By considering the distribution of API dense blocks, the
cohesiveness metric of C is defined as the ratio between
total weight of relevant blocks and weight of a compact
block, B, that contains all annotated API calls in C.
Cohesiveness(C) =
∑
b∈APIDenseBlocks(C) Weight(b)
Weight(B)
The candidate list is ranked according to the summation
of appropriated metrics, as shown in Figure 3 (c). The
developer can select one specific candidate in Figure 3
(c) to check its source code. In source code presentation
(Figure 3 (d)), the code lines with annotated API calls
in the candidate are highlighted for assisting inspection.
The developer can identify relevant code, perform minor
modifications, and then extract needed code block from the
candidate for documentation.
D. Implementation
PropER-Doc has been realized using Java language. Cur-
rently, PropER-Doc implementation supports the recommen-
dation of code examples for a framework API implemented
in Java. Google code search is used as the default CSE for
performing the code search. Besides Google code search,
PropER-Doc implementation can be configured to work
together with additional CSEs when needed.
During constructing structural API element links, the Java
Table IV
MAPPING BETWEEN CORRECT API USAGES AND GROUPING RESULT:
SEARCHENGINE CASE.
GID Num. Mapped API Usage Effort
∆Stmt(+/−) Coh.
1 5 mechanismenclose 0 / 0 1.00
2 5
mechanismtype
0 / 1 1.00
3 1 0 / 1 1.00
4 1 4 / 0 1.00
5 1 10 / 0 1.00
6 45
mechanismgeneral
0 / 1 1.00
7 19 0 / 0 1.00
8 2 0 / 2 1.00
9 30
– (Non-representative API usage)
– –
10 5 – –
didates (group 2(c), 6, and 8) covers needed API calls for
corresponding usages, and all of them have high cohesive-
ness value (from 0.63 to 1.00). This indicates that the needed
API calls within these three candidates are tightly aggregated
and can be easily extracted as code examples. For the top
ranked candidate in group 3, only one API call is missed, and
the effort for modification is relatively minor. In summary,
ranking candidates according to appropriated metrics greatly
assists developers in choosing proper candidates.
B. SearchEngine Case
The SearchEngine class in JDT provides support
to search Java program elements in specific scope that
matches given specification. SearchEngine offers one gen-
eral search mechanism and two different handy search
mechanisms. In performing a general search mechanism
(mechanismgeneral), SearchEngine requires a search pattern,
a list of search participant, a search scope, and a requestor
object. The first handy search mechanism (mechanismenclose)
performs search for Java program elements enclosed in spec-
ified Java program element. The second handy mechanism
(mechanismtype) performs search for Java types that match
the given string in the given search scope. Different code
examples are required to demonstrate the use of different
search mechanisms.
PropER-Doc returns 114 candidates from top 100 source
files and splits them into ten groups. By inspecting API
type-based diagram of each group, the mapping between
groups and different SearchEngine search mechanisms is
summarized in Table IV. There are eight valid groups that
correctly demonstrate SearchEngine usages. Candidates in
group 1 demonstrate mechanismenclose. Candidates from group
2 to 5 demonstrate mechanismtype with different requestor
objects and search scopes. Candidates from group 6 to 8
demonstrate mechanismgeneral with different search scopes.
In Table IV, mechanismtype and mechanismgeneral are mapped
to multiple groups. Such many to one mapping indicates
that these two search mechanisms may involves different
combination of interacted API types. This reminds devel-
opers that SearchEngine offers highly flexible API calls
in performing these two search mechanisms. Therefore,
more than one representative code examples are needed
for demonstrating the flexibility of these mechanisms. The
multiple groups mapped to these mechanisms can assist de-
velopers in selecting various representative code examples.
In SearchEngine case, the effort needed for transform-
ing top ranked candidates to representative code examples
is also checked. The result is summarized in Effort col-
umn of Table IV. In these eight valid groups, the top
ranked candidates of two groups perfectly match the correct
SearchEngine API usages. The top ranked candidates of
group 4 and 5 covered all needed API calls, and these API
calls are tightly aggregated (cohesiveness value = 1.00) and
can be easily extracted. The top ranked candidates of group
2, 3, 6 and 8 misses one to two needed API calls. For group 2
and 6, the missed API call can be complemented by checking
other candidates of the same groups. For group 3 and 8,
which have merely one or two candidates inside, developers
can refer to similar groups that mapped to the same usage
for picking up the missed API calls.
The study results confirm that PropER-Doc is effective
for assisting developers in identifying different API us-
ages. Also, PropER-Doc greatly help developers pick good
candidates that can be transformed to representative code
examples with less modification effort.
V. RELATED WORK
Kim et al. [6], [7] proposed a technique that automatically
augments API documents with code examples. In their work,
code examples are selected to demonstrate the use of single
API method. The technique performs clustering and ranking
based on referred API calls in candidates to select represen-
tative code examples. Since their work focuses on finding
code examples for each API method, the code example
appropriateness with respect to the correct API type usage
is not taken into account in their work.
Several recommendation systems have been developed
to suggest relevant code examples for supporting API pro-
gramming tasks. Strathcona [5] recommends code examples
relevant to the programming context where a programmer
involves. Prospector [11] and XSnippet [16] accept an API
type query pair (Tin, Tout) from a programmer, and suggest
code examples that illustrate the uses of Tin object to obtain
Tout object. PARSEWeb [20] also recommends code ex-
amples for API object instantiation using web-based CSEs.
MAPO [22] applies data mining techniques on API client
code for finding frequent API call sequences as API usage
patterns. When programmers ask for the usage of a specific
API call, MAPO would present relevant API usage patterns
along with code examples as guidance. All the aforemen-
tioned systems focus on recommending code examples that
directly match programmers needs. Alternatively, PropER-
Doc aims to assist developers in selecting code examples for
documentation purpose. Rather than directly recommending
code examples, PropER-Doc mainly concerns the cooper-
ation with developers for effective organization, navigation
國科會補助計畫衍生研發成果推廣資料表
日期:2012/03/29
國科會補助計畫
計畫名稱: 應用服務整合與篩選運算架構於醫療看護運作體系
計畫主持人: 焦惠津
計畫編號: 97-2221-E-006-177-MY3 學門領域: 圖形辨識
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
