 1
 
一、中英文摘要 
中文摘要 
 基於個人隱私的保護，在 2005 年學者 Nguyen 首先提出非對稱式的同時簽章法，也是
第一個非採用環簽章設計的同步簽章法。除了正確性、不可偽造性和公平性之外，Nguyen
的方法也滿足匿名性與不可鍊結性。為了滿足匿名性，Nguyen 的同時簽章法具有身分識別
的缺失，也就是交換簽章的簽章者無法識別彼此的身分，會使攻擊者可以利用此一缺失，
藉由愚弄簽章者而耗盡簽章者的計算資源。然而具有簽章者模糊性的同時簽章法就不會有
此一缺失。因此為了匿名的同時簽章法，定義一個新的身分識別的特性。在此一計畫中，
提出一個改良的非對稱式的同時簽章法，可以同時滿足身分識別與匿名的特性；此外也滿
足不可鍊結性。身分識別性、匿名性與不可鍊結性，就可以保護同時簽章法的簽章者隱私。 
關鍵字: 同時簽章、匿名性、身分識別、隱私、數位簽章法 
英文摘要 
For the privacy protection, Nguyen first proposed an asymmetric concurrent signature 
scheme without adopting ring signatures in 2005.  Except correctness, unforgeability, and 
fairness, Nguyen’s scheme satisfies two new properties: Anonymity and unlinkability.  To 
satisfy the anonymity property, Nguyen’s scheme has identification flaw that signers cannot 
identify each other during the exchange protocol.  So an attacker makes use of this flaw to trick 
signers to exhaust signers’ computation resources.  However, the concurrent signature schemes 
with signer-ambiguity do not have the identification flaw.  A new property, identification, is 
defined for the concurrent signature scheme with anonymity.  In this project, an improved 
asymmetric concurrent scheme is proposed to provide both anonymity and identification.  Our 
improved scheme satisfies identification, anonymity, and unlinkability at the same time.  With 
identification, anonymity, and unlinkability, the signers’ privacy is protected well without flaws. 
 
關鍵字: Concurrent signatures, anonymity, identification, privacy, signature schemes 
 
二、前言與研究目的 
In 2004, Chen et al. first proposed the concurrent signature scheme by adopting the idea of 
ring signatures [2, 19].  The ring signature scheme is a signature scheme hiding the actual signer 
among all ring members.  When the number of ring members is reduced to two, the ring 
signature scheme has the singer-ambiguity.  For example, A signs a ring signature which only 
contains A and B’s identities.  After validating A’s ring signature, B is sure that the ring signature 
is generated by A because B doesn’t sign it.  Because there are two identities involved in this 
ring signature, B can’t convince the third party that this ring signature is generated by A.  Susilo 
et al. [21] point out that Chen et al.’s scheme adopts the same keystone fix to generate both 
commitments.  To cluster two ambiguous signatures with same keystone fix, the 
signer-ambiguity is removed.  To overcome this flaw, Susilo et al. adopt different keystone fix to 
generate the commitments to propose their scheme, the perfect concurrent signature scheme in 
2004 [21].  Wang et al.’s [22] points out that Susilo et al.’s scheme does not satisfy the fairness 
property in 2006.  Therefore, Wang et al. proposed two iperfect concurrent signature schemes 
satisfying the fairness property.   Wang et al.’s scheme also improve the performance.  Wang et 
al.’s scheme satisfies four security properties: correctness, unforgeability, fairness and 
signer-ambiguity. 
Nguyen [17] first proposed asymmetric concurrent signature schemes to provide privacy 
 3
b.  Then the signer converts the promise of Schnorr signature (e, β) to a Schnorr signature (e, b) 
to show that (e, b) is a generated by the signer. 
The following shows why anyone can use the public key y to forge promises of Schnorr 
signatures.  On a message m', anyone randomly selects a secret integer k′ from Zq*, and 
computes e′= h(m′||(yk′ mod p)) and β= yk′+e′ mod p.  Then e′= h(m′||(β y-e′ mod p)) holds.  So 
the pair (e′, β) is a forged promise of Schnorr signature on m′ for the public key y. 
The Schnorr-like signature scheme proposed by Nguyen [17] is described below.   
System Construction: This algorithm selects two large primes p and q such that q|(p – 1).  Let 
g be a generator of the multiplicative subgroup of order q in Zp*.  This algorithm also selects a 
cryptographic hash functions h: {0, 1}* → Zq*.  Each participant’s private key x is chosen 
randomly from Zq*.  The corresponding public key is y= gx mod p.   
Signature Generation: The algorithm selects a random secret integer k from Zq*, and computes 
e= h(m||(gk mod p)) and b= (k- e)x-1 mod q.  The algorithm outputs a Schnorr-like signature (e, b) 
on the message m using the private key x for the public key y. 
Signature Verification: On input the tuple <e, b, y, m>, this algorithm returns an accepting result 
if the equation e= h(m||(geyb mod p)) holds; otherwise, it returns a rejecting result. 
If (e, b) is a Schnorr-like signature on the message m for the public key y, then the tuple (e, b1, 
β) is its promise, where β= yb-b1= yb2 mod p and b= b1+b2 mod q.  If e= h(m||(geyb1β mod p)) 
holds, then the promise of Schnorr-like signature (e, β) is valid on the message m for the public 
key y.  To convert the promise of Schnorr-like signature to a Schnorr-like signature, the signer 
reveals the value b2.  Hence (e, b1+b2 mod q) is indeed a legal Schnorr-like signature that 
generated by the owner of the public key y. 
Using the public key y, everyone can solely generate a valid promise of Schnorr-like 
signature at will.  On the message m′ from {0, 1}*, anyone randomly selects two integers k′ and 
b1′ from Zq*, and computes e′= h(m′||(gk′yb1′ mod p)) and β= gk′-e′ mod p.  Then the equation e′= 
h(m′||(ge′yb1′β mod p)) holds.  That is the tuple (e′, b1′, β) is a forged promise of Schnorr-like 
signature on message m′ without using the private key x. 
Asymmetric Concurrent Signature Scheme 
Nguyen’s concrete asymmetric concurrent signature scheme is described below. 
SETUP: For some security parameter l as input, this algorithm selects two large primes p and q 
such that q|(p – 1).  Let g be a generator of the multiplicative subgroup of order q in Zp*.  This 
algorithm also selects a cryptographic hash function h: {0, 1}*→ Zq*.  The function Hash is 
defined to be the hash function h.  The other functions is defined by KGEN(t)= gt mod p, 
KGENyi(t)= yit mod p, and KTRAN(t, xi)= txi mod p.  Each participant’s private key xi, 1≤ i≤ n is 
chosen randomly from Zq*.  The corresponding public key is yi= gxi mod p.  The public 
parameters are <p, q, g> along with the descriptions of the spaces F, K, and M, where F= Zp*, K= 
Zq* and M= {0, 1}*.   
ISIGN: On input the tuple <yi, xi, mi>, this algorithm chooses a random value ri∈Zq* and 
computes three values as follows: ei= h(mi||(gri mod p)), ki= xiei+ ri mod q, and si= gki mod p, 
where yi is a public key, xi is the private key corresponding to yi, and the message mi∈ M.  The 
algorithm outputs a promise of Schnorr signature σi= <ei, si> on mi, and a keystone ki, where ei, 
ki∈ K, and si∈ F. 
MSIGN: On input the tuple <yj, xj, sj, mj>, this algorithm chooses a random value rj∈ Zq* and 
computes two values as follows: ej= h(mj||(grjsj mod p)), and kj= (rj- ej)xj-1 mod q, where yj is a 
public key, xj is the private key corresponding to yj, and the message mj∈M.  The algorithm 
outputs a promise of Schnorr-like signature σj= <ej, kj, sj> on mj, where ej, kj∈ K, and sj∈ F. 
IVERIFY: On the input <σi, yi, mi>, this algorithm returns an accepting result if the equation ei= 
h(mi||(siyi-ei mod p)) holds; otherwise, it returns a rejecting result.  Here σi= <ei, si>, ei∈ K, si∈ F, 
a public key yi, and the message mi∈ M. 
 5
the Diffie-Hellman key space D, a function Hash: M→ K and a function KGEN: K→ F.  The 
algorithm also outputs the private-public key pairs {xi, yi} for all participants, the function 
families KGENyi: K→ F, KGENyi,yj: K→ D, a keystone transformation function KTRAN: F × 
{xi}→ F, and a public reducing function Reduce: F→ K. 
ISIGN: A probabilistic algorithm outputs a commitment ci= <ei, si> and a keystone ki on the 
input <yi, xi, b1, mi>, where yi is a public key, xi is the private key corresponding to yi, b1, ei, ki∈ K, 
si∈ F, the message mi∈ M, and si= KGEN(ki - b1). 
MSIGN: A probabilistic algorithm outputs a promise of Schnorr-like signature σj= <ej, kj, sj> on 
the input <yj, xj, sj, mj>, where yj is a public key, xj is the private key corresponding to yj, ej, kj∈ K, 
sj∈ F, and the message mj∈ M. 
IVERIFY: An algorithm takes Si= <σi, yi, mi> as its input and outputs an accepting or a rejecting 
result, where σi= <ei, siKGEN(b1)>, b1, ei∈ K, si∈ F, yi is a public keys, and the message mi∈ M. 
MVERIFY: An algorithm takes Sj= <σj, yj, mj> as its input and outputs an accepting or a 
rejecting result, where σj= <ej, kj, sj>, ej, kj∈ K, sj∈ F, yj is a public keys, and the message mj∈ M. 
VERIFY: An algorithm takes <ki, Si> (or <ki, Sj>) as its input, where ki ∈ K is a keystone and Si= 
<σi, yi, mi>, (or Sj= <σj, yj, mj>), σi= <ei, siKGEN(b1)>, (or σj= <ej, kj, sj>), b1, ei∈ K, si∈ F, mi∈ 
M (or ej, kj∈ K, sj∈ F, mj∈ M), and yi (or yj) is a public key.  This algorithm first checks whether 
or not KGEN(ki)= siKGEN(b1) (or KGENyj(ki)= sj).  If the equation does not hold, then the 
algorithm outputs a rejecting result.  Otherwise, it produces its output by using the algorithm 
IVERIFY(Si) (or MVERIFY(Sj)).  If the algorithm VERIFY returns an accepting result, then <ki, 
ei> forms a valid signature on mi for yi or <ki+kj, ej> forms a valid signature on mj for yj. 
The output ci= <ei, si> of ISIGN is called a commitment while a tuple σi= <ei, siKGEN(b1)> 
is called a promise of a Schnorr signature.  If IVERIFY(σi, yi, mi) returns an accepting result, 
then σi is a valid promise of Schnorr signature on mi for yi.  The output σj= <ej, kj, sj> of MSIGN 
is called a promise of Schnorr-like signature.  If MVERIFY(σj, yj, mj) returns an accepting result, 
then σj is a valid promise of Schnorr-like signature on mj for yj.  A promise of Schnorr (or 
Schnorr-like) signature σi (or σj) on the message mi (or mj) for yi (or yj) together with a keystone 
ki is called a concurrent signature.  Therefore if VERIFY(ki, Si= <σi, yi, mi>) (or VERIFY(ki, Sj= 
<σj, yj, mj>)) returns an accepting result, then the tuple <ki, σi> (or the tuple <ki , σj>) is a valid 
concurrent signature on the message mi (or the message mj) using the public key yi (or yj).  That 
is <ki, ei> (or <ki+kj, ej>) is a valid concurrent signature on the message mi (or mj) using the 
public key yi (or yj). 
The commitment has the signer-anonymity property that any third part only guesses the 
identity of the real signer among n possible signers with probability 1/n.  Because the promise of 
Schnorr signature has the signer-anonymity property, after exposing b1, the commitment still 
possesses the signer-anonymity property.  After releasing the keystone, the promise signatures 
do not possess the signer-anonymity property anymore.  So anyone utilizes keystones to bind 
these promise of signatures to their actual signer, and uses the algorithm VERIFY to validate 
concurrent signatures. 
Generic Protocol for Our Asymmetric Concurrent Signature Scheme 
Suppose that the initial signer A and the matching signer B run SETUP first to set the public 
parameters and generate their private-public key pairs.  Assume that A’s key pair is <xA, yA> and 
B’s key pair is <xB, yB>.  Our asymmetric concurrent signature protocol works as follows: 
Step 1: A sends her identity IDA to B over secure channels. 
Step 2: B randomly chooses a value t ∈ K and computes KGENyA,yB(t) and r= KGENyB(t), 
where r∈ D.  B generates b1= Reduce(KGENyA,yB(t)).  Then A sends r to B. 
 7
σi= <ei, siKGEN(b1)>, ei, b1∈ K, si∈ F, a public key yi, and the message mi∈ M. 
MVERIFY: On the input <σj, yj, mj>, this algorithm returns an accepting result if the equation 
ej= h(mj||(gejyjkjsj mod p)) holds; otherwise, it returns a rejecting result.  Here σj= <ej, kj, sj>, ej, 
kj∈ K, sj∈ F, a public key yj, and the message mj∈ M. 
VERIFY: On input the tuple <ki, Si> (or <ki, Sj>), this algorithm first checks whether or not 
KGEN(ki)= siKGEN(b1) (or KGENyj(ki)= sj), where ki∈ K, Si= <σi, yi, mi>, σi= <ei, siKGEN(b1)> 
(or σj= <ej, kj, sj>), ei, b1∈ K, si∈ F (or ej, kj∈ K, sj∈ F), yi (or yj) is a public key, and the message 
mi (or mj)∈ M.  If KGEN(ki)≠ siKGEN(b1) (or KGENyj(ki)≠ sj), it outputs a rejecting result; 
otherwise, it produces its output by using the algorithm IVERIFY(Si) (or MVERIFY(Sj)). 
These algorithms together with our proposed protocol described in Section 4.2 can realize the 
concrete asymmetric concurrent signature scheme.  After revealing the keystone ki, the property 
of the signer-anonymity would be broken by checking that the equation of KGEN(ki)= siKGEN(b1) 
or KGENyj(ki)= sj.  That is, the asymmetric concurrent signature can be verified by the algorithm 
VERIFY. 
Performance Analysis and Discussions 
In Nguyens’s scheme, an attacker pays 2TE to forge a valid promise of Schnorr signature to 
the matching signer, where TE denotes the computational cost for one modular exponentation.  
Because Nguyen’s scheme does not have the identification property, the matching signer totally 
pays 3TE to confirm the promise of Schnorr signature is valid and produces the corresponding 
promise of Schnorr-like signature to initial signer.  Hence Nguyen’s protocol is vulnerable 
against the denial-of-service attack.  
Table 1 gives the security comparison between Nguyen’s scheme and our improved scheme.  
It is easily to find that our scheme satisfies identification property.  The identification property 
can be used to guard against the denial-of-service attack for the matching signer’s computational 
resource.  Therefore, our scheme removes the identification flaw in Nguyen’s scheme.  Our 
scheme satisfies both anonymity and identification at the same time.  By using the anonymity, 
unlinkability, and identification, our scheme provides a practical privacy protection for the initial 
and matching signer. 
Table 1: Security Property Comparison between Nguyen’s Scheme and Our Improvement 
           Schemes 
Properties 
Nguyen’s Scheme Our Improvement 
Correctness √ √ 
Unforgeability √ √ 
Fairness √ √ 
Signer-ambiguity × × 
Anonymity √ √ 
Unlinkability √ √ 
Identification × √ 
Table 2 gives the performance comparison between Nguyen’s scheme and our improved 
scheme.  Both Nguyen’s scheme and our improvement need multi-exponentiation.  The 
multi-exponentiation computational costs for a1x1a2x2 and a1x1a2x2a3x3 are about 1.16 TE and 1.25TE, 
respectively [4].  The computational loads of the initial signer A and matching signer B are both 
4.16TE and 3TE in Nguyen’s scheme.  In our scheme, the computational loads of the initial 
signer A and matching signer B are 5.16TE and 5.32TE, respectively.  Our computation loads is a 
little larger than the loads of Nguyen’s scheme by 1or 2.32 exponentiations.  By paying a little 
 9
1997, pp.1-5.  
[13] M. K. Franlin and G. Tsudik, “Secure group barter: Multi-party fair exchange with 
semi-trusted neutral parties,” Proc. of Financial Cryptology - EUROCRYPT 1998, LNCS, 
Vol. 1465, New York: Springer-Verlag, 1998, pp.90-102. 
[14] J.A. Garay, M. Jakobsson, and P. MacKenzie, “Abuse-free optimistic contract signing,” 
Advances in Cryptology - CRYPTO 1999, LNCS, Vol. 1666, New York: Springer-Verlag, 
1999, pp.449-466. 
[15] O. Goldreich, “Sending certified mail using oblivious transfer and a threshold scheme,” 
Technical Report, Computer Science Department, Israel Institute of Technology, 1984. 
[16]  O. Goldreich, “A simple protocol for signing contracts,” Advances in Cryptology-CRYPTO 
1983, New York: Springer-Verlag, 1984, pp.133-136. 
[17] K. Nguyen, “Asymmetric concurrent signatures,” Proc. of Information and 
Communications Security Conference, ICICS 2004, LNCS, Vol. 3783, New York: 
Springer-Verlag, 2005, pp. 181-193. 
[18] B. Pfitzmann, M. Schunter, and M. Waidner, “Optimal efficiency of optimistic contract 
signing,” Proc. of the 7th Annual ACM Symposium on Principles of Distributed Computing, 
New York, U.S.A., 1998, pp.113-122. 
[19] R. L. Rivest, A. Shamir, and Y. Tauman. “How to leak a secret,” Asiacrypt’ 01, LNCS, Vol. 
2248, New York: Springer-Verlag, 2001, pp.552-565. 
[20] C. P. Schnorr, “Efficient Identification and Signatures for Smart Cards,” Advances in 
Cryptology-CRYPTO 1989, LNCS, Vol. 435, New York: Springer-Verlag,1990, pp.239-252. 
[21] W. Susilo, Y. Mu, and F. Zhang, “Perfect concurrent signature schemes,” Proc. of 
Information and Communications Security Conference, ICICS 2004, LNCS Vol. 3269, New 
York: Springer-Verlag, 2004, pp. 14-26. 
[22] G. Wang, F. Bao, and J. Zhou, “The Fairness of Perfect Concurrent Signatures,” The 8th 
International Conference on Information and Communications Security (ICICS 2006), 
LNCS, Vol. 4307, New York: Springer-Verlag, 2006, pp. 435-451. 
 
七、計畫成果自評 
In this project, our improved scheme is proposed to provide anonymity and identification at 
the same time.  Due to Table 1, our improved scheme satisfies not only the three basic security 
properties but also anonymity, unlinkability and identification.  Since our improved scheme 
satisfies anonymity and unlinkability, the privacy is protected well in the improved scheme.  
Even though our improved scheme satisfies anonymity, our scheme also satisfies the 
identification property to guard against denial of service attack on computational resource.  Our 
improved scheme is better than Nguyen’s scheme.  Since our improved schemes satisfy the 
identification property, our schemes are more practical in the real world.  The project goal is 
completed. 
RDT08 
  
出席國際學術會議發表之論文 
A practical anonymous proxy signature scheme with 
trusted alias issuing authority 
Hwang, Shin-Jia and Hsu, Pi-Hung* 
Department of Computer Science and Information Engineering,TamKang University, 
Tamsui, Taipei Hsien, 251, Taiwan, R.O.C. 
sjhwang@mail.tku.edu.tw, 795410132@s95.tku.edu.tw 
 
Abstract.  Proxy signature schemes with anonymous proxy signers are called anonymous proxy signature 
schemes.  Anonymous proxy signature schemes are used to protect proxy signers’ privacy.  Among the 
proposed anonymous proxy signature schemes, Sum and Wei’s scheme is more practical than the other 
proposed scheme.  However, their scheme does not satisfy strong unforgeability.  To overcome this 
drawback, a new practical anonymous proxy signature scheme is proposed with the help of trusted alias 
issuing authority.  Our scheme is the first one adopting the concurrent signature scheme to deal with the 
signature exchange between trusted alias issuing authority and anonymous proxy signers.  In the new 
scheme, the anonymous names of proxy signers keep secret before use to protect proxy signers’ privacy 
and right.  Right after the anonymous name being used, the anonymous proxy signers cannot deny their 
generation of proxy signatures to protect the original singers’ right. 
Key words: Anonymity, proxy protection, proxy signatures, concurrent signatures 
1 Introduction 
Mambo et al. [9, 10] first proposed the concept of proxy signature schemes in 1996.  In a proxy signature scheme, an 
original signer (denoted by UO) is able to authorize a proxy signer (denoted by UP) to generate proxy signatures on 
behalf of the original signer UO.  Mambo et al. [9, 10] proposed three authorization types: Full delegation, partial 
delegation, and delegation by warrant.  Based on these three types of authorization, many proxy signature schemes 
are proposed [2-4, 6, 7]. 
Some of these proposed proxy signature schemes provide proxy protection.  The proxy signer protection is 
obtained by using proxy signers’ public key to help the verification of proxy signatures.  Due to the use of proxy 
signers’ public keys, the identity of a proxy signer should be known.  However this damages the proxy signers’ 
privacy.  To protect proxy signers’ privacy, it is better that proxy signers are anonymous in proxy signature schemes.  
To deal with anonymity issues, two proxy schemes are proposed.  One is Mehta and Harn’s one-time proxy signature 
scheme [11] and another is Shum and Wei’s strong proxy signature scheme [12]. 
Mehta and Harn’s [11] scheme is proposed based on online/offline signature schemes in the delegation by warrant.  
Their scheme has anonymity property for proxy signers because, in their scheme, proxy signatures are validated only 
by a using UO’s public key.  Then only the original signer UO and proxy signer UP know the actual signer of proxy 
signatures.  When any dispute caused by proxy signatures happens, it is necessary to find out the actual signer of 
proxy signatures.  In Mehta and Harn’s scheme, both UO and UP have the evidence to identify the actual proxy 
signers with the help of a trust authority.  The proxy signatures in [11] are perfectly secure.  However, for each 
delegation by warrant, each proxy signer can generate only one proxy signature.  So their scheme is impractical in 
the real word. 
On the other hand, Shum and Wei’s scheme [12] is practical with the help of trusted alias issuing authorities.  
The trusted alias issuing authority issues certificates for the anonymous name and anonymous public key of each 
proxy signer.  Then the certificated anonymous public key is used to generate anonymous proxy private and public 
key with the original signer’s authorization.  Then proxy signatures are generated by the anonymous proxy private 
key, so any third party cannot know the proxy signer’s identity.  However, Lee et al. [8] showed that Shum and 
Wei’s [12] scheme doesn’t satisfy the strong unforgeability property. 
An anonymous scheme has to satisfy security properties given below.  Some of these properties have been 
previously listed by Mambo et al. [9, 10] and Shum and Wei [12] for their schemes, respectively. 
1. Unforgeability: Only the proxy signer with proxy authorization can generate valid proxy signatures.  Proxy 
signatures cannot be forged by any unauthorized users, except the original signer. 
2. Verifiability: Anyone can validate whether or not proxy signatures generated by the authorized proxy signers 
are correct. 
3. Proxy signer’s deviation: The proxy signer cannot forge the original signer’s signatures or obtain original 
signers’ private keys. 
4. Distinguishability: Anyone is able to distinguish proxy signatures, original signers’ signatures, and proxy 
signers’ signatures in polynomial time. 
5. Identifiability: Original signer can to identify the generator of proxy signatures. 
6. Proxy protection: Due to the anonymity, an original signer can authorize himself/herself as the proxy signer 
RDT08 
  
signature (k, ci) satisfies the equation ci = H(gkyi-ci mod p, mi). 
(2) On input the promise of Schnorr-like signature ωj= (sj, k1, cj), mj, and keystone k and the algorithm output 
accept if KGENj(k)= sj and (k+k1, cj) forms a valid Schnorr-like signature on message mi by using public 
key yj.  That is (k+k1, ci) satisfies the equation cj= H(gcjyjk+k1 mod p, mj). 
2.2. Asymmetric concurrent signature protocol 
The protocol in Nguyen’s scheme is stated below.  Assume that Alice is the initial signer and Bob is the matching 
signer.  They perform the following protocol to exchange their concurrent signatures. 
Step 1: Alice generates the promise of Schnorr signature σA on the message mA∈M by the following steps. 
(1) Perform ISIGN(yA, xA, mA) to obtain the promise of Schnorr signature σA= (sA, cA)= ISIGN(yA, xA, 
mA) and the keystone kA. 
(2) Send (σA, mA) to Bob.z` 
Step 2: Bob performs first validate Alice’s promise of Schnorr signature σA and generates Bob’s promise of 
Schnorr-like signature ωB if σA is valid. 
(1) Validate Alice’s promise of Schnorr signature σA and the message mA by performing IVERIFY(σA, 
mA, yA).  If IVERIFY(σA, mA, yA)≠accept, then abort. 
(2) Perform SSIGN(yB, xB, mB, sA) to generate Bob’s promise of Schnorr-like signature ωB = (sB, k1, 
cB)= SSIGN(yB, xB, mB, sA), where sA is the second component in σA. 
(3) Send (ωB, mB) to Alice. 
Step 3: After receiving (ωB, mB), Alice runs SVERIFY(ωB, mB, yB) to verify the validity of ωB.  If 
SVERIFY(ωB, mB, yB)= accept, Alice uses the keystone kA to verify the keystone fix sB.  If this 
keystone fix is valid, Alice forwards the keystone kA to Bob. 
After finishing the protocol, Alice obtains Bob’s Schnorr-like signature ρB= (kB, cB)= (k1+kA, cB).  The ρB= (kB, 
cB) is validated directly by cB= H(gcByBkB, mB).  After Alice releases Bob’s Schnorr-like signature ρB= (kB, cB), Bob 
can obtain Alice’s Schnorr signature ρA= (kA, cA), where kA= kB –k1 mod q.  Then Alice’s signature ρA= (kA, cA) is 
validated directly by cA = H(gkAyA-cA mod p, mA). 
3 Our new scheme 
The underlying algorithms used to design our scheme are first described.  Then our new scheme is described. 
3.1. Underlying algorithms in our scheme 
Some underlying algorithms are defined.  Our scheme adopts the asymmetric concurrent signature scheme to 
exchange signatures between proxy signers and the trusted alias issuing authority, the algorithms, SETPUP, ISIGN, 
SSIGN, IVERIFY, SVERIFY, and CVERIFY, in asymmetric concurrent signature scheme are used.  Moreover, in 
order to generate signatures, our scheme needs discrete-logarithm-based signature schemes.  The underlying 
discrete-logarithm-based signature scheme has two basic algorithms.  One is the SIGN algorithm to generate 
signatures using someone’s private key, and another is the VERIFY algorithm to validate signatures by using 
someone’s public key.  These two basic algorithms are defined below. 
SIGN 
The SIGN algorithm takes the input (xi, m) and outputs signatures Ci, where xi is a private key and m is a 
message. 
VERIFY 
The VERIFY algorithm takes the input (yi, m, Ci) to validate the signature Ci, where yi is the public key and m is 
the message.  The VERIFY outputs accept if Ci= SIGN(xi, m); otherwise it outputs reject, where xi is the matching 
private key of the public key yi. 
3.2. Our scheme 
Our scheme consists of four phases: Setup phase, pseudonym registration phase, proxy authorization phase, and proxy 
signature generation and verification phase.  Those phases are described in the following. 
Setup phase 
The input of this algorithm is a security parameter l.  On the input l, SETUP algorithm outputs the following 
parameters: 
(1) Two large public prime numbers p and q such that q|(p-1) and q is exponential in l, 
(2) A public element g∈Zp* of order q, 
RDT08 
  
the promise of Schnorr signature σP= (sP, cP).  Fortunately, when the certificate ρT= (kT, cT) on mTA||IDP||IDA||yA is 
released, UT can obtain the Schnorr signature ρP= (kP, cP) by the following way.  According to IDP||IDA||yA, UT finds 
k1 and kT in ωT and ρT, respectively.  Then UT computes kP= kT –k1 mod q to recover the Schnorr signature ρP= (kP, 
cP). 
Proxy authorization phase 
After obtaining anonymous certificate that is the Schonorr-like signature ρT= (kT, cT), the proxy signer UP uses 
this signature ρT to get the original signer UO’s proxy authorization.  The detail of proxy authorization is described 
below. 
Step 1: UP sends UO the anonymous certificate ρT= (kT, cT) and mTA||IDP||IDA||yA. 
Step 2: UO verifies ρT= (kT, cT) by using the verification cT= H(gcTyTkT mod p mTA||IDP||IDA||yA) in Schnorr-like 
signature scheme.  If ρT is invalid, then abort. 
Step 3: UO generates the proxy-certificate CO for UP by CO= SIGN(xO, mW||IDA||yA), where mW is the proxy 
warrant specifying important proxy information.  Then UO sends UP the proxy certificate CO and mW. 
Step 4: UP validates the proxy certificate CO and mW, and defines the authorized proxy private/public keys. 
(1) Check whether or not VERIFY(yO, mW||IDA||yA, CO)= accept. 
(2) If VERIFY(yO, mW||IDA||yA, CO)= accept, UP sets the proxy private key as xA and the proxy public 
key as yA. 
Proxy signature generation and verification phase 
The proxy signer UP produces the anonymous proxy signature SA on a message m by using the proxy private key 
xA.  Then a verifier uses the proxy public key yA to validate the proxy signature SA.  The generation and verification 
of proxy signatures are described in the following steps. 
Step 1: UP computes SA= SIGN(xA, m). 
Step 2: UP sends {CO, mW||IDA||yA, SA, m} to a verifier UV. 
Step 3: UV verifies the proxy signature SA by the following steps 
(1) Check whether or not VERIFY(yO, mW||IDA||yA, CO) = accept. 
(2) Check whether or not VERIFY(yA, m, SA) = accept. 
If both VERIFY(yO, mW||IDA||yA, CO) and VERIFY(yA, m, SA) return accept, the proxy signature SA is 
valid. 
4 Security analysis 
The security analysis of this scheme with trusted alias issuing authority is given below.  The basic security 
assumption of our scheme is that the underlying discrete- logarithm-based signature scheme and the asymmetric 
concurrent signature scheme are secure. 
Unforgeability 
The proxy signature SA= SIGN(xA, m) in our scheme are generated by the underlying discrete-logarithm-based 
signature scheme.  Therefore, the unforgeability of proxy signatures is guaranteed by the unforgeability of 
underlying discrete-logarithm-based signature scheme.  To forge proxy signatures, the only chance for attacks is to 
find the proxy private key xA.  However, to find the proxy private key xA directly from yA is protected by the discrete 
logarithm hard problem (DLP for short).  So attackers cannot forge proxy signatures. 
Verifiability 
The proxy signatures in our scheme are verifiable by any verifier.  In our scheme, any verifier can validate the 
proxy certificate CO on mW||IDA||yA first.  Then the verifier can use the certificated proxy public key yA to verify any 
proxy signature SA on the message m by VERIFY(yA, m, SA). 
Proxy signer’s deviation 
The original signer’s private key xO is never disclosed in the communication in our scheme.  The original signer’s 
private key xO is only used to generate the proxy certificate CO on mW||IDA||yA.  Due to the underlying 
discrete-logarithm-based signature scheme is secure, the original signer’s private key xO is never released from the 
proxy certificate CO.  Because both the original signer’s private key xO and the underlying discrete-logarithm-based 
signature scheme are secure, there is no chance for the proxy signer to forge the original signer’s signatures.  So there 
is no proxy signer’s deviation in our scheme. 
Distinguishability 
Proxy signatures, proxy signers’ signatures, and the original signers’ signatures are distinguishable in our scheme 
