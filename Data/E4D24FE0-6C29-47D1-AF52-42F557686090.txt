 
中 文 摘 要 ： 本計畫主要目的在於提出一個完善的晶片系統軟硬體除錯方
法，並配合此方法發展應用於多核心晶片系統的除錯平台架
構，提供使用者可快速有效找出軟體程式錯誤、硬體設計錯
誤或是製程錯誤的系統化方法。本專案計畫挑選之深耕技術
項目，已完成和美國 Duke 大學 Prof. Krishnendu 
Chakrabarty 進行學術互動，建立雙方研究人員實質合作關
係，達成提升研究水準之目的。 
  隨著製程技術與設計自動化工具的快速演進，越來越多
大型且複雜的電路被整合進系統單晶片。對於複雜的多核心
系統單晶片而言，如何除錯變成極為重要的議題。錯誤的起
源有硬體設計不良、製造瑕疵、硬體使用耗損、軟體程式撰
寫錯誤…等。因此，本計畫提出的除錯平台突破傳統軟硬體
各自除錯的方式，同時處理軟體程式與硬體電路上的錯誤，
以求更精確的找出錯誤起因，讓多核心晶片系統的使用與開
發更有效率。本計畫著重於對多核心晶片系統發展完善的軟
硬體除錯平台：(1)建構在多重時脈環境下能控制不同的時脈
訊號以執行硬體中斷，並可對所有的 IP 進行除錯的硬體平
台。(2)建立支援 GDB 功能之多核心全系統模擬除錯系統之
軟體平台。(3)在晶片系統中整合對類比至數位轉換器進行錯
誤診斷與自我除錯之相關技術。本計畫最終建立一套完整的
多核心及多重時脈週期的 SoC 數位類比混合環境除錯系統。
中文關鍵詞： 除錯, 晶片系統, 多重時脈, 全系統平台, 自我測試電路, 
錯誤診斷 
英 文 摘 要 ： The main goal of this project is to develop a 
complete hardware/software debug platform for multi-
core SoC systems with integrated ADC mixed signal 
components. This platform will provide users the 
required system tool to quickly and efficiently 
identify the possible system errors due to software 
bugs, hardware design, or manufacturing process 
faults. The project has identified important 
technology issues and established real cooperation 
with Prof. Krishnendu Chakrabarty (Duke University, 
USA) and carried out quality research works. 
  As the process technology and design automation 
tools advance rapidly, more and more complex circuits 
are integrated into an SoC system. For a multi-core 
SoC design, debugging system errors becomes a very 
important yet challenging issue. The system errors 
may come from hardware design, manufacturing defects, 
 I
目錄 
中文摘要...............................................................................................II 
英文摘要...............................................................................................III 
一、前言...............................................................................................1 
二、研究目的.......................................................................................3 
三、文獻探討.......................................................................................5 
四、研究方法.......................................................................................22 
五、結果與討論...................................................................................47 
六、參考文獻.......................................................................................56 
七、計畫成果與自評...........................................................................61 
 III
Abstract 
The main goal of this project is to develop a complete hardware/software debug platform for 
multi-core SoC systems with integrated ADC mixed signal components. This platform will provide 
users the required system tool to quickly and efficiently identify the possible system errors due to 
software bugs, hardware design, or manufacturing process faults. The project has identified 
important technology issues and established real cooperation with Prof. Krishnendu Chakrabarty 
(Duke University, USA) and carried out quality research works. 
As the process technology and design automation tools advance rapidly, more and more 
complex circuits are integrated into an SoC system. For a multi-core SoC design, debugging system 
errors becomes a very important yet challenging issue. The system errors may come from hardware 
design, manufacturing defects, wearing-away of hardware components, software programming 
bugs … and so on. The integrated debug platform that this project aims for is a breakthrough one 
towards the traditional method which debugs separately. With the proposed debug platform, we can 
identify the causes of the errors more precisely and greatly improve the use and development of a 
multi-core SoC system. The three most important items to develop in the proposed work include:(1) 
a complete hardware SoC debug platform which has multi-clock domains and allows interrupt 
capability of all IPs used, (2) a full system simulation software platform supporting GDB debugging 
functions for multi-core programs, and (3) the integration of built-in self test and diagnosis of ADC- 
converters in the proposed SoC system. That is, a complete hardware/software debugging system for 
a multi-core mixed-signal SoC system. 
 
 
Keywords: debug, system-on-chip, multi-clock domain, full system platform, built-in self test circuit, 
diagnosis 
 
 2
完整 SoC 晶片測試的目的為一重要的課題。針對前述課題，本研究團隊過去執行晶片系統國
家型整合型研究計畫「晶片系統測試平台之設計與自動化」，針對單晶片內類比至數位轉換器
之測試問題，成功開發出相關的可測試設計與內建自我測試技術，並與晶片系統測試平台整合
驗證，發展出一套實際可用之系統單晶片測試環境。然而，當「如何在複雜的 SoC 晶片內對
類比至數位轉換器進行測試」的問題被大部分克服之後，更進一步地，「如何解決困難度更高
的測試問題」 (例如類比至數位轉換器之 Bit Error Rate 測試)；以及除了測試之外，「如何在
複雜的 SoC 晶片內對類比至數位轉換器進行錯誤診斷(diagnosis)/除錯(debugging)」 等問題，
是值得進一步深入探討與研究的議題，這也是此次參與深耕計畫的主要目的之一。 
 
 4
案計畫特別鼓勵所挑選之深耕技術項目，和國外重要研究機構互動，建立雙方研究人員實質合
作關係，以達成提升研究水準的目的。本計劃於短期內已達成技術深耕的效益，並進而完成具
前瞻性的研究成果。 
此計劃依上述目的完成之工作簡列如下： 
(1) 完成計劃相關文獻之整理，包括期刊論文、會議論文與國際標準等。 
(2) 分析除錯元件整合至測試平台所造成之影響，包括軟硬體之共用與測試模式與除錯模式。 
(3) 完成前述所建立暫存器轉換層次各種不同除錯與測試架構之 FPGA 雛型驗證。 
(4) 完成 SoC 除錯系統之相關自動化軟體。 
(5) 完成異質性多核心處理器系統平台建置。 
(6) 完成 GDB 系統建置以及運用 GDB 除錯多核心程式之開發模擬環境。 
(7) 完成重現多執行緒平行程式行為系統增加除錯功能之準確性。 
(8) 完成高速 ADC BER BIST 技術開發與 BIST 電路的設計、佈局、下線及量測驗證。 
(9) 完成 ADC BER BIST 電路與 SoC Testing/Diagnosis/Debugging 平台整合(含介面電路設計)。 
(10)完成 Pipelined ADC 診斷技術的開發與輔助電路的設計、佈局、下線及量測驗證。 
(11)完成 Pipelined ADC 診斷電路與 SoC Testing/Diagnosis/Debugging 平台整合(含介面電路)。 
 6
映著對系統效能影響的顯著性，當然也會反映在成本的支出上，所以加入一個 SIP 所需增加
的額外電路當然是愈少愈好。 
由於系統單晶片之高複雜度及含有眾多的核心電路，為了完整驗證這些核心電路，傳統
上做法是透過設計者撰寫測試程式(Testbench)，再配合 Simulator 進行模擬。在模擬過程中，
由於所設計之電路內部所有的訊號皆可輕易觀察，可幫助使用者在實際下線前除去大部分的
錯誤，稱之為 Pre-Silicon；但系統單晶片複雜度相當高，透過軟體模擬的輔助並無法在晶片
下線前達到徹底的驗證。其次，因系統單晶片內所採用矽智財電路之供應者未必相同，此情
形將造成不同核心電路間存在設計方法及驗證與除錯策略上之差異，故如何以系統化之方法
針對這些矽智財電路進行完整驗證與除錯為一相當值得探討之問題。除了 Simulation-Based 
Verification 外，廣泛被採用的 FPGA 雛形驗證(prototyping)亦提供了另一個除錯的方法。此
一驗證方法是在 FPGA 發展板中進行仿效模擬的實際晶片環境，如此便可以針對發展內部
所設計的電路進行更進一步的雛形驗證，更可增加使用者對於所設計的電路實際下線之前的
信心度。 
但是此法依然不足以驗證整個系統以及完整除去所有系統上存在的錯誤，往往在實際晶
片下線後，第一顆晶片(First Silicon)仍存在著許多的缺陷，不過系統開發者依舊希望能夠藉
由對下線後的晶片進行除錯，找到無法在 Pre-Silicon 時發現的錯誤。對實際晶片下線之後
所進行的除錯，被稱之為 Post-Silicon 除錯，在此一層級所進行的除錯一般也稱做矽晶片除
錯(Silicon debug)。但因實體的晶片觀察與控制能力受限，相較於 Pre-Silicon 除錯，更不易
讓系統開發者進行除錯。此點可說是目前 IC 設計業者在轉型成為系統設計者時最常遇到的
問題，也是台灣 IC 設計業者目前面臨最嚴苛的挑戰。 
在國內外相關研究方面，Maier [1] 在提出結構化的JTAG（Structural JTAG），其特點在
於能夠很快地整合至不同型態的系統單晶片上。針對微處理器內部的Trace，可以利用圖一
中的Debug bus interface達成，亦可同時對記憶體模組進行監控。 
In-Circuit Embedded ICE 擁有硬體中斷點機制，使用者下達中斷點指令以後，接下來輸入的
中斷資料會存到 breakpoint scan register，直到使用者輸入完成，而使用者所設定的中斷點值
便會傳到中斷點偵測單元（BDU）。此時，ICE 會開始偵測微處理器的程式位址與使用者輸
入之中斷點是否相符，若符合則表示發生中斷事件，ICE 則會停止微處理器的動作執行，而
使用者便可針對微處理器內部做觀察與設定的動作，達成除錯的目的。但由於此除錯架構是
針對微處理器所設計，對於一般的核心電路而言，可能無法得到比較詳細的除錯資訊。 
External
debugger
Test data in 
(TDI)
Test mode select (TMS)
Test clock (TCK)
Test reset (TRST)
Microprocessor core
ICE
M/I
Interface 
Breakpoint
Detection
unit
Breakpoint configuration register
Bypass register
Scan chain configuration register
Instruction
register
Decode
logic
Test access port controller
Multiplexer
Standard JTAG Ccomponents
New components
Internal scan chain (optional)
Flush
eoi
m
od
e
C
or
e 
cl
oc
k address
data
scan_out
breakpoint
shift_IR update_IR
Test data out 
(TDO)
ICE_status
Boundary scan chain
 
▲圖二 IEEE 1149.1 JTAG Support Debug Architecture 
圖三為[6]所提出利用DSP處理器為主的除錯平台設計。透過設定除錯條件，Data 
Observer 可選擇欲觀察的內部資訊；在除錯事件觸發時，Data 將透過Trace Processing Unit 
傳遞至Trace Formatting Unit，分別對PC時脈以及觀察資料進行壓縮，透過XOR閘的壓縮設
計方式，並將壓縮過後的Data 放入FIFO 等候由晶片內部傳出至外部。因此，可藉由這樣的
方式，對DSP系統內部的PC、指令記憶體，以及資料記憶體進行除錯。 
 8
在論文[12]中，提出了針對transaction-based的debug機制。Transaction-based 的debug常
使用cross-trigger的方式來取得欲觀察的值。Cross-trigger的意思是trigger的訊號產生在一個
debug entity，但是event是發生再另一debug entity。此篇的主要概念是將debug trigger的訊號
和request訊號一起經由functional path傳送，而不是經額外debug專用路徑。如此可解決
functional path和 debug 路徑之間的latency問題，不會因為提早或延遲收到trigger訊號，造成
抓取到的觀察值產生錯誤，同時也解決 restore機制的問題。但是這個方法要修改
interconnection的router介面，在routing時負擔會變的相當大。圖五為其示意圖。 
 
▲圖五 In-band Debug Event Distribution 
 
(二) 多核心系統軟體發展與除錯平台 
 GNU debugger (GDB) on virtual platform 
GNU debugger (GDB)[40][41]為現今最被廣泛使用的開放源碼軟體除錯工具，因其具有
相當大的彈性，可適用於多種處理器架構，所以有相當多的嵌入式系統開發者利用GDB來幫
助軟體開發。GDB提供了中斷點與單步執行等動作來控制程式執行，同時支援觀察點、暫存
器存取、記憶體存取與函式呼叫流程回溯等。 
在開發嵌入系統時，除錯的目標程式通常是在遠端，例如開發板上。因此，GDB 提供
了遠端除錯協定來幫助我們除錯遠端的程式，稱做 remote debugging protocol (RDP) ，而本
機端可以與遠端利用 TCP/IP 或是串流連接埠(如 JTAG 或 ICE)連接，如圖六所示。 
 10
 ▲圖七 GDB with ESL simulation environment 
 多核心聯接機制 
電腦系統中，元件之間彼此溝通的效率對於整個系統運作的效能有很大的影響，而在以
往的單核心系統中，由於晶片中的通訊需求並不大，因此使用傳統的匯流排(Bus)就已經足
夠。然而，隨著晶片系統(SoC)技術的成熟，單晶片系統中的核心數量越來越多，現有匯流
排所能提供的頻寬已經不足以滿足下一世代之SoC系統的需求。於是，學者提出晶片網路
(Network on Chip, NoC)的概念，希望利用網路可以同時傳輸多筆資料的特性，使得晶片上的
通訊效能可以更好[50]-[56]。 
晶片網路系統的研究是個方興未艾的領域，近來國際間已經有許多成果。以下就晶片網
路系統的設計上常見的議題，包括拓撲的選用及設計(Topology selection and design)、封包路
線找尋及排程(Packet routing and scheduling)、交換器設計(Switch design)、設計自動化(Design 
Automation)以及效能模擬分析(Performance simulation and analysis)的研究成果進行討論。 
 拓撲的選用及設計：  
拓撲可分為規則拓撲(Regular topology)及應用特定拓撲(Application-specific topology)。
規則拓撲較適合用於通用系統(General purpose system)，應用特定拓撲則需要經過分析並產
生一個特殊的拓撲。拓撲對於NoC系統的效能有決定性的影響，因此很多學者已經提出許多
拓撲分析及選用的方法，期望能找到一個最適合的拓撲。[51]中提出如何把應用對映至規則
 12
此除錯架構提供了多核心除錯以及記錄各核心指令流順序之功能。PC 上的除錯軟體例
如 RVDS，透過 Multi-ICE 或 RealView-ICE 將除錯指令送到 JTAG Debug Port 上，與硬體上
的 Debug Access Port(DAP)溝通。底層硬體上是由 DAP 和 Embedded Cross Trigger(ECT)來控
制，指令流順序則由 AHB Trace Marcocell(HTM)，CoreSight Embedded Trace Marcocells(ETMs)
及 Instrumentation Trace Marcocell(ITM)來記錄。在除錯訊號與除錯資料之連接機制上，ARM
是用 ECT 去控制，因此我們也特別研究這部分的設計與實作。 
ARM Embedded Cross Trigger(ECT)[45]模組主要是用來連接各核心並且讓各核心之間
的觸發事件能夠互相傳遞，而除錯訊號就是其中一種觸發事件。ARM CPU透過致能除錯訊
號進入除錯模式，因此在多核心系統中，當任何一個核心因中斷點等事件而進入除錯模式
時，其他核心也必須一同進入除錯模式，以免干擾除錯過程。 
ECT 由一個 Cross Trigger Matrix (CTM) 與數個 Cross Trigger Interface (CTI)組成，其架
構如圖九所示。 
 
▲圖九 Embedded Cross Trigger Example 
CTI 為子系統(如某單一核心)與 CTM 之間的介面，CTI 將子系統上的觸發事件對應到
CTM channel 上，另一方面也接收來自 CTM channel 的觸發事件並將之對應到子系統上的觸
 14
當然越多的紀錄暫存器代表著越高的額外硬體成本，因此Regular Transitive Reduction 
(RTR)[47]和Strata[48]便專注在硬體成本上的降低。然而需要被記錄的資訊量和硬體成本需
求成正相關，Rerun[49]記錄各執行緒有多久沒有和其他執行緒發生衝突，而非傳統的記錄每
一次的記憶體衝突，因此硬體成本大幅降低，如圖十一(a)。圖十一(b)顯示Rerun不但紀錄檔
大小更小且幾乎不會因核心數目增加而變大。在多核心系統上，Rerun是目前成本最低且最
有效率的多執行緒平行程式行為重現的方法。 
 
   (a)                           (b) 
▲圖十一 Rerun System Estimation 
 
(三) 類比至數位轉換器之相關測試技術 
 類比至數位轉換器之 Bit Error Rate 測試與內建自我測試技術研發 
類比至數位轉換器需要測試多項效能參數才能確保其訊號轉換的品質，而這些效能參數
大致上可分為靜態參數(static parameter)和動態參數(dynamic parameter)，如圖十二所示。在
動態參數測試和靜態參數測試方面已有相當豐富的研究成果被發表，但是在位元錯誤率
(Bit-Error-Rate, BER)測試方面的相關研究卻鮮少有論文提及，主要的原因有三：(1)類比至數
位轉換器之 BER 測試與一般高速串列傳輸界面電路之 BER 測試不同，後者只需要量測一個
位元資料的正確與否，問題相對單純簡單；然而，前者卻需要同時觀測數個位元的資料，並
經由複雜的算術運算才能知道是否有 bit error 產生，困難度高出許多；(2)部分類比數位轉換
 16
 18
A國內外關於 DC動態和靜態參數測試等相關研究已有相當多的學術論文發表
[57]-[66]，本研究團隊過去亦在此一領域有深入的研討，並且有相關研究成果發表[67]-[72]。
但就BER的測試而言，除了Analog Devices公司在其Application Note [73]有提到ADC BER的
概念、BER測試的重要性以及建議測試設置(test setup)外，截至今日，尚未發現任何相關的
學術論文被發表。因此，本計畫所研發之Flash ADC with BER BIST為目前世界上第一個以晶
片實證此一功能的作品。 
▲表一 一個 100-MS/s 的類比至數位轉換器測試不同規格的位元錯誤率，每量測到一個 bit 
error 所需的平均測試時間 
 
 管路式類比至數位轉換器之錯誤診斷(diagnosis)/除錯(debugging)技術研發 
管路式類比至數位轉換器(pipelined ADC)廣泛地應用於現今的通訊和影音產品當中。一
個具有數位錯誤校正(digital error correction, DEC)的傳統 pipelined ADC 架構如圖十三所示，
包含一個前端取樣保持放大器(Sample-and-Hold Amplifier, SHA)，以及數個相互串連的管路
級(pipelined stages)。其中，數位校正電路是為了數位碼能同步輸出以及校正每一級管路級的
offset error。如圖十三所示，每一級管路級包含兩個主要子電路：類比至數位轉換子電路
(Sub-A/D)以及數位至類比轉換子電路(Multiplying Digital-to-Analog Converter, MDAC)。由於
數位校正電路的輔助，pipelined ADC 可以容忍相當程度的 offset error，因此類比至數位轉換
子電路的效能通常不會對整個 pipelined ADC 的效能造成重大的影響。整個 pipelined ADC 效
能的主要瓶頸大多出現在 MDAC 子電路，傳統切換電容式 MDAC 子電路的細部電路架構如
圖十四所示，其中包含運算放大器(operational amplifier, op-amp)、切換開關以及電容等元件。
而這些元件的非理想特性正是管路式類比至數位轉換器主要的誤差來源(error sources)，大致
上可以將這些 error sources 分成兩大類，如下所示： 
 20
這些誤差來源不僅僅會降低類比至數位轉換器的效能，而且因為他們產生的 fault effects
會同時對輸出造成影響，所以難以從輸出來判斷是哪種 error source 對效能降低的影響最為
嚴重，進而增加管路式類比至數位轉換器診斷與除錯的困難程度。 
從 1990 年代至今，有些關於診斷ADC錯誤方法的文章已陸續發表。在論文[71],[74]-[77]
中，雖然是針對不同的ADC架構，但是用來診斷錯誤的工具不約而同皆使用DNL與INL。在
論文[74][75]中，DNL與INL是用來估計錯誤量，但是估計到的結果是許多error sources共同
造成的效應，所以無法判別哪個error source的影響最為嚴重，即使事先討論不同的error source
對INL與DNL造成的效應[76]也無法達到。 
除了INL與DNL這診斷工具之外，還有人是使用電壓控制震盪器(VCO)來測試pipelined 
ADC中SHA和MDAC輸出的精確性[71]，雖然此方法對製程偏移所造成的錯誤不敏感，而且
複雜度低，但是VCO產生的高頻雜訊即有可能耦合到pipelined ADC內部對於效能影響嚴重的
類比訊號，而降低結果的精確度。又有研究是試著使用structure-based 的方法來有效的診斷、
判斷出不同的error source[77]，只不過此方法對於測試輸入訊號的精確度要求極高，所以應
用此方法的困難程度因而增加許多。 
國際組織標準： 
 IEEE 1149.7 標準  
由於 IEEE 1149.1 JTAG 制定至今 20 多年來，廣泛被工程人員採用，尤其是針對系統開
發以及系統除錯來說，幫助很大。IEEE 在 2009 年公布新的 IEEE 1149.7 標準，不僅能向下
相容 IEEE 1149.1，更能夠有效的提升除錯效能，更能夠有效的減少系統單晶片的接腳數。
新標準能夠提供的優勢有下列幾項： 
 可透過新的標準控制除錯邏輯的功率消耗 
 透過系統層級的旁路設計，可大幅降低縮短掃描串列的掃描時間，直接改善除錯
效率。 
 將星狀拓樸導入標準序列式拓樸設計。 
 22
四、研究方法 
(一) SoC 硬體除錯平台及軟硬體共同除錯機制: 
由於系統單晶片內所採用矽智財電路之供應者未必相同，此情形將造成不同核心電路間
存在設計方法及測試策略上之差異，更加深整個系統在除錯過程中的困難處，因此如何以系
統化之方法針對這些矽智財電路進行完整測試以及方便使用者對整個系統進行除錯，為一相
當值得探討之問題。由於矽智財電路通常深埋於系統單晶片之設計內，但測試流程中往往需
要利用系統之輸入/輸出埠提供矽智財電路測試向量並觀察測試結果，故如何透過系統之輸
入/輸出埠存取這些矽智財電路以有效完成除錯與測試流程為另一值得研究之問題。 
本計畫所發展的各項除錯機制，包含針對多重時脈週期環境下之 Multiple clock domain 
debug，主要是建立在除錯平台的硬體中斷點功能上，目的是幫助除錯平台執行硬體中斷點
時可以控制系統單晶片上所存在的多個時脈訊號，並在能確保時脈的運作和 function 正常上
執行除錯功能。此 Multiple clock domain debug 功能如下: 
 提供一個Clock Control unit，在多重時脈的環境用來控制和維持多重時脈訊號。 
 透過Clock Control unit中的clock control interface，使用者可以任意選擇clock domain
來發送breakpoint。 
 避免時脈暫停造成待除錯電路的Function出錯。藉由Multiple clock domain debug提供
偵測裝置可避免除錯功能運作時造成電路Function出錯。 
 提供除錯與測試整合平台操作在多重時脈的環境。在進行debug時系統整合者可使除
錯與測試整合平台操作於較慢的頻率，並同時抓取不同clock domain的待除錯電路資
訊來觀看。 
 提供新的除錯自動比對機制。DASTEP可以透過除錯電路傳送的內部資訊來做出各個
clock domain的hard trace & soft trace compare。 
 24
內部掃瞄鏈(Scan Chain)的資訊。 
 自動比對機制：自動比對擷取結果(Hard Trace)與預期結果(Soft Trace)是否有錯
誤產生 
5. 多樣化的觸發機制： 
 時間點觸發模式：使用者可在任意時間點觀看硬體內部行為。 
 匯流排位址觸發模式：依照匯流排所給予的位址，觀看匯流排資訊。 
 週期性觸發模式：透過週期性的觸發，觀看匯流排和硬體電路資訊。 
6. 本除錯平台不僅在矽晶片可幫助除錯，也可與系統發展板共同配合，幫助使用者在進
行FPGA雛型驗證時進行除錯功能。 
7. 除錯平台可經由非同步傳輸機制(UART)進行外部設定(Off-Chip Setup)，不限於只能
透過核心處理器設定或啟動，使用者無須修改其應用程式即可進行除錯功能驗證。 
8. 建立對應的使用者圖形介面，具下述功能：  
 可進行除錯元件的自動化產生及整合。 
 執行各種除錯功能的操作。 
(2) 除錯平台執行流程 
本計畫提出一個多核心及多重時脈週期晶片系統之除錯平台(Debug platform)來支
援軟硬體共同模擬及驗證，而此硬體除錯機制可分成兩個 levels 進行，如圖十五所示，
其中 Virtual Level 指的是晶片下線之前(Pre-Silicon)的階段，而 Physical Level 指的是實
際晶片下線之後 (Post-Silicon)的階段。Physical Level 則依即時追蹤及硬體中斷點又區
分為兩階段。本除錯流程的第一步是執行 Virtual Level 模擬以獲得預期結果，再進入下
一步 Physical Level 執行。SoC 以 FPGA emulate 或晶片下線之後，將實際晶片內部的
訊號透過除錯機制擷取出來，定義為 Hard trace，並與 Soft trace 比對及分析是否有錯誤
 26
 執行即時追蹤程序 
即時追蹤會於系統執行一般功能時，同時擷取使用者欲觀察之系統匯流排以及邊界
包裝的資訊（此資訊稱之為追蹤結果 B），並將擷取的資訊暫存到自有記憶體(Local 
Memory)，直到一般功能完全執行結束。此動作將不會中斷或暫停系統運作。 
 比較預期結果與即時追蹤結果 
當即時追蹤程序執行結束後，經由 Trace Port 透過 UART 將即時追蹤結果 B 儲存至
PC Host，並透過自動化軟體將預期結果 A 與即時追蹤結果 B 進行比對。 
當階段一之追蹤結果與預期結果完全匹配時，由使用者決定是否需要再次執行即時
追蹤，來確保剩餘的追蹤結果與預期結果完全匹配。若使用者認為不需要再執行，則此
階段結束。當發生預期結果與追蹤結果不匹配的情況時，進入階段二，並且記錄不匹配
情況所發生的時間區域，做為使用者進入階段二後設置中斷點之參考。 
 Physical Level 階段二：硬體中斷點 
在這個階段，將依據使用者所設定的時脈週期來暫停系統運作。從階段一的追蹤結
果，使用者可以得知錯誤是發生在哪個時間區域，如此便可在適當的時脈週期加入中斷
點。當中斷發生時，除錯系統會將待除錯電路邊界包裝及內部掃瞄鏈的資訊擷取下來，
擷取完成後，再將資料掃瞄回待除錯電路的內部，恢復中斷點前的狀態，並解除暫停使
系統恢復運作，直到下一次的中斷點發生。 
執行硬體中斷點程序： 
硬體中斷點程序提供使用者可以在任意時脈週期設置中斷點，使得系統執行到該時
脈週期時，透過停止時脈的方式，將整個系統暫停。 
 掃瞄出實體資料並恢復 
系統暫停後，除錯控制電路將取代嵌入式處理器取得系統匯流排的控制權，並控制
整個除錯程序。除錯控制電路將待除錯之電路內部及邊界資訊擷取出來，稱之為追蹤結
的位址線與資料線；當符合中斷條件時，通知處理器進入除錯模式並接手控制處理器。因此，
處理器端必須夠接收 GDB stub 的訊號以進入或退出除錯模式。此外，也必須具有一與 GDB 
stub 溝通的介面，如圖十六(a)，使得在除錯模式下，GDB stub 能夠控制處理器運作，如停
止管線前進，單步執行等。 
 
GDB stub
GDB
CPU
Reg files Control unit
Stub interface
Memory
Address bus
Data bus
LDR  R0, [target address]
 
(a)                            (b) 
▲圖十六 Interface between GDB stub and CPU 
若要存取記憶體的值則有兩種方法。第一種方法是參考硬體的作法，如圖十六(b) 。GDB 
stub 不僅監控，同時具有修改位址線與資料線的功能，可以將指令例如 Load 放到資料線上，
接著讓處理器抓取到此指令去執行，而記憶體的值便會被讀到暫存器中；GDB stub 從處理
器內取得值後，包裝成 RDP 封包送回 GDB 端。當然原本處理器內的狀態必須被保存，以保
證退回一般模式後能正常運作。第二種方法則是利用軟體的便利性，我們可以將 GDB stub
視為匯流排上模組，如圖十七，使之具有直接讀寫記憶體的能力，如此一來便可省去儲存處
理器狀態的多餘動作，提高除錯速度。 
 28
GDB 與 GDB stub 透過 TCP/IP 連接，因此只要 GDB stub 監聽的連接埠與 GDB 使用遠
端除錯時指定的連接埠相同，GDB 與 GDB stub 就能利用 socket call 互相溝通與傳送 RDP
封包。與處理器連接的部分則必須要能傳送控制訊號來控制處理器動作。另一方面，GDB stub
要能夠解讀出 RDP 封包內容與將資料包裝成 RDP 封包，圖十九為 RDP 制定之封包格式。 
→ $command/data #checksum
 +
 
▲圖十九 RDP packet format 
每個 RDP 封包以“$＂開頭“#＂結尾，後面加上 8-bit checksum。不論是 GDB 端還是
GDB stub 端，收到 RDP 封包後須檢查 checksum，若封包正確則必須回傳“+＂作為回應。
此部分須根據 RDP 規則，設計一段負責包裝與拆解 RDP 封包，與 GDB 可溝通後，才能讓
除錯動作順利進行。 
 GDB stub interconnection 
每個核心必須伴隨著一個 GDB stub 模組來幫助除錯，當我們從單核心系統擴充成多核
心系統，代表著平台上將會有許多個 GDB stub。當某個核心因為中斷點等原因進入了除錯
模式，為了避免其他核心的動作干擾除錯過程，我們必須也讓其他核心進入除錯模式，以達
成所有平台上的核心一起停止，一起單步執行等動作。因此我們參考 ARM CoreSight 標準其
中的 Embedded Cross Trigger(ECT)的方法，將各核心的 GDB stub 連接起來，讓他們能互相
溝通除錯或是單步執行等的訊號，如圖二十所示。 
GDBGDB stub 0
CPU0
GDB stub 1
CPU1
GDB stub 2
CPU2
GDB stub n
CPUn
Embedded Cross Trigger (ECT)
Inter Connection (NOC)
 
▲圖二十 Multi-core debugging system 
 30
 
▲圖二十一 General Switch Router 
 拓蹼：拓蹼可由規則性分類。常用的規則拓撲包括 Mesh、Torus、Ring、Octagon、
honeycomb 及 Binary Tree 等。大多數的晶片網路系統都使用規則的拓蹼，因此往後做
實體電路佈局的時候會較容易。每種拓蹼都有其適用的場合，舉例來說，Mesh 中連結
的應用率較高，而 tree-based 的拓蹼則較能利用資料流的區域性。拓蹼亦可分為直接拓
蹼(Direct Topology)及間接拓蹼(Indirect Topology)。直接拓蹼指的是拓蹼中每個交換單
元都與一個核心連接，而間接拓蹼則有部份交換單元僅與其他交換單元相接而未與任
何核心直接相連。 
 通訊協定： 
1. 迴路交換或封包交換(Circuit vs. packet switching)：交換器為資料保留一個固定路
徑，直到傳輸全部完成才釋放，稱為迴路交換。將資料包成封包，一站一站地傳送，
則為封包交換。 
2. 連線導向或無預先連線(Connection-oriented vs. connectionless)：傳送實體資料前需先
有邏輯上的連線，稱為連線導向，反之稱為無預先連線。 
3. 決定性路由或適應性路由(Deterministic routing vs. adaptive routing)：封包路徑在出發
地就已決定好，稱之為決定性路由。若路徑由沿路之交換器動態作決定，則稱為適
應性路由。 
 32
 34
在決定互連網路的最終架構之前，我們先決定採用何種記憶體架構。為了確立封包格
式，我們研究此晶片網路系統必需提供的支援。平行程式在執行時，會有資料搶奪(Data 
Race)的問題，因此本系統必須支援解決此議題的不可分割的交易(Atomic Transaction)。
本晶片網路系統必須建立維持快取一致性(Cache Coherece)的機制，以使程式能正常運
作。常見的快取一致性協定有目錄式(Directory-based)及窺探式(Snooping)的方法。窺探
式協定較適合於匯流排系統中，而目錄式協定則適合用於晶片網路中。 
 資料流控制(Flow Control)：資料流控制指的是決定封包如何沿著網路路徑移動。此議
題也包括如何最佳化網路資源的應用以及提供效能可預測的通訊服務。虛擬通道
(Virtual Channels, VCs)是一種資料流控制的技術，其在一個實體路徑存在多個虛擬路
徑。這些虛擬的路徑會有個別且獨立的緩衝。運作時，同時間只會有一個虛擬通道佔
用實體路徑，然而若此虛擬通道中的資料因為某些原因無法向前傳輸，這個通道會被
暫時釋放供另外的虛擬通道使用。 
運用虛擬通道可得到下列好處： 
1. 免除死結(Avoiding Deadlock)：透過適當的選擇路由方式，系統可以解開存在的迴
圈(Cycle)。 
2. 最佳化線路使用率：使多個虛擬邏輯通道共用同一個實體通道，提高線路利用率，
連帶的使漏電流減少，並減輕佈線的難度。 
3. 增進效能：即使緩衝的總量相同，運用虛擬通道的設計在高通訊負載時效能會較好。 
 Deterministic replay support 
在重現多執行緒平行程式行為方面，我們把 Rerun 的想法應用在我們的平台上。實作上
主要分成核心部分與共享記憶體部分。如圖二十二所示： 
 ▲圖二十三 Rerun Algorithm 
 
(三) 類比至數位轉換器相關測試與除錯設計 
 類比至數位轉換器之 Bit Error Rate 測試與內建自我測試技術研發 
由於本研究子題旨在研發 ADC BER 測試的 BIST 技術及其電路設計，因此我們必須先
選定合理的 ADC 架構並實現其電路來做為未來研發過程的待測電路。由於要針對高速 ADC
作 BIST 的難度遠高於低速的 ADC，並且高速 ADC 的應用範圍也涵蓋通訊晶片，因此於本
計畫擬採操作頻率可達 1G 以上的 flash ADC 為測試對象。 
傳統的 BER 測試方式如圖二十四所示。先由 Sinewave Source 產生輸入訊號灌到 ADC
裡面，然後利用兩個 registers 記錄目前 ADC 解出來的 code 和上一筆 ADC 解出來的 Code，
最後將兩個 code 相減取絕對值，判斷是否有超過事先定義的臨界值(threshold)，若是超過臨
 36
斷，適當地利用查表法來取代原本的減法器。comparison circuit 的架構和判斷機制如圖二十
六和圖二十七所示。 
G1 G2 G3 G4 G5
1
A
B
C
 
▲圖二十六 以Gray code為基礎comparison circuit架構 
= 1
If Code  equals to 
Code -1 
XOR Code 
with Code -1
Use  Code  to find 
verification code
If Code  and -1 has 
1-bit difference 
Error counter
If code distance  
is 1
= +1
Start
Exit
 
▲圖二十七 comparison circuit的判斷流程圖 
在進行完電路架構設計後，接下來便是要先建立 behavioral model 來做初步的驗證，以
確定 BIST 電路的正確性以及操作速度。在模擬結果驗證完成後，進行晶片下線(含 Flash ADC
以及 BER BIST 電路)以及量測的動作來驗證此電路的效能。 
 38
至於 gain error 方面，假設 Vtest訊號與 Vout電壓大小相近的話，傳到 back-end stage 之後
他們感受到的 gain error 是差不多的，因此利用方程式(3)便可以移除掉 back-end stage 中 gain 
error 造成的 effects。而且因為最後的到的結果是一個分式，所以即使 Vtest 不是一個準確的
DC 值也沒關係，換言之，此方法對於 Vtest訊號的精確度沒有太大的要求。 
  idealoutdiff
erroutdiff
testtest
outnoutp
testdiff
outdiff
D
D
VV
VV
V
V
,_
,_
_
_ 
    (3) 
接下來，便是討論如何將不同的 error effects 從 SUT 的輸出訊號分離出來，以下會仔細
介紹如何辨認出不同 error source 的電路實際操作方法。 
 Identifying gain error sources 
 Op-amp gain error 
在 pipelined ADC 中，finite op-amp gain 以及 capacitor mismatch 是兩種主要的 static gain 
error 主要來源。為了能從 Vtest 與 Vout 對應到的數位碼 Dout,err 和 Dout,ideal 中得到 op-amp gain 
error，所以 Vtest與 Vout訊號必須是相近的，換言之，在圖二十八中，SUT 必須是 SHA 的操
作。為了從 SUT 中隔離掉 capacitor mismatch 造成的效應，所以 SUT 操作過程中，訊號傳遞
上自始至終只用到一顆電容，如圖二十九所示。在 sampling phase 時候(1/1a)，只有一顆電
容 Cf 對輸入訊號進行取樣，Cs則是接到一定電壓，處在 reset 狀態。到了 amplifying phase(2)
的時候，Cf 則是與 opamp 輸出端相接，Cs仍舊接到 zero voltage。因為電荷不會從 Cs流進流
出，所以即使 Cf 與 Cs 不匹配，最後的輸出電壓不會感受到任何效應，這整個操作的 transfer 
function 如方程式(4)所示： 















 












f
psff
psf
off
f
psf
testout
AC
CCCC
CCC
V
AC
CCCVV
1
1
1
1    (4) 
 40















 
















f
psff
psf
off
f
psff
s
testout
AC
CCCC
CCC
V
AC
CCCC
CVV
1
1
1
1    (7) 
+
_
C f
C s
Vtest
Vout
1
1
2
2 1a 1
0
+
_
C f
+
_ Vout
C f
C s
C s
Cp
Cp
Cp
A
A
Vtest
1/ 1a=1
2=1
Voff
Voff
 
▲圖三十 Circuit topology for identifying capacitor mismatch 
這種接法是將電路接成 inverted SHA circuit，Vout 同時包含 capacitor mismatch 以及
op-amp gain error，因為在前一個步驟就已經得知 op-amp gain error，所以將之前的結果代入
方程式(7)再配合方程式(2)-(4)便可以得知 capacitor ratio，結果如方程式(8)所示： 



















f
psfidealoutdiff
errcapoutdiff
f
s
AC
CCCD
D
C
C
1
1/
,_
_,_     (8) 
理想上，Cs 與 Cf 比值(Cs/Cf)是 1，如果有 capacitor mismatch 存在 Cs與 Cf 比值便會漂離 1。 
 Identifying offset error sources 
 stage input referred offset 
op-amp 和 switch 是 pipelined stage input referred offset 的主要來源，在圖二十九和圖三十
當中，當 Vtest訊號設為零的時候，Vout訊號只包含 output offset，如方程式(9)所示： 















 
f
psff
psf
offout
AC
CCCC
CCC
VV
1
1    (9) 
 42
圖三十一是一個 10-bit 1.5-bit/stage pipelined ADC 將 sinusoidal input 轉為 digital code 的
對照圖，這轉換過程中，我們將第一級的 coarse LSB 強制設為零，這麼一來就可以輕易的得
知第一級 transition code 發生的位置，而他與理想中 transition code 發生的位置(3/82N and 
5/82N)之間的差異就是 SUT 中 comparator offset 的量。 
+Vref-Vref
-Vref
+Vref
0
Dout=00 Dout=10Dout=01
-Vref/4
Vref/4
(VIN)
(Residue)
Ddiff_tran,ideal
Ddiff_tran,real
 
▲圖三十一 一個1.5-bit/stage MDAC電路的電壓轉換曲線 
0 500 1000 1500 2000 2500 3000 3500 4000 4500
0
200
400
600
800
1000
Dout for detecting comparator offsets
index
D
ou
t(
10
-b
it)
Dout,tran_1
Dout,tran_2
 
▲圖三十二 輸入sinusoidal input給第一級以偵測transition codes的位置並觀察Dout的分布情況 
從圖三十二也可同時看出數位碼的分布會受到從來自 SUT 以及 back-end ADC 的兩種
錯誤量─input referred offset 以及 ADC gain error─所影響，這些因素會增加判斷 comparator 
offset 的困難度。但是要用一個簡單的訊號將全部 ADC 的 gain error 偵測出來是非常困難的，
而且 gain error 跟 input referred offset 比較起來根本微不足道，所以在偵測 comparator offset 
error 這方面只需要考慮 input referred offset 的緣故所造成的誤差。圖三十三是偵測 SUT 中
comparator offset 的電路示意圖。圖中，一個完整的 ADC 包含 SUT 以及 back-end stage。首
先，在 step 1 中，會先輸入一個變化速度緩慢的 sinusoidal signal 來偵測 SUT 電路中兩個
transition code(Dout,tran,i)發生的位置，接著，就是輸入一個 zero voltage 以偵測 input referred 
 44
input node 的雜散電容(Cp)會降低 SC 電路的 feedback factor，但是圖三十四中的電路接法不
會在 op-amp input node 增加任何的雜散電容，所以圖三十四的電路不會對 SUT 的 accuracy
以及 speed 方面造成任何的影響。 
+
_
C f
C s
Vout
2
1a 1
1
1
2
Vin
0
Cp
Vdac,nor{0,±Vref}
Test Ctr. Sig.
Vtest
Vlin
Vfed
Vdac,fed{0,±Vref}
0
Test Ctr. Sig.
Vtest
Vlin
Vfed
 
▲圖三十四 Circuit topology of the design-for-diagnosis MDAC. 
 Test signal generator 
圖三十五是 signal generator 的實現方式。圖三十五(a)中，使用一個簡單的 resistor ladder
來產生所需要的 DC 電壓，以偵測 op-amp gain error 和 capacitor mismatch；圖三十五(b)則是
ramp generator，以偵測 comparator offset，當中這顆 op-amp 決定輸出訊號的線性度，可是因
為偵測 comparator offset 過程對輸入訊號的線性度要求不高，一個 low-gain amplifier 便足夠。 
Vtestp
Vtestn
(a) 
+
_ Vtestp
Vtestn
Cint
Cint  
(b) 
▲圖三十五 (a) dc signal generator and (b) slow ramp signal generator. 
 46
其測試流程如圖三十七。執行測試流程時，透過多個核心中任意一個嵌入式處理器將測
試向量體搬移到本地記憶體中，然後利用嵌入式處理器對 TAM Controller 內部的測試控制暫
存器作初始化的動作，TAM Controller 隨即開始執行測試流程，透過 TAM Controller 至本地
記憶體將測試向量經由測試匯流排傳至待測試電路內部，並將待測試電路的測試結果回傳到
TAM Controller 裡的硬體比較電路做結果分析。如果待測試電路的測試結果有出現錯誤時，
則比較電路會將錯誤訊息寫回 TAM Controller 的本地記憶體中，最後再由嵌入式處理器去檢
查 TAM Controller 在測試流程中待測試電路是否有錯誤的資訊產生；如果有錯誤的資訊產
生，可經由嵌入式處理器將本地記憶體裡的錯誤訊息讀出。 
 
▲圖三十七 測試流程 
 多重時脈環境下對所有的 IP 進行除錯之除錯架構： 
在產品開發的過程中，常常因為在除錯與驗證實際晶片的階段耗費大量時間，造成產品
上市時間的延誤。為了能有效節省晶片除錯及驗證的時間，基於先前計畫成果之 Advanced 
SoC Test Platform，加入硬體除錯所需之電路，發展出一套完整的單晶片除錯平台，以有效
縮短晶片除錯及驗證的時間。透過分析除錯的過程中，針對系統與矽智產電路等在非同步溝
通上可能產生的各種問題，發展出相對應的多重時脈暫停技術與具有設定硬體中斷點和單步
 48
和 Cross Trigger Matrix (CTM) 以及前述之硬體除錯平台。CTI 負責發出或接收除錯要求，
CTM 就會依照 CTI 的設定將除錯要求傳遞到至所指定的 CTI 上，透過這樣傳遞除錯訊息的
方式，讓整個 SoC 硬體除錯平台具有在多個嵌入式核心之間與多個嵌入式核心及矽智產電
路間共同除錯的功能。 
在此除錯整合架構下，如下圖三十九所示，在對驗證程式除錯時，當 ARM 嵌入式處理
器執行到驗證程式中的中斷點，ARM 嵌入式處理器就會進入除錯狀態，同時 ARM 嵌入式
處理也會透過 ARM CoreSight Architecture 對 TAM Controller 發出進入除錯狀態的請求；當
TAM Controller (TAMC)接收到除錯請求訊號時，時脈控制單元可暫停所有待除錯電路內部
的多個時脈訊號並將其切換至除錯時脈訊號，此時除錯控制單元會發送出控制訊號以啟動除
錯動作，並經由 UART 傳送待除錯電路中的狀態資料至 PC-host。 
ARM CoreSight
ARM
CTI
0
CTM
0
CTI
1
TAMC CUD
int main(){
Software Chip FPGA
Breakpoint
}
 
▲圖三十九 Software to Hardware Cross Trigger 
如圖四十，當系統整合者設定的硬體中斷點發生時，TAM Controller 會控制待除錯電路
進入除錯狀態，此時會透過 CTI 對系統上所有的嵌入式核心發出除錯要求，經過 ARM 
CoreSight 將此請求傳送至系統上所有的嵌入式核心；當系統上所有的嵌入式處理器接受到
此訊號後，就會將執行中的驗證程式暫停並進入除錯狀態，等待 TAM Controller 將除錯流程
執行結束。 
 
▲圖四十 Hardware to Software to Cross Trigger 
 50
心系統為基礎，藉由建構其與 GDB 溝通方法，發展並建置出多核心相互中斷機制，成功地
將系統擴充為多核心模擬平台。在多核心程式開發的過程當中，會遭遇到許多的問題，而本
計畫目標之一就是有效處理資料競爭(data race)的問題。在我們完成的平台當中，加入了開
發的 RaceWeir 機制，能將可能潛在 data race 的情形找出，讓程式設計者能夠用以除錯，圖
四十一為本平台之系統架構圖，其方法簡述如下： 
 建立多核心硬體相互中斷機制： 
因為 GDB 的設計原先就是以單核心為考量，所以其對應的 GDB Stub 也都只對單核心
設計。在我們多核心的系統架構下，需要讓各個 GDB Stub 之間能夠相互溝通與中斷，因此
我們參考 ARM CoreSight 標準中的 Embedded Cross Trigger 方法，將各核心的 GDB Stub 連
接起來，讓彼此之間能互相溝通除錯。依據 ARM 的標準，這只是一套溝通的界面，並沒有
限制其傳輸的內容，因此我們利用這樣的界面來連接 GDB Stub。由於其設計之主要用意在
於處理 RTL 層級電路相互之間的溝通，所以我們在 ESL 層級當中就以模擬其動作與時序特
性為主。 
 
▲圖四十一 RaceWeir System 
 
 Data race real time detection 且支援 GDB 除錯機制，加速找出 data race 原因： 
本計畫對於資料競爭的問題開發了名為 RaceWeir 的系統，用來偵測當下任一核心的資
料存取是否造成資料競爭發生。我們利用 Cache 新增內容與多核心之間的 Cache coherency
 52
得到之 DNL 與 INL，可以發現其具有高度的一致性。本研究之相關研究成果已被 IEEE 
Transactions on VLSI Systems 所接受(尚未刊出)。 
Stop
Start
Detect 
Transition Codes
Estimate
ADC Offset 
Test 
Transition Codes
Fill results in 
Un-selected 
Transition Codes 
Calculate
INL/DNL
Identify if out 
of range occurs
Step 1
Step 2
Step 3
Step 4
Step 5
Identify if missing
codes appear
 
SHA
Stage
1
Stage
2
Stage
3
Stage
4
Stage
5
Stage
6
Stage
7
Stage
8
Stage
9
Stage
10
last
DEC
 
▲圖四十二 所提出之 pipelined ADC 錯誤
診斷流程圖。 
▲圖四十三  驗證提出之錯誤診斷技術的
12-bit 20 MS/s pipelined ADC 晶片照相圖 (in 
0.35 m) 
 
500 1000 1500 2000 2500 3000 3500 4000-0.5
0
0.5
LS
B
 @
 1
2-
b 
le
ve
l
500 1000 1500 2000 2500 3000 3500 4000-0.5
0
0.5
LS
B 
@
 1
2-
b 
le
ve
l
DNL from Histogram Based Method (- 0.37 LSB< DNL < 0.37 LSB)
DNL from Transition Code Based Method (-0.22 LSB< DNL < 0.22 LSB)
Digital Code
Digital Code    
500 1000 1500 2000 2500 3000 3500 4000-1
-0.5
0
0.5
1
LS
B
 @
 1
2-
b 
le
ve
l
500 1000 1500 2000 2500 3000 3500 4000-1
-0.5
0
0.5
1
LS
B
 @
 1
2-
b 
le
ve
l
INL from Histogram Based Method (- 0.67 LSB< INL < 0.61 LSB)
INL from Transition Code Based Method (-0.53 LSB< INL < 0.79 LSB)
Digital Code
Digital Code  
▲圖四十四 所提出之轉態碼測試方法與傳統利用 Histogram 的測試方式所量測得到之(a) 
Measured DNL results (b) Measured INL results  
 
 快閃式類比至數位轉換器之位元錯誤率內建自我測試技術 
有關類比至數位轉換器的動態參數和靜態參數測試相關之研究相當多，但在位元錯誤率
(Bit-Error-Rate, BER)測試的研究論文極少。雖然在類比數位轉換器的測試上，BER 的測試是
非必要的，但對於整合在通訊系統上的類比數位轉換器而言，卻是很重要的測試參數。然而，
BER 的測試時間相對於其他測試參數而言是極為耗時的。因此，本研究發展出快速且低成
 54
 56
六、參考文獻 
[1] Maier, K.D., “On-chip Debug Support for Embedded Systems-on-Chip,” in Proceedings of 
IEEE International Symposium on Circuits and Systems, vol. 5, 2003, pp. V-565 - V-568. 
[2] Ing-Jer Huang, Chung-Fu Kao, Hsin-Ming Chen, Chin-Nan Juan, and Tai-An Lu, “A 
Retargetable Embedded In-Circuit Emulation Module for Microprocessors,” IEEE Design & 
Test of Computers, PP.28-38, 2002. 
[3] Ing-Jer Huang and Tai-An Lu, “ICEBERG: An Embedded In-circuit Emulator Synthesizer for 
Microcontrollers,” Design Automation Conference, PP.580-585, 1999. 
[4] Ing-Jer Huang and Chung-Fu Kao, “Exploration of Multiple ICE’s for Embedded 
Microprocessor Cores in An SOC Chip,” Asia Pacific Conference on ASICs, PP.229-234, 2000. 
[5] Ing-Jer Huang, Hsin-Ming Chen and Chung-Fu Kao, “Reusable Embedded In-Circuit 
Emulator,” Asia and South Pacific Design Automation Conference, PP.33-34, 2001. 
[6] H. Ming-Chang and H. Chih-Tsun, "An embedded infrastructure of debug and trace interface 
for the DSP platform,"  Design Automation Conference, pp. 866-871, 2008. 
[7] Neal Stollon, Rick Leatherman, Bruce Ableidinger and Ernie Edgar, “Multi-Core Embedded 
Debug for Structured ASIC Systems,” DesignCon, First Silicon Solutions, 2004. 
[8] Neal Stollon, “On-Chip Instrumentation and In-Silicon Debug Tools for SoC,” HDL Dynamics, 
2007. 
[9] K.-J. Lee, C.-Y. Chu and Y.-T. Hong, “An embedded processor based SOC test platform,” 
ISCAS, pp.2983 - 2986, 2005. 
[10] K.J. Lee, Tong-Yu Hsieh, Ching-Yao Chang, “On-Chip SOC Test Platform Design Based on 
IEEE 1500 Standard,” IEEE Transactions on Very Large Scale Integration Systems, 2009, 
accepted. 
[11] Shan Tang and Qiang Xu, “A Multi-Core Debug Platform for NoC-Based Systems,” Design, 
Automation and Test in Europe Conference and Exhibition, pp.1-6, 2007. 
[12] Shan Tang and Qiang Xu. “In-band Cross-Trigger Event Transmission for Transaction-Based 
Debug,” Design, Automation and Test in Europe, pp.414- 419, 2008. 
[13] Y. Hyunbean, P. Sungju and Kundu, S. "A Design-for-Debug (DfD) for NoC-Based SoC 
Debugging via NoC," Asian Test Symposium, pp.289-294, 2008. 
[14] B. Vermeulen, K. Goossens, R. V. Steeden, and M. Bennebroek, “Communication-centric SOC 
debug using transactions,” European Test Symposium, pp.69-76, 2007. 
[15] B. Vermeulen, K. Goossens and S. Umrani, "Debugging Distributed-Shared-Memory 
Communication at Multiple Granularities in Networks on Chip," Networks-on-Chip, pp. 3-12, 
2008. 
[16] K. Goossens, B. Vermeulen, and A. B. Nejad, “A High-Level Debug Environment for 
Communication-Centric Debug,” Design, Automation, and Test in Europe, pp.202-207, 2009 
[17] B. Vermeulen and K. Goossens, "A Network-on-Chip monitoring infrastructure for 
communication-centric debug of embedded multi-processor SoCs," VLSI Design, Automation 
 58
Cote, “IEEE P1687: Toward Standardized Access of Embedded Instrumentation,” International 
Test Conference, pp.1-8, 2006. 
[35] J. Rearick, B. Eklow, K. Posse, A. Crouch and B. Bennetts, “IJTAG (Internal JTAG): A Step 
Toward a DFT Standard,” International Test Conference, pp.807-815, 2005. 
[36] K.D. Maier, “On-Chip Debug Support for Embedded Systems-on-Chip,” International 
Symposium on Circuits and Systems, pp.565-568, 2003. 
[37] X. Gu, W. Wang, K. Li, H. Kim and S. S. Chung “Re-Using DFT Logic for Functional and 
Silicon Debugging Test,” International Test Conference, pp.648-656, 2002. 
[38] N. Dakwala, “Silicon Debug and DFT for SOC IP,” International SOC Conference, pp.327-328, 
2006. 
[39] H. Hao and R. Avra, “Structured Design-for-Debug – the SuperSPARCTM II Methodology and 
Implementation,” International Test Conference, pp.175-183, 1995. 
[40] J.Gilmore and S. Shebs, “GDB Internals-A Guide to the Internals of the GNU Debugger,” 
Cygnus Solutions, February 2004. 
[41] R. Stallman, R. Pesch, S. Shebs, et al., “Debugging with GDB-The GNU Source-Level 
Debugger 9th Edition”, Cygnus Solutions, February 2004. 
[42] F. Bellard, “QEMU, a Fast and Portable Dynamic Translator,” Proceeding of the 2005 USENIX 
Annual Technical Conference, Anaheim, CA, USA, April 2005. 
[43] M. Monton, A. Portero, M. Moreno, B. Martinez, and J. Carrabina, “Mixed SW/SystemC SoC 
Emulation Framework.” Proceeding of the 2007 IEEE Symposium on Industrial Electronic 
(ISIE’07), pp/ 2338-2341, Vigo, Spain, June 2007. 
[44] CoreSight Architecture Sepcification, ARM Ltd., [Online]. Avaliable: http://infocenter.arm.com 
[45] Embedded Cross Trigger Technical Reference Manual, ARM Ltd., [Online]. Avaliable: 
http://infocenter.arm.com 
[46] M. Xu, R. Bodik, and M.D. Hill, “A Flight Data Recorder for Enabling Full-system 
Multiprocessor Deterministic Replay,” in Proc. of the 30th Annual Intnl. Symp. on Computer 
Architecture, p. 122-133, Jun. 2003. 
[47] M. Xu, R. Bodik, and M.D. Hill, “A Regulated Transitive Reduction (RTR) for Longer Memory 
Race Recording,” in Proc. of the 12th Intnl. Conf. on Architecture Support for Programming 
Languages and Operating System, p. 49-60, Oct. 2006. 
[48] S. Narayanasamy, C. Pereira, and B. Calder. “Recording Shared Memory Dependencies Using 
Strata,” In Proc. of the 12th Intnl. Conf. on Architectural Support for Programming Languages 
and Operating Systems, p. 229–240, Oct. 2006. 
[49] D. R. Hower and M D. Hill, “Rerun: Exploiting Episodes for Lightweight Memory Race 
Recording,” in Proc. of the 35th Annual International Symposium on Computer Architecture 
(ISCA), June 2008. 
[50] L. Benini and G. De Micheli, “Networks on chips: A new SOC paradigm,”  IEEE Comput., vol. 
35, no. 1, pp. 70–78, Jan. 2002. 
[51] S. Murali and G. De Micheli, “Sunmap: A tool for automatic topology  selection and 
generation for nocs,” in Proc. Design Autom. Conf., 2004. 
 60
signal generator for ADC BIST,” Journal of Electronic Testing: Theory and Applications, vol.23, 
pp.549-558, Dec. 2007. 
[69] J.-F. Lin and S.-J. Chang, “A design-for-test circuit for the reduced code based linearity test 
method in pipelined ADCs with digital error correction technique,” IEEE Asian Test 
Symposium, pp.57-62, 2009. 
[70] J.-F. Lin, T.-C. Kung and S.-J. Chang, “A reduced code linearity test method for pipelined A/D 
converters,” IEEE Asian Test Symposium, pp.111-116, 2008. 
[71] C.-H. Huang, K.-J. Lee and S.-J. Chang, “A low-cost diagnosis methodology for pipelined A/D 
converters,” IEEE Asian Test Symposium, pp.296-301, 2004. 
[72] K.-J. Lee, S.-J. Chang and R.-S. Tzeng, “A sigma-delta modulation based BIST scheme for A/D 
converters,” IEEE Asian Test Symposium, pp.124-127, 2003. 
[73] W. Kester, “Find those elusive ADC sparkle code and metastable states,” Application Note of 
Analog Devices, MT-011, pp. 1-10. 
[74] A. Charoenrook and M. Soma, “Fault diagnosis of flash ADC using DNL test,” in Proc. IEEE 
International Test Conference, Oct., 1993, pp.680–689. 
[75] A. Charoenrook and M. Soma, “Fault diagnosis technique for subranging ADCs,” in Proc. IEEE 
International Test Conference, Nov., 1994, pp. 367–372. 
[76] T. Kuyel and H. Bilhanhen, “Relating linearity test results to design flaws of pipelined analog to 
digital converters,” in Proc. IEEE International Test Conference, Sept., 1999, pp. 772–779. 
[77] E. Peralias, A. Rueda, J. A. Prieto and J. L. Huertas, “DfT & on-line test of high-performance 
data converters: a practical case,” in Proc. IEEE International Test Conference, Oct., 1998, pp. 
534–540. 
 62
Test Technology Workshop, Taiwan, 2011, pp. 59-63. 
[4] A. S. Chao, S. J. Chang, and H. W. Ting, “A SAR ADC BIST for simplified linearity test,” in 
Proc. IEEE Int. SOC Conf., Taiwan, 2011, pp. 146-149. 
 
投稿審查中/準備中： 
[5] W. C. Lien, K. J. Lee, T. Y. Hsieh, and K. Chakrabarty, “Counter-based output selection for test 
response compaction,” in preparation for submission. 
[6] T. Y. Jiang, C. C. Li, and C. H. Chen, “Race Weir: a multi-core virtual platform with 
hardware-assisted data race detection,” submitted to DAC 2012. 
 2
 Gadi Singer, (Vice President of the Intel Architecture Group and General Manager, SOC Enabling 
Group for Intel Corporation) on “The Imminent EDA Transformation” 
 Dharmendra S. Modha, (Founding Manager of the Cognitive Computing group at IBM's Almaden 
Research Center) on “Cognitive Computing: Neuroscience, Supercomputing, Nanotechnology” 
 後三個主題比較接近技術性的演講，由於演講者的經歷豐富，演講內容在技術廣度與深度皆有一
定的水準。如果要把這三場演講找出其共通的部分，我個人的體會是未來的電子系統極為複雜且龐大，
要在合理的時間開發出如此龐大的系統，EDA 扮演著重要的角色， Freescale VP 在演講中以 4 個產品
(Embedded System)做為 case studies 來說明 EDA 的角色是所有演講中較為具體的。在第二天的 Keynote
演講之前舉行頒獎，今年與學生以“A 0.9-V 11-bit 25-MS/s 0.58-mW Binary-Search SAR ADC in 90-nm 
CMOS”作品參賽，獲得 DAC/ISSCC Student Design Contest 2011 Winner，很榮幸代表上台領獎。 
 
三、 心得與建議 
由這次論文與展示來看，System level 分析與設計輔助工具的開發是目前熱門的研究方向之一，
討論的議題相當多樣性，相關技術的發展非常的快。如何在眾多的研究當中脫穎而出，的確需要下工
夫多研究、多思考。 
DAC 是全球著名的研討會，參與這次的會議遇到了不少來自世界各地的朋友，有的是以前就認
識的，也有一些是拜讀過許多文章但初次見面的。今年許多來自台灣學界的師生與業界的先進也一起
參與本會議，除了發表論文之外，也有參展發表 EDA 工具的，在許多在知名的國際 EDA 廠商中，我
們台灣的廠商兆心科技(清華大學黃錫瑜教授帶領)有不錯的表現，在全球 EDA 產業的盛會中讓台灣不
缺席，相當值得肯定。建議國家應持續在 EDA 業界的輔導投注心力，讓台灣除了半導體代工之外，
EDA 產業亦能在全球佔有重要的一席之地。 
 
四、攜回資料名稱及內容： 
 大會所提供之論文集光碟。 
 
國科會補助專題研究計畫項下出席國際學術會議心得報告 
 
計畫編號 NSC 99-2220-E-006-027 
計畫名稱 SoC 晶片系統除錯平台之開發與研究 
出國人員
姓名 張順志 
服務機構
及職稱 成功大學電機系/副教授 
會議時間 2011/7/15 會議地點 Seoul, Korea (韓國首爾) 
會議名稱 
(中文) 亞洲固態電路研討會議程委員會論文選取會議 
(英文) Asia Solid-State Circuits Conference (A-SSCC) Technical Program 
Committee (TPC) Paper Selection Meeting 
 
一、議程： 
 
 4
國科會補助專題研究計畫項下出席國際學術會議心得報告 
                                    日期： 100 年 6 月 17 日 
計畫編號 NSC 99-2220-E-006-027 
計畫名稱 SoC 晶片系統除錯平台之開發與研究 
出國人員
姓名 林城伍 
服務機構
及職稱 
國立成功大學電機工程學系(所) 
博士班研究生 
會議時間 100 年 6 月 5 日至 100 年 6 月 9 日 會議地點 聖地牙哥(美國) 
會議名稱 
(中文) 設計自動化會議 
(英文) Design Automation Conference (DAC) 
發表論文
題目 
(中文) 考量系統性與隨機性不匹配並應用於類比積體電路之共質心
電容擺置方法 
(英文) Common-Centroid Capacitor Placement Considering Systematic 
and Random Mismatches in Analog Integrated Circuits 
一、參加會議經過： 
DAC 是電子設計自動化(Electronic Design Automation, EDA)領域之全球最大型研討會，它最大
的一項特色就是同時舉辦盛大的展覽會，很多 EDA vendor 都會在展覽會中展示他們的產品，其中包
括了許多世界知名的大廠，例如：TSMC、Cadence、Synopsys、SpringSoft、Mentor Graphics、Apache
等等，與會者可以透過廠商的展示來得到最新的產品訊息與解決方案。今年的 DAC 總共有 54 個
technical session，我的報告場次是在 6/8 下午 14:00 的 Session 29: Clocks and Circuits，總共有四篇論
文被安排在此場次中發表，而我的論文是排在第三順位報告，除了剛開始有點緊張之外，之後整個
報告過程還算平順。而在此報告場次結束之後，緊接著進行 post session，讓其他與會者有機會跟作
者們面對面地交談並且釐清疑問。 
二、與會心得： 
此次參加 DAC 的最大心得是讓我可以觀摩到一個頂尖的會議是如何嚴謹地舉辦，從論文錄取
通知開始，主辦單位就陸陸續續和作者們往來通訊，包含了提供著作權宣告、論文最終版本修改、
報告投影片複檢等等，每一個步驟都有著嚴謹的要求。而在報告當天，也要求作者們必須和 session 
chairs 共進早餐，以便於作者們可以跟 session chairs 更進一步地相互認識，讓後續的報告流程可以
更順利地進行。而在每一場報告結束之後，主辦單位也要求作者們緊接著進行 post session，讓與會
者可以跟作者們面對面地交談，並對於論文中的所有問題都可以當場獲得解答。此次 DAC 之行，
讓我深刻地瞭解到 DAC 之所以能夠成為 EDA 領域中最著名會議的緣由，也希望往後幾年可以有機
會繼續參加此卓越的會議。此外，在會議的過程中，由於跟外國人有許多接觸的機會，不僅可以多
認識一些外國朋友，也可藉此機會訓練我們的英文會話，對於我們的英文聽說能力有很大的助益。 
 1
Dear Cheng-Wu Lin,
Congratulations! Your paper titled "Common-Centroid Capacitor Placement Considering Systematic
and Random Mismatches in Analog Integrated Circuits", paper number 122-TX272, was accepted for
the DAC 2011 Conference.
DAC strives to maintain a high quality technical program and your paper was one of only 156 papers
accepted out of 690 papers submitted. Your paper was chosen because, in the combined opinion of
the reviewers and the Technical Program Committee, it will substantially add to the content and
quality of the conference. The rest is now up to you.
By submitting a paper, you have agreed to prepare a version of your paper for the proceedings, to
have a presenter at the conference, and to provide a quality presentation.
Please login to the Accept-Reject site at the URL listed below to see your reviews, and to download
the required confirmation form and accept letter.
https://www.mpassociates.com/ml/account/login.aspx?redirectkey=21
Best regards,
Nikil Dutt and Soha Hassoun
48th DAC Technical Program Co-Chairs
array consists of four capacitors, and each capacitor is divided 
into several identical-layout-size unit capacitors, which are 
denoted by ui, i = 1, …, 4. Figure 2(a) shows a placement with a 
common-centroid structure. In this placement, the unit capacitors 
are placed symmetrically, and the centroid of each capacitor is 
exactly on or close to the center of the layout. Compared with the 
symmetric placement shown in Figure 2(a), Figure 2(b) shows a 
placement that exhibits higher random distribution (note that it is 
constructed based on [10]). Since Figure 2(a) has symmetry 
property, it is good for reducing systematic mismatch [6, 7], but is 
not sufficient to reduce random mismatch due to a lower degree 
of dispersion. On the contrary, the placement in Figure 2(b) 
exhibits a higher degree of dispersion, which is better for 
reducing random mismatch [10]. However, it lacks symmetry 
property to overcome the mismatch caused by process gradients. 
Therefore, in this paper, we would like to propose an 
algorithm to find a common-centroid capacitor placement, 
which possesses the property of high dispersion, to reduce 
systematic and random mismatches simultaneously. 
1.1 Previous Work 
To achieve better matching, the placement of a capacitor array 
is usually implemented by a common-centroid structure. Several 
works [6, 11-14] have studied common-centroid placement. 
Sayed and Dessouky [6] introduced an oxide gradient model to 
estimate the oxide-gradient-induced mismatch. Based on this 
model, they presented a deterministic procedure to construct a 
common-centroid placement. Later, three works used topological 
representations to tackle the placement problem with common-
centroid constraint, such as C-CBL [11], B*-trees [12], and 
sequence-pairs [13]. Recently, Lin et al. [14] proposed a thermal-
driven common-centroid placement algorithm. However, all these 
works did not consider random mismatch, and thus their common-
centroid placements lacked the property of high dispersion. 
To consider random mismatch, Luo et al. [8, 9] introduced a 
spatial correlation model for yield evaluation. They showed that a 
placement with higher correlation coefficients would have better 
matching. Moreover, they proposed a heuristic algorithm to 
obtain a placement with the highest, or near-highest, correlation 
coefficients for yield improvement [10]. Although their placement 
results exhibits a higher degree of dispersion, their placements are 
not common-centroid structure. Therefore, none of existing works 
has presented a method to construct a common-centroid 
placement with the property of high dispersion. 
1.2 Our Contributions 
Although [1] highlights that a common-centroid layout should 
exhibit the property of dispersion, there exists limited works 
discussing how to disperse sub-devices uniformly in a common-
centroid placement. Thus, in this paper, we propose an algorithm 
to construct a placement which has common-centroid structure 
and exhibits the property of high dispersion so that this placement 
can reduce systematic and random mismatches simultaneously. 
Based on the simulated annealing [15], we propose a method 
to deal with the problem of common-centroid capacitor placement 
considering systematic and random mismatches. First, we propose 
the pair-sequence representation to represent a common-centroid 
placement. Since the sub-devices in a pair can be automatically 
placed to the symmetric locations in a layout, the corresponding 
placement can easily satisfy the common-centroid constraint. 
Further, we present three operations to perturb a pair sequence, 
which can increase the degree of dispersion without breaking the 
common-centroid constraint in the resulting placement. Finally, to 
make our simulated annealing based approach more efficient, we 
propose three techniques to speed up our program. The 
experimental results show that our placements can simultaneously 
achieve smaller oxide-gradient-induced mismatch and larger 
overall correlation coefficients (i.e., higher degree of dispersion) 
than [10] in all test cases. Besides, our program can run much 
faster than [10] in larger benchmarks. Since [10] uses partially 
exhaustive search approach, they even cannot obtain result in the 
largest benchmark. 
The remainder of this paper is organized as follows. Section 2 
introduces two models for mismatch estimation. Section 3 
formulates the common-centroid placement problem for capacitor 
arrays. Section 4 describes the transformation between a pair 
sequence and its corresponding placement. Section 5 shows how 
to initialize a pair sequence for a capacitor set. Section 6 presents 
the operations to perturb a pair sequence and the techniques to 
speed up our program. Section 7 reports the experimental results. 
Finally, Section 8 concludes this paper. 
2. BACKGROUND 
The oxide gradient model [6] can be used to estimate the 
oxide-gradient-induced ratio mismatch of a capacitor array. We 
will employ the model to compare the process-gradient-induced 
mismatches of different placements. Besides, the spatial 
correlation model [8, 9] will be applied to measure the degree of 
dispersion for a placement. Due to the limit of space, we do not 
detail the two models. In the next section, we will formulate the 
capacitor placement problem based on the two models. 
3. PROBLEM FORMULATION 
Let C = {C1, C2, …, Cm} denote a set of m capacitors, and each 
capacitor Ci consist of qi unit capacitors (1 ≤ i ≤ m). The ratio of 
C1 : C2 : … : Cm is q1 : q2 : … : qm. Without loss of the generality, 
we assume qi ≤ qj if i < j, where 1 ≤ i, j ≤ m. The total number of 
unit capacitors is denoted by n (i.e., n = q1 + q2 + … + qm). 
Given a capacitor array C and an r×s matrix Ar×s, the capacitor 
placement problem is to assign each unit capacitor of C to a 
unique entry of the matrix, where n = r×s. The objective is to 
minimize the oxide-gradient-induced mismatch and maximize 
the overall correlation coefficients, simultaneously. 
4. PAIR-SEQUENCE REPRESENTATION 
In this section, we first introduce a representation to represent 
the placement of elements in a matrix. Then, we show how to map 
each element in the representation to a unique entry in the matrix. 
4.1 From a Matrix to its Pair Sequence 
In this subsection, we first propose the pair-sequence Pr×s 
representation to denote the placement of n elements in an r×s 
matrix Ar×s. The pair sequence Pr×s = [p1, p2, …, pm] is an array of 
m elements, and each element pi in Pr×s denotes a pair of 
symmetric entries in Ar×s except the first element p1, where m = ⎣(n+1)/2⎦ and n = r×s. If n is even, the first element p1 still 
denotes a pair of entries in the matrix; however, it denotes only 
one entry in the matrix if n is odd. The subscript r×s of the 
representation indicates the dimension of the matrix mapped by 
the representation. Because the placement of elements may have 
various styles, it is necessary to distinguish those pair sequences 
having the same number of elements but mapping to matrices 
with different dimensions. For example, although the sizes of 
matrices A2×6, A6×2, A3×4, and A4×3 are identical, the dimensions of 
the four matrices are different. To reveal correct information, we 
append a subscript r×s to each pair sequence to denote the 
dimension of the corresponding matrix. 
529
29.3
these capacitors, if we pick one unit capacitor from it, the number 
of its remaining unit capacitors becomes even and they can be 
paired. Then, for the picked unit capacitors (i.e., there exists 
k+l unit capacitors), we can pair them according to the following 
cases: 
z Case 1. k and l are both odd: we pick one unit capacitor 
from k unit capacitors and from l unit capacitors, 
respectively, and consider the two selected unit capacitors 
as a pair. Thus, the remaining unit capacitors can form 
(k-1)/2 and (l-1)/2 pairs. 
z Case 2. k is odd and l is even: we select one unit 
capacitor from k unit capacitors and treat it as a single-
unit pair (i.e., a pair only containing one unit capacitor). 
Thus, the remaining capacitors would form (k-1)/2 and l/2 
pairs. 
z Case 3. k is even and l is odd: if k ≠ 0, we pick one unit 
capacitor from k unit capacitors and consider it as a 
single-unit pair, and thus the remaining unit capacitors 
can be handled by Case 1; if k = 0, we select one unit 
capacitor from l unit capacitors and treat it as a single-
unit pair, and the remaining unit capacitors can form 
(l-1)/2 pairs. 
z Case 4. k and l are both even: the k unit capacitors form 
k/2 pairs, and the l unit capacitors form l/2 pairs. 
After the k+l unit capacitors are paired, we can classify them 
into four types in the following: 
z S(unique, ): it consists of pairs that each pair has only one 
unit capacitor. 
z S(unit, unit): the two unit capacitors come from different 
capacitors in Cunit. 
z S(unit, odd): one of the two unit capacitors belongs to a 
capacitor in Cunit, and the other belongs to a capacitor in 
Codd. 
z S(odd, odd): the two unit capacitors belong to different 
capacitors in Codd. 
After above procedure, the number of the remaining unit 
capacitors in each capacitor becomes even, and thus we can pair 
them completely. These unit-capacitor pairs are classified into the 
following type: 
z S’: the two unit capacitors in a pair belong to the same 
capacitor (comparing to the sets listed in the above). 
Figure 5(a) shows a capacitor set {C1, C2, C3, C4, C5, C6, C7, 
C8}, and the ratio of these capacitors is 1 : 1 : 1 : 1 : 3 : 5 : 6 : 7. 
According to above definition, Cunit = {C1, C2, C3, C4} and Codd = 
{C5, C6, C8}. We first pick one unit capacitor from each of these 
capacitors and try to pair them (i.e., u1, u2, u3, u4, u5, u6, and u8 are 
selected). Since k = 4 and l = 3, it satisfies Case 3. Assume u1 is 
selected from the first four unit capacitors u1, u2, u3, and u4, and it 
is considered as a single-unit pair (i.e., (u1, ) ∈ S(unique, )). Then, the 
remaining three unit capacitors u2, u3, and u4 and the last three 
unit capacitors u5, u6, and u8 are handled according to Case 1. 
Thus, from each of the two groups, we select one unit capacitor 
from it, and consider the two selected unit capacitors as a pair 
(assume (u4, u5) ∈ S(unit, odd) is selected). Finally, the remaining 
capacitors u2, u3, u6, and u8 are paired, which form (u2, u3) ∈ S(unit, 
unit) and (u6, u8) ∈ S(odd, odd). After the above process, the remaining 
unit capacitors in each capacitor are paired, respectively, and they 
are classified into the type S’. 
5.2 Pair Arrangement 
After all unit capacitors in a capacitor set are paired, we can 
arrange these pairs to obtain a pair sequence, and then derive an 
initial matrix placement from it. To obtain a better matrix 
placement, we have to determine a sequence to place these pairs 
into a pair sequence. 
Before we give our procedure, we first analyze the property of 
different kind of capacitors. If a capacitor belongs to Cunit, it is 
better to be placed near to the center of a matrix such that its 
centroid can be close to the matrix's center. If a capacitor belongs 
to Codd, one of its unit capacitors would form a single unit 
capacitor and others form several unit-capacitor pairs. Since each 
unit-capacitor pair can be automatically placed to the symmetric 
locations in the matrix, the capacitor's centroid can be located 
close to the center of the matrix if the single unit capacitor is also 
placed near to the matrix's center. Finally, if a capacitor comprises 
an even number of unit capacitors, its unit capacitors can be 
paired completely. Therefore, its centroid must be exactly at the 
center of the matrix. 
Through the above analysis, some unit capacitors should be 
placed closer to the matrix's center than others in order to get a 
common-centroid placement. If a pair can be arranged near to the 
head of a pair sequence, the placement of the associated unit 
capacitors would be close to the matrix's center; otherwise, its 
placement is far from the matrix's center. Therefore, we give the 
priorities of different pair types in the following: 
z S(unique, ) > S(unit, unit) > S(unit, odd) > S(odd, odd) > S’ 
S(unique, ) > S(unit, unit) means S(unique, ) has a higher priority than S(unit, 
unit), and so on. A pair belonging to a pair type with higher priority 
will be arranged more near to the head of a pair sequence. 
5.3 Algorithm for Pair-Sequence Initialization 
In this subsection, we give the complete procedure for 
initializing a pair sequence (please see Algorithm 1). We first pair 
unit capacitors and divide them into different types (see Line 1). 
Then, we serially place all pairs into a pair sequence according to 
the priorities of the pair types. Since the pairs with the same pair 
type have identical priority, we arrange them into a pair sequence 
according to a deterministic order (see Lines 3-7). 
u8
u5
u4
u6
u7
u6
u3
u1
u2
u6
u8u7u8
u7u8u7
u6u5u6
u7u5u7
u8u8u8
Pair ∈ S(unique, )
Unit capacitor ui
Pair ∈ S(unit, unit)
Pair ∈ S(unit, odd)
Pair ∈ S(odd, odd)
Pair ∈ S’
1 1 1 1 3 5 6 7
C1 C2 C3 C4 C5 C6 C7 C8
qi
                       (a)                                                (b) 
Figure 5. (a) An example of unit-capacitor pairing. (b) The 
corresponding placement in a matrix A5×5. 
Algorithm 1: initializePairSequence(Capacitor array, Matrix size)
/* All unit capacitors are paired and classified into five pair types; */
1: Unit-capacitor pairing for the capacitor array; 
2: Allocate an empty pair sequence; 
3: for highest-priority pair type to lowest-priority pair type do 
4: for all unit-capacitor pairs belonging to the pair type do 
5: Add the pair that has a unit capacitor ui with the smallest index i 
to the end of the pair sequence; 
6: end for 
7: end for 
8: Append the matrix size to the pair sequence; 
 
531
29.3
in the smaller benchmarks, we can run much fast than [10] in the 
larger benchmarks. Since [10] partially exhaustively searches 
possible combinations and computes the correlation coefficients 
for each combination to obtain the best one, their computational 
time increases significantly while the number of the available 
entries increases. On the contrary, we use SA to enhance our 
results and propose several techniques to speed up SA. That’s 
why we can get better results and run much faster than [10]. 
Figure 7(b) shows our placement result for SCF_3. Compared 
with the placement result shown in Figure 2(b) (note that it is 
constructed based on [10]), our placement has comparable overall 
correlation coefficients (i.e., similarly high degree of dispersion), 
but the symmetry property is better (i.e., common-centroid 
structure). Figure 8 compares three different placements for 
SCF_3. As shown in the figure, since the placement based on [10] 
is not common-centroid structure, it has largest oxide-gradient-
induced mismatch. Although both placements in Figure 2(a) and 
ours are common-centroid structure, we still get smaller oxide-
gradient-induced mismatch because the common-centroid 
placement is enhanced by our SA based approach. 
8. CONCLUSIONS 
We have presented an SA based approach to implement a 
common-centroid placement with the property of high dispersion 
in order to reduce systematic and random mismatches. Besides, 
we have proposed a pair-sequence representation to represent a 
common-centroid placement, and presented the associated 
perturbations to increase the degree of dispersion without 
breaking the common-centroid constraint in the resulting 
placement. The experimental results have shown that our 
common-centroid placement approach is effective to reduce 
capacitor mismatch. 
9. ACKNOWLEDGEMENTS 
This work was supported in part by National Science Council 
of Taiwan under Grant No’s NSC-99-2220-E-006-019 and NSC-
98-2221-E-006-156-MY3. 
10. REFERENCES 
[1] A. Hastings, The Art of Analog Layout, 2nd Ed., Prentice Hall, 2006. 
[2] D. A. Johns and K. Martin, Analog Integrated Circuit Design, Wiley, 1997. 
[3] M. J. McNutt, S. LeMarquis, and J. L. Dunkley, “Systematic capacitance 
matching errors and corrective layout procedures,” IEEE JSSC, vol. 29, no. 5, 
pp. 611-616, May. 1994. 
[4] J.-B. Shyu, G. C. Temes, and F. Krummenacher, “Random error effects in 
matched MOS capacitors and current sources,” IEEE JSSC, vol. 19, no. 6, pp. 
948-956, Dec. 1984. 
[5] E. Felt, A. Narayan, and A. Sangiovanni-Vincentelli, “Measurement and 
modeling of MOS transistor current mismatch in analog IC’s,” Proc. ICCAD, 
1994, pp. 272-277. 
[6] D. Sayed and M. Dessouky, “Automatic generation of common-centroid 
capacitor arrays with arbitrary capacitor ratio,” Proc. DATE, 2002, pp. 576-
580. 
[7] D. Khalil, M. Dessouky, V. Bourguet, M.-M. Louerat, A. Cathelin, and H. 
Ragai, “Evaluation of capacitor ratios in automated accurate common-centroid 
capacitor arrays,” Proc. ISQED, 2005, pp. 143-147. 
[8] P.-W. Luo, J.-E Chen, C.-L. Wey, L.-C. Cheng, J.-J. Chen, and W.-C. Wu, 
“Impact of capacitance correlation on yield enhancement of mixed-
signal/analog integrated circuits,” IEEE TCAD, vol. 27, no. 11, pp. 2097-2101, 
Nov. 2008. 
[9] J.-E Chen, P.-W. Luo, and C.-L. Wey, “Yield evaluation of analog placement 
with arbitrary capacitor ratio,” Proc. ISQED, 2009, pp. 179-184. 
[10] J.-E Chen, P.-W. Luo, and C.-L. Wey, “Placement optimization for yield 
improvement of switched-capacitor analog integrated circuits,” IEEE TCAD, 
vol. 29, no. 2, pp. 313-318, Feb. 2010. 
[11] Q. Ma, E. F. Y. Young, and K. P. Pun, “Analog placement with common 
centroid constraints,” Proc. ICCAD, 2007, pp. 579-585. 
[12] M. Strasser, M. Eick, H. Graeb, U. Schlichtmann, and F. M. Johannes, 
“Deterministic analog circuit placement using hierarchically bounded 
enumeration and enhanced shape functions,” Proc. ICCAD, 2008, pp. 306-313. 
[13] L. Xiao and E. F. Y. Young, “Analog placement with common centroid and 1-
D symmetry sonstraints,” Proc. ASPDAC, 2009, pp. 353-360. 
[14] P.-H. Lin, H. Zhang, M. D. F. Wong, and Y.-W. Chang, “Thermal-driven 
analog placement considering device matching,” Proc. DAC, 2009, pp. 593-
598. 
[15] S. Kirkpatrick, C. D. Gelatt, and M. P. Vecchi, “Optimization by simulated 
annealing,” Science, vol. 220, no. 4598, pp. 671-680, May 1983.  
Table 1. Comparisons of oxide-gradient-induced mismatches, overall correlation coefficients, and running time for the heuristic algorithm [10] and 
our work. (M: oxide-gradient-induced mismatch; L: overall correlation coefficients) 
Heuristic Algorithm [10] Our Work Array Name # of Cap. Capacitance Ratio # of Unit Cap.
Matrix 
Size Max. M (%) L Time (s) Max. M (%) L Time (s)
SCF_1 5 2 : 6 : 7 : 7 : 8 30 6 × 5 0.138 9.651 1 0.109 9.688 3 
SCF_2 5 1 : 2 : 2 : 10 : 17 32 8 × 4 0.679 9.318 1 0.601 9.343 4 
SCF_3 4 1 : 2 : 16 : 45 64 8 × 8 0.650 5.567 2* 0.546 5.571 8 
SAR_8bit 9 1 : 1 : 2 : 4 : 8 : 16 : 32 : 64 : 128 256 16 × 16 0.800 32.074 602 0.720 32.089 188 
SAR_9bit 10 1 : 1 : 2 : 4 : 8 : 16 : 32 : 64 : 128 : 256 512 32 × 16 1.077 38.072 20503 0.979 38.306 591 
SAR_10bit 11 1 : 1 : 2 : 4 : 8 : 16 : 32 : 64 : 128 : 256 : 512 1024 32 × 32 - - -** 1.155 45.400 3706 
*This running time reported in [10] is 46.9 s, but the same algorithm implemented by us takes 2 s. It may be caused from the difference in programming and running platform. 
**No result is reported because the running time is too long. 
u4
u4
u3
u2
u3
u4
u4
u4
u3
u4
u4
u3
u4
u3
u4
u4
u4
u4
u3
u1
u3
u4
u4
u3
u4u4u3u4u4
u4u4u2u3u4
u4u3u3u4u4
u3u4u4u4u4
u4u4u4u4u4
u4
u4
u4
u4
u4
u4
u3u4u4
u4u4u3
u4u4u3
ui ui
ui ui
9.1 µm25 µm
25 µm
2.6 µm
 
                         (a)                                               (b) 
Figure 7. (a) Experiment setup for the geometry of unit capacitors. 
(b) Our placement result for SCF_3. 
5.5380.603Fig. 2(a)
5.5710.546Fig. 7(b)
5.5670.650Fig. 2(b)
LMax. M (%)
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0 30 60 90 120 150 180
Angle (degrees)
M
is
m
at
ch
 (%
)
M : oxide-gradient-induced mismatch
L : overall correlation coefficients
Fig. 2(b) [10]
Fig. 2(a)
Fig. 7(b) (our work)
M
is
m
at
ch
 (%
)
Figure 8. The oxide-gradient-induced mismatches and overall 
correlation coefficients of three different placements for SCF_3. 
533
29.3
 2
三、建議 
本國際合作研究提供指導教授時間為一週，相較於學生所獲得的一個月時間起來較為不
足。只能就研究方向與可行方法與合作教授進行交流與討論。如果國科會經費許可，希望能提
供指導教授較長時間的補助，讓研究計畫能夠更加的完善。 
 
四、其他 
 
 
 2
二、研究成果 
這次與 Duke University 的學術合作中，和 Chakrabarty 教授在 SOC 晶片測試與除錯之議題有
相當多的討論，亦有許多成果，目前正在撰寫相關之論文，以投稿國際期刊。 
三、建議 
基於這次學生到 Duke University 所進行的學術合作參訪，提供下列數項建議，以供日後其他
同學參考： 
1. 一般而言，國際知名的研究學者都非常忙碌，在學術參訪的過程中，無法撥太多時間討論，
因此建議日後有機會參加國際學術合作的同學，在每次討論前都要做好充分的準備，包括
欲討論的議題、想提問的問題、甚至是初步的實驗結果，才能進行有效率的討論。 
2. 英文對絕大部分的台灣學生而言都不是母語，但英文的重要性是不容置疑的，因此還是要
勤練英文，加強與人溝通的能力。以這次杜克大學的參訪來說，除了與 Chakrabarty 教授的
討論之外，我也和其研究室的學生進行了一些討論交流，感受他們的研究風氣，並參觀
Duke University 的校區，收穫非常豐富。 
3. 許多美國大學在學術研究以外，都有各自的特色。以 Duke University 為例，其籃球隊為
NCAA 相當有競爭力的隊伍，因此我也去參觀了他們的室內籃球場以及他們的籃球隊歷史
博物館，經驗相當難得。 
四、其他 
以下提供數張至 Duke University 參訪的照片，以供參考。 
國科會補助專題研究計畫項下國際合作研究計畫國外研究報告 
                                   日期： 100 年 7 月 12 日 
計畫編號 NSC 99-2220-E-006-027 
計畫名稱 SoC 晶片系統除錯平台之開發與研究 
出國人員
姓名 連唯証 
服務機構
及職稱 國立成功大學 
合作國家 美國 合作機構 Duke University (美國杜克大學) 
出國時間 100 年 5 月 31 日至100 年 6 月 30 日 出國地點 Durham, North Carolina, USA 
一、國際合作研究過程 
  2011 年 5 月 30，我們搭機自高雄小港國際機場前往美國，並於美國時間 5 月 31 日前往杜克
大學拜訪 Prof. Krishnendu Chakrabarty 並開始進行雙邊合作研究，與其團隊共同商討 Multi-Core 
Platform 系統下進行 Silicon Debugging 之相關研究題目以及合作事宜。由於 Prof. Chakrabarty 教授
與其團隊亦於多核心 SOC系統測試與除錯領域有多年且深入的研究(已發表超過 200篇以上的期刊
與會議論文)，因此當天下午討論過後，決定結合成功大學團隊先前開發之 SoC 晶片系統除錯平台
與杜克大學團隊之 SoC 晶片系統測試經驗，合作開發一「應用於 SoC 晶片系統除錯平台之輸出響
應壓縮技術」。其目標在於降低除錯所需的 on-chip 或 off-chip 記憶體空間，藉此減低除錯所帶來的
額外成本，預期在整合該技術至成功大學團隊所開發之 SOC 測試除錯平台後，能夠有效提升該平
台的測試除錯能力。 
  由於我們的訪問行程僅有一個月的時間，為更有效率的達到此一研究目標，我們亦與 Prof. 
Chakrabarty 討論並制訂這一個月的進度計畫表，如下： 
 
日期 工作內容 
100/6/01(三) ~ 
100/6/05(日) 
了解Prof. Chakrabarty團隊的multi-core SOC系統測試
技術與最新研究成果 
100/6/06(一) ~ 
100/6/09(四) 
與其團隊討論演算法與硬體整合之細節並整合所需的
multi-core platform 系統除錯功能 
100/6/10(五) Meeting (和 Prof. Chakrabarty 討論進度) 
100/6/11(六) ~ 
100/6/22(三) 壓縮技術開發 
100/6/23(四) Meeting (和 Prof. Chakrabarty 討論進度) 
100/6/24(五) ~ 
100/6/29(三) 
整合壓縮技術至除錯平台硬體進行系統功能性模擬與
multi-core 系統除錯功能驗証 
100/6/30(四) 返回台灣 
 
 
 1
  3
 2
本計畫在關於多核心系統軟體發展與除錯平台的開發設計部份，其研究成果分為兩個部份：
RaceWeir 系統的開發、使用自我測試機制進行 CPU 開發驗證。 
RaceWeir 系統是用來偵測當下任一核心的資料存取是否造成資料競爭發生。我們利用 Cache 新增
內容與多核心之間的 Cache coherency 協定，來記錄各核心對於資料的存取情形。因為多核心程式撰寫
之時一定會對於共用資料進行保護的鎖定動作(Critical Section Lock)，所以我們的 Cache 就額外新增記
錄 Lock 狀態的內容，並且利用其狀態來判定資料使用情形。我們為了減少 Cache 面積與 L2 Cache 的
問題，我們採用 MOESIF 的協定，總共減少 29.4%的面積使用，關於 RaceWeir 的主要內容正在撰寫論
文當中。 
使用自我測試機制進行 CPU 開發驗證的部份，我們對於處理器在作業系統使用當中的 code 
coverage 數據進行了分析，確定其不足以認可為完整驗證處理器架構設計，其所得數據均不足 80%。
而我們所使用的軟體式自我測試機制在 code coverage 數據與 stuck-at fault coverage 表現有 100%與 98%
以上的成果，其相關之內容亦正在撰寫論文當中。 
 
三、建議 
本國際合作研究的時間為一個月，其時間對於單項議題尚可進行較深入的討論。希望國科會之後
對於更多的研究計畫都能有這樣的補助，讓更多的研究生能夠與國外知名研究學者有交流互動，除了
加強研究能力之外也能更加開擴其視野。 
 
四、其他 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
99 年度專題研究計畫研究成果彙整表 
計畫主持人：謝明得 計畫編號：99-2220-E-006-027- 
計畫名稱：SoC 晶片系統除錯平台之開發與研究 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 1 1 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 20 20 100%  
博士生 10 10 100%  
博士後研究員 1 1 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 1 1 100% 
人次 
 
期刊論文 3 3 100%  
研究報告/技術報告 0 0 100%  
研討會論文 3 3 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
■達成目標 
□未達成目標（請說明，以 100 字為限） 
□實驗失敗 
□因故實驗中斷 
□其他原因 
說明： 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：■已發表 □未發表之文稿 □撰寫中 □無 
專利：□已獲得 □申請中 ■無 
技轉：□已技轉 □洽談中 ■無 
其他：（以 100 字為限） 
論文: 
已發表或已獲接受論文： 
(1) 國外期刊論文：3篇 (另有 2篇審查中)  
(2) 國外會議論文：4篇 (另有 2篇審查中)  
 
專利/技轉: 
本計劃開發完成系統晶片(含類比與數位電路)測試與偵錯之 total solution，不需要仰
賴昂貴之測試機台與繁瑣之測試設定，即可完成統晶片之測試與偵錯。除了此一整合計畫成
果可做為 total solution 技轉之外，其內部各個子計畫成果亦具有創新與進步性，可移轉之
潛力技術包含有： 
(1) SoC 除錯系統之相關技術。 
(2) 異質性多核心處理器系統平台。 
(3) GDB 系統以及運用 GDB 除錯多核心程式之開發模擬環境。 
(4) On-chip Flash ADC Bit-Error-Rate Built-In Self-Test 設計。 
(5) Low-cost SAR ADC Built-In Self-Test 設計。 
3. 請依學術成就、技術創新、社會影響等方面，評估研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）（以
500 字為限） 
一、學術成就(科技基礎研究) 
(一)論文 
本計劃產出之三篇重要國際期刊皆發表於 IEEE TRANSACTIONS ON VERY LARGE SCALE 
INTEGRATION (VLSI) SYSTEMS，Impact Factor (IF)為 0.907。此外，目前尚有二篇重要
成果分別投稿至 IEEE TRANSACTIONS ON COMPUTERS (IF:1.608) 與 IEEE TRANSACTIONS ON 
INSTRUMENTATION AND MEASUREMENT (IF:1.106) 兩個國外重要期刊。會議論文方面，重
