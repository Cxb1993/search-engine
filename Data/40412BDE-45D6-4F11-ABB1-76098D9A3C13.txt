2???????????????
?????????????????
??????????????????
??????????????????
?????????????????
????????ring signature????
?????chameleon signature?????
?????committed signature??
?????? Rivest ??? 2001 ?
??????????[10]??????
?????????????????
??group manager??????????
??group signature??????????
???signer ambiguity?????????
?????????????????
???????????chameleon hash
function?????????? Krawczyk
???[11]????????????
?trapdoor??????????????
??????????????????
?????????????????
????????????????
?collision??????????????
?????????????????
??(non-transferability)????????
??????(non-interactive)?????
???????(undeniable signature)??
????
???????????????
??????????????????
??????????????public
verifiable property???????????
??????????????????
???????????????
?misuse??????
??????????????
??????????????????
?????????????? fair
exchange of signatures?????????
????? Park ??? 2003 ????
[8]?????????????????
??????????????????
? ? ? ? ? ? ? ? ? ? ? ? ? ?
(optimistic/off-line fair exchange)???
??????????????????
??????????????????
?????????
???????????????
??????????????????
?????????????????
??????????????????
??????????????????
??????????forward security?
?????????????????
??????????????????
???
???????
????????????????
??????????????????
??????????????????
??????????????????
??????????????????
??????????????????
???????????????
[1] Hsi-Chung Lin, Sung-Ming Yen, and
Yi-Hsiung Huang, “Security of Huang-Wang
nominative signature scheme—revisited,” 
Proc. of the 16th Information Security
Conference (Taichung, Taiwan), pp. 85-92,
June 8-9, 2006.
[2] Yen-Chang Chen and Sung-Ming Yen,
“Balanced concurrent signature,” Proc. of
the 16th Information Security Conference
(Taichung, Taiwan), pp. 25-32, June 8-9,
2006.
[3] Jing-Shian Tsai and Sung-Ming Yen,
“Forward-secure blind signature schemes
4??????????????????
??????????????????
??????????????????
?????????? nominee ????
? ? ? ? ? ? ? ? ? ? ? ? ?
?zero-knowledge proof????????
???????
????Susilo-Mu ???????
???????????????
screening?? Huang-Wang ? nominative
signature ?????????????
??????????????????
??
3.2 ???????????
??[2]????????????
????????????????
??????????????????
???“???”???????????
?????????????????
??????????????????
?????????????????
??????????????????
??????????????????
?????????????gradual
release?????????trusted third
party?????
???????????????
??????????????????
??????????????????
??????????on-line?????
????????????????
??????????????????
??????????????????
?????????????????
?optimistic/off-line?????????
?????????????????
??????????????????
?????????????????
??????????????????
????????certificate authority??
??????????????????
???????????????
??????? Chen ??? 2004
???????????[6]??????
????????????????
??????????????????
??????????????????
??????????????????
??????????????????
??????????????????
??????????????????
??????????????????
??????????????????
???????????????
??????????????????
?[4]???????????????
??????????????????
????????signer anonymity???
?????????unlinkability???
??
??????[2]????????
????conditional signature?[9]???
??????????????????
??????????????????
?????????????????
??????????????????
??????????????????
?????????????????
1. ???????? A ??????
?? sigA????? sigA’????
B??? sigA??????????
???? sigA??? keystone???
???? sigA’?????????
????? A ?????????
2. ??? B ???????? sigB?
?????? sigA???? keystone
????? keystone ??????sigB
?????????????? B
?????????
3. ???A?? keystone, ?????
? sigA?sigB ?????
???????????????
?????? A ??????????
??? keystone? sigB????????
6??????????????????
???????????? parallel
attack???????????????
??????sequential attack?????
?????????????????
???? one-more forgery??????
????????????????
????????
???????????????
??????????????????
??????????????????
???????? nominative signature ?
??????????????????
??????????????????
?????????????????
??????????????????
??????????????????
?????????????????
??
??????
??????????
[1] His-Chung Lin, Sung-Ming Yen, and
Yi-Hsiung Huang, “Security of Huang-Wang
nominative signature scheme—revisited,” 
Proc. of the 16th Information Security
Conference (Taichung, Taiwan), pp. 85-92,
June 8-9, 2006.
[2] Yen-Chang Chen and Sung-Ming Yen,
“Balanced concurrent signature,” Proc. of
the 16th Information Security Conference
(Taichung, Taiwan), pp. 25-32, June 8-9,
2006.
[3] Jing-Shian Tsai and Sung-Ming Yen,
“Forward-secure blind signature schemes
based on integer factorization problem,” 
Proc. of the 16th Information Security
Conference (Taichung, Taiwan), pp. 77-84,
June 8-9, 2006.
????????
[4] K. Nguyen, “Asymmetric concurrent 
signature,” Proc. of Information and
Communications Security Conference,
ICICS 2005, Lecture Notes in Computer
Science, Vol. 3783, Springer-Verlag, pp.
181-193, 2005.
[5] W. Susilo and Y. Mu, “On the security of
nominative signatures,” Proc. of Information
Security and Privacy, ACISP 2005, Lecture
Notes of Computer Science, Vol. 3574,
Springer-Verlag, pp. 329-335, 2005.
[6] L. Chen, C. Kudla, and K. G. Paterson,
“Concurrent signatures,” Advances in
Cryptology—EUROCRYPT 2004, Lecture
Notes in Computer Science, Vol. 3027,
Springer Verlag, pp. 287-305, 2004.
[7] Z.J. Huang and Y.M. Wang, “Convertible 
nominative signatures,” Proc. of Information
Security and Privacy, ACISP 2004, Lecture
Notes in Computer Science, Vol. 3108,
Springer-Verlag, pp. 348-357, 2004.
[8] J. Park, E. Chong, and H. Siegel,
“Constructing fair-exchange protocol for
e-commence via distributed computation of
RSA signatures,” Proc. of the 22nd Annual
ACM Symposium on Principles of
Distributed Computing, PODC 2003, pp.
172-181, 2003.
[9] B. Lee and K. Kim, “Fair exchange of digital 
signatures using conditional signature,” Proc.
of Symposium on Cryptography and
Information Security, SCIS 2002, Vol. 1/2,
pp. 179-184, 2002
[10]R. Rivest, A. Shamir, and Y. Tauman, “How
to leak a secret,” Advances in
Cryptology—ASIACRYPT 2001, Lecture
Notes in Computer Science, Vol. 2248,
Springer-Verlag, pp. 552-565, 2001.
[11]H. Krawczyk and T. Rabin, “Chameleon 
hash and signatures,” Proc. of Network and
Distributed System Security Symposium,
NDSS 2000, pp. 143-154, Internet Society,
2000.
[12]M. Belare and S. Miner, “A forward secure 
digital signature scheme,” Advances in
Cryptology—CRYPTO ’99, Lecture Notes in
Computer Science, Vol. 1666, Springer-
Verlag, pp. 431-448, 1999.
[13] M. Bellare, J. Garay, and T. Rabin, “Fast 
batch verification for modular
exponentiation and digital signatures,” 
Advances in Cryptology-EUROCRYPT ’98,
Lecture Notes in Computer Science, Vol.
1403, Springer-Verlag, pp. 236-250, 1998.
Security of Huang-Wang Nominative Signature Scheme –
Revisited?
Hsi-Chung Lin, Sung-Ming Yen, and Yi-Hsiung Huang
Laboratory of Cryptography and Information Security (LCIS)
Department of Computer Science and Information Engineering
National Central University
Chung-Li, Taiwan 320, R.O.C.
E-mail: {hclin;yensm;cs322039}@csie.ncu.edu.tw
http://www.csie.ncu.edu.tw/~yensm/
Abstract. To prevent potential misuse and to enhance privacy, signatures without public verifia-
bility have been recently extensively discussed in the literature. Unlike traditional systems such as
undeniable signatures and designated verifier signatures, nominative signatures restrict the ability
of signature verification and confirmation to a designated verifier only. In this paper, security issues
of a nominative signature scheme proposed in ACISP 2004 by Huang and Wang are reconsidered.
The first observation is that the cryptanalyses reported recently by Susilo and Mu in ACISP 2005
are shown to be incompletely correct; namely, the nominator in fact can not verify but merely screen
signatures, and therefore any third party should not be convinced by the confirmation done by the
nominator. The second result obtained is that the scheme proposed by Huang and Wang may not
be as strong as originally claimed. Nevertheless, the result is optimistic that the security guarantees
provided by Huang-Wang nominative signature scheme are sufficient for most applications.
Keywords: Digital signatures, Interactive confirmation protocols, Nominative signatures, Privacy,
Screening, Verification.
1 Introduction
By using digital signatures, many important cryptographic services, e.g., authentication, integrity, and
non-repudiation can be provided. Furthermore, privacy is also considered in many applications, for
example both undeniable signatures [1, 2] and designated verifier signatures [3] are systems considering
privacy requirement. The main observation inspiring those research is that the public verification property
(a.k.a. self-authenticating) of traditional digital signatures jeopardizes the privacy of some participants.
In undeniable signatures, the signer can decide whether to confirm an issued signature, thus his privacy
is enhanced; meanwhile he can not deny any signature he has made, thus keep non-repudiation satisfied.
In designated verifier signatures, the signer’s privacy is improved by forcing that only those who being
designated by the signer can verify the signature.
In either undeniable or designated verifier signatures, privacy of the signer is what being concerned. In
other words, both systems simply assume that those signed messages are only critical from the signer’s
point of view. However, in many other cases, those signed messages could be extremely sensitive to
someone other than the signer, and thus should not be confirmed or verified directly without permission.
Suppose that Alice (the designated verifier, or the nominee) now applies a vacancy offered by a company
ran by Bob (a third party) with her academic record signed by the school she graduated from (the
signer, or the nominator)1. Apparently, the academic record is not sensitive to the signer (now the
school), but to the designated verifier, Alice. Concerning the privacy of Alice, the school should not
be able to authentically reveal her record. Instead, if necessary, Alice herself should prove the validity
of the record to Bob. Similar situations also exist between patients and hospitals for medical histories,
customers and banks for credit reports, and many other applications.
Please note that the designated confirmer signatures [4] (some variants of undeniable signatures) can
not satisfy the requirement of the above mentioned applications because that the signer can confirm any
signature he signed as well.
In [5], the idea of a special type of digital signatures tailored for those aforementioned applications
is introduced, namely, the nominative signatures. In addition to the basic requirement of signature
unforgeability, a nominative signature should fulfill two more requirements listed below.
? This work was supported in part by the National Science Council R.O.C. under contract NSC 94-2213-E-008-
009.
1 This example is given in [5].
85
Cryptanalysis. Two simple cryptanalyses against KPW scheme are pointed out in [6]. First, as the
nominator s is always in possession of the random number R, he can individually verify a signature
Σm = (yv, c, C, σ) by checking whether gσye
′
s c ≡ gR (mod p), where e′ = H(yv||c||C||m). Second, since
R is known to the nominator s, he can always convince any third party the validity of Σm by proving the
equality of logg δ and logyv C, where δ = g
σye
′
s c = g
R mod p can also be computed by the third party.
2.2 HW nominative signature scheme
The HW scheme [6] is also a variant of Schnorr scheme, however the signing process is now an interactive
protocol instead. The cryptographic setting is the same as the KPW scheme.
Signature generation. The signature generation is an interactive protocol between the nominator s and
the nominee v as follows.
– The nominee first sends the nominator (a = gR1 mod p, c = yR2v mod p), where R1, R2 ∈R ZZ∗q .
– The nominator chooses r ∈R ZZ∗q , then computes and sends (b, e, σ′) as
b = ag−r mod p,
e = H(yv||b||c||m),
σ′ = r − xse mod q.
– The nominee accepts (b, e, σ′) if and only if gσ
′
yesb ≡ a (mod p), for e = H(yv||b||c||m). If (b, e, σ′)
accepted, the nominee computes
σ = σ′ +R2 −R1 mod q
and the resulting signature of message m is Σm = (yv, b, c, σ).
Signature verification. Given a message-signature pair (m,Σm), the nominee v computes e = H(yv||b||c||m)
and will accept this signature if and only if
(gσyesb)
xv ≡ c (mod p).
Signature confirmation. Similar to KPW scheme, the nominee v is in possession of the secret value xv,
thus she is capable of showing the equality of the discrete logarithms
loggσyesb c ≡ logg yv (mod p)
without revealing any information about her secret xv via interactive zero-knowledge proof protocols.
Simply by replacing interactive zero-knowledge proof protocols with non-interactive ones (a.k.a. signature
of knowledge proof) [11], the nominee can convert nominative signatures into publicly verifiable ones.
3 Analysis of Susilo and Mu’s Cryptanalysis against HW Scheme
In this section, intensive discussions about HW convertible nominative signature will be given, especially
about the cryptanalysis reported by Susilo and Mu in [7]. The intrinsic characteristic of nominative
signature schemes is that the validity of a signature can not be confirmed without the assistance from
the nominee. Thus, nominative signature schemes can be considered as the dual schemes of undeniable
signature schemes in some sense.
3.1 Susilo and Mu’s cryptanalysis
In [7], Susilo and Mu argued that HW scheme does not meet the first basic requirement of nominative
signature. They claimed that in HW scheme the nominator himself can verify the validity of an issued
signature as well. They drew their conclusion from the following observations.
In HW nominative signature scheme, an issued signature Σm = (yv, b, c, σ) of message m satisfying
(gσyesb)
xv ≡ c (mod p) with e = H(yv||b||c||m) indicates its validity. It is assumed that the nominator
always keeps all intermediate parameters he has generated and collected during the interactive signing
processes. More precisely, given a message-signature pair (m,Σm), the nominator additionally possesses
the following information:
87
3.3 Screening by the nominator
It is nontrivial to notice that although the nominators can not verify signatures successfully in the
conventional signature reasoning, however they can achieve a weaker goal, namely the screening.
Screening: a weaker verification. Screening [12] is a weaker security notion for fast and batch signatures
verification. The idea behind screening is that in some applications, what the verifier2 concerned is the
authenticity of origin of all messages, but not the overall validity and correctness of all the related
signatures. More precisely, when providing a set of message-signature pairs, the screening mechanism of
signature in [12] will output accept if the authenticity of origin of all messages is correct, otherwise the
screening mechanism should output reject with extremely high probability.
Susilo and Mu’s cryptanalysis assumes that the nominator keeps all the intermediate parameters, and
thus given a message-signature pair (m,Σm = (yv, b, c, σ)) the nominator can screen the authenticity of
origin of m. However, this screening does not imply the validity of signature Σm = (yv, b, c, σ) as can
be seen from the previous counter-example and some other extended possibilities since the nominee can
easily produce forged signatures without being detected. Therefore, the nominator can not convince a
third party of the validity of the signature Σm = (yv, b, c, σ) by the approached proposed by Susilo and
Mu.
4 Remarks on the Security of HW Scheme
It is claimed that HW scheme is secure in [6], however only intuitive observations without technical
details are given as evidences. To support the claim that HW scheme is alive, more details of the security
analyses is present in this section.
4.1 Unforgeability of nominative signature schemes
Definition 1 (Unforgeability of nominative signatures against chosen message attacks [6]).
Given the security parameter 1k, public system parameters, the public key of the nominator, and the
public-private key-pair of the nominee, a forger F is allowed to ask polynomially many adaptive signature
queries, confirmation queries, and convert queries. The adversary will finally output a pair (m,Σm),
where m is not one of those previous signature queries {mi}, with probability
Pr
 (m,σ)← Fsig,conf,conv,hash(1n, pks, pkv, skv) :(ver(1k,m,Σm, pks, pkv, skv) = 1 ∧
conf(1n,m,Σm, pks, pkv, skv) = 1
)
∨m 6∈ {mi}
 < 1
P (k)
for every positive polynomial P and all sufficiently large k. Sig, conf, conv, hash, and ver denote signing,
confirmation, conversion, hash, and verification oracles respectively.
Note that this definition is the same as the standard definition of unforgeability against active attacks,
except that the adversary is in possession of two additional oracle machines, conf and conv. For the sake of
clearness, we define a valid Schnorr signature as ΣSrm = (R, σ), where R = gr, σ = r−xse, e = H(R||m),
and xs the private key of the signer.
Theorem 1. In the random oracle model, HW nominative signature scheme is existentially unforge-
able against chosen message attacks assuming that the basic Schnorr signature scheme is existentially
unforgeable against chosen message attacks. (Assuming that Decisional Diffie-Hellman (DDH) problem
[13] is hard is necessary in some cases.)
Sketch of proof: The proof is done by contradiction. Let FHW be a forger against HW scheme, and we
assume that, without lose of generality, FHW always makes the corresponding hash query before outputs
any forgery. Using FHW as a subroutine, another forger FSr, who is capable of generating successful
forgeries of instances of Schnorr scheme given by a challenger C, can be constructed. Note that both
FHW and FSr are chosen message attackers against existential unforgeability of signatures (nominative
signatures and standard signatures respectively).
2 In the scenario of nominative signatures, this role could be any third party or the nominator, but not the
nominee. Susilo and Mu’s cryptanalysis focuses on the case where the nominator plays the role of a verifier.
89
3. The proof of Theorem 1 (the definition in [6] as well) does not include the possibility that the
nominator acts as FHW . In fact, when the nominator impersonates the nominee and prepares (a, c)
himself, valid signatures can always be produced (similar to the intuitive simulation in previous
remarks). However, there is no way for the nominator to either confirm or convert signatures.
This proof indicates that the nominee can not forge a signature of the nominator designated to him,
and any third-party can not forge a signature designated to a nominee not of his choice. Otherwise, each
of them can break the Schnorr signature scheme in the random oracle model. This is a secure result
according to chosen message attacks. Extending the security definition of nominative signatures into
chosen identity and chosen message attacks could be a further issue, especially for identity-based ones.
4.2 Verification untransferability
In this section, verification but not screening is considered. As showed in [7], signatures of HW scheme
are screenable by the nominator.
Definition 2 (Relaxed verification untransferability.). Given the security parameter 1k, public
system parameters, public and private keys of the nominator, public key of the nominee, a message m,
and the presumed signature of m, an adversary A, who is in possession of the hash oracle, will finally
output either accept or reject. Where for such A∣∣∣∣Pr [Ahash(1k, pks, sks, pkv,m,Σm) =ver(1k,m,Σm, pks, pkv, skv)
]
− 1
2
∣∣∣∣ < 1P (k)
for every positive polynomial P and all sufficiently large k. Ver and hash denote the verification and hash
oracles respectively.
Verification untransferability captures the requirement that no one other than the nominee can verify
signatures. Even the nominator is not capable of performing verification. In other words, a successful
verification done by the nominator without help from the nominee is a effective attack. Thus, the secret
key of the nominator should be included in the adversary’s resources. Note that the definition used here
is different from and weaker than the one in [6], where conf and conv oracle machines are available to
the adversary in the latter. However this weaker definition is still reasonable as
1. For those adversaries other than the nominator, the nominator’s private key sks is not available.
Thus, there is no way for them to produce valid signatures for either confirmation and conversion.
In this case, the conf and conv oracles are in fact exist while always return reject.
2. In the point of view of applications, it is hard to find scenarios where the nominator is necessary to
act as a third party who is able to query conf and conv.
Theorem 2. In the random oracle model, for anyone without the knowledge of pkv and R2, signatures
of HW scheme is not verifiable assuming that DDH problem is hard.
Sketch of proof: This claim can be proved by contradiction similarly. Let A be an adversary who is able
to verify signatures of HW scheme without knowledge of both the private key skv of the nominee v
(i.e., xv) and the random number R2. Treating A as a subroutine, a solver D of DDH problem can be
constructed.
Suppose now the DDH-solver D takes a presumed DDH-tuple (α, β, γ, δ) as input. Firstly, D randomly
chooses xs and computes ys = αxs and sets (ys, xs) as the public-private key-pair for the nominator;
clearly, now α serves as the system-wide public generator in A’s view. Secondly, D randomly chooses
σ and e, then computes b such that γ ≡ ασyesb (mod p). Finally, D sets hashHW (β||b||δ||m∗) = e for
some arbitrary bit-string m∗ and pass (pks, sks, pkv,m,Σm) = (ys, xs, β,m∗, Σm∗ = (β, b, δ, σ)) to A as
input. The output of A is the answer of the challenged DDH instance directly since accept returned by
A indicates
(ασyesb)
logα β ≡ δ (mod p)
⇒ γlogα β ≡ δ (mod p)
⇒ logα β ≡ logγ δ (mod q)
It is claimed without detail proving in [6] that HW scheme is (full) verification untransferable. To
the best of our knowledge, proving (full) verification untransferability of HW scheme based on DDH
assumption is not practical, since the private key xv of the nominee (i.e., logα β in the reduction above)
is necessary for answering the conf and conv oracles, however it must be assumed to be unknown for the
DDH-tuple (g, yv, gR2 , yR2v ). Nevertheless, in the point of view of applications, proving relaxed verification
untransferability is sufficient and practical.
91
Balanced Concurrent Signature ?
Yen-Chang Chen and Sung-Ming Yen
Laboratory of Cryptography and Information Security (LCIS)
Dept of Computer Science and Information Engineering
National Central University, Chung-Li, Taiwan 320, R.O.C.
E-mail: {cs322016;yensm}@csie.ncu.edu.tw
http://www.csie.ncu.edu.tw/~yensm/
Abstract. Concurrent signature is a scheme which allows two mutually untrusted parties to fairly
exchange their signatures in a way that either these two signatures become valid concurrently
after obtaining an additional secret (i.e., the keystone) or both of them become ambiguous from
the viewpoint of any third party. The first concurrent signature was developed based on ring
signature and this leads to the result that the two resulted signatures bind to each other due to
the nature of the ring. In most real applications, binding of these two signatures violates privacy
requirement and becomes unacceptable. To resolve this problem, Nguyen proposed a concurrent
signature scheme which is independent of the ring structure and has two new properties, i.e.,
anonymity and unlinkability. In this paper, we propose a new concurrent signature scheme based
on the conditional signature and performs more efficient than Nguyen’s scheme. The proposed
scheme achieves all the properties except anonymity in Nguyen’s scheme and we will show that
this property is in fact minor in most applications to achieve the purpose of a concurrent signature.
We present two concurrent signature protocols which allow different parties in the transaction to
finally determine whether and when to release the keystone. This is what the word balanced means
in our scheme.
Keywords: Concurrent signature, Fair exchange, Conditional signature.
1 Introduction
The notion of concurrent signature was first introduced by Chen, Kudla, and Paterson [1]. It is a signature
scheme which allows two parties, say, Alice and Bob (A and B for short respectively) to fairly exchange
their signatures without the assistance of a trusted third party (TTP). Consider the situation that A
wants to buy an item, e.g., a laptop, from B’s shop which has the service on the Internet. A first gives
her promise of signature (which can be considered as a commitment that may become a valid signature
in the future, this term is defined in [6]) of the order to B. After receiving A’s promise of signature,
B checks whether it is correctly generated by A, and sends back his promise of signature as a bill of
lading which gives permission to A to receive a laptop from his shop. From any third party’s point of
view, the promise of signatures exchanged between A and B are both ambiguous with respect to A and
B’s identities so that he can not identify which promise of signature is generated by which party. Thus,
these promise of signatures are meaningless to the third parties until a certain secret information, i.e.,
a keystone, is released. After the keystone is revealed by one of the parties involved in the transaction,
both ambiguous promise of signatures immediately bind to their real signers and become valid signatures
concurrently.
Chen et al. claimed that the promise of signatures generated by A or B are completely ambiguous
from the viewpoint of any third party as long as the keystone is kept secret, but there exists a special
case that would break this statement. That is, any third party would prefer to trust that one of these
two promise of signatures is generated by A and the other is generated by B even if the keystone is not
revealed if both parties are well-behaved people all the time. Hence, Susilo et al. proposed two perfect
schemes [9], one is constructed from the Schnorr signature scheme and the other is constructed from the
bilinear pairing, to revise this defect. After that, a generic notion of the perfect concurrent signature and
two ID-based perfect concurrent signature schemes are published [2].
? This work was supported in part by the National Science Council R.O.C. under contract NSC 94-2213-E-008-
009.
25
concurrent signature scheme respectively. Section 5 presents a concrete balanced concurrent signature
scheme and Section 6 analyzes its security and performance. We conclude this paper in Section 7.
2 Conditional Signature Schemes
The work in [5] presents the concept of conditional signature. This concept of signature scheme re-
stricts someone to obtain a signature only if the condition declared in that signature comes true. In [4],
Klonowski et al. proposed a concrete conditional signature scheme which is based on the ElGamal
scheme [3]. Because the Schnorr signature scheme is efficient than ElGamal’s, we modify the Schnorr
signature to a conditional signature scheme with the same spirit and use this as the building block in
our concurrent signature scheme.
2.1 Review of Conditional Digital Signatures
The conditional signature scheme proposed in [4] is based on the ElGamal scheme [3]. Let’s start with the
ElGamal public key cryptosystem. The public parameters are a large random prime p and a generator g
of the multiplicative group Z∗p . The private key is x and its corresponding public key is y = gx mod p.
To encrypt a message m, compute a = gk mod p and b = m× yk mod p, where 1 ≤ k ≤ p− 2. The pair
(a, b) is the ciphertext of m. To recover m, compute m = b× a−x mod p.
The ElGamal signature scheme is as follows. To sign a message m, compute a = gk mod p and
b = k−1(h(m) − xa) mod (p − 1), where gcd(k, p − 1) = 1 and h : {0, 1}∗ → Zp. The pair (a, b) is the
signature for m. To verify (a, b), check whether ya × ab ?≡ gh(m) (mod p).
Consider a scenario that B needs to give A a future signature which would become valid on particular
time t. That is, this signature is conditioned by future time t which is assigned by B. In addition to A
and B, there is a trusted third party, time authority (T for short), which would confirm current time and
publish its signature of this time periodically (e.g., every hour). A can obtain a valid signature σB from
B on condition that T releases its signature of time t. This can be achieved by the following manner.
In subsequent description and the remaining part of this paper, we will use the expression of a variable
along with a suffix to indicate that the variable belongs to the person presented in the suffix.
1. T → B : B gets the first part of the ElGamal signature aT from T . This is a public value generated
by T .
2. B → A : After that, B computes r = gh(mT ) × y−aTT mod p, where mT is the description of “time
t has passed”. The value r is actually the condition which is constrained by mT . Then B generates
his conditional signature (aB , bBrz, azT ) which includes the condition r, where z is a random integer
in the closed interval [1, p − 2] and σB = (aB , bB) is his ElGamal signature on mB . Note that
r ≡ a bTT (mod p) and the value bT is the second part of the ElGamal signature on mT which would
not be generated by T until time t. We can liken aT to the generator g, bT to the private key xT , and
r to the corresponding public key yT . Thus, the pair (azT , bBr
z) can be regarded as the ciphertext of
bB which is encrypted by the private key bT . B sends this conditional signature to A.
3. T → A : When time goes by t, T computes bT and makes it public. Then A can completely get σB
via the computation of bB = bBrz × (azT )−bT mod p.
More applications of the conditional signature scheme can be found in [4].
2.2 Conditional Signature Scheme Based on Schnorr Signature
We change the usage of the Schnorr signature scheme to let a signer be able to generate a condition
which is restricted by some message. The original Schnorr signature scheme [8] is constructed as follows.
Setup: Generate the public parameters p, q and g, where p and q are some prime numbers with appro-
priate size such that q | (p − 1) and g is a generator of the subgroup of order q in Z∗p . There still
requires a public cryptographic hash function h : {0, 1}∗ → Zq.
Key Generation: Select a random integer x such that 1 ≤ x ≤ q− 1, and compute y = gx mod p. The
pair (x, y) is the key pair, where y is the public key and x is the corresponding private key.
Signature Generation: Select a random secret integer k, where 1 ≤ k ≤ q−1. Compute a = gk mod p,
e = h(m ‖ a), and b = xe+ k mod q. The pair (e, b) is the signature for the message m signed with
the private key x.
27
3.2 Protocols of Balanced Concurrent Signature
In this section, we present two concurrent signature protocols. Both of them are based on the same
underlying algorithms described in previous section, but the difference is that they benefit different
parties (this is the origin of the word balanced in our scheme). Note that the benefit means a party has
the power of final decision to the transaction (i.e., whether and when to release the keystone), and this
does not violate the definition of fairness defined in the literatures [1, 2, 6, 9] and in Section 4 of this
paper. These two protocols can be used in different circumstances which depends on the service provided
by the merchant. The first protocol is advantageous to the customer A, and the second protocol protects
the rights and interests of the merchant B.
A and B run SETUP first to set the system parameters of the scheme and to generate personal key
pairs before they are engaged in the protocol.
1. Customer Oriented Protocol:
(a) A generates a tailored integer aA, which would become a part of her general signature, and sends
this value to B.
(b) After receiving aA, B runs CGEN to make a condition r, which is restricted by the message mA
chosen by B, such that A has to sign mA if she wants to get B’s signature. Then B performs
MSIGN to generate a conditional signature ωB on mB and sends 〈(ωB ,mB),mA〉 to A.
(c) After receiving 〈(ωB ,mB),mA〉, A performs ISIGN to generate her signature σA = 〈aA, bA〉 on
mA and verifies B’s signature ωB with algorithm MVERIFY . If it outputs accept, A sends the
keystone bA to B.
After B receives bA, he verifies A’s signature by the algorithm IV ERIFY . If it outputs accept, the
protocol completes normally. Otherwise, B can ask A to resend a valid bA or he can get a valid one
via his general signature converted from ωB by A if she makes it public.
2. Merchant Oriented Protocol:
(a) B generates a tailored integer aB , which is a part of his general signature in the future, and puts
this value on his website. Note that he does not forward this value to any particular person in
this step because he does not know who wants to purchase things from him at the moment.
(b) A surfs the web and wants to buy an item from B. She picks up aB and performs CGEN and
MSIGN to generate a conditional signature ωA, which is restricted by the bills of lading mB of
the item she wants, on the payment mA. She sends 〈(ωA,mA),mB〉 as an order for that item.
(c) After receiving the order 〈(ωA,mA),mB〉, B generates his general signature σB = 〈aB , bB〉 on
mB with algorithm ISIGN and verifies the validity of ωA via MVERIFY . If it outputs accept,
he sends the keystone bB to A.
After receiving bB , A can verify B’s signature by IV ERIFY . If it outputs accept, the protocol
completes normally. Otherwise, she can ask B to resend a valid bB or she can get a valid one via her
general signature converted from ωA if B makes it public.
Once the keystone is released, the conditional signature would be transformed into a general signature by
the algorithm MTRAN , and anyone can verify both parties’ signatures with the algorithm V ERIFY .
In previous concurrent signature schemes, the keystone is generated by the initial signer at first either
in a manner of random selecting from the keystone space [1, 2, 9] or using a part of her general signature
which has been computed when the transaction is going on [6]. Differ from these schemes, the keystone
can be looked upon as it is chosen by the matching signer in our scheme. The initial signer would be
able to get the matching signer’s general signature on condition that she sends the remaining part of her
general signature, i.e., the keystone which is conditioned by the matching signer’s conditional signature,
to the matching signer.
4 Security Model of Balanced Concurrent Signature
The initiated concurrent signature scheme in [1] has four properties in the security model, i.e., correctness,
unforgeability, ambiguity, and fairness. In [6], Nguyen strengthens the ambiguous property to the property
of anonymity and adds a new attribute, i.e., unlinkability, to his scheme. In our scheme, it holds all of
the attributes except anonymity listed above. The security model for our scheme is given in this section.
29
4.4 Unlinkability
Definition 5 A balanced concurrent signature scheme is unlinkable if the probability of success of any
polynomially bounded adversary in the following game is not better than 1/2.
The property of unlinkability of a balanced concurrent signature scheme is defined by the following
game between an adversary E and a challenger C.
Setup: This is the same as Setup in the game in Section 4.2.
Challenge: E selects two challenge public keys yiˆ and yjˆ , and then C runs the balanced concurrent
signature protocol two times with the corresponding private keys xiˆ and xjˆ to simulate two transac-
tions. C then gets two signature pairs 〈σiˆ, σjˆ〉 and 〈σ′iˆ, σ′jˆ〉, and he randomly chooses a bit b ∈ {0, 1}.
C sets τ = σjˆ if b = 0 or τ = σ
′
jˆ
if b = 1. C outputs the tuple 〈σiˆ, σ′iˆ, τ〉 and two private keys xiˆ and
xjˆ .
Output: Finally E outputs a bit b′ ∈ {0, 1} and he wins the game if b′ = b.
5 The Proposed Balanced Concurrent Signature Scheme
A concrete balanced concurrent signature scheme is given in this section. It is based on the Schnorr
signature scheme and the Schnorr based conditional signature scheme described before. The algorithms
of this scheme are as follows.
SETUP: This algorithm takes a security parameter l as input, and it outputs the public parameters
p, q and g, where p and q are two large primes such that q | (p − 1) and g is a generator of the
subgroup of order q in Z∗p . The message space M = {0, 1}∗, the signature space S = Zp × Zq, the
keystone space K = Zq, and the keystone fix space F = Zp are output by this algorithm. The
function KGEN : Zq → Zp is defined as KGEN(x) = gx mod p. Each participant’s private key xi
is randomly chosen from Z∗q and the corresponding public key yi is computed as yi = gxi mod p.
Finally a public cryptographic hash function h : {0, 1}∗ → Zq is selected.
ISIGN: This algorithm takes a tuple 〈yi, xi,mi〉 as input, and it outputs a Schnorr signature σi = 〈ai, bi〉
on mi, where ai = gki mod p and bi = xih(mi ‖ ai) + ki mod q. The value ki is a random secret
integer generated by this algorithm in Z∗q .
CGEN: This algorithm takes a tuple 〈yi, ai,mi〉 as input, and it outputs a condition r = ai×yh(mi‖ai)i mod p
which is restricted by mi and fits in with r = KGEN(bi).
MSIGN: This algorithm takes a tuple 〈yj , xj , r,mj〉 as input, and it outputs a Schnorr based conditional
signature ωj = 〈αj , βj〉, where αj = gkj × r mod p and βj = xjh(mj ‖ αj) + kj mod q. The value kj
is a random secret integer generated by this algorithm in Z∗q .
MTRAN: This algorithm takes a tuple 〈ωj , bi〉 = 〈(αj , βj), bi〉 as input, and it outputs a Schnorr
signature σj = 〈aj , bj〉 on mj , where aj = αj and bj = βj + bi mod q.
IVERIFY: This algorithm takes a tuple 〈σi, yi,mi〉 = 〈(ai, bi), yi,mi〉 as input, and it outputs accept
if and only if ai = gbi × y−h(mi‖ai)i mod p.
MVERIFY: This algorithm takes a tuple 〈ωj , yj , bi,mj〉 = 〈(αj , βj), yj , bi,mj〉 as input, and it outputs
accept if and only if αj = gβjy
−h(mj‖αj)
j g
bi mod p.
VERIFY: This algorithm is identical to the algorithm IV ERIFY .
The concrete balanced concurrent signature scheme can be directly derived from the above algorithms
and the protocols described in Section 3.2.
6 Security and Performance of The Proposed Scheme
6.1 Security Analysis
The balanced concurrent signature scheme proposed in Section 5 satisfies the properties of correctness,
unforgeability, fairness, and unlinkability described in Section 4. We explain it as follows.
Correctness: This can be deduced from the definition of correctness. The signature σi = 〈ai, bi〉 =
ISIGN(yi, xi,mi) is a Schnorr signature, and therefore the verification algorithms of a Schnorr
signature IV ERIFY and V ERIFY with an input tuple 〈σi, yi,mi〉 would output accept. The
conditional signature ωj = 〈αj , βj〉 = MSIGN(yj , xj , r,mj) can be transformed into a Schnorr
signature σj = 〈aj , bj〉 = MTRAN(ωj , bi) if KGEN(bi) = r. Thus, V ERIFY with an input tuple
〈σj , yj ,mj〉 would output accept. If ωj can be converted to a valid σj with an appropriate bi, then
MVERIFY with an input tuple 〈ωj , yj , bi,mj〉 would output accept.
31
For war d-Secur e B lind Signatur e Schemes B ased on I nteger
Factor ization P r oblem ⋆
Jing-shian Tsai and Sung-Ming Yen
La bo ra to ry o f C ry pto g ra phy a nd Info rma tio n Se c urity (LC IS)
D e pt o f C o mpute r Sc ie nc e a nd Info rma tio n Eng ine e ring
N a tio na l C e ntra l U niv e rsity , C hung -Li, T a iw a n 3 2 0 , R.O.C .
E-ma il: { cs322045;yensm } @csie.ncu.edu.tw
http://www.csie.ncu.edu.tw/~yensm/
A b s t ra ct . Blind sig na ture pla y s a n impo rta nt ro le in e -c a sh a nd e -v o ting sy ste ms w ith the pro p-
e rtie s o f a no ny mity a nd unfo rg e a bility . H o w e v e r, if sig ne r’s se c re t k e y is c o mpro mise d, the sig na ture
sig ne d be fo re w ill no t be be lie v e d a g a in. So , this k ind o f sy ste ms w ill suffe r a g re a t lo ss. F o rw a rd-
se c ure pro pe rty is a se c urity no tio n to pre se rv e tha t a c o mpro mise d c urre nt se c re t k e y do e s no t
he lp a n a dv e rsa ry to fo rg e a ny sig na ture in so me pa st time pe rio d. In this pa pe r, w e pre se nt tw o
fo rw a rd-se c ure blind sig na ture sc he me s, w hic h a re ba se d o n F ia t-Sha mir a nd Ong -Sc hno rr blind
sig na ture s, re spe c tiv e ly . We g iv e the pro o f o f the tw o fo rw a rd-se c ure blind sig na ture sc he me s w ith
the blindne ss a nd fo rw a rd se c urity .
Keywords:Blind Signature, Forward Security, Factoring Problem, Key Exposure Problem.
1 I ntr oduction
In the digital signature scheme, if the important secret key which is used to sign many documents
is compromised, then all the documents signed with it will never be believed. Even if some of the
signatures signed before do not be forged, they can not be believed again. Because of this big problem,
many researchers focused on this topic many years. In the early, secret sharing signature [19] can solve
this problem. There are two branches of the secret sharing signature scheme. One is threshold signature
scheme and the other is proactive signature scheme. But these kinds of methods do not really solve this
big problem. These methods just increase the difficulty of getting the secret key by an adversary rather
than protect the trustworthiness of the signatures. Once the secret key was leaked out, the problem
occurred again.
Now, we hope that the signatures signed before are still believed even if the key exposure problem
occurs. Forward security, which is a property, allows the signature scheme to keep the previous signatures
valid when the key exposure happens. This property is first noticed in the context of session key exchange
protocols by [12] and [9]. The basic idea of a key exchange protocol stands for that exposure of the long-
term secret key does not compromise the secrecy of the past session keys. In such a scheme, sender
and receiver negotiate a shared session key. They use it to encrypt a single message and then delete
it promptly. A key exchange protocol naturally effectuates an interactive forward-secure encryption
scheme. Afterward, Anderson [1] proposed the concept of non-interactive forward security in 1997 and
then Bellare and Miner [4] formalized it by proposing a forward-secure signature scheme. The method
proposed by Bellare and Miner is to guarantee that each secret key is used only for short time so that
compromise of a secret key in certain time period does not impact on anything based on other secret
keys which came from the prior time periods. Moreover, the scheme does not need to have a tamper-
proof storage device or distribute some shares such like secret sharing scheme. Furthermore, public key
is fixed through the lifetime of the scheme even if secret key is changing periodically. Later Abdalla and
Reyzin [2] improve the construction in [4] by proposing their new scheme with shorter keys significantly.
Moreover, their construction is more practical and they provide better security bounds.
David Chaum proposed a fascinating expansion of the traditional digital signature, called blind
signature. A user can obtain a valid signature from the signer without revealing the content of the
message. An important application of the blind signature is E-cash. In this kind of scheme, a signature
issued by the signer, i.e. bank, is considered as an electronic coin (e-coin for short). The paradigm of the
⋆ T his w o rk w a s suppo rte d in pa rt by the N a tio na l Sc ie nc e C o unc il R.O.C . unde r c o ntra c t N SC 9 4 -2 2 1 3 -E-0 0 8 -
0 0 9 .
77
This violates the blindness property. However, the time period index is publicly available and when
the secret key is updated, the signer must associate with all involved parties to agree this operation.
Something should be noticed that if a time period is too short, then there will not be many signatures
issued in that time period. This seems to violate the blindness property. So, it needs a more rigorous
blindness property. The following states this more precise.
Definition 2 (Blindness) Let an attacker A be the signer and U0, U1 be the two honest users. A
generates two messages m0 and m1 and sends them to the users randomly. U0 and U1 engage with the
signer to obtain the corresponding signature on their message. The two signatures are denoted by σ(mb)
and σ(m1−b) with respect to U0 and U1. Then, the two signatures are given to the signer and A outputs
a bit b′ ∈ {0, 1}. It is to say that A wins the game if b′ = b. It means that A knows the message and its
corresponding signature of U0 and U1.
If an attacker wins the game with the negligible probability, then he can not link a signature to its
owner. That is to say, the blindness property is satisfied. It takes notice of that the blindness property
must be sufficed for all signatures, not just in one time period.
Definition 3 (Attack Model) In the blind signature scheme, there are two kinds of attacks which are
focused on. One is the sequential attack, and the other is the parallel attack. Sequential attack means that
the attacker interacts with the signer one after another. Parallel attack means that the attacker interacts
with the signer at his own choice and this is a stronger attack because he can initial any new interactions
even if the former ones have not been ended.
2.3 Security Assumption
Choose p and q, two large prime numbers which are congruent to 3 modulo 4. Let N = p ∗ q , and it is
called a Blum-Williams integer. QN denotes a set of quadratic residues modulo N . In the following, the
definitions are adapted in [13].
Definition 4 (Unique Square Root) Let x ∈ Z∗N and ω is a quadratic residue modulo N , i.e., if
there exists an x ∈ Z∗N such that x
2 = ω (mod N) then the x ∈ QN is said to be the unique square root
of ω and is also called the principal square root of ω modulo N .
Definition 5 (Permutation Property) If N is a Blum-Williams integer, then the function f : QN →
QN defined by f(x) = x
2 (mod N) is a permutation.
3 T he P r oposed For war d-Secur e Fiat-Shamir B lind Signatur e Schemes
In this section, two versions of forward-secure Fiat-Shamir blind signature schemes and their security
proofs are provided. In the basic construction, we modify the Fiat-Shamir blind signature scheme to make
it forward-secure. However, the main defect of the basic construction is that the usable lifetime of the
scheme is a half of lifetime of the scheme. Therefore, we try to improve it to reach the full time-periods
construction.
The proposed scheme works on the multiplicative group Z∗N where N is a Blum-Williams integer. In
other words, N is the multiplication of two large primes, p and q, which are congruent to 3 modulo 4.
The setting of signer’s public key and secret key of the scheme is the same as [4]. Moreover, the lifetime
of scheme is divided into T time periods, numbered 1,2,. . .,T . When the key generation algorithm is
completed, the factors, p and q, have to be deleted. By this way, an attacker can not access them when
he breaks into the system. Notice that [8] points out that user should operate hash function honestly
by using the correct time period index. Otherwise, the forward-secure property will lose. To protect our
scheme from this kind of cheating, the correct time period index would be embedded in the verification
process. In the following, the key-evolving process in [4] is first introduced, and then two forward-secure
Fiat-Shamir blind signature schemes are appeared. We apply below two algorithms to our scheme.
Key Generation Algorithm(λ, k, T ): λ and k are security parameters. T is total number of time periods.
Choose two distinct radom prime numbers p and q which are congruent to 3 modulo 4. Let p and q are
λ/2 bits and N = pq.
Pick Si,0
R
← Z∗N ; Ui ← S
2T+1
i,0 (mod N), for i = 1, . . . , k. Erase p and q.
SK0 ← (N,T, 0, S1,0, . . . , Sk,0); PK ← (N,T, U1, . . . , Uk). Return (SK0, PK)
79
The Full Time-Periods Construction. Figure 2 shows a different version of forward-secure Fiat-
Shamir blind signature scheme. Most of the procedures are the same with the basic construction. The
proposed construction here also overcomes the same problem and tries to improve the basic construction
so that it can run out the whole lifetime of the scheme. The key point of the full time-periods construc-
tion is to create k + 1th key pair, Sk + 1,0 ∈R Z
∗
N and Uk + 1 = S
22T+1
k + 1,0 (mod N). As same as the basic
construction, the k + 1th secret key is used to compute the signer’s response y. Because 2j of the added
item, S2
j
k + 1,j = S
22j
k + 1,0, is at most 2T , the maximum value of j is T . Therefore, the lifetime of the scheme
can reach T . The correctness of the verification of the signature is similar with the basic construction.
1-
* 2 *
2
1
*
;  (mod )   ; {0,1}
                                                     (mod )
                                                     ( , , );  : {0,1} {0,1}
    
T j
i
x k
N N
k
i
i
k
t Z x t N Z
x U N
H m j H
γ
β γ
α β
ε α
+
=
∈ = → ∈ ∈
=
= →
∏
12 2 2
, 1, 1
1 1
2
                                       
( ) (mod )  ( ) (mod )
                                                      (mod )
         
j T j j
i i
T j
i i
e
k k
e ey
i j k j i k
i i
i
e
e
y t S S N y x U U N
y U N
γ
ε γ
ρ β
+ −
−
+ +
= =
>
← = ⊕
= → =
=
∏ ∏
∏
2 2
1
1
                              ( , , , , )
                       = ( ) (mod )  ( , , )ji
k
i k
i
m j
U U N and H m jε
α ε ρ
α ρ ε α− −+
=
=∏
Signer User
F ig. 2. T he F ull T ime -Pe rio ds C o nstruc tio n
Theorem 1 The proposed two forward-secure Fiat-Shamir blind signature schemes satisfy the blindness
property.
Proof. Let’s consider an experiment between an attacker and two honest users. Let an attacker be the
signer and U0, U1 be the two users. They run the game which is described in definition 2. Suppose
that attacker gets two signatures, (mb, αb, ǫb, ρb, i) and (m1−b, α1−b, ǫ1−b, ρ1−b, j), from the U0, U1. The
two signatures must be valid; otherwise the attacker gets no information to guess b meaningfully. (x,
e, y) are the transcripts between the signer and the user during the signing procedure. The signer may
collect many transcripts and stores them in his database. We should demonstrate that the selected
blinding factors exist and each of them is unique. Therefore, the signer, given any view of (x, e, y) and
any signature (m,α, ǫ, ρ, i), can not link a given view corresponding to which signature. Because the
blinding factors are chosen randomly, this fact preserves the blindness property. Given the view of (x, e,
y) and (m,α, ǫ, ρ, i), the blinding factors β and γ can be uniquely computed as follows: γ = e ⊕ ǫ and
β2 = αx−1
∏
γi = 1
U−γii (mod N). To compute the unique β is computationally infeasible, because it needs
to know the factors p and q of N . Therefore, any attacker can obtain any useful information during
the signing procedure to guess b with negligible probability. In other words: Adv(A) = |Pr[b′ = b ←
A|pk; (x, e, y); (m,α, ǫ, ρ, i)]− 1/2| is negligible.¥
Theorem 2 Consider the forward-secure Fiat-Shamir blind signature scheme in the random oracle
model. If there exists an forger F who can break forward security of the proposed scheme, then there
exists an algorithm A to solve the problem of factoring the Blum-Williams integer.
(Sketch of proof) The proof idea is to base the public key U on ν which is computed by ν = x2
(mod N) and x ∈R Z
∗
N chosen by A. A attempts to use an adversary to find a square root y of ν.
Because ν has four square roots and x is random, if x ≡ ±y (mod N), then A will be able to gain a
factor of N by computing gcd(x ± y,N). A provides the public key for F and answers his hashing and
signing queries. To run F once to get a forged signature (m,α, ǫ, ρ, i) on hth hashing query on (m,α, i).
Without loss of generality, we can suppose that all the hashing queries on (m,α, i) are asked during
the attack procedure. Otherwise, the probability of success in guessing ǫ is at most 2−k because of the
81
Correctness: The verification of the signature is given in the following equations.
ρ2
k(T+1 − j)
U−ǫ mod N = y2
k(T+1 − j)
γ2
k(T+1− j)
U2
k(T+1)τU−ǫ mod N
= xUeγ2
k(T+1− j)
U2
k(T+1)τU−ǫ mod N
= xγ2
k(T+1− j)
U ǫ + βU−ǫ mod N = α
Theorem 3 The proposed forward-secure Ong-Schnorr blind signature scheme satisfies the blindness
property.
Proof. The skill of proof is much similar with the Theorem 1. Given the view of (x, e, y) and (m,α, ǫ, ρ, i),
the blinding factors β and γ can be uniquely computed as follows: β = e − ǫ (mod 2k(T + 1)) and γ =
ρy−1U−2
kjτ (mod N). To compute the unique β is computationally infeasible, because it needs to know
what the real β is. β is randomly chosen from the {0, . . . , 2k(T + 1)−1}, so the probability is at most 1
2k(T+1)
.
It is negligible. So to compute the real γ is also infeasible. Therefore, any attacker can obtain any useful
information during the signing procedure to guess b with negligible probability.¥
Theorem 4 Consider the forward-secure Ong-Schnorr blind signature scheme in the random oracle
model. If there exists an forger F who can break forward security of the proposed scheme, then there
exists an algorithm A to solve the problem of factoring the Blum-Williams integer.
(Sketch of proof) Please refer to full paper [20] for the detailed proof.¥
5 Some Fur ther Discussions
In terms of the security level, forward-secure Fiat-Shamir blind signature scheme is secure against the
stronger attack (i.e., parallel attack) than the forward-secure Ong-Schnorr blind signature scheme. The
secret key of the proposed forward-secure Fiat-Shamir blind signature scheme having multicomponent
so that the proposed scheme satisfies witness indistinguishability. Informally, a protocol is witness indis-
tinguishable if the user can not tell which witness (i.e., secret key) the signer really uses. So, the security
of this kind of scheme is preserved under the parallel attack [11]. Therefore, the security level of the
forward-secure Fiat-Shamir blind signature scheme is against the parallel attack. In contrast with the
forward-secure Fiat-Shamir blind signature scheme, the secret key of the forward-secure Ong-Schnorr
blind signature scheme has only one component. So, the forward-secure Ong-Schnorr blind signature
scheme is not a witness indistinguishable protocol. The security level of the forward-secure Ong-Schnorr
blind signature scheme is against the sequential attack.
In terms of the efficiency, the key length and the computational costs of the signing and verification
are compared. The key length (both the public and secret keys) of the basic construction is about
λ × (k + 1) bits and that of the full time-periods construction is about λ × (k + 2) bits while that
of the forward-secure Ong-Schnorr blind signature scheme is about 2λ bits. Therefore, the keys of the
former is about (k + 1)2 or
(k + 2)
2 times longer than the latter where k is a large integer. Both of signing and
verification during the time period j for the basic construction take about k2 +kj modular multiplications
and for the full time-periods, they take about k2 + j modular multiplications. In the forward-secure Ong-
Schnorr blind signature scheme, signing takes about 3k(T + 1)
2
modular multiplications and verification
takes about k(T +1− j)+ 3k(T + 1)
2
modular multiplications. However, in the forward-secure Ong-Schnorr
blind signature scheme, the modular multiplications of signing can be reduced to 3k(T + 1)
8
by using CRT
method.
The forward-secure Ong-Schnorr blind signature scheme has significantly shorter keys than the
forward-secure Fiat-Shamir blind signature scheme, but the efficiency of the former is less than the
latter. In some application, the capacity is limited so the forward-secure Ong-Schnorr blind signature
scheme is more practical to fit the requirement. The forward-secure Fiat-Shamir is efficient and more
secure besides the large secret keys. Therefore, according to the prevailing scenario, the forward-secure
Fiat-Shamir blind signature scheme is needed if the efficiency and high security level are required without
limiting the capacity or the forward-secure Ong-Schnorr blind signature schemes is needed if the capacity
is smaller.
83
2006 ????????????????
The Seventh Smart Card Research and Advanced Application Conference
(CARDIS 2006)
???????
??? ??
?????? ??????
Tel: (03) 4227151 Ext-35316
Fax: (03) 4222681
E-mail: yensm@csie.ncu.edu.tw
http://www.csie.ncu.edu.tw/~yensm
??????:
???2006 ?????????????????(The Seventh
Smart Card Research and Advanced Application Conference 2006) ??
? CARDIS 2006????????? IFIP ???????????
????--Tarragona ?????? 2006 ? 4 ? 19 ? ? 4 ? 21 ??
CARDIS ??????????????????????????
(smart card)????????????????????????
??????????????????????????????
??????????????????????????
???????????????? 70 ?????? 25 ???
(???? 0.357)??????????????????????
??????????????????????????????
??????????????????????????????
?????????????: “???????????????
??????? (Amplifying Side-Channel Attacks with Techniques
from Block Cipher Cryptanalysis)”????????????????
??????????????????????????????
??????????????????????????????
??????????????????????????????
??????????????????????????????
?????
Amplifying Side-Channel Attacks with
Techniques from Block Cipher Cryptanalysis
Raphael C.-W. Phan1 and Sung-Ming Yen2?
1 Information Security Research (iSECURES) Lab,
Swinburne University of Technology (Sarawak Campus), 93576 Kuching, Malaysia
E-mail: rphan@swinburne.edu.my
2 Laboratory of Cryptography and Information Security (LCIS)
Dept of Computer Science and Information Engineering
National Central University, Chung-Li, Taiwan 320, R.O.C.
E-mail: yensm@csie.ncu.edu.tw
http://www.csie.ncu.edu.tw/~yensm/
Abstract. We introduce the notion of amplified side-channel attacks,
i.e. the application of block cipher cryptanalysis techniques to amplify
effects exploitable by side-channel attacks. Such an approach is advanta-
geous since it fully exploits the special characteristics of each technique
in situations where each thrives the most. As an example, we consider
the integration of block cipher cryptanalysis techniques into a particular
type of side-channel attack, the differential fault attack (DFA). In more
detail, we apply the DFA on the AES key schedule or on intermediate
states within the AES and then exploit distinguishers based on Square
attacks and impossible differential cryptanalysis to cover the remaining
rounds. The use of techniques from conventional differential cryptanal-
ysis in DFAs is not new; however, to the best of our knowledge, more
advanced differential-like attack techniques have so far not been applied
in collaboration with DFA. Further, while previous DFA attacks can only
be mounted if faults are induced in the last or first (but with more re-
strictions) few rounds, our attacks alternatively show that even when
faults are induced into some middle rounds, the DFA attacks still work,
complementing existing results in literature; and thus showing that DFA
attacks work regardless of where faults are induced. This is of impor-
tance because redundancy is a costly countermeasure against DFA and
thus it is vital to study which rounds have to be protected. We hope
that this completes the picture on the applicability of DFAs to block ci-
phers, and motivates thoughts into applying other advanced block cipher
cryptanalysis techniques into other types of side-channel attacks.
Keywords: Attacks and countermeasures in hardware and software, side-
channel attacks, cryptanalysis, fault attacks, Advanced Encryption Standard.
? S.-M. Yen’s research in this work was supported in part by the National Science
Council of the Republic of China under contract NSC 94-2213-E-008-009 and also
the University IT Research Center Project.
the cipher, we can apply techniques from block cipher cryptanalysis to amplify
these effects so that they cover more rounds and become more distinguishable.
To illustrate this, we consider the particular integration of the Square attack
and the impossible differential attack into the differential fault analysis (DFA)
[8], a type of side-channel attack. We apply this to the AES [13].
The second main contribution of this paper is that our approach of integrat-
ing block cipher cryptanalysis techniques into the DFA makes a much weaker
assumption on the fault location in that it does not restrict the fault location
to be within the last (or sometimes first1) few rounds only, as is the case with
previous DFAs [10, 19, 15, 12, 32]. This leads to a more reasonable attack from
the view point of fault attacks, and a less restricted attack model.
We therefore see that the advantages of our amplified approach is twofold.
One, it allows the individual power of block cipher cryptanalysis techniques to be
fully exploited by side-channel attacks. Side-channel attacks on their own would
not be able to cover as many rounds of a cipher. Two, it allows DFA attacks
to be mounted with a more flexible attack model, that faults could be induced
even in rounds where previous DFAs are inapplicable. This study is important
because redundancy is a costly countermeasure against DFA, thus one should
ascertain exactly which rounds need to be protected.
Our attacks do not improve on previous work in situations where previous
attacks are applicable, but our contribution is in showing that situations pre-
viously not susceptible to DFAs can now be attacked. Our work here therefore
complement previous work; and together they show the universality of DFAs
and how important it is to guard against them.
In the process, our discussions also provide an insight into the link between
side-channel attacks and techniques from block cipher cryptanalysis
1.1 Attack Models: Block Cipher Cryptanalysis vs Side Channels
Block cipher cryptanalysis assumes an attacker has access to or control over
input plaintexts and corresponding output ciphertexts − and even secret key
relationships in the case of related-key (RK) attacks. He has no access to or
control over what happens within the cipher’s encryption process but knows the
internal structure of the block cipher and exploits this to his advantage.
In contrast, side-channel attacks assume an attacker has much more access
or control, not only over the inputs and outputs but also able to induce differ-
ences into intermediate rounds (via DFA) and/or predicting behaviour in these
intermediate rounds (via timing, power or EM traces). Similarly, he also exploits
his knowledge of the internal block cipher structure.
Therefore, the attack model used in side-channel attacks is much more pow-
erful compared to that used in block cipher cryptanalysis. In fact, the former
can be considered a superset of the latter.
1 But with a higher text complexity or stricter text requirements.
can sometimes be deduced from some useful relationship between different side-
channel signals. To summarize, the purpose of integrating side-channel attacks
is to optimize the information retrieved from the limited amount of individual
side-channel information.
Agrawal et al. [2] proposed a formal multi-channel attack framework for inte-
grating multiple side-channel attacks, in particular by simultaneously collecting
the power and electromagnetic signals. They demonstrated that integrating such
multiple side-channel signals in the scenario considered in their work will lead
to a two- to three-fold reduction in the requirement of samples needed for a tra-
ditional differential power analysis (DPA) attack [28]. In [38], another combined
side-channel attack was developed by Walter and Thompson which employs pre-
vious techniques for timing attacks in order to exploit useful timing information
from power signals. Note that this combined side-channel attack is applicable
to a pure timing-attack-resistant and pure power-attack-resistant device. Later
on, the efficiency of this integrated attack was enhanced by a factor of five and
generalized considerably by Schindler [33].
3.1 Integrating Block Cipher Cryptanalysis with Side Channels
Though most side-channel attacks apply to full rounds of the cipher, they also
have restrictions. For example, the differential fault analysis (DFA) requires that
the attacker induce faults into some final rounds of a cipher. Faults induced ear-
lier cannot be exploited by conventional DFA attacks. It is therefore reasonable
to consider integrating block cipher cryptanalysis techniques into side-channel
attacks to cover more rounds of the attacked cipher.
Referring to our example of the DFA, its limitation of requiring faults to be
induced in the final rounds of the cipher can be overcome by allowing faults to be
induced much earlier, and then applying block cipher cryptanalysis techniques
to the rounds after where the fault was induced. Later in Section 5, we will show
two examples of such amplified side-channel attacks on the AES, namely the
Square-DFA and Impossible-DFA attacks.
Also in [35, 34], Schramm et al. proposed to overcome limitations of collision
attacks on cipher implementations by using techniques from either the power
analysis [28] or electromagnetic (EM) analysis [1], both of which are side-channel
attacks. In more detail, collision attacks had so far been applied successfully to
hash functions [14] and are essentially variants of the differential cryptanalysis
in that they study the propagation of a collision − which is a non-difference −
between a pair through some internal rounds. Nevertheless, collisions eventually
disappear as the rounds increase, due to the diffusing nature of round functions,
and hence cannot be directly observed at the output. Schramm et al. overcame
this limitation by measuring the power or EM traces of the cipher implementa-
tion in the second round in order to predict whether collisions had occurred in
the first round. To trigger such collisions, they collected sufficiently many chosen
plaintext pairs with certain differences for input to the cipher.
Therefore, the collision side-channel attack proposed by Schramm et al. can
in fact be viewed as the combination of differential cryptanalysis techniques
4.1 Previous DFAs on the AES
Blo¨mer and Seifert [10] first considered the DFA on AES but worked with a re-
stricted fault model. Their first attack required that a certain chosen bit of the
intermediate state just after AR0 be forced to 0, and required 128 faulty cipher-
texts in order to determine the full key. Their second attack is implementation-
dependent, and requires 256 faulty ciphertexts to obtain the full key.
This was followed by two attacks on the AES by Giraud [19]. The first attack
also required to induce a bit fault at the beginning of the last round, R, and
required 50 faulty ciphertexts. The second attack required 250 faulty ciphertexts
and the faults had to be induced on a byte of the round keys, RKR−2, and
RKR−1, and on the intermediate state before the second to last round, R− 1.
Later, Dusart, Letourneux and Vivolo [15] presented another attack that
required a fault to be induced on a byte before MC in the second to last round,
R− 1 and required about 50 faulty ciphertexts.
Chen and Yen [12] improved on Giraud’s second attack to require about 30
faulty ciphertexts. Their attack similarly needed several byte faults to be induced
in the last few rounds, but all on the round keys and none on intermediate states.
In particular, faults had to be induced one at a time on one of four bytes of
RKR−1, followed by faults one at a time on each of 7 bytes of RKR−2. Their
attack model is efficient on AES key schedules that are generated on the fly.
Piret and Quisquater [32] presented two attacks on the AES. Their first
attack required 8 faulty ciphertexts and that a byte fault be induced on the
intermediate state between MC in round R − 2 and MC in round R − 1. Their
second attack requires 2 faulty ciphertexts and that a byte fault be induced on
the intermediate state between MC in round R− 3 and MC in round R− 2.
4.2 Comments on Countermeasures Against DFA
In [12], Chen and Yen presented a DFA on the AES key schedule based on three
stages. The first stage involves inducing a fault in a byte of the 9th round key,
RK9. The next stage involves inducing a fault in a byte of the 8th round key,
RK8. Finally, the last stage involves inducing another fault in a different byte
of the 8th round key, RK8. All in all, the attack requires less than 30 faulty
ciphertexts. Their attack depended on a fault being induced in the middle of the
key schedule, as the round keys are generated on the fly, and hence relies on an
induced fault in a round key inducing further faults on subsequent round keys
and propagating the faults all the way to the ciphertext output.
Therefore, such an attack would have to occur during key accesses, during
which faults are induced as the round keys are generated. Besides this limitation
of their fault model, Chen and Yen also suggested some countermeasures [12].
Their first countermeasure suggests that in order to prevent DFA on the
AES key schedule, round keys should not be generated on the fly, but should
be pre-generated and then stored in memory. This eliminates the need for a key
schedule, and also prevents the DFA attack described in [12].
the property that the XOR of all the 256 ciphertexts would result in a zero for
all byte positions. This is a very interesting property and has been previously
exploited to attack the AES up to 7 rounds [16, 18, 29].
Consider if we use equipment similar to that described in [36] but replaced
with a suitable laser to increase precision, to induce a bit of fault in a byte of
the 6th round key, RK6, and repeating for 255 times, each time inducing one
or more bits of fault into that same byte of RK6 such that it would have all
256 (one correct and 255 faulty) values. These faults will not affect any of the
other round keys. However, they will affect the AES encryption starting from
the 6th round onwards. Therefore at the end of round 6, the 1 correct encryption
and 255 faulty encryptions under these RK6 values would be identical except
for that one byte in which they would all have different values. By the Square
distinguisher, this would propagate through the next three rounds until the end
of round 9 when the XOR of all these 256 texts would result in a zero in all byte
positions. What we have basically done is using the DFA to induce faults into
RK6 so that we can apply a 3-round Square distinguisher from rounds 7 to 9.
We can now guess all possible values of any byte of RK10 and partially
decrypt these 256 (one correct and 255 faulty) ciphertexts by one round up to
the output of round 9, and then check if their XOR gives a zero. The correct byte
value of RK10 will always satisfy this, while a wrong value would only satisfy
this with a very low probability, so it is almost guaranteed that only the right
byte value remains. In the same way, move on to guess all possible values of
another byte of RK10. Repeat this for all 16 bytes of RK10.
In summary, we need 1 correct ciphertext and 255 faulty ciphertexts, which
can be reused for guessing all 16 bytes of RK10. To guess each byte of RK10,
we make 256 guesses of the key byte and do 256 single-round AES encryptions,
so in total 256× 256× 16 = 220 single-round AES encryptions or 220/10 ≈ 216.5
AES encryptions for this DFA-induced Square attack.
Generalizations. Our attack considered inducing faults on one byte of RK6.
It equally applies when faults are induced on the intermediate state between
MCs in rounds 6 and 7, or more generally between the MCs in rounds R − 4 and
R−3. In order to generalize this further, we recall that our attack outlined above
induces the byte faults between the MCs in rounds R− 4 and R− 3, and applies
a 3-round Square distinguisher in the rounds R − 3 to R − 1. In fact, we could
also induce the byte faults a bit deeper into the middle of the AES, in particular
between the MCs in rounds R − 5 and R − 4, in either the intermediate state or
the corresponding round key, and again apply the 3-round Square distinguisher
to the rounds R − 4 and R − 2. Then, to attack the last two rounds, we guess
any column of RK9 and the corresponding 4 bytes of RK10, partially decrypt
our ciphertexts by those last two rounds up to just before round 9 and check
if the XOR is zero in any byte of the column corresponding to that column of
RK9. Repeating this four times, we obtain the entire RK9 and RK10 with the
same number of faulty ciphertexts.
faulty encryption prior to the 7th round. We then apply the 3-round impossible
differential from rounds 7 to 9 up to X, and with this in place, we guess all 232
possible values of the four bytes of the last round key, RK10 that correspond
to any column at X, say the first column, partially decrypt the correct and the
faulty ciphertexts by one round up to X and check if we get any equal bytes in
that column of X. If this is the case, then the guessed values of RK10 are wrong
since they caused the impossible differential to occur. These values are removed
from the list of 232 possible values of RK10. Doing this with one faulty encryption
causes about (1− 2−6)× 232 possible key values to remain2 [6]. Repeating this
with a sufficient number of faulty encryptions, in this case about 211, will leave
232(1− 2−6)211 ≈ 0 wrong key values, so only the correct key value remains [6].
With this, we obtain 4 bytes of RK10 that correspond to that column of X. We
can repeat the same steps for the bytes of RK10 that correspond to the other 3
columns of X, and hence obtain the entire RK10.
To obtain each column of RK10, the attack needs 1 correct ciphertext and
211 faulty ciphertexts which can be reused. Also, to obtain each column of RK10,
we do 232 single-round AES encryptions, so this makes it 234 single-round AES
encryptions or 232/10 ≈ 228.5 AES encryptions.
Generalizations. This can be generalized similarly to Section 5.1, hence the
flexibility of inducing the byte fault in the round key or in the intermediate state
between the MCs in rounds R− 4 and R− 3. However, in contrast to the case of
the DFA and Square attacks, it is not possible to further generalize and make
this attack work when the fault is induced at other locations simply because the
first few rounds of the 3-round impossible differential are in fact probability-one
differentials, so the propagation of the active and passive would always occur
irrespective of the guessed key values, hence cannot be used for filtering wrong
keys. For AES-192 (respectively AES-256), one could consider applying the 4-
round (respectively 5-round) impossible differentials reported by Kim et al. [24].
Discussion. As was the case with our attacks in Section 5.1, our attacks in this
section are the only DFA-style attacks that can be applied to the AES if faults
can only be injected between the rounds R− 4 and R− 3.
6 Concluding Remarks
We have introduced the notion of amplified side-channel attack, and illustrated
specifically with Square-DFA and impossible-DFA attacks on the AES. In Ta-
ble 1, we compare between previous DFAs and our amplified DFA attacks on
the AES. We have indicated in Table 1 the best DFAs based on the fault loca-
tion. Clearly, Dusart, Letourneux and Vivolo’s [15] attack is the best for faults
induced in round R−1 while Piret and Quisquater’s [32] attacks are the best for
2 The probability of getting a passive byte is 2−8 so the probability of getting any
passive byte in a column is 2−6.
References
1. D. Agrawal, B. Archambeault, J.R. Rao, P. Rohatgi, “The EM Side-Channel(s),”
CHES ’02, LNCS 2523, pp. 29–45, Springer-Verlag, 2002.
2. D. Agrawal, J.R. Rao, P. Rohatgi, “Multi-Channel Attacks,” CHES ’03, LNCS 2779,
pp. 2–16, Springer-Verlag, 2003.
3. E. Biham, “New Types of Cryptanalytic Attacks using Related Keys,” Advances
in Cryptology – EUROCRYPT ’93, LNCS 765, pp. 398–409, Springer-Verlag, 1994.
4. E. Biham, A. Biryukov, A. Shamir, “Miss in the Middle Attacks on IDEA, Khufu
and Khafre,” Advances in Cryptology – EUROCRYPT ’99, LNCS 1636, pp. 124–
138, Springer-Verlag, 1999.
5. E. Biham, O. Dunkelman, N. Keller, “The Rectangle Attack – Rectangling the
Serpent,” Advances in Cryptology – EUROCRYPT ’01, LNCS 2045, pp. 340–357,
Springer-Verlag, 2001.
6. E. Biham, N. Keller, “Cryptanalysis of Reduced Variants of Rijndael,” Submitted
to 3rd AES Conference, U.S., 2000.
7. E. Biham, A. Shamir, “Differential Cryptanalysis of the Data Encryption Stan-
dard,” Springer-Verlag, 1993.
8. E. Biham, A. Shamir, “Differential Fault Analysis of Secret Key Cryptosystems,”
Advances in Cryptology – CRYPTO ’97, LNCS 1294, pp. 513–525, Springer-Verlag,
1997.
9. A. Biryukov, D. Wagner, “Slide Attacks,” FSE ’99, LNCS 1636, pp. 245-259,
Springer-Verlag, 1999.
10. J. Blo¨mer, J.-P. Seifert, “Fault Based Cryptanalysis of the Advanced Encryption
Standard,” Financial Cryptography ’03, LNCS 2742, pp. 162–181, Springer-Verlag,
2003.
11. D. Boneh, R.A. Demillo, R.J. Lipton, “On the Importance of Checking Cryp-
tographic Protocols for Faults,” Advances in Cryptology – EUROCRYPT ’97,
LNCS 1233, pp. 37–51, Springer-Verlag, 1997.
12. C.-N. Chen, S.-M. Yen, “Differential Fault Analysis on AES Key Schedule,”
ACISP ’03, LNCS 2727, pp. 118–129, Springer-Verlag, 2003.
13. J. Daemen, V. Rijmen, “AES proposal: Rijndael (version 2),” Updated Documen-
tation and Complete Specification, 1999.
14. H. Dobbertin, “Cryptanalysis of MD4,” Journal of Cryptology, vol. 11, pp. 235–271,
Springer-Verlag, 1998.
15. P. Dusart, G. Letourneux, O. Vivolo, “Differential Fault Analysis on A.E.S.,” IACR
Cryptology ePrint Archive, No. 010, 2003.
16. N. Ferguson, J. Kelsey, S. Lucks, B. Schneier, M. Stay, D. Wagner, D. Whiting,
“Improved Cryptanalysis of Rijndael,” 3rd AES Conference, 2000.
17. S. Furuya, “Slide Attacks with a Known-Plaintext Cryptanalysis,” ICISC ’01,
LNCS 2288, pp. 214–225, Springer-Verlag, 2002.
18. H. Gilbert, M. Minier, “A Collision Attack on 7 Rounds of Rijndael,” 3rd AES
Conference, 2000.
19. C. Giraud, “DFA on AES,” IACR Cryptology ePrint Archive, No. 008, 2003.
20. M. Hellman, S. Langford, “Differential-linear Cryptanalysis,” Advances in Cryp-
tology – CRYPTO ’94, LNCS 839, pp. 17–26, Springer-Verlag, 1994.
21. T. Jakobsen, L.R. Knudsen, “The Interpolation Attack on Block Ciphers,” FSE ’97,
LNCS 1267, pp. 28–40, Springer-Verlag, 1997.
22. G. Jakimoski, Y. Desmedt, “Related-Key Differential Cryptanalysis of 192-bit Key
AES Variants,” SAC ’03, LNCS 3006, pp. 208–221, Springer-Verlag, 2004.
the block cipher, E(P ) = E2(E1(P )) as the composition of two halves3, where
E1 (respectively E2) denotes the earlier (respectively later) half of the cipher.
Then the differential-linear cryptanalysis applies differential cryptanalysis to E1
to enable linear cryptanalysis to be applied to E2. Differential cryptanalysis is
a chosen-plaintext (CP) attack where the attacker needs to obtain encryptions
of plaintexts with a certain chosen difference between them. Meanwhile, linear
cryptanalysis is a known-plaintext (KP) attack in that the attacker simply needs
to be able to obtain some known plaintext values and their corresponding ci-
phertexts. CP attacks that are of the differential cryptanalysis naturally can be
converted to KP attacks but with a considerably high increase in text complex-
ity. In particular, suppose that we need m pairs of CPs with a certain difference
between them. Then with 2n/2
√
2m random KPs, we can form 2n ×m pairs of
KPs, of which the probability of getting a pair with a certain difference is 2−n,
and therefore we get m pairs of CPs with the desired difference [7].
In 2001, Furuya [17] considered combining the slide attacks [9] with KP at-
tacks such as linear cryptanalysis. We consider that such attacks should rightly
be called the slide-KP attacks. These apply the slide attacks to the entire cipher
E to enable KP attacks to be applicable to some outer rounds of E. Slide at-
tacks are generally KP attacks, but if chosen-plaintext queries are possible, the
attacker could mount the slide attacks with a much reduced text complexity.
In 2002, the integral-interpolation attacks [26] where presented, which applies
integral cryptanalysis [26] to E1 to enable the interpolation attacks [21] on E2.
Integral cryptanalysis is a CP attack while interpolation attacks are KP attacks.
Finally, in cases where it is possible for the attacker to obtain the encryptions
of plaintexts under two related keys, K and K ′, he could then mount related-
key versions of any of these block cipher cryptanalysis attacks. Examples of such
considerations include the related-key differential attacks [3], related-key slide
attacks [3], related-key square attacks [16], related-key impossible differential
cryptanalysis [22], and the related-key rectangle attack [25].
As an aside, we note that some attacks have been proposed that apply the
same kind of attacks to both E1 and E2. In this respect, we consider such at-
tacks as a special case of integrated block cipher cryptanalysis. For instance, the
boomerang attack [37] uses chosen plaintexts to mount differential cryptanalysis
to E1 and then enables differential cryptanalysis on E2 by making adaptively-
chosen ciphertext queries from the other end of the cipher. Note that adaptively-
chosen plaintext-ciphertext attacks are much harder to mount than CP or KP
attacks. The amplified boomerang attack [23] and rectangle attack [5] are enhance-
ments of the boomerang attack. They similarly apply differential cryptanalysis
to E1 but the number of chosen plaintext queries used is increased considerably
such that enough texts with the desired chosen difference appear probabilisti-
cally after E1 to allow differential cryptanalysis to be further mounted on E2.
The inside-out attack [37] obtains a high number of known plaintexts such that
enough texts with the desired chosen difference appear probabilistically in the
middle of the cipher so that the difference will propagate outwards in both direc-
3 Not necessarily consisting of the same number of rounds.
