 
中 文 摘 要 ： 本計畫的目的在於透過 JPEG 2000 標準、浮水印及加密等相
關技術之發展，使實現一個符合 JPSEC 標準的資訊安全的超
大型積體電路硬體整合解決方案。加密使得 JPEG 2000 影像
資料可以在通訊頻道上安全地傳送，浮水印可驗證 JPEG 
2000 影像的完整性使保護著作權，JPSEC 則讓 JPEG 2000 影
像資料以能保有原○有特性及優點的方式被使用。為了達成
目標，本計畫包含四部分︰(1) 發展及硬體實現 JPEG 2000 
Codec。(2) 發展及硬體實現浮水印演算法使保護影像著作
權，並且滿足穩定性(robustness)和不可察覺性
(imperceptibility)等浮水印的基本性質。(3) 發展及硬體
實現加密算法讓 JPEG-2000 影像訊息不被駭客竊取。(4) 發
展及硬體實現高性能的 JPSEC 處理器，我們將整合以上所有
成果，使設計及硬體實現具有高速、低功率消耗及即時運作
等優點的 JPSEC 處理器。我們期望這些以 JPEG 2000 為基礎
而研發的訊息保護及安全/技術對保護 JPEG 2000 的數位內容
有所貢獻，我們也期望這些訊息保護/安全技術將可加以擴展
至保護 Motion JPEG 2000 視訊的數位內容。最後，我們相信
參與本研究的相關研究人員將會累積訊息保護/安全的相關技
術，同時可培育具有單晶片系統(SoC)設計能力的人力資源。
中文關鍵詞： 超大型積體電路、單晶片系統(SoC)、JPSEC 處理器、JPEG 
2000、訊息保護/安全、浮水印、加密 
英 文 摘 要 ： The purpose of this project is to develop the 
relevant technology of JPEG 2000 standard, 
watermarking, and encryption to give a total solution 
of VLSI implementation for information security to 
agree to JPSEC. Encryption enables JPEG 2000 image 
data can be transmitted safely on the communication 
channels； watermarking authenticates the integrity 
of image and protects copyright of JPEG 2000 image 
data； meanwhile, JPSEC makes JPEG 2000 image data 
are used by way of being able to preserve their 
characteristics and properties. To achieve such a 
goal, we divide this project into four parts: (1) 
Develop and hardware implement JPEG 2000 Codec. (2) 
Develop and hardware implement watermarking 
algorithms to protect JPEG 2000 authentication and to 
satisfy the basic properties of watermarking such as 
robustness and imperceptibility. (3) Develop and 
hardware implement encryption algorithms to hide JPEG 
2000 image information and to inhibit potential 
1 
行政院國家科學委員會補助專題研究計畫
成果報告   
□期中進度報告 
 
具有內容保護及安全能力的 JPSEC處理器之研製 
 
計畫類別： 個別型計畫  □ 整合型計畫 
計畫編號：NSC  97－2221－E－239－036－MY3 
執行期間：  97年 08 月 01日   至 100年 10 月 31日 
 
計畫主持人：陳榮堅副教授 
共同主持人：陳漢臣副教授、賴瑞麟副教授 
計畫參與人員：(研究生)彭玉成、洪蘇民、林峻堅、(大學生)左仕沛、
莊育丞、彭俊瑋、羅建寬、廖恆輝、謝玟晏、蘇韋郎、張喬富、
王浚宏、江飛龍、王筑霆、邱孙翼、吳百銓、蕭詠謙、沈韋綸、
林建澔、蔡佩容、陳孙嵐 
 
成果報告類型(依經費核定清單規定繳交)：□精簡報告  完整報告 
 
本成果報告包括以下應繳交之附件： 
□赴國外出差或研習心得報告一份 
□赴大陸地區出差或研習心得報告一份 
出席國際學術會議心得報告及發表之論文各一份 
□國際合作研究計畫國外研究報告書一份 
 
處理方式：除產學合作研究計畫、提升產業技術及人才培育研究計畫、
列管計畫及下列情形者外，得立即公開查詢 
          □涉及專利或其他智慧財產權，□一年二年後可公開查詢 
          
執行單位：國立聯合大學電資學院電子工程學系 
 
中   華   民   國 一○○ 年 十二 月 二十八 日 
 
3 
一、中文摘要 
本計畫的目的在於透過 JPEG 2000 標準、浮水印及加密等相關技術之發展，使實現一
個符合 JPSEC 標準的資訊安全的超大型積體電路硬體整合解決方案。加密使得 JPEG 2000
影像資料可以在通訊頻道上安全地傳送，浮水印可驗證 JPEG 2000 影像的完整性使保護著
作權，JPSEC 則讓 JPEG 2000 影像資料以能保有原○有特性及優點的方式被使用。為了達
成目標，本計畫包含四部分︰(1) 發展及硬體實現 JPEG 2000 Codec。(2) 發展及硬體實現
浮水印演算法使保護影像著作權，並且滿足穩定性(robustness)和不可察覺性(imperceptibility)
等浮水印的基本性質。(3) 發展及硬體實現加密算法讓 JPEG-2000 影像訊息不被駭客竊取。
(4) 發展及硬體實現高性能的 JPSEC 處理器，我們將整合以上所有成果，使設計及硬體實
現具有高速、低功率消耗及即時運作等優點的 JPSEC 處理器。我們期望這些以 JPEG 2000
為基礎而研發的訊息保護及安全/技術對保護 JPEG 2000 的數位內容有所貢獻，我們也期望
這些訊息保護/安全技術將可加以擴展至保護 Motion JPEG 2000 視訊的數位內容。最後，我
們相信參與本研究的相關研究人員將會累積訊息保護/安全的相關技術，同時可培育具有單
晶片系統(SoC)設計能力的人力資源。 
關鍵詞：超大型積體電路、單晶片系統(SoC)、JPSEC 處理器、JPEG 2000、訊息保護/安全、
浮水印、加密 
5 
三、前言 
由於電腦與通訊技術的蓬勃發展，數位多媒體或數位內容─文字、數據、影像、圖片、
聲音、動畫、音訊及視訊已可容易地在各種通訊媒介以有線或無線的傳輸，為了充分地使
用通訊資源，工程師們因而依據各種媒體特性發展出眾多的無損失及有損失的壓縮技術，
來減少傳輸資資料量，JPEG 2000 (正式名稱爲 ISO/IEC 15444-1)即是針對靜態影像及圖片
而發展出的新一代壓縮標準。現今，使用者都可很方便地利用通訊頻道傳送與接收數位內
容或存取多媒體資料庫；因此，如何讓數位內容在通訊頻道上安全地傳輸並且安全地儲存
在資料庫內已是一個非常重要的問題。訊息安全(information security)保護著數位內容的所
有權，確保個人或團體的秘密，而且讓使用者以合法合理的方式使用數位內容；因此，訊
息安全相關技術的發展有迫切的必要性。為了因應此一需求，國際標準組織(ISO)下的 JPEG
委員會，制定了 JPSEC (正式名稱爲 ISO/IEC 15444-8) 標準，提供一個標準框架以保護
JPEG 2000 影像資料。 
JPSEC 安全框架提供了 JPEG 2000 壓縮影像的安全服務包括驗證、證明、有條件的存
取和機密性等。JPSEC 標準定義了語法工具提供安全服務所需的參數並且說明安全服務參
數對 JPEG 2000 檔案的影響區域 (也就是 Zone of Influence, ZOI)，JPSEC 標準也提供技術
應用範例說明 JPSEC 標準架構的用法。JPSEC 位元串流可以用三種產生方式，其中之第一
種即是從原始影像產生，第二種則由 JPEG 2000 編碼資料產生，至於第三種乃從另一 JPSEC
位元串流產生。在第一種方法中，編碼和保護運算同時進行，因此 JPSEC 保護工具能存取
原始影像內容，這對於內容驗證將是很重要的。第二種狀況，JPSEC 位元串流由 JPEG 2000
編碼資料產生，適用於對 JPEG 2000 影像資料庫之加密。最後，JPSEC 位元串流可能被從
另一 JPSEC 位元串流產生，這適用於相同內容用多個 JPSEC 保護工具來產生位元串流以供
不同時間由不同的使用者使用。 
JPSEC 標準為了滿足多種安全服務，其保護工具涵蓋廣泛的範圍，包括：加密、數位
簽章、浮水印、註冊權保護等。這些保護工具主要分成兩大類：第一類稱為樣板保護工具
(template protection tools)是大加已熟知的保護工具，第二類則為註冊權保護工具(registration 
authority protection tools)是專用的保護工具，需向 JPSEC 註冊權權當局註冊以取得專用的
識別號碼及私用的參數。就加密保護工具而言，大家所熟悉的 AES、DES、3DES、RC4、
RSA、MD5、SHA-1 等加密方法屬第一類，至於新發展的加密方法則屬第二類。由於 JPSEC
保護工具的涵蓋範圍極為廣泛，這給 JPSEC 設計者很大的發揮空間，設計者可依其需求選
7 
四、研究目的 
本計畫的目的在於透過 JPEG 2000 標準、浮水印及加密等相關技術之發展，使
實現一個符合 JPSEC 標準的資訊安全的超大型積體電路硬體整合解決方案。加密使
得 JPEG 2000 影像資料可以在通訊頻道上安全地傳送，浮水印可驗證 JPEG 2000 影
像的完整性使保護著作權，JPSEC 則讓 JPEG 2000 影像資料以能保有原有特性及優
點的方式被使用。由於 ISO 於 2007 年四月才公告 JPSEC 標準的最後版本，因此現
今尚未有與本計畫相同之論文出現；惟因市場需求龐大且迫切，未來全世界之學術
界與產業界必定會投入大量人力與財力做相關之研究與發展。為了達成目標，本計
畫包含四部分︰(1) 發展及硬體實現 JPEG-2000 Codec。(2) 發展及硬體實現浮水印
演算法使保護影像著作權，並且滿足穩定性(robustness)和不可察覺性(imperceptibility)
等浮水印的基本性質。(3) 發展及硬體實現加密演算法讓 JPEG 2000 影像訊息不被駭
客竊取。(4) 發展及硬體實現高性能的 JPSEC 處理器，我們將整合以上三部分之成
果，使設計及硬體實現具有高速、低功率消耗及即時運作等優點的 JPSEC 處理器。
我們期望這些以 JPEG 2000 為基礎而研發的訊息保護及安全/技術對保護 JPEG 2000
的數位內容有所貢獻，我們也期望這些訊息保護/安全技術將可加以擴展至保護
Motion JPEG-2000 視訊的數位內容。最後，我們相信參與本研究的相關研究人員將
會累積訊息保護/安全的相關技術，同時可培育具有單晶片系統(SoC)設計能力的人力
資源。 
9 
六、研究方法 
本計畫擬把 JPEG 2000、浮水印及加密整合在一貣，使形成 JPSEC 架構，並且
提供超大型積體電路硬體整合解決方案，因此完整架構如圖一所示。它相當於是在
JPEG 2000 Codec 中，加入浮水印嵌入/檢測與加密/解密之機構。 
 
圖一 JPSEC 架構 
 
圖二 JPEG 2000 Codec 系統架構 
 系統架構設計及硬體實現 
(1) JPEG 2000 Codec 之設計與硬體實現 
圖二所示是已商品化的 JPEG 2000 Codec 系統架構圖，我們將以它為本計畫之
基礎架構，加入浮水印技術與加密技術之硬體架構，使整合出 JPSEC Processor 之硬
體架構如。JPEG 2000 Codec 之架構設計與硬體實現重點有 DWT 之架構與實現、量
化器之設計與硬體實現及熵編碼器之設計與硬體實現，我們將分項說明如下。 
甲、 DWT 之架構與實現 
由於傳統 DWT 需要大量的計算，故在 1996 年有專家提出了第二代的小波
11 
 
圖四 以 9/7 濾波器來實現之一維 Lifting Based DWT 之內部架構 
 
圖五 消除邊界效應的一維 Lifting Based DWT 架構範例 
 
圖六 消除邊界效應的一維 Lifting Based IDWT 架構範例 
13 
量化有兩種模式，第一是隱含模式(推導的量化)，它是針對LL子頻帶的量化器，
其餘的量化器再由此LL子頻帶的量化器推導出來，然而明確量化(闡述的量化)需明確
地指定每一子頻帶的量化器。 
在闡述的量化中，每子頻帶的指數/尾數對  bbe , 會放在JPEG 2000編碼串流中。
至於，推導的量化，只有LL子頻帶的指數/尾數對  bbe , 被傳送，其它子頻帶b之量化
器的指數/尾數對  bbe , 則以式(3)計算，其中i是產生子頻帶b之小波解析數。 
   bbb ileveliondecompositnb  ,__, 0                                  (3) 
由於純量量化也允許控制每子頻帶之壓縮準位，因此我們可如 JPEG 一般用品質
因數來控制 JPEG 2000 的壓縮準位。本計畫將純量量化器，我們將依式(1)~(3)來設計
純量量化器，其架構圖如圖九。 
 
圖九 純量量化器架構圖 
丙、 熵編碼器之設計與硬體實現 
如先前所述，本計畫之熵編碼器即是 EBCOT 編碼器，它包含二大部份：第
一層(tier 1)編碼器、第二層(tier 2)編碼器(含位元率控制)。事實上，第一層編碼
器，其功能在於將量化後的編碼區塊進行位元平面編碼；第二層編碼器則依目
標位元率及失真度做最佳化，並捨棄多餘資料，最後將剩餘編碼資料加入標示
資訊包裝貣來形成封包使滿足 JPEG 2000 格式。 
圖十顯示 EBCOT 編碼器架構概念圖。本計畫擬以[35]之 Context modeling
硬體架構(圖十一)為設計基礎，因為此 Context modeling 硬體架構設計引入
CUPS (Clean Up Pass Skipping) 和 PP (Pass Predicting)有效地降低 EBCOT 
15 
水印嵌入前先以環形自同構(Torus Automorphisms)技術將浮水印打散後，再於 JPEG 
2000 量化階段之後輔以失真補償技術藏入；此法不但使影像品質的失真程度大幅降
低，同時在一般影像處理的攻擊下，仍可偵測出浮水印。此外，此法因在量化階段
之後才把浮水印嵌入，因此嵌入資料不受量化的影響。 
為了計畫撰寫之完整性，我們簡要說明其工作原理如下。令 





0
0
v
u
為浮水印圖案
的原始座標且 





n
n
v
u
為打散後的座標，N 為浮水印圖案的長寬，n 為轉換矩陣 





1
11
kk
與 





0
0
v
u
的疊代次數，則 Torus Automorphisms 打散運算式定義如(4)式，所以大小為
3232 的浮水印圖案可用(5)式加以打散。 
N
v
u
kkv
u
n
n
n
mod
1
11
0
0



















                                      (4) 
32mod
21
11
0
0


















v
u
v
u
n
n
n                                                  (5) 
事實上，我們定義n值為打散私鑰。若以(5)式執行 3232 的浮水印圖案的打散，當打
散私鑰n等於3、8、16及24時的圖案變化，如圖十二所示，從圖中可發現當打散私鑰n=24
時會出現與原圖一樣的情況，此即為週期數T，所以用於還原浮水印的迭代次數就等於T減
打散私鑰n，在此我們定義  nT  為還原私鑰。選用不同的打散私鑰n，當然會得不同的還
原私鑰；又若選用不同k值時，會得不同的週期數T，因此會產生不同的打散私鑰與還原私
鑰。 
 
圖十二 打散後的浮水印變化 
打散後的浮水印藏於量化後的頻帶中，而要藏入的頻帶數，需視浮水印的大小而定，
17 
而第三種是把數值一的第4、3、2、1、0位元改為1，如圖十四(d)，其值為 10287 ，最後我們
只頇從此三種數值中選擇與原始係數值最接近的數值來替代原始係數即可，因此就能降低
影像的品質失真度。藏入1時的情況─此部份的修改方式與A.部份的修改規則一樣，但所頇
修改的位元值與藏入0部份相反，修改後的三種侯選數值如圖十四(e)-(g)所示。由圖十四可
知，藏入0的誤差僅為6，而藏入1則完全沒有誤差。 
 
圖十四 具失真補償之浮水印資料藏入技術 
浮水印的萃取是於JPEG 2000解壓縮流程中的解密之後進行取出，只頇根據式(6)算出
bM 即可知由那一位元取出浮水印資料，再依藏入浮水印時的頻帶順序，萃取至係數總數等
於原始浮水印的大小為止，之後再利用Torus Automorphoisms技術與與私鑰來還原取出的浮
水印資料。 
由以上之探討及說明，我們提出浮水印技術與 JPEG 2000 Codec 整合之硬體架構
如圖十五。浮水印資料及打散私鑰分別由 Programming data 端及 Private Scatter Key
端送入 Scrambler 做 Torus Automorphisms 打散運算，產生之打散浮水印資料再依序
送入 Watermarking Processor 以失真補償做資料藏入。 
19 
提供三種區塊大小分別是 128、192 及 256 位元，它們分別對應 10、12 及 14 不同的
Rounds。由於不論區塊大小及 Rounds，AES 均需四種基本加密操作，因此其硬體架
構設計如圖十七所示。本計畫擬引用[36]提供的 AES 硬體核心如圖十八，來做硬體
設計與發展。 
 
圖十七 AES 硬體架構 
 
圖十八 AES 硬體核心範例 
由於計畫主持人在 RCAS 串流加密技術之演算法及硬體實現之發展已稍有心得
[41-51]，因此本計畫引入 RCAS 串流加密技術做為 JPSEC 之專用保護工具。 
RCAS 串流加密技術之演算法簡要說明如下：令   10, 1  LiiF 是 N 位元組成
之字元序列，   10 1  Li,iCAp  是 N 位元組成之金鑰字元序列，則 RCAS 加解密定
21 
 
圖二十 RCAS 串流加密技術之系統架構 
 
圖二十一 RCAS 加解密引擎之硬體架構 
 由以上之說明，我們提出加密技術與 JPEG 2000 Codec 整合之硬體架構設計
如圖二十二。 
23 
串流。圖二十四之範例顯示 JPEG 2000 編碼串流格式與 JPSEC 編碼串流格式之差異
性。 
 
圖二十三 JPSEC 處理器之系統架構 
 
圖二十四 JPEG 2000 編碼串流與 JPSEC 編碼串流之差異 
以下我們將以安全轉換編碼系統說明 JPSEC編碼串流的使用，它提供 JPEG 2000
編碼串流的隱私保護，同時保持 JPEG 2000 編碼串流可伸縮性和轉換編碼得特性[4, 
5]。這使得 JPSEC 編碼串流可安全地轉換編碼，也就是沒有解密的轉換編碼。而且，
這用法描述如何使用驗證，以便於接收者能證實轉換編碼以有效和可允許的方式被
執行。我們也將說明如何用 JPSEC 語法來指示轉換編碼。我們首先對 JPEG 2000 隱
25 
串流，然後被用一把金鑰匙加密形成 JPSEC 編碼串流。這 JPSEC 編碼串流可以被可
被合法的使用者利用適當金鑰解密成為 JPEG 2000 編碼串流，然後再 JPEG 2000 編
碼串流解碼使重建影像。JPSEC 編碼串流也可在不需要金鑰狀況下，被伸縮或安全
轉換編碼成為轉換編碼的 JPSEC 編碼串流。轉換編碼的 JPSEC 編碼串流可被合法的
使用者利用適當金鑰匙解密成為轉換編碼 JPEG 2000 編碼串流，然後被解碼成解析
度較低的重建影像。 
27 
 
圖二十六  依演算法設計之 RCAS 佈局平面圖 
表 2  節省面積之 RCAS 加解密晶片規格表 
CA Encryption & Decryption Chip 
Technology UMC 0.18μm CMOS 1P6M 
Package LCC68 
Die Size 2.612 x 2.612 mm
2
 
Core Size 1.835 x 1.835 mm
2
 
Gate Count 55723 
Max Clock Rate 125MHz 
Throughtput 2G bit/sec 
Power Consumption 25.1676mW @ 1.8V, 125MHz 
Pad Number 64 
Input Pad 35 
Output Pad 20 
Clock Buffer Pad 1 
Power Pad 8 
29 
Encryption/Decryption Control 控制線用來設定晶片是執行加密還是解密的，因此 CA 加解密
晶片是具有加密及解密雙重功能。 
 
圖二十九  CA 系統規劃模擬圖 
D16~D21
Control_WireD
Control_WireUEnable
Data_In
D
0
~
D
7
D
8
~
D
1
5
Data_Out
74LS245 74LS245
Enable
Send / Receive 
Control
Enable
D
0
~
D
7
D
8
~
D
1
5
D
0
~
D
7
D
8
~
D
1
5
P1 P2
P3
Data_Out Data_Out
P4
P7
P8
Time Step, T Clock
Encryption Control
Type Selection
Reconf. Control
Reset
ED Start 74LS
245
P
6
P5
 
圖三十  FPGA 晶片與 DSP 晶片連接電路架構圖 
由於 CA 所規劃出腳位部份有 Clock、Control_WU、Control_WD、Data_In、Data_In_Enb、
Dout、ED、ED Over、ED_Start、Initial Over、Reconf_Control、Reset 和 Type_Select 的資料
線，裡面需要由 DSP 晶片的 EMIF I/O Port 送輸入資料的部分有 Clock、Control_WU、
Control_WD、Data_In、ED、ED_Start、Reset，而執行完 CA 後的加解密資料會由 Dout 資
料線送回到 DSP 晶片的記憶體裡，而可用硬體改變的腳位有 Reconf_Control 和
Type_Select。由於 Control_Wire 需要一個 Clock 就要作上下緣兩次傳送資料設定，等全部
資料設定完畢後，改變成當上源觸發時是送資料到 FPGA 晶片上，下源觸發時會把執行完
CA 運算後的資料送到 DSP 晶片的記憶體上，由於 FPGA 晶片與 DSP 晶片需要同步的時脈
來作影像加解密，而且每一筆資料都不能夠有錯誤，所以需要加上一塊連接板作傳送與接
收資料的判斷，它的整體架構如圖三十，除了用邏輯電路判斷資料的傳輸介面外，還要加
上一個 Buffer 來存取每一個 Clock 所產生的資料，可以不讓影像在高速傳輸下有遺失任何
31 
2. 浮水印及藏密硬體模擬及硬體 IP 實現 
  
圖三十三 單一位元硬體架構 
 
圖三十四 多位元硬體架構 
為了實行硬體加速，以及擁有較佳的私密性，我們將最小誤差浮水印之演算法作
硬體實現。我們將先說明硬體電路之基本架構，由單一位元架構一直衍生到多位元之
架構，且輸出輸入皆為 8 位元。單一位元架構如圖三十三所示，由輸入資料段給檢測
電路作 IMSBs 是否非全為 1 或是否非全為 0 的判斷，輸入多工段則是先處理全加器之
被加數，並判斷 bi-1 是否為 1 或是否非全為 0 且 bi-1 是否為 0 且 bi 是否為藏入資料，
最後檢測電路及輸入多工段所判斷之資訊送由全加器動作，之後再經由輸出多工段處
33 
位元及多位元，多位元檢測電路即是以單一位元衍生而來，將 1~4 位元之檢測電路經
過處理後，再由多工器選擇結果。圖三十五、三十六分別為單一位元之 All_1 及 All_0
檢測電路，圖三十七、三十八則分別為為多位元之 All_1 及 All_0 檢測電路（註：IMSB0
為 b1，IMSB6 為 b7。），其中多位元檢測電路之 em 為藏入資料之選擇線，共有 4 種
狀態，00 為藏入 1 位元、01 為藏入 2 位元、10 為藏入 3 位元、11 為藏入 4 位元。sel
為藏入位置選擇線，最多有 8 種狀態，000 為藏入在 b0 或 b0~b1 或 b0~b2 或 b0~b3，
頇依 em 來作決定，如藏入 4 位元，最高狀態只到 100，及藏入位置為 b4~b7。而如果
藏入 1 位元，最高狀態可到 111，也就是藏入位置指定為 b7。 
 
圖三十七 多位元 All_1 檢測電路 
35 
 
圖四十 2 位元比較器 
 
圖四十一 3 位元比較器 
 
圖四十二 4 位元比較器 
37 
 
圖四十四 b3 藏入 0 的最小誤差電路 
 
圖四十五 b3 藏入 1 的最小誤差電路 
 
圖四十六 b3 藏入 1 位元最小誤差電路 
39 
 
圖五十 隨機藏入/取出多位元的最小誤差電路 
而多位元之致能電路及輸出控制電路分別為圖四十八及圖四十九所示。其中 bi-1 為藏
入位元之上一位元，例如在 b4 藏入 1 位元，則 bi-1=b3。在得到藏入單一位元之總電路後，
我們增加輸入與輸出的多工段以利於多位元資料的輸入、輸出之處理。最後，再加上各種
狀態所需的檢測電路以及比較器電路作判斷即可得到圖五十之隨機藏入/取出多位元的最
小誤差電路。 
我們以 ModelSim 模擬來驗證隨機單一位元及隨機多位元最小誤差電路的藏入功能，
其輸入及輸出皆為 8 位元，並可任意選擇欲藏入之資料位置及資料量，最多可藏入 4 位元。
圖五十一為單一位元最小誤差電路以 ModelSim 模擬之結果，其中 input_data 為 8 位元輸入、
ed 為藏入資料（在此為 1）、sel 為藏入位置（在此為 b2）、output_data 為 8 位元輸出；如
在 200ns 時，輸入為 00001010，在 b2 藏入 1，則輸出為 00000111。圖五十二為多位元最小
41 
率。合成完畢後將其結果做出映像檔並且燒錄進發展系統之FPGA，燒錄完畢後可藉由發展
系統之LCD顯示，然後將藏入後圖片抓取出來與原圖作PSNR比對。 
 
圖五十四 浮水印外部控制電路 
 
圖五十五 藏密外部控制電路 
我們以隨機藏入/取出多位元最小誤差電路為核心，在外部加上簡單的控制電路送資料
進入燒錄在 SCDK 開發板上的電路，即可發展出浮水印與藏密之藏入/取出電路。利用簡易
的指撥開關，我們將欲選擇的狀態送入，以達成整合的效果。浮水印外部控制電路如圖五
十四所示，其中 rgby0 與 rgby1 是浮水印平面切換，em0 與 em1 是藏入量選擇，sel 是藏入
位置選擇。藏密外部控制電路如圖五十五所示，其中 Em1[0]與 Em1[1]是 R 平面藏入量選
擇，Em2[0]與 Em2[1]是 G 平面藏入量選擇，Em3[0]與 Em3[1]是 B 平面藏入量選擇，sel 是
藏入位置選擇。 
利用多位元之函數可以對 8 位元之數位資料作藏入 1 至 4 位元之動作。而若針對 BMP
檔案來說，分別對於 R 平面、G 平面、B 平面與經由 YCbCr 轉換後的 Y 平面做資料藏入之
動作可以是浮水印的一種應用。如在 R 平面藏入 4 位元，即可以將一張 4 位元之 16 色 BMP
43 
 
圖五十八 藏密資料藏入 R、G、B 三平面之流程方塊圖 
我們使用虹晶科技公司的 SCDK 發展系統來實現硬體實作，其架構如圖五十九與圖六
十所示，前者為無需將 RGB 訊號轉換為 YCbCr，後者則需要。浮水印與 HWDATA/HRDATA
之內部電路關係如圖六十一所示，至於藏密與 HWDATA/HRDATA 之內部電路關係則如如
圖六十二，其中 HW 為 HWDATA 且 HR 為 HRDATA。由於 SCDK 採用 ARM926EJ-S 為 
CPU，並且利用 AMBA 2.0 匯流排與周邊設備進行溝通，因此我們先規劃一個 FPGA 與 
AMBA 2.0 的轉接介面，即圖中所示之 Wrapper 模組。AMBA 2.0 規格中含有高效能匯流
排 (advanced high-performance bus, AHB)、系統匯流排 (advanced system bus, ASB) 與週
邊匯流排 (advanced peripheral bus, APB) 三種規格，一般採用 AMBA 2.0 匯流排的典型系
統架構圖如圖六十二所示。多位元最小誤差浮水印硬體架構 1 在電路合成後，所需之硬體
元件使用數如圖六十三，時脈分析結果如圖六十四。 
 
圖五十九 多位元最小誤差浮水印硬體架構一 
45 
 
圖六十二 藏密與 HWDATA/HRDATA 之內部電路關係圖 
 
圖六十三 AMBA 系統架構圖 
 
圖六十四 多位元最小誤差浮水印硬體架構合成元件數 
47 
式的商數，R(x)是餘數，分別可以由長除法推算出： 
111
)1()(

 hlhh sssxsxQ   (16) 
lhlh ssssxR
11
)1()(

 
  
(17) 
將式子(16)和(17)代入(15)並且兩邊一貣乘於 Sh
2，接下來： 
)()())(()(
22
2
2
llhhlhhh ssssxSssxsxps     (18) 
之後式子(18)兩邊同乘於 1
22
)(  llhh ssss  ，我們得到： 
1)())(()(2
2
 xSssxsxps lhhh   (19) 
由於 GF(2)的加法和減法是相同的，式((19)第一個項目可以移動到左側。比較式(15)和
(19)可以觀察得到： 
 )()(1 lhh ssxsXS                                
(20) 
圖六十六顯示了 GF(28)反向器的架構，它將 GF(28)分成為高位元和低位元兩種，開始
降階處理。最後再將其合併輸出。在 GF(28)中 GF(24) (圖六十七)也是分成高低位元，GF(24)
降階後，資料處理之後再合併輸出。圖六十八是 GF(24)降階後之 2 位元的電路，分成高低
位元後，處理之後合併輸出。圖六十九為 2-bit ×φ 電路，圖七十為 GF(24)反向器中的 4-bit
乘法器平方電路。X2(圖七十)是一個 GF(24)乘法器的特例，它們兩個輸入都相同。圖七十
一為 4-bit ×λ 電路，×λ(圖七十一)是常數乘法器，λ=11002。圖七十二為 4-bit 反向器電路，
圖七十三為圖七十二當中的等效子電路，圖七十四為 2-bit 反向器電路。總體來說就是，八
位元降階為四位元，四位元再降階為二位元，二位元降為一位元，最後再彙整貣來輸出。 
Din Isomorphic
Mapping
I
X
2
4
4
4
X
×λ4
4
4
4
X
-1
X
X
Inverse
Isomorphic
Mapping
I
-1
4
4
Reg
Reset
Clk
8
OutNh
Nl
Nh2λ
NhNl+Nl2
Θ
Nh+Nl
(Nh+Nl)Θ
4
NhΘ
8
 
圖六十六  GF(28) 反向器的架構 
49 
×-1
×2 ×φ
2
×
×-1
×
×
2
4
2
2
2
22
2
2
4
 
圖七十二  4-bit 反向器電路 
×2 ×φ
22 2 2 2
 
圖七十三  為上圖當中的等效子電路 
×-1
 
圖七十四  2-bit 反向器電路 
 圖3.1之Isomorphic Mapping (I) 以及 Inverse Isomorphic Mapping (I-1) 分別為: 



























1
1
1
1
1
1
0
0
0
1
0
0
1
0
1
1
1
0
1
1
0
0
0
0
0
1
0
0
0
1
1
0
0
1
1
1
0
1
0
0
0
1
1
1
1
1
0
0
0
1
0
1
1
1
1
1
0
0
0
0
0
0
0
1
I 、



























1
0
0
0
0
1
0
0
1
1
1
1
0
0
0
1
1
0
1
1
1
0
1
1
0
0
0
1
1
1
1
1
0
0
0
0
1
1
0
0
0
1
0
1
1
1
0
1
1
0
1
1
1
1
0
0
0
0
0
0
0
0
0
1
1I
 
               (21) 
圖七十五為Isomorphic Mapping之電路圖，Inverse Isomorphic Mapping為圖七十六，它
們只需使用XOR就可以完成。 
51 
18
1
88 

  MatrixaMatrixb ii                         (22) 
a0
a1
a2
a3
a4 a8 a12
a13a9a5
a14a6
a11
a10
a7 a15
b0
b1
b2
b3
b4 b8 b12
b13b9b5
b14b6
b11
b10
b7 b15
GF(28)-1
+
Affine
 
圖七十七  SubBytes 加密轉換圖 
a0
a1
a2
a3
a4 a8 a12
a13a9a5
a14a6
a11
a10
a7 a15
b0
b1
b2
b3
b4 b8 b12
b13b9b5
b14b6
b11
b10
b7 b15
Affine-1
+
GF(28)-1
 
圖七十八  SubBytes 解密轉換圖 










































































































0
1
1
0
0
0
1
1
1
0
0
0
1
1
1
1
1
1
0
0
0
1
1
1
1
1
1
0
0
0
1
1
1
1
1
1
0
0
0
1
1
1
1
1
1
0
0
0
0
1
1
1
1
1
0
0
0
0
1
1
1
1
1
0
0
0
0
1
1
1
1
1
7
6
5
4
3
2
1
0
7
6
5
4
3
2
1
0
a
a
a
a
a
a
a
a
b
b
b
b
b
b
b
b
                    (23) 










































































































0
0
0
0
0
1
0
1
0
0
1
0
0
1
0
1
1
0
0
1
0
0
1
0
0
1
0
0
1
0
0
1
1
0
1
0
0
1
0
0
0
1
0
1
0
0
1
0
0
0
1
0
1
0
0
1
1
0
0
1
0
1
0
0
0
1
0
0
1
0
1
0
7
6
5
4
3
2
1
0
7
6
5
4
3
2
1
0
b
b
b
b
b
b
b
b
a
a
a
a
a
a
a
a
                   (24) 
Affine 的轉換操作為式                (23)， Inv-Affine 的轉換操作為式              
(24)。Affine 和 Affine 反向器的電路整合如圖七十九。Affine 的轉換被用在 SubBytes 的轉
換，Affine 反向器的轉換被用在 InvSubBytes 的轉換。SubBytes 的轉換在執行時可以選擇
53 
圖八十 8-bit 的(Inv)SubBytes 電路架構圖 
 
圖八十 8-bit 的(Inv)SubBytes 之控制流程說明如下: 
En/De = 0 : → GF(28)Inverter → Affine Transform → Dout 
En/De = 1 : → Inv-Affine Transform → GF(28)Inverter → Dout 
 接著，我們針對 MixColumns 和 InvMixColumns 之間的資源共享做說明。在 GF(28)有
限場中，任意數可以表示為： 
  77
6
6
5
5
4
4
3
3
2
210 xbxbxbxbxbxbxbbb x                      (25) 
8
7
7
6
6
5
5
4
4
3
3
2
2
10 xbxbxbxbxbxbxbxb  與 1)(
348  xxxxxm 做模數運算的結
果為{02}•b(x)，假如 b7=0，則結果正確。假如 b7=1，則結果 overflowed 需加以修正。在
GF(2
8
)有限場中，任意數乘以 2，在 byte 層級上，相當於左移一位元接著與{1B16}做 XOR
運算，我們稱這種運算為 xtime，其電路如圖八十一。由於{04}•b(x)= {02}•({02}•b(x))，其
結果可以從 xtime 執行兩次後獲得如圖八十二。 
i7~i0
X-time
o7~o0
i4i5 i3 i2 i1 i0i6i7
o4o5 o3 o2 o1 o0o6o7
 
圖八十一  8-bit X-time 電路圖 
55 
lb3
lb2
lb1
lb0 E/D
O
i7~i0
X-time
o7~o0
i7~i0
X-time
o7~o0
i7~i0
X-time
o7~o0
i7~i0
X-4
o7~o0
Mux
8 8
8
8
8
o
E/D
lb3 lb2 lb1 lb0
 
圖八十三 32-bit(4-byte)之(Inv)MixColumns 電路圖 
我們整合四個 4-Byte 的 MixColumns 和 InvMixColumns 轉換硬體架構，並對輸入資料
做循環移位，則可用控制訊號 E/D 決定 MixColumns 和 InvMixColumns 輸出的資料。當工
作在加密模式，電路運行在 MixColumns 模式，則輸出的資料就是加密。相反，操作在
InvMixColumns 下，輸出的資料就是解密模式。整合之 16-Byte 的 MixColumns 和
InvMixColumns 如圖八十四。 
57 
k7
k5
k6
k4
k3
k2
k1
k0
d7
d5
d6
d4
d3
d2
d1
d0
o7
o5
o6
o4
o3
o2
o1
o0
 
圖八十六 8-bit 錯誤! 找不到參照來源。電路 
b4
k1
k0a0
a1
kd
o
kd
o
k3
k2a2
a3
kd
o
kd
o
k5
k4a4
a5
kd
o
kd
o
k7
k6a6
a7
kd
o
kd
o
k9
k8a8
a9
kd
o
kd
o
k10a10
kd
o
k11a11
kd
o
k12a12
kd
o
k13a13
kd
o
k14a14
kd
o
k15a15
kd
o
b5b3b2b1b0 b6 b7 b8 b15b13 b14b12b11b10b9
 
圖八十七 128-bit 錯誤! 找不到參照來源。電路 
根據 AES 演算規範，state 的長度在每一個回合是 128 位元，所以一個 128 位元的回合
金鑰是需要從擴展金鑰決定。由金鑰擴展演算法知 128 位元加密金鑰的排程如圖八十八所
示，128 位元密碼金鑰在下一個時間將會產生 128 位元金鑰 K1=W4W5W6W7 錯誤! 找不到
參照來源。。也就是說，W4 用 W0 和 W3 產生，W5 用 W1 和 W4 產生，之後以此類推。 
類似 128 位元密碼金鑰，192 位元密碼金鑰在下一個時間將會產生 192 位元金鑰 K0。
圖八十九顯示了 192 位元加密金鑰的排程。W0 和 W5 產生 W6，W1 和 W6 產生 W7，之後以
此類推。AES-192，將在下一階段產生 192 位元金鑰 K1=W6W7W8W9W10W11，然而，192
位元密碼金鑰的長度不同於其他的 state，每回合的回合金鑰不能從生成的金鑰直接映射。
為了解決這個問題，生成的金鑰列表應重新安排如圖九十，這樣的關係回合金鑰和生成的
59 
W0 W1 W2 W3 W4 W5
W4 W5 W6 W7
W8 W9 W10 W11
W12 W13 W14 W15
W16 W17 W18 W19
RoundKey 1
RoundKey 2
RoundKey 3
RoundKey 4
 
圖九十 192 位元重排加密金鑰排程 
W0 W1 W2 W3
W8 W9 W10 W11
W16 W17 W18 W19
W4 W5
W12 W13
W20 W21
W6 W7
W14 W15
W22 W23
 
圖九十一 256 位元加密金鑰排程 
61 
W8 W9
W14 W15
W4 W5
W6 W7
W0 W1 W2 W3
W10 W11
W12 W13 W16 W17
 
圖九十四 192 位元解密金鑰排程 
W8 W9 W14 W15
W4 W5 W6 W7W0 W1 W2 W3
W10 W11 W12 W13
W16 W17 W18 W19 W20 W21 W22 W23
 
圖九十五 256 位元解密金鑰排程 
金鑰擴展在 AES 標準裡面包含兩種部分，一種是金鑰的排程，另一種是回合金鑰的選
擇。金鑰的排程重點在於 XOR，SubWord 和重整係數值(Rcon)的操作，回合金鑰在生成時
可以離線操作並且儲存在記憶體，又可以飛速的產生。這種方法適合在可以負擔大型記憶
體面積下，應用在不會經常改變初始金鑰，在加密或解密過程當中，回合金鑰不需重新計
算，回合金鑰可以從記憶體當中直接去讀取，以及解密過程中沒有額外的時間延遲。在這
種方式當中，減少 Key Expansion 最長路徑，可以降低解密過程當中的硬體的複雜度。然而，
它不能提升對於初始金鑰需要經常更換的應用之整個系統的速度。 
我們為了消除了金鑰儲存的需求，所以必頇在產生飛速的回合金鑰時，即時的提供給
加密或解密電路。優點是不需要記憶體。解密的時候，解密電路所需要每回合子金鑰時，
則是利用加密電路過程中所計算出來最後合子金鑰，輸入解密金鑰擴展電路，計算出每回
合子金鑰，並即時提供給解密電路。但是我們要付出代價在時間的開銷，因為解密在最後
63 
x3 x2 x1 x0
M3 M3 M3 M3
zi3 zi2 zi1 zi0
y3 y2 y1 y0
Operation
Control
Type2
X
Y
Zi
32
32
32
Operation
Control
 
圖九十七  Key Operator –Type 2 
錯誤! 找不到參照來源。  Type1 的金鑰排程設計 
M3 M2 M1 Operation (Zi) 
0 0 0 Z0 
0 0 1 Z1 
0 1 × Z2 
1 × × Z3 
錯誤! 找不到參照來源。  Type2 的金鑰排程設計 
M3 Operation (Zi) 
0 Z2 
1 Z3 
b3 b2 b1 b0
a3 a2 a1 a0
8 8 8 8
8 8 8 8
 
圖九十八  RotWord 電路圖 
Key Expansion 主要由三種運算所組成，以下敘述如何以硬體電路來實現此三種電路
RotWord(圖九十八)：如同 ShiftRows 的硬體實現方式一樣，用接線就可以完成。SubWord(圖
九十九)：由四個 SubBytes 組合而成，此運算為輸入一個 4-byte 的字組，經過 SubBytes 轉
換後，產生一個 4-byte 的字組。Rcon(圖一○○)：由一個 X-time 乘二電路，迭代產生輸出。
65 
從之前提到，我們知道有一點差異不大的 128 位元、192 位元和 256 位元密碼金鑰去
執行飛速的金鑰排程，這方法在回合功能中，執行回合金鑰的產生。對於簡單的考慮和效
率來說，一個共享的飛速金鑰排程，在不同的金鑰長度是需要的，因此在高效率三合一的
金鑰排程架構是可以接受的。因為 state 的長度是 128，有效三合一金鑰排程使用了以 128
位元的金鑰排程架構當作基礎，然後修改它的架構來符合 192 位元和 256 位元的密碼金鑰。
圖一○一，顯示了重新安排過的金鑰排程之高效三合一金鑰排程。通過正確的密碼金鑰和
回合金鑰，在同一時間我們可以使用只有四個 EKS 去產生 128 位元回合金鑰。在規律的的
金鑰排程，使得執行三種不一樣的金鑰排程在同一個硬體下是容易的。在圖一○一中，金
鑰排程中 MUXs 決定密碼金鑰大小的應用。為了在每一回合生成正確的回合金鑰，128 位
元、192 位元和 256 位元密碼金鑰，四個 EKS 應該如何調節控制需參照表 3。解密時，金
鑰排程也可以很容易找到逆運算。 
 
圖一○一 128/192/256 三合一金鑰排程架構 
最後，我們將說明 AES 之 FPGA 硬體實現。圖一○二為 AES 核心，分成三個部分，
其一為 AES E/D core，另一為 Key Expansion ，最後為 AES 控制電路。圖一○三為 AES
核心的資料流程圖，其中中間部分把它獨立出來，稱之為 Standardround ，Standardround 電
67 
(Inv)ShiftRows (Inv)MixColumns AddRoundKey
Key_in
Clk
(Inv)SubBytes
128
Out
Reset
Data_in
En/Dekey
128
128
圖一○四  Standardround 電路圖 
AES_E/D core
MixColumns
AddRoundKey
Standardround
E
(Inv)SubBytes (Inv)ShiftRows AddRoundKey
Key_in
En/Dekey
Data_in
Reset
Dekey_start
128
E
128
Key_in
128
128
128
En/De
128
128
Clk
Reg1
ClkReg_ctrl1
Ctrl_round
Reset
Reset
Clk
Clk
Reset
128 Out_buffer
out
Clk
E
Reset
128
128
128 128
En/De En/De
128
128
Key_in
Key_in
128
 
圖一○五  AES E/D core 
Key_in
En/Dekey
Reset
Start
Ko1_out
Ko2_out
Ko3_out
Ko4_out
Sel
Key_control
3-in-1 Key ScheduleLoad
128/192/256
Key_State
2
22
128
Clk
KeyExpansion
Key_out
 
圖一○六  AES Key Expansion 
69 
表 4  本計畫 AES 硬體核心相關資料 
Key Length AES-128 AES-192 AES-256 
Freq. (MHz) 175.75 
Memory (BRAMs) 0 
Slices 2,420 
Equiv. Gate Count 
(GC) 
47.6K 
Throughput(Mbps) 681.70(En)/340.85(De) 576.82(En)/288.41(De) 499.91(En)/249.96(De) 
Mbps/Slice 
Mbps/KGC 
0.282(En)/0.141(De) 
14.32(En)/7.16(De) 
0.238(En)/0.119(De) 
12.12(En)/6.06(De) 
0.207(En)/0.104(De) 
10.5(En)/5.25(De) 
Core dynamic 
Power (mW) 
234.33 
 
表5  本計畫AES硬體與其他論文之比較表(請參閱本計畫發表論文[4]) 
Design Device 
Key 
Length 
Freq. 
(MHz) 
Slices BRAMs 
Total 
Equiv. 
Slices 
Throughput 
(Mbps) 
En/De 
Mbps/Slice 
En/De 
Power 
(mW) 
[13] 
XCV800-
6 
128 71.8 9,406 0 9,406 9,184/- 0.976/- - 
[17] 
XCV3200
E-8 
128 54.35 2,222 100 15,022 7,168/- 0.477/- - 
192 45.44 2,577 112 16,913 5,939/- 0.351/- - 
256 39.88 2,995 138 20,659 5,120/- 0.248/- - 
[18] 
XCV1000
E-8 
128 129.2 11,719 0 11,719 16,937/- 1.445/- - 
[19] 
XCV2000
E-8 
128 158 5,810 100 18,610 20,787/- 1.117/- - 
[20] 
XCV1000
-4 
128 31.8 10,992 0 10,992 1,938/- 0.176/- - 
[21] 
XCV3200
E-8 
128 145 15,112 0 15,112 18,560/- 1.228/- - 
[22] XC2VP30 128 142.5 6,211 
1 
(for De) 
6,211/ 
6,339 
1,458/1,458 0.235/0.23 - 
[24] 
XC5VLX
110T 
128 207.9 2,227 13 3,891 
1,163.6/ 
533.3 
0.299/0.137 1284 
[25] 
XC5VLX
110T 
128 146.3 1,057 0 1,057 31.68/31.68 0.03/0.03 265 
Our 
Design 
XC5VLX
110T 
128 
175.8 2,420 0 2,420 
681.70/ 
340.85 
0.282/0.141 
234.33 192 
576.82/ 
288.41 
0.238/0.119 
256 
499.91/ 
249.96 
0.207/0.104 
71 
Anti-Forensic Steganography” has been accepted and should be appeared in Proceedings of 
International Symposium on Biometrics and Security Technologies (ISBAST 2012), Taipei 
Taiwan, 26-29 March, 2012. (EI) 
[14] Rong-Jian Chen, Jui-Lin Lai, and Shi-Jinn Horng, “Anti-Forensic Steganography Using 
Multi-bit Minimum Error Replacement with Flexible Bit Location” has been accepted and 
should be appeared in Proceedings of International Symposium on Computer, Consumer and 
Control 2012 (IS3C 2012), Taichung, Taiwan, 4-6 June, 2012. (EI) 
[15] Rong-Jian Chen, Yu-Cha Chen, Jui-Lin Lai, and Shi-Jinn Horng, “Multi-bit Minimum Error 
Replacement with Flexible Bit Location for Hiding Data” has been submitted to 2012 IEEE 
International Symposium on Circuits and Systems (ISCAS 2012), Seoul, Korean, 20-23 
May, 2012. (EI) 
 
論文[7] 發表時，很受聽講者的重視，因此獲邀請整理成期刊論文轉投Journal of 
Networks Special Issue on Recent Advances in Network and Parallel Computing。修改後的期刊
論文即是 [1]。論文 [8] 被選為NSS2009最佳論文，因此獲邀請整理成期刊論文轉投
Concurrency and Computation: Practice and Experience。修改後的期刊論文即是[4]。 
73 
另外，本計畫有關硬體實現之研究成果大都尚未發表論文，預期有三篇期刊論文及三
篇會議論文可供後續發表。 
75 
Security- An open access journal. 
[19] Meerwald, P., “Quantization Watermarking in the JPEG2000 Coding Pipeline,” 
Communications and Multimedia Security Issues of The New Century, IFIP TC6/TC11 
Fifth Joint Working Conference on Communications and Multimedia Security, pp. 69-79, 
May, 2001. 
[20] Su, P. C. and Kuo, C. C., “Steganography in JPEG2000 Compressed Images,” IEEE 
Transactions on Consumer Electronics, Vol. 49, No. 4, pp. 824-832, Nov., 2003. 
[21] Li, K. and Zhang, X. P., “Reliable Adaptive Watermarking Scheme Integrated with 
JPEG2000,” Proceedings of IEEE 3rd International Symposium on Image and Signal 
Processing and Analysis, Vol. 1, pp. 18-20, Sept., 2003. 
[22] Chen, T. S., Chen, J., and Chen, J G., “A Simple and Efficient Watermarking Technique 
Based on JPEG2000 Codec,” Proceedings of IEEE Fifth International Symposium on 
Multimedia Software Engineering, pp. 80-82 Dec., 2003. 
[23] Yu-Wei Chang, Hung-Chi Fang, Chih-Chi Cheng, Chun-Chia Chen, Chung-Jr Lian, 
Shao-Yi Chien, Liang-Gee Chen, “124MS/s Pixel-Pipelined Motion-JPEG 2000 Codec 
without Tile Memory”, Proceeding of IEEE ISSCC 2006, pp. 1586-1595, Feb. 6-9, 2006. 
[24] Yu-Wei Chang, Chih-Chi Cheng, Chun-Chia Chen, Hung-Chi Fang, and Liang-Gee Chen, 
“124 MSamples/s Pixel-Pipelined Motion-JPEG 2000 Codec Without Tile Memory”, 
IEEE TRANSACTIONS ON CIRCUITS AND SYSTEMS FOR VIDEO 
TECHNOLOGY, Vol. 17, No. 4, pp. 398-406, April 2007. 
[25] Yu-Wei Chang, Chih-Chi Chen, Chun-Chia Chen, Hung-Chi Fang, and Liang-Gee Chen, 
“Design and Implementation of JPEG 2000 Codec with Bit-Plane Scalable Architecture”, 
Proceeding of SIPS’06, pp. 428-433, Oct. 2-4, 2006. 
[26] Hideki Yamauchi, Kenji Mochizuki, Kazuhiko Taketa, Tsuyoshi Watanabe, Tsugio Mori, 
Yuh Matsuda, Yoshifumu Matsushita, Akio Kobayashi, and Shigeyuki Okada, “A 
1440x1080 Pixels 30Frames/s Motion-JPEG2000 Codec for HD Movie Transmission”, 
Proceeding of IEEE ISSCC 2004, pp. 326-339, Feb. 15-19, 2004. 
[27] Hideki Yamauchi,Shigeyuki Okada, Kazuhiko Taketa, Yuh Matsuda, Tsugio Mori, 
Tsuyoshi Watanabe, Yoshihiro Matsuo, and Yoshifumi Matsushita, “1440 1080 Pixel, 30 
Frames Per Second Motion-JPEG 2000 Codec for HD-Movie Transmission”, IEEE 
JOURNAL OF SOLID-STATE CIRCUITS, Vol. 40, No. 1, pp. 331-341, Jan. 2005. 
[28] Lian-Tsung Tsai, “Design and Implementation of JPEG2000 Hardware Architecture and 
Digital Watermark System”, Master Thesis of Department of Electrical Engineering, 
National Central University, 2004. 
[29] Taubman, D. and Marcellin, M. W., JPEG2000: Image Compression Fundamentals, 
Standards and Practice, Kluwer Academic Publishers, 2001. 
[30] Taubman, D., “High Performance Scalable Image Compression,” IEEE Transactions on 
Image Processing, Vol. 9, No. 7, pp. 1158-1170, July, 2000. 
[31] 張真誠、黃國峰、陳同孝，電子影像技術，松崗電腦圖書股份有限公司，2001 年 2
月。 
[32] G. Voyatzis and I. Pitas, “Chaotic Mixing of Digital Image and Applications to 
Watermarking,” Proceedings of European Conference on Multimedia Applications, 
Services and Techniques, Vol. 2, pp. 687-695, May 1996. 
[33] Rong-Jian Chen and Jui-Lin Lai, “Data encryption using non-uniform 2-D von Neumann 
cellular automata,” in the Proceeding of IEEE CNNA 2005, pp. 77-80, Shin-Chu, Taiwan, 
May 28-30, 2005. 
[34] C.J Lian, K. F. Chen, H. H. Chen, and L. G. Chen, \Lifting based discrete wavelet 
transform architecture for JPEG2000", IEEE Inter-national Symposium on Circuits and 
Systems, Sydney, Australia, pp. 445{448, May 2001. 
[35] 林桂蘭，JPEG2000 靜態影像編碼系統之分析與架構設計，國立中央大學電機研究所
碩士論文，93 年 7 月。 
[36] National Institute of Standards and Technology (NIST). Advanced Encryption Standard 
77 
Decryption System Using 2-D Cellular Automata,” in Proceedings of 2006 IEEE 
International Symposium on Consumer Electronics, ISCE 2006, pp. 651-656, St. 
Petersburg, Russia, June 28-July 1, 2006. (EI)【NSC-93-2215-E-239-001】 
[52] C. S. Chen, “Integration and implementation of image encryption/decryption system using 
SCAN and 2-D von Neumann cellular automata,” Master Thesis, National United 
University, 2007. 
This article appeared in a journal published by Elsevier. The attached
copy is furnished to the author for internal non-commercial research
and education use, including for instruction at the authors institution
and sharing with colleagues.
Other uses, including reproduction and distribution, or selling or
licensing copies, or posting to personal, institutional or third party
websites are prohibited.
In most cases authors are permitted to post their version of the
article (e.g. in Word or Tex form) to their personal website or
institutional repository. Authors requiring further information
regarding Elsevier’s archiving and manuscript policies are
encouraged to visit:
http://www.elsevier.com/copyright
Author's personal copy
embedded by quantizing the coefﬁcients in the DCT-block.
Langelaar and Lagendijk (2001) proposed a blind watermarking
approach called differential energy watermarking. A set of several
8  8 DCT-blocks are composed and divided into two parts to
embed a watermark bit. The high frequency DCT coefﬁcients in
the JPEG/MPEG stream are selectively discarded to produce energy
differences in the two parts of the same set.
Kimpan, Lasakul, and Chitwong (2004) proposed a watermark-
ing method for still images in the spatial domain. The watermark
logo is embedded in the original image by modifying the gray-lev-
els of pixels in the original image block to appropriate an intensity
of a block. A semi-blind watermark was proposed by Mahmood
and Selin (2006). The watermark is embedded by a spatially adap-
tive wavelet threshold method to select the coefﬁcients.
Huang and Yang (2004) proposed a watermarking algorithm
based on the DWT. The original image is separated into m blocks,
each of size n  n; then every block is decomposed into a wavelet
domain. The watermark is embedded in the wavelet coefﬁcients in
the middle and low subbands of a block in each image. Kheliﬁ,
Bouridane, Kurugollu, and Thompson (2005) proposed an adaptive
blind watermarking technique based on the DWT. The original im-
age is separated into non-overlapping blocks classiﬁed as uniform
or non-uniform blocks using a JND-based classiﬁer. The watermark
is embedded in the high subband of each block which is trans-
formed into the DWT according to its classiﬁcation. Zhang, Wang,
and Wen (2004) divided the original image into n n blocks and
transformed them into a DWT domain. The watermark is embed-
ded by using the mean and the variance of a subband to modify
the wavelet coefﬁcient of a block.
Lien and Lin (2006) proposed a wavelet-based blind watermark-
ing scheme. The wavelet coefﬁcients of the host image are grouped
into wavelet trees, and each two watermark bits are embedded
using four trees. According to the binary value of two watermark
bits which are embedded, one of the four trees is quantized with
respect to a quantization index, and four trees exhibit a large sta-
tistical difference between the quantized tree and the unquantized
tree; the difference can later be used for watermark extraction. For
the existing methods listed in Cox et al. (1996, 1997), Podilchuk
and Zeng (1998), Chen et al. (2000), Tachibana et al. (2004), Wu
and Hsieh (2000), Zhou et al. (2006), Duan et al. (1998), Kwon
et al. (1999), Thiemert et al. (2004), Yang et al. (2004), Langelaar
and Lagendijk (2001), Kimpan et al. (2004), Mahmood and Selin
(2006), Huang and Yang (2004), Kheliﬁ et al. (2005), Zhang et al.
(2004) and Lien and Lin (2006), the original image is lossy since
the original coefﬁcient is modiﬁed by quantizing the coefﬁcient
of the image in the embedding process. Moreover, these methods
are not strong enough to resist geometric attacks, such as rotation
and print–photocopy–scan. Chen, Horng, and Lee (2005) proposed
a blind and lossless wavelet-based copyright protection scheme.
The wavelet coefﬁcients of the low frequency are compared with
the average coefﬁcient of the low frequency to generate the feature
value. Then the feature value is XORed with watermark bits to gen-
erate the veriﬁcation key to the trusted third party, which is called
a certiﬁcation authority. The veriﬁcation process (through the
trusted third party) arrives at non-repudiation of the extracted
watermark. Lou, Tso, and Liu (2006) improved Chen et al.’s method
by adding the torus automorphism to scramble the original image
to promote security.
Packet losses or packet errors often occur in data communica-
tion. Forward error correction (FEC) is an error correction tech-
nique to compensate packet loss in the Internet (Aikawa,
Motoyama, & Umehira, 1996; Ayanoglu, Pancha, Reibman, &
Talwar, 1996; Davis, Danskin, & Xiyong, 1996; Kousa & Turner,
1993; Nakayama & Aikawa, 1997; Noguchi, Yamamoto, & Ikeda,
2001; Puri, Ramchandran, Lee, & Bharghavan, 2001; Rosenberg &
Schulzrinne, 1999; Tan & Zakhor, 2001; Viterbi, 1976); especially
in real-time multimedia which has a strict delay requirement, such
as video transmission (Ayanoglu et al., 1996; Puri et al., 2001; Tan
& Zakhor, 2001), and voice or audio application (Rosenberg &
Schulzrinne, 1999). FEC is also applied in wireless communication
(Aikawa et al., 1996; Ayanoglu et al., 1996; Nakayama & Aikawa,
1997; Rizzo & Vicisano, 1998), since wireless communications,
which usually are with higher packet loss rates and lower trans-
mission rates, are more unreliable than transmissions by wire
communications. FEC adds the redundant information to the pack-
et in a transmission to achieve the objective of error correction and
high reliability. In the Bluetooth technique, the header information
is protected with a 1/3 rate forward error correction (The Bluetooth
Special Internet Group; Haartsen, 1998; Haartsen et al., 1998), and
the receiver subsequently uses majority voting to decide the value
of the bit which has been transmitted. The 1/3 rate forward error
correction means that one bit is transmitted thrice.
Digital signature can ascertain the source and content of infor-
mation via auditing and tracing back. It can provide integrity, non-
repudiation, authentication, and conﬁdentiality. Timestamp can
trace back and provide a time certiﬁcation by trusted third party
(Stallings, 2005). By the digital signature and timestamp, the digi-
tal content can be effectively protected in copyright protection.
In this paper, we propose a copyright protection scheme using
the 1/T rate FEC for resisting malicious attacks, where T is the times
of data redundancy. The feature value, which we call the B-map
(binary map) table, is created and is the same as that in (Chen
et al., 2005); subsequently the B-map is divided into T blocks.
The watermark logo is spread over all the blocks of the image,
whose size is the total size of the watermark logo and the noise
bits. We generate the protection key through the watermark logo
fused with the noise bits and XORed with the feature value of
the image by the 1/T rate FEC. In the veriﬁcation process, the
extraction of the watermark needs neither the original image nor
the watermark logo, and the watermark bits are determined by
majority voting. The non-repudiation of the extracted watermark
uses the protection key stored in the trusted third party to verify
whether the image is legal or not. Since the proposed method is
based on the spatial domain, it can reduce the computation time
when the image in the spatial domain is transformed to the fre-
quency domain. Experimental results show that the proposed
method can effectively resist common geometric and nongeomet-
ric attacks.
This paper is organized as follows: the image protection and
veriﬁcation using the 1/T forward error correction are described
in Section 2. The experimental results and discussion are given in
Section 3. Finally, the conclusions are summed up in Section 4.
2. The proposed method
In the propose method, we do not transfer the protected images
to frequency domain, and hence it can reduce the computation
time of embedding and extraction process. In order to raise secrecy
and confusion of a watermark, and to make the embedded infor-
mation more difﬁcult to be detected by attackers, noise bits are
used. After embedding, the proposed watermark scheme will gen-
erate a veriﬁcation key which will be used to register to a trusted
third party with digital signature and time stamp. The register pro-
cess can provide integrity, non-repudiation, authentication, and
conﬁdentiality. If there is any dispute, the digital signature and
time stamp can be used to verify the copyright image and water-
mark. Since the error correction via 1/T rate and the watermark bits
are distributed everywhere in an image, the watermark can be ex-
tracted accurately. The proposed watermarking scheme is lossless
and robust for application in copyright protection.
The detailed description of algorithms for the image protection
and veriﬁcation are is stated as follows.
W.-H. Lin et al. / Expert Systems with Applications 36 (2009) 11888–11894 11889
Author's personal copy
where the value of T and the size of a block are the same as those
deﬁned in Eqs. (9) and (10). Perms2()1 denotes the inverse func-
tion of Perms2() with seed s2.
Step 6. Use the majority vote to decide whether WE0 is bit 1
or bit 0.
WE0 ¼ MajorVðBlockPt Þ; 1 5 t 5 T: ð22Þ
where WE0 ¼ we0m;njwe0m;n 2 f0;1g; 0 <m < 2WW ; 0 6 n <WH
n o
,
the MajorV function determines the maximum number of bit 0
and bit 1 of the same position of BlockPt , 1 5 t 5 T. For example,
the number of bit 1 at position (1,1) of every block is 10, and the
number of bit 0 at position (1,1) of every block is 22. After MajorV
function, we01;1 is turned out to be bit 0.
Step 7. Split the watermark bits and noise bits from WE0 to get
watermark bits.
We ¼ SplitðWE0Þ: ð23Þ
The function Split() is the inverse function of Eq. (5).
Step 8. Inverse We to form the watermark logo W0.
W 0 ¼ Perms1ðWeÞ1: ð24Þ
where Perms1()1 denotes the inverse function of Perms1() with
seed s1.
3. Experimental results and discussion
3.1. Experiment results
Like other researchers, we use the peak signal-to-noise ratio
(PSNR) to evaluate the quality between an attacked image and
the original image. For the sake of completeness, the PSNR is for-
mulated as follows:
PSNR ¼ 10 log10
255 255
1
IHIW
PIH1
x¼0
PIW1
y¼0 i x; yð Þ  i0 x; yð Þ
	 
2 dB; ð25Þ
where IH and IW are the height and width of the image, respectively,
and ix,y and i
0
x;y are the gray level coefﬁcients located at coordinate
(x,y) of the original image I and the attacked image I0, respectively.
After extracting the watermark, the normalized correlation
coefﬁcient (NC) is computed using the original watermark and
the extracted watermark to judge the existence of the watermark
in order to measure the correctness of an extracted watermark. It
is deﬁned as follows:
NC ¼ 1
WH WW
XWH1
i¼0
XWW1
j¼0
wi;j w0i;j; ð26Þ
where WH and WW are the height and width of the watermark. wi,j
and w0i;j are the values located at coordinate (x,y) of the original
watermark W and the extracted watermark W0. Here wi,j is set to
1 if it is watermark bit 1; otherwise, it is set to 1. w0i;j is set in
the same way. So the value of wi,j  w0i;j is either 1 or 1.
We use the Lena image (512  512 pixels, 8 bits/pixel) as the
test image in our experiments. The size of the binary watermark
logo is 64  64, and the value of T is 32. For attacking, we use
the Stirmark benchmark (Petitcolas, 1997) and PhotoImpact 11
software tools to simulate common image attacks; the original
Lena image and binary watermark are shown in Fig. 1.
In the following experiments, we consider both geometric and
nongeometric attacks. Nongeometric attacks include JPEG com-
pression, low-pass ﬁltering, histogram equalization, and sharpen-
ing. The experimental results show that the watermark logo can
still be recognized clearly.
JPEG is one of the most used formats in the Internet and digital
cameras. The JPEG quality factor is a number between 1 and 100
and associates a numerical value with a particular compression le-
vel. When the quality factor is decreased from 100, the image com-
pression is improved, but the quality of the resulting image is
signiﬁcantly reduced. In Table 1, the quality factors of the JPEG
compression is 1, and we can also extract the watermark logo
completely.
For other nongeometric attacks (Petitcolas, 1997), there are
median ﬁltering, Blurring, sharpening, and histogram equalization.
After these attacks, the resulting images are blurred or sharpened
on the edge (Gonzalez &Woods, 2002); the proposed method is ro-
bust in resisting attacks and correctly extracts the watermark logo
(see Table 2).
We also use other attack methods such as rotation, scaling,
Gaussian noise, print–photocopy–scan, and cropping to conduct
geometric attacks. For the rotation attack, the image is rotated at
6 (Petitcolas, 1997). For the scaling attack, an image of size
512  512 is ﬁrst scaled to 16  16 via PhotoImpact 11 software,
then the scaled image is opened and resized to 512  512. For
the Gaussian noise attack, the variance of noise is 15; for print–
photocopy–scan, we print the Lena image using a laser printer
(HP LaserJet 9000); then the image which was photocopied is re-
scanned by a scanner within 75 dpi and 256 gray-level and resized
to 512  512 pixels. For the cropping attack, an image of 1/4 size is
cropped via PhotoImpact 11 software (see Tables 3 and 4).
We combine various kinds of attacks in our experiments to test
our proposed method, such as scaling + cropping (the test image is
scaled from 512  512 to 670  670 pixels, then we cut the edge
area of the test image to form the 512  512 test image); we also
combine blurring + noise, blurring + JPEG, print–photocopy–
scan + sharpening, print–photocopy–scan + scaling, and scal-
ing + JPEG. After these attacks, the retrieved watermark logo can
still be recognized clearly (see Table 5).
In Table 6, we compare the proposed method to Chen et al.’s
(2005) and Lou et al.’s (2006) methods to demonstrate the robust-
ness of our method. In the experiment, the Lena image (512  512
pixels, 8 bits/pixel) is used. The watermarked image is attacked (by
blurring, JPEG, Noise, sharpening, print–photocopy–scan, and scal-
ing attacks) more seriously than that in Chen et al.’s and Lou et al.’s
methods; although our PSNRs are lesser than theirs, the value of
NC under each attack is still 1. In other attacks (rotation, cropping,
and cropping + scaling), all parameters are set to the same as those
in Chen et al.’s method; that is, for the rotation attack, the image is
rotated at 2, for the cropping attack, the image is cropped by 1/4,
and for cropping + scaling attack, the image is scaled from
512  512 pixels to 560  560 pixels, then the edge area of the test
image is cut to form the 512  512 test image. As you can see, the
values of PSNRs of our method are quite closer to those in Chen
et al.’s method; the value of NC under each attack is always higher
Fig. 1. (a) The original image of Lena of size 512  512. (b) The original binary
watermark of size 64  64.
W.-H. Lin et al. / Expert Systems with Applications 36 (2009) 11888–11894 11891
Author's personal copy
method can also be applied to the color image. The watermark bits
can be embedded based on the RGB color values of the image. Fur-
thermore, the proposed method is based on the spatial domain; it
can reduce the computation time in which the image in the spatial
domain transforms to the frequency domain. Hence, the proposed
method can be applied to the video stream.
4. Conclusions
In this paper, copyright protection based on 1/T forward error
correction for digital images is proposed and the watermarked im-
age is lossless. Each feature value is generated by its corresponding
gray-level of the image; subsequently the feature value is XORed
with the embedding bits. In the veriﬁcation process, the water-
mark bits can be extracted by majority voting without either the
original image or the watermark logo. The experimental results
show that the proposed method is robust resisting common non-
geometric attacks, and is also strong enough to resist the geometric
attacks, while the retrieval watermark logo is still clearly recogniz-
able. The watermarking scheme based on spatial domain is faster
than that based on frequency domain since the step of transferring
to frequency domain is not needed. In addition to copyright protec-
tion, the proposed method can also be applied to image
authentication.
Table 4
Normalized correlation coefﬁcients (NC) upon attacks of print–photocopy–scan, blurring + JPEG, and scaling + JPEG.
Table 6
Comparison with Lou et al.’s (2006) and Chen et al.’s (2005) methods.
Attack Lou et al.’s method Chen et al.’s method Proposed method
PSNR NC PSNR NC PSNR NC
Blurring 25 0.99 29 0.99 20 1
JPEG 24 0.98 31 0.98 22 1
Noise 28 0.99 30 0.99 16 1
Sharpening 28 0.99 28 0.99 14 1
Scaling 21 0.98 29 0.99 20 1
Rotation 8 0.93 14 0.82 13 0.99
Print–photocopy–scan 7 0.94 19 0.90 9 1
Cropping 5 0.92 11 0.87 11 0.98
Cropping + scaling 9 0.93 16 0.80 15 1
Table 5
Normalized correlation coefﬁcients (NC) upon attacks of blurring + noise, print–photocopy–scan + sharpening, histogram equalization, and scaling–cropping.
W.-H. Lin et al. / Expert Systems with Applications 36 (2009) 11888–11894 11893
Novel Stream Cipher Using SCAN and Variable 
Ordered Recursive CA Substitutions and Its 
DSP+FPGA Implementation 
Rong-Jian Chena,*, Jui-Lin Laia, and Shi-Jinn Hornga, b 
a Department of Electronic Engineering, National United University, Taiwan 
rjchen@nuu.edu.tw, jllai@nuu.edu.tw
b Department of Computer Science and Information Engineering, National Taiwan Univ. of Sci. and Tech., Taiwan 
horngsj@yahoo.com.tw
Abstract—This paper presents a new stream cipher for 
data security, which is based on permutation of the data 
and replacement of the data values. Permutation is done 
by scan patterns generated by the SCAN approach. The 
replacement of data values using variable ordered 
recursive cellular automata (CA) substitutions. To achieve 
this aim, an encryption-specific SCAN technique was 
firstly developed, 2-D hybrid CA was next built, and then 
1st-ordered and 2nd-ordered generalized CA transforms 
were introduced to build variable ordered recursive CA 
substitutions. The proposed stream cipher satisfies the 
properties of confusion and diffusion because of 
characteristics of the SCAN and the CA substitutions are 
flexible. Moreover, the characteristics of the proposed 
stream cipher are loss-less, symmetric private key, very 
large number of security keys (number of possible 
security keys is more than 956810  ~ 1478510  - according 
to the size of the 2-D von Neumann CA), and 
key-dependent pixel value replacement. Experimental 
results obtained using some color images clearly 
demonstrate the strong performance of the proposed 
stream cipher. This paper also shows the DSP+FPGA 
implementation of the proposed stream cipher for the 
real-time image security. 
Index Terms—Stream cipher, SCAN, Variable ordered 
recursive CA substitutions, DSP+FPGA implementation 
I. INTRODUCTION 
With the ever-increasing growth of multimedia 
applications, data security is an important issue in 
communication and storage of data, and encryption is 
one the ways to ensure security. Data security has 
applications in inter-net communication, multimedia 
systems, medical imaging, telemedicine, and military 
communication. There already exist several methods of 
data security. They include SCAN-based methods [1-5], 
chaos-based methods [6-8], tree structure-based 
methods [9-11], and other miscellaneous methods 
[12-15]. However, each of them has its strength and 
weakness in terms of security level, speed, and 
resulting stream size metrics. We therefore proposed a 
new method of data security to overcome these 
problems. The proposed data security belongs to stream 
cipher which encryption method is based on 
permutation of the data and replacement of the data 
values. Permutation is done by scan patterns generated 
by the SCAN approach, the SCAN approach described 
in [5] is used because it produces a high volume of 
scan pattern. The data values are replaced using the 
variable ordered recursive CA substitution with a 
sequence of CA data that is generated from 2-D hybrid 
CA with special evolution rules. The advantages of CA 
in the proposed data security are described as follows. 
(1) CA has been applied successfully to several 
physical systems, processes, and scientific problems 
that involve local interactions as in image processing 
[17], data encryption [18, 19], byte error correcting 
code [20]; it has also been used in pseudorandom 
number generators for VLSI built-in self-test [21]. (2) 
Number of CA evolution rules is very large. Hence, 
many techniques are available for producing a 
sequence of CA data for encrypting and decrypting data. 
(3) Recursive CA substitution only requires integer 
arithmetic and/or logic operations simplifying the 
computation.  
The proposed data security also belongs to the case 
of the general framework called iterated product cipher 
[4, 22, 23], which is based on repeated and intertwined 
application of permutation and substitution. This 
* Corresponding author. Email: rjchen@nuu.edu.tw 
* Manuscript received December 1, 2008; revised March 24, 2009; 
accepted April 18, 2009. 
JOURNAL OF NETWORKS, VOL. 5, NO. 1, JANUARY 2010 75
© 2010 ACADEMY PUBLISHER
doi:10.4304/jnw.5.1.75-87
recursively compose simple scan patterns to obtain 
complex scan patterns. Figure 1 shows eight basic scan 
patterns, which are used in computer simulation and 
can be extended or reduced according to the need of a 
particular application. Transformations include 6 basic 
operations (identity, horizontal reflection, vertical 
reflection, rotation by 
$90 , $180 , and $270 ) and 
their combinations. The rules for building complex 
scan patterns from simple scan patterns are specified by 
the production rules of the grammar of each specific 
language. Readers are referred to [1-5] for a detailed 
description of syntax and semantics of SCAN 
languages and their applications. 
In the proposed encryption method, the scanning 
patterns are used as the encryption keys to rearrange 
pixels of the image. The scanning patterns are 
generated by an encryption-specific SCAN language 
[16] which is formally defined by the grammar 
 3$6* ,,,H  where ^ `T,V,U,P,S,A *  are 
non-terminal symbols,  6 {r, c, d, l, a, i, t, w, B, Z, X,
(, ), space, 0, 1, 2, 3, 4, 5, 6, 7} are terminal symbols, A
is the start symbol, and production rules3 are given by 
P|SA o , UTS o ,  AAAAVTP o ,
w|t|i|a|l|d|c|rU o , X|Z|BV o , and 
76543210 |||||||T o . The semantics of the 
encryption-specific SCAN language is described as 
follows. P|SAo : Process the region by scan S or 
partition P. UTS o : Scan the region with scan 
pattern U and transformation T. Each of scan patterns 
has eight transformations (Figure 2) which are defined 
as: 0: Identity. 1: Horizontal reflection. 2: 
$90
clockwise rotation. 3: 
$90  clockwise rotation 
followed by vertical reflection. 4: 
$180  clockwise 
rotation. 5: Vertical reflection. 6: 
$270  clockwise 
rotation. 7: 
$90  clockwise rotation followed by 
horizontal reflection.  AAAAVTP o : Partition the 
region with partition pattern V and transformation T,
and process each of the four sub-regions in partition 
order using As from left to right. Figure 2 shows that 
partition patterns were divided into 3 groups: B, Z, and 
X, each group has eight transformations as that of scan 
patterns. w|t|i|a|l|d|c|rU o : Scan with a 
specific scan pattern as in Figure 1, the letters r, c, d, l,
a, i, t, and w in Fig, 1 indicate the type of scan patterns. 
X|Z|BV o : Partition with a specific partition group 
B, Z, or X as in Figure 2. 76543210 |||||||T o : Use 
one of the eight transformations for a scan or a 
partition. 
Figure 3 shows the scanning path of the scan pattern 
X3(c2 Z2(d0 w2 a4 l1) t0 i4) for a 1616u  image. The 
image is first partitioned into four sub-regions using X3
partition order. These four sub-regions are scanned 
using c2, Z2(d0 w2 a4 l1), t0, and i4. The second 
sub-region is further portioned into four sub-regions 
using Z2 order and these four sub-regions are scanned 
using d0, w2, a4, and l1.
Figure 3. Example of the scan pattern X3(c2 Z2(d0 w2
a4 l1) t0 i4) 
B. 2-D Hybrid CA 
Cellular automata are dynamic systems in which 
space and time are discrete. The cells, as arranged in a 
regular lattice structure, have a finite number of states. 
These states are updated synchronously according to a 
specified local rule of neighborhood interaction. The 
neighborhood of a cell refers to the cell and some or all 
of its immediately adjacent cells. In 2-D CA space, the 
specified node P, with its four nearest neighbors form 
the von Neumann neighborhood. Figure 4a shows the 
2-D von Neumann CA space. The state of the given 
node at time step (t+1) will be determined from the 
states of nodes within its neighborhood at time step t.
Using a specified rule, the states are updated 
synchronously in time steps for all cells. Let  
t
ji,a
represent the state of (i,j)th cell at time t, whose von 
Neumann neighborhoods are in the states:  
t
ji ,1a  ,
 
t
ji 1,a  ,  
t
ji ,1a  , and  
t
ji 1,a  . Then the rule 
of 2-D von Neumann CA evolution way can be 
expressed as 
     
      
ttt
ttt
jiajiajia
jiajiaFjia
,1,1,,,.
,1,,,1,
1

 
,         (1) 
where F is a Boolean function that defines the rule. 
Readers are referred to [17-21] for a detailed 
description of 2-D von Neumann CA. 
The hardware implementation of Eq. (1) for 1-bit 
2-D von Neumann CA is shown in Figure 4b. Such a 
structure is referred as a programmable additive CA 
(PACA) due to it is implemented using EXOR gates. 
Using the 1-bit 2-D von Neumann PACA structure, one 
can build the desired hybrid NN u -bit cellular 
automata [27-29]. It costs NNN 46 22   bits to 
assign boundary condition, rule control, and initial data 
JOURNAL OF NETWORKS, VOL. 5, NO. 1, JANUARY 2010 77
© 2010 ACADEMY PUBLISHER
     1,,2  iCAiCAiE pp  in Eq. (3) means that 
 1iE ,  2iE ,  iCAp , and  1iCAp  execute 
the 2nd-ordered GCAT. Reversing the operations of the 
recursive CA encryption is to perform the recursive CA 
decryption. The 1st-ordered and the 2nd-ordered 
recursive CA decrypted substitutions can be expressed 
as Eqs. (4) and (5) respectively. Notably, the 
generalized CA transforms 
      1,11  iCAiCAiEGCAT pp and 
        1,,2,12  iCAiCAiEiEGCAT pp for 
encryption and for decryption are identical. Since the 
CA encryption/decryption scheme is lossless, the 
sequence of N-bit decrypted data   10, 1 dd LiiD  is 
identical to the original sequence   10, 1 dd LiiF .To 
achieve the goal of data security, we further develop 
the scheme of CA encryption/decryption (stream cipher 
system) as Figure 6, where the CA generating scheme 
shown in dash-line block is controlled by CA key to 
generate N-bit CA data sequence   10, 1 dd LiiCAp
for CA substitution. For CA encryption, the 
encryption/decryption control bit is set as 1; 
simultaneously, the input is a sequence of N-bit data 
and the output of recursive CA-encrypted substitution 
is a sequence of N-bit encrypted data. 
TABLE 1. 
GENERALIZED CA TRANSFORM (GCAT) 
Groups Operations 
Type selection 
control bits 
T4T3T2T1T0
1:     iCA,iEGCAT p11        Np modiCALSiE 21 1  000xx
2:     iCA,iEGCAT p11        Np modiCALSiE 21 1  001xx
3:     111  iCA,iEGCAT p       Np modiCALSiE 211 1  010xx
4:     111  iCA,iEGCAT p       Np modiCALSiE 211 1  011xx 
1:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2121 21  10000
2:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2121 21   10100 
3:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2211 21  11000 
4:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2211 21  11100 
5:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2121 12  10010
6:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2121 12  10110 
7:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2211 12  11010 
8:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2211 12   11110 
9:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2112 21  10001
10:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2112 21  10101
11:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2112 21  11001 
12:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2112 21  11101 
13:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2112 12  10011 
14:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2112 12   10111 
15:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2112 12  11011 
16:         1212  iCA,iCA,iE,iEGCAT pp            > @ Npp modiCALSiEiCALSiE 2112 12  11111 
1st-ordered CA encryption:           > @ 102111 1 dd Li,modiCAiCA,iEGCATiFiE Npp ;      (2) 
2nd-ordered CA encryption:             > @ 1021212 1 dd Li,modiCA,iCA,iE,iEGCATiFiE Npp .  (3) 
1st-ordered CA decryption:           > @ 102111 1 dd Li,modiCAiCA,iEGCATiEiD Npp .        (4)
2nd-ordered CA decryption:             > @ 1021212 1 dd Li,modiCA,iCA,iE,iEGCATiEiD Npp .  (5) 
JOURNAL OF NETWORKS, VOL. 5, NO. 1, JANUARY 2010 79
© 2010 ACADEMY PUBLISHER
is compact in representing and generating a specific set 
of permutations. In summary, in the computer 
simulation, 
  WnNNNn u 46 222 possible groups of NT u
N-bit generalized CA data were used. Notably, the 
proposed system specifies four data types and N252 
GCAT types. The basic idea of the proposed stream 
cipher system is that it uses a specified key to generate 
a key-stream and use it to encrypt a plaintext string 
according to Eqs. 2 and 3. We hence choice the length 
of key-stream at least equals to the length of plaintext 
to match the goal of security. Additionally, we know 
that the length of a CA state cycle is very important in 
determining the suitability of the CA as a generator of 
random numbers. According to [30], the average cycle 
length for 2-D NN u -cell dual-state von Neumann
CA increases exponentially and is on the order of 
322 N  for 8N  or 4
2
2 N  for 8tN . Therefore, 
we have to choose a suitable 2-D NN u -cell CA to 
produce high quality key-stream for encryption 
according to the size of image. The relationship 
between the image size and the minimum size of a 
suitable 2-D CA is described as follows. If an image is 
with size of 21 22
nn u  want to be encrypted, then the 
minimum size of a suitable 2-D CA is with size of 
ª º ª º33 2121 u nnnn   for ª º 8321  nn
or ª º ª º44 2121 u nnnn  for 
ª º 8421 t nn . For example, we used some color 
and gray-level images with size of 21 22
nn u  = 
256256u  as tested images in our simulation, the 
minimum size of a suitable 2-D CA is 55u ; hence, we 
chosen the 2-D dual-state von Neumann CA is with the 
size of 88u  for our simulations. Therefore, most 
cycle length of 2-D 88u -cell dual-state von Neumann
CA will be longer than 602 , which will produces 8-bit 
key-stream with the cycle length more than 632  and is 
larger than the size of tested images, i.e. 256256216 u .
Note that the size of 2-D CA is not more than 88u
according to [30] even the image size is more 
than 40964096u . However, we used CA with different 
size of 44u  until 3232u  to show its possible CA 
keys are high volume increasing. 
In summary, in the computer simulation, 462  scan 
patterns and
      WnNNnN  46252 22 possible groups of 
NT u  N-bit generalized CA data were used. Notably, 
the proposed system specifies four data types and 
N252   GCAT types. Thus, TABLE II presents a high 
volume of keys. 
TABLE II. 
 POSSIBLE SECURITY KEYS OF THE SCAN-CA-BASED IMAGE SECURITY SYSTEM 
Possible SCAN 
keys for 21 22
nn u =
256256u  images 
Possible data 
reformation 
keys 
Possible 
GCAT type 
selection
2-D NN u
von Neumann
CA
Time steps 
T
Possible 
CA keys 
  WnNNNn u 46 222
Possible security 
keys 
44u 32768 2172 > 956810
88u 8192 8912 > 977010
1616u 2048 39392 > 1068810
> 950010 4 N252 
3232u 512 175862 > 1478510
Cryptosystems must withstand the most types of 
attack such as ciphertext only attack, known plaintext 
attack, chosen plaintext attack, and chosen ciphertext 
attack. We had shown that our image encryption 
method satisfies the perfect secrecy condition 
   > @  > @ i,iFPiE|iFP     FEF  in [26], that is, 
the cryptanalyst can yield no information about the 
plaintext by observing the ciphertext because of the 
system’s perfect secrecy. This result proves that the 
system can withstand ciphertext only, and chosen 
ciphertext attacks. The cryptanalyst can use known 
plaintext and chosen plaintext attacks to this scheme 
guess the security key because the cryptanalyst cannot 
obtain information about the plaintext by observing the 
ciphertext. For known plaintext and chosen plaintext 
attacks, cryptanalyst can do exhaustive key search 
attacks to guess the security key; however, it is a 
difficult task because the proposed system has many 
security keys with variable length 
(
      WnNNnN)(  4625246 22 security keys with variable 
length (46)+       WnNNnN  46252 2
bits), for example, the proposed system has 1902
190-bit and 
4302  430-bit possible security keys to 
encrypt 256256u  images for the 2-D von Neumann
CA with size of 88u  and 1616u  respectively. 
Moreover, cryptanalyst has to know the exact length of 
the security keys before he mounts his exhaustive key 
search attacks. Cryptanalyst knows that the security 
key consists of four sub-keys: SCAN key, data 
JOURNAL OF NETWORKS, VOL. 5, NO. 1, JANUARY 2010 81
© 2010 ACADEMY PUBLISHER
Note that in all the following experiments, images 
are used for simulation and all images are of 
size 256256u . Figures 9a and 9b show YUV formatted 
color Lena and Lincoln Tower images that were used 
for testing the performance of SCAN-CA-based image 
security system. Encrypted images of Lena and Lincoln 
Tower are shown in Figure 10. Histograms of the 
encrypted Lena and the encrypted Lincoln Tower in 
Figure 11 show that the encrypted images get 
uniformly distributed pixels. This fact illustrates that 
the proposed data security system satisfies the 
confusion property. Encrypted images perform the 
process of decryption will produce the decrypted 
images. The decrypted images are exactly identical to 
the original images. This fact shows that the proposed 
system works well as our expectation. 
In order to determine the diffusion property of the 
proposed system with respect to images, Lena image 
was modified by incrementing the value of one 
randomly chosen pixel by 1. The Y-value of pixel (0, 0) 
was incremented from 161 to 162. Both the original 
Lena and the modified Lena were encrypted using the 
same keys. The pixel-wise absolute difference of two 
encrypted images is displayed in Figure 12, which 
shows that the two encrypted images have no 
similarities even though their original images differ by 
only one pixel. Thus, it proves the diffusion property of 
the proposed system with respect to images. 
(a)                 (b) 
(c)                 (d) 
Figure 10. Encrypted images, (a)1st-ordered Lena, (b) 
2nd-ordered Lena, (c). 1st-ordered Lincoln Tower, (d) 
2nd-ordered Lincoln Tower 
(a) 
(b) 
Figure 11. Histograms of images and its corresponding 
encrypted images, (a) Lena, (b) Lincoln Tower 
Figure 12. Diffusion property of the proposed system with 
respect to images 
(a)                  (b) 
 (c) 
Figure 13. Survival property of the proposed system, 
JOURNAL OF NETWORKS, VOL. 5, NO. 1, JANUARY 2010 83
© 2010 ACADEMY PUBLISHER
interfacing buffer. The detailed architectures of SCAN 
processing unit, processing unit of variable ordered 
recursive CA substitutions, and connecting board for 
interfacing between DSP board and FPGA board are 
shown in Figs. 15, 16, and 17, respectively. 
We used TI Code Composer Studio 3.1 to program 
SCAN approach and then the compiled code should be 
downloaded into TI DSP development board using 
USB560 JTAG emulator. Meanwhile, Altera provided 
Quartus II 5.0 can be used for the implementation of 
the variable ordered recursive CA substitutions, and the 
output POF file should be written into the EPROM of 
EP2S60F1020 FPGA chip. Figure 18 shows the integration of 
DSP+FPGA platform of the proposed SCAN-CA-based 
image security system which can be used to develop 
the real-time image security system. Readers are 
referred to [36] for a detailed description of 
DSP+FPGA platform of the proposed SCAN-CA-based 
image security system.
DSP ChipPC Client
FPGA ChipConnecting Board
CCS
System
TMS320
C6416T
DSK
Interfacing 
Buffer
GFEC Stratix II
EP2S60
F1020
SCAN
  Processing Unit
Processing Unit of 
Variable Ordered 
Recursive CA 
Encrypted/Decrypted 
Substitutions
USB560 
JTAG
Load / Save
Data Flow
EMIF I/O Send / Receive
Data
S2TS1
Send / Receive
Data
Figure 14. Architecture of SCAN-CA-based image 
security system 
4
JTAG 
HEADER
N×N -bit
SCAN Data
16M bytes
SDRAM
Data in
Data out
Memory
Expansion
Connector
SCAN
Processor
Initial Data
SCAN Key
Initialization
EMIF & CPLD
Memory
EMIFA
CE2
EMIF 
I/O 
Port
D0~D15
D16~D21
Figure 15. Architecture of SCAN processing unit 
Time Step, T
Encryption/Decryption 
Control
Reset
ED Start
Boundary Condition
Boundary In
CA Generating Scheme
A sequence of
N- bit input Data
A sequence of N- bit 
Encrypted/Decrypted Data
Type Selection
Control_WireD
Control_WireUT×N N-bit
CA Data
Reconf. Control
2-D Hybrid N×N
Von Neumann
CA Generator
Rule Control
Variable Ordered Recursive
CA Encrypted/Decrypted 
Substitutions
Data_In
ED_Over
Initial_Over
P1
P2
P3
P7
P4
P5
P
6
P8
Figure 16. Architecture of processing unit of variable 
ordered recursive CA substitutions 
D16~D21
Control_WireD
Control_WireUEnable
Data_In
D
0
~
D
7
D
8
~
D
1
5
Data_Out
74LS245 74LS245
Enable
Send / Receive 
Control
Enable
D
0
~
D
7
D
8
~
D
1
5
D
0
~
D
7
D
8
~
D
1
5
P1 P2
P3
Data_Out Data_Out
P4
P7
P8
Time Step, T Clock
Encryption Control
Type Selection
Reconf. Control
Reset
ED Start 74LS
245
P
6
P5
Figure 17. Architecture of connecting board for 
interfacing between DSP board and FPGA board 
Figure 18. DSP+FPGA platform of SCAN-CA-based 
image security system 
VI. DISUSSIONS AND CONCLUSIONS
This paper presented a new stream cipher system 
based on SCAN and variable ordered recursive CA 
substitutions. Its security method is based on 
permutation of the data and replacement of the data 
values. Permutation is done by scan patterns generated 
by the SCAN approach. The replacement of data values 
using variable ordered recursive cellular automata (CA) 
substitutions. The salient features of the proposed 
stream cipher system can be summarized as follows. (1) 
Keys consist of SCAN key, data reformation key, type 
selection key, and CA key, which are of variable 
lengths producing a large number of possible keys, 
more than 956810  ~ 1478510  - according to the size of 
the 2-D von Neumann CA. (2) Choosing a suitable size 
for the 2-D CA, according to the size of the image, 
enables the system to withstand the 
cropping-and-replacement attack. (3) The system is 
economic in consuming computational resources 
because the encryption/decryption scheme uses integer 
arithmetic and logic operations. Comparative results 
JOURNAL OF NETWORKS, VOL. 5, NO. 1, JANUARY 2010 85
© 2010 ACADEMY PUBLISHER
Indonesia, Oct. 28-31, 2002. 
[28] R. J. Chen, J. L. Lai, and Y. T. Lai, “Design of the 
Universal 2-D Cellular Automata Bases Generator and 
Its VLSI Implementation,” in Proceedings of the 7th
World Multi-Conference on Systemics, Cybernetics 
and Informatics (SCI 2003), vol. XII, pp. 165-168, 
Orlando, Florida, USA, July 27-31, 2003. 
[29] R. J. Chen, J. L. Lai, C. S. Yang, W. C. Fan, W. J. Chen, 
C. C. Hung, and L. Y. Hsu, “The Architecture of the 
Re-configurable 2-D Cellular Automata Bases 
Generator,” in Proceeding of the 14th VLSI 
Design/CAD Symposium (VLSI Design/CAD 2003), pp. 
137-140, Hualien, Taiwan, Aug. 12-15, 2003. 
[30] M. Tomassini, M. Sipper, and M. Perrenoud, “On the 
generation of high-quality random numbers by 
two-dimensional cellular automata,” IEEE Trans. on 
Computers, vol. 49, no. 10, pp 1146-1151, 2000. 
[31] C. E. Shannon, “Communication theory of secrecy 
systems,” Bell System Technical Journal, vol. 28, no. 4, 
pp. 656-715, 1949. 
[32] D. Barton, “DCPcrypt Cryptographic Component 
Library v2 Beta 3,” 
http://www.cityinthesky.co.uk/cryptography.html,
1999.
[33] S. R. Fluhrer and D. A. McGrew, “Statistical analysis 
of the Alleged RC4 keystream Generator,” Lecture 
Notes in Computer Science, vol. 2259, pp. 1-24, 
Springer-Verlag, 2001. 
[34] S. Lucks, “Attacking triple Encryption,” Lecture Notes 
in Computer Science, vol. 1372, pp. 239-253, 
Springer-Verlag, 1988. 
[35] N. Ferguson, J. Kelsey, S. Lucks, B. Schneier, M. Stay, 
D. Wagner, and D. Whiting, “Improved cryptanalysis 
of Rijndael,” Lecture Notes in Computer Science, vol. 
1978, pp. 213-230, Springer-Verlag, 2000. 
[36] C. S. Chen, “Integration and implementation of image 
encryption/decryption system using SCAN and 2-D 
von Neumann cellular automata,” Master Thesis, 
National United University, 2007. 
Rong-Jian Chen was born in 1958, Taiwan. He received 
the B.S., M.S., and Ph.D. degrees in electronic engineering 
from the National Taiwan University of Science and 
Technology, Taipei, Taiwan, in 1987, 1991, and 1995, 
respectively. 
He joined the faculty of the National Lien-Ho Institute of 
Technology in August 1995, where he was the Chair of the 
Department of Electronic Engineering during 1999–2001 
academic years. At present, he is Associate Professor of the 
Department of Electronic Engineering, National United 
University. 
Dr. Chen had been elected as IEEE Senior Member in 
2004. He is a member of Nano-electronics and Giga-scale 
System Technical Committee, IEEE CAS Society. He serves 
as Co-Editor of Globalization Leadership Column at IEEE 
Circuits and Devices Magazine during 2004-2006, and serves 
on the Editorial Board of IEEE Circuits and Systems 
Magazine during 2004-2007. He also serves as Associate 
Editor of IEEE Trans. on Circuits and Systems: Part I during 
2006-2007. His research interests include digital image/video 
processing, neural networks, and VLSI design of multimedia 
system. 
Jui-Lin Lai was born in 1955, Taiwan. He received the 
B.S degree from the Electronic Engineering, National Taiwan 
University of Science and Technology, Taipei, Taiwan, 1984. 
He received the M.S and Ph.D degree in the Institute of 
Control Engineering and the Institute of Electronic 
Engineering from the National Chiao-Tung University, 
Taiwan, R.O.C., in 1990 and 2004, respectively. 
He joined the faculty of the National Lien-Ho Institute of 
Technology in August 1984, where he was the Chair of the 
Department of Electronic Engineering during 1993–1996 
academic years. At present, he is Associate Professor of the 
Department of Electronic Engineering, National United 
University. 
Dr. Lai had been elected as IEEE Senior Member in 2005. 
His research interests include analog and digital VLSI design, 
neural networks, and computing architecture, and 
nanotechnology. 
Shi-Jinn Horng was born in 1957, Taiwan. He received 
the BS degree in Electronics Engineering from National 
Taiwan Institute of Technology, Taipei, the MS degree in 
Information Engineering from National Central University, 
Taiwan, and the PhD degree in Computer Science from 
National Tsing Hua University, Taiwan, in 1980, 1984, and 
1989, respectively. 
He was a Professor and Dean of the College of Electrical 
Engineering and Computer Science, National United 
University, Miaoli, Taiwan. Currently, he is a Professor at the 
Department of Computer Science and Information 
Engineering, National Taiwan University of Science and 
Technology. 
Dr. Horng has published more than 170 research papers 
and received many awards; especially, the Distinguished 
Research Award between 2004 and 2006 from the National 
Science Council in Taiwan; Outstanding I. T. Elite Award, in 
2005; Outstanding EE. Prof. Award, the Chinese Institute of 
Electrical Engineering; Outstanding Research and Invention 
Award between 2006 and 2008 from National Taiwan 
University of Science and Technology. 
JOURNAL OF NETWORKS, VOL. 5, NO. 1, JANUARY 2010 87
© 2010 ACADEMY PUBLISHER
Author's personal copy
Novel SCAN-CA-based image security system using SCAN and
2-D von Neumann cellular automata
Rong-Jian Chen a,, Shi-Jinn Horng b
a Department of Electronic Engineering, National United University, Miaoli 36003, Taiwan
b Department of Computer Science and Information Engineering, National Taiwan University of Science and Technology, Taipei 106, Taiwan
a r t i c l e i n f o
Article history:
Received 14 August 2008
Accepted 6 March 2010
Keywords:
Image security
Stream cipher
Encryption and decryption
SCAN methodology
Cellular automata
a b s t r a c t
This paper presents a novel SCAN-CA-based image security system which belongs to
synchronous stream cipher. Its encryption method is based on permutation of the image
pixels and replacement of the pixel values. Permutation is done by scan patterns
generated by the SCAN approach. The pixel values are replaced using the recursive
cellular automata (CA) substitution. The proposed image encryption method satisﬁes
the properties of confusion and diffusion as the characteristics of SCAN and CA
substitution are ﬂexible. The salient features of the proposed image encryption method
are lossless, symmetric private key encryption, very large number of secret keys, key-
dependent permutation, and key-dependent pixel value replacement. Simulation
results obtained using some color and gray-level images clearly demonstrate the
strong performance of the proposed SCAN-CA-based image security system.
& 2010 Elsevier B.V. All rights reserved.
1. Introduction
As the ﬁeld of multimedia applications grows, security
is an increasingly important issue in the communication
and storage of images. Encryption is an effective means for
ensuring reliable security. Image encryption has been
applied to Internet-based communications, multimedia
systems, medical imaging, telemedicine and military
communication. Numerous image encryption methods
are available. They include SCAN-based methods [1–5],
chaos-based methods [6–8], tree structure-based methods
[9–11] and other systematic methods [12–15]. Each has its
strengths and limitations in terms of security, speed, and
resulting stream size metrics. A new encryption method is
proposed to overcome these problems. The advantages of
the proposed encryption method are with variable length
security keys and its corresponding ﬂexible encryption
complexity; users can choose a suitable security key
according to their requirement for preventing attacks.
Therefore, the proposed encryption method can be used
as a candidate when users want to choose an encryption
method for their desired requirements.
The proposed SCAN-CA-based image security system
belongs to synchronous stream cipher whose encryption
method is based on the permutation of the image pixels
and the replacement of the pixel values. The permutation
is done by scan patterns that are generated by the SCAN
approach. The pixel values are replaced using a recursive
CA substitution with a sequence of CA data that is
generated from the CA evolution rules. The SCAN
approach described in [5] is used because it produces a
high volume of scan patterns. The advantages of CA in the
proposed image security method are described as follows.
(1) CA has been applied successfully to several physical
systems, processes, and scientiﬁc problems that involve
local interactions as in image processing [16,17], data
encryption [18,19], byte error correcting code [20]; it has
also been used in pseudorandom number generators for
VLSI built-in self-test [21]. (2) Number of CA evolution
Contents lists available at ScienceDirect
journal homepage: www.elsevier.com/locate/image
Signal Processing: Image Communication
ARTICLE IN PRESS
0923-5965/$ - see front matter & 2010 Elsevier B.V. All rights reserved.
doi:10.1016/j.image.2010.03.002
 Corresponding author. Tel.: +886 37 381509; fax: +886 37 362809.
E-mail addresses: rjchen@nuu.edu.tw (R.-J. Chen),
horngsj@yahoo.com.tw (S.-J. Horng).
Signal Processing: Image Communication 25 (2010) 413–426
Author's personal copy
Fig. 1, the letters r, c, d, l, a, i, t, and w in Fig. 1 indicate the
type of scan patterns. V-B9Z9X: Partition with a speciﬁc
partition group B, Z, or X as in Fig. 2. T-091929394959697:
Use one of the eight transformations for a scan or a
partition.
Fig. 3 shows the scanning path of the scan pattern
X3(c2 Z2(d0w2 a4 l1) t0 i4) for a 1616 image. The image
is ﬁrst partitioned into four sub-regions using X3 partition
order. These four sub-regions are scanned using c2, Z2(d0
w2 a4 l1), t0, and i4. The second sub-region is further
portioned into four sub-regions using Z2 order and these
four sub-regions are scanned using d0, w2, a4, and l1.
2.2. CA
CA are dynamic systems in which space and time are
discrete. The cells, as arranged in a regular lattice
structure, have a ﬁnite number of states. These states
are updated synchronously according to a speciﬁed local
rule of neighborhood interaction. The neighborhood of a
cell refers to the cell and some or all of its immediately
adjacent cells. Fig. 4 shows the 2-D CA space, where the
speciﬁed cell P with its immediate North, South, West and
East cells form the von Neumann neighborhood; the so-
calledMoore neighborhood incorporates the von Neumann
neighborhood and the diagonal cells.
Using a speciﬁed rule of neighborhood, the states are
updated synchronously in discrete time steps for all cells.
For a k-state CA, each cell can take any of the integer
values between 0 and (k1). In general, the rule
governing the evolution of the CA will encompass its
neighbor. The state of each cell for a 2-D, k-state, von
Neumann neighborhood CA, is given by the Boolean variable
a¼ aði, j, tÞ, 0r i, j, trN1. The quantity a(i, j, t) repre-
sents the state of the (i, j)th cell at discrete time t, whose four
neighbors are in states a(i1, j, t), a(i+1, j, t), a(i, j1, t) and
a(i, j+1, t). In general, a rule is needed, that will be used to
synchronously calculate the state a(i, j, t+1) from the states
of the cells in the neighborhood at the tth time step.
For a 2-D von Neumann 2-state CA, each cell has 22
5
possible CA evolutions, which can be expressed as
aði, j, tþ1Þ ¼ fBðaði1, j, tÞ,aðiþ1, j, tÞ,
aði, tÞ,aði, j1, tÞ,aði, jþ1, tÞÞ: ð1Þ
Here, fB(U) is a Boolean function deﬁning the rule.
Different cells apply different rules, making the CA hybrid.
Wolfram [27] assigned an integer R as a rule number to the
rule generating the function fB(U). Since the evolution of
the (i, j)th cell can be represented as a combinational logic
of the present states of its neighbor Thus, Eq. (1) can be
simpliﬁed as
aði,j,tþ1Þ ¼ C0
 ðC1Uaðiþ1, j, tÞ  C2Uaði, j1, tÞ  C3Uaði, j, tÞ
 C4Uaði, jþ1, tÞ  C5Uaði1, j, tÞÞ: ð2Þ
The detailed hardware implementation of CA has been
shown in [28–30]. CA evolution as Eq. (2) can be
characterized by EXOR and/or EXNOR, which is referred
as the 1-bit Programmable additive CA (PACA). Using the
1-bit PACA, one can build the desired NN-bit cellular
ARTICLE IN PRESS
Fig. 2. Transformations with partition.
Fig. 3. Example of the scan pattern X3(c2 Z2(d0 w2 a4 l1) t0 i4).
Fig. 4. 2-D CA space with von Neumann neighborhood and Moore
neighborhood.
R.-J. Chen, S.-J. Horng / Signal Processing: Image Communication 25 (2010) 413–426 415
Author's personal copy
data for specifying the CA rule number, according to the
size of CA, where [x] rounds the elements of x to the
nearest integers Zx; the next N2 bits are initial data that
specify initial conﬁguration; ﬁnally, the remaining 4N bits
specify boundary conditions. Since TN N-bit generalized
CA data have ðT  NÞ ! possible permutations, extra bits
are needed to specify a special permutation. However,
sinceðT  NÞ ! may be a huge number, nW ¼ log2ðT  NÞ ¼
log2 Tþ log2N¼ nTþnN bits are used to represent and
generate a speciﬁc set of permutation, called a linear
permutation. Notably, nT bits and nN bits are used to
specify the time step and location, respectively, of the
starting point for retrieving the TN N-bit CA data to
generate a sequence of hashed N-bit CA data for encryp-
tion and decryption. In summary, the length of the CA key
is ((6+n)+N2+4N+nW) bits. The CA key is of variable
length according to the size of the 2-D CA and the number
of time steps. Fig. 6 shows the structure of the CA key.
CA key is used to control the CA key-stream generator
(see Fig. 7) to generate a sequence of N-bit CA key-stream
for CA substitution. Fig. 7 shows the CA encryption/
decryption scheme, where stream cipher executes
recursive CA encrypted substitution which is recursive
to change the pixel value of the scanned plaintexts for
encryption, while stream decipher executes recursive CA
decrypted substitution which is recursive to change the
pixel value of the ciphertexts for decryption.
Let F(i), 0r irL11 be a sequence of N-bit input data
(scanned plaintexts), CAp(i), 0r irL11 be an N-bit
CA key-stream, and E(i), 0r irL11 be a sequence of
N-bit output data (ciphertexts). Then, the recursive CA-
encrypted substitution is deﬁned as
CA encryption : EðiÞ ¼ ½FðiÞþGCATðEði1Þ,
CApðiÞ3CApði1ÞÞmod2N , 0r irL11: ð3Þ
GCAT(E(i1), CAp(i)3CAp(i1)) means that E(i1) and
CAp(i) or CAp(i1) execute the generalized CA transform
(GCAT). Four groups of GCAT can be expressed as
Group 1 : GCATðEði1Þ, CApðiÞÞ ¼ ððE i1ð ÞþLSÞ
 CApðiÞÞmod2N , ð4Þ
Group 2 : GCATðEði1Þ, CApðiÞÞ ¼ ððEði1ÞþLSÞ  CApðiÞÞmod2N ,
ð5Þ
Group 3 : GCATðEði1Þ, CApði1ÞÞ ¼ ððEði1ÞþLSÞ
 CApði1ÞÞmod2N , ð6Þ
Group 4 : GCATðEði1Þ, CApði1ÞÞ
¼ ððEði1ÞþLSÞ  CApði1ÞÞmod2N , ð7Þ
where 0rLSr2N1 are values of level shift. (2+N)-bit
Type Selection key were used to specify the type of GCAT
since 2N GCATs exist for each group.
Every secure encryption method must satisfy two
fundamental properties. The ﬁrst is the confusion prop-
erty, which requires that similar keys produce completely
different encrypted data when encrypting the same
original data. This makes the statistical relationship
between key and encrypted data as complex as possible,
that is, a cryptanalyst tries to do exhaustive key search
attack should much harder. The second is the diffusion
property, which requires that similar original data
produce completely different encrypted data when
encrypted with the same key. This results in the statistical
properties of original data hidden in encrypted data. The
ARTICLE IN PRESS
Fig. 6. Structure of the CA key.
Fig. 7. Scheme of CA encryption/decryption.
R.-J. Chen, S.-J. Horng / Signal Processing: Image Communication 25 (2010) 413–426 417
Author's personal copy
particular type of GCAT. The CA key is used for a chosen
CA rule number, initial data, boundary conditions, and
linear permutation to generate a CA key-stream for CA
substitution.
A single pixel change in input image A(k, l), 0rk,
lrN0 1 causes all the data in E(i), 0r irL11 to
be changed as follows. On the sender site, suppose
a single pixel is changed in A(k, l), 0rk, lrN0 1. Then
the corresponding pixel at some location j in B(j),
0r jr(N0 N0 1) is changed. After data reformation
and CA encrypted substitution, all data between j and
L11 in E(i) are changed. A small change in scan key, data
reformation key, or CA key also changes all data in E(i),
0r irL11, because a change in scan key, data reforma-
tion key, or CA key causes a big change in B(j),
0r jr(N0 N0 1), F(i), 0r irL11, and/or the output
sequence E(i), 0r irL11.
On the receiver site, a scan key, a data reformation key,
a type selection key, a CA key, and a sequence of N-bit
encrypted data are required. The data will be decrypted as
follows. First, the recursive CA-decrypted substitution
performs CA decryption to generate the sequence of N-bit
decrypted data D(i), 0r irL11. Then, an inverse data
reformation is followed by an inverse SCAN to produce
the N
0 N0 decrypted image. Notably, the ﬁnal N0 N0
decrypted image is the same as the N
0 N0 original image
because the proposed image encryption method is
lossless.
4. Possible secret keys and cryptanalysis
Let S(n) be the number of scan patterns of an 2-D
2n2n array generated by the SCAN key deﬁned by the
encryption-speciﬁc SCAN language. For a 2n2n, nZ2
image, there are eight basic scan patterns shown in Fig. 1
each with eight transformations resulting in 64 basic
scan-transformation patterns. When nZ3, there are
additionally 24 ways shown in Fig. 2 to partition the
image into four sub-regions of size 2n12n1 each
having S(n1) recursive scan patterns. This results in
S(2)=64 and S(n)=64+24(S(n1))4, nZ3. However, only
a portion of scan patterns with a ﬁnite number of scan
iterations shall achieve a good dispersion, the length of
scan key was thus carefully determined as 46 bits,
meaning that only 246 scan patterns shall be used in our
simulation. As discussed previously, a 2-D NN-cell dual-
state von Neumann hybrid CA that runs over T time steps
produces 232N
2þN2þ4N  ðT  NÞ ! possible groups of TN
N-bit CA data. However, for efﬁcient computer simulation
or logic-gate implementation, the (6+n)-bit rule control
data are used to specify speciﬁc CA rule numbers.
Furthermore, since TN N-bit generalized CA data have
ðT  NÞ ! possible permutations, it could be a very large
number. Therefore, the linear permutation with
nW=log2(TN)=log2 T+log2 N=nT+nN bits is compact in
representing and generating a speciﬁc set of permuta-
tions. In summary, in the computer simulation,
2 6þnð ÞN
2þN2þ4NþnW possible groups of TN N-bit gen-
eralized CA data were used. Notably, the proposed system
speciﬁes four data types and 42N GCAT types. Thus,
Table 1 presents a high volume of secret keys.
Notably, the proposed SCAN-CA-based image security
system belongs to the stream cipher. The basic idea is that
we use a speciﬁed secret key (one of 2 6þnð ÞN
2þN2þ4NþnW )
to generate a key-stream and use it to encrypt a plaintext
string according to Eq. (6). We hence choice the length of
key-stream at least equals to the length of plaintext to
match the goal of security. Additionally, we know that the
length of a CA state cycle is very important in determining
the suitability of the CA as a generator of random
numbers. According to [31], the average cycle length for
2-D NN-cell dual-state von Neumann CA increases
exponentially and is on the order of 2N
23 for No8 or
2N
24 for NZ8. Therefore, we have to choose a suitable
2-D NN-cell CA to produce high-quality key-stream
ARTICLE IN PRESS
Fig. 9. SCAN-CA-based image security system.
R.-J. Chen, S.-J. Horng / Signal Processing: Image Communication 25 (2010) 413–426 419
Author's personal copy
using an Intels P4 CPU (3.2 GHz) personal computer with
MicrosoftsWindowss XP and Borlands C++ builders 6.0.
Many simulations were conducted to illustrate various
properties of the proposed SCAN-CA-based image security
system including pixel rearrangement, confusion and
diffusion properties, and survival property. Notably, all
images in this section were of size 256256. Fig. 10a and
b show two color images Lena and Lincoln tower, which
were used to evaluate the performance of the proposed
SCAN-CA-based image security system. Z0(Z0(i0i1i0i1)
Z4(d1d0d1d0) X3(i0i1i0i1) X2(i1i0i1i0)) scan key with
number of scan iterations 8 is used to rearrange the
pixels of these tested images. The data reformation key
was 012, meaning the data for encryption and decryption
were 8-bit, and that 2-D 88-cell von Neumann CA was
adopted. The type selection key was 00000000002,
meaning that group 1 GCAT with zero level shift (LS=0)
was applied to perform the recursive CA-encrypted and
CA-decrypted substitutions. The CA key was CA key 1
which is shown in Fig. 11a. The corresponding encrypted
images are shown in Fig. 10c and d. This fact
demonstrated that the proposed SCAN-CA-based image
security system is effective for color images.
In the following, some gray-level images were used to
demonstrate the confusion and diffusion properties of the
proposed security system. Three CA keys were used and
each of them consists of the rule control bits, the CA initial
bits, the boundary condition bits, and the permutation
control bits. Among of them, CA key 1 was uniform initial
states 6C16 and ‘‘0’’ boundary with cyclic lower right-most
corner which was shown in Fig. 11; CA key 2 was obtained
by 1-bit change to the initial data of CA key 1, the initial
state of the upper left-most cell was changed from 0 to 1.
CA key 3 was uniform initial states 0016 and ‘‘1’’ boundary
with cyclic lower right-most corner. The rule control data
were (6+6) bits and ﬁxed as 0111110000012, meaning
that the 2-D 88-cell dual-state von Neumann CA
evolution was controlled by the function a(i, j, t+1)=
a(i+1, j, t)a(i, j1, t)a(i, j, t)a(i, j+1, t)a(i1, j, t)
based on the speciﬁed hybrid CA set data 0000012. After
the initial data, the boundary condition data and the rule
control data had been determined, the 2-D 88-cell dual
state von Neumann hybrid CA ran over 8192 time steps to
generate 81928 8-bit generalized CA data. Then, 8-bit
permutation control data 000000002 guided the system to
perform a linear permutation from the ﬁrst byte of the
generalized CA data to generate a high-quality random
sequence as a key-stream. Fig. 12a–d show Lena image
and its encrypted images meanwhile the corresponding
probability density functions (pdfs) and entropies were
shown in Fig. 12e. The Jet image (Fig. 13a) and a pure
black image (Fig. 14a) were encrypted using the same
scan key X0(Z0(i0i1i0i1) Z4(d1d0d1d0) X3(i0i1i0i1)
X2(i1i0i1i0)) with number of scan iterations 8, the same
data reformation key (012), the same three CA keys, and
group 1 GCAT with zero level shift as that of Lena image to
illustrate the confusion and diffusion properties of the
proposed system. Figs. 13b–d and 14b–d show the
encrypted images of the Jet and the pure black image,
respectively. Encrypted images in Figs. 12b–d, 13b–d, and
ARTICLE IN PRESS
Fig. 10. Color testing images and the corresponding encrypted images: (a) original Lena, (b) original Lincoln tower, (c) encrypted scanned-Lena, and (d)
encrypted scanned-Lincoln tower.
Fig. 11. Illustration of CA key. This ﬁgure shows CA key 1: uniform initial states 6C16, ‘‘0’’ boundary with cyclic lower right-most corner.
R.-J. Chen, S.-J. Horng / Signal Processing: Image Communication 25 (2010) 413–426 421
Author's personal copy
Histograms in Figs. 12e, 13e, and 14e show that these
encrypted-scanned images achieve uniformly distributed
pixels. That is, the statistical properties of original images
hidden in encrypted images because the encrypted
images have uniformly distributed pixels. This fact further
shows that the proposed SCAN-CA-based image security
system satisﬁes the diffusion property.
As mentioned above, different CA keys produce
different key-streams, even though the difference is quite
small. For example, the initial data of CA key 2 is a small
change of that of CA key 1 in the upper left-most corner
(the initial state is changed from 0 to 1), but signiﬁcantly
different key-stream are produced. Finally, these different
key-streams result in vastly different encrypted images, as
shown in Figs. 12b and c, 13b and c, and 14b and c. Thus,
the confusion property of the proposed SCAN-CA-based
image security method with respect to CA keys is
illustrated in detail.
The scanned-Lena images using scan keys
X0(Z0(i0i1i0i1) Z4(d1d0d1d0) X3(i0i1i0i1) X2(i1i0i1i0)) and
X1(Z0(i0i1i0i1) Z4(d1d0d1d0) X3(i0i1i0i1) X2(i1i0i1i0)),
both with number of scan iterations 8, are shown in
Fig. 16a and b, respectively. Although scan key X1(Z0
(i0i1i0i1) Z4(d1d0d1d0) X3(i0i1i0i1) X2(i1i0i1i0)) is a small
change of X0(Z0(i0i1i0i1) Z4(d1d0d1d0) X3(i0i1i0i1)
X2(i1i0i1i0)), it results in a vastly different pixel re-
arrangements. It is clear that Fig. 16b is quite different
from Fig. 16a. The sequence as shown in Fig. 16b is then
encrypted with the same data reformation key and CA key
as in Fig. 16a, and the encrypted image is shown in Fig. 16c.
The pixel-wise and scaled difference between Figs. 16c and
12b (Fig. 12b is the encrypted image of Fig. 16a) was shown
in Fig. 16d. It shows that a small change of scan keys can
produce a signiﬁcantly different encrypted image. Thus, it
illustrates that the proposed method has the confusion
property with respect to SCAN keys.
ARTICLE IN PRESS
Fig. 14. Black image proving the confusion and diffusion properties, all of encrypted images are with X0(Z0(i0i1i0i1) Z4(d1d0d1d0) X3(i0i1i0i1)
X2(i1i0i1i0)) scan key and number of scan iterations 8, 012 data reformation key: (a) original image, (b) encrypted scanned-image using CA key 1,
(c) encrypted scanned-image using CA key 2, (d) encrypted scanned-image using CA key 3, and (e) corresponding pdfs and entropies.
Fig. 15. Pixel-wise and scaled-difference images of the encrypted-original Lena and the encrypted-modiﬁed Lena proving the diffusion property, all
images were encrypted using X0(Z0(i0i1i0i1) Z4(d1d0d1d0) X3(i0i1i0i1) X2(i1i0i1i0)) scan key and number of scan iterations 8, 012 data reformation key,
and (a) CA key 1, (b) CA key 2, (c) CA key 3.
R.-J. Chen, S.-J. Horng / Signal Processing: Image Communication 25 (2010) 413–426 423
Author's personal copy
small fraction of the ciphertext is corrupted in transmis-
sion, rather than added or lost, then only the correspond-
ing fraction in the plaintext is affected and the error does
not propagate to other parts of the plaintext; a large area
of the image therefore survives. This characteristic makes
the proposed system reliable in transmissions with high
error rate. The survival properties of the proposed system
are shown in Fig. 18. Fig. 18c shows that the pixels of the
corrupted block are dispersed all over the image after
inverse scan, which act noise-like pixels. These noise-like
pixels can be ﬁltered using the techniques of low-pass
ﬁltering.
6. Conclusions
We presented a new SCAN-CA-based image security
system based on the SCAN methodology and cellular
automata in this paper. The security method is based on
permutations of the pixels of the image and replacement of
the pixel values. The permutation is conducted by scan
patterns generated by the SCAN methodology. The pixel
values are replaced using a recursive cellular automata
(CA) substitution. The salient features of the proposed
SCAN-CA-based image security system can be summarized
as follows. (1) Secret keys consist of SCAN key, data
reformation key, type selection key, and CA key, which are
of variable lengths producing a large number of possible
secret keys, more than 109565–1014 775—according to the
size of the 2-D von Neumann CA. (2) Choosing a suitable
size for the 2-D CA, according to the size of the image,
enables the system to withstand the cropping-and-repla-
cement attack. (3) The system is economic in consuming
computational resources because the encryption/decryp-
tion scheme uses integer arithmetic and logic operations.
Comparative results show that the performance of the
proposed system is superior to those of RC4, 3DES, and AES
because of its more complicated cryptanalysis and higher
processing speed for particular ciphertext entropy.
Moreover, this system withstands the survival against
attack as well as RC4, 3DES, and AES.
Acknowledgements
The National Science Council of the Republic of China
under contracts NSC-93-2215-E-239-003 and NSC-97-
2221-E-239-036-MY3 supported this research. The
authors wish to express many thanks to the reviewers
for their fruitful suggestions.
References
[1] N.G. Bourbakis, C. Alexopoulos, Picture data encryption using SCAN
patterns, Pattern Recognition 25 (6) (1992) 567–581.
[2] C. Alexopoulos, N.G. Bourbakis, N. Ioannou, Image encryption
method using a class of fractals, Journal of Electronic Imaging 4
(1995) 251–259.
ARTICLE IN PRESS
Table 2
List of comparisons.
Algorithm
Item
SCAN-CA-based image
security system (NN)
Crypto++
RC4 (MARC4) 3DES (DES-XEX3) AES-256
Classiﬁcation Stream cipher Stream cipher Block cipher Block cipher
Key length (bits) 56þnþ5NþN2þnW a 256 192 256
Complexity of cryptanalysis  256þnþ5NþN2 þnW 233 [36] 2113 [37] 2119 [38]
Execution speed (Mbytes/s) 65b 126 20.78 48.23
Entropy of ciphertext (bits) 7.9999 7.9999 7.9999 7.9999
a Key length=46 bits (SCAN key)+2 bits (data reformation key)+(2+N) bits (type selection key)+(6+n+N2+4N+nW) bits (CA key).
b Execution speed is the speed for encrypting/decrypting 3 Mbytes of plaintext/ciphertext excluding the time required for hard disk storage.
Fig. 18. Survival property of the proposed system: (a) corrupted ciphertext (encrypted image), (b) decryption of the corrupted ciphertext, and (c) inverse
scan of the decrypted image.
R.-J. Chen, S.-J. Horng / Signal Processing: Image Communication 25 (2010) 413–426 425
© 2011 John Wiley & Sons, Ltd, Company number 00641132, Registered in England and Wales, registered office: The Atrium, 
Southern Gate, Chichester, West Sussex PO19 8SQ, UK   
Sign outAmend my detailsAdd a new article
Prof Rong-Jian Chen (rjchen@nuu.edu.tw) 
 
 
 
  
My Publications
Your Articles
 Add My Colleagues
 Add My Co-Authors
 E-mail Journal 
Production Editor
Concurrency and Computation  
"Architecture design of high efficient and non-memory AES 
crypto core for WPAN" 
Vol 23, Issue 12, start page 1332  
Issue published online  
8 Aug 2011  
Production History || View PDF  || Order Printed Offprints ||  
  
 
 Archive 
 
 Archive selected
Article Status - View stage descriptions
1 2 3 4 
Page 1 of 1Wiley-Blackwell Author Services
2011/8/11http://authorservices.wiley.com/bauthor/mypubs.asp
ARCHITECTURE DESIGN OF AES CRYPTO-CORE FOR WPAN 1333
projection, image transfer, high-speed cable replacement (e.g. wireless USB). The data rate of
802.15.3a is more than 110 Mbps within 10 m. Among these WPAN technologies, the Bluetooth
is the most widely used technology for the WPAN communication. Each technology is optimized
for specific usage, applications or domains. Although in some respects, certain technologies might
be viewed as competing in the WPAN space, but they are often complementary to each other.
Owing to the growth of applications in Internet and wireless communication, more and more
users require the security measures and devices for protecting the data, which users transmit
over the channels. As nobody can guarantee that the information will not be stolen over open
communication channels, it is a general way to encrypt the information before they are transmitted
into the channels.
There are many crypto-system developed in the past. According to the key type, the cryptography
can be classified into two types, such as the asymmetric-key and symmetric-key cryptography.
Asymmetric-key cryptography manipulates two different keys for encryption and decryption and
provides a robust mechanism for the key transportation. On the other hand, symmetric-key cryp-
tography uses an identical key for both encryption and decryption, which is more efficient for large
amount of data. DES, 3DES [5] and AES [6] are the symmetric-key cryptography, whereas, RSA
and Elliptic Curve algorithms are such asymmetric-key cryptography [7]. Because the architecture
of the symmetric-key cryptography is simple, the cryptography can encrypt or decrypt data at
high speed and is more suitable for the condition that has a large amount of data to be processed
[7–10]. Among many symmetric cryptographies, Advanced Encryption Standard (AES) is an effi-
cient scheme for both hardware and software implementation. AES algorithm was developed by
NIST and Rijndael algorithm [11] has been selected as the AES algorithm [12] by the NIST.
Current WPAN specification distinguishes two AES security suites, one is AES-CTR mode,
which provides data confidentiality only, the other is AES-CCM mode, which provides both
data confidentiality and data authenticity, depending on the combination of encryption and data
authentication used. Because cryptographic transformations of AES are computationally intensive,
consuming significant power; therefore, many works have been presented on hardware imple-
mentations of the AES algorithm using ASIC and FPGA [13–24], many of them focus on high
throughput. High-throughput AES designs can target high-end products with multi-gigabit data
rate and have no regards for power consumption. Low-end products, including handheld devices
like PDA rarely need more than 200 Mbps data transfer rate, high-throughput AES designs would
provide a throughput many times more than required and thus utilize both excessive area and
power. This gives an alternative implementation of AES algorithm, with the aim of reducing area
and/or power consumption and increasing the handsets’ battery life. Therefore, in this paper, we
focus on developing a novel AES crypto-core with lower complexity, limiting cost and acceptable
power usage to fit WPAN security requirement.
The proposed basis transformation approach from Galois Field (28) to Galois Field GF(((22)2)2)
can significantly reduce the hardware complexity of the SubBytes transformation (S-box). Besides,
the on-the-fly key expansion function is used to replace the memory (RAM or ROM) to achieve
non-memory and to reduce the power consumption. The resulted on-the-fly key scheduler fully
supports AES-128, AES-192 and AES-256 ciphers and deciphers. Moreover, resource-sharing
scheme will also be employed to reduce the hardware complexity of cipher and decipher.
This paper is organized as follows. Section 2 gives the brief overview of AES algorithm.
Section 3 shows recent related work. Section 4 discusses methods to reduce the hardware cost and
hardware solution of AES crypto-core. In Section 5, the implementation results and performance
comparisons are provided. Finally, Section 6 gives the discussions and conclusions.
2. OVERVIEW OF AES ALGORITHM
AES is a symmetric block cipher having variable key and fixed data length. The key lengths can be
independently chosen as 128, 192 or 256 bits, which result in 10, 12 and 14 rounds of operation,
respectively. The data length is however fixed to 128 bits. The input as well as intermediate data can
Copyright  2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2011; 23:1332–1347
DOI: 10.1002/cpe
ARCHITECTURE DESIGN OF AES CRYPTO-CORE FOR WPAN 1335
Figure 2. Equivalent decipher of Rijndael algorithm.
transformation immediately followed by a SubBytes transformation. The same is true for
their inverses, InvSubBytes and InvShiftRows.
2. The column mixing operations—MixColumns and InvMixColumns—are linear with respect
to the column input, which means InvMixColumns(state ⊕ Round Key)=InvMixColumns
(state)⊕InvMixColumns(round key).
These properties allow the order of InvSubBytes and InvShiftRows transformations to be
reversed. The order of the AddRoundKey and InvMixColumns transformations can also be reversed,
provided that the columns (words) of the decryption key schedule are modified using the InvMix-
Columns transformation. The equivalent decipher is defined by reversing the order of the InvSub-
Bytes and InvShiftRows transformations shown in Figure 2, and by reversing the order of the
AddRoundKey and InvMixColumns transformations used in the round loop after first modifying
the decryption key schedule for round=1 to Nr–1 using the InvMixColumns transformation. The
first and last Nb words of the decryption key schedule shall not be modified in this manner.
3. RECENT RELATED WORK
Many recent AES implementations have focused on speed gains obtained by manipulations in the
SubBytes and MixColumns, two of the more time-consuming functions in the algorithm. Works
of [13–15] take an approach involving a high level of parallelism and pipeline, enabling very high
throughput to be achieved 21.56 Gbps in [13], 29 Gbps in [14] and 30–70 Gbps in [15], respectively.
But all of them have high cost and power consumption. Such designs have the utility in application
Copyright  2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2011; 23:1332–1347
DOI: 10.1002/cpe
ARCHITECTURE DESIGN OF AES CRYPTO-CORE FOR WPAN 1337
Figure 3. Architecture of GF(28) inverter.
employed to reduce the hardware complexity [13]. Therefore, we represent elements in GF(28)
as polynomials of degree one, to reduce the complexity. In the composite field GF((24)2), an
element can be expressed as Nh x + Nl , where Nh , Nl ∈GF(24) and x is a root of P2(x). Using the
Extended Euclidean algorithm, the GF(28) inverter of Nh x + Nl modulo P2(x) can be computed
as (Nh x + Nl )−1 = Nhx +(Nh + Nl ) where = (N 2h+ Nh Nl + N 2l )−1. According to this, the
operation of calculating the GF(28) inverter is now translated from over GF(28) to over GF(24),
including multiplications, squares and additions. Figure 3 shows the architecture of GF(28)
inverter. The multipliers in GF(24) can be further decomposed into multipliers in GF(22) and
then to GF(2), in which a multiplication is simply an AND operation. Figure 4 illustrates this
decomposition, together with the other blocks used in Figure 3.
Circuit of the integration of Affine and inverse Affine transformations is shown in Figure 5. Part
of Affine transformation of Figure 5 is used for SubBytes transformation, whereas part of inverse
Affine transformation is used for InvSubBytes transformation. Because GF(28) inverter+Affine
transformation has been chosen to implement SubBytes transformation, we therefore used inverse
Affine transformation+GF(28) inverter to implement InvSubBytes transformation. In this sense
both SubBytes and InvSubBytes transformations are fulfilled by only one GF(28) inverter, which
will reduce a substantial amount of resources. The architecture of integrated unit is shown in
Figure 6. For implementation, a control signal is used to indicate SubBytes/InvSubBytes mode.
4.2. Integration of ShiftRows and InvShiftRows
ShiftRows and InvShiftRows transformations perform a cyclic shifting on each row of the State
with different numbers of byte offsets. In the ShiftRows, the first row of the state does not change,
whereas the second, third and fourth rows cyclically shift one byte, two bytes and three bytes to the
left, respectively. For the InvShiftRows, the first row of the State does not change, whereas the rest
of the rows are cyclically shifted to the right by the same offset as that in the ShiftRows. Figure 7
shows the hardware integration of ShiftRows and InvShiftRows transformations, it is clear that the
hardware implementation of both ShiftRows and InvShiftRows can be achieved by using a simple
wiring. In this implementation, E/D control signal is used to indicate ShiftRows/InvShiftRows
mode.
Copyright  2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2011; 23:1332–1347
DOI: 10.1002/cpe
ARCHITECTURE DESIGN OF AES CRYPTO-CORE FOR WPAN 1339
Figure 5. Circuit of the integration of Affine and inverse Affine transformations.
Figure 6. Architecture of SubBytes and InvSubBytes transformations.
Thus, one byte MixColumns and InvMixColumns can be merged according to Equation (2). The
schematic diagram for merging MixColumns and InvMixColumns of one byte is illustrated in
the right side of Figure 8. Subsequently, to realize the overall integration of 4-byte MixColumns
and InvMixColumns transformations, first integrate four 1-byte MixColumns and InvMixColumns
transformations, but only shift input data cyclically. The control signal E/D determines the output
data from MixColumns or InvMixColumns transformation. When working in encryption mode,
the circuit runs in MixColumns mode, and outputs the data for encryption. On the contrary, the
operation works in InvMixColumns transformation mode, and outputs the data for decryption. The
integrated unit of 16-byte MixColums and InvMixColumns can be constructed by duplicating four
copies of 4-byte MixColums and InvMixColumns transformations.
Copyright  2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2011; 23:1332–1347
DOI: 10.1002/cpe
ARCHITECTURE DESIGN OF AES CRYPTO-CORE FOR WPAN 1341
memory, and no extra delay is induced for decryption. In this case, reducing the critical path of
KeyExpansion can degrade the overhead of hardware complexity; however, it does not speed up
the whole system. For the applications in which the key needs to be changed frequently, it is
preferred to expand keys on the fly. From KeyExpansion algorithm, we can easily observe that
the critical path of KeyExpansion is composed of one multiplexer, one S-box and on XOR gate.
As the critical path of KeyExpansion is shorter than that of a round unit, reducing the critical
path of KeyExpansion will not increase the speed of the whole system. Generating round keys on
the fly eliminate the requirement for key storage, but pays penalty at hardware overhead, since
the decryption can only begin after the last round key is ready. In the applications with limited
area, generating round key on the fly is a better choice. Reference [23] is a good example of the
on-the-fly key scheduler. However, different lengths of the cipher key have different generations
of the key expansion and the round key selection. This will make it difficult to implement the
on-the-fly key scheduler. To solve such a problem and to achieve the goal of resource sharing, we
therefore developed an iterative on-the-fly key scheduler that can generate round key Ki+1, on the
fly from round key Ki and vice versa, iteratively. Moreover, the proposed iterative on-the-fly key
scheduler fully generates 128-bit, 192-bit and 256-bit cipher keys. As a result, we describe the key
scheduling for different key lengths as follows.
Let word size of round key Ki at round i be denoted as WNki+0WNki+1 · · ·WNki+(Nk−1), then key
scheduler of WNk (i+1)+l , 0≤l≤(Nk−1) for generating the next round key Ki+1 can be expressed as
Encryption : WNk (i+1)+l = KeyOperation(WNki+l ,WNk (i+1)+l−1), (3)
Decryption : WNki+l = KeyOperation(WNk (i+1)+l−1,WNk (i+1)+l ). (4)
where Nk is number of 32-bit words composing the cipher keys, Nk =4, Nk =6, and Nk =8 for
128-bit, 192-bit and 256-bit cipher keys, respectively. Equations (3) and (4) mean WNki+l and
WNk (i+1)+l−1 will generate WNk (i+1)+l for encryption, whereas, WNk (i+1)+l−1 and WNk (i+1)+l will
generate WNki+l for decryption.
According to the AES algorithm specification, the length of the State in each round function is
128. So, a 128-bit round key is needed and is decided from the expanded keys. As described in the
key expansion algorithm, the 128-bit cipher key will generate the 128-bit key K0 in the next time,
and the 128-bit key K0 will generate the 128-bit key K1 in the next time, and so on. That is, the
key scheduler of 128-bit cipher will generate W4 using W0 and W3 will generate W5 using W1 and
W4, and so on. Clearly, because the length of the cipher key is equal to the length of the State, the
decision of the round key in each round function is simple. In other words, every 128-bit generated
key is used in each round function. For decryption, W3 and W4 will generate W0 and so on.
Similar to 128-bit cipher key, the 192-bit cipher key will generate the 192-bit key K1 in the
next time and so on. That is, W0 and W5 will generate W6, W1 and W6 will generate W7, and so
on. However, the length of the cipher key is different from that of the State, the Round Key—4
words in each round function cannot be mapped directly from the generated Key—6 words. To
solve the problem, the list of the generated keys should be rearranged so that the relation between
the round key and the generated key can be satisfied easily. After rearrangement, the generated
key not only maps to the current round key, but also maps to the next round key. For example,
W6 and W7 are mapped into round key K1. W8, W9, W10 and W11 are mapped into round key K2.
So there is a little difference to implement the on-the-fly key scheduler for 128-bit cipher key and
192-bit cipher key. The key scheduling of 192-bit cipher key for decryption is similar to that of
192-bit cipher key for encryption. However, the difference is the order of the generated keys. For
decryption, W5 and W6 will generate W0, W6 and W7 will generate W1, and so on.
Also as described above, the 256-bit cipher key will generate the 256-bit key K0 in the next
time and so on. For encryption, W0 and W7 will generate W8, W1 and W8 will generate W9, and
so on. Similar to the 192-bit cipher key, the generated key from the 256-bit cipher key initially
not only maps to the current round key, but also maps to the next round key. After rearrangement,
the length of the generated key is twice more than that of the round key and the generated key
is directly mapped to the round key of two round functions. For example, W8, W9, W10 and W11
Copyright  2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2011; 23:1332–1347
DOI: 10.1002/cpe
ARCHITECTURE DESIGN OF AES CRYPTO-CORE FOR WPAN 1343
Table I. The arrangement of EKSs.
Round AES-128 AES-192 AES-256
1 Z0 Z2 Z2 Z2 Z3 Z3 Z0 Z2 Z3 Z3 Z3 Z3
2 Z2 Z2 Z2 Z2 Z0 Z2 Z2 Z2
3 Z0 Z2 Z2 Z2 Z1 Z2 Z2 Z2
4 Z2 Z2 Z0 Z2 Z0 Z2 Z2 Z2
5 Z2 Z2 Z2 Z2 Z1 Z2 Z2 Z2
6 Z0 Z2 Z2 Z2 Z0 Z2 Z2 Z2
7 Z2 Z2 Z0 Z2 Z1 Z2 Z2 Z2
8 Z2 Z2 Z2 Z2 Z0 Z2 Z2 Z2
9 Z0 Z2 Z2 Z2 Z1 Z2 Z2 Z2
10 Z2 Z2 Z0 Z2 Z0 Z2 Z2 Z2
11 Z2 Z2 Z2 Z2 Z1 Z2 Z2 Z2
12 Z0 Z2 Z2 Z2 Z0 Z2 Z2 Z2
13 Z1 Z2 Z2 Z2
14 Z0 Z2 Z2 Z2
Figure 10. Architecture design of elementary key schedulers.
indicates encryption mode, performing in encryption mode the output is ciphertext; on the contrary,
performing in decryption mode the output is plaintext. Block diagram of the proposed AES core
is shown in Figure 11, where the detailed block diagrams and data paths of AES_round and
Copyright  2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2011; 23:1332–1347
DOI: 10.1002/cpe
ARCHITECTURE DESIGN OF AES CRYPTO-CORE FOR WPAN 1345
Figure 13. Detailed block diagram and data path of KeyExpansion.
Table II. Implementation results of the proposed design.
Key Length AES-128 AES-192 AES-256
Freq. (MHz) 175.75
Memory (BRAMs) 0
Slices 2,420
Equiv. Gate Count (GC) 47.6 K
Throughput (Mbps) 681.70(En)/340.85(De) 576.82(En)/288.41(De) 499.91(En)/249.96(De)
Mbps/Slice 0.282(En)/0.141(De) 0.238(En)/0.119(De) 0.207(En)/0.104(De)
Mbps/KGC 14.32(En)/7.16(De) 12.12(En)/6.06(De) 10.5(En)/5.25(De)
Core dynamic Power (mW) 234.33
implementation results, this shows that the proposed AES crypto-core utilizes low area, relative high
throughput and low power consumption to really achieve the requirement of WPAN applications.
Note that the formula (128×frequency)/clocks is used to calculate the throughput; meanwhile,
one BRAM (Block RAM) is equivalent to 128 slices [13] in the computation of throughput/slice.
Performance comparisons of other architectures are shown in Table III. It is clear that most of the
designs were developed regarding area-throughput efficiency by de-emphasizing power consump-
tion, only the proposed design takes tradeoff among area, throughput, and power to achieve the best
optimization for WPAN applications. Table III also shows that the area-throughput efficiency of our
AES crypto-core under very low power consumption almost achieves as that of high-throughput
AES-128 Open Code [24], and much better than that of low data rate AES-128 Open Code [25].
6. DISCUSSIONS AND CONCLUSIONS
In this paper, we present methods to develop a high efficient and non-memory AES crypto-core
to fit WPAN security requirement. The proposed basis transformation approach from Galois Field
(28) to Galois Field GF(((22)2)2) can significantly reduce the hardware complexity of the SubBytes
transformation (S-box). Besides, the on-the-fly key expansion function is used to replace the
RAM-based, and the new on-the-fly key scheduler fully supports AES-128, AES-192 and AES-
256. Moreover, MixColumns/InvMixColumns resource-sharing scheme will also be employed to
reduce the hardware complexity of the cipher and decipher. The resulting hardware-efficient FPGA
Copyright  2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2011; 23:1332–1347
DOI: 10.1002/cpe
ARCHITECTURE DESIGN OF AES CRYPTO-CORE FOR WPAN 1347
implementation of the AES algorithm shows that it can serve as the crypto-engine for the modern
cryptographic systems.
ACKNOWLEDGEMENTS
The authors thank the anonymous reviewers for their valuable suggestions to improve this paper.
The National Science Council of Republic of China under the contract NSC-97-2221-E-239-036-MY3
supported this work.
REFERENCES
1. IEEE 802.15 WPAN Task Group 1 (TG1). Available at: http://www.ieee802.org/15/pub/TG1.html [April 2010].
2. IEEE 802.15 WPANTM Task Group 4 (TG4). Available at: http://www.ieee802.org/15/pub/TG4.html [April 2010].
3. IEEE 802.15 WPAN Task Group 3 (TG3). Available at: http://www.ieee802.org/15/pub/TG3.html [April 2010].
4. IEEE 802.15 WPAN High Rate Alternative PHY Task Group 3a (TG3a). Available at: http://www.ieee802.org/
15/pub/TG3a.html [April 2010].
5. National Institute of Standards and Technology (NIST). Data Encryption Standard (DES), National Technical
Information Service, Springfield, VA 22161, October 1999.
6. National Institute of Standards and Technology (NIST). Advanced Encryption Standard (AES), National Technical
Information Service, Springfield, VA 22161, November 2001.
7. Stallings W. Cryptography and Network Security: Principles and Practice (3rd edn). Prentice-Hall Inc.: Upper
Saddle River, NJ, 2003.
8. Daemen J, Knudsen LR, Rijmen V. The block cipher square. Proceedings of the Fast Software Encryption 1997,
(Lecture Notes in Computer Science, vol. 1267), Biham E (ed.). Springer: Berlin, 1997; 149–165.
9. Song B, Seberry J. Further observations on the structure of the AES algorithm. Proceedings of the Fast Software
Encryption 2003 (Lecture Notes in Computer Science, vol. 2887), Johansson T (ed.). Springer: Berlin, 2003;
223–234.
10. Ferguson N, Schroeppel R, Whiting D. A simple algebraic representation of Rijndael. Proceedings of the Selected
Areasin Cryptography (SAC) 2003 (Lecture Notes in Computer Science, vol. 2259). Springer: Berlin, 2003;
103–111.
11. Daemen J, Rijmen V. AES Proposal: Rijndael, AES algorithm submission. Available at: http://www.nist.gov/
CryptoToolkit [September 2009].
12. Draft FIPS for the AES. Available at: http://csrc.nist.gov/encryption.aes [February 2001].
13. Zhang X, Parhi K. High-speed VLSI architecture for the AES algorithm. IEEE Transactions on VLSI Systems
2004; 12(9):957–967.
14. Yoo S, Kotturi D, Pan D, Blizzard J. An AES crypto chip using a high-speed parallel pipelined architecture.
Microprocessors and Microsystems 2005; 29(7):317–326.
15. Hodjat A, Verbauwhede I. Area-throughput trade-offs for fully pipelined 30 to 70 Gbits/s AES processors. IEEE
Transactions on Computers 2006; 55(4):366–372.
16. Su C-P, Lin T-F, Huang C-T, Wu C-W. A high throughput low cost AES processor. IEEE Communications
Magazine 2003; 41(12):86–91.
17. McLoone M, McCanny J. High performance single-chip FPGA Rijndael algorithm implementations. Proceedings
of Cryptographic Hardware and Embedded Systems Workshop, CHES, Paris, May 2001.
18. Jarvinen KU, Tommiska MT, Skytta JO. A fullypipelined memoryless 17.8 Gbps AES-128 encryptor. Proceedings
of International Symposium on Field-programmable Gate Arrays (FPGA 2003), Monterey, CA, February 2003;
207–215.
19. Saggese GP, Mazzeo A, Mazocca N, Strollo AGM. An FPGA-based performance analysis of the unrolling, tiling
and pipelining of the AES algorithm. Proceedings of FPL 2003, Portugal, September 2003.
20. Elbert AJ, Yip E, Chetwynd B, Paar C. An FPGA implementation and performance evaluation of the AES block
cipher candidate algorithm finalists. IEEE Transactions on VLSI 2001; 9(4):545–557.
21. Standaert F, Rouvroy G, Quisquater J, Legat J. Efficient implementation of Rijndael encryption in reconfigurable
hardware: improvements & design tradeoffs. Proceedings of CHES 2003, Cologne, Germany, September 2003.
22. Jyrwa B, Paily R. An area-throughput efficient FPGA implementation of the block cipher AES algorithm.
Proceedings of IEEE International Conference on Advances in Computing, Control, and Telecommunication
Technologies, ACT ’09, Thiruvananthapuram, India, December 2009.
23. Homg C-L. An AES cipher chip design using on-the-fly key scheduler. PhD Thesis, Department of Electrical
Engineering, National Tsing Hua University, Hsinchu, Taiwan, June 2004.
24. High throughput AES Open Code. Available at: http://www.opencores.org/project,aes_core,overview [April 2010].
25. Low data rate AES Open Code. Available at: http://www.opencores.org/project,systemcaes,overview [April 2010].
Copyright  2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2011; 23:1332–1347
DOI: 10.1002/cpe
T-IFS-02264-2011 
 
1
Anti-Forensic Steganography Using Multi-bit 
Adaptive Embedding Algorithm with Minimum 
Error Replacement and Flexible Bit Location 
Rong-Jian Chen, Senior Member, IEEE and Shi-Jinn Horng 
  
Abstract—Multi-bit minimum error replacement (MER) is a 
method that can embed multi-bit logo/secret data into k 
least-significant bits (LSBs) of cover data only introduces 
minimum embedding error (MEE). However, k-LSBs MER 
suffers from weak anti-forensics. Moreover, it is unfortunate 
because other previous steganography works have seldom 
considered both large embedding capacity and high image quality. 
Therefore, this work proposes an anti-forensic steganography 
system using multi-bit adaptive embedding algorithm with 
flexible bit location to overcome the problem of forensics and to 
achieve high performance includes both large embedding capacity 
and high image quality. The proposed embedding algorithm 
embeds and hides multi-bit (k-bit, ) logo/secret data into any 
adjoining (starting with the ith location) k-bit of 
cover data only introduces MEE in the range of 0 to 
1≥k
11 +−− kiii bbb L( ) kik −−± 212
kN ≥
 
; 
moreover, its flexible bit location enhances the embedded security 
as security increases as embedding location increases. This work 
also develops the formulations of multi-bit MEEs to look their 
features and to easily develop the proposed embedding algorithm. 
As the proposed embedding algorithm can embed multi-bit 
logo/secret data into any adjoining bits of cover data and has large 
embedding capacity and high embedding quality, this method was 
applied to develop image steganography systems. Finally, 
anti-forensics of the proposed steganography systems are 
demonstrated using the visual attack and the statistical attack of 
Chi-square analysis. 
 
Index Terms—steganographgy, anti-forensics, multi-bit 
embedding, minimum-error replacement, flexible bit location 
 
I. INTRODUCTION 
N information and data hiding, the minimum-error 
replacement (MER) approach is typically used to find data as 
close to the original as possible. Generally, if one wants to 
embed k-bit secret data into N-bit ( ) cover data, 
replacing the k-LSBs of cover data will introduce fewer errors 
than replacing any other k bits. In this case, the embedding 
error introduced is from 0 to ( )12 −k
kN −2
kN −
± . Considering N-bit 
cover data,  values whose k-LSBs are identical exist in the 
embedded k bits. To achieve the highest quality, should use the 
most similar data among these 2  values to replace the 
original. Many LSB-based methods [1-9] have been developed 
to use in steganography application. Lee et al. [1] developed a 
two-step MER method to find the closest data value to 
minimize the errors. In [1], capacity evaluation (CE)-uses the 
gray-scale variation of neighboring pixels and their intensity to 
evaluate embedding capacity, such that it can be improved. 
Wang et al. [2] designed an optimal LSB substitution method 
that uses a genetic algorithm to search for an approximately 
optimal solution to a special mapping problem. This special 
mapping function transforms secret data values into another set 
of values. The transformed values are then embedded into 
LSBs, such that embedded data have minimum errors. Chang et 
al. [3] proposed another optimal LSB substitution method via 
dynamic programming to obtain the optimal solution. Chan et 
al. [4] developed a simple LSB substitution method using an 
optimal pixel adjustment process (OPAP) [5, 6] to reduce the 
magnitude of embedding errors. OPAP methods used the least 
k-bit to embed secret data and at the same time toggles the 
(k+1)th bit while comparing the toggle with least distortion. To 
achieve high embedding capacity, Lee and Chen [7] proposed a 
data hiding scheme based on the modulus function (HBMF), in 
which a variant Cartesian product is operated upon the modulus 
function to hide and extract the message. In HBMF method, the 
size of the variant Cartesian product is examined to evaluate the 
feasibility of embedding more secret data. Zhang and Wang [8] 
proposed an exploiting modification direction (EMD) hiding 
method to achieve high embedding quality. The EMD 
technique hide a (2n+ 1 )-ary secret digit for every n pixels in 
the cover image by adding or subtracting one at most within 
one particular pixel in the group, thus the cover pixel is slightly 
modified.  However, the major drawback of EMD is it can’t 
restore the cover image directly. Some modified EMD methods 
have been proposed in [9-11] to enhance the embedding 
capacity because the original EMD has seldom considered 
embedding capacity. Especially, [11] presented two novel 
approaches, the HoEMD and the AdEMD, to achieve high 
efficiency, high quality and large embedding ratios, use the 
I
Manuscript received December 02, 2011. The National Science Council of 
Republic of China under the contract NSC-97-2221-E-239-036-MY3 and 
NSC-100-2221-E-239-033 supported this work. Ted Knoy is appreciated for 
his editorial assistance. 
Rong-Jian Chen is with the Department of Electronic Engineering, National 
United University, Miaoli, Taiwan (phone: +886-37-381-509; fax: 
+886-37-362-809; e-mail: rjchen@ nuu.edu.tw).  
Shi-Jinn Horng is with Department of Computer Science and Information 
Engineering, National Taiwan University of Science and Technology, Taipei, 
Taiwan (e-mail: horngsj@yahoo.com.tw). 
 
T-IFS-02264-2011 
 
3
and 255. For embedding 2-bit secret data ‘01’ into b2b1 of 8-bit 
cover data, the BO is also -7 but only at 255. On the contrary, 
embedding 2-bit secret data ‘11’ into  of 8-bit cover data, 
it introduces BO with value +7 at 0, 1 and 2. For embedding 
2-bit secret data ‘10’ into  of 8-bit cover data, the BO is 
also +7 but only at 0.  
12bb
12 +i
12bb
Notably, Fig. 1 shows that some intervals have zero BEEs 
but the other intervals are not. For 2-bit MER embedding cases, 
after 2-bit MER embedding, when secret data EBs equal  
of cover data then the corresponding embedded data have no 
BEEs, that is, the embedded data are the same as the original 
cover data. Clearly, if secret data EBs do not equal b of 
cover data, the corresponding embedded data will have 
non-zero bipolar MEEs. These observations give us the chance 
to look the features of multi-bit BEEs, because it clearly shows 
that the BEEs of embedding 2-bit secret data into any adjoining 
2-bit of cover data. Therefore, we have the motivation to 
establish the formulations and properties of multi-bit BEEs in 
the following subsection. 
1−iibb
1−iib
A. The Formulations of Multi-bit BEEs 
In this subsection, we will develop the formulations of 
multi-bit BEEs to easily look their features. We firstly give 
definitions of some notations: , ,  
, 
=iP ( )⎥⎥⎤⎢⎢⎡= ∑
−
=
−−1
0
12
k
m
mi
AN
12 +−= kiBN ⎡ ⎤( )12 +k2= −kiCN , 
,( ) ⎟⎟⎠⎞+− 12 mi⎜⎜⎝⎛−= ∑
−
=
−
1
0
k
m
BO [ ]n−
⎡g
)
n−−11
{ }
E
( 2
ki= +−2
⎤
, and 
,  where notation  means the ceiling of g. 
Next, we divide the k-bit secret data into two separated groups 
and 
[ ]nE i= ++ 12
{ 320 xx kk −− L
n−
01 0xx ↔} x ( )2013 1xxxk21 xxk ↔− L−  
based on the value of . Where 1−kx φ∈x (empty space) for 
; otherwise, x is the binary value of for 
. The 1’s complementary of x is denoted as 
1=k
2≥k
0132 xxxx kk L−−
( )2121 +−−−= kiii xxxx L . Then, the BEE of multi-bit embedding 
can be expressed as the followings 
[ ] [ ][ ]⎪⎩
⎪⎨
⎧
≤≤
≤≤
≤≤
=
+
−
,
,
0,0
~00
,
C
Bki
nNnE
nNnE
Nn
ne
[ ] ( )[ ]iBkixki PxNnene %
−
−
−
1
1
1
i
C
B
P
N , .                    (2) 10 −≤ ≤ iPn
~~ 00
,
0
, −= n, 0 .                               (3) 1−≤ iP≤
[ ] [ ]ixkixki PlelEP %~0,0, = 0 ≤, .                                         (4) −≤ Gl
+
−
xN
N
B
A
≤ l
1
[ ]
⎩⎨ ≤≤−
=
− ,
, lNGBO
xN
lBO
A
ki
[ ] [ ] [ ]lBOlEPle xkixkixki 0,0,0, += −≤ G
⎧ ≤0,00x
−
−
1
1
G
B
1
+≤ Gl
.                               (5) 
, 0 .                                (6) 
[ ] [ ]lGele xkixki −−−= 10,1, , 0 .                                     (7) 1−≤≤ Gl
[ ]nk00
 
A special sequence
 
ei,
~  is defined in (2) and it’s right 
rotation version ( )[ ]iBki PxNne %~00, −  with  steps in the 
range of ,  that is 
BxN
iP [ ]ne xki0,~ , is defined in (3). Notably both 
[ ]nE−  and [ ]nE+  of [ ]ne ki00,~  are odd anti-symmetric. Either 
[ ]ne ki00,~  or [ ]nxk0,ei~  is the fundamental sequence of the periodic 
sequence [ ]lki00,EP  or [ ]lEP xki0,
EP xki
0
,
 with period  which have been 
defined in (4). We called , 
iP
0[ ]l 1−≤≤ Gl  and 
 as periodic error sequences due to them are 
periodic and each of them is one of major components of BEE. 
The BO sequence of 
1−2 1−k0 ≤≤ x
( )20x  group is denoted as [ ]lBO xki0,  and is 
defined by (5). It shows that the non-zero value of [ ]lBO xki0,  and 
its starting point depend on the values of both i and k. Moreover, 
the value and the length of non-zero value of [ ]lxki0,BO  increase 
as the values of i and/or k increases. That is, higher embedding 
location and/or more embedding bits will introduce bigger 
magnitude and longer length of BO than those of lower 
embedding location and/or less embedding bits. Equation (5) 
also shows that there are sequences of 12 −k [ ]lxki0,BO  with the 
same length G in the group ( )20x  but their length of non-zero 
value are different. It is clear that the length of non-zero value 
of [ ]lBOi xk0,  is decreasing with value of N  as the value of x 
increasing. It also clearly shows non-zero values of 
B
[ ]lxkBOi0,  
are negative and appears in around of G-1. Equation (6) means 
that BEE [ ]lxki0,e  consists of one periodic error sequence 
[ ]lEP xki0,  and one boundary overshoot [ ]lxki0,BO . Equation (7) 
shows that BEE [ ]le xki1,  is negative and position-reversal of 
[ ]le xki0, . Because [ ]le xki1,  is negative and position-reversal of 
[ ]le xki0,  therefore it can be evaluate from [ ]le xki0,  even if [ ]lxkBOi1,  
and [ ]ne xki1,~  are unknown. 
By the same way of [ ]le xki0, [ ]le xki1,
[ ]lEP xki1,
,  can be expressed in term 
of periodic error sequence  with period N and boundary 
overshoot [ ]lBO xki1, , that is, 
[ ] [ ] [ ]lBO xki1, −≤l +EP xki1,le xki1, = , 0 1≤ Gl .                                   (8) 
Alternatively, because combining (6) and (7) results in 
[ ] [ ] [ ]lG −−1BOl i− 0,Gxk −0EPi− ,le xki =1, xk−1 , 0 1−≤≤ Gl .        (9) 
Hence, compare (8) with (9) then we have 
[ ] [ ]l−1 0GEP xki0,lEP xki1, −−= , .                              (10) 1−≤ G≤ l
[ ] [ ]l−1GBOlBO kixki 0,1, x −−= , 0 .                              (11) 1−≤ Gl
i
1
,
≤
Equation (10) clearly shows that EP  is negative and 
position-reversal of 
[ ]lxk
[ ]lEP xki0, . Similarly, (11) shows that 
[ ]lBO xki1, [ ]lBO xki0, is negative and position-reversal of . 
Moreover, positive values of  appears in around of 0.  [ ]lBO xki1,
T-IFS-02264-2011 
 
5
the boundary overshoot as (8). Notably, Fig. 3d shows that the 
BEE of ‘11’-embedding is worse than that of ‘10’-embedding 
because ‘11’-embedding suffers from worse boundary 
overshoot than ‘10’-embedding. Figures 2 and 3 clearly show 
that the corresponding sequences for ‘ ’-embedding and 
those for ‘
x0
x1 ’-embedding are mutually negative and 
position-reversal in the defined domain. For example, 
fundamental sequences [ ]ne 002,5~  and [ ]ne 112,5~  ( [ ]n012,5e~  and [ ]ne 102,5~ ) 
are mutually negative and position-reversal in the range from 0 
to 63. Moreover, BO115 BO
00
2,5 [ ]l2[ ]l  and 2, [ ]l  ( BO10,5  and [ ]l012,5 ) 
ally negative and position-reversal  in the range from 0 
to 255. 
BO
1−ib
are mutu
B. Case Study of The Multi-bit Extended MER for New 
Algorithm Developing 
Notably, all k-LSBs based methods [1-9] were also 
developed to obtain MSE. However, these methods were only 
designed for a special purpose and, thus, do not offer a regular 
and formalized algorithm for easy software implementation or 
even hardware implementation for general-purpose 
applications. Therefore, this work develops a regular and 
formalized algorithm for easy software implementation and 
hardware implementation. Let the most-significant bits (MSBs) 
be the bits greater than bbb L  and the least-significant 
bits (LSBs) be the bits less than . Then, input 
MSBs (IMSBs) and input LSBs (ILSBs) denote the MSBs and 
LSBs of cover data, respectively. Additionally, output MSBs 
(OMSBs) and output LSBs (OLSBs) denote the MSBs and 
LSBs of embedded data, respectively. Thus, cover data can be 
divided into three parts—IMSBs, bbb L , and ILSBs 
from a bitwise perspective. Additionally, embedded data can be 
divided into three parts: OMSBs, EBs, and ILSBs. 
1+k
1−iibb
−ii
1−ii
iibb
−i
1−
1+k
1+−k
−iibb
−ibL
1 i
The following shows some cases of the 2-bit MER scheme to 
demonstrate how it achieves multi-bit minimum error 
embedding. Figure 4 shows four cover data with values 9210, 
8310, 11110 and 10310 that will be embedded 2-bit secret data 
into the . After 2-bit extended MER embedding, when 
secret data EBs equal  of cover data then the 
corresponding embedded data have no errors, that is, the 
embedded data are the same as the original cover data.  This 
case is summarized as case 1 (OMSBs = IMSBs and OLSBs = 
ILSBs). Figures 5 and 6 show cases of 2-bit embedded data 
have non-zero errors. Clearly, if secret data EBs do not equal 
of cover data, the corresponding embedded data will have 
non-zero errors. For 00- and 01-embeddings, after b  has 
been changed, case 2 (OMSBs = IMSBs + 1 and OLSBs = 0s 
under 12 −< kEB ) (Fig. 5a), case 3 (OMSBs = IMSBs and 
OLSBs = 1s under 12 −< kEB ) (Fig. 5b), or case 4 (OMSBs = 
IMSBs and OLSBs = 0s under 12 −< kEB ) (Fig. 5c) occurs. 
However, for 10- and 11-embeddings, after  has been 
changed, case 5 (OMSBs = IMSBs - 1 and OLSBs = 1s under 
12 −≥ kEB ) (Fig. 6a), case 6 (OMSBs = IMSBs and OLSBs = 0s 
under ) (Fig. 6b), or case 7 (OMSBs = IMSBs and 
OLSBs = 1s under ) (Fig. 6c) occurs. 
34bb
1−iibb
i
1
12 −≥ kEB
12 −≥ kEB
 
  
  
Fig. 4. Cover data will be embedded 2-bit secret data into , values 9210, 
8310, 11110, and 10310. 
34bb
 
 
(a)                                              (b) 
 
(c) 
Fig. 5. The 2-bit MER with non-zero errors for 00- and 01-embeddings, (a) 
embedded data 9610 of 9210 with error +4, (b) embedded data 7910 of 8310 with 
error -4, (c) embedded data 10410 of 10310 with error +1. 
 
 
(a)                                              (b) 
 
(c) 
Fig. 6. The 2-bit MER with non-zero errors for 10- and 11-embeddings, (a) 
embedded data 9510 of 10310 with error -8, (b) embedded data 11210 of 11110 
with error +1, (c) embedded data 8710 of  9210 with error -5. 
 
Here, the problem arises as to how the extended MER makes 
cases 1, 2, 3, 4, 5, 6, and 7 occur.  If one can identify some 
special criteria, decision rules can be developed based on these 
special criteria. Then, one can make the extended MER to do 
cases 1, 2, 3, 4, 5, 6, and 7 according to the decision rules. This 
requirement provided the motivation to develop a new 
embedding algorithm for the extended MER. Moreover, 
operations in cases 1, 2, 3, 4, 5, 6, and 7 from the bitwise 
perspective are very simple and only consist of duplications 
(OMSBs = IMSBs and OLSBs = ILSBs), arithmetic addition 
and subtraction (OMSBs = IMSBs + 1 and OMSBs = IMSBs - 
1), clearing all bits to 0 (OLSBs = 0s), and setting all bits to 1 
(OLSBs = 1s). This shows that the proposed embedding 
algorithm can be implemented very easily using software and 
even hardware approaches. Thus, a novel simple and efficient 
multi-bit A3S embedding algorithm was developed. 
 
III. THE A3S EMBEDDING ALGORITHM 
Some simple and efficient criteria and decision rules, which 
can be used for MER to generate cases 1, 2, 3, 4, 5, 6, and 7, 
were identified by observations and many MER simulations. 
This section uses these criteria and decision rules to develop 
multi-bit A3S embedding algorithm. This section also 
demonstrates how this algorithm achieves the minimized 
embedding error. In the followings,  denotes the mth 
criterion of the k-bit MER. 
mR
A. Multi-bit A3S Embedding Algorithm 
For k-bit MER, the first criterion is 1R  (EBs == 
11 +−− kii  of cover data), that is EBs ==Data, and the first 
decision rule is that if 1R  is true, then case 1 occurs; otherwise 
i bbb L
T-IFS-02264-2011 
 
7
achieving minimum error embedding. The third example is that 
of embedding secret datum EB = 102 into  of cover data 
with a value of 11110.  In step 1, secret datum EB = 102 is 
embedded into b4b3 of cover data. Next, OLSBs = 0s 
because  is true and  is false. Then, OMSBs = IMSBs and 
the procedure stops. Finally, embedded datum has a value of 
11210, only introducing +1 embedding error, achieving 
minimum error embedding. The last example is that of 
embedding secret datum EB = 112 into  of cover data with 
a value of 10310.  In step 1, the secret datum EB = 112 is 
embedded into  of cover data. Next, OLSBs = 1s because 
, , and  are true. Then, OMSBs = IMSBs-1 and then 
the procedure is stopped. Finally, embedded data has a value of 
9510, and only -8 embedding error is introduced, achieving 
minimum embedding error. These findings demonstrate that 
the proposed multi-bit A3S embedding algorithm achieves 
minimum embedding error, as was expected. 
34bb
3
3R
2R
8R 9R
1−k
4bb
34bb
10
8
8R 9R R
B. Exceptions of Overflow/Underflow Problems in the 
Proposed A3S Algorithm 
In data embedding procedure, overflow/underflow problems 
occur since the cover pixels have finite bits and when they are 
near the boundaries 0 or 255. For example, embed secret data 
0002 into cover data near 255 will occur overflow since it could 
conduct IMSBs will be increased one, that is OMSBs = 
IMSBs+1. Whereas, embed data 1112 into cover data near 0 
will occur underflow because it could conduct IMSBs will be 
decreased one, that is OMSBs = IMSBs-1. To overcome 
overflow/underflow problems, two criteria  (any bit of 
IMSBs is 0) and R  (any bit of IMSBs is 1) have been utilized in 
our proposed algorithm. For k-kit embedding, if secret data 
value smaller than 2 , i.e. the criterion  ( 1−2< kEB
R
12 −k
 ) is 
true, then criterion  checks overflow possibility of IMSB to 
decide whether IMSB will be increased one or not.  If  is 
true means IMSBs hasn’t overflow possibility, then OMSBs = 
IMSBs+1 can be executed. Once the IMSB has overflow 
possibility, our proposed embedding algorithm will keep IMSB 
value and then adaptively adjust ILSB value based on the 
criterion  ( ) to achieve minimum embedding 
error. Notably, such an exception of overflow inherently 
induces the boundary overshoots with negative values as (5). 
Meanwhile, if secret data value larger than or equals to , i.e. 
the criterion  is false, then criterion R  checks underflow 
possibility of IMSB to decide whether IMSB will be decreased 
one or not. If  is true means IMSBs hasn’t underflow 
possibility, then OMSBs = IMSBs-1 can be executed. Once the 
IMSB has underflow possibility, our proposed embedding 
algorithm will keep IMSB value and then adaptively adjust 
ILSB value based on the criterion  ( ) to achieve 
minimum embedding error. Notably, such an exception of 
underflow inherently induces the boundary overshoots with 
positive values as (11).  
3R
EB <
2
8R
3
7R Data
R 8
Data>12R EB
The above procedures work well in our proposed algorithms, 
thus our embedding scheme never suffers from the 
overflow/underflow problems. Moreover, they co-operate with 
the adaptive adjustment of ILSB to achieve minimum 
embedding error. 
C. Mathematical Expressions of the Proposed A3S 
Algorithm 
In this subsection, we will illustrate the mathematical 
expressions of the proposed A3S algorithms.  The step 1 of the 
proposed A3S algorithms can be expressed as 
⎩⎨
⎧ ≠=
.otherwise,
,f,
Data
DataEBiEB
Data                                          (15) 
Steps 2 and 3 of the A3S algorithms would be merged for easily 
develop the mathematical expressions. For k-bit embedding, 
the merged result of steps 2 and 3 can be divided into five 
categories ( ), they can be expressed as the 
followings. 
51, ≤≤ lM kl
Case : kM 1 DataEB ==  
⎩⎨
⎧
=
=
.
,
IMSBsOMSBs
ILSBsOLSBs
                                                            (16) 
Case : kM 2 DataEB ≠ & & non-overflow 12 −< kEB( )( )
⎩⎨
⎧
=
=
⎩⎨
⎧
≥≥++=
<+=
−−
−
.otherwise
,
,1
,2and2,1
or2if,0
1
1
IMSBsOMSBs
sOLSBs
ILSBsDataEBIMSBsOMSBs
DataEBsOLSBs
kik
k
   (17) 
Case : kM 3 DataEB ≠ & & overflow 12 −< kEB
⎩⎨
⎧
=
=
⎩⎨
⎧ <=
=
.otherwise
,
,0
,if
,
,1
IMSBsOMSBs
sOLSBs
DataEB
IMSBsOMSBs
sOLSBs
                                       (18) 
Case : kM 4 DataEB ≠ & & non-underflow 12 −≥ kEB( )( )
⎩⎨
⎧
=
=
⎩⎨
⎧
<≤−−=
>−=
−−
−
.otherwise
,
,0
,2and2,1
or2if,1
1
1
IMSBsOMSBs
sOLSBs
ILSBsDataEBIMSBsOMSBs
DataEBsOLSBs
kik
k
   (19) 
Case : kM 5 DataEB ≠ & & underflow 12 −≥ kEB
⎩⎨
⎧
=
=
⎩⎨
⎧ >=
=
.otherwise
,
,1
,if
,
,0
IMSBsOMSBs
sOLSBs
DataEB
IMSBsOMSBs
sOLSBs
                                  (20) 
For 1-bit ( 1=k ) embedding,  ( ) means 12 −< kEB 12 −≥ kEB
1<EB  ( ), i.e. 1≥EB 0=EB  ( ). These facts cause 1=EB
DataEB ≠ & 1−2< kEB  ( & ) means Data≠EB 12 −≥ kEB
0=EB  ( 1=EB ),  ( ) is 
always false (false), and  ( ) 
is always true (true). Thus, the mathematical expressions of 
1-bit A3S algorithm are simpler versions of that of multi-bit.  
Data EB
Datak ≥−1
EB k <+ −12
EB + 2
Datak >− −12
EB k− −12 Data≤
 
T-IFS-02264-2011 
 
9
stego-images even when EC exceeded 50%. During 
experiments, we knew that retrieved secret images were 
lossless because they are identical to the original images. Thus, 
the proposed multi-bit bitwise A3S embedding algorithm 
generates good-quality stego-images and achieves high 
embedding capacity for image steganography. 
 
 
 
Fig. 9. Stego-images of Lena: R1G1B1, PSNR 51.15 dB, EC 12.5%; R2G2B2, 
PSNR 46.37 dB, EC 25%; R3G3B2, PSNR 41.93 dB, EC 33.3%; R3G3B3, 
PSNR 40.71 dB, EC 37.5%; R4G4B4, PSNR 34.76 dB, EC 50%; R5G4B4, 
PSNR 31.77 dB, EC 54.2%. (From top left to bottom right) 
 
 
 
Fig. 10. Stego-images of Sailboat: R1G1B1, PSNR 51.15 dB, EC 12.5%; 
R2G2B2, PSNR 46.37 dB, EC 25%; R3G3B2, PSNR 41.93 dB, EC 33.3%; 
R3G3B3, PSNR 40.72 dB, EC 37.5%; R4G4B4, PSNR 34.78 dB, EC 50%; 
R5G4B4, PSNR 31.75 dB, EC 54.2%.  (From top left to bottom right) 
 
 
 
Fig. 11. Stego-images of Vegetables: R1G1B1, PSNR 51.14 dB, EC 12.5%; 
R2G2B2, PSNR 46.37 dB, EC 25%; R3G3B2, PSNR 41.77 dB, EC 33.3%; 
R3G3B3, PSNR 40.56 dB, EC 37.5%; R4G4B4, PSNR 34.35 dB, EC 50%; 
R5G4B4, PSNR 31.03 dB, EC 54.2%.  (From top left to bottom right) 
 
TABLE 3 
EC AND PSNR OF 24-BIT STEGO-IMAGES FOR THREE SECRET 
IMAGES EMBEDDING (UNIT: dB) 
Cover Image  EC (bits/%) 1/4.2 2/8.3 3/12.5 4/16.7 5/20.8 
Baboon 55.96 52.90 51.14 48.91 47.44 
Barbara 55.90 52.89 51.14 48.94 47.48 
Boat 55.90 52.91 51.15 48.96 47.48 
Goldhill 55.94 52.93 51.17 48.95 47.49 
Jet 55.92 52.91 51.14 48.94 47.47 
Lena 55.91 52.90 51.15 48.94 47.47 
Peppers 55.89 52.89 51.13 48.91 47.45 
Sailboat 55.92 52.91 51.15 48.92 47.45 
Tiffany 55.91 52.91 51.14 48.91 47.44 
Vegetables 55.90 52.90 51.14 48.93 47.45 
Windmill 55.90 52.86 51.13 48.33 47.05 
Zelda 55.90 52.89 51.32 48.92 47.44 
Average 55.91 52.90 51.16 48.88 47.43 
 
TABLE 3 (CONT.) 
EC AND PSNR OF 24-BIT STEGO-IMAGES FOR THREE SECRET 
IMAGES EMBEDDING (UNIT: dB) 
Cover Image  EC (bits/%) 6/25.0 7/29.2 8/33.3 9/37.5 10/41.7
Baboon 46.36 43.59 41.94 40.72 37.78 
Barbara 46.38 43.85 41.80 40.60 37.47 
Boat 46.40 43.29 41.53 40.41 37.11 
Goldhill 46.39 43.36 41.71 40.53 37.25 
Jet 46.38 43.60 41.92 40.71 37.78 
Lena 46.37 43.61 41.93 40.71 37.79 
Peppers 46.38 43.39 41.64 40.50 37.31 
Sailboat 46.37 43.61 41.93 40.72 37.76 
Tiffany 45.98 43.39 41.66 39.80 37.29 
Vegetables 46.37 43.37 41.77 40.56 37.28 
Windmill 45.92 42.47 40.96 39.88 36.17 
Zelda 46.35 43.47 41.85 40.67 37.54 
Average 46.30 43.42 41.72 40.48 37.38 
 
TABLE 3 (CONT.) 
EC AND PSNR OF STEGO-IMAGES FOR THREE SECRET IMAGES 
EMBEDDING (UNIT: dB) 
Cover Image 
EC (bits/%) 
11/45.
8 12/50.0 13/54.2 14/58.3 15/62.5
Baboon 36.04 34.78 31.75 30.02 28.75 
Barbara 35.73 34.56 31.29 29.64 28.45 
Boat 35.22 34.18 30.90 29.26 28.16 
Goldhill 35.52 34.37 30.90 29.25 28.11 
Jet 36.05 34.82 31.81 30.03 28.83 
Lena 36.05 34.76 31.77 30.02 28.75 
Peppers 35.46 34.35 31.15 29.44 28.36 
Sailboat 36.00 34.78 31.75 30.01 28.76 
Tiffany 35.59 32.66 30.58 28.84 26.83 
Vegetables 35.65 34.35 31.03 29.40 28.17 
Windmill 34.58 33.60 29.73 27.58 26.53 
Zelda 35.88 34.67 31.34 29.71 28.54 
Average 35.65 34.32 31.17 29.43 28.19 
B. Security Analysis 
The proposed multi-bit A3S algorithms have two excellent 
features to avoid security analysis attacks; one is its minimum 
embedding error feature makes the embedded cover pixels 
similar to the original cover pixels.  The other one is our 
embedding scheme utilized Torus automorphisms. The former 
exerts the LSBs of cover pixel on small change when secret 
data be embedded into high bit location. The later is suitable for 
k-LSB embedding; Torus automorphisms camouflages secret 
T-IFS-02264-2011 
 
11
[4] C.-K. Chan and L.M. Cheng, “Hiding data in images by simple LSB 
substitution,” Pattern Recognition, vol. 37, pp. 469-474, 2004 
[5] C.-K. Chan and L.M. Cheng, “Improved hiding data in images by optimal 
moderately significant-bit replacement,” IEE Electronics Letters, vol. 37, 
pp. 1017-1018, 2001. 
[6] M.H. Lin, Y.C. Hu, C.C. Chang, “Both color and gray scale secret images 
hiding in a color image,” International Journal of Pattern Recognition 
and Artificial Intelligence, vol. 16, no.6, pp. 697–713, 2002. 
[7] C. F. Lee and H. L. Chen, “A Novel Data Hiding Scheme Based on 
Modulus Function,” Journal of Systems and Software, vol. 83, no. 5, pp. 
832-843, 2010. 
[8] Xinpeng Zhang and Shuozhong Wang. “Efficient Steganographic 
Embedding by Exploiting Modification Direction”, IEEE 
Communications Letters, vol. 10, no. 11, pp. 781 – 783, November. 2006. 
[9] C. F. Lee, Y. R. Wang, and C. C. Chang, “A Steganographic Method with 
High Embedding Capacity by Improving Exploiting Modification 
Direction,” Proceddings of the Third International Conference on 
International Information Hiding and Multimedia Signal Processing 
(IIH-MSP 2007). Vol. 01, pp.497 – 500, Kaohsiung, Taiwan, 26-28 Nov. 
2007. 
[10] W. C. Kuo, J. C. Cheng, and C. C. Wang, “More Efficient Steganoraphic 
Embedding and Capacity-Improvement by Generalized Exploiting 
Modification Direction Method,” Procedding of the 2009 Fourth 
International Conference on Innovative Computing, Information and 
Control (ICICIC), pp.1168 – 1171, Kaohsiung, Taiwan, 7-9 Dec. 2009. 
[11] H. M. Sun, C.Y. Weng, C.F. Lee, and C.H. Yang, “Anti-Forensics with 
Steganographic Data Embedding in Digital Images,” IEEE JOURNAL ON 
SELECTED AREAS IN COMMUNICATIONS, Vol. 29, No. 7, pp. 
1392-1403, Aug. 2011. 
[12] Steganography: A Few Tools to Discover Hidden 
Data, http://www.guillermito2.net/stegano/tools/index.html,  accessible 
by Nov.06 2011. 
[13] Y. C. Peng, “Hardware implementation of watermarking using minimum 
error embedding algorithms,” Master Thesis, National United University, 
Taiwan, June 2010. 
 
Rong-Jian Chen (M’02–SM’04) received the B.S., M.S., and Ph.D. degrees in 
electronic engineering from the National Taiwan University of Science and 
Technology, Taipei, Taiwan, in 1987, 1991, and 1995, respectively. He joined 
the faculty of the National Lien-Ho Institute of Technology in August 1995, 
where he was the Chair of the Department of Electronic Engineering during the 
1999–2001 academic years. At present, he is Associate Professor of the 
Department of Electronic Engineering, National United University. He is a 
member of Nano-electronics and Giga-scale System Technical Committee, 
IEEE CAS Society. He serves as Co-Editor of Globalization Leadership 
Column at IEEE Circuits and Devices Magazine (per invitation from EIC Dr. 
Ron Waynant) during the 2004-2006, and serves on the Editorial Board of IEEE 
Circuits and Systems Magazine (per invitation from EIC Prof. Maciej 
Ogorzalek) during the 2004-2007. He also serves as Associate Editor of IEEE 
Trans. on Circuits and Systems: Part I during the 2006- 2007. His research 
interests include digital image/video processing, neural networks, and VLSI 
design of multimedia system. 
 
Shi-Jinn Horng was born in 1957, Taiwan. He received the BS degree in 
Electronics Engineering from National Taiwan Institute of Technology, Taipei, 
the MS degree in Information Engineering from National Central University, 
Taiwan, and the PhD degree in Computer Science from National Tsing Hua 
University, Taiwan, in 1980, 1984, and 1989, respectively. He was a Professor 
and Dean of the College of Electrical Engineering and Computer Science, 
National United University, Miaoli, Taiwan. Currently, he is a Professor at the 
Department of Computer Science and Information Engineering, National 
Taiwan University of Science and Technology. Dr. Horng has published more 
than 170 research papers and received many awards; especially, the 
Distinguished Research Award between 2004 and 2006 from the National 
Science Council in Taiwan; Outstanding I. T. Elite Award, in 2005; 
Outstanding EE. Prof. Award, the Chinese Institute of Electrical Engineering; 
Outstanding Research and Invention Award between 2006 and 2008 from 
National Taiwan University of Science and Technology. 
( )tji 1,a + . Then the rule of 2-D von Neumann CA 
evolution way can be expressed as 
( ) ( ) ( )(
( ) ( ) ( ) )ttt
ttt
jiajiajia
jiajiaFjia
,1,1,,,.
,1,,,1, 1
−+
−+=+ ,         (1) 
where F is a Boolean function that defines the rule. 
 
  
Figure 1. 2-D von Neumann CA, (a) 2-D von 
Neumann CA space, (b) the structure of 1-bit PACA 
 
The hardware implementation of Eq. (1) for 1-bit 
2-D von Neumann CA is shown in Figure 1b. Such a 
structure is referred as a programmable additive CA 
(PACA) due to it is implemented using EXOR gates. 
Using the 1-bit 2-D von Neumann PACA structure, one 
can build the desired hybrid NN × -bit cellular 
automata [8]. It costs NNN 46 22 ++  bits to assign 
boundary condition, rule control, and initial data to 
indicate the 2-D hybrid NN ×  von Neumann CA 
generator to produce CA data sequence. Given a 2-D 
NN × -cell dual-state von Neumann CA runs over T 
time steps, it has 62  rules, NN ×2  initial 
configurations, N42  boundary conditions, and results 
in NNN 46
22
2 ++  CA evolution ways for generating 
NT ×  N-bit generalized CA data. Consequently, 
cyclic boundary conditions were imposed on a 
2-state/3-site/ NN × -cells CA to generate the states of 
the automata. 
 
3. Image security system using the 
proposed stream cipher 
 
Let ( ) 10, 1 −≤≤ LiiF  be a sequence of N-bit input 
data, ( ) 10 1 −≤≤ Li,iE  be a sequence of N-bit output 
encrypted data, ( ) 10, 1 −≤≤ LiiD  be a sequence of 
N-bit output encrypted data, and ( ) 10, 1 −≤≤ LiiCAp  
be a sequence of N-bit CA data. We firstly defined 
variable ordered generalized CA transforms (GCATs) 
as Table 1. There are 4 groups of 1st-ordered GCATs 
and 16 groups of 2nd-ordered GCATs which were 
labeled as GCAT1 and GCAT2 in Table 1, respectively. 
Among GCAT1 and GCAT2, 12,0 21 −≤≤
NLSLS  
are the values of level shift. Since we have 20 groups 
of GCAT1 and GCAT2, each group of GCAT1 consists 
of N2  1st-ordered GCATs and each group of GCAT2 
consists of N22  2nd-ordered GCATs, therefore 
(5+2N)-bit Type Selection data were used to specify the 
type of GCAT. 
 
 
Figure 2. Architecture of the variable ordered 
recursive CA encrypted/decrypted substitutions 
 
 
Figure 3. Scheme of CA encryption/decryption 
 
Based on the definition of variable ordered GCATs, we 
firstly develop the architecture of the variable ordered 
recursive CA encrypted/decrypted substitution which is 
shown in Figure 2. In Figure 2, when 
encryption/decryption control bit is set to one and zero, 
it executes the recursive CA encryption and decryption 
substitution respectively. For example, the 
encryption/decryption control bit is set to one, it will 
cause that the switches SW1-1 and SW1-2 are in left 
position and system will perform variable ordered 
encryption according to the status of type selection. 
Type selection controller in Figure 4 used control bits 
T4T3T2T1T0 to achieve type selection, where T4 is used 
for 1st-ordered GCAT and 2nd-ordered GCAT selection, 
T3 is ( )iCAp  and ( )1−iCAp  selecting bit, T2 is 
EXOR and NEXOR selecting bit, T1 is the control bit 
75
Authorized licensed use limited to: National United University. Downloaded on January 30, 2009 at 11:04 from IEEE Xplore.  Restrictions apply.
CA encryption/decryption scheme is lossless, the 
sequence of N-bit decrypted data ( ) 10, 1 −≤≤ LiiD  is 
identical to the original sequence ( ) 10, 1 −≤≤ LiiF .To 
achieve the goal of data security, we further develop 
the scheme of CA encryption/decryption (stream cipher 
system) as Figure 3, where the CA generating scheme 
shown in dash-line block is controlled by CA key to 
generate N-bit CA data sequence ( ) 10, 1 −≤≤ LiiCAp  
for CA substitution. For CA encryption, the 
encryption/decryption control bit is set as 1; 
simultaneously, the input is a sequence of N-bit data 
and the output of recursive CA-encrypted substitution 
is a sequence of N-bit encrypted data. 
The proposed recursive CA encrypted substitution 
satisfies both confusion and diffusion properties. The 
confusion and diffusion properties are achieved by 
transforming the sequence ( ) 10, 1 −≤≤ LiiF  into the 
sequence ( ) 10, 1 −≤≤ LiiE  according to Eqs. (2) and 
(3). The sequence ( ) 10, 1 −≤≤ LiiE  yields uniformly 
distributed pixels because the high-quality random 
key-stream ( ) 10, 1 −≤≤ LiiCAp  and/or 
( ) 10,1 1 −≤≤− LiiCAp  are used in the transformation. 
The sequence ( ) 10, 1 −≤≤ LiiE  has the diffusion 
property because a single change in value ( )iF  
changes ( )iE  which changes ( )1+iE  which changes 
( )2+iE  and changes propagate up to the end of the 
sequence. 
 
 
Figure 4. Proposed stream cipher system 
 
Image security system using the proposed stream 
cipher system is shown in Figure 4. The security keys 
for encryption and decryption consist of three 
components, namely, data reformation key, type 
selection key and CA key. These keys are identical and 
are known to both the sender and the receiver before 
the communication of encrypted image. The data 
reformation key has 2 bits that are used for 
reformatting the data type of the input sequence as 
4-bit ( 200 ), 8-bit ( 201 ), 16-bit ( 211 ), or 32-bit ( 210 ). 
Type selection key consists of (5+2N) bits are used for 
selecting the type of GCATs to perform recursive CA 
encryption/decryption substitution. Whereas, the CA 
key is used for deciding CA rule number, initial data, 
boundary conditions, and linear permutation to 
generate a sequence of CA data for recursive CA 
substitution. 
In the sender site, once it had decided data 
reformation key, type selection key, CA key, and an 
input data. The encryption will be done as follows. 
Firstly, the data reformation rearrange the input data as 
N-bit data blocks and then CA encryption replace the 
rearranged N-bit data values to produce a sequence of 
N-bit encrypted data ( ) 10, 1 −≤≤ LiiE . The receiver 
site performs inverse operation of the sender site. 
Suppose receiver has received data reformation key, 
type selection key, CA key, and a sequence of N-bit 
encrypted data. The decryption will be done as follows. 
Firstly, the recursive CA decrypted substitution 
performs CA decryption to generate the sequence of 
N-bit decrypted data ( ) 10, 1 −≤≤ LiiD . Then inverse 
data reformation was done to produce the decrypted 
data with the original data type. 
The proposed stream cipher system is an extended 
and improved version of that presented in [9] because 
the proposed one used 20 groups of variable ordered 
CA-based recursive substitution to make the exhaustive 
searching attack much harder and to enhance the 
performances of system. 
 
4. Possible secret keys and cryptanalysis 
 
A 2-D hybrid NN × -cell dual-state von Neumann 
hybrid CA that runs over T time steps produces 
( )!NTNNN ××++ 46 222  possible groups of NT ×  
N-bit CA data. However, for efficient computer 
simulation, a special CA rule generator with (6+n)-bit 
rule control data is used to specify specific CA rule 
numbers, where Nlogn 2= . Furthermore, since 
NT ×  N-bit generalized CA data have ( )!NT ×  
possible permutations, it could be a very large number. 
Therefore, the linear permutation with Wn  = 
( )NTlog ×2  = Tlog 2  + Nlog 2  = Tn  + Nn  bits 
is compact in representing and generating a specific set 
of permutations. In summary, in the computer 
simulation, WnNNn ++++ 46
2
2  possible groups of NT ×  
N-bit generalized CA data were used. Notably, the 
proposed system specifies four data types and N252 +  
GCAT types. The basic idea of the proposed stream 
cipher system is that it uses a specified secret key to 
generate a key-stream and use it to encrypt a plaintext 
string according to Eqs. 2 and 3. We hence choice the 
length of key-stream at least equals to the length of 
77
Authorized licensed use limited to: National United University. Downloaded on January 30, 2009 at 11:04 from IEEE Xplore.  Restrictions apply.
fact of very long cycle length of the 2-D NN × -cell 
von Neumann CA consequently prevents cryptanalyst 
to reveal CA key from the recovered part of CA 
key-stream. 
 
5. Simulation results 
 
The proposed stream cipher system performed well 
encryption not only the general text data but also 
compressed images and uncompressed images. Several 
simulations were conducted to test various properties 
of the proposed data security system that include 
confusion and diffusion properties. In our simulations, 
the data reformation key is 201  which means that the 
data type for encryption and decryption is 8-bit. The 
CA key is selected that chooses 166C uniform initial 
states, zero boundaries with cyclic boundary at lower right 
corner, and rule control with 38486 2 =×  bits to produce 
2-D hybrid 88×  von Neumann CA as Figure 5. Once the 
2-D hybrid 88×  von Neumann CA has been built that run 
over 8192 time steps to generate CA data sequence of 
size 65536. Then 8-bit permutation control bits 1600  
in CA key guides the system to do linear permutation 
from the first 8-bit of the CA data sequence to generate 
the ( ) 10,1 1 −≤≤− LiiCAp . We used 1st-ordered 
GCAT with 1281 =LS , and 2
nd-ordered GCAT with 
1281 =LS  and 1282 =LS  to perform the recursive 
CA encryption and decryption substitutions. 
 
 
Figure 5. 2-D hybrid 88×  von Neumann CA 
 
   
(a)                       (b) 
Figure 6. Test images, (a) Lena, (b) Lincoln Tower 
 
Note that in all the following experiments, images 
are used for simulation and all images are of 
size 256256 × . Figures 6a and 6b show YUV formatted 
color Lena and Lincoln Tower images that were used 
for testing the performance of the proposed data 
security system. Encrypted images of Lena and Lincoln 
Tower are shown in Figure 7. Histograms of the 
encrypted Lena and the encrypted Lincoln Tower in 
Figure 8 show that the encrypted images get uniformly 
distributed pixels. This fact illustrates that the proposed 
data security system satisfies the confusion property. 
Encrypted images perform the process of decryption 
will produce the decrypted images. The decrypted 
images are exactly identical to the original images. This 
fact shows that the proposed system works well as our 
expectation. 
In order to determine the diffusion property of the 
proposed system with respect to images, Lena image 
was modified by incrementing the value of one 
randomly chosen pixel by 1. The Y-value of pixel (0, 0) 
was incremented from 161 to 162. Both the original 
Lena and the modified Lena were encrypted using the 
same secret keys. The pixel-wise absolute difference of 
two encrypted images is displayed in Figure 9, which 
shows that the two encrypted images have no 
similarities even though their original images differ by 
only one pixel. Thus, it proves the diffusion property of 
the proposed system with respect to images. 
 
   
(a) (b) 
   
(c)                      (d) 
Figure 7. Encrypted images, (a)1st-ordered Lena, (b) 
2nd-ordered Lena, (c). 1st-ordered Lincoln Tower, (d) 
2nd-ordered Lincoln Tower 
 
The performance of the proposed stream cipher 
system is now compared using [9] and DCPcrypt [12] 
with that of three published algorithms - RC4, 
Triple-DES and AES (Rijndael). DCPcrypt is 
79
Authorized licensed use limited to: National United University. Downloaded on January 30, 2009 at 11:04 from IEEE Xplore.  Restrictions apply.
Table 2. Summary of comparisons 
Item DCPcrypt 
algorithm 
Proposed system 
(Enhanced version of [9])
System of [9] with one 
iteration ( NN × ) RC4 Triple-DES AES 
Classification Stream cipher Stream cipher Stream cipher Block cipher Block cipher
Key length (bits) lengtha lengthb 256 192 256 
Complexity of cryptanalysis WnNNn ++++≈
26132  WnNNn ++++≈
24112  6302 .  [15] 1122  [16] 2242  [17]
Possible GCAT type selection N252 +  6 — — — 
CPU encryption timec (msec/3 
Mbytes) 1631±  1631±  870 ±  16609 ±  8180 ±  
CPU decryption timec (msec/3 
Mbytes) 1631±  1631±  870 ±  16609 ±  8180 ±  
Entropy of ciphertext (bits) 7.9999 7.9999 7.9999 7.9999 7.9999 
a. lengtha = 2 bits (Data reformation key) + (5+2N) bits (Type selection key) + ( )WnNNn ++++ 46 2  bits (CA key). 
b. Lengthb = 2 bits (Data reformation key) + 3 bits (Type selection key) + ( )WnNNn ++++ 46 2  bits (CA key). 
c. CPU encryption/decryption time is the CPU processing time for encrypting/decrypting 3 Mb of plaintext/ciphertext 
excluding the time required for hard disk storage. 
 
8. References 
 
[1] N. Bourbakis, C. Alexopoulos, “Picture data encryption 
using SCAN patterns,” Pattern Recognition, vol. 25, 
no. 6, pp. 567-581, 1992. 
[2] J. Scharinger, “Fast encryption of image data using 
chaotic Kolmogorov flows,” Electronic Imaging, vol. 
17, no. 2, pp. 318-325, 1998. 
[3] L. Chang, “Large encrypting of binary images with 
higher security’” Pattern Recognition Letter, vol. 19, 
no. 5, pp. 461-468, 1998. 
[4] T. Chuang and J. Lin, “ New approach to image 
encryption,” Electronic Imaging, no. 4, pp. 350356, 
1998. 
[5] Olu Lafe, “Data compression and encryption using 
Cellular Automata transform,” Eng. Applic. Artif. 
Intell., vol. 10, no. 6, pp. 581-591, 1998. 
[6] K Sasidhar, S. Chattopadhyay, and P. Pal Chaudhuri, 
“CA decoder for cellular automata based error 
correcting code,” IEEE Trans. On Computers, vol. 45, 
pp. 1003-1016, 1996. 
[7] P. Hortensius, R. McLeod, W. Pries, M. Miller, and H. 
Card, “Cellular Automata-based pseudorandom number 
generators for built-in self-test,” IEEE Trans. On 
Computers Aided Design, vol. 8, pp. 842-859, 1989. 
[8] R. J. Chen, Y. T. Lai and J. L. Lai, “Architecture 
Design and VLSI Hardware Implementation of Image 
Encryption/Decryption System Using Re-configurable 
2-D Von Neumann Cellular Automata,” in Proceedings 
of IEEE ISCAS 2006, pp. 153-156, Kos Island, Greece, 
May 21-24, 2005. 
[9] R. J. Chen and J. L. Lai, “Image security system using 
recursive cellular automata substitution,” Pattern 
Recognition, vol. 40, no. 5, pp. 1621-1631, 2007. 
[10] M. Tomassini, M. Sipper, and M. Perrenoud, “On the 
generation of high-quality random numbers by 
two-dimensional cellular automata,” IEEE Trans. on 
Computers, vol. 49, no. 10, pp 1146-1151, 2000. 
[11] C. S. Chen, “Integration and implementation of image 
encryption/decryption system using SCAN and 2-D 
von Neumann cellular automata,” Master Thesis, 
National United University, 2007. 
[12] D. Barton, “DCPcrypt Cryptographic Component 
Library v2 Beta 3,” 
www.cityinthesky.co.uk/cryptography.html, 1999. 
[13] B. Schneier, Applied Cryptography, Wiley, New York, 
1996. 
[14] S. Landau, “Standing the test of time: the data 
encryption standard,” Notices of American 
Mathematical Society, pp. 341-349, March 2000. 
[15] S. R. Fluhrer and D. A. McGrew, “Statistical analysis 
of the Alleged RC4 keystream Generator,” Lecture 
Notes in Computer Science, vol. 2259, pp. 1-24, 
Springer-Verlag, 2001. 
[16] S. Lucks, “Attacking triple Encryption,” Lecture Notes 
in Computer Science, vol. 1372, pp. 239-253, 
Springer-Verlag, 1988. 
[17] N. Ferguson, J. Kelsey, S. Lucks, B. Schneier, M. Stay, 
D. Wagner, and D. Whiting, “Improved cryptanalysis 
of Rijndael,” Lecture Notes in Computer Science, vol. 
1978, pp. 213-230, Springer-Verlag, 2000. 
81
Authorized licensed use limited to: National United University. Downloaded on January 30, 2009 at 11:04 from IEEE Xplore.  Restrictions apply.
conclusions. 
 
2. Overview of AES algorithm 
 
AES is a symmetric block cipher having variable key 
and fixed data length. The key lengths can be 
independently chosen as 128, 192 or 256 bits, which 
result in 10, 12 and 14 rounds of operation respectively. 
The data length is however fixed to 128 bits. The input 
as well as intermediate data can be considered as a 
matrix with four rows and four columns called state. 
Each element of the matrix is composed of eight bits, 
therefore enabling efficient implementation of AES on 
8-bit platforms. 
 
Fig. 1 Rijndael algorithm 
 
Fig. 1 shows the detailed Rijndael algorithm. From 
Fig. 1 we know that the AES algorithm has four basic 
transformations: SubBytes, ShiftRows, MixColumns 
and AddRoundKey. The encryption flow starts with the 
addition of the initial key to the plaintext. Then the 
iteration continues for (Nr-1) rounds (Nr being the total 
number of rounds). In last round the MixColumn step 
is bypassed. 
In the straightforward decipher presented in Fig. 2, 
the sequence of the transformations differs from that of 
the cipher, while the form of the key schedules for 
encryption and decryption remains the same. However, 
several properties of the AES algorithm [2] allow for 
an equivalent decipher that has the same sequence of 
transformations as the cipher (with the transformations 
replaced by their inverses). This is accomplished with a 
change in the key schedule. The equivalent decipher is 
defined by reversing the order of the InvSubBytes and 
InvShiftRows transformations shown in Fig. 2, and by 
reversing the order of the AddRoundKey and 
InvMixColumns transformations used in the round loop 
after first modifying the decryption key schedule for 
round = 1 to Nr-1 using the InvMixColumns 
transformation. The first and last Nb words of the 
decryption key schedule shall not be modified in this 
manner. 
 
Fig. 2 Equivalent decipher of Rijndael algorithm 
 
3. Hardware solution of high efficient and 
non-memory AES 
 
AES algorithm is quite complex and resource 
consuming, at the same time WPAN requires a 
low-cost, low-power, low-complexity design. If AES is 
accomplished without optimization, it might cost a 
large extra amount of area, it should difficult to accept 
by WPAN compatible transceiver chip. To achieve the 
required security level without sacrificing too much 
resource, many different kinds of resource saving 
methods are investigated. To achieve this, an important 
issue is to integrate cipher and decipher together and it 
could function between encryption and decryption 
mode. Other resource sharing and resource re-using 
methods are also applied. Finally, the hardware 
architecture of AES system is proposed. After a full 
investigation to Figs. 1 and 2, we found that resource 
sharing between encryption and decryption is possible. 
Resource sharing is achieved by combined 
transformations and inverse transformations within 
rounds. After that, other resource re-using and power 
saving methods are also applied to the AES crypto core. 
At last, low-cost and high-efficient hardware 
implementation architecture is given. In this section, 
we introduce two methods to reduce the hardware 
overhead. One is the efficient implementation of S-box, 
and the other is the resource sharing scheme. Moreover, 
the key expansion function is implemented on the fly to 
replace the RAM-based key expansion to aim at 
low-cost AES design. 
37
copies of 4-byte MixColums and InvMixColumns 
transformations. 
 
3.3 Efficient 3-in-1 key expansion 
The key expansion described in AES standard 
includes two components. One is the key scheduler and 
the other is round key selection. Key scheduler 
performs XOR, SubWord and Rcon operations. Round 
keys can either be generated off-line and stored in 
memory, or be generated on the fly. The former case is 
suitable for applications which do not change keys 
constantly and can afford large area for memory. 
During encryption/decryption, round keys can be read 
out from memory, and no extra delay is induced for 
decryption. In this case, reducing the critical path of 
key scheduler can degrade the overhead of hardware 
complexity; however, it does not speed up the whole 
system. The applications in which the key needs to be 
changed frequently, it is preferred to expand keys on 
the fly. From key expansion algorithm, we can easily 
observe that the critical path of key expansion is 
composed of one multiplexer, one S-box, and one XOR 
gate. Since the critical path of key expansion is shorter 
than that of a round unit, reducing the critical path of 
key expansion will not increase the speed of the whole 
system. Generating round keys on the fly eliminate the 
requirement for key storage, but pays penalty at 
hardware overhead, since the decryption can only begin 
after the last round key is ready. In the applications 
with limited area, generating round key on the fly is a 
better choice. In [19] an efficient architecture, which 
can generate round key Ki+1, on the fly from round key 
Ki is proposed and vice versa, iteratively. As a result, in 
our AES design, we implemented the key expansion 
function in the same way. In the followings, we 
describe the key scheduling for different key length to 
help readers understanding. 
Let word size of round key Ki at round i can be 
denoted as ( )110 −+++= kkkk NiNiNiNi WWWK L , then the 
elementary key scheduler ( ) liNkW ++1 , ( )10 −≤≤ kNl  
of the next round key Ki+1 can be expressed as: 
Encryption: 
( ) ( )( )111 −+++++ = liNliNliN kkk W,WonKeyOperatiW ,       (3) 
Decryption: 
( ) ( )( )liNliNliN kkk W,WonKeyOperatiW ++−+++ = 111 .       (4) 
 
Where kN  is number of 32-bit words composing the 
cipher keys, kN =4, kN =6, and  kN = 8 for 128-bit, 
192-bit, and 256-bit cipher keys. Equations 3 and 4 
mean liNkW + and ( ) 11 −++ liNkW will generate ( ) liNkW ++1 for 
encryption; whereas, ( ) 11 −++ liNkW  and ( ) liNkW ++1 will 
generate liNkW + for decryption. In Eqs. (3) and (4), 
KeyOperation(x,y) can be performed by the elementary 
key scheduler (EKS). There are two types of EKSs 
named as T1 (dashed squares) and T2 (white squares), 
T1 executes four key operations: ( )( ) RconYRotWordSubWordXZ ⊕⊕=0 ,
( )YSubWordXZ ⊕=1 , YXZ ⊕=2 , and XZ =3 , 
and T2 only executes two key operations: YXZ ⊕=2 , 
and XZ =3 . Both of T1 and T2 are used MUXs to 
decide which key operation is applied. Architecture 
design of elementary key schedulers has been shown in 
Fig. 7. 
 
Fig. 7 Architecture design of elementary key 
schedulers, upper one is T1 and lower one is T2 
 
According to the AES algorithm specification, the 
length of the State in each round is 128. So, a 128-bit 
round key is needed as well and is decided from the 
expanded keys. As described in key expansion 
algorithm, for AES-128, the 128-bit cipher key will 
generate the 128-bit key K1=W4W5W6W7 in the next 
time. That is, the key scheduler will generate 4W  
using 0W  and 3W , will generate 5W  using 1W  and 
4W , and so on. The key scheduling of 192-bit cipher 
key for decryption is similar with that of 192-bit cipher 
key for encryption. However, the difference is the order 
of the generated keys. For decryption, 3W  and 4W  
will generate 0W ,  4W  and 5W  will generate 1W , 
and so on. It is clear that the decision of the round key 
in each round is simple, because the length of the 
39
Stratix II EP2S60F1024C4 device with Quartus II 5.0 
software. The maximum operation clock frequency can 
reach up to 150 MHz. The process data path width is 
128 bits. It takes about 400 ns and 770 ns to complete 
an AES-128 encryption/decryption on 100 MHz clock 
frequency. That is, the corresponding throughputs are 
320 Mbps and 166 Mbps. Table 2 shows that the 
integrated design of AES crypto core results in 
hardware of 16779 logic cells with 3-in-1 key 
scheduler included and the total power dissipation is 
804.3 mW. 
Table 2 Implementation results of AES-128 core 
(Inv)SubBytes (gates) 1,478
(Inv)ShiftRows (gates) 68
(Inv)MixColumns (gates) 356
AddRoundKey (gates) 103
Key Expansion (gates) 4,080
Total (gates) 16,779
Total Power Dissipation (mW) 804.3
Throughput (Mbps) 320/166
 
5. Discussions and conclusions 
 
  In this paper, we present methods to develop a high 
efficient and non-memory AES crypto core to fit 
WPAN security requirement. The proposed basis 
transformation approach from Galois Field (28) to 
Galois Field GF(((22)2)2) can significantly reduce the 
hardware complexity of the SubBytes transformation 
(S-box). Besides, the on-the-fly key expansion function 
is used to replace the RAM-based, and the new 
on-the-fly key scheduler fully supports AES-128, 
AES-192 and AES-256. Moreover, MixColumns/ 
InvMixColumns resource-sharing scheme will also be 
employed to reduce the hardware complexity of the 
cipher and decipher. The resulting hardware-efficient 
FPGA implementation of the AES algorithm shows 
that it can serve as the crypto engine for modern 
cryptographic systems and it is suitable for integration 
into the WPAN system chips due to its acceptable 
power dissipation. 
 
6. Acknowledgements 
 
The authors would like to thank anonymous reviewers for 
their valuable suggestions to improve this paper. The 
National Science Council of Republic of China under the 
contract NSC-97-2221-E-239-036-MY3 supported this work. 
 
7. References 
 
[1] National Institute of Standards and Technology 
(NIST), Data Encryption Standard (DES), National 
Technical Information Service, Springfield, VA 
22161, Oct. 1999. 
[2] National Institute of Standards and Technology 
(NIST), Advanced Encryption Standard (AES), 
National Technical Information Service, Springfield, 
VA 22161, Nov. 2001. 
[3] W. Stallings, Cryptography and Network Security: 
Principles and Practice. 3rd ed., Prentice-Hall Inc., 
Upper Saddle River, N.J., 2003. 
[4] J. Daemen, L. R. Knudsen, and V. Rijmen, “The 
block cipher square”, in Fast Software Encryption, E. 
Biham, Ed. 1997, vol. 1267 of LNCS, pp. 149–165, 
Springer-Verlag. 
[5] B. Song and J. Seberry, “Further observations on the 
structure of the AES algorithm”, in Fast Software 
Encryption (FSE) 2003. 2003, vol. 2887 of LNCS, pp. 
223–234, Springer-Verlag. 
[6] N. Ferguson, R. Schroeppel, and D. Whiting, “A 
simple algebraic representation of rijndael”, in 
Selected Areas in Cryptography (SAC) 2003. 2003, 
vol. 2259 of LNCS, pp. 103–111, Springer-Verlag. 
[7] J. Daemen and V. Rijmen, AES Proposal: Rijndael, 
AES algorithm submission, Sept. 1999. 
(http://www.nist.gov/CryptoToolkit) 
[8] Draft FIPS for the AES, Feb. 2001. 
(http://csrc.nist.gov/encryption.aes) 
[9] M. Jing, Z. Chen, J. Chen, and Y. Chen 
Reconfigurable System for High-Speed and 
Diversified AES using FPGA, Microprocessors and 
Microsystems, in Press, Uncorrected Proof, Mar. 
2006. 
[10] S. Yoo, D. Kotturi, D. Pan, and J. Blizzard “An AES 
crypto chip using a high-speed parallel pipelined 
architecture,” Microprocessors and Microsystems, 
vol. 29, no. 7, pp. 317-326, Sep. 2005. 
[11] Verbauwhede, P. Schaumont, and H. Kuo, "Design 
and performance testing of a 2.29 Gb/s Rijndael 
Processor", IEEE Jour of Solid-State Circuits, pp. 
569-572, 2003. 
[12] A. Hodjat, P. Schaumont, and I. Verbauwhede, 
"Architectural design feature of a programmable high 
throughput aes copressor", in Proc. IEEE Coding and 
Computing, Oct. 2004. 
[13] C.-P. Su, T. -F. Lin, C. -T. Huang, and C.-W. Wu, 
"A high-throughput lowcost AES processor", IEEE 
Communications Magazine, vol. 41, no. 12, pp. 
86-91, Dec. 2003. 
[14] A. Satoh, S. Morioka, K. Takano, and S. Munetoh, 
"A compact Rijndael hardware architecture with 
S-box optimization", in ASIACRYPT 2001. 2001, 
vol. 2248 of LNCS, pp. 239-254, Springer-Verlag. 
[15] C.-L. Homg, "An AES cipher chip design using 
on-the-fly key scheduler", Master Thesis, Dept. 
Electrical Engineering, National Tsing Hua 
University, Hsinchu, Taiwan, June 2004. 
[16] X. Zhang and K. Parhi, "High-speed VLSI 
architecture for the AES algorithm", IEEE Trans. on 
VLSI Systems, vol. 12, no. 9, pp. 957-967, 2004. 
[17] Y-K. Lai, L.-C. Chang, L.-F. Chen, C.-C. Chou, and 
C.-W. Chiu, "A novel memoryless AES cipher 
architecture for networking applications", in Proc. 
IEEE Circuit and Systems Symp, May 2004. 
41
 
Fig. 6 Circuit of 1-byte MixColumns and InvMixColumns 
 
Fig. 8 Efficient 3-in-1 key scheduler 
43
respectively. Besides that, the embedding data be denote as 
EBs All conditions that will be used in the multi-bit bitwise 
adaptive 3-step embedding algorithms are listed in the 
followings. For embedding EBs 12 −< k  into 11 +−− kiii bbb  , 
we have condition 1 (SC01): 11 +−− kiii bbb  = EBs, 
condition 2 (SC02): any bit of IMSBs is 0, condition 3 
(SC03): 11 +−− kiii bbb  < EBs, condition 4 (SC04): 
11 +−− kiii bbb   < EBs + 2
k-1, condition 5 (SC05):  
11 +−− kiii bbb  = EBs + 2
k-1, and condition 6 (SC06): kib − = 0. 
Whereas, for embedding EBs 12 −≥ k   into 11 +−− kiii bbb  , 
we have condition 1 (LC01): 11 +−− kiii bbb  = EBs, 
condition 2 (LC02): any bit of IMSBs is 1, condition 3 
(LC03): 11 +−− kiii bbb  > EBs, condition 4 (LC04): 
11 +−− kiii bbb   > EBs - 2
k-1, condition 5 (LC05):  
11 +−− kiii bbb  = EBs - 2
k-1, and condition 6 (LC06): kib − = 
1.The corresponding multi-bit bitwise adaptive 3-step 
embedding algorithms are listed in the followings. 
  For EBs 12 −< k  be embedded into 11 +−− kiii bbb   
1. If SC01 is true, then OMSBs = IMSBs, OLSBs 
= ILSBs, and go to step 9. 
2. If SC01 is false, then set 11 +−− kiii bbb  = EBs. 
3. If SC02 and SC03 are true, then OMSBs = 
IMSBs, OLSBs = 0s, and go to step 9. 
4. If SC02 is true, SC03 is false, and SC04 is true, 
then OMSBs = IMSBs, OLSBs = 1s, and go to 
step 9. 
5. If SC02 is true, SC03 and SC04 are false, SC05 
and SC06 are true, then OMSBs = IMSBs, 
OLSBs = 1s, and go to step 9. 
6. If SC02 is true, SC03 and SC04 are false, and 
any one of SC05 and SC06 is false, then 
OMSBs = IMSBs + 1, OLSBs = 0s, and go to 
step 9. 
7. If SC02 is false and SC03 is true, then OMSBs 
= IMSBs, OLSBs  = 0s, and go to step 9. 
8. If SC02 is false and SC03 is false, then OMSBs 
= IMSBs, OLSBs  = 1s, and go to step 9. 
9. Stop. 
 For EBs 12 −≥ k  be embedded into 11 +−− kiii bbb   
1. If LC01 is true, then OMSBs = IMSBs, OLSBs 
= ILSBs, and go to step 9. 
2. If LC01 is false, then set 11 +−− kiii bbb  = EBs. 
3. If LC02 and LC03 are true, then OMSBs = 
IMSBs, OLSBs = 1s, and go to step 9. 
4. If LC02 is true, LC03 is false, and LC04 is true, 
then OMSBs = IMSBs, OLSBs = 0s, and go to 
step 9. 
5. If LC02 is true, LC03 and LC04 are false, 
LC05 and LC06 are true, then OMSBs = 
IMSBs, OLSBs = 0s, and go to step 9. 
6. If LC02 is true, LC03 and LC04 are false, and 
any one of LC05 and LC06 is false, then 
OMSBs = IMSBs - 1, OLSBs = 1s, and go to 
step 9. 
7. If LC02 is false and LC03 is true, then OMSBs 
= IMSBs, OLSBs  = 1s, and go to step 9. 
8. If LC02 is false and LC03 is false, then OMSBs 
= IMSBs, OLSBs  = 0s, and go to step 9. 
9. Stop. 
 
(a) 
 
(b) 
Figure 1. k-bit bitwise MER algorithm for embedding k-bit 
data into 11 +−− kiii bbb  , (a) embedding the secret data
12 −< k  
, (b) embedding the secret data 12 −≥ k . 
Because the proposed multi-bit bitwise embedding 
algorithms are induced from 3-step procedure and 
adaptively adjust IMSBs and ILSBs according to the secret 
data and the cover data to achieve the embedded data with 
minimum BEE, we therefore called these as the adaptive 3-
step (A3S) embedding algorithms. Figure 1 shows the 
proposed A3S algorithms, where Figs. 1a and 1b are used 
for embedding k-bit secret data 12 −< k and k-bit secret 
data 12 −≥ k  into bits: 11 +−− kiii bbb  of cover data, 
respectively. In Figs. 1a and 1b, IMSBs and ILSBs mean 
MSBs and LSBs of cover data, respectively; meanwhile 
OMSBs and OLSBs mean MSBs and LSBs of embedded 
data, respectively. Reason that we called these algorithms 
are “bitwise MER” is that their data replacements are based 
on the logic and the algebraic bit operations to achieve 
- 1225 -
III. SIMULATION AND PEFORMANCE COMPARISONS 
Many simulations of watermarking and steganography were 
conducted to test the performances of the proposed multi-bit 
bitwise A3S embedding algorithms.  
A. Simulation Results for watermarking 
We perform watermarking in spatial and frequency 
domains. In spatial domain, the embedded scheme embeds 
the scattered logo image into Y channel of cover image. 
Whereas, the embedded scheme embeds the scattered logo 
image into DWT coefficients of Y channel of cover image 
in frequency domain. In the following watermarking 
experiments, the over image is true color and of size 256256 × . 
Note that the cover image should be transferred into YCrCb format 
before embedding. Figure 4 shows the test images, Figures 4a, 4b, 
and 4c are the cover image, 1-bit NUU logo image, and 3-bit NUU 
logo image, respectively. It is worth to mention that the logo 
images were scattered using Torus automorphism [4, 5] with k 
= 1 and n = 10 to increase its security. In the simulations of 
DWT watermarking, the cover images were decomposed as 
3-level wavelets, and the scattered logo image was 
embedded from 1st sub-band of the 3-level DWT wavelets. 
For convenience, we used notation ∏
−
=
−
1
0
k
m
mib_X to express 
k-bit logo data should be embedded into X channel of the 
cover data from bi bit plane. For examples, B_b0 means that 
1-bit logo data should be embedded into b0 bit plane of B 
channel of the cover data, Y_b3b2b1 means that 3-bit logo 
data should be embedded into b3b2b1 bit planes of B channel 
of the cover data. Figure 5 shows the embedded images 
which were embedded the scattered 1-bit NUU logo into 
different bit-plane. Meanwhile, Figure 6 shows the 
embedded images which were embedded the scattered 3-bit 
NUU color logo into different adjoining bit-plane. Figure 7 
shows the corresponding 1-bit and 3-bit NUU logo images 
which are detected from figures in Figs. 5 and 6.  
 
(a) 
    
 
(b)                                             (c) 
Figure 4. Test data for watermarking, (a) Cover image: 
Lena (true color), (b) 1-bit NUU logo (monochrome, 
128128) and its scattered version using Torus 
automorphism with k = 1 and n = 10, (c) 3-bit NUU logo (8 
colors, 128128) and its scattered version using Torus 
automorphism with k = 1 and n = 10. 
  
(a)                                           (b) 
  
(c)                                            (d) 
Figure 5. Watermarked Lena images which the scattered 1-
bit NUU logo image has been embedded, (a) for Y_b0 with 
PSNR 52.60 dB,  (b) or Y_b3 with PSNR 47.40 dB, (c) for 
DWT_b0 with PSNR 48.65 dB, (d) for DWT_b3 with PSNR 
34.31 dB. 
  
(a)                                           (b) 
  
(c)                                            (d) 
Figure 6. Watermarked Lena images which the scattered 3-
bit color NUU logo image has been embedded, (a) for Y_ 
b2b1b0 with PSNR 46.06 dB, (b) for Y_b3b2b1 with PSNR 
41.51 dB, (c) for DWT_b2b1b0 with PSNR 36.58 dB, (d) for 
DWT_b3b2b1 with PSNR 30.05 dB. 
To test the robustness of the proposed multi-bit bitwise 
A3S embedding algorithm, some typical signal processing 
attacks, such as noise adding, filtering, brightness/contrast 
adjusting, and rotation are performed in DWT domain. The 
experimental results of Lena image are shown in Figure 8. It 
can be seen that our algorithm suffers from rotation attacks. 
- 1227 -
of the proposed multi-bit bitwise A3S embedding algorithms 
are all higher than those of  [1, 3]. 
TABLE I.  COMPARISONS OF WATERMARKING FOR 4-BIT EMBEDDING 
 [1]: PSNR (dB) Proposed: PSNR (dB) 
lena 
31.71 
34.86 
Peppers 34.78 
TABLE II.  COMPARISONS OF STEGANOGRAPHY FOR R3G2B3 HIDING 
 [3]: PSNR (dB) Proposed: PSNR (dB) 
Baboon 41.872 41.923 
Peppers 41.873 41.922 
 
IV. DISCUSSIONS AND CONCLUSIONS 
This paper presents an novel multi-bit bitwise A3S 
embedding algorithms for data hiding. These multi-bit 
bitwise A3S embedding algorithms can embed k-bit ( 1≥k ) 
secret data into cover data only introduce minimum 
embedding error smaller than ( ) kik −− − 212 1 according to the 
embedding location i. Many simulations show that the 
proposed multi-bit bitwise A3S embedding algorithms 
perform good embedding quality for watermarking and 
steganography applications. 
Reasons that we develop the proposed multi-bit bitwise 
A3S embedding algorithms are (1) to overcome the 
drawbacks that exist in the previous works and (2) to reduce 
the computation complexity that exists in the previous 
works for easy hardware implementation. Hardware 
implementation of the proposed multi-bit bitwise A3S 
embedding algorithms is our current work. 
REFERENCES 
[1] Y. K. Lee and L. H. Chen, “High capacity image steganographic 
model,” IEE Proc.-Vis. Image Signal Process., vol. 147, no. 3, June 
2000, pp. 1–15. 
[2] T. S. Chen, J. Chen, and J. G. Chen, “A simple and efficient 
watermarking technique based on JPEG2000 codec,” Proceddings of 
the IEEE ISMSE’03, 10-12 Dec., 2003, pp. 80-87. 
[3] Y. H. Yu, C. C. Chang, and I. C. Lin, “A new steganographic 
method for color and grayscale imahe hiding,” Computer Vision and 
Image Understanding,vol. 107, no. 3, September 2007, pp. 183-194. 
[4] P.W. Wong, N. Memon, “Secret andpublic key authentication 
schemes that resist vector quantization attack,” Proc. SPIE 3971(75), 
2002, pp. 417–427. 
[5] G. Voyatzis, I. Pitas, “Applications of toral automorphisms in image 
watermarking,” Proceedings of the International Conference on 
Image Processing, vol. II, 1996, pp. 237–240. 
- 1229 -
smaller than traditional 



1
0
122
k
l
lki  for all k. Embedding 
error is called as bipolar embedding error (BEE) because it 
has “+” and “-” polarities.  The procedure of embedding 
multi-bit data into 11  kiii bbb   of cover data also can be 
divided into three steps: (1) embed secret data into 
11  kiii bbb   of cover data, (2) adaptively adjust ILSBs, 
and (3) adaptively adjust IMSBs. It is helpful to summarize 
all conditions that we used to develop the multi-bit bitwise 
adaptive 3-step embedding algorithms. All conditions that 
will be used in the multi-bit bitwise adaptive 3-step 
embedding algorithms are listed in the followings. For 
embedding EBs 12 
 k  into 11  kiii bbb  , we have 
condition 1 (SC01): 11  kiii bbb  = EBs, condition 2
(SC02): any bit of IMSBs is 0, condition 3 (SC03): 
11  kiii bbb  < EBs, condition 4 (SC04): 11  kiii bbb   < 
EBs + 2k-1, condition 5 (SC05):  11  kiii bbb  = EBs + 2
k-1,
and condition 6 (SC06): kib  = 0. Whereas, for embedding 
EBs 12  k   into 11  kiii bbb  , we have condition 1 (LC01): 
11  kiii bbb  = EBs, condition 2 (LC02): any bit of IMSBs 
is 1, condition 3 (LC03): 11  kiii bbb  > EBs, condition 4
(LC04): 11  kiii bbb   > EBs - 2
k-1, condition 5 (LC05):  
11  kiii bbb  = EBs - 2
k-1, and condition 6 (LC06): kib  = 1. 
The corresponding multi-bit bitwise A3S embedding 
algorithms are listed in the followings. 
A.  For EBs 12 
 k  be embedded into 11  kiii bbb 
1. If SC01 is true, then OMSBs = IMSBs, OLSBs 
= ILSBs, and go to step 9. 
2. If SC01 is false, then set 11  kiii bbb  = EBs. 
3. If SC02 and SC03 are true, then OMSBs = 
IMSBs, OLSBs = 0s, and go to step 9. 
4. If SC02 is true, SC03 is false, and SC04 is true, 
then OMSBs = IMSBs, OLSBs = 1s, and go to 
step 9. 
5. If SC02 is true, SC03 and SC04 are false, SC05 
and SC06 are true, then OMSBs = IMSBs, 
OLSBs = 1s, and go to step 9. 
6. If SC02 is true, SC03 and SC04 are false, and 
any one of SC05 and SC06 is false, then 
OMSBs = IMSBs + 1, OLSBs = 0s, and go to 
step 9. 
7. If SC02 is false and SC03 is true, then OMSBs 
= IMSBs, OLSBs  = 0s, and go to step 9. 
8. If SC02 is false and SC03 is false, then OMSBs 
= IMSBs, OLSBs  = 1s, and go to step 9. 
9. Stop.
B. For EBs 12  k  be embedded into 11  kiii bbb 
1. If LC01 is true, then OMSBs = IMSBs, OLSBs 
= ILSBs, and go to step 9. 
2. If LC01 is false, then set 11  kiii bbb  = EBs. 
3. If LC02 and LC03 are true, then OMSBs = 
IMSBs, OLSBs = 1s, and go to step 9. 
4. If LC02 is true, LC03 is false, and LC04 is true, 
then OMSBs = IMSBs, OLSBs = 0s, and go to 
step 9. 
5. If LC02 is true, LC03 and LC04 are false, LC05 
and LC06 are true, then OMSBs = IMSBs, 
OLSBs = 0s, and go to step 9. 
6. If LC02 is true, LC03 and LC04 are false, and 
any one of LC05 and LC06 is false, then 
OMSBs = IMSBs - 1, OLSBs = 1s, and go to 
step 9. 
7. If LC02 is false and LC03 is true, then OMSBs 
= IMSBs, OLSBs  = 1s, and go to step 9. 
8. If LC02 is false and LC03 is false, then OMSBs 
= IMSBs, OLSBs  = 0s, and go to step 9. 
9. Stop.
(a)
(b)
Figure 1 Multi-bit bitwise A3S embedding algorithms for 
embedding k-bit data into 11  kiii bbb  , (a) embedding  
secret data 12 
 k  , (b) embedding  secret data 12  k .
The proposed multi-bit bitwise A3S embedding 
algorithms can be graphically illustrated in Figure 1, where 
Figures 1a and 1b are the proposed  Multi-bit bitwise A3S 
embedding algorithms for embedding k-bit secret 
3087
size 128128 . Figure 4 shows the test images, where 
Figures 4a and 4b are cover images: Lena and Sailboat. 
Figures 4c and 4d are 1-bit NUU logo image and its 
scattered version. Meanwhile, Figures 4e and 4f are 3-bit 
NUU logo image and its scattered version. It is worth to 
mention that the scattered logo images are the original logo 
image be scattered using Torus automorphism with k = 1 
and n = 10. In the simulations of DWT watermarking, the 
cover images were decomposed as 3-level wavelets, and the 
scattered logo image was embedded from 1st sub-band of the 
3-level DWT wavelets. For convenience, we used notation 




1
0
k
m
mib_X to express k-bit logo data should be embedded 
into X channel of the cover data from bi bit plane. For 
examples, B_b0 means that 1-bit logo data should be 
embedded into b0 bit plane of B channel of the cover data, 
Y_b3b2b1 means that 3-bit logo data should be embedded 
into b3b2b1 bit planes of B channel of the cover data. 
(a)                            (b)  
                           
(c)                    (d)                     (e)                     (f) 
Figure 4 Test data for various watermarking selections, (a) 
Cover image: Lena (true color, 256256), (b) Cover image: 
Sailboat (true color, 256256), (c) 1-bit NUU logo 
(monochrome, 128128), (d) scattered 1-bit NUU logo, (e) 
3-bit color NUU logo (8 colors, 128128), (f) scattered 3-
bit color NUU logo. 
Figures 5 and 6 show some watermarked Lena and 
Sailboat images which were embedded the scattered 1-bit 
NUU logo into different b0 and b3 bit planes under different 
selections. Figure 7 shows the corresponding 1-bit NUU 
logo images which are detected from figures in Figures 5 
and 6. Various simulation results of 1-bit watermarking 
have been shown in Table II. Besides, some watermarked 
Lena and Sailboat images are shown in Figures 8 and 9, 
which have been embedded the scattered 3-bit color NUU 
logo into different adjoining bit-planes under different 
selections. Figure 10 shows the corresponding 3-bit color 
NUU logo images which are detected from figures in 
Figures 8 and 9. Various simulation results of 3-bit 
watermarking have been shown in Table III. Simulation 
results show that the proposed bitwise k-bit bitwise A3S 
embedding algorithm perform good embedding quality for 
watermarking. 
(a)                             (b)                             (c) 
Figure 5 Watermarked Lena images which the scattered 1-bit 
NUU logo image has been embedded, (a) for B_b0 with 
PSNR 61.91 dB, (b) for Y_b0 with PSNR 52.60 dB, (c) for 
DWT_b0 with PSNR 48.65 dB. 
(a)                             (b)                             (c) 
Figure 6 Watermarked Sailboat images which the scattered 
3-bit color NUU logo image has been embedded, (a) for 
B_b0 with PSNR 61.95 dB, (b) for Y_b0 with PSNR 52.46 
dB, (c) for DWT_b0 with PSNR 48.60 dB. 
       (a)           (b)            (c)            (d)            (e)           (f) 
Figure 7 Corresponding 1-bit NUU logo images which are 
detected from the watermarked Lena and Sailboat images in 
Figures5 and 6. 
Table II PSNRs of 1-bit watermarking (unit: dB) 
Lena Sailboat Bit
plane B Y DWT B Y DWT
b0 61.91 52.60 48.65 61.95 52.46 48.60
b1 61.89 52.46 46.61 61.93 52.45 46.90
b2 57.88 50.68 40.96 57.96 50.61 41.51
b3 53.25 47.40 34.31 53.12 47.54 34.88
b4 48.10 42.89 27.64 47.85 42.86 28.09
b5 42.51 37.32 21.28 41.48 37.54 21.67
b6 36.88 31.48 15.59 34.49 31.63 15.98
b7 29.39 23,47 11.39 24.20 20.93 11.37
To test the robustness of the proposed multi-bit bitwise 
A3S embedding algorithm, some typical signal processing 
attacks, such as noise adding, filtering, brightness/contrast 
adjusting, and rotation are performed in DWT domain. The 
experimental results of Lena image are shown in Figure 11. 
It can be seen that our algorithm suffers from rotation 
attacks. However, it can successfully resist attacks by noise 
adding, filtering, and brightness/contrast adjusting. The 
extracted watermarks can be identified and declared 
correctly.
31009
perform good quality of stego-image for steganography due 
to the recovered secret images are lossless. 
(a)                             (b) 
(c)                           (d) 
Figure 14 Stego-images and the recovered secret images, (a) 
Lena stego-image which has been embedded the scattered 
Baboon using R3G2B3 hiding method with PSNR 41.923 
dB, (b) lossless recovered secret Baboon image, (c) Lena 
stego-image which has been embedded the scattered Peppers 
using R3G2B3 hiding method with PSNR 41.922 dB, (d) 
lossless recovered secret Peppers image. 
C. Performance Comparisons 
The comparisons of the PSNR values of the proposed 
multi-bit bitwise A3S embedding algorithm with other 
methods are shown in Tables IV and V. Among these tables, 
Table IV shows PSNR values of watermarking for 
embedding 4-bit logo image into cover images. Table V 
shows PSNR values of steganography for R3G2B3 hiding 
method. According to the results shown in Tables the PSNR 
values of the proposed multi-bit bitwise A3S embedding 
algorithm are all higher than those of  [1, 12]. 
Table IV Comparisons of watermarking for 4-bit logo 
embedding 
 [1]: PSNR (dB) Proposed: PSNR (dB)
Lena 34.86 
Peppers 
31.71 
34.78 
Table V Comparisons of steganography for R3G2B3 hiding 
 [12]: PSNR (dB) Proposed: PSNR (dB)
Baboon 41.872 41.923 
Peppers 41.873 41.922 
IV. DISCUSSIONS AND CONCLUSIONS
This paper presents the novel multi-bit bitwise A3S 
embedding algorithms for data hiding. These multi-bit 
bitwise A3S embedding algorithms can embed k-bit ( 1k )
secret data into cover data only introduce minimum 
embedding error smaller than   kik   212 1 according to the 
embedding location i. Many simulations show that the 
proposed multi-bit bitwise A3S embedding algorithms 
perform good embedding quality for watermarking and 
steganography applications. 
Reasons that we develop the proposed multi-bit bitwise 
A3S embedding algorithms are (1) to overcome the 
drawbacks that exist in the previous works and (2) to reduce 
the computation complexity that exists in the previous works 
for easy hardware implementation. Hardware 
implementation of the proposed multi-bit bitwise A3S 
embedding algorithms is one of our current works.  
ACKNOWLEDGMENT
The National Science Council of Republic of China 
under the contract NSC-97-2221-E-239-036-MY3 supported 
this work. 
REFERENCES
[1] Y. K. Lee and L. H. Chen, “High capacity image 
steganographic model,” IEE Proceedings- Vision, Image and 
Signal Processing, vol. 147, no. 3, pp. 1–15, June 2000. 
[2] T. S. Chen, J. Chen, and J. G. Chen, “A simple and efficient 
watermarking technique based on JPEG2000 codec,” 
Proceddings of the IEEE ISMSE’03, pp. 80-87, 10-12 Dec., 
2003.
[3] P. S. Huang, C. S. Chiang, C. P. Chang, and T. M. Tu, 
"Robust spatial watermarking technique for colour images via 
direct saturation adjustment," IEE Proceedings- Vision, Image 
and Signal Processing, vol. 152, pp. 561-574, 2005. 
[4] S. Kimpan, A. Lasakul, and S. Chitwong, "Variable block size 
based adaptive watermarking in spatial domain," Proceedings 
of IEEE ISCIT 2004,vol. 1, pp. 374-377, 2004. 
[5] H. Ren-Junn, K. Chuan-Ho, and C. Rong-Chi, "Watermark in 
color image," Proceedings of the first International 
Symposium on Cyber Worlds, pp. 225-229, 2002. 
[6] B. Verma, S. Jain, D. P. Agarwal, and A. Phadikar, "A New 
color image watermarking scheme," Infocomp, Journal of 
computer science, vol. 5,N.2, pp. 37-42, 2006. 
[7] X. Wu and Z.-H. Guan, "A novel digital watermark algorithm 
based on chaotic maps," Physics Letters A, vol. 365, pp. 403-
406, 2007. 
[8] L. M. Cheng, L. L. Cheng, C. K. Chan, and K. W. Ng, 
"Digital watermarking based on frequency random position 
insertion," Proceedings of Control, Automation, Robotics and 
Vision Conference, vol. 2, pp. 977-982, 2004. 
[9] L. Chun-Shien, H. Shih-Kun, S. Chwen-Jye, and L. Hong-
Yuan Mark, "Cocktail watermarking for digital image 
protection," IEEE Transactions on Multimedia, vol. 2, pp. 
209-224, 2000. 
[10] W. Lu, H. Lu, and F.-L. Chung, "Robust digital image 
watermarking based on subsampling," Applied Mathematics 
and Computation, vol. 181, pp. 886-893, 2006. 
[11] A. A. Reddy and B. N. Chatterji, "A new wavelet based logo-
watermarking scheme," Pattern Recognition Letters, vol. 26, 
pp. 1019-1027, 2005. 
[12] Y. H. Yu, C. C. Chang, and I. C. Lin, “A new steganographic 
method for color and grayscale imahe hiding,” Computer 
Vision and Image Understanding, vol. 107, no. 3, pp. 183-194, 
September 2007. 
[13] G. Voyatzis, I. Pitas, “Applications of toral automorphisms in 
image watermarking,” Proceedings of the International 
Conference on Image Processing, vol. II, pp. 237–240, 1996.
3121
 embedded value that is closest to the original value to 
introduce the minimum error. 
 
(a)                                             (b) 
 
(c)                                            (d) 
Figure 1 1-bit embedding examples of cover data with value 
of 12710, (a) cover data, (b) 9510: embedded value of 
embedding ‘0’ with maximum error -32, (c) 12810: embedded 
value of embedding ‘0’ with minimum error +1, (d) 12710: 
embedded value of embedding ‘1’ with zero error. 
 
(a)                                             (b) 
 
(c)                                            (d) 
Figure 2 1-bit embedding examples of cover data with value 
of 11110, (a) cover data, (b) 7910: embedded value of 
embedding ‘1’ with maximum error -32, (c) 9510: embedded 
value of embedding ‘1’ with minimum error -16, (d) 11110: 
embedded value of embedding ‘0’ with zero error . 
Figure 1a shows the cover data with value of 12710 which 
will be embedded 1-bit ‘0’ into 5b . After ‘0’ embedding, the 
embedded value might have the maximum error of -25 = -32 
as shown in Figure 1b. Such an embedded value is 9510. In 
order to reduce the embedding error, we used the brute forced 
search to choose the closest value 12810 as shown in Figure 
1c to replace the original value (12710) to achieve minimum 
error, and we found that the minimum embedding error is 
only +1. The rule for embedding ‘1’ into 5b  of cover data is 
similar to that of embedding ‘0’. Finally, we choose 12710 
(Figure 1d) as the embedded value which is the closest to the 
original value with zero error due to 5b  of cover data is ‘1’. 
Figure 2a shows the cover data with value of 11110 which will 
be embedded 1-bit data ‘0’ into 5b . Figure 2b shows that the 
embedded value 7910 introduce maximum error with value of 
-32; whereas, Figure 2c shows that the embedded value 9510 
introduce minimum error with value of -16. Figure 2d shows 
that the 1-bit data ‘1’ be embedded into 5b  of 11110 achieves 
zero error due to 5b  of 11110 is ‘1’. 
To further illustrate 1-bit embedding, we will show more 
other examples in the following. Suppose ‘1’ is embedded 
into 5b  of cover data with value of 6410 as in Figure 3a. After 
embedding, the embedded value might have the maximum 
error of +25 = +32 as shown in Figure 3b. Such an embedded 
value is 9610. In order to reduce the embedding error, the 
brute forced search is used to choose the closest value 6310 as 
shown in Figure 3c to replace the original value (6410) to 
achieve minimum error, and we found that the minimum 
embedding error is only -1. The rule for embedding ‘0’ into 
5b  of cover data is similar to that of embedding ‘1’; however, 
value ‘1’ is embedded into 5b  of cover data. Finally, we 
choose 6410 (Figure 3d) as the embedded value which is the 
closest to the original value with zero error due to 5b  of 
cover data is ‘0’. Figure 4a shows the cover data with value 
of 8010 which will be embedded 1-bit data ‘1’ into 5b . Figure 
4b shows that the embedded value 11210 introduce maximum 
error with value of +32; whereas, Figure 4c shows that the 
embedded value 9610 introduce minimum error with value of 
+16. Figure 4d shows that the 1-bit data ‘0’ be embedded into 
5b  of  8010 which achieves zero error due to 5b  of 8010 is ‘1’. 
 
(a)                                             (b) 
 
(c)                                            (d) 
Figure 3 1-bit embedding examples of cover data with value 
of 6410, (a) cover data, (b) 9610: embedded value of 
embedding ‘1’ with maximum error +32, (c) 6310: embedded 
value of embedding ‘1’ with minimum error -1, (d) 6410: 
embedded value of embedding ‘0’ with zero error . 
 
(a)                                             (b) 
 
(c)                                            (d) 
Figure 4 1-bit embedding examples of cover data with value 
of 8010, (a) cover data, (b) 11210: embedded value of 
embedding ‘1’ with maximum error +32, (c) 9610: embedded 
value of embedding ‘1’ with minimum error +16, (d) 8010: 
embedded value of embedding ‘0’ with zero error. 
Before summary the previous observations, we define 
some notations for convenience. Let the maximum-significant 
bits (MSBs) be the bits that higher then ib  and the least-
significant bits (LSBs) be the bits that lower then ib . We also 
let IMSBs and ILSBs denote MSBs and LSBs of cover data, 
respectively; meanwhile, OMSBs and OLSBs denote MSBs 
and LSBs of embedded data, respectively. Besides that, the 
embedding data be denote as EB. From Figs. 1c, 2c, 3c and 
4c, it clearly knows that the procedure of 1-bit data be 
embedded into ib  of cover data can be divided into three 
steps: (1) embed secret data into cover data, (2) adaptively 
adjust ILSBs, and (3) adaptively adjust IMSBs. Due to such a 
procedure achieves the minimum BEE, we therefore develop 
the corresponding embedding algorithms as the followings. 
z For EB = 0 be embedded into ib  
1. Check whether ib is equal to 0 or not. 
2. If ib = 0, then OMSBs = IMSBs, OLSBs = ILSBs, 
and go to step 6. 
3. If ib ≠  0, then set ib = 0 and check whether all 
bits of IMSBs are 1s and 1−ib is 1 or not. 
4. If any bit of IMSBs is 0 and 1−ib is 1, then 
OMSBs += 1, OLSBs = 0s, and go to step 6. 
5. If all bits of IMSBs are 1s or 1−ib is 0, then 
OMSBs = IMSBs, OLSBs  = 1s, and go to step 6. 
6. Stop. 
z For EB = 1 be embedded into ib  
1. Check whether ib is equal to 1 or not. 
212
 XOR embedding method shall introduce maximum 
embedding error with value of ∑−
=
+−±
1
0
122
k
l
lki . However, if we 
use the proposed k-bit bitwise A3S embedding algorithms the 
maximum embedding error shall be restricted to 
( ) kik −−± 212  and it is smaller than ∑−
=
+− 1
0
122
k
l
lki  for all k.  The 
procedure of embedding multi-bit data into 11 +−− kiii bbb L  of 
cover data also can be divided into three steps: (1) embed 
secret data into 11 +−− kiii bbb L  of cover data, (2) adaptively 
adjust ILSBs, and (3) adaptively adjust IMSBs. It is helpful to 
summarize all conditions that we used to develop the multi-
bit bitwise adaptive 3-step embedding algorithms. For 
embedding EBs 12 −< k  into 11 +−− kiii bbb L , we have condition 
1 (SC01): 11 +−− kiii bbb L = EBs, condition 2 (SC02): any bit of 
IMSBs is 0, condition 3 (SC03): 11 +−− kiii bbb L < EBs, 
condition 4 (SC04): 11 +−− kiii bbb L  < EBs + 2k-1, condition 5 
(SC05):  11 +−− kiii bbb L = EBs + 2k-1, and condition 6 (SC06): 
kib − = 0. Whereas, for embedding EBs 
12 −≥ k   into 
11 +−− kiii bbb L , we have condition 1 (LC01): 11 +−− kiii bbb L = 
EBs, condition 2 (LC02): any bit of IMSBs is 1, condition 3 
(LC03): 11 +−− kiii bbb L > EBs, condition 4 (LC04): 
11 +−− kiii bbb L  > EBs - 2k-1, condition 5 (LC05):  
11 +−− kiii bbb L = EBs - 2k-1, and condition 6 (LC06): kib − = 1. 
The corresponding multi-bit bitwise adaptive 3-step 
embedding algorithms are listed in the followings. 
z For EBs 12 −< k  be embedded into 11 +−− kiii bbb L  
1. If SC01 is true, then OMSBs = IMSBs, OLSBs = 
ILSBs, and go to step 9. 
2. If SC01 is false, then set 11 +−− kiii bbb L = EBs. 
3. If SC02 and SC03 are true, then OMSBs = IMSBs, 
OLSBs = 0s, and go to step 9. 
4. If SC02 is true, SC03 is false, and SC04 is true, then 
OMSBs = IMSBs, OLSBs = 1s, and go to step 9. 
5. If SC02 is true, SC03 and SC04 are false, SC05 and 
SC06 are true, then OMSBs = IMSBs, OLSBs = 
1s, and go to step 9. 
6. If SC02 is true, SC03 and SC04 are false, and any 
one of SC05 and SC06 is false, then OMSBs = 
IMSBs + 1, OLSBs = 0s, and go to step 9. 
7. If SC02 is false and SC03 is true, then OMSBs = 
IMSBs, OLSBs  = 0s, and go to step 9. 
8. If SC02 is false and SC03 is false, then OMSBs = 
IMSBs, OLSBs  = 1s, and go to step 9. 
9. Stop. 
z For EBs 12 −≥ k  be embedded into 11 +−− kiii bbb L  
1. If LC01 is true, then OMSBs = IMSBs, OLSBs = 
ILSBs, and go to step 9. 
2. If LC01 is false, then set 11 +−− kiii bbb L = EBs. 
3. If LC02 and LC03 are true, then OMSBs = IMSBs, 
OLSBs = 1s, and go to step 9. 
4. If LC02 is true, LC03 is false, and LC04 is true, then 
OMSBs = IMSBs, OLSBs = 0s, and go to step 9. 
5. If LC02 is true, LC03 and LC04 are false, LC05 and 
LC06 are true, then OMSBs = IMSBs, OLSBs = 
0s, and go to step 9. 
6. If LC02 is true, LC03 and LC04 are false, and any 
one of LC05 and LC06 is false, then OMSBs = 
IMSBs - 1, OLSBs = 1s, and go to step 9. 
7. If LC02 is false and LC03 is true, then OMSBs = 
IMSBs, OLSBs  = 1s, and go to step 9. 
8. If LC02 is false and LC03 is false, then OMSBs = 
IMSBs, OLSBs  = 0s, and go to step 9. 
9. Stop. 
Figure 8 shows the proposed multi-bit bitwise A3S 
embedding algorithms, where Figs. 8a and 8b are the 
proposed  multi-bit bitwise A3S embedding algorithms for 
embedding k-bit secret data 12 −< k and k-bit secret data 12 −≥ k  
into bits: 11 +−− kiii bbb L of cover data respectively. Figure 9 
shows four examples to illustrate how the proposed 2-bit 
bitwise A3S embedding algorithms achieve 3-step procedure. 
Using these algorithms to embed k-bit secret data into the 
bit 11 +−− kiii bbb L of cover data, the maximum BEE can be 
restricted to ( ) kik −− −± 212 1 . We used the brute force 
searching algorithm to choose the embedded data with 
minimum BEE for k-bit secret data embedding. Figure 10 
shows the minimum BEEs for embedding 2-bit secret data 
into bibi-1 of 8-bit cover data, where 71 ≤≤ i . Our simulation 
results show the proposed multi-bit A3S embedding 
algorithms achieve the embedded data with BEEs exactly 
match with those of Figure 10.  This fact also shows that the 
proposed multi-bit A3S embedding algorithms achieve the 
minimum BEEs as our expectation. 
   
(a)                                             (b) 
  
(c)                                           (d) 
Figure 9 Examples for illustrating the procedures of the 
proposed 2-bit A3S embedding algorithms, (a) embedding 002 
into b4b3, (b) embedding 012 into b4b3, (c) embedding 102 into 
b4b3, (d) embedding 112 into b4b3. 
214
    
(a)                             (b)                             (c) 
Figure 13 Watermarked Lena images which the scattered 1-bit 
NUU logo image has been embedded, (a) for B_b0 with PSNR 
61.91 dB, (b) for Y_b0 with PSNR 52.60 dB, (c) for DWT_b0 
with PSNR 48.65 dB. 
   
(a)                             (b)                             (c) 
Figure 14 Watermarked Sailboat images which the scattered 
3-bit color NUU logo image has been embedded, (a) for B_b0 
with PSNR 61.95 dB, (b) for Y_b0 with PSNR 52.46 dB, (c) 
for DWT_b0 with PSNR 48.60 dB. 
 
  
       (a)           (b)            (c)            (d)            (e)           (f) 
Figure 15 Corresponding 1-bit NUU logo images which are 
detected from the watermarked Lena and Sailboat images in 
Figs.12 and 13. 
TABLE II. PSNRs of 1-bit Watermarking (unit: dB) 
Bit 
plane 
Lena Sailboat 
B Y DWT B Y DWT
b0 61.91 52.60 48.65 61.95 52.46 48.60
b1 61.89 52.46 46.61 61.93 52.45 46.90
b2 57.88 50.68 40.96 57.96 50.61 41.51
b3 53.25 47.40 34.31 53.12 47.54 34.88
b4 48.10 42.89 27.64 47.85 42.86 28.09
b5 42.51 37.32 21.28 41.48 37.54 21.67
b6 36.88 31.48 15.59 34.49 31.63 15.98
b7 29.39 23,47 11.39 24.20 20.93 11.37
Figures in Figure 13 and Figure 14 show some 
watermarked Lena and Sailboat images which were 
embedded the scattered 1-bit NUU logo into different b0 and 
b3 bit planes under different selections. Figure 15 shows the 
corresponding 1-bit NUU logo images which are detected 
from figures in Figures 13 and 14. Various simulation results 
of 1-bit watermarking have been shown in TABLE II. 
Besides, some watermarked Lena and Sailboat images are 
shown in Figures 16 and 17, which have been embedded the 
scattered 3-bit color NUU logo into different adjoining bit-
planes under different selections. Figure 18 shows the 
corresponding 3-bit color NUU logo images which are 
detected from figures in Figures 16 and 17. Various 
simulation results of 3-bit watermarking have been shown in 
TABLE III. Simulation results show that the proposed bitwise 
k-bit bitwise A3S embedding algorithm perform good 
embedding PSNR quality for watermarking. 
   
(a)                             (b)                             (c) 
Figure 16 Watermarked Lena images which the scattered 3-bit 
color NUU logo image has been embedded, (a) for B_b2b1b0 
with PSNR 51.52 dB, (b) for Y_ b2b1b0 with PSNR 46.06 dB, 
(c) for DWT_ b2b1b0 with PSNR 36.58 dB. 
   
(a)                             (b)                             (c) 
Figure 17 Watermarked Sailboat images which the scattered 
3-bit color NUU logo image has been embedded, (a) for B_ 
b2b1b0 with PSNR 51.51 dB, (b) for Y_ b2b1b0 with PSNR 
46.06 dB, (c) for DWT_ b2b1b0 with PSNR 37.01 dB. 
 
      (a)           (b)             (c)            (d)           (e)            (f) 
Figure 18 Corresponding 3-bit color NUU logo images which 
are detected from the watermarked Lena and Sailboat images 
in Figs. 16 and 17. 
To test the robustness of the proposed multi-bit bitwise 
A3S embedding algorithm, some typical signal processing 
attacks, such as noise adding, filtering, brightness/contrast 
adjusting, rotation, and compression are performed in DWT 
domain. The experimental results of Lena image are shown in 
Figure 19. It has been seen that our algorithm suffers from 
rotation attacks. However, it can successfully resist attacks by 
noise adding, filtering, brightness adjusting, contrast 
adjusting, JPEG compression, and JPEG 2000 compression. 
The extracted watermarks can be identified and declared 
correctly. 
TABLE III. PSNRs of 3-bit Watermarking (unit: dB) 
Bit 
planes 
Lena Sailboat 
B Y DWT B Y DWT
b2b1b0 51.52 46.06 36.58 51.51 41.06 37.01
b3b2b1 46.67 41.51 30.05 46.52 41.52 30.50
b4b3b2 41.09 36.09 23.60 40.74 36.23 23.98
b5b4b3 35.27 30.37 17.61 34.49 30.75 18.01
b6 b5b4 29.60 24.21 12.71 27.00 23.10 12.90
b7b6 b5 20.83 15.98 9.66 18.84 14.87 9.34
216
 Pattern Recognition and Artificial Intelligence, vol. 16, no.6, 
pp. 697–713, 2002. 
[19] J. S. Kang, Y. You, and M. Y. Sung, “Steganography using 
block-based adaptive threshold,” Proceedings of the IEEE 2007 
International Symposium on Computer and Information 
Science, pp. 1-7,  Ankara, Turkey, 7-9 Nov., 2007. 
[20] Y. C. Peng, “Hardware implementation of watermarking using 
minimum error embedding algorithms,” Master Thesis, 
National United University, Taiwan, June 2010. 
 
Figure 7 The minimum BEEs for embedding 1-bit secret data into ib  of 8-bit cover data where 70 ≤≤ i . The proposed A3S 
embedding algorithms achieve the embedded data with BEEs exactly match with these. 
 
Figure 10 The minimum BEEs for embedding 2-bit secret data into bibi-1 of 8-bit cover data where 71 ≤≤ i . 
218
In the following paragraphs, we will discuss how choose the 
embedded value that is closest to the original value to 
introduce the minimum error. 
 
(a)                                             (b) 
 
(c)                                            (d) 
Figure 1 1-bit embedding examples of cover data with value 
of 12710, (a) cover data, (b) 9510: embedded value of 
embedding ‘0’ with maximum error -32, (c) 12810: embedded 
value of embedding ‘0’ with minimum error +1, (d) 12710: 
embedded value of embedding ‘1’ with zero error. 
 
(a)                                             (b) 
 
(c)                                            (d) 
Figure 2 1-bit embedding examples of cover data with value 
of 11110, (a) cover data, (b) 7910: embedded value of 
embedding ‘1’ with maximum error -32, (c) 9510: embedded 
value of embedding ‘1’ with minimum error -16, (d) 11110: 
embedded value of embedding ‘0’ with zero error . 
Figure 1a shows the cover data with value of 12710 which 
will be embedded 1-bit ‘0’ into 5b . After ‘0’ embedding, the 
embedded value might have the maximum error of -25 = -32 
as shown in Figure 1b. Such an embedded value is 9510. In 
order to reduce the embedding error, we used the brute forced 
search to choose the closest value 12810 as shown in Figure 
1c to replace the original value (12710) to achieve minimum 
error, and we found that the minimum embedding error is 
only +1. The rule for embedding ‘1’ into 5b  of cover data is 
similar to that of embedding ‘0’. Finally, we choose 12710 
(Figure 1d) as the embedded value which is the closest to the 
original value with zero error due to 5b  of cover data is ‘1’. 
Figure 2a shows the cover data with value of 11110 which will 
be embedded 1-bit data ‘0’ into 5b . Figure 2b shows that the 
embedded value 7910 introduce maximum error with value of 
-32; whereas, Figure 2c shows that the embedded value 9510 
introduce minimum error with value of -16. Figure 2d shows 
that the 1-bit data ‘1’ be embedded into 5b  of 11110 achieves 
zero error due to 5b  of 11110 is ‘1’. 
To further illustrate 1-bit embedding, we will show more 
other examples in the following. Suppose ‘1’ is embedded 
into 5b  of cover data with value of 6410 as in Figure 3a. After 
embedding, the embedded value might have the maximum 
error of +25 = +32 as shown in Figure 3b. Such an embedded 
value is 9610. In order to reduce the embedding error, the 
brute forced search is used to choose the closest value 6310 as 
shown in Figure 3c to replace the original value (6410) to 
achieve minimum error, and we found that the minimum 
embedding error is only -1. The rule for embedding ‘0’ into 
5b  of cover data is similar to that of embedding ‘1’; however, 
value ‘1’ is embedded into 5b  of cover data. Finally, we 
choose 6410 (Figure 3d) as the embedded value which is the 
closest to the original value with zero error due to 5b  of 
cover data is ‘0’. Figure 4a shows the cover data with value 
of 8010 which will be embedded 1-bit data ‘1’ into 5b . Figure 
4b shows that the embedded value 11210 introduce maximum 
error with value of +32; whereas, Figure 4c shows that the 
embedded value 9610 introduce minimum error with value of 
+16. Figure 4d shows that the 1-bit data ‘0’ be embedded into 
5b  of  8010 which achieves zero error due to 5b  of 8010 is ‘1’. 
 
(a)                                             (b) 
 
(c)                                            (d) 
Figure 3 1-bit embedding examples of cover data with value 
of 6410, (a) cover data, (b) 9610: embedded value of 
embedding ‘1’ with maximum error +32, (c) 6310: embedded 
value of embedding ‘1’ with minimum error -1, (d) 6410: 
embedded value of embedding ‘0’ with zero error . 
 
(a)                                             (b) 
 
(c)                                            (d) 
Figure 4 1-bit embedding examples of cover data with value 
of 8010, (a) cover data, (b) 11210: embedded value of 
embedding ‘1’ with maximum error +32, (c) 9610: embedded 
value of embedding ‘1’ with minimum error +16, (d) 8010: 
embedded value of embedding ‘0’ with zero error. 
Before summary the previous observations, we define 
some notations for convenience. Let the maximum-significant 
bits (MSBs) be the bits that higher then ib  and the least-
significant bits (LSBs) be the bits that lower then ib . We also 
let IMSBs and ILSBs denote MSBs and LSBs of cover data, 
respectively; meanwhile, OMSBs and OLSBs denote MSBs 
and LSBs of embedded data, respectively. Besides that, the 
embedding data be denote as EB. From Figs. 1c, 2c, 3c and 
4c, it clearly knows that the procedure of 1-bit data be 
embedded into ib  of cover data can be divided into three 
steps: (1) embedding secret data into cover data, (2) 
adaptively adjust ILSBs, and (3) adaptively adjust IMSBs. 
Due to such a procedure achieves the minimum BEE, we 
therefore develop the corresponding embedding algorithms as 
the followings. 
z For EB = 0 be embedded into ib  
1. Check whether ib is equal to 0 or not. 
2. If ib = 0, then OMSBs = IMSBs, OLSBs = ILSBs, 
and go to step 6. 
3. If ib ≠  0, then set ib = 0 and check whether all 
bits of IMSBs are 1s and 1−ib is 1 or not. 
26022
z For EBs 12 −< k  be embedded into 11 +−− kiii bbb L  
1. If SC01 is true, then OMSBs = IMSBs, OLSBs = 
ILSBs, and go to step 9. 
2. If SC01 is false, then set 11 +−− kiii bbb L = EBs. 
3. If SC02 and SC03 are true, then OMSBs = IMSBs, 
OLSBs = 0s, and go to step 9. 
4. If SC02 is true, SC03 is false, and SC04 is true, then 
OMSBs = IMSBs, OLSBs = 1s, and go to step 9. 
5. If SC02 is true, SC03 and SC04 are false, SC05 and 
SC06 are true, then OMSBs = IMSBs, OLSBs = 
1s, and go to step 9. 
6. If SC02 is true, SC03 and SC04 are false, and any 
one of SC05 and SC06 is false, then OMSBs = 
IMSBs + 1, OLSBs = 0s, and go to step 9. 
7. If SC02 is false and SC03 is true, then OMSBs = 
IMSBs, OLSBs  = 0s, and go to step 9. 
8. If SC02 is false and SC03 is false, then OMSBs = 
IMSBs, OLSBs  = 1s, and go to step 9. 
9. Stop. 
z For EBs 12 −≥ k  be embedded into 11 +−− kiii bbb L  
1. If LC01 is true, then OMSBs = IMSBs, OLSBs = 
ILSBs, and go to step 9. 
2. If LC01 is false, then set 11 +−− kiii bbb L = EBs. 
3. If LC02 and LC03 are true, then OMSBs = IMSBs, 
OLSBs = 1s, and go to step 9. 
4. If LC02 is true, LC03 is false, and LC04 is true, then 
OMSBs = IMSBs, OLSBs = 0s, and go to step 9. 
5. If LC02 is true, LC03 and LC04 are false, LC05 and 
LC06 are true, then OMSBs = IMSBs, OLSBs = 
0s, and go to step 9. 
6. If LC02 is true, LC03 and LC04 are false, and any 
one of LC05 and LC06 is false, then OMSBs = 
IMSBs - 1, OLSBs = 1s, and go to step 9. 
7. If LC02 is false and LC03 is true, then OMSBs = 
IMSBs, OLSBs  = 1s, and go to step 9. 
8. If LC02 is false and LC03 is false, then OMSBs = 
IMSBs, OLSBs  = 0s, and go to step 9. 
9. Stop. 
 
(a) 
 
(b) 
Figure 8 Multi-bit bitwise A3S embedding algorithms for 
embedding k-bit data into 11 +−− kiii bbb L , (a) embedding  
secret data 12 −< k  , (b) embedding  secret data 12 −≥ k . 
   
(a)                                             (b) 
  
(c)                                           (d) 
Figure 9 Examples for illustrating the procedures of the 
proposed 2-bit A3S embedding algorithms, (a) embedding 002 
into b4b3, (b) embedding 012 into b4b3, (c) embedding 102 into 
b4b3, (d) embedding 112 into b4b3. 
Figure 8 shows the proposed multi-bit bitwise A3S 
embedding algorithms, where Figs. 8a and 8b are the 
proposed  multi-bit bitwise A3S embedding algorithms for 
embedding k-bit secret data 12 −< k and k-bit secret data 12 −≥ k  
into bits: 11 +−− kiii bbb L of cover data respectively. Figure 9 
shows four examples to illustrate how the proposed 2-bit 
bitwise A3S embedding algorithms achieve 3-step procedure. 
Using these algorithms to embed k-bit secret data into the 
26224
generated from the proposed multi-bit and multi-image 
steganography system, are summarized in Figure 17. It clearly 
show that the proposed multi-bit and multi-image 
steganography system achieved high quality of stego-images 
even if the embedding capacity more than 50%. In our 
experiments, we also knew that the retrieved secret images are 
lossless due to they are identical to the original ones. These 
facts show that the proposed multi-bit bitwise A3S embedding 
algorithms perform good quality of stego-images. 
   
(a)                             (b)                           (c) 
   
(d)                             (e)                           (f) 
Figure 14 Stego-images of Lena, (a) Group_1, R3G2B3, 
PSNR 41.92 dB, EC 33.3%, (b) Group_1, R4G4B4, PSNR 
34.91 dB, CE 50%, (c) Group_1, R5G4B4, PSNR 31.90 dB, 
CE 54.2%, (d) Group_2, R3G2B3, PSNR 41.92 dB, CE 
33.3%, (e) Group_2, R4G4B4, PSNR 34.92 dB, CE 50%, (f) 
Group_2, R5G4B4, PSNR 31.79 dB, CE 54.2%. 
   
(a)                             (b)                           (c) 
   
(d)                             (e)                           (f) 
Figure 15 Stego-images of Sailboat, (a) Group_1, R3G2B3, 
PSNR 41.92 dB, CE 33.3%, (b) Group_1, R4G4B4, PSNR 
34.92 dB, CE 50%, (c) Group_1, R5G4B4, PSNR 31.59 dB, 
CE 54.2%,  (d) Group_2, R3G2B3, CE 33.3%, PSNR 41.91 
dB, (e) Group_2, R4G4B4, PSNR 34.94 dB, CE 50%, (f) 
Group_2, R5G4B4, PSNR 31.78 dB, CE 54.2%. 
   
(a)                             (b)                           (c) 
   
(d)                             (e)                           (f) 
Figure 16 Stego-images of Vegetables, (a) Group_1, R3G2B3 , 
PSNR 41.56 dB, CE 33.3%, (b) Group_1, R4G4B4, PSNR 
34.58 dB, CE 50%, (c) Group_1, R5G4B4, PSNR 31.04 dB, 
CE 54.2%,  (d) Group_2, R3G2B3, PSNR 41.72 dB, CE 
33.3%, (e) Group_2, R4G4B4, PSNR 34.53 dB, CE 50%, (f) 
Group_2, R5G4B4, PSNR 31.04 dB, CE 54.2%. 
 
(a) 
 
(b) 
Figure 17 PSNR (dB) vs embedding capacity (%) of stego-
images, (a) Group_1 secret images have been embedded, (b) 
Group_2 secret images have been embedded. 
B. Performance Comparisons 
The performance comparisons of the proposed multi-bit 
bitwise A3S embedding algorithm with other methods are 
shown in TABLE I. It shows PSNR values of stego-images for 
different embedding capacities. According to the results 
26426
 
Figure 7 The minimum BEEs for embedding 1-bit secret data into ib  of 8-bit cover data where 70 ≤≤ i . The proposed A3S 
embedding algorithms achieve the embedded data with BEEs exactly match with these. 
 
Figure 10 The minimum BEEs for embedding 2-bit secret data into bibi-1 of 8-bit cover data where 71 ≤≤ i . 
26628
Multi-bit Adaptive Embedding Algorithm for Anti-
Forensic Steganography
Rong-Jian Chen* 
Department of Electronic Engineering 
National United University 
Miaoli, Taiwan 
rjchen@nuu.edu.tw 
Shi-Jinn Horng 
Depart. of Computer Science and Information Engineering 
National Taiwan University of Science and Technology 
Taipei, Taiwan 
horngsj@yahoo.com.tw
 
 
Abstract—Multi-bit minimum error replacement (MER) is a 
method that can embed multi-bit logo/secret data into k least-
significant bits (LSBs) of cover data only introduces minimum 
embedding error (MEE). However, k-LSBs MER suffers from 
weak anti-forensics. Moreover, it is unfortunate because other 
previous steganography works have seldom considered both 
large embedding capacity and high image quality. Therefore, this 
work proposes an anti-forensic steganography system using 
multi-bit adaptive embedding algorithm with flexible bit location 
to overcome the problem of forensics and to achieve high 
performance includes both large embedding capacity and high 
image quality. The proposed embedding algorithm embeds and 
hides multi-bit (k-bit, ) logo/secret data into any adjoining 
(starting with the ith location) k-bit of cover data 
only introduces MEE in the range of 0 to 
1≥k
11 +−− kiii bbb L( ) ki−k −± 212 ; moreover, 
its flexible bit location enhances the embedded security as 
security increases as embedding location increases. As the 
proposed embedding algorithm can embed multi-bit logo/secret 
data into any adjoining bits of cover data and has large 
embedding capacity and high embedding quality, this method 
was applied to develop image steganography systems. Finally, 
anti-forensics of the proposed steganography systems are 
demonstrated using the visual attack and the statistical attack of 
Chi-square analysis. 
Keywords-steganographgy; anti-forensics; multi-bit 
embedding; minimum-error replacement; flexible bit location 
I.  INTRODUCTION 
In information and data hiding, the minimum-error 
replacement (MER) approach is typically used to find data as 
close to the original as possible. Generally, if one wants to 
embed k-bit secret data into N-bit ( ) cover data, 
replacing the k-LSBs of cover data will introduce fewer errors 
than replacing any other k bits. In this case, the embedding 
error introduced is from 0 to 
kN ≥
( )12 −± k
kN−2
. Considering N-bit 
cover data,  values whose k-LSBs are identical exist in the 
embedded k bits. To achieve the highest quality, should use the 
most similar data among these  values to replace the 
original. Many LSB-based methods [1-9] have been developed 
to use in steganography application. Lee et al. [1] developed a 
two-step MER method to find the closest data value to 
minimize the errors. In [1], capacity evaluation (CE)-uses the 
gray-scale variation of neighboring pixels and their intensity to 
Wang et al. [2] designed an optimal LSB substitution method 
that uses a genetic algorithm to search for an approximately 
optimal solution to a special mapping problem. This special 
mapping function transforms secret data values into another set 
of values. The transformed values are then embedded into 
LSBs, such that embedded data have minimum errors. Chang 
et al. [3] proposed another optimal LSB substitution method 
via dynamic programming to obtain the optimal solution. Chan 
et al. [4] developed a simple LSB substitution method using an 
optimal pixel adjustment process (OPAP) [5, 6] to reduce the 
magnitude of embedding errors. OPAP methods used the least 
k-bit to embed secret data and at the same time toggles the 
(k+1)th bit while comparing the toggle with least distortion. To 
achieve high embedding capacity, Lee and Chen [7] proposed a 
data hiding scheme based on the modulus function (HBMF), in 
which a variant Cartesian product is operated upon the 
modulus function to hide and extract the message. In HBMF 
method, the size of the variant Cartesian product is examined to 
evaluate the feasibility of embedding more secret data. Zhang 
and Wang [8] proposed an exploiting modification direction 
(EMD) hiding method to achieve high embedding quality. The 
EMD technique hide a (2n+1)-ary secret digit for every n 
pixels in the cover image by adding or subtracting one at most 
within one particular pixel in the group, thus the cover pixel is 
slightly modified.  However, the major drawback of EMD is it 
can’t restore the cover image directly. Some modified EMD 
methods have been proposed in [9-11] to enhance the 
embedding capacity because the original EMD has seldom 
considered embedding capacity. Especially, [11] presented two 
novel approaches, the HoEMD and the AdEMD, to achieve 
high efficiency, high quality and large embedding ratios, use 
the module operation and take into account of the sensitive 
nature of a human visual system. The HoEMD approach 
exploits the pixel directions. A pixel with a larger change 
implies more pixel directions and, ultimately, a larger 
embedding capacity. The pixel differencing in the proposed 
AdEMD method is used to evaluate whether the pixel located 
in the edge area can tolerate a larger change than that of the 
pixel location in a smooth area. However, disadvantages of all 
of EMD methods are that have to decide the value of n before 
the hiding process and only concern the k-LSBs embedding. As 
all of the steganography methods in [1-11] have drawbacks as 
previous mentions, lack flexible bit allocation (it means that 
they can’t embed secret data into higher bits than k-LSBs) and 
are not easily implement due to their computational complexity, 
this work proposes a novel multi-bit adaptive three-step (A3S) 
kN−2
evaluate embedding capacity, such that it can be improved. 
*Corresponding author 
However, for 10- and 11-embeddings, after 1  has been 
changed, case 5 (OMSBs = IMSBs - 1 and OLSBs = 1s under 
) (Fig. 4a), case 6 (OMSBs = IMSBs and OLSBs = 
0s under ) (Fig. 4b), or case 7 (OMSBs = IMSBs and 
OLSBs = 1s under ) (Fig. 4c) occurs. 
−iibb
12 −≥ kEB
EB 12 −≥ k
12 −≥ kEB
  
  
Fig. 4. Cover data will be embedded 2-bit secret data into , values 9210, 
8310, 11110, and 10310. 
34bb
 
 
(a)                                              (b) 
 
(c) 
Fig. 5. The 2-bit MER with non-zero errors for 00- and 01-embeddings, (a) 
embedded data 9610 of 9210 with error +4, (b) embedded data 7910 of 8310 with 
error -4, (c) embedded data 10410 of 10310 with error +1. 
 
 
(a)                                              (b) 
 
(c) 
Fig. 6. The 2-bit MER with non-zero errors for 10- and 11-embeddings, (a) 
embedded data 9510 of 10310 with error -8, (b) embedded data 11210 of 11110 
with error +1, (c) embedded data 8710 of  9210 with error -5. 
Here, the problem arises as to how the extended MER 
makes cases 1, 2, 3, 4, 5, 6, and 7 occur.  If one can identify 
some special criteria, decision rules can be developed based on 
these special criteria. Then, one can make the extended MER to 
do cases 1, 2, 3, 4, 5, 6, and 7 according to the decision rules. 
This requirement provided the motivation to develop a new 
embedding algorithm for the extended MER. Moreover, 
operations in cases 1, 2, 3, 4, 5, 6, and 7 from the bitwise 
perspective are very simple and only consist of duplications 
(OMSBs = IMSBs and OLSBs = ILSBs), arithmetic additions 
(OMSBs = IMSBs + 1 and OMSBs = IMSBs - 1), clearing all 
bits to 0 (OLSBs = 0s), and setting all bits to 1 (OLSBs = 1s). 
This shows that the proposed embedding algorithm can be 
implemented very easily using software and even hardware 
approaches. Thus, a novel simple and efficient multi-bit A3S 
embedding algorithm was developed. 
III. THE A3S EMBEDDING ALGORITHM 
Some simple and efficient criteria and decision rules, which 
can be used for MER to generate cases 1, 2, 3, 4, 5, 6, and 7, 
were identified by observations and many MER simulations. 
This section uses these criteria and decision rules to develop 
multi-bit A3S embedding algorithm. This section also 
demonstrates how this algorithm achieves the minimized 
embedding error. In the followings,  denotes the mth 
criterion of the k-bit MER. 
mR
A. Multi-bit A3S Embedding Algorithm 
For k-bit MER, the first criterion is  (EBs == 
 of cover data), that is EBs ==Data, and the first 
decision rule is that if  is true, then case 1 occurs; otherwise 
cases 2, 3, 4, 5, and 6 occur. The following discusses the 
criteria and decision rules under the case when criterion  is 
false. When  is false, the criterion  (
1R
11 +−− kiii bbb L
1R
1R
1R 2R
12 −< kEB
6R
 ) is used, 
and the second decision rule is that if  is true, then execute 
00-/01-embedding; otherwise execute 10-/11-embedding. The 
00- and 01-embedding procedures have the following five 
special criteria:  (any bit of IMSBs is 0),  
( ),  ( ),  (
2R
Data<
3R 4R
1Data≤EB k+ −12 5R EB k+ −12 ==
R
3
4R
9R
0
−kib
5
, 
i.e. ), and R  ( ). The corresponding 
decision rules of 00-/01-embedding are as follows: (1) if all , 
, and  are true, or if  and  are true but  is false 
and  is true,  then case 2  (Fig. 3a) occurs; (2) if R  and 
are true but  and  are false, or if  is true but  is 
false, or if   is false and   is true, then case 3  (Fig. 3b) 
occurs; and, (3) if  both  and  are false, then case 4  (Fig. 
3c) occurs. The criteria and decision rules of 10-/11-embedding 
are listed as follows. The 10-/11-embedding procedure has the 
following five special criteria:  (any bit of IMSBs is 1), : 
( ),  ( ),  (
ki−2
3R
Data
ILSBs ≥
4R 5R
6R
4R 5R
EB k ≥− −12
7 EB <
3R R
7R
3 7R
8R
EB k− −12
Data
4
Data>
3
R
3R
11R
6R
R
10R ==
10
R
8R
1+k
−k
11
−ib
ib
8R 9R
R
9R
1−iibb L
L
), 
and  ( ). The corresponding decision rules of 
10-/11-embedding are as follows: (1) if , , and R  are 
true, or if R  and  are true but R  is false and  is true,  
then case 5 (Fig. 4a) occurs; (2) if  and  are true but  
and  are false, or if R  is true but  is false, or if  is 
false and R  is true, then case 6 (Fig. 4b) occurs; and, (3) if 
both  and  are false, then case 7 (Fig. 4c) occurs. 
12R
11R
8R
i b
Data
9R
1R
1+−ki
EB >
8
12
12R
1R
1−ib L
10
8
9R
ib
R
8
b
10
The previous k-bit MER procedure can be divided into 
three steps: (1) embed secret data EBs into  of 
cover data; (2) adaptively adjust ILSBs to generate OLSBs, and 
(3) adaptively adjust IMSBs to generate OMSBs. Thus, the 
following regular and formalized 2-bit A3S embedding 
algorithm is developed for easy implementation. 
1 Embed secret data (EB) into 11 +−− kii b  of cover data. 
Check . If  is true, then go to step 2-1; otherwise, 
set b  = EBs and go to step 2-2. 
2 Adaptively adjust ILSBs to generate OLSBs. 
2-1 Set OLSBs  =  ILSBs and go to step 3-1. 
2-2 Check 2R . If 2R  is true, then go to step 2-2.1; 
otherwise go to step 2-2.2. 
2-2.1 00-/01-embedding. Check 3R , 4R , 5R , 6R , 
and 7R . 
2-2.1.1 If 3R , 4R , and 5R  are true,  or if 
3R  and 4R  are true but 5R  is false 
and 6R  is true, then set OLSBs = 0s 
and go to step 3-2.  
embedded datum has a value of 11110, which only introduces -1 
embedding error and minimum error embedding is achieved. 
C. Exceptions of Overflow/Underflow Problems in the 
Proposed A3S Algorithms 
In data embedding procedure of other previous works, 
overflow/underflow problems occur since the cover pixels have 
finite bits and when they are near the boundaries 0 or 255. For 
example, embed secret data 0002 into cover data near 255 will 
occur overflow since it could conduct IMSBs will be increased 
one, that is OMSBs = IMSBs+1. Whereas, embed data 1112 
into cover data near 0 will occur underflow because it could 
conduct IMSBs will be decreased one, that is OMSBs = 
IMSBs-1. To overcome overflow/underflow problems, two 
criteria  (any bit of IMSBs is 0) and  (any bit of IMSBs is 
1) have been utilized in our proposed algorithm. For k-kit 
embedding, if secret data value smaller than , i.e. the 
criterion  (  ) is true, then criterion  checks 
overflow possibility of IMSB to decide whether IMSB will be 
increased one or not.  If  is true means IMSBs hasn’t 
overflow possibility, then OMSBs = IMSBs+1 can be executed. 
Once the IMSB has overflow possibility, our proposed 
embedding algorithm will keep IMSB value and then 
adaptively adjust ILSB value based on the criterion  
( ) to achieve minimum embedding error. For 1-bit 
embedding under the situation of IMSB has overflow 
possibility, ILSB will be changed into 1s as OLSB because  
is always true. Meanwhile, if secret data value larger than or 
equals to , i.e. the criterion  is false, then criterion  
checks underflow possibility of IMSB to decide whether IMSB 
will be decreased one or not. If  is true means IMSBs hasn’t 
underflow possibility, then OMSBs = IMSBs-1 can be 
executed. Once the IMSB has underflow possibility, our 
proposed embedding algorithm will keep IMSB value and then 
adaptively adjust ILSB value based on the criterion  
( ) to achieve minimum embedding error. For 1-bit 
embedding under the situation of IMSB has underflow 
possibility, ILSB will be changed into 0s as OLSB because  
is always true. 
3R
R
Data
2
Data
8R
12 −k
R2
−k
12 −< kEB 3
3R
7R
7R
8R
12R
12R
EB <
EB >
1
2R
8R
The above procedures work well in our proposed 
algorithms, thus our embedding scheme never suffers from the 
overflow/underflow problems. Moreover, they co-operate with 
the adaptive adjustment of ILSB to achieve minimum 
embedding error. 
D. Mathematical Expressions of the Proposed A3S 
Algorithms 
In this subsection, we will illustrate the mathematical 
expressions of the proposed A3S algorithms.  The step 1 of the 
proposed A3S algorithms can be expressed as 
⎩⎨
⎧ ≠=
.otherwise,
,f,
Data
DataEBiEB
Data                                                 (2) 
Steps 2 and 3 of the A3S algorithms would be merged for 
easily develop the mathematical expressions. For k-bit 
embedding, the merged result of steps 2 and 3 can be divided 
into five categories ( ), they can be expressed as 
the followings. 
51, ≤≤ lM kl
Case : kM1 DataEB ==  
⎩⎨
⎧
=
=
.
,
IMSBsOMSBs
ILSBsOLSBs
                                                                  (3) 
Case : kM 2 DataEB ≠ & & non-overflow 12 −< kEB
( )( )
⎩⎨
⎧
=
=
⎩⎨
⎧
≥≥++=
<+=
−−
−
.otherwise
,
,1
,2and2,1
or2if,0
1
1
IMSBsOMSBs
sOLSBs
ILSBsDataEBIMSBsOMSBs
DataEBsOLSBs
kik
k
      (4) 
Case : kM 3 DataEB ≠ & & overflow 12 −< kEB
⎩⎨
⎧
=
=
⎩⎨
⎧ <=
=
.otherwise
,
,0
,if
,
,1
IMSBsOMSBs
sOLSBs
DataEB
IMSBsOMSBs
sOLSBs
                                         (5) 
Case : kM 4 DataEB ≠ & & non-underflow 12 −≥ kEB( )( )
⎩⎨
⎧
=
=
⎩⎨
⎧
<≤−−=
>−=
−−
−
.otherwise
,
,0
,2and2,1
or2if,1
1
1
IMSBsOMSBs
sOLSBs
ILSBsDataEBIMSBsOMSBs
DataEBsOLSBs
kik
k
         (6) 
Case : kM 5 DataEB ≠ & & underflow 12 −≥ kEB
⎩⎨
⎧
=
=
⎩⎨
⎧ >=
=
.otherwise
,
,1
,if
,
,0
IMSBsOMSBs
sOLSBs
DataEB
IMSBsOMSBs
sOLSBs
                                          (7) 
For 1-bit ( 1=k ) embedding,  ( ) 
means 
12 −< kEB 12 −≥ kEB
1<EB
EB
 ( ), i.e.  ( ). These facts 
cause 
1≥EB
Data
0 1=EB=EB
≠ & 1−2< kEB  ( & ) 
means 
DataEB ≠ 12 −≥ kEB
0=EB
k >− −12
Datak ≥−12
 ( ),  
( ) is always false (false), and 
 ( ) is always true (true). 
Thus, the mathematical expressions of 1-bit A3S algorithm are 
simpler versions of that of k-bit. 
1=
Data≤
EB
k− −12
Datak <−12EB +
Data
EB
EB
+EB
IV. SIMULATIONS, SECURITY ANALYSIS AND 
PERFORMANCE COMPARISONS 
Many image steganography simulations were conducted to 
test the performances of the proposed multi-bit A3S 
embedding algorithm. 
TABLE 3 
EC AND PSNR OF 24-BIT STEGO-IMAGES FOR THREE SECRET 
IMAGES EMBEDDING (UNIT: dB) 
Cover Image  EC (bits/%) 1/4.2 2/8.3 3/12.5 4/16.7 5/20.8 
Baboon 55.96 52.90 51.14 48.91 47.44 
Barbara 55.90 52.89 51.14 48.94 47.48 
Boat 55.90 52.91 51.15 48.96 47.48 
Goldhill 55.94 52.93 51.17 48.95 47.49 
Jet 55.92 52.91 51.14 48.94 47.47 
Lena 55.91 52.90 51.15 48.94 47.47 
Peppers 55.89 52.89 51.13 48.91 47.45 
Sailboat 55.92 52.91 51.15 48.92 47.45 
Tiffany 55.91 52.91 51.14 48.91 47.44 
Vegetables 55.90 52.90 51.14 48.93 47.45 
Windmill 55.90 52.86 51.13 48.33 47.05 
Zelda 55.90 52.89 51.32 48.92 47.44 
Average 55.91 52.90 51.16 48.88 47.43 
 
TABLE 3 (CONT.) 
EC AND PSNR OF 24-BIT STEGO-IMAGES FOR THREE SECRET 
IMAGES EMBEDDING (UNIT: dB) 
Cover Image  EC (bits/%) 6/25.0 7/29.2 8/33.3 9/37.5 10/41.7
Baboon 46.36 43.59 41.94 40.72 37.78 
Barbara 46.38 43.85 41.80 40.60 37.47 
Boat 46.40 43.29 41.53 40.41 37.11 
Goldhill 46.39 43.36 41.71 40.53 37.25 
Jet 46.38 43.60 41.92 40.71 37.78 
Lena 46.37 43.61 41.93 40.71 37.79 
Peppers 46.38 43.39 41.64 40.50 37.31 
Sailboat 46.37 43.61 41.93 40.72 37.76 
Tiffany 45.98 43.39 41.66 39.80 37.29 
Vegetables 46.37 43.37 41.77 40.56 37.28 
Windmill 45.92 42.47 40.96 39.88 36.17 
Zelda 46.35 43.47 41.85 40.67 37.54 
Average 46.30 43.42 41.72 40.48 37.38 
 
TABLE 3 (CONT.) 
EC AND PSNR OF STEGO-IMAGES FOR THREE SECRET IMAGES 
EMBEDDING (UNIT: dB) 
Cover Image EC (bits/%) 11/45.8 12/50.0 13/54.2 14/58.3 15/62.5
Baboon 36.04 34.78 31.75 30.02 28.75 
Barbara 35.73 34.56 31.29 29.64 28.45 
Boat 35.22 34.18 30.90 29.26 28.16 
Goldhill 35.52 34.37 30.90 29.25 28.11 
Jet 36.05 34.82 31.81 30.03 28.83 
Lena 36.05 34.76 31.77 30.02 28.75 
Peppers 35.46 34.35 31.15 29.44 28.36 
Sailboat 36.00 34.78 31.75 30.01 28.76 
Tiffany 35.59 32.66 30.58 28.84 26.83 
Vegetables 35.65 34.35 31.03 29.40 28.17 
Windmill 34.58 33.60 29.73 27.58 26.53 
Zelda 35.88 34.67 31.34 29.71 28.54 
Average 35.65 34.32 31.17 29.43 28.19 
B. Security Analysis 
The proposed multi-bit A3S algorithms have two excellent 
features to avoid security analysis attacks; one is its minimum 
embedding error feature makes the embedded cover pixels 
similar to the original cover pixels.  The other one is our 
embedding scheme utilized Torus automorphisms. The former 
exerts the LSBs of cover pixel on small change when secret 
data be embedded into high bit location. The later is suitable 
for k-LSB embedding; Torus automorphisms camouflages 
secret images so that the scattered secret images have the 
noise-like features. Before our data embedding, Torus 
automorphisms is used to alter the original secret images to 
obtain the scattered secret images.  The goal of using the 
scattered secret image for embedding is to increase its security 
because the scattered secret image has the noise-like features 
and is imperceptible. The scattered secret images keep same 
histograms as that of the original secret images although the 
scattered secret images have the noise-like features and are 
imperceptible. Actually, Torus automorphisms keeps the pixel 
values of secret images but changes the pixel location to 
obtain the scattered secret images has the noise-like features. 
These two features cause the proposed embedding scheme can 
withstand visual attack using the enhanced LSBs program [13]. 
Fig. 8 shows the visual attack test result of all stego-images in 
our experiments, it give a good examination of the proposed 
steganograpgy system.  
 
 
Fig. 8 The visual-attack-test result of all stego-images. 
 
 
Fig. 9 The Chi-square-test results of images Lena, Sailboat and 
Vegetables for embedding capacity 50%.  
 
Statistical attack of Chi-square analysis [13] is also used to 
demonstrate that the proposed multi-bit A3S embedding 
algorithm can satisfy the security requirements. Three curves 
as displayed in Fig. 9, including the red one (the bottom line in 
the simulation result), the green one (distributed in middle of 
the simulation result), and the blue one (the top line in the 
simulation result), are depicted in the results of the Chi-square 
test. In this analysis, the red curve indicates the outcome of the 
Chi-square test. In general, the red curve is reclined on the line 
of zero when a natural image is used as the test image; in other 
words the object has a high probability of embedding random 
messages if the red curve is close to one. Namely, secret data 
have been embedded in this object. The second output is the 
blue curve, in which each vertical blue line represents 1K 
bytes of embedded data. The third output is the green curve 
that remains around 0.5 if a random message is embedded. 
Figures in are summarized as the undetected results since the 
red curves are close to zero. According to these results, the 
proposed approach is undetected by using Chi-square testing 
as good as in previous studies of EMD, HoEMD and AdEMD. 
 
rjchen  
寄件者: "IS3C 2012" <is3c2012@easychair.org>
收件者: "Rong-Jian Chen" <rjchen@nuu.edu.tw>
傳送日期: 2011年12月10日 下午 01:37
主旨: [!! SPAM] IS3C 2012 notification for paper 233
b頁 1 - 1(B)
2011/12/28
Dear Chen Rong-Jian, 
 
Congratulation! Your paper entitled "Anti-Forensic Steganography Using Multi-bit Minimum 
Error Replacement with Flexible Bit Location" has been accepted for presenting in International 
Symposium on Computer, Consumer and Control 2012. The conference will be held in 
Taichung, Taiwan, on June 4-6, 2012. Please register before January 1, 2012 from the conference 
website (http://is3c2012.ncuteecs.org). 
 
This conference offers a great opportunity for scientists, engineers, and practitioners to present 
the latest research results, ideas, developments, and applications, as well as to facilitate 
interactions between scholars and practitioners. 
 
Your participation in the Conference will certainly benefit from understanding the current trend 
of related research areas. I sincerely wish you enjoy the conference and have a good stay in 
Taichung.  
 
Sincerely, 
 
Prof. Wen-Yuan Chen,  
General Chair 
 
 
----------------------- REVIEW 1 --------------------- 
PAPER: 233 
TITLE: Anti-Forensic Steganography Using Multi-bit Minimum Error Replacement with 
Flexible Bit Location 
AUTHORS: Rong-Jian Chen, Shi-Jinn Horng and Jui-Lin Lai 
 
(1) The text font in the Figures ( Fig 1, 2, 3, and 4) is not clear. The authors should modify for 
the publication. 
(2) The format of references is not consistent.
properties of multi-bit bipolar MEEs to look their features and 
get more understanding. Next, we will develop the MER_FBL 
scheme based on the formulations and the properties of multi-
bit bipolar MEEs. 
A. 4BThe Formulations and Properties of Multi-bit Bipolar 
MEEs 
Consider k-bit ( 1≥k ) secret data should be embedded 
into ( )211 +−− kiii bbb L  of N-bit cover data with data value from 
0 to 121 −=− NG  where i denotes the most-significant bit 
(MSB) location of ( )211 +−− kiii bbb L . We firstly give definitions 
of some notations in the followings: 12 += iiP , 
( )⎥⎥⎤⎢⎢⎡= ∑
−
=
−−1
0
12
k
m
mi
AN ,  12 +−= kiBN , ⎡ ⎤( )122 += − kkiCN , 
( ) ⎟⎟⎠⎞⎜⎜⎝⎛ +−= ∑
−
=
−
−
1
0
12
k
m
miBO , [ ] nnE ki −−= +−− 12 1 , and [ ] nnE i −= ++ 12 ,  
where notation ⎡ ⎤f  means the ceiling of f. Next, the k-bit 
secret data can be divided into two separated groups { } ( )20132 00 xxxxx kk ↔−− L and { } ( )20132 11 xxxxx kk ↔−− L  based 
on the value of 1−kx . Where φ∈x for 1=k ; otherwise, for 
2≥k , x is the binary value of 0132 xxxx kk L−− . The 1’s 
complementary of x is denoted as ( )2121 +−−−= kiii xxxx L . Then, 
the MEE of multi-bit embedding can be expressed as the 
followings 
[ ] [ ][ ]⎪⎩
⎪⎨
⎧
−≤≤
−≤≤
−≤≤
=
+
−
1,
1,
10,0
~00
,
iC
CB
B
ki
PnNnE
NnNnE
Nn
ne , 10 −≤≤ iPn .                         (1) 
[ ] ( )[ ]iBkixki PxNnene %~~ 00,0, −= , 10 −≤≤ iPn .                                  (2) 
[ ] [ ]ixkixki PlelEP %~0,0, = , 10 −≤≤ Gl .                                          (3) 
[ ]
⎩⎨
⎧
−≤≤+−
−+−≤≤=
− 1,
10,00
, GlxNNGBO
xNNGl
lBO
BA
BAx
ki .                                (4) 
[ ] [ ] [ ]lBOlEPle xkixkixki 0,0,0, += , 10 −≤≤ Gl .                                   (5) 
[ ] [ ]lGele xkixki −−−= 10,1, , 10 −≤≤ Gl .                                        (6) 
A special sequence
 
[ ]ne ki00,~  is defined in Eq. (1) and it’s 
right rotation version ( )[ ]iBki PxNne %~00, −  with BxN  steps in the 
range of iP ,  that is [ ]ne xki0,~ , is defined in Eq. (2). Notably both 
[ ]nE−  and [ ]nE+  of [ ]ne ki00,~  are mutually anti-symmetric. 
Either [ ]ne ki00,~  or [ ]ne xki0,~  is the fundamental sequence of the 
periodic sequence [ ]lEP ki00,  or [ ]lEP xki0,  with period iP  which 
have been defined in Eq. (3). We called [ ]lEP xki0, , 
10 −≤≤ Gl as periodic error sequence due to it is periodic 
and is one of major components of MEE. The BO sequence 
of ( )20x  group is denoted as [ ]lBO xki0,  and is defined by Eq. (4). 
It shows that the non-zero value of [ ]lBO xki0,  and its starting 
point depend on the values of both i and k. Moreover, the 
value and the length of non-zero value of [ ]lBO xki0,  increase as 
the values of i and/or k increases. That is, higher embedding 
location and/or more embedding bits will introduce bigger 
magnitude and longer length of BO than those of lower 
embedding location and/or less embedding bits. Eq. (4) also 
shows that there are 12 −k sequences of [ ]lBO xki0,  with the same 
length G in the group ( )20x  but their length of non-zero value 
are different. It is clear that the length of non-zero value of [ ]lBO xki0,  is decreasing with value of BN  as the value of x 
increasing. It also clearly shows non-zero values of [ ]lBO xki0,  
are negative and appears in around of G-1. Eq. (5) means that 
MEE [ ]le xki0,  consists of the periodic error sequence [ ]lEP xki0,  
and the boundary overshoot [ ]lBO xki0, . Eq. (6) shows that MEE 
[ ]le xki1,  is negative and position-reversal of [ ]le xki0, . Because 
[ ]le xki1,  is negative and position-reversal of [ ]le xki0,  therefore it 
can be evaluate from [ ]le xki0,  even if [ ]lBO xki1,  and [ ]ne xki1,~  are 
unknown.  
For detailed illustration, we give an example of MEEs for 
embedding 2-bit (k = 2) secret data into 45bb  (i = 5) of 8-bit 
cover data where Pi = 64, G = 256, 24=AN , 16=BN , 
40=CN , 49−=−BO , [ ] nnE −=− 15  and [ ] nnE −=+ 64 , and 8-
bit cover data has the value 2551210 8 =−=−≤≤ Gl . The 2-
bit secret data can be divided into ( ) { }222 01,000 =x  and ( ) { }222 11,101 =x . Using Eqs. (1), (2), (3), (4) and (5), we have 
[ ]ne x02,5~ , [ ]lEP x02,5 , [ ]lBO x0 2,5 , and [ ]le x0 2,5 , which are shown in 
Figure 1. 
Figure 1 shows all figures of the example of MEE for 
‘0x’-embedding which embeds ‘0x’ into 45bb  of 8-bit cover 
data. Figure 1a shows the figures of fundamental sequences [ ] 10,~02,5 ≤≤ xne x   which are generated from Eqs. (1) and (2). 
Notably, in Figure 1a, it clearly finds that [ ]ne 012,5~  is the right 
rotation of [ ]ne 002,5~  with 16 steps as the expression of Eq. (2). 
Figure 1b displays the figures of periodic error 
sequences [ ] 10,02,5 ≤≤ xlEP x , it is clear that [ ] 10,02,5 ≤≤ xlEP x  are 
periodic version of  [ ] 10,~02,5 ≤≤ xne x  as the expression of Eq. 
(3), in the range from 0 to 255. We also find that [ ]lEP012,5  is 
the right rotation of [ ]lEP002,5  with 16 steps. Figures of 
boundary overshoots
 
[ ] 10,0 2,5 ≤≤ xlBO x  are shown in Figure 1c. 
It clearly shows that there are 24 negative values (-49) appear 
nearby 255 (the maximum value G-1) of cover data for [ ]lBO002,5 , which are given by Eq. (4). Whereas, there are only 
8 negative values (-49) appear nearby 255 of cover data for [ ]lBO012,5 . This fact means that [ ]lBO002,5  is worse than [ ]lBO012,5 . 
The MEEs for embedding 2-bit secret data ‘0x’ into 45bb  of 
8-bit cover data are summarized in Figure 1d. It is clear that 
TABLE 2  Comparisons with other works  
Images Lena/Sailboat 
EC 33.3% 37.5% 45.6% 50% 54.2% 
[1] -/- -/- -/- 32.57/- -/- 
 [2]a -/- -/- -/- 33.10/- -/- 
[3] -/- -/- -/- 34.90/- -/- 
[4] -/- 37.91/37.93 -/- 31.84/31.72 -/- 
[5]-1b -/- 38.16/38.08 -/- 34.38/34.29  
[5]-2c -/- 38.98/38.85 -/- 33.10/33.54 -/- 
Our 41.92/41.92 40.75/40.76 36.00/36.07 34.89/34.76 31.79/31.78 
a. The PSNR value is averaged value of the four PSNR values that were shown in Fig. 13 of [2]. 
b. [5]-1 means HoEMD method. 
c. [5]-2 means AdEMD method. 
C. 8BSecurity Analysis 
Security is a vital concept for developing a data hiding 
scheme, thus a statistical attack of Chi-square analysis [6] is 
used to demonstrate that the proposed multi-bit A3S 
embedding algorithm can satisfy the security requirements. 
Three curves as displayed in Figure 4, including the red one 
(the bottom line in the simulation result), the green one 
(distributed in middle of the simulation result), and the blue 
one (the top line in the simulation result), are depicted in the 
results of the Chi-square test. In this analysis, the red curve 
indicates the outcome of the Chi-square test. In general, the 
red curve is reclined on the line of zero when a natural image 
is used as the test image; in other words the object has a high 
probability of embedding random messages if the red curve is 
close to one. Namely, secret data have been embedded in this 
object. The second output is the blue curve, in which each 
vertical blue line represents 1K bytes of embedded data. The 
third output is the green curve that remains around 0.5 if a 
random message is embedded. Figures in are summarized as 
the undetected results since the red curves are close to zero. 
According to these results, the proposed approach is 
undetected by using Chi-square testing as good as in previous 
studies of EMD, HoEMD and AdEMD. 
 
 
Figure 4. Chi-square tests  of Lena with EC 33.3% and 50%. 
IV. 3BDISCUSSIONS AND CONCLUSIONS 
This work develops a novel multi-bit MER_FBL scheme 
based on the formulations and the properties of MEE for 
hiding data. The proposed multi-bit MER_FBL scheme can 
embed k-bit ( 1≥k ) secret data into cover data only introduce 
minimum embedding error to be restricted to ( ) kik −− −± 212 1 according to the embedding location i. Many 
simulations show that the proposed multi-bit MER_FBL 
scheme performs good embedding quality for steganography 
application. Reasons that we develop the proposed multi-bit 
MER_FBL are (1) to overcome the drawbacks that exist in the 
previous works and (2) to develop the formulations and the 
properties of MEE to determinedly and easily calculate MEEs 
based on the multi-bit logo/secret data and the embedding 
location.  
9BACKNOWLEDGMENT 
The National Science Council of Republic of China under 
the contracts NSC-97-2221-E-239-036-MY3 and NSC-100-
2221-E-239-033 supported this work. 
10BREFERENCES 
[1] Y. K. Lee and L. H. Chen, “High capacity image steganographic 
model,” IEE Proceedings- Vision, Image and Signal Processing, vol. 
147, no. 3, pp. 1–15, June 2000. 
[2] R. Z. Wang, C. F. Lin, and J. C. Lin, “Image hiding by optimal LSB 
substitution and genetic algorithm,” Pattern Recognition, vol. 34, no. 4, 
pp. 671-683, 2001. 
[3] M.H. Lin, Y.C. Hu, C.C. Chang, “Both color and gray scale secret 
images hiding in a color image,” International Journal of Pattern 
Recognition and Artificial Intelligence, vol. 16, no.6, pp. 697–713, 
2002. 
[4] C. F. Lee and H. L. Chen, “A Novel Data Hiding Scheme Based on 
Modulus Function,” Journal of Systems and Software, vol. 83, no. 5, pp. 
832-843, 2010. 
[5] H. M. Sun, C.Y. Weng, C.F. Lee, and C.H. Yang, “Anti-Forensics with 
Steganographic Data Embedding in Digital Images,” IEEE JOURNAL 
ON SELECTED AREAS IN COMMUNICATIONS, Vol. 29, No. 7, pp. 
1392-1403, Aug. 2011. 
[6] Steganography: A Few Tools to Discover Hidden 
Data, HUhttp://www.guillermito2.net/stegano/tools/index.html UH,  accessible 
by Nov.06 2011. 
Multi-bit Minimum Error Replacement with Flexible 
Bit Location for Hiding Data 
 
Rong-Jian Chen*, Yu-Cha Chen, Jui-LinLai 
Department of Electronic Engineering 
 National United University 
Miaoli, Taiwan 
rjchen@nuu.edu.tw 
 
 
Shi-Jinn Horng 
 Department of Computer Science and Information 
Engineering, 
National Taiwan Univ. of Sci. and Tech., 
Taipei, Taiwan 
 horngsj@yahoo.com.tw 
 
Abstract—Multi-bit minimum error replacement (MER) is a 
method that can embed multi-bit logo/secret data into k least-
significant bits (LSBs) of cover data only introduces minimum 
embedding error (MEE). However, k-LSBs MER suffers from 
weak robustness. Moreover, it is unfortunate because no 
literature discusses the formulations and the properties of multi-
bit MEE up to this day. Therefore, this work proposes a novel 
new multi-bit MERs with flexible bit location (multi-bit 
MER_FBL) to overcome the problem of robustness. This work 
also illustrates the formulations and properties of MEEs in the 
multi-bit MER_FBL. The MEE can be easily and determinedly 
evaluated using the proposed formulations and properties. The 
proposed multi-bit MER_FBL embeds and hides multi-bit (k-bit, 
1≥k ) logo/secret data into any adjoining (starting with the ith 
location) k-bit 11 +−− kiii bbb L of cover data only introduces MEE 
in the range of 0 to ( ) kik −−± 212 ; moreover, its flexible bit 
location enhances the embedded robustness as robustness 
increases as embedding location increases. As the proposed 
multi-bit MER_FBL can embed multi-bit logo/secret data into 
any adjoining bits of cover data and has MEE and high 
robustness, this method was applied for the steganographic and 
watermarking applications and achieves good embedding 
quality.  
I. INTRODUCTION 
In information and data hiding, the MER approach is 
typically used to find data as close to the original as possible. 
Generally, if one wants to embed k-bit secret data into N-bit 
( kN ≥ ) cover data, replacing the k-LSBs of cover data will 
introduce fewer errors than replacing any other k bits. In this 
case, the embedding error introduced is from 0 to ( )12 −± k . 
Considering N-bit cover data, kN −2  values whose k-LSBs are 
identical exist in the embedded k bits. To achieve the highest 
quality, should use the most similar data among these kN −2  
values to replace the original. Many LSB-based methods [1-7] 
have been developed to use in steganographic application. Lee 
et al. [1] developed a two-step MER method to find the closest 
data value to minimize the errors. However, LSB-based 
methods [1-7] are not suitable for watermarking because they 
only focus on the k-LSBs of cover data, such that have poor 
robustness. Watermark embedding methods [8-11] have been 
developed to overcome the robustness problem. Lu et al. [8] 
developed a cocktail watermarking scheme. It embeds two 
watermarks, each of them playing complementary roles to 
resist various kinds of attacks. Chen et al. [9] proposed a 
simple and efficient embedding method using pre-determined 
candidates; this method can embed 1-bit logo data into any 
location according to a special threshold. As the threshold 
value increases, the embedding bit number increases. 
Although [9] robustness was efficiently improved, that study 
focused only on 1-bit watermark embedding. As all of 
methods in [1-11] have drawbacks and are not easily 
implement due to their computational complexity, this work 
proposes a novel new multi-bit MER_FBL to embed and hide 
multi-bit (k-bit, 1≥k ) logo/secret data into any adjoining 
(starting with the ith location) k-bit 11 +−− kiii bbb L of cover data. 
The proposed multi-bit MER_FBL only introduces minimized 
embedding error in the range of 0 to ( ) kik −−± 212  by 
embedding k bits and starting at location i. It also 
demonstrates that the flexible bit location enhances the 
algorithm’s robustness as robustness increases as embedding 
location increases. Moreover, this work develops the 
formulations and the properties of MEEs to determinedly 
calculate MEEs based on the multi-bit logo/secret data and the 
embedding location. The remainder of this paper is organized 
as follows. Section II presents the formulations and properties 
of multi-bit bipolar MEEs and the MER_FBL scheme. Section 
III reports simulation results, demonstrating that the proposed 
multi-bit MER_FBL scheme is suitable for watermarking and 
steganographic applications, performance comparisons also 
shown. Finally, section IV gives the discussions and 
conclusions. 
II. THE FORMULATIONS AND PROPERTIES OF MULTI-BIT 
BIPOLAR MEES AND THE MER_FBL SCHEME 
In this section, from the findings of reviewing of MER 
approaches, we firstly develop the formulations and the 
properties of multi-bit bipolar MEEs to look their features and 
get more understanding. Next, we will develop the MER_FBL 
* Corresponding author
[ ] 10,~02,5 ≤≤ xne x   which are generated from Eqs. (1) and (2). 
Notably, in Figure 1a, it clearly finds that [ ]ne 012,5~  is the right 
rotation of [ ]ne 002,5~  with 16 steps as the expression of Eq. (2). 
Figure 1b displays the figures of periodic error 
sequences [ ] 10,02,5 ≤≤ xlEP x , it is clear that [ ] 10,02,5 ≤≤ xlEP x  are 
periodic version of  [ ] 10,~02,5 ≤≤ xne x  as the expression of Eq. 
(3), in the range from 0 to 255. We also find that [ ]lEP012,5  is 
the right rotation of [ ]lEP002,5  with 16 steps. Figures of 
boundary overshoots
 
[ ] 10,0 2,5 ≤≤ xlBO x  are shown in Figure 1c. 
It clearly shows that there are 24 negative values (-49) appear 
nearby 255 (the maximum value G-1) of cover data for [ ]lBO002,5 , which are given by Eq. (4). Whereas, there are only 
8 negative values (-49) appear nearby 255 of cover data for [ ]lBO012,5 . This fact means that [ ]lBO002,5  is worse than [ ]lBO012,5 . 
The MEEs for embedding 2-bit secret data ‘0x’ into 45bb  of 
8-bit cover data are summarized in Figure 1d. It is clear that 
the MEEs are summation of the periodic error sequence and 
the boundary overshoot as Eq. (5). Notably, Figure 1d shows 
that the MEE of ‘00’-embedding is worse than that of ‘01’-
embedding because ‘00’-embedding suffers from worse 
boundary overshoot than ‘01’-embedding. 
 
Figure 2. Illustrations of MEEs [ ] 10,1 2,5 ≤≤ xle x for ‘1x’-
embedding which embeds ‘1x’ into 45bb  of 8-bit cover data.  
Using Eq. (6), we have [ ]le x1 2,5 ,  which are depicted in 
Figure 2. It is clear that the MEEs are summation of the 
periodic error sequence and the boundary overshoot as Eq. 
(6). Notably, Figure 2 shows that the MEE of ‘11’-embedding 
is worse than that of ‘10’-embedding because ‘11’-
embedding suffers from worse boundary overshoot than ‘10’-
embedding. Figures 1 and 2 clearly show that the MEE 
sequences for ‘ x0 ’-embedding and those for ‘ x1 ’-embedding 
are mutually negative and position-reversal in the defined 
domain from 0 to 255. 
B. The MER_FBL scheme 
We have developed the MER_FBL scheme based on the 
formulations and the properties of multi-bit bipolar MEEs as 
in Figure 3. The block of fundamental sequence generator 
firstly generates the fundamental sequences based on Eqs. (1), 
and (2) under the controls of the starting location i, bits of 
cover data N, and k-bit secret data (includes bits of secret data 
k). Next, the periodic error generator produces the periodic 
sequences using the fundamental sequences under the controls 
of the starting location i, bits of cover data N, and k-bit secret 
data (includes bits of secret data k) as the indication of Eq. (3). 
At the same time, boundary overshoot generator yields 
sequences of boundary overshoot based on Eq. (4) under the 
controls of the starting location i, bits of cover data N, and k-
bit secret data (includes bits of secret data k). Then, the MEE 
generator produces the MEE sequences.  Finally, the 
MER_FBL scheme adds the cover data and the MEE data to 
produce the embedded data. 
 
Figure 3. MER_FBL scheme for hiding data. 
III. SIMULATION RESULTS AND PERFORMANCE 
COMPARISONS 
Many simulations of watermarking and steganographic were 
conducted to test the performances of the proposed MER_FBL 
scheme. However, for the space limitation, we only show the 
simulation results and performance comparisons of watermarking in 
here. 
A. Simulation Results of Watermarking 
Note that all cover images are true color and with size 
of 256256× in our simulations. Besides, all logo images are 
size of 128128× . Figures 4a and 4b show the tested cover 
images Lena and Sailboat. Figure 4c shows 1-bit NUU logo 
image and its scattered version. Meanwhile, Figure 4d 
displays 3-bit NUU logo image and its scattered version. In 
the simulations of DWT watermarking, the cover images were 
decomposed as 3-level wavelets, and the scattered logo image 
was embedded into 1st sub-band of the 3-level DWT wavelets. 
    
(a)                             (b)                    (c)            (d) 
Figure 4. Test images, (a) Lena, (b) Sailboat, (c) 1-bit NUU 
logo and scattered version, (d) 3-bit color NUU logo and 
scattered version. 
Figure 5 shows some retracted logo images from 
watermarked Lena and Sailboat images. Figures 5a and 5b are 
retracted from the b0 bit of watermarked Lena and Sailboat 
images; whereas,  Figures 5c and 5d are retracted from the 
b2b1b0 bits of watermarked Lena and Sailboat images. To test 
the robustness of the proposed multi-bit MER_FBL scheme, 
some typical signal processing attacks, such as noise adding, 
filtering, brightness/contrast adjusting, rotation, and 
compression are performed in DWT domain. The 
出席國際學術會議心得報告 
                                                             
計畫編號 NSC 97－2221－E－239－046－MY3 
計畫名稱 具有內容保護及安全能力的 JPSEC 處理器之研製 
出國人員姓名 
服務機關及職稱 
陳榮堅 國立聯合大學電子工程學系副教授 
會議時間地點 2011 年 06 月 30 日~07 月 02 日，韓國首爾 
會議名稱 
The Fifth International Conference on Complex, Intelligent, and Software 
Intensive Systems (CISIS-2011) 
The Fifth International Conference on Innovative Mobile and Internet Services 
in Ubiquitous Computing (IMIS-2011) 
發表論文題目 
CISIS-2011: Novel Multi-bit Watermarking Using Adaptive Embedding 
Algorithms with Minimum Error 
IMIS-2011: Novel Multi-bit and Multi-image Steganography Using Adaptive 
Embedding Algorithms with Minimum Error 
 
一、參加會議經過 
本次會議乃是 CISIS-2011 與 IMIS-2011 合辦，共安排了三場專題演講（交大副校長
林一平教授也應邀發表專題演講），180 篇的論文發表(分成 68 個口頭報告場次，以 4 梯
次的並行場次發表)。出席者均為世界各地網路與行動有關於資訊安全、平行處理及計算
之專家學者，台灣有多位此領域之專家學者為會議議程委員。本人於此會議發表二篇論
文，其中在 CISIS-2011 發表“Novel Multi-bit Watermarking Using Adaptive Embedding 
Algorithms with Minimum Error＂，安排在七月一日上午 11:00~12:30 主題為“CISIS-S9: 
Security and Trusted Computing”的口頭報告場次；於 IMIS-2011 發表“Novel Multi-bit and 
Multi-image Steganography Using Adaptive Embedding Algorithms with Minimum Error＂，
安排在七月一日下午 2:00~3:30 主題為“IMIS-S10: Security, Trust and Privacy”的口頭報
告場次；此兩篇論文皆由本人順利完成發表。 
 
二、與會心得 
本會議為網路與系統安全及平行處理領域之年度大會，每年均會在此會議發表關於
網路與行動有關於資訊安全、平行處理及計算方面最新之研究論文，出席者均為全世界
此領域之專家學者，因此能出席此會議並發表論文，除可提升臺灣在此領域之學術地位
外，亦能藉由與專家學者之討論獲得更新更先進之技術，對於日後引進並提升臺灣此方
面之研究水準非常有幫助，所以期望國科會能多鼓勵國內學者專家參加此一研討會。 
另外，本會議除了設有最佳論文獎外，也鼓勵與會者提出 Workshop 計畫。由本次研
討會及其他多次研討會的經驗，覺得國內學術界應可多利用國際會議提出 Workshop 計畫
展現我們的力量並在國際會議上爭取表現。 
本次會議攜回會議導引手冊及會議論文集 CD 一片，會議導引手冊詳列每個子會議
 Novel Multi-bit Watermarking Using Adaptive Embedding Algorithms with Minimum 
Error 
Rong-Jian Chen and Jui-Lin Lai 
Department of Electronic Engineering, 
 National United University 
Miaoli, Taiwan 
rjchen@nuu.edu.tw, jllai@nuu.edu.tw 
 
Shi-Jinn Horng 
 Department of Computer Science and Information 
Engineering, 
National Taiwan University of Science and Technology 
Taipei, Taiwan 
 horngsj@yahoo.com.tw 
 
 
Abstract— This paper presents the novel multi-bit 
watermarking using adaptive embedding algorithms with 
minimum error. These embedding algorithms can embed 
multi-bit (k-bit, 1≥k ) logo data into cover data only 
introduce minimum embedding errors which are 
restricted to ( ) kik −− −± 212 1  according to the embedding 
location i. To achieve the goal of minimum embedding error, 
we introduced the adaptive embedding algorithms to adaptively 
evaluate the most similar value to replace the original one and 
which can be divided into three steps: (1) embed logo data into 
cover data, (2) adaptively adjust the least-significant bits (LSBs) 
of cover data, and (3) adaptively adjust the maximum-
significant bits (MSBs) of cover data. Thus, we called them as 
adaptive 3-step embedding algorithms. The proposed 
embedding algorithms are not only achieving minimum 
error but also suitable to hardware implementation due to 
they are bitwise and based on logic, arithmetic and bit 
operations. Many simulations show that the proposed 
adaptive 3-step embedding algorithms perform good 
embedding quality for watermarking applications. 
Keywords-  watermarking; minimum-error embedding; robustness 
I.  INTRODUCTION 
In information and data hiding, the minimum-error 
replacement (MER) method is usually used to find the data as 
close to the original one as possible. In general, if we want to 
embed k-bit secret data into N-bit ( kN ≥ ) cover data, then 
replacing the k-LSBs of the cover data will introduce the 
smallest error than replacing any other k bits. In this case, the 
maximum embedding error introduced is ( )12 −± k . 
Considering the N-bit cover data, there are kN−2  values whose 
k-LSBs are identical to the embedded k bits. To achieve the 
highest quality, it should take the most similar data among 
these kN−2  values to replace the original one. Y. K. Lee and L. 
H. Chen proposed a simple MER [1] to search the closest data 
value to reach the aim. However, [1] only focused on the least 
k-LSBs of cover data and it can be used for the steganography 
applications. Some other steganography methods can be seen 
in literatures [15-19]. For watermarking applications, [1] is not 
more suitable because it’s weak robustness. Researchers thus 
developed many watermarking methods [2-14] to overcome 
the problem of robustness. Among these watermarking 
methods, T.S. Chen [2] proposed a simple and efficient MER 
method, it can embed 1-bit logo data into any location 
according to a special threshold; the larger threshold, the 
embedding would be in the higher MSBs. It is based on the 
fact that higher MSB embedding implies stronger robustness. 
Although [2] 1-bit MER method can efficiently improve 
robustness but it only focused on 1-bit watermark embedding. 
This gives us the motivation to develop novel and new multi-
bit embedding algorithms to altogether overcome the 
drawbacks of [1] and [2]. The proposed multi-bit embedding 
algorithms are called adaptive 3-step embedding algorithms 
which can embed multi-bit logo data into any adjacent 
location of cover data to get minimum embedding error. 
Meanwhile, the proposed embedding algorithms can be 
applied to all applications of watermarking include fragile, 
semi-fragile and robust. For robust watermarking, we apply 
the proposed adaptive 3-step embedding algorithms to DWT 
domain to improve its robustness. Noteworthy, the proposed 
adaptive 3-step embedding algorithms are easy for hardware 
implementation due to they are bitwise and consist of simple 
logic, arithmetic and bit-operations. 
In the followings, section II shows the proposed adaptive 
3-step embedding algorithms for embedding logo data. Then, 
section III shows many simulations to illustrate the proposed 
embedding algorithms are suitable to the applications of 
watermarking; performance comparisons also show in this 
section. Finally, section IV gives the discussions and 
conclusions. 
II. ADAPTIVE 3-STEP EMBEDDING ALGORITHMS 
In this section, we shall first investigate how 1-bit 
embedding achieves minimum error and then we will develop 
the corresponding 1-bit adaptive 3-step embedding algorithm. 
Next, we will develop the multi-bit version. We also illustrate 
how these algorithms perform the embedded data with 
minimum embedding error. 
A.    1-bit Bitwise Adaptive 3-step Embedding Algorithms 
 Let we want to embed 1-bit secret data into N-bit cover 
data: 0121 bbbb NN L−−  at ib (the ith bit), then replacing the 1-
bit of the cover data will introduce the maximum embedding 
error i2±  or the minimum embedding error with range from 
0 to 12 −± i . These embedding errors are called as bipolar 
embedding error (BEE) because it has “+” and “-” polarities. 
In the following paragraphs, we will discuss how choose the 
2011 International Conference on Complex, Intelligent, and Software Intensive Systems
978-0-7695-4373-4/11 $26.00 © 2011 IEEE
DOI 10.1109/CISIS.2011.39
211
 2. If ib = 1, then OMSBs = IMSBs, OLSBs = ILSBs, 
and go to step 6. 
3. If ib ≠  1, then set ib = 1 and check whether all bits 
of IMSBs are 0s and 1−ib is 0 or not. 
4. If any bit of IMSBs is 1 and 1−ib is 0, then OMSBs -
= 1, OLSBs = 1s, and go to step 6. 
5. If all bits of IMSBs are 0s or 1−ib is 1, then OMSBs = 
IMSBs, OLSBs  = 0s, and go to step 6. 
6. Stop. 
 
 
(a)                                             (b) 
Figure 5 1-bit A3S embedding algorithms, (a) algorithm for 
embedding EB = 0 into ib , (b) algorithm for embedding EB 
= 1 into ib . 
  
(a)                                             (b) 
Figure 6 Examples for illustrating the procedures of the 
proposed 1-bit A3S embedding algorithms, (a) embedding ‘0’ 
into b3, (b) embedding ‘1’ into b3. 
The proposed 1-bit embedding algorithms can be 
graphically shown in Figure 5. It is worth to mention that the 
proposed 1-bit embedding algorithms can embed 1-bit EB 
into ib  of cover data only introduce minimum BEE with 
range from 12 −− i  to 12 −+ i . Because the proposed 1-bit 
embedding algorithms are induced from 3-step procedure and 
adaptively adjust IMSBs and ILSBs according to the secret 
data and the cover data to achieve the embedded data with 
minimum BEE, we therefore called the proposed 1-bit 
embedding algorithms as the adaptive 3-step (A3S) 
embedding algorithms.  Figure 6 shows examples for 
illustrating the procedures of the proposed A3S embedding 
algorithms. 
The brute force searching algorithm can be used to choose 
the embedded data with minimum BEE for 1-bit secret data 
embedding. Figure 7 shows the minimum BEEs for 
embedding 1-bit secret data into ib  of 8-bit cover data, where 
70 ≤≤ i . Our simulation results show the proposed A3S 
embedding algorithms achieve the embedded data with BEEs 
exactly match with those of Figure 7.  This fact shows that 
the proposed A3S embedding algorithms achieve the 
minimum BEEs as our expectation. Reason that we called 
these A3S embedding algorithms are “bitwise” is that their 
data replacements are based on logic, algebraic, and bit 
operations to achieve minimum error. Therefore, the 
proposed A3S embedding algorithms have the high potential 
for hardware implementation. 
B.   Multi-bit Bitwise Adaptive 3-step Embedding Algorithms 
 
(a) 
 
(b) 
Figure 8 Multi-bit bitwise A3S embedding algorithms for 
embedding k-bit data into 11 +−− kiii bbb L , (a) embedding  
secret data 12 −< k  , (b) embedding  secret data 12 −≥ k . 
The multi-bit bitwise adaptive 3-step embedding 
algorithms are the extension version of the 1-bit bitwise A3S 
embedding algorithms. Let we want to embed k-bit ( 2≥k ) 
secret data into N-bit cover data. If we use the traditional 
213
 III. SIMULATIONS AND PEFORMANCE COMPARISONS 
Many simulations of watermarking were conducted to test the 
performances of the proposed bitwise A3S embedding algorithms.  
A. Simulation Results of watermarking 
A novel multi-bit and invisible watermarking scheme has 
been developed using the proposed multi-bit bitwise A3S 
embedding algorithm which is shown in Figure 11. The 
proposed watermarking scheme belongs to blind due to it 
uses the blind detection algorithm to perform verification of 
the watermark without use of the original logo image. The 
proposed watermarking scheme can perform watermarking in 
spatial and frequency domains which are indicated by 
Selection signals. In spatial domain, when Selection = 002, it 
embeds the scattered logo image into B channel of cover 
image; whereas, when Selection = 012, it embeds the scattered 
logo image into Y channel of cover image. Selection is 
selected as 102 or 112 will ensue the proposed scheme to 
perform watermarking in frequency domain, which embeds 
the scattered logo image into DWT coefficients of cover 
image. Two security keys Secret key _01 and Secret key_02 
are utilized for embedding/detection, Secret key_01 consist of 
k and n which are used to permute the original logo image to 
obtain the scattered logo image using Torus automorphism 
[14].  The goal we used scattered logo image for embedding 
is to increase its security because the scattered logo image has 
the noise-like aspects and is imperceptible. For Secret key_02, 
which consist of three components, namely, bits, bitplane, 
and band_num. In frequency domain, the proposed multi-bit 
bitwise A3S embedding algorithm embeds bits-bit scattered 
logo image into some special bit planes of DWT coefficients 
of cover image, indicated by bitplane, from the band_numth 
middle frequency band. However, in spatial domain, the 
proposed multi-bit bitwise A3S embedding algorithm 
uniformly embed bits-bit scattered logo image into bitplane 
bit planes, thus the band_num is invalid. Secret keys are 
identical and are known to both embedding and detection. In 
summarization, the proposed watermarking scheme can 
perform fragile, semi-fragile and robust watermarking 
according to 12T −−= bitplanebits  which is decided by different 
choices of Selection and Secret key_02 as TABLE I. When 
T=1 means that bits-bit scattered logo image should be 
embedded into the bitplane LSBs of the cover image, and it 
performs weaker robustness. However, when T>1 means that 
bits-bit scattered logo image should be embedded into higher 
bits bits of the cover image from bitplane bit, and it performs 
stronger robustness. 
 
Figure 11 Multi-bit and invisible watermarking scheme 
TABLE I. Functions of the Proposed Watermarking Scheme 
Selection Working domain  
Secret 
key_02 (Ta) 
Functions 
Fb SFc Rd
002 
Spatial 
(B ch.) 
=1 9 
>1  9
012 
Spatial 
(Y ch.) 
=1 9 
>1  9 9
1X2 
Frequency
(DWT) 
=1  9
>1  9 9
a. 12T −−= bitplanebits , b. Fragile, c. Semi-fragile, d. Robust 
  
(a)                            (b)  
                            
(c)                    (d)                     (e)                     (f) 
Figure 12 Test data for various watermarking selections, (a) 
Cover image: Lena (true color, 256¯256), (b) Cover image: 
Sailboat (true color, 256¯256), (c) 1-bit NUU logo 
(monochrome, 128¯128), (d) scattered 1-bit NUU logo, (e) 
3-bit color NUU logo (8 colors, 128¯128), (f) scattered 3-bit 
color NUU logo. 
In the followings, we will show watermarking 
experiments using the proposed multi-bit and invisible 
watermarking scheme. Note that all cover images are true 
color and with size of 256256× . Besides, all logo images are 
size of 128128× . Figure 12 shows the test images, where 
Figures 12a and 12b are Lena and Sailboat cover images. 
Figures 12c and 12d are 1-bit NUU logo image and its 
scattered version. Meanwhile, Figures 12e and 12f are 3-bit 
NUU logo image and its scattered version. Noteworthy, the 
scattered logo images are the original logo images be 
scattered using Torus automorphism with k = 1 and n = 10. In 
the simulations of DWT watermarking, the cover images 
were decomposed as 3-level wavelets, and the scattered logo 
image was embedded from 1st sub-band of the 3-level DWT 
wavelets. For convenience, we used notation ∏−
=
−
1
0
k
m
mib_X to 
express k-bit logo data should be embedded into X channel of 
the cover data from bi bit plane. For examples, B_b0 means 
that 1-bit logo data should be embedded into b0 bit plane of B 
channel of the cover data, Y_b3b2b1 means that 3-bit logo 
data should be embedded into b3b2b1 bit planes of B channel 
of the cover data. 
215
  
(a)            (b)            (c)           (d)            (e)            (f) 
 
(g)            (h)            (i)            (j)            (k)            (l) 
Figure 19 Extracted watermarks under different attacks, (a) 
uniform noise, (b) 33× low-pass filter, (c) 33× high-pass 
filter, (d) brightness +20, (e) brightness -20, (f) contrast +20, 
(g) contrast -20, (h) vertically flip, (i) JPEG compression, CR: 
11.65, (j) JPEG, CR: 19.75, (k) JPEG 2000 compression, CR: 
15 , (l) JPEG 2000 compression, CR: 30. 
B. Performance Comparisons 
The performance comparisons of the proposed multi-bit 
bitwise A3S embedding algorithm with other methods are 
shown in TABLE IV. It shows PSNR values and embedding 
bits (EBs) of watermarking for embedding 1-bit logo image 
into cover images. According to the results shown in TABLE 
IV, performances of the proposed multi-bit A3S embedding 
algorithm are all higher than those of [2- 4] for watermarking . 
TABLE IV.  Comparisons of Watermarkinga 
Image Lena Sailboat 
Robustness
 EBs PSNR EBs PSNR 
[2] 1024 42.18 - - R 
[3] 23377 48.32 25432 48.35 SF 
[4] 16384 37.40 - - R 
Our 16384 48.82 16384 48.64 R 
a. Cover images are size of 512512× for these comparisons. 
IV. DISCUSSIONS AND CONCLUSIONS 
This paper presents the novel multi-bit bitwise A3S 
embedding algorithms for data hiding. These multi-bit bitwise 
A3S embedding algorithms can embed k-bit ( 1≥k ) secret 
data into cover data only introduce minimum embedding error 
to be restricted to ( ) kik −− −± 212 1 according to the embedding 
location i. Many simulations show that the proposed multi-bit 
bitwise A3S embedding algorithms perform good embedding 
quality for watermarking applications. 
Reasons that we develop the proposed multi-bit bitwise 
A3S embedding algorithms are (1) to overcome the drawbacks 
that exist in the previous works and (2) to reduce the 
computation complexity that exists in the previous works for 
easy hardware implementation. Literature [20] gives the 
detailed illustration of hardware implementation of the 
proposed multi-bit bitwise A3S embedding algorithms.  
ACKNOWLEDGMENT 
The National Science Council of Republic of China under 
the contract NSC-97-2221-E-239-036-MY3 supported this 
work. 
REFERENCES 
[1] Y. K. Lee and L. H. Chen, “High capacity image 
steganographic model,” IEE Proceedings- Vision, Image and 
Signal Processing, vol. 147, no. 3, pp. 1–15, June 2000. 
[2] T. S. Chen, J. Chen, and J. G. Chen, “A simple and efficient 
watermarking technique based on JPEG2000 codec,” 
Proceddings of the IEEE ISMSE’03, pp. 80-87, Taichung, 
Taiwan, 10-12 Dec., 2003. 
[3] W. L. Tai, C. M. Yeh, and C. C. Chang, “Revisible data hiding 
of histogram modification of pixel differences,” IEEE Trans on 
Circuitsand Systems for Video Technology, vol. 19, no. 6, pp. 
906-910, June 2009. 
[4] C. M. Kung, S. T. Chao, Y. C. Tu, Y. H. Yan, and C. H. Kung, 
“A Robust Watermarking and Image Authentication Scheme 
used for Digital Content Allication,” Journal of Multimedia, 
vol. 4, no. 3, pp. 112-119, June 2009.  
[5] P. S. Huang, C. S. Chiang, C. P. Chang, and T. M. Tu, "Robust 
spatial watermarking technique for colour images via direct 
saturation adjustment," IEE Proceedings- Vision, Image and 
Signal Processing, vol. 152, no. 5, pp. 561-574, 2005. 
[6] S. Kimpan, A. Lasakul, and S. Chitwong, "Variable block size 
based adaptive watermarking in spatial domain," Proceedings 
of IEEE ISCIT 2004, vol. 1, pp. 374-377, Sapporo, Japan, 26-
29 Oct., 2004. 
[7] H. Ren-Junn, K. Chuan-Ho, and C. Rong-Chi, "Watermark in 
color image," Proceedings of the first International Symposium 
on Cyber Worlds, pp. 225-229, Tokyo, Japan, 6-8 Nov., 2002. 
[8] B. Verma, S. Jain, D. P. Agarwal, and A. Phadikar, "A New 
color image watermarking scheme," Infocomp-Journal of 
computer science, vol. 5, no. 2, pp. 37-42, 2006. 
[9] X. Wu and Z. H. Guan, "A novel digital watermark algorithm 
based on chaotic maps," Physics Letters A, vol. 365, no. 5-6, pp. 
403-406, June 2007. 
[10] L. M. Cheng, L. L. Cheng, C. K. Chan, and K. W. Ng, "Digital 
watermarking based on frequency random position insertion," 
Proceedings of Control, Automation, Robotics and Vision 
Conference, vol. 2, pp. 977-982, Kunming, China, 6-9 Dec., 
2004. 
[11] L. Chun-Shien, H. Shih-Kun, S. Chwen-Jye, and L. Hong-Yuan 
Mark, "Cocktail watermarking for digital image protection," 
IEEE Transactions on Multimedia, vol. 2, pp. 209-224, 2000. 
[12] W. Lu, H. Lu, and F. L. Chung, "Robust digital image 
watermarking based on subsampling," Applied Mathematics 
and Computation, vol. 181, pp. 886-893, 2006. 
[13] A. A. Reddy and B. N. Chatterji, "A new wavelet based logo-
watermarking scheme," Pattern Recognition Letters, vol. 26, pp. 
1019-1027, 2005. 
[14] G. Voyatzis, I. Pitas, “Applications of toral automorphisms in 
image watermarking,” Proceedings of the International 
Conference on Image Processing, vol. 2, pp. 237–240, 
Lausanne, Switzerland, 16-19 Sep., 1996. 
[15] R. Z. Wang, C. F. Lin, and J. C. Lin, “Image hiding by optimal 
LSB substitution and genetic algorithm,” Pattern Recognition, 
vol. 34, no. 4, pp. 671-683, 2001. 
[16] C. C. Chang and H. W. Tseng, “Data hiding in images by 
hybrid LSB substitution,” Proceedings of the IEEE 2009 
International Conference on Multimedia and Ubiquitous 
Engineering, pp. 360-363, Qingdao, china, 4-6 June, 2009. 
[17] Y. H. Yu, C. C. Chang, and I. C. Lin, “A new steganographic 
method for color and grayscale imahe hiding,” Computer 
Vision and Image Understanding, vol. 107, no. 3, pp. 183-194, 
September 2007. 
[18] M.H. Lin, Y.C. Hu, C.C. Chang, “Both color and gray scale 
secret images hiding in a color image,” International Journal of 
217
Novel Multi-bit and Multi-image Steganography Using Adaptive Embedding 
Algorithms with Minimum Error 
Rong-Jian Chen and Jui-Lin Lai 
Department of Electronic Engineering, 
 National United University 
Miaoli, Taiwan, ROC 
rjchen@nuu.edu.tw, jllai@nuu.edu.tw 
Shi-Jinn Horng 
 Department of Computer Science and Information 
Engineering, 
National Taiwan University of Science and Technology 
Taipei, Taiwan, ROC 
 horngsj@yahoo.com.tw 
 
 
Abstract— This paper presents a novel multi-bit and multi-
image steganography system using adaptive embedding 
algorithms with minimum error. These embedding 
algorithms can embed multi-bit (k-bit, 1≥k ) secret data 
into cover data only introduce minimum embedding 
errors which are restricted to ( ) kik −− −± 212 1  according to 
the embedding location i. To achieve the goal of minimum 
embedding error, we introduced the adaptive embedding 
algorithms to adaptively evaluate the most similar value to 
replace the original one and which can be divided into three 
steps: (1) embed logo data into cover data, (2) adaptively adjust 
the least-significant bits (LSBs) of cover data, and (3) adaptively 
adjust the maximum-significant bits (MSBs) of cover data. Thus, 
we called them as adaptive 3-step embedding algorithms. The 
proposed embedding algorithms are not only achieving 
minimum error but also suitable to hardware 
implementation due to they are bitwise and based on logic, 
arithmetic and bit operations. After development of the 
adaptive 3-step embedding algorithms, we then built the 
multi-image steganography system to complicate the 
experiments of steganography. Many simulations show that 
the proposed adaptive 3-step embedding algorithms perform 
good embedding quality for steganography applications. 
Keywords-information hiding; steganographgy; minimum error 
embedding 
I.  INTRODUCTION 
In information and data hiding, the minimum-error 
replacement (MER) method is usually used to find the data as 
close to the original one as possible. In general, if we want to 
embed k-bit secret data into N-bit ( kN ≥ ) cover data, then 
replacing the k-LSBs of the cover data will introduce the 
smallest error than replacing any other k bits. In this case, the 
maximum embedding error introduced is ( )12 −± k . 
Considering the N-bit cover data, there are kN−2  values whose 
k-LSBs are identical to the embedded k bits. To achieve the 
highest quality, it should take the most similar data among 
these kN−2  values to replace the original one. Y. K. Lee and L. 
H. Chen proposed a simple MER [1] to search the closest data 
value to reach the aim. Some other steganography methods 
can be seen in literatures [2-6]. However, all of them only 
focused on the least k-LSBs of cover data and they were 
suffered from weak robustness. Moreover, they are not 
suitable for hardware implementation due to their computation 
complexity. This gives us the motivation to develop novel and 
new multi-bit embedding algorithms to overcome the 
drawbacks of [1-6]. We therefore proposed the novel adaptive 
3-step embedding algorithms which can embed multi-bit 
secret data into any adjacent location of cover data to get 
minimum embedding error. The proposed embedding 
algorithm not only can achieve minimum embedding error but 
also can improve robustness due to the secret data can be 
embedded higher adjacent bits of cover data. Moreover, the 
proposed adaptive 3-step embedding algorithms are easy for 
hardware implementation due to they are bitwise and consist 
of simple logic, arithmetic and bit operations [7].  Noteworthy, 
the proposed adaptive 3-step embedding algorithms can be 
applied to the applications of watermarking [7] include fragile, 
semi-fragile and robust. For robust watermarking, we apply 
the proposed adaptive 3-step embedding algorithms to DWT 
domain to improve its robustness. 
In the followings, section II shows the proposed adaptive 
3-step embedding algorithms for embedding secret data. Then, 
a multi-bit and multi-image steganography system will be 
developed in section III and many simulations will be shown 
to illustrate the proposed adaptive 3-step embedding 
algorithms are suitable for the applications of steganography; 
performance comparisons also show in this section. Finally, 
section IV gives the discussions and conclusions. 
II. ADAPTIVE 3-STEP EMBEDDING ALGORITHMS 
In this section, we shall first investigate how 1-bit 
embedding achieves minimum error and then we will develop 
the corresponding 1-bit adaptive 3-step embedding algorithm. 
Next, we will develop the multi-bit version. We also illustrate 
how these algorithms perform the embedded data with 
minimum embedding error. 
A.    1-bit Bitwise Adaptive 3-step Embedding Algorithms 
Let we want to embed 1-bit secret data into N-bit cover 
data: 0121 bbbb NN L−−  at ib (the ith bit), then replacing the 1-
bit of the cover data will introduce the maximum embedding 
error i2±  or the minimum embedding error with range from 
0 to 12 −± i . These embedding errors are called as bipolar 
embedding error (BEE) because it has “+” and “-” polarities. 
2011 Fifth International Conference on Innovative Mobile and Internet Services in Ubiquitous Computing
978-0-7695-4372-7/11 $26.00 © 2011 IEEE
DOI 10.1109/IMIS.2011.69
25921
4. If any bit of IMSBs is 0 and 1−ib is 1, then 
OMSBs += 1, OLSBs = 0s, and go to step 6. 
5. If all bits of IMSBs are 1s or 1−ib is 0, then 
OMSBs = IMSBs, OLSBs  = 1s, and go to step 6. 
6. Stop. 
z For EB = 1 be embedded into ib  
1. Check whether ib is equal to 1 or not. 
2. If ib = 1, then OMSBs = IMSBs, OLSBs = ILSBs, 
and go to step 6. 
3. If ib ≠  1, then set ib = 1 and check whether all bits 
of IMSBs are 0s and 1−ib is 0 or not. 
4. If any bit of IMSBs is 1 and 1−ib is 0, then OMSBs -
= 1, OLSBs = 1s, and go to step 6. 
5. If all bits of IMSBs are 0s or 1−ib is 1, then OMSBs = 
IMSBs, OLSBs  = 0s, and go to step 6. 
6. Stop. 
 
(a)                                             (b) 
Figure 5 1-bit A3S embedding algorithms, (a) algorithm for 
embedding EB = 0 into ib , (b) algorithm for embedding EB 
= 1 into ib . 
  
(a)                                             (b) 
Figure 6 Examples for illustrating the procedures of the 
proposed 1-bit A3S embedding algorithms, (a) embedding ‘0’ 
into b3, (b) embedding ‘1’ into b3. 
The proposed 1-bit embedding algorithms can be 
graphically shown in Figure 5. It is worth to mention that the 
proposed 1-bit embedding algorithms can embed 1-bit EB 
into ib  of cover data only introduce minimum BEE with 
range from 12 −− i  to 12 −+ i . Because the proposed 1-bit 
embedding algorithms are induced from 3-step procedure and 
adaptively adjust IMSBs and ILSBs according to the secret 
data and the cover data to achieve the embedded data with 
minimum BEE, we therefore called the proposed 1-bit 
embedding algorithms as the adaptive 3-step (A3S) 
embedding algorithms.  Figure 6 shows examples for 
illustrating the procedures of the proposed A3S embedding 
algorithms. 
The brute force searching algorithm can be used to choose 
the embedded data with minimum BEE for 1-bit secret data 
embedding. Figure 7 shows the minimum BEEs for 
embedding 1-bit secret data into ib  of 8-bit cover data where 
70 ≤≤ i . Our simulation results show the proposed A3S 
embedding algorithms achieve the embedded data with BEEs 
exactly match with those of Figure 7.  This fact shows that 
the proposed A3S embedding algorithms achieve the 
minimum BEEs as our expectation. Reason that we called 
these A3S embedding algorithms are “bitwise” is that their 
data replacements are based on logic, algebraic, and bit 
operations to achieve minimum error. Therefore, the 
proposed A3S embedding algorithms have the high potential 
for hardware implementation. 
B.   Multi-bit Bitwise Adaptive 3-step Embedding Algorithms 
The multi-bit bitwise adaptive 3-step embedding 
algorithms are the extension version of the 1-bit bitwise A3S 
embedding algorithms. Let we want to embed k-bit ( 2≥k ) 
secret data into N-bit cover data. If we use the traditional 
XOR embedding method shall introduce maximum 
embedding error with value of ∑−
=
+−±
1
0
122
k
l
lki . However, if we 
use the proposed k-bit bitwise A3S embedding algorithms the 
maximum embedding error shall be restricted to 
( ) kik −−± 212  and it is smaller than ∑−
=
+− 1
0
122
k
l
lki  for all k.  The 
procedure of embedding multi-bit data into 11 +−− kiii bbb L  of 
cover data also can be divided into three steps: (1) embed 
secret data into 11 +−− kiii bbb L  of cover data, (2) adaptively 
adjust ILSBs, and (3) adaptively adjust IMSBs. It is helpful to 
summarize all conditions that we used to develop the multi-
bit bitwise adaptive 3-step embedding algorithms. For 
embedding EBs 12 −< k  into 11 +−− kiii bbb L , we have condition 
1 (SC01): 11 +−− kiii bbb L = EBs, condition 2 (SC02): any bit of 
IMSBs is 0, condition 3 (SC03): 11 +−− kiii bbb L < EBs, 
condition 4 (SC04): 11 +−− kiii bbb L  < EBs + 2k-1, condition 5 
(SC05):  11 +−− kiii bbb L = EBs + 2k-1, and condition 6 (SC06): 
kib − = 0. Whereas, for embedding EBs 
12 −≥ k   into 
11 +−− kiii bbb L , we have condition 1 (LC01): 11 +−− kiii bbb L = 
EBs, condition 2 (LC02): any bit of IMSBs is 1, condition 3 
(LC03): 11 +−− kiii bbb L > EBs, condition 4 (LC04): 
11 +−− kiii bbb L  > EBs - 2k-1, condition 5 (LC05):  
11 +−− kiii bbb L = EBs - 2k-1, and condition 6 (LC06): kib − = 1. 
The corresponding multi-bit bitwise adaptive 3-step 
embedding algorithms are listed in the followings. 
26123
bit 11 +−− kiii bbb L of cover data, the maximum BEE can be 
restricted to ( ) kik −− −± 212 1 . We used the brute force 
searching algorithm to choose the embedded data with 
minimum BEE for k-bit secret data embedding. Figure 10 
shows the minimum BEEs for embedding 2-bit secret data 
into bibi-1 of 8-bit cover data, where 71 ≤≤ i . Our simulation 
results show the proposed multi-bit A3S embedding 
algorithms achieve the embedded data with BEEs exactly 
match with those of Figure 10.  This fact also shows that the 
proposed multi-bit A3S embedding algorithms achieve the 
minimum BEEs as our expectation. 
III. SIMULATIONS AND PEFORMANCE COMPARISONS 
Many simulations of steganography were conducted to test the 
performances of the proposed bitwise A3S embedding algorithms.  
A. Multi-image Steganography System and It’s Simulation 
Results 
 
Figure 11 Scheme of the multi-image steganography system 
We firstly developed a novel multi-image steganography 
system using the proposed multi-bit bitwise A3S embedding 
algorithm for hiding 3 secret images to complicate the 
experiments of steganography, which is shown in Figure 11. In 
the steganography experiments, all cover images are 24-bit true 
color and of size 256256× , three of cover images are shown 
in Figure 12. Meanwhile, all secret images are index color with 
2-, 3-, 4-, 5-, and 6-bit versions and with size of NN ×  
( 256≤N ).  Figure 13 shows six of secret images which have been 
divided into two groups: Group_1 and Group_2, where Group_1 
consists of Figs. 13a, 13b, and 13c, the other group (Group_2) 
contains Figs. 13c, 13d, and 13e. In the embedding procedure, we 
firstly choose 3 secret images of Group_1 or Group_2 with 
any different n-bit version. Next, these 3 secret images will be 
scattered using Torus automorphism [8] according to the Secret 
Key 01~03. Reason that we used Torus automorphism to scatter 
the secret images is to increase its security. Then, the 
Allocation mechanics shall give pixels of the scattered secret 
images a flexible location arrangement according to the size of 
secret images and the Secret Key 04~06. Noteworthy, 
Allocation mechanics will flexibly indicate A3S embedding 
algorithm to embed pixels of the scattered secret images into a 
suitable location of the cover image.  After location 
arrangement, the scattered secret images should be are 
separately embedded into B-channel, G-channel, and R-
channel of the cover image, using the proposed multi-bit 
bitwise A3S embedding algorithm. Due to multi-bit secret 
image data can be embedded into any adjacent bits of the 
cover image, we thus use Secret Key 07~09 and Secret Key 
10~12 to indicate how many bits will be hiding and the start 
bit from which the secret image data will be embedded. 
   
Figure 12 Three cover images, (a) Lena, (b) Sailboat, (c) 
Vegetables. 
   
 (a)                            (b)                           (c) 
   
(d)                            (e)                           (f) 
Figure 13 Secret images, (a) NUU logo 01, (b) NUU logo 02, 
(c) NUU logo 03, (d) Baboon, (e) Jet, and (f) Peppers. 
Various hiding methods were used in the proposed multi-bit 
and multi-image steganography system. In general, the 
notation Bn1Gn2Rn3 was used to denote the hiding method. 
For example, B3G4R3 hiding method means that 3 secret 
images with 3-bit, 4-bit, and 3-bit versions should be 
embedded into B, G, R channels of cover image, respectively. 
Figures 14, 15, and 16 show many stego-images with different 
PSNRs and embedding capacities (CEs). PSNR (dB) vs 
embedding capacity (%) of stego-images, which were 
26325
shown in TABLE I, performances of the proposed multi-bit 
and multi-image steganography system include embedding 
capacity and quality of stego-image are better than those of [1-
6]. Noteworthy, the proposed multi-bit and multi-image 
steganography system achieves outstanding quality of stego-
image and lossless secret images retrieval even if it is in very 
high embedding capacity. 
TABLE I.  Comparisons  
Image Lena/Sailboat Retrieved 
Images EC 33.3% 38.3% 45.6% 50% 
[1] -/- -/- -/- 32.57/- lossless 
[2]a -/- -/- -/- 33.10/- lossless 
[3] -/- -/- -/- 34.90/- lossless 
[4] 
41.87/ 
41.87 
-/- -/- -/- lossc 
[5] 
39.17/ 
39.18 
-/- -/- -/- lossless 
[6]b -/- -/- 
33.02/ 
33.25 
-/30.65 lossless 
Our 
41.92/ 
41.92 
40.71/ 
40.72 
36.00/ 
36.07 
34.91/ 
34.93 
lossless 
a. The PSNR value is averaged value of the four PSNR values 
that were shown in Figure 13 of [2]. 
b. The PSNR value is averaged value of the PSNR values of R, 
G, and B channels that were shown in Tables 1 and 2 of [6]. 
c. Table 2 of [4] shows that the PSNR values of the retrieved 
secret images are from 30.788 dB to 35.823 dB. It means 
that the retrieved secret images are loss. 
IV. DISCUSSIONS AND CONCLUSIONS 
This paper presents the novel multi-bit bitwise A3S 
embedding algorithms for data hiding. These multi-bit bitwise 
A3S embedding algorithms can embed k-bit ( 1≥k ) secret 
data into cover data only introduce minimum embedding error 
to be restricted to ( ) kik −− −± 212 1 according to the embedding 
location i. Many simulations show that the proposed multi-bit 
bitwise A3S embedding algorithms perform good embedding 
quality for steganography. 
Reasons that we develop the proposed multi-bit bitwise 
A3S embedding algorithms are (1) to overcome the drawbacks 
that exist in the previous works and (2) to reduce the 
computation complexity that exists in the previous works for 
easy hardware implementation. Literature [7] gives the 
detailed illustration of hardware implementation of the 
proposed multi-bit bitwise A3S embedding algorithms.  
ACKNOWLEDGMENT 
The National Science Council of Republic of China under 
the contract NSC-97-2221-E-239-036-MY3 supported this 
work. 
REFERENCES 
[1] Y. K. Lee and L. H. Chen, “High capacity image 
steganographic model,” IEE Proceedings- Vision, Image and 
Signal Processing, vol. 147, no. 3, pp. 1–15, June 2000. 
[2] R. Z. Wang, C. F. Lin, and J. C. Lin, “Image hiding by optimal 
LSB substitution and genetic algorithm,” Pattern Recognition, 
vol. 34, no. 4, pp. 671-683, 2001. 
[3] C. C. Chang and H. W. Tseng, “Data hiding in images by 
hybrid LSB substitution,” Proceedings of the IEEE 2009 
International Conference on Multimedia and Ubiquitous 
Engineering, pp. 360-363, Qingdao, china, 4-6 June, 2009. 
[4] Y. H. Yu, C. C. Chang, and I. C. Lin, “A new steganographic 
method for color and grayscale imahe hiding,” Computer 
Vision and Image Understanding, vol. 107, no. 3, pp. 183-194, 
September 2007. 
[5] M.H. Lin, Y.C. Hu, C.C. Chang, “Both color and gray scale 
secret images hiding in a color image,” International Journal of 
Pattern Recognition and Artificial Intelligence, vol. 16, no.6, 
pp. 697–713, 2002. 
[6] J. S. Kang, Y. You, and M. Y. Sung, “Steganography using 
block-based adaptive threshold,” Proceedings of the IEEE 2007 
International Symposium on Computer and Information 
Science, pp. 1-7,  Ankara, Turkey, 7-9 Nov., 2007. 
[7] Y. C. Peng, “Hardware implementation of watermarking using 
minimum error embedding algorithms,” Master Thesis, National United 
University, Taiwan, June 2010. 
[8] G. Voyatzis, I. Pitas, “Applications of toral automorphisms in 
image watermarking,” Proceedings of the International 
Conference on Image Processing, vol. 2, pp. 237–240, 
Lausanne, Switzerland, 16-19 Sep., 1996. 
26527
國科會補助計畫衍生研發成果推廣資料表
日期:2011/09/11
國科會補助計畫
計畫名稱: 具有內容保護及安全能力的JPSEC處理器之研製
計畫主持人: 陳榮堅
計畫編號: 97-2221-E-239-036-MY3 學門領域: 積體電路及系統設計
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
論文’Novel Stream Cipher Using 2-D Hybrid CA and Variable Ordered 
Recursive CA Substitutions,’ in Proceedings of IFIP International 
Conference on Network and Parallel Computing (NPC 2008), pp. 74-81, 
Shanghai, China, 18-21 October, 2008 (EI)發表時，很受聽講者的重視，因
此獲邀請整理成期刊論文轉投 Journal of Networks Special Issue on Recent 
Advances in Network and Parallel Computing。 
論文’Architecture Design of High Efficient and Non-memory AES Crypto 
Core for WPAN,’ in Proceedings of 3rd International Conference of 
Networks and Systems Security (NSS 2009), pp. 36-43, Gold Coast, 
Australia, 19-21 October, 2009 (EI)被選為 NSS2009 最佳論文，因此獲邀請
整 理 成 期 刊 論 文 轉 投 Concurrency and Computation: Practice and 
Experience。 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
