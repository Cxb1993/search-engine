1I. INTRODUCTION
  [2] [9] [21] [46] has been proposed to disseminate data items from an information
system to mobile clients. More specifically, a server periodically disseminates data items to the interested
mobile users through single or multiple channels. Data broadcasting generates the broadcast program
based on historical access statistics and is useful for certain applications (e.g., a small set of data items
with stable access patterns). In many real applications, the queried data items are correlated, dependent,
or sequential [10] [21] [36], and they are called dependent data items. For instance, a mobile user issues
a query to check the stock prices of Google, Microsoft, and Intel at the same time, and the dependency
of the data items is described as a set of queried data items. Moreover, in the  environment,
the access patterns of user queries change with time in real scenarios [25] [26] [41]. For example, the
frequencies of queries for the traffic information increase drastically during rush hours and decrease after
that. Therefore, it is imperative for mobile users to retrieve the queries of dependent data items in the
dynamic environment.
In this paper, we propose a new data broadcasting model by using network coding, which enables
multiples data items to be encoded in each time slot, to improve the access time. Traditional network
coding has been regarded as a promising mechanism to improve throughput [3] [13] [14] [15]. Previous
works show that network coding can utilize the available network bandwidth efficiently for multicast
communications. Instead of simply forwarding data items, an intermediate node encodes all input packets
into one output packet, where each encoded packet is the linear combination of the original input packets.
In this paper, we first show that directly applying traditional network coding to data broadcasting can
enable each time slot to serve more users and thereby reduce the access time1. Traditional network coding
encodes all data items to serve the maximal number of users using their storage to lessen the access time.
For example, consider an example with a server  three data items 1 2 3 and five clients 1 2, 3,
4 and 5. The users 1 2, 3, 4 and 5 storing data items 1 2 2 2, and 1, require 2 3 1
3 and 2 respectively as depicted in Fig. 1(a). When the server  broadcasts 1+2+3 1+22+3
and 1+2+23 instead of 1 2 and 3, the total access time of all clients is reduced from 11 to 10 as
illustrated in Fig. 1(b) and in Fig. 1(c), where the + sign here denotes a bitwise exclusive OR operation
in the linear combination. Note that encoding data 1 + 2 + 3 1 + 22 + 3 and 1 + 2 + 23 are
linearly independent, and the server also broadcasts the coefficient for each encoding data. Since all users
store a data item, they need two distinct encoding data (i.e., two independent equations) to derive their
requested data items. Consequently, the above example indicates that the traditional network coding can
reduce the access time to serve more users as compared to the traditional data broadcast. However, the
access time in data broadcasting with traditional network coding is not minimized because encoding all
1In this paper, we evaluate the performance of the broadcast program with the access time, where the access time is the time elapsing
from the moment a client issues a query to the moment that all queried data items are decoded.
3the above examples indicates that leveraging the stored data items can avoid the redundant encoding in
each time slot and further reduce the access time.
In this paper, we consider the  -  . Given a set of
queried data items and stored data items in each users, this problem is to choose the set of data items to
be encoded for each channel at each time slot to minimize the average access time. When time goes on,
the problem is to select the data items to be encoded to adapt to the changes of the access patterns of
user queries to minimize the average access time. The constraint is that every mobile user must be able
to obtain the required data items by decoding the data items in some time slots by using the stored data
items. To the best of our knowledge, there is no previous work on dynamically generating the broadcast
program with the network coding in multiple channels. Besides, the traditional data broadcasting problem
considers only the data scheduling and the channel allocation, while we also need to choose the set of
data items to be encoded and to adapt to the dynamic requirements of users. Hence, according to the
above problem, the traditional data broadcasting is a special case of our approach.
In this paper, we propose a Dynamically Demand-Oriented Pairing (DDOP) algorithm to solve the
above problem. First of all, DDOP selects the data items to be encoded for each channel at each time
slot such that the encoded items can satisfy the maximal number of mobile users to minimize the access
time. The selection of data items is based on   and  . Note that the
data selection is to find the data items to be encoded, and the maximal demanding is the maximal number
of demanding users for the encoding data. A demanding user for an encoding data means that the user
can decode the encoding data and then receives the queried data item from the decoded data. To adapt to
the changes of user requirements with time, DDOP dynamically adjusts the existing broadcast program
according to the changes of the queries in the users. Note that the users change their queries after they
received all queried data items last time. We conduct several experiments for various scenarios, and the
results show that DDOP leads to smaller access time as compared to the traditional data broadcasting.
The rest of this paper is organized as follows. The related works are given in Section II and preliminaries
are in Section III. In Section IV, we develop an algorithm DDOP to generate a broadcast program. The
experimental results are presented in Section V. Finally, this paper concludes with Section VI.
II. RELATED WORKS
A. Data Broadcast
Data broadcasting is a well-known mechanism to disseminate the data items from an information system
to the mobile clients. To provide better services for the mobile clients, a significant amount of research
efforts has been focused on developing hybrid data broadcasting [1] [20] [24], on-demand broadcast [2] [4]
[22], and data broadcasting [2] [21] [46]. Due to the limited power and bandwidth, several research results
are developed to conserve the energy and the communication bandwidth such as mobile data dissemination
5the dependent data broadcasting supports heterogeneous applications in the wireless mobile environment.
B. Network Coding
In the information relay environment, the nodes repeatedly forward the information to destined nodes,
and network coding has been shown as a promising mechanism to improve throughput [3] [13] [14] [15].
In [39], the authors show that the network coding can utilize the available network bandwidth efficiently
for multicast communications. Instead of simply forwarding data items, intermediate node encodes several
input packets into one output packet, where each encoded packet is the linear combination of the original
input packets. In contrast to the traditional schemes, the network coding efficiently utilizes the available
network resources and it increases network efficacy with minimal computational power.
We describe the network coding with several mathematical concepts as follows. We assume that  is
the number of packets 1 2 ..., and  that are created by one or several sources. With  
 [39], each packet is the linear combinations of the data items with a sequence of coefficients 1
2 ..., and  in a field size 2 (i.e., if  = 1  =0 or 1) A field contains only finitely many elements.
The field size is formed with , where  is a prime number called the characteristic of the field, and
 is a positive integer. For example, there is a field size 21 with 2 elements 0 or 1. Therefore, we can
obtain a linear equation  (i.e.,  = P=1 ) For the -th symbol of  and ,  is P=1  For
instance, given one bit symbol, the field size is 2 (i.e., 0 or 1) such that the operation + becomes addition
in the field 2 like xor or modular 2. We define the coefficients 1 2   as   and 
is   [14]. Moreover, we assume that a node retrieves sets {1 1}, ..., { }. To
decode the original packets, a node has to resolve the linear equation  (i.e.,  = P=1 ) where
the unknown variables are  This linear equation has  equations and  unknown variables. If  is
larger than  and  equations of those equations are linearly independent we can recover original data
items. That is, the number of retrieved packets has to at least larger than the number of original packets,
otherwise there are several linearly dependent equations. On the other hand,    [18]
addresses the problem of randomly selecting code coefficients from some finite fields with an independent
and the decentralized property. More precisely, it can select the linearly independent combinations of data
items with the code coefficients. However, in light of the simulation [44], the probability for selecting
the linearly dependent combinations of data items can be ignored even in small field sizes. Besides, the
deterministic algorithm [31] is developed to determine the linear combinations for each node. Each node
adopts the fixed linear coefficients such that the packets only convey the information vector. Hence, the
network coding can significantly minimize the access time and the bandwidth consumption by merely
solving linear equations.
7Moreover, each user in our approach is allowed to receive multiple data items, instead of a single one,
to solve the equation set and obtain the required data item, and a new challenge arises because we consider
the multi-channel data broadcast. In this case, the server needs to generate a broadcast program for each
channel, and any two items belonging to the same equation set but delivered in different channels cannot
reside in the same time slot. Therefore, the problem considered in this paper is more complicated. We
summary the contributions of DDOP as follows.
· We leverage the concept of network coding and show that the access time can be effectively reduced
with the proposed algorithm in application-layer data broadcast.
· Different from network coding for wireless broadcast, this paper focuses on the application-layer data
broadcast. We show that the system architectures and the objective functions are different. Coding in
application-layer broadcast is more complicated because each user can solve the required data item from
multiple broadcasted data items. In addition, the multi-channel broadcast environment is considered in
this paper.
· The proposed algorithm DDOP generates a set of the encoding data items by maximizing the number
of users with their requests satisfied in less time. Our algorithm generates the set of encoding data for
multi-channel data broadcast at each time slot, and each user is able to utilize multiple encoding data
items to obtain the required data item.
· After a server starts broadcasting encoding data, our algorithm can adapt to new users by adjusting
the existing broadcast program. Therefore, our algorithm can mitigate the workload on the server because
the server does not need to regenerate the whole broadcast program.
C. Derivation of Access Time
In this paper, we minimize the average access time of all users by using network coding. The access
time of a user is the time elapsing from the moment that the user issues a query to the moment that
all queried data items are decoded. Table I summarizes the notations in this paper. Specifically, given a
broadcast program  , for user  that stores a set of data items  and queries a set of data items ,
where 1≤  ≤  and  is the number of users in the system, we derive the average access time as
follows.
Definition 1 (Waiting Cycle) : Let  denote the number of broadcast cycles that mobile user 
collects the encoded data to decode the queried data items in , where  ≥ 0 and 1≤  ≤ .
Definition 2 (Residual Time): Let Residual Time () denote the number of time slots required by user
 to collect the encoding data for the remaining queried data items in  after  broadcast cycles
pass, where 1≤  ≤ .
We explain the above definitions with an example as follows.
Example 1: Consider the broadcast program in Fig. 2, where the number of channels  is 2. Assume that
9TABLE I
NOTATIONS OF THIS PAPER.
Description Symbol
Data size 
Bandwidth of broadcast channel 
Number of the broadcast channels 
Set of query data items issued by user  
Set of stored data items in user  
Set of encoding data subsets at time slot  
The -th encoding data subset in  
Database of broadcast data items 
Number of users 
The -th data item in  
Number of queries 
Set of user members demanding  ()
Number of broadcast data items in  
Number of time slots in a broadcast cycle 
Residual time in user  
User  
maximize the number of demanding users. Afterward, in the adaptive encoding phase, if any user changes
the queried data items, DDOP adjusts the existing codes according to the new queried and stored data
items.
Specifically, our algorithm determines the set of encoding data to maximize the number of union
demanding users, where union-demanding users are the demanding users at a time slot of any channel.
DDOP includes two phases to find  bi-codes to maximize the number of union-demanding users. In the
first phase, DDOP finds top  bi-codes of the maximal number of users. In the second phase, DDOP
refines the above  bi-codes by repeatedly replacing any one of  bi-codes with another bi-code to
maximize the number of the union-demanding users. Afterward, DDOP extends these bi-codes into multi-
codes by considering more stored data items in each user to increase the number of the demanding users
at the time slot. Additionally, our encoding algorithm considers that each encoding data set at each time
slot changes with time since each user requirement changes with time. In other words, after the server
is starting broadcasting encoding data, our algorithm needs to consider the changes of the states of the
user requirements to determine the set of encoding data for next time slot. The basic concept is to modify
the existing encoding data rather than restarting a new process to generate encoding data during the
changes of the states of user storage and requirements. To adjust the existing broadcast program, we store
the processed encoding data and their demanding users in a table at each time slot in the prior phases.
Therefore, our algorithm merely updates the tables rather than rebuilds the tables to obtain the encoding
data set for each channel.
The encoding and decoding algorithms in DDOP are simple but more efficient and more useful as
compared with traditional algorithms. Specifically, conventional algorithms find out the optimal data to
encode over large search space resulting in large delay in practice. For high-speed application such as video
11
bi-codes. Therefore, DDOP can effectively and efficiently find encoding data for each channel to serve
maximal users to reduce average waiting time at each time slot. Our algorithm is as follows.
Algorithm DDOP( ):
1. Let  ←Demanding-table Creation();
2. Let ←Bi-coding Graph( );
3. Let ← 1;
4. while (| | 6= 0)
5. Let  ← ∅;
6. Let  ←Bi-coding( );
7. Let  ← argmax
1≤≤||
{||};
8. if (| | 6= ||)
9. Let  ←Multi-coding( );
10. Let  ←  + {};
11.  ←Demanding-table Updating();
12.  ←User Updating();
13. ++;
14.  ←RefineProgram( )
15. for (each query-changing user  1 ≤  ≤ )
16. Let  ←  + {};
17. Let ← 1;
18. while (| | 6= 0)
19. Let  ←Adjustment(,  );
20.  ←User Updating();
21. ++;
22.  ←RefineProgram( )
23. return 
end
In the following, we specifically explain the details of DDOP.
a) Bi-code Generation: For minimizing the access time, DDOP first selects and encodes two distinct
data items into a bi-code for each channel at each time slot  such that the number of the union-demanding
users is maximized. In the bi-code generation, DDOP includes two phases to find  bi-codes to maximize
the number of union-demanding users. In the first phase, DDOP finds  initial bi-codes. In the second
phase, DDOP refines the above  bi-codes by repeatedly replacing any one of  bi-codes with another
bi-code to maximize the number of the union-demanding users. The details are as follows.
Given the queried and stored data items of each user, Procedure -  first
constructs a demanding table  that lists each bi-code and its demanding users. Note that  in
table  stores the -th encoding data subset of encoding data items, and  records its demanding
users. Specifically, for each bi-code, step 2 of Procedure -  randomly selects
13
(b) A demanding table at time slot 1.(a) Queried and stored profiles
DT.Ui
u2
0
0
u1,u2,u6,u7,u12
DT.Ei
{d1,d2}
{d1,d3}
{d1,d4}
{d1,d5}
{d1,d6}
{d2,d3}
{d2,d4}
{d2,d5}
u1,u6,u7
u8,u10
u4,u9,u10,u11
u3,u5
u1,u2,u3,u6,u7,u9
{d2,d6}
{d3,d4}
{d3,d5}
{d3,d6}
{d4,d5}
{d4,d6}
{d5,d6}
u3,u4
u2,u4,u5
u3,u4,u8,u9,u10
u8,u9,u11
u1,u3,u5,u6,u7
u3,u8,u11
i
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
{d3,d5} {d1,d6}
{d2,d4} {d3,d6}
{d2,d3,d4}
{d4,d6} {d2,d5}
{d5,d6}
{d4,d6}
{d3,d4,d6}
{d2,d3,d6}
{d5}{d2,d3,d6}
{d5,d6}
{d2,d3}
{d4}
{d1,d3}
{d1,d3} {d5,d6}
{d1,d3} {d5,d6}
Storage Query
{d2}
{d1} {d5}
u2
u8
u4
u3
u5
u9
u11
u6
u1
u7
User
u10
u12
Fig. 3. Running example of generating a demanding table at time slot 1.
complexity due to a large amount of unnecessary combinations. Instead, DDOP includes two phases to
find the bi-codes by using Procedure -. In the first phase, DDOP finds  initial bi-codes in steps
1-7 of Procedure -. In the second phase, DDOP refines the  bi-codes by repeatedly replacing
any one of  bi-codes with another bi-code to maximize the number of the union-demanding users as
shown in steps 8-15 of Procedure -. The details are as follows.
To maximize the number of the union-demanding users, Procedure - groups  encoding data
from  . For each bi-code, steps 1-7 of Procedure - merge a bi-code into an encoding data set
to maximize the number of the union-demanding users until the number of bi-codes in the encoding data
set reaches . Specifically, step 3 of Procedure - first finds bi-code  among all bi-codes
in  to maximize the number of the demanding users. Next, step 7 of Procedure - stores
bi-code  as 1 in , where  collects  bi-codes to be broadcasted at time slot , and  is
the -th encoding data in . Note that a server mixes the data items in  with the XOR operator and
then broadcasts this encoding data. Also, step 7 of Procedure - records the demanding users of
bi-code 1 in set  Afterward, Procedure - uses this bi-code to find another bi-code 
among all bi-codes in  to maximize the number of union-demanding users of 1 and . Next,
step 7 of Procedure - stores the bi-code  as 2 in  and records the union-demanding
users of bi-codes 1 and 2 in set  Procedure - iterates the above steps to find other
bi-codes until the number of the bi-codes in  reaches . Note that whether the number of union-
demanding users of any encoding data set is maximized or not, steps 4-6 of Procedure - store
each set of  encoding data and its union-demanding users in  at time slot  for the later adaptive
encoding phase. Specifically, when || reaches −1 for each element  in table  steps 5 and 6 of
15
operation (i.e., |
[
∈0
()|  |
[
∈
()|). Procedure - does not adopt more than
two bi-codes to be replaced since the operation of replacing more than two items leads to much higher
complexity. Therefore, DDOP can find the maximal union-demanding users of an encoding data set with
the effective refining operation.
The time complexity of this replacing operation is (2). This is because for each iteration, steps
8-15 of Procedure - find one of  encoding data to be replaced with another encoding data
among (2−) bi-codes. This replacing phase dominates the overall complexity of Procedure -
The complexity of a brute-force algorithm is (2 ) since it takes into account all possible groups of
 encoding data among 2 As compared to the brute-force algorithm, our algorithm can efficiently find
encoding data to maximize the number of demanding users. The algorithmic form of Procedure -
is outlined as follows.
Procedure Bi-coding( )
1. Let  ← ∅;
2. for (each  1 ≤  ≤ )
3. Let  ← argmax
1≤≤| |
{| ∪|};
4. if (||= − 1)
5. for (each  1 ≤  ≤ | |)
6. Let  ←  + and  ←  ∪;
7. Let  ← ,  ←  + {} and  ←  ∪;
8. for (each  2 ≤  ≤ + 1)
9. if (|| 6= )
10. Randomly select bi-code  in  and let 0 ← ;
11. if ( ∈  0)
12. Let ← argmax
1≤≤
{| [
[
∈0  6=
()] ∪()|}
13. Let 0 ← 0 − {}+ {}  ← 0 and  ←
[
∈0
();
14. if (|
[
∈
()| |
[
∈0
()|);
15. Let  ← 0 and  ←
[
∈0
();
16. return 
end
Example 3: Continuing with Example 2, we assume that the number of channels is 2. In the first phase,
DDOP finds two bi-codes to maximize the number of the union-demanding users as follows. DDOP first
finds bi-code 12 ({3 6}) with the maximal number of the demanding users in  as shown in
Fig. 3(b). Next, DDOP stores {3 6} as 11 in 1 at time slot 1. Also, DDOP records the demanding
users of bi-code 11 (i.e., (11) = {1 2 3 6 7 9}) in set . Afterward, DDOP uses this
17
other encoding data sets at time slot 1 as shown in Fig. 4. ¥
b) Multi-code Generation: If bi-code set  cannot satisfy all users at time slot , DDOP includes
additional data items in  as multi-codes to further increase the number of the union-demanding users
For each encoding data in , Procedure - is able to add more than one data item to the
encoding data, and this procedure terminates until the number is maximal.
Specifically, step 5 of Procedure - first stores bi-code set  in 0 for recording the
previous status, where  is the number of previous records in . Next, for each encoding data 0
in 0 (1≤  ≤ ) step 7 of Procedure - adds the -th (3≤  ≤ ) data item  to 0
in 0 as , where  is selected from the queried data items that have not been encoded in , and
 is the number of data items. Note that step 9 of Procedure - stores each modified set
and its union-demanding users in  at time slot  for the later adaptive encoding phase. That is,
step 9 of Procedure - stores an encoding data set in which  is replaced with  (i.e.,
−{}+{}) in  and its union-demanding users in  to facilitate the later adaptive
encoding phase Next, step 11 of Procedure - replaces  with  in  if the number of the
union-demanding users before the multi-code operation |
[
∈
()| is smaller than that after the
multi-code operation | [
[
∈ 6=
()]∪()|. In this case, we repeat the above steps to add
more data items to  to increase the number of the union-demanding users. Procedure -
terminates at step 3 if the number of the union-demanding users is maximal.
The complexity of Procedure - is () since each bi-code can be extended to at most
(− 2) multi-codes. Compared with bi-codes, DDOP with multi-codes is able to consider more queried
data items and stored data items in users. The algorithmic form of Procedure - is outlined
as follows.
Procedure Multi-coding ( )
1. Let  = ||;
2. for (each  ∈  1 ≤  ≤ )
3. Let  ←3;
4. Do
5. Let 0 ← ;
6. for (each  ∈ 0 in 0 where 1≤  ≤ )
7. Let  ← 0 + {};
8. Let ++;
9. Let  ←  − {}+ {} and  ←
[
∈
();
10. if (|
[
∈
()| | [
[
∈ 6=
()] ∪()|)
11.  ←  − {}+ {};
12. Let  ++;
19
d5 d6 d2
d3 d43 d1
(b) Result of a no coding 
scheme before adjustment. 
(a) Result of DDOP 
before adjustment.
d3 +d6
d5 +d6d1+d5
d2+d4 +d6
Fig. 6. Running examples under DDOP and a no coding scheme in broadcast programs before query changes.
29 in Fig. 5(b). That is, |(1 5) ∪ (2 6)| is smaller than |(1 5) ∪ (2 4 6)|.
Note that DDOP does not add the fourth data item to {2 4 6} in 1 since the number of the union-
demanding users cannot increase anymore. Finally, DDOP allocates 1 + 5 and 2 + 4 + 6 into two
channels respectively at time slot 1 as depicted in Fig. 6(a) and then inserts 11 and 21 in 1. ¥
c) Table and User Updating: After the users obtain the encoding data at each time slot , DDOP
updates the demanding users of each bi-code in  according to the updated queried and stored data
items of users to acquire the encoding data at later time slots. Specifically, for each bi-code in  step
4 of Procedure -  inserts user  into  if  can decode bi-code 
with stored data set   thereby obtains queried data items in queried data set  Otherwise, step
6 of Procedure -  deletes user  from  - 
repeats the above steps to update demanding users for each bi-code in  until examining all users. In
addition, for each user, step 3 of Procedure   deletes user  in  if  receives all queried
data (|| = 0) The complexity of updating table  is almost the same as Procedure -
  The algorithmic forms of Procedure -  and Procedure 
 are as follows.
Procedure Demanding-table Updating ( )
1. for( each  and each user  1 ≤  ≤ | |1≤  ≤ )
2. if(any element in {} ∈ )
3. if(any element in {} ∈ )
4  ← ;
5. else
6.  ←  − {};
7. return 
end
Procedure User Updating( )
1. for( each user 1≤  ≤ )
2. if (|| = 0)
3  ←  − ;
4. return 
end
21
items are encoded together. In other words, an encoding set {, } in this case must appear in 
if + is demanded by at least one user. The above description is outlined in steps 1-5 of Procedure
-  Note that () is an edge set in  and ( ) is an edge between vertex  and
vertex  Consider Fig. 8(a) as an example of generating the bi-coding graph according to Example 1.
Let a cyclic connected component denote a connected component with at least one cycle in the bi-coding
graph. The encoding of two data items is redundant if the users are able to derive the solutions to the two
items from other encoding data items. We avoid redundant encoding of data according to the following
theorem. The algorithmic form of Procedure -  is as follows.
Procedure Bi-coding Graph( )
1. ← ∅;
2. for (each  in 1≤  ≤ | |  ={,} 1≤   ≤ ||  6= )
3. if ( 6= {∅})
4. ()← () + (, );
5. return 
end
Theorem 1. There exists the redundant encoding of two data items if the bi-coding graph has at least
one cyclic connected component.
Proof. Consider the case that a cyclic with three edges, (, ) (, ) and ( , ), appears in a
connected component of the bi-coding graph. These three edges correspond to encoding data + +
and +. In this case, broadcast ,  and  is sufficient, and the three data items do not need to be
encoded. To avoid this case, we remove one of the edge, such as (, ), and the users that originally
require + are able to derive the solution to  or  from broadcasted + and +, because each
of the users must store  or  in this case. In other words, each user is able to derive the solution to
the queried data item by solving an equation set with three variables, according to two equations and the
solution to one variable. Similarly, we are able to remove one edge to avoid redundant encoding for any
cycle with more than three edges. ¤
With Theorem 1, our algorithm finds the redundant bi-codes in a broadcast program to further reduce
the access time. We design Procedure  to find and prune the redundant bi-codes in the
existing broadcast program.
With Theorem 1, our algorithm leverages the bi-coding graph to find the redundant bi-codes in a
broadcast program and to further reduce the access time. We design Procedure  to find
and prune the redundant bi-codes in the existing broadcast program.
Given bi-coding graph  and existing broadcast program  , we first devise Procedure 
based on Depth First Search (DFS) to find each cyclic component in  To find the cyclic components,
Procedure  traverses the graph in a recursive manner, with stack  storeing the track of the
23
3. for (each  ∈ ())
4. Push ( ) into 
5. if ( ∈  )
6. Let  ← 
7. FindCycle(,)
8. else
9. Let ← ∅;
10. Do
11. Pop  to ;
12. Let ← ;
13. while ( = )
14. return 
end
Procedure RefineProgram( )
1. Let ←FindCycle();
2. for (each cyclic component 0 in )
3. for (each  in 1≤  ≤ | |  ∈  )
4. if ({} ⊂ { ()})
5. Let  ←  − {};
6. return 
end
2) Adaptive Encoding: To adapt to the change of the queried data items after the  
phase, we propose the Adaptive Encoding phase to update the queries of the union-demanding users.
To replace the encoding data for each channel at time slot , DDOP finds the encoding data from the
union-demanding table as follows.
In the Adaptive Encoding phase, DDOP adjusts the existing codes at each time slot to avoid regenerating
the whole broadcast program. To adjust the existing broadcast program, we store the processed codes and
their demanding users in table  at time slot  (1≤  ≤ ) in the   phase. Therefore,
our algorithm merely updates the tables rather than rebuilds the tables to obtain the encoding data set for
each channel. Steps 13 and 14 of DDOP first collect all query-changing users in  . Step 17 of DDOP
starts adjusting  at time slot 1 To adjust the broadcast program and update  we devise
Procedure  and Procedure -   More specifically, with the
union-demanding table  at time slot  in the previous period, step 1 of Procedure 
first updates the union-demanding users of each encoding data set in  for query-changing users with
Procedure -  . Step 2 of Procedure -  
cleans union-demanding users in  (1≤  ≤ ||) due to user-queried changes. For each
encoding data subset  (1 ≤  ≤ ) in , steps 3 and 4 of Procedure -
  find its demanding users and then store them in () Afterward, to obtain the
25
(a) Changes of queried and stored 
data in users at time slot 1.
(c) Part of a updated union-demanding table 
for query-changing users at time slot 1.
(b) Changes of the queried and stored 
data in users at time slot 2.
(d) Part of a updated union-demanding table 
for query-changing users at time slot 2.
u10
{d1,d3,d5,d6} {d2}
{d1,d2,d3,d4,d6} {d5}
{d2,d3,d4,d5,d6}
{d2,d4,d5,d6} {d3}
{d1}
{d2,d3,d4,d6}
{d2,d3,d4,d6}
{d2,d3,d4,d6}
{d1,d4}{d2,d3,d5,d6}
{d1,d3,d5,d6}
{0}
Q10={d2,
d3,d4,d6}
{0}
{d2,d4}
{d1,d3,d5,d6} {d2,d4}
{d1,d3,d5,d6} {d2}
Storage Query
{0}
{d1,d5} {d6}
u2
u8
u4
u3
u5
u9
u11
u6
u1
u7
User
u12
{d1,d2,d3,d5,d6} {0}
{d1,d2,d3,d4,d5,d6} {0}
{d1,d2,d3,d4,d5,d6}
{d2,d3,d4,d5,d6} {0}
{0}
{d2,d3,d4,d5,d6}
{d2,d3,d4,d5,d6}
{d2,d3,d4,d6}
{d4}{d1,d2,d3,d5,d6}
{d1,d2,d3,d5,d6}
{0}
{0}
{d4}
{d1,d2,d3,d5,d6} {d4}
{d1,d2,d3,d5,d6} {0}
Storage Query
{0}
{d1,d5} {d6}
u2
u8
u4
u3
u5
u9
u11
u6
u1
u7
User
u10
u12
UDT1.Ui
u1,u2,u3,u4,u5,u6,u7,u8
u1,u2,u3,u5,u6,u7,u8
UDT1.Ei
{(d2,d6),(d1,d5)}
{(d1,d5),(d2,d3,d6)}
u1,u2,u3,u5,u6,u7,u8{(d2,d6),(d1,d3,d5)}
u3,u5,u8{(d1,d5),(d2,d4,d6)}
u1,u3,u4,u6{(d3,d6),(d1,d4)}
i
1
2
3
4
5
2
{(d1,d4),(d5,d6)} u1,u5,u6,u12
UDT2.Ui
u1,u5,u6,u12
UDT2.Ei
{(d5,d6),(d3,d4)}
u1,u5,u6,u12{(d5,d6),(d4,d5)}
u12{(d5,d6),(d3,d6)}
u12{(d5,d6),(d1,d6)}
i
3
4
5
1
Fig. 9. Running example under DDOP after query changes.
broadcasted encoding data {1 + 5 2 + 4 + 6} and allocates {1 + 5, 2 + 3 + 6} to two channels
respectively at time slot 1 as depicted in Fig. 10(a).
After users retrieve 1+ 5 or 2+ 3+ 6, the queried and stored data items in the users are changed
at time slot 2 as shown in Fig. 9(b). Next, DDOP repeats the above steps to update the union-demanding
users in 2 with the queried and stored data items in the users. Afterward, DDOP searches for encoding
data set {(1 4),(5 6)} to maximize the number of the union-demanding users in 21 as shown
at element 1 in Fig. 9(d) such that all users receive their queried data items. However, {(5 6),(3 6)} is
only demanded by user 12 Afterward, DDOP removes the broadcasted encoding data {5+ 6 3+ 6}
and allocates {1+4, 5+6} to two channels respectively at time slot 2 as depicted in Fig. 10(a). If the
broadcast program is not adjusted, many users cannot be satisfied with the previous codes. Therefore, it is
necessary for a dynamic scenario to adaptively change the broadcast program to reduce average waiting
time.
In addition, a no coding scheme, MULS [27], is running with the same queried profiles as shown in
Fig. 10(b). Under 10KBps of channel bandwidth and 1KByte of each data size, the average access time
of DDOP and MULS [27] is 0.29 Sec. and 0.6 Sec. respectively. Therefore, the above example shows
that the adaptive adjustment for the existing broadcast program is imperative in the dynamic environment.
Compared with MULS [27], our algorithm DDOP is able to adapt to the changes of user queries and
storage to adjust the broadcast program with previous stored encoding data to minimize the average access
time. ¥
27
TABLE II
THE PARAMETERS USED IN THE SIMULATION.
Parameters Values
Bandwidth of broadcast channel 10M Bps
Number of the broadcast channels () 5
Number of the broadcast data items () 50
Skewness parameter () 0.6
data item size () 1M Bytes
Average query length 30
Average store length 20
Number of data items || 1000
Number of queries || 10~50
Number of mobile users | | 500
is that DDOP can reduce average access time by allocating more than one data item to each time slot.
In contrast, MULS and GA are restricted by disseminating one data item in each time slot and lead to
more access conflicts. In addition, DDOP is better than LC with an average of 54% since LC encodes
redundant data at each time slot.
Fig. 11(b) compare the scalability of various approaches. We measure the average access time of each
approach with the number of mobile users  varied from 200 to 500, and the results show that the
average access time increases with more mobile users due to higher access load. DDOP is superior to
other approaches with an average of 38% and is close to BF since our approach searches for the encoding
data to maximize the number of demanding users from the demanding table. LC is worse than DDOP
since each user needs more encoding data items to acquire the queried data items. GA and MULS increase
slowly since they generate the broadcast program according to the access frequencies of queried data sets.
The results show that DDOP can achieve the higher scalability in the huge scale broadcasting system.
The following experiment shows that our approach can effectively utilize the channel bandwidth. Fig.
11(c) presents the average access time of each approach with the increase of the parameter  from 2 to 5
(i.e., from 20Mbps to 50Mbps). The average access time of each approach decreases with more channels.
According to our experimental results, the average performance gain of DDOP over other schemes is
about 47% since our algorithm can efficiently utilize the scarce bandwidth to minimize the number of
data transmission. As shown in Fig. 11(c), the discrepancy between DDOP and other schemes is more
prominent as the bandwidth is scarce (i.e., 20Mbps). With increasing the number of channels, GA and
MULS decrease since the data items of access conflicts are allocated into different channels in the different
time slot. Also, DDOP is still close to BF. Therefore, this experiment shows that DDOP can achieve better
performance with merely fewer channels.
Fig. 11(d) compares the average access time with different numbers of data items. The average access
time of each approach increases with more data items. DDOP outperforms other approaches with an
average of 61% and is close to BF. In addition, the discrepancy between DDOP and other schemes
29
0
0.5
1
1.5
2
2.5
3
0.5 0.7 0.9 1.1
Skewness Parameter
Av
era
ge
 A
cc
es
s T
im
e (
se
c)
MULS
BF
LC
GA
DDOP
0
3
6
9
12
15
15 17 19 21
Average Store Length
Av
era
ge
 A
cc
es
s T
im
e (
se
c)
MULS
BF
LC
GA
DDOP
(a) Comparison of each scheme with the different 
average store length.
(b) Comparison of each scheme with the different 
skewness parameters.
Fig. 12. Comparison of the performance of each scheme with the different average store length and skewness parameters.
0
10
20
30
40
50
0 10 20 30 40 50 60 70
Iteration Number
Ex
ec
uti
on
 T
im
e (
se
c)
DDOP
0
0.5
1
1.5
2
0 10 20 30 40 50 60 70
Iteration Number
Av
era
ge
 A
cc
es
s T
im
e (
se
c) DDOP
(b) Execution time with different numbers of iteration.(a) Performance improvement with different numbers of 
iterations.
Fig. 13. Comparison of the performance of DDOP with the different iteration number.
allocating one item in each slot. Hence, Fig. 12(b) demonstrates that our approach can intelligently select
the encoding data to satisfy the high skewness of user queries.
In addition, we investigate the performance and the efficiency of DDOP with different numbers of
iteration from 0 to 70 as follows. The average access time decreases with increasing the iteration number
as depicted in Fig. 13(a). DDOP can lead to significant improvements in the small iteration number 30 and
takes 70 iterations to reach the local optimum. We observe that the improvement becomes limited in the
large iteration number beyond 30. DDOP can contribute 80% of improvements on reducing the average
waiting time with only 40% of running iterations. The execution time of DDOP linearly increases with
increasing the iteration number as depicted in Fig. 13(b). Therefore, DDOP can provide much significant
improvements with fewer running iterations.
C. Efficiency Analysis
Fig. 14 compares the execution time of each scheme with different numbers of items . Fig. 14(a)
depicts that the number of data items slightly affects MULS since MULS merely allocates data items
in the broadcast channels according to the frequencies of queried data sets. In Fig. 14(a), DDOP is
31
0
0.5
1
1.5
2
2.5
1.E+02 1.E+03 2.E+03 3.E+03 4.E+03
Time (Sec.)
Av
era
ge
 A
cc
ess
 T
im
e (
sec
)
MULS
DDOP
OFFLINE
Noadjust
(d) Comparison of each scheme with different 
skewness parameters over time.
0
0.5
1
1.5
2
2.5
1.E+02 1.E+03 2.E+03 3.E+03 4.E+03
Time (Sec.)
Sk
ew
ne
ss
 P
ar
am
et
er
(c) Variance of skewness parameters over time.
0
0.5
1
1.5
2
2.5
3
1.E+02 1.E+03 2.E+03 3.E+03 4.E+03
Time (Sec.)
Av
era
ge
 A
cc
ess
 T
im
e (
sec
)
MULS
DDOP
OFFLINE
Noadjust
0
0.5
1
1.5
2
2.5
1.E+02 1.E+03 2.E+03 3.E+03 4.E+03
Time (Sec.)
Sk
ew
ne
ss
 p
ar
am
et
er
(a) Variance of the skewness parameters over time. (b) Comparison of each scheme with different 
skewness parameters over time.
Fig. 15. Comparison of the adaptiveness of each scheme in the static and dynamic environments.
adapts to the dynamic scenarios by adjusting the data items in the existing broadcast program.
Fig. 15(a) first changes the skewness parameter  slightly, and Fig. 15(b) shows that DDOP outperforms
Noadjust and MULS in an average of 48% and is close to OFFLINE. The reason is that DDOP can adapt
to the small change of the access patterns of user queries with fewer adjustments for the existing broadcast
program. We increase the deviation of  over time in Fig. 15(c), and the Fig. 15(d) shows that DDOP
is superior to Noadjust and MULS in an average of 70%. The reason is that DDOP can adapt to the
large change of the access patterns of user queries by updating the previous store status in a table at
each time slot and then finding the encoding data to adjust the existing broadcast program. On the other
hand, MULS is better than Noadjust in the dynamic scenario since MULS refines the existing broadcast
program to minimize the cost function. Therefore, the above results show that DDOP can adapt to the
changes of the access patterns in the dynamic scenario.
VI. CONCLUSION
In this paper, we have proposed a novel data broadcasting framework that adopts network coding by
leveraging data items stored in users to reduce the average access time. In our approach, a server first
33
[19] C.-L. Hu and M.-S. Chen. Adaptive information dissemination: An extended wireless data broadcasting scheme with loan-based
feedback control. IEEE Trans. on Mobile Computing, 2(4), Oct. 2003.
[20] J.-H. Hu, K. L. Yeung, G. Feng, and K. F. Leung. A novel push-and-pull hybrid data broadcast scheme for wireless information
networks. In Proceedings of the 2000 IEEE International Conference on Communications, pages 1778–1782, June 2000.
[21] J.-L. Huang and M.-S. Chen. Dependent data broadcasting for unordered queries in a multiple channel mobile environment. IEEE
Trans. on Knowledge and Data Engineering, 16(6), Jun. 2004.
[22] J.-L. Huang, M.-S. Chen, and H.-P. Hung. A qos-aware transcoding proxy using on-demand data broadcasting. In Proceedings of IEEE
INFOCOM, March 2004.
[23] J.-L. Huang and W.-C. Peng. An effective broadcast program generation algorithm for dependent data. In Proceedings of the 5th
Emerging Information Technology Conference (EITC-05), 2005.
[24] H.-P. Hung and M.-S. Chen. A general model of hybrid data dissemination. In Proceedings of the 6th International Conference on
Mobile Data Management (MDM-05), May 2005.
[25] H.-P. Hung and M.-S. Chen. Efficient data broadcasting by progressively merging and splitting data broadcasting environment. In
Proceedings of IEEE GLOBECOM, 2006.
[26] H.-P. Hung and M.-S. Chen. Muls:a general framework of providing multi-level service quality in sequential data broadcasting. IEEE
Transactions on Knowledge and Data Engineering, 2007.
[27] H.-P. Hung, J.-W. Huang, J.-L. Huang, and M.-S. Chen. Scheduling dependent items in data broadcasting environments. Proceedings
of ACM SAC’06, March 2006.
[28] A. R. Hurson, Y. C. Chehadeh, and J. Hannan. Object organization on parallel broadcast chennels in a global information sharing
environment. IEEE International Performance, Computing, and communication Conference, pages 347–353, 2000.
[29] T. Imielinski, S. Viswanathan, and B. R. Badrinath. Energy efficient indexing on air. In Proceedings of the 1994 ACM International
Conference on Management of Data, pages 25–36, 1994.
[30] T. Imielinski, S. Viswanathan, and B. R. Badrinath. Data on air: Organization and access. IEEE Transactions on Knowledge and Data
Engineering, 9(3):353–372, May/June 1997.
[31] S. Jaggi, P. Sanders, P. A. Chou, M. Effros, S. Egner, K. Jain, and L. Tolhuizen. Polynomial time algorithms for multicast network
code construction. IEEE Trans. on Information Theory, 15(6), 2005.
[32] S. Katti, H. Rahul, W. Hu, D. Katabi, M. Medard, and J. Crowcroft. The importance of being opportunistic: Practical network coding
for wireless environments. 43rd Allerton Conf. on Communication, Control, and Computing, 2005.
[33] S. Katti, H. Rahul, W. Hu, D. Katabi, M. Medard, and J. Crowcroft. Xors in the air: Practical wireless network coding. IEEE/ACM
Transactions on Networking, 16(3):497–510, 2008.
[34] J. Kuri and S. K. Kasera. Reliable multicast in multi-access wireless lans. In IEEE INFOCOM, pages 760 – 767, 1999.
[35] J. Kuri and S. K. Kasera. The optimization of an rtp level hybrid error correction scheme for dvb systems in wireless home networks
under strict delay constraint. In IEEE Transactions on Broadcasting, volume 53 of 1, pages 297–307, 2007.
[36] G. Lee, M. Yeh, S. Lo, and A. Chen. A strategy for efficient access of multiple data items in mobile environments. In Proceedings
of the 3rd International Conference on Mobile Data Management, pages 71–78, 2002.
[37] P. Lettieri, C. Fragouli, and M. Srivastava. Low power error control for wireless links. In Proc. ACM MobiCom, 1997.
[38] L. Li, R. Ramjee, M. Buddhikot, and S. Miller. Network coding-based broadcast in mobile ad-hoc networks. Proceedings of IEEE
INFOCOM, 2007.
[39] S.-Y. R. Li, R. W. Yeung, and N. Cai. Linear network coding. IEEE Transactions on Information Theory, 49:371–381, 2003.
[40] A. Nanopoulos, D. Katsaros, and Y. Manolopouslos. Effective prediction of web-user accesses: A data mining approach. Proc.
WEBKDD Workshop, 2001.
[41] W.-C. Peng, J.-L. Huang, and M. S. Chen. Dynamic leveling: Adaptive data broadcasting in a mobile computing environment. Mobile
Networks and Applications, 8(4):355–364, 2003.
[42] D. Qiao and K. G. Shin. A two-step adaptive error recovery scheme for video transmission over wireless networks. In INFOCOM,
pages 1698–1704, 2000.
[43] B. Sun, A. R. Hurson, and J. Hannan. Energy-efficientscheduling algorithms of object retrieval on indexed paralled broadcast channels.
Proceedings of the 2004 International Conference on Parallel Processing (ICPP’04), 2004.
[44] Y. Wu, P. . Chou, and K. Jain. A comparison of network codig and packing. In IEEE International Symposium on Information Theory
(ISIT), 2004.
[45] J. Xu, D. L. Lee, and B. Li. On bandwidth allocation for data dissemination in cellular mobile networks. In ACM/Kluwer Journal of
Wireless Networks (WINET), Special Issue on Advances in Mobile and Wireless, volume 9 of 2, pages 103–116, 2003.
[46] W.-G. Yee, S. B. Navathe, E. Omiecinski, and C. Jermaine. Efficient data allocation over multiple channels at broadcast servers. IEEE
Transactions on Computers, 15(10):1231–1236, October 2002.
[47] M. Zorzi and R. Rao. Energy constrained error control for wireless channels. In IEEE Personal Communications, volume 4 of 6, pages
27–33, 1997.
