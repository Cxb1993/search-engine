ύЎᄔाǺӧҁයΟԃीฝύǴךॺᕇठаΠ࣬྽όᒱளԋ݀Ǵ٠֡ς
ว߄ӧ୯ሞ࣬ᜢሦୱࡐӳޑࣴ૸཮ύǶ२ӃךॺӧѮໆၗ਑ύǴว৖р
Ծ୏ᘏڗຝ්ޕ᛽ޑᄽᆉݤǶќѦΨଞჹΒϩკޑٿᗺೱ೯კቚமୢ
ᚒǴวߏр౜܄ਔ໔ޑᄽᆉݤǶ೭ঁკፕୢᚒޑှ،ёҔӧѮໆၗ਑ޑ
ߥៈ΢ǶനࡕךॺΨගрѮໆၗ਑ύǴຝ්ޕ᛽ޑԾ୏௢ᏤᄽᆉݤǶ
ᜢᗖຒǺѮໆၗ਑ǵკᏢ౛ፕǵຝ්ǵკቚமǵᄽᆉݤ
1This is the end of a 3-year project. We have accomplished several rsults. All
of the results are published in leading international conferences. We feel that the
results justify the scope and goal of this project. The results are summarized as
follows.
– Abstracting Knowledge from Annotated Chinese Chess Game Records
This paper is published in Proc. 5th International Conference on Computers
and Games (CG), Springer-Verlag LNCS# 4630, pages 100–111, 2006.
Expert knowledge is crucial to improving the strength of computer Chinese
chess programs. Although a great deal of expert knowledge is available in text
format that uses natural languages, manually transforming it into computer
readable forms is time consuming and difficult. Written expert annotations of
Chinese chess games follow certain styles. By analyzing and collecting com-
monly used phrases and patterns from experts’ annotations, we introduce
a novel pattern matching strategy that automatically abstracts knowledge
from a large number of annotated game records. The results of experiments
on the middle phase of games indicate that our strategy achieves a low error
rate. We hope to utilize this approach to automatically collect Chinese chess
knowledge that is currently in text format.
– Smallest Bipartite Bridge-connectivity Augmentation
This paper is published in Proc. 3rd International Conference on Algorithmic
Aspects in Information and Management (AAIM), Springer-Verlag LNCS#
4508, pages 153–166, 2007.
This paper addresses two augmentation problems related to bipartite graphs.
The first, a fundamental graph-theoretical problem, is how to add a set
of edges with the smallest possible cardinality so that the resulting graph
is 2-edge-connected, i.e., bridge-connected, and still bipartite. The second
problem, which arises naturally from research on the security of statistical
data, is how to add edges so that the resulting graph is simple and dose not
contain any bridges.
– Knowledge Inferencing of Chinese Chess Endgames
This paper is published in Proc. 6th International Conference on Computers
and Games (CG), Springer-Verlag LNCS# 5131, pages 180–191, 2008.
Several Chinese chess programs exhibit grandmaster playing skills in the
opening and middle games. However, in the endgame phase, the programs
only apply ordinal search algorithms; hence, they usually cannot exchange
pieces correctly. Some researchers use retrograde algorithms to solve endgames
with a limited number of attack pieces, but this approach is often not prac-
tical in a real tournament. In a grandmaster game, the players typically
perform a sequence of material exchanges between the middle game and the
endgame, so computer programs can be useful. However, there are about 185
million possible combinations of material in Chinese chess, and many hard
endgames are inconclusive even to human masters. To resolve this problem,
we proposed a novel strategy that applies a knowledge inferencing algorithm
on a sufficiently small database to determine whether endgames with a cer-
tain combination of material are advantageous to a player. Our experiment
Abstracting Knowledge from Annotated Chinese
Chess Game Records⋆
Bo-Nian Chen1,⋆⋆, Pangfang Liu2 and Shun-Chin Hsu3 and Tsan-sheng
Hsu4,⋆⋆,⋆ ⋆ ⋆
1 Department of Computer Science and Information Engineering, National Taiwan
University, Taipei, Taiwan. r92025@csie.ntu.edu.tw
2 Department of Computer Science and Information Engineering, National Taiwan
University, Taipei, Taiwan. pangfeng@csie.ntu.edu.tw
3 Department of Information Management, Chang Jung Christian University,
Tainan, Taiwan. schsu@mail.cju.edu.tw
4 Institute of Information Science, Academia Sinica, Taipei, Taiwan.
tshsu@iis.sinica.edu.tw
Abstract. Expert knowledge is crucial to improving the strength of
computer Chinese chess programs [17]. Although a great deal of expert
knowledge is available in text format that uses natural languages, man-
ually transforming it into computer readable forms is time consuming
and difficult. Written expert annotations of Chinese chess games fol-
low certain styles. By analyzing and collecting commonly used phrases
and patterns from experts’ annotations, we introduce a novel pattern
matching strategy that automatically abstracts knowledge from a large
number of annotated game records. The results of experiments on the
middle phase of games indicate that our strategy achieves a low error
rate. We hope to utilize this approach to automatically collect Chinese
chess knowledge that is currently in text format.
1 Introduction
Computer Chinese chess has developed over the last 20 years and there are now
several computer Chinese chess programs that can demonstrate a human mas-
ter’s level of playing expertise [16]. A popular strategy for program designers is
to use variations of the α-β pruning search algorithm with rule-based evaluation
functions. The algorithm is the core component that identifies the best move,
while the evaluation function provides a standard measurement of the given po-
sition. In this game playing model, knowledge of Chinese chess is embedded in
the evaluation functions.
⋆ Early concepts of this paper appeared in ”Automatic Expert Knowledge Retrieval
Strategy”, the 10th Conference on Artificial Intelligence and Applications, Taiwan,
2005, pp 11 (one page abstract only).
⋆⋆ Supported in part by National Science Council (Taiwan) Grants 94-2213-E-001-014.
⋆ ⋆ ⋆ Corresponding author.
Abstracting Knowledge from Annotated Chinese Chess Game Records 5
game records, which are just examples of human knowledge about the middle
game. Thus, in this paper, we focus on expert knowledge about the middle game
[13].
2.2 The Importance of Automatic Expert Knowledge Retrieval
Existing expert knowledge retrieval schemes have two potential drawbacks: 1)
designers may need to spend a lot of time implementing the rules one by one;
and 2) the position sets of different expert knowledge schemes may intersect.
Consequently, if two schemes are applied simultaneously, their knowledge may
overlap or conflict. In contrast, automatic expert knowledge retrieval reduces the
implementation time and partitions the position set into several classes so that
each class can be marked as a rule.
3 Automatic Expert Knowledge Retrieval
In this section, we define our strategy for automatically retrieving expert knowl-
edge from a large number of annotated game records in text format.
3.1 Expert Knowledge and Position Value
In this paper, we focus on expert knowledge in the middle phase of games. We
use a program that automatically transforms a text-formatted annotated game
record into a position value, which is the score of a given position. Position value
assignment has been used in many applications, such as [14, 18]. The position
value is an integer in the range 0 to 9, where each number represents a class used
to measure the advantage or disadvantage of a given position to the red side, as
shown in Table 1.
Thus, a position that is advantageous to the red or black player is classified
into the red-advantage or red-disadvantage class respectively.
Position Class Description
Value
0 excellent The red player is sure to win.
1 very good The red player has very little chance of losing, and
a better chance of winning than drawing.
2 good The red player has more chances of winning than losing or drawing.
3 advantage The red player’s position is a little better than that of the black player.
4 even Both sides have an equal chance of winning.
5 draw Neither player can win.
6 disadvantage The red player’s position is not as good as that of the black player.
7 bad The red player has more chances of losing than winning or drawing.
8 very bad The red player has very little chance of winning, and
many more chances of losing than drawing.
9 worst The red player is sure to lose.
Table 1. The position values with respect to the red side and their meanings.
Abstracting Knowledge from Annotated Chinese Chess Game Records 7
Exception element: passive-exception elements, condition-exception elements,
and negation exception elements are all called exception elements. They are
used to filter phrases that look similar to an element, but they have differ-
ent meanings. These classes of phrases usually only occur in Chinese. For
example:
“The position of the black side is not bad.” (9øA]	«ý)
Here “not bad”, which contains a negative word even if it is translated into
Chinese, does not really have a negative meaning; thus, it is a negative
exception element.
3.3 Chinese Chess Annotation Abstraction Algorithm
This processing algorithm is a novel pattern matching strategy, designed espe-
cially for Chinese chess annotation abstraction. When the algorithm is applied
to a sentence, it finds the elements and uses the grammar rules below to extract
the meaning of the input sentence. Note that these rules are designed specifically
for the annotations written in Chinese.
1. Stmt→ Subject Score [Object]
This rule means that the player defined in the subject element receives the
score defined in the score-related element. In Chinese chess, there may be
an object after the score-related element, which must be the opponent of the
subject element. For example: “In the current position, black has advantage,
red is disadvantaged.” (	«ÕhA]8TR]T)
2. Stmt→ Subject Negation Score [Object]
This rule has a negation element, so the player defined in the subject element
does not receive any points. For example: “Black uses cannon to threaten
red’s knight, thus red loses the advantage.” (¬A]
ÆÓR]
¿Ý8T^bÝ)
3. Stmt→ Object Passive Score [Subject]
This rule has a passive element, so the object element occurs first. Thus, the
opponent of the player defined in the object element gets the score defined
in the score-related element. For example: “Black moves cannon, red’s ad-
vantage is lost. Because black threatens red’s knight, it also threatens red’s
cannon.” (A]
ÄªR]ÎDÝ.A]b¿ ÓÝ
Tïì8ÿÝ)
4. Stmt→ Cond Stmt
This rule has a condition element so that the subsequent sentence is ignored.
For example: “If the red side moves his rook to exchange the black’s rook, the
formation of the black side will be flexible, because the red pawn in the 1st
column is threatened by the black cannon in the 9th column. ” (AR]

·DA]pÌbÄP.R]Ý×­ºA]ÝÜ­ )
5. Stmt→ Score
This rule does not have a subject element. There are two cases for this rule,
depending on the score-related element.
Abstracting Knowledge from Annotated Chinese Chess Game Records 9
[1]; each node represents a single position. We deleted 178 positions, which were
not relevant to the measurement of the position.
The remaining 1,865 positions cover the middle phase, as well as the opening
phase and the end phase. We first identify the phase of a game that a position is
in. There are many different definitions for the phases of a game. In [3], the open-
ing game consists of about 10 plies; there may be more or less, depending on the
state of the position. In [7], the middle game starts before the actual battle pro-
ceeds. None of the phases are clearly defined. Hence, for ease of implementation,
we adopt the following definitions.
Opening game None of the rooks, cannons, and horses, which are strong pieces,
are captured, but some pawns may be taken.
Middle game For clarity, the middle game is divided into two cases: 1) at least
one player has more than four strong pieces, and at least one strong piece of
either player is captured; and 2) at least one player has exactly four strong
pieces, one of which is rook. Note that the rook is considered as two strong
pieces, since its value is equal to two cannons or two horses, or one of each.
Endgame There are two cases in the definition of the endgame: 1) both players
have less than or exactly three strong pieces, and 2) neither player has a
rook.
Based on the above definitions, the 1,865 positions consist of 424 opening
game positions, 1,377 middle game positions, and 64 endgame positions. All the
positions were annotated and the sentences were verified manually to ensure they
were free from grammatical errors and scoring conflicts. This set of test data,
called WU1865, is used to fine tune our algorithm and find various elements. In
the current algorithm, there are 306 score-related elements, 6 subject elements,
5 passive elements, 13 condition elements, 7 condition-exception elements, 5
negation elements, and 21 negation-exception elements.
The position values of the 1,865 annotated positions were manually assigned
in one week by the first author, who is a certified Chinese chess 2-Dan1 player. By
comparing the answers annotated manually and the results from our algorithm,
we were able to analyze the effectiveness of our approach statistically.
The statistical analysis of WU1865 is shown in Table 2. The numbers in the
first row are position values of the manually assigned values, while the numbers
in the first column are position values of the program results. Each grid in
the i-th row and the j-th column represents the number of cases for which the
answer is position value j, but our algorithm gives position value i, denoted
by val(i, j). The diagonal grids are correct cases, denoted by val(i, i). If the
numbers on the diagonal grids are much larger than on the vertical grids and
horizontal grids, it means the algorithm is very reliable. The numbers in the last
row and the last column are the summations of the rows or columns , denoted by
1 Dan is a measurement of the playing expertise of a Chinese chess player in Taiwan.
The range of Dan is from 1-Dan to 9-Dan. 1-Dan to 3-Dan are roughly consid-
ered experts, 4-Dan to 6-Dan are roughly masters, and 7-Dan to 9-Dan are roughly
grandmasters.
Abstracting Knowledge from Annotated Chinese Chess Game Records 11
We define the number of significant errors as the measurement of the total
errors due to the limitations of the algorithm: number of significant errors =
scoring errors − slight errors According to the statistical results, there are
11 no-keyword errors, 110 keyword-inconsistent errors, and 129 scoring errors.
There are also 75 slight errors in the training set. The number of significant
errors is 54.
It took less than 1 minute to parse the annotation of 1,865 positions and
generate a statistical analysis on an Intel Pentium IV 1.8GHz CPU with a 512MB
RAM. The code size of the system is approximately 2,000 lines (not including
the GUI code). The current size of the keyword pattern base is 3,158 bytes,
which can be increased if necessary.
0 1 2 3 4 5 6 7 8 9 Sum
0 85 10 9 0 0 0 0 1 0 0 105
1 4 98 10 0 0 0 1 0 0 0 113
2 9 10 548 5 0 1 2 1 1 0 577
3 0 0 10 82 1 1 4 0 0 0 98
4 0 0 0 2 97 0 2 0 0 0 101
5 1 0 0 2 1 29 3 2 0 1 39
6 0 0 0 0 5 1 186 9 0 0 201
7 0 0 0 1 1 0 9 393 4 2 410
8 0 0 0 0 0 0 0 2 61 0 63
9 0 0 0 0 0 0 0 0 1 36 37
E1 0 0 2 2 1 2 1 2 1 0 11
E2 1 0 19 16 23 7 28 13 3 0 110
Sum 100 118 598 110 129 41 236 423 71 39 1865
Table 2. Comparison of manually annotated answers and algorithm generated
results for WU1865. Horizontal axis represents the number of positions manually
annotated. Vertical axis represents the number of positions generated by the
algorithm, where E1 represents no element error and E2 represents inconsistent
element error.
4.2 Experiment Results
Next, we used our program to analyze an untrained data set called NET TEST.
There are two sources of NET TEST. The first is [2], which consists of 225 game
records on a CD. On average, there are 5 annotated positions in each game
record. The second source consists of web sites. There are 249 positions in the
web annotated by some of the best grandmasters in China, such as Y. C. Xu.
There are totally 1,418 annotated positions, 55 of which are not relevant to the
measurement of the position. As a result, NET TEST contains 1,363 annotated
Abstracting Knowledge from Annotated Chinese Chess Game Records 13
5 Concluding Remarks
We have proposed an automatic expert knowledge retrieval strategy that trans-
forms human knowledge into information that can be easily implemented in
computer programs. The experiment results show that the error rate of our
strategy is low and errors in annotated game records are often detected. Using
the program, a human expert can easily input Chinese chess knowledge into the
algorithm and confirm the computer’s choices.
There are many books covering all phases of Chinese chess games. The cur-
rent method of collecting data is to manually translate each game record into a
computer file, which is very time consuming. Furthermore, the process is sub-
ject to human error. An automatic game record generating system can use either
OCR (Optical Character Recognition) to obtain data from published works, or
computer agents to find text data from the Web. It can then apply our automatic
expert knowledge retrieval strategy to construct the information. In the future,
we will incorporate machine learning techniques into the strategy to generate a
new evaluation function based on the abstracted expert knowledge.
References
1. Wu, G. L. (1998), ”Hsiang Chi Pin Fa (Strategies of Chinese Chess Opening
Games),” A Computer Software published by Sohare Information Co. Ltd.
2. Wu, G. L. ”2001 Chung Kuo Hsiang Chi Ker Run Sai (Chinese Chess National
Personal Contest in 2001),” A Computer Software published by Sohare Informa-
tion Co. Ltd.
3. Huang, S. L. (1986), ”Hsiang Chi Kai Chu Tsan Li (Theory of Chinese Chess
Opening Games),” published by Shi Che Wun Wu Publishing House.
4. Chiang, C. S. (1996), ”Lio Sin Pu Chu Sin Pien Tan Suo (Discovery of The New
Variations of Popular Opening Strategies in Chinese Chess),” published by Chen
Du Xi Tai Publishing House.
5. Chi, R. S. (1990), ”Hsiang Chi Pu Chu Chu Yau (The Points of Opening Strategies
in Chinese Chess),” published by San Hai Wun Hua Publishing House, pp. 330.
6. Cho, T. Y., Tsu, C. G. (1990), ”Xiao Lie So Pao, ” published by Run Min Ti Yu
Publishing House.
7. Huang, S. L. (1986), ”Shi Tsan Chong Chu Tsan Li (Theory of Chinese Chess
Middle Games),” published by Shi Che Wun Wu Publishing House.
8. Chang, S. S., Kuo, L. P. (2001), ”Si Tsan Chong Ti Wu Chu (The Mistakes in
Playing Chinese Chess),” published by Su Ron Qi Yi Publishing House.
9. Gin, C. T., Yan, D. (1986), ”Hsiang Chi Chong Chu Tsan Su Ja Si (Analysis
of Middle Game Techniques in Chinese Chess), ” published by Su Ron Qi Yi
Publishing House.
10. Tu, J. M. (1990), ”Hsiang Chi Tsan Chu Li Dian (Bible of Endgame Examples in
Chinese Chess), ” published by published by San Hai Wun Hua Publishing House.
11. Fang, H. R., Hsu, T.-s. and Hsu, S. C. (2000), Construction of Chinese Chess
Endgame Databases by Retrograde Analysis, ”Computers and Games 2000 (CG
2000)”, pp. 96-114.
12. Hsu, T.-s. and Liu, P. Y. (2002), Verification of Endgame Databases, ”ICGA Jour-
nal”, Vol. 25, No. 3, pp. 132-144.
Smallest Bipartite Bridge-connectivity
Augmentation (Extended Abstract)
Pei-Chi Huang1, Hsin-Wen Wei1, Wan-Chen Lu1,⋆, Wei-Kuan Shih1 and
Tsan-sheng Hsu2,⋆
1 Department of Computer Science, National Tsing-Hua University, Hsinchu,
Taiwan. {peggy, bertha, wanchen, wshih}@rtlab.cs.nthu.edu.tw
2 Institute of Information Science, Academia Sinica, Taipei, Taiwan.
tshsu@iis.sinica.edu.tw
Abstract. This paper addresses two augmentation problems related to
bipartite graphs. The first, a fundamental graph-theoretical problem, is
how to add a set of edges with the smallest possible cardinality so that
the resulting graph is 2-edge-connected, i.e., bridge-connected, and still
bipartite. The second problem, which arises naturally from research on
the security of statistical data, is how to add edges so that the resulting
graph is simple and dose not contain any bridges.
1 Introduction
A graph is said to be k-edge-connected if it remains connected after the removal
of any set of edges whose cardinality is less than k. Finding the smallest set of
edges, the addition of which makes an undirected graph k-edge-connected, is a
fundamental problem with many important applications that has been studied
extensively; readers may refer to [5, 7, 19] for a comprehensive survey. Studies
of augmentation problems in bipartite graphs can be found in [9, 11, 12]. In this
paper, we focus on augmenting bipartite graphs. A graph is componentwise 2-
edge-connected if each connected component is either 2-edge-connected, or it is
an isolated vertex. Figure 1(a) shows an example of a bipartite graph. A smallest
2-edge-connectivity augmentation of (a) is shown in Figure 1(b), and a smallest
componentwise 2-edge-connectivity augmentation of (a) is shown in Figure 1(c).
Note that there is a linear-time algorithm for the smallest bridge-connectivity
augmentation problem on the general graph that does not have a bipartite con-
straint [4]. In [11], Jensen et al. proposed a polynomial time algorithm that solves
the smallest bridge-connectivity augmentation problem on a graph that has par-
tition constraints, such as bipartite graph, in O(n(m+n log n) logn) time, where
m is the number of distinct edges in the input graph. We are unaware of any pre-
vious results for the smallest componentwise bridge-connectivity augmentation
problem.
Motivation
⋆ Supported in part by National Science Council (Taiwan) Grants NSC 94-2213-E-
001-014 and NSC 95-2221-E-001-004.
Bipartite Bridge-connectivity Augmentation 17
Algorithm 1 Finding a smallest 2-edge-connectivity augmentation of a bipartite
graph G
1: procedure FS2Aug(G)
2: Let T = BB(G);
3: E = ∅;
4: repeat
5: switch (T )
6: Case 1: T is a tree
7: Case 1.1: T is an easy tree
8: Case 1.1.1: T is an ETC tree
E′= ETCT(T ); {∗ Algorithm 2 ∗}
9: Case 1.1.2: T is an anti-ETC tree with more than 4 leaves
E′= AETC(T ); {∗ Algorithm 3 ∗}
10: Case 1.1.3: T is an anti-ETC tree with at most 4 leaves
Use the solution shown in Figure 2 to find E′;
11: Case 1.2: T is a general tree
12: Case 1.2.1: T has no hybrid leaves
E′= BGTWAug(T ); {∗ Algorithm 4 ∗}
13: Case 1.2.2: T has hybrid leaves
E′= HTAug(T); {∗ Algorithm 6 ∗}
14: Case 2: T is a forest
15: Case 2.1: T contains no isolated vertices
16: Case 2.1.1: T is a light forest with |TB | = |TW |
E′= FTConversion(T ); {∗ Algorithm 7 ∗}
17: Case 2.1.2: T is a light forest with |TB | > |TW |
E′= BGTW FTConversion(T ); {∗ Algorithm 8 ∗}
18: Case 2.1.3: T is a forest with hybrid leaves
E′= H FTConversion(T ); {∗ Algorithm 9 ∗}
19: Case 2.2: T contains a set of isolated vertices S
20: Case 2.2.1: T − S contains at least 2 white and 2 black vertices
Use the method in §4.2.1 to find E′;
21: Case 2.2.2: T − S contains either 1 white or 1 black vertex
Use the method in §4.2.2 to find E′;
22: Case 2.2.3: T − S is null
E′= ISOF(T); {∗ Algorithm 10 ∗}
23: Let E = E ∪ E′;
24: Let T = BB(T ∪ E′);
25: until Case 1 is executed
26: return E;
27: end procedure
a hybrid block. A vertex in the bridge-block forest is white if its corresponding
block is white. Black and hybrid vertices in the bridge-block forest are defined
similarly. Hereafter, we focus on a bridge-block forest, rather than a graph.
Let an easy tree be a tree with an equal number of black and white leaves
and no hybrid leaves. Our main algorithm first solves the problem on an easy
tree, and then solves it on a general tree. Finally, we solve the case where the
input graph is a forest. In addition, the edge set added to the bridge-block forest
by our algorithms can be transformed into the corresponding edge set added
to the input graph G. The algorithms run in sequential liner time and O(log n)
parallel time on an EREW PRAM using a linear number of processors. A high-
level description of the algorithm for the 2-edge-connectivity case is given in
Algorithm 1. The main result of this paper is stated in Theorem 1 and will be
proved in the remaining sections. Due to space limitation, we omit some details
which can be found in [10].
Theorem 1. Algorithm 1 runs in sequential linear time and O(log n) parallel
time on an EREW PRAM using a linear number of processors.
Bipartite Bridge-connectivity Augmentation 19
Algorithm 2 ETC tree connection
1: procedure ETCT(T) {∗ where T is an ETC tree with ℓ leaves ∗}
2: Find i∗ such that vi∗ and vi∗+ℓ/2 are in different colors;
3: Let Vin = {vi∗+1, vi∗+2, . . . , v(i∗+ℓ/2)−1}, and Vout = {v1, v2, . . . , vi∗−1} ∪
{v(i∗+ℓ/2)+1, v(i∗+ℓ/2)+2, . . . , vℓ};
4: Number the black (respectively, white) leaves in Vin starting from 1 as b1, b2, . . . (respectively,
w1, w2, . . .);
5: Number the black (respectively, white) leaves in Vout starting from 1 as b′1, b
′
2
, . . . (respectively,
w′
1
, w′
2
, . . .);
6: Let E′ = {(bi, w′i) | ∀i} ∪ {(b
′
i
, wi) | ∀i};
7: return E′ ∪ {(vi∗ , vi∗+ℓ/2)};
8: end procedure
3.2 Case 1.1: When BB(G) is an easy tree
Recall that an easy bridge-block tree T for a bipartite graph is one with an equal
number of white and black leaves and no hybrid leaves. We number the leaves
of T via a depth-first ordering from 1 to ℓ, i.e., the number of leaves in T , and
denote them by v1, v2, . . . , vℓ. Note that, since ℓ is even, LOWt2e(BB(G)) = ℓ/2.
By Lemma 1, |aug2e(T )| ≥ ℓ/2. Our algorithm, described below, always adds
ℓ/2 edges. Thus, after adding edges, if we can prove the resulting graph is 2-edge-
connected, the solution found is a smallest 2-edge-connectivity augmentation of
T .
If T is an easy tree and there exists i such that vi and vi+ℓ/2 are two different-
colored leaves, we say that the tree is an easy-to-connect or ETC tree. An easy
tree that is non-ETC is called an anti-ETC tree. Note that both ETC and anti-
ETC trees are easy trees. Our algorithm considers three cases: (1) an ETC tree,
(2) an anti-ETC tree with more than four leaves, and (3) an anti-ETC tree with
at most four leaves.
Lemma 2. Let T be the input tree and Tnew = T ∪ Eadded, where Eadded is a
set of added edges. Then, each added edge e ∈ Eadded is not a bridge in Tnew.
Case 1.1.1: When BB(G) is an ETC tree Our algorithm for finding
aug2e(BB(G)) when BB(G) is an ETC tree is shown in Algorithm 2.
Lemma 3. For a subtree T ′ of T , let ea be the antenna edge of T
′ and Tnew =
T ∪ Eadded, where Eadded is a set of edges added to T . If there exists an edge
e = (va, vb) ∈ Eadded, such that va ∈ T ′ and vb 6∈ T ′ or vice versa, then ea is not
a bridge in Tnew.
Lemma 4. Let Eadded be the set of edges derived by Algorithm 2 and let Tnew =
T ∪Eadded. Then Tnew does not contain any bridge; that is, Eadded = aug2e(T ).
Case 1.1.2: When BB(G) is an anti-ETC tree with more than four
leaves In this case, we can find two consecutive leaves, denoted, respectively,
by va and va+1 (a < ℓ/2), such that va and va+1 are different colors. Without
loss of generality, we assume that va is a black leaf; therefore, va+1 is white.
Bipartite Bridge-connectivity Augmentation 21
Algorithm 4 When the input has no hybrid leaves and |B| > |W |.
1: procedure BGTWAug(T )
2: Let bi and wi be, respectively, the ith black and white leaf;
3: Let V = b1, b2, . . . , b|B|, w1, w2, . . . , w|W | and V ′ = b|W |+1, b|W |+2, . . . , b|B|;
4: Let T ′ = T − V ′;
5: if T ′ is an ETC tree then
6: E1=ETCT(T ′); {∗ Algorithm 2 ∗}
7: else if T ′ is an anti-ETC tree with more than 4 leaves then
8: Let E1=AETC(T ′); {∗ Algorithm 3 ∗}
9: else if T ′ is an anti-ETC tree with at most 4 leaves then
10: Use the solution illustrated in Figure 2 to find E1;
11: end if
12: if there is only one white vertex in T i.e., there is no white leaf in T then
13: Let u be the white vertex in T and E2 = {(bi, u) | 1 ≤ i ≤ |B|};
14: else
15: Let u1, u2 be two white vertices in T ;
16: Let E2 ={(bi, uj) | |W + 1| ≤ i ≤ |B|, j ∈ {1, 2} , where uj is not the neighbor of bi}; {∗ add
edges between a white vertex and the remaining black leaves ∗}
17: end if
18: return E1 ∪ E2;
19: end procedure
Algorithm 5 H assignment
1: procedure HAssign(T) {∗ where T is a tree with hybrid leaves ∗}
2: if |B| > ⌈(|B| + |W | + |H|)/2⌉ then
3: All hybrid leaves are recolored white;
4: else
5: Arbitrarily select |B| − |W | hybrid leaves to be recolored white;
6: The remaining ⌊(|H| − |B| + |W |)/2⌋ hybrid leaves are recolored white;
7: The rest are recolored black;
8: end if
9: Let T ′ be the resulting tree;
10: return T ′;
11: end procedure
into a tree without hybrid leaves using an algorithm called HAssign, described
in Algorithm 5. Then, we apply Algorithm 4 to the recolored tree derived by
Algorithm 5. The steps followed in this case are described in Algorithm 6.
Lemma 7. Algorithm 6 is correct and optimal. That is, aug2e(T ) = aug2e(T ′),
where T = BB(G) and T ′ is the recolored tree returned by Algorithm 5.
4 Case 2: When BB(G) is a forest
In this section, we present a number of algorithms that convert a forest into a
tree. After this transformation, we can apply the algorithms presented in Section
3 to add edges such that no bridges exist in the final graph.
Algorithm 6 When T has hybrid leaves
1: procedure HTAug(T)
2: T ′= HAssign(T); {∗ Algorithm 5 ∗}
3: E′= BGTWAug(T ′); {∗ Algorithm 4 ∗}
4: return E′;
5: end procedure
Bipartite Bridge-connectivity Augmentation 23
Algorithm 8 |TB| > |TW | Forest-Tree Conversion
1: procedure BGTW FTConversion(F ) {∗ where F is a light forest with |TB | = k + x, (x ≥ 1), |TW | = k, and
|TBW | = z ∗}
2: if TBW = TW = φ then
3: Pick a leaf from each tree in TB and number them as b1, b2, . . . ,bk+x;
4: Let E1 = {(bi, u) | 1 ≤ i ≤ k + x and let u be a white vertex of TB with the number br , where
i 6= r and 1 ≤ r ≤ k + x};
5: else
6: Find a subset T ′
B
of TB , such that |T
′
B
| = k;
7: Let T ′
B
= TB − T
′
B
and |T ′
B
| = x;
8: Let F ′ = T ′
B
∪ TW ∪ TBW ;
9: E1= FTConversion(F ′); {∗ Algorithm 7 ∗}
10: Pick a leaf from each tree in T ′
B
and number them as b1, b2, . . ., bx;
11: Number the remaining white leaves of BB(F ′ ∪ E1) as w1, w2, ,. . . wy ; {∗ assuming there are y
remaining white leaves ∗};
12: if x ≤ y then
13: Let E2 = {(bi, wi) | 1 ≤ i ≤ x};
14: else
15: Let E2 = {(bi, wi) | 1 ≤ i ≤ y} ∪ {(bi, u) | y < i ≤ x, u is an arbitrary white leaf.};
16: end if
17: end if
18: return E1 ∪ E2;
19: end procedure
Algorithm 9 When the input is a forest that has hybrid leaves
1: procedure H FTConversion(F ) {∗ where F is a forest with hybrid leaves ∗}
2: T ′= HAssign(F ); {∗ Algorithm 5 ∗}
3: E′=BGTW FTConversion(T ′) {∗ Algorithm 8 ∗}
4: return E′;
5: end procedure
Case 2.1.3: When BB(G) has hybrid leaves If one endpoint of an added
edge is a hybrid leaf, the other endpoint of that edge can be either black or white.
For a general forest, we first transform a forest with hybrid leaves into a forest
without hybrid leaves using Algorithm 5. Then, we apply Algorithm 8 to convert
a forest into a tree. The steps followed in this case are shown in Algorithm 9.
Lemma 9. Algorithm 9 finds aug2e(BB(G)) when BB(G) is a forest containing
no isolated vertices.
4.2 Case 2.2: When BB(G) contains isolated vertices
Recall that each isolated black (respectively, white) block is an isolated black
(respectively, white) vertex in G. Let b′i (respectively, w
′
i) be the ith isolated
black (respectively, white) vertex in G, and let h′1,i, h
′
2,i be arbitrary black and
white vertices, respectively, in the ith isolated hybrid block of G.
Let G′ be the graph obtained by removing the vertices and edges from the
isolated blocks of G. There are three cases, which we describe below.
Case 2.2.1: G′ contains at least two white and two black vertices. Without loss
of generality, we assume that |B′| ≥ |W ′|, which yields five sub-cases: (1) Case
2.2.1.1: |W ′| > 0; (2) Case 2.2.1.2: |W ′| = 0, |B′| > 0 and |H ′| > 0; (3) Case
2.2.1.3: |W ′| = 0, |B′| = 0 and |H ′| > 0; (4) Case 2.2.1.4: |W ′| = 0, |B′| > 0,
|H |+ |W | > 0, and |H ′| = 0; (5) Case 2.2.1.5: |W ′| = 0, |B′| > 0, |H |+ |W | = 0,
Bipartite Bridge-connectivity Augmentation 25
Algorithm 10 When G′ is null, i.e., BB(G) consists of isolated vertices
1: procedure ISOF(F ) {∗ where F is a forest that consists of isolated vertices S ∗}
2: if qB = 0 then {∗ qH must be at least 2; ∗}
3: Let E1 = {(h′1,2i−1, h
′
2,2i
) | 1 ≤ i ≤ ⌊qH/2⌋};
4: if qH is odd number then
5: E′ = E1 ∪ (h′1,qH−1
, h′
2,qH
);
6: end if
7: else
8: if qB > qW + qH then
9: Let E1 = {(b′i, w
′
i
) | 1 ≤ i ≤ qW } ∪ {(b
′
i+qW
, h′
2,i
) | 1 ≤ i ≤ qH};
10: E′ = E1 ∪ {(b′i+qW+qH
,w) | 1 ≤ i ≤ qB − qW − qH and w is a white vertex in S};
11: else if qB = qW + qH then
12: Let E1 = {(b′i, w
′
i
) | 1 ≤ i ≤ qW } ∪ {(b
′
i+qW
, h′
2,i
) | 1 ≤ i ≤ qH};
13: E′ = E1;
14: else
15: Let E1 = {(b′i, w
′
i
) | 1 ≤ i ≤ qW } ∪ {(b
′
i+qW
, h′
2,i
) | 1 ≤ i ≤ qB − qW };
16: Let E2 = {(h′1,2i−1+qW−qB
, h′
2,2i+qW−qB
) | 1 ≤ i ≤ ⌊(qH + qW − qB)/2⌋};
17: if (qH + qW − qB) is odd then
18: Let E2 = E2 ∪ (h′1,qH−1
, h′
2,qH
);
19: end if
20: E′ = E1 ∪ E2;
21: end if
22: end if
23: return E′;
24: end procedure
Hence, |H | = 0 and G′ is a star with center w; BB(G) is also a star. There
are two sub-cases: (1) G−G′ contains a white vertex, and (2) G−G′ does not
contain a white vertex.
Case 2.2.2.1: there is no white vertex in G − G′. All isolated vertices in G
are black, |W ′| = 0 and |H ′| = 0, such that |LOWf2e(BB(G′))| = |B|. Let
E′ = {(b′i, w) | ∀i}.
Lemma 10. For Case 2.2.2.1, aug2e(BB(G)) = aug2e(BB(G′)) ∪ E′, and
BB(G) ∪ aug2e(BB(G)) is a multi-graph.
Case 2.2.2.2: there is one white vertex in G − G′. Let b be a black leaf in
BB(G′). Since BB(G′) is a star with a white center, b must exist. Let w′ be a
white vertex in an isolated block (i.e., in G−G′), and let G′′ = BB(G′)∪{(w′, b)}.
Note that the number of isolated blocks in BB(G) ∪ {(w′, b)} is one less than in
BB(G), and the number of black leaves in BB(G′′) is one less than in BB(G′).
However, there is one more white leaf in BB(G′′) than in BB(G′). Thus, we have
transformed Case 2.2.2.2 into Case 2.2.1.
Lemma 11. For Case 2.2.2.2, |LOWf2e(BB(BB(G) ∪ {(w′, b)}))| =
|LOWf2e(BB(G))| − 1.
Case 2.2.3: G′ is null Let qB , qW , and qH be the numbers of isolated black,
white, and hybrid blocks, respectively. Without loss of generality, we assume
that qB ≥ qW . Our algorithm is shown in Algorithm 10.
Theorem 3. |LOWf2e(BB(G))| = |LOWf2e(BB(BB(G)∪Eadded))|+ |Eadded|,
where Eadded is the set of added edges returned by Algorithm 10.
Bipartite Bridge-connectivity Augmentation 27
3. D. E. Denning and J. Schlo¨rer. Inference controls for statistical databases. IEEE
Computer, 16:69–82, July 1983.
4. K. P. Eswaran and R. E. Tarjan. Augmentation problems. SIAM Journal on
Computing, 5:653–665, 1976.
5. A. Frank. Connectivity augmentation problems in network design. In J. R. Birge
and K. G. Murty, editors, Mathematical Programming: State of the Art 1994, pages
34–63. The University of Michigan, 1994.
6. D. Gusfield. A graph theoretic approach to statistical data security. SIAM Journal
on Computing, 17:552–571, 1988.
7. T.-s. Hsu. Graph Augmentation and Related Problems: Theory and Practice. PhD
thesis, University of Texas at Austin, 1993.
8. T.-s. Hsu and M. Y. Kao. Security problems for statistical databases with general
cell suppressions. In Proceedings of the 9th International Conference on Scientific
and Statistical Database Management, pages 155–164, 1997.
9. T.-s. Hsu and M. Y. Kao. Optimal augmentation for bipartite componentwise
biconnectivity in linear time. SIAM Journal on Discrete Mathematics, 19(2):345–
362, 2005.
10. P.-C. Huang, H.-W. Wei, W.-C. Lu, W.-K. Shih, and T.-s. Hsu. Smallest bipartite
bridge-connectivity augmentation. Technical Report TR-IIS-06-016, Institute of
Information Science, Academia Sinica, Nankang, Taipei, Taiwan, 2006.
11. J. B. Jensen, H. N. Gabow, T. Jorda´n, and Z. Szigeti. Edge-connectivity aug-
mentation with partition constraints. SIAM Journal on Discrete Mathematics,
12:160–207, 1999.
12. M. Y. Kao. Linear-time optimal augmentation for componentwise bipartite-
completeness of graphs. Information Processing Letters, pages 59–63, 1995.
13. M. Y. Kao. Data security equals graph connectivity. SIAM Journal on Discrete
Mathematics, 9:87–100, 1996.
14. M. Y. Kao. Total protection of analytic-invariant information in cross-tabulated
tables. SIAM Journal on Computing, 26:231–242, 1997.
15. J. P. Kelly, B. L. Golden, and A. A. Assad. Cell suppression: Disclosure protection
for sensitive tabular data. Networks, 22:397–417, 1992.
16. F. M. Malvestuto and M. Moscarini. Censoring statistical tables to protect sensitive
information: Easy and hard problems. In Proceedings of the 8th International
Conference on Scientific and Statistical Database management, pages 12–21, 1996.
17. F. M. Malvestuto and M. Moscarini. Suppressing marginal totals from a two-
dimensional table to protect sensitive information. Statistics and Computing,
7:101–114, 1997.
18. F. M. Malvestuto, M. Moscarini, and M. Rafanelli. Suppressing marginal cells to
protect sensitive information in a two-dimensional statistical table. In Proceed-
ings of the 10th ACM SIGACT-SIGMOD-SIGACT Symposium on Principles of
Database Systems, pages 252–258, 1991.
19. H. Nagamochi. Recent development of graph connectivity augmentation algo-
rithms. IEICE Transactions on Information and System, E83-D:372–383, 2000.
Knowledge Inferencing on Chinese Chess Endgames 29
the most important component, the search engine, takes over and computes the
best move by evaluating hundreds of millions of positions. Some programs can
search more than 14 plies with today’s computers. Although some computer
chess games end in the middle game, the endgame tends to be the key phase for
strong programs that cannot be beaten in middle game.
However, in the endgame, the search performance is not good enough for
master-level players. There are two reasons for this. The first is that players need
more moves to finish the game, but the search method cannot always find a way
to the best position because of the limit of the search depth. The second reason is
that the result of the endgame is not always related to the amount of materials.
For example, KR and KGGMM usually end in draws, even though the former
has the advantage of a rook. Hence, a program that uses the materials advantage
as the main evaluation feature often misinterprets it as a huge advantage to the
attacking side.
To solve endgame problems, Herik and Hershberg suggested the concept of
the retrograde strategy in 1985 [1]. Subsequently, Herik, Herschberg and Naka
constructed a six-man endgame database of chess in 1987 [2]. Thompson pro-
posed an improved retrograde algorithm in 1986 [6] and solved 6-piece chess
endgames in 1996 [7], Schaeffer (2003) created a 10-piece endgame database of
Checker Chess [4]. Some games, like Checker, use the retrograde method suc-
cessfully [8]. Gasser solved Nine-Man’s Morris in 1996[11]. For Western chess,
which is a more complex game, the retrograde strategy is not very successful.
In 2000, Nalimov used an efficient space to build all 3-to-5-man endgames [9].
Endgame research is still in progress.
In Chinese chess, Fang, H. R. used the retrograde method to construct an
endgame database in 2000 [3], and Ren Wu (2002) used a memory efficient
strategy to build large endgames, including KGMCPKGGMM [12]. In 2006, P.
S. Wu, P. Y. Liu and T. S. Hsu proposed using an external-memory strategy for
the retrograde algorithm to build a large endgame database [10]. There are also
web sites that provide the exact values of endgame databases [5]. However, there
are serious time and space limitations when constructing a practical endgame
database of materials with sufficient attack pieces. The current largest endgame
database of Chinese chess comprises no more than two strong attack pieces on
each side. Many useful endgames that contain two strong attack pieces on both
sides can not be solved by retrograde strategies.
In a typical grandmaster game, before a grandmaster applies his endgame
knowledge, he usually performs a series of material exchanges at the end of the
middle game. In each material exchange, he gradually obtains an advantage. The
advantage may not derive from accumulating more materials, but from a com-
bination of materials that has proven to be better based on prior experiences.
For example, it is generally believed that a combination of one rook, one horse
and one cannon is better than a combination of two horses and two cannons,
although their material values are roughly equal. The goal of this paper is to de-
termine whether or not a material combination is good by performing knowledge
inferencing on a small dataset of kernel knowledge. To this end, we define two
Knowledge Inferencing on Chinese Chess Endgames 31
A knowledge database of material combinations consists of the defending ma-
terials that players use. Each item of defending material is mapped to an attack
file that includes all possible attack materials. Attack material is defined as the
pieces that belong to the attacking player. The possible number of materials
held by a player in Chinese chess can be computed by combinatorics as follows.
First, there are 27 combinations of strong pieces, including rooks, horses, and
cannons. Second, pawns are divided into three categories, as defined in Section
2.3. By using combinations with repetition of all possible numbers of pawns, we
retrieve the combinations of all categories of pawns, which total 56. Third, there
are 9 combinations of defending pieces, including guards and ministers. Totally,
a player can have 13,608 possible material combinations; and the total number
of possible material combinations on both sides is 185 million.
We have designed two useful knowledge inferencing strategies. The first, re-
dundant attacking material checking and elimination, which is described in Sec-
tion 2.2, can be applied when creating both the basic database and database
queries. The second strategy, called pawn inferencing, can only be used when
creating the basic database. It is described in Section 2.3.
2.2 Redundant Attacking Material Checking and Elimination
This knowledge inferencing tool can find and remove all attack material that
is not necessary. The idea is that if we already know a material state is WIN,
material states to which attack material is added by one or more pieces are also
WIN states because the attacking player has a bigger advantage in the WIN
state. Similarly, if a material state is HARD WIN, material states from which
attack material is taken by one or more pieces are also at most HARD WIN
states.
By using this algorithm, we can eliminate redundant attack materials when
creating the basic database. For database queries, the same concept is used if
there are some gaps between the attack power of two players. If the state of
attack material found in the database is WIN and the material is a subset of the
query attack material, we can also report a WIN state. We call this inferencing
algorithm material state extension.
A knowledge database of material combinations is said to be complete if
all the database items that record defense materials have all the necessary in-
formation about attack materials. Generally, the time complexity of a query is
O(NM), where N is the number of defending materials in the database, and M
is the maximum number of attacking materials among all defending materials in
the database. However, if we use a complete material database, we do not need
to search the whole database for the answer to a query. Instead, we only search
the desired attacking file so that the time complexity becomes O(M). The time
saved results in more computation when searching.
Knowledge Inferencing on Chinese Chess Endgames 33
3.1 Human Evaluation of Unknown Positions
By exchanging pieces, human experts can accurately infer the results of material
combinations that were previously unheard of. For example, KHKGGMM is
generally a draw. When the result of the material combination KRHKRGGMM
is in question, if the defending player has a rook, he can exchange it directly with
the rook of the attacking player, and the result will be a draw. This strategy is
called material reduction.
Another example is the material combination KRPKHGGMM. If the attack-
ing side exchanges a pawn for two guards of the defending player, the resulting
material KRKHMM can win easily, but it would not be an absolute win. How-
ever, if the pawn is exchanged for two ministers of the defending player, the
resulting material, KRKHGG would be an absolute win.
The two examples show that making a correct exchange of pieces is important
during the endgame phase.
3.2 Material Exchange Table
We have designed a probabilistic model that predicts the results of unknown
material states by exchanging pieces. Both sides can exchange pieces when nec-
essary. A material exchange table is introduced to compute the probabilities of
exchanging pieces.
The mobility of many types of pieces is different. The ability to exchange
a certain piece for pieces of another type is also different. A helper piece can
be any piece that is not being exchanged, but it can be used to facilitate an
exchange. Each player can select one piece as the helper piece. Generally, actively
exchanging pieces with the assistance of a helper piece will increase the player’s
exchnage ability. Similarly, passively exchanging pieces with the aid of a helper
piece may reduce the chance of pieces being exchanged. Hence, we manually
construct a two-dimensional material exchange table to record the probabilities
of exchanging each type of piece with the assistance of helper pieces.
There are 6 types of pieces in addition to the king. To map a table to each
active/passive piece pair, we use 36 tables for all possible types. Each table
contains the probabilities of the specified active piece with all possible helper
pieces and the specified passive piece with all possible helper pieces.
3.3 Determining the Score of an Unknown Material State
For an unknown material combination, we can try to make any exchange and
reference the database for the material state. The strategy of an expert player
is to choose the possible best way to make an exchange. We can accept an
exchange that has a high probability, but we cannot accept an exchange with a
low probability.
An acceptable exchange is formally defined as an exchange whose material
state is the most advantageous to the active player in all feasible situations and
whose probability is higher or equal to a lower bound. To achieve an acceptable
Knowledge Inferencing on Chinese Chess Endgames 35
The most practical usage of the knowledge database of material combinations
is to retrieve material scores as a part of the evaluation function during the search
phase. When a middle game position changes to an endgame position due to
piece exchange, the search algorithm can select better endgame positions with
the aid of our material database. However, there may be some positions where
the attack power of both sides is strong; or one player is disadvantaged in terms
of material, but still represents a great threat to the opposite player’s king. The
former can be handled by assigning UNKNOWN states to the positions when
both sides are strong enough to attack each other’s kings. The latter can be
handled by increasing the weight of special locations of piece combinations in
the evaluation function.
5 Experiment Design and Results
To demonstrate the performance of our algorithm, we generate a basic database.
It is a complete database of defense materials with at most one strong attacking
piece plus one pawn and all defending pieces. We use a practical data set as our
test data and compare it with the results obtained by our algorithm.
5.1 Experiment Design
We use the endgame knowledge table used by Contemplation as our test data.
There are 17,038 combinations of materials that have been manually annotated
by a 4-Dan expert. Since the data is symmetric, that is, if a material combi-
nation is in the database, information about exchanges between the attacking
player and the defending player is also in the database, the actual number of
test data combinations is 8,519. The scoring scheme used by the test data is
different to that of our method. The score of the test data is divided into 10
values. The values 0 and 1 are mapped to WIN in our method, which means
the attacking player usually wins. The value 2 is mapped to EASY WIN, 3 is
mapped to CHANCE WIN, 4 is mapped to UNKNOWN, and 5 is mapped to
HARD WIN. The values from 6 to 9 indicate that the attacking player changes
places with the defending player. The value 6 is mapped to CHANCE WIN; 7 is
mapped to EASY WIN; and 8 and 9 are mapped to WIN. Another difference re-
lates to the definition of pawns. In the test data, all pawns are the same, with no
category information. As a result, our program must compute the approximate
values of materials and then compare them with the test data. Because bottom-
pawns are not considered by the test data, we only compute the approximate
values of materials with top-pawns and low-pawns. The approximation formula
is Vapp = ⌊(Vtop + Vlow)/2⌋, where Vapp represents the approximated result;
Vtop represents the result of defining all pawns of both players as top-pawns;
and Vlow represents the result of replacing all pawns of the attacking player
with low-pawns. There are 6,396 entries that are not in our basic database. We
use the difference between the attack powers to filter out unreasonable annota-
tions, which means the attacking player has less attack power than the defending
player, and is assigned the grade of better than or equal to CHANCE WIN.
Knowledge Inferencing on Chinese Chess Endgames 37
Table 2. Comparison of human annotated answers and the algorithm generated
results for END4775. The horizontal axis represents the number of human anno-
tated material states. The vertical axis represents the number of material states
generated by the algorithm. U represents an unknown state.
U 1 2 3 4 Sum
U 0 35 55 195 40 325
1 0 990 402 52 0 1444
2 0 1278 663 120 17 2078
3 0 31 30 233 330 624
4 0 0 0 21 283 304
Sum 0 2334 1150 621 670 4775
Amaterial combination KCPGGKPPP in our test data is judged as EASY WIN
by human expert, but reported as HARD WIN by our algorithm. The discrep-
ancy is due to the different opinions about the defense ability of a defending
player who has three pawns. Since even masters have different opinions about
hard endgames, a slightly different human annotated answer is reasonable.
The performance of the individual algorithms is as follows. The number of
material combinations that can be inferred by the material state extension algo-
rithm is 2,614. The total correct number among 2,614 entries is 1,379(52.75%);
the tolerant correct number is 2,562 (98.01%); and the slight error number is
1,183 (45.25%).
By using the heuristic strategy described in Section 4, we did not obtain any
unknown material states in this test. The number of the entries that could not be
handled by the material state extension is 2,152. However, they can be predicted
by our predictor algorithm or the heuristic algorithm. The total correct number
is 781 (36.29%); the tolerant correct number is 1,814 (84.29%); and the value of
slight error number is 1,033 (48.00%).
Although the ratio of total correctness is reduced by using the heuristic strat-
egy compared to that of combining two algorithms, we believe our predictor algo-
rithm is reliable for the following reasons. First, the input of 2,152 entries is the
most complex data among all data sets. Second, the total correctness ratio shows
that, for the given material, the algorithm can distinguish the true advantage or
disadvantage in endgames. Third, even master players can not clearly identify
the difference between WIN and EASY WIN and between CHANCE WIN and
HARD WIN based only on information about the material. For example, Y. C.
Xu, a Chinese chess grandmaster, gave his opinions about a practical endgame
in his publication “YinChang Chess Road.” He criticized his opponent, G. L.
Wu, who is also a Chinese chess grandmaster [13].
The human annotated answer for the material combination KHCPKHCM in
our test data is EASY WIN; however, our algorithm reports CHANCE WIN,
which has different advantage. If a situation like this occurred during a real
Knowledge Inferencing on Chinese Chess Endgames 39
algorithm is an effective approach. However, if the extension algorithm fails, the
predictor algorithm takes over and reports an inferred solution. This strategy
can be used to solve the problem when a complete knowledge database of an
endgame with a large amount of material cannot be built using conventional
computer methods, and only advantage information is required to know for the
material state.
References
1. Herik, H. J. van den, and Herschberg, I. S. (1985). The construction of an omni-
scient endgame data base. ICCA Journal, Vol. 8, No. 2, pages 66-87.
2. Herik, H. J., Herschberg, I. S., and Naka, N. (1987). A six-men-endgame database:
KRP(a2)KbBP(a3). ICGA Journal, Vol. 10, No. 4, pages 163-180.
3. H. R. Fang, T. R. Hsu, and S. C. Hsu. Construction of Chinese chess endgame
databases by retrograde analysis. In T. Marsland and I. Frank, editors, Lecture
Notes in Computer Science 2063: Proceedings of the 2nd International Conference
on Computers and Games, pages 96-114. Springer-Verlag, New York, NY, 2000.
4. J. Schaeffer, Y. Bjornsson, N. Burch, R. Lake, P. Lu, and S. Sutphen. Building
the checkers 10-piece endgame databases. In H. J. van den Herik, H. Iida, and E.
A. Heinz, editors, Advances in Computer Games: Many Games, Many Challenges,
volume 10, pages 193-210. Kluwer Academic Publishers, 2003.
5. Jih Tung Pai, Chinese Chess Endgame Databases Query System,
http://lpforth.forthfreak.net/endgame.html
6. K. Thompson (1986). Retrograde analysis of certain endgames. ICCA Journal, Vol.
9, No. 3. 131-139.
7. K. Thompson. 6-piece endgames. ICCA Journal, 19(4):215-226, 1996.
8. Lake, R., Schaeffer J., and Lu, P. Solving large retrograde analysis problems using a
network of workstations. Advances in Computer Chess 7, Maastricht, Netherlands,
1994, 135-162.
9. Nalimov, E. V. and Heinz, E. A. (2000). Space-efficient indexing of endgame
databases for chess. Advances in Computer Chess 9. (eds. H. J. van den Herik
and B. Monien)
10. P. S. Wu, P. Y. Liu, and T. S. Hsu. An external-memory retrograde analysis al-
gorithm. In H. Jaap van den Herik, Y. Bjornsson, and N. S. Netanyahu, editors,
Lecture Notes in Computer Science 3846: Proceedings of the 4th International Con-
ference on Computers and Games , pages 145-160. 2006.
11. R. Gasser. Solving nine men’s morris. In R. Nowakowski, editor, Games of No
Chance, volume 29 of MSRI, pages 101-113. Cambridge University Press, Cam-
bridge, 1996. ISBN: 0-521-57411-0.
12. R. Wu and D. F. Beal. A memory-efficient retrograde algorithms and its application
to Chinese chess endgames. ICCA Journal, Vol. 42, pages 213-227, 2002.
13. Y. C. Xu, YinChang Chess Road, Special Column 44-45, Yan Chen Ti Yu News-
paper Office.
14. Yen S.J., Chen J.C., Yang T.N. and Hsu S.C. (2004). Computer Chinese Chess,
ICGA Journal, Vol. 27, No.1, March 2004, pp. 3-18, ISSN 1389-6911.
15. Contemplation, A Chinese chess program
http://www.grappa.univ-lille3.fr/icga/program.php?id=112
qbsbmmfmj{bujpo- usff qbsbmmfmj{bujpoǴ٠࿶җჴᡍ่݀ղᘐᇡࣁ sppu
qbsbmmfmj{bujpo ࣁനӳޑБԄǶ
ҁԛ Dpnqvufs Pmznqjbe ύႝတຝ්໨ҞӅԖ 29 ໗ୖуǴځύѠ᡼໗ҴӅԖΟ
໗Ǵхࡴךॺი໗ޑȨϺଭՉޜȩǴբޣࢂ৪ᢌܹ௲௤ࡰᏤޑᏢғ؇ޚ݇ǵȨຝ්Шৎȩ
җᎄܴࡹӃғࣴวǵаϷȨ්ᒉȩࢂҗҬεֆኾԋ௲௤ޑი໗܌ࣴวǶҗܭӦЬ୯ε
ഌБय़ࢴр 25 ໗ୖуǴ٠ЪԖ೚ӭ໗ҴჴΚ୲மǴӧ࿶ၸ 22 ፺ᚈБϩӃޑྷγڋК
ᖻࡕǴനࡕҗεഌޑ Joufmmb ำԄᕇளߎจǹฅԶҁԛКᖻၨзΓᅈཀޑࢂǴךॺი
໗ޑȨϺଭՉޜȩȐಃΐӜȑӧᏯᕮ΢യၸ΋ޔаٰՏۚѠ᡼നமޑำԄȨຝ්Шৎȩ
ȐಃΜ΋ӜȑǴҞ߻ࣁѠ᡼ԋᕮനଯޑำԄǶ
Βǵᆶ཮Јள
ႝတຝ්߈ԃٰޑว৖ёᇥࢂ࣬྽זೲǴӧ೬ᡏБय़Ǵཛྷ൨מೌϷ࣬ᜢᄽᆉݤςᖿԋዕǹ
٠ଛӝฯᡏޑזೲ຾؁Ǵ5HI{ ޑ 9 ਡЈ DQV ӧᖻ൑ύςόᆉനଯ฻ભΑǶԜԛКᖻךॺᢀ
ჸډεഌޑ൳ঁம໗ǴдॺޑำԄόՠཛྷ൨ుࡋёډ 2931 ቫа΢Ǵӧቩֽᆶ໒ֽӚБय़
Ψ೿ΠΑࡐεޑπϻǴჴΚ࣬྽୲மǶӢԜǴอයϣགྷᆶεഌ໗Ҵݾ໢ǴᜤࡋߚதεǶό
ၸǴаᏢೌБय़ٰᇥǴεഌຝ්ำԄޑբޣǴӧ೭ԛࣴ૸཮ύࠅؒԖΓஒځЇᔏמೌว߄
рٰǴࣗࣁёெǶ
ᗨฅҞ߻ႝတຝ්ӚБय़מೌςᖿԋዕǴՠ໒ֽБय़ϝ٩ᒘ໺಍ΓπᒡΕޑБԄٰࡌ
೷໒ֽ৤ǹύֽቩֽБय़Ψ҂Ԗ౛ፕ୷ᘵǴӚৎว৖ޑቩֽڄኧӚԖ܌ߏǹූֽБय़Ψѝ
᎞ΓπБԄ΋΋ೀ౛ǶаԜᢀϐǴႝတຝ්ޑמೌۘԖ೚ӭॶள໒วϐೀǶךॺი໗҂ٰ
ޑࣴزБӛǴஒᝩុว৖ႝတຝ්ӧၗૻሦୱޑמೌǴ٠аගϲځᏢೌሽॶࣁҞޑǶ
Οǵࡌ᝼٣໨
аҁԛୖᖻΓኧٰ࣮Ǵႝတຝ්΋໨ୖуΓኧᇻຬၸځд්ᜪǹฅԶࠅѝԖҁΓӧࣴ
૸཮΢ว߄ႝတຝ්מೌϐፕЎǴӢԜҁΓ׆ఈૈቚ຾ႝတຝ්Бय़Ӛ໨מೌޑҬࢬǴ٬
၀ሦୱ׳΢΋ቫኴǶ
ӧҁԛКᖻύǴεഌБय़зΓ၎ੰޑࢂԖ΋٤ำԄൔΑٿ໗ǴᙖԜቚуளӜޑᐒ཮ǶԶЪ
Ȩ්ϺεဃȩำԄޑբޣࢂЬᒤൂՏϐ΋ǴдॺߚՠؒԖߔЗǴϸԶၟ๱ൔΑٿ໗Ǵ٬ள
КᖻၸำᡂࣁܴݾསରǴзΓѨఈǶ
ќѦǴЬᒤൂՏচҁѺᆉԏ໣Кᖻ්᛼Ǵՠࡕٰ٠ؒԖೣᄇǴ΋Бय़٬ளКᖻၸำޑϦѳ
܄ᎁډ፦ᅪȐЬᒤൂՏ໗Ҵё࣮ډځд໗ޑ්᛼ȑǴќ΋Бय़٬ளКᖻ්᛼คݤֹ᏾Ϧ໒Ǵ
࣬྽ёெǶ
Ѥǵځд
ӧҁԛКᖻύǴନΑຝ්аѦǴၨڙᜢݙޑԖΐၡൎ්ǵᆶϤη්฻໨ҞǶځύΐၡ
ൎ්໨ҞΨࢂଯЋӵ໦ǴӅԖ 18ঁ໗ҴୖᖻǴനࡕҗऍ୯ޑMany Faces of GoำԄᕇளߎ
จǹѠ᡼നம໗ࣁܿ๮εᏢᚑγృ௲௤ޑ JimmyำԄǴᕇளಃΐӜޑԋᕮǶϤη්ࢂҬε
ֆኾԋ௲௤ബҥޑᖻֽ໨ҞǴҁԛКᖻӅԖ 10໗ୖᖻǴ٠җֆኾԋ௲௤ޑ NCTU6-Liteำ
ԄᕇளߎจǶ
出席國際學術會議心得報告
計畫編號 96-2221-E-001-004-
計畫名稱 巨量資料中的圖學理論及演算法研究(3/3)
出國人員姓名
服務機關及職稱
陳柏年
台灣大學資訊工程研究所 博士生
會議時間地點 北京 2008/9/28 ~ 2008/10/5
會議名稱 電腦與賽局國際研討會暨電腦奧林匹亞棋類競賽
發表論文題目 Knowledge Inferencing on Chinese Chess Endgames
一、參加會議經過
本屆電腦與賽局國際研討會（Computer and Games 2008）暨電腦奧林匹亞棋類競賽(13th
Computer Olympid) 於西元 2008 年 9 月 28 日~10 月 5 日在北京舉行。主辦單位為
International Computer Game Assocation (ICGA)，會場則是在金世紀高爾夫俱樂部之
會議中心。本團參加的除本人外，還有電腦象棋參賽程式「天馬行空」的作者沈秉杰。
會議的議程共分為三天，首日的議程多為搜尋相關技巧，較為特別的內容有：1. 西
洋棋盤面特徵學習，其研究目的是以盤面特徵的辨識來訓練人類西洋棋手；2. 以自動建
立邊界資訊的方式，提升圍棋程式的搜尋效率；3. 以 Bayesian 計分系統來改良目前廣
泛被使用的 ELO 計分系統。
本人的 oral presentation 排在第二日早上第二個 section。主要報告本人在電腦
象棋殘局方面的新技術與研究成果，以自動推論的方式產生合理的殘局兵種勝和資訊，
以取代人工輸入，以提升效率並仍維持其正確性。presentation 中其它西洋棋專家均表
示十分 interesting，並且報告之後問了三、四個問題，休息時候更有多人前來交換意
見心得，在交流上收益良好。
第二日的其他議程則以圍棋、蒙地卡羅技術為主軸，舉例說明如下：1. 使用 partial
region 技術處理圍棋死活問題，提高大棋塊死活判斷的正確性與效率；2. 使用 Monte
Carlo Tree Search 方法在 LOA (Lines of Action)遊戲上，並且改良演算法以增進棋力。
第三日的議程主要探討 Proof Number Search 及 Parallel Monte Carlo Tree Search
等技術，較值得注意的內容有：1. 使用 Dynamic Widening 技術來解決 Proof Number
Search 中遇到 unpromising 節點時，Proof Number 大為增加的困境； 2. 比較三種
Parallel Monte Carlo Tree Search 演算法：leaf parallelization, root
parallelization, tree parallelization，並經由實驗結果判斷認為 root
parallelization 為最好的方式。
本次 Computer Olympiad 中電腦象棋項目共有 18 隊參加，其中台灣隊伍共有三隊，
包括我們團隊的「天馬行空」，作者是徐讚昇教授指導的學生沈秉杰、「象棋世家」由鄭
明政先生研發、以及「棋謀」是由交大吳毅成教授的團隊所研發。由於地主國大陸方面
派出 14 隊參加，並且有許多隊伍實力堅強，在經過 11 輪雙方分先的瑞士制比賽後，最
