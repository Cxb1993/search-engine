I 
目錄 
目錄....................................................................................................................................................................... I 
圖目錄................................................................................................................................................................ III 
表目錄................................................................................................................................................................ VI 
摘要................................................................................................................................................................... VII 
Abstract ........................................................................................................................................................... VIII 
1. 前言(Introduction) ....................................................................................................................................... 1 
2. 文獻(Releated Work) ................................................................................................................................... 4 
2.1. Loopback.......................................................................................................................................... 4 
2.1.1. 開放式迴圈(Open loop) ...................................................................................................... 4 
2.1.2. 關閉迴圈(Close loop) .......................................................................................................... 4 
2.2. MDC 編碼技術(Multiple description coding) ................................................................................ 5 
2.3. Loopback-MDC ............................................................................................................................... 5 
2.4. 客戶端儲存空間管理(Buffer management) ................................................................................... 6 
3. 描述串流分配機制探討(The Policy of Selecting Descriptions of Loopback-MDC) ................................ 8 
3.1. ORD 分配(ORDered descriptions assigment) ................................................................................. 8 
3.2. RR 分配(Round-Robin descriptions assigment) ............................................................................ 9 
3.3. OLF 分配(Open-LoopFirst descriptions assigment) ...................................................................... 9 
3.3.1. OLF 分配策略 ................................................................................................................... 10 
3.3.2. OLF 演算法 ....................................................................................................................... 11 
3.4. 效能評估與分析(Performance evaluation) ................................................................................... 14 
3.5. 結論(Conclusion) ........................................................................................................................... 15 
4. 描述串流修復機制(Mechanisms of Failure Description Recovery) ........................................................ 17 
4.1. 縫合式修復(Sewing recovery) ...................................................................................................... 17 
4.1.1. 找出開放式迴圈................................................................................................................ 18 
4.1.2. 篩選受影響最多的客戶端的候選迴圈............................................................................ 18 
4.1.3. 挑選客戶端緩衝時間最長的候選迴圈............................................................................ 19 
4.2. 補丁式修復(Patching recovery) .................................................................................................... 19 
4.3. 補丁式修復條件(Requirements of patching recovery)................................................................. 20 
4.3.1. FP 加入時間小於或等於父客戶端儲存空間結束時間 .................................................. 20 
4.3.2. FP 中 bf 最大的影格編號必須大於或等於子客戶端 bf 中最大的影格編號 .............. 20 
4.3.3. FP 中 bf 最小的影格編號必須小於或等於子客戶端 bf 中最大的影格編號 ............... 21 
4.4. 連續離開的客戶端之問題探討(The continuity of client leaves) ................................................ 21 
4.5. 效能評估與分析(Performance evaluation) ................................................................................... 22 
4.5.1. 離開的客戶端分佈情況.................................................................................................... 22 
4.5.2. 伺服器頻寬耗用................................................................................................................ 22 
4.5.3. 修補成功率........................................................................................................................ 23 
4.6. 結論(Conclusion) ........................................................................................................................... 24 
5. 系統設計與實作(Design and Implementation of the Loopback-MDC) ................................................... 25 
5.1. 多媒體前處理(Preprocess, Preprocess of multimedia sources) .................................................... 26 
III 
圖目錄 
Figure 1 CDN-P2P network. ................................................................................................................ 1 
Figure 2 Architecture of the Loopback-MDC. .................................................................................... 2 
Figure 3 Loopback 運作示意圖 .......................................................................................................... 4 
Figure 4 Loopback-MDC 示意圖 ........................................................................................................ 5 
Figure 5 Loopback-MDC 之 OLF 分配 .............................................................................................. 6 
Figure 6 客戶端儲存空間管理示意圖 .............................................................................................. 7 
Figure 7 Loopback-MDC 運作示意圖 ................................................................................................ 8 
Figure 8 ORD 描述串流分配範例 ...................................................................................................... 8 
Figure 9 RR 描述串流分配範例 ......................................................................................................... 8 
Figure 10 OLF 描述串流分配範例..................................................................................................... 9 
Figure 11 延長開放式迴圈策略範例 .............................................................................................. 10 
Figure 12 加強迴圈堅韌度策略範例 .............................................................................................. 10 
Figure 13 考慮祖先同儕儲存空間排列的比較 .............................................................................. 11 
Figure 14 需考量儲存空間的祖先同儕範例 .................................................................................. 11 
Figure 15 找出開放式迴圈演算法 .................................................................................................. 12 
Figure 16 加強迴圈堅韌度的候選描述串流的演算法 .................................................................. 13 
Figure 17 篩選加強迴圈堅韌度策略的描述串流演算法 .............................................................. 13 
Figure 18 不同的使用者儲存空間容量之代理伺服器上傳頻寬的比較 ...................................... 14 
Figure 19 不同到達率之代理伺服器上傳頻寬的比較 .................................................................. 14 
Figure 20 儲存空間容量和到達率對 OLF 的影響......................................................................... 15 
Figure 21 未執行跨串流描述修復機制的縫合式修復的迴圈 ...................................................... 17 
Figure 22 執行跨串流描述修復機制中的縫合式修復後的迴圈 .................................................. 17 
Figure 23 尋找開放式迴圈的演算法 .............................................................................................. 18 
Figure 24 篩選受影響最多的客戶端的候選開放式迴圈演算法 .................................................. 18 
Figure 25 挑選客戶端緩衝時間最長的候選開放式迴圈的演算法 .............................................. 19 
Figure 26 未執行跨串流描述修復機制中補丁式修復的迴圈 ...................................................... 19 
Figure 27 執行跨串流描述修復機制中補丁式修復後的迴圈 ...................................................... 19 
Figure 28 補丁式修復運作方法 ...................................................................................................... 19 
Figure 29 補丁式修復執行失敗範例 .............................................................................................. 20 
Figure 30 補丁式修復演算法 .......................................................................................................... 21 
Figure 31 補丁式修復執行成功範例 .............................................................................................. 21 
Figure 32 單一離開的客戶端 .......................................................................................................... 21 
Figure 33 連續離開的客戶端 .......................................................................................................... 21 
Figure 34 伺服器支援客戶端示意圖 .............................................................................................. 22 
Figure 35 不同丟棄率之集中率的比較 .......................................................................................... 23 
Figure 36 不同丟棄率之代理伺服器上傳頻寬的比較 .................................................................. 23 
Figure 37 不同丟棄率之成功率的比較 .......................................................................................... 23 
Figure 38 Architecture of implementation of the Loopback-MDC. .................................................. 25 
Figure 39 YUV subsampling formats. ............................................................................................... 26 
V 
Figure 81 Conception of gap. ............................................................................................................. 53 
Figure 82 State representation of network transfer controlling. ........................................................ 54 
Figure 83 Graph of decision ofrelationions. ...................................................................................... 54 
Figure 84 State representation of player speed controlling. .............................................................. 54 
Figure 85 Protocols working flow of the Loopback-MDC. ............................................................... 55 
Figure 86 Protocol communication of peer register. ......................................................................... 56 
Figure 87 Protocol communication of video request. ........................................................................ 56 
Figure 88 Protocol communication of provider identification. ......................................................... 57 
Figure 89 Decision graph of stream range identification. .................................................................. 57 
Figure 90 Protocol communication of intra-description recovery. .................................................... 58 
Figure 91 Protocol communication of inter-description recovery. .................................................... 58 
Figure 92 Protocol communication of data received. ........................................................................ 59 
Figure 93 Protocol communication of end of stream. ........................................................................ 59 
Figure 94 Protocol communication of buffer space updating. ........................................................... 59 
Figure 95 Protocol communication of buffer range updating. ........................................................... 59 
Figure 96 One case of peer scripts. .................................................................................................... 61 
Figure 97 Practical experiment network topology ofimplementation of the Loopback-MDC. ......... 61 
Figure 98 Experiment result of open loop(s) duration varied by arrival rate. ................................... 62 
Figure 99 Experiment result of open loop(s) duration varied by failure rate. ................................... 62 
Figure 100 Experiment result of open loop(s) duration varied by quality. ........................................ 63 
Figure 101 Experiment result of open loop(s) duration varied by descriptions. ............................... 63 
Figure 102 Experiment result of total failure recovery. ..................................................................... 64 
Figure 103 Experiment result of sewing recovery rating to total recovery. ...................................... 65 
Figure 104 Experiment result of average intra-description recovery duration. ................................. 66 
Figure 105 Experiment result of average inter-description recovery duration. ................................. 67 
Figure 106 Experiment result of server loading. ............................................................................... 68 
Figure 107 Four descriptions combined frame of 0th frame of chunk 6. .......................................... 70 
Figure 108 Experiment result of CPU usage. .................................................................................... 71 
Figure 109 Experiment result of working set usage. ......................................................................... 72 
Figure 110 One case of Loopback-MDC sewing recovery network topology. ................................. 73 
Figure 111 Descriptions combined result of 5-9th frame of chunk 9 in P5. ...................................... 74 
Figure 112 Descriptions combined result of 0-4th frame of chunk 10 in P5. .................................... 75 
  
VII 
摘要 
 
隨著網路的頻寬快速提高，更多使用者直接在 VoD (Video-on-Demand)伺服器中點選喜歡的影片來
進行觀看，如何有效率的提供多媒體影音串流服務，變成一項非常值得關注的議題。本計畫主要討論
在 CDN-P2P 混合架構模式下，以 Loopback 機制運用 MDC (Muliple Description Coding)多重描述編碼
技術的概念，來解決同儕間頻寬異質性的議題，讓使用者可依需求來享有不同的隨選視訊觀看品質。
其中我們提出 OLF (Open-Loop First)方法，在分配描述串流時，考量 Loopback 機制的堅韌度和可用度，
提升代理伺服器的延展性，以提供使用者更好的多媒體傳輸服務。接著在 Loopback-MDC 架構上，我
們進一步管理客戶端中的暫存空間以及採用跨串流描述修復機制提出S&P (Sewing & Patching)修復法，
來解決當客戶端中途離開時，造成代理伺服器負載提高的議題，藉此提升代理伺服器的延展性，降低
使用者的中途離開而影響其他使用者的觀看，並提供使用者更好的多媒體影音串流服務。最後我們實
作 Loopback-MDC 所提出之機制，由實際網路環境觀察機制之效能如迴圈延伸性、錯誤回復效能與伺
服器負擔等驗證 Loopback-MDC 是否仍具有其優勢。本計劃預計發表 P2P 串流相關六篇 SCI 國際期刊
論文，四篇研討會論文，其中包含兩篇國際研討會論文與兩篇 NCS 會議論文，另外以 Loopback-MDC
系統實作為主題之期刊論文預計發表於 Multimedia Tools and Applications。 
 
關鍵詞：回傳迴圈、多重描述編碼、開放式迴圈優先、錯誤回復、H.264/AVC  
1 
1. 前言(Introduction) 
VoD(Video-on-Demand)伺服器主要在提高系統的延展性(scalability)，每當大量的客戶端觀看請求
到達(flash crowd)或離開時，伺服器希望有足夠的頻寬和儲存空間來解決這些突如其來的情況。傳統的
客戶端-伺服器(Client-Server)架構，採用的是集中式管理方法，優勢在於確保品質，但當有大量請求，
系統無法負荷，可能導致使用者觀看的滿意度會降低。後來有許多學者針對所發生的情況提出了一些
改善的作法，例如 Batching [1] [2] [3] 、Patching [4] [5] [6] 等技術，但上述所提到的數種作法皆建立
在 IP 多播(IP multicast)。但在目前已存在的網路架構上，實作並不容易。因此學者後續進一步提出 CDNs 
(Content Distribution Networks)架構概念 [7] [8] [9] ，即在現有的網路基礎架構中，以區域為單位設立
多台代理伺服器，並將影片內容放置於中，藉由這些伺服器來分擔單一伺服器的負載，避免無法負荷，
但若要增加延展性，則須大量提高成本與資源。而後來的 P2P (Peer-to-Peer) [10] [11] [12] 架構運用客
戶端為服務端亦為接受端的特性，使客戶端暫存空間中的影片內容，可以與其它客戶端進行影片傳送，
支援伺服器固定的頻寬，進一步降低伺服器的負載。當大量的客戶端請求出現，可以提供大量的頻寬
來支援現有的伺服器頻寬，解決大量請求的問題，並提高 VoD 伺服器的延展性，但是 P2P 的劣勢在
於客戶端的加入以及離開，並非伺服器可以控管。因應上述的問題，有學者提出 Loopback [13] 機制應
用在 CDN-P2P [14] [15] [16] 混合架構上，利用了現有的架構，並排除其缺點，使其具有高擴充性。 
Local network
Proxy server
Proxy server
Local network
Proxy server
Central server Local network
 
Figure 1 CDN-P2P network. 
在 CDN-P2P 中有中央伺服器(Central server)及多台代理伺服器(Proxy server)，如 Figure 1。中央伺
服器存放所有的影片來源，並提供代理伺服器影片內容以及支援代理伺服器來給予客戶端影片內容；
代理伺服器建構在各區域中，並負責暫存(cache)比較熱門的影片，提供區域下的客戶端進行影片傳送
的服務。若客戶端所請求的影片，代理伺服器已持有，則可直接由它來服務。代理伺服器持有的熱門
影片，可以提供大多數客戶端所需的服務，進而降低中央伺服器的負載程度。透過同區域和 P2P 的特
性，使得客戶端可以互相支援，讓影片內容可以更快速的進行分享並且穩定的傳送內容。當有多個客
戶端觀看同一部影片時，由最早觀看的客戶端來跟代理伺服器取得影片內容的片頭，再由客戶端之間
進行服務，不需要再經由代理伺服器或中央伺服器來服務，進而可以提高服務的數量。但在 Loopback
機制上，只提供了單一串流來服務客戶端，並且客戶端之間存在網路異質性的問題，造成伺服器要把
影片設定為最低的串流品質，才能讓大部份的客戶端互相順利傳遞串流。 
3 
伺服器無法預測客戶端何時離開系統，因此當客戶端中途離開系統而造成迴圈斷裂發生時，就必
須要有錯誤修復的機制。當客戶端中途離開伺服器，因而影響接續在它之下的其他客戶端正常觀看。
在原本的 Loopback-MDC 機制中，利用其他客戶端的緩衝區中重複的區塊資料，傳送給受影響的客戶
端，即可使其他客戶端依然可以正常的觀看，此方式稱為內部串流描述修復(Intra-description recovery)
機制。 
如果大量客戶端離開，將導致片頭不能長時間的在客戶端間流傳，來服務新進客戶端，導致中央
伺服器和代理伺服器負載上升，降低可以服務的數量。上述情況嚴重降低此架構的應用價值，本計畫
嘗試為上述問題尋求解決之道。所以在 Loopback-MDC 架構下，提出新的緩衝管理及跨串流描述修復
(Inter-description recovery)機制，讓客戶端在離開系統的時候不會造成中央伺服器和代理伺服器的負載
上升，並考量其優先修補順序，使得 Loopback-MDC 架構將可以更有延展性及堅韌度。跨串流描述修
復機制利用別條描述串流的資源，來修復客戶端的觀看品質，此類修復法的前提為支援的描述串流不
可為需被修復客戶端已持有的描述串流，我們在計畫中針對跨串流描述修復機制分別提出 S&P修復法，
分別為縫合式修復(Sewing recovery)與補丁式修復(Patching recovery) [17] 。 
在上述架構與演算法發展過程中，利用建立模擬實驗的方式來驗證演算法效能，但實際網路與使
用者行為也將影響 Loopback-MDC 之表現，為了驗證若將 Loopback-MDC 應用於多媒體串流網路環境
中是否仍具有其優勢，本計畫最後實現 Loopback-MDC 機制。建立於真實網路實驗環境，讓實作程式
在該網路環境中請求多媒體資源。系統除了將 Loopback-MDC 之機制實現外，為了符合實際使用情形，
我們加入真正的多媒體資料，以 Loopback-MDC 網路架構即時傳輸，並於同儕接收後進行播放。在多
媒體資料的請求上，我們制定了一套初步的 Loopback-MDC 通訊協定，以提供該機制的處理。而串流
的傳輸方面，為了易於實驗數據觀察，我們簡化 RTP (Real-time Transport Protocol) [25] [26] [27] 並省
略速度控制機制，最後將之與本實作之通訊協定結合。 
本文章節安排如下，第一節為本研究前言。第二節介紹相關背景知識。第三節講述描述串流分配
機制。第四節說明描述串流修復機制。第五節介紹所述機制之設計與實作。第六節為最後的結論。 
  
5 
Loopback 的錯誤回復(failure recovery)中，利用客戶端儲存空間中暫存的資料進行修復，以解決上述的
問題。如在某迴圈中，其同儕(Peer)傳送順序為同儕 A、同儕 B 與同儕 C，同儕 A 擁有影格 10 至影格
7，同儕 B 擁有影格 8 至影格 6，同儕 C 擁有影格 6 至影格 4，當同儕 B 離開伺服器時，同儕 A 可以為
同儕 C 提供所需的影格 7 以後的串流，因此迴圈的運作並不會受到同儕 B 離開，而影響其他同儕的影
片觀看。則可提升迴圈的堅韌度，增加客戶端觀看影片的穩定性。關於錯誤回覆的細節部分並不在本
篇討論的範圍內。 
2.2. MDC 編碼技術(Multiple description coding) 
近期，多媒體串流探討網路異質性議題。網路異質性，指網路上各個客戶端所持有的資源與頻寬
不一的情況，造成每個客戶端所要求的觀看品質有所不同。因此如果伺服器只提供單一版本的串流，
並無法滿足客戶端端多樣化的請求，且客戶端間因頻寬不同，難以分享與傳送串流。 
為解決上述議題，已有相關編碼技術被發表。編碼技術主要是將一條完整影片串流，編碼成多條串流，
當客戶端所接收到的串流數量越多，則代表客戶端獲得的影片觀看品質越好。因而可視客戶端的頻寬
來調整欲下載的串流數量，即可解決上述的問題，目前常見的編碼技術分為 Layer encoding [36] [37] 和
MDC encoding。 
MDC 編碼技術是將完整的影片編碼成多條的串流。每條描述串流並不具有相依性及順序性的限制，
只要任意接收不同編號的描述串流，所獲得的封包內容越多，即可提升客戶端的觀看品質，因此可以
更有彈性的調整影片品質。 
2.3. Loopback-MDC 
Loopback-MDC 採用 CDN-P2P 混合架構，假設進來觀看影片的客戶端都擁有暫存影片內容的能力
和動態暫存影片內容於儲存空間中，因此客戶端能利用儲存空間中的暫存內容進行串流傳輸給其它客
戶端，但客戶端在進行傳送時，可能發生失敗或是中途離開伺服器。 
Open loop
new client
join
Close loop
description 1
description 3
description 2
 
Figure 4 Loopback-MDC 示意圖 
每個代理伺服器建立在區域網路上，並且暫存較熱門的影片的前半段影片內容，來服務同區網中
的客戶端。在相同區域的客戶端觀看一樣的影片時，會依進入的時間，循序產生數個迴圈，當客戶端
送出請求時，代理伺服器提供串流服務，但當代理伺服器無法滿足客戶端的請求時，或是客戶端已經
觀看到影片片尾時，則由中央伺服器來提供所需的影片內容。在代理伺服器中的影片內容透過 MDC
編碼機制，產生多條的描述串流，如 Figure 4。客戶端可依其請求來接收描述串流數量，即客戶端接受
的描述串流數量越多，表示其觀看品質越高；接受到全部的描述串流數量，表示此客戶端所觀看的影
片為最佳品質。當第一個進來的客戶端根據自身所須的請求從代理伺服器取得數條描述串流的影片片
頭，來進行觀看。在進行一段時候後，將可服務後來加入迴圈中的客戶端當影片片頭一直保持在客戶
7 
個時間單位，客戶端儲存空間為 sb，利用公式(1)與(2)將 sb，畫分成為 bf 和 bp 二區段，在 bf 中有一時
間單位表示客戶端正在觀賞的影片內容，其它為 bf，代表客戶端將在未來會觀賞到的影片內容，而 bp
表示客戶端已經觀賞後的影片空間。 
   ⌊
      
 
⌋         
            
如 Figure 6為客戶端儲存空間分配情況，假設中間那個空白方格代表一個單位時間的正觀看內容，
斜線部份代表未觀看內容，網狀部份代表已觀看內容。 
Client buffer
bf bp
未觀看的影格
正觀看的影格
已觀看的影格
 
Figure 6 客戶端儲存空間管理示意圖 
  
9 
當同儕的頻寬需求相同時，可節省上傳頻寬數量，但同儕的頻寬需求差異大時，描述串流編號較
大的迴圈，因為少有同儕加入，會形成多個擁有單一或少數同儕的迴圈。因此，ORD 分配較適用於同
儕的頻寬需求大致相同的環境。 
3.2. RR 分配(Round-Robin descriptions assigment) 
RR 分配是讓每條描述串流都平均分配給同儕，讓每條描述串流平均被伺服器中的同儕所持有。當
有客戶端請求發生，則依描述串流編號依序輪流進行分配。Figure 9 為 RR 分配範例，當同儕 A 請求二
條描述串流的觀看品質，分配 d1 和 d2 給同儕 A。同儕 B 到達並請求三條描述串流，伺服器接續分配
d3 和 d4 給同儕 B，再分配 d1。當同儕 C 請求到達時，再接續分配 d2，以此類推。 
在 RR 分配中，當請求的到達率較高時，所有描述串流中的迴圈仍維持開啟的狀態，可減少伺服器
上傳頻寬數量，且當有同儕請求最佳品質時，也不需由伺服器來提供資源，同儕間即可滿足其請求。
但是當同儕的到達率低或平均同儕需求品質低時，伺服器提供的上傳頻寬數量反而增加，因為低到達
率讓同儕間儲存空間內容無法銜接，迴圈由開啟狀態轉為關閉狀態，使下一個同儕在加入後，需開啟
新的迴圈，如此伺服器提供的上傳頻寬數量反而增加，其負載也增加。所以 RR 分配較適用於同儕高
到達率，且請求觀看品質不一致的情況。 
3.3. OLF 分配(Open-LoopFirst descriptions assigment) 
OLF 描述串流分配，主要在進行描述串流分配時，需以開放式迴圈為優先分配的對象。如一部影
片共有 5 條的描述串流，2 條為開放式迴圈，3 條為關閉迴圈，一個新加入的同儕，共要求 3 條描述串
流的覯看品質，因此系統會先優先分配 2 條開放式迴圈的描述串流給新加入的同儕，在迴圈為關閉狀
態的描述串流，開啟一條新迴圈，讓新加入的同儕加入，以達到欲觀看的品質。 
OLF 先找出為開放式迴圈的描述串流，再以這些描述串流進行分配，讓這些迴圈維持開啟的狀態，
因為新開啟一個迴圈，需花費一條代理伺服器的上傳頻寬。如公式(3)，找出開放式迴圈的描述串流集
合，假設 O 為開放式迴圈的描述串流的集合，當迴圈最後一個同儕的儲存空間結束時間大於或等於新
同儕加入時間 NowTime，則為開放式迴圈的描述串流。且影片共分為 m 條的描述串流，  為描述串流
d 迴圈中所有的同儕數量，  為描述串流 d 的迴圈中最後一個同儕，    為描述串流 d 的迴圈中最後一
個同儕的加入時間，    為描述串流 d 的迴圈中最後一個同儕的儲存空間長度。 
  { |        (         )      }     
 
Figure 10 OLF 描述串流分配範例 
Figure 10 為 OLF 分配範例，分配 d1 和 d2 給同儕 A 後。同儕 B 到達並請求三條描述串流，伺服
器優先分配開放式迴圈的描述串流 d1 和 d2 給同儕 B，無法滿足同儕 B 請求的三條描述串流的請求，
所以再開啟 d3 的迴圈分配 d3 給同儕 B。如在第二節所提到的，在 Loopback 機制中，盡量保持迴圈為
開啟的狀態，以利新的同儕加入原有的迴圈中，可顯著地節省伺服器頻寬的問題，因此當有請求發生
時，優先分配迴圈為開啟狀態的描述串流，讓迴圈維持開啟的狀態。Figure 10 的實線圈代表一個關閉
11 
加強迴圈堅韌度策略最主要是為了加強迴圈的堅韌度，使得同儕中途離開，其他同儕較不容易造
成觀看中斷。以 Figure 13 進行說明，假設每個同儕儲存空間長度皆為二個時間單位，當有連續三個時
間單位沒有同儕加入時，將使得前後同儕無法銜接，而導致迴圈斷裂。Figure 13 (a)為只考慮最後一個
同儕儲存空間的排列情況，Figure 13 (b)為除了考慮最後一個同儕儲存空間外，還考慮之前祖先同儕儲
存空間的排列情況，圖中呈灰色的同儕，指這些同儕離開伺服器時，將會造成迴圈斷裂，Figure 13 (a)
中共四個同儕為 C-1、D-1、E-2 與 F-1，Figure 13 (b)只有一個 D-1，因此當有同儕中途離開伺服器時，
Figure 13 (a)的同儕排列會比 Figure 13 (b)的同儕排列更容易發生迴圈斷裂的情況，使得伺服器需花更
多的資源進行錯誤回復，為受影響的同儕提供上傳頻寬。 
 
(a) 
 
(b) 
Figure 13 考慮祖先同儕儲存空間排列的比較 
在進行加強迴圈堅韌度策略，比較祖先同儕儲存空間需符合其儲存空間結束時間大於新加入同儕
的加入時間。因為當祖先同儕的儲存空間結束時間早於新同儕的加入時間時，新同儕的加入並不會為
此祖先同儕帶來影響。因為雙方沒有任何資料重疊的可能，此祖先同儕中途離開並不會直接影響新加
入同儕的影片觀看，因此沒有考量的必要。公式(5)中，集合 E 為搜尋所有迴圈中，倒數第 dec 個祖先
同儕可銜接新加入同儕的描述串流的集合，即需符合(                 )         。    為描述
串流 d 的第 i 個同儕的儲存空間長度；    為描述串流 d 的第 i 個同儕的加入時間。 
  { |(                 )         }     
Figure 14 為需考量儲存空間的祖先同儕範例。假設現在時間為 T4，也是下一個同儕 E 的加入時間，
每個同儕的儲存空間長度都是二個時間單位。同儕 D 儲存空間結束時間為 T5，     ，所以同儕 D
需列為祖先同儕的儲存空間比較名單，同儕 C 儲存空間結束時間為 T4，因此同儕 C 也需進行比較，同
儕 B 儲存空間結束時間為 T3，     ，同儕 B 和同儕 E 無法銜接，因此在同儕 B 以前加入的同儕(包
括同儕 B)不被進行比較。圖 10 程序如下，當同儕 E 要求一條描述串流，進行描述串流 d1、d2 比較，
選擇其一加入，d1 和 d2 中最後一個同儕 D 儲存空間結束時間相同，因此往前一個祖先同儕 C 比較，
d1 和 d2 中同儕 C 儲存空間結束時間相同，再往前一個同儕比較，d1 的同儕 B 儲存空間結束時間 d2
的同儕 A 儲存空間結束時間皆小於同儕 E 加入時間，因此不需再比較，而同儕 E 選擇 d1 和 d2 的迴圈
中，同儕數量較少者加入即可，主要為平衡迴圈中的同儕數。 
 
Figure 14 需考量儲存空間的祖先同儕範例 
3.3.2. OLF 演算法 
OLF 分為 3 步驟，找出開放式迴圈，加強迴圈堅韌度策略的候選描述串流，篩選加強迴圈堅韌度
策略的描述串流，分述如下。 
13 
Figure 15 找出開放式迴圈演算法，新加入同儕請求描述串流時，系統優先尋找目前開放式迴圈的
描述串流的集合 O，若描述串流數量集合 O 數量等於同儕請求數量     ，則直接分配描述串流給請
求的同儕，且分配的描述串流不可為同儕己持有    ，若集合 O 數量不足再開啟描述串流的新迴圈讓
同儕加入，若集合 O 數量大於請求數量，再用加強迴圈堅韌度策略，篩選迴圈中祖先同儕緩衝結束時
間較早的描述串流，進行分配描述串流，直到滿足使用者的觀看品質的數量。 
3.3.2.2. 加強迴圈堅韌度策略的候選描述串流 
當集合 O 數量大於請求數量，進行描述串流的篩選。則需尋找不同描述串流的迴圈中，同順位的
同儕，進行加強迴圈堅韌度策略的篩選，進行同儕儲存空間結束時間比較，結束時間較早者，其描述
串流優先進行分配。dec 為遞減值是同順位的基準值，dec 初始值為 0，指迴圈中最後一個同儕，往前
推一位，則加 1。  為描述串流 d 的所有同儕的數量。當考量延長開放式迴圈策略，進行分配描述串
流後，仍然有多條候選描述串流的迴圈可為同儕提供串流，因此再從這些候選迴圈中，再找出祖先同
儕儲存空間結束時間較短的描述串流。 
Figure 16 為加強迴圈堅韌度的候選描述串流的演算法，找出祖先同儕儲存空間結束時間較短的描
述串流的集合 E，並且保留惕除掉的描述串流集合 AE，當篩選後的候選描述串流小於同儕所請求的描
述串流數量，再從其保留的描述串流集合 AE 繼續進行描述串流分配。 
 Find_Pre_Loop( ,  ,  ){
          ;
           for( 1, , ++){ 
                    { | ( ) ,, - , -
                                               };
           }
         
dec m E
LE E
d d m d
E E d T B NowTimed n dec d n dec
d d
d E

 
   

  ;
            return ;
     }
AE LE E 
 
Figure 16 加強迴圈堅韌度的候選描述串流的演算法 
 Check_Can_Loop(  ,  , , ){    
            // ,  
            if ( |   |  0 && | | 0)    
                            ;
                            Allocate  
            
E ND O AEnew
E AE
E LE
E
 

比較以前的祖先peer 已無節點比較
 ( );
//open loop =peer description
            else if ( |   |   )
                           Allocate  
       //open loop <peer description
            else if ( |   |   ) 
   
    
E NDnew
E
E NDnew


的數量 需求的 數量 
 ( );
的數量 需求的 數量
                       Allocate open loop
                           if ( | |  = 0 ) close loop loop
{ | }
                                
E
AE
E d d O 
 ( ); //把目前的 的數量分配完
//從 中開新的
                                    
    Allocate
if ( | |  0 )
                                     ;
                                     ;
                                     Check_Can_Loop(  ,  
E
AE
E AE
AE
E ND


 
 ( ); 
                          
 
, , ); 
           //open loop peer description
          else if ( |   |   > )
                    { | arg MIN( ), }, - , -
                    { | ,  };
    
d E
O AEnew
E NDnew
ME d d T B d Hnewd n dec d n dec
d d
AE d d E d ME

   
  
的數量> 需求的 數量
                ;
                    if(  |  | != 0 )
                                     Check_Can_Loop(  ,  , , ); 
          return  ;
}
E ME
AE
E ND O AEnew

 
Figure 17 篩選加強迴圈堅韌度策略的描述串流演算法 
3.3.2.3. 篩選加強迴圈堅韌度策略的描述串流 
在上一個步驟，找出加強迴圈堅韌度策略的候選描述串流後，則進行篩選加強迴圈堅韌度策略的
描述串流。若候選描述串流數量剛好滿足新加入的同儕所請求的數量，則直接進行分配。若候選描述
15 
在 Figure 19 中，假設所有使用者的儲存空間長度都是 4 個時間單位，可觀察出 ORD、RR 和 OLF
中，OLF 在不同的到達率下都是最節省代理伺服器上傳數量。在到達率為 0.125，三種方法所得到的代
理伺服器的上傳頻寬皆相同，指的是在極低的到達率下，所有方法中加入的同儕皆無法接續在前一個
請求的同儕，因此代理伺服器的上傳頻寬皆相同。當到達率為 0.125 至 0.5，ORD 和 OLF 的代理伺服
器上傳數量較相近，因為 ORD 由編號較小的描述串流依序分配，因此編號較小的描述串流容易有同儕
加入。當到達率低時，編號較小的描述串流依然可保有開放式迴圈的狀態。OLF 挑選描述串流時，考
量開放式迴圈為優先加入，讓迴圈維持開啟的狀態，可使得代理伺服器減低開啟新迴圈的機會，也是
減少代理伺服器的上傳頻寬。而 RR 依描述串流編號依序加入同儕，當到達率低時，將導致同一個描
述串流中的前後同儕到達時間差異過大，而前一個同儕的儲存空間已沒有片頭可以提供服務，因此後
來的同儕只能不斷的向代理伺服器發出請求，導致代理伺服器上傳頻寬激增，這種情況當到達率越低
越顯著。而 RR 在到達率為 0.125 至 0.5 反而遞減，並不是代理伺服器上傳頻寬增加的問題得到改善，
而是因為過低的到達率，即是使用者的請求銳減，而導致代理伺服器的上傳頻寬減少。在到達率為 1
至 8 時，RR 和 OLF 的代理伺服器上傳頻寬較接近，當到達率高時，RR 可以讓所有的描述串流中的迴
圈維持開啟的狀態，而 OLF 主要考量開放式迴圈為優先加入，因此代理伺服器上傳頻寬皆維持最低。 
Figure 20 評估儲存空間容量和到達率對 OLF 的影響中，OLF 方法用四種不同使用者儲存空間長度
大小。儲存空間容量為 1，其長度代表 1 個時間單位。在圖中可得知，當到達率越高時，所需的代理
伺服器上傳頻寬越小，因為描述串流的迴圈中的同儕，在短時間內即可有下一個同儕加入，因此所有
的描述串流的迴圈皆維持開啟的狀態，則可更加節省代理伺服器上傳頻寬。當使用者儲存空間長度越
長時，所需的代理伺服器上傳頻寬也越小，因為描述串流的迴圈中的同儕有較長的時間來等待下一個
加入的同儕。 
0
500
1000
1500
2000
2500
3000
3500
1 2 3 4 5
pr
ox
y 
se
rv
er
上
傳
數
量
(d
es
cr
ip
ti
on
)
到達率(peer數量/單位時間)
buffer size =1
buffer size =2
buffer size =3
buffer size =4
 
Figure 20 儲存空間容量和到達率對 OLF 的影響 
3.5. 結論(Conclusion) 
利用 MDC 編碼技術，使得 Loopback 機制在網路的異質性問題下，也可以進行串流傳輸，並且對
編碼後的描述串流，以維持迴圈開啟為準則。OLF 分配考量目前網路平均的描述串流需求量來進行適
量的傳輸，及 Loopback 結構上的堅韌度和可用度。當有同儕中途離開系統時，降低原本迴圈發生斷裂，
減少影響其他同儕接收串流。且使維持影片的開頭在同儕端，使得新加入的同儕可以不必再向伺服器
請求資源，而節省整體的伺服器負載。模擬實驗結果證實，OLF 方法優於 ORD 和 RR，主要是因為維
持迴圈為開啟的狀態，且可發現足夠的同儕緩衝空間長度和到達率將可讓 OLF 方法達到較佳效能。 
17 
4. 描述串流修復機制(Mechanisms of Failure Description Recovery) 
Loopback-MDC 是假設於 CDN-P2P 架構下，利用客戶端的資源，為其他客戶端服務。伺服器無法
預測客戶端何時離開系統，因此當客戶端中途離開系統時，造成迴圈斷裂發生時，在錯誤回復中，可
分為內部串流描述修復機制 (Intra-description recovery)和跨串流描述修復機制 (Inter-description 
recovery)。 
內部串流描述修機制部分，當客戶端中途離開伺服器，因而影響接續在它之下的其他客戶端正常
觀看。在原本的 Loopback-MDC 機制中利用其他客戶端的儲存空間中的重複的影格資料，傳送給受影
響的客戶端，即可以使其他客戶端依然保有正常的觀看。 
跨串流描述修復機制部分，在原本的 Loopback-MDC 機制中，需要有其他客戶端暫存重複的資料，
才能進行內部串流描述修復機制，如果沒有任何同儕有暫存其需要的資料，則需由伺服器進行錯誤回
復。所以我們提出了跨串流描述修復機制，可以利用別條描述串流的資源，來修復同儕的觀看品質，
其中補丁修復法的前提為支援的描述串流不可為需被修復客戶端已持有的描述串流。例如：一部影片
分為四條的描述串流，客戶端 x 請求三條描述串流，分別為描述串流 1、描述串流 2 與描述串流 4，提
供描述串流 2 給客戶端 x 的客戶端 x-1 中途離開系統，無法進行內部串流描述修復機制，客戶端 x 面臨
缺少第 n 個影格，只能從描述串流 3 的迴圈當中，尋找有沒有第 n 個影格。 
在跨串流描述修復機制中，可分二大修復步驟的方法：縫合式修補與補丁式修補。當錯誤發生時，
依序進行修補方法，直到完成錯誤回復，以下進行這二種修復方法的詳細說明。 
4.1. 縫合式修復(Sewing recovery) 
當描述串流中的迴圈將會發生斷裂時，無法利用內部串流描述修復機制時。在跨串流描述修復機
制中先進行縫合式修復法，移動其它描述串流的客戶端來修補這條斷裂迴圈，使迴圈能繼續完整串流
傳送，不需要拆成二條迴圈，避免伺服器再多提供一條上傳頻寬；且遺失的資料，無法被其它客戶端
修復時，暫由伺服器進行修補，在伺服器傳送完遺失的資料後，即可停止支援，以節省伺服器頻寬。
被移動的客戶端其前提為不可造成原本迴圈發生斷裂。 
 
Figure 21 未執行跨串流描述修復機制的縫合式修復的迴圈 
 
Figure 22 執行跨串流描述修復機制中的縫合式修復後的迴
圈 
如 Figure 21、Figure 22 所示，假設每個客戶端儲存空間為三個時間單位，因此當有三個時間單位
沒有客戶端銜接時，則將造成迴圈斷裂。每個客戶端依其所需品質來決定它持有的描述串流數，如Figure 
21 中客戶端 B 請求最佳品質，即持有四條描述串流為 B-1、B-2、B-3 與 B-4。Figure 21 說明當客戶端
D 中途離開系統時，d1 和 d4 因為客戶端 D 的離開而產生迴圈斷裂。因此，我們先進行縫合式修復，
如仍未修補成功，則再進行補丁式修復。如 Figure 22 所示，利用縫合式修復把 d2 中的 C-1 加 d4 的迴
圈中，即把 d2 中的 C-1 移入 d4 的迴圈中，因為客戶端 C 未持有 d4 的資料，因此不影響客戶端 C 的
正常觀看。但客戶端 C 未持有 d4 的資料，無法為 d4 中的 E-2 進行串流傳送，因此需要由伺服器進行
短暫的支援，為客戶端 E 傳送 d4 的資料，直到 d4 中的 C-1 從 d4 中的 B-4 接收到 d4 的串流資料，則
19 
4.1.3. 挑選客戶端緩衝時間最長的候選迴圈 
當有相同受影響總數的迴圈時，再挑選迴圈中最後客戶端緩衝時間最長的優先修復。避免剛修復
完成的迴圈，因沒有較長的等待時間來等待新進客戶端的加入，使得迴圈變成封閉式迴圈，而不能服
務更多新進的客戶端。如 Figure 25 為挑選迴圈中客戶端緩衝時間最長的演算法。如公式(6)，找出緩衝
結束時間最晚的修補迴圈(failed loop)，假設 EN 為修補迴圈的集合，即需符合   (          )。       
為描述串流 d 的第 i 個客戶端；    為描述串流 d 的第 i 個客戶端的加入時間；    為描述串流 d 的第 i
個客戶端的緩衝時間。 
     { |   (          )      }     
/* buffer time failed loop*/
 last_buffer_time( ){
       | Max( ) ,  1, ,
       , };
}
  
EN
EN EN d T B dd j d j dd
m d EN
   
 
找出 結束時間較晚的
{ 
 
Figure 25 挑選客戶端緩衝時間最長的候選開放式迴圈的演算法 
4.2. 補丁式修復(Patching recovery) 
當進行縫合式修復後，如果還有客戶端無法順利的進行觀看影片時，再使用補丁式修復替受影響
的客戶端找尋其它可加入且客戶端尚未持有的描述串流的迴圈中，且可加入的描述串流。 
 
Figure 26 未執行跨串流描述修復機制中補丁式修復的迴圈 
 
Figure 27 執行跨串流描述修復機制中補丁式修復後的迴圈 
如 Figure 26 所示，當進行縫合式修復完後，還有一個 d4 未成功修補，再使用補丁式修復。利用補
丁式修復把 d1 中的 F-1 加 d3 的迴圈中，即把客戶端 F 中 d1 中的 F-1 移 d3 的迴圈中，如 Figure 27。 
FP
Pre-client
Post-client
 
Figure 28 補丁式修復運作方法 
Figure 28 為 FP 插入到別描述串流。父客戶端(Pre-client)和子客戶端(Post-client)為描述串流 x 中的
迴圈，FP 為描述串流 y 因發生迴圈產生斷裂而產生的錯誤客戶端，而 FP 所需的影片可加入描述串流 x
的迴圈內的父客戶端來取得，所以搬移 FP 到描述串流 x 中的迴圈時。FP 利用 bf 來降低 FP 進行搬移
所產生的影片延遲，而且描述串流 x 迴圈中的父客戶端和子客戶端因 FP 的加入，可能會發生傳輸影格
錯誤。如 Figure 29 所示，假設每個客戶端的儲存空間長度為 5，其 bf 為 3，bp 為 2，而 FP 為別條描
述串流發生斷裂後產生的錯誤客戶端，為了修復此客戶端，將 FP 加入別的描述串流有它需要的資料的
迴圈中。如 Figure 29 (a)所示，FP 插入到別的迴圈中的父客戶端 p1 和子客戶端 p2 之間，FP 清空 bp
區段，讓 p1 和 p2 來使用它，經過一單位時間後，如 Figure 29 (b)所示，p1 傳送影格 26 給 FP 再給 p2。
21 
4.3.3. FP 中 bf 最小的影格編號必須小於或等於子客戶端 bf 中最大的影格編號 
為確保在進行修補時，FP 有足夠的未觀看影格進行緩衝修補時間。如公式(9)，找出符合 FP 中 bf
最小的影格編號必須小於等於子客戶端 bf 中最大的影格編號的       。即符合             。    為
描述串流 d 的第 i 個客戶端未觀看儲存空間中最大的影格編號。      為發生錯誤描述串流 d 的第 i 個
錯誤客戶端未觀看儲存空間中最小的影格編號。 
                 
Figure 30 為滿足補丁式修復條件的演算法，找出滿足                、                  和
             這三個條件的       。 
0;
patching( ,  ) //
   repeat      
          ,
          |  , / /                      , , , ,
                 , / /, , , 1
                , ,
B
FID N
Peerd i
Peer T T pro peerd i fd fi d i d i
post peerd i fd fi d i
fd fi d
  
 

 
  

補丁式修復
0) / /     
                        patch_recovery();          
, ,1 ,
                 , , ;,
                EX EX - { };,
                if ( ,
  until   | E |
peer
Peer CXi d i
d N d O d H fd fi
Peerfd fi
Peerd i
N


  

找到可以進行修復的
 = 0
 
Figure 30 補丁式修復演算法 
30 29 28 27 26
28 27 26
26 25 24 23 22
P1
FP
P2
31 30 29 28 27
28 27 27
27 26 25 24 23
P1
FP
P2
32 31 30 29 28
28 28 27
28 27 26 25 24
P1
FP
P2
33 32 31 30 29
29 28 27
29 28 27 26 25
P1
FP
P2
(b) 在時間點N+1
(c) 在時間點N+2
(d) 在時間點N+3
(a) 在時間點N
 
Figure 31 補丁式修復執行成功範例 
補丁式修復成功範例，在 Figure 31 (a)FP 加入 p1 和 p2 之間已經先滿足前述三個條件。所以當三
個時間單位後，在 Figure 31 (d) p2 順利修補完影格 28 後，剛好接上 FP 正需接收影格 29，順利完成補
丁式修復。 
4.4. 連續離開的客戶端之問題探討(The continuity of client leaves) 
當迴圈產生斷裂時，在 Loopback-MDC 中，如果無法利用內部串流描述修復機制來修復此客戶端
時，將由伺服器來提供其客戶端所需的描述串流。 
2 3 4 5
 
Figure 32 單一離開的客戶端 
2 3 4 5
 
Figure 33 連續離開的客戶端 
如 Figure 32 所示，假設編號為 3 的客戶端因前面有客戶端中途離開，導致迴圈斷裂，經過修復後，
仍然無法銜接起來，此時由伺服器提供所需的描述串流，來服務編號為 3 的客戶端。但不是每個發生
錯誤的客戶端都需要由伺服器提供額外的上傳頻寬來進行修補。如 Figure 33 所示，由伺服器提供影格
23 
機制和 Loopback-MDC 內部修復因客戶端太少，所以無法成功修補，全由伺服器來進行服務。整體而
言，使用跨串流描述修復機制搭配 Loopback-MDC 將可以更有效的降低伺服器的上傳頻寬。 
 
Figure 35 不同丟棄率之集中率的比較 
 
Figure 36 不同丟棄率之代理伺服器上傳頻寬的比較 
4.5.3. 修補成功率 
以下為跨串流描述修復機制和 Loopback-MDC 內部修復法，再評估這二種分配方法於不同的丟棄
率下整體的堅韌度。在迴圈中當有客戶端一離開即造成迴圈斷裂，且無法利用儲存空間中重複的串流
資料進行內部修復，稱這些的客戶端為脆弱客戶端(fragility client)。我們定義一個成功率 ，其計算為
公式(11)。經修復後仍由客戶端服務的客戶端總數量為 ，脆弱客戶端總數量為 。當成功率 越高則代
表被修復的節點越多。 
  
 
 
     
如 Figure 37 所示，跨串流描述修復機制的成功率 比 Loopback-MDC 內部串流描述修復機制來得
高。因為在 Loopback-MDC 中的內部修復法只能利用其他的客戶端的儲存空間中的重複的資料，傳送
給受影響的客戶端。如圖 22所示，在丟棄率 10%中，S&P完全不受丟棄客戶端的影響，而 Loopback-MDC
內部修補出現 20%的客戶端數量需要由伺服器提供服務；在丟棄率 50%以上，因迴圈中的離開的客戶
端過多，導致修補成功率 大幅降低；在丟棄率達到 70%，因丟棄客戶端過多，所以迴圈中的客戶端無
法為下個客戶端服務，只能全部由伺服器提供所需的內容，導致成功率 為 0。整體而言，S&P 在丟棄
率 40%以下，可以更有效利用迴圈中的客戶端來為新進客戶端提供更多的服務，大部分的請求都可由
客戶端之間來進行服務。 
 
Figure 37 不同丟棄率之成功率的比較 
25 
5. 系統設計與實作(Design and Implementation of the Loopback-MDC) 
系統依功能規劃為五大區塊，分別為多媒體前處理(Preprocess of multimedia sources, Preprocess)、網
路架構(Network Infrastructure)與播放器(Player)，其中網路架構又分為伺服器(Server/Proxy)、同儕(Peer)
與函式庫(Library)。如 Figure 38 所示，來源多媒體資料將在前處理過程建立描述串流，並編碼為壓縮
之多媒體資料，提供伺服器的資源管理區塊(Resource)管理並傳輸。伺服器將與同儕進行通訊協定溝通
與資料傳輸，兩者功能分別由通訊協定區塊(Protocol)與傳輸區塊(Transmitter)實現，另外同儕間連線資
訊將由網路拓樸區塊(Topology)紀錄並處理。 
Topology
Server
Decoder
Combiner
Buffer Showing
Controller
Peer
Player
Preprocess
Preprocess
Service Next 
Peer
Database 
component
Library
Network 
component
Utility
Network transmission
Block  data input/output
Inherit
Block exchange data 
Resource
Transmitter
Protocol
Receiver
Protocol
Resource
Relay
 
Figure 38 Architecture of implementation of the Loopback-MDC. 
同儕也以通訊協定區塊(Topology)向伺服器溝通。當需要請求多媒體資料時，接收區塊(Receiver)
將向伺服器或同儕取得所需資料。當資料到達時，資料將儲存於資源管理區塊(Resource)。當其他同儕
向本機請求資料時，由轉送區塊(Relay)提供服務並進行資料的轉送。由於伺服器與同儕皆需要經由網
路進行溝通，這些功能將由函式庫(Library)提供，並將功能分類統整為資料庫元件(Database component)、
網路元件(Network component)與函式集(Utility)。資料庫元件提供基礎資源管理，網路元件提供基礎網
路處理，函式集提供共用函式。最後當資料到達並儲存於資源管理區塊後，播放器(Player)將以解碼器
(Decoder)解碼該資料，完成後儲存於緩衝(Buffer)。描述串流在合併元件(Combiner)處理後，將藉由在
控制器(Controller)的畫格率調節，於顯示元件(Showing)向使用者播放所要求之影片內容。 
27 
environmental batch file model)和影像編碼模組(Encoder model)，其中影像編碼模組採用 H.264/AVC 格
式。而本系統的 H.264/AVC 編碼器(Encoder)與解碼器(Decoder)皆使用聯合視訊團隊(Joint Video Team, 
JVT)所釋出的參考程式碼 JM (Joint Model) [28] 。其主要目的是為了產生能夠適應影像編解碼及影像串
流的條件的網路多媒體傳輸資料，並能夠提供使用者一定的服務品質(Quality of Service, QoS)。 
Execute batch file
PreProcesser
SMDC model
Encoder 
environmental 
batch file model
Encoder model
 
Figure 41 Architecture ofimplementation ofpreprocess. 
而前處理的資料流程如 Figure 42 所示，首先將切割的影片經 SMDC 模組產生子影片，也就是子描
述串流(Sub-description)。接著將編碼環境變數設定產生批次檔，最後執行批次檔並且進行影像編碼程
序，然後產生網路傳輸多媒體資料以及傳輸參數檔。 
Subfiles
Data
Function model
Execute Batch
file
Procedure
Action
SMDC modelYUV File
YUV 
Subfiles
Encoder 
environmental 
batch file model
Batch fileEncoder model
H.264 files 
and config
 
Figure 42 Data flow of implementation ofpreprocess. 
5.1.1. 子取樣多重描述編碼(Sub-sampling Multiple Description Coding model) 
由於 P2P 網路架構中，同儕間存在網路異質性，提供單一版本的多媒體串流很容易造成符合頻寬
條件的同儕才能順利進行多媒體傳輸。所以為了解決同儕間異質性的問題，我們將採用已發表的可調
式編碼技術的多重描述編碼(Multiple Description Coding, MDC)技術，主要選定的技術為 SMDC [29] 
[30] ，將多媒體串流編碼為多版本的描述串流。基於 JM的影像編碼格式之長寬必為 16的倍數的限制，
我們將輸入影像的大小限制為 CIF(Common Intermediate Format, 352 × 288)與 4CIF(704 × 576)，這樣
切割出來的描述串流才能經編碼模組正確地被編碼，以下皆以切割成 4 條描述串流為例。 
SMDC 輸入參數主要有影像高度(Height)、影像寬度(Width)、影像畫面數量(Number of Frames)與
切割數(Number of descriptions)─通常為 2 的次方數，高度及寬度為特殊格式─CIF 或是 4CIF，影像畫
面數量─基本上依照 YUV 的取樣而有所不同，而切割數量─依據個人需求而定。 
29 
關係則是 Y 資料索引位置向右偏移 1 位元為((bias + pos) right shift 1)，就是拿取 U 和 V 資料的索引位
置，且需要拿取的時機為行數為 4 的倍數及除四餘數為 3 的時候。 
0 1 2 3
4 5 6 7
8 9 10 11
12 13 14 15
0 2
8 10
1 3
9 11
4 6
12 14
5 7
13 15
SMDC
Des_0 Des_1
Des_2 Des_3
0 1 2 3
4 5 6 7
0 1 2 3
4 5 6 8
Y
U
V
0 4
0 4
1 5
1 5
2 6
2 6
3 7
3 7
 
Figure 45 Pixel distribution of SMDC method in YUV422. 
5.1.2. 編碼環境批次檔模組(Encoder environmental batch file model) 
經影像切割後，在進行影像編碼前，必須先針對編碼環境做參數的設定。透過參數的設定，更能
使得傳輸的多媒體資料更能符合實際傳輸的狀況，並提供使用者一定的服務品質。本系統採用聯合視
訊團隊所釋出的參考程式碼 JM，而 JM 的編碼環境參數主要經由檔案 encode.cfg 設定。 
Encoder
Description_1(YUV file)
Description_2(YUV file)
Environmental parameters
One chunk
(Consist of ten frames)
Set of 264 files 
produced from Description_1 
Set of 264 files 
produced from Description_2 
Batch file
 
Figure 46 Description is encoded to a set of 264files by Chunk’s conception. 
JM 編碼環境參數設定，主要牽涉兩大問題，且皆與解碼部分相關。第一個問題是解碼部分參考畫
面的數量，由於參考畫面緩衝區的限制(最大到 30 張)，所以解碼程序必須將一次的解碼畫面數量設定
31 
(Peer model)，同儕模組實現(Implement)同儕之主要功能如選擇影片、取得串流資料、提供轉送服務等，
由繼承(Inherit)函式庫模組方式完成之。伺服器的實現也分為函式庫模組與伺服器模組(Server model)，
伺服器模組實現伺服器之主要功能如影片管理、網路拓樸管理、提供串流服務等，由繼承函式庫模組
方式完成之。網路介面之基礎元件將被同儕與伺服器使用，主要加入各自的通訊協定(Protocol)並以之
作溝通。 
Peer model
Library  
model
Server model
Peer
Network 
Interface
Server/Proxy
ImplementImplement Implement
Protocol Protocol
Inherit Inherit
Relation
Data
 
Figure 47 Architecture of implementation of network infrastructure. 
5.2.1. 函式庫模組(Library model) 
函式庫模組提供共用元件如 Figure 49 所示，包含網路介面之基礎元件、資料處理相關之基礎元件
與函式集(Utility)，元件間關係如 Figure 48 所示。 
網路介面之基礎元件主要提供連線的進入或離開與資料的進入或送出之處理，此元件包含監聽者
(Accepter)與處理者(Handler)。監聽者具有監聽特定連接埠(Port)、管理新連線進入與離開之功能，而處
理者具有包裝並處理新連線，並與該連線以通訊協定進行溝通之功能。這兩種處裡單元構成網路介面
的基礎連線功能，通訊協定溝通則由同儕模組與伺服器模組繼承此元件並實作之。 
資料處理相關之基礎元件主要提供資料的儲存與管理，此元件包含阻塞佇列(Blocking queue)與資
源管理(Management)。阻塞佇列提供標準的佇列(Queue)方法如 Enqueue 與 Dequeue 等，為使系統資源
的使用最佳化，進一步在 Enqueue 與 Dequeue 函式中加入阻塞(Blocking)，形成具等候資源功能之阻塞
佇列。而資源管理則利用 C#內建的雜湊表元件提供最佳化與模組化的資源管理，並加入泛型(Generic)
適應為不同的資源管理元件。 
函式集提供多項共同函式，這裡主要介紹位元組複製(Copybytes)、位元組結合(Combinebytes)與執
行緒化(Threadlize1)，這些函式提供已最佳化之程式碼供函式庫模組、同儕模組與伺服器模組引用。 
Handler
Blocking 
Queue
Data
Management Accepter
handler
Utility
Data
 
Figure 48 Data flow ofimplementation oflibrary model. 
                                                 
1將函式獨立為新執行緒 (Thread)之過程 
33 
Figure 50 Implementation of Combinebytes. 
執行緒化為將函式封裝並獨立為新執行緒的函式。如 Figure 51 所示，實現方法為將 System.Action
類型的函式參數以執行緒啟動(System.Threading.ThreadStart)進行包裝，並在其中呼叫(Invoke)該函式，
最後以 System.Threading.Thread 包裝執行緒啟動並呼叫 Start 啟動之。 
new Thread(new ThreadStart((Action)(() => { 
 action.Invoke(); 
}))).Start(); 
Figure 51 Implementation of Threadlize. 
5.2.1.4. 處理者(Handler, Processor of network I/O) 
主要接管處理資料的傳送與接收。傳送部分提供一個函式 Send，Send 將輸出封包(OutPacket)封裝
為二進位區塊並在標頭加上封包長度，並將此區塊加入傳送排程。傳送排程由阻塞佇列實作，並以執
行緒逐一取得資料並送出。在接收部分，由於 C#之網路物件 System.Net.Sockets.Socket 並未將封包資
料集中後回傳，而是以接收緩衝大小 ReceiveBufferSize 為限制，提供開發者自行取出位元組資料。實
作上如 Figure 52 所示，我們將在基礎接收區塊每次讀取 1k 位元組的資料區塊，並以單位封包(Packet)
封裝之。由於所接收的資料長度不一樣，有可能小於 4 位元組，也可能超過一個集中封包的長度，所
以必須在每次讀取 1k 位元組的資料區塊後進行判斷與封包集中函式 ReserveHandle。 
byte[] buffer = new byte[1024]; 
int readed = socket.Receive(buffer); 
if (readed > 0) { 
 Packet packet = new Packet(buffer, 0, readed); 
 if (R == null) { 
  if (R_4 != null) packet = R_4.Append(packet); 
  R_4= null; 
  if (packet.Length > 4) L = packet.NextInteger(); 
  else R_4= packet; 
 } else { 
  packet = R.Append(packet); 
  R = null; 
 } 
 if (R_4== null) ReserveHandle(packet); 
 RCV = false; 
} 
if (RCV) Send(new byte[] { 0 }); // 送出測試連線封包 
RCV = !RCV; 
Figure 52 Part of implementation in Handler. 
封包集中方面，我們首先定義 L 為目前預期集中的封包長度，也就是接收進來的資料若達到 L+4
位元組則視為封包已集中，則將之與剩餘單位封包分離形成獨立封包，此時獨立封包便可進行通訊協
定之處理。R 為當資料長度大於 4 位元組且尚未達到   位元組時暫存單位封包之緩存區，R 將在下
次接收時與新的單位封包結合。  為當進來的資料小於 4 位元組時暫存單位封包之緩存區，系統將保
留該單位封包直到單位封包長度超過 4 位元組。另外為了偵測連線是否已中斷，我們採用送出測試封
包的方式確認。若連續兩次接收資料長度都為 0 的情況，則可能連線已經中斷。這個部分由布林值 RCV
偵測得知是否發生該情況，此時將送出長度為 1 的資料封包，促使 C#網路元件確認是否連線已中斷。 
在ReserveHandle的實作中如 Figure 53所示，首先判斷目前資料是否已達到資料長度為 L位元組。
若達成則將該資料以接收封包(InPacket)包裝，由通訊協定繼續處理之。然後判斷剩餘資料之長度是否
可以再繼續切割，此時一樣會判斷資料長度是否大於 4 位元組，若不大於則保留於 R_4，若大於則會
35 
Server
Transmitter Protocol Resource
Service 
Accepter
Peer Handler
Stream 
Handler
Videos Table
Descriptions 
Table
Allotments 
Table
Chunks 
Table
Stream 
Handler 
Management
Peer Handler 
Management
Loops Table
Topology
Stream 
Accepter
 
Figure 55 Architecture ofimplementation ofserver model. 
通訊協定區塊方面，同儕處理者負責與同儕溝通。我們將於文後說明部分實作如 OLF、取得提供
者(Provider request)、跨串流描述修復機制與同儕離線(Peer offline)。參照描述串流修復機制的實驗結果，
跨串流描述修復機制將僅實作縫合式修復。另外由於同儕的進入或溝通具有不同步的特性，對相同資
源存取將產生同步的問題。為了解決此一問題，我們設立資源同步鎖定，一旦某個執行緒需對資源進
行處理時，呼叫資源同步鎖定之鎖定函式後，其他執行緒將等候使用資源之執行緒執行完成並釋放後，
才能取得資源的使用權。 
在資源管理方面，影片表格管理伺服器中所有影片。影片儲存影像序列相關資訊，相關資訊包含
影片識別碼(Video ID)、標題(Title)、MDC 切割方法(Segmentation Method)、MDC 切割數量(Descriptions 
Count)、影片長度(Chunks per Description)、區塊畫面數(Frames per Chunk)、剩餘畫面數量(Frames of the 
Last Chunks)、FPS(Frame rate, Frames Per Second)、畫面尺寸(Width, Height)、YUV 格式(YUV format)
與實際儲存位置(Path)等。影片中具有一個描述表格，而描述表格則以描述串流管理各描述的區塊資料
表格與迴圈表格。區塊資料表格負責鎖定該描述的所有區塊資料，並在需要使用時讀取之，並將已讀
取的資料暫存於記憶體中，便於快速取得提升系統效能。迴圈表格則管理屬於該描述之迴圈集合，為
了保持在 Loopback-MDC 機制中迴圈之先後關係且易於管理，我們以動態陣列(Dynamic Array)結構管
理迴圈集合。而迴圈則儲存同儕間的網路拓樸關聯，在此也是以動態陣列方式來管理。迴圈表格與迴
圈相關操作將於文後說明。 
網路拓樸區塊方面，由於在通訊協定溝通時，同儕間的網路拓樸資訊需時常存取。為了降低在網
路拓樸搜尋網路拓樸資訊的時間，我們以分派表格(Allotments Table)將迴圈表格與同儕處理者進行連結。
意義上可視為“分派表格集中所有屬於該同儕的網路拓樸資訊”，以分派表格將搜尋網路拓樸資訊耗
時降為常數時間。分派表格以分派(Allotment)為基礎單位，儲存所連結的同儕實體與迴圈實體。意指當
同儕加入描述串流時，在該描述串流便會具有屬於該同儕的分派。同時分派也協助管理同儕緩衝與串
流範圍資訊。這個部份我們也提出串流緩衝與範圍更新機制以達成資源等候與降低重複更新次數來提
升資訊更新效率，此部分將於文後說明。 
37 
在迴圈表格中，附加之輸入參數為一個分派，目的將該分派加入目前描述串流最後一個位置，通
常發生於同儕初始連線的時候。這個部分首先將判斷最後一個迴圈是否已為關閉迴圈，若已為關閉迴
圈，則在迴圈表格後新增迴圈並置於最後，接著對最後一個迴圈執行附加即完成迴圈表格之附加。插
入之輸入參數為兩個分派甲與乙，目的將乙置於甲後面，通常發生於跨串流描述修復移動節點的時候。
這個部分將於迴圈表格內找到乙所屬之迴圈，並對迴圈執行插入即完成迴圈表格之插入。離開之輸入
參數為一個分派，目的將使分派離開這個描述串流之網路拓樸，通常發生於節點離開的時候。這個部
分將於迴圈表格內找到分派所屬之迴圈，並對迴圈執行離開即完成迴圈表格之離開。中斷之輸入參數
為一個分派，目的將使該分派與位於其後且屬於同一個迴圈之分派集合形成新的迴圈，通常發生於跨
串流描述修復由伺服器服務的時候。這個部分首先將於迴圈表格內找到分派所屬之迴圈，並對之執行
中斷，然後建立新迴圈，以中斷之後的分派集合逐一對新迴圈執行附加，最後將新迴圈置於原迴圈之
後即完成迴圈表格之中斷。 
5.2.2.2. 更新緩衝與範圍資訊方法(Buffer space and range updating mechanism) 
由於描述串流之緩衝與範圍資訊並非隨時都需要向同儕更新，更新時機只發生在同儕發出影片要
求(Video request)與跨串流描述修復時。為了使系統在向同儕更新時能在閥值時間內非同步等候回應並
避免重複更新，而制定此機制。首先我們在分派中為緩衝與串流範圍各制定可讀與已接收之布林值，
預設為可讀與未接收。接著給予更新緩衝與更新範圍的函式，當函式被呼叫時，代表該分派需要被更
新。函式內將判斷所需更新資料是否為可讀取與未接收，當成立則設定為不可讀取，並對該分派所屬
同儕送出更新之通訊協定。此時若本函式設計為同步函式，則需等候至資料回傳才能繼續。在此我們
的做法則讓系統先進行其他動作如繼續通知其他同儕，將需要通知的同儕通知完後，再嘗試由分派中
的對應函式取得資料。在對應函式中，首先將判斷該資料是否可讀取，若為不可讀取，則先釋出處理
器資源使該執行緒等候並讓其他執行緒執行，直到有其他執行緒通知或超過三秒時再進行確認資料是
否為可讀取，最後回傳所取得之資料。當資料由同儕回傳時，將呼叫分派之設定函式，回傳資料儲存
後，將該資料布林值設定為已接收與可讀取，並通知等候執行緒使之繼續執行，同時新增一個倒數計
時器，使之等候三秒後將該筆資料設定為未接收。綜觀以上機制，在第一次向同儕送出更新通知後，
直到接收資料後的三秒內，不會有第二次通知發生，達成避免重複更新的效果。而將送出通知與存取
資料分開，以非同步方式撰寫，讓通知可以一次全部送出，使同儕能以最快時間回應資料，也達成非
同步等候回應效果，提升系統效能。 
5.2.2.3. OLF 之實作(Implementation of Open-Loop First) 
OLF 為 Loopback-MDC 描述分配之主要概念。首先我們將欲進行描述分配同儕已分配的描述串流
形成集合 A，伺服器所有描述串流為 S，剩餘可分配的描述串流則為  {   }。建立一個空陣列 C
為候選描述串流集合，接著對所有描述的最後一個分派進行更新緩衝，並以儲存空間資訊對 R 做排序
如 Figure 58 (a)所示。取得已更新且已排序的 R 之後，接著進行延長開放式迴圈策略。將具有剩餘空間
且為最小剩餘空間的描述串流加入 C，由於 R 已經排序，所以我們可使用如 Figure 58 (b)方法省略不可
能為最佳分配之描述。若這次執行結束後使得 C 不為空集合，代表一條或多條描述存在開放式迴圈。
若存在多條描述串流，將進行加強迴圈堅韌度策略。該策略為當該次判斷無法取得最佳描述分配時須
往前一個分派執行相同判斷，以達成串流離開時造成最小影響。故在實作上也跟前述相同，從更新緩
衝資料到取得候選描述串流集合，完成後若尚存在多條描述串流則再進行相同動作。這個部分可能出
現例外情形，為進行判斷發現該位置不存在分派時，導致最後 C 為空集合，使得不存在候選描述串流
39 
若 C 為空集合，則代表沒有分派可以提供縫合式修復。在此將中斷迴圈，並以 T 開始產生新迴圈，由
伺服器提供修復。 
foreach (Allotment allotment in this) { // this為請求修補同儕之分派表格 
 allotment.UpdateMinMax(); // 更新串流範圍資訊 
 if (allotment.Parent != null) { 
  allotment.Parent.UpdateMinMax(); 
  if (allotment.Parent.Parent != null) 
   allotment.Parent.Parent.UpdateMinMax(); 
 } 
} 
(a) Updating buffer range information part 1 
foreach (Description description in R) 
 description.UpdateMinMax(); 
(b) Updating buffer range information part 2 
return (  .MaxReceivedChunkID>P.MinReceivedChunkID) 
 && (  .MaxReceivedChunkID <P.MaxReceivedChunkID); 
(c) IsIntraRecoveryable 
if (M.Peer[M.videoId][T.DescriptionId] == null) { 
 if (IsIntraRecoveryable(  .Parent，M) 
  && IsIntraRecoveryable(M,   )) { 
  if (M.Child != null &&M.Parent != null) 
   if (!IsIntraRecoveryable(M.Parent, M.Child))return false; 
  return true; 
 } 
} 
return false; 
(d) IsSewingRecoveryable 
Figure 59 Part of implementation of Inter-description recovery. 
5.2.2.6. 同儕離開實作(Peer offlineimplementation) 
當同儕預期或非預期離開時，將由處理者(Handler)偵測到離線訊息，並轉交給同儕處理者，由同
儕處理者告知同儕管理者此同儕已離開，此時同儕管理者將會從資料庫中移除此同儕的訊息，並釋放
該識別碼，供新同儕使用。從系統移除同儕資訊後，接著將呼叫同儕停止的函式。該函式首先釋放分
配表格，將對所有屬於該同儕的分派在迴圈表格呼叫離開，自此在網路拓樸中移除該同儕連結資訊。
最後對處理者呼叫停止函式，完全中斷進入與送出資料的處理執行緒。 
5.2.3. 同儕模組(Peer model) 
同儕模組提供同儕行為、資源存放與管理的功能。如 Figure 60 所示，同儕模組主要分為通訊協定、
接收區塊、傳輸區塊與資源管理，其元件間關係如所示。伺服器在整個 Loopback-MDC 中是屬於被動
的角色，當同儕主動請求的時候，整個系統才會有所動作。通訊協定區塊由服務連接器 (Service 
Connector)向伺服器請求服務，該元件會試圖與伺服器建立連線，並以通訊協定進行溝通，當同儕離開
時才會中斷。為了伺服器或同儕接收區塊資源，接收處理者(Requester Handler)以通訊協定向提供者如
父同儕或伺服器進行溝通。接收處理者將由接收者表格(Requesters Table)管理，當有新接收或中斷連線
事件發生時，接收者表格將進行相對應的操作。由於 Loopback-MDC 設計同儕將轉送所接收之描述串
流，所以同儕也提供傳輸服務稱轉送區塊(Relay)。轉送區塊類似伺服器模組之傳輸區塊，串流監聽者
41 
Network Interface
Service 
Connector
Protocol
Request
Handler
Protocol
Request 
Handler 
Management
Videos Table
Stream 
Accepter
New connection
Stream 
Handler
Protocol
Socket
Stream 
Handler 
Management
Inherit
Descriptions 
Table
Chunks Table
Chunk
Peer event
Requester event
Inherit
Inherit
Resource informations
Chunk
Relation
Data
 
Figure 61 Data flow ofimplementation ofpeer model. 
5.2.3.1. 描述串流請求回傳(Description reply) 
描述串流請求回傳為請求描述串流後回傳之通訊協定。接收到描述串流請求回傳後，首先將為這
個描述串流建立描述串流實體，並儲存在描述表格中。接著為這個描述串流建立新的接收處理者，主
要為這個描述串流接收資料，至此便完成描述串流請求回傳。當可使用之描述串流已得知，接著將進
行識別提供者，進入通訊協定溝通。 
5.2.3.2. 取得提供者回傳(Provider reply) 
取得提供者回傳發生於描述初建立需取得資料或是任何父節點連線資訊請求時，如內部串流描述
修復或跨串流描述修復的縫合式修復等。接收到該回傳後，首先會取得該回傳的所屬影片與描述串流
與目標連線資訊。接著由所屬影片與描述串流資訊導向負責接收該資訊的接收處理者，由呼叫轉向
(Redirect)函式讓請求者中斷目前連線，並向目標進行連線。接著送出識別連線的請求，進入通訊協定
溝通。 
5.2.3.3. 跨串流描述修復回傳(Inter-description recovery reply) 
跨串流描述修復回傳只發生於同儕向伺服器請求跨串流描述修復後。接收到該回傳後，首先會取
得影片與接收處理者識別碼，並得知跨串流描述修復後主要串流可由哪個區塊開始取得，這裡將它定
義為 ID。故主要串流請求者將向伺服器進行識別提供者，然後向提供者從    開始取得區塊。同時
為了填補由於移動描述而產生的區塊縫隙，這個部分將建立一個暫時性的接收處理者，向移動過來的
同儕請求斷裂部分區塊資料。請求串流範圍將從目前存在最大已接收的區塊識別碼直到 ID，這個部分
43 
Timer of 
showing 
pictures
Cirqueue of 
bitmap buffer
Flag controller
unit
Adjustment of 
FSP
unit 
Combine 
description 
model
HashTable of 
subDescriptions
Show pictures
Change flag Change flag
Put picture Set timer of FPS
Combine
Gap
Combine 
controller
unit
ChunkID
CombineID
Buffer Controller
Decoder
model
Decoded
package
Decoded packages 
receiving from server
Data
 
Figure 63 Data flow ofimplementation ofplayer. 
之後我們便針對解碼模組和合併模組做詳細說明及如何實作，並進一步詳述整個播放器核心架構
的資料結構以及運作方式，最後將介紹不同的調整播放方式，以盡可能降低畫面暫停緩衝發生的機率。 
5.3.1. 解碼器模組(Decoder model) 
解碼模組主要分為兩大部分，第一為將 H.264 解碼器修改為我們可以使用的模組，第二部分為導
入該模組，並以獨立執行緒處理解碼流程。 
5.3.1.1. H.264/AVC 解碼器(H.264/AVC decoder) 
在 H.264/AVC 解碼器的修改上，我們以 JM18.0 為基礎，將之修改為可以由 C#引用之動態鏈結程
式庫(Dynamic-link library)。在這個部份我們僅專注於 JM18.0 之專案 ldecod 的修改。 
首先解碼測試過程位於檔案 decoder_test.c 的 main 函式。由於我們只需要如同預設值一樣的解碼
過程，差別在於原本的 H.264/AVC 資料檔案輸入與輸出需更改為由記憶體輸入與輸出。首先我們加入
動態鏈結程式庫的主函式並不進行任何動作如 Figure 64 (a)。接著將 main 修改為一個獨立函式
JMDecode 如 Figure 64 (b)，該函式之輸入參數分別為 H.264 檔案的位元組陣列、以位元組為單位的檔
案長度、解碼後檔案的位元組陣列與解碼後相關資訊，解碼後相關資訊如 YUV 格式(YUV Format)、高
度(Height)與寬度(Width)等。由於我們不考慮使用參數呼叫，設定參數函式部分將移除參數呼叫如
Figure 64 (c)。接著將 H.264 檔案的位元組陣列加入初始化解碼器函式中如 Figure 64 (d)。然後鎖定以附
件 B(AnnexB)的開檔方式，加入 H.264 檔案的位元組陣列如 Figure 64 (e)。 
至此已將 H.264/AVC 檔案的位元組陣列加入解碼器並初始化。由於附件 B 的讀取函式 getChunk
依然是以檔案為主，此時必須修改附件 B 的讀取函式才能達成從記憶體讀取的要求。如 Figure 64 (f)
所示，這個部份我們另外定義剩餘資料長度為 R，在正常情況下，getChunk 每次呼叫將讀取一個固定
45 
5.3.1.2. 解碼通道(Decoding channel) 
在導入模組的部分，我們設計為解碼通道(Decoding channel)，並以阻塞佇列實作解碼通道，以獨
立執行緒逐一取出資料並呼叫 JMDecode 解碼之。在實作上如 Figure 65 所示，導入外部函式庫以
System.Runtime.InteropServices.DllImport 為主要方式，函式名稱須與 JM 中的名稱相同。 
[System.Runtime.InteropServices.DllImport("ldecod.dll")] 
public static extern int JMDecode(byte[] bitStreamMemory, 
 int length, byte[] output, int[] config); 
Figure 65 Implementation of decoder DLL importation. 
導入模組後，將進行解碼通道主要過程。如 Figure 66 所示，首先同儕接收到的資料會包裝成解碼
封包(Packeted .264)，其中包含影片、描述、區塊識別碼與待解碼資料，並送入通道(Channel)。當解碼
封包從通道中取出後，會將待解碼資料交給 JMDecode 進行解碼。結果會產出 YUV 資料(YUV Data)
與相關資訊，如 YUV 格式、長度與寬度。接著將 YUV 資料、描述與區塊識別碼包裝為已解碼封包，
最後交給播放器處理。 
.264 
Data
YUV 
Data
Channel
Packeted
 .264
JMDecode
Player
Data
Function 
model 
Network
 
Figure 66 Architecture of decoder model. 
5.3.2. 核心模組(Core model) 
在介紹完解碼模組後，產生出被解碼描述串流，且這些資料該被儲存在哪裡或是哪種資料結構，
才能有助於播放的效率及控制。之後並藉由適當的控制機制，有效地控制合併時間及使用記憶體，主
要是因為電腦除了要緩衝接收到的封包還要暫存播放時的畫面，就耗費了不少記憶體空間，更何況再
播放時候，資源耗費的更多，所以如何有效控制資源，在實作播放器是必須要面對的問題，最後便針
對網路傳輸速度與播放速度的問題做詳細探討，並提出相對應得調整機制。 
5.3.2.1. 資料結構(Data structure of core model) 
在網路封包被解碼後，因為必須等到所有接收的描述串流中，同一個區塊資料都接收後，才能做
合併，所以必須先暫存在解碼緩衝區(Decoded buffer)做等待。但是基於封包可能會發生延遲到達的問
題，導致緩衝區中解碼過的封包數量不只 1 到 5 個，所以基於搜尋效率需求，在這裡我們對於解碼的
緩衝區採用的資料結構為雜湊表(Hash Table)，其主要原因雜湊表搜尋的複雜度為 O(1)。結構圖如 Figure 
67，顏色相同的被解碼封包，為擁有相同的區塊識別碼，也就是這些具有相同顏色的被解碼封包是要
被合併成同一個畫面。 
47 
 第一種情況為只接收到一條描述串流如 Figure 70，必須透過單一條描述串流的複製，才能夠還原
影像大小，程式碼如 Figure 69 所示。 
int offset = 0; 
for (int f = 0; f < NumOfFrame; f++){ 
 int bias = 0, DesYArraypos = 0，DesUVpos = 0; 
 for (int i = 0; i < player_H / 2; i++){ 
  for (int pos = 0; pos < player_W; pos++){ 
   Yarr[bias + pos] = DesYuv[0].Y[DesYArraypos]; 
   Yarr[bias + pos + player_W] = 
    DesYuv[0].Y[DesYArraypos]; 
   if (pos % 2 == 1) DesYArraypos++; 
   if (pos % 4 == 0 || pos % 4 == 3){ 
    Uarr[(bias + pos) >> 1] = DesYuv[0].U[DesUVpos]; 
    Uarr[(bias + pos + player_W) >> 1] = 
     DesYuv[0].U[DesUVpos]; 
    Varr[(bias + pos) >> 1] = DesYuv[0].V[DesUVpos]; 
    Varr[(bias + pos + player_W) >> 1] = 
     DesYuv[0].V[DesUVpos]; 
    if (pos % 4 == 3) DesUVpos++; 
   } 
  } 
  bias += player_W * 2; 
 } 
 offset += DesFrameSize; 
} 
Figure 69 Implementation of ISMDC method in receiving one description. 
0 0 2 2
0 0 2 2
8 8 10 10
8 8 10 10
0 2
8 10
ISMDC
Des_0
0 0 0 0
4 4 4 4
0 0 0 0
4 4 4 4
Y
U
V
0 4
0 4
 
Figure 70 Pixel distribution of ISMDC method in receiving one description. 
  
49 
 第三種情況為接收到三條描述串流如 Figure 74，透過左上角一條描述串流的向右複製，來還原影
像大小，程式碼如 Figure 73 所示。 
int offset = 0; 
for (int f = 0; f < NumOfFrame; f++) { 
 int bias = 0, DesYArraypos = 0，DesUVpos = 0; 
 for (int i = 0; i < player_H / 2; i++) { 
  for (int pos = 0; pos < player_W; pos++) { 
   Yarr[bias + pos] = DesYuv[0].Y[DesYArraypos]; 
   Yarr[bias + pos + player_W] = 
    DesYuv[(pos % 2 == 0)?1:2].Y[DesYArraypos]; 
   if (pos % 2 == 1) DesYArraypos++; 
   if (pos % 4 == 0 || pos % 4 == 3) { 
    Uarr[(bias + pos) >> 1] = DesYuv[0].U[DesUVpos]; 
    Uarr[(bias + pos + player_W) >> 1] = 
     DesYuv[(pos % 2 == 0) ? 1 : 2].U[DesUVpos]; 
    Varr[(bias + pos) >> 1] = DesYuv[0].V[DesUVpos]; 
    Varr[(bias + pos + player_W) >> 1] = 
     DesYuv[(pos % 2 == 0) ? 1 : 2].V[DesUVpos]; 
    if (pos % 4 == 3) DesUVpos++; 
   } 
  } 
  bias += player_W * 2; 
 } 
 offset += DesFrameSize; 
} 
Figure 73 Implementation of ISMDC method in receiving three descriptions. 
0 1 2 3
4 4 6 6
8 9 10 11
12 12 14 14
0 2
8 10
1 3
9 11
4 6
12 14
ISMDC
Des_0 Des_1
Des_2
0 1 2 2
4 5 6 6
0 1 2 2
4 5 6 6
Y
U
V
0 4
0 4
1 5
1 5
2 6
2 6
 
Figure 74 Pixel distribution of ISMDC method in receiving three descriptions. 
  
51 
設為 30 fps，也就是每秒播放 30 張畫面，而對於 Timer，則是每 1/30 秒要從播放器緩衝區抓一張畫面，
藉此透過這樣的概念就能實做出播放速度的控制。 
Timer
(a Thread)
Player buffer
requests /
30
1
Get a frame
Interval of Timer = 30 fps
 
Figure 77 Conception of Showing Picture model. 
5.3.2.4. 控制機制(Operatingmechanism) 
透過適當的控制機制，能夠有效地運用空間播放整條影片串流，或是提前將影片作合併，減少合
併時所耗費的時間，進一步減少對播放速度的影響。以下我們將針對播放器系統中，最主要兩個控制
機制的運作方式做詳細介紹，以及提出兩種調整機制，來處理網路傳輸因網路環境或是接收後的處理
流程和播放速度相對速度出現不穩定的情況，其目的是為了盡可能的持續播放影片。 
合併控制(Combinative Controller)在播放器系統架構中，扮演非常重要角色，其目的是為了有效減
少暫存解碼後封包的數量。主要原因是解碼過後的封包，資料格式為 YUV，而資料量為原本 264 的 10
倍以上。以每個資料區塊儲存 10 畫面為例，假設 1 個資料區塊的資料量為 7KB，解碼後的資料量為
102KB，如此大的差距對記憶體空間影響非常大，況且這只是針對一個描述串流。假如一個使用者接
收 4 條描述串流，以及基於合併需求在於提供 4 條服務品質，此時此刻緩衝區(Hash Table)就必定暫存
4 個解碼後的封包，資料量為 408KB。但是基於封包進來的時間點可能會因為網路延遲或是壅塞，導
致不同描述串流但相同識別碼的區塊資料要被合併的時間點可能就會往後延，嚴重的的話，暫存的被
解碼封包數量可能會相當多，以至於電腦的記憶體無法負荷。所以為了要提供一定的服務品質且有效
使用記憶體資源，我們設置一個門檻值(Threshold, Gap)，來達到此目的。從 Figure 78 可以看出，門檻
值為合併的區塊識別碼(8)和解碼的區塊識別碼(11)的差距為        ，而最先將數值預設為接收的
描述串流數量(3)(此為最佳情況沒有延遲)，再依據之後接收封包延遲的差距，來提升或是縮小門檻值，
藉此控制機制能達到一定的服務品質及有效使用記憶體空間。 
53 
至於出現不穩定的速度時，主要分為兩種情形。第一種情形，如圖?(a)，Tail flag速度快於Head flag，
也就是播放速度大於網路傳輸速度，導致 Tail flag 追上 Head flag，此時必須停止 Player 播放，然後進
行緩衝的動作。而第二種情形，如圖?(b)，Tail flag 速度慢於 Head flag，也就是播放速度小於網路傳輸
速度，導致 Head flag 追上 Tail flag，此時必須要求 Server 端傳輸率降低或是暫停傳輸。由於我們並沒
有使用類似 RTSP (Real Time Streaming Protocol)控制影片的傳輸速度或是暫停，且基於想讓影像一直
不間斷播放，我們這裡提出了一些調整機制為網路傳輸控制與播放速度控制，這些方法皆是藉由 Head 
flag 和 Tail flag 之間的差距(Gap)，在 Head flag 和 Tail flag 互相接近時，就提前做調整的動作，來達到
不間斷播放。下一小節我們將會詳細描述這兩種調整方法。 
1 2 3 4
[0] [1] [2] [3]
5 6 7 8
[4] [5] [6] [7]
Tail flag Head flag 
(a) Tail flag > Head flag
9 10 11 4
[0] [1] [2] [3]
5 6 7 8
[4] [5] [6] [7]
Tail flagHead flag 
(b) Head flag > Tail flag
: Can play : Play over
 
Figure 80 Unstable situation of playing controller. 
5.3.3. 調整模組(Adjusting model) 
由前一章節所說，播放器主要是靠著 Tail flag 和 Head flag 來控制播放畫面的程序，藉此盡可能延
長不間斷播放的時間。但是基於網路傳輸的速度，即使伺服器跟同儕彼此傳送和接收都配合影片的播
放速度(FPS)，也可能受到網路壅塞、掉封包且重傳或是接收後，一連串的封包處理程序，以至於原本
傳輸和播放一致的時間出現偏差，導致必須用一些調整的方法，使這種不穩定的狀態，能夠動態調整，
並且盡可能使影片連續播放。在此我們透過這兩個旗標之間的差距(Gap)和一個門檻值(Threshold)，做
為一個評估是否做動態調整的標準。如 Figure 81 所示，門檻值設為播放緩衝區大小的一半，主要原因
是盡可能讓可以播放的畫面數量為緩衝區大小的一半，以下將詳敘描述兩種方法。 
300 301 302299298 303 304 305 …… 309 310 … 598 5992972960 1 … 290 291
Head flag Tail flagGap
 
Figure 81 Conception of gap. 
5.3.3.1. 實作方法(Implementation of adjusting model) 
網路傳輸控制(Network transfer controlling)的部分是以通訊協定向傳輸端溝通，並控制傳輸速度的
方法。如 Figure 82 所示，從門檻值往前後推算 100 單位的儲存空間並給予狀態編號，分別為狀態 0 至
4，並給予初始影片播放速度為預設值且狀態為 2，當差距增加至 400 以上時，狀態將由 2 變為 3，依
此類推根據如 Figure 82 規則進行狀態變化。而因為以通訊協定控制傳輸速度需要回應時間，沒辦法快
速使差距回復正常值，所以狀態與狀態間之距離平均分配，給予狀態變化最佳時間。由於狀態的制定，
55 
5.4. 通訊協定設計(Protocols Design) 
Loopback-MDC 實作除了系統部分外，我們在網路的溝通方面，由分析整理過後的通訊協定集合來
達成 Loopback-MDC 的演算法流程。 
5.4.1. 通訊協定工作流程(Working flow) 
此節介紹本系統所規畫之通訊協定大綱。在通訊協定的區塊切割方面，我們依照使用者的行為與
重複性區塊做切割，如 Figure 85 所示。使用者第一步會進入伺服器並進行註冊(Register)，註冊完畢將
識別此使用者，賦予唯一的同儕識別碼(Peer ID)，並取得伺服器上所有影像序列的簡要資訊。第二步
由使用者選擇欲觀看的影像序列，並提出影片請求(Video request)。影片請求完畢使用者將加入該影片
群組，並加入數條描述串流之迴圈。系統得到已加入的串流資訊後，將會進行提供者識別(Provider 
identify)，這個過程首先向伺服器取得串流提供者後，對提供者進行連線與識別，並告知所需區塊範圍，
取得同意後即持續傳輸串流，直到特定事件發生。 
特定事件總共有四項，分為異常情況與正常情況，異常情況有提供者離開(Provider leaves)與無法
提供(Stream failed)，正常情況有接收資料(Data received)與傳送結束(End of stream)。首先當提供者離開
的時候，表示該描述串流之資料無法正常接收，此時將進行內部串流描述修復。過程為向伺服器請求
新的提供者，也就是提供者的提供者，並進行提供者識別。而無法提供的情況下，表示提供者無法提
供所需範圍的資料，此時將進行跨串流描述修復。過程為向伺服器請求跨串流描述修復，找出可以提
供縫合式修復的節點並修復之。若不存在可提供修復的節點，則等同迴圈斷裂，此時將由伺服器或代
理(Proxy)提供服務，根據結果再進行提供者識別。而在正常情況方面，接收資料只會發生在串流資料
到達時，代表該協定帶有一個區塊(Chunk)的資料，系統會將之儲存並同時更新已儲存之資訊。傳送結
束表示請求範圍已傳送完畢，並關閉處理該串流之接收處理者(Receive Handler)，最後等候使用者操
作。 
當使用者決定離開時，便會進行同儕離開(Peer Quit)。這個協定主要在收集系統相關資訊，若使用者強
制離開的情況下，系統也可以由處理者偵測為正常離開，此協定最後將同儕關閉(Peer closed)完成整個
通訊協定流程。 
Register
Video 
Request
Provider 
Identification
Intra 
Recovery
Inter 
Recovery
End of 
Stream
Buffer 
Update
Minmax 
Update
Peer Quit
Data 
Received
Store 
Data
Peer Closed
Stream
Peer 
Left
Update 
Buffer 
Space
Update 
Buffer 
Range
 
Figure 85 Protocols working flow of the Loopback-MDC. 
57 
串流範圍以區塊識別碼規範，並以特殊識別碼-1 當作影片之結束。在同儕加入這個影片群組的初始連
線時，串流範圍為 0 至-1。若為內部串流描述修復或跨串流描述修復情形中之串流範圍通常為修復起
始點至-1。而當所進行的是縫合式修復的描述串流移動時，填補缺空區塊之串流範圍可能為修復起始
點至修復終止點。提供者接收到串流範圍資訊後，將對本同儕所持有的串流區塊做確認，確認條件分
析如 Figure 89 所述。當無法提供串流的情況發生，則會告知串流連接失敗，代表提供者無法提供所需
串流，此時同儕將進行跨串流描述修復。而當串流結束情形發生，則代表同儕所需的串流範圍在系統
設定上，已經屬於結束範圍，將告知影片結束。若上述條件皆未通過，代表提供者可正常提供服務，
並告知串流已開始。此後便會以畫面率為原則，定時送出區塊資料，並在每一次將送出區塊前，再進
行如 Figure 89 之確認，避免網路延遲產生蔓延，而使整個系統趨於不穩定。至此識別提供者完成，往
後將視提供者或同儕的事件進行不同的通訊協定。 
Peer Server
Provider connection information request
Provider connection information reply
Targeted description identify
Requesting description ok
Streaming starts in specified range chunks
Streaming started notify
Provider
 
Figure 88 Protocol communication of provider identification. 
End of requesting 
is -1
Start of requesting 
> End of video
Start of requesting 
> Upper bound of 
received chunks
Start of requesting 
< Lower bound of 
received chunks
Start of requesting 
> End of requesting
End of stream
Stream failed
Stream starts
False
True
False
True
False
False
Requesting stream 
range (Requesting) 
identification starts
True
False
 
Figure 89 Decision graph of stream range identification. 
59 
移動同儕，則對修補同儕回傳確認資訊，同儕接著會識別提供者，嘗試銜接串流，同時對於可移動同
儕則是告知移動描述串流，可移動同儕將進行新描述串流的識別使用者。另外由於同儕的描述串流移
動，產生串流縫隙，將導致所需的資料來自於不同描述串流。為加以識別，我們使用另一個具有指定
範圍的識別使用者向提供者請求串流縫隙。另外若無法成功找到可移動同儕，則伺服器將切斷迴圈，
新迴圈將與伺服器銜接。這個部分在告知同儕後，同儕一樣進行識別使用者，由伺服器提供串流。修
復完成後串流將繼續接收。 
5.4.7. 資料接收(Data received) 
資料接收則只有接收串流指令而已。如 Figure 92 所示，該指令後帶有一個區塊的資料，同儕收到
這份資料後會知道該資料之區塊識別碼為何，接著將之儲存於對應描述串流的區塊表格中，同時更新
區塊表格的串流範圍。 
Peer Provider
Stream data chunk by chunk
…
 
Figure 92 Protocol communication of data received. 
Peer Provider
Requesting stream task finished
Offline signal detected
 
Figure 93 Protocol communication of end of stream. 
5.4.8. 傳送結束(End of stream) 
傳送結束通訊協定發生後，將會終止該描述串流之請求與傳輸。如 Figure 93 所示，傳輸途中，若
提供者所提供之區塊資料到達影片最後一個區塊後，將會終止目前的串流傳輸工作，並告知同儕影片
已達結尾。由於自最後一個區塊後，沒有任何需要的資料，故請求工作將中斷與提供者的連線。提供
者得知同儕已離線後，停止對同儕的描述串流通訊協定服務，至此該描述串流傳輸工作正常完成。 
5.4.9. 串流緩衝更新(Buffer space updating) 
串流緩衝更新將向同儕更新指定描述串流的緩衝區大小。由於串流緩衝資訊僅在進行 OLF 策略時
才會被使用，也就是在影片請求時需要更新串流緩衝資訊，並不是隨時都要知道目前所有描述串流的
狀態，所以我們設計了串流緩衝更新在特定時機更新串流緩衝資訊。這個部分如 Figure 94 所示，首先
伺服器會向同儕告知需要更新，為了 OLF 策略能在最短時間內完成，我們減少更新串流緩衝資訊的時
間，同儕會將本協定視為最高優先序之一，以最快的速度向伺服器回報狀態。在實作上，送出更新串
流緩衝資訊時，伺服器將等候同儕回應，若等候超時則會略過此次更新，但同儕回應時一樣會更新串
流緩衝資訊，以便不久以後可能會使用到。由於每個描述串流都是獨立運作，所以將每次更新所有串
流緩衝資訊，由於短時間的更新結果都是相同的，所以為了降低重複更新所帶來的負擔，規定每個同
儕回應後，將等候一段時間後才能在進行下一次更新。 
Peer Server
Update description 
remaining buffer space information
Description remaining 
buffer space information reply
 
Figure 94 Protocol communication of buffer space updating. 
Peer Server
Update description received 
chunks range information
Description received 
chunks range information reply
 
Figure 95 Protocol communication of buffer range updating. 
 
61 
Quality 
(descriptions/ peer) 
2, 4, 6, 8, 10, 12, 14 Normal 
Buffer length (minute) 0.5 Uniform 
5.5.2. 同儕腳本(Peer scripts) 
每位同儕都是獨立個體，同儕將由某部電腦執行，在該電腦上可以存在多個同儕。而每次實驗的
環境配置、個體啟動與事件觸發都需以人力來該電腦進行操作，現實中亦如此。所以在實驗過程中，
為了降低人力支出並提升實驗效率，我們為每項同儕操作定義一個對應的控制協定，為同儕腳本(Peer 
scripts)。以實驗設定予以對應的數據分布，使同儕模擬使用者事件的觸發，達成伺服器集中式控制。
對應事件與控制協定說明有： 
 環境設置：這個部分僅設定緩衝長度，實作上將送出指令 Control.BufferSpace n，其中 n 代表緩衝
長度值，單位為區塊長度。 
 請求影片：伺服器將替同儕從清單中選擇一部影片 v，並送出控制協定 Control.Video v，同儕接收
到後會開始進行請求影片的通訊協定。 
 畫面品質：由於每條描述的處理是獨立的，所以伺服器為同儕決定影片 v 的品質為 q 後，將送出
q 次控制協定 Control.Description v，同儕接收到後會向伺服器請求加入串流。 
 同儕離開：當同儕必須離開時，如選定為離開之對象。將對同儕送出 Control.Peer.Quit 指令，同儕
會進行同儕離開之通訊協定。 
以上控制協定將以文字檔案儲存，並在每個控制協定前賦予事件發生時間，以秒為單位。而事件
發生時間依參數而變化，Figure 96 為一組同儕腳本之範例。 
1 Control.BufferSpace int 30 
20 Control.Video short 0 
21.5 Control.Description short 0 
21.5 Control.Description short 0 
21.5 Control.Description short 0 
41.5 Control.Peer.Quits 
Figure 96 One case of peer scripts. 
Server/Proxy
Switch
Peer group 0
(0, 20, …, 80)
Peer group 1
(1, 21, …, 81)
Peer group 19
(19, 39, …, 99)
…
DHCP Server
 
Figure 97 Practical experiment network topology ofimplementation of the 
Loopback-MDC. 
5.5.3. 實驗步驟(Experment steps) 
我們執行實驗的實體網路環境為 21部電腦，配備之處理器均為 Intel Core 2 Duo E7500 @ 2.93GHz，
記憶體容量為 2GB，網路環境以 Alcatel-Lucent 設備為主，為一個不對外連線的區域網路。 
在電腦配置方面，如 Figure 97 所示，伺服器與代理將配置於單一電腦上，而第一次同儕將分散於
剩餘 20 台電腦中執行，為了提升經由交換器進行串流的機率，將盡最大可能分散同儕。當 n 個同儕分
配於 m 台電腦中，第 k 電腦將形成同儕群組 k (Peer group k)，該群組配置識別碼 d 的同儕個體其中
  {    |    ⌈   ⌉}，Figure 97 為 100 個同儕分配於 20 台電腦之範例。 
63 
在到達率之 Figure 98 (a)與(b)中，由於我們期望在不特別考慮延長迴圈的情況下，開放式迴圈存在
總時間應該可以在到達率視為 1 的時候達成實驗時間  品質。在本次環境中，到達率  緩衝時間  
離開率可以視為 1 時，到達率           即為 4，預期開放式迴圈存在總時間為 80 分鐘。而在實驗
表現當到達率為 4 時，總時間長度為 84.9 分鐘，比預期延長了 4.9 分鐘，約有 6%的增益。當離開率上
升時如 Figure 99 (a)與(b)，雖然開放式迴圈存在總時間因離開率增加，而跟著減少，但平均迴圈維持時
間卻在高離開率維持約 1 至 1.5 分鐘，代表平均迴圈維持時間是增加的。對於品質的變化如 Figure 100 
(a)與(b)，在開放式迴圈存在總時間方面，可以與預期總時間為 品質 實驗時間 來比較，在品質為 14
條串流以下的時候，都超過預期總時間，其中在品質為 8 時最大約有 25%的增益。而在平均迴圈維持
時間方面整體看來是處於下降的趨勢，代表在相同離開率底下隨著品質的提升，會使得同儕要求之描
述分散。在高品質情況下，離開對平均迴圈維持時間的影響較低品質大。對於描述數量的變化如 Figure 
101 (a)與(b)，在開放式迴圈存在總時間方面，描述串流隨著倍數增加，但總時間在 90 與 92 分鐘之間
跳動，描述數量變化對整體效率影響不大。而在平均迴圈維持時間方面呈現一個微幅成長的趨勢，但
在描述串流為 512 條時我們認為屬於實驗次數需再提升，才能表現高描述數量的情況。 
  
(a) Total openloops duration (b) Average openloop duration 
Figure 100 Experiment result of open loop(s) duration varied by quality. 
  
(a) Total openloops duration (b) Average openloop duration 
Figure 101 Experiment result of open loop(s) duration varied by descriptions. 
5.5.5. 錯誤回復效能(Failure recovery efficiency) 
這個部分討論錯誤回復的效能，錯誤回復包含內部串流描述修復與跨串流描述修復，並可能由同
儕或伺服器支出，Loopback-MDC 主要設計盡量由同儕進行支出，所以我們以整體錯誤回復來評估錯
0
20
40
60
80
100
120
140
160
2 4 6 8 10 12 14
D
u
ra
ti
o
n
 (
m
in
u
te
) 
Quality (descriptions/peer) 
Total open-loops duration
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
2 4 6 8 10 12 14
D
u
ra
ti
o
n
 (
m
in
u
te
) 
Quality (descriptions/peer) 
Average open-loop duration
88.5
89
89.5
90
90.5
91
91.5
92
92.5
16 32 64 128 256 512
D
u
ra
ti
o
n
 (
m
in
u
te
) 
Descriptions (descriptions/video) 
Total open-loops duration
0
0.5
1
1.5
2
2.5
16 32 64 128 256 512
D
u
ra
ti
o
n
 (
m
in
u
te
) 
Descriptions (descriptions/video) 
Average open-loop duration
65 
形。而縫合式修復需在網路結構穩定如祖父節點與同儕可以產生內部串流描述修復時，該結構之父節
點才能移動修補別條串流而不產生迴圈中斷。而隨著到達率的提升，縫合式修復之比例應該可以繼續
提升。限於實驗環境不足以提高到達率，預測到達某一個到達率後，會達到高峰並往回下降。這是因
為到達率夠高時，同儕數量足夠提供內部串流描述修復，內部串流描述修復數量上升，縫合式修復成
功的比率便下降。若在變動離開率的情形下如 Figure 103 (b)，表現出一個較不穩定的結果，不過貼近
我們預測的，在低離開率與高離開率時，縫合式修復產生的機率較小，在離開率為 0.5 時為最顛峰值。
當以品質為變動參數時如 Figure 103 (c)，產生一個較明顯的峰型曲線圖，當品質為 6 時達到峰值。當
以描述數量為變動參數時 Figure 103 (d)，曲線圖沒有較固定的走向，代表描述數量的變化對於縫合式
修復沒有較相關之影響。 
  
(a) Arrival rate variation (b) Failure rate variation 
  
(c) Quality variation (d) Description variation 
Figure 103 Experiment result of sewing recovery rating to total recovery. 
5.5.6. 錯誤回復時間(Failure recovery duration) 
為了得知錯誤回復對使用者的影響程度，我們收集內部串流描述修復與跨串流描述修復的錯誤回
復時間予以分析。一次錯誤回復時間之紀錄起始從發生錯誤的時間點如提供者離開或無法提供資料，
直到接收到第一個區塊資料為止。 
在此首先觀察內部串流描述修復所需時間。由於內部串流描述修復只需要向伺服器請求父同儕提
供者即可，所以平均內部串流描述修復時間通常不會產生差異，但經過分析而得知，當伺服器產生瞬
間大量內部串流描述修復時，可能會對平均修復時間造成影響。觀察實驗結果如 Figure 104，由於當變
化參數不為品質時如到達率、離開率、描述數量時將為固定值，所以每位同儕的離開，將產生相近的
內部串流描述修復請求數量。所以以到達率、離開率、描述數量的內部串流描述修復時間變化而言，
0
0.2
0.4
0.6
0.8
1
1.2
2 4 6 8 10 12 14
F
a
il
u
re
 R
ec
o
v
er
y
 r
a
te
 (
%
) 
Arrival rate (peers/minute) 
Sewing recovery rate to
total recovery
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
F
a
il
u
re
 R
ec
o
v
er
y
 r
a
te
 (
%
) 
Failure rate (failure peers/arrival peer) 
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
2 4 6 8 10 12 14
F
a
il
u
re
 R
ec
o
v
er
y
 r
a
te
 (
%
) 
Quality (descriptions/peer) 
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
16 32 64 128 256 512
F
a
il
u
re
 R
ec
o
v
er
y
 r
a
te
 (
%
) 
Descriptions (descriptions/video) 
67 
導致描述數量在某些部分出現集中的現象，使得同儕離開後，未知修補位置之描述較少，所以受網路
拓樸規模之影響也隨之減少。最後當描述數量上升時，同儕有可能請求超過 16 條串流，所以在超過
16 的描述數量情形下才會有影響，就實驗結果觀察，雖然如同推測在描述數量上升時，跨串流描述修
復時間有所增加，但影響不甚明顯。 
  
(a) Arrival rate variation (b) Failure rate variation 
  
(c) Quality variation (d) Description variation 
Figure 105 Experiment result of average inter-description recovery duration. 
5.5.7. 伺服器負載(Proxy/Server loading) 
最後觀察伺服器負載，伺服器負載以提供比率(Providing Rate)為單位，該單位代表由伺服器支出之
描述數量與總描述數量之比例(包含錯誤回復)，故同儕之負擔即為伺服器負載取 1 的補數。為了表現具
有內部與跨串流描述修復之 Loopback-MDC 之效能，我們移除內部與跨串流描述修復功能，即當錯誤
發生時直接由伺服器修補，紀錄為另一個伺服器負擔，並比較兩者差異。 
當以到達率為變化參數時如 Figure 106 (a)，當到達率遞增時，兩者差距逐漸拉大。這是由於到達
率較高的情況下，同儕間的串流範圍重疊機率增加，使得內部串流描述修復與跨串流描述修復成功比
率提升。而當以離開率為變化參數時如 Figure 106 (b)，當離開率遞增時，兩者差距呈現遞增後遞減的
情形，這是因為在低離開率時修復機會少，使初始分配成為數據主要組成。而在高離開率的情況下，
由於內部串流描述修復與跨串流描述修復成功機率降低，所以由伺服器提供的比率也隨之增加，但可
以看出在高離開率情形中，內部串流描述修復與跨串流描述修復也提供約 15%的增益。另外當以品質
與描述數量為變化參數時如 Figure 106 (c)與(d)，由圖可以看出品質與描述數量的變化對兩者負擔比率
影響不大，大約保持 20%的差距。在伺服器負擔實驗中，具有錯誤回復與移除錯誤回復之結果最大差
距約為 25%，顯示 Loopback-MDC 之機制有效降低伺服器負擔。 
0
0.5
1
1.5
2
2.5
2 4 6 8 10 12 14
D
u
r
a
ti
o
n
 (
m
il
li
se
c
o
n
d
) 
Arrival rate (peers/minute) 
Average inter-description
recovery duration
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
D
u
ra
ti
o
n
 (
m
il
li
se
c
o
n
d
) 
Failure rate (failure peers/arrival peer) 
0
0.2
0.4
0.6
0.8
1
1.2
1.4
2 4 6 8 10 12 14
D
u
ra
ti
o
n
 (
m
il
li
se
c
o
n
d
) 
Quality (descriptions/peer) 
0
0.2
0.4
0.6
0.8
1
1.2
16 32 64 128 256 512
D
u
ra
ti
o
n
 (
m
il
li
se
c
o
n
d
) 
Descriptions (descriptions/video) 
69 
Table 2 Decoded time varied by descriptions. 
畫面大小(size/description) 352×576 352×288(cif) 176×144(qcif) 
描述串流集合(number/set) 2 條描述串流 4 條描述串流 16 條描述串流 
平均解碼時間(ms /chunk) 0.127163 0.065305 0.023741 
5.5.8.2. 合併(Duration of frame combination) 
評估合併的影響，主要有兩項，第一個合併時間是否過長，以至於影響系統播放，而且是否會隨
著描述串流的增長而加長，以及透過合併控制機制，是否影響到合併後的品質，以下實驗時間為 100
秒，我們將用原始影像畫面為 704×576(4CIF)來分析合併時間以及 HashTable 的暫存數量，來評估可能
影響系統的原因。 
首先分析系統合併時間，基於本系統實作 SMDC，主要是透過空間上的切割方式，所以相對的要
合併描述串流時，就必須反轉 SMDC，從合併方式可以看出，不管是 2 條描述串流合併或是更多條合
併，都需要跑兩層迴圈，其執行次數約為原始畫面大小(Width × Height)，所以時間複雜度是 O(Width × 
Height)，結果就如實驗數據 Table 3 一樣，不管是哪一種描述串流做合併，合併時間皆約是 0.15 左右，
如果要改善時間速度，就必須使用其他的 MDC 技術，藉此來降低對系統的影響，但本系統主要合併
的時間點並非在播放之前，而是用合併控制機制來提早合併，盡可能來降低合併對系統播放的影響，
但相對的可能會造成記憶體的大量使用或是合併品質不佳的問題。 
Table 3 Combinative time varied by descriptions. 
畫面大小(size/description) 352×576 352×288(cif) 176×144(qcif) 
描述串流集合(number/set) 2 descriptions 4 descriptions 16 descriptions 
平均合併時間(ms /frame) 0.145619 0.158347 0.162657 
透過合併控制機制，除了能夠降低合併時間對播放的影響，也能夠有效降低記憶體的使用，實驗
Table 4 針對描述串流集合為 4，並分別針對不同接收的數量，來分析 Hash Table 暫存已解碼過的封包
數量，由合併控制的理論，藉由門檻值來控制合併的時間，並且控制 Hash Table 暫存已解碼過的封包
數量，而門檻值的初始設定為接收描述串流數量，其目的是基於封包最好情況為連續 3 個時間點進來，
但因為避免封包延遲而影響和品質，所以透過動態調整門檻值，能夠有效維持一定的品質，實驗數據
顯示在接收不統的描述串流數量下，皆能維持一定的品質以及將已解碼過的封包暫存數量降低在 10 以
下。 
Table 4 Hash Table capacity varied by receiving descriptions. 
描述串流集合(number/set) 4 條描述串流 
接收描述串流數量(條) 2 3 4 
平均合併品質(條/frame) 2 3 4 
雜湊表內封包數量(個) 2.5 5 8.5 
至於合併的效果，Figure 107 以四條描述串流為例。Figure 107(a)，為一條描述串流合併成原始影
像，Figure 107(b)，為兩條描述串流合併成原始影像，Figure 107(c)，為三條描述串流合併成原始影像，
Figure 107(d)，為四條描述串流合併成原始影像，很明顯的可以看出當接收地的描述串流越多，畫質重
建的品質越加佳，相反的越低則為模糊，而至於 Figure 107(b)，之所以鋸齒狀特別多，主要取決於 ISMDC
的實作方式，在這我們單純用複製的概念，而沒有用像是內差或是平均的想法，所以鋸齒狀相較於其
他幾張圖較為明顯。 
71 
數時如 Figure 108 (c)，由於描述數量的增加，導致每位同儕離開時內部串流描述修復的數量增加，若
產生跨串流描述修復時，相對於低品質來說，高品質所需處理的描述數量也會隨之增加，故實驗結果
呈現遞增的情況。而最後以描述數量為變化參數時如 Figure 108 (d)，描述數量遞增而處理器使用率也
有部分上升，這是因為當所有描述都成為關閉迴圈時，會隨機分配一個描述給同儕，所以在高描述數
量時有較高機率將同儕分散在不同的描述中，在跨串流描述修復時有較高機會成為未知位置之描述，
導致跨串流描述修復所需收集的資料增加，故處理器資源增加，而在描述數量為 512 條時產生的折返
為實驗規模不足以客觀表現的結果。 
  
(a) Arrival rate variation (b) Failure rate variation 
  
(c) Quality variation (d) Description variation 
Figure 108 Experiment result of CPU usage. 
在觀察工作集的實驗結果 Figure 109 中，可以發現不論以甚麼參數變化，同儕都保持約 20MB 的
工作集使用量，顯示系統在同儕的記憶體資源管理表現穩定。當以到達率為變化參數時如 Figure 109 (a)，
伺服器之工作集隨著提升，這個部分與處理器使用率論述相同，只是變化差異較不明顯。而當以離開
率為變化參數時如 Figure 109 (b)，在離開率為 0.4 產生峰值與處理器使用率論述相同，但在離開率為
0.1 至 0.4 之間維持差不多的工作集使用率，這是因為到達的同儕數量一樣，而離開率也處於低至中間
值，所以平均後的工作集使用率相近，至於高離開率則對工作集使用率有較大影響。而當以品質為變
化參數時如 Figure 109 (c)，由實驗結果可以看到在品質為 8 產生分段，品質小於 8 時為遞增曲線，而
品質大於 8 則工作集保持在 50 左右，這是因為品質小於 8 時有較大機會只使用某些描述的資源，所以
影像序列不需要完整讀取，所以工作集使用率便以品質為據遞增，當品質大於 8 時，因為品質為常態
分布，所以某些同儕有較大機會分配為 16 條描述的品質，故幾乎所有影像序列需要讀取至工作集中並
0
5
10
15
20
25
2 4 6 8 10 12 14
C
P
U
 u
sa
g
e 
(%
) 
Arrival rate (peers/minute) 
Peer
Server
0
2
4
6
8
10
12
14
16
0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
C
P
U
 u
sa
g
e 
(%
) 
Failure rate (failure peers/arrival peer) 
0
2
4
6
8
10
12
14
16
18
20
2 4 6 8 10 12 14
C
P
U
 u
sa
g
e 
(%
) 
Quality (descriptions/peer) 
0
2
4
6
8
10
12
14
16 32 64 128 256 512
C
P
U
 u
sa
g
e 
(%
) 
Descriptions (descriptions/video) 
73 
P0
? ?
P1
? ?
P3
? ?
P4
? ?
P5
? ?
Description 1
P0
? ?
P1
? ?
P3
? ?
P5
? ?
Description 2
P0
? ?
P2
? ?
P3
? ?
P5
? ?
Description 3
P0
? ?
P1
? ?
P2
? ?
P4
? ?
Description 0
P5
? ?
Server
 
P0
? ?
P1
? ?
P4
? ?
P5
? ?
Description 1
P0
? ?
P1
? ?
P5
? ?
Description 2
P0
? ?
P2
? ?
P5
? ?
Description 3
P0
? ?
P1
? ?
P2
? ?
P4
? ?
Description 0
P5
? ?
Server
 
(a) Event occurs at t (b) P3 left 
P0
? ?
P1
29 12
P4
15 0
P5
9 0
Description 1
P0
34 14
P1
29 12
P5
9 0
Description 2
P0
34 14
P2
24 7
P5
10 0
Description 3
P0
? ?
P1
? ?
P2
24 7
Description 0
P5
9 0
P4
15 0
Server
 
P0
? ?
P1
29 12
P4
15 0
P5
9 0
Description 1
P0
34 14
P1
29 12
P5
9 0
Description 2
P0
34 14
P2
24 7
P5
10 0
Description 3
P0
? ?
P1
? ?
P2
24 7
P4
15 0
Description 0
P5
9 0
P4
15 0
Server
 
(c) Buffer range updated (d) P5 ask for inter-description recovery, P4 satisfied 
Figure 110 One case of Loopback-MDC sewing recovery network topology. 
在進行缺口修補時，由於來源資料是由提供者移動前的描述提供，所以可能會對畫面造成影響，
故由實驗截圖觀察之，Figure 111 顯示 P5 的描述 2 播放區塊 9 的最後 5 個畫面，而下一個區塊將為跨
串流描述修復的缺口，當 P5 接收 P4 的描述 0 之區塊 10 來修補缺口時，畫面表現如 Figure 112 所示。
由 PSNR 資訊得知，在缺口串流範圍畫面之畫質與正常接收畫面沒有明顯差異。 
75 
 
Figure 112 Descriptions combined result of 0-4th frame of chunk 10 in P5. 
5.7. 結論(Conclusion) 
本節實現 Loopback-MDC 之機制包含 OLF、內部串流描述修復與跨串流描述修復之縫合式修復，
並針對這些機制制定通訊協定，最後加入多媒體資料與播放器，結合 H.264/AVC 串流即時解碼，使本
實作結果接近實際應用。最後經由實驗數據得知，Loopback-MDC 機制在實作上表現與模擬結果相近，
得知 Loopback-MDC 在實際應用時也能保持其優勢。另外也得知在品質與同儕數量增加時，縫合式修
復所需時間會隨之提升。而當在品質增加時，內部串流描述修復所需時間將有所提升。而當
Loopback-MDC 機制不存在錯誤回復時，伺服器負擔效能將達降低最大 25%。本實作之伺服器實作效
能量測後，得知在設定實驗環境中，理論上可服務到達率 133。而播放器的效能，透過兩種控制機制
及 FPS 調整機制，使播放變得更為順暢且不影響 Loopback-MDC 機制。但實驗結果得知，當品質上升
或畫面大小增加時，FPS 調整機制漸漸影響觀看品質。最後因描述串流交換而產生的縫隙，由不同描
述串流修補時，對同儕觀看品質影響沒有明顯差異。 
  
(a) 0
th
 frame of chunk 10, 
PSNR (Y:29.36, 
U:40.59, V:41.52) 
(b) 1
st
 frame of chunk 10, 
PSNR (Y:28.79, 
U:40.28, V:41.21) 
(c) 2
nd
frame of chunk 10, 
PSNR (Y:28.73, 
U:40.02, V:41.21) 
(d) 3
rd
 frame of chunk 10, 
PSNR (Y:29.12, 
U:39.94, V:41.06) 
(e) 4
th
 frame of chunk 10, 
PSNR (Y:29.37, 
U:39.8, V:40.8) 
77 
參考文獻(References) 
[1]  A. Dan, D. Sitaram and P. Shahabuddin, “Scheduling policies for an on-demand video server with 
batching,” Proc. of ACM MM, pp.15-23, 1994. 
[2]  C. C. Aggarwal, J. L. Wolf, and P. S. Yu, “On optimal batching policies for video-on-demand storage 
servers,” in Proc. IEEE Int. Conf. Multimedia Computing and Systems, pp. 253–258, 1996. 
[3]  S. Sheu, Kien A. Hua, and W. Tavanapong, “Chaining: A generalized batching technique for 
video-on-demand,” in Proc. of the IEEE Int'l Conf. On Multimedia Computing and System, Ottawa, 
Ontario, Canada, pp. 110-117, 1997. 
[4]  K. A. Hua, Y. Cai, and S. Sheu, “Patching: a multicast technique for true video-on-demand services,” 
Proc. of ACM MM, pp.191-200, 1998. 
[5]  Y. Guo, K. Suh, J. Kurose, and D. Towsley, “P2Cast: peer-to-peer patching scheme for VoD service,” in 
Proc. WWW’03, Budapest, Hungary, 2003. 
[6]  L. Gao and D. Towsley, “Supplying instantaneous video-on-demand services using controlled multicast,” 
IEEE Multimedia, pp. 117–121, 1999. 
[7]  Dinesh C. Verma, Content Distribution Networks: An Engineering Approach, John Wiley & Sons, Inc., 
New York, NY, 2002. 
[8]  G. Pallis, and A. Vakali, “Insight and Perspectives for Content Delivery Networks,” Communications of 
the ACM, Vol. 49, No. 1, ACM Press, NY, USA, pp. 101-106, 2006. 
[9]  B. Krishnamurthy, C. Willis, and Y. Zhang, “On the Use and Performance of Content Distribution 
Network,” In Proceedings of 1st International Internet Measurement Workshop, ACM Press, pp. 169-182, 
2001. 
[10]  D. A. Tran, K. A. Hua, and T. Do, “ZIGZAG: An efficient peer-to-peer scheme for media 
streaming,” Proc. of IEEE INFOCOM, vol. 2, pp.1283-1292, 2003. 
[11]  A. Oram (editor), Peer-to-Peer: Harnessing the Power of Disruptive Technologies, O’Reilly Press, 
USA, 2001. 
[12]  D.S. Milojicic, V. Kalogeraki, R. Lukose, K. Nagaraja, J. Pruyne, B. Richard, S. Rollins, Z. Xu, 
Peer-to-peer computing, Technical Report HPL-2002-57R1, HP Laboratories, Palo Alto, USA, 3 July 
2003. 
[13]  E. Kusmierek, Y. Dong and D. H. C. Du, “Loopback: Exploiting collaborative caches for 
large-scale streaming,” IEEE Trans. on Multimedia, vol. 8, no. 2, pp.233-242, 2006. 
[14]  C.-L. Chan, S.-Y. Huang, H.-H. Chen, W.-H. Tung, and J.-S. Wang, “An application-level multicast 
framework for large scale VOD services,” Proc. of 11th International Conference on Parallel and 
Distributed Systems, vol. 1, pp.98-104, 2005. 
[15]  C.-L. Chan, S.-Y. Huang, N.-C. Lin, J.-S. Wang, “Performance analysis of caching strategies for 
proxy-assisted VOD services,” Information Technology and Applications, Proc. of Third International 
Conference on ICITA,vol. 2, pp.387-392, 2005. 
[16]  Y. Dong, E. Kusmierek, and Z. Duan, “Exploiting limited upstream bandwidth in peer-to-peer 
streaming,” Proc. of IEEE ICME, pp.1230-1233, 2005. 
[17]  林朝興, 李明憲, 王鼎超, “在 CDN-P2P 網路上採用跨串流描述修復提升影音服務的堅韌性,” 
2009 資訊科技國際研討會(AIT), 2009。 
79 
[38]  G. Tsirtsis and P. Srisuresh, “Network address translation - protocol translation (NAT-PT),” 2000. 
RFC-2766. Available: http://wiki.tools.ietf.org/html/rfc2766 
[39]  F. Audet and C. Jennings, “NAT Behavioral Requirements for Unicast UDP,” 2006. RFC 4787. 
Available: http://tools.ietf.org/html/rfc4787 
[40]  J. Watkinson, “The MPEG handbook: MPEG-1, MPEG-2, MPEG-4,” Focal Press, 2001. 
 
  
81 
of the Loopback-MDC using H.264/AVC Encoder and Decoder,” Multimedia Tools and 
Applications, in submission. 
會議論文 
1. C.-S. Lin and I.-T. Lee, “Loopback-MDC: Scalability Enhancement for Streaming Multiple 
Description Coded Video on CDN-P2P Network,” The 2010 International Conference on 
Business and Information (BAI2010), Kitakyushu, Japan, July, 2010.  
2. 林朝興, 陳安琪, 林哲維, 李明憲, “在 CDN-P2P 上使用 ExtLoopback-MDC 提升影音服務
的可用性,” 2009 National Computer Symposium (NCS 2009), Dec. 2009. 
3. 林朝興, 黎俊達, 王冠升, “以分群平衡機制之動態緩衝策略提升同儕式網路隨選視訊串
流效能,” 2009 National Computer Symposium (NCS 2009), Dec. 2009. 
4. C.-S. Lin and G.-S. Wang, “Balanced Dynamic Buffering for Scalable P2P Video-on-Demand 
Streaming with Multiple Description Coding,” The Fifth International Conference on 
Complex, Intelligent, and Software Intensive Systems (CISIS-2011), Korea, June, 2011. 
 
3. 請依學術成就、技術創新、社會影響等方面，評估研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）（以
500 字為限） 
 
 本計畫研究成果豐碩，共計將發表六篇國際期刊與四篇會議論文，對多媒體
串流、多重描述編碼、內容傳遞網路或同儕式網路等領域具相當貢獻。本計畫最
後設計並實作基於 Loopback-MDC 機制之系統，藉由收集數據驗證本機制在應
用上仍具有低伺服器負擔、適應裝置與網路異質性、高同儕服務穩定性之優勢。
雲端運算為本國現今重點發展項目之一，影音串流亦是雲端中關注的重點，本研
究在客戶端間以協力式快取提升延展性及堅韌度，成果將有助於雲端串流互動服
務品質(QoS)需求之發展。本計畫就一般網路如伺服器、代理與客戶端之架構進
行完整探討，未來當 Loopback-MDC 機制結合雲端服務網路架構，將需考慮雲
端與客戶端間的合作關係，可能出現多層式 Loopback-MDC 的架構，具有研究
討論空間。 
 
 
 
push the HCI application boundaries of this expanding horizon. The demonstration of the 
Multi-touch HCI research results which were started about ten years ago in the SDR lab is quite 
amazing. Lots of those foreseeing innovations have been successfully realized on most of emerging 
personal mobile devices, such as iPhone. It is interesting to foretell that the Multi-touch HCI 
techniques will eventually alter the way of human operating computing devices. 
 
Finally, I want to thank National Science Council for granting me the honor of participating in 
WiNA-2010. It is a wonderful experience to have professional conversations with worldwide 
outstanding researchers. Their opinions and suggestions not only enrich my knowledge but also are 
useful for my future research works. 
 
 
 
 
國科會補助計畫衍生研發成果推廣資料表
日期:2011/10/28
國科會補助計畫
計畫名稱: 運用多重編碼描述的協力式快取提升CDN-P2P網路上影音串流之延展性及堅韌
度
計畫主持人: 林朝興
計畫編號: 97-2221-E-024-014-MY3 學門領域: 計算機網路與網際網路
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
1. 入圍獎： 2009 全國計算機會議(NCS 2009) ’’’’最佳學生論文’’’’
獎 
2. 佳作、值得注目獎：99 學年大學院校網路通訊軟體與創意應用競賽，整合
型整合型羽球電子計分板暨即時賽制排程派送系統 
3. CISCO CERTIFIED NETWORK ADMINISTRATOR (CCNA) – August, 2009 
4. CISCO CERTIFIED ACADEMY INSTRUCTOR (CCAI) – August, 2009 
 
 
 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
