2reliability is obtained after all LBPs (UBPs) are added into the subset. After a certain number of
LBPs (UBPs) are used, the LB (UB) provides partial information about the MS2TRd with less
computational effort. Several authors have devoted themselves to searching the set of all LBPs and/or
UBPs [6]-[11], so that the MS2TRd can be computed/bounded by inclusion-exclusion method.
However, since searching for the set of all LBPs/UBPs is NP-hard, the inclusion-exclusion method
cannot avoid the computational pitfall of exponential execution time as the network size increases.
Recently, Satitsatian and Kapur (S&K) [12] present a lower bound algorithm for MS2TRd. Finally,
step 4 eliminates any vectors that are greater than LBPs from the search space. After a subset of LBP
is searched, the LB of MS2TRd can be computed by inclusion-exclusion principle.
J&L’s exact and direct method, without requiring a priori the lower and/or upper boundary
points of the network, decomposes a set of state vectors into an acceptable subset of state vectors and
disjoint subsets of state vectors. Each subset of state vectors is further classified as an acceptable,
unacceptable, or unspecified set. The probabilities of acceptable sets of state vectors contribute to the
MS2TRd. All the unacceptable sets of state vectors are suspended. Each unspecified set of state
vectors is similarly decomposed repeatedly until no unspecified set of state vectors is left. This note
modifies J&L’s algorithm to provide sequences of upper and lower bounds that converge to the
MS2TRd. This modified method pre-sets a critical value αfor classifying unspecified sets of state
vectors. Namely, an unspecified set of state vector is classified as α-qualified (α-unqualified) if its
probability is no less (smaller) than α. In J&L’s algorithm, all unspecified sets of state vectors are
decomposed. In the bounding algorithm only unspecified sets of state vectors that areα-qualified are
decomposed. Those unspecified andα-unqualified sets of state vectors, like unacceptable sets of state
vectors, are suspended.
The rest of the paper is organized as follows. In Section 2, J&L’s exact and direct algorithm is
briefly introduced. The modified version of J&L’s algorithm for bounding the MS2TRd is presented
in Section 3. In Section 4, two examples analyzed in S&K are employed. One is to illustrate the
bounding algorithm, the other is used for comparisons made between the bounding algorithm and
S&K’s algorithm. Conclusions are presented in Section 5.
2. The J&L’s Algorithm
This section briefly introduces J&L’s exact and direct algorithm for computing the MS2TRd.
Refer to J&L [1] for detail.
Property 1. For multi-state network G = (N,A,C), if the maximum flow from s to t under the largest
4algorithm are stated in the following properties 6 and 7 respectively.
Property 6. The exact algorithm takes O(m3#C) time where #C denotes the number of unspecified
sets of state vectors generated by the algorithm.
Property 7. Storage S requires O(n ini n1 ) memory space in the worst case.
3. The Bounding Algorithm
To trade off accuracy for execution time so that the MS2TRd can be approximated with
sufficient accuracy under an acceptable time, the α-qualified set of state vectors is introduced. For a
pre-specified value αwith 0 α< 1 an unspecified set of state vectors C is named α-qualified
(α-unqualified) if its probability is no less (smaller) than α, i.e., Pr(C) α(Pr(C) <α). Recall to the
steps 9 and 10 in the exact algorithm. We note here that “if F( Cl ) d then C is acceptable else if
F( Cu ) d then C is unspecified.”In the bounding algorithm, before each unspecified C is
decomposed according to steps 11-15, C has to be α-qualified. In other words, α-unqualified C is
suspended. With respect to value α, let UB and LB denote the upper and lower bounds for Rd
respectively. The bounding algorithm can be easily obtained by modifying the exact algorithm as
follows.
3.1 The bounding algorithm
1 Input: N, A,, s, t, d,α.
2 Procedure:
3 UB= 1, LB= 0
4 S = {collection_1}, collection_1 = { l , u ,(0,0,…,0),,0,0}
5 while Sdo
6 { Obtain the first C according to index i in the top collection of S
7 if i < I then i = i+1 else the top collection of S is discarded
8 Evaluate the maximum flows of F( Cl ) and F( Cu )
9 if F( Cl )d then LBis replaced by LB+ Pr(C) //C is acceptable//
10 else if F( Cu ) < d then UB= UB- Pr(C) //C is unacceptable//
11 else if Pr(C)αthen //C is unspecified andα-qualified//
12 { Derive a d-flow (f1d, f2d,…,fnd) and the Ad(C)
13 Decompose C into C1, C2, …,Cq and C0 by searching Cil
* , Ciu
* , CiK and
64.1 Example 1
a4
a3
a8
a7
a2
a1
1 7
a9
a10
2
3
5
6
4
a5
a6
Fig. 1. A multi-state network [12]
Table I Arc probabilities of Fig. 4
a1 a2 a3 a4 a5 a6 a7 a8 a9 a10
0 0.2 0.1 0.1 0.1 0.2 0.2 0.1 0.05 0.1 0.1
1 0.3 0.6 0.4 0.2 0.8 0.8 0.2 0.25 0.2 0.2
2 0.2 0.3 0.5 0.3 0.7 0.7 0.3 0.2
3 0.3 0.4 0.4 0.3
4 0.2
Fig. 1 and Table I, are employed for comparing S&K and the bounding algorithms. The
following 3 observations are made, and it is concluded that bounding algorithm is much superior to
S&K’s algorithm.
(1) In S&K’s algorithm, only LB is searched. However, both LB and UB are obtained in the
bounding algorithm. Without upper boundary value, the S&K’s algorithm supplies only partial
information about the exact reliability value.
(2) In S&K’s algorithm, though, for each demand d, the LB equals to the exact reliability value when
4 minimal cuts are used (except d=1, where 3 and 4 minimal cuts are used), without upper boundary
value, it is hard to decide whether one more minimal cut is needed to search a better LB (like case
d=1, where both 3 and 4 minimal cuts are used to search the LB but have the same LB value). On the
other hand, the bounding algorithm stops testing a smallervalue whenever LB equals UB.
(3) In addition to the supplement of UB, the bounding algorithm can reach a larger LB in a smaller
CPU time than the S&K’s algorithm. In fact, in a small example like Fig. 5, the bounding algorithm
