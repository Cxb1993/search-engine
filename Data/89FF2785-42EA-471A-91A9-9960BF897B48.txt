i 
??????? 
???? 
?? G???????????? G????????????????
???????????????????????????????????
??????????????????????????????????
???????????????????????????????????
????????????????? NP-complete????????????
???????????????????????????????????
?????? G????????????? G ?????????????
???????????????????????????????????
??? NP-hard??????????????????????????? 
???????????????????????????????
O(n2 logn)?????????? n ???????????????????
???????????????????????????????????
???????????????????????????????????
?????????????????? O(n2 logn)????????????
?????????????? O(n2 logn)????????????????
??????? 
?????????O(∆n)?????????????????????
?∆????????????????????????????O(∆n)??
?????????????????????????O(∆n)?????? 
???? ???????????????????????????? 
 
 
iii 
?  ? 
??????? ............................................................................................................ i 
?????? ............................................................................................................... 1 
??????............................................................................................................ 1 
?????????????................................................................................ 2 
????????.................................................................................................... 2 
?????????.............................................................................................. 12 
?????? ............................................................................................................. 13 
???????? ..................................................................................................... 16 
???An Efficient Algorithm for the Hamiltonian Cycle Problem on Circular-Arc 
Graphs  
 
 
 
 
 
 
? 2 ? 
problem is called the Hamiltonian 
related problem. 
A circular-arc family F is a 
collection of arcs in a circle. A graph G 
is a circular-arc graph if there exist a 
circular-arc family F and a one-to-one 
mapping of the vertices of G and the 
arcs in F such that two vertices in G are 
adjacent if and only if their 
corresponding arcs in F intersect. For a 
circular-arc family F, G(F) denotes the 
graph constructed from F. Circular-arc 
graphs were introduced as a 
generalization of interval graphs 
(similarly defined, except that intervals 
on a real line are used instead of arcs on 
a circle) [16]. If there exists a point on 
the circle such that no arc of F covers it, 
then G(F) is an interval graph. Both 
classes of graphs have a variety of 
applications involving traffic light 
sequencing, VLSI design, scheduling 
[16] and genetics [38]. In the report, we 
will use V(F) and E(F) to denote the 
vertex and edge sets of G(F), 
respectively, i.e. G(F) = (V(F), E(F)). 
????????????? 
In this report, we solve the 
Hamiltonian cycle problem on 
circular-arc graphs in O(∆n) time. This 
improves the best previous result in [35] 
for this problem which is an O(n2 logn) 
-time algorithm. Previous related works 
are summarized below. Arikati and 
Rangan presented an O(n+m)-time 
algorithm to solve the path cover 
problem on interval graphs [1]. Chang et 
al. proposed O(n)-time algorithms for 
both the Hamiltonian cycle and path 
cover problems on interval graphs given 
a set of n sorted intervals [7]. 
Damaschke presented an algorithm for 
the Hamiltonian path problem on 
circular-arc graphs that runs in O(n5) 
time [11]. Shih et al. proposed an O(n2 
logn)-time algorithm for the 
Hamiltonian cycle problem on 
circular-arc graphs [35]. The algorithm 
proposed by Bonuccelli and Bovet for 
solving the path cover problem on 
circular-arc graphs [5] contains a flaw 
which is pointed out in [35]. Some 
researchers [6, 27, 28] claimed that 
O(n)-time algorithms exist for the 
Hamiltonian cycle problem and the path 
cover problem on circular-arc graphs 
given n sorted arcs as an arc family, but 
they have not yet succeeded in proving 
the correctness of their algorithms. In 
[23], we showed that the Hamiltonian 
path and path cover problems on 
circular-arc graphs can be solved by an 
algorithm whose time complexity is the 
same as that of the most efficient 
algorithm for the Hamiltonian cycle 
problem on the same class of graphs. 
Hence, we conclude that the 
Hamiltonian and related problems on 
circular-arc graphs are solvable in O(∆n) 
time. 
???????? 
Tucker presented an O(n3)-time 
algorithm for testing whether a graph is 
a circular-arc graph [37]. Hsu proposed 
? 4 ? 
of C from G disconnects G. We call C a 
connecting set of G if C is a cutset of G 
and the removal of C from G 
disconnects G into at least |C|+1 
connected components. 
Our algorithm for solving the 
Hamiltonian cycle problem on 
circular-arc graphs reduces the problem 
to the path cover and Hamiltonian cycle 
problems on interval graphs. Arikati and 
Rangan presented an O(n+m)-time 
algorithm for the path cover problem on 
interval graphs [1]. Manacher et al. 
solved the Hamiltonian cycle problem 
on interval graphs in linear time [29]. 
These two algorithms can be 
implemented in O(n) time given a set of 
n sorted intervals [7]. 
In the rest of the report, let I be a 
set of intervals on the real line. Every 
interval in I is defined by its left 
endpoint and right endpoint. Without 
loss of generality, assume that (1) no 
two distinct intervals in I have endpoints 
in common and (2) the left and right 
endpoints of every interval in I are 
distinct, i.e., the left endpoint of an 
interval is to the left of its right endpoint. 
Assume that intervals in I are labeled by 
integers from 1 to n in the increasing 
order of their right endpoints. Notice 
that we do not distinguish an interval 
from its label. 
Definition 5. Let x be an interval in I. 
Denote the left endpoint and right 
endpoint of x by left(x) and right(x), 
respectively, and denote x by [left(x), 
right(x)]. 
Definition 6. Let x and y be two distinct 
intervals in I. We say that x is smaller 
than y, denoted by x < y, if right(y) is to 
the right of right(x). Denote by s(I) the 
interval in I with the leftmost right 
endpoint. 
We next review two algorithms 
presented in [1] and [23] on interval 
graphs that are used in our algorithm. 
The first one is a greedy algorithm for 
the path cover problem on interval 
graphs. The second one is a greedy 
algorithm to find a subset C of a set I of 
intervals such that G(I\ C) has |C|+1 
connected components. We briefly 
describe them below. 
The path cover problem on interval 
graphs can be solved by the algorithm 
presented in [1]. Note that intervals of I 
are labeled in increasing order according 
to their right endpoints. The algorithm 
bases upon a greedy principle to extend 
a path Zi = z1→ z2→ … → zk, k ≥ 1. 
Initially, i =1 and Z1 visits s(I); i.e., z1 = 
s(I). Then, the unvisited neighbor of zk 
with the leftmost right endpoint is 
chosen and Zi is extended to visit it. If 
no such neighbor exists, then path Zi is 
stopped and a new path Zi+1 is started in 
the remaining graph from the smallest 
labeled unvisited interval if possible. To 
simplify the notation, we denote the 
algorithm and its output by Algorithm 
GP and GP(I), respectively. For instance, 
Algorithm GP outputs two paths given 
the set of intervals shown in Figure 1. 
These two paths are Z1 = i1→ i2→ i3→ 
i4→ i6→ i5 and Z2 = i7→ i8→ i9→ i10→ 
? 6 ? 
greedy path Z1 = i1→ i2→ i3→ i4→ i6→ 
i5 in Figure 1, Procedure GCS outputs 
C(Z1)= {i6} and R(Z1)= {i1→ i2→ i3→ i4, 
i5}.  
The following lemma is verified in 
Appendix which reveals the properties 
of Algorithm GP and procedure GCS: 
Lemma 1. Let C(GP(I)) = ∪Zi∈GP(I)C(Zi) 
and R(GP(I)) = ∪Zi∈GP(I)R(Zi), where Zi 
is the i-th greedy path output by 
Algorithm GP(I), C(Zi) is the greedy 
connecting set of Zi, and R(Zi) = Zi\ 
C(Zi). Then, the following statements 
hold: 
(1) If |GP(I)| ≥ 2, then the removal of 
C(Z1) from G(I) results in at least 
|C(Z1)|+2 connected components. 
(2) Each element of R(GP(I)) is a 
connected component of G(I\ 
C(GP(I))). 
(3) |R(GP(I))| = |C(GP(I))|+|GP(I)|. 
For instance, let I be the set of 
intervals shown in Figure 1. Then, 
C(GP(I)) = {i6, i12} and R(GP(I)) = 
{i1→ i2→ i3→ i4, i5, i7→ i8→ i9→ i10, 
i11}. By Lemma 1, we can find a subset 
C(GP(I)) of I such that |R(GP(I))| = 
|C(GP(I))|+|GP(I)|. Each path of 
R(GP(I)) is a connected component of 
G(I\C(GP(I))).  
The following theorem can be 
easily derived by the above lemma: 
Theorem 2. (Arikati et al. [1]; Hung et 
al. [23]) GP(I) is a minimum path cover 
of G(I). 
Based on the greedy path cover 
algorithm on interval graphs, we design 
an O(∆n)-time algorithm for solving the 
Hamiltonian cycle problem on G(F) 
given a set F of n sorted arcs. Our 
algorithm reduces the problem to the 
Hamiltonian cycle and the path cover 
problems on interval graphs. Note that 
the Hamiltonian cycle and the path 
cover problems on interval graphs can 
be solved in O(n) time if the input is a 
set of n intervals with endpoints sorted 
[1, 7, 29]. 
Definition 8. For a point q on the circle, 
let Bp(q) be the set of all arcs in F 
containing point q. For an arc x in F, let 
Ba(x) be the set of all arcs in F 
containing arc x. 
Definition 9. Let q be a point on the 
circle.  An arc v containing point q can 
be divided into two open segments (h(v), 
q) and (q, t(v)), called the head portion 
and tail portion of arc v with respect to q, 
respectively, by removing q from v. 
Denote the head portion and tail portion 
of arc v with respect to q by head(v, q) 
and tail(v, q), respectively. For a set B of 
arcs containing q, let head(B, q) = 
{head(v, q) | v ∈ B } and tail(B, q) = 
{tail(v, q) | v ∈ B }. 
Definition 10. For a point q on the circle 
and a subset B of Bp(q), let Fc(B, q) = (F\ 
B) ∪ tail(B, q) and Fcc(B, q) = (F\ B) ∪ 
head(B, q). For each v ∈ F, (either v ∈ 
Fc(B, q) or tail(v, q) ∈ Fc(B, q)) or 
(either v ∈ Fcc(B, q) or head(v, q) ∈ 
Fcc(B, q)). We refer to the portion of arc 
v in Fc(B, q) and Fcc(B, q) as arc v in 
Fc(B, q) and Fcc(B, q), respectively. 
? 8 ? 
[q, t(x)] and coalesce it to interval Ic(x), 
i.e., Ic(x) = Ic(x) ∪ [q, t(x)] = [h(x), t(x)]. 
We refer to such a conversion as 
clockwise conversion starting from point 
q. For instance, by a clockwise 
conversion starting from point h(a1) we 
convert Fc(Ba(a1), h(a1)) (as shown in 
Figure 3) into a set Ic(Fc(Ba(a1), h(a1))) 
of intervals as shown in Figure 5.  By 
the same way, we can convert arcs in 
Fcc(B, q) into a set Icc(Fcc(B, q)) of 
intervals in counterclockwise direction 
starting from point q on the circle. We 
refer to such a conversion as 
counterclockwise conversion starting 
from point q. For instance, by a 
counterclockwise conversion starting 
from point t(a8), we convert Fcc({a9, 
a10}, t(a8)) (as shown in Figure 4) into a 
set Icc(Fcc({a9, a10}, t(a8))) of intervals 
as shown in Figure 6. By definition, 
there is a one-to-one mapping between 
the sets of arcs of F and Fc(B, q) (resp. 
Fcc(B, q)). There is also a one-to-one 
mapping between the set Fc(B, q) of arcs 
and the set Ic(Fc(B, q)) of intervals (resp. 
Fcc(B, q) and Icc(Fcc(B, q))). Therefore 
there is also a one-to-one mapping 
between the set F of arcs and the set 
Ic(Fc(B, q)) of intervals (resp. F and 
Icc(Fcc(B, q))). 
Definition 11. Let q be a point on the 
circle, B be a subset of Bp(q), and let 
F~ = Fc(B, q) (resp. F
~ = Fcc(B, q)). Let I 
be Ic( F
~ ) (resp. Icc( F
~ )). Let x be an arc 
in F and let X be a subset of F. We use 
F~ (x) to denote the portion of arc x in 
F~  and use F~ (X) to denote { F~ (x) | x 
∈ X}. We use I(x) to denote the interval 
corresponding to arc x in I and I(X) to 
denote {I(x) | x ∈ X}. Let y be an 
interval in I and let Y be a subset of I. 
We use F(y)and F~ (y) to denote the arcs 
in F and F~ , respectively, corresponding 
to y. We use F(Y) and F~ (Y) to denote 
{F(y) | y ∈ Y} and { F~ (y) | y ∈ Y}, 
respectively. For an arc z ∈ F~ , we use 
F(z) and I(z) to denote the arc in F and 
the interval in I, respectively, 
corresponding to z. For a path P and a 
path cover PC in G(I), we use F(P) and 
F(PC) to denote the path and path cover 
in G(F) corresponding to P and PC, 
a1a3a4
a2
a5
a6
a7a8
a9
a10
a11
Figure 6: (  ({ , }, ( ))) for  shown in Figure 4I t acc 8Fcc a a F a a t a9 10 9 10 8cc ({ , }, ( ))
a1 a3 a4
a2
a5
a6
a7 a8
a9
a10
a11
Figure 5: (  ( ( ), ( ))) for  shown in Figure 3I B a h ac a 1 1F F B a h ac c ( ( , ( ))a 1 1
? 10 ? 
x ∈ F(C(P))\ {wP}; 
26. let Q = QP → PQ  such that 
I2(wP) = end(QP); let Pz  be the 
arc corresponding to start( PQ ); 
27. if 
Pz ∉ F(C(Q)), then output 
“G(F) has no Hamiltonian cycle” 
and stop. 
28. call Procedure GCS(QP) to find 
L(QP);  
29. if L(QP) ≠ ∅, then output “G(F) 
has no Hamiltonian cycle” and 
stop. 
30. let Rˆ = { rˆ∈ F | rˆ  ∈ F( PQ ) 
and t( rˆ ) is contained in 
seg(h(wP), t(v))}; 
31. let Fˆ  = F\ Rˆ∪ 
head( Rˆ ,h(wP)); 
32. call Algorithm HC( Fˆ , u); 
We then give an example to 
illustrate the above algorithm in the 
following. Let F be the set of arcs shown 
in Figure 2 and let arc u = a1. The set F1 
= Fc(Ba(a1), h(a1)) of arcs is shown in 
Figure 3. The set I1 of intervals obtained 
from F1 by a clockwise conversion 
starting from h(a1) is shown in Figure 5. 
This first greedy path P output by 
Algorithm GP(I1) is a1 → a2 → a3 → a5 
→ a4 → a6 → a9 → a7 → a10 → a8 
which is not a Hamiltonian path of G(I1). 
It is straightforward to verify that v = a8 
and C(P) = L(P) = {a9, a10}. The set F2 
= Fcc({a9, a10}, t(a8)) of arcs is shown in 
Figure 4. The set I2 of intervals obtained 
from F2 by a counterclockwise 
conversion starting from t(a8) is shown 
in Figure 6. Call Algorithm GP(I2) to 
compute |GP(I2)| = 1. Then, Q = a8 → 
a10 → a7 → a9 → a6 → a4 → a5 → a3 → 
a2 → a1 → a11 is a Hamiltonian path of 
G(I2). We can find that arc z = a8 does 
not intersect arc w = a11 and G(I2) has no 
Hamiltonian cycle. Next, it computes 
C(Q) = {a2, a5, a6}, L(Q) = {a2, a5}, and 
R = {a10}. In this time, R ≠ ∅, s = a10, 
and sI 2  = I2\ {a10}. Then, |GP(
sI 2 )| = 2. 
It is straightforward to verify that wP = 
a9, Pz  = a6, QP = a8 → a10 → a7 → a9, 
and 
PQ  = a6 → a4 → a5 → a3 → a2 → 
a1 → a11. Since Pz ∈ F(C(Q)) and L(QP) 
= ∅, the algorithm does not terminate at 
either line 27 or 29. The algorithm then 
computes Rˆ = { rˆ ∈ F | rˆ  ∈ F( PQ ) 
and t( rˆ ) is contained in seg(h(a9), t(a8))} 
= {a6} and Fˆ  = F\ {a6}∪ 
head({a6},h(a9)) which is shown in 
Figure 7. It then calls Algorithm HC( Fˆ , 
a1) recursively. To distinguish the 
symbols in Algorithm HC( Fˆ , a1) from 
those in Algorithm HC(F, a1), we will 
use 1ˆI , 2Iˆ , Pˆ , and Qˆ  to denote I1, I2, 
P, and Q, respectively, which are as 
defined in Algorithm HC(F, a1). Fˆ  is 
first converted to a set 1ˆI  of intervals 
by a clockwise conversion starting from 
h(a1) (as shown in Figure 8). The first 
greedy path output by Algorithm GP( 1ˆI ) 
is Pˆ  = a1 → a2 → a3 → a5 → a4 → a6. 
In this time, L( Pˆ ) = ∅. Note that we can 
prove that L( Pˆ ) = ∅ in Appendix. Next, 
Algorithm HC( Fˆ , a1) converts Fˆ  to 
the set 2Iˆ  of intervals by a 
counterclockwise conversion starting 
from t(a6) (as shown in Figure 9). Call 
Algorithm GP( 2Iˆ ). The only path output 
by Algorithm GP( 2Iˆ ) is Qˆ  = a4 → a6 
→ a3 → a5 → a1 → a11 → a10 → a8 → 
a9 → a7 → a2. Arcs a4 does not intersect 
arc a2 in Fˆ  and hence, it does not 
terminate at line 13. By the Hamiltonian 
cycle algorithm for interval graphs, we 
find that G( 2Iˆ ) has a Hamiltonian cycle 
a4 → a6 → a3 → a2 → a1 → a11 → a10 
→ a8 → a9 → a7 → a5 → a4. It is a 
Hamiltonian cycle of G( Fˆ ) and hence, 
it is a Hamiltonian cycle of G(F) too. 
Note that we can prove, in Appendix, 
? 12 ? 
|GP( sI 2 )|=2, Pz ∈ F(C(Q)), 
and L(QP) = ∅. Then, G(F) is 
Hamiltonian if and only if 
G( Fˆ ) is Hamiltonian  (line 
32). 
The above claims are proved in 
Appendix. The correctness of Algorithm 
HC is based on the above claims. On the 
other hand, we show, in Appendix, that 
the recursive call in line 32 occurs only 
once. The other lines of Algorithm HC 
can be done in O(1) and lines 16 to 23 
are iterated at most ∆ times. Hence the 
time complexity of Algorithm HC is 
O(∆n). The details of complexity 
analysis are shown in Appendix. We 
finally conclude the following theorem: 
Theorem 3. Algorithm HC solves the 
Hamiltonian cycle problem on 
circular-arc graphs in O(∆n) time. 
Together with the result in [23], we 
have the following corollary: 
Corollary 4. The Hamiltonian path and 
path cover problems on circular-arc 
graphs can be solved in O(∆n) time. 
????????? 
In this project, we solve the 
Hamiltonian cycle problem on 
circular-arc graphs in O(∆n) time, where 
n and ∆ represent the number of vertices 
and the maximum degree of the input 
graph, respectively. This improves the 
best previous result in [35] for this 
problem which is an O(n2 logn)-time 
algorithm.  
It follows immediately from the 
result in [23] that both the Hamiltonian 
path and path cover problems on 
circular-arc graphs can also be solved in 
O(∆n) time. It is interesting to know 
whether the approach used in this paper 
can be applied to design efficient 
algorithms for other classes of graphs. In 
the future, we would like to solve the 
Hamiltonian cycle or Hamiltonian path 
problem on circular-arc graphs in O(n) 
time if a set F of n arcs with endpoints 
sorted is given. 
 
? 14 ? 
[16] M.C. Golumbic, Algorithmic Graph Theory and Perfect Graphs, Academic Press, 
New York, 1980.  
[17] S.Y. Hsieh, C.W. Ho, T.S. Hsu and M.T. Ko, The Hamiltonian problem on 
distance-hereditary graphs, Discrete Appl. Math. 153 (2006) 508-524. 
[18] W.L. Hsu and K.H. Tsai, Linear time algorithms on circular-arc graphs, Inform. 
Process. Lett. 40 (1991) 123-129. 
[19] W.L. Hsu, O(M ⋅N) algorithms for the recognition and isomorphism problems on 
circular-arc graphs, SIAM J. Comput. 24 (1995) 411-439. 
[20] R.W. Hung, S.C. Wu and M.S. Chang, Hamiltonian cycle problem on 
distance-hereditary graphs, J. Inform. Sci. Eng. 19 (2003) 827-838. 
[21] R.W. Hung and M.S. Chang, A simple linear algorithm for the connected 
domination problem in circular-arc graphs, Discuss. Math. Graph Theory 24 
(2004) 137-145. 
[22] R.W. Hung and M.S. Chang, Linear-time algorithms for the Hamiltonian 
problems on distance-hereditary graphs, Theoret. Comput. Sci. 341 (2005) 
411-440. 
[23] R.W. Hung and M.S. Chang, Solving the path cover problem on circular-arc 
graphs by using an approximation algorithm, Discrete Appl. Math. 154 (2006) 
76-105. 
[24] A. Itai, C.H. Papadimitriou and J.L. Szwarcfiter, Hamiltonian paths in grid 
graphs, SIAM J. Comput. 11 (1982) 676-686. 
[25] D.S. Johnson, The NP-complete column: an ongoing guide, J. Algorithms 6 
(1985) 434-451. 
[26] M.S. Krishnamoorthy, An NP-hard problem in bipartite graphs, SIGACT News 7 
(1976) 26. 
[27] Y.D. Liang and G.K. Manacher, An O(n logn) algorithm for finding a minimal 
path cover in circular-arc graphs, in: Proceedings of the ACM conference on 
Computer Science, Indianapolis, IN, USA, 1993, pp. 390-397. 
[28] Y.D. Liang, G.K. Manacher, C. Rhee and T.A. Mankus, A linear algorithm for 
finding Hamiltonian circuits in circular-arc graphs, in: Proceedings of the 32nd 
Southeast ACM conference, 1994, pp. 15-22. 
[29] G.K. Manacher, T.A. Mankus and C.J. Smith, An optimum Θ(n logn) algorithm 
for finding a canonical Hamiltonian path and a canonical Hamiltonian circuit in a 
set of intervals, Inform. Process. Lett. 35 (1990) 205-211. 
[30] S. Masuda and K. Nakajima, An optimal algorithm for finding a maximum 
independent set of a circular-arc graph, SIAM J. Comput. 17 (1988) 41-52. 
[31] R.M. McConnell, Linear-time recognition of circular-arc graphs, Algorithmica 
37 (2003) 93-147. 
? 16 ? 
???????? 
?????????????????????????????????
?????????????????????????????? 
?????????????????????????????????
???????????????????????????????????
??????????????????????? 
1. ???????(O(∆n))???????????????????? 
2. ??????????[23]?????????????????????
?????? O(∆n)?????? 
3. ???????????????????????????????? 
4. ?????????????????????????????????
??????????????? 
 
An Eﬃcient Algorithm for the Hamiltonian Cycle Problem
on Circular-Arc Graphs∗
Ruo-Wei Hung
Department of Computer Science and Information Engineering,
Chaoyang University of Technology,
Wufong, Taichung 413, Taiwan
E-mail: rwhung@cyut.edu.tw
August 19, 2007
Abstract
A Hamiltonian cycle in a graph G is a simple cycle in which each vertex of G
appears exactly once. The Hamiltonian cycle problem involves testing whether a
Hamiltonian cycle exists in a graph, and ﬁnds one if such a cycle does exist. It is well
known that the Hamiltonian cycle problem is one of the classic NP-complete problems
on general graphs. It is interesting to eﬃciently solve it on special classes of graphs.
Shih et al. solved the Hamiltonian cycle problem on circular-arc graphs in O(n2 log n)
time [35], where n is the number of vertices of the input graph. Whether there exists
an eﬃcient algorithm whose time-complexity is better than O(n2 log n) for solving the
Hamiltonian cycle problem on circular-arc graphs has languished for a decade. In
this paper, we present an O(∆n)-time algorithm to solve it, where ∆ represents the
maximum degree of the input graph.
Keywords: graph algorithms, Hamiltonian cycle problem, path cover problem, in-
terval graphs, circular-arc graphs
AMS subject classiﬁcations. 05C85, 68Q25, 68Q20, 68R20, 68R10, 90C27
∗The research was supported in part by the National Science Council of Republic of China under grant
no. NSC95-2221-E-324-056.
1
to denote the vertex and edge sets of G(F ), respectively, i.e., G(F ) = (V (F ), E(F )).
In this paper, we solve the Hamiltonian cycle problem on circular-arc graphs in O(∆n)
time. This improves the best previous result in [35] for this problem which is anO(n2 log n)-
time algorithm. Previous related works are summarized below. Arikati and Rangan pre-
sented an O(n+m)-time algorithm to solve the path cover problem on interval graphs [1].
Chang et al. proposed O(n)-time algorithms for both the Hamiltonian cycle and path cover
problems on interval graphs given a set of n sorted intervals [7]. Damaschke presented
an algorithm for the Hamiltonian path problem on circular-arc graphs that runs in O(n5)
time [11]. Shih et al. proposed an O(n2 log n)-time algorithm for the Hamiltonian cycle
problem on circular-arc graphs [35]. The algorithm proposed by Bonuccelli and Bovet for
solving the path cover problem on circular-arc graphs [5] contains a ﬂaw which is pointed
out in [35]. Some researchers [6, 27, 28] claimed that O(n)-time algorithms exist for the
Hamiltonian cycle problem and the path cover problem on circular-arc graphs given n
sorted arcs as an arc family, but they have not yet succeeded in proving the correctness of
their algorithms. In [23], we showed that the Hamiltonian path and path cover problems
on circular-arc graphs can be solved by an algorithm whose time complexity is the same as
that of the most eﬃcient algorithm for the Hamiltonian cycle problem on the same class
of graphs. Hence, we conclude that the Hamiltonian cycle, Hamiltonian path, and path
cover problems on circular-arc graphs can be solved in O(∆n) time.
The paper is organized as follows. In Section 2, we deﬁne some notations and review
a greedy algorithm on interval graphs. We also review some observations appeared in
[23] on this algorithm to be used in proving the correctness of our algorithm. In Section
3, we present an algorithm for the Hamiltonian cycle problem on circular-arc graphs and
analyze the complexity of our algorithm. Section 4 shows the correctness of our algorithm.
Finally, some concluding remarks and future work are given in Section 5.
2 Preliminaries
Tucker presented an O(n3)-time algorithm for testing whether a graph is a circular-arc
graph [37]. Hsu proposed an O(mn)-time algorithm to recognize circular-arc graphs [19].
Eschen and Spinrad proposed an O(n2)-time recognition algorithm for circular-arc graphs
[14]. McConnell presented an O(n+m)-linear-time recognition algorithm for circular-arc
graphs [31]. An arc family F can be obtained by these recognition algorithms in the
3
Deﬁnition 2.4. A subset C of vertices of a graph G is called a cutset if the removal of
C from G disconnects G. We call C a connecting set of G if C is a cutset of G and the
removal of C from G disconnects G into at least |C|+ 1 connected components.
Since each connected subgraph needs to be covered by at least one path, the following
proposition is easily veriﬁed by the pigeonhole principle:
Proposition 2.1. (Shih et al. [35]) Let C be a cutset of a connected graph G and let g
be the number of connected components in G \ C. Then, π(G) ≥ g − |C|.
For a graph G = (V,E) and a subset C of V , let E(C) denote the set of edges of E that
connect two vertices in C. The following two propositions are very important in proving
the correctness of our algorithm and can be easily veriﬁed by the pigeonhole principle:
Proposition 2.2. Let C be a cutset of a connected graph G and let g be the number of
connected components in G \ C such that g > |C|. Then, G has no Hamiltonian cycle.
Proposition 2.3. Let C be a cutset of a connected graph G = (V,E) and let g be the
number of connected components in G \ C such that g = |C|. Then, G is Hamiltonian if
and only if GC = (V,E \ EC) is Hamiltonian, where EC is a subset of E(C).
Our algorithm for the Hamiltonian cycle problem on circular-arc graphs reduces the
problem to the path cover and Hamiltonian cycle problems on interval graphs. Arikati
and Rangan presented an O(n+m)-time algorithm for the path cover problem on interval
graphs [1]. Manacher et al. solved the Hamiltonian cycle problem on interval graphs in
linear time [29]. These two algorithms can be implemented in O(n) time given a set of n
sorted intervals [7].
In the rest of this section, let I be a set of intervals on the real line. Every interval
in I is deﬁned by its left endpoint and right endpoint. Without loss of generality, assume
that (1) no two distinct intervals in I have endpoints in common and (2) the left and
right endpoints of every interval in I are distinct, i.e., the left endpoint of an interval is
to the left of its right endpoint. In the following, assume intervals in I are labeled by
integers from 1 to n in the increasing order of their right endpoints. Notice that we do
not distinguish an interval from its label.
Deﬁnition 2.5. Let x be an interval in I. Denote the left endpoint and right endpoint
of x by left(x) and right(x), respectively, and denote x by [left(x), right(x)].
5
Deﬁnition 2.7. Let Z be a path of G(I). Use L(Z) to denote the set {x|x ∈ Z and
end(Z) < x}. A path Z is called a monotone path if and only if L(Z) = ∅.
For the set I of intervals shown in Fig. 1 and GP (I) = {Z1 = i1 → i2 → i3 → i4 →
i6 → i5, Z2 = i7 → i8 → i9 → i10 → i12 → i11}, L(Z1) = {i6} and L(Z2) = {i12}.
The following lemma can be veriﬁed by the greedy rule of Algorithm GP and has been
proved in [23].
Lemma 2.4. (Hung et al. [23]) Suppose Z is a greedy path in GP (I). Then,
(1) an interval x ∈ Z if and only if left(x) is to the left of right(end(Z)),
(2) if intervals x and y do not intersect and x, y ∈ Z, then Z visits x before y if and only
if x  y,
(3) an interval x ∈ L(Z) if and only if x contains right(end(Z)), and
(4) an interval x ∈ L(Z) if and only if x contains end(Z).
Given a greedy path Z in GP (I), we can ﬁnd a subset C(Z) of Z satisfying that the
removal of C(Z) from Z disconnects Z into |C(Z)| + 1 subpaths [23]. The procedure is
formally presented as follows:
Procedure GCS
Input: Z, a greedy path in GP (I).
Output: C(Z), the greedy connecting set of path Z, and R(Z), the set of all of the sub-
paths of Z obtained by removing C(Z) from Z.
Process:
1. C(Z) = ∅; S = Z; R(Z) = ∅;
2. z = end(Z); CurrentPathEnd = end(Z);
3. while z 
= start(S) do
4. z = predecessor(z), where S visits predecessor(z) right before z;
5. if CurrentPathEnd < z, then
6. let S = S1 → z → S2, where S1 and S2 are two sub-paths of S;
7. C(Z) = C(Z) ∪ {z}; R(Z) = R(Z) ∪ {S2};
8. S = S1; CurrentPathEnd = end(S1); z = end(S1);
9. R(Z) = R(Z) ∪ {S};
10. output C(Z) and R(Z).
7
Lemma 2.7. Let C(GP (I)) = ∪Zi∈GP (I)C(Zi) and R(GP (I)) = ∪Zi∈GP (I)R(Zi), where
Zi is the i-th greedy path output by Algorithm GP(I), C(Zi) is the greedy connecting set
of Zi, and R(Zi) = Zi \ C(Zi). Then, the following statements hold:
(1) If |GP (I)| ≥ 2, then the removal of C(Z1) from G(I) results in at least |C(Z1)| + 2
connected components.
(2) Each element of R(GP (I)) is a connected component of G(I \ C(GP (I))).
(3) |R(GP (I))| = |C(GP (I))|+ |GP (I)|.
For instance, let I be the set of intervals shown in Fig. 1. Then, C(GP (I)) = {i6, i12}
and R(GP (I)) = {i1 → i2 → i3 → i4, i5, i7 → i8 → i9 → i10, i11}. By Lemma 2.7, we can
ﬁnd a subset C(GP (I)) of I such that |R(GP (I))| = |C(GP (I))| + |GP (I)|. Each path
in R(GP (I)) is a connected component of G(I \ C(GP (I))). It follows immediately from
Lemma 2.7 and Proposition 2.1 that the following theorem holds:
Theorem 2.8. (Arikati et al. [1]; Hung et al. [23]) GP (I) is a minimum path cover of
G(I).
3 The Hamiltonian Cycle Algorithm
In this section, we present an O(∆n)-time algorithm to solve the Hamiltonian cycle prob-
lem on G(F ) given a set F of n sorted arcs. Our algorithm reduces the problem to the
Hamiltonian cycle and the path cover problems on interval graphs. Note that the Hamil-
tonian cycle and the path cover problems on interval graphs can be solved in O(n) time if
the input is a set of n intervals with endpoints sorted [1, 7, 29].
Deﬁnition 3.1. For a point q on the circle, let Bp(q) be the set of all arcs in F containing
point q. For an arc x in F , let Ba(x) be the set of all arcs in F containing arc x.
Deﬁnition 3.2. Let q be a point on the circle. An arc v containing point q can be
divided into two open segments (h(v), q) and (q, t(v)), called the head portion and the
tail portion of arc v with respect to q, respectively, by removing q from v. Denote the
head portion and the tail portion of arc v with respect to q by head(v, q) and tail(v, q),
respectively. For a set B of arcs containing q, let head(B, q) = {head(v, q)|v ∈ B} and
tail(B, q) = {tail(v, q)|v ∈ B}.
Deﬁnition 3.3. For a point q on the circle and a subset B of Bp(q), let Fc(B, q) =
(F \B)∪tail(B, q) and Fcc(B, q) = (F \B)∪head(B, q). For each v ∈ F , (either v ∈ Fc(B, q)
9
a1
a2
a3
a4
a5
a6a7
a8
a9
a10 a11
Fig. 3: Fc(Ba(a1), h(a1)) for the set F of arcs shown in Fig. 2.
a1
a2
a3
a4
a5
a6a7
a8
a11
a9
a10
Fig. 4: Fcc({a9, a10}, t(a8)) for the set F of arcs shown in Fig. 2.
11
use F (z) and I(z) to denote the arc in F and the interval in I, respectively, corresponding
to z. For a path P and a path cover PC in G(I), we use F (P ) and F (PC) to denote the
path and path cover in G(F ) corresponding to P and PC, respectively.
For simplicity, we will use x to refer to an arc x in F , F˜ (x), and I(x), use P to refer to a
path P in G(I), F˜ (P ), and F (P ), and use PC to refer to a path cover PC in G(I), F˜ (PC),
and F (PC) if they are understood without ambiguity.
Now, we present an O(∆n)-time algorithm for the Hamiltonian cycle problem on
circular-arc graphs given a set F of n sorted arcs. Our algorithm reduces the problem
to the Hamiltonian cycle and path cover problems on interval graphs. We sketch our al-
gorithm as follows: Let u be an arc of F such that it does not contain any other arc. Our
algorithm ﬁrst computes F1 = Fc(Ba(u), h(u)) and converts F1 into a set I1 of intervals by
a clockwise conversion starting from h(u), i.e., I1 = Ic(F1). Let P be the ﬁrst greedy path
in GP (I1) and let v = F (end(P )). By deﬁnition, u = F (start(P )). If u ∈ Bp(t(v)), then
P is a Hamiltonian path of G(I1) shown in [23] and hence, “v → P” is a Hamiltonian cycle
of G(F ). Otherwise, it computes F2 = Fcc(F (L(P )), t(v)) and converts F2 into a set I2 of
intervals by a counterclockwise conversion starting from t(v), i.e., I2 = Icc(F2). If u = v,
then G(F ) and G(I2) are isomorphic shown in [23] and hence, the input is an interval
graph. In this case, we can solve the Hamiltonian cycle problem on it by using the algo-
rithm in [29]. If |GP (I2)| > 1, i.e., G(I2) has no Hamiltonian path, we prove in Lemma 4.8
that G(F ) is not Hamiltonian. Suppose |GP (I2) = {Q}| = 1. Let z = F (start(Q)) and
w = F (end(Q)). By deﬁnition, either v = z or v ∈ Ba(z). Obviously, G(F ) has a Hamil-
tonian cycle “w → Q” if arc z intersects arc w. It is easy to see that arc z intersects arc w
if w ∈ Ba(v). Since G(I2) is a spanning subgraph of G(F ), G(F ) is Hamiltonian if G(I2)
is Hamiltonian. Whether or not G(I2) is Hamiltonian can be determined in O(n) time by
examining path Q [29]. In the following, assume that u 
= v, u 
∈ Bp(t(v)), arc z does not
intersect arc w in F , and G(I2) is not Hamiltonian. We then call Procedure GCS(Q) to
compute C(Q) and L(Q). Let Q = Q1 → d1 → Q2 → · · · → dh−1 → Qh → dh → Qh+1,
where C(Q) = {d1, d2, · · · , dh} and |C(Q)| = h. Let R = {r ∈ F |r 
∈ F (L(Q)) and
r ∈ Bp(h(w))}. Then, we prove in Lemma 4.13 that G(F ) has no Hamiltonian cycle if
R = ∅. Suppose R 
= ∅. We prove in Lemma 4.14 that R ⊆ Ba(z). Let s be the arc in R
such that I2(s) = min{I2(R)}, i.e., right(I2(s)) is to the left of right(I2(x)) for x ∈ R\{s}.
Let I s¯2 = I2\{I2(s)}. Since the removal of an interval in Q will increase the number of paths
by at most one, we have |GP (I s¯2)| ≤ 2. There are two cases: Case 1, |GP (I s¯2)| = 1. Let Qs¯
13
R̂ ⊆ Bp(h(wP )). Let F̂ = F \ R̂ ∪ head(R̂, h(wP )). That is, F̂ is obtained by removing
tail(R̂, h(wP )) from F . Then, we prove in Lemma 4.26 that G(F ) is Hamiltonian if and
only if G(F̂ ) is Hamiltonian. Whenever F̂ is constructed, our algorithm calls itself to
solve the problem on G(F̂ ). We can prove the above recursive call occurs only once. The
algorithm is formally presented in the following:
Algorithm HC(F, u)
Input: F , a set of sorted arcs, and u, an arc of F that does not contain any other arc.
Output: A Hamiltonian cycle of G(F ) if it is Hamiltonian; otherwise, G(F ) has no
Hamiltonian cycle.
Method:
1. compute F1 = Fc(Ba(u), h(u));
2. convert F1 into a set I1 of intervals by a clockwise conversion starting from h(u),
i.e., I1 = Ic(F1);
3. call Algorithm GP to compute GP (I1);
4. let P be the ﬁrst greedy path output by Algorithm GP(I1) and let v be the arc
corresponding to end(P ), i.e., v = F (end(P ));
5. if |GP (I1)| = 1 and arc u intersects arc v, then output “v → P” as a Hamiltonian
cycle of G(F ) and stop.
6. call Procedure GCS(P ) to ﬁnd L(P ) and C(P );
7. compute F2 = Fcc(F (L(P )), t(v));
8. convert F2 into a set I2 of intervals by a counterclockwise conversion starting from
t(v), i.e., I2 = Icc(F2);
9. call Algorithm GP to compute GP (I2);
10. if |GP (I2)| > 1, then output “G(F ) has no Hamiltonian cycle” and stop.
11. let Q be the only path in GP (I2);
12. let z and w be the arcs corresponding to start(Q) and end(Q), respectively, i.e.,
z = F (start(Q)) and w = F (end(Q));
13. if arc z intersects arc w, then output “w → Q” as a Hamiltonian cycle of G(F )
and stop.
14. if G(I2) is Hamiltonian, then output the Hamiltonian cycle found in G(I2) and
stop. /* call the algorithm in [29] to test whether G(I2) is Hamiltonian or not. */
15. call Procedure GCS(Q) to ﬁnd L(Q) and C(Q);
15
R = {a10}. In this time, R 
= ∅, s = a10, and I s¯2 = I2 \ {a10}. Then, |GP (I s¯2)| = 2.
It is straightforward to verify that wP = a9, zP = a6, QP = a8 → a10 → a7 → a9,
and QP = a6 → a4 → a5 → a3 → a2 → a1 → a11. Since zP ∈ F (C(Q)) and
L(QP ) = ∅, the algorithm does not terminate at either line 27 or 29. The algorithm
then computes R̂ = {rˆ ∈ F |rˆ ∈ F (QP ) and t(rˆ) is contained in seg(h(a9), t(a8))} = {a6}
and F̂ = F \ {a6} ∪ head({a6}, h(a9)) which is shown in Fig. 8. It then calls Algorithm
HC(F̂ , u) recursively. To distinguish the symbols in Algorithm HC(F̂ , u) from those in
Algorithm HC(F , u), we will use Î1, Î2, P̂ , and Q̂ to denote I1, I2, P , and Q, respec-
tively, which are as deﬁned in Algorithm HC(F , u). F̂ is ﬁrst converted to a set Î1 of
intervals by a clockwise conversion starting from h(a1) (as shown in Fig. 9). The ﬁrst
greedy path output by Algorithm GP(Î1) is P̂ = a1 → a2 → a3 → a5 → a4 → a6. In
this time, L(P̂ ) = ∅. Note that we can prove that L(P̂ ) = ∅. Next, Algorithm HC(F̂ ,
u) converts F̂ to the set Î2 of intervals by a counterclockwise conversion starting from
t(a6) (as shown in Fig. 10). Call Algorithm GP(Î2). The only path output by Algorithm
GP(Î2) is Q̂ = a4 → a6 → a3 → a5 → a1 → a11 → a10 → a8 → a9 → a7 → a2. Arcs
a4 does not intersect arc a2 in F̂ and hence, it does not terminate at line 13. By the
Hamiltonian cycle algorithm for interval graphs, we ﬁnd that G(Î2) has a Hamiltonian
cycle a4 → a6 → a3 → a2 → a1 → a11 → a10 → a8 → a9 → a7 → a5 → a4. It is a
Hamiltonian cycle of G(F̂ ) and hence, it is a Hamiltonian cycle of G(F ) too. Note that
we can prove that given F̂ and u Algorithm HC will terminate before line 24, i.e., the
recursive call occurs only once. 
Example 2. Let F be the set of arcs shown in Fig. 11 and let arc u = a5. The set
F1 = Fc(Ba(a5), h(a5)) of arcs is shown in Fig. 12. The set I1 of intervals obtained from
F1 by a clockwise conversion starting from h(a5) is shown in Fig. 13. This ﬁrst greedy
path P output by Algorithm GP(I1) is a5 → a4 → a6 → a7 → a1 → a2 → a3 → a8. It is
straightforward to verify that v = a8, C(P ) = L(P ) = ∅, and arcs u and v do not intersect.
The set F2 = Fcc(∅, t(a8)) of arcs is shown in Fig. 14. The set I2 of intervals obtained from
F2 by a counterclockwise conversion starting from t(a8) is shown in Fig. 15. The ﬁrst path
in GP (I2) is Q = a3 → a2 → a8 → a6 → a7 → a1 → a5 → a4 and Q is a Hamiltonian path
of G(I2). Then, z = a3 and w = a4. Arc a3 does not intersect arc a4. By the algorithm
for interval graphs, we ﬁnd that G(I2) has no Hamiltonian cycle. Hence Algorithm HC(F ,
a5) does not terminate before line 15. It is straightforward to verify that C(Q) = {a6, a1}
17
a1a3a4
a2
a5
a6 a7a8
a9
a10
a11
Fig. 10: The set Î2, corresponding to I2 in Algorithm HC(F , u), of intervals for the set F̂
of arcs shown in Fig. 8.
a1 a2
a3
a4
a5
a6
a7
a8
Fig. 11: A set F of arcs used in Example 2.
HC(F ,u) terminates at either line 13 or line 14. If G(I2) is not Hamiltonian then R = ∅
since P visits only I1(u), v = u, and no arcs contain t(u). Thus Algorithm HC(F , u)
terminates at line 17. We have shown that Algorithm HC(F , u) is correct for the case
of u = v. Suppose that u 
= v. In [23], we showed that P is a Hamiltonian path of
G(I1) if u ∈ Bp(t(v)). Hence, “v → P” is a Hamiltonian cycle of G(F ) and the algorithm
terminates at line 5 if u ∈ Bp(t(v)). In the following, assume that u 
= v and u 
∈ Bp(t(v)).
To verify the correctness of Algorithm HC(F ,u), we will prove the following claims:
Claim 1. G(F ) is not Hamiltonian if |GP (I2)| > 1 (line 10);
Claim 2. G(F ) is not Hamiltonian if R = ∅ (line 17);
Claim 3. Suppose that R 
= ∅ and |GP (I s¯2)| = 1. Then, G(F ) is Hamiltonian if and only
if arc s intersects arc ws¯ (line 22);
Claim 4. Suppose that R 
= ∅ and |GP (I s¯2)| = 1. If arc s does not intersect arc ws¯, then
G(F ) is Hamiltonian if and only if G((F \ {s})∪head(s, h(w))) is Hamiltonian (line
23);
19
a1
a4
a5
a6
a2
a3
a7a8
Fig. 15: The set I2 of intervals obtained by a counterclockwise conversion starting from
t(a8) given Fcc(∅, t(a8)) shown in Fig. 14.
a1 a2
a3
a4
a5
a6
a7
a8
Fig. 16: F = (F \ {a8}) ∪ head(a8, h(a4)) for the set of arcs shown in Fig. 11.
21
output by Algorithm GP(I2) with that C(Q) = {d1, d2, · · · , dh} and |C(Q)| = h. If u 
= v,
u 
∈ Bp(t(v)), w 
∈ Bp(t(v)), and L(P ) 
= ∅, the following lemma is given in [23]:
Lemma 3.2. (Hung et al. [23]) Assume that u 
= v, u 
∈ Bp(t(v)), w 
∈ Bp(t(v)), and
L(P ) 
= ∅. Then, Q can be divided into two sub-paths QP and QP with Q = QP → QP
satisfying the following conditions:
(1) QP = P ′k+1 → ci1 → P ′k → ci2 → · · · → cik−1 → P ′2 → cik and QP = Z → dt →
Qt+1 → dt+1 → · · · → Qh → dh → Qh+1, where I2(C(P )) = {ci1 , ci2 , · · · , cik}, I2(x) ∈ P ′j
if and only if I1(x) ∈ Pj for x ∈ F and 2 ≤ j ≤ k + 1, Z may be an empty path,
Z ∩ C(Q) = ∅, and D = QP ∩ C(Q) = {dt, dt+1, · · · , dh};
(2) F (P ′k+1), F (P
′
k), · · · , F (P ′2), F (Z), F (Qt+1), · · · , F (Qh), and F (Qh+1) are connected
components in G(F \ F (C(P ) ∪D)).
Fig. 7 shows the relative positions of arcs in F (P ′k+1), F (P
′
k), · · · , F (P ′2), F (Z),
F (Qt+1), · · · , F (Qh), and F (Qh+1) satisfying all conditions described in Lemma 3.2. The
following lemma will be veriﬁed in Section 4 (See Lemma 4.24).
Lemma 3.3. Assume that u 
= v, u 
∈ Bp(t(v)), |GP (I2) = {Q}| = 1, arc z does not
intersect arc w, R 
= ∅, and |GP (I s¯2)| = 2. Let Q = QP → QP satisfying all conditions
given in Lemma 3.2, wP = F (end(QP )), zP = F (start(QP )), and let D = QP ∩C(Q). If
zP ∈ F (C(Q)), then the following statements hold:
(1) any arc of F (QP \D) is contained in seg(t(v), h(wP )), and
(2) for arcs x ∈ F (D) and y ∈ F (QP ) \ F (C(P )), arc y is contained in seg(t(x), t(v)).
Now we analyze the running time of Algorithm HC given F̂ and u, where F̂ and u
are as deﬁned in Algorithm HC(F, u). Given F̂ and u, Algorithm HC ﬁrst computes
F̂1 = Fc(Ba(u), h(u)) and converts F̂1 into a set Î1 of intervals with Î1 = Ic(F̂1). Then, it
computes GP (Î1). Let P̂ be the ﬁrst greedy path in GP (Î1). We ﬁrst prove that L(P̂ ) = ∅
in the following lemma:
Lemma 3.4. Assume that Algorithm HC given F̂ and u computes F̂1 = Fc(Ba(u), h(u))
and Î1 = Ic(F̂1). Let P̂ be the ﬁrst greedy path in GP (Î1). Then, L(P̂ ) = ∅.
Proof . Let Q = QP → QP satisfying all conditions given in Lemma 3.2, wP = F (end(QP )),
and let D = QP ∩ C(Q) = {dt, dt+1, · · · , dh}. By deﬁnition of F̂ , Z = ∅ and L(QP ) = ∅.
The relative locations of arcs in F (P ′k+1), F (P
′
k), · · · , F (P ′2), F (Qt+1), · · · , F (Qh), and
F (Qh+1) are shown in Fig. 7.
23
F (P ′1∪P ′2∪· · ·∪P ′k+1) does not contain arc u. Thus, any arc of F (QP )\F (C(P )) is not in
Ba(u). By the previous argument, any arc of F (C(P )) is not in Ba(u). Hence any arc of
F (QP ) is not in Ba(u). By deﬁnition, for x ∈ F (QP ) F1(x) = x and hence left(I1(x)) =
h(x). Since left(I1(x)) = h(x) for x ∈ F (QP ) and h(x˜) is contained in seg(h(wP ), t(v))
for x˜ ∈ F (QP ) \ {wP }, left(I1(x˜)) is to the right of left(I1(wP )) for x˜ ∈ F (QP ) \ {wP }.
By deﬁnition, either F1(v̂) = v̂ or F1(v̂) = tail(v̂, h(u)). Thus, right(I1(v̂)) = t(v̂).
If t(v̂) is contained in seg(t(v), h(wP )), then I1(v̂)  I1(x) for x ∈ F (QP ) and hence
I1(v̂) = end(P ), a contradiction occurs. Thus, t(v̂) is contained in seg(h(wP ), t(v)). By
Statement (1) of Lemma 3.3, any arc of F (QP \D) is contained in seg(t(v), h(wP )) and
hence, there exists no arc of F (QP \D) with tail be in seg(h(wP ), t(v)). Thus, v̂ ∈ F (D)
and v̂ ∈ Bp(h(wP )). Let R̂ = {rˆ ∈ F |rˆ ∈ F (QP ) and t(rˆ) is contained in seg(h(wP ), t(v))}.
Then, v̂ ∈ R̂. By deﬁnition, F̂ is obtained by removing tail(R̂, h(wP )) from F . Thus,
F̂ (v̂) = head(v̂, h(wP )) and right(Î1(v̂)) = h(wP ). Let ŷ be an arc in F (P1) \ {v̂}. Then,
either F1(ŷ) = ŷ or F1(ŷ) = tail(ŷ, h(u)) depending on whether or not ŷ ∈ Ba(u). By
deﬁnition, I1(P1) is a monotone path in G(I1), i.e., I1(ŷ) < I1(v̂). Note that right(I1(x)) =
t(x) for x ∈ F (P1). Thus, t(ŷ) is contained in seg(h(u), t(v̂)). If t(ŷ) is contained in
seg(h(u), h(wP )), then F̂ (ŷ) = ŷ and hence Î1(ŷ)  Î1(wP ). Suppose that t(ŷ) is contained
in seg(h(wP ), t(v̂)). Then, ŷ ∈ Bp(h(wP )), ŷ ∈ R̂ and hence, F̂ (ŷ) = head(ŷ, h(wP )). Note
that seg(h(wP ), t(v̂)) does not contain arc ŷ since ŷ ∈ F (D). Thus, right(Î1(ŷ)) = h(wP ).
In the above arguments, we show that for y ∈ F (P1), either right(Î1(y)) = h(wP ) or
Î1(y)  Î1(wP ). Note that F̂ (wP ) = wP and left(Î1(wP )) = h(wP ). Thus, Î1(y) 
Î1(wP ) in G(Î1) for y ∈ F (P1).
By Claims (1) and (2), no interval of Î1(P ) contains left(Î1(wP )) corresponding to
h(wP ). We can easily see from Lemma 2.5 that for x 
∈ F (P ), left(Î1(x)) is to the right
of left(Î1(wP )) in G(Î1). Thus, no interval of Î1 contains left(Î1(wP )) = right(Î1(v̂))
corresponding to h(wP ). Since arcs of F (QP ) intersect if and only if they intersect in G(F̂ ),
G(Î1(P1)) has a Hamiltonian (greedy) path P̂ with end(P̂ ) = Î1(v̂) and right(Î1(v̂)) =
h(wP ). Since no interval of Î1 contains right(end(P̂ )), P̂ is a monotone path and hence,
L(P̂ ) = ∅. 
By the above lemma, L(P̂ ) = ∅. By Lemma 3.1, Algorithm HC(F̂ , u) will terminate
before line 24. That is, the recursive call of Algorithm HC(F , u) occurs only once. By
the previous analysis on Algorithm HC(F , u), Algorithm HC given F̂ and u executes in
25
Proposition 4.4. Let x and y be two arcs in F . If F2(x) intersects F2(y) but I2(x) does
not intersect I2(y), then either x ∈ Bp(t(v)) \ F (L(P )) or y ∈ Bp(h(u)) \ F (L(P )).
Proposition 4.5. Assume that u 
= v and u 
∈ Bp(t(v)). If x ∈ F (L(P )), then x ∈ Ba(v).
Algorithm HC(F , u) is absolutely correct if it terminates at either line 13 or line 14
since G(I2) is a spanning subgraph of G(F ). In the following, we assume that Algorithm
HC(F , u) does not terminate at line 13 or line 14. Notice that arcs are open segments,
no arc in F covers the entire circle, and arc u does not contain any other arc in F . The
following two lemmas appeared in [23] and will be used in proving our claims:
Lemma 4.6. (Hung et al. [23]) Assume that u 
= v and u 
∈ Bp(t(v)). Then, the following
statements hold:
(1) seg(h(u), t(v)) contains t(u).
(2) Bp(t(v)) ⊆ Ba(u) ∪ F (L(P )).
(3) P visits I1(x) if and only if either x = u or arc x intersects seg(t(u), t(v)).
(4) If x, y are two distinct arcs in F , and I1(x) intersects I1(y) but I2(x) does not intersect
I2(y), then either (x ∈ Bp(t(v)), I1(x) ∈ L(P ), and y ∈ F \ F (P )) or (y ∈ Bp(t(v)),
I1(y) ∈ L(P ), and y ∈ F \ F (P )).
Lemma 4.7. (Hung et al. [23]) Assume that u 
= v, u 
∈ Bp(t(v)), and F \ F (Q) 
= ∅,
i.e., |GP (I2)| > 1. Then, the following statements hold:
(1) Either u = w or seg(t(v), h(u)) contains h(w).
(2) Bp(t(v)) ∪Bp(h(w)) = F (L(P )) ∪ F (L(Q)).
(3) An arc x is in F \ F (Q) if and only if seg(t(v), h(w)) contains arc x.
(4) If L(P ) ∪ L(Q) 
= ∅, then there exists a set CQ ⊂ Q such that F (L(P )) ∪ F (L(Q)) ⊆
F (CQ) and G(F (Q \ CQ)) has at least |CQ| connected components.
By using the above two lemmas, we prove Claim 1 as follows:
Lemma 4.8. (Claim 1) Assume that u 
= v and u 
∈ Bp(t(v)). If |GP (I2)| > 1, then
G(F ) has no Hamiltonian cycle.
Proof . Since |GP (I2)| > 1, F \F (Q) 
= ∅. By Statement (1) of Lemma 4.6 and Statement
(1) of Lemma 4.7, seg(h(u), t(v)) properly contains arc u and seg(h(w), t(v)) contains
seg(h(u), t(v)) as shown in Fig. 17. By Statement (3) of Lemma 4.7, we obtain that
(1) an arc x is in F \ F (Q) if and only if it is contained in seg(t(v), h(w)), and (2)
27
Assume that Algorithm HC(F , u) does not terminate before line 15. Then, |GP (I2)| =
1. By Lemma 4.9, w 
∈ Ba(v). Thus, v ∈ Bp(h(w)) if w ∈ Bp(t(v)). Then, w is either
in Bp(t(v)) or not. For the case of w 
∈ Bp(t(v)), the following lemma can be proved by
using the same arguments in [23]:
Lemma 4.10. (Hung et al. [23]) Assume that u 
= v, u 
∈ Bp(t(v)), |GP (I2) = {Q}| = 1,
and w 
∈ Bp(t(v)). Then, the following statements hold:
(1) Either u = w or seg(t(v), h(u)) contains h(w).
(2) Bp(t(v)) ∪Bp(h(w)) = F (L(P )) ∪ F (L(Q)).
(3) seg(t(v), h(w)) contains no arc in F .
Consider that u 
= v, u 
∈ Bp(t(v)), |GP (I2)| = 1, and arc z does not intersect arc w.
By Lemma 4.9, w 
∈ Ba(v). By Proposition 4.5, w 
∈ F (L(P )). By deﬁnition, F2(w) = w.
Hence, h(F2(w)) = h(w) and right(I2(w)) corresponds to h(w). Note that w is either in
Bp(t(v)) or not. For the case of w 
∈ Bp(t(v)), the following proposition can be seen from
Lemma 2.4 and the deﬁnition of F2 and I2:
Proposition 4.11. Assume that u 
= v, u 
∈ Bp(t(v)), |GP (I2)| = 1, and arc z does not
intersect arc w. Let x be an arc in F . If w 
∈ Bp(t(v)) and F2(x) ∈ Bp(h(w)), then
I2(x) ∈ L(Q).
Lemma 4.12. Assume that u 
= v, u 
∈ Bp(t(v)), |GP (I2) = {Q}| = 1, and arc z does
not intersect arc w. Let Q = Q1 → d1 → Q2 → · · · → dh−1 → Qh → dh → Qh+1, where
C(Q) = {d1, d2, · · · , dh} and |C(Q)| = h. If w 
∈ Bp(t(v)), then the following statements
hold:
(1) Bp(h(w)) ⊆ F (L(P )) ∪ F (L(Q)),
(2) if x ∈ F (L(P )), then either I2(x) ∈ Q1 or I2(x) ∈ C(Q), and
(3) if y ∈ F (Qi) for 2 ≤ i ≤ h + 1, then y 
∈ Bp(t(v)).
Proof . By assumption, w 
∈ Bp(t(v)). By deﬁnition of F2, F2(w) = w. Hence, left(I2(w))
and right(I2(w)) correspond to t(w) and h(w), respectively. We ﬁrst prove Statement (1).
Suppose that arc x contains h(w) and x 
∈ F (L(P )). By deﬁnition of F2, F2(x) = x. Since
arc x contains h(w), F2(x) contains h(F2(w)) = h(w). By Proposition 4.11, I2(x) ∈ L(Q)
and hence, x ∈ F (L(Q)).
We next show that Statement (2) holds. Assume by contradiction that I2(x) ∈ Qi
for 2 ≤ i ≤ h + 1. Since x ∈ F (L(P )), x ∈ Ba(v) by Proposition 4.5. By deﬁnition of
29
x 
∈ Bp(t(v)) and hence F2(x) = x, i.e., left(I2(x)) corresponds t(x) and right(I2(x))
corresponds h(x). Thus, arc x intersects arc y if and only if I2(x) intersects I2(y) for
x, y ∈ F (Q2 ∪ Q3 ∪ · · · ∪ Qh+1). By Statement (3) of Lemma 2.5, Q1, Q2, · · · , Qh+1 are
islands with respect to C(Q) in G(I2). Hence, F (Q1), F (Q2), · · · , F (Qh+1) are islands
with respect to F (C(Q)) in G(F ). That is, G(F \ F (C(Q))) has at least |C(Q)| + 1
connected components. By Proposition 2.2, G(F ) has no Hamiltonian cycle. 
Lemma 4.14. Assume that u 
= v, u 
∈ Bp(t(v)), |GP (I2) = {Q}| = 1, and arc z does
not intersect arc w. If w 
∈ Bp(t(v)), then Bp(h(w)) ⊆ F (L(Q)) ∪ F (L(P )); otherwise,
Bp(h(w)) ⊆ F (L(Q)) ∪Ba(z).
Proof . By Statement (1) of Lemma 4.12, Bp(h(w)) ⊆ F (L(Q))∪F (L(P )) if w 
∈ Bp(t(v)).
Suppose that w ∈ Bp(t(v)). By Lemma 4.9, w 
∈ Ba(v). Hence, v ∈ Bp(h(w)). By
assumption, arc z = F (start(Q)) does not intersect arc w. Hence, v 
= z. Since left(I2(v))
is the leftmost endpoint in G(I2) and I2(z) < I2(v), I2(v) contains I2(z). Since arc z does
not intersect arc w and w ∈ Bp(t(v)), z 
∈ Bp(t(v)) and hence z 
∈ F (L(P )). By deﬁnition,
F2(v) = v and F2(z) = z. Hence, v ∈ Ba(z). Assume that arc x ∈ Bp(h(w)) and
x 
∈ F (L(Q)). Consider the following two cases:
Case 1: x 
∈ Ba(v). By Proposition 4.5, x 
∈ F (L(P )). By deﬁnition, F2(w) = w
and F2(x) = x. Assume by contradiction that x ∈ Bp(t(v)). Then, F2(x) contains
h(F2(w)) = h(w). Thus, I2(x) contains right(I2(w)). By Statement (3) of Lemma 2.4,
I2(x) ∈ L(Q). It contradicts the assumption that x 
∈ F (L(Q)). Hence, x 
∈ Bp(t(v)) and
t(x) is contained in seg(h(w), t(v)). Since h(w) is contained in seg(t(z), t(v)), t(x) is also
contained in seg(t(z), t(v)). By deﬁnition, F2(x) = x, F2(z) = z and hence, left(I2(x)) is
to the left of left(I2(z)). Since I2(z) is the interval with the leftmost right endpoint in
G(I2), right(I2(x)) is to the right of right(I2(z)). Thus, I2(x) contains I2(z) and hence,
x ∈ Ba(z).
Case 2: x ∈ Ba(v). Since v ∈ Ba(z), x ∈ Ba(z).
In either case, x ∈ Ba(z). Therefore, Bp(h(w)) ⊆ F (L(Q))∪Ba(z) if w ∈ Bp(t(v)). 
Recall that s is the arc in R such that I2(s) = min{I2(R)} and I s¯2 = I2 \ {I2(s)}. We
the prove Claim 3 as follows:
Lemma 4.15. (Claim 3) Assume that u 
= v, u 
∈ Bp(t(v)), |GP (I2) = {Q}| = 1, and
arc z does not intersect arc w. If R 
= ∅, |GP (I s¯2) = {Qs¯}| = 1, ws¯ = F (end(Qs¯)), and
31
Proof . By Lemma 4.14, s ∈ Ba(z). By Lemmas 4.16 and 2.4, I2(w) ∈ L(Qs¯). Since
|GP (I2) = {Q}| = 1 and I2(w) = end(Q), |GP (I2 \ {I2(w)})| = 1. Assume by contradic-
tion that there exists an arc s′ in B(z, s) such that s′ 
∈ F (C(Qs¯)). Let Qs¯1 be the ﬁrst path
component of Qs¯ \ C(Qs¯). By deﬁnition, z = F (start(Q)) = F (start(Qs¯1)). By deﬁnition
of F2, F2(z) = z and v ∈ Ba(z) if z 
= v. If s′ ∈ F (L(P )), then F2(s′) = head(s′, t(v)) and
F2(s′) contains F2(z); otherwise, F2(s′) = s′ and F2(s′) also contains F2(z). Hence, F2(s′)
contains F2(z) no matter whether s′ ∈ F (L(P )) or not. That is, I2(s′) intersects I2(z).
By Statement (3) of Lemma 2.5, I2(s′) ∈ Qs¯1. By deﬁnition, I2(s) < I2(s′) ≤ end(Qs¯1).
Hence, no interval of Qs¯1 ∪ {I2(s)} intersects any interval of other connected components
of I2 \C(Qs¯). Note that I2(w) ∈ C(Qs¯). Consider removing from I2 \{I2(w)} all intervals
in C(Qs¯) \ {I2(w)}. What results is a set of at least |C(Qs¯)| + 1 connected compo-
nents. By Proposition 2.1, G(I2 \ {I2(w)}) has no Hamiltonian path. It contradicts that
|GP (I2 \ {I2(w)})| = 1. Thus, B(z, s) ⊆ F (C(Qs¯)). 
Lemma 4.18. Assume that u 
= v, u 
∈ Bp(t(v)), |GP (I2) = {Q}| = 1, arc z does not
intersect arc w, R 
= ∅, |GP (I s¯2) = {Qs¯}| = 1, ws¯ = F (end(Qs¯)), and arc s does not
intersect arc ws¯. Let Qs¯ = Qs¯1 → f1 → Qs¯2 → · · · → f−1 → Qs¯ → f → Qs¯+1, where
C(Qs¯) = {f1, f2, · · · , f} and |C(Qs¯)| = . Then, the following statements hold:
(1) Bp(h(w)) ⊆ F (C(Qs¯)) ∪ {s}.
(2) If arc x intersects seg(h(w), h(ws¯)), then x ∈ F (C(Qs¯)) ∪ {s}.
(3) F (Qs¯1), F (Q
s¯
2), · · · , F (Qs¯+1) are islands with respect to F (C(Qs¯)) in G(F \ {s}).
Proof . By assumption, arc w does not intersect arc z and arc s does not intersect arc
ws¯. By Lemma 4.16, w ∈ Ba(ws¯). By deﬁnition, s ∈ Bp(h(w)). By Lemma 4.14,
s ∈ Ba(z). Hence, both h(w) and t(s) are contained in seg(t(z), h(ws¯)), t(s) is contained
in seg(h(w), h(ws¯)), and s ∈ Ba(z). The relative positions of arcs z, s, ws¯, and w are
shown in Fig. 18.
We ﬁrst prove Statement (1). By deﬁnition, Bp(h(w)) = F (L(Q)) ∪ R. Note that
s ∈ R such that right(I2(s)) is the leftmost right endpoint in I2(R). By Lemma 4.16,
I2(ws¯) < I2(w). By deﬁnition, I2(w) < I2(x) for x ∈ F (L(Q)). Hence, an arc in F (L(Q))
is also in F (L(Qs¯)). That is, F (L(Q)) ⊆ F (L(Qs¯)) ⊆ F (C(Qs¯)). By Lemma 4.14,
R ⊆ Ba(z). By deﬁnition, R \ {s} ⊆ B(z, s). By Lemma 4.17, B(z, s) ⊆ F (C(Qs¯)).
Hence, R \ {s} ⊆ F (C(Qs¯)). Thus, Bp(h(w)) ⊆ F (C(Qs¯)) ∪ {s}.
Next we show that Statement (2) holds. By Statement (1), Bp(h(w)) ⊆ F (C(Qs¯))∪{s}.
33
Q1
f1
s
z
Q2
s
Q3
s
f2
Q
+1
s
w s
Q

s
w
Q
-1
s
f
-2
f
-1
s
Fig. 18: The relative locations of arcs z, ws¯, w, s, and arcs in F (Qs¯1), F (Q
s¯
2), · · · , F (Qs¯+1)
on the circle when the conditions given in Lemma 4.18 are satisﬁed.
Otherwise, ws¯ ∈ Ba(v) and ws¯ intersects z, a contradiction. By deﬁnition, F2(ws¯) = ws¯.
Let x ∈ F (Qs¯i ) for 2 ≤ i ≤ +1. Assume by contradiction that x ∈ Bp(t(v)). By Statement
(2), x does not intersect seg(h(w), h(ws¯)). Hence, arc x contains z and t(x) is contained in
seg(t(z), h(w)). Obviously, I2(z) ∈ Qs¯1. If x ∈ F (L(P )), then I2(x) clearly intersects I2(z)
and it contradicts that no interval of Qs¯1 intersects any interval of Q
s¯
i , 2 ≤ i ≤  + 1, by
Statement (3) of Lemma 2.5. Hence, x 
∈ F (L(P )). By deﬁnition, F2(x) = x and hence,
left(I2(x)) corresponds to t(x). Since t(x) is contained in seg(t(v), h(ws¯)), I2(ws¯)  I2(x).
It contradicts that |GP (I s¯2)| = 1. Therefore, x 
∈ Bp(t(v)). By deﬁnition, left(I2(x))
corresponds to t(x) and right(I2(x)) corresponds to h(x). By Statement (2), no arc of
F (Qs¯1) intersects seg(h(w), h(w
s¯)). Hence, no arc of F (Qs¯1) intersects arcs of F (Q
s¯
i ) for
2 ≤ i ≤  + 1.
In any case, we show that I2(x) intersects I2(y) if and only if x intersects y for any
x, y ∈ F (Qs¯1) ∪ F (Qs¯2) ∪ · · · ∪ F (Qs¯+1). By Statement (3) of Lemma 2.5, Qs¯1, Qs¯2, · · · ,
Qs¯+1 are islands with respect to C(Q
s¯) in G(I s¯2). Hence, F (Q
s¯
1), F (Q
s¯
2), · · · , F (Qs¯+1) are
islands with respect to F (C(Qs¯)) in G(F \ {s}). 
35
end(Q′)  I2(u) and it contradicts that |GP (I2 \ {I2(w), I2(v)})| = 1. Hence, end(Q′)
intersects I2(w). Let Qv¯ = Q′ → I2(w). Then, Qv¯ is a Hamiltonian path of G(I v¯2 ). Hence,
|GP (I v¯2 )| = 1.
Case 2: |GP (I2 \ {I2(w), I2(v)})| = 2. Let GP (I2 \ {I2(w), I2(v)}) = {Q˜1, Q˜2} with
end(Q˜1) < end(Q˜2) and let w1 = F (end(Q˜1)). We ﬁrst prove that I2(w) intersects I2(w1).
Assume by contradiction that I2(w) does not intersect I2(w1). Note that F2(w) = w,
F2(u) = u, and I2(w) contains I2(u). Since I2(w) does not intersect I2(w1), I2(w1) 
I2(u). Hence, arc w1 intersects seg(t(u), t(v)). By deﬁnition of F2, either F2(w1) = w1
or F2(w1) = head(w1, t(v)). Hence, h(F2(w1)) = h(w1) and right(I2(w1)) corresponds to
h(w1). By Statement (1) of Lemma 2.4, the left endpoint of every interval in Q˜1 is to
the left of right(I2(w1)). Thus every arc x with I2(x) ∈ Q˜1 intersects seg(t(u), t(v)). By
Statement (3) of Lemma 4.6, I1(x) ∈ P for x ∈ F (Q˜1). Since I2(w1)  I2(u), I2(u) 
∈ Q˜1.
Let P = I2(P ) \ Q˜1. Then, P contains I2(u). Therefore, P 
= ∅. By Statements (1)–(3)
of Lemma 2.5, there exists a set C(Q˜1) such that C(Q˜1) ⊂ Q˜1, L(Q˜1) ⊆ C(Q˜1), and the
removal of C(Q˜1) from Q˜1 results in |C(Q˜1)| + 1 nonempty and disjoint sub-paths and
each of them is an island with respect to C(Q˜1) in G(I2). By Statement (5) of Lemma
2.5, I2 \ Q˜1 is also an island with respect to C(Q˜1) in G(I2). Since P ⊂ I2 \ Q˜1 and
P 
= ∅, no intervals in P intersect any interval of Q˜1 \ C(Q˜1). Thus, P is an island
with respect to C(Q˜1) in G(I2(P )). In other words, there are |C(Q˜1)|+ 2 disjoint islands
with respect to C(Q˜1) in G(I2(P )). Therefore, the removal of C(Q˜1) from G(I2(P ))
results in at least |C(Q˜1)| + 2 connected components. By Proposition 2.1, G(I2(P ))
has no Hamiltonian path. But, I2(P ) is a Hamiltonian path of G(I2(P )) which follows
immediately from Statement (4) of Lemma 4.6, a contradiction. Hence, I2(w) intersects
I2(w1). By Statement (5) of Lemma 2.5, I2(w1)  start(Q˜2). By deﬁnition, F2(w) = w
and F2(start(Q˜2)) = F (start(Q˜2)). Since w ∈ Bp(t(v)) and I2(w) intersects I2(w1), I2(w)
also intersects start(Q˜2). Let Qv¯ = Q˜1 → I2(w) → Q˜2. Then, Qv¯ is a Hamiltonian path
of G(I v¯2 ). Hence, |GP (I v¯2 )| = 1. 
Lemma 4.21. Assume that u 
= v, u 
∈ Bp(t(v)), |GP (I2)| = 1, and arc z does not
intersect arc w. Let r be an arc in F with I2(r) < I2(v). If v ∈ Ba(z) and |GP (I2 \
{I2(v)})| = 1, then |GP (I2 \ {I2(r)})| = 1.
Proof . Let Qv¯ = Qv¯1 → I2(r) → Qv¯2 be the only greedy path in GP (I2 \ {I2(v)}). By
deﬁnition, F2(v) = v and F2(z) = z. Hence, I2(v) contains I2(z). Clearly, start(Qv¯1) =
37
has at least |C|+1 connected components. By Proposition 2.2, G(F ) has no Hamiltonian
cycle. 
It is easy to see that if L(Q) = ∅ then zP 
∈ F (C(Q)). By Lemma 4.23, G(F ) has no
Hamiltonian cycle if zP 
∈ F (C(Q)). Hence, G(F ) has no Hamiltonian cycle if L(Q) = ∅.
Lemma 4.24. (Lemma 3.3) Assume that u 
= v, u 
∈ Bp(t(v)), |GP (I2) = {Q}| = 1, arc
z does not intersect arc w, R 
= ∅, and |GP (I s¯2)| = 2. Let Q = QP → QP satisfying
all conditions given in Lemma 3.2, wP = F (end(QP )), zP = F (start(QP )), and let
D = QP ∩ C(Q). If zP ∈ F (C(Q)), then the following statements hold:
(1) any arc of F (QP \D) is contained in seg(t(v), h(wP )), and
(2) for arcs x ∈ F (D) and y ∈ F (QP ) \ F (C(P )), arc y is contained in seg(t(x), t(v)).
Proof . By assumption, zP ∈ F (C(Q)). Hence, Z = ∅. Let QP = P ′k+1 → ci1 → P ′k →
ci2 → · · · → cik−1 → P ′2 → cik and QP = dt → Qt+1 → dt+1 → · · · → Qh → dh →
Qh+1, where I2(C(P )) = {ci1 , ci2 , · · · , cik} and D = QP ∩ C(Q) = {dt, dt+1, · · · , dh}.
Let y˜ be an arc in F (Qt+1). By deﬁnition, v ∈ F (P ′k+1). By Condition (2) of Lemma
3.2, y˜ does not intersect v and hence, y˜ 
∈ Bp(t(v)). Assume by contradiction that y˜
intersects seg(h(wP ), t(v)). If y˜ is contained in seg(h(wP ), t(v)), then I2(y˜) < I2(wP )
and hence I2(y˜) ∈ QP by Lemma 2.4, a contradiction occurs. Thus, h(y˜) is contained in
seg(t(v), h(wP )) and y˜ ∈ Bp(h(wP )). By deﬁnition of F2, F2(y˜) = y˜ and either F2(wP ) =
wP or F2(wP ) = head(wP , t(v)). Thus, F2(y˜) intersects F2(wP ) and I2(y˜) intersects
I2(wP ). By Lemma 2.6, dt contains I2(y˜). Then, I2(wP ) intersects both I2(y˜) and dt. By
the greedy rule of Algorithm GP, Q visits I2(y˜) before dt. It contradicts that start(QP ) =
dt. Thus, y˜ does not intersect seg(h(wP ), t(v)) and it is contained in seg(t(v), h(wP )). Let
x˜ be any arc in Qi, t + 2 ≤ i ≤ h + 1. By Condition (2) of Lemma 3.2, x˜ 
∈ Bp(t(v))
and hence F2(x˜) = x˜. By Statements (3) and (4) of Lemma 2.5, I2(x˜) is to the right of
any interval of Qt+1. Hence, F2(x˜) is contained in seg(t(v), h(y˜)) for y˜ ∈ F (Qt+1). Since
F2(x˜) = x˜ and any arc of F (Qt+1) is contained in seg(t(v), h(wP )), x˜ is also contained in
seg(t(v), h(wP )). Therefore, Statement (1) holds.
We next prove Statement (2). By deﬁnition, arc u does not contain any arc of F .
By deﬁnition, F2(x) = x for x ∈ F (QP ). By deﬁnition, u ∈ F (QP ). By Lemma 2.6,
di, t ≤ i ≤ h, contains any interval of Qi+1. Thus, u 
∈ F (D). Suppose u ∈ F (Qη),
t + 1 ≤ η ≤ h + 1. Let y be an arc in F (P ′i ), 2 ≤ i ≤ k + 1. By Condition (2) of
Lemma 3.2, y 
∈ Bp(t(v)) since v ∈ F (P ′k+1) and Pk+1 is a monotone path in GP (I1).
39
F (P ′k+1), F (P
′
k), · · · , F (P ′k−j+2), F (Q˜P ), F (Qt+1), F (Qt+2), · · · , F (Qh), and F (Qh+1)
are connected components in G(F \ C). By Proposition 2.2, G(F ) has no Hamiltonian
cycle. 
Lemma 4.26. (Claim 7) Assume that u 
= v, u 
∈ Bp(t(v)), |GP (I2) = {Q}| = 1, arc
z does not intersect arc w, R 
= ∅, and |GP (I s¯2)| = 2. Let Q = QP → QP satisfying
all conditions given in Lemma 3.2, wP = F (end(QP )), zP = F (start(QP )), and let
D = QP ∩ C(Q) = {dt, dt+1, · · · , dh}. If zP ∈ F (C(Q)) and L(QP ) = ∅, then G(F )
is Hamiltonian if and only if G(F̂ ) is Hamiltonian.
Proof . By assumption, zP ∈ F (C(Q)) and hence Z = ∅. Let QP = P ′k+1 → ci1 → P ′k →
ci2 → · · · → cik−1 → P ′2 → cik and QP = dt → Qt+1 → dt+1 → · · · → Qh → dh → Qh+1
be as deﬁned in Lemma 3.2. Fig. 7 reveals the relative positions of arcs in F (P ′k+1),
F (P ′k), · · · , F (P ′2), F (Qt+1), · · · , F (Qh), and F (Qh+1). Let C = F (C(P )) ∪ F (D). By
Condition (2) of Lemma 3.2, we obtain that (1) G(F \ C) has |C| connected components,
and (2) F (P ′k+1), F (P
′
k), · · · , F (P ′2), F (Qt+1), · · · , F (Qh), and F (Qh+1) are connected
components in G(F \ C). Note that v ∈ F (P ′k+1) and no arc of F (P ′k+1) contains t(v).
By deﬁnition of F2, we have (1) F2(x) = x for x ∈ F \ C, (2) either F2(c) = c or
F2(c) = head(c, t(v)) for c ∈ F (C(P )), and (3) F2(d) = d for x ∈ F (D).
Recall that R̂ = {rˆ ∈ F |rˆ ∈ F (QP ) and t(rˆ) is contained in seg(h(wP ), t(v))} and
F̂ = F \ R̂ ∪ head(R̂, h(wP )) are as deﬁned in Algorithm HC(F, u). By Statement (1) of
Lemma 4.24, any arc of F (QP \D) is contained in seg(t(v), h(wP )). Hence, R̂ ⊆ F (D).
Let γ be an arc in R̂. We ﬁrst prove that γ ∈ Bp(h(wP )). By Statement (1) of Lemma
4.24, any arc of F (Qt+1 ∪ Qt+2 ∪ · · · ∪ Qh ∪ Qh+1) is contained in seg(t(v), h(wP )). By
deﬁnition of F2, F2(x) = x for x ∈ F (Qt+1 ∪ Qt+2 ∪ · · · ∪ Qh ∪ Qh+1), either F2(wP ) =
wP or F2(wP ) = head(wP , t(v)), and F2(γ) = γ. Hence, right(I2(wP )) = h(wP ) and
left(I2(γ)) = t(γ). Since t(γ) is contained in seg(h(wP ), t(v)), left(I2(γ)) is to the right
of right(I2(wP )). By Lemma 2.6, we can easily see that I2(γ) contains any interval of
I2(Qt+1) and hence, F2(γ) contains any arc of F2(Qt+1). Thus, arc γ contains any arc of
F (Qt+1). Since any arc of F (Qt+1) is contained in seg(t(v), h(wP )), t(γ) is contained in
seg(h(wP ), t(v)) and γ contains any arc of F (Qt+1), we get that arc γ contains h(wP ),
i.e., γ ∈ Bp(h(wP )).
Next, we will show that any arc of F \ C does not intersect tail(γ, h(wP )). By State-
ment (1) of Lemma 4.24, any arc of F (Qt+1 ∪ Qt+2 ∪ · · · ∪ Qh ∪ Qh+1) is contained in
41
[3] J.C. Bermond, Hamiltonian graphs, in Selected Topics in Graph Theory ed. by L.W.
Beinke and R.J. Wilson, Academic Press, New York, 1978.
[4] A.A. Bertossi and M.A. Bonuccelli, Hamiltonian circuits in interval graph generaliza-
tions, Inform. Process. Lett. 23 (1986) 195–200.
[5] M.A. Bonuccelli and D.P. Bovet, Minimum node disjoint path covering for circular-arc
graphs, Inform. Process. Lett. 8 (1979) 159–161.
[6] M.S. Chang, S.L. Peng and J.L. Liaw, Deferred-query – an eﬃcient approach for some
problems on interval and circular-arc graphs, Lecture Notes in Comput. Sci., vol. 709,
Springer, Berlin, 1993, pp. 222–233.
[7] M.S. Chang, S.L. Peng and J.L. Liaw, Deferred-query: an eﬃcient approach for some
problems on interval graphs, Networks 34 (1999) 1–10.
[8] D.Z. Chen, D.T. Lee, R. Sridhar and C.N. Sekharan, Solving the all-pair shortest path
query problem on interval and circular-arc graphs, Networks 31 (1998) 249–258.
[9] P. Damaschke, The Hamiltonian circuit problem for circle graphs is NP-complete,
Inform. Process. Lett. 32 (1989) 1–2.
[10] P. Damaschke, J.S. Deogun, D. Kratsch and G. Steiner, Finding Hamiltonian paths in
cocomparability graphs using the bump number algorithm, Order 8 (1992) 383–391.
[11] P. Damaschke, Paths in interval graphs and circular arc graphs, Discrete Math. 112
(1993) 49–64.
[12] J.S. Deogun and G. Steiner, Polynomial algorithms for Hamiltonian cycle in cocom-
parability graphs, SIAM J. Comput. 23 (1994) 520–552.
[13] J.S. Deogun and C. Riedesel, Hamiltonian cycles in permutation graphs, J. Combin.
Math. Combin. Comput. 27 (1998) 161–200.
[14] E.M. Eschen and J.P. Spinrad, An O(n2) algorithm for circular-arc graph recognition,
in: Proceedings of the 4th Annual ACM-SIAM Symposium on Discrete Algorithm
(SODA’93), 1993, pp. 128–137.
[15] M.R. Garey and D.S. Johnson, Computers and Intractability: A Guide to the Theory
of NP-Completeness, Freeman, San Francisco, CA, 1979.
43
