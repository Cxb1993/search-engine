 表 2-1 
                   表目錄 
各種偵測技術的優缺點比較．．．．．．．．．．．．．．．． 18 
表 2-2 偵測軟體偵測提出 Rootkit 結果．．．．．．．．．．．．．． 29 
表 2-3 使用資料探勘之惡意軟體偵測 ．．．．．．．．．．．．．． 40 
表 4-1 所欲測試之 Rootkits 種類．．．．．．．．．．．．．．．．． 57 
表 4-2 偵測機制功能比較．．．．．．．．．．．．．．．．．．．． 58 
表 4-3 偵測機制比較．．．．．．．．．．．．．．．．．．．．．． 58 
表 4-4 偵測機制各模組之運作時間．．．．．．．．．．．．．．．． 59 
 圖 2-24 方法 8 之找尋 Object Drivers 的方式．．．．．．．．．．．．．．．．．．．．．．． 35 
圖 2-25 方法 9 之找尋 Object Drivers 的方式．．．．．．．．．．．．．．．．．．．．．．． 36 
圖 2-26 方法 10 之找尋 Object Drivers 的方式．．．．．．．．．．．．．．．．．．．．．．． 36 
圖 2-27 方法 11 之找尋 Object Drivers 的方式．．．．．．．．．．．．．．．．．．．．．．． 37 
圖 3-1 Driver-hidden Rootkits 偵測機制流程．．．．．．．．．．．．．．．．．．．．．．． 42 
圖 3-2 尋找 Object Driver 相關屬性．．．．．．．．．．．．．．．．．．．．．．．．．．． 43 
圖 4-1 Windows 環境設定．．．．．．．．．．．．．．．．．．．．．．．．．．．． 53 
圖 4-2 偵測器載入．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．． 54 
圖 4-3 開始搜尋記憶體．．．．．．．．．．．．．．．．．．．．．．．．．．．．．． 54 
圖 4-4 未發現 Rootkit．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．． 55 
圖 4-5 偵測到 Tsaur et al. 所提出之 Rootkit，並探勘相關特徵後詢問是否
卸載．．．．．．．．．．．．．．．．．．．．．．．．．．．．． 55 
圖 4-6 如選擇不要卸載，機制仍會再次詢問是否卸載．．．．．．．．．．．．．．． 56 
圖 4-7 本機制研發之偵測器成功卸載該 Rootkit．．．．．．．．．．．．．．．．．．．． 56 
 iv 
Abstract 
More and more malicious programs are combined with rootkits to shield their illegal 
activities, and the result makes information security defense encounter a great challenge. It 
can be observed that most sophisticated kernel mode rootkits are implemented to execute 
hiding tasks through drivers in Windows Kernel. Therefore, for the purpose of system 
security, the role of a detector for detecting Windows driver-hidden rootkits is becoming 
extremely important. In the project of TWISC@NCKU(III) in 2008, we have developed a 
new Windows driver-hidden rootkit with five tricks based on Direct Kernel Object 
Manipulation, and have verified on the Testbed@TWISC platform that it can successfully 
avoid a variety of well-known rootkit detectors. Therefore, in this project we then propose a 
countermeasure to effectively detect Windows driver-hidden rootkits. Furthermore, we also 
develop an effective scheme to unload the detected driver-hidden rootkits from the Windows 
system to achieve higher system security. After the proposed detecting and unloading 
schemes have been developed, we also test them on the Testbed@TWISC platform by 
Windows 2000, Windows XP SP0, Windows XP SP2 and Windows XP SP3, respectively. 
We affirm our efforts will be extremely useful for improving the current techniques of 
detecting Windows driver-hidden rootkits. 
Keywords: Malware, Rootkit, System security, Windows, Kernel mode 
 - 2 - 
 
圖 1-1  惡意軟體結合Rootkits趨勢 
第二節   研究動機與目的 
與許多其他惡意軟體相比，Rootkit通常並不具有強大的破壞力，但是Rootkit
的高深隱藏技術卻會被其他惡意程式用來躲過防毒軟體或防惡意軟體程式的監
控，讓系統在神不知鬼不覺的情況下被惡意程式侵佔，進而造成防護上的漏洞，
使電腦內重要的檔案被駭客偷走或流出，嚴重影響到資料的安全性。例如，Sony 
BMG為了防止使用者盜拷光碟，自2005年出貨的音樂光碟中，採用了Rootkit技術
來隱藏其數位版權管理軟體(Felten and Halderman, 2006)，結果如此的做法卻讓其
他惡意軟體有機可乘，於侵入使用者電腦後在使用者不知的情況下利用此Rootkit
隱藏蹤跡，造成了使用者極大的損失。在以上事件被 Mark Russinovich 
(RootkitRevealer偵測軟體[Cogswell and Russinovich, 2005]發明者)揭發以及一個
專屬的Rootkit論壇(Bulter and Honglund, 2004)問世後，Rootkit就受到全世界非常
廣泛的注意，也因此許多以Microsoft Windows為目標之Rootkit被製造出來。更糟
糕的是，越來越多的惡意軟體製造者以更高竿的Kernel Mode Rootkit技術進行隱
藏其非法活動(Florio, 2005; McAfee, 2006; Chian and Lloyd, 2007)，如此的Rootkit
隱藏技術在Microsoft Windows作業系統中，大多數皆被製作成驅動程式(driver 
program)的形式。雖然市面上有許多的Rootkit偵測軟體被研發出來，且對各種已
 - 4 - 
開發了該 DKOM-based Rootkit 後，發現現今知名偵測軟體其偵測方法考慮並未
周全。因此，本研究將進一步研發能偵測各種 Windows Kernel Mode Rootkit(驅動
程式之類型)之偵測機制，包括亦能偵測新型未知 Rootkits，並發展出目前各種知
名偵測軟體所無法做到的有效卸載 Rootkits 機制及常駐功能，以徹底去除其潛在
的破壞。 最後，於 完成該 Driver-hidden Rootkit 偵測軟體 後，將會 在
Testbed@TWISC 平台上進行其運作的測試。 
第五節   報告架構 
本報告由第二章開始，首先將針對與本研究相關的文獻進行探討。第三章則
經由第二章所探討的 Rootkits 相關文獻，並試圖改善各偵測軟體缺點，設計常駐
型偵測與卸載 Rootkits 機制。於第四章進行實測所提之偵測與卸載 Rootkits 功能，
最後於第五章作一總結，並提出未來展望。各章說明如下： 
第二章 文獻回顧： 
探討與本研究相關之文獻，包括 Rootkits 的種類與隱藏技術、Rootkit 偵測
技術、找出 Object Drivers 的方法及基於資料探勘惡意軟體偵測技術之相關
研究。 
第三章 建構 Driver-hidden Rootkits 偵測與卸載機制： 
依據第二章之相關理論基礎，發展基於資料探勘技術之 Driver-hidden 
Rootkits 偵測與卸載機制，以 有 效 抵 禦 R o o t k i t s 並 徹 底 去 除 其 潛 在
的 破 壞 。 
第四章 實驗設計與分析： 
當本偵測軟體開發完成後，於 Testbed@TWISC 平台上針對 Windows 2000、
Windows XP SP0、Windows XP SP2、 Windows XP SP3 四種作業系統進行
實測其偵測與卸載 Rootkits 功能。。 
第五章 結論與未來展望： 
對本研究作一總結，並提出未來展望。 
 - 6 - 
第二章   文獻探討 
在此章中，本研究將對相關之文獻進行探討，包括 Rootkit 的種類與隱藏技
術、Rootkit 偵測技術、新型 Driver-hidden Rootkit 隱藏方法、找出 Object Drivers
的方法及基於資料探勘之惡意軟體偵測技術，並加以歸納、分析與整理。 
第一節   Rootkit 的種類與隱藏技術 
Rookit 在 90 年代初期首次出現並由許多工具收集而成，它源自於 UNIX 作
業系統，在系統中原是一組指令，可藉此指令取得作業系統 Root 存取權限的工
具套件(Kit)，所以 Rootkit 是來自 Root 與 Kit 兩個字的結合。 
在 UNIX-like 系統中 Root 為最高權限的帳號，同時也是系統管理者的名稱，
一般的攻擊者都會想要取得系統中 Root 的存取權限，Rootkit 並沒有病毒或蠕蟲
的特性(例如：傳播或複製)，而攻擊者所採取一些方法(例如：開啟通訊埠、系統
弱點或木馬程式等等)是將 Rootkit 程式植入目標系統中，並暗中啟動該程式，其
會隱藏攻擊者的行為並不被系統管理者發現已植入或正在執行的 Rootkit。 
雖然 Rootkit 源自於 UNIX 系統 (Chian and Lloyd, 2007; Andreas, 2004)，但是
包括 Windows 在內的電腦系統也已漸漸出現數種 Rootkit，而現有的 Rootkit 也不
全為指令，只要能取得、執行系統高權限的帳號、不被系統管理者發現的工具或
沿用現有 Rootkit 相同概念所撰寫的程式，都稱為 Rootkit。尤其以近期的 Rootkit 
都特別著重在隱藏蹤跡的技術，且已經有越來越多的間諜軟體、病毒、蠕蟲、後
門等惡意軟體，也開始加入 Rootkit 的隱藏功能。 
以下玆將現有的 Rootkit 類型如下： 
一、Rootkits 的種類 
Rootkit 現有的隱藏技術共可分為五種類型 (Molina, Zimmerman, 
Roberts, Eaddie, and Peterson, 2008)：資料庫型(Library)、使用者模式(User 
 - 8 - 
 
圖 2-1  作業系統架構 
建立於 Kernel 層級之 Kernel Mode Rootkit (Kruegel, Robertson, and 
Vigna, 2004)比 User Mode Rootkit 功能更強大，其透過操作與利用
Kernel，成為最難被發現的 Rootkit，因為它能夠在應用層檢查過程中，
建立一條繞過檢驗的通道。雖然這種惡意軟體主要是針對特定作業系
統所製作，但它可能經由修改，以針對某個通訊埠或者是其他的作業
系統來進行攻擊。一旦被安裝到目標主機上，代表系統完全被駭客所
控制，甚至連系統管理員都找不到駭客隱藏的蹤跡，進而嚴重地威脅
整個電腦系統。因此，我們不得不留意此類型 Rootkit 的產生。 
(五)BIOS 型(BIOS-Level) Rootkit 
BIOS(Basic Input / Output System) 提供了電腦系統與硬體元件之
間的溝通橋樑，當電腦開機確認基本元件(CPU、記憶體、顯示卡、鍵
盤、滑鼠…等)裝備無誤後，才會將電腦執行權轉交給硬碟中的 OS。因
此，BIOS-Level Rootkit 通常都比 OS 更低階，且更早被載入。但其較
為稀少且缺乏有效性， 故我們並不談如何偵測此種 Rootkits。 
二、Rootkits 的隱藏的技術 
以下將進一步描述現有 Rootkit 隱藏技術。 
(一)Patching 
此技術是置換或修改作業系統物件來達到防止被發現 Rootkit 的
 - 10 - 
的函數皆有各自的索引值。一般進程呼叫存取 SSDT 四個步驟如圖
2-3 所示。 
步驟 1：一個進程擁有該函數的索引值，並查詢 SSDT 得到該函數
的記憶體位置。 
步驟 2：當進程得到該函數的記憶體位置後，便能夠呼叫該函數。 
步驟 3：Windows 執行函數。 
步驟 4：函數回傳結果給原先進程。 
 
圖 2-3  進程呼叫 API 
Rootkit Hook SSDT，修改或攔截函數的要求，如圖 2-4 所示。
其可分為六個步驟，並分別列述如下： 
步驟1： 進程呼叫 SSDT 去得到函數的記憶體位置。 
步驟2： 由於 SSDT 已經被 Hooking，SSDT 裏進程呼叫函數所得
到的記憶體位置被 Rootkit 竄改成 Rootkit 程式碼的記憶
 - 12 - 
(SSDT)。 
其執行進程示意如圖 2-5 所示，並分別以八個步驟列述如下： 
步驟1： 一個進程呼叫被 Rootkit Hooking 指到 Rootkit 程式碼的
函數。 
步驟2： 執行 Hooked 函數並立即跳到 Rootkits 程式碼。 
步驟3： Rootkit 程式執行，同時修改參數訊息。 
步驟4與5： Rootkit 替換 Hooked 函數的 「jmp」 原本程式碼，
並完成函數呼叫。 
步驟6： 函數結果至 Rootkit 後，Rootkit 便能夠再次修改原本的參
數。 
步驟7： Rootkit 還原 Hooked 函數的原本程式碼成「jmp」程式碼， 
以方便下次再進行 Hooking。 
步驟8： Rootkit 回傳被竄改過的資訊給原本進程。 
 
圖 2-5  呼叫被 Hooked 之 API 的程序 
 
 - 14 - 
系統都會分配 4GB 的虛擬記憶體空間，前 2GB 供使用者模式
的應用程式使用，後 2GB 是核心模式記憶體空間，供核心使用，
如圖 2-7 所示。而上述的所有結構都存在核心記憶體中，使用者模
式的程式是不能存取核心記憶體的，要存取核心記憶體，必須要有
相當的權限進入核心，因此一般要進入核心只能通過撰寫驅動程式
的方式，達到目的。 
 
 
 
 
 
 
 
 
圖 2-7  Windows 系統 4G 虛擬記憶體空間之分佈位置 
如圖 2-8 所示，Butler 等人(Bulter, Undercoffer, and Pinkston, 
2003)使用 DKOM 一種核心結構的 EPROCESS，來改變一個雙重鏈
結， 讓進程隱藏。如果要隱藏 EPROCESS B 需要把其雙向鏈結刪
除，並把進程 B 的前一個進程 A 的 FLINK 指向目前進程 B 後一個
進程 C，再把目前進程 B 後一個進程 C 的 BLINK 指向目前進程 B
前一個進程 A。亦即 DKOM-based Rootkits 為隱藏中間進程 B 之
FLINK 和 BLINK 的過程。當使用 DKOM，雖然 Rootkits 的製作者
需要辛苦的了解 Windows 核心結構，但比起使用 Hooking 的隱藏
效果卻更好。 
 
使 用 者 模 式 應 用 程 式  
 
核 心 模 式 物 件  
0 x 0 0 0 0 0 0 0 0  
 
 
0 x 8 0 0 0 0 0 0 0  
 
 
0 x FF F F F F F  
 - 16 - 
(http://www.chkRootkit.org)。 
二、行為偵測(Heuristic/Behavioral Based Detection) 
行為偵測則是搜尋 Rootkit 程式隱藏的元素，包括檔案或記錄。特徵偵
測充滿許多缺點，故可以利用行為偵測去取代，而最佔優勢的部分，是其
具有鑑別的能力，可辨別與正常系統不一樣之行為，故可用以偵測出新的
或者先前從未被辨識之 Rootkit。VICE(Jamie, 2004)、Patchfinder 都是基於
此技術所研發的 Rootkit 偵測軟體。 
三、完整性偵測(Integrity Based Detection) 
除了特徵偵測與行為偵測技術外完整性偵測也是偵測技術另外一種選
擇，一旦作業系統安裝設定完後，立即透過不同的完整性確認演算法，如
MD5 (Ronald, 1995)與從 WIKIPEDIA 的網頁中，可以獲得 SHA-1 資訊
(http://en.wikipedia.org/wiki/SHA-1)，皆會對系統中的檔案與目錄建立一個
比對資料庫，定期或不定期經由上述之演算法對檔案與目錄進行運算後，
再將所得到的資料與比對資料庫進行比對，以驗證檔案或目錄是否被竄
改，若比對當中有與比對資料庫之資料不符合即被認為是惡意行為的依
據，而 Tripwire 是這一技術之翹楚。 
四、交叉察看偵測(Cross-view Based Detection) 
交叉察看偵測是目前新興且被看好的偵測技術。其首先透過 Windows 
Common APIs 取得系統上重要的資訊，如檔案(Files)、進程或機碼(Registry 
Key)，再與「經由程式本身演算法產生的資訊」進行交叉察看，若此兩種
資訊不一樣，就表示系統可能被安置 Rootkit。Rootkit Revealer 並且從
F-SECURE 的 網 頁 中 ， 可 以 獲 得 Blacklight 資 訊
(http://www.f-secure.com/blacklight)，都是基於此技術所研發的 Rootkit 偵測
軟體。 
 - 18 - 
表 2-1  各種偵測技術的優缺點比較 
偵測技術之類別 優點 缺點 
特徵偵測 
需不定期更新病毒碼至資料
庫中，即可偵測新的惡意軟
體。 
檢測系統檔案、進程、驅動
程式與機碼。 
行為偵測 
可辨識已知或未知的惡意軟
體。 
無法辨識特定的惡意軟體。 
完整性偵測 
不需更新病毒碼至資料庫
中，可發現系統檔案是否被
竄改。 
無 法 辨 識 惡 意 軟 體 行
為 。  
硬體式偵測 
擁有自己的 CPU，並透過
DMA 對電腦記憶體掃描。 
需花費大量成本建置與維
護。 
交叉察看偵測 
檢測系統檔案、進程、驅動
程式與機碼。 
只應用於 Windows 作業系
統。 
第三節   新型 Driver-hidden Rootkit 隱藏方法 
Rootkit 隱藏電腦資源的方法大約分成兩種不同的技術。一種是使用
Hooking，攔截系統中的各種函數。另一種使用 DKOM 讓 Driver 的 Driver Object
進行隱藏。另外，NT Rootkit 是最早的 Windows 核心模式 Rootkit，其使用 Table 
Hooking 方式修改 SSDT 達到隱藏進程、驅動程式、檔案等功能。雖然此方法是
簡單穩定且有效的隱藏方式，但也很容易被 Rootkit 偵測軟體(Keong, 2004)所偵測
到。Hunt 和 Brubacher(1999)使用 Detours 修改資料的 Win32 二元函數達到隱藏。 
後來，有些 Rootkit 使用 Inline Hooking 的特殊「jump」函數指向它自己的 Rootkit 
程式碼，而不再是竄改 SSDT 達到隱藏效果。因此，VICE (Jamie, 2004)就是來偵
測 Table Hooking 或是 Inline Hooking 的 Rootkit 行為偵測型偵測軟體。後來的
Rootkit 製作者使用了複合(polymorphic) (Beaucamps, 2007)的技術，製作出一個擁
 - 20 - 
2-9 所示，有三個物件分別命名為 A、B 與 C。每一個都有一個 List_Entry 資料結
構。A.FLINK 指向 B，B.FLINK 指向 C，C.BLINK 指向 B，B.BLINK 指向 A。
如果我們要隱藏 B，我們將 A.FLINK 指向 C，C.BLINK 指向 A，結果如圖 2-10
所示。此技巧簡單但又有效，其 DKOM 程式片段如下： 
 DKOM(Target_Object) 
 { 
       (Target_Object -> Blink) -> Flink = Target_Object -> Flink 
    (Target_Object -> Flink) -> Blink = Target_Object -> Blink 
 } 
圖 2-9  以雙重鍊結進行鍊結相同類型的物件 
 
 
 
 
 
 
 
圖 2-10  修改雙重鍊結以隱藏物件 B 
 - 22 - 
pObjectDirectory: a pointer to theObject_Directory 
Target: an array storing wanted drivers’ name to hide 
FindObject(): a function that finds the value of the argument 0 in 
argument 1. If the value is found, it returns 1 or 0. 
CheckObjectType() : a function that checks the type of a given object. If a 
given object belongs to the type of ObjectDriver or the 
type of ObjectDevice, the function returns 1. If it belongs 
to the type of ObjectDirectory, then the function returns 2 
or returns 0. 
移除 Object Drivers 和 Object Devices 程式片段如下： 
1 HideMain(pObjectDirectory) 
2    for ( i = 0 to 36 )   // an array with 37 items 
3          pTmp= pObjectDirectory + i*4    
   //a address storing an object’s address 
4          while( true) 
5              j = CheckObjectType(pTmp) 
6              if j = 1 
7                      HideDriver(pTmp) 
8              else if j = 2 
9                      HideMain(pTmp) 
10              if pTarget -> ChainLink = Null 
11                      exit 
12              else 
13                pTmp = pTmp ->ChainLink 
14    i = i + 1 
15    return 0 
 - 24 - 
1 Hide(pObjectType) 
2  pTarget = pObjectType -> Flink 
3  whil (pTarget <> pObjectType) 
4   ptmp = pTarget -> Flink 
5   i = FindObject (pTarget , Target) 
6   if i = 1 
7    (pTarget -> Blink) -> Flink = ptmp -> Flink 
8    (pTarget -> Flink) -> Blink = ptmp -> Blink 
9    pTarget = pTarget -> Flink 
10 return 0 
 
圖 2-12  Object Driver 和 Object Type 的關係 
三、從 Object Directory 移除 Object Drivers 和 Object Devices 
除了是不同種類的物件外，本方法與 0 節相同。首先我們先透過載入
Object Driver 去找出 Object Device。找到 Object Device 以後，我們便可以
 - 26 - 
數改為一個指向 PsLoadedModuleList 的指標以外，其餘與「從驅動程式的
Object_Type 移除 Object Drivers」段中所列出者皆相同。 
 
 
圖 2-14  一個 Object Driver 和 PsLoadedModuleList 之間關係 
五、修改 Object Driver 的屬性 
為了躲避以特徵為基礎的偵測器，Tsaur, Chen, and Tsai (2009)修改了標
的 Object Driver 屬性讓其與一般 Object Driver 不相同。例如，若一個正常
Object Driver 在 Offset 0x000h 值為 0x04，則將其修改成另一個隨機值以達
到隱藏的效果，如圖 2-15 所示。 
 - 28 - 
由於上述缺點，Testbed@TWISC 平台即是為了解決傳統網路安全
測試平台之不足，TWISC＠NCKU 整合美國 Utah 大學所授權的 Emulab 
Testbed 軟體、國產硬體以及自行研發設計的軟體與韌體，利用簡單的
Web-GUI 操控介面，即能克服時間與空間的限制，提供國內資訊安全
研究與實驗所需的隔離性、封閉性、可紀錄性、可控制性與可儲存性
之完整環境。 
(二)Testbed@TWISC 平台實測結果 
在前五小節我們已經說明了提出 Windows Driver-hidden Rootkit 
的隱藏方法。我們將在此節示範實測過程。所提出的 Rootkit 被命名為 
hookzw.sys，其使用 Borland TSAM5.0 所撰寫並以驅動程式呈現，且執
行在 Windows XP SP2。經由 AntiRootkit website(Anti Rootkit.com, 2008)
推薦，我們找到了 DarkSpy、GMER、IceSword  和 Unhooker，此四種
是被評為五星級的 Rootkit 偵測軟體；另外 Buster  和 Tucan 分別由趨
勢公司(Trend Micro)和 Panda 所製，其雖未被評比，但也有偵測 Rootkit
的功能。 
基於上述六種偵測軟體，在 Testbed@TWISC 平台上進行測試此新
型 Windows Driver-hidden Rootkit 的隱藏能力，其結果說明如下。當提
出的 Rootkit 被安裝但未開啟隱藏功能時，此四個偵測軟體 DarkSpy、
GMER、 IceSword 和 Unhooker 皆列出系統中有存在著驅動程式
hookzw.sys；而另外兩個偵測軟體 RootkitBuster 和 Tucan 其使用者介面
並不顯示任何驅動程式訊息。當我們所提出的 Rootkit 開啟隱藏功能
後，此六種偵測軟體皆無法偵測到此 Rootkit。測試結果如表 2-2 所示。 
 
 
 - 30 - 
實體記憶體中。因此，所有的驅動程式都將會被載入到記憶體中。故只要
搜索我們所定義的記憶體範圍便可以找到所有的 Object Drivers，並且能夠
得到相對應的驅動程式之所在記憶體位置。如要找出所有可能的 Object 
Drivers，便需定義出正確的記憶體範圍。因此，如何定義出記憶體搜尋區
塊，以使得能夠搜尋出所有可能的 Object Drivers 將成為重要的議題。因此，
我們將詳細地提出定義記憶體區塊的方法。 
Object Driver 與其 PsLoadeModuleList 距離是小於 0x1000000，而其
PsLoadeModuleList 與鄰近的 PsLoadeModuleList 距離也是小於 0x1000000。
因此，我們便得出 PsLoadeModuleList 與其他的 Object Driver 距離為正負
0x2000000 之間，如圖 2-16 所示。 
搜尋記憶體流程如下： 
步驟1： 我們提出的偵測機制安裝後便可得到其 Object Driver。 
步驟2： 經 由 其 他 Object Drivers 內 的 DriverSection 得 到 該
PsLoadedModuleLists，進而獲得所有 Object Drivers 最小到最大的
記憶體位置範圍。 
步驟3： 我們把最小與最大的記憶體位置分別命名為：A1 和 A2。而 A1
與 A2 皆為 10-bit 格式，如：0x85451000。並使其前 4 bits 不變其
他則設為 0，如：0x85000000。 
步驟4： 將開始位置 A1 再減 0x02000000 並讓結束位置 A2 增加
0x02000000。 
 - 32 - 
 
圖 2-17  方法 1 之找尋 Object Drivers 的方式 
方法2： 檢驗偵測物件 Object Driver 裡的「Type」值是否為 0x004 且「Size」
值是否為 0x0a8，如圖 2-18 所示。 
 
圖 2-18  方法 2 之找尋 Object Drivers 的方式 
方法3： 檢驗偵測物件 Object Driver 裡的「HaredwareDataBase」值是否與
偵測器的相符，如圖 2-19 所示。 
 - 34 - 
 
圖 2-21  方法 5 之找尋 Object Drivers 的方式 
方法6： 檢驗偵測物件 Object Driver 裡的「DeviceObject」值是否介於
0x80000000 與定義搜尋記憶體的最大記憶體位置之間，如圖 2-22
所示。 
 
圖 2-22  方法 6 之找尋 Object Drivers 的方式 
方法7： 檢驗偵測物件 Object Device 裡的「Type」值是否等於 0x003，如
圖 2-23 所示。 
 - 36 - 
 
圖 2-25  方法 9 之找尋 Object Drivers 的方式 
方法10： 檢驗偵測物件 PsLoadedModuleList 裡的「DriverInit」是否與該
Object Driver 裡的「DriverInit」相等，如圖 2-26 所示。 
 
圖 2-26  方法 10 之找尋 Object Drivers 的方式 
方法11： 偵測物件 PsLoadedModuleList 0 裡的「TypeList」之 Flink 和 Blink
值將等於 PsLoadedModuleList 1 和 2 的記憶體位置。因此只需檢
驗 PsLoadedModuleList 1 裡的「 TypeList 」之 Blink 值與
PsLoadedModuleList 2 裡 「 TypeList 」 的 Flink 值 是 否 與
 - 38 - 
示。同時，由於 Rootkit 屬於較為特殊的研究，我們更難發現以資料探勘來偵測
Rootkit 的相關著作。 
表 2-3  使用資料探勘之惡意軟體偵測 
Martignoni 等人(2008) Ye 等人(2007) Schultz 等人(2001) 
攻擊行為 Windows API API 
由於基於 DKOM 的 Driver-hidden Rootkit 屬於 Windows 最核心的部份，故若
使用Ye, Wang, and Li等人(2007)及Schultz, Eskin, amd Zadok等人(2001)用於偵測
API 的偵測機制來偵測 DKOM-based Driver-hidden Rootkit 是無法成功的。另外，
Martignoni, Stinson, and Fredrikson 等人(2008)雖然結合了資料探勘技術來偵測
Windows API 攻擊行為，但其尚無法找出 DKOM-based Driver-hidden Rootkit，且
該機制之惡意軟體行為分析方式將常駐在系統中，也就是說當 Rootkit 載入、攻
擊時該機制僅能單純地進行偵測與分析。 
在本研究中，資料探勘的特徵比對可以幫助本研究來分析 Driver 與
Driver-hidden Rootkit 所擁有的連續屬性特徵，使得 Driver-hidden Rootkits 特徵可
以更精準地被探勘出，進一步輔助本機制提高 Driver-hidden Rootkit 的偵測能力，
因此本研究將使用 Oh 和 Kim 在 2005 年提出的資料相似度計算方法，並對此方
法說明如下。 
Oh 和 Kim (2005)年提出一種完全不同的概念來計算樣本相似度。該篇論文
主要探討連續(Sequence)資料的相似度計算方法如公式 2-1 所示，其中 is 與 js 代
表兩連續資料樣本， |EE| ji ∩ 則代表兩樣本中任一對項目(Item)所交集的個數，而
|E| i 及 |E| j 代表該樣本中任一對相目的總數，舉例來說：若 1s ={A,B,C,D}，
2s ={A,C,D,E}，則 1E = {AB,AC,AD,BC,BD,CD}，  |E| 1 =6，
2E ={AC,AD,AE,CD,CE,DE}， 2|E |=6，  21 EE ∩ ={AC,AD,CD}，
|EE| 21 ∩ =3，而 1s 與 2s 的相似度 Sim( 1s , 2s )=1/2。 
 - 40 - 
第三章  建構 Driver-hidden Rootkits 偵測與卸載機制 
本研究已於第二章中論述Rootkits與新型Driver-hidden Rootkit相關議題之研
究現況，可知現存知名 Rootkit 偵測軟體機制雖具備偵測某些 Rootkit 能力，但卻
未詳加考慮以致忽略某些 Driver-hidden Rootkits 的存在，同時亦無常駐偵測功
能。是故，本研究將植基於陳昱成(2008)提出之 Driver-hidden Rootkit 偵測機制並
結合定時偵測(Molina, Zimmerman, Roberts, Eaddie, and Peterson, 2008)，以提出具
特徵比對能力之 Driver-hidden Rootkits 偵測機制，來有效地去除 Rootkits 在載入
使用者電腦後產生之系統危害，並具備能將所偵測到的 Rootkits 從作業系統中進
行卸載(Unload)，以徹底去除其潛在的破壞。以下茲將於第一節與第二節中，分
別提出 Driver-hidden Rootkits 偵測與卸載機制流程，以及其各階段之運作流程細
節。 
第一節   機制流程 
目前知名的 Rootkits 偵測軟體，譬如：DarkSpy、GMER、 IceSword 和 
Unhooker，皆只提供了 Rootkit 單次偵測的功能。若使用者未採用定時 Rootkit 偵
測軟體捕捉 Driver-hidden Rootkits 將提昇使用者被植入惡意軟體的機率，進而造
成其電腦系統飽受安全上的威脅。因此，本研究將基於資料探勘技術的特徵比對
與陳昱成於  2008 年新 Driver-hidden Rootkits 之偵測方法，並結合 Molina, 
Zimmerman, and Roberts 等人(2008)的定時 Rootkits 偵測機制的概念，以達到更準
確與安全的 Driver-hidden Rootkits 偵測機制。以下茲列出本機制之詳細流程。 
許多 Utility 程式都依賴 Windows 核心函數 ZwQuerySystemInformation 得到
需要使用的驅動程式。PsLoadedModuleList 也可經由 ZwQuerySystemInformation
函數得到所有驅動程式，而 Rootkits 便可利用此 PsLoadedModuleList 得到所需要
隱藏的驅動程式位置，進而使用 DKOM 方式達到隱藏某特定驅動程式的目的。
我們能夠從所設計的偵測器得到目前記憶體所被載入的驅動程式列表，並與從
 - 42 - 
並將其 Object Driver 內的「DriverStart」值記錄於另一串列(稱其為串列
三)中，並與步驟 3 所獲得的串列二於步驟 6 進行比對。 
步驟6： 在比對完串列二與串列三後，如果可以從串列三找到驅動程式的記憶
體位置，而在串列二中找不到，我們便可以判定其可能為一個被隱藏
的驅動程式。 
此後，按照階段二的各個步驟，持續不斷進行偵測以找出所被隱藏的驅動程
式。 
值得注意的是，Tsaur, Chen, and Tsai(2009)在研究中發現一些關於驅動程式
資料結構的相關性，可以偵測出其是否為被隱藏的 Driver，而不需要經由
「PsLoadedModuleList」的 List_Entry 結構去尋找驅動程式相關訊息，因此為了
有效偵測各類型 Driver-hidden Rootkits，本研究將基於上述觀點並使用資料探勘
為基礎的特徵比對設計出具偵測未知型 Driver-hidden Rootkits 的偵測機制。 
 
圖 3-1  Driver-hidden Rootkits 偵測機制流程 
 - 44 - 
SP/EP： 紀錄記憶體範圍的起始點/終點 
alt_SP/ alt_EP： 紀錄新增 driver 的起始點/終點 
unload_rootkit()： 卸載函數 
 
主程式控制演算法如下： 
main() //主程式控制模組 main() 
load_detector(SP,EP);//呼叫載入偵測器函數並輸入 SP 及 EP 
 while(x=1) //x=1 使其產生迴圈達到即時偵測的效用 
 { detect(alt_SP,alt_EP); 
 if(detected!=NULL)//如 detected 陣列有資料便載入卸載函數 
      {    unload_rootkit(detected);      } 
   _sleep(3*1000);//延遲三秒鐘 
    x = 1;} 
二、偵測器起始模組 load_detector() 
在偵測器起始模組中，首先會從之前定義的記憶體範圍搜尋一次所有
的 ObjectDriver 記憶體位置並儲存到陣列中，其演算法之變數定義及輸入輸
出描述如下： 
輸入： 紀錄記憶體範圍的 SP/EP 
輸出： 把 SP 儲存到 tds 陣列 
SP/EP： 紀錄記憶體範圍的起始點/終點 
sv： 相似值 
tv： 門檻值 
sig： 儲存 ObjectDrivers 方法陣列 
 - 46 - 
在偵測器起始與偵測模組中，我們將 sig 陣列分成兩個階段來進行，第
一階段僅執行第二章第四節之方法 1 到 6，第二階段開始則將繼續階段一未
完成的方法。如果偵測的物件連第一階段近似值都無法達到門檻值 6 時，
將不會繼續執行第二階段，以節省偵測時間。如果偵測物件超過門檻值才
會繼續執行第二階段，以找出所有 Drivers，包含被隱藏的 Drivers。 
三、偵測模組 detect() 
在偵測器偵測模組中，首先它會判別是否為第一次執行，如果是，便
會將偵測器起始模組搜尋的所有 ObjectDriver 記憶體位置陣列，輸入到交叉
查看模組進行比較得出是否有 Driver-hidden Rootkit。當第二次執行以後，
它僅會對新增的 ObjectDriver 進行交叉察看已達到一定的效率。其演算法之
變數定義及輸入輸出描述如下： 
輸入： 新增 driver 的起始點(alt_SP)/終點(alt_EP) 
輸出： 把新增 driver 的起始點(alt_SP)儲存到 alt_tds 陣列 
count： 紀錄偵測執行次數 
compare()： 交叉查看函數 
alt_SP/ 
alt_EP： 
新增 driver 的起始點/終點 
sig_length： 讀取 sig 陣列長度函數 
alt_tds： 儲存新增 Object Driver 裡 DriverStart 值的陣列 
sv： 相似值 
tv： 門檻值 
sig： 儲存搜尋 ObjectDrivers 方法陣列 
tds： 儲存每個 Object Driver 裡 DriverStart 值的陣列 
strcmp()： 比較兩邊數值的函數。如果兩值相等函數傳回 1 否則傳回 0 
Store()： 儲存 Object Driver 到陣列的函數 
 - 48 - 
料結構，因此此模組負責將偵測模組及起始模組所找到的 ObjectDriver 與
PsLoadedModuleList 進行交叉比較便可以得到哪個 Driver 是被隱藏的，其
演算法之變數定義及輸入輸出描述如下： 
輸入： PsLoadedModuleList 
輸出： Hidden-Driver 陣列(detected) 
SP/EP： 被 Select()的紀錄記憶體範圍的起始點/終點 
tds： 儲存每個 Object Driver 裡 DriverStart 值的陣列 
fds： 儲存每個 PsLoadedModuleList 裡 DriverStart 值的陣列 
PLML： 儲存每個 PsLoadedModuleList 位置位置的陣列 
detected： 儲存 hidden-drivers 的陣列 
Record()： 在 PLML 陣列儲存參數值函數(PsLoadedModuleList 記憶體
位置)和在 fds 的陣列參數的 DriverStart 值 
Select()： 從 PLML 陣列選出最小與最大值並同存為 SP 及 EP 的函數 
Searching()： 從記憶體範圍中找尋所有可能的 Driver Objects 的函數 
strcmp()： 比較兩陣列(tds,fds)的差異並存到 detected 陣列中 
dm()： 特徵比對函數 
交叉察看演算法如下： 
Detecting(PsLoadedModuleList) 
ptmp = PsLoadedModuleList -> Flink 
while ( ptmp <> PsLoadedModuleList) 
Record(ptmp) 
Select(PLML) 
strcmp (tds,fds) 
return detected 
dm(detected) 
 - 50 - 
較低的相似度會影響其結果，所以不予考慮，則設為 Outlier。 
步驟5： 依其群集 C 內 js 的特徵來與 is 作判別，若有不同的特徵則更新
sig 陣列，以供偵測模組 detect()作為後續偵測之用；反之，則為
已知特徵，並不需更新 sig 陣列。來判別是否會產生特徵，若特
徵產生即存入 sig 陣列，否則回到步驟 3。 
經由上述的資料結構特徵比對得知，當未知的 Rootkit 在系統中改變資
料結構與現有已知 Rootkit 有部分相似時，可以經由特徵來判別是否為
Driver 並經由交 叉 察 看 ( c o m p a r e ( ) )模 組 來 得 知 是 否 為 新型未知的
Driver-hidden Rootkit。 
六、卸載模組 unload_rootkit() 
目前知名的 Rootkits 偵測軟體，譬如：DarkSpy、GMER、IceSword  和 
Unhooker，皆只提供了 Rootkit 偵測的功能，但卻無法卸載(Unload)Windows 
Driver-hidden Rootkits，因此仍然存在著繼續危害使用者電腦系統的可能
性。本研究希望能在發現 Rootkits 後，進而從作業系統中將其卸載，以徹底
去除其潛在的破壞。當驅動程式欲卸載時，I/O Manager 便須要呼叫 Windows 
核心的  Unload Routine 來執行清除，以釋放原先核心的記憶體空間 
(Tsegaye and Foss, 2004)。其演算法之變數定義及輸入輸出描述如下： 
輸入： Hidden-Driver 陣列(detected) 
輸出： 空的 detected 陣列 
Get_SLN() 獲取 Driver 的 Symbolic Link Name 函數 
sln 儲存 Symbolic Link Name 陣列 
free() 清除陣列函數 
ControlDriver() 控制 Driver 函數 
DeleteDriver() 刪除 Driver 函數 
reboot 重開機並刪除 Driver 函數 
 - 52 - 
第四章   實驗設計與分析 
本章主要以第三章研究方法所提出 Driver-hidden Rootkits 偵測機制為架構，
設計實驗並且進行分析，主要分為三小節包括實驗環境的說明、系統實作內容以
及最後針對實驗結果作一探討。 
第一節   實驗環境 
本研究所使用之軟硬體實驗環境如下： 
系統軟體：Microsoft Windows XP SP2 & SP3 
系統硬體：IBM 相容 Intel Pentium 3.0 GHz 桌上型電腦、512MB 動態存取記憶體
做為系統的開發平台。 
程式語言：本系統採用 Borland TASM5.0 及 Visual C++ 6.0 撰寫，程式主要分為
六大部分，分別為主程式控制、偵測器起始、偵測、交叉察看、特徵
比對與卸載模組。 
第二節   偵測機制測試 
本研究依照所提出Driver-hidden Rootkits偵測機制進行系統實作與實驗，其主
要是植基於陳昱成(2008)提出之Driver-hidden Rootkit偵測機制加入主程式控制、
偵測器起始、偵測、交叉察看、特徵比對、卸載模組(上述各模組如第三章所述之
main()、load_detector()、detect()、compare()、dm()、unload_rootkit())進而研發出
一套Driver-hidden Rootkits偵測機制。 
以下將測試本研究所研發之Driver-hidden Rootkits偵測機制。在使用本計畫所
研發之Rootkit偵測機制時，首先設定系統環境為Testbed@TWISC的Microsoft 
Windows XP SP2，如圖4-1所示。 
 - 54 - 
 
圖 4-2  偵測器載入 
 
圖 4-3  開始搜尋記憶體 
 - 56 - 
 
圖 4-6  如選擇不要卸載，機制仍會再次詢問是否卸載 
 
圖 4-7  成功卸載該 Rootkit 
第三節   機制可行性分析 
經由上述測試，可以清楚地了解本研究所提出的「Driver-hidden Rootkits 偵
測機制」，的確可以偵測到陳昱成(2008)提出之未知型 Driver-hidden Rootkit，並
 - 58 - 
表 4-2  偵測機制功能比較 
偵測 
工具 
功能 
Proposed 
scheme 
陳 
昱 
成 
(2008) 
Darkspy 
1.05 
GMER 
1.0.14 
IceSword 
1.22 
Unhooker 
3.7.3 
定時偵測 ○ × × × × × 
卸載 △ × × × × × 
△代表從表 4-1 中，除 Unreal 外皆能卸載 
表 4-3  偵測機制比較 
偵測工具 
Rootkits 
Proposed 
scheme 
陳昱成 
(2008) 
Darkspy 
1.05 
GMER 
1.0.14 
IceSword 
1.22 
Unhooker 
3.7.3 
AFXRootkit2005 ○ ○ ○ ○ ○ ○ 
Migbot ○ ○ ○ ○ ○ ○ 
Klog ○ ○ ○ ○ ○ ○ 
Unreal ○ × × ○ × ○ 
Rootkit.Win32. 
Agent.ff 
○ ○ ○ ○ ○ ○ 
Rootkit.Win32. 
Agent.eii 
○ ○ ○ ○ ○ ○ 
Hacktool.Rootkit ○ ○ ○ ○ ○ ○ 
RootKit.Win32. 
Mnless.akx 
○ ○ ○ ○ ○ ○ 
Tsaur et al.’s ○ ○ × × × × 
○代表被偵測到 / ×代表無法被偵測 
 - 60 - 
等人 (2008)提出的機制對偵測 Rootkit 相較之下，由於其僅對 Windows 的 API 部
份進行惡意軟體的行為分析，因此並不能夠找出未知型 DKOM-based 
Driver-hidden Rootkits，且此惡意軟體的行為分析法雖常駐在系統中，但僅當
Rootkit 載入時才進行偵測。最後，有關我們所提出的偵測機制，即使 Rootkit 已
經載入到系統中，本機制依然能偵測 Rootkit 的存在。因此，我們可以歸納出知
名五星級偵測軟體及陳昱成(2008) 所提出的偵測機制無法偵測到 Tsaur, Chen, 
and Tsai (2009)所提出的 Rootkit 及 Unreal 是有以下兩個原因： 
一、 一些偵測器僅使用預先定義特徵或偵測法進行偵測，而無法定時地透過已
知 Rootkit 進行特徵比對學習，進一步提高偵測能力，同時缺乏對 Driver 內
部的 List_Entry 資料結構之完整性檢查。 
二、 Driver 內的 Symbolic Link Name 之屬性記載著該 Driver 的名稱等資訊，然
而 Unreal 的 Symbolic Link Name 卻為空值，因此一些偵測器並未考慮當
Symbolic Link Name 為空時的處置方式，因而無法判斷 Unreal 為一個 Driver
進而無法判別為 Driver-hidden Rootkit。 
 - 62 - 
平台的用戶遠離 Rootkit 惡意軟體的威脅。 
在未來發展方面，由於本研究所提出之偵測機制僅對 DKOM-based 
Driver-hidden Rootkit 進行偵測，然而，現今 Rootkit 隱藏技術也開始採用複合方
式，譬如 DKOM 結合檔案的隱藏方式。因此未來將會針對 DKOM 等隱藏方法加
強其對複合式 Rootkit 偵測能力以達到預防 Rootkit 的效果，並使其可以在
Windows Vista 或 Windows 7 平台運作。
 - 64 - 
Computer Science, 2(3), 194-205. 
Beck, D., Vo, B., & Verbowski, C. (2005). Detecting stealth software with strider 
ghostbuster. International Conference on Dependable Systems and Networks, 
(pp. 368-377). 
Bulter, J., & Honglund, G. (2004). Rootkit Forum [online]. 
Available :http://www.rootkit.com [2009, June 14]. 
Bulter, J., Undercoffer, L. J., & Pinkston, J. (2003). Hidden process: the implication 
for intrusion detection. Papers presented at the IEEE International Workshop 
on Information Assurance, (pp. 116-121). 
Chian, K., & Lloyd, L. (2007). A case study of the rustock rootkit and spam bot. 
Papers presented at the USENIX First Workshop on Hot Topics in 
Understanding Bonets. 
Chuvakin, A. (2003). An Overview of Unix Rootkits. iALERT White Paper, iDefense 
Labs, Chantilly, Virginia. 
Cogswell, B., & Russinovich, M. (2005). RootkitRevealer [online].Available: 
http://technet.microsoft.com/en-us/ 
sysinternals/bb897445.aspx.[2009, June 14]. 
Dhamija, R., & Tygar, D. J. (2005). The Battle against Phishing: Dynamic Security 
Skins. Papers presented at the 1st Symposium on Usable Privacy and Security, 
(pp. 77-78). 
 - 66 - 
Keong, C. (2004). Defeating Kernel Native API Hookers by Direct Service Dispatch 
Table Restoration [Online]. Available: 
http://www.packetstormsecurity.org/hitb04/hitb04-chew-keong-tan.pdf [2009, 
June 10]. 
Kim, H. G., & Spafford, H. E. (1994). The design and implementation of tripwire: a 
file system integrity checker. Proceedings of the 2nd ACM Conference on 
Computer and Communications Security, (pp. 18-29). 
Kim, Y. S., Jung, S. T., Suh, H. E., & Hwang, S. H. (2006). Customer segmentation 
and strategy development based on Customer lifetime value: A case study. 
Expert Systems with Applications, 31(1), 101-107. 
King, S., Chen, P., Wang, Y., Verbowski, C., Wang, H., & Lorch, J. (2006). SubVirt: 
Implementing Malware with Virtual Machines. Proceedings of the IEEE 
Symposium on Security and Privacy, (pp. 314-327). 
King, T. S., & Chen, M. P. (2005). Backtracking intrusions. ACM Transactions on 
Computer Systems, 23(1), 51-76. 
Kreibich, C., & Crowcroft, J. (2004). Honeycomb: Creating intrusion detection 
signatures using honypots. ACM SIGCOMM Computer Communication Review, 
34(1), 51-56. 
Kruegel, C., Robertson, W., & Vigna, G. (2004). Detection kernel-level rootkits 
through Binary Analysis. Proceedings of the 20th Annual Computer Security 
Applications Conference, USA.  
 - 68 - 
Available:  http://www.vi-ruslist.com 
/en/analysis?pubid=168740859[2009, June 25]. 
Oh, S. J., & Kim, J. S. (2005). A hierarchical clustering algorithm for categorical 
sequence data. International Journal of Information Technology & Decision 
Making, 4(1), 81-96. 
Petroni, N. L., Fraser, T., Molina, J., & Arbaugh, W. A. (2004). Copilot-a 
coprocessor-based kernel runtime integrity monitor. Proceedings of the 13th 
Usenix Security Symposium, (pp. 179-194), USA. 
Rabek, J., Khazan, R., Lewandowski, S., & Cunningham, R. (2003). Detecting of 
injected, dynamically generated, and obfuscated malicious code. Proceedings of 
the ACM Workshop on Rapid Malcode, (pp. 76-82), New York. 
Ramakrishna, P., & Maarof, M. A. (2002). Detecting and prevention of active sniffing 
on routing protocol. Student Conference on Research and Development, (pp. 
498-501), USA. 
Ronald, R. (1995). Retrieved 6 14, 2009, from MD5 [Online]. Available: 
http://en.wikipedia.org/wiki/MD5 [2009, June 25]. 
Schultz, M. G., Eskin, E., Zadok, E., & Stolfo, S. J. (2001). Data mining methods for 
detection of new malicious executables. IEEE Symposium on Security and 
Privacy, (pp. 39-49), USA. 
Shaw, J. M., Subramaniam, C., Tan, W. G., & Welge, E. M. (2001). Knowledge 
 - 70 - 
國科會補助專題研究計畫成果報告自評表 
請 就 研 究 內 容 與 原 計 畫 相 符 程 度、達 成 預 期 目 標 情 況、研 究 成 果 之 學 術 或
應 用 價 值（ 簡 要 敘 述 成 果 所 代 表 之 意 義、價 值、影 響 或 進 一 步 發 展 之 可 能
性 ）、是 否 適 合 在 學 術 期 刊 發 表 或 申 請 專 利、主 要 發 現 或 其 他 有 關 價 值 等 ，
作 一 綜 合 評 估 。  
1.  請 就 研 究 內 容 與 原 計 畫 相 符 程 度 、 達 成 預 期 目 標 情 況 作 一 綜 合 評 估  
■ 達 成 目 標  
□  未 達 成 目 標 （ 請 說 明 ， 以 100 字 為 限 ）  
□  實 驗 失 敗  
□  因 故 實 驗 中 斷  
□  其 他 原 因  
說 明 ：  
2.  研 究 成 果 在 學 術 期 刊 發 表 或 申 請 專 利 等 情 形 ：  
論 文 ： □ 已 發 表  ■ 未 發 表 之 文 稿  □ 撰 寫 中  □ 無  
專 利 ： □ 已 獲 得  ■ 申 請 中  □ 無  
技 轉 ： □ 已 技 轉  ■ 洽 談 中  □ 無  
其 他 ：（ 以 100 字 為 限 ）  
3.  請 依 學 術 成 就、技 術 創 新、社 會 影 響 等 方 面，評 估 研 究 成 果 之 學 術 或 應
用 價 值（ 簡 要 敘 述 成 果 所 代 表 之 意 義、價 值、影 響 或 進 一 步 發 展 之 可 能
性 ）（ 以 500 字 為 限 ）  
 
( 1 )  辨 識 出 目 前 Wi n d o w s  R o o t k i t s 偵 測 軟 體 之 弱 點 ， 可 激 勵 R o o t k i t 偵
測 軟 體 研 發 廠 商 須 時 時 檢 測 其 功 能，以 有 效 保 障 廣 大 使 用 者 電 腦 系
統 安 全 。  
( 2 )  提 出 新 型 有 效 偵 測 D r i v e r- h i d d e n  R o o t k i t s  偵 測 軟 體 ， 可 提 供 相 關
R o o t k i t 偵 測 軟 體 研 發 廠 商 及 時 更 新 其 偵 測 能 力 。  
( 3 )  具 有 能 標 示 出 未 知 型 隱 藏 的 R o o t k i t s， 並 將 其 從 作 業 系 統 中 卸 載 ，
以 徹 底 去 除 其 潛 在 的 破 壞 。  
( 4 )  經 由 研 製 比 市 面 上 更 強 的 偵 測 機 制，期 望 能 提 供 軍 方 用 以 保 護 其 重
要 情 報 免 於 遭 受 竊 取 。  
 
附 件 一  
 - 72 - 
 （ 英 文 ）  
Most sophisticated kernel mode rootkits are implemented to 
execute hiding tasks through drivers in Windows Kernel. Therefore, 
the role of a detector for detecting Windows driver-hidden rootkits is 
becoming extremely important. In the project of 
TWISC@NCKU(III) in 2008, we have developed a new Windows 
driver-hidden rootkit with five tricks based on Direct Kernel Object 
Manipulation, and have verified on the Testbed@TWISC platform 
that it can successfully avoid a variety of well-known rootkit 
detectors. Thus, in this project we then propose a countermeasure to 
effectively detect Windows driver-hidden rootkits, which can also 
unload the detected rootkits effectively. After the proposed detecting 
scheme has been developed, we also test it on the Testbed@TWISC 
platform by Windows 2000, Windows XP SP0, Windows XP SP2 
and Windows XP SP3, respectively. We affirm our efforts will be 
extremely useful for improving the current techniques of detecting 
Windows driver-hidden rootkits. 
產業別  
資訊服務業、研究發展服務業 
技術/產品應用範圍 
本計畫所發展之 Windows 核心模式 Rootkits 高偵測技術，非
常適合用於政府單位與各民營企業，來提供其資訊系統使用者的
安全，更可以提供防毒軟體業者及時更新其偵測能力，當然亦能
在此基礎之上開發更具安全性之相關加值應用與服務，以進一步
為廣大電腦系統使用者提供一個更具信賴的 Windows 作業系統
使用環境。 
技術移轉可行性及
預期效益 
(1) 辨識出目前 Windows Rootkits 偵測軟體之弱點，可激勵
Rootkit 偵測軟體研發廠商須時時檢測其功能，以有效保障廣
大使用者電腦系統安全。 
(2) 提出新型有效偵測 Driver-hidden Rootkits 偵測軟體，可提供
相關 Rootkit 偵測軟體研發廠商及時更新其偵測能力。 
(3) 具有能標示出未知型隱藏的 Rootkits，並將其從作業系統中
卸載，以徹底去除潛在的破壞。 
(4) 經由研製比市面上更強的偵測機制，期望能提供軍方用以保
護其重要情報免於遭受竊取。 
 
2 
to Understand and Enable Networks (by Dr. Noshir Contractor, the Jane S. & William J. White 
Professor of Behavioral Sciences in the McCormick School of Engineering & Applied Science, the 
School of Communication and the Kellogg School of Management at Northwestern University, 
USA), and Kith and Kin: How Social Networks Make Us Smart (by Dr. Alex (Sandy) Pentland, 
Toshiba Professor of Media, Arts, and Sciences, Massachusetts Institute of Technology, USA)。從 8
月 20 日至 8 月 22 日共舉辦 21 場論文發表，發表的論文數有 103 篇，為大會從 412 篇投稿
論文中嚴格審核所挑選出來的。本人此次分別作論文『Exploring Rootkit Detectors’ 
Vulnerabilities Using a New Windows Hidden Driver Based Rootkit』(本場次於 8 月 21 日 09:00
至 11:30 舉行)、『Mobile Malware Behavioral Analysis and Preventive Strategy Using Ontology』 
(本場次於 8 月 21 日 13:00 至 15:30 舉行)與『A Secure Smart-card-based Password Authenticated 
Key Agreement Scheme in Multi-server Environments』 (本場次於 8 月 21 日 16:00 至 18:30 舉
行)之發表。各場次聽眾頗多，發言詢問非常踴躍。本人論文亦引起在座與會學者的關注，紛
紛提出問題詢問相關理論推導與實務應用上之可行性，令我深感獲益良多，不虛此行。於會
議期間，亦至其它多場與個人研究興趣相關之會場聆聽其他學者之研究成果，並對其發表內
容提出詢問，以交換彼此研究的心得，藉以增廣見聞，激發研究之靈感。除會議發表時間外，
在其他交流活動時，本人與國際/國內學者互動甚佳，因此瞭解頗多國際與國內在資訊科技與
資訊安全方面之研究趨勢，此亦是這次參加會議的重大收穫之一。 
二、與會心得 
     此次會議每篇論文之發表時間約為 25 分鐘， 感覺上時間尚充裕， 約略可描述出論文
之核心所在。此會議涵蓋 Information Privacy, Security, Risk and Trust 之相關主題， 每一主題
4 
此舉除了可提升教師本身研究能力，亦可增加台灣學術研究之國際知名度，但也希望在經費
補助方面能再寬裕一點。例如，本次會議地點是美國明尼蘇達州著名之雙子城大都會，旅館
住宿與膳食費用皆頗為昂貴，因此建議國科會能考量修訂生活費補助金額。 
四、攜回資料名稱及內容 
參與此次會議共攜回 The 2010 IEEE International Conference on Information Privacy, 
Security, Risk and Trust (PASSAT2010) / The 2010 IEEE International Conference on Social 
Computing (SocialCom2010)議程與論文集，包含了亞太、歐、美等國家之作者所發表之論文。 
其探討內容涵蓋 Information Privacy, Security, Risk and Trust 與 Social Computing 等相關主
題，包括  
• Privacy Foundations  
• Privacy Enhancing Technologies  
• Privacy-Preserving Computing  
• Privacy Policies and Laws  
• Economics of Privacy  
• Privacy Theory and Engineering  
• Natural Disasters and Emergencies, and Terrorism Protection  
• Risk Analysis, Modeling, and Management  
• Trust Formalization and Modeling  
• Trustworthy Computing  
• Trust Management  
• Trust Evaluation  
• Security Foundations  
• Network and Communication Security  
Exploring Rootkit Detectors’ Vulnerabilities Using a New Windows Hidden Driver 
Based Rootkit  
Woei-Jiunn Tsaur   
Department of Information Management  
Da-Yeh University  
Changhua, Taiwan, R.O.C. 
e-mail: wjtsaur@yahoo.com.tw  
Yuh-Chen Chen  
Department of Information Management  
Da-Yeh University  
Changhua, Taiwan, R.O.C. 
Abstract—More and more malware writers are taking 
advantage of rootkits to shield their illegal activities. Any 
computer security products that are not equipped with the 
anti-rootkit functionality may not identify this kind of threat. 
Thus, the role of a rootkit detector is becoming extremely 
important. Though much research has been focused on kernel 
data to develop schemes for finding malicious behaviors and 
undoubtedly they can effectively detect hooking based or 
virtual machine based rootkits in Linux or Windows, they 
cannot foresee what the result is when meeting unknown 
Windows DKOM (Direct Kernel Object Manipulation) based 
rootkits. In this paper, we develop a new Windows driver-
hidden rootkit with five tricks based on DKOM, and have 
verified that it can successfully avoid a variety of well-known 
rootkit detectors. This paper spots the weaknesses of current 
detectors, and also discusses possible remedies and solution for 
detecting the proposed subtle rootkit. We expect that this 
research will contribute to the development of rootkit detection 
methods for Windows hidden driver based rootkits. 
Keywords-system security; rootkit; malware; Windows; 
kernel mode  
I. INTRODUCTION
In 2005, Sony-BMG used a rootkit to conceal the digital 
right management [1] software, which is aptly installed in 
consumers’ computers to prevent unauthorized copying. As 
a result, it lets the installed rootkit computers provide 
malware with proper shelters to be capable of escaping anti-
virus detection easily. After this event was exposed by Mark 
Russinovich, RootkitRevealer [2] maker, the term “rootkit” 
drew the great attention of people around the world. 
“Rootkit” represents stealth techniques which can hide 
information about computer resources furtively, and prevent 
itself from being discovered by system administrators. 
Rootkits made its debut at the end of 80’s. Roughly 
speaking, the evolution of rootkits can be divided into four 
phases. In the first phase, a rootkit can alter Unix’s log files 
to hide the presence of certain users. In the second phase, it 
not only alters log files but also replaces some important 
programs such as “ls”, “ps” or “netstat” to hide users’ 
activities. The main drawback of substituting programs is 
that it can be easily found by integrity checking programs 
such as Tripwire [3]. To overcome this drawback, the third 
phase is that rootkits aim to intercept user mode function 
requests and hide desired information in memory. It is not 
necessary to modify or replace files in this phase. In order to 
pursue higher stealth level, rootkits and detectors have 
transferred to the kernel mode in the fourth phase. The 
targeted operating system is also changed from the UNIX 
system to Microsoft Windows system. 
Since Sony-BMG used a rootkit and an opening dedicated 
rootkits forum [4] was created, the topics related to rootkits 
have been widely discussed and many rootkits targeting 
Microsoft Windows have been available. In addition, more 
and more malware writers are integrating rootkits to shield 
their illegal activities [5]-[8]. Any computer security 
products that are not equipped with the anti-rootkit 
functionality may not identify this kind of threat. Thus, the 
role of a rootkit detector is becoming extremely important. 
It can be observed that most of the sophisticated kernel 
mode rootkits are implemented as driver-style programs to 
execute hiding tasks in Windows. Though much research 
[9]-[20] has been focused on kernel data to develop schemes 
for finding malicious behaviors and undoubtedly they can 
effectively detect hooking based or virtual machine based 
rootkits in the Linux or Windows system, they cannot 
foresee what the result is when meeting unknown Windows 
DKOM (Direct Kernel Object Manipulation) based rootkits. 
This paper aims to discuss detective measures to guard these 
avenues of attack by introducing a new set of tricks for 
implementing a driver-hidden rootkit using DKOM in the 
Windows system. As King et al.’s research process [12], in 
this paper we first assume the perspective of the attacker, 
who is trying to run malware and avoid detection. By 
assuming this perspective, we then hope to help defenders 
understand and defend against the threat posed by the 
proposed new type of driver-hidden rootkit.  
To sum up, our contributions are threefold. First, we 
demonstrate the vulnerability of well-known Windows 
rootkit detectors by exploring the design and 
implementation of the proposed driver-hidden rootkit. 
Second, as stated in the literature [2], [21]-[23], rootkit is a 
stealth technology, and the intent with which this 
technology is used determines their malicious or otherwise 
legitimate purpose. The same technology used by rootkits is 
also used in security software such as firewalls and host-
based intrusion prevention systems to extend the protection 
IEEE International Conference on Social Computing / IEEE International Conference on Privacy, Security, Risk and Trust
978-0-7695-4211-9/10 $26.00 © 2010 IEEE
DOI 10.1109/SocialCom.2010.127
842
Our contribution in this section does not highlight how to 
use DKOM to alter objects, but we disclose five places, 
some of which may not be known by anti-rootkit developers, 
to hide driver information. The proposed new Windows 
driver-hidden rootkit is composed of five tricks which will 
be presented in the following Items A-E, respectively. 
A. Removing Object Drivers and Object Devices from 
Object Directory  
In the internal of Windows kernel, the crucial part is 
objects. They contain all kinds of resources that are queried 
by kernel functions. The program of Windows object 
management is responsible to manage objects. All of objects 
are kept in a tree of Object Directory. As shown in Fig. 3, the 
Object Directory is established with 37 HashBuckets. Each 
one points to an Object Directory Entry whose Object 
member refers to an object and ChainLink member points to 
another Object Directory Entry. Most of Object Drivers have 
at least one Object Device pointing to themselves, so Object 
Drivers and Object Devices are needed to consider when a 
driver-hidden rootkit is created. We can explore the whole 
Object Directory to find the desired Object Drivers and 
Object Devices, and then apply DKOM to achieve the 
purpose of hiding. In the following, we first define notations, 
and then the operation process for removing Object Drivers 
and Object Devices from Object Directory is depicted in 
Algorithm 2.  
Figure 3.   Relationship between an Object_Directory and its member. 
Notations definition 
pObjectDirectory :  a pointer to the Object Directory 
Target :  an array storing target drivers’ names to hide 
FindObject() :  a function finding the object. If the object is 
found, the function returns 1; otherwise, it 
returns 0.       
CheckObjectType() :  a function checking the type of a 
given object. If a given object 
belongs to the type of Object 
Driver or Object Device, the 
function returns 1. If it belongs to 
the type of Object Directory, then 
the function returns 2. 
Algorithm 2 
HideMain(pObjectDirectory) 
1  { 
2      for ( i = 0; i<=36; i++ ){     // 37 HashBuckets 
3             pTmp= pObjectDirectory + i*4     
//an address storing an object’s address 
4             j = CheckObjectType(pTmp) 
5             if ( j = = 1 ){ 
6                HideDriver(pTmp)       
7             } 
8                else if( j = = 2 ){ 
9                   HideMain(pTmp) 
10               } 
11            if (Target -> ChainLink = = Null){ 
12                   exit 
13            } 
14               else{  
15                   pTmp = pTmp ->ChainLink 
16               } 
17      } 
18  } 
ʳ
HideDriver(pTmp) 
1  { 
2    i = FindObject(pTmp, Target) 
3    if ( i = = 1 ){    
4       ptmp = pTmp -> ChainLink 
5       ptmp1 = ptmp -> ChainLink 
        6       pTmp -> ChainLink = ptmp1 
        7    } 
        8  } 
B. Removing Object Drivers from Driver Object_Type  
Every object has a pointer to an Objec_Type structure 
which defines the common properties of the same kind of 
objects. Each kind of objects has a dedicated Object_Type. 
For example, an Object Device and an Object Driver have 
different Object_Type. The TypeList member of an 
Object_Type maintains a string of Object_Creator_Info 
structures of the same kind of objects. Here the type of 
objects is referred to Object Driver. Fig. 4 shows the 
relationship between an Object Driver and an Object_Type. 
Taking Fig. 4 as an example, we first exploit our loaded 
rootkit driver to get its Object Driver 0, then move to the 
Object_Header of the Object Driver 0 to get the pointer to 
the Object_Type, and finally check its TypeList member to 
find the desired Object Drivers to hide. In the following, we 
first define notations, and then the operation process for 
removing Object Drivers from Driver’s Object_Type is 
described in Algorithm 3. 
844
example, as shown in Fig. 7, if the value stored in the offset 
0x000h of an Object Driver should be 0x04, then we can 
alter it with a random value to accomplish the purpose of 
stealth. 
Figure 7.  Replacing the value of the Type member of an Object Driver 
      with a random one. 
IV. EXPERIMENTAL RESULTS AND DISCUSSION
We have explained the principles of stealth in the 
proposed new Windows driver-hidden rootkit in Section III. 
In the following, we will demonstrate the experimental 
results. First, the experimental procedure is illustrated in Fig. 
8.  
Loading the proposed driver-hidden 
rootkit into the memory
Executing  the well-known  rootkit
detectors
RootkitBusterGMER IceSword
TucanDarkSpyRootkit
Unhooker
Experimental results
Figure 8. Experimental procedure for testing the stealth ability of the 
proposed DKOM-based driver-hidden rootkit. 
The proposed rootkit named hookzw.sys is a driver format, 
composed by Borland TASM5.0. We execute it on Windows 
XP SP2. According to the recommendations of the 
Antirootkit website [30], we find kernel-level detectors 
DarkSpy, GMER, IceSword and Rootkit Unhooker all have a 
rating with five stars. Detectors RootkitBuster [31] and 
Tucan [32], developed by famous Trend Micro and Panda 
respectively, are not rated, but they also possess a driver-
hidden detection capability. Moreover, as stated in the 
literature [16], [18], [19], [21]-[23], we can find DarkSpy, 
GMER, IceSword and Rootkit Unhooker are highly effective 
detectors for identifying DKOM-based systemic threats to 
kernel data. Therefore, in order to effectively test the stealth 
ability of the proposed DKOM-based driver-hidden rootkit, 
we choose the above-mentioned six rootkit detectors. When 
the proposed rootkit is installed but its stealth functionality is 
not invoked, the four detectors DarkSpy, GMER, IceSword 
and Rootkit Unhooker have listed it, respectively; however, 
the two detectors RootkitBuster and Tucan do not provide 
with displaying any driver information. When its stealth 
functionality has been invoked, all of six well-known 
detectors cannot detect the presence of the proposed rootkit.  
In particular, although detectors GMER and Rootkit 
Unhooker can effectively detect the known sophisticated 
DKOM-based FU, FUTo and Unreal rootkits, they are still 
unable to find the proposed DKOM-based rootkit. We 
conclude that the reasons all of the six detectors cannot 
detect it should be the following two points. First, in Section 
III we have introduced the first four tricks to independently 
hide drivers by respectively modifying the List_Entry data 
structures of Object Directory, Object Driver, Object Device 
and PsLoadedModuleList. Some detectors do not completely 
check whether the four List_Entry data structures may be 
modified, and therefore the proposed first four tricks are to 
evade the heuristic based detection method. Second, the 
proposed fifth trick aims to modify targeted Object Driver 
appearance to let it look different as compared to a normal 
one, so that it is no longer a driver format and thus capable of 
escaping driver signature based detectors to achieve the 
purpose of hiding. In summary, in order to avoid both 
heuristic based and signature based detection methods, all of 
the proposed five tricks must be executed. 
V. POSSIBLE REMEDIES AND SOLUTION
In this section, we will discuss possible remedies and 
solution for detecting the proposed new rootkit in order to 
help detector researchers strengthen their techniques against 
such a subtle rootkit. Current rootkits and detectors are 
almost always through drivers in the kernel mode to execute 
their tasks. Thus, such a way is also adopted in the proposed 
solutions for detecting the sophisticated driver-hidden rootkit. 
In Section III, the first four tricks are to independently hide 
drivers by respectively modifying the List_Entry structures 
of Object Directory, Object Driver, Object Device and 
PsLoadedModuleList. If a detector counts on these 
List_Entry structures, it is consequently unable to identify 
our proposed Windows driver-hidden rootkit, because the 
hidden driver has already disappeared from the modified 
doubly linked lists of the List_Entry structures and therefore 
it is impossible for a detector to easily find the hidden driver 
from these List_Entry structures. As Schuster’s research 
process [33], we can search for drivers from Microsoft 
Windows memory dumps. This approach does not depend on 
the List_Entry structures, and is consequently able to resist 
the attack of DKOM modification to provide trusted 
information. Therefore, we can be based on such an idea to 
get reliable information about drivers. In order to detect the 
proposed new rootkit, we can employ the cross view based 
846
[24] NT Rootkit, 
http://www.rootkit.com/board_project_fused.php?did=proj11, 2010. 
[25] C. Keong, “Defeating kernel native API hookers by direct service 
dispatch table restoration,” Technical Report, SIG2 G-TEC Lab, 2004. 
[26] G. Hunt and D. Brubacker, “Detours: binary interception of Win32 
functions,” in Proc. the Third USENIX Windows NT Symposium, pp. 
135-143, 1999. 
[27] VICE, http://www.rootkit.com/board_project_fused.php?did=proj20, 
2010. 
[28] P. Beaucamps, “Advanced polymorphic techniques,” International 
Journal of Computer Science, vol. 2, no. 3, pp. 194-205, 2007. 
[29] J. Bulter, J. L. Undercoffer and J. Pinkston, “Hidden process: the 
implication for intrusion detection,” in Proc. the IEEE International 
Workshop on Information Assurance, pp. 116-121, 2003. 
[30] Antirootkit, http://www.antirootkit.com, 2010. 
[31] RootkitBuster, http://www.trendmicro.com/, 2010. 
[32] Tucan, http://www.pandasecurity.com/, 2010. 
[33] A. Schuster, “Searching for processes and threads in Microsoft 
Windows memory dumps,” Digital Investigation: The International 
Journal of Digital Forensics & Incident Response, vol. 3, no.1, pp. 
10-16, 2006. 
848
outdated, its effectiveness will diminish. Lastly, a mobile 
device is highly mobile and always has a greater degree of 
difficulty in quarantining the malware in a local region. 
In this paper, we propose an ontology-based behavioral 
analysis for mobile malware, and further provide 
information about mobile malware for end users to help 
them use their mobile phones securely. Ontology theory is a 
research methodology which gives us the design rationale of 
a knowledge base, kernel conceptualization of the world of 
interest, semantic constraints of concepts together with 
sophisticated theories and technologies enabling 
accumulation of knowledge which is dispensable for 
knowledge processing in the real world [6]-[9]. Furthermore, 
ontology also provides a mechanism to allow inference on 
the data, such that an inference engine, in combination with 
rules, can derive new facts and conclusions implicitly 
represented in the data [10], [11]. Thus, ontology theory is 
very suitable for supporting the behavioral description and 
the knowledge management of mobile malware.  
The rest of the paper is organized as follows. Section II 
reviews related works and lists major technologies and 
methodologies for mobile malware detection in mobile 
environments. The process of mobile malware’ ontology 
knowledge representation is described in Section III. In 
Section IV, the mobile malware preventive strategy is 
discussed. Finally, some concluding remarks are given in 
Section V.  
II. RELATED WORK
Internet worms and computer viruses have been plaguing 
computer environment for many years and led to the 
widespread investigation of malware propagation on the 
Internet. Traditionally, the detection of malware is handled 
by anti-malware software. The most commonly-used 
technique for malware mitigation is signature-based methods. 
Typically, a signature-based method is picked to illustrate 
the distinct properties of a specific malicious executable. A 
unique detection signature is extracted by an expert in the 
field or using static information and a code value for each 
malware program so that future examples of it can be 
correctly classified with a small error rate. Therefore, this 
type of detected method must rely on a signature database to 
analyze each malware. In other words, signature-based 
detection cannot detect an attack from unknown malware or 
its variant [12], [13]. Protection from unknown malware is 
the major issue of the day in computer virology. The anti-
malware community relies heavily on known signatures to 
detect malicious programs but all efforts still have not solved 
the key problem until behavior based method appeared. The 
behavioral detection method is based on an in-depth 
understanding of malware’ nature, characteristics, and 
dynamic behavior. The runtime behavior of an application is 
monitored and compared against malicious and normal 
behavior profiles. Behavioral detection is more resilient to 
polymorphic worms and code obfuscation, because it 
assesses the effects of an application based on more than just 
specific payload signatures. Moreover, behavioral detection 
has potential for detecting new virus and zero-day worms 
[14], because new virus are often constructed by adding new 
behaviors to existing malware or replacing the obsolete 
modules with fresh ones, indicating that they share similar 
behavior patterns with existing malware [12]. In addition, 
Signature-based detection methods are not efficient for 
resource-limited mobile devices because they must check if 
each derived signature of an application matches in the virus 
database. Moreover, due to the high mobility of devices and 
the relatively closed nature of cellular networks, constructing 
network signature of mobile malware is very difficult. Thus a 
lightweight and novel detection method is required.
There have been recent studies to model propagation of 
such malware in cellular and ad-hoc networks. Most 
previous works of mobile malware propagation are focused 
on Bluetooth worms. Generic worm propagation model is 
based on behavioral signatures that describe aspects of any 
particular worm’s behavior such as sending similar data from 
one machine to another, the propagation pattern, and the 
change of a server into a client [15]. Khayam and Radha [16] 
developed a topologically-aware worm propagation model 
for stationary wireless sensor networks. They incorporate 
MAC layer interference into this model by specifying a 
constant infection rate when a worm spreads itself onto its 
neighbors. Mickens and Noble [17] observed that traditional 
epidemic models fail to characterize worm propagation in 
mobile networks, so they modified traditional analytic 
models to create a probabilistic queuing technique that 
accounted for movement and traffic patterns over various 
time durations. Zheng et al. [18] focused on modeling 
population distribution density, Bluetooth radius, and node 
velocity. Statistical Monitoring observed that the logical 
ordering of an application’s actions over time. Cheng et al. 
[19] presented SmartSiren, a collaborative virus detection 
and alert system for smart-phones. In order to detect viruses, 
SmartSiren collects the communication activity information 
from the smart-phones, and performs joint analysis to detect 
both single-device and system-wide abnormal behaviors. 
Taejoon and Shin [20] proposed a File system Monitoring 
method that can be monitored by checking file integrity, file 
attributes, or file access attempts. In checking for file 
integrity, the agent yields messages digests or cryptographic 
checksums for critical files, compare them against reference 
values, and verified their differences. Power-monitoring 
malware-detection framework that monitors detects and 
analyzes previously unknown energy-depletion threats. Kim 
et al. [21] characterize power consumption patterns of events 
and designed two important system components to perform a 
comprehensive analysis of the detection accuracy for 
pinpointing the identify of events, as well as classifying them 
as malicious or normal. SMS/MMS and Bluetooth 
vulnerabilities analysis identified the vulnerabilities in 
Bluetooth and SMS/MMS messaging systems that may be 
exploited by future mobile malware. By analyzing existing 
mobile malware to extract a set of their common behavior 
vector can be used to develop mobile malware detection and 
containment algorithm. Bose and Shin [22] investigated the 
propagation of mobile worms and viruses that spread 
primarily via SMS/MMS messages and Bluetooth. First, they 
1081
TABLE III. EXTRACTED FEATURES FROM THE MOBILE MALWARE 
BEHAVIORS
Features Content 
Attachment file Including pictures, jokes, executable files, 
etc. 
Embedded URL ActiveX controls URL 
Embedded Script JavaScript and VBScript 
Download files Download dangerous files 
Install application 
software 
Install danger software, ex. games, 
screensavers 
Execute file type exe, vbs, scr, pif, bat, chm, com… 
Varying file 
extension 
The extension of file is varying and 
questionable 
B. Ontology Building  
The capability of ontology can represent the knowledge 
and relationship of the specific domain. To find out the 
dynamic malicious patterns, we build ontology to represent 
the behaviors of mobile malware. We are based on the steps 
and strategies of the TOVE Enterprise Modeling method [29] 
to build the ontology of mobile malware behaviors as 
follows. 
Motivating scenario. In recent years, due to the 
advantage of smart phone that is becoming more popular. 
However, the number of malware targeting mobile phones 
soared from one to more than 300, in past three years. 
Mobile malware may result in loss of confidential 
information, excess services fees, and battery draining. Since 
the knowledge presentation capability of ontology, this paper 
aims to explore the various behavioral characters and 
construct an ontology of mobile malware. We find out the 
unalterable characteristics through analyzing. 
Informal competency. We described the domain 
application and competency question of an ontology based 
on motivation scenario. In the future applications, ontology 
must be able to answer the questions which follow the 
principles of the design phase of several questions. 
Competency questions were shown as following: 
CQ1: How to identify the type of mobile malware 
CQ2: How to describe behaviors of the mobile malware  
CQ3: How to identify the infection routes of mobile malware  
CQ4: How to identify the attacks pattern of mobile malware  
CQ5: How to identify the spreading ways of mobile malware  
CQ6: How to identify the damage type of mobile malware 
Terminology. In this step, we defined the terminology of 
mobile malwares’ ontology. This study divided the behavior 
of mobile malwares into four hierarchies: infection routes, 
attack patterns, damage types, spreading ways. 
Formal competency questions and axioms. These two 
steps are the application of the phrases for the terminology, 
and transfer informal competency questions to formal 
competency questions. However, when the phrases can not 
to represent the deeper relationships, axioms must be used to 
establish the norms. This study builds the ontology of mobile 
malware through behavior analysis. We describe informal 
competency question, solving strategies and design the 
axioms to infer, make ontology can be adapted in mobile 
malware detection. 
Completeness theorems. The competency question is 
adapted to verify the soundness of ontology in the final step. 
Here, the tool Protégé 4.0 [31] developed by Stanford 
University for knowledge acquisition is used to create 
ontology for mobile malware and make a technical judgment. 
By adopting these steps above, the mobile malware’ 
ontology is shown in Fig. 1. 
IV. MOBILE MALWARE PREVENTIVE STRATEGY
We have developed a mobile malware behavioral 
ontology that describes many attributes, analytical 
characterization and relationships between these behaviors of 
mobile malware. By the capability of ontology knowledge 
management and presentation, a checklist of diagnoses, as 
shown in Table 4, can be used for end users in the prevention 
of mobile malware. Note that, a new mobile malware may 
defeat this checklist by simply generating a rule that would 
be opposite to the checklist rules in Table IV. Thus, users 
should always keep a newly updated checklist in the long run. 
Figure 1. The ontology of the mobile malware behaviors. 
1083
[5] Yury, “Mobile threats – myth or reality,” Kaspersky Lab’s Report on 
Mobile Viruses. Nov. 2006. Available online at 
http://www.viruslist.com/en/weblog?weblogid=204924390 , 2010.  
[6] O. Corcho, M. Fernández-López, and A. Gómez-Pérez, 
“Methodologies, tools and languages for building ontologies: where 
is their meeting point,” Data Knowledge Engineering, vol. 46, no. 1, 
pp. 41-64, 2003. 
[7] K. A. Dahlgren, “Linguistic ontology,” International Journal of 
Human-Computer Studies vol. 43, pp. 809-818, 1995. 
[8] Z. Kedad and E. Metais, “Dealing with semantic heterogeneity during 
data integration,” in Proc. 18th International Conference Conceptual 
Modeling, pp. 325-339, Nov. 1999.  
[9] D. B. Lenat, “CYC: a large-scale investment in knowledge 
infrastructure,” Communications of the ACM, vol. 38, no. 11, pp. 33-
38, 1995. 
[10] A. Bernaras, I. Laresgoiti, and J. Corera, “Building and reusing 
ontologies for electrical network applications,” in Proc. the European 
Conference on Artificial Intelligence (ECAI'96), pp. 298-302, 
Budapest, Hungary, 1996. 
[11] D. B. Lenat and R.V. Guha, Building Large Knowledge-Based 
Systems: Representation and Inference in the Cyc Project, Addison-
Wesley Pub, Boston, Jan. 1990. 
[12] M. Christodorescu, S. Jha, S.A. Seshia, D. Song, and R.E. Bryant, 
“Semantics-aware malware detection,” in Proc. the IEEE Symposium 
on Security and Privacy, Oakland, California, pp. 32-46, May 2005. 
[13] J. A. Morales, P. J. Clarke, Y. Deng, and B. M. Golam Kibria, 
“Testing and evaluating virus detectors for handheld devices”, 
Journal in Computer Virology, vol. 2, no. 2, pp. 135-147, 2006. 
[14] K. Wang, G. Cretu, and S. J. Stolfo, “Anomalous payload-based 
worm detection and signature generation,” in Proc. the 8th 
International Symposium of Recent Advances in Intrusion Detection 
(RAID 2005), pp. 227-246, Sep. 2005. 
[15] D. R. Ellis, J. G. Aiken, K. S. Attwood, and S. D. Tenaglia, “A 
behavioral approach to worm detection,” in Proc. the 2004 ACM 
Workshop on Rapid Malcode (WORM), pp. 43-53, 2004. 
[16] S. A. Khayam and H. Radha, “A topologically-aware worm 
propagation model for wireless sensor networks,” in Proc. 25th IEEE 
International Conference Distributed Computing Systems Workshops, 
pp. 210-216, June 2005. 
[17] J. W. Mickens and B. D. Noble, “Modeling epidemic spreading in 
mobile environments,” in Proc. the 4th ACM Workshop on Wireless 
Security, pp. 77-86, Sep. 2005. 
[18] H. Zheng, D. Li, and Z. Gao, “An epidemic model of mobile  
phone virus,” in Proc. the 2006 1st International Symposium on 
Pervasive Computing and Applications, pp. 1-5, 2006. 
[19] J. Cheng, S. Wong, H. Yang, and S. Lu. “Smartsiren: virus detection 
and alert for smartphones”, In Proceeding of the 5th ACM
International conference on Mobile systems, applications, and 
services, San Juan, Puerto Rico, pp. 258-271, 2007.  
[20] P. Taejoon and K. G. Shin, “Soft tamper-proofing via program 
integrity verification in wireless sensor networks,” IEEE Transactions 
on Mobile Computing, vol. 4 no. 3 pp. 297-309, 2005.  
[21] H. Kim, J. Smith, and K. G. Shin, “Detecting energy-greedy 
anomalies and mobile malware variants,” in Proc. the 6th ACM 
International Conference on Mobile Systems, Applications, and 
Services, pp. 239-252, 2008. 
[22] A. Bose and K. G. Shin, “On mobile viruses exploiting messaging 
and bluetooth services,” in Proc. the 2th IEEE International 
Conference on Security and Privacy in Communication Networks, pp. 
1-10, 2006. 
[23] E. V. Ruitenbeek, T. Courtney, W. H. Sanders, and F. Stevens, 
“Quantifying the effectiveness of mobile phone virus response 
mechanisms,” in Proc. the 37th Annual IEEE/IFIP International 
Conference on Dependable Systems and Networks, pp. 790-800. June 
2007. 
[24] A. Bose, Xin Hu, K. G. Shin, and Tajoon Park, “Behavioral detection 
of malware on mobile handsets,” in Proc. the 6th ACM international 
conference on Mobile systems, applications, and services, 
Breckenridge, CO, USA, pp. 225-238, 2008. 
[25] A. Schmidt, F. Peters, F. Lamour, C. Scheel, S. A. Camtepe, and S. 
Albayrak, “Monitoring smartphones for anomaly detection,” Mobile 
Networks and Applications, vol. 14, no. 1, pp. 92-106, 2009. 
[26] Trend Micro, “Network viruswall outbreak prevention appliance,” 
2004. Available online at http://www.trendmicro.com, 2010. 
[27] J. Flinn and M. Satyanarayanan, “Powerscope: a tool for profiling the 
energy usage of mobile applications,” in Proc. Second IEEE 
Workshop on Mobile Computing Systems and Applications, pp. 1-9, 
New Orleans, Louisiana, Feb. 1999. 
[28] Cisco, “Cisco network admission control,” 2003. Available: 
http://www.cisco.com, 2010. 
[29] M. Gruninger and M.S. Fox, “Methodology for the design and 
evaluation of ontologies,” in Proc. the Workshop on Basic 
Ontological Issues in Knowledge Sharing, pp. 1-10, Montreal, April 
1995. 
[30] D. H. Shih, B. Lin, H. S. Chiang, and M. H. Shih, “Security aspects 
of mobile phone virus: a critical survey,” Industrial Management and 
Data Systems, vol. 108, no. 4, pp. 478-494, 2008.  
[31] Protégé 4.0, Available online at http://protege.stanford.edu/, 2010. 
1085
server can easily delete his/her account based on the scheme 
of service period management. Thus, in this paper we also 
further develop the scheme of service period management for 
password authenticated key agreement in multi-server 
environments. 
The rest of this paper is organized as follows. In Section II, 
our secure and convenient password authenticated key 
agreement scheme in multi-server environments is proposed. 
The security analysis is described in Section III. In Section 
IV, some features of our proposed scheme are discussed. 
Finally, some concluding remarks are included in the last 
section.  
II. THE PROPOSED SCHEME
In the proposed scheme, not only the man-in-the-middle 
attack is eliminated but also the service period management 
is added, as compared with the previously proposed schemes 
[15]-[19]. Two phases are involved in our proposed scheme: 
the registration phase and the log-in and session key 
agreement phase. Here, Ek(m) means that plaintext m is 
encrypted using the secret key k of some secure symmetric 
cryptosystem, Dk(c) means that ciphertext c is decrypted 
using the secret key k of the corresponding symmetric 
cryptosystem, У denotes the bitwise exclusive-or operator, 
and || denotes the concatenation operator. Moreover, let x be 
the secret key kept secretly by the registration center (RC). 
RC computes the key wj = h(x, SIDj) shared between it and 
the jth server Sj, where SIDj is the jth server’s identity and h(.) 
is a one-way and collision-free hash function. Then RC sends 
wj to Sj via a secure channel. These two phases are further 
illustrated below. 
A.   Registration Phase
Suppose that user Ui can get service granted only from S = 
{S1, S2, ..., Sr}, and the service periods of these servers S1, 
S2, ..., and Sr for Ui are E_Ti1, E_Ti2, ..., and E_Tir, 
respectively. Ui first chooses his/her identity UIDi and 
password PWi, and then sends them to RC for registration via 
a secure channel. After verifying the qualification, RC will 
perform the following steps: 
Step 1: Compute Ui’s secret information vi = h(x+1, UIDi) 
and ȝi = vi У PWi. 
Step 2: Compute the secret key vij = h(vi, SIDj) shared 
between Ui and Sj for all Sj ∈ S. 
Step 3: Calculate )(
_ ijTEwij vEA ijj ⊕= for all Sj ∈ S. 
Step 4: Store UIDi, ȝi, E_Tij and Aij to the memory of a 
smart card and issue this smart card to Ui. 
B.   Log-in and Session Key Agreement Phase
When the registered user Ui wants to log in the server Sj, 
he/she first inserts his/her own smart card to a card reader, 
and then keys in his/her password PWi. The following steps 
are the kth log-in with respect to this smart card. 
Step 1: The smart card first computes vi = ȝi У PWi and vij
= h(vi, SIDj). Then it chooses a kth random value 
ruk and calculates Evij(ruk, h(UIDi)). A message  
              Mij = {E_Tij, Aij, UIDi, Evij(ruk, h(UIDi))} 
             is constructed and will be transmitted to the server  
Sj. 
Step 2: After receiving the authentication message Mij, Sj
validates the format of UIDi and gets vij by 
computing )(
_ ijTEw AD ijj ⊕ . By employing vij to 
decrypt Evij(ruk, h(UIDi)), Sj then obtains ruk and 
h(UIDi). Sj will reject this log-in if the 
authentication tag h(UIDi) is not valid; 
additionally, the service period E_Tij is further 
checked to see if the service period has expired. If 
not, Sj chooses the kth random value rsk, and 
calculates the kth session key skk = h(rsk, ruk, vij). 
Then it sends ),( TrsE kvij to Ui, where T is a 
timestamp chosen by Sj.  
Step 3: Upon receiving the message ),( TrsE kvij , Ui’s smart 
card decrypts the message by computing 
Dvij(Evij(rsk, T)). And it then computes the kth 
session key skk = h(rsk, ruk, vij) and the 
ciphertext ),( ksk skTE k , and sends ),( ksk skTE k to
Sj. 
Step 4: After receiving the message ),( ksk skTE k , Sj
decrypts it with the session key skk, and then 
checks whether tnow is too much later than the 
timestamp T by examining if tnow – T > ǻT, where 
tnow represents Sj’s current date and time, and ǻT
is the endurable transmission delay from Sj to Ui, 
then back to Sj. If not, Sj further checks the session 
key skk derived from decrypting the 
message ),( ksk skTE k for correctness. If the 
session key is correct, both Ui and Sj can use the 
session key skk for securing a subsequent 
communication. 
III. SECURITY ANALYSIS
Prior to demonstration of security, some assumptions of 
security are given. 
Assumption 1. A user’s identity and password are securely 
sent to RC in the registration phase. In 
general, it is assumed that there is a secure 
channel between each user and RC in the 
registration phase. In fact, users can also 
directly go to RC for registration, or apply 
1000
TABLE  I.         COMPARISONS AMONG OUR PROPOSED SCHEME AND OTHER PREVIOUSLY PROPOSED SCHEMES
Comparative items Proposed 
scheme 
Juang [15] Li et al. 
[16] 
Lin et al. 
[17] 
Tsaur et al. 
[18] 
Tsaur et al. 
[19] 
No verification table Yes Yes Yes Yes Yes Yes 
Freely chosen password Yes Yes Yes Yes Yes Yes 
Computation cost Low Low High High High High 
Mutual authentication Yes Yes No No No No 
Service period management Yes No No Yes Yes Yes 
Session key agreement Yes Yes No No No No 
Single registration Yes Yes Yes Yes Yes Yes 
No time synchronization 
problem 
Yes Yes No No No No 
Prevention of  man-in-the-
middle attack 
Yes No Yes Yes Yes Yes 
Proposition 5. The proposed scheme can withstand the 
attack of known session key. 
Proof: 
Assume that a session key skk = h(rsk, ruk, vij) is known by 
an attacker, and he/she will try to derive the lth session key 
skl = h(rsl, rul, vij). However, rsl and rul are random numbers 
which are different in every session. In addition, vij is a 
secret key shared between user Ui and server Sj, and thus an 
attacker cannot know it. Hence, our proposed scheme can 
withstand the attack of known session key. 
IV. DISCUSSION
In this section, several features of our proposed scheme 
are discussed as follows: 
1. In Step 2 of the log-in and session key agreement phase, 
server Sj sends the message ),( TrsE kvij  to user Ui, 
where T is a timestamp chosen by Sj. On the other hand, 
Sj will derive this timestamp T from the 
message ),( ksk skTE k received from Ui in Step 3 of the 
log-in and session key agreement phase. The timestamp 
T is verified by Sj who created T. Therefore, our 
proposed scheme does not have the time 
synchronization problem. 
2. In Juang’s scheme [15], when server Sj wants to derive 
the secret key vij shared by user Ui, it should maintain a 
verification table or request to RC to obtain this key. In 
order to maintain the verification table, the load is 
absolutely heavy for a server when the number of users 
is increasing. Moreover, in general remote password 
authentication schemes, RC is only responsible for user 
registration. The server which always requests to RC to 
derive each session key shared by users will cause a 
bottleneck of RC operations. In our proposed scheme, 
the secret key vij is contained in the parameter Aij which 
will be sent to server Sj in the user log-in phase. Hence, 
Sj can derive vij only from Aij and the correct service 
period E_Tij. 
3. The comparisons among our proposed scheme and 
other previously proposed schemes are shown in Table 
I. Unlike the other schemes [16]-[19] employing public 
key cryptosystems to develop remote password 
authentication scheme, our proposed scheme and 
Juang’s scheme [15] are to adopt the hash function, 
exclusive-or operation and symmetric cryptosystem, so 
the computation cost is low. From Table I, it is obvious 
that our proposed scheme is superior to the others in 
accordance with all of essential comparative items.
V. CONCLUSION
A secure and convenient remote password authentication 
scheme with key agreement is proposed in this paper.  Our 
proposed scheme can satisfy all of the requirements needed 
for achieving secure password authentication in multi-server 
environments, as compared with the previously proposed 
schemes. Besides, in our proposed scheme, the man-in-the-
1002
國科會補助計畫衍生研發成果推廣資料表
日期:2010/12/31
國科會補助計畫
計畫名稱: Windows 核心模式Rootkits之高偵測技術研究
計畫主持人: 曹偉駿
計畫編號: 98-2219-E-212-001- 學門領域: 網路通訊國家型計畫 
研發成果名稱
(中文) Windows 核心模式Rootkits之高偵測技術
(英文) Highly Effective Technology for Detecting Windows Kernel Mode Rootkits
成果歸屬機構
大葉大學 發明人
(創作人)
曹偉駿,蔡秉諭
技術說明
(中文) 有越來越多惡意程式結合Rootkit技術來遮掩本身的不法行為，使得系統安全的
防衛面臨了極大的挑戰。我們發現先進的Rootkit技術都屬於核心模式，並且絕
大部份都是以“驅動程式”的形態被載入到Windows作業系統核心中。為了能躲
避偵測軟體進行偵測，Rootkit技術勢必具備能將其本身驅動程式給隱藏起來的
功能。因此，對系統安全來說，能偵測以驅動程式型態隱藏的Rootkit是相當重
要的。我們於民國97年期間曾參與TWISC@NCKU(III)研究團隊，並負責研製出基
於DKOM(Direct Kernel Object Manipulation)技術專門用於隱藏驅動程式的
Rootkit，且在Testbed@TWISC平台實測後確實能躲過各種知名的偵測軟體，因此
本計畫進一步開發新型有效偵測Driver-hidden Rootkits之機制，並使其具備能
將所偵測到的Rootkits從作業系統中進行卸載(Unload)，以徹底去除其潛在的破
壞。本偵測軟體開發完成後，亦於Testbed@TWISC平台上針對Windows 
2000、Windows XP SP0、Windows XP SP2、 Windows XP SP3四種作業系統進行
實測其偵測功能。我們相信本計畫所提出之偵測方法，應能激勵並提供相關研發
Rootkit偵測軟體之廠商以改善其目前有關偵測Windows Driver-hidden 
Rootkits的能力。
(英文) Most sophisticated kernel mode rootkits are implemented to execute hiding tasks through 
drivers in Windows Kernel. Therefore, the role of a detector for detecting Windows 
driver-hidden rootkits is becoming extremely important. In the project of 
TWISC@NCKU(III) in 2008, we have developed a new Windows driver-hidden rootkit 
with five tricks based on Direct Kernel Object Manipulation, and have verified on the 
Testbed@TWISC platform that it can successfully avoid a variety of well-known rootkit 
detectors. Thus, in this project we then propose a countermeasure to effectively detect 
Windows driver-hidden rootkits, which can also unload the detected rootkits effectively. 
After the proposed detecting scheme has been developed, we also test it on the 
Testbed@TWISC platform by Windows 2000, Windows XP SP0, Windows XP SP2 and 
Windows XP SP3, respectively. We affirm our efforts will be extremely useful for 
improving the current techniques of detecting Windows driver-hidden rootkits.
產業別 資訊服務業；研究發展服務業
技術/產品應用範圍
本計畫所發展之Windows 核心模式Rootkits高偵測技術，非常適合用於政府單位與各民
營企業，來提供其資訊系統使用者的安全，更可以提供防毒軟體業者及時更新其偵測能
力，當然亦能在此基礎之上開發更具安全性之相關加值應用與服務，以進一步為廣大電
腦系統使用者提供一個更具信賴的Windows 作業系統使用環境。
技術移轉可行性及
預期效益
(1) 辨識出目前Windows Rootkits偵測軟體之弱點，可激勵Rootkit偵測軟體研發廠商須
時時檢測其功能，以有效保障廣大使用者電腦系統安全。 
(2) 提出新型有效偵測Driver-hidden Rootkits 偵測軟體，可提供相關Rootkit偵測軟
體研發廠商及時更新其偵測能力。 
(3) 具有能標示出未知型隱藏的Rootkits，並將其從作業系統中卸載，以徹底去除其潛
在的破壞。 
(4) 經由研製比市面上更強的偵測機制，期望能提供軍方用以保護其重要情報免於遭受
竊取。 
註：本項研發成果若尚未申請專利，請勿揭露可申請專利之主要內容。
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
促成產學合作: 
  (1) 合作廠商名稱: 達康數位有限公司 
  (2) 合作計畫: 基於誘捕與入侵防禦技術建構高安全無線區域網路系統 
  (3) 合作有效期間: 2010/11/1 ~ 2011/10/30 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
