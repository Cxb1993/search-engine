II 
 
 
目錄	
I.  摘要 ........................................................................................................................................ III 
中文摘要 ................................................................................................................................ III 
英文摘要 ................................................................................................................................ IV 
II.  計畫的緣由與目的 .................................................................................................................. 1 
A.  LDPC Decoder ................................................................................................................. 1 
1.  A 11.5-Gbps LDPC Decoder Based on CP-PEG Code Construction ...................... 1 
2.  A 2.37-Gb/s 284.8mW Rate-Compatible (491,3,6) LDPC-CC Decoder ................. 2 
B.  BCH and RS Decoder ...................................................................................................... 3 
1.  Soft BCH Decoder Chip for DVB-S2 System ......................................................... 3 
2.  An Improved Soft BCH Decoder with One Extra Error Compensation .................. 4 
3.  Soft RS Decoder Chip for Optical Communication System .................................... 5 
C.  Viterbi Decoder ................................................................................................................ 6 
1.  A Low-Power Viterbi Decoder Based on Scarce State Transition and Variable 
Truncation Length ............................................................................................................ 6 
2.  A Low Power Differential Cascode Voltage Switch with Pass Gate Pulsed Latch 
for Viterbi Decoder........................................................................................................... 9 
III.  研究方法及成果 .................................................................................................................... 10 
A.  LDPC Decoder ............................................................................................................... 10 
1.  A 11.5-Gbps LDPC Decoder Based on CP-PEG Code Construction .................... 10 
2.  A 2.37Gb/s 284.8mW Rate-Compatible (491,3,6) LDPC-CC Decoder ................ 18 
B.  BCH and RS Decoder .................................................................................................... 23 
1.  Soft BCH Decoder Chip for DVB-S2 System ....................................................... 23 
2.  An Improved Soft BCH Decoder with One Extra Error Compensation ................ 31 
3.  Soft RS Decoder Chip for Optical Communication System .................................. 39 
C.  Viterbi Decoder .............................................................................................................. 45 
1.  A Low-Power Viterbi Decoder Based on Scarce State Transition and Variable 
Truncation Length .......................................................................................................... 45 
2.  A Low Power Differential Cascode Voltage Switch with Pass Gate Pulsed Latch 
for Viterbi Decoder......................................................................................................... 51 
IV.  結論與討論 ............................................................................................................................ 61 
V.  參考文獻 ................................................................................................................................ 64 
VI.  計畫成果自評 ........................................................................................................................ 68 
VII.  附錄– 2007-2011 本計畫相關之研究成果 .......................................................................... 72 
 
IV 
 
英文摘要 
Signal processing in baseband processor designs plays a key role in wireless communication 
system designs—in not only improving overall system transmission performance, but also 
providing the capability of multi-mode and multi-standard for cost-effective system realization. 
To reach better performance indices in terms of low-cost and low-power, it is necessary to 
investigate system design methodologies, covering in-depth exploration of algorithms of key 
modules and exploitation of unique features/behaviors of a complete system. As a result, a more 
competitive solution can be delivered. In three year (2008/8~2011/7), we have concentrated on 
the key modules (Viterbi decoder, LDPC decoder, BCH decoder and RS decoder) of the 
main-stream OFDM wireless communication systems. The first issue is low power solution for 
Viterbi decoder. The second issue is the high-speed solution for LDPC decoder. The last issue is 
the low-cost solution for soft BCH and RS decoder. In the end, these design techniques and key 
modules will be integrated on a design platform, together with synchronization modules, to come 
up with a multi-mode, multi-standard, and low-power baseband processor. 
 
Keywords 
Baseband Processor, Multi-mode, Multi-Standard, Low-Cost, Low-Power, Viterbi Decoder, 
LDPC Decoder, BCH Decoder, RS Decoder
2 
 
implemented in 90nmtechnology will show its advantages in terms of throughput, energy 
efficiency, and hardware efficiency.  
2. A 2.37-Gb/s 284.8mW Rate-Compatible (491,3,6) LDPC-CC 
Decoder 
Near the rediscover of LDPC-BCs, LDPC-CCs were proposed in 1999 [A-10]. LDPC-CCs 
have the characteristics of convolutional code not found in LDPC-BCs. Continuous encoding 
supports any length of input data stream, which is especially suitable for streaming video and 
packet-switching network. The puncture scheme applied in LDPC-CCs provides flexible 
code-rates by abandoning certain positions of encoded bits according to the puncture table. 
Simple encoder circuitry composed by registers, multiplexers and a few XOR gates has lower 
hardware cost and power consumption, and can be used in distributed sensor network. 
Furthermore, the correlation between codeword symbols of LDPC-CCs is limited to a specific 
interval (constraint length ms+1, ms is the memory size of encoder). This locality property lowers 
the overall routing complexity of the decoder. Although possessing many advantages, LDPC-CCs 
were few chosen by standards. The main reason lies in its bottlenecks of the long decoding 
latency, high power consumption, and low-to-moderate decoding throughput. 
The throughput of LDPC-CC decoders reported in literatures was only several hundred 
Mbps, which is difficult to compete with LDPC-BC decoder with several tens of Gbps 
throughput. Cause of lower throughput can be explained by the decoder structure. LDPC-CC 
decoder consists of serially concatenated processors, and each processor decoding a sliding 
window on the trellis diagram can be taken as one iteration in LDPC-BCs. Increasing processor 
number can enhance error-correcting capability but cannot increase throughput. Therefore many 
works put efforts on realizing the parallel message passing: analysis of parallelization concepts in 
[A-11], single-instruction-multiple-data (SIMD) architecture in [A-12], and joint code-decoder 
design in [A-13]. Recently, a high throughput LDPC-CC decoder design was proposed by adding 
regularity during code construction [A-14]. However, achieving high throughput is still 
challenging for some time-varying LDPC-CC code without regularity. 
4 
 
 
Fig. 2. Simulation results for BCH (255,239) concatenating with a 16-state BCJR under BPSK 
modulation and AWGN channel 
 
2. An Improved Soft BCH Decoder with One Extra Error 
Compensation 
The Bose-Chaudhuri-Hocquenghen (BCH) [B-1] codes are popular in storage and 
communication systems, such as flash device, DMB-T [B-2] and DVB-S2 [B-3] broadcasting 
systems. Recently, soft decoding of BCH codes has aroused many research interests. Forney 
developed the generalized-minimum-distance (GMD) [B-4] to generate a list of candidate 
codewords and choose a most likely codeword from the list. Other algorithms with similar 
concept, such as Chase [B-5] and SEW [B-6], are also widely used in many applications. 
Moreover, Therattil and Thangaraj provided a sub-optimum MAP BCH decoding method with 
Hamming SISO decoder in 2005 [B-12]. 
In general, the complexity of a soft BCH decoder is much higher than a hard BCH decoder 
for decoding an entire codeword. Nevertheless, soft BCH decoders with lower complexity can be 
revealed by focusing on the least reliable bits instead of the whole codeword. A soft BCH 
decoding algorithm using error magnitudes to deal with the least reliable bits was developed in 
1997 [B-7]. However, Fig. 3 shows that there is about 0.25 dB performance loss at BER = 10−5 
in AWGN channel as compared to hard decision BCH decoder for BCH (255,239) code. For the 
existing soft decision algorithms, the soft BCH decoder provides either better error correcting 
6 
 
error-locator polynomial Λ(x) less than error correction capability t. The Gray code based 
bit-flipping method is also exploited leading to only one suit of hardware requirement. 
 
C. Viterbi Decoder 
1. A Low-Power Viterbi Decoder Based on Scarce State Transition and 
Variable Truncation Length 
The Viterbi decoder implementing the Viterbi algorithm [C-1] for decoding convolutional 
codes is composed of three main blocks: the branch metric (BM) unit, the ACS unit, and the 
survivor memory. The BM unit generates branch metrics from the input data. The ACS unit 
recursively accumulates branch metrics as path metrics (PM) and makes decisions to select the 
most likely state transition sequences, or the survivors. Survivor memory stores the survivors 
for retrieving the data sequence. 
There are two well-known survivor memory management approaches: the 
register-exchange (RE) and the trace-back (TB) [C-2]. The register-exchange is conceptually 
the simplest technique that eliminates repeatedly memory access operations. Therefore, this 
approach has shorter latency and is suitable for high speed decoder implementations. However, 
due to the data movement among registers, the approach is considered to be power inefficient. 
Fig. 4 shows the conventional 2υ-state Viterbi decoder with the register-exchange 
architecture [C-3]. The decisions from ACS units will be shifted within the survivor memory 
from left to right.  Applying the scarce state transition (SST) technique and the variable 
truncation length, we illustrate the proposed low-power Viterbi decoder for the MB-OFDM 
UWB system [C-4] in Fig. 5. The SST unit is integrated to reduce state transition activities, 
leading to less dynamic power consumption [C-8]. Furthermore, the path merging detector 
monitors the merged point for all survivors and adjusts the truncation length to avoid 
unnecessary data movement in registers. Many redundant operations in the survivor memory 
can be reduced to save power dissipation. Additionally, considering the high throughout 
8 
 
information o(D). 
The SST Viterbi decoding architecture in Fig. 6 (B) includes two additional blocks: 
pre-decoder and re-encoder. Assume 
r(D) = u(D) G(D) + e(D) = C(D) + e(D)                       ( 1 ) 
and e(D) is the error sequence from a noisy channel, the pre-decoder directly decode the 
information sequence from r(D): 
-1 ˆi(D) = r(D) G (D) = u(D)                               ( 2 ) 
The re-encoder then encodes i(D) to a new codeword z(D). 
ˆz(D) = i(D) G(D) =  C(D)                               ( 3 ) 
The Viterbi decoder performs maximum likelihood decoding on y(D), which is defined as 
follows: 
ˆy(D) = r(D) + z(D) = C(D) + e(D) + C(D)                        ( 4 ) 
In high SNR conditions, e(D) is nearly zero, and the decoded information sequence becomes 
 ˆo(D) = i(D) + n(D) = u(D) + n(D)                          ( 5 ) 
If the channel condition is good enough, the decoder estimates an approximately zero 
sequence; as a result, the dynamic power is reduced as the channel becomes better. 
 
 
Fig. 6. (A) Conventional model (B) SST decoding model 
 
10 
 
III. 研究方法及成果 
A. LDPC Decoder  
1. A 11.5-Gbps LDPC Decoder Based on CP-PEG Code Construction 
 
a) CODE STRUCTURE AND DECODING ALGORITHM 
(1) CP-PEG LDPC Code Construction 
The (2048, 1920) irregular LDPC code, rate-15/6, used in this project was constructed by 
CP-PEG algorithm and shown in Fig. 8(a). The constructed parity-check matrix H consists of p*p 
circulant permutation (CP) and all-zero matrices. A CP matrix is a cyclic square matrix with 
constant row and column weight of one. The number of each CP matrix indicates the cyclic shift 
amount and -1 means all zero matrixes. By setting p=32, there are 4*p check nodes and 64*p 
variable nodes in bipartite graph, where each check node has uniform degree 46, and 16*p, 24*p, 
24*p variable nodes have degrees of 4, 3, 2 respectively. The performance of this code was 
proven to have better performance than other PEG-based LDPC codes [A-7]; nevertheless, the 
high check node degree required suitable decoder architecture to overcome implementation 
difficulties. 
(2) Variable-node centric Sequential Scheduling 
In VSS approach, the initialization, stopping criterion test, and output steps remain the same 
as the standard BP algorithm. The only difference between two algorithms lies in the updating 
procedure. The normalized min-sum (NMS) algorithm which compensates the approximation 
error in check node In VSS approach, the initialization, stopping criterion test, and output steps 
remain the same as the standard BP algorithm. The only difference between two algorithms lies 
in the updating procedure. The normalized min-sum (NMS) algorithm which compensates the 
approximation error in check node is shown and described in the next page. 
In this work, the codeword is divided into G=4 groups, therefore the parity-check matrix H is 
divided into 4 sub-matrices (H1 to H4). As shown in Fig. 8(b), each sub-matrix consists of equal 
12 
 
b) PROPOSED DECODER ARCHITECTURE 
In this section, the complete decoder architecture will be presented, including data path, 
scheduling, and VLSI structure of CNU and modified CNU. 
(1) Single Pipelined Architecture 
The entire decoder depicted in Fig. 9(a) is composed of fully-parallel CNUs and 
partial-parallel VNUs, where the VNU2, VNU3, and VNU4 will handle variable node operations 
with degree 2, 3, and 4 respectively. Let
( )i
g denote the sorted messages sent from variable nodes 
in the g-th group to one specific check node at i-th iteration, which is: 
 
Then the magnitude part of check node to variable node message in (1) could be computed 
by the following equation: 
 
Fig. 9(b) demonstrates the timing diagram of proposed decoder. There are G initialization 
cycles required to calculate 
( )i
g  for 0 ≤ g ≤ G − 1. Since only one subgroup of the message 
( )i
mnz  is updated in g-th cycle of one iteration, the main operation of CNU could be simplified to 
calculate 
( )i
g  (local sorting) in each cycle and then perform global sorting like equation (5). 
From the proposed single pipelined architecture, only messages 
( )i
g  and ( )imn  are stored. The 
sorted results could be represented by min value, second min value, and the index of min value in 
NMS algorithm. Therefore, the proposed decoder only latches two values, one index, and sign 
part of messages in each subgroup, while the variable node to check node message 
( )i
mnz  is 
on-the-fly calculated. The single pipelined architecture is feasible because the CNU could be 
updated immediately after VNU’s operations in VSS approach. 
14 
 
second min from G − 1 subgroups into one group. Some extra control circuits are needed to 
open or close the feedback loop in Fig. 10(b). This sorter architecture is beneficial since the 
complexity reduction of storage registers and global sorters is higher than the overhead of control 
circuits. Section IV will show the performance of this modified CNU is similar to original CNU.  
 
(3) Summary 
In traditional two-stage pipelined architecture, both 
( )i
mnz  and 
( )i
mn  messages are kept in 
registers or memory. Assume the bit-width of messages is w (= 6) and variable node degree is dv, 
then the required memory size (or registers) is as follows: 
 
For the proposed single pipelined decoder and modified CNU in Fig.4 (b), the memory size 
is reduced to 
 
Therefore the overall register reduction of proposed architecture is 73%, leading to the 
following advantages: fewer registers, higher utilization of functional units, and reduced 
complexity. Since high-rate LDPC codes usually have more VNUs than CNUs (in our case: 512 
VNUs and 128 CNUs), the elimination of registers from VNU to CNU not only reduces hardware 
cost but also lowers power consumption of clock tree. 
16 
 
indicates that the test chip with FF corner can achieve 11.5 Gbps throughput under 1.4V supply 
voltage. The throughput could be scaled down to 5.77Gbps with 0.8V supply voltage to meet the 
throughput requirement of IEEE 802.15.3c standard and the energy efficiency will be 0.033 nJ/bit. 
Compared with the state-of-the-art in 
 
Table 1, the proposed LDPC decoder outperforms others in the aspects of throughput, 
hardware efficiency, and power efficiency. Since the LDPC code specifications of these designs 
are different, the SNR loss between each work to their Shannon limit is also listed for reference. 
 
Fig. 11. Performance 
 
d) CONCLUSION 
A high-throughput and power-efficient LDPC decoder is presented. Utilizing the 
characteristic of variable-node-centric sequential scheduling, the proposed decoding algorithm 
could reduce the maximum iteration number without performance loss. In addition, the single 
pipelined architecture and modified CNU can save 73% message storage memory and decrease 
the sorter size, resulting in a low-complexity design. After implementation in 90nm technology, 
the test chip occupies 3.84 mm2 of area and supports maximum 11.5 Gbps data rate under 1.4V 
supply voltage. 
18 
 
2. A 2.37Gb/s 284.8mW Rate-Compatible (491,3,6) LDPC-CC 
Decoder 
a) PROPOSED ALGORITHM AND ARCHITECTURE 
Fig. 15 demonstrates the algorithm-level optimization to accelerate the decoding 
convergence speed by using the on-demand variable node activation (OVA) scheduling technique 
[A-15]. The main idea is to change the variable activation location leaving from the processor to 
the position right before each check node input. The OVA scheduling is similar to the layered 
decoding in LDPC-BCs that check nodes could access the most recent messages. The original 
VNU can be disassembled into several sub-VNU (SVNUs) and distributed within a processor. 
Since the equation of VN-to-CN messages (e.g. n1 and n2 in Fig. 15) has two common terms, we 
may calculate n2 from n1 by deducting m2 (done by pre-SVNU) and adding m1 (done by 
post-SVNU). Therefore, the channel values (i.e. u and v) are concealed in VN-to-CN messages 
and the storage space of channel values can be removed from processors to save 17% memory. 
When the channel values are concealed within the summation values, the bit-width of each 
message should be adjusted to avoid truncation error. In the situation of w-bit channel value, the 
summation values needs (w + 2)-bit. Since the operations of pre-SVNU and post-SVNU are 
independent, they can be retimed such that the messages between them only need (w+1)-bits. 
The original critical path from CNU to post-SVNU is also diminished by one adder delay. 
Fig. 16 is the bit-error-rate (BER) performance of the rate-compatible (491, 3, 6) 
time-varying LDPC-CC proposed in [A-16] under AWGN channel. In contrast to log-BP 
algorithm with 10 processors, the proposed algorithm with 5 processors can achieve similar or 
even better performance in all code-rates. Therefore, only half processors are required under the 
same performance, leading to half decoding latency reduction as well. 
In the original structure of Fig. 14, the LDPC-CC decoder can only decode one bit in one 
cycle, so the information throughput will be fclk Mb/s at fclk MHz clock frequency. To increase 
throughput, the node level optimization duplicates both CNUs and VNUs to ρ (folding factor) 
20 
 
 
Fig. 15. Algorithm level optimization (OVA scheduling with concealing channel values). 
 
 
Fig. 16. BER performance of Log-BP algorithm (floating-point) and our proposed scheduling in     
      Normalized Min-Sum algorithm with scaling factor 0.875 (fixed-point (6,2)) under 
AWGN channel. 
 
b) IMPLEMENTATION RESULTS 
Fabricated in 90nm 1P9M CMOS process, our test chip integrates the OVA scheduling with 
concealed channel values, folding architecture, re-timed SVNU, and hybrid-partitioned FIFOs. 
Key features and performance comparison are given in Table 2. The decoder chip occupies 
22 
 
 
Fig. 18. Chip micrograph. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
24 
 
 
where γci is the error magnitude corresponding to βci for i = 1, 2, . . . , 2t. The left 2t × 2t matrix in 
(2) is defined as β - matrix. From (1) and (2), it is evident that if all the errors are in the location 
set, the exact γci value can be determinated; otherwise, this decoding approach fails to correct 
errors. The error magnitudes solver shown in Fig. 19 is used to solve (2) to get γci. For those γci 
equal to 1, the corresponding Lci are the exact error locations. The codeword polynomial C(x) can 
be obtained by inversing the Lci -th values in the received polynomial R(x). 
 
b) Proposed Algorithm and Architecture 
 
(1) Error Locators Evaluator 
As shown in Fig. 20, error locators evaluator architecture includes the reliability part, the 
error locator part and the error location part. The upper part is the reliability part which stores the 
reliabilities of 2t least reliable candidates Rc1 ,Rc2 , . . . ,Rc2t . The medium part is the error locator 
part to construct the β-vector. Because the β value of the i-th location isαi, the β value of (i+1)-th 
locations isαtimes the β values of i-th location. The β value can be computed by multiplyingα−1 
with register REG if the input is serial in from the highest degree coefficient of R(x). Thus, the 
error locator part can use a constant multiplier to calculate the error locator of each input. Notice 
that register REG initially contains the β value of the first input. The bottom part is the error 
location part. The decoding method focuses on the least reliable bits instead of the whole 
codeword, so the error location part uses a counter to compute the error location Lci 
corresponding to each Rci for serial input. Hence, the Chien search procedure is no longer 
required and a lot of redundant decoding latencies can be eliminated. 
26 
 
(a) Heuristic Error Magnitudes Solver(H-EMS):  
In BCH codes, the valid error magnitude in (2) is either 0 or 1, so the problem can be 
formulated into checking all combinations of γci over GF(2) instead of calculating real error 
magnitudes. A 2t-bit counter is used to do a heuristic search for all binary combinations. Since 
S12 = S2,  S22 = S4, . . . ,  St2 = S2t in BCH codes, the even part of syndromes check can be 
eliminated to simplify (2) as : 
 
 
 
Table 3 
The Proposed Heuristic EMS Algorithm 
 
 
Table 3 illustrates details of the proposed H-EMS algorithm. The i-th bit of CNT, CNTi, 
performs as the i-th error magnitude, γci. Thus, by iteratively flipping each CNTi value, a heuristic 
search for all binary combinations can be completed. At each iteration, the solver can verify 
where the equation (3) stands or not. As shown in Fig. 21, H-EMS uses 2t(t-1) multipliers to 
construct the β-matrix. Each βcij value will be calculated with CNTi, and the solver checks the 
results equal to the syndromes or not. 
28 
 
implementation complexity. After all computations, Si indicates the i-th error magnitude. From 
Table 4, Borck-Pereyra algorithm has division, multiplication and addition operations. Notice that 
the multiplier can be shared if the divider can be decomposed into an inversion and a multiplier. 
Thus, as shown in Fig. 22, BPEMS only contains 1 multiplier, 1 inversion, 3 adders and a control 
logic. The control logic determines the computation order of the syndromes and βci, and the 
computation results will be used to update each Si value. The inversion in the proposed 
architecture is carried out in composite field because the finite field inversion over GF(2m) is 
costly and infeasible with table-lookup implementation for large m. 
 
Fig. 22. Borck-Pereyra Error Magnitudes Solver Architecture 
 
Composite field [B-11] is viewed as an extension field of GF(2k) while given m = kr. The 
finite field GF(2m) can be constructed by coefficients from the subfield GF(2k). Operating in 
subfield leads to lower implementation complexity and better computation efficiency. For 
example, every element in GF(216) can be represented by bx+c and inversion of bx+c can be 
derived as (4) with the polynomial x2 + x +ψ[B-11], where b and c are over GF(28). 
 
The composite field inversion over GF(216) is only 2.1K gate count in CMOS 90nm 
technology while the inversion using Look Up Table method is about 186K gate count. 
30 
 
 
Table 5  
Summary of Implementation Results 
 
 
For BCH (762,752), key equation procedure is not needed due to t = 1. To eliminate Chien 
search, the hard BCH decoder uses look up table method to solve the error location, and the soft 
BCH decoder uses the H-EMS architecture. Calculating all the combination values at one cycle, 
the gate-count of the soft BCH decoder is only 38.8% of the hard BCH decoder under the same 
latency and operation frequency. For BCH (32400, 32208) with t = 12, the hard BCH decoder 
uses iBM algorithm to solve key equation and needs Chien search to get error locations. By 
inserting registers in composite field inversion, the operation frequency of the soft BCH decoder 
with BP-EMS is enhanced from 166MHz to 333MHz with only 2.5% latency increment in 
overall decoding procedure. Computing error locations without Chien search, the soft BCH 
decoder has almost half latencies of the hard BCH decoder. Hence, the soft BCH decoder has 
much better throughputs than the hard BCH decoder. The measurement result reveals that the soft 
BCH decoder saves 50.0% gate-count and 47.4% clock cycle latency as compared with the hard 
BCH decoder. Fig. 25 is the chip microphoto of soft BCH (32400, 32208). 
 
Fig. 25.  Microphoto of Soft BCH(32400,32208) Chip 
 
32 
 
where Γ = [γ1, γ2, . . . , γ2t]T is the error magnitude set corresponding to B, and the 2t × 2t 
matrix in (9) is defined as β-matrix B. Let Δ = [δ1, δ2, . . . , δ2t]T be defined as 
(10) 
From (8) and (9), it is evident that if all the errors are in the error location set, the exact γi 
value can be determinated and Δ will be all zero; otherwise, this decoding approach fails to 
correct errors. There are at most 2t error locations can be determined. However, it is very likely 
that only one error outside L but the decoder can’t solve any error. To improve the error 
correcting ability, we additionally check whether Δ is a geometrical sequence or not to make a 
compensation for an error location outside L. A geometrical sequence Δ = [βlloss, βlloss2, . . . , 
βlloss2t] means an error location loss can be found, where βlloss = αlloss . For example, if there are 
four errors in 1st, 3rd, 5th and 9th locations for a BCH (255,239) decoder which can correct 2 
errors, S is expressed as 
(11) 
In the case that the decoder collects B = [β1, β3, β6, β9], and Γ = [1, 1, 0, 1], Δ becomes 
(12) 
Then not only errors at 1-st, 3-rd and 9-th locations but also an error at 5-th location can be 
corrected. Therefore, the proposed compensation soft BCH decoder can correct at most 2t+1 error. 
The compensation error magnitude solver (CEMS) shown in Fig. 26 is used to solve (9) and (10) 
to get Γ and Δ. For those γi equal to 1, the corresponding li and lloss are the exact error locations. 
The codeword polynomial C(x) can be obtained by inversing values at error locations in the 
received polynomial R(x). 
34 
 
b) VLSI ARCHITECTURE FOR THE COMPENSATION SOFT BCH DECODER 
 
(1) Error Locator Evaluator 
As shown in Fig. 27, error locator evaluator architecture includes the reliability part, the error 
locator part and the error location part. The upper part is the reliability part which stores the 
reliabilities of 2t least reliable candidates Rl1,Rl2, . . .,Rl2t . The medium part is the error locator 
part to construct the error locator set B. Because the error locator of the i-th location is αi, the 
error locator of (i+1)-th locations is α times the error locator of i-th location. The error locator can 
be computed by multiplying α−1 with register REG if the input is serial in from the highest 
degree coefficient of R(x). 
Thus, the error locator part can use a constant multiplier to calculate the error locator of each 
input. Notice that register REG initially contains the error locator of the first input. The bottom 
part is the error location part. The decoding method focuses on the least reliable bits instead of 
the whole codeword, so the error location part uses a counter to compute the error location li 
corresponding to each Rli for serial input. Hence, the Chien search procedure is no longer 
required and a lot of redundant decoding latencies can be eliminated. 
36 
 
initial value of registers in each row is set as B so that the output of the SQUARE will always be 
βli2 for first t-1 cycles. Iteratively multiplied byβli2, the bottom registers generate βli2j+1 for i = 1 
~ 2t and j = 0 ~ t-1. Thus, totally only 2t multipliers are used for Bodd calculation. After t-1 
cycles, Bodd is constructed and the registers will stop update. Matrix multiplication is evaluated 
in the following 22t cycles. By counting Γ value, a heuristic search for all binary combinations 
can be completed. At each iteration, each βlij value will be calculated with γi, and the solver can 
verify whether the geometrical sequence check stands or not. If Δodd is a geometrical sequence, 
then δi × δ12 = δi+2. CEMS uses t multipliers to check the relation and uses a look up table (LUT) 
for looking for lloss from δ1. 
 
Fig. 28. Compensation Error Magnitude Solver Architecture 
 
(3) Architecture Comparison 
The architectures of a hard BCH decoder and the proposed soft BCH decoder are compared 
in Table 6. In finite field operation, the complexity of a multiplier is much higher than a register. 
Because of fewer multipliers, the proposed soft BCH decoder with more registers and additional 
LUT has similar hardware complexity as the hard BCH decoder with inversionless 
38 
 
 
Fig. 29. Simulation results for BCH (255,239) code 
 
The BCH (255,239) decoder is implemented with hard decision and soft decision methods 
and demonstrated in Table 7. The hard BCH decoder uses iBM algorithm to solve key equation 
and needs Chien search to get error locations. Computing error locations without Chien search, 
the soft BCH decoder has almost half latency of the hard BCH decoder. Hence, the soft BCH 
decoder has much better throughputs than the hard BCH decoder. According to the post-layout 
simulations, the soft BCH decoder saves 47.1% clock cycle latency with similar gate count and 
operation frequency as compared with the hard BCH decoder in standard CMOS 90nm 
technology. 
Table 7  
Summary of Implementation Results 
 
 
40 
 
b) VLSI Architecture for Soft RS Decoder 
For the 2.5 Gb/s requirement of the optical communication systems, a soft RS (255,239) 
decoder with three pipelined stages based on our decision-confined decoding algorithm is 
presented and the decoding scheme is shown in Fig. 30. The following subsections will show 
the unique parts of our proposal in contrast to conventional hard decoders. 
(1) Syndrome Updater 
According to the method in step 2 of Algorithm 1, the candidate syndrome S(i+1)(x) can 
be updated from S(i)(x) by utilizing a look-up table (LUT) instead of recalculating it with 
syndrome calculator for further cost efficiency. Note that there are at most 25 candidates for 
each received message and 259 computational cycles for each pipelined stage. Thus it has 8 
computational cycles for every S(i+1)(x) and Λ(i+1)(x). As a result, the finite field multipliers 
(FFMs) and the squares can be shared to compute 16 compensation values for further hardware 
reduction. In our design, it only costs 4 FFMs and 2 squares for the calculation of all 
compensation values as shown in Fig. 31. 
 
 
Fig. 30. Decoding scheme of the proposed soft RS decoder 
 
42 
 
 
Fig. 33. The homogeneous architecture of Half-iteration RiBM 
 
(3) BP-based Error Value Evaluator 
Conventionally, after Chien search evaluates the error locators Xi’s, the corresponding 
error values ei’s can be calculated with Λ(x) and Ω(x) based on the Forney’s algorithm. From 
another approach, the BP based method [B-18] can compute the error values by solving the 
Vandermonde relation between the syndrome Si’s and error locators Xi’s as following form. 
 
 
Since the Forney’s algorithm and BP-based method consume nearly the same hardware 
costs, our half-iteration RiBM method removes the calculation of Ω(x) for further area 
efficiency. Based on the BP method, the error value evaluator can be implemented with the 
architecture as shown in Fig. 34. 
44 
 
 
Table 8 
 
Table 9 
 
Table 8 shows the comparison with LCC-based soft RS decoder. Our proposal can achieve 
more than 40% area reduction while the assumption is even not including the cost of decision 
making unit consumed in [B-19]. In addition, our design can operate with only half latency for 
each pipeline and less pipelined stages. Fig. 36 shows our decoder chip which is the first soft 
RS decoder chip in our understanding. Hence,  
Table 9 illustrates the implementation results of our soft RS decoder with other hard RS 
decoders. Implemented in 90nm CMOS process, our chip with 45.3K gates is comparable with 
a conventional hard decoder. Moreover, it can fit well for 10- 40 Gb/s with 16 RS decoders in 
optical fiber systems and 2.5 Gb/s GPON applications with 0.4 dB coding gain over hard 
decoders at 10−4 CER. 
 
Fig. 36. Microphoto of soft RS (255,239) chip 
46 
 
Table 10  
Average required truncation length for path merging in different channel condition 
 
Eb/N0 1.0 2.0 3.0 4.0 5.0 
Truncation 
length 
33.78 26.86 23.34 21.54 20.54 
 
(1) VARIABLE TRUNCATION LENGTH 
The Viterbi decoder for the MB-OFDM UWB system has 64 states. Fig. 38 illustrates the 
survivor memory on the radix-4 trellis. D0 to D63 are the decisions provided by the ACS units 
for selecting survivor paths. Base on path merging property, the 64 states tend to be equivalent 
from the left stages to the right stages, which are more reliable. 
The path merging detection unit will find the merge point, or stage in the trellis. 
Obviously, if contents of all the 64 survivors are equivalent at the same stage, the 64 survivor 
paths have merged. However, it is complex to check all 64 states concurrently. To reduce the 
hardware complexity, our proposal detects path merging by dividing 64 states into 16 groups 
that are verified separately. The simulation results show that this scheme has no performance 
loss. We assume the 64 survivor paths have merged and the value in state 0 is already reliable 
if every group (the circles in Fig. 38) contains equivalent values at the same stage. After 
detecting the merged point, we apply clock gating to the registers in the shadow region and 
directly shift out the value. The state 0 path is considered as the correct one, and the others are 
dropped. 
Fig. 39 illustrates the survivor memory architecture with variable truncation length. The 
registers of each stage are connected to the path merging detection unit that decides the merge 
point and generates clock gating signals of each stage. Based on the scheme, we can adjust 
truncation length dynamically, depending on the channel. In high SNR environments, a shorter 
truncation length is required and the clock gating can be applied to more registers, resulting in 
a power efficient survivor memory. 
48 
 
of 8-level soft-decision is less than 0.5dB. The proposed variable truncation length scheme still 
preserves the error performance. 
Table 11 
 Design parameters of proposed Viterbi decoder 
 
Technology 
1.2V 0.13-μm 
1P8M CMOS 
State Number 64 
Code Rate 1/3 
Soft-Decision 8-levels 
BM Width 6 bits 
PM Width 9 bits 
Max. Truncation 
length 
64 
ACS structure radix-4 
 
 
Fig. 40. Simulation results in AWGN channel, BPSK, 8-level soft decision and code rate=1/3 
 
b) Power Simulation 
We analyze the power dissipation of three implementations: the conventional 
register-exchange approach, the SST scheme without and with the variable truncation length 
scheme. Table 12 lists the gate counts of these implementations. In different channel 
50 
 
 
Fig. 41. Comparison of (A) Decoder power (B) Survivor memory power at 500Mbps 
 
Fig. 42. The power profiling of (A) Conventional structure and (B) Proposed structure as Eb/N0 is 
5.0dB 
 
52 
 
 
Fig. 43. (a) DCVSPG pulsed latch (b) Waveform of implicit pulse generator 
 
(1) DCVSPG Latch 
The DCVSPG latch is implemented using a differential cascode voltage switch with pass 
gate logic. Two cross-coupled PMOS transistors, M1 and M2, form the circuit load. Below the 
PMOS load, NMOS transistors form the n-channel logic evaluation. The DCVSPG latch 
captures input data in a transparent window generated by an implicit-pulse generator. Fig. 43(b) 
displays the corresponding waveform that is used to generate a transparent window. An 
implicit-pulse generator uses an odd-stage inverter chain to create a delayed signal of the 
opposite clock (clkb). According to the signals clk and clkb, an implicit pulse is generated as a 
transparent window by turning on NMOS pass transistors (M3 and M4, M5 and M6). The 
DCVSPG latch samples input data only in this transparent window. In a transparent window, 
the DCVSPG latch captures input data via four pass transistors. When the input datum is logic 
1, the node QB is discharged to ground along the pull down path (M5 and M6). Accordingly, 
the output Q is changed to logic 1 following one propagation delay associated with an inverter. 
After the node QB is discharged, the node QQ is charged by the PMOS, M1. Additionally, the 
operation of sampling logic 0 is similar to that of sampling logic 1. When the input datum is 
logic 0, the node QQ is discharged to ground along the other pull down path (M3 and M4). M2 
54 
 
scheme is employed in the pulse generator. In the proposed low-swing pulse generator, a gated 
PMOS is connected between the supply voltage (Vdd) and virtual Vdd. Furthermore, a gated 
NMOS is inserted between the ground and the virtual ground. The purpose of these two gated 
transistors is to form a low-swing clock between virtual Vdd and virtual ground. Therefore, the 
voltage swing is reduced from Vdd to Vdd ─│Vtp│ ─Vtn. Fig. 44 displays the corresponding 
waveform of the pulse generator and DCVSPG latch. The pulse width determines the hold time 
of the proposed DCVSPG pulsed latch. The proposed low-swing pulse generator has two 
advantages. First, stack transistors reduce leakage current and increase the propagation delay 
time. The delay chain of the DCVSPG pulsed latch is implemented to generate a transparent 
window. In advanced technologies, the number of inverters in a delay chain must be increased 
in a pulsed latch to guarantee that the width of the transparent window suffices for capturing 
the datum. Increasing the number of inverters causes substantial power consumption. 
Therefore, stack transistors increase the propagation delay without the need to add inverters. 
Second, reducing the voltage swing of the inverter chain reduces the switching power. 
However, the low-swing inverter chain decreases the noise immunity. Table 13 lists the static 
noise margin (SNM) of 3-stage low-swing and full-swing inverter chains. The average SNM of 
the low-swing inverter chain is reduced by 39% compared to that of the full-swing inverter 
chain. 
Table 13 
Static Noise Margin (SNM) of Three-Stage Inverter Chains 
 
 Low-Swing Full-Swing
SNMhigh 291 mV 548 mV 
SNMlow 287 mV 400  
 
b) A Low-Power Radix-4 Viterbi Decoder Based on DCVSPG Pulsed Latch with 
Sharing Technique 
(1) DCVSPG Pulsed Latch with Sharing Technique 
With state number increasing, the truncation length should be longer. In this condition, the 
register number will increase rapidly. Moreover, the punctured convolutional codes need 
56 
 
systems.  
Fig. 46 shows the plot of power versus delay based on different number pulsed latches. 
According to the simulation result, the power consumption reduces obviously in small number 
pulse latches. But with increasing latches, this reduction turns into saturated and delay rises 
rapidly. 
 
Fig. 46. Sharing analysis of different number of pulsed latch 
 
(2) Proposed Radix-4 RE-based Viterbi Decoder 
In the Viterbi decoder design, two important issues have to be considered carefully: speed 
and power. For high-speed applications, the high-radix architecture [C-11] becomes popular, to 
perform multi-step of trellis in one cycle. The data rate becomes n times based on radix-2n 
architecture, in other words, processing n bits in one cycle. In addition, without loss generality, 
the area and power overheads are also n times. Moreover, to achieve high data rate, the 
designer usually adopt RE-based SMU. The RE approach is the simplest technique which 
58 
 
cell library. In the Viterbi decoder using C2MOS flip-flops, all the blocks are implemented by 
C2MOS flip-flops, including the SMU block. To valid the design of the SMU using DCVSPG 
pulsed latches, the output pin of the decoded bit and three by-pass input pins (1 bit for input 
data and 2 bits for controlling the exchange of registers) are connected to the SMU to trace all 
the paths in SMU. The operating frequency and the throughput are 250 MHz and 500 Mb/s, 
respectively, to meet the requirement of UWB systems. The total number of gates and core size 
of the Viterbi decoder are 119K and 0.372mm2, respectively. Moreover, the power 
consumption is 56.86mW at 0.9V, estimated from the post-layout simulation. By comparison 
with C2MOS flip-flops, the DCVSPG pulsed latch not only reduces the power consumption of 
the Viterbi decoder by 21% but also reduces the core area by 12%. Fig. 48 presents the power 
distributions of the core power with C2MOS flip-flops and DCVSPG pulsed latches. The 
power consumption of SMU is 70% of the total power consumption in a C2MOS-based Viterbi 
decoder. The DCVSPG pulsed latch can reduce power consumption by 22% by reducing the 
power consumed by flip-flops and the clock tree of the SMU. Hence, the proposed DCVSPG 
pulsed latch is a power-efficient approach for implementation the SMU in a Viterbi Decoder. 
 
Fig. 48. Power Distributions of the Core Power with C2MOS flip-flop and DCVSPG Pulsed 
Latch 
 
Table 14 
Implementation Results of Viterbi Decoder 
 
C2MOS  
Flip-Flop 
DCVSPG 
Pulsed Latch 
Technology UMC 90nm CMOS Process 
Supply Voltage 0.9 v 
60 
 
 
Fig. 49. Performance of Viterbi decoder with sharing technique 
 
 
Fig. 50. Power comparison of Viterbi decoders 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
62 
 
complexity is reduced by dealing with the least reliable bits, and the error correcting ability is 
enhanced by compensating an extra error outside the least reliable set. In addition, Chien 
search can be eliminated with a counter that evaluates error locations in the proposed error 
locator evaluator procedure. Thus, a lot of redundant decoding latencies can be eliminated and 
higher throughputs can be achieved without parallelism. From the experimental results of BCH 
(255,239) code, the proposed soft decoder can give 0.75dB coding gain over the hard BCH 
decoder at BER = 10−5. Also, it can achieve 316.3 Mb/s throughputs while reducing 7% 
gate-count as be compared with the 167.4Mb/s traditional hard BCH decoder in CMOS 90nm 
technology. 
A novel decoding algorithm and its area-efficient architecture for soft RS codes is 
provided in this project. By confining the degree of error-locator polynomial, our approach has 
only one candidate sequence to be decoded. For RS (255,239) codes, our method can achieve 
0.4 dB coding gain at 10−4 CER over hard decoders. Unlike Chase-type methods using several 
hard RS decoders and determining the most probable candidate, our proposal only demands 
one, leading to significant hardware complexity reduction. According to the measurement 
results, the proposed soft RS decoder can achieve 2.56 Gb/s throughput with 45.3 K gate. As a 
result, our proposal can provide more powerful correcting ability with a high-speed and area 
efficient solution for optical communications applications. 
A low-power Viterbi decoder combining the SST and the variable truncation length 
scheme is presented. Reducing the state transition activities, the SST approach reduces the 
dynamic power in the decoder. The variable truncation length scheme provides a more efficient 
survivor memory management that pursues the sufficient truncation lengths for real channel 
conditions. Consequently, the redundant data movement can be abandoned for low power. 
Furthermore, high SNR environment causes the survivors merge rapidly, leading to more gated 
register elements. After implemented with the 0.13-μm cell based design flow, the fix-point 
error performance, the gate count, and the power dissipation has been examined by applying 
the presented low power techniques. Experimental results indicate the power reduction of the 
64 
 
V. 參考文獻 
[A-1] R. G. Gallager, Low-Density Parity-Check Codes. Cambridge, MA: MIT Press, 1963. 
[A-2] D. J. C. MacKay and R. M. Neal, “Near Shannon limit performance of low density 
parity check codes,” Electron. Lett., vol. 33, no. 6, pp.457–458, Mar. 1997. 
[A-3] M. Mansour and N. Shanbhag, “High-throughput LDPC decoders,” IEEE Trans. on 
VLSI Systems, vol. 11, no. 6, pp. 976–996, Dec. 2003. 
[A-4] Part 3: carrier sense multiple access with collision detection (CSMA/CD) access 
method and physical layer specificaions, IEEE Std. P802.3an-2006, Sept. 2006. 
[A-5] Part 15.3: wireless medium access control (MAC) and physical layer (PHY) 
specifications for high rate wireless personal area networks (WPANs), IEEE Std. 
P802.15.3c-DF8, 2009. 
[A-6] J. Zhang and M. Fossorier, “Shuffled iterative decoding,” IEEE Transactions on 
Communications, vol. 53, no. 2, pp. 209–213, Feb. 2005. 
[A-7] Y. K. Lin, C. L. Chen, Y. C. Liao, and H. C. Chang, “Structured LDPC codes with low 
error floor based on peg tanner graphs,” in IEEE Int. Sympo. Circuits and Systems 
(ISCAS’08), May 2008, pp. 1846–1849. 
[A-8] A. Darabiha, A. C. Carusone, and F. R. Kschischang, “A 3.3-Gbps bitserial 
block-interlaced min-sum LDPC decoder in 0.13-μm CMOS,” in Proc. IEEE CICC’07, Sept. 
2007, pp. 459–462. 
[A-9] X. Y. Shih, C. Z. Zhan, C. H. Lin, and A. Y. Wu, “A 19-mode 8.29mm2 52-mW LDPC 
decoder chip for IEEE 802.16e system,” in Proc. Int. Sympo. VLSI Circuits (SOVC’07), 
June 2007, pp. 16–17. 
[A-10] A. J. Felstrom and K. S. Zigangirov, “Time-varying periodic convolutional codes 
with low-density parity-check matrix,＂ IEEE Transactions on Information Theory, vol. 45, 
no. 6, pp. 2181 –2191, Sep. 1999. 
[A-11] E. Matus, M. Tavares, M. Bimberg, and G. Fettweis, “ Towards a GBit/s 
programmable decoder for LDPC convolutional codes,＂ in IEEE International Symposium 
on Circuits and Systems (ISCAS), May 2007, pp. 1657–1660. 
[A-12] M. Bimberg, M. Tavares, E. Matus, and G. Fettweis, “ A high-throughput 
programmable decoder for LDPC convolutional codes,＂ in IEEE International Conference 
on Application-specific Systems, Architectures and Processors (ASAP), July 2007, pp. 
239–246. 
[A-13] Z. Chen, S. Bates, and W. Krzymien, “High throughput parallel decoder design for 
66 
 
1974 
[B-9] A. Bj¨orck and V. Pereyra, “Solution of Vandermonde Systems of Equations,” Math. 
Computation, vol. 24, pp. 893–903, Oct. 1970 
[B-10] J. Hong and M. Vetterli, “Simple Algorithms for BCH Decoding,” IEEE Trans. on 
Communication, vol. 43, pp. 2324–2333, Aug. 1995 
[B-11] C. Parr, “Efficient VLSI Architectures for Bit-Parallel Computation in Galois Fields,” 
Ph.D. dissertation, Inst. for Experimental Mathematics of Univ. of Essen Germany, 1994 
[B-12] F. Therattil and A. Thangaraj, “A Low-complexity Soft-decision Decoder for Extended 
BCH and RS-Like Codes,” IEEE Trans. Inform. Theory, p. 1320V132, Sept. 2005. 
[B-13] Y. Chen and K. Parhi, “Small Area Parallel Chien Search Architectures for Long BCH 
Codes,” IEEE Trans. on VLSI, vol. 12, no. 5, pp. 545–549, May 2004. 
[B-14] J. Cho and W. Sung, “Strength-Reduced Parallel Chien Search Architecture for Strong 
BCH Codes,” IEEE Trans. on Circuits and Systems II, vol. 55, no. 5, pp. 427–431, May 
2008. 
[B-15] I. S. Reed, M. T. Shih, and T. K. Truong, “VLSI Design of Inverse-Free 
Berlekamp-Massey Algorithm,” Proc. Inst. Elect. Eng, vol. 138, pp. 295–298, Sept. 1991 
[B-16] D. Sarwate and N. Shanbhag, “High-speed architectures for Reed-Solomon decoders,” 
IEEE Trans. VLSI Syst., vol. 9, no. 5, pp. 641–655,Oct. 2001. 
[B-17] A. Raghupathy and K. J. R. Liu, “Algorithm-Based Low-Power/High-Speed 
Reed-Solomon Decoder Design,” IEEE Trans. on Circuits and Systems-II: Analog and 
Digital Signal Processing, vol. 47, no. 11, pp.1254–1270, Nov. 2000. 
[B-18] D. Sarwate and N. Shanbhag, “High-speed architectures for Reed-Solomon decoders,” 
IEEE Trans. VLSI Syst., vol. 9, no. 5, pp. 641–655, Oct. 2001. 
[B-19] X. Zhang, “High-speed VLSI architecture for low-complexity Chase soft-decision 
Reed-Solomon decoding,” IEEE Inform. Theory and Application Workshop, pp. 422–430, 
Feb 2009. 
[B-20] J.-I. Park, K. Lee, C.-S. Choi, and H. Lee, “High-speed low-complexity Reed-solomon 
decoder using pipelined berlekamp-massey algorithm,” IEEE Int. SoC Design Conference 
(ISOCC), pp. 452–455, 2009. 
[B-21] S. Lee, H. Lee, J. Shin, and J.-S. Ko, “A High-Speed Pipelined Degree- 
Computationless Modified Euclidean Algorithm Architecture for Reed-Solomon Decoders,” 
IEEE Int. Symp. on Circuits and Systems (ISCAS)., pp. 901-904, May 2007. 
[B-22] J. Baek and M. Sunwoo, “New Degree Computationless Modified Euclid Algorithm 
and Architecture for Reed-Solomon Decoder,” IEEE Trans. VLSI Syst., vol. 14, no. 8, pp. 
68 
 
VI. 計畫成果自評 
在此計畫執行三年中，我們提供七個可應用於無線通訊之低功耗基頻處理器元件分別為： 
I. A 11.5-Gbps LDPC Decoder Based on CP-PEG Code Construction 
II. A 2.37Gb/s 284.8mW Rate-Compatible (491, 3, 6) LDPC-CC Decoder 
III. A Soft BCH Decoder Chip for DVB-S2 System 
IV. An Improved Soft BCH Decoder with One Extra Error Compensation 
V. A Decision-Confined Soft RS Decoder 
VI. A Low-Power Viterbi Decoder Based on Scarce State Transition and Variable Truncation 
Length 
VII. A Low Power Differential Cascode Voltage Switch with Pass Gate Pulsed Latch for Viterbi 
Decoder 
下表一至三是為本研究團隊對於今年執行的計畫進度與各別研究規劃，在表中，我們
完成了六個研究的架構設計、下線與陸續完成量測；在此計畫三年的研究成果，希望能在
未來為產業界、學術界盡一份心力。 
表一 子計畫一之研究規劃 
月份 (2009) 01 02 03 04 05 06 07 08 09 10 11 12
A 11.5-Gbps LDPC Decoder Based on CP-PEG Code Construction 
LDPC Paper Survey                         
CP-PEG Code Construction                 
Sequential Scheduling Design                
Algorithm Simulation                 
Architecture Design                    
Cell-Based Design                    
Chip Layout                  
 
 
 
 
70 
 
 
表三 子計畫三之研究規劃 
月份 (2008) 01 02 03 04 05 06 07 08 09 10 11 12
A Low-Power Viterbi Decoder Based on Scarce State Transition and Variable 
Truncation Length 
Modified SST Algorithm                         
Modified SST Architecture Design                
Modified SST VD FPGA Platform                
Modified SMU Prepare                 
Modified SMU Design & Simulation                    
Modified SST + SMU VD FPGA Platform                 
Modified SST + SMU VD Chip Layout                    
Modified SST + SMU VD IC Tape-out                  
 
月份 (2010) 01 02 03 04 05 06 07 08 09 10 11 12
A Low Power Differential Cascode Voltage Switch with  
Pass Gate Pulsed Latch for Viterbi Decoder 
Low Power Latch Paper Survey                         
DCVSPG Pulsed Latch Development                
DCVSPG Pulsed Latch Simulation                 
Viterbi Decoder Architecture Design                 
Viterbi Decoder Cell-Based Design                    
 
感謝本計畫對我們的鼓勵，讓我們每年有穩定成長的貢獻，下者我們列出掛有本計畫的論
文： 
1. Yi-Min Lin, Chih-Lung Chen, Hsie-Chia Chang, and Chen-Yi Lee, “A 26.9K 314.5Mbps 
Soft (32400,32208) BCH Decoder Chip for DVB-S2 System,” in IEEE Journal of Solid-State 
Circuits, vol.45, no.11, pp.2330-2340, Nov. 2010 
2. Yi-Min Lin, Hsie-Chia Chang, and Chen-Yi Lee, “An Improved Soft BCH Decoder with One 
Extra Error Compensation,” in IEEE Int. Symposium on Circuits and Systems (ISCAS), France 
Paris, May 2010 
3. Yi-Min Lin, Chih-Lung Chen, Hsie-Chia Chang, and Chen-Yi Lee, “A 26.9K 314.5Mbps 
Soft (32400,32208) BCH Decoder Chip for DVB-S2 System,” in IEEE Asia Solid State 
Circuits Conf. (ASSCC), Taiwan Taipei, Nov. 2009 
72 
 
VII. 附錄– 2007-2011 本計畫相關之研究成果 
Patents: 
1. 林義閔、楊其衡、張錫嘉、李鎮宜，” 一種用以處理循環碼之方法及裝置,”中華民國專
利申請第 099135609 號，99 年 10 月 19 日。 
2. 翁政吉、唐正浩、張錫嘉、李鎮宜，”應用於迭代解碼之多層級網路架構及其傳輸方法,”
中華民國專利申請第 96149409 號，96 年 12 月 21 日。（公告號：200929892）（經濟部
科專 95-EC-17-A-01-S1-048）  
3. 陸志豪、廖彥欽、李鎮宜、許雅三、張錫嘉，”應用於低密度對稱檢查碼（LDPC）解碼
器之運算方法及其電路,” 中華民國專利申請第 096128039 號，96 年 7 月 31 日。（公告
號：200906073）（經濟部科專 93-EC-17-A-03-S1-0005） 
4. 陸志豪、林建青、李鎮宜、許雅三、張錫嘉，”用於通訊系統的資料交換裝置及方法,” 中
華民國專利發明 I339944 號，96 年 4 月 23 日。（國科會 NSC94-2220-E-009-027） 
5. 陸志豪、林建青、李鎮宜、張錫嘉、許雅三，”多模多平行度資料交換方法及其裝置,”
中華民國專利發明 I339955 號，96 年 12 月 7 日。（經濟部科專 93-EC-17-A-03-S1-0005）。 
6. 李鎮宜、林建青、林凱立、張錫嘉, “用於更新低密度配類核對（LDPC）碼解碼器之核
對節點的方法及其裝置,” 中華民國專利發明 I291290 號，96 年 12 月 11 日。（國科會 NSC 
93-2220-E-009-033） 
7. 陸志豪、廖彥欽、李鎮宜、許雅三、張錫嘉，”應用於低密度對稱檢查碼（LDPC）解碼
器之運算方法及其電路,” 日本專利申請特願 2008-082997 號，97 年 3 月 27 日。（經濟
部科專 93-EC-17-A-03-S1-0005） 
8. Yi-Min Lin, Chi-Heng Yang, Hsie-Chia Chang, and Chen-Yi Lee, “APPARATUS AND 
METHOD OF PROCESSING CYCLIC CODES” has been filed as U.S. Patent pending, 
12/790,875, May 31, 2010. 
9. Chih-Hao Liu, Yen-Chin Liao, Chen-Yi Lee, Hsie-Chia Chang, and Yar-Sun Hsu, “Operating 
Method Applied to Low Density Parity Check (LDPC) Decoder and Circuit Thereof”, has 
been filed as U.S. Patent pending, 11/939119, November 13, 2007. （pub. no. 20090037799）
（經濟部科專 93-EC-17-A-03-S1-0005） 
10. Chih-Hao Liu, Chien-Ching Lin, Chen-Yi Lee, Hsie-Chia Chang, and Yar-Sun Hsu, 
“Multi-mode multi-parallelism data exchange method and thereof,” U.S. Patent pending, 
74 
 
Conference: 
1. Chih-Hsiang Hsu, Yi-Min Lin, Hsie-Chia Chang, and Chen-Yi Lee, “A 2.56Gb/s Soft RS 
(255,239) Decoder Chip for Optical Communication Systems”, has been accepted by IEEE 
ESSCIRC Proceedings 
2. Chih-Lung Chen, Yu-Hsiang Lin, Hsie-Chia Chang and Chen-Yi Lee, “A 2.37Gb/s 284.8mW 
Rate-Compatible (491,3,6) LDPC-CC Decoder,” in IEEE Symposium on VLSI Circuits, pp. 
134-135, June 2011 
3. Xin-Ru Lee, Hsie-Chia Chang, and Chen-Yi Lee, “A Low-Power Radix-4 Viterbi Decoder 
Based on DCVSPG Pulsed Latch with Sharing Technique,” in IEEE Asia Pacific Conference 
on Circuits and Systems (APCCAS), Kuala Lumpur Malaysia, Dec. 2010 
4. Yi-Min Lin, Hsie-Chia Chang, and Chen-Yi Lee, “An Improved Soft BCH Decoder with One 
Extra Error Compensation,” in IEEE Int. Symposium on Circuits and Systems (ISCAS), France 
Paris, May 2010.（EI） 
5. Yi-Min Lin, Chih-Lung Chen, Hsie-Chia Chang, and Chen-Yi Lee, “A 26.9K 314.5Mbps Soft 
(32400, 32208) BCH Decoder Chip for DVB-S2 System,” IEEE Asian Solid-State Circuits 
Conference (A-SSCC), Hsinchu, Taiwan, November 2009, pp.373-376, (EI) 
6. Shao-Wei Yen, Ming-Chih Hu, Chih-Lung Chen, Hsie-Chia Chang, Shyh-Jye Jou, and 
Chen-Yi Lee, “A 0.92mm2 23.4mW Fully-Compliant CTC Decoder for WiMAX 802.16e 
Application,” IEEE Custom Integrated Circuits Conference (CICC), , San Jose, California, 
October 2009, pp.191-194. (EI). 
7. Chih-Lung Chen, Kao-Shou Lin, Hsie-Chia Chang, Wai-Chi Fang, and Chen-Yi Lee, “A 
11.5-Gbps LDPC Decoder Based on CP-PEG Code Construction,” European Solid-State 
Circuits Conf. (ESSCIRC), Athens, Greece, September 2009. 
8. Chih-Hao Liu, Chien-Ching Lin, Hsie-Chia Chang, Chen-Yi Lee, and Yar-Sun Hsu, 
“Multi-mode Message Passing Switch Networks Applied for QC-LDPC Decoder,” in IEEE 
Int. Symposium on Circuits and Systems (ISCAS), Seattle, U.S., May 2008, pp.752-755. (EI) 
9. Cheng-Chi Wong, Cheng-Hao Tang, Ming-Wei Lai, Yan-Xiu Zheng, Chien-Ching Lin, 
Hsie-Chia Chang, Chen-Yi Lee, and Yu-T. Su, “A 0.22nJ/b/iter 0.13µm Turbo Decoder Chip 
Using Inter-Block Permutation Interleaver,” in IEEE Custom Integrated Circuits Conference 
(CICC), San Jose, California, October 2007, pp.273-276. 
 
76 
 
 
 2
國政府已將醫療電子產業納入六大新興產業的發展重點,可見的未來亦將投入大量的科研經
費,在現有 ICT 的科技產業基礎上,推動此一高附加價值的產業生態.而相關的法規和配套機制,
也應同時進行立法和設定推動時程,否則將無法事實帶動國內科技業者的投入,在全球競爭激
烈的醫療電子市場中取得優勢. 
下午所主持的生醫界面電路(BIO INTERFACE),是和來自 XILINX 公司的 Dr. Ken Chang 共同
主持,此場次中共有四篇論文發表(皆來自於北美和西歐),顯示對於醫療電子的科研投入,歐美
先進國家是相當積極也企圖在此一新領域上取得市場的先機.此四篇論文之技術重點簡述如
下: 第一篇是由 KAIST 和 IMEC 合作,主要針對 ECG 訊耗用於行動照護上的需求和關鍵電路
的設計;第二篇是由 STANFORD 大學所提出的低功耗 96 通道的 EEG 讀取電路;第三篇則是由
密西根大學所提出的具有人體通道傳輸功能的植入性 EEG 讀取和傳輸電路;第四篇則由德州
大學所提出的光電產能電路設計;基本上以上所提的四種方案,皆有其特色但並沒有進行人體
試驗,是否具實用價值後續仍有許多待驗證之處. 
另外由於為此會議之 TPC 委員,因此亦邀請目前任職於台大醫院的吳造中教授參與晚間的
RUMP 場次,透過工程與醫療團隊的對話,可激發出務實的研究議題和執行方案,將有助於工程
團隊在相關電路的研發,避免陷入”只為電路而欠缺務實醫療用途”的窘境.透過兩個多小時的
對話,雖然吳教授給工程團隊撥了許多冷水但也激發出醫療電子電路設計上的思維,亦即在醫
療電子領域漸進式的改善方案將不易獲致重大的成效,唯有跨領域的研究團隊整合,方有機會
獲致突破性的研究成果,進而獲取醫療團隊和一般民眾的信賴和使用(就如同電腦斷層掃描 CT
的成功案例).這也是國內產學研單位有意投入此一醫療健康照護產業所必須建立的基本態度. 
 
 
 2
的人員跟演講的專家能夠充分的交流，是比較特別的地方。 
會議的第一天(六月十四日)是早上八點十分開始，所以我提早於前一天抵達日本京都，早上
先至會場註冊報到，會議地點是日本的Rihga Royal Hotel Kyoto，距離京都車站步行約八分鐘，
到了會場註冊並領取相關資料，第一天的議程是Short Course 跟Workshop，Short Course 
的主題是「Device Awareness in Circuit Design」、Workshop 的主題則是「Bio Inspired 
Computation –What Electronics can learn from Bio-」，speaker 幾乎都是來自知名大廠，如
Toshiba、Fujitsu、TSMC、Qualcomm、Broadcom、IBM、Renesas Electronics、Hitachi、Georgia 
Tech，加上少數大學教授，有東京大學、UC Berkeley、Univ. of Michigan等，所以幾乎快要
是知名大廠的技術發表會了。由於有些演講的題目不是跟我研究相關的領域，所以只能聽懂
些許，不過能從中吸取演講的經驗也是很好。 
第二天(六月十五日)開始接連三天就是論文發表的時間，第一天我去聆聽了Advanced Wireless 
Transceivers 、Circuit and System Integration、Multi Gigabit Wireline Communication 這三個
section，因為跟我本身的領域通訊系統及數位電路比較相關，了解目前熱門的題目在做些什
麼。同時這天也到speaker preparation room 準備隔天要演講的投影片、並瞭解規定與順序。 
第三天(六月十六日)下午的第一場就是我報告的section：HighSpeed Digital for Interconnects，
同section 一共有四篇論文發表，第一篇是日本的NTT Lab，做的是10G-EPON OLT and ONU 
LSIs；第二篇則是我；第三篇來則UCLA，發表FPGA Chip；第四篇來自Univ. of Michigan，
發表Self-arbitrating Interconnect Fabric；除了第一位，另外三個報告者都是學生，有互相交流
與競爭的感覺。比較起來，第一位日本人的英文演講比較差，還需要看講稿，而第三第四位
因為來自美國，所以英文很流利，演講內容很紮實，希望我之後也能多多向他們看齊。第三
天晚上的Rump Session 則是這次會議最有趣的地方，我去聽的Session 題目是「Will Circuit 
Design be a Key Issue in Biomedical Applications? (or Boring Circuits?)」，這個座談會請來了七
位世界各國大學的教授、加上一位台大醫院的醫師C.-C. Wu，一起來討論在生醫領域，電路
設計究竟是重要的還是只是無聊的電路。電路設計領域的教授們當然主要是站在電路設計很
重要這邊，所以台大醫師C.C. Wu 就成了很有趣的角色，因為他是從醫界的角度來提出不同
意見，所以兩方的想法交流有來有往，讓與會的人都能從中去思考與反省，希望能對未來的
研究與人類的生活更有幫助。 
最後一天(六月十七日)的Session 主要則是數位電路、記憶體(DRAM、Flash、Nonvolatile 
Memories)、還有能源(power)有關的議題。讓我比較有印象的是台大陳良基教授的研究群有發
現一篇Full HD160-degree Object Recognition SoC Chip，能夠從不同視角去做物件辨識。整個
會議總體而言，可以看到國外大學與企業進行的研究都具有前瞻性與技術性，值得學習。 
二、 與會心得 
由於是電路與元件兩個會議一同舉行，所以第一天的晚上有安排joint rump session，請了半導
體產業的大師或是熱門領域的學者來演講，演講題目涵蓋兩個領域，有的是講電路設計，有
的是在討論電子元件，讓大家互相交流，算是此會議比較特別的地方。 
由於半導體電路的領域很廣，在此會議發表的論文內容，大部份比較偏向類比電路與混合訊
號電路，所以去聽其它人報告時，常會遇到聽不太懂的情況。不過還是可以去了解別人做研
究的核心概念，尤其是國外學者嚴謹的態度與有創意的想法。 
 1
國科會補助專題研究計畫項下出席國際學術會議心得報告 
                            日期： 99 年 12 月 15 日 
一、 參加會議經過 
1. 會議說明 
2010 IEEE 亞太電路與系統研討會（IEEE Asia Pacific Conference on Circuits And 
Systems, APCCAS 2010）於2010年12月6日至12月9日於馬來西亞吉隆坡舉辦，主辦單位
為IEEE電路及系統社群（IEEE Circuits and System Society）。APCCAS 2010是第十一屆
舉行的APCCAS會議，在電子電路相關領域算是一個歷史悠久的會議。  
 
計畫編號 NSC97－2220－E－009－166 
計畫名稱 應用於無線通訊之低功耗基頻處理器 
出國人員
姓名 李欣儒 
服務機
構及職
稱 
交通大學電子研究所 
博士班研究生 
會議時間 
99 年 12 月 6 日
至 
99 年 12 月 9 日 
會議地
點 
馬來西亞吉隆坡 
會議名稱 
(中文) IEEE 亞太電路與系統研討會 
(英文) IEEE Asia Pacific Conference on Circuits And 
Systems(APCCAS) 
發表論文
題目 
(中文)以脈波閂鎖器共用技術之低功率維特比解碼器 
(英文) A Low-power Radix-4 Viterbi Decoder Based on DCVSPG 
Pulsed Latch with Sharing Technique 
 3
個領域的想法及方法。 
三、 建議 
由於今年的APCCAS舉行在吉隆坡，距離台灣並不遠，消費水準也與台灣相近，建議老
師可以多鼓勵學生出國參與此類國際會議，以培養學生對國際學術活動的交流互動與國
際觀，並提昇學生在研究上能衍生出不同見解。 另外此國際會議不論參與人數或是文章
發表數都還不少，所以同時會有多個不同的會議廳同時舉行，建議在出發前得知會議議
程後便能決定要參與那些議程，並先找出一些跟實驗室相關研究的paper並前往聆聽其報
告，且先去會場了解地形，以免臨時找不到會議地點。 
四、 攜回資料名稱及內容 
1. APCCAS會議隨身碟 
2. APCCAS會議手冊 
3. APCCAS紀念手提包 
 
 
97 年度專題研究計畫研究成果彙整表 
計畫主持人：李鎮宜 計畫編號：97-2221-E-009-166-MY3 
計畫名稱：應用於無線通訊之低功耗基頻處理器 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 1 1 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 1 1 100%  
博士生 4 4 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 2 2 100%  
研究報告/技術報告 0 0 100%  
研討會論文 6 6 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 1 1 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
■達成目標 
□未達成目標（請說明，以 100 字為限） 
□實驗失敗 
□因故實驗中斷 
□其他原因 
說明： 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：■已發表 □未發表之文稿 □撰寫中 □無 
專利：□已獲得 ■申請中 □無 
技轉：■已技轉 □洽談中 □無 
其他：（以 100 字為限） 
3. 請依學術成就、技術創新、社會影響等方面，評估研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）（以
500 字為限） 
基頻訊號處理在無線通訊系統上扮演關鍵性的角色，不僅可有效提升傳輸的效能，更能提
供多模式和多標準的系統實現方案。然而要達成低成本和低功率設計方法，不僅對於個別
模組的演算法需深入瞭解外，也必須融入系統層級的行為，方能提供一個具有技術競爭力
的解決方案。因此在今年的研究計畫，我們針對 OFDM 主流無線通訊系統所需求的關鍵模
組 Viterbi 解碼器、LDPC 解碼器、RS 解碼器及 BCH 解碼器進行相關議題的研究。 
在 IEEE 802.11 的 Wifi 規格中，幾乎都使用了 Viterbi 解碼器，為了因應綠色節能的觀
念， 
我們在 Viterbi 解碼器加入了關鍵技術使功耗下降。模擬結果顯示，Viterbi 中最主要消
耗 
功率的儲存單元省了 60%的功耗，而整個解碼器也下降了 30%的功耗，最重要的是只多出
了 8%的大小。 
在 LDPC 解碼器方面，所設計出的 LDPC Convolutional Code 解碼器，提出了演算法、節
點、位元等三個層級的最佳化架構來提升吞吐量及降低解碼延遲時間，以及藉由混合分割
式 FIFO（hybrid-partitioned FIFO）架構來降低功率消耗。演算法層級最佳化後可以用
5個處理單元達成傳統演算法 10 個疊代次數的效能，等同於可減少一半的處理單元，剩下
來的一半還可以隱藏通道值（concealing channel values），省去 17% FIFO 容量。有效
降低功率至 284mW，換算成能量效率（energy efficiency）為 0.024 nJ/bit/proc，相較
過去的文獻，在功率消耗、解碼吞吐量，以及硬體代價各方面都具有極高的競爭力。 
