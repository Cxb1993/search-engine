 2 
 
中文摘要 
本研究計畫研究公開式廣播加密系統，現今
最好的公開式廣播加密系統的私密金鑰大
小、公開金鑰和傳輸量能無法和私密式的廣
播系統相比，我們覺得可以使之達到更佳的
效率：分別為 O(r), O(log n) 和 O(1)，同
時計算量也可控制在合理的範圍之內，不像
BGW的方法需要 O(n)。 
  第一年度我們發展出兩個公開廣播加密
協定，第一個協定可以達到 O(r)密文長度，
O(log n)私密金鑰及 O(1)公開金鑰，計算量
需要 O(r)。第二個協定可以達到 O(r)密文長
度，O(log2 n)私密金鑰及 O(1)公開金鑰，計
算量只需要 O(1)。論文已在 2008 的 PKC 會
議上發表。第二年度我們將協定修改，加強
其安全度達到 IND-CCA2的等級，目前投稿到
知名的期刊，正在審稿中。 
第二年度，我們還進行了有關感測網路
金鑰建立的問題，我們提出一個和現有論文
完全不同的攻擊模型，再據此提出一個安全
的金鑰建立協定並探討其安全性，結果發表
在 IEEE Trans.Wireless Communications
上。 
第三年度我們對 permutation code（PC）
做了詳細的研究，提出許多 PC碼的性質及好
的編解碼方法，結果發表在 IEEE Trans. 
Information Theory上。 
關鍵詞：廣播加密、公開金鑰、排序碼、金
鑰建立。 
英文摘要 
In this project we study the public-key 
broadcast encryption system, in which one can 
broadcast to a set of authorized users. To our 
best knowledge, the best public-key broadcast 
encryption system is not very efficient in the 
size of the header, public key and private key of 
users, compared to the secret-key broadcast 
encryption system. One of the goals of this 
research is to design and analyze efficient 
public-key broadcast encryption schemes. 
In 2008, we we designed two efficient 
public-key broadcast encryption schemes. The 
first scheme achieves O(1) public-key size, O(r) 
header size and O(log n) private keys per user. 
The decryption time is reasonably O(r). Our 
second scheme achieves O(1) public-key size, 
O(r) header size and O(log
2
 n) private keys per 
user. Although the private key size is less 
efficient than the first one, its decryption time 
is remarkably O(1). The paper of these results 
has been published in prestigious PKC 
conference. In 2009, we improve one of our 
designed schemes to achieve the IND-CCA2 
security and give a very strict proof. We have 
submitted the improved result to a prestigious 
journal. 
In 2009, we also spent time on the 
problem of key establishment problem in the 
wireless sensor networks. We explore a very 
novel security model in which the adversary is 
instead storage-bounded, not computing-power 
constraint. By this model, we propose a very 
simple and secure key establishment protocol. 
The protocol does not require the sensors to 
pre-load secret. This result has been accepted 
and published in IEEE Trans. Wireless 
Communications. 
In 2010, we studied the error correcting 
coding problem for permutation codes. We 
found many interesting properties and proposed 
efficient decoding algorithms. The result has 
been accepted by IEEE Trans. Information 
Theory. 
Keywords: Broadcast encryption, public key 
system, permutation code, key establishment. 
一、 計畫緣起及目的 
 4 
由上述兩種方法我們觀察可得知，當每
個使用者金鑰儲存量少的時候，傳輸量多；
當儲存量少之時，所需傳輸量就大，而如何
能有個好方法能在這兩者間取得平衡？亦或
是使這兩者參數皆小，並在計算量上所需最
小，便是我們研究的主要課題。 
二、 研究成果 
第一年度我們發展出兩個公開廣播加密
協定，第一個協定可以達到 O(r)密文長度，
O(log n)私密金鑰及 O(1)公開金鑰，計算量
需要 O(r)。第二個協定可以達到 O(r)密文長
度，O(log2 n)私密金鑰及 O(1)公開金鑰，計
算量只需要 O(1)。論文已在 2008 的 PKC 會
議上發表。第二年度我們將協定修改，加強
其安全度達到 IND-CCA2的等級，目前投稿到
知名的期刊，正在審稿中。 
第二年度，我們進行了有關感測網路金
鑰建立的問題，我們提出一個和現有論文完
全不同的攻擊模型，再據此提出一個安全的
金鑰建立協定並探討其安全性。這篇論文主
要是探討 storage-bounded 攻擊者的模式
下，建立節點間金鑰的方法，我們發現節點
間不需要事先載入秘密值就可建立安全的通
訊金鑰，我們使用了機率式的分析方法來討
論金鑰的安全行，我們是第一個在感測網路
上使用這個分析方法。結果發表在 IEEE 
Trans.Wireless Communications上。 
第三年度我們對 permutation code（PC）
做了詳細的研究，提出許多 PC碼的性質及好
的編解碼方法，結果發表在 IEEE Trans. 
Information Theory上。 
三、 計畫成果自評 
本計劃我們發表了四篇高水準的會議及
期刊論文，還有一篇在審稿中，以成果來看，
我們達成了計劃的預定目標。 
 
 
 
 
附件 
1. Y.-R. Liu, W.-G. Tzeng. Public key 
broadcast encryption with low number of 
keys and constant decryption time.  In 
Proceedings of International Workshop on 
Practice and Theory in Public-Key 
Cryptography (PKC 08), LNCS 4939, 
pp.380-396, 2008.  
2. S.-C. Tsai, W.-G. Tzeng, Kun-Yi Zhou. 
"Key Establishment Schemes Against 
Storage-Bounded Adversaries in Wireless 
Sensor Networks," IEEE Transactions on 
Wireless Communications 8(3), 
pp.1218-1222, 2009. 
3. Yi-Ruei Chen and Wen-Guey Tzeng. A 
Public-Key Traitor Tracing Scheme with an 
Optimal Transmission Rate, In Proceedings 
of the 11th International Conference on 
Information and Communications Security 
(ICICS 09), LNCS 5927, pp.121-134, 2009. 
4. T. Kløve, T.-T. Lin, S.-C. Tsai, W.-G. 
Tzeng. "Permutation Arrays Under the 
Chebyshev Distance," IEEE Transactions 
on Information Theory 56(6), pp.2611-2617, 
2010. 
 
Public Key Broadcast Encryption with Low Number of Keys 381
broadcasted messages can be decrypted by authorized users only. Broadcast en-
cryption has many applications, such as pay-TV systems, encrypted ﬁle sharing
systems, digital right management, content protection of recordable data, etc.
A broadcasted message M is sent in the form 〈Hdr(S,m), Em(M)〉, where
m is a session key for encrypting M via a symmetric encryption method E. An
authorized user in S can use his private keys to decrypt the session key m from
Hdr(S,m). Since the size of Em(M) is pretty much the same for all broadcast
encryption schemes, we are concerned about the header size. The performance
measures of a broadcast encryption scheme are the header size, the number of
private keys held by each user, the size of public parameters of the system (public
keys), the time for encrypting a message, and the time for decrypting the header
by an authorized user. A broadcast encryption scheme should be able to resist
the collusion attack from revoked users. A scheme is fully collusion-resistant if
even all revoked users collude, they get no information about the broadcasted
message.
Broadcast encryption schemes can be stateless or stateful. For a stateful
broadcast encryption scheme, the private keys of a user can be updated from
time to time, while the private keys of a user in a stateless broadcast encryption
scheme remain the same through the lifetime of the system. Broadcast encryp-
tion schemes can also be public key or secret key. For a public key BE scheme,
any one (broadcaster) can broadcast a message to an arbitrary group of autho-
rized users by using the public parameters of the system, while for a secret key
broadcast encryption scheme, only the special dealer, who knows the system
secrets, can broadcast a message.
In this paper we refer ”stateless public key broadcast encryption” as ”public
key BE”.
1.1 Our Contribution
We propose three public key BE schemes that have eﬃcient complexity measures.
The ﬁrst scheme, called the BE-PI scheme (broadcast encryption with polyno-
mial interpolation), has O(r) header size, O(1) public keys, and O(logN) private
keys per user1, where r is the number of revoked users. This is the ﬁrst public
key BE scheme that has both public and private keys under O(logN) while the
header size is O(r). These complexity measures match those of eﬃcient secret
key BE schemes [11,20,21]. The idea is to run logN copies of the basic scheme
in [17,19,22] in parallel for lifting the restriction on a priori ﬁxed number of
revoked users. Nevertheless, if we implement the logN copies straightforwardly,
we would get a scheme of O(N) public keys. We are able to use the properties
of bilinear maps as well as special private key assignment to eliminate the need
of O(N) public keys and make it a constant number.
Our second scheme, called the PK-SD-PI scheme (public key SD broadcast en-
cryption with polynomial interpolation), is constructed by combining the polyno-
mial interpolation technique and the subset cover method in the SD scheme [16].
1 log is based on 2 if the base is not speciﬁed.
Public Key Broadcast Encryption with Low Number of Keys 383
polynomial interpolation (in fact, the Reed-Solomon code) to any linear code for
constructing public key BE schemes. The schemes in [7,13,14,17,19,22] all have
O(k) public keys, O(1) private keys, and O(r) header size, r ≤ k. However, k is
a-priori ﬁxed during the system setting and the public key size depends on it.
These schemes can withstand the collusion attack of up to k revoked users only.
They are not fully collusion-resistant.
Yoo, et al. [21] observed that the restriction of a pre-ﬁxed k can be lifted by
running logN copies of the basic scheme with diﬀerent degrees (from 20 to N) of
polynomials. They proposed a scheme of O(logN) private keys and O(r) header
size such that r is not restricted. However, their scheme is secret key and the
system has O(N) secret values. In the public key setting, the public key size is
O(N).
Recently Boneh, et al. [4] proposed a public key BE scheme that has O(1)
header size, O(1) private keys, and O(N) public keys. By trading oﬀ the header
size and public keys, they gave another scheme with O(
√
N) header size, O(1)
private keys and O(
√
N) public keys. Lee, et al. [15] proposed a better trade-oﬀ
by using receiver identiﬁers in the scheme. It achieves O(1) public key, O(logN)
private keys, but, O(r logN) header size. Boneh and Waters [5] proposed a
scheme that has the traitor tracing capability. This type of schemes [4,5,15]
has the disadvantage that the public keys are needed by a user in decrypting the
header. Thus, the de-facto private key of a user is the combination of the public
key and his private key.
It is possible to transform a secret key BE scheme into a public key one.
For example, Dodis and Fazio [6] transformed the SD and LSD schemes [12,16]
into public key SD and LSD schemes, shorted as PK-SD and PK-LSD. The
transformation employs the technique of hierarchical identity-based encryption
to substitute for the hash function. Instantiated with the newest constant-size
hierarchical identity-based encryption [2], the PK-SD scheme has O(r) header
size, O(1) public keys and O(log2 N) private keys. The PK-LSD scheme has
O(r/) header size, O(1) public keys and O(log1+ N) private keys, where 0 <
 < 1 is a constant. The decryption costs of the PK-SD and PK-LSD schemes
are both O(logN), which is the time for key derivation incurred by the original
relation of private keys. If we apply the HIBE technique to the secret key BE
schemes of O(logN) or O(1) private keys [1,11,20], we would get their public
key versions with O(N) private keys and O(N) decryption time.
2 Preliminaries
Bilinear map. We use the properties of bilinear maps. Let G and G1 be two
(multiplicative) cyclic groups of prime order q and eˆ be a bilinear map from
G × G to G1. Then, eˆ has the following properties.
1. For all u, v ∈ G and x, y ∈ Zq, eˆ(ux, vy) = eˆ(u, v)xy.
2. Let g be a generator of G, eˆ(g, g) = g1 = 1 is a generator of G1.
Public Key Broadcast Encryption with Low Number of Keys 385
In the above the adversary A is static since it chooses the target set S∗ of
users before the system setup. Let Advind-ccaA,Π (z) be the advantage that A wins
the above game, that is,
Advind-ccaA,Π (z) = 2 · Pr[AO(PK,SKU\S∗ ,m0,m1,Hdr(S∗,m)) = b :
S∗ ⊆ U , (PK,SKU) ← Setup(1z, Id,U),
Hdr(S∗,m) ← Enc∗(PK,S∗), b u← {0, 1}] − 1,
where SKU = {SKi : 1 ≤ i ≤ N} and SKU\S∗ = {SKi : Ui ∈ S∗}.
Deﬁnition 1. A public key BE scheme Π=(Setup, Enc, Dec) is (t, , qD)-IND-
CCA secure if for all t-time bounded adversary A that makes at most qD decryp-
tion queries, we have Advind-ccaA,Π (z) < .
In this paper we ﬁrst give schemes with one-way security against chosen plaintext
attacks (OW-CPA security) and then transform them to have IND-CCA security
via the Fujisaki-Okamoto transformation [9]. The OW-CPA security is deﬁned
as follows.
Init. The adversary A chooses a system identity Id and a target set S∗ ⊆ U
of users to attack.
Setup. The challenger C runs Setup(1z, Id, U) to generate a public key PK
and private key sets SK1, SK2, . . . , SKN . The challenger C gives SKi to A,
where Ui ∈ S∗.
Challenge. The challenger C runs Enc∗(PK,S∗) and outputs Hdr(S∗, m),
where m is randomly chosen.
Guess. A outputs a guess m′ for m.
Since A can always encrypt a chosen plaintext by himself, the oracle of en-
crypting a chosen plaintext does not matter in the deﬁnition. Let Advow-cpaA,Π (z)
be the advantage that A wins the above game, that is,
Advow-cpaA,Π (z) = Pr[A(PK,SKU\S∗,Hdr(S∗,m)) = m : S∗ ⊆ U ,
(PK,SKU) ← Setup(1z, Id,U),Hdr(S∗,m) ← Enc∗(PK,S∗)].
Deﬁnition 2. A public key BE scheme Π=(Setup, Enc, Dec) is (t, )-OW-CPA
secure if for all t-time bounded adversary A, we have Advow-cpaA,Π (z) < .
3 The BE-PI Scheme
Let G and G1 be the bilinear groups with the pairing function eˆ, where q is
a large prime. Let H1, H2 : {0, 1}∗ → G1 be two hash functions and E be a
symmetric encryption with key space G1.
The idea of our construction is as follows. For a polynomial f(x) of degree
t, we assign each user Ui a share f(i). The secret is f(0). We can compute the
secret f(0) from any t+1 shares. If we want to revoke t users, we broadcast their
Public Key Broadcast Encryption with Low Number of Keys 387
3. Dec(SKk,Hdr(S,m), C): Uk ∈ S. The user Uk does the following.
– Compute b0 = eˆ(gr, grk,αfα(k)) = g
rrk,αfα(k)
1 .
– Compute bj = eˆ(grk,α , grfα(ij)) = g
rrk,αfα(ij)
1 , 1 ≤ j ≤ L.
– Use the Lagrange interpolation method to compute
g
rrk,αfα(0)
1 =
L∏
j=0
b
λj
j , (1)
where λj =
(−i0)(−i1)···(−ij−1)(−ij+1)···(−iL)
(ij−i0)(ij−i1)···(ij−ij−1)(ij−ij+1)···(ij−iL) (mod q), i0 = k.
– Compute the session key
meˆ(gρ, hα)r · grrk,αfα(0)1
eˆ(gr, grk,αfα(0)hρα)
=
meˆ(gρ, hα)r · grrk,αfα(0)1
eˆ(gr, hρα) · grrk,αfα(0)1
= m. (2)
– Use m to decrypt the ciphertext body C to obtain the message M .
Correctness. We can easily see that the scheme is correct by Equation (2).
3.1 Performance Analysis
For each system, the public key is (Id, H1, H2, E,G,G1, eˆ, g, gρ), which is of
size O(1). Since all systems can use the same (H,E,G,G1, eˆ, g), the public key
speciﬁc to a system is simply (Id, gρ). Each system dealer has a secret ρ for
assigning private keys to its users. Each user Uk holds private keys SKk =
{sk,0, sk,1, . . . , sk,log N}, each corresponding to a share of polynomial fi in the
masked form, 0 ≤ i ≤ logN . The number of private keys is O(logN). When r
users are revoked, we choose the polynomial fα of degree 2α for encrypting the
session key, where 2α−1 < r ≤ 2α. Thus, the header size is O(2α) = O(r). It is
actually no more than 2r.
To prepare a header, the broadcaster needs to compute one pairing function,
2α+2 hash functions, and 2α+2 modular exponentiations, which is O(r) modular
exponentiations.
For a user in S to decrypt a header, with a little re-arrangement of Equation
(1) as
L∏
j=0
b
λj
j = b
λ0
0 · eˆ(grk,α ,
L∏
j=1
(grfα(ij))λj ),
the user needs to perform 3 pairing functions and 2α modular exponentiations,
which is O(r) modular exponentiations. The evaluation of λj ’s can be done in
O(L) = O(2r) if the header consists of
λ˜j =
(−i1) · · · (−ij−1)(−ij+1) · · · (−iL)
(ij − i1) · · · (ij − ij−1)(ij − ij+1) · · · (ij − iL) mod q, 1 ≤ j ≤ L.
The user can easily compute λj ’s from λ˜j ’s. Inclusion of λ˜j ’s in the header does
not aﬀect the order of the header size.
Public Key Broadcast Encryption with Low Number of Keys 389
If the query has ever been asked, we return the stored hash value for the query.
For other non-queried inputs, we return random values in G.
We should check whether the distributions of the parameters in our reduction
and those in the system are equal. We only check those related to α since the
others are correctly distributed. Since τ, w1, w2, . . . , wL are randomly chosen,
ga
(α)
i , 0 ≤ i ≤ L are uniformly distributed over GL+1. Due to the random oracle
model, their corresponding system parameters are also uniformly distributed
over GL+1. Since κ, μ1, μ2, . . . , μL are randomly chosen, the distribution of hα
and gri,α , 1 ≤ i ≤ L, are uniform over GL+1, which is again the same as that
of the corresponding system parameters. The distributions of gr in the header
and gρ in the public key are both uniform over G since they are set from the
given input gc and ga, respectively. Since the session key m is chosen randomly
from G1, meˆ(gρ, hα)r is distributed uniformly over G1. We set it to a random
value y ∈ G1. Even though we don’t know about m, it does not aﬀect the
reduction. Other parameters are dependent on what have been discussed. We
can check that they are all computed correctly. So, the reduction preserves the
right distribution.
If the revoked users compute m from the header with probability , we can
solve the BDH problem with the same probability 1 =  by computing the
following:
y · m−1 · eˆ(ga, gc)−κ = eˆ(gρ, hα)r · eˆ(g, g)−acκ
= eˆ(ga, gb+κ)c · eˆ(g, g)−acκ
= eˆ(g, g)abc. (3)
Let t′ be the time for this reduction and the solution computation in Equation
(3). We can see that t′ is polynomially bounded. Thus, if the collusion attack of the
revoked users takes t1 − t′ time, we can solve the BDH problem within time t1.
4 The BE-PI Scheme with IND-CCA Security
In Theorem 1, we show that the session key in the header is one-way secure
against any collusion of revoked users. There are some standard techniques of
transforming OW-CPA security to IND-CCA security. Here we present such a
scheme Π ′ based on the technique in [9].
The IND-CCA security of the Fujisaki-Okamoto transformation depends only
on the OW-CPA security of the public key encryption scheme, the FG security
of a symmetric encryption scheme E , and the γ-uniformity of the public key
encryption scheme. The FG-security is the counterpart of the IND-security for
symmetric encryption. A public key encryption scheme is γ-uniform if for every
key pair (pk, sk), every message x, and y ∈ {0, 1}∗, Pr[Epk(x) = y] ≤ γ. Before
applying the transformation, we check the following things:
1. The transformation applies to public key encryption, while ours is public key
broadcast encryption. Nevertheless, if the authorized set S is ﬁxed, our public
Public Key Broadcast Encryption with Low Number of Keys 391
the subsets in C, that is, S = ∪wi=1Sw, where Si ∈ C are disjoint, 1 ≤ i ≤ w. Each
subset Si in C is associated with a private key ki. A user is assigned a set of keys
such that he can derive the private keys of the subsets to which he belongs. The
subset keys ki cannot be independent. Otherwise, each user may hold too many
keys. It is preferable that the subset keys have some relations, for example, one
can be derived from another. Thus, each user Uk is given a set SKk of keys so
that he can derive the private key of a subset to which he belongs. A subset-cover
based broadcast encryption scheme plays the art of choosing a collection C of
subsets, assigning subset and user keys, and ﬁnding subset covers.
5.1 The PK-SD-PI Scheme
We now present our PK-SD-PI scheme, which is constructed by using the poly-
nomial interpolation technique on the collection of subsets in [16]. The system
setup is similar to that of the BE-PI scheme. Consider a complete binary tree T
of logN + 1 levels. The nodes in T are numbered diﬀerently. Each user in U is
associated with a diﬀerent leaf node in T . We refer to a complete subtree rooted
at node i as ”subtree Ti”. For each subtree Ti of η levels (level 1 to level η from
top to bottom), we deﬁne the degree-1 polynomials
f
(i)
j (x) = a
(i)
j,1x + a
(i)
j,0 (mod q),
where a(i)j,0 = lgH2(Id‖i‖j‖0) and a(i)j,1 = lgH2(Id‖i‖j‖1), 2 ≤ j ≤ η. For a user
Uk in the subtree Ti of η levels, he is given the private keys
sk,i,j = (grk,i,j , grk,i,jf
(i)
j (ij), grk,i,jf
(i)
j (0)hρ)
for 2 ≤ j ≤ η, where nodes i1, i2, . . . , iη are the nodes in the path from node i
to the leaf node for Uk (including both ends). We can read sk,i,j as the private
key of Uk for the jth level of subtree Ti. In Figure 1, the private keys (in the
unmasked form) of U1 and U3 for subtree Ti with η = 4 are given. Here, we use
hρ in all private keys in order to save space in the header.
Recall that in the SD scheme, the collection C of subsets is
{Si,t : node i is a parent of node t, i = t},
where Si,t denotes the set of users in subtree Ti, but not in subtree Tt. By our
design, if the header contains a masked share for f (i)j (t), where node t is in the
j-th level of subtree Ti, only user Uk in Si,t can decrypt the header by using his
private key sk,i,j , that is, the masked form of f
(i)
j (s), for some s = t. In Figure 1,
the share f (i)3 (t) is broadcasted so that only the users in Si,t can decrypt the
header.
For a set R of revoked users, let Si1,t1 , Si2,t2 , . . ., Siz ,tz be a subset cover for
U\R, the header is
(meˆ(gρ, h)r, gr, (i1, t1, g
rf
(i1)
j1
(t1)), . . . , (iz, tz, grf
(iz)
jz
(tz))),
where node tk is in the jk-th level of subtree Tik , 1 ≤ k ≤ z.
Public Key Broadcast Encryption with Low Number of Keys 393
and H2, all polynomials are independent. Thus, we can simply consider a partic-
ular Sα,t in the subset cover for S∗ = U\R, where t is at level β of subtree Tα.
The corresponding polynomial is f(x) = f (α)β (x) = a1x + a0 (mod q). Wlog, let
{U1, U2, . . . , Ul} be the set of revoked users that have the secret share about f(t).
The reduction to the BDH problem is as follows. Recall that the public key of the
PK-SD-PI method is (Id, H1, H2, E,G,G1, eˆ, g, gρ).
1. Let g be the generator in the system and gρ = ga.
2. Set f(t) = w and compute gf(t) = gw, where w is randomly chosen from Zq.
3. Let ga0 = gf(0) = ga · gτ , where τ is randomly chosen from Zq.
4. Compute ga1 from gf(t) and ga0 via the Lagrange interpolation.
5. The (random) hash values H2(Id‖α‖β‖0) and H2(Id‖α‖β‖1) are set as ga0
and ga1 respectively.
6. Set h = gb · gκ, where κ is randomly chosen from Zq.
7. The f(x)-related secret share of Ui, 1 ≤ i ≤ l, is computed as (gri , grif(t),
grif(0)hρ), where gri = g−b · gμi and μi is randomly chosen from Zq. Note
that grif(0)hρ = ga(μi+κ)−bτ+μiτ can be computed from the setting in the
previous steps.
8. The non-f(x)-related secret shares of Ui, 1 ≤ i ≤ l, can be set as follows.
Let f ′ be a polynomial related to subtree α′ and level β′, where t′ is in the
β′-th level and Ui ∈ Sα′,t′ . The secret share (gr′i , gr′if ′(t′), gr′if ′(0)hρ) of Ui is
computed from (gri , grif(t), grif(0)hρ). Let f ′(t′) = w′, f ′(0) = f(0)+ a′ and
r′i = ri + r
′, where w′, a′, and r′ are randomly chosen from Zq. Thus, gr
′
i =
gri ·gr′ , gr′if ′(t′) = (gr′i)w′ and gr′if ′(0)hρ = (grif(0)hρ)·gr′f(0)·gria′ ·gr′a′ . Note
that the hash values H2(Id‖α′‖β′‖0) and H2(Id‖α′‖β′‖1) can be answered
accordingly.
9. Set the challenge as
(y, gc, (i1, t1, g
cf
(i1)
j1
(t1)), (i2, t2, g
cf
(i2)
j2
(t2)), . . . , (iz, tz, gcf
(iz)
jz
(tz))),
where y is randomly chosen from G and thought as meˆ(gρ, h)c. Note that
g
cf
(ik)
jk
(tk), 1 ≤ k ≤ z, can be computed since f (ik)jk (tk) is a number randomly
chosen from Zq, as described in Step 2.
If the revoked users U1, U2, . . . , Ul can together compute the session key m
from the challenge with probability 1, we can compute
y · m−1 · eˆ(ga, gc)−κ = eˆ(gρ, h)c · eˆ(g, g)−acκ
= eˆ(ga, gb+κ)c · eˆ(g, g)−acκ = eˆ(g, g)abc (4)
with the same probability 1. This contradicts the BDH assumption.
Let t′ be the time for the reduction and solution computation in Equation
(4), where t′ is polynomially bounded. Thus, if the collusion attack takes t1 − t′,
we can solve the BDH problem in time t1.
Similarly, we can modify our PK-SD-PI scheme to have IND-CCA security like
Section 4
Public Key Broadcast Encryption with Low Number of Keys 395
With the same extension in [12], we can have a PK-LSD-PI scheme that
has O(1) public keys and O(log1+) private keys, for any constant 0 <  < 1.
The header size is O(r/), which is O(r) for a constant . The decryption cost
excluding the time of scanning the header is again O(1).
6 Conclusion
We have presented very eﬃcient public key BE schemes. They have low public
and private keys. Two of them even have a constant decryption time. Our results
show that the eﬃciency of public key BE schemes is comparable to that of
private-key BE schemes.
We are interested in reducing the ciphertext size while keeping other com-
plexities low in the future.
Acknowledgement
We thankEikeKiltz andMichelAbdalla for valuable comments on themanuscript.
References
1. Attrapadung, N., Imai, H.: Graph-decomposition-based frameworks for subset-
cover broadcast encryption and eﬃcient instantiations. In: Roy, B. (ed.) ASI-
ACRYPT 2005. LNCS, vol. 3788, pp. 100–120. Springer, Heidelberg (2005)
2. Boneh, D., Boyen, X., Goh, E.-J.: Hierarchical identity based encryption with
constant size ciphertext. In: Cramer, R.J.F. (ed.) EUROCRYPT 2005. LNCS,
vol. 3494, pp. 440–456. Springer, Heidelberg (2005)
3. Boneh, D., Franklin, M.: An eﬃcient public key traitor tracing scheme. In: Wiener,
M.J. (ed.) CRYPTO 1999. LNCS, vol. 1666, pp. 338–353. Springer, Heidelberg
(1999)
4. Boneh, D., Gentry, C., Waters, B.: Collusion resistant broadcast encryption with
short ciphertexts and private keys. In: Shoup, V. (ed.) CRYPTO 2005. LNCS,
vol. 3621, pp. 258–275. Springer, Heidelberg (2005)
5. Boneh, D., Waters, B.: A fully collusion resistant broadcast, trace, and revoke
system. In: Proceedings of the ACM Conference on Computer and Communications
Security - CCS 2006, pp. 211–220. ACM Press, New York (2006)
6. Dodis, Y., Fazio, N.: Public key broadcast encryption for stateless receivers. In:
Feigenbaum, J. (ed.) DRM 2002. LNCS, vol. 2696, pp. 61–80. Springer, Heidelberg
(2003)
7. Dodis, Y., Fazio, N.: Public key broadcast encryption secure against adaptive cho-
sen ciphertext attack. In: Desmedt, Y.G. (ed.) PKC 2003. LNCS, vol. 2567, pp.
100–115. Springer, Heidelberg (2002)
8. Fiat, A., Naor, M.: Broadcast encryption. In: Stinson, D.R. (ed.) CRYPTO 1993.
LNCS, vol. 773, pp. 480–491. Springer, Heidelberg (1994)
9. Fujisaki, E., Okamoto, T.: Secure integration of asymmetric and symmetric en-
cryption schemes. In: Wiener, M.J. (ed.) CRYPTO 1999. LNCS, vol. 1666, pp.
537–554. Springer, Heidelberg (1999)
A Public-Key Traitor Tracing Scheme with an
Optimal Transmission Rate
Yi-Ruei Chen and Wen-Guey Tzeng
Department of Computer Science
National Chiao Tung University
Hsinchu, Taiwan 30010, ROC
yrchen.cs98g@nctu.edu.tw, wgtzeng@cs.nctu.edu.tw
Abstract. The way of transmitting the encrypted digital content to
the legitimate subscribers over a broadcast channel has wide commer-
cial applications, such as Pay-TV, DVD, etc. In order to discourage
the legitimate subscribers from giving away their decryption keys, the
traitor tracing scheme comes up. In this paper, we propose a public-key
traitor tracing scheme that has optimal transmission rate. In other words,
our scheme enables everyone to transmit the encrypted digital contents
almost without any redundancy. As for tracing, our scheme supports
black-box tracing, i.e., identifying colluders without opening the pirate
decoder. Moreover, in our scheme, the storage requirement for legitimate
subscribers and digital content broadcasters is smaller than that of pre-
vious schemes.
Keywords: Traitor tracing, transmission rate, ﬁngerprinting code.
1 Introduction
Consider the scenario that a data supplier distributes the digital content over
a broadcast channel. The data supplier gives a secret key to each legitimate
subscriber. Then the data supplier broadcasts the encrypted digital content and
the legitimate subscribers decrypt the digital content by their secret keys. The
protection for some Pay-TV, CD-ROM, DVD, and online databases is based on
this scenario. However, some malicious subscribers (called traitors) might give
copies of their secret keys to illegitimate users (called pirates). Then the pirates
decrypt the digital content for free. In order to solve the problem above, the
traitor tracing scheme comes up.
The goal of traitor tracing schemes is to discourage legitimate subscribers from
giving away their secret keys. One approach is to give each subscriber a unique
set of secret keys that both decrypt the encrypted digital content and identify
(“trace”) the subscribers. To avoid being traced by a tracer, the traitors may
collude to obfuscate their secret keys and generate a new secret key set (called
 The research was supported in part by projects NSC 96-2628-E-009-011-MY3 and
98-2219-E-009-003-
S. Qing, C.J. Mitchell, and G. Wang (Eds.): ICICS 2009, LNCS 5927, pp. 121–134, 2009.
c© Springer-Verlag Berlin Heidelberg 2009
A Public-Key Traitor Tracing Scheme with an Optimal Transmission Rate 123
Table 1. Scheme Comparison
transmission user-key public-key black-box traceability
rate size size tracing
BF99 [2] 2t + 1 2t 2t + 1 ineﬃcient private
BSW06 [4] 6
√
N 1 4
√
N + 2 O public
KY02 [13] ∼ 3 2 4 O private
CPP05 [8] ∼ 1 2  + 1 X private
FNP07 [11] ∼ 1 2 10 O private
Ours ∼ 1  + 2 2 + 1 O private
† : the codeword length in ﬁngerprinting code
† N : the total number of legitimate subscribers
requirements in our scheme for user-keys and pubic-keys are smaller than previ-
ous schemes that have the constant (or optimal) transmission rate. Our scheme
is based on a ﬁngerprinting code, and an all-or-nothing transformation [6,7,19].
The idea is to encrypt a block of the output of an all-or-nothing transformation
by a special public-key scheme. The encryption does not entail much overhead
and allows us to feed indistinguishable messages for tracing. The comparison
with other related schemes is given in Table 1. We show that our scheme is se-
mantically secure based on the DDH assumption and the indistinguishability of
PKE-AONT. We also show that our traitor tracing scheme is t-collusion resistant
under the DDH assumption.
2 Preliminaries
Notations. A function f : N → R is negligible if for every constant c ∈ N, there
exists an integer k0 ∈ N such that f(k) ≤ k−c for all k ≥ k0, denoted by neg(k).
We use x $←− X to denote that x is chosen from the set X uniformly. Let M be
the plaintext space.
Fingerprinting Codes. The ﬁngerprinting technique with ﬁngerprinting codes
embeds a speciﬁc ﬁngerprint (codeword) to each document copy so that one can
identify which copy of document by examining the embedded ﬁngerprint. The
codeword is a collection of some alphabets. The traitors will collude and try to
modify their codewords to avoid being identiﬁed. However, the coalition of the
traitors is restricted by the marking assumption: the traitors are only able to com-
pare their codewords and make a modiﬁcation from their respective codewords
diﬀering in some positions. Under the marking assumption, the possible modiﬁed
codeword set from t traitor’s codewords set W is called a feasible set of W .
– For a codeword w ∈ {0, 1}, we write w = w1w2...w, where wi ∈ {0, 1}.
– Let W = {w(1), ..., w(t)} ⊆ {0, 1}. We say that a codeword w¯ is feasible for
W if ∀i ∈ {1, 2, ...} ∃j ∈ {1, 2, ..., t} s.t. w¯i = w(j)i . For example, if W =
{0101, 1111}, the codewords {0101, 0111, 1101, 1111} are feasible for W .
– For a codeword set W ⊆ {0, 1}, we say that the feasible set of W , denoted
by F (W ), is the set of all codewords that are feasible for W .
A Public-Key Traitor Tracing Scheme with an Optimal Transmission Rate 125
3 The Notion for Public-Key Traitor Tracing Scheme
A public-key traitor tracing scheme is a 4-tuple of probabilistic polynomial-time
algorithms (Setup,Encrypt,Decrypt,Trace), where
Setup(1λ, N). The setup takes as input a security parameter λ and N , the
number of users in the system. The algorithm outputs a public broadcast-key
BK, a secret trace-key TK, and the private user-key SKu for each legitimate
subscriber u.
Encrypt(BK,M). The encryption algorithm takes as input the public broadcast-
key BK and a message M ∈ M. The algorithm outputs a ciphertext C.
Decrypt(SKu, C). The decryption algorithm takes as input the private user-key
SKu of user u and a ciphertext C. The algorithm outputs a message M or
⊥.
TraceD(TK). The tracing algorithm takes as input the private trace-key TK and
queries the pirate decoder D as a black-box oracle. The algorithm outputs a
traitor set S which is a subset of {1, ..., N}.
Moreover, the scheme must satisfy the correctness property as follows:
For all u ∈ {1, ..., N} and for all M ∈ M: if 〈BK,TK, (SK1, ...,SKN )〉 $←−
Setup(1λ, N) and C $←− Encrypt(BK,M), then Decrypt(SKu, C) = M .
Semantic Security Game
– Setup. The challenger runs Setup, and gives BK to the adversary.
– Challenge. The adversary chooses two plaintexts M0,M1 ∈ M to the chal-
lenger. Then the challenger ﬂips a coin b ∈ {0, 1}, and gives a ciphertext
Cb
$←− Encrypt(BK,Mb) to the adversary.
– Guess. The adversary returns a guess b′ ∈ {0, 1} of b to the challenger.
The advantage of winning this game by the adversary is AdvTTSSS := |Pr[b′ =
b]− 12 |
Deﬁnition 1 (Semantically secure). An N -user public-key traitor tracing
scheme is semantically secure if for all polynomial time adversaries A, AdvTTSSS
is a negligible function of the security parameter.
Traceable against t-collusion Game
– Setup. The challenger runs Setup and gives BK to the adversary. The ad-
versary chooses a traitor set T = {u1, ..., ut} ⊆ {1, ..., N} to the challenger.
Then the challenger gives the adversary SKu1 , ...,SKut to produce a pirate
decoder D.
– Trace. By taking a pirate decoder D as a decryption oracle, the challenger
runs the algorithm TraceD(TK) to obtain a traitor set S ⊆ {1, ..., N}.
The adversary wins this game if (1) D decrypts all valid ciphertext with a con-
stant probability δ, i.e., Pr[D(Encrypt(BK,M)) = M ] ≥ δ, and (2) S ∩ T = ∅.
The probability of adversary winning this game is AdvTTSTR .
A Public-Key Traitor Tracing Scheme with an Optimal Transmission Rate 127
– Setup. Algorithm B is given as input an instance (g, gu, gv, X) of the DDH
assumption, and it wants to determine whether X = guv or X is a random
element in   (  has prime order q). B chooses a0, a1 $←− ∗q and sets bk =
〈g, (gu, ga1)〉 to A. (we see that f(x) = u + a1x (mod q))
– Challenge. A chooses two plaintexts m0,m1 ∈ M to B, then B ﬂips a coin
b ∈ {0, 1}, and sets the challenge cb = 〈mbX, gv, (j,X(gv)a1j)〉 to A, where
j
$←− ∗q .
– Guess. A outputs b′ ∈ {0, 1} to B. If b′ = b, B answers that X = guv; else B
answers that X is a random element in  .
If X = guv, A gets a valid ciphertext cb = 〈mbguv, gv, (j, gv(u+a1j))〉. Therefore,
A answers b′ = b successfully with probability 12 + ;
If X is a radom element in  , A gets an invalid ciphertext. In this case, A
answers b′ = b successfully with probability 12 .
Hence, B solves the DDH problem with non-negligible advantage . This is a
contradiction to the DDH assumption. So we conclude that such adversary A
does not exist.
Theorem 2. The 2-PK-TTS scheme is traceable against 1-collusion under the
DDH assumption.
Proof. By contradiction, assume that there exists an adversary A that, given
the public-key bk and one of user-keys skσ in 2-PK-TTS scheme, A produces
a pirate decoder D that decrypts all valid ciphertexts perfectly, i.e., Pr[D(2-
Encrypt(bk,m)) = m : D $←− A(bk, skσ), σ ∈ {0, 1}] = 1. But when given a probe
ciphertext cˆ, D outputs a diﬀerent value from the pre-computed values in 2-Trace
algorithm with non-negligible probabilistic  > 0, i.e., Pr[D(cˆ) = A/Vσ] = . We
construct an algorithm B that breaks the DDH assumption with non-negligible
advantage 2 as follows:
– Setup. Algorithm B is given as input an instance (g, gu, gv, X) of DDH as-
sumption, and it wants to determine whether X = guv or X is a random
element in  . B chooses i, z $←− ∗q and gives A bk = 〈g, (gu, ga1 = ( g
z
gu )
i−1)〉.
A chooses a traitor set T = {0} or {1} to B. Then B gives A sk = 〈i, z〉 to
produces a pirate decoder D.
– Trace. By taking a pirate decoder D as a decryption oracle, B runs the
modiﬁed 2-Trace as follows:
1. Choose A $←−   , and j $←− ∗q , where j = i. Compute W = X( (g
v)z
X )
ji−1
and set the ciphertext as c¯ ← 〈A, gv, (j,W )〉.
2. Pre-compute V ← W −ij−i (gv)z −ji−j .
3. If D(c¯) = A/V , B answers that X = guv or X is a random element in  
randomly; else B answers that X is a random element in  .
If X = guv, ciphertext c¯ is a valid ciphertext, since
X(
(gv)z
X
)ji
−1
= guv(
(gv)z
guv
)ji
−1
= guv((
gz
gu
)i
−1
)vj = guv(ga1)vj = gv(u+a1j).
In this case, D(c¯) = A/V , B gives the correct answer with probability 12 ;
A Public-Key Traitor Tracing Scheme with an Optimal Transmission Rate 129
Our traitor tracing scheme for N users Π = (Setup,Encrypt,Decrypt,Trace) is
as follows:
Setup(1λ, N). Given a security parameter λ and user number N , the algorithm
generates a ﬁngerprinting code Γ = {w(1), ..., w(N)} ∈ ({0, 1})N for some .
Then it runs 2-Setup  times to generate the keys 〈(bki, tki, (sk0,i, sk1,i))Ni=1〉
(but use the same q, , g, i0, i1) and sets
– Public broadcast-key BK := 〈g, (ga0,j , ga1,j )j=1〉
(we denote the k-th key of BK by BKk = (g, (ga0,k, ga1,k)))
– Secret trace-key TK := 〈(fj(x))j=1〉
– User-key SKu := 〈w(u), i0, i1, (fj(iw(u)j )

j=1〉, ∀u ∈ {1, 2, ..., N}
(we denote k-th key of SKu by SKu,k = (iw(u)k
, fk(iw(u)k
)))
Encrypt(BK,M ′). Given BK and a plaintext M ′ ∈M′ , the algorithm chooses a
random string ρ $←− {0, 1}τ , and computes Σ(M ′; ρ) = M = m1||...||m. Then
it chooses a position index k $←− {1, 2, ..., }, and computes the ciphertext
C
$←− 〈k, 2-Encrypt(BKk,mk),MINUSk(M)〉.
Decrypt(SKu, C). Given a ciphertext C = 〈k, ck, Y 〉, user u computes mk ←
2-Decrypt(SKu,k, ck) and M ′ = Σ−1(COMBk(Y,mk)).
TraceD(TK). Given a pirate decoder D that decrypts all valid ciphertext per-
fectly as a decryption oracle. The algorithm does:
– For each position index k ∈ {1, 2, ..., },
1. Compute Σ(M ′; ρ) = M = m1||m2||...||m, where M ′ $←− M′ and
ρ
$←− {0, 1}τ .
2. Call 2-TrEncrypt(BKk,mk)
$−→ cˆk = 〈Ak = mkgra0,k , R=gr, (j, Wˆk =
grˆfk(j)))〉. Set the probe ciphertext as Cˆ $←− 〈k, cˆk, Y = MINUSk(M)〉.
3. ∀σ ∈ {0, 1}, pre-compute Mk,σ = COMBk(Y,Ak/Wˆ
−iσ
j−iσ
k R
fk(iσ)
−j
iσ−j ).
4. ∀σ ∈ {0, 1}, if Σ(D(Cˆ); ρ) = Mk,σ, set w∗k = σ; else set w∗k = 0 for
convenience.
– Recover w∗ = w∗1w
∗
2 ...w
∗
 , then call the tracing algorithm in ﬁngerprint-
ing code by taking w∗ as the input to obtain collude codewords. Finally,
output the corresponding traitor set S.
5.2 Security Analysis of Our Scheme
Theorem 3. The scheme Π is semantically secure under the semantic security
of 2-PK-TTS and the indistingushability of PKE-AONT.
Proof. For each position index k ∈ {1, 2, ..., }, we use two games to bound the
advantage of semantically secure in Π with Adv2-PK-TTSSS and Adv
PKE-AONT
ind as
follows:
Game G0. Deﬁne G0 as the original semantic security game and let S0 be the
event where b′ = b, i.e., AdvΠSS := |Pr[S0]− 12 |.
A Public-Key Traitor Tracing Scheme with an Optimal Transmission Rate 131
Hence, by the discussion above and the triangle inequality,
|Pr[S0]| = |Pr[S0]− Pr[S1] + Pr[S1]|
≤ |Pr[S0]− Pr[S1]|+ |Pr[S1]|
= 2Adv2-PK-TTSSS + Adv
PKE-AONT
ind +
1
2
.
Since Adv2-TTSSS and Adv
PKE-AONT
ind are two negligible functions of λ, we conclude
that the advantage of A winning the semantic security game is bounded by a
negligible function of λ.
Theorem 4. The scheme Π is traceable against t-collusion under the DDH as-
sumption.
Proof. By contradiction, assume that there exists an adversaryA that, given the
public key BK, t of user keys {SKu1 , SKu2 , ...,SKut} and an AONT Σ, produces
a pirate decoder D that decrypts all valid ciphertexts perfectly. But when given
a probe ciphertext, D outputs a diﬀerent value from the pre-computed values
in Trace algorithm with non-negligible probabilistic  > 0, i.e., Pr[Σ(D(Cˆ); ρ) =
Mk,σ] = . We construct an algorithm B that breaks the DDH assumption with
non-negligible advantage 2 as follows:
– Setup. Algorithm B is given as input an instance (g, gu, gv, X) of DDH
assumption, and it wants to determine whether X = guv or X is a ran-
dom element in   (  has prime order q). B chooses a position index k $←−
{1, 2, ..., }, chooses fj(x) = a0,j + a1,jx (modq), where a0,j, a1,j $←− ∗q , ∀j ∈
{1, 2, ..., }, chooses i0, i1, z $←− ∗q and gives A BK = 〈g, (ga0,j , ga1,j )j=1〉
but repalces ga0,k by gu and ga1,k by ( g
z
gu )
i−1σ , where σ $←− {0, 1}. A chooses
a traitor set T ⊆ {1, ..., N} of size t to B. Then B chooses t codewords
w(u1), w(u2), ..., w(ut)
$←− Γ (even if Γ is public, the information of which user
get which codeword can be hiden, so B can choose t codewords by his own)
satisfy w(u1)k = w
(u2)
k = ... = w
(ut)
k = σ (the existence of these codewords is
guaranteed by the ﬁngerprinting codes) and sets A the keys
SKu1 = 〈w(u1), i0, i1, (f1(iw(u1)1 ), ..., fk−1(iw(u1)k−1 ), z, fk+1(iw(u1)k+1 ), ..., f(iw(u1) ))〉,
SKu2 = 〈w(u2), i0, i1, (f1(iw(u2)1 ), ..., fk−1(iw(u2)k−1 ), z, fk+1(iw(u2)k+1 ), ..., f(iw(u2) ))〉,
...
SKut = 〈w(ut), i0, i1, (f1(iw(ut)1 ), ..., fk−1(iw(ut)k−1 ), z, fk+1(iw(ut)k+1 ), ..., f(iw(ut) ))〉,
to produces a pirate decoder D.
– Trace. By taking a pirate decoder D as a decryption oracle, B runs the
modiﬁed Trace algorithm as follows:
A Public-Key Traitor Tracing Scheme with an Optimal Transmission Rate 133
2. Boneh, D., Franklin, M.K.: An eﬃcient public key traitor scheme (Extended
abstract). In: Wiener, M. (ed.) CRYPTO 1999. LNCS, vol. 1666, pp. 338–353.
Springer, Heidelberg (1999)
3. Boneh, D., Naor, M.: Traitor tracing with constant size ciphertext. In: Ning, P.,
Syverson, P.F., Jha, S. (eds.) ACM Conference on Computer and Communications
Security, pp. 501–510. ACM, New York (2008)
4. Boneh, D., Sahai, A., Waters, B.: Fully collusion resistant traitor tracing with short
ciphertexts and private keys. In: Vaudenay, S. (ed.) EUROCRYPT 2006. LNCS,
vol. 4004, pp. 573–592. Springer, Heidelberg (2006)
5. Boneh, D., Shaw, J.: Collusion-secure ﬁngerprinting for digital data. IEEE Trans-
actions on Information Theory 44(5), 1897–1905 (1998)
6. Boyko, V.: On the security properties of oaep as an all-or-nothing transform. In:
Wiener, M. (ed.) CRYPTO 1999. LNCS, vol. 1666, pp. 503–518. Springer, Heidel-
berg (1999)
7. Canetti, R., Dodis, Y., Halevi, S., Kushilevitz, E., Sahai, A.: Exposure-resilient
functions and all-or-nothing transforms. In: Preneel, B. (ed.) EUROCRYPT 2000.
LNCS, vol. 1807, pp. 453–469. Springer, Heidelberg (2000)
8. Chabanne, H., Phan, D.H., Pointcheval, D.: Public traceability in traitor tracing
schemes. In: Cramer, R. (ed.) EUROCRYPT 2005. LNCS, vol. 3494, pp. 542–558.
Springer, Heidelberg (2005)
9. Chor, B., Fiat, A., Naor, M.: Tracing traitors. In: Desmedt, Y.G. (ed.) CRYPTO
1994. LNCS, vol. 839, pp. 257–270. Springer, Heidelberg (1994)
10. Chor, B., Fiat, A., Naor, M., Pinkas, B.: Tracing traitors. IEEE Transactions on
Information Theory 46(3), 893–910 (2000)
11. Fazio, N., Nicolosi, A., Phan, D.H.: Traitor tracing with optimal transmission rate.
In: Garay, J.A., Lenstra, A.K., Mambo, M., Peralta, R. (eds.) ISC 2007. LNCS,
vol. 4779, pp. 71–88. Springer, Heidelberg (2007)
12. Furukawa, J., Attrapadung, N.: Fully collusion resistant black-box traitor revocable
broadcast encryption with short private keys. In: Arge, L., Cachin, C., Jurdzin´ski,
T., Tarlecki, A. (eds.) ICALP 2007. LNCS, vol. 4596, pp. 496–508. Springer, Hei-
delberg (2007)
13. Kiayias, A., Yung, M.: Traitor tracing with constant transmission rate. In: Knud-
sen, L.R. (ed.) EUROCRYPT 2002. LNCS, vol. 2332, pp. 450–465. Springer, Hei-
delberg (2002)
14. Kurosawa, K., Desmedt, Y.G.: Optimum traitor tracing and asymmetric schemes.
In: Nyberg, K. (ed.) EUROCRYPT 1998. LNCS, vol. 1403, pp. 145–157. Springer,
Heidelberg (1998)
15. Naor, M., Pinkas, B.: Threshold traitor tracing. In: Krawczyk, H. (ed.) CRYPTO
1998. LNCS, vol. 1462, pp. 502–517. Springer, Heidelberg (1998)
16. Naor, M., Pinkas, B.: Eﬃcient trace and revoke schemes. In: Frankel, Y. (ed.) FC
2000. LNCS, vol. 1962, pp. 1–20. Springer, Heidelberg (2001)
17. Phan, D.H.: Traitor tracing for stateful pirate decoders with constant ciphertext
rate. In: Nguyeˆn, P.Q. (ed.) VIETCRYPT 2006. LNCS, vol. 4341, pp. 354–365.
Springer, Heidelberg (2006)
18. Phan, D.H., Safavi-Naini, R., Tonien, D.: Generic construction of hybrid public
key traitor tracing with full-public-traceability. In: Bugliesi, M., Preneel, B., Sas-
sone, V., Wegener, I. (eds.) ICALP 2006. LNCS, vol. 4052, pp. 264–275. Springer,
Heidelberg (2006)
1Key Establishment Schemes Against
Storage-Bounded Adversaries in Wireless Sensor
Networks
Shi-Chun Tsai, Wen-Guey Tzeng, Kun-Yi Zhou
Abstract—In this paper we re-examine the attacking scenario
about wireless sensor networks. It is generally assumed that the
adversary picks up all radio communications of sensor nodes
without any loss and stores the eavesdropped messages for later
use. We suggest that in some situations the adversary may not
be able to pick up all radio communications of sensor nodes.
Therefore, we propose the storage-bounded adversary model for
wireless sensor networks, in which the adversary’s storage is
bounded.
We propose two key establishment schemes for establishing
shared keys for neighboring sensor nodes in the storage-bounded
adversary model. The first scheme needs special beacon nodes
for broadcasting random bits. In the second scheme, some sensor
nodes play the role of beacon nodes. Our results are theoretical
in some sense. Nevertheless, we can adjust them for realistic
consideration.
Index Terms—Bounded-storage model, key establishment, un-
conditional security, wireless sensor network.
I. INTRODUCTION
A wireless sensor network usually consists of a large
number of small autonomous sensor nodes. Each sensor node
has some level of computing power, a limited size of storage,
a set of sensors for exploring the environment and a small
antenna for communicating with the outside world. One way of
deploying a wireless sensor network is to scatter senor nodes in
the field randomly. Then, these sensor nodes form a network
autonomously via their built-in programs. Due to restriction
of small antenna, each sensor node can communicate with its
geographic neighbors only. We say that two sensor nodes are
neighbored if they can communicate with each other via radio
directly. In some situations, we may deploy a set of special
nodes, called beacon nodes, for broadcasting instructions and
data to the sensor nodes. A beacon node is more powerful so
that its radio signal could cover a larger area.
There are some security issues about wireless sensor net-
works, such as, communication security, message authentica-
tion, node authentication, etc. We are concerned about the key
establishment problem, which is to establish a shared (secret)
The authors are with Computer Science Department, National Chiao Tung
University, Hsinchu, Taiwan 30050. Their emails are sctsai@cs.nctu.edu.tw,
wgtzeng@cs.nctu.edu.tw, and kyzhou@cs.nctu.edu.tw. The corresponding au-
thor is Professor Wen-Guey Tzeng
Research supported in part by projects NSC-96-2628-E-009-011-
MY3, NSC-97-2221-E-009-064-MY3 NSC-97-2219-E-009-006 (TWISC),
and MoE-97W803.
Manuscript received August 06, 2008; revised October 02, 2008; accepted,
November 08, 2008.
The corresponding Associate Editor is Professor Dapeng Wu.
key for two neighboring sensor nodes via the public radio link.
The established key is later used for secure communication
(encryption) or authentication. The key establishment problem
for wireless sensor networks has been studied actively. In this
paper we re-examine the attacking scenario about wireless
sensor networks. It is generally assumed that the adversary
picks up all radio communications of sensor nodes without any
loss and stores the eavesdropped messages for later use. We
suggest that this may not be the case. For example, the radio
quality of a sensor node is not very good and its coverage area
is small. It is hard for the adversary to get all communications
between sensor nodes. Therefore, we propose the storage-
bounded adversary model for wireless sensor networks to
capture the nature of incomplete eavesdropping. In this model,
the adversary cannot eavesdrop all communications of the
sensor nodes. We could conceptually think that the adversary’s
storage is limited so that it cannot store all communications.
The storage-bounded adversary model has been studied in
the cryptographic field for its advanced view. It explores the
possibility of encryption in the era of quantum computation.
We bring the model to wireless sensor networks for exploring
an alternative adversary model.
By considering the storage-bounded adversary, we propose
two key establishment schemes. The first scheme needs some
special beacon nodes for broadcasting random bits. In the
second scheme, some sensor nodes play the role of beacon
nodes. Our results are theoretical in some sense. Nevertheless,
we can adjust them for realistic consideration.
Our key establishment schemes have the following prop-
erties. Firstly, they do not pre-load secrets to sensor nodes.
This saves quite a lot of setup work before sensor nodes
are deployed to the field. Secondly, the connectivity rate of
neighboring sensor nodes is very high and the probability
of repeated keys is very low. Thirdly, even if the adversary
captures a large fraction of the deployed sensor nodes, almost
all of the shared keys of un-compromised links remain secure.
We note that most key pre-distribution schemes allow only
a small fraction of sensor nodes to be compromised by the
adversary. Finally, the shared keys in the first scheme are
unconditionally secure. Furthermore, since all shared keys are
generated in the field without pre-loaded secrets in sensor
nodes, shared keys can be updated from time to time.
We do not consider the adversary that applies other types
of attacks, such as node impersonation, node replication, etc.
There have been many proposed countermeasures [5]–[7]. If
we need them, we can simply use them without too much
31) B1 generates and broadcasts α random bits on the fly.
2) Each Vi, 1 ≤ i ≤ m, randomly stores µ bits
ri1ri2 · · · riµ . Let Si = {i1, i2, . . . , iµ}.
3) Each Vi, 1 ≤ i ≤ m, does the following:
a) Exchange Si with each of its neighbors Vj via their
direct radio link;
b) Let Si,j = Si ∩ Sj = {s1, s2, . . . , sl}. If |Si,j | =
l ≥ κ, compute Ki,j = H(rs1rs2 · · · rsl).
c) Erase the stored bits ri1ri2 · · · riµ from its memory.
Fig. 2. KEB-SB: Steps of establishing shared keys between neighboring sensor
nodes within the radio range of the beacon node B1.
beacon nodes do the same thing. The idea is that B1 broadcasts
α random bits and each sensor node randomly stores µ bits.
Then, two neighboring sensor nodes exchange the indices of
their stored bits and find their common bits. Finally, they
compute the shared key from the common bits by taking
the hash value of the common bits. It is easy to check that
Ki,j = Kj,i since Vi and Vj found their common bits from
the publicly exchanged indices.
It is critical that some sensor nodes V lie within the radio
coverage areas of many beacon nodes, say, B1,B2, . . . ,Bτ .
Assume that Bi’s use different frequencies for broadcasting
so that they won’t interfere with each other. In this case,
V establishes shared keys with its neighboring sensor nodes
within various beacon nodes Bk, 1 ≤ k ≤ τ . Thus, a network
that connects all sensor nodes can be formed. For example, the
sensor node V1 has a shared key K1,3 with V3 within B1 and a
shared key K1,7 with V7 within B3. V1 plays as a connecting
node between the sensor nodes within B1 and the sensor nodes
within B3.
Probability of Establishing Shared Keys. In the scheme
each sensor node within a beacon node stores µ = 2
√
κα
broadcasted bits randomly. Two neighboring sensor nodes
within a beacon node will have 4κ common bits on average.
Furthermore, the probability that two neighboring sensor nodes
have at least κ common bits is 1−e−κ/4 at least. For κ = 128,
1−e−κ/4 ≈ 1. The following lemma shows this fact, where S
and T are the sets of indices of stored bits by two neighboring
sensor nodes, respectively.
Lemma 1 ( [4]): If S and T are randomly chosen from
the 2
√
κα-element subsets over {1, 2, . . . , α}, then, for suf-
ficiently large α,
Pr
S,T
[|S ∩ T | < κ] < e−κ/4.
Security of Shared Keys. Assume that the adversary stores
β = δα bits of the broadcasted α bits, where δ < 1 is a
constant. The security of shared keys depends on δ and κ. Two
neighboring sensor nodes within a beacon node have l = 4κ
common bits on average and the adversary gets a fraction
δl of them on average. Although the number l of common
stored bits is a random variable, we take the average l = 4κ
for simplifying analysis. We show that the probability that the
adversary gets up to (δ+ ²)l common bits is very low, where
δ + ² < 1.
Let A ⊂ {1, 2, . . . , α} be the set of indices of the stored
bits by the adversary, |A| = β, and B the set of indices of
the commonly stored bits by two neighboring sensor nodes,
|B| = l. We fix A first. The probability that the adversary
stores (δ + ²)l common bits is, for δ + ² < 1 and integer
l(δ + ²),
Pr
B
[|A ∩B| ≥ (δ + ²)l] =
l∑
i=(δ+²)l
(
β
i
)(
α−β
l−i
)(
α
l
) .
It is hard to derive a closed form for the above equation.
Nevertheless, we can compute a pretty tight upper bound. In
the above computation the elements in B are randomly chosen
one by one from {1, 2, . . . , α} without replacement. However,
if α is much larger than l, we can think that the elements are
randomly chosen one by one with replacement. Let B′ be a
multi-set with l elements randomly chosen one by one from
{1, 2, . . . , α} with replacement. Since α is indeed much large
than l in our schemes, we can safely say that
Pr
B
[|A ∩B| ≥ (δ + ²)l] ≈ Pr
B′
[|A ∩B′| ≥ (δ + ²)l],
which is bounded by the following lemma.
Lemma 2: Let A be a fixed subset of {1, 2, . . . , α} with
|A| = β and B′, |B′| = l ¿ β, a multi-subset randomly
chosen from {1, 2, . . . , α} with replacement. It holds that
Pr
B′
[|A ∩B′| ≥ (δ + ²)l] ≤ e−l²2/(3δ).
Proof: Let Xi be the indicator random variable for
whether the ith chosen element of B′ is in A, 1 ≤ i ≤ l.
We have |A ∩ B′| = ∑li=1Xi and E(∑li=1Xi) = δl. Since
Xi’s are independent, by the Chernoff bound, we have
Pr
B′
[|A ∩B′| ≥ (δ + ²)l] = Pr[
l∑
i=1
Xi ≥ (δ + ²)l]
= Pr[
l∑
i=1
Xi ≥ δl(1 + ²/δ)] ≤ e−δl(²/δ)2/3
= e−l²
2/(3δ).
Since the above holds for any fixed A, the probability holds
no matter how the adversary stores broadcasted bits. For κ =
128, δ = 2/3, ² = 1/4, we have
Pr
B′
[|A ∩B′| ≥ (11/12)l] < e−16.
In this case, the adversary does not know at least (1−δ−²)l ≈
43 common bits of two neighboring sensor nodes within a
beacon node.
Probability of Complete Connectivity. We now compute the
number of beacon nodes that are needed for high pcomplete.
The most important factor for pcomplete is the size of the
overlapping area of radio coverage since the sensor nodes
within the overlapping area connect sensor nodes within
different beacon nodes. Let R be the radius of the field and r
be the radius of the radio coverage of a beacon node. Recall
that there are z beacon nodes. We take a very conservative
and ideal estimate for the required z. Here, we assume that
5Density of Beaming Nodes. The larger p is, the higher
pcomplete is. Nevertheless, we want to have a smaller p so
that the expected number np of beaming nodes is as small
as possible. Assume that r is the radius of radio range of a
beaming node and R is the radius of the deployment field.
Note that this r is smaller than that of a beacon node in the
KEB-SB scheme. The expected number of beaming nodes is
np, which is equivalent to z, the number beacon nodes. By
Equation (1), we need
z = np ≥ nR
2
nr2 − 2cR2 ,
where c is the expected number of connecting nodes in the
overlapping area of two beaming nodes. Thus, we have
p ≥ R
2
nr2 − 2cR2 .
V. DISCUSSION
Our schemes are designed on an abstract model of wireless
sensor networks. Many details are omitted. Comparison be-
tween the conventional and storage-bounded adversary model
is uncalled-for since their basic assumptions are fundamentally
different. Even though our schemes are theoretical, we can
use some techniques to improve their performance on energy
consumption, storage requirement and computation cost.
1) No re-send: It is possible that a sensor node does not
receive some random bits from beacon or beaming
nodes. The sensor node can simply ignore a lost bit
and continues to wait for the next one. This does not
affect its functionality since only a very small fraction
of broadcasted bits are stored by each sensor node. Thus,
the beacon and beaming nodes can broadcast in a ”raw”
mode.
2) Sleeping: In our schemes, random bits are broadcasted
for a relatively long period of time. But, the sensor
nodes do not store all of them. Thus, the sensor nodes
can use the random sleeping technique to reduce energy
consumption. Each sensor node stays in a state of very
low energy consumption for most time and wakes up to
receive bits from time to time.
Furthermore, when a sensor node needs to receive broad-
casted random bits from different beacon or beaming
nodes in different frequencies, it can switch to a different
frequency in each wake-up. Thus, the beacon or beaming
nodes can broadcast random bits at different frequencies
without worrying about whether their neighboring sensor
nodes can receive them simultaneously.
3) Pseudorandomness: In our schemes, all kinds of nodes
need some random bits. Beacon and beaming nodes
need to generate random bits for broadcasting and sensor
nodes need to generate random indices for picking up
broadcasted random bits. In fact, pseudorandom bits can
replace random bits for better efficiency. A node can
sample a short random seed s from the environment
and uses the pseudorandom bit generator G to generate
pseudorandom bits G(s).
It should be noted that if we use pseudorandom bits in
the scheme, the storage-bounded adversary should be
polynomial-time bounded also, instead of computing-
unboundedness. This is because a computing-unlimited
adversary can search the seed by the eavesdropped
pseudorandom bits and the pseudorandom generator G.
In reality, an adversary may jam the media to block the
process of key establishment. It is hard for wireless commu-
nications to resist this kind of denial of service attacks. Due
to sensor nodes’ low hardware profile, it is not practical for
them to receive the random bits from a satellite. In the above
we only discuss how to establish shared keys for the sensor
nodes that are within the radio range of beacon and beaming
nodes. For others that are neighbored can establish direct link
through the path-key finding process.
VI. CONCLUSIONS
We have introduced the storage-bounded adversary model to
wireless sensor networks and proposed two key establishment
schemes in this model. We are interested in improving effi-
ciency of the schemes for practicability in the future. We are
also interested in proposing different kinds of security schemes
for wireless sensor networks in this model.
REFERENCES
[1] R. Blom. An optimal clas of symmetric key generation systems, EURO-
CRYPT 84, pp. 335-338, 1984.
[2] C. Cachin, U.M. Maurer. Unconditional security against memory-bounded
adversaries, CRYPTO 97, pp.292-306, 1997.
[3] H. Chan, A. Perrig, D. Song. Random key predistribution for sensor
networks, IEEE Symposium on Security and Privacy 03, pp.197-213,
2003.
[4] Y.Z. Ding. Oblivious transfer in the bounded storage model, CRYPTO 01,
pp.155-170, 2001.
[5] W. Du, J. Deng, Y.S. Han, P. Varshney. A pairwise key pre-distribution
scheme for wireless sensor networks, ACM CCS 03, pp.42-51, 2003.
[6] L. Eschenauer, V.D. Gilgor. A key-mamnagement scheme for distributed
sensor networks, ACM CCS 02, pp.41-47, 2002.
[7] D. Liu, P. Ning. Eatablishing pairwise keys in distributed sensor networks,
ACM CCS 03, pp.52-61, 2003.
[8] U.M. Maurer. Conditionally-perfect secrecy and a provably-secure ran-
domized cipher. Journal of Cryptology 5(1), pp.53-66, 1992.
[9] M.J. Miller, N.H. Vaidya. Leveraging channel diversity for key establish-
ment in wireless sensor networks, IEEE INFOCOM 06, pp.1-12, 2006
[10] S. Meguerdichian, F. Koushanfar, M. Potkonjak, B. Srivastava. Coverage
problems in wireless ad-hoc sensor networks, IEEE INFOCOM 01,
pp.1380-1387, 2001.
[11] M. Mitzenmacher, E. Upfal. Probability and Computing: Randomized
Algorithms and Probabilistic Analysis. University of Cambridge Press,
2005.
[12] K. Ren, K. Zeng, W. Lou. A new approach for random key pre-
distribution in large scale wireless sensor networks. Wireless Commu-
nications and Mobile Computing 6(3), pp.307-318, 2006.
2Theorem 2: If n = ad+ b, where 0 ≤ b < d, then
P (n, d) ≥ ((a+ 1)!)b(a!)d−b.
Example 1: For d = 2, we get
P (2a, 2) ≥ (a!)2.
We note that if 2d > n, then a = 1 and b = n − d and
so |C| = 2n−d. If 2d = n, then a = 2, b = 0, and we
have |C| = 2d = 2n−d as well. However, if 2d < n, then
|C| > 2n−d. Especially, when d is small relative to n, |C|
is much larger than 2n−d. For example, for n = 30, d = 2,
|C|/2n−d ≈ 6.37× 1015.
This construction has a very simple error correcting algo-
rithm. For d ≥ 2t + 1, we can correct error up to size t
in any coordinate. For coordinate i, the codeword has value
pii ≡ i (mod d). Suppose that this coordinate is changed into
σ = pii + u, where |u| ≤ t. Then pii is the integer congruent
to i which is closest to σ. Therefore, decoding of position i
is done by first computing
a ≡ i− σ (mod d),
where −(d − 1)/2 ≤ a ≤ (d − 1)/2. Then a = −u, and so
we decode into σ + a = pii.
B. First recursive construction
Let C be an (n, d) PA of size M , and let r ≥ 2 be an
integer. We define an (rn, rd) PA, Cr, of size Mr as follows:
for each multi-set of r code words from C,
(pi(j)1 , . . . , pi
(j)
n ), j = 0, 1, . . . , r − 1,
let
ρj = (rpi
(j)
1 − j, . . . , rpi(j)n − j), j = 0, 1, . . . , r − 1,
and include (ρ0|ρ1| . . . |ρr−1) as a codeword in Cr. It is clear
that under this construction the distance between any two
distinct ρj , ρj′ is at least rd. It is also easy to check that
(ρ0|ρ1| . . . |ρr−1) ∈ Srn. Hence |Cr| =Mr. In particular, we
get the following bound.
Theorem 3: If n > d and r ≥ 2, then
P (rn, rd) ≥ P (n, d)r.
Proof: Let C be an (n, d) PA of size P (n, d). Then
the construction above gives an (rn, rd) PA of Cr. Hence
P (rn, rd) ≥ |Cr| = |C|r = P (n, d)r.
C. Second recursive construction
For a permutation pi = (pi1, pi2, . . . , pin) ∈ Sn and an integer
m, 1 ≤ m ≤ n+ 1 define
ϕm(pi) = (m,pi′1, pi
′
2, . . . , pi
′
n) ∈ Sn+1
by
pi′i = pii if pii ≤ m,
pi′i = pii + 1 if pii > m.
Let C be an (n, d) PA, and let
1 ≤ s1 < s2 < · · · < st ≤ n+ 1
be integers. Define
C[s1, s2, . . . , st] = {ϕsj (pi) | 1 ≤ j ≤ t, pi ∈ C}.
Theorem 4: If C is an (n, d) PA of size M and
sj + d ≤ sj+1 for 1 ≤ j ≤ t− 1,
then C[s1, s2, . . . , st] is an (n+ 1, d) PA of size tM .
Theorem 5: If C is an (n, d) PA of size M and n ≤ 2d,
then C[d] is an (n+ 1, d+ 1) PA of size M .
Proof: If j > j′, then
dmax(ϕsj (pi), ϕsj′ (σ)) ≥ sj − sj′ ≥ d.
Next, consider j′ = j. If pi, σ ∈ C, pi 6= σ, then w.l.o.g, there
exist an i such that pii ≥ σi + d. Hence
dmax(ϕsj (pi), ϕsj (σ)) ≥
{
pii − σi + 1 > d if pii > sj ≥ σi,
pii − σi ≥ d otherwise.
This proves Theorem 4. To complete the proof of Theorem 5
we note that
pii ≥ σi + d ≥ d+ 1 > d,
and
σi ≤ pii − d ≤ n− d ≤ d.
Hence pii > d ≥ σi and so
dmax(ϕsj (pi), ϕsj (σ)) ≥ d+ 1.
The constructions imply bounds on P (n, d).
Theorem 6: If n > d ≥ 1, then
P (n+ 1, d) ≥
(⌊n
d
⌋
+ 1
)
P (n, d).
Proof: Let t = bn/dc + 1. Then (t − 1)d + 1 ≤ n + 1.
If C is an (n, d) PA of size P (n, d), then Theorem 4 implies
that C[1, d+ 1, 2d+ 1, . . . , (t− 1)d+ 1] is an (n+ 1, d) PA
of size tP (n, d). Hence P (n+ 1, d) ≥ tP (n, d).
Example 2: In Example 1 we showed that the explicit con-
struction implied that P (2a, 2) ≥ (a!)2. Combining Theorem
6 and search, we can improve this bound. We have found that
P (7, 2) ≥ 582, see the table at the end of the next section.
From repeated use of Theorem 6 we get
P (2a, 2) ≥ (a(a− 1) · · · 5)2 · 4P (7, 2) ≥ 97
24
(a!)2.
Theorem 5 implies the following bound.
Theorem 7: If d < n ≤ 2d, then
P (n+ 1, d+ 1) ≥ P (n, d).
Proof: Let C be an (n, d) PA of size P (n, d). By Theorem
5, C[d] is an (n+ 1, d+ 1) PA of size P (n, d). Hence
P (n+ 1, d+ 1) ≥ |C[d]| = P (n, d).
Theorem 7 shows in particular that for a fixed r,
P (d+ 1 + r, d+ 1) ≥ P (d+ r, d) for d ≥ r. (1)
We will show that P (d + r, d) is bounded. We show the
following theorem.
4Remark. By a more involved analysis, we can improve
this bound somewhat. For example, we see that two new
permutations can contribute at most 4r−3 to the total support.
We can now complete the proof of Theorem 8. Let C be a
(d+r, r) code of size cr. By Lemma 3, |χ(C)| ≤ cr(2r−1)+1.
If d > 1 + cr(2r − 1) − r, then d + r > |χ(C)|. Hence,
by Lemma 2, P (d − 1 + r, d − 1) = P (d + r, d). Therefore,
dr ≤ 1+cr(2r−1)−r, that is, (3) is satisfied. This completes
the proof of Theorem 8.
Theorem 9: We have P (d+ 1, d) = 3 for d ≥ 2.
Proof: We use the same notation as in the proof of Lemma
2. Let C be an (d + 1, d) PA. The only potent elements are
1 and n. W.lo.g. we may assume the first permutation in C
is (1, n, ∗, ∗, . . .) where ∗ denotes some unspecified integer in
the range 2, 3, . . . , d. W.l.o.g, a second permutation has one
of three forms:
(n, 1, ∗, ∗, . . .), (n, ∗, 1, ∗, . . .), (∗, 1, n, ∗, . . .).
We see that if the second permutation is of the first form, there
cannot be more permutations. If the second permutation is of
the form (n, ∗, 1, ∗, . . .), then there is only one possible form
for a third permutation, namely (1, ∗, n, ∗, . . .). Hence we see
that P (d+ 1, d) ≤ 3 and that P (d+ 1, d) = 3 for d ≥ 2.
To determine P (d + r, d) along the same lines for r ≥ 2
seems to be difficult because of the many cases that have to be
considered. Even to determine P (d+2, d) will involve a large
number of cases. For example for the second permutation there
are 138 essentially different possibilities for the four positions
in the potency support of the first permutation. For each of
these there are many possible third permutations, etc.
D. Encoding/decoding of some PA constructed by the second
recursive construction
Suppose we start with the PA
Cd = {(1, 2, 3, . . . , d)}.
For ν = d, d+ 1, . . . , n− 1 let
Cν+1 = Cν [1, ν + 1].
Then Cn is an (n, d) PA of size 2n−d. For some applica-
tions, we may want to map a set of binary vectors to a
permutation array. One algorithm for mapping a binary vector
(x1, x2, . . . , xn−d) into Cn would be to use the recursive con-
struction of Cn by mapping (x1, x2, . . . , xi) into a permutation
pi in Cd+i. Recursively, we can then map (x1, x2, . . . , xi, 0)
to ϕ1(pi) and (x1, x2, . . . , xi, 1) to ϕd+i+1(pi).
However, there is an alternative algorithm which requires
less work. Retracing the steps of the construction, we see
that given some initial part of length less than n − d of a
permutation in Cn, there are exactly two possibilities for the
next element, one ”larger” and one ”smaller”. More precisely,
induction shows that if the initial part of length i− 1 contains
exactly t ”smaller” elements, then element number i is either
t+1 (the ”smaller”) or n− i+ t+1 (the ”larger”). This is the
basis for a simple mapping from Zn−d2 to Cn. We give this
algorithm in Figure 1.
Input: (x1, . . . , xn−d) ∈ Zn−d2
Output: (pi1, . . . , pin) ∈ Cn
for i← n− d+ 1 to n do xi ← 0;
t← 0; //* t is the number of zeros seen so far.*//
for i← 1 to n do
if xi = 0
then {pii ← t+ 1; t← t+ 1;}
else {pii ← n− i+ t+ 1;}
Fig. 1. Algorithm mapping Zn−d2 to Cn
We see that the difference between the larger and the smaller
element in position i ≤ n − d is n − i. Hence we can
recover from any error of size less than (n− i)/2 by choosing
the closest of the two possible values, and the corresponding
binary value. We give the decoding algorithm in Figure 2.
Input: (pi1, . . . , pin) ∈ [n]n
Output: (x1, . . . , xn−d)
t← 0; //* t is number of zeros determined. *//
for i← 1 to n− d do
if pii < (n− i)/2 + t+ 1
then {xi ← 0; t← t+ 1;}
else {xi ← 1;}
Fig. 2. Decoding algorithm recovering the binary preimage from a corrupted
permutation in Cn.
Without going into all details, we see that we can get a
similar mapping from q-ary vectors. Now we start with the
PA
C(q−1)d = {(1, 2, 3, . . . , (q − 1)d)}.
For (q− 1)d ≤ ν ≤ n− 1 let sj = (j− 1)bν/(q− 1)c+1 for
1 ≤ j ≤ q − 1 and sq = ν + 1. Let
Cν+1 = Cν [s1, s2, . . . , sq].
Then Cn is an (n, d) PA of size qn−(q−1)d. Encoding and
decoding correcting errors of size at most (d−1)/2, based on
the recursion, is again relatively simple.
IV. FURTHER BOUNDS ON P (n, d)
A. General bounds
Since dmax(pi, σ) ≤ n−1 for any two distinct permutations
in Sn, we have P (n, n) = 1. Therefore, we only consider
d < n.
Since the spheres of radius d in Sn all have size V (n, d),
we can get a Gilbert type lower bound on P (n, d).
Theorem 10: For n > d ≥ 2 we have
P (n, d) ≥ n!
V (n, d− 1) .
Proof: It is clear that the following greedy algorithm pro-
duces a permutation array with cardinality at least n!/V (n, d−
1).
6Combining equations (33) and (34) in Kløve [8] we get the
following lower bound on V (n, d):
V (n, d) ≥ n! (2d+ 1)
n
22d nn
. (5)
For d odd, (5) gives
V (n, b(d− 1)/2c) = V (n, (d− 1)/2) ≥ n! d
n
2d−1 nn
.
Combining this with Theorem 11 we get the following explicit
upper bound on P (n, d).
Corollary 2: For d odd and n > d ≥ 1, we have
P (n, d) ≤ 2
d−1nn
dn
.
Similarly, for d even, combining Theorem 11 and Theorem 12
with (5), we get the following.
Corollary 3: For d even and n > d ≥ 2, we have
P (n, d) ≤ min
{
2d−2nn
(d− 1)n ,
2d(n+ 1)n+1
(d+ 1)n+1
}
.
The bounds on V (n, d), both the upper and the lower, are
in most cases quite weak and so the bounds on P (n, d) also
become quite weak.
B. Table of bounds on P (n, d)
We have used the following greedy algorithm to find an
(n, d) PA C: Let the identity permutation in Sn be the
first permutation in C. For any set of permutations chosen,
choose as the next permutation in C the lexicographically
next permutation in Sn with distance at least d to the chosen
permutations in C if such a permutation exists. The size of
the resulting PA is of course a lower bound on P (n, d).
The lower bounds in Table II were in most cases found by
this greedy algorithm. For n = 8, d = 5, the greedy algorithm
gave a PA of size 26. However,
P (8, 5) ≥ P (7, 4) ≥ 28
by Theorem 7. Similarly,
P (10, 7) ≥ P (9, 6) ≥ P (8, 5) ≥ 28.
Some other of the lower bounds are also determined using
Theorem 7. They are marked by ∗. The upper bound is the
Hamming type bound in Theorem 11 or it’s modified bound in
Theorem 12. Since P (n, 1) = n! for all n, this is not included
in the table.
V. CONCLUSION
We give a number of constructions of permutations ar-
rays under the Chebyshev distance, some with efficient error
correction algorithms. We also consider an explicit mapping
of vectors to permutations with efficient encoding/decoding.
Finally, we give some bounds on the size of PAs under the
Chebyshev distance.
Tamo and Schwartz [15] independently considered this
problem and gave, among other results, a construction equiv-
alent to our first construction as well as some other construc-
tions.
TABLE II
BOUNDS ON P (n, d).
d = 2 d = 3 d = 4
n = d+ 1 3 3 3
n = d+ 2 6− 24 9 9− 12
n = d+ 3 29− 120 20− 34 28− 43
n = d+ 4 90− 720 84− 148 68− 166
n = d+ 5 582− 5040 401− 733 283− 4077
d = 5 d = 6 d = 7
n = d+ 1 3 3 3
n = d+ 2 9− 12 9− 18 9− 18
n = d+ 3 28∗ − 43 28∗ − 60 28∗ − 60
n = d+ 4 95− 166 95∗ − 216 95∗ − 216
n = d+ 5 236− 714 236∗ − 850 236∗ − 850
REFERENCES
[1] P. Cappelletti, C. Golla, P. Olivo, and E. Zanoni, Flash memories.
Kluwer Academic Publishers, 1999.
[2] H. Chadwick, L. Kurz, “Rank permutation group codes based on
Kendall’s correlation statistic,” IEEE Trans. Inform. Th., vol. IT-15, pp.
306–315, Mar 1969.
[3] P. Diaconis, Group Representations in Probability and Statistics. Hay-
ward, CA: Institute of Mathematical Statistics, 1988.
[4] S. Haykin, Communication Systems, 4th Ed. John Wiley & Sons, 2001.
[5] A. Jiang, R. Mateescu, M. Schwartz and J. Bruck, “Rank Modulation for
Flash Memories,” in Proc. IEEE Internat. Symp. on Inform. Th., 2008,
pp. 1731-1735.
[6] A. Jiang, M. Schwartz and J. Bruck, “Error-Correcting Codes for Rank
Modulation,” in Proc. IEEE Internat. Symp. on Inform. Th., 2008, pp.
1736-1740.
[7] M. Kendall and J. D. Gibbons, Rank correlation methods. London, U.K.:
Edward Arnold, 1990.
[8] T. Kløve, “Spheres of Permutations under the infinity norm - permu-
tations with limited displacement,” Reports in Informatics, Dept. of
Informatics, Univ. Bergen, Report no. 376, November 2008.
[9] T. Kløve, “Generating functions for the number of permutations with
limited displacement,” The Electronic Journal of Combinatorics, R104,
vol. 16(1), August 14, 2009.
[10] T. Kløve, “Lower bounds on the size of spheres of permutations under
the Chebychev distance,” Designs, Codes and Cryptography, to appear.
[11] D. H. Lehmer, “Permutations with strongly restricted displacements,” in
Combinatorial Theory and its Applications II, P. Erdo¨s, A. Rn´yi and V.
T. So´s (eds.), Amsterdam: North Holland Publ., 1970.
[12] K. W. Shum, ”Permutation coding and MFSK modulation for frequency
selective channel,” IEEE Personal, Indoor and Mobile Radio Commu-
nications, vol. 13, pp. 2063–2066, Sept. 2002.
[13] R. P. Stanley, Enumerative Combinatorics, Vol. I. Cambridge, U.K.:
Cambridge Univ. Press, 1997.
[14] E. Stoll and L. Kurz, “Suboptimum Rank Detection Procedures Using
Rank Vector Codes,” IEEE Trans. Commun., vol. COM-16, pp. 402-
410, June 1968.
[15] I. Tamo and M. Schwartz, “Correcting limited-magnitude errors in the
rank-modulation scheme,” arXiv:0907.3387, July 20, 2009.
[16] J.H. van Lint, R. M. Wilson, A Course in Combinatorics, 2nd ed.
Cambridge, U.K.: Cambridge Univ. Press, 2001.
Torleiv Kløve (M’89–SM’91–F’03) was born in Voss, Norway, 1943. He
received the Cand. Mag., Cand. Real., and Dr. Philos. degrees from the
University of Bergen, Norway, in 1966, 1967, and 1971, respectively.
He has been with the University of Bergen since 1971, first as Senior
Lecturer in Mathematics, and, since 1982, Professor of Informatics. During the
academic years 1975–1976, 1981–1982, and 1990–1991 he spent sabbaticals
at the University of Hawaii at Manoa. During the academic year 2001–
2002, he was a Visiting Professor at The Chinese University of Hong Kong,
and during the fall semester 2002, he was Visiting Professor at Hong Kong
University of Science and Technology. During the academic year 2008–2009
he spent a sabbatical at the University of California, Santa Cruz.
出席 2010 國際密碼會議(CRYPTO 2010)報告 
曾文貴 陳毅睿 
一、時間與地點：99/8/16~8/19，U. C. Santa Barbara 
二、論文：203篇投稿，接受 39篇 
三、參加會議經過： 
第 30屆國際密碼會議 (The 30th Annual Cryptology Conference，簡稱 CRYPTO 
2010) 為國際密碼研究會 (International Association for Cryptologic 
Research，簡稱 IACR) 主辦，今年的會議在美國加州大學的聖塔芭芭拉分校舉行，
與會人數共約 350人。會議為期五天 (8/16~8/19)，除了第二天以及第五天下午
外，其餘皆為論文發表時間。第一天的早上有大師級的學者受邀演講，講者分別
有 Shafi Goldwasser (MIT and Weizmamnn) 以及 Silvio Micali (MIT)，講題
是 Zero knowledge – 25 Years 。在會議會場內的討論氣氛非常熱烈，休息時
間都可看到許多學者在相互交流與討論。 
 
四、發表論文介紹： 
無論文發表。 
 
五、與會心得： 
本次會議共有 39篇論文發表，每篇發表的時間為 25分鐘，分為 12個 sessions: 
    Day 1 (8/16) 
    Session 1: Leakage 
    Session 2: Lattice 
    Session 3: Invite Talk 
    Session 4: Homomorphic Encryption 
    Session 5: Theory and Applications 
    (c) Auxiliary-input security.在證明一個 PKE scheme的安全性中，攻擊 
者除了可以從系統公開訊息中詴著取得系統私密資訊之外，可以更進一 
步地推廣成攻擊者還有辦法得知 f(secret key,public key)，其中 f 
是攻擊者任意選定的一個函數。在這樣增強攻擊者能力的 PKE scheme 
所證明的安全性的即是 auxiliary-input security。 
 
在這篇論文中，作者提出了一個 PKE scheme，除了滿足一般常見的 semantic 
security 外，更同時滿足了上述的三種安全性。而這篇論文中所提出的 PKE 
scheme是基於 quadratic residuosity (QR) assumption (或是 Paillier’s 
decisional composite residuosity (DCR) assumption)。 
 
 
(2) Ali Juma and Yevgeniy Vahlis, “Protecting Cryptographic Keys against  
Continual Lekage”. 
 
在一般現實中應用的加密系統中，side-channel attack 是攻擊者常會使用
的一類攻擊法，其主要的精神是籍由記錄系統運行時的各種狀態來進行系統私密
資訊的分析及偷取，像是 cold boot attacks。所以在設計加密演算法時，需要
將這類攻擊考慮到安全的 model之中，而以住的加密系統在證明其安全性時大多
都是假設系統在運行時，私密的資訊是不會洩露的，但在現實中攻擊者在系統運
行中利用 side-channel attack 來獲得系統私密的資訊卻是有可能的。而一個能
被證明抵擋 side-channel attack 的加密系統可稱為 leakage-resilient 
scheme。 
在這篇論文當中，作者們提出一種利用”fully homomorphic encryption 
with re-randomizable ciphertexts”來保護系統中的私密資訊免於受到
side-channel attack 的方法。其中作者們在證明安全性時是假設系統只有在進
行運算時，才有可能讓攻擊者利用 side-channel attack 來偷取私密資訊，像是
cold boot attack就是藉由使用者在解密時，會將解密金鑰 load到記憶體中才
會讓攻擊者有機會將當時的記憶體狀態記錄下來並進行分析，而其他時候使用者
的私密金鑰都是假設在系統中被安全地保護著。 
 
 
(3) Shafi Goldwasser and Guy N. Rothblum, “Securing Computation against  
Continuous Leakage”. 
 
在現實的密碼系統中，攻擊者可利用 side-channel attack來偷取系統私密
資訊。近幾年來，在證明一個密碼系統的安全性時，都會將這類的攻擊放入安全
性 model 中考量分析，而滿足這種安全性的這類的密碼演算法可稱之為
leakage-resilient cryptographc algorithms。 
會受到大家的重視。因此，我們也應該盡量發表在重要的國際會議上，才可以真
正提升我國的密碼學研究層次。另外，各國學者在會議期間積極的討論與交流的
態度，是我們應該學習的。若有足夠的經費補助，無論是學生或是教授，都應該
能多出國吸取國外學者的研究經驗。 
 
七、攜回資料名稱與內容： 
(1) CRYPTO 2010 會議資訊: 記載本次研討會的時間、地點、會議流程、報告人員、
以及報告題目等與研討會相關的會議資訊。 
(2) CRYPTO 2010會議論文集 (proceeding): 收錄本次研討會所接受論文之全文記
錄。 
96年度專題研究計畫研究成果彙整表 
計畫主持人：曾文貴 計畫編號：96-2628-E-009-011-MY3 
計畫名稱：具密文與金鑰效率之公開式廣播加密系統之研究 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 2 2 100% 
IEEE Trans. 
Wireless 
Communications 
及  IEEE Trans. 
Information 
Theory 
研究報告/技術報告 0 0 100%  
研討會論文 2 2 100% 
篇 
PKC 2008, ICICS 
2009 國際會議論
文 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
 
