implementation. A Hamiltonian cycle in a graph is a 
simple cycle in which each vertex of the graph 
appears exactly once. The Hamiltonian cycle problems 
involves testing whether a Hamiltonian cycle exist in 
a graph. It is well known that the Hamiltonian cycle 
problem is a classic NP-complete problem on general 
graphs. A path cover of a graph G is a family of 
vertex-disjoint paths that covers all vertices of G. 
Given a graph G, the path cover problem is to find a 
path cover of G with minimum cardinality. The path 
cover problem is NP-hard for general graphs since it 
contains the Hamiltonian path problem as a special 
case.  
    The Hamiltonian cycle and path cover problems on 
interval graphs given a set of n sorted intervals can 
be solved in O(n) time. Unfortunately, these 
algorithms fail to provide supporting evidence for 
their answers. In the first year of this project, we 
give linear-time certifying algorithms for these two 
problems on interval graphs. The certificates 
provided by our algorithms can to be authenticated in 
O(n) time. 
    In the literature, the Hamiltonian cycle problem 
on circular-arc graphs can be solved O(n^2 log n) 
time, where n is the number of vertices of the input 
graph. In fact, the O(n^2 log n)-time algorithm can 
be modified as a certifying algorithm although it was 
published before the term certifying algorithms 
appeared in the literature. However, whether there 
exists an algorithm whose time complexity is better 
than O(n^2 log n) for solving the Hamiltonian cycle 
problem on circular-arc graphs has been opened for 
two decades. In the second year of this project, we 
propose an O(dn)-time certifying algorithm for the 
Hamiltonian cycle problem on circular-arc graphs, 
where d is the maximum degree of the input graph. The 
certificate provided by our algorithm can be 
authenticated in O(n) time. In addition, we obtain an 
O(n^2)-time certifying algorithm for the path cover 
problem on circular-arc graphs by using a simple 
reduction. 
 ?????????????????????? 
 
*******************************************************************
* *
* ?????????????? *
* *
*******************************************************************
 
 
 
???????????  ?????? 
?????NSC 99?2221?E?324?011?MY2 
?????99? 8? 1? ? 101? 7? 31? 
 
????????? 
?????? 
?????????????????????? 
 
 
??????(???????????)??????  ????? 
 
???????????????? 
??????????????? 
????????????????? 
?????????????????????? 
?????????????????? 
 
???????????????????????????????
??????????????????? 
          ?????????????????????????? 
          
????????????????(?) 
 
?   ?   ?   ?   101? 08? 10? 
II 
Abstract 
A certifying algorithm for a problem is an algorithm that provides a certificate 
with each answer that it produces. The certificate is a piece of evidence that proves 
the answer has no compromised by a bug in the implementation. A Hamiltonian cycle 
in a graph is a simple cycle in which each vertex of the graph appears exactly once. 
The Hamiltonian cycle problems involves testing whether a Hamiltonian cycle exist 
in a graph. It is well known that the Hamiltonian cycle problem is a classic 
NP-complete problem on general graphs. A path cover of a graph G is a family of 
vertex-disjoint paths that covers all vertices of G. Given a graph G, the path cover 
problem is to find a path cover of G with minimum cardinality. The path cover 
problem is NP-hard for general graphs since it contains the Hamiltonian path problem 
as a special case.  
The Hamiltonian cycle and path cover problems on interval graphs given a set of 
n sorted intervals can be solved in O(n) time. Unfortunately, these algorithms fail to 
provide supporting evidence for their answers. In the first year of this project, we give 
linear-time certifying algorithms for these two problems on interval graphs. The 
certificates provided by our algorithms can to be authenticated in O(n) time. 
In the literature, the Hamiltonian cycle problem on circular-arc graphs can be 
solved O(n2 log n) time, where n is the number of vertices of the input graph. In fact, 
the O(n2 log n)-time algorithm can be modified as a certifying algorithm although it 
was published before the term certifying algorithms appeared in the literature. 
However, whether there exists an algorithm whose time complexity is better than 
O(n2 log n) for solving the Hamiltonian cycle problem on circular-arc graphs has 
been opened for two decades. In the second year of this project, we propose an 
O(∆⋅n)-time certifying algorithm for the Hamiltonian cycle problem on circular-arc 
graphs, where ∆ is the maximum degree of the input graph. The certificate provided 
by our algorithm can be authenticated in O(n) time. In addition, we obtain an 
O(n2)-time certifying algorithm for the path cover problem on circular-arc graphs by 
using a simple reduction. 
Keywords: Certifying algorithms; Hamiltonian cycle problem; path cover problem; 
interval graphs; circular-arc graphs. 
 
1 
?????? (??????) 
?????????????? 
Certifying Algorithms on Interval Graphs and Circular-Arc Graphs 
?????NSC 99-2221-E-324-011-MY2 
?????99? 8? 1?? 101? 7? 31? 
??????? 
E-mail?rwhung@cyut.edu.tw 
?????????????????????(?) 
?????? 
The study of certifying algorithms is motivated by software engineering, software 
reliability and the insight that software is often not bug-free. Although an algorithm has 
been always proved to be correct, its implementation may contain bugs. Thus, it is 
desirable to have tools for knowing whether the output of an implementation of an 
algorithm is correct or returned due to a bug. Obviously, there is no way to guarantee by 
the design and analysis of an algorithm that its implementations are bug-free. 
Nevertheless, certifying algorithm design may support software reliability.  
The name “certifying algorithm” was introduced by Kratsch et al. in [32]. A 
certifying algorithm for a problem is an algorithm that provides a certificate together 
with its each answer. An authentication algorithm is a separate algorithm that confirms 
the validity of the answer by checking the certificate; it takes the input, the output, and 
the certificate produced by the original algorithm, and verifies (independently of the 
original algorithm) whether the output is correct. Bug-free implementation of the 
authentication algorithm is crucial, and hence authentication should be simple. For 
example, an implementation of a certifying algorithm testing whether an input graph is 
bipartite provides an odd cycle as a certificate whenever it claims the input graph is not 
bipartite and provides two disjoint independent vertex sets as a certificate if it claims 
the input graph is bipartite. An authentication algorithm can verify the correctness of an 
answer claiming the input graph is not bipartite by checking whether the certificate is 
an odd cycle of the input graph indeed; and verify the correctness of an answer claiming 
the input graph is bipartite by checking whether the certificate does consist of two 
disjoint independent sets whose union is the vertex set of the input graph. In this project, 
we study the certifying algorithms for interval graphs and circular-arc graphs.  
 
3 
Polynomial-time algorithms were known only for a few special classes of graphs 
including trees [42], block graphs [7, 54, 55], interval graphs [1, 6], cographs [36], 
bipartite distance-hereditary graphs [56], distance-hereditary graphs [26], bipartite 
permutation graphs [49], and cocomparability graphs [11]. The path cover problem has 
found some applications in database designing, networking, establishing ring protocol, 
VLSI designing, code optimization [5], mapping parallel programs into parallel 
architectures [42, 45], and more. The Hamiltonian related problems include 
Hamiltonian and path cover problems. 
A graph G = (V, E) is called an intersection graph for a finite family F of nonempty 
sets if there is a one-to-one correspondence between F and V such that two sets in F 
have nonempty intersection if and only if their corresponding vertices in V are adjacent. 
We call F an intersection model of G. For an intersection model F, we use G(F) to 
denote the intersection graph for F. If F is a family of intervals on a real line, then G is 
called an interval graph for F and F is called an interval model of G. If F is a family of 
arcs on a circle, then G is called a circular-arc graph for F and F is called a circular-arc 
model of G. Note that interval graphs form a subclass of circular-arc graphs. The two 
classes of interval graphs and circular-arc graphs have a variety of applications 
involving traffic light sequencing, VLSI design, scheduling [16] and genetics [53]. 
There exists a linear-time certifying recognition algorithm for interval graphs [33] and a 
linear-time non-certifying recognition algorithm for circular-arc graphs [39].  
In this project, we propose certifying algorithms for the Hamiltonian related 
problems on interval graphs and circular-arc graphs. Related works are summarized as 
follows. Arikati and Rangan [1] presented an O(n+m)-time algorithm to solve the path 
cover problem on interval graphs. Manacher et al. [37] gave an O(n loglog n)-time 
algorithm for the Hamiltonian cycle problem on a set of n endpoint-sorted intervals. 
Chang et al. [6] proposed O(n)-time algorithms for both Hamiltonian cycle and path 
cover problems on interval graphs given a set of n endpoint-sorted intervals. In [25], we 
proved that the Hamiltonian path and path cover problems on circular-arc graphs can be 
reduced to the Hamiltonian cycle problem on the same class of graphs in O(n) time. 
Whether there exists an efficient algorithm whose time-complexity is better than O(n2 
log n) for solving the Hamiltonian cycle problem on circular-arc graphs remains open 
for two decades.  
Kratsch et al. [33] gave a linear-time certifying recognition algorithm for interval 
graphs. Kaplan et al. [30] gave a linear-time certifying recognition algorithm for proper 
circular-arc graphs. McConnell [39] gave a linear-time non-certifying recognition 
algorithm for circular-arc graphs. To the best of our knowledge, whether there exists a 
linear-time certifying recognition algorithm for circular-arc graphs remains open. 
In the first year of this project, we present O(n)-time certifying algorithms for the 
5 
certificates provided by our algorithms can be authenticated in O(n) time. 
3.1.1. A Certifying Algorithm for the Path Cover Problem on Interval Graphs  
Arikati and Rangan [1] gave an O(n+m)-time algorithm for the path cover problem 
on interval graphs. Manacher et al. [37] presented an O(n loglog n)- time for the 
Hamiltonian path problem on interval graphs given a set of n endpoint-sorted intervals. 
The two papers were published in the same volume of Information Processing Letters. 
They used the same greedy approach independently. Assume that the input graph is 
given by an interval model I that is a set of n endpoint-sorted intervals labeled by 1, 2, 
…, n in increasing order of their right endpoints. Notice that we do not distinguish an 
interval from its label. The left endpoint of interval x is denoted by left(x) and the right 
endpoint by right(x). Interval x is denoted by (left(x), right(x)). An interval x is said to 
contain another interval y if every point of y falls within the interior of (left(x), right(x)). 
For convenience, we need the following notation. 
(1) For two distinct intervals x, y in I, x is smaller than y (or y is larger than x), denoted 
by x < y, if right(y) is to the right of right(x), and y is to the right of x if left(y) is to the 
right of right(x). 
(2) s(I) denotes the interval in I with the leftmost right endpoint; that is, s(I) ≤ x for x ∈ I. 
i
1
i
2
i
3
i
4
i
5
i
6
i
7
i
8
i
9
i
10
i
11
i
12
 
Figure 1. A family I of twelve intervals. 
We first introduce Procedure GP that is the key procedure used in the algorithm in 
[1] for the path cover problem. Given an interval model I, Procedure GP uses a greedy 
principle to obtain a path Z as follows. Initially, Z visits s(I) only, i.e., Z = s(I). 
Repeatedly extend Z to visit the one with the leftmost right endpoint among neighbors 
of end(Z) not visited by Z until all neighbors of end(Z) are visited by Z. Then it outputs 
path Z and stops. For instance, given a set of 12 endpoint-sorted intervals shown in 
Figure 1, Procedure GP outputs path Z = i1 → i2 → i3 → i4 → i6 → i5. 
For interval model I, define a path cover PC(I) of G(I) recursively as follows. If I = 
φ, then PC(I) = φ. Otherwise, let PC(I) = {Z} ∪ PC(I′), where Z is the path obtained from 
I by Procedure GP and I′ = I − Z. For instance, PC(I) = {Z1 = i1 → i2 → i3 → i4 → i6 → i5, 
Z2 = i7 → i8 → i9 → i10 → i12 → i11}, where I is the set of intervals shown in Figure 1, Z1 
and Z2 are the paths obtained by Procedure GP from I and I − Z, respectively. 
Arikati and Rangan [1] proved by induction that PC(I) is an optimal path cover of 
G(I). Chang et al. [6] showed that PC(I) can be computed in O(n) time and O(n) space 
given a set of n endpoint-sorted intervals. 
7 
Corollary 4. Let Z be the path obtained by Procedure GP from interval model I, C(Z) 
= {c1, c2, …, ch}, and let Z = Q1 → c1 → Q2 → c2 → … → Qh → ch → Qh+1. Then, Q1, 
Q2, …, Qh+1, and I − Z are islands with respect to C(Z) in G(I). 
Suppose PC(I) = {Z1, Z2, …, Zq}, where q = |PC(I)|. Define (I) = ∪1≤i≤qC(Zi). For 
example, (I) = {i6, i12} for the interval model I shown in Figure 1, where PC(I) = {Z1 = 
i1 → i2 → i3 → i4 → i6 → i5, Z2 = i7 → i8 → i9 → i10 → i12 → i11}, C(Z1) = {i6}, and C(Z2) = 
{i12}. By Corollary 5, we have the following corollary: 
Corollary 5. There are |PC(I)| + | (I)| connected components in G(I − (I)). 
By the above corollary and Proposition 1, we know that PC(I) is an optimal path 
cover of G(I). Now we are ready to describe our authentication algorithm as follows. 
Given PC(I), the algorithm first checks whether PC(I) is a path cover of G(I) and then 
computes (I) to test whether G(I − (I)) has |PC(I)| + | (I)| connected components. 
Whether PC(I) is a path cover of G(I) can be checked in O(n) time. Given PC(I), (I) 
can be computed in O(n) time. Given a sorted interval model I and (I), the number of 
connected components in G(I − (I)) can be determined in O(n) time. Thus the running 
time of the authentication algorithm is O(n) and we have the following theorem. 
Theorem 6. There is an O(n)-time certifying algorithm for the path cover problem on 
interval graphs given sorted interval models. The optimality of the output of this 
algorithm can be authenticated in O(n) time. 
3.1.2. A Certifying Algorithm for the Hamiltonian Cycle Problem on Interval 
Graphs  
Manacher et al. [37] gave an O(n loglog n)-time algorithm for the Hamiltonian 
cycle problem on a set I of n endpoint-sorted intervals. Chang et al. showed that their 
algorithm can be done in O(n) time. Recently, Ibarra [27] gave a simple O(n+m)-time 
algorithm for the Hamiltonian cycle problem on proper interval graphs. Unfortunately, 
their algorithms fail to provide certificates for their answers. In this subsection, we will 
propose a certifying algorithm to solve the Hamiltonian cycle problem on interval 
graphs. The algorithm is simpler and shorter than the foregoing algorithms in [31, 37].  
It is assumed that a set I of n endpoint-sorted intervals is given and n > 2. The 
algorithm first computes path Z by calling Procedure GP. If I − Z ≠ φ or L(Z) ≠ φ, then 
G(I) has no Hamiltonian cycle. In this case, it outputs C(Z) as a certificate. Clearly, C(Z) 
is of length O(n). The authentication algorithm simply checks whether G(I − C(Z)) has 
more than |C(Z)| connected components. If G(I − C(Z)) does have more than |C(Z)| 
connected components, then, by Proposition 2, G(I) does have no Hamiltonian cycle. 
Suppose I − Z = φ and L(Z) = φ. That is, G(I) has a Hamiltonian path Z with L(Z) = φ. 
9 
problem on n sorted interval models. The length of the certificate provided by the 
algorithm is O(n) and the authentication algorithm runs in O(n) time. 
3.2. The Second Year  
Tucker [52] presented an O(n3)-time algorithm for testing whether a graph is a 
circular-arc graph. Hsu [21] proposed an O(mn)-time algorithm to recognize 
circular-arc graphs. Eschen and Spinrad [14] proposed an O(n2)-time recognition 
algorithm for circular-arc graphs. McConnell [39] presented an O(n+m)-linear- time 
recognition algorithm for circular-arc graphs. An arc family F can be obtained by these 
recognition algorithms in the affirmative case. Hence, researchers studying circular-arc 
graphs sometimes assume that a set of arcs with endpoints sorted is given [6, 8, 20, 23, 
38]. If endpoints of arcs are not sorted, then O(n log n) sorting preprocessing time will 
be sufficient. In the rest of the report, it is assumed that endpoints of arcs in F are sorted. 
Denote an arc x that begins at endpoint p and ends at endpoint q in clockwise direction 
by (p, q). We call p the head, denoted by h(x), and q the tail, denoted by t(x), of arc (p, q). 
The contiguous part of the circle that begins with an endpoint c and ends with an 
endpoint d in clockwise direction is referred to as segment (c, d), denoted by seg(c, d), 
of the circle. We use “arc” to refer to a member of F and “segment” to refer to a part of 
the circle between two endpoints. A point y on the circle is said to be contained in arc 
(or segment) (p, q) if it falls within the interior of seg(p, q). An arc or segment x is said 
to contain another arc or segment y if x contains every point of y. Two arcs, or two 
segments, or an arc and a segment intersect if and only if they share a point in common. 
Without loss of generality, it is assumed that (1) all endpoints are distinct, (2) no arc 
covers the entire circle, and (3) an arc (segment) does not include its two endpoints, i.e., 
it is an open segment of the circle. Note that G(F) is an interval graph if there exists a 
point on the circle such that no arc of F contains it. 
The Hamiltonian cycle problem on circular-arc graphs can be solved in O(n2 log n) 
time [48]. In fact, the O(n2 log n)-time algorithm can be modified as a certifying 
algorithm although it was published before the term certifying algorithms appeared in 
the literature. However, whether there exists an algorithm whose time complexity is 
better than O(n2 log n) for solving the Hamiltonian cycle problem on circular-arc 
graphs has been opened for two decades. In the second year of this project, we propose 
an O(∆⋅n)-time certifying algorithm for the Hamiltonian cycle problem on circular-arc 
graphs, where ∆ represents the maximum degree of the input graph. Further, the 
certificate provided by our algorithm can be authenticated in O(n) time. 
Our basic strategy for the Hamiltonian cycle problem on circular-arc graphs is 
described as follows. If the input graph is hamiltonian, our algorithm outputs a 
Hamiltonian cycle for it. Otherwise, it provides a certificate for this answer that can be 
11 
a1 a2
a4
a5
a6a7
a8
a9
a10 a11
a3
 
Figure 4. A circular-arc model F of eleven sorted arcs. 
h a( )4
a1 a2
a4
a5
a6a7
a8
a9
a10 a11
a3
 
Figure 5. Fc(Ba(a4), h(a4)) for the set F of arcs shown in Figure 4, where dashed lines 
indicate the removed portions of arcs from F. 
t a( )6
a1 a2
a4
a5
a6a7
a8
a9
a10 a11
a3
 
Figure 6: Fcc(φ, t(a6)) for the set F of arcs shown in Figure 4, where dashed lines 
13 
Careful implementation of Procedure ArcToI takes O(n) time and O(n) space. 
It is not difficult to see that there is a one-to-one mapping between the sets of arcs 
of F and Fc(B, q) (resp. F and Fcc(B, q)). There is also a one-to-one mapping between 
the set Fc(B, q) of arcs and the set Ic(Fc(B, q)) of intervals (resp. Fcc(B, q) and Icc(Fcc(B, 
q))). Therefore there is a one-to-one mapping between the set F of arcs and the set 
Ic(Fc(B, q)) of intervals (resp. F and Icc(Fcc(B, q))). 
1
h a( )4
a1 a2
a3
a4
a5
a6a7
a8
a9
a10 a11
3
4
5
6
78
9
10
12
13
14
15
16
17
19
18
20
21
22
2
11
 
Figure 7. The clockwise labeling by Procedure ArcToI given F shown in Figure 4, 
endpoint q = h(a4), and B = Ba(a4). 
a4 a10
a8a6
a5
a7
a11a9
a2
a1 a3
 
Figure 8. The interval model Ic(Fc(Ba(a4), h(a4)) of Fc(Ba(a4), h(a4)) shown in Figure 
5. 
a1a3a4
a2
a5
a6 a7a8
a9
a10
a11
 
Figure 9. The interval model Icc(Fcc(φ, t(a6))) of Fcc(φ, t(a6)) shown in Figure 6. 
3.2.1. The Hamiltonian Cycle Algorithm on Circular-Arc Graphs  
In this subsection, we will present an O(∆⋅n)-time non-certifying algorithm to 
solve the Hamiltonian cycle problem on circular-arc graphs, where ∆ is the maximum 
degree of the input graph. It is assumed that a circular-arc model F with n endpoints 
sorted is given. Our basic idea, named Algorithm Non-Certifying-HC-Arcs, contains 
the following three stages:  
15 
test the hamiltonity of Q, we find that there exists a Hamiltonian cycle a4 → a5 → a1 → 
a11 → a10 → a8 → a9 → a7 → a2 → a3 → a6 in G(Icc). That cycle is also a Hamiltonian 
cycle of G(F). 
Example 2. Let F be the set of arcs shown in Figure 10. The algorithm first picks arc µ 
= a5 that does not contain any other arc of F. It computes Fc = Fc(Ba(a5), h(a5)) and 
constructs the interval model Ic of Fc by a clockwise conversion starting from h(a5) (as 
shown in Figure 11). The path P output by procedure GP given Ic is a5 → a4 → a6 → a7 
→ a1 → a2 → a3 → a8. It computes C(P) = φ. It is straightforward to verify that υ = 
end(P) = a8. The algorithm then computes the set Fcc = Fcc(φ, t(a8)) and constructs the 
interval model Icc of Fcc by a counterclockwise conversion starting from t(a8) (as shown 
in Figure 12). Call Procedure GP to compute path Q = a3 → a2 → a8 → a6 → a7 → a1 
→ a5 → a4 which is a Hamiltonian path of G(Icc). By calling the algorithm in Section 
3.1.2 to test the hamiltonity of Q, we find that there exists no Hamiltonian cycle in 
G(Icc). Then, z = start(Q) = a3, ω = end(Q) = a4, and C(Q) = {a1, a6}. It is 
straightforward to verify that R = Bp(h(ω)) − F(C(Q)) = {a8, a1} − {a1, a6} = {a8}. Then, 
Stage 2 is executed. We can see that s = a8. By calling Procedure GP given Icc − Icc{a8}, 
we find Qs = a3 → a2 → a1 → a7 → a6 → a4 → a5. Then, Qs is a Hamiltonian path of 
G(Is) but arc s = a3 does not intersect arc end(Qs) = a5 in G(F). Then, R = R − {a8} = φ. 
By calling the algorithm in Section 3.1.2 to test the hamiltonity of G(Icc), we find that 
G(Icc) has no Hamiltonian cycle and hence, the algorithm outputs “G(F) has no 
Hamiltonian cycle”. 
a1 a2
a3
a4
a5
a6
a7
a8
 
Figure 10. A set F of arcs used in Example 2. 
a1
a4
a5
a6
a2
a3a7
a8
 
Figure 11. The set Ic of intervals converted from F shown in Figure 10 by a clockwise 
conversion starting from h(a5). 
17 
works as follows. If Algorithm Non-Certifying-HC-Arcs outputs a Hamiltonian 
cycle C, then it outputs C as a certificate. Suppose that Algorithm Non-Certifying- 
HC-Arcs outputs that G(F) has not Hamiltonian cycle. Then, Algorithm Certifying- 
HC-Arcs provides a certificate for this answer. The certificate (F) of non- 
hamiltonian provided by the algorithm is a pair 〈Ĉ, Fˆ 〉 and is computed as follows. 
Consider the following two cases: 
Case 1: Q is not a Hamiltonian path of G(Icc). Let Fˆ  = F and Ĉ be a cut set of 
G(F), where Ĉ can be found in Appendix II. In Appendix II, we show that G( Fˆ −Ĉ) 
contains at least |Ĉ|+1 connected components. 
Case 2: Q is a Hamiltonian path of G(Icc). Let Ĉ = F(C(Q)). If R ≠ φ, then let Fˆ  
= (F−{s}) ∪ head(s, h(ω)) for all s ∈ R; otherwise, let Fˆ = F. In Appendix II, we 
show that G( Fˆ −Ĉ) contains at least |Ĉ|+1 connected components. 
It follows from Proposition 2 that (F) = 〈Ĉ, Fˆ 〉 can be served as a certificate 
showing that G(F) is not hamiltonian.  
The certificate provided by Algorithm Certifying-HC-Arcs is either a 
Hamiltonian cycle of G(F) or a pair (F) = 〈Ĉ, Fˆ 〉 showing that G(F) is not 
hamiltonian. Now, we are ready to describe our authentication algorithm as follows. 
Given a hamiltonian certificate which is a cycle C = v1 → v2 → ... → vn → v1, the 
authentication algorithm first tests whether the number of distinct vertices in the 
cycle C equals to n. It then checks whether the cycle C is indeed a Hamiltonian cycle 
of G(F) by testing that (vi, vi+1), 1 ≤ i ≤ n−1, and (vn, v1) are edges in G(F). The size 
of this certificate is O(n) and the time to authenticate it is O(n). For a non- 
hamiltonian certificate (F) = 〈Ĉ, Fˆ 〉, the authentication algorithm checks whether 
G( Fˆ −Ĉ) contains at least |Ĉ| + 1 connected components. The size of this certificate 
is O(n), and testing whether G( Fˆ −Ĉ) contains at least |Ĉ| + 1 connected components 
takes O(n) time. Thus, the authentication algorithm runs in O(n) time. Then we 
conclude the following theorem. 
Theorem 9. Given a circular-arc model F with n sorted arcs, Algorithm 
Certifying-HC-Arcs is a certifying algorithm for solving the Hamiltonian cycle 
problem on G(F) in O(∆⋅n) time, where ∆ is the maximum degree of G(F). The 
certificates provided by the algorithm can be authenticated in O(n) time. 
3.2.4. The Certifying Hamiltonian Path and Path Cover Algorithms   
In [25], we proposed an O(n)-time approximation non-certifying algorithm for 
the path cover problem on a circular-arc graph G(F). Let π′ be the cardinality of the 
path cover found by the approximation algorithm. In [25], we have showed that π′ ≤ 
π(G(F)) + 1. Then, the path cover problem on G(F) can be solved by reducing it to the 
19 
 Ruo-Wei Hung and Maw-Shang Chang, An efficient certifying algorithm 
for the Hamiltonian cycle problem on circular-arc graphs, Theoretical 
Computer Science 412/39 (2011) pp. 5351−5373. 
 
21 
Theory of NP-Completeness, Freeman, San Francisco, CA, 1979. 
[16] M.C. Golumbic, Algorithmic Graph Theory and Perfect Graphs, Second edition, 
Annals of Discrete Mathematics 57, Elsevier, 2004. 
[17] P. Heggernes and D. Kratsch, Linear-time certifying algorithms for recognizing 
split graphs and related graph classes, Nordic J. Comput. 14 (2007) 87−108. 
[18] P. Hell and J. Huang, Certifying LexBFS recognition algorithms for proper 
interval graphs and proper interval bigraphs, SIAM J. Discrete Math. 18 (2005) 
554−570. 
[19] S.Y. Hsieh, C.W. Ho, T.S. Hsu, and M.T. Ko, The Hamiltonian problem on 
distance-hereditary graphs, Discrete Appl. Math. 153 (2006) 508−524. 
[20] W.L. Hsu and K.H. Tsai, Linear time algorithms on circular-arc graphs, Inform. 
Process. Lett. 40 (1991) 123−129. 
[21] W.L. Hsu, O(M⋅N) algorithms for the recognition and isomorphism problems on 
circular-arc graphs, SIAM J. Comput. 24 (1995) 411−439. 
[22] R.W. Hung, S.C. Wu, and M.S. Chang, Hamiltonian cycle problem on distance- 
hereditary graphs, J. Inform. Sci. Eng. 19 (2003) 827−838. 
[23] R.W. Hung and M.S. Chang, A simple linear algorithm for the connected 
domination problem in circular-arc graphs, Discuss. Math. Graph Theory 24 
(2004) 137−145. 
[24] R.W. Hung and M.S. Chang, Linear-time algorithms for the Hamiltonian 
problems on distance-hereditary graphs, Theoret. Comput. Sci. 341 (2005) 
411−440. 
[25] R.W. Hung and M.S. Chang, Solving the path cover problem on circular-arc 
graphs by using an approximation algorithm, Discrete Appl. Math. 154 (2006) 
76−105. 
[26] R.W. Hung and M.S. Chang, Finding a minimum path cover of a distance- 
hereditary graph in polynomial time, Discrete Appl. Math. 155 (2007) 
2242−2256. 
[27] L. Ibarra, A simple algorithm to find Hamiltonian cycles in proper interval 
graphs, Inform. Process. Lett. 109 (2009) 1105−1108. 
[28] A. Itai, C.H. Papadimitriou, and J.L. Szwarcfiter, Hamiltonian paths in grid 
graphs, SIAM J. Comput. 11 (1982) 676−686. 
[29] D.S. Johnson, The NP-complete column: an ongoing guide, J. Algorithms 6 
(1985) 434−451. 
[30] H. Kaplan and Y. Nussbaum, Certifying algorithms for recognizing proper 
circular-arc graphs and unit circular-arc graphs, Lecture Notes in Comput. Sci., 
vol. 4271, Springer, Berlin, 2006, pp. 11−16. 
[31] J.M. Keil, Finding Hamiltonian circuits in interval graphs, Inform. Process. Lett. 
23 
Math. Combin. Comput. 19 (1995) 55−63. 
[48] W.K. Shih, T.C. Chern, and W.L. Hsu, An O(n2 log n) time algorithm for the 
Hamiltonian cycle problem on circular-arc graphs, SIAM J. Comput. 21 (1992) 
1026−1046. 
[49] R. Srikant, R. Sundaram, K.S. Singh, and C.P. Rangan, Optimal path cover 
problem on block graphs and bipartite permutation graphs, Theoret. Comput. Sci. 
115 (1993) 351−357. 
[50] R. E. Tarjan and M. Yannakakis, Addendum: Simple linear-time algorithms to 
test chordality of graphs, test acyclicity of hypergraphs, and selectively reduce 
acyclic hypergraphs, SIAM J. Comput. 14 (1985) 254−255. 
[51] G.T. Toussaint, Pattern recognition and geometrical complexity, in: Proceedings 
of the 5th International Conference on Pattern Recognition, Miami Beach, 1980, 
pp. 1324−1347. 
[52] A.C. Tucker, An efficient test for circular-arc graphs, SIAM J. Comput. 9 (1980) 
1−24. 
[53] M.S. Waterman and J.R. Griggs, Interval graphs and maps of DNA, Bull. Math. 
Biol. 48 (1986) 189−195. 
[54] P.K. Wong, Optimal path cover problem on block graphs, Theoret. Comput. Sci. 
225 (1999) 163−169. 
[55] J.H. Yan and G.J. Chang, The path-partition problem in block graphs, Inform. 
Process. Lett. 52 (1994) 317−322. 
[56] H.G. Yeh and G.J. Chang, The path-partition problem in bipartite distance- 
hereditary graphs, Taiwanese J. Math. 2 (1998) 353−360. 
 
25 
problem on circular-arc graphs)? 
4. ???????????????????????????????? 
5. ?????????????????????????????????
??????????????? 
??????????????????????(proper interval graphs)?
??????(neighbor- scattering number)???????????? 
 Ruo-Wei Hung, Chun-Kai Wang and Chih-Chia Yao, The neighbor-scattering 
number of proper interval graphs, ICIC Express Letters 5/6 (2011) pp. 
2059−2064. (EI)  (????????) 
??????????????????????(proper interval graphs)?
??????(neighbor- scattering number)???????????? 
?????????????????? 2011??????? International 
MultiConference of Engineers and Computer Scientists 2011 (IMECS’2011)????
?? 2012? International Conference on Advanced Information Technologies and 
The Second National Conference on Web Intelligence and Applications (AIT / NCWIA 
2012),????????????????????????(????????) 
 Ruo-Wei Hung and Chien-Chih Liao, Two edge-disjoint Hamiltonian cycles 
and two-equal path partition in augmented cubes, in: International 
MultiConference of Engineers and Computer Scientists 2011 (IMECS’2011), 
Hong Kong, vol. I, 2011, pp. 197−201.  (EI, ISI Proceeding, DBLP, Scopus, 
Computer Science Bibliographies) [Award: Best Paper Award]  
 Ruo-Wei Hung and Chien-Chih Liao, Constructing two edge-disjoint 
Hamiltonian cycles in decomposable networks, in: 2012 International 
Conference on Advanced Information Technologies and The Second National 
Conference on Web Intelligence and Applications (AIT/NCWIA 2012), Taichung, 
2012, Article no. 47. [Award: Best Paper Award] 
 
Linear-Time Certifying Algorithms for the Path Cover and Hamiltonian Cycle
Problems on Interval Graphs
Ruo-Wei Hunga,∗, Maw-Shang Changb
aDepartment of Computer Science and Information Engineering, Chaoyang University of Technology, Wufeng, Taichung 413, Taiwan
bDepartment of Computer Science and Information Engineering, National Chung Cheng University, Ming-Hsiung, Chiayi 621, Taiwan
Abstract
A certifying algorithm for a problem is an algorithm that provides a certificate with each answer that it produces. The
certificate is an evidence that can be used to authenticate the correctness of the answer. A Hamiltonian cycle in a
graph is a simple cycle in which each vertex of the graph appears exactly once. The Hamiltonian cycle problem is to
test whether a graph has a Hamiltonian cycle. A path cover of a graph is a family of vertex-disjoint paths that covers
all vertices of the graph. The path cover problem is to find a path cover of a graph with minimum cardinality. This
paper presents O(n)-time certifying algorithms for the above two problems on interval graphs given a set of n intervals
with endpoints sorted. The certificates provided by our algorithms can be authenticated in O(n) time.
Keywords: Certifying algorithms, Path cover, Hamiltonian cycle, Interval graphs
1. Introduction
The study of certifying algorithms is motivated by software engineering, software reliability and the insight that
software is often not bug-free. Although an algorithm has been always proved to be correct, its implementation may
contain bugs. Thus, it is desirable to have tools for knowing whether the output of an implementation of an algorithm
is correct or returned due to a bug. Obviously, there is no way to guarantee by the design and analysis of an algorithm
that its implementations are bug-free. Nevertheless, certifying algorithm design may support software reliability.
The name “certifying algorithm” was coined in [14]. A certifying algorithm for a problem is an algorithm that
provides a certificate with each answer that it produces. An authentication algorithm is a separate algorithm that
confirms the validity of the answer by checking the certificate; it takes the input, the answer, and the certificate
produced by the original algorithm, and verifies (independently of the original algorithm) whether the answer is
correct. For example, an implementation of a certifying algorithm testing whether an input graph is bipartite provides
an odd cycle as a certificate whenever it claims the input graph is not bipartite, and provides two disjoint independent
vertex sets as a certificate if it claims the input graph is bipartite. An authentication algorithm can verify the correctness
of an answer claiming the input graph is not bipartite by checking whether the certificate is an odd cycle of the input
graph indeed; and verify the correctness of an answer claiming the input graph is bipartite by checking whether the
certificate does consist of two disjoint independent sets whose union is the vertex set of the input graph. Usually
we prove the correctness of our algorithm after we design it. However the purpose of a certificate produced by a
certifying algorithm is not to prove the correctness of the algorithm. It is for implementation of the algorithm. When
we implement a valid algorithm, we are not sure that the implementation is bug-free. One way to see the correctness
of the implementation is to output a certificate for each answer it produces and let an authentication program verify
the correctness of the answer by checking the certificate. Certifying algorithms reduce the risk of erroneous answer,
caused by bugs in the implementation. For more background on certifying algorithms, we refer the readers to [10, 15].
∗Corresponding author.
Email addresses: rwhung@cyut.edu.tw (Ruo-Wei Hung), mschang@cs.ccu.edu.tw (Maw-Shang Chang)
Preprint submitted to Applied Mathematics Letters December 3, 2010
i
1
i
2
i
3
i
4
i
5
i
6
i
7
i
8
i
9
i
10
i
11
i
12
Fig. 1: An interval model I of twelve endpoint-sorted intervals.
Since each connected subgraph needs to be covered by at least one path, the following propositions can be easily
verified by the pigeonhole principle.
Proposition 2.1. (Shih et al. [21]) Let C be a cutset of a graph G and let g be the number of connected components
in G −C. Then, π(G)  g − |C|.
Proposition 2.2. Let C be a cutset of a graph G and let g be the number of connected components in G−C. If g > |C|,
then G has no Hamiltonian cycle.
3. A Certifying Algorithm for the Path Cover Problem on Interval Graphs
Arikati and Rangan [1] gave an O(n+m)-time algorithm for the path cover problem on interval graphs. Manacher
et al. [16] presented an O(n log log n)-time algorithm for the Hamiltonian path problem on interval graphs given a set
of n endpoint-sorted intervals. The two papers were published in the same volume of Information Processing Letters.
They used the same greedy approach independently. Assume that the input graph is given by an interval model I that
is a set of n endpoint-sorted intervals labeled by 1, 2, . . . , n in increasing order of their right endpoints. Notice that we
do not distinguish an interval from its label. The left endpoint of interval x is denoted by left(x) and the right endpoint
by right(x). Interval x is denoted by (left(x), right(x)). An interval x is said to contain another interval y if every point
of y falls within the interior of (left(x), right(x)). For convenience, we need the following notation.
(1) For two distinct intervals x, y in I, x is smaller than y (or y is larger than x), denoted by x < y, if right(y) is to the
right of right(x), and y is to the right of x if left(y) is to the right of right(x).
(2) s(I) denotes the interval in I with the leftmost right endpoint; that is, s(I)  x for x ∈ I.
We first introduce Procedure GP that is the key procedure used in the algorithm in [1] for the path cover problem.
Given an interval model I, Procedure GP uses a greedy principle to obtain a path Z as follows. Initially, Z visits s(I)
only, i.e., Z = s(I). Repeatedly extend Z to visit the one with the leftmost right endpoint among neighbors of end(Z)
not visited by Z until all neighbors of end(Z) are visited by Z. Then it outputs path Z and stops. For instance, given a
set of 12 endpoint-sorted intervals shown in Fig. 1, Procedure GP outputs path Z = i1 → i2 → i3 → i4 → i6 → i5.
For interval model I, define a path cover PC(I) ofG(I) recursively as follows. If I = ∅, then PC(I) = ∅. Otherwise,
let PC(I) = {Z} ∪ PC(I′), where Z is the path obtained from I by Procedure GP and I′ = I − Z. For instance,
PC(I) = {Z1 = i1 → i2 → i3 → i4 → i6 → i5,Z2 = i7 → i8 → i9 → i10 → i12 → i11}, where I is the set of intervals
shown in Fig. 1, Z1 and Z2 are the paths obtained by Procedure GP from I and I − Z1, respectively.
Arikati and Rangan [1] proved by induction that PC(I) is an optimal path cover of G(I). Chang et al. [4] showed
that PC(I) can be computed in O(n) time and O(n) space given a set of n endpoint-sorted intervals.
Our certifying algorithm for the path cover problem on interval graphs works as follows. It computes PC(I) as
both an optimal path cover of G(I) and a certificate showing that PC(I) is indeed an optimal path cover of G(I). Note
that the length of PC(I) is O(n).
Before we show how to verify the optimality of PC(I), let us observe the behavior of Procedure GP and the path
obtained by it from I. It is easy to see that every interval in I − {s(I)} is either a neighbor of s(I) or to the right of s(I).
We see that Procedure GP maintains the following invariant while growing path Z to be output:
Every interval x ∈ I − Z is either a neighbor of end(Z) or to the right of end(Z).
Initially, Z = s(I) and the invariant holds trivially. Assume now Z = z1 → z2 → · · · → zh with h  1 and the invariant
holds. Let interval z be the one with the leftmost right endpoint among the neighbors of end(Z) not in Z. There are
two cases: either z < zh or zh < z. Consider the former case first. By the variant, z = s(I − Z). Hence every interval in
3
i
5
i
2
i
1
i
6
i
7
i
3
i
8
i
4
Fig. 2: A sorted interval model I with a Hamiltonian cycle, where arrow lines indicate the visited sequences of the two paths.
i
5
i
2
i
1
i
6
i
7
i
3
i
8
i
4
Fig. 3: A sorted interval model I without Hamiltonian cycle, where arrow lines indicate the visited sequences of the two paths.
components. If G(I − C(Z)) does have more than |C(Z)| connected components, then by Proposition 2.2 G(I) does
have no Hamiltonian cycle. On the other hand, suppose I − Z = ∅ and L(Z) = ∅. That is, G(I) has a Hamiltonian path
Z with L(Z) = ∅. Then, we grow two paths P1 and P2 from Z. Let Z = z1 → z2 → · · · → zn−1 → zn. Initially, let
P1 = z1 and P2 = z2. Then for i from 3 to n, we grow the two paths as follows. Let P∗ be the one that visits zi−1 and
P′ be the other path. If zi is adjacent to end(P′) then extend P′ to visit zi; otherwise extend P∗ to visit zi. After all
intervals are visited by either one of the two paths, let P∗ be the one that visits zn and P′ be the other path. We can
easily see thatG(I) has a Hamiltonian cycle if P′ visits zn−1 since z1 and z2 are adjacent and zn−1 and zn are adjacent. In
this case, the algorithm outputs the Hamiltonian cycle obtained from the two paths. On the other hand, it claims that
G(I) has no Hamiltonian cycle if P′ does not visit zn−1. Next, we show how to obtain a certificate proving that G(I)
has no Hamiltonian cycle in case that zn−1  P′. Let h be the largest index such that zh ∈ P′. Clearly, h < n − 1. Let
Z′ = z1 → z2 → · · · → zh−1 → zh. By the above algorithm, zh+1 ∈ P∗. Then for h + 2  i  n, zi is not adjacent to zh
by the algorithm and is to the right of zh by the invariant maintained by ProcedureGP. Notice that the set {zh+2, . . . , zn}
is not empty. Hence, {zh+2, . . . , zn} is an island with respect to L(Z′)∪ {zh+1} inG(I). Then, there are at least |C(Z′)|+2
islands with respect to C(Z′) ∪ {zh+1} in G(I). The algorithm outputs C(Z′) ∪ {zh+1} as a certificate showing that G(I)
has no Hamiltonian cycle by Proposition 2.2.
For instance, given a set of sorted intervals shown in Fig. 2, Z = i1 → i2 → i4 → i3 → i5 → i6 → i7 → i8. Then,
P1 = i1 → i5 → i6 → i7 and P2 = i2 → i4 → i3 → i8. It is easy to see that a Hamiltonian cycle can be obtained from
the two paths. On the other hand, given a set I of sorted intervals shown in Fig. 3, Z = i1 → i2 → i4 → i3 → i5 →
i6 → i7 → i8. Then, P1 = i1 → i5 → i6 → i7 → i8 and P2 = i2 → i4 → i3. We can see that Z′ = i1 → i2 → i4 → i3,
C(Z′) = {i4}, and zh+1 = i5. Then, G(I − {i4, i5}) contains 3 connected components. By Proposition 2.2, G(I) has no
Hamiltonian cycle. We finally conclude the following theorem.
Theorem 4.1. There is an O(n)-time certifying algorithm for the Hamiltonian cycle problem on sorted interval models.
The length of the certificate provided by the algorithm is O(n) and the authentication algorithm runs in O(n) time.
5. Concluding Remarks
Certifying algorithms provide more software reliability than the traditional algorithms. They oﬀer a certificate
accompanying each answer that it produces. An authentication algorithm then confirm the validity of the answer by
checking the certificate. In this paper, we propose O(n)-time certifying algorithms for solving the path cover and
Hamiltonian cycle problems on interval graphs given a set of n endpoint-sorted intervals. The certificates provided
by our algorithms can be authenticated in O(n) time. It is interesting to see if the proposed certifying algorithms can
be applied to the path cover and Hamiltonian problems on circular-arc graphs, which form a superclass of interval
graphs.
5
27 
??? (Appendix II)???????? 
 Ruo-Wei Hung and Maw-Shang Chang, An efficient certifying algorithm for 
the Hamiltonian cycle problem on circular-arc graphs, Theoretical Computer 
Science 412/39 (2011) pp. 5351−5373. (SCI/EI)  (????????????
??????????????????????)  
 
In general, we prove the correctness of our algorithm after we design it. However the purpose of a certificate
produced by a certifying algorithm is not to prove the correctness of the algorithm. It is for the implementation
of an algorithm. When we implement a valid algorithm, we are not sure whether the implementation is bug-free.
One way to see the correctness of the implementation is to output a certificate for each answer that it produces and
let an authentication program verify the correctness of the answer by checking the certificate. The certificate has
practical value when the implementation of an algorithm for solving the problem from scratch is diﬃcult but the
implementation of the authentication algorithm is easier. For more background on certifying algorithms, we refer
the readers to [19, 20, 31, 33]. We also refer the readers to the recent survey paper [41] for a detailed discussion on
certifying algorithms.
A recognition algorithm is an algorithm that decides whether a given input (graph, geometrical object, picture,
etc.) has a certain property. Such an algorithm accepts the input if it has the property or rejects it if it does not.
Some certifying recognition algorithms have appeared in the literature recently [9, 18, 19, 31, 33, 42]. In fact some
recognition algorithms published before the term certifying algorithms appeared were certifying algorithms already.
To the best of our knowledge, most published certifying algorithms are recognition algorithms for special classes of
graphs. Recently, we presented linear-time certifying algorithms for the path cover and Hamiltonian cycle problems
on interval graphs [28].
1.2. Our results
All graphs considered in the paper are finite and undirected, without loops or multiple edges. Throughout this
paper, let m, n, and ∆ denote the number of edges, the number of vertices, and the maximum degree of a graph,
respectively. For any two sets X and Y , let X − Y denote the set of elements of X that are not in Y . A Hamiltonian
cycle in a graph is a simple cycle in which each vertex of the graph appears exactly once. A Hamiltonian path
in a graph is a simple path with the same property. The Hamiltonian cycle (resp., path) problem involves testing
whether or not a graph contains a Hamiltonian cycle (resp., path). A graph is said to be hamiltonian if it contains a
Hamiltonian cycle. The Hamiltonian problems include the Hamiltonian path and Hamiltonian cycle problems. They
have numerous applications in diﬀerent areas, including establishing transport routes, production launching, the on-
line optimization of flexible manufacturing systems [2], computing the perceptual boundaries of dot patterns [43],
and pattern recognition [3, 44, 47]. It is well known that the Hamiltonian problems are NP-complete for general
graphs [16, 30]. The same holds true for bipartite graphs [34], split graphs [17], circle graphs [10], undirected path
graphs [4], and grid graphs [29]. However, polynomial time non-certifying algorithms exist for the Hamiltonian cycle
or Hamiltonian path problem on some special classes of graphs, such as interval graphs [1, 7], permutation graphs
[14, 45], cocomparability graphs [11, 13], distance-hereditary graphs [21, 24, 26], and circular-arc graphs [46]. A
path cover of a graph G is a family of vertex-disjoint paths that cover all vertices of G. A minimum path cover of a
graph G is a path cover with minimum cardinality, denoted by π(G). The path cover problem is to find a minimum
path cover of a graph G. This problem is NP-hard for general graphs [16] since it contains the Hamiltonian path
problem as a special case.
A graph G = (V, E) is called an intersection graph for a finite family F of nonempty sets if there is a one-to-one
correspondence betweenF and V such that two sets inF have nonempty intersection if and only if their corresponding
vertices in V are adjacent. We call F an intersection model of G. For an intersection model F , we use G(F ) to denote
the intersection graph for F . If F is a family of intervals on a real line, then G is called an interval graph for F and
F is called an interval model of G. If F is a family of arcs on a circle, then G is called a circular-arc graph for F
and F is called a circular-arc model of G. If there exists a point on the circle such that no arc in a circular-arc model
F passes through, then G(F ) is also an interval graph. Thus, circular-arc graphs form a superclass of interval graphs.
Interval graphs and circular-arc graphs have a variety of applications involving traﬃc light sequencing, VLSI design,
scheduling [17], and genetics [50]. Kratsch et al. [33] presented a linear-time certifying recognition algorithm for
interval graphs and McConnell [40] gave a linear-time non-certifying recognition algorithm for circular-arc graphs.
Shih et al. presented an O(n2 log n)-time algorithm for the Hamiltonian cycle problem on circular-arc graphs
[46]. If the given graph does not contain a Hamiltonian cycle, their algorithm can produce a proof either through the
deletion of an appropriate cut set or through the failure to obtain a specific type of Hamiltonian cycle. Thus, it is not
diﬃcult to modify the algorithm in [46] to provide a supporting evidence for its answer, and hence their algorithm is
a certifying algorithm already. However, whether there exists an eﬃcient algorithm whose time complexity is better
than O(n2 log n) for the Hamiltonian cycle problem on circular-arc graphs has been opened for two decades. In this
2
path is called the reversed path, denoted by Prev, of P if it visits the vertices of P from end(P) to start(P) sequently;
that is, the reversed path Prev of P = v1 → v2 → · · · → v|P|−1 → v|P| is v|P| → v|P|−1 → · · · → v2 → v1.
Let G = (V, E) be a graph with vertex set V and edge set E. For a subset S ⊆ V of vertices, we write G[S ] for the
subgraph of G induced by S , G − S for the subgraph G[V − S ], i.e., the subgraph induced by V − S . For a vertex v in
G, we write G − v instead of G − {v}. Let S and C be two disjoint subsets of vertices in G such that S is nonempty.
We say that S is an island with respect to C in G or an island in G − C if no vertex in S is adjacent to any vertex of
V − (C ∪ S ) in G. By the above definition, an island S with respect to C in G is not empty and it contains at least one
connected component in G −C. A subset C of vertices of G is called a cut set if the removal of C from G disconnects
G. We call C a connecting set of G if C is a cut set of G and the removal of C from G disconnects G into at least
|C| + 1 connected components.
Since each connected subgraph needs to be covered by at least one path, the following proposition can be easily
verified by the pigeonhole principle.
Proposition 2.1. [46] Let C be a cut set of a connected graph G and let g be the number of connected components in
G −C. Then, π(G)  g − |C|.
For C ⊆ V , let E(C) denote the set of edges of E that join two vertices in C. The following two propositions are
very important in proving the correctness of our algorithm and can be easily verified by the pigeonhole principle.
Proposition 2.2. Let C be a cut set of a connected graph G and let g be the number of connected components in
G −C. If g > |C|, then G has no Hamiltonian cycle.
Proposition 2.3. Let C be a cut set of a connected graph G and let g be the number of connected components in G−C
such that g = |C|. Then, G = (V, E) is hamiltonian if and only if G′ = (V, E − E′) is hamiltonian, where E′ is any
nonempty subset of E(C).
2.2. A certifying algorithm for the path cover problem on interval graphs
Arikati and Rangan [1] gave an O(n+m)-time algorithm for the path cover problem on interval graphs. Manacher
et al. [38] gave an O(n log log n)-time for the Hamiltonian path problem on interval graphs given a set of n endpoint-
sorted intervals. They used the same greedy approach independently. It is assumed that the input graph is given by
an interval model I that is a set of n endpoint-sorted intervals labelled by 1, 2, · · · , n in increasing order of their right
endpoints. Notice that we do not distinguish an interval from its label. The left endpoint of interval x is denoted by
le f t(x) and the right endpoint by right(x). Interval x is denoted by (le f t(x), right(x)). Interval x intersects interval y if
and only if they share a point on a real line. An interval x is said to contain another interval y if every point of y falls
within the interior of (le f t(x), right(x)). For convenience, we introduce the following notations.
(1) For two distinct intervals x, y in I, x is smaller than y (or y is larger than x), denoted by x < y, if right(y) is to the
right of right(x), and y is to the right of x, denoted by x 	 y, if le f t(y) is to the right of right(x).
(2) s(I) denotes the interval in I with the leftmost right endpoint; that is, s(I)  x for x ∈ I.
We have showed in [28] that the algorithm in [1] for the path cover problem on interval graphs can be modified
as a certifying algorithm. We first review Procedure GP that is the key procedure used in the algorithm in [1] for the
path cover problem. Given an interval model I, Procedure GP uses a greedy principle to obtain a path Z as follows.
Initially, Z visits s(I) only, i.e., Z = s(I). Repeatedly extend Z to visit the one with the leftmost right endpoint
among neighbors of end(Z) not visited by Z until all neighbors of end(Z) are visited by Z. Then it outputs path Z
and stops. For instance, given a set of 12 endpoint-sorted intervals shown in Fig. 1, Procedure GP outputs the path
Z = i1 → i2 → i3 → i4 → i6 → i5.
For interval model I, define a path coverPC(I) of G(I) recursively as follows: If I = ∅, thenPC(I) = ∅. Otherwise,
let PC(I) = {Z} ∪ PC(I′), where Z is the path output by Procedure GP given I and I′ = I − Z. For instance,
PC(I) = {Z1 = i1 → i2 → i3 → i4 → i6 → i5,Z2 = i7 → i8 → i9 → i10 → i12 → i11}, where I is the set of intervals
shown in Fig. 1, Z1 and Z2 are the paths obtained by Procedure GP from I and I − Z1, respectively.
Arikati and Rangan [1] proved by induction that PC(I) is a minimum path cover of G(I). Chang et al. [7] showed
that PC(I) can be computed in O(n) time and O(n) space given a set of n endpoint-sorted intervals. Our certifying
algorithm in [28] for the path cover problem on interval graphs works as follows. It computes PC(I) as both a
4
Theorem 2.7. [28] There is an O(n)-time certifying algorithm for the path cover problem on sorted interval models.
The optimality of the output of this algorithm can be authenticated in O(n) time.
In [28], we also proposed an O(n)-time certifying algorithm for the Hamiltonian cycle problem on interval graphs
and gave the following theorem.
Theorem 2.8. [28] There is an O(n)-time certifying algorithm for the Hamiltonian cycle problem on sorted interval
models. The length of the certificate provided by this algorithm is O(n) and the authentication algorithm runs in O(n)
time.
3. A Non-Certifying Algorithm for the Hamiltonian Cycle Problem on Circular-Arc Graphs
Circular-arc graphs are simple generalization of interval graphs. However, circular-arc graphs have rich structure,
and there is a long history for the recognition problem. Tucker presented an O(n3)-time algorithm for testing whether
a graph is a circular-arc graph [48]. Hsu proposed an O(mn)-time algorithm to recognize circular-arc graphs [23].
Eschen and Spinrad proposed an O(n2)-time recognition algorithm for circular-arc graphs [15]. In 2003, McConnell
presented an O(n + m)-linear-time recognition algorithm for circular-arc graphs [40]. A circular-arc model F can
be obtained by these recognition algorithms in the aﬃrmative case. Thus, researchers studying circular-arc graphs
sometimes assumed that a set of arcs with endpoints sorted is given [7, 8, 22, 25, 39]. Throughout the remainder of
the paper, we assume that the input graph is given by a circular-arc model F that is a set of n endpoint-sorted arcs.
3.1. Definition and conversion
Some notations are defined in the subsection. In addition, we will introduce a conversion that maps F into a set of
intervals in clockwise or counterclockwise direction. An arc x in F that begins with endpoint p and ends at endpoint
q in clockwise direction is denoted by (p, q). We call p the head, denoted by h(x), and q the tail, denoted by t(x), of
arc x = (p, q). The contiguous part of the circle that begins with an endpoint c and ends at an endpoint d in clockwise
direction is referred to as segment (c, d), denoted by seg(c, d), of the circle. We use “arc” to refer to a member of F
and “segment” to refer to a part of the circle between two endpoints. A point y on the circle is said to be contained in
arc (or segment) (p, q) if it falls within the interior of seg(p, q). An arc or segment x is said to contain another arc or
segment y if x contains every point of y. Two arcs, or two segments, or an arc and a segment intersect if and only if
they share a point. Note that if a point on the circle is not contained in any arc of F then G(F) is an interval graph.
Without loss of generality, we will assume that (1) all endpoints are distinct, (2) no arc covers the entire circle, and
(3) an arc (segment) does not include its two endpoints, i.e., it is an open segment of the circle.
Definition 3.1. For a point q on the circle, let Bp(q) denote the set of all arcs in F containing point q. For an arc x in
F, let Ba(x) denote the set of all arcs in F that contain arc x.
Definition 3.2. Let q be a point on the circle. An arc v containing point q can be divided into two open segments
(h(v), q) and (q, t(v)), called the head portion and tail portion of arc v with respect to q, respectively, by removing q
from v. The head portion and tail portion of arc v with respect to q are denoted by head(v, q) and tail(v, q), respectively.
For a set B of arcs containing q, let head(B, q) = {head(v, q)|v ∈ B} and tail(B, q) = {tail(v, q)|v ∈ B}.
Definition 3.3. For a point q on the circle and a subsetB of Bp(q), let Fc(B, q) = (F−Bp(q))∪tail(B, q)∪head(Bp(q)−
B, q) and Fcc(B, q) = (F − Bp(q)) ∪ head(B, q) ∪ tail(Bp(q) − B, q), where the subscript ‘c’ (resp., ‘cc’) of Fc (resp.,
Fcc) indicates the ‘clockwise’ (resp., ‘counterclockwise’) mapping of F starting from point q.
Let v be an arc in F. If v ∈ B, then tail(v, q) ∈ Fc(B, q) (resp., head(v, q) ∈ Fcc(B, q)); otherwise, either
v ∈ Fc(B, q) or head(v, q) ∈ Fc(B, q) (resp., tail(v, q) ∈ Fcc(B, q)). We refer to the portion of arc v in Fc(B, q)
and Fcc(B, q) as arc v in Fc(B, q) and Fcc(B, q), respectively. For instance, given a set F of arcs shown in Fig. 2,
Fc(Ba(a1), h(a1)) and Fcc(∅, t(a6)) are shown in Figs. 3 and 4, respectively, where Bp(h(a1)) = {a2, a5, a6, a11} and
Ba(a1) = {a2, a5, a6}.
Since no arc in Fc(B, q) and Fcc(B, q) contains point q, G(Fc(B, q)) and G(Fcc(B, q)) are interval graphs. Ap-
parently, G(Fc(B, q)) and G(Fcc(B, q)) are spanning subgraphs of G(F). We can convert arcs in Fc(B, q) into a
set Ic(Fc(B, q)) of intervals in clockwise direction starting from point q on the circle such that G(Ic(Fc(B, q))) and
6
a1
a2
a3
a4
a5
a6a7
a8
a9
a10 a11
t a( )6
Fig. 4: Fcc(∅, t(a6)) for the set F of arcs shown in Fig. 2, where dashed lines of arcs indicate the removed portions of arcs from F.
a1
a2
a3
a4
a5
a6
a7
a8
a9
a10
a11
1
2
3 4
5
6
7
8
911
12
13
15
16
17
18
19
20
21
10
14
22
h a( )1
Fig. 5: The clockwise labelling by Procedure ArcToI given F shown in Fig. 2, endpoint q = h(a1), and B = Ba(a1).
3. for each arc x  B, x is converted to interval Ic(x) = (h(x), t(x)) if (t(x)) > (h(x)) (resp., Icc(x) = (t(x), h(x)) if
(h(x)) > (t(x))) and to interval Ic(x) = (h(x), t(x) + 2n) (resp., Icc(x) = (t(x), h(x) + 2n)) otherwise;
4. for each arc x ∈ B, x is converted to interval Ic(x) = (1, t(x)) (resp., Icc(x) = (1, h(x)));
5. let Ic(Fc(B, q)) = {Ic(x)|x ∈ F} (resp., Icc(Fcc(B, q)) = {Icc(x)|x ∈ F}) and output Ic(Fc(B, q)) (resp., Icc(Fcc(B, q))).
For instance, given F shown in Fig. 2, endpoint q = h(a1), and B = Ba(a1), Procedure ArcToI first labels the
endpoints of arcs of F (as shown in Fig. 5) in clockwise direction starting from h(a1). Then, it converts F into a
set Ic(Fc(Ba(a1), h(a1))) of intervals as shown in Fig. 6. We can see that G(Ic(Fc(Ba(a1), h(a1)))) is isomorphic to
G(Fc(Ba(a1), h(a1))) shown in Fig. 3. We call Ic(Fc(Ba(a1), h(a1))) to be the interval model of Fc(Ba(a1), h(a1)). On
the other hand, Procedure ArcToI constructs the interval model Icc(Fcc(∅, t(a6))) (as shown in Fig. 7) of Fcc(∅, t(a6))
(as shown in Fig. 4). Careful implementation of Procedure ArcToI takes O(n) time and O(n) space.
It is not diﬃcult to see that there is a one-to-one mapping between the sets of arcs of F and Fc(B, q) (resp., F and
Fcc(B, q)). There is also a one-to-one mapping between the set Fc(B, q) of arcs and the set Ic(Fc(B, q)) of intervals
(resp., Fcc(B, q) and Icc(Fcc(B, q))). Therefore there is a one-to-one mapping between the set F of arcs and the set
Ic(Fc(B, q)) of intervals (resp., F and Icc(Fcc(B, q))).
For simplicity, we define the following notations.
Definition 3.4. Let q be a point on the circle, B be a subset of Bp(q), and let F′ be either Fc(B, q) or Fcc(B, q). Let
8
• Call Procedure GP to obtain path Qs from Is. Notice that start(Qs) = start(Q) = z.
• If Qs is the Hamiltonian path of G(Is) and arc s intersects arc F(end(Qs)), then output “s → Qs → s” as a
Hamiltonian cycle of G(F) and stop; Else let R = R − {s}.
At last, the algorithm determines whether G(Icc) has a Hamiltonian cycle or not. If G(Icc) has a Hamiltonian cycle,
then a Hamiltonian cycle of G(Icc) is also a Hamiltonian cycle of G(F); otherwise output “G(F) has no Hamiltonian
cycle”. The algorithm is formally presented as follows.
Algorithm HC-Arcs
Input: F, a set of sorted arcs.
Output: A Hamiltonian cycle of G(F) if it is hamiltonian; otherwise, G(F) has no Hamiltonian cycle.
Method:
1. pick an arc µ of F that does not contain any other arc;
2. compute Fc = Fc(Ba(µ), h(µ));
3. construct the interval model Ic of Fc by calling Procedure ArcToI that is a clockwise conversion starting from
h(µ), i.e., Ic = Ic(Fc);
4. call Procedure GP to obtain path P from Ic;
5. let P = P1 → c1 → P2 → · · · → ck−1 → Pk → ck → Pk+1, where C(P) = {c1, c2, · · · , ck};
6. let υ and υP be the arcs corresponding to end(P1) and end(P), i.e., υ = F(end(P1)) and υP = F(end(P));
7. if µ ∈ Bp(t(υP)), then output “P→ start(P)” as a Hamiltonian cycle of G(F);
8. compute Fcc = Fcc(∅, t(υ));
9. construct the interval model Icc of Fcc by calling Procedure ArcToI that is a counterclockwise conversion
starting from t(υ), i.e., Icc = Icc(Fcc);
10. call Procedure GP to obtain path Q from Icc;
11. if Q is not a Hamiltonian path of G(Icc), then output “G(F) has no Hamiltonian cycle”;
12. let z and ω be the arcs corresponding to start(Q) and end(Q), respectively, i.e., z = F(start(Q)) and ω =
F(end(Q));
13. if arc z and arc ω intersect, then output “Q→ start(Q)” as a Hamiltonian cycle of G(F);
14. let R = {r ∈ F|r ∈ Bp(h(ω)) − F(L(Q))};
15. while R  ∅ do // iteration step
16. let s be an arc of R such that right(Icc(s)) is the smallest in Icc(R), i.e., Icc(s)  Icc(x) for x ∈ R;
17. let Is be the set of intervals obtained by removing Icc(s) from Icc, i.e., Is = Icc − {Icc(s)};
18. call Procedure GP to obtain path Qs from Is;
19. if Qs is the Hamiltonian path of G(Is) and arc s intersects arc F(end(Qs)), then output “s→ Qs → s” as a
Hamiltonian cycle of G(F);
20. else let R = R − {s};
21. if G(Icc) is hamiltonian, then output the Hamiltonian cycle found in G(Icc);
22. else output “G(F) has no Hamiltonian cycle”.
We now give the following two examples to illustrate Algorithm HC-Arcs.
Example 1. Let F be the set of arcs shown in Fig. 2. The algorithm first picks arc µ = a1 that does not contain
any other arc. It computes Fc = Fc(Ba(a1), h(a1)) (as shown in Fig. 3) and constructs the interval model Ic of Fc
by a clockwise conversion starting from h(a1) (as shown in Fig. 6). The path P output by Procedure GP given Ic
is a1 → a2 → a3 → a5 → a4 → a6 → a9 → a7 → a10 → a8. It is straightforward to verify that the greedy
connecting set of P is C(P) = {a9, a10} and P1 = a1 → a2 → a3 → a5 → a4 → a6. Then, υ = F(end(P1)) = a6
and υP = F(end(P)) = a8. Clearly, µ = a1  Bp(t(a8)). The algorithm then computes the set Fcc = Fcc(∅, t(a6)) (as
shown in Fig. 4) and constructs the interval model Icc of Fcc by a counterclockwise conversion starting from t(a6)
(as shown in Fig. 7). Call Procedure GP given Icc to obtain path Q = a4 → a6 → a3 → a5 → a1 → a11 →
a10 → a8 → a9 → a7 → a2. It is easy to see that Q is a Hamiltonian path of G(Icc), z = F(start(Q)) = a4, and
ω = F(end(Q)) = a2. Then, R = {r ∈ F|r ∈ Bp(h(a2)) − F(L(Q))} = {a6}. In this time, s = a6. Let Is = Icc − {Icc(a6)}.
Call Procedure GP given Is to obtain Qs = a4 → a5 → a3 → a2 → a1 → a11 → a10 → a8 → a9 → a7. It is
straightforward to verify that Qs is a Hamiltonian path of G(Is) but arc s = a6 does not intersect arc F(end(Qs)) = a7.
10
a1
a4
a5
a6
a2
a3 a7
a8
Fig. 10: The set Icc of intervals converted from F shown in Fig. 8 by a counterclockwise conversion starting from t(a8).
We have proved the correctness of Algorithm HC-Arcs when µ = υP or µ ∈ Bp(t(υP)). Throughout the remainder
of the section, we assume that µ  υP and µ  Bp(t(υP)). The following lemma was given in [27] and will be used in
proving the correctness of our algorithm.
Lemma 4.1. [27] Assume that µ  υP and µ  Bp(t(υP)). The following statements then hold true:
(1) seg(h(µ), t(υP)) contains t(µ);
(2) Bp(t(υP)) ⊆ F(L(P)) ∪ Ba(µ);
(3) path P visits Ic(x) if and only if either x = µ or arc x intersects seg(t(µ), t(υP)); and
(4) if L(P)  ∅ and P = P1 → c1 → P2 → · · · → ck−1 → Pk → ck → Pk+1, where C(P) = {c1, c2, · · · , ck} is the greedy
connecting set of path P and υ = F(end(P1)), then every arc of F(P− (P1 ∪C(P))) is contained in seg(t(υ), t(υP)) and
no arc of F(Pi) intersects any arc of F(Pj) for i  j and k + 1  i, j  2.
The relative locations of arcs µ, υ, υP on the circle are depicted in Fig. 11 when µ  υP and µ  Bp(t(υP)). Fig.
11 also shows the relative locations of arcs visited by P1, P2, · · · , Pk+1 on the circle. In addition, the relative locations
of intervals of Icc corresponding to arcs of F(P1), F(P2), · · · , F(Pk+1), and F − F(P) are shown in Fig. 12. We first
prove the following lemma.
Lemma 4.2. Let P = P1 → c1 → P2 → · · · → ck−1 → Pk → ck → Pk+1 where C(P) = {c1, c2, · · · , ck}. Assume that
L(P)  ∅. Then, arc F(ci) contains every arc of F(Pi+1) for k  i  1.
Proof. Let ci be an interval of C(P) and let x be an interval of Pi+1 for k  i  1. By Statements (1) and (4) of
Lemma 4.1, any arc of F(P − (P1 ∪ C(P))) does not intersect arc µ, and, hence, arc F(x) does not intersect arc µ.
By the definition of Fc, Fc(x) = F(x). By Statement (6) of Lemma 2.5, interval ci contains interval x. Thus, Fc(ci)
contains Fc(x). By the definition of Fc, either Fc(ci) = F(ci) or Fc(ci) = tail(F(ci), h(µ)) depending on whether
F(ci) ∈ Ba(µ). Thus, F(ci) contains Fc(ci). Since F(ci) contains Fc(ci), Fc(ci) contains Fc(x), and Fc(x) = F(x), we
get that F(ci) contains F(x). Thus, the lemma holds true. 
The following lemma shows that arcs containing t(υ) are in F(C(P)) ∪ Ba(µ).
Lemma 4.3. Let υ = F(end(P1)) and let X be the set of arcs that contain t(υ). Then, X ⊆ F(C(P)) ∪ Ba(µ), i.e.,
Bp(t(υ)) ⊆ F(C(P)) ∪ Ba(µ).
Proof. If L(P) = ∅, then υ = υP and hence Bp(t(υ)) ⊆ F(L(P))∪Ba(µ) ⊆ F(C(P))∪Ba(µ) by Statement (2) of Lemma
4.1. Suppose that L(P)  ∅. Then, υ  υP. We refer the readers to Fig. 11 for the relative locations of arcs µ, υ,
and υP. By the definition of Ic, right(Ic(x)) corresponds to t(x) for x ∈ F(P). By Statement (3) of Lemma 4.1, either
υ = µ or υ intersects seg(t(µ), t(υP)). Obviously, t(υ)  seg(t(υP), t(µ)). Otherwise, Ic(υ) will be in L(P). Thus, t(υ)
is contained in seg(t(µ), t(υP)) if υ  µ. Let x1 be an arc in F − F(P) and let x2 be an arc in F(P − (P1 ∪ C(P))). By
Statement (3) of Lemma 4.1, x1 is contained in seg(t(υP), t(µ)) and, hence, it is contained in seg(t(υP), t(υ)). Thus,
x1  Bp(t(υ)). By Statement (4) of Lemma 4.1, x2 is contained in seg(t(υ), t(υP)). Thus, x2  Bp(t(υ)). On the other
hand, we consider that there exists an arc x3 in F(P1) − {µ, υ}. Then, υ  µ. By Statement (1) of Lemma 2.5, P1
is a monotone path. Thus, Ic(µ) < Ic(x3) < Ic(υ) and, hence, t(x3) is contained in seg(t(µ), t(υ)). If x3 ∈ Bp(t(υ)),
then arc x3 contains seg(t(υ), t(µ)) and hence it contains arc µ, i.e., x3 ∈ Ba(µ). We have showed that no arc of
(F − F(P)) ∪ F(P − (P1 ∪C(P))) contains t(υ) and arcs of F(P1) containing t(υ) are in Ba(µ). Thus, the lemma holds
true. 
To verify the correctness of Algorithm HC-Arcs, we first consider that Q is not a Hamiltonian path of G(Icc) and
prove the following claim.
12
By Statement (3) of Lemma 2.4, Icc(x) ∈ L(Q). In any case, Icc(x) ∈ L(Q) and hence x ∈ F(L(Q)). By the above
arguments, if x ∈ Bp(h(ω)) then x ∈ F(L(Q)). Thus, R = {r ∈ F|r ∈ Bp(h(ω)) − F(L(Q))} = ∅. 
By the above lemma, if R  ∅ then υ ∈ Bp(h(ω)) and υ ∈ R. Obviously, ω ∈ Bp(t(υ)) if and only if υ ∈ Bp(h(ω)).
We then have the following proposition.
Proposition 4.6. If R  ∅, then υ ∈ Bp(h(ω)) and ω ∈ Bp(t(υ)).
It follows from the above lemma and proposition that the iteration step (lines 15–20) of Algorithm HC-Arcs is
executed only if υ ∈ Bp(h(ω)) and ω ∈ Bp(t(υ)). We then prove the following claim.
Claim 2. Assume that Q is a Hamiltonian path of G(Icc), arc z does not intersect arc ω, and R  ∅. Then, G(F) is
hamiltonian if Qs is the Hamiltonian path of G(Is) and arc s intersects arc F(end(Qs)) (line 19).
Next, we prove the correctness of the iteration step. Suppose that R  ∅ and the algorithm does not terminate at
line 19. We remove tail(s, h(ω)) from F to obtain a new arc family ˆF. That is, ˆF = (F − {s}) ∪ head(s, h(ω)). Then,
we will prove the following claim.
Claim 3. Assume that Q is a Hamiltonian path of G(Icc), arc z does not intersect arc ω, R  ∅, and that Qs is not a
Hamiltonian path of G(Is) or arc s does not intersect arc F(end(Qs)). Then, G(F) is hamiltonian if and only if
G( ˆF) = G((F − {s}) ∪ head(s, h(ω))) is hamiltonian (line 20).
By Claim 3, we can obtain an arc family ˆF such that it preserves the hamiltonicity property of G(F). Thus, if the
algorithm does not terminate before line 21, then no arc of ˆF except ˆF(L(Q)) = F(L(Q)) contains h(ω), where ˆF = F
or ˆF = (F − {s}) ∪ head(s, h(ω)) for all s ∈ R. Thus, we finally prove the following claim.
Claim 4. Assume that Q is a Hamiltonian path of G(Icc), arc z does not intersect arc ω, and R = ∅. Then, G(F) is
hamiltonian if and only if G(Icc) is hamiltonian (lines 21-22).
In the following subsections, we will prove the correctness of the above claims.
4.1. The correctness of Claim 1
In this subsection, we will prove the correctness of Claim 1 that G(F) is not hamiltonian if Q is not a Hamiltonian
path of G(Icc), i.e., |PC(Icc)| > 1. We will find a cut set ˆCN of G(F) such that G(F − ˆCN) contains at least | ˆCN | + 1
connected components. By Proposition 2.2, G(F) has no Hamiltonian cycle and hence the claim holds true. First, we
consider that L(P) = ∅. Then, υ = υP. For the case of L(P) = ∅ and |PC(Icc)| > 1, the following lemma was given in
[27].
Lemma 4.7. [27] Assume that |PC(Icc)| > 1 and L(P) = ∅. Let Q be the path output by Procedure GP given Icc and
let ω = F(end(Q)). The following statements then hold true:
(1) either µ = ω or seg(t(υ), h(µ)) contains h(ω);
(2) Bp(t(υ)) ∪ Bp(h(ω)) = F(L(Q));
(3) an arc x is in F − F(Q) if and only if seg(t(υ), h(ω)) contains arc x; and
(4) if L(Q)  ∅, then G(F(Q −C(Q))) contains at least |C(Q)| connected components.
We refer the readers to Fig. 13 for the relative locations of arcs in Lemma 4.7. Using Lemmas 4.1 and 4.7, we
prove the following lemma.
Lemma 4.8. Assume that |PC(Icc)| > 1 and L(P) = ∅. Then, G(F − C(Q)) contains at least |C(Q)| + 1 connected
components.
Proof. Since |PC(Icc)| > 1, F − F(Q)  ∅. Since L(P) = ∅, we get that C(P) = ∅ and υ = υP. By Statement (1)
of Lemma 4.1 and Statement (1) of Lemma 4.7, seg(h(µ), t(υ)) properly contains arc µ and seg(h(ω), t(υ)) contains
seg(h(µ), t(υ)). By Statement (3) of Lemma 4.7, we have that (1) an arc x is in F−F(Q) if and only if it is contained in
seg(t(υ), h(ω)), and (2) an arc y is in F(Q) if and only if y intersects seg(h(ω), t(υ)). Hence, F −F(Q) is an island with
14
Proof. Consider the following two cases:
Case 1: |PC(Iccp)| > 1. By the definition of Iccp, if F − F(P) = ∅, then Iccp = Icc(P1) and hence |PC(Iccp)| = 1.
Thus, F−F(P)  ∅. Let R(Iccp) = PC(Iccp)−C(Iccp) = ∪hi1(Hi−C(Hi)). By Lemma 2.6, G(Iccp−C(Iccp)) contains
|R(Iccp)| = |PC(Iccp)|+|C(Iccp)| connected components. We claim that F(R(Iccp)) and F(P2), F(P3), · · · , F(Pk), F(Pk+1)
are islands with respect to ˆCccp in G(F). Then, G(F− ˆCccp) contains at least |R(Iccp)|+k connected components. Since
|R(Iccp)| = |PC(Iccp)| + |C(Iccp)|, |C(P)| = k, | ˆCccp| = |C(Iccp)| + |C(P)|, and |PC(Iccp)| > 1, we get that G(F − ˆCccp)
contains more than | ˆCccp| connected components. Then the lemma holds true.
We then prove the above claim as follows. Note that Iccp = Icc(P1 ∪ (F − F(P))) and R(Iccp) ⊆ Iccp. By Statement
(4) of Lemma 4.1, every arc of F(P2∪P3∪· · ·∪Pk∪Pk+1) is contained in seg(t(υ), t(υP)). By Statement (3) of Lemma
4.1, all arcs in F − F(P) are contained in seg(t(υP), t(µ)), and, hence they are contained in seg(t(υP), t(υ)). Thus, no
arc of F − F(P) intersects arcs of F(P2 ∪ P3 ∪ · · · ∪ Pk ∪ Pk+1). We refer the readers to Fig. 11 for the relative position
of these arcs. Let γ be an arc of F(P1) such that it intersects seg(t(υ), t(υP)). By the definition of Ic, right(Ic(υ))
corresponds t(υ). Since P1 is a monotone path in G(Ic), Ic(γ)  Ic(υ) and hence right(Ic(γ)) corresponds t(γ). Then,
either γ = υ or t(γ) is contained in seg(h(µ), t(υ)). Since γ intersects seg(t(υ), t(υP)) and µ  Bp(t(υP)), arc γ contains
both t(υP) and arc µ. By the definition of Icc, Icc(µ) = (t(µ), h(µ)), Icc(υP) = (t(υP), h(υP)), and Icc(γ) = (t(γ), h(γ)) or
Icc(γ) = (t(γ), h(γ) + 2n) depending on whether γ ∈ Bp(t(υ)). Thus, Icc(γ) contains both le f t(Icc(υP)) and Icc(µ). By
Lemma 4.9, Icc(µ)  end(H1), where H1 is the first greedy path in PC(Icpp). Since |PC(Iccp)| > 1, end(H1) 	 Icc(υP).
Since Icc(γ) contains Icc(µ), Icc(µ)  end(H1), end(H1) 	 Icc(υP), and Icc(γ) contains le f t(Icc(υP)), we get that Icc(γ)
contains right(end(H1)). By Statement (3) of Lemma 2.4, Icc(γ) ∈ L(H1) and hence γ ∈ ˆCccp. Thus, no arc of
F(R(Iccp)) intersects seg(t(υ), t(υP)). By Statement (4) of Lemma 4.1, every arc of F(P2 ∪ P3 ∪ · · · ∪ Pk ∪ Pk+1) is
contained in seg(t(υ, t(υP))). Then, no arc of of F(R(Iccp)) intersects arcs of F(P2 ∪ P3 ∪ · · · ∪ Pk ∪ Pk+1). This proves
the above claim.
Case 2: |PC(Iccp)| = 1. In this case, PC(Iccp) = {H1}. Assume by contradiction that end(H1) intersects Icc(υP).
Then, H1 → Prevk+1 → Icc(ck) → Prevk → Icc(ck−1) → Prevk−1 → Icc(ck−2) → · · · → Icc(c2) → Prev2 → Icc(c1) is a
Hamiltonian path of G(Icc), where Previ is the reversed path of Pi for k+1  i  2. It contradicts the assumption of the
lemma that |PC(Icc)| > 1, i.e., G(Icc) has no Hamiltonian path. Thus, end(H1) does not intersect Icc(υP). By similar
arguments in proving Case 1, we can show that G(F − ˆCccp) contains at least | ˆCccp| + 1 connected components. 
It immediately follows from Lemmas 4.8 and 4.10 that the following lemma holds true.
Lemma 4.11. Assume that |PC(Icc)| > 1. Let ˆCN = F(C(Q)) if L(P) = ∅; otherwise, let ˆCN = F(C(Iccp)) ∪ F(C(P)),
where C(Iccp) is defined in Lemma 4.10. Then, G(F − ˆCN) contains at least | ˆCN | + 1 connected components.
By Proposition 2.2 and Lemma 4.11, G(F) has no Hamiltonian cycle when |PC(Icc)| > 1 (line 11 of Algorithm
HC-Arcs). Thus, Claim 1 holds true.
4.2. The correctness of Claim 2
In this subsection, we will prove the correctness of Claim 2 that “s → Qs → s” is a Hamiltonian cycle of G(F)
if Q is a Hamiltonian path of G(Icc), arc z does not intersect arc ω, R  ∅, Qs is a Hamiltonian path of G(Is), and
arc s intersects arc F(end(Qs)). Note that υP = F(end(P)), υ = F(end(P1)), z = F(start(Q)), ω = F(end(Q)), and
s ∈ R = {r ∈ F|r ∈ Bp(h(ω)) − F(L(Q))}. We first prove that R ⊆ Ba(z) in the following lemma.
Lemma 4.12. Assume that |PC(Icc)| = |{Q}| = 1, arc z does not intersect arc ω, and R  ∅. Then, Bp(h(ω)) ⊆
F(L(Q)) ∪ Ba(z).
Proof. By Proposition 4.6, υ ∈ Bp(h(ω)) and ω ∈ Bp(t(υ)). By Proposition 4.4, υ ∈ Ba(z). By assumption of the
lemma, arc z does not intersect arc ω. Then, seg(t(z), t(υ)) contains both h(ω) and seg(h(ω), t(υ)), seg(t(υ), h(z))
contains t(ω), and seg(t(υ), h(ω)) contains arc z. The relative positions of arcs υ, ω, z on the circle are depicted in Fig.
14. Suppose that arc χ ∈ Bp(h(ω)) but χ  υ. Consider the following two cases:
Case 1: t(χ) is contained in seg(t(υ), h(ω)). Since χ ∈ Bp(h(ω)), arc χ contains seg(h(ω), t(υ)) and hence χ ∈
Bp(t(υ)). By the definition of Fcc, Fcc(χ) = tail(χ, t(υ)) and Fcc(ω) = tail(ω, t(υ)). By the definition of Icc, Icc(χ) =
(t(χ), h(χ) + 2n) and Icc(ω) = (t(ω), h(ω) + 2n). Since χ ∈ Bp(h(ω)), Icc(χ) contains right(Icc(ω)). By Statement (3) of
Lemma 2.4, Icc(χ) ∈ L(Q). We refer the readers to Fig. 14(a)-(b) for this case.
16
v
z
(a) (b)
s 
s

v
z s
s

Fig. 15: An illustration for the proof of (a) Lemma 4.15 and (b) Lemma 4.16, where the dashed lines of arcs ωs and s˜ indicates the possible
extended portions.
Since the removal of one vertex Icc(s) in a path Q will increase the number of paths by at most one, we get that
1  |PC(Icc − {Icc(s)})|  2. Thus, we consider the following two cases:
C I: |PC(Icc − {Icc(s)})| = |{Qs}| = 1 but arc s does not intersect F(end(Qs));
C II: |PC(Icc − {Icc(s)})| = 2.
For the case that |PC(Icc − {Icc(s)})| = |{Qs}| = 1 and arc s intersects F(end(Qs)), we have proved in Lemma 4.13
that “s → Qs → s” is a Hamiltonian cycle of G(F). We will prove the correctness of Claim 3 under C I and C
II in Lemma 4.18 and Lemma 4.24, respectively. For C I (resp., C II), we compute a cut set ˜CI (resp., ˜CII) of
G(F) such that it contains arc s. Let ˜C = ˜CI or ˜C = ˜CII. We then show that G(F − ˜C) contains at least | ˜C| connected
components and no arc of F − ˜C intersects tail(s, h(ω)). By Proposition 2.3, the removal of tail(s, h(ω)) preserves the
hamiltonicity property of G(F). We first consider C I. It needs the following three lemmas to verify its correctness.
Lemma 4.15. Assume that |PC(Icc)| = 1, arc z does not intersect arc ω, and R  ∅. If |PC(Icc − {Icc(s)})| = |{Qs}| = 1
but arc s does not intersect ωs = F(end(Qs)), then Icc(ωs) < Icc(ω) and ω ∈ Ba(ωs).
Proof. By Lemma 4.12, s ∈ Ba(z). By Proposition 4.6, υ ∈ Bp(h(ω)) and ω ∈ Bp(t(υ)). By the definition of s,
s ∈ Bp(h(ω)) and hence arc s intersects arc ω. Thus, h(ω) is contained in seg(t(z), t(s)) and arc ω contains t(s). The
relative locations of arcs z, s, υ, ω, ωs on the circle are shown in Fig. 15(a). Since arc s intersects arc ω but it does
not intersect arc ωs, ωs  ω. Thus, seg(t(s), h(s)) contains arc ωs and hence seg(h(ω), h(s)) contains arc ωs. By
the definition of Icc, Icc(ω) = (t(ω), h(ω) + 2n), and either Icc(ωs) = (t(ωs), h(ωs)) or Icc(ωs) = (t(ωs), h(ωs) + 2n)
depending on whether ωs ∈ Bp(t(υ)). Then, right(Icc(ω)) is to the right of right(Icc(ωs)). That is, Icc(ωs) < Icc(ω). By
Statements (1) and (3) of Lemma 2.4, Icc(ω) contains right(Icc(ωs)) and Icc(ω) ∈ L(Qs). By Statement (4) of Lemma
2.4, Icc(ω) contains Icc(ωs). Thus, arc ω contains arc ωs. That is, ω ∈ Ba(ωs). 
For convenience, we define B(z, s) = {x|x ∈ Ba(z) and Icc(s) < Icc(x)}.
Lemma 4.16. Assume that |PC(Icc)| = 1, arc z does not intersect arc ω, and R  ∅. If |PC(Icc − {Icc(s)})| = |{Qs}| = 1
but arc s does not intersect ωs = F(end(Qs)), then B(z, s) ⊆ F(C(Qs)).
Proof. Since |PC(Icc)| = |{Q}| = 1 and Icc(ω) = end(Q), we get that |PC(Icc − {Icc(ω)})| = 1. By Lemma 4.12,
s ∈ Ba(z). By Lemmas 4.15 and 2.4, Icc(ω) ∈ L(Qs). Assume by contradiction that there exists an arc s˜ in B(z, s) such
that s˜  F(C(Qs)). Let Qs1 be the first path component of Qs −C(Qs). Then, z = F(start(Q)) = F(start(Qs1 )). By the
definition of Fcc, Fcc(z) = z. By Proposition 4.4, υ ∈ Ba(z). By the definition of B(z, s), s˜ ∈ Ba(z) and Icc(s) < Icc(s˜).
We can see that Ic(s˜) ∈ P1 and either s˜ = υ or t(s˜) is contained in seg(t(z), t(υ)). Otherwise, Ic(υ) < Ic(s˜) and it
contradicts that P1 is a monotone path. We refer the readers to Fig. 15(b) for the relative locations of arcs z, s, s˜, υ, ω
on the circle are shown in Fig. 15(b). By the definition of Icc, Icc(z) = (t(z), h(z)) and Icc(s˜) = (t(s˜), h(s˜)). Then, Icc(s˜)
contains Icc(z), and, hence Icc(s˜) intersects Icc(z). By Statement (3) of Lemma 2.5, Icc(s˜) ∈ Qs1 . By the greedy rule of
Procedure GP, Icc(s) < Icc(s˜)  end(Qs1 ). Hence, no interval of Qs1 ∪ {Icc(s)} intersects intervals of other connected
18
in seg(h(ω), h(ωs)). In this time, Icc(x) contains right(Icc(ωs)). By Statement (3) of Lemma 2.4, Icc(x) ∈ L(Qs).
Hence, x ∈ F(C(Qs)).
Finally we prove Statement (3). Since s ∈ Ba(z) and arc ωs does not intersect arc s, arc ωs does not intersect arc
z. Since υ ∈ Ba(z) and ωs does not intersect arc z, ωs  Ba(υ). Clearly, υ  Ba(ωs). Note that υ ∈ Bp(h(ω)). Two cases
arise from the location of t(υ) as follows:
Case 1: t(υ) is contained in seg(h(ω), h(ωs)). By Statement (2), υ ∈ F(C(Qs)) ∪ {s}. Let x be an arc in F(Qsi ),
1  i   + 1. By Statement (1), x  Bp(h(ω)). Then, arc x is contained in seg(h(ωs), h(ω)). Thus, x  Bp(t(υ)). By
the definition of Fcc, Fcc(x) = x.
Case 2: t(υ) is contained in arc ωs. In this case, arc υ intersects seg(h(ω), h(ωs)) and υ  s since s does not
intersect ωs. By Proposition 4.14, s ∈ Ba(z) and υ ∈ Ba(s). By Statement (2), υ ∈ F(C(Qs)). Let y ∈ F(Qsi ) for
1  i  . Assume by contradiction that y ∈ Bp(t(υ)). If y ∈ Ba(υ), then y intersects seg(h(ω), h(ωs)), y ∈ F(C(Qs))
by Statement (2), and, hence a contradiction occurs. Hence, both ωs and y do not contain υ and they contain t(υ).
By the definition of Icc, Icc(y) intersects Icc(ωs). It contradicts that no interval of Qsi , 1  i  , intersects intervals
of Qs+1 by Statement (3) of Lemma 2.5. Note that Icc(ωs) ∈ Qs+1 . Hence, y  Bp(t(υ)). By the definition of Fcc,
Fcc(y) = y. By Statement (2), no arc of F(Qs+1 ) ∪ F(Qs1 ) intersects seg(h(ω), h(ωs)). Hence, no arc of F(Qs+1 )
intersects arcs of F(Qsi ) for 1  i  .
It follows from the above two cases that Icc(x) intersects Icc(y) if and only if arc x intersects arc y for x, y ∈
F(Qs1 ∪ Qs2 ∪ · · · ∪ Qs+1 ). By Statement (3) of Lemma 2.5, Qs1 , Qs2 , · · · , Qs+1 are islands with respect to C(Qs) in
G(Icc − {Icc(s)}). Hence, F(Qs1 ), F(Qs2 ), · · · , F(Qs+1 ) are islands with respect to F(C(Qs)) in G(F − {s}). 
The following lemma uses Lemma 4.17 to prove the correctness of Claim 3 in C I that |PC(Icc − {Icc(s)})| =
|{Qs}| = 1 but arc s does not intersect arc F(end(Qs)).
Lemma 4.18. Assume that |PC(Icc)| = 1, arc z does not intersect arc ω, R  ∅, and that |PC(Icc−{Icc(s)})| = |{Qs}| = 1
but arc s does not intersect ωs = F(end(Qs)). Then, G(F) is hamiltonian if and only if G( ˆF) is hamiltonian, where
ˆF = (F − {s}) ∪ head(s, h(ω)).
Proof. Let ˜CI = F(C(Qs)) ∪ {s}. Since an arc of ˆF is either an arc of F or arc head(s, h(ω)), G( ˆF) is a spanning
subgraph of G(F). Let E and ˆE be the edge sets of G(F) and G( ˆF), respectively. We prove this lemma by showing
that G(F − ˜CI) contains at least | ˜CI| connected components and every edge in E − ˆE connects two arcs of ˜CI. By the
pigeonhole principle (see Proposition 2.3), no edges in E − ˆE can be in any Hamiltonian cycle of G(F).
By Statement (3) of Lemma 4.17, G(F − ˜CI) contains at least | ˜CI| connected components. By Statement (2) of
Lemma 4.17, an arc intersecting seg(h(ω), h(ωs)) is in ˜CI. The relative locations of arcs z, s, ω, ωs, and arcs in F − ˜CI
on the circle are shown in Fig. 16. Since s ∈ Bp(h(ω)), s does not intersect ωs, and ω ∈ Ba(ωs) by Lemma 4.15, we
get that seg(h(ω), h(ωs)) contains seg(h(ω), t(s)) = tail(s, h(ω)). Hence, no arc of F − ˜CI intersects tail(s, h(ω)). By
Proposition 2.3, ˜CI is a cut set of G(F) for showing that G(F) is hamiltonian if and only if G( ˆF) is hamiltonian. 
Next, we consider C II of |PC(Icc − {Icc(s)})| = 2. It is assumed that Icc(s)  Icc(υ). We first claim that if
L(P) = ∅ then |PC(Icc −{Icc(s)})| = 1. Thus, L(P)  ∅ if |PC(Icc −{Icc(s)})| = 2. We prove the above claim by showing
that |PC(Icc − {Icc(υ)})| = 1 and |PC(Icc − {Icc(α)})| = 1 for Icc(α) < Icc(υ) in the following two lemmas.
Lemma 4.19. Assume that |PC(Icc)| = 1, arc z does not intersect arc ω, and R  ∅. If L(P) = ∅, then |PC(Icc −
{Icc(υ)})| = 1.
Proof. Since L(P) = ∅, C(P) = ∅ and υ = υP. By Proposition 4.6, υ ∈ Bp(h(ω)) and ω ∈ Bp(t(υ)). By Lemma 4.3,
ω ∈ Ba(µ). By the definition of Fcc, Fcc(ω) = tail(ω, t(υ)) and Fcc(µ) = µ. By the definition of Icc, Icc(ω) contains
Icc(µ). Since |PC(Icc)| = |{Q}| = 1 and Icc(ω) = end(Q), we get that |PC(Icc − {Icc(ω)})| = 1, i.e., G(Icc − {Icc(ω)})
contains a Hamiltonian path. Since the removal of interval Icc(υ) from Icc − {Icc(ω)} increases the number of paths by
at most one, we get that |PC(Icc − {Icc(ω), Icc(υ)})|  2. Consider the following two cases:
Case 1: |PC(Icc − {Icc(ω), Icc(υ)})| = 1. Let PC(Icc − {Icc(ω), Icc(υ)}) = { ˜Q}. If end( ˜Q) does not intersect Icc(ω),
then end( ˜Q) 	 Icc(µ) since Icc(ω) contains Icc(µ), and it contradicts |PC(Icc − {Icc(ω), Icc(υ)})| = 1. Hence, end( ˜Q)
intersects Icc(ω). Then, ˜Q→ Icc(ω) is a Hamiltonian path of G(Icc − {Icc(υ)}). Hence, |PC(Icc − {Icc(υ)})| = 1.
Case 2: |PC(Icc − {Icc(ω), Icc(υ)})| = 2. Let PC(Icc − {Icc(ω), Icc(υ)}) = { ˜Q1, ˜Q2} such that end( ˜Q1) < end( ˜Q2), and
let ω˜1 = F(end( ˜Q1)). Since L(P) = ∅, P = P1 is the first path in PC(Ic). By the definition of Icc, two intervals in P1
20
Lemma 4.23. Assume that |PC(Icc)| = 1, arc z does not intersect arc ω, R  ∅, and that Icc(s)  Icc(υ). If PC(Icc −
{Icc(s)}) = {Q1s ,Q2s} with end(Q1s) < end(Q2s), then Icc(µ)  end(Q1s).
Proof. We first prove that G(Icc(P1) − {Icc(s)}) contains a Hamiltonian path. Since Icc(υ) = end(P1), G(Icc(P1) −
{Icc(υ)}) contains a Hamiltonian path that is the reversed path of P1−{Ic(υ)}. Suppose that s  υ. By Proposition 4.14,
υ ∈ Ba(s) and hence Icc(υ) contains Icc(s). Let the Hamiltonian path of G(Icc(P1) − {Icc(υ)}) be S 1 → Icc(s) → S 2,
where S 1 and S 2 are two sub-paths of this path. Since Icc(υ) contains Icc(s), S 1 → Icc(υ)→ S 2 is a Hamiltonian path
of G(Icc(P1) − {Icc(s)}). Thus, G(Icc(P1) − {Icc(s)}) contains a Hamiltonian path.
Consider that end(Q1s)  Icc(µ). Assume by contradiction that right(end(Q1s)) is contained in interval Icc(µ). By
Statement (3) of Lemma 2.4, Icc(µ) ∈ L(Q1s). By Statement (6) of Lemma 2.5, Icc(µ) contains at least one interval of
Icc − {Icc(s)}. It contradicts that arc µ does not contain any other arc of F. Thus, right(end(Q1s)) is not contained in
Icc(µ). Further, assume by contradiction that end(Q1s) 	 Icc(µ). It is easy to see that Q1s ⊂ Icc(P1) − {Icc(s)}. Then,
(Icc(P1) − {Icc(s)}) − Q1s contains Icc(µ), and, hence (Icc(P1) − {Icc(s)}) − Q1s  ∅. By Statements (1)–(3) of Lemma
2.5, there exists a set C(Q1s) such that C(Q1s) ⊂ Q1s , L(Q1s) ⊆ C(Q1s), and the removal of C(Q1s) from Q1s results in
|C(Q1s)|+1 nonempty and disjoint sub-paths and each of them is an island with respect to C(Q1s) in G(Icc(P1)−{Icc(s)}).
By Statement (5) of Lemma 2.5, (Icc(P1)−{Icc(s)})−Q1s is also an island with respect to C(Q1s) in G(Icc(P1)−{Icc(s)}).
In other words, there are |C(Q1s)|+2 disjoint islands in G((Icc(P1)−{Icc(s)})−C(Q1s)). Therefore, the removal of C(Q1s)
from G(Icc(P1)−{Icc(s)}) results in at least |C(Q1s)|+2 connected components. By Proposition 2.1, G(Icc(P1)−{Icc(s)})
has no Hamiltonian path. It contradicts that G(Icc(P1) − {Icc(s)}) contains a Hamiltonian path. Hence, Icc(µ) is not to
the right of end(Q1s). We have proved that right(end(Q1s)) is not contained in interval Icc(µ) and Icc(µ) is not to the right
of interval end(Q1s) when end(Q1s)  Icc(µ). Thus, Icc(µ) < end(Q1s) if end(Q1s)  Icc(µ). Then, Icc(µ)  end(Q1s). 
Suppose thatPC(Icc−{Icc(s)}) = {Q1s ,Q2s}with end(Q1s) < end(Q2s), and Icc(s)  Icc(υ). By Lemma 4.21, L(P)  ∅.
We next give the following lemma for showing the correctness of Claim 3 under C II that |PC(Icc − {Icc(s)})| = 2
and Icc(s)  Icc(υ).
Lemma 4.24. Assume that |PC(Icc)| = 1, arc z does not intersect arc ω, R  ∅, Icc(s)  Icc(υ), and that PC(Icc −
{Icc(s)}) = {Q1s ,Q2s} with end(Q1s) < end(Q2s). Then, G(F) is hamiltonian if and only if G( ˆF) is hamiltonian, where
ˆF = (F − {s}) ∪ head(s, h(ω)).
Proof. Let P = P1 → c1 → P2 → · · · → ck−1 → Pk → ck → Pk+1, where C(P) = {c1, c2, · · · , ck} is the greedy
connecting set of path P. We refer the readers to Fig. 11 for the relative locations of arcs in F(P) and F −F(P), and to
Fig. 12 for the relative locations of intervals in Icc(P) and Icc− Icc(P). By Lemma 4.21, L(P)  ∅. Thus, |C(P)| = k  1
and P− (P1 ∪C(P)) = {P2, P3, · · · , Pk, Pk+1}  ∅. Let ω1 be the arc corresponding to end(Q1s), i.e., ω1 = F(end(Q1s)).
The relative positions of arcs µ, υ, s, z, ω, ω1 on the circle are shown in Fig. 17. Let D = Q1s ∩ Icc(P− (P1 ∪C(P))) and
let ˜CII = F(C(Q1s)) ∪ F(C(P) − Q1s) ∪ {s}, where C(Q1s) is the greedy connecting set of path Q1s . We claim that ˜CII is
a cut set of G(F) for showing that G(F) is hamiltonian if and only if G((F − {s}) ∪ head(s, h(ω))) is hamiltonian. We
show that the claim holds true in the following two cases:
Case 1: D = ∅. Let ˜Z = Icc((P1 − {Ic(s)})∪ (F − F(P)))−Q1s , where ˜Z may be empty. By Statement (4) of Lemma
4.1, seg(t(υ), t(υP)) contains arc υP. Since arc µ does not contain any other arc and υ is the arc with the largest right
endpoint in P1, seg(h(µ), t(υ)) contains arc µ. By Lemma 4.23, Icc(µ)  Icc(ω1). Since D = ∅, Icc(ω1) 	 Icc(υP).
Thus, seg(t(υP), t(υ)) contains h(ω1) and seg(h(ω1), t(υ)) contains arc µ. The relative locations of arcs υ, µ, ω1, υP,
and F( ˜Z) are depicted in Fig. 17(a).
By Statement (4) of Lemma 4.1, every arc of F(P − (P1 ∪ C(P)) is contained in seg(t(υ), t(υP)). By Lemmas
2.4 and 2.5, every interval of Q1s − C(Q1s) is not larger than Icc(ω1) in G(Icc). Thus, every arc of F(Q1s − C(Q1s)) is
contained in seg(t(ω1), t(υ)). Let β be an arc of F( ˜Z). By Statement (5) of Lemma 2.5, Icc(ω1) 	 Icc(β). Assume by
contradiction that β ∈ Bp(t(υP)). By the definition of ˜Z, β  F(L(P)). By Statement (2) of Lemma 4.1, β ∈ Ba(µ).
Since Icc(µ)  Icc(ω1), Icc(β) intersects Icc(ω1) and it contradicts that Icc(ω1) 	 Icc(β). Thus, β  Bp(t(υP)). Then, β is
contained in seg(t(υP), h(ω1)) and hence every arc of F( ˜Z) is contained in seg(t(υP), h(ω1)). By the above arguments,
we have that
(1) no arc of F( ˜Z) intersects arcs of F(P − (P1 ∪C(P))) and F(Q1s −C(Q1s)), and
(2) no arc of F(Q1s −C(Q1s)) intersects arcs of F(P − (P1 ∪C(P))).
We can see that C(P) − Q1s = C(P) − L(Q1s) and |C(P) − L(Q1s)|  k = |C(P)|. Then, ˜CII = F(C(Q1s)) ∪ F(C(P) −
Q1s) ∪ {s} = F(C(Q1s)) ∪ F(C(P) − L(Q1s)) ∪ {s}. The sets F(Q1s − C(Q1s)), F( ˜Z), and F(P − (P1 ∪ C(P))) are islands
22
P
1
P2
Pk+1
ck
c k
j

+1
P
*
k j+2
vP Pk j+3
ck j+2
Z
Pk j+1
r
s
v

F
F
P

(
)
1
z


P
1
P2
r
s
v

F
F
P

(
)
1
z


(a) (b)
Z
P3
Pk+1
ck
c k
j

+1
Pk j+2
Pk
ck1
vP
c2
Q CQs s- ( )
11
Q CQs s- ( )
11
CQ( )s
1
CQ( )s
1
Fig. 17: An illustration for the proof of Lemma 4.24, where (a) the relative locations of arcs of F(Q1s − C(Q1s )), F( ˜Z), F(Pk+1), F(Pk), · · · , F(P3),
F(P2) for the case of D = ∅, and (b) the relative locations of arcs of F(Q1s − C(Q1s )), F( ˆZ), F(Pk− j+1), F(Pk− j), · · · , F(P3), F(P2) for the case of
D  ∅.
v
z
(a) (b)
I vcc( )
I zcc( )
Icc( )
Icc( )

Icc( )
r
r
Fig. 18: An illustration for the proof of Lemma 4.26, where (a) the relative positions of arcs µ, z, υ, ω, r˜, and the dashed line of arc r˜ indicates the
possible extended portion, and (b) the relative locations of intervals Icc(µ), Icc(z), Icc(υ), Icc(ω), Icc(r˜) when t(r˜) is contained in seg(t(υ), h(ω)).
t(r˜) is not contained in seg(t(υ), h(ω)). Then, t(r˜) is contained in seg(h(ω), t(υ)). Since r˜ ∈ Bp(h(ω)), we get that
tail(υ, h(ω)) contains tail(r˜, h(ω)). Consider the following two cases:
Case 1: |PC(Icc − {Icc(υ)})| = |{Qυ}| = 1. By Lemma 4.16, r˜ ∈ F(C(Qυ)). Let ˜CI = F(C(Qυ)) ∪ {υ}. Then, r˜ ∈ ˜CI.
By the proof of Lemma 4.18, G(F − ˜CI) contains at least | ˜CI| connected components and no arc of F − ˜CI intersects
tail(υ, h(ω)). Since tail(υ, h(ω)) contains tail(r˜, h(ω)), no arc of F − ˜CI intersects tail(r˜, h(ω)). By Proposition 2.3, ˜CI
is a cut set of G(F) for showing that G(F) is hamiltonian if and only if G((F − {r˜}) ∪ head(r˜, h(ω))) is hamiltonian.
Case 2: |PC(Icc − {Icc(υ)})| = |{Q1υ,Q2υ}| = 2. Without loss of generality, assume that end(Q1υ) < end(Q2υ). By
Lemma 4.22, r˜ ∈ F(C(Q1υ)). Let ˜CII = F(C(Q1υ)) ∪ F(C(P) − Q1υ) ∪ {υ}. Then, r˜ ∈ ˜CII. By the proof of Lemma 4.24,
G(F− ˜CII) contains at least | ˜CII| connected components and no arc of F− ˜CII intersects tail(υ, h(ω)). Since tail(υ, h(ω))
contains tail(r˜, h(ω)), no arc of F − ˜CII intersects tail(r˜, h(ω)). By Proposition 2.3, ˜CII is a cut set of G(F) for showing
that G(F) is hamiltonian if and only if G((F − {r˜}) ∪ head(r˜, h(ω))) is hamiltonian. 
It immediately follows from Lemmas 4.25 and 4.26 that Claim 3 holds true. Finally, we will prove the correctness
of Claim 4 in the following lemma.
24
a Hamiltonian cycle of G(F) by testing that (vi, vi+1), 1  i  n − 1, and (vn, v1) are edges in G(F). The size of
this certificate is O(n) and the time to authenticate it is O(n). For a non-hamiltonian certificate (F) = 〈 ˆC, ˆF〉, the
authentication algorithm checks whether G( ˆF − ˆC) contains at least | ˆC| + 1 connected components. The size of this
certificate is O(n), and testing whether G( ˆF− ˆC) contains at least | ˆC|+1 connected components takes O(n) time. Thus,
the authentication algorithm runs in O(n) time. Then we conclude the following theorem.
Theorem 5.1. Given a circular-arc model F with n sorted arcs, Algorithm Certifying-HC-Arcs is a certifying al-
gorithm for solving the Hamiltonian cycle problem in O(∆n) time, where ∆ is the maximum degree of G(F). The
certificates provided by the algorithm can be authenticated in O(n) time.
6. Reduction
In [27], we proposed an O(n)-time approximation non-certifying algorithm for the path cover problem on a
circular-arc graph G(F). Let π′ be the cardinality of the path cover found by the approximation algorithm. We
showed that π′  π(G(F)) + 1 [27]. Then, the path cover problem on G(F) can be solved by reducing it to the Hamil-
tonian cycle problem as follows. If π′ = 1, then π(G(F)) = π′. Otherwise, π(G(F)) = π′ −1 if and only if G(F)⊗Kπ′−1
is hamiltonian, where Kπ′−1 is a complete graph of π′ − 1 vertices, G(F) and Kπ′−1 are disjoint, and G(F) ⊗ Kπ′−1
is the graph obtained by connecting every vertex of G(F) with all vertices of Kπ′−1. Apparently, G(F) ⊗ Kπ′−1 is
also a circular-arc graph. Let ∆ be the maximum degree of G(F). Then, the maximum degree of G(F) ⊗ Kπ′−1 is
∆ + (π′ − 1)  O(n). By using the above reduction and Algorithm Certifying-HC-Arcs, an O(n2)-time certifying
algorithm for solving the path cover problem on G(F) can be easily obtained. Thus, we have the following corollary.
Corollary 6.1. Given a circular-arc model F with n sorted arcs, there exists an O(n2)-time certifying algorithm to
solve the path cover problem on G(F), where its certificates can be authenticated in O(n2) time.
It is well known that the Hamiltonian cycle and Hamiltonian path problems on circular-arc graphs can be reduced
to each other [27, 35]. Thus, the Hamiltonian path problem on circular-arc graphs can be solved by an algorithm
whose time complexity is the same as that of the most eﬃcient algorithm for the Hamiltonian cycle problem on the
same class of graphs. Therefore, we have the following corollary.
Corollary 6.2. Given a circular-arc model F with n sorted arcs, there exists an O(∆n)-time certifying algorithm to
solve the Hamiltonian path problem on G(F), where its certificates can be authenticated in O(n) time.
7. Concluding Remarks
In this paper, we present an O(∆n)-time certifying algorithm to solve the Hamiltonian cycle problem on circular-
arc graphs. This improves the best known result in [46] for this problem which is an O(n2 log n)-time (certifying)
algorithm. The certificates provided by our algorithm can be authenticated in O(n) time. Using a general reduction
technique in [27] and [35], an O(∆n)-time certifying algorithm for solving the Hamiltonian path problem on circular-
arc graphs can be obtained. On the other hand, using the reduction technique in [27] and the certifying Hamiltonian
cycle algorithm presented in the paper, an O(n2)-time certifying algorithm for solving the path cover problem on
circular-arc graphs can be constructed. It is interesting to know whether the approach used in the paper can be applied
to design eﬃcient certifying algorithms for other classes of graphs. Further, given a circular-arc model F with n
sorted arcs, whether there exists an O(n)-time (certifying) algorithm to solve the Hamiltonian cycle or Hamiltonian
path problem remains open.
Acknowledgements
The authors would like to thank anonymous referees for many useful comments and suggestions which have
improved the presentation of this paper. Particularly, the referee suggests us to provide suitable figures for illustrating
the proofs of some lemmas and to improve the presentation of notations for easily understandable.
26
[40] R.M. McConnell, Linear-time recognition of circular-arc graphs, Algorithmica 37 (2003) 93–147.
[41] R.M. McConnell, K. Mehlhorn, S. Na¨her, and P. Schweitzer, Certifying algorithms, Computer Science Review 5 (2011) 119–161.
[42] S.D. Nikolopoulos and L. Palios, An O(nm)-time certifying algorithm for recognizing HHD-free graphs, Lecture Notes in Comput. Sci., vol.
4613, Springer, Berlin, 2007, pp. 281–292.
[43] J.F. O’Callaghan, Computing the perceptual boundaries of dot patterns, Comput. Graphics Image Process. 3 (1974) 141–162.
[44] F.P. Preperata and M.I. Shamos, Computational Geometry: An Introduction, Springer, New York, 1985.
[45] C. Riedesel and J.S. Deogun, Permutation graphs: Hamiltonian paths, J. Combin. Math. Combin. Comput. 19 (1995) 55–63.
[46] W.K. Shih, T.C. Chern, and W.L. Hsu, An O(n2 log n) time algorithm for the Hamiltonian cycle problem on circular-arc graphs, SIAM J.
Comput. 21 (1992) 1026–1046.
[47] G.T. Toussaint, Pattern recognition and geometrical complexity, in: Proceedings of the 5th International Conference on Pattern Recognition,
Miami Beach, 1980, pp. 1324–1347.
[48] A.C. Tucker, An eﬃcient test for circular-arc graphs, SIAM J. Comput. 9 (1980) 1–24.
[49] H. Wasserman and M. Blum, Software reliability via run-time result-checking, J. ACM 44 (1997) 826–849.
[50] M.S. Waterman and J.R. Griggs, Interval graphs and maps of DNA, Bull. Math. Biol. 48 (1986) 189–195.
28
ICIC Express Letters ICIC International c©2011 ISSN 1881-803X
Volume 5, Number 6, June 2011 pp. 1–ICICIC2010-000
THE NEIGHBOR-SCATTERING NUMBER OF PROPER INTERVAL
GRAPHS
Ruo-Wei Hung, Chun-Kai Wang and Chih-Chia Yao
Department of Computer Science and Information Engineering
Chaoyang University of Technology
Wufeng, Taichung 41349, Taiwan
rwhung@cyut.edu.tw
Received July 2010; accepted November 2010
Abstract. The neighbor-scattering number of a noncomplete graph G = (V,E) is de-
fined by ns(G) = max{ω(G−N [X])− |X| : X ⊆ V and ω(G−N [X]) ≥ 1}, where N [X]
denotes the closed neighborhood of X in G and ω(G−N [X]) denotes the number of con-
nected components of the graph G − N [X]. This parameter can be used to measure the
vulnerability of networks. It shows not only the difficulty to break down the network but
also the damage that has been caused. In this paper, we first point out that the known al-
gorithm for computing the neighbor-scattering number of interval graphs contains a flaw.
We then present the first linear time algorithm for computing the neighbor-scattering
number of proper interval graphs, which form a subclass of interval graphs.
Keywords: Neighbor-scattering number, Interval graphs, Proper interval graphs
1. Introduction. In a communication network (or graph), vulnerability measures the
resistance of the network to disruption of operation after the failure of certain stations or
communication links. To measure vulnerability we have some parameters such as tough-
ness, binding number, vertex integrity, scattering number [9], and neighbor-scattering
number [2]. In this paper, we will discuss the neighbor-scattering number of interval
graphs and proper interval graphs.
Gunther and Hartnell [2] discussed the neighbor-scattering number of graphs – disrup-
tion caused by the removal of vertices and their adjacent vertices. Let G = (V,E) be a
graph and let v be a vertex in V . The open neighborhood of v is N(v) = {u ∈ V : (v, u) ∈
E} while the closed neighborhood of v is N [v] = N(v) ∪ {v}. Let X be a subset of V .
We define analogously the open neighborhood N(X) = ∪v∈XN(v) and the closed neigh-
borhood N [X] = N(X) ∪X. Denote by G[X] the subgraph induced by vertices of X. If
G−N [X] is disconnected, or a complete graph, or ∅, then X is called cut-neighbor-set of
G. The neighbor-scattering number of G is defined by ns(G) = max{ω(G−N [X])−|X| :
X is a cut-neighbor-set of G and ω(G−N [X]) ≥ 1}, where ω(G−X) denotes the number
of components in G−X. A cut-neighbor-set S ⊆ V fulfilling ω(G−N [S])− |S| = ns(G)
is called a neighbor-scattering set of G. Especially, the neighbor-scattering number of a
complete graph is defined to be −1 and any vertex of the complete graph forms a neighbor-
scattering set of the graph. Clearly, if G is not a complete graph, then ns(G) ≥ 0. The
problem of deciding the neighbor-scattering number of a general graph has been shown
to be NP-complete [10].
An interval family I is a collection of intervals on a real line. A graph G is an interval
graph if there exist an interval family I and a one-to-one mapping of the vertices of
G and the intervals in I such that two vertices in G are adjacent if and only if their
corresponding intervals in I intersect. We call I an interval model of G. For an interval
model I, we use G(I) to denote the interval graph for I. A proper interval graph is an
interval graph that has an interval model in which no interval is properly contained in
1
ICIC EXPRESS LETTERS, VOL.5, NO.6, 2011 3
3. The Neighbor-Scattering Number of Proper Interval Graphs. In this section,
we will proposed an O(n)-time algorithm to compute the neighbor-scattering number of
proper interval graphs given a set of n sorted intervals. We first give some notations. Let
I be an interval model. The left endpoint of interval x in I is denoted by left(x) and the
right endpoint by right(x). Interval x is represented by [left(x), right(x)]. An interval
x intersects another interval y if there is a common point falling within the interior of
[left(x), right(x)] and [left(y), right(y)]. An interval x is said to contain another interval
y if every point of y falls within the interior of [left(x), right(x)]. The contiguous part of
a real line that begins with a point c and ends with a point d is referred to as segment
[c, d], denoted by seg[c, d], of the real line. For two distinct intervals x, y in I, x is smaller
than y (or y is larger than x), denoted by x < y, if right(y) is to the right of right(x),
and y is to the right of x, denoted by x  y, if left(y) is to the right of right(x). For a
subset I ′ of I, the largest interval in I ′ is denoted by last(I ′), and the interval in I ′ with
the smallest left endpoint is denoted by first(I ′). Proper interval graphs are characterized
by an ordering of their intervals as follows.
Theorem 3.1. [12] A graph G(I) is a proper interval graph if and only if for every triple
ia, ib, ic of intervals, ia < ib < ic and ia intersects ic implies that ia intersects ib and ib
intersects ic.
Let G(I) be a proper interval graph with n vertices and m edges; an ordering of the
intervals of G(I) satisfying Theorem 3.1 can be constructed in O(n + m)-linear time [12].
In the following, it is assumed the input graph is given by a connected proper interval
model I that is a set of n endpoint-sorted intervals labeled in increasing order of their
right endpoints, i.e, I = {i1, i2, · · · , in} such that ij < ij+1 for 1 ≤ j ≤ n − 1. By the
definition of a proper interval graph, no interval is properly contained in another. That
is, for any two intersected intervals ia and ib, if ia < ib then left(ib) is contained in interval
ia. The following characterization can be easily verified from the definition of a proper
interval graph.
Lemma 3.1. Any induced subgraph of a proper interval graph is a proper interval graph.
We now calculate the neighbor-scattering number ns(G(I)) of a connected proper in-
terval graph G(I). We first prove that ns(G(I)) ≤ 1 as follows.
Lemma 3.2. Let G(I) be a connected proper interval graph. Then, ns(G(I)) ≤ 1.
Proof. Assume by contradiction that ns(G(I)) > 1. Let S = {s1, s2, · · · , s|S|} be a
neighbor-scattering set of G(I). Then, |S| ≥ 1. Let I1, I2, · · · , Iκ be the disjoint connected
components of intervals of of G(I)−N [S] such that last(I) < last(I+1) for 1 ≤  ≤ κ−1.
By Lemma 3.1, G(I) is a connected proper interval graph for 1 ≤  ≤ κ. Then, we have
ns(G(I)) = κ− |S| > 1. (1)
Let sj be an interval of S such that sj is properly contained in seg[right(last(I)), left(first
(I+1))] for some . Since S 6= ∅, sj does exist. Since no interval of N(sj) contains any other
interval of I and I+1, every interval of N(sj) is properly contained in seg[left(first(I)),
right(last(I+1))]. Thus, every interval of N [sj] is properly contained in seg[left(first(I)),
right(last(I+1))]. Since G(I) is connected and every two connected components I, I+1
need to be connected via at least one set N [sj] of intervals, by the pigeonhole principle
we obtain that
|S| ≥ κ− 1. (2)
Combining Eqs. (1) and (2), we get that κ > |S|+ 1 ≥ (κ− 1) + 1 = κ, a contradiction.
Thus, ns(G(I)) ≤ 1.
By the above lemma and the definition of a neighbor-scattering number, we get the
following theorem.
ICIC EXPRESS LETTERS, VOL.5, NO.6, 2011 5
i = in 4
(a) (b) (c)
i = in 5i = if 2 i = in 7i = if 4
Figure 3. Three cases for the neighbor-scattering number of a proper
interval graph G(I), where (a) ns(G(I)) = −1, (b) ns(G(I)) = 0, and (c)
ns(G(I)) = 1.
Based on the above lemmas, our algorithm is to find an interval if such that I 6= ∅
if G(I) is not a complete graph. The algorithm for computing ns(G(I)) is sketched as
follows. It is given by a set I = {i1, i2, · · · , in} of n intervals such that ij < ij+1 for
1 ≤ j ≤ n − 1. The algorithm first tests whether G(I) is a complete graph. If G(I) is
a complete graph, then it outputs ns(G(I)) = −1. Suppose that G(I) is not a complete
graph. Let if be the largest interval of G(I)−N [in]. Since G(I) is not a complete graph,
if does exist. Let I = I − If − N(if ) and let Ih = If − N [if ] for some h < f . Then,
I = {in} 6= ∅. If Ih 6= ∅, then let ns(G(I)) = 1; otherwise, let ns(G(I)) = 0. The
algorithm then outputs ns(G(I)).
Figure 3 shows the possible cases for the neighbor-scattering number of a proper
interval graph G(I). Given a proper interval model I shown in Figure 3(a) (resp. Fig-
ure 3(b), Figure 3(c)), our algorithm calculates ns(G(I)) = −1 (resp. ns(G(I)) = 0,
ns(G(I)) = 1).
The correctness of the above algorithm follows from Theorem 3.2 and Lemmas 3.5–3.6.
Clearly, the above algorithm runs in O(n) time. Thus, we conclude the following theorem.
Theorem 3.3. There is an O(n)-time algorithm for computing the neighbor-scattering
number on proper interval graphs given a set of n endpoint-sorted intervals.
Acknowledgment. This work is partly supported by the National Science Council of
Republic of China under grant no. NSC99-2221-E-324-011-MY2. The authors deeply
appreciate the reviewers’ comments for many helpful suggestions which have improved
the presentation of paper.
REFERENCES
[1] K. Asdre and S.D. Nikolopoulos, A polynomial solution to the k-fixed-endpoint path cover problem
on proper interval graphs, Theoret. Comput. Sci., vol.411, pp.967–975, 2010.
[2] G. Gunther and B.L. Hartnell, On minimizing the effects of betrayals in a resistance movement,
Proc. 8th Manitoba Conference on Numerical Mathematics and Computing, pp.285–306, 1978.
[3] P. Heggernes, D. Meister and C. Papadopoulos, A new representation of proper interval graphs with
an application to clique-width, Electronic Notes Discrete Math., vol.32, pp.27–34, 2009.
[4] P. Hell, R. Shamir and R. Sharan, A fully dynamic algorithm for recognizing and representing proper
interval graqphs, SIAM J. Comput., vol.31, pp.289–305, 2001.
[5] R.W. Hung, A linear-time algorithm for the restricted paired-domination problem in cographs, Int.
J. Innov. Comp. Inf. Control, vol.6, no.11, pp.4957-4978, 2010.
[6] R.W. Hung and M.S. Chang, Certifying algorithms for the path cover and related problems on
interval graphs, Lecture Notes in Computer Science (LNCS), vol.6017, pp.314–323, 2010.
[7] T. Itokawa, A. Tada and M. Migita, Parallel algorithm for finding minimum edges required to make
a DAG strongly connected, Int. J. Innov. Comp. Inf. Control, vol.5, no.3, pp.581-588, 2009.
[8] D. Kratsch, T. Kloks and H. Mu¨ller, Computing the toughness and the scattering number for interval
and other graphs, IRISA Report PI-806, 1994.
[9] D. Kratsch, T. Kloks and H. Mu¨ller, Measuring the vulnerability for classes of intersection graphs,
Discrete Appl. Math., vol.77, pp.259–270, 1997.
[10] F. Li and X. Li, Computational complexity and bounds for neighbour-scattering number of graphs,
in: Proc. 8th International Symposium on Parallel Architectures, Algorithms and Networks (IS-
PAN’2005), IEEE Computer Society, Nevade, Las Vegas, USA, 2005.
29 
??? (Appendix IV)??????????? 
 Ruo-Wei Hung and Chien-Chih Liao, Two edge-disjoint Hamiltonian cycles 
and two-equal path partition in augmented cubes, in: International 
MultiConference of Engineers and Computer Scientists 2011 (IMECS’2011), 
Hong Kong, vol. I, 2011, pp. 197−201. (EI/ISI Proceeding, DBLP, Scopus, 
Computer Science Bibliographies) [Award: Best Paper Award] 
 Ruo-Wei Hung and Chien-Chih Liao, Constructing two edge-disjoint 
Hamiltonian cycles in decomposable networks, in: 2012 International 
Conference on Advanced Information Technologies and The Second National 
Conference on Web Intelligence and Applications (AIT / NCWIA 2012), Taichung, 
2012, Article no. 47. [Award: Best Paper Award] 
 

Embedding Two Edge-Disjoint Hamiltonian
Cycles and Two Equal Node-Disjoint Cycles into
Twisted Cubes
Ruo-Wei Hung‡§, Shang-Ju Chan‡, and Chien-Chih Liao‡
Abstract—The presence of edge-disjoint Hamiltonian cycles
provides an advantage when implementing algorithms that
require a ring structure by allowing message traffic to be
spread evenly across the network. Edge-disjoint Hamiltonian
cycles also provide the edge-fault tolerant Hamiltonicity of an
interconnection network. Two node-disjoint cycles in a network
are called equal if the number of nodes in the two cycles
are the same and every node appears in one cycle exactly
once. The presence of two equal node-disjoint cycles provides
algorithms that require a ring structure to be preformed in
the network simultaneously. The hypercube is one of the most
popular interconnection networks since it has simple structure
and is easy to implement. The n-dimensional twisted cube, an
important variation of the hypercube, possesses some properties
superior to the hypercube. In this paper, we present linear time
algorithms to construct two edge-disjoint Hamiltonian cycles
and two equal node-disjoint cycles in an n-dimensional twisted
cube.
Index Terms—edge-disjoint Hamiltonian cycles, equal node-
disjoint cycles, twisted cubes, parallel computing, inductive
construction
I. INTRODUCTION
PARALLEL computing is important for speeding upcomputation. The topology design of an interconnection
network is the first thing to be considered. Many topologies
have been proposed in the literature [4], [6], [8], [9], [10],
[13], [18], and the desirable properties of an interconnection
network include symmetry, relatively small degree, small
diameter, embedding capabilities, scalability, robustness, and
efficient routing. Among those proposed interconnection net-
works, the hypercube is a popular interconnection network
with many attractive properties such as regularity, symmetry,
small diameter, strong connectivity, recursive construction,
partition ability, and relatively low link complexity [24]. The
topology of an interconnection network is usually modeled
by a graph, where nodes represent the processing elements
and edges represent the communication links. In this paper,
we will use graphs and networks interchangeably.
The n-dimensional twisted cube TQn, an important vari-
ation of the hypercube, was first proposed by Hilbers et al.
[13] and possesses some properties superior to the hypercube.
The twisted cube is derived from the hypercube by twisting
some edges. Due to these twisted edges, the diameter, wide
diameter, and fault diameter of TQn are about half of those
of the comparable hypercube [5]. An n-dimensional twisted
cube is (n − 3)-Hamiltonian connected [16] and (n − 2)-
pancyclic [22], whereas the hypercube is not. Moreover, its
‡Department of Computer Science and Information Engineering,
Chaoyang University of Technology, Wufeng, Taichung 41349, Taiwan
§Corresponding author’s e-mail: rwhung@cyut.edu.tw
performance is better than that of the hypercube even if it is
asymmetric [1]. Recently, some interesting properties, such
as conditional link faults, of the twisted cube TQn were in-
vestigated. Yang et al. [27] showed that, with ne+nv  n−2,
a faulty TQn still contains a cycle of length l for every
4  l  |V (TQn)| − nv , where ne and nv are the numbers
of faulty edges and faulty nodes in TQn, respectively, and
|V (TQn)| denotes the number of nodes in TQn. In [12], Fu
showed that TQn can tolerate up to 2n − 5 edge faults,
while retaining a fault-free Hamiltonian cycle. Fan et al.
[11] showed that the twisted cube TQn, with n  3, is
edge-pancyclic and provided an O(l log l + n2 + nl)-time
algorithm to find a cycle of length l containing a given edge
of the twisted cube. In [11], the author also asked if TQn
is edge-pancyclic with (n − 3) faults for n  3. Yang [28]
answered the question and showed that TQn is not edge-
pancyclic with only one faulty edge for any n  3, and that
TQn is node-pancyclic with (n2 −1) faulty edges for every
n  3. Lai et al. [20] embedded a family of 2-dimensional
meshes into a twisted cube.
A Hamiltonian cycle in a graph is a simple cycle that
passes through every node of the graph exactly once. The
ring structure is important for distributed computing, and
its benefits can be found in [19]. Two Hamiltonian cycles
in a graph are said to be edge-disjoint if there exists no
common edge in them. The edge-disjoint Hamiltonian cycles
can provide an advantage for algorithms that make use of
a ring structure [25]. Consider the problem of all-to-all
broadcasting in which each node sends an identical message
to all other nodes in the network. There is a simple solution
for the problem using an n-node ring that requires n − 1
steps, i.e., at each step, every node receives a new message
from its ring predecessor and passes the previous message to
its ring successor. If the network admits edge-disjoint rings,
then messages can be divided and the parts broadcast along
different rings without any edge (link) contention. If the
network can be decomposed into edge-disjoint Hamiltonian
cycles, then the message traffic will be evenly distributed
across all communication links. Edge-disjoint Hamiltonian
cycles also form the basis of an efficient all-to-all broad-
casting algorithm for networks that employ wormhole or
cut-through routing [21]. Further, edge-disjoint Hamiltonian
cycles also provide the edge-fault tolerant Hamiltonicity of
an interconnected network; that is, when a Hamiltonian cycle
of an interconnected network contains one faulty edge, then
the other edge-disjoint Hamiltonian cycle can be used to
replace it for transmission. The existence of a Hamiltonian
cycle in twisted cubes has been verified [16]. However,
there has been little work reported so far on edge-disjoint
001 101
000 100
111 011
110 010
Fig. 1. The 3-dimensional twisted cube TQ3
00001 00101
00000 00100
00111 00011
00110 00010
01001 01101
01000 01100
01111 01011
01110 01010
10001 10101
10000 10100
10111 10011
10110 10010
TQ3
10
11001 11101
11000 11100
11111 11011
11110 11010
TQ3
11
TQ3
00
TQ3
01
Fig. 2. The 5-dimensional twisted cube TQ5 containing TQ003 , TQ103 ,
TQ013 , TQ
11
3 , where the leading two bits of nodes are underlined
III. TWO EDGE-DISJOINT HAMILTONIAN CYCLES
In this section, we first show the existence of two edge-
disjoint Hamiltonian cycles of an n-dimensional twisted
cube TQn with odd integer n  5. We then present a
linear time algorithm to construct two such edge-disjoint
Hamiltonian cycles of TQn. Obviously, a 3-dimensional
twisted cube TQ3 contains no two edge-disjoint Hamiltonian
cycles since each node is incident to three edges. Note
that the dimension of TQn is always odd. We will prove
the existence of two edge-disjoint Hamiltonian cycles in
TQn, with n  5, by induction on n, the dimension
of the twisted cube. For any odd integer n  5, we
show that there exist two edge-disjoint Hamiltonian paths
P and Q in TQn such that start(P ) = 00(0)n−5000,
end(P ) = 11(0)n−5000, start(Q) = 00(0)n−5100, and
end(Q) = 01(0)n−5100. By the definition of parity function
Pi(·), Pn−3(end(P )) = Pn−3(11(0)n−5000) = 0 and
Pn−3(end(Q)) = Pn−3(01(0)n−5100) = 1. By Definition
1, start(P ) ∈ N(end(P )) and start(Q) ∈ N(end(Q)).
Thus, P and Q are two edge-disjoint Hamiltonian cycles in
TQn for any odd integer n  5. In the following, we will
show how to construct two such edge-disjoint Hamiltonian
cycles. We first show that TQ5 contains two edge-disjoint
Hamiltonian paths as follows.
Lemma 1. There are two edge-disjoint Hamiltonian paths
P and Q in TQ5 such that start(P ) = 00000, end(P ) =
11000, start(Q) = 00100, and end(Q) = 01100.
Proof: We prove this lemma by constructing two such
paths P and Q. Let
P = 00000 → 00001 → 00101 → 00100 → 10100 → 10101
→ 10001 → 10000 → 10110 → 10010 → 00010 → 00011
→ 10011 → 10111 → 00111 → 00110 → 11110 → 11010
10001
00001 00101
10000
00111 00011
00110 00010
01001
01000
01101 01111 01011
01110 01010
10001 10101 10111 10011
10000 10100 10110 10010
11001
00011
11101 11111 11011
11100 11110 11010
00000
TQ3
00
TQ3
01
TQ3
10
TQ3
11
start P( )
end P( )
start Q( ) end Q( )
Fig. 3. Two edge-disjoint Hamiltonian paths in TQ5, where solid arrow
lines indicate a Hamiltonian path P , dashed arrow lines indicate the other
edge-disjoint Hamiltonian path Q, and the leading two bits of nodes are
underlined
→ 01010 → 01011 → 11011 → 11111 → 01111 → 01110
→ 01000 → 01001 → 01101 → 01100 → 11100 → 11101
→ 11001 → 11000, and let
Q = 00100 → 00000 → 10000 → 10100 → 10010 → 10011
→ 10001 → 00001 → 00011 → 00111 → 00101 → 10101
→ 10111 → 10110 → 00110 → 00010 → 01010 → 01110
→ 11110 → 11111 → 11101 → 01101 → 01111 → 01011
→ 01001 → 11001 → 11011 → 11010 → 11100 → 11000
→ 01000 → 01100.
Fig. 3 depicts the construction of P and Q. Clearly, P and
Q form two edge-disjoint Hamiltonian paths in TQ5.
Using Lemma 1, we prove the following lemma by induc-
tion.
Lemma 2. For any odd integer n  5, there are two
edge-disjoint Hamiltonian paths P and Q in TQn such
that start(P ) = 00(0)n−5000, end(P ) = 11(0)n−5000,
start(Q) = 00(0)n−5100, and end(Q) = 01(0)n−5100.
Proof: We prove this lemma by induction on n, the
dimension of the twisted cube. By Lemma 1, the lemma
holds true when n = 5. Assume that the lemma is true
for any odd integer n = k  5. We will prove that
the lemma holds true for n = k + 2. We first par-
tition TQk+2 into four sub-twisted cubes TQ00k , TQ10k ,
TQ01k , TQ
11
k . By the induction hypothesis, there are two
edge-disjoint Hamiltonian paths P ij and Qij in TQijk for
i, j ∈ {0, 1} such that start(P ij) = ij00(0)k−5000,
end(P ij) = ij11(0)k−5000, start(Qij) = ij00(0)k−5100,
and end(Qij) = ij01(0)k−5100. By the definition of parity
function Pi(·), Pk−1(end(P ij)) = Pk−1(start(P ij)) = 0,
Pk−1(end(Qij)) = 0, and Pk−1(start(Qij)) = 1. By
Definition 1, we have that end(P 00) ∈ N(end(P 10)),
start(P 10) ∈ N(start(P 01)), end(P 01) ∈ N(end(P 11)),
end(Q00) ∈ N(end(Q10)), start(Q10) ∈ N(start(Q11)),
and end(Q11) ∈ N(end(Q01)).
Let P = P 00 ⇒ P 10rev ⇒ P 01 ⇒ P 11rev and let Q =
Q00 ⇒ Q10rev ⇒ Q11 ⇒ Q01rev, where P 10rev , P 11rev , Q10rev, and
Q01rev are the reversed paths of P 10, P 11, Q10, and Q01,
respectively. Then, P and Q are two edge-disjoint Hamil-
tonian paths in TQk+2 such that start(P ) = 00(0)k−3000,
end(P ) = 11(0)k−3000, start(Q) = 00(0)k−3100, and
O(m logm) = O(n2n). Thus, the running time of Algorithm
CONSTRUCTING-2EDHP-TQ given TQn is O(n2n). Since
an n-dimensional twisted cube TQn contains 2n nodes and
n2n−1 edges, the algorithm is a linear time algorithm. Let
P and Q be two edge-disjoint Hamiltonian paths output
by Algorithm CONSTRUCTING-2EDHP-TQ given TQn. By
Definition 1, start(P ) ∈ N(end(P )) and start(Q) ∈
N(end(Q)). In addition, the edge connecting start(P ) with
end(P ) is different from the edge connecting start(Q) with
end(Q). Thus, P and Q are two edge-disjoint Hamiltonian
cycles of TQn. We then conclude the following theorem.
Theorem 4. Algorithm CONSTRUCTING-2EDHP-TQ cor-
rectly constructs two edge-disjoint Hamiltonian cycles
(paths) of an n-dimensional twisted cube TQn, with odd
integer n  5, in O(n2n)-linear time.
IV. TWO EQUAL NODE-DISJOINT CYCLES
In this section, we will construct two equal node-disjoint
cycles P and Q in a n-dimensional twisted cube TQn,
for any odd integer n  3. Our method for constructing
two equal node-disjoint cycles of TQn is also based on an
inductive construction. For any odd integer n  3, we will
construct two equal node-disjoint paths P and Q in TQn
such that start(P ) = 00(0)n−31, end(P ) = 01(0)n−31,
start(Q) = 00(0)n−30, and end(Q) = 11(0)n−30. The
basic idea is similar to that of constructing two edge-disjoint
Hamiltonian paths and is described as follows. Initially, we
construct two equal node-disjoint paths P and Q in TQ3
such that start(P ) = 001, end(P ) = 011, start(Q) = 000,
and end(Q) = 110. By Definition 1, P and Q are also node-
disjoint cycles with the same length. Consider that n is an
odd integer with n  5. We first partition TQn into four
subtwisted cubes TQ00n−2, TQ10n−2, TQ01n−2, TQ11n−2. Assume
that P ij and Qij are two equal node-disjoint paths in TQijn−2,
for i, j ∈ {0, 1}, such that start(P ij) = ij00(0)n−51,
end(P ij) = ij01(0)n−51, start(Qij) = ij00(0)n−50, and
end(Qij) = ij11(0)n−50. We then concatenate them into
two equal node-disjoint paths P and Q of TQn such that
start(P ) = 00(0)n−31, end(P ) = 01(0)n−31, start(Q) =
00(0)n−30, and end(Q) = 11(0)n−30. By Definition 1, P
and Q are also two equal node-disjoint cycles of TQn since
start(P ) ∈ N(end(P )) and start(Q) ∈ N(end(Q)). The
concatenating process will be presented in Lemma 6.
For TQ3, let P = 001 → 101 → 111 → 011 and let
Q = 000 → 100 → 010 → 110. Then, P and Q are
two equal node-disjoint paths in TQ3. By Definition 1,
start(P ) ∈ N(end(P )) and start(Q) ∈ N(end(Q)). Thus,
the following lemma holds true.
Lemma 5. There are two equal node-disjoint paths (cycles)
P and Q in TQ3 such that start(P ) = 001, end(P ) = 011,
start(Q) = 000, and end(Q) = 110.
Based on Lemma 5, we prove the following lemma.
Lemma 6. For any odd integer n  3, there exist two equal
node-disjoint paths P and Q in TQn such that start(P ) =
00(0)n−31, end(P ) = 01(0)n−31, start(Q) = 00(0)n−30,
and end(Q) = 11(0)n−30.
Proof: We prove this lemma by induction on n, the
dimension of TQn. By Lemma 5, the lemma holds true when
P
00 Q
00
TQk
10
end P( )
00
0001(0) 1
k 3
end Q( )
00
0011(0) 0
k 3
P
01 Q
01
end P( )
01
0101(0) 1
k 3
end Q( )
01
0111(0) 0
k 3
revP
10 Q
10
start P( )
10
1000(0) 1
k 3
end P( )
10
1001(0) 1
k 3
end Q( )
10
1011(0) 0
k 3
P
11 Q
11
start P( )
11
1100(0) 1
k  3
end P( )
11
1101(0) 1
k  3
end Q( )
11
1111(0) 0
k 3
rev
rev rev
TQk
11
TQk
00
TQk
01
start P( )
01
0100(0) 1
k 3
start P( )
00
0000(0) 1
k 3
start Q( )
00
0000(0) 0
k 3
start Q( )
01
0100(0) 0
k 3
start Q( )
11
1100(0) 1
k 3
start Q( )
10
1000(0) 0
k 3
Fig. 5. The constructions of two equal node-disjoint paths in TQk+2,
with k  3, where dashed arrow lines indicate the paths and solid arrow
lines indicate concatenated edges
n = 3. Assume that the lemma holds when n = k  3.
We will prove that the lemma holds true for n = k +
2. We first partition TQk+2 into four subtwisted cubes
TQ00k , TQ
10
k , TQ
01
k , TQ
11
k . By the induction hypothesis,
there are two equal node-disjoint paths P ij and Qij , for
i, j ∈ {0, 1}, in TQijk such that start(P ij) = ij00(0)k−31,
end(P ij) = ij01(0)k−31, start(Qij) = ij00(0)k−30, and
end(Qij) = ij11(0)k−30. By the definition of parity func-
tion Pi(·), Pk−1(end(P ij)) = 0, Pk−1(start(P ij)) = 1,
and Pk−1(end(Qij)) = Pk−1(start(Qij)) = 0. According
to Definition 1, we have that end(P 00) ∈ N(end(P 10)),
start(P 10) ∈ N(start(P 11)), end(P 11) ∈ N(end(P 01)),
end(Q00) ∈ N(end(Q10)), start(Q10) ∈ N(start(Q01)),
and end(Q01) ∈ N(end(Q11)).
Let P = P 00 ⇒ P 10rev ⇒ P 11 ⇒ P 01rev and let Q = Q00 ⇒
Q10rev ⇒ Q01 ⇒ Q11rev, where P 10rev , P 01rev , Q10rev, and Q11rev are
the reversed paths of P 10, P 01, Q10, and Q11, respectively.
Then, P and Q are two equal node-disjoint paths in TQk+2
such that start(P ) = 00(0)k−11, end(P ) = 01(0)k−11,
start(Q) = 00(0)k−10, and end(Q) = 11(0)k−10. Fig. 5
depicts the constructions of two such equal node-disjoint
paths P and Q in TQk+2. Thus, the lemma hods true when
n = k + 2. By induction, the lemma holds true.
By Definition 1, nodes start(P ) = 00(0)n−31 and
end(P ) = 01(0)n−31 are adjacent, and nodes start(Q) =
00(0)n−30 and end(Q) = 11(0)n−30 are adjacent. It imme-
diately follows from Lemma 6 that the following corollary
holds true.
Corollary 7. For any odd integer n  3, there exist two
equal node-disjoint cycles in TQn.
By the same arguments and analysis in constructing two
edge-disjoint Hamiltonian cycles of TQn, we can easily
construct two equal node-disjoint cycles of TQn in linear
time. We then conclude the following theorem.
Theorem 8. There exists an algorithm such that it correctly
constructs two equal node-disjoint cycles (paths) of an n-
dimensional twisted cube TQn, with odd integer n  3, in
O(n2n)-linear time.
−1− 
???????????? 
                                                             
???? NSC 99-2221-E-324-011-MY2 
???? ?????????????? 
?????? 
??????? 
??? 
??????????? ?? 
?????? 
??  
March 14-16, 2012 
???? International MultiConference of Engineers and Computer Scientists 2012 (IMECS 2012) 
?????? Embedding Two Edge-Disjoint Hamiltonian Cycles and Two Equal Node-Disjoint Cycles into Twisted Cubes 
 
?? ?????? 
IMECS (International MultiConference of Engineers and Computer Scientists) 
2012?? International Association of Engineers (IAENG)???????????
???????????????????????????????????
????IMECS ?????? 30 ???? 250 ??????????????
???????????????????????????????????
?? 
IAENG (International Association of Engineers)?????????????
????????????????????? 30 ????????????
???????????????????????????????????
???????????????????????????????????
???????????????????????????????????
???????? 
IMECS 2012????????????????????????Artificial 
−3− 
Networks?TCP in Wired and Wireless Networks?Quality of Service?Wireless MAC 
Protocol?Communication Coding?Ad hoc Networks and Cross Layer??)????
????(Applications for Smart Phones)??????????????????
?????? 
?? ???? 
?????????????????????????????????
?????????????????(?????)?????????????
???????????????????????????????????
???????????????????????????????????
??????????????????????????????????
???????????????????????????????????
???????????????????????????????????
????????????????????????? 
?? ?? 
LAENG IMECS??????????????????????????
??????????????????? EI/ISI ?????????????
???????????????????????????????????
?? 
?? ????????? 
????LAENG IMECS 2012???????Vol. I??(????????
Volume)? CD??(? Vol. I? Vol. II)??????????????? 
−5− 
?? ?????????? (???????) 
Ruo-Wei Hung, Shang-Ju Chan, and Chien-Chih Liao, Embedding two edge-disjoint 
Hamiltonian cycles and two equal node-disjoint cycles into twisted cubes, in:  
International MultiConference of Engineers and Computer Scientists 2012 
(IMECS’2012), Hong Kong, Vol. I, 2012, pp.362−367.  (EI/ISI Proceeding) 
 
                                                 
 Corresponding author. 
properties in the twisted cubes. In this paper, we show that,
for any odd integer n  5, there are two edge-disjoint
Hamiltonian cycles in the n-dimensional twisted cube TQn.
Two cycles in a graph are said to be equal and node-
disjoint if they contain the same number of nodes, there
is no common node in them, and every node of the graph
appears in one cycle exactly once. Finding two equal node-
disjoint cycles in an interconnected network is equivalent
to decompose the network into two disjoint sub-networks
with the same number of nodes such that each sub-network
contains a Hamiltonian cycle. Then, algorithms that require
a ring structure can be preformed in the two sub-networks
simultaneously. In this paper, we show that, for any odd
integer n  3, there exist two equal node-disjoint cycles
in the n-dimensional twisted cube TQn.
Related areas of investigation are summarized as fol-
lows. The edge-disjoint Hamiltonian cycles in k-ary n-
cubes and hypercubes has been constructed in [2]. Barth
et al. [3] showed that the butterfly network contains two
edge-disjoint Hamiltonian cycles. Petrovic et al. [23] char-
acterized the number of edge-disjoint Hamiltonian cycles
in hyper-tournaments. Hsieh et al. [14] constructed edge-
disjoint spanning trees in locally twisted cubes. Hsieh et
al. [15] investigated the edge-fault tolerant Hamiltonicity of
an n-dimensional locally twisted cube. The existence of a
Hamiltonian cycle in locally twisted cubes and twisted cubes
has been shown in [26] and [16], respectively. However,
there has been little work reported so far on edge-disjoint
properties in locally twisted cubes and twisted cubes. In
[17], we presented a linear time algorithm to construct two
edge-disjoint Hamiltonian cycles in locally twisted cubes.
In this paper, we show that there exist two edge-disjoint
Hamiltonian cycles and two equal node-disjoint cycles in an
n-dimensional twisted cube TQn. Note that for any TQn, n
is always an odd integer.
The rest of the paper is organized as follows. In Section
II, the structure of the twisted cube is introduced, and some
definitions and notations used throughout this paper are
given. Section III shows the construction of two edge-disjoint
Hamiltonian cycles in the twisted cube. In Section IV, we
construct two equal node-disjoint cycles in the twisted cube.
Finally, we conclude this paper in Section V.
II. PRELIMINARIES
We usually use a graph to represent the topology of an
interconnection network. A graph G = (V,E) is a pair of
the node set V and the edge set E, where V is a finite set
and E is a subset of {(u, v)|(u, v) is an unordered pair of
V }. We will use V (G) and E(G) to denote the node set and
the edge set of G, respectively. If (u, v) is an edge in a graph
G, we say that u is adjacent to v and u, v are incident to
edge (u, v). A neighbor of a node v in a graph G is any node
that is adjacent to v. Moreover, we use NG(v) to denote the
set of neighbors of v in G. The subscript ‘G’ of NG(v) can
be removed from the notation if it has no ambiguity.
Let G = (V,E) be a graph with node set V and edge set
E. A (simple) path P of length  in G, denoted by v0 →
v1 → · · · → v−1 → v, is a sequence (v0, v1, · · · , v−1, v)
of nodes such that (vi, vi+1) ∈ E for 0  i   − 1. The
first node v0 and the last node v visited by P are denoted
by start(P ) and end(P ), respectively. Path v → v−1 →
· · · → v1 → v0 is called the reversed path, denoted by Prev,
of path P . That is, path Prev visits the nodes of path P from
end(P ) to start(P ) sequentially. In addition, P is a cycle
if |V (P )|  3 and end(P ) is adjacent to start(P ). A path
P = v0 → v1 → · · · → v−1 → v may contain another
subpath Q, denoted as v0 → v1 → · · · → vi−1 → Q →
vj+1 → · · · → v−1 → v, where Q = vi → vi+1 →
· · · → vj for 0  i  j  . A path (or cycle) in G
is called a Hamiltonian path (or Hamiltonian cycle) if it
contains every node of G exactly once. Two paths (or cycles)
P1 and P2 connecting a node u to a node v are said to be
edge-disjoint if and only if E(P1) ∩ E(P2) = ∅. Two paths
(or cycles) Q1 and Q2 of graph G are called node-disjoint
if and only if V (Q1)∩ V (Q2) = ∅. Two node-disjoint paths
(or cycles) Q1 and Q2 of graph G are said to be equal if and
only if |V (Q1)| = |V (Q2)| and V (Q1) ∪ V (Q2) = V (G).
Two node-disjoint paths Q1 and Q2 can be concatenated
into a path, denoted by Q1 ⇒ Q2, if end(Q1) is adjacent to
start(Q2).
Now, we introduce twisted cubes. The node set of the n-
dimensional twisted cube TQn is the set of all binary strings
of length n. Note that due to the twisted edge property of
a twisted cube, the dimension n of TQn is always defined
as an odd integer. A binary string b of length n is denoted
by bn−1bn−2 · · · b1b0, where bn−1 is the most significant bit.
We denote the complement of bit bi by bi = 1 − bi. To
define TQn, a i-th bit parity function Pi(b) is introduced. Let
b = bn−1bn−2 · · · b1b0 be a binary string. For 0  i  n−1,
Pi(b) = bi ⊕ bi−1⊕ · · · ⊕ b1⊕ b0, where ⊕ is the exclusive-
or operation. We then give the recursive definition of the n-
dimensional twisted cube TQn, for any odd integer n  1,
as follows.
Definition 1. [13], [28] TQ1 is the complete graph with
two nodes labeled by 0 and 1, respectively. For an odd
integer n  3, TQn consists of four copies of TQn−2. We
use TQijn−2 to denote an (n − 2)-dimensional twisted cube
which is a subgraph of TQn induced by the nodes labeled
by ijbn−3 · · · b1b0, where i, j ∈ {0, 1}. Edges that connect
these four sub-twisted cubes can be described as follows:
Each node b = bn−1bn−2 · · · b1b0 ∈ V (TQn) is adjacent
to bn−1bn−2 · · · b1b0 and bn−1bn−2 · · · b1b0 if Pn−3(b) =
0; and to bn−1bn−2 · · · b1b0 and bn−1bn−2 · · · b1b0 if
Pn−3(b) = 1.
By the above definition, an n-dimensional twisted cube
TQn is an n-regular graph with 2n nodes and n2n−1 edges,
i.e., each node of TQn is adjacent to n nodes. The dimension
n of TQn is always an odd integer. In addition, TQn can be
decomposed into four sub-twisted cubes TQ00n−2, TQ10n−2,
TQ01n−2, TQ
11
n−2, where TQ
ij
n−2 consists of those nodes
b = bn−1bn−2 · · · b1b0 with leading two bits bn−1 = i
and bn−2 = j. For each ij ∈ {00, 10, 01, 11}, TQijn−2 is
isomorphic to TQn−2. For example, Fig. 1 shows TQ3 and
Fig. 2 depicts TQ5 containing four sub-twisted cubes TQ003 ,
TQ103 , TQ
01
3 , TQ
11
3 .
Let b be a binary string bt−1bt−2 · · · b1b0 of length t. We
denote bτ the new binary string obtained by repeating b string
τ times. For instance, (01)3 = 010101 and 04 = 0000.
P
00 Q
00
TQk
10
end P( )
00
0011(0) 000
k 5
end Q( )
00
0001(0) 100
k 5
P
01 Q
01
end P( )
01
0111(0) 000
k 5
end Q( )
01
0101(0) 100
k 5
rev
P
10 Q
10
start P( )
10
1000(0) 000
k 5
end P( )
10
1011(0) 000
k 5
end Q( )
10
1001(0) 100
k 5
P
11 Q
11
start P( )
11
1100(0) 000
k 5
start Q( )
11
1100(0) 100
k 5
end P( )
11
1111(0) 000
k 5
end Q( )
11
1101(0) 100
k 5
revrev rev
start Q( )
10
1000(0) 100
k 5
TQk
11
TQk
00
TQk
01
start P( )
01
0100(0) 000
k 5
start P( )
00
0000(0) 000
k 5
start Q( )
00
0000(0) 100
k 5
start Q( )
01
0100(0) 100
k 5
Fig. 4. The construction of two edge-disjoint Hamiltonian paths in TQk+2,
with odd integer k  5, where dashed arrow lines indicate the paths, solid
arrow lines indicate concatenated edges, and the leading two bits of nodes
are underlined
end(Q) = 01(0)k−3100. Fig. 4 depicts the construction of
two such edge-disjoint Hamiltonian paths in TQk+2. Thus,
the lemma hods true when n = k + 2. By induction, the
lemma holds true.
Let P and Q be two edge-disjoint Hamiltonian paths
constructed in Lemma 2. By the definition of parity func-
tion, Pn−3(end(P )) = Pn−3(11(0)n−5000) = 0 and
Pn−3(end(Q)) = Pn−3(01(0)n−5100) = 1. By Definition
1, node start(P ) is adjacent to node end(P ), and node
start(Q) is adjacent to node end(Q). In addition, the
two edges (start(P ), end(P )) and (start(Q), end(Q)) are
distinct. Thus the following theorem holds true.
Theorem 3. For any odd integer n  5, there exist two
edge-disjoint Hamiltonian paths (cycles) in an n-dimensional
twisted cube TQn .
Based on the proofs of Lemmas 1 and 2, we design
a recursive algorithm to construct two edge-disjoint
Hamiltonian paths of an n-dimensional twisted cube.
The algorithm typically follows a divide-and-conquer
approach [7] and is sketched as follows. It is given by an
n-dimensional twisted cube TQn with odd integer n  5.
If n = 5, then the algorithm constructs two edge-disjoint
Hamiltonian paths according to the proof of Lemma 1.
Suppose that n > 5. It first decomposes TQn into four sub-
twisted cubes TQ00n−2, TQ10n−2, TQ01n−2, and TQ11n−2, where
TQijn−2 consists of those nodes b = bn−1bn−2bn−3 · · · b1b0
with leading two bits bn−1 = i and bn−2 = j. For each
ij ∈ {00, 10, 01, 11}, TQijn−2 is isomorphic to TQn−2.
Then, the algorithm recursively computes two edge-disjoint
Hamiltonian paths of TQijn−2 for ij ∈ {00, 10, 01, 11}.
Finally, it concatenates these eight paths into two edge-
disjoint Hamiltonian paths of TQn according to the proof
of Lemma 2, and outputs two such concatenated paths. The
algorithm is formally presented as follows.
Algorithm CONSTRUCTING-2EDHP-TQ
Input: TQn, an n-dimensional twisted cube with odd integer
n  5.
Output: Two edge-disjoint Hamiltonian paths P and Q
in TQn such that start(P ) = 00(0)n−5000, end(P ) =
11(0)n−5000, start(Q) = 00(0)n−5100, and end(Q) =
01(0)n−5100.
Method:
1. if n = 5, then
2. let P = 00000 → 00001 → 00101 → 00100 →
10100 → 10101 → 10001 → 10000 → 10110 →
10010 → 00010 → 00011 → 10011 → 10111 →
00111 → 00110 → 11110 → 11010 → 01010 →
01011 → 11011 → 11111 → 01111 → 01110 →
01000 → 01001 → 01101 → 01100 → 11100 →
11101 → 11001 → 11000;
3. let Q = 00100 → 00000 → 10000 → 10100 →
10010 → 10011 → 10001 → 00001 → 00011 →
00111 → 00101 → 10101 → 10111 → 10110 →
00110 → 00010 → 01010 → 01110 → 11110 →
11111 → 11101 → 01101 → 01111 → 01011 →
01001 → 11001 → 11011 → 11010 → 11100 →
11000 → 01000 → 01100;
4. output “P and Q” as two edge-disjoint Hamiltonian
paths of TQ5;
5. decompose TQn into four sub-twisted cubes TQ00n−2,
TQ10n−2, TQ
01
n−2, and TQ11n−2, where TQ
ij
n−2 consists
of those nodes b = bn−1bn−2bn−3 · · · b1b0 with leading
two bits bn−1 = i and bn−2 = j
6. for ij ∈ {00, 10, 01, 11} do
7. call Algorithm CONSTRUCTING-2EDHP-TQ given
TQijn−2 to compute two edge-disjoint Hamiltonian
paths P ij and Qij of TQijn−2, where start(P ij) =
ij00(0)n−7000, end(P ij) =ij11(0)n−7000,
start(Qij) = ij00(0)n−7100, and end(Qij) =
ij01(0)n−7100;
8. compute P = P 00 ⇒ P 10rev ⇒ P 01 ⇒ P 11rev and Q =
Q00 ⇒ Q10rev ⇒ Q11 ⇒ Q01rev, where P 10rev , P 11rev , Q10rev,
and Q01rev are the reversed paths of P 10, P 11, Q10, and
Q01, respectively;
9. output “P and Q” as two edge-disjoint Hamiltonian
paths of TQn.
The correctness of Algorithm CONSTRUCTING-2EDHP-
TQ follows from Lemmas 1 and 2. Now, we analyze
its time complexity. Let m be the number of nodes in
TQn. Then, m = 2n. Let TQ(m) be the running time of
Algorithm CONSTRUCTING-2EDHP-TQ given TQn. It is
easy to verify from lines 2 and 3 that TQ(m) = O(1)
if n = 5. Suppose that n > 5. By visiting every node
of TQn once, decomposing TQn into TQ00n−2, TQ10n−2,
TQ01n−2 and TQ11n−2 can be done in O(m) time, where
each node in TQijn−2, ij ∈ {00, 10, 01, 11}, is labeled with
leading two bits ij. Thus, line 5 of the algorithm runs in
O(m) time. Then, our division of the problem yields four
subproblems, each of which is 1/4 the size of the original.
It takes time TQ(m4 ) to solve one subproblem, and so it takes
time 4 · TQ(m4 ) to solve the four subproblems. In addition,
concatenating eight paths into two paths (line 8) can be easily
done in O(m) time. Thus, we get the following recurrence
equation:
TQ(m) =
{
O(1) , if n = 5;
4 · TQ(m4 ) +O(m) , if n > 5.
The solution of the above recurrence is TQ(m) =
V. CONCLUDING REMARKS
In this paper, we construct two edge-disjoint Hamiltonian
cycles (paths) of a n-dimensional twisted cubes TQn, for
any odd integer n  5. Furthermore, we construct two equal
node-disjoint cycles (paths) of TQn, for any odd integer n 
3. Note that due to the twisted edge property of a twisted
cube, the dimension n of TQn is always an odd integer.
In the construction of two edge-disjoint Hamiltonian cycles
(paths) of TQn, some edges are not used. It is interesting
to see if there are more edge-disjoint Hamiltonian cycles of
TQn with odd dimension n  7. We would like to post this
as an open problem to interested readers.
ACKNOWLEDGMENT
This work was partly supported by the National Science
Council of Taiwan, R.O.C. under grant no. NSC 99-2221-E-
324-011-MY2.
REFERENCES
[1] S. Abraham and K. Padmanabhan, “The twisted cube topology for
multiprocessors: a study in network asymmetry,” J. Parallel Distrib.
Comput., vol. 13, pp. 104–110, 1991.
[2] M.M. Bae and B. Bose, “Edge disjoint Hamiltonian cycles in k-ary
n-cubes and hypercubes,” IEEE Trans. Comput., viol. 52, no. 10, pp.
1271–1284, 2003.
[3] D. Barth and A. Raspaud, “Two edge-disjoint hamiltonian cycles in
the butterfly graph,” Inform. Process. Lett., vol. 51, pp. 175–179, 1994.
[4] L.N. Bhuyan and D.P. Agrawal, “Generalized hypercube and hyperbus
structures for a computer network,” IEEE Trans. Comput., vol. C-33,
no. 4, pp. 323–333, 1984.
[5] C.P. Chang, J.N. Wang, and L.H. Hsu, “Topological properties of
twisted cubes,” Inform. Sci., vol. 113, pp. 147–167, 1999.
[6] S.A. Choudum and V. Sunitha, “Augmented cubes,” Networks, vol. 40,
no. 2, pp. 71–84, 2002.
[7] T.H. Cormen, C.E. Leiserson, R.L. Rivest, and C. Stein, Introduction
to Algorithms (3rd ed.), MIT Press, Cambridge, Massachusetts, 2009.
[8] P. Cull and S.M. Larson, “The Mo¨bius cubes,” IEEE Trans. Comput.,
vol. 44, no. 5, pp. 647–659, 1995.
[9] D.Z. Du and F.K. Hwang, “Generalized de Bruijn digraphs,” Networks,
vol. 18, pp. 27–38, 1988.
[10] K. Efe, “The crossed cube architecture for parallel computing,” IEEE
Trans. Parallel Distribut. Syst., vol. 3, no. 5, pp. 513–524, 1992.
[11] J. Fan, X. Jia, and X. Lin, “Embedding of cycles in twisted cubes with
edge pancyclic,” Algorithmica, vol. 51, pp. 264–282, 2008.
[12] J.S. Fu, “Fault-free Hamiltonian cycles in twisted cubes with condi-
tional link faults,” Theoret. Comput. Sci., vol. 407, pp. 318–329, 2008.
[13] P.A.J. Hilbers, M.R.J. Koopman, and J.L.A. van de Snepscheut, “The
twisted cube,” in: J. deBakker, A. Numan, P. Trelearen (Eds.), PARLE:
Parallel Architectures and Languages Europe, Parallel Architectures,
vol. 1, Springer, Berlin, 1987, pp. 152–158.
[14] S.Y. Hsieh and C.J. Tu, “Constructing edge-disjoint spanning trees in
locally twisted cubes,” Theoret. Comput. Sci., vol. 410, pp. 926–932,
2009.
[15] S.Y. Hsieh and C.Y. Wu, “Edge-fault-tolerant Hamiltonicity of locally
twisted cubes under conditional edge faults,” J. Comb. Optim., vol. 19,
pp. 16–30, 2010.
[16] W.T. Huang, J.M. Tan, C.N. Hung, and L.H. Hsu, “Fault-tolerant
Hamiltonianicity of twisted cubes,” J. Parallel Distrib. Comput., vol.
62, pp. 591–604, 2002.
[17] R.W. Hung, “Embedding two edge-disjoint Hamiltonian cycles into
locally twisted cubes,” Theoret. Comput. Sci., vol. 412, no. 35, pp.
4747–4753, 2011.
[18] S.C. Hwang and G.H. Chen, “Cycles in butterfly graphs,” Networks,
vol. 35, no. 2, pp. 161–171, 2000.
[19] A. Kanevsky and C. Feng, “On the embedding of cycles in pancake
graphs,” Parallel Comput., vol. 21, pp. 923–936, 1995.
[20] C.J. Lai and C.H. Tsai, “Embedding a family of meshes into twisted
cubes,” Inform. Process. Lett., vol. 108, pp. 326–330, 2008.
[21] S. Lee and K.G. Shin, “Interleaved all-to-all reliable broadcast on
meshes and hypercubes,” in: Proc. Int. Conf. Parallel Processing, vol.
3, 1990, pp. 110–113.
[22] T.K. Li, M.C. Yang, J.M. Tan, and L.H. Hsu, “On embedding cycle
in faulty twisted cubes,” Inform. Sci., vol. 176, pp. 676–690, 2006.
[23] V. Petrovic and C. Thomassen, “Edge-disjoint Hamiltonian cycles in
hypertournaments,” J. Graph Theory, vol. 51, pp. 49–52, 2006.
[24] Y. Saad and M.H. Schultz, “Topological properties of hypercubes,”
IEEE Trans. Comput., vol. 37, no. 7, pp. 867–872, 1988.
[25] R. Rowley and B. Bose, “Edge-disjoint Hamiltonian cycles in de
Bruijn networks,” in: Proc. 6th Distributed Memory Computing Con-
ference, 1991, pp. 707–709.
[26] X. Yang, G.M. Megson, and D.J. Evans, “Locally twisted cubes are
4-pancyclic,” Appl. Math. Lett., vol. 17, pp. 919–925, 2004.
[27] M.C. Yang, T.K. Li, Jimmy J.M. Tan, and L.H. Hsu, “On embedding
cycles into faulty twisted cubes,” Inform. Sci., vol. 176, pp. 676–690,
2006.
[28] M.C. Yang, “Edge-fault-tolerant node-pancyclicity of twisted cubes,”
Inform. Process. Lett., vol. 109, pp. 1206–1210, 2009.
99年度專題研究計畫研究成果彙整表 
計畫主持人：洪若偉 計畫編號：99-2221-E-324-011-MY2 
計畫名稱：區段圖與圓弧圖上之認證演算法 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 1 1 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 2 2 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 3 3 100%  
研究報告/技術報告 0 0 100%  
研討會論文 2 2 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
■達成目標 
□未達成目標（請說明，以 100字為限） 
□實驗失敗 
□因故實驗中斷 
□其他原因 
說明： 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：■已發表 □未發表之文稿 □撰寫中 □無 
專利：□已獲得 □申請中 ■無 
技轉：□已技轉 □洽談中 ■無 
其他：（以 100字為限） 
3. 請依學術成就、技術創新、社會影響等方面，評估研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）（以
500字為限） 
本計畫第一年中，我們提出 O(n)-時間的認證演算法(certifying algorithms)來解決區段
圖(interval graphs)上的路徑覆蓋(path cover)、漢彌爾頓迴路(Hamiltonian cycle)問
題。本年度之執行成果已整理成期刊論文，並已發表於 Appl. Math. Lett.期刊(SCI)，如
下所示： 
(I)Ruo-Wei Hung* and Maw-Shang Chang, Linear-time certifying algorithms for the 
path cover and Hamiltonian cycle problems on interval graphs, Applied Mathematics 
Letters 24/5 (2011) pp. 648-652. (SCI/EI) 
 
    本計畫第二年中，我們提出有效率認證演算法來解決圓弧圖上漢彌爾頓迴路的相關問
題(Hamiltonian cycle related problems on circular-arc graphs)。本年度之執行成
果已整理成期刊論文，並已發表於 Theoret. Comput. Sci.期刊(SCI)，如下所示： 
(II)Ruo-Wei Hung* and Maw-Shang Chang, An efficient certifying algorithm for the 
Hamiltonian cycle problem on circular-arc graphs, Theoretical Computer Science 
412/39 (2011) pp. 5351-5373. (SCI/EI) 
 
    另外, 透過本計畫的補助, 我們另外發表如下的 EI 期刊論文: 
(III)Ruo-Wei Hung*, Chun-Kai Wang and Chih-Chia Yao, The neighbor-scattering 
number of proper interval graphs, ICIC Express Letters 5/6 (2011) pp. 2059-2064. 
