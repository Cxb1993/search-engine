研究計畫中英文摘要： 
 
關鍵詞：剖面導向程式設計，多型剖面，織入，多型型態系統，型態推理 
 
剖面導向程式設計(Aspect-Oriented Programming, AOP)是近年來繼物件導向程式設計
(OOP)後，所興起的一種新的程式設計方法。從 AOP 的觀點來看，應用程式除了功能邏輯
以外，還有許多像安全需求等的橫跨性關注(crosscutting concerns)；實現這些橫跨性關注
的程式碼應該要從功能模組中分離出來，自成一模組並稱之為剖面。剖面與功能模組之間
的界接點由所謂橫跨點(pointcut)來定義，並透過稱之為織入(weaving)的機制將剖面程式碼
整合入功能模組中，從而合成完整程式，滿足系統整體需求。這樣實現橫跨性關注的程式
碼就可以集中封裝於適當的模組中，避免掉程式碼糾結與重複的問題。 
 
近幾年來關於剖面程式設計的各項研究蓬勃發展，從剖面程式語言、開發工具、剖面
設計與分析，到剖面的理論基礎，都可見到了許多的研究成果陸續發表出來。這些研究成
果大多集中在探討像 AspectJ 這類以物件導向為基礎的剖面語言的各個面向，因這類語言
都不具備參數式多型(parametric polymorphism)的功能，所以關於多型剖面(Polymorphic 
aspects)的研究尚屬起步階段。不過去年推出的 Java 5 已提供多型(或稱泛型 Generics)的機
制，所以我們認為實有必要針對多型剖面所帶來的技術與理論的挑戰加以探討，好替下一
代的剖面語言奠定基礎。目前多型剖面的研究主要是以具備多型機制的函數式語言為基
礎，雖然已經有了一些重要的結果，但仍然有許多可以改善加強的地方。舉例而言，如何
適當整合高階函數與多型剖面就還是一個重要的研究課題。 
 
本計劃以型態導向的方法發展一套多型剖面的織入技術，並將其應用到多型程式設計
上。目前關於多型剖面的織入處理研究，雖然也會採用型態資訊，但是還是以語法結構為
基礎，以致於不能處理像高階函數的間接呼叫，也無法解決多個形態有重疊的剖面的織入
問題。我們提出所謂的諮詢型態(advised types)的概念，將剖面織入的需求內入型態之中，
透過型態推理(type inference)的過程，選擇出型態相容的剖面在適當的環境(context)下織入
功能程式模組。這樣以型態推演程序完成織入的作法，不僅可以避免單就語法結構來決定
織入剖面的缺點，並有機會可以替多型剖面奠定一個良好的理論基礎，並進而在多型程式
的設計上，導入剖面機制，改善多型程式的模組結構。 
 
目錄 
1. Introduction 
2. AspectFun: The Aspect Language 
3. Operational Semantics 
4. Static Weaving 
5. Correctness of Static Weaving 
6. Control-Flow Based Pointcuts 
7. Related Work 
8. Conclusions and Future Work 
9. Appendix: Proof 
10. 計畫成果自評 
11. 出席國際會議心得報告與論文 
· 3
rest of the computation at the advised function”; specifically, it enables the control
to revert to the advised function (ie., h).
Using type-scoped aspects enable us to have customized, type-dependent tracing
message. Note that String (a list of Char) is treated differently from ordinary lists.
Assuming a textual order of advice triggering, the corresponding trace messages
produced by executing the complete program is displayed to the right of the example
code.
In the setting of strongly-type polymorphic functional languages, types are treated
as compile-time entities. As their use in controlling advices can usually be deter-
mined at compile-time, it is desirable to perform static weaving of advices into base
program at compile time to produce an integrated code without explicit declaration
of aspects. Moreover, as pointed out by Sereni and de Moor [Sereni and de Moor
2003], the integrated woven code produced by static weaving can facilitate static
analysis of aspect-oriented programs.
Despite its benefits, static weaving is never a trivial task, especially in the pres-
ence of type-scoped advices. Specifically, it is not always possible to determine
locally at compile time if a particular advice should be woven. Consider Exam-
ple 1, from a syntactic viewpoint, function h can be called in the body of f. If we
were to naively infer that the argument x to function h in the RHS of f’s defini-
tion is of polymorphic type, we would be tempted to conclude that (1) advice n3
should be triggered at the call, and (2) advices n4 and n5 should not be called as
its type-scope is less general than a → a. As a result, only n3 would be statically
applied to the call to h.
Unfortunately, this approach would cause inconsistent behavior of h at run-time,
as only the third trace message “exiting from h” would be printed. This would
be incoherent because the invocations (h [1]) (indirectly called from (f [1]))
and (h [2]) would exhibit different behaviors even though they would receive
arguments of the same type.
Most of the work on aspect-oriented functional languages do not address this
issue of static and yet coherent weaving. In AspectML [Dantas et al. 2007] (a.k.a
PolyAML [Dantas et al. 2005]), dynamic type checking is employed to handle match-
ing of type-scoped pointcuts; on the other hand, Aspectual Caml [Masuhara et al.
2005] takes a lexical approach which sacrifices coherence1 for static weaving.
In this paper, we present a compilation model for AspectFun that ensures static
and coherent weaving. AspectFun is an aspect-oriented polymorphically typed func-
tional language with lazy semantics. The overall compilation process is illustrated
in Figure 2. Briefly, the model comprises the following three major steps: (1) Static
type inference of an aspect-oriented program; (2) Type-directed static weaving to
convert advices to functions and produce a piece of woven code; (3) Type-directed
optimization of the woven code.
This paper consolidates our past research in this field [Wang et al. 2006b; 2006a;
Chen et al. 2007] and makes significant revisions and extensions to several dimen-
sions of our research. Specifically, in this paper,
1Our notion of coherence admits semantic equivalence among different invocations of a function
with the same argument type. This is different from the coherence concept defined in quali-
fied types [Jones 1992] which states that different translations of an expression are semantically
equivalent.
· 5
h x = x in
f dh x = dh x in
(f <h,{n3,n4,n5}> "c", f <h,{n3,n4}> [1], <h,{n3,n4}> [2])
Note that all advice declarations are translated into functions and then woven. A
meta-construct 〈 , {. . .}〉, called chain expression, is used to express the chaining
of advices and advised functions. For instance, 〈h , {n3, n4}〉 denotes the chaining
of advices n3 and n4 to advised function h. In the above example, the two invo-
cations of h, with integer-list arguments, in the original aspect program have been
translated to invocations of the chain expression 〈h , {n3, n4}〉. This shows that our
weaver respects the coherence property.
All the technically challenging stages in the compilation process are explained
in detail – in their respective sections – in the rest of this paper. We gather all
compilation processes pertaining to control-flow based pointcuts in Section 6.
The outline of the paper is as follows: Section 2 highlights various aspect-
oriented features through AspectFun. Section 3 defines a lazy semantics for As-
pectFun. In Section 4, we describe our type inference system and the corresponding
type-directed static weaving process. Next, we formulate the correctness of static
weaving with respect to the semantics of AspectFun. In section 6, we provide a
detailed description of how control-flow based pointcuts are handled in our com-
pilation model. We discuss related work in Section 7 and conclude in Section 8.
Appendix A provides the detailed proof of the correctness of static weaving.
2. ASPECTFUN: THE ASPECT LANGUAGE
In this section, we introduce the aspect-oriented lazy functional language, Aspect-
Fun, for our investigation. Next, we briefly introduce the concept of advised type
to capture the need for advice weaving based on type contexts. We also intro-
duce various features of aspects in our language. These include: curried pointcuts,
control-flow based pointcuts, second-order advices and nested advices.
Programs pi ::= d in pi | e
Declarations d ::= x = e | f x = e | n@advice around {pc} (arg) = e
Arguments arg ::= x | x :: t
Pointcuts pc ::= ppc | pc+ cf | pc− cf
Primitive PC’s ppc ::= f x | any | any\[f ] | n
Cflows cf ::= cflow(f) | cflow(f( :: t)) | cflowbelow(f) | cflowbelow(f( :: t))
Expressions e ::= c | x | proceed | λx.e | e e | let x = e in e
Types t ::= Int | Bool | a | t→ t | [t]
Advice Predicates p ::= (f : t)
Advised Types ρ ::= p.ρ | t
Type Schemes σ ::= ∀a¯.ρ
Fig. 3. Syntax of the AspectFun Language
Figure 3 presents the language syntax. We write o¯ as an abbreviation for a
sequence of objects o1, ..., on (e.g. declarations, variables etc) and fv(o) as the set of
free variables in o. We assume that o¯ and o, when used together, denote unrelated
· 7
scheme for f will be inferred to be ∀a.(h : a → a).a → a, which indicates that
whenever f is applied in a specific context, the advices on h may also be triggered.
Specifically, inside the main expression, all three function calls will carry some
proper sets of advices on h, even for the calls that are made to f. Then, when a
h-call is eventually invoked, the right advices to h will be triggered.
2.2 Curried Pointcuts
Higher-orderness naturally brings forth the notion of partial application of curried
functions. In typical applications of AOP such as tracing or profiling, it is important
to be able to advise on not only full applications of functions, but also partial
applications of curried functions to their arguments other than the first one. In our
system, we allow type-scoped advices with curried-function pointcuts, as shown
below:
Example 2
n1@advice around {f x} (arg::Int) = e1 in
n2@advice around {f} (arg::Int) = e2 in
n3@advice around {f x} (arg) = e3 in
let f x y = x + 1 in
f 1 2
We use meta-variables (in italic font) such as e1, e2 and so on to represent expres-
sions with omitted details. Through out this paper, without special mentioning, we
assume expressions represented by meta-variables are not advised. Note that be-
cause of well-typedness, we insist that the advice body of n2, e2, to be of a function
type · → ·, while the advice bodies e1 and e3 are of non-function types.
There have been some recommmendation for defining operational semantics of
aspect-oriented programs for higher-order functions and partial function applica-
tions, scuh as [Tucker and Krishnamurthi 2003]. Nevertheless, there is still not yet
any unanimous and unambiguous agreement on it. In this work, we adopt the view-
point that functions are identified by names at pointcuts, and advices are triggered
whenever their partial applications matches that of the pointcuts [Masuhara et al.
2005]. This differs from the recommendation by [Tucker and Krishnamurthi 2003]
which triggers advices based on matching of run-time closures.
Back to Example 2, using a similar technique as in [Masuhara et al. 2005], we
simplify curried advices into non-curried ones as follows:
n1 = \x.\arg -> let proceed’ = proceed x in [proceed’/proceed]e1 in
n2 = \arg -> e2 in
n3 = \x.\arg -> let proceed’ = proceed x in [proceed’/proceed]e3 in
f x y = x in
<f,{n1,n2,n3}> 1 2
We refer the readers to Section 4.6 for detail.
2.3 Control-flow Based Pointcuts
The composite pointcuts in AspectFun are those related to the control flow of a
program. Specifically, we can write a pointcut which identifies a subset of invoca-
· 9
a run-time stack with the aspects. Furthermore, we also perform some static anal-
ysis to reduce the runtime overhead of executing control-flow based advices. The
detailed scheme will be presented in Section 6.
2.4 Second-Order Advices and Nested Advices
In AspectFun, advice names can also be primitive pointcuts. As such, we allow
advices to be developed to advise other advices. We refer to such advices as second-
order advices. In contrast, the two-layered design of AspectJ like languages only
allow advices to advise other advices in a very restricted way. The loss of expres-
siveness of such an approach has been well argued in [Rajan and Sullivan 2005].
The following code fragment shows a use of second-order advice to compute the
total amount of a customer order and apply discount rates according to certain
business rules.
Example 4
n3@advice around {n1,n2} (arg) = let finalRate = proceed arg
in if (finalRate < 0.5) then 0.5
else finalRate in
n1@advice around {getRate} (arg) =
(getHolidayRate arg) * (proceed arg) in
n2@advice around {getRate} (arg) =
(getAnnivRate arg) * (proceed arg) in
discount item = (getRate item) * (getPrice item) in
calcPrice cart = sum (map discount cart) in e
In addition to the regular discount rules, ad-hoc sale discounts such as holiday-
sales, anniversary sales etc., can be introduced through aspect declarations, thus
achieving separation of concerns. This is shown in the n1 and n2 declarations.
Furthermore, there may be a rule stipulating the maximum discount rate that is
applicable to any product item, regardless of the multiple discounts it qualifies.
Such a business rule can be realized using a second-order aspect, as in n3. It calls
proceed to compute the combined discount rate and ensures that the rate does not
exceed 50%.
In addition to direct advising, we can also write advice that advises other advice
indirectly. Specifically, inside the body of an advice definition, there may be calls to
other functions that are advised by other advices. We call the latter nested advices.
This is particularly useful in security applications. Consider a different attempt to
invoke the restricted function f from Example 3.
Example 5
n@advice around {f + cflow(g)} (arg) = e1 // fully trusted execution
n1@advice around {w} (arg) = f arg in
f x = e2 // partially trusted execution
w x = e3 in
h x y = x y in
g x = h w x in
g 1
· 11
3.1 FIL conversion
We provide three sets of conversion rules to transform an AspectFun program into
an FIL program, namely declaration conversion, expression conversion and type
conversion, listed in figures 5, 6 and 7. The conversion process is led by the step
pi
prog½ (A, eI) in the declaration conversion rule, (prog½). The judgement ∆ `D pi :
τ ½ eI ;A asserts that an AspectFun program, pi, under a type environment (also
called conversion environment) ∆ of structure x : ς, having type τ is converted to an
FIL program, consisting of an expression eI , and an advice store A which is a set of
advice tuples. Another major conversion is expression conversion. The judgement
∆ ` e : τ ½ eI asserts that an AspectFun expression e having a type τ under ∆
is converted to an FIL expression eI . Lastly, the type conversion
type½ simply strips
away the advice predicate part of a type scheme in AspectFun and map the latter
to an isomorphic type scheme in FIL. Here, the function fresh(a) takes a sequence
of type variables and returns the same number of new type variables in sequence.
(
prog½) ∅ `D pi : τ ½ e
I ;A
pi
prog½ (A, eI) (Decl:MainExpr)
∆ ` e : τ ½ eI
∆ `D e : τ ½ eI ; ∅
(Decl:Var)
∆ ` e : τx ½ eIx α = fv(τx) \ fv(∆) ∆.x : ∀α. τx `D pi : τ ½ eI ;A
∆ `D x = e in pi : τ ½ LET x = Λα. eIx IN eI ;A
(Decl:Func)
∆ ` λx.e : τx → τf ½ λx : τx.eIf α = fv(τx → τf ) \ fv(∆)
∆.f : ∀α. τx → τf `D pi : τ ½ eI ;A
∆ `D f x = e in pi : τ ½ LET f = Λα. λf :τx→τfx : τx. eIf IN eI ;A
(Decl:Adv)
∆ `D n@advice around {pc} (x :: a) = e in pi : τ ½ eI ;A
∆ `D n@advice around {pc} (x) = e in pi : τ ½ eI ;A
(Decl:Adv-An)
tx
type½ τx ∆.proceed : τ1 → τ2 ` λx.e : τ1 → τ2 ½ λx : τ1.eIn
α = fv(τ1 → τ2) \ fv(∆) ∆.n : ∀α.τ1 → τ2 `D pi : τ ½ eI ;A
∆ `D n@advice around {pc} (x :: tx) = e in pi : τ ½ eI ;
A.(n : ∀α.τ1 → τ2, pc, τx u τ1,Λα. λn:τ1→τ2x : τ1. eIn)
τ1 u τ2 = let S = mgu(τ1, τ2) in Sτ1
Fig. 5. FIL declaration conversion rules
Since most of the conversion rules follow the standard Hindley-Milner style, we
only highlight the distinguished parts here. First, the (Decl:Func) rule converts
top-level functions to let-bound ones having annotated lambda λf :τx : τx.eI ; the
· 13
(
type½) b = fv(t) \ a α = fresh(a) β = fresh(b) a : α.b : β ` t
type½ τ
∀a.p.t type½ ∀α.τ
(Type:Base) V ` Int type½ Int V ` Bool type½ Bool V.a : α ` a type½ α
(Type:Inferred)
V ` t type½ τ
V ` [t] type½ [τ ]
V ` t1
type½ τ1 V ` t2
type½ τ2
V ` t1 → t2
type½ τ1 → τ2
Fig. 7. FIL type conversion rules between AspectFun and FIL
Expressions:
(OS:Value) c ⇓ c λjpx : τx. eI ⇓ λjpx : τx. eI Λα. eI ⇓ Λα. eI
(OS:App)
eI1 ⇓ λjpx : τx. eI3 Trigger(λx : τx. eI3, jp) = λx : τx. eI4 [eI2/x]eI4 ⇓ vI
eI1 e
I
2 ⇓ vI
(OS:Ty-App)
eI1 ⇓ Λα. eI2 [τ/α]eI2 ⇓ vI
eI1{τ} ⇓ vI
(OS:Let)
[eI1/x]e
I
2 ⇓ vI
LET x = eI1 IN eI2 ⇓ vI
Auxiliary Functions:
Trigger : eI × jp→ eI
Trigger(eI , ²) = eI
Trigger(λx : τx. eI , f : τf ) =Weave(λx : τx. eI , τf ,Choose(f, τx))
Weave : eI × τ ×Adv→ eI
Weave(eI , τf , []) = eI
Weave(eIf , τf , a : advs) = Let (n : ∀α. τn, pc, τ,Λα. eI) = a
τ be types such that [τ/α]τn = τf
eIp =Weave(eIf , τf , advs)
eIa = (Λα. e
I){τ}
λn:τnx : τx. eIn = [eIp/proceed]eIa
In Trigger(λx : τx. eIn, n : τn)
Choose(f, τ) = {(ni : ςi, pci, τi, eIi ) | (ni : ςi, pci, τi, eIi ) ∈ A, τi D τ,
∃pc ∈ pci s.t. JPMatch(f, pc)}
JPMatch(f, pc) = (f ≡ pc) ∨ (pc ≡ any) ∨ (pc ≡ any \ [h] ∧ f 6∈ h)
Fig. 8. Operational Semantics for FIL
during function applications, as shown in rule (OS:App). The advice triggering
operation first chooses eligible advices based on argument type, and weaves them
· 15
(nscope : ∀α.[α]→ [α], f, [α], Λα.λnscope:[α]→[α]arg : [α]. proceed (tail arg)),
(n : ∀αβ.α→ β, g, α, Λα.Λβ.λn:α→βarg : α. proceed arg),
(n2nd : ∀αβ.α→ β, n, α, Λα.Λβ.λn2nd:α→βarg : α. proceed arg)
When evaluating the converted program, the application of h {Int} 1 in the
main expression will result in the invocation of g {[Int]} 1, which will then lead
to the weaving of advices n and n2nd. During the evaluation of g’s body, f will
be applied to three different types of arguments: [Int], ([Int], [Int]), and [[Int]].
The advice nscope will be triggered, except for the second one, since the call
Choose(f, ([Int], [Int])) returns an empty set. The case for the application of
(k {Int} 2) is also similar. The notable difference is that, during the evaluation of
the three function calls to f, only the last one of f {[Int]} will trigger the advice
nscope. Finally, the result of executing the FIL program is
(([], ([1], [1]), []), (2, (2, 2), []))
4. STATIC WEAVING
In our compilation model, aspects are woven statically (Step 5 in Figure 2). Specif-
ically, we present in this section a type inference system which guarantees type
safety and, at the same time, weaves the aspects through a type-directed trans-
lation. Note that, for composite pointcuts such as f+cflowbelow(g), our static
weaving system simply ignores the control-flow part and only considers the asso-
ciated primitive pointcuts (ie., f). Treatment of control-flow based pointcuts is
presented in Section 6.
4.1 Type directed weaving
As introduced in Section 2, advised type denoted as ρ is used to capture function
names and their types that may be required for advice resolution. We further
illustrate this concept with our tracing example given in Section 1.
For instance, function f possesses the advised type ∀a.(h : a → a).a → a, in
which (h : a → a) is called an advice predicate. It signifies that the execution of
any application of f may require triggering of those advices on h whose types can
be instantiated to t′ → t′, where t′ is an instantiation of type variable a.
The notion of more general is formally defined as:
Definition 1 We say a type t is more general than or equivalent to a type t′, if
t D t′. When t D t′ but t 6≡ t′, we say t is more general than t′. Similarly, we say
a type t is more specific than a type t′ if t′ D t and t 6≡ t′.
Note that advised types are used to indicate the existence of some advices inde-
terminable at compile time. If a function contains only applications whose advices
are completely determined, then the function will not be associated with an advised
type; it will be associated with a normal (and possibly polymorphic) type. As an
example, the type of the advised function h in Example 1 is ∀a.a→ a since it does
not contain any application of advised functions in its definition.
We begin with the following set of auxiliary functions that assists type inference:
(Gen) is a generalization procedure turning a type into a type scheme by quanti-
· 17
Expressions:
(Var)
x : ∀a¯.p¯.t; e ∈ Γ
Γ ` x : [t¯/a¯]p¯.t; e (Var-A)
x :∗ ∀a¯.p¯.tx ∈ Γ t′ = [t¯/a¯]tx
wv(x : t′) Γ ` ni : t′ ; ei |y¯| = |p¯|
n¯ : ∀b¯.q¯.tn ./ x; n¯ ∈ Γ {ni | ti D t′}
Γ ` x : [t¯/a¯]p¯.tx ; λy¯.〈x y¯ , {ei}〉
(App)
Γ ` e1 : t1 → t2 ; e′1
Γ ` e2 : t1 ; e′2
Γ ` e1 e2 : t2 ; (e′1 e′2)
(Abs)
Γ.x : t1 ; x ` e : t2 ; e′
Γ ` λx.e : t1 → t2 ; λx.e′
(Let)
Γ ` e1 : ρ; e′1 σ = gen(Γ, ρ) Γ.f : σ ; f ` e2 : t; e′2
Γ ` let f = e1 in e2 : t; let f = e′1 in e′2
(Pred)
x :∗ ∀a¯.p¯.tx ∈ Γ [t¯/a¯]tx D t
Γ.x : t; xt ` e : ρ; e′t
Γ ` e : (x : t).ρ; λxt.e′t
(Rel)
Γ ` e : (x : t).ρ; e′
Γ ` x : t; e′′ x 6= e
Γ ` e : ρ; e′ e′′
Declarations:
(Global)
Γ ` e : ρ; e′ σ = gen(Γ, ρ) Γ.id :(∗) σ ; id ` pi : t; pi′
Γ ` id = e in pi : t; id = e′ in pi′
(Adv)
Γ.proceed : t ` λx.ea : p¯.t; e′a fi : ∀a¯.ti ∈ Γbase
t D [t¯/a¯]ti Γ.n : σ ./ f¯ ; n ` pi : t′ ; pi′ σ = gen(Γ, p¯.t)
Γ ` n@advice around {f¯} (x) = eain pi : t′ ; n = e′a in pi′
(Adv-an)
Γ.proceed : tx → t ` λx.ea : p¯.tx → t; e′a σ = gen(Γ, p¯.tx → t)
fi : ∀a¯.ti → t′i ∈ Γbase S = [t¯/a¯]ti D tx
t D S[t¯/a¯]t′i Γ.n : σ ./ f¯ ; n ` pi : t′ ; pi′
Γ ` n@advice around {f¯} (x :: tx) = eain pi : t′ ; n = e′a in pi′
Fig. 10. Static Typing and Weaving rules
scheme bound to x in the environment. Then we check weavable condition of (x : t′).
If the check succeeds (i.e., x’s input type is more general or equivalent to those of
the advices with unifiable types), x will be chained with the translated forms of
all those advices defined on it, having equivalent or more general types than x has
(the selection is done by {ni|ti D t′}). We coerce all these selected advices to have
non-advised type during their translation Γ ` ni : t′ ; ei. This ensures correct
weaving of nested advices advising the bodies of the selected advices. The detail
will be elaborated in Section 4.4. Finally, the translated expression is normalized
by bringing all the advice abstractions of x outside the chain 〈. . .〉. This ensures
· 19
under the type environment extended with proceed. The advice body is therefore
translated. Note that this translation does not necessarily complete all the chaining
because the weavable condition may not hold. In this case, just like functions, the
advice is parameterized. At the same time, an advised type is assigned to it and
only released when it is chained in rule (Var-A).
After type inference of the advice, we ensure that the advice’s type is more
general than or equivalent to all functions’ in the pointcut. Note that the type
information of all the functions is stored in Γbase. Then, this advice is added to
the environment. It does not appear in the translated program, however, as it is
translated into a function awaiting for participation in advice chaining.
In rule (Adv-An), variable x can only be bound to a value of type tx such
that tx is no more general than the input type of those functions in the pointcut.
This constraint is similar to the subsumption rule used for type annotations which
requires the annotated type to be no more general than the inferred one. For each
function in the pointcut, we match a freshly instantiation of the input type ti to tx
which results in a substitution S. The output type of the advice t is expected to be
more general or equivalent to the type of each functions under the substitution S.
In passing, we note that these two rules can be merged but it makes the rule
rather complicated. Hence we keep them separated. In addition, as all the advices
are of function types, attempts to advise a non-function type expression will be
rejected by the type system.
4.4 Advising Advice Bodies
As mentioned in the previous (sub)section, the rules (Adv) and (Adv-an) make
an attempt to translate advice bodies. However, just like the translation of function
bodies, the local type contexts may not be specific enough to satisfy the weavable
condition. Consider a variant of Example 5, in which the control-flow based point-
cut is removed and a type scope is added for illustration purpose.
n@advice around {f} (arg::Int) = e1 in // fully trusted execution
n1@advice around {w} (arg) = f arg in
f x = e2 in
w x = e3 in
h x y = x y in
h w 1
Here, advice n1 calls f which will then be advised. The goal of our translation
is to enable correct chaining of advices even within some advice body, such as that
of n1. Concretely, when a call to w is chained with advice n1, the body of n1 must
also be advised. Moreover, the choice of advices must be coherent.
At the time when the declaration of n1 is translated, the body of the advice is
translated. An advised type is given to it since the weavable condition wv(f : a→ a)
from the current context is not satisfied.
When the translation attempts to chain an advice in rule (Var-A), the judgment
Γ ` ni : t′ ; ei in the premise forces the advice to have a non-advised type. This
ensures that all the advice abstractions are fully released so that chaining can take
effect.
· 21
when their input parameter is empty. We can capture this pattern using an advice
as follows.
n@advice {reverse, append, mergesort} (arg::[a]) =
\x . if arg == [] then x else (proceed arg) x in
reverse x accum = reverse (tail x) (cons (head x) accum) in
reverse [1,2] []
Here we focus on the reverse function to show our scheme. After the type
inference of advice n and function reverse, we get the following result (we omit
the irrelevant translation part for the moment). We write tr as an abbreviation of
[a]→ [a]→ [a].
Γ = { n : ∀ab.[a]→ b→ b, reverse :∗ ∀a.(reverse : tr).tr}
looping
(Rel)
Γ ` reverse : [Int]→ [Int]→ [Int] ...
(Rel)
Γ ` reverse : [Int]→ [Int]→ [Int] ...
(App)
Γ ` (reverse [1, 2]) : [Int]→ [Int]
(App)
Γ ` (reverse [1, 2] []) : [Int]
The above derivation clearly shows that rule (Rel) will repeatedly apply on the
same judgement when an advised type has a predicate that is the same as the base
type.
Our solution is to break the loop by devising a different releasing rule for recursive
functions which predicate on themselves.
(Rel-F)
Γ ` f : (f : t).ρ; e′ F fresh
Γ ` f : ρ; let F = (e′ F ) in F
Rule (Rel-F) uses a fixed point combinator as the translation result. Note that
it only releases the recursive predicate (f : t). Should there be any predicates of
other functions, rule (Rel) is applied.
As a result, the main expression in the above program is translated to
let F = \y.<reverse y,{n}> F
in F [1,2] []
4.6 Curried Pointcuts
In [Masuhara et al. 2005], Masuhara et al. proposed a technique to simplify a
curried pointcut by iteratively removing the last parameter in it. Unfortunately,
their weaving strategy does not support type-scoped curried pointcuts.
In our approach, we also simplify curried pointcuts into uncurried pointcuts, but
we maintain the type constraints of type-scoped curried advices in the environment.
Furthermore, the special function proceed is redefined locally to effect the currying
of function arguments. Because function calls are not handled syntactically (i.e.,
they are not handled according to their textual appearances), our approach can deal
with type-scoped curried pointcuts straightforwardly: What we need is to introduce
· 23
eM : Expressions containing meta-constructs
addProceed : eM −→ eM
addProceed (n df arg = e1 in e2) = if (n is an advice) then
n df proceed arg = e1
in addProceed(e2)
else n df arg = e1 in addProceed(e2)
addProceed (e) = e
[[·]] : eM −→ Expanded expression
[[x = e1 in e2]] = x = [[e1]] in [[e2]]
[[let x = e1 in e2]] = let x = [[e1]] in [[e2]]
[[λx.e]] = λx.[[e]]
[[e1 e2]] = [[e1]] [[e2]]
[[x]] = x
[[proceed]] = proceed
[[e1 e2]] = [[e1]] [[e2]]
[[〈f e , {}〉]] = [[f e]]
[[〈f e , {ea, eadvs}〉]] = proceedApply(ea, 〈f e , {eadvs}〉)
proceedApply(n e, k) = [[n e k]] if rank(n) = 0
proceedApply(〈n e , {ns}〉, k) = [[〈n e k , {ns}〉]] otherwise
rank(x) =

1 if x ≡ 〈f e , {}〉
1 + maxi rank(eai) if x ≡ 〈f e , {ea}〉
0 otherwise
Fig. 11. Definition of Chain Expansion with proceed Lifting
n arg = proceed arg in
n2nd arg = proceed arg in
f x = x in
g df x = (df x, f (x, x), <f, {nscope}> [x]) in
h x = (\df. <g df, {<n, {n2nd}>}>) <f, {nscope}> [x] in
k df x = (\df. <g df, {<n, {n2nd}>}>) df x in
(h 1, k f 2)
After applying addProceed and chain expansion, the final result is the following
expanded expression:
n proceed arg = proceed arg in
nscope proceed arg = proceed (tail arg) in
n2nd proceed arg = proceed arg in
f x = x in
g df x = (df x, f (x, x), nscope f [x]) in
h x = (\df. n2nd (n (g df))) (nscope f) [x] in
k df x = (\df. n2nd (n (g df))) df x in
(h 1, k f 2)
· 25
go on to prove the closed-equivalence between the whole expanded expression of an
AspectFun program and the whole FIL-converted expression of the same program.
Note that since an expanded expression e′′ is basically an AspectFun expression e
without those advice-related constructs, to avoid notation cluttering, we shall use
e and e′′ interchangeably in the following discussion when the context is clear.
Fig. 12. Relationship between expressions and equivalences
We begin with the definition of the equivalence between closed terms of AspectFun
expressions and FIL expressions. As the operational semantics of AspectFun is
reduction-based, we define the equivalence relation using the proper reduction rules.
Definition 3 (∼∼) A closed expanded expression e is said to be equivalent to a
closed FIL expression eI under an advice store A, written as e ∼∼ eI , if the following
holds:
e 7−→∗β v iff eI ⇓A vI
where vI is not a type abstraction and v ∼∼v vI .
In the above, v ∼∼v vI is defined by:
c ∼∼v c
v ∼∼v λjpx : τ.eI iff ∀e1 ∼∼ eI1, (v e1) ∼∼ ((λjpx : τ.eI) eI1)
when the RHS is well-typed
We shall omit the advice store A when it is obvious from the context.
Next, we extend the equivalence relation to open terms of expanded AspectFun
expressions and FIL expressions. The free variables which may occur in them,
directly or indirectly, are those introduced via top-level bindings, local let-bindings
and lambda-bound parameters.3 They are subjected to static weaving and FIL-
conversion. (However, these have no effect on lambda parameters.) Hence we
3Note that, after static weaving, advice names, indicated by n, may appear as free variables in an
expanded AspectFun expression. In addition, proceed is treated as a lambda parameter.
· 27
Definition 4 (') Let e be an expanded expression typed under environment Γ and
eI an FIL expression to be woven dynamically using the advice store A. We define
an open equivalence between e and eI under Γ and A, written as e ' eI , if for all
ev ∼∼ eIv such that [eIv/y]eI is well-typed, then
[ev/y][Body′(x)/x]e ∼∼ [eIv/y][BodyI(x)/x]eI under A
where
Body′(x) =
{
[[Body(x)]] if x is not an advice
[[λdp.λproceed.λz.body(x)]] if x is an advice
We shall omit Γ and A when they are obvious from the context.
As an example of the open equivalence relation, consider the definition of g in
Example 6 (Section 3.3): g x = (f x, f(x, x), f [x]). In particular, we focus
on the part in which function f is applied to a list argument [x]. As described
in Section 4.7, after static weaving, this occurrence of function f is woven with
advice nscope as <f, {nscope}> and is subsequently expanded to nscope f. By
contrast, on the FIL side, it will be converted to f {[α]}. Then, according to the
definition of open equivalence, we apply the body substitutions to (nscope f)
and (f {[α]}), and get \arg.((\x.x)(tail arg)) and λ xf:[α]→[α] : [α].x, re-
spectively. Clearly, when the substituted FIL expression is invoked with an ar-
gument of type [α], the advice nscope will be triggered and executed. Hence,
\arg.((\x.x)(tail arg))) ∼∼ λxf:[α]→[α] : [α].x. It then follows that (nscope f) '
f {[α]}.
Note that FIL expressions do not contain advice; advices only take effect when
advised functions are invoked. Hence, the open equivalence relation above does
not consider the case when eI involves advice. However, due to nested advice and
second-order advice, static weaving will treat such advices as advised functions
and transform any occurrence of such advice into an intermediate expression that
should be related to its corresponding FIL expression, which is simply advice with
type application.4 Hence we need to enhance the definition of open equivalence
to handle the cases when the FIL expression under equivalence test is an advice
expression.
As an example, consider the function k in Example 6 (Section 3.3): k x = g
x. After static weaving, the function g inside k is translated to \df.<g df, {<n,
{n2nd}>}> and then expanded to \df.(n2nd n (g df)) In other words, the invo-
cation of g will trigger advice n, which in turn will trigger the second-order advice
n2nd. Here, although (n2nd n) is not a complete expanded expression, we still
need to relate it to its FIL-corresponding part: n{α}, which, when applied, will also
trigger advice n2nd.
To handle such intermediate expressions produced by static weaving in the pres-
ence of second-order advices, the definition of open equivalence needs to consider
the case when eI ≡ n{τ}. Specifically, the definition of Body′(x) is extended to:
Body′(x) =
{
[[Body(x)]] if x is not an advice or x ≡ n
[[λdp.λproceed.λz.body(x)]] if x is an advice and x 6≡ n
4Recall the premise Γ ` ni : t′ ; ei in the (Var-A) rule of static weaving.
· 29
Next, we define the conditional form of equivalence, called respect of expressions,
based on the definition of feasibility and the ' relation. It specifies that an As-
pectFun expression with advice predicates respects a corresponding FIL expression
under a type-constrained context if they are equivalent (') after the advice predi-
cates involved are properly realized by feasible expressions.
Definition 7 (Respect of Expressions) Given an AspectFun program pi, let e
be an expression of pi and A be the advice store derived from pi. Suppose that
Γ ` e : p.t ; e′, fv(p¯) ⊆ fv(t), and the environment Γ contains the set of predi-
cates (g : tg ; dg) introduced via the (Pred) rule. We say that e′ respects an FIL
expression, eI , under the pair of types (p.t, τ), written as (p.t, τ) ` e′ ∝ eI , if for all
type substitutions S, S′, and expressions ep, eg, such that ep m Sp, eg m S(g : tg),
and St
type½ S′τ , then [[[eg/dg]e′ ep]] ' (S′eI) under Γ and A holds.
Now we can define the mutual agreement between the binding definitions in the
static weaving environment and those in the FIL-environment and the advice store.
It is specified in terms of the “respect of expression” relation for each form of binding
declarations which may occur in an AspectFun program, such as global functions,
global advices, and local functions.
Definition 8 (Respect of Bindings) Given an AspectFun program pi, bindings
derived from pi in a static weaving environment Γ is said to respect those in an
FIL-converting environment, ∆, and an advice store, A, written as Γ
pi
∝ (∆,A), if
(1 ) Γ ∝ (∆,A),
(2 ) for all x : ∀a.p.t ; x ∈ Γ introduced via (Global) as a global variable and
x : ∀α.τx ∈ ∆, we have (p.t, τx) ` Body(x) ∝ bodyI(x),
(3 ) for all g : ∀a.p.t ; g ∈ Γ introduced via (Global) as a global function and
g : ∀α.τx → τg ∈ ∆, we have (p.t, τx → τg) ` Body(g) ∝ λx : τx.bodyI(g),
(4 ) for all advice n : ∀a.p.t ./ f ∈ Γ and (n : ∀α.τx → τn, pc, τx,BodyI(n)) ∈ A,
we have (p.t, τx → τn) ` Body(n) ∝ λx : τx.bodyI(n),
(5 ) for all x : ∀a.p.t ; x ∈ Γ introduced via (Let) and x : σx ∈ ∆, we have
(p.t, τx) ` Body(x) ∝ bodyI(x),
(6 ) there are no constraints on those bindings introduced via (Abs) or (Pred).
Based on the above definitions, we can proceed to develop the intermediate results
that will lead the the correctness of static weaving. The first result is that there
is a direct correspondence between the static weaving derivations and the FIL-
conversions. In particular, the types derived in the two systems follow the type
conversion defined in Section 3. Indeed, ignoring the code emitting part, the FIL
conversion rules listed in figures 5 and 6 are simply a conservative extension of the
Hindley-Milner type inference rules with explicit type abstraction and application.
We present the result as two theorems. The first theorem concerns the corre-
spondence of expression types in two systems under proper program environments.
· 31
fv(p¯) ⊆ fv(t), and (t,Sτf ) ` ei ∝ AdviceName(ei){AdviceUnifiers(ei,Sτf )}, then
(p.t,Sτf ) ` λdp.〈f dp , {e}〉 ∝ f{τ} where S = [τ/α] and t
type½ Sτf .
The following theorem shows that, given an AspectFun program pi with respectful
binding environments, any expressions of pi transformed by static weaving will also
respect the corresponding FIL-converted expressions.
Theorem 3 (Soundness of Expression Weaving) If Γ
pi
∝ (∆,A), Γ ` e : p.t;
e′, and fv(p) ⊆ fv(t), then there exists an eI such that ∆ ` e : τ ½ eI and
(p.t, τ) ` e′ ∝ eI
Finally, the correctness of our static weaving scheme is established by the follow-
ing theorem.
Theorem 4 (Soundness of Static Weaving) Let pi0 be an AspectFun program.
If ∅ ` pi0 : t ; e′, then there exists an FIL-converted program, piI = (A, eI), such
that pi0
prog½ piI and [[e′]] ∼∼ eI .
6. COMPILING CONTROL-FLOW BASED POINTCUTS
In this section, we present our compilation model for composite pointcuts – control-
flow based pointcuts. Despite the fact that control-flow information are only avail-
able fully during run-time, we strive to discover as much information as possible
during compilation. In particular, we transform type scopes within such pointcuts
and then compile these type scopes away using our static type-directed weaver.
When a pointcut designator depends on the dynamic state of the join point, we
insert a dynamic test to capture such dependency. These dynamic tests are imple-
mented in a state-based fashion without the need to maintain call stacks, and is
similar to that used in AspectJ as well as that used by Masuhara et al. [Masuhara
et al. 2003]. We also consider the strategy to eliminate such tests at compile time.
Our compilation process for composite pointcuts thus involves three steps:
(1) Pre-processing source code to eliminate uses of a variant of control flow keyword
– cflow– and type-scoped control flow (eg. cflow(f( :: Int))).
(2) Installing state-based mechanism in woven code, including insertion of dynamic
tests.
(3) Analyzing and optimizing woven code produced at step (2) to compile away as
many dynamic tests as possible.
After presenting the formal semantics of control-flow based pointcut, we shall
describe these steps in more detail in the rest of this section.
6.1 Semantics of control-flow based pointcut
The semantics of control-flow based pointcut is defined by modifying the opera-
tional semantics for FIL introduced in section 2. The modification is so small that
existing conditions or proofs based on the new definitions are all valid with minor
modification.
First, We modify the reduction-based big-step operational semantics function ⇓A
to carry a stack S, written as ⇓SA, denoting that the progress is done under stack
· 33
Trigger′ : eI × jp× stack→ eI
Trigger′(eI , ²,S) = eI
Trigger′(λf :τf x : τx. eI , f : τf ,S) =Weave′(λf :τf x : τx. eI , τf ,S,Choose′(f, τx,S))
Weave′ : eI × τ × stack×Adv→ eI
Weave′(eI , τf ,S, []) = eI
Weave′(eIf , τf ,S, a : advs) = Let (n : ∀α. τn, pc, τ,Λα. eI) = a
In If ¬(τn D τf ) Then Weave(eIf , τf , advs)
Else Let τ be types such that [τ/α]τn = τf
(eIp, e
I
a) = (Weave
′(eIf , τf ,S, advs), (Λα. eI){τ})
λn:τnx : τx. e
I
n = [e
I
p/proceed]e
I
a
In Trigger′(λnx : τx. eIn, n : τn,S)
Choose′(f, τ,S) = {(ni : ςi, pci, τi, eIi ) | (ni : ςi, pci, τi, eIi ) ∈ A, τi D τ,
∃pc ∈ pci s.t. JPMatch′(f, pc,S)}
JPMatch′(f, pc+ cflowbelow(g),S) = JPMatch′(f, pc,S) ∧ g ∈ S
JPMatch′(f, pc− cflowbelow(g),S) = JPMatch′(f, pc,S) ∧ g 6∈ S
JPMatch′(f, pc,S) = JPMatch(f, pc)
6.2 De-sugaring
This step aims to transform source programs into ones that are amenable to static
type inference and weaving. Specifically, type-scoped control flow (eg. cflow(f(
:: Int))) and cflow can be considered as syntactic sugar in our source language.
They are therefore translated away before we conduct static analysis on the source
code.
Type-scoped control-flow based pointcuts can be replaced by ones without type
scopes. For instance,
n@advice around {k + cflow(f(_::Int))} (arg) = ...
is translated into
n’@advice around {f} (arg :: Int) = proceed arg in
n@advice around {k + cflow(n’)} (arg) = ...
Note that, with the help of second-order advice, cflow(f( ::Int)) has been trans-
lated into cflow(n’), where n’ is a newly defined type-scoped advice on f which
simply passes the argument to proceed. As a language design decision, we only
allow the introduction of advice name as argument to cflow as part of compiler
internal; it is not part of the source language.
In addition, we translate all cflow-pointcuts into pointcuts involving cflowbelow.
Doing so reduces the number of cases to be considered during compilation. The
rules for cflow translation are listed below. They are applied repetitively on point-
cuts until there is no more change. The notation +o refers to other pointcuts which
· 35
g x = enter "g";
<k, {n}> x;
restore_state
Here, enter records into the global state the entry into function g, and restore state
erases this record from the global state.
Next, uses of cflowbelow advices appear in various chain expressions; eg., <k,{n}>
occurs in two places in Example 7. For these uses, we insert code to perform lookups
for the presence of the respective pointcuts in the global state. The encoding is a
form of guarded expression denoted by <| guard, n |>. Semantically, the advice n
will be executed only if guard evaluates to True. The translated (pseudo) code for
Example 7 is as follows:
Example 7a
// meta-data: IFAdvice [k+cflowbelow(g)] (n,...)
n proceed arg = arg+123 in
k x = x + 1 in
g x = enter "g";
<k, { <| isIn "g", n|> } > x;
restore_state in
f x = if x == 0 then g x
else <k, { <| isIn "g", n |> } > x in
(f 0, f 1)
The guard (isIn "g") determines if g has been invoked and not yet returned. If
so, advice n is executed. In this case, n is not triggered when evaluating f 1, but
it is when evaluating f 0.
6.4 Control-Flow Pointcut Analysis and Optimization
From Example 7a, we note that the guard occurring in the definition of g is always
true, and can thus be eliminated. Similarly, the guard occurring in the definition
of f is always false, and the associated advice n can be removed from the code.
Indeed, many of such guards can be eliminated during compile time, thus speeding
up the execution of the woven code.
We share the sentiment with Avgustino et al. [Avgustinov et al. 2005] that such
optimization and its associated analysis can be more effectively performed on the
woven code. In our system, we employ two interprocedural analyses to determine
the opportunity for optimizing guarded expressions. These are mayCflow and
mustCflow analysis (cf. [Avgustinov et al. 2005]).
Since the subject language is polymorphically typed and higher-order, we adopt
an annotated-type and effect system for our analyses. This approach has been
described in detail in [Nielson et al. 1999]. Judgments for both mayCflow and
mustCflow analyses are of the form
Γˆ ` e : τˆ1 ϕ
′
−→τˆ2 & ϕ
For mayCflow analysis (resp. mustCflow analysis), this means that under an
annotated-type environment Γˆ, an expression e has an annotated type τˆ1
ϕ′−→τˆ2 and
· 37
(Const) Γˆ `may c : τˆc & ϕ (Var) Γˆ `may x : Γ(x) & ϕ
(Lambda)
Γˆ.x : τˆx `may e : τˆe & ϕ
Γˆ `may λx.e : τˆx ϕ
′
−→τˆe & ϕ
(App)
Γˆ `may e1 : τˆ2 ϕF−→τˆ & ϕ ¬guarded(e1)
Γˆ `may e2 : τˆ2 & ϕ ϕ ⊆ ϕF
Γˆ `may (e1 e2) : τˆ & ϕ
(Let)
Γˆ.x : τˆ1 `may e1 : τˆ1 & ϕ
Γˆ.x : τˆ1 `may e2 : τˆ & ϕ
Γˆ `may let x = e1 in e2 : τˆ & ϕ
(If)
Γˆ `may e1 : Bool & ϕ
Γˆ `may e2 : τˆ & ϕ Γˆ `may e3 : τˆ & ϕ
Γˆ `may if e1 then e2 else e3 : τˆ & ϕ
(Decl)
Γˆ.(f : τˆx
ϕF−→τˆ ′).(x : τˆx) `may ef : τˆ ′ & ϕF ∪ {f}
Γˆ.(f : τˆx
ϕF−→τˆ ′) `may p : τˆ & ∅
Γˆ `may f x = ef in p : τˆ & ∅
(Gd-app)
Γˆ `may e1 : Bool & ϕ Γˆ `may e3 : τˆ & ϕ Γˆ `may (e2 e3) : τˆ & ϕ
Γˆ `may <|e1, e2|> e3 : τˆ & ϕ
(Chain)
Γˆ `may [[〈e , {e1, . . . , en}〉]] : τˆ & ϕ
Γˆ `may 〈e , {e1, . . . , en}〉 : τˆ & ϕ
(Subs)
Γˆ `may e : τˆ & ϕ
Γˆ `may e : τˆ ′ & ϕ
if τˆ ≤ τˆ ′
(Subt1)
τˆ ′1 ≤ τˆ1 τˆ2 ≤ τˆ ′2 ϕ′ ⊆ ϕ
τˆ1
ϕ−→τˆ2 ≤ τˆ ′1 ϕ
′
−→τˆ ′2
(Subt2) τˆ ≤ τˆ
Fig. 13. mayCflow inference rules
Applying the analysis over the woven code given in Example 7a, we obtain the
following contexts for the body of each of the functions:
ϕ
may
k = {f, g} May-context for body of k
ϕmayg = {f} May-context for body of g
ϕmayf = ∅ May-context for body of f
Since the type-and-effect system formustCflow analysis is similar to that formay-
Cflow analysis, we omit the detail in this paper, but simply point out the resulting
contexts produced by performing mustCflow analysis over the same example:
ϕmustk = ∅ Must-context for body of k
ϕmustg = {f} Must-context for body of g
ϕmustf = ∅ Must-context for body of f
· 39
f is not in the context when the call to g is invoked; this results in the full removal
of the associated advice. The final code is thus:
n proceed arg = proceed (arg + 1) in
f x = enter "f"; x 1 ;
restore_state in
g y = y 2 in
k z = z * 2 in
(f <k,{n}>, g <k,{}>)
7. RELATED WORK
7.1 Aspect-Oriented Languages
Recently, researchers in functional languages have started to study various issues of
adding aspects to strongly typed functional languages. Two notable works in this
area, AspectML [Dantas et al. 2007; 2005] and Aspectual Caml [Masuhara et al.
2005], have made many significant results in supporting polymorphic pointcuts
and advices in strongly typed functional languages such as ML. While these works
have introduced some expressive aspect mechanisms into the underlying functional
languages, they have not successfully reconciled coherent and static weaving – two
essential features of a compiler for an aspect-oriented functional language.
AspectML [Dantas et al. 2007; 2005] advocates first-class join points for con-
structing generic aspect libraries. In order to support non-parametric polymorphic
advice, AspectML includes case-advices which are subsumed by our type-scoped
advices. Its type system is a conservative extension to the Hindley-Milner type
inference algorithm with a form of local type inference based on some required
annotations. During execution, advices are looked-up through the labels and run-
time type analysis is performed to handle the matching of type-scoped pointcuts.
This completely dynamic mechanism gives additional expressiveness by allowing
run-time advice introduction. However, many optimization opportunities are lost
as advice application information is not present during compilation. Lastly, ad-
vices are anonymous in AspectML and apparently not intended to be the targets
of advising, i.e. no second-order advices.
Aspectual Caml [Masuhara et al. 2005], on the other hand, carries out type
inference on advices without consulting the types of the functions designated by
the pointcuts. Similar to AspectML, it allows a restricted form of type-scoped
advices. Static weaving is achieved by traversing type-annotated base program
ASTs to insert advices at matched joint points. The types of the applied advices
must be more general than those of the joint points, through which, type safety
is guaranteed. This design has the advantage of clean separate compilation as
aspects can be compiled completely independently from the base program. In our
case, we value correctness and understandability of program more than the ease of
compilation.
Aspectual Caml’s lexical approach also makes it easy to advise anonymous func-
tions. However, for polymorphic functions invoked indirectly through aliases or
functional arguments, this approach cannot achieve coherent weaving results. It is
also not clear how to extend the lexical weaving scheme to handle nested advices,
second-order advices or control flow based pointcuts such as cflow.
· 41
8. CONCLUSION
Static typing, static and coherent weaving are our main concerns in constructing a
compilation model for functional languages with higher-order functions and para-
metric polymorphism. This paper consolidates our previous research results [Wang
et al. 2006b; 2006a; Chen et al. 2007], and makes several significant revisions and ex-
tensions to multiple dimensions of our research. Not only do we provide a complete
treatment to several advanced features in AspectFun, we also present the compila-
tion process in full detail. Above all, we provide a formal account of the correctness
of our static typing and weaving rules with respect to the operational semantics of
AspectFun.
Moving ahead, we intend to continue this line of investigation in a few directions.
Currently, the type system bans mutual recursion and circular around advice ex-
ecution. It will be interesting to see how these limitations can be removed. Since
one of the major advantages of static weaving is the ease of static analysis and op-
timization, we will also investigate additional optimization techniques and conduct
empirical experiments of performance gain.
We also would like to investigate the use of aspects to capture side-effecting
computation for AspectFun. This is particularly promising, as our compilation
model automatically converts the base program to monadic form.
On another frontier, we plan to explore the possibility of applying our static
weaving system to other language paradigms. Java 1.5 has been extend with para-
metric polymorphism by the introduction of generics. The following example is
taken from [Jagadeesan et al. 2006]
class List<T extends Comparable<T>> {
T[] contents; ...
List<T> max(List<T> x) {
// general code for general types
} }
This class implements a list with a method max. When the input is an Boolean list,
we may want to use bit operations for a more efficient implementation. This can
be done with a type-scoped aspect.
aspect BooleanMax {
List<Boolean> around(List<Boolean> x): args(x) &&
execution(List<Boolean> List<Boolean>.max(List<Boolean>)) {
// special code for boolean arguments
} }
However, as mentioned in [Jagadeesan et al. 2006], the above aspect cannot be
handled by their aspect language because the type-erasure semantics of Java pro-
hibits any dynamic type test to be performed. We speculate that our type-directed
weaving could be a key to the solution of the problem.
9. ACKNOWLEDGMENT
This research is partially supported by the National University of Singapore under
research grant “R-252-000-252-112”, and by the National Science Council, Taiwan,
R.O.C. under grant number “NSC 95-2221-E-004-004-MY2”.
· 43
Washburn, G. and Weirich, S. 2006. Good advice for type-directed programming. InWorkshop
on Generic Programming 2006. ACM Press.
A. PROOF OF CORRECTNESS OF STATIC WEAVING
In this appendix, we detail the proof of the correctness of static weaving. After
presenting a few straightforward propositions, we shall prove the key lemmas and
theorems stated in Section 5. Note that, as in the main text, e is used to stand
for both an AspectFun source expression and an expanded expression, eI for an FIL
expression, and e′ for an intermediate expression produced by static weaving.
We begin by listing down some properties about FIL conversion and basic prop-
erties about open and close equivalence.
Proposition 1 If ∀a.p.t type½ ∀α.τ , then ∀S, ∃S′ such that St type½ S′τ
Proposition 2 Given an expanded expression e and an FIL annotated lambda ex-
pression λf :τfx : τx.eI , if e ∼∼ Trigger(λx : τx.eI , f : τf ), then e ∼∼ λf :τfx : τx.eI .
Proposition 2a Given an expanded expression e and an FIL annotated lambda
expression λf :τfx : τx.eI , if e ' Trigger(λx : τx.eI , f : τf ), then e ' λf :τfx : τx.eI .
Proposition 3 Suppose Γ
pi
∝ (∆,A). If x is a non-lambda-bound identifier in Γ,
then
e ' eIunder Γ and A ⇔ [Body′(x)/x]e ' [BodyI(x)/x]eIunder Γx and A
where Body′(x) is the same as the one defined in Definition 4 and Γx is Γ with the
binding of x removed.
Proposition 4 If e1 ' eI1 then [e1/proceed]e ' [eI1/proceed]eI ⇔ e ' eI .
Theorem 1 (Correspondence of Expression Types) If Γ ∝ (∆,A) and Γ `
e : ρ ; e′, then there exists a corresponding FIL-conversion ∆ ` e : τ ½ eI such
that ρ
type½ τ .
Proof. By induction on the height of the derivation tree for Γ ` e : ρ; e′.
Theorem 2 (Correspondence of Program Types) If ` pi : t; e′, then there
is an FIL-conversion ∅ `D pi : τ ½ eI ;A such that t
type½ τ
Proof. This can be proved by induction on the length of declarations in pi using
a stronger hypothesis which is detailed in the proof of Theorem 4.
Lemma 1 (Advice Selection) If Γ ∝ (∆,A) and Γ ` e0 : p.t; λdp.〈f dp , {e}〉,
then
(1 ) there exist some types τ1, τ2 and τ such that ∆ ` e0 : τ1 → τ2 ½ f{τ}
(2 ) for any type substitutions S and S’ that satisfy St
type½ S′(τ1 → τ2), we have
AdviceSet(λdp.〈f dp , {e}〉) = Names(Choose(f,S′τ1)) where Names(s) = {n |
(n : ςn, · · · ) ∈ s}.
· 45
where t′1 = S1tk. Let ∀a.p.tf1 → tf2 = Γ(f). Consider the kinds of advice
binding for nk.
(i) (Adv): By the condition of (Adv), tk → tnk D tf1 → tf2 , which in
turn implies that tnk D t′2 since tf1 → tf2 D St. This contradicts the
assumption.
(ii) (Adv-An): By the condition of (Adv-An), there exists a substitution
S0 such that
tk = S0tf1 (1)
and tnk D S0tf2 (2)
Then t′1 = S1S0tf1 . Now, since tf1 → tf2 D t′1 → t′2, there exists a
substitution S2 such that t′2 = S2S1S0tf2 . Hence by (2),
S1tnk D S1S0tf2 D S2S1S0tf2 = t′2
This contradicts the assumption.
Since no such advice exists, we conclude that Cset ⊆ Aset.
Lemma 2 (Respect of Chain Expressions ) Suppose that Γ
pi
∝ (∆,A). Let f
be an advised function or advice that ∆(f) = ∀α.τf . If Γ ` f : p.t; λdp.〈f dp , {e}〉,
fv(p¯) ⊆ fv(t), and (t,Sτf ) ` ei ∝ AdviceName(ei) {AdviceUnifiers(ei, Sτf )} for all
ei ∈ e, then (p.t, Sτf ) ` λdp.〈f dp , {e}〉 ∝ f{τ} where S = [τ/α] and t
type½ Sτf .
Proof. Let ∀a.pf .tf = Γ(f) and S0tf = t. Then, by Γ ∝ (∆,A) and Proposition
1, such S exists.
Next, we proceed to prove the lemma according to the requirements stated in
Definition 7 (respect of expressions). Specifically, given S, S′, ep, and eg such that
St
type½ S′Sτf , ep m Sp and eg m S(g : tg ; dg) as in Definition 7, we need to prove
that
[eg/dg][[(λdp.〈f dp , {e}〉) ep]] ' S′(f{τ})
By Proposition 3 and definition of BodyI(f), it is equivalent to show that
[[[Body(f)]]/f ][eg/dg][[(λdp.〈f dp , {e}〉) ep]] ' S′S(λf :τfx : τx.bodyI(f))
Let S′′ = S′ ◦ S. By applying Proposition 2a on the RHS, it suffices to show that
[[[Body(f)]]/f ][eg/dg][[(λdp.〈f dp , {e}〉) ep]] ' Trigger(λx : S′′τx.S′′(bodyI(f)), f : S′′τf )
By the definition of Trigger(·), we can rewrite the RHS of the above equation to
Weave(λx : S′′τx.S′′(bodyI(f)),S′′τf ,Choose(f, S′′τx))
According to Lemma 1, AdviceSet(λdp.〈f dp , {e}〉) = Names(Choose(f,S′′τx)).
Thus, it suffices to show that
[[[Body(f)]]/f ][eg/dg][[(λdp.〈f dp , {e}〉) ep]] '
Weave(λx : S′′τx.S′′(bodyI(f)), S′′τf , {A(ni) | ni ← AdviceSet(ec)}) (3)
· 47
Thus, we need to show that
[eg/dg][[[〈Body(f) ep , {e2, · · · , em}〉]]/proceed][[(λy.[e1′/dq]body(n1))]]
' [eIp/proceed](λy : τy.[τ1/β]bodyI(n1))
By the induction hypothesis for the length (|e| = m− 1):
[eg/dg][[〈Body(f) ep , {e2, · · · , em}〉]] ' eIp
Hence, by Proposition 4, we in turns need to show that
[eg/dg]([[(λy.[e1′/dq]body(n1))]] ' λy : τy.[τ1/β]bodyI(n1) (∗)
Finally, by the assumption of the Lemma,
(t,Sτf ) ` (n1 e1′) ∝ n1 {AdviceUnifiers(e1, Sτf )}
Hence, given St
type½ S′Sτf , by Proposition 3 and Definition 7, we have
[eg/dg]([[Body′(n1) e1′]]) ' BodyI(n1) {τ1}
Note that, since the above respect assumption holds with no advice predicates,
if there are any advice parameters in e1′, they must belong to dg. Then, by the
enhanced definition of Body′(x) and rank(e1) = 0, we have
[eg/dg][[(λy.[e1′/dq]body(n1))]] ' (λy : τy.[τ1/β]bodyI(n1))
Thus the open equivalence to show (*) holds. This concludes the case for rank(ec) =
1.
Induction step for the rank (rank(ec)):
Suppose that the equivalence (3) holds for all ec with rank(ec) < r. When
rank(ec) = r, we do induction on the length of |e|.
If |e| = 0, then ec actually has rank one, and the equivalence holds by the
induction base. Suppose it holds for |e| = m− 1.
Now consider the case |e| = m. Let e = e1, e2, · · · , em. If rank(e1) = 0, then the
proof is the same as the one for the case of rank(ec) = 1. Otherwise, assume that
0 < rank(e1) < r, and let e1 = (λdr.〈n1 dr , {en}〉) e′. Consider the open equation
3 that we need to prove:
LHS = [eg/dg][[[Body(f)]]/f ][[(λdp.〈f dp , {e1, e2, · · · , em}〉) ep]]
= [eg/dg][[[Body(f)]]/f ](λdp.proceedApply(e1, 〈f dp , {e2, · · · , em}〉)) ep
= [eg/dg][[[Body(f)]]/f ](λdp.[[〈n1 e′ 〈f dp , {e2, · · · , em}〉 , {en}〉]]) ep
= [eg/dg][[[Body(f)]]/f ]
(λdp.[[〈(λdq.λproceed.λy.body(n1)) e′ 〈f dp , {e2, · · · , em}〉 , {en}〉]]) ep
= [eg/dg][[〈(λdq.λproceed.λy.body(n1)) e′ 〈Body(f) ep , {e2, · · · , em}〉 , {en}〉]]
→∗β [eg/dg][[〈[[[〈Body(f) ep , {e2, · · · , em}〉]]/proceed](λy.[e′/dq]body(n1)) , {en}〉]]
· 49
case (Pred) :
In this case, x is advised and x :∗ ∀a¯.p¯x.tx ∈ Γ, p is empty, t = [t¯/a¯]tx, and
e′ ≡ xt, a variable. Moreover, If ∆(x) = ∀α. τx, then, by Γ ∝ (∆,A) and
Proposition 1, there are types τ that t
type½ [τ/α]τx. Hence, by (Expr:Ty-App),
τ = [τ/α]τx and eI ≡ x{τ}. We need to prove that (t, τ) ` xt ∝ x{τ}.
According to Definition 7, given S, S′, with St
type½ S′τ and eg feasible to S(g : tg),
we must show that [eg/dg]e′ ' S′x{τ}. Obviously, x belongs to g and thus xt
belongs to dg. Hence there is an ex ∈ eg such that ex m S(x : t). Therefore,
[eg/dg]e′ = ex ' S′(x{τ}) by the definition of feasibility. Consequently, (t, τ) `
e′ ∝ eI .
case (Global), (Let), (Adv), (Adv-an) :
In all these cases, e′ ≡ x and p.t is an generic instance of σ(≡ ∀a¯.p¯x.tx),
p.t = [t¯/a¯]p¯x.tx. If ∆(x) = ∀α. τx, then, by Γ ∝ (∆,A), Proposition 1 and
(Expr:Ty-App), τ = [τ/α]τx, eI ≡ x{τ}, and t
type½ τ . We need to prove that
(p.t, τ) ` x ∝ x{τ}.
According to Definition 7, given S, S′, ep, and eg with (S ◦ [t¯/a¯])tx
type½ (S′ ◦
[τ/α])τx, we need to show that
[eg/dg]x ep ' (S′x{τ})
By proposition 3, it suffices to show that
[eg/dg][[Body′(x)]] ep ' S′(BodyI(x){τ}) (6)
We show it on a case by case basis.
subcase Global variable, (Let) :
Here Body′(x) = Body(x) and BodyI(x){τ} = [τ/α]bodyI(x). Besides, (S ◦
[t¯/a¯])tx
type½ (S′ ◦ [τ/α])τx. By Γ
pi
∝ (∆,A), (p¯x.tx, τx) ` Body(x) ∝ bodyI(x).
Hence the open equation (6) follows by applying to this respect condition with
S ◦ [t¯/a¯], S′ ◦ [τ/α], ep, and eg, according to Definition 7.
subcase Global function :
Let S′′ = S′◦[τ/α] and we can rewrite the RHS of (6) as S′′(λx:τxy : τy.bodyI(x)).
By proposition 2a, the open equation (6) can be verified by proving:
[eg/dg][[Body(x)]] ep ' Trigger(S′′(λy : τy.bodyI(x)), x : S′′τx)
= Weave(S′′(λy : τy.bodyI(x)), S′′τx,Choose(x, S′′τx))
= Weave(S′′(λy : τy.bodyI(x)), S′′τx, {}) (7)
= S′′(λy : τy.bodyI(x)) (8)
Equality (7) holds because any x’s typed by the (Var) rule is not advised (i.e.,
Choose(x, S′′τx)) = {}). Moreover, by Γ
pi
∝ (∆,A), (p¯x.tx, τx) ` Body(x) ∝
λy : τy.body(x). Similar to the previous case, equality (8) follows by applying
to this respect condition with S ◦ [t¯/a¯], S′′, ep, and eg, according to definition
7.
· 51
Moreover, let τ be τ1 and eI be eI1, then we need to show that (ρ, τ) ` e′1e′2 ∝ eI .
In other words, given S, S′, ep, and eg with St = S′τ as in Definition 7,
[[[eg/dg](e′1e
′
2) ep]] ' S′eI
Let ∀α.τx = ∆(x), then, by the induction hypothesis on the second derivation,
we get (t1, τ ′x) ` e′2 ∝ x{τ} where τ ′x = [τ/α]τx and t1
type½ τ ′x. By Definition 7 and
a reasoning similar to the previous case, it suffices to show that e′2 m S(x : t1).
Now, since (t1, τ ′x) ` e′2 ∝ x{τ}, we have [[[eg/dg]e′2]] ' S′x{τ}, which proves that
e′2 m S(x : t1).
case (Var-A) :
In this case, xmust be an advised function or advice. We can prove it by applying
Lemma 2 as follows.
Let ∀a¯.p¯x.tx = Γ(x) and ∀α.τx = ∆(x). Then, p = [t¯/a¯]px and t = [t¯/a¯]tx.
eI ≡ x{τ}. By Γ ∝ (∆,A) and Proposition 1, there exists an S = [τ/α] such
that t
type½ Sτx, as required by Lemma 2.
Finally, from the premise of the rule, we have Γ ` ni : t; ei. By the induction
hypotheses of these sub-derivations, there exist eIi such that ∆ ` ni : τ ½ eIi
and (t,Sτx) ` ei ∝ eIi . Moreover, let ∀βi.τni = ∆(ni). Then, by Theorem 1,
t
type½ [AdviceUnifiers(ei, Sτx)/βi]τni . Hence, by (Expr:Ty-App) it is obvious
that (ni {AdviceUnifiers(ei, Sτx)}) are such eIi . This case then follows directly
from Lemma 2.
case (Let) We have a derivation of the form:
Γ ` e1 : ρ; e′1 σ = gen(Γ, ρ) Γ.f : σ ; f ` e2 : t; e′2
Γ ` let f = e1 in e2 : t; let f = e′1 in e′2
Here e′ ≡ let f = e′1 in e′2 and f can be either a variable or a function. We present
only the proof for the case of variable since the case of function is similar.
Suppose ρ ≡ q.t′. By the induction hypothesis of the first sub-derivation, there
is an τf and eIf such that ∆ ` e : τ ½ eI , t′
type½ τf” and (ρ, τf ) ` e′1 ∝ eIf .
Since e′1 = Body(f) and e
I
f = body
I(f), by Definition 8 and Γ
pi
∝ (∆,A), Γ.f :
∀a.ρ ; f
pi
∝ (∆.f : ∀α.τf ,A). Hence, by the induction hypothesis of the second
sub-derivation, there exist an type τ and eI2 such that t
type½ τ and
(t, τ) ` e′2 ∝ eI2 Under Γ.f : σ ; f
Now, applying the substitution S′ and eg derived from Definition 7 to the above
respect condition, we get
[[[eg/dg]e′2]] ' S′eI2 Under Γ.f : σ ; f
Given Body(f) = e′1, and Body
I(f) = Λα.eIf , by Proposition 3 we have
[[[eg/dg][e′1/f ]e
′
2]] ' S′[Λα.eIf/f ]eI2 Under Γ
By β-reduction, the open equation above is equivalent to
[[[eg/dg](let f = e′1 in e
′
2)]] ' S′(LET f = Λα. eIf IN eI2)
· 53
Theorem 4 (Soundness of Static Weaving) Let pi0 be an AspectFun program.
If ∅ ` pi0 : t ; e′, then there exists an FIL-converted program, piI = (A, eI), such
that pi0
prog½ piI and [[e′]] ∼∼ eI under A.
Proof. It is equivalent to show that if ` pi0 : t ; e′ then `D pi0 : τ ½ eI ;A
and [[e′]] ' eI under ∅ and A. We use a stronger proposition to prove it. Suppose
Γ
pi0
∝ (∆,A) and all bindings in Γ are introduced only via (Global), (Adv), or
(Adv-An). If Γ ` pi : t; e′ for a sub-program pi of pi0, i.e. pi0 ≡ d0.pi, then there
exists an FIL-conversion ∆ `D pi : τ ½ eI ;A1 such that [[e′]] ' eI under Γ and
A∪A1. Afterwards, the original result of the theorem can be obtained by assigning
∅ to Γ, ∆, A and d0.
Let pi ≡ d.e. We prove the above proposition by induction on the length of
declarations of pi, |d|.
Induction basis:
d = 0: we have pi ≡ e0. Since no binding in Γ is introduced via (Pred), this case
is a direct consequence of Theorem 3 and Proposition 5.
Induction step:
When the proposition holds for pi with length(d) = k, we shall prove it for pi1
with length(d) = k + 1. Let pi1 ≡ d.pi. The Induction step to prove is that if
Γ1
pi0
∝ (∆1,A1) and Γ1 ` pi1 : t1 ; e′1 then ∆1 `D pi1 : τ1 ½ eI1;A2 and [[e′1]] ' eI1
under Γ1 and A2 ∪ A1. We prove it by a case analysis on d and induction on the
derivation for Γ1 ` d.pi : t1 ; e′1:
case (GLOBAL variable) :
We have a derivation of the form:
Γ1 ` ex : ρx ; e′x σ = gen(Γ1, ρx) Γ1.x : σ ; x ` pi : t1 ; e′
Γ1 ` x = ex in pi : t1 ; x = e′x in e′
Given Γ1 ` ex : ρx ; e′x, by Theorem 3, ∆1 ` ex : τx ½ eIx, ρx
type½ τx (1) and
(ρx, τx) ` e′x ∝ eIx. Besides, since no binding in Γ is introduced via (Pred), we
have (ρx, τx) `T Body(x) ≡ e′x ∝ eIx ≡ bodyI(x). So, by Γ1
pi0
∝ (∆1,A1) and
Definition 8,
Γ ≡ Γ1.x : gen(Γ1, ρx); x
pi0
∝ (∆1.x : gen(∆, τx),A1) ≡ (∆,A1)
Thus, by the induction hypothesis of the second derivation, Γ ` pi : t1 ; e′, we
have
∆ `D pi : τ ½ eI ;A (2) and [[e′]] ' eI under Γ and A ∪A1
Then, by (1) and (2), we can apply the (Decl:Var) rule and get
∆1 `D pi1 : τ1 ½ eI1;A1
where τ1 ≡ τ
eI1 ≡ LET x = BodyI(x) IN eI
A2 ≡ A
and [[e′]] ' eI under Γ and A2 ∪ A1
· 55
Thus we get all the premises of (Decl:Adv-An) fulfilled. Hence
∆1 `D pi1 : τ1 ½ eI1;A2
where τ1 ≡ τ
eI1 ≡ eI
A2 = A.(n : gen(∆, τn), f , τ1,BodyI(n))
and [[e′]] ' eI under Γ and A0 ∪ A
As the last step, we need to show that [[e′1]] ' eI1 under Γ1 and A2 ∪ A1 where
e′1 ≡ n = e′a in e′. Clearly A2 ∪ A1 = A0 ∪ A. Now applying Proposition 3 to
[[e′]] ' eI under Γ and A0 ∪ A, we get
[[[e′a/n]e
′]] ' [BodyI(n)/n]eI1 under Γ1 and A2 ∪ A1
Thus
[[e′1]] ≡ [[n = e′a in e′]] ' eI1 under Γ1 and A2 ∪ A1
by β-reduction and that advice names never appear in eI1.
case (Adv-An) : We have a derivation of the form:
Γ.proceed : tx → t ` λx.ea : p¯.tx → t; e′a σ = gen(Γ, p¯.tx → t)
fi : ∀a¯.ti → t′i ∈ Γbase S = [t¯/a¯]ti D tx
t D S[t¯/a¯]t′i Γ.n : σ ./ f¯ ; n ` pi : t′ ; pi′
Γ ` n@advice around {f¯} (x :: tx) = eain pi : t′ ; n = e′a in pi′
Pick τ1 and τ2 such that tx → t
type½ τ1 → τ2. The rest of the proof is very similar
to the previous case, except the part for the third element (i.e., τx u τ1) in the
Adv tuple, to be included in the advice store by (Decl:Adv-An). As required
by (Decl:Adv-An), the τx must satisfy tx
type½ τx, hence we can choose τx ≡ τ1.
This gives us τx u τ1 = τx, which is still the parameter part of the FIL converted
type of n, τ1 → τ2.
出席國際會議研究心得報告及發表論文 
政治大學資訊科學系 
陳 恭 
97/10 
 
計畫名稱：以型態導向方法發展多型剖面的織入技術與應用 
編號：NSC 95－2221－E—004－004－MY2 
執行期間：95/08/01~97/07/31 
 
本計畫執行結果已發表於下列國際學術會議: 
The 14th International Static Analysis Symposium (SAS 2007)  
Kongens Lyngby, Denmark 
22-24 August 2007 
論文名稱: A Compilation Model for Aspect-Oriented Polymorphically Typed 
Functional Languages 
收錄於論文集: Riis Nielson, Gilberto File (Eds.): Static Analysis, 14th International 
Symposium, SAS 2007, Lecture Notes in Computer Science 4634 Springer 2007, 
ISBN 978-3-540-74060-5 
 
Static Analysis Symposium 是程式分析國際社群一年一度的學術會議，今年是第
十四屆，在丹麥首都哥本哈根近郊的 Kongens Lyngby 的丹麥科技大學舉行，會
議從 8/22 到 8/24 舉行，來自全球各地學術界與產業界共計有近百人左右與會，
本人與參與計畫的學生翁書鈞是僅有的兩位來自台灣的與會人員。會議議程除一
般研究論文外，大會也特別邀請了兩位資深學者進行專題演講，內容相當豐富。 
 
本人的論文是發表在第一天的上午，論文題目為＂ A Compilation Model for 
Aspect-Oriented Polymorphically Typed Functional Languages＂。此篇論文是我們
專題研究計畫的主要成果，針對 Aspect-Oriented Functional Languages，提出型態導
向的多型剖面織入方法的理論與實作雛型技術。我們的方法可以處理 type-coped advice, 
indirect function calls, higher-order function, overlapping advices，而且完全是以 static 
typing獲致一致的織入(weaving)結果。普林斯頓大學的 PolyAML不能完全以 static typing
做到 type-scoped advice的織入.東京大學的Aspectual Caml無法處理 indirect function calls, 
higher-order function, overlapping advices 的一致性。我們除了發展理論外，也設計並實
作了 AspectFun 語言，將一些常用的剖面導向機制納入，例如 curried pointcuts 與 cflow 
pointcuts。並以靜態分析技術，針對使用 cflow 的剖面進行 control flow 優化分析。論文
將 AspectFun 語言的編譯過程做了重點式的介紹。限於篇幅，一些細節與靜態織
入方法的證明，未來將以期刊論文方式發表。 
A Compilation Model for Aspect-Oriented
Polymorphically Typed Functional Languages
Kung Chen1, Shu-Chun Weng2, Meng Wang3,
Siau-Cheng Khoo4, and Chung-Hsin Chen1
1 National Chengchi University
2 National Taiwan University
3 Oxford University
4 National University of Singapore
Abstract. Introducing aspect orientation to a polymorphically typed
functional language strengthens the importance of type-scoped advices;
i.e., advices with their eﬀects harnessed by type constraints. As types are
typically treated as compile time entities, it is highly desirable to be able
to perform static weaving to determine at compile time the chaining of
type-scoped advices to their associated join points. In this paper, we de-
scribe a compilation model, as well as its implementation, that supports
static type inference and static weaving of programs in an aspect-oriented
polymorphically typed lazy functional language, AspectFun. We present
a type-directed weaving scheme that coherently weaves type-scoped ad-
vices into the base program at compile time. We state the correctness
of the static weaving with respect to the operational semantics of As-
pectFun. We also demonstrate how control-ﬂow based pointcuts (such
as cflowbelow) are compiled away, and highlight several type-directed
optimization strategies that can improve the eﬃciency of woven code.
1 Introduction
Aspect-oriented programming (AOP) aims at modularizing concerns such as
proﬁling and security that crosscut the components of a software system[8]. In
AOP, a program consists of many functional modules and some aspects that
encapsulate the crosscutting concerns. An aspect provides two speciﬁcations: A
pointcut , comprising a set of functions, designates when and where to crosscut
other modules; and an advice, which is a piece of code, that will be executed when
a pointcut is reached. The complete program behaviour is derived by some novel
ways of composing functional modules and aspects according to the speciﬁcations
given within the aspects. This is called weaving in AOP. Weaving results in
the behaviour of those functional modules impacted by aspects being modiﬁed
accordingly.
The eﬀect of an aspect on a group of functions can be controlled by introducing
bounded scope to the aspect. Speciﬁcally, when the AOP paradigm is supported
by a strongly-type polymorphic functional language, such as Haskell or ML, it
is natural to limit the eﬀect of an aspect on a function through declaration
H. Riis Nielson and G. File´ (Eds.): SAS 2007, LNCS 4634, pp. 34–51, 2007.
c© Springer-Verlag Berlin Heidelberg 2007
36 K. Chen et al.
Example 1, from a syntactic viewpoint, function h can be called in the body of
f. If we were to naively infer that the argument x to function h in the RHS of
f’s deﬁnition is of polymorphic type, we would be tempted to conclude that (1)
advice n3 should be triggered at the call, and (2) advices n4 and n5 should not
be called as its type-scope is less general than a → a. As a result, only n3 would
be statically applied to the call to h.
Unfortunately, this approach would cause inconsistent behavior of h at run-
time, as only the third trace message “exiting from h” would be printed. This
would be incoherent because the invocations (h [1]) (indirectly called from (f
[1])) and (h [2]) would exhibit diﬀerent behaviors even though they would
receive arguments of the same type.
Most of the work on aspect-oriented functional languages do not address this
issue of static and yet coherent weaving. In AspectML [4] (a.k.a PolyAML [3]),
dynamic type checking is employed to handle matching of type-scoped pointcuts;
on the other hand, Aspectual Caml [10] takes a lexical approach which sacriﬁces
coherence1 for static weaving.
Fig. 2. Compilation Model for AspectFun
In this paper, we present a compilation model for AspectFun that ensures
static and coherent weaving. AspectFun is an aspect-oriented polymorphically
typed functional language with lazy semantics. The overall compilation process
is illustrated in Figure 2. Brieﬂy, the model comprises the following three major
steps: (1) Static type inference of an aspect-oriented program; (2) Type-directed
static weaving to convert advices to functions and produce a piece of woven code;
(3) Type-directed optimization of the woven code. In contrast with our earlier
work [15], this compilation model extends our research in three dimensions:
1. Language features: We have included a suite of features to our aspect-oriented
functional language, AspectFun. Presented in this paper are: second-order
1 Our notion of coherence admits semantic equivalence among diﬀerent invocations of
a function with the same argument type. This is diﬀerent from the coherence concept
deﬁned in qualiﬁed types [6] which states that diﬀerent translations of an expression
are semantically equivalent.
38 K. Chen et al.
for a sequence of objects o1, ..., on (e.g. declarations, variables etc) and fv(o) as
the free variables in o. We assume that o¯ and o, when used together, denote un-
related objects. We write t1 ∼ t2 to specify uniﬁcation. We write t  t′ iﬀ there
exists a substitution S over type variables in t such that St = t′, and we write
t ≡ t′ iﬀ t  t′ and t′  t. To simplify our presentation, complex syntax, such
as if expressions and sequencings (;), are omitted even though they are used in
examples.
Programs π ::= d in π | e
Declarations d ::= x = e | f x = e | n@advice around {pc} (arg) = e
Arguments arg ::= x | x :: t
Pointcuts pc ::= ppc | pc + cf
Primitive PC’s ppc ::= f | n
Cﬂows cf ::= cflowbelow(f) | cflowbelow(f( :: t))
Expressions e ::= c | x | proceed | λx.e | e e | let x = e in e
Types t ::= Int | Bool | a | t → t | [t]
Advice Predicates p ::= (f : t)
Advised Types ρ ::= p.ρ | t
Type Schemes σ ::= ∀a¯.ρ
Fig. 3. Syntax of the AspectFun Language
In AspectFun, top-level deﬁnitions include global variable and function def-
initions, as well as aspects. An aspect is an advice declaration which includes
a piece of advice and its target pointcuts. An advice is a function-like expres-
sion that executes when any of the functions designated at the pointcut are
about to execute. The act of triggering an advice during a function application
is called weaving. Pointcuts are denoted by {pc} (arg), where pc stands for ei-
ther a primitive pointcut, represented by ppc, or a composite pointcut. Pointcuts
specify certain join points in the program ﬂow for advising. Here, we focus on
join points at function invocations. Thus a primitive pointcut, ppc, speciﬁes a
function or advice name the invocations of which, either directly or indirectly
via functional arguments, will be advised.
Advice is a function-like expression that executes before, after , or around
a pointcut. An around advice is executed in place of the indicated pointcut,
allowing the advised pointcut to be replaced. A special keyword proceed may
be used inside the body of an around advice. It is bound to the function that
represents “the rest of the computation” at the advised pointcut. As both before
advice and after advice can be simulated by around advice that uses proceed,
we only need to consider around advice in this paper.
A sequence of pointcuts, {pc}, indicates the union of all the sets of join points
selected by the pci’s. The argument variable arg is bound to the actual argument
of the named function call and it may contain a type scope. Alpha renaming is
applied to local declarations beforehand so as to avoid name clash.
40 K. Chen et al.
found in the Hindley-Milner type system) with advice predicates, (f : t), which
are used to capture the need of advice weaving based on type context. We shall
explain them in detail in Section 3.
We end our description of the syntax of AspectFun by referring interested
readers to the accompanied technical report [2] for detailed discussion of the
complete features of AspectFun, which include “catch-all” pointcut any and its
variants, a diversity of composite pointcuts, nested advices, as well as advices
over curried functions.
Semantics of AspectFun. As type information is required at the triggering of
advices for weaving, the semantics of AspectFun is best deﬁned in a language that
allows dynamic manipulation of types: type abstractions and type applications.
Thus, we convert AspectFun into a System-F like intermediate language, FIL.
Program πI ::= (Adv, eI)
Advice Adv ::= (n : ς, pc, τ, eI)
Join points jp ::= f : τ | 
Expressions eI ::= vI | x | proceed | eI eI | eI{τ} | LET x = eI IN eI
Values vI ::= c | λjpx : τx. eI | Λα. eI
Types τ ::= Int | Bool | α | τ → τ | [τ ]
Type schemes ς ::= ∀α. τ | τ
Fig. 4. Syntax of FIL
(
prog)
∅ D π : τ  eI ;A
π
prog
 (A, eI) (Decl:MainExpr)
Δ  e : τ  eI
Δ D e : τ  eI ; ∅
(Decl:Func)
Δ.x : τx  e : τf  eIf α = fv(τx → τf ) \ fv(Δ)
Δ.f : ∀α. τx → τf D π : τ  eI ;A
Δ D f x=e in π : τ  LET f =Λα. λf :τx→τf x : τx. eIf IN eI ;A
(Decl:Adv-An)
fv(tx) : fresh(fv(tx))  tx type τx
Δ.x : τx.proceed : τx → τn  e : τn  eIn
α = fv(τx → τn) \ fv(Δ) Δ D π : τ  eI ;A
Δ D n@advice around {pc} (x :: tx) = e in π : τ  eI ;
A.(n : ∀α.τx → τn, pc, τx, Λα. λn:τx→τnx : τx. eIn)
(Expr:Var)
τ = Δ(x)
Δ  x : τ  x (Expr:Ty-App)
∀α. τ = Δ(x) τx = [τ ′/α]τ
Δ  x : τx  x{τ ′}
(Type:Base) σ  Int type Int σ  Bool type Bool σ.a : α  a type α
(Type:Inferred)
σ  t type τ
σ  [t] type [τ ]
σ  t1 type τ1 σ  t2 type τ2
σ  t1 → t2 type τ1 → τ2
Fig. 5. Conversion Rules to FIL (interesting cases)
42 K. Chen et al.
Operational Semantics for FIL. We describe the operational semantics for
AspectFun in terms of that for FIL. Due to space limitation, we leave the seman-
tics for handling cﬂow-based pointcut to [2].
The reduction-based big-step operational semantics, written as ⇓A, is deﬁned
in Figure 6. Together with it are deﬁnitions of the auxiliary functions used. Note
that the advice store A is implicitly carried by all the rules, and it is omitted to
avoid cluttering of symbols.
Triggering and weaving of advices are performed during function applications,
as shown in rule (OS:App). Triggering operation ﬁrst chooses eligible advices
based on argument type, and weaves them into the function invocation – through
a series of substitutions of advice bodies – for execution. Note that only those
advices the types of which are instantiable to the applied function’s type are
selected for chaining via the Weave function.
3 Static Weaving
In our compilation model, aspects are woven statically (Step 5 in Figure 2).
Speciﬁcally, we present in this section a type inference system which guarantees
type safety and, at the same time, weaves the aspects through a type-directed
translation. Note that, for composite pointcuts such as f+cflowbelow(g), our
static weaving system simply ignores the control-ﬂow part and only considers the
associated primitive pointcuts (ie., f). Treatment of control-ﬂow based pointcuts
is presented in Section 4.
Type directed weaving. As introduced in Section 2, advised type denoted as
ρ is used to capture function names and their types that may be required for
advice resolution. We further illustrate this concept with our tracing example
given in Section 1.
For instance, function f possesses the advised type ∀a.(h : a → a).a → a, in
which (h : a → a) is called an advice predicate. It signiﬁes that the execution of
any application of f may require advices of h applied with a type which should be
no more general than a′ → a′ where a′ is a fresh instantiation of type variable
a. We say a type t is more general than type t′ iﬀ t  t′ but t ≡ t′. Note
that advised types are used to indicate the existence of some indeterminate
advices . If a function contains only applications whose advices are completely
determined, then the function will not be associated with an advised type; it will
be associated with a normal (and possibly polymorphic) type. As an example,
the type of the advised function h in Example 1 is ∀a.a → a since it does not
contain any application of advised functions in its deﬁnition.
We begin with the following set of auxiliary functions that assists type
inference:
(Gen) gen(Γ,σ) = ∀a¯.σ where a¯ = fv(σ)\fv(Γ ) (Card) |o1...ok | = k
The main set of type inference rules, as described in Figure 7, is an extension to
the Hindley-Milner system. We introduce a judgment Γ  e : σ  e′ to denote
that expression e has type σ under type environment Γ and it is translated to
44 K. Chen et al.
Deﬁnition 1. Given a function f and its type t2 → t′2, if ((∀n.n :(∗) ∀a¯.p¯.t1 →
t′1  f) ∈ Γ ∧ t1 ∼ t2) ⇒ t1  t2, then wv(f : t2 → t′2).
This condition basically means that under a given typing environment, a func-
tion’s type is no more general than any of its advices. For instance, under the
environment {n : ∀a.[a] → [a]  f, n1 : Int → Int  f}, wv(f : b → b) is
false because the type is not speciﬁc enough to determine whether n1 and n2
should apply whereas wv(f : Bool → Bool) is vacuously true and, in this case,
no advice applies. Note that since uniﬁcation and matching are deﬁned on types
instead of type schemes, quantiﬁed variables are freshly instantiated to avoid
name capturing.
There are two rules for variable lookups. Rule (Var) is standard. In the case
that variable x is advised, rule (Var-A) will create a fresh instance t′ of the
type scheme bound to x in the environment. Then we check weavable condition
of (x : t′). If the check succeeds (i.e., x’s input type is more general or equivalent
to any of the advice’s), x will be chained with the translated forms of all those
advices deﬁned on it, having equivalent or more general types than x has (the
selection is done by {ni|ti  t′}). All these selected advices have corresponding
non-advised types guaranteed by the weavable condition. This ensures the bodies
of the selected advices are correctly woven. Finally, the translated expression is
normalized by bringing all the advice abstractions of x outside the chain 〈. . .〉.
This ensures type compatibility between the advised call and its advices.
If the weavable condition check fails, there must exist some advices for x with
more speciﬁc types, and rule (Var-A) fails to apply. Since x ∈ A still holds, rule
(Pred) can be applied, which adds an advice predicate to a type. (Note that
we only allow sensible choices of t constrained by tx  t.) Correspondingly, its
translation yields a lambda abstraction with an advice parameter. This advice
parameter enables concrete advice-chained functions to be passed in at a later
stage, called releasing, through application of rule (Rel). Speciﬁcally, rule (Rel)
is applied to release (i.e., remove) an advice predicate from a type. Its translation
generates a function application with an advised expression as argument.
Handling Advices. Declarations deﬁne top-level bindings including advices.
We use a judgement Γ  π : σ  π′ which reassembles the one for expressions.
Rule (Global) is very similar to rule (Let) with the tiny diﬀerence that rule
(Global) binds id which is not in A with :. It binds id with :∗ otherwise.
Rule (Adv) deals with advice declarations. We only consider type-scoped ad-
vices, and treat non-type-scoped ones as special cases having the most general
type scope ∀a.a. We ﬁrst infer a (possibly advised) type of the advice as a func-
tion λx.ea under the type environment extended with proceed. The advice body
is therefore translated. Note that this translation does not necessarily complete
all the chaining because the weavable condition may not hold. Thus, as with
functions, the advice is parameterized, and an advised type is assigned to it and
only released when it is chained in rule (Var-A).
Next, we check whether the inferred input type is more general than the type-
scope: If so, the inferred type is specialized with the substitution S resulted from
the matching; otherwise, the type-scope is simply ignored. The function try acts
46 K. Chen et al.
eM : Expressions containing meta-constructs
addProceed : eM −→ eM
addProceed(let n df arg = e1 in e2) = if (n is an advice) then
let n df proceed arg = e1
in addProceed(e2)
else let n df arg = e1 in addProceed(e2)
addProceed(e) = e
[[·]] : eM −→ Expanded expression
[[e1 e2]] = [[e1]] [[e2]] ... trivial rules omitted
[[〈f e , {}〉]] = [[f e]]
[[〈f e , {ea, eadvs}〉]] = ProceedApply(ea, 〈f e , {eadvs}〉)
ProceedApply(n e, k) = [[n e k]] if rank(n) = 0
ProceedApply(〈n e , {ns}〉, k) = [[〈n e k , {ns}〉]] if rank(n) > 0
rank(x) =
{
1 + maxi rank(eai) if x ≡ 〈f e , {ea}〉
0 otherwise
4 Compiling Control-Flow Based Pointcuts
In this section, we present our compilation model for composite pointcuts –
control-ﬂow based pointcuts. Despite the fact that control-ﬂow information are
only available fully during run-time, we strive to discover as much information
as possible during compilation. Our strategy is as follows: In the early stage of
the compilation process (step 2 in Figure 2), we convert all control-ﬂow based
pointcuts in the source to pointcuts involving only cflowbelow[2]. For example,
m@advice around {h+cflowbelow(d(_::Int))} (arg) = ...
will be translated, via introduction of second-order advice, into the following:
m’@advice around {d} (arg :: Int) = proceed arg in
m@advice around {h+cflowbelow(m’)} (arg) = ...
Next, the advice m will be further translated to
m@advice around {h} (arg) = ...
while the association of h+cflowbelow(m’) and m will be remembered for
future use.
After the static weaving and addProceed step, we reinstall the control-ﬂow
based pointcuts in the woven code through guard insertion and monad transfor-
mation (steps 6 and 8 in Figure 2), following the semantics of control-ﬂow based
pointcuts, and then subject the woven code to control-ﬂow pointcut analysis
and code optimization. The description of these steps will be presented after
explaining the extension made to the FIL semantics.
48 K. Chen et al.
Here, enter "g" adds an entry record into the global state, and restore state
erases it.
Next, for each use occurrence of cflowbelow advices, we wrap it with a state-
lookup to determine the presence of the respective pointcuts. The wrapped code
is a form of guarded expression denoted by <|guard,n|> for advice n. It implies
that n will be executed only if the guard evaluates to True. The Example 3 with
wrapped code appears as follows:
Example 3a
// meta-data: IFAdvice [k+cflowbelow(g)] (n,...)
n proceed arg = arg+123 in
k x = x + 1 in
g x = enter "g"; <k, { <| isIn "g", n|> } > x; restore_state in
f x = if x == 0 then g x else <k, { <| isIn "g", n |> } > x in (f 0, f 1)
The guard (isIn "g") determines if g has been invoked and not yet returned.
If so, advice n is executed. In this case, n is not triggered when evaluating f 1,
but it is when evaluating f 0.
Control-Flow Pointcut Analysis and Optimization. From Example 3a, we
note that the guard occurring in the deﬁnition of g is always true, and can thus
be eliminated. Similarly, the guard occurring in the deﬁnition of f is always false,
and the associated advice n can be removed from the code. Indeed, many of such
guards can be eliminated during compile time, thus speeding up the execution
of the woven code. We thus employ two interprocedural analyses to determine
the opportunity for optimizing guarded expressions. They are mayCﬂow and
mustCﬂow analyses (cf. [1]).
Since the subject language is polymorphically typed and higher-order, we
adopt annotated-type and eﬀect systems for our analysis (cf. [11]). We deﬁne
a context ϕ to be a set of function names. Judgments for both mayCﬂow and
mustCﬂow analyses are of the form
Γˆ  e : τˆ1 ϕ
′
−→τˆ2 & ϕ
For mayCﬂow analysis (resp. mustCﬂow analysis), this means that under an
annotated-type environment Γˆ , an expression e has an annotated type τˆ1
ϕ′−→τˆ2
and a context ϕ capturing the name of those functions which may be (resp. must
be) invoked and not yet returned during the execution of e. The annotation ϕ′
above the arrow → is the context in which the function resulted from evaluation
of e will be invoked.
This type-and-eﬀect approach has been described in detail in [11]. As our
analyses follow this approach closely, we omit the detail here for space limita-
tion, and refer readers to [2] for explanation. Applying both mayCﬂow and
mustCﬂow analyses over the woven code given in Example 3a, we obtain the
following contexts for the body of each of the functions:
ϕmayk = {f, g}, ϕmayg = {f}, ϕmayf = ∅
ϕmustk = ∅, ϕmustg = {f}, ϕmustf = ∅
50 K. Chen et al.
most existing techniques to be shared. The concerns of closures and inlining
can be more straightforwardly encoded with higher-order functions and function
calls in AspectFun; whereas the complex control ﬂow of higher-order functional
languages makes the cﬂow analysis much more challenging. As a result, our typed
cﬂow analysis has little resemblance with the one in ABC which was based on
call graphs of an imperative language.
In [9], Masuhara et al. proposed a compilation and optimization model for
aspect-oriented programs. As their approach employs partial evaluation to op-
timize a dynamic weaver implemented in Scheme, the amount of optimization
is restricted by the ability of the partial evaluator. In contrast, our compilation
model is built upon a static weaving framework; residues are only inserted when
it is absolutely necessary (in case of some control-ﬂow based pointcuts), which
keeps the dynamic impact of weaving to a minimum.
6 Conclusion and Future Work
Static typing, static and coherent weaving are our main concerns in constructing
a compilation model for functional languages with higher-order functions and
parametric polymorphism. As a sequel to our previous work, this paper has made
the following signiﬁcant progress. Firstly, while the basic structure of our type
system remains the same, the typing and translation rules have been signiﬁcantly
reﬁned and extended beyond the two-layered model of functions and advices.
Consequently, advices and advice bodies can also be advised. Secondly, we proved
the soundness of our static weaving with respect to an operational semantics for
the underlying language, AspectFun. Thirdly, we seamlessly incorporated a wide
range of control-ﬂow based pointcuts into our model and implemented some
novel optimization techniques which take advantage of the static nature of our
weaver. Lastly, we developed a compiler which follows our model to translate
AspectFun programs into executable Haskell code.
Moving ahead, we will investigate additional optimization techniques and con-
duct empirical experiments of performance gain. Besides, we plan to explore ways
of applying our static weaving system to other language paradigms. In particu-
lar, Java 1.5 has been extend with parametric polymorphism by the introduction
of generics. Yet, as mentioned in [5], the type-erasure semantics of Java prohibits
the use of dynamic type tests to handle type-scoped advices. We speculate our
static weaving scheme could be a key to the solution of the problem.
Acknowledgment
We would like to thank the anonymous referees for their insightful comments.
This research is partially supported by the National University of Singapore
under research grant “R-252-000-250-112”, and by the National Science Council,
Taiwan, R.O.C. under grant number “NSC 95-2221-E-004-004-MY2”.
出席國際會議研究心得報告及發表論文 
政治大學資訊科學系 
陳 恭 
97/10 
 
計畫名稱：以型態導向方法發展多型剖面的織入技術與應用 
編號：NSC 95－2221－E—004－004－MY2 
執行期間：95/08/01~97/07/31 
 
本計畫執行結果已發表於下列國際學術會議: 
The 14th International Static Analysis Symposium (SAS 2007)  
Kongens Lyngby, Denmark 
22-24 August 2007 
論文名稱: A Compilation Model for Aspect-Oriented Polymorphically Typed 
Functional Languages 
收錄於論文集: Riis Nielson, Gilberto File (Eds.): Static Analysis, 14th International 
Symposium, SAS 2007, Lecture Notes in Computer Science 4634 Springer 2007, 
ISBN 978-3-540-74060-5 
 
Static Analysis Symposium 是程式分析國際社群一年一度的學術會議，今年是第
十四屆，在丹麥首都哥本哈根近郊的 Kongens Lyngby 的丹麥科技大學舉行，會
議從 8/22 到 8/24 舉行，來自全球各地學術界與產業界共計有近百人左右與會，
本人與參與計畫的學生翁書鈞是僅有的兩位來自台灣的與會人員。會議議程除一
般研究論文外，大會也特別邀請了兩位資深學者進行專題演講，內容相當豐富。 
 
本人的論文是發表在第一天的上午，論文題目為＂ A Compilation Model for 
Aspect-Oriented Polymorphically Typed Functional Languages＂。此篇論文是我們
專題研究計畫的主要成果，針對 Aspect-Oriented Functional Languages，提出型態導
向的多型剖面織入方法的理論與實作雛型技術。我們的方法可以處理 type-coped advice, 
indirect function calls, higher-order function, overlapping advices，而且完全是以 static 
typing獲致一致的織入(weaving)結果。普林斯頓大學的 PolyAML不能完全以 static typing
做到 type-scoped advice的織入.東京大學的Aspectual Caml無法處理 indirect function calls, 
higher-order function, overlapping advices 的一致性。我們除了發展理論外，也設計並實
作了 AspectFun 語言，將一些常用的剖面導向機制納入，例如 curried pointcuts 與 cflow 
pointcuts。並以靜態分析技術，針對使用 cflow 的剖面進行 control flow 優化分析。論文
將 AspectFun 語言的編譯過程做了重點式的介紹。限於篇幅，一些細節與靜態織
入方法的證明，未來將以期刊論文方式發表。 
A Compilation Model for Aspect-Oriented
Polymorphically Typed Functional Languages
Kung Chen1, Shu-Chun Weng2, Meng Wang3,
Siau-Cheng Khoo4, and Chung-Hsin Chen1
1 National Chengchi University
2 National Taiwan University
3 Oxford University
4 National University of Singapore
Abstract. Introducing aspect orientation to a polymorphically typed
functional language strengthens the importance of type-scoped advices;
i.e., advices with their eﬀects harnessed by type constraints. As types are
typically treated as compile time entities, it is highly desirable to be able
to perform static weaving to determine at compile time the chaining of
type-scoped advices to their associated join points. In this paper, we de-
scribe a compilation model, as well as its implementation, that supports
static type inference and static weaving of programs in an aspect-oriented
polymorphically typed lazy functional language, AspectFun. We present
a type-directed weaving scheme that coherently weaves type-scoped ad-
vices into the base program at compile time. We state the correctness
of the static weaving with respect to the operational semantics of As-
pectFun. We also demonstrate how control-ﬂow based pointcuts (such
as cflowbelow) are compiled away, and highlight several type-directed
optimization strategies that can improve the eﬃciency of woven code.
1 Introduction
Aspect-oriented programming (AOP) aims at modularizing concerns such as
proﬁling and security that crosscut the components of a software system[8]. In
AOP, a program consists of many functional modules and some aspects that
encapsulate the crosscutting concerns. An aspect provides two speciﬁcations: A
pointcut , comprising a set of functions, designates when and where to crosscut
other modules; and an advice, which is a piece of code, that will be executed when
a pointcut is reached. The complete program behaviour is derived by some novel
ways of composing functional modules and aspects according to the speciﬁcations
given within the aspects. This is called weaving in AOP. Weaving results in
the behaviour of those functional modules impacted by aspects being modiﬁed
accordingly.
The eﬀect of an aspect on a group of functions can be controlled by introducing
bounded scope to the aspect. Speciﬁcally, when the AOP paradigm is supported
by a strongly-type polymorphic functional language, such as Haskell or ML, it
is natural to limit the eﬀect of an aspect on a function through declaration
H. Riis Nielson and G. File´ (Eds.): SAS 2007, LNCS 4634, pp. 34–51, 2007.
c© Springer-Verlag Berlin Heidelberg 2007
36 K. Chen et al.
Example 1, from a syntactic viewpoint, function h can be called in the body of
f. If we were to naively infer that the argument x to function h in the RHS of
f’s deﬁnition is of polymorphic type, we would be tempted to conclude that (1)
advice n3 should be triggered at the call, and (2) advices n4 and n5 should not
be called as its type-scope is less general than a → a. As a result, only n3 would
be statically applied to the call to h.
Unfortunately, this approach would cause inconsistent behavior of h at run-
time, as only the third trace message “exiting from h” would be printed. This
would be incoherent because the invocations (h [1]) (indirectly called from (f
[1])) and (h [2]) would exhibit diﬀerent behaviors even though they would
receive arguments of the same type.
Most of the work on aspect-oriented functional languages do not address this
issue of static and yet coherent weaving. In AspectML [4] (a.k.a PolyAML [3]),
dynamic type checking is employed to handle matching of type-scoped pointcuts;
on the other hand, Aspectual Caml [10] takes a lexical approach which sacriﬁces
coherence1 for static weaving.
Fig. 2. Compilation Model for AspectFun
In this paper, we present a compilation model for AspectFun that ensures
static and coherent weaving. AspectFun is an aspect-oriented polymorphically
typed functional language with lazy semantics. The overall compilation process
is illustrated in Figure 2. Brieﬂy, the model comprises the following three major
steps: (1) Static type inference of an aspect-oriented program; (2) Type-directed
static weaving to convert advices to functions and produce a piece of woven code;
(3) Type-directed optimization of the woven code. In contrast with our earlier
work [15], this compilation model extends our research in three dimensions:
1. Language features: We have included a suite of features to our aspect-oriented
functional language, AspectFun. Presented in this paper are: second-order
1 Our notion of coherence admits semantic equivalence among diﬀerent invocations of
a function with the same argument type. This is diﬀerent from the coherence concept
deﬁned in qualiﬁed types [6] which states that diﬀerent translations of an expression
are semantically equivalent.
38 K. Chen et al.
for a sequence of objects o1, ..., on (e.g. declarations, variables etc) and fv(o) as
the free variables in o. We assume that o¯ and o, when used together, denote un-
related objects. We write t1 ∼ t2 to specify uniﬁcation. We write t  t′ iﬀ there
exists a substitution S over type variables in t such that St = t′, and we write
t ≡ t′ iﬀ t  t′ and t′  t. To simplify our presentation, complex syntax, such
as if expressions and sequencings (;), are omitted even though they are used in
examples.
Programs π ::= d in π | e
Declarations d ::= x = e | f x = e | n@advice around {pc} (arg) = e
Arguments arg ::= x | x :: t
Pointcuts pc ::= ppc | pc + cf
Primitive PC’s ppc ::= f | n
Cﬂows cf ::= cflowbelow(f) | cflowbelow(f( :: t))
Expressions e ::= c | x | proceed | λx.e | e e | let x = e in e
Types t ::= Int | Bool | a | t → t | [t]
Advice Predicates p ::= (f : t)
Advised Types ρ ::= p.ρ | t
Type Schemes σ ::= ∀a¯.ρ
Fig. 3. Syntax of the AspectFun Language
In AspectFun, top-level deﬁnitions include global variable and function def-
initions, as well as aspects. An aspect is an advice declaration which includes
a piece of advice and its target pointcuts. An advice is a function-like expres-
sion that executes when any of the functions designated at the pointcut are
about to execute. The act of triggering an advice during a function application
is called weaving. Pointcuts are denoted by {pc} (arg), where pc stands for ei-
ther a primitive pointcut, represented by ppc, or a composite pointcut. Pointcuts
specify certain join points in the program ﬂow for advising. Here, we focus on
join points at function invocations. Thus a primitive pointcut, ppc, speciﬁes a
function or advice name the invocations of which, either directly or indirectly
via functional arguments, will be advised.
Advice is a function-like expression that executes before, after , or around
a pointcut. An around advice is executed in place of the indicated pointcut,
allowing the advised pointcut to be replaced. A special keyword proceed may
be used inside the body of an around advice. It is bound to the function that
represents “the rest of the computation” at the advised pointcut. As both before
advice and after advice can be simulated by around advice that uses proceed,
we only need to consider around advice in this paper.
A sequence of pointcuts, {pc}, indicates the union of all the sets of join points
selected by the pci’s. The argument variable arg is bound to the actual argument
of the named function call and it may contain a type scope. Alpha renaming is
applied to local declarations beforehand so as to avoid name clash.
40 K. Chen et al.
found in the Hindley-Milner type system) with advice predicates, (f : t), which
are used to capture the need of advice weaving based on type context. We shall
explain them in detail in Section 3.
We end our description of the syntax of AspectFun by referring interested
readers to the accompanied technical report [2] for detailed discussion of the
complete features of AspectFun, which include “catch-all” pointcut any and its
variants, a diversity of composite pointcuts, nested advices, as well as advices
over curried functions.
Semantics of AspectFun. As type information is required at the triggering of
advices for weaving, the semantics of AspectFun is best deﬁned in a language that
allows dynamic manipulation of types: type abstractions and type applications.
Thus, we convert AspectFun into a System-F like intermediate language, FIL.
Program πI ::= (Adv, eI)
Advice Adv ::= (n : ς, pc, τ, eI)
Join points jp ::= f : τ | 
Expressions eI ::= vI | x | proceed | eI eI | eI{τ} | LET x = eI IN eI
Values vI ::= c | λjpx : τx. eI | Λα. eI
Types τ ::= Int | Bool | α | τ → τ | [τ ]
Type schemes ς ::= ∀α. τ | τ
Fig. 4. Syntax of FIL
(
prog)
∅ D π : τ  eI ;A
π
prog
 (A, eI) (Decl:MainExpr)
Δ  e : τ  eI
Δ D e : τ  eI ; ∅
(Decl:Func)
Δ.x : τx  e : τf  eIf α = fv(τx → τf ) \ fv(Δ)
Δ.f : ∀α. τx → τf D π : τ  eI ;A
Δ D f x=e in π : τ  LET f =Λα. λf :τx→τf x : τx. eIf IN eI ;A
(Decl:Adv-An)
fv(tx) : fresh(fv(tx))  tx type τx
Δ.x : τx.proceed : τx → τn  e : τn  eIn
α = fv(τx → τn) \ fv(Δ) Δ D π : τ  eI ;A
Δ D n@advice around {pc} (x :: tx) = e in π : τ  eI ;
A.(n : ∀α.τx → τn, pc, τx, Λα. λn:τx→τnx : τx. eIn)
(Expr:Var)
τ = Δ(x)
Δ  x : τ  x (Expr:Ty-App)
∀α. τ = Δ(x) τx = [τ ′/α]τ
Δ  x : τx  x{τ ′}
(Type:Base) σ  Int type Int σ  Bool type Bool σ.a : α  a type α
(Type:Inferred)
σ  t type τ
σ  [t] type [τ ]
σ  t1 type τ1 σ  t2 type τ2
σ  t1 → t2 type τ1 → τ2
Fig. 5. Conversion Rules to FIL (interesting cases)
42 K. Chen et al.
Operational Semantics for FIL. We describe the operational semantics for
AspectFun in terms of that for FIL. Due to space limitation, we leave the seman-
tics for handling cﬂow-based pointcut to [2].
The reduction-based big-step operational semantics, written as ⇓A, is deﬁned
in Figure 6. Together with it are deﬁnitions of the auxiliary functions used. Note
that the advice store A is implicitly carried by all the rules, and it is omitted to
avoid cluttering of symbols.
Triggering and weaving of advices are performed during function applications,
as shown in rule (OS:App). Triggering operation ﬁrst chooses eligible advices
based on argument type, and weaves them into the function invocation – through
a series of substitutions of advice bodies – for execution. Note that only those
advices the types of which are instantiable to the applied function’s type are
selected for chaining via the Weave function.
3 Static Weaving
In our compilation model, aspects are woven statically (Step 5 in Figure 2).
Speciﬁcally, we present in this section a type inference system which guarantees
type safety and, at the same time, weaves the aspects through a type-directed
translation. Note that, for composite pointcuts such as f+cflowbelow(g), our
static weaving system simply ignores the control-ﬂow part and only considers the
associated primitive pointcuts (ie., f). Treatment of control-ﬂow based pointcuts
is presented in Section 4.
Type directed weaving. As introduced in Section 2, advised type denoted as
ρ is used to capture function names and their types that may be required for
advice resolution. We further illustrate this concept with our tracing example
given in Section 1.
For instance, function f possesses the advised type ∀a.(h : a → a).a → a, in
which (h : a → a) is called an advice predicate. It signiﬁes that the execution of
any application of f may require advices of h applied with a type which should be
no more general than a′ → a′ where a′ is a fresh instantiation of type variable
a. We say a type t is more general than type t′ iﬀ t  t′ but t ≡ t′. Note
that advised types are used to indicate the existence of some indeterminate
advices . If a function contains only applications whose advices are completely
determined, then the function will not be associated with an advised type; it will
be associated with a normal (and possibly polymorphic) type. As an example,
the type of the advised function h in Example 1 is ∀a.a → a since it does not
contain any application of advised functions in its deﬁnition.
We begin with the following set of auxiliary functions that assists type
inference:
(Gen) gen(Γ,σ) = ∀a¯.σ where a¯ = fv(σ)\fv(Γ ) (Card) |o1...ok | = k
The main set of type inference rules, as described in Figure 7, is an extension to
the Hindley-Milner system. We introduce a judgment Γ  e : σ  e′ to denote
that expression e has type σ under type environment Γ and it is translated to
44 K. Chen et al.
Deﬁnition 1. Given a function f and its type t2 → t′2, if ((∀n.n :(∗) ∀a¯.p¯.t1 →
t′1  f) ∈ Γ ∧ t1 ∼ t2) ⇒ t1  t2, then wv(f : t2 → t′2).
This condition basically means that under a given typing environment, a func-
tion’s type is no more general than any of its advices. For instance, under the
environment {n : ∀a.[a] → [a]  f, n1 : Int → Int  f}, wv(f : b → b) is
false because the type is not speciﬁc enough to determine whether n1 and n2
should apply whereas wv(f : Bool → Bool) is vacuously true and, in this case,
no advice applies. Note that since uniﬁcation and matching are deﬁned on types
instead of type schemes, quantiﬁed variables are freshly instantiated to avoid
name capturing.
There are two rules for variable lookups. Rule (Var) is standard. In the case
that variable x is advised, rule (Var-A) will create a fresh instance t′ of the
type scheme bound to x in the environment. Then we check weavable condition
of (x : t′). If the check succeeds (i.e., x’s input type is more general or equivalent
to any of the advice’s), x will be chained with the translated forms of all those
advices deﬁned on it, having equivalent or more general types than x has (the
selection is done by {ni|ti  t′}). All these selected advices have corresponding
non-advised types guaranteed by the weavable condition. This ensures the bodies
of the selected advices are correctly woven. Finally, the translated expression is
normalized by bringing all the advice abstractions of x outside the chain 〈. . .〉.
This ensures type compatibility between the advised call and its advices.
If the weavable condition check fails, there must exist some advices for x with
more speciﬁc types, and rule (Var-A) fails to apply. Since x ∈ A still holds, rule
(Pred) can be applied, which adds an advice predicate to a type. (Note that
we only allow sensible choices of t constrained by tx  t.) Correspondingly, its
translation yields a lambda abstraction with an advice parameter. This advice
parameter enables concrete advice-chained functions to be passed in at a later
stage, called releasing, through application of rule (Rel). Speciﬁcally, rule (Rel)
is applied to release (i.e., remove) an advice predicate from a type. Its translation
generates a function application with an advised expression as argument.
Handling Advices. Declarations deﬁne top-level bindings including advices.
We use a judgement Γ  π : σ  π′ which reassembles the one for expressions.
Rule (Global) is very similar to rule (Let) with the tiny diﬀerence that rule
(Global) binds id which is not in A with :. It binds id with :∗ otherwise.
Rule (Adv) deals with advice declarations. We only consider type-scoped ad-
vices, and treat non-type-scoped ones as special cases having the most general
type scope ∀a.a. We ﬁrst infer a (possibly advised) type of the advice as a func-
tion λx.ea under the type environment extended with proceed. The advice body
is therefore translated. Note that this translation does not necessarily complete
all the chaining because the weavable condition may not hold. Thus, as with
functions, the advice is parameterized, and an advised type is assigned to it and
only released when it is chained in rule (Var-A).
Next, we check whether the inferred input type is more general than the type-
scope: If so, the inferred type is specialized with the substitution S resulted from
the matching; otherwise, the type-scope is simply ignored. The function try acts
46 K. Chen et al.
eM : Expressions containing meta-constructs
addProceed : eM −→ eM
addProceed(let n df arg = e1 in e2) = if (n is an advice) then
let n df proceed arg = e1
in addProceed(e2)
else let n df arg = e1 in addProceed(e2)
addProceed(e) = e
[[·]] : eM −→ Expanded expression
[[e1 e2]] = [[e1]] [[e2]] ... trivial rules omitted
[[〈f e , {}〉]] = [[f e]]
[[〈f e , {ea, eadvs}〉]] = ProceedApply(ea, 〈f e , {eadvs}〉)
ProceedApply(n e, k) = [[n e k]] if rank(n) = 0
ProceedApply(〈n e , {ns}〉, k) = [[〈n e k , {ns}〉]] if rank(n) > 0
rank(x) =
{
1 + maxi rank(eai) if x ≡ 〈f e , {ea}〉
0 otherwise
4 Compiling Control-Flow Based Pointcuts
In this section, we present our compilation model for composite pointcuts –
control-ﬂow based pointcuts. Despite the fact that control-ﬂow information are
only available fully during run-time, we strive to discover as much information
as possible during compilation. Our strategy is as follows: In the early stage of
the compilation process (step 2 in Figure 2), we convert all control-ﬂow based
pointcuts in the source to pointcuts involving only cflowbelow[2]. For example,
m@advice around {h+cflowbelow(d(_::Int))} (arg) = ...
will be translated, via introduction of second-order advice, into the following:
m’@advice around {d} (arg :: Int) = proceed arg in
m@advice around {h+cflowbelow(m’)} (arg) = ...
Next, the advice m will be further translated to
m@advice around {h} (arg) = ...
while the association of h+cflowbelow(m’) and m will be remembered for
future use.
After the static weaving and addProceed step, we reinstall the control-ﬂow
based pointcuts in the woven code through guard insertion and monad transfor-
mation (steps 6 and 8 in Figure 2), following the semantics of control-ﬂow based
pointcuts, and then subject the woven code to control-ﬂow pointcut analysis
and code optimization. The description of these steps will be presented after
explaining the extension made to the FIL semantics.
48 K. Chen et al.
Here, enter "g" adds an entry record into the global state, and restore state
erases it.
Next, for each use occurrence of cflowbelow advices, we wrap it with a state-
lookup to determine the presence of the respective pointcuts. The wrapped code
is a form of guarded expression denoted by <|guard,n|> for advice n. It implies
that n will be executed only if the guard evaluates to True. The Example 3 with
wrapped code appears as follows:
Example 3a
// meta-data: IFAdvice [k+cflowbelow(g)] (n,...)
n proceed arg = arg+123 in
k x = x + 1 in
g x = enter "g"; <k, { <| isIn "g", n|> } > x; restore_state in
f x = if x == 0 then g x else <k, { <| isIn "g", n |> } > x in (f 0, f 1)
The guard (isIn "g") determines if g has been invoked and not yet returned.
If so, advice n is executed. In this case, n is not triggered when evaluating f 1,
but it is when evaluating f 0.
Control-Flow Pointcut Analysis and Optimization. From Example 3a, we
note that the guard occurring in the deﬁnition of g is always true, and can thus
be eliminated. Similarly, the guard occurring in the deﬁnition of f is always false,
and the associated advice n can be removed from the code. Indeed, many of such
guards can be eliminated during compile time, thus speeding up the execution
of the woven code. We thus employ two interprocedural analyses to determine
the opportunity for optimizing guarded expressions. They are mayCﬂow and
mustCﬂow analyses (cf. [1]).
Since the subject language is polymorphically typed and higher-order, we
adopt annotated-type and eﬀect systems for our analysis (cf. [11]). We deﬁne
a context ϕ to be a set of function names. Judgments for both mayCﬂow and
mustCﬂow analyses are of the form
Γˆ  e : τˆ1 ϕ
′
−→τˆ2 & ϕ
For mayCﬂow analysis (resp. mustCﬂow analysis), this means that under an
annotated-type environment Γˆ , an expression e has an annotated type τˆ1
ϕ′−→τˆ2
and a context ϕ capturing the name of those functions which may be (resp. must
be) invoked and not yet returned during the execution of e. The annotation ϕ′
above the arrow → is the context in which the function resulted from evaluation
of e will be invoked.
This type-and-eﬀect approach has been described in detail in [11]. As our
analyses follow this approach closely, we omit the detail here for space limita-
tion, and refer readers to [2] for explanation. Applying both mayCﬂow and
mustCﬂow analyses over the woven code given in Example 3a, we obtain the
following contexts for the body of each of the functions:
ϕmayk = {f, g}, ϕmayg = {f}, ϕmayf = ∅
ϕmustk = ∅, ϕmustg = {f}, ϕmustf = ∅
50 K. Chen et al.
most existing techniques to be shared. The concerns of closures and inlining
can be more straightforwardly encoded with higher-order functions and function
calls in AspectFun; whereas the complex control ﬂow of higher-order functional
languages makes the cﬂow analysis much more challenging. As a result, our typed
cﬂow analysis has little resemblance with the one in ABC which was based on
call graphs of an imperative language.
In [9], Masuhara et al. proposed a compilation and optimization model for
aspect-oriented programs. As their approach employs partial evaluation to op-
timize a dynamic weaver implemented in Scheme, the amount of optimization
is restricted by the ability of the partial evaluator. In contrast, our compilation
model is built upon a static weaving framework; residues are only inserted when
it is absolutely necessary (in case of some control-ﬂow based pointcuts), which
keeps the dynamic impact of weaving to a minimum.
6 Conclusion and Future Work
Static typing, static and coherent weaving are our main concerns in constructing
a compilation model for functional languages with higher-order functions and
parametric polymorphism. As a sequel to our previous work, this paper has made
the following signiﬁcant progress. Firstly, while the basic structure of our type
system remains the same, the typing and translation rules have been signiﬁcantly
reﬁned and extended beyond the two-layered model of functions and advices.
Consequently, advices and advice bodies can also be advised. Secondly, we proved
the soundness of our static weaving with respect to an operational semantics for
the underlying language, AspectFun. Thirdly, we seamlessly incorporated a wide
range of control-ﬂow based pointcuts into our model and implemented some
novel optimization techniques which take advantage of the static nature of our
weaver. Lastly, we developed a compiler which follows our model to translate
AspectFun programs into executable Haskell code.
Moving ahead, we will investigate additional optimization techniques and con-
duct empirical experiments of performance gain. Besides, we plan to explore ways
of applying our static weaving system to other language paradigms. In particu-
lar, Java 1.5 has been extend with parametric polymorphism by the introduction
of generics. Yet, as mentioned in [5], the type-erasure semantics of Java prohibits
the use of dynamic type tests to handle type-scoped advices. We speculate our
static weaving scheme could be a key to the solution of the problem.
Acknowledgment
We would like to thank the anonymous referees for their insightful comments.
This research is partially supported by the National University of Singapore
under research grant “R-252-000-250-112”, and by the National Science Council,
Taiwan, R.O.C. under grant number “NSC 95-2221-E-004-004-MY2”.
