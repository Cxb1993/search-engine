2 
 
中文摘要 
近幾年來，PH加密技術被應用到很多領域中，最熱門的莫過於無線感測器網路。
在這一方面，PH被應用於資料聚合(Data Aggregation)。然而，PH加密系統不能完全
的抵抗擄獲攻擊(compromising attack)。如果 PH是建構在對稱式加密機制上，在攻擊
者捕獲節點並取出相關的金鑰時，攻擊者解密並取得聚合後的資料。再者，如果 PH
是建構在非對稱式，雖然攻擊者無法解密，但他仍可加密不合法訊息已影響整個網路
的資料流。 
另一方面，Order-Preserving Encryption[18][19] 是延伸自 PH的一個新的議題。
在這一類的 PH中，強調可以透過對某些密文經過預先處理(Pre-processing)，在傳遞密
文之前先對密文進行排序。從另一個角度來看，就是針對已加密的密文進行排序。最
後，傳統的 PH加密系統僅支援代數運算，而且這個運算集合並不是完備的。到目前
為止，現有的 PH僅支援加、減、乘運算。除法運算一直是一個無法完整實作的運算。
另外，邏輯運算在現有的 PH加密系統上也是不提供的。 
在未來的三年裡，我們亦將持續有關 PH密碼系統之研究，包括Multiple Group 
Based PH Cryptosystem、Secure Comparison on Encrypted Data、Logic Operations on PH 
Schemes之研究。第一年，我們將研究並設計適用於多個群組之 PH加密系統，並且將
其應用於適合的應用環境，例如無線感測器網路(Wireless Sensor Networks)、私密資訊
提取(Private Information Retrieve )。在第二年，我們將設計一個可用於比較密文中明文
數值之大小之方法 (Secure Comparison on Encrypted Data)。在第三年，我們將研究並設
計一個嶄新的 PH加密系統，該加密系統支援所謂的邏輯運算(Logic Operations)。在底
下，我們將分年列述所要發展的 PH加密系統。 
 
關鍵詞：隱私同態加密, 代數同態密碼學, 加密資料比對, 邏輯運算 
 
 
 
 
 
 
 
 
 
 
4 
 
目錄 
1. 研究背景與目的   ...................................................................................................................... 7
2. 文獻探討   .................................................................................................................................. 8
2.1. Multiple-Group PH scheme   ......................................................................................... 8
2.2. Secure Comparison on Encrypted Data   ....................................................................... 8
2.3. Logic operations on PH schemes   ................................................................................. 9
3. 研究成果   ................................................................................................................................ 10
3.1. 第一年   ........................................................................................................................ 10
3.2. 第二年   ........................................................................................................................ 15
3.3. 第三年   ........................................................................................................................ 24
4. 國科會補助專題研究計畫成果報告自評表   ........................................................................ 31
5. 計畫綜合成果自評   ................................................................................................................ 32
5.1. Multiple-Group PH scheme   ....................................................................................... 32
5.2. Secure Comparison on Encrypted Data   ..................................................................... 32
5.3. Logic operations on PH schemes   ............................................................................... 32
6. 參考文獻   ................................................................................................................................ 33
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
6 
 
List of Figure 
Figure 1 Multiple-Application Scenario   ........................................................................................ 21
Figure 2 Multiple Applications Scenario   ....................................................................................... 24
Figure 3 The Kantarcioglu's Framework   ....................................................................................... 25
Figure 4 Encrypted Genetic Data   ................................................................................................... 28
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
8 
 
2. 文獻探討 
2.1. Multiple-Group PH scheme 
近幾年來在無線感測器網路(WSN, Wireless Sensor Networks)上的安全方面，PH被
廣泛的應用，主要是應用於資料聚合(Data Aggregation)。由於無線感測器網路天生的限
制，安全機制的設計必須是有效率的。在保持資料私密性上，通常是利用加密機制解
決。但傳統式的加密機制確保的是點對點的安全性，路徑上的節點如果想執行資料聚
合的動作(Aggregation)，必須先解密後才能對明文進行數值運算，例如加減乘除。然而，
解密不僅耗能，亦不能保持點對點的私密性。在兩者前提下，PH加密系統便是可靠的
選擇。Westhoff等人[12]、Mykletun等人[13]與 Girao等人[14]都提出了所謂私密資料
聚合技術(Concealed Data Aggregation , CDA)來解決上述問題。當然他們都是利用 PH
加密系統使得聚合節點(cluster head)得以聚合加密過的密文。透過 PH加密系統，聚合
節點可以在收到的密文上進行代數運算(algebraic operation)。透過這些技術，密文傳遞
量可以減少，同時進行必要的聚合運算。舉例來說，進行總合運算(sum)便是利用加法
特性的 PH所達成。遺憾的是，在這些方法中都不能完全的抵抗擄獲攻擊(compromising 
attack)。如果 PH是建構在對稱式加密機制上[12][14]，在攻擊者捕獲節點並取出相關
的金鑰時，攻擊者解密並取得聚合後的資料。再者，如果 PH是建構在非對稱式[13]，
雖然攻擊者無法解密，但他仍可加密不合法訊息已影響整個網路的資料流。 
2.2. Secure Comparison on Encrypted Data 
雖然很多學者對於目前 social network 的安全議題提出警告，但是多數的 social 
network服務依然沒有提供足夠的安全層級保障使用者的隱私，而有些服務本身的目的
亦與安全議題相衝突，使得此方面研究更加困難，為了便利性，多數的人在使用服務
上並不會特別關注安全問題，多數使用者寧願相信自己不會遇到此問題。 
Google map 是行動運算裝置上一個非常有名的服務，很多應用皆以此服務為基
礎，Google Latitude為其中之一，使用者可以透過行動運算裝置的 GPS功能，將使用
者的位置經由 Google Latitude告知給其朋友，亦可透過該服務找到朋友的所在位置。 
這一類服務帶來全新的應用與方便性，使用者可以分享自己所在位置的相關資
訊，或是得知朋友的位置，並且進行傳統電話服務所無法提供的應用，例如：使用者
可以發起一個活動，希望找五公里內的朋友一起唱歌，透過 Google Latitude就可以過
濾出符合條件的朋友們，並利用手機進行邀約。 
針對上述情境討論，為了使用 Google Latitude的服務所帶來的便利性，使用者必
須付出一些代價，即透過內建 GPS的行動運算裝置，將自己的位置資訊公開，犧牲個
人部份隱私，反之人人注重隱私問題，則 Google Latitude的服務即喪失了原先的目的，
10 
 
3. 研究成果 
3.1. 第一年 
1.1.1. 研究目的 
Wireless sensor networks (WSNs) are composed of several thousand or hundreds sensor 
nodes which can sense data such as temperature, moisture, smoke and so on. Many applications 
of WSNs have been proposed such as environment monitoring, accident reporting, and military 
applications[16].  
The sensor nodes have limited power and computation capability. Thus, to reduce their 
power consumption is very important. For better power utilization, cluster-based WSN [17] is a 
good choice. In such a topology, a WSN consists of several clusters. Each cluster includes several 
sensor nodes and one cluster head. To reduce the transmission cost, each cluster head aggregates 
the data from the sensor nodes in the same cluster before sending the data to the base station.  
Data aggregation can be algebraic operations on numeric data such as addition and 
multiplication or statistical operations on numeric data, such as median, minimum, maximum, 
and mean of a data set[18]. 
Since sensor nodes are prone to be captured in a hostile environment, designing a secure 
aggregation scheme is necessary. When a cluster head is captured, an adversary can fake the 
aggregated results[14]. This is identical to compromise all the sensor nodes in this cluster. In 
some studies, such as the delay aggregation[15], SIA[18], ESPDA[19], and SRDA [20] have been 
proposed to solve the problem of faking aggregated results. However, most of these schemes 
either limit the data type of aggregation or need additional transmission overhead. 
An interesting approach to solve the above problem is to aggregate ciphertexts directly. Wu 
et al. [21]proposed a scheme where the cluster head can classify encrypted data without 
decrypting them. However, it is not good enough because it only provides data filtering. Then 
Westhoff et al. [12] and Girao et al. [14] proposed Concealed Data Aggregation (CDA) which 
can solve this problem. Both schemes utilize the privacy homomorphism encryption (PH) to 
make the cluster heads aggregate encrypted data. Due to the additive and the multiplicative 
homomorphism in the PH schemes, the cluster heads can execute algebraic operations on the 
encrypted numeric data. Later, Mykletun et al. [13] adopted public-key based privacy 
homomorphism encryptions to solve this problem in a similar way.  
In some scenarios, there are multiple applications in a WSN. For example, one 
application gathers the temperature and the other gathers moisture. If we apply traditional 
PH schemes [12][13][14][22] in this scenario, we need to aggregate data separately because 
the values of temperature and moisture cannot be aggregated together. Thus, it spends 
double transmission cost than a single application. In short, the transmission cost grows with 
12 
 
the proposed scheme only utilizes the additive homomorphic property. We only describe the 
additive homomorphism of BGN scheme. The detail is described as follows:  
Setting:  
Generate the public key (PK) and private key (SK). 
• A security parameter  +∈Zτ  and compute KeyGen (τ) = (q1, q2, E) where E is a set of 
elliptic curve points which form a cyclic group. The order of E is n where n = q1q2.  
• Select two generators (or base point) Eug ∈,  randomly where ord(g) = ord(u) = n. The 
ord(g) denotes the order of g.  
• Set h = q2*u and ord(h) = q1 where * is the multiplication on the elliptic curve points.  
• Set T< q2 and let the bit length of T is approximately close to the bit length of q2. 
• Public Key: PK = (n, E, g, h, T). 
• Private Key: SK = q1. 
Encryption:  
Check if message },...,1,0{ TM ∈ . Randomly select }1,...,1,0{ −∈ nR . Encrypt M as ciphertext C: 
)()()( hRgMCMEPK ∗+∗==  
where + is the addition and * is the multiplication on elliptic curve points. If M is larger than T, 
the message should be segmented into multiple parts. 
Addition (or aggregation in WSNs):  
If two ciphertexts are )()( 111 hRgMC ∗+∗= and 
)()( 222 hRgMC ∗+∗= . Compute the aggregated ciphertext of (m1+m2), 'C . 
2121 '),( CCCCCAggregate +==  
where C’ hRRgMM *)(*)( 2121 +++= . 
Decryption: 
)*(log)(*log
*log)(
1~1~
1~
gqMhRgMq
CqMCD
gg
gSK
∗=∗+∗=
==
where gqg *~ 1= . 
 
Here we explain some symbols and definitions in the above description. First, in Setting 
part, E is a set of elliptic curve points. The order of E equals to the number of points in E. 
The generation of E is depicted in Section 5.2. Second, the order of a generator or base point 
is the minimum integer such that the multiple of itself is the identity element in the cyclic 
group. In ECC[24], the identity element is the infinite point, ∞. Assume the order of base 
point P, ord(P), is k. Then k is the minimum integer such that k*P = ∞. Third, symbol + is 
the point addition and * is the point multiplication. n*P is also called scalar multiplication on 
P where n is a scalar and P is a curve point. In ECC[24], the simplest way to calculating n*P 
is achieved by executing n-1 point additions, e.g., n*p = p+p+…+p.  
Now we use an instance to explain how the BGN scheme can be applied in WSNs. 
When a SN tries to encrypt its sensing data M, it first chooses a random number R, and 
computes the ciphertext C = M*g+R*h. Since R is randomly chosen, BGN scheme is a 
probabilistic encryption which encrypts the same plaintext to different ciphertexts for each 
encryption. After encrypting sensing data, the SN sends C to the neighboring CH. Next, 
14 
 
  '*log)'( 31~ CqqmCD qjSK == ∑  where qqqq *~ 31= . 
Note that the + and * symbols in the above description is addition and multiplication on 
elliptic curve points. 
In CDAMA (k = 2) scheme, encryption is the same as BGN scheme. The setting is 
slightly changed in our design because two public keys are required to be known for two 
groups, respectively. SNs in GA hold PKA and the others in GB hold PKB. Only the SNs in 
GA have PKA and only the SNs in GB have PKB. More preciously, these two public keys 
are only known by their corresponding group nodes. Another issue is how to distribute keys 
in each SN. The key distribution issue will be described in Section 4.5. 
The CHs only store point addition function. In addition, the major change is the 
decryption procedure in CDAMA. The BS can extract individual information for different 
groups from the aggregated ciphertexts through performing individual decryption. 
(ii) CDAMA (k>2) (Generalization in k groups) 
Similarly, CDAMA (k = 2) can be generalized to CDAMA (k > 2) scheme, for k groups 
where k > 2. The paradigm of CDAMA (k > 2) adopts different generators to construct 
different public key pairs in each group. Asymmetric public key pairs make message 
partition possible. The generalized scheme, CDAMA (k > 2) is showed in the following. 
Setting: generate the public keys (PK) and private key (SK) of each group Gi. 
• A security parameter  +∈Zτ  and compute KeyGen (τ) = (q1, q2, qk+1, E) where E is the set 
of elliptic curve points which form a cyclic group. The order of E is n where n = 
q1q2q3…qkqk+1. Pick up k+1 generating point Egg k ∈+11,..., randomly where ord(gi) = n for i 
= 1 to k+1.  
• Compute 1
1
* +
=






= ∑ k
k
i
i gqh . 
• Set Ti < qi and let the bit length of Ti is approximately close to the bit length of qi. 
• Compute Px as the following: 
kxwheregqP x
k
xii
ix ,...,1*
1
,1
=





= ∑
+
≠=
 
ord(h) = qk+1, ord(pi) = qi  where i = 1...k. 
• Gi’s Public Key (PKi): PKi = (n, E, Pi, h, Ti). 
• Private Key: SK = (q1, q2, …, qk+1). 
Encryption in Gi :  
Check if message },...,1,0{ iTM ∈ . Randomly select }1,...,1,0{ −∈ nR . Encrypt M as ciphertext C: 
hRPMCME iPK ∗+∗==)(  
Aggregation:  
Compute the aggregated ciphertext, 'C . 
2121 '),( CCCCCAggregate +==  
16 
 
Nevertheless, adversaries can forge the aggregated results through compromising keys 
inside the sensors when PH schemes [12][13][14] utilized a global key such that all sensors 
shared a single key to encrypt data in a WSN. A new PH scheme proposed by Castelluccia et al. 
[30] can avoid this problem by using individual key, where each sensor shares a unique key with 
the base station. However, each sensor needs to perform re-keying for each transmission data. 
Thus, large costs may lead to this scheme impractical. Here we note that except for data 
aggregation, PH schemes can also be applied to other applications, such as group key 
management [31] and key pre-distribution scheme [32] in ad hoc networks. 
Recently, He et al. [33] addressed a new problem about privacy-preserving data aggregation 
in WSNs. In their scheme, the cluster heads only know the aggregated result, e.g., sum of the 
sensing data set. However, it cannot retrieve the inputs before aggregation, e.g., the entities of 
sensing data set. This is another useful application in aggregation issue.  
On the other hand, secure comparison of encrypted data is useful in the WSN 
environment. Based on this comparison, some practical aggregated operations can be 
achieved, such as max and min, without decryption. With the best approach being achieved 
without decryption, M. Acharya et al. [34] proposed a scheme based on Order Preserving 
Encryption Scheme (OPES) [35] to support comparison operations. Their scheme preserved 
the order information inside the ciphers. Although adversaries cannot decrypt the ciphers, 
they can obtain max-value or min-value ciphers according to the order of encrypted data. 
Based on this, adversaries can drop the max or min data as they want. 
3.2.2. 文獻探討 
In WSNs, since sensors are prone to be captured, adversaries can launch several kinds of 
attacks. We categorize these threats into the following list. 
 Adversaries can steal the secret and key through capturing sensors. 
 Adversaries can sniff the packages in the air. 
 Adversaries can forge or modify the received packets, and send them to the legal nodes or 
base station.  
 Adversaries can selectively forward packets when they deploy some malicious nodes. 
 
Based on the threats, attacking methods are listed as follows.  
 Adversaries attempt to send forged packets to or impersonate other legal nodes while they 
compromise keys inside captured nodes.  
 Adversaries try to break the cryptosystem such as decrypting or tempering the ciphers 
without knowing any secret or keys of sensors. 
 Adversaries try to sniff sensing readings of the neighbors of the captured node. 
 
18 
 
Let E be an elliptic curve defined over a field K and let n be a positive number. Assuming the 
characteristic of K does not divide n, and then there is a pairing nn nEnEe µ→× ][][: . E[n] is a 
n-torsion point of elliptic curve E. nµ be the group of nth roots of unity in extension field L, i.e., 
}1|{ =∈= nn xLxµ . Therefore, nµ is a cyclic group of order n. Compared with the definition of 
bilinear pairing, group G is the set of n-torsion points E[n] and group G’ is nµ . Due to the limited 
space, we omit the detail in this paper. The detail can be found in [24]. 
 
Table 1 BGN Public-Key PH System 
BGN public-key PH scheme under elliptic curve construction 
Procedure Description 
KeyGen(τ) 
Input: a security parameter +∈ Zτ  
Output: a tuple (q1, q2, G) 
1. Generate G: the elliptic curve points which 
form a cyclic group which has order n 
where n = q1q2. 
2. Pick up two generators (or base point) 
Gug ∈,  randomly where ord(g) = ord(u) 
= n. 
Public Key(PK) 
Set h = q2*u. ord(h) = q1. 
PK = (n, G, g, h) 
Private Key(SK) SK = q1 
Encrypt(PK,M) 
Message space T< q2.  
Check if },...,1,0{ TM ∈  
Choose random }1,...,1,0{ −∈ nR  
Cipher C is computed as: )()( hrgMC ∗+∗=  
Decrypt(SK,C) 
)()( 111 gqMhRgMqCq ∗=∗+∗=∗  
CqM g 1~log=  where gqg 1
~ = . 
Aggregate(C1, C2) 
)()( 111 hRgMC ∗+∗=
)()( 222 hRgMC ∗+∗=  
C’ is the aggregated cipher of (m1+m2). 
C’ = C1 + C2 + R’h where }1,...,1,0{' −∈ nR  
hRRRgMM
hRhRgMhRgM
hRCCC
)'(*)(
'*
''
2121
2211
21
++++=
+∗+∗+∗+∗=
++=
 
+ is the addition on elliptic curve points. * is the multiplication on the elliptic curve points.  
* is achieved by recursive additions +.  
Calculating n*p should add point p by n times, e.g., n*p = p+p+…+p. 
If M is larger than T, the message should be segmented into multiple parts. 
 
20 
 
Cipher C is computed as: 
hRqMC ∗+∗=  
Aggregate(C1, C2) 21 CCC += , C is the aggregated message. 
Where  
hrqmpmC
hrqmpmC
jlk
iji
)()()(
)()()(
2
1
∑+∑+∑=
∑+∑+∑=
 
Ai GinmessageaggregatedThem :∑  
Bj GinmessageaggregatedThem :∑  
Decrypt(SK,C) C is the aggregated message. 
General form of C. 
hrqmpmC iji )()()( ∑∑∑ ++=  
Retrive the aggreated message in GA. 
Cqqm gi 31~log=∑  where pqqg 31
~ = . 
Retrive the aggreated message in GB. 
Cqqm gj 21~log=∑  where qqqg 21
~ = . 
+ is the addition on elliptic curve points. * is the multiplication on the elliptic curve points. 
If M is larger than T, the message should be segmented into multiple parts. 
 
In BGN-EXT-2 scheme, encryption is the same as the BGN scheme. The key generation is 
slightly changed in our design since the public key should be different in each group. Sensors in 
GA hold PKA and others in GB hold PKB. Noted that PKA is only shared with sensors in GA and 
PKB is only shared with sensors in GB. The cluster heads only store point addition function. In 
addition, the aggregation is also tailored for two purposes. First, it should be developed to 
aggregate messages not only inside the same group but also coming from different groups. 
Second, aggregation would be performed by aggregators and sensors. Comparing with previous 
aggregation schemes, the proposed scheme is more efficient. The major change is the decryption 
procedure in our design. Since the aggregated message formed by different groups, the base 
station should extract individual aggregated data through performing individual decryption for 
each groups. 
 
Concrete example 
Now we use an example to describe the procedure of BGN-EXT-2 scheme. Fig. 1 illustrates a 
WSN consist of three clusters. Each sensor belongs to one group, GA or GB. Sensor A1, A2 and 
A3 in GA hold PKA=(p, h). Others in GB, B1, B2 and B3 hold PKB=(q, h). The three cluster 
heads ranges from CH1 to CH3, and CH4 is the aggregator which gathers all messages from 
CH1~CH3. For simplicity, the order of p, q, and h are setting small. In this example, we set 
ord(h)=q1=17, ord(p)=q2=19, ord(q)=q3=23, and n=q1q2q3=7429.  
In Fig. 1, cluster 2 and 3 represents a simple case while sensors are in the same group. 
Aggregation seems to be simple. Sensors C3 and C4 encrypt their message m3(7) and m4(4) as 
C3 = 7q+6h and C4 = 4q+8h. Hence, CH2 aggregates C3 and C4 as 
22 
 
Groups 
KeyGen(τ) Input: a security parameter 
+∈ Zτ  
Output: a tuple (q1,…,qk+1 ,G) 
Generate G: the elliptic curve points which 
form a group of order n. n= 
q1q2q3…qkqk+1. 
Pick up three generating point 
Ggg k ∈+11,...,  randomly where the order 
of them are n. 
Gi’s Public Key PKi Set h and Px as the following: 
1
1
* +
=






∑= k
k
i
i gqh
, 
kxwheregqP x
k
xii
ix ,...,1*
1
,1
=







∑=
+
≠=  
ord(h) = qk+1, ord(pi) = qi  where i =1...k. 
PKi = (n, G, pi, h) where i = x. 
Private Key (SK) SK = (q1,q2,…,qk+1) 
 
Encrypt(PKi, M) in 
Gi 
Check if M ∈ {0,1,2,…,T} where T < qi. 
Choose random }1,...,1,0{ −∈ nR  
Cipher C is computed as: hRPMC i ** +=  
Aggregation(Ci, Cj) 
hrpmC
hrpmC
jjkj
iiii
∑+∑=
∑+∑=
  
C’ is the aggregated message. 
ji CCC +='  
Decrypt(SK,C) 
C is the aggreated 
cipher. 
hrpmC i
k
i
ii ∑∑∑ +=
=0
*)(
 
Extract the aggregated message from group x  
as follows:. 
∑=∑=∑
+
≠=
+
≠==
1
,1
1
,1
~ ~log
k
xii
i
k
xii
ig
xi
i qgwhereCqm
 
+ is the addition on elliptic curve points. * is the multiplication on the elliptic curve points. 
 
Re-Encryption functionality 
PH schemes offer an additional functionality, re-encryption, which can provide data privacy. 
Assuming the public key of the sensor is (g, h), then the re-encryption procedure is defined in 
A.1. 
24 
 
 
Figure 2 Multiple Applications Scenario 
 
 
 
 
 
 
 
 
 
 
 
3.3. 第三年 
3.3.1. 研究目的 
Kantarcioglu et al.' proposed an approach [36] to protect the privacy of genetic information 
and operate on encrypted tuples at the same time. Their framework incorporate four participants: 
data holders, data users, a data storage site (DS), and a key holder site (KHS). Note that data 
holders are a set of hospitals and data user are a set of biomedical researchers. In order to query 
or operate on the encrypted tuples, they applied a well-known homomophic public-key 
26 
 
Bilinear Pairings 
Let G1 and G2 be two (multiplicative) cyclic groups of large prime order p. Let g be a 
generator of G1. A bilinear pairing e : G1 X G1 → G2  is mapping function that mapping two 
elements in G1 onto a single element in G2. The function satisfies the following properties: 
 Bilinearity : abba vuevue ),(),( =  for all 1, Gvu ∈  and *, pZba ∈  
 Non-degeneracy : 1),( ≠gge  
 Computable : There is an e±cient algorithm to compute ),( vue . 
With above properties, we say e is a bilinear group. 
 
Boneh's Homomorphic Public Key System 
The proposed scheme makes use of the homomorphic public-key encryption system 
proposed by Boneh et al. [8] Boneh's homomophic public-key system is a privacy 
homomorphism (PH) scheme. The concept of PH was firstly introduced by Rivest, Adleman and 
Dertouzos [1]. A privacy homomorphism is an encryption transformation that allows computing 
on encrypted data. Formally privacy homomorphism can be defined as an encryption function E 
which has efficient algorithms to compute E(xy) and E(x + y) from E(x ), E(y) without revealing 
x and y. Some famous Privacy Homomorphism have been proposed, such as 
Goldwasser-Micali[38], Paillier[7], Naccache-Stern cryptosystem[4], Fujisaki-Okamoto 
cryptosystem[6] and Domingo-Ferrer's two algebraic PHs[10][39]. This system is similar with the 
Okamoto-Uchiyama and the Paillier encryption schemes. Boneh et al.' system is introduced as 
following: 
 Key Generation: Given a security parameter +∈ Zk . Let e is bilinear mapping from G to G1, 
where G is the group of the point on elliptic curve E over Fp and p is prime. The group order 
of G and G1 are n and n=q1*q2 where q1 and q2 are prime. Choosing two random generator g, 
u ← G and set 2quh =  . Then h is a random generator of the subgroup of G of order q1. Let 
public key is a tuple(n, G, G1, e, g, u) and private key is q1. 
 Encryption: Assuming the message space T = 1. Choosing a random number 
}1,...,1,0{ −∈ nr . It encrypts a binary bit in following steps: 
GhgC rm ∈=  
 Decryption : It decrypts a ciphertext C through 
mqqrqmqrmq
sk gughgCCD )())(()()(
11211 ====  where sk is private key 
The discrete logarithm 1qC  of  base 1qg  is computable. 
Sinece Boneh's homomorphic scheme[8] supports additive and multiplicative operations on 
encrypted data. The homomorphic properties are described as following: 
 There are two binary bit a and b. Epk(a) and Epk(b) are represented as ciphertexts by using 
public key encrypting, where rapk hgaE =)(  and 
sb
pk hgbE =)( . Choosing a random number 
28 
 
 
Figure 4 Encrypted Genetic Data 
 
Security Framework 
Here, we describe the proposed framework clearly and describe how the encrypted sequence 
are used for querying. Figure 1 shows a complete perspective of the procedure.  
 Step 1 (Key Generation) : KHS generates a pair of public key and private key. The public 
key is widely distributed to all participants and a secret key is held by KHS. Anyone encrypt 
original genetic sequence by PK. However, the encrypted genetic sequence only can be 
decrypted by KHS. 
 Step 2 (Data Encryption) : While a data holder desires to share the genetic data with 
researchers, it first encrypts the genetic data with PK. Next, the data holder sends the 
encrypted result to the DS. After receiving the encrypted genetic data, the DS inserts a new 
genetic sequence into the database. 
 Step 3 (Design Query Statement) : The genetic database includes n-tuples. Each tuple is 
represented as a character or an attribution. The query statement can merge arbitrary tuples 
for investigation. For an instance, an query syntax consists of “(AACC OR GGTT)”. This 
query statement maybe describe that researchers merge the first, the third, the fifth and the 
eighth tuple to desire the records including “AACC” OR “GGTT”. Because the proposed 
scheme apply Boneh's homomorphic scheme, the query statement has the presentation of 
query restriction. Hence, the query statement must satisfy the following two case. 
Case 1: Only An AND 
The presentation of query statement can be shown as follows: 
( κ OR ... ORκ) AND (κOR ... ORκ) where },,,{ TGCA∈κ  
For an instance, an query syntax consists of “(A OR G OR C) AND (A OR T)”. 
Case 2: Only An OR 
The presentation of query statement can be shown as follows: 
30 
 
 
 
This section analysis the proposed scheme and compare with Kantarcioglu's approach. The 
following focus on ciphertext length and query times. 
 
Ciphertext Length 
The proposed scheme uses Boneh's scheme which based on elliptic curve encryption[40][41]. 
Since a genetic sequence is composed by k two-bits characters and Boneh's scheme handles 160 
bits ciphertext per bit, the length of an encrypted genetic sequence is 320*k bits. In contrast, the 
length of encrypted genetic sequence in Kantarcioglu's scheme is 1024*k bits. To conclude, the 
length of encrypted genetic sequence in proposed scheme are shorter than Kantarcioglu's scheme. 
 
Query Times 
This subsection analysis querying times of querying process. When biomedical research 
investigations become more complex, researchers needs more efficient query. In Kantarcioglu's 
scheme, biomedical research has querying restriction problem. If researcher needs complex 
querying syntax, such as “(AA OR AG OR GA OR GT)”. The DS-COUNT protocol needs to be 
executed 4 times for querying results. In contrast, the DS-COUNT protocol of proposed scheme 
just needs to be executed one times. This subsection does not consider the comparison of 
KHS-COUNT between proposed scheme and Kantarcioglu's scheme, since the executing time are 
almost same. To conclude, the proposed scheme has more flexibility. 
This paper enhances the flexibility of querying syntax in Kantarcioglu's scheme. A 
researcher can execute a complex querying syntax once for desired results. Since the proposed 
scheme use Boneh's scheme which based on elliptic curve cryptography (ECC), the length of the 
encrypted genetic sequence is shorter than Kantarcioglu's scheme. Besides, the encrypted genetic 
sequence can confirm that privacy issue. 
 
 
32 
 
5. 計畫綜合成果自評 
5.1. Multiple-Group PH scheme 
本計劃順利提出一可應用於無線感測網路之多群組安全資料聚合演算法，過去所提出
的安全資料聚合演算法，大部份是防止CH被compromised進而影響到整個網路，其演算法
只能允許網路中所有節點皆執行同一種應用，而我們提出來的演算法是第一個應付多個應
用同時存在網路的演算法，我們的方法允許整個網路之中，存在執行不同應用的節點同時
存在，將所收集到的訊息加密傳送給CH，當CH收到節點所傳送的訊息後，雖然是不同應
用的訊息，仍然可以將這些加密過的訊息聚合成一份，再將聚合後的結果送往基地台處理。 
 
5.2. Secure Comparison on Encrypted Data 
本計畫除了完善去年計畫之多群組安全資料聚合演算法外，亦以去年成果為主，提出
一加密比較演算法，目的在於增加安全資料聚合演算法之功能，過去所提出的安全資料聚
合演算法，大部份是防止cluster head(CH) 被compromised進而影響到整個網路，其演算法
只能允許網路中所有節點皆執行同一種應用，而我們提出來的演算法是第一個應付多個應
用同時存在網路的演算法，我們的方法允許整個網路之中，存在執行不同應用的節點同時
存在，將所收集到的訊息加密傳送給CH，當CH收到節點所傳送的訊息後，雖然是不同應
用的訊息，仍然可以將這些加密過的訊息聚合成一份，再將聚合後的結果送往基地台處理。
而有關加密比較的部份，過去當基地台得聚合後的資料，通常會將資料進行解密，並從中
得到所需要的部份，而我們提出的演算法則可以讓中間的CH在不解密的情況下，對於收到
的密文進行排序或選擇極值之動作，減少不必要的動作與資料傳輸，更加有效的節省能源
之消耗。 
 
5.3. Logic operations on PH schemes 
在最後一年，我們將研究並實作一個具有邏輯運算的PH加密系統。我們以Kantarcioglu 的
架構作為基礎，並利用了 Boneh 的密碼演算法來針對基因資料庫做加密運算。我們的方法
可以讓研究員對加密的基因資料庫執行一個複雜的查詢語法，以獲得所需的研究結果。並
且，我們依然可以同時保存位於基因資料庫裡的基因資料的安全性。 
 
34 
 
[14]. J. Girao, M. Schneider, and D. Westhoff, “CDA: Concealed Data Aggregation in 
Wireless Sensor Networks,” Proc. ACM Workshop on Wireless Security (WiSe’ 04), Oct. 
2004. 
[15]. D Wagner, “Cryptanalysis of an Algebraic Privacy Homomorphism” Proc. 6th Int. Conf. 
Information Security (ISC 2003), Springer, 2003. 
[16]. I.F. Akyildiz, W. Su, and Y. Sankarasubramaniam and E. Cayirci, “A survey on sensor 
networks,” IEEE Comm. Magazine, Vol . 40, Issue 8, Aug 2002, pp. 102-114. 
[17]. W.R. Heinzelman, A.P. Chandrakasan, and H. Balakrishnan, “Energy-Efficient 
Communication Protocol for Wireless Microsensor Networks,” Proc. the 33rd Annual 
Hawaii Int. Conf. 4-7, vol.2, Jan 2000, pp. 3005-3014. 
[18]. B. Przydatek, D. Song, and A. Perrig, “SIA: Secure Information Aggregation in Sensor 
Networks,” Proc. the First ACM Conf. Embedded Networked Sensor Systems, Nov 
2003, pp. 255-265. 
[19]. H. Cam, S. Ozdemir, P. Nair, and D. Muthuavinashiappan, “ESPDA: Energy-Efficient 
and Secure Pattern Based Data Aggregation for Wireless Sensor Networks,” Proc. 5th 
IEEE Conf. Sensors, 2003, pp. 732-736. 
[20]. H. O. Sanli, S. Ozdemir, and H. Cam, “SRDA: Secure Reference-Based Data 
Aggregation Protocol for Wireless Sensor Networks,” Proc. IEEE Conf. Vehicular 
Technology (VTC’04), 2004, pp. 4650-4654. 
[21]. Y. Wu, D. Ma, T. Li, and R. H. Deng, “Classify Encrypted Data in Wireless Sensor 
Networks,” Proc. IEEE Conf. Vehicular Technology (VTC’04), 2004, pp. 3236-3239. 
[22]. E. Mykletun, J. Girao, and D. Westhoff, “Public Key Based Cryptoschemes for Data 
Concealment in Wireless Sensor Networks,” IEEE International Conf. Communications 
(ICC '06), 2006, pp. 2288-2295. 
[23]. N. Koblitz, A. Menezes and S. Vanstone, “The State of Elliptic Curve Cryptography,” 
Journal of Designs, Codes and Cryptography, Vol. 19, Springer, Mar 2000, pp. 
173-193. 
[24]. L.C. Washington, Elliptic Curves – Number Theory and Cryptography, Chapman & 
Hall/CRC, 2003. 
[25]. R. Zheng, R. Barton, “Toward Optimal Data Aggregation in Random Wireless Sensor 
Networks,” Proc. the 26th Ann. Joint Conf. the IEEE Computer and Comm. Society 
(INFOCOM’07), pp. 249-257, 2007. 
[26]. S.CH. Huang, P.J. Wan, C. T. Vu, Y. Li, and F. Yao, “Nearly Constant Approximation 
for Data Aggregation Scheduling in Wireless Sensor Networks,” Proc. the 26th Ann. 
Joint Conf. the IEEE Computer and Communications Society (INFOCOM’07), pp. 
36 
 
[39]. J. Domingo-Ferrer, \A New Privacy Homomorphism and Applications", Information 
Processing Letters, Vol. 60, no. 5, pp. 277-282, Dec.1996. 
[40]. V. Miller, Use of elliptic curves in cryptography, CRYPTO 85, 1985. 
[41]. N. Koblitz, Elliptic curve cryptosystems, in Mathematics of Computation 48, 1987, pp. 
203-209 
 
 
 
III. THE PROPOSED PROTOCOL 
In this scheme, we partition our protocol into three parts. 
The first part is topology-construction. The second part is 
data processing. The third one is verification. Next, we will 
show the detailed protocol in three parts. 
A. Topology Construction 
After deployment of sensor nodes, the base station 
requests all sensor nodes to construct a topology tree [3]. 
First of all, the base station broadcasts a topology-
construction message. The message contains a sensing 
request and an aggregation function. The detailed format of 
the message is shown in table II. Before broadcasting this 
message, the base station sets the source address and original 
address as itself. The hopCount is represented as the hops to 
the base station.  The base station initializes hopCount as 
zero. The sensing type could contain temperature, humidity 
and so on. The default aggregation function is the average. 
Upon receiving the request, each sensor node executes 
the following steps. First of all, it checks whether it received 
the request or not.  If not, it marks the source node of this 
message as it parent. In the meanwhile, it records the 
hopCount into its storage. Then, it increases the variable 
hopCount by one. If a node receives the same request, it 
compares the new hopCount with its own. If the new one is 
larger than the original, it records the node as it uncle. If the 
new one is larger than its own one, it records the node as its 
child. If the two ones are equal, it records the source node as 
its sibling.  
Finally, each node can be aware of its parent, uncles, 
sibling and children in the topology. In the meanwhile, each 
node also informs the base station the relations with its 
neighbors along with its hopCount. Hence, the base station 
can know the topology of the whole networks. Fig. 1 shows 
an example of aggregation tree. 
 
Figure 1.  An example of aggregation tree 
TABLE II.  THE QUERY MESSAGE 
Source 
address 
Original 
address 
Sequence 
number 
HopCount Sensing 
type 
Aggregation 
function 
 
B. Data Processing 
After the first step, each sensor node knows all its 
neighbors. In the second step, leaf nodes and aggregators 
perform different data processing according to the contents 
of messages. For instance, the contents of a message can be 
classified as an emergent event or a usual event. When an 
emergency happens, sensor nodes could transmit it by single 
routing path or multiple routing paths. On the contrary, the 
usual event is only sent by one path. Next, we will show the 
two methods. 
In the second step, leaf nodes sense data and transmit the 
readings to aggregators. After receiving data from children, 
aggregators categorize these data. If there is an abnormal 
value, the aggregator will append this one to the packet. 
Otherwise, the aggregator just performs aggregation based 
on the aggregation function. Finally, the base station can 
collect all messages from aggregators and perform further 
analysis. 
In single-path routing, only one aggregator will send the 
same emergent message. 
1) Leaf node 
All leaf nodes sense environment and forward sensing 
data to their parents. As shown in Fig. 2, we take node N, O 
and G for example. Firstly, node N generates a timestamp TN 
and encrypts its identifier IDN, sensing data DN and the 
timestamp TN by utilizing the pairwise key shared with node 
G. If DN is located out of the predefined range, node N 
generates a MAC by using the secret key shared with the 
base station and append the MAC to the packet. In the 
meanwhile, node N also evaluates the receiving 
acknowledgement time from the base station. Finally, it 
stores the next hop address, packet transmitting time and the 
expected time for receiving an acknowledgement from the 
base station into a table. The transmission table is shown in 
table III. On the contrary, DO is within the threshold. Hence, 
node O does not commute the corresponding MAC. Next, 
the followings are the payload of the transmitted packet. 
N  G: IDN |TN | E(KN,G, IDN|DN|TN) | MACN(KN, IDN|DN|TN) 
O  G: IDO |TO | E(KO,G, IDO|DO|TO )  
2) Aggregator  
An aggregator receives messages from its children and 
decrypts them. Firstly, it checks whether the abnormal value 
exists. If yes, it encrypts the original sender’s ID, sensing 
value and the timestamp and forms an encrypted unit. In the 
meanwhile, it also maintains the original MAC. Finally, it 
appends the encrypted unit and the MAC. If not, it just 
aggregates these sensing data, encrypts them and forwards to 
its parent. The step continues until the base station receives 
all aggregated results.  
C. Verification 
Whenever the base station receives messages from 
aggregators, it can verify the correctness and validity. In the 
second step, a leaf node which senses the emergent event 
must append the MAC value computed by its own unique 
secret key, its identifier, sensing value and the timestamp. 
Whenever the base station receives the emergent message 
from aggregator, it can identify the original sender at first 
1042
2) A compromised node modifies a usual message to an 
emergent one 
In Fig. 4, node A senses its readings and sends a usual 
message to node B. After receiving the message, node B 
performs some processing and forwards it. Similarly, node C 
receives the packet form node B but it alters the contents of 
the message. In order to cheat the base station, node C 
fabricates a key KA’. Transmitted messages are shown as 
below.  
A  B: IDA|TA|E(KA,B, IDA|DA|TA) 
B  C: IDB|TB|E(KB,C, IDB|DB|TB) 
CBS:IDC|TC|E(KC,BS,IDC|DC|TC)|E(KC,BS,IDA|DA|TA)|MACA(
KA’, IDA|DA|TA) 
 
After collecting these messages, the base station can 
decrypt all packets and be aware of that node A produces the 
emergent message. Then, the base station can retrieve KA 
and compute the MAC value. Finally, it discovers the forged 
MAC message. 
  
 
Figure 4.  Altering attack 
 
3) A compromised node alters the timestamp of an 
emergent message  
An adversary could not only save the overhearing 
messages but also alter the timestamp to conform to the 
reasonable value. For instance, node A transmits an emergent 
message to node B.  
A  B: IDA |TA | E(KA,B, IDA|DA|TA) | MAC(EA, IDA|DA|TA) 
When node B receives the packet, it maintains the 
message. At next query, in order to cheat the base station, 
node B modifies the timestamp TA to TA’. The message will 
be also processed by node B. Finally, the base station 
receives a message shown as below.  
BC:IDB|TB|E(KB,C,IDB|DB|TB)|E(KB,C,IDA|DA|TA’)|MACA(
KA, IDA|DA|TA) 
CBS:IDC|TC|E(KC,BS,IDC|DC|TC)|E(KC,BS,IDA|DA|TA’)|MAC
A(KA, IDA|DA|TA) 
The message will be forwarded until the base station 
receives it. Then, the base station deciphers the message and 
obtains the identifier IDA, sensing data DA and timestamp 
TA’. Then the base station can use the uniquely shared key 
KA to generate the corresponding MAC value. The MAC 
value computed by the base station is not equal to MAC 
value of the packet. Then, the base station can know the 
contents of the message altered.  
C. Replay attack resistance 
In order to prevent an attacker from performing the 
replay attack, each sensor node which senses an emergent 
event has to add the timestamp to display the timing of that 
event. In the meanwhile, each one also generates a MAC 
value which is computed by the identifier of the message 
generator, the sensing readings and the timestamp. For 
example, node A sends an emergent message to the base 
station where the timestamp is TA. Then, an adversary can 
overhear in the transmission of messages and record the 
emergent message into its storage. After a period or until 
next query, the attacker will retrieve these stored messages 
and resend them. When the base station receives the packet, 
it can decrypt the message and gain prior timestamp TA. The 
base station will compare TA and TBS produced in accordance 
with its own clock. In general, TA is less than TBS. The result 
of TBS-TA should be between [0, ] where  is a predefined 
positive number. If TBS-TA is larger than , the base station 
can identify the replayed message and ignore it. 
D. Dropping resistance  
In this paper, we focus on the transmission of emergent 
messages. Hence, the dropping of usual packets is not under 
consideration.  
 Attack models in wireless sensor networks are similar 
with ad hoc networks. An adversary can drop packets 
arbitrarily. She can drop all receiving packets or specific 
ones such as sinkhole attacks or selective forwarding. In 
order to resist packet dropping, we proposed that the base 
station has to reply an acknowledgment for each emergent 
packet. A sensor node which senses an emergency must 
record the transmission time. In the meanwhile, it can 
compute the time to receive an acknowledgment from the 
base station. If time expires, the node retransmits the 
emergent packet and requests another node to forward it. 
Finally, the message can arrive at the base station unless the 
attacker can compromise all the neighbors of the source 
node. 
The mechanism of retransmission causes messages 
delayed. Hence, each node that receives the emergent 
message can exploit multi-path routing to forward it. In 
general, an attacker can only capture a small amount of 
sensor nodes. Hence, she cannot drop these emergent 
messages completely. In Fig. 5, we present that how the 
multi-path routing can indeed resist the packet dropping 
attacks.  
 
 
Figure 5.   Resistance to dropping packets 
 
E.  Forging detection 
An adversary could impersonate a leaf node and forge an 
emergent message. Whenever other nodes receive the 
falsified message, they cannot verify the correctness.  So 
they just forward it to the base station. After collecting 
messages, the base station can recognize the identifier and 
retrieve the corresponding shared unique keys. Then, the 
1064
In general, most data aggregation protocols proposed that 
the base station issues a query along with the seed. Then, 
whenever a sensor node has to send its reading along with 
the seed and compute a MAC by using the identifier, data 
and the seed. When the base station receives the MAC values 
from nodes, it can verify them and the query seed. 
Nevertheless, a query seed cannot present the real time of an 
event. Hence, we utilize a timestamp instead of a query seed. 
In the meanwhile, a timestamp represents a computation for 
system time. The comparisons of computational cost are 
shown in Table VII.  
We denote that the length of the node’s identifier is i 
bytes, the sensing value is d bytes, the output of MAC value 
or hash functions is m bytes, a query seed is s bytes, a 
timestamp is t bytes, all other numbers are l bytes and the 
network size is n. In addition, the length of synopsis is k 
bytes and the sensing range is r. For instance, the measurable 
range is between 0 and 99, so r is 100. 
In some of these protocols, the length of transmitted 
message would change according to hops. Hence, we 
analyze the communication cost in accordance with the 
initial length of a transmitted message by a source node.  
In [4], the length of transmitted message would increase 
as long as any inner ring’s node appends a MAC value to the 
synopsis. In [5], the message length is associated with not 
only the network size, sensing range but also the message 
space. In [6], each sensor node has to send the pattern code, 
its identifier and a timestamp to the aggregator at first time. 
After comparisons of pattern codes, an aggregator will 
request that some nodes send their identifier, the real values 
to the base station at second time.   
In [9], one bit is used to represent the transmitted data are 
aggregated or not. As compared with other similar protocols, 
the proposed scheme increase communication cost a little [8] 
[9] [10]. On the contrary, the proposed protocol can achieve 
higher security than others. The comparisons of 
communication cost are shown in Table VIII. 
TABLE VIII.  COMPARISONS OF COMMUNICATION COST 
communication cost  
schemes 
# of bytes 
Roy [4] k+m 
Castelluccia [5] logr+logn 
Çam [6] l+t+2i+d 
Wagner [7] – 
Hu [8] i+d+m 
Yang [9] i+d+s+m+l+1 bits 
Chan [10] l+2d+m 
Proposed scheme 2l+d+2t+m 
6) Comparisons of application environment  
In general, previous data aggregation protocols do not 
deal with outlier values. These prior protocols could induce 
some consequences as they neglect the real meaning of 
outlier data. For instance, an extremely high temperature 
could represent a fire. However, the process of data 
aggregation could cause the high extremely high value 
become unobvious. Therefore, the base station cannot be 
aware of the event. 
In order to solve the previous problem, this paper mainly 
focuses on addressing outlier sensing data. The scheme 
proposes that an outlier value should be appended into the 
message so that the base station can notice it obviously. 
Then, the base station can analyze these values and perform 
corresponding actions. 
V. CONCLUSIONS 
We proposed a lightweight secure data aggregation 
protocol for emergency detection in wireless sensor 
networks. In this paper, we focus on designing a solution to 
protect from altering, forging and dropping packets. At the 
end of this paper, we analyze the security and cost of the 
solution. In the future, we will involve some topics into our 
protocol. The first one is that to add public key based data 
aggregation into our protocol. The second one is that to 
distinguish an attacker from an attacker.  
 
ACKNOWLEDGMENT 
This work was supported in part by the National Science 
Council, Taiwan, under Contract NSC 97-2221-E-007-055-
MY3 and NSC 99-2218-E-007-012. 
 
REFERENCES 
[1]  A. Perrig, J. Stankovic, and D. Wagner, “Security in wireless sensor 
networks,” Communications of the ACM, Volume 47, Pages: 53-57, 
June 2004. 
[2] A. Perrig, R. Szewczyk, V. Wen, D. Culler, and D. Tygar, “SPINS: 
Security Protocols for Sensor Networks,” Wireless Networks Journal 
(WINE), Volume 8, Pages: 521-534, September 2002. 
[3] M. Ding, X. Cheng, and G. Xue, “Aggregation Tree Construction in 
Sensor Network,” Vehicular Technology Conference, IEEE 58th, 
Volume 4, Pages: 2168–2172, October 2003. 
[4] S. Roy, S. Setia, and Sushil Jajodia, “Attack-resilient hierarchical 
Data Aggregation in Sensor Networks,” Proceedings of the fourth 
ACM workshop on Security of ad hoc and sensor networks (SASN 
'06), Pages: 71–82, ACM Press, October 2006. 
[5] C. Castelluccia, E. Mykletun, and G. Tsudik, “Efficient Aggregation 
of Encrypted Data in Wireless Sensor Network,” Mobile and 
Ubiquitous Systems: Networking and Services (MobiQuitou ‘05), the 
Second Annual International Conference, Pages: 109-117, July 2005.     
[6] H. Çam, S. Özdemir, P. Nair, D. Muthuavinashiappan, and H. O. 
Sanli, “Energy-efficient secure pattern based data aggregation for 
wireless sensor networks”, Computer Communications, Volume 29, 
Pages: 446-455, February 2005. 
[7] D. Wagner, “Resilient Aggregation in Sensor Networks,” Proceedings 
of the ACM workshop on Security in Ad Hoc and Sensor Networks 
(SASN’04), Pages: 78–87, ACM Press, October 2004. 
[8] L. Hu, and D. Evans, “Secure Aggregation in Sensor Network,” 
Proceeding of Workshop on Security and Assurance in Ad Hoc 
Networks, Pages: 384-391, January 2003. 
[9] Y. Yang, X. Wang, S. Zhu, and G. Cao, “SDAP: A Secure Hop-by-
Hop Data Aggregation Protocol for Sensor Networks,” Proceedings 
of the seventh ACM international symposium on Mobile ad hoc 
networking and computing (MobiHoc '06), Pages: 356–367, ACM 
Press, May 2006. 
[10] H. Chan, A. Perrig, and D. Song, “Secure Hierarchical In-Network 
Aggregation in Sensor Networks,” Proceedings of the 13th ACM 
conference on Computer and communications security (CCS’06), 
Pages: 278–287, ACM Press, October 2006.   
1086
A Gen2-Based RFID Authentication Protocol
for Security and Privacy
Hung-Min Sun and Wei-Chih Ting
Abstract—EPCglobal Class-1 Generation-2 specification (Gen2 in brief) has been approved as ISO18000-6C for global use, but the
identity of tag (TID) is transmitted in plaintext which makes the tag traceable and clonable. Several solutions have been proposed
based on traditional encryption methods, such as symmetric or asymmetric ciphers, but they are not suitable for low-cost RFID tags.
Recently, some lightweight authentication protocols conforming to Gen2 have been proposed. However, the message flow of these
protocols is different from Gen2. Existing readers may fail to read new tags. In this paper, we propose a novel authentication protocol
based on Gen2, called Gen2þ, for low-cost RFID tags. Our protocol follows every message flow in Gen2 to provide backward
compatibility. Gen2þ is a multiple round protocol using shared pseudonyms and Cyclic Redundancy Check (CRC) to achieve reader-
to-tag authentication. Conversely, Gen2þ uses the memory read command defined in Gen2 to achieve tag-to-reader authentication.
We show that Gen2þ is more secure under tracing and cloning attacks.
Index Terms—Protocol design and analysis, security, privacy.
Ç
1 INTRODUCTION
RADIO Frequency Identification (RFID) tags for thefunction of next-generation electronic product code
(EPC) will become one of the most widely used devices
in the near future [1]. An RFID application contains three
basic roles:
1. tag,
2. reader, and
3. back-end database.
Each tag contains a unique identification, often called
the tag identification (TID). The reader is used to query the
tag’s TID and forward it to the back-end database. Once the
tag is found valid, the back-end database will look up its
product information for further processing. RFID tags are
classified into three types: active, semipassive, and passive.
Active tags contain batteries so that they can actively
communicate with the reader. Semipassive tags also contain
batteries but they wait for the reader’s query. As for passive
tags, the power comes from the reader. The class of a tag
represents the effective reading range. The reading range of
a class-0 tag is 5-10 cm, and that of a class-1 tag is up to
several meters.
EPCglobal class-1 generation-2 (Gen2 in brief) [2] was
approved as ISO18000-6C in July 2006. It is widely believed
that Gen2 tags will be the mainstream when developing
RFID applications because the effective reading range is
larger. However, the Gen2 specification has the vulner-
ability that the TID is transmitted without any guard. Thus,
in this paper, we focus on the protection of class-1 passive
tags from being accessed by malicious readers.
1.1 Security Threats
Previous studies [1], [3], [4], [5], [6], [7] addressed several
threats to RFID applications:
. Eavesdropping: An adversary listens to all the com-
munications through Radio Frequency (RF) and
dumps them for later cracking.
. Hotlisting: This attack, similar to eavesdropping,
focuses on matching specific values with his chosen
keywords to understand one’s personal interests,
like his favorite books or his reading behavior.
. Replay attack: An attacker repeats the same messages
logged from eavesdropping to spoof a reader or tag.
. Cloning: Since RFID tags are usually placed in open
environments such as hospitals, schools, and offices,
they may be exposed under all kinds of malicious
tools. An adversary can read the tag and then clone
the tag by writing all the obtained data into a
blank tag.
. Tag tracing: Readers and tags have different abilities
of sending data. Attackers can either identify the
same tag from passively logged messages or interact
actively with the tag to understand its location.
. Invading privacy: Customers may not want eaves-
droppers to know what items they have bought from
the store, which may indicate their interests.
. Data forging: Once RFID technology becomes the
mainstream of retailing, a tag may store extra data
such as date, price, and the place of production for
convenience. However, this also attracts attackers to
modify the price and cause great loss.
. Denial of service: It is an effective attack against some
RFID systems, which utilize locking or killing
approach as their protection. Even though this is
the weakest test when designing secure protocols,
1052 IEEE TRANSACTIONS ON MOBILE COMPUTING, VOL. 8, NO. 8, AUGUST 2009
. The authors are with the Department of Computer Science, National Tsing
Hua University, 101, Kuang Fu Road, Sec. 2, Hsinchu, Taiwan 300, ROC.
E-mail: hmsun@cs.nthu.edu.tw, sd@is.cs.nthu.edu.tw.
Manuscript received 20 Nov. 2007; revised 2 Aug. 2008; accepted 9 Dec. 2008;
published online 18 Dec. 2008.
For information on obtaining reprints of this article, please send e-mail to:
tmc@computer.org, and reference IEEECS Log Number TMC-2007-11-0348.
Digital Object Identifier no. 10.1109/TMC.2008.175.
1536-1233/09/$25.00  2009 IEEE Published by the IEEE CS, CASS, ComSoc, IES, & SPS
practice. The cost of encryption functions remains high
nowadays. Hash function with the uninvertible character-
istic seems to be an excellent candidate for low-cost tag
design. However, the cost of a hash function is still higher
than basic operations such as AND, OR, XOR, and rotation.
1.2.2 Lightweight Solutions
A shared pseudonym between each tag and the back-end
database is required in [17], [22], [23], [24], [25], [26], [27],
[28], [29]. Exclusive-or (XOR) operation is the main
functional component that is needed. They suggest key
update after each session to guarantee forward security.
Vajda and Buttya´n [22] proposed a set of extremely
lightweight tag authentication protocols based on XOR,
subset, squaring, etc. Although they cannot prevent active
tracking attacks, they present effective ideas for low-cost
RFID tag design. Another utmost lightweight metric is
based on the concept of one-time pad [24]. Each tag must
store ReaderID for every reader. Although it provides
sufficient security level, the tag usually needs to store more
than one ReaderID. A more practical way is to have all tags
of each person store the same ReaderID. However, this
becomes a drawback because any compromised tag will
reveal its ReaderID and will allow an attacker to access all
other tags. Chabanne and Fumaroli [28] proposed a noisy
protocol to prevent passive eavesdropping via taking
advantage of a Bit Pair Iteration Protocol to correct transmis-
sion errors. Their work is particularly useful at initial setup
and privacy amplification of RFID application scenarios.
Privacy bit suggested in [30], [31] prevents illegal reading
via a minor modification in the tag. A privacy flag is
asserted while privacy violation is seriously concerned.
Then, the tag will not respond to normal interrogation of
any reader. To access this tag again, they often require an
extra command, called private-read, which needs the
authentication process as well. CRC-based protocol [32]
focuses on the enhancement of Gen2 protocol with the
built-in CRC component to cut down cost.
In this paper, we propose a solution, called Gen2þ, for
current RFID application before safer tags with built-in
cryptographic function come to market. We focus on the
protection of UltraHigh Frequency (UHF) passive tags from
malicious readers who will try to perform skimming,
tracking, and cloning attacks after obtainingTID.Our scheme
utilizes the built-in CRC function as a verification function to
authenticate readers based on shared pseudonyms. A tag’s
ID is never revealed until the reader passes the challenge.
In RFID applications, readers are much more expensive
than tags. We aim at following the Gen2 standard so that
existing readers can read both Gen2 tags and Gen2þ tags.
Although the scheme makes a modification to the tag, the
cost in tag is still cheaper than hash-based or encryption-
based solutions.
Compared with other lightweight solutions, we provide
better security level than [23], [26], [32], [27], [29]. The
protocol only needs to update the key once in a while,
instead of in every round as in [25]. The proposedGen2þ tag
requires no cryptographic operations but only a Hamming
distance calculator and some memory space. We evaluate
the number of rounds required for authentication and give
an algorithm to boost the search of the back-end database.
The rest of the paper is organized as follows: We give a
review of Gen2 protocol along with previous work in
Section 2. The proposed protocol is given in Section 3,
followed by simulation results and security analyses in
Section 4. Comparisons with other works are shown in
Section 5.
2 RELATED WORK
2.1 Generation-2 Protocol
First, we address the limitations of a Gen2 passive tag, and
then we review the procedure of the Gen2 protocol. A Gen2
tag contains a Pseudorandom Number Generator (PRNG)
and protects message integrity via Cyclic Redundancy Code
(CRC-16). The memory space is separated into four banks:
Reserved memory, EPC memory, TID memory, and User
memory. It harvests power from readers through the
antenna, and hence, cannot perform complex computations.
The Gen2 protocol has a main drawback pointed out in
[32]. The exposition of tag identification in this protocol
may violate user’s privacy. Any revealed TID can be easily
tracked and cloned. Our goal is to enhance the security of
the Gen2 protocol and remain lightweight at the same time.
A tag can generate a 16-bit random string, denoted as
RN16, and temporarily stores it in the memory. A read
operation consists of three stages: select, inventory, and
access. Select is used to select a specific population of tags.
Fig. 1 shows the steps of the original Gen2 protocol (in
Annex E [2]). Steps 1-4 in Fig. 1 are called the inventory
stage. After the reader successfully selects a tag through
singulation protocol as defined in the Gen2 specification,
the tag enters its ready state and backscatters RN16, which is
Step 2 in Fig. 1. At Step 3, note that any reader echoing RN16
will make the tag enter its acknowledged state and reply its
EPC data. Hence, any malicious reader is able to obtain TID.
This is due to the lack of the reader-to-tag authentication.
Steps 5-7 represent the access stage. Message 5 is a reader
command, which asks for another random number. The tag
will check if RN16 is correct and replies message 6, called
handle. Step 7 involves memory access commands, such as
Read, Write, and BlockWrite. The reader must provide the
same handle.
From the specification of Gen2, one can see that optimal
security is protected by the access password. In other
words, the time complexity of exhaustive search is Oð232Þ.
The scheme is safer when the password is longer.
1054 IEEE TRANSACTIONS ON MOBILE COMPUTING, VOL. 8, NO. 8, AUGUST 2009
Fig. 1. EPCglobal class-1 generation-2 protocol.
responds to the reader if it is correct. Both SID and four
keys must be updated after each session to provide forward
secrecy. Recently, an attack on M2AP has been proposed in
[35]. They could discover the tag’s identity and some shared
secrets from two eavesdropped rounds.
2.6 Juels’ Minimalist Cryptography
Juels introduced the concept of multiple pseudonyms as
one-time pads [25]. Each reading must search the whole
database to rule out impossible tags and then mark the
corresponding pseudonym invalid. The cut down version
addresses that most tags only perform the first step of the
protocol. So, the attacker cannot obtain useful information
but only pseudonyms. This also brings a problem, i.e.,
running out of pseudonyms due to the fact that they were
statically planted into the tag before being sold.
2.7 SASI
Chien’s protocol, called SASI [29], used the same basic
operations as in M2AP. The proposed scheme is ultralight-
weight, but active tracking is still possible among two valid
reads because IDS in SASI is a static value. Sun et al. [34]
showed a desynchronization attack on SASI with at most
96 trials.
To summarize previous literatures, as we have seen,
encryption algorithms and hash functions are not suitable
for low-cost RFID tags, at least in the near future. Jamming
signals, although very effective, may be illegal and some-
how interfere with normal reading. To minimize the cost in
each tag, the design principle is to use built-in components.
3 PROPOSED SCHEME
Our main idea is to randomize each session and provide
mutual authentication between legitimate readers and tags,
like other pseudonym-based approaches [23], [25], [26], [27],
[32], [29]. In order to be compatible with the original Gen2
specification, we proposed a new protocol called Gen2þ
using only PRNG and CRC-16 functions for authentication.
We assume that each tag shares an l-word-long random
string, called keypool, with the back-end database. This
string is randomly generated by the back-end server and is
written into the tag’s user-bank memory before deploy-
ment. The string is considered as a keypool where we can
randomly draw keys. A threshold value is set in each tag to
tolerate error bits of the received value and to boost the
reading speed. Therefore, we need an extra circuitry
element in the tag to calculate the Hamming distance of
two 16-bit numbers. Hamming distance calculators are
often seen in error-correcting hardwares. We believe the
new tag can be implemented easily.
3.1 Secured Gen2 Protocol
In the following, we show the basic version of the secured
Gen2 protocol. Step 1 in Fig. 2 is the same as the singulation
protocol described in the specification. The reader sends
commands Query/QueryAdjust/QueryRep to select a
specific tag. In Step 2, the tag whose Q-slot counted down
to zero responds to the reader’s request and backscatters
RN16 to proceed. We now consider this 16-bit random
number as two 8-bit addresses, a and b. These two numbers
mark a segment of the keypool stored in this tag. Let k½a : b
denote the segment (substring) from the ath word to the
bth word of keypool k. Note that this marking is made
circular, which follows the following equations. At the same
time, the tag calculates the CRC residue of k½a : b and keeps
the residue, which is denoted by ck
k½a : b ¼ k½a : b; for a  b; ð4aÞ
k½a : l 1kk½0 : b; for a > b: ð4bÞ

In Step 2 of Fig. 2, the reader simply forwards this number
to the back-end database. The database then searches
through records and generates a 16-bit number ck0, called
the centralkey, in Step 3. This value is sent back to the reader
and the tag as well. In Step 4, the tag compares ck0 with ck. If
their Hamming distance is smaller than a threshold value t,
the tag believes the reader is legal and replies with its EPC
data; otherwise, it remains silent and returns to arbitrate state.
Most of the time, only Steps 1-4 are required. We suggest
updating keypool through MemWrite command once in a
while. Since the steps of requesting PIN number and the
steps of MemWrite command are exactly the same as in the
standard (Fig. 1), they are omitted here. During the update,
the back-end server randomly generates another l-word-
long string as the new keypool and overwrites the old value
through memory write. Steps 1-4 only provide reader-to-tag
authentication. If the back-end server wants to check
whether a tag is valid or not, it can read out the whole
keypool and check if it is the same in database.
The threshold value t is also configurable by using
MemWrite command. This value represents that the tag can
tolerate up to t-bit Hamming distance between ck0 and ck.
This value is previously set to 16 before deployment, which
means the tag always accepts and acts like a Gen2 tag. The
threshold value is designed to boost the reading speed and
provide a trade-off between security and efficiency. After
the tagged item is sold at the retail, t is set to zero to prevent
further active scanning. This means the tag only accepts if
ck0 exactly matches ck.
For example:
Let l ¼ 32, t ¼ 1, and
keypool ¼ 1234567890FFF . . .FFFh.
1. R! T : Query.
2. T ! R: Choose ða; bÞ ¼ ð0; 4Þ. Hence, the segment is
k½a : b ¼ 1234567890h.
3. S ! R: Assume the back-end database calculates the
central key from the current database and obtains
ck0 ¼ 53D8h.
4. R! T : ck0.
1056 IEEE TRANSACTIONS ON MOBILE COMPUTING, VOL. 8, NO. 8, AUGUST 2009
Fig. 2. Gen2þ protocol: basic version.
version and should be implemented by linear search. If the
candidate set is too small, sometimes it takes more rounds
to identify the tag by Algorithm 1 than by linear search. The
situation happens less in the complete version.
3.4 CRC-16 Distribution
Previously proposed CRC-based protocols tend to assume
that CRC distribution is uniform. But this claim is not
accurate since there are still relatively high probabilities of
certain values. The following graph (Fig. 5) shows the
distribution of the output of a CRC-16 function. The input
length is arbitrary and the output range in decimal is from 0
to 65,535. Given an l-word-long string as the keypool and two
random values ða; bÞ, the probability is calculated by the
number of accumulated residues over the number of tests.
The result shows that the highest probability may be twice
as large as the lowest one. It explains the fact that if the bias
in probability p is larger, the candidate set shrinks faster.
3.5 Complete Version: Gen2þ
In order to boost the reading speed, it is obviously helpful if
the tag can provide extra bits of information about itself to
the back-end database. We hereby introduce a new
approach by applying extra bits in Step 2 of Fig. 2. The
last two bits are now considered as a check message, which
is constructed by taking XOR operation on the two LSBs of
the ath word and the bth word of the keypool. That is,
check ¼ ðkeypool½a  keypool½bÞ ^ 0003h: ð8Þ
Message 2 of Fig. 2 becomes ða; b; checkÞ, which means a; b
are now both 7-bit address only. The overall length of
message 2 remains 16 bits. It is possible to use more bits to
accelerate the reading speed furthermore. Assume that the
tag provides x bits of extra information, then ð1 1=2xÞ can-
didates are pruned away every round. The number of
rounds required is now calculated by the following equation:
qcomplete   logN
log 12x  ð1 P 00Þ
  : ð9Þ
The complete version shows an improvement in reading
speed. Due to the bit length of a and b, the largest size of the
keypool can only be 128words, which is different from Fig. 4.
The following figure shows the number of rounds required
for the complete version with different lengths of keypool.
When l ¼ 128 and t ¼ 0, it needs about nine rounds to finish
the authentication process. This makes a great difference
from the basic version. Note that if l ¼ 64, where a; b are both
6-bit long, one dummybit is added to theMSBof both a and b.
In this way, the total length of message 2 is still 16 bits.
3.6 Tag-to-Reader Authenticity
After the reader has proved itself to the tag, the reader can
check the validity of the tag by reading the whole keypool
and compare it with the record in the database. If the
attacker tries to recover the whole keypool from previous
captured sessions, the reader can update the tag’s keypool
by memory write.
4 SECURITY ANALYSIS
We classify readers into four types based on their behavior:
. Associate reader: The reader is legal and works with a
back-end database, which stores the information of
the tag that it is going to read.
. Semifriendly reader: A reader that is legal and works
with a back-end database, but has no information of
the tag.
. Malicious active reader: A powerful device that has no
information of the tag, but it can actively interact
with the tag and tries to trace it.
. Malicious passive logger: A small device that logs all
the RF signals and tries to obtain the information of
the tag or identifies the tag from logged data.
In the following, we analyze how our protocol performs
against these attacks.
4.1 Against Tracing Attack
A tracing attacker is the most powerful attacker who has
both a “malicious active reader” and several “malicious
passive” loggers. The goal of the attack is to discover the
presence of a specific tag. The attacker actively scans the tag
from a far distance and logs all the RF signals by the small
device near the tag. If the tag ever replies the same message
twice, such as the same TID, it can be traced. The associate
reader with the knowledge of keypool database has the
advantage of creating a possible value ck0 for authentication.
As for the attacker, there are two options. The attacker may
choose a random value of ck0 and interact with the tag every
round, or he may choose a fixed value of ck0 every round.
1058 IEEE TRANSACTIONS ON MOBILE COMPUTING, VOL. 8, NO. 8, AUGUST 2009
Fig. 5. The distribution of CRC-16 with different length of input. Fig. 6. Simulation result of complete version: relations between
threshold value t and number of rounds with different length l.
which means the Hamming distance equals 0, the follow-
ing equations hold:
ck1  ck2 ¼ CRCðk1ðxÞÞ  CRCðk2ðxÞÞ ð11Þ
¼ CRCðk1ðxÞ  k2ðxÞÞð12Þ ð12Þ
¼ CRCðkHðxÞ  xja1b1j  kLðxÞ  kLðxÞÞ ð13Þ
¼ CRCðkHðxÞ  xja1b1jÞ ð14Þ
The attacker then generates a lookup table for all
65,536 cases of kHðxÞ to see which one equals the value of
(11). In this way, the attacker obtains kHðxÞ, i.e., the
keypool bit from a2 to a1. After performing the same trick
several times, the attacker may recover the whole keypool
piece by piece.
To succeed, first the attacker must have at least two
sessions such that the second index of message 2 is the
same. The length of the keypool is l and the index value b is
uniformly chosen from l. By the birthday paradox, the
probability of finding a collision is the following, where x
represents the number of logged rounds
pðxÞ ¼ 1 l!ðlÞxðl xÞ! : ð15Þ
The probability reaches 53 percent when x  20 with
l ¼ 256 in the basic version. The probability reaches
52 percent when x  14 with l ¼ 128 in the complete
version. Note that the probability here is to recover a piece
of the keypool, not the whole keypool.
Fortunately, this is the best case for the attacker. If ck0
does not equal ck exactly, for example, the Hamming
distance is 2. The attacker cannot locate which two bits in
ck0 are different from ck. Thus, the attacker cannot use this
ck0 to derive the keypool by (11). There is still a chance that
the attacker is really lucky. As a result, we suggest to
perform a key update every 14 successful rounds.
5 DISCUSSION
5.1 Private Mode and Public Mode
End users demand their handful items to be switched to
private mode and switched back whenever they want.
Under such a scenario, our scheme provides flexibility
between the private mode and the public mode. For those
items, which need to be invisible from the outside world,
users switch them into the private mode by setting the
threshold value t to 0. Then, the tag can avoid tracing and
skimming attacks. They can pass through attackers’ effective
reading range in a public domain. In addition, these tags in
their private mode react to the malicious reader one after
another by sending nonsense just like passive-jamming tags.
As for the public mode, we set t to a higher value. Then, the
reading speed increases rapidly (shown in Fig. 6). However,
this also exposes the tag to the environment. This is
configurable according to user’s preference.
5.2 Scalability
From (7) and (9), the number of rounds is proportional to
logN. Our scheme is scalable no matter how large the
database is. The number of rounds increases very slightly
for both versions when N grows. The computational cost to
the back-end server is mainly CRC computations. The
number of CRC operations required to read a tag is
OðN  qRÞ, where qR is the number of rounds.
5.3 Comparisons
Table 1 shows comparisons between different proposals
that are similar to ours. The security level is evaluated by
the resistance to four major attacks. The size of challenge set
in Juels’ protocol is denoted as qJ . Parameter l in [26]
represents the length of shared pseudonym, L is the length
of each one-time pad in [25], and parameterM in [27] is the
length of the key. It is suggested that M ¼ f8; 16; 32; 64; 96g.
m denotes the security parameter, which is a small value or
zero in [25]. The symbol “–” means the attack is not possible
or not likely to happen. “y” in Table 1 means there exists a
known attack by which the attacker can reach his goal in
constant time.
Both Duc’s protocol and ours use the access PIN for tag-
to-reader authentication, and hence, the time complexity to
resist cloning attack is Oð232Þ.
We can see that [25] is also a good solution. Tracing and
skimming attacks are not possible because the one-time pad
is discarded every round. However, it requires key update
every round. In our protocol, we suggest to update the
keypool every 14 successful rounds, due to the attack
introduced in Section 4.4.
Table 2 counts the number of operations required among
these protocols on different entities. N is the number of tags
in database. C;R;X stand for CRC operation, PRNG, and
basic operations, respectively. Basic operations are XOR,
AND, OR, and modular summation. qR is to estimate the
number of rounds required for legitimate readers. Though
our scheme seems to create more overheads, qR is propor-
tional to logN , and hence, the computational loads will not
grow fast when supporting large-scale databases.
1060 IEEE TRANSACTIONS ON MOBILE COMPUTING, VOL. 8, NO. 8, AUGUST 2009
TABLE 1
Complexity of Security
[13] G. Avoine and P. Oechslin, “A Scalable and Provably Secure Hash
Based RFID Protocol,” Proc. Third IEEE Int’l Workshop Pervasive
Computing and Comm. Security (PERCOMW ’05), Mar. 2005.
[14] D. Henrici and P. Mu¨ller, “Hash-Based Enhancement of Location
Privacy for Radio-Frequency Identification Devices Using Varying
Identifiers,” Proc. First IEEE Int’l Workshop Pervasive Computing and
Comm. Security (PerSec ’04), Mar. 2004.
[15] A. Juels, R. Rivest, and M. Szydlo, “The Blocker Tag: Selective
Blocking of RFID Tags for Consumer Privacy,” Proc. 10th ACM
Conf. Computer and Comm. Security (CCS ’03), Oct. 2003.
[16] M. Rieback, B. Crispo, and A. Tanenbaum, “RFID Guardian: A
Battery-Powered Mobile Device for RFID Privacy Management,”
Proc. Australasian Conf. Information Security and Privacy (ACISP
’05), July 2005.
[17] A. Juels and J. Brainard, “Soft Blocking: Flexible Blocker Tags on
the Cheap,” Proc. Workshop Privacy in the Electronic Soc. (WPES
’04), Oct. 2004.
[18] L. Bolotnyy and G. Robins, “Physically Unclonable Function-
Based Security and Privacy in RFID Systems,” Proc. Fifth IEEE Int’l
Conf. Pervasive Computing and Comm. (PERCOM ’07), Mar. 2007.
[19] G. Ateniese, J. Camenisch, and B. De Medeiros, “Untraceable
RFID Tags via Insubvertible Encryption,” Proc. 12th ACM Conf.
Computer and Comm. Security (CCS ’05), Nov. 2005.
[20] I. Kim, B. Lee, and H. Kim, “Privacy-Friendly Mobile RFID Reader
Protocol Design Based on Trusted Agent and PKI,” Proc. 10th IEEE
Int’l Symp. Consumer Electronics (ISCE ’06), June 2006.
[21] I. Kim, B. Lee, and H. Kim, “Privacy Protection Based on User-
Defined Preferences in RFID System,” Proc. Eighth Int’l Conf.
Advanced Comm. Technology (ICACT ’06), Feb. 2006.
[22] I. Vajda and L. Buttya´n, “Lightweight Authentication Protocols for
Low-Cost RFID Tags,” Proc. Second Workshop Security in Ubiquitous
Computing (Ubicomp ’03), Oct. 2003.
[23] A. Juels, “Strengthening EPC Tags against Cloning,” manuscript,
RSA Laboratories, Mar. 2005.
[24] Y.C. Chen, W.L. Wang, and M.S. Hwang, “RFID Authentication
Protocol for Anti-Counterfeiting and Privacy Protection,” Proc.
Ninth IEEE Int’l Conf. Advanced Comm. Technology (ICACT ’07), Feb.
2007.
[25] A. Juels, “Minimalist Cryptography for Low-Cost RFID Tags,”
Proc. Fourth Int’l Conf. Security in Comm. Networks (SCN ’04), Sept.
2004.
[26] Y.Z. Li et al., “Security and Privacy on Authentication Protocol for
Low-Cost RFID,” Proc. Int’l Conf. Computational Intelligence and
Security (CIS ’06), Nov. 2006.
[27] P. Peris-Lopez et al., “M2AP: A Minimalist Mutual-Authentication
Protocol for Low-Cost RFID Tags,” Proc. Third Int’l Conf.
Ubiquitous Intelligence and Computing (UIC-06), Sept. 2006.
[28] H. Chabanne and G. Fumaroli, “Noisy Cryptographic Protocols
for Low-Cost RFID Tags,” IEEE Trans. Information Theory, vol. 52,
no. 8, pp. 3562-3566, Aug. 2006.
[29] H.Y. Chien, “SASI: A New Ultralightweight RFID Authentication
Protocol Providing Strong Authentication and Strong Integrity,”
IEEE Trans. Dependable and Secure Computing, vol. 4, no. 4, pp. 337-
340, 2007.
[30] D.H. Choi, T.S. Kim, and H.W. Kim, “Privacy Protection for
Secure Mobile RFID Service,” Proc. First IEEE Int’l Symp. Wireless
Pervasive Computing (ISWPC ’06), Jan. 2006.
[31] A. Juels, “A Bit of Privacy,” http://www.rfidjournal.com/
article/view/1536/1/82, May 2005.
[32] D.N. Duc et al., “Enhancing Security of EPCglobal Gen2 RFID Tag
against Traceability and Cloning,” Proc. Third Conf. Soft Computing
and Intelligent Systems (SCIS ’06), Jan. 2006.
[33] H.Y. Chien and C.W. Huang, “A Lightweight RFID Protocol
Using Substring,” Proc. IFIP Int’l Conf. Embedded and Ubiquitous
Computing (EUC ’07), Dec. 2007.
[34] H.M. Sun, W.C. Ting, and K.H. Wang, “On the Security of Chien’s
Ultralightweight RFID Authentication Protocol,” Cryptology ePrint
Archive, http://eprint.iacr.org/, Feb. 2008.
[35] M. Ba´ra´sz et al., “Passive Attack Against the M2AP Mutual
Authentication Protocol for RFID Tags,” Proc. First Int’l Workshop
RFID Technology (EURASIP), Sept. 2007.
Hung-Min Sun received the BS degree in
applied mathematics from National Chung-Hsing
University in 1988, the MS degree in applied
mathematics from National Cheng-Kung Univer-
sity in 1990, and the PhD degree in computer
science and information engineering from Na-
tional Chiao-Tung University in 1995, respec-
tively. He was an associate professor in the
Department of Information Management,
Chaoyang University of Technology from 1995
to 1999, and the Department of Computer Science and Information
Engineering, National Cheng-Kung University from 1999 to 2002.
Currently, he is a professor in the Department of Computer Science,
National Tsing Hua University. He has published more than 100 interna-
tional journal and conference papers. He was a program cochair of the
2001 National Information Security Conference and a program commit-
tee member of the 1997 and 2005 Information Security Conference, the
2000 Workshop on Internet and Distributed Systems, the 2001, 2002,
and 2005 Workshop on the 21st Century Digital Life and Internet
Technologies, the 1998-1999, 2002-2004, and 2006-2007 National
Conference on Information Security, ACISP 2004, NCS 2001, ICS
2002, ITRE 2005, and NCS 2007. His research interests include
information security, wireless network security, cryptography, and
multimedia security.
Wei-Chih Ting received the BS degree in
computer science from National Chiao Tung
University in 2004. He is currently working toward
the PhD degree in computer science at National
Tsing Hua University. His research interests are
in the areas of RFID security, system security,
network security, and cryptography.
. For more information on this or any other computing topic,
please visit our Digital Library at www.computer.org/publications/dlib.
1062 IEEE TRANSACTIONS ON MOBILE COMPUTING, VOL. 8, NO. 8, AUGUST 2009
the resources of Ci (but not in Cj) in the time interval ½tj1 ; tj2 . It
means, they should not be able to derive Ki;t where t 2 ½tj1 ; tj2 .
By using u2’s device, they calculate a point S such that
fSgY ¼ fKigY  IDj  IDi. Then, they store S into the device as
the fraud Kj. Since the device treats it as Kj, it directly calculates
Kj;t with S as follows:
K0j;t ¼ HKðfSgY HtðaÞ HZtðbÞ  IDjÞ
¼ HKððfKigY  IDj  IDiÞ HtðaÞ HZtðbÞ  IDjÞ
¼ Ki;t:
As a result, they obtain the crafted access key K0j;t, which is
indeed equal to Ki;t, from the output of the device. Then, they can
access Ci at time t using Ki;t, in which they are not authorized. We
shall notice that this attack also works even if ½tj1 ; tj2  and ½ti1 ; ti2 
are overlapped. That means, these two devices can access the
encrypted resources at the same time.
The remaining part is to calculate the point S. Suppose that we
follow the suggestion of [3] to implement the elliptic curve over a
prime field Fp, a finite field of p elements and p is a prime, with the
formula y2 ¼ x3 þ axþ b mod p. Therefore, finding S is equivalent
to finding the root of x3 þ axþ b mod p. Although S does not
always exist, most cases can successfully find S in polynomial
time. Other choices of implementation will also lead to similar
results. Also, if the device does not validate the point S is on the
curve or not, this attack will succeed without doubt.
4 POSSIBLE IMPROVEMENTS
The causes of the vulnerability are due to: 1) the symmetric
property of exclusive-or  and 2) the input materials Ki and Ri;j
are not authenticated. A simple improvement is to replace the
symmetric operator exclusive-or  in (1) by string concatenation jj.
The resulting equation is shown as (6).
Ki;t ¼ HKððKiÞY jjHtðaÞjjHZtðbÞjjIDiÞ: ð6Þ
This amendment is lightweight; however, we cannot guarantee
that it eradicates all other attacks.
The other method is to prove the authenticity of Ki and Ri;j.
The vendor signs Ki and Ri;j using digital signature as follows:
si ¼ SigðKijjiÞ; si;j ¼ SigðRi;jjjijjjÞ:
Then, whenever Ki and Ri;j are input, users respectively
provide si and si;j as well. The device aborts the computation if Ki
or Ri;j are not input with valid signatures. Although it incurs extra
computation and transmission loads to the system, this amend-
ment makes the scheme provable secure [4]. It is because the
device only accepts inputs that are prepared by the vendor. In
addition, Ki are tightly coupled with i and Ri;j are bundled with
i; j by the signatures, which disallow attackers to forge or replace
any of those.
5 CONCLUSION
There are many time-bound hierarchical key assignment schemes
in the literature which apparently seems to work but they have
been shown to be insecure. Nevertheless, the very recent Bertino
et al.’s scheme is shown to be broken in this paper. We suggest
some simple improvements to fix the scheme against the collusion
attack.
ACKNOWLEDGMENTS
This work was supported in part by the National Science Council,
Taiwan, under Contract nos. NSC 97-2221-E-007-055-MY3 and
NSC 97-2745-P-001-001.
REFERENCES
[1] W.-G. Tzeng, “A Time-Bound Cryptographic Key Assignment Scheme for
Access Control in a Hierarchy,” IEEE Trans. Knowledge and Data Eng.,
vol. 14, no. 1, pp. 182-188, Jan./Feb. 2002.
[2] H.-Y. Chien, “Efficient Time-Bound Hierarchical Key Assignment Scheme,”
IEEE Trans. Knowledge and Data Eng., vol. 16, no. 10, pp. 1301-1304, Oct.
2004.
[3] E. Bertino, N. Shang, and S. Wagstaff, “An Efficient Time-Bound
Hierarchical Key Management Scheme for Secure Broadcasting,” IEEE
Trans. Dependable and Secure Computing, vol. 5, no. 2, pp. 65-70, Apr.-June
2008.
[4] H.-M. Sun, K.-H. Wang, and C.-M. Chen, “On the Security of an Efficient
Time-Bound Hierarchical Key Management Scheme (Full Version),”
technical report, National Tsing Hua Univ., 2009.
. For more information on this or any other computing topic, please visit our
Digital Library at www.computer.org/publications/dlib.
160 IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING, VOL. 6, NO. 2, APRIL-JUNE 2009
4 THE SECOND ATTACK
We assume that there is a synchronized tag with the above
settings. The attacker eavesdrops on a successful session between
the tag and the reader, and records the values (A;B;C) as
(A1; B1; C1). At the same time, the database updates its variable
list to ðIDS2; K12; K22Þ. In the tag, the values of ðIDSold;K1old;
K2oldÞ are ðIDS1;K11;K21Þ and ðIDSnext; K1next;K2nextÞ are
ðIDS2;K12;K22Þ.
When the reader leaves the reading range of the tag, the
attacker initiates the protocol and requests IDS1 by claiming a
mismatching for IDS2. Thus, the tag will reply with IDS1. The
attacker’s goal is to forge a tuple ðA01; B01; C01Þ that is acceptable by
the tag. The attacker makes A01 ¼ A1, where A1 is to flip the kth bit
in A1, makes B
0
1 ¼ B1, and C01 ¼ C1 , where C1 is to flip the most
significant bit (MSB) of C1. Then, the attacker replies the tag with
ðA01; B01; C01Þ.
Note that in the protocol of SASI, flipping the kth bit in A1 leads
to the kth bit in n11 be flipped, if IDS1 andK11 remain unchanged.
Therefore, the kth bit in K21  n11 will flip. If the flipped bit is
coincidentally rotated to the MSB in K2, then C will be changed in
the MSB.
When the tag tries to verify message C, it is actually using C1 ,
K2, and K1, where K2 differs from K2 in the MSB. Note that the
carry bit under mod 296 would be discarded. Let us assume CR be
the value computed by the reader, CT be the intermediate value
computed by the tag, and carry denotes whether “þ” operation
generates a carry bit. Table 1 shows that in all cases, CT equals C1 .
In this way, the attacker is accepted.
Since the rotation is controlled by the Hamming weight of K21,
the attacker can obtain an authenticated tuple ðA01; B01; C01Þ by at
most 96 trials for all possible values of k. We also note that an
authenticated tuple can be confirmed if there is a response D0 from
the tag in Step 6. In fact, D0 differs from D in the MSB too. Once an
authenticated tuple ðA01; B01; C01Þ is accepted by the tag, the tag will
update ðIDSnext;K1next;K2nextÞ ¼ ðIDS2;K12;K22Þ, where K22
has the kth bit flipped in K22.
In the next time, when the reader tries to read the tag, it
replies IDS2. This value can be found in the database, but the
reader will be rejected by the tag, since the key K2next stored in
the tag is no longer synchronized with the database. This makes
them desynchronized.
5 DISCUSSION
5.1 Dual-Record Patch
In order to prevent the first attack, it is possible to store two tuples
of ðIDS;K1;K2Þ in the database as well. In this way, the old IDS,
i.e., IDSold, can be found in the database so that the first attack
cannot work. However, this approach is still vulnerable to the
second attack. In the second attack, IDSnext in the tag is the same as
IDSnext in the database. However, the reader cannot be authenti-
cated due to the difference in K2next.
One may consider to revise the protocol policy in which if the
reader fails the authentication by using IDSnext, the reader
reinitiates the protocol using IDSold. This amendment prevents
the second attack, but unfortunately it remains insecure.
The attacking method is described as follows: We assume that
the attacker has successfully mounted the second attack. The
variables saved in the database become IDSold ¼ IDS1; IDSnext ¼
IDS2, and the tag stores IDSold ¼ IDS1; IDSnext ¼ IDS2, but the
keys K2next stored in the database and the tag are different. The
attacker flips a bit in B1 to become B

1. When the attacker tries to
read the tag, he will receive IDSnext, which is IDS2. He replies
with the message ðA001kB001kC001 Þ to the tag, where A001 ¼ A1 of the
one in the second attack, B001 ¼ B1, and C001 ¼ C1. Follow the same
logic in the second attack, the message will be authenticated by
the tag with at most 96 trials. Then the tag will update
ðIDSold;K1old; K2oldÞ ¼ ðIDS2;K12;K22Þ and ðIDSnext;K1next;
K2nextÞ ¼ ðIDS3;K13;K23Þ. Now IDS3 does not exist in the
database, so the reader will request for IDSold ¼ IDS2 from the
tag. However, the reader cannot be authenticated due to K2 that
are different in both sides.
5.2 Parity Check Message Patch
Here, we provide an easy patch to the prevent these two attacks.
First, we append an odd parity check message E to both AkBkC
and D. Note that the message E is constructed by the parity of
message AkBkC. The tag also checks the parity simultaneously.
The tag echoes the same E if the authentication is successful. In
this way, if the attacker is using the interfering method, the success
rate drops. Second, we count the number of failed sessions on the
tag. If it reaches a certain threshold value, the tag replies an alert to
the valid reader so that the administrator knows that the tag has
been desynchronized and needs to be reset manually. This
prevents the attacker from using the man-in-the-middle attack or
the second attack, which often incurs a significant number of
failure authentications.
6 CONCLUSION
During the review process of this paper, we have found that other
researchers [5], [6], [7] also proposed several attacks to SASI. Phan
[7] illustrated a way to passively trace the tag with nonnegligible
probability. Cao et al. [6] showed three types of desynchronization
attacks. The first two work on a portion of the tags, and the third
one works on all tags and succeeds in less than 192 trials. Identity
disclosure attack introduced in [5], which can obtain the whole
secret of the tag, is the strongest attack to SASI so far.
We often find security loopholes in authentication protocols
without hash functions. It remains a challenge to design an
ultralightweight secure authentication protocol for RFIDs.
ACKNOWLEDGMENTS
This work was supported in part by the National Science Council,
Taiwan, under Contracts NSC 97-2745-P-001-001 and NSC 97-2221-
E-007-055-MY3. The authors thank Professor Chien for clarifying
the design.
316 IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING, VOL. 8, NO. 2, MARCH-APRIL 2011
TABLE 1
The MSB Bit of Each Variable
IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY, VOL. 4, NO. 4, DECEMBER 2009 781
On the Security of the Secure Arithmetic Code
Hung-Min Sun, King-Hang Wang, Member, IEEE, and Wei-Chih Ting
Abstract—In 2007, Kim et al. proposed a secure compression
code called the Secure Arithmetic Code (SAC). The code was
claimed to be secure against chosen plaintext attacks. However,
we find that the SAC is not as secure as the authors have claimed.
In this paper, we show the code is prone to two attacks. The
first attack completely breaks the code using an adaptive chosen
plaintext attack with a polynomial number of queries. The second
attack is a ciphertext-only attack, which removes a part of the
output permutation.
Index Terms—Arithmetic codes (ACs), communication system
security, data compression.
I. INTRODUCTION
A N arithmetic code (AC) [1] is one of the textbook loss-less compression algorithms. It is designed for encoding
fixed-length multiple-symbol strings, where the occurring prob-
ability of the symbols in each position is identical and indepen-
dent. In other words, the input of the algorithm is a string of
length , , where values of are independent
and identically distributed random variables. For example, in
a binary system with only two input symbols, ,
the occurring probabilities of and are and , respec-
tively. AC can be explained with the help of Fig. 1. The initial
interval of the output is such that is marked as
and is marked as . That is, if the first symbol of this
string is , it is encoded to a value in the interval . To
encode the second symbol of the string, the interval is
divided into two: and . The first interval
represents and the second interval represents . The in-
terval indicates and
indicates . The algorithm recursively partitions these inter-
vals times to encode a string of length . Suppose
is the interval that represents the input string. The output of
the algorithm is a codeword . This codeword is
a -bit string that represents a decimal in , in particular,
the . We say the input is compressed if .
To decode the codeword, the receiver has to acquire input
symbols. This can be embedded in the metadata, which is like a
file header, or agreed between the sender and the receiver in ad-
vance. Then, the receiver repeatedly splits the intervals times
Manuscript received August 03, 2008; revised July 27, 2009. First published
September 22, 2009; current version published November 18, 2009. This work
was supported in part by the National Science Council, Taiwan, under Contract
NSC 97-2221-E-007- 055-MY3 and NSC 97-2745-P-001-001. The associate
editor coordinating the review of this manuscript and approving it for publica-
tion was Dr. Bart Preneel.
The authors are with the Department of Computer Science, National
Tsing Hua University, Hsinchu, Taiwan 300 (e-mail: hmsun@cs.nthu.edu.tw;
khwang0@is.cs.nthu.edu.tw; sd@is.cs.nthu.edu.tw).
Digital Object Identifier 10.1109/TIFS.2009.2031944
as the encoder does. After the split, the interval contains the re-
quired codeword and that represents the symbols of the input.
In this way, the receiver is able to decode the codeword success-
fully.
The Secure Arithmetic Code (SAC) [2] was proposed by Kim
et al. in 2007. It is an extension of their previous work [3]. The
scheme intends to provide a compression algorithm based on the
AC [1] with a certain security level. Based on solid analyses, the
SAC algorithm was believed to be secure against chosen plain-
text attacks in which an adversary is allowed to pick any plain-
text as input and receive its corresponding ciphertext (scrambled
codewords). Due to its efficient compression performance and
high security, we agree that the SAC is a very good AC algo-
rithm in the literature, compared to prior art [4]–[6].
However, we find that the SAC is not as secure as the authors
have claimed. It is still vulnerable to chosen plaintext attacks. In
this paper, we show a way to break the SAC with a polynomial
number of queries. A “query” means to ask the encryption or-
acle once for the encryption of a plaintext. In addition, the output
permutation of the algorithm, which is designed to provide con-
fusion of the cipher, can be degraded by a ciphertext-only at-
tack. We point out these problems with concrete and efficient
attacks. We first review the SAC algorithm in Section II and
then describe our attack model in Section III. Next, we present
our attacking algorithm based on a chosen plaintext attack in
Section IV. An auxiliary attack based on the ciphertext-only at-
tack is given in Section V. Finally, we conclude this paper in
Section VI.
II. REVIEW OF THE SAC
In this section, we review the SAC algorithm. This algorithm
is divided into three phases: the input permutation (IP), the in-
terval splitting arithmetic coding (ISAC), and the output permu-
tation (OP). The input of the algorithm is a sequence of symbols
and the output is a scrambled and compressed bit stream. Each
phase requires several keys. These keys are generated by a key
scheduler. However, the construction of the key scheduler was
not fully described in [2]. For simplicity, we illustrate the algo-
rithm with a binary system. It is possible to extend it to a mul-
tiple-symbol system.
A. Input Permutation
Given an input sequence of binary symbols,
with length , where . They are aligned in a raster
order with four columns and rows. The algorithm takes
two sets of keys, namely a column key and a row key to control
the permutation. A column key consists of four subkeys, where
each subkey is a random integer in the range of .
A row key consists of subkeys, where each subkey is
a random integer in the range of . The IP operates on the
1556-6013/$26.00 © 2009 IEEE
SUN et al.: ON THE SECURITY OF THE SECURE ARITHMETIC CODE 783
Fig. 3. Interval splitting of two symbols: (a) before and (b) after.
Fig. 4. Interval splitting: (a) Regions are merged back logically as if we are following the original arithmetic coding. (b) Split each interval based
on   . (c) Swapping. (d) Put them back where they belong after the previous interval splitting.
TABLE I
NUMBER OF SUBKEYS AND NUMBER OF BITS OF EACH SUBKEY
FOR EACH PHASE
Row Key 1, Column Key 2, and Row Key 2. The remaining
bits of the codeword form a four-column
codeword block in raster order. Then, it performs a column
shift and a row shift on the codeword block using Column Key
1 and Row Key 1, respectively. After that, it appends the last
four bits back to the codeword block.
Finally, it permutes the block with a column shift and a row
shift again using Column Key 2 and Row Key 2, respectively.
The encoded ciphertext in the raster order is the final output
of the whole SAC algorithm. To make sure the decoder of the
SAC can reverse the OP, the generation of Column Key 2 and
Row Key 2 are independent of .
D. Key Generation
Table I summarizes the number of subkeys and the number
of bits needed for each subkey for each phase. According to in
[2, Sec. II.B], these keys are generated by a pseudorandom bit
generator called the key scheduler. The key scheduler takes an
initial key sequence of length as input and generates a bit
string based on XOR operations. The IP shifting keys, the ISAC
splitting keys, and the OP shifting keys are extracted from the
bit string. If the size of input data is , there will be
rows. According to Table I, there are also row keys for
the IP. The size of each subkey is calculated first and then ex-
tracted from the bit string in a predefined order. Otherwise, if the
receiver does not know how to extract keys from the bit string,
he cannot decrypt correctly. Based on this observation, the key
size stays the same when , , ,
or , where represents the number of rows. Under
these cases, the IP Column keys, the IP Row keys, and the ISAC
keys stay the same.
III. ATTACK MODEL
In this section, we describe the attack model in order to ana-
lyze the SAC. First, we assume that the system takes binary in-
puts of the length . As presented in [2], is selected as 16, 64,
256, and 1024 in different experiments. Since the ending zeros
SUN et al.: ON THE SECURITY OF THE SECURE ARITHMETIC CODE 785
Fig. 5. Plaintext queried for Step 1.
Formally, we query a set of four -symbol sequences, as
shown in the right-hand side of Fig. 5, namely, ,
, , and . We need to transform
these strings using the inverse row permutation and the in-
verse column permutation with before querying them from
the oracle. Also, we query another set of pieces of
plaintext with length . They are and
for , plus and
for as shown in the left-hand side of Fig. 5. Now, we
examine which ciphertext in the second set gives the same result
as any ciphertext from the first set. In fact, there exists exactly
one match from these two sets. Whenever ,
, or are the one that matches,
we output . In this step, we have
to query sequences in total.
We claim that there is exactly one matching pair between
these two sets. To justify this claim, here are some important
facts.
1) Fact 1: The encryption of the sequence
is equal to either the encryption of or the encryp-
tion of .
2) Fact 2: A sequence and a shorter sequence do not
produce the same ciphertext if is not a prefix of .
Suppose that ; this means the
matching plaintext in the second set after the column permu-
tation produces the sequence , where denotes ei-
ther or . Then after the row permutation, it will become
one of the following: , , ,
or . Thus, one of these will have the same encryption
as the one given in the first set. Other candidates (with different
values of ) always have a different prefix from the plaintext in
the other set. Therefore, there will be exactly one match.
In addition, by knowing which plaintext in the first set is the
matching candidate, we can also deduce the row key .
For example, if is the matching plaintext, then
will be 2.
B. Step 2
After obtaining , we know which symbol in the first
column will be permuted to the last row in the IP. Let us name
this position . To deduce , we randomly generate a
sequence of length such that the second column of the
block, formed by the sequence, consists of all , and the po-
sition of the sequence is also . We call this sequence .
Then, we create another sequence such that , i.e., a
symbol is appended to the sequence . We request the oracle
for the encryption of and . If they are the same, we pick
again randomly until they are not. Next, we substitute of
with the symbol and name the formed sequence . Then, we
create sequences for such that for each
sequence , except for the symbol placed in the second
column and the th row, . Finally, we create another
sequence for . Each sequence equals
except .
Fig. 6(a) shows how these ciphertext are being selected. Both
and are used for the left-hand side while both and
are for the right-hand side of the figure.
Now, we query , , , and from the oracle. There is
exactly one sequence from all and which equals either
or . Suppose that (same for ) matches or ; we
declare the column key .
The existence of such a match is due to the following facts.
During the column permutation, the symbols in the second
column of and are shifted to the last row and become
and . , , , permuted from , , , and
after the IP respectively, share the same sequence from
the first row to the th row, i.e., the first symbols. If we
focus on the last row, we have
from and from . Depending
on the value of , the last row formed by be-
comes or . The
last row formed by becomes , re-
gardless of the value of . If the last row of is
, we know that has the same en-
cryption as , given the fact that ’s encryption does not
match with ’s encryption. If in the other case, the last row of
is instead, then, we know that the
encryption of must be equal to either the encryption of or
the encryption of due to Fact 1. This is why we can deduce
by this method.
SUN et al.: ON THE SECURITY OF THE SECURE ARITHMETIC CODE 787
Fig. 7. Illustrating how to deduce the Column Key 2 by   ,   ,   ,   .
TABLE III
DERIVATION OF THE ROW KEY 
encryption of . It they are equal, ,
otherwise it is 0.
This stage requires a random process that has a probability
of 1/2 to find such a pair. On average, we need two pairs of
sequences and . Together with the challenges , , ,
and , we need input sequences to deduce the values
of and .
To obtain the third column key, we can apply similar methods
by picking another as shown in Fig. 6(b) such that the en-
cryption of does not equal the encryption of . Recall that
and . Then, we prepare such that it
is the same as except that has at position . Also, we
prepare three sets of plaintext , , and for
such that except that is , except that
is , and except that is . Therefore, if
the column key of the third row is ,
then the last row of , , and will equal ,
, and , respectively. By com-
paring the encryptions from the set and ,
we can obtain the value of . In addition, we can obtain
the value of with the knowledge of ,
as shown in Table III. When we consider the probability that the
encryption of does not equal the encryption of , the total
number of queries of is .
Adopting a similar logic and with the help of , vari-
ables like , , and are crafted as shown in Fig. 6(c). We
can obtain the column key as long as we compare the en-
cryptions of these plaintexts. This stage consumes queries
on average. Summing up the queries requires in Step 2, it takes
queries in total.
C. Step 3
We already know all column keys and the row keys of the last
two rows when the input length is . Recall that we have
obtained from Step 1 and from Step 2. The next
step is to derive all other row keys. The idea is shown in Fig. 7.
We want to align them to the same row after the column shift. To
obtain a particular row key, we construct four sequences on the
right-hand side and one on the left hand side. In the example, we
assume , the column key for is [0 1 2 2] and the column
key for is [2 3 1 0]. The block which will be shifted to the
last block is set to “ ”. In this way, only one “ ” is present
in the row. Then we ask the oracle for their encryptions to see
whether the encryptions of both sides are the same. If there is a
match, the row key of the tested row is found. One can always
find another row key using the same trick.
Here are the details of Step 3. With the help of the IP key
, we can individually deduce each row key , where
. Let be a sequence of
symbols after being processed by the column permutation. Since
we already obtain the column keys from previous steps, we are
able to create a sequence with specified values in .
Each row of symbols can be considered in the same class. As
long as the symbols in the same class have the same value, say
, they will yield the same encryption independent of the value
of the corresponding row key. This fact helps us in deducing
each row key. Suppose that we find for some .
We create four input sequences of length such that all
symbols are except for , where . Then,
we create another two input sequences and of long,
such that and . After querying , , and
to the oracle, we will find that there will be a match between
one of the and either one of or . Then, we declare that
the th row key .
There are only four possible values for . Each of these
values maps and to a permuted sequence with one of the
being their prefix. This mapping is one-to-one and answers
the questions why such a unique match exists and how the row
key can be obtained.
SUN et al.: ON THE SECURITY OF THE SECURE ARITHMETIC CODE 789
ACKNOWLEDGMENT
The authors would like to thank the anonymous reviewers for
their invaluable advice.
REFERENCES
[1] G. Langdon and J. Rissanen, “Compression of black-white images with
arithmetic coding,” IEEE Trans. Commun., vol. 29, no. 6, pp. 858–867,
Jun. 1981.
[2] H. Kim, J. Wen, and J. D. Villasenor, “Secure arithmetic coding,” IEEE
Trans. Signal Process., vol. 55, no. 5, pt. 2, pp. 2263–2272, May 2007.
[3] H. Kim, J. Villasenor, and J. Wen, “Secure arithmetic coding using in-
terval splitting,” in Proc. Thirty-Ninth Asilomar Conf. Signals, Systems
and Computers, 2005 , Oct. 28–Nov. 1, 2005, pp. 1218–1221.
[4] X. Liu, P. Farrell, and C. Boyd, “A unified code,” Cryptography and
Coding p. 797, 1999 [Online]. Available: http://dx.doi.org/10.1007/3-
540-46665-7_9
[5] M. Grangetto, E. Magli, and G. Olmo, “Multimedia selective encryp-
tion by means of randomized arithmetic coding,” IEEE Trans. Multi-
media, vol. 8, no. 5, pp. 905–917, Oct. 2006.
[6] M. Grangetto, A. Grosso, and E. Magli, “Selective encryption of JPEG
2000 images by means of randomized arithmetic coding,” in Proc. 2004
IEEE 6th Workshop Multimedia Signal Processing, Sep. 29–Oct. 1,
2004, pp. 347–350.
[7] Data Encryption Standard, Federal Information Processing Standards
Publication 46, Jan. 1977.
[8] Advanced Encryption Standard (AES), Federal Information Processing
Standards Publication 197, Nov. 26, 2001.
Hung-Min Sun received the B.S. degree in applied
mathematics from National Chung-Hsing University
in 1988, the M.S. degree in applied mathematics
from National Cheng-Kung University in 1990,
and the Ph.D. degree in computer science and
information engineering from National Chiao-Tung
University in 1995, respectively.
He was an Associate Professor with the De-
partment of Information Management, Chaoyang
University of Technology, from 1995 to 1999, and
with the Department of Computer Science and In-
formation Engineering, National Cheng-Kung University, from 1999 to 2002.
Currently he is a Professor with the Department of Computer Science, National
Tsing Hua University. He has published over 100 international journal and
conference papers. His research interests include information security, wireless
network security, cryptography and multimedia security.
Prof. Sun was the program cochair of the 2001 National Information Security
Conference and the program committee member of the 1997 and 2005 Informa-
tion Security Conferences, the 2000 Workshop on Internet and Distributed Sys-
tems, the 2001, 2002, and 2005 Workshops on the 21st Century Digital Life
and Internet Technologies, the 1998–1999, 2002–2004, and 2006–2009 Na-
tional Conferences on Information Security, ACISP’04, NCS’2001, ICS’2002,
ITRE’2005, and NCS’2007.
King-Hang Wang (S’06–M’08) was born in Hong
Kong, China, in 1981. He received the B.S. degree
in Information Engineering from the Chinese Univer-
sity of Hong Kong in 2002. He is now working toward
the Ph.D. degree in Computer Science from National
Tsing Hua University.
His research interests include provable security,
digital rights management, and steganography.
Wei-Chih Ting received the B.S. degree from the
Department of Computer Science, National Chiao
Tung University, in 2004, and the Ph.D. degree in
computer science from National Tsing Hua Univer-
sity, in 2009.
He is now affiliated with the Industrial Technology
Research Institute of Taiwan. His current research in-
terests include information security, wireless network
security, and RFID security.
CTR mode [14] also has computation problems and length
problems where an initial vector (IV) is attached at the
beginning of each block. Besides it is not secure against
chosen ciphertexts attacks. Furthermore, if a packet is lost,
following packets will not be able to decode. The reader
should be able to observe that designing such a code is a
non-trivial task.
In this paper, we present an algorithm for both compres-
sion and encryption that satisﬁes the above requirements.
In Section II, we will review AC brieﬂy and other related
works. Then, we will present our scheme in Section III.
It will be followed by some discussions on the proposed
scheme in Section IV. The paper will be concluded in
Section V.
II. RELATED WORK
In this section, we will ﬁrst review the principle of AC.
Then, some previous works about the security of AC will
also be described.
A. The Arithmetic Code
Due to the limited space of the paper, we are unable to
review the detail of arithmetic codes here. Readers who are
still confusing after reading this section, please refer to the
tutorial available on wikipedia or our related work [11].
Let (a1, a2, . . . , aN ) be the input of length N , where val-
ues of ai are i.i.d. random variables. Assume ai ∈ {A,B},
with the occurring probabilities pA and pB respectively.
The initial interval of the output is [0, 1) with [0, pA) is
marked as A and [pA, 1) is marked as B. That is, if the
ﬁrst symbol of this string is A, it is encoded to a value
in the interval [0, pA). To encode the second symbol of the
string, the interval [0, pA) is divided into two: [0, pA·pA) and
[pA·pA, pA). The ﬁrst interval representsAA and the second
interval represents AB. The interval [pA, pA + pB · pA)
indicates BA and [pA + pB · pA, 1) indicates BB. The
algorithm recursively partitions these intervals N times to
encode a string of length N . Suppose [a, b) is the interval
that represents the input string. The output of the algorithm is
a codeword [c1, c2, . . . , cM ]. This codeword is a k-bit string
that represents a decimal d (in binary) in [a, b), in particular,
the d =
∑M
i=1 ci · 2
−i
.
Notice that the compression efﬁciency of the code only
depends on the occurrences of the dominants symbols but
not the length of consecutive runs.
B. Previous Work
In 1999, Liu et al. presented a table-based bit-wise substi-
tution mechanism to strength arithmetic code [5]. Grangetto
et al. proposed Randomized Arithmetic Code (RAC) to
protect JPEG2000 images in 2004 [6, 7]. The idea of RAC
is to selectively swap the encoding intervals of A and B
for each input symbol. Both methods are insecure against
strong adversary models like chosen plaintext attacks or
chosen ciphertext attacks [4]. Kim et al. presented Secure
Arithmetic Code (SAC) in 2006 [4] which is based on
Interval Splitting Arithmetic Code (ISAC) in 2005 [8]. ISAC
separates a continuous symbol interval into two portions
and reassign the values of these intervals. SAC further
enhance ISAC by equipping a keyed input permutation
and two output permutations. It was believed that SAC
satisﬁes all requirements listed in previous section until very
recently that is shown the scheme is insecure against chosen
plaintext attacks [11] and insecure against chosen ciphertext
attacks [10]. Later, Zhou et al., the authors who proved that
SAC is insecure against chosen ciphertext attacks, tried to ﬁx
SAC by removing the permutations and masking the outputs
of the code with a random stream [9]. Yet, this method
does not satisfy the decode independent requirement that
when one of packet is lost, the subsequence message will
not be able to decode. Alternatively, an additional packet is
needed to synchronize the streams on both sides whenever a
packet is lost. This will increase the data size without doubt.
Besides, the random bit stream is generated by a pseudo-
random generator, which will repeat the same random bit
stream sequence when the generator completes its period.
This property will weaken the security strength of the code.
III. PROPOSED SCHEME
In this section, we present an arithmetic code for jointly
compression and encryption. We ﬁrst state the motivation of
our design. Then, we will describe how the code is designed
in details.
A. Motivation
It has been observed that a good block cipher should have
two good properties: confusion and diffusion [14]. Confusion
refers to the complex relationship between the cipher and the
key. Diffusion requires the change of one bit in plaintext will
result in a completely different cipher. It the ideal case, if
the i-bit of the plaintext is ﬂipped, any bit of the cipher has
probability 0.5 been ﬂipped. Previous solutions like RAC
[7], SAC [4], or the solution suggested by Zhou et al. [9] do
not meet the diffusion requirement. As a result, they can be
easily broken. On the other hand, well known block ciphers
like AES or DES, they all consist mechanisms to provide
diffusion. Therefore, apart from the requirement listed in
the introduction, we should design our code in the way that
provide diffusion.
B. Architecture
The architecture of our scheme is shown in Figure 1.
With an N -symbols input, it is ﬁrstly processed by Mixer .
Then, the permuted code will be compressed with Encoder .
The resulting codeword will be scrambled by Post-scrambler
. The output of the Post-scrambler is the cipher of the
algorithm. In each phase, keys will be fed by a Key Manager
independently.
1050445
IV. DISCUSSION
It this section, we will ﬁrst analysis the security level
achieved by the code. Next, we will show that it meets the
other requirements listed in Section I. The section will be
wrapped up by the discussion of keys.
A. Security
The design philosophy of the code is to enhance the
diffusion property that previous schemes fail to provide.
If a bit of the input is ﬂipped, the permutation in the
Mixer will have a different number of count of A. Then
the permutation of that column will be completely differ-
ent. In the subsequence iterations, the differences will be
diffused when the shift takes place, which will affect the
position of other column. The nonlinearity of Encoder will
also diffuse the differences. We should aware that ISAC
has a better diffusion property than simple AC and RAC.
Also, Post-scrambler further diffuses the code by modular
arithmetics. In a single iteration, one different bit of the
codeword will at least affect one bit. It will affect one
more bit if the carrier is also affected, which happens with
1
2
probability. Therefore, on average one different bit will
affect
∑M
4

i=1 i(
1
2
)i = 2 − (M
4
 + 2)(1
2
)
M
4
 bits, which is
slightly smaller than 2 bits for sufﬁcient large ciphers. After
j iterations of Post-scrambler, the difference will be widely
diffused. We estimate 2j bits are different.
Let’s consider chosen plaintext attacks against the pro-
posed scheme, where the attacker can request the ciphertext
of any plaintext chosen by the attacker. Common attacks,
including the one that breaks SAC [11], by observing the re-
lationship among the ciphertexts of similar plaintexts would
no longer works. It is because the diffusion property ensures
that there is no observable correlation by changing or adding
a single symbol in the plaintext. Also, by choosing suitable
security parameters i and j, the total number of iterations in
Mixer and Post-scrambler, we can provide sufﬁcient enough
diffusion for every input symbols.
Let’s consider we the chosen ciphertext attack against
the proposed scheme, where a chosen ciphertext attack, the
attacker can request the plaintext of any ciphertext chosen
by the attacker. The particular attack to break SAC [10]
would fail against the proposed scheme. It is because that
the diffusion property introduced by Post-scrambler would
change the codewords signiﬁcantly even the ciphers are
very similar. Besides, without the knowledge of the key
of Post-scrambler, it is infeasible for the attacker to derive
the codeword after the inverse of Post-scrambler. Also, the
diffusion property in Mixer would also stop the attacker
from observing the relationship between plaintext and the
ciphertext.
Theoretically speaking, the length of the codeword out-
putted by a AC (same for both RAC and ISAC) has already
implicated the portion of dominant symbols. As a result, by
feeding several plaintexts with the same length and the same
amount of A, an arithmetic code encoder would produce
roughly the same length ciphers. Thus, if attackers try to
mount a chosen ciphertext attack by feeding some same
length ciphers, it can be expected that the algorithm would
produce plaintexts with the merely the same portion of
dominant symbols. It is because that the inverse of Post-
scrambler does not change the length of the codewords, and
the inverse of Mixer only permutes the symbols. Ideally,
if Mixer and its inverse provide truly random permutation
to the input, attackers have no clue to recover the keys by
observing the plaintexts and ciphertexts pairs.
The reason for us to shift N bits in Post-scrambler
is due to a particular type of chosen ciphertext attacks.
Consider that the code is used to encode variable length
data and the step of shifting N bits in Post-scrambler is
omitted. Attackers can query for the same ciphertext for
several different values of N . When these ciphers have been
processed by the inverse of Encoder, the resulting permuted
symbols will share the same preﬁx of symbols sequence.
Thus, attackers can ﬁgure out the permutations produced
by Mixer though analyzing these plaintext-ciphertext pairs.
However, when the critical step, shifting N bits, is kept
in Post-scrambler, the resulting permuted symbols will be
totally different. This prevents attackers to exploit the code.
B. Other Requirements
Recall the requirements listed in Section I. Our scheme
satisfy those requirements as follows:
Computation Efﬁcient in Decoders. The computation over-
head introduced by the secure mechanism is very limited.
Mixer needs to count the number of A in each column,
shifting the symbols vertically and horizontally which can
be easily computed. For fast implementation, Encoder can
be implemented with normal arithmetic code. Even if RAC
or ISAC is used, the computation can also be efﬁcient [7, 8].
Post-scrambler requires modular additions and shiftings.
Both of them can be efﬁciently computed. Besides, the
shiftings in Mixer can be reused in Post-scrambler. It saves
implementation cost in hardware or software.
Minimum Length. Recalled that the compression efﬁ-
ciency of arithmetic code are mainly related to the frequency
of dominant symbols, rather than the length of consecutive
runs of a symbol. Only the order of the symbols is changed
in Mixer. Thus, the compression efﬁciency is not affected
on average.
Decode Independent. We observe that each of the cipher
does not depends on other ciphers, as long as the key
manager can generate key independently.
C. Keys
The keys size required for each stage of the algorithm
is listed in Table I. Meanwhile, SAC consumes roughly
4 log(N
4
)+ 2(N
4
)+ 8 log(M
4
)+ 4M
4
 for permutation
1052447
CDS: Concealed Data Sorting Scheme in Wireless Sensor Networks
Yue-Hsun Lin, Bing-Zhe He, Hung-Min Sun
Information Security Lab
Department of Computer Science
National Tsing Hua University
Hsinchu, Taiwan, R.O.C.
{tenma,ckshjerho}@is.cs.nthu.edu.tw,
hmsun@cs.nthu.edu.tw
Yen-Hsueh Chen
Department of Internet Security
Information and Communications Research Laboratories
Industrial Technology Research Institute
HsinChu, Taiwan, R.O.C.
killo.chen@gmail.com
Abstract—Recently, concealed data aggregation schemes
have been proposed to reduce the transmission cost under
maintaining data privacy. Those schemes enhanced security
of conventional aggregation through utilizing privacy homo-
morphic encryption. The privacy homomorphic encryption
provides algebraic computations on ciphertexts directly, e.g.,
without decryption ciphertexts.Unfortunately, it does not sup-
port extreme value selections, such as median, minimum, or
maximum. Hence, we construct a novel sorting scheme on
ciphertexts without decryption where ciphertexts are generated
by Elliptic Curve ElGamal encryption. Moreover, the proposed
scheme could be preserve additive homomorphic property of
the Elliptic Curve ElGamal encryption. Deployed aggregator
can execute sorting according to different cases. To the end of
this paper, the proposed scheme has been evaluated on physical
sensor system. Comprehensive analyses and comparisons are
shown to prove that the proposed scheme is practical and
efﬁcient.
Keywords-Conceal data aggregation, wireless sensor network,
privacy homomorphic encryption
I. INTRODUCTION
Energy saving is quite important in wireless sensor net-
work (WSN) research area. Basically, a WSN is composed
of a centralized server (base station) and multiple sensor
nodes. Depending on applications, the number of deployed
sensors could be hundreds or thousands. Those sensors are
responsible for gathering speciﬁc data and return to the base
station [1]. For example, environment monitoring, accident
reporting, or military service distribute WSNs to collect data
from sensors. Unfortunately, sensor are cheap and resource-
limited. Most of them are battery-powered, low computation,
and capable of tiny storage. Therefore, security protocol
design on WSN should be energy-efﬁcient since we wish
to maintain usability and acceptable lifetime of WSN.
Compare with computation, transmission cost becomes
energy bottleneck for deployed sensors [2]. In order to save
energy in transmission, the cluster-based model has been
proposed and adopted on WSN since data from several
sensors could be aggregated by a cluster head within a
predeﬁned cluster [3]–[6].
In a cluster-based WSN, deployed sensors are divided into
several clusters after deployment. Based on some metrics,
such like short distance or strong signal, couples of sensors
would be merged in one cluster. Generally, sensors in the
same cluster will select one of them to be the cluster head.
During the whole transmission, the cluster head aggregates
messages from other sensors. And then it will send the
aggregated result to the base station. This model is depicted
in Figure 2.
In general, cluster head performs speciﬁc aggregation
functions on messages from sensors. The aggregation func-
tion, f , can be used to compute algebraic operations, e.g.,
addition or multiplication. On the other hand, f can also
perform statistical analysis on numeric data, such as media,
min, max, or mean of a data set. The purpose of function f
depends on the application on WSN.
Aggregation can reduce energy consumption signiﬁcantly.
For instance, if the base station wish to collect the sum of
all the data from deployed sensors, the cluster could perform
aggregation and return the result to the parent node. Without
aggregation, the cluster would deliver all data instead of
aggregated result. However, aggregation on plaintexts does
not satisfy conﬁdentiality since eavesdropping is feasible
for adversaries. On the other hand, sensors are prone to be
captured in a hostile environment. Messages or data stored in
sensors are easy to be compromised. Another serious attack
is to compromise cluster heads. Malicious cluster heads can
fake aggregated results [7]. This is identical to compromise
all the sensors in this cluster.
Recent studies, such as the delay aggregation, SIA [3],
ESPDA [8], and SRDA [9] have been proposed to solve
the problem of faking aggregated results. However, most
of their schemes either limit the data type of aggregation
or need additional transmission overhead. A new approach,
concealed data aggregation (CDA), is introduced to pro-
vide data privacy in aggregation [10]. They utilize PH
(privacy homomorphic encryptions) to provide functionality
to aggregate ciphertexts directly. Due to the additive or
multiplicative homomorphism in PHs, cluster heads can
perform algebraic operations on the encrypted numeric data
without decryption. Up to now, Westhoff et al. and Girao
et al. proposed CDA-like schemes [10], [11] to enhance the
мрй978-1-4244-7640-4/10/$26.00 ©2010 IEEE
B. Secure Comparison of Encrypted Data in WSNs
Recently, Acharya et al. proposed a comparison method
on encrypted data for WSNs [13]. They adopted OPES [18]
to achieve comparison on encrypted data. The technique in
OPES is to map the distribution of plaintexts to a normal
distribution. If an adversary eavesdrops those messages, he
could not obtain the original plaintexts since he does not
understand the mapping function. However, OPES has a
major disadvantage. They do not really apply encryption on
aggregated result; The output ciphertext is only a shifted
value from the original plaintext value. In other words, the
adversary can extract the plaintext values from statistical
analysis after collect enough plaintext samples. On the other
hand, deployed sensors are easy to be captured in hostile
environment. Once sensors are captured and compromised,
the adversary can reverse the distribution since the mapping
function is already compromised.
C. Bilinear Pairing
By deﬁnition, a bilinear pairing eˆ<·, ·> is a “bilinear”
map such that eˆ : G1 × G1 → G2 where G1 is an additive
cyclic groups and GT is a cyclic multiplicative group. A
bilinear pairing eˆ has the following properties:
1) Bilinearity: eˆ<S1 + S2, T> = eˆ<S1, T>eˆ<S2, T>
and eˆ<S, T1 + T2> = eˆ<S, T1>eˆ<S, T2> where
∀S, S1, S2, T, T1, T2 ∈ G1.
2) Non-Degeneracy: If S and T are linearly independent,
then eˆ<S, T> = 1T ∀S, T ∈ G1 and 1G2 is identity
of G2.
3) Computability: eˆ is computable efﬁciently.
In fact, there are two well-known pairing constructions
satisfying these four properties, Weil pairing [19] and Tate
pairing [20]. Both of them are based on elliptic curve. In the
proposed scheme, we adopted Weil pairing as our building
block. Weil pairing is described shortly here.
Let E be an elliptic curve deﬁned over a ﬁnite ﬁeld K and
let n be a positive number. Assume that the characteristic of
K does not divide n. Weil pairing is the map eˆn : E[n] ×
E[n] → ζn where E[n] is a set of n-torsion points over E
and ζn is a group of nth roots of unity over ﬁeld L, i.e.,
ζn = {x ∈ L | xn = 1}. Noted that L is an extension ﬁeld
of K. Therefore, ζn is a cyclic group of order n. Compared
with the deﬁnition of bilinear pairing, group G1 is the set of
n-torsion points E[n] and group G2 is ζn. The Weil pairing
maps cross products of elliptic curve points to elements on
the ﬁnite ﬁeld.
D. Network Model
The network has one base station (BS), several cluster
heads (CHs) and many sensor nodes (SNs), Figure 2. BS
broadcast the instructions to all SNs in the enviroment. SNs
sense the data according to the receieving instructions. After
ﬁnish sensing data, SN encrypts the data and sends it back
to BS through CHs. The sensed data may pass through
several CHs from SN to BS. When receieving all packet
from SNs, CH perform secure aggregation function, f .
Without decrypting ciphters, CH can obtain extreme value
through secure aggregation function. Finally, CH sends the
result to the BS through other CHs.
BS
CH3
CH1 CH2
SN SN SN SN SN
Cipher Ci = Ek(Mi)
Data:M1, M2, M3, M4 and M5
C1 C2
C3 C4 C5
f(C1, C2, C3) f(C4, C5)
f(f(C1, C2, C3), f(C4, C5))
Figure 2. Network model
III. CDS: CONCEALED DATA SORTING SCHEME FOR
WIRELESS SENSOR NETWORKS
The proposed scheme, CDS, is based on EC-ElGamal.
Generally, CDS can be applied on cluster-base WSNs (See
Section II-D). CDS consists of three phases. The ﬁrst
one is pre-deployment phase. All pre-computed secrets and
functions need to be installed in sensors (SNs), cluster
heads (CH), and the base station (BS). The second one
is sorting phase, which is the kernel of CDS. At beginning,
we introduce the basic approach to compare two ciphertexts
in CDS. Then we construct a sorting algorithm based on the
basic approach. The ﬁnal one is return phase. In this phase,
the CH would randomize the aggregated ciphertext as the
result against statistical attacks.
A. Pre-deployment Phase
Since CDS is established on EC-ElGamal, BS generates
the public key (E, p,G, Y ) and the private key x where
Y = xG. Detail of key generation is showed in Figure 1.
Then BS constructs a pairing function eˆ<·, ·> from elliptic
curve E over ﬁnite ﬁeld Fpr where r>1. The detail of
eˆ<·, ·> is given in Section II-C. Next, BS installs the
public key on all SNs. After deployment, deployed sensors
SNs would be divided to several clusters; CHs are selected
within each cluster. The ﬁnal step is each CH would send
its request to the BS, and BS would broadcast the bilinear
pairing function, eˆ<·, ·>, through authentic broadcasting
methods.
B. Sorting Phase
First we proposed the secure comparison on two cipher-
texts only where ciphertexts are generated by EC-ElGamal.
мрл
valued ciphertext would be dropped because the plaintext
value is far away from the median of plaintext value. If the
boundary value  is selected carefully, adversary is hard to
unject skew valued packets into the legal network ﬂow.
The second one is also indistinguishable for the adversary
since re-encryption is supported when the CH transmits its
comparison result. All ciphertexts are indistinguishable since
adversary cannot retrieve secret key from captured SNs or
CHs.
The third one is only possible when the adversary com-
promised the CHs. Through compromising secret in CHs,
Adversary can gather information about distribution of
plaintext. A intuition method is change the distribution of
plaintext.
The ﬁnal attack is revealing the secret key through com-
promising SN or CH. The only way of revealing private key
x is to solve the ECDLP of public key pair (G, Y ) through
solving DLP of eˆ<G, Y > and eˆ<G,G>. The security
strength can be raised from increasing the embedding degree
of the bilinear pairing. The detail is given in the previous
section.
V. DISCUSSION
A. Curve selection
Generally speaking, bilinear pairings are useful and rich
in cryptography. They can be constructed by ordinary or
super-singular curves. Those curves are also called pairing-
friendly elliptic curves. However, cryptosystem based on
bilinear pairing might be attacked since ECDLP on elliptic
curve will be reduced to DLP in Galois ﬁnite ﬁelds. To our
best knowledge, DLP in ﬁnite ﬁeld Fp can be solved by
the index calculus attack when p is not large enough. As
we depicted in section II, those pairings including Tate or
Weil pairing maps from an elliptic curve group #E(Fq) to
the multiplication group of some extension ﬁeld F∗qr . The
parameter r is called embedding degree of the curve.
For sufﬁcient security and optimal performance, the curve
should satisfy two requirements. The ﬁrst one is the order
of the group #E(Fq) should be a prime number or have
a large prime factor. The second one is that two discrete
logarithm problems (ECDLP and DLP) are difﬁcult against
best known attacking methods. In recent research, a pairing
is considered secure against best attacks when p ≈ 2160 and
r ≈ 6-10 where r is the embedding degree and p is the
large prime factor of #E(Fq). For efﬁcient performance,
we choose MNT curves for our pairing construction. MNT
curves are ordinary curves, and their embedding degree r are
one of 2,3,6. Hence, we select MNT curves for p ≈ 2160
and r=6. The construction of MNT curves is given in the
appendix.
B. Distribution of plaintext space
As we depicted in section III, the boundary value, ,
should be deﬁned carefully. If  is too small, CH only
compares few ciphertexts since the difference of any two
ciphertexts are always bigger than . On the other hand, if 
is too large, the CH should store more ﬁnite ﬁeld elements
and execute more comparisons.
The simple way of determining the value of  depends
on the standard derivation of plaintext message space.
Generally, the value of  can be chosen as twice of the
standard derivation. If the distribution of plaintext message
is normal distribution, or called Gauss distribution. Almost
98% plaintexts are located within the median of the plaintext
distribution.
C. Implementation
The proposed scheme, CDS, was implemented on phys-
ical wireless sensor systems. CDS has three roles, incluing
one BS, several CH , and many SNs. We use MICAz
sensors as SNs. Since CH should be more powerful than
SN , we choose SCAN sensors as CHs. SCAN sensor is
made by Industrial Technology Research Institute. The ﬁnal
device is BS. BS is a SCAN sensor which is connected to
the desktop PC. EC-ElGamalencryption for Micaz sensors
is implemented based on TinyECC library [21]. The bilinear
pairing library we adopted in CDS is a re-implemented
version.
VI. CONCLUSION
CDS provides the cluster head nodes to select the max
or min cipher without decryption. However, when the dis-
tribution of plaintext values inside the ciphers is divergent,
CDS does not work. In the near future, we will enhance the
CDS to a more powerful version. Based on this, we will
apply some statistic evaluation methods to investigate how
to estimate the threshold in an accurate way.
VII. ACKNOWLEDGEMENTS
This work was supported in part by the National Science
Council, Taiwan, under Contract NSC 97-2221-E-007-055-
MY3 and NSC 98-2218-E-007-014. This work was also a
joint work between Information Security Lab, Department
of Computer science, National Tsing Hua University and
Internet Security Department, Information and Communica-
tions Research Laboratories, Industrial Technology Research
Institute.
APPENDIX A.
MNT CURVE GENERATION
Miyaji et al. proposed their method on constructing ordi-
nary curves for bilinear pairing [22]. The curves are called
MNT curves in short. Under their construction, the elliptic
curve has the following properties.
• The order of subgroup of points on curve has a large
prime factor.
• The order of subgroup of points on curve has a small
Co-factor.
мрн
An Authentication Scheme Balancing Authenticity and Transmission for Wireless
Sensor Networks
Hung-Min Sun ∗, Shih-Ying Chang ∗, Alcides Bernardo Tello †, and Yen-Hsuen Chen ‡
∗Department of Computer Science
National Tsing Hua University
Hsinchu, Taiwan, R.O.C.
Email: hmsun@cs.nthu.edu.tw
†Department of Computer Science
Universidad de Huanuco
Huanuco, PERU
‡Internet Security Department
Information and Communications Research Laboratories
Industrial Technology Research Institute
Hsinchu, Taiwan, R.O.C.
Abstract—In recent years, wireless sensor networks (WSN)
have received a lot of attention and several cryptographic
protocols have been proposed to protect WSN. However, it still
opens that how to balance authenticity and transmission. For
authenticating the message from a sensor, the message is ap-
pended a Message Authentication Code (MAC) authenticating
it. These MACs may result in large amount of transmission,
which is the most energy-expensive resource. For reducing
the amount of the transmission for the MACs, the exclusive-
or (XOR) of the MACs is sent instead. In this way, the
transmission can be largely reduced but any error occurred
in these MACs would make the authentication failed. All the
messages and MACs should be retransmitted. In summary,
transmitting all MACs supports better authenticity but worse
transmission-efﬁciency, and transmitting an XOR of all MACs
supports better transmission-efﬁciency but worse authenticity.
In this paper, we propose a new scheme based on Reed Solomon
Codes for balancing authenticity and transmission effectively.
Keywords-message authentication code; Reed Solomon codes;
wireless sensor networks;
I. INTRODUCTION
Due to the rapid development in sensing hardware and
sensing technologies, the applications of wireless sensor
networks (WSN) e.g., environment monitor, security assur-
ance, military applications and healthcare, have been widely
investigated. Since the sensors are limited in energy, compu-
tational capability, and memory [1], [2], energy reservation
is the most important issue in WSN. In general, the most
energy-expensive operation is RF transmission [1], [2]. Wan-
der et al. [2] showed that the energy required to transmit 1
bit approximately equals to 2090 CPU clock cycles. Besides
that, compared with computation cost, the communication
cost is hardly reduced through hardware advance. Thus,
reducing the amount of transmission is signiﬁcant for WSN.
Besides energy reservation, security is another important
issue for security-sensitive applications, such as battleﬁeld
monitor and security service. An important security re-
quirement in WSN is authenticity, which refers to the
truthfulness of sensors or messages. Many WSN protocols
and WSN speciﬁcation ZigBee (IEEE 802.15.4) [3], [4] uti-
lize lightweight Message Authentication Code (MAC), e.g.,
HMAC-MD5, HMAC-SHA-1, AEC-CBC-MAC, to provide
authenticity in WSN. However, since the length of an
MAC determining the security strength of an MAC function
can not be shorten unconditionally, these lightweight MAC
functions cannot reduce the energy consumption effectively.
Thus, how to reduce the amount of transmission for the
authentication data is still a challenge.
In the previous literature, two approaches we named
PMAC and SXMAC for simplicity provide end-to-end au-
thenticity in WSN, which means that base station can
authenticate the messages sent by sensor nodes. In Pairwise
MAC (PMAC) [5], [6], a sensor node computes an MAC
for a message and forward them to the base station. In
this approach, intermediate nodes just forward these data
without any further processing such that the number of
MACs is as large as the number of messages, causing larger
transmission overhead. Moreover, the sensor nodes closer
to the base station will run out of energy more quickly. In
contrast, Zhu et al. [7] use the notion of single XORMAC
(SXMAC) to reduce the number of MACs in WSN. In
this approach, an intermediate node aggregates all MACs
received to a single XORMAC by computing the exclusive-
or (XOR) of these MACs. Many research [8], [9], [10], [11]
adopted SXMAC to reduce the amount of the transmission
for MACs. However, once any fault occurs among these
MACs XORed, the base station can not identify the false
messages such that all the messages must be dropped and
retransmitted, causing the condition of Denial of Service
ллл978-1-4244-7640-4/10/$26.00 ©2010 IEEE
for v errors. In other words, if we can ﬁnd the roots of
σ(x), we can ﬁnd the error location. The details of remaining
process of locating errors is out of the scope of this paper.
In summary, for RS(κ, t) code, the code can correct up to t
errors.
III. PROPOSED SCHEME (RSMAC)
Based on RS codes, 2t MAC-size redundancy are gener-
ated to authenticate m MACs for correcting t errors. Since
we employ systematic RS codes, the m MACs are not sent to
the BS. Instead, the m messages are sent to the BS because
the BS can reconstruct the m MACs from these messages.
By this construction, RSMAC locates t instead of no error
in comparison with SXMAC and requires 2t instead of m
MAC-size transmission in comparison with PMAC. In other
words, RSMAC is the balance between PMAC and SXMAC.
Note that since MAC is invertible and uncorrectable, we use
the word locate instead of correct.
However, it is commonly known that RS codes are
computation-inefﬁciency while the underlying ﬁeld is too
large. Considering an MAC as an element on GF(q), e.g.,
GF(264), is infeasible. Therefore. RSMAC is based on
interleaved RS codes, built on a smaller ﬁeld, e.g., GF (28).
A. Data Representation
We assume that each MAC is l-bit long. We group l bits in
a MAC into l¯ smaller blocks where l¯ is l/κ¯ and each block is
an element in GF (2κ¯). In other words, each MAC consists
of l¯ element in GF (2κ¯). For instance, we set κ¯ to 8 since
GF (28) is commonly known as computation-efﬁciency and
has been deployed in several applications. In this way, m
MACs (M1,M2, ...,Mm) can be represented as a m × l¯
matrix as follows.
M =
⎛
⎜⎝
M1
.
.
.
Mm
⎞
⎟⎠ =
⎛
⎜⎝
M1,1 · · · M1,l¯
.
.
.
.
.
.
.
.
.
Mm,1 · · · Mm,l¯
⎞
⎟⎠ , (6)
where Mi = (Mi,1,Mi,2, ...,Mi,l¯), Mi,j ∈ GF (2κ¯). In data
view, Mi is equal to Mi,1 ‖ Mi,2 ‖ ... ‖ Mi,l¯ where ‖
denotes the concatenation.
B. Encoding
Each column of M is independently encoded using
RS(κ¯, t); that is, the blocks in an MAC are interleaved with
the blocks in the remaindering MACs. More speciﬁcally,
we represent these l¯ column vectors of M as l¯ message
polynomials. For instance, the ith of l¯ message polynomial
is
mi(x) = M1,i + ...+Mm−1,ixm−2 +Mm,ixm−1, (7)
where i = 1, 2, ..., l¯.
According to (2), the parity polynomial ri(x) of each
message polynomial mi(x) can be computed. Consequently,
each message polynomial mi(x) can be encoded into the
code polynomial ci(x) according to (1).
C. Decoding
Each code polynomial ci(x) can be independently de-
coded and the corresponding error-location polynomial
σi(x) can be generated. Since MAC is invertible and un-
correctable, we compute σi(x) for locating errors in ci(x).
After that, we deﬁne the following quantities.
Fi,j = 1, if σj(x) of cj(x) indicates the ithcoefﬁcient
erroneous or decoder failure happened.
Fi,j = 0, otherwise.
After that, whether the data in a code polynomial are
erroneous or not can be determined as follows.
Fi = 1, if ∃Fi,j = 1, j = 1, 2, ..., l¯.
Fi = 0, otherwise.
Fi denotes whether the ith data in the code polynomial is
wrong or not. Finally, we count the number of errors as
follows.
F =
m+2t∑
i=1
Fi. (8)
As a result, if Fi is greater than 0, this means that the ith
data (i.e., an MAC or an RSMAC) is erroneous; otherwise
it is correct. And F denotes the number of overall errors.
D. The Detailed Construction of RSMAC
In this session, we describe the detailed construction of
RSMAC in WSN.
• Initialization: The BS conﬁgures the underlying ﬁeld
and the associated generator polynomial g(x) and check
polynomial h(x) for a RS code RS(κ¯, t). Next, the BS
sends (GF(2κ¯), g(x)) to the CH.
• Each iteration of data gathering in a cluster is as
follows:
1) The ith sensor node SNi sends its sensing reading
msgi and MAC Mi to the CH.
2) After receiving m data pairs, the CH processes
the data as follows.
– The CH transforms m MACs to forms the
matrix M and constructs l¯ degree-(m − 1)
message polynomials mi(x), i = 1, 2, .., l¯ in
column wise as shown in (6).
– The CH computes ri(x) = R1,i+R2,ix+ ...+
R2t,ix
2t−1 for each mi(x) via (2).
– The CH sends m messages
(msg1,msg2, ...,msgm) and all the
coefﬁcients of l¯ parity polynomials ri(x)
(i.e., R1,i, R2,i, ..., R2t,i for i = 1, 2, ..., l¯) to
the BS. More speciﬁcally, these coefﬁcients
of parity polynomials can be represented as
follows.
ллн
Table I
THE BASE-2 LOGARITHM OF SPECIFIC PROBABILITY OF DECODER
ERROR FOR VARIOUS t IN VARIOUS GF.
t = 4 t = 8 t = 16 t = 32 t = 64
GF(25) -5.24 -17.235 - - -
GF(26) -4.91 -16.33 -47.98 - -
GF(27) -4.74 -15.81 -46.03 -124.55 -
GF(28) -4.66 -15.55 -45.12 -120.95 -309.21
may happen at the same time. Hence, we can bound the
probability of FA and FR in a code polynomial by the
probability of DE in a code polynomial as follows.
Pr(FA ∪ FR) ≤ Pr(DE). (10)
To compute the probability of DE, we introduce the notion
of a sphere containing vectors of n-tuples over GF (q).
Deﬁnition 1: Given a vector space Vn over GF (q). The
sphere S(x, t) centering at a vector x and with radius t is
the set
S(x, t) = {y : d(x,y) ≤ t}, (11)
where x,y ∈ Vn and d(x,y) denotes the hamming distance
between x and y.
The sphere contains the set of all n-tuples vectors in a given
vector space Vn whose distances from some given vector x
as the ”center” does not exceed a given value t. Now let u be
a vector in Vn. We determine the number of vectors v ∈ Vn
such that d(u,v) = d where d ≤ t gives us the number of
vectors in Vn of distance exactly d from u. The choices that
v differs from u with d positions is (nd ). For each position,
we have q−1 choices. Therefore, the total number of vectors
of distance d from u is given by (nd )(q−1)d. For 0 ≤ d ≤ t,
the sphere of radius t in Vn over GF (q) contains exactly
V (n, t) vectors as follows.
V (n, t) =
t∑
i=0
(ni )(q − 1)i. (12)
If t or fewer errors occur in a codeword x, then the
received vector y may differ from the center of the sphere
S(x, t), but cannot get out from the sphere. In these cases, y
would be decoded into x. On the other hand, if the number
of errors is greater than t, then either:
1) The decoder detects the existence of the errors but
is unable to correct it when the received vector v
falls outside of all codeword spheres. This refers to
the decoder failure.
2) The decoder misinterprets or miscorrects the received
vector v for some other codeword c¯ when the received
vector falls into the radius t of the sphere of c¯. v(x)
would be decoded into another codeword. This refers
to the decoder error we previously described.
Table II
THE ENCODING AND DECODING TIME OF RS CODES OVER GF(28) (μS
=10−6 SECOND)
t = 2 t = 4 t = 8 t = 16 t = 32
Enc. 4 μs 7 μs 14 μs 26 μs 52 μs
Dec. with 0 err. 4 μs 8 μs 18 μs 43 μs 113 μs
Dec. with t err 29 μs 66 μs 142 μs 365 μs 1090 μs
Computing the probability of DE is the same as comput-
ing the number of vectors in the spheres outside the sphere of
the codeword c. Since we consider every valid codeword as
the center of the spheres, there are exactly as many spheres
as codewords in the vector space Vn over GF(q). If we take
one sphere of codeword c, there exist (qk−1) other spheres,
each of which is with one valid codeword as the center.
Therefore, decoder error occurs when the received v falls
into one of those (qk − 1) spheres. It follows that the total
numbers of vectors in the (qk−1) spheres is (qk−1)V (n, t).
Then, the probability of decoder error is given by
Pr(DE) =
(qk − 1)V (n, t)
qn
=
(qk − 1)∑ti=0(ni )(q − 1)i
qn
(13)
Combining (10) and (13), we estimate the probabilities
of FA and FR in a code polynomial. Table I shows the
probability of DE for various t. If we set a reasonably big
t (i.e., small k), the probability of DE would be negligible;
that is, the probabilities of FA and FR would be negligible.
On the other hand, the BS has the probability 1-Pr(DE) to
locate the errors, meaning that no FA and no FR would
happen.
In short, in most settings, FA in RSMAC is quite small;
that is, forging a message is negligible.
V. PERFORMANCE EVALUATION
In this section, we estimate the computation cost and the
transmission cost of RSMAC.
A. Computation Cost
RSMAC gets better performance while the energy con-
sumption of employed RS codes is smaller than the en-
ergy consumption of the RF transmission we saved. More
speciﬁcally, we build the RS implementation in laptop PC
with 2.4GHz CPU. The result is shown in Table II. The
computation time is linearly increased with the value of t.
But in most conﬁgurations, we think that the computation
costs are quite small and affordable for SNs. Besides that, we
only locate errors without correction such that we can further
save some computation from skipping the error correction
in the RS decoding.
ллп
A Native APIs Protection Mechanism
in the Kernel Mode against Malicious Code
Hung-Min Sun, Hsun Wang, King-Hang Wang, Member, IEEE, and
Chien-Ming Chen, Student Member, IEEE
Abstract—As new vulnerabilities on Windows systems are reported endlessly, it is more practical to stop polymorphic malicious code
from exploiting these vulnerabilities by building an behavior-based monitor, rather than adopting a signature-based detection system or
fixing these vulnerabilities. Many behavior-based monitors have been proposed for Windows systems to serve this purpose. Some of
them hook high-level system APIs to detect the suspicious behaviors of code. However, they cannot detect malicious code that directly
invokes Native APIs. In this paper, we present a novel security scheme that hooks Native APIs in the kernel mode. This method
effectively prevents malicious code calling Native APIs directly. It introduces an average eight percent computation overhead into the
system. Analyses and a series of experiments are given in the paper to support our claims.
Index Terms—API hooking, Windows API, code injection.
Ç
1 INTRODUCTION
LESSONS from monocultural agriculture teach us thepossibility of large-scale crop losses when a new virus
pattern shows. Notably, similar situation also appears in the
modern computer world as most of the PCs are with Wintel
architecture. That enables remote attackers to hack into other
computers easily. Many computers run the same software
that contain the same vulnerability can be exploited by code
injection attacks. Attackers inject their code into these software
and force them to abnormally execute the injected code.
For instance, a host running a tainted FTP server program is
attacked by a worm. The worm can overflow the FTP server
program’s buffer with harmful code (injected code) through
some vulnerabilities. Next, the worm modifies the program
stack and points it to the code. The program will then be
redirected to the segment of code and execute these harmful
code. Then, the victim computer will be controlled by the
attacker and spread the infection to other victims.
Essentially during the infection process, infected code
needs to execute privileged commands via invoking system
services, more specifically, native APIs. For example, the
injected code intends to store itself into the file system, it
needs to create a file. Without invoking system services, it
may require over thousands lines of machine code to
reimplement files I/O. However, injected code normally
cannot carry such a large amount of instructions for two
reasons. First, the vulnerable buffers in host programs may
have limited sizes, it is infeasible for the injected code to
conduct every operation with raw code. Second, injecting
such a large amount of instructions are easily detected by
network-based IDS. In fact, it can be done by a few line of
code by invoking system services. Since injected code must
invoke system services, infections can be effectively avoided
by forbidding injected code invoking system services.
Before going further, we need to explain how would
system services be invoked by legitimate programs and
injected code. A typical scenario is illustrated in Fig. 1.
Legitimate programs are usually built using high-level APIs
in MFC, .NET, or other libraries. Some of these APIs need
system services for task executions. They may relay their
requests to middle-level APIs from kernel32.dll, or directly
reach the user-mode lowest level APIs from ntdll.dll.
Ntdll.dll is the entrance to the kernel mode. All user-mode
APIs are expected to reach this entrance for system services.
Ntdll.dll passes the requests to the service dispatcher in
kernel, as known as KiSystemService, where the requests are
redirected to the suitable kernel service providers. Mean-
while injected code may act like other legitimate programs
to invoke system services, by calling user-mode APIs to
arrive ntdll.dll. Another way is to directly request the
services from KiSystemService, without reaching ntdll.dll. To
the best of our knowledge, no injected code is excluded
from them while still maintain a reasonable code size.
In bothWindows and Linux systems, API hooking1 based
methods are popular to stop injected code through protect-
ing system services. By inspecting the behaviors of how
APIs are called, these methods intend to allow all legitimate
code to call system services, at the same time, disallow all
injected code to call system services. They are preferred by
the commercial market over other approaches like compiler-
based [1] or pattern-matching-based [2], [3], [4] methods.
First, they do not require the programs’ source code, which
are generally unavailable. Also, they have real-time re-
sponses and therefore can be deployed in stand-alone hosts.
The major challenge of these methods is to accurately allow
IEEE TRANSACTIONS ON COMPUTERS, VOL. 60, NO. 6, JUNE 2011 813
. H.-M. Sun, H. Wang, and C.-M. Chen are with the Department of
Computer Science, National Tsing Hua University, Hsinchu, Taiwan 300.
E-mail: hmsun@cs.nthu.edu.tw, {zeno, kkyy}@is.cs.nthu.edu.tw.
. K.-H. Wang is with the Hong Kong Institute of Technology, Hong Kong.
E-mail: kevinwang@hkit.edu.hk.
Manuscript received 21 Dec. 2009; revised 24 Sept. 2010; accepted 20 Jan.
2011; published online 10 Feb. 2011.
Recommended for acceptance by M. Eltoweissy.
For information on obtaining reprints of this article, please send e-mail to:
tc@computer.org, and reference IEEECS Log Number TC-2009-12-0621.
Digital Object Identifier no. 10.1109/TC.2011.46. 1. Sometimes is referred as system call hooking in Linux.
0018-9340/11/$26.00  2011 IEEE Published by the IEEE Computer Society
attacker model that we intend to tackle by illustrating its
capabilities and goals. Finally, we describe one important
prior work by Nguyen et al. [14].
2.1 Invoke Native APIs
Windows systems provide many high-level APIs for
application development. Some of these APIs require system
services to accomplish their functionalities. An application
built on the top of these high-level APIs will first call one or
more user-mode APIs. These APIs will recursively invoke
lower level APIs and eventually reach the portal to the
kernel mode, ntdll.dll, which consists of a set of Native APIs.
Native APIs are the fundamental interfaces in the user
mode, in which application programmers should not call
any API that has a lower level than Native APIs.
Fig. 2 shows how a system service, for example,
NtCreateFile is requested. Note that the dispatch ID of
NtCreatFile is 25. The following sequence is involved:
NtCreatfile:
mov eax, 25
mov edx, Fastcall_addr
call edx
Fastcall Stub:
mov edx, esp
sysenter
The parameters for running the system service are
prepared in the stack in advance. The dispatch ID (25) and
the address of fastcall stub are loaded to the register
eax and edx, respectively. Then, it calls into Fastcall
Stub. Fastcall Stub records its origin in the register esp
and executes sysenter instruction in ntdll.dll. Note that
sysenter is a kernel-mode instruction that switches the
system from the user mode to the kernel mode.
Consequently, KiSystemService, the service dispatcher in
the kernel mode, looks up the system service dispatch table
(SSDT) with the dispatch ID in eax and then provides the
corresponding system service, ZwCreatFile. After the
kernel completes the system service and desires to switch to
the user mode, it returns the address that was previously
stored in esp.
2.2 Attacker Model
The attacker of the system is defined as injected code that can
exploit some vulnerable processes. The goal of injected code
is to invoke system services without calling any user-mode
API.Wedeclare the attacker breaks our system if it is allowed
to invoke system services with the following capabilities:
1. Injected code is not allowed to call high-level APIs
included in user32.dll, gdi32.dll, kernel32.dll, or
even ntdll.dll on Windows. We assume that any
high-level API invoking will be detected by other
protection mechanism.
2. Injected code has the complete control of the stacks.
It can read and write the memory from the stacks.
3. Injected code cannot scan code segment of the
legitimate program. This property is implicitly
assumed in Nguyen et al.’s scheme. Otherwise,
injected code can derive the permutation from their
scheme. In practice, reading that segment may
trigger general protection faulted by the OS.
4. Injected code is forbidden to the modify read-only
memory page. Windows provides Win32 APIs to
protect the memory from modification. To disable
the read-only flag, injected code is required to
invoke the Win32 APIs, which they are disallowed
to call.
5. Unlike rootkits or other malware, injected code
cannot alternate their thread ID, process ID, modify
hard drive, nor scan other processes’ memory space.
To capture these attacks, we shall adopt a system that
monitors the KiSystemService in the kernel mode and
ntdll.dll in the user mode.
2.3 Reviewing Nguyen et al.’s Scheme
A prior work by Nguyen et al. [14] also captures the attack
by monitoring the SSDT. The architecture of their system is
illustrated in Fig. 3. Their system includes a monitor
program and a KiSystemService hooking driver. When a
program is started up as a protected process, the monitor
program will record its process ID (PID) into its protection
list. Then, the monitor will customize the process’s ntdll.dll
such that the dispatch IDs of all system services are
reordered randomly. When the protected process invokes
a system service, say NtCreateFile, it will enter the
kernel with a scrambled dispatch ID, 18. The KiSystemSer-
vice hooking driver will check the PID of the caller to see if
the process on the protected list. If the PID is in the
SUN ET AL.: A NATIVE APIS PROTECTION MECHANISM IN THE KERNEL MODE AGAINST MALICIOUS CODE 815
Fig. 2. The routine in requesting a system service, e.g., NtCreateFile,
which has the dispatch ID 25.
practical even the solutions create high-computational
overhead. Payer et al. [4] proposed one of these solutions
that consists of many checks on the whole malicious code.
The method detects NOP zone and searches a long
executable chain. After primary filtering, the doubtful code
segments are further verified by a neural network. This
method is able to detect polymorphic malicious code in a
more precise way by constantly up-to-date training.
Linn et al. [10] designed a procedure to prevent mimicry
attacks [8] in Linux. They record the process addresses that
call system service into the Interrupt Address Table (IAT).
When the process invoke a system service, it is intercepted
by their framework in the kernel mode. Therefore, they can
check that whether this invoking system call is legitimate by
looking up the caller’s address in the IAT. Yet this method
is hard be migrated to Windows system. It is because that
obtaining the callers’ addresses in Windows kernel is a
difficult task.
In 2005, Rajagopalan et al. proposed a scheme to
authenticate system calls [9] in Linux systems. When a
function tries to invoke a system call, it is required to append
a message authentication code (MAC) after the system call
number. This MAC helps the system to authenticate this
system call. Due to the open source property in Linux, their
system can be implemented by directly modifying the
kernel. The same principle can be applied on Windows.
However, since the source code of Windows is not open for
public research, appending messages during system calls
would be a challenge in implementation.
Researchers also presented many other solutions
through protecting Windows APIs. Rabek et al. proposed
a user-mode monitor DOME [6] that is developed using
the Detoured API call [20] released by Microsoft. DOME
disassembles the byte code of a program and records the
addresses of functions invoking Win32 APIs. When system
services are invoked, the DOME monitor will trace the
address of the caller and justify if this request is legal.
Wang et al. [12] presented a static analysis method to
detect malicious program. Their method collects the calling
sequences of native APIs from legitimate programs and sets
up a data model using support vector machine (SVM).
Then, it can detect malicious code by analyzing its calling
sequences. Unfortunately, this method is unable to stop
malicious code in real time and malicious code can easily
mimic a legitimate calling sequence.
Battistoni et al. [13] proposed WHIPS that is one of the
few Windows-based protection system works in kernel
mode. WHIPS inspects every system request in kernel. It
validates the caller’s process name, the service it requests,
and the parameters of the requests using a predefined
access control database. It blocks requests that are invalid.
The major challenge in using WHIPS is to define the access
control database properly, especially to decide what
parameters are safe.
Nguyen et al. proposed a framework to diversify API
numbers [14]. This framework protects the system in the
same layer as our scheme. Same as our system, this method
can be implemented by hooking SSDT rather thanmodifying
the kernel. We have reviewed its drawbacks in a previous
section. All these drawbacks are fixed in our paper.
4 APPROACH
4.1 Overview
The ultimate goal of our design is to authenticate a system
service caller in the kernel mode. However, constructing a
protection mechanism in the kernel mode is extremely
difficulty owing to the following two reasons. First, the
Windows systems firmly define functions and data struc-
tures, like SSDT, that disallows developers to customize
their kernel easily. They may implement their system plug-
ins as a kernel driver that hooks on the kernel. The
limitation of such driver is that it has to follow the system
flow protocol. Second, Windows systems forbid intermodes
memory access for the sake of security. As a result, a kernel-
mode driver cannot read memory spaces of the user mode
directly. Due to these restrictions, instead of authenticate a
system service in kernel, we opt to implement our system as
a kernel driver and load it into the kernel mode as a plug-in.
The driver is responsible for guiding the processes into the
validation functions, while these complex validation func-
tions are placed in the user mode.
Our system has four components: the Monitor, the
Prevalidation function, the Validation function, and the driver.
Fig. 4 shows the architecture of our system. The detail
procedures are as follows:
. Step 1. At the beginning, a protected process is
initiated by the monitor. The monitor will customize
the ntdll.dll for the process when the process starts.
Before the process calling sysenter, it goes
through a prevalidation function that specified by the
customized ntdll.dll.
. Step 2. After entering the prevalidation function, come
vital information will be cached and prepared. The
process then enters the kernel mode.
. Step 3. After entering the kernel for the first time, the
process will be guided to a validation function by our
driver. This validation function will authenticate
legitimate processes in requesting system services. It
will stop illegal attempts in requesting system
services and alert the monitor.
. Step 4. An authenticated process will enter the
kernel mode again.
SUN ET AL.: A NATIVE APIS PROTECTION MECHANISM IN THE KERNEL MODE AGAINST MALICIOUS CODE 817
Fig. 4. The architecture of our system.
4.5 Validation Function
The validation function is a segment of code located in the
customized ntdll.dll. A process that enters kernel for the first
time will be guided to this function by the driver. First, the
function restores the stack pointer esp from the addresses
saved at S. Then, it validates a process by inspecting the
password P popped from the stack. Recall that the password
is a 32-bit string concatenated by a 23-bit key K and a 9-bit
dispatch ID. IfK equals to the key registered by the monitor
at load time, the process is authenticated. In this case, it
restores the register from stacks, moves the dispatch ID to
eax, and executes sysenter to reenter the kernel. Other-
wise, this process is suggested to be hijacked by some
malicious code that are unable to push the correct password
before requesting system service. The validation function
will then log this event and alert the system administrator.
This process will also be terminated to avoid system crash or
compromised. Notice that regardless the validation function
decides to grant or deny the request, itwill explicitly erase the
password P from the memory to prevent injected code
learning its value.
5 EXPERIMENT AND ANALYSIS
In this section, we will illustrate the overhead brought by
our design and analyze the security aspect of the scheme.
5.1 Experiment
In order to evaluate the overhead brought by our imple-
mentation, a set of experiments were conducted on a 2.8 GHz
Intel Pentium 4 machine with 256 MB RAM running
Microsoft Windows XP Professional with kernel version
5.1.2600. In each set of experiments, the running times with
andwithout the protection of ourmechanismwere recorded.
The kernel driver was implemented using the Microsoft
Windows Driver Kit [21]. A driver loader, OSRLoader [22],
was used for hooking the driver onto SSDT. Twenty
important Native APIs were chosen to protect.
The first experiment investigated the overhead in
hooking different Native APIs individually. We wrote
several C programs that calls one of these Native APIs for
1,000 times. The average numbers of CPU cycles spent were
recorded. However, the arguments were omitted while
calling these APIs. Therefore, these calls were stopped at
once after passing SSDT and will return fail without
carrying the actual request. For the hooked test, most of
the running time should be spend on the our protection
mechanism. This can help us to estimate the actual running
time of our mechanism.
The second experiment illustrated the overhead when
protected Native APIs are called by C functions. Another
Cprogram invoked theC functionfopen for 1,000 times. The
arguments were properly placed in the C function, thus APIs
would accomplish their tasks. In these two experiments, only
oneNativeAPIwas hooked. Each experimentwas conducted
for 10 times in both the original system and the system with
the protection enabled. We measured CPU cycles consumed
and took the average as the experimental results.
We conducted the third experiment to give the perfor-
mance of the system while running some real-life applica-
tions. In this experiment, we calculated the time consumed
by running several applications that are both computation
and I/O demanding. They included WinRAR, WinAVI, and
regedit.exe. This should reflect the overhead of our scheme
incurred to the system.
At last, an experiment was done to demonstrate the
loading times of different programs. We loaded programs
with different sizes into memory in three distinct fashions.
The first one did not apply our mechanism and solely
reflected the time needed to invoke a process by the OS. The
second one corresponded to the regular loading mechanism
described above. The third one was a speedup version,
which will be further described in Section 8.2. Popular
applications include Internet Explorer, WinRAR, Visual
C++, MS Word, and CuteFTP are subjected to the experi-
ment. Number of CPU cycles consumed in loading different
programs for each case will be recorded.
5.2 Performance Overhead Evaluation
Table 1 shows the execution time in loading native API
functions. On average, our mechanism induced 36.7 percent
overhead in the runtime. This number shows the additional
time from calling a Native API to the point that entering the
kernel mode (i.e., the time consumed in prevalidation
function, validation function, entering to and exiting from
the kernel mode). Roughly, an additional 13.93 CPU cycles
are need per each time native API is invoked. The overhead
in percentage is diluted from 36.7 to 9.1 percent when the
API is invoked by a complete C functions instead. Results in
Table 2 simulate a more practical situation. The computa-
tion overhead induced in general-purpose applications
were around 8.8 percent. This result proved our system is
indeed practical. Fig. 6 demonstrates that the loading time
are increased by 103.6 percent in the regular case and
9.8 percent in the simplified case. The additional loading
time incurred in both cases are acceptable.
6 CASE STUDY
In this section, we study a case in using our prototype
system. We focus on the process notepad.exe in this
study to investigate how the memory and registers change
during the time process is invoked and the save button is
SUN ET AL.: A NATIVE APIS PROTECTION MECHANISM IN THE KERNEL MODE AGAINST MALICIOUS CODE 819
TABLE 1
Experimental Results for Experiments 1 and 2 (Unit: CPU Cycle)
a 23-bit random number with 9-bit 0 padding. Next, the
registers are backed up in the stacks. The validation
address S is positioned at _PID distant away from the
top of the register where the variable _PID stores process
ID. Before entering the kernel, it prepares the address of
validation function and is expected to return to that address
while the first return from the kernel.
A driver is hooked on the kernel function ZwCreate-
File as shown in Fig. 10. The function retrieve the current
process ID and compare if the process has visited the kernel
before. If not, the function will return to the validation
function. Otherwise, the requested will be handled.
The validation function restores the registers and the
password. It extracts the upper 23 bits and compare with
the key. If the key is correct, it will reenter to the kernel for
the request function. Otherwise, it will flow to an exception
handler.
Throughout the program, no message box is popped up.
The overhead of execution time, for both initialization of the
process and execution of a notepad function, introduced by
the mechanism is limited (see Section 5.1). Our lab tests
conclude that the mechanism is transparent to users.
7 SECURITY ANALYSIS
We want to analyze the security of the scheme by first
illustrating that any system service will go through the
validation function. Recall the attacker model that we have
defined in Section 2.2. When the injected code invokes a
system service and enters the kernel, it will be checked by
the kernel that if it is a protected process and it has
requested the service before. Given that PID is unforgeable
without calling system service, the kernel will immediately
exit and return to the address contained in R. In addition, R
is a read-only memory and it contains the address of
validation function. Therefore, the injected code will be
guided at the validation function.
Second, injected code is very unlikely to pass the
validation function. The injected code passes the validation
function only if it process the random keyK. Notice that the
random key K has 23 bits and is randomly assigned during
the load time of the process. Realizing that without the
knowledge ofK, injected code can be successfully guess the
value of K with probability 223. The prevalidation and
validation functions are hardcoded with the valueK. By the
assumption that injected code is disallowed to scan the code
segment, injected code is unable to learn the value K. When
the legitimate code requests a system service, the password
K will be pushed to stack. However, it will be cleaned up in
the validation function. Besides, injected code is unable to
interrupt the calling process. Therefore, the injected code
learns nothing about the value K.
Last, we can show that the validation function would not
be modified. Validation function is located at the code
segment, which is located in read-only pages. Unless the
injected code has privilege access control, the validation
function cannot be overwritten.
We have mentioned that it is safe to let the attacker know
S, the location that stores the stack pointer. The argument is
that the stack pointer is pointing to a segment of code
containing the key K. However, the key will only appear in
the segment if system service is called through in a
legitimate way. Once the legitimate call is completed, the
key will be popped and erased. Since no malicious code can
interrupt a legitimate service call at the middle to reveal the
key, letting the attacker know the position of S does not
reveal the value of the key. Besides, changing the value of S
and make the validation function to retrieve a wrong value
of key would not bring any benefit to the attacker other than
denying the system service. Yet, denying the execution of
the code is never a reasonable intention to an attacker who
is possessing the execution thread.
It worths to discuss when multiprocessing and multi-
threading take place. In a multiprocessing system, the
addresses of the same DLL in different processes are virtual
and mapped to the same physical address. When a DLL is
modified in a process, OS performs Copy on Write that
duplicates a copy of the DLL for the process. Therefore,
customizing ntdll.dll is independent to other processes. In
other words, unprotected processes will not share the
modified ntdll.dll with the protected processes in our
mechanism.
If a protected process invokes CreateProcess function
to create a new child process, it will introduce a new
problem. This is because the ntdll.dll of the new process is
loaded from disk, instead of being copied from the parent
process. Also, the child will obtain a new PID that is not
registered in the monitor. Then, this child will be unpro-
tected from the kernel list. We may fix this problem by
hooking CreateProcess in kernel32.dll, or directly hook-
ing ZwCreateProcess in ntdll.dll. When the hooked
function is invoked, the monitor program will be informed
and will alert the system administrator. It can also auto-
matically include the child into its protection by injecting the
hook.dll into the child.
Threads of a multithreading process share the same
customized ntdll.dll, the same PID, but having different
stacks.Whenanew thread is created, it inherits theprotection
sincentdll.dll andPIDare sameas theoriginal process. In case
of two threads call invoke a service at the same time, the
kernel can still determine if a thread has entered the kernel
before. It is because the kernel will record thread ID with the
PID and the requested system service. This also shows that
injected codewill be captured by the validation function even
when the process has multiple threads.
SUN ET AL.: A NATIVE APIS PROTECTION MECHANISM IN THE KERNEL MODE AGAINST MALICIOUS CODE 821
Fig. 10. A driver hook on the kernel function ZwCreateFile.
[7] Y. Ye, D. Wang, T. Li, and D. Ye, “IMDS: Intelligent Malware
Detection System,” Proc. 13th ACM SIGKDD Int’l Conf. Knowledge
Discovery and Data Mining (KDD ’07), pp. 1043-1047, 2007.
[8] D. Wagner and P. Soto, “Mimicry Attacks on Host-Based
Intrusion Detection Systems,” Proc. Ninth ACM Conf. Computer
and Comm. Security, pp. 255-264, 2002.
[9] M. Rajagopalan, M. Hiltunen, T. Jim, and R. Schlichting,
“Authenticated System Calls,” Proc. Int’l Conf. Dependable Systems
and Networks (DSN ’05), 2005.
[10] C.M. Linn, M. Rajagopalan, S. Baker, C. Collberg, S.K. Debray, and
J.H. Hartman, “Protecting against Unexpected System Calls,”
Proc. 14th Conf. USENIX Security Symp. (SSYM ’05), p. 16, 2005.
[11] M. Rajagopalan, S. Baker, C. Linn, S. Debray, R. Schlichting, and J.
Hartman, “Signed System Calls and Hidden Fingerprints,”
Technical Report TR04-15, Dept. of Computer Science, The Univ.
of Arizona, May 2004.
[12] M. Wang, C. Zhang, and J. Yu, “Native API Based Windows
Anomaly Intrusion Detection Method Using SVM,” Proc. IEEE
Int’l Conf. Sensor Networks, Ubiquitous, and Trustworthy Computing
(SUTC ’06), pp. 514-519, June 2006.
[13] R. Battistoni, E. Gabrielli, and L.V. Mancini, “A Host Intrusion
Prevention System for Windows Operating Systems,” Proc. Ninth
European Symp. Research in Computer Security (ESORICS ’04),
pp. 352-368, Sept. 2004.
[14] L. Nguyen, T. Demir, J. Rowe, F. Hsu, and K. Levitt, “A
Framework for Diversifying Windows Native APIs to Tolerate
Code Injection Attacks,” Proc. Second ACM Symp. Information,
Computer and Comm. Security (ASIACCS ’07), pp. 392-394, 2007.
[15] Vendicator, “Stack Shield,” http://www.angelfire.com/sk/
stackshield/, Jan. 2000.
[16] C. Cowan, S. Beattie, J. Johansen, and P. Wagle, “PointGuard:
Protecting Pointers from Buffer Overflow Vulnerabilities,” Proc.
12th Conf. USENIX Security Symp. (SSYM ’03), p. 7, 2003.
[17] C. Cowan, M. Barringer, S. Beattie, G. Kroah-Hartman, M.
Frantzen, and J. Lokier, “FormatGuard: Automatic Protection
from Printf Format String Vulnerabilities,” Proc. 10th Conf.
USENIX Security Symp., p. 15, 2001.
[18] T. Chiueh and F. Hsu, “RAD: A Compile-Time Solution to Buffer
Overflow Attacks,” Proc. 21st Int’l Conf. Distributed Computing
Systems, pp. 409-417, 2001.
[19] D. Larochelle and D. Evans, “Statically Detecting Likely Buffer
Overflow Vulnerabilities,” Proc. 10th Conf. USENIX Security Symp.,
2001.
[20] G. Hunt and D. Brubacher, “Detours: Binary Interception of
Win32 Functions,” Proc. Third Conf. USENIX Windows NT Symp.,
July 1999.
[21] “Windows Driver Kit,” http://www.microsoft.com/whdc/
devtools/WDK, 2011.
[22] “OSR Driver Loader,” http://www.osronline.com/, 2011.
[23] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, and D.
Boneh, “On the Effectiveness of Address-Space Randomization,”
Proc. ACM Conf. Computer and Comm. Security, http://dblp. uni-
trier.de/db/conf/ccs/ccs2004p.html#ShachamPPGMB04,
pp. 298-307, 2004.
Hung-Min Sun received the BS degree in
applied mathematics from the National Chung-
Hsing University in 1988, the MS degree in
applied mathematics from the National Cheng-
Kung University in 1990, and the PhD degree in
computer science and information engineering
from the National Chiao-Tung University in 1995,
respectively. He was an associate professor at
the Department of Information Management,
Chaoyang University of Technology from 1995
to 1999, and the Department of Computer Science and Information
Engineering, National Cheng-Kung University from 2000 to 2002, and
the Department of Computer Science, National Cheng-Kung University
from 2002 to 2008. Currently, he is a full professor at the Department of
Computer Science, National Tsing Hua University. He has published
more than 150 international journal and conference papers. He was the
program cochair of 2001 National Information Security Conference, and
the program committee member of many international conferences. He
was the honor chair of the 2009 International Conference on Computer
and Automation Engineering, 2009 International Conference on Com-
puter Research and Development, and 2009 International Conference
on Telecom Technology and Applications. He serves as the editor in
chief in the International Journal of Digital Content Technology and its
Applications, and the editorial member of many international journals
including the ISRN Communications and Networking, International
Journal of Security, Advances in Information Sciences and Service
Sciences: An International Journal of Research and Innovation,
International Journal of Intelligent Information Processing, and Journal
of Next Generation Information Technology. He won many best paper
awards in academic journal and conferences, including the annual best
paper award in Journal of Information Science and Engineering in 2003,
the best paper award in MobiSys ’09, NSC ’05, NISC ’06, NISC ’07,
CISC ’09, and ICS ’10. He won Y.Z. Hsu Scientific Paper award, Far
Eastern Y.Z. Hsu Science and Technology Memorial Foundation, 2010.
His research interests include network security, cryptography, and
wireless networks.
Hsun Wang received the BS degree in compu-
ter science and information engineering from
Feng Chia University in 2006, the MS degree in
information system and application from the
National Tsing Hua University in 2008. He is
currently working in a company of design and
manufacturing for information and communica-
tion product. He is responsible for the firmware
of notebook and other mobile products.
King-Hang Wang received the BS degree in
information engineering from the Chinese Uni-
versity of Hong Kong in 2002 and the PhD
degree in computer science from the National
Tsing Hua University in 2010. He is currently a
lecturer in the Hong Kong Institute of Technol-
ogy. His research interests include information
security, digital rights management, steganogra-
phy, and mobile authentication. He has been an
IEEE member since 2006.
Chien-Ming Chen received the BS and MS
degrees in computer science and information
engineering from Fu-Jen Catholic University in
2000 and 2002, respectively. He is currently
working toward the PhD degree in computer
science from the National Tsing Hua University.
His current research interests include provable
security, applied cryptography, multimedia se-
curity, and digital right management. He has
been an IEEE student member since 2007.
. For more information on this or any other computing topic,
please visit our Digital Library at www.computer.org/publications/dlib.
SUN ET AL.: A NATIVE APIS PROTECTION MECHANISM IN THE KERNEL MODE AGAINST MALICIOUS CODE 823
Figure 1. The flow chart of the ISAIAL algorithm.
II. INDEX SEARCHING ALGORITHM WITH INDEX
ASSOCIATED LIST (ISAIAL)
In the traditional VQ system, a digital image is vector-
quantized block by block in the raster scan order to pro-
duce an index map. Since the similarity in the region of
pixel domain implies to the region of index domain, there
exists similarity between neighboring indices in the index
map. The work [15] introduced the coding structure, called
relative index table, and proposed a lossless VQ index
compression scheme, called Index Searching Algorithm with
index Associated List (ISAIAL). The relative index tables
are used to exploit the correlation between adjacent indices
in the index map. In this article, two modified relative index
tables are proposed to further improve the performance of
ISAIAL. Two methods for constructing modified relative
index tables will be proposed in Section III.
The proposed compression scheme is based on the ISA-
IAL scheme, as illustrated in Algorithm 1. Fig. 1 shows the
flow chart of ISAIAL algorithm. The notations of Algorithm
1 is explained as follows.
• indexL : the quantized index of the neighboring left
block of the current block
• indexT : the quantized index of the neighboring top
block of the current block
• indexP : the quantized index of the previous input
index (Most of the time, indexP = indexL, but when
the input index is at the leftest position of the image,
indexL is not exist.)
• rsize(k) : the number of the elements stored in the
relative index table of the index k
• rk,h: the index value which is stored at the position h
of the relative table of the index k
Algorithm 1 compresses the current index i by four cases
(The detailed description of ISAIAL is ignored here due to
limited space. The interested readers can refer to [15]). The
third case (steps 7-9) is to encoded the current index i by
using relative index tables. This paper improves the ISAIAL
by using two modified relative index tables instead of the
original relative index table. In Section III, we will describe
how to build the modified relative index tables.
Algorithm 1 The basic structure of ISAIAL algorithm
Require: The index map of an image after doing VQ
process.
Ensure: The compressed corresponding index map of the
input image.
1: repeat
2: Get the next index i of the input index map in the
raster scan order.
3: if i = indexL then
4: encode the current index as 00
5: else if i = indexT then
6: encode the current index as 01
7: else if i ∈ {rindexP,h|h = 1, 2, . . . , rsize(indexP )}
then
8: encode the current index as 10 followed by the
binary representation of h
9: else
10: encode the current index as 11 followed by the
binary representation of i
11: end if
12: until No any other quantized index which has not been
encoded
222
that is matched to the h-th position of the relative index
tables for codeword i, i.e., Cih records how many indices
are encoded by h-th elements of the relative index table for
codeword i. Therefore, we can measure Pir by (3).
P˜ir =
∑2r
h=1 Cih∑
h Cih
(3)
Similarly, we measure wi by (4)
w˜i =
∑
h Cih∑
i
∑
h Cih
(4)
According to the decoding procedure introduced above, the
proposed ISAIAL can exactly (lossless) recover the original
index map produced by conventional VQ. In other words,
ISAIAL introduces no extra loss of information compared
with the conventional VQ, [12] and [13] together.
The approach introduced above can be also employed
to calculate an optimal size for each relative index table
in M-1 and M-2 with a little modification. Recall that the
sizes of relative index tables in M-1 and M-2 are distinct.
More specifically, the optimal size of a relative index table
highly depends on the hit rate. In the following, we illustrate
how to determine an optimal size of the relative index
table for codeword i. Subsequently, the sizes of the other
relative tables can be computed by using the same method.
Let Rit(i) denote the relative index table for codeword i.
Suppose that Pr is the hit rate of the Rit(i) when the Rit(i)
uses r bits to represent the elements. We calculate an optimal
size r by minimizing (5) to reach the best bit rate in ISAIAL.
Pr · r + (1− Pr) log2 n, r = 1, . . . , log2 n (5)
Equation (5) represents the bit rate of Rit(i) when it uses
r bits to encode its elements. Similarly, the hit rate Pr can be
also measured by the approach introduced previously with
a little modification (see (3)). A counter Ch is employed
to record the number of indices in the index maps that is
matched to the h-th position of Rit(i), i.e., Ch records how
many indices are encoded by h-th element of the Rit(i).
Therefore, we can measure Pr by (6).
P˜r =
∑2r
h=1 Ch∑
h Ch
(6)
IV. EXPERIMENTAL RESULTS
In order to prove the excellent effects of our proposed
algorithms, we confirm the results by the following experi-
ments. All experiments are implemented on Windows 2000,
CPU P4 1.6 GHZ, RAM 256MB. The images in the USC-
SIPI image database [16] are used as test images. First, we
select five 512×512 monochromes with the block size 4×4
to be the training set of LBG algorithm for generating the
codebook. Besides, we choose three kinds of codebook sizes,
128, 256, and 512. The bit rate of the proposed algorithm
is computed by
Table I
PERFORMANCE COMPARISON OF THE PROPOSED METHODS M-1 AND
M-2 IN TERMS OF BITS PER PIXEL (BPP)
Method 128 256 512
SOC 0.28 0.33 0.41
Hu-Chang 0.27 0.35 0.43
HM-1 0.24 0.29 0.36
HM-2 0.23 0.28 0.33
M-1 0.23 0.27 0.34
M-2 0.22 0.26 0.31
RAR 0.23 0.29 0.36
ZIP 0.33 0.40 0.49
ARJ 0.34 0.42 0.50
BR = [LT Num× 2 +RT Num× (2 + r) (7)
+Full Num× (2 + p)]/(M ×N)
• LT Num : The number of the blocks whose indices
are the same as their left or top indices.
• RT Num : The number of the blocks whose indices
are not the same as their left or top indices, but can be
found in the relative index table.
• Full Num : The number of blocks whose indices are
not the same as their left or top indices, and can not
be found in the relative index table, either.
• r : The number of bits used to identify the members of
the relative index table.
• p : The number of bits needed for storing the index of
the codeword in the codebook.
• M,N : The length and the width of the image (mea-
sured by pixels)
The experimental results are shown in Table I. In the
experiments, the proposed methods are compared with the
existing lossless index compression techniques (SOC [12]
and Hu-Chang [13]) and with some well-known commercial
lossless compressors, such as ZIP, RAR, and ARJ. ZIP
and ARJ are the systems based on the adaptive Huffman
coding and LZ77. RAR is the system uses a combination
of statistical, entropy, and dictionary based compressors.
When the codebook size is 128, the bit rate reduction is
14.3% ∼ 17.9% to SOC[12], 11.1% ∼ 14.8% to Hu-Chang
algorithm[13], and 45.5% ∼ 47.7% to traditional VQ even.
When the codebook size is 256, the bit rate reduction is
12.1% ∼ 18.2% to SOC, 17.1% ∼ 22.9% to Hu-Chang
algorithm, and 42.0% ∼ 46.0% to the traditional VQ. When
the codebook size is 512, the bit rate reduction is 12.2% ∼
17.1% to SOC, 16.3% ∼ 20.9% to Hu-Chang algorithm, and
35.7% ∼ 39.3% to the traditional VQ. Table I also shows
that the performance of ISAIAL more significantly outper-
forms the commercial compressors as the larger codebook
(i.e., 512) is used.
224
國科會補助專題研究計畫項下出席國際學術會議心得報告 
                              日期： 100  年 7 月 28 日 
一、參加會議經過 
這次參加的會議為 ACC 2011，舉辦地點為馬來西亞-Kota Kinabalu 市中心的
Kinabalu Daya Hotel。 本次發表的論文為 A Robust Defense Scheme to Resist 
Routing Attacks in Mobile Ad Hoc Networks.在與來自世界各地的學者交流之後，
對於本研究有非常正面的幫助，藉由深入的討論與思考，可以確實的提升本篇論文
的研究品質，以及深思如何從這篇論文繼續延伸出更多的研究方向，收獲良多。 
二、與會心得 
除了較正式的議程之外，ACC 2011 還有一個比較特別的 Free Talk 時段，讓與會學
者藉由輕鬆聊天的方式來交換不同的研究經驗。透過這種方式可以磨練自己的社交
計畫編號 NSC 97－2221－E－007－055－MY3 
計畫名稱 多群體, 安全比較, 與邏輯運算之同態加密系統設計 
出國人員
姓名 陳耀鑫 
服務機構
及職稱 清華大學 博士生 
會議時間 
100 年 7 月 16 日
至 
100 年 7 月 17 日 
會議地點 馬來西亞 – 沙巴 
會議名稱 
(中文)第三屆應用計算、電腦科學、電腦工程會議 
(英文)2011 3rd World Congress in Applied Computing, Computer 
Science, and Computer Engineering (ISTP) 
發表論文
題目 
(中文)行動隨意網路下抵擋路由攻擊之防禦機制 
(英文) A Robust Defense Scheme to Resist Routing Attacks in Mobile Ad 
Hoc Networks 
陳耀鑫 <iisaintz@gmail.com>
ACC 2011 Acceptance Letter for Paper 31
ACC 2011 <acc2011@easychair.org> 2011年6月4日下午7:56
收件者: Yao-Hsin Chen <yaohsin.chen@is.cs.nthu.edu.tw>
Dear Yao-Hsin Chen,
31: A Robust Defense Scheme to Resist Routing Attacks in Mobile Ad Hoc Networks
Thank you for your submission to ACC 2011. We are pleased to inform you that, according to the reports from
anonymous reviewers, the following distinguished work from you has been accepted for EEIC 2011, with the
publisher of All accepted papers will be published by Advances in Communication Technology, ISSN 2160-
0708, which will be indexed by ISTP
You are kindly reminded with the following important notes:
1. Open the link and find a lot of information of paper submission and registration.
http://www.engineering-press.org/acc2011/istp/
2. In order to make high quality of Proceedings, the camera-ready version should follow format. Kindly
download from here
http://www.engineering-press.org/acc2011/istp/
3. After Finish the final Paper, you can prepare a Copyright Release Form. The copyright should download,
print, write author names, paper title, sign a name and date, and scanned it to PDF format
http://www.engineering-press.org/acc2011/istp/
4. Kindly download the registration form and pay for it,
http://www.engineering-press.org/acc2011/istp/
and send both registration form and a scanned receipt from your bank to above Email  acc2011reg@163.com
before June 15, 2011. If you have not paid for your paper in that time, your paper will not be published.
5. The e-copy official acceptance Letter could be download though
http://www.engineering-press.org/acc2011/istp/Acceptance_letter_ei.doc
Write you write author names, paper title and print it
Kindly send Final paper (doc format), copyright, registration form and a scanned receipt to
acc2011reg@163.com before June 15, 2011
Sincerely,
Program Committee of ACC 2011
E-mail: acc2011reg@163.com
URL: http://www.engineering-press.org/acc2011/
Answer the following question in scale (1-7, 1-low and 7 high)
Quality of the abstract: 5
Relevance to the conference: 5
Introduction and motivation: 4
Presentation of the "state of the art": 3
Description, originality of the own contribution: 3
Presentation of the results: 4
Conclusions and future work: 4
Readability, quality of the English: 4
Quality of the figures: 4
Quality of format: 4
2011/6/7 Gmail - ACC 2011 Acceptance Letter for …
https://mail.google.com/mail/?ui=2&ik=53… 1/2
 A Robust Defense Scheme to Resist Routing Attacks  
in Mobile Ad Hoc Networks  
Hung-Min Sun1, a, Chiung-Shun Chen1,b, Ci-Lun Chen1,c and Yao-Hsin Chen1,d 
1 Department of Computer Science, National Tsing Hua University 
Hsinchu, Taiwan 30013 
a hmsun@cs.nthu.edu.tw, b mikemouse@is.cs.nthu.edu.tw,  
c alantrue@is.cs.nthu.edu.tw, d yaohsin.chen@is.cs.nthu.edu.tw 
Keywords: Ad hoc networking, routing protocol, routing attack, packet-dropping problem, DoS. 
 
Abstract. Wireless network technology is demanding and continually growing. However, 
unconstrained dynamic nature of the topology of mobile ad hoc networks makes them vulnerable to 
various types of attacks including routing attacks. Black hole attacks belong to one such type of 
attacks which disrupt the routing functions in MANETs. Rushing attacks also enable the attackers 
with limited resources and no cryptographic material to destroy the operation in MANETs. 
Wormhole attacks which are more sophisticated attacks still can easily crumble the connection in 
MANETs. These attacks greatly reduce the performance of the networks. Moreover, they are able to 
partition the network and degrade the connectivity of the network.  In this paper, we propose a robust 
scheme to defense these routing attacks in MANETs and improve the performance of the networks.  
Introduction 
A MANET is considered a collection of wireless mobile nodes that are capable of communicating 
with each other without the utilization of a network infrastructure or any centralized administration. 
Due to the limited transmission range of wireless network interfaces, each node participates in an ad 
hoc routing protocol that allows it to discover multi-hop paths through the network to any other node. 
However, as a result of some fundamental characteristics, wireless MANETs are particularly 
vulnerable to attackers: the medium is easily monitored, the topology of the network is dynamic, the 
networking protocols rely on distributed cooperation of the nodes, and the nodes have constrained 
capabilities. 
In current on-demand routing protocols such as ad hoc on-demand distance vector (AODV) [10] 
and dynamic source routing (DSR) [11], they are designed on basis of trustfulness. They assume that 
the nodes in the network can cooperate to forward packets. However, malicious nodes exploit this 
vulnerability to launch various denial-of-service (DoS) attacks in order to disrupt the routing in ad 
hoc networks. Like black hole attacks, rushing attacks, wormhole attacks and flooding attacks, they 
seriously threat the performance of MANETs. 
The primary goals of this paper are to design a robust scheme to defense above DoS attacks in 
MANETs and improve the network performance. Firstly, a strong detection system is proposed to 
effectively detect the misbehavior of malicious nodes. It must work properly even if multiple 
malicious nodes are collusive and try to circumvent the detection. Secondly, for effectively utilization 
of the observation in the network, a secure and cooperative reputation system is proposed. The 
proposed reputation system is necessary to defense false accusation caused by malicious nodes. 
Finally, two mechanisms are proposed to prevent from the above DoS attacks and can improve the 
throughput of the network. 
Related Work 
In this section, we introduce problems and previous solutions. In 2000, Marti et al. [1] remarked 
this packet-dropping problem. A malicious node launches a denial of service (DoS) attack by 
dropping packets. In the past, many researches [2] [3], are proposed to solve the packet-dropping 
 TREP a message means that this is a TEST reply 
CONFIRM a message means that this is a CONFIRM packet 
Seq a sequence number for CONFIRM packet 
DataCount record the numbers of packets recently sent by source node 
WARNING a message means that this is a WARNING packet 
InvalidCount record the numbers of packets which doesn’t validly forward by 
intermediate node 
 
After a period of time, source node S will transmit a CONFRIM packet to the destination node. 
And the CONFRIM packet contains the information about the amount of the packets which are sent 
by source node S in the period. All the neighbors of the intermediate nodes can overhear this 
CONFIRM packet. Thus, they can compare the numbers of the packets recorded in its monitoring 
table and the numbers of the packets provided by the CONFIRM packet to verify whether the 
intermediate node validly forwarded those data packets which are sent by source node S in the period. 
If the comparison is not equal, it means that the intermediate node is misbehavior and may be a 
malicious node. 
In the network, each node monitors several intermediate nodes on different data flows. A data flow 
is defined according to a pair of the source node and the destination node. Fig. 3 shows different data 
flows in the network. Data flow 1 is from source node S1 to destination node D2. Data flow 2 is from 
source node S2 to destination node D1. Node I acts as the intermediate node for these two data flows. 
Node NW which is a neighbor of node I should create two entries in its monitoring table to monitor 
node I. Later, we will introduce the monitoring table. 
                      
Figure 3. An example of the data flow.        Figure 4. Three phases in the Neighbor Watcher technique. 
 
(3) Neighbor Watcher algorithm. The Neighbor Watcher technique is divided to three phases, Test 
phase, Data Transmission phase, Termination phase, which are depicted in Fig. 4. The detail is 
described as follows.  
(a) Test phase. After a node discovers a new route, it will transmit a TREQ packet to the 
destination for examining the connection of this path and notify all Neighbor Watchers in this route to 
monitor the intermediate nodes. The TREQ packet is formed as follows: [ TREQ, IPS, IPD, TS, 
SignS(IPS, IPD, TS) ]. We utilize TS to prevent from the replay attack. IPS, IPD and NS are regarded as a 
unique flow ID. In normal case, the TREQ will be routed to the destination through all intermediate 
nodes, so all neighbors of the intermediate nodes will overhear it. When a Neighbor Watcher 
overhears a TREQ, it first verifies the signature by the public key of the source node. If the signature 
is false, it will directly discard this request. If true, it will create an entry in its monitoring table to 
record this flow. The structure of monitoring table is showed in Table 2. For example, in Fig. 2, when 
node N1 overhears a TREQ sent by node B and successfully verifies it, node N1 will add an entry in its 
monitor table, such as Table 2. The Record fsield is used to record the numbers of the packets 
forwarded by node B in this data flow. 
Table 2. The monitor table. 
Source Destination Time stamp Target Record 
S D TS B 0 
 
 one’s own direct observations, but it has the drawback that they cannot effectively utilize all 
information available. Thus, this paper proposes two types of reputation system that can mitigate 
false accusations which are disseminated by malicious nodes. 
(1) Basic Reputation system. Each node maintains a suspicious rating for every node in the 
network. A suspicious rating is between 0 and 1. In the beginning, suspicious ratings are set to 0. The 
suspicious rating may be set to 1, when someone suspicions strongly that the misbehaving node is an 
attacker. Each source node calculates the suspicious ratings according to the information reported by 
Neighbor Watchers. The information is mainly provided by the InvalidCount field in the WARNING 
packet. We divide the misbehavior into three levels, light misbehavior, middle misbehavior, and 
heavy misbehavior by LowMisbehavingThreshold and HighMisbehavingThreshold. The system 
adopts different ratios to tally suspicious ratings according to the difference of misbehavior. 
For instance, Fig. 6 depicts the diagram of curves about how to calculate the suspicious point. In 
Fig. 6, the LowMisbehavingThreshold is set to 0.3 and HighMisbehavingThreshold is set to 0.6. The 
LowSuspiciousPoint is set to 0.05 and HighSuspiciousPoint is set to 0.2. The 
MaximumSuspiciousPoint is set to 0.5. At most, a misbehaving node is once added by 0.5 suspicious 
points. The misbehavior is defined according to following value: 
ketCountAllSentPac
ntInvalidCougRateMisbehavin =                                                                                                      (1) 
MisbehavingRate means the level of the misbehaving node. If the MisbehavingRate is lower than 
LowMisbehavingThreshold, it is belong to the light misbehavior. If the MisbehavingRate is higher 
than HighMisbehavingThreshold, it is belong to the heavy misbehavior. If the MisbehavingRate is 
between LowMisbehavingThreshold and HighMisbehavingThreshold, it is belong to the middle 
misbehavior. 
In light misbehavior, the misbehaving node may just lose few packets due to some normal reasons, 
such as moving away, overloading, or power consideration. We tolerate the type of misbehaving 
nodes and just increase few suspicious points in following formula: 
oldvingThreshLowMisbeha
ousPoLowSuspicigRateMisbehavinPointSuspicious int×=                                                                      (2) 
However, in middle misbehavior, the misbehaving node has some problems lead to lose a large of 
packets and it may be a malicious node. We will add the suspicious point in following formula: 
( ) ( )( ) ousPointLowSuspicioldvingThreshLowMisbehaholdavingThresHighMisbeh
ousPointLowSuspiciiousPointHighSuspicoldvingThreshLowMisbehagRateMisbehavinPointSuspicious +
−
−
×−=
       (3) 
Moreover, in heavy misbehavior, the misbehaving has seriously lost a huge amount of packets. So, 
the abnormal node must need more penalties with following formula: 
( )
( )
( ) iousPointHighSuspicholdavingThresHighMisbeh
iousPointHighSuspicntpiciousPoiMaximumSus
holdavingThresHighMisbehgRateMisbehavinPointSuspicious
+
−
−
×−=
1
                                                                    (4) 
For example, while the source node infers that the suspicious node dropped 80% percent of data 
packets, the suspicious rating of the node will be added by 0.35 and the source node will send a 
TERMINATE packet to the destination instantly. Sometimes, a normal node may be decided as 
misbehaving node in some conditions, such as being overload, moving away. For this reason, each 
node automatically restores all suspicious ratings by 0.01 after every periodic interval. 
(2) Cooperative Reputation. For effectively utilizing observations of Neighbor Watcher, every 
node shares the information gathered by Neighbor Watcher scheme with all nodes in the network. 
However, it is necessary to prevent from the false reputation spread by malicious nodes. In view of 
this, when a node receives accusations send by other nodes, it will temporarily keep them at a period 
time. The node will believe the accusations from others until it directly detects the misbehavior of the 
accused nodes. If it detects that the accused nodes have middle misbehavior or heavy misbehavior 
before the accusations expire, it will adopt these accusations to calculate the suspicious ratings of the 
accused nodes. In general, a common node should cause no more than the light misbehavior. 
Therefore, when malicious nodes arbitrarily spread many false accusations of normal nodes, other 
nodes still do not believe the malicious nodes. When a node detected the middle or heavy 
misbehavior, it broadcasts the following ACCUSATION packet. [ACCUSATION, IPS, TS, 
 In ad hoc network, the packet-dropping attack makes a great effect on the performance. Moreover, 
packet-dropping problem is more severe if it is appended to some DoS attacks such as black hole 
attack, rushing attack, and wormhole attack.  In this paper, we propose a robust scheme to defense 
these DoS attacks.  
In our scheme, a new detection system is proposed to effectively detect the misbehavior of the 
malicious nodes. It can work properly even if multiple malicious nodes are collusive and try to 
circumvent the detection. In addition, a secure and cooperative reputation system is proposed for 
effectively utilization of the observation in the network. This reputation system can effectively 
defense false accusation by the malicious node. Moreover, we propose two mechanisms to prevent 
from the various types of DoS attacks. 
Acknowledgement 
This work was supported in part by the National Science Council, Taiwan, under Contract NSC 
97-2221-E-007-055-MY3. 
References 
[1] S. Marti, T.J. Giuli, K. Lai, and M. Baker, “Mitigating Routing Misbehavior in Mobile Ad Hoc 
Networks,” International Conference on Mobile Computing and Networking − MOBICOM 
2000, pp. 255−265, ACM Press, 2000. 
[2] Y. Rebahi, V. Mujica, C. Simons, and D. Sisalem, “SAFE: Securing pAcket Forwarding in ad 
hoc nEtworks,” International Workshop on Applications and Services in Wireless Networks 
−ASWN 2005, 2005. 
[3] M. Just, E. Kranakis, and T. Wan, “Resisting Malicious Packet Dropping in Wireless Ad Hoc 
Networks,” International Conference on AD-HOC Networks and Wireless − ADHOCNOW’03, 
vol. 2865, pp. 151−163, Springer-Verlag, 2003. 
[4] Y. C. Hu, A. Perrig, and D. B. Johnson, “Rushing Attacks and Defense in Wireless Ad Hoc 
Network Routing Protocols,” ACM Workshop on Wireless Security − WiSe 2003, pp. 30−40, 
ACM Press, 2003. 
[5] J. Kong, X. Hong, and M. Gerla, “Modeling Ad-hoc Rushing Attack in a Negligibility-based 
Security Framework,” International Conference on Mobile Computing and Networking, pp. 
55−64, ACM Press, 2006. 
[6] S. Ramaswamy, H. Fu, M. Sreekantaradhya, J. Dixon, and K. E. Nygard, “Prevention of 
Cooperative Black Hole Attack in Wireless Ad Hoc Networks,” International Conference on 
Wireless Networks − ICWN’03, pp. 570−575, CSREA Press, 2003. 
[7] M. AI-Shurman, S. M. Yoo, and S. Park, “Black Hole Attack in Mobile Ad Hoc Networks,” 
ACM Southeast Regional Conference, pp. 96−97, ACM press, 2004. 
[8] X. Wang, “Intrusion Detection Techniques in Wireless Ad Hoc Networks,” International 
Computer Software and Applications Conference − COMPSAC'06, vol. 2, pp. 347−349, IEEE 
Computer Society Press, 2006. 
[9] Y. C. Hu, A. Perrig, and D. B. Johnson, “Packet Leashes: A Defense against Wormhole Attacks 
in Wireless Ad Hoc Networks,” INFOCOM 2003, vol. 3, pp. 1976−1986, IEEE Computer 
Society Press, 2003. 
[10] S. Das, C. E. Perkins, and E. M. Royer, “Ad Hoc On Demand Distance Vector (AODV) 
Routing”, Mobile Ad-hoc Network (MANET) Working Group, IETF, 1999. 
[11] D. Johnson, D. A. Maltz, and J. Broch, “The Dynamic Source Routing Protocol for Mobile Ad 
Hoc Networks,” Mobile Ad-hoc Network (MANET) Working Group, IETF, 1999. 
[12] A. Rawat, P. D. Vyavahare, and A. K. Ramani, “Evaluation of rushing attack on secured 
message transmission (SMT/SRP) protocol for mobile ad-hoc networks,” International 
Conference Personal Wireless Communications − ICPWC, pp. 62−66, IEEE Computer Society 
Press, 2005. 
97 年度專題研究計畫研究成果彙整表 
計畫主持人：孫宏民 計畫編號：97-2221-E-007-055-MY3 
計畫名稱：多群體, 安全比較, 與邏輯運算之同態加密系統設計 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 2 2 100%  
研究報告/技術報告 0 0 100%  
研討會論文 1 1 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 3 3 100%  
博士生 1 1 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
