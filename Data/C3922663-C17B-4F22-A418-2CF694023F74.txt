前 言 
車牌辨識是確認車輛身份最直接、有效的方法，如能迅速確實的辨認車牌號碼，則車
牌辨識系統就可以被廣泛的用於我們的日常生活，例如：停車場的收費系統、高速公路的
收費系統、贜車的查緝、違規車輛的取締告發等，甚至於可直接用於私人車庫的大門控制。
如此不但可以使得相關工作更有效率，更可節省人力的損耗。也由於車牌辨識有其重要性，
因此不論國內、外皆有相當多的研究人員投入相關的研究，而且也有相當多的研究成果產
生。然而不幸的是雖有如此多的研究成果，但自動車牌辨識系統，至今仍無法廣泛的進入
人類生活，為我們人類所使用。 
而車牌辨識系統至今之所以仍無法廣為使用，究其原因除了自動車牌辨識系統無法擁
有 100%絕對穩定可靠的辨識率外，最主要原因還是辨識的速度問題，即使目前國人電腦的
速度加快了，但是如果要做到即時的自動車牌辨識，通常還是要一台專用的電腦來做車牌
辨識的工作，如此所耗費的成本又太大。 
 
研究目的 
 本計畫之終極目的就是希望能將自動車牌辨識之演算法予以硬體化、晶片化，藉由硬
體電路處理的速度可以即時的辨識車牌號碼，以提高自動車牌辨識系統的實用性，及應用
範圍。而在車牌辨識中，大致可分為二個步驟：一為從影像中找出車牌的位置，一為從車
牌中找出每一個字元，並加以辨認。所以究其根本自動車牌辨識中，最主要的步驟還是要
先找出車牌的位置，所以在本計畫中我們的目的就是在探討車牌定位硬體化的研究，希望
能以硬體電路直接從輸入影像中找出車牌之位置。 
 
文獻探討 
在自動車牌定位中，不外乎利用車牌中的邊線資訊來做車牌的定位，其方法大都是以
梯度（gradient）偵測方法[1][2]，或其它邊線偵測法找出影像中的邊線，再利用垂直及水平
投影的方法找出邊線較為集中的區域做為車牌所在的候選區域。然而在邊線偵測時，往往
我們所得到的邊線不光是車牌上的邊線，它還包括了影像中其它的邊線，諸如：車輛上的
輪廓、散熱孔、商標等也都會有邊線的產生，甚至影像中還有其它廣告招牌、路標等也都
可以偵測到類似車牌上的邊線，因此以邊線來偵測車牌位置，雖是一種最直接簡單的方法，
但往往也會受到其它邊線的干擾，因而誤判車牌的位置。 
因此我們如果可以只偵測到車牌內的邊線，並抑制其它邊線的產生，那麼我們必能更
準確的找到車牌的所在位置，在[3]中我們根據車牌上的字元及車牌本身的顏色，來偵測車
牌上的邊線，使得我們可以更準確的找到車牌上的邊線，並可抑制其它邊線的產生，以至
於能幫助我們更準確的找到車牌所在的位置。 
此外在邊線的偵測上，雖然車牌內會有較多的邊線，但是車牌外的其它區域也會有一
些雜散的邊線存在，此時如果能將原本較為聚集的車牌內邊線，聚合在一塊狀，並把雜散
在影像中的其它邊線消除掉，則將更容易找到車牌的位置。在此方面形態學運算
(morphological operation)[4]則提供我們一個不錯的解決方法，利用形態學運算中的 closing
運算，我們可以將本來就較為集中的車牌內邊線聚集成一區塊，而利用形態學運算中的
opening運算，則可以將原本就雜散在影像中的邊線消除掉。 
在本計畫中我們就是要以彩色邊線偵測的方法，來偵測車牌內的邊線，並利用形態學
的運算來使所偵測到的邊線更能聚在一起，並消除其它非車牌內的邊線，使我們更容易的
能找到車牌所在的位置。而且為了使車牌定位能被即時的完成，我們則提出彩色邊線偵測
及形態學運算的硬體架構，希望藉由此車牌定位的硬體化來幫助我們繼續完成整個車牌辨
識的硬體化、晶片化的工作，使得未來自動車牌辨識系統能被廣泛的應用於人類生活中。 
在本計畫報告中，我們將提出車牌內邊線偵測的方法及其硬體架構，以及可程式規劃
形態學處理器之硬體架構，最後將此兩硬體架構以 FPGA來實作。 
 
1. 車牌內的彩色邊線偵測器 
車牌內邊線的彩色邊線偵測器，主要是用來偵測車牌內的邊線，藉由這些邊線來幫助我
們找到車牌的位置。因此在本節我們將探討國內所使用的車牌顏色，進而根據這些顏色的
min{ | |,| |}     if , ,  have the same sign 
                                  and | | | |,| | | |
0                                                otherwise
WG
R B R G B
E G R G B
∆ ∆ ∆ ∆ ∆⎧⎪= ∆ < ∆ ∆ < ∆⎨⎪⎩
                (4)                 
min{| |,| |}     if , ,  have the same sign
                                 and ,  
0
YK
R G R G B
E B R B G
∆ ∆ ∆ ∆ ∆⎧⎪= ∆ < ∆ ∆ < ∆⎨⎪⎩
                  (5) 
 若要找出所有車牌的邊線，則只要找出EWB、EWG、EWR和EYK這些邊線的最大值即可，
如(6)式所示。當然在一般的應用上我們不需要找出所有種類的車牌，而是只要找出一些特
定顏色的車牌，所以我們也只要找出一些特定顏色的邊線即可，因此可以在(6)式中加入一
些控制位元來決定那些邊線是我們要的(當其所對應的控制位元被設定為1時)，以及那些邊
線不是我們所要的(當其所對應的控制位元被設定為0時)。如(7)式所示。 
{ }( , ) max ( , ), ( , ), ( , ), ( , )WB WR WG YKE x y E x y E x y E x y E x y= .                  (6) { }),( ),,( ),,( ),,( max),( yxECyxECyxECyxECyxE YKYKWGWGWRWRWBWB= .         (7) 
 
1.3 車牌上邊線偵測的硬體架構： 
要偵測車牌上的邊線主要就是要以硬體來實現(1)~(5)式來找出車牌上的邊線，並以(7)式
來找出我們所要車種的車牌顏色，其硬體架構如圖1.所示。在圖1.架構中可分為顏色差值偵
測器( Color difference detector)及顏色邊線選擇器兩部份(Color edge detector)，其中顏色差值
偵測是用來分別找出影像中紅、綠、藍三種顏色成份的差值，再將這些差值，由顏色邊線選
擇器找出我們所要的車牌顏色的邊線。 
 
 
 
 
 
 
 
 
 
 
 
 
R difference 
detector 
G difference 
detector 
B difference 
detector 
R 
G 
B 
Color 
edge 
selector 
, sgn( )R R∆ ∆
, sgn( )B B∆ ∆
, sgn( )G G∆ ∆
Color difference detector 
E 
 
圖 1. 車牌邊線偵測之硬體架構 
 
1.3.1 顏色差值偵測器(Color Difference Detector) 
顏色差值偵測器可分為紅(R)、綠(G)、和藍(B)三種顏色的差值計算，其中紅色差值的計
算如圖2.所示。在圖2.中當影像中的紅色成份輸入到此電路，經過一個像素(即一個clock)的
延遲後，與新進來的像素值做相減後，再取絕對值，就可以得到△Rh(x,y)的絕對值( ( , )hR x y∆ )
與其極性sgn(△Rh(x,y))；同理若原輸入值經由一條線的延遲後(即延遲w個clock，w為影像的
廣度)，再與原輸入影像做相減再取絕對值，則可以得到△Rv(x,y)的絕對值( ( , )vR x y∆ )與其極
性sgn(△Rv(x,y))。然後再選擇兩個絕對值的較大值，即可得到△R(x,y)的絕對值與其極性
sgn(△R(x,y))，也就是實現(1)式的結果，用來計算影像中紅色成份上的所有差值。同樣的結
構如果在輸入端輲入影像的綠或藍色成份(G(x,y)或B(x,y))則我們可以得到影像中綠色或藍
色成份的所有差值(△G(x,y)和△B(x,y))。 
 
1 pixel 
delay 
1 line 
delay 
a 
b 
a 
b 
SUB1 
SUB2 
 
( , 1)R x y−  
( 1, )R x y−  
( , )hR x y∆  
( , )R x y∆  
sgn( ( , ))R x y∆
  ABS2 
ABS1  COMP
a 
a>bb 
MUX 
s 
)),(sgn( yxRh∆
sgn( ( , ))R x yv∆
Bo 
( , )hR x y∆  
Bo 
( , )R x y  
( , )vR x y∆  
S 
S 
  
圖 2. 紅色差值計算 
點非白-紅邊線，我們以 0值做為此邊線的強度值，其架構如圖 5.所示。而同樣的架構也可
以用來偵測白-綠間的邊線以及黃-黑間的邊線。 
R∆  a 
b 
a<b 
comparator 
a 
b comparator 
G∆  
R∆  
B∆  
sgn 
a<b 
 
 
 
minimum 
multiplexer 
      G B∆ ∆
0 
a b 
c 
s 
EWR  
圖 5. 白-紅邊線偵測器的架構 
 
c. Edge selector: 
 
CBW multiplexer multiplexer multiplexer 
EBW     0         EGW       0         ERW       0         EYK     0 
s s s
CGW 
CRW 
Max 
Max 
E
multiplexer 
C                 C                C         C 
A      B          A        B         A        B          A      B
Max 
CYK 
s
 
   圖 6. 邊線選擇器之架構 
 
經由白-黑(WB)、白-紅(WR) 、白-綠(WG) 、及黃-黑(YK)等邊線偵測器的偵測，我們
可以偵測到白底黑字、白底紅字、紅底白字、白底綠字、綠底白字、及黃底黑字等國內常
用車牌內的邊線。當然在某些的應用中，我們並不需要去偵測所有的車牌，因此我們利用
CWB、 CWR、 CWG及 CYK等四個位元來決定那些顏色的車牌邊線需要偵測，整個邊線選擇
器的架構如圖 6.所示。當我們需要偵測某些顏色的車牌時，只要將該對應的控制位元設定
為“1”，則該控制位元所控制的多工器將會選擇該顏色邊線做為輸出，否則該控制位元所控
制的多工器將會選擇“0”值做為輸出。最後選擇最大值做為此邊線點的強度值。 
 
2. 可程式規劃形態學處理器 
可程式規劃形態學處理器主要是提出一個可以任意規劃形態學運算中的結構元件
(structuring element)，以及多種不同的形態學處算。在本節將介紹本計劃所要實現的形態學
處算及其硬體架構。 
 
2.1 形態學運算之介紹： 
在形態學的運算中，首先必須定義一個結構元件(structuring element)，而其中心點稱為
原點(origin)。而結構元件則可以根據不同的運用，定義成不同的形狀如：三角形、方形、
長方形、十字形．．．，並且可以對結構元件內的每一個元素給予任意的值，以從事不同
的運算。在介紹形態學運算前，先對本報告中所要使用的一些符號做一介紹，令 B為一結
構元件，B(m,n) 為結構元件上座標(m,n)這一點的值。令 I為輸入影像，而 I(i,j)為輸入影像中
在座標 (i,j)這一點上的強度值(intensity)。 
以下將對本報告所要實現的形態學運算 Dilation、Erosion、Closing、Opening、
Morphological Gradient及 Top-hat transfer，作一介紹： 
a、 Dilation ⊕： 
Dilation的運算表示為 D= I ⊕ B，而 D(i,j)則可表示為(10)式，Dilation的運算是把結構
元件，放在影像 I(i,j)上，然後求其結構元件所含蓋範圍內影像之像素 I(i－m,j－n)和結構元件之
元素 B(m,n)之和的最大值。而在大部份的應用中，我們可以將結構元件內所有的值都定義為
0，也就是說我們只定義結構元件的形狀而不定義結構元件內的值，如此 Dilation的運算可
 圖 7.是一個結構元件最大為 1×8的可程式規劃 dilation/erosion單元(PDEU)，包括 8個
移位暫存器(Shift Register, SR)、一個比較網路(Compare Network, CN)、及一個 FIFO(First In 
First Out)所構成。其中 SR跟 FIFO的功能是用來暫存輸入影像資料，FIFO的長度為 N-8，
其中 N為輸入影像的寬度，因此，SR跟 FIFO共可貯存一橫列的影像資料，這些資料在每
一個 clock進來時會同時往右移一位。而比較網路(CN)則是用來執行由 SR送來的八筆資料
之最大值(執行 dilation運算時)或最小值(執行 erosion運算時)。 
 
 
 
 
 
 FIFO(N-8) 
I 
CN ODE 
P2 SR P8．．．P1 
D/E 
OBuf   
P7SR SR 
CW 
OSR 
 
圖 7. 1×8之 PDEU架構 
 
 圖 8.為比較網路的內部架構，由八個輸入單元(Input Unit, IU)及七個取大值或取小值
(Max/Min)所組成。另外我們以一個 8個位元的控制字組(Control Word, CW)，來控制輸入單
元的輸入資料，當控制字組中某一個位元被設定為”0”表示其所對應的輸入單元之輸入資料
是不被使用的，藉由此控制字組設定可以原來 1×8的結構元件，成為 1×3、1×4、．．．等
其它形狀，其輸入單元的真值表如表 2所示，而取大值或取小值(Max/Min)的電路則是根據
dilation(D/E=1)或 erosion(D/E=0)來決定要取兩輸入的較大值或較小值，其內部架構如圖 9.
所示。 
 
 
 
 
c 
D/E 
c 
D/E 
Max/Min Max/Min Max/Min Max/Min 
Max/Min 
Max/Min Max/Min 
P8 P7 P6 P5 P4 P3 P2 P1 
D/E 
ODE 
IU IU IU IU IU IU IU IU cD/E
c 
D/E 
c 
D/E 
c 
D/E 
c
D/E
c
D/E
CW 
 
圖 8. 比較網路之架構 
表 2 輸入單元之真值表 
c D/E O 
0 0 FFH
0 1 0H
1 0 I 
1 1 I 
其中：O表輸入單元的輸出，I表輸入 
 
Comparator MUX 
A     B A     B
A>B 
s 
O 
B A 
D/E Out  
圖 9. Max/Min之電路架構 
 
b. 4*8 之 PDEU： 
在圖 10.中我們將四個 1×8的 PDEU串接起來，構成一個 4×8的 PDEU，藉由四個控制
字組(CW1、CW2、CW3、CW4)的設定可以在 4×8的範圍內任意改變結構元件的形狀。在圖
中，輸入影像是由輸入端 I一個 pixel一個 pixel逐一輸入到本電路中，而四個 1×8的 PDEU
的輸出結果再經三個(Max/Min)即可得到最後的結果由 ODE輸出。 
 
若輸入的控制命令 C2-0＝“111”時，控制單元的輸出 DE1=“1”、DE2=“0”表示 PDEU1執行
dilation運算，而 PDEU1執行 erosion運算；而多工器 1(MUX1)選擇原輸入資料(I)做為 PDEU2
的資料輸入(因 s10-11=“01＂)，因此兩個 4×8 PDEU分別對輸入資料做不同的形態學運算；
多工器 2(MUX2)選擇CW1-4做為 PDEU2的結構元件控制，因此整個系統的結構元件由CW1-4
來控制，也就是我們可以設定最大為 4×8的任意形狀之結構元件；多工器 3(MUX3)選擇
PDEU1的輸出做為減法器(Sub)的輸入，因此減法器是將兩個 4×8 PDEU的輸出結果相減；
最後此相減的結果會做為系統的輸出，因多工器 4的選擇輸入(s40-41=“01＂)也就是整個系
可執行(I⊕B)-(IΘB)的Morphological gradient運算。 
 
結果與討論（含結論與建議） 
1. 實驗結果 
 本計劃所提出的硬體架構皆以 FPGA(Field Programmable Gate Array)元件所設計，系統
發展工具為 ALTERA 公司生產之 Stratix_1S10系列 SOPC發展電路板，所使用的晶片元件
為 EP1S10F780C6，系統的設計與規劃使用 QuartusⅡ軟體。在圖 12.(a)~(d)為四種不同顏色
的車牌，在 12.(e)~(f)我們可以清楚的看到在車牌內的邊線都可以很清楚的被偵測出來，而
非車牌部份的邊線，則大都以被抑制。 
 
(a)     (b)     (c)     (d) 
.  
(e)     (f)     (g)     (h) 
圖 12. 各種車牌邊線偵測之結果 
 圖 13.為可程式規劃形態學處理器之實驗結果，在本報告中我們設定可程式形態學處理
器的結構元件為 3×3。其中(a)圖為原輸入影像，(b)~(g)分別為 Dilation、Erosion、Closing、
Opening、Top-hat transfer及Morphological Gradient的處理結果。 
 
(a)     (b)     (c)     (d) 
 
(e)     (f)     (g) 
圖 13. 各種形態學運算後的結果 
