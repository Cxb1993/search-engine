 2
一、中文摘要 
穿透矽通孔(TSVs)是用於連接一個三維晶
片的晶片層間的訊號。不同於傳統的通
孔，TSVs 會佔用設備面積以及跟邏輯閘比
較之下，它們是非常之大。然而，大部份
過往的三維晶片平面規劃只把 TSVs 視為
點，導致在最初的平面規劃後需要執行白
空間重新配置以便插入 TSVs，這樣會得到
一個不理想的佈局。在本計劃，我們研發
出一個非常有效率的三維晶片平面規劃自
動化軟體去同時對功能性組件作規劃及
TSV 的放置，目的是符合固定外形限制下
去作總線長的最優化處理。跟一個目前最
先進的三維晶片平面規劃及 TSV 規劃相比
之下，我們始終如一地產生更好的平面規
劃，在平均上能減少 15%的線長及減少 31%
的 TSV 數目。我們的工具是非常之快，對
幾百個組件的基準去作平面規劃只需要幾
秒的時間，相比之下，之前先進的平面規
劃則需要幾個小時。 
 
關鍵詞: 三維晶片, 三維晶片樓層規劃 , 
固定外形限制的樓層規劃, 穿透矽通孔, 
線長最優化 
 
Abstract 
Through-silicon vias (TSVs) are used to 
connect inter-die signals in a 3-D IC. Unlike 
conventional vias, TSVs occupy device area 
and they are very large compared to logic 
gates. However, most previous 3-D 
floorplanners only view TSVs as points. As 
a result, whitespace redistribution is 
necessary for TSV insertion after the initial 
floorplan is computed which leads to 
suboptimal layouts. In this project, we have 
developed a very efficient 3-D floorplanning 
tool to simultaneously floorplan the 
functional modules and place the TSVs 
together to optimize the total wirelength 
under fixed-outline constraint. Comparing to 
the state-of-the-art 3-D floorplanner with 
TSV planning, we consistently produce 
better floorplans with 15% shorter 
wirelength and 31% less TSVs on average. 
Our tool is extremely fast and only takes a 
few seconds to floorplan benchmarks with 
hundreds of modules compared to hours as 
required by the previous state of the art. 
 
Keywords: 3-D integrated circuit, 3-D IC 
floorplanning, fixed-outline floorplanning, 
through-silicon vias, wirelength 
minimization 
  
二、研究目的與文獻探討 
3-D integration has attracted a lot of interest 
because it holds the promise to provide 
higher device density and higher bandwidth 
beyond Moore's Law. Moreover, 
heterogeneous technologies can be 
comfortably integrated in a die stack which 
provides an economical alternative to 
system-on-chip integration. Other 
advantages to migrate to 3-D IC design 
include smaller footprint, reduced 
interconnect delay, higher system 
performance, and lower power consumption. 
 
A 3-D IC is made up of an IC stack with 
very short vertical interconnections between 
adjacent dies by means of through-silicon 
vias (TSVs). Laying out a design in 3-D will 
change the wirelength distribution compared 
to that of its 2-D layout. More nets can be 
made shorter in a 3-D layout. But TSVs are 
not free and cannot be used indiscriminately. 
3-D IC can be manufactured with a via-first 
 4
redistribution at each annealing step to try to 
insert the buffer and TSV for each net within 
its feasible region as much as possible to 
improve interconnect delay. On the other 
hand, [9] proposed applying 
post-floorplanning whitespace insertion to 
make the whitespace distribution more 
favorable for TSV insertion to reduce the 
total wirelength increase. The resultant total 
wirelength though reduced is limited by the 
initial floorplan of the modules. 
 
Recently, [7] proposed a two-stage 3-D 
fixed-outline floorplanning algorithm with 
TSV planning. In the first stage, hard 
modules and TSV-blocks are simultaneously 
planned for wirelength minimization using a 
simulated annealing engine. Then stage two 
improves the wirelength by re-assigning 
TSVs among the planned TSV-blocks. It 
obtained a significant average wirelength 
reduction of 26% compared to a 
post-processing TSV planning algorithm. 
However, it has a huge runtime overhead. 
For example, it took more than six hours to 
floorplan n300 with three hundreds hard 
modules into four tiers. Moreover, like [8], 
[9], the approach in [7] only works when all 
modules are hard modules which restricts 
their applicability in general. 
 
In this work, we propose a fast algorithm for 
3-D floorplanning with TSV co-placement 
to optimize the total wirelength in an 
accurate manner under fixed-outline 
constraint. We observe that there are two 
challenges associated with floorplanning the 
functional modules and TSVs at the same 
time. Firstly, including the TSVs as the 
floorplanning objects will increase the 
problem size by at least a few times. 
Secondly, there is a large discrepancy 
between the area of a module and the area of 
a TSV. In face of these difficulties, the 
commonly used probabilistic iterative 
improvement approach by simulated 
annealing is unlikely to be effective. Hence, 
we propose a non-simulated annealing-based 
approach. Comparing with the 
state-of-the-art 3-D floorplanner with TSV 
planning [7], we consistently produce better 
floorplans with 15% shorter wirelength on 
average. Our algorithm is extremely fast and 
only takes a few seconds to flooplan n300 
with TSV co-placement in four tiers. In 
addition, it also enables 3-D fixed outline 
floorplanning with smaller footprint area 
than possible with [7]. Finally, unlike 
previous works which only deal with hard 
modules, our floorplanner can handle both 
hard and soft modules at the same time. 
 
三、研究方法 
3.1 Preliminaries 
In this section, we formally define the 
problem and state our assumptions. Then we 
discuss the issue of wirelength estimation in 
3-D floorplanning and describe the 
wirelength estimation model used in this 
work. Lastly, we review the generalized 
slicing tree floorplan representation which is 
adopted in our 3-D floorplanning algorithm. 
 
3.1.1 Problem Formulation 
We are given a netlist of N modules, the 
desired fixed outline W×H for the tiers, and 
the number of tiers L. We have to assign the 
modules to the L tiers, and place the 
 6
subfloorplan orientation, (2) subfloorplan 
order, and (3) slice line direction. In an 
ordinary slicing tree [11], the parent tree 
node of two child subfloorplans A and B is 
labeled “H” or “V” to specify that A and B 
are separated by a horizontal or vertical slice 
line, and the order between the two child 
nodes in the slicing tree specifies the 
top-bottom or left-right order of A and B in 
the layout. In a generalized slicing tree, a 
parent tree node of two child subfloorplans 
can be labeled with “⊕” meaning that both 
horizontal and vertical slice line directions 
are possible, and the top-bottom or left-right 
order between the child subfloorplans is not 
determined yet. In addition, the subfloorplan 
orientation is also left unspecified. So, a 
parent node labeled with “⊕” represents all 
sixteen possible slicing layouts between two 
child floorplans (see Fig. 3). 
 
 
Fig. 3. Sixteen different layouts implied by 
the “⊕” operator in a generalized slicing 
tree. 
 
The advantage of using the generalized 
slicing tree representation is that we can 
maintain a large set of floorplanning 
solutions of each die with a single shape 
curve at the root of a generalized slicing tree. 
Thus we can easily choose a good slicing 
floorplan for each die that can fit into the 
fixed outline. At the end, we can make the 
decision on the subfloorplan order 
(left-right/top-bottom) to optimize the 
wirelength by subfloorplan swapping and 
mirroring. Note that all of these can be done 
very efficiently. 
 
3.2 Algorithm for 3-D Floorplanning with 
TSV Co-placement 
The flow of the proposed 3-D floorplanning 
process is shown in Fig. 4. First, we 
determine a suitable tier assignment of the 
modules to minimize the number of TSVs 
required and balance the utilized area in 
each tier. Second, we insert TSVs into the 
original netlist and break the 3-D nets into 
subnets. Next, the global floorplanning stage 
generates a set of slicing floorplans for each 
tier and keeps them by a generalized slicing 
tree. The original circuit will be partitioned 
into subcircuits after global floorplanning. 
Local enumerative packing is performed on 
these subcircuits to capture all possible 
slicing structures to obtain the complete set 
of slicing floorplans for each die. If none of 
the floorplans generated for a die can fit in 
the fixed outline, a new generalized slicing 
tree will be re-constructed for the die again. 
Otherwise, subfloorplan swapping and 
mirroring are carried out to improve the 
wirelength. Finally, we apply a 
network-flow based algorithm to re-assign 
the TSVs to further reduce the wirelength. 
 
 8
 
 
 
Procedure 1 computes the minimum total 
cost of k-1 cut positions on the linear 
placement from mp to mN under the given 
area constraint and records the 
corresponding cut positions for p = 1, …, N 
and k = 1, … L. The best L-1 cut positions 
on the linear placement that induce a tier 
assignment with the minimum number of 
TSVs is obtained by calling Print Cut 
Positions(1,L). It can be easily checked that 
procedure Compute Partition Cost takes 
O(LN2) time while Print Cut Positions(1,L) 
takes O(L) time. 
 
 
 
3.2.2 Netlist Pre-processing 
Given the tier assignment, we insert TSVs 
into the original netlist and break down each 
net that has terminals on multiple tiers into 
subnets connected by TSVs. If tier i is the 
highest die that contains a terminal of net α 
and tier j is the lowest die that contains a 
terminal of the same net, then one TSV is 
required by net α in each of tier i to tier j-1. 
For example, net a in Fig. 6(a) is a 
4-terminal net with two terminals in tier k 
and two terminal in tier k+2. Net a is broken 
down into subnets a1, a2, and a3 connected 
by two TSVs. We need one TSV in tier k and 
one TSV in tier k+1 to connect net a. 
 
 
Fig. 6. Wirelength is dependent on TSV 
locations. 
 
Note that each TSV is connected to exactly 
two subnets. The placement of a TSV will 
affect the wirelength of the two subnets 
connected to it. For example, when the TSV 
for net a in die k+1 is re-positioned as in Fig. 
6(b), the wirelength of subnet a2 is increased 
while the wirelength of subnet a3 is 
 10
outline. So, we choose to defer the decision 
of the slicing direction to a later stage to 
maintain a high degree of packing feasibility 
when the number of modules in a region is 
less than maxM(lines 25-36). 
 
 
Fig. 8. Global Layout Determination 
 
There are two issues to be further discussed. 
First, if too many TSVs get clustered 
together, they will form a large routing 
obstacle under the via-last technology which 
is not desirable. So how can large TSV 
cluster formation be avoided? Second, the 
exact net model in [13] is for 2-D 
floorplanning, how can it be adapted to 3-D 
nets? We will address these two issues one 
by one. 
 
We can avoid the formation of large TSV 
clusters as follows. After we partition the 
objects of a region in line 28, we check if 
the numbers of TSVs assigned to the two 
new sub-regions will differ substantially 
(line 29). If so, we will re-partition the TSVs 
between the two sub-regions again by 
treating the modules in the two sub-regions 
as fixed nodes. 
 
Now we show how to apply the exact net 
model for 3-D nets. Consider the example 
shown in Fig. 9(a) where subnets netj,k and 
netj,k+1 originate from the same net netj. 
Suppose we have to partition a region 
containing m3 and t2. It can be seen that 
subnet netj,k is connected to m3 and t2 within 
the region to be partitioned and also to m1 
and t1 outside the region as in Fig. 9(b). We 
will project all terminals of netj,k to the same 
plane (Fig. 9(b)) and treat m1 and t1 as fixed 
terminals. The locations of m1 and t1 are set 
at the centers of their respective regions. 
Then we can use the exact net model 
described in [13] to model netj,k to match the 
HPWL cost. Subnet netj,k+1 can be modeled 
in the same way. 
 
 
Fig. 9. (a) Each subnet connects objects 
from two adjacent tiers. (b) All objects 
are projected to the same plane before the 
 12
10), but these operations can change the 
floorplan wirelength. So, we take advantage 
of this property to optimize the 3-D 
wirelength. 
 
 
Fig. 10. Swapping and mirroring. 
 
We carry out a few rounds of optimization 
until convergence. In each round, we 
process the dies from tier 1 to tier L in order. 
But the first round is slightly different from 
the other rounds for two reasons. First, note 
that there can be many valid points on the 
final shape curve of each die, we have to 
make a selection in round 1. Second, when 
we process tier i in round 1, we do not have 
any chosen floorplan for tiers i+1 to L yet. 
So in the first round, we pick at most P valid 
points on the final shape curve of tier 1 to 
optimize. We apply swapping and mirroring 
on all of them to optimize the wirelength in 
tier 1 only. The valid point that results in the 
least wirelength is kept and the other points 
are dropped. Then in the rest of round 1, we 
also pick at most P valid points on the final 
shape curve of each die to optimize. When 
tier i is processed, we will reference the TSV 
locations in the current floorplan of tier i-1 
to optimize the 3-D wirelength. The valid 
point that results in the least 3-D wirelength 
is kept and the other points are dropped. At 
the end of round 1, there is only one 
floorplan kept for each die. 
 
In round 2, we apply swapping and 
mirroring on the floorplan of each die from 
tier 1 to L again. When tier i is processed, 
we will reference the TSV locations in the 
current floorplans of tiers i-1 and i+1 to 
optimize the 3-D wirelength. We can repeat 
a few more rounds until there is no more 
improvement. 
 
3.2.6 Minimum Cost Flow-based TSV 
Re-assignment 
Finally, we re-assign the inter-die signals to 
the TSVs placed within each die using the 
minimum cost flow algorithm to further 
optimize the wirelength. The TSVs of 
inter-die nets are re-assigned tier by tier. For 
tier k, we create a network Nk as shown in 
Fig. 11. Besides a source node s and a sink 
node t, there is a set of net nodes and a set of 
TSV nodes. Each net node represents a net 
that requires a TSV in tier k, and each TSV 
node represents a TSV placed in tier k. 
Every net node is connected to all TSV 
nodes. There is an edge from source node s 
to each net node and an edge from each TSV 
node to sink node t. The capacities of all 
edges are 1 since each net has to be assigned 
to one placed TSV and each placed TSV can 
only be used by a single net. The cost of an 
edge from net node netj to TSV node TSVi is 
equal to the sum of the wirelengths of 
subnets netj,k and netj,k+1 if TSVi is assigned 
to netj. (For k ≥ 2, netj,k denotes a subnet of 
netj that connects all modules and TSV of 
netj that are in tier k, and TSV of netj in tier 
k-1, if any (see Fig. 9). or k = 1, netj,k 
 14
Table I 
Comparing our floorplanning results with 
those by [7] for hard module benchmarks. 
 
First, we compare the quality of result and 
CPU time of our TSV co-placement 
approach with the TSV planning approach 
proposed in [7]. Since the approach in [7] 
cannot handle soft modules, we compare the 
floorplanning results with hard modules 
only for three-tier and four-tier 
floorplanning. The TSV size is 3μm as in [7]. 
For fair comparison, we need to perform 
some post-processing on the output of [7]. In 
[7], the output includes a floorplan of 
modules and TSV-blocks, and the 
assignment of inter-die signals to 
TSV-blocks, but the inter-die signals are not 
assigned to specific TSV locations yet. On 
the other hand, our floorplanner determines 
the exact locations of the TSVs used by the 
inter-die signals. Thus, we used a minimum 
cost flow approach to assign the inter-die 
signals of each TSV-block to specific TSV 
locations within the TSV-block to minimize 
the wirelength. The wirelength of a net is 
estimated by summing up its lateral 
wirelength on each individual die that it 
spans as described in section 3.1.2. The final 
results are summarized in Table I. The 
number of TSVs, wirelength, and CPU time 
under the TSV co-placement columns are 
average values over 100 runs. But since [7]'s 
approach is very time-consuming, the 
number of TSVs, wirelength, and CPU time 
under the [7] columns are average values 
over 10 runs. 
 
 
Fig. 12. A 3-tier floorplan produced by 
our floorplanner for n300. (a) to (c) shows 
the floorplans in tiers 1 to 3. The TSVs 
are shown as red squares. 
 
From Table I, we can see that our 
floorplanner used 31% less TSVs than [7]. 
This shows that our tier assignment 
approach introduced in section 3.2.1 is 
indeed very effective in reducing TSV usage. 
Second, our floorplanner is able to achieve 
100% success rate for fixed-outline 
floorplanning using 15% whitespace for 
both three-tier and four-tier floorplans. Third, 
the average wirelength produced by our 
floorplanner is 15% shorter than [7]. Finally, 
the CPU time of our approach is over three 
 TSV co-placement [7] 
#layer testcase #TSV WL(μm) CPU 
time(s)
#TSV WL(μm) CPU 
time(s)
3 n100 505 146070 1.61 760.4 151094 1414 
3 n200 1043 266419 2.25 1465 311818 8170 
3 n300 1244 380638 2.99 1816.5 439443 21053 
4 n100 677 133980 2.61 1065.9 146883 1607 
4 n200 1572 250829 4.97 2083.3 359647 8974 
4 n300 1758 350980 3.38 2503.7 444659 21947 
  0.69 0.85 1.00 1.00 1.00 3410.84
 16
enumerative packing (section 3.2.4) is often 
necessary to ensure the layout can fit inside 
the fixed outline. And high level 
enumerative packing will alter the 
generalized slicing tree obtained at the 
global layout determination stage. Second, 
we experimented with TSV re-assignment 
that allows the TSVs to be re-assigned to the 
unused whitespace. Therefore, we enlarge 
the set of candidate TSV locations to include 
the whitespace. But we found that the 
resultant total 3-D wirelength did not differ 
much. It is because our floorplanner has 
intentionally evenly spread out the placed 
TSVs on each die, so it is unnecessary to 
consider more candidate TSV locations 
during re-assignment. 
 
四、計劃成果自評 
We considered TSV co-placement during 
3-D floorplanning for wirelength reduction 
and satisfying the fixed-outline constraint. 
We developed a very efficient tool that 
simultaneously floorplan the functional 
modules and place the TSVs in a 3-D IC. 
Comparing to the state-of-the-art 3-D 
floorplanner with TSV planning, we 
consistently produce better floorplans with 
15% shorter wirelength and 31% less TSVs 
on average. Our algorithm is extremely fast 
and only takes a few seconds to floorplan 
benchmarks with hundreds of modules 
compared to hours as required by the 
previous state of the art. 
 
Finally, this project has resulted in two 
theses [16-17]. In addition, two IEEE 
transactions papers [19-20] and five 
international conference papers [21-25] has 
been published. 
 
Table II 
Results of our floorplanner for soft 
module benchmarks 
#layer testcase WS #TSV WL(μm) CPU 
time(s)
3 n100 15% 505 142500 3.19 
3 n200 15% 1043 254757 3.42 
3 n300 15% 1244 363384 4.65 
4 n100 15% 677 129057 1.54 
4 n200 15% 1572 241392 3.85 
4 n300 15% 1758 342535 4.86 
 
參考文獻 
[1] D. Noice and V. Gerousis. Physical 
design implementation for 3D 
IC –methodology and tools. International 
Symposium on Physical Design, 2010. 
http://www.ispd.cc/slides/slides10/4 02.pdf. 
[2] J. Cong, J. Wei, and Y. Zhang. A 
thermal-driven floorplanning algorithm for 
3d ics. In Proc. of the IEEE International 
Conference on Computer-Aided Design, 
pages 306–313, 2004. 
[3] Z. Li, X. Hong, Q. Zhou, Y. Cai, J. Bian, 
H.H. Yang, V. Pitchumani, and C.-K. Cheng. 
Hierarchical 3-d floorplanning algorithm for 
wirelength optimization. IEEE Trans. on 
Circuits and Systems - I, 53(12):2637–2646, 
December 2006. 
[4] P. Zhou, Y. Ma, Z. Li, R.P. Dick, L. 
Shang, H. Zhou, and Q. Zhou X. Hong. 
3d-staf: Scalable temperature and leakage 
aware floorplanning for three-dimensional 
integrated circuits. In Proc. of the IEEE 
International Conference on 
Computer-Aided Design, pages 590–597, 
2007. 
 18
Rectilinear Steiner Tree Construction, in 
Proceedings of ACM International 
Symposium on Physical Design, pp.27-34, 
2010.  
[22] J.Z.Yan, C. Chu, and W.K. Mak, 
SafeChoice: A Novel Clustering Algorithm 
for Wirelength-Driven Placement, in 
Proceedings of ACM International 
Symposium on Physical Design, pp.185-192, 
2010.  
[23] F.Y. Chang, R.S. Tsay, W.K. Mak, and 
S.H. Chen, Cut-Demand Based Routing 
Resource Allocation and Consolidation for 
Routability Enhancement, in Proceedings of 
IEEE/ACM Asia and South Pacific Design 
Automation Conference, pp.533-538, 2011. 
[24] S.H. Wang, Y.Y. Liang, T.Y. Kuo, and 
W.K. Mak, Power-Driven Flip-Flop Merging 
and Relocation, in Proceedings of ACM 
International Symposium on Physical 
Design, pp.107-114, 2011. 
[25] S.I. Lee and W.K.Mak, Simultaneous 
Constrained Pin Assignment and Escape 
Routing for FPGA-PCB Codesign, in 
Proceedings of Field Programmable Logic 
and Applications, pp.435-440, 2011. 
2011 International Symposium on Physical Design 心得
報告 
梁有毅 
  本年度的 ISPD 於美國加州的聖塔芭芭拉舉行，從 3 月 27 到 30 號總共為期
四天，3 月 27 號下午只是一個簡單的報到流程，主要的活動內容都是從 28 號開
始一直到 30 號上午，而於 30 下午大會提供了一個旅遊的行程，提供與會的人士
一個觀光與相互交流的機會。 
 28 號當天上午請來的於 physical design 領域相當有貢獻的 Kuh 教授來為大
家發表了一段簡單的談話，Kuh 教授指導出了許多有名的學生繼續在 physical 
design 領域指導下一代的學子，而我們系上的蔡仁松老師也是 Kuh 教授的學生之
一。於 28 號這天晚宴也以感恩 Kuh 教授為主題，晚宴中邀請了多位 Kuh 教授的
學生來分享和 Kuh 教授的相處經歷。而同樣在這天早上，除了 Kuh 教授的談話
之外，大會也請來了一些知名學者為大家發表一些演說，其中我們系上的蔡仁松
老師也與大家分享了他之前的研究經驗和何謂 progress optimization。 
 於 28 號下午正式開始各篇 paper 的作者報告，而今年度的 ISPD 總共錄取了
19 篇 paper，涵蓋了數個主題，其中有幾篇 paper 跟我們一樣是先被 ASP-DAC 
reject 後，經過修改後才被這次大會錄取，其中還有一篇成為了 best paper 的候
選，這更讓我深刻體會到一時的失敗與挫折並不是永久的，只要能發現錯誤及時
修正都能夠重新獲得肯定。 
 在 29 號下午大會公布了本屆 ISPD routability driven placement contest 的比賽
結果，我與同學也組成了一隊參與了這次的比賽，最後總共有 9 隻隊伍存活下
來，其中有 5 隊來自於台灣。雖然我們隊伍的成果如預期的表現不好，但是經過
這次比賽的練習，讓我們更加熟悉了 placement 所需要用到的技巧，算是相當有
收穫。而今年比賽冠軍是由香港中文大學的隊伍獲得，會後我也與本屆比賽冠軍
隊伍的作者討論了一下比賽心得，讓我十分驚訝的是，他們不是使用 analytical
的方式，這顯現出 analytical 將不再是 placement 的主流方式，也表示說 placement
的演算法仍然有相當大的進步空間，因此我覺得往後我們可以朝著非 analytical
的方向去改善我們這次參與比賽的 placer，應該可以有不錯的成果。 
在這次的大會中看到了幾篇十分有趣的 paper 和好幾位於 physical design 界
相當有名的學者教授，而我也和幾位與會的人與討論交換了心得與想法，讓我開
Power-Driven Flip-Flop Merging and Relocation∗
Shao-Huan Wang
National Tsing Hua University
shwang@cs.nthu.edu.tw
Yu-Yi Liang
National Tsing Hua University
yuyiliang@cs.nthu.edu.tw
Tien-Yu Kuo
National Tsing Hua University
u9562105@oz.nthu.edu.tw
Wai-Kei Mak
National Tsing Hua University
wkmak@cs.nthu.edu.tw
ABSTRACT
We propose a power-driven flip-flop merging and reloca-
tion approach that can be applied after conventional timing-
driven placement and before clock network synthesis. It tar-
gets to reduce the clock network size and thus the clock
power consumption, as well as the switching power of the
nets connected to the flip-flops by selectively merging flip-
flops into multi-bit flip-flops and relocating them under tim-
ing and placement density constraints. The experimental
results are very encouraging. For a set of benchmarks, our
approach reduced the clock wirelength by 30 to 50%. Mean-
while, the switching power of signal nets connected to the
flip-flops were reduced by 2 to 43%.
Categories and Subject Descriptors
J.6 [COMPUTER-AIDED ENGINEERING]: Computer-
aided design (CAD)
General Terms
Algorithms, Design
Keywords
Clock Network, Low Power, Multi-bit Flip-Flop, Post Place-
ment
1. INTRODUCTION
Clock network plays an important role in power consump-
tion as it accounts for up to 50% [1] of dynamic power in
some real circuits for its highest switching rate. Many kinds
of power reduction technique have been proposed. [2, 3]
worked on buffer sizing for clock power minimization. [4, 5,
6] designed some new low-power flip-flop structures. [7, 8, 9]
discussed clock gating. [10, 11, 12] minimized the power of
clock network by considering the location of registers in the
∗This work was partially supported by NSC under grant
NSC 99-2220-E-007-007.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee.
ISPD’11, March 27–30, 2011, Santa Barbara, California, USA.
Copyright 2011 ACM 978-1-4503-0550-1/11/03 ...$10.00.
placement stage. They try to group registers into clusters
and place registers in a cluster closer to reduce the wire-
length of the leaf level of a clock tree. In this paper, we
make use multi-bit flip-flop to reduce the clock power and
switching power of signal nets.
The use of multi-bit flip-flop (MBFF) was first proposed
in [13] for reducing clock delay, controlling clock skew, and
improving routing resource utilization. [14] introduced a de-
sign methodology for MBFF inference during logic synthesis
for area and power reduction. However, to form MBFFs in
early design stage, it is hard to consider its effect on tim-
ing. Recently, [15] introduced a new algorithm to reduce
the power consumption of flip-flops by incrementally form-
ing more multi-bit flip-flops at the post-placement stage.
Figure 1 shows an example of replacing traditional flip-
flops by a multi-bit flip-flop. Because of manufacturing
ground rules in advanced process technology, inverters tend
to be oversized so that an inverter can drive more than one
traditional flip-flop. By merging multiple 1-bit flip-flops into
one MBFF, it is possible to eliminate some inverters. For
example, we can eliminate two inverters after merging in
Figure 1. It will reduce the total area and power consump-
tion of the flip-flops. This is the motivation for [15].
Figure 1: Replacing two traditional flip-flops by a
2-bit MBFF.
More importantly, using multi-bit flip-flop can also reduce
the number of clock sinks. This will reduce the wirelength of
the clock network and the buffers required in the clock net-
work to maintain the slew and balance the skew. Therefore,
power consumed by the clock network will be reduced.
In this paper, we propose a power-driven flip-flop merg-
ing and relocation approach that can be applied after con-
ventional timing-driven placement and before clock network
synthesis. To apply flip-flop merging after initial placement,
Figure 4: The intersection graph.
each other. Every intersected region represents the feasi-
ble region of a MBFF for the corresponding original FFs.
As shown in Figure 4, each intersection of feasible regions
of original FFs is a clique in the corresponding rectangle
intersection graphs2. Therefore, if we consider the case to
minimize the number of clock sinks with timing constraint
only, the problem is exactly the same as minimum clique
partition of a rectangle intersection graph (MCPRIG). The
MCPRIG problem is defined as follows:
Input: Given a rectangle intersection graph G = (V,E).
V is the vertex set representing all rectangles and E is the
edge set representing all intersection relations.
Objective: Find k disjoint cliques to cover all the vertices
in V where k is minimum.
MCPRIG has been proved to be NP-hard in [16], and it
is a special case of our power-driven flip-flop merging and
relocation problem by setting w to 1 in equation (1) and re-
moving the constraints of placement density and library. By
the definition of MCPRIG, it can be reduced to our problem
easily. Hence, we get the following theorem:
Theorem 1. The power-driven flip-flop merging and re-
location problem is NP-Hard.
Although MCPRIG is NP-Hard, it still has some prop-
erty which can help us to solve the power-driven flip-flop
merging and relocation problem. We define some terms and
introduce the property as follows.
Definition 1. A maximal clique is a clique that cannot be
extended by including one more adjacent vertex.
Definition 2. For a vertex vi ∈ V , participating degree of
vi is the number of maximal cliques which cover vi.
Definition 3. A vertex vi is a critical vertex if and only if
the participating degree of vi is 1.
Definition 4. A maximal clique ci is called an essential
maximal clique if and only if ci contains at least one critical
vertex.
Lemma 1. Let Ce be the set of all essential maximal cliques.
|Ce| is a lower bound of k. In other words, k ≥ |Ce|.
Proof. By the definition of essential maximal clique, we
know there exist |Ce| critical vertices covered by different
maximal cliques. Hence, in order to cover these vertices we
need at least |Ce| cliques.
2In a rectangle intersection graph, each vertex corresponds
to a rectangle, and if two rectangles intersect with each
other, there is an edge between the corresponding vertices.
Lemma 1 gives a lower bound of the number of sinks of
our merging problem. Therefore, if we want to minimize the
number of sinks, it is good to start from finding all maximal
cliques. In the next section, we will use these definitions
and lemma to construct an efficient algorithm to solve the
power-driven flip-flop merging and relocation problem.
4. POWER-DRIVEN FLIP-FLOP MERGING
AND RELOCATON ALGORITHM
The proposed design flow is shown in Figure 5. First, we
compute the feasible region of each original flip-flop accord-
ing to the timing slacks after placement. Second, we form
the corresponding rectangle intersection graph and compute
all the maximal cliques in order to get all groups of flip-
flops that can be merged without violating any timing con-
straint (section 4.1). The third step is to find a set of
non-conflicting3 MBFFs by dividing maximal cliques into
MBFFs (section 4.2). The last step is to determine the loca-
tion of each MBFF (section 4.3). Noticeably, there might ex-
ist 1-bit MBFFs in the set of non-conflicting MBFFs. They
are also relocated to further optimize the switching power
of signal nets.
Because our algorithm can take care of original FFs which
are more than 1-bit, we can apply our algorithm iteratively
until there is no further improvement. We note that, al-
though we assign MBFFs to unoccupied grid points sub-
ject to placement density constraints, there may still exist
some overlappings between the MBFFs and pre-placed cells.
Placement legalization can be done using techniques like[17,
18].
Figure 5: Design flow with power-driven flip-flop
merging and relocation.
3Non-conflicting means if one FF has been merged into some
MBFF, then this FF cannot be merged into other MBFF.
In line 5, we generate one candidate from each maximal
clique and push it into a heap. From lines 8 to 12, we pick
the best candidate β from the heap and put it into N if
it does not conflict with any MBFF belonging to N . And
in line 14, we generate another candidate by sampling the
maximal clique that generated β again. Each time we do
the MBFF sampling of a clique, we will select a new target
feasible candidate MBFF which does not conflict with any
MBFF belonging to N . We repeat these steps until all the
FFs are allocated into some MBFFs of N .
We use an example to illustrate the procedure of MBFF
extraction. We are given a MBFF library that contains
1/2/4-bit MBFFs. There are 7 FFs v1∼v7 and all of them
are 1-bit FF. After applying sweep line method, we get two
maximal cliques, c1 = {v1, v2, v3, v6, v7} and c2 = {v4, v5,
v6}. Suppose after the initial sampling, we get MBFF {v1,
v2, v3, v6} from c1 and {v4, v5} from c2 where Cost({v1, v2,
v3, v6}) < Cost({v4, v5}). In the first iteration, we extract
{v1, v2, v3, v6} and put it into N , then genereate a new
MBFF, said {v7}, from c1 after updating c1. The value of
each set after this iteration would be: H = {{v4, v5}, {v7}},
N = {{v1, v2, v3, v6}},P = {v1, v2, v3, v6}, c1 = {v7} and
c2 = {v4, v5, v6}. Again, we extract a new MBFF, {v4, v5},
with the smallest cost from H. After the second iteration,
the sets would be updated as follows: H = {{v7}}, N =
{{v1, v2, v3, v6}, {v4, v5}},P = {v1, v2, v3, v4, v5, v6}, c1 =
{v7} and c2 = {}. In the last iteration, we extract {v7}
from H, and get N = {{v1, v2, v3, v6}, {v4, v5}, {v7}} which
is the set of MBFFs ready for location assignment.
4.3 Decide MBFF Locations
For a non-conflicting MBFF β, we first calculate the weigh-
ted median interval of the x-(y-)coordinate of its fanin(s) and
fanout(s), where the weight of a pin is the switching rate of
the signal net between β and the pin.
We call the region formed by the intersection of these two
weighted median intervals the preferred region of β, as shown
in Figure 7. We call the bins covered by the preferred region
the preferred bins. If we can put MBFF β in its preferred re-
gion, then the switching power of the signal nets connected
to β,
∑
neti∈Net(β)
(αi ×WLi), will be minimized. We set
the rank of preferred bins to 0 and assign increasing ranks
to other bins inside β’s feasible region as in Figure 8. There-
fore, each selected MBFF has a ranked-list of bins, and we
perform bin assignments according to these ranked-lists, and
Figure 7: Example of preferred region. The switch-
ing rate ratio of the nets connected to a certain
MBFF from P1 ∼ P5 are 2:1:1:3:1.
Figure 8: Ranking of bins.
then do the grid assignments. Nevertheless, we might fail to
assign some non-conflicting MBFFs due to placement den-
sity constraint. So, if a non-conflicting MBFF generated
cannot be successfully assigned, we will generate a smaller
MBFF from its originating clique until we can assign it suc-
cessfully.
The schema of grid point assignment is like bin assign-
ment. For each MBFF, if the bin assignment will not cause
bin density violation, then we will find all the preferred grid
points. And we run a breath-first search to find an unoccu-
pied grid point to place the MBFF starting from preferred
grid points. With this assignment method, we can opti-
mize the switching power of the signal nets connected to the
MBFFs.
5. EXPERIMENTAL RESULTS
We implemented the algorithm in C++ and conducted
our experiments on an Ubuntu workstation with 8GB mem-
ory and Intel(R) Xeon(R) E5506 @ 2.13GHz CPU. Cases
t0∼t3 are from [21] and r1∼r5 are from [22]. For r1∼r5, we
assume all the original sinks are 1-bit flip-flops, original tim-
ing slacks and placement densities are generated randomly.
For these 9 cases, we assume the unit resistance and capaci-
tance of wire are 0.0001(Ohm/nm) and 0.0002(fF/nm), and
use Bounded-Skew Clock Tree Routing(Version 1.0) [23] to
perform zero-skew clock tree synthesis. Switching rate of sig-
nal nets connected to flip-flops of these cases are randomly
generated in the range from 0.05 to 0.15.
We tested the 9 test cases with a MBFF library containing
1/2/4-bit MBFFs. The experimental results with the given
library are shown in Table 1 and Table 2. We note that the
ratio between the wirelength of signal nets connected to FFs
and the wirelength of clock network varies from case to case,
the weight w in equation (1) is adjusted accordingly.
Table 1 shows that our algorithm can achieve very good
reduction in terms of number of clock sinks and wirelength
of clock network. For the given library, we can reduce the
number of sinks by 68.90% in average. The same table also
shows, due to the reduction of sinks, the wirelength of clock
tree can be reduced significantly by 40.51%. We can observe
from Figure 9 that the reduction of the number of clock sinks
is roughly proportional to the reduction of the wirelength
of clock network. Figure 10 shows the clock tree synthesis
results of case r1 using [23] before and after merging.
Table 2 shows the overall improvement of αi×WLi of sig-
nal nets connected to the FFs. This product is proportional
to the switching power consumption of the signals. We can
make a rough estimation of the total switching power reduc-
Table 4: Comparison with [15].
Test #FFs [15] Ours
cases FF Power Red. HPWL Red. Run time(s) FF Power Red. HPWL Red. Run time(s)
c1 98 14.8% 8.7% 0.01 15.64% 8.2% 0.01
c2 423 16.9% 5.3% 0.04 17.52% 11.1% 0.05
c3 1692 17.1% 5.2% 0.10 17.41% 11.5% 0.22
c4 5129 16.8% 5.5% 0.28 17.07% 11.5% 0.72
c5 10575 17.1% 5.1% 0.60 17.29% 13.4% 1.89
c6 169200 17.2% 5.1% 78.92 17.52% 11.8% 36.12
avg. 16.65% 5.82% 17.03% 11.25%
Since a larger MBFF would lead to more flip-flop power
reduction as shown in Table 3, we modify our algorithm as
follow. In the stage of MBFF extraction, for each clique,
we find the maximum MBFF size, k, that can be generated,
and we randomly sample ten k-bit MBFFs from each clique.
Then, the one resulting in the largest wirelength reduction of
the nets connected to FFs is chosen as the candidate MBFF.
Finally, we filter out some conflicting candidate MBFFs as
before, and do the location assignment.
We compared the 6 test cases from [15] as shown in Ta-
ble 4. “FF Power Red.” is the reduction of power consumed
by FFs, and “HPWL Red.” is the wirelength reduction of
the nets connected to FFs. The experimental results for [15]
were taken from their paper which were run on a 2.66GHz
Intel i7 PC. We get more flip-flop power and wirelength re-
duction in these cases, and our run time is better than [15]
in the largest test case. If we compare the runtime in Ta-
ble 1 and Table 4, we can see that it is more time-consuming
to minimize the clock network and switching power of the
nets connected to the flip-flops simultaneously. The reason is
that forming a larger MBFF would not necessarily be better
because it may greatly increase the switching power of the
nets connected to it. So we can not greedily pick the largest
MBFF each time, as a result sampling will take more time
and the while loop from line 7 to line 15 in Algorithm 1 will
also take more iterations to terminate.
6. CONCLUSIONS
In this paper, we presented a power-driven flip-flop merg-
ing and relocation approach to reduce the switching power
consumption of the entire circuit. Our algorithm does a
non-conflicting candidate searching and determines the lo-
cation of a multi-bit flip-flop using weighted median interval
and ranking. Experimental results indicated that the num-
ber of clock sinks can be reduced by about 70%. Moreover,
decreasing the number of clock sinks leads to shorter wire-
length of clock tree and hence less power consumption. It
is shown that our works can reduce clock tree wirelength
by 30∼50% and thus the power consumption. Additionally,
our work can also save the power taken by those signal nets
connecting to FFs and the experimental results indicate a
reduction of about 17% in average.
7. ACKNOWLEDGMENTS
We would like to thank Prof. Mark Lin of NCCU for
providing us the benchmarks used in [15].
8. REFERENCES
[1] D. Liu and C. Svensson. Power consumption
estimation in cmos vlsi circuits. IEEE Solid-State
Circuits, 29:663–670, 1994.
[2] K. Wang and M. Marek-Sadowska. Buffer sizing for
clock power minimization subject to general skew
constraints. In Design Automation Conference, pages
153–156, 2004.
[3] G. Wilke and R. Reis. A new clock mesh buffer sizing
methodology for skew and power reduction. In IEEE
Computer Society Annual Symposium on VLSI, pages
227–232, 2008.
[4] A.S. Seyedi, S.H. Rasouli, A. Amirabadi, and
A. Afzali-Kusha. Low power low leakage clock gated
static pulsed flip-flop. In IEEE International
Symposium on Circuits and Systems, pages 3658–3611,
2006.
[5] S. Naik and R. Chandel. Design of a low power
flip-flop using cmos deep sub micron technology. In
International Conference on Recent Trends in
Information, Telecommunication and Computing,
pages 253–256, 2010.
[6] C.C. Yu. Design of low-power double edge-triggered
flip-flop circuit. In IEEE Conference on Industrial
Electronics and Applications, pages 2054–2057, 2007.
[7] S.K. Teng and N. Soin. Low power clock gates
optimization for clock tree distribution. In
International Symposium on Quality Electronic
Design, pages 488–492, 2010.
[8] M. Donno, A. Ivaldi, L. Benini, and E. Macii.
Clock-tree power optimization based on RTL
clock-gating. In Design Automation Conference, pages
622–627, 2003.
[9] Q. Wu, M. Pedram, and X. Wu. Clock-gating and its
application to low power design of sequential circuits.
IEEE Transactions on Circuits Systems I,
47(3):415–420, 2000.
[10] Y. Cheon, P.H. Ho, A.B. Kahng, S. Reda, and
Q. Wang. Power-aware placement. In Design
Automation Conference, pages 227–232, 2008.
[11] Y. Lua, C.N. Sze, X. Hong, Q. Zhou, Y. Cai,
L. Huang, and J. Hu. Navigating registers in
placement for clock network minimization. In Design
Automation Conference, pages 176–181, 2005.
[12] W. Hou, D. Liu, and P.H. Ho. Automatic register
banking for low-power clock trees. In International
Symposium on Quality Electronic Design, pages
647–652, 2009.
[13] R.P. Pokala, R.A. Feretich, and R.W. McGuffin.
Physical synthesis for performance optimization. In
國科會補助計畫衍生研發成果推廣資料表
日期:2011/10/20
國科會補助計畫
計畫名稱: 子計畫一：三維晶片技術的創新樓層規劃研發(2/2)
計畫主持人: 麥偉基
計畫編號: 99-2220-E-007-007- 學門領域: 晶片科技計畫--整合型學術研究
計畫
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
國內獎項 
1. 特優: 99 學年度大學校院積體電路電腦輔助設計軟體製作競賽定題組 
2. 優等: 98 學年度大學校院積體電路電腦輔助設計軟體製作競賽馬拉松組  
 
國外獎項 
1. 3rd Place: IEEE Council on Electronic Design Automation sponsored 2011 
PATMOS Timing Analysis Contest 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
