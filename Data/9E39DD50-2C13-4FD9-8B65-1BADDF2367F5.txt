I 
摘 要 
 
根據著名的 XML 應用軟體商 Sarvega 公司的調查，XML 資料的流量於 2004 年超越了 Email 的流量，
且將於 2007 年超越 Web 流量，這是非常重要的發展趨勢，我們周圍將充斥著許多 XML文件與資料，
大量的 XML 資料將透過網路或其他傳輸媒介在世界各地進行交流與轉換；XSLT 標準轉換語言（W3C
所制訂）主要用來擷取、重組或轉換 XML 資料，因此，如何快速且正確的執行 XSLT 轉換，滿足未
來的需求是我們必頇面對的挑戰。另一方面，在硬體製程技術尚未有關鍵性突破之前，多執行緒
（multithread）多核心（multicore）處理器系統符合使用者高效能且低耗能的需求，也是目前晶片設
計的主流。多核心處理器系統於硬體部分的支援，已逐漸趨於成熟階段，但是在軟體部分，仍然還沒
有準備好。除了研發多核心程式的軟體開發工具之外，哪些應用程式需要多核心處理器，一直是軟硬
體廠商想知道的問題，也是多核心硬體系統是否能被大家所接受的關鍵。根據我們的分析與評估，
XSLT 的轉換是採用不同的樣版套用到 XML source tree 中不同的 tree node 的集合，每個樣版的執行具
有很高的獨立性，非常適合在多執行緒多核心處理器系統下執行，發揮多核心處理器系統的效能。 
 
本研究計畫之計畫名稱為”XSLT optimizer for multicore architecture”，研發 XSLT analyzer 與 XSLT 
optimizer。研究目的為使用程式分析與編譯器最佳化的技術，將 XSLT 編譯為多執行緒多核心之 C 程
式，這種方式可以加速原先使用直譯方式的執行效能，我們同時也將利用多核心處理器的硬體資源，
盡量同時執行可平行執行的 XSLT operations，創造多核心處理器系統的使用價值。Figure I顯示 XSLT
編譯器的基本架構，Table I 列出本計畫於各年度之工作項目與產出。本計畫的研究成果與相關之技
術，將可適時的提供處理大量 XML 資料轉換速度過慢問題的解決方法，同時也將驗證這類的應用很
適合在多核心處理器系統下執行，在學術上，有重要的研究價值；在產業界或日常生活上，讓國內中
小企業能在有限的電腦資源下，快速處理 XML 的資料，提升其競爭力，對產業界也有非常重要的幫
助。 
 
 
關鍵詞：XML、XSLT、編譯器、多核心（multicore）、多執行緒（multithread） 
 
III 
 
Abstract 
 
According to the report from Sarvega, a leading corporation in the area of XML applications, XML traffic 
already exceeds all mail traffic in 2004 and expects to exceed all web traffic in 2007. Every minute and 
every moment, massive XML data files are created, transferred, exchanged, extracted, and re-organized 
through by network or other transfer-medias. XSLT, a standard XML transformation language defined by 
W3C, is used to extract, re-organize and transfer XML data files. Therefore, how we can use XSLT to 
transfer these massive XML data files quickly is a very critical problem we cannot avoid. Besides, the trend 
of processor design is going to multithreaded / multicore architecture to meet the requirement of high 
performance and low power. In this part, many industry companies and research groups work hard on not 
only exploitation of software development tools, but also the application of multicore architecture. 
According to our analysis and evaluation, XSLT transformation use different template to match the 
corresponding nodes in the XML source tree, and each template is isolated in most cases. Consequently, 
XSLT transformation is very suitable to execute under multicore architecture for exploit the performance. 
 
The title of this research project is “XSLT optimizer for multicore architecture”. In this project, we will 
develop an XSLT analyzer and XSLT optimizer. The main objective of this project is to compile XSLT file 
into multithreaded / multicore C program by leverage the technologies of program analyses and compiler 
optimizations. Figure I shows the structure of XSLT compiler and Table I lists the working items at each year. 
From the view of point of performance, the compiled program has a better performance than interpreted 
program. In addition to compile technology, our approach will also try to execute XSLT operations in 
parallel to explore the hardware resources of multicore processor. Accordingly, the research results and 
technologies developed in this project will provide a solution of handling massive XML data files, and prove 
XSLT translation can fit the application of multicore architecture. To sum up, on one hand, this research 
project contributes a very important research value. One the other hand, the result from this project will help 
the industry to advance their capability of processing massive XML data files under limited resources, and 
improve their competition power. 
 
 
Keywords：XML、XSLT、Compiler、multicore、multithread 
 
V 
 
目 錄 
 
 
摘 要 .................................................................................................................................................................................... 2 
Abstract ................................................................................................................................................................................. 4 
目 錄 .................................................................................................................................................................................... 6 
圖 目 錄 .............................................................................................................................................................................. 7 
一、 前言 ......................................................................................................................................................................... 8 
二、 研究背景 ................................................................................................................................................................. 9 
三、 研究方法 ............................................................................................................................................................... 12 
四、 結果與討論 ........................................................................................................................................................... 21 
五、 結論 ....................................................................................................................................................................... 25 
六、 參考文獻 ............................................................................................................................................................... 26 
七、 附錄 ....................................................................................................................................................................... 29 
 
2 
 
 
一、 前言 
 
近年來網際網路對資料儲存、資料交換、資訊傳輸等方面的需求快速增加，因此 W3C 制定 XML
標準用來描述資料內容與格式，經過多年的推廣，XML已成為描述資料的標準語言，並且廣泛地應用
在不同系統之間的資料交換;同樣由 W3C 制定的 XSLT，功能是用來描述如何將 XML文件轉換成其他
資料格式，在XSLT轉換的過程中，XSLT processor同時讀入XML文件與XSLT stylesheet，依據 stylesheet
的範本規則將 XML 文件轉換輸出我們所需要的資料格式。XSLT 常見的應用是將 XML 轉換為適合在
標準瀏灠器上顯示的 HTML文件，除此之外，XSLT 也支援標準的資料交換規則，以符合 B2B（business 
to business）與 B2C（business to customer）的需求。除了以上典型的應用之外，XSLT 所處理的轉換也
逐漸變得龐大且複雑，因此，提昇 XSLT processor 的效能成為一個相當重要的課題。 
 
XSLT processor 通常有兩種實作方法。第一種方法採用直譯器（Interpreter）架構，在 run-time 的階
段，同時解析 XSLT 指令並且對 XML 進行轉換，此種架構的缺點與直譯器相似，執行效率不良、缺乏
最佳化的空間。第二種方法採用編譯器（Compiler）架構，先將 XSLT 樣板（stylesheet）解析過後翻譯
成 C 語言程式碼，之後將此程式碼編譯為執行檔，執行此執行檔，即可對 XML 進行轉換。此方法在
使用相同 XSLT 樣板的條件下，可以重複使用編譯的執行檔，只需翻譯一次 XSLT 樣板，還可以利用
編譯器的相關最佳化方法來提昇效能。從資料安全的角度來看，XSLT 以執行檔的方式運作，轉換內容
較不易被有心人士所知悉。下圖分別為直譯式（Figure 1）和編譯式（Figure 2）的轉換流程。XSLT compiler
將 XSLT stylesheet 翻譯成對應的 C 語言程式碼，經過 Native compiler 編譯後產生與 XSLT stylesheet 相
同功能的執行檔。 
 
XML
XSLT 
stylesheet
XSLT
interpreter
XML
HTML
PDF
Others ...
 
Figure 1: 傳統直譯式的轉換方式. 
 
 
4 
<xsl:stylesheet version="1.0"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
 
<xsl:output method="html" encoding="utf-8"/>
 
<xsl:template match="/">
      <html>
      <body>
      <xsl:apply-templates/>      
      </body>
      </html>
</xsl:template>
<xsl:template match="Course">
  <h3> <xsl:value-of select="Teacher"/> </h3>
  <ul>
       <li><xsl:value-of select="Title"/></li>
  </ul>
</xsl:template>
</xsl:stylesheet>
 
Figure 3: Example of XSLT stylesheet. 
 
 
為了設計 XSLT 之編譯演算法，需要先了解該產生怎樣的程式片段，因此，我們先手動建立一份程
式架構，其中的每個部分，分別對應 XSLT 的相關指令。 Figure 7 是我們編譯出來相對應的 C code，
灰色部分用來處理 XSTL相關的指令，如 apply-templates、value-of，白色的部分則是 function body 的
區塊。 
 
這個架構進行 XSLT 翻譯的主要重點說明如下: 
(1) main function讀取 XML文件，並且建立相對應的 XML tree，我們將操作這個樹狀結構來完成
轉換的工作，它扮演了非常重要的角色。 
(2) 根據 XSLT 的規則，我們從 root 開始比對 pattern並且套用範本，若沒有發現符合的範本，則
依照節點的內建範本來處理，如同 main function的下半段所描述。 
(3) <xsl:template match=”/”>和<xsl:template match=”Course”>以 function call 來實作。 
(4) 在翻譯出來的 C code 中，利用適當的 API來處理 XML 文件中不同的資料節點。 
(5) <xsl:apply-templates>和<xsl:value-of>分別實作出各別的函式。 
 
6 
<html><body>
    All courses
   <h3> Tom </h3>
<ul><li> Computer Architecture </li></ul>
   <h3> Jason </h3>
<ul><li> Programming Language </li></ul>
</body></html>
 
Figure 6: Transformation result. 
 
 
 
三、 研究方法 
 
Figure 8說明了XSLT compiler的軟體架構，整個架構與典型的編譯器架構非常相似，為了保留 XSLT
的特性以及後端分析的方便，在 front-end 階段，我們先將 XSLT 樣板轉換成 IR tree，因為 XSLT 本身
也是 XML 格式，非常適合用 tree structure 來表示。在 Back-end 階段，IR tree 經過 Code generator 翻譯
成相對應的 C code，每個 XSLT 指令分別由獨立的函式來實現，透過呼叫這些函式來完成 XSLT 樣板
的轉換工作。轉換演算法的細節，描述如下。 
 
3.1 <xsl:template> element 
 
XSLT 樣板中的範本（template）依編譯的順序被命名為 template1,template2, template3, ..., templateN，
N 為範本的個數，template0 則預設為處理純文字節點的內建範本。編譯<xsl:template>元件時，會依照
DFS（deep-first search）的順序拜訪範本的樹狀結構，每次拜訪的節點，則會依照節點的內容產生出對
應的程式片段。<xsl:template match=”/”>中的屬性值 match可以被使用來對 XML 節點進行範本比對，
因此在編譯範本時，屬性值 match 將以變數形式被記錄在相對應的 target C code 中，幫助
<xsl:apply-templates>來比對合適的範本。以 Figure 3 的<xsl:template match=”/”>為例，其對應的函式 
templateN 執行順序應為<html>、<body>、<xsl:apply-templates>、</body>、</html>，經觀察得知，執
行順序為 FILO（first-in, last-out），因此我們選擇 stack 結構來處理範本的編譯。Figure 9 為<xsl:template 
match=”/”>的樹狀結構，Figure 10 是範本編譯的過程。首先，我們拜訪<html>和<body>節點，產生對
應的敘述到 target C code 中，<html>與<body>被 push到 stack 中，接著拜訪 xsl:apply-templates，我們
產生一個對應的 function call 到 target code 中，同樣 push節點到 stack 中，繼續搜尋後發現沒有子節點，
就將<xsl:apply-templates> pop 出來，接著 pop 出<html>與<body>，產生 end tag的輸出到 targe code 中，
8 
Parser
IR tree
Target C code
Code generator
Front-end
Back-end
XSLT stylesheet
(source program)
Symbol-table 
manager
Error handler
 
Figure 8: Software architecture of the XSLT compiler Zebu. 
 
 
xsl:template html body xsl:apply-templates
match “/”
 
Figure 9: Tree structure of <xsl:template match=”/”> in Figure 3. 
 
 
Stack
html
body
xsl:apply-templates
Stack
html
Stack
html
body
Stack
html
body
Stack
html
Stack
/* Code fragment in target C 
code */
template2() {
  ...
Output tag <html>   /*(a)*/
Output tag <body>   /*(b)*/
Handle <xsl:apply-template> 
element             /*(c)*/
Output tag </body>  /*(d)*/
Output tag </html>  /*(e)*/
... }
(a) (b) (c)
(d)(e)
 
Figure 10: Code generation and stack data structure. 
 
 
3.2 <xsl:apply-templates> element 
 
xsl:apply-templates element 可以定義一群要交由範本規則處理的節點，一般可分為選擇特定節點及
處理所有子節點兩種情況。經過我們的 XSLT compiler 處理，apply-template 指令將被編譯而產生函式
match_template。為了使 match_template 能正確運作，我們需要每個範本的 match 屬性值，因此在範本
編譯的階段，將屬性值 match記錄在 target C code 的陣列 tlist 中，而在所有範本分析與編譯完成後，
10 
上層的 symbol table 找不到定義的變數，則往下層的 symbol table 去尋找。Figure 13 表示 symbol table
與 scope 之間的對應狀況。 
 
 
/*
 * <xsl:apply-templates> is processed by the function
 * match_template() that visits all child nodes of
 * the current node to check for whether or not a template is matched.
 * - cnode is a pointer that points to an XML tree node.
 */
char *tlist[] = {"__text__", "Course", "/"};
match_template(cnode) {
  ...
/* cnode points to the children of the current code. */
cnode = cnode->children;
while (cnode != NULL) {
   ...
   for (i=0; i<=2; i++) {
      ...
      if (cnode->name matches tlist[i]) {
         switch(i) {
         case 0: template0(); break;
         case 1: template1(); break;
         case 2: template2(); break;
         }
      }
   }
   if (no match)
      match_template(cnode);
   /* cnode points to the next sibling node of the current node. */
   cnode = cnode->next;      
}
}
 
Figure 12: Code skeleton of the function match_template. 
 
 
Symbol table II
Name Value
Data 
type
Symbol table I
Name Value
Global symbol table
Name Value
XSLT tree structure
Data 
type
Data 
type
 
Figure 13: Symbol table and the corresponding scope. 
 
 
 
12 
是否有符合的範本套用，若未發現到可套用的範本，則依 XSLT 的內建規則，呼叫 match_template 繼
續比對根節點的所有子節點。 
 
xsl:template html xsl:for-each
match "/"
"Found!!"
select "/Semester/Course"
template1() {
  ...
  Output tag <html>
 /* Parse XPath expression and store proper information */
 xpath_info = XPath_parse("...");
  /* Identify the XPath-interested node.
     result_node_set points to the set of nodes */
  result_node_set = XPath_evaluation(xpath_info, ...);
  for (i=0; i<size(result_node_set); i++) {
     ...
  }
  ...
}
 
Figure 15: Pseudo code of the <xsl:for-each> element. 
 
 
main()
{
  ...
  Read XML file;
  Construct the corresponding tree structure;
  RootNode points to the root node of the XML tree;
  ...
  /* Begin XSLT transformation */  
  xsltprocessing(RootNode);
  ...
}
/* check whether user-defined templates match the root node */
xsltprocessing(cnode) {
  ...
if (cnode != NULL) {
   for (i=0; i<=2; i++) {
      if (cnode->name matches tlist[i]) {
         switch(i) {
         case 0: template0(); break;
         case 1: template1(); break;
         case 2: template2(); break;
         }
      }
   }
/* If no match, the built-in template rule is applied. */
   if (no match)
      match_template(cnode);
}
}
chAr *tlist[] = {"__text__", "Course", "/"};
...
 
Figure 16: Pseudo code of the main and xsltprocessing functions. 
14 
3.8 Multithreaded XSLT compiler 
 
 為了達到 XML transformation 平行化的目的，我們必頇先分析並且找出可以平行執行的 task，
以完成後續平行執行及合併的工作，因此，我們將分成三個階段來實作，包括 task 分析、task queue
執行、結果合併。 
 
3.8.1 Task 分析 
這個階段主要工作是找出可平行化的 task，由 XML轉換過程可以發現，特定 XML 節點的
轉換並不會影響其他節點轉換，也就是說，節點之間的轉換不具有相依關係，適合作為平
行執行的單位。一開始，我們以 deep-first、left-to-right 的順序來 traverse XML tree，每次比
對到一個節點，就利用 tlist 來檢查該節點是否為欲轉換之節點，tlist 內容為 XSLT compile
階段所記錄的各範本 match 屬性值。若該節點符合轉換條件，則視此節點為可平行化之
task，因此，我們記錄這個節點的資料並且在 task tree 中對應位置產生一個 task節點，task tree
代表所有 task 的合併順序，節點間的順序等同於原來 XSLT 的套用順序，藉由 task tree，可
以確保平行化與循序執行的結果一致。 
 
3.8.2 Task queue 執行 
找出可平行化的 task 後，我們利用 task queue 來實作平行化執行的部分，task queue 是採用
動態方式來分配 task，當其中一個 thread 執行完目前所拿到的 task 後，可以從 task queue
中取得下一個 task，來避免 thread 閒置的情況發生，相對地，將 task 靜態分配給 thread 執
行，較容易產生 load unbalance 的問題。 
 
在這個階段，我們先 fork 出與執行平台之CPU core 個數相同的 thread，thread 依序將 task 放
到 task queue 中，所有 task 放入 queue 之後，thread 再從 queue 中取得 task 來執行。在 XML
轉換的例子中，若範本的轉換內容過於簡單，將導致 task 的執行時間過短，thread 需要頻
繁地從 task queue 取出 task 執行，使得 queue 的存取成為效能的瓶頸，我們也實作相關的
方法，將過於簡單的 task 合併成較大的 task，以改善平行化的效能。在 task 執行的過程中，
遇到 apply-templates 指令時，我們會記錄下目前 buffer 位置，當 thread 執行完一個 task 後，
便將轉換內容記錄到該 task 的 buffer 中，將來我們可以透過 task tree 來讀取 buffer 進行最
後結果的合併工作。 
 
 
3.8.3 結果合併 
在這個步驟，藉由第一階段所建立的 task tree 結構，可以確保 task 結果正確地被合併，我
們依照 deep-first、 left-to-right 的順序來 traverse task tree，並且參考上一個階段記錄
apply-templates 的 buffer 位置，完整合併最後的結果，將結果輸出至 output file，此結果將
與循序執行相同。 
 
16 
 
 
Table 2: Configuration of the experimental environment. 
 
 
 
Table 3: Benchmark programs. 
 
 
 
我們量測五個著名的 XSLT processor（如 Table 4 所示），Figure 18 與 Table 5 顯示各個 XSLT processor
的執行時間，結果顯示我們的 XSLT compiler 有最少的執行時間。Figure 19 與 Table 6 顯示 speedup 的
比較，其比較的 baseline 為 Xalan XSLT processor，結果顯示，我們的 XSLT compiler 平均有 1.36 倍的
加速。 
 
 
 
18 
 
Table 5: Execution time (nanoseconds) for evaluated XSLT processors. 
 
 
 
Figure 19: Comparison of speed-ups for evaluated XSLT processors compared to Xalan. 
 
20 
多執行緒的 XSLT compiler 又比循序的 XSLT compiler 快 1.43 倍。這項 XSLT 處理技術可以加速許多
Web 應用程式處理 XSLT 轉換的效能，同時，也讓相關之應用程式在有限的運算資源下，滿足未來龐
大的 XML 處理需求。 
 
 
六、 參考文獻 
[1] libxml2 APIs, http://xmlsoft.org/index.html. 
[2] Xalan-Java, http://xml.apache.org/xalan-j/xsltc/index.html#compiler. 
[3] World Wide Web Consortium. XSL Transformations (XSLT). W3C Recommendation. 
(http://www.w3.org/TR/xslt) 
[4] World Wide Web Consortium. XML Path Language. W3C Recommendation. 
(http://www.w3.org/TR/xpath) 
[5] Anguel Novoselsky. The Oracle XSLT Virtual Machine. XTech 2005 Amsterdam, Netherlands, 24-27 
MAY 2005. 
[6] World Wide Web Consortium. Extensible Markup Language (XML) 1.0. W3C Recommendation. 
(http://www.w3.org/TR/1998/REC-xml-19980210) 
[7] Anguel Novoselsky and K. Karun. XSLTVM – an XSLT Virtual Machine. XML Europe 2000, Paris, 
France, June 12-16, 2000. 
[8] Oracle's Java XSLT processor is available from 
http://technet.oracle.com/tech/xml/parser_java2/index.html. 
[9] TransforMiix, The Mozilla Project offers its TransforMiiX processor at 
http://www.mozilla.org/projects/xslt. 
[10] Gregor/XSLT framework, http://www.ambrosoft.com/. 
[11] XSLT performance benchmarks: XSLTMark, http://www.datapower.com/xmldev/xsltmark.html. 
[12] MSXML, The Microsoft XML Parser is available at 
http://msdn.microsoft.com/xml/general/xmlparser.asp 
[13] The XPath 1.0 Recommendation, published by the World Wide Web consortium. The definitive 
specification of the XPath expression syntax used within an XSLT style sheet. 
[14] P. Briggs. Automatic parallelization. ACM SIGPLAN Notices, 31(4):11-15, 1996. 
[15] J. Derrick. Cost effective XML processing in the datacenter. In XML Europe 2004, Amsterdam, The 
Netherlands, Apr. 2004. 
22 
http://www-106.ibm.com/developerworks/xml/library/x-xslt/. 
[34] D. Jacobs. Rescuing XSLT from Niche Status. 
http://www.xfront.com/rescuing-xslt.html. 
[35] Intel XSLT accelerator. 
http://www.intel.com/cd/software/products/asmo-na/eng/335035.htm. 
 
Compiler Support for Effective
XSL Transformation
Ching-Mao Chen†, Fu-Shun Chu‡,and Peng-Sheng Chen∗§
Department of Computer Science and Information Engineering
National Chung Cheng University, Chia-Yi 621, Taiwan
SUMMARY
XML (Extensible Markup Language) is a markup language used to describe data or documents. The main
goal of XML is to facilitate the sharing of data across diverse information systems, especially via the
Internet. XSLT (XML Stylesheet Transformations) is a standard approach to describe how to transform
an XML stylesheet into another data format. The ever-increasing number of Web technologies being used
in our everyday lives often leverage XSLT to support data exchange among heterogeneous environments,
and the associated increasing burdens on XSLT processors has increased the demand for high-performance
XSLT processors. In this paper we present an XSLT compiler, named Zebu, that can transform an XSLT
stylesheet into the corresponding C program. The compiled program can be used to transform documents
without requiring XSLT stylesheets to be processed. The results from experimental testing using standard
∗Correspondence to: Department of Computer Science and Information Engineering
National Chung Cheng University, Chia-Yi 621, Taiwan
†E-mail: mash105@gmail.com
‡E-mail: p700603@yahoo.com.tw
§E-mail: pschen@cs.ccu.edu.tw
2 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
(1) An increasing number of Web technologies are being used in our everyday lives. These
technologies often leverage XSLT to support solutions in heterogeneous environments [5].
(2) The maturing of technologies of information integration is increasing the importance of the
performance and throughput of data exchange. A requirement to transform massive data set
is also becoming more and more frequent.
(3) Social networking is increasing in popularity, with individuals being grouped for specific events
and sharing various types of information. The performance of XSLT processors represents one of
the major bottlenecks in supporting the setting up of large-scale social networking and handling
the exchange of massive amounts of information [6].
(4) An application gateway decouples back-end applications and consumers to achieve the goals of
better maintainability and higher security [7, 8, 9]. XML can be flexibly used to describe the
rules that will be applied to application traffic. Message traffic can be easily managed by XSLT
and fast XSLT processors are crucial to handling increasing traffic volumes.
(5) The management of massive volumes of XML data is becoming increasingly important to the
database community [10, 11, 12]. Especially, how to efficiently search and transform massive
volumes of XML data is becoming a critical problem.
The expansion of the above applications will increase the importance of designing and building
high-performance XSLT processors. Two general implementation approaches are used for XSLT
processors. The first is an interpreter-based approach that transforms an XSLT stylesheet and executes
the corresponding operations at run-time. The drawback is that an XSLT stylesheet is parsed and
analyzed whenever an XSLT processor is executed, which requires considerable amounts of time and
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
4 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
XSLT 
stylesheet
XSLT
compiler
XML
HTML
PDF
Others ...
XML
C program
Native C
compiler
XSLT 
executable
XSLT 
executable
Figure 2. Execution flow of an XSLT compiler
to 1.36 times compared to the Xalan-XSLTC XSLT processor. This technique will also help to advance
the capabilities to process massive XML data files with limited resources, and thereby improve the
competitiveness of the industry.
1.1. Contributions
This paper makes the following contributions:
(1) Compilation algorithm: It presents a compilation algorithm that translates an XSLT stylesheet
into the corresponding ISO-compliant C code.
(2) Implementation: It presents the implementation and the corresponding data structures in detail.
(3) Experimental results: It presents results obtained in experimental testing using standard
benchmarks, which show that our XSLT compiler exhibits better overall performance than
conventional XSLT processors.
The remainder of this paper is organized as follows. Section 2 briefly describes the transformation
process of an XSLT processor and presents an example that illustrates the conceptual skeleton of the
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
6 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html" encoding="utf-8"/>
<xsl:template match="/">
<html>
<body>
<xsl:apply-templates/>      
</body>
</html>
</xsl:template>
<xsl:template match="Course">
<h3> <xsl:value-of select="Teacher"/> </h3>
<ul>
<li><xsl:value-of select="Title"/></li>
</ul>
</xsl:template>
</xsl:stylesheet>
Figure 3. Example of an XSLT stylesheet
tree, and the <xsl:value-of> elements take information from the XML Teacher and Title elements and
adds them to the result tree. Once the transformation is finished, the output in Figure 6 is displayed.
2.2. XSLT stylesheet and corresponding C code
When designing the compilation algorithm it is necessary to understand and observe what the target C
code could look like. Consider the XSLT stylesheet in Figure 3 and the behavior of XSLT processing.
We determined a conceptual skeleton of target C code that performs the same transformation operation
as an XSLT stylesheet. Figure 7 illustrates the skeleton of the target C code. Each gray box shows
the appropriate function that will be called to handle the corresponding operation, and each white box
represents a function body. Several important observations are explained as follows:
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
8 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
<html><body>
All courses
<h3> Tom </h3>
<ul><li> Computer Architecture </li></ul>
<h3> Jason </h3>
<ul><li> Programming Language </li></ul>
</body></html>
Figure 6. Transformation result
(1) The main function first reads the appropriate XML file and constructs the corresponding tree
structure, which is a critical data structure in this C code.
(2) According to XSLT transformation rules, we begin by pattern matching from the XML root node
and then search for an appropriate template to apply the transformation. If no matched template
is found, the built-in template will be executed. The bottom half of the main function behaves as
described above.
(3) The XSLT templates <xsl:template match=“/”> and <xsl:template match=“Course”> are viewed
and processed as C functions.
(4) Due to the input XML file being unpredictable, the C functions for handling the appropriate built-
in templates should be added to the target C code.
(5) The XSLT elements <xsl:apply-template> and <xsl:value-of> are represented as C functions.
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
10 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
Parser
IR tree
Target C code
Code generator
Front-end
Back-end
XSLT stylesheet
(source program)
Symbol-table 
manager
Error handler
Figure 8. Software architecture of the XSLT compiler Zebu
preserve the characteristics of XSLT processing, a tree structure is adopted for the IR format. The code-
generator pass traverses the IR and generates corresponding target C code. In our compiler, each XSLT
element is transformed into a corresponding C function or corresponding C statements. The entire
XSLT process relies on cooperation among these functions. The proposed transformation algorithms
are described below.
3.1. The <xsl:template> element
For each XSLT template element, a dedicated C function is generated in the target C code. In our
compiler the template functions are named as template1, template2, template3, . . ., templaten, where
the n value in templaten is decided by the compilation order of the template elements, with template0
is reserved for the built-in template rule. We traverse each node in the tree structure of the template
element in a deep-first visiting order. Each node is transformed into the corresponding C statements.
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
12 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
Stack
html
body
xsl:apply-templates
Stack
html
Stack
html
body
Stack
html
body
Stack
html
Stack
/* Code fragment in target C 
code */
template2() {
...
Output tag <html>   /*(a)*/
Output tag <body>   /*(b)*/
Handle <xsl:apply-template> 
element             /*(c)*/
Output tag </body>  /*(d)*/
Output tag </html>  /*(e)*/
... }
(a) (b) (c)
(d)(e)
Figure 10. Code generation and stack data structure
3.2. The <xsl:apply-templates> element
The <xsl:apply-templates> element makes the XSLT processor apply a template to its child nodes
or to the specialized nodes. A C function named match template is generated to handle this
element in the target C code. Generating the correct match template function requires an
understanding of all match attributes in all templates. Accordingly, the code generation of the
match template function is performed after all templates have been compiled. Figure 11 shows the
code fragments in the target C code after compiling all templates in Figure 3. The built-in template is
transformed into the corresponding C function named template0, and we internally use “ text ” as its
recorded match attribute. Next, the <xsl:template match=“Course”> and <xsl:template match=“/”>
elements are transformed into the corresponding C functions, template1 and template2, and the match
attributes “Course” and “/” are recorded. Finally, an array of strings (tlist) containing match-attribute
information is generated in the target C code. Figure 12 displays the code skeleton of the function
match template after compiling <xsl:apply-templates> in Figure 3. The match template
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
14 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
/*
* <xsl:apply-templates> is processed by the function
* match_template() that visits all child nodes of
* the current node to check for whether or not a template is matched.
* - cnode is a pointer that points to an XML tree node.
*/
char *tlist[] = {"__text__", "Course", "/"};
match_template(cnode) {
...
/* cnode points to the children of the current code. */
cnode = cnode->children;
while (cnode != NULL) {
...
for (i=0; i<=2; i++) {
...
if (cnode->name matches tlist[i]) {
switch(i) {
case 0: template0(); break;
case 1: template1(); break;
case 2: template2(); break;
}
}
}
if (no match)
match_template(cnode);
/* cnode points to the next sibling node of the current node. */
cnode = cnode->next;      
}
}
Figure 12. Code skeleton of the function match template
(2) Evaluating XPath expression: This reads a parsed XPath expression and returns an appropriate
set of nodes in an XML document.
(3) Value extraction: This extracts the correct values from the XPath-selected nodes.
3.4. XSLT elements for declaring variables and parameters
XSLT provides elements that can be used to define variables and parameters in a stylesheet. Consider
one of these elements, <xsl:variable>. The scope of an <xsl:variable> element is the element that
contains it; if its parent is <xsl:stylesheet>, the scope is global. These elements are handled by
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
16 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
/*
* This function implements the functionality of
* the <xsl:value-of> element.
* Variable cnode points to the XML tree node.
* Variable xpath-string is the corresponding string value of
* XPath description.
*/
xsl_valueof(cnode, xpath-string)
{
/* Initialization */
...
/* Parse XPath expression and store appropriate information */
xpath_info = XPath_parse(xpath-string);
/* (1) Identify the XPath node of interest.
(2) result_node_set points to the node */
result_node_set = XPath_evaluation(xpath_info, ...);
Output the correct value by using result_node_set;
/* Release the resources */
...
}
Figure 14. Pseudo code of <xsl:value-of> element
of the select attribute is parsed for obtaining the appropriate set of nodes. Then, we use a FOR-
LOOP construct to visit each node in the set. Finally, the transformations of the child nodes of the
<xsl:foreach> element are performed and generated C codes are placed in the loop body of the FOR-
LOOP construct.
3.6. Main and xsltprocessing functions
After traversing and compiling the tree structure of an XSLT stylesheet, we begin to generate the main
function in the target C code. We add the appropriate C statements to the main function for reading
input XML files and building the corresponding tree structure. Then, a call to the xsltprocessing
function is added to the main function for starting an XSLT transformation. The xsltprocessing
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
18 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
main()
{
...
Read XML file;
Construct the corresponding tree structure;
RootNode points to the root node of the XML tree;
...
/* Begin XSLT transformation */  
xsltprocessing(RootNode);
...
}
/* check whether user-defined templates match the root node */
xsltprocessing(cnode) {
...
if (cnode != NULL) {
for (i=0; i<=2; i++) {
if (cnode->name matches tlist[i]) {
switch(i) {
case 0: template0(); break;
case 1: template1(); break;
case 2: template2(); break;
}
}
}
/* If no match, the built-in template rule is applied. */
if (no match)
match_template(cnode);
}
}
chAr *tlist[] = {"__text__", "Course", "/"};
...
Figure 16. Pseudo code of the main and xsltprocessing functions
left-to-right visiting order. The adopted transformation policies vary with the characteristics of the
nodes, as described in detail in Sections 3.1, 3.3, 3.4, and 3.5. After traversing the XSLT tree structure,
we generate the function match template to handle the <xsl:apply-templates> element. Finally,
the main and xsltprocessing functions are correctly generated in the target C code.
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
20 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
Zebu (XSLT compiler)
ISO-compliant C code libxmllibxslt
XSLT stylesheet
Native C compiler
Executable codeXML stylesheet
(source)
Transformed content
(result)
Figure 17. Compilation and execution flow of the Zebu compiler
4.1. Implementation
Figure 17 illustrates the compilation and execution flow of the Zebu compiler. An XSLT stylesheet is
read by the Zebu compiler and compiled into the corresponding ISO-compliant C code. Our current
implementation leverages two open-source libraries, libxml2 [16, 17] and libxslt [18, 19], to parse the
XML stylesheet, construct the corresponding tree structure, and handle XPath expressions. These two
libraries were developed as part of the GNOME project [20] and implemented in the C programming
language. Due to their features of completeness and stabilization, they are selected to help the Zebu
compiler to manipulate the XML stylesheet. A native C compiler is used to compile the target C code,
and to correctly link the object code with libxml2 and libxslt libraries into an executable code. The
executable code can be executed to fetch an XML stylesheet and produce the transformed content, in
the same manner as an XSLT processor.
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
22 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
4.2. Evaluation environment
Table II lists the configuration of the experimental environment. The experiments were evaluated on
an Intel-Core-i7-based computer system with 12 GB of memory. The native C compiler GCC 4.3.4
was used with the -O3 option to compile target C codes that were transformed by the Zebu compiler.
The POSIX function clock gettime with parameter CLOCK PROCESS CPUTIME ID was adopted to
measure the execution time. Table III lists the benchmarks used to evaluate the performance. The fourth
and fifth columns in the table list the sizes of the input XML and XSLT stylesheets, respectively. These
benchmarks were selected from XSLTMark [21, 22], which contains comprehensive benchmarks for
evaluating the performance of XSLT.
The five XSLT processors used to evaluate the performance are described in Table IV. Each tested
benchmark was run 11 times on each XSLT processor, with the first run being discarded in order to
reduce the effects of disk I/O. An average time was then computed from the results of the remaining
ten executions for evaluation and comparison.
4.3. Experimental results
Table V lists the code sizes of the transformed C code, and Figure 18 and Table VI compares the
execution times among the evaluated XSLT processors. The results show that the execution time was
lowest for the Zebu compiler for all of the evaluated XSLT processors. Figure 19 and Table VII
present the speed-up values with Xalan selected as the comparison baseline. The speed-up for the
Zebu compiler has an average of about 1.36 times, whereas the benchmark xslbench2 exhibits only a
1.03-times speed-up. This low value is due to xslbench2 containing 8 templates and the tested input
XML stylesheet being very large, with 2699 nodes in the corresponding tree structure. The C code
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
24 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
Table III. Benchmark programs [22]
Benchmark Description Number of
templates
Size of XSLT
stylesheet (bytes)
Size of input XML
stylesheet (bytes)
axis Tests XPath selection along differ-
ent axes
2 1309 360
find Test breadth of XML structure 2 380 4259
game Produces a HTML table of the data 2 1111 2667
inventory Produces a HTML table of the data 2 811 1893
identity The identity transform 1 284 16047
avts Tests attribute-value template ex-
pansion
2 465 16047
dbtail Prints a table by traversing the
following-sibling axis
2 497 16047
creation Tests xsl:element and xsl:attribute 3 557 16047
functions Tests various number and string
functions
1 1218 16047
total Reports on sales data 1 806 1220
attests Tests node copying using named
attribute sets
3 852 1220
xslbench2 Test a very large XML file 8 1127 149524
encrypt Performs a Rot-13 operation on all
element names and text nodes
2 745 16047
dbonerow Selects a single row from a very
large table
2 1836 16047
trend Computes trends in the input data 1 643 1806
union Performs complex pattern matching 3 628 173
xpath Performs complex pattern matching 3 615 296
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
26 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
Table V. Code size of transformed C code
Benchmark Number of lines of C code
axis 559
find 383
game 510
inventory 584
identity 313
avts 397
dbtail 527
creation 426
functions 399
total 371
attests 483
xslbench2 1016
encrypt 412
dbonerow 488
trend 392
union 505
xpath 445
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
28 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
Table VII. Speed-ups for evaluated XSLT processors compared to Xalan
Benchmark Zebu Xslta Saxon Xalan XT
axis 1.4329 1.0402 1.0161 1.0000 1.0021
find 1.3711 1.0361 0.9921 1.0000 0.9989
game 1.4284 0.9944 1.0129 1.0000 0.9974
inventory 1.4232 1.0155 0.9987 1.0000 0.9957
identity 1.2031 1.0176 1.0030 1.0000 0.9746
avts 1.4467 1.0374 1.0071 1.0000 0.9998
dbtail 1.4202 1.0389 1.0109 1.0000 1.0007
creation 1.3941 1.0195 1.0050 1.0000 0.9601
functions 1.4834 1.0871 1.0539 1.0000 0.9983
total 1.4610 1.0374 0.9612 1.0000 1.0204
attsets 1.4339 1.0336 0.9994 1.0000 0.9897
xslbench2 1.0392 1.0083 0.9705 1.0000 0.9824
encrypt 1.1745 1.0297 1.0025 1.0000 0.9975
dbonerow 1.0889 1.0112 0.9812 1.0000 1.0012
trend 1.3980 0.9991 1.0013 1.0000 0.9670
union 1.4295 1.0382 1.0136 1.0000 0.9877
xpath 1.4813 1.0557 1.0422 1.0000 1.0368
average 1.3594 1.0294 1.0042 1.0000 0.9947
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
30 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN

	





	
	
	




	
	


	



	


     ! " " " " 



Figure 19. Comparison of speed-ups for evaluated XSLT processors compared to Xalan
Xalan-Java, written in Java, is one of the Apache XML projects. It consists of an interpretive
processor and an XSLT compiler. The interpretive processor generally operates with the XML parser,
Xerces-Java, and completely implements the standard of XSLT 1.0. It also provides Java interfaces for
easily performing XML transformations. The standard of XPath 1.0 is also supported, and appropriate
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
32 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
very similar to that used for our XSLT compiler. The major difference other than compilation algorithm
is that XSLTC generates C++ code whereas our compiler produces C code. In addition, the advantage
of our XSLT compiler is that a C compiler is much more common than a C++ compiler, especially for
embedded and specialized computing systems.
5.3. Hardware-based approach
XSLTVM [36, 37] is an XSLT virtual machine that was developed by Novoselsky and Karun. It has a
stack-based architecture and contains a dedicated low-level instruction set for XSLT processing. The
virtual machine is designed to be independent of the implementation technology, host hardware, and
host operating system, so it can be easily implemented on any platform. The virtual machine stack holds
variables, partial results, and appropriate run-time information, so the stack cell can contain different
data types. The XSLTVM instruction consists of an operator and one or two operands. An XSLTVM
instruction gets the operands from the stack, perform the operation, and replaces them with the result.
XVM (XML virtual machine) [38] is a hybrid sequential-query virtual machine for processing
XPath, XQuery, XQueryP, and XSLT. A compiler, XCompiler, is provided to compile XQuery,
XQueryP, and XSLT into the corresponding unified byte code, which is platform independent. Like
XSLTVM, XVM is a stack-based virtual machine where each instruction gets its operands from the
stack and pushes the result back into the stack. In addition to a sequential execution model, XVM is
capable of interacting with external query processors via the proprietary compiler technique, query-
pushdown. Based on XVM and XCompiler, an XSLT stylesheet can be compiled, saved in a file, and
efficiently reused on different platforms .
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
34 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
5. Kelly PM, Coddington PD, Wendelborn AL. Distributed, parallel web service orchestration using xslt. e-Science and Grid
Computing, International Conference on 2005; 0:312–319.
6. Derrick J. Cost effective XML processing in the datacenter. XML Europe 2004 2004; .
7. Chang TK, Hwang GH. To secure xml documents with the extension function of xslt. Softw. Pract. Exper. 2006; 36(5):539–
555.
8. lmamura T, Dillaway B, Simon E. XML encryption syntax and processing. Website December 2002; Online available at
http://www.w3.org/TR/xmlenc-core/.
9. Chandramouli R. Enterprise access policy enforcement for applications through hybrid models and xslt technologies. ICEC
’04: Proceedings of the 6th international conference on Electronic commerce, ACM: New York, NY, USA, 2004; 490–499.
10. Liu ZH, Novoselsky A. Efficient xslt processing in relational database system. VLDB ’06: Proceedings of the 32nd
international conference on Very large data bases, VLDB Endowment, 2006; 1106–1116.
11. Graefe G. Query evaluation techniques for large databases. ACM Comput. Surv. 1993; 25(2):73–169.
12. Fokoue A, Rose K, Sime´on J, Villard L. Compiling xslt 2.0 into xquery 1.0. WWW ’05: Proceedings of the 14th
international conference on World Wide Web, ACM: New York, NY, USA, 2005; 682–691.
13. Aho AV, Sethi R, Ullman JD. Compilers: Principles, Techniques, and Tools. Addison Wesley, 1986.
14. Muchnick S. Advanced Compiler Design and Implementation. Morgan Kaufmann, 1997.
15. Clark J, DeRose S. XML path language (xpath). W3C Recommendation November 1999; Online available at
http://www.w3.org/TR/xpath/.
16. Website. The XML C parser and toolkit of GNOME, libxml. http://xmlsoft.org 2010.
17. Fleck J. libxml tutorial. Website 2003; Online available at http://xmlsoft.org/tutorial/index.html.
18. Website. The XSLT C library for GNOME, libxslt. http://xmlsoft.org/XSLT 2010.
19. Fleck J. libxslt tutorial. Website 2001; Online available at http://xmlsoft.org/XSLT/tutorial/libxslttutorial.html.
20. Website. GNOME: The Free Software Desktop Project. http://www.gnome.org/ 2010.
21. DataPower. Benchmark tests, understanding the benchmark. Website 2000; Online available at
http://lists.w3.org/Archives/Public/w3c-ietf-xmldsig/2002JanMar/att-0102/XSLTMark-excerpts.txt.
22. Kuznetsov E, Dolph C. Xslt processor benchmarks. Website March 2001; Online available at
http://www.xml.com/pub/a/2001/03/28/xsltmark/index.html.
23. Intel. Intel XML Software Suite for Java* Environments, User’s Guide. Website 2008; Online available at
http://software.intel.com/file/1897.
Copyright c© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0–0
Prepared using cpeauth.cls
出席國際學術會議心得報告 
                                                             
計畫編號 NSC 97-2221-E-194-028-MY2 
計畫名稱 支援多核心處理器架構之 XSLT優化器 (第二年) 
出國人員姓名 
服務機關及職稱 
陳鵬升 
國立中正大學 資訊工程學系 助理教授 
會議時間地點 民國 99年 6月 14~16日 
會議名稱 
International Workshop on OpenMP, June 14-16, 2010, Tsukuba, Japan 
(IWOMP 2010) 
發表論文題目 無 
 
一、參加會議經過 
由於目前主要的研究議題與如何撰寫平行程式有關，而 OpenMP是目前被廣為使用，並
公認最容易使用來撰寫多執行緒多核心程式的方式之一，IWOMP 是每年 OpenMP 
community的聚會，主要發表相關 OpenMP的論文，並討論 OpenMP未來的發展方向，
希望藉由這次參加 IWOMP，能夠獲取國際間對於 OpenMP 相關研究的第一手資料，增
強國內在這部分研究的能量。 
 
 
二、與會心得 
本次與會獲得許多寶貴的知識與經驗，如下所述： 
y 本次大會的三場主要的演講為Mike Heroux (Sandia National Lab.)、Michael Wolfe 
(PGI)、Hans Boehm (HP)，其中 Heroux主要談及MPI與其他撰寫平行程式工具的結
合，由使用者的角度出發，談及如何撰寫高效能的平行程式；Michael Wolfe應算是
裡面最重量級的演講者，其在平行處理與高效能計算領域，發表非常多重要的論文，
他談到未來 accelerator將在高效能計算上佔有重要的角色，而如何讓 programmer能
輕易的撰寫利用 accelerator的平行程式更是一重要的議題，Dr Wolfe提出了自己的
看法與解決方案；最後一位 Dr. Boehm 談到關於 memory model 的問題，他建議
OpenMP應該支援 sequentially consistent (SC) atomics syntax，以利程式的除錯，他是
由非 OpenMP community人員的角色來建議，部分與會人員有不同的意見，我對於
這個議題仍不太能理解。 
 
y 本次大會也安排了一個下午的 tutorial，主題是介紹 OpenMP programming，由 Dr. 
Ruud van der Pas所主講，他本身任職於 Oracle，且是資深的軟體工程師，自己也出
版 OpenMP相關的書籍，雖然我之前已經對 OpenMP有一定的瞭解，但是，由他的
課程裡，仍然有所收穫。 
 
 
以下為本次會議會場的相關照片： 
 
 
 
 
 
 
 
 
 
97 年度專題研究計畫研究成果彙整表 
計畫主持人：陳鵬升 計畫編號：97-2221-E-194-028-MY2 
計畫名稱：支援多核心處理器架構之 XSLT 優化器 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 1 1 100%  專利 已獲得件數 0 1 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 1 1 100% 
人次 
 
期刊論文 0 2 100% 一篇已經投稿，另一篇正在撰寫。 
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 1 1 100%  專利 已獲得件數 0 1 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
