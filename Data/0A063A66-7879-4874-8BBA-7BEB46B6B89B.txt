 I 
 
摘 要 
近年來同儕網路獲得高度關切，並吸引了大量的使用者。利用同儕網路進行的即時多媒體應用亦
日漸普及，它成為一個在業界與學界都很有興趣的研究主題。本計畫為國科會整合計畫“高韌性同儕
網路及其在即時多媒體上之應用＂之子計畫。總計畫旨在針對異質性同儕網路提供多媒體串流，並且
在此異質性同儕網路上建構一個以服務為導向的平台，而本子計畫是針對在異質性同儕網路下提出有
效的搜尋及繞徑技術。JXTA 是在同儕網路機制下提供不同網路裝置溝通與分工的多種協定之集合，由
於 Java 跨平台的特性，它對於實現我們欲建構服務於異質性同儕網路之目標是相當可行的。JXTA 採
用 LC-DHT 為其資源發現機制，但此機制未提供關鍵字搜尋。然而關鍵字搜尋是同儕網路下搜尋各種資
源，包括檔案、節點和各式網路服務的重要功能。缺乏關鍵字搜尋的搜尋引擎，使用者所下的搜尋參
數必須包括檔案的全名，否則無法尋得檔案，這對使用者來講是非常不方便的。為了增進搜尋功能的
完整性，我們在 JXTA 上加入關鍵字搜尋的功能，我們採用分隔字元來切割檔名以取得其關鍵字。此外，
因為中文無法用分隔字元來切割檔名，我們使用查詢信息來取得它的關鍵字。加入關鍵字搜尋功能的
JXTA 搜尋引擎，經過模擬評估後，得到其在關鍵字發佈及搜尋的成本皆小於原先 JXTA 的搜尋引擎。
也就是說，此方法節省了頻寬的消耗。另外我們發現以 DHT 為基礎的同儕網路都有關鍵字分佈不均的
問題，此問題會造成索引分佈的不平均，使得各個節點的負載不平衡。為因應此問題，我們加入了一
個新功能，即在發佈關鍵字時，多做幾次雜湊處理，讓不同的節點對同一個關鍵字可以經由多次的雜
湊處理，以產生一個不同的索引，而不同的索引就會送到不同的節點儲存。藉此可讓各節點的負載平
均，並提升整體搜尋命中率。模擬評估結果顯示，僅額外增加少許的流量就可讓搜索命中率提升至百
分之九十九左右。最後，為了因應極多的索引量並且使關鍵字分佈更加均勻，我們加入了同餘定理的
想法，我們給予同儕網路的每一個節點一個 mod ID，即負載過重的節點會將之後的同一關鍵字儲存請
求導至其他相同同餘編號的節點。如此一來便不會出現負載過重的節點。藉由讓各節點的負載更加平
均，亦可以讓各節點被詢問次數更為平衡。我們使用基尼係數來評估所提出的負載平衡方法，基尼係
數為 0表示最平衡的情況，而 1為最不平衡情況。模擬評估結果顯示，我們的方法提升了搜尋命中率，
使其接近 100%。至於發佈負載，評估結果顯示其基尼係數由原本 KAD 方法的 0.93 降低至 0.23，而關
於被詢問負載，我們方法的基尼係數由原本 KAD 方法的 0.83 降低至 0.33。那就是說，藉由同儕網路
負載的平衡，可以使其搜尋更有效率。此外，我們已將所提之搜尋及負載方法整合至多媒體串流服務(子
計畫四目標)，使其可以快速在同儕網路找到所欲串流之多媒體檔案。 
關鍵詞: 檔案分享、JXTA、關鍵字搜尋、負載平衡、同儕網路。 
 III 
 
目錄 
摘 要 ...................................................................................................................................... I 
Abstract ................................................................................................................................ II 
目錄 ..................................................................................................................................... III 
報告內容 ............................................................................................................................... 1 
參考文獻 ............................................................................................................................... 9 
圖表 ..................................................................................................................................... 10 
國科會補助專題研究計畫成果報告自評表 ................................................................................. 17 
附件 .......................................................................................................................................... 18 
 
 2 
 
乙、 同儕網路負載平衡及搜尋命中率之改良 
 
結構化 P2P 網路是建構在 DHT 之上，因為 DHT 之設計方式會造成網路中 O(log N)的 peers 存在著不
平衡[10]。由於加了關鍵字搜尋機制，會使得 publish 負載更加不平衡，進而造成 request 負載亦非
常不平衡。因為所有的關鍵字都會被儲存在特定的 peer 上，如果有一個關鍵字是特別熱門的，便會造
成儲存此關鍵字之 peer 負載異常的重。也因為儲存了熱門的關鍵字，所以被詢問的頻率也會異常的頻
繁。此外，因為結構化 P2P 網路內的 peer 上下線非常頻繁，所以負載重的 peer 下線便會影響到熱門
的關鍵字無法被搜尋到，進而影響到搜尋命中率。 
現今有許多文獻著重在負載平衡的策略，不過改善效果卻是有限，或是要付出更多額外的代價。以
下提出幾個例子說明，例如在 KAD 同儕網路中[1]，KAD 限制一個 peer 可以儲存的關鍵字索引不能超
過 6000 筆，不過此方法雖然可以稍微的避免某些 peers 負載過重，但是會降低搜尋成功率。在[11]
中，作者採用多個雜湊函數(h0、h1、h2 …)來達到發布負載平衡。當一個 peer 的被詢問頻率超過每秒
800 個時，此 peer 會用使用 h1雜湊函數將身上的關鍵字索引複製到其他 peer 上，若此 peer 被詢問頻
率又超過每秒 800 個詢問時，此 peer 會用使用 h2雜湊函數將身上的關鍵字索引複製到其他 peer 上，
以此類推執行下去。這個方法可以改善被詢問負載，但是只有在超過每秒 800 個詢問頻率下才可以有
作用。因為是將關鍵字索引複製到其他 peer 上，所以會產生額外大量的網路流量，並且不會改善到發
布負載平衡。因此一個好的負載平衡機制，要能兼顧發佈負載平衡及被詢問負載平衡，並且只要付出
少量額外的代價，這些是改良負載平衡的關鍵課題。 
三、 研究方法及成果 
本子計畫主要是在 JXTA 下研發實用並且負載平衡的搜尋技術，並且探討如何與多媒體串流服務做
整合。我們期許可以在 JXTA 上提供中、英文的關鍵字搜尋，除了可以付出少許的代價達到好的發佈平
衡和被詢問負載平衡之外，還可以提高搜尋命中率。以下前面三部分說明研究方法與成果，第四部分
說明與其他子計畫之整合。這些方法都適用於其他 DHT-based 的結構化 P2P 網路。 
 
甲、 JXTA 關鍵字搜尋法(JKS: JXTA Keyword Search) [12] 
 
我們提出一個增加 JXTA 搜尋命中率的方法(JKS)，其主要可以分成 publish 以及 search  來討論。
在此之前先介紹一下JKS的網路架構，JKS中主要peers分兩種peers分別是Rendezvous Peers和Edge 
Peers。Edge Peer 可以執行 search 以及產生 search requests，Rendezvous Peer 則是會紀錄其他
Rendezvous Peer 的位址資訊並且傳遞 search requests，此外每一個 Edge Peer 必定會和一個
Rendezvous Peer 有聯繫， 
 
發佈(Publish): 
 檔案想要分享給其他 peer 就必須透過 publish 的動作，在 publish 的過程中，一個檔案名稱可以
產生數個關鍵字。而關鍵字分割的方法是以空格或者是特殊符號來判別，例如: ｀.＇, ｀ ,＇, ｀ :＇, 
｀-＇, ｀_＇, ｀*＇, ｀?＇等。圖(一)是關鍵字分割的演算法。在 JKS 中 advertisement 是用來描
述檔案，在 advertisement 中紀錄檔名、cid、檔案大小及檔案位址。圖(二)是一個 JKS 想要 publish
 4 
 
而言，將會有極大的負載。當 peer 負責的關鍵字索引越多，也會有越多其他 peer 來詢問，所以不只
是會有發佈負載不平衡的問題，也會有被詢問負載不平衡的問題。在這方面的研究有一些挑戰，如果
要把負載重的 peer 將一些負擔轉移至其他 peer，必須要考慮被搜尋時的便利性、轉移的成本，以及
搜尋的成本。 
在此我們提出一個重複雜湊處理的機制，即在發佈關鍵字前，多做幾次雜錯處理，讓不同的節點對
同一個關鍵字可以經由多次的雜錯處理，以產生一個不同的索引，而不同的索引就會被送到不同的節
點儲存。此機制可讓不同的節點處理同一個關鍵字所得的索引在同儕網路中不同的節點儲存。藉此可
以讓各節點的負載平均，並提升搜尋命中率。其方法如圖(四)所示，以下為其說明： 
 
發佈(Publish): 
 我們所提出的方法允許對單一的檔案發佈多個關鍵字，過程包含關鍵字分割、經由重複雜錯產生
個別關鍵字的索引(index)，以及依照索引找出應儲存此索引的節點及發佈索引至該節點等項目[14]。
此同儕網路亦會設定一個重複雜錯的上限次數 k，每次的重複雜錯處理不能超過此上限。 
 
發佈機制的步驟如下： 
1. 將檔案名稱拆成關鍵字組。 
2. 在處理每一個關鍵字前，先個別產生出一個隨機數字:r，此 r需小於等於 k。 
3. 每一個關鍵字進行 r次的重複雜錯處理，以產生該關鍵字的索引。 
4. 以此關鍵字的索引為目標對同儕網路發出查詢(lookup)信息。 
5. 當收到查詢信息的回應，本節點會將最接近索引目標的節點記錄在候選表(candidate list)中。 
6. 再從此候選表中選出最接近索引目標的節點，將所要發佈的索引送給此節點。  
7. 當目標節點收到發佈的索引，就將此索引儲存在其資料庫內。 
 
搜尋(search) 
 此服務讓使用者在同儕網路中能夠使用關鍵字搜尋。 
 
搜尋機制的步驟如下： 
1. 從查詢信息(query)中分割字串(使用關鍵字分割方式)。 
2. 每個關鍵字個別產生出 k個經由重複雜湊而得的索引。  
3. 將這 k個索引當作目標，對同儕網路發出查詢信息。 
4. 將查詢信息的回應記錄到候選表中。 
5. 從候選表中選出最接近索引目標的節點，並對其發出搜尋信息。 
6. 收到這些搜尋訊息的節點會查詢自身的資料庫，以找出符合的資料，並回傳給搜尋者。 
 
丙、 同儕網路之負載平衡策略之進一步改善(KAD-mod)[16] 
 
由於存在於同儕網路的資料量與日遽增，相對的關鍵字索引也產生更多。上一小節提到的負載平
衡問題也就更為嚴重，為了進一步改善負載的平衡，我們提出了以同餘定理(modulo-based)為基礎的
新策略。此方法可以簡單的找到要幫忙分擔負載的 peer，並且只有負載過重的節點才需要啟動此機制。 
 6 
 
結果數不需要太多。 
 我們提出的方法中，JKS 提供之中、英文關鍵字搜尋可以提高搜尋命中率，只需要關鍵字便可以找
出想要的檔案。JKS 也可以提供過濾器，避免找到過多不需要的檔案。在負載平衡策略中，負責熱門
關鍵字的 peer 可以將負擔轉移到其他 peer 上，所以可以降低被 request 的次數，進而降低網路流量，
如此一來便不會佔用過多的多媒體串流服務之頻寬。在負載平衡策略之進一步改善方面，其搜尋的過
程中是由比較靠近搜尋 peer 的 peer 開始搜尋，所以搜尋回應時間會比較短。 
 我們也提出一個可用在JXTA平台上的串流機制[17]，以整合我們提出的JKS搜尋方法，讓使用者可
以輸入關鍵字，可以在很短的時間內回傳可能的結果，使用者即可選取想要觀看的多媒體串流服務。
首先，我們切割影音串流資料並建立多棵群播樹來傳送這些串流資料。然後，我們結合一個前向糾錯
編碼演算法來回復遺失的資料。最後，我們整合拉式與推式方法，一旦資料遺失時，我們使用資料重
傳的方法，即以拉式的方法來取回遺失的資料。 
四、 討論與結論 
本節承上一節，以四部分分別討論之，最後再加以總結。 
 
甲、 JXTA 關鍵字搜尋法(JKS: JXTA Keyword Search) [12] 
 
我們經過模擬來與其他熱門的同儕網路比較，我們比較的對象有原始的 JXTA 及一樣擁有關鍵字搜尋
功能的 KAD。圖(八)是比較在搜尋過程中，回應結果完全吻合的個數比較。由圖(八)中可以得知我們
的方法(JKS)在搜尋英文檔案的情況，JKS 與 KAD 吻合個數是一樣的，都比 JXTA 好許多，其原因是 JXTA
並沒有提供關鍵字的搜尋。在比較搜尋中英文檔案的情況，JKS 吻合個數則比 KAD 多 81%，因為只有
JKS 擁有特有的中文關鍵字搜尋功能。此外，我們評估 publish 以及 search 過程中所需的網路頻寬。
圖(九)是比較此三種同儕網路所需的頻寬比較，JKS 的頻寬花費比 KAD 來的少 237%，其主要原因是因
為 JKS 是兩階式的網路架構，所以在 publish 及 search 的頻寬花費上都會比 KAD 來的少。 
 
乙、 同儕網路之負載平衡策略[15] 
 
在重複雜湊的方法下，雜湊次數越多的話，表示索引會被分散的越廣。雜湊次數會影響整個同儕網
路的 publish 負載平衡的狀況，進而影響搜尋命中率，以及網路流量。首先我們先利用標準差公式來
評估網路負載平衡。圖(十)表示在不同重複雜湊次數下標準差的表現。 表示標準差，其計算公式如
下: 
 
其中 n 表示 zone 的個數， 表示每一個 zone 所儲存的索引數， 表示平均每一個 zone 儲存的索引
數。由圖(十)中可以看出重複雜湊次數大於 6以後便沒有明顯的改善標準差。雖然越多的重複雜湊可
以提升搜尋命中率，亦可以降低標準差，但是相對的網路流量會增加。圖(十一)、圖(十二)分別表示
 8 
 
提升至 98%。 
我們也成功地將這套搜尋機制架構在 JXTA 平台上，這套搜尋機制並且可與子計畫四的多媒體串流
傳輸方法做整合。依據我們設計出的多媒體串流服務之搜尋機制，使用者可以輸入所欲觀賞影片之關
鍵字，即可以在很短的時間內從同儕網路中得到回傳結果。接著使用者可以從回傳結果中選取有此影
片的 peer，以進行多媒體串流。 
關於本子計畫研究成果，除可能的技術移轉及專利申請外，在學術論文發表方面，到目前為止，共
發表了四篇論文，包括[12][15][17][19]，其中 [15][17]是 IEEE 國際會議論文，而[16]已經投稿至
IEEE WCNC 2011。另外也正準備將這些會議論文改寫投稿至期刊。 
 10 
 
圖表 
 
圖 (一) : 關鍵字分割演算法。 
 
圖 (二) : JKS 檔案 publish 過程 
 12 
 
 
圖(五)：mod ID 產生過程示意圖。 
 
 
圖(六)：publish 重新導向示意圖。 
 
 
圖(七)：publish 步驟示意圖。 
 
 
 14 
 
 
圖(十一)：在不同重複雜湊次數下搜尋命中率比較。 
 
 
圖(十二)：在不同重複雜湊次數下額外增加的網路流量比較。 
 
 
圖(十三):在不同雜湊次數下之成本效益係數比較。 
 16 
 
 
圖(十七)：針對 publish 負載平衡，在不同同儕網路架構下基尼係數比較。 
 
圖(十八)：針對 request 負載平衡，在不同同儕網路架構下之基尼係數比較。 
 18 
 
附件 
已發表之學術論文(與計畫直接相關部分) 
[1] C. Y. Liu, K. C. Wang, Y. L. Hsieh, “Efficient Push-Pull Based P2P Multi-streaming Using 
Application Level Multicast,” in Proceedings of the 21’th IEEE International Symposium on Personal, 
Indoor and Mobile Radio Communications, September 2010. 
[2] B.W. Li, K.C. Wang, and Yi-Ling Hsieh, “A Hierarchical Social Network-based P2P SIP System for 
Mobile Environments,” in Proceedings of the 21th IEEE International Symposium on Personal, 
Indoor and Mobile Radio Communications, September 2010. 
[3] T. T. Wu, K. C. Wang. “An Efficient Load Balancing Scheme for Resilient Search in KAD Peer to 
Peer Networks,” in Proceedings of the Ninth IEEE Malaysia International Conference on 
Communications, pp. 759-764, March 2010. 
[4] W. C. He, K. C. Wang and I. L. Hsieh, “Dependable Peer to Peer Multi-Streaming Using DHT-based 
Application Level Multicast,” in Proceedings of the IASTED Wireless and Optical Communications, 
July 2009. 
[5] T. H. Chang, K. C. Wang and C. Y. Hsu, “Keyword Search for Enhancing JXTA Discovery Service 
in Peer to Peer Networks,” in Proceedings of the National Computer Symposium, November 2009. 
[6] C. Y. Hsu, K. C. Wang, “An Efficient Decentralized Load Balancing Scheme in KAD Peer-to-Peer 
Networks,” Submitted to IEEE WCNC 2011. 
 
  
(MDC). 
CoolStreaming [3]: There are three key modules in this 
system: 1) membership manager, which maintains a partial 
view of the overlay; 2) partnership manager, which establishes 
and maintains partnership with other peer nodes; 3) scheduler, 
which is responsible for the schedule of stream transmissions. 
This system is a mesh-based and receiver-driven design of a 
streaming overlay. Each node periodically exchanges the buffer 
map which records the data availability information of partner 
nodes. CoolStreaming uses the pull-based method to retrieve 
unavailable data from partners. 
mTreebone [5]: Its key idea is to identify a set of stable nodes 
to construct a tree-based backbone, called treebone, with most 
of the data being pushed over this backbone [5]. These stable 
nodes, together with others, are further organized through an 
auxiliary mesh overlay, which facilitates the treebone to 
accommodate node dynamics and fully exploit available 
bandwidth between overlay nodes [5]. 
Zhang et al. [6]: The authors pointed out that high overhead 
and large delay of the pull-based protocol can be easily 
overcome by their proposed protocol. They showed that the 
protocol can not only approach the nearly optimal throughput 
but also can reach far lower playback delay and much smaller 
overhead than the pull-based protocol. 
Gridmedia [7]: CoolStreaming is a kind of receiver-driven 
system. However, the delay of CoolStreamig is long. To 
improve this drawback, Gridmedia proposed a push-pull 
streaming method. In order to reduce the delay at nodes as well 
as to offer resilience to a high churn rate in the overlay, the 
nodes in Gridmedia are organized into an unstructured overlay. 
The pull-based method is same as that of CoolStreaming. The 
nodes first use the pull mode. When the partnership between 
nodes is stable, the delivery mode is changed to the push mode.  
 
III. DESIGN APPROACH: HYSTREAM 
The architecture of the proposed P2P streaming system, 
called HyStream, was built on top of the DHT and application 
level multicast. We used Pastry [9] as the DHT layer to 
implement the basic structure of our streaming system.  And the 
application level multicast is responsible to construct a 
multicast overlay network, like Scribe [10]. Our approach 
focuses on the streaming layer. The streaming layer is 
responsible to transfer streaming data. Traditionally, tree-based 
approaches use a push-based method, in which nodes transfer 
data to its children nodes. This approach has low start-up delay. 
However, there are two main problems in this method. (1) If the 
bandwidth of an interior node is low, children nodes may lose 
data. (2) When encountering an interior node failure, the 
children nodes can’t receive data until completing the recovery 
of the tree. Thus, we propose a hybrid method which integrates 
a mesh-pull method and a tree-push method to resolve the 
above two problems and still maintain the advantages of 
tree-based and mesh-based approaches. Our approach is 
composed of three parts: (1) Streaming data fragmentation and 
a forest built-up: we split streaming data and build a forest to 
transfer streaming data. (2) Data restoration: we integrate a 
forward error correction (FEC) algorithm to recover lost data. 
(3) Data retransmission: when encountering data loss we use a 
data retransmission method, which is a pull-based method, to 
retrieve lost data. We describe the details of these three parts, as 
follows. 
A. Streaming data fragmentation and a forest built-up 
Video data are first divided into frames, and each frame is 
assigned a sequence number to represent its playback order. We 
then split a frame into several stripes and transfer each stripe by 
using an individual multicast tree that is formed by 
participating nodes. To distribute the forwarding load among 
all participating nodes, all the nodes form interior-node-disjoint 
multicast trees [4]. We used Scrbie multicast trees to form a 
forest. We exploited the properties of Pastry to construct 
interior-node-disjoint trees. In our P2P network, each node has 
a nodeId, and each stripe has a stripeId. Each stripe’s stripeId 
starts with a different digit. The nodeIds of interior nodes share 
a prefix with stripeId. Figure 1 shows an example forest 
construction. Since nodeId of node A starts with 1, node A is an 
interior node in the tree for stripeId starting with 1. And node A 
is a leaf node in other trees. In the forest, one node is an interior 
node in one multicast tree, and is a leaf node in another 
multicast tree. 
B.  Data Restoration 
We use multiple trees to transfer stripes. Nodes may lose 
some stripes, so we use an FEC algorithm to recover a data 
frame. The forward error correction (FEC) algorithm is used for 
data recovery. The sender adds redundant data to the original 
data using an error correction code. The use of FEC(n, k) begins 
with a proper selection of parameters k and n (k < n). We split 
one frame into k packets. n is the number of encoded packets. In 
our approach, n is equal to the number of stripes. The source 
node will transfer n encoded packets to children nodes. Then 
even suffering from packet loss in some stripes, we still can 
recover the original data with at least k encoded packets. By this 
technique, the number of redundant packets are (n - k). The 
details of the decoder and encoder of FEC are described in [11]. 
Let xK  be the source data. The encoded data yK is generated by
xGy KK = . G is an n × k matrix with rank k. The matrix G is called 
a generator matrix [11]. yK  is encoded data by a linear 
combination of G and xK . Even only k components of yK  are 
successfully received at the receiver, we can still restore the 
source data by using the k components. To decode data, we 
have yGx KK ′′= −1  from xGy KK ′=′ , where xK is the source data 
and y′K  is a subset of k components of yK . Matrix G' is the rows 
from G corresponding to the components of y′K . The matrix G' 
is k × k and G' is invertible. We can decode the source data by 
multiplying 1−′G  and y′ .  
 
  
recover most of data with a small number of retransmission 
requests and low extra control overhead. 
B.  Comparison with CoolStreaming 
We compare the proposed HyStream with CoolStreaming in 
terms of delivery ratio and start-up delay. The simulation 
results of CoolStreaming were obtained from [3]. We first 
compare the delivery ratio between HyStream and 
CoolStreaming. We implemented a simulation environment 
according to [3]. We set the streaming rate to 500 Kbps. And 
the overlay size is 200 nodes. We set each node to change its 
status according to the ON/OFF period. The node actively 
participates the overlay during the ON period and leaves (or 
fails) during the OFF period. Both the ON and OFF periods are 
exponentially distributed with an average period T. In  
Figure 6, we found that the shorter ON/OFF period leads to a 
lower delivery ratio. We also observed that the delivery ratio of 
SplitStream is lower with a lower ON/OFF period because 
SplitStream is a push-based method. Our approach integrtaes 
data recovery and push-pull hybrid methods to increase the 
delivery ratio. The delivery ratio of HyStream is also higher 
than that of CoolStreaming. This is beacause CoolStreaming 
used a receiver-driven approach, and sometimes it has longer 
delays. 
We define start-up delay as the waiting time that a node 
receives enough data to start playing after it joins the overlay. 
We implemented 1000 nodes in the overlay and recorded the 
cumulative distribution function (CDF) of the start-up delay, as 
shown in  
Figure 7. Note that HyStream had the same start-up delay 
with SplitStream. We observed that 90th percentile nodes had 
the start-up delay of 15 seconds in HyStream. The 90th 
percentile nodes had the start-up delay of 50 seconds in 
CoolStreaming. That is, the proposed HyStream is 35 seconds 
shorter in the start-up delay of the 90th percentile nodes 
compared to CoolStreaming. That is, the proposed approach 
has a lower start-up delay, compared to CoolStreaming. 
 
V. CONCLUSION 
We have presented an efficient and resilient push-pull based 
P2P multi-streaming scheme, called HyStream. We fragment a 
stream and build multiple trees to transfer data and add an FEC 
data recovery mechanism to restore lost data. We have also 
used a pull-based method to retransmit the data that could not 
be recovered. Our approach has the advantages of both the 
tree-push and mesh-pull methods. Simulation results have 
shown that in average our approach has 11.7% improvement in 
delivery ratio against SplitStream under various node failure 
rates. The delivery ratio of the proposed HyStream is 2.2% 
higher than that of CoolStreaming in a peer churn environment. 
The start-up delay of 90th percentile nodes of HyStream is 35 
seconds shorter than that of CoolStreaming. However, our 
approach has 6% redundant packets overhead due to the use of 
FEC, compared to SplitStream and CoolStreaming. In addition, 
HyStream has no more than 0.5% extra control overhead 
compared to SplitStream and CoolStreaming, even in a high 
peer churn environment. 
 
VI. REFERENCES 
[1] B. Li and H. Yin, “Peer-to-peer live video streaming on the internet: 
issues, existing approaches, and challenges,” IEEE Communications 
Magazine, vol. 45, pp. 94-99, July 2007 
[2] A. Sentinelli, G. Marfia, M. Gerla, L. Kleinrock, and S. Tewari, “Will 
IPTV ride the peer-to-peer stream?” IEEE Communications Magazine, 
vol. 45, pp. 86-92, July 2007. 
[3] X. Zhang, J. Liu, B. Li, and Y.-S.P. Yum,” CoolStreaming/DONet: a 
data-driven overlay network for peer-to-peer live media streaming,” in 
Proc. IEEE INFOCOM, pp. 2102-2111, Mar. 2005. 
[4] M. Castro, P. Druschel, A.M. Kermarrec, A. Nandi, A. Rowstron, and A. 
Singh, “SplitStream: high-bandwidth content distribution in a cooperative 
environment,” in Proc. Nineteenth ACM Symposium on Operating 
Systems Principles, pp. 292-303, Oct. 2003. 
[5] F. Wang, Y. Xiong, and J. Liu, “mTreebone: A Hybrid Tree/Mesh 
Overlay for Application-Layer Live Video,” in Proc. 27th International 
Conference on Distributed Computing Systems, pp. 49-49, June 2007.  
[6] M. Zhang, Q. Zhang, L. Sun, and S. Yang, “Understanding the Power of 
Pull-Based Streaming Protocol: Can We Do Better?” IEEE Journal on 
Selected Areas in Communications, Vol. 25, No. 9, pp. 1678-1695, Dec. 
2007. 
[7] L. Zhao, J. G. Luo, M. Zhang, W.J. Fu, J. Luo, Y.F. Zhang, and S.Q. Yang, 
“Gridmedia: A practical peer-to-peer based live video streaming system,” 
in Proc. 7th Workshop on Multimedia Signal Processing, pp. 1-4, Nov. 
2005. 
[8] N. Magharei, R. Rejaie, “PRIME: peer-to-peer receiver-driven 
mesh-based streaming,” in Proc. 26th IEEE International Conference on 
Computer Communications, pp. 1415-1423, May 2007. 
[9] A. Rowstron and P. Druschel, “Pastry: scalable, distributed object 
location and routing for large-scale peer-to-peer systems,” in Proc. 
IFIP/ACM International Conference on Distributed Systems Platforms 
(Middleware), pp. 329–350, 2001. 
[10] M. Castro, P. Druschel, A.M. Kermarrec, and A. Rowstron., “Scribe: a 
large-scale and decentralized application level multicast infrastructure,” 
IEEE Journal on Selected Areas in Communications, vol. 20, pp. 
1489-1499, Oct. 2002. 
[11] L. Rizzo, “Effective erasure codes for reliable computer communication 
protocols,” ACM SIGCOMM, vol. 27, pp. 24-36, Apr. 1997. 
[12] “Freepastry,” [Online]. Available: http://freepastry.org/FreePastry/. 
[13] S. Birrer and F.E. Bustamante, “The feasibility of DHT-based streaming 
multicast,” in Proc. International Symposium on Modeling, Analysis, and 
Simulation of Computer and Telecommunication Systems, pp. 288-298, 
Mar. 2005. 
[14] S. Banerjee, S. Lee, B. Bhattacharjee, and A. Srinivassan, “Resilient 
multicast using overlays,” IEEE/ACM Transactions on Networking, vol. 
14, pp. 237-248, Apr. 2006. 
[15] W.L. Miller, R. M. Ollerton, A. Shum, and C.J. Warner, “Proactive 
FEC-based forwarding for the collaborative reliable multicast protocol,” 
in Proc. Information Systems for Enhanced Public Safety and Security, pp. 
269-273, May 2000. 
[16] C. Wu, B. Li, and S. Zhao, “Diagnosing Network-wide P2P Live 
Streaming Inefficiencies,” in Proc. IEEE INFOCOM, pp. 2731-2735, 
April 2009. 
 
  
 
Abstract—P2P SIP (peer to peer session initiation protocol) 
systems have emerged as a new trend in multimedia realm due to 
their abilities to overcome the shortcomings of conventional SIP 
systems. Most of P2P SIP systems were implemented using Chord, 
a Distributed Hash Table (DHT) based routing algorithm which 
can provide scalability and reliability. Previous studies on P2P 
SIP systems did not address node heterogeneity, location 
information and mobility issues all together. For node 
heterogeneity, nodes with different capabilities (processing power, 
storage and bandwidth) should be treated suitably. For location 
information, the signaling latency is correlated with the distance 
between end users. This will influence call setup latency greatly. 
As to mobility, the node churn property will involve additional 
messages to maintain a stable DHT-based network and increases 
call setup latency. To conquer these problems, we propose a 
hierarchical social network-based P2P SIP system. The social 
network property can increase routing efficiency when calling 
friends. In addition, the proposed hybrid (structured/ 
unstructured) overlay is more resilient to cope with node churn. 
Simulation results show that our approach can improve 32% call 
setup latency with non-buddies and reduce 63% maintenance cost 
in comparison with the conventional Chord-based approach. In 
addition, we improve lookup efficiency from O(logN) to O(1) when 
making calls with buddies, where N is the number of nodes in a 
DHT-based network. 
 
Index Terms—call setup latency, mobile environment, P2P SIP, 
social network. 
 
I. INTRODUCTION 
P2P networks can be classified into unstructured and 
structured ones. Unstructured P2P networks, such as Kazaa [3] 
and Gnutella [4], build a random graph and use flooding or 
random walks on that graph to discover data stored by overlay 
nodes. Broadcasting messages using by these systems will 
burden the network with unnecessary traffic. However, 
unstructured P2P networks are more resilient to cope with node 
churn (the continuous process of node arrival and departure) 
[23][24]. On the other hand, structured P2P networks use 
DHT-based algorithm such as Chord [5], CAN [6] and Pastry [7] 
 
1  The support by the National Science Council under Grants 
NSC96-2628-E-009-140-MY3 and NSC98-2219-E-009-008 is grateful 
acknowledged. 
to provide a lookup service in a distributed fashion. Nodes 
construct an overlay with a predicable way and adopt efficient 
routing instead of blind and unpredictable search by flooding. 
P2P SIP studies have emerged as a new trend in multimedia 
realm. The combination of SIP and P2P can overcome the 
shortcomings of conventional SIP systems. IETF P2P SIP 
Internet drafts define a Chord-based P2P SIP system [21][22]. 
A node in a P2P-SIP system acts as a conventional SIP-UA 
(SIP-user agent), a registrar as well as a proxy/redirect server. 
Traditional SIP lookup service has been replaced by P2P 
overlay lookup service. Therefore, a node in a P2P SIP system 
can perform all functions of traditional SIP-UA without a need 
of a centralized SIP server. P2P SIP systems benefit from 
scalability and reliability offered by P2P. However, P2P SIP 
overlay based on Chord, the resource lookup procedure takes 
O(logN) hops which is larger than traditional SIP’s lookup 
latency of O(1), where N is the number of nodes in the overlay 
[8]. Therefore, our design goal is to speed up the lookup 
procedure as close to that of a traditional SIP system as 
possible. 
Node heterogeneity is an important issue that should be 
considered. In a pure P2P network, all nodes are treated equally 
and there is no difference between nodes. However, in a real 
world, nodes have different capability, such as different 
processing power, storage and bandwidth. Furthermore, node 
availability also affects indirectly the availability of a P2P 
system [18]. For example, if a node has longer uptime and 
better fault tolerance in the system, other nodes can use its 
service much more to reduce the churn rate. Thus, nodes with 
greater resources and desirable features should be grouped as 
super nodes (SNs) while the rest of nodes are categorized as 
ordinary nodes (ONs). In addition, lookup routing in DHT 
networks may be through public Internet, which may introduce 
significant call setup latency [20]. The physical locations of 
nodes in a DHT overlay are unpredictable so that the routing 
path may not be optimal, which significantly increases the call 
setup latency. Thus, an efficient lookup mechanism has to be 
considered in DHT-based systems. Besides, node mobility is 
another critical issue that should be paid attention to. Node 
churn involves additional maintenance messages to ensure a 
stable DHT-based network, and it increases call setup latencies 
[11]. 
In this paper, we propose a hierarchical social network-based 
P2P-SIP system. In our system, nodes are categorized as an SN 
A Hierarchical Social Network-based P2P SIP 
System for Mobile Environments1 
Bo-Wei Li, Kuochen Wang, and Yi-Ling Hsieh
Department of Computer Science 
National Chiao Tung University 
Hsinchu 300, Taiwan 
kwang@cs.nctu.edu.tw 
 the SN of the buddy. If a buddy is an SN, it
itself. We assume that a node can get a buddy
user information, such as a buddy list and pr
managed by a centralized authentication serv
encrypted file within the overlay [9]. 
C. Super node (SN) selection 
When a node M wants to join the overlay, 
SN among contacts. The first choice is the o
connected. If the last contact is not availab
should be the one who includes the most num
M. For example, in TABLE II, the SN shoul
pair 140.113.90.88/Alice. By this rule, one can
number of contacts. 
D. Node startup, node registration and user re
Once a user enters his/her SIP 
alice@p2psip.com, a user identifier, Resou
calculated first by hashing the SIP URI. The
algorithm in Chord is SHA-1 [26], whi
consistent hashing results. Second, the user 
selection. If there are no contacts to select, c
will proceed. When there are no buddies
contacts initiation will fail. Then, node reg
executed. 
Node registration refers to a new node that j
and acts as an SN. The new node uses Re
Node-ID. Next, it uses SIP REGISTER a
Temporarily” messages to locate the closest su
responsible for accepting the joining node. 
routing fashion. However, in practice, our
overlay is much stable so that using recursiv
another good way to improve routing ef
illustrates a routing procedure in an iterative
The joining node with Node-ID 80 first sen
message to the bootstrap node, which has Nod
For a specific Resource-ID k in Chord, the
Node-ID is equal to or greater (mod the size o
than k is the responsible node for k. The boo
currently responsible for the joining node so 
Moved Temporarily” message, which inclu
about the node that might be responsible for th
this case, node A (step 2). Then, the joining 
procedure to send a REGISTER message to no
A is not responsible for that (steps 3-4). Fin
node, node B, is indicated, and it responds a “2
to the joining node, and then the node regist
(steps 5-6). Node B is also a location where 
for the joining node should be placed. On th
recursive routing, the bootstrap node and no
proxy servers to relay the REGISTER messag
finishing the node registration, the joining n
SN, and node startup is done. 
When a node gets an SN during the super 
will become an ON, and proceeds user r
registration refers to a node publishing its loc
(the mapping of Resource-ID and IP addre
nodes can locate it. There are two places w
information should be registered to. One is th
s contact will be 
 list. In practice, 
eferences, can be 
er or stored as an 
it has to select an 
ne who was last 
le, a super node 
ber of buddies of 
d be the IP name 
 build a minimal 
gistration 
URI, such as 
rce-ID, will be 
 default hashing 
ch can produce 
performs the SN 
ontacts initiation 
 in the overlay, 
istration will be 
oins the main net 
source-ID as its 
nd “302 Moved 
ccessor, which is 
It is an iterative 
 main net DHT 
e routing style is 
ficiency. Fig. 3 
 routing fashion. 
ds a REGISTER 
e-ID 44 (step 1). 
 first node with 
f the namespace) 
tstrap node is not 
it returns a “302 
des information 
e joining node, in 
node repeats this 
de A. Also, node 
ally, the correct 
00 OK message” 
ration is finished 
offline messages 
e other hand, in 
de A acts as SIP 
e to node B. After 
ode becomes an 
node selection, it 
egistration. User 
ation information 
ss) so that other 
here the location 
e node’s SN and 
the other is the node that is responsib
Fig. 4, a joining node first register
Node A then adds the joining node
responds “200 OK” message (steps 
relayed to node C, which is respon
(steps 3-5). Finally, node C puts the
resource table, and returns a “200 OK
routing process is the same as that in
recursive routing fashion, SNs act as
the REGISTER message. 
E. Session setup and user location 
When a node wishes to establish
must be located. This process is 
example, if Alice wishes to locate
Bob’s Resource-ID by hashing Bob
cases of user location. One case is th
buddies, Alice can refer to Bob’s c
address. Alice first sends a SIP MES
 
Fig. 3. A node proceeds to node registration
 
Fig. 4. A node proceeds to user registra
 
le for it in the main net. In 
s itself to its SN, node A. 
 to its sub node table, and 
1-2). Next, the message is 
sible for the joining node 
 location information to its 
” message to node A. The 
 the node registration. In a 
 SIP proxy servers to relay 
 a session, the target node 
called user location. For 
 Bob, she first calculates 
’s SIP URI. There are two 
at if Bob is one of Alice’s 
ontact to locate Bob’s IP 
SAGE or INVITE message 
 
 in iterative routing fashion. 
 
tion in a recursive routing 
  
TABLE I 
FEATURES COMPARISON BETWEEN DIFFERENT P2P SIP SYSTEMS. 
              Approach 
 
Feature 
SOSIMPLE 
[9] 
DChord 
[10] 
UP2P 
SIP 
[11] 
SP2P 
SIP 
(Propo
sed) 
Zero 
configuration 
Yes Yes Yes Yes 
Efficient lookup Yes Yes No Yes 
Interoperability Yes Yes Yes Yes 
Node 
heterogeneity 
No Yes No Yes 
Advanced 
services 
Yes Yes No Yes 
Churn handling No No Yes Yes 
buddies, where N is the number of nodes in a DHT-based 
network. As to mobile environments, the proposed hybrid 
(structured/unstructured) overlay is more resilient to cope with 
node churn. 
 
REFERENCES 
[1] J. Rosenberg, H. Schulzrinne, G. Camarillo, A. Johnston, J. Peterson, R. 
Sparks, M. Handley and E. Schooler, “SIP: session initiation protocol,” 
RFC3261, IETF, June 2002 
[2] “Skype Technologies,” [Online]. Available: http://www.skype.org/.  
[3] N. Leibowitz and M. Ripeanu and A. Wierzbicki, “Deconstructing the 
Kazaa network,” in Proc. of the 3rd IEEE Workshop on Internet 
Applications (WIAPP), pp. 112-120, June 2003. 
[4] M. Ripeanu, “Peer-to-peer architecture case study: Gnutella network,” in 
Proc. of the 1st IEEE International Conference on Peer-to-Peer 
Computing, pp. 99-100, August 2001. 
[5] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek and H. Balakrishnan, 
“Chord: A scalable peer-to-peer lookup service for internet applications,” 
in Proc. of the Conference on Applications, Technologies, Architectures, 
and Protocols for Computer Communications, pp. 149-160, August, 
2001. 
[6] S. Ratnasamy, M. Handley, R. Karp and S. Shenker, ”Application-level 
multicast using content-addressable networks,”  Lecture Notes in 
Computer Science, Vol. 2233, January 2001. 
[7] A.Rowstron and P.Druschel, “Pastry: scalable, distributed object location 
and routing for large-scale peer-to-peer systems,” in Proc. of 18th 
IFIP/ACM International Conference on Distributed Systems Platforms, 
pp. 329-350, November 2001. 
[8] K. Singh and H. Schulzrinne, “Peer-to-peer Internet telephony using SIP,” 
in Proc. of the International Workshop on Network and Operating 
Systems Support for Digital Audio and Video Tech, pp. 63-68, June 2005.  
[9] D. A. Bryan, B. B. Lowekamp and C. Jennings, “SOSIMPLE: A 
serverless, standards-based, P2P SIP communication system,” in Proc. of 
International Workshop on Advanced Architectures and Algorithms for 
Internet Delivery and Applications, pp. 42-49, June 2005.  
[10] H. Ma, B. Xu, H. Wan and C. Li, “A hierarchical P2P architecture for SIP 
communication,” in Proc. of International Conference on Next 
Generation Mobile Applications, Services and Technologies (NGMAST), 
pp. 130-135, September 2007. 
[11] C.-M. Cheng, S.-L. Tsao, and J.-C. Chou, “Unstructured peer-to-peer 
session initiation protocol for mobile environment,” in Proc. of the 18th 
Annual IEEE International Symposium on Personal, Indoor and Mobile 
Radio Communications (PIMRC), pp. 1-5, September 2007. 
[12] S. Rhea, D. Geels, T. Roscoe, and J. Kubiatowicz, “Handling churn in a 
DHT,” in Proc. of the Annual Conference on USENIX Annual Technical 
Conference, pp. 10-10, June 2004. 
[13] K. Singh, “Structured vs. unstructured P2P or why we chose DHT for 
P2P-SIP?” [Online]. Available: 
http://p2p-sip.blogspot.com/2006/06/structured-vs-unstructured-p2p-or-
why.html.  
[14] B. T. Loo, R. Huebsch, I. Stoica, and J. Hellerstein, "The case for a hybrid 
P2P search infrastructure," In Proc. of  International Workshop on 
Peer-To-Peer Systems (IPTPS), pp. 141-150,  February 2004.  
[15] “Overlay Weaver: An overlay construction toolkit,” [Online]. Available: 
http://overlayweaver.sourceforge.net/. 
[16] “Plurk,” [Online]. Available: http://www.plurk.com/. 
[17] R. Schollmeier,” A definition of peer-to-peer networking for the 
classification of peer-to-peer architectures and applications,” in Proc. of 
the 1st International Conference on Peer-to-Peer Computing (P2P), pp. 
101-102, August 2001.  
[18] L. Le and G-S Kuo, “Hierarchical and breathing peer-to-peer SIP system,” 
in Proc. of IEEE International Conference on Communications (ICC), pp. 
1887-1892, June 2007. 
[19] G. Kunzmann, “Recursive or iterative routing? hybrid!,” [Online]. 
Available: 
http://subs.emis.de/LNI/Proceedings/Proceedings61/GI-Proceedings.61-
27.pdf. 
[20] C. Zhang, J. Shi, L. Li, W. Lin, Y. Wang, L. Gu, Y. Ji and Z. Feng, 
“Signaling latency analysis of peer-to-peer SIP systems,” in Proc. of  the 
5th IEEE Conference on Consumer Communications and Networking 
(CCNC), pp. 505-509, January 2008. 
[21] C. Jennings, B. Lowekamp, E. Rescorla, S. Baset and H. Schulzrinne, 
“REsource LOcation And Discovery (RELOAD) base protocol,” [Online]. 
Available: http://tools.ietf.org/html/draft-ietf-p2psip-base-02, March 
2009. 
[22] M. Zangrilli and D. Bryan, “A Chord-based DHT for resource lookup in 
P2PSIP,” [Online]. Available: 
http://tools.ietf.org/html/draft-zangrilli-p2psip-dsip-dhtchord-00, 
February 2007. 
[23] Y. ZHu, X. Yang and Y. Hu, “Making search efficient on Gnutella-like 
P2P systems,” in Proc of the 19th IEEE Conference on Parallel and 
Distributed Processing Symposium, pp. 56a-56a, April 2005. 
[24] Y. Chawathe, S. Ratnasamy, L. Breslau, N. Lanham and S. Shenker, 
“Making Gnutella-like P2P systems scalable,” in Proc. of ACM 
Conference on Applications, Technologies, Architectures, and Protocols 
for Computer Communications, pp. 407-418, August 2003. 
[25] PlanetLab,” [Online]. Available: http://www.planet-lab.org/.  
[26] National Institute of Standards and Technology (NIST), “SHA- 1 
standard,” [Online]. Available: 
http://www.techheap.com/cryptography/hash/fip180-1.pdf. 
[27] D. Chopra, H. Schulzrinne, E. Marocco, and E. Ivov, “Peer-to-peer 
overlays for real-time communication: security issues and solutions,” 
IEEE Journal on Communications Surveys & Tutorials, Vol. 11, pp. 4-12, 
March 2009. 
 
TABLE II 
THE CONTACT TABLE FOR SPEEDING UP THE LOOKUP PROCEDURE. 
Buddy Contact 
Alice 140.113.90.88/Alice 
Bob 140.113.90.88/Alice 
Carl 140.113.90.88/Alice 
David 140.113.100.200/Fred 
Eric 140.113.100.200/Fred 
 
own indexes of published objects. They do not suffer from the 
above problem. 
C. Proposed KAD-N 
In this paper, to resolve the unbalanced load problem in 
structured P2P networks, we propose a KAD-N scheme that 
hashes the keyword of an object random times to produce a 
key for publishing the object. Other peers who want to publish 
the object with the same keyword will do the same. Different 
peers may hash different times to produce different keys, 
which all represent the same keyword. That is, our method 
will produce several different keys to represent the same 
keyword. These keys will be published to different peers, not 
to only one peer. And peers who receive these publishing 
messages will use these keys to build indexes. Our method 
can spread indexes more even in the network. Simulation 
results show that we can balance the loads of peers and also 
increase the search hit rate in case that some peers failed or 
left. The overhead of our method is increasing the network 
traffic slightly. 
II. PRELIMINARIES AND RELATED WORK 
First, we describe the principles of how to lookup, publish, 
and search objects in the KAD P2P network. After that, we 
discuss the original KAD load balancing mechanisms. 
A. Background of KAD 
KAD specifies the structure of a network and the exchange 
of information through peer lookups. Peers communicate 
among themselves in KAD using UDP [3]. A virtual overlay 
network is formed by participating peers. Each peer is 
identified by a KAD ID. The KAD ID not only serves as an 
identity, but is used to locate objects. When searching for 
some objects, a peer needs to know the target location and 
explores the network in several steps. Each step will find 
peers that are closer to the target. Figure 1 shows the steps of 
the lookup procedure. First, a searching peer sends messages 
to two closest possible peers. When the searching peer 
received responses, it obtains three closer possible peers. Then 
these new possible peers that are in the target keyspace will be 
stored to a list, called a candidate list. In this example, two 
peers are in the target keyspace. These two peers will be saved 
to the candidate list. In the last step, the searching peer sends a 
request for closer peers to the three closest peers again, but 
only two peers are available and reply with closer peers. The 
lookup procedure terminates when the lookup responses 
contain only peers that are either already present in the 
candidate list or farther away from the target than the other 
top three candidate peers [15]. At this point, the candidate list 
becomes stable. Like other DHT networks, KAD travels only 
O(logN) peers during the execution of the lookup procedure 
when there are N peers in the network. Therefore, the lookup 
procedure is very efficient. 
B. Load balancing in KAD 
KAD P2P networks do little to balance the load of each 
peer. They just limit the number of indexes handled in each 
peer to prevent them from overloading. A peer can only be 
responsible for maximum 60,000 indexes and can hold a 
maximum of 50,000 indexes of an individual keyword. Once 
reaching the limit, a peer would send an overload response to 
the publishing peer. After receiving the overload response, the 
publishing peer will publish this object to another peer. 
III. DESIGN APPROACH 
In general, each keyword of an object will be hashed one 
time to get a key to publish. To enhance the search hit rate, we 
propose a KAD-N method to publish keywords by multiple 
hashes in the KAD P2P network, where N is the maximum 
hash times. By hashing the key of a keyword, we can get the 
second key that can represent the same keyword. We can still 
hash the second key to get the third key. By hashing it random 
times, we get a final key to publish. Peers may produce 
different keys to represent the same keyword. And different 
keys are published to different peers. This multiple hashes 
method will publish a keyword from peers to different peers to 
balance their loads. 
 
 
Figure 1. Steps of the lookup procedure [16]. 
Figure 2 shows the procedure of how to generate a key to 
publish. If we want to publish object 1, we will use terms 1, 2, 
and 3 as keywords. We use term 1 as an example to describe 
our multiple hashes operation. First, we generate a random 
number r and 1 ≤ r ≤ N. Next, we hash term 1 to get key 1 
and then hash key 1 to get key 2, etc. After r times of hashing, 
we get key r, which is the final key to publish. Then we 
publish key r to the network. However, the multiple hashes 
method will increase the number of search messages. If we 
publish a keyword by hashing the key twice then we must 
query two keys in average to get the whole indexes of a 
keyword. Figure 3 shows the concept of multiple hashes for 
publishing and search. In this figure, keyword A may be 
published to peers 1 to N. If peer M want to search keyword A, 
it must send N search messages (queries) to these peers who 
may store indexes of keyword A. Then peer M will receive N 
search responses. It can then build the indexes of keyword A 
from these responses. Therefore, the proposed KAD-N 
760
distribution curve will be smoother if we hash the key more 
times. In other words, if we hash the key more times, 
publishing load will be more balanced. However, the number 
of search messages will increase after applying the proposed 
KAD-N method. In Figure 6, we found that the total network 
messages will increase linearly with more hash times. Total 
network messages were calculated based on [19], which was 
introduced in the simulation setup. They include search 
messages and publishing messages. 
Figure 7 plots the percentage of extra traffic under different 
hash times. The growth of the curve is linear just like that of 
Figure 6. As we mentioned in the simulation setup, number of 
search messages multiplied 0.019 KB is search traffic and 
number of publishing messages multiplied 0.18 KB is 
publishing traffic. We added search traffic to publishing 
traffic to get total network traffic. We calculated extra traffic 
percentage p according to the following equation: 
 
KADoriginaloftrafficnetworktotal
trafficsearchincreasedp =  
 
The extra traffic is very small because the number of search 
messages is much fewer than the number of publishing 
messages, and the traffic produced by a search message is 
much smaller than that by a publishing message. 
We used a standard deviation σ to show the divergence 
under different hash times. A standard deviation is a measure 
of the dispersion of a data set. A low standard deviation 
indicates that the data points tend to be very close to the mean, 
while a high standard deviation indicates that the data are 
“spread out” over a large range of values. We calculated the 
standard deviation using the number of indexes handled by 
each keyspace. In other words, the higher the value is, the 
more unbalanced publishing load of each keyspace is.σ is 
computed as follows: 
 
n
X
n
i
i∑
=
−
=
1
2)( μ
σ  
 
where n is the number of keyspaces (n = 256 in KAD); Xi is 
the number of indexes handled in the i
th keyspace and μis  the 
average number of indexes handled in each keyspace. 
From Figure 8, we observed that when hash times ≥ 7, σ will 
not decrease too much. That is, if we hash more than 7 times, 
the standard deviations are almost the same. In other words, 
when hash times ≥ 7, it will not help much on load balancing. 
We also simulated the hit rate variation under different hash 
times in case that some peers failed. We cannot retrieval 
indexes from failed peers. We call these indexes as missing 
indexes. Objects referenced by missing indexes would be 
unsearchable. Note that the hit rate is calculated by (1－ 
number of missing indexes) divided by number of total 
indexes. In Figure 9 , by hashing more times it increases the 
hit rates while peers failed. From [18], we know the number 
of peers vary according to a diurnal. And the minimal number 
of peers is about 78% of the maximum. So the percentage of 
failed peers in a day is about 27%. 
 
 
Figure 5. The index distribution of each keyspace under different hash times. 
 
Figure 6. The total number of network messages under different hash times. 
Figure 9 shows that the hit rate is close to 100% if we hash 
more than 5 times with 27% of peers failed. The proposed 
KAD-N will increase the search resilience in the situation of a 
large number of peers failed. Because more hash times do not 
always bring more efficiency, we define a cost-effectiveness 
factor k to determine the maximum hash times. 
 
σ×
=
  traffic network total
ratehitk  
 
To have a larger k, one has to increase the hit rate, and reduce 
the total network traffic and the standard deviation. From 
Figure 10, the k values under 6, 7 and 8 hash times are very 
close, and the k value under 7 hash times is the highest. That 
is, hashing 7 times is the optimal choice for the trace we 
simulated. 
 
 
762
[18] M. Steiner, T. En-Najjary, and E. W. Biersack, “A global view of 
KAD” in Proceedings of the 7th ACM SIGCOMM Conference on 
Internet Measurement, pp. 117-122, October 2007. 
[19] E. W. Biersack, “Everything you want to know on KAD,” June 2008. 
[Online]. Available: http://www.thlab.net/old/rescom2008/talks/E-
Biersack_KAD-tut.pdf. 
[20] “aMule Project,” [Online]. Available: http://www.amule.org/. 
[21] “WiredReach,” [Online]. Available: http://www.wiredreach.com/. 
[22] “Collanons Workplace,” [Online]. Available: 
http://www.collanos.com/. 
[23] X. L. Fu and Y. Xu, “A load balance algorithm for hybrid P2P network 
model,” in Proceedings of the ISECS International Colloquium on 
Computing, Communication, Control, and Management, pp.236-239, 
August 2008. 
 
764
2.2 IP Multicast and Application Level Multicast 
 
IP multicast is implemented in the IP layer and it has 
some drawbacks. Firstly, it needs routers to maintain the 
members of each multicast group. Secondly, its reliability 
and security cannot be guaranteed. Thirdly, IP multicast 
calls for changes at the infrastructural level instead of 
pure software, which slows down the pace of deployment, 
and it is extremely difficult to work efficiently by a large 
scale. 
 In contract to IP multicast, application level multicast 
uses only end hosts to construct an overlay network that 
offers multicast functionalities. Thus, two of the main 
disadvantages in IP multicast can be improved in 
application level multicast. Firstly, it does not need to 
maintain routers. Secondly, it is flexible for all interfaces 
of the network to be used in the application layer. 
Although application level multicast seems better than IP 
multicast, it still has some drawbacks. For example, the 
mapping of the overlay to the network topology may be 
suboptimal. Some improvements of application level 
multicast have been proposed to make the multicast 
schemes more efficient. 
 Scribe: The Scribe [4] relies on the underlying DHT 
substrate routing table for data forwarding and builds 
upon Pastry to support applications that demand a large 
number of multicast groups. Any multicast group may 
consist of a subset of all nodes in the Pastry network and 
is assigned a random ID (topicId). The multicast tree for a 
group is formed by those forwarding nodes that Pastry 
routes from each group member to the root, identified by 
topicId. Messages are then multicast from the root using 
reverse path forwarding. 
 
2.3 Streaming Algorithms 
 
Existing streaming work on P2P networks can be 
classified into categories according to how the content is 
disseminated: tree-based, mesh-based, and forest-based. 
Firstly, the tree-based algorithm is that the source and 
interior nodes will offer extensive bandwidth for leaves, 
but the leaves just receiving data. Due to this character, 
such an infrastructure may be not suitable for P2P 
streaming because only partial interior nodes carry large 
load of forwarding multicast messages. Secondly, the 
mesh-based algorithm is that each client maintains the 
partnership and periodically exchanges data availability 
information with a set of partners. CoolStream [5], a 
representation of mesh-based streaming, provides a buffer 
map to check what a peer is lacking and then request from 
other peers. Finally, the forest-based algorithm strips the 
content across a forest of interior-node-disjoint multicast 
trees on its overlay network. SplitStream, a representation 
of forest-based streaming, is first introduced as follows. 
 SplitStream: Considering tree-based protocols that 
are unsuitable to cooperative environments, in [2], the 
authors proposed to split the multicast content into k 
stripes and each stripe is multicast by a separate multicast 
tree, where an interior node in one tree is a leaf node in all 
others. By those disjoint trees, the forwarding load will be 
distributed among participating peers, and the system will 
be more robust to node failures by reducing the 
dependency on any node. In order to ensure the system 
being feasible, inbound bandwidth consumption is 
controlled; a peer joins at most as many stripes as its 
bandwidth capacity permits. The SplitStream 
implementation relies on Scribe [4], an application level 
group communication protocol built on Pastry [3], a DHT 
based, structured peer-to-peer routing protocol. 
 CoopNet: Like SplitStream, CoopNet [6] splits the 
multicast content across different trees for improving load 
sharing and resilience. In addition, CoopNet relies on a 
centralized organization protocol and adopts MDC 
(Multiple Description Coding) to provide redundancy in 
data. 
 AMSS: In AMSS (asynchronous multi-source 
streaming) [7], each of the source peers is responsible to 
transmit different packets to each of requesting leaf peers. 
Also, it attaches some parity packets in each stream, so as 
to improve tolerance of faulty source peers and packet 
loss. Additionally, contents peers must exchange control 
packets to each other to detect whether every other 
contents peer is active or dormant. 
 PRM: Probabilistic Resilient Multicast (PRM) [8] is 
a data recovery scheme which can be applied to any 
application layer multicast for improving data delivery 
ratios. It used two techniques to recover data. Firstly, it 
utilizes randomized forwarding; each overlay node 
chooses a certain amount of other overlay nodes at 
random, and forwards data to each of them with a low 
probability. Secondly, it adopts a reactive mechanism 
called triggered NAKs (negative acknowledgements) to 
handle data loss due to link errors and network 
congestion. 
 
 
3. Design Approach 
 
In [9], it shows that the delivery ratio decreases in highly 
transient P2P networks. We propose a multi-streaming 
scheme on the streaming layer, called ConStream, to 
resolve this problem. The basic architecture of our 
proposed approach is like SplitStream, striping the 
content across a forest of interior-node-disjoint multicast 
trees that distributes the forwarding load among all 
participating peers. In SplitStream, a content source 
forwards the content via different stripes in a proper 
sequence, and the content length is fixed. However, in our 
ConStream, we merge three stripes as a unit named 
multistripe and the total stripes in SplitStream can be 
viewed as several multi-stripes. The content in a multi-
stripe will be divided into small pieces, and they will be 
forwarded by three multicast trees concurrently. In 
addition, we insert parity packets [7] into streams for error 
recovery. 
 In Figure 1, it shows the difference between the 
traditional stripe and multi-stripe. We view the total 
contents as many fixed time segments, and stripes are 
2
construction is feasible, the sum of the desired indegrees 
of all nodes cannot exceed the sum of the forwarding 
capacities of all nodes. (2) Sufficient condition: for the 
above feasible condition to hold, each node’s forwarding 
capacity must exceed its desired indegree. 
 Following the above two conditions, the more 
forwarding capacity a client contributes, the more 
indegree a client can receive. These two conditions 
emphasize fairness and are used to improve performance. 
And since our proposed architecture is based on 
SplitStream [2], we can also make our model ideal by 
satisfying the feasible condition and sufficient condition. 
According to our improved architecture, clients can 
contribute more capacity to promote efficiency in a 
system and to easily satisfy the need of indegree, because 
their original load is lowered by decreasing the 
transmission rate. 
 In our ConStream, we merge three stripes as a multi-
stripe and take it as a unit to forward contents. But why 
not merge four, five, or six as a multi-stripe? When 
streams are delivered concurrently, a client will receive 
contents from different paths, and the delay time of these 
data will be more varied than that of just from one path. 
For example, in Figure 4, node F receives contents form 
streaming 1, streaming 2, and streaming 3 concurrently, 
but the hops of stream paths from the source to node F are 
4, 3, and 2, respectively. This situation will result in 
unsteady quality of media contents played in real time. To 
reduce such a jitter problem, we merge only three stripes 
and we also base on the slowest stream to start the real 
time multimedia playing during multi-stripe delivering. 
However, in this way, it will cause the client buffer being 
occupied by the data from the other two streams during 
waiting for the slowest stream. To remedy this, we 
increase clients’ buffers to avoid the packet loss problem. 
 
 
4. Simulation Results and Discussion 
 
We used FreePastry (version 2.0_03) [10] to realize the 
DHT (Pastry), application layer multicast (Scribe), and 
streaming (SplitStream). Then we implemented our 
proposed ConStream scheme under this configuration. In 
addition, we implemented Scribe-PRM, which we are 
going to compare with, by applying PRM to Scribe to 
significantly augment the data delivery ratio of Scribe. 
 
4.1 Simulation Scenarios 
 
Our environment was built on a Pastry overlay with 1000 
nodes and a forest structure with all overlay nodes was 
built as well. The delivery ratio is defined as the ratio of 
packets a client received to total delivered packets by the 
source. Repair time is determined primarily by 
SplitStream’s failure detection period, which triggers a 
tree repair when no heartbeats or data packets have been 
received for 30 seconds [2]. Besides, the randomized 
forwarding probability p in Scribe-PRM is chosen to be 
0.05 [8]. We will measure the delivery ratio under 
transient conditions, and the parameters for the degree of 
transiency include mean time to failure (MTTF) [9] and 
node failure rate [8]. We assume that the delivery ratio of 
each peer is 100% under non-transient environments. On 
the other hand, we measure the absolute delay of 
sequential packets on a certain client to examine delay 
jitter. The absolute delay is defined as the elapsed time of 
a packet from source to destination. In addition, the 
environment we used to measure the absolute delay was 
established with non-transient condition because the 
transient condition might cause more unstable factors in 
the measurement. 
 
4.2 Simulation Results 
 
In Figure 5, we examine the variation of delivery radios 
under the node failure rate between 1% and 30% (which 
implies 10 to 300 simultaneous failures in the overlay 
with 1000 nodes) with a fixed MTTF of 120 seconds. The 
result shows that the descending rates of the delivery ratio 
with the increase of the node failure rate for ConStream 
and SplitStream are similar, but Scribe-PRM has a lower 
descending rate. Our ConStream performs better than 
Scribe-PRM under the node failure rate less than 20%. 
And in reality, 20% of the node failure rate is too high in 
today’s Internet. 
 
 
Figure 5. Delivery ratios with various node failure rates 
under a fixed MTTF (120 seconds) 
 
 Assuming that the actual internet environment of 
node failure rate is 5% (which is still high in today’s 
Internet) [8], we examined the delivery ratio under 
different MTTFs. From simulation results in Figure 6, 
ConStream has higher delivery ratio than SplitStream and 
Scribe-PRM under different MTTFs. Additionally, we 
found that the curve of ConStream demostrates more 
steady trend than the other two with respect to different 
MTTFs. Note that the difference of delivery ratios 
between ConStream and Scribe-PRM (or SplitStream) 
increases as MTTF decreases. For example, when MTTF 
is between 180 and 60 seconds, the variance of delivery 
ratios for ConStream is about 0.02, while the variances 
for Scribe-PRM and SplitStream are about 0.05 and 0.06, 
respectively. 
4
  
 
 
Abstract—JXTA (Juxtapose) is emerging as the next 
generation P2P (peer to peer) platform and has been 
adopted by many applications, such as instant messaging 
systems, file sharing systems, and real-time collaboration 
platforms, etc. However, JXTA is lack of keyword search. 
Without the support of keyword search, the query must 
contain the exact full name of a desired resource. It is 
inconvenient for users in this aspect. In this paper, we 
propose a mechanism called JXTA Keyword Search (JKS) 
with the support of Chinese Keyword Partition (CKP). JKS 
has two objectives. First, it is providing keyword search 
upon JXTA. New publishing and discovery schemes are 
proposed for keyword search. Second, it is designing a 
Chinese Keyword Partition method to enhance the number 
of exact matches. Experimental results, based on real data 
obtained from some notable portal sites, show that the 
number of exact matches of the proposed JKS is 
comparable to that of KAD with English queries. 
Furthermore, JKS is 237% less than KAD in terms of 
bandwidth cost with English queries. The proposed JKS 
performs much better than KAD with mixed queries 
(English + Chinese). The research results are applicable 
for P2P applications (e.g. file sharing, multimedia 
streaming sharing, internet service discovery, etc.) built on 
JXTA. 
 
Keywords — Discovery service, JXTA, keyword search, peer to 
peer network. 
1.  INTRODUCTION 
XTA is a set of protocols which provide different 
network devices to communicate and collaborate in 
a P2P manner. JXTA is a common framework 
provided for P2P application development. There are 
several advantages of JXTA. (1) It accepts 
heterogeneous devices like PCs and mobile devices 
[2], [3]. (2) There is a J2ME version for mobile 
devices to build applications to access JXTA 
networks [4]. (3) It provides firewall routing 
 
1
 This work was supported by the National Science Council under Grants 
NSC96-2628-E-009-140-MY3 and NSC97-3114-E-009-001. 
capabilities [2]. It is used by many projects to 
establish their applications [5], [6], [7]. It is emerging 
as a next-generation P2P platform [8].  
There are two types of P2P overlay networks: 
structured and unstructured [9]. Most structured P2P 
networks are based on distributed hash table (DHT) 
technology. The advantage of DHT is its 
cost-effectiveness on query routing. Given a key, it 
guarantees to find an object within bounded cost. But 
it is useful only when the user has the exact file name. 
Most of the time, the user may only know partial 
information [10]. Thus, augmenting DHT with a 
keyword-based search capability is a valuable 
extension [11].  
JXTA uses loosely-consistent DHT (LC-DHT) as 
the underlying query routing mechanism. The 
operation is like DHT which stores a file index in a 
selected peer according to some kind of hash values. 
However, it is also lack of keyword search. There are 
two objectives for this research. The first objective is 
designing the keyword search function upon JXTA. 
The second objective is designing a Chinese 
Keyword Partition (CKP) method to enhance the 
number of exact matches. 
The rest of this paper is organized as follows. The 
preliminary knowledge of JXTA is presented in 
Section 2. Section 3 discusses related work. Section 4 
depicts design approach. Experimental results and 
discussion are shown in Section 5. Section 6 gives 
concluding remarks. 
2.  PRELIMINARIES 
2.1 Introduction of JXTA [5] 
JXTA was started by Sun Microsystems in 2001. 
Network devices can join the JXTA network by 
applications they run if it conforms to the JXTA set 
of protocols and could parse XML. An advertisement 
Keyword Search for Enhancing JXTA Discovery 
Service in Peer to Peer Networks 1 
Tsung-Hsuan Chang                    Kuochen Wang          Chung-Yuan Hsu 
Department of Computer Science       Department of Computer Science    Department of Computer Science 
National Chiao Tung University         National Chiao Tung University       National Chiao Tung University 
Hsinchu 300, Taiwan                          Hsinchu 300, Taiwan                        Hsinchu 300, Taiwan 
sam0408.cs95g@nctu.edu.tw             kwang@cs.nctu.edu.tw                     theone0615@gmail.com 
J 
  
 
 
entry to a different rendezvous peer and then the 
received peer stores it. 
Discovery 
Discovery service helps users to find out who owns 
files they are looking for. JXTA discovery service 
allows user input one set <Field, Value> (e.g. <name, 
“A Whole World”>) and finds out advertisements 
which contain it. Since an RPV is not always 
consistent, it is possible to route a query to an 
incorrect rendezvous peer. JXTA designed a 
limited-range walker algorithm to cope with it. In 
this case, the query walks along rendezvous peers in 
both directions of the RPV. The walker is stopped 
when a result is found, the end of RPV is reached, or 
a defined hop count is run out [13]. 
In an edge peer, the steps of discovery are listed 
below: 
(1) Create a query message that contains user input, 
and then send the query message to a connected 
rendezvous peer. 
(2) In a rendezvous peer: search its local   
advertisement database. 
(2a) Find results: return found advertisements to 
the query peer. 
(2b) No result: go to step 3. 
(3) In a rendezvous peer: search its index entry 
database. 
(3a) Find results: forward the query to the peers 
which have published the index entry. The 
owner peer then returns the desired 
advertisement to the query requester. 
(3b) No result: if the rendezvous peer is the 
responsible peer go to step 5; otherwise, go to 
step 4. 
(4) Forward the query to a responsible rendezvous  
peer. The receiving peer will start from step 2.  
(5) Start the walker algorithm (described above). 
The JXTA publish and discovery scenario is 
illustrated in Fig. 3. The number nearby an arrow line 
is corresponding to the step described above. 
3.  RELATED WORK 
3.1 JXSE-CMS [15] 
JXSE-CMS (content manager service) provides 
file sharing and retrieving services on JXTA. It also 
provides metadata search, but this function can’t be 
used in the remote search because an index is found 
only when a query is routed to the rendezvous peer 
which contains the index. JXSE-CMS define its own 
content advertisement which could contain content id 
(cid), length, description, name and etc. The cid field 
contains the unique 128-bit MD5 checksum of the 
file. The index of an advertisement is published by 
the underlying JXTA functions.  
 
Fig. 3. JXTA publish and discovery scheme. 
 
3.2 Rich metadata searches [16] 
In Fig. 4, the metadata search layer is implemented 
based on the existing CMS. The abundant metadata is 
added into an advertisement so that much more 
searchable attributes could be supported in a query 
expression. The query could include author, 
publisher, etc. But this mechanism can’t work in a 
recent JXTA version in the internet because the 
resource is stored in a selected peer according to 
some kind of a hash value. The metadata search only 
works in a local network. 
 
 
Fig. 4. Metadata architecture. 
 
GUI layer 
Metadata search layer 
Content manager service 
JXTA 
Physical network 
3a 
Discovery 3a 
Ri  Rendezvous peer 
Ei  Edge peer 
4 
3 
2 4 
3 
2 1 
4 
3 
2 1 
Index 
Store 
E1 
R1 
R2 
R4 
R3 
E2 
Publish 
  
 
 
Table 2. Qualitative comparison of existing approaches. 
 
 JXSE-CMS 
[15] 
Rich [16] KAD [17] JKS (Proposed) 
P2P network JXTA JXTA Kademlia JXTA 
Search capability Metadata Metadata Keyword + 
Attribute 
Keyword + Attribute 
Query key Content id or exact file name1 Keyword + Attribute 
Special feature N/A N/A N/A Chinese Keyword 
Partition (CKP) 
Number of exact matches Low Low Medium High 
Bandwidth cost Low Low High Medium 
Storage cost Low Low Low High 
 
implementation of JXTA is JXSE 2.5. JKS is based 
on JXSE 2.5. 
4.1 Keyword search 
The solution of how to add keyword search 
functionality upon JXTA is described in two parts: 
publish and discovery. 
Publish 
The publish scheme allows to publish several 
keywords for a single file. It involves adding 
keyword partition, a new advertisement, and 
modifying the publishing behavior of each 
rendezvous peer. The keyword partition algorithm 
will be described in Section 4.2. The publish scheme 
uses the content advertisement extended from 
JXSE-CMS to describe files, which is detailed as 
follows. 
To let users search files by file attributes (e.g. 
author), the related pairs can added into 
advertisements, (e.g. <Author> David). These 
attributes are not index entries but are used when 
determining whether a query and an advertisement 
match. The index entries are extracted from “name” 
and “cid” fields of the content advertisement. Then 
the entries are sent to the connected rendezvous peer. 
When the rendezvous peer receives entries, it stores 
the entries with field “cid” into the index entry 
database. If the entry field is “name,” the keywords 
are extracted by the keyword partition algorithm. 
These keywords are added into entries and also store 
into the index entry database with field “keyword.” 
Then the entry with field “name” is discarded. 
In the original JXTA source code, the rendezvous 
peer distributes each entry to other rendezvous peers 
to store. The 2-tier hierarchical architecture allows to 
further decrease network traffic and storage cost. If 
there are multiple same entries, only one entry is sent. 
Besides, the sources of entries are all changed to the 
rendezvous peer. During the discovery phase, the 
query would be routed to the rendezvous peer and 
then be forwarded to the real publisher. 
The steps of file publishing are listed below: 
(1) Create an advertisement and save it in a local 
advertisement database. 
(2) Extract index entries from the local 
advertisement database and pack these entries into 
an index message.  
(3) Send the index message to the connected 
rendezvous peer. 
(4) In the rendezvous peer: retrieve entries from the 
index message and store them into the index entry 
database. If an entry field is “name,” it is not stored. 
Keywords are obtained by ripping file name, and 
keyword pairs are stored into the index entry 
database. 
In the rendezvous peer: for each entry of the index 
message, remove duplicated entries and change the 
source to the rendezvous peer. Then use the routing 
mechanism to send each entry to a different 
rendezvous peer and store it.Fig. 6 shows the 
publishing scenario and the number nearby each 
arrow line is corresponding to the step described 
above. 
  
 
 
from returned results, the cid of the file is used for 
searching the peers who have the desired file. This 
process is like the KAD source key search. The 
discovery scheme is illustrated in Fig. 7. The number 
nearby an arrow line is corresponding to the step 
described above. 
4.2 Chinese keyword partition (CKP) 
The aim of CKP is to let files with Chinese names 
increase their possibilities of being searched out. In 
other words, increase the number of exact matching 
results for a query containing Chinese keywords. The 
character characteristic of Chinese sentences makes 
it difficult to be partitioned by the keyword partition 
algorithm of KAD because it does not have spaces 
between each character. Users who publish files need 
to manually add some special delimiters between 
Chinese characters. But some users may not know 
how to separate or are not diligent to change all files’ 
names. It results in only a subset of files with Chinese 
names being searched out if a user uses a complete 
file name to query. 
CKP provides a method to automatically 
distinguish Chinese keywords from file names. CKP 
involves a Chinese keyword list (CKL) and a 
keyword partition algorithm. Each rendezvous peer 
needs to maintain a CKL. The list contains records in 
form of <Keyword, Frequency>. The Keyword is 
Chinese. When a rendezvous peer receives a query 
from other peers, it gets a keyword set from the query 
by using the CKP algorithm. For each keyword in the 
keyword set, a rendezvous peer checks whether the 
keyword is contained in the CKL. If there is no 
record for the keyword, it adds a record <keyword, 
1> into the CKL. Otherwise, it adds 1 to Frequency 
of the old record. 
The CKL needs to be maintained to control the use 
of storage. When the number of records in the CKL 
exceeds 2,000, all records with frequency less than 3 
are removed. When the total frequencies of all 
records exceed 100,000, the frequencies of all 
records are divided by 2. If the original frequency is 1, 
the record is deleted. If the number of records in the 
CKL is less than 200, a peer uses its RPV to ask for 
records from other rendezvous peers. Each 
transmission is limited to 200 records selected from 
the top of the CKL. A peer would continually ask for 
records until the number of records exceeds 200. 
An array TK (Top Keywords) contains 200 
keywords with the most frequencies in the CKL. It is 
updated once per hour and after asking for record 
transmission from one of rendezvous peers. The 
proposed keyword partition algorithm, the CKP 
algorithm, is presented in Fig. 8. 
 
 
Fig. 8. Chinese keyword partition (CKP) algorithm. 
 
From the CKP algorithm, if the file name contains 
any keyword of TK, the keyword is retrieved and 
added into the keyword set. The overhead of CKP 
can be examined from three aspects: network traffic, 
storage cost and CPU load. 
Network traffic 
It is produced by record transmissions among 
rendezvous peers. It only occurs when the number of 
records in the CKL is less than 200. If the number of 
records exceeds 200, it seldom goes down to the 
number less than 200 again because the list keeps 
growing while queries keep coming. If there are 
enough queries in the network, the demand for 
Chinese Keyword Partition (CKP) 
Algorithm: 
INPUT file_name 
OUTPUT R_Keyword_Set 
Key_Set = Split file_name by special characters  
{space, ‘.’, ‘,’, ‘:’, ‘-’, ‘_’, ‘*’, ‘?’, etc.} 
For each Keyword in Key_Set 
Split Keyword if it consists of Chinese and  
English and then add results into 
Keyword_Set 
For each Keyword in Keyword_Set 
IF Keyword is not Chinese THEN          
IF Keyword.length > 2 THEN          
Add Keyword into R_Keyword_Set 
ENDIF 
ELSE                    //Keyword is Chinese 
Add Keyword into R_Keyword_Set 
FOR i = 1 to 200 
IF Keyword contains TK[i] THEN 
              Add TK[i] into R_Keyword_Set  
ENDIF 
ENDIF  
return R_Keyword_Set 
 
  
 
 
duplicate results were removed. Fig. 10 shows 
simulation results using two kinds of data (English 
and mixed: Chinese +  English). JXTA is zero in both 
data because it needs a query that exactly matches to 
the file name. 
For the number of exact matches, the proposed 
JKS is 1% less than KAD when data is English and 
81% more than KAD when data is mixed. It is 
because JKS publishes more keywords according to 
most popular query keywords (TK). Besides, if a file 
name contains a string with a mix of Chinese, 
English or number, the string is partitioned and more 
keywords are published. The growth of published 
references increases with the number of exact 
matches.  
 
 
Fig. 10. Number of exact matches (no duplicate) 
Bandwidth cost 
In the second experiment, it aims to show the 
network traffic produced by the keyword search. The 
bandwidth cost consists of publish cost and discovery 
cost. Since the number of publish messages is ten 
times bigger than the number of discovery messages 
[26], [27], the bandwidth cost is computed as 
follows: 
   Bandwidth cost = Publish cost *10 + Discovery 
cost  (1)  
Fig. 11 shows the publish cost using two kinds of 
data (English and mixed). JXTA is 2 in both data 
because it publishes one index entry for each file and 
each index entry is transmitted twice. One is from an 
edge peer to a connected rendezvous peer; the other 
is transmitted to the responsible peer.  
For the publish cost, JKS is 474% less than KAD 
with English data and is 163% less than KAD with 
mixed data. There are two reasons for this. One is 
because JKS uses a 2-tier hierarchical architecture. 
The rendezvous peer publishes the index entries from 
many connected edge peers. When there are 
duplicate index entries, only one is published. The 
other reason is that attributes and file information are 
attached to the keyword key published in KAD. So 
when there is a same keyword appeared in two file 
names, the keyword is published twice in KAD but 
only once in JKS. However, when mixed data is used, 
the performance improvement margin is smaller. The 
reason is that the CKP can retrieve more keywords 
from the file name so that more index entries can be 
published. 
   
 
Fig. 11. Publish cost.   
 
 
Fig. 12. Discovery cost. 
 
Fig. 12 shows the discovery cost using two kinds of 
data (English and mixed). JXTA is around 26 in both 
data because when a query finds nothing in the 
responsible rendezvous peer it goes walking. In the 
walking, it visits other rendezvous peers.  
JKS has 89% and 95% more discovery cost than 
KAD when the data are English and mixed, 
respectively. The reason is as follows. KAD is a 
2-level search scheme that searches the source key in 
the first level. The abundant information published 
with the keyword key gives the query sufficient 
information to determine whether it matches the 
  
 
 
[4] “JXTA CMS” [Online]. Available: 
https://jxse-cms.dev.java.net/ 
[5] “JXTA community projects,” [Online]. Available: 
https://jxta.dev.java.net. 
[6] “JXTA company spotlight,” [Online]. Available: 
https://jxta.dev.java.net/companyarchive.htm. 
[7] “SourceForge,” [Online]. Available: 
http://sourceforge.net/search/?type_of_search=s
oft&type_of_search=soft&words=jxta. 
[8] T. Kim, H. Lee, and H. Cheon, "Implementation 
of a service oriented architecture based on JXTA 
for new business models (ICCAS 2007)," in Proc. 
of the International Conference on Control, 
Automation and Systems , pp. 2402-2406, 
October 2007. 
[9] E. K. Lua, J. Crowcroft, M. Pias, R. Sharma, and 
S. Lim, "A survey and comparison of 
peer-to-peer overlay network schemes," 
Communications Surveys & Tutorials, IEEE, vol. 
7, pp. 72-93, 2005. 
[10] Y.-J Joung, L.-W. Yang, and C.-T. Fang, 
"Keyword search in DHT-based peer-to-peer 
networks," IEEE Journal on Selected Areas in 
Communications, vol. 25, pp. 46-61, January 
2007. 
[11] L. Liu, K. D. Ryu, and K.-W. Lee, "Keyword 
fusion to support efficient keyword-based search 
in peer-to-peer file sharing," IEEE International 
Symposium on Cluster Computing and the Grid, 
pp. 269-276, April 2004. 
[12] “JXTA Java Standard Edition v2.5: Programmers 
Guide,” [Online]. Available: 
https://jxta-guide.dev.java.net. 
[13] N. Théodoloz, "DHT-based Routing and 
Discovery in JXTA," Master’s Thesis, School of 
Computer and Communication Sciences, 
February 2004. 
[14] M. Abdelaziz, B. Traversat, E. Pouyoul, "Project 
JXTA: A Loosely-Consistent DHT Rendezvous 
Walker," Mar. 2003. [Online]. Available: 
http://www.jxta.org/docs/jxta-dht.pdf. 
[15] “JXSE CMS,” [Online]. Available: 
https://jxse-cms.dev.java.net. 
[16] X. Xiang, Y. Shi, and L. Guo, "Rich metadata 
searches using the JXTA content manager 
service," in Proc. of the 18th International 
Conference on Advanced Information 
Networking and Applications, vol. 1, pp. 624-629, 
2004. 
[17] R. Brunner, “A performance evaluation of the 
Kad-protocol,” Master’s Thesis, University of 
Mannheim and Institut Eurecom, 2006. 
[18] M. Steiner, T. En-Najjary, and E. W. Biersack, 
"A global view of KAD," in Proc. of the 7th ACM 
SIGCOMM Conference on Internet Measurement, 
pp.117-122, 2007. 
[19] “eMule,” [Online]. Available: 
http://www.emule-project.net/home/perl/general.
cgi?l=1. 
[20] D. Carra and E. W. Biersack, "Building a reliable 
P2P system out of unreliable P2P clients: the case 
of KAD," in Proc. of the ACM CoNEXT 
Conference, No. 28, 2007. 
[21] “AOL query log,” [Online]. Available: 
http://www.gregsadetsky.com/aol-data. 
[22] “Yahoo,” [Online]. Available: 
http://tw.buzz.yahoo.com/live_kw.php.xml. 
[23] “Google Soap Search API,” [Online]. Available: 
http://code.google.com/apis/soapsearch. 
[24] D. Stutzbach, S. Y. Zhao, and R. Rejaie, 
"Characterizing files in the modern Gnutella 
network," Multimedia Systems, vol. 13, pp. 35-50, 
Sep. 2007. 
[25] X. Jin, W.-P. K. Yiu, and S.-H. G. Chan, 
"Supporting multiple-keyword search in a hybrid 
structured peer-to-peer network," in Proc. of the 
IEEE International Conference on 
Communications, pp. 42-47, June 2006. 
[26] M. Steiner, W. Effelsberg, T. En-Najjary, and E. 
W. Biersack. “Load reduction in the KAD 
peer-to-peer system,” in Proc. of 5th 
International Workshop on Databases, 
Information Systems and Peer-to-Peer 
Computing, 2007. 
[27] M. Steiner, T. En-Najjary, and E. W. Biersack, 
"Exploiting KAD: possible uses and misuses," 
ACM SIGCOMM Computer Communnication 
Review, vol. 37, pp. 65-70, 2007. 
[28] “NOVA,” [Online]. Available: 
http://www.nova.com.tw. 
 
 objects, and it causes network traffic much lower than the 
unstructured P2P network. The searching scheme in the hybrid 
P2P network depends on how popular the object is. However, 
defining popular objects is a complex problem. In contrast, the 
search mechanism in the structured P2P network is much 
simpler. Therefore, in this paper, we will focus on structured 
P2P networks. In structured P2P networks, we chose KAD 
since it is used by the most popular structured P2P networks 
[23]. 
B. Motivation 
We want to balance the publishing load in KAD P2P 
networks as much as possible to avoid peers becoming 
hotspots. In structured P2P systems, each data item is mapped 
to a unique identifier (ID) and the peer with this ID stores all 
the indexes that are mapped into it. Structured P2P systems 
could result in an )(log NO  imbalance factor in the number of 
objects stored at a peer, where N is the number of peers in the 
system [24]. Heavy load peers may become hotspots and cause 
network congestion around them and also affect routing 
performance. Once these peers become offline, the search hit 
rate will decrease dramatically. Load imbalancing is a critical 
problem that must be treated property in order to fairly use 
available physical resources. 
C. Problem statement 
We intend to resolve two problems in KAD P2P networks. 
The first one is the publish load imbalancing problem and the 
other is the search hit rate problem. By the structured P2P 
network mechanism, each keyword produces a key. Each key 
has a specific target peer to publish. Target peers use these 
keys to construct indexes of objects. If a keyword is popular, 
the target peer will handle unusually large indexes. In this 
situation, a few peers may handle most of the indexes. It may 
cause unbalanced loads between peers. As to the search hit rate, 
because peers are online or offline frequently in KAD P2P 
networks, peer offline or failures may result in indexes lost. 
Although indexes may be lost, the related objects still exist in 
the network. To find these objects, it will lower the search hit 
rate. 
II. PRELIMINARIES AND RELATED WORK 
Since the KAD P2P network is our main target to enhance, 
we review the KAD P2P network and some existing load 
balancing methods. KAD P2P networks are based on 
distributed hash table (DHT). First we review the DHT and 
then describe the mechanisms of how to lookup, publish, and 
search objects in the KAD P2P network. Finally, we review 
existing load balancing mechanisms, KAD [4], KAD-7 [20], 
and MHF [21]. 
 
A. Background of KAD 
Each KAD node has a global identifier, referred as KAD ID, 
which is 128-bit long and randomly generated by a 
cryptographic hash function. The designers of KAD decided to 
consider a contact sufficiently close to the target if it shares 
with it at least the first 8 bits. The space of KAD IDs that 
satisfy this constraint is called a tolerance zone [15]. There are 
25628   zones in a KAD P2P network. We will briefly 
explain the lookup, publishing, and searching procedures in 
KAD P2P networks. 
B.    Lookup procedure 
When searching for some objects, a peer needs to know the 
target location and explores the network in several steps. Each 
step will find peers that are closer to the target. Routing in 
KAD is based on prefix matching. In KAD networks, the 
distance between two nodes is calculated by XOR-distance. 
The XOR-distance is defined as d(a, b) = a  b. It calculates 
bitwise on the KAD IDs of two nodes, e.g., the distance 
between a = 10011 and b = 01111 is d(a, b) = 10011  01111 
= 10100. Routing to a KAD ID is done in an iterative way. 
Figure  is an example iterative lookup procedure. In the first 
step, the searching peer has three closest possible contacts 
from the routing table. They have different XOR-distances and 
are still not close enough to the target peer. The second step in 
Figure  shows that the searching peer received three responses. 
The searching peer obtains three closer possible contacts by 
the responses. If a new possible peer is in the tolerance zone, it 
will be stored to a list called the candidate list. In the third step, 
two of these possible peers are in the tolerance zone. These two 
peers will be saved to the candidate list. In the fourth step, the 
searching peer sends a request for closer peers to the three 
closest peers again. The lookup procedure terminates when the 
lookup responses contain only peers that are either already 
present in the candidate list or farther away from the target than 
the other top three candidate peers [15]. At this point, no new 
request is sent and the candidate list becomes stable. KAD 
travels only O(logN) peers during the execution of the lookup 
procedure when there are N peers in the network. 
C. . Publish procedure 
Publish is an essential action when peers want to share 
objects. Peers will publish keyword keys and a source key to 
foreign peers. Figure  shows an example of publishing steps for 
an index. Before publishing an index, a sending peer must use 
KAD_REQ to find a receiving peer. At first the sending peer 
sends a KAD_REQ to the receiving peer. KAD_REQ is used 
to find the receiving peer and check whether the peer is alive. 
When the receiving peer receives KAD_REQ, it will send a 
KAD_RES back. After establishing a connection between the 
sending peer and the receiving peer, the sending peer starts to 
publish keys to the receiving peer. 
 
 KAD_REQ’s peer N received for storing the same key does 
not exceed RFT. Figure (b) shows an alternative publishing 
procedure in five steps when the number of KAD_REQ’s peer 
N received for storing the same key K is over RFT. The five 
steps are: 
Step 1: When a sending peer wants to publish key K to 
receiving peer N, it sends a KAD_REQ to receiving 
peer N. 
Step 2: Divide REQ_counter by RFT to get a quotient i. In this 
case, i ≥ 1. Receiving peer N will become a 
redirection peer and redirect KAD_REQ to peer 
1202 iN . 
Step 3: When receiving peer 
1202 iN  receives KAD_REQ, 
it will sends a KAD_RES to the sending peer. 
Step 4: Then, the sending peer starts to send 
KAD_PUBLISH_REQ to new receiving peer 
1202 iN . 
Step 5: When receiving peer 
1202 iN  receives 
KAD_PUBLISH_REQ, it sends KAD_ PUBLISH 
_RES to sending peer N. Then, keyword K is 
published successfully. 
 
IV. SIMULATION RESULTS 
A. Simulation setup 
First, we analyze the KAD P2P network environment. In 
[18], the authors crawled a representative subnet of KAD 
every five minutes for six months. They found that in average, 
there are 8000 peers in a zone. In [17], the authors spied on one 
zone in the KAD P2P network for 12 hours. They observed 
that the number of search messages is 561,542 and the size of 
search messages is 10.8 MB, while the number of publishing 
messages is 5,549,183 and the size of publishing messages is 
996 MB. According to the observation in [17], the average size 
is 0.019 KB for a search message and 0.18 KB for a publishing 
message. We classify keywords into ranks according to the 
number of times a keyword appeared. The n
th
 popular keyword 
is classified as rank n. The number of indexes for the n
th
 
popular keyword is proportional to 
63.11 nk  , where k is the 
number of indexes for the most popular keyword [16]. 
According to [16], k is about 
710 . We used JAVA to construct 
our simulation environment. In the simulation, the number of 
indexes handled by each zone and the number of times each 
zone being requested were collected for evaluation. 
B. Simulation results 
We used Gini coefficient (G) as a load balancing index for 
evaluation of load balancing regarding the number of indexes 
handled by each zone. The range of G is between 0 and 1. The 
closer the G approaches to 0, the more load balancing it is. G is 
computed as follows [19]: 
 
 
N
i
N
j
ji
ll
N
G
1 1
2
1
2
1

 
For calculating G regarding the number of published 
indexes in each zone, N is the number of zones (N = 256), li and 
lj are the numbers of indexes handled by the i
th
 and j
th
 zones, 
respectively, and μ is the average number of indexes handled 
by each zone. For calculating G regarding the number of 
requested indexes in each zone, N is the number of zones (N = 
256), li and lj are the number of requested indexes in the i
th
 and 
j
th
 zones, respectively, and μ is the average number of 
requested indexes in each zone. 
Because RFT would affect the performance of KAD, 
KAD-7, and the proposed KAD-mod, we conducted 
experiments to decide the best RFT. Figure  shows G regarding 
the number of indexes published in each zone under a different 
RFT. We found that the lowest value of G occurs when the 
values of RFT are between 5000 and 6000. 
 
There are two issues in the proposed KAD-mod. First, the 
average hop count of finding a target to publish an index will 
increase after applying the KAD-mod method. We used the 
results of [15] to evaluate the average hop count of finding a 
target to publish an index. Figure  shows the average hop count 
of finding a target to publish an index under a different RFT. In 
our method, for some popular keywords, receiving peers may 
need to redirect KAD_REQs to other peers because the total 
number of indexes of a popular keyword in the receiving peers 
exceeds RFT. The redirection of KAD_REQs needs an 
additional hop to find the next target. 
 
Figure 6. The Gini coefficient regarding the number of indexes 
published in each zone under a different RFT. 
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
G
in
i 
 c
o
e
ff
ic
ie
n
t 
(G
) 
RFT 
KAD_REQ
Sending peer Receving peer: N
KAD_RE
S
KAD_PUBLISH_REQ
KAD_
PUBL
ISH_R
ES
1
2
3
4
KAD_REQ
Sending peer
Receving peer: 
N+i * 2120
KAD_R
ES
KAD_PUBLISH_REQ
KAD
_PUB
LISH
_RES
KAD_REQ
1
2
3
4
5
Redirection 
peer: N
(a) The publish procedure when receiving 
peer is not overloaded.
(b) The publish procedure when receiving 
peer is overloaded.  
Figure 5. The KAD-mod publish procedure for a key. 
 V. CONCLUSION 
A. Concluding remarks 
In this paper, we have presented an efficient modulo-based 
method (KAD-mod) to balance the publish load and request 
load of KAD P2P networks. Our approach also improves the 
hit rate of keyword searching. The proposed KAD-mod is a 
simple and effective method without complex calculations. By 
redirecting overloaded indexes, indexes can be distributed 
more even, and not only the publish load but also the request 
load of each peer would be more balanced. Although the 
average hop count of finding a target to publish an index will 
increase and the total network traffic will slightly increase, 
these overhands are very small. Based on the simulation results, 
the G (G, 0 ≤ G ≤ 1, 0: fully balanced) of publishing load for 
KAD-mod is 0.23, KAD-7 is 0.80, and KAD is 0.93. As to the 
G of request load, KAD-mod is 0.33, KAD-7 is 0.67, and KAD 
is 0.83. KAD-mod improves the search hit to 98% and only 
causes 8% extra traffic and KAD-mod’s is only 0.5 hop more 
than KAD and KAD-7. Our method can not only improve the 
search resilience but also balance the publish and request load 
among peers in KAD P2P networks.  
B. Future work 
The proposed KAD-mod is simple and effective method to 
achieve publish load balancing, request load balancing, and 
search resilience. In the future, we will adapt our method to let 
it be applicable to other DHT based P2P networks. In addition, 
if the number of indexes becomes too large, how to flexibly 
adjust RFT to balance load in the KAD P2P network is 
deserved to further study. 
REFERENCES 
[1]  “The Gnutella 0.4 protocol specification, 2000,” [Online]. Available: 
http://dss.clip2.com/GnutellaProtocol04.pdf. 
[2] A. Oram et al., Peer-to-peer: Harnessing the power of disruptive 
technologies, 2001, O'Reilly. 
[3] I. Clake, T.W. Hong, O. Sanberg, and B. Wiley. “Protecting free 
expression online with Freenet,” IEEE Trans. Internet Computing, vol. 6, 
no. 1, pp.40-49, 2002. 
[4] P. Maymounkov and D. Mazieres, “Kademlia: A peer-to-peer 
information system based on the XOR metric”, in Proceedings of the 1st 
International Workshop on Peer-to-Peer Systems (IPTPS), pp. 53- 65, 
March 2002. 
[5] I. Stoica, R. Morris, D. R. Karger, M. F. Kaashoek, and H. Balakrishnan, 
“Chord: A scalable peer-to-peer lookup service for Internet applications,” 
in Proceedings of the Conference on Applications, Technologies, 
Architectures, and Protocols for Computer Communications, pp. 
149-160, August 2001. 
[6] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker, “A 
scalable content-addressable network,” in Proc. ACM Applications, 
Technologies, Architectures, and Protocols for Computer 
Communications, pp. 161-172, August 2001. 
[7] A. Rowstron and P. Druschel, “Pastry: Scalable, decentralized object 
location and routing for large-scale peer-to-peer systems,” in 
Proceedings of the Conference on Applications, Technologies, 
Architectures, and Protocols for Computer Communications, pp. 
161-172, August 2001. 
[8] Y. Zhao, J. Kubiatowicz, and A. D. Joseph, “Tapestry: An infrastructure 
for fault-tolerant wide-area location and routing,” University of 
California, Berkeley, Tech. Rep., UCB/CSD-01-1141, April 2001. 
[9] “eMula Project,” [Online]. Available: http://www.emule.com/. 
[10] “BitTorrent,” [Online]. Available: http://www.bittorrent.com/. 
[11] “aMula Project,” [Online]. Available: http://www.amule.org/. 
[12] B. T. Loo, J. M. Hellerstein, R. Huebsch, S. Shenker, and I. Stoica, 
“Enhancing P2P file-sharing with an Internet-scale query processor,” 
Proceedings of the Thirtieth International Conference on Very large 
Data Bases, vol. 30, pp. 432-443, 2004. 
[13] B. T. Loo, R. Huebsch, I. Stoica, and J. Hellerstein, “The Case for a 
hybrid P2P search infrastructure,” In Proceedings of the 4th 
International Workshop on Peer-to-Peer Systems (IPTPS), pp. 141-150, 
February 2004. 
[14] R. Brunner, “A performance evaluation of the KAD-protocol,” Master’s 
Thesis, University of Mannheim and Institut Eurecom, November 2006. 
[15] M. Steiner, D. Carra, and E. W. Biersack, “Faster content access in KAD,” 
in Proceedings of the Eighth International Conference on Peer-to-Peer 
Computing, pp. 195-204, September 2008. 
[16] M. Steiner, W. Effelsberg, T. En-Najjary, and E. W. Biersack, “Load 
reduction in the KAD peer-to-peer system,” in Proceedings of the 5th 
International Workshop on Databases, Information Systems and 
Peer-to-Peer Computing, October 2007. 
[17] E. W. Biersack, “Everything you want to know on KAD,” June 2008. 
[Online]. Available: 
http://www.thlab.net/old/rescom2008/talks/E-Biersack_KAD-tut.pdf. 
[18] M. Steiner, T. En-Najjary, and E. Biersack. “Long Term Study of Peer 
Behavior in the KAD DHT,” in Proceedings of the IEEE/ACM 
Transactions on Networking, 2009. 
[19] T. Pitoura,  P. Triantafillou ,  T. Pitoura ,  P. Triantafillou. “Load 
distribution fairness in P2P data management systems,” in Proceedings 
of the IEEE 23rd International Conference on Data Engineering, pp. 
396-405, April 2007. 
[20] T. T. Wu and K.C. Wang. “An efficient load balancing scheme for 
resilient search in KAD peer to peer networks,” in Proceedings of the 
Ninth IEEE Malaysia International Conference on Communications, pp. 
759-764, March 2010. 
[21] Y. Mu, C. Yu, T. Ma, C. Zhang, W. Zheng, and X. Zhang. “Dynamic 
load balancing with multiple hash functions in structured p2p system,” in 
Proceeding of WiCom '09. 5th International Conference on Wireless 
Communications, Networking and Mobile Computing, October 2009.  
[22] M. Steiner, T. En-Najjary, and E. W. Biersack, “A global view of KAD” 
in Proceedings of the 7th ACM SIGCOMM Conference on Internet 
Measurement, pp. 117-122, October 2007. 
[23]  “Internet Study 2007,” [Online]. Available: http://www.ipoque.com/. 
[24] Y. Zhu, Y. Hu. “Efficient, proximity-aware load balancing for 
DHT-based p2p systems,” IEEE Trans. Parallel and 
Distributed Systems, vol. 16, no. 4, pp. 349-361, 2005. 
[25] M. Castro, M. Costa and A. Rowstron, “Peer-to-peer overlays: 
structured, unstructured, or both?” Microsoft Research, Cambridge, 
2004.
 
An Efficient Load Balancing Scheme for Resilient 
Search in KAD Peer to Peer Networks1 
Tai-Ting Wu, Kuochen Wang 
Department of Computer Science 
National Chiao Tung University 
Hsinchu 300, Taiwan 
kwang@cs.nctu.edu.tw 
 
 Abstract — In this paper, we propose an efficient multiple hashes 
method (called KAD-N) to balance peer loads in the KAD 
(Kademlia) network. Note that N is the maximum hash times, 
determining by a cost-effectiveness factor. This method hashes 
the keyword of an object r times to produce a key for publishing 
objects, where r is a random number and 1 ≤ r ≤ N. Simulation 
results show that the distribution of indexes is more balanced 
using the proposed KAD-N method. We found out that N = 7 
(KAD-7) is the optimal setting in our simulation environment. 
We used a standard deviation to evaluate the proposed load 
balancing method. Simulation results also show that KAD-7 has 
the search hit rate close to 100% and the standard deviation is 
44% less than that of the KAD (i.e., KAD-1), which means the 
proposed method is more load balancing than the KAD. 
However, KAD-7 has 7% extra traffic overhead. By increasing 
the search hit rate, KAD-N improves the search resilience of 
KAD networks with failed peers. Furthermore, the proposed 
KAD-N method can easily be extended to other DHT-based P2P 
networks. 
 
Keywords—Load balancing, KAD, peer to peer network, 
resilient search. 
I. INTRODUCTION 
The power to access useful information in a cost-effective 
manner is very important in today’s Internet. Models for 
information sharing between users are currently being 
investigated for collaborative and cooperative media sharing 
applications. The most popular model to date is based on the 
P2P communication network model. A P2P network consists 
of peers that can play the roles of both clients and servers. 
Peers in a P2P network do not exploit an existing network 
infrastructure for operations such as routing and information 
retrieval. They use other peers’ computing power and 
bandwidth to route and retrieve [1]. 
A. Types of P2P networks 
Based on the structure of a network, P2P networks can be 
divided into three types: structured, unstructured, and hybrid. 
Most of the structured P2P networks are constructed by using 
a distributed hash table (DHT). A peer in a DHT-based 
network represents a small database that is to store indexes of 
                                                 
  1 The support from the National Science Council, Taiwan under Grants 
NSC96-2628-E-009-140-MY3, NSC97-3114-E-009-001, and NSC98-2219-
E-009-008 is grateful acknowledged. 
objects. When a peer intends to locate an object, it first needs 
to determine which peer storing indexes of the object. This is 
usually done by hashing an object’s name to obtain a key 
which maps to a unique peer in the network. The remaining 
step then is simply routing the query message to the peer who 
storing indexes of the object [2]. Examples of DHT-based 
networks include KAD [3], Chord [4], Content Addressable 
Network (CAN) [4], Pastry [6], and Tapstry [7]. They differ 
basically in how peers maintain their routing tables to 
guarantee an efficient route between peers. KAD has been 
widely used in file sharing applications. Famous applications, 
such as eMule [8] and BitTorrent [9], were built based on 
KAD. 
As to the unstructured type, peers are loosely coupled in an 
unstructured P2P network. The link between two peers is 
established in a more casual way. Peers only pay little cost to 
maintain the network. Unstructured P2P networks rely on 
flooding or random walk for searching, with query messages 
propagated to every peer. This results in increased network 
traffic [1]. Although unstructured P2P networks have some 
drawbacks, such as unguaranteed search and a large number 
of search messages; however, they are easy to implement and 
maintain. Several successful unstructured P2P systems have 
been deployed over the Internet, such as Gnutella [10], 
FastTrack [11], and iMesh [12]. 
The JXTA-based P2P network is a representative of a 
hybrid type. JXTA [13] is a set of P2P protocols which has 
been adopted by many applications, such as WiredReach [21] 
and Collanos [22]. It uses loosely-consistent DHT (LC-DHT) 
as the underlying query routing mechanism. The LC-DHT 
uses a hybrid approach that merges structured and 
unstructured P2P networks [14]. However, JXTA is lack of 
some functions, such as keyword search. Keyword search for 
JXTA has been developed in [14]. 
B. Motivation of this research 
In structured P2P networks, if we publish an object by 
keywords, popular keywords will produce a lot of identical 
keys. Each key has a specific target to publish. Target peers 
use these keys to construct indexes of objects. So the indexes 
of these popular keywords may aggregate in a few peers. Thus, 
it may cause unbalanced loads between peers. Peers who store 
the indexes of popular keywords consume more resources 
than others. In unstructured P2P networks, peers save their 
Proceedings of the 2009 IEEE 9th Malaysia International Conference on Communications 
                                    15 -17 December 2009 Kuala Lumpur Malaysia
978-1-4244-5532-4/09/$26.00 ©2009 IEEE 759
method will result in more traffic in searching keywords. 
However, the number of search messages is usually ten times 
less than publishing messages [15]. Hence, KAD-N requires 
just a small overhead to balance the publishing load. 
Figure 4 is an example of multiple hashes for balancing the 
index distribution. Figure 4(a) is the index distribution of the 
original KAD. All indexes of an individual keyword will be 
handled by a keyspace, e.g. keyspace 1 handling all indexes of 
keyword Q. After applying the proposed KAD-N method to 
the network, the index distribution will spread more even. In 
this example, we apply KAD-3 to the network. KAD-3 will 
distribute indexes of keyword Q into 3 keyspaces as shown in 
Figure 4(b). One is handled by the original keyspace 1 and the 
other two will be spread to the other two keyspaces. 
 
 
Figure 2. The procedure of how to generate a key for publishing. 
IV. SIMULATION RESULTS 
A. Simulation setup 
First, we analyze the overhead of publishing messages and 
search messages in KAD. In [17], they spied on 20 different 
keyspaces of the KAD network for 24 hours. During this time, 
on average, 4.3 million publishing messages and 350,000 
search messages were recorded. Based on the measurements 
of [17], it showed that there are ten times more publishing 
messages than search messages. Moreover, a publishing 
message is ten times bigger than a search message since it 
contains not only a keyword but also metadata describing a 
published object. In [19], they also spied on a keyspace in the 
KAD P2P network for 12 hours.  They got 561,542 search 
messages and 5,549,183 publishing messages. Search 
messages produced 10.8 MB traffic and publishing messages 
produced 966 MB traffic. Based on these data, traffic 
produced by a search message and a publishing message on 
average is 0.019 KB and 0.18 KB, respectively. We used these 
data to calculate total network traffic in our simulation 
environment. Total network traffic contains search traffic and 
publishing traffic. 
We rank keywords according to their appearance times. 
Rank 1 is the most popular keyword. The publishing messages, 
which were collected by [17], contain 26,500 different 
keywords per keyspace and 315,000 distinct files. The 
appearances of each keyword were also counted. Based on 
these data, the study in [17] used Matlab to estimates the 
number of indexes for the ith popular keyword which is 
proportional to 1/i1.63 and the number of indexes for the most 
popular keyword is about107. For example, the number of 
indexes of the most popular keyword is ten times more than 
the tenth popular keyword in the KAD P2P network. That is, 
the peer who handles indexes of the most popular keyword 
will get ten times network load than the peer who handles 
indexes of the tenth popular keyword. Based on the above 
analysis, we evaluate the performance of our approach. 
 
 
 
Figure 3. The concept of multiple hashes for publishing and search. 
 
 
Figure 4. The concept of multiple hashes for balancing the index distribution. 
We used JAVA to construct our simulation environment. 
Based on [16] and the above analysis, we simulated the 
behaviors of how a KAD P2P network publishes objects and 
distributes indexes.  The indexes handled by each peer were 
also recorded. Then we applied our method to this simulation 
environment. We gathered the indexes handled by each peer 
and used them to show the effectiveness of the proposed 
KAD-N method. 
B. Simulation results 
Figure 5 shows the index distributions of each keyspace 
under different hash times. We rank keyspaces according to 
the number of indexes handled, i.e. keyspace popularity. Rank 
1 keyspace handles the most indexes. We found that the index 
distribution of the original KAD (KAD-1) is very uneven. A 
large number of indexes were handled by a few keyspaces. If 
we hash more times, some indexes would be moved from 
front rank keyspaces to others. From this figure, the index 
keyspace 1 
(a) The original KAD index distribution 
: Indexes of keyword Q : Publishing target 
(b) The KAD-3 index distribution 
Apply KAD-3 method 
Target peer
hash 
Object 1 
term 1 
term 2  
term 3 
Key 1 Key r 
hash hash 
… 
Hash r times 
r: A random number, 1 ≤  r ≤ N 
N: Maximum hash times 
761
 
Figure 7. The percentage of extra traffic under different hash times. 
 
Figure 8. The standard deviation of each keyspace under different hash times. 
V. CONCLUSIONS 
The proposed KAD-N method does balance load of each 
peer and also improve the search hit rate. It is a simple and 
effective method. By hashing random times when publishing a 
keyword, indexes can be distributed more even and the 
publishing load of each peer would be more balanced. 
Although KAD-N may slightly increase the number of total 
messages in the KAD network, the extra traffic is very small. 
Based on the simulation results, the optimal hash times (N) is 
7, which can improve the hit rate to close to 100% and results 
in about 7% of extra traffic. Our method can not only improve 
the search resilience but also balance the publishing load 
between peers in KAD networks. In addition, the proposed 
KAD-N method can be extended to support other DHT based 
P2P networks. 
 
Figure 9. The hit rate with respect to failed peers under different hash times. 
 
Figure 10. Cost-effectiveness factor under different hash times. 
REFERENCES 
[1] D. Kundur, Z. Liu, M. Merabti, and H. Yu, “Advances in peer-to-peer 
con tent search,” in Proceedings of the IEEE International Conference 
on Multimedia and Expo, pp. 404-407, July 2007. 
[2] Y.J. Joung, L.W. Yang, and C.T. Fang, "Keyword search in DHT-
based peer-to-peer networks," IEEE Journal on Selected Areas in 
Communications, vol. 25, pp. 46-61, January 2007. 
[3] P. Maymounkov and D. Mazieres, “Kademlia: A peer-to-peer 
information system based on the XOR metric,” in Proceedings of the 
1st International Workshop on Peer-to-Peer Systems (IPTPS), pp. 53-
65, March 2002. 
[4] Stoica, R. Morris, D. R. Karger, M. F. Kaashoek, and H. Balakrishnan, 
“Chord: A scalable peer-to-peer lookup service for Internet 
applications,” in Proceedings of the Conference on Applications, 
Technologies, Architectures, and Protocols for Computer 
Communications, pp. 149-160, August 2001. 
[5] Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker, “A 
scalable content-addressable network,” in Proceedings of the 
Conference on Applications, Technologies, Architectures, and 
Protocols for Computer Communications, pp. 161-172, August 2001. 
[6] Rowstron and P. Druschel, “Pastry: Scalable, decentralized object 
location and routing for large-scale peer-to-peer systems,” in 
Proceedings of the 2001 IFIP/ACM International Conference on 
Distributed Systems Platforms, vol. 2218, pp. 329-350, November 
2001. 
[7] Y. Zhao, J. Kubiatowicz, and A. D. Joseph, “Tapestry: An 
infrastructure for fault-tolerant wide-area location and routing,” 
University of California, Berkeley, Tech. Rep. UCB/CSD-01-1141, 
April 2001. 
[8] “eMula Project,” [Online]. Available: http://www.emule.com/. 
[9] “BitTorrent,” [Online]. Available: http://www.bittorrent.com/. 
[10] “Gnutella website,” [Online]. Available: http://www.gnutella.com. 
[11] “Fasttrack peer-to-peer technology,” [Online]. Available: 
http://www.fasttrack.nu/. 
[12] “iMesh website,” [Online]. Available: http://www.imesh.com. 
[13] “JXTA community projects,” [Online]. Available: 
https://jxta.dev.java.net. 
[14] M. Abdelaziz, B. Traversat, and E. Pouyoul, "Project JXTA: a loosely-
consistent DHT rendezvous walker," March 2003. [Online]. Available: 
http://www.jxta.org/docs/jxta-dht.pdf. 
[15] M. Steiner, D. Carra, and E. W. Biersack, “Faster content access in 
KAD,” in Proceedings of the Eighth International Conference on Peer-
to-Peer Computing, pp. 195-204, September 2008. 
[16] R. Brunner, “A performance evaluation of the KAD-protocol,” 
Master’s Thesis, University of Mannheim and Institut Eurecom, 
November 2006. 
[17] M. Steiner, W. Effelsberg, T. En-Najjary, and E. W. Biersack, “Load 
reduction in the KAD peer-to-peer system,” in Proceedings of the 5th 
International Workshop on Databases, Information Systems and Peer-
to-Peer Computing, October 2007. 
 
763
國科會補助專題研究計畫項下出席國際學術會議心得報告 
日期： 99 年 8 月 20 日 
                                
一、 參加會議經過 
 
本會議於北京清華大學舉辦，會期三天，會議地點為北京清華大學的信息技術大樓(Future 
Internet Technology Building)。本會議包括三個 Keynotes (其中比較有興趣的主題是 Scalable 
localized routing in wireless sensor networks)及八個 Sessions。我的論文被安排在第三天的第一個
session。本會議參加人數雖沒有像大型會議的人數那麼多，但每一個 session 的參與人數不少，而
發言也很踴躍。 
 
二、 與會心得 
 
本國際會議是在北京舉辦，會議過程中聽取了相當多的最新技術及研究，並且和與會人士做
多方面的學術交流與討論，學習到很多新的技術及概念。由於是在北京舉辦，所以對於大陸目前
的學術研究方向也有進一步的了解，對於兩岸的學術交流有相當的幫助。這是我第一次出國參加
國際會議，獲得非常寶貴的經驗，也在北京清華大學見證中國的學術研究的大幅進展。 
 
三、 考察參觀活動(無是項活動者略) 
 
北京是中國好幾個朝代的首都，文化遺產相當的豐富，這次趁著到北京參與會議的機會，走
訪了頤和園與故宮博物院。在參觀的過程中，深深了解到中國文化的博大精深。同時，也了解到
大陸的主要都市其實已經非常現代化。走在北京街頭，就像是走在台北街頭一樣，像北京這樣子
古老與現在交錯的城市，在世界上已算是少數。 
 
四、 建議 
 
兩岸的學術研究交流在會愈來愈頻繁，若可以就學術與教育方面採取更開放的態度來對待兩
岸的學術交流，相信不管是對於台灣或者是大陸的學術研究，彼此都會有更好的進步與發展。 
 
五、 攜回資料名稱及內容 
 
1. Proceedings of the International Conference on Wireless Algorithms, Systems, and Applications (CD). 
2. 相關會議及期刊之 Call for Papers. 
 
計畫編號 NSC 97-3114-E-009-001 
計畫名稱 在異質性同儕網路下即時多媒體內容之有效搜尋及繞徑技術 
出國人員
姓名 
施宏政 
服務機構及
職稱 
國立交通大學資訊工程系 
博士生 
會議時間 
2010年 8月 15日至 
2010年 8月 17日 會議地點 
中國 北京 
會議名稱 
(中文)  第五屆WASA無線演算法、系統與應用國際學術會議 
(英文)  The Fifth International Conference on Wireless Algorithms, Systems and 
Applications (WASA 2010) 
發表論文
題目 
(中文)  WiMAX行動裝置中保障服務品質與節省能源之封包排程演算法 
(英文)  A QoS-Guaranteed Energy-Efficient Packet Scheduling Algorithm for WiMax 
Mobile Devices 
76 H.-C. Shih and K. Wang 
 
 
To reduce the energy consumption of SSs, the sleep mode was introduced in the 
IEEE 802.16-2009 to achieve energy saving. The sleep mode is a state for an SS to be 
temporarily absent from the serving base station (BS) air interface [3]. Note that in the 
IEEE 802.16-2009, normal transmission periods, which are called normal mode, and 
sleeping periods, which are called sleep mode, are interleaved with each other. 
2   Existing Approaches 
The characteristics of wireless networks are high error rate, high channel variation, 
and high transmission delay, and we must consider these characteristics when we 
design a packet scheduling algorithm [4]. In [5], the authors proposed a Deficit Fair 
Priority Queue (DFPQ) algorithm, which uses two-tier architecture. The first tier 
ensures that low priority data streams will have the opportunity to transmit packets. 
The second tier uses a multiple queue mechanism and applies a different packet 
scheduling algorithm according to each queue’s characteristic. The drawback of this 
algorithm is that the transmission of low priority data streams may interrupt the 
transmission of high priority data streams. In [6], the authors proposed an algorithm 
called Preemptive DFPQ to fix the problem mentioned above. However, these two 
algorithms did not consider the wireless network channel condition. 
In [7], the authors proposed an algorithm that considers network traffic patterns 
and SS mobility to maximize energy efficiency. The authors suggested several calcu-
lation methods of the length of a sleep window to avoid the problem of serious trans-
mission delay caused by a long sleep window. The disadvantage of this algorithm is 
that the total sleep time will be shortened. In [8], the authors proposed another way to 
adjust the parameters of sleep mode for the traffic patterns of constant bit rate (CBR) 
and FTP. However, they set the round trip time (RTT) to a constant in their experi-
ment, which is not realistic in real network environments. 
In [9], the authors proposed an algorithm to determine the lengths of sleep window 
and listening window based on the QoS constraints of real-time communications. 
Packets are scheduled by the EDF algorithm. The disadvantages of this algorithm are 
that it uses linear integer programming to find an optimum solution, which results in 
high time and space complexities. In [10], the authors proposed a packet scheduling 
algorithm not only considering the delay constraint, but also the delay jitter constraint. 
Packets are also scheduled by the EDF algorithm. The disadvantage of this algorithm 
is that it is applied to PSC type 3, which will be deactivated when the sleep period is 
expired. As a result, the calculation of PSC parameters and the negotiation of PSC 
creation must be performed repeatedly, which are not energy-efficient. 
3   Design Approach 
In the IEEE 802.16-2009, we must combine packet scheduling and power saving 
modes altogether to achieve low power consumption, while maintaining the QoS 
requirement. Therefore, we propose a QoS-guaranteed and energy-aware packet 
scheduling algorithm. The proposed algorithm is divided into two steps: power saving 
class generation and packet scheduling, which involve simple computations so as to 
have low time complexity. 
78 H.-C. Shih and K. Wang 
 
Table 1. Experiment parameters 
Symbol Description Value 
BW Nominal channel bandwidth 10MHz 
NFFT Number of subcarriers 256 
Nd Data subcarriers 192 
G Guard fraction 1/4 
TF Frame duration 5 ms 
5.696296025
5.69633494
5.69600
5.69610
5.69620
5.69630
5.69640
5.69650
Naïve Proposed Algorithm
A
ve
ra
ge
 p
ac
ke
t 
de
la
y 
(m
se
c)
 
Fig. 1. Average packet delay under different numbers of connections 
2
2.5
3
3.5
4
4.5
5
1 2 3 4 5 6 7 8 9 10
E
ne
rg
y 
C
on
su
m
pt
io
n 
(j
ou
le
)
Number of Connections
Naïve Proposed Algorithm
 
Fig. 2. Energy consumption under various numbers of connections 
5   Conclusion 
As mobile computing is getting more popular, the demand of efficient power source 
usage will become even greater. In this paper, we have presented a QoS-guaranteed, 
energy-efficient packet scheduling algorithm. Simulation results show that our pro-
posed algorithm has 14.37% less energy consumption than the naïve algorithm. In 
addition, our algorithm does not sacrifice the average packet delay. Currently, we are 
working on comparing with some representative related work. The contributions of our 
proposed algorithm are that our algorithm is suitable for wireless environments where 
connections come and go rapidly and the time complexity of our algorithm is low. 
國科會補助計畫衍生研發成果推廣資料表
日期 2010年11月01日
國科會補助計畫
研發成果名稱
發明人
(創作人)
技術說明
技術移轉可行性及
預期效益
技術/產品應用範圍
產業別
計畫名稱:
計畫主持人:
計畫編號: 學門領域:
(中文)
(英文)
成果歸屬機構
(中文)
(英文)
在異質性同儕網路下即時多媒體內容之有效搜尋及繞徑技術
王國禎
96 -2628-E -009 -140 - WEB 技術
高效率非集中式之 KAD 同儕網路負載平衡策略
An Efficient Decentralized Load Balancing Scheme in KAD Peer-to-Peer
Networks
國立交通大學 王國禎,徐崇騵
在結構化同儕網路中具備關鍵字搜尋的系統皆會有負載不平衡的問題存在，並
且在上下線頻繁的網路中容易降低搜尋命中率。為了不讓單一個peer儲存過多
的關鍵字，我們提出一個具備強韌搜尋與負載平衡方法(KAD-mod)。KAD-mod會
給予每個peer一個新ID (mod ID)。mod ID的產生方式是用原本的ID去除以一個
zone最多會擁有的peer數後取餘數，此餘數就是mod ID。若是某個peer的負擔
超過門檻，此peer將會把過多的負擔重新導向給予其他zone且與此peer有一樣
mod ID之peer。藉由以上動作可以讓有共同mod ID之peers一起分擔負載。如此
一來可以避免同一關鍵字皆被同一個peer所儲存。模擬結果顯示，我們用基尼
系數來評估網路負載平衡程度，與其他同儕網路比較，其在評估發佈負載
(publish)方面，KAD-mod， KAD-7，和KAD 在基尼係數的表現上分別為
0.23，0.80，0.93。基尼係數越小，表示負載愈平衡。在評估被詢問負載
(request)時，KAD-mod， KAD-7，和KAD 在基尼係數的表現上分別為
0.33，0.67，0.83。另外因為關鍵字被分散儲存，所以搜尋命中率跟著一起提
升。當40% peers下線時，KAD-mod可以將搜尋命中率維持在98%，比起KAD的78%
高上許多。
In structured P2P networks, these P2P networks suffer from the
unbalanced publishing load problem. It causes a few peers handling
large numbers of indexes. Therefore, we propose a modulo-based method
(called KAD-mod) to balance load in the KAD network. We give each
peer a new ID (called mod ID) using modulo arithmetic. Request
forwarding threshold (RFT) is used to help decide if an index should
be redirected to the same mod ID of peers in another zones. This
method allows the same mod ID peers to share load. We used Gini
coefficient (G, 0 G 1, 0: fully balanced) as a load balancing index
to evaluate representative load balancing methods. Simulation results
show that the proposed KAD-mod has the index search hit rate close to
100%. The G of KAD-mod is 0.23, KAD-7 is 0.80, and KAD is 0.93 in
publishing load. In G for request load, KAD-mod is 0.33, KAD-7 is
0.67, and KAD is 0.83. We found that the proposed KAD-mod can achieve
資訊服務業
在結構化同儕網路中具備關鍵字搜尋的系統皆會有負載不平衡的問題存在。本方法可
用於任何結構化同儕網路。
現存的同儕網路大部分都具備關鍵字搜尋的功能，負載平衡問題及搜尋命中率一定需
要改善。本方法可以有效改善負載平衡及提高搜尋命中率。
註：本項研發成果若尚未申請專利，請勿揭露可申請專利之主要內容。
96年度專題研究計畫研究成果彙整表 
計畫主持人：王國禎 計畫編號：96-2628-E-009-140-MY3 
計畫名稱：高韌性同儕網路及其在即時多媒體上之應用--在異質性同儕網路下即時多媒體內容之有效
搜尋及繞徑技術 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 1 1 70%  
研究報告/技術報告 0 0 100%  
研討會論文 1 1 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 5 5 100%  
博士生 2 2 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 4 4 70%  
研究報告/技術報告 0 0 100%  
研討會論文 4 5 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 5 5 100%  
博士生 2 2 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
 
