 
中 文 摘 要 ： 本計畫主要目的在提出新穎、高效率且低成本的測試資料壓
縮技術，以解決因超大型積體電路日益複雜龐大所衍生之測
試資料量壓縮問題。一般而言，測試資料壓縮方法可分為測
試向量壓縮與測試響應壓縮，過去有許多不同的硬體架構被
提出來分別對測試向量與測試響應進行壓縮。然而，在測試
響應壓縮方面，傳統的測試響應壓縮方法常有失真
(aliasing)，無法壓縮含不確定值(unknown values)的資
料，或無法幫助電路錯誤診斷(diagnosis)等問題。除此之
外，以往的硬體測試向量壓縮技術，為達完整測試，往往需
耗費相當長的測試時間，且需使用外部自動測試設備或內部
記憶裝置儲存壓縮過後的測試資料，以至於需消耗較多測試
成本。因此，如何解決這些問題並有效降低測試成本已成為
學術界與工業界均極端重視的問題，此些問題也被列為未來
系統單晶片(SoC)發展的重要瓶頸之一。 
本計畫所提之測試資料壓縮技術，將有效地同時解決輸出響
應壓縮與測試向量壓縮所面臨的難題。在輸出響應壓縮方
面，此計畫提出一稱之為輸出響應資料選擇的壓縮技術，用
以同時解決失真、無法壓縮含不確定值的資料，與無法幫助
電路錯誤診斷(diagnosis)等問題，並在測試向量壓縮方面，
亦提出了不需儲存裝置的硬體測試向量產生器用以自動產生
完整測試所需的所有測試向量。本計畫為三年計畫，執行時
間為 2008 年 8 月 1 日至 2011 年 7 月 31 日，至今此計畫所有
項目均已完成，摘要如下： 
 
1. 輸出響應資料選擇之基本特性分析。 
2. 針對大電路發展一有效率且低記憶體使用量的輸出選擇演
算法。 
3. 發展一套快速求得資料選擇量最低限(Lower bound)的演
算法。 
4. 輸出響應資料選擇之硬體架構及其演算法分析 
5. 發展一對含不確定值之輸出響應資料選擇演算法 
6. 整合輸出響應資料選擇壓縮技術至傳統測試流程並進行驗
證 
7. 發展無須儲存裝置之硬體測試向量產生器架構及其演算法
分析 
8. 撰寫自動化軟體產生相關硬體壓縮電路達成流程自動化 
 
中文關鍵詞： 輸出響應壓縮、硬體測試向量產生器、電路自我測試、系統
單晶片測試 
英 文 摘 要 ： The main objective of this project is to develop and 
algorithm for output response selection method 
5. Development of output response selection algorithm 
with ability of unknown prevention 
6. Integrate the output response selection technique 
into a traditional test procedure and perform the 
gate-level verification 
7. Development of the hardware architecture and the 
algorithm for test pattern generator with no storage 
requirement 
8. Automation of software flow to generate related 
hardware compression circuit 
 
英文關鍵詞： IC Testing, output response compaction, hardware test 
pattern generator, built-in self-test, system-on-a-
chip test. 
 
1 
目  錄 
一、中文摘要 ……………………………………………….…………….……. 2 
    英文摘要 ……………………………………….………………….………. 2 
二、緣由及目的 ……………………………….…………………………….……. 3 
三、計畫進度與討論 ……………………………………………………………... 3 
四、結論及論文發表 ……………………………………..………...................….. 9 
五、成果自評 …………………………………………………………………... 9 
 
圖一、輸出響應資料選擇架構概觀……………..………………..…………..……. 9 
圖二、唯一區域與唯一錯誤的範例……..………………………………………... 10 
圖三、以計數器為基礎之輸出響應壓縮電路…..………………………………... 10 
圖四、輸出響應選擇演算法流程………..………………………………………... 10 
圖五、預防不確定值之路徑選擇方法…..………………………………………... 10 
圖六、以累加器為基礎之輸出響應壓縮電路…..………………………………... 10 
圖七、整合輸出響應選擇技術之測試流程…..…………………………………... 10 
圖八、無須儲存裝置的自動向量產生器架構…..………………………………... 11 
圖九、硬體自動向量產生器測試流程…..………………………………………... 11 
圖十、以旋轉為基礎之自我回授測試硬體…..…………………………………... 11 
 
表一、 以商用軟體對輸出響應選擇量分析…………………………….…….….. 10 
表二、 高效率且低記憶體的輸出選擇演算法……………………………….…... 11 
表三、 輸出響應選擇資料最低限分析………………………………………….... 11 
表四、 動態輸出選擇演算法實驗結果使用(+1 -1)計數器與 32條掃描鏈……... 12 
表五、 動態輸出選擇演算法實驗結果使用不同計數器與 32條掃描鏈……….. 12 
表六、 動態輸出選擇演算法實驗結果使用(+1 -1)計數器於不同數目掃描鍊 ... 11 
表七、 預防不確定值之輸出響應選擇使用(+1 -1)計數器實驗結果(不含掃描鏈重
排方法) ……………………………………………………………..……... 12 
表八、 預防不確定值之輸出響應選擇使用(+1 -1)計數器實驗結果(含掃描鏈重排
方法) …………………………………………………………………..…... 13 
表九、 預防不確定值之輸出響應選擇使用(+3 +1 0 -1)計數器對不確定值之實驗
結果(含掃描鏈重排方法) …………………………………………….…... 13 
表十、以累加器為基礎之輸出響應選擇技術對不同數目壓縮輸出端實驗結果... 13 
表十一、輸出響應選擇壓縮技術面積負擔使用(+1 -1)計數器不同數目掃描鏈.. 14 
表十二、輸出響應選擇壓縮技術使用累加器對不同數目輸出端面積負擔…….. 14 
表十三、硬體自動向量產生器設計演算法之實驗結果………………………….. 14 
表十四、以旋轉為基礎之硬體自動向量產生器設計演算法實驗結果………….. 14 
 
附件一、可供推廣之研發成果資料 ……………………………………….…… 15 
 
3 
that high test cost is often required. So, how to 
solve those problems and reduce the test cost 
efficiently has become a critical problem in 
both academia and industry. It is also a serious 
bottleneck in future SOC design.  
In this project, the proposed technologies 
can overcome the challenges of both the 
stimulus compaction and the response 
compaction effectively and concurrently. For 
the response compaction, this project proposes 
a compaction method called output response 
selection method to solve all aliasing, 
unknown values and difficult-to-diagnose 
problems simultaneously. For the pattern 
compaction, this project also presents a 
hardware test pattern generator to generate all 
test patterns and achieve complete fault 
coverage without storage requirement. This 
project will be carried out in three years (from 
Aug. 1, 2008 to July 31, 2011). All items in 
this project are accomplished as listed below. 
 
1. Analysis the basic concepts of output- 
selection-based response compaction. 
2. Development of algorithms to 
efficiently select the output response 
data. 
3. Lower bound analysis on the selections 
of output response data. 
4. Analysis of the hardware architecture 
and the algorithm for output response 
selection method 
5. Development of output response 
selection algorithm with ability of 
unknown prevention 
6. Integrate the output response selection 
technique into a traditional test 
procedure and perform the gate-level 
verification 
7. Development of the hardware 
architecture and the algorithm for test 
pattern generator with no storage 
requirement 
8. Automation of software flow to generate 
related hardware compression circuit 
 
Keywords: IC testing, output response 
compaction, hardware test pattern generator, 
built-in self-test, system-on-a-chip test. 
 
2、 緣由及目的 
在積體電路測試領域中，掃描式測試法
為一廣被業界採用的測試技術。然而，許多
研究結果(如本實驗室在1998年於ICCAD所
發表之 Broadcast scan 之觀念)均顯示傳統
的掃描式測試方法面對日益複雜的電路仍
有許多可改善的空間。而近年來基於掃描測
試方法所發展出來的一些技術，其效率之佳
更使人不得不重新思考如何發揮本技術之
最大效果。 
    一般而言，測試資料壓縮方法可分成輸
入資料(測試向量)及輸出資料(輸出響應)之
壓縮。在本計畫中，我們將同時考慮輸入與
輸出資料壓縮以期達到最佳的測試資料壓
縮效果。由於同時考量輸出及輸入端的測試
資料壓縮，因此比起僅單一考量輸出或輸入
資料壓縮更能夠有效降低測試成本。基於本
實驗室在掃描式測試方法多年累積的經
驗，本計畫也將整合多項低成本的測試技
術，以提供一套最佳的掃描式測試架構為目
標。 
3、 計畫成果與討論 
我們所提出的測試資料壓縮架構需要
整合許多不同的方法，涵蓋層面極廣。本計
畫第一年度對測試資料壓縮的基本特性分
析結果，基於此特性分析的結果，本計畫第
二年度與第三年度進一步提出對應的輸出
與輸入端測試資料壓縮技術，並針對其硬體
架構與演算法進行分析驗證。茲將已完成的
工作項目摘要分述如下： 
 
3.1 輸出響應資料選擇之基本特性分析 
我們首先分析輸出選擇的選擇問題並
將其模型化，如圖一所示。當一筆測試資料
輸入待測電路(circuit under test)之後，電路
中的錯誤被激發並傳遞到多個輸出端，而我
5 
觀察少於 3%的輸出端響應。經由實驗結果
顯示，所提出的壓縮方法在所有測試電路中
皆能達到很高的壓縮效率，尤其在較大電路
中效果更加顯著，足以證明此一輸出選擇響
應壓縮技術能夠有效應用於龐大電路。 
 
3.3 發展一套快速求得資料選擇量最低限
(Lower bound)的演算法 
雖然我們所提出的演算法在小電路的
驗證中均可以找到近似商用軟體所提供的
最佳解，但對於大電路中依然無法評判其成
效如何，故我們亦發展一個可快速分析資料
選擇量最低限(Lower bound)的演算法，可進
一步驗證其輸出選取演算法效率。 
首先，我們先找出每一輸出端的唯一區
域(unique cone)，如圖二扇型標示區域，由
於無論在何種測試向量中，此區域所測試到
的錯誤必定會傳遞其錯誤響應到唯一的輸
出端，此種錯誤被我們稱之為唯一錯誤
(unique fault)。由此一錯誤的特性可知，為
觀察到所有的唯一錯誤，所有能夠觀察到唯
一錯誤的輸出端均須被選取。基於此一概
念，我們可以將所有能夠測試到唯一錯誤的
輸出端數目當成是輸出選擇資料的最低
限。表三顯示各電路對應的最低限並與我們
所提出的輸出選取演算法比較。由此結果可
知，除 c3540外，我們輸出選擇演算法找出
的解與最低限的平均差異小於 10%，足以證
明我們所提的輸出選擇演算法相當有效率。 
 
3.4 輸出響應資料選擇對單一壓縮輸出端
之硬體架構設計及分析 
基於前述的輸出選擇特性分析，我們提
出一個以計數器為基礎的輸出響應選擇硬
體壓縮技術，可將輸出響應選擇的概念實際
應用在使用掃描式測試架構進行測試的待
測電路中，以下是我們對此技術的說明。 
    以計數器為基礎的輸出響應選擇硬體
架構如圖三所示，其壓縮硬體由一計數器及
一多工器所組成，由於壓縮硬體僅附加在待
測電路輸出端，因此不需修改原先電路即可
直接應用於一般掃描式測試架構，故可輕易
整合至一般測試流程中。在測試時，當輸出
響應傳遞至掃描鍊輸出端的同時，我們可藉 
由輸入適當的控制訊號對計數器進行控
制，根據計數器所顯示的數值，所需觀察的
輸出響應資料將依序被選取並傳遞至壓縮
硬體輸出端，由於僅有選擇到的輸出資料能
夠被觀察，其他不需觀察的部分將被忽略，
因此可以達到輸出響應壓縮之目的。此外，
由於壓縮硬體僅需使用一計數器與一多工
器，因此不論額外面積負擔或控制複雜度，
均比傳統的輸出響應壓縮方法來的低。 
針對以計數器為基礎的選擇硬體架
構，我們提出一不需修改輸出端測試向量的
動態輸出選擇演算法，此一方法可藉由控制
計數器的運作分析出最少所需觀察的輸出
響應以有效提高輸出資料壓縮率。 
其演算法流程如圖四所示，如章節 3.2
的方法所述，我們首先使用錯誤模擬器產生
對應輸入端測試向量的錯誤辭典，由錯誤辭
典中，我們得知各輸出端的錯誤響應與其所
觀察到的錯誤資訊，並優先選取所有的必要
輸出位元。然而由於一計數器在單一測試週
期僅會選擇一個輸出位元，所以在此演算法
中，我們定義一組能夠被計數器連續選擇的
輸出位元為一條路徑(path)，其所含的輸出
位元數目至多等同於掃描鏈的深度 (scan 
depth)，舉例來說，在圖四中的一條路徑可
包含 SFF1、SFF5、SFF9和 SFF11。當一路
徑所含的輸出位元數目比起掃描鏈深度來
的小，代表此路徑尚能夠容納其他選取的輸
出位元，我們稱此一路徑為部分路徑(partial 
path)，而包含一個以上必要輸出位元的路徑
被稱之為必要路徑(essential path)。基於上述
7 
資料當成障礙物，並將可使用計數器選
取的所有輸出響應建構成如圖五右方所
示之路徑，藉此我們便可根據此路徑圖
選擇所有需觀察的輸出響應，此一方法
可整合至動態輸出響應選擇演算法(見
章節 3.4)的步驟一至步驟三。 
 
(2) 掃描鏈重排方法: 雖預防不確定值之路
徑選擇方法可利用建構一不含不確定輸
出資料的路徑圖用來避免選取到含不確
定值的輸出資料，然若含不確定值的輸
出資料過多時，此一方法仍有可能找不
到任何路徑，因此我們利用掃描鏈重排
方式改變原先的路徑，並配合項目(1)所
述的預防不確定值之路徑選擇方法，進
一步提升預防不確定值的壓縮能力。 
 
表七與表八分別顯示整合預防不確定
值之路徑選擇方法至輸出響應選擇演算法
含與不含掃描鏈重排方法的實驗結果，表中
的數字代表選擇的路徑數而括弧中的數字
代表無法避免的不確定值數，由結果可知當
不確定值的數目較低時，我們僅需使用防不
確定值之路徑選擇方法即可避免選到任何
不確定值，但當不確定值的數目較高時，加
入掃描鏈重排方法可有效降低選到的不確
值數目。此外我們更進一步改變計數器模
組，實驗結果(見表九)顯示變更使用(+3 +1 0 
-1)計數器後，即使輸出響應有高達 14-36%
的不確定值，我們的方法依然可以完全避免
選取到任何一個含不確定值的輸出資料。 
 
3.6 輸出響應資料選擇對多壓縮輸出端之
硬體架構設計及分析 
由於上述以計數器為基礎的輸出響應
選擇壓縮硬體(見章節 3.4與 3.5)僅使用一個
計數器與一個多工器，因此在每一個測試週
期只能夠觀察到一筆輸出響應(單一壓縮輸
出端)，為了達到完整錯誤涵蓋率，需載入
一組測試向量多次以選取所需觀察的全部
輸出響應，因此將導致測試時間延長。為解
決此一問題，我們提出一以累加器
(Accumulator)為基礎的輸出響應選擇壓縮
硬體，利用數個累加器與數個多工器，我們
便可在同一測試週期同時選取多個輸出響
應進行觀察(多壓縮輸出端)，由於累加器可
任意變換所需的加數，比起計數器功能更加
強大，因此可降低在觀察多輸出響應時選取
到不必要輸出響應的機率。 
利用累加器的特性，我們亦提出一測試
向量與輸出響應選擇演算法，此一演算法特
點是能夠在產生測試向量的同時考慮輸出
響應選擇壓縮。此一演算法的步驟簡單敘述
如下： 
 
步驟一: 對所有的錯誤產生一組測試向量
集合及其對應的錯誤辭典，並利用
錯誤辭典提供的資訊計算每一個
錯誤與輸出端的權重。 
步驟二: 逐一選取高權重的輸出端，並加入
一條決定的路徑中直到此一路徑
被填滿(full path)。 
步驟三: 針對步驟二與前一個疊代中決定
的路徑各自產生一組測試向量，並
根據其測試到的錯誤計算各自的
測試向量權重，選取權重較高的測
試向量與其對應的路徑加入最後
的測試向量集合中。 
步驟四: 將所有被選取測試向量測試到的
錯誤自錯誤集合中排除。如仍有錯
誤尚未被測試到，更新每一輸出端
的權重並回到步驟二，否則結束此
流程。 
 
表十列出上述流程在 ISCAS’89 與
ITC’99大電路的實驗結果。以觀察單一壓縮
9 
我回授邏輯產生出所需的種子向量 (seed 
pattern)，並利用循環位移暫存器將每一種子
向量對應的所有測試向量依序產生出來，由
於只有種子向量是由選取內部接線產生
的，比起章節 3.8的架構，此一架構可有效
降低所需的接線數量，其實驗結果如表十四
所示，可知大多數的電路可使用更少的接線
組合在極短時間內達成完整測試。 
 
4、 成果自評 
本計畫主要目的在提出一新穎、低成
本且高效率之測試資料壓縮技術，以解決輸
出測試資料量過於龐大的問題。本計畫除完
成原規劃之內容外，亦支援另一未獲國科會
補助之計畫，即如何增進 IC 產品之良率之
計畫，另本計畫亦衍生一產學合作計畫，與
台積電共同合作開發一先進製程之測試及
診斷技術，但因其涉及商業機密，故成果不
能在此列出。本計畫共執行三年，與原規劃
內容相關之主要成果如下: 
1. 已完成對輸出響應資料選擇之高效率
演算法，實驗結果顯示此技術對於大型
電路僅需觀察不到 3%的輸出響應即可
達到 100%錯誤覆蓋率。 
2. 可輕易解決傳統壓縮器所面臨的失
真、不確定值及不利錯誤診斷等問題。 
3. 已分別提出以計數器以及累加器為基
礎的硬體架構以將此技術實現在以掃
描鏈為基礎的電路上。實驗結果證實僅
需不到 2%之額外面積。 
4. 結合所提出的不確定值避免技術，可成
功解決含超過 14%不確定值的輸出資
料壓縮問題。 
5. 提出一使用電路內部接線的自我回授
測試技術，並結合以旋轉為基礎之自我
回授測試硬體，使其所產生的測試向量
不需任何儲存裝置即可在極短時間內
達到 100%的錯誤覆蓋率。 
 
5、 發表及準備中之論文 
本計畫目前成果包含已發表論文 11 篇，
已投稿論文 2篇，準備中論文 3篇，列舉如
下： 
 
[1] K.-J. Lee, W.-C. Lien and T.-Y. Hsieh, “Test 
Response Compaction via Output Bit 
Selection," IEEE Transactions on Computer- 
Aided Design of Integrated Circuits and 
Systems, Vol. 30, No. 10, pp.1535-1544, Oct. 
2011. 
[2] K.J. Lee, Tong-Yu Hsieh, Ching-Yao 
Chang, “On-Chip SOC Test Platform 
Design Based on IEEE 1500 Standard,” 
IEEE Transactions on Very Large Scale 
Integration Systems, 18(7), 1134-1139, 
July, 2010. 
[3] T.-Y. Hsieh, K.-J. Lee and M. A. Breuer, 
"An error-tolerance-based test methodo- 
logy to support product grading for yield 
enhancement," IEEE Trans. on 
Computer-Aided Design of Integrated 
Circuits and Systems, Vol. 30, No. 6, pp. 
930-934, Jun. 2011. 
[4] K.-J. Lee, T.-Y. Hsieh and M. A. Breuer, 
“Efficient over-detection elimination of 
acceptable faults for yield improvement,” 
IEEE Trans. on Computer-Aided Design 
of Integrated Circuits and Systems, 
accepted. 
[5] W.-C. Lien, T.-Y. Hsieh, C.-T. Tsai and K.-J. 
Lee, “A Rotation-Based BIST with 
Self-Feedback Logic to Achieve Complete 
Fault Coverage,” Int’l Symp. VLSI Design, 
Automation and Test, 2011, pp.1-4. 
[6] W.-C. Lien, K.-J. Lee, T.-Y. Hsieh, “Concurrent 
Determination of Seeds and Test Sequences for 
LFSR Reseeding,” The 6th VLSI Test 
Technology Workshop, July 13-15, 2011, 
pp.1-4. 
[7] W.-C. Lien, K.-J. Lee, T.-Y. Hsieh and S.-S. 
Chien, “Test Response Compaction via 
Accumulator-Based Output Selection,” The 22th 
VLSI DESIGN/CAD Symposium, 2011. 
[8] W.-C. Lien and K.-J. Lee, “A Complete Logic 
BIST Technology with No Storage 
Requirement,” The 19th Asian Test Symposium, 
2010, pp.129-134. 
[9] W.-C. Lien, Y.-T. Wang, Y.-H. Wu and K.-J. 
Lee, “Counter-Based Output Selection Method 
for Test Response Compaction,” Electronic 
Technology Symposium, June 18, 2010, pp. 
1-4. 
[10] W.-C. Lien and K.-J. Lee, “Efficient 
Mixed-Mode BIST for Complete Fault 
11 
圖六、以累加器為基礎之輸出響應壓縮電路 
 
 
圖七、整合輸出響應選擇技術之測試流程 
 
表一、以商用軟體對輸出響應選擇量分析 
CKT #OL #TF #TP #SOB OR% 
c432 7 523 28 69 35.20  
c499 32 750 52 119 7.15  
c880 26 942 21 189 34.62  
c1355 32 1566 84 143 5.32  
c1908 25 1870 106 247 9.32  
c2670 140 2630 45 421 6.68  
c3540 22 3291 93     
c5315 123 5293 46 882 15.59  
c6288 32 7710 14 202 45.09  
c7552 108 7419 75 866 10.69  
s838 34 857 76 217 8.40  
s953 52 1079 76 327 8.27  
s1423 79 1501 24 401 21.15  
s5378 228 4563 100 1050 4.61  
s9234 250 6475 111 1503 5.42  
s13207 790 9664 235     
s15850 684 11336 97     
s35932 2048 35110 12 8574 34.89  
s38417 1742 31015 87     
s38584 1730 34797 114     
 
表二、高效率且低記憶體的輸出選擇演算法 
CKT # Essential Bits 
Peak   
Memory % 
#SOB 
(optimal) 
#SOB 
(OS) 
OR 
% 
Time 
(sec) 
c432 47 39.86 69 69 35.2 0.01 
c499 64 31.48 119 119 7.15 0.03 
c880 117 46.47 189 189 34.62 0.01 
c1355 96 28.38 143 143 5.32 0.08 
c1908 144 16.5 247 247 9.32 0.18 
c2670 53 75.62 421 424 6.73 0.19 
c3540 36 75.84  231 11.29 0.28 
c5315 293 52.62 882 899 15.89 0.41 
c6288 115 37.2 202 208 46.43 0.14 
c7552 298 41.56 866 873 10.78 0.75 
s838 89 59.52 217 222 8.59 0.05 
s953 123 49.02 327 329 8.32 0.08 
s1423 163 61.41 401 404 21.31 0.05 
s5378 178 76.27 1050 1080 4.74 0.98 
s9234 506 62.71 1503 1509 5.44 0.96 
s13207 176 88.23  2998 1.61 6.22 
s15850 543 64.42  2929 4.41 2.52 
s35932 3136 57.47 8574 8574 34.89 0.23 
s38417 1127 70.49  7261 4.79 6.01 
s38584 2012 71.08  10497 5.32 7.57 
b17 3018 42.4  18152 1.14 94.67 
b18 11853 40.54  55803 1.51 273.36 
b19 22416 40.22  113175 1.26 757.54 
b20 2693 28.75  9077 2.49 23.27 
b21 2950 28.04  9342 2.48 24.46 
b22 3882 27.7  13395 2.84 32.83 
Avg.   50.53    11.30    
 
表三、輸出響應選擇資料最低限分析 
CKT #TF #UF LB #SOB Difference ratio (%) 
Time  
(sec) 
c432 523 131 67 69 2.99  0.2 
c499 750 294 110 119 8.18  0.5 
c880 942 576 184 189 2.72  0.5 
c1355 1566 553 135 143 5.93  2 
c1908 1870 817 225 247 9.78  7 
c2670 2630 614 345 424 22.90  2 
c3540 3291 509 132 231 75.00  3 
c5315 5293 1657 763 899 17.82  4 
c6288 7710 1058 190 208 9.47  2 
c7552 7419 3205 763 873 14.42  9 
s838 857 564 210 222 5.71  1 
s953 1079 511 283 329 16.25  2 
s1423 1501 861 393 404 2.80  2 
s5378 4563 1452 898 1080 20.27  16 
s9234 6475 4050 1422 1509 6.12  28 
s13207 9664 5781 2772 2998 8.15  136 
s15850 11336 6485 2762 2929 6.05  111 
s35932 35110 23728 8574 8574 0.00  121 
s38417 31015 15839 6360 7261 14.17  216 
s38584 34797 24176 9803 10497 7.08  277 
Avg. 12.79 (9.52)   
 
 
 
表六、動態輸出選擇演算法實驗結果使用
(+1 -1) 計數器於不同數目掃描鏈 
CKT 8 16 32 64 128 Lower Bound 
s13207 16.25  9.38  5.72  4.23  3.18  1.61  
s15850 20.25  13.00  10.13  8.34  6.47  4.40  
s35932 45.63  42.06  40.38  33.95  28.94  34.89  
s38417 24.88  16.94  14.72  12.03  10.04  4.79  
s38584 27.38  17.88  14.97  13.48  10.98  5.32  
b14 17.13  9.13  5.84  4.13  3.17  2.22  
b15 18.75  10.44  6.59  4.69  3.45  2.16  
b17 19.38  10.75  6.75  4.81  3.14  1.14  
b18 25.75  15.56  11.13  9.03  7.28  1.50  
b19 27.75  16.38  11.41  9.09  7.82  1.26  
13 
b19 11.40  8.79  9.27  14.33  10.26  10.46  7.54  9.25  7.47  
b20 7.95  8.71  7.88  9.79  7.77  7.45  6.61  6.81  7.58  
b21 8.13  8.99  7.98  9.88  7.92  7.45  6.76  6.95  7.59  
Avg. 9.39  9.14  8.88  10.55  9.12  9.00  7.42  7.80  7.57  
表七、預防不確定值之輸出響應選擇使用(+1 -1)計數器實驗結果(不含掃描鏈重排方法) 
CKT Percentage of unknown data in all output bits 0% 0.5% 1% 2% 3% 4% 5% 10% 
s13207 443 (0) 443 (0) 445 (0) 448 (0) 444 (1) 453 (1) 447 (2) 458 (8) 
s15850 393 (0) 392 (0) 398 (0) 406 (1) 408 (2) 407 (0) 412 (0) 424 (15) 
s35932 331 (0) 328 (0) 333 (0) 332 (2) 336 (3) 339 (6) 338 (4) 347 (39) 
s38417 483 (0) 480 (0) 485 (0) 490 (2) 491 (3) 495 (4) 501 (4) 530 (25) 
s38584 712 (0) 722 (0) 719 (0) 729 (0) 730 (2) 744 (4) 755 (8) 804 (50) 
b14 1319(0) 1325(0) 1328(0) 1340(2) 1342(2) 1347(2) 1348 (7) 1371(27) 
b15 940 (0) 945 (0) 940 (0) 946 (0) 964 (0) 963 (2) 967 (5) 1005(21) 
b17 2260(0) 2260(0) 2272(0) 2306(5) 2323(2) 2340(8) 2350(17) 2513(75) 
b18 3943(0) 3974(2) 4000(2) 4012(10) 4064(34) 4108(47) 4178(68) 4423(361) 
b19 4919(0) 4951(1) 4962(5) 5013(13) 5078(43) 5131(78) 5186(113) 5478(689) 
b20 1815(0) 1812(0) 1824(1) 1832 (2) 1838 (2) 1846 (7) 1870 (18) 1929 (62) 
b21 1917(0) 1923(0) 1924(0) 1929 (0) 1954 (7) 1959 (7) 1963 (9) 2044 (52) 
 
 
表八、預防不確定值之輸出響應選擇使用(+1 -1)計數器實驗結果(含掃描鏈重排方法) 
CKT Percentage of unknown data in all output bits 0% 0.5% 1% 2% 3% 4% 5% 10% 
s13207 443 (0) 443 (0) 445 (0) 448 (0) 445 (0) 463 (0) 450 (0) 465 (0) 
s15850 393 (0) 392 (0) 398 (0) 399 (0) 403 (0) 407 (0) 412 (0) 429 (0) 
s35932 331 (0) 328 (0) 333 (0) 337 (0) 336 (0) 335 (0) 339 (0) 352 (12) 
s38417 483 (0) 480 (0) 485 (0) 477 (0) 493 (0) 492 (0) 500 (0) 519 (0) 
s38584 712 (0) 722 (0) 719 (0) 729 (0) 740 (0) 747 (0) 761 (0) 794 (15) 
b14 1319 (0) 1325 (0) 1328 (0) 1426 (0) 1428 (0) 1378 (0) 1636 (0) 1673 (11) 
b15 940 (0) 945 (0) 940 (0) 946 (0) 964 (0) 967 (0) 1030 (0) 1174 (4) 
b17 2260 (0) 2260 (0) 2272 (0) 2294 (0) 2307 (0) 2335 (0) 2224 (0) 2364 (56) 
b18 3943 (0) 3964 (0) 3972 (0) 3927 (0) 3923 (0) 3943 (16) 3953 (39) 4266 (284) 
b19 4919 (0) 4921 (0) 4952 (0) 4977 (0) 4949 (19) 5079 (50) 5147 (94) 5442 (574) 
b20 1815 (0) 1812 (0) 1858 (0) 1835 (0) 1910 (0) 2003 (0) 2291 (0) 2248 (41) 
b21 1917 (0) 1923 (0) 1924 (0) 1929 (0) 2076 (0) 2344 (0) 2396 (0) 2252 (43) 
 
表九、預防不確定值之輸出響應選擇使用(+3 +1 0 -1)計數器 
對不確定值之實驗結果(含掃描鏈重排方法) 
CKT Percentage of unknown data in all output bits 10% 11% 12% 13% 14% Max% 
s13207 357 (0) 352 (0) 356 (0) 353 (0) 359 (0) 36 
s15850 275 (0) 276 (0) 276 (0) 283 (0) 279 (0) 35 
s35932 261 (0) 259 (0) 257 (0) 260 (0) 263 (0) 27 
s38417 331 (0) 335 (0) 337 (0) 343 (0) 335 (0) 30 
s38584 510 (0) 517 (0) 510 (0) 511 (0) 510 (0) 25 
b14 1145 (0) 1140 (0) 1150 (0) 1148 (0) 1158 (0) 28 
b15 715 (0) 721 (0) 737 (0) 744 (0) 737 (0) 30 
b17 1554 (0) 1563 (0) 1560 (0) 1536 (0) 1573 (0) 23 
 15 
附件一 
參加2010年亞洲測試會議報告 
 
出席者：  成功大學電機系 李昆忠教授 
 
會議名稱 :中文 : 2010亞洲測試會議 
          英文 : 2010 Asian Test Symposium 
 
時間 :    2010年12月1日~4日 
 
地點 :    中國 上海 
 
1. 參加會議經過： 
2010年亞洲測試會議 (Asian Test Symposium, ATS) 於12月1~4日在中國上
海之Sheraton飯店舉行，參加的人員來自世界十餘個國家及地區，除亞洲的日本、
台灣、中國大陸、香港及印度外，尚有來自歐美國家的學者及業界人士參與，故其
規模已不侷限於亞洲，為亞洲VLSI測試界的一大盛事。 
本人今年參加此會議主要任務有二，第一為參加ATS之指導委員會議，今年主
要議題為往後幾屆會議地點之選擇及指導委員之更動，其中確定2011, 2012, 2013
年之ATS分別將由印度、日本及台灣主辦，另外本人亦被選為ATS指導委員會之Vice 
Chair。第二項任務則在發表一篇論文並與與會人士進行交流。 
今年會議主要內容為2場主題演講(keynote speech)、3場邀請演講(invited 
speech) 及3座談會(panel discussion)及24場technical sessions。 
第一場 Keynote Speech 邀請美國 Univ. of Texas at Austin 的Jacob 
Abraham 主講，題目為New Paths for Testing. 內容主要針對未來IC的發展趨勢
如IC內電晶體密度的更加提升、系統單晶片(SOC)因整合更多種類的電路而更加複
雜以及混合訊號電路在電子系統中的比例將逐漸提高，對IC測試將帶來的嚴重衝擊
進行探討。在Deep Submicron的製程技術下，defect 不將只以random的形式出現，
也可能更加parametric及systematic 而造成更多yield loss使晶片良率偏低。因
此發展可容忍defect或是on-chip repair的技術將為未來良率提昇研究的重要議
題之ㄧ。主講者也提出以軟體為主的測試方法(Software-Based Testing)將可更加
有效地偵測timing defects(如delay faults)，而此方法亦適用於系統單晶片設
計，可充分利用內嵌之微處理器完成測試流程。 
第二場 Keynote Speech 邀請美國Cadence Design Systems 的Dr. Sanjiv 
Taneja主講，題目為Consumerization of Electronics and Nanometer 
Technologies: Implication on Test. 內容主要為探討在未來晶片設計的低功
率、低成本等需求，以及奈米製程對晶片製造帶來的挑戰(更高的晶片複雜度、更
 17 
知亦有其他專家學者從事與自己研究方向近似之工作。跟與會人士之間的交談及討
論，可以進一步知道其他研究團隊之研究方向及趨勢所在。進而吸收他人研究優勢
的部份及改善自己的缺點。 
 
3. 攜回資料： 
攜回2010年亞洲測試會議論文集CD一片，內容包括此次會議所發表的所有論
文全文，有興趣者可向本人借閱。 
 19 
produce deterministic patterns. The circular BIST 
scheme [10-11] replaces each primary IO with a special 
BIST cell and connects them together with the internal 
scan chains to form a long circular self-test path. In this 
scheme both pattern generation and signature analysis 
can be done by the self-test path, and thus only small 
area overhead is needed. However if some states 
required to detect some faults cannot be reached by the 
self-test path, the fault coverage will degrade. The work 
in [12] addresses this problem by using a jumping logic 
for state transition such that the desired patterns can be 
generated effectively. Recently, the CircularScan 
method [13] modifies each scan chain to a circular scan 
chain and circularly shifts the captured response for 
each circular chain independently to construct the next 
pattern. In [14] the authors propose to connect some 
internal nets of the CUT to its inputs so as to provide 
the required logic values of the next pattern directly. By 
exploring the relation between the responses of internal 
nets and a pre-computed test set, this method can 
generate a series of deterministic patterns that are 
compatible with the pre-computed patterns. However, 
since the test set is pre-defined, it is difficult to identify 
a set of connections that can generate all required 
patterns. To get high enough fault coverage, different 
sets of connections, each with a special initial pattern, 
are required. Therefore the area overhead can be high 
and it still needs some storage to store the initial test 
pattern for each set of connections. 
In this paper, a mixed-mode BIST scheme requiring 
no any internal or external storage device is presented. 
This scheme first applies pseudo random testing to drop 
easy-to-detect faults and then generates deterministic 
patterns by utilizing the responses of internal nets 
(include outputs). Unlike the work in [14] which selects 
patterns from a given test set and tries to identify a set 
of internal nets to provide the required logic values, we 
propose an efficient algorithm to regenerate effective 
test patterns based on the current circuit response. Thus, 
we do not require any test data to initialize the internal 
state of the test pattern generator. Furthermore, an 
X-filling process is embedded in our algorithm to 
utilize the X-bits in each decided pattern so as to speed 
up the fault detection process. In the experimental 
results, we show that our method can achieve full fault 
coverage within 1000 cycles for all ISCAS 85 
benchmark circuits, which is significantly shorter than 
those of previous work that also requires no storage 
device [3][8][9]. The comparison with [14] also shows 
that we can use much lower area overhead and shorter 
test time to reach the same fault coverage. 
In the rest of this paper we first describe our BIST 
architecture in Section 2. The algorithm to generate all 
test patterns and associated hardware configurations are 
then detailed in Section 3. Experimental results are 
given in Section 4 where comparisons with previous 
work are also given. Finally, we conclude the paper in 
Section 5. 
2. BIST Architecture 
As shown in Figure 1, the proposed mixed-mode 
BIST architecture mainly consists of a test pattern 
generator (TPG) and an on-chip control unit. In the 
TPG, an LFSR is used to generate a set of pseudo 
random patterns to detect easy-to-detect faults. The 
other parts in the TPG are responsible for generating 
deterministic patterns by connecting some internal nets 
of the CUT to the LFSR so as to change the state of the 
LFSR. In this paper, we name the test methodology that 
generates the deterministic patterns by extracting the 
responses of internal nets as feedback testing (FT). 
During FT a set of feedback patterns to detect the 
hard-to-detect faults will be generated. In order to 
achieve complete fault coverage, we may need different 
sets of internal nets to provide all required test data. 
Each such set of internal nets will be called a 
configuration of the FT. As shown in the figure, the 
selection of configurations is through a multiplexer. 
When one configuration is employed, the internal nets 
associated with the configuration will feed their 
responses back to the LFSR to provide one new 
feedback pattern per cycle. In our scheme each 
configuration will provide a series of feedback patterns 
for the CUT. It should be pointed out that although 
more than one configuration may be required in order 
to achieve 100% fault coverage, our experimental 
results show that in general only a very small number 
of configurations is needed using our method. 
 
Figure 1: Proposed BIST architecture. 
The control unit shown in the left side of Figure 1 is 
employed to control the switching between pseudo 
random testing and feedback testing as well as to 
control the selection of different configurations. The 
control unit consists of a pattern counter and a 
combinational decoder. The pattern counter is used to 
indicate the current pattern index and the decoder will 
provide the desired switch signals according to the 
 21 
4 indicates that the 1st internal net will have a value of 1 
under the current test pattern, and the test data required 
at the 3rd and 5th input ports so far in the current 
configuration can all be provided by connecting the 1st 
internal net to them. Since CM63 = CM65 = 0, the 3rd and 
5th input ports can also be connected to the 6th internal 
net in this configuration, which means that no matter 
what values the 3rd and 5th input ports require for the 
next pattern, a valid connection always exists that can 
provide the required logic values. On the other hand, 
the entry CM32 = ‘-’ indicates that the 3rd internal net 
cannot be connected to the 2nd input port of the circuit 
under the current configuration.  
 
Figure 3: Test Generation and Configuration 
Determination Algorithm. 
   
Figure 4: An example of a configuration 
matrix. 
Now back to the algorithm in Figure 3. Before 
entering the while loop (line 7), we form the initial 
configuration matrix by performing a logic simulation 
(LSIM) with the last pattern tprev in BPT and setting 
each entry CMij as the response of the i-th internal net 
(line 6). In our algorithm, the first configuration will 
use the last pseudo random pattern as its initial pattern, 
and each of the following configurations will use the 
Algorithm Test Generation & Configuration Determination 
Input: polynomial P(X), fault list F, PRL and LZERO 
Output: a set of BIST patterns BPT and the information of 
each configuration 
1. Determine an initial pattern to perform pseudo random 
test for PRL cycles,  
2. Remove the last few pseudo random patterns that detect 
no faults and add all useful patterns into BPT. Drop all 
faults detected by pseudo random test from F 
3. if F = Φ then Exit 
4. zeroc ← 0, config ← 1, tprev ← the last pattern in BPT 
5. Generate a partially-specified test set PT for F 
6. Form the initial response matrix CM based on tprev 
7. while F ≠ Φ do 
8.  tc ← Valid cube identified from CM 
9.  tselect ← Pattern Selected from PT based on tc 
10.  if tselect = NULL then 
11.    tnext ← tc 
12.  else  
13.   tnext ← intersection of tc and tselect 
14.   Remove tselect from PT 
15.  if any X-bit exists in tnext then  
16.    Perform X-filling to refine tnext 
17.  Add tnext to BPT 
18.  if any faults are detected by tnext then 
19.   Drop all detected faults from F, zeroc ← 0 
20.  else zeroc ← zeroc + 1 
21.  if tnext = tprev or zeroc = LZERO then 
22.   Record the information of the current configuration 
23.    Remove the last zeroc patterns from BPT 
24.   tprev ← the last pattern in BPT 
25.    zeroc ← 0, config ← config + 1 
26.  Generate a partially-specified test set PT for F 
27.    Form a new CM based on tprev 
28.  else 
29.    tprev ← tnext 
30     Update CM based on t  
  
 23 
feedback pattern for cycle 4 is shown in Figure 6(b). 
The cube identification process will find tc as 
(XXXXX), and the pattern selection process will select 
PT1 (assuming PT1 detects the most number of 
undetected faults) and form tnext as (X101X). All X-bits 
in tnext will be filled by the two-stage X-filling. We then 
drop all detected faults and simulate the circuit with tnext 
= (11010). Assume the response of circuit is now 
(101010). After updating the CM as shown in the top of 
Figure 6(c), two more patterns (cycle 5 and cycle 6) are 
generated after the execution of the following two 
iterations. Assume that the patterns in cycles 5 and 6 
are the same as indicated. Then the first termination 
condition of a configuration is satisfied and thus we 
will need to start a new configuration. After deleting the 
pattern of cycle 6, a new test set PT will be generated 
and the response of the pattern of cycle 5 will be used 
to form a new CM as shown in Figure 6(d). By using 
the new CM, Figure 6(d) also shows that two more 
patterns will be identified (cycles 6 and 7). Assuming 
that after cycle 7 all faults are detected, the test 
generation procedure will then finish at this cycle. 
 
(a) Initialization 
 
(b) Iteration 1 
 
 (c) Iterations 2 to 3 
 
  
(d) Iterations 3 to 5 
Figure 6: An example of Test Generation and 
Configuration Determination Algorithm. 
4. Experimental Results 
In this section, we provide the experimental results of 
our BIST scheme on ISCAS 85 benchmark circuits and 
compare the results with those of related work. For all 
experiments, the input parameter LZERO is set to 50 
which is large enough to avoid wasting long time in 
applying useless test patterns for these circuits. To 
enlarge the solution space, not only the responses of 
internal nets but also their inversions are recorded in the 
configuration matrix. A commercial ATPG tool is 
employed to complete the X-filling process. All of our 
programs are implemented in C++ and executed on an 
IBM PC server. 
Table 1 shows the experimental results when 100% 
fault coverage (FC) is targeted. The first four columns 
show the circuit name (CKT), the number of input ports 
 25 
[8] C. Fagot, O. Gascuel, P. Girard and C. Landrault, “A 
Ring Architecture Strategy for BIST Test Pattern 
Generation,” Journal of Electronic Testing-Theory & 
Applications, Vol. 19, No. 3, pp. 223-231, June 2003. 
[9] E. Kalligeros, X. Kavousianos, D. Bakalis and D. 
Nikolos, “On-the-Fly Reseeding: A New Reseeding 
Technique for Test-Per-Clock BIST,” Journal of 
Electronic Testing-Theory & Applications, Vol. 18, No. 3, 
pp. 315-332, June 2002. 
[10] A. Krasniewski and S. Pilarski, “Circuilar self-test path: 
A low-cost BIST technique for VLSI circuits,” IEEE 
Trans. on Computer-Aided Design of Integrated Circuits 
and Systems, Vol.8, No. 1, pp. 46-55, Jan. 1989. 
[11] J. Carletta and C. Papachristou, "Structural constraints 
for circular self-test paths," in Proc. of VLSI Test 
Symposium, 1994, pp. 87-92. 
[12] W. Ke, H. Yu and X. Li, “Deterministic Circular Self Test 
Path,” Tsinghua Science and Technology, Vol. 12, No. S1, 
pp. 20-25, July 2007. 
[13] B. Arslan and A. Orailoglu, "CircularScan: a scan 
architecture for test cost reduction," in Proc. of Design, 
Automation and Test in Europe, 2004, pp.1290-1295. 
[14] K. Jishun, O. Xiong, and Y. Zhiqiang, "A Novel BIST 
Scheme Using Test Vectors Applied by 
Circuit-under-Test Itself," in Proc. of Asian Test 
Symposium, 2008, pp. 75-80. 
 27 
技術/產品應用範圍 
IC設計公司可將本技術整合至晶片的掃描式測試架構中，用以壓
縮輸出端測試資料並以此降低測試成本。 
技術移轉可行性及預期
效益 
本技術可解決大型積體電路測試時所引發的龐大輸出資料問題，
極具推廣之價值。 
     註：本項研發成果若尚未申請專利，請勿揭露可申請專利之主要內容。 
 
國科會補助計畫衍生研發成果推廣資料表 
日期：100年 10月 31日 
國科會補助計畫 
計畫名稱：輸出選擇響應壓縮技術之研發及應用 
計畫主持人： 李昆忠  成功大學電機系 教授 
計畫編號： NSC 97-2221-E-006-248  學門領域：EM 
研發成果名稱 
（中文）邏輯電路內建自我回授測試技術 
（英文）Logic Built-In Self-Feedback Test Technology 
成果歸屬機構 成功大學 
發明人 
(創作人) 
李昆忠 
技術說明 
（中文） 
此一電路自我測試技術利用電路內部接線數值產生完整測試所需
的所有測試向量，可在極短時間內達到 100%的錯誤涵蓋率，並且
儲存不需任何輸入端測試資料。 
 
（英文） 
The built-in self-test technique uses the logic value of internal nets in 
the circuit under test to generate all test patterns and achieve 100% 
fault coverage in a short period without any input test data storage. 
產業別 IC測試 
 29 
3. 請依學術成就、技術創新、社會影響等方面，評估研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）（以
500字為限） 
 
本計畫主要目的在提出一新穎、低成本且高效率之測試資料壓縮技術，以解
決輸出測試資料量過於龐大的問題。本計畫除完成原規劃之內容外，亦支援
另一未獲國科會補助之計畫，即如何增進 IC產品之良率之計畫，另本計畫亦
衍生一產學合作計畫，與台積電共同合作開發一先進製程之測試及診斷技
術，但因其涉及商業機密，故成果不能在此列出。本計畫共執行三年，目前
已產出 16 篇論文，包含已發表論文 11 篇，已投稿論文 2 篇，準備中論文 3
篇。與原規劃內容相關之主要成果如下: 
1. 已完成對輸出響應資料選擇之高效率演算法，實驗結果顯示此技術對於
大型電路僅需觀察不到 3%的輸出響應即可達到 100%錯誤覆蓋率。 
2. 可輕易解決傳統壓縮器所面臨的失真、 不確定值及不利錯誤診斷等問題 
3. 已分別提出以計數器以及累加器為基礎的硬體架構以將此技術實現在以
掃描鏈為基礎的電路上。實驗結果證實僅需不到 2%之額外面積。 
4. 結合所提出的不確定值避免技術，可成功解決含超過 14%不確定值的輸
出資料壓縮問題。 
5. 提出一使用電路內部接線的自我回授測試技術，並結合以旋轉為基礎之
自我回授測試硬體，使其所產生的測試向量不需任何儲存裝置即可在極短時
間內達到 100%的錯誤覆蓋率。 
 
整體而言，本計畫已完成所規劃之所有項目，並進一步支援其他未受補助之
計畫，更已衍生一產學合作計畫，成果相當豐碩。 
 
 
 
 
 
 
 2 
率、低成本等需求，以及奈米製程對晶片製造帶來的挑戰(更高的晶片複雜度、更
加複雜之defect形式)下，測試技術研發人員該如何因應。主講者提出的解決方案
為測試技術應與設計方法更加高度整合，從以前的”design for test”觀念進步
到”design with test”，以掌握到設計與測試技術間的緊密關係。相關的研究議
題包含Testing for Low-Power Designs、Yield Learning、Power-Aware ATPG、
Physical-Aware Compression、DfM-Aware test development等。 
第一場 invited speech 由美國Intel公司的Dr. T. M. Mak 主講，題目為
Testing of Power Constraint Computing. 內容主要為探討過去測試技術研究的
發展中鮮少討論到的功率消耗相關測試議題，包含power regulator、voltage 
accuracy、power ripples、current capability的測試以及real-workload 
testing。 
第二場 invited speech 由美國Synopsys公司的Dr. Tom W. Williams 主講，
題目為 EDA to the Rescue of the Silicon Roadmap。內容主要為探討在不同的
製程技術如130nm, 65 nm下，EDA tools如何因應設計、製造及測試上的不同挑戰
來幫助使用者有效率地實現晶片。EDA tools將可處理design for manufacturing 
and yield, design for low power及design for variability等議題，以保證設
計之品質。 
第三場 invited speech主講者為中國大陸SMIC公司的Kary Chien，題目為
Foundry Full-Scale Reliability Testing Capability Setup for Advanced 
Technology. 內容主要針對在產品的多樣化、縮短time-to-market並須保證產品
reliability的需求下，我們必須發展一flexible、fast-responsible, efficient 
full-scale的可靠性測試方法。此方法必須具備多項功能包含: technology 
development and qualification, process monitor以及reliability assessment 
of process issues。主講者亦介紹了多項目前可見可支援Full-Scale Reliability 
Testing之技術。 
大會之24埸technical paper sessions總共包含了79篇論文，分三個埸地同
時進行。筆者之論文題目為 “A Complete Logic BIST Technology with No Storage 
Requirement,”。在此論文中我們提出一完全不用儲存測試資料即可達到100%測試效
率之測試方法。此方法可大幅減低外部測試機台之需求，使得我們僅需一相當簡單
之測試儀器提供此平台一些必要控制訊號即可啟動自我測試功能並可達到完整且
極低成本之測試，因而可大幅降低系統單晶片之測試成本。在此論文中我們提出嶄
新的測試架構產生方法，亦提出實驗數據來佐證我們的技術。會後有許多學界及業
界的研究及設計人員均感興趣，並在報告過程中及Session 結束後與筆者進行意見
交流。 
 
2. 與會心得與建議： 
亞洲測試會議(ATS)一向是亞洲VLSI測試界重要的會議之一，它提供了從事相
關研究的人員一個互相觀摩與學習的場合。藉由參與會議之technical sessions，
 4 
 
A Complete Logic BIST Technology with No Storage Requirement 
 
 Wei-Cheng Lien and Kuen-Jong Lee 
Department of Electrical Engineering, National Cheng Kung University, Tainan, Taiwan 70101 
E-mail: kjlee@mail.ncku.edu.tw 
 
Abstract 
Mixed-mode BIST enhances test efficiency of digital 
circuits by combining the advantages of both pseudo- 
random and deterministic patterns. In order to apply 
the deterministic patterns, most traditional methods 
need to store some test data in external testers or 
on-chip memory. In this paper we present a novel 
mixed-mode BIST technique by which all deterministic 
patterns can be generated on chip in real time and thus 
requiring no storage device. By appropriately 
connecting some internal nets of the circuit under test 
to the inputs of the circuit, together with a set of 
pseudo-random patterns, this BIST scheme can reach 
full fault coverage in a very short time. Experimental 
results show that all irredundant stuck-at faults in each 
of the ISCAS85 benchmarks can be detected in less 
than 1000 test cycles with no storage space required. 
1. Introduction 
The traditional test methods using external test 
equipment have become cost-ineffective for VLSI 
circuits due to long test application time, limited I/O 
channels and expensive memory storages. One way to 
alleviate this problem is known as built-in self-test 
(BIST) which embeds some specific test infra-structure 
into the circuit-under-test (CUT) and thus can reduce 
the requirement of external testers. 
Pseudo-random testing based on linear feedback shift 
registers (LFSRs) is commonly used as the basis of 
BIST due to its simplicity and effectiveness. However a 
complex circuit often contains some hard-to-detect 
faults that are random-pattern resistant and thus a 
pseudo random test scheme usually requires long time 
to reach satisfactory fault coverage. To shorten the test 
application time, several methods have been proposed. 
The weighted random test method [1] applies single or 
multiple sets of weights to adjust the 0/1 probability of 
each input port so as to enhance the detectability of 
hard-to-detect faults. This method requires to store all 
weights in an on-chip ROM and thus may require large 
area overhead. To reduce the storage data volume, in [2] 
an iterative process is used to minimize the total 
number of weights. In each iteration, the process 
generates a test set that maximizes the number of X-bits 
such that by filling these X-bits carefully, the number of 
weights for each test set can be minimized and thus 
leading to small area overhead. In [3] the weighted 
random testing is combined with a shift-inversion 
mechanism which can invert scan shift data at some 
selected positions of scan paths. By on-chip generating 
control signals to select different positions for scan data 
inversion, it is shown that a single weight set is often 
enough to achieve full fault coverage. The single 
weight set does not need to be stored because it can be 
embedded into the LFSR logic. However, long test 
application time may be needed for a circuit containing 
many hard-to-detect faults. 
The mixed-mode BIST technique [1] takes 
advantages of both pseudo random and deterministic 
patterns to achieve the complete fault coverage in a 
short time. The main idea lies in first using an LFSR to 
generate a set of pseudo random patterns so as to drop 
the easy-to-detect faults and then applying deterministic 
patterns to detect the hard-to-detect faults. The 
deterministic patterns can be stored in external testers 
or on-chip ROM. For example, the so-called hybrid 
BIST technique [4] stores the deterministic patterns in 
external testers. Since the storage device in a tester is 
usually quite expensive, the volume of deterministic 
patterns should be minimized. Test data compression 
techniques [1] are thus often adopted to reduce the 
volume of test data. 
Storing deterministic patterns in on-chip ROM 
eliminates the need of tester memory and reduces the 
test equipment cost. However, the on-chip ROM may 
induce high area overhead and the ROM itself needs 
extra test techniques (such as memory BIST). To reduce 
the required ROM space, some reseeding techniques 
[5-6] have been proposed to compress the required test 
data into some small-size seeds, which can then be 
decompressed by an LFSR or similar logic during test 
application time. 
Another mixed-mode technique, namly mapping 
logic [7-9], uses additional logic to modify the outputs 
or internal states of the LFSR so as to translate some 
pseudo random patterns into deterministic ones. The 
bit-flipping technique [7] modifies the LFSR contents 
by inverting some LFSR output bits. In [8] a ring 
architecture is used to fix unwanted values at certain 
bits of pseudo random patterns by using some specific 
mask patterns. All mask patterns can be embedded to a 
mapping logic and thus no storage device is required. 
Rather than revising the outputs of the LFSR, the 
on-the-fly reseeding technique proposed in [9] inverts 
the logic values in some bits of the LFSR to modify its 
next state. These methods [7-9] may require large area 
overhead for the mapping logic if a large number of 
patterns need to be translated. 
Some techniques use the circuit responses to directly 
 6 
pattern index. In general the decoder is quite simple 
since the modes of the LFSR only switch once (from 
pseudo random test mode to feedback mode) and the 
number of configurations is quite small. Thus the area 
overhead of our BIST is mainly on the connection 
wires from the CUT to the MUX and the MUX itself, 
which highly depends on the total number of 
configurations that are required to achieve complete 
fault coverage. Next, we present an efficient algorithm 
which aims to minimize the total number of 
configurations without compromising the fault 
coverage. 
3. Test Generation and Configuration 
Determination Algorithm 
Figure 2 shows an overview of our test generation 
and configuration determination algorithm. The pseudo 
random patterns are first generated. If any faults are not 
detected after this procedure, a new configuration and a 
set of test patterns that can be generated by the 
configuration are determined. The configuration will be 
utilized until all faults are detected or it cannot detect 
more faults for a specified number of test cycles. The 
algorithm will terminate for the former case and will 
start another configuration for the latter case. 
 
  
Figure 2: Overview of the proposed algorithm. 
Figure 3 shows the pseudo-code of our algorithm. 
The algorithm outputs the information of each 
configuration and the set of patterns BPT that will be 
generated by the determined BIST architecture during 
test application time. Two user-defined input 
parameters, PRL and LZERO, are respectively used to 
limit the maximum number of pseudo random patterns 
and the maximum number of consecutive feedback 
patterns that do not detect any new fault. When 
executing pseudo random testing, the initial state of the 
LFSR is set to the pattern that detects the largest 
number of faults (based on a pre-determined 
fully-specified test set). According to the initial pattern 
and the LFSR polynomial P(X), a pseudo random test 
set containing PRL patterns is generated (line 1). The 
last few patterns of the test set will be removed if they 
do not detect any new fault. We then put all the 
remaining patterns into BPT and drop those faults 
detected by the test set from the fault list F (line 2). If 
all faults are detected, the procedure finishes (line 3), 
otherwise we will enter the feedback testing procedure. 
Two variables, zeroc and config, are used to record the 
number of consecutive feedback patterns that detect no 
new fault and the total number of configurations, 
respectively (line 4). Each new configuration will start 
with a test pattern denoted as tprev which is the last 
pattern in BPT. A partially-specified test set PT is 
generated for all the remaining faults in F (line 5). This 
set will be used to help determine the feedback patterns 
in the following process. 
In our algorithm, we build a special data structure, 
called a configuration matrix (CM), to keep track of 
two kinds of important information: the current 
response of all internal nets under the current test 
pattern, and the validity of the connections between the 
input ports and the internal nets under the current 
configuration. We use the example shown in Figure 4 to 
explain the concept of an CM. Each entry CMij can be 
at one of the three states ‘0’, ‘1’ or ‘-’, where i is an 
index of the internal nets and j is an index of the input 
ports. If an entry CMij is ‘0’ (‘1’), it means that the 
current response of the i-th internal net is ‘0’ (‘1’), and 
it is still valid to connect the i-th internal net to the j-th 
input port. If CMij has the state ‘-’, then it is invalid to 
connect the i-th internal net to the j-th input port in this 
configuration. For instance, CM13 = CM15 = 1 in Figure 
 8 
response of the last pattern of its preceding 
configuration as its initial pattern. Thus, our method 
needs no storage space. Also note that when a new 
configuration starts, all entries in the same row of the 
CM will have the same valid value, i.e., the value of the 
internal net corresponding to the row. 
In each iteration of the while loop, one feedback 
pattern will be determined by the following procedure. 
From all valid connections of CM, we determine a 
candidate cube tc which represents all input patterns 
that can be generated by the current configuration. For 
example, in Figure 4, tc is (00X0X) because any of 
(00000), (00100), (00001) and (00101) can be 
generated as the feedback pattern in the next cycle. 
Based on tc, we then execute a pattern selection 
process to select a pattern tselect from the pre-generated 
partially-specified test set PT that is compatible to tc  
(line 9). The compatibility makes sure that each 
specified input bit of tselect has at least one valid 
connection in the current configuration. If more than 
one pattern are compatible to tc, we select the pattern 
that is likely to detect the most number of undetected 
faults. If a compatible pattern tselect can be found, then 
we intersect tselect and tc bit by bit to form the next 
feedback pattern tnext and then remove tselect from PT. 
Otherwise we simply set tnext to be tc (lines 10-14). If 
tnext contains any X-bits, a two-stage X-filling is utilized 
to specify X-bits (lines 15-16). In the first stage of 
X-filling, a commercial ATPG tool is employed to fill 
the X-bits aiming to detect as many undetected faults as 
possible. If any X-bit still exists in tnext after this stage, 
the second stage will fill all remained X-bits in a way 
that the most number of valid connections in CM are 
retained. In the example of Figure 4, if tnext is (0000X) 
after the first filling stage, the 5-th bit of tnext will be 
specified as 1 in the second stage since it retains three 
valid connections CM15, CM35 and CM55 and only 
invalidates the entry CM65. After X-filling, the next 
feedback pattern is fully specified and added to BPT 
(line 17). If the refined tnext does not detect any new 
fault, zeroc is increased by one, otherwise all faults 
detected by tnext will be dropped from F and zeroc is 
reset to 0 (lines 18-20). 
The pattern generation of the current configuration 
will terminate if either of the following conditions 
occurs. The first one is when the next pattern tnext is the 
same as tprev, which means that the current 
configuration will repeatedly generate the same pattern, 
a phenomenon due to the structure correlation of the 
circuit that leads the circuit responses to a steady state 
[11]. The second one is when a number of 
consecutively generated feedback patterns do not detect 
any new faults. This condition is checked by comparing 
the value of zeroc and the pre-defined limit LZERO. 
When the second condition occurs, the last zeroc 
patterns of BPT will be removed to avoid wasting time 
on useless patterns.  
When either of the above conditions occurs, we 
record the information of the current configuration and 
start to work on a new configuration (lines 21-27). The 
last pattern in BPT will be used as the first tprev of the 
new configuration. We also reset zeroc and increment 
config. We then regenerate a new PT for all the 
remaining faults in F and form a new CM based on tprev 
and then start another iteration. If both conditions are 
not satisfied, then more test patterns can be generated 
by the current configuration and thus we replace tprev 
with tnext, update the current CM (line 29-30), and then 
enter the next iteration. There are two steps for 
updating CM. First, all invalid connections are pruned 
off according to tnext. Second, all valid connections are 
updated based on the responses after applying tnext. Use 
Figure 4 again as an example. Assume that tnext is 
(00001) and the response will become (110010) after 
applying tnext. Figure 5 shows the results of the two 
steps to update CM. At the left side of the figure, the 
step 1 will invalidate the entry CM13, CM33, CM53 and 
CM65 by setting them to ‘-’ since input 3 and input 5 
will require logic 0 and logic 1 respectively for the next 
pattern (00001). At the right side of the figure, the step 
2 updates the entries CM21, CM22 and CM24 to 1 and the 
entry CM35 to 0 because the current response of the 2nd 
and 3rd internal nets becomes 1 and 0, respectively.  
The while loop (lines 7-31) will be executed until all 
faults are detected. Next we use an example to illustrate 
our algorithm. 
 
Figure 5: An example to update a configuration matrix. 
Example: 
Assume the CUT has five input ports, six internal 
nets {W1, W2, …, W6} and the TPG contains an 
external LFSR with a primitive polynomial P(X) = 
1+X4+X5. We set PRL to 4 and LZERO to 2 in this 
example. Figure 6 show the procedure of our algorithm 
to deal with this circuit. The cycle number of each 
pattern indicates when the corresponding pattern is 
generated. 
Figure 6(a) first shows the generation of PRL pseudo 
random patterns to drop the easy-to-detect faults. Of the 
four patterns assume that the 4th one does not detect any 
fault and thus can be removed. We then generate a test 
set PT for the remaining faults and assume PT contains 
4 patterns {PT1, PT2, PT3 and PT4}. A logic 
simulation on the last pseudo-random pattern (cycle3, 
11100) is performed. Assume the response of the 
internal nets is (010100). The CM is initialized by this 
response as shown in the bottom right of Figure 6(a), 
which indicates that all connections are valid now. 
After initialization, the first iteration to decide the 
 10 
(#IN), the number of testable faults (#TF), and the 
number of ATPG patterns without BIST. The fifth 
column (PRL) shows the number of random patterns to 
be generated. The column #CF shows the number of 
configurations required to achieve 100% fault coverage 
in our BIST. It can be seen that the largest number of 
configurations is 5 while most circuits require 3 or less 
configurations. The data under column #Cycles show 
the numbers of required cycles of our method and those 
of previous work that also requires no storage device. In 
the subcolumn Ours we provide the number of used 
pseudo random test patterns (PRT), the number of 
feedback test patterns (FT) and the total test length for 
each circuit using our BIST. The results show that our 
method can achieve 100% fault coverage within 1000 
test cycles for all circuits.  
The other three subcolumns under #Cycles provide 
the required test cycles reported in [9], [8] and [3]. Both 
[9] and [8] employ the mapping logic method and [3] 
presents a weighted random test with shift-inversion 
mechanism. From the table it is clear that our method 
requires much less test time than these methods for all 
circuits. 
Table 1: Experimental results and comparisons with 
previous work when fault coverage = 100%. 
CKT #PI #TF #TP PRL #CF 
#Cycles 
Ours [9] [8] [3] PRT FT Total 
c432 36 523 47 279 0 279 0 279 - - 1024 
c499 41 750 54 300 1 293 5 298 - - 1024 
c880 60 942 35 300 1 266 12 278 980 1K 2048 
c1355 41 1566 86 600 1 585 10 595 1046 2K 4096 
c1908 33 1870 116 800 3 785 115 900 3327 4K 8192 
c2670 233 2630 59 300 5 285 58 343 1002 5K 6144 
c3540 50 3291 131 900 3 900 19 919 - 4.5K 32768 
c5315 178 5293 69 500 1 479 28 507 - - 4096 
c6288 32 7710 23 100 0 40 0 40 - - 1024 
c7552 207 7419 105 500 5 496 241 737 3958 8K 32768 
 
Table 2 compares our results with the recent work 
[14] which also generates patterns by feeding the 
responses of circuit back to its inputs. For fair 
comparisons, we target the same fault coverage as those 
reported in [14] which are shown in the second column 
of the table. It can be seen that our BIST can achieve the 
same fault coverage with much less numbers of 
configurations within comparable test application time. 
It is also worth to point out that different from [14] 
which still needs some storage device to store the initial 
pattern for each configuration, our method requires 
absolutely no storage device. 
 
Table 2: Comparisons with [14] under the same 
fault coverage. 
CKT Target FC % 
#CF #Cycles 
Ours [14] Ours [14] 
c432 99.81 0 3 279 99 
c499 100 1 3 298 315 
c880 100 1 2 278 234 
c1355 97.84 0 3 542 520 
c1908 98.50 1 3 798 691 
c2670 99.20 3 3 322 842 
c3540 99.60 1 3 907 786 
c5315 99.91 1 2 487 587 
c6288 100 0 1 40 35 
c7552 99.00 2 3 634 849 
Total  4585 4958 
 
5. Conclusions 
This paper proposes a novel mixed-mode BIST that 
can reach complete stuck-at fault coverage in a short 
time without using any storage device. The proposed 
BIST applies pseudo random testing to detect the 
easy-to-detect faults first and then using a test method 
called feedback testing to detect hard-to-detect faults. 
An efficient algorithm to concurrently determine the test 
patterns and the feedback connections is provided 
which results in very short test time and very small area 
overhead as compared to previous work. To the best of 
our knowledge, this is the first BIST work that can 
detect all irredundant faults in each of the ISCAS 85 
circuits within 1000 cycles without requiring external or 
on-chip storage to store test data. 
One problem that deserves further investigation is 
that although the number of configurations is small, the 
connections from the internal nets to the circuit outputs 
still require large routing area. We are currently 
exploring the possibility to reduce and share these 
connections among the internal nets and the input ports 
of the circuit such that the area overhead can be 
minimized. 
Acknowledgement: This work was supported in part 
by the National Science Council of Taiwan under 
contract number NSC 97-2221-E-006-248-MY3. 
References 
[1] L.-T. Wang, C.-W. Wu, and X. Wen, VLSI Test Principles 
and Architectures: Design for Testability, Morgan 
Kaufmann, 2006. 
[2] B. Reeb and H. J. Wunderlich, "Deterministic pattern 
generation for weighted random pattern testing," in Proc. 
European Design and Test Conference, 1996, pp. 30-36. 
[3] L. Lai, J. H. Patel, T. Rinderknecht and W.-T. Cheng, 
“Logic BIST with Scan Chain Segmentation,” in Proc. of 
International Test Conference, 2004, pp.57-66. 
[4] L. Li and K. Chakrabarty, “Hybrid BIST Based on 
Repeating Sequences and Cluster Analysis,” in Proc. of 
Design, Automation and Test in Europe, 2005, 
pp.1142-1147. 
[5] Z. Wang, H. Fang, K. Chakrabarty and M. 
Bienek,”Deviation-Based LFSR Reseeding for Test-Data 
Compression,” IEEE Trans. on Computer-Aided Design 
of Integrated Circuits and Systems, Vol. 28, No. 2, pp. 
259-271, Feb. 2009. 
[6] A. Jutman, A. Tsertov and R. Ubar, “Calculation of LFSR 
Seed and Polynomial Pair for BIST Applications,” in 
Proc. of Design and Diagnostics of Electronic Circuits 
and Systems Workshop, 2008, pp.1-4. 
[7] V. Gherman, H. J. Wunderlich, H. Vranken, F. Hapke, M. 
Wittke and M. Garbers, "Efficient pattern mapping for 
deterministic logic BIST," in Proc. of International Test 
Conference, 2004, pp. 48-56. 
 12 
 
 
國科會補助計畫衍生研發成果推廣資料表 
日期：100年 10月 31日 
國科會補助計畫 
計畫名稱：輸出選擇響應壓縮技術之研發及應用 
計畫主持人： 李昆忠  成功大學電機系 教授 
計畫編號： NSC 97-2221-E-006-248  學門領域：EM 
研發成果名稱 
（中文）以計數器為基礎之輸出選擇硬體架構 
（英文）Counter-Based Output Selection for Test Response 
Compaction 
成果歸屬機構 成功大學 
發明人 
(創作人) 
李昆忠 
技術說明 
（中文） 
此一輸出響應選擇壓縮技術利用計數器壓縮輸出端測試資料，此
技術不僅有高壓縮率且僅需極低的面積負擔，且具有零失真，可
容忍極高的不確定值，並具有極佳之錯誤診斷能力。實驗結果以
觀察單一壓縮輸出端)而言，平均只需觀察 9.84%與 8.19%的輸出
資料即可達到 100%的錯誤涵蓋率。當所允許觀察的壓縮輸出端數
目增加時，輸出響應觀察率會隨之上升，但測試時間可大幅縮減，
以一包含約 10萬個邏輯閘之電路而言，輸出響應觀察率上升
15.57-6.75=8.82%，但測試時間下降(4468-1289)/4468 = 71%。
由此結果可知，選取適當的壓縮輸出端數目能夠有效同時兼顧測
試時間與輸出響應壓縮的目的。 
（英文） 
The output selection response compaction utilizes one or more 
counters   for output test data. This technology not only has high 
compaction ratio but also requires small area overhead. Besides, it still 
ensures the zero-aliasing, high unknown-preventing ability and 
nearly-perfect diagnosibility. 
 
產業別 IC測試 
附件一 
 14 
技術/產品應用範圍 
IC設計公司可將本技術整合至晶片設計流程中，使電路能夠進行
自我測試並藉此降低測試成本。 
技術移轉可行性及預期
效益 
本技術可解決高複雜晶片的測試所造成龐大的測試向量問題，極
具推廣之價值。 
     註：本項研發成果若尚未申請專利，請勿揭露可申請專利之主要內容。 
 
 
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。 
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
□ 達成目標 
□ 未達成目標（請說明，以 100字為限） 
□ 實驗失敗 
□ 因故實驗中斷 
□ 其他原因 
說明： 
 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：□已發表 □未發表之文稿 □撰寫中 □無 
專利：□已獲得 □申請中 □無 
技轉：□已技轉 □洽談中 □無 
其他：（以 100字為限） 
 
 
附件二 
國科會補助計畫衍生研發成果推廣資料表
日期:2011/12/15
國科會補助計畫
計畫名稱: 輸出選擇響應壓縮技術之研發及應用
計畫主持人: 李昆忠
計畫編號: 97-2221-E-006-248-MY3 學門領域: 積體電路及系統設計 
研發成果名稱
(中文) 以計數器為基礎之輸出選擇硬體架構
(英文) Counter-Based Output Selection for Test Response 
成果歸屬機構
國立成功大學 發明人
(創作人)
李昆忠
技術說明
(中文) 此一輸出響應選擇壓縮技術利用計數器壓縮輸出端測試資料，此技術不僅有高壓
縮率且僅需極低的面積負擔，且具有零失真，可容忍極高的不確定值，並具有極
佳之錯誤診斷能力。實驗結果以觀察單一壓縮輸出端)而言，平均只需觀察9.84%
與8.19%的輸出資料即可達到100%的錯誤涵蓋率。當所允許觀察的壓縮輸出端數
目增加時，輸出響應觀察率會隨之上升，但測試時間可大幅縮減，以一包含約10
萬個邏輯閘之電路而言，輸出響應觀察率上升15.57-6.75=8.82%，但測試時間下
降(4468-1289)/4468 = 71%。由此結果可知，選取適當的壓縮輸出端數目能夠有
效同時兼顧測試時間與輸出響應壓縮的目的。
(英文) The output selection response compaction utilizes one or more counters for output test 
data. This technology not only has high compaction ratio but also requires small area 
overhead. Besides, it still ensures the zero-aliasing, high unknown-preventing ability and 
nearly-perfect diagnosibility.
產業別 研究發展服務業
技術/產品應用範圍
IC設計公司可將本技術整合至晶片的掃描式測試架構中，用以壓縮輸出端測試資料並以
此降低測試成本。
技術移轉可行性及
預期效益
本技術可大幅降低大型積體電路測試時所需紀錄之輸出資料，極具推廣之價值。
註：本項研發成果若尚未申請專利，請勿揭露可申請專利之主要內容。
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
