 2 
中文摘要 
一般的公開金鑰密碼系統中，使用者 U 擁有一對公開金鑰 PKU與密鑰 SKU，擁有
SKU就等於擁有使用者 U 的身份，就能代替 U 執行相對的密碼工作，因此如何保護 SKU
是一個重要的研究課題。將 SKU 以金鑰分享的技術分給 n 個參與者，不但是不錯的保
護技術，也使系統具有容錯性。 
本計畫的主要目的是研究當 n 很大時如何有效率地產生金鑰持份。Canny 和 Sorkin
的基於 DL 的大規模產生金鑰持份方法相當創新，但也有一些缺點，我們希望研究改進
其缺點，提出新的分散式金鑰持份產生方法及新的證明方法。最後我們希望將系統實出
來，做實際的應用。 
在計畫執行的期間我們完成協定的設計與分析，並已寫成論文發表在國際會議
上。我們也完成系統實作與實驗分析，結果符合我們的理論預期。 
關鍵詞：分散式門金鑰產生、隨機技巧、安全證明。 
英文摘要 
In a public-key cryptosystem, each user U has a pair of public key PKU and private key 
SKU. As long as one possesses the private key SKU, he owns the identity of U and can carry 
on the cryptographic tasks that are associated with SKU. Therefore, it is very important to 
protect SKU fro from leakage. One way of protecting SKU is to share SKU to n participants 
such that each participant gets a share and a number of them over a threshold can recover 
SKU. The distributed key generation is that all participants together generate their own 
secret shares by exchanging messages via an open network.  
In the previously proposed schemes, due to real-world limitation and practical 
consideration, the number n of participants cannot be very large. In 2005, Canny and Sorkin 
proposed a practical DL-based distributed key generation method for large-scale n. The 
communication cost of their scheme is much less than the previous ones. They use the 
random walk technique to analyze the threshold of the proposed scheme. Nevertheless, it is 
still possible to improve their scheme. 
In this project we proposed a practical DL-based distributed key generation scheme with 
more flexibility and better efficiency. We did some experiments for our proposed scheme 
and analyzed the simulated results. The results show that the real implementation matches 
with our analytical results. 
一、 計畫緣起及目的 
一般的公開金鑰密碼系統中，使用者 U 擁有一對公開金鑰 PKU與密鑰 SKU，擁有
 4 
本計畫（NSC 94-2213-E-009-110, NSC 95-2213-E-009-031）完成以下成果： 
1. 完成論文『Efficient large scale distributed key generation against burst interruption』，
發表在 Secrypt 07 的國際會議上（July 28-31, Barcelona, Spain, 2007），完整內容請
見附錄一。我們正在把這篇論文做些整理，準備投到期刊發表。 
   這篇論文主要的精神為利用機率方法來討論一個隨意的 bipartite graph G=(V, 
E)，結論是即使每個節點只有少數的邊，整個圖 G 也具有很高的 order。我們將 tn 
evaluation 矩陣 E 的每一列中任意 k 個 entry 設為非零的值，這相當是在一個 bipartite 
graph G=(U, V, E)中將少數邊加到 U 和 V 的節點上，形成一個 expander graph，再利
用機率方法來討論這樣的 E 矩陣的 order 為 t。最後我們以實驗的方式來驗證我們的
方法。 
實驗結果證實我們的方法具有較好的通訊量。 
2. 實作出整個系統，根據我們的理論，即使有很多的參與者無法參加重建金鑰的過程，
系統仍然可以成功。請見論文有關系統的模擬與描述。 
3. 我們也利用本計畫的經費完成論文，『Cheating prevention in visual cryptography』，
已被 IEEE Trans. Image Processing 接受。論文請見附錄二。 
三、 計畫成果自評 
在本計畫中，我們完成兩篇論文，一篇是國際會議論文，另一篇為國際期刊論文。
我們正將國際會議論文轉寫成期刊論文，將轉投國際著名期刊。計畫完成後，我們對大
規模分散式的金鑰產生有了徹底的瞭解，也實作了系統，不論理論與實務皆有不錯的成
果產出。以成果來看我們達成了本計畫的目標。 
參考文獻 
1. Noga Alon, V. D. Milman: Eigenvalues, Expanders and Superconcentrators (Extended Abstract). FOCS 1984: 
320-322, 1984. 
2. R. Canetti, “Security and composition of multiparty cryptographic protocols”, Journal of Cryptology 13(1), 
pp. 143-202, 2000. 
3. R. Canetti, R. Gennaro, S. Jarecki, H. Krawczyk, T. Rabin, "Adaptive security for threshold cryptosystems", 
Proceedings of Advances in Cryptology -- Crypto '99, Lecture Notes in Computer Science 1666, pp.98-115, 
Springer-Verlag, 1999. 
4. R. Canetti, S. Halevi, A. Herzberg, "Maintaining authenticated communication in the presence of break-ins”, 
Journal of Cryptology 13(1), pp.61-106, 2000. 
5. R. Gennaro, S. Jarecki, H. Krawczyk, T. Rabin. Secure Distributed Key Generation for Discrete-Log Based 
Cryptosystems. Eurocrypt ’99, pages 295-310, 1999. 
6. R. Canetti, E. Kushilevitz, R. Ostrovsky, A. Tosen, “Randomness versus fault-tolerance”, Journal of 
Cryptology 13(1), pp.107-142, 2000. 
7. J. Canny, S. Sorkin. Practical Large-scale Distributed Key Generation. In Proceedings of Advances in 
EFFICIENT LARGE-SCALE DISTRIBUTED KEY GENERATION
AGAINST BURST INTERRUPTION∗
Jheng-Ru Ou, Shi-Chun Tsai, Wen-Guey Tzeng
Dept. Computer Science, National Chiao Tung University, Taiwan
wgtzeng@cs.nctu.edu.tw
Keywords: Distributed key generation, secret sharing, cryptographic protocol.
Abstract: A distributed key generation scheme allows the key servers to distributively share a secret key and then com-
pute the corresponding public key. Canny and Sorkin (Canny and Sorkin, 2004) proposed a probabilistic
threshold distributed key generation scheme that is suitable for the case that the number of key servers is large.
The communication cost of their scheme is much less than that of previous schemes. Nevertheless, it is pos-
sible to improve their scheme in some aspects. In this paper we employ the randomness technique to cope
with some problems encountered by their scheme. Our contribution is twofold. Firstly, our scheme is secure
against a large cluster of dishonest key servers. Secondly, our scheme has better performance in some aspects.
We support this point by a series of simulation experiments. As a result, our scheme and Canny and Sorkin’s
scheme can be used in different situations.
1 INTRODUCTION
The security of a cryptographic scheme usually re-
lies on protecting a secret key. One way to protect
such a key is to distribute it to a set of key servers such
that each key server holds a key share. Key sharing
not only enhances key protection, but also provides
a robustness property for the secret key. For exam-
ple, in a threshold key sharing scheme, a set of key
servers over a threshold number can recover the se-
cret key. Even though some servers do not work, the
system works.
A distributed key generation scheme allows the
key servers to distributively share a secret key and
then compute the corresponding public key. In this
paper we focus on discrete logarithm-based thresh-
old distributed key generation schemes, in which the
secret key is x and the public key is y = gx mod
p. Almost all threshold distributed key genera-
tion schemes use secret sharing schemes as build-
ing blocks. Each key server runs a secret sharing
scheme to share its chosen secret to other key servers.
∗Supported in part by NSC projects 94-2213-E-009-110
and 95-2221-E-009-031, and Taiwan Information Security
Center at NCTU (TWISC@NCTU).
Shamir (Shamir, 1979) proposed the first threshold
secret sharing scheme based on polynomial interpo-
lation. Feldman (Feldman, 1987) added verification
of secret shares (verifiable secret sharing, VSS) to
Shamir’s scheme. Pedersen (Pedersen, 1991a) further
improved the scheme by making the secret shares un-
conditionally secure.
Based on his verifiable secret sharing scheme,
Pedersen (Pedersen, 1991b) proposed a threshold dis-
tributed key generation scheme with some important
properties that a threshold distributed key generation
scheme should have. Gennaro et al. (Gennaro et al.,
1999) found that an adversary can bias the distribu-
tion of the generated secret key by a subtle maneuver.
They then gave a formal definition and proposed a se-
cure scheme. Chu and Tzeng (Chu and Tzeng, 2002)
further pointed out that dishonest key servers should
not obtain valid key shares to avoid abuse. Canny and
Sorkin (Canny and Sorkin, 2004) proposed a prob-
abilistic threshold distributed key generation scheme
that is suitable for the case that the number n of in-
volved key servers is large, for example, in the level
of hundreds or thousands. The main merit of their
scheme is that the total number of communications
between key servers is greatly reduced from O(n2)
For A = {Si1 ,Si2 , . . . ,Sir}, let EA be the matrix
with the columns i1, i2, . . . , ir of E. For example,
E{S1,S3,S4} is a t × 3-dimensional matrix that has
columns 1, 3 and 4 of E. A set T of key servers from
H can recover the secret key x if and only if ET has
the full rank, i.e., rank(ET ) = t. We can solve x by se-
lecting t independent columns ET ′ from ET , T ′ ⊆ T ,
and compute
∑
i∈H
ai = (∑
i∈H
si)
T ′(ET
′
)−1. (1)
Since any t rows of E form a Vandermonde matrix,
these rows are independent and any t key servers can
recover the secret key x, which is the first entry of
∑i∈H ai. Any set of less than t key servers cannot
compute the secret key x. Thus, the above defines a
((t−1)/n,t/n,0)-PTDKG scheme.
One disadvantage of the above method is that each
key server Si has to communicate with each other key
server. The total number of communications between
the key servers is O(n2), which shall entail heavy net-
work overhead when n is large.
Distributed key generation schemes based on
Feldman’s and Pedersen’s verifiable secret sharing
schemes are similar except that the received shares of
each key server are verifiable (Feldman, 1987; Peder-
sen, 1991b).
2.2 Canny and Sorkin’s approach
The idea of Canny and Sorkin to reduce the commu-
nication cost is to make si very sparse by choosing an
appropriate E. For a zero entry si, j, the key server Si
need not send si, j to the key server S j. By this, the
communication cost from Si to S j is saved. If si is
very sparse, the communication cost from Si to other
key servers S j is much reduced.
Let E be a t × n-dimensional evaluation matrix
with a band of non-zero entries as follows, where ⋆
means a random number in Zq, which is non-zero
overwhelmingly:
E =


⋆ ⋆ ⋆ ⋆ 0 0 0 · · · 0 0 0
0 0 ⋆ ⋆ ⋆ ⋆ 0 · · · 0 0 0
0 0 0 0 ⋆ ⋆ ⋆ · · · 0 0 0
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0 0 0 0 0 0 0 · · · 0 0 0
0 0 0 0 0 0 0 · · · ⋆ 0 0
0 0 0 0 0 0 0 · · · ⋆ ⋆ ⋆


Let l be the width of the band and f be the offset of the
band between two consecutive rows. For example, the
above band matrix has l = 4 and f = 2. In the scheme,
a dealer chooses E and publishes it. Each key sever Si
chooses a t-dimensional block vector
ai =
[
0 · · · 0 ai, j ai, j+1 · · · ai, j+k−1 0 · · · 0
]
where j is a pre-determined index and k is the block
width. The vector si = aiE has only (k−1) f + l non-
zero entries. The key server Si need send non-zero
share si, j to the key servers S j. With fixed t and n, we
can make (k−1) f + l small by tuning parameters k, l
and f .
Canny and Sorkin’s PTDKG (called CS-PTDKG
hereafter) scheme is (1/ f − ε,1/ f + ε,δ), for some
small ε and δ, 0 < ε,δ < 1. Overall, their method
needs n((k−1) f + l)) node-to-node communications,
while most previous methods need n(n− 1) node-to-
node communications. They suggest that l = O(logn)
and k = l/(2ε2). This saves quite a lot of communi-
cations between key servers overall when n is large.
We note that E and ai is very regular and this reg-
ularity makes the system vulnerable to burst interrup-
tion. For example, if a burst interruption keeps l con-
secutive key servers from participating the scheme,
the scheme does not work even though the number
n− l of alive key servers is much larger than βn =
(1/ f + ε)n.
3 OUR CONSTRUCTION
We employ the randomness technique to cope
with the problem of burst interruption. We choose
E and ai randomly such that it is more robust against
burst interruption. To see this, if l consecutive key
servers cannot participate, the rest key servers can
compute the secret key with high probability.
For each row of E, we randomly choose l entries
and assign random values in Zq to them. For example,
the following E has t = 3,n = 5, and l = 2:
E =

 0 1 0 0 53 0 2 0 0
0 4 0 3 0

 . (2)
Each key server Si,1≤ i≤ n, randomly chooses k en-
tries of ai and assigns random values in Zq to them.
We see that si = aiE has kl non-zero entries at most.
Although the number of non-zero entries is more than
(k − 1) f + l in the CS-PTDKG scheme if k and l
are the same. We shall show that our system needs
smaller k and l to achieve the same level of robust-
ness in simulation.
Before presenting our scheme, we need to discuss
some theoretical problems concerning the feasibility
of our construction. The framework is to consider
the probability that E′, which is obtained from E by
deleting some columns randomly, has the full rank.
If rank(E′) = t, the key shares of honest key servers
define the secret key uniquely.
Theorem 2 For appropriate positive intgers t, l,m
and n such that, for 3 ≤ j ≤ t,
j( j−1)
(t− j + 1)(n−m− j + 2)·
(
j−2 + m
j−1 + m)
( j−1)l(
n
j−1 + m)
l ≥ 1.
Let G = (U,V,E) be a left l-regular random bipar-
titate graph. After deteting random m vertices from
V, the probability that the remainded bipartite graph
has a perfect matching is 1−(n−m) t(t−1)22 (m+1n )2l at
least , where |U |= t, |V |= n and t ≤ n.
Proof 2 Let V ′ be the subset of V after deleting m ver-
tices, where |V ′|= n′ = n−m. An edge from a vertex
in U that hits a vertex in V −V ′ makes no contribution
to Hall’s lemma. For a subset S ⊆U of j vertices and
T ⊆ V ′ of j− 1 vertices, the probability that Hall’s
lemma does not hold on S to T is
(
j−1 + m
n
) jl.
Thus, the probability that there is a subset of S⊆U of
j vertices whose edges hit a subset of fewer than j−1
vertices in V ′ or V −V ′ is at most
p j =
(
t
j
)(
n−m
j−1
)
(
j−1 + m
n
) jl
Since
p j−1
p j
=
j( j−1)
(t− j + 1)(n−m− j + 2)·
(
j−2 + m
j−1 + m)
( j−1)l(
n
j−1 + m)
l ≥ 1,
we have
t
∑
j=2
p j ≤ (t−1)p2 =
t(t−1)2
2
(n−m)(
m+ 1
n
)2l ,
which is an upper bound for the proability that Hall’s
lemma fails.
3.1 Our distributed key generation
scheme
The structure of our scheme is based on Gennaro et
al.’s study on secure distributed key generation (Gen-
naro et al., 1999). Their scheme is secure against the
attack of skewing the secret key distribution by dis-
honest key servers. Note that the key shares of their
scheme are unconditionally secure.
At beginning, a dealer chooses a t×n-dimensional
evaluation matrix E and publishes it in a public bul-
letin board. Our distributed key generation scheme is
as follows:
Setup:
1. A dealer does:
(a) Select a large prime p = 2q+1, where q is also
prime.
(b) Compute generators g and h of Gq, where
Gq = {a2 | a∈ Z∗p} is the subgroup of quadratic
residues of Z∗p.
(c) Choose a t × n-dimensional evaluation matrix
E such that each row has l non-zero entries.
Key share establishment:
1. Each key server Si does the following:
(a) Select two t-dimensional vectors ai and a′i
which each consists of k non-zero random en-
tries. The non-zero entries are in the same in-
dexes of ai and a′i.
(b) Compute si = aiE, s′i = a′iE and the set of his
communication key servers Qi = { j | si, j 6= 0∨
s′i, j 6= 0}.
(c) Send si, j and s′i, j to key server S j via a secure
channel, j ∈ Qi.
(d) Broadcast Ci, j = gai, j ha
′
i, j mod p, 1 ≤ j ≤ t, to
all the key servers in Qi.
2. Each key server S j does the following:
(a) Check validity of the received shares, for each
i, j ∈ Qi,
gsi, j hs
′
i, j ≡
t
∏
k=1
CEk, ji,k (mod p). (3)
If the check fails for i, S j broadcasts a com-
plaint against Si to the key servers in Q j.
(b) If S j is complained by Si, it sends s j,i and s′j,i to
the key servers in Q j.
The other key servers in Q j check validity of
s j,i and s′j,i by Equation (3).
If S j fails the test, it is marked as ”dishonest”
by the key servers in Q j.
3. Each key server S j builds a set H of honest key
servers and sets his key share as
x j = ∑
i∈H, j∈Qi
si, j mod q,
which is the jth entry of (∑i∈H ai)E. Note that the
secret key is
x = (∑
i∈H
ai) ·~1,
where~1 = [1 1 · · · 1].
Public-key computation:
1. Each key server Si ∈H broadcasts Ai,k = gai,k mod
p, 1 ≤ k ≤ t, to the key servers in H.
 


	
 


























  







  





 




ﬀ
ﬁ
ﬂ
ﬃ
ﬃ

 
!
"
#
$
%
&'

()
* +


ﬀ



,
-
ﬀ
Figure 1: Probability of achieving the full rank for different
l, when f = 2
./012345
6667
.1849
66
6
5
6
:6
;6
<6
9
6
=6
>
6
?6
@6
5
66
@
5
:
59
;6 <6 <
9 9
6 =6
5
66
A
4
B
/C 3/3DEFG/ F38G
H
FI
J
K
L
LM
N
O
P
Q
R
S
TU
D
VW
X Y
/CCIF84
;Z
[
1GI
Figure 2: Probability of achieving the full rank for different
l, when f = 3
5 DISCUSSION
Our scheme and the CS-PTDKG scheme have dif-
ferent security parameters. For ours, α = 1/l′ − ε
and β = 1−m/n. For the CS-PTDKG scheme, α =
1/ f − ε and β = 1/ f + ε. These two set of param-
eters can be used for different situations. For exam-
ple, if the number of dishonest key server is relatively
small (about one in l′ key servers), our scheme is suit-
able. Since we are dealing with a large number of
key servers, a small percent of dishonest key servers
is very likely. Our β is adjustable under some con-
straints. If larger β is desirable, our scheme provides
such choice.
REFERENCES
Canny, J. and Sorkin, S. (2004). Practical large-scale dis-
tributed key generation. In Proceedings of Advances
in Cryptology - EUROCRYPT ’04, volume 3027 of
LNCS, pages 138–152. Springer-Verlag.
\]^_`abc
ddde
\_fbg
dd
d
c
d
hd
id
jd
g
d
kd
l
d
md
nd
c
dd
m n
c
h
cg
hd id ii i
g
jd
o
b
p
]q a]arstu] tafu
v
tw
x
y
z
z{
|
}
~




r

 
]qqwtfb
j

_uw
Figure 3: Probability of achieving the full rank for different
l, when f = 4
Chu, C.-K. and Tzeng, W.-G. (2002). Distributed key gener-
ation as a component of an integrated protocol. In Pro-
ceedings of the 4th Information and Communications
Security - ICICS ’02, volume 2513 of LNCS, pages
411–421. Springer-Verlag.
Feldman, P. (1987). A practical scheme for non-interactive
verifiable secret sharing. In 28th Annual Symposium
on Foundations of Computer Science (FOCS), pages
427–437. IEEE.
Gennaro, R., Jarecki, S., Krawczyk, H., and Rabin, T.
(1999). Secure distributed key generation for discrete-
log based cryptosystems. In Proceedings of Advances
in Cryptology - EUROCRYPT ’99, volume 1592 of
LNCS, pages 295–310. Springer-Verlag.
Pedersen, T. P. (1991a). Non-interactive and information-
theoretic secure verifiable secret sharing. In Proceed-
ings of Advances in Cryptology - CRYPTO ’91, vol-
ume 576 of LNCS, pages 129–140. Springer-Verlag.
Pedersen, T. P. (1991b). A threshold cryptosystem without a
trusted party. In Proceedings of Advances in Cryptol-
ogy - EUROCRYPT ’91, volume 547 of LNCS, pages
522–526. Springer-Verlag.
Shamir, A. (1979). How to share a secret. Communications
of the ACM, 22(11):612–613.
an employee or a secret agent recovers an urgent secret at some place where no electronic
devices are available. In these situations the human visual system is one of the most
convenient and reliable tools to do checking and secret recovery. Therefore, Naor and
Shamir [19] invented the Visual Cryptography (VC) in which a secret image (printed text,
picture, etc) is encrypted in a perfectly secure way such that the secret can be decoded
directly by the human visual system.
VC is a method of encrypting a secret image into shares such that stacking a sufficient
number of shares reveals the secret image. Shares are usually presented in transparen-
cies. Each participant holds a transparency (share). Unlike conventional cryptographic
methods, VC needs no complicated computation for recovering the secret. The act of de-
cryption is to stack shares and view the image that appears on the stacked shares simply.
A (k, n)-visual cryptography scheme (denoted as (k, n)-VCS) is a visual secret sharing
scheme such that stacking any k or more shares reveals the secret image, but stacking
fewer than k shares reveals not any information about the secret image.
VC has been studied intensively since the pioneer work of Noar and Shamir [19].
Most of the previous research work on VC focused on improving two parameters: pixel
expansion and contrast [5, 6, 8, 11, 13, 16, 23]. In these cases, all participants who hold
shares are assumed to be semi-honest, that is, they won’t present false or fake shares
during the phase of recovering the secret image. Thus, the image shown on the stacking
of shares is considered as the real secret image. Nevertheless, cryptography is supposed
to guarantee security even under the attack of malicious adversaries who may deviate
from the scheme in any way. We have seen that it is possible to cheat [12, 14, 18, 26] in
VC, though it seems hard to imagine. For cheating, a cheater presents some fake shares
such that the stacking of fake and genuine shares together reveals a fake image. With the
property of unconditional security, VC is suitable for sending to highly-classified orders
to a secret agent when computing devices may not be available. The secret agent carried
some shares, each with a pre-determined order, when departing to the hostile country.
When the headquarter decides to execute a specific order, it can simply send another
2
improvable.
3. We propose some necessary criteria for a VCS to be secure against cheating robustly.
By these criteria, we propose a generic method that converts any VCS to another
VCS with the property of cheating prevention. Our conversion is very efficient and
incurs little overhead compared with the original VCS. The degression in contrast
of the converted VCS is almost optimal. For each pixel of the secret image, we add
two additional subpixels to the encoded subpixels only, no matter how many the
encoded subpixels are.
The rest of this paper is organized as follows. The models for VCS, EVCS and cheating
behaviors in VC are discussed in Section 2. We then describe three cheating methods, each
with its distinct cheating behavior in Section 3. In Section 4, we survey some previous
cheat-preventing schemes and show how to attack and improve them. Finally, We present
an efficient and generic transformation from any VCS to a cheat-preventing VCS that is
measurably better than all previous schemes in Section 5.
1.2 Previous Work
Naor and Shamir [19] proposed a (k, n)-VCS. Many improvements and extensions fol-
lows [1, 2, 3, 5, 6, 8, 10, 11, 13, 15, 16, 17, 22, 23, 24, 25]. For example, Ateniese,
et al. [1] proposed an elegant VCS for general access structures based on the cumulative
array method. Tzeng and Hu [22] proposed a new definition for VC, in which the secret
image can be either darker or lighter than the background.
Naor and Pinkas [18] showed some methods of authentication and identification for
VC. Their scenario focuses on authentication and identification between two participants.
Yang and Laih [26] proposed two cheat-preventing methods. Their first method needs an
on-line TA (Trusted Authority) to verify the shares of participants. Their second method
is a transformation from a VCS (but not a (2, n)-VCS) to a cheat-preventing VCS on
which the stacking of two shares reveals the verification image. The method needs to add
extra O(n2) subpixels for each pixel in the secret image.
4
realization of the VC construction, we do not construct C0 and C1 directly. Instead, we
construct two n ×m basis matrices S0 and S1 and then let C0 and C1 be the set of all
matrices obtained by permuting columns of S0 and S1, respectively.
Let OR(B,X) be the vector of ”bitwise-OR” of rows i1, i2, . . . , iq of B, where B is
an n ×m Boolean matrix and X = {Pi1 , Pi2 , . . . , Piq} is a set of participants. Let w(v)
be the Hamming weight of row vector v. For brevity, we let w(B,X) = w(OR(B,X)).
Let pb(S) = w(v)/m, where v is a black pixel in share S and m is the dimension of v.
Similarly, pw(S) = w(v)/m, where v is a white pixel in share S. Note that all white (or
black) pixels in a share have the same Hamming weight. We use ”Si+Sj” to denote ”the
stacking of shares Si and Sj”. The ”stacking” corresponds to the bitwise-OR operation
”+” of subpixels in shares Si and Sj .
The definition of VC [1] for an access structure is as follows.
Definition 2.1. Let Γ = (P, Q, F ) be an access structure. Two collections (multisets) C0
and C1 of n×m Boolean matrices constitute a (Γ,m)-VCS if there exist a value α(m) > 0
and a set {(X, tX)}X∈Q satisfying:
1. Any qualified set X = {Pi1 , Pi2 , . . . , Piq} ∈ Q can recover the secret image by stacking
their shares. Formally, for any M ∈ C0, w(M,X) ≤ tX − α(m) ×m; whereas, for
any M ′ ∈ C1, w(M ′, X) ≥ tX .
2. Any forbidden set Y = {Pi1 , Pi2 , ..., Piq} ∈ F has no information on the secret image.
Formally, the two collections Ct, t ∈ {0, 1}, of q×m matrices obtained by restricting
each n×m matrix in M ∈ Ct to rows i1, i2, ..., iq, are indistinguishable in the sense
that they contain the same matrices with the same frequencies.
The value m is called pixel expansion, which is the number of subpixels that each pixel
of the secret image is encoded into in each share. The value α(m) ≥ 0 is called contrast.
The higher the contrast is, the more visible by human eyes the secret image is. The first
property (contrast) ensures that the recovered image shows difference between the white
pixels and the black pixels. The second property (security) ensures that nothing about
6
S1 S2 S3
S1  + S3 S1 + S2 S2 + S3
Figure 2: A (Γ, 4)-EVCS.
2.2 Cheating in VC
There are two types of cheaters in our scenario. One is a malicious participant (MP) who
is also a legitimate participant, namely, MP ∈ P, and the other is a malicious outsider
(MO), where MO /∈ P. In this paper, we show that not only an MP can cheat, but also
an MO can cheat under some circumstances.
A cheating process against a VCS consists of the following two phases.
1. Fake share construction phase: the cheater generates the fake shares.
2. Image reconstruction phase: the fake image appears on the stacking of genuine shares
and fake shares.
In order to cheat successfully, honest participants who poll their shares for recovering
the secret image should not be able to distinguish fake shares from genuine shares. A
reconstructed image is perfect black if the subpixels associated to a black pixel of the secret
image are all black. Most proposed VC schemes have the property of perfect blackness.
For example, the reconstructed secret images S in Example 2.1 are all perfect black.
We only consider to cheat the participants who together do not constitute a qualified
set. Since all participants together in a qualified set can recover the real secret image in
perfect blackness already, it is not possible to cheat them.
Example 2.3. Figure 3 shows how to cheat participants in a (2, 2)-VCS. Since S1 + FS
reveals the fake image FI, P1 is cheated to believe that the secret image is FI. Although
8
Input: share S1. (Wlog, we assume that the cheater is P1)
Fake share construction phase:
Assume that each pixel of S1 has x black and y white subpixels.
Then, P1 chooses a fake image and prepares r = dmx e − 1 fake shares
FS1, FS2, . . . , FSr as follows:
1. For each white pixel of the fake image, copy the corresponding
subpixels of the pixel in S1 to each fake share.
2. For each black pixel of the fake image, randomly assign x black
and y white subpixels to each fake share such that the pixel in the
stacking of these fake shares and S1 is perfect black.
Image reconstruction phase (the fake image):
Let Y = {P1, Pi1 , Pi2 , . . . , Piq} be a set of participants. If Y /∈
Q, the stacking of genuine shares S1, Si1 , Si2 , . . . , Siq and fake shares
FS1, FS2, . . . , FSr shall reveal the fake image.
Figure 4: Cheating method CA-1, initiated by an MP.
3.1 Cheating a VCS by an MP
The cheating method CA-1, depicted in Figure 4, applies to attack any VCS. Without
loss of generality, we assume that P1 is the cheater. Since the cheater is anMP, he uses his
genuine share as a template to construct a set of fake shares which are indistinguishable
from its genuine share. The stacking of these fake shares and S1 reveals the fake image
of perfect blackness. We see that, for Y = {P1, Pi1 , Pi2 , . . . , Piq} /∈ Q the stacking of their
shares reveals no images. Thus, the stacking of their shares and the fake shares reveals
the fake image due to perfect blackness of the fake image.
Example 3.1. Figure 5 shows how to cheat the participants in a (4, 4)-VCS. There are
four shares S1, S2, S3 and S4 in the (4, 4)-VCS. P1 is assumed to be the MP. By CA-1,
one fake share FS1 is generated. Since Y = (P1, P3, P4) (or (P1, P2)) /∈ Q, we see that
10
Input: none.
Fake share construction phase:
The MO chooses a fake image and does the following:
1. Encode the fake image into two fake shares FS1 and FS2 with the
optimal (2, 2)-VCS.
2. Generate enough pairs of fake shares FS1,i and FS2,i with various
sizes and subpixel distributions, 1 ≤ i ≤ r for some r.
Image reconstruction phase (the fake image):
Let Y = {Pi1 , Pi2 , . . . , Piq} /∈ Q. The stacking of Si1 , Si2 , . . . , Siq and two
fake shares FS1,c and FS2,c shows the fake image for some c, 1 ≤ c ≤ r.
Figure 6: Cheating method CA-2, initiated by an MO.
(2, 2)-VCS to construct the fake shares for the fake image. Then, we tune the size of fake
shares so that they can be stacked with genuine shares.
Now, the only problem is to have the right share size for the fake shares. Our solution
is to try all possible share sizes. In case that the MO gets one genuine share, there will
be no such problem. It may seem difficult to have fake shares of the same size as that of
the genuine shares. We give a reason to show the possibility. The shares of a VCS are
usually printed in transparencies. We assume that this is done by a standard printer or
copier which accepts only a few standard sizes, such as A4, A3, etc. Therefore, the size
of genuine shares is a fraction, such as 1/4, of a standard size. We can simply have the
fake shares of these sizes. Furthermore, it was suggested to have a solid frame to align
shares [19] in order to solve the alignment problem during the image reconstruction phase.
TheMO can simply choose the size of the solid frame for the fake shares. Therefore, it is
possible for the MO to have the right size for the fake shares.
Example 3.2. Figure 7 shows that an MO cheats a (4, 4)-VCS. The four genuine shares
S1, S2, S3, and S4 are those in Figure 5 and the two fake shares are FS1 and FS2. For
12
Input: share S1. (Wlog, we assume that the cheater is P1.)
Fake share construction phase:
P1 chooses a fake image and does the following:
1. Create S′1, which is S1, but without the share image. The share
image of S1 is removed by changing d black subpixels into white
subpixels in each black pixel, where d is the difference between the
numbers of black subpixels of a black and a white pixel.
2. Create r = dmx e − 1 temporary fake shares FS′i, 1 ≤ i ≤ r, by
using S′1 according to CA-1.
3. Randomly change d white subpixels into black subpixels of each
pixel of the share image in FS′i, 1 ≤ i ≤ r.
4. Construct FSi by randomly adding ²m black subpixels (changing
from white subpixels) to each pixel in FS′i, 1 ≤ i ≤ r. The thresh-
old value ²m, like those in Table 1, is obtained by experiments.
Image reconstruction phase (the fake image):
Same as in CA-1.
Figure 8: Cheating method CA-3 against an EVCS
3.3 Cheating an EVCS by an MP
In the definition of VC, it only requires the contrast be non-zero. Nevertheless, we observe
that if the contrast is too small, it is hard to ”see” the image. Based upon this observation,
we demonstrate the third cheating method CA-3, depicted in Figure 8, against an EVCS.
The idea of CA-3 is to use the fake shares to reduce the contrast between the share
images and the background. Simultaneously, the fake image in the stacking of fake shares
has enough contrast against the background since the fake image is recovered in perfect
blackness.
14
               
            S1                                  S2                                     S3
               
           FS2                               S1+S2                            S1+S3
               
          S2+S3                          S1+S2+S3                      FS2+S1+ S3
Figure 10: An example of cheating a (Γ,m)-EVCS.
Theorem 3.3. The MP in CA-3 successfully cheats an EVCS by producing fake shares
with meaningful share images if the ² is correct.
Proof. By Step 3 in CA-3, the share image appears on the fake share.
Contrast. Since the fake shares are constructed by the same way ofCA-1, the recovered
fake image in perfect blackness appears on the stacking of shares. Furthermore, the share
images of the fake shares are invisible since we have added an enough number of black
subpixels to blur them.
Indistinguishability. The proof is the same as that of Theorem 3.1 except that we
have to show that honest participants cannot identify fake shares. Since share images
are used for identification, honest participants will not know the exact shapes of share
images. They care only about the content of share images. Therefore, the cheater who
is a legitimate participant can create reasonable share images on fake shares according to
his own share to cheat other participants.
16
generality, we assume that they are P1 and P2. P1 and P2 together constructs a fake share
FS such that FS + V S reveals the verification image and FS cheats other participants.
We see how the attack works.
1. FS + V S reveals the verification image. The reason is that the first two subpixels
(before permutation) of FS and S1 are the same. The first two subpixels of FS+V S
are the same as those of S1+V S. Thus, the verification image appears on FS+V S.
The details are as follows.
For the white pixel of the verification image, the first two pairs of subpixels in S1
and S2 are (1, 1) and (0, 0) by S00 and S01, the corresponding subpixels in FS are
the same as those in S1 by Step 2 in the fake share construction phase. Thus, the
pixel of FS+V S is white since S1+V S shows whiteness in the pixel. For the black
pixel of the verification image, the first two pairs of subpixels in S1 and S2 are (0, 0)
and (1, 1) by S10 and S11, the corresponding subpixels in FS are the same as those
in S1. Thus, the pixel of FS + V S is black since S1 + V S shows blackness in the
pixel.
2. For Y = {P1, P2, Pi1 , Pi2 , . . . , Piq) /∈ Q, S1 + FS + Si1 + Si2 + · · · + Siq reveals the
fake image. For the white pixel of the fake image, the pixel in FS is the same as
that in S1 by Step 1. Thus, the pixel in S1+FS is white. For the black pixel of the
fake image, the subpixels 1 and 0 of S1 is changed to 0 and 1 in FS (see Step 2).
Thus, the white pixel, containing subpixels
[· · · 1 · · · 0 · · · ] + [· · · 0 · · · 0 · · · ] = [· · · 1 · · · 0 · · · ],
of S1 + S2 is changed to a black pixel, containing subpixels
[· · · 1 · · · 0 · · · ] + [· · · 0 · · · 1 · · · ] = [· · · 1 · · · 1 · · · ],
in S1 + FS. Thus, the fake image appears on S1 + FS + Si1 + · · ·+ Siq .
3. FS are indistinguishable by other participants. For each pixel, the numbers of black
and white subpixels in the pixels of FS and S1 are the same since the only change
18
     S1                                    S2                                   S3                                    VS
       
    FS                                S1+VS                            S2+ VS                             S3+ VS
       
FS+ VS                        S1 +FS+S2                       S1 +FS+S3                       S1+S2+S3  
Figure 12: An example of cheating the cheat-preventing (3, 3)-VCS of Yang and Laih.
is to swap subpixels b and w in S1 to w and b in FS. Thus, FS and S1 look the
same and other participants cannot distinguish them.
Example 4.1. Figure 12 shows the results of cheating a (3, 3)-VCS of Yang and Laih.
We see that all shares including the fake share FS pass verification by revealing the correct
verification image V. Since S1 + FS + S3 reveals a fake image FI, P3 is cheated.
4.2 Attacks on Horng et al.’s cheat-preventing methods
In the first cheat-preventing method of Horng et al. [14], each participant Pi has a veri-
fication share Vi. The shares Si’s are generated as usual. Each Vi is divided into n − 1
regions Ri,j , 1 ≤ j ≤ n, j 6= i. Each region Ri,j of Vi is designated for verifying share Sj .
The region Ri,j of Vi + Sj shall reveal the verification image for Pi verifying the share Sj
of Pj . The verification image in Ri,j is constructed by a (2, 2)-VCS. Although the method
requires that the verification image be confidential, we show that it is still possible to
cheat.
Assume that P1 knows the regions of the verification share Vi. P1 generates a fake share
FS1 to cheat Pi as follows. The pixels of FS1 in the region Ri,1 are the same as those in
S1. The rest pixels of FS1 (outside the region Ri,1) are constructed by CA-1. As a result,
the correct verification image appears on the region Ri,1 of FS1 + Vi and Pi believes that
20
of the following four matrices respectively:
S00 =

1 0 1 0 . . . 1 1
1 0 1 1 . . . 1 1
1 1 1 0 . . . 1 1 S0
1 1 1 1 . . . 1 1
...
... . . . 1 0
1 1 1 1 . . . 1 0

, S01 =

1 0 1 0 . . . 1 1
1 0 1 1 . . . 1 1
1 1 1 0 . . . 1 1 S1
1 1 1 1 . . . 1 1
...
... . . . 1 0
1 1 1 1 . . . 1 0

,
S10 =

1 0 1 0 . . . 1 1
0 1 1 1 . . . 1 1
1 1 0 1 . . . 1 1 S0
1 1 1 1 . . . 1 1
...
... . . . 1 0
1 1 1 1 . . . 0 1

, S11 =

1 0 1 0 . . . 1 1
0 1 1 1 . . . 1 1
1 1 0 1 . . . 1 1 S1
1 1 1 1 . . . 1 1
...
... . . . 1 0
1 1 1 1 . . . 0 1

.
The pixel expansion of this construction is m′ = m + n(n − 1) and contrast is α(m′) =
(1 + (α(m) ×m))/m′, where α(m) is the contrast of the original VCS without cheating
prevention.
By our observation [22], what the human eyes care about is contrast, no matter whether
the image is darker or lighter than the background. Therefore, we gave a new definition
VCS2 for VC based on this observation and made improvements on some types of access
structures [22]. Our improvements are applicable to Yang and Laih’s cheat-preventing
method. It reduces the pixel expansion to m+n(n−1)/2. Moreover, since the verification
image can be made public to all participants, we can let the verification image appear on
the shares. By this, we can further reduce the pixel expansion to m+ n(n− 1)/4.
Our improvement is based on the following three theorems, which are proved in [22].
Theorem 4.1. [22] (Composition property) Let Γ1 = (P, Q1, F1) and Γ2 = (P, Q2, F2)
be two access structures. Assume that Q1 ∩Q2 = ∅. If there exist a (Γ1,m1)-VCS2 and a
(Γ2,m2)-VCS2, there exist a (Γ,m1 +m2)-VCS2, where Γ = (P, Q1 ∪Q2, F1 ∩ F2). VCS2
is a visual cryptography scheme based on the new definition proposed in [22].
22
S10 =

1 0 1 0 1 0 1 1 1 1 1 1
0 1 1 1 1 1 1 0 1 0 1 1
1 1 0 1 1 1 0 1 1 1 1 0 S0
1 1 1 1 0 1 1 1 0 1 0 1

,
S11 =

1 0 1 0 1 0 1 1 1 1 1 1
0 1 1 1 1 1 1 0 1 0 1 1
1 1 0 1 1 1 0 1 1 1 1 0 S1
1 1 1 1 0 1 1 1 0 1 0 1

.
We reduce the pixel expansion of the left appended matrices from 12 to 3 as follows:
S00 =

0 0 1
0 1 0
1 1 1 S0
1 0 0

, S01 =

0 0 1
0 1 0
1 1 1 S1
1 0 0

,
S10 =

0 1 1
1 0 1
0 0 0 S0
1 1 0

, S11 =

0 1 1
1 0 1
0 0 0 S1
1 1 0

.
Example 4.2. Figure 13 shows the results of the improved cheat-preventing (3, 3)-VCS2.
We see that the stacking of any two shares reveals the verification image V. S1+S3 reveals
the reversed verification image and S2 shows the verification image.
5 A generic transformation for cheating prevention
By the attacks and improvement in previous sections, we propose that an efficient and
robust cheat-preventing method should have the following properties.
1. It does not rely on the help of an on-line TA. Since VC emphasizes on easy decryption
with human eyes only, we should not have a TA to verify validity of shares.
24
It generates two shares for each participant. One is the secret share and the other is
the verification share. Let S0 and S1 be the n × m basis matrices of a (Γ,m)-VCS. At
first, we create two n× (m+ 2)-dimensional basis matrices T 0 and T 1. The transformed
(Γ,m+2)-VCS uses T 0 and T 1 as the basis matrices to generate shares for the participants
as usual. Then, for each participant Pi, it generates a verification share Vi for a chosen
verification image. For each white pixel in the verification image, it puts the pixel of
(m+2)-dimensional [1 0 0 · · · 0] to Vi (after corresponding permutation as for the share
Si). For each black pixel in the verification image, it puts the pixel of (m+2)-dimensional
[0 1 0 0 · · · 0] to Vi (after corresponding permutation as for the share Si). We see
that the verification image is encoded into the first two subpixels. If participant Pi wants
to verify the share Sj of participant Pj , he checks whether Vi + Sj shows his verification
image.
Example 5.1. Figure 15 shows a transformed (Γ,m+ 2)-VCS with cheating prevention,
where P = {P1, P2, P3} and Q = {(P1, P2), (P2, P3), (P1, P2, P3)}. The verification images
for participants P1, P2 and P3 are A, B and C, respectively. Note that the simple veri-
fication images are for demonstration only. By our proposed principle in Section 4.2, we
should use more complicated verification images.
Theorem 5.1. The algorithm in Figure 14 transforms any (Γ,m)-VCS to another (Γ,m′)-
VCS with cheating prevention, where m′ = m+ 2 and α(m′) = (α(m)×m+ 1)/m′.
Proof. Since the first two subpixels are all the same for all pixels in all shares of (Γ,m′)-
VCS, the secret image is not affected except that the contrast is slightly reduced to α(m′) =
(α(m)×m+ 1)/m′. Thus, the transformation produces another (Γ,m+ 2)-VCS.
For Pi verifying the share Sj of Pj , we see how the verification image appears on
Vi+ Sj . For each black pixel of the verification image, the first two subpixels of Vi+ Sj is
[0 1] + [1 0] = [1 1]. For each white pixel of the verification image, the first two subpixels
of Vi + Sj is [1 0] + [1 0] = [1 0]. Thus, the black and white pixels of the verification
image have a positive contrast and Pi can see the verification image in Vi + Sj .
26
  S1                                    S2                                   S3                                     V1
       
   V2                                   V3                                V1+S2                               V1+S3
       
V2+S1                             V2+S3                             V3+S1                              V3+S2
       
S1+S2                             S1+S3                              S2+S3                           S1+S2+S3
Figure 15: An example of a transformed VCS with cheating prevention.
Each participant has his own private verification image, which is not known to other
participants. Since the first two subpixels [1 0] (before permutation) of all shares are the
same, a participant Pi even with all shares cannot know the positions of black pixels of
the verification image of participant Pj , j 6= i. Therefore, Pi cannot produce a fake share
FSi such that FSi + Vj shows the verification image of Pj . Participant Pi cannot cheat
participant Pj for i 6= j. Furthermore, we see that collaboration of some participants
cannot succeed to cheat, either.
6 Conclusion
We have proposed three cheating methods against VCS and EVCS. We examined previ-
ous cheat-preventing schemes and found that they are either not robust enough or still
improvable. We presented an improvement on one of these cheat-preventing schemes. By
our attacks, we pointed out an essential principle for a robust cheat-preventing VCS. We
finally proposed an efficient transformation of VCS for cheating prevention. Our trans-
formation incurs minimum overhead on contrast and pixel expansion. It only added two
subpixels for each pixel in the image. The contrast is reduced a little bit only.
28
