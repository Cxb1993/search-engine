中文摘要
令 G為一圖類別 (graph class) 。 假設圖 G的點集合可以被分割成兩個點集合 P和 N,其
中點集合 P 中的元素稱為 「探針」 (probes), 點集合 N 中的元素稱為 「非探針」 (nonprobes)
而且 N 為圖 G 的一個獨立點集合 (independent set) 。 如若可以在某些非探針點之間加邊
之後, 使得圖 G 屬於 G 圖類別, 則稱 G 是圖類別 G 的 「探測圖」(probe graph)。 假如圖
G 的探針和非探針點已經預先指定, 則稱 G 為圖類別 G 的 「探針已知探測圖」(partitioned
probe graph)。 本計畫研究如何辨識某些圖類別,例如互補圖 (cographs) 、 保距圖 (distance-
hereditary graphs)、 區間圖 (interval graphs) 、 排列圖 (permutation graphs) 、 比較圖
(comparability graphs)、 互補比較圖 (comparability graphs)、 圓弧圖 (circular-arc graphs)
、 圓形圖 (circle graphs)的 (探針已知)探測圖。
探針已知的探測區間圖 (partitioned probe interval graphs)的辨識可以應用在重組 DNA
序列這方面的問題。 至於其他類別的探測圖辨識問題, 就目前為止, 大多僅有純理論方面的
研究和探討。 我們相信這些辨識問題的研究值得關注, 並且存在應用價值。 探針已知的探測
圖的辨識問題與 「圖完成問題」(graph completion problem)、「圖三明治問題」(graph sand-
wich problem) 有密切關係。 給定圖G, 「G-圖完成問題」(G-graph completion problem) 即
是在圖 G 上加入最少的邊, 使它變成屬於圖類別 G 的圖。 例如:「區間圖形完成問題」 (inter-
val graph completion problem)就是在圖形 G 上加入最少的邊,使它變成區間圖。 給定兩個
圖 G1 = (V ,E1) 以及 G2 = (V ,E2) 滿足 E1 是 E2 的子集合的條件, 「 G-三明治問題」(G-
graph sandwich problem) 即是找到一個邊集合 E 滿足 E1 ⊆ E 以及 E ⊆ E2 的條件, 使得
圖 G = (V ,E) 屬於圖類別 G。 其實不難看出,當 E2 \ E1形成 (induces) G2的 一個完全子圖
時, 圖類別 G 的探針已知探測圖辨識問題, 其實是 「 G -圖形三明治問題」 的一個特例。 不過,「
G -圖形完成問題」 和 「 G -圖形三明治問題」 對於比較圖、互補比較圖、圓形圖、 圓弧圖. . .等等
大多數的圖形而言是 NP-hard 的。 然而對於保距圖的圖形三明治問題,尚未有人提出一個多
項式時間的演算法來解決它或者證明它是 NP-hard 。
在本計畫中, 我們的研究成果包含 (1) 探針未知互補圖 (unpartitioned probe cographs)
和探針已知互補圖 (partitioned probe cographs), (2) 探針已知保距圖 (partitioned probe
distance-hereditary graphs), (3)探針已知比較圖 (partitioned probe comparability graphs),
(4) 探針未知托勒密圖 (unpartitioned probe ptolemaic graphs), (5) 探針未知保距圖 (un-
i
Abstract
Given a class G of graphs, a graph G is a probe graph of G if its vertices can be partitioned
into a set P of probes and an independent set N of nonprobes such thatG can be embedded
into a graph of G by adding edges between certain nonprobes. If the partition of the
vertices is a part of the input we call G a partitioned probe graph of G. In this project,
we study the recognition of some (partitioned) probe graph classes such as cographs,
distance-hereditary graphs, interval graphs, permutation graphs, comparability graphs,
cocomparability graphs, circular-arc graphs, circle graphs. The recognition of partitioned
probe interval graphs has an application in reconstructing DNA from fragments. The
study of recognition of other probe graph classes more or less is of pure theoretic interest
at present. But we believe that these problems are interesting and will have applications
in the long run.
The recognition of partitioned probe graph classes is closely related to the graph com-
pletion problem and graph sandwich problem. Given a graph G, the G-graph completion
problem is to find minimum number of edges we can add to make graph G a graph of
G. For example, given a graph G, the interval graph completion problem is to add as
few edges as possible to make G an interval graph. Given two graphs G1 = (V ,E1) and
G2 = (V ,E2) such that E1 ⊆ E2, the G-graph sandwich problem is to find an edge set E
such that E1 ⊆ E ⊆ E2 and graph G = (V ,E) is a graph of G. It is not hard to see that the
recognition of partitioned probe graphs of G is a special G-graph sandwich problem where
E2\E1 induces a complete subgraph of G2. Unfortunately, the G-graph sandwich problem
and the G-graph completion problem are NP-hard for most graph classes G such as permu-
tation graphs, comparability graphs, cocomparability graphs, circle graphs, circular-arc
graphs, etc. Whether the distance-hereditary graph sandwich problem can be solved in
polynomial time remains open.
In this project, we have developed recognition algorithms of the following probe graph
classes, (1) unpartitioned probe cographs and partitioned probe cographs, (2) partitioned
probe distance-hereditary graphs, (3) partitioned probe comparability graphs, (4) un-
iii
Contents
1 前言 1
2 研究目的 2
3 文獻探討 2
4 研究方法 4
4.1 Partially partitioned probe distance-hereditary graphs . . . . . . . . . . . . 11
4.1.1 Twins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
4.1.2 Kernel probe graphs and Algorithm B . . . . . . . . . . . . . . . . . 14
4.1.3 Non-biconnected probe graphs without twins and Algorithm R . . . 24
4.1.4 Time complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
4.2 Partially partitioned probe bipartite distance-hereditary graphs . . . . . . 31
4.2.1 False twins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
4.2.2 Biconnected without false twins . . . . . . . . . . . . . . . . . . . . 33
4.2.3 Non-biconnected without false twins . . . . . . . . . . . . . . . . . 38
4.2.4 Time complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
4.3 Partially partitioned probe ptolemaic graphs . . . . . . . . . . . . . . . . . 43
4.3.1 True twins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
4.3.2 Non-biconnected probe graphs and Algorithm RP . . . . . . . . . . 44
4.3.3 Biconnected probe graph and Algorithm BP . . . . . . . . . . . . . 49
4.3.4 Fully-partitioned probe graphs and Algorithm F . . . . . . . . . . . 55
4.3.5 Time complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
5 結果與討論 63
6 計畫成果自評 64
7 參考文獻 65
v
1 前言
A probe graph P is a two-tuple (G,L) where G is a graph and L is a function from
VG to the set {P,N,U} of labels. We use PG and PL for the first and second tuple of P,
respectively, and use PV and PE for the sets of vertices and edges of PG, respectively. We
also use PP, PN, and PU for the sets of vertices v ∈ PV with PL(v) = P, PL(v) = N, and
PL(v) = U, respectively. A probe graph P is fully (resp. partially) partitioned if PU = ∅
(resp. PU 6= ∅). A probe graph P is unpartitioned if PP = PN = ∅. We call probe graph P
′ a
subgraph of a probe graph P if P′G is a subgraph of PG and P
′
L(v) = PL(v) for v ∈ P
′
V. Let X
be a subset of PV. A subgraph of P induced by X is the subgraph P
′ of P with P′G = PG[X],
i.e., P′G is the subgraph of PG induced by X. For v ∈ PV, use P − v to denote the probe
subgraph of P induced by PV − v. We also use P − X for the subgraph of probe graph P
induced by PV − X for a subset X of PV. We call a vertex v ∈ PV a probe, a nonprobe, and
a prime if PL(v) = P, PL(v) = N, and PL(v) = U, respectively.
A probe graph P is feasible if PN is an independent set of PG. We say a probe graph
P∗ is an embedding of probe graph P if P∗V = PV, PE ⊆ P
∗
E, PN ⊆ P
∗
N
, PP ⊆ P
∗
P
, P∗ is fully
partitioned, i.e., P∗
U
= ∅, P∗
N
is an independent set of PG, and for (u, v) ∈ P
∗
E− PE we have
P∗L(u) = P
∗
L(v) = N. Let G be a class of graphs. We call probe graph P a probe G graph
if there exists an embedding P∗ of P such that P∗G ∈ G. If probe graph P is not feasible,
then it does not have any embedding by definition and hence it is not a probe G graph
for any graph class G. The recognition of fully partitioned (resp. unpartitioned) probe G
graphs is to determine whether a fully partitioned (resp. unpartitioned) probe graph has
an embedding in G.
The recognition of fully partitioned probe G graphs is a special case of the graph sand-
wich problem [15]. Given G1 = (V ,E1) and G2 = (V ,E2) where E1 ⊆ E2, the graph
sandwich problem asks whether there exists a graph G = (V ,E), E1 ⊆ E ⊆ E2, where
G is in a specific graph class G. For example, the interval sandwich problem asks ”Is
there an interval graph G = (V ,E) where E1 ⊆ E ⊆ E2?”. The partitioned probe graph
1
Table 1: Some results and open problems on probe graphs.
Graph class Fully partitioned Unpartitioned
probe chordal O(|P|m) [2, 16] O(m2) [2]
probe strongly chordal Poly. [5] Open
probe chordal bipartite Poly. [5] Open
probe interval O(n +m) [22] Poly. [10]
Probe DHG O(n2) [this project] O(nm) [this project]
probe cographs O(n2) [this project] O(n2) [this project]
Probe bipartite DHG O(n2) [this project] O(nm) [this project]
probe ptolemaic O(nm) [this project] O(n3) [this project]
probe comparability O(nm) [this project] Open
probe co-comparability O(n3) [this project] Open
probe permutation O(n2) [8] Open
3
Corollary 2. A bipartite graph G is a bipartite distance-hereditary graph if and only if it has
no induced domino nor induced hole.
Corollary 3. A graph G is a bipartite distance-hereditary graph if and only if every connected
induced subgraph of G with at least two vertices has a pendant vertex or a false twin.
Cographs are a subclass of distance-hereditary graphs. The following property of
cographs is used in the paper.
Theorem 4. [3] The following conditions are equivalent:
1. G is a cograph;
2. Every induced subgraph of G with at least two vertices has at least one pair of twins;
3. G is P4-free.
Figure 1: A house, a hole, a domino, and a gem.
In [14] the notion of a hanging of G by a vertex v was introduced.
Definition 1. [14] The hanging Φ of G = (V ,E) by v is an (ℓ + 1)-tuple (L0,L1, . . . ,Lℓ)
where ℓ = maxu∈V dG(u, v), L0 = {v}, and Li = {u ∈ V | dG(u, v) = i} for 1 6 i 6 ℓ.
Fig. 2 (a) shows a connected distance-hereditary graph G that is not a cograph.
Fig. 2 (b) shows the hanging of G by v8.
Definition 2. Let Φ = (L0,L1, . . . ,Lℓ) be a hanging of G. For x ∈ Li, 0 < i 6 ℓ, use
N−Φ(x) for NG(x) ∩ Li−1. For x ∈ Li, 0 6 i < ℓ, use N
+
G(x) for NG(x) ∩ Li+1. Denote the
subgraph of G induced by ∪i6j6ℓLj by Gi for 0 6 i 6 ℓ. By definition, G = G0. Let x
and y be vertices in Li with 1 6 i 6 ℓ. We say that (i) x properly contains y, denoted by
5
Corollary 10. SupposeG is a biconnected distance-hereditary graph andΦ = (L0,L1, . . . ,Lℓ)
is a hanging of G. Let C be a component of Gi where 1 < i 6 ℓ. Then NG(C) contains a pair
of twins.
Proof. For every component C of Gi, there exists a minimal component C
∗ such that
NG(C
∗) ⊆ NG(C). For every component C of Gi, NG(C) induces a cograph. Otherwise
by Theorem 4 there exists a P4 in G[NG(C)]. The P4 with any x ∈ C induces a gem,
a contradiction. Because G is biconnected, |NG(C
∗)| > 1. By Corollary 9, NG(C
∗) is a
module of G. SinceNG(C
∗) induces a cograph in G, there exists two verticesNG(C
∗) that
are twins in the subgraph induced by NG(C
∗). They are twins in G. 2
Corollary 11. Suppose G is a biconnected bipartite distance-hereditary graph and Φ =
(L0,L1, . . . ,Lℓ) is a hanging of G. Let C be a component of Gi where 1 < i 6 ℓ. NG(C)
contains two vertices that are false twins in G.
Proof. For every component C of Gi, there exists a minimal component C
∗ such that
NG(C
∗) ⊆ NG(C). For every component C of Gi, NG(C) is an independent set of G.
Because G is biconnected, |NG(C
∗)| > 1. By Corollary 9, NG(C
∗) is a module of G. Since
NG(C
∗) is an independent set of G, any two vertices in NG(C
∗) are false twins in G. This
completes the proof. 2
Corollary 12. Suppose Φ = (L0,L1, . . . ,Lℓ) is a hanging of a connected ptolemaic graph G.
For each 1 6 i 6 ℓ, Gi has a minimal component C, i.e., NG(C) does not properly contain
NG(C
′) for any component C ′ of Gi other than C. In addition, if C is a minimal component
of Gi then NG(C) is a clique module of G.
Proof. By Theorem 6 and Theorem 8, for any minimal component C of Gi, 1 6 i 6 ℓ,
NG(C) is a module of G. If |NG(C)| = 1, NG(C) is a trivial clique module. Suppose
|NG(C)| > 2. If x,y ∈ NG(C) are not adjacent, then {v, x,y, z} induces a cycle of length
four in G where v ∈ Li−2 and z ∈ C, a contradiction to the assumption that G is a
ptolemaic. Thus all pairs of x,y ∈ NG(C) are adjacent, NG(C) is clique module. 2
7
Gv0
v1
v2
v3
v4 v5
v6
v7
v8
v9
v10
v11
v12
v13
L0
L1
L2
L3
L4
v8
v6 v10 v11
v4 v5 v7
v12 v13
v0 v1 v3
v2 v9
Figure 2: A connected distance-hereditary graph G and the hanging of G by v8.
Proof. Suppose the universal vertex of any induced gem is a nonprobe. Then all the
other vertices in the gem are probes. Hence the same five vertices will induce a gem in
any embedding of P, a contradiction. 2
The next lemma shows that also any induced house can be assigned a designated vertex.
Lemma 16. If P is a probe distance-hereditary graph, then the simplicial vertex of any
induced house of PG is a nonprobe in any distance-hereditary embedding of P.
Proof. An induced house in PG can have only two nonprobes in any distance-hereditary
embedding of P. If they are two vertices of the square, then adding an edge creates a
gem, which is a contradiction. 2
Theorem 17. If P is a probe distance-hereditary graph and the subgraph of PG induced by
a set D of six vertices is a domino, then in any distance-hereditary embedding of P, D has
exactly two nonprobes which are at distance three in the subgraph of PG induced by D.
Proof. Any maximal independent set in a domino has either two or three vertices. As-
sume there are three nonprobes in a distance-hereditary embedding of P. Then the three
9
Theorem 21. Suppose P is a probe graph and u is a universal vertex of PG. Then P is a
probe distance-hereditary graph if and only if one of the following conditions are satisfied:
(i) PL(u) = P and P − u is a probe cograph.
(ii) PL(u) = N and P − u is a cograph.
(iii) PL(u) = U and P − u is a probe cograph.
Proof. If P has a distance-hereditary embedding P∗, then P∗ − u is a cograph, i.e., P − u
is a probe cograph. Otherwise there exists an induced P4 in P
∗ − u and the P4 with u
induces a gem in P∗, a contradiction. If u is a nonprobe, then all vertices in P − u are
probes. Hence P − u must be a cograph.
Suppose P−u is a probe cograph. Let P ′ be a cograph embedding of P−u. We create
a new graph P∗ from P ′ by letting u be adjacent to all vertices of P ′. It cannot introduce
any induced P4 in P
∗ including u since u is a universal vertex. Hence P∗ is a cograph
embedding of P and a distance-hereditary embedding of P. Suppose P − u is a cograph.
There is no induced P4 including u since u is a universal vertex. Thus P is a cograph and
also a distance-hereditary graph if u is a universal vertex and P − u is a cograph. 2
Corollary 22. Suppose P is a probe graph and u is a universal vertex of PG. Then P is a
probe distance-hereditary graph if and only if P is a probe cograph.
4.1 Partially partitioned probe distance-hereditary graphs
In this section, we give anO(nm)-time algorithm to recognize probe distance-hereditary
graphs. This algorithm is a recursive one. We denote the input probe graph by P. The
algorithm first checks whether P is feasible. If P is not feasible, then it is not a probe
distance-hereditary graph. Set PL(u) = P for all vertices of u ∈ PU that are adjacent to
v ∈ PV with PL(v) = N. This can be done in linear time. In the following assume P is
feasible, i.e., all neighbors of a nonprobe must be probes. The algorithm checks to which
of the following classes the input probe graph P does belong and takes action accordingly:
P 1. PG has twins. If it has one, reduce the size of P according to Lemma 23 and 24
11
hence NP∗(v) = NP(v). By Theorem 1, P
∗ is a distance-hereditary embedding of P.
Suppose that PL(u) = PL(v) = U. Since u and v are adjacent in P, one of u and v is
not a nonprobe in any embedding of P. Without loss of generality assume that u is a
probe. Since P′L(u) = P, NP′(u) = NP′′(u). We obtain P
∗ from P ′′ by attaching v as a
true twin of u and relabel v as a probe in P∗. By Theorem 1, P∗ is a distance-hereditary
embedding. 2
Lemma 24. Suppose P is a probe graph and u and v are false twins in PG satisfying one of
the following conditions.
1. PL(u) = PL(v) = P, N, or U.
2. PL(u) = P, PL(v) = N or U.
3. PL(u) = N, PL(v) = U.
Then P is a probe distance-hereditary graph if and only if P−v is a probe distance-hereditary
graph.
Proof. If P has a distance-hereditary embedding P∗, then P∗ −v is an embedding of P−v.
Next we show that P has a distance-hereditary embedding if P− v has one. Suppose P− v
has an embedding P ′. We then obtain P∗ from P ′ by attaching v as a false twin of u. Let
P∗L(v) = P
′
L(u) if PL(v) = U. If P
∗
L(u) = P, we see NP(u) = NP∗(u) and NP(v) = NP∗(v).
Suppose P∗L(u) = N and PL(v) = N or U. Assume NP∗(u) = NP(u) + X, all vertices in
X are nonprobes. We obtain P∗ from P′ by attaching v as a false twin of u and letting
P∗L(v) = N if PL(v) = U. Hence NP∗(v) = NP∗(u) = NP(u) + X. By Theorem 1, we see P
∗
is a distance-hereditary embedding of P. 2
The proofs of the above two lemmas explicitly point out how to reduce the size of
input probe graph P and imply the problem can be solved recursively. For completeness,
we summarize them as follows.
1. PG has true twins u and v. Note that u and v are adjacent in PG, either one of them
is a probe or both of them are primes. If one of them is a nonprobe, the other is a
probe. There are two cases:
13
the problem to the case that there is a vertex p ∈ PV with PL(p) = P. We call a probe graph
P satisfying the following four conditions a kernel probe graph: (i) PG is biconnected, (ii)
PG has no twins, (iii) there is a vertex p ∈ PV with PL(p) = P, and (iv) P is not a probe
cograph. Given a kernel probe graph P and a probe p, our goal is to determine whether
P is a probe distance-hereditary graph. We say that a kernel probe graph P is well-labeled
if there is a vertex p such that PL(p) = P and PL(x) 6= U for every vertex x in the open
neighborhood of p in PG. Let Φ = (L0,L1, . . . ,Lℓ) be the hanging of PG by p. Since P is
not a probe cograph, by Corollary 22 there is no universal vertex in PG, ℓ > 1. For clarity
of the notation, use G for PG. The second stage of Algorithm B checks to which class of
probe graphs the input kernel probe graph P does belong and takes action accordingly:
C 1. P is well-labeled.
C 2. P is not well-labeled.
To handle the case that P is of class C 2, i.e., not well-labeled, the algorithm again checks
to which class of probe graphs the input kernel probe graph P does belong and takes
action accordingly:
D 1. there is a component C in G2 with |C ∩ L2| > 2. If ℓ > 2, there must be a component
C in G2 with |C ∩ L2| > 2 since G is biconnected.
D 2. ℓ = 2, |C| = 1 for every component C in G2 and there is a vertex q ∈ L2 with
PL(q) = P.
D 3. ℓ = 2, |C| = 1 for every component C in G2 and every vertex in L2 is not a probe.
In the following assume that P is a kernel probe graph and P∗ is a minimal distance-
hereditary embedding of P. For simplicity, use G and G∗ for PG and P
∗
G, respectively. Let p
be a probe of P∗, Φ = (L0,L1, . . . ,Lℓ) and Ψ = (Z0,Z1, . . . ,Zh) be the hangings of G and
G∗ by vertex p, respectively. The above notation will be used in lemmas and theorems in
the rest of this subsection. Now we give some observations on both the hangings of G and
G∗ by a probe p.
Lemma 26. Suppose C is a component of G∗i with 1 < i 6 h. Then NG∗(C) contains probes
and nonprobes in P∗. In addition, if |C ∩ Zi| > 1 then C ∩ Zi also contains probes and
15
in Zi. By definition, dG∗(x,p) = i. Notice that dG∗(x,p) 6 dG(x,p) since G
∗ is obtained
from G by adding edges between nonprobes. By Corollary 27, x is adjacent to a probe y
in Zi−1 = Li−1. Hence dG(x,p) = dG(y,p) + 1 = i and x ∈ Li. 2
Theorem 29. For 1 < i 6 ℓ and x ∈ Li, x is a probe in P
∗ if and only if in G x is adjacent
to some vertices in Li−1 that are nonprobes in P
∗.
Proof. By Lemma 28, x ∈ Zi since x ∈ Li. By Corollary 27, in G
∗ every vertex in Zi is
adjacent to vertices in Zi−1 that are nonprobes in P
∗. Since x is a probe, NG(x) = NG∗(x).
By Lemma 28, Li−1 = Zi−1. Hence in G x is adjacent to vertices in Li−1 that are nonprobes
in P∗. On the other hand, x must be a probe in P∗ if in G x is adjacent to some vertices
that are nonprobes in P∗. 2
Algorithm W
Now we are ready to show the algorithm for the case that P is of class C 1, i.e., a well-
labeled kernel probe graph. We refer to the algorithm for handling this case as Algorithm
W. We will see that Algorithm W serves as a major subroutine to be used later. The
algorithm is as follows. By definition, the labels of vertices in NG[p] are either P or N.
Compute P′ from P as follows. Let P′G = PG and let P
′
L(y) = PL(y) for all y ∈ NG[p].
For every i from i = 2 to i = ℓ and every y ∈ Li with PL(y) = U, let P
′
L(y) = P if in
G y is adjacent to some vertex z ∈ Li−1 with P
′
L(z) = N; and let P
′
L(y) = N otherwise.
By Theorem 29, we see that P is a probe distance-hereditary graph if and only if P′ is a
probe distance-hereditary graph. Apparently P′ is fully partitioned. Use the O(n2)-time
algorithm in [4] to determine whether P′ is a probe distance-hereditary graph. It is not
hard to see that Algorithm W runs in O(n2) time.
In the following we give observations to be used for handling probe graphs of class C 2.
Lemma 30. Suppose P∗ is a minimal distance-hereditary embedding of P. Then the following
statements hold:
(1) A component of Gi is a component of G
∗
i for 0 6 i 6 ℓ.
17
the gem is either x3 or x4. Without loss of generality assume x3 is the universal of
the gem. Then the fifth vertex x5 of F is adjacent to x3 and one of x1 or x2. In other
words, x5 is adjacent to a vertex in Zi and another vertex in Zi−1. Therefore x5 ∈ Zi
or x5 ∈ Zi−1. If x5 ∈ Zi, then x5 is also adjacent to x4. If x5 ∈ Zi−1, then x5 is also
adjacent to both x1 and x2. It contradicts that F induces a gem.
2. x3 and x4 are not adjacent and F induces a house. Then the fifth vertex x5 of F is
the simplicial vertex of the house. It is adjacent to a vertex in Zi and another vertex
in Zi−1. By arguments similar to those for proving the above case, it contradicts the
assumption that F induces a house.
3. x3 and x4 are not adjacent and F induces a domino. The fifth vertex x5 and the sixth
vertex x6 of F are adjacent and one of them is adjacent to a vertex in Zi and the other
is adjacent to a vertex in Zi−1. Thus at least one of them is in Zi or in Zi−1. In G
′ if
it is in Zi then it is adjacent to both x3 and x4 and if it is in Zi−1 then it is adjacent
to both x1 and x2. In other words, F does not induce a domino, a contradiction.
Next we prove Statement (2). By Statement (1), C is also a component of G∗i . By
Lemma 28, Zi = Li for 0 6 i 6 ℓ. Hence C ∩ Zi ⊆ C ∩ Li. Since G
∗ is obtained from G by
adding edges, C ∩ Li ⊆ C ∩ Zi. Therefore C ∩ Zi = C ∩ Li.
Finally, we prove Statement (3). Clearly the statement is true if i = 1. In the following
assume 1 < i 6 ℓ. By Statement (1) of this lemma, C is also a component of G∗i . By
Statement (2) of this lemma, C∩Zi = C∩Li. Since |C∩Zi| > 1, by Lemma 26 bothNG∗(C)
and C ∩ Zi contains probes and nonprobes. Let x ∈ C ∩ Zi be a probe in G
∗. Since G∗ is
distance hereditary, NG∗(C) = N
−
Ψ
(x) by Theorem 5. Because Zi = Li for 0 6 i 6 ℓ (see
Lemma 28) and x is a probe in P∗,N−Ψ(x) = N
−
Φ(x). SinceG
∗ is obtained fromG by adding
edges, we have NG(C) ⊆ NG∗(C). Thus NG∗(C) = N
−
Ψ(x) = N
−
Φ(x) ⊆ NG(C) ⊆ NG∗(C).
This proves the statement. 2
Theorem 31. Suppose P∗ is a minimal distance-hereditary embedding of P and C is a com-
ponent of Gi with |C ∩ Li| > 1 and 1 < i 6 ℓ. A vertex x ∈ C ∩ Li (resp. NG(C)) is a probe
in P∗ if and only if x is adjacent to all vertices in NG(C) (resp. C).
19
in L ′2 and are in the same component of G − NG[q]. Hence P is also of class D 1 and the
algorithm is finished by calling the algorithm for D 1. Thus the algorithm for D 2 runs in
O(n2) time.
Algorithm for D 3. In this case ℓ = 2, |C| = 1 for every component of G2, and every
vertex in L2 is not a probe. Let q be a vertex in L2 and be of minimum degree among
vertices in L2. By definition, PL(q) = U or PL(q) = N. Let P^ be the probe graph (PG, P^L)
where P^L(q) = P and P^L(x) = PL(x) for x ∈ PV − q. Let Pˇ be the probe graph (PG, PˇL)
where PˇL(q) = N, PˇL(y) = P for y ∈ NG(q), and PˇL(x) = PL(x) for x ∈ PV − NG[q].
If PL(q) = U, then P is a probe distance-hereditary graph if and only if one of P^ and Pˇ
is a probe distance-hereditary graph. It is easy to see that we can use the algorithm for
D 2 to test whether P^ is a probe distance-hereditary graph. In the following we focus on
checking whether Pˇ is a probe distance-hereditary graph. Notice that PˇG = G. In the
following we use G to refer to PˇG. Since G has no twins, N
−
Φ(q) 6= N
−
Φ(q
′) for any q ′ ∈ L2
and q ′ 6= q. We distinguish the following two classes of the input graph:
N 1. There exists a vertex q ′ ∈ L2, q
′ 6= q, that N−Φ(q
′) and N−Φ(q) are incomparable,
i.e., N−Φ(q
′) ∩N−Φ(q) 6= ∅, N
−
Φ(q
′) −N−Φ(q) 6= ∅, and N
−
Φ(q) −N
−
Φ(q
′) 6= ∅.
N 2. For all q ′ ∈ L2, q
′ 6= q, either N−Φ(q) ⊂ N
−
Φ(q
′), or N−Φ(q) and N
−
Φ(q
′) are disjoint.
To which of the above two classes Pˇ does belong can be determined in O(n+m) time. We
refer to the algorithms for input probe graphs of classes N 1 and N 2 as Algorithm N 1
and Algorithm N 2, respectively.
Algorithm N 1. Let y1,y2 ∈ N
−
Φ
(q) where y2 ∈ N
−
Φ
(q ′) and y1 /∈ N
−
Φ
(q ′). Let z ∈ N−
Φ
(q ′)
but z /∈ N−Φ(q). Notice that y1 and y2 must be probes in any distance-hereditary embed-
ding of Pˇ. Suppose y1 and y2 are not adjacent in G. Consider the hanging (Lˇ0, Lˇ1, . . . , Lˇk)
of G by y1. By definition, dG(y1,q
′) > 2. Thus k > 2. Clearly dG(y1,y2) = 2. If
dG(y1,q
′) = 2, then both y2 and q
′ are in Lˇ2 and in the same components of the graph
obtained by removing NG[y1]. If dG(y1,q
′) > 2, then k > 2. We see that Pˇ is of class
D 1. Hence whether Pˇ is a probe distance-hereditary graph can be determined in O(n2).
21
in the following. Let y be any vertex in Y. By definition there are y1,y2 ∈ N
−
Φ(q) such that
y is adjacent to y2 but not adjacent to y1. The subgraph of G induced by {p,y1,y2,y,q}
is either a house or a gem as shown in Fig. 3(c) depending on whether y1 and y2 are
adjacent in G. The only way to destroy the house or the gem is to make y a nonprobe
and to add edge (y,q) in the embedding. Thus all vertices in Y must be nonprobes in any
distance-hereditary embedding. Let x be a vertex in X. If x is adjacent to some vertex in
Y, then x must be a probe in any embedding. Suppose x is not adjacent to any vertex in
Y. After adding edge (y,q), {y2, x,p,y,q} induces a gem, where y2 is the universal vertex
and xpyq is the P4, in the embedding. For destroying the gem, x must be a nonprobe in
any distance-hereditary embedding. Let Q = {q ′ | q ′ ∈ L2,q
′ 6= q,N−Φ(q) ⊆ N
−
Φ(q
′)}. If
q ′ ∈ Q is adjacent to some vertex in Y, then it must be a probe in any distance-hereditary
embedding. Suppose q ′ ∈ Q is not adjacent to any vertex of Y. Similar to the case for
vertex x ∈ X not adjacent to any vertex in Y, we can show that q ′ must be a nonprobe in
any distance-hereditary embedding. From the arguments above we see that every vertex
in NG(NG(q)) has a unique label among all distance-hereditary embeddings of Pˇ. Let P
′
be the probe graph (PG,P
′
L) where P
′
L(y) = N for y ∈ Y, P
′
L(x) = N for x ∈ X not adjacent
to any vertex in Y, P ′L(x) = P for x ∈ X adjacent to some vertex in Y, P
′
L(q
′) = N for
q ′ ∈ Q not adjacent to any vertex in Y, P ′L(q
′) = P for q ′ ∈ Q adjacent to some vertex
in Y, and P ′L(u) = PˇL(u) for u ∈ PV − (X + Y + Q). From the above arguments, we see
that Pˇ is a probe distance-hereditary graph if and only if P ′ is a probe distance-hereditary
graph. Let p ′ be some vertex in NG(q). We see that p
′ is a probe in P ′ and P ′L(u) 6= U
for every u ∈ NG(p
′). Thus P ′ is well-labeled with respect to p ′ (C 1). Hence we can call
Algorithm W to complete the job in O(n2) time.
The following lemma summarize the results of this subsection.
Lemma 32. Whether a probe graph of class P 4 is a probe distance-hereditary graph can be
determined in O(n2) time.
23
PG− v, then P is a probe distance-hereditary graph if and only if P−C has an embedding P
′
and P[C + v] has an embedding P ′′ where either P ′L(v) = P
′′
L (v) = P or P
′
L(v) = P
′′
L (v) = N.
Proof. If P has a distance-hereditary embedding P∗, then P∗[C+v] is a distance-hereditary
embedding of P[C + v] and P∗ − C is a distance-hereditary embedding of P − C.
Suppose that PL(v) = P or N. By Lemma 33,P
∗ = P ′ + P ′′ is a distance-hereditary
embedding of P.
Suppose that PL(v) = U. If P[C+v] has no distance-hereditary embedding that v is a probe
or a nonprobe, then P is not a probe distance-hereditary graphs. If P[C+v] has a distance-
hereditary embedding P^ that v is a probe but has no distance-hereditary embedding that
v is a nonprobe, then P has a distance-hereditary embedding if and only if P − C has a
distance-hereditary embedding that v is a probe. Conversely, if P[C + v] has a distance-
hereditary embedding Pˇ that v is a nonprobe but has no embedding that v is a probe,
then P has a distance-hereditary embedding if and only if P−C has a distance-hereditary
embedding that v is a nonprobe. If P[C + v] has a distance-hereditary embedding P^ that
v is a probe and P[C + v] has a distance-hereditary embedding Pˇ that v is a nonprobe,
then P has a distance-hereditary embedding if and only if P−C has a distance-hereditary
embedding. 2
The proof of the above lemma is constructive. It points out a recursive way to solve
the problem. We now describe Algorithm R in detail. Let v be a cut vertex of PG and C be
a component of PG− v such that C does not contain any other cut vertex of PG. In other
words, C+ v induces a biconnected component of PG. There are two cases:
1. PL(v) = P or N. By Lemma 34, P is a probe distance-hereditary graph if and only if
both P[C + v] and P − C are probe distance-hereditary graphs. Call Algorithm C to check
whether P[C + v] has an embedding and recursively call the main algorithm to check
whether P − C has an embedding.
2. PL(v) = U. Let P^ be the probe graph (PG[C+v], P^L) where P^L(v) = P and P^L(x) = PL(x)
for x ∈ C. Let Pˇ be the probe graph (PG[C + v], PˇL) where PˇL(v) = N, PˇL(x) = P for
25
Theorem 35. Suppose G is a non-biconnected graph without twins. There exists a bicon-
nected component GC + v of G that only contains a cut vertex v of G. Then one of the
following statements holds.
(i) There are no twins in GC+ v.
(ii) There is only one pair of twins in GC + v, v is one of the pair of twins. After removing
one of the pair of twins from GC+ v, the resulting graph has no twins and either it is
biconnected or it has only one cut vertex which is one of the pair of twins in GC+ v.
Proof. Since G has no twins, no x,y ∈ GC are twins in GC+ v. After the decomposition,
only the neighborhood of the vertex used to decompose the graph is changed. Hence v
must be one of the pair of twins, and there exists only one vertex u in GC that u and v
are twins in GC+ v.
Suppose there exists a pair of twins x and y in GC. Removing v from GC + v only
changes the neighborhood of vertices in NGC [u], where u and v are twins in GC + v.
Hence one of x,y ∈ NGC [u]. If u = x and y ∈ NGC (u), y and v are twins in GC + v, a
contradiction. If u = x and y 6∈ NGC [u], y and v are twins in GC + v, a contradiction.
Suppose x 6= u and y 6= u. If x,y ∈ NGC (u), they are twins in GC+ v, a contradiction. If
x ∈ NGC (u) but y 6∈ NGC [u], then they are not twins in GC since y is not adjacent to u,
contradiction. Hence there are no twins in GC. Similarly, we can show that there are no
twins in GC+ v − u.
Suppose GC is non-biconnected. If u is not a cut vertex, let x 6= u be a cut vertex
of GC. Let C1 and C2 be two components of GC − x. Since GC + v is biconnected, v is
adjacent to some vertex of C1 and some vertex of C2 in GC+v. Since u and v are twins in
GC+v, in GC u is adjacent to some vertex of C1 and some vertex of C2, a contradiction to
the assumption that x 6= u is a cut vertex. Hence u is the only cut vertex in GC. Similarly,
we can show v is the only cut vertex of GC+ v− u. 2
Corollary 36. The probe graph P[C + v] produced in Case 1. of Algorithm R and the probe
graphs P^ and Pˇ produced in Case 2. of Algorithm R are pseudo-kernel probe graphs. In
27
for 1 6 i < j 6 r. For each Ci, i = 1, 2, . . . , r, call Algorithm C to check (P[Ci], v).
Lemma 37. Whether a pseudo-kernel probe graph is a probe distance-hereditary graph can
be checked in O(nm) time.
Proof. Let g(n) denote the time complexity of Algorithm C. We claim that g(n) 6 c1nm.
The input graph of class E 1 can be recognized in O(1) time. The input graph of class E 2
can be recognized in O(n2) time. The input graph of class E 3 can be recognized in g(n−
1)+c0(n+m) time where c0(n+m) is the time spent for decomposing the input graph into
biconnected components and removing a twin from it. It is easy to see that g(n−1)+c0(n+
m) 6 c1nm if c1 > 2c0. The input of class E 4 can be recognized in Σ
r
i=1g(ni)+c0(n+m)
time where ni = |Ci| and C1,C2, . . . ,Cr are biconnected components in PG. Assume that
Cr has the maximum number of vertices among C1,C2, . . . ,Cr.
g(n) = Σri=1g(ni) + c0(n +m)
6 Σri=1c1nimi+ c0(n +m)
6 c1nrΣ
r
i=1mi+ c0(n +m)
= c1nrm+ c0(n+m)
6 c1(n − 1)m + c0(m+m)
6 c1nm − (c1 − 2c0)m
6 c1nm where c1 > 2c0.
This completes the proof. 2
4.1.4 Time complexity
In this section we analyze the time complexity of the algorithm. There are two recursive
steps in the main algorithm. One of them is to remove twins. The other is to decom-
pose the graph into subgraphs (Algorithm R). To make the algorithm more efficient, we
perform the step of removing twins first until the graph has no twins.
29
t1(n
′) = 2g(n1) + t1(n
′ − n1 + 1) + c0(n
′ +m ′)
= 2g(n1) + · · · + 2g(nk) + c0k(n
′ +m ′)
= 2Σki=1g(nimi) + c0k(n
′ +m ′)
= 2Σki=1c1nimi + c0k(n
′ +m ′)
6 2c1n
′Σki=1mi+ c0k(n
′ +m ′)
6 2c1n
′m ′ + c0n
′(m ′ +m ′)
6 c2n
′m ′ where c2 > 4c1
= O(n ′m ′)
Since t(n) = t1(n
′) + O(n2) and t1(n
′) = O(n ′m ′), we have t(n) = O(nm). This
completes the proof of the theorem. 2
4.2 Partially partitioned probe bipartite distance-hereditary graphs
In this section, we modified the recognition algorithm of probe distance-hereditary
graphs to obtain anO(nm)-time algorithm to recognize probe bipartite distance-hereditary
graphs. This algorithm is also a recursive one. The algorithm first check whether the input
probe graph P is a bipartite graph. If P is not bipartite, then it has no bipartite distance-
hereditary embedding. If P is bipartite, the algorithm checks whether P is feasible. If P
is not feasible, then it is not a probe bipartite distance-hereditary graph. Set PL(u) = P
for all vertices of u ∈ PU that are adjacent to v ∈ PV with PL(v) = N. This can be done
in linear time. In the following assume P is bipartite and feasible, i.e., all neighbors of
a nonprobe must be probes. The algorithm checks to which of the following classes the
input probe graph P does belong and takes action accordingly:
Q 1 PG has false twins. If it has one, reduce the size of P according to Lemma 39 and
solve the problem recursively. The lemma and the reduction steps will be described
in Section 4.2.1.
31
Hence given a graph, removing vertices that have a false twin until it is not possible
can be done in O(n2) time [20].
4.2.2 Biconnected without false twins
In the subsection we deal with the case that input graph P is of class Q 4. We will
show that whether such a probe graph P is a probe bipartite distance-hereditary graph
can be recognized in O(n2) time. First arbitrarily pick an edge (x,y) of PE. In any
bipartite distance-hereditary embedding of P, either x is a probe or y is a probe. Hence
we reduce the problem to the case that there is a vertex p ∈ PV with PL(p) = P. We
call a probe graph P satisfying the following three conditions a kernel probe bipartite
graph: (i) PG is biconnected and bipartite, (ii) PG has no false twins, and (iii) there is
a vertex p ∈ PV with PL(p) = P. Given a kernel probe bipartite graph P and a probe
p, our goal is to determine whether P is a probe bipartite distance-hereditary graph. Let
Φ = (L0,L1, . . . ,Lℓ) be the hanging of PG by p. Since L0,L1, . . . ,Lℓ are independent
sets of PG and PG are biconnected, ℓ > 1. For clarity of the notation, use G for PG. In
Algorithm B’, we have the same classification of the input probe graphs as Algorithm B
given in Section 4.1.2. Algorithm B’ checks to which class of probe graphs the input kernel
probe graph P does belong and takes action accordingly:
C 1. P is well-labeled.
C 2. P is not well-labeled.
To handle the case that P is of class C 2, i.e., not well-labeled, the algorithm again checks
to which class of probe graphs the input kernel probe bipartite graph P does belong and
takes action accordingly:
D 1. ℓ > 2.
D 2. ℓ = 2 and there is a vertex q ∈ L2 with PL(q) = P.
D 3. ℓ = 2 and every vertex in L2 is not a probe.
In the following assume that P is a kernel probe bipartite graph and P∗ is a minimal
bipartite distance-hereditary embedding of P. For simplicity, use G and G∗ for PG and P
∗
G,
33
and G∗ are biconnected, all G0, G1, G
∗
0, and G
∗
1 have only one component. Hence the
lemma holds for i = 0 and i = 1. For 1 < i 6 ℓ, we prove the statement by contradiction
showing that if some component C of G∗i is not a component of Gi then P
∗ is not a
minimal bipartite distance-hereditary embedding of P. Suppose C is a component of G∗i
that properly contains a component D of Gi. Let P
′ be an embedding of P obtained from
P∗ by removing edges connecting a vertex in C −D and another vertex in D. Use G ′ for
P ′G. Clearly NG∗(C) = NG∗(D) ∩ Zi−1 = NG∗(C − D) ∩ Zi−1 = NG′(D) = NG′(C − D).
If P ′ is still a bipartite distance-hereditary embedding of P, the P∗ is not minimal. In
the following we prove that P ′ is still a bipartite distance-hereditary embedding of P by
contradiction again. Assume that P ′ is not a bipartite distance-hereditary embedding of
P, i.e., G ′ is not a bipartite distance-hereditary graph. There is an induced forbidden
subgraph in G ′. Let F be the set of vertices that induces an even hole or a domino in
G ′. Because the induced forbidden subgraph is formed by removing edges connecting a
vertex in D and another vertex in C − D, |D ∩ F| > 1 and |(C − D) ∩ F| > 1. Since all
induced forbidden subgraph are biconnected, |F ∩NG′(C)| = |F ∩NG∗(C)| > 2. Without
loss generality assume that x1, x2, x3, and x4 are vertices in F where x1 ∈ (C−D), x2 ∈ D,
and x3, x4 ∈ NG∗(C). By definition, x1 and x2 are not adjacent in G
′. By assumption,
x1, x2 ∈ Zi and x3, x4 ∈ Zi−1. Clearly {x1, x2} and {x3, x4} are fully adjacent both in G
∗
and in G ′. In G ′ the four vertices x1, x2, x3, and x4 induce a cycle of length four. Therefore
it is impossible for F to induce a hole. Thus F induces a domino. The fifth vertex x5 and
the sixth vertex x6 of F are adjacent and one of them is adjacent to a vertex in Zi and the
other is adjacent to a vertex in Zi−1. Thus at least one of them is in Zi or in Zi−1. In G
′
if it is in Zi then it is adjacent to both x3 and x4 and if it is in Zi−1 then it is adjacent to
both x1 and x2. In other words, F does not induce a domino, a contradiction.
Next we prove Statement (2). By Statement (1), C is also a component of G∗i . By
Proposition 2, Zi = Li for 0 6 i 6 ℓ. Hence C ∩ Zi ⊆ C ∩ Li. Since G
∗ is obtained from G
by adding edges, C ∩ Li ⊆ C ∩ Zi. Therefore C ∩ Zi = C ∩ Li.
Finally, we prove Statement (3). Clearly the statement is true if i = 1. In the following
35
bipartite distance-hereditary graph if and only if P ′ is a probe bipartite distance-hereditary
graph after we relabel primes of P in C. In P′, there must be a probe p ′ in C∩ L2. Besides
P ′L(y) 6= U for every y ∈ NG(p
′). Thus P ′ is a well-labeled kernel probe graph. We then
call Algorithm W to determine whether P ′ is a probe bipartite distance-hereditary graph.
It takes linear time to find a component C of G2 with |C ∩ L2| > 1 and obtain P
′ in linear
time. Thus the algorithm for D 1 runs in O(n2) time.
Algorithm for D 2. In this case ℓ = 2 and there is a vertex q ∈ L2 with PL(q) = P. If
NG(q) = L1, then q is a false twin of p, a contradiction. Thus L1 − NG(q) 6= ∅. Let
(L ′0,L
′
1, . . . ,L
′
k) be the hanging of G by q. Then p and all vertices in L1 − NG(q) are in
L ′2+ L
′
3 and are in the same component of G−NG[q]. Hence P is also of class D 1 and the
algorithm is finished by calling the algorithm for D 1. Thus the algorithm for D 2 runs in
O(n2) time.
Algorithm for D 3. In this case ℓ = 2 and every vertex in L2 is not a probe. Let q be a
vertex in L2 and be of minimum degree among vertices in L2. By definition, PL(q) = U
or PL(q) = N. Let P^ be the probe graph (PG, P^L) where P^L(q) = P and P^L(x) = PL(x) for
x ∈ PV−q. Let Pˇ be the probe graph (PG, PˇL) where PˇL(q) = N, PˇL(y) = P for y ∈ NG(q),
and PˇL(x) = PL(x) for x ∈ PV −NG[q]. If PL(q) = U, then P is a probe bipartite distance-
hereditary graph if and only if one of P^ and Pˇ is a probe bipartite distance-hereditary
graph. It is easy to see that we can use the algorithm for D 2 to test whether P^ is a probe
bipartite distance-hereditary graph. In the following we focus on checking whether Pˇ is a
probe bipartite distance-hereditary graph. For simplifying the notation, we use G to refer
to PG. Since G has no false twins, N
−
Φ
(q) 6= N−
Φ
(q ′) for any q ′ ∈ L2 and q
′ 6= q. If for
all q ′ ∈ L2, q
′ 6= q, either N−Φ(q) ⊂ N
−
Φ(q
′), or N−Φ(q) and N
−
Φ(q
′) are disjoint, then any
two vertices in N−Φ(q) are false twins in G. Thus there exists a vertex q
′ ∈ L2, q
′ 6= q, that
N−
Φ
(q ′) and N−
Φ
(q) are incomparable, i.e., N−
Φ
(q ′) ∩ N−
Φ
(q) 6= ∅, N−
Φ
(q ′) − N−
Φ
(q) 6= ∅,
and N−Φ(q) − N
−
Φ(q
′) 6= ∅. Let y1,y2 ∈ N
−
Φ(q) where y2 ∈ N
−
Φ(q
′) and y1 /∈ N
−
Φ(q
′).
Let z ∈ N−Φ(q
′) but z /∈ N−Φ(q). Notice that y1 and y2 must be probes in any bipartite
distance-hereditary embedding of Pˇ. Consider the hanging (Lˇ0, Lˇ1, . . . , Lˇk) of G by y1.
37
Lemma 44. Let P be a probe graph. If there exists a cut vertex v in P and C is a component
of PG − v, then P is a probe bipartite distance-hereditary graph if and only if P − C has a
bipartite distance-hereditary embedding P ′ and P[C + v] has a bipartite distance-hereditary
embedding P ′′ where either P ′L(v) = P
′′
L (v) = P or P
′
L(v) = P
′′
L (v) = N.
Lemma 44 points out a recursive way to solve the problem. We now describe Algo-
rithm R’ in detail. Let v be a cut vertex of PG and C be a component of PG− v such that C
does not contain any other cut vertex of PG. In other words, C+ v induces a biconnected
component of PG. There are two cases:
1. PL(v) = P or N. By Lemma 44, P is a probe bipartite distance-hereditary graph if and
only if both P[C + v] and P − C are probe bipartite distance-hereditary graphs. Call Al-
gorithm C’ to check whether P[C + v] has an embedding and recursively call the main
algorithm to check whether P − C has an embedding.
2. PL(v) = U. Let P^ be the probe graph (PG[C+v], P^L) where P^L(v) = P and P^L(x) = PL(x)
for x ∈ C. Let Pˇ be the probe graph (PG[C + v], PˇL) where PˇL(v) = N, PˇL(x) = P for
x ∈ NPG (v) ∩ C, and PˇL(x) = PL(x) for x ∈ C − NPG (v). Let P
′ be the probe graph
(PG[V − C],P
′
L) where P
′
L(v) = P and P
′
L(x) = PL(x) for x ∈ V − C − v. Let P
′′ be the
probe graph (PG[V − C],P
′′
L ) where P
′′
L (v) = N, P
′′
L (x) = P for x ∈ NPG (v) ∩ (V − C), and
P ′′L (x) = PL(x) for x ∈ V − C −NPG [v]. Call Algorithm C’ to check whether P^ and Pˇ have
embeddings. There are four subcases:
(a) If neither P^ nor Pˇ is a probe bipartite distance-hereditary graph, then P is not a probe
bipartite distance-hereditary graph.
(b) If both P^ and Pˇ are probe bipartite distance-hereditary graphs, then P is a probe
bipartite distance-hereditary graph if and only if P −C is a probe bipartite distance-
hereditary graph. Recursively call the main algorithm to check whether P − C has
an embedding.
(c) If P^ is a probe bipartite distance-hereditary graph but Pˇ is not, then P is a probe
bipartite distance-hereditary graph if and only if P ′ is a probe bipartite distance-
hereditary graph. Recursively call the main algorithm to check whether P ′ has an
39
Suppose there exists a pair of false twins x and y in GC. Removing v from GC + v
only changes the neighborhood of vertices in NGC (u), where u and v are false twins in
GC+ v. Hence one of x,y ∈ NGC (u). If x,y ∈ NGC (u), they are false twins in GC + v, a
contradiction. If x ∈ NGC (u) but y 6∈ NGC [u], then they are not false twins in GC since y
is not adjacent to u, a contradiction. Similarly, we can show that there are no false twins
in GC+ v − u.
Suppose GC is non-biconnected. If u is not a cut vertex, let x 6= u be a cut vertex of
GC. Let C1 and C2 be two components ofGC−x. SinceGC+v is biconnected, v is adjacent
to some vertex of C1 and some vertex of C2 in GC + v. Since u and v are false twins in
GC+v, in GC u is adjacent to some vertex of C1 and some vertex of C2, a contradiction to
the assumption that x 6= u is a cut vertex. Hence u is the only cut vertex in GC. Similarly,
we can show v is the only cut vertex of GC+ v− u. 2
Corollary 46. The probe graph P[C + v] produced in Case 1. of Algorithm R’ and the probe
graphs P^ and Pˇ produced in Case 2. of Algorithm R’ are pseudo-kernel probe bipartite graphs.
In addition, if u and v are the only pair of false twins in PG[C + v], after removing a false
twin according to Lemma 39 from P[C + v], P^, and Pˇ, the resulting probe graph R is a
pseudo-kernel probe bipartite graph.
Proof. Note that PG[C + v] satisfies one of the conditions of Theorem 45 and v is not a
prime. Assume u is the false twin of v. By the steps of removing false twins according
to Lemma 39, if v is a probe, we remove u; if v is a nonprobe and u is a nonprobe or a
prime, we remove u; if v is a nonprobe and u is a probe, we remove v. After removing
false twins, if the resulting probe graph R is biconnected, by Theorem 45 it is a kernel
probe bipartite graph. Assume R is non-biconnected, by Theorem 45 one of u and v is the
only cut vertex of R. Moreover, the only cut vertex in R is not a prime. 2
Now we are ready to describe Algorithm C’. The input of Algorithm C’ is a two-tuple
(P, v) where P is a pseudo-kernel bipartite probe graph and v is a vertex in P with PL(v) =
P or N. Note that if PG is biconnected, it has at most one pair of false twins and v is one
41
4.3 Partially partitioned probe ptolemaic graphs
In this section, we give an O(n3)-time algorithm to recognize probe ptolemaic graphs.
This algorithm is a recursive one. We denote the input probe graph by P. The algorithm
first checks whether P is feasible. If P is not feasible, then it is not a probe ptolemaic
graph. Set PL(u) = P for all vertices of u ∈ PU that is adjacent to v ∈ PV with PL(v) = N.
This can be done in linear time. In the following assume P is feasible, i.e., all neighbors
of a nonprobe must be probes. The algorithm checks to which of the following classes the
input probe graph P does belong and takes action accordingly:
PP 1. PG has true twins. If it has one, reduce the size of P according to Theorem 49 and
solve the problem recursively. The theorem and the reduction steps will be described
in Section 4.3.1.
PP 2. |PV| 6 c for some constant c. Solve the problem by brute force in O(1) time.
PP 3. PG is biconnected and without true twins. Call Algorithm BP, to be given in Sec-
tion 4.3.3, to solve the problem.
PP 4. PG is not biconnected and without true twins. Call Algorithm RP, to be given in
Section 4.3.2 to solve the problem recursively.
PP 5. P is fully partitioned. Use the O(nm)-time algorithm, Algorithm F, to be given in
Section 4.3.4.
It is easy to see the correctness of the algorithm if the algorithm for each class of input
is correct. We analyze the time complexity of the algorithm in Section 4.3.5.
4.3.1 True twins
In this subsection we first give two theorems that can be used to solve the problem recur-
sively.
Lemma 49. Suppose P is a probe graph and u and v are true twins in PG satisfying one of
the following conditions.
1. PL(u) = PL(v) = P or U.
43
Lemma 51. Let P be a probe graph. If there exists a cut vertex v in P and C is a component
of PG− v, then P is a probe ptolemaic graph if and only if P −C has a ptolemaic embedding
P ′ and P[C + v] has a ptolemaic embedding P ′′ where either P ′L(v) = P
′′
L (v) = P or P
′
L(v) =
P ′′L (v) = N.
Proof. If P has a ptolemaic embedding P∗, then P∗[C + v] is a ptolemaic embedding of
P[C + v] and P∗ − C is a ptolemaic embedding of P − C.
Suppose that PL(v) = P or N. By Lemma 50,P
∗ = P ′ + P ′′ is a ptolemaic embedding of P.
Suppose that PL(v) = U. If P[C + v] has no ptolemaic embedding that v is a probe
or a nonprobe, then P is not a probe ptolemaic graphs. If P[C + v] has a ptolemaic
embedding P^ that v is a probe but has no ptolemaic embedding that v is a nonprobe,
then P has a ptolemaic embedding if and only if P − C has a ptolemaic embedding that
v is a probe. Conversely, if P[C + v] has a ptolemaic embedding Pˇ that v is a nonprobe
but has no ptolemaic embedding that v is a probe, then P has a ptolemaic embedding
if and only if P − C has a ptolemaic embedding that v is a nonprobe. If P[C + v] has a
ptolemaic embedding P^ that v is a probe and P[C + v] has a ptolemaic embedding Pˇ that
v is a nonprobe, then P has a ptolemaic embedding if and only if P − C has a ptolemaic
embedding. 2
The proof of the above lemma is constructive. It points out a recursive way to solve
the problem. We now describe Algorithm RP in detail. Let v be a cut vertex of PG and
C be a component of PG − v such that C does not contain any other cut vertex of PG. In
other words, C+ v induces a biconnected component of PG. There are two cases:
1. PL(v) = P or N. By Lemma 51, P is a probe ptolemaic graph if and only if both
P[C + v] and P − C are probe ptolemaic graphs. Call Algorithm C to check whether
P[C+v] has a ptolemaic embedding and recursively call the main algorithm to check
whether P − C has a ptolemaic embedding.
2. PL(v) = U. Let P^ be the probe graph (PG[C + v], P^L) where P^L(v) = P and P^L(x) =
PL(x) for x ∈ C. Let Pˇ be the probe graph (PG[C+v], PˇL) where PˇL(v) = N, PˇL(x) = P
45
following statements holds.
(i) There are no true twins in GC+ v.
(ii) There is only one pair of true twins in GC+v, v is one of the true twins. After removing
one of the pair of true twins from GC + v, the resulting graph has no true twins and
either it is biconnected or it has only one cut vertex which is one of the pair of true twins
in GC+ v.
Proof. Since G has no true twins, no x,y ∈ GC are true twins in GC+v. After the decom-
position, only the neighborhood of the vertex used to decompose the graph is changed.
Hence v must be one of the pair of twins, and there exists only one vertex u in GC that u
and v are true twins in GC+ v.
Suppose there exists a pair of true twins x and y in GC. Removing v from GC+ v only
changes the neighborhood of vertices in NGC [u], where u and v are true twins in GC+ v.
Hence one of x,y ∈ NGC [u]. If u = x and y ∈ NGC (u), y and v are true twins in GC+ v, a
contradiction. Suppose x 6= u and y 6= u. If x,y ∈ NGC (u), they are true twins in GC+ v,
a contradiction. If x ∈ NGC (u) but y 6∈ NGC [u], then they are not true twins in GC since
y is not adjacent to u, contradiction. Hence there are no true twins in GC. Similarly, we
can show that there are no true twins in GC+ v− u.
Suppose GC is non-biconnected. If u is not a cut vertex, let x 6= u be a cut vertex of
GC. Let C1 and C2 be two components ofGC−x. SinceGC+v is biconnected, v is adjacent
to some vertex of C1 and some vertex of C2 in GC + v. Since u and v are ture twins in
GC+v, in GC u is adjacent to some vertex of C1 and some vertex of C2, a contradiction to
the assumption that x 6= u is a cut vertex. Hence u is the only cut vertex in GC. Similarly,
we can show v is the only cut vertex of GC+ v− u. 2
Corollary 53. The probe graph P[C+ v] produced in Case 1. of Algorithm RP and the probe
graphs P^ and Pˇ produced in Case 2. of Algorithm RP are pseudo-kernel probe graphs. In
addition, if u and v are the only pair of true twins in PG[C + v], after removing a true twin
according to Lemma 49 from P[C+v], P^, and Pˇ, the resulting probe graph R is a pseudo-kernel
47
Lemma 54. Whether a partially partitioned pseudo-kernel probe graph is a probe ptolemaic
graph can be checked in O(n3) time.
Proof. Let g(n) denote the time complexity of Algorithm CP. We claim that g(n) 6 c1n
3.
The input graph of class E 1 can be recognized in O(1) time. The input graph of class E 2
can be recognized in O(n3) time. The input graph of class E 3 can be recognized in g(n−
1)+c0(n+m) time where c0(n+m) is the time spent for decomposing the input graph into
biconnected components and removing a twin from it. It is easy to see that g(n−1)+c0(n+
m) 6 c1n
3 if c1 > 2c0. The input of class E 4 can be recognized in Σ
r
i=1g(ni) + c0(n+m)
time where ni = |Ci| and C1,C2, . . . ,Cr are biconnected components in PG. Assume that
Cr has the maximum number of vertices among C1,C2, . . . ,Cr.
g(n) = Σri=1g(ni) + c0(n +m)
6 g(n1) + g(n − n1+ 1) + c0(n +m)
6 g(a + 1) + g(n− a) + c0(n+m)
6 c1(a+ 1)
3 + c1(n − a)
3+ c0(n +m)
6 c1(a
3 + 3a2 + 3a+ 1) + c1(n
3− 3an2 + 3a2n− a3) + c0n
2
6 c1n
3− (3c1an
2 − c0n
2 − 3c1a
2n − 3c1a
2 − 3a− 1)
6 c1n
3 if c1 > c0.
This completes the proof. 2
4.3.3 Biconnected probe graph and Algorithm BP
In the subsection we deal with the case that input graph P is of class PP 3, i.e., P is
biconnected without true twins. We will show that whether such a probe graph P is a
probe ptolemaic graph can be recognized in O(n3) time. First pick an edge (x,y) of PE
that neither x nor y is a universal vertex in PG. For any edge (x,y) of PE, if both x and y
are universal vertices in PG, then x and y are true twins, a contradiction to our assumption
that there are no true twins in PG. Suppose that x is a universal vertex. If PG contains
49
Proof. Since NG∗(C
∗) only contains nonprobes, there exists a probe q in C∗ ∩ Z2 that is
adjacent to all vertices of NG∗(C
∗) in G. Hence {p,y1,y2,q} induces a 4-cycle in G. By
Corollary 12 y1 and y2 are true twins in G
∗. Since for any y1,y2 ∈ NG∗(C) P
∗
L(y1) =
P∗L(y2) = N, they are false twins in G. 2
Lemma 57. Suppose in P u, v ∈ L1 are false twins and N
+
G(u) 6= ∅. Then P is probe
ptolemaic graph if and only if P − v is probe ptolemaic graph.
Proof. If P has an embedding P∗, obviously P∗ − v is a ptolemaic embedding of P − v.
Since p ∈ L0 is adjacent to u and v, puqvp is an induced cycle of length four in G where
q ∈ N+G(u). Since p is a probe, by Lemma 19, u and v must be nonprobes in P
∗. Thus
we can always attach v as a true twin of u in the embedding of P − v. This proves the
lemma. 2
If NG∗(C
∗) only contains nonprobes, they are false twins in G. By Lemma 57, we
can remove these false twins in G. After removing all false twins following Lemma 57,
|NG∗(C
∗)| = 1. Thus there exists a cut vertex in L1 that is a nonprobe. By Lemma 51 we
can recognize each component separately.
In the following, we may assume that for every minimal componentC∗ ofG∗2,NG∗(C
∗)
contains exactly a probe.
Lemma 58. If for every minimal connected component C∗ of G∗2, NG∗(C
∗) contains exactly
a probe, then by hanging the same p in G L2 = Z2.
Proof. Since for every minimal connected component its neighborhood contains exactly
a probe in Z1, every vertex in Z2 is adjacent to at least a probe in Z1. Because Z1 = L1,
we have Z2 = L2. 2
If there exists some minimal component C∗ of G∗3 whose neighborhood only contains
nonprobes, they are false twins in G. By the same process following Lemma 57, we can
remove all false twins that are contained in the neighborhood of the minimal component
51
ptolemaic graph, G has a ptolemaic embedding H. If we hang the same vertex p in H, we
can obtain a hanging Ψ = (Z0,Z1, . . . ,Zh) where Z0 = {p} and Zi = {v | dH(v,p) = i}.
Since p is a probe, Z0 = L0 and Z1 = L1. The algorithm will give all possible partitions
of the input graph that is to label all vertices in U to be probes or nonprobes. Once we
have a partition of the input graph, we can check whether it is a valid partition by the
partitioned probe ptolemaic graph recognition algorithm given in Section 4.3.4.
The first step of our algorithm is to label all vertices v ∈ L1 that PL(v) = U andN
+
G(v) 6=
∅. By Lemma 56, for any minimal component C∗ of H2, if all vertices in NH(C
∗) are
nonprobes, they are false twins inG and for any two vertices y1,y2 ∈ NH(C
∗) {p,y1,y2,q}
induces a 4-cycle in G where q ∈ C∗. For any vertex q ∈ L2, if there exists y1,y2 ∈ N
−
Φ(q)
that are not adjacent, then relabel y1 and y2 as nonprobes and relabel q as a probe. Then
we compute if there are two nonprobes in L1 that are false twins. By Lemma 57, we can
always remove a vertex from a pair of false twins in L1 if they have some neighbors in
L2 until there are no two false twins in L1 that have neighbors in L2. After the process of
removing false twins in L1, if there exists a cut vertex in L1, it must be a nonprobe. By
Lemma 50, a cut vertex v in a probe ptolemaic graph is a cut vertex in a minimal probe
ptolemaic embedding. Thus we can check each component C + v of G − v separately.
We may assume that there are no true twins, no two nonprobes that are false twins, nor
cut vertex in L1. According to the assumption, by Lemma 58 the neighborhood of every
connected component of G2 contains at least a probe and Z2 = L2. For any minimal
component C∗ of H2, NG(C
∗) only contains two vertices y and y ′ that are adjacent. We
can label y as a probe and y ′ as a nonprobe if NG(y
′) ⊂ NG(y). For any vertex v ∈ L1
that PL(v) = U and N
+
Φ(v) 6= ∅, there exists a component C of H2 that v ∈ NH(C). Since
for any component of H2, its neighborhood induces a clique in H, v, y, and y
′ must
be in the same induced clique in the embedding for some minimal component C∗ that
NH(C
∗) = {y,y ′}. Thus, for any v ∈ L1 that PL(v) = U, relabel v as a probe if it is adjacent
to both y and y ′ in G, or relabel v as a nonprobe if it is only adjacent to y but not adjacent
to y ′. Thus for any vertex v ∈ L1 that N
+
Φ
(v) 6= ∅, we can label it is as a probe or a
53
Proof. It takes O(n + m) time to label primes into nonprobes. It takes O(n2) time to
remove false twins in the same layer of the hanging. Suppose g1(n) denote the time
complexity to check whether a biconnected probe graph without true twins is a probe
ptolemaic graph. We have the following recursive formula to denote the algorithm de-
compose the probe graph into biconnected component according to the cut vertex that
we obtain after removing twins.
g1(n) = g1(a + 1) + g1(n − a) +O(n
2)
Suppose g1(n) 6 c3n
3 and a = βn.
g1(n) = g1(βn+ 1) + g1(n − βn) + c1(n +m)
6 c3(βn+ 1)
3 + c3(n− βn)
3 + c1n
2
= c3(β
3n3+ 3β2n2 + 3βn+ 1) + c3(n
3 − 3βn3 + 3β2n3− β3n3) + c1n
2
= c3(1− 3β + 3β
2)n3 + (3c3β
2 + c1)n
2 + 3c3βn+ c3
6 c3n
3 if 0 < β < 1.
The last step holds as long as c3 > c1 and n > 10. This completes the proof. 2
4.3.4 Fully-partitioned probe graphs and Algorithm F
In this subsection, we give an O(nm)-time algorithm to recognize fully partitioned probe
ptolemaic graphs. We call the algorithm Algorithm F. Suppose P is a fully partitioned
probe graph. Given a probe x and a nonprobe y in P, we say x and y are probe true twins
if NG[y] ⊆ NG[x] and NG[x] −NG[y] only contains nonprobes.
Lemma 62. Suppose P is a fully partitioned probe graph and u and v are probe true twins
with PL(u) = P and PL(v) = N. Then P is a probe ptolemaic graph if and only if P − v is a
probe ptolemaic graph.
55
F 1 |PV| 6 c for some constant c. Solve the problem by brute force in O(1) time.
F 2 P has twins satisfying one of the following conditions.
(a) there are two vertices u and v that are true twins with PL(u) = P and PL(v) = P
or N. By Lemma 49, P is a probe ptolemaic graph if and only if P − v is a probe
ptolemaic graph. Recursively call Algorithm F to check if P − v has a ptolemaic
embedding.
(b) there are two vertices u and v that are false twins with PL(u) = PL(v) = N. By
Lemma 63, P is a probe ptolemaic graph if and only if P−v is a probe ptolemaic
graph. Recursively call Algorithm F to check if P−v has a ptolemaic embedding.
(c) there are two vertices u and v that are probe true twins with PL(u) = P and
PL(v) = N. By Lemma 62, P is a probe ptolemaic graph if and only if P − v is
a probe ptolemaic graph. Recursively call Algorithm F to check if P − v has a
ptolemaic embedding.
F 3 P is biconnected and without any twins described in F 2. By Lemma 64, P is not a
probe ptolemaic graph.
F 4 P is not biconnected and without any twins described in F 2. By Lemma 50, a cut
vertex of a probe ptolemaic graph is a cut vertex of its minimal ptolemaic embedding.
Let v be a cut vertex of PG and C be a component of PG − v such that C does not
contain any other cut vertex of PG. In other words, C + v induces a biconnected
component of PG. By Lemma 51, P is a probe ptolemaic graph if and only if both
P[C+v] and P−C are probe ptolemaic graphs. Recursively call Algorithm G to check
(P[C+v], v) and recursively call Algorithm F to check whether P−C has a ptolemaic
embedding.
For simplifying the description, in the rest of the subsection we call two vertices satis-
fying one of the conditions of F 2 in Algorithm F twins.
Lemma 65. Suppose P is a probe graph having no twins satisfying any condition of F 2 in
Algorithm F and v is a cut vertex of P. Assume C is a component of P−v that has no other cut
vertex of P. If P is a probe ptolemaic graph, then P[C+v] has exactly a pair of twins satifying
57
Now we are ready to describe Algorithm G. Note that the input of Algorithm G is a
two-tuple (P, v) where P is a pseudo-kernel probe graph and v ∈ PV is either one of the
only twins in P or the only cut vertex in P.
Algorithm G
G 1 |PV| 6 c for some constant c. Solve the problem by brute force in O(1) time.
G 2 v has a twin u satisfying one of the following conditions.
(a) PL(v) = P and PL(u) = P or N. By Lemma 49, 62, and 63, P is a probe ptolemaic
graph if and only if P−u is probe ptolemaic graph. Recursively call Algorithm G
to check (P − u, v).
(b) PL(v) = N and PL(u) = P. By Lemma 49 and 62, P is a probe ptolemaic graph
if and only if P − v is probe ptolemaic graph. Recursively call Algorithm G to
check (P − v,u).
(c) PL(v) = P and PL(u) = P or N. By Lemma 63, P is a probe ptolemaic graph
if and only if P − u is probe ptolemaic graph. Recursively call Algorithm G to
check (P − u, v).
G 3 P is biconnected without twins, output P is not a probe ptolemaic graph.
G 4 P is non-biconnected without twins and v is the only cut vertex in PG. Compute
the biconnected component decomposition of PG. Assume that C1,C2, . . . ,Cr are
biconnected components of PG. For i = 1, . . . , r recursively call Algorithm G to
check (P[Ci], v).
Lemma 66. There exists an O(nm)-time algorithm to check whether a fully-partitioned
pseudo-kernel probe graph is a probe ptolemaic graph.
Proof. Since removing a twin and computing the biconnected component decomposition
of a pseudo-kernel probe graph can be done in O(n + m) time. For an input (P, v) of
Algorithm G, it takes O(n + m) time to find the only twin u of v and to compute the
biconnected component decomposition of P−u (resp. P−v). Let g(n) denote the running
time of Algorithm G. The algorithm spends c0(n+m) time to remove a twin and to comput
59
removing all twins. Let C1,C2, . . .Ck be the biconnected components produced by F 6
of Algorithm F in each recursive call. Let c0(n
′ + m ′) denote the time spent on finding
the biconnected component C+ v and on removing the only pair of twins in P[C+ v] and
P−C. Assume |Ci| = ni for i = 1, . . . ,k. Letmi denote the number of edges in PG[Ci]. We
use g(ni) to denote the time spent by Algorithm G for checking whether P[Ci] is a probe
ptolemaic graph, i = 1, . . . ,k.
f1(n
′) = g(n1) + f1(n
′ − n1 + 1) + c0(n
′ +m ′)
6 g(n1) + g(n2) + f1(n
′ − n1 − n2+ 2) + 2c0(n
′ +m ′)
6 g(n1) + · · · + g(nk) + c0k(n
′ +m ′)
= Σki=1g(nimi) + c0k(n
′ +m ′)
= Σki=1c1nimi + c0k(n
′ +m ′)
6 c1(n
′ − 1)Σki=1mi+ c0k(n
′ +m ′)
6 c1n
′m ′ − c1m
′ + c1n
′(m ′ +m ′)
6 c2n
′m ′ where c2 > 3c1
= O(n ′m ′)
Since f(n) = f1(n
′) +O(n2) and f1(n
′) = O(n ′m ′), f(n) = O(nm). 2
4.3.5 Time complexity
Theorem 68. There exists anO(n3) algorithm to recognize partially partitioned probe ptole-
maic graphs.
Proof. The algorithm for recognizing probe ptolemaic graphs is of two stages. The first
stage of the algorithm is to label the input partially partitioned probe graph into a fully
partitioned probe graph. Then the algorithm proceeds the second stage to check whether
the fully-partitioned probe graph a probe ptolemaic graph by the O(nm) algorithm given
61
5 結果與討論
In this report, we demonstrate the following results.
1. anO(nm)-time recognition algorithm for partially partitioned probe distance-hereditary
graphs,
2. anO(nm)-time recognition algorithm for partially partitioned probe bipartite distance-
hereditary graphs,
3. anO(n3)-time recognition algorithm for partially partitioned probe ptolemaic graphs,
and
4. an O(nm)-time recognition algorithm for fully partitioned probe ptolemaic graphs.
The graph class, distance-hereditary graphs, has been well-studied since it was intro-
duced by Howorka [18]. It was shown that the rankwidth of distance-hereditary graphs
is at most 1 [23]. The probe graphs of distance-hereditary graphs constitute a generaliza-
tion of distance-hereditary graphs. It is easy to see that the rankwidth of probe distance-
hereditary graphs is at most 2. The recognition of probe distance-hereditary graphs can be
formulated in C2MS formula. It is known in [13] a graph class can be recognized in O(n
3)
by formulating the problem in C2MS formulas [13] if the rankwidth of graphs in the graph
class is bounded. In this project, we give a more efficient algorithm for the recognition of
probe distance-hereditary graph and probe bipartite distance-hereditary graphs. For the
feature works, we hope to use the same idea to develop more efficient algorithms for the
recognition of the other probe graph classes. As we know the partitioned probe graph
recognition problem is a special case of graph sandwich recognition problem. We hope
all of our achievements can be applied to solve the distance hereditary graph sandwich
problem.
63
7 參考文獻
References
[1] H. J. Bandelt, and H. M. Mulder, Distance-hereditary graphs, Journal of Combina-
torial Theory, Series B 41 (1986), pp. 182–208.
[2] A. Berry, M. C. Golumbic, and M. Lipshteyn, Recognizing Chordal Probe Graphs
and Cycle-Bicolorable Graphs, SIAM J. Discrete Math., 21 (2007), pp. 573–591.
[3] A. Brandsta¨dt, V. B. Le, and J. P. Spinrad, Graph classes: A survey, SIAM Mono-
graphs on Discrete Mathematics and Applications, Philadelphia, 1999.
[4] D. B. Chandler, M.-S. Chang, T. Kloks, J. Liu, and S.-L. Peng, Recognition of probe
cographs and partitioned probe distance hereditary graphs, Proceedings of AAIM
2006, LNCS 4041, 267-278.
[5] D. B. Chandler, J. Guo, T. Kloks, and R. Niedermeier, Probe matrix problems: to-
tally balanced matrices, Proceeding of AAIM 2007, LNCS 4508 (2007), pp. 368–
377.
[6] D. B. Chandler, M.-S. Chang, T. Kloks, J. Liu, and S.-L. Peng, Partitioned probe
comparability graphs, Theoretical Computer Science, 396 (2008), pp. 212–222.
[7] D. B. Chandler, M.-S. Chang, T. Kloks, V. B. Le, and S.-L. Peng, Probe ptolemaic
graphs, Proceedings of COCOON 2008, LNCS 5092 (2008), pp. 468–477.
[8] D. B. Chandler, M.-S. Chang, A. J.J. Kloks, J. Liu, and S.-L. Peng, On probe permu-
tation graphs, Discrete Applied Mathematics, 157 (2009), pp. 2611–2619.
[9] Chandler D. B., M.-S. Chang, T. Kloks, and S.-L. Peng, Probe graphs. Manuscript,
2009; on-line version available:
http://www.cs.ccu.edu.tw/˜ hunglc/ProbeGraphs.pdf
65
[21] V. B. Le and H. N. de Ridder, Characterisations and linear-time recognition of probe
cographs. Proceedings of WG 2007, LNCS 4769 (2007), pp. 226–237.
[22] R. M. McConnell and Y. Nussbaum, Linear-time recognition of probe interval
graphs, to appear in Proceedings of ESA2009.
[23] S. Oum, Rank-width and vertex-minors, Journal of Combinatorial Theory, Series B,
95 (2005), pp. 79–100.
[24] P. E. Zhang, A. Schon, S. G. Fischer, E. Cayanis, J. Weiss, S. Kistler, and E. Bourne,
An algorithm based on graph theory for the assembly of contigs in physical map-
ping of DNA, CABIOS 10 (1994), pp. 309–317.
67
Recognition of Probe Cographs and Partitioned
Probe Distance Hereditary Graphs
David B. Chandler1, Maw-Shang Chang2,, Ton Kloks,
Jiping Liu3, and Sheng-Lung Peng4
1 Institute of Mathematics, Academia Sinica
Nangang, Taipei 11529, Taiwan
chandler@math.sinica.edu.tw
2 Department of Computer Science and Information Engineering
National Chung Cheng University
Chiayi 62107, Taiwan
mschang@cs.ccu.edu.tw
3 Department of Mathematics and Computer Science
The University of Lethbridge
Alberta, T1K 3M4, Canada
4 Department of Computer Science and Information Engineering
National Dong Hwa University
Hualien 974, Taiwan
lung@csie.ndhu.edu.tw
Abstract. Given a class of graphs G, a graph G is a probe graph of G if
its vertices can be partitioned into two sets P (the probes) and N (non-
probes), where N is an independent set, such that G can be embedded
into a graph of G by adding edges between certain vertices of N. If the
partition of the vertices into probes and nonprobes is part of the input,
then we call the graph a partitioned probe graph of G. We give the ﬁrst
polynomial-time algorithm for recognizing partitioned probe distance-
hereditary graphs. By using a novel data structure for storing a multiset
of sets of numbers, the running time of this algorithm is O(n2), where
n is the number of vertices of the input graph. We also show that the
recognition of both partitioned and unpartitioned probe cographs can be
done in O(n2) time.
1 Introduction
To analyze long DNA sequences, restricted enzymes are used to cut the DNA into
smaller fragments called clones. The clones are then reproduced many times
for further research. To resequence the DNA strand, tests are performed to de-
termine whether a pair of clones overlap in the longer DNA sequence. In DNA
 The author thanks the Institute of Information Science of Academia Sinica of Tai-
wan for their hospitality and support where part of this research took place, and is
partially supported by the National Science Council of Taiwan, NSC94-2213-E-194-
009.
 Supported by the National Science Council of Taiwan, grant NSC94-2627-B-007-001.
S.-W. Cheng and C.K. Poon (Eds.): AAIM 2006, LNCS 4041, pp. 267–278, 2006.
c© Springer-Verlag Berlin Heidelberg 2006
Recognition of Probe Cographs 269
In this paper, we solve the partitioned probe recognition problem for two
graph classes, namely, for the class of distance hereditary graphs and for the
class of cographs. We give the ﬁrst polynomial-time recognition algorithm for
probe distance-hereditary graphs. By using a novel data structure for storing a
multiset, the running time of this algorithm is O(n2), where n is the number of
vertices of the graph. We also show that the recognition of both partitioned and
unpartitioned probe cographs can be done in O(n2) time.
2 Recognizing Partitioned Probe Distance Hereditary
Graphs
A graph G is a pair G = (V, E), where the elements of V are called the vertices
of G, and where E is a family of two-element subsets of V called the edges. We
denote edges of a graph G as (x, y) and we call x and y the endvertices of the
edge. Unless stated otherwise, a graph is regarded as undirected. For a vertex x
we write N(x) for its set of neighbors, and N[x] = N(x) ∪ {x}. We write n = |V |
for the number of vertices and m = |E| for the number of edges. For a graph
G = (V, E) and a subset S ⊆ V of vertices, we write G[S] for the subgraph of G
induced by S. For a subset W ⊆ V of vertices of a graph G = (V, E) we write
G − W for the graph G[V − W], i.e., the subgraph induced by V − W. For a
vertex x we write G − x rather than G − {x}.
Deﬁnition 2 ([14]). A graph is distance hereditary if the distance between any
two vertices in any connected induced subgraph equals the distance in the original
graph.
Deﬁnition 3. A pendant vertex in a graph is a vertex of degree 1.
Deﬁnition 4. A twin in a graph is a module1 with two vertices. A twin is true
if the vertices are adjacent. Otherwise the twin is false.
Theorem 1 ([1]). Let G be a graph. The following conditions are equivalent:
1. G is distance hereditary.
2. G does not contain a house, hole, domino, or gem as an induced subgraph.
3. Every connected induced subgraph of G with at least two vertices has a pendant
vertex or a twin.
4. For every pair of vertices x and y with d(x, y) = 2, there is no induced x, y-
path of length greater than 2.
Aﬃrmation of membership in the class of distance-hereditary graphs can be
obtained using a linear-time algorithm [7, 10, 15].
Deﬁnition 5. Let G = (P+N, E) be a partitioned graph. A pair of vertices {x, y}
is a probe twin if one of the following holds:
1 A module is a subset M of vertices such that for all vertices x, y ∈ M and z ∈ V −M
(x, z) ∈ E if and only if (y, z) ∈ E.
Recognition of Probe Cographs 271
test whether there are two sets that are equal in the multiset. In the following we
describe the data structure ﬁrst, and then the implementation of the recognition
algorithm using the data structure.
A multiset diﬀers from a set in that each element has a multiplicity, which
is a natural number indicating (loosely speaking) how many times it is in the
multiset. In this paper we consider multisets whose elements are subsets of V =
{1, . . . , n} and denote them by calligraphic capitals, like S. For clarity of notation,
we use {1, 2, 3} for a normal set with elements 1, 2, and 3 and use {∗ 2, 2, 3 ∗}
for a multiset with elements 2, 2, and 3. It is possible that the empty set is an
element of a multiset S.
Deﬁnition 6. The representative of a nonempty multiset S, denoted by r(S), is
deﬁned as follows. If |S | = 1 or when all sets in S are equal then let r(S) = n+1.
Otherwise, r(S) is the smallest number r such that there exist U,U′ ∈ S, with
r ∈ U and r /∈ U′.
We recursively deﬁne as follows a binary tree, RT(S), for a multiset S. The binary
tree RT(S) is a rooted tree. Each node x in RT corresponds with a multiset X (x),
and is associated with a list Υ(x) (possibly nil), which is the set of “univer-
sal” elements less than r(X (x)) contained in all elements of X (x), in increasing
order. We also use Υ(x) to denote the corresponding set. The label (x) is the
representative r(X (x)).
1. If r(S) = n+ 1, then RT is a tree consisting of one node x which is the root.
In this case, X (x) = S, Υ(x) is the ordered list of elements of any set in S,
and (x) = r(S).
2. Suppose r(S) ≤ n. For the root x of RT, X (x) = S, Υ(x) is the ordered list
of {s | s < r(S) and s ∈ U for all U ∈ S}, and (x) = r(S). Let SL and SR be
two multisets where
SL = {∗ U − Υ(x) | U ∈ S and r(S) /∈ U ∗}, and
SR = {∗ U − (Υ(x) + (x)) | U ∈ S and r(S) ∈ U ∗} .
The left and right children of x are the root of RT(SL) and the root of RT(SR),
respectively.
Denote the root of RT(S) by ρ(S). For each leaf node x of RT, let P(x) be the
path in RT from x to ρ. For each edge (y, z) of P(x), let S(y, z) = Υ(z) if z is
the left child of y and S(y, z) = (y) + Υ(z) if z is the right child of y. Let S(x)
denote the set that is the union of S(y, z)’s of all edges (y, z) visited by P(x),
where z is a child of y, and Υ(ρ(S)).
For example, let
n = 6, S = {∗ {1, 2, 3}, {1, 2, 3}, {1, 2, 4, 5}, {1, 4, 5, 6}, {1, 4, 5, 6} ∗} .
Then RT(S) is a tree with ﬁve vertices, x1, x2, x3, x4, and x5, where x1 is
the root, x2 and x3 are the left and right children of x1, respectively, and x4
and x5 are the left and right children of x3, respectively. Then (x1) = 2,
Recognition of Probe Cographs 273
r(S′), respectively. We describe procedure merge(x, x′) recursively as follows.
Assume r ≤ r′. The case where r > r′ can be done in a similar way.
Compute r∗ = r({Υ(x), Υ(x′)}). Since Υ(x) and Υ(x′) are in increasing order,
r∗ can be computed in O(|{s | s ∈ Υ(x), s ≤ r∗}| + 1) time. There are several
cases. In the following, for an internal node z let zL and zR denote the left and
right children of z. If z is not the root, denote the parent of z by zP.
1. r∗ = n + 1. By deﬁnition, Υ(x) = Υ(x′). All sets in S + S′ contain Υ(x).
(a) r = n + 1. By the assumption, r = r′ = r∗ = n + 1. Hence all sets in
S+S′ are equal. Both RT(S) and RT(S′) are trees of a single node. Output
the tree obtained from RT(S) by replacing X (x) with X (x) + X ′(x′ as
RT(S + S′). The list of X (x) + X ′(x) can be obtained in O(1) time by
concatenating the two lists.
(b) r < n + 1. There are two cases.
i. r = r′. Some sets in S and in S′, but not all of them, contain r.
Call merge(xL, x′L) and merge(xR, x
′
R), recursively. Then replace
the subtrees of RT(S) rooted at xL and xR with the trees returned
by merge(xL, x′L) and merge(xR, x
′
R), respectively, and output the
tree rooted at x.
ii. r < r′. All sets in S′ do contain Υ(x) = Υ(x′) but do not contain any
number k where r ≤ k < r′. Replace Υ(x′) with the empty set. Call
merge(xL, x′), recursively. Replace the subtree of RT(S) rooted at
xL with the tree merge(xL, x′), and output the tree rooted at x.
2. r < r∗ < n + 1. Clearly, r∗ /∈ Υ(x) but r∗ ∈ Υ(x′). All sets in S′ contain
Υ(x) but do not contain any number k where r ≤ k < r∗. Replace Υ(x′) with
{s ∈ Υ(x′) | s ≥ r∗}. Call merge(xL, x′), recursively. Replace the subtree of
RT(S) rooted at xL by merge(xL, x′). Output the tree rooted at x.
3. r = r∗ < n + 1. All sets in S′ contain both r and Υ(x). Replace Υ(x′) by
{s ∈ Υ(x′) | s > r}. Call merge(xR, x′), recursively. Replace the subtree of
RT(S) rooted at xR with the tree merge(xR, x′). Output the tree rooted at
x.
4. r∗ < r. Assume r∗ ∈ Υ(x). Then r∗ ∈ S for all S ∈ S and r∗ /∈ S′ for any
S′ ∈ S′. Create a new node y as the root of RT(S + S′). Let Υ(y) = {s ∈
Υ(x) | s < r∗} and (y) = r∗. Let x be the right child of y and Υ(x) = {s ∈
Υ(x) | s > r∗}. Let x′ be the left child of y, and Υ(x′) = {s′ ∈ Υ(x′) | s′ > r∗}.
Output the tree rooted at y. The case where r∗ ∈ Υ(x′) is similar.
Lemma 4. One can merge two binary trees RT(S) and RT(S′) of two multisets
S and S′, respectively, into the binary tree RT(S + S′) of multiset S + S′ in
O(‖RT(S)‖ + ‖RT(S′)‖ − ‖RT(S + S′)‖ + |S | + |S′|) time.
Proof. The proof is by induction. There are several cases in the merge procedure.
We present a tithe in this extended abstract. The whole hog can be found in the
full version.
Since numbers in Υ(x) and Υ(x′) are in increasing order, r∗, {s ∈ Υ(x) | s < r∗},
{s ∈ Υ(x) | s > r∗}, and {s′ ∈ Υ(x′) | s′ > r∗} can be obtained in O(|{s ∈
Υ(x) + Υ(x′) | s ≤ r∗}|) time if r∗ < n + 1 and in O(|Υ(x)| + 1) time otherwise.
Recognition of Probe Cographs 275
Lemma 7. Given RT(S), one can determine in O(|S |) time whether there exist
two sets in S that are equal, and ﬁnd them if they exist.
Proof. We can check in O(|S |) time whether there exists a leaf node x of RT(S)
with |X (x)| > 1. unionsq
Lemma 8. For any integer s ∈ {1, . . . , n}, one can obtain RT(S −s) from RT(S)
in O(‖RT(S)‖ − ‖RT(S − s)‖ + |S |) time.
Proof. Follow the pointers of s to ﬁnds all x’s with (x) = s or s ∈ Υ(x). For
a node x with s ∈ Υ(x), remove s from Υ(x). For a node x with (x) = s,
clearly x is not a leaf node. Replace the subtree rooted at x with merge(xL, xR).
Let y be the root of merge(xL, xR). Replace Υ(y) with Υ(y) + Υ(x). Suppose
both nodes u and v have the property that either the label of the node is s
or the list associated with the node contains s. Then it is not hard to verify
that neither u is an ancestor of v nor v is an ancestor of u. Thus all subtrees
of RT(S) rooted at xL, xR, yL, and yR are distinct. Therefore the procedure
merge always merges distinct subtrees, and the number of nodes visited by all
merge procedures is O(|S |). The total size reduction for all merge procedures
is O(‖RT(S)‖ − ‖RT(S − s)‖). By Lemma 4, the deletion of s from S takes
O(‖RT(S)‖ − ‖RT(S − s)‖ + |S |) time. unionsq
Our algorithm maintains four multisets of sets of vertices: S1 = {∗ N[x] | x ∈ P ∗},
S2 = {∗ N(x) | x ∈ P ∗}, S3 = {∗ N[x]∩P | x ∈ P+N ∗}, and S4 = {∗ N(x)∩P | x ∈
P + N ∗}. If one of these has repeated elements, by Lemma 7 a probe twin can
be found in O(n) time, once the four binary trees for these multisets have been
built. The total size of the four binary trees is O(n + m). In addition to the
trees, we maintain the degree of all vertices and a list P of pendant vertices,
vertices of degree one. A pendant vertex can be found in O(1) time from list P.
Whenever we remove a pendant vertex or a probe twin v, we update the degrees
of all vertices and list P in O(|N(v)|) time. The four binary trees are also updated
by deleting the neighborhood sets of the removed pendant or probe twin vertex
and obtaining RT(Si − v) from RT(Si), 1 ≤ i ≤ 4. By Lemma 8, the total time
in deleting vertices from the four binary trees is O(n2), since the initial size of
the four binary trees is O(n + m) and they become empty at the end of the
algorithm. Thus the algorithm can be implemented to run in O(n2) time and
we have the following theorem.
Theorem 3. There exists an O(n2) algorithm to test whether a partitioned
graph G is a partitioned probe distance-hereditary graphs and to ﬁnd an em-
bedding for G in the aﬃrmative case.
3 Recognizing Probe Cographs
A cograph is a graph without an induced P4, i.e., an induced path with four
vertices. Since the complement of a P4 is again a P4, it follows that cographs form
a self-complementary class of graphs. By now there are many characterizations
Recognition of Probe Cographs 277
The vertices of Ω must all be nonprobes (or we have a P4 we cannot destroy)
and we have P = N(a) + N(Ω). Note that this case includes the possibility that
P = N(a)+N(c). Since Ω can be found in O(n+m) time, so can P. The feasible
partition can be tested by an algorithm recognizing partitioned probe cographs.
The case where a, c ∈ P and b, d ∈ N is similar.
Case 2. Assume a, d ∈ N and b, c ∈ P. Similarly to Case 1, if N(a) + N(d) is
not the complete set of probes, then the vertices {a, b, c, d} cannot lie in both H1
and H2. Assume {a, b, c, d} ⊆ V(H1). There exists a nonprobe α ∈ V(H2) ∩ N.
In G, α is adjacent to b and c and not adjacent to a and d. Now, it is easy to
see that P = N(a) + N(α). Find the set
Ω = {α | b, c ∈ N(α) and a ∈ N(α) and d ∈ N(α)}
All vertices of Ω must be nonprobes; otherwise, there exists a house in any
embedding. Thus in this case P = N(a) + N(d) + N(Ω). Since Ω can be found
in O(n + m) time, so can P. unionsq
Obviously, by Theorem 1, cographs are distance hereditary. Cographs can be
characterized as those graphs for which every nontrivial induced subgraph has a
twin [3, Theorem 11.3.3]. Thus, partitioned probe cographs are those partitioned
graphs for which every connected induced subgraph with at least two vertices
has a probe twin. Therefore the recognition algorithm for partitioned probe
distance hereditary graphs can be easily modiﬁed to recognize partitioned probe
cographs. By Theorem 5 we obtain the following theorem.
Theorem 6. There exists an O(n2) algorithm to test whether a graph G is a
(partitioned or unpartitioned) probe cograph and to ﬁnd an embedding for G in
the aﬃrmative case.
In Memoriam
It is with deep sadness that we report the death of our friend Jiping (Jim) Liu
on 14 January 2006, as the result of an automobile accident.
References
1. Bandelt, H. J. and H. M. Mulder, Distance-hereditary graphs, Journal of Combi-
natorial Theory, Series B 41 (1989), pp. 182–208.
2. Berry, A., M. C. Golumbic, and M. Lipshteyn, Two tricks to triangulate chordal
probe graphs in polynomial time, Proceedings 15th ACM–SIAM Symposium on
Discrete Algorithms (2004), pp. 962–969.
3. Bra¨ndstadt, A., Van Bang Le, and J. P. Spinrad, Graph Classes: A Survey , SIAM
Monographs on Discrete Mathematics and Applications, Philadelphia, 1999.
4. Chang, Ge´rard Jennwha, Ton Kloks, and Sheng-Lung Peng, Probe interval bi-
graphs (extended abstract), Electronic Notes in Discrete Mathematics 19 (2005),
pp. 195–201.
5. Chang, Ge´rard Jennwha, Antonius J. J. Kloks, Jiping Liu, and Sheng-Lung Peng,
The PIGs full monty - a ﬂoor show of minimal separators, Proceedings STACS’05 ,
LNCS 3404 (2005), pp. 521–532.
Theoretical Computer Science 396 (2008) 212–222
www.elsevier.com/locate/tcs
Partitioned probe comparability graphs
David B. Chandlera, Maw-Shang Changb, Ton Kloksc, Jiping Liud, Sheng-Lung Penge,∗
aDepartment of Mathematical Sciences, University of Delaware, Newark, DE 19716, United States
bDepartment of Computer Science and Information Engineering, National Chung Cheng University, Chiayi 621, Taiwan
c School of Computing, University of Leeds, Leeds LS2 9JT, UK
dDepartment of Mathematics and Computer Science, The University of Lethbridge, Alberta, T1K 3M4, Canada
eDepartment of Computer Science and Information Engineering, National Dong Hwa University, Hualien 974, Taiwan
Received 5 July 2007; received in revised form 5 January 2008; accepted 17 January 2008
Communicated by D.-Z. Du
In honor of Prof. Dr. J.H. van Lint
Abstract
Given a class of graphs G, a graphG is a probe graph of G if its vertices can be partitioned into a set of probes and an independent
set of nonprobes such that G can be embedded into a graph of G by adding edges between certain nonprobes. If the partition of the
vertices is part of the input, we call G a partitioned probe graph of G. In this paper we show that there exists a polynomial-time
algorithm for the recognition of partitioned probe graphs of comparability graphs. This immediately leads to a polynomial-time
algorithm for the recognition of partitioned probe graphs of cocomparability graphs. We then show that a partitioned graph G
is a partitioned probe permutation graph if and only if G is at the same time a partitioned probe graph of comparability and
cocomparability graphs.
c© 2008 Elsevier B.V. All rights reserved.
Keywords: Graph recognition algorithms; Probe graphs; Comparability graphs; Cocomparability graphs; Permutation graphs
1. Introduction
Let G = (V, E) be a finite, simple, and undirected graph. A vertex subset W ⊆ V is independent if for any two
vertices u, v ∈ W, (u, v) /∈ E. Let G be a class of graphs. A graph G = (V, E) is a probe graph of G if its vertex
set can be partitioned into a set of probes P and an independent set of nonprobes N, such that G can be embedded
into a graph of G by adding edges between certain vertices of N. If the partition is part of the input, then we call G a
partitioned probe graph of G. In this paper we denote a partitioned graph as G = (P + N, E), and when this notation
is used it is to be understood that N is an independent set. Given a partitioned graph G = (P + N, E), the partitioned
probe-G recognition problem of G is to determine whether G is a partitioned probe graph of G.
∗ Corresponding author. Tel.: +886 38634026; fax: +886 38634010.
E-mail addresses: davidbchandler@gmail.com (D.B. Chandler), mschang@cs.ccu.edu.tw (M.-S. Chang), slpeng@mail.ndhu.edu.tw
(S.-L. Peng).
0304-3975/$ - see front matter c© 2008 Elsevier B.V. All rights reserved.
doi:10.1016/j.tcs.2008.01.038
214 D.B. Chandler et al. / Theoretical Computer Science 396 (2008) 212–222
Definition 1. Let E ′ ⊆ E be a subset of edges of a graph G = (V, E). We call (V(E ′), F) (or F) an orientation of
H = (V(E ′), E ′) (or E ′) if F^ = E ′ and F ∩ F−1 = ∅.
Definition 2. A transitive orientation of a graph G = (V, E) is an orientation F of E such that F2 ⊆ F. A graph G is a
comparability graph if G has a transitive orientation.
Given a comparability graph, a transitive orientation of its edges can be obtained in linear time [15,17]. However,
checking the transitivity of the orientation needs a verification phase, for which no faster algorithm is known than a
fast matrix multiplication [9].
Definition 3 (Golumbic [12]). Define the binary relation Γ on the directed edges
−→
E of a graphG = (V, E) as follows.
For xy, xz ∈ E,
−→xy Γ −→xz ⇐⇒ ←−xy Γ ←−xz ⇐⇒ yz /∈ E.
The relation Γ is reflexive and symmetric and its transitive closure Γc is an equivalence relation on
−→
E . The equivalence
classes of Γc partition
−→
E into the implication classes of G. For an implication class A of G, the symmetric closure
A^ = A+A−1 is called a color class of G.
Golumbic [10,11] gave a simple algorithm to test whether a graph G = (V, E) is a comparability graph and to
give it a transitive orientation if it is a comparability graph. The central part of Golumbic’s algorithm is to compute a
G-decomposition of E, defined as follows.
Definition 4. Let G = (V, E) be an undirected graph. A partition E = B^1 + · · · + B^k is called a G-decomposition of
E if Bi is an implication class of G for all i = 1, . . . , k.
Golumbic’s algorithm follows directly from the following theorem.
Theorem 5 (Golumbic [10–12]). Let G = (V, E) be a graph and let E = B^1 + · · · + B^k be a G-decomposition. The
following statements are equivalent.
(i) G is a comparability graph;
(ii) A ∩A−1 = ∅ for all implication classes A of G;
(iii) Bi ∩ B−1i = ∅ for i = 1, . . . , k.
Furthermore, if these conditions hold, then B1 + · · ·+ Bk is a transitive orientation of E.
By Theorem 5, we can test whether a graph G = (V, E) is a comparability graph and give G a transitive orientation
through computing a G-decomposition. Golumbic [10–12] gave an algorithm to compute a G-decomposition in
O(∆ ·m) time where ∆ is the maximum degree of G.
3. Recognition of partitioned probe comparability graphs
In this section we extend the algorithm for recognizing comparability graphs given by Golumbic [10–12] such that
it permits a recognition algorithm for partitioned probe comparability graphs within the same time bound. Golumbic’s
result shows that a graph G is a comparability graph by showing that G has a transitive orientation. An orientation
of a partitioned probe comparability graph may not be transitive, but the transitive completion may be a transitive
orientation of an embedding. The following proposition is clear from the definitions.
Proposition 6. Let G = (P + N, E) be a partitioned probe comparability graph with an embedding H. Let F be a
transitive orientation of H, F =
−→
E ∩ F, and let (V, Fc) be the transitive closure of (V, F). Then,
(i) Fc ⊆ F,
(ii) V(F − F) ⊆ N, and
(iii) (V, F^c) is a comparability graph with transitive orientation Fc.
Observe that Fc is an orientation of the smallest embedding of G such that it can be oriented in agreement with F. We
will call F a quasitransitive orientation. Determining whether G is partitioned probe comparability will be equivalent
to determining whether it has a quasitransitive orientation.
216 D.B. Chandler et al. / Theoretical Computer Science 396 (2008) 212–222
of the following lemmas are extensions of lemmas given in [10–12,22] for proving the TRO Theorem. Note that in
the original TRO Theorem, there are four statements. The last statement presents that every circuit has even length.
Currently, we do not know how to transform it for the probe graphs. So, we omit this statement.
Arcs −→xy and −→uv are in the same probe implication class if and only if they are joined by an Υ-chain, i.e., a sequence
of edges xiyi ∈ E such that
−→xy = −−−→x0y0 Υ · · · Υ −−−→xkyk = −→uv. (1)
Proposition 12. If −→xy Υc −→uv, then there exists an Υ-chain (1) such that for each i, 1 ≤ i ≤ k, either
xi−1 = xi and yi−1 6= yi, or
xi−1 6= xi and yi−1 = yi. (2)
Such a chain will be called a canonical Υ-chain.
Proof. Suppose −→xy Υc −→uv and that (1) is a shortest Υ-chain from −→xy to −→uv. Then (2) holds for each 1 ≤ i ≤ k, since
otherwise the ith step is an equality and we have a shorter chain by removing it. 
Corollary 13. LetG = (P+N, E) be a partitioned graph and letA be a probe implication class ofG. Then (V(A), A^)
is a connected undirected graph.
Lemma 14 (The Probe Triangle Lemma). Let x, y, and z be three distinct vertices of a partitioned graph G =
(P+ N, E), let z ∈ P, and let X, Y, and Z be probe implication classes of G with X 6= Z and Z 6= Y−1 and
having arcs −→xy ∈ Z, −→zx ∈ Y, such that −→zy ∈ X. Then the following four statements hold.
(i) If x 6= u 6= y, xu ∈ E and −→xu Υ −→xy, then z 6= u, zu ∈ E and −→zu ∈ X.
(ii) If x 6= u 6= y, uy ∈ E and −→uy Υ −→xy, then z 6= u, zu ∈ E and −→zu ∈ Y.
(iii) If −→pq ∈ Z, then −→zp ∈ Y and −→zq ∈ X.
(iv) z /∈ V(Z).
Proof. We first prove (i). Notice that −→xz /∈ Z, since −→zx ∈ Y and Z 6= Y−1. Then u 6= z because −→xy ∈ Z 6= Y−1 and
−→xu Υ −→xy. Since z ∈ P, if zu /∈ E, −→xz Υ −→xu, a contradiction to the assumption that −→xz /∈ Z. Hence zu ∈ E must hold.
Since −→xu Υ −→xy, we have that yu /∈ E and at least one of y and u is a probe. Because zu ∈ E, zy ∈ E, yu /∈ E, and at
least one of y and u is a probe, we have −→zu Υ −→zy and −→zu ∈ X because −→zy ∈ X.
The proof of (ii) is similar.
Next, to prove (iii), let −→pq ∈ Z. By Proposition 12, since −→xy ∈ Z, there exists a canonical Υ-chain
−→xy = −−−→x0y0 Υ · · · Υ −−−→xkyk = −→pq.
We claim that xi 6= z 6= yi, −→zxi ∈ Y, and −→zyi ∈ X, for 0 ≤ i ≤ k. We prove the claim by induction on i. It holds
for i = 0 by assumption. Suppose it holds for i − 1. If xi−1 = xi and yi 6= yi−1, then −→zyi ∈ X by (i). Otherwise
xi−1 6= xi and yi = yi−1 and hence −→zxi ∈ Y by (ii). In either case, we have xi 6= z 6= yi, −→zxi ∈ Y and −→zyi ∈ X. In
particular, p = xk 6= z 6= yk = q, −→zp = −−→zxk ∈ Y, and −→zq = −−→zyk ∈ X. We have (iii) and (iv). 
The following is immediate from (iv) of Lemma 14.
Corollary 15. Let G = (P+N, E) be a partitioned graph with a probe implication class Z. Let x, y, z ∈ V = P+N,
let xy, xz, yz ∈ E, and let z ∈ P. If −→xy ∈ Z, then z ∈ V(Z) if and only if at least one of −→xz ∈ Z or −→zy ∈ Z.
For a probe implication class A of G = (V, E), let GA = (V, A^) and GA = (V, E − A^). We have the following
lemmas.
Lemma 16. Let G = (P + N, E) be a partitioned graph and let A be a probe implication class of G. Exactly one of
the following alternatives holds.
(i) A = A−1, or
(ii) A ∩A−1 = ∅, and A and A−1 are quasitransitive orientations of the graph GA.
218 D.B. Chandler et al. / Theoretical Computer Science 396 (2008) 212–222
(ii) A ∩A−1 = ∅ for each probe implication class A of G.
(iii) For each probe implication class A of G, the graphs GA = (V, A^) and GA = (V, E − A^) are partitioned probe
comparability graphs.
Proof. We will prove the theorem by induction on the number of vertices in G, and on the number k of probe color
classes when two graphs have the same number of vertices.
Suppose k = 1. Since G has only one probe color class, E(GA) = ∅, and by Lemma 16, all the statements hold or
none holds.
For the remainder of the proof we assume that k > 1, and that the theorem holds for all partitioned probe graphs on
fewer vertices than G, and for all partitioned probe graphs on V(G) for which the number of probe color classes is
less than k. We prove that the statements are equivalent for a partitioned probe graph G of k probe color classes.
(i)=⇒(ii). Let F be a quasitransitive orientation of G and suppose that −→xy ∈ A ∩A−1. Then there is an Υ-chain from
−→xy to −→yx
−→xy = −−−→x1y1 Υ · · · Υ −−→x`y` = −→yx.
However, from the definitions of Υ and quasitransitive orientation for G, if xy and pq are two edges of G such that
−→xy ∈ F and −→xy Υ −→pq then −→pq ∈ F, which is a contradiction since −→xy and −→yx cannot both be in F.
(ii)=⇒(iii). That GA is a partitioned probe comparability graph follows from (ii) of Lemma 16. In the following we
prove that GA is also a partitioned probe comparability graph. We consider two cases:
Case 1. V(A) = V . First we show that every probe implication class D of G, with D^ 6= A^, is a subset of some probe
implication class of GA. Let ΥA denote the relation Υ for the graph GA. Suppose
−→xy,−→xz ∈ D and −→xy Υ −→xz. Then
xz /∈ E and clearly −→xy ΥA −→xz. That is, an Υ-chain between two arcs of D implies an ΥA-chain between them. Thus
D is a subset of some probe implication class of GA.
We will show that probe implication classes of G that merge in GA are all stars in GA with a nonprobe as the center,
and any two stars which merge together have a common center as the source for all arcs or the sink for all arcs in the
classes. Therefore D ∩D−1 = ∅ for every probe implication class D of GA. Since GA has at least one class fewer
than G, the result now follows from the induction hypothesis.
Suppose the relation ΥA connects
−→xy ∈ Di and −→xz ∈ Dj, whereDi andDj are two distinct probe implication classes
of G. Then yz ∈ A^. If x ∈ P, then by Lemma 14 (iv) x /∈ V(A), contradicting the assumption V(A) = V ; thus
x ∈ N, and y and z must be probes. Also note that Di 6= D−1j , since otherwise −→zx,−→xy ∈ Di, but −→zy /∈ Di. Therefore
D^i ∩ D^j = ∅.
Suppose there exists a vertex p 6= x such that −→xy Υ −→py. Then p ∈ P since x ∈ N. Since z ∈ P and −→xy,−→py ∈ Di, we
have −→pz ∈ Dj by the Probe Triangle Lemma (iii). Then by (iv) of the same lemma, since −→py ∈ Di, −→pz ∈ Dj, and
−→yz ∈ A^, we have p /∈ V(A), a contradiction. Hence all arcs of the probe implication class of −→xy must be of the form
−→xq. Hence Di is a star, as claimed. Since −→xy ∈ Di and −→xz ∈ Dj, we see that Di and Dj merge at x.
Case 2. V(A) ⊂ V . As in Case 1, every probe implication class of G except A and A−1 is contained in some probe
implication class ofGA. ThereforeGA has at least one color class fewer thanG. The result follows from the induction
hypothesis if D ∩D−1 = ∅ for every implication class of GA.
We divide the arcs of
−→
E (GA) into two groups: those arcs between two vertices ofM = V(A), and those with at least
one endvertex not inM. SinceM is aQT-module, by Lemma 20, every probe implication class ofG is either a subset
of
−→
E (G[M]), or disjoint from
−→
E (G[M]). First consider G[M]. Relation Υ does not connect any arc of
−→
E (G[M])
with any arc not in
−→
E (G[M]), and ΥA does not either, because the edges of G missing in GA do not leaveM. Thus,
by the same argument as in Case 1, every probe implication class D of (M,E(G[M]) −A) satisfies D ∩D−1 = ∅.
Next we consider those probe implication classes that are disjoint from
−→
E (G[M]). Let X be a set containing one
vertex from each component ofG[P(M)]. SinceG[V−M+X] is a proper induced subgraph, it satisfies Statement (ii)
of the theorem. Since the vertex set is not all of G, the induction hypothesis says that G[V −M + X] is a partitioned
probe comparability graph having a quasitransitive orientation F. We extend this orientation to an orientation F∗ of
(V, E− E(G[M])) as follows. Let v ∈ V −M. Since X is an independent set, every arc between v and X in F is from
v to X, or every such arc is from X to v. We give every edge between v andM the same orientation.
220 D.B. Chandler et al. / Theoretical Computer Science 396 (2008) 212–222
Algorithm 1 Recognizing a partitioned probe comparability graph.
Input: The directed version (V(G),
−→
E (G)) of a partitioned probe graph G with vertices v1, v2, . . . , vn whose
adjacency sets obey j ∈ Adj(i) if and only if −−→vivj ∈ −→E (G).
Output: A variable FLAG and a variable CLASS(i, j) for each edge −−→vivj. If the algorithm terminates with
FLAG equal to zero, then a quasitransitive orientation of G is obtained by combining all edges having positive
CLASS.
1: Initialize: k← 0; FLAG← 0;
2: for each edge −−→vivj ∈ −→E (G) do
3: if CLASS(i, j) is undefined then
4: k← k+ 1;
5: CLASS(i, j)← k; CLASS(j, i)← −k;
6: Quasi-EXPLORE(i, j);
7: end if
8: end for
Algorithm 2 Quasi-EXPLORE(i, j)
Input: −−→vivj.
Output: Find the edges of a probe implication class containing edge −−→vivj.
For each edge visited with CLASS undefined, assign it a value.
1: for each h ∈ Adj(i) such that
{vh, vj} 6⊆ N(G) and h /∈ Adj(j) or |CLASS(j, h)| < k do
2: if CLASS(i, h) is undefined then
3: CLASS(i, h)← k; CLASS(h, i)← −k;
4: Quasi-EXPLORE(i, h);
5: else
6: if CLASS(i, h) = −k then
7: CLASS(i, h) = k; FLAG← 1;
8: Quasi-EXPLORE(i, h);
9: end if
10: end if
11: end for
12: for each h ∈ Adj(j) such that
{vh, vi} 6⊆ N(G) and h /∈ Adj(i) or |CLASS(i, h)| < k do
13: if CLASS(h, j) is undefined then
14: CLASS(h, j)← k; CLASS(j, h)← −k;
15: Quasi-EXPLORE(h, j);
16: else
17: if CLASS(h, j) = −k then
18: CLASS(h, j) = k; FLAG← 1;
19: Quasi-EXPLORE(h, j);
20: end if
21: end if
22: end for
Theorem 23. Recognizing a partitioned probe comparability graph G and finding a corresponding quasitransitive
orientation of G can be done inO(∆ ·m) time andO(n+m) space, where ∆ is the maximum degree of G. Moreover,
an embedding of G can also be obtained from a quasitransitive orientation in O(∆ ·m) time.
Let G = (P + N, E) be a partitioned graph. Recall that the sandwich conjugate G∗ of G is the partitioned graph
obtained from G by removing all edges between vertices of N. It is not hard to check that a partitioned graph G is a
222 D.B. Chandler et al. / Theoretical Computer Science 396 (2008) 212–222
By Theorems 23 and 27 we obtain the following theorem.
Theorem 28. A partitioned probe permutation graph can be recognized in O(n3) time.
Remark 29. By using a modular decomposition, Chandler et al. showed that there exists an O(n2)-time algorithm
that recognizes partitioned probe permutation graphs [3].
Acknowledgements
The second author was partially supported by the NSC of Taiwan, grant NSC94-2213-E-194-009. The third
author was partially supported by the NSC of Taiwan, grant NSC94-2627-B-007-001. The fourth author was partially
supported by the NSERC of Canada.
References
[1] A. Berry, M.C. Golumbic, M. Lipshteyn, Recognizing and triangulating chordal probe graphs, Research Report LIMOS/RR–03–08, 4th July
2003.
[2] A. Berry, M.C. Golumbic, M. Lipshteyn, Two tricks to triangulate chordal probe graphs in polynomial time, in: Proceedings 15th ACM–SIAM
Symposium on Discrete Algorithms, 2004, pp. 962–969.
[3] D.B. Chandler, M.-S. Chang, A.J.J. Kloks, J. Liu, S.-L. Peng, On probe permutation graphs, in: Proceedings TAMC 2006, in: LNCS, 3959,
2006, pp. 494–504.
[4] D.B. Chandler, M.-S. Chang, T. Kloks, J. Liu, S.-L. Peng, Recognition of probe cographs and partitioned probe distance-hereditary graphs,
in: Proceedings AAIM 2006, in: LNCS, 4041, 2006, pp. 267–278.
[5] D.B. Chandler, J. Guo, T. Kloks, R. Niedermeier, Probe balanced matrices: Totally balanced matrices, in: Proceedings AAIM 2007, in: LNCS,
4508, 2007, pp. 368–377.
[6] G.J. Chang, A.J.J. Kloks, J. Liu, S.-L. Peng, The PIGs full monty—a floor show of minimal separators, in: Proceedings STACS 2005,
in: LNCS, 3404, 2005, pp. 521–532.
[7] G.J. Chang, T. Kloks, S.-L. Peng, Probe interval bigraphs, Electronic Notes in Discrete Mathematics 7 (2005) 195–201.
[8] M.-S. Chang, T. Kloks, D. Kratsch, J. Liu, S.-L. Peng, On the recognition of probe graphs of some self-complementary graph classes,
in: Proceedings COCOON 2005, in: LNCS, 3595, 2005, pp. 808–817.
[9] D. Coppersmith, S. Winograd, Matrix multiplication via arithmetic progressions, in: Proceedings 19th ACM Symposium on Theory of
Computing, 1987, pp. 1–6.
[10] M.C. Golumbic, The complexity of comparability graph recognition and coloring, Computing 18 (1977) 199–208.
[11] M.C. Golumbic, Comparability graphs and a new matroid, Journal of Combinatorial Theory Series B 22 (1977) 68–90.
[12] M.C. Golumbic, Algorithmic Graph Theory and Perfect Graphs, Academic Press, New York, 1980.
[13] M.C. Golumbic, H. Kaplan, R. Shamir, Graph sandwich problems, Journal of Algorithms 19 (1995) 449–473.
[14] M.C. Golumbic, M. Lipshteyn, Chordal probe graphs, in: Proceedings WG 2003, in: LNCS, 2880, 2003, pp. 249–260.
[15] M. Habib, F. de Montgolfier, C. Paul, A simple linear-time modular decomposition algorithm for graphs, using order extensions,
in: Proceedings SWAT 200, in: LNCS, 3111, 2004, pp. 187–198.
[16] J.L. Johnson, J. Spinrad, A polynomial time recognition algorithm for probe interval graphs, in: Proceedings 12 ACM–SIAM Symposium on
Discrete Algorithms, 2001, pp. 477–486.
[17] R.M. McConnell, J.P. Spinrad, Modular decomposition and transitive orientation, Discrete Mathematics 201 (1999) 189–241.
[18] R.M. McConnell, J. Spinrad, Construction of probe interval graphs, in: Proceedings 13 ACM–SIAM Symposium on Discrete Algorithms,
2002, pp. 866–875.
[19] F.R. McMorris, C. Wang, P. Zhang, On probe interval graphs, Discrete Applied Mathematics 88 (1998) 315–324.
[20] A. Pnueli, A. Lempel, S. Even, Transitive orientation of graphs and identification of permutation graphs, Canadian Journal of Mathematics
23 (1971) 160–175.
[21] L. Sheng, Cycle free probe interval graphs, Congressus Numerantium 140 (1999) 33–42.
[22] K. Simon, P. Trunz, A cleanup on transitive orientation, in: Proceedings ORDAL 1994, in: LNCS, 831, 1994, pp. 59–85.
[23] P. Zhang, E.A. Schon, S.G. Fisher, E. Cayanis, J. Weiss, S. Kistler, P.E. Bourne, An algorithm based on graph theory for the assembly of
contigs in physical mapping of DNA, CABIOS 10 (1994) 309–317.
Probe Ptolemaic Graphs 469
the vertices of a graph G into a set of probes P and a set of nonprobes N is part
of the input then we call G a partitioned probe graph of G if G can be embedded
into a graph of G by adding edges between certain vertices of N. We denote a
partitioned graph as G = (P+N, E), and when this notation is used it is to be un-
derstood that N is an independent set. We will refer to the class of (partitioned)
probe graphs of the class of G graphs as (partitioned) probe G graphs.
For the partitioned case, there are eﬃcient algorithms for the recognition
problem on some classes of graphs, e.g., probe interval graphs [18],[22], probe
permutation graphs [5], probe distance-hereditary graphs [6], probe compara-
bility graphs [7], and so on. In graph theory, the unpartitioned case is more
interesting. Only few graph classes have polynomial-time recognition algorithms
for their probe versions in unpartitioned case. These classes are chordal [3], in-
terval [8], cograph [9,21], split [9],[20], P4-reducible [9], and P4-sparse graphs [9].
In this paper, we study the unpartitioned case of probe ptolemaic graphs. The
remaining of this paper is organized as follows. Some notation and preliminaries
are given in Section 2. We then propose some characterizations of probe ptole-
maic graphs in Section 3. In Section 4, we consider the recognition of a special
class of probe ptolemaic graphs, called probe chordal cographs. In Section 5, we
show that there exists a polynomial-time algorithm that checks whether a graph
is a probe ptolemaic graph. Finally, we give conclusion in the last section.
2 Preliminaries
A graph G is a pair (V,E), where the elements of V are called the vertices of G
and where E is a family of two-element subsets of V , called the edges. We use
V (G) and E(G) to denote the vertex and edge sets of G, respectively. We write
n = |V | for the number of vertices and m = |E| for the number of edges. We
denote edges of a graph G as (x, y) (or xy) and we call x and y the end vertices of
the edge. Unless stated otherwise, a graph is regarded as undirected. For a vertex
x we write N(x) for its set of neighbors in G, and for a subset W ⊆ V we write
N(W ) = ∪x∈W N(x) − W . For other conventions on graph-related notation we
refer to any standard textbook. For graph classes not deﬁned here we refer to [4].
For two sets A and B we write A+ B and A − B instead of A ∪ B and A \ B
respectively. We write A ⊆ B if A is a subset of B with possible equality and
we write A ⊂ B if A is a subset of B and A = B. For a set A and an element x
we write A − x instead of A − {x} and A + x instead of A ∪ {x}.
For a graph G = (V,E) and a subset S ⊆ V , we write G[S] for the subgraph of
G induced by S. For a subset W ⊆ V , we write G−W for the graph G[V −W ], i.e.,
the subgraph induced by V −W . For a vertex x we write G−x rather than G−{x}.
For a partitioned probe graph G = (P+N, E) of some graph class G, an embed-
ding of G is a graph of G obtained by adding edges between certain nonprobes,
i.e., vertices of N.
Originally, ptolemaic graphs were deﬁned as follows.
Deﬁnition 1 ([19]). A connected graph is ptolemaic if for every four vertices
x, y, u, and v:
Probe Ptolemaic Graphs 471
It is well-known that chordal graphs can be characterized as those graphs in
which every induced subgraph has a simplicial vertex [11],[14],[26].
Deﬁnition 3. A vertex x is simplicial if its neighborhood N(x) is a clique.
We end this section with two other characterizations of ptolemaic graphs. Another
way to characterize chordal graphs is by their minimal separators. A minimal x, y-
separator for nonadjacent vertices x and y is a minimal set of vertices S such that
x and y are in diﬀerent components of G−S, the graph induced by V −S, where
V is the set of vertices of G. A minimal separator is a set which is a minimal x, y-
separator for some nonadjacent vertices x and y. A classic result of Dirac’s says
that a graph is chordal if and only if every minimal separator is a clique [11].
Theorem 3. A connected graph is ptolemaic if and only if every connected in-
duced subgraph either is a clique, or has a cutvertex, or has a separator which is
a nontrivial clique-module.
Proof. To see this, assume that G is ptolemaic and let H be a connected induced
subgraph. Thus H is ptolemaic. If H is a clique or has a cutvertex, we are
done. Otherwise, let x be a non-universal vertex. Let C be a component of
H − N [x] such that N(C) is inclusion minimal. By Theorem 2 on the facing
page, S = N(C) is a clique module in H [S +C]. Since H is chordal, there exists
a vertex y ∈ C with S in its neighborhood. It follows, again by Theorem 2,
that S is also a clique module in the component of G − N [y] that contains x.
Thus S is a separating clique module. To see the converse, notice that gems and
chordless cycles of length at least 4 are not cliques, have no cutvertices, and have
no nontrivial clique-modules. unionsq
Theorem 4 ([17]). A graph is G is ptolemaic if and only if for every pair of
vertices x and y with d(x, y) = 2, N(x) ∩ N(y) is a clique separator in G.
3 Characterizations of Probe Ptolemaic Graphs
A graph is HHD-free if none of its induced subgraphs is a hole, a house, or a
domino. HHD-free graphs can be recognized in O(n3) time ([16]).
A ptolemaic twin in a partitioned graph G = (P+N, E) is pair of vertices x, y
such that
– x, y ∈ P and N [x] = N [y], or
– x, y ∈ N and N(x) = N(y), or
– x ∈ P, y ∈ N and N [x] ∩ P = N(y).
A k-fan is the graph consisting a k-path Pk and with a fully adjacent vertex.
Thus a 4-fan is the gem. For a given graph G = (V,E), a particular 2-cnf
instance F (G) is created as follows.
– The boolean variables are the vertices of G,
– for each edge ab of G, (a ∨ b) is a clause, the edge clause for ab,
– for each C4 = abcd of G, (a ∨ b) and (c ∨ d) are two clauses, the C4 clauses
for that C4,
Probe Ptolemaic Graphs 473
Deﬁnition 4 ([10],[13]). A cograph is a graph without induced P4.
Chordal cographs can be characterized as follows. For a graph G let Υ = Υ (G) be
the set of universal vertices, viz , the set of vertices adjacent to all other vertices.
Obviously, for any graph G, Υ induces a clique in G.
Proposition 1 ([29],[30]). A connected graph is a chordal cograph if and only
if it is complete or G − Υ (G) is a disconnected chordal cograph.
Remark 1. Chordal cographs have the following tree-model: Let T be a rooted
tree. Make any two vertices adjacent if they are contained in a common path
from a leaf to the root.
From proposition 1 we easily obtain:
Lemma 1. A partitioned graph G = (P + N, E) can be embedded into a chordal
cograph if and only if every connected induced subgraph has a nonempty set Υ of
vertices that can be made universal by adding edges between nonprobes.
The condition of Lemma 1 can be formulated in monadic second-order logic
without edge-set quantiﬁers. Probe chordal-cographs have rankwidth at most 2.
Therefore:
Corollary 2. There exists an O(n3) algorithm which checks if a graph has an
independent set N of nonprobes such that the partitioned graph G = (P + N, E)
can be embedded into a chordal cograph by adding some edges between nonprobes.
For alternative algorithms see [6],[21].
5 Recognition of Probe Ptolemaic Graphs
In this section we show that there exists a polynomial-time recognition algorithm
for the class of probe ptolemaic graphs. We assume that G is connected, otherwise
we can test each component of G separately. By Section 4, we may assume that
G has no universal vertices.
It is routine to check the following:
Proposition 2. A probe ptolemaic graph has no induced house, hole, or domino.
Furthermore, an induced gem has exactly two nonprobes, and they are at distance
two in the P4 of the gem.
Lemma 2. Consider two vertices x and y at distance 2 in G. Assume there
exists an embedding of G in which x and y are probes. Let H be the graph
obtained from G by adding the following edges:
(i) If G has an induced C4 containing x and y, then the two nonprobes in the
C4 form an edge in H.
(ii) If G has a gem Γ with x and y at distance 2, then the two nonprobes in Γ
form an edge in H.
Then every gem or C4 in H induces also a gem or C4 in G.
Probe Ptolemaic Graphs 475
By table look-up, we check if there exists an embedding for the components of
Ci − Ai such that Ai consists of only nonprobes.
Assume that S has only nonprobes. Consider all gems and C4’s in S +C inci-
dent with vertices of S, and add the edges between the nonprobes. By Lemma 2,
this ﬁxates A. Notice that the partition of A into probes and nonprobes is deter-
mined: the set of probes in A is exactly N(σ) ∩ A for any σ ∈ S. Let C1, . . . , Ct
be the components of C − A. Then Si is a module for Ci, otherwise there would
be a gem incident with a vertex of S. Let Ai be the set of vertices in Ci adjacent
to Si. By table look-up we check if there exist embedding for blocks (u,Ci) where
u is a nonprobe in S. If there are overlapping separators Si and Sj , we check if
there are embeddings such that Ai or Aj consists only of nonprobes.
The case where x is a nonprobe, is similar to the description above.
Theorem 7. There exists an eﬃcient algorithm to check whether a given graph
G = (V,E) is probe ptolemaic.
Proof. For the case where there exists a universal vertex, the algorithm is de-
scribed in Section 4. Otherwise, choose a vertex x such that the largest compo-
nent C of G − N [x] has maximum cardinality. Let S = N(C). By the choice of
x, all vertices of C0 = V − (S + C) are adjacent to all vertices of S. Consider
the case where S has at least one nonprobe. Then C0 has only probes. By table
look-up we can check if there is an embedding for the block (x,C).
Consider the case where S has only probes. If C0 is not an independent set, it
has at least one probe, say x. Again, we can check by table look-up if there is an
embedding for (x,C). The algorithm in Section 4 checks if there is an embedding
for S+C0. If C0 is an independent set of nonprobes, we can proceed as described
prior to this theorem. unionsq
Remark 2. There are O(nm) diﬀerent blocks in a graph. A rough estimate shows
that each block can be processed in O(n2) time. This shows a time complexity of
O(n3m) time as a rough upperbound. Notice that for the processing of a block
only vertices are considered that are at distance at most 2 from the ‘handle.’ This
shows that the algorithm can be implemented to run in O(n3) time. However,
this needs a careful analysis and this is beyond the scope of today’s abstract.
6 Concluding Remarks
Many probe graph classes have been investigated recently. However, many ques-
tions remain. To mention just one: Can probe perfect graphs be recognized in
polynomial time?
References
1. Bandelt, H.J., Mulder, H.M.: Distance-Hereditary Graphs. Journal of Combinato-
rial Theory, Series B 41, 182–208 (1986)
2. Bayer, D., Le, V.B., de Ridder, H.N.: Probe Trivially Perfect Graphs and Probe
Threshold Graphs (manuscript) (2006)
Probe Ptolemaic Graphs 477
23. Mo¨hring, R.H., Radermacher, F.J.: Substitution Decomposition for Discrete Struc-
tures and Connections with Combinatorial Optimization. Ann. Discrete Math. 19,
257–356 (1984)
24. Nicolai, F.: Strukturelle und Algorithmische Aspekte Distanz-erblicher Graphen
und Verwandter Klasses. Dissertation thesis, Gerhard-Mercator-Universita¨t, Duis-
burg (1994)
25. de Ridder, H.N.: On Probe Graph Classes. PhD thesis, Universita¨t Rostock, Ger-
many (2007)
26. Rose, D.J., Tarjan, R.E., Lueker, G.S.: Algorithmic Aspects of Vertex Elimination
on Graph. SIAM Journal of Computing 5, 266–283 (1976)
27. Soltan, V.P.: d-Convexity in Graphs. Soviet Math. Dokl. 28, 419–421 (1983)
28. Uehara, R., Uno, Y.: Laminar Structure of Ptolemaic and its Applications. In:
Deng, X., Du, D.-Z. (eds.) ISAAC 2005. LNCS, vol. 3827, pp. 186–195. Springer,
Heidelberg (2005)
29. Wolk, E.S.: The Comparability Graph of a Tree. Proceedings of the American
Mathematical Society 13, 789–795 (1962)
30. Wolk, E.S.: A Note on The Comparability Graph of a Tree. Proceedings of the
American Mathematical Society 16, 17–20 (1965)
G2 = (V,E2) where E1 ⊆ E2, the graph sand-
wich problem asks whether there exists a graph
G = (V,E), E1 ⊆ E ⊆ E2, where G is in a
specific graph class G. For example, the interval
sandwich problem asks ”Is there an interval
graph G = (V,E) where E1 ⊆ E ⊆ E2?”.
The partitioned probe graph recognition prob-
lem is equivalent to the graph sandwich prob-
lem in which G1 = G and E2 = E1 + {(u, v) |
PL(u) = PL(v) = N}.
Instead of studying the recognition of fully
partitioned (or unpartitioned) probe G directly,
we study the recognition of partially partitioned
probe G graphs. The recognition of partially
partitioned probe G graphs is equivalent to
the recognition of fully partitioned G graphs if
PU = ∅ and is equivalent to the recognition of
unpartitioned probe G graphs if PP = PN = ∅.
In this paper, we give an O(nm)-time algorithm
to recognize partially partitioned probe bipartite
distance-hereditary graphs.
II. PRELIMINARIES
For a vertex v of G, the open neighborhood
of v, denoted by NG(v), consists of all vertices
adjacent to v in G. We use NG[v] for NG(v)+ v,
called the closed neighborhood of v. For a subset
X of V , we use NG(X) = ∪x∈XNG(x) − X to
denote the neighborhood of X in G. A subset
X of V is called a module in G if for every x ∈ X
NG(x) − X = NG(X). Two vertices u 6= v are
false twins in G if NG(u) = NG(v) and are true
twins if NG[u] = NG[v]. We say they are twins
if NG(u) − v = NG(v) − u. A vertex v in G is
called a pendant vertex if the degree of v is one.
A vertex v in G is called a universal vertex if the
degree of v is |V |−1. In a graph G = (V,E), two
disjoint subsets S and T of V are fully adjacent if
every vertex of S is adjacent to all vertices in T .
Two sets A and B are incomparable if A∩B 6= ∅,
A − B 6= ∅, and B − A 6= ∅. For two vertices
u, v ∈ V , we use dG(u, v) to denote the distance
of u and v in a graph G = (V,E).
We say a graph G is a distance-hereditary graph
(DHG for short) if the distance between any
two vertices remains the same in every con-
nected induced subgraph of G. It is a classical
result that distance-hereditary graphs can be
captured by forbidden induced subgraphs [1].
For the house, hole, domino, and gem, we refer
to Fig. 1. A hole is a k-cycle where k ≥ 5.
r
r
r
r
r
  @@
r
r r
r
r
@@ 


Q
Q
r
r
r r
r
r
r
r
r r
rHHH




L
L
L
L
J
JJ






Figure 1: A house, a hole, a domino, and a gem.
Theorem 1. [1] Let G be a graph. The following
conditions are equivalent:
1) G is distance hereditary.
2) G contains no house, hole, domino, or gem as
an induced subgraph.
3) Every connected induced subgraph of G with
at least two vertices has a pendant vertex or
a twin.
4) For every pair of vertices x and y with
d(x, y) = 2, there is no induced x, y-path of
length greater than 2.
Corollary 1. A bipartite graph G is a bipartite
distance-hereditary graph if and only if it has no
induced domino nor induced hole.
Corollary 2. A graph G is a bipartite distance-
hereditary graph if and only if every connected
induced subgraph of G with at least two vertices
has a pendant vertex or a false twin.
Definition 1. [13] The hanging Φ of G = (V,E)
by v is an (ℓ+ 1)-tuple (L0, L1, . . . , Lℓ) where ℓ =
maxu∈V dG(u, v), L0 = {v}, and Li = {u ∈ V |
dG(u, v) = i} for 1 ≤ i ≤ ℓ.
Definition 2. Let Φ = (L0, L1, . . . , Lℓ) be a hang-
ing of G. For x ∈ Li, 0 < i ≤ ℓ, use N
−
Φ
(x) for
NG(x) ∩ Li−1. Denote the subgraph of G induced
by ∪i≤j≤ℓLj by Gi for 0 ≤ i ≤ ℓ. By definition,
G = G0. Let x and y be vertices in Li with
1 ≤ i ≤ ℓ. We say that (i) x properly contains
y, denoted by x ≫ y, if N−
Φ
(x) properly contains
N−
Φ
(y); (ii) x and y are equivalent, denoted by
x ≡ y, if N−
Φ
(x) = N−
Φ
(y); and (iii) x is minimal
(resp. maximal) if there does not exist any other
vertex z ∈ Li such that x≫ z (resp. z ≫ x).
Remark 1. Let C be a component of Gi where 0 <
i ≤ ℓ. By definition of hanging, NG(C) ⊆ Li−1.
rr r
r
r
@@ 


Q
Q
(a)
r
r
r
r
r
r
r
r
(b)
r
r
r
r
r
r
r
r
r
r




(c)
Figure 2: Some forbidden subgraphs of probe
bipartite distance-hereditary graphs.
Lemma 2. If P is probe bipartite distance-
hereditary and the subgraph of G induced by a set
D of six vertices is a domino, then D has exactly
two nonprobes which are at distance three and the
two vertices of degree three in the subgraph of PG
induced by D are probes.
Proof: It can be shown by analyzing all
cases.
In Fig. 2, we list three forbidden subgraphs of
probe bipartite distance-hereditary graphs. By
Lemma 1, we see that Fig. 2(a) is a forbidden
subgraph of probe bipartite distance-hereditary
graphs. By Lemma 2, both vertices of degree
three in an induced domino are probes. In
Fig. 2(b), the four vertices of degree three must
be probes, it is impossible to add any edge to
destroy the induced dominos in it. In Fig 2(c),
let the five vertices in the left-hand side from
the bottom up be u1, u2, u3, u4, u5, let the
other five vertices in the right-hand side from
the bottom up be v1, v2, v3, v4, v5. Since the
vertices of degree three in any induced domino
are probes, u2, v2, u4, and v4 are probes. Since
{u3, u2, u4, v4, u5, v5} induces a domino, u4 and
v4 are of degree three and u2 is a probe, u3 and
v5 must be nonprobes. Also {u1, v1, u2, v2, v4, v3}
induces a domino, u2 and v2 are of degree three
and v4 is a probe, v3 and v1 must be nonprobes.
We see that (u3, v3) is an edge in the graph, but
they have to be labeled as nonprobes in any
probe bipartite distance-hereditary embedding,
a contradiction. This shows that Fig. 2(c) is
also a forbidden subgraph of probe bipartite
distance-hereditary graphs.
Proposition 1. Suppose P is a probe bipartite
distance-hereditary graph and P ∗ is a bipartite
distance-hereditary embedding of P . Then the fol-
lowing statements are true:
1) Any two probes in P ∗ that are false twins in
P ∗ are false twins in P .
2) Any two nonprobes in P ∗ that are false twins
in P ∗ are false twins in P .
Definition 3. Two disjoint vertex sets X and Y
are called probe adjacent if X can be partitioned
into two non-empty sets X1 and X2 and Y can
be partitioned into two non-empty sets Y1 and
Y2 such that every vertex in X1 (resp. Y1) is
adjacent to all vertices of Y (resp. X) and every
vertex in X2 (resp. Y2) is adjacent to all vertices
of Y1 (resp. X1) but not adjacent to any vertex of
Y2 (resp. X2).
According the definition of probe adjacent,
we have the following lemma.
Lemma 3. Let P be a probe graph and P ∗ be a
bipartite distance-hereditary embedding of P . Sup-
pose X and Y are two disjoint vertex sets of PG
of size greater than one and X and Y are fully
adjacent in P ∗G. If both X and Y have vertices with
labels both P and N in P ∗, then X and Y are probe
adjacent in G. Besides, a vertex x ∈ X (resp. Y )
is a probe in P ∗ if and only if x is adjacent to all
vertices in Y (resp. X).
IV. THE ALGORITHM
In this section, we give an O(nm)-time al-
gorithm to recognize probe bipartite distance-
hereditary graphs. This algorithm is a recursive
one. We denote the input probe graph by P .
The algorithm first check whether P is a bi-
partite graph. If P is not bipartite, then it has
no bipartite distance-hereditary embedding. If
P is bipartite, the algorithm checks whether P
is feasible. If P is not feasible, then it is not a
probe bipartite distance-hereditary graph. Set
PL(u) = P for all vertices of u ∈ PU that is
adjacent to v ∈ PV with PL(v) = N. This can be
done in linear time. In the following assume
P is bipartite and feasible, i.e., all neighbors
of a nonprobe must be probes. The algorithm
checks to which of the following classes the
and PG are biconnected, ℓ > 1. For clarity of the
notation, use G for PG. Algorithm B checks to
which class of probe graphs the input kernel
probe graph P does belong and takes action
accordingly:
C 1. P is well-labeled.
C 2. P is not well-labeled.
To handle the case that P is of class C 2, we
have the following three subcases.
D 1. ℓ > 2.
D 2. ℓ = 2 and there is a vertex q ∈ L2 with
PL(q) = P.
D 3. ℓ = 2 and every vertex in L2 is not a
probe.
In the following assume that P is a ker-
nel probe graph and P ∗ is a minimal bi-
partite distance-hereditary embedding of P .
For simplicity, use G and G∗ for PG and P
∗
G,
respectively. Let p be a probe of P ∗, Φ =
(L0, L1, . . . , Lℓ) and Ψ = (Z0, Z1, . . . , Zh) be the
hangings of G and G∗ by vertex p, respectively.
The above notation will be used in lemmas
and theorems in the rest of this subsection.
Now we give some observations on both the
hangings of G and G∗ by a probe p. Since P ∗
is also a distance-hereditary embedding of P ,
P ∗ has all properties of the distance-hereditary
embedding of P that are shown in [12].
Theorem 6. [12] Suppose P = (G,PL) is a
probe bipartite distance-hereditary graph and P ∗ =
(G∗, P ∗L) is a minimal embedding of P . Let p be
a probe of P ∗, Φ = (L0, L1, . . . , Lℓ) and Ψ =
(Z0, Z1, . . . , Zh) be the hangings of G and G
∗ by
vertex p, respectively. Then the following statements
hold.
1) Suppose C is a component of G∗i with 1 <
i ≤ h. ThenNG∗(C) contains probes and non-
probes in P ∗. In addition, if |C∩Zi| > 1 then
C ∩Zi also contains probes and nonprobes in
P ∗.
2) For x ∈ Zi where 1 < i ≤ h, N
−
Ψ
(x) contains
probes and nonprobes in P ∗.
3) ℓ = h > 1 and Li = Zi for 0 ≤ i ≤ ℓ = h.
4) For 1 < i ≤ ℓ and x ∈ Li, x is a probe in
P ∗ if and only if in G x is adjacent to some
vertices in Li−1 that are nonprobes in P
∗.
Algorithm W
Now we are ready to show the algorithm for
the case that P is of class C 1, i.e., a well-labeled
kernel probe graph. We refer to the algorithm
for handling this case as Algorithm W. We
will see that Algorithm W serves as a major
subroutine to be used later. The algorithm is as
follows. By definition, the labels of vertices in
NG[p] are either P or N. Compute P
′ from P as
follows. Let P ′G = PG and let P
′
L(y) = PL(y) for
all y ∈ NG[p]. For every i from i = 2 to i = ℓ and
every y ∈ Li with PL(y) = U, let P
′
L(y) = P if
in G y is adjacent to some vertex z ∈ Li−1 with
P ′L(z) = N; and let P
′
L(y) = N otherwise. By
Theorem 6, we see that P is a probe bipartite
distance-hereditary graph if and only if P ′ is a
probe bipartite distance-hereditary graph. Ap-
parently P ′ is fully partitioned. Use the O(n2)-
time algorithm in [4] to determine whether P ′
is a probe bipartite distance-hereditary graph.
It is not hard to see that Algorithm W runs in
O(n2) time.
In the following we give observations to be
used for handling probe graphs of class C 2.
Lemma 5. Suppose P ∗ is a minimal bipartite
distance-hereditary embedding of P . Then the fol-
lowing statements hold:
1) A component of Gi is a component of G
∗
i for
0 ≤ i ≤ ℓ.
2) For any component C of Gi with 1 ≤ i ≤ ℓ,
C ∩ Li = C ∩ Zi.
3) For any component C of Gi with 1 ≤ i ≤ ℓ
and |C ∩ Li| > 1, NG(C) = NG∗(C).
Proof: First we prove Statement (1). By
Theorem 6, h = ℓ and Li = Zi for 0 ≤ i ≤ h = ℓ.
In addition, G∗ is obtained from G by adding
edges. Hence a component of G∗i , 0 ≤ i ≤ h,
is a component of Gi or the union of some
components of Gi. Since both G and G
∗ are bi-
connected, all G0, G1, G
∗
0
, and G∗
1
have only one
component. Hence the lemma holds for i = 0
and i = 1. For 1 < i ≤ ℓ, we prove the statement
by contradiction showing that if some compo-
nent C of G∗i is not a component of Gi then P
∗
is not a minimal bipartite distance-hereditary
embedding of P . Suppose C is a component
of G∗i that properly contains a component D
is a probe bipartite distance-hereditary graph
if and only if P ′ is a probe bipartite distance-
hereditary graph after we relabel primes of P
in C. In P ′, there must be a probe p′ in C ∩L2.
Besides P ′L(y) 6= U for every y ∈ NG(p
′). Thus P ′
is a well-labeled kernel probe graph. We then
call Algorithm W to determine whether P ′ is
a probe bipartite distance-hereditary graph. It
takes linear time to find a component C of G2
with |C ∩ L2| > 1 and obtain P
′ in linear time.
Thus the algorithm for D 1 runs in O(n2) time.
Algorithm for D 2. In this case ℓ = 2 and there
is a vertex q ∈ L2 with PL(q) = P. If NG(q) =
L1, then q is a false twin of p, a contradiction.
Thus L1−NG(q) 6= ∅. Let (L
′
0
, L′
1
, . . . , L′k) be the
hanging of G by q. Then p and all vertices in
L1 − NG(q) are in L
′
2
+ L′
3
and are in the same
component of G−NG[q]. Hence P is also of class
D 1 and the algorithm is finished by calling the
algorithm for D 1. Thus the algorithm for D 2
runs in O(n2) time.
Algorithm for D 3. In this case ℓ = 2 and every
vertex in L2 is not a probe. Let q be a vertex in
L2 and be of minimum degree among vertices
in L2. By definition, PL(q) = U or PL(q) = N. Let
Pˆ be the probe graph (PG, PˆL) where PˆL(q) = P
and PˆL(x) = PL(x) for x ∈ PV − q. Let Pˇ be
the probe graph (PG, PˇL) where PˇL(q) = N,
PˇL(y) = P for y ∈ NG(q), and PˇL(x) = PL(x)
for x ∈ PV − NG[q]. If PL(q) = U, then P
is a probe bipartite distance-hereditary graph
if and only if one of Pˆ and Pˇ is a probe
bipartite distance-hereditary graph. It is easy
to see that we can use the algorithm for D 2
to test whether Pˆ is a probe bipartite distance-
hereditary graph. In the following we focus
on checking whether Pˇ is a probe bipartite
distance-hereditary graph. For simplifying the
notation, we use G to refer to PG. Since G has
no false twins, N−
Φ
(q) 6= N−
Φ
(q′) for any q′ ∈ L2
and q′ 6= q. If for all q′ ∈ L2, q
′ 6= q, either
N−
Φ
(q) ⊂ N−
Φ
(q′), or N−
Φ
(q) and N−
Φ
(q′) are dis-
joint, then any two vertices in N−
Φ
(q) are false
twins in G. Thus there exists a vertex q′ ∈ L2,
q′ 6= q, that N−
Φ
(q′) and N−
Φ
(q) are incomparable,
i.e., N−
Φ
(q′)∩N−
Φ
(q) 6= ∅, N−
Φ
(q′)−N−
Φ
(q) 6= ∅, and
N−
Φ
(q) − N−
Φ
(q′) 6= ∅. Let y1, y2 ∈ N
−
Φ
(q) where
y2 ∈ N
−
Φ
(q′) and y1 /∈ N
−
Φ
(q′). Let z ∈ N−
Φ
(q′) but
z /∈ N−
Φ
(q). Notice that y1 and y2 must be probes
in any bipartite distance-hereditary embedding
of Pˇ . Consider the hanging (Lˇ0, Lˇ1, . . . , Lˇk) of
G by y1. By definition, dG(y1, q
′) = 3. Since
dG(y1, q
′) = 3, k > 2. We see that Pˇ is of
class D 1. Hence whether Pˇ is a probe bipartite
distance-hereditary graph can be determined in
O(n2).
The following lemma summarizes the results
of this subsection.
Lemma 6. Whether a probe graph of class P 4 is
a probe bipartite distance-hereditary graph can be
determined in O(n2) time.
C. Non-biconnected probe graphs without false
twins and Algorithm R
In this subsection we show how to solve
the problem recursively when the input probe
graph P is bipartite without false twins and is
non-biconnected. Our algorithm is based upon
the following two theorems.
Theorem 8. [12] Suppose P is a connected probe
graph and P ∗ is a minimal distance-hereditary
embedding of P . Then a vertex is a cut vertex of
P ∗ if and only if it is a cut vertex of P .
Corollary 7. Suppose P is a connected probe graph
and P ∗ is a minimal bipartite distance-hereditary
embedding of P . Then a vertex is a cut vertex of
P ∗ if and only if it is a cut vertex of P .
Proof: Suppose P has k biconnected com-
ponents C1, C2, . . . , Ck. Let P
∗
G be the graph
(P ∗V ,∪
k
j=1P
∗
E [Ci])). It is easy to see that a vertex
is a cut vertex of P ∗ if and only if it is a cut
vertex of P . We then prove the corollary by
showing that P ∗ is indeed a bipartite distance-
hereditary embedding of P . If P ′ is a bipartite
distance-hereditary embedding of P and P ′ 6=
P ∗, then P ′ is not minimal, a contradiction.
Thus P ′ = P ∗ if P ∗ is a bipartite distance-
hereditary embedding of P .
Now we prove that P ∗ is a bipartite distance-
hereditary embedding of P . Suppose that P ∗ is
not a bipartite distance-hereditary embedding
of P . That is, P ∗ has a forbidden induced sub-
graph of bipartite distance-hereditary graphs.
Proof: Since G has no false twins, no x, y ∈
GC are false twins in GC + v. After the de-
composition, only the neighborhood of the ver-
tex used to decompose the graph is changed.
Hence v must be one of the pair of false twins,
and there exists only one vertex u in GC that u
and v are false twins in GC + v.
Suppose there exists a pair of false twins
x and y in GC . Removing v from GC + v
only changes the neighborhood of vertices in
NGC (u), where u and v are false twins in GC+v.
Hence one of x, y ∈ NGC (u). If x, y ∈ NGC (u),
they are false twins in GC + v, a contradiction.
If x ∈ NGC (u) but y 6∈ NGC [u], then they are
not false twins in GC since y is not adjacent to
u, a contradiction. Similarly, we can show that
there are no false twins in GC + v − u.
Suppose GC is non-biconnected. If u is not a
cut vertex, let x 6= u be a cut vertex of GC . Let
C1 and C2 be two components of GC −x. Since
GC + v is biconnected, v is adjacent to some
vertex of C1 and some vertex of C2 in GC + v.
Since u and v are false twins in GC + v, in GC
u is adjacent to some vertex of C1 and some
vertex of C2, a contradiction to the assumption
that x 6= u is a cut vertex. Hence u is the only
cut vertex in GC . Similarly, we can show v is
the only cut vertex of GC + v − u.
Corollary 8. The probe graph P [C + v] produced
in Case 1. of Algorithm R and the probe graphs
Pˆ and Pˇ produced in Case 2. of Algorithm R are
pseudo-kernel probe graphs. In addition, if u and v
are the only pair of false twins in PG[C + v], after
removing a false twin according to Corollary 6 from
P [C+ v], Pˆ , and Pˇ , the resulting probe graph R is
a pseudo-kernel probe graph.
Proof: Note that PG[C + v] satisfies one of
the conditions of Theorem 10 and v is not a
prime. Assume u is the false twin of v. By
the steps of removing false twins according to
Corollary 6, if v is a probe, we remove u; if v is
a nonprobe and u is a nonprobe or a prime, we
remove u; if v is a nonprobe and u is a probe,
we remove v. After removing false twins, if
the resulting probe graph R is biconnected, by
Theorem 10 it is a kernel probe graph. Assume
R is non-biconnected, by Theorem 10 one of u
and v is the only cut vertex of R. Moreover, the
only cut vertex in R is not a prime.
Now we are ready to describe Algorithm C.
The input of Algorithm C is a two-tuple (P, v)
where P is a pseudo-kernel probe graph and v
is a vertex in P with PL(v) = P or N. Note that
if PG is biconnected, it has at most one pair of
false twins and v is one of the false twins. If
PG is non-biconnected, v is the only cut vertex
in PG.
Algorithm C. We distinguish the following
four classes of the input graphs.
E 1. |PV | ≤ c for some constant c. Solve the
problem by brute force in O(1) time.
E 2. P is biconnected without false twins. Call
Algorithm B to solve the problem in O(n2)
time.
E 3. PG is biconnected and v has a false twin u.
It is easy to see that u can be found in linear
time by simply checking whether the open
neighborhood of the other vertices is the same
as the neighborhood of v. By Corollary 6, we
can remove one of u and v from P , and check
whether the resulting probe graph is a probe
bipartite distance-hereditary graph. We have
the following two cases:
(1) PL(v) = P. Recursively call Algorithm C to
check (P − u, v).
(2) PL(v) = N. If PL(u) = N or U, recursively
call Algorithm C to check (P − u, v). If
PL(u) = P, recursively call Algorithm C to
check (P − v, u).
E 4. PG is non-biconnected without false twins,
v is the only cut vertex in PG. Let C1, C2, . . . , Cr
be biconnected components of PG. Since v is
the only cut vertex in PG, Ci ∩ Cj = {v} for
1 ≤ i < j ≤ r. For each Ci, i = 1, 2, . . . , r, call
Algorithm C to check (P [Ci], v).
Lemma 7. Whether a pseudo-kernel probe graph is
a probe bipartite distance-hereditary graph can be
checked in O(nm) time.
Proof: Let g(n) denote the time complexity
of Algorithm C. We claim that g(n) ≤ c1nm.
The input graph of class E 1 can be recognized
in O(1) time. The input graph of class E 2 can
be recognized in O(n2) time. The input graph of
[8] Chandler, D. B., Chang, M.-S., Kloks, A. J.J., Liu, J. and
Peng, S.-L., On probe permutation graphs,Discrete Applied
Mathematics, 157 (2009), 2611–2619.
[9] Chang, G. J., Kloks, A. J. J., Liu, J. and Peng, S.-L., The
PIGs full monty - a floor show of minimal separators,
Proceedings STACS 2005, LNCS 3404 (2005), 521–532.
[10] Chang, G. J., Kloks, T. and Peng, S.-L., Probe interval
bigraphs (extended abstract), Electronic Notes in Discrete
Mathematics 19 (2005), 195–201.
[11] Chang, M.-S., Kloks, T., Kratsch, D., Liu, J. and Peng,
S.-L., On the recognition of probe graphs of some self-
complementary classes of perfect graphs, Proceedings of
COCOON 2005, LNCS 3595 (2005), 808–817.
[12] Chang, M.-S., Hung, L.-J., and Rossmanith P., Probe
distance-hereditary graphs, to appear in Proceeding of
CATS 2009.
[13] D’Atri, A. and Moscarini, M., Distance-hereditary graphs,
Steiner trees, and connected domination, SIAM Journal on
Computing 17 (1988), 521–538.
[14] Golumbic, M.C., Kaplan, H. and Shamir, R., Graph sand-
wich problems, Journal of Algorithms 19 (1995), 449–473.
[15] Golumbic, M. C. and Lipshteyn, M., Chordal probe
graphs, Discrete Applied Mathematics 43 (2004), 221–237.
[16] Hammer, P. L. and Maffray, F., Completely separable
graphs, Discrete Applied Mathematics 27 (1990), 85-99.
[17] A. Hertz, Slim graphs, Graphs and Combinatorics 5
(1989), 149–157.
[18] Johnson, J. L. and Spinrad, J., A polynomial-time recog-
nition algorithm for probe interval graphs, Proceedings of
SODA 2001, 477–486.
[19] Lanlignel, J.-M. and Thierry, E., Pruning graphs with
digital search trees. Application to distance hereditary
graphs, Proceedings of STACS 2000, LNCS 1770 (2000), 529–
541.
[20] Le, V. B. and de Ridder, H. N., Characterisations and
linear-time recognition of probe cographs. Proceedings of
WG 2007, LNCS 4769 (2007), 226–237.
[21] McConnell, R. M. and Nussbaum, Y., Linear-time recog-
nition of probe interval graphs, to appear in Proceedings
of ESA2009.
[22] Zhang, P. E., Schon, A., Fischer, S. G., Cayanis, E., Weiss,
J., Kistler, S. and Bourne, E. , An algorithm based on graph
theory for the assembly of contigs in physical mapping
of DNA, CABIOS 10 (1994), 309–317.
Table 1: Some results and open problems on probe
graphs.
Graph class Fully partitioned
probe chordal O(|P|m) (Golumbic & Lipshteyn
2004, Berry et al. 2007)
probe strongly chordal Poly. (Chandler et al. 2007)
probe chordal bipartite Poly. (Chandler et al. 2007)
probe interval O(n+m) (McConnell & Nussbaum
2009)
Probe DHG O(n2) (Chandler et al. 2006)
probe cographs O(n+m) (Le & de Ridder 2007)
Probe bipartite DHG O(n2) (Chandler et al. 2006)
probe ptolemaic O(nm) (Chang & Hung 2009)
probe comparability O(nm) (Chandler et al. 2008)
probe co-comparability O(n3) (Chandler et al. 2008)
probe permutation O(n2) (Chang et al. 2009)
Graph class Unpartitioned
probe chordal O(m2) (Berry et al. 2007)
probe strongly chordal Open
probe chordal bipartite Open
probe interval Poly. (Chang et al. 2005)
Probe DHG O(nm) [this paper ]
probe cographs O(n+m) (Le & de Ridder 2007)
Probe bipartite DHG O(nm) (Chang et al. 2009)
probe ptolemaic O(n3) (Chang & Hung 2009)
probe comparability Open
probe co-comparability Open
probe permutation Open
in G. We use NG[v] for NG(v) + v, called the closed
neighborhood of v. For a subset X of V , we use
NG(X) = ∪x∈XNG(x) − X to denote the neighbor-
hood ofX inG. A subsetX of V is called amodule in
G if for every x ∈ X NG(x)−X = NG(X). Two ver-
tices u 6= v are false twins in G if NG(u) = NG(v) and
are true twins ifNG[u] = NG[v]. We say they are twins
if NG(u) − v = NG(v) − u. A vertex v in G is called
a pendant vertex if the degree of v is one. A vertex v
in G is called a universal vertex if the degree of v is
|V | − 1. A vertex v in G is simplicial if NG(v) induces
a complete subgraph of G. In a graph G = (V,E),
two disjoint subsets S and T of V are fully adjacent if
every vertex of S is adjacent to all vertices in T . Two
setsA andB are incomparable ifA∩B 6= ∅,A−B 6= ∅,
and B − A 6= ∅. For two vertices u, v ∈ V , we use
dG(u, v) to denote the distance of u and v in a graph
G = (V,E).
We say a graph G is a distance-hereditary graph
(DHG for short) if the distance between any two ver-
tices remains the same in every connected induced
subgraph of G. It is a classical result that distance-
hereditary graphs can be captured by forbidden in-
duced subgraphs (Bandelt & Mulder 1986). For the
house, hole, domino, and gem, we refer to Fig. 1.
A hole is a k-cycle where k ≥ 5.
Theorem 1. (Bandelt &Mulder 1986) LetG be a graph.
The following conditions are equivalent:
1. G is distance hereditary.
2. G contains no house, hole, domino, or gem as an in-
duced subgraph.
3. Every connected induced subgraph ofG with at least
two vertices has a pendant vertex or a twin.
4. For every pair of vertices x and y with d(x, y) = 2,
there is no induced x, y-path of length greater than
two.
Cographs are a subclass of distance-hereditary
graphs. The following property of cographs is used
in the paper.
Theorem 2. (Brandsta¨dt et al. 1999) The following con-
ditions are equivalent:
1. G is a cograph;
2. Every induced subgraph of G with at least two ver-
tices has at least one pair of twins;
3. G is P4-free.
Figure 1: A house, a hole, a domino, and a gem.
In (D’Atri & Moscarini 1988) the notion of a hang-
ing of G by a vertex v was introduced.
Definition 1. (D’Atri & Moscarini 1988) The hanging
Φ ofG = (V,E) by v is an (`+1)-tuple (L0, L1, . . . , L`)
where ` = maxu∈V dG(u, v), L0 = {v}, and Li = {u ∈
V | dG(u, v) = i} for 1 ≤ i ≤ `.
Definition 2. Let Φ = (L0, L1, . . . , L`) be a hanging
of G. For x ∈ Li, 0 < i ≤ `, use N−Φ (x) for NG(x) ∩
Li−1. Denote the subgraph of G induced by ∪i≤j≤`Lj
by Gi for 0 ≤ i ≤ `. By definition, G = G0. Let x
and y be vertices in Li with 1 ≤ i ≤ `. We say that
(i) x properly contains y, denoted by x À y, if N−Φ (x)
properly contains N−Φ (y); (ii) x and y are equivalent,
denoted by x ≡ y, if N−Φ (x) = N−Φ (y); and (iii) x is
minimal (resp. maximal) if there does not exist any other
vertex z ∈ Li such that xÀ z (resp. z À x).
Remark 1. Let C be a component ofGi where 0 < i ≤ `.
By definition of hanging, NG(C) ⊆ Li−1.
Theorem 3. (D’Atri & Moscarini 1988) A connected
graph G is distance hereditary if and only if for every
hanging Φ = (L0, L1, . . . , L`) ofG and every pair of ver-
tices x, y ∈ Li (1 ≤ i ≤ `) that are in the same compo-
nent of Gi, we have N−Φ (x) = N
−
Φ (y). In other words,
for a component C of Gi, NG(C) and C ∩ Li are fully
adjacent.
Theorem 4. (Hammer & Maffray 1990) Suppose Φ =
(L0, L1, . . . , L`) is a hanging of a connected distance-
hereditary graph G. For any two vertices x, y ∈ Li
with 1 ≤ i ≤ `, N−Φ (x) and N−Φ (y) are disjoint or
N−Φ (x) ⊆ N−Φ (y) or N−Φ (y) ⊆ N−Φ (x).
The following corollary can be seen from the
above two theorems.
Corollary 1. Suppose Φ = (L0, L1, . . . , L`) is a hang-
ing of a connected distance-hereditary graph G. For any
two components C1 and C2 of Gi with 1 ≤ i ≤ `,
NG(C1) and NG(C2) are disjoint or NG(C1) ⊆ NG(C2)
or NG(C2) ⊆ NG(C1).
Theorem 5. (Hammer & Maffray 1990) Suppose Φ =
(L0, L1, . . . , L`) is a hanging of a connected distance-
hereditary graph G. For each 1 ≤ i ≤ `, there exists
a minimal vertex v. In addition, if v is minimal then
NG(x) − N−Φ (v) = NG(y) − N−Φ (v) for every pair of
vertices x and y in N−Φ (v).
By Theorem 3 and Theorem 5, we get the follow-
ing corollary.
3 The algorithm
In this section, we give an O(nm)-time algorithm
to recognize probe distance-hereditary graphs. This
algorithm is a recursive one. We denote the in-
put probe graph by P . The algorithm first checks
whether P is feasible. If P is not feasible, then it is
not a probe distance-hereditary graph. Set PL(u) = P
for all vertices of u ∈ PU that are adjacent to v ∈ PV
with PL(v) = N. This can be done in linear time.
In the following assume P is feasible, i.e., all neigh-
bors of a nonprobe must be probes. The algorithm
checks to which of the following classes the input
probe graph P does belong and takes action accord-
ingly:
P 1. PG has twins. If it has one, reduce the size of
P according to Lemma 4 and 5 and solve the
problem recursively. The two lemmas and the
reduction steps will be described in Section 3.1.
P 2. |PV | ≤ c for some constant c. Solve the problem
by brute force in O(1) time.
P 3. P is fully partitioned. Use the O(n2)-time algo-
rithm in (Chandler et al. 2006).
P 4. PG is biconnected and without twins. Call Al-
gorithm B, to be given in Section 3.2, to solve
the problem.
P 5. PG is not biconnected and without twins. Call
Algorithm R, to be given in Section 3.3 to solve
the problem recursively.
It is easy to see the correctness of the algorithm if
the algorithm for each class of input is correct. We
analyze the time complexity of the algorithm in Sec-
tion 3.4.
3.1 Twins
In this subsection we first prove two lemmas and
show how to use them to solve the problem recur-
sively.
Lemma 4. Suppose P is a probe graph and u and v are
true twins in PG satisfying one of the following condi-
tions.
1. PL(u) = PL(v) = P or U.
2. PL(u) = P, PL(v) = N or U.
Let P ′ = P − v if PL(u) = P. If PL(u) = PL(v) = U,
let P ′ be the probe graph obtained from P −v by changing
the label of u from U to P, i.e., P ′G = PG − v, P ′L(u) = P,
and P ′L(x) = PL(x) for x ∈ PV − u − v. Then P is a
probe distance-hereditary graph if and only if P ′ is a probe
distance-hereditary graph.
Proof. If P has an embedding P ∗, then P ∗ − v is an
embedding of P −v. Thus P ∗−v is an embedding of
P ′. Next we show that P has a distance-hereditary
embedding if P − v has one. Assume that P ′′ is a
distance-hereditary embedding of P ′.
Suppose that PL(u) = P. We obtain P ∗ from P ′′ by
attaching v as a true twin of u and relabel v as a probe
in P ∗ if PL(v) = U. Since u is a probe, we have
NP ′(u) = NP ′′(u) and hence NP∗(v) = NP (v). By
Theorem 1, P ∗ is a distance-hereditary embedding
of P .
Suppose that PL(u) = PL(v) = U. Since u and v are
adjacent in P , one of u and v is not a nonprobe in any
embedding of P . Without loss of generality assume
that u is a probe. Since P ′L(u) = P,NP ′(u) = NP ′′(u).
We obtain P ∗ from P ′′ by attaching v as a true twin
of u and relabel v as a probe in P ∗. By Theorem 1, P ∗
is a distance-hereditary embedding. ¤
Lemma 5. Suppose P is a probe graph and u and v are
false twins in PG satisfying one of the following condi-
tions.
1. PL(u) = PL(v) = P, N, or U.
2. PL(u) = P, PL(v) = N or U.
3. PL(u) = N, PL(v) = U.
Then P is a probe distance-hereditary graph if and only if
P − v is a probe distance-hereditary graph.
Proof. If P has a distance-hereditary embedding P ∗,
then P ∗−v is an embedding of P −v. Next we show
that P has a distance-hereditary embedding if P − v
has one. Suppose P − v has an embedding P ′. We
then obtain P ∗ from P ′ by attaching v as a false twin
of u. Let P ∗L(v) = P
′
L(u) if PL(v) = U. If P ∗L(u) =
P, we see NP (u) = NP∗(u) and NP (v) = NP∗(v).
Suppose P ∗L(u) = N and PL(v) = N or U. Assume
NP∗(u) = NP (u)+X , all vertices inX are nonprobes.
We obtain P ∗ from P ′ by attaching v as a false twin
of u and letting P ∗L(v) = N if PL(v) = U. Hence
NP∗(v) = NP∗(u) = NP (u) + X . By Theorem 1, we
see P ∗ is a distance-hereditary embedding of P . ¤
The proofs of the above two lemmas explicitly
point out how to reduce the size of input probe
graph P and imply the problem can be solved recur-
sively. In (Lanlignel & Thierry 2000), an O(n2)-time
algorithm was developed for removing all twins in a
given graph. The following lemma summarizes the
result of this subsection.
Lemma 6. Given a graph, removing vertices that have a
twin until it is not possible can be done in O(n2) time.
3.2 Kernel probe graphs and Algorithm B
In the subsection we deal with the case that input
graph P is of class P 4. This is the most crucial
part of the algorithm. We will show that whether
such a probe graph P is a probe distance-hereditary
graph can be recognized in O(n2) time. There are
two stages in Algorithm B. At the first stage of Algo-
rithm B, we check whether P is a probe cograph. A
probe cograph can be recognized in linear time (Le
& de Ridder 2007). If P is not a probe cograph,
we do the second stage of Algorithm B. First arbi-
trarily pick an edge (x, y) of PE . In any distance-
hereditary embedding of P , either x is a probe or y
is a probe. Hence we reduce the problem to the case
that there is a vertex p ∈ PV with PL(p) = P. We call
a probe graph P satisfying the following four condi-
tions a kernel probe graph: (i) PG is biconnected, (ii)
PG has no twins, (iii) there is a vertex p ∈ PV with
PL(p) = P, and (iv) P is not a probe cograph. Given
a kernel probe graph P and a probe p, our goal is to
determine whether P is a probe distance-hereditary
graph. We say that a kernel probe graph P is well-
labeled if there is a vertex p such that PL(p) = P and
Proof. First we prove Statement (1). By Lemma 8,
h = ` and Li = Zi for 0 ≤ i ≤ h = `. In addi-
tion, G∗ is obtained from G by adding edges. Hence
a component of G∗i , 0 ≤ i ≤ h, is a component of Gi
or the union of some components of Gi. Since both
G and G∗ are biconnected, all G0, G1, G∗0, and G∗1
have only one component. Hence the lemma holds
for i = 0 and i = 1. For 1 < i ≤ `, we prove
the statement by contradiction showing that if some
component C of G∗i is not a component of Gi then
P ∗ is not a minimal distance-hereditary embedding
of P . Suppose C is a component of G∗i that properly
contains a component D of Gi. Let P ′ be an embed-
ding of P obtained from P ∗ by removing edges con-
necting a vertex in C − D and another vertex in D.
Use G′ for P ′G. Clearly NG∗(C) = NG∗(D) ∩ Zi−1 =
NG∗(C−D)∩Zi−1 = NG′(D) = NG′(C−D). If P ′ is
still a distance-hereditary embedding of P , then P ∗
is not minimal. In the following we prove that P ′
is still a distance-hereditary embedding of P by con-
tradiction again. Assume that P ′ is not a distance-
hereditary embedding of P , i.e., G′ is not a distance-
hereditary graph. There is an induced forbidden
subgraph in G′. Let F be the set of vertices that in-
duces a hole or a domino or a gem or a house in G′.
Because the induced forbidden subgraph is formed
by removing edges connecting a vertex inD and an-
other vertex inC−D, |D∩F | ≥ 1 and |(C−D)∩F | ≥
1. Since all induced forbidden subgraph are bicon-
nected, |F ∩ NG′(C)| = |F ∩ NG∗(C)| ≥ 2. Without
loss generality assume that x1, x2, x3, and x4 are ver-
tices in F where x1 ∈ (C −D), x2 ∈ D, and x3, x4 ∈
NG∗(C). By definition, x1 and x2 are not adjacent in
G′. By assumption, x1, x2 ∈ Zi and x3, x4 ∈ Zi−1.
Clearly {x1, x2} and {x3, x4} are fully adjacent both
in G∗ and in G′. Depending on whether x3 and x4
are adjacent or not, in G′ the four vertices x1, x2, x3,
and x4 induce either a cycle of length four or a cycle
of length four with a chord. Therefore it is impossi-
ble for F to induce a hole. If x3 and x4 are adjacent,
then F must induce a gem. Otherwise F induces a
house or a domino.
1. x3 and x4 are adjacent and F induces a gem. By
observation, the universal vertex of the gem is
either x3 or x4. Without loss of generality as-
sume x3 is the universal of the gem. Then the
fifth vertex x5 of F is adjacent to x3 and one of
x1 or x2. In other words, x5 is adjacent to a ver-
tex in Zi and another vertex in Zi−1. Therefore
x5 ∈ Zi or x5 ∈ Zi−1. If x5 ∈ Zi, then x5 is
also adjacent to x4. If x5 ∈ Zi−1, then x5 is also
adjacent to both x1 and x2. It contradicts that F
induces a gem.
2. x3 and x4 are not adjacent and F induces a
house. Then the fifth vertex x5 of F is the sim-
plicial vertex of the house. It is adjacent to a
vertex in Zi and another vertex in Zi−1. By ar-
guments similar to those for proving the above
case, it contradicts the assumption that F in-
duces a house.
3. x3 and x4 are not adjacent and F induces a
domino. The fifth vertex x5 and the sixth vertex
x6 of F are adjacent and one of them is adjacent
to a vertex in Zi and the other is adjacent to a
vertex in Zi−1. Thus at least one of them is in Zi
or in Zi−1. InG′ if it is in Zi then it is adjacent to
both x3 and x4 and if it is in Zi−1 then it is adja-
cent to both x1 and x2. In other words, F does
not induce a domino, a contradiction.
Next we prove Statement (2). By Statement (1),
C is also a component of G∗i . By Lemma 8, Zi = Li
for 0 ≤ i ≤ `. Hence C ∩ Zi ⊆ C ∩ Li. Since G∗ is
obtained from G by adding edges, C ∩ Li ⊆ C ∩ Zi.
Therefore C ∩ Zi = C ∩ Li.
Finally, we prove Statement (3). Clearly the state-
ment is true if i = 1. In the following assume
1 < i ≤ `. By Statement (1) of this lemma, C is also
a component of G∗i . By Statement (2) of this lemma,
C∩Zi = C∩Li. Since |C∩Zi| > 1, by Lemma 7 both
NG∗(C) and C ∩ Zi contains probes and nonprobes.
Let x ∈ C ∩ Zi be a probe in G∗. Since G∗ is distance
hereditary, NG∗(C) = N−Ψ (x) by Theorem 3. Because
Zi = Li for 0 ≤ i ≤ ` (see Lemma 8) and x is a probe
in P ∗, N−Ψ (x) = N
−
Φ (x). Since G
∗ is obtained from G
by adding edges, we have NG(C) ⊆ NG∗(C). Thus
NG∗(C) = N−Ψ (x) = N
−
Φ (x) ⊆ NG(C) ⊆ NG∗(C).
This proves the statement. ¤
Theorem 9. Suppose P ∗ is a minimal distance-
hereditary embedding of P and C is a component of Gi
with |C ∩ Li| > 1 and 1 < i ≤ `. A vertex x ∈ C ∩ Li
(resp. NG(C)) is a probe in P ∗ if and only if x is adjacent
to all vertices in NG(C) (resp. C).
Proof. By Statement (2) of Lemma 9, C ∩ Zi =
C ∩ Li. Hence |C ∩ Zi| > 1. By Statement (3) of
Lemma 9, NG(C) = NG∗(C). Since G∗ is bicon-
nected, |NG∗(C)| > 1. Since G∗ is distance heredi-
tary, NG∗(C) and C ∩ Zi are fully adjacent by Theo-
rem 3. By Lemma 3, the theorem holds. ¤
Next we show how to use the above lemmas and
theorems to handle the case that P is of class C 2.
Algorithm for D 1. In this case there is a compo-
nent C in G2 with |C ∩ L2| ≥ 2. By Lemma 9 and
Theorem 9, a vertex x ∈ C ∩ L2 (resp. NG(C)) is
a probe in P ∗ if and only if x is adjacent to all ver-
tices in NG(C) (resp. C). Compute P ′ from P as fol-
lows. Let P ′G = PG and P
′
L(y) = PL(y) for every
y ∈ PV − (C ∪NG(C)). For every y ∈ (C ∪NG(C)),
let P ′L(y) = PL(y) if PL(y) 6= U. For every y ∈ NG(C)
with PL(y) = U, let P ′L(y) = P if in G y is adjacent
to all vertices z ∈ C ∩ L2 and let P ′L(y) = N other-
wise. If we let P ′L(y) = PL(y) for all primes y ∈ C,
we see that P is a probe distance-hereditary graph if
and only if P ′ is a probe distance-hereditary graph
by Theorem 9. But we will go further. Clearly all
vertices in NG(C) are not primes now. From i = 2
to i = `, for every y ∈ C ∩ Li with PL(y) = U, let
P ′L(y) = P if in G y is adjacent to some nonprobes
in Li−1 and let P ′L(y) = N otherwise. By Theorem 9,
we see that P is a probe distance-hereditary graph if
and only if P ′ is a probe distance-hereditary graph
after we relabel primes of P in C. In P ′, there must
be a probe p′ in C ∩ L2. Besides P ′L(y) 6= U for ev-
ery y ∈ NG(p′). Thus P ′ is a well-labeled kernel
probe graph. We then call AlgorithmW to determine
whether P ′ is a probe distance-hereditary graph. It
takes linear time to find a component C of G2 with
|C ∩ L2| > 1 and obtain P ′ in linear time. Thus the
algorithm for D 1 runs in O(n2) time.
Algorithm for D 2. In this case ` = 2 and there is
a component C of G` that C = {q} and PL(q) = P.
u ∈ PV −(X+Y +Q). From the above arguments, we
see that Pˇ is a probe distance-hereditary graph if and
only if P ′ is a probe distance-hereditary graph. Let
p′ be some vertex in NG(q). We see that p′ is a probe
in P ′ and P ′L(u) 6= U for every u ∈ NG(p′). Thus P ′
is well-labeled with respect to p′ (C 1). Hence we can
call AlgorithmW to complete the job in O(n2) time.
p
y1 y2
z
q q′
(a)
p
y1 y2
z
q q′
(b)
p
x
y1 y2
y
q q′
(c)
Figure 2: Some induced subgraphs in P where a dot-
ted line denotes two vertices are possibly adjacent or
possibly not adjacent.
The following lemma summarizes the results of
this subsection.
Lemma 10. Whether a probe graph of class P 4 is a probe
distance-hereditary graph can be determined in O(n2)
time.
3.3 Non-biconnected probe graphs without twins
and Algorithm R
In this subsection we show how to solve the prob-
lem recursively when the input probe graph P has
no twins and is not biconnected. Our algorithm is
based upon the following two lemmas.
Lemma 11. Suppose P is a connected probe graph and
P ∗ is a minimal distance-hereditary embedding of P .
Then a vertex is a cut vertex of P ∗ if and only if it is a
cut vertex of P .
Proof. Suppose P has k biconnected compo-
nents C1, C2, . . . , Ck. Let P ∗G be the graph
(P ∗V ,∪kj=1P ∗E [Ci])). It is easy to see that a ver-
tex is a cut vertex of P ∗ if and only if it is a cut
vertex of P . We then prove the lemma by showing
that P ∗ is indeed a distance-hereditary embedding
of P . If P ′ is a distance-hereditary embedding of P
and P ′ 6= P ∗, then P ′ is not minimal, a contradic-
tion. Thus P ′ = P ∗ if P ∗ is a distance-hereditary
embedding of P .
Now we prove that P ∗ is a distance-hereditary em-
bedding of P . Suppose that P ∗ is not a distance-
hereditary embedding of P . That is, P ∗ has a
forbidden induced subgraph of distance-hereditary
graphs. Let F be the vertex set of a forbidden
induced subgraph. Since P ∗[Ci] is a distance-
hereditary embedding of P [Ci], F is not a subset of
any Ci for 1 ≤ i ≤ k. Notice that F induces a hole, a
gem, a house, or a domino. All these four forbidden
induced subgraphs are biconnected. Thus F must be
a subset of some Ci, a contradiction. This completes
the proof. ¤
Lemma 12. Let P be a probe graph. If there exists a cut
vertex v in P and C is a component of PG−v, then P is a
probe distance-hereditary graph if and only if P−C has an
embedding P ′ and P [C + v] has an embedding P ′′ where
either P ′L(v) = P
′′
L(v) = P or P ′L(v) = P ′′L(v) = N.
Proof. If P has a distance-hereditary embedding P ∗,
then P ∗[C+v] is a distance-hereditary embedding of
P [C+ v] and P ∗−C is a distance-hereditary embed-
ding of P − C.
Suppose that PL(v) = P or N. By Lemma 11, P ∗ =
P ′ + P ′′ is a distance-hereditary embedding of P .
Suppose that PL(v) = U. If P [C+ v] has no distance-
hereditary embedding that v is a probe or a non-
probe, then P is not a probe distance-hereditary
graphs. If P [C + v] has a distance-hereditary em-
bedding Pˆ that v is a probe but has no distance-
hereditary embedding that v is a nonprobe, then P
has a distance-hereditary embedding if and only if
P − C has a distance-hereditary embedding that v
is a probe. Conversely, if P [C + v] has a distance-
hereditary embedding Pˇ that v is a nonprobe but
has no embedding that v is a probe, then P has a
distance-hereditary embedding if and only if P − C
has a distance-hereditary embedding that v is a non-
probe. If P [C + v] has a distance-hereditary embed-
ding Pˆ that v is a probe and P [C + v] has a distance-
hereditary embedding Pˇ that v is a nonprobe, then
P has a distance-hereditary embedding if and only if
P − C has a distance-hereditary embedding. ¤
The proof of the above lemma is constructive. It
points out a recursive way to solve the problem. We
now describe Algorithm R in detail. Let v be a cut
vertex of PG and C be a component of PG − v such
that C does not contain any other cut vertex of PG.
In other words, C + v induces a biconnected compo-
nent of PG. There are two cases:
1. PL(v) = P or N. By Lemma 12, P is a probe
distance-hereditary graph if and only if both P [C+v]
and P−C are probe distance-hereditary graphs. Call
Algorithm C to check whether P [C + v] has an em-
bedding and recursively call the main algorithm to
check whether P − C has an embedding.
2. PL(v) = U. Let Pˆ be the probe graph (PG[C +
v], PˆL) where PˆL(v) = P and PˆL(x) = PL(x) for
x ∈ C. Let Pˇ be the probe graph (PG[C + v], PˇL)
where PˇL(v) = N, PˇL(x) = P for x ∈ NG(v) ∩ C,
and PˇL(x) = PL(x) for x ∈ C −NG(v). Let P ′ be the
probe graph (PG[V − C], P ′L) where P ′L(v) = P and
P ′L(x) = PL(x) for x ∈ V −C−v. Let P ′′ be the probe
graph (PG[V − C], P ′′L) where P ′′L(v) = N, P ′′L(x) = P
for x ∈ (P − C) ∩ NG(v), and P ′′L(x) = PL(x) for
x ∈ V − C − NG[v]. Call Algorithm C to check
whether Pˆ and Pˇ have embeddings. There are four
subcases:
(a) If neither Pˆ nor Pˇ is a probe distance-hereditary
graph, then P is not a probe distance-hereditary
graph.
(b) If both Pˆ and Pˇ are probe distance-hereditary
graphs, then P is a probe distance-hereditary
graph if and only if P − C is a probe distance-
hereditary graph. Recursively call the main al-
gorithm to check whether P − C has an embed-
ding.
(c) If Pˆ is a probe distance-hereditary graph but Pˇ is
not, then P is a probe distance-hereditary graph
if and only if P ′ is a probe distance-hereditary
graph. Recursively call the main algorithm to
