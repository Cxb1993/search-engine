detectors to the public and undoubtedly they can 
detect known rootkits effectively, they cannot 
foresee what the result is when meeting unknown 
rootkits and crashed operating systems. Therefore, 
for the purpose of system security, developing an 
integrated mechanism for both protecting the 
operating systems and detecting rootkits is becoming 
extremely important. 
   This project aims to construct an integrated anti-
rootkit scheme for protecting Windows kernel to 
higher system security. After the proposed protection 
scheme has been developed, we have tested it on the 
Testbed@TWISC platform by Windows 2000, Windows XP 
SP0, Windows XP SP2, Windows XP SP3 and Windows 
Vista, respectively. We affirm our efforts will be 
extremely useful for improving the current techniques 
of preventing and detecting Windows driver-hidden 
rootkits. 
 
英文關鍵詞： Malware, Rootkit, System security, MS Windows, Kernel
 
  
  第一節  結論．．．．．．．．．．．．．．．．． 68 
  第二節  未來發展方向．．．．．．．．．．．．． 69 
參考文獻．．．．．．．．．．．．．．．．．．．．．． 70 
附件一: 國科會補助專題研究計畫成果報告自評表．．．．．． 77 
附件二: 國科會補助計畫衍生研發成果推廣資料表．．．．．． 78 
  
圖 目 錄 
圖 1-1 研究流程．．．．．．．．．．．．．．．．．． 7 
圖 2-1 作業系統架構．．．．．．．．．．．．．．．． 11 
圖 2-2 要求檔案訊息的進程(Process)．．．．．．．．． 13 
圖 2-3 進程呼叫 API．．．．．．．．．．．．．．．． 14 
圖 2-4 當 SSDT 被 Hooking 後之呼叫 API 程序．．．．． 15 
圖 2-5 呼叫被 Hooked 之 API 的程序．．．．．．．．． 16 
圖 2-6 正常 Process 雙向鏈結結構．．．．．．．．．．． 18 
圖 2-7 DKOM 技術之修改 Process 結構．．．．．．．． 18 
圖 2-8 Driver-hidden Rootkit 偵測方法流程．．．．．．． 23 
圖 2-9 尋找 Object Driver 相關屬性．．．．．．．．．． 23 
圖 2-10 RETURNIL 記憶體影子防禦系統(保護狀態)．．． 25 
圖 2-11 RETURNIL 記憶體影子防禦系統(解除保護狀態)． 25 
圖 2-12 Windows 內核代碼簽章．．．．．．．．．．．． 26 
圖 2-13 主機型入侵防禦系統．．．．．．．．．．．．． 27 
圖 2-14 全虛擬化 VMM．．．．．．．．．．．．．．． 32 
圖 2-15 半虛擬化 VMM．．．．．．．．．．．．．．． 32 
圖 3-1 整體防禦機制架構．．．．．．．．．．．．．． 36 
圖 3-2 整合式 Windows 核心模式之 Driver-hidden Rootkit
防護機制．．．．．．．．．．．．．．．．．．． 38 
圖 3-3 Windows NT system architecture．．．．．．．．． 39 
圖 3-4 Windows XP KeServiceDescriptorTable 系統呼叫(a) 41 
圖 3-5 Windows XP KeServiceDescriptorTable 系統呼叫(b) 42 
圖 3-6 Windows XP KeServiceDescriptorTable 系統呼叫(c) 42 
圖 3-7 Windows server 2008 監測機制(a)．．．．．．．． 46 
圖 3-8 Windows server 2008 監測機制(b)．．．．．．．． 47 
- 1 - 
 
                         中文摘要 
有越來越多惡意程式結合 Rootkit 技術來遮掩本身的不法行
為，使得系統安全的防衛面臨了極大的挑戰。我們發現先進的
Rootkit 技術都屬於核心模式，並且絕大部份都是以“驅動程式
(Driver Program)”的形態被載入到 Windows 作業系統核心中，容
易造成作業系統極大的傷害。在目前的 Rootkit 防禦機制中，包
括記憶體影子防禦系統 (Memory Shadowing)、內核代碼簽章
(Kernel-Mode Code Signing Walkthrough)、主機型入侵防禦系統
(Host-based Intrusion Prevention System)，皆只是消極的保護作業
系統，並無法有效的偵測是否為 Rootkit 攻擊。另一方面，雖然
市面上有許多的 Rootkit 偵測軟體被研發出來，且對各種已知型
Rootkit 皆能有效偵測，但面對未知型 Rootkit 以及具備能修復遭
毀損之作業系統的功能，則是束手無策。因此，開發一個可以積
極保護系統並具備能偵測是否為 Rootkit 攻擊之機制，是一項相
當重要的課題。 
本計畫目的在於提出兼具防禦與偵測 Windows Kernel Mode 
Rootkits 之機制，亦即建構出整合式 Windows Kernel Mode 
Rootkits 防護技術，尤其能夠防護未知型 Driver-hidden Rootkits，
以徹底去除外來的威脅及潛在的破壞。本計畫研發之 Rootkit 防
護軟體在 Testbed@TWISC 平台上進行測試，已分別通過測試
Windows 2000、Windows XP SP1、Windows XP SP2、 Windows XP 
SP3、Windows Vista 環境下的防護能力。我們相信本計畫所提出
之防護方法，應能激勵並提供相關研發 Rootkit 防護軟體之廠商
以改善其目前有關防護 Windows Driver-hidden Rootkits 的能力。 
 
關鍵詞: 惡意程式、Rootkit、系統安全、MS Windows、核心模式                                                
- 3 - 
 
第一章   緒論 
本報告第一章將介紹研究之背景、動機與目的、研究流程，
並針對本報告的章節架構作一說明。 
第一節   研究背景 
近年來，Rootkit惡意軟體與相關防禦軟體的交戰，己經顯得
白熱化，在雙方交戰的過程中，就算Rootkits被移除了，作業系統
往往也損傷過大，甚至須重新安裝作業系統，造成使用者莫大的
困擾。在Rootkits盛行下，大家越來越熟悉Rootkit這個名詞，但是
對於Rootkits的種類及技術還是略顯陌生。「Rootkit」最早出現是
在1990年代初期，其最主要鎖定目標是Sun和Linux作業系統。目
前則有針對許多作業系統的各種Rootkit，包括Microsoft Windows
平台、Unix與FreeBSD，其主要功能是「隱藏程式不讓其他軟體
發現」。因為Rootkit高深的隱藏技術，讓許多己被偵測到的木馬、
蠕蟲、病毒再次猖狂，使得一般防毒軟體或是防惡意軟體程式為
之頭疼，無法發現混合Rootkit技術的惡意程式，自然也無法清除
系統中被植入擁有Rootkit技術的惡意程式，防禦Rootkit技術己成
為各家廠商的必爭之地。現有之Rootkit可分為虛擬機器(virtual 
machine based)、資料庫型(library)、使用者模式(user mode)、核心
模式(kernel mode)和BIOS型(BIOS-Level)五種類型，其中資料庫型
與User Mode較易被偵測出且造成的威脅與傷害相對較低，然而
Kernel Mode是目前最為大宗且相當不易被發現，尤其各種新型
Kernel Mode Rootkit對系統核心之破壞甚巨，這是個非常嚴重的
問題。 
- 5 - 
 
害，內核代碼簽章方法(kernel-mode code signing walkthrough, 
KMCS)(Microsoft, 2010)則是強制嵌入認證機制至系統程式中，來
確保其安全，如此的作法使得廠商在撰寫相關驅動程式時必須加
入Windows的數位簽章，徒增不必要之困擾；另外，主機型入侵
防禦系統(host-based intrusion prevention system, HIPS)(Fuchsberger, 
2005)的作法，雖可阻擋所有的系統函數呼叫，但其功能只負責阻
擋，並不具判斷是否為惡意攻擊。綜合上述，我們可以發現目前
的Rootkit防禦機制雖然可以保護系統，但皆無法有效的判斷是否
為Rootkit入侵，其只是消極的保護作業系統且當遭受攻擊後往往
須重新建置系統環境，因此開發一個可以積極保護系統並具備能
判別是否為Rootkit攻擊之機制，是一項相當重要的課題。 
本計畫目的在於提出兼具防禦與偵測Windows Kernel Mode 
Rootkits之機制，亦即將建構出整合式Windows Kernel Mode 
Rootkits防護技術，尤其能夠防護未知型Driver-hidden Rootkits。
我們的作法是，當外來的Rootkit侵入到我們所建置的系統時，會
先遭遇到核心函數檢測機制的查核，如果符合核心函數檢測機制
所設立的規則，便會立刻阻止該Rootkit的運行，但為求檢測機制
的完善，在Rootkit的侵入過程中，透過虛擬監測機制(Virtual 
Machine Monitor) (Laureano, Maziero, and Jamhour, 2007)監視著
作業系統內所發生的一切動作，將所有完整資訊記錄下來並傳送
給核心函數檢測機制，讓該機制增加新的規則模組，以加強下一
次的查核。此外，我們另擁有一道防線是藉由上年度計畫所提出
之偵測機制，針對無法有效阻擋之Rootkit加以偵測並予以卸載
(Unload)，進而達到完整的防護。其中，整個系統環境都是在虛
擬機器下運作，其具有以下優點： 
1. 提供強而有力的隔絕環境，避免真實作業系統受到損害。 
2. 以最低的成本來建置一個作業系統，不需添加硬體設備。 
- 7 - 
 
 
圖 1-1  研究流程 
 
第四節   報告架構 
本報告由第二章開始，首先將針對與本研究相關的文獻進行
探討。第三章則為了改善目前 Rootkit 防護機制缺點，提出有效
的整合式防護機制。於第四章進行實測所提之防禦與偵測
Rootkits 功能，最後於第五章作一總結，並提出未來展望。各章
說明如下： 
第二章 文獻回顧： 
探討與本研究相關之文獻，包括Rootkit的種類與隱藏技術、
現有偵測及防禦之方法，以及Virtual Machine相關技術。 
第三章 建構整合式Windows核心模式之Rootkit防護機制： 
- 9 - 
 
第二章  文獻探討 
以下介紹現有 Rootkit 隱藏、偵測與防禦技術及 Virtual 
Machine 原理與特性。 
第一節   Rootkit 的種類與隱藏技術 
Rootkit 首先在 90 年代初期出現，它源自於 UNIX 作業系統，
在系統中原是一組指令，可藉此指令取得作業系統 root 存取權限
的工具套件(kit)，所以 Rootkit 是來自 root 與 kit 兩個字的結合。
在 UNIX-like 系統中 root 為最高權限的管理者，同時也是系統管
理員的名稱，一般的攻擊者都會想要取得系統中 root 的存取權
限，Rootkit 本身並沒有病毒或蠕蟲的特性(例如：傳播或複製)，
而攻擊者所採取一些方法(例如：開啟通訊埠、系統弱點或木馬程
式等等)將混入 Rootkit 技術的惡意軟體植入目標系統中並暗中啟
動其程式，其會隱藏惡意軟體行為使其不被系統管理者發現已植
入或正在執行的混合 Rootkit 技術的惡意軟體。 
Rootkit 雖然源自於 UNIX 系統 (Chian and Lloyd, 2007; 
Andreas, 2004)，但是包括 Windows 在內的電腦系統也已漸漸出
現數種 Rootkit，而現有的 Rootkit 也不全為指令，只要能取得、
執行系統高權限的帳號、不被系統管理者發現的工具或沿用現有
Rootkit 相同概念所撰寫的程式，都稱為 Rootkit。尤其近期的
Rootkit 都特別著重在隱藏蹤跡的技術，而已經有越來越多的間諜
軟體、病毒、蠕蟲、後門等惡意軟體，也開始加入 Rootkit 的隱
藏功能。以下玆將描述現有的 Rootkit 類型。  
一、Rootkit 的種類 
- 11 - 
 
體的程式、管理電腦的所有資源，為硬體和使用者間的介
面，如圖 2-1所示。 
 
圖 2-1  作業系統架構 
建立於Kernel層級之Kernel Mode Rootkit(Kruegel, 
Robertson, and Vigna, 2004)是比User Mode Rootkit功能更
強大。其透過操作與利用Kernel，已成為最難被發現的
Rootkit，因為它能夠在應用層檢查中，建立一條繞過檢驗
的通道。雖然這種惡意軟體主要是針對特定作業系統所製
作，但它可能被修改來針對某個通訊埠或者是其他的作業
系統來做攻擊，一旦被安裝目標主機上，系統就可說完全
是被駭客所控制，系統管理員甚至找不到駭客隱藏的蹤
跡。由上述可知此種Rootkit將會相當嚴重的威脅到電腦網
路。  
(五)BIOS 型 Rootkit 
BIOS(Basic Input / Output System)通常提供了電腦系
統與硬體元件之間溝通的橋樑，當電腦開機確認基本元件
(CPU、記憶體、顯示卡、鍵盤、滑鼠…等)裝備無誤後，
才把電腦執行權轉交給硬碟裏的OS。因此，BIOS-Level 
Rootkit(Geer, 2006)通常都比OS更低階更早被載入，進而
- 13 - 
 
 
圖 2-2  要求檔案訊息的進程(process) 
為了合宜且有效率的提供管理 APIs，提供了許多表格去儲存
各個 API 的資訊。API 也可稱為函數且都有其索引值(index value)
並在 SSDT(system service descriptor table)指向到函數的記憶體位
置。特定的函數皆有各自的索引值。一般進程呼叫存取 SSDT 四
個步驟 如圖 2-3 所示。 
步驟1：一個進程擁有該函數的索引值，並查詢SSDT得到該函
數的記憶體位置。 
步驟2：當進程得到該函數的記憶體位置後，便可以呼叫該函數。 
步驟3：Windows 執行函數。 
步驟4：函數回傳結果給原本進程。 
 
 
 
 
- 15 - 
 
 
圖 2-4  當 SSDT 被 Hooking 後之呼叫 API 程序 
2. Inline Hooking 
儘管 Table Hooking 是 Rootkit 製作者最常採用
的一個簡單且有效的方式，但此方法較容易被 Rootkit 
detectors (Keong, 2004)所偵測到。Hunt 和 Brubacher 
介紹 Detours (Detours, 1999)，其是一個函式庫可以任
意攔截 Win32 二元函數。Inline Hooking 使用類似
Detours 的作法針對呼叫的函數修改頭段使用” jump ”
指令指到 Rootkit 程式碼，而不是針對系統 table 
(SSDT)。其執行進程如圖 2-5 所示，其八個步驟說明
如下： 
步驟1：一個進程呼叫被Rootkit Hooking指到Rootkit
程式碼的函數。 
步驟2：執行 Hooked函數並立即跳到Rootkits 程式
碼。 
步驟3：Rootkit 程式執行，並且同時修改參數訊息。 
- 17 - 
 
結構。且 Windows 具有唯一的內核處理器控制結構
(KPRCB)，這個結構用來描述 CPU 當前處理的所有
資訊，它總是位於記憶體位址 0xffdff120 處，這個位
址偏移 0x124 就是指向當前 ETHEREAD 的指標，從
這個 ETHREAD 再往下偏移 0x881 便可指向進程的
FLINK。如圖 2-6 所示，在 EPROCESS 結構中皆擁有
雙向鏈結 LIST_ENTRY 結構，此結構內有兩個
DWOED 指標物件 BLINK 和 FLINK，這兩指標分別
指向目前進程(EPROCESS B)的前一個(EPROCESS A)
和後一個(EPROCESS C)進程。 
系統為每個進程都分配 4GB 的虛擬記憶體空間，前 2GB 供
使用者模式的應用程式使用，後 2GB 是核心模式記憶體空間，供
核心使用。而上述的所有結構都存在核心記憶體中，使用者模式
的程式是不能存取核心記憶體的，要存取核心記憶體，必須要有
相當的權限進入核心，因此一般要進入核心只能通過撰寫驅動程
式的方式，達到目的。 
如圖 2-7 所示，Butler 等人(Bulter, Undercoffer, and Pinkston, 
2003)使用 DKOM 一種核心結構的 EPROCESS，來改變一個雙重
鏈結，讓進程隱藏。如果要隱藏 EPROCESS B 需要把其雙向鏈結
刪除即可，並把進程 B 的前一個進程 A 的 FLINK 指向目前進程
B 後一個進程 C，再把目前進程 B 後一個進程 C 的 BLINK 指向
目前進程 B 前一個進程 A。亦即 DKOM-based Rootkits 為隱藏了
中間進程 B 之 FLINK 和 BLINK 的過程。當使用 DKOM，雖然
Rootkits 的製作者需要辛苦的了解 Windows 核心結構，但比起使
用 Hooking 的隱藏效果卻更好。 
 
- 19 - 
 
第二節   現有 Rootkit 偵測技術 
目前 Rootkit 偵測方法包括特徵偵測、行為偵測、完整
性偵測、硬體式偵測、交叉察看偵測共五種，以下將簡要描
述。 
(一)特徵偵測(signature based detection) 
特徵偵測運用在防毒軟體或是入侵偵測系統
(intrusion detection system, IDS)上已行之有年，是目前最
普遍、成熟的技術。其概念相當簡單，系統檔案被掃描時
必需包括有鑑別獨特Rootkit的特徵，一旦在使用者系統之
任一檔案內若發現此特徵，它將會發出被入侵的信號；特
徵掃描傳統上已被應用在檔案系統，但是對偵測Rootkit
是有限除非結合更先進的技術，由於Rootkit利用「Hook」
技術達到隱藏檔案之目的。從ChkRootkit的網頁中，可以
獲得適用於Linux的ChkRootkit是最常被用來當做偵測
Rootkit的工具，是基於特徵偵測方法之最典型偵測軟體的
代表(http://www.chkRootkit.org)。 
(二)行為偵測(heuristic/behavioral based detection) 
行為偵測則是搜尋Rootkit程式隱藏的元素，包括檔案
或記錄。無論特徵偵測充滿許多缺點但也可以利用行為偵
測去取代，而最佔優勢方面，其具有鑑別的能力可偵測出
新的或者先前從未被辨識之Rootkit而主要的功能是辨別
與正常系統不一樣之行為。VICE、Patchfinder都是基於此
技術所研發的Rootkit偵測軟體。 
(三)完整性偵測(integrity based detection) 
除了特徵偵測與行為偵測技術外完整性偵測也是偵
測技術另外一種選擇，一旦作業系統安裝設定完後，立即
- 21 - 
 
(六)比較分析 
如表2-1所示。從表2-1中可以看出，交叉察看偵測法
是所有偵測法當中，既適用於Windows作業系統中，亦可
偵測未知型Rootkit，而不像特徵偵測軟體，需建立特徵資
料庫(signature database)且無法偵測未知型的惡意軟體。 
表 2-1  各種偵測技術的優缺點比較 
偵測法 優點 缺點 
特徵偵測 需不定期更新病毒碼至資料庫中，即可偵測新的惡意軟體。 
無法偵測未知型的
惡意軟體。 
行為偵測 可辨識已知或未知的惡意軟體。 無法辨識特定的惡意軟體。 
完整性偵測 不需更新病毒碼至資料庫中，可發現系統檔案是否被竄改。 
無法辨識惡意軟體
行為。 
硬體式偵測 
擁有自己的 CPU，針對電腦記憶
體掃描，不被其他惡意軟體所破
壞。 
需花費大量成本建
置與維護，無法偵
測未知型的惡意軟
體。 
交叉察看偵
測 
檢測系統檔案、進程、驅動程式
與機碼。 
可偵測未知型惡意
軟體，但本身機制
需未受感染。 
 
第三節   本研究上年度提出之新型 Rootkit 偵測
技術 
關於本研究於 98 年度計畫所提出之新型 Rootkits 偵測技術，
其目標在於能偵測各種 Windows DKOM-based Driver-hidden 
Rootkits，包括亦能偵測本研究於 97 年度計畫中所研製之新型
- 23 - 
 
程式位置，並將其記錄於串列中以便稍後使用。 
步驟 4：我們將從步驟 2 得到的一個串列(稱其為串列一)與從
步驟 3 得到的另一個串列(稱其為串列二)進行比較。
如果可以從串列一找到驅動程式的記憶體位置，而在
串列二中找不到，我們便可以判定其可能為一個被隱
藏的驅動程式。 
 
圖 2-8  Driver-hidden Rootkits 偵測方法流程 
 
圖 2-9  尋找 Object Driver 相關屬性 
經由上述我們可以清楚發現到所有的Rootkit偵測技術都是
屬於被動的，其皆在Rootkit入侵攻擊之後才開始偵測，這種方式
顯然是不足的，在現今惡意軟體橫行的時代，能主動的防禦Rootkit
是刻不容緩的。因此，下一節將探討目前用於防禦Rootkit的方法。 
- 25 - 
 
 
圖 2-10  RETURNIL 記憶體影子防禦系統(保護狀態) 
 
圖 2-11  RETURNIL 記憶體影子防禦系統(解除保護狀態) 
二、內核代碼簽章(kernel-mode code signing walkthrough) 
內 核 代 碼 簽 章 (kernel-mode code signing 
walkthrough)(Microsoft, 2009)是一種將數位簽章的概念包含
在內核程式裡面，它可以辨識欲載入的驅動程式上是否有標
- 27 - 
 
入侵防禦系統(Fuchsberger, 2005)則著重在監控電腦的註冊
表、應用程式、檔案系統、系統進程等，當有 Rootkit 欲修
改系統任何資源時，防禦系統便會發出警告訊息，並訊問使
用者是否許可。主機型入侵防禦方法在防禦 Rootkit 上的確
是受到好評(Kumar, 2006)，但是卻忽略一個缺點，就是誤判
率過高，使用者本身需親自訓練該系統，並花費大量時間來
增進其精確度(Ierace, Urrutia, and Bassett, 2005)。 
我們實際使用主機型入侵防禦系統，如圖 2-13 所示，必
需自己手動設定當系統核心遭到修改時該做什麼樣的處理，
無法主動判斷是否為 Rootkit 入侵。 
 
圖 2-13 主機型入侵防禦系統 
四、虛擬機器(virtual machine) 
以虛擬機器技術為基礎的 Rootkit 防禦方式，其與記憶
體影子防禦系統有著相似的概念，但相對於記憶體影子系統
- 29 - 
 
它提供使用者在Windows、Solaris 及Linux 作業系統上虛
擬x86的作業系統，支援圖形化界面、 Intel VT-X和
AMD-V 。使用者可以在 VirtualBox 上安裝並且執行
Solaris、Windows、Linux、DOS、OpenBSD、及FreeBSD 
等系統。 
Virtualbox中可以建置多個作業系統在同一台電腦之
中，但其模擬的作業系統效率並不高，模擬越多個作業系
統記憶體需求也更大。不過模擬出來的作業系統都是獨立
分開，不用擔心會造成原主機資料的損毀。 
(三)VMware  
VMware工作站(VMware workstation)(VMware, 2009)
是VMware公司開發的商業軟體產品之一。它允許多個x86
虛擬機器同時建立和運行，不需要重新開機就能在同一台
電腦上運行兩種以上的作業系統，不同的作業系統之間還
可以互動操作，包括檔案分享及複製貼上功能，也可以設
定還原點，方便在系統不穩或中毒時快速還原，所設置的
資料也將包含在VM的映像檔及分享資料夾中，支持多
CPU，有效的與其他硬碟資料隔離，不會被網路駭客竊取。 
(四)Virtual PC  
Virtual PC(Microsoft, 2009)是由Connectix公司開發，
起初只能在Mac OS執行，後改為跨平台，稱為Connectix 
Virtual PC。Microsoft公司於2003年收購該軟體，並改稱為
Microsoft Virtual PC，可以在  Mac OS 和  Microsoft 
Windows 作業系統上模擬x86電腦。由於是在Microsoft旗
下，所以模擬Microsoft相關系統時穩定度相對提升許多，
操作也非常方便，但是其模擬效能並不高，建立越多虛擬
環境，其記憶體耗損量也越大。 
- 31 - 
 
離可確保原系統不會受到損害，全虛擬化及半虛擬化則是
前者在模擬上需透過作業系統來與硬體溝通而後者是可
直接與硬體溝通，可模擬32位元及64位元系統即是可模擬
新、舊型的作業系統。 
介紹完各虛擬機器，以下將開始說明虛擬監測機制，並闡述
其全虛擬化與半虛擬化之特性。 
第五節   虛擬監測機制(virtual machine monitor) 
在一般的防禦機制與惡意軟體交戰下，作業系統早己千瘡百
孔，每當雙方交戰結束，防禦機制有可能受到重大的傷害，甚至
作業系統的功能都會喪失，而這當中，記錄惡意軟體的攻擊過程
資料，也早己不復存在，造成整個實驗必需重新來過的困擾，因
此虛擬監測機制便成了一個重要的環節，來確保在實驗過程中，
所有的資訊被完整監控並加以保存。 
在一個虛擬作業系統環境下，創造另一個虛擬作業系統並加
於監測，我們稱之為虛擬監測機制 (virtual machine monitor, 
VMM)(Laureano, Maziero, and Jamhour, 2007)。其有兩種典型的設
置 方 式 ， 如 圖  2-13 與  2-14 所 示 ， 全 虛 擬 化 (Full 
Virtualization)(Barham, Dragovic, and Fraser et.al, 2003)這類型的
虛擬監測機制，在與硬體設備溝通時，都必需透過主作業系統的
支援，來達到虛擬監測機制與硬體之間的溝通任務。而半虛擬化
(Paravirtualization)(Youseff, Wolski, and Gorda et.al, 2006)這類型
的虛擬監測機制，不需要透過主作業系統的支援，便可與硬體設
備溝通，在這樣的情況下，效率將可大大的增加，而目前擁有這
項技術的只有 Xen 與 Hyper-v。 
- 33 - 
 
第三章   建構整合式 Windows 核心模式之
      Driver-hidden Rootkit 防護機制 
     為了建構完整的 Windows Kernel Mode Rootkits 防護機制，
其研究流程如下所示。 
 
 
 
在了解 Rootkit 的技術、特徵以及各虛擬機器技術之後，我們建
構了核心函數檢測機制和虛擬監測機制實驗環境。其作法是當外
來的 Rootkit 侵入到我們所建置的系統時，會先遭遇到核心函數
檢測機制的查核，如果符合核心函數檢測機制所設立的規則，便
會立刻阻止該 Rootkit 的運行，但為求檢測機制的完善，在 Rootkit
的侵入過程中，透過虛擬監測機制(Virtual Machine Monitor)監視
著作業系統內所發生的一切動作，將所有完整資訊記錄下來並傳
- 35 - 
 
1  Dim WMIService  
2  Dim VHDService  
3  Dim strVHD, strAction 
4  SetWMIService=  
GetObject("winmgmts:\\.\root\virtualization\Proposed  
Protection Scheme")  
  //在管理者權限下掛載本防禦機制 
5  strAction = WScript.Arguments.Item(0)  
6  strVHD = WScript.Arguments.Item(1)  
7  Set VHDService = WMIService.ExecQuery("SELECT * 
FROM ImageManagementService").ItemIndex(0)  
//呼叫虛擬機器來讀取我們掛載的防護機制 
8  Select Case strAction  
9  Case "mount"  
10  VHDService.Mount(strVHD)  
11      WScript.Echo "防禦機制掛載成功"  
12   Case "unmount"  
13      VHDService.UnMount(strVHD)  
14      WScript.Echo "防禦機制卸載成功"  
15   Case else  
16      WScript.Echo "防禦機制掛載失敗"  
17  End Select 
- 37 - 
 
卸載(Unload)，以達到完整的防護。上述之整合式防護機制如圖 
3-2 所示。以下茲將其四個步驟作一說明：  
 
步驟1：將製作的防禦機制常駐到記憶體中，以得到系統中的
SystemProcessInformation、ProcessId、 ProcessName等各
相關核心函數。 
步驟2：呼叫SystemProcessInformation、ProcessId、ProcessName等核
心函數後，再呼叫DriverSection函數，並進一步檢測
相關可疑程式是否有寫入此DriverSection核心函數。
由於 DriverSection函數裡包含著FullDllName函數，
而FullDllName包含LIST_ENTRY 結構的訊息，此訊
息擁有著前後EPROCESS之記憶體位置。為了要隱藏
驅動程式，必需先有前後兩個LIST_ENTRY鏈結的記
憶體位置，才可以做到修改鏈結的動作，如圖2-7所
示。因此，若有寫入此DriverSection核心函數的動作，
則可以判斷為DKOM-based Driver-hidden Rootkit，並
加以阻檔。 
步驟 3：檢視從虛擬監測機制所傳來Windows系統記錄、應用
程式、服務記錄檔等，從中篩選出重要的資訊，加至
核心函數檢測機制中，以強化下一次的檢測，使能阻
擋未知型Rootkit。 
步驟4：針對無法有效阻擋之Rootkit，將藉由上年度計畫所提
出 之 偵 測 機 制 來 判 斷 是 否 為 DKOM-based 
Driver-hidden Rootkit，若是則進一步予以卸載；若不
是，則結束本機制。 
- 39 - 
 
址，如圖 3-3，其目的是讓 Windows 系統掌握其相關核心函數真
正的位址，以下我們將做更為詳細的解釋。 
 
 
圖 3-3  Windows XP system architecture and components 
資料來源： Solomon, D.A. (1998). The Windows NT Kernel 
Architecture. computer, 31(10), 40-47. 
Windows 系列作業系統一般劃分為 User mode 與 Kernel 
mode 兩個層級，如圖 3-3 所示，可看出 User mode 與 Kernel mode
的唯一溝通是經由 Ntdll.dll 檔案，這個檔案是做為當驅動程式要
呼叫核心函數時從使用者層轉換到核心層的一個橋梁，在轉換過
後，驅動程式會帶著必要資料來到 SSDT(System Service 
Descriptor Table)尋找所要呼叫的核心函數真實記憶體位址，而擁
有了真實記憶體位址才可以正確的驅動其相關核心函數。 
- 41 - 
 
看 Winodws 內核核心系統，以下將舉出一個例子並做進一步描
述。 
在 LiveKd 內輸入 dd KeServiceDescriptorTable 可以看到當中
出現數個記憶體位址，如圖 3-4 所示，我們選擇其中 804e3d20
位址繼續往下探索，輸入 dd 804e3d20，發現了更多有意義的記憶
體位址，如圖 3-5 所示，為了解析其記憶體內容究竟擁有什麼資
料，因此必需使用另一個指令，輸入 u 80587691，如圖 3-6 所示，
在 80587691 位址存放著 Nt!AcceptConnectPort 核心函數，而這僅
僅是多數核心函數的其中之一。 
 
圖 3-4  Windows XP KeServiceDescriptorTable 系統呼叫(a) 
- 43 - 
 
在 經 上 述 原 理 說 明 之 後 ， 因 此 便 了 解
KeServiceDescriptorTable 在防禦機制的用意並寫入其程式中，如
下所示，亦再進行第二節所描述之第二步驟。 
Typedef  struct   ：自定義類型 
PVOID          ：無類型指標 
PULONG        ：指向一個無符號長整數的指標 
ULONG         ：長整數 
Extern           ：全域變數 
KeServiceDescriptorTable  
typedef struct _SystemServiceDescriptorTable 
{ 
PVOID ServiceTableBase; 
PULONG ServiceCounterTableBase; 
ULONG NumberOfService; 
ULONG ParamTableBase; 
} 
SERVICE_DESCRIPTOR_TABLE,*PSERVICE_DESCRIPTOR_TABLE; 
Extern PSERVICE_DESCRIPTOR_TABLE KeServiceDescriptorTable; 
//導出 KeServiceDescriptorTable 
經由 Tsaur, Chen, and Tsai (2009)所設計之 DKOM Rootkit 偵
測機制的經驗中，可以發現 DKOM 型的 Rootkit 利用當中
ZwQuerySystemInformation 來獲得所要的資訊，而我們也發現 ZW
一系列的核心函數當中，都有 System 名詞，因此本防禦程式便針
對這點，搜尋「System」關鍵點，獲取所有的 System 相關資訊，
來達到判斷是否為 DKOM 型 Rootkit 關鍵，如下所示。 
- 45 - 
 
完成上述步驟，在找到所需要的 System 資料之後，便可以將
資料複製到緩衝區，供驅動程式使用，如下所示，IRQL是Windows 
系統的中斷請求，讓新的 IRQL 替代舊的 IRQL，並取得每一個
Process PID，以獲得實體路徑的判別。 
PEPROCESS         ：指向EPROCESS數扯結構指針 
Char    *name ptr    ：指向當前Process name 
ULONG             ：長整數 
Strncpy              ：替換新的Process  
Process  Name 
BOOL GetProcessName (PCHAR Name) 
{ 
PEPROCESS       curproc; 
char             *name ptr; 
ULONG                 i;  
KIRQL             oldirql; 
If(GetProcessNameOffset) 
{ 
   curproc = PsGetCurrentProcess();   
   nameptr   = (PCHAR) curproc + GetProcessNameOffset; 
   strncpy (Name, nameptr, NT_PROCNAMELEN ); 
   return TRUE; 
} 
return FALSE;} 
 
 
 
- 47 - 
 
 
圖 3-8  Windows server 2008 監測機制(b) 
在設定其監控機制之後，為了尋找未知型 DKOM Rootkit，
因 而 載 入 由 Tsaur, Chen, and Tsai (2009) 所 製 作 之 新 型
DKOM-based Driver-hidden Rootkit，如圖 3-9 所示，DKOM-based 
Rootkit 在載入之後可被發現是由 System 來更動，故我們便可加
以判斷這個驅動程式有可能是 Rootkit。 
 
圖 3-9  Windows Server 2008 監測機制(c) 
- 49 - 
 
main() //主程式控制模組 main() 
load_detector(SP,EP);//呼叫載入偵測器函數並輸入 SP 及 EP 
 while(x=1) //x=1 使其產生迴圈達到即時偵測的效用 
 { detect(alt_SP,alt_EP); 
 if(detected!=NULL)//如 detected 陣列有資料便載入卸載函數 
      {    unload_rootkit(detected);      } 
   _sleep(3*1000);//延遲三秒鐘 
    x = 1;} 
二、偵測器起始模組 load_detector() 
在偵測器起始模組中，首先會從之前定義的記憶體範圍
搜尋一次所有的 ObjectDriver 記憶體位置並儲存到陣列中，
其演算法之變數定義及輸入輸出描述如下： 
輸入： 紀錄記憶體範圍的 SP/EP 
輸出： 把 SP 儲存到 tds 陣列 
SP/EP： 紀錄記憶體範圍的起始點/終點 
sv： 相似值 
tv： 門檻值 
sig： 儲存 ObjectDrivers 方法陣列 
tds： 儲存每個 Object Driver 裡 DriverStart 值的陣
列 
strcmp()： 比較兩邊數值的函數。如果兩值相等函數傳
回 1，否則傳回 0 
Store()： 儲存 Object Driver 到陣列的函數 
偵測器起始演算法如下： 
- 51 - 
 
三、偵測模組 detect() 
在偵測器偵測模組中，首先它會判別是否為第一次執
行，如果是便會將偵測器起始模組搜尋的所有 ObjectDriver
記憶體位置陣列，輸入到交叉查看模組進行比較得出是否有
Driver-hidden Rootkit。當第二次執行以後，它僅會對新增的
ObjectDriver 進行交叉察看已達到一定的效率。其演算法之
變數定義及輸入輸出描述如下： 
輸入： 新增 driver 的起始點(alt_SP)/終點(alt_EP) 
輸出： 把新增 driver 的起始點(alt_SP)儲存到 alt_tds陣
列 
count： 紀錄偵測執行次數 
compare()： 交叉查看函數 
alt_SP/ 
alt_EP： 
新增 driver 的起始點/終點 
sig_length： 讀取 sig 陣列長度函數 
alt_tds： 儲存新增 Object Driver 裡 DriverStart 值的陣列 
sv： 相似值 
tv： 門檻值 
sig： 儲存搜尋 ObjectDrivers 方法陣列 
tds： 儲存每個 Object Driver 裡 DriverStart 值的陣列 
strcmp()： 比較兩邊數值的函數。如果兩值相等函數傳回
1 否則傳回 0 
Store()： 儲存 Object Driver 到陣列的函數 
偵測演算法如下： 
- 53 - 
 
PsLoadedModuleList 的資料結構，因此此模組負責將偵測模
組及起始模組所找到的 ObjectDriver 與 PsLoadedModuleList
進行交叉比較便可以得到哪個 Driver 是被隱藏的，其演算法
之變數定義及輸入輸出描述如下： 
輸入： PsLoadedModuleList 
輸出： Hidden-Driver 陣列(detected) 
SP/EP： 被 Select()的紀錄記憶體範圍的起始點/終點 
tds： 儲存每個Object Driver裡DriverStart值的陣列 
fds： 儲存每個 PsLoadedModuleList 裡 DriverStart
值的陣列 
PLML： 儲存每個 PsLoadedModuleList 位置位置的陣
列 
detected： 儲存 hidden-drivers 的陣列 
Record()： 在 PLML 陣 列 儲 存 參 數 值 函 數
(PsLoadedModuleList 記憶體位置)和在 fds 的
陣列參數的 DriverStart 值 
Select()： 從 PLML 陣列選出最小與最大值並同時存為
SP 及 EP 的函數 
Searching()： 從記憶體範圍中找尋所有可能的 Driver 
Objects 的函數 
strcmp()： 比較兩陣列(tds,fds)的差異並存到 detected 陣
列中 
dm()： 特徵比對函數 
 
- 55 - 
 
2
||||
||),(
ji
ji
ji EE
EE
SSSim
+
∩
=
 
其中 is , js 分別代表 Hidden-Driver 陣列(detected)與已知
Driver-hidden Rootkit， |EE| ji ∩ 則代表兩個 Rootkit 特徵中任
一個項目所交集的個數，而 i|E |及 j|E | 分別代表 Hidden-Driver 
陣列(detected)與已知 Rootkit 特徵中任一項目的總數。 
步驟2： 將樣本先取得群集編號 is 。 
步驟3： 依據相似度比對，檢視兩個特徵是否高於門檻值。 
2
),( STSSSim ji >
 
步驟4： 若 js 的特徵相似度高於門檻值ST ，則設為同一群C ; 
反之，因較低的相似度會影響其結果，所以不予考
慮，則設為 Outlier。 
步驟5： 依其群集 C 內 js 的特徵來與 is 作判別，若有不同的
特徵則更新 sig 陣列，以供偵測模組 detect()作為後
續偵測之用；反之，則為已知特徵，並不需更新 sig
陣列。來判別是否會產生特徵，若特徵產生即存入
sig 陣列，否則回到步驟 3。 
經由上述的資料結構特徵比對得知，當未知的 Rootkit 
在系統中改變資料結構與現有已知 Rootkit 有部分相似時，
可以經由特徵來判別是否為 Driver 並經由交 叉 察 看
(compare( ) ) 模 組 來 得 知 是 否 為 新 型 未 知 的
Driver-hidden Rootkit。 
六、卸載模組 unload_rootkit() 
目前知名的 Rootkits 偵測軟體，譬如：DarkSpy、GMER、
IceSword  和 Unhooker，皆只提供了 Rootkit 偵測的功能，
- 57 - 
 
我們在本節中使用了交叉察看偵測法進行 Driver-hidden 
Rootkits 偵測，如果得到 Driver-hidden Rootkit，進而從 detected
陣列以取得該 Rootkit 的記憶體位置。並從該記憶體位置，去查
詢該位置的 Rootkit 資料結構，同時得到其 Symbolic Link Name ，
並呼叫核心的 Unload Routine 且輸入該 Driver-hidden Rootkit 的
Symbolic Link Name 。 而 Unload Routine 裏 面 的
IoDeleteSymbolicLink 將 刪 除 Symbolic Link Name ， 且
IoDeleteDevice 亦將該驅動程式進行移除，進而達到卸載功能。 
 
 
 
 
 
 
 
- 59 - 
 
個實驗的流程與步驟。 
因此，本研究將選擇成功大學Testbed@TWISC平台做為本防
護機制之測試環境，因該平台可解決傳統網路安全測試平台之不
足。 
 表 4-1  整體開發系統環境 
硬體設備 
主機型號 Acer 6700 
中央處理器 Intel(R) Core 2 Duo E8500 3.0 GHz 
記憶體 4 GB 
硬碟 250 GB 
軟體設備 
Host OS Windows server 2008(Hyper-v) 
Gost OS Windows XP SP3 
應用開發 
驅動程式 Windows Driver Kit (7600) 
應用程式 Visual Studio 2008 (C++) 
第二節   實驗流程 
以下茲將於本小節介紹整個實驗步驟，包括所使用的Rootkit
及實驗流程。 
步驟一：開啟本研究所製作之驅動級主動防禦程式，如圖 4-1
所示，來到Log畫面會有本實驗室的名稱及大葉大學圖案。 
- 61 - 
 
步驟三：在成功開啟防禦機制功能之後，便開始實地進行防
禦機制測試。 
首先載入由Tsaur, Chen, and Tsai (2009)所開發之新型
DKOM-based Driver-hidden Rootkit到作業系統當中，如圖 4-3所
示，在 Debug View內核調試工具中出現「I am here!!」字樣，這
證明了Rootkit成功隱藏在作業系統當中。 
 
圖 4-3  DKOM型Rootkit載入畫面 
在成功展示完Tsaur, Chen, and Tsai (2009)所開發之新型
DKOM-based Driver-hidden Rootkit之後，重新載入一個新的虛擬作
業系統，按照本節開頭步驟所述載入本研究所製作之防禦機制，
再一次載入Tsaur, Chen, and Tsai (2009)所設計的Rootkit，如圖 4-4
所示，出現了防止新Process被創建的視窗，成功阻擋了Rootkit，
而Debug View上也沒有出現任何訊息，故可證明本防禦機制成功
防禦了Rootkit。 
 
 
成功載入未知型
DKOM Rootkit 
- 63 - 
 
 
圖 4-5  System message畫面 
然而凡事皆有例外的狀況，舉例而言，在Winodws XP作業系
統上按開始，選擇執行，輸入Cmd會執行DOS命令提示字元。呼
叫DOS命令提示字元，這個動作是個正常動作，但是卻被本防禦
機制也認為有可能是Rootkit之一，如圖 4-6 所示。因此我們必需
將呼叫DOS命令字元列入資料庫當中，讓防禦機制確認為正常動
作而不是Rootkit，如圖 4-7所示，便是增加呼叫DOS命令字元規
則，爾後，防禦機制便不會再誤判此一程式的執行。 
 
 
 
 
 
 
- 65 - 
 
第三節   實驗成果與機制比較 
經由前兩節的實驗過程，證實了本研究的確可以阻擋由Tsaur, 
Chen, and Tsai (2009)所開發之未知型DKOM-based Driver-hidden 
Rootkit，並且也搜尋了其它相關Rootkit (Riley, Jiang, and Xu, 2008)
進行實驗，結果亦顯示能成功的抵擋，如表4-2所示。 
表 4-2  Rootkit 防禦機制實驗結果 
Rootkit Attack Category Defense 
hxdef Hook Yes 
hkdoor11 Hook Yes 
yyt hac Hook Yes 
Vice Hook Yes 
NT Rootkit Hook Yes 
HE4Hook Hook Yes 
FU DKOM Yes 
FUTo DKOM Yes 
Tsaur et al.’s DKOM Yes 
在表4-2中，FU是最具代表性的DKOM-based Rootkit，FU 
Rootkit在植入Windows 作業系統後，便會修改PsActiveProcessList
中的EPROCESS鏈結結構，以達到自身的隱藏，成功讓系統管理
者無法察覺電腦己被入侵。其亦大方的公開其原始程式碼供大家
觀摩及學習DKOM技術的原理。 
以下茲將介紹現今各防禦機制的不足之處以及本防禦機制
之優勢。 
 
- 67 - 
 
SystemProcessInformation、ProcessId、ProcessName等核心函數，
他們是DKOM-based Driver-hidden Rootkit常要呼叫的核心函數以
執 行 隱 藏 的 動 作 ， 故 本 防 禦 機 制 透 過 核 心 函 數
ZwQuerySystemInformation 將 可 精 準 的 防 禦 DKOM-based 
Rootkit，這正是本防禦機制優勢所在。 
經由上述說明，以下將各防禦機制做一優劣比較，如表4-3
所示。 
表 4-3  Rootkit 防禦機制比較 
 
          功能 
 
 
Rootkit 
防禦機制 
主動防禦 Rootkit 判別 系統穩定度 防禦規則維護 
記憶體影子
防禦系統 No No No No 
內核代碼
簽章 No No No No 
主機型入侵
防禦系統 Yes No Yes Yes 
本研究所提
之防禦機制 Yes Yes Yes Yes 
 
 
 
 
 
 
 
- 69 - 
 
第二節   未來發展方向 
目前本計畫研發之Rootkit防護機制在Testbed@TWISC平台
上進行測試，已分別通過Windows 2000、Windows XP SP1、
Windows XP SP2、 Windows XP SP3、Windows Vista環境下的防
護能力測試。未來期望本機制能延伸至 Windows 7，並從MSDN 
Library研究相關核心函數，以持續建構更具信賴的Windows 作業
系統使用環境。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
- 71 - 
 
Barham, P., Dragovic, B., Fraser, K., Hard, S., Harris, T., Ho, A., 
Neugebauer, R., Pratt, I., & Warfield, A. (2003). Xen and the 
art of virtualization. In 19th ACM Symposium on Operating 
Systems Principles, (164-177). 
Bulter, J., & Honglund, G. (2004). Rootkit Forum [online]. 
Available :http://www.rootkit.com [2009, December 14]. 
Cogswell, B., & Russinovich, M. (2005). RootkitRevealer [online]. 
Available: http://technet.microsoft.com/en-us/sysinternals/bb897445.aspx. 
[2009, December 28]. 
Chian, K., & Lloyd, L. (2007). A case study of the rustock rootkit and 
spam bot. Papers presented at the USENIX First Workshop on 
Hot Topics in Understanding Bonets. 
Chuvakin, A. (2003). An Overview of Unix Rootkits. iALERT White 
Paper, iDefense Labs, Chantilly, Virginia. 
Felten, E. W., & Halderman, J. A. (2006). Digital Rights Management, 
Spyware, and Security. IEEE Security & Privacy, 4(1), 18-23. 
Florio, E. (2005). When Malware Meets Rootkits [online]. Available: 
http://www.symantec.com/avcenter/reference/when.malware.
meets.rootkits.pdf [2009, December 14]. 
Fuchsberger, A. (2005). Intrusion Detection Systems and Intrusion 
- 73 - 
 
and Privacy, (314-327). 
Kruegel, C., Robertson, W., & Vigna, G. (2004). Detection 
kernel-level rootkits through Binary Analysis. Proceedings of 
the 20th Annual Computer Security Applications Conference, 
USA.  
Keong, C. (2004). Defeating Kernel Native API Hookers by Direct 
Service Dispatch Table Restoration [Online]. Available: 
http://www.packetstormsecurity.org/hitb04/hitb04-chew-k
eong-tan.pdf [2009, December 14]. 
Kreibich, C., & Crowcroft, J. (2004). Honeycomb: Creating intrusion 
detection signatures using honypots. ACM SIGCOMM 
Computer Communication Review, 34(1), 51-56. 
Kim, G. H., & Spafford, E. H. (1994). The design and implementation 
of tripwire: a file system integrity checker. Proceedings of the 
2nd ACM Conference on Computer and Communications 
security (pp. 18-29), USA: Virginia. 
Kumar, E. (2006). Battle with the unseen–understanding rootkits on 
Windows. Proceedings of the 9th AVAR International 
conference (pp. 96-112). 
Laureano, M., Maziero, C., & Jamhour, E. (2004). Intrusion detection 
in virtual machine environments. Proceedings of the 30th 
- 75 - 
 
Riley, R., Jiang, X., & Xu, D. (2008). Guest-Transparent Prevention 
of Kernel Rootkits with VMM-Based Memory Shadowing. 
Proceedings of the 11th International Symposium on Recent 
Advances in Intrusion Detection (pp. 1-20). 
Rutkowska, J. (2006). Subverting Vista Kernel For Fun And Profit 
[online]. Available: http://www.blackhat.com/presentations 
/bh-usa-06/BH-US-06-Rutk owska.pdf [2010, January 10]. 
Ronald, R. (1995). Retrieved 6 14, 2009, from MD5 [Online]. 
Available: http://en.wikipedia.org/wiki/MD5 [2010, January 
10]. 
Schreiber, S. (2001). Undocumented Windows 2000 Secrets: A 
Programmer’s Cookbook. Addison-Wesley. 
Solomon, D.A. (1998). The Windows NT Kernel Architecture, 
computer, 31(10), 40-47. 
Sequeira D. (2003). Intrusion prevention systems: security's silver 
bullet?. Business Communications Review (pp. 36-41). 
Sun Microsystems. (1986). VirtualBox [online]. Available: 
http://www.virtualbox.org/ [2009, December 14]. 
Tsaur, W. J., Chen, Y. C., & Tsai, B. Y. (2009). A new windows 
driver-hidden rootkit based on direct kernel object manipulation. 
- 77 - 
 
國科會補助專題研究計畫成果報告自評表 
請 就 研 究 內 容 與 原 計 畫 相 符 程 度、達 成 預 期 目 標 情 況、研 究 成 果 之 學 術 或
應 用 價 值  
1.  請 就 研 究 內 容 與 原 計 畫 相 符 程 度 、 達 成 預 期 目 標 情 況 作 一 綜 合 評 估  
■ 達 成 目 標  
2.  研 究 成 果 在 學 術 期 刊 發 表 或 申 請 專 利 等 情 形 ：  
論 文 ： ■ 已 發 表  □ 未 發 表 之 文 稿  □ 撰 寫 中  □ 無  
專 利 ： □ 已 獲 得  □ 申 請 中  ■ 無  
技 轉 ： □ 已 技 轉  ■ 洽 談 中  □ 無  
3.  請 依 學 術 成 就、技 術 創 新、社 會 影 響 等 方 面，評 估 研 究 成 果 之 學 術 或 應
用 價 值  
A、 學 術 成 就  
    本 計 畫 成 果 共 發 表 及 被 接 受 4 篇  S C I 期 刊 論 文 、 1 篇  T S S C I 期 刊
論 文 與 2 篇 國 內 外 研 討 會 論 文 ， 其 重 大 成 果 分 別 敘 述 如 下 ：  
( 1 )可 辨 識 現 有 Wi n d o w s  R o o t k i t s 防 護 軟 體 弱 點 ， 激 勵  R o o t k i t s 防 護 軟
體 廠 商 須 時 時 檢 測 其 功 能 ， 以 有 效 保 障 廣 大 使 用 者 電 腦 系 統 安 全 。  
( 2 ) 提 出 有 效 的 整 合 式  D r i v e r- h i d d e n  R o o t k i t s  防 護 軟 體 ， 提 供 相 關  
R o o t k i t s 防 護 軟 體 研 發 廠 商 及 時 更 新 其 防 禦 與 偵 測 的 能 力 。  
( 3 )本 防 護 機 制 因 採 用 了 虛 擬 監 測 機 制 來 即 時 監 測 ， 除 了 可 以 有 效 的 阻
擋  未 知 型  R o o t k i t s 攻 擊 外 ， 亦 可 以 省 去 每 次 遭 受 攻 擊 後 需 重 新 設
置 作 業 系 統 環 境 的 麻 煩 。  
B、 技 術 創 新  
( 1 )  所 研 發 之 防 護 機 制 具 有 可 偵 防 未 知 型 Wi n d o w s  D r i v e r - h i d d e n  
R o o t k i t s 之 能 力 ， 因 而 可 大 幅 提 升 防 護 軟 體 之 使 用 壽 命 。  
( 2 )  本 整 合 式 防 護 軟 體 同 時 具 有 能 防 禦 與 偵 測 隱 藏 的  R o o t k i t s，且 在 偵
測 後 可 將 其 從 作 業 系 統 中 卸 載 ( U n l o a d )， 以 徹 底 去 除 潛 在 的 破 壞 。   
C、 社 會 影 響  
( 1 )  所 發 展 之  Wi n d o w s  核 心 模 式  R o o t k i t s 高 防 護 技 術，非 常 適 合 用 於
政 府 單 位 與 各 民 營 企 業 ， 來 提 供 其 資 訊 系 統 使 用 者 的 安 全 。  
( 2 )  本 計 畫 研 製 出 比 一 般 市 售 產 品 更 強 的  R o o t k i t s 防 護 機 制，可 提 供 軍
方 用 以 保 護 其 重 要 情 報 免 於 遭 受 竊 取 。   
附 件 一  
- 79 - 
 
（ 英 文 ）  
More and more malicious programs are combined with rootkits to 
shield their illegal activities, and the result makes information 
security defense encounter a great challenge. It can be observed that 
most sophisticated kernel mode rootkits are implemented to execute 
hiding tasks through drivers in Windows Kernel. In the current 
prevention schemes, the memory shadowing, kernel-mode code 
signing walkthrough and host-based intrusion prevention system are 
all to passively protect the operating systems, and they cannot 
identify whether rootkits intrude in the operating systems. On the 
other hand, though many companies or individuals have developed 
rootkit detectors to the public and undoubtedly they can detect known 
rootkits effectively, they cannot foresee what the result is when 
meeting unknown rootkits and crashed operating systems. Therefore, 
for the purpose of system security, developing an integrated 
mechanism for both protecting the operating systems and detecting 
rootkits is becoming extremely important. 
This project aims to construct an integrated anti-rootkit scheme for 
protecting Windows kernel to higher system security. After the 
proposed protection scheme has been developed, we have tested it on 
the Testbed@TWISC platform by Windows 2000, Windows XP SP0, 
Windows XP SP2, Windows XP SP3 and Windows Vista, 
respectively. We affirm our efforts will be extremely useful for 
improving the current techniques of preventing and detecting 
unknown Windows driver-hidden rootkits. 
產業別 資訊服務業、研究發展服務業 
技術/產品應用範圍 
本計畫所研發之整 合 式 Wi n d o w s  核 心 模 式 R o o t k i t s
之 防 護 技 術，非常適合用於政府單位與各民營企業，來提供其
資訊系統使用者的安全，更可以提供防毒軟體業者及時更新其防
護能力，當然亦能在此基礎之上開發更具安全性之相關加值應用
與服務，以進一步為廣大電腦系統使用者提供一個更具信賴的
Windows 作業系統使用環境。 
1 
出席國際學術會議心得報告 
                                                             
計畫編號  NSC 99-2219-E-212-001 
計畫名稱 整合式 Windows 核心模式 Rootkits 之防護技術研究 
出國人員姓名 
服務機關及職稱 
曹偉駿 
大葉大學 資訊管理學系 教授 
會議時間地點 
 100 年 7 月 31 日至 8 月 4 日 
Maui, Hawaii, USA  
會議名稱 The 20th IEEE International Conference on Computer Communication and Networks (ICCCN 2011)  
發表論文題目 Identifying Smartphone Malware Using Data Mining Technology  
 
一、參加會議經過 
   The 20th IEEE International Conference on Computer Communication and Networks (ICCCN 
2011) 於民國 100 年 7 月 31 日至 8 月 4 日聯合 12 個 Workshop 在美國夏威夷州茂宜島的
Sheraton Maui Resort & SPA 會議中心舉行。 7 月 31 日上午 08:30 開始報到，五天會議期間
每天上午 08:50 ~ 10:00 皆有一場國際知名學者之 Keynote Speech，題目分別是 Creative 
Industries – Revolution, Agility and Excellence (by Dr. Terrence Masson Director of Creative 
Industries, Northeastern University, USA), Dynamic Spectrum Management (by Dr. John M. Cioffi, 
Chairman and CEO, ASSIA Inc., USA), Putting the Cloud in the Palm of your Hand (by Dr. Victor 
Bahl, Director of MCRC, Microsoft Research, USA), Sense and Sensibility for Mobile Networks 
(by Dr. Hari Balakrishnan, Professor, MIT, USA), and Emerging Very High Throughput Wireless 
over Optical Access Networks (by Dr. Gee-Kung Chang, Byers Eminent Scholar Chair Professor in 
Optical Networking School of Electrical and Computer Engineering, Georgia Institute of 
3 
除了參加會議以外，利用空閒時間曾至夏威夷大學電機與電腦學系，進行參訪並洽談學
術研究合作之可行性。此行參訪目的有三：(1) 實地參訪此校之通訊網路安全實驗室研究成
果，藉以尋求研究靈感；(2) 洽談與此校相關學者共同研究並發表論文之可行性；(3) 嘗試邀
請相關學者蒞臨台灣舉辦講座與開課。其中最令我印象深刻的是其學生多有優異的專業能
力，不論是來參加會議的學生或校園內被我詢問的學生，大多能侃侃而談，表現得極為熱衷
與認真，實為我國學生學習之表率。 
三、建議 
    此次會議地點設在美國夏威夷州茂宜島的 Sheraton Maui Resort & SPA 會議中心, 會場
設備齊全，每間會議室的基本配備是單槍投影機與筆記型電腦，論文發表者若需要的其他視
聽設備則可由工程人員另外提供。這些準備對發表者而言相當溫馨與方便。希望我國在舉辦
各型之國際會議時, 在場地設備上能盡量學習本次會議的做法。然而，本次會議較為遺憾是
安排的活動稍嫌單調，除了歡迎晚宴外，並沒有其他參觀活動, 值得國內借鏡。 
    建議國科會往後可多鼓勵教師藉由參加國際學術研討會，順便多作校際學術交流活動，
此舉除了可提升教師本身研究能力，亦可增加台灣學術研究之國際知名度，但也希望在經費
補助方面能再寬裕一點。例如，本次會議地點是美國夏威夷州著名之觀光勝地—茂宜島，旅
館住宿與膳食費用皆相當昂貴，因此建議國科會能考量修訂生活費補助金額。 
四、攜回資料名稱及內容 
參與此次會議共攜回 The 20th IEEE International Conference on Computer Communication 
and Networks (ICCCN 2011) 議程與論文集，包含了亞太、歐、美等國家之作者所發表之論文。 

acquire insight to develop more effective detection 
techniques for identifying mobile malware. 
II. RELATED WORK 
The previous research discussed on malware detection 
has primarily dealt with the desktop environment and is 
unsuitable for addressing malware in mobile environments, 
which are capable of spreading via non-traditional vectors 
such as Bluetooth and SMS/MMS messages; moreover, 
handhelds have much fewer resources (e.g., CPU, memory, 
and battery power) than their desktop counterparts. 
Signature-based detection methods are inefficient for 
resource-limited mobile devices because the approach must 
check whether each derived signature of an application 
matches any signature in the malware database.  
Recent studies have modeled the propagation of such 
malware in cellular and ad-hoc networks, most of which 
have focused on Bluetooth worms. The generic worm 
propagation model is based on behavioral signatures that 
describe aspects of any particular worm’s behavior, such as 
sending similar data from one machine to another, the 
propagation pattern, and the change of a server into a client 
[8]. Khayam and Radha [9] developed a topologically-aware 
worm propagation model for stationary wireless sensor 
networks. MAC layer interference was incorporated into 
this model by specifying a constant infection rate when a 
worm spreads itself onto its neighbors. Mickens et al.  
observed that traditional epidemic models fail to 
characterize worm propagation in mobile networks; 
therefore, traditional analytic models were modified to 
create a probabilistic queuing technique that accounted for 
movement and traffic patterns over various time durations. 
Zheng et al. [10] focused on modeling population 
distribution density, Bluetooth radius, and node velocity.  
Cheng et al. [11] introduced SmartSiren, a collaborative 
virus detection and alert system for smart phones. To detect 
viruses, SmartSiren collects the communication activity 
information from the smart phones and performs joint 
analysis to detect both single-device and system-wide 
abnormal behaviors. Taejoon and Shin [12] proposed a 
filesystem (Filesystem Monitoring) for checking file 
integrity, file attributes, or file access attempts. In 
monitoring file integrity, the agent yields message digests or 
cryptographic checksums for critical files, compares them 
against reference values, and verifies their differences. Kim 
et al. [13] characterized power consumption patterns of 
events and designed two important system components to 
perform a comprehensive analysis of the detection accuracy 
for pinpointing the identify of events, as well as classifying 
them as malicious or normal. Bose and Shin [14] 
investigated the propagation of mobile worms and viruses 
that spread primarily via SMS/MMS messages and 
Bluetooth. First, they study these vulnerabilities in-depth so 
that appropriate malware behavior models can be developed. 
Next, they study the propagation of a mobile virus similar to 
Commwarrior in a cellular network using data from a real-
life SMS customer network. This result reveal that hybrid 
worms that use SMS/MMS and proximity scanning (via 
Bluetooth) can spread rapidly within a cellular network, 
making them potential threats in public meeting places such 
as sports stadiums, train stations, and airports. Bose et al. 
[15] proposed a behavioral approach to detect anomalous 
activity and initiation containment of malware propagating 
via MMS/SMS. Bose and Shin [14] further model malware 
propagating through both MMS/SMS and Bluetooth vectors, 
parameterizing their analysis based upon real messaging 
workloads from a large mobile provider. Ruitenbeek et al. 
[16] also investigated propagation of MMS/SMS malware 
and various responses, although within only a small user 
population with an unconstrained messaging server. Support 
Vector Machines (SVMs) support on-line reconstruction of 
potentially suspicious behavior from the run-time behavior 
of applications, so that the observed signatures can be 
matched against a database of normal and malicious 
signatures in order to detect malicious programs from their 
partial or incomplete behavior signatures. Bose et al. [15] 
presented a behavioral detection framework for viruses, 
worms and Trojans that increasingly target mobile handsets 
and used SVM to train a classifier from normal and 
malicious data. Schmidt et al. [17] demonstrated how to 
monitor a smart-phone running Symbian OS in order to 
extract features that describe the state of the device and can 
be used for anomaly detection methods that analyze the data 
for distinguishing between normal and abnormal behavior. 
Quarantine-based systems prevent a suspicious or infected 
client from sending or receiving messages, that is to say, if 
Bluetooth worms are found on cell phones located at a 
specific area, quarantine tools can be deployed there to 
prevent them from spreading to other places. Recent 
industry initiatives such as Network Admission Control 
(NAC) [11] and Network VirusWall [18] were intended to 
enforce established security policies to endpoint devices as 
they enter a protected network. However, such systems are 
in very early stages of development for SMS/MMS and 
Bluetooth networks.  
III. THE METHODOLOGIES USED FOR DETECTING 
SMARTPHONE MALWARE 
In this section, we briefly describe the methodologies 
used in this research, such as the behavioral analysis of 
smartphone viruses by ontology, the certainty factor 
function (CF function) generation by the certainty factor 
theory and the reasoning process of detecting viruses by a 
FPN model. Finally, an example of mobile malware 
reasoning is given.  
associated with a certainty factor value between zero and 
one. Directed arcs represent the relationships from places to 
transitions and from transitions to places. A FPN structure 
can be defined as an 8-tuple:  
( )βα ,,,,,,, fOIDTPFPN =  
where  
{ }npppP ,......., 21=  is a finite set of places, 
{ }itttT ,......., 21=  is a finite set of transitions,  
{ }ndddD ,......., 21=  is a finite set of propositions, 
DPDTP == ,φ∩∩  
∞→ PTI :  is an input function, a mapping from 
transitions to bags of places, 
∞→ PTO :  is an output function, a mapping from 
transitions to bags of places, 
[ ]1,0: →Tf  is a association function, a mapping from 
transitions to real values between zero and one, 
[ ]1,0: →Pα  is a association function, a mapping from 
places to real values between zero and one, 
DP →:β  is a association function, a bijective mapping 
from places to propositions. 
Let A be a set of directed arcs. If pj ∈ I(ti), then there 
exists a directed arc aji, aji ∈ A, from the place pj to the 
transition ti. If pk ∈ O(ti), then there exists a directed arc aik, 
aik ∈ A, from the transition ti to the place pk. If f(ti) = μi, μi, 
∈ [0,1], then the transition ti is said to be associated with a 
real value μi. If β(pj) = dj, dj ∈ D, then the place pj is said to 
be associated with the proposition dj . A fuzzy Petri net with 
some places containing tokens is called a marked fuzzy Petri 
net. In a marked fuzzy Petri net, the token in a place pj is 
represented by a labeled dot •
)( jpα
. 
The token value in a place pj, pj ∈ P, is denoted by α(pj), 
where α(pj) ∈ [0,1]. If α(pj) = yi and β(pj) = dj, then it 
indicates that the proposition dj is yi. 
1) Fuzzy Production Rule 
Fuzzy production rules (FPRs) have been the most 
popular and easiest way to capture and represent fuzzy, 
vague, imprecise and uncertain domain knowledge. FPRs 
are usually presented in the form of a fuzzy IF-THEN rule 
in which both the antecedent and the consequent are fuzzy 
concepts denoted by fuzzy sets. To effectively represent 
both the fuzziness and the uncertainty in FPRs, several 
knowledge parameters such as certainty factor and threshold 
value have been incorporated into the FPRs [20].  
If the antecedent portion or consequence portion of a FPR 
contains "and" or "or" connectors, then it is called a 
composite fuzzy production rule. The composite FPR can be 
distinguished into the following rule-types [20]: 
Type 1: IF dj THEN dk (CF= μi). The fuzzy reasoning 
process of this type of rule can be represented by equation 
(7) 
( ) ( ) ijk PP μαα *=  (7) 
Type 2: IF dj1 and dj2 and….and djn THEN dk (CF= μi ). 
The fuzzy reasoning process of this type of rule can be 
represented by equation (8) 
( ) ( ) ( ) ( ){ } ijnjjk PPPP μαααα *,....,min 21=  (8) 
Type 3: IF dj THEN dk1 and dk2 and….and dkn (CF= μi). 
The fuzzy reasoning process of this type of rule can be 
represented by equation (9) 
( ) ( ) ijk PP μαα *1 = , ( ) ( ) ijk PP μαα *2 = ,…. ( ) ( ) ijkn PP μαα *=  (9) 
Type 4: IF dj1 or dj2 or….or djn THEN dk (CF= μi). The 
fuzzy reasoning process of this type of rule can be 
represented by equation (10) 
( ) ( ) ( ) ( ){ }ijnijijk PPPP μαμαμαα *,....*,*max 21= (10) 
Type 5: IF dj THEN dk1 or dk2 or….or dkn (CF= μi). The 
fuzzy reasoning process of this type of rule can be 
represented by equation (11) 
( ) ( ) ( ) ( ) ( ) ( ) injknijkijk PPPPPP μααμααμαα *,.....*,* 2211 ===
 
(11) 
In addition, let ta be a transition, and pi, pj, and pk be three 
places. If pi ∈  I(ta) and pk ∈  O(ta), then pk is called 
immediately reachable from pi. If pk is immediately 
reachable from pi and pj is immediately reachable from pk, 
then pj is called reflexive transitive closure of the 
immediately reachable relationship. The set of places which 
is immediately reachable from a place pi is called the 
immediate reachability set of pi and is denoted by IRS(pi). 
The set of places which is reachable from a place pi is called 
the reachability set of pi and is denoted by RS(pi) [20]. 
Using this simple mechanism, all the FPRs can be 
mathematically and graphically. By carefully connecting 
related place and assigning reasonable values of certainty 
factors to transitions, we can come up with an FPN that can 
make decision based on the expertise during its 
construction. 
2) FPN Reasoning algorithm 
The fuzzy reasoning algorithm is an interactive algorithm, 
and it can automatically generate all the reasoning paths 
from starting place ps to a goal place pj, and if the token 
value in the starting place ps is known, then the token value 
in the goal place pj can also be evaluated. This implies that, 
if the degree of truth of proposition ds is known, the degree 
of truth of proposition dj can be evaluated by the algorithm. 
Given a set of FPRs and an observed fact, FPR reasoning is 
used to draw an approximate conclusion by matching the 
observed fact against the set of FPRs [20]. In a FPN model, 
a transition may be enabled to fire. A transition ti is enabled 
if for all pj ∈ I(ti), α(pj) ≥ λ, where λ is a threshold value and 
λ ∈ [0,1]. A transition ti fires by removing the tokens from 
its input places to each of its output places. The truth of each 
proposition is repressed by the certainty factors (CF) for the 
propagation of uncertain evidence from the antecedent of a 
production rule to its consequences. Thus, the truth of 
proposition of the goal place is gained through FPN 
reasoning algorithm. 
 
TABLE II.    IRS AND RS FOR EACH PLACE IN FIG. 2 
Place pi IRS(pi) RS(pi) 
p1, p2, p3 {p7} { p7, p12, p13, p14} 
p7 {p12, p13} {p12, p13, p14} 
p12 {p14} {p14} 
p13 {p14} {p14} 
p14 φ φ 
IV. EXPERIMENTAL EVALUATION AND DISCUSSION 
In the experiment, a mobile environment is constructed in 
our laboratory. The HTC HD2 smartphone with Windows 
mobile 6.5 operation system is adopted as the main test 
platform. We install and run our mobile malware detection 
system (MMDS) on HTC HD2 smartphone. Then the other 
smartphones send files or messages to the HTC HD2 through 
MMS or SMS. The MMDS can automatically filter all files 
and message through extracting their behavioral 
characteristics. The system will determine the degree of 
danger of these behaviors. When users have confirmed that 
this message is in danger of intrusion, the system will refuse 
the MMS or SMS. 
In the experiment design, the FPRs are operated for 
supporting reasoning in FPN. The final proposition of the 
FPN decides whether a mobile connection behavior is 
malware. All of mobile malware are used to test the FPN 
model we propose, and most of mobile malware have been 
detected under our proposed FPN. In order to further test the 
capability of our proposed FPN model in inferring unseen 
mobile malware, we adopt some new mobile malware to test 
whether the proposed FPN can unearth them or not. These 
new mobile malware were found after September 2009, and 
they are not contained in our data set during FPN model 
construction. Table III shows the testing result of our 
proposed FPN reasoning. As a result, our proposed FPN 
model can detect most of new mobile malware. However, 
there exist two mobile malware that cannot be detected by 
our FPN model. Since the collection of mobile malware is 
difficult, we cannot gain various types of mobile malware to 
test. Thus, the FPN model through the behavior analysis of 
mobile malware based on the ontology theory may not detect 
the above-mentioned mobile malware. These problems need 
to further be studied in the near future. 
TABLE III.    TESTING RESULTS OF NEW MOBILE MALWARE (“√”: DETECTED) 
Malware Profile detected  Malware Profile detected 
WinCE.InfoJack.a √ SMS.WinCE.Redoc.g √ 
WinCE.InfoJack.b √ SMS.WinCE.Redoc.h √ 
WinCE.PMCryptic.a - SMS.WinCE.Redoc.i √ 
WinCE.InfoJack.c - SMS.WinCE.Redoc.j √ 
Virus.WinCE.Duts.a √ SMS.WinCE.Redoc.k √ 
WinCE.Brador.a √ SMS.WinCE.Redoc.l √ 
WinCE.Brador.b √ SMS.WinCE.Redoc.m √ 
SMS.WinCE.Redoc.f √ SMS.WinCE.Redoc.n  √ 
V. CONCLUSION 
Currently, anti-malware software continues to play a 
central role in defending against mobile malware. The major 
of such mechanism relies on up-to-date malware signature 
database to detect malware. However, mobile phone 
networks have very different characteristics in terms of 
limited processing power, storage capacity and battery power, 
and communication patterns. It is a challenge to distribute 
malware signatures files to the mobile devices in a timely 
manner and limits the effectiveness of complex anti-malware 
solutions in battery-powered handsets. This paper proposes a 
mobile malware detection method based on behavioral 
analysis to detect new, unknown mobile malware. We have 
illustrated a construction of smartphone malware detection. It 
is a useful approach to assist end users to detect mobile 
malware. We affirm that our proposed method is very 
meaningful, and can be incorporated with mobile handsets to 
assist the detection of mobile malware.  
ACKNOWLEDGMENT 
This work was supported by the National Science Council 
of Republic of China under contract numbers NSC 99-2219-
E-212-001, NSC 99-2622-E-212-010-CC3 and NSC 98-
2218-E-212-002. 
REFERENCES 
[1] H. S. Chiang and W. J. Tsaur, “Mobile malware behavioral analysis 
and preventive strategy using ontology, in Proc. the 2010 IEEE 
International Conference on Information Privacy, Security, Risk and 
Trust (PASSAT 2010), pp. 1080-1085, 2010. 
[2] O. Corcho, M. Fernández-López, and A. Gómez-Pérez, 
“Methodologies, tools and languages for building ontologies: where 
is their meeting point,” Data Knowledge Engineering, vol. 46, no. 1, 
pp. 41-64, 2003. 
[3] K. A. Dahlgren, “Linguistic ontology,” International Journal of 
Human-Computer Studies vol. 43, pp. 809-818, 1995. 
[4] Z. Kedad and E. Metais, “Dealing with semantic heterogeneity during 
data integration,” in Proc. 18th International Conference Conceptual 
Modeling, pp. 325-339, Nov. 1999.  
[5] D. B. Lenat, “CYC: a large-scale investment in knowledge 
infrastructure,” Communications of the ACM, vol. 38, no. 11, pp. 33-
38, 1995. 
[6] A. Bernaras, I. Laresgoiti, and J. Corera, “Building and reusing 
ontologies for electrical network applications,” in Proc. the European 
Conference on Artificial Intelligence (ECAI'96), pp. 298-302, 
Budapest, Hungary, 1996. 
[7] D. B. Lenat and R.V. Guha, Building Large Knowledge-Based 
Systems: Representation and Inference in the Cyc Project, Addison-
Wesley Pub, Boston, Jan. 1990. 
[8] D. R. Ellis, J. G. Aiken, K. S. Attwood, and S. D. Tenaglia, “A 
behavioral approach to worm detection,” in Proc. the 2004 ACM 
Workshop on Rapid Malcode (WORM), pp. 43-53, 2004. 
[9] S. A. Khayam and H. Radha, “A topologically-aware worm 
propagation model for wireless sensor networks,” in Proc. 25th IEEE 
International Conference Distributed Computing Systems Workshops, 
pp. 210-216, June 2005. 
[10] H. Zheng, D. Li, and Z. Gao, “An epidemic model of mobile phone 
virus,” in Proc. the 2006 1st International Symposium on Pervasive 
Computing and Applications, pp. 1-5, 2006. 
 (References available upon request to authors) 

其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
促成產學合作: 
(1) 合作廠商名稱: 達康數位有限公司 
(2) 合作計畫: 基於誘捕與入侵防禦技術建構高安全無線區域網路系統 
(3) 合作有效期間: 2010/11/1 ~ 2011/10/30 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
