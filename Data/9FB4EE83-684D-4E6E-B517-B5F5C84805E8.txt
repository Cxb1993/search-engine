二、 緣由與目的 
為 了 強 化 模 組 化 的 概 念 ， 傳 統 TCP/IP 
(Transmission Control Protocol/Internet Protocol)通訊協
定採用階層式 (Layer)的模組化設計 [1-3](如圖一所
示)，主要的目的在於訊息溝通只發生在相鄰的階層之
間。因此，引發一些影響效能的問題，例如無線網路
之安全性、服務品質、行動通訊的電力耗損與高錯誤
率等問題。如繼續維持此模組化的運作架構，勢必會
影響未來 4G 環境的整體執行效能。以下針對幾項重
要影響效能課題說明之。 
for QoS and resource management in the 4G-IMS 
network environment. 
The first year of the project completed the cross-layer, 
cognition, cooperation, QoS manager (C3QM） 4G-IMS 
network structure, in which interfaces were defined, 
C3QM data plane modules were designed and developed, 
and quality-of-service (QoS） in the control layer of the 
C3QM 4G-IMS network is allocated dynamically. The 
second year of this project focuses on integrating the 
services of QoS dynamic control in the C3QM 4G-IMS 
network. The data plane interfaces and modules were 
used to finish Flow Classifier and the Monitoring 
mechanism design as well as to improve Data 
Collection/Transmission functions. 
 
The second year of the project via the cooperative 
mechanism, in addition to defining and implementing the 
handoff differentiation mechanism and cooperative 
operations to comply with QoS requirements of QoS, the 
project has satisfied the requests of QoS when a handoff 
occurred. The second year of the project completed the 
mechanism of QoS agent and cross-layer, cognitive and 
cooperative process by using a cross-layer design and 
cognition-cooperative decision operating mode to satisfy 
QoS requests for various applications in heterogeneous 
networks. To enhance the quality of service, this work 
establishes a hardware environment that integrates 
project and tests with each subject, as well as confirms 
the function of each model to evaluate the system 
performance. 
圖一: TCP/IP 各層的相關協定架構 
 
一、Security：在現階段的網路環境中，使用了
許多加密協定與技術，例如 Transport Layer 與
Application Layer 之 SSH、PGP 及 SSL、Network Layer
之 IPsec、無線網路之 WEP、WPAN 等技術。由於每
個階層皆執行加密動作，雖然可以增加整體的安全
性，但相對地，由於要處理多次的加密運算，將會造
成較多的能量耗損，並增加傳輸時的延遲[4, 5]。在未
來的行動通訊網路應用，需研究如何避免此類安全考
量之負面效應。 
 
二、Quality-of-Service：現行的網路服務可以分
為 Elastic Service 和 Real-Time Service [6, 7]。面對
Elastic Service，如 FTP 協定的檔案傳輸、HTTP 協定
的網頁資料傳輸等，這些服務在一段時間內完成工作
即可；而 Real-Time Service，如語音訊息、影音資料
等，由於這些服務較具即時性的需求，因此必須在限
定的時間內完成工作。但在現行的網路環境下，系統
無法動態地針對不同的需求提供適當的服務，造成無
法滿足使用者所需的 QoS [8,9]。 
 
Keywords: IP Multimedia Subsystem Platform, 
Cross-Layer Management, Quality of Service, Resource 
Management, Cognitive Network, Cooperative Network 
 
 
 第 2 頁 / 共 86 頁
為不同的網路狀況，而使得執行效能降低，而這些效
能的波動將被大範圍的散佈開來。為了解決這些問
題，必須有一個能讓上層應用不受底層變化所影響的
QoS 設計，以確保服務品質的提供。本子計畫的研究
將著重於目前 TCP/IP 階層式架構中 QoS 不足的部份
提出解決策略，以下茲介紹國內外研究實例，說明 QoS
在有無 Cross-layer、Cognitive、4G-IMS Network 支援
情況下的差異。 
 
三、 文獻探討 
本計畫依據所提出的異質網路環境以及欲達成服
務品質保證與資源管理的目標，分別針對 IMS、
Cross-Layer Issue 及 Cognitive Network 進行文獻的蒐
集與分析，以利計畫的研究與開發‧ 
 
3.1 IP Multimedia Subsystem (IMS) 
IMS 是由國際合作組織 3GPP (3rd Generation 
Partnership Project)所提出的技術標準。IMS 平台主要
以 SIP (Session Initiation Protocol)為基礎，透過開放和
標準架構，使服務提供者可以在 IMS 平台上同時提供
語音、數據、與視訊等多樣化應用服務，亦可以作為
固網、WLAN、WiMAX、GSM、GPRS 等有線或無線
網路的共同平台。IMS 的應用目的，係在 3G 網路架
構中提供行動網際網路的服務，並確保在不同網路間
轉換時的 QoS [13, 14]。  
 
在Mobile Network內提供QoS是相當具挑戰性的
議題。由於頻寬之變動、基地台之間 Handoff 問題，
嚴重影響封包之傳遞，使得 Mobile Network 中的
Realtime Applications 相當容易受影響。在一般的有線
網路中，封包傳輸處於「最佳效率」的狀態，此狀態
意味著網路會儘量保持 Application 所需的頻寬，但不
會依據頻寬的可用性和網路的堵塞情形，予以任何的
保證，此項設計並無法確保 Mobile Network 中的
Real-time Applications 服務 QoS [15]。 
 
整合 SIP-based Network Mobility 至 IMS 環境中，
其帶來好處是節省電力、複雜度低、減少 Handoff。
此研究提出兩種機制: Loosely Coupled Architecture 以
及 Tightly Coupled Architecture。在 Loosely Coupled 架
構中(如圖四所示)，能保持原有 SIP-NEMO 及 IMS
特色，並且在會議建立初始時，讓控制訊號順利通過
於 Interrogating Network 環境。 
 
圖四: 利用鬆散耦合建立 Session 的訊號流程 
 
此外在 Tightly Coupled Architecture 中(如圖五所
示)，特色是其利用 SIP-NEMO 網路代理者，當作是
使用者代理人，整合 SIP-NEMO 於 IMS 中，會做些
許修改加強其架構更為完備，並且能提供安全機制在
IMS Network [16]。 
 
 
圖五: 利用緊密耦合建立 Session 的訊號流程 
 
IMS 的 QoS 機制是為了取代「最佳效率」狀態而
設計，以確保所提供的傳輸品質。IMS 的 QoS 機制為
確保封包傳輸的品質，經由針對相關網路狀態參數如
傳輸率、閘道延遲及錯誤率之量測，使得 Resource 可
事先被保留。用戶可依據服務形式及用戶環境，指定
要求的 QoS。IMS 中「智慧型」的 QoS Request，被
稱為政策決策功能 (Policy Decision Function，簡稱
PDF)模組(運作架構如圖六所示)，PDF 模組與基礎分
封網路互動，並控制基礎分封網路資源分配(透過 Go 
 第 4 頁 / 共 86 頁
 原發送端也因而得知網路的擁塞情況，此後兩端傳輸
將會依照相對應的排程機制，進行適當的傳輸動作，
以避免 Congestion 與 Channel Fading 情況的混淆不
清，所導致縮減傳送速率的誤判。依據這些不同的實
體網路狀況以作適當的傳送排程，一方面可以動態因
應實際的網路狀況，避免在環境不佳的時段作傳送，
另一方面也避免擁塞狀態的誤判，所導致不必要的傳
送速率縮減，從而改善整體的傳輸效能，也確保 QoS。 圖九: WQE 系統架構圖 
 
 
WQE 系統設計即從上層的 Application Layer 跨
越至 Network Layer，將 Application Layer 的 QoS 需
求，利用附加資訊的方式通知下層的 Network Layer
知道，再利用此附加資訊，依循不同的傳送策略進行
傳輸。 
 
圖八: ECN Bit 系統架構圖 一些具有代表性的跨層式設計方案如圖十所示
[19-26]。更具體來說，跨層式設計在各層會利用到的
參數如下。  
 
ECN Bit 系統主要提出的概念是由 Physical 
Layer 直接將即時的網路環境狀況，向上反映至
Network Layer,運用 IP 表頭的附加欄位作標示，以便
區隔 Congestion 及 Channel Fading 這兩種情況所造成
的封包遺失，也同樣屬於利用 Cross-Layer 的設計理
念，以確保 QoS 的實例。 
應用層： Application Types, QoS Requirements 
傳輸層： Rate Allocation, Rate Control  
網路層： Routing Policy, Admission Control 
MAC 層： Channel Assignment, Scheduling 
實體層： Rate Adaptation, Power Control 
  
 
WQE（Wireless Quality Enhancer）系統 
WQE 系統(如圖九所示)主要就是在無線網路
中，加入 WQE 裝置至 AP 有線端。上層的應用程式
會將該應用之 QoS 需求附加在每個資料片段，傳遞到
Network Layer；資料流在網路中傳遞時，在 IP 表頭的
延伸欄位中附加相關資訊以供區別 QoS 的需求。WQE
系統裡的 AP 能夠依據不同 QoS 的需求，以不同的傳
送策略進行傳遞。假如遭遇 QoS 需求無法識別的封
包，便會將該封包送到 WQE 設備，由 WQE 依據該
封包的 QoS 需求，來指定適當的傳送策略，再將此傳
送策略讓 AP 知道，並由 AP 依據 WQE 所指定的傳送
策略來進行傳送。 
圖十：跨層式之設計研究 
 
3.3 Cognitive Network 
感知網路(Cognitive Network)概念是以感知無線
電(Cognitive Radio, CR)為基礎所描繪的網路架構。
Mitola為第一位描述感知無線電的學者，在Mitola的觀
點中，感知無線電是建立在軟體定義無線電(Software 
 
 第 6 頁 / 共 86 頁
間，增加感知無線技術系統的利用度。與採取 Fixed 
Quiet Interval 的策略相比，此研究提出的設計具有頻
率選擇性衰減的優點，增進 Channel Sensing 的效能。 
網路的使用者可以藉著網際網路存取網路伺服
器，而此網路伺服器是直接連結至 CPN [32-35]，此時
的 CPN 就如同一個流量控制系統，經由兩個不同的連
接埠，連結到兩個外部 CPN，存取各自 ISP 所提供的
服務，整合之後再經由網際網路，回傳訊息給網路使
用者 [36]。此研究實作了 CPN 封包路徑選擇的協定，
再加上網路伺服器的支援，完成一套 QoS 的感知控制
系統，藉由此感知控制系統，能夠動態地去控管整個
網際網路的 QoS。 
 
Self-Aware Networks and QoS 
在各種相關的網路架構中，以QoS-Driven Routing 
Protocol 為核心的架構，稱為 Cognitive Packet Network 
(CPN)。CPN 是一種封包路徑選擇(Routing)的協定，
此協定藉由即時線上量測的數據，選擇使用適合的技
術進行路徑選擇。執行 CPN 的必備條件中，其中一項
為第一次進行隨機搜尋時，CPN 即使沒有初始值也能
夠自我啟動(Cold Start)，並經由執行的紀錄，逐步地
改善其行為。由於網路的主要功能是將從某一來源(S)
的封包轉送到某一目的地(D)，因此 CPN 必須具備即
使沒有轉送路徑的資訊，還是能將封包從 S 轉送到 D
的功能(如圖十四所示)。 
 
Multi-Agent System 
    Multi-Agent Systems (MASs)是由多個代理者
(Agent)所構成的，MASs 是屬於 Distributed Artificial 
Intelligence (DAI)系統之一環。DAI 系統是任務分派、
協調、合作與代理者之間的相互作用語言相關研究之
先驅[37]。MASs 的研究目標比 DAI 的目標更寬廣，
其中包含了任何軟體代理者的分散式網路系統。雖然
MASs 沒有標準的定義，而在 Jennings 所發表的 Paper
中，定義了三個概念：Situated，Autonomous 和
Flexible[38]。Situated 指的是代理者在他們的環境中，
可以感覺和行動。有別於一般對代理者的認知，定義
為具有不完整的知識、環境的部份控制權或兩者兼具
[39]。Autonomous 指的是代理者能夠像人類般自由地
行動，或代理者會考慮其它代理者在自主程度上的限
制。Flexible 指的是代理者對環境變動適時做出反應甚
至預先行動，並可以和其他代理者相互動，甚至和人
們互動，就像人們互相幫助般解決問題。 
 
 
圖十四: CPN Network Topology 
 
在此研究中利用 CPN 的技術，開發出 Dynamic 
QoS Control 實驗系統，運作架構如圖十五所示。整個
系統操作範圍在網際網路中進行，使用的是動態流量
控制，其中網路伺服器藉由不同的網際網路連接埠，
將訊息傳遞出去，此方法可以有效的降低上述訊息傳
遞的延遲。 
 
Dietterich 描述一個標準代理者模組應包括四個
主要部份：觀察、行動、推論引擎和知識庫[40]。在
代理者模型中，推理和學習是使用推論引擎和知識庫
相結合的結果。而推理是推論引擎從知識庫收集相關
的資訊、知覺的輸入和行動的集合來決定的即時過
程。學習是較長期的過程，藉由推論引擎去評估關係，
譬如比較過去行動和當前觀察之間的關係，或在並行
的行動之間觀察等，並且觀察的結論轉換成知識，再
存放於知識庫。  
圖十五: Dynamic QoS Control System  
Wooldridge提出兩個影響MASs研究的要點[41]：  
 第 8 頁 / 共 86 頁
 圖十九為可見增強式學習法將會建立一個學習
代理人，而學習代理人將根據現在所處的狀態(state)
採取動作(action)，初始時，若無任何知識基礎下，代
理人可任意選擇一項動作。環境(environment)當接收
到此動作後，即依據此動作回饋給代理人一個報酬
(reward)，此報酬可能是正面的獎勵或是負面的懲罰，
且學習代理人則會以極大化未來整體預期收益
(expected return)為目標，由方程式(1)其 value 則表示
為預期最大收益，E 則表示為預期報酬，r 為增強式訊
號，γ 則為[0,1]係數值。 
value=E[rt+γrt+1+γ2rt+2+…]                    (1)              
 
 
圖十九:增強式學習法架構圖 
 
其預期最大收益值則可用於建立與調整此項狀
態與動作的價值函數(value function)，價值函數所代表
的意義是在此狀態下採取這個動作後所能獲得的預期
收益，而價值函數的起始值通常設為零，也可根據基
礎知識設定其它的數值。當環境在予以學習代理人報
酬的同時，也會提供下一個狀態給代理人，代理人根
據環境所提供的新狀態選擇一個相對應的動作。藉由
代理人與環境反覆互動後，則代理人可學習到一個狀
態與動作的對應，在增強式學習法中稱此對應為策略
(policy)，之後遇到同樣的狀態時，系統便可根據此策
略進行決策。 
 
 價值函數則根據馬爾可夫決策過程定義其方程
式，由於增強式學習法目標則為獲得眾多報酬、狀態
與動作參數，於是價值函數定義兩個函數為 state-value
函數和 action-value 函數，配合一系列的策略來表示其
方程式。方程式(2)則為 state-value 函數，且方程式(3)
為 action-value 函數，而方程式中參數 π 表示為一系列
策略，s 則為狀態，a 為所反應之動作，R 則表示回應
之報酬，根據其兩種函數，則定義出於最佳化策略 π＊
中之 state-value 函數以及 action-value 函數，如方程式
(4)、(5)，而方程式(6)為利用最佳化之 state-value 函數
與 action-value 函數所計算出之價值函數。 
 
     (2) 
   (3) 
                     (4) 
                      (5) 
              (6) 
 
 依據增強式學習法之概念，本研究利用
-Learning 實現其概念，Q-learning 是一種 off-policy Q
時間差分控制方法，於估算價值函數時，Q-learning
採用的是下一個狀態中價值函數最高的動作之價值函
數值，而非學習代理人在下一個狀態實真正採用的動
作的價值函數值，其計算方式如方程式(7)，而所計算
結果稱為 Q-value，用於表示一對狀態與動作之函數
值。 
 
      (7)  
 根據以上 Q-Learning 方程式中，其 t+1,
α)表示從下一個狀態 st+1 能的動作中來挑選
maxa Q(s
中所有可
出價值函數最高的動作 a 的價值函數值做為調整之
用，而非下一個狀態真正採用的動作價值函數值，其
下一個狀態真正採用的動作的價值函數值應為 Q(st+1,
αt+1)，圖二十為 Q-Learning 演算法。 
 
 
 
 
 第 10 頁 / 共 86 頁
 資料層中涵蓋四個模組，其 Data Collection 模組
中包含 Delay、Jitter、Packet Loss Ratio 和 Throughput
等 QoS 參數值；Local Trigger 模組則為當事件發生
時，依據知識層所定義之 QoS 策略來觸發傳送訊息於
控制層；Data Cooperation 模組則接收其他代理人傳送
之資料，並給予 Local Trigger 模組來觸發特定事件；
Parameter Transmission 模組為接收換手訊息並傳送換
手訊息於各異質網路中基地台(Base Station)得知，如
圖二十四所顯示其 Mobile Node 中架設代理人來傳送
換手之訊息於原先所架設之Base Station 0用以換手至
Base Station 1。 
圖二十五: Validation Mechanism 
 
圖二十六: Decision-making 模組織流程圖 
圖二十四:Handoff Procedure 
控制層中之 Q-Learning 模組則用予計算 Q-value
且 Control 模組則傳送控制訊號於各層做 QoS 之決
策，而 Validation 模組則為監控其他代理人的 QoS 參
數值是否更新，並將相關資訊回傳給原先之網域中代
理人，用於做為判斷是否將參數值更新之依據，如圖
二十五所示。知識層則利用 Knowledge base 模組來儲
存 QoS 決策之參數值，並運用 Decision-making 模組
接收控制層所傳送之 Q-value 做為依據，傳送換手之
相關訊息，圖二十六則顯示 Decision-making 模組之流
程圖，判斷是否進行換手之動作。 
 
4.4 QoS 策略 
本研究之 QoS 策略依據 3G、WLAN 及 WiMAX 
QoS 規格，將不同類型之應用程式分為 Interactive 
Class，VoIP，Video/Audio Streaming 以及 Best Effort
等四個類別(如表二所示)，每類應用程式具有不同的
QoS 需求，結合由感知能力所獲取的 RSSI 值進行
QoS 的決策，判斷是否有更合適的存取網路提供使用
者做換區的動作以獲得最佳的傳輸品質。當使用者的
網路環境遭受到雜訊干擾時，往往會造成傳輸的品質
 
 
 第 12 頁 / 共 86 頁
 
圖三十一:VoIP Jitter 
 
圖三十二顯示有使用 Q-Learning 的 Multi-agent 
System 的封包遺失率會低於沒有使用 Q-Learning 的
Multi-agent System 的封包遺失率。由上述結果可知，
本計畫所提出之 Q-Learning 的 Multi-agent System 在
對於不同應用程式的平均延遲時間(Delay Time)、抖動
時間(Jitter)、及封包遺失率(Packet Loss Ratio)皆比傳
統無使用 Q-Learning 的 Multi-agent System 穩定，故
將增強式學習法之代理人建置於異質網路中，並不影
響其平均延遲時間、抖動時間與封包遺失率增加。 
 
 
圖三十二:封包遺失率 
 
5.2 實作成果 
圖三十三為本計畫完成之 IMS QoS Framework
架構，其中 Policy Repository 由 Open Source 的 XDMS 
Server 進行建構，用來儲存定義的 QoS Policy 檔案。
本計畫定義完成四種 Policy，分別為 Codec、Domain 
Name、QoS Class 和 Application Class Authorization 
Rules。PCRF 具備 Domain Processor 功能模組，藉由
XCAP 協 定 (Parsing XML documents) 取 得 遠 端
Repository 存放的 QoS Policy 檔案定義之參數，以及
具備 Generic Processor 功能模組取得全域的參數設
定。本計畫處理 AAA 認證需求，主要採取 Open Source
的 Diameter Engine。PCRF 與 AF 之間 AAA 資訊傳遞
透過 Diameter Rx 介面實現，而位於 Transport Layer
之 PCEF與 PCRF間資訊傳遞則透過Diameter Gx介面
實現。PCRF 能夠接收 AF 傳送的授權要求，依據其
QoS 要求取得對應的 Policy 定義之參數，及結合本計
畫完成之 QoS 演算法決策後的 QoS 參數，封裝成 Gx 
介面之Diameter RAR訊息向PCEF要求執行。當PCEF
實際將 Traffic Flow 執行 Admission Control 後，則回
傳 Diameter RAA 訊息給 PCRF。 
 
 
圖三十三: Proposed IMS QoS framework 
 
圖三十四為編輯 Codec Policy 之介面，藉由此介
面，管理者可依據 QoS 需求，動態更改多媒體傳輸所
需要的 Codec 模式，例如:g722、g723 和 g729 等
Codec。當完成編輯並按下 Add Codec 按鈕後，PCRF
會接收到 AF 傳送的認證需求(Rx 介面之 Diameter 
AAR 訊息)，將更換後的 Codec Policy 進行處理，再
向 PCEF 傳送再次認證需求(Gx 介面之 Diameter RAR
訊息)，讓 PCEF 實際替換 Session 的 Codec 模式。 
 
 第 14 頁 / 共 86 頁
 圖三十八: 動態編輯 Application Class Policy 
 
圖三十九為 QoS Parameter Database 介面，藉由
此介面，管理者可隨時監控異質存取網路之整體網路
狀態，並將底層觀察並分析後的 QoS 資訊，例如: 
Packet lost、Delay 和 Jitter 等參數呈現在管理介面上。
QoS Parameter Database 也提供 QoS 參數儲存之功
能，將資料送到後端資料庫存放(MySQL Database)，
使本計畫設計之QoS策略能夠依據分析後的資訊進行
決策。 
圖四十: 判斷是否超過最大頻寬  
 
圖四十一為監測流量，目前有五台電腦皆由 AP
指派虛擬 IP，可相互連結傳遞資料。當流量超過 QoS 
class 頻寬限制需求，就會在 AP 執行頻寬流量的監控
程式，中斷超過頻寬的用戶 IP。因此中斷上述超過頻
寬的用戶，就無法連線至 AP。圖四十二為執行實作程
式。  
 
 
 
圖三十九: QoS Parameter Database 
 
圖四十為透過 Monitor.o 功能模組，使 PCEF 可
得知目前擷取到的 IP 流量，自動判斷是否超過管理者
所設定之最大頻寬，再透過 iptable 語法寫進程式，即
能成功控制防火牆 terminate 此用戶。 
圖四十一: 監測流量  
 
 第 16 頁 / 共 86 頁
  
圖四十八: QoS_learningAgent 執行畫面 圖四十六: QoS_pAgnet 執行畫面 
  
六、 計畫成果自評 
現今瞬息萬變的網路應用環境中，即時性
（Real-Time）的應用服務是研發重點，然而網路資源
有限，但品質保證之需求卻無止盡地提升，因此需要
一個品質保證的服務，以確保網路使用者的權益。在
現代之網際網路蓬勃發展下，使用者皆處於有線及無
線之異質性網路環境，故注重的服務品質也不盡相
同。例如：無線網路環境中比較著重於位元錯誤率、
資料重傳，以及封包遺失的問題，主要是因為眾多服
務品質控制參數於有線環境中之敏感度較低。此外，
應用程式類別繁多，造成所需控制之服務品質參數有
所差異。例如：網路電話則注重延遲變化率，以及端
對端的延遲時間，線上電影較為重視封包遺失率相對
於影片解析度的影響。 
 
故根據現有的QoS規範，以多媒體應用軟體之
QoS分類為基礎，本計畫設計出可適性QoS管理機
制，用於即時監控網路流量及網路壅塞時的頻寬管
理，且提供可選擇性的存取網路，針對無線網路異質
性的服務品質參數來做進一步控制調整，進而確保
Access Network的服務品質，並可提供相關參數運用
於換手機制使用，達到本計畫之QoS控制與整體
4G-IMS網路架構之完整性。 
 
本研究為三年期之研究計畫，研究主題分別為
「4G-IMS網路架構、介面定義與C3QM資料層模組設
計與開發」、「All-IP 4G網路C3QM控制層QoS整合與
動態調配」及「4G-IMS網路C3QM知識層之QoS動態
控管之服務整合」三大課題。 
 圖四十七為 QoS_dbAgent 接收資訊後之訊息，
透過 QoS_dbAgent 可定時與 HSS 進行相互溝通，QoS
資料定時更新，可讓使用者方便於得知目前QoS資訊。 
 
 
圖四十七: QoS_dbAgent 動態更新資訊 
 
 透過 Q-Learning 演算法，將其應用於 PCRF 中，
並建置 QoS_learningAgnet，執行 QoS 理想頻段之決
策，並依照 QoS_pAgent 定時傳遞更新資訊，也將立
即更新決策資訊，其相關決策結果，則可提供子計畫
四進行換手之依據。圖四十八為 QoS_learningAgent
執行畫面。 
 
 第 18 頁 / 共 86 頁
參考文獻 
 
[1] J. Choi, Kihong Park and C.K. Kim, “Analysis of 
Cross-Layer Interaction in Multirate 802.11 
WLANs,” IEEE Transactions on Mobile Computing, 
Vol. 8, No. 5, pp. 682-693, May 2009. 
[2] B.J. Chang and J.F. Chen, “Cross-Layer-Based 
Adaptive Vertical Handoff with Predictive RSS in 
Heterogeneous Wireless Networks,” IEEE 
Transaction on Vehicular Technology, Vol. 57, No. 
11, pp. 3679-3692, Nov. 2008. 
[3] F. Foukalas, V. Gazis and N. Alonistioti, 
“Cross-Layer Design Proposals for Wireless Mobile 
Networks: a Survey and Taxonomy,” IEEE 
Communications Survey & Tutorials, Vol. 10, No 4, 
pp. 70-85, Apr. 2008. 
[4] C. Xiangqian, K. Makki, Y. Kang and N. Pissinou, 
“Sensor Network Security: a Survey,” IEEE 
Communications Surveys & Tutorials, Vol. 11, No. 2, 
pp. 52-73, Apr. 2009. 
[5] W.L. Benjamin, J.F. Colin and A.C. David, 
“Cross-Layer Verification of Type Flaw Attaches on 
Security Protocols,” Proceedings of ACM 13th 
Australasian Conference on Computer Science, Vol. 
62, pp. 171-180, 2007. 
[6] H. Ekstrom, “QoS control in the 3GPP evolved 
packet system,” IEEE Communications Magazine, 
Vol. 47, No. 2, pp. 76-83, Feb. 2009. 
[7] P. Bellavista, A. Corradi and L. Foschini, “IMS-based 
Presence Service with Enhanced Scalability and 
Guaranteed QoS for Interdomain Enterprise 
Mobility,” IEEE Wireless Communications, Vol. 16, 
No. 3, pp. 16-23, Jun. 2009. 
[8] Y.T. Mai, C.C. Yang and Y.H. Lin, “Cross-Layer QoS 
Framework in the IEEE 802.16 Network,” 
Proceedings of the 9th International Conference on 
Advanced Communication Technology, Vol. 3, pp. 
2090-2095, Feb. 2007. 
[9] M.S. Siddiqui, R.A. Shaikh and C.S. Hong, “QoS 
Control in Service Delivery in IMS,” Proceedings of 
the 11th Interational Confernece on Advanced 
Communication Technology, Vol. 1, pp. 157-160, 
Feb. 2009. 
[10]M.K. Denjo, E. Shakshuki and H. Malik, “A 
Mobility-Aware and Cross-Layer Based Middleware 
for Mobile Ad Hoc Networks,” Proceedings of the 
21th International Conference on Advanced 
Networking and Applications, pp. 474-481, 2007. 
[11] M. Chang, M. Lee and H. Lee “Per-Application 
Mobility Management with Cross-Layer Based 
Performance Enhancement,” IEEE Wireless 
Communications and Networking Conference, pp. 
2822-2827, Mar. 2008. 
[12] V.C.M. Leung, J. Zhang, F.R. Yu, H.C.B. Chan and 
H. Tang, “Enhancing Interoperability in 
Heterogeneous Mobile Wireless Networks for 
Disaster Response,” Preceding of the IEEE 
Transactions on Wireless Communications, Vol. 8, 
No. 5, pp. 2424-2433, May 2009. 
[13] L. Lifeng and L. Gang, “Cross-Layer Mobility 
Management based on Mobile IP and SIP in IMS,” 
Proceedings of the International Conference on 
Wireless Communications, Networking and Mobile 
Computing, pp. 803-806, Sep. 2007. 
[14] M.A. Melnyk, A. Jukan and C.D. Polychronopoulos, 
“A Cross-Layer Analysis of Session Setup Delay in 
IP Multimedia Subsystem (IMS) with EV-DD 
Wireless Transmission,” IEEE Transactions on 
Multimedia, Vol. 9, No. 4, pp. 869-881, Jun. 2007. 
[15] A. Anzaloni, M. Listanti and I. Petrilli, 
“Performance Study of IMS Authentication 
Procedures in Mobile 3G Networks,” Proceedings of 
the International Conference on Wireless 
Communications and Mobile Computing, pp. 
248-253, 2007. 
[16] W.K. Chiang, A. Ren and Y.C. Chung, "Integrating 
SIP-Based Network Mobility into IP Multimedia 
Subsystem," Proceedings of the IEEE Wireless 
Communications and Networking Conference, 
pp.1-6, 5-8 April 2009. 
[17]M.S. Siddiqui, S.O. Amin and C.S Hong, “A Set-Top 
Box for End-to-End QoS Management and Home 
Network Gateway in IMS,” IEEE Transactions on 
Consumer Electronics, Vol. 55, No. 2, pp. 527-534, 
May 2009. 
[18]K.S. Munasinghe and A. Jamalipour, “Interworked 
WiMAX-3G Cellular Data Networks: An 
Architecture for Mobility Management and 
Performance Evaluation,” IEEE Transactions on 
Wireless Communications, Vol. 8, No. 4, pp. 
1847-1853, Apr. 2009. 
[19] Q. Zhang and Y.Q. Zhang, “Cross-Layer Design for 
QoS Support in Multihop Wireless Networks,” 
Proceedings of the IEEE, Vol.96, No.1, pp.64-76, 
Jan. 2008. 
[20] B. Zamani, M. Mohammadi, A. Jalalvand, R. 
Fakouri and M. Fathy, “A Cross Model Approach to 
Support of QoS Parameters in Wireless Sensor 
network,” Preceding of the International Conference 
on Computer and Electrical Engineering, pp. 41-45, 
Dec. 2008. 
[21] C. E. Huang and C. Leung, “Adaptive Cross Layer 
Scheduling with Flow Multiplexing,” Preceding of 
the IEEE Wireless Communications and Networking 
Conference, pp. 1871-1876, Apr. 2008. 
[22] Y. Hu, “Cross Layer Dynamic Resource 
Management with Guaranteed QoS in MIMO 
OFDM Systems,” Preceding of the International 
Conference on Wireless Communication, pp. 1-6, 
Oct. 2008. 
[23] C. Tian and D. Y “Cross Layer Opportunistic 
Scheduling for Multiclass Users in Cognitive Radio 
Networks,” Preceding of the International 
Conference on Wireless Communication, pp. 1-4, 
Oct. 2008. 
[24] A. Morell, G. Seco-Granados and M. Á. 
Vázquez-Castro, “Cross-Layer Design of Dynamic 
Bandwidth Allocation in DVB-RCS,” IEEE System 
Journal, Vol. 2, No. 3, pp. 62-73, Mar. 2008. 
[25] D. P Pezaros and L. Mathy, ”Explicit 
 第 20 頁 / 共 86 頁
Conference on Intelligent Systems, Modelling and 
Simulation (ISMS), 2010, pp. 38-42, Feb. 2010. 
import org.apache.xml.serialize.XMLSerializer; 
import org.apache.xml.serialize.OutputFormat; [48] S. Arnon, D. Dov and S. Onn, “An 
Object-Process-Based Modeling Language for 
Multiagent Systems,” IEEE Transactions on Systems, 
Man, and Cybernetics, Part C: Applications and 
Reviews, Vol. 40, No. 2, pp. 227-241, Feb. 2010. 
 
/** 
 * DecisionEngine: [49] S. Liu, S. Wu and J.L. Chen, "Adaptive Cross-layer 
QoS Mechanism for Cognitive Network 
Applications," Proceedings of IEEE 12th 
International Conference on Advanced 
Communication Technology (ICACT), Vol. 2, pp. 
1389-1393, Feb. 2010. 
 *  
 * This class implements the functions to deal with 
resource request at the PCRF 
 * - It loads all listed policies and policy profiles  
附錄 程式碼  *  - defines policy processor blocks for each policy 
type  
1. DecisionEngine.java  * - passes session information (new and modified) to 
each policy processor block (depending on priority)  
package pcrf;  * - Enforces returned policy rules in the transport 
layer  
import java.io.*;  */ 
import java.net.*;  
import java.util.*;  
 public class DecisionEngine  
import de.fhg.fokus.Constants; { 
  DiameterPeer diameterPeer; 
import de.fhg.fokus.diameter.DiameterPeer.data.AVP;  xcap policyEngine = null; 
import 
de.fhg.fokus.diameter.DiameterPeer.data.DiameterMessa
ge; 
 String[] policies  = new String[10]; 
 String policy_db = ""; 
 String username =""; 
import 
de.fhg.fokus.diameter.DiameterPeer.transaction.Transact
ionListener; 
 String password = ""; 
 int remote_xcap_server; 
         
import 
de.fhg.fokus.diameter.DiameterPeer.DiameterPeer; 
 /** Decision Engine constructor intialises 
variables*/ 
  public DecisionEngine(DiameterPeer diameterPeer, 
String policy_db, String[] policies, String username, 
String password, int remote_xcap_server) throws 
IOException 
import javax.xml.parsers.DocumentBuilder; 
import javax.xml.parsers.DocumentBuilderFactory; 
import javax.xml.parsers.ParserConfigurationException; 
  { 
import org.w3c.dom.Document;   this.diameterPeer = diameterPeer; 
import org.w3c.dom.Element;   this.diameterPeer.enableTransactions(10,1); 
import org.w3c.dom.NodeList;   this.policies = policies; 
import org.xml.sax.SAXException;   this.policy_db = policy_db; 
 第 22 頁 / 共 86 頁
  {      Element trigger_point = 
(Element)nl.item(0);    System.out.println("INFO: Session ID: 
" + session_id + " already exists, removing current IP 
Flow rules"); 
     NodeList nl1 = 
trigger_point.getElementsByTagName("media"); 
   //remove IP flows from bearer level      if(nl1 != null && 
nl1.getLength() > 0)    Vector current_ip_flows  = 
policyEngine.getIPFlows(session_id);      { 
   for (int b = 0; b < 
current_ip_flows.size(); b++) 
      Element media = 
(Element)nl1.item(0); 
   {       policy_info = 
policy_info + 
media.getFirstChild().getNodeValue().toString(); 
    int avail_QoS_ul = 0; 
    int avail_QoS_dl = 0; 
    st = new 
StringTokenizer(current_ip_flows.get(b).toString(),";"); 
     } 
    } 
    session_id = st.nextToken();     policy_vector.add(policy_info); 
    session_id = session_id + ";" + 
st.nextToken(); 
   } 
  } 
    session_id =  session_id + ";" + 
st.nextToken(); 
 
  //check if session is new request or already 
existing     String flow_id = st.nextToken(); 
    String source_ip = 
st.nextToken(); 
  //if already existing remove current IP flow 
rules from the bearer level  
    String dest_ip = st.nextToken();   //extract session ID 
    int dest_port = 
Integer.valueOf(st.nextToken()).intValue(); 
  StringTokenizer st = new 
StringTokenizer(af_session,";"); 
    int source_port = 
Integer.valueOf(st.nextToken()).intValue(); 
  /**The session ID has 2 semi-colons in it, so 
3 tokens form the session ID*/ 
    int usage = 
Integer.valueOf(st.nextToken()).intValue(); 
  /**TO DO Define a way to decide how long 
the session id is, perhaps read from the back*/ 
    int status = 
Integer.valueOf(st.nextToken()).intValue(); 
  String session_id = st.nextToken(); 
  session_id = session_id + ";" +  
st.nextToken();     int bw_ul = 
Integer.valueOf(st.nextToken()).intValue();   session_id = session_id + ";" +  
st.nextToken();     int bw_dl = 
Integer.valueOf(st.nextToken()).intValue();   String orig_realm = st.nextToken(); 
    int QoS_class = 
Integer.valueOf(st.nextToken()).intValue(); 
  String dest_realm = st.nextToken(); 
 
  if(policyEngine.sessionExists(session_id) == 
1)  
    int guaranteed_br_ul = bw_ul; 
 //defaults to same as max 
 第 24 頁 / 共 86 頁
        
 return result_code; 
        } 
        else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_TRIGGE
R_EVENT) 
        { 
        
 System.out.println("INFO: Result code TRIGGER 
ERROR EVENT received from PCEF"); 
        
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        
 return result_code; 
        } 
        else 
if(result_code == 
Constants.ResultCode._DIAMETER_PCC_RULE_EVE
NT) 
        { 
        
 System.out.println("INFO: Result code PCC 
RULE EVENT received from PCEF"); 
        
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        
 return result_code; 
        } 
        else 
        { 
        
 System.out.println("INFO: Unknown Result Code 
received from PCEF"); 
        
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        
 return result_code; 
        } 
       } 
      } 
     } 
     System.out.println("INFO: 
IP Flow with flow id: " + flow_id + " is being removed 
from the bearer level"); 
    } 
   } 
    
  } 
  else 
  { 
   result_code = 
Constants.ResultCode._DIAMETER_SUCCESS; 
  
  } 
  if(result_code == 
Constants.ResultCode._DIAMETER_SUCCESS) 
  { 
   
   //invoke policies according to priority 
and trigger points 
   //find highest priority and invoke - then 
remove policy and find next highest priority policy - 
continue until all policies invoked 
   while(policy_vector.size()>0) 
   { 
    int highest_priority = 100; 
    int highest_priority_tag = -1; 
    for (int a = 0; a < 
policy_vector.size(); a++) 
    { 
     st = new 
 第 26 頁 / 共 86 頁
   int bw_ul = 
Integer.valueOf(st.nextToken()).intValue(); 
 
 /** 
   int bw_dl = 
Integer.valueOf(st.nextToken()).intValue(); 
      * This methods check through a session IP 
Flows and enforces those marked ENABLED in the 
bearer level    int guaranteed_br_ul = bw_ul; 
 //defaults to same as max  * @param ip_flows all IP Flows assocaited with 
IMS session    int guaranteed_br_dl = bw_dl;
 //defaults to same as max  * @param orig_realm the realm or domain of the 
orginating user    String PCC_rule_name = session_id + 
";" + flow_id;  * @param dest_realm the realm or domain of the 
destination user    int QoS_class = 
Integer.valueOf(st.nextToken()).intValue();  */  
     public int enforce_IP_Flows(Vector ip_flows, 
String orig_realm, String dest_realm) throws 
IOException  
   System.out.println(session_id + ";" + 
flow_id + ";" + source_ip + ";" + dest_ip + ";" + 
source_port + ";" + dest_port + ";" + usage + ";" + status 
+ ";" + bw_ul + ";" + bw_dl + ";" + QoS_class); 
 { 
  int result_code = -1; 
       
   String pcef_address = "";   int b = 0; 
   /** enable the IP Flow in the bearer 
level*/ 
  for (b = 0; b < ip_flows.size(); b++) 
  { 
   if(status == 
Constants.FlowStatus.ENABLED) 
   StringTokenizer st = new 
StringTokenizer(ip_flows.get(b).toString(),";"); 
   {    String session_id = st.nextToken(); 
    /**Send Diameter RAR install 
message via Gx*/ 
   session_id = session_id + ";" + 
st.nextToken(); 
    DiameterMessage rar = 
createRAR(session_id,dest_realm,PCC_rule_name,sourc
e_ip, dest_ip, 
source_port,dest_port,QoS_class,bw_ul,bw_dl,guarantee
d_br_ul,guaranteed_br_dl,2); //command - 2 for install 
   session_id =  session_id + ";" + 
st.nextToken(); 
   String flow_id = st.nextToken(); 
   String source_ip = st.nextToken(); 
   String dest_ip = st.nextToken(); 
    System.out.println();    int dest_port = 
Integer.valueOf(st.nextToken()).intValue();    
 System.out.println("-------------------------------------
-------------"); 
   int source_port = 
Integer.valueOf(st.nextToken()).intValue(); 
    System.out.println();    int usage = 
Integer.valueOf(st.nextToken()).intValue();     System.out.println("INFO: 
Sending DIAMETER RAR message to PCEF");    int status = 
Integer.valueOf(st.nextToken()).intValue();     pcef_address = 
 第 28 頁 / 共 86 頁
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
       { 
       
 System.out.println("INFO: Unknown Result Code 
received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
      } 
     } 
    } 
    System.out.println("INFO: IP 
Flow with flow id: " + flow_id + " is being enforced in 
the bearer level"); 
   } 
   /** disable the IP Flow in the bearer 
level*/ 
   else if (status == 
Constants.FlowStatus.DISABLED) 
   { 
    /**Send DIAMETER RAR 
remove message via Gx*/ 
    DiameterMessage rar = 
createRAR(session_id,dest_realm,PCC_rule_name,sourc
e_ip,dest_ip, 
source_port,dest_port,QoS_class,bw_ul,bw_dl,guarantee
d_br_ul,guaranteed_br_dl,1); //command - 1 for remove 
    System.out.println(); 
   
 System.out.println("-------------------------------------
-------------"); 
    System.out.println(); 
    System.out.println("INFO: 
Sending DIAMETER RAR message to PCEF"); 
    pcef_address = 
policyEngine.getPCEF(orig_realm,dest_realm); 
    DiameterMessage raa = 
diameterPeer.sendRequestBlocking(pcef_address,rar); 
    if (raa==null)  
    { 
     System.out.println("INFO: 
Time out waiting for PCEF RAA via Gx"); 
     result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
     return result_code; 
    } 
    else  
    { 
      
     if (raa.commandCode == 
Constants.Command.RAA) 
     {  
      System.out.println(); 
     
 System.out.println("INFO: Received DIAMETER 
RAA message from PCEF"); 
      AVP 
result_code_avp = 
raa.findAVP(Constants.AVPCode.RESULT_CODE,true, 
Constants.Vendor.DIAM); 
     
 if(result_code_avp != null) 
      { 
       result_code = 
result_code_avp.int_data; 
       if(result_code 
== Constants.ResultCode._DIAMETER_SUCCESS) 
 第 30 頁 / 共 86 頁
  {    }    
   if(policies[a] != null)   } 
   {   if(result_code == 
Constants.ResultCode._DIAMETER_SUCCESS)     String policy_info = policies[a] + 
";";   { 
    String profile_loc = 
"/opt/OpenIMSCore/uctpcrf/policies/" + "profile_" + 
policies[a] + ".xml"; 
   System.out.println("INFO: IP Flows 
associated with IMS session have been successfully 
processed"); 
    //read policy profile information   } 
    Document doc = null;   return result_code; 
    DocumentBuilderFactory dbf = 
DocumentBuilderFactory.newInstance(); 
 } 
   
    try {  
       /** 
     //Using factory get an 
instance of document builder 
      * this loads the necessary policies and 
invokes policy processor blocks based on priorities and 
trigger points      DocumentBuilder db = 
dbf.newDocumentBuilder();  * and removes the created policy rule 
       * @param af_session session information 
     //parse using builder to get 
DOM representation of the XML file 
      */ 
 public int termination_request(String af_session)  
throws IOException      doc = 
db.parse(profile_loc);  { 
         
     int result_code = -1; 
   
 }catch(ParserConfigurationException pce) { 
 
  StringTokenizer st = new 
StringTokenizer(af_session,";");      pce.printStackTrace(); 
    }catch(SAXException se) {   String session_id = st.nextToken(); 
     se.printStackTrace();   session_id = session_id + ";" + 
st.nextToken();     }catch(IOException ioe) { 
     ioe.printStackTrace();   session_id =  session_id + ";" + 
st.nextToken();     }  
    Element docEle = 
doc.getDocumentElement(); 
  String orig_realm = st.nextToken(); 
  String dest_realm = st.nextToken(); 
      /**Get policy profile information*/ 
    //get all policy information into 
vector format 
  /**policy name; priority; trigger point*/ 
  Vector policy_vector = new Vector(); 
    NodeList nl =   for (int a = 0; a < policies.length; a++) 
 第 32 頁 / 共 86 頁
      catch (Exception err)     { 
      {     /**Send DIAMETER RAR 
remove message via Gx*/       
 err.printStackTrace();     DiameterMessage rar = 
createRAR(session_id,dest_realm,PCC_rule_name,sourc
e_ip,dest_ip,source_port,dest_port,QoS_class,bw_ul,bw_
dl,guaranteed_br_ul,guaranteed_br_dl,1); //command - 1 
remove 
      } 
      counter++; 
     } 
    
    }     System.out.println(); 
    else     
 System.out.println("-------------------------------------
-------------"); 
    { 
     System.out.println(); 
     System.out.println("INFO: 
Received DIAMETER RAA message from PCEF"); 
    System.out.println(); 
    System.out.println("INFO: 
Sending DIAMETER RAR message to PCEF");      if (raa.commandCode == 
Constants.Command.RAA)     pcef_address = 
policyEngine.getPCEF(orig_realm,dest_realm);      {  
      AVP 
result_code_avp = 
raa.findAVP(Constants.AVPCode.RESULT_CODE,true, 
Constants.Vendor.DIAM); 
    DiameterMessage raa = 
diameterPeer.sendRequestBlocking(pcef_address,rar); 
    int counter = 0; 
    if (raa==null)  
     
 if(result_code_avp != null) 
    { 
     if(counter == 3) 
      {      { 
       result_code = 
result_code_avp.int_data; 
     
 System.out.println("INFO: Time out waiting for 
PCEF RAA via Gx");        if(result_code 
== Constants.ResultCode._DIAMETER_SUCCESS)       result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
       { 
       
 System.out.println("INFO: AAR Result code 
SUCCESS received from PCEF"); 
      return result_code; 
     } 
       }      else 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_INITIAL
_PARAMETERS) 
     { 
      try 
      { 
      
 Thread.sleep(100);        { 
             } 
 第 34 頁 / 共 86 頁
StringTokenizer(policy_vector.get(a).toString(),";"); 
     st.nextToken(); 
     int priority = 
Integer.valueOf(st.nextToken()).intValue(); 
     if(priority < 
highest_priority) 
     { 
      highest_priority = 
priority; 
      highest_priority_tag 
= a; 
     } 
     
    } 
    //policy with highest priority is 
policy_vector(a) 
    //create policy processor block 
for this policy 
    //pass info to this processor block 
and result code in return 
    //if result success enforce IP 
Flows 
    //then remove policy from policy 
vector 
    st = new 
StringTokenizer(policy_vector.get(highest_priority_tag).
toString(),";"); 
    String policy = st.nextToken(); 
    st.nextToken(); 
    String trigger_point = 
st.nextToken(); 
   
 if(policy.equals("domain_policies"))  
    { 
    
 if(trigger_point.equals("ANY")) 
     { 
     
 DomainPolicyProcessor dpp = new 
DomainPolicyProcessor(diameterPeer, policy_db, policy, 
username, password, remote_xcap_server); 
      result_code = 
dpp.termination_request(af_session); 
      
     } 
    } 
    
   
 policy_vector.removeElementAt(highest_priority_t
ag); 
 
    /**TO DO Add support to create 
dynamic Policy Processor Blocks*/ 
    //ADD new policy processor 
blocks here - remember to check the trigger points for 
each IP Flow which determine whether that policy 
should be called 
 
   } 
   System.out.println("INFO: IMS with 
session_id: " + session_id + " has been removed as well 
as all associated IP Flows"); 
  } 
  return result_code; 
 }  
  
 /** 
      * This creates a DIAMETER RAR message 
 * @param input 
      */ 
 private DiameterMessage createRAR (String 
session_id,String destination_realm,String 
PCC_rule_name,String source_ip,String dest_ip,int 
source_port,int dest_port,int qos_class_identifier,int 
max_bw_ul,int max_bw_dl,int guaranteed_br_ul,int 
guaranteed_br_dl, int command) 
 { 
  DiameterMessage rar = 
 第 36 頁 / 共 86 頁
   /*Charging rule name*/  rar.addAVP(charging_rule_remove_avp); 
   AVP charging_rule_name_avp = new 
AVP(Constants.AVPCode.CHARGING_RULE_NAME,
true,Constants.Vendor.V3GPP); 
  } 
  else if (command == 2) 
  { 
  
 charging_rule_name_avp.setData(PCC_rule_name
); 
   /**add PCC Rule install*/ 
   AVP charging_rule_install_avp = new 
AVP(Constants.AVPCode.CHARGING_RULE_INSTA
LL,true,Constants.Vendor.V3GPP);   
 charging_rule_install_avp.addChildAVP(charging
_rule_name_avp); 
   /*Charging rule definition*/ 
   AVP charging_rule_definition_avp = 
new 
AVP(Constants.AVPCode.CHARGING_RULE_DEFIN
ITION,true,Constants.Vendor.V3GPP); 
  
 rar.addAVP(charging_rule_install_avp); 
    
  }     /*Flow description1*/ 
  else     AVP flow_description_avp = 
new 
AVP(Constants.AVPCode.FLOW_DESCRIPTION,true,
Constants.Vendor.V3GPP); 
  {  
   System.out.println("Unknown 
command in Create RAR Message"); 
   return null;     String flow = "permit out ip from 
" + source_ip + " to " + dest_ip + " " + source_port;   } 
        
 flow_description_avp.setData(flow);   /**add Authorised QoS*/ 
  AVP authorised_qos_avp = new 
AVP(Constants.AVPCode.AUTHORISED_QOS,true,Co
nstants.Vendor.V3GPP); 
   
 charging_rule_definition_avp.addChildAVP(flow_
description_avp); 
  /*QoS Class identifier*/     /*Flow description2*/ 
  AVP qos_class_identifier_avp = new 
AVP(Constants.AVPCode.QOS_CLASS_IDENTIFIER,t
rue,Constants.Vendor.V3GPP); 
    flow_description_avp = new 
AVP(Constants.AVPCode.FLOW_DESCRIPTION,true,
Constants.Vendor.V3GPP); 
 
 qos_class_identifier_avp.setData(qos_class_identif
ier); 
    flow = "permit in ip from " + 
dest_ip + " to " + source_ip + " " + dest_port; 
   
 flow_description_avp.setData(flow);  
 authorised_qos_avp.addChildAVP(qos_class_ident
ifier_avp); 
   
 charging_rule_definition_avp.addChildAVP(flow_
description_avp);   /*Max requested bandwidth uplink*/ 
  AVP max_requested_bandwidth_ul_avp = 
new 
AVP(Constants.AVPCode.MAX_REQUESTED_BAND
  
 charging_rule_install_avp.addChildAVP(charging
_rule_definition_avp); 
 第 38 頁 / 共 86 頁
  {   
   System.out.println("INFO: Codecs 
authorised"); 
         
 /** Decision Engine constructor intialises 
variables*/   } 
  else  public DomainPolicyProcessor(DiameterPeer 
diameterPeer, String policy_db, String policy, String 
username, String password, int remote_xcap_server) 
throws IOException 
  { 
   System.out.println("\nINFO: " + new 
java.util.Date().toString() + " Session with ID : " + 
session_id + " attempted to use unauthorised codec");  { 
   result_code = 
Constants.ResultCode._REQUESTED_SERVICE_NOT
_AUTHORISED; 
  this.diameterPeer = diameterPeer; 
  this.diameterPeer.enableTransactions(10,1); 
  this.policyEngine = new xcap(policy_db, 
policy, username, password, remote_xcap_server);    return result_code; 
  }  } 
  
  /**Check that originating and destination 
realms are authorised domains*/ 
 public int authorisation_request(String af_session, 
Vector ip_flows, Vector codecs) throws IOException  
  if(policyEngine.checkDomain(orig_realm, 
dest_realm) == 1) 
 { 
  int result_code = -1; 
  {   //extract session ID 
   System.out.println("INFO: Originating 
and Destination Domains authorised "); 
  StringTokenizer st = new 
StringTokenizer(af_session,";"); 
  }   /**The session ID has 2 semi-colons in it, so 
3 tokens form the session ID*/   else 
  {   /**TO DO Define a way to decide how long 
the session id is, perhaps read from the back*/    System.out.println("\nINFO: " + new 
java.util.Date().toString() + " Session with ID : " + 
session_id + " attempted to use unauthorised domain"); 
  String session_id = st.nextToken(); 
  session_id = session_id + ";" +  
st.nextToken();    result_code = 
Constants.ResultCode._REQUESTED_SERVICE_NOT
_AUTHORISED; 
  session_id = session_id + ";" +  
st.nextToken(); 
   return result_code;   String orig_realm = st.nextToken(); 
  }   String dest_realm = st.nextToken(); 
     String source_ip = ""; 
  /**Check if session is new or if session 
already exists and is to be modified*/ 
  String dest_ip = ""; 
   
     
  if(policyEngine.sessionExists(session_id) == 
1) 
  /**Check that codecs are supported*/ 
  if(policyEngine.checkCodecs(codecs) == 1) 
 第 40 頁 / 共 86 頁
   return result_code;    total_req_bw_dl = total_req_bw_dl + 
req_bw_dl;       } 
  System.out.println("INFO: Originating and 
Destination Domains can handle the required 
bandwidth"); 
 
 
  
 if(policyEngine.checkQoSBW(QoS_class, 
req_bw_ul, req_bw_dl) == 0) 
 
 
  /**Manipulates the data repository to 
indicate the added IMS session and associated IP flows*/
  
   { 
    System.out.println("\nINFO: " + 
new java.util.Date().toString() + " Session with ID : " + 
session_id + " attempted to request more bandwidth than 
the requested QoS class can handle."); 
   
  policyEngine.insertSession(af_session, 
codecs);     result_code = 
Constants.ResultCode._REQUESTED_SERVICE_NOT
_AUTHORISED; 
  System.out.println("INFO: IMS Session 
information for session " + session_id + " added to 
Policy Repository");     return result_code; 
      } 
     
  /**add IP Flow parameters to IP_Flows 
tables*/ 
  } 
  System.out.println("INFO: Requested QoS 
class can handle the session bandwidth");   policyEngine.insertIPFlow(ip_flows); 
  System.out.println("INFO: IP Flow 
information for session " + session_id + " information 
added to Policy Repository"); 
 
  /**Check that the originating and destination 
realms can handle the bandwidth requirements for each 
IP Flow*/  
  /**edit QoS_classes remaining UL and DL 
bandwidth*/ 
 
 
 if(policyEngine.checkDomainBW(orig_realm, 
total_req_bw_ul, total_req_bw_dl) == 0 || 
policyEngine.checkDomainBW(dest_realm, 
total_req_bw_ul, total_req_bw_dl) == 0) 
  for ( int b = 0; b < ip_flows.size(); b++) 
  {    
   st = new 
StringTokenizer(ip_flows.get(b).toString(),";"); 
   int req_bw_ul = 0;   { 
   int req_bw_dl = 0;    System.out.println("\nINFO: " + new 
java.util.Date().toString() + " Session with ID: " + 
session_id + " attempted to request more bandwidth than 
the domains can handle."); 
   int QoS_class = -1; 
   int i = 0; 
   String temp = ""; 
   for (i = 0 ;i < 10;i++)    result_code = 
Constants.ResultCode._REQUESTED_SERVICE_NOT
_AUTHORISED;; 
   { 
    temp = st.nextToken(); 
 第 42 頁 / 共 86 頁
  }    st = new 
StringTokenizer(ip_flows.get(a).toString(),";");   System.out.println("INFO: Requested QoS 
class can handle the session bandwidth");       int req_bw_ul = 0; 
    int req_bw_dl = 0; 
    int QoS_class = -1; 
  /**Check that the originating and destination 
realms can handle the bandwidth requirements for each 
IP Flow*/ 
    
   int i = 0; 
   String temp = ""; 
    for (i = 0 ;i < 10 ;i++) 
 
 if(policyEngine.checkDomainBW(orig_realm, 
total_req_bw_ul, total_req_bw_dl) == 0 || 
policyEngine.checkDomainBW(dest_realm, 
total_req_bw_ul, total_req_bw_dl) == 0) 
   { 
    temp = st.nextToken(); 
   } 
   req_bw_ul = 
Integer.valueOf(st.nextToken()).intValue(); 
  {    req_bw_dl = 
Integer.valueOf(st.nextToken()).intValue();    System.out.println("\nINFO: " + new 
java.util.Date().toString() + " Session with ID: " + 
session_id + " attempted to request more bandwidth than 
the domains can handle."); 
   QoS_class = 
Integer.valueOf(st.nextToken()).intValue(); 
 
   result_code = 
Constants.ResultCode._REQUESTED_SERVICE_NOT
_AUTHORISED;; 
   total_req_bw_ul = total_req_bw_ul + 
req_bw_ul; 
   total_req_bw_dl = total_req_bw_dl + 
req_bw_dl;        return result_code; 
  }  
  System.out.println("INFO: Originating and 
Destination Domains can handle the required 
bandwidth"); 
 
  
 if(policyEngine.checkQoSBW(QoS_class, 
req_bw_ul, req_bw_dl) == 0)    
  /**Remove previous session*/    { 
  termination_request(af_session);     System.out.println("\nINFO: " + 
new java.util.Date().toString() + " Session with ID : " + 
session_id + " attempted to request more bandwidth than 
the requested QoS class can handle."); 
    
  /**Manipulates the data repository to 
indicate the added IMS session and associated IP flows*/
      result_code = 
Constants.ResultCode._REQUESTED_SERVICE_NOT
_AUTHORISED; 
 
  policyEngine.insertSession(af_session, 
codecs);     return result_code; 
  System.out.println("INFO: IMS Session 
information for session " + session_id + " added to 
   } 
    
 第 44 頁 / 共 86 頁
   String source_ip = st.nextToken(); st.nextToken(); 
   String dest_ip = st.nextToken();   String orig_realm = st.nextToken(); 
   int dest_port = 
Integer.valueOf(st.nextToken()).intValue(); 
  String dest_realm = st.nextToken(); 
   
   int source_port = 
Integer.valueOf(st.nextToken()).intValue(); 
  int total_bw_ul = 0; 
  int total_bw_dl = 0; 
   int usage = 
Integer.valueOf(st.nextToken()).intValue(); 
   
  /**Check that session exists*/ 
  if(policyEngine.sessionExists(session_id) == 
0) 
   int status = 
Integer.valueOf(st.nextToken()).intValue(); 
   int bw_ul = 
Integer.valueOf(st.nextToken()).intValue(); 
  { 
   System.out.println("INFO: " + new 
java.util.Date().toString() + " Attempted to delete 
non-existent Session with session ID : " + session_id); 
     
   int bw_dl = 
Integer.valueOf(st.nextToken()).intValue(); 
   int QoS_class = 
Integer.valueOf(st.nextToken()).intValue();    result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION;     
   int guaranteed_br_ul = bw_ul; 
 //defaults to same as max 
   int guaranteed_br_dl = bw_dl;
 //defaults to same as max 
   return result_code; 
  } 
   String PCC_rule_name = session_id + 
";" + flow_id; 
 
  /**Return bandwidth to individual QoS 
classes and calculate total bandwidth to be freed in each 
domain*/ 
   total_bw_ul = total_bw_ul + bw_ul; 
   total_bw_dl = total_bw_dl + bw_dl; 
  
 policyEngine.freeQoSBandwidth(QoS_class,bw_ul
,bw_dl); 
  Vector current_ip_flows = 
policyEngine.getIPFlows(session_id); 
  for (int b = 0; b < current_ip_flows.size(); 
b++)   }  
     { 
    int avail_QoS_ul = 0; 
  /**return total free-ed bandwidth to orig and 
dest domains*/ 
   int avail_QoS_dl = 0; 
   st = new 
StringTokenizer(current_ip_flows.get(b).toString(),";");   /**return bandwidth to all domains*/ 
  int avail_orig_realm_bw_ul = 0;    session_id = st.nextToken(); 
  int avail_orig_realm_bw_dl = 0;  
  
   session_id = session_id + ";" + 
st.nextToken(); 
  int avail_dest_realm_bw_ul = 0;    session_id =  session_id + ";" + 
st.nextToken();   int avail_dest_realm_bw_dl = 0;  
     String flow_id = st.nextToken(); 
 第 46 頁 / 共 86 頁
 */ IOException  
 public void run() throws IOException  { 
 {   getPreferences(); 
  //turns current PCEF ON   String pcefID = "1"; 
  System.out.println("INFO: Changing Status 
of PCEF #" + pcefID + " to 'On'"); 
     
  //FOR TESTING PURPOSES ASSUME 
PCEF ID 1   policyEngine.statusPCEF(pcefID, "on"); 
  System.out.println("INFO: This is PCEF 
number: " +pcefID); 
  //System.out.print("Enter PCEF Name : "); 
  //pcefID = in.readLine(); 
  System.out.println("DEBUG: PCRF Address: 
" + pcrfAddress); 
 
  PCEF pcef = new PCEF(pcefID); 
      pcef.run(); 
  // Starting pcef Diameter Stack  } 
  try  
  {  /** 
   diameterStack = new 
pcefDiameterStack(linux_router, diameterPeer, 
remote_xcap_server); 
 * Constructor for PCEF 
 *  -initialises variables 
 * @param args 
   diameterStack.startup();  */ 
  }  
  catch (Exception e)  public PCEF(String pcefID) throws IOException 
  {  { 
   System.out.println("ERROR: " + e);   this.pcefID = pcefID; 
   e.printStackTrace();   diameterPeer = new 
DiameterPeer("config/DiameterPeerPCEF.xml");   } 
  System.out.println("INFO: PCEF Gx 
Diameter interface started");  
  policyEngine = new xcap (policy_db, 
"domain_policies", username, password, 
remote_xcap_server);  
  waitForExit();   pcrfAddress = 
policyEngine.getPCRF(pcefID);    
  policyEngine.statusPCEF(pcefID, "Off");   linux_router = new 
LinuxRouter(diffserv_interface, pcrfAddress, 
policyEngine, diameterPeer);//initialises machine as a 
linux router 
  diameterStack.shutdown(); 
  String flush_iptables = 
"/opt/OpenIMSCore/uctpcrf/scripts/flush_iptables"; 
   try    this.linux_router=linux_router; 
   {   } 
   
 Runtime.getRuntime().exec(flush_iptables); 
  
 /** 
   }   * This connects to PCRF 
 第 48 頁 / 共 86 頁
  * This method waits until exit is typed in the 
console 
StringTokenizer(password_line, "="); 
   st1.nextToken(); 
  * If wait is typed, then it returns.    st2 = new 
StringTokenizer(st1.nextToken(), "\"");   */ 
 private static void waitForExit() {    password = st2.nextToken(); 
  byte[] buffer = new byte[80];    
  int read;    String remote_xcap_server_line = 
st.nextToken();   String input=""; 
  while (true){    st1 = new 
StringTokenizer(remote_xcap_server_line, "=");       try{ 
          System.out.println("\nType \"exit\" 
to stop PCEF!");           
   st1.nextToken(); 
   remote_xcap_server = 
Integer.valueOf(st1.nextToken()).intValue();           read = System.in.read(buffer, 0, 
80);             
          input = new String(buffer, 0, read);    String diffserv_interface_line = 
st.nextToken();           input  = input.trim(); 
      }    st1 = new 
StringTokenizer(diffserv_interface_line, "=");       catch (IOException e){ 
          e.printStackTrace();    st1.nextToken(); 
      }    st2 = new 
StringTokenizer(st1.nextToken(), "\"");        
      if(input.equalsIgnoreCase("exit") || 
input.equalsIgnoreCase("x")){ 
   diffserv_interface = st2.nextToken(); 
 
       return;    String data_counter_line = 
st.nextToken();       } 
  }    st1 = new 
StringTokenizer(data_counter_line, "=");  } 
}    st1.nextToken(); 
    data_counter = 
Integer.valueOf(st1.nextToken()).intValue();  
4. PCRF.java   } 
  catch(FileNotFoundException e)  
  { package pcrf; 
   System.out.println("Preferences file 
not found"); 
 
import java.net.*; 
  } import java.io.*; 
 } import java.rmi.*; 
 import java.util.*; 
 /**  
 第 50 頁 / 共 86 頁
    /** 
  // Starting pcrf Diameter Stack  * This defines the behavour of the PCRF 
  try  *  -It starts the PCRF  
  {  * -Starts the diameter stack and connects to the 
P-CSCF    diameterStack = new 
pcrfDiameterStack(diameterPeer,currentDomain,policy_
db, policies,username,password, remote_xcap_server, 
policyEngine); 
 * -Starts the dimater stack and connects to all 
listed PCEFs 
 */ 
   diameterStack.startup();  public void run() throws IOException 
  }  { 
  catch (Exception e)  
  {   String currentDomain=""; 
              System.out.println("ERROR: " + 
e); 
 
  String pcrfID= "1"; //defaults to 1 
              e.printStackTrace();    
         }   //FOR TESTING PURPOSES Assume 
PCRFid 1   System.out.println("INFO: PCRF Rx 
Diameter interface started");    //choose PCRF from those listed in database 
if more than 1   System.out.println("INFO: PCRF Gx 
Diameter interface started");    //BufferedReader in = new 
BufferedReader(new InputStreamReader(System.in));    
  waitForExit();   //System.out.println(); 
  policyEngine.statusPCRF(pcrfID, "Off");   //System.out.print("Enter PCRF Number : "); 
  diameterStack.shutdown();   //pcrfID = Integer.parseInt(in.readLine()); 
  System.exit(0);    
 }   //turns current PCRF ON 
      System.out.println("INFO: Changing Status 
of PCRF #" + pcrfID + " to 'On'");  /**This retreives the preferences from 
pcrf.properties**/       policyEngine.statusPCRF(pcrfID, "on"); 
 private static void getPreferences() throws 
IOException 
  currentDomain = 
policyEngine.getPCRFDomain(pcrfID); 
 {    
  StringBuffer fileData = new 
StringBuffer(1000); 
  //FOR TESTING PURPOSES 
  System.out.println("INFO: This is PCRF 
number: " +pcrfID);           
     System.out.println("INFO: Controlling 
Domain: " + currentDomain);   try 
  {   System.out.println("INFO: PCRF Server #" 
+ pcrfID + " started : " + new java.util.Date().toString());    BufferedReader reader = new 
 第 52 頁 / 共 86 頁
  } 
import java.io.*;  
import java.net.*;  /** 
import java.util.*;   * This method waits until exit is typed in the 
console  
import org.apache.commons.httpclient.HttpClient;   * If wait is typed, then it returns. 
import 
org.apache.commons.httpclient.UsernamePasswordCred
entials; 
  */ 
 private static void waitForExit() { 
  byte[] buffer = new byte[80];  
import org.apache.commons.httpclient.auth.AuthScope;   int read; 
import 
org.apache.commons.httpclient.methods.GetMethod; 
  String input=""; 
  while (true){ 
import 
org.apache.commons.httpclient.methods.PutMethod; 
      try{ 
          System.out.println("\nType \"exit\" 
to stop PCRF!");           import 
org.apache.commons.httpclient.methods.StringRequestE
ntity; 
          read = System.in.read(buffer, 0, 
80);            
           input = new String(buffer, 0, read); 
import javax.xml.parsers.DocumentBuilder;           input  = input.trim(); 
import javax.xml.parsers.DocumentBuilderFactory;       } 
import javax.xml.parsers.ParserConfigurationException;       catch (IOException e){ 
           e.printStackTrace(); 
import org.w3c.dom.Document;       } 
import org.w3c.dom.Element;        
import org.w3c.dom.NodeList;       if(input.equalsIgnoreCase("exit") || 
input.equalsIgnoreCase("x")){ import org.xml.sax.SAXException; 
import org.apache.xml.serialize.XMLSerializer;        return; 
import org.apache.xml.serialize.OutputFormat;       } 
   } 
  } 
 } 
 /** 
  * xcap: 
  *  
  * This class defines the XCAP methods for retrieving 
and modifying policies stored on an XDMS server  
5. xcap.java  * It also defines methods for parsing and reading the 
XML document  
 * @author Richard Good package pcrf; 
 第 54 頁 / 共 86 頁
   se.printStackTrace();    // Serialize XML Document  
    }catch(IOException ioe) { 
   ioe.printStackTrace();    probeMsgSerializer.serialize(dom); 
  }    xmlStr = strWriter.toString(); 
 }    strWriter.close(); 
    
   } 
 /**   catch (IOException ioEx) 
      * This receives a list of codecs - checks the 
domain policies and returns whether they are acceptable 
or not 
  { 
   System.out.println("Error " + ioEx);
  
 * @param codecs vector of requested requested 
codecs 
  } 
  return xmlStr;  
 * @return 1 if authorised 0 if not    } 
 */   
 public int checkCodecs(Vector codecs) throws 
IOException 
 /** 
 * This creates the XML parser 
 {  **/ 
  //fetch and parse the policy XML document  private void parseXML(InputStream xmlDoc) 
  parseXML(getXML());  { 
  //get the root elememt    
  Element docEle = 
dom.getDocumentElement(); 
  //get the factory 
  DocumentBuilderFactory dbf = 
DocumentBuilderFactory.newInstance();    
  //get all authorised codec id's in a vector   try { 
  Vector authCodecs = new Vector();     
    //Using factory get an instance of 
document builder   NodeList nl = 
docEle.getElementsByTagName("rule");    DocumentBuilder db = 
dbf.newDocumentBuilder();   if(nl != null && nl.getLength() > 0) { 
   for(int i = 0 ; i < nl.getLength();i++) {     
        //parse using builder to get DOM 
representation of the XML file     //get the authorised codec rule 
    Element rule = 
(Element)nl.item(i); 
   dom = db.parse(xmlDoc); 
    
    String id = 
rule.getAttribute("id"); 
 
  }catch(ParserConfigurationException pce) { 
    if(id.equals("codec 
authorisation")) 
   pce.printStackTrace(); 
  }catch(SAXException se) { 
 第 56 頁 / 共 86 頁
       Element 
domain = (Element)nl1.item(0); 
 public int checkDomain(String orig, String term) 
throws IOException 
       NodeList nl2 = 
domain.getElementsByTagName("address");  
 { 
  //fetch and parse the policy XML document 
       if(nl2 != null 
&& nl2.getLength() > 0)  
  parseXML(getXML()); 
  //get the root elememt 
       {   Element docEle = 
dom.getDocumentElement();         for(int a 
= 0 ; a < nl2.getLength();a++)  
        {   int orig_authorised = 0; 
        
 Element address = (Element)nl2.item(a); 
  int term_authorised = 0; 
   
        
 domains.add(address.getFirstChild().getNodeValu
e()); 
  Vector domains = new Vector();  
   
  NodeList nl = 
docEle.getElementsByTagName("rule");         }  
       }   if(nl != null && nl.getLength() > 0) { 
      }    for(int i = 0 ; i < nl.getLength();i++) { 
     }      
    }     //get the authorised codec rule 
   }     Element rule = 
(Element)nl.item(i);   } 
     String id = 
rule.getAttribute("id");   //check that both orig and term domains are 
authorised     if(id.equals("domain 
authorisation"))   for (int b = 0; b < domains.size(); b++) 
  {     { 
  
 if(domains.get(b).toString().equals(orig)) 
     NodeList nl3 = 
rule.getElementsByTagName("conditions"); 
   {      if(nl3 != null && 
nl3.getLength() > 0)     orig_authorised = 1; 
   }      {  
      Element conditions = 
(Element)nl3.item(0); 
  
 if(domains.get(b).toString().equals(term)) 
   {       NodeList nl1 = 
conditions.getElementsByTagName("domain");     term_authorised = 1; 
   }       if(nl1 != null && 
nl1.getLength() > 0)   } 
         {  
 第 58 頁 / 共 86 頁
        for(int a 
= 0 ; a < nl2.getLength();a++) 
  int authbw_ul = 0; 
  int authbw_dl = 0; 
        {   parseXML(getXML()); 
        
 Element class_id = (Element)nl2.item(a); 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement();         
 if(QoS_class == 
(Integer.valueOf(class_id.getFirstChild().getNodeValue(
))).intValue()) 
   
  NodeList nl = 
docEle.getElementsByTagName("rule"); 
         {   if(nl != null && nl.getLength() > 0) { 
         
 if(bw_dl < 
(Integer.valueOf(class_id.getAttribute("bw_downlink")))
.intValue()) 
   for(int i = 0 ; i < nl.getLength();i++) { 
     
    //get the authorised codec rule 
    Element rule = 
(Element)nl.item(i);          
 {     String id = 
rule.getAttribute("id");          
  authbw_dl = 1;     if(id.equals("qos class 
authorisation"))          
 }     { 
         
 if(bw_ul < 
(Integer.valueOf(class_id.getAttribute("bw_uplink"))).int
Value()) 
     NodeList nl3 = 
rule.getElementsByTagName("conditions"); 
     if(nl3 != null && 
nl3.getLength() > 0) 
     {  
      Element conditions = 
(Element)nl3.item(0); 
         
 { 
         
  authbw_ul = 1;       NodeList nl1 = 
conditions.getElementsByTagName("qos_class");          
 }       if(nl1 != null && 
nl1.getLength() > 0)          } 
           {  
        }         Element 
qos_class = (Element)nl1.item(0);        } 
       NodeList nl2 = 
qos_class.getElementsByTagName("class_id");  
      } 
     } 
    }        if(nl2 != null 
&& nl2.getLength() > 0)     } 
  }        { 
 第 60 頁 / 共 86 頁
 * @param Vector codecs A list of the requested 
codecs 
 { 
         
  authbw_dl = 1;  */ 
 public void insertSession(String ims_session, 
Vector codecs) throws IOException 
         
 } 
 {          
 if(bw_ul < 
(Integer.valueOf(address.getAttribute("bw_uplink"))).int
Value()) 
  parseXML(getXML()); 
   
  StringTokenizer st = new 
StringTokenizer(ims_session,";");          
 {   /**The session ID has 2 semi-colons in it, so 
3 tokens form the session ID*/          
  authbw_ul = 1;   /**TO DO Define a way to decide how long 
the session id is, perhaps read from the back*/          
 }   String session_id = st.nextToken(); 
  session_id = session_id + ";" +  
st.nextToken(); 
         } 
     
  session_id = session_id + ";" +  
st.nextToken(); 
        }  
       } 
  String orig_domain = st.nextToken();       } 
  String term_domain = st.nextToken();      } 
     } 
  String codec_list = "";    } 
  for (int a =0; a < codecs.size(); a++)   } 
  {   if(authbw_ul == 0 || authbw_ul == 0) 
   codec_list = codec_list + codecs.get(a) 
+ ";"; 
  { 
   return 0; 
  }   } 
     else 
  //get the root elememt   { 
  Element docEle = 
dom.getDocumentElement(); 
   return 1; 
  } 
  //get a nodelist of <IMS session> elements  } 
  NodeList nl = 
docEle.getElementsByTagName("tris"); 
 
 /** 
  if(nl != null && nl.getLength() > 0)        * This inserts a session into the Policy 
repository   { 
   Element tris = (Element)nl.item(0);  * @param String ims_session The session 
information    NodeList nl1 = 
 第 62 頁 / 共 86 頁
    Element Codecs = 
dom.createElement("codecs"); 
dom.createElement("codecs"); 
     
 Codecs.appendChild(dom.createTextNode(codec_l
ist)); 
   
 Codecs.appendChild(dom.createTextNode(codec_l
ist));      
 AF_Session1.appendChild(Codecs);    
 AF_Session1.appendChild(Codecs);      
 tris.appendChild(AF_Session1);     tris.appendChild(AF_Session1); 
    //docEle.appendChild(tris);      
 //docEle.appendChild(tris);    } 
  }       } 
  putXML(XMLDocToString(dom));       
 }     } 
    } 
 /**    else 
      * This inserts an ip flow into the Policy 
repository 
   { 
    Element AF_Session1 = 
dom.createElement("af_session");  * @param ip_flows A vector of all the IP Flow 
information     Element Session_ID1 = 
dom.createElement("session_id");  */ 
 public void insertIPFlow(Vector ip_flows) throws 
IOException 
   
 Session_ID1.appendChild(dom.createTextNode(se
ssion_id));  { 
  parseXML(getXML());    
 AF_Session1.appendChild(Session_ID1);   for (int b = 0; b < ip_flows.size(); b++) 
  {     Element Orig_Domain = 
dom.createElement("orig_domain");    StringTokenizer st = new 
StringTokenizer(ip_flows.get(b).toString(),";");    
 Orig_Domain.appendChild(dom.createTextNode(o
rig_domain)); 
   String session_id = st.nextToken(); 
   session_id =  session_id + ";" + 
st.nextToken();    
 AF_Session1.appendChild(Orig_Domain);    session_id =  session_id + ";" + 
st.nextToken();     Element Term_Domain = 
dom.createElement("term_domain");    String flow_id = st.nextToken(); 
   String source_ip = st.nextToken();    
 Term_Domain.appendChild(dom.createTextNode(t
erm_domain)); 
   String dest_ip = st.nextToken(); 
   String dest_port = st.nextToken(); 
   String source_port = st.nextToken();    
 AF_Session1.appendChild(Term_Domain);    String usage = st.nextToken(); 
 第 64 頁 / 共 86 頁
       { urce_port)); 
        Element 
BW_Uplink = (Element)nl1.item(0); 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("dest_port");        
 BW_Uplink.appendChild(dom.createTextNode(bw
_ul)); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       }        { 
       nl1 = 
IP_Flow.getElementsByTagName("bw_downlink"); 
        Element 
Dest_Port = (Element)nl1.item(0); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       
 Dest_Port.appendChild(dom.createTextNode(dest_
port));        { 
        Element 
BW_Downlink = (Element)nl1.item(0); 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("flow_usage");        
 BW_Downlink.appendChild(dom.createTextNode(
bw_dl)); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       }        { 
       nl1 = 
IP_Flow.getElementsByTagName("qos_class"); 
        Element 
Flow_Usage = (Element)nl1.item(0); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       
 Flow_Usage.appendChild(dom.createTextNode(us
age));        { 
        Element 
QoS_Class = (Element)nl1.item(0); 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("flow_status");        
 QoS_Class.appendChild(dom.createTextNode(Qo
S_class)); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       }        { 
      }         Element 
Flow_Status = (Element)nl1.item(0);       else 
      {        
 Flow_Status.appendChild(dom.createTextNode(sta
tus)); 
       Element 
IP_Flow1 = dom.createElement("ip_flow"); 
       Element 
Session_ID1 = dom.createElement("session_id"); 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("bw_uplink");       
 Session_ID1.appendChild(dom.createTextNode(se
ssion_id)); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
 第 66 頁 / 共 86 頁
    
 IP_Flow1.appendChild(Source_Port); 
      
    } 
     Element Dest_Port = 
dom.createElement("dest_port"); 
    else 
    { 
    
 Dest_Port.appendChild(dom.createTextNode(dest_
port)); 
     Element IP_Flow1 = 
dom.createElement("ip_flow"); 
     Element Session_ID1 = 
dom.createElement("session_id");     
 IP_Flow1.appendChild(Dest_Port);     
 Session_ID1.appendChild(dom.createTextNode(se
ssion_id)); 
     Element Flow_Usage = 
dom.createElement("flow_usage"); 
    
 Flow_Usage.appendChild(dom.createTextNode(us
age)); 
    
 IP_Flow1.appendChild(Session_ID1); 
     Element Flow_ID = 
dom.createElement("flow_id");     
 IP_Flow1.appendChild(Flow_Usage);     
 Flow_ID.appendChild(dom.createTextNode(flow_
id)); 
     Element Flow_Status = 
dom.createElement("flow_status"); 
    
 Flow_Status.appendChild(dom.createTextNode(sta
tus)); 
    
 IP_Flow1.appendChild(Flow_ID); 
     Element Source_IP = 
dom.createElement("source_ip");     
 IP_Flow1.appendChild(Flow_Status);     
 Source_IP.appendChild(dom.createTextNode(sour
ce_ip)); 
     Element BW_Uplink = 
dom.createElement("bw_uplink"); 
    
 BW_Uplink.appendChild(dom.createTextNode(bw
_ul)); 
    
 IP_Flow1.appendChild(Source_IP); 
     Element Dest_IP = 
dom.createElement("dest_ip");     
 IP_Flow1.appendChild(BW_Uplink);     
 Dest_IP.appendChild(dom.createTextNode(dest_ip
)); 
     Element BW_Downlink = 
dom.createElement("bw_downlink"); 
    
 BW_Downlink.appendChild(dom.createTextNode(
bw_dl)); 
    
 IP_Flow1.appendChild(Dest_IP); 
     Element Source_Port = 
dom.createElement("source_port");     
 IP_Flow1.appendChild(BW_Downlink);     
 Source_Port.appendChild(dom.createTextNode(so
urce_port)); 
     Element QoS_Class = 
dom.createElement("qos_class"); 
 第 68 頁 / 共 86 頁
      
 tris.removeChild(IP_Flow); 
 */ 
 public void deleteIPFlow(String session_id) throws 
IOException        i = 0; 
      }  { 
     }    
     nl = 
tris.getElementsByTagName("ip_flow"); 
  parseXML(getXML()); 
   
    }   //get the root elememt 
   }   Element docEle = 
dom.getDocumentElement();   } 
     NodeList nl0 = 
docEle.getElementsByTagName("tris");   putXML(XMLDocToString(dom)); 
 }    if(nl0 != null && nl0.getLength() > 0)  
   { 
 /**    Element tris = (Element)nl0.item(0); 
      * This returns the specified uplink and 
downlink bandwidth to the specified QoS class 
   NodeList nl = 
tris.getElementsByTagName("ip_flow"); 
 * @param QoS_class the QoS class to return the 
bandwidth to 
   if(nl != null && nl.getLength() > 0)  
   { 
 * @param bw_ul the uplink bandwidth to free     int i = 0; 
 * @param bw_dl the downlink bandwidth to free     while ((nl != null && 
nl.getLength() > 0) && i < nl.getLength())  */ 
 public void freeQoSBandwidth(int QoS_class, int 
bw_ul, int bw_dl) throws IOException 
    { 
     Element IP_Flow = 
(Element)nl.item(i);  { 
  parseXML(getXML());      i++; 
        NodeList nl1 = 
IP_Flow.getElementsByTagName("session_id");   //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
     if(nl1 != null && 
nl1.getLength() > 0)  
      { 
       Element Session_ID 
= (Element)nl1.item(0);   NodeList nl = 
docEle.getElementsByTagName("rule");       String 
current_session_id = 
Session_ID.getFirstChild().getNodeValue().toString(); 
  if(nl != null && nl.getLength() > 0) { 
   for(int i = 0 ; i < nl.getLength();i++) { 
          
 if(current_session_id.equals(session_id))     //get the authorised codec rule 
    Element rule =       { 
 第 70 頁 / 共 86 頁
        for(int a 
= 0 ; a < nl2.getLength();a++) 
  parseXML(getXML()); 
   
        {   //get the root elememt 
        
 Element class_id = (Element)nl2.item(a); 
  Element docEle = 
dom.getDocumentElement(); 
        
 if(QoS_class == 
(Integer.valueOf(class_id.getFirstChild().getNodeValue(
))).intValue()) 
 
 
  NodeList nl = 
docEle.getElementsByTagName("rule"); 
         {   if(nl != null && nl.getLength() > 0) { 
         
 int temp = 
(Integer.valueOf(class_id.getAttribute("bw_downlink")))
.intValue() - bw_dl; 
   for(int i = 0 ; i < nl.getLength();i++) { 
     
    //get the authorised codec rule 
    Element rule = 
(Element)nl.item(i);          
 String new_bw_dl = "" + temp;     String id = 
rule.getAttribute("id");          
 temp = 
(Integer.valueOf(class_id.getAttribute("bw_uplink"))).int
Value() - bw_ul; 
    if(id.equals("qos class 
authorisation")) 
    { 
         
 String new_bw_ul = "" + temp; 
     NodeList nl3 = 
rule.getElementsByTagName("conditions"); 
         
 class_id.setAttribute("bw_downlink",new_bw_dl); 
     if(nl3 != null && 
nl3.getLength() > 0) 
     {  
      Element conditions = 
(Element)nl3.item(0); 
         
 class_id.setAttribute("bw_uplink",new_bw_ul); 
         
        NodeList nl1 = 
conditions.getElementsByTagName("qos_class");          } 
           if(nl1 != null && 
nl1.getLength() > 0)         }  
       }       {  
      }        Element 
qos_class = (Element)nl1.item(0);      } 
       NodeList nl2 = 
qos_class.getElementsByTagName("class_id");  
    } 
   } 
  }        if(nl2 != null 
&& nl2.getLength() > 0)    putXML(XMLDocToString(dom)); 
 }        { 
 第 72 頁 / 共 86 頁
         } 
     
        }  
       } 
      } 
     } 
    } 
   } 
  } 
  putXML(XMLDocToString(dom)); 
 } 
  
 /** 
      * This deducts the specified uplink and 
downlink bandwidth to the specified domain 
 * @param domain the domain to return the 
bandwidth to 
 * @param bw_ul the uplink bandwidth to deduct 
 * @param bw_dl the downlink bandwidth to 
deduct 
 */ 
 public void reqDomainBandwidth(String domain, 
int bw_ul, int bw_dl) throws IOException 
 { 
   
   parseXML(getXML()); 
   
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
 
  NodeList nl = 
docEle.getElementsByTagName("rule"); 
  if(nl != null && nl.getLength() > 0) { 
   for(int i = 0 ; i < nl.getLength();i++) { 
     
    //get the authorised codec rule 
    Element rule = 
(Element)nl.item(i); 
    String id = 
rule.getAttribute("id"); 
    if(id.equals("domain 
authorisation")) 
    { 
     NodeList nl3 = 
rule.getElementsByTagName("conditions"); 
     if(nl3 != null && 
nl3.getLength() > 0) 
     {  
      Element conditions = 
(Element)nl3.item(0); 
      NodeList nl1 = 
conditions.getElementsByTagName("domain"); 
      if(nl1 != null && 
nl1.getLength() > 0) 
      {  
       Element 
Domain = (Element)nl1.item(0); 
       NodeList nl2 = 
Domain.getElementsByTagName("address");  
       if(nl2 != null 
&& nl2.getLength() > 0)  
       { 
        for(int a 
= 0 ; a < nl2.getLength();a++) 
        { 
        
 Element address = (Element)nl2.item(a); 
        
 if(domain.equals( address.getFirstChild().getNode
Value())) 
         { 
         
 int temp = 
(Integer.valueOf(address.getAttribute("bw_downlink"))).
intValue() - bw_dl; 
         
 第 74 頁 / 共 86 頁
  } 
 } 
 
 /** 
 * This gets an XML file from the XDMS server 
 * @return xmlDoc InputStream  representation of 
the document retrieved from the server 
 */ 
 public InputStream getXML() throws IOException 
 { 
  InputStream xmlDoc = null; 
  if(remote_xcap_server == 1) 
  { 
 //  
 System.out.println("-------------------------------------
-------------"); 
 //   System.out.println(); 
 //   System.out.println("INFO: Sending 
HTTP GET to XDMS Server"); 
 //   System.out.println(); 
  
   HttpClient client = new HttpClient(); 
   client.getState().setCredentials( 
   AuthScope.ANY, 
   new 
UsernamePasswordCredentials(username,password) 
   ); 
   GetMethod get = new 
GetMethod(policy_db); 
   get.setDoAuthentication( true ); 
   try { 
   // execute the GET 
   int status = 
client.executeMethod( get ); 
  
   // print the status and response 
   //System.out.println("INFO: Received 
HTTP " + status + " from XDMS Server" ); 
   String temp = status + "\n" + 
get.getResponseBodyAsString(); 
  
   xmlDoc = 
get.getResponseBodyAsStream(); 
   }finally { 
   // release any connection resources 
used by the method 
    get.releaseConnection(); 
   } 
  } 
  else 
  { 
   Document doc1 = null; 
   DocumentBuilderFactory dbf = 
DocumentBuilderFactory.newInstance(); 
   try { 
     
    //Using factory get an instance of 
document builder 
    DocumentBuilder db = 
dbf.newDocumentBuilder(); 
     
    //parse using builder to get DOM 
representation of the XML file 
    doc1 = db.parse(policy_db); 
     
  
   }catch(ParserConfigurationException 
pce) { 
    pce.printStackTrace(); 
   }catch(SAXException se) { 
    se.printStackTrace(); 
   }catch(IOException ioe) { 
    ioe.printStackTrace(); 
   } 
   String xmlStr = 
XMLDocToString(doc1); 
   xmlDoc = new 
ByteArrayInputStream(xmlStr.getBytes()); 
 第 76 頁 / 共 86 頁
       }        nl1 = 
IP_Flow.getElementsByTagName("source_port");        nl1 = 
IP_Flow.getElementsByTagName("bw_downlink");        if(nl1 != null 
&& nl1.getLength() > 0) {        if(nl1 != null 
&& nl1.getLength() > 0) {         Element 
Source_Port = (Element)nl1.item(0);         Element 
BW_Downlink = (Element)nl1.item(0);         ip_flow 
= ip_flow + Source_Port.getFirstChild().getNodeValue() 
+ ";"; 
        ip_flow 
= ip_flow + 
BW_Downlink.getFirstChild().getNodeValue() + ";";        } 
       }        nl1 = 
IP_Flow.getElementsByTagName("dest_port");        nl1 = 
IP_Flow.getElementsByTagName("bw_uplink");        if(nl1 != null 
&& nl1.getLength() > 0) {        if(nl1 != null 
&& nl1.getLength() > 0) {         Element 
Dest_Port = (Element)nl1.item(0);         Element 
BW_Uplink = (Element)nl1.item(0);         ip_flow 
= ip_flow + Dest_Port.getFirstChild().getNodeValue() + 
";"; 
        ip_flow 
= ip_flow + BW_Uplink.getFirstChild().getNodeValue() 
+ ";";        } 
       }        nl1 = 
IP_Flow.getElementsByTagName("flow_usage");        nl1 = 
IP_Flow.getElementsByTagName("qos_class");        if(nl1 != null 
&& nl1.getLength() > 0) {        if(nl1 != null 
&& nl1.getLength() > 0) {         Element 
Flow_Usage = (Element)nl1.item(0);         Element 
QoS_Class = (Element)nl1.item(0);         ip_flow 
= ip_flow + Flow_Usage.getFirstChild().getNodeValue() 
+ ";"; 
        ip_flow 
= ip_flow + QoS_Class.getFirstChild().getNodeValue(); 
       }        } 
      
 ip_flows.add(ip_flow);     
   
       nl1 = 
IP_Flow.getElementsByTagName("flow_status"); 
       if(nl1 != null 
&& nl1.getLength() > 0) {       } 
     }         Element 
Flow_Status = (Element)nl1.item(0);     } 
   }         ip_flow 
= ip_flow + Flow_Status.getFirstChild().getNodeValue() 
+ ";"; 
  } 
  return ip_flows; 
 第 78 頁 / 共 86 頁
  /**TODO Link multiple PCEFs if realms 
different*/ 
  /**If orig and dest realm the same*/ 
 
 //if(orig_realm.equalsIgnoreCase(dest_realm)) 
  //{ 
    
   //fetch and parse the policy XML 
document 
   parseXML(getXML()); 
   //get the root elememt 
   Element docEle = 
dom.getDocumentElement(); 
  
   int orig_authorised = 0; 
   int term_authorised = 0; 
    
   NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
   if(nl0 != null && nl0.getLength() > 0)  
   { 
    Element tris = 
(Element)nl0.item(0); 
    NodeList nl = 
tris.getElementsByTagName("pcrf"); 
    if(nl != null && nl.getLength() > 
0) { 
     for(int i = 0 ; i < 
nl.getLength();i++) { 
       
      //get the address 
element 
      Element PCRF = 
(Element)nl.item(i); 
      NodeList nl1 = 
PCRF.getElementsByTagName("domain"); 
      if(nl1 != null && 
nl1.getLength() > 0) { 
       Element 
Domain = (Element)nl1.item(0); 
      
 if(Domain.getFirstChild().getNodeValue().toString
().equals(orig_realm)) 
       { 
        nl1 = 
PCRF.getElementsByTagName("af_address"); 
        if(nl1 != 
null && nl1.getLength() > 0) { 
        
 Element AF_Address = (Element)nl1.item(0); 
        
 af_address = 
AF_Address.getFirstChild().getNodeValue().toString();
  
        } 
       } 
         
      } 
     } 
    } 
    
   } 
  return af_address; 
  //} 
  /**if orig and dest realm different*/ 
  //{ 
  //} 
 } 
 
 
 /** 
 * This returns the address of the AF associated 
with a PCRF 
 * @param pcrf_address the address of the pcrf 
 * @return af_address the address of the AF 
 */ 
 public String getAF(String pcrf_address) throws 
IOException 
 第 80 頁 / 共 86 頁
   Element docEle = 
dom.getDocumentElement(); 
  
   NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
   if(nl0 != null && nl0.getLength() > 0)  
   { 
    Element tris = 
(Element)nl0.item(0); 
    //get all authorised domains and 
list of authorised QoS classes into vectors 
    NodeList nl = 
tris.getElementsByTagName("pcef"); 
    if(nl != null && nl.getLength() > 
0) { 
     for(int i = 0 ; i < 
nl.getLength();i++) { 
       
      //get the address 
element 
      Element PCEF = 
(Element)nl.item(i); 
      NodeList nl1 = 
PCEF.getElementsByTagName("domain"); 
      if(nl1 != null && 
nl1.getLength() > 0) { 
       Element 
Domain = (Element)nl1.item(0); 
      
 if(Domain.getFirstChild().getNodeValue().toString
().equals(orig_realm)) 
       { 
        nl1 = 
PCEF.getElementsByTagName("address"); 
        if(nl1 != 
null && nl1.getLength() > 0) { 
        
 Element Address = (Element)nl1.item(0); 
        
 pcefAddress = 
Address.getFirstChild().getNodeValue().toString();  
        } 
       } 
         
      } 
     } 
    } 
    
   } 
  return pcefAddress; 
  //} 
  /**if orig and dest realm different*/ 
  //{ 
  //} 
 } 
 
 /** 
 * This sets the stats of the specified PCEF to ON 
or OFF 
 * @param pcefID ID of PCEF 
 * @param status either ON or OFF 
 */ 
 public void statusPCEF(String pcefID, String 
status) throws IOException 
 { 
   
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
  NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
  if(nl0 != null && nl0.getLength() > 0)  
  { 
   Element tris = (Element)nl0.item(0); 
   NodeList nl = 
tris.getElementsByTagName("pcef"); 
   if(nl != null && nl.getLength() > 0) { 
 第 82 頁 / 共 86 頁
 第 84 頁 / 共 86 頁
 Status.replaceChild(dom.createTextNode(status),St
atus.getFirstChild()); 
       } 
      } 
     } 
      
    } 
   } 
 
  } 
  putXML(XMLDocToString(dom)); 
 } 
  
 /** 
 * This gets the domain of a specified PCRF 
 * @param pcrfID ID of PCRF 
 * @return domain associated domain 
 */ 
 public String getPCRFDomain(String pcrfID) 
 { 
  String domain = ""; 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
  NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
  if(nl0 != null && nl0.getLength() > 0)  
  { 
   Element tris = (Element)nl0.item(0);
   
   NodeList nl = 
tris.getElementsByTagName("pcrf"); 
   if(nl != null && nl.getLength() > 0) { 
    for(int i = 0 ; i < 
nl.getLength();i++) { 
      
     Element PCRF = 
(Element)nl.item(i); 
     NodeList nl1 = 
PCRF.getElementsByTagName("pcrf_id"); 
     if(nl1 != null && 
nl1.getLength() > 0) { 
      Element  PCRF_ID 
= (Element)nl1.item(0); 
     
 if(pcrfID.equals(PCRF_ID.getFirstChild().getNode
Value())) 
      { 
       nl1 = 
PCRF.getElementsByTagName("domain"); 
       if(nl1 != null 
&& nl1.getLength() > 0) { 
        Element  
Domain = (Element)nl1.item(0); 
        domain = 
Domain.getFirstChild().getNodeValue().toString(); 
       } 
      } 
     } 
      
    } 
   } 
  } 
  return domain; 
 } 
 
} 
 
 第 86 頁 / 共 86 頁
2. Multi-agent System：主要因應大型環境中訊息交換和進行控制
等功能所設計，主要係建構 Cooperative 概念，且可運用增強
式學習法設計 Multi-agent system，以做為大量資料的判斷，而
代理人彼此進行相互溝通，達到資訊交換之目的。 
3. QoS 策略：依據 3G、WLAN 及 WiMAX QoS 規格，將不同類
型之應用分為 Interactive、VoIP、Video/Audio Streaming 及 Best 
Effort 等四個類別，每類應用具有不同的 QoS 需求，結合由感
知能力所獲取的 RSSI 值，進行 QoS 的決策，判斷是否有更合
適的存取網路，提供使用者進行換區的動作，以獲得最佳的傳
輸品質。當使用者的網路環境遭受到雜訊干擾時，往往會造成
傳輸的品質不佳，進而導致傳輸環境不符合應用所需的 QoS
要求，此時 QoS 策略機制便會啟動，以保證應用服務所需的
QoS。 
推廣及運用的價值 
此研發成果可推廣及運用於無線網路和車載之相關產業，建置
於無線網路之終端設備、車載之路側系統 (Road Side Unit, RSU) 
與車輛單元 (On-Board Unit, OBU)中，使用者運用相關移動或非移
動性終端設備時，可確保傳輸多媒體訊息之網路服務品質。 
※ 1.每項研發成果請填寫一式二份，一份隨成果報告送繳本會，一份送 貴單位
研發成果推廣單位（如技術移轉中心）。 
※ 2.本項研發成果若尚未申請專利，請勿揭露可申請專利之主要內容。 
※ 3.本表若不敷使用，請自行影印使用。 
 
 目 錄 
 
一.研究目的 ----------------------------------------------------3 
二.研究步驟 ----------------------------------------------------4 
三.研究成果 ----------------------------------------------------5 
四.檢討與建議 -------------------------------------------------5 
五.成果相關資料附件 ----------------------------------------7 
附件一:國科會補助與 Telcordia 合作系統測試 
附件二:研究成果發表於 International Journal of Communication 
Systems (Minor Revision)  
附件三:研究成果 Submitted to ACM Transactions on Autonomous 
and Adaptive Systems 
附件四:研究成果發表於 ChinaCom2010 
附件五:研究成果發表於 ACM Multimedia System Journal  
附件六: IJMIS- Special Issue ‘Multimedia Signal Processing and 
Communications’ 
 
圖一: 4G-IMS Testbed  
 
 
二.研究步驟 
 
     本人於前期計畫（NSC 94－2219－E－259－003; NSC 96－2219
－E－011－009; NSC 97－2219－E－011－008）已與兩研究單位合作五年
餘(2005~)，所以本次赴美參加研討會議前，已與 Telcordia Technologies
與 NJIT 談妥研究執行步驟，如表一所列(時間以 3 天為期；含假日)。
兩方之研究團隊於 95 年 5 月中已開始 meeting。拜網路之賜，台科大
電機系及東華大學資工系研究生(計畫主持人原任教於東華大學資工
系 )，藉由網路 Meeting  (Skype Toolkit)與國際學者專家一起
meeting，感受國際合作的氣氛。唯一可惜，因兩地時差 12 小時，參
與研究之學生 meeting 相當辛苦。 
 
 
表一: 執行步驟 
研究單位 4/11 (星期日) 4/12(星期一) 4/13(星期二) 
Telcordia  C3QM 系統 IMS 
QoS 模組功能測
試(台科大 
Group 與
Telcordia 
 C3QM- 
Cross-Layer 及
Cognitive 及
Cooperative 
Protocol 
未來合作規劃 
(台科大與 Director;
地點: Princeton 
University)  
 4
NJIT 研究成果 
‘Design and 
Integration of the 
OpenCore Based 
Mobile TV 
Framework for 
DVB-H/ T Wireless 
Network,’ Accepted 
by ACM Multimedia 
System Journal. (如
附件五)  
  
  
IJMIS- Special 
Issue 
 ‘Multimedia 
Signal 
Processing and 
Communications’ 
(CFP;如附件六) 
 
除上述量化成果外，本人亦完成許多的合作 Activities： 
(1) 擔任 Telcordia Technologies 之 Visiting Researcher，與多位首席科學家
討論未來合作議題。 
(2) 於 99/4/12 至 NJIT 向 College of Computing Sciences 演講，並介紹研究
成果。  
(3) 於 IEEE Sarnoff Symposium 發表研究成果’Cooperative QoS Mechanism for 
Heterogeneous Networking’。 
 
四.檢討與建議 
 
     本人感謝國科會給我此機會，跨出學校與國際學術合作，合作執
行研究，雖然相當辛苦，研究壓力亦大，但品嚐成果卻相當甘甜。此
外，參與研究計畫的學生藉由網路與國際學者 Meeting，感受國際研
究的氣氛，他們都感覺相當值得。  
 
 6
  
附件三:研究成果 Submitted to ACM Transactions on Autonomous 
and Adaptive Systems 
 
 
 
附件四:研究成果發表於 ChinaCom2010 
 
 
 
 
 
 8
 1 
 
 
附件一 
行政院國家科學委員會補助專題研究計畫 ■成果報告   □期中進度報告 
 
跨層式感知與協力 4G-IMS 無線網路研究 
子計畫三: 跨層式感知與協力 4G-IMS 無線網路之服務品質與
資源管理研究(2/3) 
 
計畫類別：□ 個別型計畫 ■ 整合型計畫 
計畫編號：  NSC 98－2219－E－011－006 
執行期間： 98 年 8 月 1 日至 99 年 7 月 31 日 
計畫主持人：陳俊良   國立台灣科技大學電機工程學系 
計畫參與人員：伍思霖、楊佩嘉、劉世偉、馬奕葳、卓俊宇、陳佳伶、鄭秉
昇 
 
成果報告類型(依經費核定清單規定繳交)：□精簡報告 ■完整報告 
 
本成果報告包括以下應繳交之附件： 
□赴國外出差或研習心得報告一份 
□赴大陸地區出差或研習心得報告一份 
■出席國際學術會議心得報告及發表之論文各一份 
□國際合作研究計畫國外研究報告書一份 
 
處理方式：除產學合作研究計畫、提升產業技術及人才培育研究計畫、列管
計畫及下列情形者外，得立即公開查詢 
          □涉及專利或其他智慧財產權，□一年□二年後可公開查詢 
          
執行單位：國立台灣科技大學電機工程學系 
中   華   民   國  九十九 年 十 月 二十八 日 
 3 
 
 
    
           地鐵自動售票機                              地鐵商店 
   
              Phoenix Park                         Phoenix Park 住宿飯店 
   
            SKI World 大廳                           SKI World 餐廳 
 
    Conference 報到處設在住宿大樓 2 樓大廳，Registration Desk 依據我的報名資料解釋手冊
與研討會相關資訊。最重要的是韓國無線網路的使用方式，可向飯店租用 3G 網路或由研討
會提供之韓國 3G 無線網路軟體上網，但大會僅提供有限人次同時上網。可能是大部分韓國
參與者已有 3G 網路帳號，因此才使用此分享帳號之方式。大會晚宴時與台灣同伴一起同桌，
 5 
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 7 
 
 
本人所指導之學生 Szu-Lin Wu 於會議上報告 
                                             
 
    此外，本人亦與台東大學張耀中教授合作研究並共同發表研究成果- 論文 Optimal 
Deployment Strategy of RFID Networks Using Tabu Search Mechanism 在 Session 10A: RFID & 
USN Technologies (I) 發表，由日本 Waseda University 的 Mitsuji Matsumoto 教授主持。在十五
分鐘簡短的報告後，與會學者對於如何佈建 RFID Reader 非常有興趣，並討論實施在小學之
中所遭遇的問題，Session 結束後，並至 Poster Session 參觀其他 Poster 展示的論文。 
 
1. Optimal Deployment Strategy of RFID Networks Using Tabu Search Mechanism, Yao-Chung 
Chang, Yu-Shan Lin(National Taitung University, Taiwan), Ci-Jhih Fong(Taiwan Hospitality 
and Tourism College, Taiwan), Jiann-Liang Chen (National Taiwan University of Science and 
Technology, Taiwan) 
2. USN-based Architecture for Traffic Managemen, J.H. Eu, Ph.D., PE, YH Kim, Ph.D., C.S. 
Chung, S.J. Park(Jcast Networks Korea, Inc., Korea)  
3. A Hybrid Tag Number Estimation Scheme for Aloha Based Anti-Collision Algorithm in RFID 
Networks, Zheng-Ping li, Shu-Jun Guo, Yu-Hua Wang, Zhi-Hao Yang, Min Zhang(North 
China University of Technology, China) 
4. Enhanced Agent based User Mobility Support Mechanism in RFID Networking Environment, 
Dong Geun Yun,, Seong Gon Choi(Chungbuk National University, Korea), Chang Ho 
Seo(Gongju National University, Korea) 
5. RFID based Localization Techniques for Indoor Environment, Nichapat Pathanawongthum, 
Panarat Cherntanomwong(King Mongkut’s Institute of Technology Ladkrabang, Thailand) 
 
 9 
 
出席 IEEE Sarnoff Symposium 國際學術會議心得報告 
 
IEEE Sarnoff Symposium是由 IEEE協會及Princeton大學每年合辦的學術研討會議，
舉辦地點在Princeton大學。4月12日至風景優美及學風鼎盛的Princeton大學 IEEE Sarnoff
會議報到處辦理報到，領取會議相關資料。隔天在 Princeton 大學校內之 Nassau Inn 舉行
研討會議。會議開始由大會主席 Prof. Nirwan Ansari (New Jersey Institute of Technology, 
USA)介紹與會來賓與參與之工作人員，同時報告本屆 Sarnoff 會議議程。本屆研討會著
重於 Green Technologies for Communications，研討會議程包含一場 Dinner Speech、12 場
Tutorial (Specifications、 Information Theory、Broadband Access Networks、  Wireless 
Communications Transceivers、 Antennas for Wireless Communications、 Applications and 
Multimedia、 Wireless Communications RF Devices、 Radio Resource and Interference 
Management、 MINO、 Sensor Networks)、一場 Keynote Lecture (Network Convergence in 
Future Internet)及 25 場論文發表 Session，投稿論文總數為 230 篇，大會接受 95 篇十四國
之研究論文，論文接受率為 41%。 
  
我們的報告是安排在 4/14 上午 8:00~9:40，同一個時段有 5 個 Parallel Session 進行。
此次我們的研究團隊發表了 1 篇研究報告 ”Cooperative QoS Mechanism for 
Heterogeneous Networking”。每一 Session 安排 paper 發表篇數不多，所以討論熱烈，
我們的研究合作夥伴 Prof. Frank 及 Kevin 亦分別從 NJIT 及 Telcordia 趕來參加此盛
會，並與 Princeton 大學的 Prof. Kung 討論未來合作事宜。我們報告完後，與會的先進
也提出了一些問題，與之回覆與討論，覺得受益良多。此外亦聽取其他 Session 的研究
成果報告，包括：Radha Poluri (NJIT, US),Ali Akansu (NJIT, US)的”Short Length CDMA 
Codes for Wireless Sensor Networks”; Mojtaba Sabeghi (Delft University of Technology, NL); 
Mahmoud Naghibzadeh (Ferdowsi University of Mashhad, IR); Koen Bertels (Delft 
University of Technology, NL)的” RDM+: A New Mac Layer Real-Time Communication 
Protocol”; Trent Jacobs (University of Texas at Dallas, US); Hlaing Minn (University of 
Texas at Dallas, US); Naofal Al-Dhahir (University of Texas at Dallas, US)
的”Reduced-Complexity Bandwidth-Constrained Distributed Estimation for Wireless Sensor 
Networks”; Brian Matt (SPARTA, US); Matt Mundy (SPARTA, US)的” Designing Efficient 
and Resilient Tactical Sensor Network Neighborhood Keying Algorithms”，對未來通訊網路
研究方向的定位較明確。 
  
接著由主席 Prof. Ansari 介紹大會 Keynote Lecture，主題為 Network Convergence in 
Future Internet，主講者為 Biswanath Mukherjee, University of California, USA。演講內容
以 2005 年開始由 NSF 補助之 Optical Network Project 為主軸，參與之研究機構包含
Adaptive Cross-layer QoS Mechanism for
Cognitive Network Applications
Shih-Wei LiU I2, Szu-Lin we' and Jiann-Liang Chen2
JDepartment ofComputer Science & In/ormation Engineering, National Dong Hwa University, Hualien, Taiwan
2Department 0/Electrical Engineering, National Taiwan UniversityofScience & Technology, Taipei, Taiwan
*Corresponding email: Lchen@mail.ntust.edu.tw
Abstract- Given limited network resources, applications,
particularly those that support real-time services, must deliver
an ambient quality-guaranteed service. Different applications
are associated with different Quality of Service (QoS) concerns,
as well as different QoS control parameters. This work
discusses the QoS specifications of three wireless access
technologies, 3G, WiMAX and WiFi, in the design of an
ambient QoS mechanism. By exploiting the concepts of Cross-
Layer and Cognition, this study integrates these environmental
parameters with the sensing of spectral and received signal
strength from a cognitive radio paradigm, and proposes the
ambient QoS algorithm to select the best access network for
services. The proposed QoS mechanism not only meets the
requirements of various applications but also guarantees QoS.
From the simulation results, the proposed ambient QoS
mechanism outperforms existing mechanisms in real-time
applications. Comparison with traditional mechanisms reveals
that the proposed ambient intelligence reduces average delay
time and jitter to 0.157 seconds and 0.086 milliseconds,
respectively, for VoIP services, and reduces the packet loss ratio
for high-definition video stream by 3.42%.
K~wortk-Heterogeneous Network, Quality of Service,
Ambient Intelligence, Cross-Layer, Cognitive Network
I. INTRODUCTION
The rapid development of the Internet is driving daily
changes in wireless communication and mobile computing
technologies. Mobile communication and service providers
suffer from heterogeneous network environments.
Consequently, supporting ambient Quality of Service (QoS)
is importance to next generation wireless communication.
Figure I presents the promising 40 heterogeneous
network architecture which includes 30, WLAN and
WiMAX access technologies. The IMS (IP Multimedia
Subsystem) fulfills three main functions in the packet
switching core network, including providing QoS for
services, offering extensible charging mechanisms to
multimedia services and integrating AII-IP services.
Spectral resources have become increasingly limited
owing to the rapid development of wireless communication
technology, especially the frequencies below 30Hz.
Cognitive radio (CR) is a key technology for improving
spectrum-utilization efficiency under the current static
spectrum-allocation policy [1, 2]. CR is a wireless
communication paradigm in which either a network or a
wireless node changes its transmission to increase
communication efficiency. The CR allows user terminals to
sense whether a portion of the spectrum is being used, thus
facilitating spectrum sharing among neighboring users.
Layering is fundamental in providing the basis for protocol
design. System designers can divide a complicated architecture
into modules and solve each one independently. Stressing the
concept of modular design leads to major communication and
only occurs between nearby layers, and causes problems in
transmission performance, such as high error rate in wireless
networks, security, QoS and power consumption of mobile
communications. Hence, an ambient mechanism, Cross-Layer
scheme, can enhance transfer efficiency and networking
performance.
-1G Cere :\ t h. o rL.
(I". d,tt S", h ch1,'d )
u :
Figure 1: 4G Network Architecture
Based on the cross-layer, cognitive and cooperative
operating concepts, this study proposes an ambient QoS
architecture for 40 network services. Figure 2 presents the
proposed C3QM (Cross-layer, Cognitive, Cooperative QoS
Manager) system architecture. The system architecture includes
the Data Plane, Control Plane and Knowledge Plane. The Data
Plane primarily collects network status or parameters and then
provides Control Plane and Knowledge Plane data for analysis
ISBN 978-89-5519-146-2 - 1389- Feb. 7-10, 2010 ICACT 2010
Figure 4 illustrates the proposed cross-layer ambient QoS
manager system architecture, which includes the Data Plane,
Control Plane and Knowledge Plane. The Data Plane
primarily gathers network status and parameters, manages
incoming traffic and provides the information to the Control
Plane and the Knowledge Plane for analysis and
management; meanwhile, the Control Plane judges whether
the resource is sufficient for allocation to the requested
connection, manages the handover process and responds by
transferring the control signal to each layer; the Knowledge
Plane defmes different QoS goals from low layer information
and makes handover decisions involving appropriate access
networks based on the proposed ambient QoS algorithm.
QoS Man uger ---------------,
Knowlcd~ePlane
Rule A m b ient
Repos itory QoSM echanism
C o n t r o l Pl ane
A dmission Ha nd o ff QoS
C o nt ro l C o nt ro l Monitor
Data P lanc
C o g n it io n etwork Bandwidth Traffic
Function Parameters C o n tro l C o n tro l
Figure 4: Proposed Ambient QoS Manager System Architecture
Figure 5 describes the ambient QoS algorithm. The mobile
node checks its environment for available networks. For each
available network, the ambient QoS algorithm checks the
application type and maps it to the appropriate traffic class.
Four traffic classes are defined, including Interactive Class,
Conversation Class, Video/Audio Streaming Class and Best
Effort Class. The Conversation Class traffic, such as VoIP
stream, is more concern about the jitter. Excessive jitter
distorts voice conversation. The Video/Audio Streaming
Class traffic, such as MPEG video suffers issues of packet
loss. Video quality is reduced if the packet loss ratio exceeds
a pre-defined threshold.
The ambient QoS algorithm judges the QoS parameters
and bandwidth of the candidate networks. If the candidate
network status satisfies the user requests, the mobile node
performs the handover procedure, and moves to the
candidate network to obtain better QoS. If the mobile node
has two or more candidate networks that satisfy user QoS
requests, the ambient QoS algorithm selects that with the
highest RSSI value as the candidate network. Figure 6 shows
the flow chart of the ambient QoS algorithm.
Check available network & store in ANIi]
if{i ~ 0)
{
for ( index = 0 : index ;$ i : index++ )
{
switch (traffic_class)
(
case #2:
if( JANIil--NULL )
{
flag[i]-O :
break:
I else if ( J'hd ~ J ANIil&& B~. :iO BAsrn)
flag[ i) - I :
break:
case #3:
if( PLRASlil==NULL )
(
flag[i]-O;
break;
I else if{ PLR.hd ~ PLRA"1il&& B~ ;$ BAsm)
tlag[i]- 1:
break:
default:
flag!i] = 0:
}
if( exist i when flag!i]==l && max{RSSIAN,.l»
{
B ANril - = B~q ;
return candidate network AN[i]
[else
(
if{ RSSI.u , < max{RSSIANlill)
return AN!i] which has max(RSSIAslll)
else
Using current network!!
[else
No available network!!
Figure 5: Ambient QoS Algorithm
Calculate the candidate
network according to traffi c
class & ca ndidate network
condition
Figure 6: Flow Chart of Ambient QoS Algorithm
ISBN 978-89-5519-146-2 - 1391 - Feb. 7-10, 2010 ICACT 2010
