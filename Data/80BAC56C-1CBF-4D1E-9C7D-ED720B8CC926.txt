 2 
 
目錄 
中文摘要 3 
Abstract (英文摘要) 3 
一、前言 4 
二、研究目的 4 
三、低功率快取記憶器架構簡介 4 
四、提出之低功率快取記憶器架構 6 
 4.1 區塊範圍偵測濾過式快取 6 
 4.2 資料記憶體槽化 13 
 4.3 標籤記憶體存取忽略與資料記憶體致能控制 15 
五、研究結果 19 
 5.1 實驗架構 19 
 5.2 實驗設定與結果 20 
  5.2.1 效能評估程式介紹 20 
  5.2.2 指令快取記憶體實驗類型與EDA環境 21 
  5.2.3 實驗結果 21 
  5.2.4 FPGA合成結果 23 
  5.2.5 元件庫合成結果 23 
 5.3 晶片規格 24 
六、結論  25 
七、參考文獻 26 
誌謝   27 
計畫成果自評 28 
 
 
 
 
 
 
 
 4 
一、前言 
快取記憶體的概念是為了彌補處理器與主記憶體之間的速度差距而搭起的橋樑，目
的是為了減低存取記憶體系統的平均時間，以提升整體執行效能。自1980年起，處理器
的速度每年約成長60%，反觀動態隨機存取記憶體的存取速度，平均一年只成長了9%，
時間經過的越久，記憶體與處理器之間速度不匹配的問題就越嚴重。因此on-chip cache[5, 
10]的設計被用來解決這類的問題，在設計上，快取記憶體的大小會間接的影醒快取整體
的命中率，快取面積越大能提供的效能便會越好，但是隨之而來的是擴大面積後所造成
的功率消耗。隨著時代的前進，可攜式裝置(如:手提電腦、智慧型手機、GPS裝置)被迫
要提供更佳的效能，以處理更多複雜的功能，因而快取記憶體[11, 12]的設計在這些裝置
上就顯得相當重要，且一般可攜式裝置多使用電池為其電力來源，若能有效降低裝置執
行時所消耗的功耗，則能提升裝置的續航力，並得以提升產品在消費市場上的競爭力。 
二、研究目的 
低功率快取記憶器的設計目標為降低快取記憶器的功率消耗，並且必須對效能不能
造成太大的影響。可攜式裝置的功能日新月異，裝置內所採用的處理器等級也不斷的提
升，處理器運算的速度上升，相對的快取記憶體系統的效能就必須跟著提升，為了讓快
取記憶體系統能發揮更好的效能，最直接的作法就是增加快取記憶體的容量，以提升存
取快取記憶體的命中率，然而，如此一來也會大幅增加存取快取記憶體所消耗的功率。
例如： StrongArm-110中快取記憶體所消耗的功率佔處理器晶片的 42%[1]；
ARM920T[16~19]中指令快取記憶體所消耗的功率也佔總功率消耗的25%[2]。 
由於快取記憶器在晶片處理器（on-chip cache）中所佔的面積越來越大，甚至達到
整體處理器晶片的70%。因此，降低了快取記憶器的功率消耗，就等於間接的降低了處
理器整體的功率消耗。所以在低功率快取記憶器的設計上，我們首要注重的地方便是效
能與功率間的取捨（trade off）。 
傳統的低功率快取記憶器設計著重於功率的節省，因而較易造成效能上的損失，例
如濾過式快取（Filter cache）採用一級L0-cache減少處理器對L1-cache的存取[14]，進而
節省了約58%的功率消耗，但是此舉會造成近20%的效能損失。因此，我們的研究將建
構在效能的保證之上，盡可能的降低快取記憶器的功率消耗。 
三、低功率快取記憶器架構簡介 
當我們在設計快取記憶器的時候，首先必須決定快取記憶器的關聯度，因為關聯
度會影響到快取記憶器的命中率以及設計的複雜度，並且在不同的關聯度架構下會發展
出不同的低功率快取架構，傳統上直接對映式（Direct-map）擁有較佳的功率消耗，但
是受困於過高的衝突性失誤，導致其快取記憶器的效能較差。而集合關聯式
（Set-associative）則有較好的效能，但是每次存取快取記憶器所消耗的功率較多。在本
研究中我們將採用集合關聯式作為基礎架構，以期能擁有較佳的效能，並盡可能的降低
其功率消耗。傳統的低功率快取記憶器發展架構我們將於圖1示之，並加以說明。 
 6 
30%左右。並且這種預測型的技術非常仰賴預測的準確程度，倘若預測失誤非但會降低
效能還得付出多餘的功率消耗。 
因此本研究中採用了自行設計的區塊範圍偵測濾過式快取，使用區塊範圍偵測的方
法，有效的幫助處理器以相當機制的方法決定是否對L0-cache進行存取，透過偵測的方
式避免掉了預測錯誤的損失，有效的阻止效能傷害以及提升功率減緩，在我們的設計中
將此濾過式快取以Victim cache的形式輔助主快取；並以標籤記憶體存取忽略技術和記憶
體槽化技術搭配輔助節省功率，圖2示之，有效的達到降低55%的功率消耗以及無損的效
能。 
 
圖2. 提出之低功率快取記憶器架構圖 
四、提出之低功率快取記憶器架構 
在本節中，我們將對所提出的低功率指令快取記憶體所使用的三種省電技術加以說
明，分別為： 
1. 區塊範圍偵測濾過式快取 
2. 資料記憶體槽化[8] 
3. 標籤記憶體存取忽略與資料記憶體致能控制 
4.1  區塊範圍偵測濾過式快取 
在一般嵌入式應用程式中我們發現，許多程式使用了大量的迴圈以進行運算。而在
傳統快取記憶體架構中，每一次的指令提取時，皆要致能整塊快取記憶體，然而因執行
迴圈而提取的指令往往只會存在於少數的快取區塊中。第三節所提及的預測型濾過式快
取記憶體架構也就是以這個概念為基礎，然而在實驗其架構的可用性中我們發現了下列
 8 
憶體在哪些情況下會產生失誤： 
1. 強制性失誤(compulsory misses)： 
當記憶體區塊第一次被存取時，快取中一定沒有該區塊的資料而產生的失誤。 
2. 容量性失誤(capacity misses)： 
容量性失誤指的是因為快取記憶體容量不足以放入所有需要的記憶體區塊而
產生的失誤，這種失誤的產生是因為一個快取區塊被置換掉後，稍後一段時間
內又會被處理器存取到。要改善這部份的失誤，可以藉由增加快取記憶體的容
量，然而如此一來快取記憶體所佔用的面積會增加，功率消耗也會增加。 
3. 衝突性失誤(conflict misses)： 
在直接對映式與集合關聯式中，因為一個快取區塊集合其中的區塊數目有所限
制，使得一個記憶體區塊能夠放置的位置有限，因而造成記憶體區塊之間產生
碰撞衝突而產生失誤。解決的方式是增加快取區塊集合中的區塊數目，然而如
此作法會使得硬體變的如同全關聯式般，使電路更為複雜。 
有了以上對於快取失誤的了解，我們可以知道，若是在效能、面積以及電路複雜度
上皆有所限制的情況時，有一定的機會會發生快取失誤。表1為參考文獻[9]使用三種置
換策略所模擬的結果，實驗結果中約為10%的機會會造成快取失誤。 
表1. 三種置換策略(LRU、Random、FIFO)的指令快取失誤率比較 
Assoc. Two-way Four-way Eight-way 
Size LRU Rand. FIFO LRU Rand. FIFO LRU Rand. FIFO 
16KB 114.1 117.3 115.5 111.7 115.1 113.3 109.0 111.8 110.4 
64KB 103.4 104.3 103.9 102.4 102.3 103.1 99.7 100.5 100.3 
256KB 92.2 92.1 92.5 92.5 92.1 92.5 92.1 92.1 92.5 
Cache miss per 1000 instructions by 10 SPEC2000 and 5 SPECfp2000 benchmarks 
 處理器對記憶體的存取具有局部性質，分別為時間局部性以及區域局部性，快取記
憶體是由這兩種局部特性所衍生的概念。圖4中左半部為傳統快取記憶體發生失誤後快
取區塊置換的示意圖。 
 10 
別當前的記憶體位址是否能由濾過式快取中取得所需的指令。 
 區塊偵測機制排除掉了使用預測機制可能發生的預測失誤。所使用的方法是在保證
所需的指令可由濾過式快取中取得時才去存取，反之則判斷為讀取第一層級快取。其中
的電路是判斷目前記憶體位址與前一個的記體位址的標籤區段與索引區段是否完全相
同，在完全相同的情況下，我們可以判斷這兩個記憶體位址會存取到相同的記憶體區
塊。下圖6為區塊偵測機制的演算法。 
 
圖6. 區塊範圍偵測濾過式快取記憶體之演算法 
圖6其演算流程為以下： 
1. 首先判斷前一個記憶體位址是否命中於濾過式快取中。 
2. 判斷目前記憶體位址與前一個記憶體位址是否為相同的記憶體區塊： 
a. 若前兩步驟皆成立，則存取濾過式快取並將指令送回處理器。 
b. 反之則存取第一層級快取，如同一般快取記憶體的存取，當失誤發生時，
執行置換程序，並將該記憶體區塊同時寫回濾過式快取以及第一層級快取
 12 
 
表4. 程式模擬結果 FC:256B ; L1:8KB 
 
表5. 程式模擬結果 FC:512B ; L1:4KB 
 
 
圖7. 各種設定比較的程式模擬結果 
由圖7我們可以看出，在不同的濾過式快取以及第一層級快取的容量設定下，有31%
至52%的平均機率可以存取到濾過式快取，以減少對第一層級快取的存取。而表中表現
最好的是bitcount，約有60%至72%的機會可以由濾過式快取取得所需要的指令。而表現
最差的則是basicmath在256B_8KB的設定下，然而也有19%的表現。我們可以發現，當
Benchmark (Mi-bench) Total access Access FC FC Ratio Tag skip/miss Execution time 
Auto. / Industrial      
---basic-math 65,459,080 12,839,428 19.61% 40689345/1354314 940,853,160ns 
---bit-count 40,377,051 26,921,752 66.67% 2281927/792 403,857,767ns 
---quick-sort 26,448,993 7,035,195 26.59% 12905579/8760 265,453,557ns 
Office-------string 
search 
303,843 84,172 27.70% 102512/195 3,059,907ns 
Network----dijkstra 42,634,284 12,407,509 29.10% 22257188/2785 426,649,217ns 
Telecomm.-FFT 84,197,611 17,841,066 21.18% 40638969/93208 852,229,017ns 
 
FC Ratio Min. 19.61% FC Ratio Max. 66.67% FC Ratio Avg. 31.8% 
Benchmark (Mi-bench) Total access Access FC FC Ratio Tag skip/miss Execution time 
Auto. / Industrial      
---basic-math 65,459,080 16,623,205 25.39% 36905569/1354314 940,853,160ns 
---bit-count 40,377,051 26,922,428 66.67% 2281251 / 793 403,857,767ns 
----quick-sort 26,448,993 13,054,333 49.35% 6886441 / 8760 265,453,557ns 
Office---string search 303,843 148,654 48.92% 71251 / 195 3,059,907ns 
Network----dijkstra 42,634,284 14,081,974 33.02% 20582723 / 2785 426,649,217ns 
Telecomm.-FFT 84,197,611 20,184,311 23.97% 40124902/93208 852,229,017ns 
 
FC Ratio Min. 23.97% FC Ratio Max. 66.67% FC Ratio Avg. 41.22% 
FC ACCESS RATIO 
256B_4KB Avg. = 40.55% 
512B_4KB Avg. = 52.39% 
256B_8KB Avg. = 31.80% 
512B_8KB Avg. = 41.22% 
 
 14 
 
圖9. 記憶體位址切割與解碼器 
更詳細的資料記憶體功率消耗與面積比較如下表6。 
表6. Artisan記憶體模組面積與功率消耗之比較 
 
在我們的指令快取記憶體設定下，預定容量為8KB，四路的集合關聯式架構，每一路
中包含了2KB的資料記憶體模組，如下列所示，我們將2KB的資料記憶體加以分割： 
1. 切割成兩個1KB區塊組成 
功率減低了原本的6.68%，面積增加了原本的34%。 
2. 切割成四個512B區塊組成 
功率減低了原本的8.08%，面積增加了原本的99%。 
 由上述可知，雖然存取時所消耗的功率減低了，但相對的產生了額外的面積負擔。
而試著以更小的記憶體模組切割下去，因為記憶體模組中的控制電路會造成一定的負
擔，所以造成在2KB以下的記憶體模組其功率消耗沒有太大的差異。而若繼續切割下去，
只會造成更多額外的面積負擔。在此我們採用第一種切割方式，也就是將原本2KB的資
料記憶體切割成兩個1KB，如此一來雖會稍微增加面積，但可以降低約7%左右的功率消
耗，算是在面積與功率消耗之間取得一個平衡。 
 在此我們可以下一個結論，也就是資料記憶體槽化的技術較適用於大容量的快取記
憶體中，而對於小容量的資料記憶體而言，切割過細只會造成額外面積的負擔以及增加
 16 
 
圖10. 存取快取可能的流程圖 
圖10中左半部為讀取而右半部為寫入。如上述所說，當連續存取且是存取到同一個
快取區塊時，此時我們可以省略標籤區段的比較，而減少標籤區段比較也就是可以減少
標籤記憶體致能發生，而達到減少功率消耗的效果。 
 細部的指令提取狀況如圖11所示，我們可以觀察到，存取到同一個快取區塊指令
時，此時我們假設一個快取區塊由八個字組所組成，而其記憶體位址變動部分只會發生
在A[4:2]以及A[1:0]的部分，也就是字組偏移量以及位元組偏移量。而當在循序存取且發
生快取區塊轉換時，我們發現A[5]產生了變化。 
 
圖11. 循序指令存取示意圖 
 18 
 
圖13. 標籤記憶體存取忽略 
然而我們進一步發現，在這種架構下，我們可以進一步減少資料記憶體的致能。藉
由上一次記憶體位址的存取，我們可以知道我們所要存取的快取區塊是存在於哪一路
(way)中。當區塊偵測為真時，我們將上一個記憶體位址的標籤比較結果迴授給資料記憶
體，作為它的致能訊號，如此一來，我們可以減少到只有一個資料記憶體區塊被致能，
如下圖14所示： 
 
圖14. 資料記憶體區塊致能控制 
在4.1節中所提及的Mibench程式實驗中，我們將存取第一層級快取的部份加以分
析，檢視其中有多少的比例可以使連續存取的部份如圖13與14中忽略其標籤記憶體的存
取以及只致能一個資料記憶體區塊，而到達省電的效果。如圖15所示，其統計的結果(標
籤記憶體存取忽略與資料記憶體致能控制次 除以 存取第一層級快取次數)。 
 20 
1. ARM9處理器模擬器：由於我們目的在於計算指令快取記憶體在程式執行過程
中存取與寫入所消耗的功率，而等待處理器運算不在我們的考量範圍內，所以
我們在此使用一個ARM9處理器的仿真器，具備ARM公司處理器ARM9E-J[16]
的記憶體介面特性，以達到對記憶體存取的功能。 
2. 指令快取記憶體：指令快取記憶體中包含了控制器單元、置換單元、AMBA匯
流排[17]主裝置介面以及記憶體模組。而功率與效能也是針對此部分加以評估。 
3. 外部記憶體：外部記憶體是包含AMBA-AHB匯流排、從裝置SRAM控制器以及
外部的記憶體模組。當指令快取記憶體發生失誤時，快取記憶體控制器向AHB
發出使用要求，透過存取外部記憶體模組以取得所需的記憶體區塊。 
在圖中有兩個白色區塊，分別為程式執行的指令記憶體存取追蹤(Program Execution 
Trace File)與測試程式(Program.mif)。 
5.2 實驗設定與結果 
5.2.1 效能評估程式介紹 
本研究所使用的Benchmark：Mibench[13]，是由密西根大學電機工程計算機實驗室
(The University of Michigan Electrical Engineering and Computer Science) 以 及
EEMBC(EDN Embedded Microprocessor Benchmark Consortium)共同提出，針對嵌入式系
統及提供學術研究上所用途為發展的Benchmarks。 
Mibench將benchmarks分為Automotive、Industrial Control、Consumer Devices、Office 
Automation、Network、Security、Telecommunications六大類。 
本研究從中選取數個Benchmark：basicmath、bitcount、qsort、stringsearch、dijkstra、
FFT等進行模擬分析，表7為其各模擬程式的特性。 
 
 
 
 
 
 22 
上在產生記憶體模組時，有其寬度與深度的最小限制。 
而在觀察第二型，這部份的平均消耗功率略較第一型高，可能的原因是因為使用了
資料記憶體槽化的技術，使得電路增加了額外的解碼器與多工器，使得增加的功率消耗
大於因資料記憶體槽化而減少的功率。 
表10. 實驗結果 
第一層級快取8KB；濾過式快取256B (4-way SA, 32 byte per block) 
面積(um2) 功率消耗(mW) 減少比例 類型 
 Ctl Mem BM BC QS SS DIJ FFT Avg. % 
傳統型 491771 1015152 82.55 82.89 82.56 82.67 82.42 82.59 82.61 0% 
第一型 729990 1095147 74.78 54.11 75.65 76.07 73.43 78.10 72.02 12.81% 
第二型 710453 1095147 32.93 52.95 34.72 34.67 32.06 31.47 36.46 55.86% 
第三型 760348 1356632 35.52 56.12 36.67 35.14 33.47 34.08 38.45 53.45% 
 而在表11中，我們可以觀察到功率減少的比例略多於表10，原因是在於因為第一層
級快取的容量減少，而造成快取失誤的比例上升，然而這部份也會增加濾過式快取的利
用度，使得功率減少的比例小幅增加。 
表11. 實驗結果 
第一層級快取4KB；濾過式快取256B (4-way SA, 32 byte per block) 
面積(um2) 功率消耗(mW) 減少比例 類型 
 Ctl Mem BM BC QS SS DIJ FFT Avg. % 
傳統型 413464 742316 79.74 80.19 80.98 80.76 81.02 79.71 80.40 0% 
第一型 625168 822303 68.61 53.26 72.76 71.61 71.20 76.91 69.04 14.12% 
第二型 624991 822303 30.93 52.34 33.31 33.11 25.64 30.16 34.24 57.41% 
第三型 674318 994320 33.21 53.12 35.72 34.52 27.61 35.31 36.58 54.50% 
而在此我們發現，資料記憶體槽化並不是適用於小型容量的快取記憶體中，在快取
記憶體為8KB以及4KB的情況下使用其技術，功率消耗反而增加，而面積也增加了相當
的比例。 
由快取記憶體功率消耗分析，在我們所提出的指令快取記憶體中，可以表示為下列： 
(這裡以FC為濾過式快取代號；L1為第一層級快取) 
1. 處理器可以由濾過式快取取得資料，此時消耗功率與時間可以表示為： 
P4-way SA cache ≈ 1 × PTag(FC) + 1 × PData(FC)                    (1) 
P4-way SA cache = 1 Cycle                  (2) 
而存取FC僅在保證可資料在其中的情況下，這裡不會發生如第3章所討論的預
 24 
 在Proto3-ARM9TM系統暫存器轉移層程式碼驗證無誤後，我們使用Synopsys公司的
Design Compiler合成工具將暫存器轉移層程式碼轉換成邏輯閘型式。合成環境使用
TSMC 0.18 µm 元件庫，系統時脈週期為7.8 ns，工作頻率為129 MHz。合成結束後，利
用合成工具所產生的netlist檔與標準時序延遲檔(*.sdf)，使用Modelsim模擬器以SS(Slow 
NMOS Slow PMOS model)模式進行功能驗證。 
 表13為Proto3-ARM9TM系統元件庫合成後面積分布比例表。由於我們使用了
8K-BYTE的指令快取記憶體，由圖中可知，指令快取記憶體佔了系統整體面積的59%，
剩餘的部份分別為AMBA與其周邊、Proto3-ARM9TM核心、BTC與暫存器檔案所使用的
SRAM。 
表13. Proto3-ARM9TM系統之元件庫合成後面積分布比例表 
module name combinational area noncombinational area total area percentage 
Proto3-ARM9TM 
-AMBA-CACHE 
576714 2224548 2801262 100% 
Proto3-ARM9TM 185948 200798 486746 17.37% 
AMBA 56882 63766 120778 4.31% 
ICACHE 82767 1427709 1678995 59.93% 
BTC SRAM 4939 160166 165106 5.89% 
Regfile SRAM 17513 332124 349637 12.48% 
5.3 晶片規格 
 最終的晶片規格與佈局圖分別如表14與圖18所示。 
表14. 晶片完成後最終規格 
Technology 0.18 µm 1P6M 
Package LCC84 
Max. frequency 129MHz 
(Simulation condition = SS) 
Power disspation 147mW 
Total 84 
Input 15 
Output 34 
Inout 16 
IO_VDD 5 
IO_VSS 4 
CORE_VDD 5 
 
 
 
 
Pin count 
CORE_VSS 5 
Die size(with DFT; without I/O pad) 2.200 × 2.218 mm2 
Chip size(with DFT and I/O pad) 3.036 × 3.028 mm2 
 
 26 
實現部分，共消耗了10302個LUTs，最高操作頻率可達29 MHz。在元件庫實現方面，其
所耗費的核心面積為 2.200 × 2.218 mm2，整體晶片面積為3.036 × 3.028 mm2，在129 MHz
操作頻率下，平均功耗為147 mW 
七、參考文獻 
[1] Montanaro J., et al.: “A 160-MHz, 32-b, 0.5-W CMOS RISC microprocessor”, IEEE J. 
Solid-State Circuits, vol. 32, no.11, pp. 1703–1714, 1996. 
[2] S. Segars: “Low Power Design Techniques for Microprocessors”, in ISSCC Tutorial, 
Feb. 2001. 
[3] Bhattacharyya S., Srikanthan T., Vivekanandarajah K.: “Area and Power Efficient 
Pattern Prediction Architecture for Filter Cache Access Prediction in the Instruction 
Memory Hierarchy”, in VLSI Design, Automation and Test, pp. 345-348, 2005. 
[4] Jian Chen, Ruihua Peng, Yuzhuo Fu: ”Low Power Set-Associative Cache with 
Single-Cycle Partial Tag Comparison”, in ASIC, 2005. ASICON 2005. 6th International 
Conference, vol. 1, pp. 73-77, 24-0 Oct. 2005. 
[5] David A. Patterson, John L. Hennessy, Computer Organization and Design, The 
Hardware/Software Interface, 3rd ed., Morgan Kaufmann, 2003. 
[6] Tse-Yu Yeh, Patt. Y.N.: “Alternative Implementation of Two-Level Adaptive Branch 
Prediction”, in The 19th Annual International Symposium, pp. 124-134, May 19-21, 
1992. 
[7] Hasegawa A: “High code density, Low power”, IEEE Micro, vol. 15, no. 6, pp. 11, 
1995. 
[8] Ching-Long Su, Alvin M. Despain: “Cache Design Trade-offs for Power and 
Performance Optimization: A Case Study” in Proceedings of the 1995 International 
Symposium on Low Power Electronics and Design, pp. 63-68, 1995. 
[9] PrimePower Manual, Synopsys Ltd., 2003. 
[10] David A. Patterson, John L. Hennessy, Computer Architecture: A Quantitative 
Approach, 3rd ed. Morgan Kaufmann, 2003.  
[11] Nakkar M., Ahmed N.: “Low Power Cache Architecture”, in The 6th International 
Workshop on System-on-Chip for Real-Time Applications, pp. 1-4, 2006. 
[12] Hongkyun Jung, Hyoungjun Kim, Kwangmyoung Kang, Kwangki Ryoo, Hanbat Nat. 
Univ.: ”Performance Improvement and Low Power Design of Embedded Processor”, in 
Third International Conference on Convergence and Hybrid Information Technology, 
(ICCIT '08), vol. 2, pp 140-145, 11-13 Nov. 2008. 
 28 
 
計畫成果自評 
 
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應
用價值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、
是否適合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜
合評估。 
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
達成目標 
□ 未達成目標（請說明，以100字為限） 
□ 實驗失敗 
□ 因故實驗中斷 
□ 其他原因 
說明： 
 
 
 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：□已發表 □未發表之文稿 □撰寫中 ■無 
專利：□已獲得 □申請中 ■無 
技轉：□已技轉 □洽談中 ■無 
其他：（以100字為限） 
 
無研發成果推廣資料 
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
■達成目標 
□未達成目標（請說明，以 100字為限） 
□實驗失敗 
□因故實驗中斷 
□其他原因 
說明： 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：□已發表 □未發表之文稿 □撰寫中 ■無 
專利：□已獲得 □申請中 ■無 
技轉：□已技轉 □洽談中 ■無 
其他：（以 100字為限） 
3. 請依學術成就、技術創新、社會影響等方面，評估研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）（以
500字為限） 
本計畫預定設計與實作一個適用於 32 位元嵌入式微處理器的 Cache 記憶器模組。我們以
本實驗室自行建構之 ARM9TM 作為核心發展，主要以降低指令快取記憶器消耗功率為設計
目標。目前已經完成整個晶片指令快取部分的設計與驗證，並且研究成果顯示，我們發展
出來的指令快取記憶器相較於傳統型的低功率設計優秀許多。本計畫將使用 TSMC 0.18 μ
m 2P8M 製程設計與驗證，未來將整合我們實驗室內部自行發展之 ARM 相關 IP 下線製作積
體電路。目前對於整個計畫的執行任務，已經完整的達成。由於本計畫屬於實務型的研究，
在學術期刊發表論文較不易，然而其成果預計可以完成兩篇碩士論文，其中一篇已經完
成，如參考資料[20]所示，另外一篇預計於 2011年 6 月完成。 
