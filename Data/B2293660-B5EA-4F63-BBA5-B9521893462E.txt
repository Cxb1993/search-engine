中文摘要
長久以來, 我們總是避免去直接地去求 NP-hard 的問題的最佳解。 如今, 我們考慮使用一些設計固定
參數演算法的策略, 直接去解這些我們過去避而不談的問題。 一個參數化問題為一語言 L ⊂ Σ∗ × Σ∗, 其
中 Σ 為一個有限的字母集, 而第二個元素稱為此問題 L 之參數。 一個能在 f(k) · nO(1) 的時間複雜度下
解出一個參數化問題的演算法被稱為固定參數演算法, 其中 f 是一個只跟 k 相依的函數。 在過去十年來,
證明一個問題存在固定參數演算法和設計各種不同固定參數演算法的方法與技巧, 不斷地被開發出來。
此外,隨著科技不斷地進步, 我們無可避免地必須在短時間內快速地解一些需要輸入大量資料的問題。
這些問題在實際的應用面上有共同特性: 它們的資料量都非常地龐大, 即便我們花線性時間內去讀完所有
的輸入並且輸出一個解來, 在實際的應用上都稍嫌太慢。 性質測試在計算複雜度理論上是一個新的領域,
它可以在不需要看過所的有輸入資料的情況下, 透過一定次數的查詢部分的輸入資料, 推論出一個合理的
解。 給定一個函數 f : D→ F 為輸入, 如果存在一個函數 f ′ : D→ F 滿足性質 P 且 f ′ 與 f 對應的函數
值不同之處不多於 |D| 個位置, 我們稱 f 為 -接近於性質 P, 否則我們稱我們稱 f 為 -遠離於性質 P。
給定一個事先定義好的性質 P, 性質測試最主要的工作如下: 透過查詢或存取的一個未知的函數 f, 決定 f
是否滿足性質 P 抑或 f 為 -遠離於滿足性質 P。 假如對於該性質查詢的複雜度和問題輸入的大小彼此是
獨立的, 我們稱這個性質是可測試的。 固定參數演算法複雜度和性質測試是兩個當今演算法研究領域中最
熱門的主題, 這兩個研究主題不僅十分有趣, 而且更重要的是, 如何找出這兩個研究方法中的關連。 在這個
計畫中, 我們將會針對演化樹相容性問題和 λ2,1 塗色問題研究有效率的隨機固定參數演算法和性質測試
測演算法, 並且試著結合固定參數演算法和性質測試演算法, 進而提出一個新的方法去解決 NP-hard 的
問題。 目前在台灣很少人投入這方面的研究, 我們相信在這個計畫書中所提出的研究主題將有拋磚引玉的
效果, 並引發國內研究演算法的同仁投入這些研究領域的興趣。
關鍵詞: 固定參數演算法, 性質測定, 近似演算法, 隨機演算法, 演化樹, λ2,1-著色。
i
目錄
1 前言 1
2 研究目的 4
3 文獻探討 5
3.1 Property testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
3.1.1 Testing graph properties in dense graphs . . . . . . . . . . . . . . . . . 6
3.1.2 Testing graph properties in sparse graphs . . . . . . . . . . . . . . . . 8
3.2 Parameterized complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.3 Quartet consistency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
3.4 Triplet consistency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.5 λ2,1-colorability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
4 研究方法 24
4.1 Efficient fixed-parameter algorithms for the MQI problem . . . . . . . . . . . 24
4.1.1 Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
4.1.2 An O(3.0446kn+ n4) Algorithm . . . . . . . . . . . . . . . . . . . . . . 25
4.1.3 An O(2.0162kn3 + n5) Algorithm . . . . . . . . . . . . . . . . . . . . . 26
4.1.4 An O∗((1+ )k) Algorithm . . . . . . . . . . . . . . . . . . . . . . . . 26
4.2 Testing tree-likeness of quartet topologies . . . . . . . . . . . . . . . . . . . . 27
4.2.1 Existence of a complete set of quartet topologies which is at least 0.04-
far from being tree-like . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.2.2 An O(n/) property tester for tree-likeness of quartet topologies . . 30
4.2.3 Concluding remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
5 結果與討論 35
6 計畫成果自評 35
7 參考文獻 36
8 附錄 45
8.1 出席國際學術會議心得報告 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
8.1.1 出席 IWPEC 2008 會議心得報告 . . . . . . . . . . . . . . . . . . . . . . . 45
8.1.2 出席 IWOCA 2010 會議心得報告 . . . . . . . . . . . . . . . . . . . . . . 46
8.2 發表著作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
iii
2. ΨP returns “ FAIL” with probability at least 2/3 if ∆(f,P) > .
From the definition of property tester, we can see that the quality of the output is guar-
anteed only if input function has the property or is -far from the property. Preferably, a
tester should look at a portion of the input whose size is a function of  only. In other words,
the query complexity of a tester should be O(n) where n is the size of the function tested.
Notice that we consider the size of a function f, denoted by |f|, tested by a tester is the size
of the domain of the function. If the query complexity of a property tester is independent of
the input size |f|, we say that this property is testable.
To familiar readers with property testing, we give the monotonically increasing sequence
testing problem as an example. Let F : D → R be a set of one-to-one functions with the
same domain D, where D = {1, 2, . . . ,n} and R is the set of real numbers. Notice that
the size of any function in F is n. Let P be a property of functions in F such that, for a
function f ∈ F satisfying property P, we have f(i) < f(j) for 1 6 i < j 6 n. We define FP
to be the class of functions in F satisfying the property P. We say that f is monotonically
increasing if f ∈ FP. Let δ(·, ·) be a distance function such that for two functions f,g ∈ F,
δ(f,g) = |{i | f(i) 6= g(i), for 1 6 i 6 n}|/n, that is, the fraction of elements in D where f
and g have different values. Then we define ∆ to be the distance function with respect to
property P such that for a function f ∈ F, ∆(f,P) = ming∈FP δ(f,g). To design a property
tester for monotonically increasing property of a function f ∈ F is closely related to the
following problem:
Input: A sequence of n integers L = (x1, x2, . . . , xn) and a constant 0 <  < 1.
Output: Determine whether L is monotonically increasing.
For example, a sequence of n = 6 integers L = [10, 18, 7, 23, 2, 37] can be considered as
a function f ∈ F, where f(1) = 10, f(2) = 18, f(3) = 7, f(4) = 23, f(5) = 2, and f(6) = 37.
The size of function f, denoted by |f|, is 6. Let f′(i) = L′[i] for 1 6 i 6 n = 6 where
L′ = [10, 18, 19, 23, 25, 37]. It is easy to see that δ(f, f′) = 26 =
1
3 and ∆(f,P) = δ(f, f
′).
Therefore f is 13 -close to property P. In [45], a tester for monotonically increasing is given
whose query complexity and running time are both O( 1 · lgn).
Property testing can be viewed as an alternate type of an approximation problem. Such
an approximation might be just as good as an exact answer when the data is constantly
changing, or might be used as a fast sanity check to rule out very “bad” inputs before running
a slow but more exact algorithm. Property testers and the techniques behind them have been
applied to constructing approximate probabilistically checkable proof systems (approximate
PCPs; see [46] for more detailed results). Some property testers have been converted to
give sublinear time approximation algorithms, for example for the Max-Cut problem [57]. It
is interesting to note that there are examples of problems that are NP-hard to approximate
but for which the property testing version of the problem can be decided in constant time.
There have been plenty of methods and results in property testing and some related fields
of research. Yet, the study of sublinear algorithms is still very new, and much remains to be
understood about their scope.
2
2 研究目的
For a long time, to cope with intractable problems, people have referred to several other
related algorithmic methodologies, such as approximation algorithms, average-case analysis,
or purely heuristic methods. In other words, they were usually scared away and gave up
solving these intractable problem exactly. In fact, we usually find that most instances of an
NP-hard problem are easy to be solved. Thus ideally, we aim for statements such as “if some
parameter k is small in an intractable problem X, then X can be solved efficiently”. Now,
instead of being scared away, we consider the strategy, fixed-parameter algorithms, to solve
these problems exactly.
Definition 3 (parameterized problem). A parameterized problem is a language L ⊂ Σ∗ × Σ∗,
where Σ is a finite alphabet. The second component is called the parameter of the problem.
Generally speaking, a fixed-parameter algorithm is an algorithm that solves a parameter-
ized problem in f(k) ·nO(1) time for some computable function f depending solely on k. Such
algorithms then bring out a class of problems called fixed-parameter tractable. When random-
ization was considered, Fellows and Koblitz [50, 51] introduced the concept of randomized
fixed-parameter tractable.
The concept of property testing was introduced in Section 1. As we have mentioned, we
are interested in coping with problems with large data efficiently. We know now there are
two kinds of ways for solving hard problems. Hence the major objective of this project is
to delve into the relation between property testing and parameterized complexity by solving
these hard problems. Toward the objective, we foucs on parameterized complexity and prop-
erty testing on the following three properties and try to delve into the relationship between
parameterized complexity and property testing:
• quartet consistency;
• triplet compatibility;
• λ2,1-colorability.
By studying the parameterized complexity and property testing of the above three prop-
erties, we will then verify whether the following conjecture proposed by us is true by using
the experience of designing fixed-parameter algorithms and property testers.
Conjecture: For some property P, it has a property tester if and only
if there exists a randomized fixed-parameter algorithm that solves the
property P modification problem in time g() · nO(1) where n = |D|
and g(.) is a computable function depending solely on .
4
Goldwasser, and Ron [57]. They showed that many graph properties, such as k-colorability,
bipartiteness, having a large clique, having a large cut, etc., are easily testable under the
adjacency-matrix model. There are also non-graph properties discussed in the field of prop-
erty testing, such as testing monotonically nondecreasing of a sequence of numbers [45],
testing constraint satisfiability [6], testing whether a language is regular [4] (the results are
then extended to the testing on read-once branching programs [84] and read-twice branch-
ing programs [55], which are testable and non-testable respectively), etc. In [22], Batu et
al. considered testing whether two distributions of n elements are closed. For more detailed
results on testing combinatorial properties, especially the graph theoretical properties, see
the excellent surveys [7, 48, 56, 91] for further references.
In the rest of this subsection, we will summarize the recent results on testing graph
properties in both dense graphs and sparse graphs.
3.1.1 Testing graph properties in dense graphs
For dense graphs, the adjacency-matrix model is a commonly used model. In this model, a
property tester is allowed to make queries, where each query is to examine the value of (u, v)
in the adjacent matrix that whether vertices u, v are adjacent or not in the corresponding
graph. We say that an n-vertex graph is -far from satisfying a graph property P if more than
n2 edge additions or deletions should be performed on the graph to make the graph have
the property. In [57], graph properties that can be modeled as a certain partition problem,
such as k-colorability, having a large cut, having a large clique, etc., are shown to be testable.
In [2] it is shown that every first-order graph property without a quantifier alternation of type
‘∀∃’ is testable. Later there are further results on monotone graph properties and hereditary
graph properties. Monotone graph properties are the graph properties that are closed under
removal of vertices and edges, while hereditary graph properties are the graph properties
that are closed under removal of vertices. It is clear that a monotone graph property is
also hereditary. Monotone graph properties and hereditary graph properties are shown to
be testable respectively in [9] and [10] by using Szemere´di’s Regularity Lemma [98] and
its variant version proposed by Alon et al. [2]. However, by making use of the regularity
lemma, the upper bounds of query complexity are only guaranteed to be towers of towers of
exponents of height polynomial in 1/.
Some researchers attempted to seek for the possibilities of deriving an upper bound on the
query complexity polynomial in 1/, that is, to prove that certain testable graph properties
are easily testable. Goldreich et al. [57] showed that k-colorability (including bipartiteness,
of course) is easily testable. However, it is also shown in [57] that property testers for
some properties, such as having a large clique, having a large cut, etc., only have two-sided
error property testers, hence their easily testability is excluded. For the other results related
to easily testability, let us consider the properties PH and P∗H as follows. PH is a graph
property that a graph does not contain any subgraph isomorphic to H, while P∗H is a graph
property that a graph does not contain any induced subgraph isomorphic to H. Clearly, PH
6
and P∗H are monotone and hereditary respectively. When we consider undirected graphs,
PH is shown to be easily testable [1] if H is bipartite. As for directed graphs, Alon and
Shapira [5] showed that PH is testable for every fixed connected digraph H, and they also
gave a precise characterization of H’s such that PH is easily testable. The core of a digraph H
is the subgraph K ofHwith the smallest number of edges, for which there is a homomorphism
from H to K. Alon and Shapira [5] showed that if PH is easily testable if and only if H does
not have a 2-cycle or an oriented tree as its core. They also showed that for a digraph H,
deciding whether PH is testable, is NP-complete [5]. Let us go back to the discussion on
undirected graphs. In [8], Alon and Shapira gave a nearly complete characterizations of H’s
such that P∗H is easily testable, though it is still open that whether P∗P4 and P
∗
C4
are easily
testable (P4 is a path of length 3, i.e., a path of four vertices, while C4 is a cycle of length
four, i.e., a cycle of four vertices. To delve into the possibilities of certain graph properties
being easily testable is one of our main goals in this proposal. Table 3.1.1 summarizes the
results on testing graph properties in dense undirected graphs.
3.1.2 Testing graph properties in sparse graphs
For sparse graphs, the bounded-degree incidence-list model is the commonly used model. To
be concise, we abbreviate this model to bounded-degree graphs. In this model, a query is like
the question that “who is the ith neighbor of vertex v in the graph?” A property tester can
probe the incidence list of the vertices in the graph, where the maximum degree of the graph
is assumed to be bounded (say, at most d). When we consider bounded-degree graphs, we
say that an n-vertex graph G is -far from satisfying a graph property P if more than dn
edge ss additions and deletions should be performed to make G satisfy the property. Unlike
the adjacency-matrix model for dense graphs, there are only a few results on testing testing
graph properties in the bounded-degree graphs. Goldreich and Ron [62] presented property
testing in bounded-degree graphs for connectivity, k-edge-connectivity2, cycle-freeness, and
Eulerianess3, all with query complexity polynomial in 1/. They also established Ω(
√
n)
lower bounds on the query complexity of testing bipartiteness, cycle-freeness (for one-sided
error property testers), and expander properties. An Ω(n1/3) lower bound on the query
complexity for testing acyclicity in directed bounded-degree graphs is also obtained by Ben-
der and Ron [29]. For k-colorability, Bogdanov et al. [27] gave an Ω(n) lower bound on
the query complexity of testing 3-colorability. Table 3.1.2 summarizes the results on testing
graph properties in sparse undirected graphs.
A graph H is said to be a minor of a graph G if H can be obtained from G using a
sequence of vertex removals, edge removals and edge contractions. A graph G is said to be
H-minor free if every minor of G is not isomorphic to H. In [30], it is shown that for every
(finite) graph H, the property of being H-minor free is testable in the sparse model. In one
of the deepest results in graph theory, Robertson and Seymour proved the so called Graph-
2A graph is said to be k-edge-connected if there are k edge-disjoint paths between each pair of the graph.
3A graph G is Eulerian if there exists a path in G that traverses every edge in G exactly once.
8
Minor Theorem [96], which states that a graph satisfies P, there is a finite family of graphs
HP such that a graph satisfies P if and only if it is H-minor free for all H ∈ HP. Follows
this immediately, every minor-closed graph property is testable, however, the running time
of their property tester is O(22
2poly (1/ )
), and the analysis is quite complicated. Using the
locality lemma given in [86], Hassidim et al. [65] simplified the proof in [30] and provide a
better time bound on testing minor-closed properties, which is O(2poly(1/)).
It deserves to be noted that there have been some results on testing graph properties
in some special graph classes. Czumaj and Sohler [39] showed that any hereditary graph
property is testable if the input graph belongs to a non-expanding family of graphs.
3.2 Parameterized complexity
Downey and Fellows’ [42] work in 1999 is one of the best monographs for introducing
parameterized complexity. Later in 2006, Niedermeier [85] wrote an elaborate textbook
for introducing fixed-parameter algorithms and parameterized complexity. As to design and
analyze fixed-parameter algorithms, there have been plenty of useful techniques devised.
Here we summarized them as follows.
• data reduction and problem kernels [42]
• depth-bounded search trees [42, 82]
• dynamic programming [38, 101]
• tree-decompositions of graphs [94]
• color-coding [12] (also divide-and-color [79])
• integer linear programming [61]
• iterative compression [97]
• greedy localization [75]
• graph minor theory [40, 42, 44, 94]
• randomized algorithms [12, 20]
Basic definitions and facts are listed in the following paragraphs.
• Data reduction and problem kernels. To simplify matters, it is assumed here that the
parameter is a positive integer. Cases with more than one parameter being a number are
each handled analogously.
Definition 5. Let L be a parameterized problem, that is, L consists of input pairs (I, k),
where I is the problem instance and k is the parameter. Reduction to a problem kernel then
means to replace instance (I,k) by a “reduced” instance (I′,k′) (called problem kernel) such
that
k′ 6 k, |I′| 6 g(k)
for some function g only depending on k, and
(I, k) ∈ L iff (I′,k′) ∈ L.
10
where d := max{d1, . . . ,di}. Now, we describe a simple scheme how to solve recurrence
equations in the form of 1. Let us assume that recurrence 1 has a solution of the form
Tn = α
n for some real or even complex number α. Setting n := d and plugging this into
recurrence 1 we obtain
αd = αd−d1 + . . .+ αd−di , (3)
that is, α is a zero of the characteristic polynomial 2. In the same way, it is also not hard to
see the converse direction if α is zero of the characteristic polynomial then αn is a solution
of the recurrence 1. Moreover, with some more effort one can show that if α is a jth zero of
the characteristic polynomial 2 then nl · αn for all 0 6 l < j is a solution of recurrence 1.
This finally leads to the following result.
Proposition 2. A depth-bounded search tree with branching vector (d1, . . . ,di) and its root
labeled with parameter value n has size nO(1) · |α|n, where α is the zero of the corresponding
characteristic polynomial.
The base α of the exponentially growing function in Proposition 2 is called the branching
number. Obviously, the ordering of the entries of a branching vector plays no role in the
mathematical analysis; it may only reflect the order of the recursive calls corresponding to
each vector entry.
• Dynamic programming. In a sense, dynamic programming makes exhaustive search—
which guarantees finding optimal solutions—more efficient by avoiding the computation of
solutions of subproblems more than once. Dynamic programming is a promising solution
strategy when a problem exhibits the property of having optimal substructure, that is, an
optimal solution to the problem contains within its optimal solutions to subproblems. More-
over, dynamic programming uses this property in a bottom-up fashion. Two properties usually
make dynamic programming particularly feasible:
- independence
- overlapping subproblems
By independence of subproblems we mean that the solution of one subproblem does not
affect the solution of another subproblem of the same problem. By overlapping subproblems
we mean that the same problem occurs as as subproblem of different problems, hence giv-
ing an advantage over recursive algorithms where these solutions of subproblems would be
computed more than once.
Dynamic programming applies to every problem that observes the principle of optimality.
In a nutshell, this means that solutions to subproblems can be optimally extended only with
regard to the current “state” of this solution—it is to date. Finally, a brief word about a
variation of dynamic programming: memoization. The basic difference from dynamic pro-
gramming in the classical sense here is that the flow of control changes: the dynamic pro-
gramming is filled with in a top-down manner instead of a bottom-up one. We maintain a
12
Figure 1: A graph together with a tree decomposition of width 2.
Lemma 1. Given a width-k and n-nodes tree decomposition of a graph G, one can find a width-
k and O(n)-nodes nice tree decomposition of G in O(n) time.
Tree decompositions of graphs are connected to another central concept in algorithmic
graph theory: graph separators. Graph separators are vertex sets whose removal from the
graph separates the graph into two or more connected components.
Definition 8. Let G = (V ,E) be a connected graph. A subset S ⊆ V is called a separator of
G if the subgraph G[V \ S] is disconnected.
Actually, each bag of a tree decomposition forms a separator of the corresponding graph.
Here, however, we are more interested in the reverse direction, that is, constructing tree
decompositions from graph separators. The fundamental idea is to find small separators of
the graph and to merge tree decompositions of the resulting subgraphs using the separator
sets as “interfaces”.
For any given separator splitting a graph into different components, we obtain a simple
upper bound for the tree width of this graph which depends on the size of the separator and
the tree width of the resulting components.
Proposition 3. If a connected graph can be decomposed into components of treewidth of at most
t by means of a separator of size s, then the whole graph has treewidth of
• Color-coding. [12] Many graph problems are actually special versions of the Subgraph
Isomorphism Problem as follows.
Input: Two graphs G = (V ,E) and G′ = (V ′,E′).
Output: Determine whether there is a subgraph ofG that is isomorphic
to G′.
14
number of variables can be solved in linear time. More precisely, with improvements due to
Ravi Kannan [77], we have the following theorem. It refers to the so-called Integer Linear
Programming Feasibility Problem where one has to decide on the existence of (not necessar-
ily optimal) solutions fulfilling all the constraints given by linear inequalities over a set of
integer-valued variables.
Theorem 2 ([81]). The Integer Linear Programming Feasibility Problem can be solved with
O(p9p/2L) arithmetic operations in integers of O(p2pL) bits in size, where p is the number of
ILP variables and L is the number of bits in the input.
Note that this fixed-parameter result with respect to p also needs space exponential in
the parameter p.
• Iterative compression. Iterative compression is a very new technique introduced by
Reed et al. [97] published in 2004. It has already led to significant breakthroughs in show-
ing fixed-parameter tractability results. For instance, in this way the Graph Bipartization
Problem, that is, the task of finding a minimum set of vertices whose deletion transforms
a graph into a bipartite graph, has been shown fixed-parameter tractable with respect to
the number of deleted vertices. For years this has been a central open problem in parame-
terized complexity. Moreover, ongoing research indicates that the corresponding algorithm,
improved by performance tuning through algorithm engineering, is competitive in practice.
In a nutshell, iterative compression can be described as follows. The technique serves for
developing fixed-parameter algorithms for minimization problems parameterized by the size
of the solution set. The basic idea is that it is sufficient to give a fixed-parameter algorithm
which, given a size-(k+ 1) solution, either constructs a size-k solution or proves that there is
no size-k solution. For example, one can show that, given an n-vertex graph and a bipartiza-
tion vertex set with k+ 1 vertices, one can find in O(3k ·k ·m) time a bipartization vertex set
with k vertices, or decide that there is no such vertex bipartization. This is the compression
step, the workhorse of the whole algorithm. Based on this compression step, the algorithm it-
eratively considers for i = 1, 2, . . . ,n the induced subgraphs Gi of the input graph G = (V ,E)
where V := {v1, . . . , vn} and Gi = G[{v1, . . . , vi}]. Clearly, the optimal vertex bipartization for
G1 is the empty set. For i > 1, if Gi has no vertex bipartization of size k, then neither has
Gi+1; otherwise, let X denote a vertex bipartization of Gi with |X| 6 k. Then, X ∪ {vi+1} is a
vertex bipartization of Gi+1. If the set X∪ {vi+1} has k+ 1 vertices, the algorithm attempts to
“compress” it to a set of size k. The running time of the algorithm is clearly O(3k · k ·m · n).
Although the overall algorithmic strategy is very intuitive, a lot of technical work can lie in
showing—if at all possible—that the compression step can be done in O(f(k) · nO(1)) time.
• Greedy localization. Different to the previous strategy, iterative compression, greedy
localization is another new method to attack maximization problems. This strategy was first
introduced by Jia et al. [75] in 2004, and further applications appeared in succession [43,
16
vertices on each side. The following two theorems are very interesting and crucial in the
graph minor theory.
Theorem 3 (The Graph Minor Theorem [76]). Let F be a family of finite graphs closed under
taking minors. Then there exists a finite “obstruction set” of graphs OF = {H1,H2, . . . ,Ht} such
that
(G /∈ F) ≡ (∃1 6 i 6 t : Hi 6m G).
Theorem 4. [76] Given an n-vertex graph G and a fixed k-vertex graph H, we can decide in
f(k) · n3 time whether H 6m G. Here f is a function depending only on k but not on f.
• Randomized algorithms. To illustrate a randomized fixed-parameter algorithm, let us
consider the Feedback Vertex Set Problem first as follows.
Input: Two graphs G = (V ,E) and a nonnegative integer k.
Question: Is there a subset V ′ ⊆ V with k or fewer vertices such that
each cycle in G contains at least one vertex from V ′?
Thus removing the vertices in V ′ from G results in a forest.
A fairly simple and efficient randomized fixed-parameter algorithm for the Feedback Ver-
tex Set Problem was given by Beck et al. [20]. The key observations are as follows. First,
it is easy to eliminate vertices of degree at most two from the graph. Thus, assuming with-
out loss of generality a graph with minimum vertex degree three, the algorithm is based on
the easy-to-prove observation that if one picks an edge at random then there is a probabil-
ity of at least 1/2 that at least one of its two endpoints belongs to any feedback vertex set
searched for. This implies that with probability 1/4 a vertex chosen uniformly at random is
part of the desired feedback vertex set. This leads to a simple (Monte Carlo) randomized
algorithm that terminates with a feedback vertex set of size k with probability at least 1/4k.
Repeating the above algorithm independently c · 4k times results in an algorithm that after
O(c · 4k · n) steps finds a size-at-most-k feedback vertex set—if it exists—with probability at
least 1− (1− 1/4k)c·4k .
Related work on demonstrating randomized fixed-parameter tractability of problems is
summarized as follows. Fellow and Koblitz [50, 51] showed that the Bounded Factor Fac-
torization Problem, the Polynomially Smooth Number Problem, and the Small Prime Di-
visor Problem (all with a positive integer k being the parameter) are in randomized FPT.
Brightwell and Winkler [31, 32] showed that the Linear Extension Count Problem is in ran-
domized FPT, yet not known to be in FPT.
3.3 Quartet consistency
Let S be a set of taxa and |S| = n. An evolutionary tree T on S is an unrooted, leaf-labeled tree
such that the leaves of T are bijectively labeled by the taxa in S, and each internal node of
T has degree three. A quartet is a size 4 subset {a,b, c,d} of the taxon set S and the quartet
18
3.4 Triplet consistency
Here we focus on rooted and binary evolutionary trees. Let S be a set of n taxa. An rooted
evolutionary tree T on S is a rooted, leaf-labeled binary tree such that the leaves of T are
bijectively labeled by the taxa in S, and each internal node of T has exactly two children. We
denote by a <T b that the a node a is a descendant of a node b in T . The lowest common
ancestor of x and y in T , denoted by lcaT (x,y), is an ancestor of x and y such that none of
its proper descendants is an ancestor of x and y. We call a set of three taxa in S a triple. If
lcaT (a,b) <T lcaT (a, c), then we say that the triple {a,b, c} has a triplet (or triple topology)
((ab)c) induced by T , and, equivalently, we say T satisfies ((ab)c). For example, consider
the rooted evolutionary tree T in Fig. 4, the triples {a,b, c} and {c,d, e} have induced triplets
((ab)c) and ((cd)e) respectively. Namely, a triplet is a rooted evolutionary tree with three
leaves. A triple {a,b, c} has a triplet either ((ab)c), ((ac)b), or ((bc)a) induced by a rooted
evolutionary tree, as Fig. 5 shows. Note that by the rules representing a rooted evolutionary
tree, we regard ((ab)c), ((ba)c), (c(ab)), and (c(ba)) as the same triplet.
Figure 4: A rooted evolutionary tree.
Let Y be a set of triplets over S such that each triple has at most one triplet in Y. We
denote by YT the set of all induced triplets in a rooted evolutionary tree T . We say that Y is
tree-consistent if there exists a rooted evolutionary tree T such that Y ⊆ YT . We say that a
rooted evolutionary tree T satisfies Y if all the triplets in Y are satisfied by T .
Figure 5: Possible triplets of {a,b, c}.
Given a set ofm constraints of the form lcaT (a,b) <T lcaT (c,d), where a,b, c,d ∈ S, Aho
et al. [11] focused on the problem of determining whether there exists a rooted evolutionary
tree T (yet not necessarily binary) satisfying all of the input constraints. They showed that
20
λ2,1-coloring of graphs has been extensively studied during the past decade. These in-
clude bounds for general graphs [34, 80] as well as special graphs such as trees [34, 63],
chordal graphs [100], bipartite graphs [25], complete k-partite graphs [63], cographs [34],
k-almost trees [52], outerplanar and planar graphs [25, 54, 67, 83, 106], graphs of treewidth k,
permutation graphs and split graphs [25]; exact values for paths, cycles, hexagonal grids,
bidimensional grids, cellular grids, cartesian products and strong products of cycles, etc. [28,
63, 70, 71]. For a general graph G with maximum degree ∆, ∆ > 2, Griggs and Yeh [63]
proved that λ(G) 6 ∆2 + 2∆ and conjectured that λ(G) 6 ∆2 in general. This upper
bound was later improved to λ(G) 6 ∆2 + ∆ by Chang and Kuo [34]. In 2003, Kra´l and
Sˇkrekovski [80] improved this bound by showing λ(G) 6 ∆2 + ∆ − 1. In 2005, Kra´l [78]
considered the generalized version of the λ2,1-coloring problem and gave an exact algorithm
computing the bound for general graphs, although the running time is not polynomial. For
the class of chordal graphs, Sakai [100] showed that λ(G) 6 (∆ + 3)2/4 for any chordal
graph G. Table 3 is the summary of previous results on the λ2,1-coloring problem.
We say that a graph G is λ2,1-colorable if G has a λ2,1-coloring. Fiala et al. [52] showed
that for a general graph G, determine whether G is λ2,1-colorable is NP-complete for every
fixed value λ > 4. Junosza-Szaniawski and Rza¸z˙ewski presented an O∗(3.3323n) exact algo-
rithm for finding a λ2,1-coloring of a graph where the largest label λ is as least as possible.
22
4 研究方法
4.1 Efficient fixed-parameter algorithms for the MQI problem
During execution of this project, by working on the parameterized complexity of the MQI
problem, we have some surprising results. Instead of designing a randomized fixed-parameter
algorithm for the parameterized MQI problem, we devised deterministic ones:
• an O(3.0446kn+ n4) time fixed-parameter algorithm,
• an O(2.0162kn3 + n5) time fixed-parameter algorithm, and
• an O∗((1+ )k) time fixed-parameter algorithm
for the parameterized MQI problem. We briefly describe our approaches in the following
subsections.
4.1.1 Preliminaries
A quintet is a set of five taxa in S, while a sextet is a set of six taxa in S. The quintet topology
of a quintet {a,b, c,d, e} induced by an evolutionary tree T is the path structure connecting
a, b, c, d, and e in T . Similarly, we have the sextet topology of a sextet. Without loss of
generality, assume that we have [bc|de] induced by T and another taxon a, we have five
possible quintet topologies (Figure 6). Thus it is clear that there are 15 possible quintet
topologies for a quintet. Two taxa a,b are siblings on an evolutionary tree T if a and b are
both adjacent to the same internal vertex in T . Here we consider the sextet topologies of
the sextet {a,b,w, x,y, z} where a,b are siblings. It is clear that there are 15 possible sextet
topologies with siblings a,b for a sextet {a,b,w, x,y, z} (Figure 7).
Figure 6: Five possible topologies for the quintet {a,b, c,d, e} when [ab|cd] is given.
Given a set of quartet topologiesQ over the taxon set S, we say that a quintet {a,b, c,d, e}
⊆ S is resolved if there exists an evolutionary tree T ′, on which a,b, c,d, e are leaves, such
that all the quartet topologies induced by T ′ are in Q. Otherwise, we say that {a,b, c,d, e}
is unresolved. Similarly, we say that a sextet {a,b,w, x,y, z} ⊆ S is {a,b}-resolved if there
exists an evolutionary tree T ′′, on which a,b,w, x,y, z are leaves and a,b are siblings, such
that all quartet topologies induced by T ′′ are in Q. Otherwise, we say that {a,b,w, x,y, z} is
{a,b}-unresolved.
Theorem1 can be easily obtained by Bandelt and Dress’ work [21], and Theorem 2 can
be derived in Gramm and Niedermeier’s work in [60].
24
q = {a,b, c,d, e} ∈ Cf arbitrarily and then tries to make q resolved by the procedure update
according to all the possible 15 quintet topologies of q. The procedure update changes quar-
tet topologies according to the quartet topologies which µ stands for, and updates the set Cf
and the parameter k to be C ′f and k
′ respectively.
The algorithm works as a depth-bounded search tree. Each tree node has 15 branches
and each branch corresponds to a quintet topology. Since there are 243 possible topology
vectors of a quintet but 15 of them are in V, we have 228 possible branching vectors and the
corresponding branching numbers as well. It can be derived that the branching number in
the worst case is between 3.0445 and 3.0446. Thus the size of the search tree is O(3.0446k).
Then we obtain the following theorem by careful analysis.
Theorem 3. There exists anO(3.0446kn+n4) fixed-parameter algorithm for the parameterized
minimum quartet inconsistency problem.
4.1.3 An O(2.0162kn3 + n5) Algorithm
We define the two-siblings-determined minimum quartet inconsistency problem (2SDMQI) as
follows. Given a complete quartet topology set Q over a taxon set S, a parameter k and
two taxa a,b ∈ S as the input, determine whether there exists an evolutionary tree T on
which a and b are siblings such that QT differs from Q in at most k quartet topologies. For
this problem, we devised a fixed-parameter algorithm FPA-2SDMQI, which works as follows.
First, for every u, v ∈ S \ {a,b} such that [ab|uv] /∈ Q, we change the quartet topology of
{a,b,u, v} to be [ab|uv] and decrease k by 1. Second, we build two lists Ca and V2, where
Ca is a list of unresolved quintets containing a while V2 is a list of {a,b}-reduced topologies
vectors of possible sextet topologies on which a,b are siblings. Then the algorithm calls a
recursive subroutine to resolve all {a,b}-unresolved sextets by changing at most k quartet
topologies. In each recursion of this subroutine, we arbitrarily select an unresolved quintet q
and try to make q ∪ {b} be {a,b}-resolved by the procedure update2 according to all possible
15 sextet topologies of q∪ {b} having a,b as siblings. The procedure update2 updates the set
of unresolved quintets Ca and the parameter k.
By careful analysis, we obtain that the size of the search tree is O(2.0162k). Hence we
have anO(2.0162kn+n4) fixed-parameter algorithm for the 2SDMQI problem. Besides, since
every evolutionary tree with |S| > 4 leaves has at least two pairs of taxa which are siblings,
we have the following theorem.
Theorem 4. There exists an O(2.0162kn3 + n5) fixed-parameter algorithm for the parameter-
ized minimum quartet inconsistency problem.
4.1.4 An O∗((1+ )k) Algorithm
Let T denote an evolutionary tree on S such that QT differs from Q in at most k quartet
topologies. For an integer m > 2, we say that taxa a1, . . . ,am are adjacent if there exists
an edge e = (w, v) on T such that cutting e will produce a bipartition ({a1, . . . ,am},S \
26
those in Q∗ are called the quartet errors of Q, and we call the number of such quartet errors
the error number of Q for the sake of conciseness.
Let us recall the general concepts of property testing by considering functions as follows.
Let F be the set of all functions with the same domain D. Let P be a fixed property of func-
tions in F, which can be viewed as a subset of F. For two functions f,g ∈ F, let δ(f,g) denote
the fraction of the domain elements in D where f and g have different values. Obviously the
range of δ is [0, 1]. Then for a function f ∈ F, we define that ∆(f,P) = ming∈P δ(f,g). We say
that f satisfies the property P if ∆(f,P) = 0. We say f is -far from satisfying P if ∆(f,P) > ,
otherwise f is said to be -close to satisfying P. The following is the general definition for a
property tester.
Definition 10 (Property testers [57]). Given a function f ∈ F and a parameter 0 <  6 1 as
the input, a property tester for P is an algorithmM such that the following conditions hold:
1. M makes o(|D|) queries;
2. M returns “yes” with probability at least 2/3 if f ∈ P;
3. M returns “no” with probability at least 2/3 if ∆(f,P) > .
Moreover, we say that M is a one-sided-error property tester if it returns “yes” whenever f
satisfies P with probability 1.
Throughout the following discussions, we assume thatQ is complete and |S| = n > 5. We
assume that an array of
(
n
4
)
entries is used for storing the topology for each quartet over S
such that a query for getting the topology of a quartet can be done in constant time. We
say that Q satisfies quartet consistency if Q is tree-like, that is, ∆(Q,Pq) = 0. We say that
Q is -far from satisfying quartet consistency if the error number of Q is at least 
(
n
4
)
, that
is, ∆(Q,Pq) > . For testing quartet consistency, a query means to examine the topology
of a quartet in Q, and we assume that it can be done in constant time. Similar to the
previous content introducing general property testers, we define a property tester for quartet
consistency as follows.
Definition 11. Given a complete set of quartet topologies Q. A property tester for quartet
consistency is an algorithmM making o(n4) queries, such that
i. M answers “yes” with probability at least 2/3 if ∆(Q,Pq) = 0 (i.e., Q satisfies quartet
consistency);
ii. M answers “no” with probability at least 2/3 if ∆(Q,Pq) >  (i.e., the error number
of Q is at least 
(
n
4
)
).
Moreover, we say thatM is a one-sided-error property tester for quartet consistency if it returns
“yes” with probability 1 whenever Q satisfies quartet consistency.
4.2.1 Existence of a complete set of quartet topologies which is at least 0.04-far
from being tree-like
Here we show that there exists a complete set of quartet topologies that is at least 0.04-far
from being tree-like, that is, its error number is at least 0.04
(
n
4
)
. The sketch of the proof
28
Theorem 9. There exists a set of quartet topologies Q which is at least 0.04-far from being
tree-like.
Proof. Let Q∗ be a tree-like set of quartet topologies over the taxon set S. We know that
there exists a set of quintets U over S of size at least 0.04
(
n
4
)
such that every two quintets
in U do not share any quartet (by Lemma 8). Then, for each quintet in U, we arbitrarily
pick one of its subset quartets and change its corresponding topology in Q∗ to one of the
other two possible topologies arbitrarily. LetQ denote the resulting set of quartet topologies.
Now, every quintet in U with respect to Q has exactly one subset quartet whose topology is
changed. Since one has to change at least two quartet topologies over a resolved quintet to
make this quintet resolved again (by Fact 1), every quintet in U is unresolved with respect
to Q. Furthermore, for each of these unresolved quintets in U, we have to change at least
one quartet topology of its subset quartets to make it resolved (otherwise, the unresolved
quintet stays the same). Hence at least |U| quartet topologies in Q have to be changed to
make the unresolved quintets in U with respect to Q resolved. Therefore, we obtain that the
error number of Q is at least |U| > 0.04
(
n
4
)
, hence Q is at least 0.04-far from being tree-like,
as claimed by the theorem.
2
4.2.2 An O(n/) property tester for tree-likeness of quartet topologies
Our property tester for tree-likeness of quartet topologies is presented in Table 4. Theo-
rem 10, which is mentioned in [37] and was implicitly proved in Bandelt and Dress’ re-
sult [21], is the building block of our property tester.
1. Pick an arbitrary taxon ` ∈ S, and then repeat (a) and (b) for 72

n3 times.
(a) Pick four taxa s1, s2, s3, s4 ∈ S \ {`} uniformly at random.
(b) If the quintet {s1, s2, s3, s4, `} is not resolved, then return “no”.
2. Return “yes”.
Table 4: A property tester for tree-likeness of quartet topologies.
Theorem 10 ([21]). Given a set of taxa S, a complete set of quartet topologies Q over S, and a
fixed taxon ` ∈ S, Q is tree-like if and only if every quintet containing ` is resolved.
Remarks. It follows from Theorem 10 that we can determine whether Q is tree-like by
examining quintets with respect to Q. If Q is not tree-like (i.e., the error number of Q is at
least one), by Theorem 10, we know that for any fixed taxon ` ∈ S, there exists an unresolved
quintet containing `. Hence it is clear that the number of unresolved quintets with respect
to Q is at least Ω(n), which yields an O(n4) deterministic algorithm to see if Q is tree-like.
Intuitively, we expect more unresolved quintets when the error number of Q gets larger. In
particular, if the error number of Q is at least cn4 for some constant c, we expect to have
30
The following theorem shows that the algorithm given in Table 4 is a non-adaptive prop-
erty tester which is of one-sided error and makes at most O(n3/) queries.
Theorem 12. The algorithm in Table 4 is a non-adaptive one-sided-error property tester for
tree-likeness of quartet topologies, which makes at most O(n3/) queries.
Proof. If Q is tree-like, then the algorithm will never find an unresolved quintet, it will
always return “yes”, hence it is of one-sided-error. As for the case that Q is -far from being
tree-like, consider an arbitrarily fixed taxon ` ∈ S. By Theorem 11, the number of unresolved
quintets containing ` with respect to Q is more than n/36. In each iteration of the loop of
the algorithm, the probability of finding an unresolved quintet is at least (n/36)/
(
n−1
4
)
>
(/36)/n3. For simplicity, let α denote (/36)/n3. Once an unresolved quintet is found
during these 2/α iterations, the algorithm returns “no”, otherwise, it returns “yes”, with
probability at most (1 − α)2/α 6 e−2 < 1/3, where we use the fact that (1 − t)−1/t > e
for any t > 0 (Note that e−1 = limt→0(1 − t)1/t). Moreover, checking whether a quintet is
resolved or not requires at most five queries, thus at most O(n3/) queries are made by the
algorithm. Since the algorithm makes each query without knowing the results of previous
ones, it is clearly non-adaptive. The theorem is proved. 2
4.2.3 Concluding remarks
We propose a one-sided error property tester for tree-likeness of quartet topologies, which is
non-adaptive and utilizes at most O(n3/) queries. However, for the moment, whether the
query complexity of testing tree-likeness of quartet topologies can be proved to be indepen-
dent of n still remains open.
Figure 9: The tree structure with the quartet topology [ab|cd]. T1, T2, T3, T4, and T5 are subtrees.
One might be curious about whether our results can be extended to incomplete sets of
quartet topologies. Unfortunately, it seems to be impossible since Theorem 10 is not true
when the set of quartet topologies Q is incomplete. Let us say a quintet is partially resolved
if the set of quartet topologies over this quintet in Q is tree-consistent (but not necessarily
tree-like). The following example illustrates that there exists an incomplete set of quartet
topologies Q, such that Q is not tree-consistent even when each quintet is partially resolved
with respect to Q.
32
over S = {a,b, c,d, e, f}. There are only two quartets which do not have topologies in Q
(i.e., {a,b, c,d} and {a,d, e, f}). We observe that Q is “dense” in this case. To be precise, for
each quintet, at least four of its subset quartets have topologies in Q. Similar to the previ-
ous example, we observe from Fig. 12 that each quintet is partially resolved. However, Q
is not tree-consistent due to the following observation. Consider the topology of the quintet
{a,b, c,d, e}. The evolutionary tree with the quartet topology [ab|ce] is depicted in Fig. 11.
Since [ab|de], [ad|ce] ∈ Q, the taxon d has to be in T3. Similarly, we derive that f has to be
in T2 since [ae|bf] ∈ Q. Then we obtain that the induced topology of the quartet {a, c,d, f} on
the evolutionary tree can only be [af|cd], which contradicts the assumption that [ac|df] ∈ Q.
Figure 12: A set of thirteen quartet topologies Q, where only two quartets {a,b, c,d} and {a,d, e, f} do
not have topologies in Q. Each quintet over S = {a,b, c,d, e, f} is partially resolved.
By the above two examples, we conclude that when the input set of quartet topologies
is not complete, “local consistency” (i.e., the property that each quintet is partially resolved)
does not guarantee “global consistency” (i.e., the property that Q is tree-consistent).
34
Computing Systems 這期刊所接受發表。
大致而言, 本計畫的研究內容與原計畫相符程度甚高, 研究成果深具學術價值, 計有一篇國際研討會
論文以及兩篇國際期刊論文的著作發表。 雖然因問題困難而時間有限,我們未能完成計畫的所有預期目標,
但是在計畫執行期間,我們藉由與國外學者的合作與討論,除了有論文發表以外,我們得到許多與國外學者
合作的寶貴經驗, 同時也掌握了目前世界上理論計算機科學界的研究趨勢, 使我們未來在相關研究問題上,
能夠更有信心解決相關的問題。 此外, 在本計畫執行期間, 參與計畫的博士班學生林莊傑赴 IWPEC 會議
負責報告研究成果, 達到了訓練其在國際研討會上演講能力的目的, 對其日後的學術研究有相當大的助益。
7 參考文獻
[1] N. Alon: Testing subgraphs in large graphs. Random Structures Algorithms 21 (2002)
359–370.
[2] N. Alon, E. Fischer, M. Krivelevich, and M. Szegedy: Efficient testing of large graphs.
Combinatorica 20 (2000) 451–476.
[3] N. Alon and M. Krivelevich: Testing k-colorability. SIAM J. Discrete Math. 15 (2002)
211–227.
[4] N. Alon, M. Krivelevich, I. Newman, and M. Szegedy: Regular languages are testable
with a constant number of queries. SIAM J. Comput. 30 (2001) 1842–1862.
[5] N. Alon and A. Shapira: Testing subgraphs in directed graphs. In Proceedings of the
35th Annual Symposium on Theory of Computing (STOC’03), San Diego, California, pp.
700-709. Also: J. Comput. System Sci. 69 (2004) 354–382.
[6] N. Alon and A. Shapira: Testing satisfiability. J. Algorithms 47 (2003) 87–103.
[7] N. Alon and A. Shapira: Homomorphisms in graph property testing - A survey. Elec-
tronic Colloquium on Computational Complexity (ECCC 2005). Report No. 85.
[8] N. Alon and A. Shapira: A characterization of easily testable induced subgraphs. Com-
bin. Probab. Comput. 15 (2006) 791–805.
[9] N. Alon and A. Shapira: Every monotone graph property is testable. SIAM J. Comput.
38 (2008) 505–522.
[10] N. Alon and A. Shapira: A characterization of the (natural) graph properties testable
with one-sided error. SIAM J. Comput. 37 (2008) 1703–1727.
[11] A. V. Aho, Y. Sagiv, T. G. Szymanski, and J. D. Ullman: Inferring a tree from lowest
common ancestors with an application to the optimization of relational expressions.
SIAM J. Comput. 10 (1981) 405–421.
[12] N. Alon, R. Yuster, and U. Zwick: Color-coding. J. ACM 42 (1995) 844–856.
36
[26] M. Blum, M. Luby, and R. Rubinfeld: Self-testing/correcting with applications to nu-
merical problems. J. Comput. System Sci. 47 (1993) 549–595.
[27] A. Bogdanov, K. Obata, and L. Trevisan: A lower bound for testing 3-colorability in
bounded-degree graphs. In Proceedings of the 43rd IEEE Symposium on Foundations of
Computer Science (FOCS’02), pp. 93–102.
[28] A. A. Bertossi, C. Pinotti, and R. B. Tan: L(2, 1)-labeling and L(2, 1, 1)-labeling of graphs
with application to channel assignment in wireless networks. In Proceedings of the 4th
International Workshop on Discrete Algorithms and Methods for Mobile Computing and
Communications (DIAL-M 2000), Boston, August 2000.
[29] M. Bender and D. Ron: Testing properties of directed graphs: acyclicity and connectiv-
ity. Random Structures Algorithms 20 (2002) 184–205.
[30] I. Benjamini, O. Schramm, and A. Shapira: Every minor-closed property of sparse
graphs is testable. In Proceedings of the 40th Annual ACM Symposium on Theory of
Computing (STOC 2008), pp. 393–402. See also Adv. Math. 223 (2010) 2200–2218.
[31] G. Brightwell and D. Winkler: Counting linear extensions is #P -complete. In Pro-
ceedings of the 23rd Annual ACM Symposium on Theory of Computing (STOC 1991),
pp. 175–181.
[32] G. Brightwell and D. Winkler: Counting linear extensions. Order 8 (1992) 225–242.
[33] B. Cho: From quartets to phylogenetic trees. In Proceedings of the 25th Conference on
Current Trends in Theory and Practice of Informatics (SOFSEM 1998), Lecture Notes in
Comput. Sci., Vol. 1521, Springer, Berlin, 1998, pp. 36–53.
[34] G. J. Chang and D. Kuo: The L(2, 1)-labeling problem on graphs. SIAM J. Discrete Math.
9 (1996) 309–316.
[35] J. Chen, I. A. Kanj, and G. Xia: Improved Parameterized Upper Bounds for Vertex Cover.
Theoret. Comput. Sci. 411 (2010) 3736–3756.
[36] G. J. Chang and S. C. Liaw: The L(2, 1)-labeling problem on ditrees. Ars Combin. 66
(2003) 23–31.
[37] Maw-Shang Chang (張貿翔), Chuang-Chieh Lin (林莊傑), and Peter Rossmanith: New
fixed-parameter algorithms for the minimum quartet inconsistency problem. Theory of
Computing Systems 47 (2010) 342–368.
[38] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein: Introduction to Algorithms.
MIT Press, 2001.
[39] A. Czumaj, A. Shapira, and C. Sohler: Testing hereditary properties of nonexpanding
bounded-degree graphs. SIAM J. Comput. 38 (2009) 2499–2510.
38
[52] J. Fiala, T. Kloks, and J. Kratochv´ıl: Fixed-parameter complexity of λ-labelings. Discrete
Appl. Math. 113 (2001) 59–72.
[53] E. Fischer and I. Newman: Testing versus estimation of graph properties. SIAM J. Com-
put. 37 (2007) 482–501.
[54] D. A. Fotakis, S. E. Nikoletseas, V. G. Papadopoulou and P. G. Spirakis: NP-completeness
results and efficient approximations for radiocoloring in planar graphs. In Proceed-
ings 25th International Symposium on the Mathematical Foundations of Computer Sci-
ence (MFCS 2000), Lecture Notes in Comput. Sci., Vol. 1893, Springer Verlag, 2000,
pp. 363–372.
[55] E. Fischer, I. Newman, and J. Sgall: Functions that have read-twice constant width
branching programs are not necessarily testable. Random Structures Algorithms 24
(2004) 175–193.
[56] O. Goldreich: “Combinatorial property testing (a survey),” Randomization methods in
algorithm design (Eds., P. Pardalos, S. Rajaseekaran, and J. Rolin), DIMACS Series in
Discrete Mathematics and Theoretical Computer Science, AMS, Providence, Vol. 43,
45–59. 1998.
[57] O. Goldreich, S. Goldwasser, and D. Ron: Property testing and its connection to learning
and approximation. J. ACM 45 (1998) 653–750.
[58] L. Ga¸sieniec, J. Jansson, A. Lingas, and A. O¨stlin: On the complexity of constructing
evolutionary trees. J. Comb. Optim. 3 (1999) 183–197.
[59] S. Guillemot and M. Mnich: Kernel and fast algorithm for dense triplet inconsistency.
In Proceedings of the 7th Annual Conference on Theory and Applications of Model of
Computation (TAMC 2010).
[60] J. Gramm and R. Niedermeier: A fixed-parameter algorithm for minimum quartet in-
consistency. J. Comput. System Sci. 67 (2003) 723–741.
[61] J. Gramm, R. Niedermeier, and P. Rossmanith: Fixed-parameter algorithms for Closest
String and related problems. Algorithmica 37 (2003) 25–42.
[62] O. Goldreich and D. Ron: Property Testing in Bounded Degree Graphs. Algorithmica 32
(2002) 302–343.
[63] J. R. Griggs and R. K. Yeh: Labeling graphs with a condition at distance 2. SIAM J.
Discrete Math. 5 (1992) 586–595.
[64] W. K. Hale: Frequency assignment: theory and applications. In Proceedings of the IEEE,
Vol. 68, 1980, pp. 1497–1514.
[65] A. Hassidim, J. A. Kelner, H. N. Nguyen, and K. Onak: Local graph partitions for approx-
40
[79] J. Kneis, D. Mo¨lle, Stefan Richter, and P. Rossmanith: Divide-and-Color. In Proceedings
of the 32nd International Workshop on Graph-Theoretic Concepts in Computer Science
(WG 2006), Lecture Notes in Comput. Sci., Vol. 4271, Springer-Verlag, 2006, pp. 58–
67.
[80] D. Kra´l and R. Sˇkrekovski: A theorem about the channel assignment problem. SIAM J.
Discrete Math. 16 (2003) 426–437.
[81] H. W. Lenstra: Integer programming with a fixed number of variables. Math. Oper. Res.
8 (1983) 538–548.
[82] K. Mehlhorm: Data Structures and Algorithms, Volume 2: NP-Completeness and Graph
Algorithms. EATCS Monographs on Theoretical Computer Science, Springer-Verlag.
[83] M. Molloy and M. R. Salavatipour: A bound on the chromatic number of the square of
a plannar graph. J. Combin. Theory Ser. B 94 (2005) 189–213.
[84] I. Newman: Testing of functions that have small width branching programs. In Pro-
ceedings of the 41st IEEE Symposium on Foundations of Computer Science (FOCS 2000),
2000, pp. 251–258.
[85] R. Niedermeier: Invitation to Fixed-Parameter Algorithms. Oxford University Press,
2006.
[86] H. N. Nguyen and K. Onak: Constant-time approximation algorithms via local improve-
ments. Proceedings of the 49th Annual IEEE Symposium on Foundations of Computer
Science (FOCS 2008), pp. 327–336.
[87] M. P. Ng and N. C.Wormald: Reconstruction of rooted trees from subtrees. Discrete
Appl. Math. 69 (1996) 19–31.
[88] M. Parnas and D. Ron: Testing the diameter of graphs. Random Struct. Alg. 20 (2002)
165–183.
[89] M. Parnas, D. Ron and R. Rubinfeld: Tolerant property testing and distance approxima-
tion, J. Comput. System Sci. 72 (2006) 1012–1042.
[90] E. Prieto, and C. Sloper: Looking at the stars. In Proceedings of the 1st International
Workshop on Parameterized and Exact Computation (IWPEC 2004), Lecture Notes in
Comput. Sci., Vol. 3162, Springer-Verlag, 2004, pp. 138–148.
[91] D. Ron: Property testing, in Handbook of Randomized Computing, Vol. II. S. Ra-
jasekaran, P. M. Pardalos, J. H. Reif, and J. D. P. Rolim, eds., Kluwer Academic Publish-
ers, Dordrecht, The Netherlands, 2001, 597–649.
[92] V. Ro¨dl and R. Duke: On graphs with small subgraphs of large chromatic number.
Graphs Combin. 1 (1985) 91–96.
42
[108] G. Wu, J-H. You, and G. Lin: A polynomial time algorithm for the minimum quartet
inconsistency problem with O(n) quartet errors. Inform. Process. Lett. 100 (2006) 167–
171.
[109] Y. Yoshida nad H. Ito: Property testing on k-vertex-connectivity of graphs. In Pro-
ceedings of the 35th International Colloquium on Automata, Languages and Program-
ming (ICALP 2008). Lecture Notes in Comput. Sci., Vol. 5125, Springer-Verlag, 2008,
pp. 539–550.
44
得底下的聽眾大多能吸收我的演講內容。 另外值得一提的是,我的投影片是使用 Latex Beamer所製作而
成的 pdf檔,播放上非常順利,沒有任何問題。 這次的會議當中,許多演講者使用Microsoft Powerpoint
製作的投影片, 經常會有相容性的問題, 造成播放效果不如預期, 或是根本無法播放, 必須更換成自己的
notebook, 費了一番功夫之後才能順利進行演講。 希望透過我的這個經驗, 得以給國內的學者準備演講或
製作投影片的前車之鑑。
8.1.2 出席 IWOCA 2010 會議心得報告
46
2生，頓時讓我不覺得有離家萬里的感覺。
大會總共接受三十一篇口頭發表的論文，八篇以 poster 形式發表的精簡
論文(收錄於會議論文集)，以及五篇 poster 論文。三天的論文發表期間，大會
另外安排了四場邀請演講 (invited talks) 都很精彩。
在口頭論文發表以及邀請演講的空檔，不少學者、學生來觀看我的 poster
並進行討論，頗有收穫。會議期間，認識一位正在 King’s College London 訪問
的日本 Kysuhu university 的助理教授 小野 廣隆 (Hirotaka Ono)，他研究的
領域與我很相近，研究成果很好，我口頭邀請他訪問我們學校。另外認識一位
由泰國以及一位由越南赴日留學的兩位日本學生，經過與他們交談，發覺日本
教育界以獎學金吸引不少東南亞的學子赴日留學。
開完會的隔天，即搭機返國。
二、與會心得
感謝國科會以及學校的經費贊助，讓我可以參加這次學術會議。這是個與
我的研究領域相當契合的學術會議，除了發表論文增加能見度外，透過與與會
者的交流讓我更了解這個領域的發展現況，也獲得一些研究的新方向，對我的
研究很有幫助。
除了專業上的收穫之外，我也有一些對於歐美學術界的觀察。最近幾年參
加歐、美舉辦的學術會議之後，發覺歐美學者在研究上交流非常密切。相同領
域的學者經常合作發表論文。與國內大多由教授帶領自己學生做研究的情形大
異其趣。這次與參加會議的一位法國學者交談，才知道他並沒有指導任何碩士
生或博士生，但是他還是每年可以發表一兩篇期刊論文以及兩三篇會議論文，
這些論文成果，都是透過與同事甚至英、美、澳洲、加拿大等同行的合作的成
果。研究很不容易有成果的，透過交流集多數人的智慧可以事半功倍，這是我
們必須學習的，也由於如此我們才有可能國際化，才能提升我們的競爭力。國
內學者雖多，但是相較於全世界的學者仍屬少數。由於研究領域分工精細，在
國內不容易找到相同領域的學者一起合作，這時候惟有透過國際交流，才比較
有機會找到志同道合的研究夥伴一起合作。假如我們不積極進行國際交流，我
們的學術研究成果很難在國際上展露頭角。歐美學術界應該已經看出這點，因
此他們學術交流經費非常充裕。根據我們留英的學生的說法，他的指導教授一
年出國開學術會議進行交流的旅費預算幾乎沒有上限，今年他也已經隨著指導
教授出國開學術會議兩、三次以上，他的指導教授一年出國開會七、八次以上。
另外我也發覺歐美學術界熱中舉辦學術會議。舉辦學術會議若可以吸引全世界
8.2 發表著作
國際研討會論文
1. Maw-Shang Chang (張貿翔), Chuang-Chieh Lin (林莊傑), and Peter Rossmanith: New
fixed-parameter algorithms for the minimum quartet inconsistency problem. In Pro-
ceedings of the 3rd International Workshop on Exact and Parameterized Computation
(IWPEC 2008, Victoria B.C., Canada; 14–16 May), Lecture Notes in Computer Science,
Vol. 5018, Springer-Verlag, pp. 66–77.
2. Maw-Shang Chang (張貿翔) and Ling-Ju Hung (洪綾珠): Recognition of Probe Ptolemaic
Graphs. To appear in Proceedings of the 21st International Workshop on Combinatorial
Algorithms (IWOCA 2010).
期刊論文
1. Maw-Shang Chang (張貿翔), Chuang-Chieh Lin (林莊傑), and Peter Rossmanith: New
fixed-parameter algorithms for the minimum quartet inconsistency problem. Theory of
Computing Systems 47 (2010) 342–368.
2. Maw-Shang Chang (張貿翔), Chuang-Chieh Lin (林莊傑), and Peter Rossmanith: A prop-
erty tester for tree-likeness of quartet topologies. Theory of Computing Systems. Ac-
cepted for publication. Online first. DOI: 10.1007/s00224-010-9276-5
49
New Fixed-Parameter Algorithms 67
[bc|de] induced by T and another taxon a, then there are ﬁve possible quintet
topologies since there are ﬁve positions for inserting a into the tree structure of
[bc|de] (see Fig. 3 for an illustration).
Fig. 1. The quartet topology of {a, b, c, d} in-
duced by evolutionary tree T
There are 15 possible quintet
topologies for a quintet {a, b, c,
d, e}. A quintet has ﬁve quartets,
and hence a quintet topology has
5 diﬀerent induced quartet topolo-
gies. Two taxa a, b are siblings on
an evolutionary tree T if a and b
are both adjacent to the same in-
ternal vertex in T . Here we con-
sider sextet topologies of the sextet
{a, b, w, x, y, z} where a, b are sib-
lings. It is clear that there are 15 possible sextet topologies with siblings a, b
(refer to Fig. 4).
Fig. 2. Three topologies for the
quartet {a, b, c, d}
Given a set of quartet topologies Q over
the taxon set S, we say that a quintet
{a, b, c, d, e} ⊆ S is resolved if there exists
an evolutionary tree T ′, on which a, b, c, d, e
are leaves, such that all the quartet topolo-
gies induced by T ′ are in Q. Otherwise, we
say that {a, b, c, d, e} is unresolved. Similarly,
we say that a sextet {a, b, w, x, y, z} ⊆ S is
{a, b}-resolved if there exists an evolutionary
tree T ′′, on which a, b, w, x, y, z are leaves and a, b are siblings, such that all quar-
tet topologies induced by T ′′ are in Q. Otherwise, we say that {a, b, w, x, y, z} is
{a, b}-unresolved.
Fig. 3. Five possible topologies for the
quintet {a, b, c, d, e} when [ab|cd] is given
Let QT be the set of quartet topolo-
gies induced by T . If there exists an
evolutionary tree T such that Q ⊆ QT ,
we say that Q is tree-consistent [2]
(with T ) or T satisfies Q. If there exists
a tree T such that Q = QT , we say that
Q is tree-like [2]. Q is called complete
if Q contains exactly one topology for
every quartet, otherwise, incomplete. For two complete sets of quartet topologies
Q and Q∗ where Q∗ is tree-like but Q is not, the quartet errors of Q with respect
to Q∗ are the quartet topologies in Q that diﬀer from those in Q∗. We denote
the number of quartet errors of Q with respect to Q∗ by Δ(Q,Q∗). The number
of quartet errors of Q is deﬁned to be min{Δ(Q,Q∗) : Q∗ is tree-like}.
1.1 Related Work
The Quartet Compatibility Problem (QCP) is to determine if there exists an evo-
lutionary tree T on S satisfying all quartet topologies Q. The QCP problem can
New Fixed-Parameter Algorithms 69
ﬁxed-parameter algorithm for the parameterized MQI problem. In Sect. 4, we will
introduce the two-siblings-determined minimum quartet inconsistency problem
(2SDMQI), then an O(2.0162kn+n4) ﬁxed-parameter algorithm for this problem
will be given. At the end of this section, we will present an O(2.0162kn3 + n5)
ﬁxed-parameter algorithm for the parameterized MQI problem by solving the
2SDMQI problem. Finally in Sect. 5, we will present an O∗((1 + )k) ﬁxed-
parameter algorithm for the parameterized MQI problem, where  > 0 is an
arbitrarily small constant. For the sake of brevity, many proofs are omitted in
this extended abstract, but can be found in the full paper.
2 Preliminaries
Recall that S is a set of taxa and |S| = n. Let Q denote the complete set
of quartet topologies over S. The set Q is of size
(
n
4
)
. We say that a set of
quartet topologies Q′ over S involves a taxon f if there exists at least one quartet
topology t = [v1v2|v3v4] ∈ Q′, where v1, v2, v3, v4 ∈ S, such that f = vi for some
i ∈ {1, 2, 3, 4}. If a set of quartet topologies is not tree-consistent, we say that
it has a conflict. We say that a set of three topologies has a local conflict if it is
not tree-consistent.
Lemma 1. [8] A set of three quartet topologies involving more than five taxa is
tree-consistent.
Theorem 1. [8] Given a set of taxa S and a complete set of quartet topologies
Q over S, and some taxon f ∈ S, then Q is tree-like if and only if every set of
three quartet topologies in Q that involves f has no local conflict.
Lemma 2. Assume that q ⊆ S is a quintet such that f ∈ q and let Qq ⊆ Q
denote the set of quartet topologies of quartets in q. Then q is resolved if and
only if every set of three quartet topologies in Qq has no local conflict.
Corollary 1. Given a set of taxa S, a complete set of quartet topologies Q
over S, and some taxon f ∈ S, then Q is tree-like if and only if every quintet
containing f is resolved.
There are ten sets of three quartets with respect to a quintet {a, b, c, d, e}. Check-
ing whether a set of three quartet topologies has a local conﬂict requires only
constant time [8]. It is then clear that checking whether a quintet is resolved
requires only constant time. Given a taxon f ∈ S which is ﬁxed, there are (n−14
)
quintets containing f . Thus we have the following theorem.
Theorem 2. Given a set S of taxa, some taxon f ∈ S, and a complete set Q of
quartet topologies, then all unresolved quintets involving f can be found in O(n4)
time.
Let ≺ be some order (e.g. lexicographic order) on the taxon set S. For the three
possible topologies of a quartet, we denote them by type 0, 1, and 2 according to
New Fixed-Parameter Algorithms 71
Algorithm 1: FPA1-MQI (a complete set of quartet topologies Q, an integer
parameter k, a list Cf of unresolved quintets)
1: if Cf is empty and k ≥ 0 then
2: return ACCEPT;
3: else if k ≤ 0 then
4: return;
5: end if
6: Extract an unresolved quintet q from Cf ;
7: for each μ ∈ V do
8: (Q′, C′f , k′) ← update(Q, Cf ,q, μ, k);
9: FPA1-MQI (Q′, k′, C′f );
10: end for
in the search tree such that some quartet, which has been marked, must be
changed in all the possible 15 branches to make an unresolved quintet resolved,
the algorithm stops branching here and just returns. Let Qµ be the set of quartet
topologies changed according to μ. The procedure update obtains the updated
set of unresolved quintets C′f by removing the newly resolved quintets and adding
the newly unresolved quintets, and gets the updated parameter k′ = k − |Qµ|.
By Corollary 1, we know Cf is empty if and only if the set of quartet topologies
is tree-like. Algorithm FPA1-MQI branches in all possible ways to eliminate each
unresolved quintet in Cf and it changes at most k quartet topologies from the
root to each branch node in the search tree. Thus it is easy to see that the
algorithm is correct.
The Time Complexity. The algorithm works as a depth-bounded search tree.
Each tree node has 15 branches and each branch corresponds to a quintet
topology. Since there are 243 possible topology vectors of a quintet but 15 of
them are in V , we have 228 possible branching vectors and the correspond-
ing branching numbers as well. Consider the case that the algorithm selects a
quintet q = {a, b, c, d, e} which has induced quartet topologies [ab|cd], [ac|be],
[ae|bd], [ad|ce], and [bc|de] in Q. By comparing its corresponding topology vector
(0,1,2,1,0) with each topology vector μ ∈ V , we obtain the numbers of quartet
topologies changed by Algorithm FPA1-MQI, and then we have a branching vec-
tor (3, 3, 4, 3, 3, 3, 4, 3, 3, 4, 4, 3, 3, 4, 3) hence a branching number between 2.3004
and 2.3005 is obtained. It can be derived that the branching number in the worst
case is between 3.0445 and 3.0446. Thus the size of the search tree is O(3.0446k).
Then we obtain the following theorem by careful analysis.
Theorem 3. There exists an O(3.0446kn + n4) fixed-parameter algorithm for
the parameterized minimum quartet inconsistency problem.
4 An O(2.0162kn3 + n5) Algorithm
We deﬁne the two-siblings-determined minimum quartet inconsistency problem
(2SDMQI) as follows. Given a complete quartet topology set Q over a taxon set
New Fixed-Parameter Algorithms 73
Algorithm 3: Resolve (a complete set of quartet topologies Q, an integer
parameter k, a list Ca of unresolved quintets, two taxa a, b)
1: if Ca is empty and k ≥ 0 then
2: return ACCEPT;
3: else if k ≤ 0 then
4: return;
5: end if
6: Extract an unresolved quintet q from Ca;
7: if b ∈ q then q ← q ∪ {s}, for some arbitrary taxon s /∈ q; else q ← q ∪ {b};
8: for each ν ∈ V2 do
9: (Q′, C′a, k′) ← update2(Q, Ca,q, ν, k);
10: Resolve(Q′, k′, C′a, a, b);
11: end for
5 An O∗((1 + )k) Algorithm
The Algorithm. At the beginning of this section, let us consider some additional
preliminaries. Let T denote an evolutionary tree on S such that QT diﬀers from
Q in at most k quartet topologies. For an integer m ≥ 2, we say that taxa
a1, . . . , am are adjacent if there exists an edge e = (w, v) on T such that cutting e
will produce a bipartition ({a1, . . . , am}, S \{a1, . . . , am}) of S. In Fig. 5, cutting
the edge e will derive four adjacent taxa a1, a2, a3, and a4. After e = (w, v) is
cut, two binary trees will be produced which are rooted at w and v respectively.
Note that two taxa on T are adjacent if and only if they are siblings on T .
Lemma 3. Given an evolutionary tree T and an integer 2 ≤ ω ≤ n/2, there
exists a set of m adjacent taxa as leaves on T , where ω ≤ m ≤ 2ω − 2.
By extending the idea of Algorithm FPA2-MQI to consider m ≥ 3 adjacent
taxa, we obtain another ﬁxed-parameter algorithm, called FPA3-MQI, with two
subroutines Algorithm MAKE-ADJ and Algorithm ADJ-Resolve. Assume that
Am = {a1, . . . , am} is a set of adjacent taxa on T . We introduce the main
concepts of Algorithm FPA3-MQI as follows.
(2, 2)-cleaning: For every two taxa ai, aj ∈ Am and every two taxa u, v ∈
S \Am, we modify the topology of {ai, aj , u, v} to be [aiaj |uv]. We call this part
of the algorithm (2, 2)-cleaning.
(3, 1)-cleaning: Assume the parameter is k′. For ah, ai, aj ∈ Am and s ∈
S \ Am, without loss of generality we denote the type of quartet topology
[ahai|ajs] by 0, [ahaj |ais] by 1, and [ahs|aiaj ] by 2. We construct a set of all
possible evolutionary trees Tm+1 on the taxa in Am ∪ {x}, where x is an arbi-
trary taxon in S \Am, such that each T ′ ∈ Tm+1 has at most k′ diﬀerent induced
quartet topologies from Q. Afterwards, for each T ′ ∈ Tm+1, we change the type
of topology of every quartet {ah, ai, aj, s} into the same type of topology as
{ah, ai, aj, x} has on T ′. We call this part of the algorithm (3, 1)-cleaning.
(1, 3)-cleaning: Without loss of generality, we denote the type of quartet
topology [aiw|xy] by 0, [aix|wy] by 1, and [aiy|wx] by 2 for ai ∈ Am and
New Fixed-Parameter Algorithms 75
Algorithm 4: FPA3-MQI (a complete set of quartet topologies Q, an integer
parameter k, a list of unresolved quintets Ca1 , an arbitrary integer m)
1: Q∗ ← Q; C∗a1 ← Ca1 ; k∗ ← k;
2: for every set of m taxa Am = {a1, . . . , am} ⊆ S do
3: for every two taxa ai, aj ∈ Am and every two taxa u, v ∈ S \Am do
4: if k ≤ 0 then return; else Change the quartet topology of {ai, aj , u, v} in Q∗
to be [aiaj |uv] if [aiaj |uv] /∈ Q∗, and then update C∗a1 and k∗ ← k∗ − 1;
5: end for
6: Build a set of all possible evolutionary trees Tm+1 such that each T ′ ∈ Tm+1 is
an evolutionary tree on Am ∪ {x}, where x is an arbitrary taxon in S \Am and
|QT ′ \ Q∗| ≤ k∗;
7: Build a list Bm of sets of three taxa w, x, y ∈ S \ Am such that topologies of
{ai, w, x, y} in Q∗ are not all the same for all 1 ≤ i ≤ m;
8: Q∗∗ ← Q∗; C∗∗a1 ← C∗a1 ; k∗∗ ← k∗;
9: if Tm+1 = ∅ then
10: return;
11: else
12: for each T ′ ∈ Tm+1 do
13: k∗∗ ← k∗∗ − |QT ′ \Q∗∗|;
14: Change the quartet topologies in Q∗∗ over Am to those in QT ′ ;
15: For every taxon s ∈ S \ Am and every three taxa ah, ai, aj ∈ Am, change
the topology of {ah, ai, aj , s} to the one of the same type as {ah, ai, aj , x}
has; update C∗∗a1 ;
16: if MAKE-ADJ(Q∗∗, C∗∗a1 , k∗∗) returns ACCEPT then
17: return ACCEPT;
18: else
19: Restore (Q∗∗, C∗∗a1 ) to (Q∗, C∗a1), and k∗∗ ← k∗;
20: end if
21: end for
22: end if
23: Restore (Q∗, C∗a1) to (Q,Ca1), delete Bm, and k∗ ← k;
24: end for
Algorithm 5: MAKE-ADJ (a complete set of quartet topologies Q, a list of
unresolved quintets Ca1 , an integer parameter k)
1: if Ca1 is empty and k ≥ 0 then
2: return ACCEPT;
3: else if k ≤ 0 then
4: return;
5: end if
6: while Bm 	= ∅ do
7: Extract {w, x, y} from Bm;
8: for each type i ∈ {0, 1, 2} do
9: Change all the topologies of {a1, w, x, y}, . . . , {am, w, x, y} to topologies of
type i; let Q′, C′a1 , k′ be the changed Q, Ca1 , k respectively;
10: MAKE-ADJ(Q′, C′a1 , k′);
11: end for
12: end while
13: if ADJ-Resolve(Q,k, Ca1) returns ACCEPT then return ACCEPT;
New Fixed-Parameter Algorithms 77
Acknowledgments. We thank the anonymous referees for their helpful
comments.
References
1. Ben-Dor, A., Chor, B., Graur, D., Ophir, R., Pelleg, D.: From four-taxon trees to
phylogenies: The case of mammalian evolution. In: Proceedings of the RECOMB,
pp. 9–19 (1998)
2. Bandelt, H.J., Dress, A.: Reconstructing the shape of a tree from observed dissim-
ilarity date. Adv. Appl. Math. 7, 309–343 (1986)
3. Berry, V., Jiang, T., Kearney, P.E., Li, M., Wareham, H.T.: Quartet cleaning: Im-
proved algorithms and simulations. In: Nesˇetrˇil, J. (ed.) ESA 1999. LNCS, vol. 1643,
pp. 313–324. Springer, Heidelberg (1999)
4. Cho, B.: From quartets to phylogenetic trees. In: Rovan, B. (ed.) SOFSEM 1998.
LNCS, vol. 1521, pp. 36–53. Springer, Heidelberg (1998)
5. Downey, R.G., Fellows, M.R.: Parameterized Complexity. Springer, Heidelberg
(1999)
6. Erdo˝s, P., Steel, M., Sze´kely, L., Warnow, T.: A few logs suﬃce to build (almost)
all trees (Part 1). Random Struct. Alg. 14, 153–184 (1999)
7. Greene, D.H., Knuth, D.E.: Mathematics for the Analysis of Algorithms, 2nd edn.
Progress in Computer Science. Birkhauser, Boston (1982)
8. Gramm, J., Niedermeier, R.: A ﬁxed-parameter algorithm for minimum quartet
inconsistency. J. Comput. System Sci. 67, 723–741 (2003)
9. Jiang, T., Kearney, P.E., Li, M.: Some open problems in computational molecular
biology. J. Algorithms 34, 194–201 (2000)
10. Jiang, T., Kearney, P.E., Li, M.: A polynomial time approximation scheme for
inferring evolutionary tree from quartet topologies and its application. SIAM J.
Comput. 30, 1942–1961 (2001)
11. Steel, M.: The complexity of reconstructing trees from qualitative characters and
subtrees. J. Classiﬁcation 9, 91–116 (1992)
12. Niedermeier, R.: Invitation to Fixed-Parameter Algorithms. Oxford University
Press, Oxford (2006)
13. Niedermeier, R., Rossmanith, P.: A general method to speed up ﬁxed-parameter
algorithms. Inform. Process. Lett. 73, 125–129 (2000)
14. Wu, G., You, J.-H., Lin, G.: A lookahead branch-and-bound algorithm for the
maximum quartet consistency problem. In: Casadio, R., Myers, G. (eds.) WABI
2005. LNCS (LNBI), vol. 3692, pp. 65–76. Springer, Heidelberg (2005)
15. Wu, G., You, J.-H., Lin, G.: A polynomial time algorithm for the minimum quartet
inconsistency problem with O(n) quartet errors. Inform. Process. Lett. 100, 167–
171 (2006)
Table 1. Some results and open problems on probe graphs. Here n and m are the
number of vertices and the number of edges in a given probe graph and |P| denotes the
number of vertices labeled P in a fully partitioned probe graph.
Graph class Fully partitioned Unpartitioned
probe chordal O(|P|m) [3] O(m2) [3]
probe strongly chordal Poly. [5] Open
probe chordal bipartite Poly. [5] Open
probe interval O(n + m) [14] Poly. [8]
Probe DHG O(n2) [4] O(nm) [10]
probe cographs O(n + m) [13] O(n + m) [13]
Probe bipartite DHG O(n2) [4] O(nm) [9]
probe ptolemaic O(nm) [this paper] O(nm) [this paper]
probe comparability O(nm) [6] Open
probe co-comparability O(n3) [6] Open
probe permutation O(n2) [7] Open
probe trivially-perfect O(n + m) [2] O(n + m) [2]
probe threshold O(n + m) [2] O(n + m) [2]
r
r
r
r
r
 @
r
r r
r
r
@ 

Q
Q
r
r
r r
r
r
r
r
r r
rHHH



L
L
L
J
J





Fig. 1. A house, a hole, a domino, and a gem.
which some NP-hard problems can be solved in polynomial time. As the first
step of the study of probe G graphs, we developed polynomial time recognition
algorithms. In Table 1, we list some recent results and open problems on the
recognition of probe graphs of different graph classes. In this paper we give an
O(nm)-time algorithm to recognize partially partitioned probe ptolemaic graphs.
Distance-hereditary graphs are those graphs having no house, hole, domino,
or gem as an induced subgraph [1]. Ptolemaic graphs are those graphs that are
chordal and have no gem as an induced subgraph [12]. Ptolemaic graphs are a
subclass of chordal graphs and distance-hereditary graphs.
Let G = (V, E) be a graph. For v ∈ V , NG(v) consists of all vertices adjacent
to v in G, NG[v] = NG(v)∪{v}, and for X ⊆ V , NG(X) =
⋃
v∈X NG(v)−X . A
module X is a vertex set of G such that NG(v)−X is the same for every v ∈ X .
A twin is a pair of vertices u and v such that {u, v} is a module, the pair is a true
twin if u and v are adjacent and a false twin otherwise. A clique X in G is a vertex
subset such that every two distinct vertices in X are adjacent. A clique module X
of G is a vertex set of G that is both a module and a clique of G. A clique module
is trivial if it consists of exactly a vertex. A universal vertex is a vertex adjacent
to all other vertices. Suppose v is a vertex of ptolemaic graph G = (V, E) where
v is a non-universal vertex. Let C be a minimal component of G[V − NG[v]]
where G[V −NG[v]] is a subgraph of G induced by V −NG[v] and NG(C) does
not properly contain NG(C
′) for any component C′ of G[V −NG[v]]. Then either
NG(C) is a non-trivial clique module of G or NG(C) consists of exactly a vertex
that is a cut vertex of G. Notice that NG(C) ⊆ NG(v). If NG(C) is a non-trivial
clique module, then there is at least a pair of true twins in NG(C).
2
We sketch the algorithm in the following:
1. If the size of P is small, we solve the problem by brute force.
2. If P is unpartitioned, arbitrarily select an edge (u, v). Generate two partially
partitioned probe graphs. They are obtained from P by relabeling u and v
as probes, respectively. Then P is a probe ptolemaic graph iff one of them
is. They can be checked by the algorithm for partially partitioned case.
3. If P is partially or fully partitioned, there is a probe p. If p is a universal
vertex, then P is a probe trivially perfect graph and can be determined in
linear time [2]. Otherwise we reduce the problem instance to smaller partially
or fully partitioned probe graphs according to the cases given in Theorem 1.
Theorem 2. There exists an O(nm)-time algorithm to check if a probe graph
P is a probe ptolemaic graph.
References
1. H. J. Bandelt, and H. M. Mulder, Distance-hereditary graphs, Journal of Combi-
natorial Theory, Series B 41 (1986), pp. 182–208.
2. D. Bayer, V. B. Le, and H.N. de Ridder, Probe threshold and probe trivially perfect
graphs, Theoretical Computer Science 410 (2009), pp. 4812–4822.
3. A. Berry, M. C. Golumbic, and M. Lipshteyn, Recognizing Chordal Probe Graphs
and Cycle-Bicolorable Graphs, SIAM J. Discrete Math. 21 (2007), pp. 573–591.
4. D. B. Chandler, M.-S. Chang, T. Kloks, J. Liu, and S.-L. Peng, Recognition of
probe cographs and partitioned probe distance hereditary graphs, Proceedings of
AAIM 2006, LNCS 4041, pp. 267–278.
5. D. B. Chandler, J. Guo, T. Kloks, and R. Niedermeier, Probe matrix problems:
totally balanced matrices, Proceeding of AAIM 2007, LNCS 4508, pp. 368–377.
6. D. B. Chandler, M.-S. Chang, T. Kloks, J. Liu, and S.-L. Peng, Partitioned probe
comparability graphs, Theoretical Computer Science 396 (2008), pp. 212–222.
7. D. B. Chandler, M.-S. Chang, A. J.J. Kloks, J. Liu, and S.-L. Peng, On probe
permutation graphs, Discrete Applied Mathematics 157 (2009), pp. 2611–2619.
8. G. J. Chang, A. J. J. Kloks, J. Liu, and S.-L. Peng, The PIGs full monty - a floor
show of minimal separators, Proceedings STACS 2005, LNCS 3404, pp. 521–532.
9. M.-S. Chang, L.-J. Hung, and P. Rossmanith, Probe bipartite distance-hereditary
graphs, in Proceedings of NCS 2009: Workshop on Algorithms and Bioinformatics,
pp. 16–27.
10. M.-S. Chang, L.-J. Hung, and P. Rossmanith, Probe distance-hereditary graphs,
Proceedings of CATS 2010, CRPIT 109, pp. 55–64.
11. M.C. Golumbic, H. Kaplan, and R. Shamir, Graph sandwich problems, Journal of
Algorithms 19 (1995), pp. 449–473.
12. E. Howorka, A characterization of ptolemaic graphs, Journal of Graph Theory, 5
(1981), pp. 323–331.
13. V. B. Le and H. N. de Ridder, Characterisations and linear-time recognition of
probe cographs. Proceedings of WG 2007, LNCS 4769, pp. 226–237.
14. R. M. McConnell and Y. Nussbaum, Linear-time recognition of probe interval
graphs, in Proceedings of ESA 2009, LNCS 5757, pp. 349–360.
15. P. E. Zhang, A. Schon, S. G. Fischer, E. Cayanis, J. Weiss, S. Kistler, and
E. Bourne, An algorithm based on graph theory for the assembly of contigs in
physical mapping of DNA, CABIOS 10 (1994), pp. 309–317.
4
Theory Comput Syst (2010) 47: 342–367 343
1 Introduction
Nowadays, to determine the evolutionary relationship of a set of taxa is very impor-
tant in biological research, especially in computational biology. For this relationship,
an evolutionary tree is a common model, which is widely considered. Let S be a set
of taxa and |S| = n. An evolutionary tree T on S is an unrooted, leaf-labeled tree
such that the leaves of T are bijectively labeled by the taxa in S, and each inter-
nal node of T has degree three. In the past decade, quartet methods for building an
evolutionary tree for a set of taxa have received much attention [1, 3, 4, 6, 8–11, 14].
A quartet is a set of four taxa {a, b, c, d} in the taxon set S. The quartet topology
for {a, b, c, d} induced by T is the path structure connecting a, b, c, and d in T
(see Fig. 1 for an illustration). A quartet {a, b, c, d} has three possible topologies
[ab|cd], [ac|bd] and [ad|bc], which are the bipartitions of {a, b, c, d} (hence [ab|cd],
[ba|cd], [ab|dc], [ba|dc], [cd|ab], [dc|ab], [cd|ba], [dc|ba] are viewed as the same
topologies of the quartet {a, b, c, d}). Figure 2 is an illustration for the three possible
topologies of the quartet {a, b, c, d}.
A quintet is a set of five taxa in S, while a sextet is a set of six taxa in S. The quin-
tet topology of a quintet {a, b, c, d, e} induced by an evolutionary tree T is the path
structure connecting a, b, c, d , and e in T . Similarly, we have the sextet topology of
a sextet. Without loss of generality, assume that we have [bc|de] induced by T and
another taxon a, then there are five possible quintet topologies since there are five po-
sitions for inserting a into the tree structure of [bc|de] (see Fig. 3 for an illustration).
Since there are three different topologies for the quartet {a, b, c, d}, there are 15 pos-
sible quintet topologies for a quintet {a, b, c, d, e}. A quintet has (54
) = 5 quartets, and
hence a quintet topology has five different induced quartet topologies. Two taxa a, b
are siblings on an evolutionary tree T if a and b are both adjacent to the same inter-
nal vertex in T . Here we consider the sextet topologies of the sextet {a, b,w,x, y, z}
where a, b are siblings. It is clear that there are 15 possible sextet topologies with
siblings a, b for a sextet {a, b,w,x, y, z} (see Fig. 4 for an illustration).
Fig. 1 The quartet topology of {a, b, c, d} induced by evolutionary tree T
Fig. 2 Three topologies for the
quartet {a, b, c, d}
Theory Comput Syst (2010) 47: 342–367 345
that the number of quartet errors of Q with respect to QT is minimized. The MQC
problem and the MQI problem are both NP-hard [3], however, the MQC problem has
a polynomial time approximation scheme (PTAS) [10], while the best approximation
ratio found so far for the MQI problem is O(n2) [9]. Ben-Dor et al. gave an O(3nn4)
algorithm to solve the MQI problem by dynamic programming [1]. For the case that
Q has less than (n − 3)/2 quartet errors, Berry et al. [3] devised an O(n4) algorithm
for the MQI problem. Furthermore, if Q has at most cn quartet errors, Wu et al. [15]
compute the optimal solution for the MQI problem in O(n5 +24cn12c+2) time, where
c is some positive constant. While this is a polynomial time algorithm, the degree of
the polynomial in the runtime grows quickly. Therefore parameterized algorithms are
faster for practical values of k and n.
Provided with a positive integer k as an additional part of the input, the parame-
terized MQI problem is to determine whether there exists an evolutionary tree T such
that the number of quartet errors of Q is at most k. Gramm and Niedermeier proved
that the parameterized MQI problem is fixed parameter tractable [8], and they pro-
posed a O(4kn + n4) fixed parameter algorithm [8]. In [14], Wu et al. presented a
lookahead branch-and-bound algorithm for the MQC problem which runs in time
O(4k′n2k′ + n4), where k′ is an upper bound on the number of quartet errors of Q.
1.2 Our Result
In this paper, we focus on the parameterized MQI problem as follows. Given a com-
plete set of quartet topologies Q and a parameter k as the input, determine whether
there is a tree-like quartet topology set that differs from Q in at most k quartet topolo-
gies, that is, determine whether Q has at most k quartet errors. Using the depth-
bounded search tree strategy [12], we propose an O(3.0446kn+ n4) fixed-parameter
algorithm for this problem. With slight refinement, we obtain an O(2.0162kn3 + n5)
algorithm. Furthermore, by applying the depth-bounded search tree technique again,
we obtain an O∗((1 + )k) time fixed-parameter algorithm1 with arbitrarily small
 > 0. The running time of the third algorithm has an exponential term with an ar-
bitrarily small base, which can be very close to 1, yet its polynomial factor grows
quickly as the base of the exponential term decreases.
In this paper, we present three fixed-parameter algorithms in an incremental way,
since the second one is obtained by extending the first one, and the third one is gen-
eralization of the second one. The paper is organized as follows. In Sect. 2, we will
give additional theoretical background for the MQI problem, and introduce the depth-
bounded search tree strategy for designing fixed-parameter algorithms as well. In
Sect. 3, we present an O(3.0446kn + n4) fixed-parameter algorithm for the parame-
terized MQI problem. In Sect. 4, first we will introduce the two-siblings-determined
minimum quartet inconsistency problem (2SDMQI), which is a variation of the pa-
rameterized MQI problem. We will present an O(2.0162kn + n4) fixed-parameter
algorithm for the 2SDMQI problem, and then we will give an O(2.0162kn3 + n5)
fixed-parameter algorithm for the parameterized MQI problem by solving the 2SD-
MQI problem. Finally in Sect. 5, we will present an O∗((1 + )k) fixed-parameter
1For two functions f,g : (N,N) → R, we write f = O∗(g) if f (n, k) = O(poly(n, k) · g(n, k)).
Theory Comput Syst (2010) 47: 342–367 347
constant time [8]. It is then clear that checking whether a quintet is resolved requires
only constant time. With a taxon f ∈ S which is fixed, there are (n−14
)
quintets con-
taining f . Thus we have the following theorem.
Theorem 3 Given a set S of taxa, some taxon f ∈ S, and a complete set Q of quartet
topologies, then all unresolved quintets involving f can be found in O(n4) time.
Let ≺ be a total order on the taxon set S. Without loss of generality, every set of l
taxa is represented according to ≺. That is, we denote a set of taxa by {s1, s2, . . . , sl} if
s1 ≺ s2 ≺ · · · ≺ sl . A quartet topology is represented by [s1s2|s3s4] if s1 ≺ s3, s1 ≺ s2,
and s3 ≺ s4. For the three possible topologies of a quartet, we denote them by type
0, 1, and 2 according to ≺. Consider a quartet {a, b, c, d} ⊂ S as an example. If
a ≺ b ≺ c ≺ d , we denote [ab|cd] by 0, [ac|bd] by 1, and [ad|bc] by 2.
Let ≺l be the lexicographic order on the Cartesian product of l’s S according
to the total order ≺. For a quintet {s1, s2, s3, s4, s5}, where s1 ≺ s2 ≺ s3 ≺ s4 ≺ s5,
we define its topology vector to be an ordered sequence (r1, r2, r3, r4, r5), where r1,
r2, r3, r4, and r5 are the types of quartet topologies of {s1, s2, s3, s4}, {s1, s2, s3, s5},
{s1, s2, s4, s5}, {s1, s3, s4, s5}, and {s2, s3, s4, s5} respectively (i.e., the quartets in the
order of ≺5). For example, consider a quintet {a, b, c, d, e} ⊆ S, where a ≺ b ≺ c ≺
d ≺ e. Assume that [ab|cd], [ae|bc], [ab|de], [ae|cd], and [bd|ce] are in Q, then
the topology vector of {a, b, c, d, e} is (0,2,0,2,1). Recall that there are 15 possible
quintet topologies for a quintet {s1, s2, s3, s4, s5}. We denote by V the set of topology
vectors of all the possible quintet topologies of a quintet, then we have
V = {(0,0,0,0,0), (1,1,0,0,0), (2,2,0,0,0), (2,2,1,1,0), (2,2,2,2,0),
(0,0,0,1,1), (2,0,1,1,1), (1,0,2,1,1), (1,1,2,0,1), (1,2,2,2,1),
(0,0,0,2,2), (0,2,2,2,2), (0,1,1,2,2), (1,1,1,0,2), (2,1,1,1,2)}.
Note that the size of V is far less than the number of possible topology vectors of a
quintet, which is 35 = 243.
Assume that s1, s2 are siblings in an evolutionary tree over S, and hence that we
have 15 sextet topologies for the sextet {s1, s2, s3, s4, s5, s6} ⊆ S. There are
(6
4
) = 15
quartets with respect to the sextet {s1, s2, s3, s4, s5, s6}, yet
(4
2
) = 6 of them have
fixed quartet topologies since s1, s2 are siblings. For example, the quartet topol-
ogy of {s1, s2, s3, s4} must be [s1s2|s3s4]. Given two siblings s1, s2, the {s1, s2}-
reduced topology vector of sextet {s1, s2, s3, s4, s5, s6} is an ordered sequence of
types of the quartet topologies which are not fixed. For example, consider a sex-
tet {a, b,w,x, y, z} ⊆ S with siblings a, b such that [aw|xy], [ax|wz], [az|wy],
[ay|xz], [bw|xy], [bx|wz], [bz|wy], [by|xz], and [wx|yz] are in Q. The {a, b}-
reduced topology vector of {a, b,w,x, y, z} is (0,1,2,1,0,1,2,1,0). Let us denote
by V2 the set of {a, b}-reduced topology vectors of all possible sextet topologies of
{a, b,w,x, y, z}. Then we have
V2 = {(0,0,0,0,0,0,0,0,0), (1,1,0,0,1,1,0,0,0), (2,2,0,0,2,2,0,0,0),
(2,2,1,1,2,2,1,1,0), (2,2,2,2,2,2,2,2,0), (0,0,0,1,0,0,0,1,1),
Theory Comput Syst (2010) 47: 342–367 349
Theorem 4 [7, 12, 13] A depth-bounded search tree with branching vector (d1, d2,
. . . , di) and its root labeled with parameter k has size kO(1) ·αk , where α is the great-
est characteristic root the corresponding characteristic polynomial. Furthermore, if
α is unique, then the size of the search tree is O(αk).
For simplicity, we call the base of the exponentially growing function in Theo-
rem 4, i.e., α, the branching number. Let ρ(v) denote the branching number cor-
responding to a branching vector v. Note that the ordering of a branching vector
does not affect the corresponding branching number. The following theorem concerns
about the relation between a branching vector its corresponding branching number.
Theorem 5 Given two branching vectors v = (d1, d2, . . . , di) and v′ = (d ′1, d ′2,
. . . , d ′i ), where dj ≤ d ′j for 1 ≤ j ≤ i. Then ρ(v) ≥ ρ(v′).
Proof The reflected characteristic polynomial of v and v′ are 1 − ∑ij=1 zdj and
1 − ∑ij=1 zd
′
j respectively. Let z0 and z′0 be the roots of 1 −
∑i
j=1 zdj and 1 −
∑i
j=1 z
d ′j respectively, then we have
∑i
j=1 z0dj = 1 and
∑i
j=1 z′0
dj = 1. Since
z0 < 1 and dj ≤ d ′j for 1 ≤ j ≤ i, we have z0d
′
j ≤ z0dj for all 1 ≤ j ≤ i, and hence
∑i
j=1 z0
d ′j ≤ 1. Thus z′0 must be greater than or equal to z0. Therefore, ρ(v) =
1/z0 ≥ 1/z′0 = ρ(v′). 
3 An O(3.0446kn + n4) Fixed-Parameter Algorithm for the Parameterized
MQI Problem
3.1 The Algorithm
Our first fixed-parameter algorithm is called FPA1-MQI, which runs recursively. The
concepts of the algorithm are as follows. We build a list of unresolved quintets Cf
containing some fixed taxon f and the list V of topologies vectors of possible quintet
topologies for a quintet as preprocessing steps. In each recursion, the algorithm se-
lects an unresolved quintet q = {a, b, c, d, e} ∈ Cf arbitrarily and then tries to make q
resolved by the procedure update according to all the possible 15 quintet topologies
of q.
Recall that each topology vector μ ∈ V represents a quintet topology of a quintet.
The procedure update changes quartet topologies according to the quartet topologies
which μ stands for, and updates the set Cf and the parameter k to be C′f and k′ re-
spectively. For example, assume that we have [ab|cd], [ae|bc], [ab|de], [ae|cd], and
[bd|ce] in Q for the quintet {a, b, c, d, e} (the corresponding topology vector is then
(0,2,0,2,1)), and assume that μ = (2,1,1,1,2). The procedure update changes
these quartet topologies to [ad|bc], [ac|be], [ad|be], [ad|ce], and [be|cd] respec-
tively, according to μ, and these quartets are marked so that their topologies will
not be changed again. However, if there is a branch node in the search tree such
that some quartet topology, whose corresponding quartet has been marked, must be
Theory Comput Syst (2010) 47: 342–367 351
Table 1 Some possible branching vectors and branching numbers of FPA1-MQI
Topology vector Branching vector Branching number
(0,1,2,1,0) (3,3,4,3,3,3,4,3,3,4,4,3,3,4,3) 2.30042. . .
(0,0,1,0,1) (2,4,4,4,5,2,2,3,3,4,3,4,3,3,4) 2.46596. . .
(0,0,1,0,2) (2,4,4,4,5,3,3,4,4,5,2,3,2,2,3) 2.54314. . .
(0,0,1,0,0) (1,3,3,3,4,3,3,4,4,5,3,4,3,3,4) 2.55234. . .
(0,0,1,1,2) (3,5,5,3,5,2,2,3,5,5,2,3,2,3,2) 2.67102. . .
(0,0,0,0,1) (1,3,3,5,5,1,3,3,3,4,2,4,4,4,5) 3.04454. . .
case, the algorithm selects a quintet q = {a, b, c, d, e} which has induced quartet
topologies [ab|cd], [ac|be], [ae|bd], [ad|ce], and [bc|de] in Q. By comparing its
corresponding topology vector (0,1,2,1,0) with each topology vector μ ∈ V , we
obtain that the numbers of quartet topologies changed by Algorithm FPA1-MQI are
3, 3, 4, 3, 3, 3, 4, 3, 3, 4, 4, 3, 3, 4, and 3 respectively. Hence we have a branching
vector (3,3,4,3,3,3,4,3,3,4,4,3,3,4,3) and then we can compute a branching
number between 2.3004 and 2.3005. It can be derived that the branching number in
the worst case is greater than 3.0445 and less than 3.0446. Thus the size of T (k) is
O(3.0446k).
3.2.3 The Procedure update
For μ ∈ V , since there are n − 4 quintets involving a fixed quartet, there are at most
|Qμ|(n − 4) quintets involving quartet topologies in Qμ. Thus the procedure update
runs only in O(n) time.
From the above analysis, we derive that the time complexity of Algorithm FPA1-
MQI is O(3.0446kn + n4). Thus the following theorem follows.
Theorem 6 There exists an O(3.0446kn + n4) fixed-parameter algorithm for the
parameterized minimum quartet inconsistency problem.
4 An O(2.0162kn3 + n5) Fixed-Parameter Algorithm for the Parameterized
MQI Problem
4.1 The Two-Siblings-Determined Minimum Quartet Inconsistency Problem
We define the two-siblings-determined minimum quartet inconsistency problem as
follows. Given a complete quartet topology set Q over a taxon set S, a parameter k
and two taxa a, b ∈ S as the input, determine whether there exists an evolutionary
tree T on which a and b are siblings such that QT differs from Q in at most k quartet
topologies. As we have mentioned in Sect. 1, we abbreviate this problem as 2SDMQI
for the readers’ convenience.
We present a fixed-parameter algorithm called FPA-2SDMQI for the 2SDMQI
problem as follows. First, for every u,v ∈ S \{a, b} such that [ab|uv] /∈ Q, we change
Theory Comput Syst (2010) 47: 342–367 353
Algorithm Resolve works recursively. In each recursion, it arbitrarily selects an
unresolved quintet q. It is clear that q ∪ {b} is {a, b}-unresolved. Then Algorithm
Resolve tries to make q ∪ {b} be {a, b}-resolved by the procedure update2 according
to all the possible 15 sextet topologies of q ∪ {b} having a, b as siblings. Similar to
the procedure update in Sect. 3, we mark the quartets whose topologies are changed,
and if there is a branch node in the search tree such that some quartet, which has been
marked, must be changed in all the possible 15 branches to make q ∪ {b} be {a, b}-
resolved, the algorithm stops branching here and just returns (by the same reason
mentioned in Sect. 3.1).
Each {a, b}-reduced topology vector ν ∈ V2 represents a sextet topology of a sextet
with siblings a, b. The procedure update2 changes quartet topologies according to the
quartet topologies that ν stands for, marks these quartets so that their topologies will
not be changed again, and updates the set Ca and the parameter k to be C′a and k′
respectively. We denote by Qν the set of quartet topologies changed according to ν.
The procedure update2 gets the updated C′a by removing the newly resolved quintets
and adding the newly unresolved quintets from Ca , and gets the updated parameter
k′ by letting k′ = k − |Qν |. Similar to the analysis of Algorithm FPA1-MQI, we can
derive easily that Algorithm FPA-2SDMQI is correct.
4.2 Time Complexity
4.2.1 Nonrecursive Steps
Execution of lines 6–13 in Algorithm FPA-2SDMQI costs O(n2) time. Building Ca
requires O(n4) time by Theorem 3. Furthermore, it is obvious that building V2 costs
only constant time.
4.2.2 The Recursive Structure of Algorithm FPA-2SDMQI
The algorithm (i.e., Algorithm Resolve) again works as a depth-bounded search tree.
Each tree node has 15 branches and each branch corresponds to a sextet topology
with siblings a, b. The root of the search tree is labeled by k. Let us denote the size
of the search tree rooted at a node labeled r to be the T2(r). For each ν ∈ V2, we
have T2(r) = ∑ν∈V2 T2(r − |Qν |), that is, the branching vector is (|Qν |)ν∈V2 . There
are 39 = 19683 possible {a, b}-reduced topology vectors of a sextet containing a, b.
By ignoring {a, b}-reduced topology vectors in V2, there are 19668 possible branch-
ing vectors as well as 19668 branching numbers left. Actually, there are only 141
different branching numbers among these 19668 ones (this can be easily checked
by a small program). Table 2 lists part of the branching vectors and the correspond-
Table 2 Some possible branching vectors and branching numbers of FPA-2SDMQI
Topology vector Branching vector Branching number
(0,0,1,1,1,1,2,2,0) (6,6,8,6,6,6,6,5,6,6,6,6,5,6,6) 1.58005. . .
(0,0,1,0,1,2,2,1,0) (5,6,6,5,6,6,6,5,6,6,7,6,7,6,7) 1.58142. . .
. . . . . . . . .
(0,0,0,0,0,0,0,1,0) (1,5,5,7,8,2,6,6,8,9,3,7,7,8,8) 2.00904. . .
(0,0,0,0,0,0,0,0,1) (1,5,5,9,9,2,6,6,6,8,3,7,7,7,9) 2.01615. . .
Theory Comput Syst (2010) 47: 342–367 355
Theorem 8 There exists an O(2.0162kn3 + n5) fixed-parameter algorithm for the
parameterized minimum quartet inconsistency problem.
5 An O∗((1 + )k) Fixed-Parameter Algorithm for the Parameterized MQI
Problem
5.1 The Algorithm
At the beginning of this section, let us consider some additional preliminaries. Let
T denote an evolutionary tree on S such that QT differs from Q in at most k quar-
tet topologies. For an integer m ≥ 2, we say that taxa a1, . . . , am are adjacent if
there exists an edge e = (w,v) on T such that cutting e will produce a bipartition
({a1, . . . , am}, S \ {a1, . . . , am}) of S. In Fig. 6, cutting the edge e will derive four
adjacent taxa a1, a2, a3, and a4. In addition, after e = (w,v) is cut, two binary trees,
which are rooted at w and v respectively, will be produced. Note that two taxa on T
are adjacent if and only if they are siblings on T .
Lemma 3 Given an evolutionary tree T and an integer 2 ≤ ω ≤ n/2, there exists a
set of m adjacent taxa as leaves on T , where ω ≤ m ≤ 2ω − 2.
Proof If there exists ω adjacent taxa on T , the lemma holds. Otherwise, assume that
there is no subtree of T which has exactly m taxa as leaves. Let T (s) denote the
subtree of T which is rooted at a tree node s. There must exist some edge e∗ = (w,v)
such that cutting e∗ will produce a bipartition (A,S \ A), where |A| > ω, T (v) has
A as its leaf set and two subtrees of T (v) have both less than ω taxa as their leaves
(otherwise, assume that t is one child of v such that T (t) has more than ω taxa
as leaves. Then we can recursively find a subtree of T (t) rooted at some tree node
x descendant of t until both two subtrees of T (x) have less than ω taxa as their
leaves). Assume that v has two children u and t , and T (u) and T (t) have p and p′
taxa as leaves respectively, where p,p′ < ω. Since |A| > ω, we have p + p′ > ω.
Furthermore, p + p′ ≤ 2ω − 2 since p and p′ are both less than ω. So we have
ω + 1 ≤ p + p′ ≤ 2ω − 2. Therefore the lemma follows. 
Recall that Algorithm FPA2-MQI copes with siblings on an evolutionary tree first.
In this section, we extend the idea of Algorithm FPA2-MQI to consider m ≥ 3 ad-
jacent taxa. We obtain another fixed-parameter algorithm called FPA3-MQI with
two subroutines Algorithm MAKE-ADJ and Algorithm ADJ-Resolve. Assume that
Fig. 6 An evolutionary tree
with adjacent taxa a1, a2, a3, a4
Theory Comput Syst (2010) 47: 342–367 357
Algorithm 6 MAKE-ADJ (A complete set of quartet topologies Q, a list of unresolved
quintets Ca1 , an integer parameter k)
1: if Ca1 is empty and k ≥ 0 then
2: Return ACCEPT;
3: else if k ≤ 0 then
4: Return;
5: end if
6: while Bm = ∅ do
7: Extract {w,x, y} from Bm;
8: for each type i ∈ {0,1,2} do
9: Change all the topologies of {a1,w,x, y}, . . . , {am,w,x, y} to topologies of
type i; let Q′, C′a1 , k′ be the changed Q, Ca1 , k respectively;
10: MAKE-ADJ(Q′, C′a1 , k′);
11: end for
12: end while
13: if ADJ-Resolve(Q,k, Ca1) returns ACCEPT then
14: Return ACCEPT;
15: end if
Algorithm 7 ADJ-Resolve (A complete set of quartet topologies Q, an integer para-
meter k, a list Ca1 of unresolved quintets)
1: if Ca1 is empty and k ≥ 0 then
2: Return ACCEPT;
3: else if k ≤ 0 then
4: Return;
5: end if
6: Extract an unresolved quintet q from Ca1 ;
7: for each μ ∈ V do
8: (Q′, C′a1 , k′) ← updatem(Q, Ca1 ,q,μ, k);
9: ADJ-Resolve(Q′, k′, C′a1);
10: end for
5.1.2 (3,1)-Cleaning
Assume the parameter is k′. For ah, ai, aj ∈ Am and s ∈ S \ Am, without loss of
generality we denote the type of quartet topology [ahai |aj s] by 0, [ahaj |ais] by 1,
and [ahs|aiaj ] by 2. We construct a set of all possible evolutionary trees Tm+1 on the
taxa in Am ∪ {x}, where x is an arbitrary taxon in S \ Am, such that each T ′ ∈ Tm+1
has at most k′ different induced quartet topologies from Q. Afterwards, for each
T ′ ∈ Tm+1, we change the type of topology of every quartet {ah, ai, aj , s} into the
same type of topology as {ah, ai, aj , x} has on T ′. We call this part of the algorithm
(3,1)-cleaning.
Theory Comput Syst (2010) 47: 342–367 359
Fig. 8 Possible topologies for
the quintet {a1, a2, a3, x, y}
we obtain the other two quintet topologies in (b) and (c) of Fig. 8. So the quintet
{a1, a2, a3, x, y} must be also resolved. Then a contradiction occurs.
Third, without loss of generality we assume q = {a1, a2, a3, a4, s}, where
a1, a2, a3, a4 ∈ Am and s ∈ S \ Am. Recall that for some fixed taxa x ∈ S \ Am, the
tree topology of Am ∪ {x} is determined because of (3,1)-cleaning of the algorithm.
Moreover, all the quartets in {a1, a2, a3, a4, s} have the same type of quartet topolo-
gies as {a1, a2, a3, a4, x} have. So the quintet {a1, a2, a3, a4, s} must be resolved.
Then a contradiction occurs again. As to the fourth case of the proof, i.e., the quintets
involving five taxa in Am, their topologies are also determined by (3,1)-cleaning of
the algorithm, so they must be resolved. Therefore, we have shown that as long as
(2,2)-cleaning, (3,1)-cleaning, and (1,3)-cleaning of the algorithm are done, there
is no unresolved quintet in Ca1 containing taxa in Am except a1. Hence the lemma
follows. 
Note that there do not always exist ω adjacent taxa in an evolutionary tree for an
arbitrary integer ω. By Lemma 3, we know there must be m taxa which are adjacent
in an evolutionary tree, where ω ≤ m ≤ 2ω − 2. Assume that we are given an integer
ω as an additional input. Then to solve the parameterized MQI problem, first we
build a list of unresolved quintet involving s for each s ∈ S, then we run Algorithm
FPA3-MQI for every m ∈ {ω, . . . ,2ω − 2}.
By Lemma 4 we know that each unresolved quintet q ∈ Ca1 contains a1 and the
other four taxa from S \ Am. The procedure updatem is similar to the procedure
update in Sect. 3. Yet if a quartet topology of {a1,w,x, y}, where w,x, y ∈ q \ a1,
is changed, the procedure not only changes quartet topologies according to μ, but
also changes the topologies of {a2,w,x, y}, {a3,w,x, y}, . . . , {am,w,x, y} together
into the same type as {a1,w,x, y} has. Let d denote the number of quartet topologies
changed by updatem. Then the procedure updates the set Ca1 and the parameter k to
be C′a1 and k′ respectively, where k′ is k − d .
5.1.5 Correctness
Recall that we use T to denote an evolutionary tree on S such that QT differs from Q
in at most k quartet topologies. Given an arbitrary integer 2 ≤ ω ≤ n/2, there exists
m adjacent taxa in T , where ω ≤ m ≤ 2ω − 2. So we can assume that there is a set
of adjacent taxa Am = {a1, . . . , am} ⊆ S on T . Since the taxa in Am are adjacent, the
path connecting every two taxa ai, aj ∈ Am and the path connecting two taxa u,v ∈
S \Am will be disjoint and hence the topology of {ai, aj , u, v} must be [aiaj |uv]. So
(2,2)-cleaning is valid. In addition, once the topology of {ah, ai, aj , x} is fixed for
ah, ai, aj ∈ Am and some x ∈ S \ Am, the quartets {ah, ai, aj , s} must have the same
type of quartet topologies as {ah, ai, aj , x} has one T . Hence (3,1)-cleaning is valid.
Theory Comput Syst (2010) 47: 342–367 361
(1,3)-cleaning branches on these three types to make every quartet {ai,w,x, y},
where ai ∈ Am, have the same type of topology. Then (1,3)-cleaning of the algo-
rithm has a recurrence of T (k) = T (k − (m1 + m2)) + T (k − (m0 + m2)) + T (k −
(m0 + m1)). So we have a branching vector (m1 + m2,m0 + m2,m0 + m1). Let
r0 = m1 + m2, r1 = m1 + m2 and r2 = m0 + m1. Since the order of a branching
vector does not change its branching number, without loss of generality we assume
that 0 < r0 ≤ r1 ≤ r2 ≤ m. Since m0 + m1 + m2 = m, we have r0 + r1 + r2 = 2m
and r1, r2 ≥ m/2. The next lemma shows that the size of the depth-bounded search
tree of (1,3)-cleaning is O((1 + 5m−1/4)k). Moreover, it can be proved to be
O((1 + 2m−1/2)k) if m ≥ 19.
Lemma 5 Given a branching vector (r0, r1, r2), where 0 < r0 ≤ r1 ≤ r2 ≤ m, r0 +
r1 + r2 = 2m and r1, r2 ≥ m/2, then we have a branching number α < 1 + 5m−1/4.
Furthermore, α < 1 + 2m−1/2 if m ≥ 19.
Proof The reflected characteristic polynomial of (r0, r1, r2) is 1 − zr0 − zr1 − zr2 .
Let f (z) = 1 − zr0 − zr1 − zr2 . We have f (0) = 1 and f (1) = −2, so there is
a root of f (z) in [0,1]. The derivative f ′(z) = −r0zr0−1 − r1zr1−1 − r2zr2−1.
We can derive that f (z) is monotonically decreasing in [0,1] since f ′(z) ≤ 0 for
0 ≤ z ≤ 1. Let us define g(z) = 1 − z − 2zm/2. Similarly, g(z) has a root in [0,1]
and is monotonically decreasing in [0,1]. Since zr0 ≤ z and zr1 , zr2 ≤ zm/2, we have
g(z) ≤ f (z). We can then derive that there is a root of g(z) which is smaller than the
root of f (z).
Let 0 ≤ z0 ≤ 1 be a root of g(z), i.e., g(z0) = 0. Let z1 = 1 − m−1/4 and
z2 = 1−m−1/2, so 0 ≤ z1, z2 ≤ 1. Then we have g(z1) = m−1/4 −2(1−m−1/4)m/2 >
m−1/4 − 2e−m3/4/2, and g(z2) = m−1/2 − 2(1 −m−1/2)m/2 > m−1/2 − 2e−m1/2/2. So
g(z1) > 0 when m ≥ 3 and g(z2) > 0 when m ≥ 19. If g(z1) > 0, then z0 must
be bigger than z1 because g(z) is monotonically decreasing in [0,1]. So we have
z0 > 1 − m−1/4 for m ≥ 3. Similarly, we have z0 > 1 − m−1/2 if m ≥ 19. There-
fore, the branching number α is smaller than 1/(1 − m−1/4) < 1 + 5m−1/4. Further-
more, if m ≥ 19, α is smaller than 1/(1 − m−1/2) < 1 + 2m−1/2. The lemma is then
proved. 
Quintet cleaning by the recursive algorithm ADJ-Resolve Assume that the list
of unresolved quintets is Ca1 . Let q = {a1,w,x, y, z} be an unresolved quintet
in Ca1 , and let vq = (vq(1),vq(2),vq(3),vq(4),vq(5)) denote the topology vec-
tor of q, where vq(1), vq(2), vq(3), vq(4), and vq(5) are the types of topolo-
gies of {a1,w,x, y}, {a1,w,x, z}, {a1,w,y, z}, {a1, x, y, z}, and {w,x, y, z} re-
spectively, with respect to Q. Recall that V = {μ1, . . . ,μ15} is a set of topol-
ogy vectors of 15 possible quintet topologies for a quintet, such that each μi =
(μi(1),μi(2),μi(3),μi(4),μi(5)) ∈ V stands for the ith topology vector in V .
If q is resolved, there exists exactly one μi ∈ V such that vq(j) = μi(j) for each
1 ≤ j ≤ 5. Let vq(j) ⊕ μi(j) denote whether vq(j) and μi(j) are different. That is,
for 1 ≤ j ≤ 5 we denote vq(j) ⊕ μi(j) = 1 if vq(j) = μi(j) and vq(j) ⊕ μi(j) = 0
otherwise.
For an unresolved quintet q, let b(q) denote the branching vector of the recurrence
of the quintet cleaning for q. By the descriptions of quintet cleaning and the procedure
Theory Comput Syst (2010) 47: 342–367 363
m adjacent taxa Am is given, since it costs O(mn) time at each node in the search
tree, the time complexity for the search tree is O((1 + 2m−1/2)kmn). Assume that
1 + 2m−1/2 ≤ 1 +  for some constant  > 0. We obtain m ≥ (2/)2. Thus after the
lists of unresolved quintets {Cs | s ∈ S} are built, we run Algorithm FPA3-MQI for
every (2/)2 ≤ m ≤ 2(2/)2 − 2 and every set of m taxa in S. Let ω denote (2/)2.
By the analysis in the previous subsection, we obtain the overall time complexity of
the algorithm as follows
O
(
n5 +
2ω−2∑
m=ω
(
n
m
)(
m2n3 + mn3 + h(m) ·
(
m4n + m3n2 + (1 + )kmn
)))
= O(n5 + (ω − 1)n2ω−2(4ω2n3 + 2ωn3
+ h(2ω) · (16ω4n + 8ω3n2 + 2(1 + )kωn)))
= O((1 + )kn2ω−1 + n2ω+1 + n5)
= O((1 + )kn8/2−1 + n8/2+1 + n5).
Consider the first line of above deduction. Recall that the term n5 comes from
building Cs for s ∈ S. The summation and the term
(
n
m
)
arise due to exhaustively tak-
ing all the possibilities of Am (i.e., the set of m adjacent taxa) into consideration. The
term m2n3 comes from (2,2)-cleaning. The term mn3 comes from the preprocessing
of (1,3)-cleaning and quintet-cleaning. The term h(m) arises from the construction
of all possible evolutionary trees on Am ∪ {x}, where x is a taxon not in Am. The
terms m4n and m3n2 arise from (3,1)-cleaning. The rest term (1 + )kmn in the first
line is derived from the analysis of the size of depth-bounded search tree of (1,3)-
cleaning and quintet-cleaning. The second equality holds since m < 2ω − 2 < 2ω
and
(
n
m
) = O(nm). Therefore we have an O∗((1 + )k) fixed-parameter algorithm
for the parameterized MQI problem. Hence the following concluding theorem fol-
lows.
Theorem 9 There exists an O∗((1 + )k) time fixed-parameter algorithm for the pa-
rameterized minimum quartet inconsistency problem, where  is an arbitrarily small
constant and the degree of the involved polynomial in the running time has depen-
dence on .
Acknowledgement The authors thank anonymous referees for their careful reading and for their many
helpful comments.
Appendix
We list all the possible branching vectors as well as the corresponding branching
numbers for Algorithm FPA1-MQI in Tables 3–5. Note that we abbreviate topology
vectors, branching vectors and branching numbers to be t.v., b.v., and b.n. respec-
tively, and NB means there is no branching for the topology vector.
Theory Comput Syst (2010) 47: 342–367 365
Table 4 The possible branching vectors and branching numbers of Algorithm FPA1-MQI (part 2)
t.v. b.v. b.n. t.v. b.v. b.n.
(0,2,2,2,0) (3,4,3,3,1,4,5,4,4,2,3,1,3,5,5) 3.04454 (0,2,2,2,1) (4,5,4,4,2,3,4,3,3,1,3,1,3,5,5) 3.04454
(0,2,2,2,2) NB NB (1,0,0,0,0) (1,1,2,4,4,3,4,3,3,4,3,5,5,3,5) 3.04454
(1,0,0,0,1) (2,2,3,5,5,2,3,2,2,3,3,5,5,3,5) 2.67102 (1,0,0,0,2) (2,2,3,5,5,3,4,3,3,4,2,4,4,2,4) 2.54314
(1,0,0,1,0) (2,2,3,3,4,2,3,2,4,4,3,5,5,4,4) 2.54314 (1,0,0,1,1) (3,3,4,4,5,1,2,1,3,3,3,5,5,4,4) 3.04454
(1,0,0,1,2) (3,3,4,4,5,2,3,2,4,4,2,4,4,3,3) 2.46596 (1,0,0,2,0) (2,2,3,4,3,3,4,3,4,3,2,4,4,4,5) 2.46596
(1,0,0,2,1) (3,3,4,5,4,2,3,2,3,2,2,4,4,4,5) 2.54314 (1,0,0,2,2) (3,3,4,5,4,3,4,3,4,3,1,3,3,3,4) 2.55234
(1,0,1,0,0) (2,2,3,3,4,4,3,3,3,4,4,5,4,2,4) 2.46596 (1,0,1,0,1) (3,3,4,4,5,3,2,2,2,3,4,5,4,2,4) 2.54314
(1,0,1,0,2) (3,3,4,4,5,4,3,3,3,4,3,4,3,1,3) 2.55234 (1,0,1,1,0) (3,3,4,2,4,3,2,2,4,4,4,5,4,3,3) 2.46596
(1,0,1,1,1) (4,4,5,3,5,2,1,1,3,3,4,5,4,3,3) 3.04454 (1,0,1,1,2) (4,4,5,3,5,3,2,2,4,4,3,4,3,2,2) 2.54314
(1,0,1,2,0) (3,3,4,3,3,4,3,3,4,3,3,4,3,3,4) 2.30042 (1,0,1,2,1) (4,4,5,4,4,3,2,2,3,2,3,4,3,3,4) 2.46596
(1,0,1,2,2) (4,4,5,4,4,4,3,3,4,3,2,3,2,2,3) 2.46596 (1,0,2,0,0) (2,2,3,4,3,4,4,2,2,3,4,4,5,3,5) 2.54314
(1,0,2,0,1) (3,3,4,5,4,3,3,1,1,2,4,4,5,3,5) 3.04454 (1,0,2,0,2) (3,3,4,5,4,4,4,2,2,3,3,3,4,2,4) 2.46596
(1,0,2,1,0) (3,3,4,3,3,3,3,1,3,3,4,4,5,4,4) 2.55234 (1,0,2,1,1) NB NB
(1,0,2,1,2) (4,4,5,4,4,3,3,1,3,3,3,3,4,3,3) 2.55234 (1,0,2,2,0) (3,3,4,4,2,4,4,2,3,2,3,3,4,4,5) 2.46596
(1,0,2,2,1) (4,4,5,5,3,3,3,1,2,1,3,3,4,4,5) 3.04454 (1,0,2,2,2) (4,4,5,5,3,4,4,2,3,2,2,2,3,3,4) 2.54314
(1,1,0,0,0) NB NB (1,1,0,0,1) (3,1,3,5,5,3,4,3,1,3,4,5,4,2,4) 3.04454
(1,1,0,0,2) (3,1,3,5,5,4,5,4,2,4,3,4,3,1,3) 3.04454 (1,1,0,1,0) (3,1,3,3,4,3,4,3,3,4,4,5,4,3,3) 2.55234
(1,1,0,1,1) (4,2,4,4,5,2,3,2,2,3,4,5,4,3,3) 2.54314 (1,1,0,1,2) (4,2,4,4,5,3,4,3,3,4,3,4,3,2,2) 2.46596
(1,1,0,2,0) (3,1,3,4,3,4,5,4,3,3,3,4,3,3,4) 2.55234 (1,1,0,2,1) (4,2,4,5,4,3,4,3,2,2,3,4,3,3,4) 2.46596
(1,1,0,2,2) (4,2,4,5,4,4,5,4,3,3,2,3,2,2,3) 2.54314 (1,1,1,0,0) (3,1,3,3,4,5,4,4,2,4,5,5,3,1,3) 3.04454
(1,1,1,0,1) (4,2,4,4,5,4,3,3,1,3,5,5,3,1,3) 3.04454 (1,1,1,0,2) NB NB
(1,1,1,1,0) (4,2,4,2,4,4,3,3,3,4,5,5,3,2,2) 2.54314 (1,1,1,1,1) (5,3,5,3,5,3,2,2,2,3,5,5,3,2,2) 2.67102
(1,1,1,1,2) (5,3,5,3,5,4,3,3,3,4,4,4,2,1,1) 3.04454 (1,1,1,2,0) (4,2,4,3,3,5,4,4,3,3,4,4,2,2,3) 2.46596
(1,1,1,2,1) (5,3,5,4,4,4,3,3,2,2,4,4,2,2,3) 2.54314 (1,1,1,2,2) (5,3,5,4,4,5,4,4,3,3,3,3,1,1,2) 3.04454
(1,1,2,0,0) (3,1,3,4,3,5,5,3,1,3,5,4,4,2,4) 3.04454 (1,1,2,0,1) NB NB
(1,1,2,0,2) (4,2,4,5,4,5,5,3,1,3,4,3,3,1,3) 3.04454 (1,1,2,1,0) (4,2,4,3,3,4,4,2,2,3,5,4,4,3,3) 2.46596
(1,1,2,1,1) (5,3,5,4,4,3,3,1,1,2,5,4,4,3,3) 3.04454 (1,1,2,1,2) (5,3,5,4,4,4,4,2,2,3,4,3,3,2,2) 2.54314
(1,1,2,2,0) (4,2,4,4,2,5,5,3,2,2,4,3,3,3,4) 2.54314 (1,1,2,2,1) (5,3,5,5,3,4,4,2,1,1,4,3,3,3,4) 3.04454
(1,1,2,2,2) (5,3,5,5,3,5,5,3,2,2,3,2,2,2,3) 2.67102 (1,2,0,0,0) (2,1,1,3,3,4,5,4,3,3,4,4,5,3,5) 3.04454
(1,2,0,0,1) (3,2,2,4,4,3,4,3,2,2,4,4,5,3,5) 2.54314 (1,2,0,0,2) (3,2,2,4,4,4,5,4,3,3,3,3,4,2,4) 2.46596
(1,2,0,1,0) (3,2,2,2,3,3,4,3,4,3,4,4,5,4,4) 2.46596 (1,2,0,1,1) (4,3,3,3,4,2,3,2,3,2,4,4,5,4,4) 2.46596
(1,2,0,1,2) (4,3,3,3,4,3,4,3,4,3,3,3,4,3,3) 2.30042 (1,2,0,2,0) (3,2,2,3,2,4,5,4,4,2,3,3,4,4,5) 2.54314
(1,2,0,2,1) (4,3,3,4,3,3,4,3,3,1,3,3,4,4,5) 2.55234 (1,2,0,2,2) (4,3,3,4,3,4,5,4,4,2,2,2,3,3,4) 2.46596
(1,2,1,0,0) (3,2,2,2,3,5,4,4,3,3,5,4,4,2,4) 2.54314 (1,2,1,0,1) (4,3,3,3,4,4,3,3,2,2,5,4,4,2,4) 2.46596
(1,2,1,0,2) (4,3,3,3,4,5,4,4,3,3,4,3,3,1,3) 2.55234 (1,2,1,1,0) (4,3,3,1,3,4,3,3,4,3,5,4,4,3,3) 2.55234
(1,2,1,1,1) (5,4,4,2,4,3,2,2,3,2,5,4,4,3,3) 2.54314 (1,2,1,1,2) (5,4,4,2,4,4,3,3,4,3,4,3,3,2,2) 2.46596
(1,2,1,2,0) (4,3,3,2,2,5,4,4,4,2,4,3,3,3,4) 2.46596 (1,2,1,2,1) (5,4,4,3,3,4,3,3,3,1,4,3,3,3,4) 2.55234
(1,2,1,2,2) (5,4,4,3,3,5,4,4,4,2,3,2,2,2,3) 2.54314 (1,2,2,0,0) (3,2,2,3,2,5,5,3,2,2,5,3,5,3,5) 2.67102
(1,2,2,0,1) (4,3,3,4,3,4,4,2,1,1,5,3,5,3,5) 3.04454 (1,2,2,0,2) (4,3,3,4,3,5,5,3,2,2,4,2,4,2,4) 2.54314
Theory Comput Syst (2010) 47: 342–367 367
References
1. Ben-Dor, A., Chor, B., Graur, D., Ophir, R., Pelleg, D.: From four-taxon trees to phylogenies: the
case of mammalian evolution. In: Proceedings of the RECOMB, pp. 9–19 (1998)
2. Bandelt, H.J., Dress, A.: Reconstructing the shape of a tree from observed dissimilarity data. Adv.
Appl. Math. 7, 309–343 (1986)
3. Berry, V., Jiang, T., Kearney, P.E., Li, M., Wareham, H.T.: Quartet cleaning: Improved algorithms
and simulations. In: Proceedings of the 7th Annual European Symposium on Algorithms (ESA 99).
Lecture Notes in Comput. Sci., vol. 1643, pp. 313–324. Springer, Berlin (1999)
4. Cho, B.: From quartets to phylogenetic trees. In: Proceedings of the 25th Conference on Current
Trends in Theory and Practice of Informatics (SOFSEM). Lecture Notes in Comput. Sci., vol. 1521,
pp. 36–53. Springer, Berlin (1998)
5. Downey, R.G., Fellows, M.R.: Parameterized Complexity. Springer, Berlin (1999)
6. Erdo˝s, P., Steel, M., Székely, L., Warnow, T.: A few logs suffice to build (almost) all trees (Part 1).
Random Struct. Algorithms 14, 153–184 (1999)
7. Greene, D.H., Knuth, D.E.: Mathematics for the Analysis of Algorithms, 2nd edn. Progress in Com-
puter Science. Birkhäuser, Boston (1982)
8. Gramm, J., Niedermeier, R.: A fixed-parameter algorithm for minimum quartet inconsistency. J. Com-
put. Syst. Sci. 67, 723–741 (2003)
9. Jiang, T., Kearney, P.E., Li, M.: Some open problems in computational molecular biology. J. Algo-
rithms 34, 194–201 (2000)
10. Jiang, T., Kearney, P.E., Li, M.: A polynomial time approximation scheme for inferring evolutionary
tree from quartet topologies and its application. SIAM J. Comput. 30, 1942–1961 (2001)
11. Steel, M.: The complexity of reconstructing trees from qualitative characters and subtrees. J. Classif.
9, 91–116 (1992)
12. Niedermeier, R.: Invitation to Fixed-Parameter Algorithms. Oxford University Press, London (2006)
13. Niedermeier, R., Rossmanith, P.: A general method to speed up fixed-parameter algorithms. Inf.
Process. Lett. 73, 125–129 (2000)
14. Wu, G., You, J.-H., Lin, G.: A lookahead branch-and-bound algorithm for the maximum quartet con-
sistency problem. In: Proceedings of WABI 2005. Lecture Notes in Comput. Sci., vol. 3692, pp. 65–
76. Springer, Berlin (2005)
15. Wu, G., You, J.-H., Lin, G.: A polynomial time algorithm for the minimum quartet inconsistency
problem with O(n) quartet errors. Inf. Process. Lett. 100, 167–171 (2006)
Theory Comput Syst
1 Introduction
1.1 Property Testing
Let F be the set of all functions with the same domain D. Let P be a fixed property
of functions in F , which can be viewed as a subset of F . For two functions f,g ∈ F ,
let δ(f, g) denote the fraction of elements in D for which f and g have different
values. Obviously the range of δ is [0,1]. Then for a function f ∈ F , we define
(f, P) = ming∈P δ(f, g). We say that f satisfies the property P if (f, P) = 0.
We say that f is -far from satisfying P if (f, P) ≥ , otherwise f is said to be
-close to satisfying P . The complexity measure we concern is the query complexity,
where a query is an examination of the function value of an element of D, and we
assume that a query takes only constant time. The following definition of a property
tester is given by Goldreich et al. [16].
Definition 1 ([16]) Given a function f ∈ F and a parameter 0 <  < 1, a property
tester for P is an algorithm M making o(|D|) queries, such that
1. M returns “yes” with probability at least 2/3 if f ∈ P ;
2. M returns “no” with probability at least 2/3 if (f, P) ≥ .
Moreover, we say that M is a one-sided-error property tester if it returns “yes” when-
ever f satisfies P with probability 1. If M makes queries without knowing the results
of previous ones, we say that M is non-adaptive.
As clarified in [13, 20], the success probability ‘2/3’ in Definition 1 can be sub-
stituted by any arbitrary constant strictly greater than 1/2. In order to have success
probability of 1 − ρ for any ρ < 1/3, we can simply execute M for O(log(1/ρ))
times and return the majority of these outputs.
As mentioned in [20], property testing may be useful in some scenarios. For ex-
ample, suppose we have a slow exact decision procedure and a property tester for a
function. If the property tester answers “no”, then we know that with high probability
the function does not have the property. In particular, for one-sided-error property
testers, such a negative answer provides a witness that the function does not have
the property, and therefore it is not necessary to run the slow decision procedure.
Property testing is also useful when we can tolerate a small number of errors of the
function values. In such a scenario, we only care whether the function is “good” (i.e.,
has the property) or “very bad” (i.e., -far from having the property).
The general notion of property testing was first formulated by Rubinfeld and Su-
dan [21], who were motivated by the connection to program checking [7]. The study
on testing combinatorial objects was first introduced by Goldreich, Goldwasser, and
Ron [16]. Property testing is a very active field in theoretical computer science, espe-
cially in testing graph properties. See [1, 13, 15, 20] for surveys.
1.2 Quartets, Quintets, and Tree-Likeness
Determining the evolutionary relationship of a set of taxa is a very essential topic in
computational biology. In order to model such relationships, evolutionary trees are
Theory Comput Syst
Fig. 2 Three topologies for the
quartet {a, b, c, d}
Fig. 3 The fifteen topologies
for a quintet {a, b, c, d, e}
S = {a, b, c, d, e, f } and Q = {[ab|cd], [ab|ce], [ab|cf ], [ab|de], [ab|df ], [ab|df ],
[ab|ef ], [ac|de], [af |cd], [af |ce], [af |de], [bc|de], [bf |cd], [bf |ce], [bf |de],
[cf |de]}, then Q is tree-like since it is exactly the set of quartet topologies induced
by T in Fig. 1(i). Let ϒ be the set of all tree-like sets of quartet topologies over S.
We call minQ∗∈ϒ |Q \ Q∗| the error number of Q. We call the quartet topologies
in Q \ Q∗ the quartet errors of Q if |Q \ Q∗| equals to the error number of Q for
Q∗ ∈ ϒ . Note that the number |Q \ Q∗| is equal to |Q∗ \ Q| since Q and Q∗ are
complete (if a quartet has a topology is in Q \ Q∗ then there must be a different one
of this quartet in Q∗ \ Q).
A quintet is a set of five taxa in S. Given a complete set of quartet topologies Q
over the taxon set S, we say that a quintet {a, b, c, d, e} ⊆ S is resolved with respect
to Q if the set of quartet topologies over {a, b, c, d, e} in Q is tree-like. Otherwise, we
say that {a, b, c, d, e} is unresolved with respect to Q. Similar to the quartet topology,
the quintet topology of a quintet {a, b, c, d, e} induced by an evolutionary tree T is the
path structure connecting a, b, c, d , and e in T . Without loss of generality, assume
that we have [ab|cd] induced by T , then there are five quintet topologies for the
quintet {a, b, c, d, e} induced by T since there are five positions for inserting e into
the tree structure of [ab|cd]. Since there are three different topologies for the quartet
{a, b, c, d}, there are fifteen quintet topologies for a quintet {a, b, c, d, e} (see Fig. 3).
Consider quintet topology (v) and quintet topology (x) in Fig. 3. Quintet topology (v)
induces five quartet topologies [ab|cd], [ab|ce], [ab|de], [ac|de], and [bc|de], while
quintet topology (x) induces [ac|bd], [ac|be], [ab|de], [ac|de], and [bc|de], so there
are two quartets (i.e., {a, b, c, d} and {a, b, c, e}) whose topologies induced by quintet
topology (v) are different from those induced by quintet topology (x). By exhaustively
observing their induced quartet topologies, we obtain the following fact.
Fact 1 Any two topologies of a quintet differ in at least two induced quartet topolo-
gies.
Theory Comput Syst
exists a complete set of quartet topologies which is 0.04-far from being tree-like.
This fact suggests that for  = (1) testing tree-likeness of quartet topologies is not
trivial.2 Afterwards, we present the first property tester for this property, which is of
one-sided error and non-adaptive. The impossibility of extending our results to deal
with incomplete sets of quartet topologies is also clarified.
The rest of this paper is organized as follows. In Sect. 2, we prove the existence a
complete set of quartet topologies which is at least 0.04-far from being tree-like. In
Sect. 3, we give a non-adaptive property tester for tree-likeness of quartet topologies,
which uses O(n3/) queries and has only one-sided error. Finally, in Sect. 4 we give
some concluding remarks and clarify the impossibility of extending our results to
incomplete sets of quartet topologies.
2 Existence of a Complete Set of Quartet Topologies which is at Least 0.04-far
from Being Tree-Like
In this section, we show that there exists a complete set of quartet topologies that is
at least 0.04-far from being tree-like, that is, its error number is at least 0.04
(
n
4
)
. The
sketch of the proof is as follows. First, we show that there exists a set of γ
(
n
4
)
quintets
U over S for some constant γ , such that every two quintets of U do not share any
quartet. We present two ways for constructing such a set U and show that γ ≥ 0.04.
Second, by considering an arbitrary tree-like set Q∗, for each quintet u ∈ U with
respect to Q∗, we change one quartet topology of the subset quartets of u to make u
unresolved. We show that the error number of the resulting set of quartet topologies
is at least 0.04
(
n
4
)
.
A Simple Construction of U Let us label the taxa in S by S = {s1, s2, . . . , sn}. Let U
denote the set {{sn/5+i1, s2n/5+i2 , s3n/5+i3 , s4n/5+i4 , si1+i2+i3+i4} | 1 ≤ i1, i2, i3, i4 ≤
n/20}. Clearly the five taxa of every element of U are distinct, U is indeed a set of
quintets over S. Moreover, each 4-tuple (i1, i2, i3, i4) corresponds to a quintet in U ,
so the size of U is (n/20)4 = n4/160000 > 0.0015(n4
)
.
Lemma 1 Any two quintets in U do not share any quartet.
Proof Assume the contrary that two quintets u,v in U share a quartet. Let u =
{sn/5+i1 , s2n/5+i2 , s3n/5+i3 , s4n/5+i4 , si1+i2+i3+i4} and v = {sn/5+j1 , s2n/5+j2 , s3n/5+j3 ,
s4n/5+j4 , sj1+j2+j3+j4} respectively, where 1 ≤ i1, . . . , i4, j1, . . . , j4 ≤ n/20. If u and
v share the quartet {sn/5+i1, s2n/5+i2 , s3n/5+i3 , s4n/5+i4}, that is, i1 = j2, i2 = j2,
i3 = j3, i4 = j4, we have i1 + i2 + i3 + i4 = j1 + j2 + j3 + j4. Then u and v are actu-
ally the same quintets, so a contradiction occurs. As for the other possibilities that u
and v share a quartet, without loss of generality, we assume that they share the quartet
{sn/5+i1 , s2n/5+i2 , s3n/5+i3 , si1+i2+i3+i4}. We obtain that i1 = j1, i2 = j2, i3 = j3 and
i1 + i2 + i3 + i4 = j1 + j2 + j3 + j4, then we also have i4 = j4. Hence u and v are the
same quintet, and then another contradiction occurs. Thus, the lemma is proved. 
2If any complete set of quartet topologies is η-close to be tree-like for some η = o(1), then for any  =
(1) a trivial algorithm that always answers “yes” suffices to be a property tester for this property.
Theory Comput Syst
Table 1 A property tester for
tree-likeness of quartet
topologies
1. Pick an arbitrary taxon 
 ∈ S, and then repeat (a) and (b) for 72 n3
times.
(a) Pick four taxa s1, s2, s3, s4 ∈ S \ {
} uniformly at random.
(b) If the quintet {s1, s2, s3, s4, 
} is not resolved, then
return “no”.
2. Return “yes”.
Theorem 2 ([3]) Given a set of taxa S, a complete set of quartet topologies Q over S,
and a fixed taxon 
 ∈ S, Q is tree-like if and only if every quintet containing 
 is
resolved.
Remarks It follows from Theorem 2 that we can determine whether Q is tree-like
by examining quintets with respect to Q. If Q is not tree-like (i.e., the error number of
Q is at least one), by Theorem 2, we know that for any fixed taxon 
 ∈ S, there exists
an unresolved quintet containing 
. Hence it is clear that the number of unresolved
quintets with respect to Q is at least (n), which yields an O(n4) deterministic
algorithm to see if Q is tree-like. Intuitively, we expect more unresolved quintets
when the error number of Q gets larger. In particular, if the error number of Q is at
least cn4 for some constant c, we expect to have a large number (e.g., c′n5 for some
constant c′) of unresolved quintets with respect to Q since each quartet is contained
in n − 4 quintets. The more unresolved quintets exist, the less queries are required to
find one of them. However, it is difficult to give an accurate estimate of the number
of unresolved quintets due to the following reason. Assume that Q∗ is a tree-like set
of quartet topologies such that |Q \ Q∗| is equal to the error number of Q. Clearly,
Q can be derived from Q∗ by changing the quartet topologies in Q∗ \ Q one by one.
However, changing a quartet topology may either make a set of unresolved quintets
resolved or make a set of resolved quintets unresolved. After |Q \ Q∗| changes, it is
difficult to say how many unresolved quintets exist with respect to Q.
We now consider the case that Q is -far from being tree-like. That is, one has to
change at least 
(
n
4
)
quartet topologies to make Q tree-like. The following theorem
provides an improved lower bound on the number of unresolved quintets.
Theorem 3 If Q is -far from being tree-like, then for an arbitrary taxon 
 ∈ S, there
exist more than n/36 unresolved quintets containing 
.
Proof Assume that Q is -far from being tree-like. First, fix an arbitrary taxon 
. Let
S∗ be a maximal subset of S containing 
 such that the subset QS∗ of Q over S∗
is tree-like, and let S′ = S \ S∗. It is clear that adding any further taxon of S′
into S∗ will cause inconsistency (i.e., the set of quartet topologies over S∗ is not
tree-like). The size of S′ can never be o(n), otherwise, Q can be modified to be
tree-like by simply changing the quartet topologies {[a1a2|a3b] | a1, a2, a3 ∈ S∗, b ∈
S′} ∪ {[a1a2|b1b2] | a1, a2 ∈ S∗, b1, b2 ∈ S′} ∪ {[ab1|b2b3] | a ∈ S∗, b1, b2, b3 ∈ S′} ∪
{[b1b2|b3b4] | b1, b2, b3, b4 ∈ S′}, and the number of these changes of quartet topolo-
gies is at most
(
n−o(n)
3
) · (o(n)1
) + (n−o(n)2
) · (o(n)2
) + (n−o(n)1
) · (o(n)3
) + (o(n)4
) = o(n4),
which contradicts the assumption that the error number of Q is at least 
(
n
4
)
. Thus
Theory Comput Syst
Fig. 4 The tree structure with
the quartet topology [ab|cd]. T1,
T2, T3, T4, and T5 are subtrees
Fig. 5 Q = {[ab|cd], [ab|ce],
[ad|bf ], [be|df ], [cd|ef ]}.
Each quintet over
S = {a, b, c, d, e, f } is partially
resolved
ment, whether the query complexity of testing tree-likeness of quartet topologies can
be proved to be independent of n still remains open.
One might be curious about whether our results can be extended to incomplete
sets of quartet topologies. Unfortunately, it seems to be impossible since Theorem 2
is not true when the set of quartet topologies Q is incomplete. Let us say a quintet
is partially resolved if the set of quartet topologies over this quintet in Q is tree-
consistent (but not necessarily tree-like). The following example illustrates that there
exists an incomplete set of quartet topologies Q, such that Q is not tree-consistent
even when each quintet is partially resolved with respect to Q.
Let Q = {[ab|cd], [ab|ce], [ad|bf ], [be|df ], [cd|ef ]} be a set of quartet topolo-
gies over S = {a, b, c, d, e, f }. Obviously, Q is not complete. The (65
) = 6 quintets
over S are {a, b, c, d, e}, {a, b, c, d, f }, {a, b, c, e, f }, {a, b, d, e, f }, {a, c, d, e, f },
and {b, c, d, e, f }. Let us first observe the possible topologies of the quintet
{a, b, c, d, e}. Figure 4 depicts the evolutionary tree with the quartet topology
[ab|cd]. Since [ab|ce] ∈ Q, as Fig. 4 shows, e has to be in T3, T4, or T5. Simi-
larly, f has to be in T2. Then the induced topology of the quartet {b, d, e, f } on the
evolutionary tree can only be [bf |de]. Since this conflicts with the assumption that
[be|df ] ∈ Q, we derive that Q is not tree-consistent (Q is clearly not tree-like since
Q is incomplete). However, as Fig. 5 shows, each of these six quintets is partially
resolved.
In the above example, each quintet has at most two of its subset quartets with
topologies in Q. One might conjecture that if the input Q is “dense enough”, that is,
almost all the subset quartets of each quintet have topologies in Q, then we might
be able to derive that Q is tree-consistent if and only if each quintet is partially re-
solved. However, the following example disproves this conjecture. Let Q = {[ab|ce],
[ac|bf ], [ab|de], [ad|bf ], [ae|bf ], [ad|ce], [ac|df ], [af |ce], [bd|ce], [bf |cd],
[bf |ce], [bf |de], [ce|df ]} be a set of quartet topologies over S = {a, b, c, d, e, f }.
Theory Comput Syst
phylogenies from quartets: elucidation of eutherian superordinal relationships. J. Comput. Biol. 5,
377–390 (1998)
5. Berry, V., Gascuel, O.: Inferring evolutionary trees with strong combinatorial evidence. Theor. Com-
put. Sci. 240, 271–298 (2000)
6. Berry, V., Jiang, T., Kearney, P.E., Li, M., Wareham, H.T.: Quartet cleaning: improved algorithms
and simulations. In: Proceedings of the 7th Annual European Symposium on Algorithms (ESA 99).
Lecture Notes in Comput. Sci., vol. 1643, pp. 313–324. Springer, Berlin (1999)
7. Blum, M., Luby, M., Rubinfeld, R.: Self-testing/correcting with applications to numerical problems.
J. Comput. Syst. Sci. 47, 549–595 (1993)
8. Bryant, D., Steel, M.: Constructing optimal trees from quartets. J. Algorithms 38, 237–259 (2001)
9. Chor, B.: From quartets to phylogenetic trees. In: Proceedings of the 25th Conference on Current
Trends in Theory and Practice of Informatics (SOFSEM). Lecture Notes in Comput. Sci., vol. 1521,
pp. 36–53. Springer, Berlin (1998)
10. Chang, M.-S., Lin, C.-C., Rossmanith, P.: New fixed-parameter algorithms for the minimum quartet
inconsistency problem. Theory Comput. Syst. 47, 342–368 (2010)
11. Colonius, H., Schulze, H.H.: Tree structures for proximity data. Br. J. Math. Stat. Psychol. 34, 167–
180 (1981)
12. Erdo˝s, P., Steel, M., Székely, L., Warnow, T.: A few logs suffice to build (almost) all trees (Part 1).
Random Struct. Algorithms 14, 153–184 (1999)
13. Fischer, E.: The art of uninformed decisions: A primer to property testing. Bull. Eur. Assoc. Theor.
Comput. Sci. (EATCS) 75, 97–126 (2001)
14. Felsenstein, J.: Inferring Phylogenies. Sinauer Associates, Inc., Sunderland
15. Goldreich, O.: Combinatorial property testing—a survey. In: Pardalos, P., Rajaseekaran, S., Rolin, J.
(eds.) Randomization Methods in Algorithm Design. DIMACS Series in Discrete Mathematics and
Theoretical Computer Science, vol. 43, pp. 45–59. AMS, Providence (1998)
16. Goldreich, O., Goldwasser, S., Ron, D.: Property testing and its connection to learning and approxi-
mation. J. ACM 45, 653–750 (1998)
17. Gramm, J., Niedermeier, R.: A fixed-parameter algorithm for minimum quartet inconsistency. J. Com-
put. Syst. Sci. 67, 723–741 (2003)
18. Jiang, T., Kearney, P.E., Li, M.: Some open problems in computational molecular biology. J. Algo-
rithms 34, 194–201 (2000)
19. Jiang, T., Kearney, P.E., Li, M.: A polynomial time approximation scheme for inferring evolutionary
tree from quartet topologies and its application. SIAM J. Comput. 30, 1942–1961 (2001)
20. Ron, D.: Property testing. In: Rajasekaran, S., Pardalos, P.M., Reif, J.H., Rolim, J.D.P. (eds.) Hand-
book of Randomized Computing, vol. II, pp. 597–649. Kluwer Academic, Dordrecht (2001)
21. Rubinfeld, R., Sudan, M.: Robust characterization of polynomials with applications to program test-
ing. SIAM J. Comput. 25, 252–271 (1996)
22. Steel, M.: The complexity of reconstructing trees from qualitative characters and subtrees. J. Classif.
9, 91–116 (1992)
23. Verwer, R.W.H., Pelt, J.V.: Analysis of binary trees when occasional multifurcations can be considered
as aggregates of bifurcations. Bull. Math. Biol. 52, 629–641 (1990)
2生，頓時讓我不覺得有離家萬里的感覺。
大會總共接受三十一篇口頭發表的論文，八篇以 poster 形式發表的精簡
論文(收錄於會議論文集)，以及五篇 poster 論文。三天的論文發表期間，大會
另外安排了四場邀請演講 (invited talks) 都很精彩。
在口頭論文發表以及邀請演講的空檔，不少學者、學生來觀看我的 poster
並進行討論，頗有收穫。會議期間，認識一位正在 King’s College London 訪問
的日本 Kysuhu university 的助理教授 小野 廣隆 (Hirotaka Ono)，他研究的
領域與我很相近，研究成果很好，我口頭邀請他訪問我們學校。另外認識一位
由泰國以及一位由越南赴日留學的兩位日本學生，經過與他們交談，發覺日本
教育界以獎學金吸引不少東南亞的學子赴日留學。
開完會的隔天，即搭機返國。
二、與會心得
感謝國科會以及學校的經費贊助，讓我可以參加這次學術會議。這是個與
我的研究領域相當契合的學術會議，除了發表論文增加能見度外，透過與與會
者的交流讓我更了解這個領域的發展現況，也獲得一些研究的新方向，對我的
研究很有幫助。
除了專業上的收穫之外，我也有一些對於歐美學術界的觀察。最近幾年參
加歐、美舉辦的學術會議之後，發覺歐美學者在研究上交流非常密切。相同領
域的學者經常合作發表論文。與國內大多由教授帶領自己學生做研究的情形大
異其趣。這次與參加會議的一位法國學者交談，才知道他並沒有指導任何碩士
生或博士生，但是他還是每年可以發表一兩篇期刊論文以及兩三篇會議論文，
這些論文成果，都是透過與同事甚至英、美、澳洲、加拿大等同行的合作的成
果。研究很不容易有成果的，透過交流集多數人的智慧可以事半功倍，這是我
們必須學習的，也由於如此我們才有可能國際化，才能提升我們的競爭力。國
內學者雖多，但是相較於全世界的學者仍屬少數。由於研究領域分工精細，在
國內不容易找到相同領域的學者一起合作，這時候惟有透過國際交流，才比較
有機會找到志同道合的研究夥伴一起合作。假如我們不積極進行國際交流，我
們的學術研究成果很難在國際上展露頭角。歐美學術界應該已經看出這點，因
此他們學術交流經費非常充裕。根據我們留英的學生的說法，他的指導教授一
年出國開學術會議進行交流的旅費預算幾乎沒有上限，今年他也已經隨著指導
教授出國開學術會議兩、三次以上，他的指導教授一年出國開會七、八次以上。
另外我也發覺歐美學術界熱中舉辦學術會議。舉辦學術會議若可以吸引全世界
無衍生研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
