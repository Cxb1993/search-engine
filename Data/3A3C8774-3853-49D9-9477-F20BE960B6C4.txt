II 
 
行政院國家科學委員會專題研究計畫成果報告 
以 SmartARM 為基礎的可重組計算系統平台之 FPGA 研製(2/2) 
The Design and FPGA Implementation of a Reconfigurable 
Embedded System Platform Based on SmartARM CPU(2/2) 
計畫編號：NSC  95－2221－E－035－009 
執行期限：95 年 8 月 1 日至 96 年 7 月 31 日 
主持人：王壘   逢甲大學電機系 
共同主持人：劉嘉政   逢甲大學資工系 
計畫參與人員：羅宏毅 李進貴  逢甲大學電機系 
 
中文摘要 
本計畫為期兩年，第一年之目標是利用以前已完成的 ARM9 相容之處理器核心
(SmartARM)為基礎，定義並完成 ARM9 處理器晶片的界面及接腳設計，並在計算機結
構上持續開發適於嵌入式系統的硬體支援設計。其主要研究成果包含：完成 SmartARM
核心與 FPGA 實驗平台的整合設計，完成 BBQ 分支預測電路的改良及全面的模擬評估。 
至於在本年度的第二年研究中，則除了完成於 FPGA 實驗平台的處理器整合驗證
外，對 BBQ 分支預測電路也做了進一步的改良與模擬驗證，且對嵌入式系統之硬體安
全架構，亦開發出有別於傳統系統安全技術的硬體安全架構。 
關鍵詞：FPGA、系統安全、分支預測、BBQ 
 
Abstract 
This project is a two-year research program that concentrates on the hardware design 
and the improvement of embedded processors. Based on the processor core, named 
SmartARM, which is an ARM9 compatible embedded processor, the major research results of 
this project in the first year include: Completing the integration design for SmartARM 
processor core into the FPGA platform. A complete simulation is made for the branch 
prediction mechanism, BBQ, and then modifies the design to improve its efficiency. 
For the research progress in the second year, there are three major achievements are 
produced: The verification for the whole chip design has been completed on the 
implementation platform. The branch prediction circuit, BBQ, is been further improved and 
evaluated. Moreover, the project also proposes a hardware security model to support the 
security of embedded systems. Unlike the traditional methods for hardware security support, 
this model is much simpler and suitable for the usage in handheld equipments. 
 
Keywords: FPGA, system security, branch prediction, BBQ 
 
  1  
報告內容 
一、前言 
本計劃藉著逢甲大學資電學院「嵌入式系統發展研究中心」之助整合資訊系已開
發之「動態可重組計算系統雛形」，開發一個以 ARM 架構為核心的「FPGA 動態可重
組計算系統平台」，以兩年的時間將已有的研究成果(SmartARM CPU 核心的設計)實踐
於本平台中，並為未來 SoC 系統及應用設計，奠定紮實且具特色的基礎。本計劃目前
的研究成果可分為以下四個方向敘述： 
1. 可重組計算機系統平台： 
我們所選擇之實驗平台為「嵌入式系統發展研究中心」自行設計之 FPGA 程式
燒錄實驗平台的改良型號：mFCU-PCI010。為完成設計，我們在已設計完成的
SmartARM[1]之外，加入負責與 Local Bus 間進行協調以模擬記憶體存取的記憶體
介面電路。在控制訊號定義完成後，設計記憶體介面之 VHDL 電路，並將之實際燒
錄至 mFCU-PCI010 晶片中進行實測。透過 Xilinx 電路設計軟體，我們已逐步完成
記憶體介面電路與 SmartARM 的整合，並藉由比較執行測試程式完畢後由 SRAM
中所取出之資料是否符合預期結果，完成對整個處理器電路的驗證測試。 
2. 分支預測機制 BBQ[2]的模擬及改良： 
本計畫在以往的研究中開發了一個針對迴路(Loop)之迴向分支指令(Backward 
Branch)行為的分支預測機制，該硬體命名為 BBQ(Backward Branch prediction 
Queue)，該預測機制目前亦已申請專利(申請號 095112523)，目前正公告中。而本
研究中，透過對部份程式結構在 BBQ 模擬中所顯露的特性，對 BBQ 再加以改良，
分別提出 Stacked BBQ 及 Circular BBQ 兩種改良設計，預計可再提升 BBQ 12%及
25%的效率[3]。 
3. ILP 技術的持續引入： 
在本年度的第一年研究中，觀察了 ARM 實行的 Predicated Execution 的方式，
發現只使用了一組 N,Z,C,V 旗標，若在執行程式中的某一個分支指令後又隨即發生
另一個分支指令(此在多重條件測試當中經常出現)，可能會發生旗標被重新設定，
而導致程式的執行判斷錯誤。因而本研究在 ILP 技術的研究方面，首先選擇了建立
Predicated 的替代方案，由原本利用 N,Z,C,V 旗標控制 Predication 擴展成利用多組
暫存器儲存條件指令抑制執行，並且發展出更具功能性的條件型態(Type)。再開發
新的指令格式，使用 Predicated Register 用以執行類似 Full Predication 指令，以充份
發揮 Predicated Execution 的效果。 
4. 手持式資訊設備的資料私密性保護架構[4]： 
在本年度的第二年研究中，針對 PDA、行動電話等特殊的應用及儲存特性，開
發新型式且簡易、低成本的資訊保密機制。此一機制有別於傳統的資訊安全思考模
式，能針對 PDA、行動電話等特殊的應用及儲存特性，以極低的代價產生資訊保密
的效果，即使設備完全落入他人的手中，也無虞個人資料會被盜取。 
二、研究目的 
為了發展一個以 CPU 為主，FPGA 為輔的快速雛形發展系統，系統中的 CPU 即
扮演最核心且重要的關鍵，本計劃以兩年的時間，將已有的研究成果(SmartARM CPU
核心的設計)實踐於本系統中，並為未來 SoC 系統及應用設計，奠定紮實且具特色的基
礎。本計劃的研究目的可分為以下三個方向敘述： 
1. 完成以 SmartARM 為 CPU 核心的可重組計算機系統平台 
以「可重組計算系統平台」的快速雛型電路為基礎，完成可重組計算機系統平台
  3  
重新整理通訊/系統安全的各種安全/加密技術，並檢討嵌入式系統在特定領域
(手持式通訊/資訊處理設備)的應用特性，開發結構簡單、省電快速的硬體安全架構。 
三、研究方法 
以下說明乃按照前節所述的三大研究方向，逐項說明之。 
1. 完成以 SmartARM 為 CPU 核心的可重組計算機系統平台 
我們將 SmartARM 燒錄至 FPGA 晶片平台，透過外部輸入指令以進行測試。我們所
選擇之實驗平台為「嵌入式系統發展研究中心」自行設計之 FPGA 程式燒錄實驗平台
PCI-mFCU 實驗板的改良型號，mFCU-PCI010。此實驗板之系統架構如圖 1 所示，具有
PCI 9052 控制晶片、可燒錄 FPGA 晶片組(Spartan II XC2S200-5 PQ208 x2)、CPLD 晶片
(XC9572XL)、32bits(8bits x 4) Static Ram (0.5MB)與 8/16 bits Smart5 Flash memory (2MB)
等元件。其中 FPGA 晶片組用作電路設計燒錄使用。我們透過板上屬於 FPGA 晶片的
JTAG port，使用 Boundary Scan Mode 將設計電路燒錄至 CPLD 與 FPGA 中。其中 CPLD
晶片乃作為系統中的控制電路使用，並可另行加入所需的功能設計。 
 
圖 1. mFCU-PCI010 架構圖 
在此系統中，PCI-9052 晶片所提供之控制功能可以達到下述效果：在上行端 PCI 
9052 晶片可以透過 PCI 介面與電腦進行資料交換，而在下行端 PCI 9052 透過 Local Bus
與分佈在 Bus 上之各元件進行資料交換，此時 PCI 9052 晶片扮演 Local Bus Master，各
元件間之資料均需透過 PCI 9052 方能進行資料傳輸。 
我們將 SmartARM 燒錄至 FPGA 並欲進行驗證時，若以電腦透過 PCI 介面直接輸入
指令並觀察輸出結果，將因 PCI 介面頻寬不足以應付 SmartARM 的需求而發生困難並增
加設計複雜度。因此在我們的設計中，SmartARM 所需之指令碼與資料將改由同樣在
Local Bus 上之 SRAM 提供，此時則需考慮 Local Bus 的控制權問題。使用者首先將驗證
用的程式與相關資料透過 PCI 介面輸入 SRAM 中，接著控制 FPGA 中的 SmartARM 使
其取代 PCI 9052 成為 Loacal Bus Master 並開始由 SRAM 中取得指令並加以執行。當驗
證程式執行完畢，再令 PCI 9052 重新成為 Local Bus Master 並透過 PCI 介面將 SRAM 中
所儲存之執行結果輸出至電腦中，最後以電腦程式處理執行結果並完成驗證流程。 
在考慮以上需求後，我們將 SmartARM 記憶體介面電路規劃如圖 2 所示。其中指令
位址、資料位址、指令輸入、資料輸入與資料輸出均為 32-bit 之線路，作為 SmartARM
與記憶體間的資料存取使用。值得注意的是 Local Bus 的規格中，由於 Local Bus 之資料
傳輸為 32-bit，其位址線設計為[27:2]共 26-bit，意味著我們在安排指令位址與資料位址
  5  
二年)兩方面敘述： 
2.1 Predicated Execution 技術開發 
ARM 指令集架構有支援 Predicated 的技術，幾乎所有指令都可以使用「條件式執
行」，也就是說如果 Assembler 指令後面附加有條件符號，在轉換成機械碼後會存於指令
[31:28]中。指令在執行時指令[31:28]必須符合 N,Z,C,V 四種旗標在 CPSR 中所指定的狀
態，否則就執行 NOP；然而觀察了 ARM 實行的 Predicated 的方式，發現只使用了一組
N,Z,C,V 旗標，若在執行程式中的某一個分支指令後又隨即發生另一個分支指令，可能
會發生旗標被重新設定，而導致程式的執行判斷錯誤。例如圖 3 所示，當 While 指令發
生，第一組比較完後記錄在旗標上，再比較第二組後也記錄在旗標上，同時有兩個以上
的比較結果，但 N,Z,C,V 旗標只有一組，因而將造成判斷錯誤。因此本計劃將針對此類
問題，進行研究改良以提升正確率。 
 
 
 
 
 
 
 
 
 
 
 
 
圖 3. 具雙重條件判斷的迴圈條件 
除了上述一組旗標可能發生錯誤外，ARM 的指令集架構為了能夠實行 Predicated 
Excution，除了限制使用的情形外，另也需要使用到更多道的指令去完成，造成指令數
的增加，效能可能因此大打折扣。本研究為了充份發揮 Predicated Execution 的效果，決
定為 SmartARM 建立 Predicated 的擴充方案，將原旗標利用 N,Z,C,V 控制 Predication 擴
展成利用多組暫存器儲存條件指令抑制執行，並且發展出更具功能性的條件型態
(Type)。並開發新的指令格式，使用 Predicated Register 的概念以執行類似 Full Predication
之指令效果。 
2.2 BBQ 的模擬與改良 
在迴向的分支指令(Backward Branch)的特性觀察中，我們發現如果遇到巢狀迴圈時
有其特性可循，根據巢狀迴圈之分支行為，本研究在以往即開發了一個針對迴路(Loop)
之迴向分支指令(Backward Branch)行為的 Branch Prediction 設計，該硬體命名為 BBQ，
由於 BBQ 的設計十分適合 Embedded Processor 的需求，且為一創新理念的設計，因而
成為本系列研究中最具學術價值且最有創新成果的部份。而 BBQ 預測機制目前亦已申
請專利(申請號 095112523)，目前正公告中。 
本研究在第一年完成了對嵌入式處理器相關應用程式的模擬觀察，根據我們的統
計，BBQ 迴向分支預測機制能以極低的硬體成本，產生對迴向分支平均達 87.32%，最
佳達 99.99%的預測正確性，並在程式執行上達到加速 8.62%的效果。而在嵌入式處理器
有其特定的應用行為上，若 BBQ 預測機制應用於 Network 與 Consumer Devices 的嵌入
式處理器，BBQ 能以其 90%以上的預測正確性提升效能並達到最佳效能/成本比。 
根據模擬的結果，我們將 BBQ 的改進目標轉至如圖 4 所示之程式迴圈結構，圖 4(a)
在原本 BBQ 預測機制可能會造成預測失誤的情況，其僅因每個迴圈初次建構迴圈以及
離開迴圈的時候會造成預測失誤，由於離開迴圈之後若未有迴向分支指令使其重複執
行，因此造成的損失之比例較小，而當迴圈結構如圖 4(b)時圖中的 C 迴圈包含 A 迴圈
C M P  a= b
C M P  c= d
InsBIn sA
W hile (a= b  & &  c= d)
  7  
資料可能遭到惡意修改。雜湊運算可利用樹狀（Tree）資料結構的概念一層一層進行資
料驗證的 Hash Tree，此一方式可加快取（Cache）的技術以加快驗證速度（Cache Hash 
Tree），或是運用 incremental multiset hash function 的 Log Hashes 以達到加速的目的。 
 
圖 5 資料完整性驗證示意圖 
  在可攜式電子裝置的安全考量上，由於經常有遺失或送修的風險存在，因而本
研究所針對的研究議題為資料私密性的技術，使裝置內儲資訊在即使裝置完全落入他人
手中的情況下也無法藉任何軟／硬體手法被取得。由於可攜式電子裝置大多數使用記憶
卡為資料的儲存體，因此本研究將資料私密性實現於快閃記體之類的非揮發性記憶體
（Flash Memory）的技術。至於對資料完整性的安全考量，則亦將因私密性機制的保護
導致有心者無法將錯誤訊息有意義的寫入原有資料中，因而達到入侵的察覺
（tamper-evidence）之效果。 
四、結果與討論 
本計畫所研究的各個方向之成果及預期目標如下所述： 
1. 完成以 SmartARM 為 CPU 核心的可重組計算機系統平台 
我們根據前節所述之電路規格與定義，設計記憶體介面之 VHDL 電路，並在設計完
成後將之實際燒錄至 mFCU-PCI010 晶片中進行實測。藉由比較執行測試程式完畢後由
SRAM 中所取出之資料是否符合預期結果，即可快速得知電路設計是否正確。 
為完成以上設計，我們在已設計完成的 SmartARM 之外，加入負責與 Local Bus 間
進行協調以模擬記憶體存取的記憶體介面電路。此電路需包含下述功能：轉送
SmartARM 對記憶體所送出之需求(如指令抓取)至 SRAM 中；將 SRAM 所傳回之資料送
至 SmartARM 中；與 PCI 9052 進行協調以獲取 Local Bus 控制權。 
我們首先考慮 SmartARM 與記憶體間的介面需求，分別為指令記憶體和資料記憶體
兩部分。在指令記憶體方面，SmartARM 進行指令抓取時，送出 32-bit 之指令位址至指
令記憶體並取回 32-bit 之指令碼；而在資料記憶體方面，當 SmartARM 執行 Load/Store
指令時即需藉由送出 32-bit 之資料位址並對資料記憶體進行 32-bit 之資料存取以獲得所
需資料。 
在記憶體介面需求外，我們接著考慮如何取得 Local Bus 控制權，PCI 9052 晶片利
用 LHOLD 與 LHOLDA 兩組訊號，作為 Local Bus 控制權移轉使用，其工作流程如圖 6
所示。當 Local Bus 上任一元件欲由 PCI 9052 處取得 Bus 的控制權時，首先需將連接至
元件本身之 LHOLD 訊號拉起並等待 PCI 9052 端回應。當 PCI 9052 將 LHOLDA 訊號拉
起後，該元件便取得 Bus 控制權。而在元件降下 LHOLD 訊號後，Bus 控制權方移交回
  9  
圖 8. 透過 SRAM 管理程式輸入啟動碼 EFFFFFF 
此時記憶體介面電路將因偵測到 Local Data Bus 上的啟動資料而開始工作，在由
PCI9052 處取得 Local Bus 控制權後開始讀取測試程式載入 SmartARM 電路中執行並將
執行結果寫回 SRAM 中。當我們透過 SRAM 管理程式輸入停止碼如圖 9 時，記憶體介
面電路再終止 SmartARM 電路執行並將 Local Bus 控制權歸還至 PCI9052 晶片，此時透
過 SRAM 管理程式即可取出執行結果觀察 SmartARM 是否正確執行測試程式。 
 
圖 9. 透過 SRAM 管理程式輸入停止碼 0FFFFFF 
圖 10 為執行後之程式結果，受限於晶片平台 mFCU-PCI010 所提供之 SRAM 大小，
我們所執行之測試程式僅包含基本指令與 SmartARM 支援的特殊指令而非完整的
Benchmark 程式，但已可觀察到此記憶體介面電路確能協調 SmartARM 電路與晶片平台
共同工作，並有效完成透過 PCI 介面與平台上之記憶體電路進行指令串流測試的目標。 
 
圖 10. 透過 Sram 控制程式由記憶體將輸出檔 outputfile 存回電腦 
2.  ILP 技術的持續引入： 
  11  
令或能造成程式流程改變之前置分支指令。當執行指令經解碼判斷為分支
指令時，若指令為迴向分支指令且發生跳躍時，會判斷其跳躍的目的位址
與 CBBQ 中最外層巢狀紀錄 M 所對應之跳躍紀錄是否構成巢狀，而在構
成巢狀迴圈的判斷上，其定義為:新的迴向分支指令其目的位址與 PC 包夾
M指標對應的儲存欄位(圖一(a)為例判斷BRz與BRy是否構成巢狀迴圈以
(Target(BRz)≧Target(BRy) && PC(BRz)＜PC(BRy)))判定；若未構成巢狀
則表示已脫離 CBBQ 已紀錄之巢狀迴路，兩者皆於 IE Stage 更新其對應之
CBBQ 欄位紀錄。CBBQ 曾否溢位用以判斷是否目前的迴圈紀錄是否已建
構至欄位末端而循環回到欄位開端，為避免巢狀迴圈存在於不連續的儲存
欄位上導致無法正確判定最內層迴圈所在位置，此時 CBBQ 將重新由開端
欄位建構巢狀迴圈。若指令為前置分支指令且發生跳躍時，則根據其跳躍
的目的位址與全 CBBQ 紀錄判斷控制指標是否需調整至正確的對應位置。 
 
圖 12. CBBQ 工作流程圖 
『IE Stage』：CBBQ 根據 ID Stage 的條件判斷後，在 IE 進行指標調整，其調整方式如
下所述，同樣可分為左線流程與右線流程： 
調整策略(ㄧ)：當 CBBQ 已記錄之迴向分支指令再一次被執行，預測其跳躍而的確發生
跳躍，此時 CBBQ 預測正確，根據巢狀迴圈的特性，若未有其他分支指令更改程式流
程，下次必然回到 CBBQ 所構建之巢狀迴圈最內層。CBBQ 將在比較該分支跳躍位址
與舊有紀錄而判斷出巢狀迴圈的最內層後，更改讀出預測位址的 Front 指標令其指向
巢狀迴圈的最內層，其餘指標保持不動。 
調整策略(二)：當 CBBQ 已記錄之迴向分支指令再一次被執行，預測其跳躍但因不符合
執行條件未發生跳躍時，因上述行為表示程式流程已脫離現在的迴圈而進行到下一層
迴圈，CBBQ 會將讀出預測位址的 Front 指標指向下一個儲存欄位(即指向下一層迴圈)
以進行預測，其餘指標則保持不動。 
  13  
40.0000%
50.0000%
60.0000%
70.0000%
80.0000%
90.0000%
100.0000%
bitc
oun
t
q-so
rt s
mal
l
cjpe
g
djpe
g
tiff2
b
dijk
stra sha crc ff
t
blow
fish
-e
blow
fish
-d
rijn
dae
l
ave
rage
BBQ 4 entry
CBBQ 4entry
 
圖 13. CBBQ 與原始 BBQ 之預測正確率比較 
3. 嵌入式系統的硬體安全架構研發 
本研究將焦點放在可攜式電子裝置的資料隱私保護，提出以下假設環境： 
(1) 裝置本身是可能落入他人手中的，可能是使用者疏忽遺失或遭惡意人士偷竊取
得。 
(2) 系統可能遭到攻擊者成功的入侵。 
  由於快閃記憶體具有低耗電量、高可攜性、抗震性強，是目前可攜式電子產品的儲
存元件首選，故本論文以快閃記憶體為討論主體。可攜式電子裝置通常不會搭配高規格
硬體或複雜的電路設計，以符合低耗電量、小體積等特性，因此要盡可能用簡單的邏輯
電路達成資料的隱私保護。 
  本研究提出的資料隱私保護機制與一般的做法不同，我們不以使用者身份來限制資
料存取的權限，亦即非獲得合法授權的惡意攻擊者也可以從裝置中順利的存取資料，但
是我們確保攻擊者拿到的資料是錯誤的。 
  在探討此安全機制前，首先定義「特徵」一詞，本文中所指的特徵是一組能區別個
人身分的資訊來源。由於文數字組合的密碼可能有使用者遺忘、遭攻擊者猜測的風險存
在，因此建議特徵的資訊採用使用者身上的個人生理特徵（如：指紋、視網膜、眼球虹
膜、語音辨識等，本文以下探討的加密機制均以指紋為例），並且特徵應具有以下特點： 
(1) 普遍性，每個人都具有的特徵。 
(2) 唯一性，即沒有任何兩人具有完全相同的特徵。 
(3) 恆久性，此特徵必須持久且不能被改變。 
(4) 可量測性，即特徵必須能被量測成可定量描述的數據指標。 
  特徵在系統中肩負兩項重要的功能，其一是分辨使用者；其二是擔任資料加解密的
關鍵金鑰，亦即將傳統上密碼驗證與金鑰加密的功能合而為一。並且為了讓資料能達到
理論安全，必須在系統上建構出 OTP（One-Time Pad）。 
  參考圖 14，藉由使用者提供的個人生物特徵與儲存裝置的位址（Address），將兩項
資訊經過對稱式加密演算法 AES 運算後得到的資料串接起來作為資料加密的 OTP。由
於特徵沒有儲存在系統之中，並且 OTP 加密資訊只有在資料進行存取時才即時產生，
攻擊者至多只能掌握產生 OTP 的運算架構與位址，除非攻擊者能脅迫使用者配合輸入
特徵，否則將無法正確產生加密 OTP 的資訊。 
  15  
圖 16.資料隱私性加密模型 
  綜合以上的架構分析，可將本研究所提出的資料私密性保護機制與一般常見的安全
保護機制做出如下的比較： 
1.一般常見的安全機制多以使用者提供的帳號、密碼對為系統資源保護依據，或是透過
系統上儲存的金鑰為資料加解密的依據；本研究所提出的資料私密性的保護架構則以
使用者的個人生物特徵為依據產生加解密的金鑰。 
2.系統上的保護機制通常依使用者的權限給予或限制資源的存取權限，可針對多位使用
者進行多層次複雜的存取權限管理；在通訊系統上主要著重在嚴謹、複雜的加解密演
算法以達到通訊上的鑑定性與不可否認性；本研究所提出的資料私密性保護架構則不
針對使用者做存取限制，亦即所有使用者均可存取資料，但保護機制確保只有合法的
使用者可以取得正確資料。 
3.傳統的身分認證將比對母體或是加解密用的金鑰均須儲存在系統之中，有遺失或遭竄
改的風險；本研究所提出的資料私密保護機制因沒有在系統上存放金鑰，因此沒有金
鑰遺失或遭竄改的問題存在。 
 
  17  
計劃成果自評 
本計劃接續以往研究成果的系列研究，更展開系所合作，透過本校「嵌入式系統發
展研究中心」的組織，於第一年度的研究中利用由資訊系主導研製的「動態可重組計算
系統雛形」改良版，完成以 SmartARM 為基礎的可重組計算系統平台之設計，並於第二
年的研究進程中將整個 5 Stages與ARM9核心相容的處理器電路逐步整合並完成最後的
電路實作及驗證。相關的電路設計也已與「動態可重組計算系統雛形」的另一型改良版
結合而成為一套適於在邏輯設計、數位系統等相關科目所施行的實驗實習教材，在逢甲
大學資電學院碩專班 96 學年度所開的＂SoC 系統晶片設計＂課程中，單任 ASIC 電路設
計實習部份的主要教材，使本系列研究的成果正式進入實用階段。 
而本系列研究中所提出迴向分支預測電路(BBQ)，亦因十分具有學術及原創性，在
完成了相關的硬體電路驗證、模擬分析檢討等工作，並提出中華民國及美國的專利的申
請。而在本計劃完成最後階段與 BTB 結合使用之效益評估後，亦已編寫論文投稿於國際
期刊(IEICE)[附錄 B]。而在本研究中，更根據 BBQ 的模擬分析結果，分別提出 Stacked 
BBQ 及 Circular BBQ 兩種改良設計，預計可再提升 BBQ 12%及 25%的效率。有關上述的
兩項改良成果，亦將在完成細部電路驗證後，提出專利的改良與期刊論文寫作。 
本研究原計劃在第二年度的研究中，配合本院另一計劃而對特定嵌入式系統的應用
(行動通訊網路之 Access Point)提出硬體支援設計；可惜由於該計劃未能獲得通過而取
消，改為對嵌入式系統的硬體安全架構展開探討，將系列研究的重心由處理器核心擴展
到系統層級的安全設計上。本研究方向也在第二年度的研究中產生初步的研究成果，針
對 PDA、行動電話等特殊的應用及儲存特性，提出以極低的代價產生資訊保密效果的硬
體安全架構，可使設備即使完全落入他人的手中，也無虞個人資料會被盜取。此一構想
亦已完成設計，並將初步成果編寫論文投稿於九十六年之國家計算機會議(NCS 2007)。 
本研究進行至今，亦有部份感到遺憾之處：首先是由於參與研究的人力不足，且缺
乏對 Compiler 相關研究有興趣及能力的研究人才，使本計畫原本要跨入層次較複雜，
需開發系統軟體技術支援的 ILP 技術(Speculative Execution)，卻無法在計畫中實現。
另外在研究成果的論文發表上，由於本計劃有相當的比例是著眼於硬體電路的設計驗證
上，尤其是整個處理器電路的設計及整合十分複雜費時，而該成果雖較具實用性卻也較
缺乏學術創新性，因而此一特性也就使得本研究在論文發表上較為失色。研究中的學術
重點：迴向分支預測電路 BBQ，也因不斷的檢討改善而使得期刊論文一直無法定稿，直
到本年八月才完成第一份文稿投遞。此一缺憾已影響了本系列研究的學術重要性，導致
無法於九十六年度獲得支持以持續在系統安全硬體上做更進一步的深入研究。未來在提
出研究構想及規劃研究重心上，將針對此一缺憾多做考慮，避免再花大量研究能量於硬
體細節設計上，並盡量加快期刊論文的撰寫進度，以期獲得他人的重視及支持。 
總結而言，本研究的主要研究成果包含： 
1. 以 SmartARM 為基礎的可重組計算系統平台之設計 
2. 處理器電路逐步整合並完成最後的電路實作及驗證 
3. 完成適於數位系統及電路設計的實驗實習教材(本教材已委由全華圖書出版成書) 
4. 迴向分支預測電路(BBQ)的兩種改良設計及效能分析 
5. 建立 ARM 架構在 Predicated Execution 方面的替代方案 
  19  
可供推廣之研發成果資料表 
█ 可申請專利  █ 可技術移轉                                      日期：96 年 10 月 31 日 
國科會補助計畫 
計畫名稱：以 SmartARM 為基礎的可重組計算系統平台之 FPGA
研製 
計畫主持人： 王 壘    逢甲大學電機系        
計畫編號：NSC 95－2221－E－035－009 學門領域：計算機系統結構
技術/創作名稱 
迴向跳躍指令預測機制之改良 
The enhancement for the mechanism of backward branch 
predictions 
發明人/創作人 王  壘 
技術說明 
中文： 
本研究過去曾提出針對迴向分支(Backward Branch)設計之預
測機制 BBQ (Backward Branch prediction Queues)，其運作機制乃基
於對構成迴圈之迴向分支指令加以記錄並作為預測來源，而不需盲
目儲存所有分支指令以進行預測。此一簡易的預測機制經由模擬程
式實驗發現，可在極低之硬體成本基礎上對迴向分支的預測正確
性，達到平均 87.32%以上的比例，並在整個程式執行上產生加速
8.62%的執行效果；然而在之前的研究中，我們注意到由於 BBQ 僅
針對巢狀迴圈結構加以考慮，以單一一組 BBQ 儲存最近執行的巢
狀迴圈之迴向分支指令；而透過模擬程式的觀察，發現在程式迴圈
結構中包含多個子迴圈會導致部份模擬程式預測正確率下降。 
本研究提出一改進技術，利用比較已儲存之迴圈記錄進行動態
的預測指標調整，並採取循環方式管理有限的 BBQ 儲存欄位以充
分保留有效的迴圈紀錄供預測使用之改良設計，稱之為
CBBQ(Circular Branch prediction Queues)。CBBQ 迴向分支預測機
制在對 BBQ 電路進行少量修改後，能產生對迴向分支平均達
90.51%的預測正確率而 CBBQ 改良之循環儲存管理機制，更可有
效解決複雜巢狀迴圈對 BBQ 預測機制的干擾問題且充分利用所有
儲存欄位進行分支預測，較原始 BBQ 在預測效率的改善上達到
25.15%的改進。 
（100~500 字） 
  21  
The Hardware Design for Stacked BBQ 
ARM9TDMI [1][2] is an architecture of embedded processors, comes from the most 
popular embedded processor family that share a great part of the IA market. It is widely used 
as the processing core of cellular phone, personal PDA, and hand-top game player. Since its 
popularity and simplicity, the architecture is selected as the base architecture for the design of 
BBQ. The previous chapter has introduced the behavior of stacked BBQ to cooperate with the 
datapath of ARM9 pipeline. This chapter exhibits the hardware design according to the 
definition described in the previous chapter.  
The block diagram of the stacked BBQ can be drawn as Figure 1. There are three major 
components contribute the prediction mechanism. They are stack controller, BBQ elements 
and dynamic adjust circuit. 
 
Figure 1. The block Diagram of Stacked BBQ 
• Stack controller 
It’s a specialized functional unit to record and control the usage of multiple BBQ 
prediction elements. It records the control entries of the executed routines in the order of 
FILO sequence, and assigns the adequate BBQ element from the multiple distinct elements to 
serve the prediction for dedicated routine. This is accomplished by enabling the BBQ element 
according to the lines of Element# issued by the controller in the figure. The unused element 
should be reset according to the lines of Valid and Reset# when it is pop by the controller. The 
stack controller can also identify the situation of recursive call and assign the same element 
for the recursive routine no matter how deep the recursive behavior did. 
• BBQ elements 
There are several BBQ elements to serve as the major prediction engines for program’s 
execution. An element can predict the execution of backward branches in a nest loop to 
  23  
As described in Figure 2, stack controller will identify a new subroutine and then push 
the new item for the subroutine if StackTop.entry is not equal to the target address of the 
decoded CALL instruction. The assigned element number, BBQ#, will be increased if the 
signal named USED comes from the current BBQ element is TRUE, otherwise the same 
element will be assigned to the new subroutine. On the other hand, if StackTop.entry is equal 
to the target address of the decoded CALL instruction, the condition shows that a recursive 
call is happened. The stack controller would identify the calling is the first time happened or 
not by comparing the value of Stacktop.RA and the value of NPC. If it is the first time 
execution of a recursive call, it will make a push operation for the subroutine and record it as 
a recursive routine, R-Flag be set to 1. Otherwise, if the condition, Stacktop.RA is equal to the 
value of NPC, is true, it shows that the called routine is the routine being executed and the 
calling is a recursive call for itself, then the stack will keep the same without change. 
The consideration for pop operation is little complex than push. According to the 
reservations about the binaries of real applications, we found that programmers sometimes 
may achieve the effect of return by the instruction of indirect jump but not RETURN 
instruction. The truth means that stacked BBQ can not expect the behavior of call/return will 
always happened by an instructions pair. For identifying the return operation achieved by 
other control transfer instructions, the stack controller will check the PC value of the fetched 
instruction with Stacktop.RA in the IF stage. If Stacktop.RA is equal to the value of PC, the 
return will be detected and then the coordinate pop operation will be done in this stage. For 
the operation identified in this stage is a return operation of recursive routine, the stack 
controller also can identify the condition, PC is equal to the value of the RA field of the item 
under the top, and then decide to pop 2 entries directly or just keep the stack entries without 
change to match the execution condition. 
In the ID stage, when a RETURN instruction is decoded and the condition Stacktop.RA 
is equal to the value of linkage register, that is the physical return address of the instruction. 
The controller can determine whether or not to pop the entry in the top of the stack by means 
of the value of R-Flag. However, when the condition is not true, the stack controller will 
directly pop 2 entries from the stack to catch the progress of execution. It is noted that this 
situation will be only happened in the condition of the return will cause the termination of the 
recursive execution and the execution flow will be transferred back to the original calling 
program.  
As shown in Figure 1, there are three major parts contributing the function of stacked 
controller. The Push Control and Pop Control are two combinational circuits that can make 
comparisons among addresses and signal stack storage to push or pop items. Based on the 
algorithm describe in Figure 2, the function description of Push Control can be described as 
following VHDL code: 
 Circuit Push ( Input Target[0:31], NPC[0:31], Stacktop.entry[0:31], 
Stacktop.RA[0:31], USED, CALL; 
Output new.entry[0:31], new.RA[0:31], new.element#[0:1],new.R-Flag, Push ) 
{ 
Boolean recursive, self, nself; 
Set recursive = EQUAL(Target, Stacktop.entry); 
Set self = EQUAL(NPC, Stacktop.RA); 
Set nself = NOT self; 
Set Push = CALL AND nself; 
Set new.element# = Stacktop.element# + USED AND nself 
Set new.entry = Target; 
Set new.RA = NPC; 
Set new.R-Flag = recursive AND nself; 
} 
According to the circuit design of Push Control described above, we can easily find that 
the circuit can be built in less than 100 gates. The circuit of Pop Control is alike Push Control 
  25  
 
Figure 3. The circuits in stack storage 
Because of the regularity of FILO feature of the call/return behavior, the assignment and 
management of a pool of BBQ elements for the subroutines are simple and easy for 
implemented. By equipping the stack controller circuit described in this section, we can 
assign different element to each different subroutine for predictions. Moreover, by identifying 
the recursive behavior by observing the PC value and CALL/RETURN instructions, the 
demand for the number of BBQ elements can be reduced dramatically because the recursive 
behavior is the major reason for the depth of calling in an application. By eliminating the 
factor for elements requirement, we can expect that the number of BBQ elements will not 
many. There is another important reason for the fewer requirement based on the FILO 
call/return feature and the structure of BBQ. When the stack in the controller was overflowed, 
the assignment for a new subroutine will rotate to the very beginning to sustain the execution. 
The prediction record be replaced by the allocation would be expected that should not be used 
in the near future since the locality feature of execution. When the execution finally returned 
back to the program that the record in the stack is damaged, the contents of BBQ element will 
  27  
• RESET: an input control signal to reset the BBQ component, the signal is sent by Controller 
to reset the contents of BBQ element and store the first backward branch 
immediately. 
• USED: an output signal which informs stack controller that the element is used or not. 
Based on the 5 stage pipeline of ARM9 as the base architecture, the related functions of 
the BBQ element are added into the three leading stages: instruction fetch (IF), decode (ID) 
and execution (EXE). The Design can be illustrated graphically as shown in Figure 5.  
The circuits in the IF stage uses a NPC multiplexer to select an address to write the next 
program counter (NPC) as the address for the instruction be fetched at the next cycle. Besides 
selecting the original cumulative PC values from the arithmetic logic unit (ALU) or memory 
access, the new 32-bits lines, BTAR, send from the BBQ element is added to the multiplexer 
as the target address of the predicted backward branch. If the instruction fetched is a 
backward Branch and its PC matches the content of BBQ front data, BPC, the comparator 
will select BTAR by means of EQU signal to NPC multiplexer to indicate BTAR is the 
address being fetched next cycle. It means that the value of BTAR will be written into the 
program counter to fetch the predict instruction in next cycle. 
When the instruction been fetched entered into the decode stage, the decode circuit will 
use its [27:23] bits, the OP-code and the sign bit of displacement, to determine whether the 
instruction is a branch instruction or not, and identify whether the type of the branch 
instruction is forward or backward branch. The control signals, BACK, FORWARD, are the 
two indications to indicate the decoded instruction is a backward jump or a forward jump. 
Another control signal COND is produced in the same stage by comparing the condition field 
of the decoded instruction ( [31:28] bits in the instruction) with the value of NZCV flags by a 
comparator to indicate the condition, or named predicate, is TRUE or FALSE. The signals 
will be delivered to BBQ element at the execution stage. 
REGISTER
PC
Instruction memory
IF/ID
ID/EXE
DECODE&C.U
A
L
U
M
E
M 
/   
W
B
INC
B
T
A
R
BPC==PC ?
B
P
C
CPSR
Branch type
Identification
Condition 
test
Fast Adder
[23:0]
T
A
R
G
E
T 
P
C
M
T
A
R
N
Z
C
V
[31:28]
L
T
BBQ Element
EQU
COND
BACKLT
BPC
[0:31]
BTAR
[31:0]
MTAR
[31:0]
Target Address
[31:0]
PC
[31:0]
MPC
[0:31]
[27:23]
EQU
C
O
N
D
Forw
ard
B
A
C
K
A.L.U
M
P
C
MPC < PC
&&
MTAR > = TARGET
P
C
Forward
EN
A
B
LE
R
ESET
Stack Controller
NPC
U
SED
 
Figure 5. The Block Diagram of BBQ Design for ARM9 Datapath 
  29  
divided into three components: a group of storing circuitry, the BBQ element controller, and 
the BBQ element pointer adjust circuit as shown in Figure 6. 
•BBQ element storing circuitry 
The circuit is the main storage of the BBQ element, organized in Flip/Flops and related 
decoders and counters. A basic entry of the storage is comprised of two sets of 32-bit D 
Flip/Flops for storing the PC value and the target address of a backward branch instruction 
executed. The number of entries determines the maximum number of levels in a nest loop that 
can be predicted by the BBQ element. There are three pointers keep the element works. The 
front pointer, BBQF, and the rear pointer, BBQR, are two n-bits (the value of n is 2 in the 
circuit of Figure 6) counters used to address the entry from the 2n entries that should be read 
out for prediction or be written for new branch. It is noted that the BBQF is little complex 
than BBQR since the counter may load a value directly from the dynamic adjust circuit to 
adjust the prediction entry. There is another counter, BBQM, is used as the pointer which 
point to the entry that contains the last valid PC/target address pair as the outer most loop be 
recorded.  
•BBQ element control circuit  
 The signals be used to control the action of BBQ element are all issued from the BBQ 
control circuit. It’s a combination circuit for translating the input lines as described in Figure 4 
to the internal control signals. For abbreviating the illustration, the function is described as a 
function table list in Table 1. 
 
•BBQ pointer adjust circuit  
 The function of BBQ pointer adjust circuit is to adjust the prediction entry in the BBQ 
element to eliminate the side effect introduced by the forward branches that jump into the 
body of the nested loops aforementioned. The circuit uses the target address of the forward 
branch instruction being executed to compare with the PCs values stored in each entry of the 
current BBQ. The outcomes, C0~C2, can indicate which entry point that the branch jumped. 
The signals will be sent into a combination logic circuit with BBQM value to produce the 
correct read pointers, S0 and S1, for correcting BBQF. The detail function of the combination 
Table 1. The Truth Table of BBQ Element Control Circuit 
 Input Output 
Action 
EN
A
B
L 
R
ESET 
EQ
U
 
C
O
N
D
 
B
A
C
K
 
Forw
ard 
LT 
FInc 
W
R
 
M
-C
ount 
F-R
eset 
R
-R
eset 
M
-R
eset 
F-C
hange 
No Action (Element Disabled) 0 X X X X X X 0 0 0 0 0 0 0 
Reset Element  1 1 X X X X X 0 0 0 1 1 1 0 
No Action (Branch not Taken) 1 0 0 0 X X X 0 0 0 0 0 0 0 
No Action (Not Branch) 1 0 0 1 0 0 X 0 0 0 0 0 0 0 
BBQF Adjusted by S0,S1 
(A Forward Branch Happened) 1 0 0 1 0 1 X 0 0 0 0 0 0 1 
Rebuild Element  
(Meet a New Loop Structure) 1 0 0 1 1 X 0 0 1 0 1 1 1 0 
Insert a New Outer Branch 1 0 0 1 1 X 1 0 1 1 1 0 0 0 
BBQF Increment 
(Prediction Miss) 1 0 1 0 X X X 1 0 0 0 0 0 0 
BBQF Reset(Prediction Hit) 1 0 1 1 X X X 0 0 0 1 0 0 0 
  31  
approximately measure the different units, they are BBQ element, stacked controller, and one 
set of 4-way associative structure for BTB, are in the same level of hardware complexity/cost, 
say x. Thus we can expect that a stacked BBQ with 4 elements, each element equipped with 4 
entries, will cost like a 4-way set associative BTB with the capacity of 20 entries only. 
However, the stacked BBQ will gain a much higher speedup than the small BTB as shown in 
simulation. 
•Access speed  
 Although the hardware cost of a BBQ element is in as same as a 4-entries BTB, the 
gate delay time is much different between BBQ and BTB. According to the measured result 
produced by ISE, we found that the BBQ can produce the prediction in 0.89 ns. On the other 
hand, the BTB completes its function in 1.324 ns. The difference is mainly created by the 
different feature of state update. BBQ maintains the internal states by using three pointers, 
and the changes of these pointers are simple actions such as increment or reset. The states in 
BTB are much complex for maintain. For achieving the LRU replacement, the update of 
replacement states must be achieved by a FSM. It will spend more gate delays for the state 
change in the critical path of the circuit. 
•Power consumption  
Stacked BBQ is an example of power saving technique proposed in architecture level, 
the idea is to replace a large and complicated branch prediction mechanism, BTB, by a 
simpler, cheaper, and much modular prediction scheme. Since the high speed buffers for 
enhancing the efficiency of pipelined execution are power-hungry devices in modern 
architecture, less capacity means less energy consumed. For power-sensitive embedded 
processors, the fewer demand of the SRAM storage and related circuits make stacked BBQ be 
an attractive solution to replace the power-hungry BTB with an approximately performance. 
Due to the feature of stacked BBQ, the modular design can benefit the implementation 
of the techniques of power saving, too. For example, an efficient hardware approach to reduce 
the storage energy consumption by turning unused registers into a low power state. Hardware 
designers had also developed SRAM cells with low-leakage operating modes (e.g., sleep 
mode). The difference between the technique of sleep mode with low power state is, sleep 
mode reduces static power dissipation, but data stored in a sleeping cell is unreliable or lost. 
These techniques are hard to be used for a BTB because of the associative structure makes the 
identification of the usage for each entry in the BTB to be difficult. But for stacked BBQ, only 
one BBQ element should be active at a short period of time. The other elements can be 
switched into a low power state, for the used element, or a sleep state, for the unused element, 
to reduce the energy consumption.  
  33  
2. Power consumption.  Processors in mobile devices rely on batteries as the energy source 
and must be as energy efficient as possible to prolong battery life.  Even in the realm of 
mainstream processors, the power consumption of cache memory has recently received 
significant research attentions [1].  BTBs and other sophisticated branch predictors, if 
used, could be a major power drain for embedded processors.  The situation is 
exacerbated by the fact that a BTB needs a good size to achieve high prediction accuracy.  
An alternative solution to the branch prediction problem is in demand for embedded 
processors. 
3. Short product cycles.  Many markets of embedded processors have very short product 
life cycles. It is reported in 2007 that, for instance, in urban China an average cell phone 
user purchases a new cell phone every 8 to 12 months [2]. Simple solutions in any aspect 
of product designs, including branch predictions, have inherent advantages in debugging, 
development and consequently short times to market. 
In this work, we take on the challenge of devising extremely simple, low-cost and yet 
effective branch prediction solutions that are intended for use by embedded processors.  Not 
surprisingly, the research path that we follow is a return to the RISC philosophy: Focus on the 
most common cases that have the biggest impact on performance, and use simple solutions to 
support the common cases well.  
In particular, we single out backward branches used in loops as the most important case of the 
branch prediction problem.  Our rational is twofold.  First, loops typically make up a 
significant portion, if not the major portion, of program execution times.  Improving the 
performance of loops, especially nested ones, offers the best potential of performance 
improvements.  Second, nested loops have a clear structure of program control flows.  To 
illustrate this structure, we show in Figure 1(a) a nested loop structure.  The three branch 
target addresses X, Y and Z mark the ingress points of the three loops, respectively. In 
execution, address Z is computed first when the branch instruction BRz is executed, followed 
by Y when BRy is executed, followed in turn by X when BRx is executed.  The three 
addresses in this way form a queue (Z, Y, X), where Z is at the front and X at the rear, 
according to the times at which they become known to the processor. As shown in Figure 1(b), 
the later uses of the three branch addresses also reflect a similar pattern: inside the inner most 
loop, address Z is most likely to be the next branch target.  Once the program flow exits the 
inner most loop, address Y becomes the most likely target of the next control flow branching. 
Once outside Loop Y, address X becomes the most likely branch target. As we will show later, 
the BBQ approach takes advantages of this simple, queue-structured behavior in effective 
branch predictions.   
 
Fig. 1: A nested loop and its queue-structured branch targets 
We acknowledge that not all loops are perfectly nested as the one in Figure 1.  However, by 
taking into account the small number of exception cases which exist in applications (e.g., 
loops that are not perfectly nested, loops that include forward branches, etc.), we show that it 
is possible to preserve the simple, queue-like behaviors for the majority of backward branches.  
The result is a novel approach to the branch prediction problem, called Backward Branch 
prediction Queue, or BBQ. By using a standard benchmark suite for embedded processors, 
MiBench, our performance results show that with merely 4 entries in the queue, the BBQ 
design achieves 42% of the performance benefits of a 128 entries, 4-way set-associative BTB 
by the hardware cost with less than 3.2% of the cost for the BTB. It must be emphasized again 
S 1
S 2
S 3
S 4
S 5
S 6
S 7
B R x
B R z
B R y
X :
Y :
Z :
(a )
Z ( B R z )
ta k e n
ta k e n
ta k e n
S e q u e n t ia l  
p a th
S u c c e e d  
p r o c e d u r e
Y ( B R y ) X ( B R x )
u n t a k e n
ta k e n
( b )
  35  
in one or more pattern history tables (PHTs) of two bits saturating counters. In essence, the 
BHR is used to index the PHT to select respective two-bit counters.  
In general, large amounts of history and behavioral information need to be maintained to 
order achieve the high prediction accuracies. Recent research of two-level predictions mainly 
focus on avoiding the exponential growth of table sizes and/or new hashing function to 
eliminate the conflictions in the tables [8][9], or propose some variants by acceding other 
dynamic states such as branch pattern probabilities to the hierarchical history tables to 
facilitate prediction accuracy [10].  
2.3. Neural-network Based Branch Predictions  
Neural-network based approaches to branch predictions give rise to interesting “learning” 
(from past) potentialities stemming from the research in artificial intelligence. A dynamic 
branch predictor using neural networks, called Learning Vector Quantization (LVQ) was 
proposed in [11]. In 2001, Jiménez and Lin introduced a perceptron branch predictor [12], 
where neural networks are used as a more powerful alternative to the commonly used two-bit 
counters.  Later improvements and other variants of the perceptron predictor can be found in 
[13]. 
In summary, branch prediction solutions involving, large history caches, hierarchical tables, 
and/or neural networks achieve high prediction accuracies at the expense of hardware costs. 
They are suitable for mainstream processors as the rapid advancements of VLSI technologies 
accommodate steadily increasing numbers of transistors per chip over time.  The embedded 
processors however face drastically different design criteria, especially in the areas of 
complexity and power consumption constraints. 
2.4. Power-saving Branch Predictors  
A methodology for a low-power branch prediction mechanism, which enables the design of 
extremely power-efficient branch predictors for embedded processors, is important. The issue 
has also attracted most concentrations   about the related studies in the recent years. Some 
research results about the techniques for power saving have also been proposed. 
In order to save power dissipation by a power hungry BTB, the most instinctive way is to 
reduce the accesses of BTB. A prediction probe detector (PPD) is proposed to use predecode 
bits to eliminate unnecessary predictor and BTB accesses in [14]. By adding an instruction 
filter cache in [15], the same goal is achieved by reducing the fetching operations from the 
instruction cache and the subsequent decoding. Some researches try to reduce the power 
consumption by modifying the structure of predictors. For example, the study in [16] claims 
that by looking up two predictions at a time by increasing the width of the PHT, and by 
accessing the PHT in advance. The reduction for the unnecessary BTB accesses can be 
achieved.  In [17], the reduction is made by utilizing the hardware to buffer the control-flow 
structure of the executed program.   
It is noted that the related techniques focus the attention on the techniques of power saving 
and achieve their goal by adding extra hardware. The acclivity of hardware cost makes the 
solutions be suitable for the high performance processors, but not for low-cost embedded 
processors.      
3. The BBQ Approach 
3.1 Basic Concept 
We use the nested loop shown in Figure 1 to illustrate the operations of the BBQ. When a 
program starts its execution and an innermost backward branch BRz is encountered for the 
first time in loop Z, the BBQ discovers that it is a backward branch instruction by checking 
the OP-code and offset fields in the instruction, and thus the PC value and the target address 
  37  
as shown in Figure 2(a). 
3.2 Handling Forward Branches 
The basic concept of BBQ is to focus on the predictions of backward branches used in nested 
loops.  However, there cases, as shown in Figure 4, where forward branches interfere with 
the control flow of nested loops.  If not handled with care, such forward branches could 
cause confusion to the BBQ circuits. 
S1
S2
S3
S4
S5
S6
S7
BRx
BRz
BRy
X:
Y:
Z:
BRf
F:
S1
S2
S3
S4
S5
S6
S7
BRx
BRz
BRy
X:
Y:
Z:
BRf
F:
S1
S2
S3
S4
S5
S6
S7
BRx
BRz
BRy
X:
Y:
Z:
BRf
F:
(a) (b) (c)   
Fig. 3: Conditions of forward branches 
The way of the forward branch behavior interfere the prediction of the BBQ is described in 
detail as follows. Although the BBQ does not store the information of a forward branch, the 
flow running from the interior to the exterior of a nested loop will be ruined after the forward 
branch instruction jumps.  Therefore, the prediction has to take the effect of the forward 
branch instructions into consideration. According to the observation from the behavior of 
simulated applications, the forward branches of this sort that will alter the regular behaviors 
of nested loop are divided into three types as shown in Figure 3. 
The situations as shown in Figures 3(a) and 3(b) will not ruin the existing prediction 
mechanism of the BBQ and at most it may confuse the BBQ to store unnecessary information 
only.  As the loop continues, the BBQ will rearrange the predicted information of the 
foregoing mechanism, so as to eliminate the interference of the jumps of this sort. 
The situation as shown in Figure 3(c) is more complicated.  If the forward branch, BRf, 
occurs in the nested loop, and its target address is situated in another level of nest loop, the 
target address will exceed the innermost backward branch/branches of the nested loop. Refer 
to the figure, the target address of BRf exceeds the backward branches, BRz and BRy. If the 
forward branch jumps, it will exit the range of the innermost loop Z. Since the forward branch 
instruction BRf jumps and the flow enters directly into the outermost loop X. Meanwhile, the 
BBQ retains the original prediction that is pointed to loop Z but not loop X. The condition 
will make the prediction for the following backward branch to be missed even the loop 
structure has already built completely. Because the forward branch instruction BRf in the 
nested loop will be repeated continuously, the interfering misses caused by the repeated 
executions would be seriously.  Based on the analysis of the dynamic execution of the 
benchmark programs, we discovered that the situation of this sort occupies about 0.9139% of 
the total number of executed instructions.  Particularly in certain specific applications such 
as the jpeg and dijkstra shortest path occupy 5.773% and 16.839% of the total executed 
instructions respectively. The interfering condition must be distinguished by the BBQ for 
prediction accuracy. 
To overcome the ruin of this sort of forward branch as described above, some comparators are 
added to compare the target address of the executing branch instruction and the PC values 
stored in each entries of BBQ to determine the location where the forwarding branch jumped. 
The result of comparisons will adjust the front pointer to catch the progress of execution flow 
for the following execution. 
  39  
REGISTER
PC
Instruction memory
IF/ID
ID/EXE
DECODE&C.U
A
L
U
M
E
M 
/   W
B
INC
B
T
A
R
BPC==PC ?
B
P
C
CPSR
Branch type
Identification
Condition 
test
Fast Adder
[23:0]
T
AR
G
E
T 
PC
M
T
A
R
NZ
CV[31:28]
LT
BBQ Element
EQU
COND
BACKLT
BPC
[0:31]
BTAR[3
1:0]
MTAR[31:
0]
Target Address
[31:0]
PC
[31:0]
MPC
[0:31]
[27:23]
EQU
CO
N
D
Forw
ard
B
A
C
K
A.L.U
M
PC
MPC < PC
&&
MTAR > = TARGET
PC
Forward
NPC
 
Fig. 5:The block diagram of BBQ design for ARM9 datapath 
When an instruction enters the decode stage, the decode circuit will use its first level OP-code 
and the sign bit of displacement (bits [27:23]) to determine whether the instruction is a branch 
instruction or not, and identify the type of the branch instruction such as a forward branch or a 
backward branch, producing BACK and FORWARD control inputs to the BBQ Element 
when the instruction enters the EXE stage.  Another control signal COND is produced in the 
decode stage by comparing the conditional fields of the decoded instruction ([31:28] bits in 
the instruction) with the value of NZCV flags by a comparator. 
It is noted that in the original ARM-9 architecture, branch target addresses are calculated by 
ALU at the EXE stage. This arrangement delays the updates of the BBQ Element to the 4th 
stage as described in Figure 4. If the address is calculated at the ID stage, the branch 
instruction can be completed one stage earlier, and the branch delay can be reduced to one. 
This optimization technique applies equally to both forward and backward branches. We 
therefore modify the ARM-9 pipeline by adding a dedicated branch address adder into the ID 
stage (see Fig. 5) and in this way obtain the branch target address one stage earlier than the 
standard ARM-9 pipeline. By comparing the target address with the MTAR issued from the 
BBQ Element, and the original PC value with the MPC of the BBQ Element, the outcome of 
the comparator, LT, can be made to determine whether the backward branch is a new one or 
not, and decide whether the new branch can constitute an outer loop of the nested loops 
structure stored in BBQ already. The LT is then latched and send to the next stage for the use 
of BBQ Element as BACK/Forward/COND does. 
When the execution enters into the execution stage, the BBQ Element will update its content 
according to the comparison results in this stage.  
4.2 BBQ Element 
Besides the control lines such as COND, LT, and EQU produced in the first two stages. There 
are other input/output lines of BBQ Element defined below. 
• PC[31:0]: a 32-bit input that provides the address of the instruction being fetched in the 
present cycle. It should be written into the BBQ if the instruction is a new backward 
branch. 
• Target Address[31:0]: a 32-bit input that provides the target address of a branch in ID stage. 
The input is used for updating the BBQ Element. 
  41  
For verifying the design and evaluating the efficiency of BBQ, this research adopts Xilinx 
Foundation 4.2i and Xilinx ISE as the design tools to implement the circuit in gate level. By 
incorporating the circuit with an ARM-9 equivalent circuit that implemented by the formal 
research [18]. The whole circuit has been verified and the hardware characters can be 
concluded below. 
The total cost of a 4-entry BBQ in gate counts is 5013 gates. It is noted that the whole register 
bank built in the processor cost 22756 gates (including the related decoder circuits) and other 
6850 gates been used for a barrel shifter. The number proved that the hardware cost is much 
low for implementation. Furthermore, the study has also built a 4-way set associative BTB 
with 256 entries for the ARM-9 architecture, too. The hardware comparison between the BBQ 
and the BTB shows that the BBQ is even smaller than one set of the BTB (one set with 
4-entries is designed in the same technology with 5114 gates). For access speed, the BBQ 
Element can issue the prediction in 0.89 ns, and the BTB will read out the predict value by 
1.324 ns.  
5. Performance Evaluation 
We use 12 benchmarks that contribute a representative part of Mibench [19] as a standard 
performance testing programs. They are Bitcount and Quicksort used in industrial 
applications, Jpeg encode/decode and Tiff2bw used in consumer programs, Dijkstra, CRC32, 
and FFT for telecommunication usage, SHA, Blowfish encrypt/decrypt, and Rijndael 
encrypt/decrypt for security functions. All of these benchmarks are popular and widely used 
in the various applications of embedded systems. The testing platform selected for simulation 
is Simplescalar [20]. It is a well-known and reliable simulation tool that used for architecture 
studies.  
The simulation results reveal the truth that BBQ is a cost-effective technology for embedded 
processors. From the simulations with various capacities of BBQ to store nest loops as shown 
in Figure 7, we found that when a BBQ with 2 entries only, the hit ratio for applications has 
reached a flat growing curve with 86.93% hit ratio in average. The hit ratio of a BBQ with 4 
entries can reach 87.35% that is only slightly higher than the smaller BBQ gained.  
52.052%
87.346%
87.346%
87.346%
87.346%
87.346%
86.929%
40%
50%
60%
70%
80%
90%
100%
1 2 3 4 5 6 8
 
Fig. 7: The hit ratios for different BBQ sizes 
We have also simulated with the same benchmarks for the prediction made by different BTBs 
for comparison. As shown in Figure 8, the simulated results show that even predicted by a 
128-entry direct mapped BTB with two-bit prediction strategy, which is the BTB equipped in 
XScale processor, the hit ratio for backward branches is only 81.38%. The BTB with direct 
mapped structure must be equipped with more than 256 entries to gain a hit ratio higher than 
90%. Further, a BTB with set-associative structure can achieve higher prediction rate by 
complex hardware. A 128-entry 4-way set associative BTB can predict backward branches in 
91.77% hit ratio. The simulation results exhibited in Figure 9 shows that our BBQ could 
achieve 92.27% of the hit ratio of a 128-entry 4-way set associative BTB.  
 
  43  
smaller BTB. For a high-end embedded processor, the hybrid prediction mechanism can 
effectively reduce the hardware cost for implementation and achieve a cost-effective design. 
However, it should be noted that the improvement by combining the features of BBQ and set 
associative BTBs is comparatively small than the values shown for direct mapped BTBs. 
Because of the higher prediction accuracy of set associative structure, the hybrid feature can 
benefit prediction evidently only in the conditions that the capacity of the BTB is less than 32 
entries. 
Table 1. Performance Improvements by Combined Features 
BTB capacity 128 256 512 
Direct Mapped BTB  20.03% 20.64% 20.68%
Direct Mapped BTB +BBQ 21.71% 21.92% 21.94%
6. Concluding Remarks 
In this paper, we propose a novel mechanism, BBQ, for the branch prediction. By focusing 
only on backward branches used to create loops, we show that BBQ is able to sustain good 
prediction accuracies in a most cost-effective way. The idea of BBQ creates new tradeoff 
points of costs, performance, and power consumptions that best suit embedded processors. 
There is an important issue for BBQ been observed from the simulation results, we found that 
the behavior of Call/Return and multiple nested loops exist in a same outer loop confuses 
BBQ and introduce some unnecessary misses. We are now expanding the BBQ design into a 
stacked structure equipped with several BBQs. The preliminary simulation shows that the 
modification can promote the hit ratio of BBQ from 87% to 92%. The detail of this 
improvement will be proposed when the hardware verification is completed. 
References 
 [1] M.B. Kamble, and  K. Ghose, “Analytical energy dissipation models for low power caches,” Proceedings of the 1997 
International Symposium on Low Power Electronics and Design, 1997, Pages 143- 148, Aug 1997. 
[2] http://www.xfsd.com/news/2007/0712/article_1139.html 
[3] J.L. Hennessy and D.A. Patterson, "Computer Architecture: A Quantitative Approach, " Morgan Kaufmann, San 
Francisco, CA, 1996. 
[4] J. A. Fisher, and S. M. Freudenberger,“Predicting conditional branch directions from previous runs of a program,” 
Proceedings of the 5th international conference on Architectural support for programming languages and operating 
systems, pg.85-95, 1992. 
[5] J. E. Smith, “A Study of Branch Prediction Strategies,” Proc. 8th Int'l Symp. Computer Architecture (ISCA-8), pg. 
135-148, 1981. 
[6] Intel XScaleTM Technology, http://www.intel.com/design/ intelxscale/. 
[7] T.-Y. Yeh and Y. Patt, “Two-level adaptive training branch prediction,” Proceedings of the 24th annual international 
symposium on Microarchitecture, pg. 51-61, 1991. 
[8] A. Fern, R. Givan, B. Falsafi, and T. N. Vijaykumar, “Dynamic feature selection for hardware prediction,” Journal of 
Systems Architecture , Volume 52, Issue 4, Pages 213-234, April 2006. 
[9] Yi Ma, Hongliang Gao, Huiyang Zhou, "Using Indexing Functions to Reduce Conflict Aliasing in Branch Prediction 
Tables," IEEE Transactions on Computers, vol. 55,  no. 8,  pp. 1057-1061,  Aug.,  2006. 
[10] J. W. Kwak, J-H Kim, and C. S. John, “The Impact of Branch Direction History Combined with Global Branch History 
in Branch Prediction,” IEICE Transactions on Information and Systems, vol. E88-D, No. 7, pg. 1754-1758, 2005. 
[11] L. Vintan, and M. Iridon, “Towards a high performance neural branch predictor,” Proceedings of the International Joint 
Conference on Neural Networks(IJCNN), vol. 2, pp. 868-873, 1999. 
[12] Daniel A. Jimenez, Calvin Lin, "Dynamic Branch Prediction with Perceptrons," hpca, p. 0197,  Seventh International 
Symposium on High-Performance Computer Architecture (HPCA'01),  2001. 
[13] V. Desmet, L. Eeckhout, and K. De Bosschere, “Improved composite confidence mechanisms for a perceptron branch 
predictor,” Journal of Systems Architecture, Volume 52, Issue 3 , Pages 143-151, March 2006. 
[14] D. Parikh, K. Skadron, Y. Zhang, and M. R Stan,”Power-Aware Branch Prediction: Characterization and Design,” 
IEEE Transaction on Computers, Vol. 53, No. 2, pp.168-186, Feb. 2004. 
[15] W Tang, R Gupta, A Nicolau,” Power Savings in Embedded Processors through Decode Filer Cache,” 2002 Design, 
Automation and Test in Europe Conference and Exhibition (DATE'02), pp. 443- 448, Aug. 2002. 
[16] S. W. Chung, G. H. Park, and S. B. Park, “A Low-Power Branch Predictor for Embedded Processors,” IEICE 
TRANSACTIONS on Information and Systems  Vol.E87-D  No.9  pp.2253-2257, Sep. 2004. 
