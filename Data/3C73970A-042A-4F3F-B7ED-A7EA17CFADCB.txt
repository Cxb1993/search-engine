 
中 文 摘 要 ： 本計畫的第一年著重於硬體設計及研製、視覺影像的辨識、
基本及特殊運動功能的實現以及 3對 3智慧型策略的發展與
應用。其中機器人結構主體為鋁鎂合金且擁有 20 個自由度，
影像系統部分，裝設了全域 CCD 攝影機，用以取得比賽場地
全景圖，因而獲得充分資訊，以增加辨識能力。運動控制策
略部份：以一個完整的步伐週期為基礎，衍生出前進，後
退，轉彎與側移等的動作。策略部份：分為攻擊部分、防守
部份與守門部分。將攻擊者、防守者、球和球門之間的距離
與角度關係以向量的方式來表示，經由計算得到最佳攻擊與
防守位置。最後，將所有的功能與系統加以整合並實現在小
型仿人形機器人足球競賽上。 
而第二年本計畫之執行的重點在於硬體設計的研製及更新、
影像辨識的功能改進、機器人各項運動功能的實現及效能增
進，並以及 3對 3足球賽智慧型策略在應用方面的加強。系
統架構上，機器人結構材料為鋁鎂合金並擁有 18 個自由度。
影像系統部分，場地上方裝設了 CCD 攝影機，以取得比賽場
地的全景俯視圖，以獲得所需的充分資訊來進行影像分析與
辨識。機器人的運動控制部份，利用前一代機器人的步伐模
式為基礎，進一步衍生出更多樣化的動作，以配合策略軟體
的需要。策略規劃方面，也是構築在前一代的策略概念上，
同樣基於向量場的原理，再針對實際應用的情況加以強化與
改進。最後，將所有改進的功能與系統加以整合，並以小型
仿人形機器人足球競賽作為實際效能的測試。 
本計畫進行的最後一年，主要在探討 FIRA AndroSot 小型人
形機器人足球賽模擬器之開發與其策略演算系統。由於人形
機器人足球比賽提供了一個動態而且多樣化的環境，因此可
以做為多方面研究題材的測試平台。然而由前面兩年計畫經
驗，我們發現針對策略系統而言，如果在沒有硬體架構與視
覺系統整合完成情況之下，很難進行測試。為了解決上述問
題，在計畫執行的最後一年我們提出了一套人形機器人足球
比賽的策略模擬系統，以供使用者方便測試策略之可行性與
優缺點。在模擬器中，會將使用者編譯完成的動態連結程式
庫動態載入至程式中。並且在 AndroSot 機器人硬體架構中，
我們將會與上一代的機器人作整理與比較。 
 
中文關鍵詞： 模擬器、機器人足球賽、智慧型控制策略、AndroSot、FIRA 
英 文 摘 要 ： This project in the first year emphasizes the 
hardware design, vision image recognize, 
implementation of the basic and special motion 
functions, and development and application of the 
英文關鍵詞： Simulator, robot soccer, Intelligent control 
strategy, AndroSot, FIRA 
 
 II
一、 中文摘要 
本計畫的第一年著重於硬體設計及研製、視覺影像的辨識、基本及特殊運動功能的實
現以及 3 對 3 智慧型策略的發展與應用。其中機器人結構主體為鋁鎂合金且擁有 20 個自由
度，影像系統部分，裝設了全域 CCD 攝影機，用以取得比賽場地全景圖，因而獲得充分資
訊，以增加辨識能力。運動控制策略部份：以一個完整的步伐週期為基礎，衍生出前進，
後退，轉彎與側移等的動作。策略部份：分為攻擊部分、防守部份與守門部分。將攻擊者、
防守者、球和球門之間的距離與角度關係以向量的方式來表示，經由計算得到最佳攻擊與
防守位置。最後，將所有的功能與系統加以整合並實現在小型仿人形機器人足球競賽上。 
而第二年本計畫之執行的重點在於硬體設計的研製及更新、影像辨識的功能改進、機
器人各項運動功能的實現及效能增進，並以及 3 對 3 足球賽智慧型策略在應用方面的加強。
系統架構上，機器人結構材料為鋁鎂合金並擁有 18 個自由度。影像系統部分，場地上方裝
設了 CCD 攝影機，以取得比賽場地的全景俯視圖，以獲得所需的充分資訊來進行影像分析
與辨識。機器人的運動控制部份，利用前一代機器人的步伐模式為基礎，進一步衍生出更
多樣化的動作，以配合策略軟體的需要。策略規劃方面，也是構築在前一代的策略概念上，
同樣基於向量場的原理，再針對實際應用的情況加以強化與改進。最後，將所有改進的功
能與系統加以整合，並以小型仿人形機器人足球競賽作為實際效能的測試。 
本計畫進行的最後一年，主要在探討 FIRA AndroSot 小型人形機器人足球賽模擬器之
開發與其策略演算系統。由於人形機器人足球比賽提供了一個動態而且多樣化的環境，因
此可以做為多方面研究題材的測試平台。然而由前面兩年計畫經驗，我們發現針對策略系
統而言，如果在沒有硬體架構與視覺系統整合完成情況之下，很難進行測試。為了解決上
述問題，在計畫執行的最後一年我們提出了一套人形機器人足球比賽的策略模擬系統，以
供使用者方便測試策略之可行性與優缺點。在模擬器中，會將使用者編譯完成的動態連結
程式庫動態載入至程式中。並且在 AndroSot 機器人硬體架構中，我們將會與上一代的機器
人作整理與比較。 
關鍵字：模擬器、機器人足球賽、智慧型控制策略、AndroSot、FIRA。 
 
 
 
 
 III
一、中文摘要 ................................................................................................................................. II 
二、Abstract ................................................................................................................................. IIII 
三、研究計畫之緣由及目的： ...................................................................................................... 1 
四、研究方向與進行步驟 .............................................................................................................. 1 
(一) Introduction ...................................................................................................................... 1 
(二) Overview of the Robot Soccer System ............................................................................ 2 
1. Introduction .................................................................................................................. 2 
2. Introduction to Robot Soccer Game ............................................................................. 3 
3. Mechanism Design of the Robot Soccer for AndroSot ................................................ 4 
4. The Hardware of aiRobots-S2 ...................................................................................... 8 
5. The Peripheral of AndroSot System ........................................................................... 14 
6. Summary .................................................................................................................... 17 
(三) Simulator for Humanoid Robot Soccer Competition ..................................................... 18 
1. Introduction ................................................................................................................ 18 
2. System Architecture ................................................................................................... 18 
3. User Guide of the Proposed Simulator....................................................................... 20 
4. The Tutorial on Creating DLL Files ........................................................................... 31 
5. Extended Mode - Master Level .................................................................................. 33 
6. Summary .................................................................................................................... 35 
(四) Strategy Decision Systems ............................................................................................. 35 
1. Introduction ................................................................................................................ 35 
2. The Dynamic Strategy System for AndroSot in FIRA ............................................... 36 
3. The Extended Strategy for Actual Competition in AndroSot ..................................... 61 
4. Summary .................................................................................................................... 67 
(五) Simulation and Experimental Results ............................................................................ 67 
1. Introduction ................................................................................................................ 67 
2. Simulation Results of Strategies for AndroSot .......................................................... 67 
3. Actual Competitions in FIRA 2010............................................................................ 75 
五、參考文獻 ................................................................................................................................ 83 
六、計畫成果自評： .................................................................................................................... 87 
七、可供推廣之研發成果資料表 ................................................................................................ 86 
  2
SimuroSot game, the 3D two-wheel robot soccer simulator was developed by the RSS 
Development team and directed by Dr. Jun Jo of Griffith University, Australia. The aim of 
simulate competition is used for providing game training and strategy learning environment for 
each team. All in all, simulator provides a very convenient operating environment for the strategy 
testing of robot soccer competitions. 
In terms of humanoid robot soccer, there are numerous competitions held around the world. 
Such as FIRA Android Soccer Tournament (AndroSot). A humanoid robot belongs to highly 
intelligent system. The intelligent technologies of the humanoid robots include mechanism design, 
vision system, and algorithms in software programming. Therefore, its competitions can 
encourage creativity and technical development. To facilitate the strategy testing of these 
humanoid robot soccer competitions, a strategy simulator for AndroSot in FIRA is proposed. In 
this simulator, strategies compiled to DLL files may be explicitly loaded at run-time. Besides, we 
choose Dev C++ [3] for the compiler. 
On the other hand, to build a world-class robot soccer team will require individual skilled 
agent, teamwork, and the ability to develop and execute plays and strategies in real time [11-12]. 
In AndroSot, potential field algorithm of obstacle avoidance is proposed. In order to reach high 
performance, it computes all of the robot information, such as the coordinates and direction 
vectors of the robots. 
 
(二) Overview of the Robot Soccer System 
1 Introduction 
Robot soccer game has become a popular research category around the world since the 
inauguration of the FIRA organization and the RoboCup competition. Also as the enthusiasm for 
these international competitions are growing every day and now that robot soccer has made its 
mark. Because robot soccer involves integrated technology application, which offers a 
challenging test platform for developing new ideas or techniques of multi-agent systems. It also 
  4
 In additional, the robot should be a biped android, and all androids must have (at least) a 
3.5 cm × 3.5 cm solid region of their team color patch, blue or yellow, visible from the top. The 
maximum area of color patch set on the top side of each android is 7 cm × 7 cm. The team color 
either blue or yellow, as assigned by the organizers, will identify the robots in a team. 
Besides the camera above the playground, the goalkeeper of each team may possess its own 
camera. The image of the camera may be sent via a wireless communication channel to an 
off-board computer for processing. 
 
Fig. 2.1 The overview of FIRA Android Soccer Tournament 
 
3 Mechanism Design of the Robot Soccer for AndroSot 
 The robot is designed and implemented according the rules of AndroSot league competition 
in FIRA 2010. According to Android Soccer Tournament Laws of the Game 2010, robot 
participating in the competitions must have a human-like body plan. The previous design of robot 
  6
The design of the mechanism and hardware of aiRobots-S2 conforms to the rules of FIRA 
AndroSot game. In AndroSot, the endurance and the robustness of the robots are very important. 
Since the robots need to keep running on the field for approaching the ball, and kicking the ball. 
Furthermore, after the robots were knocked down by other opponents or dived for the ball, they 
also have to get up autonomously. All in all, during the competition, robots in the playing field 
have to deal with every complex situation immediately. These capabilities depend significantly 
on strong mechanism and high-performance control of humanoid robots. The motion control 
system includes 18 actuators, Zigbee module and Li-po batteries. Besides, two touch sensors are 
installed in aiRobots-S2. They are used to detect whether the robot falls down or not. The robot 
will execute the action of getting up when one of the touch sensors was pressed. Finally, pictures 
of aiRobots-S2 are shown in Fig. 2.4. 
 
  
(a) Front view (b) Rear view (c) Side view 
Fig. 2.4 Pictures of aiRobots-S2 
 
According to Android Soccer Tournament Laws of the Game 2010, robot participating in 
the competitions must have a human-like body plan, as shown in Fig. 2.5. To handle the weight 
of the hardware and perform all actions smoothly, the aluminum-magnesium alloy is a suitable 
Touch sensor 
Touch sensor Touch sensor 
  8
  
(c) The top view (d) The bottom view 
  
(e) The complete structure (f) The disposition of actuators 
Fig. 2.6 The mechanism design of aiRobots-S2 
 
4 The Hardware of aiRobots-S2 
Specifications of aiRobots-S2 is shown in Table 2.1. The following sections will introduce 
the detailed hardware of the motion control system which includes 18 actuators, a motion 
controller and Li-po batteries. In AndroSot rules, the total height restriction of the robot is 30 cm 
to 60 cm. We take these constraints into consideration when we design the mechanism of the 
robot. And the foot also fits into a rectangle of area 0.035×H2. 
 
 
 
 
 
  10
 
Fig. 2.7 The figures of Dynamixel AX-12+ 
 
 
Fig. 2.8 The control network of the actuator 
 
Table 2.2 Specification of AX-12+ 
Size(mm) 32×50.1×40 
Torque 16.5kg-cm 
Speed 0.196s/60° 
Weight 53.5g 
Voltage 7~10V 
Motor Cored motor 
 
 
  12
 
Fig. 2.9 The picture of Arduino Mega 
 
Table 2.3 Specification of Arduino Mega 
Microcontroller ATmega1280 
Operating Voltage 5V 
Input Voltage (recommended) 7-12V 
Input Voltage (limits) 6-20V 
Digital I/O Pins 54 (of which 14 provide PWM output) 
Analog Input Pins 16 
DC Current per I/O Pin 40 mA 
DC Current for 3.3V Pin 50 mA 
Flash Memory 128 KB (of which 4 KB used by boot loader) 
SRAM 8 KB 
EEPROM 4 KB 
Clock Speed 16 MHz 
 
 
  14
5 The Peripheral of AndroSot System 
Basically, the robot soccer game system is composed of various systems such as vision 
system, host computer system and communication system.  
This section describes the whole system of robot soccer game, and all of these systems are 
briefly mentioned in the following subsections. Fig. 2.12 shows the experiment field of 
AndroSot. 
 
 
Fig. 2.12 The experiment field of AndroSot 
 
5.1 Host Computer System 
The Host computer system manages the image recognition algorithm, the position and 
direction vector of all objects, strategy inference, and the control command sending via wireless 
communication module. Besides, Lenovo ThinkPad X61 with Intel Core 2 Duo 2.0GHz T7300 
processor and 2048MB DDR2 RAM are chosen to be in the host computer for the competition. 
The main storage capability of the computer is 100GB. The picture of Lenovo ThinkPad X61 is 
shown in Fig. 2.13. 
 
  16
Table 2.4 Specification of the Logitech Webcam C905 
Model Logitech Webcam C905 
Optical Sensor Type CMOS 
Maximum Video Resolution 1600 ×1200 
Focus Type Autofocus 
Maximum Frame Rate 30 Fps 
Connection Interface USB 2.0 
 
5.3 Wireless Communication System 
The commands from host computer are transferred to home robots by means of the wireless 
communication module. The wireless communication modules used in the system are 
USB2Dynamixel [7], Zig2Serial [8] and Zig-100 [9], as shown in Figs. 2.15-2.17, respectively. 
Next, the wireless network is also shown in Fig. 2.18. 
 Zig-100 is a small module which has a built-in MCU and Zigbee IC, allowing UART 
communication using 2.4GHz frequency. Utilized as a PAN (Personal Area Network) Module, it 
replaces wired serial communication with more modern wireless characteristics. And the basic 
specifications of Zig-100 are shown in Table 2.5. 
 
 
Fig. 2.15 The picture of USB2Dynamixel Fig. 2.16 The picture of Zig2Serial 
 
  18
In the following chapter, the proposed simulator for AndroSot in FIRA will be illustrated in 
detail. 
 
(三) Simulator for Humanoid Robot Soccer Competition 
1 Introduction  
In this chapter, the overview of humanoid robot soccer simulator is addressed. The simulator is 
not only used for providing game training and strategy learning environment for each team but 
also used for testing the feasibility and advancement of the game strategy of each team. This 
simulator uses computer graphics to simulate the field, the robots and the ball. The robots are 
divided into two teams: team A and team B. And each team contains a goalkeeper. Before the 
start of play, each robot can be selected to change its position on the game field, and the direction 
of robots can be tuned by turning the wheel of the mouse. Simulate competition software is 
compiled using Embarcadero C++ Builder 2010 [10], and it can run under Windows XP and 
Windows 7. Furthermore, the DLL files of the strategy can link to its software explicitly. 
 
2 System Architecture 
 First of all, the system flowchart of the simulator is shown in Fig. 3.1. When the “Start” 
button is clicked by the user, the background music composed by ourselves is played. Next, the 
simulator will check whether the DLL files are loaded or not. If the DLL strategy files are loaded, 
the simulator will execute the strategies in the DLL files. On the contrary, if the DLL strategy 
files are not loaded, the simulator will execute the built-in strategies. After that, the pose of the 
robots will be set immediately. Then, if the simulation level selected by the user is “Master level”, 
the healthy point (HP) of each robot will be reduced or increased. The value of HP depends on 
the circumstances during the competition. Afterward, the location of the ball is updated. After all 
of the processes described above are completed, in order to show the circumstances in the playing 
field, the simulator will use computer graphics to simulate the field, the robots and the ball. 
  20
3 User Guide of the Proposed Simulator 
Fig. 3.2 shows the user interface of Robot Soccer Simulator, which includes the game field, 
the main menu and the scoreboard. The robots are divided into two teams: team A (blue) and 
team B (yellow). And each team contains three robots. When the program is enabled, the form of 
scoreboard is shown in the monitor. It is used for showing the score of each team. However, if the 
user doesn’t want to place the scoreboard on the monitor, closing the form of scoreboard is 
available. Next, the playing field, the robots, the ball, and some basic settings of the simulator are 
introduced in the following subsections. 
 
 
Fig. 3.2 The interface of the simulator 
 
3.1 Playing Field 
 The field of AndroSot in the simulator is shown in Fig. 3.3. This field contains two goals, 
four free-ball positions and two penalty-kick positions. The free-ball positions are marked in 
orange color; the penalty-kick positions are in pink color. Furthermore, the center circle, goal area, 
and the penalty area are also marked. The goal line is in front of the goal. And the goal areas are 
  22
 
A. Basic settings of the ball 
 The link for opening the robot setting form is shown in Fig. 3.5. And Fig. 3.6 shows the 
form for setting of the robots and ball. In the robot setting form, the group box of the ball is on 
the top of the form. In this group box, the user can adjust the radius and the RGB value of the 
ball. 
 
B. Basic settings of the robots 
 The setting parameters of the robots are under the group box of the ball. The user can select 
the color of each robot. Furthermore, the length, width, and height of the robots are also can be 
adjusted. Besides, the vertical visual angle and the horizontal visual angle of the camera which 
are on the robots are variable. Next, the current position, the current angle and the initial position 
of the robots, are shown in this form. The user can realize the actual coordinates and the angles of 
the robots by opening the form. Finally, the camera directions of the robots can be rotated by the 
user in this form. The small rectangles in different colors denote the plane of the vertical angle 
and the horizontal angle of the robots. The range of the vertical angle is 0° to 90°; and the range 
of the horizontal angle is -90° to 90°. The user can click the plane or drag the white circle to 
change the position of the circle. If the user does, the head of the robot will be rotated to the 
corresponding direction. 
 
Fig. 3.5 The link for opening the robot setting form 
 
  24
B. Start 
 The game will start, if this button is clicked. 
C. Stop 
 If the user wants to discontinue the simulation, click this button. 
D Replay 
 If the simulation is stopped, the user can open the replay mode. 
E Exit 
 This button is used to close the main form. 
F Coordinate of the mouse 
 The coordinate of the mouse is shown in this label. 
 
3.4 The Basic Functions 
 There are some basic functions in the simulator, which are described briefly below. 
A. Move the ball and robots 
 The user can drag the robots and the ball for changing their positions. If the user presses the 
robot by the mouse, rolling the wheel of the mouse can rotate the robots. If the wheel rolled up, 
the robot will rotate in clockwise; on the contrary, if the wheel rolled down, the robot will rotate 
in counterclockwise. However, making the robots overlap each other is prohibited. 
B. Turn on/off the robots 
 The user can double click the robots to turn on/off the robots. If the robot is turned off, it can 
not execute any motion. 
C. Throw the ball 
 The user can throw the ball during the competition. After dragging the ball and the event of 
mouse-up, the simulator will make the ball move by itself. Then, the speed of the ball will slow 
down gradually. Moreover, the moving direction and the initial speed can be controlled by the 
user. 
  26
 
 
Fig. 3.11 The monitoring board 
 
F. Setting of display 
 The link for opening the display setting form is shown in Fig. 3.12. Fig. 3.13 shows the 
display setting form. The check box named “Show” denotes whether the visual region of the 
robot should be shown or not. “Alpha” denotes the transparency of the visual region. Besides, the 
value of “Alpha” is limited between 0 and 255. Next, the check box named “Delay” denotes the 
simulation delay. Importantly, the higher value of “Delay” is, the slower speed of the simulation 
will be. 
 
  28
characteristic of the field, in AndroSot, we set SF=4. Importantly, after the position of the ball is 
updated,   will be reduced. 
B. Collision handling 
 The calculation method of the collision point is shown in Fig. 3.14. The red line denotes the 
“wall”. It contains two points, Point1 and Point2. First of all, Ext_Point1, Ext_Point2, Ext_Point3 
and Ext_Point4 must be calculated as the following equations. Since R is the radius of the ball. 
And VX and VY are the x-y components of the vector which is orientated from Point1 to Point2. 
 
2 2
2 2
( ) ( )
( ) ( )
Point2X Point1XVX
Point2X Point1X Point2Y Point1Y
Point2Y Point1YVY
Point2X Point1X Point2Y Point1Y
         
 (3.3)
 
Ext_Point1X Point1X R VX R VY
Ext_Point1Y Point1Y R VY R VX
Ext_Point2X Point1X R VX R VY
Ext_Point2Y Point1Y R VY R VX
Ext_Point3X Point2X R VX R VY
Ext_Point3Y Point2Y R VY R VX
Ext_Point4X Point2X R VX R
    
    
    
    
    
    
    VY
Ext_Point4Y Point2Y R VY R VX
      
 (3.4)
  
 
Fig. 3.14 The collision point of the ball 
  30
point will be treated as the actual collision point. As shown in Fig. 3.14, Coll_Point2 is the actual 
collision point.  
After we get the actual collision point, the position of the ball must be updated after the 
collision. Fig. 3.15 shows the chain collision of the ball. Firstly, we use equation (3.2) to calculate 
Ball_End1. The distance between Ball_Start and Ball_End1 and is D1. D1 means the initial total 
distance of the ball trajectory. After the ball is moved to Coll_Point1, the total distance will be 
shortened to D2. After that, Ball_End2 is calculated. However, the collision event is occurred 
again. Thus, the ball is moved to Coll_Point2 again. And the total distance is shortened to D3. 
Finally, Ball_End3 is calculated; and no collision event. Therefore, Ball_End2 is the final 
position of the ball. Importantly, the angle of incidence is equal to the angle of reflection. As 
shown in Fig. 3.15. A1 is the angle of incidence and the angle of reflection from the first collision. 
And A2 is the angle of incidence and the angle of reflection from the second collision. 
 
 
Fig. 3.15 The chain collision of the ball 
  32
files is essential. For the facilitation of teaching, the free software, Dev C++ is chosen for the 
compiler. The picture of creating DLL files by Dev C++ is shown in Fig. 3.17. First of all, the 
user must open the project file (as shown in the left rectangle in Fig. 3.17) of the strategy. Then 
start to implement the strategy programs. The reference codes of the strategy are shown in 
Appendix. In Appendix A.2 (Dll_Project\AndroSot_Team_A\dllmain.cpp), line 48th to 93th are 
the strategies of the robots. For testing, some repetitive actions are assigned to the robots. 
However, for the briefness of the contents, we are not going to illustrate the detail of the codes in 
here since we do not make much fix on it. After coding, we can click the button (as shown in the 
circle in Fig. 3.17) which is on the upper-left corner of the form to compile the DLL file. If the 
compilation is successful, The DLL file will be created in the folder, as shown in the right 
rectangle in Fig. 3.17. 
 
Fig. 3.17 The picture of creating DLL files by Dev C++ 
 
 After DLL files are created by the user, they must be copied to the folder named “dll”. Next, 
open the form for loading the DLL files in the simulator. The link for opening the DLL loading 
  34
 
 
  
Fig. 3.21 The picture of master level in AndroSot 
 
 If the collision occurred between the robots during the competition, as shown in Fig. 3.22, 
the symbol of crossing wrench will be shown on the top of the robots. Moreover, The HP of the 
robots will also be reduced. However, if the HP is reduced to zero, the color of the symbol will be 
changed into gray (as the red robot). After that, the robot cannot move anymore unless repaired. 
 
Fig. 3.22 The picture of the collision between the robots 
  36
on the field and then decides the behavior each robot should have. 
 
2 The Dynamic Strategy System for AndroSot in FIRA 
In this section, we discuss the orientation of the robot to follow the direction of the resultant 
vector generated by the vector field by using the fuzzy logic control. 
 
2.1 Overview of Potential Field Navigation Method 
The conventional robot control consists of methods for path generation and path following 
[13]. When a robot moves away the estimated path, it must return immediately, and while doing 
so, the obstacle avoidance behavior and the effectiveness of such a path are not guaranteed. So, 
motion control is a difficult task, especially in real time and high speed control. We unify these 
two steps into one step, by generating suitable vector fields [14-21] and orienting the robots to the 
direction of these vector fields by using fuzzy logic control. 
 In the vector field method, a mobile robot can move in proportion to the resultant force. An 
originality of the algorithm is the concept that particle is repulsive to one with the same electric 
charge and is attractive to particle with the opposite electric charge. These opposite charges 
attracted, pulling the particles towards each other. In the robot soccer game, a robot tends to 
approach the ball and always avoid the collision with obstacle. It is not troublesome to implement 
the ideal by virtually setting the robot and obstacle to be both positive electric charges while the 
ball to be negative electric charge. 
 Since the entire vector field is composed of attractive force from the ball and repulsive force 
from the obstacle, we analyze the two elements respectively. For the analysis of attractive force, 
the robot is set to be a particle with positive electric charge and the ball to be particle with 
negative electric charge, as shown in Fig. 4.1. Where hbF

 is the attractive force between hq  
and bq . 
 
  38
2 2 2 2
- -= ,
( - ) +( - ) ( - ) +( - )
t h t h
t h t h t h t h
x x y yA
x x y y x x y y
    

 (4.1)
where A

 is the direction vector at position ( , )x y  with a unity magnitude, ( , )t tx y  is the 
coordinate of the target point, and ( , )h hx y  is the coordinate of the home robot. 
 Fig. 4.3 shows the repulsive force from the obstacle. Because the home robot always needs 
to avoid collision with other objects on the field, we set the obstacles as the same polar charges to 
form the repulsive forces. When the distance between the home robot and the opponent robot is 
far, the home robot doesn’t care about the opponent robot. Hence, we assume that when the 
distance is larger than the influence distance D, the repulsive force hoF

, which is generated by 
the opponent robot, would not influence the home robot. The obstacle vector field at each 
position is given as follows. 
2 2 2 2
- -, ,
= ( - ) +( - ) ( - ) +( - )
(0,0) ,
h o h o
o h o h o h o h o
x x y y distance D
R x x y y x x y y
distance D
      

 (4.2)
where oR

 is the direction vector with a unity magnitude, ( , )o ox y  is the coordinate of the 
opponent robot, and ( , )h hx y  is the coordinate of the home robot. 
 
 
Fig. 4.3 Repulsive force generated by the opponent robot 
 
 Fig. 4.4 depicts the resultant force for an attractive force from the ball and a repulsive force 
  40
 
Fig. 4.5 Vector field built by the obstacles and the ball 
 
2.2 Extended Potential Field Navigation Method 
 However, objects in the vicinity but are not in the way of the robot can produce unwanted 
effects (repulsive forces). The influence could cause the robot to move in a direction different 
from the desired one, as shown in the blue circles in Fig. 4.5. In order to address these problems, 
we adopt the following equation to calculate the angle between two vectors, 1V

 and 2V

. Where 
( , )1x 1yv v  is the x-y component of 1V

 and ( , )2x 2yv v  is the x-y component of 2V

. 
1
2 2 2 2
1 2 1 21
2 2 2 2
cos , 0
( )( )
( , , , )
cos , 0
( )( )
1x 2x 1y 2y
1x 2y 1y 2x
1x 1y 2x 2y
1x 1y 2x 2y
x x y y
1x 2y 1y 2x
1x 1y 2x 2y
v v v v
v v v v
v v v v
f v v v v
v v v v
v v v v
v v v v



                       
 (4.4)
 If the function returns a positive value, it means that 2V

 is on the direction of clockwise of 
1V

. On the contrary, if the function returns a negative value, it means that 2V

 is on the direction 
of counterclockwise of 1V

. Next, we calculate   and the new repulsive forces, EoR  by using 
the following equations. And the angle between hbV

 and hoV

 is shown in Fig. 4.6. 
  42
Aspect of the ball, we replace the negative electric charge with positive electric charge. And 
set a kicking point on the field, as shown in the yellow circle in Fig. 4.7. However, the kicking 
point is set as a virtual negative electric charge. The extended navigation method is shown in Fig. 
4.7. The path in red color is much smoother, and also the unwanted effects are eliminated. After 
the electric charge on the ball is changed and the kicking position is set, the robot can walk along 
the path to go to the kicking position. 
 
 
Fig. 4.7 The extended navigation method 
 
Sometimes, the robot will get stuck in local minima between two obstacles. To overcome 
this problem, we have to add the following rule. Fig. 4.8 shows three overlapped variable 
obstacles. If more than two variable obstacles are overlapped, they can be regarded as one 
obstacle [22] and a new central position of obstacles can be defined as follows. 
1 1
1 1= , =
n n
x xk y yk
k k
Q O Q O
n n 
   (4.9)
where ( , )x yQ Q  denotes the x-y values of center position of the overlapped obstacles. And n is 
the number of the overlapped variable obstacles. Thus, in this case, the repulsive force R

 must 
be corrected as the following equation (4.10). Fig. 4.9 shows the resultant force built by the 
  44
2.3 Pre-Calculating Information 
A. The position of the goal 
 In order to find the best shooting direction, the position of the goal is set by follows. 
2 2
2 2
2 2
( ) ( )
( ) ( )
( ) ( )
OB
G1
G2
D O_x - Ball_x O_y - Ball_y
D Goal_1x - Ball_x Goal_1y - Ball_y
D Goal_2x - Ball_x Goal_2y - Ball_y
      
 (4.11)
- -= ,
- -= ,
= ,
BO
OB OB
BG1
G1 G1
BG2
G2 G2
O_x Ball_x O_y Ball_yV
D D
Goal_1x Ball_x Goal_1y Ball_yV
D D
Goal_2x - Ball_x Goal_2y - Ball_yV
D D
                



 (4.12)
where ( , )O_x O_y , ( , )Goal_1x Goal_1y  and ( , )Goal_2x Goal_2y  are the coordinates of the 
opponent goalkeeper, Goal_1 and Goal_2 respectively, as shown in Fig. 4.10. OBD  is the 
distance between the ball and opponent goalkeeper. G1D  (or G2D ) represent the distances 
between the ball and Goal_1 (or Goal_2). Then its corresponding angle, Angle1 and Angle2 are 
calculated by the following equation. 
( , , , )
( , , , )
BO_x BO_y BG1_x BG1_y
BO_x BO_y BG2_x BG2_y
Angle1 f v v v v
Angle2 f v v v v


 
 (4.13)
where Angle1 and Angle2 are illustrated in Fig. 4.10. And f  is defined in equation (4.4). If the 
value of Angle1 × Angle2 is negative, it means that the opponent goalkeeper is located in the 
triangular region, as shown in Fig. 4.10. So the opponent goalkeeper may block the shooting path. 
Therefore, if Angle1 > Angle2, the shooting direction will be set in the center angle of Angle1. 
Else, the center angle of Angle2 is chosen. However, if the value of Angle1 × Angle2 is positive, 
it means that the opponent goalkeeper is not located in the triangular region. So, the shooting 
direction will just be set toward the middle of the goal. After the process described above, the 
shooting path will be changed to the new path which is not blocked. 
  46
 
Fig. 4.11 The kicking position on the field 
 
C. Extended setting of the goal 
 If the ball is within the edge of the field, the kicking region estimated by us will over the 
bound of the field as shown in Fig. 4.12. If the robot reluctant to go the kicking position, the 
robot may collide with the wall and fall. Besides, the extended setting of the goal is proposed as 
shown in Fig. 4.12. In this case, we calculate the positions of Goal_1, Goal_2 and opponent 
goalkeeper in the mirror imagine field. Then use this information to create a new kicking 
direction and a kicking position. Therefore, if the ball is kicked by the kicking direction, the ball 
will move along the orange dotted line, as shown in Fig. 4.12. Even though it is merely the ideal 
case of the movement, we still have greater opportunities to score. 
However, according to this idea, sometimes the situation of the shooting action is dangerous. 
As shown in Fig. 4.13, the ball may roll into our goal by accident. In order to address this 
problem, another extended setting of the goal is proposed. 
 
  48
  
In the case of the dangerous shooting, we calculate the positions of Goal_1, Goal_2 and 
opponent goalkeeper in the mirror imagine field 3. Then use this information to create a new 
kicking direction and a kicking position. Therefore, if the ball is kicked by the kicking direction, 
the ball will move along the pink dotted line, as shown in Fig. 4.14. The ball will be rebounded in 
two times, and then move towards the goal. Additionally, the dangerous shooting route is 
dispelled. 
 
 
Fig. 4.14 Another extended setting of the goal 
 
D. Decision of the walking direction 
 Fig. 4.15 shows the decision of the walking direction. Since RV

 is the vector which the 
robot faces, and PV

 is the vector generated by the potential field method. Besides, RP  is 
  50
line equation of the goalkeeper. However, 1D  and 2D  are constants; and normally, 1 2D D . 
Then we solve the following simultaneous equations. 
( )
01
Our_GoalY Ball_Yy Our_GoalY x Our_GoalX
Our_GoalX Ball_X
x D
      
 (4.18)
( )
02
Our_GoalY Ball_Yy Our_GoalY x Our_GoalX
Our_GoalX Ball_X
x D
      
 (4.19)
where ( , )Ball_X Ball_Y , ( , )Our_GoalY Our_GoalX  are the coordinates of the ball and our 
goal respectively. 
Therefore, after solving the simultaneous equations, two of the defending positions will be 
calculated as ( ) ( ), 11
D Our_GoalX Our_GoalY Ball_YD Our_GoalY
Our_GoalX Ball_X
       and 
( ) ( ), 22
D Our_GoalX Our_GoalY Ball_YD Our_GoalY
Our_GoalX Ball_X
      . If the robot reached the 
defending position, the shot taken by the opponent will be blocked. 
 
  
Fig. 4.16 The defending position of the defender and goalkeeper 
 
2.4 Design of Fuzzy Controller 
A. Decision of the turning level 
 In order to make the robot face the target, the robot must to turn left/right. And the turning 
level is generated by the fuzzy logic controller. The form of the setting of turning level 
parameters and the rule table are shown in Fig. 4.17. 
  52
 
Fig. 4.18 TError  and TDelta  of the turning level 
 
The membership functions of the input and output variables are all decomposed into seven 
fuzzy partition terms, NB (Negative Big), NM (Negative Medium), NS (Negative Small), ZE 
(Zero), PS (Positive Small), PM (Positive Medium) and PB (Positive Big). Each input 
membership function is described with triangular shape, presented in Figs. 4.19-4.20, respectively. 
The input variables are fuzzified according to the membership functions, and then the fuzzy rule 
table should be designed as the string grid, the upper part, in Fig. 4.17. 
ET
ZENSNMNB PS PM PB
0 5030 70-30-50-70
TError
 
Fig. 4.19 The membership function of the input variable TError  
 
  54
OT
TOutput
 
Fig. 4.21 The membership function of the output variable TOutput  
 
B. Decision of the walking level 
 On the other hand, in order to make the robot walk toward the target, the robot have to 
determine the distance of step at first. And the walking level is generated by the fuzzy logic 
controller. The form of the setting of walking level parameters is shown in Fig. 4.22. 
 
 
Fig. 4.22 The form of the setting of walking level parameters 
 
Firstly, the input data, WError  and WDelta  must be calculated as follows. 
  56
EW
WError
 
Fig. 4.24 The membership function of the input variable WError  
 
DW
WDelta
Fig. 4.25 The membership function of the input variable WDelta  
 
The membership function of the output variable WOutput  is shown in Fig. 4.26. We still 
use the center of area (COA) method to accomplish the defuzzification strategy, which can be 
described as equation (4.22). Furthermore, the value of WOutput  represents the walking level. 
Because we just want to make the robot walk toward the kicking position, there are no negative 
values assigned to WOutput . The higher value of WOutput  represents that the walking rate must 
be increased for reaching the kicking position. 
  58
Keep an appropriate 
distance to the ball
Near enough 
to the ball?
Is the robot much more close
to the ball than other robots?
Decide the
kicking direction
Is the robot on the 
kicking position?
Decide the
walking direction
Navigation & obstacle avoidance
using potential field method 
toward the kicking position
Aim at the goal?
RotateShoot
Yes No
No Yes
Yes
No
No
Yes
Start
 
Fig. 4.27 The strategy for attacker 
 
2.6 The Strategy for Defender 
Helping to defense is the major work of the defender. When the ball comes to the rear half 
field, in order to block the path from the ball to the goal, the defender needs to move to the 
defending position which is defined above. After that, in order to block the ball immediately, 
defender must to face the ball. If the defender reaches the defending position, there will be a great 
opportunity to block the attacking path of the ball. And this is also main function of the defender. 
On the other hand, when the ball comes to the front half field, the defender just acts as the 
attacker. In this situation, defender will also go to the kicking position and shoot. Fig. 4.28 
illustrates the flowchart of the defender robot. Besides, before the robots walk to the ball, the 
robots will check whether the robot is much more close to the ball than other robots. This is to 
prevent the collision occurred between team robots. 
  60
into our goal. In other words, the goalkeeper should dive for the ball. Furthermore, the diving 
direction is determined according to the moving path of the ball and the position of the 
goalkeeper. If the estimated moving path of the ball may go through the left side of the robot, the 
goalkeeper should dive left. And the rest can be done in the same manner. 
 
Table 4.1 The threshold values of bD  and s  
Region bD  s  
Region A bD > 10 pixels s < 60° 
Region B bD > 20 pixels s < 50° 
Region C bD > 30 pixels s < 40° 
Region D bD > 40 pixels s < 30° 
 
 
Fig. 4.29 The decision of the diving motion 
 
 Fig. 4.30 depicts the strategy for goalkeeper. Another work of the goalkeeper is to kick the 
ball away from the goal area. If the ball is not within the goal area, the goalkeeper robot will 
move to the defending position which is defined above, and then face the opponent goal. Besides, 
if the ball is getting closer and closer to the goal area, the goalkeeper robot will kick the ball 
  62
Here, the strategy system played the role of system integration. Furthermore, in order to facilitate 
the interpretation, some codes have to be introduced. Table 4.2 shows specifications of the codes. 
The codes are used for communicating with each system. 
 
Fig. 4.31 The communication among the systems in AndroSot 
 
(a) The interface of the vision system (b) The interface of the strategy system 
Fig. 4.32 The interface of the vision system and strategy system 
 
Table 4.2 Specifications of the codes 
Code Data type Transmission interface Checking function 
RS Boolean Shared memory Information updating 
DR1, DR2, DR3 Boolean Shared memory Robot detecting 
MD1, MD2, MD3 Boolean Shared memory Action state 
RMD1, RMD2, RMD3 Byte Zigbee module Action state 
CFD1, CFD2, CFD3 Byte Zigbee module Falling down 
 
 
  64
3.2 The Strategy System 
 Fig. 4.34 shows the system flowchart of the strategy system in AndroSot. First of all, 
commands which are sent by the robots must be received. Since RMD1, RMD2 and RMD3 are the 
command codes which denote that whether the action of the robot is finished. Next, we must 
check whether RS is equal to true or not. If so, it means that the updating of the information from 
the vision system is finished. Then, commands from the strategy system must be sent to the 
robots. However, if the action of the robot is not finished, command will not be sent to the robot. 
On the other hand, if action of the robot is finished, and the robot can’t be detected by the vision 
system, CFD1, CFD2 or CFD3 will be sent to the robot. Else, the strategy of the robot will be 
executed, and send the corresponding action command to the robot. Since CFD1, CFD2 and 
CFD3 are the command codes which denote that the state of the robot should be checked. In 
other words, the robot must confirm whether it falls down after receiving these commands. 
 
  66
Receive the 
commends from 
the host computer
Robot1 
action finished?Yes
Send RMD1 to 
the host computer
Contiune doing
the action
No
Receive 
CFD1?
Execute the strategy 
for getting up
Execute the 
commend of action
Yes No
Receiving data = Null?
No
Stay and wait
Yes
Start
 
Fig. 4.35 The system flowchart of Robot1’s motion control system in AndroSot 
 
3.4 Getting Back into Stable Standing 
 The collision between the robots may happen frequently in the competition and cause 
the robots to fall down. The robot must possess the ability to get back into stable standing 
automatically. However, since it is unpredictable for us to know the time that the robot might fall, 
we keep receiving command from the Zigbee module. If CFD1, CFD2 or CFD3 is received, the 
robot will execute the strategy for getting back into stable standing. Next, if one of the touch 
sensors is pressed, the robot will implement the climbing up motion to stand up according to the 
different fall down circumstance. The flowchart of getting back into stable standing strategy is 
shown in Fig. 4.36. 
 
  68
strategies for AndroSot. And the simulator proposed in chapter 3 is applied in the simulation. 
 
2.1 Rebound Shooting 
Fig. 5.1 shows the result of the rebound shooting. Firstly, two robots are scrambling for the 
ball. And the ball is kicked to the edge of the field. Then, the attacker of Team B executes the 
rebound shooting strategy. After rebounding, the ball moves directly to the goal of Team A. 
However, the goalkeeper of Team A predicts the moving path of the ball, and then dives for the 
ball. Finally, the ball is blocked successfully. 
 
(a) (b)
(c) (d)
  70
the ball will be stopped by the field friction. Although the success ratio is not high, we can create 
more opportunities for the next scoring. This is because the distance between the ball and the 
opponent goal is shortened by this shooting. 
 
(a) (b)
(c) (d)
(e) (f)
  72
(c) (d)
(e) (f)
(g) (h)
(i) (j)
  74
(c) (d)
(e) (f)
(g) (h)
(i) (j)
  76
ball.  
 
(a) (b)
(c) (d)
(e) (f)
(g) (h)
(i) (j)
Fig. 5.5 The result of penalty kick 
 
Fig. 5.6 shows the result of long shooting. Firstly, the ball was beside our robot. Our robot 
backward and shift left to approach the kick point. In order to make the path not blocked by 
  78
(k) (l)
(m) (n)
(o) (p)
(q) (r)
(s) (t)
Fig. 5.6 The result of long shooting 
 
Fig. 5.7 shows the result of backward kicking. Our robot found that the ball was behind him. 
In order to save time, not turn toward the ball but kick backward directly was an excellent 
strategy. So just kick backward powerfully and goal. 
  80
(m) (n)
(o) (p)
Fig. 5.7 The result of backward kicking 
 
Fig. 5.8 shows the result of side kicking. Our robot found that the direction of the ball with 
him was just at the left. In order to save time, our robot shift left to approach the kicking point 
quickly. Then he left side kicked the ball powerfully and goal. 
 
(a) (b)
(c) (d)
(e) (f)
  82
(a) (b)
(c) (d)
(e) (f)
(g) (h)
(i) (j)
(k) (l)
  84
International Conference on Intelligent Robots and Systems, 1997. IROS '97., 1997, 
vol. 3, pp. PS8-PS9. 
[13] B. J. Lee, S. O. Lee, and G-T Park, “Trajectory generation and motion tracking 
control for the robot soccer game,” in Proceedings of 1999 IEEE/RSJ International 
Conference on Intelligent Robots and Systems, 1999, vol. 2, pp. 1149-1154. 
[14] E. Rimon, “Exact robot navigation using artificial potential functions,” IEEE Trans. 
on Robotics and Automation, vol. 8, no. 5, pp. 501-518, Oct. 1992. 
[15] Y. Z. Guo, Design and implement ring potential field method for a three-on-three 
robot soccer game, Master Thesis, Dept. of Electrical Engineering, National Cheng 
Kung Univ., Tainan, Taiwan, R.O.C., June 2002. 
[16] J. Barraquand, and J. C. Latombe, “Robot motion planning: a distributed 
representation approach,” International Journal Automation, vol. 10, No. 6, pp. 
628-649, 1991. 
[17] J. Guldner, V. I. Utiken, H. Hashimoto, and F. Harashima, “Tracking gradients of 
artificial potential fields with non-holonomic mobile robots,” in Proceedings of 1995 
American Control Conference, 1995, pp. 2803-2804. 
[18] M. G. Park, J. H. Jeon, and M. C. Lee, “Obstacle avoidance for mobile robots using 
artificial potential field approach with simulated annealing,” in Proceedings of IEEE 
Conf. on IEEE International Symposium, 2001, vol. 3, pp. 1530-1535. 
[19] W. Su, R. Meng, and C. Yu, “A study on soccer robot path planning with fuzzy 
artificial potential field,” in Proceedings of 2010 International Conference on 
Computing, Control and Industrial Engineering (CCIE), 2010, vol. 1, pp. 386-390. 
[20] X. Xu, J. Xie, and K. Xie, “Path planning and obstacle-avoidance for soccer robot 
based on artificial potential field and genetic algorithm,” in Proceedings of The Sixth 
World Congress on Intelligent Control and Automation, 2006, vol. 1, pp. 3494-3498. 
[21] H. Shi, C. Sun, X. Sun, and T. Feng, “Chaotic potential field method and application 
  86
六、計畫成果自評： 
本子計畫組隊參與許多國內及國際比賽，皆獲得優異成績。本計畫目前成果如下： 
(一)本計畫所研發之機器人於2008年在中國青島所舉行之「FIRA 機器人足球世界盃：
AndroSot組」比賽中，獲得季軍。 
(二) 本計畫所研發之機器人於2008年在台南科技大學所舉行之「人工智慧單晶片電腦鼠暨
機器人實作競賽：AndroSot組」比賽中，獲得冠軍。 
(三) 本計畫所研發之機器人於2008年在台南科技大學所舉行之「台灣智慧型機器人國內及
國際邀請賽：AndroSot組」比賽中，獲得冠軍。 
(四) 本計畫所研發之機器人於2010年在印度所舉行之「FIRA 機器人足球世界盃：AndroSot
組」比賽中，獲得季軍。 
 
  88
推廣及運用的價值 
在未來，家庭除了服務型機器人以外，為家裡帶來歡笑的娛樂型機
器人也不可少。緊張、刺激的機器人足球賽更是可以讓每個家庭增
添許多歡樂，本計畫開發的模擬器除了教學以外，亦是在撰寫機器
人策略時，方便的工具。 
※ 1.每項研發成果請填寫一式二份，一份隨成果報告送繳本會，一份送 貴單位研發成
果推廣單位（如技術移轉中心）。 
※ 2.本項研發成果若尚未申請專利，請勿揭露可申請專利之主要內容。 
※ 3.本表若不敷使用，請自行影印使用。 
出席國際學術會議心得報告 
                                                             
計畫編號 NSC 97-2221-E-006-172-MY3 
計畫名稱 仿人形運動與娛樂機器人之設計、研製及應用-子計畫四: 仿人形運動與娛樂機器 
出國人員姓名 
服務機關及職稱 國立成功大學電機系 李祖聖 特聘教授 
會議時間地點 Sept. 25-28, 2010, Shanghai , China 
會議名稱 The 3nd International Symposium on Nonlinear Dynamics (2010 ISND) 
發表論文題目 
1. An MIMO Adaptive Terminal Sliding Function Controller Design Based on 
Parameters Estimation of the T-S Fuzzy Model Approach 
2. Robust neural network-based tracking control for electrically driven 
constrained robots with constraint uncertainties 
 
三、參加會議經過 
The 3nd International Symposium on Nonlinear Dynamics (2010 ISND)係 International 
Journal of Nonlinear Dynamics and Nonlinear Simulations 舉辦之國際會議。計畫主持人應
邀組織一 Mini-Symposium，其主題為 Nonlinear dynamics analysis and control，本
Mini-Symposium 共 6 篇論文。 
計畫主持人共發表兩篇論文，第一篇是“An MIMO Adaptive Terminal Sliding Function 
Controller Design Based on Parameters Estimation of the T-S Fuzzy Model Approach”，本論
文重點是探討適應性終端滑動函數控制之研究。另一篇論文是 “Robust neural 
network-based tracking control for electrically driven constrained robots with constraint 
uncertainties”，本論文重點是提出受制約機器人之電控下類神經網路控制法。 
 
四、與會心得 
兩論文最後版本獲刊登在 International Journal of Nonlinear Dynamics and Nonlinear 
Simulations 之期刊。摘要的檔案在本報告最後。 
 
 
 
 
58 Y.-T. Su et al. 
 
experiment result is presented to demonstrate the effectiveness of the proposed con-
trol method. Conclusions are drawn in Section 5. 
2   System Model of aiRobot-HBR1 
In this section, we will first describe the human body model. According to this model, 
the system of human-sized biped robot is constructed. Then the dynamic model of 
ISCM is introduced to explain the mechanism of HBM tracking control. Finally, the 
kalman filter is applied to estimate the states of the ISCM and the complete procedure 
of HBM tracking control is proposed. 
2.1   Human Body Model 
For realizing human biped motion tracking, the human body model should be simpli-
fied, ease compute, and reliable. Actually, the structure of the human skeleton is so 
complicated that there may have several degrees of freedoms coupled in the same 
joint. The geometric human body model designed by Hanavan [4] in 1964 is wildly 
adopted. As shown in Fig. 1, Hanavan’s model is a mathematical model that com-
prises 15 segments. He considered the segments as rigid bodies and assumed the seg-
ments are homogenous. 
   
Fig. 1. Hanavan’s human body model    Fig. 2. Coordinate system definition of human leg 
   
 (a) (b) 
Fig. 3. (a) The front view and (b) the lateral view of aiRobot-HBR1 
   
 (a) (b) 
Fig. 4. (a) Appearance of the ISCM controller (b) Appearance of ISCM-D1 and ISCM-D2 
60 Y.-T. Su et al. 
 
make movements following the human leg motion. From Eq. (1), the relation between 
T( ) g ( ) g ( )x y zg t t t⎡ ⎤⎣ ⎦  and 
T( ) g ( ) g ( )x y zg t t t t t t⎡ ⎤+ Δ + Δ + Δ⎣ ⎦  can be expressed 
as follows:  
2
2
2
( ) ( )
( ) ( )
( ) ( )
x x y z x z y
x x
y x y z y y z x y
z zx z y y z x z
r V C r r V r S r r V r Sg t g t t
g t r r V r S r V C r r V r S g t t
g t g t tr r V r S r r V r S r V C
φ φ φ φ φ φ
φ φ φ φ φ φ
φ φ φ φ φ φ
Δ Δ Δ Δ Δ Δ
Δ Δ Δ Δ Δ Δ
Δ Δ Δ Δ Δ Δ
⎡ ⎤+ − +⎡ ⎤ ⎡ ⎤+ Δ⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥= + + − + Δ⎢ ⎥ ⎢ ⎥⎢ ⎥⎢ ⎥ ⎢ ⎥+ Δ⎢ ⎥
− + +⎣ ⎦ ⎣ ⎦⎣ ⎦
 (2) 
The inverse of a rotation matrix is the transpose of the matrix. Eq. (2) becomes 
2
2
2
( ) ( )
( ) ( )
( ) ( )
x x y z x z y
x x
y x y z y y z x y
z zx z y y z x z
r V C r r V r S r r V r Sg t t g t
g t t r r V r S r V C r r V r S g t
g t t g tr r V r S r r V r S r V C
φ φ φ φ φ φ
φ φ φ φ φ φ
φ φ φ φ φ φ
Δ Δ Δ Δ Δ Δ
Δ Δ Δ Δ Δ Δ
Δ Δ Δ Δ Δ Δ
⎡ ⎤+ + −⎡ ⎤ ⎡ ⎤+ Δ ⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥+ Δ = − + +⎢ ⎥ ⎢ ⎥⎢ ⎥⎢ ⎥ ⎢ ⎥+ Δ ⎢ ⎥+ − +⎣ ⎦ ⎣ ⎦⎣ ⎦
 
Considering 0tΔ →  and 0φΔ → , above equation can be simplified as 
1( ) ( )
( ) 1 ( )
1( ) ( )
z yx x
y z x y
y xz z
r rg t t g t
g t t r r g t
r rg t t g t
φ φ
φ φ
φ φ
⋅ Δ − ⋅Δ⎡ ⎤⎡ ⎤ ⎡ ⎤+ Δ ⎢ ⎥⎢ ⎥ ⎢ ⎥
+ Δ = − ⋅Δ ⋅Δ⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎢ ⎥ ⎢ ⎥
⋅ Δ − ⋅ Δ+ Δ⎣ ⎦ ⎣ ⎦⎣ ⎦
 (3) 
Moreover, 
( ) 1 0 0 ( )
( ) 0 1 0 ( )
0 0 1( ) ( )
x x
y y
z z
g t g t
g t g t
g t g t
⎡ ⎤ ⎡ ⎤⎡ ⎤⎢ ⎥ ⎢ ⎥⎢ ⎥
=⎢ ⎥ ⎢ ⎥⎢ ⎥⎢ ⎥ ⎢ ⎥⎢ ⎥⎣ ⎦⎣ ⎦ ⎣ ⎦
 (4) 
Subtract Eq. (4) from Eq. (3) and then divide by tΔ , we get 
0, 02 2 2
x x
t x
x y z
r r
t tr r r
φ
φ φ
ωΔ → Δ →
⋅ Δ Δ
= ⋅ ≡
Δ Δ+ +
 
0, 02 2 2
y y
t y
x y z
r r
t tr r r
φ
φ φ
ωΔ → Δ →
⋅ Δ Δ
= ⋅ ≡
Δ Δ+ +
 
0, 02 2 2
z z
t z
x y z
r r
t tr r r
φ
φ φ
ωΔ → Δ →
⋅ Δ Δ
= ⋅ ≡
Δ Δ+ +
 
Note that 2 2 2 1x y zr r r+ + = . xω , yω , and zω  denote the components of the angular 
velocity measured by gyroscope. Thus, we get the dynamic model of the ISCM: 
62 Y.-T. Su et al. 
 
3   Kalman Filter Based HBM Tracking 
Considering the dynamic model of the ISCM, system equation Eq. (6) and output 
equation Eq. (7), we can estimate the state ( ) ( ) ( ) Tx y zg k g k g k⎡ ⎤⎣ ⎦  by utilizing the 
discrete Kalman filter [6]. The estimated state is the gravity acceleration with respect 
to the sensor coordinate system, which is attached in the human leg. Define 
( ) ( ) ( ) T1 1 1x y zg k g k g k⎡ ⎤⎣ ⎦  as the estimated state of the ISCM-D1 and  
( ) ( ) ( ) T2 2 2x y zg k g k g k⎡ ⎤⎣ ⎦  as the estimated state of the ISCM-D2. The posture 
[ ]Th1 h2 2θ θ θ  can be obtained by the inverse kinematics, that is 
11
1 2 2
1
tan yh
y
g
g g
θ −
⎛ ⎞⎜ ⎟
= ⎜ ⎟⎜ ⎟
−⎝ ⎠
, 
1 1
2
1
tan xh
z
g
g
θ − ⎛ ⎞= ⎜ ⎟
−⎝ ⎠
, 
2 1 1 21
2
1 2 1 2
tan y z y z
y y z z
g g g g
g g g g
θ −
⎛ ⎞
−
= ⎜ ⎟⎜ ⎟+⎝ ⎠
 
where 2 2 2x y zg g g g= + + . The overall flow of the HBM tracking based on Kal-
man filter is depicted in Fig. 5. The parameter selection and tuning have much to do 
with the performance of the Kalman filter. Fig. 6 and Fig. 7 show the estimation result 
of the Kalman filter. Fig. 6 is measured in the condition that human expeditiously 
rotate the ISCM with a 90 degree. Fig. 7 is under a heavy vibration motion that hu-
man vibrates the ISCM in a horizontal plane. By the natural of the Kalman filter and 
well parameter tunings, the Kalman filter can reject the noise existing in the meas-
urements efficiently. However, the dynamic model of the ISCM did not considered 
the compensation for the translation acceleration. We just consider the translation 
acceleration as the noise existing in the measurements. Although the estimate may 
become a little inaccuracy in the situation existing large translation acceleration, it is 
receivable. Based on these results, we can realize the posture of human thigh and 
shank with respect to the reference coordinate system by the ISCM. Fig. 8 depicts the 
control structure of the real-time HBM tracking control with ISCM for airobot-HBR1. 
The posture of the human thigh and shank is the control input of the real-time HBM 
tracking control. The posture of the human thigh and shank are mapped to the biped 
robot directly. In other words, if the rotation angle of the human knee joint is known, 
this angle is regard as the command of the knee joint of the robot, because the motion 
control system of the robot receives the absolute angle commands. Therefore, it is the 
“direct mapping” from the human body to airobot-HBR1. 
4   Experiment Result 
In this section, the results of the real-time HBM tracking control are presented. As 
shown in Fig. 9, ISCM-D1 and ISCM-D2 are attached in human thigh and shank. In 
the experiments, human swings his leg forward, backward, and right to demonstrate the 
validity and the performance of the real-time HBM tracking control. Fig. 10 shows the 
successive tracking results of the swinging forward. Fig. 11 shows the successive 
tracking results of the swinging backward, and Fig. 12 shows the successive tracking 
64 Y.-T. Su et al. 
 
 
Fig. 11. Tracking results of the swinging backward 
 
Fig. 12. Tracking results of the swinging right 
5   Conclusion 
This paper has presented the SOPC based HBM tracking control for the human-sized 
biped robot, aiRobot-HBR1. We have presented the dynamic model of the ISCM and 
the kinematics model of human leg. The Kalman filter is utilized to estimate the states 
of the ISCM model, and the kinematics model is to figure out the posture of human 
leg. Then the human posture maps to the joint commands of the robot directly to real-
ize the real-time HBM tracking control. Finally, the experiment results show the fea-
sibility of proposed HBM tracking control.  
Acknowledgment 
This work was supported by National Science Council of Taiwan, R.O.C, under 
Grants NSC97-2221-E006-0-160-MY3 and NSC97-2221-E006-0-172-MY3. 
References 
1. Su, Y.-T., Hu, C.-Y., Lu, M.F., Chang, C.-M., Lai, S.-W., Liu, S.-H., Li, T.-H.: Design and 
implementation of SOPC based image and control system for HuroCup. J. of Harbin Insti-
tute Tech (New Series) 15, 41–46 (2008) 
2. Li, T.-H., Su, Y.-T., Liu, S.-H., Hsiao, M.-Y.: Design and Implementation of a Gait Pattern 
Generator Based on Fuzzy Control for Small-Sized Humanoid Robot by Using SOPC. In: 
2008 CACS Int. Automatic Control Conference, Taiwan (November 2008) 
3. Su, Y.-T., Li, T.-H., Hsu, C.L., Lu, M.F., Hu, C.Y., Liu, S.H.: Omni-Directional Vision-
Based Control Strategy for Humanoid Soccer Robot. In: Proc. of 2007 IEEE IECON, pp. 
2950–2955 (November 2007) 
4. Hanavan, E.P.: A mathematical model of the human body. AMRL. Technical Report 64-
102. Wright-Patterson Air Force Base, OH (1964) 
5. Fu, K.S., Gonzales, R.C., Lee, C.S.G.: Robotics: control, sensing, vision, and intelligence. 
McGraw-Hill Book Company, New York (1987) 
6. Welch, G., Bishop, G.: An introduction to the Kalman filter, Department of Computer Sci-
ence, University of North Carolina, Chapel Hill, TR 95 – 041 
 Design and Implementation of SOPC Based Motion Control 131 
This paper is organized as follow. The hardware design of the human-sized biped 
robot, aiRobot-HBR1, is presented in Section 2. The biped robot motion control  
system is depicted in Section 3. In section 4, the experiment result is presented to 
demonstrate the effectiveness of the proposed hardware design and control method. 
Conclusions are drawn in Section 5. 
2   Mechanism and Hardware of aiRobot-HBR1 
The biped robot presented in this paper consists of two legs, and each leg is composed 
of a thigh, shank, and foot. There are six degrees-of-freedoms (DOFs) in each leg, 
three of which are located in the hip joint, one in the knee joint, and two in the ankle 
joint. The arrangement of the motors is shown in Fig. 1 and the 3D design graph is 
shown in Fig. 2. 
Fig. 3. shows the appearance of aiRobot-HBR1. Table 1 lists the specification of 
aiRobot-HBR1. Fig. 4 depicts the control system structure of aiRobot-HBR1. The 
central processor unit of the overall control system is Altera Cyclone II EP2C20 
FPGA. The core processor of this FPGA is a 32 bits Nios II CPU. FPGA (Field Pro-
grammable Gate Array) are now wildly used in the field of digital integrated circuit 
design and verifying. And there are twelve Maxon RE40 DC motors used as actua-
tors. According to different rated currents, the power system is divided into high 
power part and low power part. While planning the power supplying system, it is 
important to distinguish these two parts to avoid destroying of the device. Fig. 5 de-
picts the planning of the power system. 
                                                          
            Fig. 1. Arrangement of motors               Fig. 2. 3D design graph of aiRobot-HBR1 
Table 1. Specification of aiRobot-HBR1 
Height 110 cm 
Weight 40 kg 
Hip 3 DOFs 
Knee 1 DOFs DOFs 
Ankle 2 DOFs 
Controller Altera NIOS II FPGA 
Actuator DC motor 
Material of the structure A5052 aluminum alloy 
 Design and Implementation of SOPC Based Motion Control 133 
motor driver, motor, and encoder. Most motor controllers are implemented in software 
in programmable logic controllers. Software programming has the advantages of 
flexibility and saving time. When system is complicated or needs much computation, 
software program which executes sequentially becomes not efficient. The excellence 
of hardware implementation is its high speed and parallel execution. NIOS II FPGA 
combines the feature of hardware implementation and software programming. One 
can design the hardware circuit in the FPGA as well as program control strategies in 
the NIOS II CPU. The mechanism is called “system on a programming chip” (SOPC). 
Based on the feature of the SOPC, the motion control system can control several mo-
tors simultaneously and communicate with computers or other devices easily. There-
fore we develop the motor controller in the FPGA. The motor controller can be por-
tioned into four parts: digital noise filter, feedback decoder unit, PD controller, and 
PWM module. Fig. 7 depicts the control structure of the motor controller for one 
motor. 
The form of the discrete PD algorithm is [ ]( ) ( )  ( ) ( 1)p du k K e k K e k e k= + − − . In 
real implication, we multiply u(k) by a scale factor to get the PWM duty ratio which 
presents the velocity command of the motor control system. We use VerilogHDL to 
implement the PD controller in the FPGA, and the control structure of the PD 
controller is shown in Fig. 8.  
The feedback decoder unit utilizes two techniques to implement the function. Fi-
nite state machine and digital noise filter are combined to transfer the two incoming 
quadrature signals of the encoder to the rotation angle, and angular velocity. The en-
coder outputs two quadrature signals A and B according to the rotation angle of the 
motor. These two signals have a 90 degrees phase difference. Discerning which signal 
leads another provides us to realize the rotation direction of the motor. Moreover, the 
frequency and the width of the signal A and the signal B are proportional to the angu-
lar velocity of the motor. Count the number of pulses passing through in a fix interval 
or calculate the width of the pulse, we can realize the angular velocity of the motor. 
Generalizing the relationship between the signal A and the signal B, it can be inter-
preted by a state diagram as shown in Fig. 9.  
In the practical application, signals are interfered by noise easily. If we just use the 
decoder as designed above, it will work badly and miss the rotation information. 
Hence, we add a finite impulse response (FIR) filter in the front stage of the feedback 
decoder unit. The digital noise filter is responsible for rejecting noise for the incoming 
quadrature signals. 
The encoder captures the position information of the motor and outputs two quad-
rature signals. After the signals processed by the feedback unit, the angle of the motor 
is transmitted to the PD controller. The motor controller will make calculations and 
subsequently outputs values of PWM duty to the PWM module. The corresponding 
PWM signal are generated by the PWM module and be transmitted to the outer motor 
driver. Based on this circuit for one motor, we construct a motion control system 
which can control twelve motors simultaneously. 
3.2   Trajectory Planning 
Trajectory planning is to generate motion patterns for the robot to achieve user’s 
planning. Fig. 10 shows a diagram in sagittal plane of the robot that biped robot swing 
 Design and Implementation of SOPC Based Motion Control 135 
 
Fig. 8. Control structure of the PD controller 
 
Fig. 9. State diagram of the signal A and the signal B 
 
Fig. 10. Swing leg for avoiding obstacle 
4   Experiment Result 
In this section, an experiment is planned for confirming the performance of the pro-
posed motion control system. The experiment runs the procedure from motion plan-
ning to practical motion test, and it is to plan a motion pattern for the robot to make a 
lifting leg motion. Firstly, recode desired commands for each joint by using GUI. The 
desired commands for each joint has six desired points as shown in Fig. 11. Second, 
we use the cubic spline line interpolation method to insert some points among these 
six points. Finally, the robot makes a lifting leg motion in practice. Fig 11 shows the 
 Design and Implementation of SOPC Based Motion Control 137 
Acknowledgment 
This work was supported by National Science Council of Taiwan, R.O.C, under 
Grants NSC97-2221-E006-0-160-MY3 and NSC97-2221-E006-0-172-MY3.  
References 
1. Chang, C.-M., Lu, M.F.g., Hu, C.-Y., Lai, S.-W., Liu, S.-H., Su, Y.-T., Li, T.-H.: Design 
and Implementation of Penalty Kick Function for Small-Sized Humanoid Robot by using 
FPGA. In: Proc. IEEE Workshop on Advanced Robotics and its Social. Impacts (ARSO 
2008), Taiwan (August 2008) 
2. Su, Y.-T., Li, T.-H., Hsu, C.L., Lu, M.F., Hu, C.Y., Liu, S.H.: Omni-Directional Vision-
Based Control Strategy for Humanoid Soccer Robot. In: Proc. of 2007 IEEE IECON, pp. 
2950–2955 (November 2007) 
3. Su, Y.-T., Li, T.-H.: Design and Implementation of Fuzzy Auto-Balance Control for Hu-
manoid Robot. In: 2007 FIRA RoboWorld Congress, USA (June 2007) 
4. Kajita, S., Nagasaki, T., Kaneko, K., Hirukawa, H.: ZMP-Based Biped Running Control. 
IEEE Robotics and Automation Magazine 4, 63–72 (2007) 
5. Fu, C., Chen, K.: Gait Synthesis and Sensory Control of Stair Climbing for a Humanoid 
Robot. IEEE Transactions on Industrial Electronics 55, 2111–2120 (2008) 
6. Kanehiro, F., Kaneko, K., Fujiwara, K., Harada, K., Kajita, S., Yokoi, K., Hirukawa, H., 
Akachi, K., Isozumi, T.: The first humanoid robot that has the same size as a human and 
that can lie down and get up. In: IEEE International Conference on Robotics and Automa-
tion, ICRA 2003, vol. 2, pp. 1633–1639 (2003) 
7. Mitsunaga, N., Smith, C., Kanda, T., Ishiguro, H., Hagita, N.: Adapting Robot Behavior 
for Human–Robot Interaction. IEEE Transactions on Robotic, 911–916 (August 2008) 
8. Su, Y.-T., Hu, C.-Y., Lu, M.F., Chang, C.-M., Lai, S.-W., Liu, S.-H., Li, T.-H.: Design and 
implementation of SOPC based image and control system for HuroCup. J. of Harbin Insti-
tute Tech (New Series) 15, 41–46 (2008) 
9. Li, T.-H., Hsu, C.-L., Hu, C.-Y., Su, Y.-T., Lu, M.-F., Liu, S.-H.: SOPC Based Weight 
Lifting Control Design for Small-Sized Humanoid Robot. In: Proc. 2008 ICCAS, Korea 
(October 2008) 
10. Li, T.-H., Su, Y.-T., Liu, S.-H., Hsiao, M.-Y.: Design and Implementation of a Gait Pattern 
Generator Based on Fuzzy Control for Small-Sized Humanoid Robot by Using SOPC. In: 
2008 CACS Int. Automatic Control Conference, Taiwan (November 2008) 
 
 

國科會補助計畫衍生研發成果推廣資料表
日期:2011/11/29
國科會補助計畫
計畫名稱: 子計畫四: 仿人形運動與娛樂機器人之系統開發與整合
計畫主持人: 李祖聖
計畫編號: 97-2221-E-006-172-MY3 學門領域: 智慧型機器人
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
指導學生參加 2011 RoboCup Japan Open Osaka，獲得人形機器人 3 對 3 機器
人足球賽亞軍以及技術挑戰賽季軍。 
指導學生參加 2010 FIRA RoboWorld Cup 獲得人形機器人組(HuroCup: All 
Round)總冠軍，人形機器人投籃賽冠軍、人形機器人障礙賽冠軍、人形機器人
不平坦路面負重賽季軍 
指導學生參加 2010 FIRA RoboWorld Cup 獲得 AndroSot 組銅牌 
指導學生參加 2010 年 RoboCup 世界機器人足球競賽獲「小型人形機器人技術挑
戰賽」亞軍 
指導學生參加 2010 台灣智慧型機器人國內及國際邀請賽獲「FIRA AndroSot 競
賽」第一名 
指導學生參加 2010 台灣智慧型機器人國內及國際邀請賽獲「人形機器人探索
挑戰賽」第三名 
指導學生參加 2009 年 RoboCup 世界機器人足球競賽: 人形機器人組，挺進前八
強，是台灣區所有隊伍中，歷年來最好的成績。 
 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
