1國科會計畫：NSC 98-2221-E-009-081-MY3
一商業流程規格中 Artifacts異常使用偵測之研究
A Study to Detecting Artifact Anomalies in Workflow
Specifications
摘要
一個結構良好的工作流程仍然可能由於錯誤的資料存取而發生執行期錯誤，在過去，由
於結構衝突造成的資料存取錯誤已經被充分地研究，然而混合了時序與結構因素所造成
的資料存取錯誤，也就是 artifact 異常使用，則仍然缺乏討論，在本計畫中，我們發展
了一個可以針對時序結構化工作流程規格進行分析，找出隱藏於其中，由於時序與結構
化因素同時作用而造成的資料存取錯誤，我們嶄新的分析方法，藉由將工作流程中的迴
圈簡化可以達成快速的分析，幫助工作流程設計者除去規格中隱藏的資料存取錯誤，進
一步減少工作流程在執行期可能發生的問題。
關鍵字：工作流程、時序結構化工作流程、工作流程規格分析、artifact異常使用、資料
存取錯誤
31. Introduction
A workflow is a set of tasks systematized to achieve certain business goals by completing
the tasks in a particular order under automatic control (WfMC, 1999). Structural conflicts
among tasks such as deadlocks might cause run-time errors, and should be eliminated. Analyses
of workflow specifications are helpful in reducing such conflicts. By mapping workflow
specifications into petri-nets, Adam’s methodology can detect inconsistent dependencies 
among tasks to assure the safety of a workflow (Adam et al., 1998). Van der Aalst develops a
petri-net based methodology to verify deadlocks, livelocks (infinite loops), and dead tasks in
workflow specifications (van der Aalst and ter Hofstede, 2000; van der Aalst et al., 1999).
Kiepuszewski et al. (2000) define the structured workflow model which is free from deadlock
and multiple active instances of the same activity, i.e. the structured workflow is well-behaved.
Kiepuszewski et al. claim that although structured workflow model is less expressive, most
arbitrary well-behaved workflows can be transformed into a structured workflow, and
structured workflow is a good tool for workflow analysis (Kiepuszewski et al, 2000).
However, a well-structured workflow may still fail or produce unanticipated run-time
behavior because of abnormal data manipulation, the artifact anomalies. Detect artifact
anomalies in workflows checks possible data misuse buried in workflow specifications. Various
methodologies have been developed for detection of artifact anomalies generated from
structural relationships between activities in a workflow (Sadiq et al., 2004; Wang et al., 2006;
Hsu et al., 2007; Wang et al., 2009; Hsu et al, 2009). Sadiq et al. (2004) present seven basic
data validation problems, redundant data, lost data, missing data, mismatched data, inconsistent
data, misdirected data, and insufficient data in structured workflow model. Hsu et al. define
preliminary improper artifact usages anomalies, and introduce the analysis of such anomalies in
design phase of a structured workflow (Wang et al., 2006; Hsu et al., 2007). Wang et al. (2009)
introduce a behavior model to describe the data behavior in a workflow and refine the work
accomplished by Hsu et al. (2007) through improving its efficiency. Hsu et al. (2009) raise the
issues about analyzing artifact anomalies in workflows adopting message passing data models,
and describe a formal description for such anomalies. Nevertheless, how temporal factors may
affect the analysis of artifact anomalies is still seldom addressed. The methodology detecting
artifact anomalies generated from twisted temporal and structural relationships between
activities in workflows should be further discussed on the basis of the previous studies.
Besides, analysis of workflows may not be completed without considering temporal issues.
Li et al. (2004a) indicate that analysis of temporal factors is essential for validation of the
interval dependencies with temporal constraints in a workflow schema. Adam et al. (1998)
consider timing constraints as the external conditions for structural correctness of a Petri-net
based workflow model. Chen and Yang (2008) develop an approach for dynamic verification of
fixed-time constraints in grid workflow syste. From a graph based workflow model, Eder et al.
52. Temporal Structured Workflow Model
2.1 Basic Elements
A workflow is composed of a start process, an end process, some activity processes and
some control processes. The start (ST) process represents the entry point of a workflow, and the
end (END) process indicates the termination point. An activity (ACT) process stands for a piece
of work to be performed and describes one logical step within a workflow (WfMC, 1999).
A control process is a routing construct used to control the divergence and convergence of
sequence flows. The control processes can be classified as AND-split (AS), AND-join (AJ),
XOR-split (XS), and XOR-join (XJ). An AND-split process within a workflow splits a single
sequence of control into two or more sequences to allow simultaneous execution of activities;
on the contrary, an AND-join process merges multiple parallel executing sequences into a
single common sequence of control (WfMC, 1999). An XOR-split process within a workflow
is the point where a single sequence of control decides a branch to take from multiple
alternative branches, and an XOR-join process converges multiple alternative branches in a
workflow (WfMC, 1999).
Processes are connected by directed flows, the flow(s) leading to a process are called the
in-flow(s) of the process, and the flow(s) departing from a process are called the out-flow(s) of
the process. The process starting a flow is the source process of the flow, and the process ending
a flow is the sink process of the flow. In a workflow, only AND-split and XOR-split processes
have multiple out-flows, and only AND-join and XOR-join processes have multiple in-flows.
Figure 1 illustrates the notation of the basic elements described above.
Figure 1 The Graphic Notations of the Basic Workflow Elements
With all the descriptions above, a workflow is modeled as following:
Definition 1 (Workflow Model)
A workflow w, w = (Pw, Fw, s, e). and
Pw represents the set of the processes in w, and
pPw, p.type{ACT, AS, AJ, XS, XJ, ST, END}
FwPwPw represents the set of flows in w.
7All the processes between the start and the end process in a structured workflow are
organized with the building blocks shown in Figure 2. For Figure 2(c) and Figure 2(d), the
blocks X1, X2, …, and Xn represent the branches split and converged in a parallel structure or a
decision structure. Besides, in Figure 2(e), the structured loop acts like a do-while loop when
block Y is null, and acts like a while loop when block X is null. Figure 3 illustrates the control
graph of a sample structured workflow.
Figure 3 A Sample Structured Workflow
Two processes are reachable from one to the other if there exists a path between them,
parallel if they reside on different branches of a parallel structure, and exclusive to each other if
they reside on different branches of a decision structure. Take Figure 3 for example. The path
<v1, xs1, v2, v3> indicates that v1 is reachable to v3. v3 and v4 are parallel because they reside on
different branches split from as1. v2 and v8 are exclusive because they reside on different
branches of the decision structure quoted by xs1 and xj1. In this report, the above structural
relationships between processes are notated as following Boolean functions:
Definition 3 (Structural Relationships in a Structured Workflow)
For a structured workflow w,
Reachable: PwPw {true, false}
Reachable(p, q) holds if and only if there exists a path from p to q.
Parallel: PwPw {true, false}
Parallel(p, q) holds if and only if p and q reside in different branches of a
parallel structure.
Exclusive: PwPw {true, false}
Exclusive(p, q) holds if and only if p and q reside in different branches of a
decision structure.
2.3 Temporal Structured Workflow
A timed workflow is modeled by describing the maximal and minimum working durations
for each activity (Zhuge et al., 2001). In this report, a timed and structured workflow named as
Temporal Structured Workflow (TS workflow) is formally modeled as following:
9reduction method for the analysis of TS workflow.
First, it is assumed that the maximal number of iterations for a structured loop in a TS
workflow is finite. In other words, the infinite loops are not discussed in this study. Based on the
assumption, a structured loop is transformed into a decision structure with three branches: no
iteration, a single iteration, and maximal iterations as Figure 5 illustrates.
Figure 5 Refined Loop Reduction for TS Workflow Model
The refined loop reduction bring following advantage: (1) All the possible state variations
of artifacts between iterations are still completely captured, (2) the active intervals of the
processes succeeding to the structured loop can still be accurately estimated because the worst
case scenario is considered, and (3) the methodology for acyclic structured workflow can be
adopted in TS workflow because the structured loops are reduced. In this project, loop-reduced
TS workflows (LRTS workflows) are widely adopted in our methodology.
2.4.2 Analysis of Structural Relationships between Processes in LRTS workflow
The structural relationships between activity processes are the groundwork for analysis of
TS workflow, and are described and proved in the following lemma.
Lemma 1
For an LRTS workflow w, p and qPw, and p.type == q.type == ACT, one and
exactly one of the following statements, Reachable(p, q), Reachable(q, p),
Parallel(p, q), and Exclusive(p, q), holds.
Proof:
An LRTS workflow is still structured, and the lemma can be proved through the
discussion of the construction rules of a structured workflow. Because a single activity
process is a basic building block of a structured workflow, p and q can always be distributed
into two different building blocks combined in a sequence, a parallel structure, or a decision
11
Definition 6 (ABStack)
pPw, p.abstack represents the ABStack corresponding to p.
A structural item, stitem = (sp, bm), is included in p.abstack if and only if
(1) spPw, sp.type{AS, XS}, and a path <sp, …, p, …, jn> in w where jn is the
corresponding join process of sp.
(2) bm = BM( (sp,p’) ) wherep’== p or Reachable(p’, p) == true.
p.abstack == « » if and only if p resides in no decision/parallel structure.
p.abstack == «(sp1, bm1), (sp2, bm2), …, (spk, bmk)» exists if and only if a path
<spk, …, sp2, …, sp1, …, p, …, jn1, …, jn2, …, jnk> exists.
To calculate ABStacks of the processes in an LRTS workflow, push and pop
functions associated with ABStack are defined as following:
Let an ABStack abs == «(sp1, bm1), (sp2, bm2), …, (spk, bmk)»
Push( abs, (sp, bm) ) returns a new ABStackabs’, where
abs’== «(sp, bm), (sp1, bm1), (sp2, bm2), …, (spk, bmk)»
Pop( abs ) returns a new ABStackabs’, where
abs’== «(sp2, bm2), …, (spk, bmk)»
Figure 6 illustrates how push and pop functions work for the calculation of the ABStacks
corresponding to the processes in an LRTS workflow.
Figure 6 Calculation of ABStacks for Processes in an LRTS Workflow
13
As for the only-if-part, if Parallel(p, q) == true, p and q reside on different branches of a
parallel structure. Let sp be the AND-split process starting the parallel structure, and jn be the
AND-join process terminating it. The nodes in the path from sp to p are totally different from
those in the path from sp to q. Besides sp and jn, two distinct paths, <sp, …, p, …, jn> and
<sp, …, q, …, jn>, exist. Therefore, there exists a process m that (sp, m)Fw and either m is
equivalent to p or Reachable(m, p) == true. Similarly, there also exists such a process n for q.
m and n can not be the same process because they reside on different branches split from sp,
and thus, BM(sp, m) ≠ BM(sp, n). According to Definition 6, (sp, BM(sp, m)) is included in
p.abstack, and (sp, BM(sp, n)) is included in q.abstack. The only-if part of statement (1) of
the lemma is proved.
Part (2) can be proved similarly and the proof is omitted here. With the paragraphs above,
Lemma 2 is shown correct.□
2.4.3 Analysis of Twisted Temporal and Structural Relationships between Processes in LRTS
workflow
In a TS workflow, the temporal and structural relationships between processes are twisted.
This section firstly shows how to identify the temporal property between processes.
Figure 8 The Temporal Relationships between Time Intervals (Allen, 1983)
A time interval is duration of a segment of time. Allen (1983) defines seven reasoning
relationships between time intervals. Figure 8 illustrates the temporal relationships adopted in
this project on the basis of Allen’s definition, and Definition 7 describes the formal definition of
time intervals and the temporal relationships between time intervals adopted in this project.
15
EST(p) indicates the earliest time that p can be initialized.
LET(p) indicates the latest time that p must terminate.
With the assumption that the EST and LET of the start process of a TS workflow are zero,
the methodologies made by Li et al. (2004b) and Hsu and Wang (2008) can be adopted to
calculate the EAIs of processes in an LRTS workflow as Figure 9 illustrates.
With Lemma 1 and Lemma 2, whether two processes in an LRTS workflow are
exclusive, parallel, or reachable from one to the other is identified with corresponding
ABStacks. The path direction of two reachable processes can be further derived according to
the corresponding EAIs, and the following lemmas show how EAIs can be adopted in
analysis of LRTS workflow.
Lemma 3
For an LRTS workflow w, p and qPw, q.type == ACT,
if Reachable(p, q), LET(p) < LET(q)
Proof:
Reachable(p, q) represents that the path <p, m1, m2, …, mn, q> exists. Now we prove the
lemma with mathematical induction. For n = 0, (p, q)Fw, since q.type = ACT, D(q) > 0 and
LET(q) = LET(p) + D(q). LET(p) < LET(q) holds.
Hypothesis: The lemma holds when n < k.
For n = k, LET(q) = LET(mk) + D(q) and LET(mk) < LET(q). According to the
construction rule of TS workflow, mk.type≠ S, E, and mk.type{AS, XS, AJ, XJ, ACT}. The
following conditions should be discussed:
For any 1ik, if there exists an mi where mi.type = ACT, according to the hypothesis,
LET(p) < LET(mi) and LET(mi) < LET(q). Therefore, LET(p) < LET(q). Otherwise, for any
1ik, mi.type{AS, XS, AJ, XJ}, according to the EAI calculation methods, for any (u, mi)
Fw, LET(u)LET(mi). Since there exists a path from p to mi, LET(p)LET(mi). On the
other hand, according to the hypothesis, LET(mi) < LET(q). Therefore, LET(p) < LET(q).
With statements above, we know the lemma holds for n = k, and on the basis of mathematical
induction, Lemma 3is proved. □
Lemma 4
For an LRTS workflow w, p and qPw, p.type == q.type == ACT,
if Parrallel(p, q) == Exclusive(p, q) == false, and LET(p) < LET(q),
Reachable(p, q) == true.
Lemma 4 can be shown correct with Lemma 1 and the construction rule of LRTS
workflow. Lemma 4 describes that if two activity processes in an LRTS workflow are not
mutually parallel or exclusive, the process with larger LET is reachable from the process with
smaller LET. From Lemma 1, we know that in an LRTS workflow, two processes are either
17
3. Artifact Anomalies in TS workflow
3.1 Artifact Operations
In this project, we assume that an activity process in a TS workflow may operate an
artifact as one of the following ways: define (Def), use (Use) and kill (Kill). Defining an artifact
is to assign a value to the artifact, and when an artifact is first defined, it is initialized. An
activity process references an artifact through using it, and an artifact can not be used without
definition. Killing an artifact is to remove the definition of the artifact, and using a killed
artifact before it is defined again leads to errors during execution. As for the control processes
in a TS workflow, it is assumed that they all do no operation (Nop) on any artifacts.
An artifact in a TS workflow is initially stated undefined (UD), and turns to
defined&no-use (DN) after it is defined. When a DN artifact is used, its state becomes
defined&referenced (DR). A DR artifact remains DR after being used, and transits to DN after
being defined again. An artifact in any states becomes UD after being killed.
On the other hand, the artifact operations made by concurrent processes are executed with
undetermined order and might generate ambiguity to artifacts. When several concurrent
processes operate on the same artifact, they race against each other for accessing the artifact and
anomalies might thus be generated. For example, let one process make a definition to an artifact,
and another one kills the artifact concurrently. The existence of the definition of the artifact
becomes ambiguous because the execution order between the kill and the definition is not
determined during design-time. These operations, called Racing Operations, require additional
consideration during analysis, and are categorized according to the operations involved as
following:
(1) Racing Definition(s)&Kill(s), abbreviated as RDK, represents a racing operation
composed of both definition(s) and kill(s) with none or any usage(s).
(2) Racing Definitions, abbreviated as RDS, represents a racing operation composed of
multiple definitions and no kills with none or any usage(s).
(3) Racing Kills, abbreviated as RKS, represents a racing operation composed of no
definitions and multiple kills with none or any usage(s).
(4) Racing Definition&Usage(s), abbreviated as RDU, represents a racing operation
composed of a single definition, any usage(s) and no kills.
(5) Racing Usage(s)&Kill, abbreviated as RUK, represents a racing operation composed of no
definitions, any usage(s), and a single kill.
(6) Racing Usages, abbreviated as RUS, represents a racing operation composed of multiple
19
Killing or defining a DN artifact makes the previous definition useless because the
definition is destroyed (or redefined) without any usage. If an artifact remains DN at the end
process, its definition is also useless because it is not used before the end of the workflow. A
useless definition is a kind of redundancy indicating there might be logic error in the workflow
schema and should be warned to designers.
(2) Undefined Usage:
An activity process might not be correctly executed if the essential artifact is not properly
defined. Therefore, an undefined usage, i.e. using an UD artifact, is an error leading to faulty
execution, and is necessary to be handled by the workflow designers.
(3) Null Kill:
A null kill represents a process try to remove an inexistent definition; e.g. to kill a UD
artifact. A null kill is a kind of redundancy, and designers should be noticed about it.
(4) Ambiguous Usage:
An ambiguous usage means that an activity process uses an artifact which is ambiguous in
definitions or in states. Therefore, the direct usage of an AB artifact is an ambiguous usage. The
usage(s) involved in an RDS, an RDK, or an RDU are also ambiguous usages. Besides, if an
artifact is stated DR/DN before an RKU, the usage(s) involved in the RKU is also ambiguous.
Similarly, when an UD artifact meets an RDU, the definition in the RDU may not be made in
time for the usages, and the usage(s) involved in the RDU is also ambiguous.
21
04: loop {
05: Process p = tq.dequeue();
06: if( (p.type{AJ, XJ}) && ((p’, p)Fw,p’.mark == false) ) continue;
07: p.mark = true;
08: calculate EAI(p);
09: calculate p.abstack;
10: if( p.type == ACT )
11: aAw, AOP(p, a) ≠ Nop,
12: add (p, a, EST(p), LET(p), AOP(p, a)) to AOPLa;
13: else if( p.type == END ) {
14: aAw, add (p, a, EST(p), LET(p), AOP(p, a)) to AOPLa;
15: break;
16: }
17: (p,p’)Fw, tq.enqueue(p’);
18: }
19: aAw, Sorting AOPLa by LET
}
In Algorithm 1, a traverse queue is introduced to hold the order of traversal of processes in
an LRTS workflow. Starting from the start process, the processes in a TS workflow is traversed
along with flows. The EAIs, ABStacks, and artifact operations lists are calculated and collected
correspondingly. To prevent unnecessary redundancy, a Boolean flag mark is given to each
process. Besides the start process, the mark of each process in w is initialized as false, and when
a process is calculated, its mark turned to true. Since a join process may have several in-flows, a
Boolean expression is checked at line 6 to assure that the join process is calculated only when
each of its source process is calculated. Algorithm 1 records the artifact operation made by each
activity process at line 12 and the“no operation”made by the end process in AOPLa at line 14
for further analysis of the definitions remaining useless at the end of w. At line 19, artifact
operation list corresponding to each artifact is sorted by LET.
4.2 Collecting Structural and Temporal Relationships between Artifact Operations in LRTS
workflow
Artifact operations are made by activity processes. Based on the structural and temporal
relationships between the processes, the operations effective on the same artifact can be before,
after, concurrent, or exclusive to each other. To identify these relationships between artifact
operations is the foundation of analysis of artifact anomalies. Here, we first define the structural
and temporal relationships between artifact operations as following:
23
05: if ( Concurrent(opi.p, opj.p) ){
06: if( opi.type == Def ) add opi to ConcD_opj;
07: else if( opi.type == Kill ) add opi to ConcK_opj;
08: if( opj.type == Def ) add opj to ConcD_opi;
09: else if( opj.type == Kill ) add opj to ConcK_opi;
10: }
11: j++;
12: }
13: }
14: }
}
Because AOPLa is sorted by LETs in Algorithm 1, Algorithm 2 checks each operation in
AOPLa in order. For any opiAOPLa, Algorithm 2 first checks if it resides in some parallel or
decision structure(s) at line 2. If not, opi can not be concurrent or exclusive to any other
operations. From line 3 to line 14, the algorithm checks the operations which are succeeding to
opi in AOPLa in order. If the operation under checking is concurrent to opi, the records for both
operations are updated.
For an artifact operation, the operations directly before it generate/carry its input artifact
state, and might make it an artifact anomaly. For example, when a kill directly before a usage,
i.e. no other operations between them, the usage is an undefined usage. We define the
relationship directly before between artifact operations on the basis of Definition 12 as
following:
Definition 14 (Directly Before)
For an LRTS workflow w and aAw,
op, op’AOPLa, op is directly before op’if and only if op is before op’, and 
noop”AOPLa thatop”is after op and before op’.
opAOPLa, DB4op = { op’| op’AOPLa and op’is directly before op}
According to Definition 9, Definition 12, and Lemma 5, for any two artifact operations
effective on artifact a, op andop’, ifop’is before op,op’.let < op.let. Therefore, the operations
directly before op can be identified by analyzing the sub-list of AOPLa where the operations in
the sub-list are all with smaller index in AOPLa than op. The sub-list is defined as following:
Definition 15 (The List of Operations with Smaller LET than Operation op)
opAOPLa,
OPLop = {op’| op’AOPLa , and op’.let < op.let}
Similar to AOPLa, OPLop is sorted and indexed with LETs
25
before op. Because op’CDBO(op), op’must be collected in the result set at line 4 or line 6
in Algorithm 3. Since op”is after op’, op’.let < op”.let. op”has a larger index than op’in
OPLop, and is touched by Algorithm 3 earlier than op’does. Therefore, either op”is directly
before op or not, op’can not be collected in the result set at line 4 or line 6. op’CDBO(op)
which is a contradiction, and the if-part of Lemma 7 is shown correct.
As for the only-if-part, B.W.O.C, we assume that op’is directly before op and
op’CDBO(op). The assumption indicates that op’is before op. According to Lemma 6,
op’.let < op.let, and thus op’belongs to OPLop. op’also passes the checking at line 3 based on
Lemma 4 and Definition 12. If the result set is empty when Algorithm 3 touches op’, op’is
inserted into the result set at line 4 because op’is before op. Otherwise, op’is added into the
result set at line 6 because op’is directly before op and there exist no other operations after
op’in OPLop. Therefore, op’CDBO(op) which is a contradiction, and the only-if-part of
Lemma 7 is shown correct. With the proofs of the both direction, Lemma 7 is proved.□
For an artifact operation op, multiple operations directly before it might exist. According
to Definition 14, the operations are not before or after each other. On the basis of Lemma 1 and
Definition 9, the operations are mutually concurrent or exclusive, and are possibly organized as
the following cases:
(1) All the operations are concurrent to each other.
(2) All the operations are exclusive to each other.
(3) The operations can be divided into several distinct groups where the operations in the
same group are concurrent to each other, and the operations belonging to different
groups are all mutually exclusive.
(4) The operations can be organized into several varied groups where the operations in the
same group are concurrent to each other, and the operations belonging to different
groups are either identical or mutually exclusive.
The operations in case (1) compose a racing operation. In case (2), each operation is
considered separately during analysis because only one of the operations is executed during
run-time. Case (3) and (4) happen when the operations are made by processes reside in nestedly
organized decision and parallel structures. Since only one of the branches in a decision structure
is taken during run-time, the operations reside in different branches of a decision structure are
separately analyzed with the operations concurrent to them. Figure 11 illustrates two partial
LRTS workflow schemas as the examples of case (3) and (4).
27
Algorithm 4 Collecting Directly Before Operation Sets - CDBOPS
Input: an operation op,
Pre-Condition: DB4op has been calculated by Algorithm 3
Set of Operation Sets CDBOPS {
01: DB4OPSop = Ø;
02: duplicate DB4op to BaseSet;
03:while( BaseSet ≠ Ø) {
04: CurrentOPS = Ø;
05: choose and remove arbitrary operationop’from BaseSet;
06: duplicate DB4op \{op’} to CountSet;
07: addop’to CurrentOPS;
08: while( CountSet ≠ Ø) {
09: choose and remove arbitraryop”from CountSet;
10: if( op3CurrentOPS, Concurrent(op”, op3) == true ) {
11: addop”to CurrentOPS;
12: removeop”from BaseSet;
13: }
14: }
15: add CurrentOPS to ResultSet;
16: }
17: return DB4OPSop;
}
First, the algorithm duplicates DB4op to BaseSet at line 2. The codes from line 3 to 16 form
a loop. In the loop, an operation op’is arbitrarily chosen from BaseSet, and all the operations
concurrent to op’and each other are gathered and put into CurrentOPS. CurrentOPS is added to
the result set as one of the operation sets found by the algorithm at the end of the loop. The
operations in CurrentOPS are removed from BaseSet, and the next loop starts if there is still
operation remaining in BaseSet. Because any operations in DB4op are mutually concurrent or
exclusive, the operation chosen in the next loop is exclusive to at least one of the operations
gathered in this loop. Besides, the algorithm starts collecting an operation sets from different
operations every loop, and thus none of the operation sets collected in Algorithm 4 are identical.
After each operation in BaseSet is distributed into some operation set, the algorithm returns the
calculated DB4OPSop at line 17.
To depict the correctness and the effectiveness of Algorithm 4, we show that the following
lemmas hold.
Lemma 8
The result set returned by Algorithm 4 follows Definition 16.
29
starting from line 3, and therefore the algorithm derives at most N operation sets
from DB4op. For case (4), the number of operation sets identified by Algorithm 4 is
less than N, but the number of operation sets in this case might exceed N. The
operation sets in case (4) follow Definition 16, and so is Algorithm 4. Since the
number of operation sets in case (4) might exceed the maximal capability of
Algorithm 4. Obviously, Algorithm 4 identifies the operation sets for case (4) only
partially.□
4.3 Detecting Blank Branch
Besides the cases described above, analysis of blank branches, i.e. the branches in a
decision structure where no process residing in the branch has operations effective on the same
artifact, is still ignored. Figure 12 illustrates parts of an LRTS workflow that the definitions
made by v1 and v2 are directly before the usage made by v4. The definitions should be
considered separately during analysis because they are exclusively executed during run-time.
However, if the third branch is taken during execution, the usage made by v4 is undefined
because the definition of a is killed by v0, and no further definition is made by activity processes
on the third branch. The third branch is a blank branch which generates a blind spot in our
methodology.
Figure 12 An Example of a Blank Branch
For any operation op, to eliminate the effect brought by blank branches when calculating
its input states, all the operations reside in the decision structure with blank branches should be
removed from OPLop, and DB4op can then be recalculated for analysis. Algorithm 5 detects
blank branches from the directly before operations of the input operation.
Algorithm 5 Detecting Blank Branch - DBB
Input: an operation op,
Pre-Condition: DB4op has been calculated by Algorithm 3
Branch Set DBB {
01: XSSet = Ø;
02: AllBranch = Ø;
03: OpBranch = Ø;
04: op’DB4op {
05: si(op’.p.abstack\op.p.abstack ) where si.p.type == XS {
31
Definition 17 (Records of Artifact States)
state item stItem, stItem = (st, SRC),
stItem.st represents the output artifact state of op.a, and
stItem.SRC indicates the source operations producing the state.
With the definition above, Algorithm 6 describes the methodology to calculate the input
state for each operation.
Algorithm 6 Gathering Input States of an Operation - GIS
Input: an LRTS workflow w,
an operation op
Pre-Condition: DB4OPSop has been calculated by Algorithm 4
Set of State Items GIS {
01: InStates = Ø;
02: if( DB4OPSop == Ø )
03: add ( UD, {w.s}} ) to InStates;
04: else OPSDB4OPSop {
05: if( OPS is an RDS/RDK )
06: add ( AB, {op’|op’OPS, op.type{Def, Kill}} ) to InStates;
07: else if ( OPS is an RDU )
08: add ( DR, {op’|op’OPS, op.type == Def} ) to InStates;
09: else if ( OPS is an RKS/RKU )
10: add ( UD, {op’|op’OPS, op.type == Kill} ) to InStates;
11: else if ( OPS is an RUS ) {
12: if (op’OPS, siop’.OutState that si.st == UD) {
13: UDSRC = Ø;
14: op’OPS and siop’.OutState,
15: if( si.st == UD ) UDSRC = UDSRCsi.SRC;
16: add( UD, UDSRC ) to InStates;
17: }
18: if( op’OPS and siop’.OutState that si.st(AB, DR) ) {
19: ABSRC = Ø;
20: DRSRC = Ø;
21: op’OPS and siop’.OutState {
22: if( si.st == AB ) ABSRC = ABSRCsi.SRC;
23: else if( si.st == DR ) DRSRC = DRSRCsi.SRC;
24: }
25: if ( ABSRC ≠ Ø) add( AB, ABSRC ) to InStates;
26: if ( DRSRC ≠ Ø) add( DR, DRSRC ) to InStates;
33
of the output states for operations with different types.
Algorithm 7 Identifying Artifact Anomalies for No Operations - IAAN
Input: an LRTS workflow w,
an artifact operation op, and
a set of state items InState
Pre-Condition: op.type == Nop
IAAN {
01: stItemInState,
02: if( stItem.state == DN )
03: add(op’ |op’stItem.SRC, Useless Definition, {op} ) to AATw;
04: op.OutState = InState;
}
For an artifact a, the no operation made by the end process is recorded in AOPLa to detect
if any useless definition exists at the end of the LRTS workflow. Since only a definition transits
an artifact to state DN, the algorithm records the operations generating DN state directly before
the end of the LRTS workflow as useless definitions.
Algorithm 8 Identifying Artifact Anomalies for Definitions - IAAD
Input: an LRTS workflow w,
an artifact operation op, and
a set of state items InState
Pre-Condition: op.type == Def
IAAD {
01: stItemInState,
02: if( stItem.state == DN )
03: add(op’ |op’stItem.SRC, Useless Definition, {op} ) to AATw;
04: op.OutState = { ( DN, {op} ) };
}
Algorithm 8 identifies the artifact anomalies generated from a definition, and calculate its
output state. For an artifact a, a definition which is not referenced by any usages before being
defined again is a useless definition. Finally, a definition transits a to state DN, and the output
state generated by the definition is recorded accordingly.
Algorithm 9 Identifying Artifact Anomalies for Kills - IAAK
Input: an LRTS workflow w,
an artifact operation op, and
a set of state items InState
Pre-Condition: op.type == Kill
35
operated, and makes the usage an ambiguous usage. If the input state of the usage is UD, the
algorithm checks if there is any definition concurrent to the usage from at line 6. If no
concurrent definition exists, the usage is undefined. Otherwise, the usage is ambiguous because
it may reference an undefined artifact or the value defined by the concurrent definition(s). If the
input state of the usage is DN or DR, the concurrent definitions or kills which cause ambiguity
to the usage are checked at line 11, and an Ambiguous Usage is raised if any ambiguity exists.
The usage transits a DN artifact to state DR or simply propagates the input states to the
following operations otherwise.
The expressions adopted in Algorithm 7 to Algorithm 10 are stated based on the
description in section 4.1. With all the definitions and algorithms described in this chapter, the
methodology detecting artifact anomalies in a TS workflow is introduced as following.
Algorithm 11 Identifying Artifact Anomalies - IAA
Input: an LRTS workflow w
IAA {
01: IG( w );
02: aAw {
03: ICO( a );
04: for( i = 1 to |AOPLa| ) {
05: while( true ) {
06: CDBO( opi );
07: CDBOPS( opi );
08: InState = GIS( w, opi );
09: if( opi.type == Nop ) IAAN( opi, InState, w );
10: else if ( opi.type == Def ) IAAD( opi, InState, w );
11: else if ( opi.type == Kill ) IAAK( opi, InState, w );
12: else if ( opi.type == Use ) IAAU( opi, InState, w );
13: BlankBranch = DBB( opi );
14: if( BlankBranch == Ø ) break
15: else
16: opOPLopi,
17: if( siBlankBranch, and si’op.p.abstack, where si.sp == si’.sp )
18: remove op from OPLopi;
19: }
20: }
21: }
}
At line 1, the algorithm first invokes Algorithm 1 to collect structural and temporal
37
5. Case Study
In this section, a case study is made to illustrate the feasibility of our methodology.
Figure 13 The Sample TS Workflow for the Case Study in Chapter 4
Figure 13 shows the sample TS workflow for our case study. The processes, flows,
working durations, and the artifact operations made on artifact a are illustrated in the sample.
To analyze the sample TS workflow with our methodology, the structured loops in the TS
workflow should first be reduced. After loop reduction, the LRTS workflow generated from the
sample TS workflow are illustrated as Figure 14.
Figure 14 The Sample LRTS Workflow Derived from Figure 13 with Decoration of EAIs and ABStacks
39
definition concurrent to them. Before op9 is calculated, the artifact anomaly table, AATw,
records the following anomalies:
AATw = { ( op1, Undefined Usage, {s} ), ( op3, Ambiguous Usage, {s, op2} ), ( op4,
Ambiguous Usage, {s, op2} ), ( op6, Ambiguous Usage, {s, op2, op7} ), ( op7,
Ambiguous Usage, {s, op2, op7} ) }
For op9, Algorithm 11 retrieve all the operations with smaller LET from AOPLa as OPLop9,
{op1, op2, op3, op4, op5, op6, op7, op8}, and invokes Algorithm 3 to calculate DB4op9, {op5, op7}.
Since all the operations directly before op9 are mutually exclusive, i.e. the case (2) described in
section 4, the DB4OPSop9 is calculated from Algorithm 4 as { {op5}, {op7} }. With DB4OPSop9,
Algorithm 6 gathers the input states of op9 as the union of the output states of op5 and op7 as
{ (DR, {op2}), (UD, {op7}) }. op9 is a definition, and Algorithm 8 is invoked for detection of
artifact anomalies and generation of its output state. As a result, no artifact anomaly is found
and the output state of op9 is generated as { (DN, {op9}) }. However, during the blank branch
detection, (xs1, 2) is found a blank branch, and the operation in the same decision structure
should be removed to eliminate the effect of blank branch. op5 and op7 is removed from OPLop9.
DB4op9, DB4OPSop9, and the InState of op9 are recalculated as {op2}, {{op2}}, and { (DN,
{op2}) }. After invoking Algorithm 8 once again, an artifact anomaly (op2, Useless Definition,
{op9}) is raised because the definition made by op2 is not used before redefinition when the
blank branch is taken.
DB4op10 is generated as {op3, op5, op7, op8}, and DB4OPSop10 is generated as { {op3, op5},
{op7, op8} }. Since this case is relatively simple, we can easily identify that the operation sets
{op3, op7} and {op5, op8} is neglected in our methodology. With DB4OPSop10, the input states
of op10 are generated. According to the definition of racing operations introduced in section 3.1,
{op3, op5} is an RUS and {op7, op8} is an RKU, and { (DR, {op2}) } and { (UD, {op7}) } are
generated as op10’s input statescorrespondingly. Algorithm 10 is invoked to detect artifact
anomalies and identify the output state of op10. Two artifact anomalies, (op10, Ambiguous
Usage, {op7, op9}) and (op10, Ambiguous Usage, {op2, op9}), are generated because op9 makes
a definition to a concurrently, and generates ambiguity to op10. The output states of op10 is
{ (DR, {op2}), (UD, {op7}) }. Then the algorithm removes the blank branches for op10, and
finds no further anomalies.
Except for the artifact anomalies listed and described above, (op13, Useless Definition, {e})
are detected and recorded to AATw when Algorithm 11 completes its work throughout w. The
useless definition is detected at the end process of the LRTS workflow because the definition
made by op13 is not used by any other activity process until the end of w.
41
Wang et al. (2009) develop a systematic notation to describe artifact anomalies and
simplify the description of artifact anomalies from the classification made by Hsu et al. (2007)
into three categories, Missing Production, Redundant Write, and Conflict Write. Missing
Production occurs when an artifact is consumed before it is produced or after it is destroyed.
Redundant Write occurs when an artifact is written by an activity but the artifact is neither
required by the succeeding activities nor a member of the process outputs. Conflict Write
occurs when parallel processes race their access to the same artifact. According to different
structural relationships between activities accessing some artifacts, thirteen abnormal usage
patterns are described for the three categories to follow the previous models made by Sadiq et
al.(2004), Hsu et al (2007), and Sun et al. (2006).
6.2 Comparison between Our Approach and the Related Works
Table 3 lists and compares the features between the related works and our approach.
Artifact anomalies are appealed with different names in previous studies, but can still be
mapped into the three basic categories made by Sun et al. (2006). By comparing the definition
of the artifact anomalies defined in our approach and the related works, we conclude that
Undefined Usage and Useless Definition can be directly mapped into Missing Data and
Redundant Data descri intrduced by Sun et al. (2006). On the other hand, the Conflict Data
defined by Sun et al. (2006) are anomalies generated when multiple definitions are made in
parallel. In our approach, the concurrent definitions are considered being executed with
undetermined order, and generate ambiguity in artifacts. They are not directly considered as an
anomaly because (1) an anomaly actually occurs when a usage refers to the ambiguous
definitions, and (2) similar anomaly may also occur when there exist kills or definitions
concurrent to usages. Therefore, Ambiguous Usage is categorized in this project, and covers
Conflict Data discussed in the previous works. Besides, Sadiq et al. additionally define
Insufficient Data and Mismatched Data in (Sadiq et al., 2004) for conflicts about contents or
format between definitions and usages. Since the studies made by Hsu et al. (2007), Wang et
al, (2009), Sun et al. (2006) and this project do not discuss the contents of artifacts,
Insufficient Data and Mismatched Data are ignored in these studies. Finally, although
destruction of artifacts is considered in Hsu et al. (2007), Wang et al, (2009)’s studies, the
redundancy generated by unnecessary destruction is not discussed in these works. In our studies,
Null Kill is categorized and detected to eliminate such redundancies.
Our approach also considers how temporal factors may affect the detection of artifact
anomalies. The twisted temporal and structural relationships between activity processes are
modeled and analyzed, and the artifact anomalies generated along with them are detected.
Besides, when the previous works only focus on detection of artifact anomalies, our approach
also helps designers locating the problems hidden in a workflow schema with providing the
information about the sources leading to artifact anomalies.
43
7. Conclusion and Future Works
In this project, the temporal factors in structured workflows are considered with TS
workflow. The twisted temporal and structural relationships between processes in TS workflow
are modeled, and the methodologies to analyze such relationships in TS workflow are presented.
Three classes of artifact operations, Define, Use, and Kill, are discussed, and four kinds of
artifact anomalies, Useless Definition, Undefined Usage, Ambiguous Usage, and Null Kill, are
defined. The racing operations composed by concurrent operations are categorized into seven
classes, the how artifact operations may affect the state transition of an artifact is depicted. With
all the features modeled above, the methodology to detect artifact anomalies in a TS workflow
is established. A case study and comparison between our approach and the related works are
made to show the feasibility and contribution of our work.
Several advanced studies can still be made in this topic. First, a solution to group the
operation sets from the operations directly before another operation can be further studied. The
efficiency and completeness of the solution should be discussed. Second, the methodology
described in this project traverses the whole workflow schema to detect artifact anomalies. In
the future, on the basis of this work, we might construct an incremental algorithm to detect
artifact anomalies generated or eliminated by each design operations made by the designers.
The algorithm analyzes only partial workflow schema which is changed in last design operation
and informs the designers immediately after a design operation is made. Finally, the artifact
operations can be discussed in finer-grained, we may not only summarize the actions which an
activity process made on an artifact into one single artifact operation, but consider all the
operations made by activity processes and discuss the dependency between the operations in
more detail.
45
Concurrent Workflows, Electronic Commerce Research and Applications Vol. 4, pp.
124-142
(Makino and Uno, 2004) K. Makino, and T. Uno, 2004, New Algorithms for Enumerating All
Maximal Cliques, the Proceedings of 9th Scandinavian Workshop on Algorithm Theory,
Lecture Notes in Computer Science, Vol. 3111, pp. 260-272
(Marjanovic, 2000) O. Marjanovic, 2000, Dynamic Verification of Temporal Constraints in
Production Workflows, the Proceedings of the 11th Australian Database Conference, pp.
74-81
(Pardalos and Xue, 1994) P. M. Pardalos, and J. Xue, 1994, The Maximum Clique Problem,
Journal of Global Optimization, Vol. 4, No. 3, pp. 301-328
(Sadiq et al., 2004) S. Sadiq, M. E. Orlowska, W. Sadiq, and C. Foulger, 2004, Data flow and
validation in workflow modeling, the Proceedings of the 15th Conference on Australasian
Database, Vol. 27, pp. 207-214
(Sun et al., 2006) Formulating the data flow perspective for business process management,
Information Systems Research, Vol. 17, Issue 4, pp. 374-391
(Tsukiyama et al., 1977) (Makino and Uno, 2004)S. Tsukiyama, M. Ide, H. Ariyoshi and I.
Shirakawa, 1977, A new algorithm for generating all the maximal independent sets, Society
for Industrial and Applied Mathematics (SIAM) Journal on Computing, Vol. 6, pp. 505–517
(van der Aalst and ter Hofstede, 2000) W. M. P. van der Aalst, and A. H. M. ter Hofstede,
2000, Verification of Workflow Task Structures: A Petri-net Approach, Information System,
Vol. 25, Issue 1, pp. 43-69
(van der Aalst et al., 1999) W. M. P. van der Aalst, K.M. van Hee, and R.A. van der Toorn,
1999, Adaptive Workflow: An Approach Based on Inheritance, the Proceedings of the
Workshop on Intelligent Workflow and Process Management: The New Frontier for AI in
Business, pp. 36-45
(Wang et al., 2006) F.-J. Wang, C.-L. Hsu, and H.-J. Hsu, 2006, Analyzing Inaccurate Artifact
Usages in a Workflow Schema, the Proceedings of the 30th Annual International Computer
Software and Application Conference, Vol. 2, pp. 109-114
(Wang et al., 2009) C.-H. Wang, and F.-J. Wang, 2009, Detecting Artifact Anomalies in
Business Process Specification with a Formal Model, Journal of Systems and Software, Vol.
82, Issue 10, pp. 1064-1212
(WfMC, 1999) Workflow Management Coalition (WfMC), 1999, WFMC-TC-1011 Ver 3
Terminology and Glossary English, Workflow Management Coalition
(Zhuge et al., 2001) H. Zhuge, T.-Y. Cheung, and H.-K. Pung, 2001, A Timed Workflow
Process Model, Journal of Systems and Software, Vol. 55, Issue 2, pp. 231-243
國科會補助計畫衍生研發成果推廣資料表
日期:2012/08/20
國科會補助計畫
計畫名稱: 一商業流程規格中Artifacts異常使用偵測之研究
計畫主持人: 王豐堅
計畫編號: 98-2221-E-009-081-MY3 學門領域: 程式語言與軟體工程
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
