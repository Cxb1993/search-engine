2 
 
中文摘要 
 
我們針對多面體三維模型提出三個演算法，分別是高藏量的資訊隱藏演算法、
可適應性(adaptive)的資訊隱藏方法、與無變形量的資訊隱藏演算法。這些方法都
屬於空間域，具有替代性、盲擷取性的特性。前兩個演算法在資訊嵌入時，偽裝
模型會有少許的變形，後一個演算法則不產生任何變形。前兩個演算法是計算三
維頂點所構成表面之特徵，對秘密訊息作可高藏量、適應性、無變形量的嵌入。
這兩個演算法都利用人類視覺系統在相鄰多面體所顯現的平滑表面(smooth 
surface)與崎嶇表面(rough surface)視覺敏銳性相異之特性。我們估計相鄰兩多面
體之表面之特性：如果多面體之某一頂點位於崎嶇表面(rough surface)，則我們
允許嵌入更多量的秘密訊息，使乃源於人類視覺系統在崎嶇表面較無法辨別大量
訊息嵌入時所引起之多幅度模型變形量之故。相反的，如果多面體之某一頂點位
於平滑表面(smooth surface)，則我們僅允許嵌入少量的秘密訊息，雖然人類視覺
系統對平滑表面變異量具有敏銳之認知，但由於我們僅嵌入少量之秘密訊息，故
人類視覺系統仍無法辨識模型存在些許之變形量。實驗結果顯示：我們的方法極
具高藏量、可適應性、簡單性，有效性、一般性、與安全性。我們的方法可以嵌
入大量的秘密訊息，但仍能維持極低的模型變形量。該法可以抵抗旋轉、平移、
縮放等攻擊，且證明適用於三維模型之資訊偽裝領域。 
無變形量資料偽裝演算法則是將秘密訊息藏在媒體的結構空間(the structure 
domain)。由於訊息是藏在結構空間中，因此隱密媒體中的數值並沒有被更改，
所以當我們使用標準的媒體播放器開啟偽裝媒體時，所得到的結果會跟直接開啟
掩護媒體一樣，這也代表著，兩者之間並沒有變形的存在。最常見的無變形量資
料偽裝技術是排序演算法(permutation scheme)。在排序演算法中，訊息是被藏在
元素的順序中。如果在檔案結構中，元素的順序與最終的結果並不相依，我們就
4 
 
technique has high capacity and low distortion, and it is robust against affine 
transformations. Our technique provides an adaptive method and has proven feasible 
in steganography. 
Unlike traditional steganography, distortion free steganography hides the 
message in the structure domain of the medium. No distortion between the cover and 
the stego medium is perceived when viewing by a standard viewer. Since the message 
is hidden in the structure domain of the media, different media exploit various 
techniques for distortion free steganography. The most common technique is the 
permutation scheme, which works on data structures with the condition that the order 
of the element is independent to the final result, such as the 3D polygonal mesh file. 
The third algorithm we propose in this research project is the distortion free 
steganographic technique. In particular, we employ the permutation scheme to 
achieve distortion free data embedding. Our technique is an advance technique of 
Bogomjakov et al.’s algorithm. By changing the encoding part, our technique 
achieves higher capacity that is closer to the optimal capacity but with the same time 
complexity. 
 
Keywords 3D polygonal models, Human visual system, Steganography, distortion 
free steganography 
 
 
 
 
 
Visual Comput (2006)
DOI 10.1007/s00371-006-0069-4 O R I G I N A L A R T I C L E
Yu-Ming Cheng
Chung-Ming Wang
A high-capacity steganographic approach for
3D polygonal meshes
© Springer-Verlag 2006
Y.-M. Cheng · C.-M. Wang ()
Institute of Computer Science, National
Chung Hsing University, Taichung, Taiwan
ssmtt.cym@msa.hinet.net,
cmwang@cs.nchu.edu.tw
Abstract We present a high-capacity
steganographic approach for three-
dimensional (3D) polygonal meshes.
We first use the representation in-
formation of a 3D model to embed
messages. Our approach successfully
combines both the spatial domain
and the representation domain for
steganography. In the spatial domain,
every vertex of a 3D polygonal mesh
can be represented by at least three
bits using a modified multi-level
embed procedure (MMLEP). In the
representation domain, the represen-
tation order of vertices and polygons
and even the topology information
of polygons can be represented with
an average of six bits per vertex
using the proposed representation
rearrangement procedure (RRP).
Experimental results show that the
proposed technique is efficient and
secure, has high capacity and low
distortion, and is robust against
affine transformations. Our technique
is a feasible alternative to other
steganographic approaches.
Keywords Steganography · Spatial
domain · Representation domain
1 Introduction
Steganography, or data hiding, is the art of communicat-
ing in a way that hides the existence of the communica-
tion. Compared with watermarking, which is a process for
protecting copyright ownership, steganography is a tech-
nique that conceals messages inside other harmless media
in a way that does not allow any enemy to even detect
that there is a second secret message present. Steganog-
raphy algorithms tend to require security, high capacity,
and low distortion, but they can lead to relatively poor ro-
bustness [6, 12, 22, 26]. Performance is also an important
trade-off attribute, especially when trying to recover hid-
den messages [15].
In computer-based steganography, images, audio files,
documents, and even three-dimensional (3D) models may
all serve as innocuous-looking hosts for secret messages.
With the development of various 3D applications and
computer animation, many steganography and watermark-
ing schemes have been presented for 3D models. Unfortu-
nately, most of the steganographic methods provide poor
capacity. Because of the natural differences between 3D
polygonal models and traditional cover media, such as 2D
images, traditional schemes of steganography are not very
well suited to 3D polygon files. Finding a way to fully ex-
ploit the features of 3D polygonal models is an important
research issue.
This paper presents a high-capacity steganographic ap-
proach for 3D polygonal meshes, inspired by the concepts
proposed by [21, 26]. We first use a modified multi-level
embed procedure (MMLEP) that can embed at least three
bits per vertex with little visual distortion. Furthermore,
we propose a new representation rearrangement procedure
(RRP) based on the representation domain to achieve the
higher capacity with no visual distortion. To the best of
our knowledge, this is the first 3D polygon model stegano-
graphic approach that can use the representation infor-
A high-capacity steganographic approach for 3D polygonal meshes
on both the traversal order and the representation order of
vertices. Similarly, we extend the same basic idea to poly-
gons and embed one bit in every polygon representation,
except the last polygon. Finally, we combine two triangles
as one message set, and embed three bits in every mes-
sage set by modifying the topology information of both
triangles. This procedure efficiently increases the capacity
from three fixed bits to around nine bits per vertex depend-
ing on the number of vertices and polygons of a model, a
200% increase in capacity over [26]. Our scheme is sim-
ple and can achieve high capacity with little or no visual
distortion.
3 The proposed approach
This section describes the proposed approach for stegano-
graphy for 3D polygonal meshes. Our approach consists
of two separate procedures: an embedding procedure and
an extraction procedure (see Fig. 2).
The embedding process proceeds as follows. In a pre-
processing step, the initial triangle and the initial vertex
for embedding are resolved by PCA [24]. The traversal
list of triangles and vertices in the cover model that will
contain the message are established, starting from the ini-
tial triangle and the initial vertex respectively, depending
on a secret key. First, every triangle of the traversal list is
modified or not according to the binary symbol it has to
convey. Then, the representation order of every vertex and
triangle of the traversal lists is also rearranged according
Fig. 2. An overview of the proposed approach
to the binary symbol it has to convey. Next, the topology
information of every message set, which is combined by
two triangles, is modified or not according to the binary
symbol it has to convey. Finally, the resulting stego model
is obtained after the embedding step. During extraction,
the following steps are performed. The embedded model
is analyzed using the PCA technique in the preprocess-
ing step. Then, the traversal list of triangles and vertices
in the stego model is established. Finally, the message is
extracted using a MMLEP and RRP.
3.1 Information embedding
The embedding procedure of our steganographic system
proceeds in multiple steps as described in the next subsec-
tions.
Preprocessing. Principal component analysis (PCA) de-
termines the initial polygon and the initial vertex; it gives
three principal axes centered on the centroid of the model,
whose intersections with the mesh lead to a small num-
ber of possible initial polygons. In addition, we let the
first vertex of the largest edge of the initial triangle be
the initial vertex. The next vertex of the list is in counter-
clockwise order of the initial triangle, and so on.
Traversal List. To embed information, we must first
choose the traversal list of the triangles and their vertices.
Here, we use a hierarchical kd-tree, triangle neighbor
table, and advanced jump strategy to efficiently select the
next triangles in the list depending on the bit value of
the binary pseudo-noise sequence generator [26]. If the
bit value is “0”, then the next triangle is the first one of
the initial triangle in counter-clockwise order; otherwise,
the next triangle is the second one in counter-clockwise
order. Furthermore, the next vertices in the list are se-
lected depending on the list of triangles. Since the next
triangle has at most one untraversal vertex, we select this
untraversal vertex be the next vertex. We simply skip the
vertex which has been traced before during the embedding
or decoding. In short, these strategies effectively create
one traversal list of triangles and one traversal list of ver-
tices. Furthermore, both traversal lists are geometrically
invariant; they are robust against affine transformations.
Once both traversal lists are ready, we can begin to embed
the information. Since all procedures of the algorithm are
symmetrical, we can easily maintain both traversal lists in
both the embedding and extracting procedures.
Modified multi-level embedding procedure (MMLEP).
First, we consider every vertex of a triangle as a mes-
sage vertex. To embed information in every vertex, we use
a MMLEP, which includes sliding, extending, and arching.
In MMLEP, we embed the information by modifying the
message vertex based on geometrical properties; it guides
the change of the position of the orthogonal projection
A high-capacity steganographic approach for 3D polygonal meshes
Fig. 6. a A larger radius leads to a larger distortion when the change
is based on the same angle. b Using the same arc length for changes
ensures identical distortions for various radii
we can fine tune the γa by adding or subtracting the γi ,
which leads to the change of angle ϕ based on Eqs. 3, 4,
5 and 6.
−−→VsVm ·−−−→VsV ′′′m =
∣
∣
∣
−−→VsVm
∣
∣
∣ ·
∣
∣
∣
−−−→
VsV ′′′m
∣
∣
∣ cos ϕ = r2 cos ϕ (6)
We can achieve this procedure by Eq. 7,
if
⌊(
γa
γi
)⌋
mod 2 /∈ Bi :
ϕ =
(
360◦ × (γa + p×γi)
2×π ×r
)
− θ , (7)
where p ∈ {−1, 1} is the PRNS generated from a secret
key, and ϕ is the variation of angle introduced by the
change of the arc length.
In fact, every method of these levels is not limited to
embedding one bit per point. The real limitation is data
representation precision. For instance, in the sliding level,
when we divide the VaVb interval into 2s (s ≥ 1) sets,
we can embed s bits into each set. Let MMMLEP be the
maximal number of bits actually embedded and V be the
number of vertices in the model. We can then state the
following equation on this scheme:
MMMLEP = 3× s × (V −3)+2× s (8)
This approach achieves reversibility based on a recov-
ery key which is constructed during embedding and kept
private for retrieving the perfect original 3D model [6, 26].
Since the MMLEPs shift every message vertex symmetri-
cally, if we prefer to recover the original state of a message
vertex, it is necessary to store an extra bit for every bit
of the message, and its size is exactly the same as the
message size. Certainly, it can be compressed using some
lossless compression algorithms. In this way, reversibility
is only granted to the holder of the recovery key and the
secret key.
Representation rearrangement procedure (RRP). As men-
tioned previously, the main benefit of using the represen-
tation information of 3D polygon models to embed mes-
sages is that the stego model still preserves perfect visual-
ization, which means it looks exactly the same as the ori-
ginal model. Consequently, we first propose a representa-
tion rearrangement procedure (RRP), which includes ver-
tex order rearrangement, polygon order rearrangement,
and polygon indexes rearrangement, to embed messages
in the representation domain. In RRP, we embed messages
by modifying the vertex representation order, the polygon
representation order, and even the topology information of
polygons, with respect to the traversal orders. Our scheme
is simple and can achieve high capacity without any visual
distortion. Three-dimensional polygon models generally
include topology connectivity information and Cartesian
coordinate geometry (x, y, z). The geometry is defined
with three vectors x, y, z that assign 3D Cartesian coordi-
nates to every vertex. Furthermore, the mesh is composed
of the geometry defined over the arbitrary connectivity.
One can also add other attributes to the model like texture
coordinates, color, local refraction, etc. However, process-
ing of such data is out of the scope of this work. Although
our approach can directly be extended to process such data
to achieve higher capacity, here we only focus on em-
bedding messages by modifying the representation of the
most necessary vertices and polygons.
For simplicity, the vertices’ representation order is
classified into two sets according to the number of orders.
If the representation order number is an even number, then
we consider the vertex representation is in a ‘0’ state; oth-
erwise, the representation order number is an odd number,
and the vertex representation is in a ‘1’ state. As a result,
we can rearrange the representation order of vertices ac-
cording to the binary symbol they have to convey.
However, this basic scheme can only represent max-
imal V/2 ‘0’ states and V/2 ‘1’ states simultaneously,
where V is the number of vertices, as mentioned previ-
ously. In addition, since an uncertain number of bits can
be embedded, the embedded message should include the
information of the number of bits to be retrieved, which
possibly could be done by adding a lead-in sequence or
a lead-out sequence. Unfortunately, the bit numbers ‘0’
and ‘1’ of the real embedded message cannot be restricted.
Consequently, this simple scheme can just embed less than
V/2 bits in the worst case.
In fact, we propose an “iterative dynamic reassignment
conveyed message algorithm” to achieve higher capacity.
To solve this problem, we use the so-called global local-
ization technique. The purpose of such a technique is to
explicitly embed the value of the message bit based on
a specific traversal order for its number. In particular, we
embed message values (bits) through a vertex represen-
tation order rearrangement approach with the assistance
of the iterative dynamic reassignment conveyed message
algorithm, along the traversal list of the vertices. The mes-
A high-capacity steganographic approach for 3D polygonal meshes
where E is the number of edges in the manifold, and G is
the genus of the manifold; for example, a sphere has a 0
genus, a torus has a 1 genus, etc.
Assume that a triangular manifold mesh contains a suf-
ficiently large number of edges and triangles. In addition,
suppose that the ratio of the number of boundary edges to
the number of non-boundary edges is negligible. Then, the
number of edges can be approximated by Eq. 10:
E  3× P
2
, (10)
since an edge is shared by two triangles in general. Substi-
tuting Eq. 10 into Eq. 9, we get
P  2× V. (11)
Consequently, a typical triangular mesh has twice as
many triangles as vertices. In other words, we can embed
around (2V) bits, namely two bits per vertex, by modify-
ing the polygon representation order without causing any
visual distortion.
Finally, we apply the same concept to the polygon
indexes rearrangement and embed messages in every mes-
sage set, which is combined by two triangles, by modify-
ing the topology information of the message set.
Generally, the topology information of a triangle is
represented as A, B, C, where the A, B, and C are the in-
dex of vertices which construct the triangle ∆ABC. Since
A, B, and C cannot have the same number of indexes, we
can use this characteristic to define the triangle state for
embedded messages. First, we let the maximal number of
indexes of a triangle ∆ABC be index A, and the minimal
number of indexes be index C, and the index B is the re-
maining number of indexes. Furthermore, if the first index
is the maximal number of indexes of a triangle, then we
consider this triangle is in an ‘A’ state. Similarly, if the first
index is the minimal number of indexes of a triangle, then
the triangle is in a ‘C’ state; otherwise, the first index is
the remaining number of indexes of a triangle, and the tri-
angle is in a ‘B’ state. Since the direction of the mesh is
always defined by the order of vertices of triangles, the
order must be unified to clockwise or counter-clockwise
to maintain the same direction of the mesh. Consequently,
there are only three possibilities of the order. For example,
if the order of vertices of a triangle is counter-clockwise,
then the triangle can be represented as A, B, C, or B, C, A,
or even C, A, B, and represented ‘A’ state, ‘B’ state, or ‘C’
state, respectively; see Fig. 9.
In this way, every separate triangle has three pos-
sible representation states; namely, every separate triangle
could simply convey at least one bit of message. In other
words, there are nine possible combinations of two tri-
angles, and twenty seven possible combinations of three
triangles, and so on, because every triangle has three in-
dependent states. For simplicity, we combine two triangles
Fig. 9. A simple example of the representation state of a triangle
as one message set, and we embed three bits in the mes-
sage set by modifying the index representation of both
triangles. Which eight patterns of the nine combinations
of a message set should be used to represent three bits
of message was selected with a secret key. The capacity
of this approach is defined as Mpir, and simply stated by
Eq. 12.
Mpir =
⌊
P
2
⌋
×3+ P mod 2 (12)
In other words, we can embed around (3V) bits,
namely three bits per vertex, by modifying the topology
information of the messages set without creating any vi-
sual distortion.
Since the vertex order rearrangement changes the in-
dex number of vertices, we first need to embed a message
by vertex order rearrangement; we then embed succes-
sive messages by polygon order rearrangement. Finally,
the remaining message is embedded by polygon indexes
rearrangement. In sum, the proposed approach, which in-
cludes MMLEP and RRP, is simple and can achieve high
capacity with little visual distortion. Let M be the maxi-
mal number of bits actually embedded. The full capacity
of our approach can be simply stated by Eq. 13.
M = 3× s × (V −3)+2× s + (V −1)+ (P −1)
+
⌊
P
2
⌋
×3+ P mod 2 (13)
Consequently, our approach can embed around nine
bits per vertex based on both the spatial domain and the
representation domain.
3.2 Information extracting
Since all procedures of the approach are symmetrical, we
can easily extract the message using the method men-
tioned above if we have the help of the secret key.
4 Experimental results
We implemented the proposed technique using C++ pro-
gramming language. The 3D models use the IEEE single
A high-capacity steganographic approach for 3D polygonal meshes
Fig. 10. The cover and stego model of the teeth model. For a better comparison, we show the close-up views
Fig. 11. From left to right, stego models are listed in the following order: rabbit and venus
Table 2. The comparison of the five related steganographic methods: Aspert et al. [3] (ADME02), Cayre and Macq [6] (CM03), Maret
and Ebrahimi [16] (ME04), Wang and Cheng [26] (WC05), and our method. The capacity is denoted as average bits per vertex, and the
embedding time is the cost for embedding about 4000 bits to a 3D model on an Intel Pentium 1.6 GHz processor and 512 MB memory
ADME02 CM03 ME04 WC05 Our method
capacity < 0.5 < 1 0.5 3 9
embedding time ≈ 37 sec ≈ 15 sec ≈ 38 sec ≈ 0.15 sec < 0.1 sec
extraction blind blind blind blind blind
robustness affine affine affine affine affine
transformations transformations transformations transformations transformations
domain transform spatial transform spatial spatial &
representation
the watermark should survive after malicious attacks, thus
protecting copyright ownership. Steganography, on the
other hand, always tends to require security, high capacity,
blind extraction, and no robustness requirements. Conse-
quently, all of the steganographic methods for 3D models
in Table 2, which include our method, only consider ro-
bustness of the basic trivial operations of 3D models, such
as affine transformations. In addition, all of them also
can extract messages without the assistance of the cover
model. As mentioned previously, only our approach can
embed message based on the representation domain. Fi-
nally, our proposed approach offers a large improvement
in capacity and only costs minimal embedding time com-
pared to the previous 3D steganographic methods.
A high-capacity steganographic approach for 3D polygonal meshes
26. Wang, C.M., Cheng, Y.M.: An Efficient
Information Hiding Algorithm for Polygon
Models. Comput. Graph. Forum 24(3),
591–600 (2005)
27. Xiang, X., Held, M., Mitchell, J.: Fast and
Efficient Stripification of Polygonal Surface
Models. In: ACM Symposium on
Interactive 3D Graphics Proceedings, pp.
71–78 (1999)
28. Zafeiriou, S., Tefas, A., Pitas, I.: Blind
Robust Watermarking Schemes for
Copyright Protection of 3D Mesh Objects.
IEEE Trans. Visual. Comput. Graph. 11(5),
596–607 (2005)
29. Zollner, J., Federrath, H., Klimant, H.,
Pfitzmann, A., Piotraschke, R., Westfeld,
A., Wicke, G., Wolf, G.: Modeling the
Security of Steganographic Systems. In:
Information Hiding Workshop Proceedings,
pp. 345–355 (1998)
YU-MING CHENG is currently a Ph.D. can-
didate at the Institute of Computer Science,
National Chung-Hsing University, Taiwan. He
received a B.E. degree in Electronic Engin-
eering from the National Taiwan University
of Science and Technology in 2002. Then he
went to NCHU for the master program and
was allowed to directly pursue Ph.D. studies
in 2003. His research interests include tone
reproduction, three-dimensional steganography
and watermarking.
CHUNG-MING WANG (M’97) received a B.S.
degree in Applied Mathematics from the Na-
tional Chung-Hsing University, Taiwan, in 1984,
and a Ph.D. degree in Computer Science from
the University of Leeds, Leeds, UK, in 1992.
From August 1986 to August 1988, he was
a system analyst in the President Enterprise
Cooperation and the PAL Company.
He is currently a professor at the Institute of
Computer Science, National Chung-Hsing Uni-
versity, Taiwan. His research interests include
computer graphics, color science, virtual reality,
multimedia systems, and three-dimensional
watermarking and steganography.
Dr. Wang has won three Dragon Thesis Awards,
funded by Acer Computers, and the Outstanding
Paper Award from the Computer Society of the
Republic of China. He is a member of ACM,
IEEE Computer Society and Eurographics.
722 Y.-M. Cheng, C.-M Wang
polygonal model steganographic scheme that can achieve
adaptive message embedding. In particular, we propose an
adaptive minimum-distortion estimation (AMDE) proced-
ure to achieve adaptability and preserve important shape
features, such as ridges and corners, with respect to the
human visual system (HVS) [7]. This procedure also effi-
ciently increases the embedding capacity from three fixed
bits per vertex to variable 3v bits per vertex, where v is
the number of adaptive bits for embedding on the vertex
and v ≥ 1, depending on the correlation between neigh-
boring polygons. Furthermore, our procedure decreases
the maximum distortion from 2v −1 to 2(v−1). A simple
and efficient contagious diffusion technique is devoted to
the embedding path. This new technique is generalized for
polygonal meshes. It can support not only common tri-
angular meshes but also other polygonal meshes, such as
quadrangles. In addition, secret keys and a hash function
are used on the AMDE and contagious diffusion technique
for more security. Similarly to previous 3D steganography
methods, our algorithm is robust against affine trans-
formations, which include translation, rotation, uniform
scaling, or their combined operations.
The rest of this paper is organized as follows. In
Sect. 2, related work is described. Then, an overview of
the proposed technique is presented in Sect. 3. The details
of our algorithm are presented in Sects. 4 and 5. Experi-
mental results are shown in Sect. 6, followed by a brief
conclusion and future work in Sect. 7.
2 Related work
Several information hiding schemes for 3D models have
been proposed. They can further be categorized into
steganography or copyright marking with respect to
their specific purposes. As noted earlier, the purpose
of steganography is for covert communication between
two parties whose existence is unknown to a possible
attacker [14]. Copyright marking can be classified into
robust copyright marking and fragile watermarking. In-
formation hiding can be applied either to the trans-
form domain [2, 8, 10, 13, 17–19, 22] or to the spatial
domain [4, 5, 15, 16, 21, 23–25]. Figure 1 illustrates these
categories and shows which works address them.
Processing these schemes in a transform domain can
aid robustness but requires extra time. In addition, these
schemes often embed messages by relying on additive or
substitutive schemes. The substitutive scheme often can be
used for blind detection purposes. In steganography, we
are interested in maximizing capacity, efficiency, and per-
formance, but we assume limited robustness requirements.
Exploiting the features of 3D models from a capacity point
of view is one of our main goals here.
The purposes of steganography and copyright mark-
ing are very different. We survey a selection of 3D model
approaches mainly used for steganography without giving
Fig. 1. A simple category of the related work
a complete overview for copyright marking, which would
be beyond the scope of this paper.
Aspert et al. [2] proposed a scheme that transformed
Wagner’s watermarking technique [22] into a stegano-
graphic algorithm for 3D polygonal models. They used
small displacements of the vertices to embed the informa-
tion. Maret and Ebrahimi [13] made some improvements
to [2, 22]. They increased the capacity by using the em-
bedding process for the sample distribution in the similar-
ity transform invariant space. Unfortunately, both stegano-
graphic schemes have low capacity and large processing
time.
Cayre and Macq [5] described an algorithm for 3D
triangle meshes in the spatial domain. Their algorithm,
which is derived from the quantization index modulation
(QIM) concept, can normally embed one bit per vertex.
Unfortunately, their algorithm usually cannot use all ver-
tices of models for data embedding. In addition, the pro-
cessing is time-consuming.
Research presented by Wang and Wang [24] seems to be
the source for steganographyon point-sampled geometries.
Their scheme works in the spatial domain, using a princi-
pal component analysis (PCA) [20], a symmetrical swap
algorithm, and an encoded swap algorithm. The capacity in
bits generally achieves nearly 1.2 ∼ 3 times the number of
points in the models. This type of 3D model is outside the
scope of this paper and will not be considered here.
Wang and Cheng [23] proposed an efficient stegano-
graphic scheme for 3D triangle meshes recently. Their
scheme is also a blind scheme in the spatial domain. First,
they resolve the initial triangle for embedding by PCA.
Next, an efficient triangular mesh traversal method is de-
veloped to generate a sequence list of triangles, which
will contain the hidden message. Finally, they embed three
fixed bits per vertex for all vertices relying on three in-
dependent degrees of freedom. As a result, they exploit
a larger capacity in the 3D space than Cayre et al. [5]
and [4].
The algorithm proposed by Wang and Cheng has three
drawbacks. First, it ignores the fact that not all vertices in
a model can tolerate equal amounts of vertex shift with-
out causing noticeable distortion. Specifically, the vertex
724 Y.-M. Cheng, C.-M Wang
Fig. 3. A simple example of VBT and PNT
cause it reduces the number of candidate polygons needed
to be searched and compared. Note that if two polygons
share an edge containing two identical vertices, then these
two polygons are neighbors. To build the PNT, we first
visit every polygon and find its edges and corresponding
vertices. We then check the VBT to determine whether
there are any edges shared by two polygons. Since every
entry of the VBT contains a small number of polygons, the
checking is efficient and fast. As a result, by employing
the VBT we can construct the PNT efficiently, leading to
a faster determination of a polygon’s neighbors.
4.2.2 Terminology
The contagious diffusion technique quickly traverses the
polygonal mesh, producing the traversal path. This tech-
nique is inspired by the concept of epidemics, which can
spread widely in a short time. First, we define the ini-
tial polygon of the polygonal mesh as incubative. We
can think of this polygon as just having been “infected”
by PCA. An edge in this polygon is the initial edge, and
two vertices of this edge are the initial vertices. The two
initial vertices on the initial edge are defined as virus ver-
tices, and consequently the initial edge is defined as the
virus edge. On the other hand, all vertices are considered
healthy except these two initial vertices. We take a virus
edge as the medium for infection; a polygon would be in-
fected by the shared virus edge. A polygon that has not yet
been infected is called susceptible, which means that it can
easily be infected by one shared virus edge and in turn be-
come incubative. When a polygon is infected, we embed
a message into one of its healthy vertices (detailed later).
A healthy vertex becomes a virus vertex once it has
been embedded into a message. When all healthy ver-
tices in an incubative polygon become virus vertices, the
polygon becomes infective. This means that the infective
polygon can infect susceptible neighbor polygons, since
all edges within it are virus edges. In addition, when all
neighbor polygons have been infected, the originally in-
fective polygon is no longer capable of infecting other
polygons anymore. It is then immune.
Every infective polygon can only infect other, sus-
ceptible polygons exactly once, the time cost for which
is O(n). This susceptible–incubative–infective–immune
process repeats until all the polygons of the polygonal
mesh are immune (Fig. 4). Consequently, if a polygon has
at least one neighbor polygon that has a direct or indi-
rect connection to the initial polygon, it will finally be
infected.
4.2.3 The process of contagious diffusion
We now detail the process of contagious diffusion using an
example. Figure 5 illustrates some part of the polygonal
mesh where the initial polygon, Pinitial , contains three vi-
ral vertices and nearby susceptible polygons consist of
healthy vertices. Now, the infective polygon intends to
infect these nearby polygons through the virus edge con-
structed by two viral vertices (VA and VB). Referring to
the PNT, we know that polygon Pj is infected. Here, we
call polygon Pinitial the pathogenic polygon of Pj .
At this point, we begin to embed a message into the
healthy vertices of the incubative polygon Pj . We first
split the incubative polygon Pj into two virtual triangles,
each of which contains the virus edge VAVB. Beginning
with vertex VA and applying the counterclockwise order
in polygon Pj , we can derive the first virtual triangle
as T1, which contains vertices VA, VB, V1, and the second
virtual triangle T2, which contains vertices VA, VB, V2.
Generally, we can represent virtual triangles as T1, T2,
. . . , T(ej−2), where ej denotes the number of edges in
polygon Pj .
For security, we do not use the order derived from the
counterclockwise approach. Instead, we apply Eq. 1 to de-
termine the first triangle for message embedding. In this
equation, Tfirst represents the identity of the first embed-
ding triangle, and Sj is a pseudo random number sequence
Fig. 4. The four states of polygons in contagious diffusion
Fig. 5. An example of the contagious diffusion method
726 Y.-M. Cheng, C.-M Wang
gon VAVBVC VD, and the number of bits to be embedded
into the healthy vertex (v), we consider a virtual triangle
∆VAVBVC , as shown in Fig. 8. Let VC be the healthy ver-
tex on which we intend to embed the secret message, and
let VS represent the orthogonal projection point of VC on
the base edge VAVB . Now, we extend the QIM concept
to the base edge. Given an integer α, we divide the base
edge into α line segments, and denote each line segment
by Sk, where k = 0, 1, . . . , α−1. Since each line segment
is a fraction of the base edge, these line segments are in-
variant to an affine transform of the model.
We define the message state (Mi) of each line seg-
ment Sk as i = k mod 2v. For simplicity, we represent
the message state using a v-bit binary representation
(see Fig. 9). We can now define a vertex’s message state as
follows. Suppose the VS is inside a particular line segment
with the message state Mi . We use the expression VS ∈ Mi
to indicate that a vertex VC has the message state Mi .
Now, let i represent the secret message (v-bit of 0 or 1
bit string). To embed message i into the healthy vertex VC ,
two cases can occur:
Case 1. VS ∈ Mi . No vertex shift is needed.
Case 2. VS /∈ Mi . We need to shift VC , parallel to the
base edge VAVB, to the new position V ′C so that V ′S ∈ Mi ,
where V ′S is the orthogonal projection point of the shifted
vertex V ′C .
The shift does not change the angle features between
two neighboring polygons, because V ′C is on the same
plane containing the virtual triangle.
If we define the length of each segment Sk as a unit
interval, then the approach of shifting the vertex only in
one direction introduces 2v −1 unit interval of distortion
in the worst case. For example, when we employ the pos-
itive direction (VA to VB) to change VC from the message
state M00 to M11, the vertex shift causes three units of
Fig. 8. The sliding level of the proposed scheme
Fig. 9. Given v is set as 2 and α is set as 12, we divide the base
edge VAVB into 12 line segments Sk, k= 0, 1, . . . , 11, where each
segment has the corresponding message state Mi , i = k mod 2v;
namely, M00 ∼ M11, using 2-bit binary representation
distance distortion, as shown in Fig. 10. To decrease the
distortion, we employ the minimal distortion distance esti-
mation instead. The first step of the scheme is to estimate
the minimal distortion distance. The second step is to de-
termine the direction of the vertex shift, either followed by
the positive direction from VA to VB , or its opposite.
Let VC have the message state “o”, i.e. VS ∈ Mo, and
suppose we intend to embed a secret message “e”. Accord-
ing to Case 2, we need to shift vertex VC to the new pos-
ition V ′C , so that V ′S ∈ Me. Applying the MDDE approach,
we estimate the minimal distortion distance by Eq. 4,
⎧
⎪
⎨
⎪
⎩
err1 = Me − Mo
err2 = 2v + Me − Mo
err3 = −2v + Me − Mo
|errm | = min(|err1|, |err2|, |err3|)
⎫
⎪
⎬
⎪
⎭
. (4)
To determine the sign of errm we first let sign(errm)
represent the sign of errm . Then, we define that sign(errm)
is identical to the sign of minimal error value. For ex-
ample, if |err3| is the minimal error value, then sign(errm)= sign(err3). We can determine the direction of vertex
movement as follows:
1) if sign(errm) is positive, use the positive direction, but
2) if sign(errm) is negative, use the negative direction.
This MDDE approach allows the vertex shift in two di-
rections. It efficiently decreases the maximum distortion
from 2v −1 to 2(v−1) unit interval, where v ≥ 2. Now, we
follow the same example shown in Fig. 10 using the MDDE
approach. When we shift VC from M00 to M11, we know
errm = −1, since err1 = 3 −0 = 3, err2 = 4 +3 −0 = 7,
err3 = −4+3−0 = −1. We follow the negative direction
for the vertex movement since sign(errm) = sign(err3) is
negative. Thus, we shift M00 negatively to M11, resulting
in only one unit interval of distortion distance. As a con-
sequence, the minimum distortion distance estimation ap-
proach provides less perceptual distortion for embedding.
4.3.3 Embedding at the extending level using MDDE
We can apply the same MDDE approach for message em-
bedding at the second level, the extending level. At this
Fig. 10. A simple diagram of MDDE
728 Y.-M. Cheng, C.-M Wang
Fig. 12. a Rotating level of the proposed
scheme. b A cross-sectional view of the
original clip angle θ, the rotation angle ϕ,
and the new clip angle θ ′ after the vertex
rotation
“d” rotation direction, which is determined using Eq. 10.
For example, if err1 = 3, err2 = 7, and err3 = −1, then
errd = 3 if d = 1, and errd = −1 if d = −1,
d =
{
1, if (θ mod π
σ
)
< π2σ
−1, if (θ mod π
σ
) ≥ π2σ
. (10)
In this equation, d = 1 represents the “positive” rota-
tion, where the new clip angle is increased after the vertex
rotation (θ ′ > θ). In contrast, d = −1 indicates the “nega-
tive” rotation due to the decreased new clip angle (θ ′ < θ).
The geometric meaning of this equation is that when the
original clip angle is within the lower half of the category,
the vertex is rotated to a new position which increases the
new clip angle.
The movement mapping from VC to V ′C is invariant
through affine transformations. For the initial polygon, we
embed messages only at the sliding and extending levels.
We do not embed any message at the rotation level, since
there is no pathogenic polygon with respect to the initial
polygon.
5 Information extraction
During extraction, the following steps are performed.
First, the stego model is analyzed using the PCA tech-
nique to obtain the initial polygon. Then, we traverse the
polygonal meshes using the contagious diffusion tech-
nique, producing the traversal path. Finally, we extract
the message using the AMDE procedures in the sliding,
extending, and rotating levels.
6 Experimental results
We implemented the proposed technique using C++ pro-
gramming language. Experimental results were collected
on a personal computer with a 2.4 GHz processor and
512 MB memory. The analyses of our steganographic sys-
tem are based on the following four goals: increased cap-
acity, invisibility, security, and complexity.
In this paper, one of our main goals was capacity. We
assumed limited robustness requirements, except basic op-
erations such as affine transformations. Depending on the
correlation between neighboring polygons, we increased
the capacity from three fixed bits to variable 3v bits per
vertex using the message adaptation estimation (MAE) ap-
proach. No errors were found in the recovered messages,
even when we applied some arbitrary affine transform-
ations to the stego models.
Figure 13a shows the relation between the capacity and
the tolerant value σ using the MAE approach. Once again,
a larger σ tolerates more changes in a vertex’s position in
return for a higher capacity in this vertex.
Table 1 presents the model details, the embedded mes-
sage, model distortion using MDDE, and the processing
time. Some proposals have been made for 3D polygo-
nal models based on the Hausdorff distance [1, 6], while
some others handle meshes with different topologies [11].
Since our scheme does not change the topology of 3D
polygonal models, we divided the root mean square error
(RMSE) [23] by the length of the bounding box diag-
onal to evaluate the distortion induced by the embedding
process. The distortion values are rather small, indicating
insignificant distortion in quality for the stego models. All
distortion statistics demonstrate that our approach works
well with 3D polygonal models.
For invisibility, we preserved the important shape fea-
tures, such as ridges and corners, with respect to the HVS.
Vertices on rough surfaces may embed more data than
those on smooth surfaces. Figure 13b shows the relation
between the distortion and the tolerant value σ . As ex-
pected, a larger σ leads to more distortion but higher cap-
acity. Figure 13b also shows the advantage of our MDDE
approach. This approach decreases the maximum distor-
tion from 2v −1 to 2(v−1). As a result, the distortion intro-
duced by the MDDE is always smaller than the original
730 Y.-M. Cheng, C.-M Wang
Fig. 14. The cover and stego model of the dinosaur model. For a better comparison, we also show the close-up views
Fig. 15. The cover and stego model of the car model. For a better comparison, we also show the close-up views
Table 2. A comparison of the methods of Aspert et al. [2] (ADME02), Cayre and Macq [5] (CM03), Maret and Ebrahimi [13] (ME04),
Wang and Cheng [23] (WC05), and our method. The capacity is denoted as average bits per vertex, and the embedding time is the cost
for embedding about 4000 bits to a 3D model on a 1.6 GHz processor and 512 MB memory
ADME02 [12] CM03 [3] ME04 [14] WC05 [4] Our method
Capacity < 0.5 < 1 0.5 3 3 ∼ 6
Adaptability No No No No Yes
Embedding time ≈ 37 s ≈ 15 s ≈ 38 s ≈ 0.15 s < 0.05 s
Cover model Triangle meshes Triangle meshes Triangle meshes Triangle meshes Polygonal meshes
Extraction Blind Blind Blind Blind Blind
Robustness Affine Affine Affine Affine Affine
Transformations Transformations Transformations Transformations Transformations
Domain Transform Spatial Transform Spatial Spatial
embedding time, compared to the previous 3D stegano-
graphic methods.
7 Conclusion and future work
In this paper we have presented a new adaptive stegano-
graphic algorithm for 3D polygonal meshes. Our tech-
nique provides steganography with adaptability, simpli-
city, efficiency, generalization, high capacity, security, low
distortion, and robustness against affine transformations.
To the best of our knowledge, this is the first 3D polygonal
model steganographic scheme that can achieve adaptively
embedded messages. In addition, the scheme has been
generalized to support polygonal meshes, not necessarily
restricted to only triangular meshes. Our scheme also pre-
732 Y.-M. Cheng, C.-M Wang
YU-MING CHENG is currently a PhD candidate
at the Institute of Computer Science, National
Chung-Hsing University, Taiwan. He received
a BE degree in electronic engineering from
the National Taiwan University of Science and
Technology in 2002. Then he went to NCHU
for the Master’s program and was allowed to
directly pursue PhD studies in 2003.
His research interests include tone reproduc-
tion, three-dimensional steganography and
watermarking, and secret sharing.
CHUNG-MING WANG received a BS degree in
applied mathematics from the National Chung-
Hsing University, Taiwan, in 1984, and a PhD
degree in computer science from the University
of Leeds, UK, in 1992.
From August 1986 to August 1988 he was
a systems analyst at the Uni-President Enter-
prises Corporation and in the PAL Company.
He is currently a professor at the Institute of
Computer Science, National Chung-Hsing Uni-
versity, Taiwan. His research interests include
computer graphics, color science, virtual reality,
multimedia systems, and three-dimensional
watermarking and steganography.
HUANG et al.: TOWARD OPTIMAL EMBEDDING CAPACITY FOR PERMUTATION STEGANOGRAPHY 803
Fig. 1. Given   elements which are currently available, our algorithm encodes
the first elements and the last elements by the  -bit words of secret
message, while elements left are encoded by the -bit words.
Fig. 2. Pseudo code of encoding part in proposed algorithm. The input of the
secret message is in form of a bitstream and the output is the stego array stego[].
Fig. 3. Example of encoding section in proposed algorithm.
by the -bit word, where . Elements in the
second part ( elements) are encoded by -bit words.
This scheme allows our algorithm to offer a greater capacity
than that can be achieved by Bogomjakov et al.’s algorithm.
Fig. 2 depicts the pseudo code of our algorithm for embedding
the secret message. We compute the reference ordering of the
elements in Step 1, and then we permute elements to embed the
message through a for-loop in Step 2.
We present an example in Fig. 3 to illustrate Step 2. Assume
that there are seven elements, (b, d, f, c, a, g, e), and that the
secret data entry is “1001100101001.” In Step 1, the original
seven elements are sorted to become (a, b, c, d, e, f, g). The
for-loop has six iterations, as depicted below.
Iteration 1: and . We
read a 2-bit word of the secret message, “10,” shown with the
underlined, and we compute its decimal value, val = 2. Because
, we take advantage by reading one
extra bit of the message, “0.” We then update to
. Now, we output (c) to the stego sequence
because element (c) has the sequence value 2, equivalent to .
At the end of this iteration, we move the last element (g) to the
Fig. 4. Pseudo code of decoding section in our algorithm. The input is the stego
array stego[] and the output is the secret message in form of a bitstream.
Fig. 5. Example of decoding section in our algorithm.
position of element (c) in the element sequence, thus leading to
the element sequence (a, b, g, d, e, f).
Iteration 2 : The parameter , and
. We read a 2-bit word of the secret message,
“11,” and because , we cannot take
advantage of encoding one extra bit. Instead, we output (d) to
the stego sequence, and, again move the last element (f) so that
the element sequence becomes (a, b, g, f, e).
We can operate iterations 3 to 6 by following the approaches
described above in order to produce the final stego sequence (c,
d, e, b, a, f, g). For comparison, given seven elements, our algo-
rithm can encode 13 bits of a secret message, but Bogomjakov
et al.’s algorithm can only encode 12 bits of a secret message.
Fig. 4 depicts the pseudo code of our algorithm used for ex-
tracting the secret message. In Step 1, we compute the refer-
ence ordering of the elements in the stego sequence. In Step 2,
we extract the message through a for-loop. For simplicity, we
illustrate the message extraction by using an example shown in
Fig. 5. Given a stego sequence (c, d, e, b, a, f, g), we can produce
the original element order (a, b, c, d, e, f, g) after the sorting of
Step 1. We focus the message extraction in the for-loop shown
in Step 2.
Iteration 1: First, we compute parameters
and . Second, we read the first stego element
(c), which has the original sequence value of 2. This procedure
leads to extracting a 2-bit word of message “10.” Third, because
, we gain a one-bit advantage when embedding the
secret message. We can then extract an extra bit of message “0.”
Finally, we move element (g) to the place of (c), thereby leading
to a new element sequence (a, b, g, d, e, f).
Iteration 2 : First, we read the second stego element
(d) and assign by referring to its original sequence
Authorized licensed use limited to: National Chung Hsing University. Downloaded on August 25, 2009 at 22:49 from IEEE Xplore.  Restrictions apply. 
