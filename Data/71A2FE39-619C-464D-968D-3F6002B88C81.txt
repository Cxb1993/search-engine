 
The VERTAF/Multi-Core (VMC) framework takes SysML models 
as input which contains user-specified modellevel explicit 
parallelism and automatically generates corresponding multi-core 
embedded software code in C++, which are scheduled and tested for 
a particular platform such as ARM 11MPCore and Linux OS. 
 
The VMC project has been divided into seven subjects, including 
VMC_REM, VMC_MUM, VMC_DSS, VMC_SYN, VMC_AM, 
and VMC_TMS. These subprojects cooperate together to solve the 
problems aforementioned. 
 
 
目錄 
摘要 ........................................................................................................................................................ 3 
Abstract .................................................................................................................................................. 7 
一、 前言 ........................................................................................................................................ 8 
二、 二年研究項目及成果 ............................................................................................................ 9 
I. VMC-REM：以 SysML 為基礎之多核心嵌入式系統需求塑模環境 ............................. 12 
A. 研究目的 ...................................................................................................................... 13 
B. 研究成果 ...................................................................................................................... 14 
C. 結論 .............................................................................................................................. 27 
II. VMC-MUM：支援多核心嵌入式軟體設計之多重觀點整合模型與可再用元件庫 ..... 28 
A. 研究目的 ...................................................................................................................... 28 
B. 研究成果 ...................................................................................................................... 29 
C. 結論 .............................................................................................................................. 42 
III. VMC-DSS：設計樣式支援系統: ................................................................................... 43 
A. 研究目的 ...................................................................................................................... 43 
B. 研究成果 ...................................................................................................................... 43 
C. 結論 .............................................................................................................................. 53 
IV. VMC-SYN: 多核心嵌入式軟體合成及程式碼生成 .................................................... 55 
A. 研究目的 ...................................................................................................................... 55 
B. 研究成果 ...................................................................................................................... 57 
C. 結論 .............................................................................................................................. 72 
V. VMC-AM: 架構及效能調校支援實作 .............................................................................. 72 
A. 研究目的 ...................................................................................................................... 72 
B. 研究成果 ...................................................................................................................... 73 
C. 結論 .............................................................................................................................. 75 
VI. VMC-PPO: 平行程式優化支援實作 ............................................................................. 76 
A. 研究目的 ...................................................................................................................... 76 
B. 研究成果 ...................................................................................................................... 77 
C. 結論 .............................................................................................................................. 86 
VII. VMC-TMS: 測試支援系統 ............................................................................................ 87 
A. 研究目的 ...................................................................................................................... 87 
B. 研究成果 ...................................................................................................................... 88 
C. 結論 ............................................................................................................................ 118 
三、 計畫成果(期刊、論文發表) ............................................................................................. 118 
四、 國科會補助計畫衍生研發成果推廣資料表 .................................................................... 123 
 I. 子計畫一: 以SysML為基礎之多核心嵌入式系統需求塑模環境： 
本子計畫主要在需求階段解決因自然語言所描術的需求常有模糊不清、不一致等問題，使
得訂定規格所帶來的效益減低，成本增加。在執行嵌入式軟體開發的過程中有很多的問題，
而其重要的問題之一，就是如何幫助系統開發人員從先前開發過的案例中找尋符合目前系
統的可重用軟體需求，並利用重用技術減少系統開發成本、加快研發速度。然而這個問題
不容易解決的原因在於缺乏能夠提供系統開發人員瞭解需求重用的資訊，因而需要人工逐
一檢視需求文件。本研究中將結合需求訪談與編輯、樣板及SysML圖三種元素到軟體中，
利用介面引導搭配專家樣板實現需求重用，並讓系統開發人員了解使用者需求的正確與否，
預期將可減少開發人員思索如何定義需求屬性的時間，提高開發效率。 
II. 子計畫二:多重觀點整合模型與可再利用元件庫: 
本子計劃主要目的在支援多核心嵌入式軟體設計之多重觀點整合模型與可再用元件庫
(VMC_MUM)，分析了XML-based Unified Model 在嵌入式系統中之限制及元件再利用，以
物件導向技術(OO Technologies) 作為基礎，主要原因是目前物件導向分析及設計語言如
UML 及相關物件導向程式語言，如Java，C++已被廣泛的接受與使用，本子計劃分析了重
觀點整合模型與可再用元件庫： 第一是使用先前在XML為基礎的軟體標準整合模型研究
的成果，定義出一個以模型為基礎之XML 系統文件描述模型，稱為XML-based Unified 
Model Metamodel。 二是使用Reusable Design Component Repository，藉由元件式資料庫之
再利用性來提高軟體品質及產能。最後透過本子計畫的Unified and Integration Model 作各
子計劃之間的銜接與資訊交換。將各子計畫所採用不同之標準整合後，透過一致的表現方
式以及整合鏈結(Integration Links)的串接，有效達到跨階段、觀點間相關連資訊的串接與再
用。 
III. 子計畫三：設計樣式支援系統: 
本計畫重點著重於系統開發者在設計方面的支援，即VMC之設計應用子系統（Design 
Supporting Subsystem for VMC，簡稱為VMC-DSS）主要功能的設計與開發，包含樣式塑模
模組、操作定義模組以及硬體資訊定義模組，並與其他子計畫系統做進一步的整合，且以
一嵌入式系統實例驗證本研究之實用性。本計畫預期提供系統開發者一個完整的UML系統
設計流程環境，即選定硬體規範、設計與套用樣式、定義操作功能，用以提供其他子計畫
銜接之所需的設計相關資訊。 
VII. 子計畫七：多核心嵌入式軟體之測試支援系統 
在多核心嵌入式軟體的軟體開發的過程中，軟體測試是一項龐大的工程，更是軟體產品執
行品質控管的重要關鍵。然而軟體測試工作往往需要花費很多的人力及物力，加上嵌入式
系統的硬體資源的限制，使得嵌入式軟體的測試較為困難。此外多核心嵌入式軟體之
concurrent program 存在很多不確定性，且相對於 sequence program 也較難除錯。然而，目
前大部分嵌入式軟體開發環境也較缺乏自動化的軟體測試工具來輔助。為了減輕這些問題，
本子計畫建構了一個支援嵌入式軟體開發的 cross-testing的自動化測試環境系統。能提供自
動執行多回合測試機制；降低測試工程師的負擔，增進嵌入式系統執行測試工作的效率。
以「支援平行程式自動化測試」及「object testing」為主找出平行程式在資料同步時潛在的
錯誤，藉由檢查多執行緒共同存取共享資源 synchronization lock 的一致性及監控所有
synchronization primitives 事件執行的順序來判斷是否有潛在的 race condition。而平行程式
的效率也是開發人員所關注的項目，本子計畫針對多核心來平行程式效能的測試，可以即
時監控 CPU各個核心的利用率、程式執行時間。此外，我們也將發展如何提昇平行效能的
方法及發展配合多核心嵌入式軟體的測試方法，例如配合 OpenMP 及 TBB的測試方法。 
 
關鍵詞: 嵌入式系統, 多核心, 統一塑模語言,系統塑模語言,統一塑模,自由軟體, 軟體設計框
架 
一、 前言 
本整合型計畫網羅了各方面的專家，包括了需求分析、軟體設計、軟體工程、嵌入式系統、
平行化計算、軟體測試、系統整合等，共同開發設計出一套整合式多核心嵌入式軟體之模
型驅動整合開發環境–VERTAF/Multi-Core (VMC)。VMC對於目前國內嵌入式軟體產業缺
乏支援自動化的軟體發展整合開發環境現象，提供一個符合開放原始碼(open source)規範的
選擇，進而提升國內嵌入式產業軟體設計能力與品質。 
本整合型開發計畫(簡稱 VMC 計畫)為二年期長期計畫，横跨五所大專院校合作，因此若沒
有一致的專案管理方式與技術整合機制，會造成資源浪費、時程落後、品質不齊、無法整
合等問題。因此總計畫依據 Light-weight CMMI的方式，溝通、協調與管理整個 VMC 計畫
，如圖二所示，總計畫的重點在於架構協調、專案管理、規格控制、與品質控制等議題。 
 
 
圖 2總計畫與其它子計畫關係圖 
 
A. 架構管理: 主要在確認各子計畫對 VMC 系統有一致的架構認知，特別是在介面的溝通
上。 
B. 專案管理: 則廣泛的包含CMMI中的專案計畫、專案監控、建構管理與量化分析等項目。
試的環境，方便軟體測試的進行，增加測試的效能，提高測試的coverage，降低軟
體的錯誤率。另外，預計發展出提昇Code Coverage 的方法及配合多核心嵌入式軟
體的測試方法。 
就第一年的成果而言，需求塑模利用需求模板(Requirement template)對 DVR 例子分析
重要資訊，設計樣式則針對 DVR 中的平行模型，例如 software pipeline等定義了樣式
模板。而 DVR 系統也以 QP 及 TBB完成整合及實作並在 PC 端做展示，其中包含系統
功能測試及監測部份功能，擷取系統執行期資訊並加以分析，以上成果亦有論文發表於
會議及期刊，此成果將會在面後章節詳列。 
在第二年的計畫中增加了二個新的子計畫分別為多重觀點整合模型與可再用元件庫
(VMC-MUM)以及平行程式優化支援實作(VMC-PPO)。 透過子計畫二，各子畫目前已
按 DVR 例子提供 input/output 範例進行資訊交換整合。此外 VMC 計畫利用 Trac project 
建置專案管理網站(http://140.123.105.205/projects/vmc)。Trac搭配 SVN 來使用，含括
文件，時間軸追蹤，產品路線圖，瀏覽原始碼，新增/檢視待辦事項，搜尋等功能) ，
提供計畫進度管理、會議紀綠等相關文件及各子計畫之設計產出之管理，並提供各子計
畫交換資訊及解決問題的地方。 
下圖 3為 wiki 文件管理畫面，包含文件如下： 
1. VMCMeetingMinutes: 
存放各子計畫每次開會的會議紀錄。 
2. Documents： 
主要為 light weight CMMI文件管理 
3. DVRSourceCode 
存放三年實作之 DVR source code 
4. DVRModels 
存放以 papyrus 設計之 DVR 塑模 
 
 圖 5 Roadmap畫面 
 
圖 6為源碼瀏覽畫面，主要是利用 SVN為後端版本控制系統，前端 Trac提供使用者查詢
及管理，SVN logs，可以看到修改紀錄， 版本比對等資訊。 
 
圖 6源碼瀏覽及版本控管畫面 
 
為了第二年各子計畫之間的整合及塑模之間資料一致性的控管及追踨，各子計畫實作三項
計畫整合工作，包含：API介面制定及 Data dictionary。就 API制定的目的而言，各子計畫
制訂的 API交由子計畫二統一實作，提供子計畫間訊息及資料的交流及傳遞。交流的技術
主要以 XML格式為主。另外由於系統的 model之間彼此往往會具有相依性，需要為 model
之間建立鏈結，以維護不同設計階段各 model之間的關係，我們透過 data dictionary制訂，
維護不同 model之間資料的一致性，達到整合的目標及 VMC 功能的正確性。 
 
本章節我們將針對各子計畫之研究及開發成果做說明： 
 
I. VMC-REM：以 SysML 為基礎之多核心嵌入式系統需求塑模環境 
求規格(SRS，Software Requirement Specification)。但是由於將顧客要求轉換成顧客需求必
須建立在經驗的基礎上，也就是說如果工程師缺乏相關的經驗，在將要求轉成需求的過程
當中，有可能會遺漏相關的資訊或是必要之功能。 
在開發流程之需求階段時，及時地規劃出使用者需求的系統流程以及動態，而後開發
者得以從介面延伸出類別、方法以及類別圖。而其他的需求，尤其在Non-Functional的方
面的需求，如Security、Performance、Reliability，則需要開發者在設計階段訂定。近年來
嵌入式軟體不論從絕對數量或複雜度而言都是處於蓬勃發展階段，需要開發的軟體越來越
多樣化，包括手機、PDA、GPS或是嵌入式伺服器(Embedded Server)都是全球廠商非常看
好的一塊市場。同時，在嵌入式系統中，透過軟體實現的功能有日益增加的趨勢。傳統的
先硬體後軟體的設計方法對這種複雜的嵌入式系統開發已不再適用。因為無論從品質或是
從生產力的角度來看，軟體和硬體都必須同時開發和驗證。因此在需求分析階段取得精確、
完整的需求將會是降低軟體開發成本的關鍵，其重要性也是顯而易見。 
本計畫兩年期間藉由所開發之需求塑模環境，提供使用者方便建立完整且量化之需求、
提高嵌入式軟體需求的重用性與可靠度，並且建立需求之間的雙向追溯，節省系統開發的
成本，並能應變市場環境以及多樣客製化等因素，成為針對多核心嵌入式軟體一套完整的
輔助開發環境。 
B.  研究成果 
在需求分析，針對嵌入式系統的特性，在需求階段特別強調量化及模型導向，使用
SysML來描述需求。為了提供輸入需求資料時更好的組織化，並且正規化資料，避免缺漏
或模糊等情況，我們設計一個系統模式的畫面呈現給需求建立者，包括利用模板來編輯需
求，以及匯入匯出等功能。接著，藉由專家樣板的引導，讓需求建立者能夠清楚瞭解需要
輸入什麼資訊以達到需求的重用性。 
為了提高嵌入式軟體元件的重用性(Reusability)與元件之間的關聯性，我們提出以
XML為基礎的專家樣板(expert template)，並開發了XML為基底並結合參考硬體限制的重
用嵌入式軟體需求資料庫。 
當需求輸入完畢後，會將資訊輸出成XML檔案存入需求庫，成為經驗樣版的儲存體，
以利日後的使用者重用，若未來需求的內容有所改變，也可以經由此系統模式更新需求，
並以版本控制作為解決需求重複或不一致的情況產生。使用者並不瞭解自己真正需求的元
件時，就可以依照一套標準的專家樣板來引導使用者篩選出需要的元件類型，將自己所需
要的元件一一的選取。 
1. 模型導向需求塑模 
係。需求圖可以顯現出需求與需求之間的階層(hierarchy)，讓系統設計師清楚地看出
需求階層關係與系統架構；還有數種表示方法來找出需求間的關係，包括 derive (衍
生)、copy(複製)、satisfy(滿足)、verify(驗證)、refine(提煉)、trace(追蹤)等，通常應用
於比較大型且複雜系統方面。 
SysML可以應用於表示各種領域的模型元素，靠著需求圖與視覺化的關係。事實上，
SysML的需求圖為 UML類別圖(class diagram)的擴充原型(stereotype)，如圖 10所示: 
<<Metaclass>>
UML4SysML::Class
<<Stereotype>>
Requirement
-Text : String
-Id : String
 
圖 10需求圖擴充原型 
 
如圖 11為需求推導流程，由使用者需求到系統需求的推導。與專案關係人的需求訪
談以及系統分析師的知識領域分析，來產生使用者需求。接下來由 SysML的塑模，
來產生需求圖，此需求圖為初階的需求圖圖形。然後由分析使用者需求來產生 Use 
Case與 Scenario，Use Case 與需求之間會有 refine關係產生。可以從 Scenario 的細部
描述，來得到使用者需求的 external 與 internal interface，而形成第二層的需求圖，會
有 derive關係產生；另外一方面，可以藉著 Use Case與 Scenario，來推得使用者需求
的 Test Case，需求與 Test Case會有 verify關係。由於已經從 Scenario 得知細部的需
求，加上第二層需求圖的內外部介面動作，所以可推得需求的類別屬性與操作，而產
生 Block Definition Diagram，類別與需求之間有 satisfy關係。在推導得知需求最細部
的類別之後，階層式的完整需求圖圖形也已經完成，然後再描繪出系統的 State 
Machine Diagram。這就是由使用者需求到系統需求的推導流程。 
需求的完整性，同時也便於估算開發成本與時程。 
 
3. PIM 階段 
在 PIM 階段我們根據分析狀態圖來有說明關於人員、流程、系統的運作，以及其狀態的轉移
的規則；接著為狀態圖內部各狀態之間轉移的動作，定義需求的操作(operation)，以及為狀態
的轉換行為定義屬性(Attribute)，所得到的資訊如表 2，將被參照使用於區塊定義圖來表達系
統內部的靜態結構，區塊定義圖(Block Definition Diagram 以下簡稱 BDD)，如圖 13，通常會
是系統設計的時候，被拿來當作重要設計藍圖，分析師經過套用需求樣版，得到初步的系統靜
態結構，也就是區塊定義圖，而透過分析前面的狀態圖與需求樣版來得知區塊定義圖尚需加入
的屬性與操作種類，並可透過每個區塊所屬的 Profile(表 3)來描述元件運作方式。 
 
表 2定義狀態轉移動作時的操作 
系統名稱 
A.轉移動作 
B.轉換行為 
a.操作定義 
b.屬性定義 
 
表 3 Connection Server BDD Profile 內容 
Profile Content 
區塊名稱 Connection Server 
區塊編號 1 
描述 
提供連線給 RMC，並且接受 client 端的指令，經過指令分析之
後提供相對應的服務。 
 
+waitForConnection()
+parseCommand()
+sigchld_handler()
+get_in_addr()
connectionServer
 
圖 13 Connection Server Block Definition Diagram 
 
在分析狀態圖以及子系統內每個元件所屬的區塊，瞭解子系統內一群物件的互動情形之後，分
析師將完整的區塊定義圖繪製出來，分析師在 CIM 階段取得系統環境以及初步的需求內容，
經過分析之後，於 PIM 階段將系統內部細節結構化並且產出 SysML 圖形，經過擷取系統的靜
態以及動態需求的過程，就能得到繪制出完整的 SysML需求圖所需要的需求資訊，而分析與
整合這些需求資訊之後所得到的需求圖，是經由原始的使用者需求不斷的被延伸(derive)、細
分(refine)、滿足(Satisfy)、 驗證(verify)、追蹤(trace)之後，方能完成一個表現出需求之間關連
性的 SysML需求圖。 
 
4. 需求追蹤 
需求圖的追蹤(Traceability)是系統設計中很重要的一部分。在需求工程中，需求追蹤
是極具重要性的一環，在某些需求改變之後，必須經由需求追蹤以便找出需求與需求
我們利用 OCL來規範使用者在輸入 Profile時的敘述方式，這樣可以藉由驗證使用
者所輸入的需求內容是否符合該欄位所制定的 OCL條件，避免使用者輸入不當的數
據或是需求文件內容，如表 6是我們應用 OCL做出條件限制的範例之一。 
表 6 OCL條件限制 
樣版 
內容 
資料 
型態 
條件 
限制 
OCL定義 
客戶端
數目 
整數 
數值不
得小於
1 
Self.CleintNum>0 
 
6. 重用需求資料庫 
同時，我們運用重用資料庫(Reuse Library)進行需求重用，以便有效率地需求重用
及引導使用者建構需求。考慮到嵌入式開發專案多種開發特性，像客制化、領域差
異性高、開發時程緊湊等等，我們的需求庫存放所有開發中或已開發的重用嵌入式
軟體需求資料，針對硬體規格差異性小、使用者需求相近、系列產品去進行需求重
用，以利於縮短開發週期，進一步降低開發成本。 
系統設計架構如下圖 15，此以物件導向概念開發的重用資料庫系統將產生不同類型
的文件，分別代表了各自的意義，以下分別說明。這些文件會經由本系統檢查是否
符合格式，進而經由 XML Generator 產生 XML文件記錄相關資訊，最後將元件與
XML文件一起存入資料庫中，將來檢索元件時也依據這些 XML記錄資訊來進行條
件檢索。 
 
圖 15需求重用資料庫系統架構 
 
本研究依據上述的系統概念，將文件分為幾個部份： 
Classification(分類)：此部分主要依產品類別為基礎由使用者在設計需求介面決定分
類，需求依照所選取的參考進行分類。 
Relationship(關聯性)：內部可能包含一個至數個需求，讓使用者能夠經由此需求所屬
之介面，進而瞭解此需求之間的來源與關聯，在本系統藉由此介面增加需求之間之關
聯性，並且能夠記錄良好定義需求的方式。 
傳輸速率 10 frame/s 
客戶端數量 10個 
 
我們採用「需求模板(Requirement Template)」(如圖 17)來協助使用者思考所需要
的各類需求。此模板是基於功能及操作面去制定的，並透過系統內部的資料結構
來補足必要的硬體資訊或參數資訊。 
«metaclass» 
UML4SysML::Class
+internetConnection : string
+systemConnection : string
+fileStoring : string
+fileDownloading : string
+fileEncoding_Decoding : string
+dataRTtransfering : string
+userRecognition : string
+pwUserManagement : string
+fileInfoDisplay : string
+cpuInfoDisplay : string
+memInfoDisplay : string
+powerInfoDisplay : string
+platformInfoDisplay : string
+taskScheduling : string
+taskTimeLimiting : string
+functionAtomDefinition : string
+preCondtionDefinition : string
+postCondtionDefinition : string
+mathFunctionExecution : string
+codeOutput : string
+chartOutput : string
+performanceReq : object
+testReq : object
+acceptanceReq : object
+safetyReq : object
+reliabilityReq : object
+maintainanceReq : object
<<stereo type>> 
reqUserTemplate
 
圖 17 需求模板 
 
以下是VMC-REM系統操作畫面截圖。首先使用者透過圖 18畫面，將訪談到的
使用者需求，輸入到VMC-REM。 
 
圖 21 需求刪除管理 
 
 
使用者可透過VMC-REM，將以系統需求產生對應的需求追蹤矩陣(圖18)。 
 
圖 22 產生需求追蹤矩陣 
 
使用者可亦在矩陣介面上勾選，建立新關聯(圖 23) 
 
 
圖 26產生 SysML需求圖模型 
 
圖 27對應產生 SysML 需求圖 
 
使用者也可以產生輸入測試需求接受條件，提供給子計畫七產生自動測試使用
(圖 28)。 
 
圖 28測試需求產生 
 
 
圖 29 測試需求接受條件輸出 
2011，目前此工具已被三星電子應用於部分電子與數位媒體產品測試)，與本計畫的
SysML-based 需求塑模環境整合，達成自動化測試目標。 
 
II. VMC-MUM：支援多核心嵌入式軟體設計之多重觀點整合模型與可再用元件庫 
A. 研究目的 
軟體的生命週期一般而言包含了需求、設計、實作、測試及維護五個階段，在這些階段
裡可以利用許多的軟體標準以降低軟體開發本身的複雜度。然而當我們使用某個標準於
某階段時所造成的改變，可能會帶來其他階段所使用的標準也連帶的需要作改變的問題。
在整個軟體開發週期裡，開發團隊裡的成員會根據特殊的需求或個人的經驗法則導入不
同的軟體標準。但是所引發的結果卻是標準與標準之間的不相容(Incompatibility)，這樣
的結果往往會帶來許多問題，若使用的軟體輔助開發系統工具互相整合有難處，彼此間
無協調整合機制，所帶來的不確定因素讓開發者之發展環境持續在改變而使其無所適從，
軟體開發方法、軟體開發流程與軟體輔助開發工具無法相互整合，以致於不能發揮整體
功效。軟體的開發與維護相當的不易，也因此至目前為止已有許多的組織及相關領域的
專家制定並提出了軟體標準，其目的就是提昇軟體的品質。但沒有一種軟體標準及模型
可以涵蓋軟體開發過程中的每個階段，因此我們必須要開發一套專屬於嵌入式系統的軟
體工程方法來處理上述可能發生的問題。 
綜觀目前整個嵌入式系統軟體設計方面各個階段之間的關係，在整合技術方面並無一套
標準步驟以及應用的工具，會在開發的過程中將會產生許多不必要的成本，就有可能導
致產出功能與原始需求不盡相同的產品仍勉強上架。並且也須考慮到跨各階段間的連續
性與一致性，往往以人工方式檢視並協調整合來自不同的標準、方法及應用及工具之來
源資料，更因為開發經驗難以學習累積，使得嵌入式系統開發的成本居高不下且品質浮
動。並且，不同設計之間的統合、細部分工等作業程式，使得嵌入式系統開發與研究者
無法以一個一致性、協同性的開發方式進行軟體系統的開發作業。此外因為系統會因不
同硬體、不同 OS、不同平台而有所變化，功能亦因價格、硬體資源問題有所增減及不
同，而使得整個軟體開發及維護困難重重。 
不好的開發流程，已經被認定為是造成成本浪費及進度落後的主要原因，在任何新的專
案的生命週期裡，最重要的一個部份就是要整合系統各階段之不同的標準，因此我們提
出的 Unified and Integration Model，運用先前在 XML為基礎的軟體標準整合模型研究
的成果，定義一個以模型為基礎之 XML系統文件描述模型，稱之為 XML-Based Unified 
Model Metamodel 來描述，將相關的資訊表示成元件(Components)、關連(Associations)
垂直一致性(Vertical Consistency)：又稱交互模型(Inter-Model)一致性，指在不同的抽
象層級中，不同的模型應該保持一致性。在軟體開發的程序中，當規格被轉換到更
細部的規格時，一致性應要能被確保，隨著軟體程序這樣的動作會不斷的重複。 
水平一致性(Horizontal Consistency)：又稱內部模型(Intra-Model)一致性，意指在相
同抽象層級中不同的模型間應該保持一致性，例如類別圖、循序圖以及狀態圖彼此
之間應該保持一致。 
演化一致性(Evolution Consistency)：驗證不同版本的相同模型應保持一致性。 
語意的一致性(Semantic Consistency)：在 UML的Metamodel 中，語意的意義應該
被驗證。 
語法的一致性(Syntactic Consistency)：在 UML的Metamodel 中，UML模型的規格
應該被驗證。 
在本計畫中，我們利用 XUM 的理論，達到 UML垂直與水平的一致性，整合使用案
例圖(Use Case Diagram)、類別圖(Class Diagram)、狀態圖(State Machine)、循序圖
(Sequence Diagram)等模型，這四種圖型最被常用來描述系統的不同觀點，因此優先
被探討。 
2. 整合模型 XUM 
UML可以描述系統不同面向的靜態與動態觀點，但本身並未定義彼此之間的關聯，
在過往的研究當中探討了不同的 UML模型間的關聯性，可以歸納如圖 31，系統的
描述由使用案例開始，表明了系統的功能面向和使用者與其之關係，再更進一步的
細化設計則利用類別圖顯示系統的靜態觀點，當某個類別圖的邏輯過於複雜時，狀
態的轉移可能分散在不同的使用案例中，則由狀態圖針對事件以及狀態做統一的描
述，而循序圖分別可以描述使用案例以及類別圖的動態觀點，以進行驗證，最後這
些模型會產生明確的程式碼去實作。 
 
 當我們從上述的兩種標準獲取相關的資訊時，即可將需要的資訊寫入至整合模型之
中，是 XUM 整合模型中類別圖的定義，分別從 XMI的檔案中取得類別的 ID、名稱
以及來源的檔案，並寫入指定的屬性，從圖形交換格式取得此類別所屬的圖形名稱，
另外定義三種不同的鏈結記錄與其他 UML的關聯性。 
在每一種模型的表示下，定義了整合關係(Unification Link)，整合關係是用以整合各階段相關產出物的機制。其
中包含了抽象鏈結(Abstraction Link)、整合鏈結(Integration Link)與程式碼鏈結(Source Code Link)，如 
 
圖 34定義了抽象鏈結，包含了幾個屬性，分別是此鏈結的 ID、來源的圖形名稱以
及類型、指向的圖形名稱以及類型、此鏈結的建立是否由使用者所決定和此鏈結建
立的時間。 
 
 
 
 
 
 
 
 
圖 34抽象鏈結的定義 
. 
抽象鏈結是用來串聯較抽象的軟體需求與較具體的軟體設計，軟體的生命週期中，
在需求分析的階段，會利用使用案例圖獲取系統的需求，描述不同的系統功能面向
或是目標，明確的指出系統該做的事情，而不是如何去做，並從較高的層級來觀看
整個系統，這些被識別出的功能會在設計的階段，使用多個類別圖描述系統構成的
物件以及其間的關係，再細化成循序圖與狀態圖描述動態的結構和事件，如圖 35
顯示使用案例圖與類別圖之間的關聯，兩種圖形分別位於不同的系統抽象層級，其
中使用案例的描述，可能會被定義成類別的名稱或是透過特定類別內的方法去實現，
透過抽象鏈結，將這些位於不同系統抽象層級的資訊進行整合，以達到垂直一致性。 
 
 
 
 
 
 
 
  
 
 
 
 
 
圖 37整合鏈結的示意 
 
程式碼鏈結則是用來串聯設計模型資訊中的類別與實作的程式碼，如圖 38是其定
義，主要包含此鏈結的 ID、來源的類別圖到指向的程式碼、此鏈結的建立是否由使
用者所決定和此鏈結建立的時間，圖 39顯示由程式碼擷取出的資訊，類別與程式
碼之間，從名稱、變數到方法，彼此之間應該有著一對一的關係，任何一邊都不可
以只有單獨的定義出現。 
 
 
 
 
 
 
 
 
圖 38程式碼鏈結的定義 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Camera 0.11 
HuffStatistics 0.07 
 
4. 可再用元件庫 
針對各相關功能進行模組化之關聯性探討、模組分析與設計、整合分析、原型發展
後，設計一套具轉換性質的平台。 
我們設定的再使用元件庫為一 XML資料庫，其中的再使用軟體元件(Reusable 
Components，RC)，是蒐集程式的知識並產生原始述語(Primitive Predicate)，我們用
來替 Reusable Components 建立正規化的知識，使其成為正規化軟體元件(FRC)及定
義相關之推理規則，並將程式 Artifacts 及 FRC 存入相對的 Reuse Component Library
中，藉由搜尋樹產生 Artifacts，正規化之再使用元件(Formal Reusable Components, 
FRC)，然後儲存至再使用程式庫中，並以一有效率的元件存取機具(Library Retrieving 
Tool, LRT)，提供後續擷取所需。 
此系統另外其中包含了二個組件： 
a. 再使用程式庫和資料庫擷取協尋工具(Reuse Library and Library Retrieving Tool，
LRT) 
使用元件程式庫(Reuse Library)是用來存放處理中或處理後的再使用元件。 
我們透過 OO觀念，配合 XML資料庫使用 QUERY語法索引，目標是呈現一套
使用者透明化、低維護需求、組織良好之軟體再使用元件高效能資料庫與資料管
理系統。可提供使用者與系統工具間對軟體再使用元件之增減修改等等操作，可
作為讓各階段各工具存取資訊之中間儲放所。 
資料庫擷取協尋工具(LRT)，它的作用在於提供一套正規化的元件擷取
(Retrieving)協助方式，經由述語編碼的量化資訊，將使用者所需要的元件搜尋出
來。 
 
b. 元件再利用編輯器(Reusable Component Editor，RCE) 
此編輯器可列出元件及它們間的相互關係，從 XML資料庫中抓出所需的項目列
表， 
可以幫助我們達到元件再利用性及各階段之模型鏈結以達到模型之一致性。除了
可檢視元件關係外，使用者也可以在編輯器中進行修改元件相互關系，並再儲存
進元件程式庫中。 
5. 系統實作 
  
 
 
 
 
 
 
 
 
 
 
 
 
圖 41系統活動圖 
 
本系統的流程如圖 41活動圖所示，使用者必須先在 Papyrus的專案下，建立一個副
檔名為 XUM 的檔案，接著按下檢查的按鈕，系統會抓取專案下所有.uml 與.di2 的檔
案，並儲存至資料庫內，接著將 UML的模型與 XUM 的整合模型進行比對，將相關
的資訊寫入 XUM 檔案中，最後顯示給使用者。 
以下是 VMC-MUM 系統操作畫面截圖。首先使用者可以透過本系統之新增檔案的
Wizard，加入 XUM 的檔案，如圖 42所示。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 在模型分析完成後，編輯器會自動更新資料，如圖 44所示，左邊的樹狀結構顯示
所有的 UML項目，點擊其中任一項目，在右邊的上方表格顯示與此名稱一致之項
目，右邊的下方表格，則是利用相似度比對，找出可能潛在結果，使用者可以在右
下方的表格，透過勾選 Checkbox 進行確認。另外，考量到使用者可能需要進行手動
變更的需求，使用者也可以透過 Add的按鈕自行手動加入相關連性的項目，透過
Remove的按鈕將不相關的項目移除，如圖 45所示。 
 
 
 
圖 44模型的關聯 
 
 
圖 45手動修改關聯 
 
系統分析模型的過程中，所發生的事件會自動的記錄下來，如圖 46所示，由 Link 
Event 的 View去顯示。使用者可以搜尋或是排序特定的欄位，來獲取不同的訊息，
圖 47 搜尋特定 Link Event 欄位 
 
圖 48則顯示了使用者針對 UML模型修改的紀錄，這樣的紀錄有助於使用者了解前
後版本的差異。 
 
 
 
 
 
 
 
圖 48Maintenance Log View 
 
 
C. 結論 
在本計畫中，我們建立的多重觀點整合模型與可利用元件庫，分析 XMI以
及圖形交換格式，將所需的資訊擷取並儲存到 XUM的模型，建立垂直與
水平的一致性確認機制，針對不同的抽象層級，使用不同的鏈結型態進行
串連，並且在分析的過程中，不同事件的發生都會被記錄下來，使得系統
開發人員能發現系統開發過程中潛在的錯誤，達到軟體的追溯性，利用
MODEL 的特性將軟體的知識加以儲存利用，使得組織在開發專案時，能
規格化設計（PSM Design），並利用多核心的平行觀察框架延伸設計系統，使得開
發出來的系統能夠更容易被監控其平行化的效率。 
樣式（Pattern）規格設計 
如圖 50所示，從結構面來看一個樣式規格包含了三個元素，分別是： 
 
圖 49研究方法的應用流程 
 
 
圖 50 樣式規格化MDA設計架構 
 
 超模型（Meta-model）：在樣式的超模型階層中，我們定義樣式中所有的角色
及屬性，根據樣式的結構訂定刻板 (Stereotype)以及標籤值 (Tagged Value)，並
  
 
 
 
圖 51 樣式模型轉換方法 
 
 
圖 52引用設計樣板方法 
 
3. 樣式應用後之驗證 
在樣式被應用到設計之後，開發者會針對需求修改其設計，如此將可能會產生不符
合原本應用該樣式目的的變更。所以我們在樣式規格化時，根據樣式的目的與限制，
利用 OCL撰寫樣式的規則，以確保樣式在被應用之後還能保有其應用之功能。OCL
是一種敘述性的查詢語言，它可以被定義在超模型層 (M1 level)或模型層 (M2 level)
上，而我們選擇將樣式的規則定義在 M1層是著眼於它的可重用性，只要 M2層的
元素套用了M1層的刻板，便能夠利用 M1層的 OCL描述來限制M2層的規則，如
此一來使用者在設計時便不需要重複定義 M2 層的 OCL描述，只要依靠事先描述好
的M1層 OCL敘述，便能夠達到驗證的目的。圖 53 描述了一個樣式驗證的架構。 
a. 樣式與樣板規格化 
樣式規格化 
步驟 1：定義超模型 
圖 55描繪了一個 TBB 管線樣式平台獨立設計的超模型，由於 TBB 管線樣式平
台獨立設計主要是由 Client 及 Delegate等類別所組成，所以其超模型將會包含
Client 及 Delegate 等角色，其中 Client 的 Operation 會將工作委派給 Delegate的
SubOperation 去執行，類似管線中不同的工作階段。而表 9則表示了這個超模型
的參與角色以及擴展了那些 UML超模型。 
圖 56則描繪了一個 TBB管線樣式平台規格化設計的超模型，而表 9表示了這
個超模型的參與角色以及擴展了那些 UML超模型。我們可以看到 TBB管線樣
式平台規格化設計主要由 Client、tbb:pipeline 及 tbb:filter等類別所組成。值得一
提的是在 TBB管線中，呼叫 run函式必須傳入一個 max_number_of_live_tokens
的整數參數，用以限制所有工作階段中能夠處理的工作內容總和，因此，在 run
這個刻板中將會有一個標籤值來表示這個參數。另外，每個 filter刻板也會有一
個 order的標籤值來識別工作階段的先後順序。 
 
圖 55 TBB管線樣式平台獨立設計的超模型（TBB-Pipeline PIM meta-model） 
 
 
 
 
 
 
 
 
 
 
並且設定其對應的標籤值。圖 57使用 ATL程式碼描述了 serialDelegate 的部分
轉換規則。 
步驟 3：定義驗證規則 
針對 TBB管線樣式的特徵，本節列舉幾個該樣式的平台規格化設計所要遵守的
規則： 
 在 TBB管線中的每個工作階段都必須繼承 filter類別。 
 在一個 TBB管線中，工作內容的總數必須大於等於工作階段的數量。 
 工作內容的順序編號不能重複。 
對應以上三條規則，圖 58使用 OCL語法來描述 TBB管線樣式平台規格化設計
的限制規則。 
 
表 10 TBB管線樣式平台規格化設計的參與者資訊 
UML meta-model Stereotype Tagged-value Description 
Class client  管線樣式中的使用者端。 
tbb::pipeline  定義 TBB 管線的角色。 
tbb::filter  定義 TBB 工作階段的角色。 
ConcreteFilter filter_order: int 
filter_mode: 
mode 
定義具體工作階段的角色，其中
filter_order 定義了該工作階段的運作
順序，而 filter_mode則定義了該工作階
段的運作模式是平行或是線性的。 
Generalization ConcreteFilter
ExtendFilter 
 具體工作階段繼承 TBB 工作階段的一
般化關係。 
Association InstantiateFilt
er 
 由 TBB管線使用到 TBB工作階段的關
係。 
Operation run max_number_of
_live_tokens: int 
TBB 管線執行管線任務的操作，其中
max_number_of_live_tokens定義了所有
工作階段中能容納的工作內容總和。 
clear  TBB 管線清除所有管線任務的操作。 
add_filter  TBB 管線加入新的管線任務的操作 
FilterConstruc
tor 
 工作階段的建構子操作。 
operator  工作階段所執行的工作內容操作。 
 
表 11 TBB管線樣式角色對應關係 
 來源模型參與者 標籤值 目標模型參與者 標籤值 
參
與
者 
client  client  
tbb:pipeline  
 add_filter  
 run max_number_of_live_tokens: int 
 clear  
tbb:filter  
serialDelegate order: int ConcreteFilter filter_order: int 
filter_mode: mode (=serial_in_order) 
parallelDelegate order: int ConcreteFilter filter_order: int 
filter_mode: mode (=parallel) 
 
我們在樣板規格化的最後一個步驟將會根據先前所定義好的超模型產生相對應
的模型，並且儲存起來作為樣式樣板使用。圖 59則是套用了 TBB管線樣式平
台規格化設計超模型的模型。 
 
 
圖 59套用 TBB管線樣式平台規格化設計的模型 (TBB-Pipeline PSM model) 
 
 
b. 樣式與樣板套用 
圖 12描繪了套用 TBB 管線樣式平台獨立設計的模型結構範例，經由執行樣式
模型轉換後將會產生圖 61描繪的模型結構。如果來源模型越複雜則越能夠顯現
出樣式模型轉換的優點，因為有越多的來源參與者實體則能夠轉換出相對應數量
的目標參與者實體。 
 
 
 
 
 
 圖 62 多核心軟體設計支援系統架構圖 
 
 
圖 63 多核心軟體設計支援系統運作流程圖 
 
在本研究中介紹了一個模型驅動及樣式支援的方法用以幫助多核心軟體設計，我們對樣
式進行抽象化，藉由以樣式為基礎的轉換方法，讓開發者達成快速開發的目的。藉由此
方法減低人為錯誤的引發機會又可讓設計維持一定的品質。而這些抽象化後的樣式資訊
與轉換規格儲存在樣式儲存庫後，在之後的開發專案中可被重複使用，可重用性大幅提
昇。 
在支援系統實作的部分，我們提供了一個無縫的設計環境來支援多核心軟體的開發，透
過本系統可以降低開發人員設計多核心軟體的門檻，並且增加應用樣式的機會以提升軟
體的品質。我們同時也說明了樣式的規格化流程，以增加日後系統的可擴充性，本研究
也設計了多個多核心相關樣式供開發人員使用，藉由超模型層級定義轉換規則並進行自
動化的轉換或是直接引用設計樣板的方式，使得這些規則可以不斷的被重複使用。 
XML Schema
Semantics 
Tree
Model 
Parser
Model 
Compiler
QP-
Annotated 
Tree
Parallelism 
Implementer
Tree 
Translator
Parallelized 
C++ Code
QP Information 
Files
TBB Information 
Files
Parallel Design Pattern
Parallel Data Model
Pipeline Data Model
…
Class Diagrams
TBB-
Annotated 
Tree
Monitor 
Generator
Block definition 
Diagrams
State machine 
Diagrams
State machine 
Diagrams
Requirement 
Diagrams
Monitor-
Annotated 
Tree
Monitor Model
 
圖 64程式碼生成器流程 
 
    Model Compiler (MC)，是將使用者設計的 state machine diagrams 和描述系統功能的
class diagrams 翻譯成以 QP 程式架構的樹狀資料結構。每一個 state machine 在 QP 裡分
別用一個 Active Object (AO)實現。為了要把 semantics tree翻譯成帶有 QP的程式架構，
就需要 QP Information Files 的資訊，如此一來才能便於程式碼的自動生成。例如：使用
者設計了一個 state machine，由 QP Information Files 得知把 state machine對應成 AO，
就實作來講，即為把此 state machine宣告成 C++ Class，並繼承 QActive。 
  MC 的流程主要可分為以下三個部份：Tree Traverser、QP Transformer以及
QP-Annotated Tree Generator。圖 66為MC 的架構圖。 
  MC 走訪MP 所建的 semantics tree上的每個節點，之後由 QP Transformer根據每個
節點的資訊來轉換出所相對應的 QP 程式碼。例如：遇到一個 state machine 的節點，就
可以產生 QP Initialization 的程式碼來初始化 AO和 AO所需要用到的訊號；遇到 state 
machine上的 state，就根據 QP Information Files 來產生相對應的 QP 程式碼；遇到 state 
machine上的 transition，則是將 transition 上的 event 條件和 actions 依據 class diagram 所
描述的功能，一併轉換成 QP 程式碼。 
  最後，每個節點透過 QPc Transformer所轉換出來的 QP 程式碼，由 QP-Annotated 
Tree Generator 嵌入到 semantics tree上，即為 MC 的輸出：QP-Annotated Tree。 
  Parallel Implementer (PI)主要功能為將系統設計時指定的平行模型(Parallel Model)，
以 TBB為應用介面，生成相對應的平行演算法程式碼。我們主要針對 Data flow 
parallelism 來設計平行程式碼之生成。 
  圖 67為 PI的設計架構圖，主要包含三個部分：QP-Annotated Tree Traverser、Parallel 
Model Translator、TBB-Annotated Tree Generator。PI將會接收從上層 MC 而來的
QP-Annotated Tree以及外部加入的 TBB Information Files，其中 TBB Information Files
包含使用者描述的 parallel model 用來產生 TBB parallel code，最後 PI產生出
TBB-Annotated Tree供下層的 Monitor Generator (MG)使用。 
Monitor Generator (MG)，將會接收從上層 Parallelism Implementer(PI)而來的
TBB-Annotated Tree以及外部加入的QP Information Files、Monitor Model和 Requirement 
Diagrams。其中 Requirement Diagrams 包含使用者描述要 monitor的資訊。主要的功能
是要產生一個程式執行時期可以對 resource做觀測的 Monitor active object，從使用者描
述的 Requirement Diagrams了解要monitor的 resource，依照Monitor Model來將 resource
和Monitor做對應並將程式碼加入 TBB-Annotated Tree內，最後輸出 Monitor-Annotated 
Tree。 
我們仍然使用 Quantum Platform (QP)來實作Monitor，也就是說，Monitor也會是一個系
統中的一個 AO。這樣一來，Monitor和系統中原有的 AOs 在溝通上可以沿用 QP 提供
的溝通機制，使得各 AOs 和Monitor之間的互動 API較為方便設計與整合。 
MG包含了三個部分：TBB-Annotated Tree Traverser、Monitor Model Translator 和
Monitor-Annotated Tree Generator。圖 68為MG的架構圖。 
 
 
Parallelism 
Implementer
(1.2.0)
TBB-Annotated 
Tree Traverser
(1.3.1)
Monitor Model 
Translator
(1.3.2)
Monitor-Annotated 
Tree Generator
(1.3.3)
Tree Translator
(1.4.0)
QP Information 
Files
Monitor 
Generator
(1.3.0)
External 
Interface
External 
Interface
Internal 
Interface
Internal 
Interface
External 
Interface Monitor Model
Requirement 
Diagrams
 
圖 68  MG架構圖 
 
 圖 70 PVEEncoding的 Block Definition Diagram 
 
 
 
 
圖 71  PVEEncoding 的 State Machine Diagram 
 
有了使用者定義的 PVEEncoding的 block definition diagram和 state machine diagram後，
Model Parser可產生 PVEEncoding的 semantics tree。MC 從 semantics tree中獲得關於
PVEEncoding model 的相關資訊，在走訪每節點時，會根據 QP Information Files 貼上相
對應的程式碼，例如：當遇到 state machine的標籤時，會在此節點貼上 Active Object
的相關程式碼，因為 QP 裡的每個 state machine都是一個 AO，就物件導向程式語言的
角度來說(以 CPP 為例)，就是讓 PVEEncoding 物件來繼承叫作 QActive的物件；而在
state machine裡的每個 state，在 QP 裡都是 PVEEncoding物件的 member function。圖 72
和圖 73為MC 所產生的 header file和 cpp files。 
以 PVEEncoding的 state machine 為例(如圖 71所示)，transition 上有叫作<<pipeline>>
的 stereotype，PI會參考 pipeline的 parallel model 來產生相對應的 TBB code。圖 74是
pipeline的 parallel model。 
 圖 74 Pipeline的 Parallel Model 
 
 
 
基於多核心嵌入式系統之動態可適性效能監視機制(Adaptive Performance Monitoring for 
Multicore Embedded Systems) 
由於多核心處理器的蓬勃發展，軟體在運行的效能上，已經又被推向更高的一個層級，
多核心處理器已經漸漸普及，不像以往僅有高階的伺服器會使用，一般家用的桌上型電
腦也已經能夠輕易發現多核心處理器的存在，近年來在嵌入式平台上，更有許多多核心
處理器的發表與採用，例如 Nvidia Tegra、Qualcomm Snapdragon 等。因應多核心處理
器的發展，在軟體設計上，也必須發展出新的演算法，才能夠有效的發揮出多核心處理
器的效能，但是這是一個非常困難的問題，因為許多常見的效能瓶頸問題，例如 Resource 
sharing problems、Unbalanced workload、Power consumption 等瓶頸，在多核心平台上發
生時，會嚴重的影響到軟體的執行效能，但是這些問題有往往不容易被發現，因此我們
發展出一套基於多核心嵌入式系統之動態可適性效能監視機制，希望藉此來輔助程式設
計人員可以能夠輕易地發現軟體效能的瓶頸，進而做適當的修正來取得最大效能，充分
發揮多核心平台的運算能力。 
由於系統僅需額外執行一個執行緒，因此對於系統的額外運算負擔(Computation 
Overhead)很低，但是卻會引起額外的資料溝通負擔(Communication Overhead)，並且當
使用者監視的資訊越多時，可能導致監控執行緒工作過於忙碌，導致正確性與即時性下
降，而取得無效的資訊。 
 
圖 77四種監控執行緒分配情境 
 
 
 
在本實驗當中，分別設計了四種工作分配情境，如圖 77所示，其中 T 代表工作執行緒，
M 代表監控執行緒，而工作執行緒根據兩種不同工作內容，可分為受裝置存取限制工
作(IO-bound task)與受運算能力限制工作(CPU-bound task)。本實驗監控執行緒將在不同
的時間區隔，分別為 10000us,1000us,100us,10us,1us，不斷的監測工作執行續的工作狀
況，取得已完成的運算數量資訊。本次實驗分別運行於兩個實驗平台，第一個平台為 Intel 
Core2 Duo SU7300, 4GB DDR3 SDRAM, Linux 2.6.35，第二個平台為 ARM 11 MPCore, 
512MB SDRAM, embedded Linux 2.6.35，本實驗都是使用 GNU gcc 4.4.5 編譯器，並且
關閉所有編譯器最佳化功能。 
 
 圖 79不同的監測時間區隔所取得之資訊 
 
在這篇論文當中，我們提出了一套基於多核心嵌入式系統之動態可適性效能監視機制，
希望藉由此一機制來輔助程式設計人員，能更輕易地發現軟體效能的瓶頸，做出適當的
修正來取得最大效能，充分發揮多核心平台的運算能力。在實驗中，我們針對監控執行
緒的分配方式提出了分析，並且對於監控執行緒數量與分配方式做出了建議，並且發現
在監測之資訊正確性與即時性之間的取捨，必須適當的設定監測時間區隔，才能夠獲得
最準確的資訊。 
 
以多核心系統偵測與追蹤籃球比賽視訊串流中的球 (A Multicore System Design for Basketball 
Detection and Tracking in Sports Competition Video Streaming) 
由於籃球為熱門球類之一，且籃球比賽包含了動機之所有部分，因此我們將目標球類設
定為籃球。而系統首要目的為正確追蹤籃球位置，唯有達到此目的才能實踐其餘目標。
同時系統也將使用多核心之分散處理達到即時運算，得以跟上比賽節奏。另外，為了達
到減少漏網鏡頭的目的，系統從兩方位錄製比賽，並自動切換攝影畫面。 
圖 80為自動化球類即時追蹤系統之架構。架構中包含四個主要功能:球場邊線偵測、籃
球位置偵測、籃球追蹤及影像切換。系統中，我們匯入 OpenCV 進行影像處理。 
 
 
 
 
於菱形中心時，系統會將搜尋範圍從LDSP縮小為SDSP(Small Diamond Search Pattern)，
並重複執行 Step1，進行精準定位。而此步驟求得之 MBD即為籃球之最後所在之範圍。
我們認定此次MBD中權重最高之集合為籃球，計算平均座標並在影像中圈出。如果在
Step3仍無法獲得籃球確切座標，經過三個影像之容忍期後，跳回 Ball Detection 重新定
位籃球。圖 81 表示可以看到 MBD 在角落或邊上時，演算法繼續以 LDSP(藍色圓形)
為搜尋範圍，當MBD 在菱形中心時，將縮小為 SDSP(綠色正方)搜尋。 
View Exchanging: 
當近景影像偵測到籃球時，將影像輸出切換為近景；當近景影像連續無法偵測到籃球時，
將影像輸出切為遠景。 
 
圖 81 Diamond search algorithm(DSA)示意圖 
 
 
圖 82 Task Parallelism 示意圖 
 由圖 84觀察得到的結果來分析，發現利用 TBB Pipeline所得到的結果是減少了原本執
行時間的 59.22%。 
 
C. 結論 
三年計畫的第一年主要是以 bottom-up為設計主軸，來設計數位影像串流(DVR)系統，
並從中獲得更多關於多核心嵌入式軟體的發展經驗與議題;第二年計畫的目標著重於多
核心程式碼生成器的設計流程並支援更完整的平行模型(Parallel Model)提供系統更多平
行化程式碼生成的能力;第三年則重點放在加入 Monitoring Mechanism 來監控系統資源
(Resource)與執行效能(QoS)，以期符合使用者給定的需求(User-specific Requirements)。
我們也透過介面的制定說明與其他子計畫之間資訊的交換及所需的功能性互動，達到從
上層 model，程式碼生成後到多核心目標平台上執行的完整性。 
我們已經透過 DVR 系統這個例子和二大仲介軟體 QP、TBB Libraries，實作出自動化平
行程式碼生成器，並也已發展出一套完整的自動化流程。 
目前的成果有兩大技術優越性，其一是使用 Model-driven的開發流程，特點是可以重複
使用且容易作系統驗證，另一是多核心程式碼的開發，目前多核心系統愈來愈普遍，能
自動產生多核心平行化程式碼勢必是一大優勢。目前成果可以提供業界一套多核心嵌入
式系統的自動化平行程式碼生成流程，也可以提供學界一套在多核心嵌入式系統上的
Model-driven開發流程，例如可以用在嵌入式軟體工程的課程教材上。 
三年計畫已告一個段落，當初我們規劃的目標已大部分實現，我們接下來會繼續延伸
Monitoring Mechanism 的研究，朝著動態 monitoring並依使用者需求作系統效能調校的
方向努力，之後也會繼續往異質多核心系統作研究。 
 
V. VMC-AM: 架構及效能調校支援實作 
A. 研究目的 
本子計劃五(Subproject 5)主要著重於架構對應及整合後工具組之實際應用，首要之目標
為將子計劃一與三產生之嵌入式多核心軟體規格，在經由子計劃四之 thread-mapping、
thread-scheduling和正式的驗證以後，實作一自動淬取及合成核心(extraction and mapping 
kernel)。子計畫五之目標為設計一多執行緒分析模組(multi-thread analysis module)以針
對合成多核心嵌入式程式碼時，解決多執行緒與多核心分配對應之問題。目地在提昇多
核心嵌入式程式碼之效能及避免 Racing及 deadlock現象。此階段將利用 Intel 之所提供
與彼此之間的詳細規劃情形，我們將在以下的章節中逐一說明。首先對不使用 GPS 之
相機定位法如直接線性轉換及光流演算法進行說明。 
 
第二階段不使用 GPS 情況下，產生定位相機外參數，以做為輸入之持續拍攝視訊（ｖ
ｉｄｅｏ ｓｅｑｕｅｎｃｅ）疊合第一階段所產生的粗體模型。本研究的特色在於環
物影像的拍攝並不需要精密的相機定位儀器，拍攝方位可以不預知，利用光流原理計算
每張影相與類近影相的相素位移。經與粗體模型的對應即可求得相機的內，外方位，進
而計算３Ｄ網格之線性投影。至於上述各階段內部與彼此之間的詳細規劃情形，我們將
在以下的章節中逐一說明。以下介紹本階段重要之理論部份:直接線性轉換及。此直接
線性轉換理論在第二階段會使用到。 
DLT 理論簡介:給定 N 對之對應 x,y,z 及 u,v。式(1)可表達如下: 
 
 
 
 
 
上
式為典型之線性系統方程式，可使用最小平方差矩陣計算 L1 到 L11。一旦計算出 L1 到 
L11，x0,y0,z0可由式(2)計算獲得。旋轉矩陣(T)之元素 r11,r12…r33可由式(3)計算獲得。 
(2) 
 





































































1
1
8
4
1
11109
765
321
0
0
0
8
4
0
0
0
11109
765
321
L
L
LLL
LLL
LLL
z
y
x
L
L
z
y
x
LLL
LLL
LLL
 
(3) 
































11109
71106100590
31102100190
333231
232221
131211
/
LLL
d
LLv
d
LLv
d
LLv
d
LLu
d
LLu
d
LLu
D
rrr
rrr
rrr
T
vvv
uuu
OI
 
 
(1) 
























































N
N
NNNNNNNNN
NNNNNNNNN
v
u
v
u
L
L
L
zvyvxvzyx
zuyuxuzyx
zvyvxvzyx
zuyuxuzyx
1
1
11
2
1111111111
111111111
10000
00001
10000
00001

三為對一實體建物特徵點進行光流追蹤結果。由此圖可看出隨著相機之移動，光流計算出
正確的特徵點位移量，並顯示於實體建物之角落點。 
第四工作項目結合 GPS 定位及光流位移，以 DLT 進行相機內外參數計算，最後 3D立體
路標反投影至影像平面。給定第三工作項目產出之特徵點位移量(2D)，再加上處於該物體
之模型頂角之特徵點(3D)，即可以 DLT理論計算出相機之外參數，進而進行 3D路標之反
投影。最後將路標投影至正確的平面位置，圖四為 3D路標加建物模型在各個角度顯示之
結果。圖五為 2D路標與平面影像重疊後之結果，由此圖可知經由光流追蹤計算之結果是
正確的，2D路標可以持續標示於建物附近，而且會隨著相機移動而變動。 
目前對光流計算效率評估是以核心數進行調整，研究對效能及耗電進行比較。結果顯示當
核心數增加時核心數增加時，效能(performance)有獲得提昇，顯示本計劃產出之 Makefile
可正常運作，同時分析結果可幫助提昇效能(performance)，但耗電量確在提昇效能
(performance)之後有所降低。此為下階段研究極待努力克服之議題。 
 
VI. VMC-PPO: 平行程式優化支援實作 
A. 研究目的 
有效的平行迴圈切割與排程可以顯著地減少程式在多核心處理器系統環境中的整體回
應時間，特別是針對具有許多迴圈的應用程式與針對新興的多核心嵌入式系統環境，其
優化處理也更為重要。本子計畫的研究重點主要是設計與實作多核心嵌入式軟體之平行
程式優化支援。在本計畫中，我們實作一套基於 OpenMP 的自動平行化工具，以產生
能運行在多核心系統上之平行程式碼，其中我們使用 ROSE 開放原始碼編譯器為核心，
針對 ROSE 深入探討並實作一個使用者介面以簡化使用之複雜度。本計畫完成一套自動
程式碼平行化整合系統，系統包含如何去判斷該程式是否適合平行化及所需要的背景知
識以及技巧等內容。並介紹如何讓使用者透過我們提供的 GUI圖形使用者介面或是使
用 Eclipse外掛(Plug-In)，透過圖形操作方式，來使程式碼自動平行使得自動平行更加
的容易。在多核心嵌入式系統上如果只運行普通的程式將無法達到應有的效能，所以透
過適當的平行化轉換，會節省許多的時間。本計畫實驗有兩個部分，首先，我們證明了
這些自動平行化的工具可行性與正確性。接著，分別於一般的處理器和嵌入式系統上運
行並討論其效能比較。最後，我們將展示如何應用此工具來使得程式在多核心系統上有
更佳的效能。 
本子計畫主要設計與實作多核心嵌入式軟體之平行程式優化支援。有效的迴圈切割與排
程可以顯著地減少程式在多核心處理器系統環境中的整體回應時間，特別是針對具有許
本子計畫所開發，結合了平行技術與程式碼優化演算法，提供程式碼優化的基本功能和
學習模式。本計畫建置一多核心嵌入式軟體之高效能平行編譯器 (PPO)，載入既有之程
式碼，透過逐行逐段分析，輔以高效能平行演算法，基於 OpenMP 及 Intel Threading 
Building Block多核心函式庫，產出平行程式碼，使其達到多核心同步執行，加速其運
算速度，並達到最大之產出。有鑒於以往程式優化系統的全面性，我們採取了區塊優化，
也就是經過學習模式就每個迴圈區塊做一次優化並記錄下來，以迴圏執行效率做為比較，
去判定運算迴圏是否需要程式優化，因此本系統利用 Intel TBB與 OpenMP 以及 ROSE
來達到程式碼平行與優化的效果。 
 
圖 86 VMC_PPO Architecture 
 
圖 86為本子計畫的系統架構示意圖，Source Code 部分是由子計畫四所產生的程式碼
為 Input 支援 TBB與 OpenMP，中間部分為我們子計畫的核心部分，分別是 PAM、COM
與 CGM。Output 部分是要連接子計畫七並讓其做測試。 
 
 整數線性程式化、相依性抽象化。 
7. Loop transformation 
 線性迴?轉換、迴?的融合/分裂與增加平行化和局部化。 
8. Self-optimizing programs 
根據預先分系的效能記錄自動添加 OpenMP 標籤。 
本系統可區分為四個子部份系統，其個子系統之間的關係如圖 88各子系統關係圖所
示。 
 
Source Program 
Parsing 
Subsystem
Parallelism 
Subsystem
Optimization 
Subsystem
Logging Subsystem
Source 
Code
Output 
Code
 
圖 88各子系統關係圖 
 
以下會各別對每個子系統做詳細敘述，如下： 
1. 程式剖析子系統(Source Program Parsing Subsystem, SPPS) 
SPPS 為 PPO 系統之前端，用以語法剖析系統接受程式碼之後，逐行剖析，找
出所有可平行化之部份，捕捉與程式結構區塊有關之符號，審視程式上下文，判
斷符號與關鍵字之前後配對架構，濾出關鍵符號及框架，最後交付給後端之平行
子系統。圖 89 為 SPPS 子系統架構圖，SPPS 包含下列兩個子部份： 
A. UI：提供使用者操作與設定介面  
B. Parsing：程式碼語意整理 
C. Analysis：程式碼語意分析 
 
 
Analysis：程式碼優化區塊分析  
Modify：處理欲優化程式區塊行為 
 
圖 91 OS 子系統架構圖 
 
4. 紀錄子系統(Logging Subsystem, LS) 
LS  功能為紀錄程式編譯優化過程中，所標記之程式碼行號以及所加入之程式導引
器，並將之輸出以做檢驗或查詢用途。圖 8  LS 子系統架構圖為 LS 子系統架構圖，
本子系統之組成如下： 
A. Markup code log：紀錄程式碼被剖析時的所有 SPPS 行為 
B. Parallel code log：紀錄程式碼在平行化時所有 PS 行為 
C. Optimize code log：紀錄程式碼優化其間 OS 的所有行為 
 
 
圖 92 LS 子系統架構圖 
 
在 LS 中，於編譯程式執行過程中，紀錄程式分析紀錄，包含所標記之行號，新增加
之平行函式導引器及其位置，最後分別輸出  TXT、XML、以及  SQLlite 等格式，供
日後追蹤分析。 
我們利用了 ROSE 計畫中兩大部分 Program Analysis 與 Program Transformation and 
Optimizations中的 Recognizing Loops、Generating Control Flow Graphs、Dataflow Analysis、
 圖 94 Loop Optimizer 執行畫面 
 
我們這支程式利用 Auto Parallel 與 Loop Optimizer，進一步去達到迴?剖析、分析資料相
依性、變數區域性與效能最佳化分析。除了文字命令介面，我們還以 C#實做出使用者
圖形介面，讓使用者可以利用點選的方式去執行與操作。C#介面如圖 95。 
 
 圖 97 Eclipse使用者圖形介面 
 
 
圖 98 平行化通知視窗 
 
如通知視窗所表示，針對第五行及第七行使用自動平行化。 
 
C. 結論 
本計畫完成一套自動程式碼平行化整合系統，系統包含如何去判斷該程式是否適合平行
化及所需要的背景知識以及技巧等內容。並介紹如何讓使用者透過我們提供的 GUI圖
形使用者介面或是使用 Eclipse外掛(Plug-In)，透過圖形操作方式，我們所建立的程式
 使測試工程師容易得知軟體在嵌入式平台上執行的效能。 
5. 以文字及視覺化介面輔助呈現每回合的測試結果。 
 使測試工程師容易理解測試報告。 
 
 
B. 研究成果 
1. 自動化測試方法 
在本章節中，我們將說明本研究實現包含功能性及非功能性自動化測試主要的方法，
在功能性測試中，我們將說明在單元測試中自動產生支援 C/C++複雜資料型態的 test 
data、test case、test driver方法，讓自動化測試能支援複雜的資料型態，並且介紹在
覆蓋率測試中結合自動化多回合測試機制的方法，可減少測試需重覆多次執行的負
擔；最後在非功能性測試中，則說明 TBB平行程式效能量測方法，幫助測試工程師
找出適合 TBB pipeline 平行化所需的參數值。 
a. 自動化單元測試 
在單元測試中，我們將測試程式中每一個 function 是否會發生錯誤，在進行測試
前，必須先產生測試所需的 test data、test case 及 test driver，首先，我們說明如
何自動產生支援C\C++複雜資料型態的 test data，其資料型態包含primitive type、
structure type、object type的 test data，此外也可以產生 array type的 test data，而
產生的 test data 將作為 test case及 test driver的輸入資料，圖 99為自動產生 test 
data的演算法，在演算法中相關名詞說明如下： 
(1) Function-List 
儲存待測程式中所有 function 的資訊，包含名稱、參數型態及回傳型態。 
(2) Object-List 
儲存待測程式中所有 object type的屬性。 
(3) Parameter-List 
儲存所有 function 的參數型態。 
(4) TestInputDataGenerationMainFunction 
擷取待測程式所有 function 的參數型態及回傳值型態。 
(5) TestInputDataGenerator 
產生與 function 參數型態及回傳值型態的 test data。 
 
   演算法執行的步驟： 
入的期望值，圖 100為自動產生 test case的演算法，其演算法中相關名詞說明
如下： 
Function-List 
儲存待測程式中所有 function 的資訊，包含名稱、參數型態及回傳型態。 
Object-List 
儲存待測程式中所有 object type的屬性。 
Parameter-List 
儲存所有 function 的參數型態。 
TestCaseGenerationFunction 
產生與 function 參數型態及回傳值型態的 test data。 
 
演算法執行的步驟： 
Step 1：從 function list中取得 method name、parameter type及 return type。 
Step 2：產生 test case 的 function signature 程式碼。 
Step 3：判斷 parameter type 是否為 primitive type、structure type、object type。 
Step 4：依據 parameter type instrument 一個變數(variable)宣告的程式碼。 
Step 4-1：若 parameter type 為 primitive type，則 instrument 讀取一筆 test data給
此變數的程式碼。 
Step 4-2：若 parameter type 為 object type或 structure type，則取出所有的 primitive 
type attribute，並且 instrument 讓所有 attribute 可讀取 test data的程式碼。 
Step 4-3：若 parameter type 為 array type則計算出所需讀入的 test data 數目，並
產生利用 loop 將所有 test data讀入的程式碼。 
Step 5：判斷此 method的回傳型態(return type) 
Step 5-1：若為 primitive type、structure type、object type則 instrument 讀取 test data
的程式碼、呼叫待測程式 function 的程式碼，及 assertion 的程式碼。assertion 的
程式碼可用來判斷待測程式的 method的回傳值是否符合期望值。 
Step 5-2：判斷此 method的回傳型態(return type)，若為 void 則產生呼叫待測程
式 function 的程式碼。 
Step 5-3：若都不是則產生以 null 代入待測程式 method的程式碼或以人工指定。 
 
 
 
 圖 101 Test case產生範列 
 
最後，我們需再產生 test driver，圖 102 為自動產生的以 cppunit 為基礎的 test 
driver 範例，藉由 test driver可以控制所有 test case執行並擷取測試時待測程式
所發生的錯誤，當測試完成並將測試結果寫入 XML檔案中，但目前對於自動產
生 test data、test case仍有些限制，例如 C/C++的 template型態或是指標。 
 
 
圖 102 Test driver產生範列 
 
 
 圖 103多回合 coverage test 流程 
 
 
圖 104多回合 coverage test 流程 
 
經過我們多次的分析，我們發現量測 token數目對於程式執行時間的分布大都如
圖 106所示，因此我們以五個 token數為單位，計算其平均值，並找出一個建議
的 token數範圍。以圖 107所示，量測的 token數為 1~10，我們取 token數 1~5
執行時間的平均值為 17.6毫秒，token數 2~6執行時間的平均值為 12.4 毫秒，以
此類推，當我們發現下一次的平均值大於目前的平均值(Token No. 4~8 的執行時
間大於 Token No. 3~7 的執行時間)，因此我們建議的 token數為目前取平均數的
範圍，以圖 9 為例，我們所建議的 token數為 3~7。 
 
圖 106 TBB效能量測時間分布範例 
 
 
圖 107 TBB pipeline效能量測方法 
 
2. 系統架構 
本章節我們介紹我們所發展的嵌入式軟體自動化測試環境(ATEMES，automatic 
testing environment for multi-core embedded software)，本系統(ATEMES)主要分成四
個部分，分別為前置處理模組(Pre-processing Module, PRPM)、主機端自動測試模組
(Host-Side Auto Testing Module, HSATM)、目的端自動測試模組(Target-Side Auto 
Testing Module, TSATM)、後置處理模組(Post-processing Module, POPM)，透過這四
a. 前置處理模組 (Pre-Processing Module, PRPM) 
PRPM 為測試的前置處理，首先讀取待測程式，透過 Code Analyzer來剖析(parse)
及切割(tokenize)原始程式碼，擷取出程式內部資訊(例如 function 名稱、參數、
Key-Word)，而 Test Case Generation Module 會依據測試需求(unit testing、coverage 
testing、performance monitor)自動產生 test case 及 test case所需的 test data。Code 
Analyzer會找出需插入程式片段(instrument code)的位置使 Code Instrumentation 
Module能產生測試所需的 instrumented program，此外測試工程師也可自行輸入
test case、test data 及 instrument code所需的資訊。此模組架構如圖 110所示。 
 
圖 110 PRPM 模組架構 
 
本模組主要是在分析及處理測試的結果，將其測試結果分類成各個項目，並產生
文字及圖形的報表，Test Log Manager 會依據測試需求，執行不同的剖析器(Parser)
即時分析 Test Log的資訊，包含 Coverage Test Log Parser、Unit Test Log Parser、
Performance Monitor Log Parser，並且將分析後的結果動態的回饋給 PRPM 及
HSATM，做為下一步測試的參考。此外，測試工程師可在測試執行時即時地觀
察 coverage test 結果或 performance monitor 結果，Test Result Presentation Module
會將測試結果以文字描述及圖形化介面的方式來呈現結果。模組架構如圖 112
所示。 
 
圖 112 POPM 模組架構 
 
 
圖 113 TSATM 模組架構 
 
Step 2: 開啟測試程式編輯介面，左邊可列出所
有待測程式的檔案，右邊可列出所選擇的待測程
式的 source code，使用者可在此編輯、新增、刪
除待測程式的 source code，如圖 115所示。 
 
圖 115 待測程式編輯介面 
Step 3: 測試工程師可以使用 ”Test Case and 
Driver Generator”功能，自動產生 test case 及 test 
driver的 source code。ATEMES 在執行”Test Case 
and Driver Generator” 功能時，”Code Analyzer”
會去 parse待測程式的所有 method 的 signature，
包含 method name、parameter type、return type
等資訊，並自動產生 test case and test driver；作
為呼叫待測程式及讀 test data 用。此外，使用者
也可以再編輯待測程式中每個 function 的 test 
case。如圖 116所示，左邊可列出所有待測程式
的檔案，右邊為系統自動產生的 test case 的
source code。 
 
圖 116 Test case 和 test driver 產生器介面 
Step 4: 測試工程師可以使用”Generate Random 
Test Case”功能，來自動產生隨機測試案例，且使
用者可自行決定測試案例產生的數目，如
圖 
117 所示 
圖 117 產生 test case 選單介面 
Step 5: 測試工程師可以使用 ”Run Coverage 
Test”功能，執行 Coverage Test，系統會自動將待
測 試 程 式 、 test case and test driver 做
cross-compile，並將執行檔及 test data file傳送至
target-side (embedded system)執行測試工作，測試
工作可以是 single-round，也可做 multi-round 的
測試，在測試時，測試工程師可在 host-side即時
的觀察及接收測試結果，如圖 118所示。 
 
圖 118 執行 coverage test 選單介面 
testing的方式產生 test data，對每一個 function而言，每一回合產生 3組 test data，
執行 20回測試。在 runtime時，使用者可觀察每一回合的 test coverage圖 121
及最後的測試結果。系統並會記錄每一回合程式執行的資訊，包含 line coverage，
branch coverage，executing time 及失敗的 test case內容等。 
實驗結果： 
由圖 121、表 12、表 13所示，就 insertion_sort()而言，當到第五回合，line coverage
及 branch coverage 皆可達到 100%，每一個 round 測試完成後，就其它 function
而言，對於 line coverage 及 branch coverage 皆有提升，但是就 fractionCalculator()
來看 line coverage和 branch coverage到了第四回合時，為 92%及 65%，且 coverage
很難再提升，會有這樣的瓶頸是因為我們所採用的演算法為 random testing，我
們將會再利用其它的演算法來提升 coverage。 
 
圖 121 Coverage test 測試結果介面 
 
表 12Line Coverage測試結果 
 
Round 
Function 
1st 2nd 3rd 4th 5th 6th 7th 8th 9th 10th 20th 
seqsearch 92% 100% 100% 100% 100% 100% 100% 100% 100% 100% 100% 
binsearch 79% 100% 100% 100% 100% 100% 100% 100% 100% 100% 100% 
insertion_sort 91% 91% 91% 91% 100% 100% 100% 100% 100% 100% 100% 
merge 100% 100% 100% 100% 100% 100% 100% 100% 100% 100% 100% 
merge_pass 92% 100% 100% 100% 100% 100% 100% 100% 100% 100% 100% 
merge_sort 92% 100% 100% 100% 100% 100% 100% 100% 100% 100% 100% 
quicksort 26% 100% 100% 100% 100% 100% 100% 100% 100% 100% 100% 
heapsort 92% 92% 92% 92% 92% 92% 92% 92% 92% 100% 100% 
adjust 100% 100% 100% 100% 100% 100% 100% 100% 100% 100% 100% 
rollDiceGame 72% 83% 83% 83% 83% 94% 94% 94% 100% 100% 100% 
 圖 122 Unit test 測試結果介面 
 
表 14單元測試結果 
 
Function 
name 
Test case 
0 1 2 3 4 
getSubString success exception 
out of range 
success success  exception 
out of range  
electricityTraiff success assertion 
failed 
success assertion 
failed 
success 
factorial success success assertion 
failed 
assertion 
failed 
success 
insertion_sort success success Segment 
fault 
Segment 
fault 
Segment 
fault 
seqsearch success success success success success 
fractionCalculator success assertion 
failed 
success success success 
 
c. 實驗三 - 多核心效能監控 
本實驗將測試 2維矩陣乘法運算的範例程式效能，矩陣大小為 256*128 及
128*256，本系統將會自動分析待測程式碼，並 instrument 程式片段，使得能夠
監控執行時間，並且自動將 cross-compile後的測試執行檔上傳至ARM 11MPCore
開發板上自動執行測試，在程式執行時，使用者能夠即時觀看 CPU 每個核心的
使用率，且同時測試結果也會自動回傳至 Host-Side做即時的分析。 
實驗結果： 
程式執行的效能如圖 123及表 15所示，由圖 121可以看出，core 1 的效能一直
保持穩定狀態，而 core 2 使用率較低，由表 15可以看出，對於 CPU 平均的使
用率，core 3和 core 4 相對於另外兩個核心還要高，再來為 core1，最後為 core4，
  
(c) (d) 
 
圖 123多核心 CPU使用率視覺化介面 
 
d. 實驗四 - 不同 CPU core 數目在 TBB pipeline 技術下的效能量測 
本實驗主要目的為運用我們所發展的工具來觀測 TBB pipeline技術在不同的
CPU core數目執行的效率，且不同的 token數對效能的影響。以 TBB使用影像
處理範例，將不同階段的影像處理以 pipeline方式處理，預處理的圖片大小為
1280*1024，對影像做邊緣化及去雜訊。在此我們將 pipeline分為四個階段，分
別為讀取影像、邊緣化、去雜訊、輸出影像；讀取影像、輸出影像我們設定以循
序方式執行(serial)，而邊緣化、去雜訊為平行處理(parallel)。本系統將會自動產
生 pipeline token number的 test case，每個 test case為 100組資料集合，分別為 1、
2、3…100的 token數目，自動執行多回合效能量測並找出一個建議的 pipeline
平行化門檻值及顯示各個 CPU核心數的使用率。 
實驗結果： 
實驗結果如圖 39所示，我們可以得知使用的 CPU core數目越多則效率越高，
以 pipeline token 數來看，當 token數小於 5時效率皆較差，當 token 數大於 5時
則效率明顯提升很多，因此我們可以發現 pipeline token數越多則效率越佳，但
對於 TBB pipeline，token數到了某個數目則不會再有明顯的效率提升，反而會
增加系統的負擔，以下(1)~(4)我們將分別說明以不同的 CPU core數及不同的
token數執行狀況及建議使用的 token數目： 
 
core 3 0 0 0 
core 4 0 0 0 
 
(2) TBB pipeline 效能量測 2 - 以 2個 CPU core執行 
如圖 126所示待測程式平均執行時間約為 127秒，當 pipeline token 數為一時效
率最差，需 239 秒才執行完成，而 pipeline token 數大約為 6至 10時能達到較高
的效率，pipeline token 數大於 26皆到平穩狀態，很難再提升效率了，在 CPU的
使用率如表 17 所示，core1 及 core2 及 core3 的使用率平穩，core4 的平均使用
率最低。 
 
 
            圖 126 TBB pipeline以 2個 CPU core執行的效能量測 
 
表 17 以 2個 CPU core 執行 TBB pipeline的 CPU utilization 效能量測 
CPU utilization 
Core No. 
Min (%) Max (%) Average (%) 
core 1 0 57 49 
core 2 0 100 99 
core 3 0 100 99 
core 4 0 0 0 
 
(3) TBB pipeline 效能量測 3 - 以 3個 CPU core執行 
如圖 127所示，我們可以看出效率有明顯的改進，待測程式平均執行時間約為
85秒，當 pipeline token 數為 1效率最差，需 225秒才執行完成，而 pipeline token
數大約為 8至 12時能達到較高的效率，pipeline token 數大於 36皆到平穩狀態，
很難再提升效率了，在 CPU的使用率如表 18所示，core1、core、core3 及 core4
的 CPU 使用率平均皆算高，效率較好。 
 表 19 以 4個 CPU core 執行 TBB pipeline的 CPU utilization 效能量測 
CPU utilization 
Core No. 
Min (%) Max (%) Average (%) 
core 1 0 100 91 
core 2 0 100 72 
core 3 0 100 95 
core 4 0 100 99 
 
e. 實驗五 - TBB pipeline 效能分析 
本實驗將以TBB pipeline實作影像處理程式，測試不同的 stage數目的效能為何，
並使用 4個 CPU core 執行，預處理的影像大小為 128*128，共執行 12種不同的
影像處理主要工作為以不同的演算法達到影像的邊緣化(gradient、laplacian、
Prewitt)、去雜訊(smooth、median)、去除影像不連續的接點(erosion/dilation)、細
線化(thinning)、旋轉(rotation)及二值化(threshold)；在 pipeline中需循序處理的包
含讀取影像、輸出影像，可平行處理的為 gradient、laplacian、Prewitt、thinning、
smooth、median、erosion、dilation、rotation、threshold，量測的 stage數目為 1~12，
在此我們去比較 1~12stage的執行時間、CPU 使用率，並量測出一個建議的
pipeline token數。 
實驗結果： 
圖 129、表 20 為 1-12個 stage 分別輸入 1-36 個 token數的執行時間，由此可以
看出，當使用 1個 stage時效率最差，其次為使用 2個 stage，且當 stage的數目
大於 3時，程式所執行的時間都是差不多的，圖 45~圖 56將個別列出使用不同
stage及不同 token 數的執行時間分布。 
 
 
  
圖 130 使用 1個 pipeline stage執行的時間 
 
 
圖 131 使用 2個 pipeline stage執行的時間 
 
 
圖 132 使用 3個 pipeline stage執行的時間 
 
圖 135 使用 6個 pipeline stage執行的時間 
 
 
圖 136 使用 7個 pipeline stage執行的時間 
 
 
圖 137 使用 8個 pipeline stage執行的時間 
 
圖 138 使用 9個 pipeline stage執行的時間 
 
平行化的效率，讓測試工程師得知一個建議的 token數，使得測試工程師不需花
額外時間測試 TBB pipeline平行化的效率。 
 
C. 結論 
本研究建構了一個支援嵌入式軟體開發的 cross-testing的自動化測試環境系統，此系統
能根據剖析原始碼後的資訊，能自動 instrument source code、自動產生 test case、test driver
及支援自動產生 primitive types，structure types and object types 的 test data，，可回合跨
平台交叉測試，和，並以圖形化方式顯示測試結果。同時降低測試工程師的負擔，並提
高的效率，嵌入式軟體測試過程中，這個系統開發的自動測試功能，包括單元測試，覆
蓋測試，多核心平行參數的偵測。此外，ATEMES 可以直接測試執行在多核心嵌入式
平台的嵌入式軟體，嵌入式軟體採用英特爾 TBB庫，例如 parallel parameters such as 
pipeline tokens測試。此工具也實際上使用在 ARM11 多核平台進行測試實驗，在實驗
一及實驗二中，我們針對 C/C++資料結構範例程式進行測試，測試結果呈現我們所發展
的系統是可運作的；實驗三為監控平行測試在嵌入式平台上執行的 CPU使用率，使得
測試工程師能夠清楚了解軟體執行狀況，實驗四及實驗五為 TBB pipeline平行效率自動
化測試，可使測試工程師不需花額外的時間手動輸入 test data來測試TBB pipeline效率，
利用我們所開發出來的系統，來減少測試的負擔並增加測試的效率。 
 
 
三、 計畫成果(期刊、論文發表)  
1. Chang, C.H.; Lu, C.W.; Chu, C.W.; Yang, C.T.; Hsiung, P.A.; Hsueh, N.L.; and Koong, 
C.S, "XML-based Reusable Component Repository for Embedded Software," 
Proceedings of the 35th IEEE Computer Software and Applications Conference 
(COMPSAC2011), 17-22 (2011.07). (EI) 
2. Yu, K.Y.; Chen, T.C.; Lee, S.Y.; Chang, C.H.; and Chu, C.W.,"A SysML-based 
Requirement Environment for Embedded System Software Engineering," Proceedings 
of the 2011 Join Conference on Object-Oriented Technology Applications (OOTA) and 
Software Engineering (TCSE), pp. 437-441, 8-9 (2011.07) 
3. P.-Y. Tsai, H.-Y. Yeh, T.-S. Hsu, S.-Y. Pan, L.-W. Sung, Bipin Kumar and P.-A. Hsiung, 
“A Multicore System Design for Basketball Detection and Tracking in Sports 
Competition Video Streaming,” In Proceedings of the Workshop on Consumer 
Electronics (WCE), Taiwan, 2011. 
4. C.-Y. Shih, M.-C. Li, C.-S. Lin, P.-A. Hsiung, C.-H. Chang, W.C. Chu, N.-L. Hsueh, 
Chang and P.-A. Hsiung, "Synthesis and Code Generation of Multi-Core Embedded 
Software," The 2010 Join Conference on Object-Oriented Technology Applications 
(OOTA) and Software Engineering (TCSE), 2010 (in Chinese). 
14. Chao, T.Y.; Lin, B.Y.; Chang, C.H.; Chu, C.W.; and Chen, C.C., "XML-based Embedded 
Software Reusable Component Repository," Proceedings of the 2010 Join Conference 
on Object-Oriented Technology Applications (OOTA) and Software Engineering 
(TCSE), pp. 353-358, 22-23 (2010.07). 
15. You, C.R.; Chao, T.Y.; Lin, B.Y.; Wu, C.W.; Chang, C.H.; and Chu, C.W., "A Supporting 
Tool for System Software in Requirements Phase," Proceedings of the 2010 Join 
Conference on Object-Oriented Technology Applications (OOTA) and Software 
Engineering (TCSE), pp. 377-382, 22-23 (2010.07) 
16. Tung, H.Y.; Chang, C.H.; Chu, C.W.; Yang, H.J.; and Lu, C.W., "From Applications, to 
Models and to Embedded System Code: A Modeling Approach in Action," Proceedings 
of the 10th International Conference on Quality Software, pp. 488-494, 14-15 (2010.07). 
(EI) 
17. You, C.R.; Xhao, T.Y.; Lin, B.Y.; Chang, C.H.; and Chu, C.W., “需求階段與設計階段
整合追蹤性之探討 ," Proceedings of the 2010 the E-Learning and Information 
Technology Symposium, 31 (2010.03) 
18. Chang, C.H.; Lu, C.W.; Chu, C.W.; Shih, C.H.; Hsiung, P.A.; Yang, C.T.; Hsueh, N.L.; 
and Koong, C.S.;" SysML-based Requirement Modeling Environment for Multicore 
Embedded System," Proceedings of the 25th Annual ACM Symposium on Applied 
Computing (SAC'10), Volume III, pp. 2224-2228, 22-26 (2010.03). (EI) 
19. Chang, C.H.; Lu, C.W.; Chu, C.W.; Chen, W.C.; and Chen, T.Y., "Model-based 
Object-oriented Requirement Engineering for Supporting the Integration of Software 
Documents," Submitted to Journal of Software Engineering Studies. 
20. P.A. Hsiung, S.W. Lin, Y.R. Chen, C.H. Huang, C.H. Shih and C.W. Chu, “Modeling 
and verification of real-time embedded systems with urgency”, The Journal of Systems 
and Software, Vol. 82, pp. 1627-1641, October 2009 (EI) 
21. C.S. Lin, P.A. Hsiung, S.W. Lin, Y.R. Chen, C.H. Lu, S.Y. Tong, W.T. Su, C.H. Shih, 
N.L. Hsueh, C.H. Chang, and C.S.Koong, “VERTAF/Multi-Core: A SysML-based 
Application Framework for Multi-Core Embedded Software Development,” Journal of 
the Chinese Institute of Engineers, Vol. 32, No. 7, pp. 985-991 
22. Tung, H.Y.; Chang, C.H.; Chu, C.W.; Yang, H.J.; and Lu, C.W., "From Applications, to 
Models and to Embedded System Code: A Modeling Approach in Action," to appear in 
the Proceedings of the 10th International Conference on Quality Software, 14-15 
33. M.U. Zhuang, N.L. Hsueh, P.H. Chu ,P.A. Hsiung, William C. Chu , S.C Hwang, C.H. 
Chang, C.H. Shih , C.S Ko , “Using MDA Approach in Design Pattern Specification and 
Transformation” The 20th Workshop on Object-Oriented Technology and Applications 
(OOTA 2009) , Taichung, Taiwan, pp.345-353, November 20, 2009 
34. N.L. Hsueh, P.H. Chu, H.H. Shen and C.H. Chang, "A Semi-Automatic Approach for 
Test Case Traceability in a Test-Driven Development," Proceedings of the Workshop on 
Accountability and Traceability in Global Software Engineering (ATGSE 2008), pp. 
21-22, December 1-5, 2008, Beijing. 
35. L.C. Wen, N.L. Hsueh and P.H. Chu, "An Approach for Evaluating the Effectiveness of 
Design Patterns in Design Evolution," Object-Oriented Technology and Applications 
and Software Engineering, July 22-23, National Central University, Jhongli, 2010（審稿
中） 
36. P. A. Hsiung, C. S. Lin. “VERTAF/Multi-Core: A SysML-based Application Framework 
for Multi-Core Embedded Software Development,” The 9th International Conference on 
Algorithms and Architectures for Parallel Processing (ICA3PP’09). 
37. P.A. Hsiung,  S.W. Lin, Y.R. Chen, N.L. Hsueh,  C.H. Chang, C.H. Shih, C.S. Koong, 
C.S. Lin, C.H. Lu, S.Y. Tong, W.T. Su, and W.C. Chu. “Model-driven development of 
multi-core embedded software,” Workshop on Multicore Software Engineering, 2009. 
IWMSE '09, PP. 9 – 16, July 12, 2009. 
38. Chao-Tung Yang and Chih-Lin Huang, “Hybrid CUDA, OpenMP, and MPI Parallel 
Programming on Multicore GPU Clusters”, Conference on Computational Physics 2009 
(CCP09), Kaohsiung, Taiwan, Dec. 15-19, 2009. 
39. Chao-Tung Yang*, Chien-Hsiang Tseng, Keng-Yi Chou, and Shyh-Chang Tsaur, “A 
Virtualized HPC Cluster Computing Environment on Xen with Web-based User Interface”, 
The second International Conference on High Performance Computing and Applications, 
HPCA 2009, Lecture Notes in Computer Science, vol., 5938, pp. 503–508, Springer, 
Shanghai, China, August 10-12, 2009. 
40. [3] Chao-Tung Yang*, Jen-Hsiang Chang, and Chao-Chin Wu, “Performance-based 
Parallel Loop Self-Scheduling on Heterogeneous Multicore PC Clusters”, The second 
International Conference on High Performance Computing and Applications, HPCA 2009, 
Lecture Notes in Computer Science, vol., 5938, pp. 509–514, Springer, Shanghai, China, 
August 10-12, 2009. 
Competition: 
1. P. A. Hsiung. Digital Video Recording on Embedded Multicore Systems. 九十七學年
度全國大學校院嵌入式系統設計競賽. 教育部顧問室、SOC 總聯盟 
英文： 
The main goal of this sub-project is to design and implement the 
parallel program optimization supporting for VERTAF/Multi-Core 
(VMC) embedded software. Today, the processor researcher is not 
dependent on the method of enhanced clock speed to improve 
performance. Because of absolute performance, the increase of power 
consumption, as well as the rising cost of marginal benefit to make a 
gradually descending trend. At present, most industries have been 
considered multi-core is the future of development. The main design 
challenge has succeeded gradually overcomes, the actual operations 
have already started to build. The multiprocessing and multi-core 
technology has three major challenges, program partition, and program 
parallelization and program optimization. The most important need is a 
compiler model, which enables to develop parallel applications. Using 
these applications mapped to the parallel hardware and run the action 
of optimization, as well as to collect information in order to make the 
best decision. Effective parallel loop splitting and scheduling can 
obviously reduce the program response time in the multiple processor 
environment, especially that optimize process is also more difficult 
when aims at a many circle application programs and emerging 
multi-core embedded system environment. First year, we will use 
compiler technology, such as the data dependency analysis and 
software pipelining that implement parallel instruction, parallel loop 
partitioning, and loop scheduling and optimization. Second year, we 
will extend the interface of VMC parallel program and support more 
architecture and applications, such as multi-core library like OpenMP 
and Intel Threading Building Block(TBB), and strengthen the interface 
of other sub-projects. At the same time, we will build a set of 
multi-core embedded systems which support parallel program 
optimization model for OpenMP and Intel Threading Building Block 
API. 
可利用之產業 
及 
可開發之產品 
本子計畫所開發，結合了平行技術與程式碼優化演算法，提供程式
碼優化的基本功能和學習模式。本計畫建置一多核心嵌入式軟體之
高效能平行編譯器 (PPO)，載入既有之程式碼，透過逐行逐段分
析，輔以高效能平行演算法，基於 OpenMP 及 Intel Threading 
Building Block 多核心函式庫，產出平行程式碼，使其達到多核心
同步執行，加速其運算速度，並達到最大之產出。有鑒於以往程式
優化系統的全面性，我們採取了區塊優化，也就是經過學習模式就
每個迴圏區塊做一次優化並記錄下來，以迴圏執行效率做為比較，
去判定運算迴圏是否需要程式優化，因此本系統利用 Intel TBB與
OpenMP 以及 ROSE 來達到程式碼平行與優化的效果。 
技術特點 
本系統的主要功能可區分為四個部份，分別敘述如下： 
 程式剖析子系統(Source Program Parsing Subsystem, SPPS) 
SPPS 接受使用者輸入之原始程式碼，逐行進行剖析，主
要鎖定多數可平行運行之迴圈，以平行程式撰寫時常用的
關鍵字與平行化之架構為基礎，針對輸入程式之上下文，
以及各種區塊符號，判斷出各個程式區塊，最後交付後端
之平行優化子系統。 
 平行子系統(Parallelism Subsystem, PS) 
PS 接受前端程式剖析子系統之結果，針對剖析子系統所
技術說明 
（中文） 
設計者僅需要輸入工業標準的 SysML模型，其中遵循我們 VMC
框架所訂的平行化之 stereotypes (標籤)，即可由 VMC 框架自動生
成適合於多核心嵌入式系統執行的平行程式碼。目前，支援 C++
程式語言、quantum platform (QP)狀態機程式庫、Intel Threading 
Building Blocks (TBB)多核心程式庫於 Intel 的多核心 CPU 以及
ARM 11 MPCore (4 核心)微處理機上執行。 
 
（英文） 
Designers have to only specify embedded software requirements via 
industry-standard SysML models, and use the VMC stereotypes to 
specify parallelism, then VMC can automatically generate parallel 
code. Currently, VMC supports the code generation of C++ code, 
quantum platform (QP) state machine library, Intel Threading Building 
Blocks (TBB) multicore library, that can run on Intel multicore CPU 
and ARM 11 MPCore CPU. 
 
產業別 
嵌入式系統設計之公司以及嵌入式軟體開發之公司。 
技術/產品應用範圍 
自動化多核心程式碼生成。 
技術移轉可行性及預期
效益 
縮短多核心嵌入式軟體的開發時程。 
 
國科會補助計畫 
計畫名稱：多核心嵌入式軟體之模型驅動整合開發環境-VMC－子
計畫七:多核心嵌入式軟體設計之測試支援系統(2/2) 
計畫主持人：孔崇旭         
計畫編號：NSC 99-2220-E-142 -001  領域：軟體測試 
研發成果名稱 
（中文）多核心嵌入式軟體自動測試工具 
（英文）an automatic testing environment for multi-core embedded 
software (ATEMES) 
成果歸屬機構 
國立台中教育大學 發明人 
(創作人) 
孔崇旭 
automatic testing functions including unit testing, coverage testing, 
multi-core performance monitoring. Moreover, ATEMES can perform 
automatic multi-round cross-testing benchmark testing on multi-core 
embedded platform for parallel programs adopting Intel TBB library 
to recommend optimized parallel parameters such as pipeline tokens. 
Using ATEMES on the ARM11 multi-core platform to conduct testing 
experiments, the results show that our constructed testing environment 
is effective, and can reduce burdens of test engineer, and can enhance 
efficiency of testing task. 
 
產業別 
軟體業 
嵌入式軟體開發 
技術/產品應用範圍 
嵌入式軟體系統開發 
軟體自動化測試工具 
平行程式之平行度效能測試 
技術移轉可行性及預期
效益 
可提昇嵌入式軟體的品質 
減少軟體測試的人力 
加速嵌入式軟體的開發 
 出席國際學術會議心得報告 
                                                             
出國人員姓名 
服務機關及職稱 
資訊工程學系 朱正忠教授 
會議時間地點 July 18-21, 2011 Munich, Germany 
會議名稱 
The 35
th
 Annual IEEE Computer Software and Applications Conference 
(COMPSAC 2011) 
 
一、參加會議經過 
 
    此會議Computer Software and Applications Conference是在電腦軟體及應用科學具領導地位
的國際會議，討論的領域以軟體技術與應用為主也包括程式開發、分析、改進、測試與需求等。
今年會議舉辦地點是德國慕尼黑，本次主要擔任會議之 Steering Committee, Program Committee, 
Session Chair，與會的學者都是世界上頂尖的專家，主要與會學者如 Bruce McMillin, Klaus Beetz, 
(General Chair) Sheikh Iqbal Ahamed (Program Chairs)等知名學者。本次研討會的核心議題主要以
軟體工程為主，但也包含熱門的嵌入式系統、雲端計算等熱門議題，在會議的第一天的 workshop
與第三天下午的 Panel 中，也探討未來軟體技術的發展與軟體重用的觀念，討論熱烈，從中獲
取不少心得，整體來說此會議涵蓋的研究範圍已相當完整。 
 
二、與會心得 
 
這次除了與來自各國專家一起討論軟體開發的研究之外，並發表一篇論文 Requirements 
Recovery by Matching Domain Ontology and Program Ontology 以及主持一場關於即時嵌入式系
統的論文發表會，與眾多學者一起討論、交換心得是這次會議最大的收穫，未來有機會也許可
以與國外研究團隊合作；在會場有許多專家討論到個人最近在做的關於多核心嵌入式系統方面
的研究，各國學者皆對於我們的研究非常有興趣，與這些專家學者做了一些深入的討論，這學
者們也認同我們在此領域的研究是有其必要性，並且這也是目前正熱門的議題之一，在交流的
過程中，也瞭解這些專家學者所做的相關研究，也對我們的研究上有莫大的幫助。 
 
 
 
 
 
 
 
 
 
 
 
 
 information for conference registration, visa letter requests, travel, and 
hotel accommodation. 
 
Best regards, 
 
Sheikh Iqbal Ahamed 
 
Wolfgang Minker 
 
Zhi Jin 
 
COMPSAC 2011 Program Committee Chairs 
===================================== 
 
Reviewer: 1 
 
 
Originality : Weak Accept 
Quality : Weak Accept 
Relevance : Neutral 
Presentation : Weak Accept 
Recommendation : Weak Accept 
 
Summary: Ontology is really a foundamental element for reverse engineering. 
Applying ontology to reverse a program for the maintenance is a good 
approach. 
 
Details: Ontology is really a foundamental element for reverse engineering. 
The authors provide two methods to help the reverse work based on ontology 
and give an example to indicate the success of their methods. The paper 
writing is acceptable. However, the example does not show how the steps in 
each method are applied. Therefore, it validity is not good enough. 
 
 
Candidate for the best paper award? : No 
Have you checked whether there may be a plagiarism with this paper? (give 
specific information on the review form) : Yes 
Have you noticed that there may be a conflict of interest? (explain using 
the review form) : Yes 
 
===================================== 
 
Reviewer: 2 
 
 
Originality : Weak Reject 
  
 
Details: Favor 
Recovering ontologies from legacy might be useful to understand existing 
system. 
The authors try to demonstrate the proposed method with POS (Point Of Sale) 
terminal. 
 
Against 
Whole paper lacks rigorous discussions. 
A case study of POS(T) system is rather shallow, and details are not 
presented. Therefore, it's hard to see the effectiveness of the proposed 
method against the methods of local company. 
 
 
Candidate for the best paper award? : No 
Have you checked whether there may be a plagiarism with this paper? (give 
specific information on the review form) : No 
Have you noticed that there may be a conflict of interest? (explain using 
the review form) : No 
 
 
 
 
 
 
 
 
 which computer system will be able to find 
implicit consequences of explicit knowledge.  
In general, it is expected to reduce the 
development and maintenance costs and 
delays through a relative general 
domain-specific pattern or architecture [3]. 
Since ontology can provide a vocabulary of 
terms and relations to model such domains, it 
will therefore facilitate the construction of the 
domain-specific solutions by introducing 
ontology-based approach.  
2. Related Work 
Much work has been carried out on ontology 
based software engineering. Devedzic [6] 
proposes that ontologies are needed in all 
software systems. Bures et al. [2] propose 
how ontology can facilitate schema-based 
program synthesis. Zimmer and Rauschmayer 
[29] present a way of enhanced 
ontology-based software modelling. Furtado 
et al. [9] propose a universal user interface 
design. The conceptual level is to create the 
domain ontology. Wongthongtham et al. [20] 
propose a software engineering ontology for 
software engineering knowledge management 
in multi-site software development 
environment.  
Several studies have been carried out to 
utilise ontology and other knowledge 
representation techniques to facilitate 
program comprehension and reverse 
engineering. Yang et al. [24] suggest that 
ontology has a great potential for legacy 
software understanding and re-engineering. Li 
et al. [16] introduce an innovative approach to 
recovering domain knowledge with enhanced 
reliability from source code. Zhang et al. [26] 
propose an approach to identifying security 
flaws and reasoning security concerns. Zhou 
et al. [28] present an Ontology-based 
PlaTform-specIfic software Migration 
Approach (OPTIMA). Jin and Cordy [11] 
utilise ontology-based approach to facilitating 
software analysis and reengineering tools 
integration via Ontology Adaptive 
Service-Sharing Integration System (OASIS). 
Ambrosio et al. [1] use ontologies to help the 
combination of application domain 
information and software reengineering 
knowledge, producing up-to-date 
documentation that evolves along time. 
ONTODM [10] is an ontology-based tool 
supporting specification of domain models in 
Multi-Agent Domain Engineering.  
In many cases, a requirement specification 
will prove to be inconsistent or inaccurate, or 
even worse, not available. Requirement 
reengineering is needed and the requirement 
of existing systems needs to be recovered. 
El-Ramly et al. [7, 8] propose a method to 
recover requirements from systems-user 
interaction trace and build use case models. 
Paul Rayson et al. [21] propose the 
probabilistic natural language processing 
techniques to assist requirements recovery 
from legacy documents. Liu [17] proposes a 
semiotic approach, Analysing and Modelling 
the Behaviour of Legacy Systems 
(AMBOLS), to requirement engineering.  
Melikhova et al. [18] show a practical 
approach for reengineering requirements for 
reuse along with examples of how it was 
applied in a cable TV environment. Colom [5] 
and Yu [25] propose an i* framework, which 
is a goal-oriented approach. The i* 
framework addresses requirements 
engineering and business process 
reengineering.  
There are many challenges in Requirements 
Engineering research area [19] and it is very 
natural to apply ontology in this area. Kaiya 
et al. [12] propose a software requirements 
analysis method based on domain ontology 
technique to establish a mapping between a 
software requirements specification and the 
domain ontology that represents semantic 
components. Lee et al. [15] present an 
Ontology-based Active Requirements 
Engineering (Onto-ActRE) framework, which 
integrates various RE modelling techniques 
 3.2.1. Development of Program Ontology. 
Program ontology comes from knowledge of 
code, database and application framework. 
Hence Program ontology describes 
programming elements and their relationships. 
Program ontology also includes artefacts at 
Schema level, such as conceptual database 
schemas. If there exists an application 
framework, it is normally domain specific, 
which can be linked to the domain ontology 
easily. Since Object-Oriented class has many 
features that make it easy to be transformed to 
the form of ontology, in this work, program 
ontology will be populated from a class 
diagram. 
3.2.2. Class Diagram Transformation. A 
class generally includes three parts: class 
name, attributes and operations. Class itself 
will be transformed into concept in the 
ontology. The attributes of the class will be 
transformed into properties of that concept in 
ontology. For the generalisation and 
inheritance classes, the relationships 
SubClassOf and SuperClassOf will be 
preserved by the subclass and superclass 
concepts. Association will be transformed into 
ConnnectTo property, and it is a symmetric 
property. Dependency will be transformed 
into DependOn property and its inverse 
property Depend. Aggregation/composition 
will be transformed into HasA/PartOf 
property.  
3.3. Ontology Mapping  
Basically, ontology mapping is performed 
based on the understanding process. The 
mapping algorithm given below was proposed in 
[27]: 
1. Load two ontologies Oc and Od, Oc is the class diagram 
ontology while Od is the domain ontology. 
2. Scan the concepts names. 
3. For each concept Cc in Oc, retrieve the initial list of 
suggestions. Find the best choice Cd from the 
suggestions in Od. Introduce the relation implement into 
these two ontologies: implement (Cc, Cd) and let the 
relation implement ⊆ subsume, so Cc⊆ Cd. As a result, 
the classes in class diagram are mapped to the concepts in 
Od. 
4. Create a neighbourhood ontology On. 
5. For each concept Cc′ ∈ Oc, which does not have the 
initial list of suggestions, let R and R′ be two binary 
relations, concept Cc″ ∈ Oc, and either   Cc′ ⊆ 
∃R..Cc″ or Cc″⊆ ∃R′. Cc′. If Cc″ has best choice Cd″ 
∈ Od, let Cc″ ∈ On and Cd″ ∈ On. 
6. Do 5 until Cc″∈ ∅. 
7. Find out concept Cd‴ ∈ Od, where ∀ Cd″( Cd″ ∈ Od 
and Cd″ ∈ On) and R∈ Od → Cd‴⊆           ∃ 
R.Cd″. Put Cd‴ into the initial list of suggestions for the 
concept Cc′ in 5. 
8. Do 3 until Cd‴ ∈ ∅. 
9. Generate application specific ontology Os.  
10. Stop. 
Based on this algorithm, the program 
ontology can be combined with domain 
ontology, and the application specific 
ontology is populated.  
4. An Ontology Based Requirement 
Recovery Approach 
Requirements artefacts include Use Case 
Model, Supplementary Specification, 
Glossary and System Sequence Diagram. The 
proposed approach is to recover requirements 
by rebuilding the use cases. 
4.1. Use Case Diagram Recovery 
The use case model is the model of system's 
functionality and environment. It may 
optionally include a UML use case diagram to 
show the names of use cases and actors, and 
their relationships. This gives a nice context 
diagram of a system and its environment. Use 
case model can be briefly (high level) or fully 
addressed. Generally, after many use cases 
have been identified and written in a brief 
format, a few (such as 10%) of the 
architecturally significant and high-value use 
cases should be written in detail. 
The name of use case normally starts with a 
verb. It means that from ontology analysis 
point of view, to recover the use cases from 
the existing system, it is better to capture 
functions or operations from program 
  
Figure 2. Domain ontology for POST system 
  
 
Figure 3. Program ontology for POST system 
 
 [3] F. Chen, H. Guo, L. Dai and H. Yang, "An application framework for ontology-based data mining," Journal of Dalian University 
of Technology, vol. Suppl., 43(S1), China, pp. 143-145, Oct. 2003. 
[4] F. Chen, Z. Zhang, J. Li and H. Yang, "Service identification via ontology mapping," 33rd Annual IEEE International Computer 
Software and Applications Conference (COMPSAC '09). Seattle, WA 2009, pp. 486-491. 
[5] G. G. Colom, "An i*-based reengineering framework for requirements engineering," Universitat Politècnica de Catalunya, 2008. 
[6] V. Devedzic, "Understanding ontological engineering," Communications of the ACM, vol. 45(4), pp. 136-144, Apr. 2002. 
[7] M. El-Ramly, E. Stroulia and P. Sorenson, "Mining system-user interaction traces for Use Case models," Proceedings of the 10th 
International Workshop on Program Comprehension (IWPC '02), 2002. 
[8] M. El-Ramly, E. Stroulia and P. Sorenson, "Recovering software requirements from system-user interaction traces," Proceedings 
of the 14th International Conference on Software Engineering and Knowledge Engineering (SEKE '02), 2002. 
[9] E. Furtado, J. J. V. Furtado, W. B. Silva, et al., "An ontology based method for universal design of user interfaces," Workshop on 
Multiple User Interfaces over the Internet: Engineering and Applications Trends, Lille, France, Sep. 2001. 
[10] R. Girardi, C. G. d. Faria and L. Balby, "Ontology-based domain modeling of multi-agent systems," 3rd International Workshop 
on Agent-Oriented Methodologies at OOPSLA 2004, Vancouver, Canada, Oct. 2004. 
[11] D. Jin and J. R. Cordy, "Ontology-based software analysis and reengineering tool integration: The OASIS Service-Sharing 
Methodology," 21st IEEE International Conference on Software Maintenance (ICSM'05), Budapest, Hungary, Sep. 2005. 
[12] H. Kaiya and M. Saeki, "Ontology based requirements analysis: lightweight semantic processing approach," Fifth International 
Conference on Quality Software (QSIC 2005). Sep. 2005, pp. 223-230. 
[13] M. Kossmann and M. Odeh, "Ontology-driven requirements engineering – A case study of OntoREM in the aerospace context," 
2010 INCOSE Conference. Chicago, USA, 2010. 
[14] C. Larman, Applying UML and Patterns: an Introduction to Object-oriented Analysis and Design: Prentice Hall PTR, 1997. 
[15] S. W. Lee and R. A. Gandhi, "Ontology-based active requirements engineering framework," 12th Asia-Pacific Software 
Engineering Conference (APSEC '05), Dec. 2005, pp. 8-15. 
[16] Y. Li, H. Yang and W. Chu, "A concept-oriented belief revision approach to domain knowledge recovery from source code," 
Journal of Software Maintenance: Research and Practice, vol. 13(1), pp. 31-52, Jan. 2001. 
[17] K. Liu, "Requirements reengineering from legacy information systems using semiotic techniques," Systems, Signs and Actions – 
The International Journal on Communication, Information Technology and Work, vol. 1 (1), pp. 36–61, 2005. 
[18] L. Melikhova, A. Elcock, A. A. Dovzhikov, G. Bulatov and D. Vavilov, "Reengineering for system requirements reuse: 
methodology and use-case," IEEE International Symposium on Consumer Electronics (ISCE 2007), Irving, TX, Jun. 2007. 
[19] B. Nuseibeh and S. Easterbrook, "Requirements engineering: a roadmap," Proceedings of the Conference on The Future of 
Software Engineering (ICSE '00), 2000, pp. 35-46. 
[20] W. Pornpit, E. Chang and I. Sommerville, "Software engineering ontology for software engineering knowledge management in 
multi-site software development environment," 10th International Protege Conference 2007, Budapest, Hungary, Jul. 2007. 
[21]P. Rayson, R. Garside and P. Sawyer, "Assisting requirements recovery from legacy documents," Technical Report CSEG/8/2000, 
Computing Department; Lancaster University 2000. 
[22] J. F. Sowa, Knowledge Representation: Brooks/Cole, an Imprint of Thomson Learning, 2000. 
[23] Stanford, "Protégé Programming Development Kit (PDK)," http://protege.stanford.edu/doc/dev.html. 
[24] H. Yang, Z. Cui and P. O'Brien, "Extracting ontologies from legacy systems for understanding and re-engineering," 23rd Annual 
International Computer Software and Applications Conference (COMPSAC'99), Phoenix, AZ, Oct. 1999. 
[25] E. Yu, "Towards modeling and reasoning support for early-phase requirements engineering," Proceedings of the 3rd IEEE 
International Symposium on Requirements Engineering (RE '97)  1997. 
[26] Y. Zhang, J. Rilling and V. Haarslev, "An ontology-based approach to software comprehension - reasoning about security 
concerns," 30th Annual International Computer Software and Applications Conference (COMPSAC'06), Chicago, USA, Sep. 
2006. 
[27] H. Zhou, F. Chen and H. Yang, "Developing application specific ontology for program comprehension by combining domain 
ontology with code ontology," 8th International Conference on Quality Software (QSIC'08). Oxford, UK, Aug. 2008, pp. 
225-234. 
[28] H. Zhou, J. Kang, F. Chen and H. Yang, "OPTIMA: an Ontology-based PlaTform-specIfic software Migration Approach," 7th 
International Conference on Quality Software (QSIC'07), Portland, Oregon, USA, Oct. 2007. 
[29] C. Zimmer and A. Rauschmayer, "Tuna: ontology-based source code navigation and annotation," Workshop on Ontologies as 
Software Engineering Artifacts, Vancouver, Canada, 2004. 
 
99 年度專題研究計畫研究成果彙整表 
計畫主持人：朱正忠 計畫編號：99-2220-E-029-001- 
計畫名稱：多核心嵌入式軟體之模型驅動整合開發環境-VMC--總計畫(2/2) 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
期刊論文 0 0 100%  
研究報告/技術報告 0 0 100%  
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100% 章/本  
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 0 0 100%  
博士生 0 0 100%  
博士後研究員 0 0 100%  
國外 
參與計畫人力 
（外國籍） 
專任助理 0 0 100% 
人次 
 
國科會補助專題研究計畫成果報告自評表 
請就研究內容與原計畫相符程度、達成預期目標情況、研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）、是否適
合在學術期刊發表或申請專利、主要發現或其他有關價值等，作一綜合評估。
1. 請就研究內容與原計畫相符程度、達成預期目標情況作一綜合評估 
■達成目標 
□未達成目標（請說明，以 100 字為限） 
□實驗失敗 
□因故實驗中斷 
□其他原因 
說明： 
2. 研究成果在學術期刊發表或申請專利等情形： 
論文：■已發表 □未發表之文稿 □撰寫中 □無 
專利：□已獲得 □申請中 ■無 
技轉：□已技轉 □洽談中 ■無 
其他：（以 100 字為限） 
本計畫共產出 40 篇國內外相關期刊論文。 
3. 請依學術成就、技術創新、社會影響等方面，評估研究成果之學術或應用價
值（簡要敘述成果所代表之意義、價值、影響或進一步發展之可能性）（以
500 字為限） 
研究目的：本整合型計畫網羅了各方面的專家，包括了需求分析、軟體設計、軟體工程、
嵌入式系統、平行化計算、軟體測試、系統整合等，共同開發設計出一套整合式多核心嵌
入式軟體之模型驅動整合開發環境–VERTAF/Multi-Core (VMC)。VMC 對於目前國內嵌入式
軟體產業缺乏支援自動化的軟體發展整合開發環境現象，提供一個符合開放原始碼(open 
source)規範的選擇，進而提升國內嵌入式產業軟體設計能力與品質。 
2. 人才培育成果說明：計有三位博士、十七位碩士的畢業論文與本計畫密切相關。 
3. 技術研發成果說明：本計畫研究集合在需求分析、軟體設計、嵌入式系統、軟體測試、
系統整合等領域，開發設計出一套整合式多核心嵌入式軟體之模型驅動整合開發環境，提
供給使用者一個最完整的多核心軟體開發環境。 
4. 技術特點說明：軟體必須導入平行處理的概念才能有效利用多核心的優點。然而對於
熟悉傳統循序式設計的軟體開發人員而言，實現平行運算的技術勢必遭遇到許多的困難。
因此我們提出模型驅動及樣式支援的方法來加速多核心軟體的開發，並且降低開發人員設
計多核心軟體的門檻。。 
5. 可利用之產業及可開發之產品：多核心嵌入式軟體開發。 
6. 推廣及運用的價值：多核心嵌入式軟體開發是目前的軟體趨勢，一個整合的多核心嵌
入式軟體開發環境將成為不可或缺的利器。 
 
