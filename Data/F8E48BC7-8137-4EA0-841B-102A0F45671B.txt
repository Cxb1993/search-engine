2 
中文摘要 
無線感知網路的催生是由於近年來在無線網路技術的突飛猛進，相關標準的制訂（例
如，IEEE 802.11b、Bluetooth）的相繼推出，也帶動的無線感知網路的新發展。使用無線技
術雖然可以帶感知網路新的發展，但是相對的，我們就必須考慮到無線網路的一些安全特
性，無線網路因為透過無線電波來傳輸，所以每個人都可以輕易的收到訊號，也可以輕易
的發出偽造的訊號，這些是與原來的有線網路所不同的，而這些問題，在應用在保全方面
的無線感知網路中更形重要。本子計畫之目的在於設計適用於總計畫 wireless sensor 
network 的安全性架構，提供不同的安全需求。我們可以知道無線感知網路最重要的特性是
他在計算資源及電源的限制，如何在有限的資源裡達到最完善的保護，是我們所需要研究
的問題。 
底下是各年要達成的目標，其中第一年主要著重在最基礎的加密演算法研發與實作，
第二年著重在安全的無線感知網路溝通架構，最後第三年主要著重在應用層及中介軟體層
的安全。 
 
關鍵詞：無線感知網路、加密、認證、安全機制 
4 
目錄 
1. 研究目的.................................................................................................................................... 7 
2. 文獻探討..................................................................................................................................... 8 
2.1 加密演算法收集與評估................................................................................................... 8 
2.2 Sensor routing protocol 的資料收集 ................................................................................. 9 
2.3 routing protocol 相關之攻擊的資料收集 ....................................................................... 10 
2.4 Data aggregation 演算法收集與問題研究 ..................................................................... 10 
2.5 橢圓曲線加密技術應用於 wireless sensor network 之研究 ........................................ 10 
3. 研究成果................................................................................................................................... 11 
3.1 加密套件演算法............................................................................................................. 12 
3.1.1 Improve AES......................................................................................................... 12 
3.1.2 加密套件安全性分析........................................................................................... 13 
3.1.3 加密套件實作...................................................................................................... 15 
3.1.4 加密演算法效能評估.......................................................................................... 15 
3.2 routing protocol................................................................................................................ 16 
3.2.1 routing protocol 安全模型 .................................................................................... 16 
3.2.2 模擬與實作........................................................................................................... 17 
3.3 Secure data aggregation ................................................................................................... 17 
3.3.1 BGN-EXT scheme ................................................................................................ 17 
3.3.2 Secure Data Encryption Comparison .................................................................... 20 
3.3.3 比較與分析.......................................................................................................... 20 
4. 參考文獻................................................................................................................................... 22 
5. 計劃成果自評........................................................................................................................... 26 
5.1 加密套件演算法............................................................................................................. 26 
5.2 Routing protocol............................................................................................................... 26 
5.3 Secure data aggregation ................................................................................................... 26 
6. 可供推廣之研發成果資料表................................................................................................... 27 
7. 附錄........................................................................................................................................... 29 
7.1 適用於無線感知網路的 Modified AES ......................................................................... 29 
7.2 A Pair-wise Key Establishment Scheme for Wireless Sensor Networks ......................... 46 
6 
List of Figure 
Figure 1 Throughput vs. area diagram for the ASIC implementations of the basic iterative 
architecture developed by NSA ....................................................................................................... 8 
Figure 2 Comparison of the best results obtained using three different technologies and device ... 9 
Figure 3 the flow chart of our AES algorithm................................................................................ 13 
Figure 4 MixColumn Operation 乘數的選擇................................................................................ 14 
Figure 5 Inv_MixColumn Operation 乘數的選擇 ........................................................................ 14 
Figure 6 Node insertion.................................................................................................................. 16 
Figure 7 Authentication algorithm ................................................................................................. 16 
Figure 8 Multiple-Application Scenario ........................................................................................ 18 
Figure 9. proof of SDEC ................................................................................................................ 20 
Figure 10 algorithm of SDEC ........................................................................................................ 20 
8 
2. 文獻探討 
2.1 加密演算法收集與評估 
考量到串流密碼需要同步化，而在無線網路傳輸環境的封包容易發生遺失，感知節點
的資源消耗比較大，於是我們仍使用傳統的塊狀密碼。相關演算法包含 RC5、RC6、Rijndael、
Serpent、Twofish、Mars、TEA。 
RC5 的方法比較簡單，主要觀念是使用資料相依混合(data dependent rotation)，RC6 又
進一步改進 RC5 的流程，一次使用四個暫存器加密。Serpent 只需要使用 shift-row 和 xor
等運算元，算是最簡單的加密方法，當然速度上有其優勢。然而在安全性方面稍嫌不足。
Rijndael 的好處在於只要以電路面積換取時間，就能達到很高的 throughput，這是其他演算
法如 Twofish、RC6 所辦不到的。它的缺點在於加解密能共用的面積少，只有約 45%的空間
可以共用，硬體實作出來會較大，因此這是我們改進的目標。Mars 和 Twofish 則是 throughput
太低無法達到感知節點資料傳輸速率的要求，因此不列入考慮。Figure 1.與 Figure 2.是相關
演算法的效能比較。(資料來源: 
http://ece.gmu.edu/reports/Pawel_Chodowiec_MS_Thesis.pdf) 
 
 
Figure  1 Throughput vs. area diagram for the ASIC implementations of the basic iterative architecture developed 
by NSA 
10 
Table 1 Comparison various routing algorithms 
 
 
2.3 routing protocol 相關之攻擊的資料收集 
相關攻擊模式整理成以下幾種 
A. Modification：更改路由的 sequence numbers、更改 hop count、更改來源路由以達成 DoS
攻擊 
B. Impersonation：偽造傳輸路徑使路徑行成迴路，無法將資料送出 
C. Fabrication：偽造路由路徑錯誤封包、偽造要求路由封包、偽造回應路由要求封包。 
 
2.4 Data aggregation 演算法收集與問題研究 
由於無線感測器有電源限制，因此如何降低因傳輸所造成的消耗，變成一個重要的課
題，data aggregation 正是為了減少資料傳輸而產生的技術，當 leaf node 收集到資料並傳送
至 base station 時，中間的節點(aggregator)如果將每個所收到的封包皆轉傳出去，將會嚴重
的消耗能源，也降低無線感測網路的壽命，因此中間節點將所收集到的資料做聚合的動作，
將聚合後的結果重送至 base station，以減少節點因做過多的轉傳動作而導致能源過多消耗。 
Data aggregation 易受到惡意節點的攻擊，惡意節點傳送大量錯誤訊息給 aggregator，
若 aggregator 無法判別訊息的合法性，而將所有的資訊聚合並回傳至 base station，將導致
base station 決策出現錯誤。另一個問題是 aggregator 身份合法性問題，對 leaf node 而言，
若 aggregation 受到捕獲，則 aggregator 將得到通訊範圍內所有 leaf node 的訊息，若 leaf node
採用加密演算法來確保訊息的私密性，則此法不但不能夠解決問題且更加重能源消耗負擔。 
 
2.5 橢圓曲線加密技術應用於 wireless sensor network 之研究 
橢圓曲線技術有著儲存量較小、安全性較高以及同態運算等特質。根據研究橢圓曲線
密碼系統只需要 160 bits 金鑰長度，其安全性就等同於 1024 bits RSA 密碼系統，因此在相
同安全等級之下，橢圓曲線擁有較短的金鑰，此特性也正符合無線感測器儲存空間限制。
而同態運算則可以在 data aggregation 演算法，讓 leaf node 將加密訊息傳送給 aggregator，
而 aggregator 卻可以不需要解密(亦無解密的金鑰)即可執行聚合動作。 
Privacy Homomorphic(PH) 的特性可以用下面式子表達： 
( ) )()( 2121 mEmEmmE kkk +=+  
PH 可以被實做於各式各樣的密碼系統上，BGN 即為其中一個具有 PH 特性的橢圓曲線密碼
系統，BGN scheme (由 D. Boneh, Eu-Jin God, 與 Kobbi Nissim 所提出) 可由 Table 2 了解其
演算法步驟。 
12 
3. 研究成果 
3.1 加密套件演算法 
3.1.1 Improve AES 
為了保證一定的安全性，我們從 AES 決選中的演算法挑了 Rijndael 進行改進。目的是
符合感知節點的特性需求，將加解密的回合數減少，以在安全性以及電力消耗上取得平衡。
我們的演算法將加密回合數減少至約 7 個 rounds，大幅提升資料處理的速度，並且改良
Rijndael 的 Mix Column Operation，可以加速密文的混合特性(diffusion)，維持一定的安全
性。另外為了配合硬體設計，縮小硬體實作的面積，利用 Rijndael 的加密等效性(equivalence)
將兩個 table 合併。原本的: 
 AESRound(){ 
   SubByte(state); 
   ShiftRow(state); 
   MixColumn(state); 
   AddRoundKey(state,Rkey); 
 } 
 AESRound(){ 
   ShiftRow(state); 
   SubByte(state);     MixColumn(state); 
   AddRoundKey(state,Rkey); 
 } 
AESRound(){ 
   ShiftRow(state); 
   SubMix(state);    AddRoundKey(state,Rkey); 
 } 
SubMix operation 就能以 lookup-table 的方式實作成硬體。此部分使用 table 是因為加密速度
的考量，若使用 Xtime 等計算方法將無法配合上感知節點的 data rate。 
我們提出的演算法流程如 Figure 3 所示: 
14 
 
Figure  4 MixColumn Operation 乘數的選擇 
 
Inv_MixColumn Operation 乘數的選擇: 
 
Figure  5 Inv_MixColumn Operation 乘數的選擇 
 
這些數字必須同時滿足漢明值較高、數字重複而且存在反函數。因此，當攻擊者使用
試圖發動差分攻擊(differential attack)或是線性攻擊(linear attack)，所需要的明文和密文配對
數也有提升，讓攻擊者更難進行攻擊。這是因為位元之間的對應關係比起原本的 Rijndael
變的更加複雜。實際上，所需的配對數遠遠超過感知節點可能的資料傳輸量。一般而言，
因為金鑰的時效性，sensor network 經常進行金鑰更新，在兩次更新之間所能傳送的資料量
還不足以進行差分攻擊，因此我們的演算法能達到安全性的需求。 
改良的部分不僅可用查表方式達到硬體設計需求，同[15]我們也提供了 bitwise 的轉換
方式以提供軟體實作，避免使用 Xtime 的乘法。 
{17} 
a0’=b0 + b4 + b6 + b7  
a1’=b0 + b1 + b4 + b5 + b6  
a2’=b0 + b1 + b2 + b5 + b6 + b7  
a3’=b1 + b2 + b3 + b4 
a4’=b0 + b2 + b3 + b5 + b6 + b7  
a5’=b1 + b3 + b4 + b6 + b7  
a6’=b2 + b4 + b5 + b7 
a7’=b3 + b5 + b6 
{37} 
a0’=b0 + b3 + b4 + b6 
a1’=b0 + b1 + b3 + b5 + b6 + b7  
a2’=b0 + b1 + b2 + b4 + b6 + b7  
a3’=b1 + b2 + b4 + b5 + b6 + b7  
a4’=b0 + b2 + b4 + b5 + b7  
a5’=b0 + b1 + b3 + b5 + b6  
a6’=b1 + b2 + b4 + b6 + b7  
a7’=b2 + b3 + b5 + b7 
{5d} 
a0’=b0 + b2 + b4 + b5 + b7  
a1’=b1 + b2 + b3 + b4 + b6 + b7  
a2’=b0 + b2 + b3 + b4 + b5 + b7  
a3’=b0 + b1 + b2 + b3 + b6 + b7  
16 
3.2 routing protocol 
3.2.1 routing protocol 安全模型 
3.2.1.1 Low power 節點 
(1)金鑰交換演算法： 
每一個節點在部署之前都先從 key pool 選擇 k 把金鑰。將 k 把金鑰經由雜湊函數運算，
儲存此雜湊值 H(Kk)以及 key list，並儲存另一金鑰 Kp，所有 node 的 kp 都是一樣的。部署
後所有節點利用 Kp 迅速與鄰近節點建立 pairwise key，當建立完成後則丟棄 Kp。之後所有
傳輸皆使用 pairwise key 做安全的認證及保護。當需要新增節點時，新節點必須預先儲存
key pool 的所有 key，由於每個節點都有儲存 key list 以及 H(Kk)，所以可以利用此來建立安
全的 pairwise key，當 pairwise key 建立完成，新節點必須丟棄所有 key pool 的 key，如下圖
所示。 
 
Figure  6 Node insertion 
 
(2) 認證演算法： 
欲傳送訊息 M 的節點，須先以 pairwise key 來做訊息確認雜湊值，再送出 M 和雜湊值，
當下一個節點收到時可以使用相對應的 pairwise key 來做訊息認證，若認證無誤，則再使用
與下一個節點的 pairwise key 做訊息確認雜湊值，再送出 M 和雜湊值。當接收者收到可以
用相同方式來驗證，其方法如下圖所示。 
 
Figure  7 Authentication algorithm 
 
(3) 安全性分析 
因為使用 Multi-Hop 訊息確認機制，所以可以抵擋非法攻擊者隨意 flooding 的攻擊。 
 
3.2.1.2 Powerful 節點 
(1)金鑰交換演算法： 
使用公開金鑰加密系統，佈署前每個節點 Base Station 產生其公開金鑰及私密金鑰並
儲存之，此外並儲存 Base Station 的公開金鑰。佈署後，欲與鄰近節點建立 pairwise key 則
向 Base Station 取得鄰近節點的公開金鑰，並用此金鑰來做 Key Agreement，產生 pairwise 
key，並用此金鑰建立安全的訊息交換。 
 
(2) 認證演算法： 
利用公開金鑰加密系統的簽章機制，便可以達成節點的認證。資料認證則使用如同 low 
power 節點所使用的演算法 
 
18 
 
Figure  8 Multiple-Application Scenario 
20 
3.3.2 Secure Data Encryption Comparison 
因為 BGN-EXT 只能夠允許 aggregator 對於資料做加法或乘法的聚合，所以我們提出
Secure Data Encryption Comparison(SDEC)，SDEC 可以允許 aggregator 在滿足特定條件下，
對資料做比較大小的動作。在某些特定的應用環境之下，SDEC 可以允許 aggregator 從所收
到的資料中，在不解密的情況之下，找出最大值，並回傳給 base station，而其餘資料則可
以捨棄，以節省傳輸資源，或者 aggregator 可以從眾多加密的封包之中，判斷那些封包的
資料超過設定的範圍，將這些特殊的封包捨棄或回報。在 SEDC 中節點需要二個 random 
n-torsion point P and Q，並計算 ><= QPmenSig ii , , 並將(Ci, Sigi), where Ci 是 mi 的密文, 回
傳給 aggregator，而 aggregator 則沒有 P and Q，但是 aggregator 有 μ, ><= QPen ,μ , 若
aggregator 收到二個一樣的 Sig 代表原來的明文亦相同，證明如下(Figure 9)： 
 
 
Figure 9. proof of SDEC 
 
而利用上面兩個式子，SEDC 的演算法如下(Figure 10)： 
 
 
Figure  10 algorithm of SDEC 
where CH means cluster header, here is aggregator 
 
3.3.3 比較與分析 
Table 4 是將我們的演算法與其它學者所提出來的方法做一個比較，將分別朝
aggregator(cluster head) 是否能夠偽造資料、同一群組的節點是否能夠得知其它節點的資
料、節點是否能夠偽造訊息以及所支援的資料聚合動作。 
22 
4. 參考文獻 
[1] E. Biham and A. Shamir, Differential Analysis of the Data Encryption Standard, Springer-Verlag, 
1993. 
[2] David Wheeler and Roger Needham. Tea, a tiny encryption algorithm. 
http://www.ftp.cl.cam.ac.uk/ftp/papers/djw-rmn/djw-rmn-tea.html , November 1994. 
[3] J. Nechvatal, et. al., Report on the Development of the Advanced Encryption Standard(AES), 
National Institute of Standards and Technology, October 2,2000. 
[4] E. Biham, A. Shamir. Differential Cryptanalysis of DES-like Cryptosystems. Journal of Cryptology, 
Vol. 4 No. 1 1991. 
[5] R.L. Rivest, The RC5 encryption algorithm, CryptoBytes (1) (Spring 1995). 
[6] The RC6 Block Cipher, 3rd AES Workshop, April 2000. 
[7] RossAnderson, EliBiham, and LarsKnudsen. Serpent: A Flexible Block Cipher With Maximum 
Assurance. In The First Advanced Encryption Standard Candidate Conference, Ventura, California, 
USA, 20–22 August 1998. 
[8] Joan Daemen, Lars Knudsen, and Vincent Rijmen. The Block Cipher Square. In Eli Biham, editor, 
Fast Software Encryption ’97, volume 1267 of Lecture Notes in Computer Science, pages 149–165, 
Haifa, Israel, January 1997. Springer-Verlag. 
[9] Bruce Schneier, John Kelsey, Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson. The 
Twofish Encryption Algorithm: A 128-Bit Block Cipher. John Wiley & Sons, April 1999. 
[10] National Institute of Standards and Technology (U.S.), Advanced Encryption Standard. Available at: 
http://csrc.nist.gov/publication/drafts/dfips-AES.pdf  
[11] V. Rijmen, “Efficient Implemenation of the Rijndael S-box”, available at: 
http://www.esat.kuleuven.ac.be/~rijmen/rijn dael/sbox.pdf  
[12] Johannes Wolkerstorfer, Elisabeth Oswald, and Mario Lamberger, “An ASIC Implementation of the 
AES SBoxes,“  
CT-RSA 2002,LNCS 2271,pp. 67-78,2002. 
[13] X. Lai and J. Massey, "A proposal for a New Block Encryption Standard," Advances in 
Cryptology--- EUROCRYPT '90 Proceedings. 
[14] B. Schneier,"Blowfish" ,Fast Software Encryption, Cambridge Security Workshop Proceedings 
(December 1993), Springer-Verlag, 1994, pp. 191-204. 
[15] P. Noo-intara, S. Chantarawong, and S. Choomchuay, "Architectures for MixColumn Transform for 
the AES," Proc. of  Information and Computer Engineering Workshop 2004 (ICEP2004), Prince of 
Songkla University (Phuket Campus), January 2004, pp.152-156. 
[16] Carman DW. Constraints and approaches for distributed sensor network security. Technical Report, 
#00-010, NAI Labs, 2000. 
[17] Jian Yin; Madria, S, SecRout: A Secure Routing Protocol for Sensor Networks, Advanced Information 
24 
[38] R. Zheng, R. Barton, “Toward Optimal Data Aggregation in Random Wireless Sensor Networks,” 
Proc. the 26th Ann. Joint Conf. the IEEE Computer and Comm. Society (INFOCOM’07), pp. 
249-257, 2007. 
[39] S.C.-H. Huang, P.J. Wan, C. T. Vu, Y. Li, and F. Yao, “Nearly Constant Approximation for Data 
Aggregation Scheduling in Wireless Sensor Networks,” Proc. the 26th Ann. Joint Conf. the IEEE 
Computer and Communications Society (INFOCOM’07), pp. 366-372, 2007. 
[40] Z. Ye, A. A. Abouzeid, J. Ai, “Optimal Policies for Distributed Data Aggregation in Wireless Sensor 
Networks,” Proc. the 26th Ann. Joint Conf. the IEEE Computer and Comm. Society (INFOCOM’ 07), 
pp. 1676 – 1684, 2007. 
[41] A. Perrig, J. Stankovic, and D. Wagner, “Security in Wireless Sensor Networks,” Comm. of ACM, vol. 
47, Issue 6, pp.53-57, Jun 2004. 
[42] L. Hu and D. Evans, “Secure Aggregation for Wireless Networks,” Proc. Applications and the Int’l 
Workshops, pp. 384 – 391, Jan 2003. 
[43] H. Cam, S. Ozdemir, P. Nair, and D. Muthuavinashiappan, “ESPDA: Energy-Efficient and Secure 
Pattern Based Data Aggregation for Wireless Sensor Networks,” Proc. 5th IEEE Conf. Sensors, pp. 
732-736, 2003. 
[44] H. O. Sanli, S. Ozdemir, and H. Cam, “SRDA: Secure Reference-Based Data Aggregation Protocol 
for Wireless Sensor Networks,” Proc. IEEE Conf. Vehicular Technology (VTC’04), pp. 4650-4654, 
2004. 
[45] Y. Wu, D. Ma, T. Li, and R. H. Deng, “Classify Encrypted Data in Wireless Sensor Networks,” Proc. 
IEEE Conf. Vehicular Technology (VTC’04), pp. 3236- 3239, 2004. 
[46] D. Westhoff, J. Girao, and M. Acharya, “Concealed Data Aggregation for Reverse Multicast Traffic 
in Sensor Networks: Encryption, Key Distribution, and Routing Adaptation,” IEEE Trans. Mobile 
Computing, Vol. 5, pp. 1417-1431, Oct 2006. 
[47] J. Girao, M. Schneider, and D. Westhoff, “CDA: Concealed Data Aggregation in Wireless Sensor 
Networks,” Proc. ACM Workshop on Wireless Security (WiSe’ 04), Oct. 2004. 
[48] E. Mykletun, J. Girao, and D. Westhoff, “Public Key Based Cryptoschemes for Data Concealment in 
Wireless Sensor Networks,” IEEE International Conf. Communications (ICC '06), pp. 2288-2295, 
2006. 
[49] C. Castelluccia, E. Mykletun, G. Teudik, “Efficient Aggregation of encrypted data in Wireless Sensor 
Networks,” Proc. of Second Ann. Int’l Conf. Mobile and Ubiquitous Systems: Networking and 
Services (MobiQuitous), pp. 109-117. Jul 2005. 
[50] L. Luo, R. Safavi-Naini, J. Baek, and W. Susilo, “Self-organised group key management for ad hoc 
networks,” Proc. the 2006 ACM Symp. Information, computer and comm. security, pp. 138-147, 
2006. 
[51] A. C-F. Chan, “Distributed symmetric key management for mobile ad hoc networks,” Proc. the 23th 
Ann. Joint Conf. the IEEE Computer and Comm. Society (INFOCOM’ 04), pp. 2414-2424, Mar 
2004. 
[52] W. He, X. Liu, H. Nguyen, K. Nahrstedt, and T. Abdelzaher, “PDA: Privacy-Preserving Data 
Aggregation in Wireless Sensor Networks,” Proc. the 26th Ann. Joint Conf. the IEEE Computer and 
Comm. Society (INFOCOM’ 07), pp. 2045-2053, 2007. 
[53] M. Acharya, J. Girao and D. Westhoff, “Secure Comparison of Encrypted Data in Wireless Sensor 
Networks,” Proc. Third Int’l Symp. Modeling and Optimization in Mobile, Ad-Hoc and Wireless 
Networks (WiOpt'05), pp. 47-53, Oct, 2005. 
[54] R. Agrawal, J. Kiernan, R. Srikant and Y. Xu, “Order Preserving Encryption for Numeric Data,” Proc. 
the 2004 ACM SIGMOD, pp. 563-574, 2004. 
[55] D. Boneh, Eu-Jin God, and Kobbi Nissim, “Evaluating 2-DNF Formulas on Cipertexts,” Proc. 
Theory of Cryptography Conf. (TCC 2005), Vol. 3374 of LNCS, pp. 325-321, Jan 2005. 
[56] L. C. Washington, Elliptic Curves – Number Theory and Cryptography, Chapman & Hall/CRC, 
2003. 
26 
5. 計劃成果自評 
5.1 加密套件演算法 
目前我們主要完成的部分是加密的演算法以及其硬體設計，其他週邊加密套件可架構
在此演算法之上，諸如: 
1. 單向雜湊函數(One Way Hash function) 
2. 亂數產生器(Random Number Generation) 
3. 大數運算器(使用非對稱加密時) 
重複利用已有之硬體，目標是將體積減少到最小，同時維持安全性，兼顧效率以及電力消
耗。 
 
5.2 Routing protocol 
目前我們主要完成的部分是金鑰交換與認證演算法以及其軟體設計，大部分網路架構
及環境可採用我們提出的演算法來確保安全性，包含資料完整性、保密性、認證性…等安
全性要件。 
 
5.3 Secure data aggregation 
我們對於資料聚合的安全性不足的問題提出一套安全的資料聚合演算法，可以解決任
意一個未經授權的節點傳送不實的訊息，影響資料聚合的結果，同時我們的演算法具有 PH
特性，允許 aggregator 在無法解密的情況下，對於所收到的密文做聚合動作，另外我們提
出 SEDC 演算法來增進我們資料聚合演算法的能力，SEDC 可以使 aggregator 分辨封包的大
小，找出最大值或是將不落在範圍內的資料捨棄(或回報)，以增加資料聚合的能力，減少能
源消耗。 
28 
可供推廣之研發成果資料表 
□ 可申請專利  ■ 可技術移轉                                      日期： 年 月 日 
國科會補助計畫 
計畫名稱：通用無線感測器平台的研發--子計畫四無線感知網路之
安全問題研究 (1/3) 
計畫主持人：孫宏民 
計畫編號：NSC 93-2213-E-007-102 學門領域： 
技術/創作名稱 金鑰管理演算法 
發明人/創作人 孫宏民, 林岳勳, 陳炯勳 
中文：提供一套適用於無線感測網路上的金鑰管理, 可確保節點於
部署之後的通訊可以受到加密演算法的保護以及認證, 同時我們
的演算法亦允許網路建好之後, 再新增節點且必須經過認證之後
才可加入網路 
 
技術說明 英文：We propose an algorithm of the key management in wireless 
sensor network. The nodes could use the key to protect the 
communication in network and authenticated by the key. Additionally, 
our algorithm can achieve that adding a new node to the network and 
authenticating it. 
可利用之產業 
及 
可開發之產品 
居家保全, 及需要安全性的無線網路 
技術特點 
金鑰管理演算法, 可於網路一開始部署時, 認證節點身份合法性, 
並於之後隨時新增節點, 並認證該節點的身份 
推廣及運用的價值 
若無線感測網路有需要安全性上的考量時, 即需要加密演算法的
保護, 因此金鑰管理演算法可提供一個可行性的方式,在感測器的
硬體限制下, 成功部署金鑰並供加密演算法使用 
 
30 
a fast block cipher using symmetric key. The initiation 
of AES was announced by the National Institute of 
Standards and Technology (NIST) in January, 1997. 
After a series of evaluation, Rijndael [12][13] 
developed by Joan Daemen and Vincent Rijnment was 
selected by NIST as new encryption standard in 
October, 2000 [15][18]. AES is iterated with Boolean 
transformation applied to the plaintext block called 
state. Recently, various hardware implementations of 
AES showed good performance and suitable for 
wireless applications. 
2.1 AES Polynomial Multiplication 
Polynomial multiplication in AES corresponds 
with multiplications of polynomials modulo an 
irreducible polynomial of degree 8. By default setting, 
this irreducible polynomial is m(x) = x8 + x4 + x3 + x + 
1. For example, {57} • {83} = {C1}, where ‘•’ denotes 
polynomial multiplication in GF(28).  
First we have binary representation of {57} as 
{01010111}2, which stands for (x6 + x4 + x2 + x + 1). 
Polynomial multiplication is computed by 
 
(1)      1)  x   x  x (x modulo 1)   x (x
 1  x   x  x  x  x  x  x  x  x
 1)  x  (x 1)  x   x  x (x
34867
3456891113
7246
++++++=
+++++++++=
++++++
 
 
One can easily verify that {57} • {01} = {57} where 
{01} is the identity. If given two polynomials and their 
multiplications over an irreducible polynomial equals to 
the identity element, for example {DE} • {90} = {01}, 
they are inverses of each other. 
 
2.2 AES Equivalent Round 
Each round of AES has an equivalent format 
which outputs exactly the same ciphertext; that is, we 
can change the order of SubBytes and ShiftRows. The 
standard AES round is as follow: 
 
AES-round ( ) { 
 SubBytes (state); 
 ShiftRows (state); 
 MixColumns (state); 
 AddRoundKey (state, RoundKey); 
} 
SubBytes transformation operates on each byte of 
current state, and ShiftRows only change their positions 
among rows. We can rearrange their order and have 
equivalent round as follow:  
 
Equivalent-round ( ) { 
 ShiftRows (state); 
 SubBytes (state); 
 MixColumns (state); 
 AddRoundKey (state, RoundKey); 
} 
 
Then, we merge SubBytes and MixColumns into a new 
transformation called SubMix. Thus, encryption 
requires only three stages. 
 
MAES-round ( ) { 
 ShiftRows (state); 
 SubMix (state); 
 AddRoundKey (state, RoundKey); 
} 
 
2.3 MixColumns Transformation 
MixColumns substitutes and permutes data at the 
same time to achieve high diffusion property. During 
MixColumns transformation, columns are considered as 
polynomials over GF(28) and multiplied with a fixed 
polynomial a(x) under x4+1, given by  
 
(2)  {02}.{01}x{01}x{03}x  a(x) 23 +++=  
 
Let S0,c denotes the first byte of column c, S’0,c 
after MixColumns and S2,c ~ S3,c respectively. Each 
column then multiplies the rotations of a(x). This can 
be written as a matrix multiplication. 
 
)3(
02010103
03020101
01030201
01010302
,3
,2
,1
,0
'
,3
'
,2
'
,1
'
,0
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
=
⎥⎥
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢⎢
⎢
⎣
⎡
c
c
c
c
c
c
c
c
S
S
S
S
S
S
S
S
 
 
In standard AES, coefficients of MixColumns are 
very simple, but more complicated of InvMixColumns, 
because AES was designed to be also efficient in 
software. The xtime operation means to multiply a 
polynomial x modulo m(x), and can be implemented 
with a shifter and bit-wised XOR. It is a very efficient 
way to compute polynomial multiplications when there 
are more zeros in binary representation of the operand, 
since we only need to shift left iteratively. Obviously, 
computational cost of {37} is much greater than that of 
{03} using xtime computations. 
 
)4(}01{}01{
}03{}02{
,3,2
,1,0
'
,0
•⊕•⊕
•⊕•=
cc
ccc
SS
SSS  
 
If we take a closer look, the portion of S3, c • {01} = S3, c 
doesn’t contributes effort in mixing data if S0, c, S1, c, 
and S2, c are fixed to zeros, then output of this stage is 
exactly same to the input. 
 
In contrast, MAES is designed for hardware where 
table look-up is the fastest way, and computing {37} 
and {03} are the same. Hence, we are allowed to 
choose these polynomials freely. However, a 
polynomial in GF(28)[x] modulo x4+1 doesn’t 
guarantee to have inverse. Even if it has one, its 
bit-wised mapping may not be sufficiently complex 
(measured by hamming weight). We suggest using 
polynomial  
 
(5)  {17} {17}x   {5D}x  {37}xp(x) 23 +++=  
32 
)7(
)SubBytes(
)SubBytes(
)SubBytes(
)SubBytes(
17175D37
3717175D
5D371717
175D3717
,3
,2
,1
,0
'
,3
'
,2
'
,1
'
,0
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
⎥⎥
⎥⎥
⎦
⎤
⎢⎢
⎢⎢
⎣
⎡
=
⎥⎥
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢⎢
⎢
⎣
⎡
c
c
c
c
c
c
c
c
S
S
S
S
S
S
S
S
 
 
According to the Design of Rijndael [13], SubBytes and 
MixColumns have the following property: 
 
(8)                              b(x))  (x)SubBytes(a 
 b(x) ) (x)SubBytes(a
•=
•
 
 
For example, if input s(x) = {01} + {02}x + {03}x2 + 
{04}x3, the value of S0, c after SubMix is computed by 
 
{C2} = {5C} ♁ {E7} ♁ {6E} ♁ {17} =
17)SubByte(04 ♁ 5D)SubByte(03 ♁
37)SubByte(02 ♁ 17)SubByte(01 =
{17} )SubByte(04♁{5D})SubByte(03♁
{37} )SubByte(02♁{17} )SubByte(01 =
) {04} , {03} , {02} , {01} SubMix( = 'S c 0,
••
••
••
••
 
 
Figure 3 Illustration of the SubMix transformation. 
 
SubByte(a(x)•b(x)) can be realized in two different 
ways; one by look-up table, which is faster but requires 
large space, while the other way is bit-wised mapping 
that can be implemented by XOR gates [21], smaller 
but slower. To handle the tradeoff, we attempt to use 
look-up tables for SubMix. 
 
First, if implemented with look-up tables, each 
table requires 256 bytes in size (same as Sbox in AES), 
and we need both 3*256 bytes for encryption and 
decryption. Compare to AES, which needs one table for 
SubBytes, 3*256 bytes for MixColumns and 4*256 
bytes for InvMixColumns. Our result saves 512 bytes 
space in total. Table 1 shows a comparison of sizes 
using look-up table implementations. 
 
Table 1 Comparison of AES and MAES 
 AES MAES 
SubBytes 1 table 0 table 
MixColumns 3 tables 3 tables 
InvSubBytes 1 table 0 table 
InvMixColumns 4 tables 3 tables 
 
Secondly, if implemented with look-up tables, the 
following are bit-wised mapping equations to compute 
multiplication of {DE} with input a(x) = a0 + a1x + a2x2 
+ a3x3 + a4x4 + a5x5 + a6x6 + a7x7 to output a(x)’: 
 
)9('
'
'
'
'
'
'
'
53107
74206
6315
5204
754303
76542102
76543101
64210
 a  a  a aa
  a  a  a aa
  a  a aa
  a  a aa
  a  a  a  a aa
 a  a  a  a  a  a aa
  a  a  a  a  a  a aa
 a  a  a aa
⊕⊕⊕=
⊕⊕⊕=
⊕⊕=
⊕⊕=
⊕⊕⊕⊕=
⊕⊕⊕⊕⊕⊕=
⊕⊕⊕⊕⊕⊕=
⊕⊕⊕=
 
 
3.3 Decryption 
 
As for decryption, its round is slightly different, 
because we perform an extra MixColumns at the end of 
encryption. There needs an InvMixColumns right after 
the first step of decryption --- AddRoundKey to stay 
equivalence. The rest parts of decryption are exactly 
same to the standard AES. It is described in pseudo 
code in Fig 10. 
 
Nr = 7 
Begin 
    state = input 
   AddRoundKey(RoundKey[Last]) 
   InvMixColumns(state) 
   For round=Nr-1 step -1 downto 1 
      InvShiftRows (state) 
      InvSubBytes(state) 
   AddRoundKey (state, RoundKey[round]) 
       InvMixColumns(state) 
    End for 
 
    InvShiftRows(state) 
    InvSubBytes(state) 
    AddRoundKey(state, RoundKey[First]); 
    output = state 
End 
Figure 4 Pseudo code for the inverse cipher 
 
4. Security Analysis 
AES was designed to stand against both linear and 
differential attacks. Linear attack was introduced by 
Mitsuru Matsui [17]. The main purpose of linear attack 
is to find the relationship between input and output. 
Although the probability is quite low, suppose the 
attacker is allowed to choose plaintext and ciphertext 
adaptively (known as adaptive chosen ciphertext attack), 
with sufficient pairs, he is able to recover some parts of 
a round key and perhaps the whole secret key by 
exhaustive search. Differential attacks to DES-like 
ciphers suggested by E.Biham & A. Shamir [11] 
extended from fault attacks [3] analyses the effect of 
differences in plaintext pairs on differences in 
ciphertext pairs. The probabilities discovered will help 
an attacker to extract the most probable key as long as 
there are sufficient chosen plaintext pairs. The standard 
way is to trace a path of high probable differences 
through the various stages of encryption. 
 
34 
attack (to obtain the last round key) will be 5.29*108 
pairs. 
 
As for MAES, let ε = {67}, then we have ε0 = 
SubBytes(ε) = {E6}. After MixColumns transformation, 
difference propagation of the first column are {66}, 
{66}, {65}, and {B9} with a probability less than 
0.006168% and 0.003064% in the last round. Our 
proposed SubMix transformation turns out to be as 
strong as standard AES.  
 
5. Implementation 
 
Due to the limited resources including power 
supply and area on wireless sensor network nodes, we 
will introduce some techniques we use in the design of 
MAES to achieve the goals of reduced power and low 
gate count in this section. 
 
After the analysis of overall AES and modified 
AES, inclusive of encryption, decryption, and key 
expansion, some portions of these three algorithms 
should be focused to implement an efficient design with 
lower power consumption and lower gate count.  
 
Firstly, as to the key expansion part, two methods 
including pre-computation method and on-the-fly key 
schedule method [6] are usually used to generate round 
keys. On-the-fly key schedule first generates the 
expanded keys from the Cipher key and then decides 
the round key of each round. Each round key is used 
when it is generated, so it is not necessary to use 
storage elements to store keys as what pre-computation 
method does. Under the concern of area and power, 
on-the-fly key schedule is adopted. 
 
Secondly, the most critical part and power-hungry 
part of AES and MAES are (1) SubBytes in key 
expansion and encryption round functions, and (2) 
InvSubBytes in decryption round functions [26] [2]. We 
use Galois field arithmetic [16] to complete the 
operations under the consideration of timing and area. 
 
5.1 Area Reduction Techniques 
There are many methods that can be used to 
implement Sbox. The better way is using the Galois 
field arithmetic [16] [9] under the consideration of 
performance and area. One operation of SubBytes is 
calculating the multiplicative inverse over GF(28). 
However, it is quite complex to compute directly, 
therefore we first transform it from GF(28) to GF((24)2) 
and then we can use inverter in GF((24)2). Since the 
polynomial x8 + x4 + x3 + x + 1 ({11B} in hexadecimal 
form) used in AES and MAES is not a primitive 
irreducible polynomial, we had better use isomorphism 
before and after the implementation of GF((24)2) 
inverter. In GF((24)2), the primitive irreducible 
polynomial x8 + x4 + x3 + x2 + 1 ({11D} in hexadecimal 
form) is a better basis. The isomorphism function from 
GF(28) to GF((24)2) is B as shown in Equation 12 [16] 
[25] and the isomorphism function from GF((24)2) to 
GF(28) is B-1 as shown in Equation 13 [16] [25]. 
 
)12(
10001110
01100000
01000001
00101000
00001110
01001011
00110101
00000101
'
'
'
'
'
'
'
'
0
1
2
3
4
5
6
7
0
1
2
3
4
5
6
7
⎥⎥
⎥⎥
⎥⎥
⎥⎥
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢⎢
⎢⎢
⎢⎢
⎢⎢
⎢
⎣
⎡
⎥⎥
⎥⎥
⎥⎥
⎥⎥
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢⎢
⎢⎢
⎢⎢
⎢⎢
⎢
⎣
⎡
=
⎥⎥
⎥⎥
⎥⎥
⎥⎥
⎥⎥
⎥
⎦
⎤
⎢⎢
⎢⎢
⎢⎢
⎢⎢
⎢⎢
⎢
⎣
⎡
b
b
b
b
b
b
b
b
b
b
b
b
b
b
b
b
 
36 
 
(2)AND gate 
 
(3)OR gate 
 
Figure 12 Propagation probabilities of signal transitions 
 
As shown in Figure 14, composite field Sbox and 
Inverse Sbox are divided into three blocks to reduce the 
probabilities of signal transitions [2]. In addition, the 
two-level logic, i.e. AND-XOR arrays are used to 
reduce the number of dynamic hazards. 
 
In conclusion, we use the following approaches to 
achieve power reduced Sbox and Inverse Sbox: (1) Use 
composite field Sbox to reduce gate count, (2) Divide 
combinational logic into three stages to reduce the 
probabilities of signal transitions, and (3) Adjust the 
signal timing by using two-level (AND-XOR) logic to 
reduce the number of dynamic hazards. 
 
 
Figure 13.1  Two-level AND-XOR logic 
 
Figure 13.2  Two-level OR-XOR logic 
 
 
Figure 14 3-stage AND-XOR architecture used for 
composite field S-box 
 
Figure 15 shows the key scheduler we use in our 
MAES design [26] [14]. When the encryption routine is 
processed, EN/ DE = 1 and Init_K0 through Init_K3 are 
the Cipher key. In the beginning, Init_K0 through 
Init_K3 are put into K0 through K3, respectively. After 
one clock cycle, 
)]otWord(K3)[SubWord(RRcon[0]K00K ⊕⊕=
K’1=K’0⊕ K1, K’2=K’1⊕ K2, K’3=K’2⊕ K3 and 
the generated K’0 through K’3 become the new K0 
through K3. After another 6 clock cycles, all round keys 
are generated and the final round key are stored in 
registers. Similarly, when the decryption routine is 
processed, EN/DE = 0 and Init_K0 through Init_K3 are 
the final key stored in registers. At first, Init_K0 
through Init_K3 are put into K0 through K3, 
respectively. After one clock cycle, K’3=K2 ⊕ K3, 
K’1=K0⊕ K1, K’2=K1⊕ K2,  
))]otWord(K'3[SubWord(RRcon[0]K00K' ⊕⊕= , 
and the generated K’0 through K’3 become the new K0 
through K3. After another 6 clock cycles, all round keys 
are generated. 
 
Figure 15 Circuit of key scheduler 
 
5.3 Design Flow and Design Environment 
We use cell-based design flow to implement our 
design, since our design belongs to digital logic. To 
perform simulation and synthesis, we utilize some EDA 
tools supplied by CIC (National Chip Implementation 
Center). In the beginning, we write Verilog-HDL 
(Hardware Description Language) codes according to 
the spec. Then we use ModelSim SE to simulate the 
design. The simulation is just to verify the correctness 
of the functions we want to design and the simulation is 
in the phase of RTL (Register Transfer Level) 
38 
References 
[62] A. Satoh, S. Morioka, K. Takano, and S. Munetoh, 
“Unified hardware architecture for128-bit block 
ciphers AES and Camellia”, in Cryptographic 
Hardware and Embedded Systems (CHES) 2003. 
Aug. 2003, Springer-Verlag. 
[63] A. Hodjat, I. Verbauwhede, “Minimum Area Cost 
for a 30 to 70 Gbits/s AES Processor”, IEEE 
computer Society Annual Symposium on VLSI,. 
pp. 83-88, Feb. 2004. 
[64] Boneh, DeMillo, and Lipton, On the Importance 
of Checking Cryptographic Protocols for Faults, 
Lecture Notes in Computer Science, Advances in 
Cryptology, proceedings of EUROCRYPT’97, pp. 
37-51, 1997. 
[65] B. Schneier, et. al. The Twofish Encryption 
Algorithm: A 128-Bit Block Cipher. John Wiley 
& Sons, April 1999. 
[66] B. Schneier, "Blowfish" ,Fast Software 
Encryption, Cambridge Security Workshop 
Proceedings (December 1993), Springer-Verlag, 
1994, pp. 191-204. 
[67] C.-L. Horng, “An AES Cipher Chip Design Using 
On-the-Fly Key Scheduler”, Master Thesis, Dept. 
Electrical Engineering, National Tsing Hua 
University, Hsinchu, Taiwan, June 2004. 
[68] D. Wheeler and R. Needham. Tea, a tiny 
encryption algorithm. 
http://www.ftp.cl.cam.ac.uk/ftp/papers/djw-rmn/d
jw-rmn-tea.html , November 1994. 
[69] D.W. Carman. Constraints and approaches for 
distributed sensor network security. Technical 
Report, #00-010, NAI Labs, 2000. 
[70] E. D. Mastrovito, “VLSI Architecture for 
Computations in Galois Fields”, Ph.D. Thesis, 
Dept of EE, Linköping Univ., Lingköping, 
Sweden 1991. 
[71] E. Trichina, “Combinational logic design for AES 
SubByte transformation on masked data”, IACR 
report, 2003. Available at 
http://eprint.iacr.org/2003/236.pdf. 
[72] E. Biham, A. Shamir. Differential Cryptanalysis 
of DES-like Cryptosystems. Journal of 
Cryptology, Vol. 4 No. 1 1991. 
[73] J. Daemen, L. Knudsen, and V. Rijmen. The 
Block Cipher Square. In E. Biham, editor, Fast 
Software Encryption ’97, volume 1267 of Lecture 
Notes in Computer Science, pages 149–165, 
Haifa, Israel, January 1997. Springer-Verlag. 
[74] J. Daemen and V. Rijmen. AES proposal: 
Rijndael. 
http://csrc.nist.gov/encryption/aes/rijndael/Rijnda
el.pdf, 1999 
[75] J. H. Shim, D. W. Kim, Y. K. Kang, T. W. Kwon, 
and J. R. Choi, “A rijndael cryptoprocessor using 
shared on-the-fly key scheduler”, in Proc. 3rd 
IEEE Asia-Pacific Conf. ASIC, Taipei, Aug. 2002, 
pp. 89–92. 
[76] J. Nechvatal, et. al., Report on the Development 
of the Advanced Encryption Standard(AES), 
National Institute of Standards and Technology, 
October 2,2000. 
[77] J. Wolkerstorfer, E. Oswald, and M. Lamberger, 
“An ASIC Implementation of the AES SBoxes “, 
CT-RSA 2002, LNCS 2271, pp. 67-78,2002. 
[78] M. Matusi, "Linear Cryptanalysis Method for 
DES Cipher." In T. Helleseth, editor, Advances in 
Cryptology - EUROCRYPT'93, Volume765 of 
Lecture Notes in Computer Science, pp.386-397. 
Springer-Verlag, Berlin, Heidelberg, NewYork, 
1994. 
[79] National Institute of Standards and Technology 
(NIST), Advanced Encryption Standard (AES), 
National Technical Information Service, 
Springfield, VA 22161, Nov. 2001. 
[80] National Bureau of Standards, NBS FIPS PUB 46, 
“Data Encryption Standard," National Bureau of 
Standards, U.S. Department of Commerce, Jan 
1977. 
[81] P. Dusart, G. Letourneux, O. Vivolo, Differential 
Fault Analysis on AES, available at: 
http://www.unilim.fr/laco/rapports/2003/R2003_0
1.pdf, 2003 
[82] P. Noo-intara, S. Chantarawong, and S. 
Choomchuay, "Architectures for MixColumn 
Transform for the AES," Proc. of  Information 
and Computer Engineering Workshop 2004 
(ICEP2004), Prince of Songkla University 
(Phuket Campus), January 2004, pp.152-156. 
[83] RSA Laboratories. PKCS #1: RSA encryption 
standard, Version 1.5, November 1993. 
[84] R. L. Rivest. The RC5 Encryption Algortihm, 
Proceedings of Fast Software Encryption 
Workshop 1994, pp. 86-96.  
40 
42 
Table 5 SubMix table of {5D} 
18 e9 d0 61 ad c6 a9 d7 f2 5d 77 6c 1c ca 23 8d 
81 f5 66 b4 73 8e 22 17 f6 2d a0 4c 59 75 e2 e5 
35 fb 0f 80 27 a4 9f 54 9d 28 82 4a 05 9c af 95 
6f 6d b2 02 79 3d 32 8c 88 1d 4f 0a 89 dd 07 6a 
83 a8 e4 c3 9e f4 69 1a b7 cb 97 5a d6 57 03 20 
ea 1f 00 5c 55 a6 e0 34 9b dc b6 71 ce 1b d3 b3 
42 e6 7e 2e 4d 46 15 7d 98 94 ba 0e 0d 43 be c4 
50 fd aa 19 52 04 2c 25 0c 68 26 08 a7 41 f0 f8 
09 b1 40 01 5b 60 c5 2f 8a 92 53 1e 90 e1 24 bf 
ff 12 fc f3 ef 31 e8 91 7f bb 63 c8 49 06 39 7b 
b0 48 96 64 29 d5 3a bc 5f a5 ab 45 b5 da df db 
38 3b 7a 13 a3 70 a1 99 4e d8 78 d4 cd 3c 11 de 
d9 86 67 5e 16 cf d2 30 6e ae 37 f1 93 51 76 2b 
58 f9 8f 2a 74 e7 c2 0b a2 c0 85 3e 9a b8 4b e3 
ed c9 36 fa 7c c1 44 87 d1 ac c7 33 ee 3f 8b 14 
fe 47 cc ec eb 65 10 21 f7 6b b9 56 bd 62 84 72 
 
44 
Round Key  00 00 00 00 
           00 00 00 00 
           00 00 00 00 
           00 00 00 00 
Round 1> 
After ShiftRows  74 20 61 73 
                 69 20 74 68 
                 74 21 69 73 
                 21 73 20 65 
After SubMix      2c 42 1d 71 
                  f6 07 0e ea 
                  ac ec ba 6a 
                  c5 ad 02 8c 
After AddRoundKey  4e 20 7f 13 
                   95 64 6d 89 
                   cf 8f d9 09 
                   a6 ce 61 ef 
Round 2> 
After ShiftRows  4e 20 7f 13 
                 64 6d 89 95 
                 d9 09 cf 8f 
                 ef a6 ce 61 
After SubMix      89 e2 b9 f8 
                  9d f9 24 8e 
                  b1 1d f9 ea 
                  53 62 07 0b 
After AddRoundKey  12 1b 22 01 
                   05 02 bc 75 
                   29 e6 61 11 
                   9a c8 ce a1 
Round 3> 
After ShiftRows  12 1b 22 01 
                 02 bc 75 05 
                 61 11 29 e6 
                 a1 9a c8 ce 
After SubMix      15 c5 68 71 
                  67 87 2b b7 
                  49 a7 a2 92 
                  af a4 9a 7a 
After AddRoundKey  85 ac 9a 7a 
                   f0 eb df b8 
                   7d 68 f5 3e 
                   ff 5e a9 e3 
Round 4> 
After ShiftRows  85 ac 9a 7a 
                 eb df b8 f0 
                 f5 3e 7d 68 
                 e3 ff 5e a9 
After SubMix      fd 85 ff 96 
                  83 f8 56 8f 
                  d7 68 d5 fe 
                  2f a8 12 b3 
After AddRoundKey  13 02 8a e8 
                   85 92 c8 1e 
                   0d 7d 97 10 
                   54 29 a0 98 
Round 5> 
After ShiftRows  13 02 8a e8 
                 92 c8 1e 85 
                 97 10 0d 7d 
                 98 54 29 a0 
After SubMix      e4 90 04 cc 
                  91 ea a5 24 
                  ce 92 34 03 
46 
7.2 A Pair-wise Key Establishment Scheme for Wireless Sensor Networks 
A Pair-wise Key Establishment Scheme for 
Wireless Sensor Networks 
 
Hung-Min Sun, Yue-Hsun Lin, and Shuai-Min Chen 
 
Department of Computer Science 
National Tsing Hua University 
Hsinchu, Taiwan 30055 
 
Abstract --- Random key pre-distribution scheme is a flexible key management scheme for wireless 
sensor networks. Over the past years, numerous studies have been proposed. However, most of them have 
some weaknesses. The major weakness is that each sensor node demands large storage to maintain high 
connectivity. Another weakness is that attacks from compromised sensor nodes can not be completely 
eliminated. In this paper, we propose a new pair-wise key establishment scheme based on the combination of 
a small key pool and the pigeon-hole principle. We ensure that the pair-wise key for each pair of sensor 
nodes is different from the others. Therefore, attacks from compromised sensor nodes will never occur. We 
also reduce the storage and maintain high connectivity simultaneously. Most significantly, we achieve the 
merit of fully connectivity which means that each sensor node can build secure relations with all of its 
neighbors. Our scheme is energy-efficient in contrast to the previous works. Finally, simulations on 
connectivity and average length of path built in path-key phase are also conducted. 
 
 
INTRODUCTION 
Wireless sensor networks (WSNs) is a new issue in wireless networks. It is usually employed in 
human unreachable environments, such as a hostile area or a disaster area. Sensor nodes in WSNs 
are responsible for data-collection, temperature sensing, monitoring the situation it locates, and so 
on. In general, sensor nodes have the constraints on low power rate, short radio emission range, 
short life time, and limited bandwidth. Sensor nodes can also be added dynamically after 
deployment or replaced if they are failed or unreliable.  
Security is one of the most important subjects for WSNs. Failing to meet the security 
standard may result in catastrophic events. Several security threats [2, 14] have been reported on 
WSNs. Attacks like modifying data packets, stealing critical information by capturing sensor 
nodes or destroying network topology by wormhole attacks are critical and should be avoided by 
a secure WSN framework.  
To prevent data from being eavesdropped, one could encrypt data before transmitting it. 
Since the processor and memory of a sensor node is not powerful enough, we should adopt a 
lightweight cryptosystem to ease the sensor node’s work load. Specifically, it is suitable to adopt 
symmetric cryptosystems [15] instead of asymmetric cryptosystems [11]. 
Knowledge of how to deploy keys in sensor nodes, known as the key agreement problem, is 
very important in a secure WSN. Generally, there are three types of key agreement schemes: 
trusted-server scheme [19], self-enforcing scheme [4], and key pre-distribution scheme [3, 5, 7]. 
In this paper, we focus on the key pre-distribution scheme since this approach is appropriate for 
employing symmetric cryptosystems and the others are more suitable for using asymmetric 
cryptosystems. In the key pre-distribution scheme, key information has to be installed into sensor 
nodes before deployment.  
If we have the prior-knowledge of the network deployment, we can pre-distribute the keys 
into a sensor node according to its geographic position. However, in some applications, sensor 
nodes in WSNs are randomly deployed and there is no prior-knowledge about sensors’ location. 
Therefore, an effective solution is to employ the random key pre-distribution scheme [7]. 
In the random key pre-distribution scheme [7], the base station first generates a large key 
pool and each sensor node randomly selects a subset of key pool before deployment. After 
deployment, two sensor nodes arbitrarily selected may probably share the same keys and the 
48 
compromised sensor nodes is less than λ . Recently Du et al. [5] proposed a pair-wise key 
establishment scheme combined with randomly pre-distribution policy. Generalizing Blom’s 
scheme in which a single key space is used, Du et al. extended Blom’s idea to multiple key 
spaces. Each sensor node randomly selects τ  key spaces from ω  key spaces. After 
deployment, if any two sensor nodes carry key information from the same key space, they can 
compute their pair-wise key. 
Hwang and Kim [10] used the giant component theory [8, 13] to review the previous three 
schemes [3, 5, 7]. The giant component theory showed that even if the degrees of sensor nodes 
are small, most of the sensor nodes in the network can be connected. Based on the theory, they 
showed that they can reduce memory requirement by sacrificing a small number of isolated 
sensor nodes. These isolated sensor nodes are useless in the network since they are disconnected 
from the other sensor nodes.  
The proposed scheme 
In this section, we describe our proposed scheme which includes three phases: (A) Key 
Pre-deployed phase (B) Initialization phase and (C) Phase for adding new sensor nodes. The 
following notations are used throughout this paper. 
 
Before going further into our scheme, we state some assumptions here. A trusted server TS 
exists in our architecture. For a WSN, TS often is the base station and plays the role of a trusted 
dealer. 
Key Pre-deployed Phase 
During the key pre-deployed phase, TS  needs to assign key information into each sensor node. 
At the beginning, TS chooses n keys from the key space S as the key pool. Then TS generates a 
set of all possible key lists, denoted by L(n, m), where ⎥⎦
⎥⎢⎣
⎢ += 1
2
nm . For example, TS generates 
the set L(3, 2) = {(1, 2), (1, 3), (2, 3)}. After generating L(n, m), TS randomly chooses one key 
list from L(n, m) for each sensor node, and then stores those keys in the key list into each sensor 
node and removes the selected one from L(n, m). For instance, TS chooses one key list L[k] = (1,3) 
for sensor node k and removes L[k] from L(n, m). After that, TS stores the related key set {K1, K3} 
into sensor node k. We also call the key set {K1, K3} as the key ring of sensor node k. 
Subsequently, TS assigns an identity key into each sensor node. TS randomly chooses a key 
set R from the key space S excluding the prior-chosen n-key pool. The size of R must be greater 
than or equal to the number of sensor nodes in the whole sensor network. Assume R is of the 
form: R = {R1, R2, R3, R4, …, Ri}, i ≧ N, N is the size of network. Ri is the identity key of the 
sensor node i, and it means that an adversary cannot forge Ri until he captures sensor node i. 
With the above deployment, we can guarantee two properties: 
 
Notation Description 
n
mC  
The number of ways of picking m unordered outcomes 
from n possibilities. [24] 
L(n, m) The set of combinations of m numbers out of {1, …, n} 
L[k] The key list of sensor node k which is chosen from L(n, m) 
Ri The identity key of sensor node i 
|| Concatenation operation 
H(M) The hashed value of M, H is a one-way hash function 
EKi(M) The encrypted content of M using symmetric key Ki. 
S The total key space. 
N The network size, in sensor nodes. 
IDi The identity of sensor node i. 
50 
adding new sensor nodes is necessary. It’s important to kwon how to add new sensor nodes, 
securely. Here we propose a method for adding new sensor nodes into the deployed network.  
First we describe the key pre-deployed phase for a new sensor node. Assuming sensor node 
u is a new sensor node, TS randomly chooses one key list L[u] for node u from the updated L(n, m) 
after the key pre-deployed phase, and then updates L(n, m) by removing L[u]. Next TS picks the 
remaining and unused identity key Ru in set R. TS stores L[u] and Ru into sensor node u. The only 
difference from the key pre-deployed phase is that sensor node u needs to store all the n keys 
instead of m keys. After deployment, we assume sensor node u is deployed nearby sensor node i. 
Notice that sensor node i has already been deployed. After that, the new sensor node u begins 
building secure association with its neighborhood, including sensor node i. 
Step 1 (Identity key exchanging): 
At the beginning, sensor node u broadcasts its IDu and a joining request (NJR) to its 
neighborhood. Once sensor node i receives the joining request, it encrypts its node IDi and 
identity key Ri with key Vi, which is generated in the initialization phase. Then sensor node i 
reply to u with the encrypted content EVi(IDi || Ri) and its key list L[i]. After receiving the 
message, sensor node u obtains Ri since it can generate Vi by hashing the related keys from 
L[i]. Note that sensor node u keeps all n keys at this stage. For example, if L[i] = {1, 5, 7, 8}, 
sensor node u can use H(K1||K5||K7||K8) = Vi to decrypt it and get Ri. Note that node u can 
confirm that node i indeed computed Vi through checking IDi. Next, sensor node u uses Vi to 
encrypt its IDu and Ru and sends the message EVi(IDu || Ru) to sensor node i. Similarly, sensor 
node i retrieves Ru and IDu after it has received EVi(IDu || Ru). The purpose of IDu is to 
confirm that sensor node u really computed Vi. At this point, the two sides have already 
exchanged their identity key in a secure way. 
Step 2 (Computing the link key) 
After exchanging their identity keys, sensor nodes u and i can generate their secure link key 
Kui by hashing with Vi and Ru (e.g., H(Vi||Ru)= Kui).  
 
Fig. 2 illustrates the phase for adding of new nodes. After sensor node u sets up all the link 
keys with its neighbors, sensor node u uses the hash function to calculate Vu through Eq.(A.1). 
Sensor node u then drops all n keys it took and completes the protocol.  
In fact, every new sensor node needs to store n keys initially. Someone may criticize that 
there are too many keys to store in a new sensor node. However, the key pool size n can be small 
and m is almost half of n, the storage required for a new sensor node is just twice that required in 
the initialization phase. Such an approach makes new sensor nodes to preserve the same full 
connectivity feature as the deployed sensor nodes in the initialization phase. Therefore, after 
these three phases, a WSN is secure and fully connected. 
analysis of the proposed scheme 
We analyze our scheme in the aspects of security, connectivity, and average length of path built 
in path-key establishment phase. Furthermore, we also compare our scheme with three 
well-known random key pre-deployed schemes: EG scheme [7], CPS scheme [3] and DDHV 
scheme [5] for each aspect. 
4.1 Security Analysis 
Since an adversary can often mount a physical attack through capturing sensor nodes after 
deployment, we focus on the security resilience against nodes capture here. An adversary can 
read secret information from the captured sensor nodes. Then he can wiretap partial 
communication between the remaining sensor nodes. To reduce the damage from the above 
attack, our scheme specifies that when each sensor node has finished the initialization stage, it 
will erase all the keys it holds. This avoids the exposing of the original key pool. In addition, the 
secure link keys among each pair of sensor nodes are all different since their identity keys are 
unique. Consequently, such a problem will never occur in our scheme.  
On the other hand, Sybil attack [20] is a famous threat as it injects some malicious nodes into 
a deployed WSN. Authentication Property guarantees that each sensor node can authenticate with 
52 
4.2.1 Computing local connectivity when nm 2
1≤  
Based on Property 1, Pactual  is always 1 when we set m greater than half of  n and use L(n, m) 
to generate the all key lists in the key pre-deployment phase. Here we discuss the local 
connectivity when m is less than or equal to half of n. It is obvious that Pactual  is less than 1. 
Indeed, Pactual can be evaluated by Eq. (E.1): 
Pactual  = p{two node has at least one key} = 1-p {any two nodes do not share any key} = 
n
m
mn
m
C
mn
m
n
m
C
C
C
CC
n
m
−−
−≅×− 12/)(1
2
                               
Eq.(E.1) 
In Eq. (E.1), ( nmC *
mn
mC
− )/2 is the number of choices that two sensor nodes choose distinct 
keys. Assume the choices that the first sensor node chooses m keys from the n-key pool is nmC  
and the choices that the second sensor node chooses m keys from the remain (n-m)-key pool is 
mn
mC
− . Since the production is a permutation, the production needs to divide by two. 
n
mCC2 is the 
number of choices that we choose two from all key lists generated by using L(n, m). 
Consequently, we can calculate the probability by using fixed n and variable m. Table 1 shows 
the probability Pactual  by using Eq.(E.1) with different n and m value.  
In Table 1, let us take 30mC  as an example. Here we can find that when m is 8, the local 
connectivity Pactual  is greater than 90%. However, if we want to make a fully-connected network 
(i.e. Pactual = 1), m must be greater than half of n, say m=16. It is easy to find that Pactual  is just 
decreasing by 10%, but the storage of each sensor node can reduce to half. Let us look another 
example. In 200mC  case, Pactual is greater than 90% when m is 21. The value of m is far less than 
half of n (100). The storage can reduce to 20% (21/100). In summary, we can find (1) when m is 
less than or equal to half of n, the local connectivity Pactual  is still high, and (2) when n is larger, 
we can reduce a large storage by trading of a little local connectivity. 
4.2.2 Supportable Maximum Network Size 
Flexibility is an important issue in WSN because adding or replacing sensor nodes is routine. As 
we know, every sensor node needs to carry the key ring in the pre-deployed phase. Therefore, we 
must evaluate the estimation value about how many sensor nodes a WSN has. To increase 
flexibility, our scheme supports an enormous size of network. In our scheme, the supportable 
maximum network size depends on the value of nmC . In fact, 
n
mC  is the number of all possible 
key lists. Since the storage of sensor node is fixed, we can assume that m is a constant. Therefore, 
if we want to improve the maximum network size, we must increase the value of n (i.e. 52
10
2 CC > ). 
As we describe in Section 4.2.1, the local connectivity might not be degraded significantly when 
we choose a larger n. For example, the local connectivity Pactual of 6020C  is 99.99% and 
100
20C  is 
99.34%. Pactual decreases by 0.65% but 2010020 10*5=C  is far greater than 156020 10*4=C . 
Compared to other schemes, our scheme can support a greater network than EG and CPS. In 
EG scheme, each sensor needs to store 350 keys if we want to support a WSN of 2,000 sensor 
nodes. In the q-composite scheme of CPS (q=2), each sensor is required to store 350 keys if we 
want to support a WSN of 2,500 sensor nodes. Multi-path key reinforcement in CPS can support 
more than 9,000 sensor nodes when each sensor node stores 350 keys. In our scheme, we can 
support 167,960 nodes when each node only stores 11 keys. ( 960,1672011 =C ).  
Analysis of Average Path Length in Path-Key Establishment Phase 
A path key is assigned to a pair of sensor nodes in communication range that do not share any key. 
54 
our scheme with EG, CPS, and DDHV. We measure the storage requirement in each sensor node 
under different local connectivity. Table 2 shows the results. For EG scheme (P=10,000, P is the 
key pool size), each sensor node must store at least 83 keys when the local connectivity is greater 
than 0.5. For CPS, it needs to store at least 92 keys. However, our scheme just needs only 37 keys. 
We can find that each sensor node needs τλ )1( +  keys in DDHV scheme since the storage 
overhead is not affected by the local connectivity. λ  cannot be too small due to the security 
reason. We set 50=λ  and τ =2, so the DDHV stores (50+1)*2 = 102 keys. In addition, the 
storage overhead of our scheme grows slowly when local connectivity grows. Each sensor needs 
to store 41 keys in our scheme when the local connectivity is greater than 0.9. In the contrary, the 
storage overheads in the other schemes are all greater than 100 keys. It proves that our scheme 
outstands in storage requirement. 
Communication Overhead 
We use LEACH protocol [10] to evaluate the energy cost in our scheme. The LEACH protocol, 
calculates the energy cost by the following formula: 
1. When sensor sends the messages. 
2***),(
),()(),(
dkEkEdkE
dkEkEdkE
ampelecTx
ampTxelecTxTx
+=
+= −−  
2. When sensor receives the messages. 
kEkE
kEkE
elecRx
elecRxRx
*)(
)()(
=
= −
 
Note that k is the bit length of the transmission message, and d is the distance between the 
sender and the receiver (the unit is meter). We state some environment parameters such as the 
packet header, key length, length of node identity, and etc. Table 3 shows those environment 
parameters. 
Based on the same local connectivity, we compare the communication cost of our scheme 
with EG, CPS, and DDHV schemes. In EG, CPS, and DDHV schemes, we can measure the 
communication overhead in shared key discovery phase [3], [5], [7]. In our scheme, we measure 
the cost of the initialization phase. The shared key discovery phase is similar to the initialization 
phase in our scheme since all sensor nodes built secure links after shared key discovery phase. 
First, we evaluate the EG scheme, the communication cost is related to the size of key ring of 
each sensor node. If the key ring size is k, each sensor needs to broadcast a list ( ) kiEKi ,,1, L=α , 
where α is a challenge. Here we assume the encrypted challenge is 128 bit. In CPS scheme, the 
communication cost is similar to EG scheme since the q-composite scheme is modified from EG 
scheme. It should be noticed that the sender uses broadcast communication in EG and CPS 
scheme. In DDHV scheme, each sensor node needs to broadcast the indices of the space it carried. 
After it found the common key space, it will send the seed of the column of matrix in a unicast 
way. We can assume the size of the seed is the same as the key length.  
Fig. 5 shows our proposed scheme is more energy-saving compared to EG and CPS scheme 
since the later two need more energy to maintain a higher connectivity. DDHV scheme is little 
better than our proposed scheme since DDHV scheme just transmits a seed. 
Simulations 
In this section, we examine the proposed scheme by simulation. Our simulation is divided into 
two parts: (1) Connectivity Test (2) Average length paths in Path-Key establishment. The first 
simulation result can verify the local connectivity evaluated by Eq.(E.1). The second simulation 
is for testing the correctness of our path-key establishment model. 
First we state some parameters in the simulation environment: N is the total number of 
sensor nodes in a WSN network and r is the radio of communication range. If the deployed range 
56 
REFERENCES 
[1] R. Blom. “An optimal class of symmetric key generation systems,” Advances in Cryptology: 
Proc. of EURICRYPT 84, Lecture Notes in Computer Science, pp. 471–486, 1993. 
[2] D. Carman, P. Kruus and B. Matt, “Constraints and Approach for Distributed Sensor 
Network Security,” Comm. of the ACM, vol. 47, Number 6, pp. 53–57, 2000. 
[3] H. Chan, A. Perrig and D. Song, “Random Key Predistribution Schemes for Sensor 
Networks,” Proc. IEEE Symposium on Security and Privacy, pp. 197–213, May. 2003. 
[4] W. Diffie and M. E. Hellman, “New directions in cryptography,” IEEE Trans. on 
Information Theory, Vol. 22, pp. 644–654, Nov. 1976 
[5] W. Du, J. Deng, Y. S. Han and P. K. Varshney, “A Pair-wise Key Pre-distribution for 
Wireless Sensor Networks,” Proc. 10th ACM Conf. Computer and Communications Security, 
pp. 42–51, Oct. 2003. 
[6] W. Du, J. Deng, Y. S. Han and S. Chen, “A Key Management Scheme for Wireless Sensor 
Networks Using Deployment Knowledge,” Proc. INFOCOM’ 2004, 2004. 
[7] L. Eschenauer and Virgil .D. Gligor, “A Key-Management Scheme for Distributed Sensor 
Networks,” Proc. 9th ACM Conf. on Computer and Communications Security, pp. 41–47, 
Nov. 2002. 
[8] P. Erdos and A. Renyi, “On the evolution of random graph,” Publ. Math. Inst. Hungar. Acad. 
Sci., vol. 5, pp. 17–61, 1960. 
[9] S.I Huang, “Adaptive Random Key Distribution Schemes for Wireless Sensor Networks,” in 
Int. Workshop on Advanced Developments in Software and Systems Security, Dec. 2003. 
[10] J. Hwang and Y. Kim, “Revisiting Random Key Pre-distribution for Sensor Networks,”  
Proc. 2003 IEEE Symposium on Security and Privacy, pp. 43–52, Oct. 2004 
[11] W. Heinzelman, A. Chandrakasan, and H. Balakrishnan, “Energy analysis of public-key 
cryptography for wireless sensor networks” Third IEEE International Conf. on Pervasive 
Computing and Communication, pp. 324–328, Mar. 2005. 
[12] W. Heinzelman, A. Chandrakasan, and H. Balakrishnan, “Energy-Efficient Communication 
Protocol for Wireless Microsensor Networks,” Proc. 33rd Hawaii Int. Conf. on System 
Sciences 2000, pp. 3005–3014, 2000. 
[13] S. Janson, T. Luczak, and A. Rucinski. Random Graphs. Wiley, 2000. 
[14] C. Karlof and D. Wagne, “Secure Routing in Sensor Networks: Attacks and 
Countermeasures,” First IEEE Int. Workshop on Sensor Network Protocols and Applications, 
pp. 253–275, May. 2003 
[15] C. Karlof, N. Sastry and D. Wagner, “TinySec：A link layer security architecture for 
wireless sensor network,” Proc. 2nd Int.  Conf. on Embedded networked sensor systems, pp. 
162–175, Nov. 2004. 
[16] D. Liu and P. Ning, “Establishing Pair-wise Keys in Distributed Sensor Networks,” Proc. 1st 
ACM workshop on Security of ad hoc and sensor networks, pp. 62–71, Oct. 2003. 
[17] D. Liu and P. Ning, “Establishing Pairwise Keys in Distributed Sensor Networks,” ACM 
Trans. on Information and System Security, Vol. 8, No. 1, pp. 41–77, Feb. 2005. 
[18] C. L. Liu, “Elements of Discrete Mathematics, second edition,” McGraw-Hill Book 
Company, 1985. 
[19] B. C. Neuman and T. Tso. Kerberos, “An authentication service for computer networks,” 
IEEE Comm. Vol. 32, Issue 9, pp. 33–38, Sep. 1994. 
[20] J. Newsome, E. Shi, D. Song and A. Perrig, “The Sybil Attack in Sensor Networks.” Proc. 
3rd international symposium on Information processing in sensor networks, pp.259–268, 
Apr. 2004. 
[21] R. Di Pietro, L. V. Mancini and J. Radhakrishnan, “Connectivity Properties of Secure 
Wireless Sensor Networks,” Proc. 2nd ACM workshop on Security of ad hoc and sensor 
networks. pp. 53–58, 2004. 
[22] J. Apencer, “The strange logic of random graphs, ” In Algorithm and Combinatorics , 2000 
[23] Y. Wang, “Robust Key Establishment in Sensor Networks." ACM SIGMOD Record, Special 
section on sensor network technology & sensor data management, pp.14–19, Mar. 2004. 
58 
 
 
 
 
 
 
 
 
 
 
)||(||][ iiiV RIDEiL
NJRIDu ||
)||( uuV RIDE i
 
 
Fig. 2.  The flow chart in the phase for adding new nodes.  
Node u is a new node, node i is a deployed node. 
i ji and j builds Kij＇= H(Kij || Ri || Rj)
i j
)||( jjij RIDK
i j
)||( iiij RIDK
i j
][|| iLIDi
][|| jLIDj
 
 
Fig. 1. The flow chart in the initialization phase. 
 
 
Fig. 3. The resilience against node capture. The fraction of communication compromised means the 
fraction of communication which an adversary can eavesdrop. Our scheme can completely eliminate the 
effect led by compromised nodes since our curve is a horizontal line. 
60 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
              
 
 
Fig. 7.  The curve of Pe , average of Pr, Min of Pr, Max of Pr. This shows that the error between Pe 
and the average of Pr is small, and the biggest error is under 2%. The simulation value Pr is close to our 
estimated value Pe. 
62 
 
 
 
 
 
TABLE  4 
THE SIMULATION AND ESTIMATED PROBABILITY (%) 
n=60 m= 9 10 11 12 13 14 15 
Pe 75 85.71 90.00 95.00 97.22 98.61 99.35 
Avg. Pr 77.17 86.29 91.29 94.98 97.39 98.41 99.25 
Min. Pr 75.42 85.56 90.43 94.63 97.08 98.12 99.03 
Max. Pr 78.89 87.28 92.08 95.22 97.92 98.66 99.61 
 
*This table shows Pe , Avg. Pr, Min. Pr, and Max. Pr. Pe is the probability evaluated by equation 1. Avg. 
Pr  is the average probability of 10 times simulation results. Min. Pr is the minimum probability of 10 
times simulation results. Max. Pr is the maximum probability of 10 times simulation results.  
TABLE 5 
THE SIMULATION DATA 
C(30, 7) 
R=0.05 2-PATH 3-PATH 4-PATH
> 4 
PATH 
Max 
path 
length 
Avg. 
length of 
path-key 
N=500 
D=3.79 87.59% 10.9% 0.64% 0.126% 32 2.39 
N=1000 
D=7.49 87.73% 11.57% 0.53% 0.107% 17 2.13 
N=1500 
D=11.25 87.94% 11.93% 0.082% 0.023% 8 2.121 
N=2000 
D=15.04 88.04% 11.9% 0.06% 0% 4 2.12 
N=2500 
D=18.51 88.10% 11.88% 0.02% 0% 4 2.119 
N=3000 
D=22.55 88.11% 11.89% 0% 0% 3 2.118 
estimated 87.5% 10.94% 1.37% 0.153%  2.142 
 
*This table shows the average length of paths built in the path-key phase. It also shows the proportion of 
2-hop, 3-hop, 4-hop and more than 4-hop length path in path-key establishment. N is the size of network, 
in node. D is the network density which is the average number of neighbor in a network.  
出席國際學術會議報告 
出席人員：王景行 
國立清華大學資訊工程學系  博士班學生 
會議名稱：Twenty-first International Conference Image and Vision Computing New Zealand 
IVCNZ 2006 
一、參加會議經過 
IVCNZ 2006 是本會議舉行以來的第 21 屆，於 2006 年 11 月 27 日至 29 日在紐西蘭
Great Barrier Island，由奧克蘭大學主辦。 
本人於此次會議中發表的論文為“VQ-Based Data Hiding in Images by Minimum 
Spanning Tree＂，於 11 月 27 日上午之 Session 1 報告。 
除了 Session 1 之外，本人也出席了其他 session (Signal/Image Processing，Security，
Visualisation and Graphics，3D，Application，Bio-medical Imaging，Recognition and 
Detection，Motion/Image Processing，Stereo ) 以及 keynote speech，以期瞭解目前世界上
各個研究單位在影像暨應用領域最新的研究方向以及成果。 
二、與會心得 
IVCNZ 的規模年年增長，雖然大部份的與會者皆來自澳紐兩地，但亦不乏日本，韓
國，荷蘭，中東，等地的研究員參與，目前世界各地學者在影像及應用研究仍然持續地
在創新以及進展中。 
影像處理不再局限於技術上的處理，很多學者在會上提出了不少應用性的議題。這
些應用包括停車場出入口自動收費，刑事偵訊設備，以及指膜辨認系統等應用性論文。
這對我在技術應用上有更進一步的思考。 
在論文報告中，少不免緊張焦慮，加上用英語與外國學者對談，更是壓力倍增。是
次會議給予我一個良好的機會面對這樣的困難。加上與國外學者的對談中，開拓了不少
學術上的視野。 
