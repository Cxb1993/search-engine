I 
 
 
摘    要 
在本計畫期末報告中，我們提出在單方向星狀圖(the unidirectional n-star graph; 
USn)中任意兩點間的路由演算法。主要是藉由可行路由循環結構(feasible routing cycle 
structure)，來實現我們的路由演算法。我們將證明得到的路由路徑可以有效率地完成
任意兩點間的路由，推導出單方向星狀圖(USn)的直徑(diameter): 當 n ≥ 5 時，不會超
過 2n。並且證明我們演算法的時間複雜度為 O(n2)。這個結果比起 Day 和 Tripathi 所
提出的分散式路由演算法(DRA)有顯著的進步(其最大路由距離為 5n-9)，而且相對於先
前已知的單方向星狀圖直徑明顯的更接近最佳解。此外，我們也針對 5 ≤ n ≤ 12，以
Bread-first algorithm(以寬廣為先之窮舉法)撰寫程式找出最佳路由路徑，發現我們推導
出單方向星狀圖(USn)的直徑與程式計算出的結果相同。 
關鍵詞：平行與分散式處理、交互連結網路、星狀圖、路由、排列之循環結構 
 
ABSTRACT 
In this project, we propose a routing algorithm between any two nodes in the 
uni-directional star graph upon the specific cycle representation, called the 
feasible routing cycle structure (RCS). We prove that the feasible routing path can 
accomplish the routing effectively in the unidirectional n-star graph USn, and also 
derive that the diameter is no more than 2n for n ≥ 5 in USn. We also show that 
our routing algorithm could be performed in time O(n2). The result shows a great 
improvement to the corresponding result of distributed routing algorithm (DRA) 
proposed by Day and Tripathi (the maximal routing distance is 5n-9 in USn). That 
is, the previous known bound for the diameter of USn is substantially improved. 
Moreover, the upper bound of the maximal routing distance is the same as the 
calculated diameters for 5 ≤ n ≤ 12 in USn. 
Keywords：Parallel and distributed computing；interconnection networks；star 
graph；routing；cycle structure of permutations 
1 
 
1. 前言  
隨著超大型積體電路(VLSI)技術的發展，目前已經有辦法建構一數千個處理器
(processors)的大型平行及分散式系統(parallel and distributed system)，如 Connection 
Machine[1]便包含了 216 個處理器。在設計一個大型的平行及分散式系統時，連結網路
(interconnection network)的拓樸結構(topology)是一個關鍵議題，因為系統的效能往
往受到連結網路的 topology 所影響。因此一些較優異的 topologies 相繼被提出來取代
原有的線性陣列(linear arrays)、二維陣列(two dimensional arrays)及環狀(circular 
rings) topologies，其中最著名的兩個 topologies 為超立方體(Hypercubes)[2, 3]和星狀
圖(Star graphs)[4, 5]。超立方體(Hypercubes)和星狀圖(Star graphs)的優勢在於：利用
較少數目的通訊鏈結(communication links)來連接所有的處理器；同時，任兩個處理器
之間的最大傳輸延遲(communication delay)相對較短；而且，擁有對稱性(symmetry)、
高連結性 (connectivity)以及簡單的路由 (routing)策略等；另外，Star graphs 比
Hypercubes 擁有較少的分支度 (degree)和較短的直徑 (diameter)等優勢，因此在
interconnection networks 領域廣受討論，請參見圖一。 
 
圖一 4-star graphs S4 
除了 Star graphs 外，尚有許多對稱性(symmetric) topologies 都是透過凱利圖模型
(Cayley graphic model)[5]來設計與評估，這是因為凱利圖(Cayley graphs)擁有相當多
優良的特性，如擴展性(scalability)、對稱性(symmetry)、高可靠度(reliability)等。目
前常見較有名的 Cayley graphs 包含有：重排圖(Arrangement graphs)[6]、交替群圖
(Alternating group graphs)[7]、(n, k)-星狀圖((n, k)-star graphs)[8, 9]等。其中(n, k)-star 
graphs 為本計劃主持人所提出，它舒解了佈建 Star graphs 連結網路時，節點個數限制
的問題；另外，也證明了(n, n-2)-Arrangement graphs An, n-2 和 n-Alternating group 
graphs AGn 同構(isomorphic)[10]。我們將上述這些 network topologies 的節點數
(number of nodes)、分支度(degree)、直徑(diameter)及連結度(connectivity)整理，請
參見表一。 
3 
 
2. 研究目的  
在過去，Day 和 Tripathi [18]與 Cheng 和 Lipman [20]曾分別針對 star graphs、(n, 
k)-star graphs 提出的導向(orientation)規則，使得 Unidirectional star graphs 和
Unidirectional (n, k)-star graphs 都具有強連通(strongly connected)，以及最高地有向
邊連結性(highest arc-connectivity)，這些性質都顯示出這兩個導向規則的優越性。然
而，這兩個單方向連結網路目前尚無最短路由策略，因此這兩個連結網路的 diameters
仍是 open problems。因此本計劃將針對 Unidirectional star graphs 設計最短路徑路由
(shortest path routing)策略，以求得到這個網路拓樸結構的 diameter 為目標。表二列
舉單方向 Star networks 的對稱性(symmetry)、diameters 和最大路由距離。 
表二 Topological properties of Unidirectional star networks 
 symmetry diameter maximal routing distance 
Unidirectional n-cube none n+1 or n+2 as diameter 
Unidirectional      
alternating group graphs 
UAGn 
node 
symmetry 
≈ 3*(n-2)/2 as diameter 
Unidirectional      
star graphs USn 
none unknown ≤ 5n-9 
Unidirectional      
(n, k)-star graphs USn,k 
none unknown 
≤ 10k-5, for small k 
≤ 5k+5⎣(n-1)/2⎦, for large k 
 
本研究計畫將針對單方向星狀星狀圖(Unidirectional star graphs)探討最短路徑
(shortest paths)問題，並試圖設計最佳的路由策略來推導出 Unidirectional star graphs
的 diameter。連結網路的最大傳輸延遲(maximal communication delay)直接影響連結
網路的效能，因此如何在 nodes 之間找到一條最短的路徑來傳遞訊息是基本的問題。
雖然最短路徑問題對於某些 Star networks 已能有效地解決；然而在單方向拓樸結構
裡，nodes 之間只能透過特定方向的 communication links 來傳送或接收訊息，因此需
要將 communication links 的方向列入考量才能得到最佳的路由策略。 
3. 文獻探討 
目前針對 Unidirectional star graphs 和 Unidirectional (n, k)-star graphs 路由策略
之研究，只有 Day 和 Tripathi [18]與 Cheng 和 Lipman [20]各自在設計架構時提出過
簡單的路由策略。接下來，就他們的做法分別加以簡介。 
在 Unidirectional star graphs 裡，每個 node 都是以符號(symbols)的排列組合來
表示，而兩個 nodes 之間的路由(route)可以視為對符號(symbols)做一連串位置互換
(transpositions)動作。Day 和 Tripathi 針對 Unidirectional star graphs 提出的路由策
5 
 
structures(equivalent cycles transformation)的概念，設計適用於 Unidirectional star 
networks 路由的 routing cycle structures，並設計演算法嘗試產生 shortest routing 
paths，並導出 Unidirectional star networks 之 diameter。 
• 分析 Unidirectional star networks 與 Star networks 的差異：將首先研究
Unidirectional star graphs和Unidirectional (n, k)-star graphs上 link的方向規則
(orientation rules)與 topological properties，並且分析 Unidirectional star 
networks 與 Star networks 的差異；接著探討 Star graphs 和(n, k)-star graphs 的
cycle structures 和 shortest routing paths 之間的對應關係。 
• 提出解決 Unidirectional star networks 上 routing 問題的 cycle structures：將參
考 Star networks 的 cycle structures 定義，加以修改成直接依據代表 source node
與 destination node 的 symbols 之對應關係，重新定義 Unidirectional star 
networks 的 relative cycle structures；接著再設計規則將將 relative cycle 
structures 等 價 轉 換 (equivalent cycles transformation) 成 適 用 於 解 決
Unidirectional star networks 上 routing 問題的 routing cycle structures。 
• 設計 Unidirectional star networks 的 shortest path routing 演算法：以 routing 
cycle structures 為基礎，研究 the length of routing paths 與 routing cycle 
structures之關係，探討如何以既有之 relative cycle structures取得較短的 routing 
path；也就是設計演算法嘗試產生 shortest routing paths，並導出 Unidirectional 
star networks 之 diameters。 
為完成上述所列之三個階段研究步驟，我們將分別就各階段採取之研究方法說明如
下： 
(1) 分析 Unidirectional star networks 與 Star networks 的差異： 
首先，研究 Unidirectional star graphs 上 communication link 的 orientation 
rules。在 Unidirectional star graphs 上所有 nodes 分可為奇數節點(odd nodes)與偶數
節點(even nodes)[18]，其中 odd nodes 的 symbols 排列可視為 Identity 經過奇數次位
置互換(transpositions)得到，even nodes 的 symbols 排列則是由 Identity 經過偶數個
transpositions 得到(參見圖三)。 
在 Unidirectional star graphs 上 communication links 的 orientation rules 是：(a)
奇數 communication link (i-edge 或→i, i∈odd)連接 odd node 到 even node；(b)偶數
communication link(i-edge 或→i, i∈even)連接 even node 到 odd node。特別的是，
Unidirectional (n, k)-star graphs 另外還針對 1-edge[8]或稱 residual edge[20]提供
orientation rules，這些 orientation rules 使得 Unidirectional star graphs 擁有強連通
(strongly connected)、階層架構(hierarchical structure)及最高地有向邊連結性(highest 
arc-connectivity)等特性，而且每個 oriented communication link 存在最大 6-arc 的
cycle 上[18][20]。 
至於，Star graphs 除了具備 hierarchical structure 等特性外，都擁有 node 
symmetry 的特性，因此可以對應(mapping)任兩點的路由到某特定點至 Identity 的路
由上，而 Star graphs 的 cycle structures 則表現此特定點和 Identity 之間的 symbols
7 
 
我們設計路由演算法大致分為 5 個階段，可以推導出單方向星狀圖 (the 
unidirectional n-star graph; USn)中任意兩點間的可行路由路徑。簡單條列如下： 
 
針對 phases 1~5，我們分別設計了 Sub-Algorithm；並且也證明我們演算法的時間
複雜度為 O(n2)。 
(4) 推導 Unidirectional star networks 之 diameter： 
我們運用前述設計的路由演算法，產生任意兩點間的可行路由路徑，可以推導出單
方向星狀圖(USn)的直徑(diameter): 當 n ≥ 5 時，不會超過 2n。這個結果比起 Day 和
Tripathi 所提出的分散式路由演算法(DRA)有顯著的進步(其最大路由距離為 5n-9)，而
且相對於先前已知的單方向星狀圖直徑明顯的更接近最佳解。此外，我們也針對 5 ≤ n ≤ 
12，以 Bread-first algorithm(以寬廣為先之窮舉法)撰寫程式找出最佳路由路徑，發現
我們推導出單方向星狀圖(USn)的直徑與程式計算出的結果相同。 
 
 
 
9 
 
參考文獻 
[1] W.D. Hillis, “The connection machine,” MIT Press, Cambridge, MA, 1985. 
[2] L.N. Bhuyan and D.P. Agrawal, “Generalized hypercube and hyperbus 
structures for a computer network,” IEEE Transactions on Computers, vol. 
c-33, no. 4, pp. 323-333, 1984. 
[3] Y. Saad and M.H. Schultz, “Topological properties of hypercubes,” IEEE 
Transaction on Computers, vol 37, pp. 867-872, 1988. 
[4] S.B. Akers, D. Horel and B. Krisnamurthy, “The star graph: An attractive 
alternative to the n-cube,” Proceeding of the 1987 International Conference 
on Parallel Processing, Penn State University, pp. 393-400, 1987. 
[5] S.B. Akers and B. Krisnamurthy, “A group-theoretic model for symmetric 
interconnection networks,” Proceeding of International Conference on 
Parallel Processing, pp. 216-223, 1986. 
[6] K. Day and A. Tripathi, “Arrangement Graphs: A class of generalized star 
graphs,” Information Processing Letters, vol. 42, no. 5, pp. 235-241, 1992. 
[7] J.S. Jwo, S. Lakshmivarahan and S.K. Dhall, “A new class of interconnection 
network based on the alternating group,” Networks, vol. 23, no. 4, pp. 
315-326, 1993. 
[8] W.K. Chiang and R.J. Chen, “The (n, k)-star graph: A generalized star 
graph,” Information Processing Letters, vol. 56, pp. 259-264, 1995. 
[9] W.K. Chiang and R.J. Chen, “Topological properties of the (n, k)-star graph,” 
International Journal of Foundations of Computer Science, vol. 9, no. 2, 
pp.235-248, 1998. 
[10] W.K. Chiang and R.J. Chen, “On the arrangement graph,” Information 
Processing Letters, vol. 66, no. 4, pp. 215-219, 1998. 
[11] M. Nigam, S. Sahni and B. Krishnamurthy, ”Embedding hamiltonians and 
hypercubes in star interconnection graphs,” International Conference on 
Parallel Processing, 1990. 
[12] R.S. Lo and G.H. Chen, “Embedding hamiltonian paths in faulty 
arrangement graphs with the backtracking method,” IEEE Transaction 
Parallel Distributed Systme, vo. 12, no. 2, pp. 209-222, 2001. 
[13] S.Y. Hsieh and G.H. Chen, C.W. Ho, “Hamiltonian-laceability of star 
graphs,”  Networks, vol.36, no. 4, pp. 225-232, 2000. 
[14] P. Fragopoulou and S.G. Akl, “A parallel algorithm for computing Fourier 
transforms on the star graph,” IEEE Transactions on Parallel and Distributed 
Systems, vol. 5, no. 5, pp. 525-531, 1994. 
[15] A. Mann and A.K. Somani, “An efficient sorting algorithm for the star graph 
interconnection network,” Proceedings of the International Conference on 
Parallel Processing, vol. 3, pp. 1-8, 1990. 
11 
 
計畫成果自評 
本期末報告研究內容與原計畫預期成果相符，研究議題主要可分為兩個部分，首先
是設計 Unidirectional star graphs的 routing 演算法；另外，我們也推導 Unidirectional 
star graphs之 routing distances 與 diameters。 
我們將證明得到的路由路徑可以有效率地完成任意兩點間的路由，推導出單方向星
狀圖(USn)的直徑(diameter): 當 n ≥ 5 時，不會超過 2n。並且證明我們演算法的時間複
雜度為 O(n2)。這個結果比起 Day 和 Tripathi 所提出的分散式路由演算法(DRA)有顯著
的進步(其最大路由距離為 5n-9)，而且相對於先前已知的單方向星狀圖直徑明顯的更接
近最佳解。此外，我們也針對 5 ≤ n ≤ 12，以 Bread-first algorithm(以寬廣為先之窮舉
法)撰寫程式找出最佳路由路徑，發現我們推導出單方向星狀圖(USn)的直徑與程式計算
出的結果相同。 
目前已將計畫研究成果寫成論文[R1, 附錄二]，正進行定理證明修改，預計將此結
果投稿至國際期刊 Journal of Parallel and Distributed Computing 或者是 Networks。 
[R1] Tseng, Chun-Hong, “Routing algorithm and diameter for the unidirectional 
star graph,” Master Thesis, Department of Computer Science and Information 
Engineering, National Chung Cheng University, July 2007. 
 
1 Introduction
Due to the rapid advancement in massive parallel and distributed computing, unidirec-
tional interconnection networks have received much attention in the literature recently[7, 8,
9, 10, 16], especially in the eld of high speed networking, such as optical networks. Although
most existing interconnection networks for parallel systems are undirected, undirected links
are normally realized by two separate opposite unidirectional links in practice, which doubles
the degree of a node and increases the cost and di¢ culty when constructing interconnection
networks. Comparatively, unidirectional interconnection networks require half as many links
as the bidirectional ones. Their average and maximal routing distance between any pair of
nodes are comparable to bidirectional interconnection networks. In addition, some excellent
characteristics also make unidirectional interconnection networks appropriate for high-speed
optical networks: simple routing schemes; the number of alternate paths is su¢ cient; tra¢ c
is uniformly distributed across the network; channels in an optical ber are unidirectional.
The star graph[2, 3] has been recognized as an attractive alternative to the hypercube.
It has signicant advantages over the hypercube, such as a lower degree and a smaller
diameter. In addition, the star graph possesses many attractive topological properties, such
as recursive structure, symmetry, maximal fault tolerance and strong resilience. Motivated
by these attractive properties, many related aspects of the star graph have been investigated,
including the topological properties[11, 19], embedding capability[5, 20], broadcasting[18, 23],
fault tolerance[4, 11, 15, 17, 22], sorting[21], ranking[1], Fourier transform[13] and topology
extension[6, 12].
Day and Tripathi[10] rst proposed an orientation to the star graph and the resulting
unidirectional star graph is strongly connected and recursive structure. In addition, Cheng
and Lipman[8] showed that the unidirectional star graph proposed by Day and Tripathi is
highest possible arc-connected and is regular by adding a directed matching, these charac-
teristics show that the orientation is good. Day and Tripathi[10] also proposed a simple
distributed routing algorithm for the unidirectional star graph, and the maximal routing
distance is 5n   9 in the unidirectional n-star graph, USn; however, the diameter of the
unidirectional star graph remains an open problem.
In this paper, we improve the previous result on routing in USn. There have been many
schemes to specify shortest paths from the source to the destination upon the cycle structure
in the star graph. However, these schemes are not feasible in the unidirectional star graph,
because each edge is unidirectional now. Hence we equivalently transform the cycle structure
into a specic cycle representation, the feasible routing cycle structure, and develop a scheme
to specify the feasible routing paths upon the feasible routing cycle structure. The feasible
routing paths accomplish the routing e¤ectively in USn, and we conclude that the length of
any feasible routing path is no more than 2n. We also derive that our routing algorithm could
be performed in time O(n2). Our scheme obviously species a much shorter routing path
than the routing algorithm proposed by Day and Tripathi (the maximal routing distance is
5n   9 in USn), and these feasible routing paths are nearly optimal.
This paper is organized as follows. The unidirectional star graph and the operations
of the cycle structure are presented in section 2. We introduce in section 3 the Routing
algorithm. In section 4 we compute the maximum length of the feasible paths our routing
algorithm and prove the diameter. Section 5 concludes this paper.
1
The orientation to the star graph proposed by Day and Tripathi[10] is: direct i-edge
from an odd permutation to an even permutation if i 2 odd, and direct i-edge from an
even permutation to an odd permutation if i 2 even. Figure 1 shows the topology of the
unidirectional 4-star graph, US 4.
Recall that any permutation with respect to the Identity can be viewed as a set of cycles,
called the cycle structure, which are cyclically order sets of symbols with the property: each
symbols desired position is occupied by the next symbol in the same set. In addition,
each permutation is either even or odd; a permutation is an even (odd) permutation if it is
obtained from the Identity by an even (odd) number of transpositions. Obviously, any edge
in the star graph connects an even permutation and an odd permutation, hence traversing
an edge will change an even permutation into an odd one and vice versa.
S = s1, s2, … , sn
x1, x2, … , dn
x1, x2, … , dn-1, dn
x1, x2 , x3, d4, … , dn
D = d1, d2 , d3, d4, … , dn
Stagen
Stagen-1
Stage4
cleanup stage
Figure 2: Each node of Stagei in the distributed routing algorithm(DRA)
Day and Tripath[10] also propose a distributed routing algorithm (DRA), which is a
simple routing algorithm, by utilizing the properties. Suppose that the message is routed
from a source node s1s2...sn to a destination node d1d2...dn by n   1 stages. Where Stagei
is done by a sequence of moves to take the di symbol to its position i, for 2  i  n. Since
symbol d1 is corrected automatically after the n  1 stages, the procedure of routing scheme
goes through the stages from Stagen to Stage2. They divide the stages in two parts, the stages
for i > 3 and the stages 2 and 3, which is a "cleanup" stage, which is shown as Figure 2.
3
The relative cycle structure indicates the correct positions of symbols in the source per-
mutation. For example, given two nodes 24635718 and 73462158 in US8, the relative cycle
structure of 24635718 with respect to 73462158 is (5, 7, 6, 1)(2, 3, 4), as shown in Figure
3. We can nd that each permutation of symbols could be mapped into a permutation of
positions, and the group of all permutations of positions {1, 2, . . . , n} is the symmetric
group on n positions.
Position 1 2 3 4 5 6 7 8
Source 2 4 6 3 5 7 1 8
Destination 7 3 4 6 2 1 5 8
Figure 3: Mapping the posititions of symbols
In the star graph, the path from the source permutation to the destination permutation
corresponds to a sequence of transpositions, and the sequence of transpositions corrects the
cycles of the cycle structure. Based on properties Eq 4 and Eq 5 in chapter 2, the shortest
paths to correct a cycle optimally are given as follows. Traversing an pk-edge will be noted
as ! pk, i.e. apply the (pk, 1) transposition; a path contains a sequence of transpositions,
noted as <!p1, !p2, . . .>.
Lemma 2 [15] For an arbitrary cycle Ci, we correct Ci as follows.
(1) We correct an abitrary cycle along the path: <!p1, !p2, . . . , !pm > if Ci = (p1, p2,
. . . , pm, 1);
(2) We correct an abitrary cycle along the path: <!p1, !p2, . . . , !pm, !p1 > if Ci =
(p1, p2, . . . , pm).
If we could specify a path to correct the cycles of the relative cycle structure, the path
accomplish the routing from the source permutation to the destination permutation in USn.
However, the shortest path specied upon Lemma 2 is not always feasible to correct a cycle in
USn. Since the edge is unidirectional, the specied path might traverse edges in the opposite
direction against their orientation, these orientation-violated edges make the specied path
unfeasible.
Consider the example that routing from 24635718 to 73462158 in US 8, the relative cycle
structure of 24635718 with respect to 73462158 is (5, 7, 6, 1)(2, 3, 4). One of the shortest
paths that corrects (5, 7, 6, 1) and (2, 3, 4) sequentially is 24635718 !5 54632718 !7
14632758 !6 74632158 !2 47632158 !3 67432158 !4 37462158 !2 73462158. Obviously
the path is unfeasible in US 8, because it traverses three orientation-violated edges: 54632718
(even) !7 14632758 (odd), 14632758 (odd) !6 74632158 (even) and 37462158 (odd) !2
73462158 (even).
5
A arbitrary cycle (p1, p2, . . . , pm) can be factorized into a product of two non-disjoint
cycles (p1, p2, . . . , pk)(pk, pk+1, . . . , pm), and the right cycle is to be corrected rst. With
Lemma 8, we further extend this proposition to specify a path as follows.
Lemma 9 If a cycle (p1, p2, . . . , pm) is factorized into a product of two non-disjoint cycles
(p1, p2, . . . , pk)(pk, pk+1, . . . , pm), 1 =2 fpk; pk+1, . . . , pmg. To correct (p1, p2, . . . , pk)(pk,
pk+1, . . . , pm), a path could start with correcting cycle (p1, p2, . . . , pk) rst, and before
traversing the !pk edge, jump to correct cycle (pk, pk+1, . . . , pm), then the correcting of
cycle (p1, p2, . . . , pk) is not resumed until the completion of correcting cycle (pk, pk+1, . . . ,
pm).
For example, given two nodes 24635718 and 73462158 in US 8, the relative cycle structure
24635718 to 73462158 is (5, 7, 6, 1)(2, 3, 4). In order to accomplish the route from 24635718
to 73462158 in US8, we try to solve the consecutive even or odd edges in the relative cycle
structure by inserting the feasible cycles before the orientation-violated edges. By Lemma
9, we can get the feasible routing cycle structure (5, 7, 6, 1)(2, 3)(3, 4). The feasible routing
path from 24635718 to 73462158 is < 24635718!5 54632718!4 34652718!3 64352718!4
54362718!7 14362758!6 74362158!3 34762158!2 43762158!3 73462158 > by Lemma
8 and 9.
3.3 Our routing algorithm
Given any two arbitrary nodes s and t in USn, we try to derive the feasible routing
path by the following phases.
1. Generate the relative cycle structure: Given any two arbitrary nodes s and s,we
could generate the relative cycle structure. And we can rearrange the relative cycle
structure as C1O1O2...OE 1E 2...EH 1H 2...H G1G2...G with the invariant posi-
tions e1e2...ez.
2. Analyse the relative cycle structure: We can evaluate the number of cycles, denoted
by cRelative, and the number opositions, denoted by mRelative, in the relative cycle
structure. Moreover, we can evaluate the number of odd X, denoted by sumXO, the
number of even X, denoted by sumXE, and the number of total X which will be
encountered, denoted by sumX, in the relative cycle structure.
3. Merge the pure cycles with the other cycles or the invariant potisions: Because the
pure cycle cant be factorized to get the good cycles, we merge the pure cycles with
the other cycles or the invariant positions to be the new hybrid cycles.
4. Get the good cycles: Get the good cycles we need to insert before the orientation-
violated edges. Then, we get the feasible routing cycle structure we want.
5. Derive the feasible routing path: Derive the feasible routing path from the feasible
routing cycle structure by correcting each cycle in the feasible routing cycle structure.
These phases are described as below.
7
 The number of total positions is given by:
mRelative =

mO +mE +mH +mG
mC1 +mO +mE +mH +mG
if C1 doesnt exist,
if C1 exists,
where mO = mO1 + ::: +mO , mE = mE1 + ::: +mE , mH = mH1 + ::: +mH , mG =
mG1 + :::+mG .
 The number of total orientation-violated odd edges is given by:
sumXO =

XO +X
O
H
XOC1 +XO +X
O
H
if C1 doesnt exist,
if C1 exists,
where XO = XO1 + :::+XO , X
O
H = X
O
H1
+ :::+XOH .
 The number of total orientation-violated even edges is given by:
sumXE =

XE +X
E
H
XEC1 +XE +X
E
H
if C1 doesnt exist,
if C1 exists,
where XE = XE1 + :::+XE , X
E
H = X
E
H1
+ :::+XEH .
 The number of total orientation-violated edges which will encounted while correcting
each in the relative cycle structure is given by:
If C1 doesnt exist:
sumX =
8>>>>>>>>>>>><>>>>>>>>>>>>:
sumXO + sumXE         + 1
sumXO       +   sumXE   1
sumXO       +   sumXE
sumXE      +    sumXO   1
sumXE      +    sumXO
if   sumXE,   sumXO;
if  > sumXE,   sumXO;
and (s) 2 odd,
if  > sumXE,   sumXO;
and (s) 2 even,
if   sumXE,  > sumXO;
and (s) 2 even,
if   sumXE,  > sumXO;
and (s) 2 odd.
Otherwise:
9
will exist an even position ez, ez =2 the relative cycle structure if the pure cycle is a pure-odd
cycle. Hence, its proved.
We nd the cases will be held while there exists a pure cycle in the relative cycle
structure. Thus, we propose a algorithm to merge the pure cycles with other cycles or the
invariant positions. Before describing our algorithm for merging the pure cycle with other
cycles or the invariant positions, some notations and terminologies are introduced rst.
Lemma 11 Two disjoint cycles ( p1, p2, . . . , pk) and ( pk+1, pk+2, . . . , pm) can be merged
to be the cycles ( p1, p2, . . . , pk, pk+1, pk+2, . . . , pm)(pm, pk), where cycle (pm, pk) must be
corrected before edges !pm and !pk in cycle ( p1, p2, . . . , pk, pk+1, pk+2, . . . , pm) being
corrected. A cycle ( p1, p2, . . . , pm) and a position ez, which ez =2 f p1, p2, . . . , pmg, can be
merged to be the cycles ( p1, p2, . . . , pm, ez)(pm, ez), where cycle (pm, ez) must be corrected
before edges !pm and !ez in cycle ( p1, p2, . . . , pm, ez) being corrected.
Denition 12 The current number of orientation-violated edges after there exists no case
(1) of Lemma 10, denoted by sumX 0, is given by:
sumX 0 =
8>>>>>>>>>><>>>>>>>>>>:
XO1 +XO2 + :::+XO sumXE +   sumXE   1 if  > sumXE and (s) 2
odd (resp. (C1m0) 2 even),
XO1 +XO2 + :::+XO sumXE +   sumXE if  > sumXE and (s) 2
even (resp. (C1m0) 2 odd),
XE1 +XE2 + :::+XE sumXO +    sumXO   1 if  > sumXO and (s) 2
even (resp. (C1m0) 2 odd),
XE1 +XE2 + :::+XE sumXO +    sumXO if  > sumXO and (s) 2
odd (resp. (C1m0) 2 even).
The current number of good cycles we can get after existing no case (1) of Lemma 10, denoted
by sumG0, is given by:
sumG0 =

 +  +  + sumX   (XO1 +XO2 + :::+XO sumXE )  2sumXE if  > sumXE,
+  +  + sumX   (XE1 +XE2 + :::+XE sumXO )  2sumXO if  > sumXO:
Sub-Algorithm : Merge the pure cycle with other cycles or the invariant positions
                                    
Input : CR(s, t) = C1O1O2...OE 1E 2...EH 1H 2...H G1G2...G
Output : The cycle structure C1O1O2...O0E 1E 2...E0H 1H 2...H 0G1G2...G0 after merg-
ing the pure cycle with other cycles or the invariant positions
Begin
While there exists a pure cycle ( p1, p2, . . . , pm)
If case (1) of Lemma 10 is existed and sumX > 
There exists a cycle ( c1, c2, . . . , cm0), which (c1) = (cm0) 6= (p1) :
Rule 3-1 ( p1, p2, . . . , pm)( c1, c2, . . . , cm0) = ( p1, . . . , pm, c1, . . . , cm0)(pm, cm0);
sumX = sumX   2 ;
Else if case (2) of Lemma 10 is existed
If there exists a C1 cycle ( C11, C12, . . . , C1m0, 1), which (C11) = (C1m0) 6= (p1)
= @(s), @(C1k) 6= @(C1k+1) for 1  k  m0   1 and sumX >  :
Rule 3-2 ( C11, C12, . . . , C1m0, 1)( p1, p2, . . . , pm) = ( C11, . . . , C1m0, p1,
11
3.3.4 Phase 4 - Get the good cycles
After merging the pure cycles with other cycles or the invariant positions, we can get
enough good cycles to be inserted before the orientation-violated edges. By Eq. 6 in chapter
2, a hybrid cycles could be factorized to get the good cycles. If there exists a cycle =2 E or O,
and XC > 0, we rotate this cycle to be ( p1, p2, . . . , pm), which (p1) = (pm) 6= (pm 1).
We factorized this cycle into ( p1, p2, . . . , pm 1)( pm 1, pm), which ( pm 1, pm) is a good
cycle and must be corrected before!pm 1 being corrected in cycle (p1, p2, . . . , pm 1). This
operation of cycle factorization reduce a X and add a new good cycle, which cause sumX
will be reduced by two. Since we can evaluate the sumX after merging the pure cycle with
other cycles or the invariant positions, we could know how many times the operation of cycle
factorization will be executed. Our goal is to let sumX < , and the cycle structure which
sumX <  could be the feasible routing cycle structure. In other words, we can get the
feasible routing cycle structure after getting the good cycles.
Sub-Algorithm : Get the good cycles
                                    
Input : The cycle structure C1O1O2...O0E 1E 2...E0H 1H 2...H 0G1G2...G0 after elimi-
nating the pure cycle
Output : The feasible routing cycle structure CFRoute(s, t)
Begin
While sumX    > 0
Cycle XH0 : ( p1, p2, . . . , pm)
If XH0 < d sumX2 e
Execute the operation of cycle division XH0 times.
For 1 to XH0
If (p1) = (pm) 6= (pm 1)
Rule 4 ( p1, p2, . . . , pm) = ( p1, p2, . . . , pm 1)( pm 1, pm);
sumX = sumX   2 ;
Else
Rotate the cycle to ( p2, . . . , pm, p1);
Else
Execute the operation of cycle division d sumX
2
e times.
For 1 to d sumX
2
e
If (p1) = (pm) 6= (pm 1)
Rule 4 ( p1, p2, . . . , pm) = ( p1, p2, . . . , pm 1)( pm 1, pm);
sumX = sumX   2 ;
Else
Rotate the cycle to ( p2, . . . , pm, p1);
End
                                    
There are some supplements to the algorithm for getting the good cycles :
13
                                    
We try to evaluate the time complexity now. In phase 1, the time complexity for generat-
ing the relative cycle structure is obviously O(n2). In pahse 2, it takes O(n) times to analyse
the relative cycle structure. In order to evaluate the value we need, we should traverse all
positions in the relative cycle structure. In pahse 3, since the number of the pure cycles is
bn 1
4
c at most. The operation of eliminating the pure cycle is the same as the number of pure
cycles. In phase 4, the value of sumX is dn 1
2
e(n 1 2bn 1
4
c) at most after eliminating the
pure cycles. Thus, the operation of getting the good cycles is 1
2
dn 1
2
e at most. In phase 5, the
operation of getting the feasible routing path is at most as the diameter of the unidirectional
n-star graph, which is 5n   9 proposed by Day and Tripathi. Its obviously that the time
complexity of our algorithm for getting the feasible routing path is O(n2).
Recall the example in Chapter 2, if we want to sent a message from a source node
123456789ABCDE to a destination node 3412756A98BEDC in US14. We generate the rel-
ative cycle structure from the given source permutation and the given destination in phase
1. The relative cycle structure is (3, 1), (2, 4), (8, A), (C, E), (5, 6, 7). After gener-
ating the relative cycle structure, we evaluate the value of parameters we need. Which
cRelative = 5, mRelative = 11, sumXO = 2, sumXE = 6, sumXE      +    sumXO   1 =
6   0   1 + 3   2   1 = 5. In phase 3, we adopt the Rule 3-1 and Rule 3-2 to merge the
pure-even cycles (2, 4), (8, A) with the hybrid cycle (5, 6, 7) and the C1 cycle (3, 1). The
cycle structure after phase 3 is (3, 2, 4, 1), (C, E), (5, 6, 7, 8, A), (7, A), (3, 4), and
sumX = 5   2   2 = 1. Thus, we need one time of the cycle factorization and the feasible
routing cycle structure after phase 4 is (3, 2, 4, 1), (C, E), (A, 5, 6, 7), (7, 8), (7, A), (3, 4).
The length of the feasible routing paht is 6 + 16   2 = 20, which is comparable with 30 as
the result of DRA.
4 Routing Distance and Diameter
Each feasible routing path in our approach corrects the cycles of the feasible routing cycle
structure in a recursive way, the length of a feasible routing path can be evaluated upon the
feasible routing cycle structure.
Theorem 13 [3]Let dRelative(s; t) denotes the length of the routing path from the source
node s to the destination node t in USn specied upon the relative cycle structure, dRelative(
s; t) is given by:
dRelative(s; t) =

cRelative +mRelative
cRelative +mRelative   2
if 1 =2 the relative cycle structure,
if 1 2 the relative cycle structure,
where cRelative is the number of cycles and mRelative is the number of positions in the relative
cycle structure.
In addition, the feasible routing cycle structure is transformed from the relative cycle
structure, the length of the feasible routing path from the source s to the destination t
can be obtained upon the relative cycle structure. Assume that cFRoute is the number of cycles
and mFRoute is the number of positions in the feasible routing cycle structure, dFRoute(s,
15
of even positions besides the C1 cycle.
In general, there existsX in a cycle or e that could be merged with the pure cycles by Rule
3-1 and Rule 3-3). However, if CR(s, t) = C1O1O2...OE 1E 2...EH 1H 2...H G1G2...G
with XC1 = 0,
8<:
sumXE = 1, (s) 2 odd, (C11) 2 even,  = 1, or
sumXO = 1, (s) 2 even, (C11) 2 odd,  = 1, or
sumXO = 0, sumXE = 2,
and the relation of the remainder positions besides the C1 cycle is mO + 2 = mE, there
exists no X in a cycle or e that could be merged with the pure cycle. We merge the pure
cycle with C1 cycle in the later two special cases by Rule 3-2 and 3-4. Thus, we analyse the
routing distance for any two arbitrary node s and t in USn by considering the following
ten cases:
1.Case A-1. CR(s, t) = O1O2...OE 1E 2...EH 1H 2...H G1G2...G with    but  
sumXE.
Case A-2. CR(s, t) = O1O2...OE 1E 2...EH 1H 2...H G1G2...G with  >  and  >
sumXE.
Case A-3. CR(s, t) = O1O2...OE 1E 2...EH 1H 2...H G1G2...G with    but  
sumXO.
Case A-4. CR(s, t) = O1O2...OE 1E 2...EH 1H 2...H G1G2...G with  >  and  >
sumXO.
Case B-1. CR(s, t) = C1O1O2...OE 1E 2...EH 1H 2...H G1G2...G with    but  
sumXE, either XC1 > 0 or (XC1 = 0 without sumXE = 1, (s) 2 odd, (C11) 2
even, and  = 1).
Case B-2. CR(s, t) = C1O1O2...OE 1E 2...EH 1H 2...H G1G2...G with  >  and  >
sumXE.
Case B-3. CR(s, t) = C1O1O2...OE 1E 2...EH 1H 2...H G1G2...G with    but  
sumXO, eitherXC1 > 0 or (XC1 = 0 without sumXO = 1, (s) 2 even, (C11) 2
odd, and  = 1).
Case B-4. CR(s, t) = C1O1O2...OE 1E 2...EH 1H 2...H G1G2...G with  >  and  >
sumXO, either XC1 > 0 or (XC1 = 0 without sumXO = 0 and sumXE = 2).
Case B-5. CR(s, t) = C1O1O2...OE 1E 2...EH 1H 2...H G1G2...G with
XC1 = 0, sumXE = 1, (s) 2 odd, (C11) 2 even, and  = 1, or
XC1 = 0, sumXO = 1, (s) 2 even, (C11) 2 odd, and  = 1.
Case B-6. CR(s, t)=C1O1O2...OE 1E 2...EH 1H 2...H G1G2...G withXC1 = 0, sumXO
= 0 and sumXE = 2.
We now start to analyse the routing distance for any two arbitrary nodes in USn.
Lemma 14 Given two arbitrary nodes s and t in USn for n  5, if CR(s, t) =
O1O2:::OE1E2:::EH1H2:::HG1G2:::G with    but   sumXE (Case A-1), the length
of the feasible routing path is given by:
17
dist will be increased by 2 whenever we factorize a hybrid cycle to get a new good cycle. The
length of the feasible routing path is dRelative(s, t) + distphase3 +distphase4 = cRelative +
mRelative+2+2(r )+2 = cRelative+mRelative+2r+2 = cRelative+mRelative+sumX +1.
Corollary 15 Given two arbitrary nodes s and t in USn for n  5, if CR(s, t) =
O1O2:::OE1E2:::EH1H2:::HG1G2:::G with    but   sumXE (Case A-1), the upper
bound for the routing distance is given by:
dFRoute(s, t) =

2n  1 if n = 6,
2n if n 6= 6.
Proof. The value of mRelative and sumXO + sumXE are at most n   1 since there exists
no C1 cycle. Based on Lemma 14 , if sumX    is even, the length of the feasible routing
path dFRoute(s, t) = cRelative + mRelative + sumX    = cRelative + mRelative + sumXO +
sumXE          + 1   = mRelative + sumXO + sumXE + 1 since sumX = sumXO +
sumXE          + 1 and cRelative =  +  +  + , so the upper bound for the routing
distance is n   1 + n   1 + 1 = 2n   1. If sumX    is odd, the length of the feasible
routing path dFRoute(s, t) = cRelative +mRelative + sumX    + 1 = cRelative +mRelative +
sumXO + sumXE          + 1    + 1 = mRelative + sumXO + sumXE + 2 since
sumX = sumXO+ sumXE     +1 and cRelative = ++ + , so the upper bound
for the routing distance is n   1 + n   1 + 2 = 2n. Moreover, there exists no hybrid cycles
or pure cycles since mRelative = n   1 and sumXO + sumXE = n   1, so we can evaluate
sumX    = sumXO + sumXE       + 1 = n   ( + ). We prove the corollary by
considering the following two cases:
(a)n = 6 : Since  = 1 and  = 1, sumX    = 6  (1 + 1) = 4 2 even, the upper bound of
the routing distance is 2n  1 for any two arbitrary nodes s and t in USn if n = 6.
(b)n 6= 6 : If n = 5,  = 1 and  = 1, sumX    = 5  (1 + 1) = 3 2 odd. If n = 7,  = 1
and  = 1, sumX    = 7   (1 + 1) = 5 2 odd. If n  8, sumX    = n   ( + ) can
always be evaluated as an odd number since ( + ) could be even or odd. Thus, the upper
bound of the routing distance is 2n for any two arbitrary nodes s and t in USn if n  5
and n 6= 6.
Lemma 16 Given two arbitrary node s and t in USn for n  5, if CR(s, t) = O1O2:::O
E1E2:::EH1H2:::HG1G2:::G with  >  and  > sumXE (Case A-2), the length of the
feasible routing path is given by:
dFRoute(s, t) =
8>>>>>>>>>><>>>>>>>>>>:
cRelative +mRelative + sumX    if sumX 0  sumG0
and sumX    is even,
cRelative +mRelative + sumX    + 1 if sumX 0  sumG0
and sumX    is odd,
cRelative +mRelative + sumX    if sumX 0 > sumG0
and sumX  2sumXE
2
is even,
cRelative +mRelative + sumX    + 1 if sumX 0 > sumG0
and sumX  2sumXE
2
is not even,
19
(d) sumX 0 > sumG0 and sumX  2sumXE
2
is not even: Assume sumX    = 2sumXE +
4r + q, 0 < q  3. If 0 < sumXE + r <    1, we merge the sumXE pure-odd cy-
cles with the pure-even cycles and the hybrid cycles to be the new hybrid cycles (Rule 3-1)
and sumX      2sumXE = 4r + q since the number of the orientation-violated edges
will be reduced by 2 (new sumX = old sumX   2) whenever we merge a pure-odd cycle
with a pure-even cycle or a hybrid cycle. Since sumX 0 > sumG0, we need to merge the
r (r     sumXE   2) pure-odd cycles with the invariant positions to be the new hybrid
cycles (Rule 3-3) and sumX      2sumXE   4r = q since the number of the orientation-
violated edges will be reduced by 4 (new sumX = old sumX   4) whenever we merge a
pure-odd cycle with a invariant position. Then, we need to factorize the hybrid cycles to
get the good cycles (Rule 4) for d q
2
e times since q > 0 and the number of the orientation-
violated edges will be reduced by 2 (new sumX = old sumX   2) whenever we factorize
a hybrid cycle to get a new good cycle. Moreover, distphase3 = 2sumXE + 4r since the
increment of dist will be increased by 2 whenever we merge a pure-odd cycle with a pure-
even cycle or a hybrid cycle and the increment of dist will be increased by 4 whenever
we merge a pure-odd cycle with a invariant postion, and distphase4 = 2d q2e since the in-
crement of dist will be increased by 2 whenever we factorize a hybrid cycle to get a good
cycle. The length of the feasible routing path is dRelative(s, t)+distphase3+distphase4 =
cRelative +mRelative + 2sumXE + 4r + 2d q2e  cRelative +mRelative + 2sumXE + 4r + q + 1 =
cRelative +mRelative + sumX    + 1. If sumXE + r    1, we merge the sumXE pure-odd
cycles with the pure-even cycles and the hybrid cycles to be the new hybrid cycles (Rule 3-1)
and sumX    2sumXE = 4r+ q since the number of the orientation-violated edges will be
reduced by 2 (new sumX = old sumX 2) whenever we merge a pure-odd cycle with a pure-
even cycle or a hybrid cycle. Since sumX 0 > sumG0, We need to merge the ! pure-odd cycles
with the invariant positions to be the new hybrid cycles (Rule 3-3), where !   sumXE 2,
and sumX      2sumXE   4! = 4r   4! + q since the number of the orientation-violated
edges will be reduced by 4 (new sumX = old sumX   4) whenever we merge a pure-odd
cycle with a invariant position. Then, we need to factorize the hybrid cycles to get the good
cycles (Rule 4) for 2(r   !) + d q
2
e times since 4(r   !) + q  4r   4 + 4sumXE + q > 0
and sumX      2sumXE   4! 2 even, and the number of the orientation-violated edges
will be reduced by 2 (new sumX = old sumX   2) whenever we factorize a hybrid cycle
to get a new good cycle. Moreover, distphase3 = 2sumXE + 4r since the increment of
dist will be increased by 2 whenever we merge a pure-odd cycle with a pure-even cycle
or a hybrid cycle and the increment of dist will be increased by 4 whenever we merge a
pure-odd cycle with a invariant postion, and distphase4 = 4(r   !) + 2d q2e since the in-
crement of dist will be increased by 2 whenever we factorize a hybrid cycle to get a good
cycle. The length of the feasible routing path is dRelative(s, t) +distphase3+distphase4 =
cRelative+mRelative+2sumXE+4!+4(r !)+2d q2e  cRelative+mRelative+2sumXE+4r+q+1 =
cRelative +mRelative + sumX    + 1.
Corollary 17 Given two arbitrary node s and t in USn for n  5, if CR(s, t) =
O1O2:::OE1E2:::EH1H2:::HG1G2:::G with  >  and  > sumXE (Case A-2), the up-
per bound for the routing distance is given by:
dFRoute(s, t) =
3(n 1)
2
+ 1 .
21
dFRoute(s, t) =
8>>>>>>>>>><>>>>>>>>>>:
cRelative +mRelative + sumX   ; if sumX 0  sumG0
and sumX    is even,
cRelative +mRelative + sumX    + 1; if sumX    is odd
and sumX 0  sumG0,
cRelative +mRelative + sumX   ; if sumX 0 > sumG0
and sumX  2sumXE
2
is even,
cRelative +mRelative + sumX    + 1; if sumX 0 > sumG0
and sumX  2sumXE
2
is not even,
where sumX =

sumXO       +   sumXE   1 if (s) 2 even,
sumXO       +   sumXE if (s) 2 odd,
sumX 0 =

XO1 +XO2 + :::+XO sumXE +   sumXE if (s) 2 even,
XO1 +XO2 + :::+XO sumXE +   sumXE   1 if (s) 2 odd,
and sumG0 = +  +  + sumX   (XE1 +XE2 + :::+XE sumXO )  2sumXO.
Proof. Similar to the proof of Lemma 16, we can prove it by exchanging "pure-odd", sumXE,
and  with "pure-even", sumXO, and  in the argument of the Lemma 16 proof.
Corollary 21 Given two arbitrary node s and t in USn for n  5, if CR(s, t) =
O1O2:::OE1E2:::EH1H2:::HG1G2:::G with  >  and  > sumXO (Case A-4), the up-
per bound for the routing distance is given by:
dFRoute(s, t) = 3n2 + 1 .
Proof. The value of mRelative+sumXE sumXO is at most n since there exists no C1 cycle
and the value of  is at most b dn 12 e
2
c since the value of sumXE is at most dn 12 e. Based on
Lemma 16, we prove the corollary by considering the following four cases:
(a) sumX 0  sumG0 and sumX    is even: The length of the feasible routing path is
cRelative+mRelative+ sumX     cRelative+mRelative+ sumXE     +    sumXO    =
mRelative + sumXE   sumXO + 2 = n + 2b d
n 1
2
e
2
c  3n
2
since sumX is at most sumXE  
   +    sumXO and cRelative = +  +  + .
(b) sumX 0  sumG0 and sumX  is odd: The length of the feasible routing path is cRelative+
mRelative + sumX    + 1  cRelative +mRelative + sumXE      +    sumXO    + 1 =
mRelative + sumXE   sumXO + 2 + 1 = n+ 2b d
n 1
2
e
2
c+ 1  3n
2
+ 1 since sumX is at most
sumXE      +    sumXO and cRelative = +  +  + .
(c) sumX 0 > sumG0 and sumX  2sumXE
2
is even: The length of the feasible routing path is
cRelative+mRelative+ sumX     cRelative+mRelative+ sumXE     +    sumXO    =
mRelative + sumXE   sumXO + 2 = n + 2b d
n 1
2
e
2
c  3n
2
since sumX is at most sumXE  
   +    sumXO and cRelative = +  +  + .
(d) sumX 0 > sumG0 and sumX  2sumXE
2
is not even: The length of the feasible routing path
is cRelative+mRelative+sumX +1  cRelative+mRelative+sumXE  + sumXO +1
= mRelative+ sumXE   sumXO+2+1 = n+2b d
n 1
2
e
2
c+1  3n
2
+1 since sumX is at most
sumXE      +    sumXO and cRelative = +  +  + .
Lemma 22 Given two arbitrary node s and t in USn for n  5, if CR(s, t) = C1O1O2:::
OE1E2:::EH1H2:::HG1G2:::G with    but   sumXE, either XC1 > 0 or (XC1 = 0
23
dFRoute(s, t) =
8>>>>>>>>>><>>>>>>>>>>:
cRelative +mRelative + sumX      2 if sumX 0  sumG0
and sumX    is even,
cRelative +mRelative + sumX      1 if sumX 0  sumG0
and sumX    is odd,
cRelative +mRelative + sumX      2 if sumX 0 > sumG0
and sumX  2sumXE
2
is even,
cRelative +mRelative + sumX      1 if sumX 0 > sumG0
and sumX  2sumXE
2
is not even,
where sumX =

sumXO       +   sumXE   1 if (C1m0) 2 even,
sumXO       +   sumXE if (C1m0) 2 odd
sumX 0 =

XO1 +XO2 + :::+XO sumXE +   sumXE if (C1m0) 2 even,
XO1 +XO2 + :::+XO sumXE +   sumXE   1 if (C1m0) 2 odd,
and sumG0 =  +  +  + sumX   (XO1 +XO2 + :::+XO sumXE )  2sumXE.
Proof. We prove the lemma by considering the following four cases:
(a) sumX    is even and sumX 0  sumG0 : The proof is the same as the proof of Lemma
22(a).
(b) sumX    is odd and sumX 0  sumG0 : The proof is the same as the proof of Lemma
22(b).
(c) sumX  2sumXE
2
2 integer even and sumX 0 > sumG0 : Assume sumX  2sumXE
2
= 2r,
then sumX    = 4r + 2sumXE. The proof is similar to the proof of Lemma 16(c). The
di¤erence between these two proofs is there exists the C1 cycle in this lemma, so the length of
the feasible routing path is dRelative(s, t)+distphase3+distphase4 = cRelative+mRelative 
2 + sumX    = cRelative +mRelative + sumX      2.
(d) sumX  2sumXE
2
=2 integer even and sumX 0 > sumG0 : Assume sumX    = 2sumXE +
4r+ q, 0 < q  3. The proof is similar to the proof of Lemma 16(d). The di¤erence between
these two proofs is there exists the C1 cycle in this lemma, so the length of the feasible routing
path is dRelative(s, t)+distphase3+distphase4 = cRelative+mRelative 2+sumX +1 =
cRelative +mRelative + sumX      2 + 1.
Corollary 25 Given two arbitrary node s and t in USn for n  5, if CR(s, t) =
C1O1O2:::OE1E2:::EH1H2:::HG1G2:::G with  >  and  > sumXE (Case B-2), the
upper bound for the routing distance is given by:
dFRoute(s, t) =
3(n 1)
2
.
Proof. The value of mRelative+sumXO sumXE is at most n since there exists the C1 cycle
and the value of  is at most b bn 12 c
2
c since the value of sumXO is at most bn 12 c. Based on
Lemma 24, we prove the corollary by considering the following four cases:
(a) sumX 0  sumG0 and sumX    is even: The length of the feasible routing path is
cRelative+mRelative+sumX  2  cRelative+mRelative+sumXO  + sumXE  2
= mRelative + sumXO   sumXE + 2  2 = n+ 2b b
n 1
2
c
2
c   2  3(n 1)
2
  1 since sumX is at
most sumXO       +   sumXE and cRelative = +  +  + .
(b) sumX 0  sumG0 and sumX  is odd: The length of the feasible routing path is cRelative+
25
dFRoute(s, t) =
8>>>>>>>>>><>>>>>>>>>>:
cRelative +mRelative + sumX      2 if sumX 0  sumG0
and sumX    is even,
cRelative +mRelative + sumX      1 if sumX 0  sumG0
and sumX    is odd,
cRelative +mRelative + sumX      2 if sumX 0 > sumG0
and sumX  2sumXE
2
is even,
cRelative +mRelative + sumX      1 if sumX 0 > sumG0
and sumX  2sumXE
2
is not even,
where sumX =

sumXO       +   sumXE   1 if (C1m0) 2 odd,
sumXO       +   sumXE if (C1m0) 2 even,
sumX 0 =

XO1 +XO2 + :::+XO sumXE +   sumXE if (C1m0) 2 odd,
XO1 +XO2 + :::+XO sumXE +   sumXE   1 if (C1m0) 2 even,
and sumG0 = +  +  + sumX   (XE1 +XE2 + :::+XE sumXO )  2sumXO.
Proof. Similar to the proof of Lemma 24, we can prove it by exchanging "pure-odd", sumXE,
and  with "pure-even", sumXO, and  in the argument of the Lemma 24 proof.
Corollary 29 Given two arbitrary node s and t in USn for n  5, if CR(s, t) =
C1O1O2:::OE1E2:::EH1H2:::HG1G2:::G with  >  and  > sumXO, either XC1 > 0
or (XC1 = 0 without sumXO = 0 and sumXE = 2) (Case B-4), the upper bound for the
routing distance is given by:
dFRoute(s, t) = 3n2 .
Proof. The value of mRelative + sumXE   sumXO is at most n + 1 since there exists the
C1 cycle and the value of  is at most b dn 12 e
2
c since the value of sumXE is at most dn 12 e.
Based on Lemma 28, we prove the corollary by considering the following four cases:
(a) sumX 0  sumG0 and sumX    is even: The length of the feasible routing path is
cRelative+mRelative+sumX  2  cRelative+mRelative+sumXE  + sumXO  2
= mRelative + sumXE   sumXO + 2   2 = n+ 1+ 2b d
n 1
2
e
2
c   2  3n
2
  1 since sumX is at
most sumXE      +    sumXO and cRelative = +  +  + .
(b) sumX 0  sumG0 and sumX  is odd: The length of the feasible routing path is cRelative+
mRelative + sumX      1  cRelative +mRelative + sumXE      +    sumXO      1 =
mRelative + sumXE   sumXO + 2   1 = n+ 1 + 2b d
n 1
2
e
2
c   1  3n
2
since sumX is at most
sumXE      +    sumXO and cRelative = +  +  + .
(c) sumX 0 > sumG0 and sumX  2sumXE
2
is even: The length of the feasible routing path is
cRelative+mRelative+sumX  2  cRelative+mRelative+sumXE  + sumXO  2
= mRelative + sumXE   sumXO + 2   2 = n+ 1+ 2b d
n 1
2
e
2
c   2  3n
2
  1 since sumX is at
most sumXE      +    sumXO and cRelative = +  +  + .
(d) sumX 0 > sumG0 and sumX  2sumXE
2
is not even: The length of the feasible routing path
is cRelative+mRelative+sumX  1  cRelative+mRelative+sumXE  + sumXO  1
= mRelative+ sumXE   sumXO+2  1 = n+1+2b d
n 1
2
e
2
c  1  3n
2
since sumX is at most
sumXE      +    sumXO and cRelative = +  +  + .
27
OE1E2:::EH1H2:::HG1G2:::G with XC1 = 0, (C11), (C1m0) 2 odd, sumXO = 0,
sumXE = 2, and  = 1, the length of the feasible routing path is given by:
dFRoute(s, t) = cRelative +mRelative + 2.
Proof. We merge the pure-even cycle withe the C1 cycle (Rule 3-4) since there exists neither
an odd X in a cycle nor a invariant position e. Then, we get the feasible routing cycle
structure. The length of the feasible routing path is cRelative +mRelative   2 + 4 = cRelative +
mRelative + 2.
Corollary 33 Given two arbitrary node s and t in USn for n  5, if CR(s, t) =
C1O1O2:::OE1E2:::EH1H2:::HG1G2:::G with XC1 = 0, (C11), (C1m0) 2 odd, sumXO
= 0, sumXE = 2, and  = 1, the upper bound for the routing distance is given by:
dFRoute(s, t) = 32n+ 2 .
Proof. Since cRelative  bn2 c and mRelative  n, the length of the feasible routing path is no
more than bn
2
c+ n+ 2  3
2
n+ 2.
Theorem 34 The diameter of the unidirectional n-star graph for n  5 is given by:
D(USn) =

2n  1 if n = 6,
2n if n 6= 6.
Proof. Combining the above corollaries, we get the theorem directly.
5 Comparison
Table 3: Comparison of the maximal routing distance.
USn Diameter DRA IDRA FRCS
US5 10 16 12 10
US6 11 21 16 11
US7 14 26 19 14
US8 16 31 24 16
US9 18 36 27 18
US10 20 41 31 20
US11 22 46 33 22
US12 24 51 38 24
We list in Table 3 the result of the maximum routing distances of US 5  US 12 by
di¤erent routing algorithms. The diameters of US 5  US 12 have been calculated by a bread-
rst algorithm and a tree structure; DRA lists the maximum lengths of the feasible routing
paths by Day and Tripathis algorithm; IDRA, which is the improvement of DRA with some
29
[11] K. Day and A. Tripathi, A comparative study of topological properties of hypercubes
and star graphs,IEEE Transactions on Parallel Distributed Systems, vol. 5, no. 1, pp.
31-38, 1994.
[12] K. Day and A. Tripathi, Arrangement graphs: a class of generalized star graph,
Information Precessing Letters, vol. 42, pp. 234-241, 1992.
[13] P. Fragopoulou and S.G. Akl, A parallel algorithm for computing Fourier transforms
on the star graph,IEEE Transactions on Parallel and Distributed Systems, vol. 5, no.
5, pp. 525-531, 1994.
[14] John B. Fraleigh, A First Course In Abstract Algebra,ISBN. 0-201-53467-3, Addison
Wesley, 1993.
[15] J.S. Jwo, S. Lakshmivarahan, and S.K. Dhall, Characterization of Node Disjoint
(Parallel) Path in Star Graphs, 5th International Parallel Processing symposium, pp.
404-409, 1991.
[16] J.S. Jwo and T.C. Tuan, On container length and connectivity in unidirectional hy-
percubes,Networks, vol. 32, pp. 307-317, 1998.
[17] S. Lati, On the Fault Diameter of the Star Graph,Information Processing Letters,
vol. 46, pp. 143-150, 1993.
[18] V. Mendia and D. Sarkar, Optimal broadcasting on the star graph,IEEE Transactions
on Parallel and Distributed Systems, vol. 3, no. 4, pp. 389-396, 1992.
[19] K. Qiu, S.G. Akl, and H. Meijer, On some properties and algorithms for the star and
pancake interconnection networks,Journal of Parallel and Distributed Computing, vol.
12, pp. 16-25, 1994.
[20] S. Ranka, J.C. Wang, and N. Yeh, Embedding meshes on the star graph,Journal of
Parallel and Distributed Computing, vol. 19, pp. 131-135, 1993.
[21] S. Rajasekaran and D.S.L. Wei, Selection routing and sorting on the star graph,
Journal of Parallel and Distributed Computing, vol. 41, pp. 225233, 1997.
[22] Y. Rouskov and P.K. Srimani, Fault Diameter of Star Graphs,Information Processing
Letters, vol. 48, pp. 243-251, 1993.
[23] J.P. Sheu, W.H. Liaw, and T.S. Chen, A broadcasting algorithm in star graph in-
terconnection networks, Information Processing Letters, vol. 48, no. 15, pp. 237-241,
1993.
31
2 
 
• Keynote: Seamless Middleware Services for Pervasive Computing Environments  
• Speaker: Mohan Kumar (The University of Texas, Arlington, USA)  
• Symposium on Computational Intelligence for Sensor Networks I & II 
• Symposium on Sensor Networks: e-Sense & Information Processing 
• Symposium on Autonomous Configurability and Control in Dynamic Wireless Networks 
• Symposium on Middleware for Sensor Networks I 
 
二、與會心得 
此次與會感到最有興趣的部份是在會場中推廣的一項技術規格(e-SENSE)，除
了對議程中 e-SENSE 相關的論文簡報深感興趣，也帶回他們在展場提供的資料。
相關內容，整理簡述如下： 
• e-SENSE 計畫網頁 http://www.ist-e-sense.org/ 
介紹的是一個新穎的 wireless senor networks (WSN)架構，用來獲得我們生
活周遭的裝置資訊，並且可以加以整合到目前 3G IP Multimedia Subsystem 系統
底下。與 ZigBee 相比，提供了值得我們注意的優勢。這個架構就叫做 e-SENSE。 
• Integration of the e-SENSE system into IMS 
下圖簡單的表示出一個簡單的 IMS 架構，其中包括了 e-SENSE 的 service 
enabler (SE)和 e-SENSE 系統本身，當然也包括了原本 IMS 的元件。這個架構利用
SIP 將 e-SENSE 整合到原本的 IMS 裡，這意味著 e-SENSE SE 可以透過 AS 來當作
一個提供服務的區塊，提供各種不同有關裝置資訊相關的服務。 
 
• e-SENSE Service Enabler 
e-SENSE SE 是唯一用來和 IMS 應用溝通的元件，且處理從 e-SENSE system
獲得的裝置資訊。 
• Gateway Extensions 
Gateway extensions 提供 e-SENSE system 能夠整合到 IMS 下的介面，讓
e-SENSE SE 和 e-SENSE system 能夠互動並且使用一些服務的功能。 
 
Simultaneous Handover Support for Mobile Networks 
on Vehicles 
 
Wei-Kuo Chiang, Member, IEEE, Wen-Yen Chang, and Liang-Yu Liu 
Department of Computer Science and Information Engineering 
National Chung Cheng University 
Chiayi 621, Taiwan, R.O.C. 
{wkchiang, cwy91u, lly95m}@cs.ccu.edu.tw 
 
 
Abstract—With high mobility rates of vehicles, there may be 
frequent occurrences of simultaneous handover. Our work 
focuses on and straightens out the problems resulting from 
simultaneous handover in SIP-NEMO. This article proposes a 
proxy-aided simultaneous handover (PASH) mechanism for the 
architecture of mobile networks operating on vehicles. The 
system architecture is modified from SIP-NEMO. We design a 
Fast Route/local routE re-Establishment (FREE) algorithm 
capable of re-establishing the optimized routing path fast and 
ensuring signaling messages buffered in local proxy could be sent 
to the correct destination without loss. Moreover, the Master-
Slave Determination procedures derived from H.245 are 
introduced to handle the racing conditions fairly when two local 
proxies involved in a simultaneous handover issue re-INVITE 
requests at about the same time. Analytical results show that the 
handover delay can be improved significantly using the PASH, 
compared with the home-aided simultaneous handover. 
Keywords- SIP; network mobility; simultaneous mobility 
I.  INTRODUCTION  
As the demand for ubiquitous computing increases, various 
architectures have been proposed for mobile networks. An 
emerging form of this ubiquitous connectedness is vehicle 
networks, especially in public transport systems, such as trains, 
planes, buses, etc. Many researchers have been working 
towards developing mechanisms for such mobile networks so 
that all nodes in a mobile network can still maintain their 
ongoing sessions as the mobile network changes its point of 
attachment to the Internet [1]-[5] . 
The network mobility (NEMO) basic support protocol [3] 
has been proposed as a standard, based on an extension of 
MIPv6, called MIPv6-NEMO hereafter for convenience, to 
manage the mobility of a moving network and maintain the 
global reachability for all nodes in the network.  Thus, network 
mobility reduces the number of handover and reduces 
complexity of location update too. Nevertheless, it has some 
limitations in terms of performance, due to the increased path 
length and the packet header overhead that this solution 
introduces [4]. To overcome these limitations for real-time 
multimedia transmission, a SIP-based network mobility 
management scheme called SIP-NEMO was proposed [5]. SIP-
NEMO not only avoids those problems inherited from MIPv6 
but also provides the optimized route path for data transmission. 
However, SIP-NEMO uses direct binding updates to achieve 
the route optimization between two SIP clients; thus, it is 
vulnerable to the simultaneous handover problem. 
Simultaneous handover is the special case when two 
communication nodes are mobile and both move at about the 
same time. Consider that mobile networks are usually deployed 
on vehicles, with higher mobility rates of vehicles, there may 
be more frequent occurrences of simultaneous handover. 
Moreover, the disruption caused by the simultaneous mobility 
may far exceed the typical disruption caused by the non-
simultaneous mobility; therefore, we must solve it properly. 
This article proposes a Proxy-Aided Simultaneous 
Handover (PASH) mechanism for the architecture of mobile 
networks operating on vehicles. The system architecture is 
modified from SIP-NEMO. We design a Fast Route/local routE 
re-Establishment (FREE) algorithm cooperating with two new 
SIP user-defined headers – Record-Axis and Axis. The main 
concept of FREE algorithm is not only to re-establish the 
optimized routing path as fast as possible but also to ensure 
signaling messages buffered in local proxy could be sent to the 
correct destination without loss under simultaneous handover. 
Furthermore, a fair Master-Slave Determination procedure is 
proposed to overcome the racing condition arising from that a 
local proxy receives two re-INVITE requests coming from 
different sources but belonging to the same dialog. 
The remainder of this article is organized as follows. 
Section II reviews previous works on network mobility and 
simultaneous handover. Section III describes the PASH 
architecture of mobile networks. In section IV, we propose the 
proxy-aided simultaneous handover (PASH) mechanism and 
the FREE algorithm. In section V, we present a home-aided 
simultaneous handover (HASH) and then evaluate the 
handover delay and the improvement ratios of the PASH 
compared with HASH. Section VI concludes this article. 
II. PREVIOUS WORKS 
This section briefly introduces some researches and 
protocols relating to this article. 
A. SIP-NEMO 
SIP-NEMO [5] extends the SIP framework; it should 
coexist and be compatible with SIP. SIP clients can roam from 
the SIP framework to the SIP-NEMO environment, and vice 
versa. SIP-NEMO defines a SIP network mobility server (SIP-
NMS) for each mobile network. Each SIP-NMS has one 
1525-3511/08/$25.00 ©2008 IEEE
This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the WCNC 2008 proceedings.
2771
Step 8. NA2 receives the INVITE, translates the Contact field, 
and forwards it to UA2.  
Step 9-14. UA2 receives the INVITE and sends 200 OK to 
UA1. 
Step 15-20. UA1 sends ACK to UA2. The routing path based 
on the Route header is “NA1, SCM1, SCM2, NA2.” Finally 
the session is established. 
IV. PROXY-AIDED SIMULTANEOUS HANDOVER 
For the purpose of solving simultaneous handover problem 
and keeping routing path optimized, we devise a Fast 
Route/local routE re-Establishment (FREE) algorithm and add 
the two new SIP user-defined headers  Record-Axis and 
Axis. With the aid of FREE algorithm, the optimized routing 
path including local route could be re-established faster; 
moreover, the buffered messages are also re-sent to correct 
destination without loss. In addition, while both SCMs detect 
the racing condition resulting from sending the re-INVITE and 
receiving the re-INVITE from the other side as well, the fair 
Master-Slave Determination procedures are proposed to 
overcome this condition, remove the redundant overhead, and 
eliminate the unexpected results. 
A. Construction of Record-Axis and Axis Headers 
Record-Axis header could be seen as a set of points on X-
axis and Y-axis. We defined the two rules to form Record-Axis 
header as follows: 
1. If sending the request via egress interface, UA/NA/SCM 
adds itself to a point on X-Axis of which X-coordinate is 
(max(X) + 1). 
2. If receiving the request via egress interface, 
UA/NA/SCM adds itself to a point on Y-Axis of which Y-
coordinate is (min(Y) - 1). 
Note that the initial point is origin, that is, X-coordinate 
must be positive and Y-coordinate must be negative for all 
points added. Similar to the relationship between Record-
Route header and Route header, Record-Axis header should be 
copied to Axis header for subsequent requests once session is 
established or re-established. An example for construction of 
Record-Axis header during call set-up is depicted in Fig. 3. 
  
Figure 3.  Construction of Record-Axis header during call set-up. 
B. FREE lgorithm 
 
UA/NA/SCM will send/receive a re-INVITE message with 
a growing Record-Axis header and the Axis header copied 
from the previous Record-Axis header in case of handover. 
After updating the growing Record-Axis header according to 
the rules mentioned in Section IV-A, NA/SCM commences to 
run respective FREE algorithm and eventually sends out the re-
INVITE message. 
We suppose the SCM would choose the egress interface for 
delivering by default upon receiving the re-INVITE message 
from UA/NA, so that it could add itself to X-Axis in the 
Record-Axis header despite local route. Additionally, the SCM 
must extract and store the newest Record-Axis header and 
dialog information from the request coming from the UA/NA 
until session is established or re-established. Furthermore, the 
NA always needs to keep the newest Record-Axis header once 
receiving the request from passengers until nosing out 
detachment of passengers. 
What follows is detailed elaboration of FREE algorithm 
respectively for SCM and NA. An illustration applying FREE 
algorithm to simultaneous handover is demonstrated in Fig. 4. 
FREE-SCM: 
Rule 1. If (Y of the Record-Axis header) = φ , compare (X 
of the Record-Axis header) with (X of the Axis header) to 
check if they are identical: 
1-1. If yes, routing is based on Route header. 
1-2. If no, send a SIP SUBSCRIBE message with dialog 
information to (max(X) of the Axis header), and 
forward the re-INVITE message to (max(Y) of the Axis 
header). 
Rule 2. If (Y of the Record-Axis header)φ  
2-1. If learning that it has been subscribed after checking 
dialog information, the SCM empties out (Y of the 
Record-Axis header) and then sends the re-INVITE 
message to subscriber. 
2-2. If being a subscriber itself, the SCM replaces Route 
header with (X of Router-Axis header) which was 
extracted and stored from the re-INVITE request 
coming from the UA/NA before. 
2-3. Else, the SCM replaces Route header with (Y of Axis 
header). 
FREE-NA: 
Rule 1. If (Y of the Record-Axis header) =φ , compare (X 
of the Record-Axis header) with (X of the Axis header) to 
check if the former is prefix of the latter: 
1-1. If yes, routing is based on Route header. 
1-2. If no, forward the re-INVITE message upwards. 
Rule 2. If (Y of the Record-Axis header)φ  
2-1. If (Y of Record-Axis header) only contains itself, the 
NA empties out (Y of the Record-Axis header) first. 
Then, search (X of the Axis header) and (Y of the Axis 
header) in order to find and copy the duplicate part to 
the Record-Axis header and retain their original 
coordinates. Lastly, add itself to (Y of Record-Axis 
header) and deliver the message. 
2-2. Else, routing is based on Route header. 
This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the WCNC 2008 proceedings.
2773
M
aster : U
A
1
Slave: U
A
2
M
aster : U
A
2
Slave: U
A
1
Re-INV
ITE &
FR
E
E A
lgorithm
R
egistration &
 
Session
Re-establishm
ent
 
Figure 6.  The PASHmessage flow under simultaneous handover. 
Fig. 7 depicts the message flow of the HASH in the same 
scenario as that illustrated in Fig. 6. Note that procedures in 
interval 1 and interval 2 proceed in parallel. When one of them 
finished the re-INVITE procedure first, the handover completes. 
 
Figure 7.  The HASH message flow under simultaneous handover. 
Comparing the PASH with the HASH done here is on the 
basis of handover delay only. The following notations are used 
in the analysis: 
 The time switching wireless access network is 2LT . 
 The time for Layer 3 detecting is 3LT , i.e., the time 
between reception of an L2 trigger and DHCP replay. 
 The time to discover an SCM for a SIP Proxy is erDisT cov . 
 The time to detect the change of IP address in the 
application layer is DetectT . 
 The propagation delay between the SCMs of both sides 
is  SCMSCMT ⇔ ; the propagation delay between the 
previous detached-SCM and the new attached-SCM 
is   '  SCMSCMT ⇔ . 
 The propagation delay between the UA and its home 
server is   UHSUAT ⇔ ; the propagation delay between one 
UA and the home server of the other UA is   '  UHSUAT ⇔ . 
 The propagation delay between the UA and the NA 
is NAUAT ⇔  , and so on. 
 N represents the number of service providers for the UA 
and the NA. 
Assume wireless transmission latency is insignificant 
compared to wired propagation delays, considering relatively 
high bandwidth in the wireless link [11]. 
Suppose that ( 2LT + 3LT + erDisT cov ) is one unit; the 
propagation delay across two networks is α  unit, and the 
propagation delay in the same network is β  unit. It is 
anticipated that ( 0 1β α< < ≤ ) or ( 0 1β α< < ≤ ) for the 
following reasons: 
( 2LT + 3LT + erDisT cov ) consists of detach/attach time, one 
DHCP query for getting local IP addresses, and the discovery 
of the SCM, so it must be longer than propagation delay in the 
same network. That is, 1β < . 
The propagation delay across two networks takes longer 
time than the propagation delay in the same network. So it is 
anticipated that β α< . The propagation delay across two 
networks increases/decreases depending on the number of 
routers in path, so it could be longer/shorter than one unit. That 
is, 1α ≤  or 1 α≤ . Also, DetectT  is assumed to be zero here 
owing to the possibility of the emergence of mature cross-layer 
solutions in the future. 
Due to the lack of actual deployment of the discussed 
architecture, it is delicate to predict the number of calls 
involving the components of this architecture in the same 
domain. We use the following set of data, which comes from 
the GSM world [12]: 
 Percentage of roaming subscribers: 20% 
 Percentage of UA calling a UA in another home network: 
60% 
Table I lists the parameters for analysis and their delay time 
derived based on the above data. 
According to Fig. 6 and Fig. 7, the total handover delays of 
two mechanisms under simultaneous movement are shown in 
Table II. PASHT  is the handover delay of proxy-aided 
simultaneous handover. HASHT  is the handover delay of home-
aided simultaneous handover. 
By applying the set of data in Table I to the equations in 
Table II, we rewrite them to get: 
PASHT = 1+(0.512+0.208x 1-
2-
N
N +0.024x
2
2
)1(
33
−
+−
N
NN ) α + 
(3.256+0.208x
1-
1
N
+0.024x
21)-(
2-
N
N ) β + MIN((1.024+0.416x
1-
2-
N
N

+0.048x
2
2
)1(
33
−
+−
N
NN ) α +(7.512+0.416x
1-
1
N
+0.048x
21)-(
2-
N
N ) β 
(1.536+0.624x
1-
2-
N
N +0.072x
2
2
)1(
33
−
+−
N
NN ) α +(5.768+0.624x
1-
1
N

+0.072x
21)-(
2-
N
N ) β 
HASHT 1+(4.48+0.36x 1-
2-
N
N ) α +(6.16+0.36x
1-
1
N
) β . 
This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the WCNC 2008 proceedings.
2775
