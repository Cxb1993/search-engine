A Defense Against Clock Skew Replication Attacks in Wireless Sensor
Networks
Ding-Jie Huang, Wei-Chung Teng∗
Department of Computer Science and Information Engineering
National Taiwan University of Science and Technology,
Taipei, Taiwan
Abstract
As studies to date have demonstrated that the clock skew of every physical device differs and so is
suitable for device identification in network communications, the fact that any adversary can easily produce
a fake clock skew by altering the timestamp of the sent packets remains a concern. This study contributes
to this issue by realizing a replication attack of an indistinguishable fake clock skew and by developing
its countermeasure in a wireless sensor network environment. In the first part of the study, a method of
timestamp back calculation is developed for imitating the clock skew of a neighbor node. Given the relative
clock skews of a victim node and an imitated node, our method calculates the time difference between the
attacker node and the imitated one, which makes the biased timestamps of the attacker node’s packets,
when measured by the victim node, derive to the exactly the same clock skew as the imitated node. Our
experiment results show that the success rate of physical replication attacks ranges from 82.5% to 95%. In
the second part of this study, a novel approach is proposed to defend against such clock skew replication
attacks. This approach is based on our observation that a precise skew estimation can be performed only
when the packets are sent at fixed time intervals. When the time period of the synchronization is changed
frequently, our experiments show that the success rate of an attack is considerably reduced to less than
2.4%, or even 0% in most cases.
Keywords: Wireless sensor networks, clock skew, replication attack
1. Introduction
As wireless sensor network (WSN) based applications have matured over the last decade, security issues
for WSNs have become an important research topic. Due to their inherent limitations of energy, computing
power and memory size, WSNs have increased the difficulty of developing practical yet effective data security
technologies. For instance, classic public key cryptographic methods take a large amount of computation
time and are not suitable to be applied directly in WSNs. Liu and Ning developed a framework, named
TinyECC, to provide an efficient public key cryptography (PKC) for WSNs [18]. However, as many WSN
applications have their nodes distributed in open space, an attacker can physically capture, analyze and
compromise one specific node to collect key information. Therefore, an adversary still has a chance to
launch an attack after stealing the secret key.
Since WSNs support dynamic network routing, a new node added by attackers can easily become an
intermediate node between any pair of nodes, thereby stealing, replicating or even faking the feedback data.
Also, as the identity in WSNs is easy to fake, many attacks are launched by utilizing this flaw. For example,
a Sybil attack [5] can be launched by exploiting the vulnerability of node identities in WSNs and pretending
∗Corresponding author
Email addresses: D9515002@mail.ntust.edu.tw (Ding-Jie Huang), weichung@mail.ntust.edu.tw (Wei-Chung Teng)
Preprint submitted to Journal of Network and Computer Applications October 29, 2012
3. Skew: The difference in frequency of two clocks, e.g., the skew of Cr relative to Cs at time t is
C′r(t)− C
′
s(t).
2.2. Clock Skew-Based Node Identification
Generally, modern processor clocks have two properties [25, 21, 14, 6, 29]: first, the clock skew between
two devices is stable over a long period of time under normal temperature; second, there is a distinguishable
clock skew between any two physical devices. According to these two properties, the clock skew can be used
as a fingerprint of any device with a digital clock. Since 2005, when Kohno proposed a method to fingerprint
every computer in a general communication network by analyzing its clock skew [14], many researchers have
attempted to develop clock skew-based identification for different types of networks. For example, Murdoch
proposed a method to detect the identities of computers behind a Tor network by using the clock skew as
a fingerprint [22]. From a user’s perspective, that method could launch an attack to break the anonymity
behind the Tor network. In 2008, Zander and Murdoch developed an enhanced attack with a synchronized
sampling technique [35] which significantly reduced the quantization error and thus eliminated the heavy
network traffic necessary to the previous attack proposed by Murdoch. Their work was the first to undertake
clock skew estimation through the HTTP protocol.
Since clock skew can be used as a fingerprint, some researchers have proposed practical mechanisms to
detect malicious devices. For example, Jana and Kasera successfully utilized clock skew as a defense tool
to detect unauthorized wireless access points in wireless local area networks [13]. Recently, clock skew has
been used to check node identification in WSNs. The mechanism can be categorized into two scenarios:
End-to-end: Uddin and Castelluccia provided an end-to-end method to detect virtual sensor nodes, worm-
holes and Sybil attacks in WSNs [33]. They also confirmed that sensor motes have both a different and
unique clock skew even when the temperature varies from 4 to 60 degrees Celsius. In the end-to-end scenario,
only the sink node can execute the clock skew-based identification method; the sink node itself does not send
out its time information to others. In this manner, as the malicious node cannot collect the time information
from the sink node, this method is more secure under an encryption channel. However, a malicious node is
capable of imitating a normal node’s skew if the secret key is known to the attacker.
In-network: In the in-network scenario, every node can use the clock skew to check the identity of its
neighbor nodes, as proposed by Huang et al. [11, 12]. The in-network method can be used to identify
sensor nodes in WSNs by utilizing a two-tier clock skew filter. Since a sensor node is deployed with finite
neighbors, the in-network method is feasible in WSN environments. Furthermore, as it is assumed that the
temperature of a certain region is not extremely varied during a particular period of time, the clock skew
can be a practical tool to represent the identity of a device. The results of previous analysis confirmed that
clock skews can be used to represent the fingerprints of sensor nodes and that the method can be used to
defend against a Sybil attack. For instance, if a malicious node wants to fake multiple identities, all these
fake identities generated by the same node would have the same skew averages within 0.15 ppm (parts per
million). Thus, a Sybil attack can be easily detected by using this method. However, since every node can
collect the time information of its neighbor nodes, a malicious node can imitate another node’s clock skew
if the secret key is known. In this study, as the end-to-end scenario can be considered as an extension of the
in-network one, we focused on the in-network method to provide a solution to the aforementioned issue.
2.3. Flooding Time Synchronization Protocol (FTSP)
FTSP is one of the most popular technologies for time synchronization in WSNs [19], and there is much
research being conducted on the basis of FTSP [28, 15, 27, 20, 10, 12]. FTSP provides a dynamic hierarchical
time synchronization topology and high precision by utilizing both MAC-layer timestamping with a jitter
reducing technique and a linear prediction of global time technique. Thus, the delay caused by data access,
hardware interruption, and the distance between each node can be kept to a minimum.
The process of time synchronization in FTSP can be simplified as follows: the node with the smallest
ID is chosen as the root node at the beginning; then the root node uses its own timestamp as the global
time and sends out time synchronization packets by broadcasting. After receiving a synchronization packet,
each neighbor node records the timestamp of the receiving time, which is the local time of the receiver, and
3
Figure 1: A typical model of a replication attack in a WSN running FTSP
According to the clock skew-based node identification [11], the relative clock skew between each pair
of nodes is used as a fingerprint to certify the identities of the sensor nodes. If an adversary node is used
to launch a replication attack on the clock skew-based node identification, it needs either to directly or
indirectly duplicate the clock skew of the target node. Since a receiver node is able to calculate the relative
clock skew of a sender node after it has collected enough SLT data, a malicious node can imitate the clock
skew of any target node by backtracking the relative skew, as long as this malicious node is able to receive
the SLT from the target node.
3.1.1. Clock Skew Replication Attack Model
A typical replication attack model while running FTSP is shown in Fig. 1: node R stands for the root
node which sends out its SLT as the GT ; node A is the attacker node which sends out fake timestamps
to imitate the clock skew of the target node; node T is the target node whose identity node A wants to
fake; and node V is the victim node which node A wants to deceive. As shown in Fig. 1, node T cannot
directly connect with node R, but node T can receive the time synchronization packets via the route of the
dotted line by multi-hop communication and extract the GT . Nodes T , A and V are neighbors and can
communicate with each other through a one-hop connection.
When node T sends out the synchronization packets to node A and node V , these two nodes would
respectively compute their relative clock skews to node R by extracting the GT from the synchronization
packets. Here, the relative clock skew of the root node to node A is called skewRA; similarly the clock skew
of the root node to node V is called skewRV . Since nodes T , A and V are neighbors, node A can compute
skewTA from node T by collecting the SLT of node T , and node V can compute skewTV from node T in
the same way. In this study, it was assumed that node V utilized the clock skew-based node identification
to verify the identity of its parent, node T . The malicious node, node A, tries to launch a replication attack
on the clock skew-based node identification by duplicating the clock skew, skewTV .
Since the hop distance between each node can result in variations to the skew average, we further
considered two kinds of synchronization: the one-hop scenario and the multi-hop scenario.
One-hop scenario: Each node communicates to its neighbor nodes through a one-hop connection, so the
attacker node can directly gather the time information from the target node. For instance, node A may
want to deceive node V by imitating the identity of node T . By duplicating skewTV , node A can launch a
replication attack in this one-hop scenario, as illustrated in Fig. 1.
Multi-hop scenario: If the distance between a target node and the attacker node is greater than the
communication range, the attacker node cannot directly connect with the target node. Thus, the attacker
node can only gather the information of the target node through multi-hop synchronization. For example,
node A may want to imitate the identity of node R by duplicating skewRV .
5
Table 2: Relative clock skews and the corresponding diff s of nodes T , A and V
T → V T → A V → A A → T A → V
skew -16.93 25.51 42.68 -24.52 -41.11
diff -24 35 ∼ 36 59 ∼ 60 -35 ∼ -36 -59 ∼ -60
Skew unit: ppm diff unit: tick
By applying the analysis of diff, node A can induce the relation between itself and node T , thereby generating
fake timestamps.
Although the time period is a constant in the same mote, different motes have different time periods
because the resonant frequency of the quartz crystal in each mote is different. To generate a fake timestamp,
node A needs to further calculate the difference in the time period between node T and node V .
3.2.1. Calculation of the diff
In FTSP, every node broadcasts its time synchronization packets to its neighbor nodes periodically.
Because each oscillator has a slight variation in frequency, the clock of each node is different from that of
the others; this difference increases during a period of time, which is known as the clock skew. In addition,
there is a propagation delay between any two nodes [8]. These two factors cause the time offset between two
motes, as mentioned in Section 2.4. According to FTSP [19], a propagation delay of 300 meters between two
nodes is less than 1µs. Since the distance between the two nodes in our experiments was less than 30 meters,
the propagation delay would be constant and negligible. Thus, as we have only discussed the condition of
one-hop scenario, the propagation delay was ignored in our calculation.
Table 2 summarizes the skews and diffs in the preliminary experiment. The skew field shows the average
of the relative clock skew and the diff shows the range of difference between two consecutive offsets. The
diff also obeys the additive inverse and the linearity relation. As the diff is much more precise than the
estimated skew, the diff could be utilized to implement the imitation algorithm.
To proceed with our discussion, some functions need to be defined. Given a malicious node which launches
a replication attack at the nLth synchronization, the notations and meanings of these functions are as follows:
TS(s, t, nL) Timestamp of sender s in the nLth packet with s altering its timestamp to im-
personate node t. If s is not performing an attack, its timestamp is denoted as
TS(s, s, nL).
TR(s, r, nL) Local timestamp of node r when it received the nLth synchronization packet from
node s.
offset(s, t, r, nL) Offset between sender s and receiver r derived from the nLth synchronization packet
sent from s when s is imitating the clock skew of target t. If s is not performing an
attack, we denote the offset as offset(s, s, r, nL).
diff(s,t,r,nL) Diff derived from offset(s, t, r, nL+1) and offset(s, t, r, nL). If s is not performing
an attack, we denote the diff as diff(s, s, r, nL). In order to simplify the notations,
diff(T, T, V, nL) is denoted as diffTV and diff(A,A, V, nL) is denoted as diffAV in
some equations.
According to these definitions, the diff between node A and node V at the nLth synchronization can be
derived as follows:
diff(A,A, V, nL) = offset(A,A, V, nL + 1)− offset(A,A, V, nL). (6)
Therefore, in order to compute one diff, two contiguous offsets are necessary. Then, according to the
definition, the offset between node A and node V at the nLth synchronization can be deduced from:
offset(A,A, V, nL) = TS(A,A, nL)− TR(A, V, nL). (7)
7
Therefore, given any positive integer γ, we may derive the general form of TS(A, T, nL+γ) by applying (12)
recursively:
TS(A, T, nL + γ) = TS(A,A, nL + γ)+
nL+γ∑
j=nL+1
(diff(A, T, V, j)− diff(A,A, V, j)), γ ∈ Z+.
(13)
Since diff(T, T, V, nL) is the target diff that node Awants to imitate, nodeA should generate a diff(A, T, V, nL)
which is equal to diff(T, T, V, nL). According to the additive inverse and the linearity relation of the diff, we
can induce diffTA by:
diffTV − diffAV = diffTV + diffV A = diffTA. (14)
By substituting (14) into (13), the fake sending time can be represented as:
TS(A, T, nL + γ) = TS(A,A, nL + γ)+
nL+γ∑
j=nL+1
(diff(T, T,A, j)), γ ∈ Z+.
(15)
Thus, malicious node A can calculate diffTA and generate the fake outgoing timestamp by using (15). In
this manner, malicious node A can generate a fake skew with the same pattern of skewTV .
Another way to calculate a fake sending time is to use a constant diff as a prediction tool. Since the
clock skew is relatively stable over a long period of time, the diff is a constant value theoretically, which
induces Equation (16).
diff(A,A, V, nL) ∼= diff(A,A, V, nL + 1) and
diff(A, T, V, nL) ∼= diff(A, T, V, nL + 1)
(16)
Thus, by substituting Equation (16) in (15), the general form of TS(A, T, nL+γ) can be simplified as follows:
TS(A, T, nL + γ) ∼= TS(A,A, nL + γ)+
γ × (diff(T, T,A, nL)), γ ∈ Z+.
(17)
Basically, both (15) and (17) can be used to generate a fake skew. The main difference of these two
equations is the accuracy. As stated above, although the clock skew is stable within the range of 0.15 ppm,
it is possible to accumulate the error between the imitated skew and the target skew when the attacker
applies Equation (17). In other words, the imitated skew may be the same as the target one by using (17)
at the beginning of the attack, but the attack may not succeed over a long period of time because of the
accumulated error. A more detailed experimental analysis is given in Section 4.2.
3.2.2. Adapting the Time Period of the Target Node
As stated above, the sending period is a constant time. The default sending period in FTSP is 90
seconds, so the default value of time period is 2,880,000 ticks in 32kHz precision. Fig. 3 illustrates how
node A, V and T differ in terms of the time length of one time period. From the perspective of node T , its
own time period is always 2,880,000 ticks. However, the same time length requires 2,880,024 ticks from the
perspective of node V . We denote this relative number of ticks as time periodTV , which can be derived by:
time periodTV = time period + diffV T = time period − diffTV . (18)
In the same way, the relative number of node A is 2,879,964 ticks.
In order to cheat node V , node A has to imitate the sending period of node T to node V . Since node A
can compute time periodTA by observing the packet from node T , it can simply replace its time period with
time periodTA to cheat the victim node.
To verify this observation, we first calculate the original sending period of node A from the perspective
of node V :
time periodAV = time period − diffAV . (19)
9
to Equation (20). This effect also leads to a wrong calculation of a fake timestamp. Thus, changing the
sync period can seriously affect the correctness of skewAV .
According to our experimental results, a slight reduction in the sync period causes diffAV to change
considerably during the next few rounds. As a result of this condition, the attacker node must take several
periods to recalculate a new diffAV . Meanwhile, diffAV fluctuates abnormally and the victim node can
simply filter out the manipulated skewAV from skewTV . It is easy to change the sync period of each node
by assigning a new value to the parameter time period. It is important that this change does not affect the
value of skewTV because time period does not affect the skew estimation as implied in Equation (2). Thus,
it can be applied to our defense algorithm without affecting the correctness of the clock skew-based node
identification. Experiments and analysis of the effect from changing the time period are described in Section
4.3.
The discussion above leads to the proposed defense method as shown in Algorithm 1. This algorithm
consists of two phases:
1. Detection phase: In the beginning of a replication attack, the target node receives a packet of
its own ID, and then it knows that a replication attack has been launched. In this case, the target
node proceeds to the next phase. Otherwise, the victim node should be able to detect the replication
attack according to the inconsistent behavior of the target node, such as two packets with the same
ID and seqnum. Once the replication attack has been detected, the victim node asks the target node
to proceed to the defense phase. Finally, if the working communication protocol is vulnerable to
replication attacks, such that it is difficult to tell if an attack has been launched, the target node can
skip the detection phase at the very beginning for the sake of security.
2. Defense phase: During this phase, the target node and the victim node intermittently decrease their
sync period, which we call entering the burst mode. During the period of the burst mode, the target
node and the victim node decrease their time period to a random value for seven rounds and then
return to the original period for another seven rounds. Once the replication attack ends, the target
node and the victim node stop the burst mode. Since the burst mode increases energy consumption
slightly, it should be used only when necessary.
Each time the sync period is changed, the manipulated skewAV becomes obviously different from skewTV :
the attacker node needs eight rounds to obtain a new skewAV . However, as the sync period changes every
seven rounds, the attacker node never has a chance to generate a fake skew close enough to the real one.
During the burst mode, the victim node can easily distinguish the difference between skewTV and skewAV
because the difference fluctuates so noticeably; thus, most, if not all, fake skews exceed the 0.15 ppm
fluctuation threshold [11]. This method is effective but easy to implement because we only need to add a
component to execute the attack detection and the burst mode in FTSP. Without any further calculation,
the victim node can note the replication attack and filter out packets from the malicious node. Even if there
is packet loss between node T and node V , the performance of burst mode would not be affected because
the purpose of burst mode is to affect diffTA between node A and node T .
As an application of our scheme, consider the case of an attacker node wanting to poison the FTSP
buffers of its neighbor nodes. This attacker calculates a fake sending time TS(A, T, nL + γ) and sends out
the fake packet with seqnum nL + γ + 1 every round to assure that the receiver nodes always accept its
packets according to FTSP. If no defense mechanism is used, node V would only receive fake packets, since
synchronization packets from node A always arrive earlier than the ones from node T . The challenge in
implementing the defense method is that fake packets must be filtered out immediately after being received
by node V , or the fake timestamps will accumulate in the skew estimation buffer. In this case, we can apply
Algorithm 1 to node T and further utilize a filter with the 0.15 ppm fluctuation threshold at node V as
proposed in [11]. Incoming packets will be dropped by node V if the skews calculated with these packets
do not pass through the filter. By utilizing Algorithm 1 and the fluctuation filter, we believe that attacker
nodes are unable to poison the FTSP buffers of their neighbor nodes.
11
Figure 5: Network configuration for experiment of clock skew imitation
50 100 150 200 250 300 350 400 450 500
−4.5
−4
−3.5
x 10−5
Cl
oc
k s
ke
w 
(s
/s)
 
 
SkewTV
SkewAV
50 100 150 200 250 300 350 400 450 500
−4.6
−4.59
−4.58
−4.57
−4.56
x 10−5
(seqnum)
Cl
oc
k s
ke
w 
(s
/s)
 
 
SkewTV
SkewAV
Figure 6: Experiment result of the replication attack with a constant diff in two different scales. The
upper part shows that skewAV starts to approach skewTV after seqnum 132, as indicated by a dash-
dotted line. The lower part is the partial enlargement of the same attack period, and it shows that the
distance between skewAV and skewTV increases as of seqnum 400.
where n is the total number of synchronization rounds, skewTV is the average of the estimated skewTV and
skewAV,i is the skewAV calculated at round i. The closer this value is to zero, the closer skewAV is to the
average of the estimated skewTV . The RMS error can evaluate the closeness of the two skew values. Second,
ASR is computed by executing clock skew node identity detection to every incoming packet, as introduced
in Section 2.2. This value represents the practical performance of the attack. A higher ASR means that
there are more malicious packets passing through the inspection. For example, if 90 out of 100 malicious
packets can pass through the clock skew node identity detection mentioned in [11], ASR would be 90%.
4.2. Clock Skew Replication Attack Experiments
In the general setup, we used five motes, including: one base station, one poller, the target node, the
attacker node and the victim node. The base station collects data from the three nodes and forwards these
data to a computer; the poller periodically sends requests to ask other nodes for their local time and other
necessary information. Here, the base station and poller were not involved in our scenario and were used
only to monitor the progress of the experiment. Node T is the target node and serves as the root node in
this scenario; node V is a victim node; and node A is the attacker node. In Fig. 5, the arrows represent
the direction of the synchronization packet. As in the attack scenario introduced previously, node A wants
to cheat node V by pretending to have the identity of node T . In order to confirm the effectiveness of the
clock skew replication attack, we set up two experiments to implement the replication attack stated above
by either applying Equation (17) or (15).
Replication attack with a constant diff : In the first experiment, the attacker uses a constant diff
by applying Equation (17) to implement the replication attack. Also, the time period adaptation shown
13
Table 3: Performance evaluation of the replication attack
Exp 1 Exp 2 Exp 3 Exp 4 Exp 5 Exp 6 Exp 7 Exp 8 Exp 9 Exp 10
ASR 82.56% 87.47% 93.75% 88.26% 94.27% 91.61% 88.39% 91.56% 95.17% 94.38%
RMS 0.106 0.152 0.033 0.029 0.164 0.03 0.127 0.021 0.068 0.02
PKS 929 1669 240 656 646 1467 862 948 829 2831
ASR = attack success rate, RMS = RMS error, PKS= number of packets
poller and base station, but each experiment used the T node in the previous experiment as the A node,
used the V node in the previous experiment as the T node, and used a new mote as the V node. Thus, in
total 14 motes were used in these 10 experiments. Table 3 gives the evaluation results of all 10 experiments.
The time used to conduct each experiment, which was also proportional to the number of packets, varied
from 90 minutes to almost 24 hours. According to this table, ASRs ranged from 82.56% to 95.17%, and the
RMS errors ranged from 0.02 to 0.164. In fact, ASRs would be even higher in practice. Since the skewTV
calculated by node V is affected by fake skews and is closer to the fake skews, the number of fake skews
passing the filters increases. In addition, the Pearson correlation coefficient between these two variables
is only -0.3, which shows a weak inversely proportional relationship. Thus, both ASR and RMS error are
required to observe and to evaluate replication attacks.
To summarize, although both packet loss and calculation error can reduce ASR, most of the time the
attacker node is able to manipulate its skew and makes it indistinguishable to the skew of the target node
from the perspective of the victim node. Hence, the imitation algorithm described in Section 3.2 can seriously
break the clock skew-based node identification.
4.3. Defense Against Replication Attack Experiments
To find a suitable changing period for Algorithm 1, we conducted a series of experiments. The experiment
setup was the same as for the previous experiments. We studied changing periods ranging from 16.67% to
99.99% of the original period, and 10 representative results are depicted in Fig. 8. In the 16.67% case, the
time period is assigned to 16.67% of the original value, or 2, 880, 000 ∗ 16.67% ∼= 480, 000 ticks, for every
seven rounds and then returns to the origin period for another seven rounds. The other nine results are
achieved in the same fashion. Only the point of 100% is an exception. As the changing period is the same
as the original one, the RMS error value of this point is in fact the result of a replication attack without
a defense mechanism. Since the changing periods ranging from 16.67% to 99.95% have fairly similar RMS
errors and ASRs, we suggest a changing period close to 99.9% of the origin period for the burst mode. A
shorter period implies more frequent communication and thus more power consumption. On the other hand,
the periods of 99.95% and 99.99% show much higher ASRs than smaller periods do. It might be surprising
that even a 0.1% modification can lead to a significant RMS error. The underlying reason for this is that,
compared to the 1 tick diff variation in Table 2, the changing periods differ from the origin period for more
than 2000 ticks. This kind of change can seriously affect the back calculation of the attacker nodes.
To prevent the attackers from reverse engineering the burst mode and then developing an adaptive back
calculation, we change the length of the changing period randomly for each round. In Algorithm 1, the
changing periods vary from 99.84% (2,875,450 ticks) to 99.93% (2,878,000 ticks), though any boundary close
to 99.9% is believed to have the same effect. To evaluate the performance of Algorithm 1, we conducted
two experiments with Equations (17) and (15), respectively. The general experiment setup is the same as
for the experiment in Fig. 5 and Algorithm 1 is applied on both node T and node V .
Defense against replication attack with a constant diff : As the replication attack with a constant
diff only calculates the fake diff once, one might argue that the burst mode might not be able to defend
against the attack at the beginning. Therefore, we needed to confirm if this attack could imitate the clock
skew at the beginning of the attack during the burst mode. In this experiment, the attacker sends out
fake packets to launch the replication attack with a constant diff. Node T and V enter the burst mode
15
150 200 250 300 350 400 450 500 550 600
−10
−9
−8
−7
−6
−5
−4
−3
x 10−5
(seqnum)
Cl
oc
k s
ke
w 
(s
/s)
 
 
SkewTV
SkewAV
(a)
0 500 1000 1500 2000 2500 3000
−10
−8
−6
−4
−2
0
2
4
6
8
x 10−6
(seqnum)
Cl
oc
k s
ke
w 
(s
/s)
 
 
SkewTV
SkewAV
140
(b)
Figure 9: (a) Replication attack with a constant diff being revealed during the burst mode. (b) Repli-
cation attack with an accumulated diff being revealed during the burst mode. The malicious node
launches a replication attack at the dash-dotted line and then the burst mode is launched. According
to the experiment results, our algorithm could defend against both replication attacks.
Table 4: Performance evaluation of Algorithm 1 against replication attack from 10 experiments
Maximum Average Minimum Median
ASR 2.34% 0.60% 0% 0%
RMS 96301.0 9977.4 0.27114 2.11
ASR = attack success rate, RMS = RMS error
attack dramatically decreased to 2.34% when our algorithm was used. Since ASR was rather low according
to our experiment results, we recommend dropping those packets both from node T and node A which
cannot be distinguished. As the rate was less than 2.34%, or 0% in most cases, eliminating those packets
would not affect the normal operation of the time synchronization.
5. Conclusions
This paper verified the clock skew to be a practical method for node identification in wireless sensor
networks. The first part of this paper revealed that fake clock skews generated by neighbor attacker nodes
can be very close to the target skew and even fluctuate in the same pattern. Given a real clock skew precisely
measured by FTSP, more than 80% of an attacker’s packets were still able to pass through the current skew
filter. In fact, the high accuracy advantage of FTSP not only leads to the success of node identification,
but also gives attackers the same power to imitate the identity of other nodes. Hence, in the second part of
this paper, we proposed a defense method against the above replication attack. We found that the accuracy
of a fake clock skew could be seriously affected by changing the time sync period. Thus, we developed an
algorithm to defend against the replication attack by changing the time period of the time synchronization.
The experiment results showed that this algorithm filtered out at least 97.6% of the fake packets, or 100%
in many cases.
One future work is to apply this algorithm in a large scale environment with varying environmental
conditions. We conducted the experiments herein under a strictly bounded environment in order to verify
the effectiveness of our theory for the first step. Further studies on the influence of variable environment
parameters on our method should be worthwhile.
17
[26] Ransford, B., Rosensweig, E.. Skewmask: Frustrating clock skew fingerprinting attempts. 2007.
[27] Roosta, T., Liao, W.C., Teng, W.C., Sastry, S.. Testbed implementation of a secure flooding time synchronization
protocol. In: Wireless Communications and Networking Conference. 2008. p. 3157–3162.
[28] Roosta, T., Sastry, S.. Securing flooding time synchronization protocol in sensor networks. 2006.
[29] Sharma, S., Saran, H., Bansal, S.. An empirical study of clock skew behavior in modern mobile and hand-held devices.
In: 2011 Third International Conference on Communication Systems and Networks (COMSNETS). 2011. p. 1–4.
[30] Sheela, D., Priyadarshini, , Mahadevan, G.. Efficient approach to detect clone attacks in wireless sensor etworks. In:
3rd International Conference on Electronics Computer Technology (ICECT). volume 5; 2011. p. 194–198.
[31] Ssu, K.F., Wang, W.T., Chang, W.C.. Detecting sybil attacks in wireless sensor networks using neighboring information.
Computer Networks 2009;53(18):3042–3056.
[32] Tran, T., Agbinya, J.. Early and lightweight distributed detection of node replication attack in sensor networks. In:
IEEE Wireless Communications and Networking Conference (WCNC). 2010. p. 1–6.
[33] Uddin, M., Castelluccia, C.. Toward clock skew based wireless sensor node services. 2010. p. 1–9.
[34] Wang, J., Yang, G., Sun, Y., Chen, S.. Sybil attack detection based on RSSI for wireless sensor network. In: In
International Conference on Wireless Communications, Networking and Mobile Computing. 2007. p. 2684–2687.
[35] Zander, S., Murdoch, S.J.. An improved clock-skew measurement technique for revealing hidden services. In: Proceedings
of the 17th conference on Security symposium. 2008. p. 211–225.
[36] Zeng, Y., Cao, J., Zhang, S., Guo, S., Xie, L.. Random-walk based approach to detect clone attacks in wireless sensor
networks. IEEE Journal on Selected Areas in Communications 2010;28(5):677–691.
[37] Zhu, B., Setia, S., Jajodia, S., Roy, S., Wang, L.. Localized multicast: Efficient and distributed replica detection in
large-scale sensor networks. IEEE Transactions on Mobile Computing 2010;9(7):913–926.
[38] Zhu, W.T.. Node replication attacks in wireless sensor networks: Bypassing the neighbor-based detection scheme. In:
International Conference on Network Computing and Information Security (NCIS). volume 2; 2011. p. 156–160.
[39] Zhu, W.T., Zhou, J., Deng, R.H., Bao, F.. Detecting node replication attacks in wireless sensor networks: A survey.
Journal of Network and Computer Applications 2012;35(3):1022–1034.
19
INTERNATIONAL JOURNAL OF COMMUNICATION SYSTEMS
Int. J. Commun. Syst. 0000; 00:1–20
Published online in Wiley InterScience (www.interscience.wiley.com). DOI: 10.1002/dac
Secured Flooding Time Synchronization Protocol
Ding-Jie Huang, Wei-Chung Teng∗, and Kai-Ting Yang
National Taiwan University of Science and Technology, Taiwan
SUMMARY
This work aims to complement security vulnerability of Flooding Time Synchronization Protocol (FTSP),
which is currently one of the most popular approaches for time synchronization in wireless sensor networks
(WSNs). FTSP has advanced features such as implicitly dynamic topology and high accuracy time, but there
are still some unsolved security issues. In order to defend against attacks from malicious nodes, we propose
several techniques to reinforce the structure of FTSP. First, a new root selection mechanism is proposed
to secure the process of updating root node. Second, a reference node selecting mechanism is proposed to
reduce the effect of multiple reference nodes, and four filters are proposed to defend against seqNum attack,
global time attack, and node replication attack. Experiment results show that proposed sequence number
blacklist filter and global time blacklist filter are effective to defend above mentioned attacks. Furthermore,
data collection time can be reduced from ten sending cycles to five cycles when detecting global time attack
with proposed fluctuation filter.
Copyright c© 0000 John Wiley & Sons, Ltd.
Received . . .
KEY WORDS: FTSP, clock skew, WSN, root selection mechanism
1. INTRODUCTION
In the last decade, WSN based applications mature rapidly due to their usability on sensing
services [1–6]. Some applications in WSNs depend on time-based collaboration to increase
performance. Time synchronization protocols [7–13] play an important role in these cases to ensure
the correctness of collaboration between distributed nodes. Many applications of WSNs have their
nodes distributed in an open space; hence, attackers can physically capture, analyze, or compromise
a victim node and then threaten the entire time system. As a result, it is crucial to design robust
synchronization protocols with security in mind.
The importance of security issues in time synchronization has already been widely discussed
in the literature [14–26]. Some studies [15,18,19,22,23,27] pointed out serious attacks on existing
synchronization protocols and provided common solutions to tackle these attacks. For instance,
Ganeriwal et al. [15] analyzed attacks on existing time synchronization protocols RBS [7], TPSN
[8], and FTSP [10], and provided a secure time synchronization toolbox to defend against these
attacks. Some studies [16,24,25] proposed new secure time synchronization protocol with build-
in security mechanism, such as TinySeRSync [16] and ATSP [24]. Besides, some researches
[26,28–30] propose enhanced mechanism to secure existing protocols.
Among existing time synchronization protocols, FTSP is a practical one with fully functional
implementation written in NesC language and is one of the official components in TinyOS 2.1.1
∗Correspondence to: Wei-Chung Teng, Department of Computer Science and Information Engineering National Taiwan
University of Science and Technology, Taipei, Taiwan
†Email: {D9515002, weichung, D9615007}@mail.ntust.edu.tw
Copyright c© 0000 John Wiley & Sons, Ltd.
Prepared using dacauth.cls [Version: 2010/03/27 v2.00]
3It is worthy to notice that aforementioned secure protocols can defend against different attacks
(e.g. Sybil attack, masquerade attack, replication attack, message manipulation attack, replay attack,
delay attack, wormhole attack, and misleading attack); however, FTSP has inherent security flaw
based on its design, which has not been fully tackled yet.
2.2. Syncing Process of FTSP
Among present studies, flooding time synchronization protocol (FTSP) is considered to be the most
popular time synchronization protocol in WSNs [10], but it lacks of security concerns in its design.
It provides a dynamic hierarchical time synchronization topology and high precision by utilizing
both MAC-layer time-stamping with jitter reducing technique and the linear prediction of global
time technique. Thus, the delay caused by data access, hardware interruption and distance between
each nodes can be compensated to a minimum.
The time synchronization process of FTSP is as follows: the node with the smallest ID is chosen
as the root node in the beginning, and then the root node uses its own timestamp as global time
and broadcasts time synchronization packets. Every synchronization packet consists of three fields:
the ID number of root node rootID, the sequence number seqNum, and the global time from the
sender sendingT ime. When receiving a time synchronization packet, the neighbor node first checks
if the seqNum is greater than the one that has already received. If newly received seqNum is larger,
which means that this is a new synchronization packet, the neighbor node records the timestamp of
receiving time, which is the local time of the neighbor node, and calculates the offset between the
global time and the local time. After gathering eight offsets and local time, the neighbor node starts
to calculate its clock skew relative to the sender node, also called as reference node, by using linear
regression. This clock skew is then used to estimate the global time, and the calculated global time is
then broadcasted to the yet outer neighbor nodes which are not directly connected to the root node.
In this way, every node can synchronize its time following an implicit tree topology.
The main program of FTSP consists of two parts: sender part and receiver part as shown in
Fig. 1. In the sender part, there is a timer used to trigger the function of ”timesSyncMsgSend” in
each node. After ”timesSyncMsgSend” is triggered, a node checks whether it is sending a packet
or not. If there is no process sending packet, this node calls the ”sendMsg” function and sends
out a time synchronization packet. In the receiver part, syncing process can be separated into
four steps: ”receive”, ”processMsg”, ”addNewEntry”, and ”calculateConversion.” The ”receive”
function retrieves all information from received packets and passes them to the next function
”processMsg”. The ”processMsg” function decides if the receiver node needs to change its reference
node according to the rootID and the seqNum fields from the incoming packet. If the node has
to change its reference node or update synchronization message, it triggers the ”addNewEntry”
function; otherwise, it ignores the packet. The function ”addNewEntry” does only one thing: it
replaces the oldest time information with the new time information inside the buffer for time entries.
Finally, after collecting enough data, a receiver node performs linear regression for the collected
time information and computes the evaluated skew between itself and the incoming packet.
receive processMsg addNewEntry calculateConversion
Receiver
Sender
Timer timeSyncMsgSend sendMsg
Figure 1. Program architecture for FTSP.
The only security component is a global time filter in the original design of FTSP. It is used
to filter out abnormal packets by comparing the global time of the incoming packet with the one
computed by applying the existent skew in the buffer. If the difference between these two values
is greater than a threshold three times consecutively, the receiver node would clear the buffer and
Copyright c© 0000 John Wiley & Sons, Ltd. Int. J. Commun. Syst. (0000)
Prepared using dacauth.cls DOI: 10.1002/dac
5nodes. However, since there are multiple reference nodes, their methods may cause unstable skew
estimation with linear regression [30]. Consequently, the root selection problem still remains an
open issue in FTSP.
2.3.2. Attack on ’sendingtime’ field. Once a malicious node wants to disturb the time system of
the network, it needs to fill fake global time into the sendingT ime field of the outgoing packets.
If a node selects this malicious node as its reference node, it uses the wrong global time after
synchronizing with the malicious node. Since any node can alter its sendingT ime, it becomes a
flaw that malicious node can easily utilize to crash the time system. In this paper, we call this
attack a global time attack. Besides, this attack is sometimes combined with other attacks, such as
seqNum attack. Our overall defense approach is provided in next section. Furthermore, most of
attacks mentioned in Section 2.1 may be launched along with the global time attack in FTSP. Thus,
defending this attack is essential for securing FTSP.
2.3.3. Attack on ’seqNum’ field. As stated above, only the root node can increase the value of
seqNum theoretically. However, the seqNum field is not protected either, so an adversary can
change this value and send out fake messages with higher seqNum. When a node receives this fake
message, it would find the seqNum inside this message higher than all current records and thus
selects the malicious node as its reference node. The countermeasure of this seqNum attack is to
use seqNum filter introduced in [30]. This seqNum filter uses extended data structure to collect
data from randomly chosen k nodes out of total n neighbors and then chooses the node with smallest
seqNum as reference node. Hence, the seqNum attack is not working under their modified FTSP.
2.3.4. Attack on Time Synchronization Rate. This attack is launched by sending out packet with
faster period. This attack sometimes accompanies with seqNum attack and global time attack,
because the malicious node should send time synchronization updates more frequently than normal
nodes so as to increase the possibility of affecting the time of its neighbor. Therefore, the attack
itself is not harmful for the time system, but a malicious node can apply this attack to launch other
attacks.
2.3.5. Attack on Node Identity. As stated above, rootID is not covered, so any node can imitate the
identity of another node by sending out a packet with the ID the same with the victim node. In this
manner, a malicious node can easily launch replication attack and pretends to be a reference node
or oven the root node in the network. Huang et al. proposed a clock skew based node identification
method which can be applied to distinguish each different node in a wireless sensor network [34].
Uddin and Castelluccia also used clock skew as identifications of sensor motes [35]. However, this
node identification technique can not be directly applied to FTSP yet needs some modifications.
Even if there are several countermeasures against the attacks on FTSP [29,30], there is no overall
practical solution available that could defend against all the attacks stated above. Moreover, attacks
on node identity of FTSP is a severe problem and is still left unsolved. This paper proposes a more
complete approach to reinforce the structure of FTSP and is able to help defend the known attacks.
3. SECURITY ENHANCEMENT FOR FTSP
This section present our proposed mechanisms to support security among WSNs when performing
time synchronization. Our solutions includes a new root selecting mechanism, single reference node
selection mechanism, and four message filters. All these approaches are integrated into original
FTSP for better security concerns without effecting it.
3.1. Root Selection Mechanism
After analyzing the structure of FTSP, it is evident that the root selection mechanism should
be protected. The simplest solution is applying cryptographic methods. However, involving
Copyright c© 0000 John Wiley & Sons, Ltd. Int. J. Commun. Syst. (0000)
Prepared using dacauth.cls DOI: 10.1002/dac
7The root selection mechanism is separated into four steps: start of root selection, selection of new
root, synchronization of new root, and end of selection. The detailed steps of new root selection
mechanism is as follows:
1. Start of root selection
(a) Base station first signs messages with its private key including: its node number (BS ID),
selection counts (Vote Cnt), and election start flag (Sync State = 0). It will then send out
the selection start packet, shown in Fig. 3a, with these information and the signature.
The signature is denoted as SBS Pri(D), where S is the signature scheme, BS Pri
represents the private key of base station, and D is the input data.
(b) When adjacent nodes receive the selection start packet, those receiving nodes will verify
the packet with the public key of base station and record the ID of base station. At this
moment, receiving nodes will freeze the ID of base station in the CTP routing table
in order to prevent the malicious node from participating in the routing process. Later,
nodes will forward the received selection start packet to other nodes via broadcasting.
In this way, each node can receive the selection start packet and has a fixed path to the
base station.
2. Selection of new root
(a) After freezing the CTP routing table, each node, who wants to be the new root, will
return back the campaign packet, where Camp Flag is set to 1, to the base station. The
packet format of campaign packet is shown in Fig. 3b. To ensure that the message is not
altered by any malicious node, each node will sign the Camp Flag with its own private
key.
(b) When the base station receives the campaign packet from different nodes, it will verify
the packets with the corresponding public key and record all messages. After waiting for
a period of time, it will select an ID, which has not been chosen as root last time and is
an unique ID in this round, as root node. The waiting period is based on the scale of the
wireless sensor network.
(c) Base station signs the ID and the public key of new root with its private key, and then
writes these information and the signature into the selected packet, shown in Fig. 3c.
After broadcasting the selected packet, base station will record the root ID in this round
to prevent duplicated selection in the next round.
(d) When a node receives the selected packet, it will verify the message with the public key
of base station and use Root ID as its root. In the meanwhile, it will also forward the
selected packet to other nodes. Furthermore, the node will store the public key of the
new root, and uses this public key to verify the identity of new root, thereby defending
against the replication attack on root.
3. Synchronization of new root
(a) When the new root receives the selected packet, it will record its local time, denoted
as LTrs. Later, the new root sends out the time synchronization packet to the base
station via CTP for requesting time synchronization information. The format of time
synchronization packet is shown in Fig. 3d. This packet contains Sync Finish, which is
set to 0, and Timestamp, which are encrypted by the public key of the base station.
(b) While sending messages to the base station, the corresponding relay node must store the
Src ID, the ID of source node, and the Dst ID, the ID of destination node.
(c) When base station receives the time synchronization packet from the new root node, it
then records the timestamp, denoted as GTbsr. While the base station starts to send back
the time synchronization packet, it records the timestamp as GTbss and encrypts both
GTbsr and GTbss with root’s public key. Later, these encrypted time information will be
added into time information packet, shown in Fig. 3e, and sent out along the path to the
new root node reversely.
(d) While new root node receives the time information packet from base station, it will
record the LTrr and decrypt the time synchronization packet with its private key. By
Copyright c© 0000 John Wiley & Sons, Ltd. Int. J. Commun. Syst. (0000)
Prepared using dacauth.cls DOI: 10.1002/dac
9(a)
Node 1
Node 2
Node 3
Node 4
109
109
109
109108
110
110
110
110
111
111
111
111
112
112
112
(b)
Figure 4. The influence of packet loss on FTSP.
!"#$%
!"&%%
!"&'%
!"&(%
!"&!%
!"&#%
!"&&%
!"&)%
!"&"%
!"&*%
'%) '%" '%* '%$ ''% ''' ''( ''! ''# ''&
!
""
#$
%
!
""
#$
%
!
""
#$
%
!
""
#$
%
!"#$!%&'(
(a)
!"#$%
!"&%%
!"&'%
!"&(%
!"&!%
!"&#%
!"&&%
!"&)%
!"&"%
!"&*%
'%) '%" '%* '%$ ''% ''' ''( ''! ''# ''&
!"#$!%&'(
!
""
#
$
%
!
""
#
$
%
!
""
#
$
%
!
""
#
$
%
(b)
Figure 5. Timeline example showing how clock skew may be affected by multiple reference nodes.
The reference node selection mechanism in original FTSP is achieved by comparing the value
of seqNum. If the value of seqNum from the incoming packet is larger than the current buffered
value of seqNum, then one node will change its reference node ID to the ID of the incoming packet.
However, a node may change its reference node several times in a short period of time due to the
packet loss, and this may cause the time evaluation inaccurate because of unstable clock skew.
For example, the reference node of Node 4 is Node 1 when its buffered seqNum is 109 in Fig. 4b,
but the packets with seqNum 110 and 111 from Node 1 are lost. In this case, Node 4 changes its
reference node in these two rounds and uses the synchronization information from Node 2 as shown
in Fig. 4b. This behavior affects the calculation of the clock skew and makes the evaluation unstable.
The clock skew evaluation with single reference node is shown in Fig. 5a. On the contrary, Fig. 5b
shows the linear regression drift caused by multiple reference nodes. Sometimes the offset bias is
tiny; however, our experiments show that even a skew bias of 1 ppm affects the evaluation of the
clock skew enormously.
Hence, in order to reduce the effect of multiple reference node, unique reference node is applied
to our reference node selection mechanism. If a node does not receive any synchronization packet
from its reference node for N periods, it selects a new reference node from another neighbor node.
A suitable value of N may depends upon the environment of the sensor node. If the packet loss rate
is high, N needs to be set to a larger value. In our study, N is set to 3 in the following experiments.
3.3. Synchronization Message Filters
In order to enhance the security, four filters are added into the architecture of FTSP: Global Time
Blacklist Filter, Sequence Number Blacklist Filter, Clock Skew Filter, and Fluctuation Filter. The
two former filters are applied to filter suspicious neighbor nodes, whereas the later two are aimed
to tackle the issues arose by reference nodes. When processing synchronization message, during
the state of proccessMsg, nodes adopt Global Time Blacklist Filter to filter out abnormal global
time, and Sequence Number Blacklist Filter to filter out unusual value of seqNum from incoming
packets. If there exists any suspicious malicious node, it would be added into blacklist. Furthermore,
two states are included in system architecture: addNewEntryP and calculateConversionP in order
Copyright c© 0000 John Wiley & Sons, Ltd. Int. J. Commun. Syst. (0000)
Prepared using dacauth.cls DOI: 10.1002/dac
11
0
2
6
5
4
3
10
7
13
8 9
12
11
14
(a)
0
2
6
5
4
3
10
7
13
8 9
12
11
14
(b)
Figure 7. Different subjects for global time filter and global time blacklist filter in FTSP.
(a)
Node 1
Node 2
Node 3
Node 4
126
126
126
126125
127
127
127
127
128
128
128
128
129
129
129
(b)
Figure 8. Timeline example for global time blacklist filter.
bool globalTimeBlackListFilter(){
int32_t timeError;
eTimeSyncMsg* msg = (eTimeSyncMsg*)
(call  Send.getPayload(processedMsg, sizeof(eTimeSyncMsg)));
timeError = msg->localTime;
call GlobalTime.local2Global((uint32_t*)(&timeError));
timeError -= msg->globalTime;
if( (is_synced() == SUCCESS) &&
(timeError > (3*ENTRY_THROWOUT_LIMIT) ||
timeError < (3*-ENTRY_THROWOUT_LIMIT)) )
{
if(!inBlackTable(msg->nodeID))
addCriticalTable(msg->nodeID);
overGFLimit = TRUE;
return FALSE;
}
return TRUE;
}
Figure 9. Code fragment of global time blacklist filter.
time blacklist. Here, the values of N and L are depending on the synchronization message sending
period. If the sending period is longer, it needs more time to synchronize with each other so the
time would be much less accurate. Thus, the threshold L should be set to a larger number. On the
contrary, if the sending period is shorter, the threshold L should be set to a smaller number. In our
experiment, N is 3 and L is 1500 ticks and the code fragment is shown in Fig. 9. Here L is equal
to 3 ∗ ENTRY THROWOUT LIMIT , and ENTRY THROWOUT LIMIT , which is 500
ticks, is the threshold of the original global time filter.
3.3.2. Sequence Number Blacklist Filter The purpose of Sequence Number (seqNum) Blacklist
Filter is to filter out the packets from neighbor nodes whose seqNums are significantly larger than
that of the reference node. Sequence Number Blacklist Filter aims to prevent suspicious neighboring
node, who fakes its sequence number, from being the reference node. The sender ID of the abnormal
packet is then added into the blacklist and will not be chosen as reference node in the following
Copyright c© 0000 John Wiley & Sons, Ltd. Int. J. Commun. Syst. (0000)
Prepared using dacauth.cls DOI: 10.1002/dac
13
bool seqNumBlackListFilter(){
int8_t diff;
eTimeSyncMsg* msg = (eTimeSyncMsg*)
(call Send.getPayload(processedMsg, sizeof(eTimeSyncMsg)));
diff = (int8_t)(seqBase - msg->seqNum);
if(diff > (SEQNUM_THROWOUT_LIMIT) || 
diff < -(SEQNUM_THROWOUT_LIMIT))
{
if(!inBlackTable(msg->nodeID)){
addCriticalTable(msg->nodeID);
atomic test =  msg->nodeID;
}
overSFLimit = TRUE;
return FALSE;
}
return TRUE;
}
Figure 12. Code fragment of sequence number blacklist filter.
3.3.3. Clock Skew Filter The Clock Skew Filter is used to detect the identity of the malicious node
by applying the technique of clock skew based node identification. The basic concept is that physical
devices generally has characteristics of distinguishable and unique clock skew [35]. If a node intends
to pretend as another one, the clock skew can reveal the identity of it. Thus, if an adversary wants
to pretend to be the reference node or the root node, clock skew can be used to reveal the identity of
the malicious nodes.
In order to present the effectiveness of clock skew’s characteristics, 18 motes are used to
experiment the variation of devices’ clock skew. Since the amount of clock skew fluctuation
increases with the hop numbers grow, we only apply the single-hop skew estimation for the reference
node in the following experiment. Furthermore, we assume that the temperature is stable in a short
period of time, so the clock skew of each node still remains the characteristic of continuity, which
keeps the node identifiable [34]. The experiment result is shown in Table II.
The result records the clock skew between Node 0 and every other nodes in the network. It
shows the maximum skew, the minimum skew, and the skew range, which is the difference between
maximum skew and minimum skew, of Node 0 and other nodes. The result shows that all skew
values range less than 1 ppm, and even the largest variation is only 0.831 ppm. Based on this
experiment, 1 ppm is applied as the threshold of the skew filter to detect the packet from the
malicious node. Clock skew filter collects at least four packets from the reference node so as to
calculate the relative skew between itself and the reference node. Although it remains vulnerable in
its initialization time, we believe this period is short enough such that it is practical to assume that
there is no attack launched in the beginning. Later, if the computed skew difference between the
incoming packet and the original skew is greater than 1 ppm threshold, this message will be filtered
out.
3.3.4. Fluctuation Filter The Fluctuation Filter is used to reduce the effect caused by adjustment
error or imitation attack launched by malicious node. In FTSP, four continuous data is needed
to calculate the skew between itself and global time. After that, if there exists three consecutive
errors, the buffer, which is used to calculate the clock skew, will be cleared. Here, a error means
the difference between the global time, from the incoming packet, and the evaluated global time is
greater than the threshold. After clearing the buffer, the node will recollect time information and
calculate a new clock skew. Hence, if communication noise only appears instantaneously, i.e. less
than three times, the evaluated value will be affected significantly, thereby inducing the adjustment
error.
Since the original global time filter can filter out the error greater than 500 ticks, it sometimes can
not filter out the value within 500 ticks and the adjustment error may occur in this period. Therefore,
the fluctuation filter is needed to detect the abnormal time information from the reference node.
Copyright c© 0000 John Wiley & Sons, Ltd. Int. J. Commun. Syst. (0000)
Prepared using dacauth.cls DOI: 10.1002/dac
15
base station is compromised or being physically attacked, the corresponding sensor network will no
longer survive.
As stated above, since any packet with the difference of the seqNum greater than one will be
added into the blacklist, a malicious node can still send out packet with the difference equals to one
to bypass the defense. In this case, the sequence number blacklist filter cannot detect this malicious
packet. However, the global time blacklist filter can further detect the malicious packet and reduce
the effect of this attack. In addition, combining global time blacklist filter with clock skew filter,
if the skew of the global time, sent from the malicious node, is significantly different from the
evaluated skew, the packet will be filtered. Thus, by utilizing proposed filters simultaneously, it can
reduce the effect of the attack. Even if the packet can pass the filters, the fake global time would be
similar to the evaluated global time, so this attack cannot affect the time system within our secured
FTSP.
Furthermore, consider a wireless sensor network running our secured FTSP. Suppose that there
are n legitimate nodes and (mr +mh) malicious nodes in the WSNs. Here, mr denotes the number
of revealed malicious nodes who do bad things during the root selection, so these malicious nodes
will be detected during the procedure; mh denotes the number of hidden malicious nodes who join
the root selection with regular procedure but launch attacks after the root selection. Besides, let the
root selection procedure be performed for t rounds and every malicious node launched Sybil attacks
by creating s fake nodes. Therefore, the probability of malicious nodes being selected as root node
at round t is:
P (t) = 1− ( n
n+s∗(mh)
) ∗ ( n−1
n+mh−1
)t−1, ∀t ≥ 2 (2)
n Number of legitimate nodes
mr Number of revealed malicious nodes
mh Number of hidden malicious nodes
t Round of root selection procedure
s Number of fake nodes that a malicious creates
l Round of root selection procedure for a continuing
period
In (2), the probability that legitimate nodes are selected as root node in first selection is n
n+s∗(mh)
,
but the probability of that after first selection becomes n−1
n+mh−1
because the Sybil attack can be
detected after first synchronization. Therefore, our enhanced FTSP can reduce the effect caused
by revealed malicious nodes, and if there are only a few of hidden malicious nodes, P (t) will be
relatively low.
On the other hand, since the root selection is regularly performed during the synchronization, a
malicious node may have chance to compromise the time system during some period, but it cannot
be the root all the time. Thus, our enhanced FTSP can recover its time system, even if the malicious
node is selected as the root node during a certain period. According to the previous scenario, the
probability of malicious nodes being selected as the root node for continuing l rounds is:
P (l) = ( mh−1
n+mh−1
)l, ∀l ≥ 1 (3)
P (l) is relatively low when the synchronization is executed for a long period. According to (2)
and (3), we can conclude that our proposed mechanism can reduce the effect of malicious nodes and
is resilient to the root selection attack.
4. EXPERIMENTS
We have implemented the proposed secured FTSP and have run several experiments to evaluate the
performance. Crossbow TelosB motes are used as experimental platform and TinyOS 2.1.1 [31],
Copyright c© 0000 John Wiley & Sons, Ltd. Int. J. Commun. Syst. (0000)
Prepared using dacauth.cls DOI: 10.1002/dac
17
0 50 100 150 200 250 300
−50
−45
−40
−35
−30
−25
−20
−15
seqNum
Sk
ew
 (p
pm
)
 
 
1+2
1
Figure 16. Experimental result for the effect of multiple reference nodes.
4.3. Exp2: Wrong global time sent from a malicious node
The effect of wrong global time sent from a malicious node is analyzed in the Exp2. Node A is the
malicious node, who alters global time by dividing the value of original global time by two, and
sends out this fake message to its adjacent nodes. The experiment setup is the same with Fig. 14 and
the attacker node is denoted as Node 3.
Since the reference selection mechanism and global time filter are not considered in the original
FTSP, it is easy to launch attacks to affect time system. In order to provide a better representation
on time distribution, only one-third of data is drawn in Fig. 17a and Fig. 17b. The result running on
original FTSP is indicated in Fig. 17a. Node 1 is the reference node of Node 6 before the seqNum
50, so the global time in Node 6 is growing steadily. However, the malicious node appears and
launches the global time attack from seqNum 50 to 100, and it causes the global time to vary
between the original one and the fake one in Node 6. Node 1 disappears from seqNum 100 to 150,
so Node 6 considers the malicious node as its reference node in this period. Thus, the malicious
node successfully compromises the time system of Node 6 in this experiment.
On the other hand, the result of modified FTSP is illustrated in Fig. 17b. Because reference node
sticks to only one node with new reference node selection mechanism, the global time of Node 6
is not affected from seqNum 50 to 100. Furthermore, the global time from the malicious node is
much greater than the original global time, so the malicious node is added into the blacklist of Node
6. Finally, even when Node 1 disappears from seqNum 100 to 150, Node 6 first checks the blacklist
and does not use the malicious node as its reference node. Instead, Node 6 uses the previous skew to
evaluate the global time during this period. Therefore, our global time blacklist filter and reference
node selection successfully defend the global time attack in this experiment.
4.4. Exp3: Fake seqNum sent from a malicious node
The effect of the fake seqNum attack launched by a malicious node is analyzed in Exp3. Here,
Node A is the malicious node and it sends out fake packets with the seqNum equal to the original
seqNum plus 5 in every sending period, after the time is synchronized in this network. The node
distribution is the same as Fig. 14.
There is no defense technique in the original FTSP, so all nodes in this network are affected by
the fake seqNum sent from the malicious Node 3 after the seqNum is 50, as shown in Fig. 17c.
The seqNum attack makes all node to synchronize their time with the malicious node. On the
other hand, after Node 3 joins this network, the adjacent nodes of Node 3 detect the malicious
packets by applying the seqNum blacklist filter and add Node 3 into the blacklist in the enhanced
FTSP. Therefore, the adjacent nodes around Node 3 are not affected and do not send out the wrong
messages to other nodes in Fig. 17d. Besides, the seqNum of the malicious node falls down to 90
after the seqNum 210. It is caused by the data overflow of the seqNum, which is a signed 8 bits
Copyright c© 0000 John Wiley & Sons, Ltd. Int. J. Commun. Syst. (0000)
Prepared using dacauth.cls DOI: 10.1002/dac
19
node is Node 1, is affected by the malicious node after seqNum is 50 in Fig. 17e. There are skew
variations over 1 ppm during seqNum 55 ∼ 65, 80 ∼ 85, and 95 ∼ 100, caused by the imitating
attack from the malicious node. However, while applying the clock skew filter, Node 6 can detect
that the skew varies over 1 ppm and filter out the incoming packet. As shown in Fig. 17f, after the
malicious node, represented by Node 3, joins to the network, Node 6 can filter out the fake packets
coming from the malicious node.
5. CONCLUSIONS
In this paper, we propose several techniques to complement the security vulnerability of FTSP. FTSP
has advanced features like implicitly dynamic topology and high accuracy time, but security issues
are not taken into consideration in its original design. Thus, a malicious node can easily break the
time synchronization protocol and change the time of synchronization messages. Assaults on FTSP
are divided into two categories: the attacks on the root node and the attacks on normal nodes. The
later type can be further subdivided into three different cases: (1) modifying the globalTime field;
(2) modifying the seqNum field; (3) reducing the frequency of sending packets. After analyzing the
structure of FTSP, we propose a root node selection mechanism which benefits from base station to
defend the first type attacks. With the new mechanism, the base station is the only judge who can
assign root status in the network. By utilizing asymmetric encryption, the connections between each
node can be secured during the root selection.
In order to defend against attacks from malicious nodes, a reference node selecting mechanism
and several data filters are proposed. The proposed filters include global time blacklist filter,
seqNum blacklist filter, clock skew filter and time fluctuation filter. By applying these enhanced
components, the security of FTSP can be ensured. The results of experiments show that we have
successfully defended against the seqNum attack and the global time attack by utilizing seqNum
blacklist filter and global time blacklist filter. By applying the characteristics of fixed clock skew
fluctuation, around 1 ppm, reference node can be successfully identified. Furthermore, the data
collection time for detecting global time attack drops from ten sending cycles to five sending cycles
by applying the fluctuation filter. From our experimental results, the proposed filters can improve
the security of FTSP and fix the vulnerabilities caused by original design.
ACKNOWLEDGMENT
This work was supported under the National Science Council Grants 98-2221-E-011-066-MY3.
REFERENCES
1. Hamdi M, Boudriga N, Obaidat MS. Whomoves: An optimized broadband sensor network for military vehicle
tracking. International Journal of Communication Systems 2008; 21(3):277–300.
2. Xiong N, Cao M, Vasilakos AV, Yang LT, Yang F. An energy-efficient scheme in next-generation sensor networks.
International Journal of Communication Systems 2010; 23(9-10):1189–1200.
3. Pham ND, Le TD, Park K, Choo H. Sccs: Spatiotemporal clustering and compressing schemes for efficient data
collection applications in wsns. International Journal of Communication Systems 2010; 23(11):1311–1333.
4. Xu X, Wan J, Zhang W, Tong C, Wu C. Pmsw: a passive monitoring system in wireless sensor networks.
International Journal of Network Management 2011; 21(4):300–325.
5. Jurdak R, Ruzzelli AG, Barbirato A, Boivineau S. Octopus: monitoring, visualization, and control of sensor
networks. Wireless Communications and Mobile Computing 2011; 11(8):1073–1091.
6. Xue L, Guan X, Liu Z, Yang B. Tree: Routing strategy with guarantee of qos for industrial wireless sensor networks.
International Journal of Communication Systems 2012; .
7. Elson J, Girod L, Estrin D. Fine-grained network time synchronization using reference broadcasts. OSDI ’02:
Proceedings of the Fifth Symposium on Operating Systems Design and Implementation, vol. 36, 2002; 147–163.
8. Ganeriwal S, Kumar R, Srivastava MB. Timing-sync protocol for sensor networks. SenSys ’03: Proceedings of the
First International Conference on Embedded Networked Sensor Systems, Los Angeles, CA, USA, 2003; 138–149.
9. van Greunen J, Rabaey J. Lightweight time synchronization for sensor networks. Proceedings of the 2nd ACM
international conference on Wireless sensor networks and applications, 2003; 11–19.
Copyright c© 0000 John Wiley & Sons, Ltd. Int. J. Commun. Syst. (0000)
Prepared using dacauth.cls DOI: 10.1002/dac
!"#$%&'()*+,-./!012#345678
!"#$%&'()
!!!!" #$ % &''' ()*+,-./01234#$56!&'''!&75897:5;<7:=!><7?8987@8!<7!ABC:7@8B!
&7?<9D:5;<7!E85F<9G;7H!:7B!AII=;@:5;<7JK!&'''!A&EA!#LM#NOPQRST"UVWXYZ[\
]^_`abcd.Y3efgchij\klmnopq123rs1tbuvpwOxyz
"{V|}pq123v~S A&EA!#LM# YTWZ\Ok\
. #LL S{\WZ\ \eh4D:;7!59:@GN
 ¡Z #L q F<9GJ6<Iv123¢£¤3e_`¥ #¦ q§\¨©^ #¦ q J8JJ;<7 ªv3e
(«¬ ­ q J8JJ;<7 ®c(\¯ª ° qOeh\± ² q³¥´µ¶ ·<9GJ6<Ivxy
z¸¹ª_`W A&EAº»¦A¼!>=<½B!><DI½5;7H!:7B!»¾J58DJ\O" °" Mq J8JJ;<7v!
YV3efg_`¿À ² Á\¯ª M#$ ÁÂÃÄ3e_`\iÅÆÇ #­È°ÉvÊÁ_`Ë]
3ÌÍÎ(®ÏÐÑ\ÒPÓÔÑÕPhÖ×ØÊÁ_`ÙÚÛÜÝÞß\kl£rs_
`ËÙ¤ÛÜà1táâ.ãäåv!
xyzWYV3eæçèÌéêë\ìíîï*ðñòóôõö÷øùôõ\é
úûüýôõþvÿOûôõOxyz®!!v±\"#k$%&'\w(
çXY)*+,-{ôõ4.9<?È!»:G½9:;!/<½;@6;K!XY*¨01N¤2Á_`rs\"
3ôõ4¤|}\5(ç6v!
xyz£rs_`”!>=<@G!»G8F!7:J8B!>=;875!88C;@8!&B875;?;@:5;<7!;7!>=<½B!'7C;9<7D875J”
9:;^<=>?/0!"\Oà#$W%=&\woO'0ë(Ú)*+v,-ÿO®{
q J8JJ;<7 ¯._`/O%<&1t\kl01Wrsc.¯..3ë¤23î4v-P5
6789ôõ4.9<?È!>6<º:;!·:7HN/ç; <:C:=>W<??@+\"Öùç¢h¬ABCD
E4J8:D=8JJ=¾NFGç-®ýéHIJK\³OL J8JJ;<7 2_MNO1tv!
*"+%,-)
./01) 234) ) 56788897:7;997;<<7=>?)
./@A) BCDEFGHIJKLMNOPQRST)
UVWX
Y@)
Z[\)
]^_`
abA)
cdefghijklmnop
q)
%&Dr)
9;9s ?t 8<uv)
9;9 s ? t 85 u)
%&wN)
!"#$%#$&#$'()
*)
%&@A)
x\yz{|}~ ::: ij+CS%)
xyz)8<):::))4)))
)2))):::)2)8;98)
y
 )
Clock Skew Based Client Device Identification in Cloud Environments)
!"#$%
! "#$%&'()*+,-!
!
!
PSPB Operations Manual, including provisions covering originality, authorship, author responsibilities and author misconduct. More information on
IEEEs publishing policies may be found at http://www.ieee.org/publications_standards/publications/rights/pub_tools_policies.html. Authors are
advised especially of IEEE PSPB Operations Manual section 8.2.1.B12: "It is the responsibility of the authors, not the IEEE, to determine whether
disclosure of their material requires the prior consent of other parties and, if so, to obtain it." Authors are also advised of IEEE PSPB Operations
Manual section 8.1.1B: "Statements and opinions given in work published by the IEEE are the expression of the authors."
 
 
RETAINED RIGHTS/TERMS AND CONDITIONS
 
General
 
1. Authors/employers retain all proprietary rights in any process, procedure, or article of manufacture described in the Work.
 
2. Authors/employers may reproduce or authorize others to reproduce the Work, material extracted verbatim from the Work, or derivative works for
the author's personal use or for company use, provided that the source and the IEEE copyright notice are indicated, the copies are not used in any way
that implies IEEE endorsement of a product or service of any employer, and the copies themselves are not offered for sale.
 
3. In the case of a Work performed under a U.S. Government contract or grant, the IEEE recognizes that the U.S. Government has royalty-free
permission to reproduce all or portions of the Work, and to authorize others to do so, for official U.S. Government purposes only, if the contract/grant
so requires.
 
4. Although authors are permitted to re-use all or portions of the Work in other works, this does not include granting third-party requests for
reprinting, republishing, or other types of re-use.The IEEE Intellectual Property Rights office must handle all such third-party requests.
 
5. Authors whose work was performed under a grant from a government funding agency are free to fulfill any deposit mandates from that funding
agency.
 
Author Online Use
 
6. Personal Servers. Authors and/or their employers shall have the right to post the accepted version of IEEE-copyrighted articles on their own
personal servers or the servers of their institutions or employers without permission from IEEE, provided that the posted version includes a
prominently displayed IEEE copyright notice and, when published, a full citation to the original IEEE publication, including a link to the article
abstract in IEEE Xplore.Authors shall not post the final, published versions of their papers.
 
7. Classroom or Internal Training Use. An author is expressly permitted to post any portion of the accepted version of his/her own IEEE-copyrighted
articles on the authors personal web site or the servers of the authors institution or company in connection with the authors teaching, training, or work
responsibilities, provided that the appropriate copyright, credit, and reuse notices appear prominently with the posted material. Examples of permitted
uses are lecture materials, course packs, e-reserves, conference presentations, or in-house training courses.
 
8. Electronic Preprints. Before submitting an article to an IEEE publication, authors frequently post their manuscripts to their own web site, their
employers site, or to another server that invites constructive comment from colleagues.Upon submission of an article to IEEE, an author is required to
transfer copyright in the article to IEEE, and the author must update any previously posted version of the article with a prominently displayed IEEE
copyright notice. Upon publication of an article by the IEEE, the author must replace any previously posted electronic versions of the article with
either (1) the full citation to the IEEE work with a Digital Object Identifier (DOI) or link to the article abstract in IEEE Xplore, or (2) the accepted
version only (not the IEEE-published version), including the IEEE copyright notice and full citation, with a link to the final, published article in IEEE
Xplore.
 
 
INFORMATION FOR AUTHORS
IEEE Copyright Ownership
 
Clock Skew Based Client Device Identification
in Cloud Environments
Ding-Jie Huang ∗, Kai-Ting Yang ∗, Chien-Chun Ni †, Wei-Chung Teng ∗, Tien-Ruey Hsiang ∗, and Yuh-Jye Lee ∗
∗ Department of Computer Science and Information Engineering
National Taiwan University of Science and Technology, Taipei City, Taiwan 106
Email: {D9515002, D9615007, weichung, trhsiang, yuh-jye}@mail.ntust.edu.tw
† Department of Computer Science
Stony Brook University, Stony Brook, NY 11794, USA
Email: chni@cs.stonybrook.edu
Abstract—Along with the growth of various online devices,
the importance of host identity concern over cloud computing is
emerging. To provide a lightweight yet reliable method for device
identification, an application layer approach based on clock skew
is proposed. By utilizing AJAX technology, the timestamps of
devices are recorded in the cloud server during connection time
to analyze the clock skews of client devices. Few methods based
on linear regression and piecewise minimum algorithm are also
developed to optimize the accuracy and to shorten time collection
process. The proposed approach also includes a jump point
detection scheme to resolve the offset drifting problem so as to
accelerate and rectify the skew estimation process. Finally, two
experiments are performed and the results illustrate that the
proposed approach may give an estimated skew close enough to
the long-run measured skew in a short period of time like 1,000
seconds. The estimated skews are thus suitable to serve as the
fingerprints of physical devices and are helpful to the security of
cloud environments.
Index Terms—clock skew, device identity, cloud service, jump
point detection
I. INTRODUCTION
The growth of cloud-based services in recent years has
changed the way how people use computers and smart devices,
and also the way security attacks may be launched. The
architecture of cloud differs from classic computer in many
ways. Network connections become part of infrastructure on
basic operations like data accessing, and the server threats are
further isolated under virtualization technologies. Therefore,
classic security issues such as user privacy, data confidentiality
and regulation concerns should be reconsidered under the
cloud computing environments.
This paper studies the client device identification problem
of cloud security. Nowadays, people often subscribe cloud
services through personal devices such as mobile phones,
tablets, and laptop computers. Therefore, user identity can be
associated to dedicated hardware. Device identification in the
cloud is useful in detecting unauthorized account access and
locating stolen devices.
Device identification is realized by maintaining a registered
list of physical devices which are associated with valid users.
Once a user logs into the service via an unregistered de-
vice, service provider may ask the user to pass additional
verification, or raise an alarm to the system supervisor for
possible invalid user login. Many candidates can be used as
the fingerprint of physical devices, such as IP address, MAC
address, cookie, or web browser’s configurations [1]. However,
these attributes suffer the weaknesses of easy to forge, lack of
uniqueness, and varying with environments, which make them
insufficient to serve as device fingerprinting. In this paper,
we propose clock skew, a distinctive fingerprint, to identify
different devices.
Clock skew is the difference of clocking speed between
two clocks. Generally, modern processor’s clocks present two
properties [2]–[4]: first, the clock skew between two devices
is relatively stable over time; second, there is distinguishable
clock skew between any two physical devices. According
to these two properties, clock skew can be regarded as a
fingerprint of any device with digital clock. Clock skew has
been widely used as an attack method to reveal a web host
behind HoneyPot or Tor networks [4]–[6]. Later, it is also
used to verify the identity of sensor motes [7,8]. This work
applies clock skew to identify client devices for server security
in cloud environments, or even in classic web systems.
In this paper, we treat clock skew from a novel aspect
and regard it as a detection mechanism of adversary. Also,
to display the usability of clock skew, a web page based
skew detection system is constructed to collect the timestamps,
and five different methods are implemented on it to calculate
the clock skews of client devices. We provide an AJAX-
based technique to periodically collect time information from
cloud service subscribers to the server. Device fingerprinting
is then performed by estimating the clock skew via this
time information. Through experiments performed on a testing
platform containing over 100 hosts, the clock skew effectively
identifies client hosts regardless of underlying networking
channels such as 3G, Wi-Fi, or ADSL, etc.
Furthermore, during our experiments, we observed that
sometimes packet offsets drift dramatically and thus cause a
jump point. This problem is mainly caused by global time
synchronization or network connection hand-off. In previous
work, since the packet collection period is long, this phe-
nomenon is ignored and have not been solved. To minimized
the packet collection period and speed up the clock skew
computation, a jump point detection scheme is provided.
Calculate the 
clock skew of 
the device, then 
add it to 
registered list 
DB
Clients key in 
username & password
Check if the client has a 
registered device
Yes No
Check if the client can 
pass other veriﬁcation
Collecting time information and
estimating  clock skew 
| skew difference | 
< threshold 
NoYes
Reject to loginRegister the client 
device or not NoYes
Login
Yes No
Pass 
veriﬁcation and 
login
Login
Fig. 1. Flowchart of clock skew based host identification system.
2) Time information collecting system of a cloud service:
From previous scenario, with the aid of physical clock skew
fingerprinting technique, a could service can provide additional
protection against malicious attacker. Practically, device finger-
printing should be considered over several networking param-
eters, such as IP, MAC address, and cookies, to strengthen the
reliability. Hence, clock skew’s two major properties, uneasy
to forge and device distinctness, make our method a prospect
candidate that can be implemented in cloud-based applications.
In [6], a clock skew estimating method based on HTTP is
provided. However, their method cannot be directly applied
at the server side in above scenario. Since their approach
frequently asks for the time information of server through
HTTP request periodically, it is infeasible for a cloud server
to perform similarly. Therefore, for a cloud server, a different
technique is required to obtain time information from a client.
To force the client to return its own time informations
back to server, AJAX technique is applied in our system.
With AJAX, every packet generated by AJAX contains the
corresponding timestamp. Since AJAX is implemented by
javascript, which is generously applied in almost every web
applications, we assume that the execution of javascript is
allowed.
The architecture of the time information collecting system
is shown in Fig. 2. On the client side, to protect its link, a
client connects to web server through Secure Sockets Layer
(SSL). On the server side, the main web server provides
general services and application for clients. Meanwhile, a data
collection server is used to gather the time information sent
from clients, and the corresponding timestamp records are
stored in the database server for further analysis. Once a client
tries to request the index page (index.php) from main web
Firewall
Main Web 
Server 
Laptop
Database 
Data Collection 
Server 
Request 
index.php
Return 
sync.js
o
o
o
Ajax request
ClientServer
Fig. 2. Scenario of time information collection.
server, the main web server returns the page and an additional
script (sync.js). This script stimulates each client device to
send back its time information to the data collection server.
B. Terminology of Clock Behavior
Before discussing the method to estimate clock skew be-
tween client and server, the terminology used to represent
the clock characteristics is introduced. The nomenclature from
[3,8,12] is adapted to our algorithm in the following section.
Consider Cx(t) is the time reported by the clock of device x
at real time t, C ′x(t) ≡ dCx(t)/dt and C ′′x (t) ≡ d2Cx(t)/dt2,
∀t ≥ 0. Let Cc and Cs be the clocks of client and server
respectively:
1) Offset: The difference between the time reported by Cc
and Cs, e.g., the offset of the client clock Cc relative to
server clock Cs is Cc(t)− Cs(t), ∀t ≥ 0.
2) Frequency: The rate at which the clock progresses, e.g.,
the frequency at time t of Cc is C ′c(t).
3) Skew (δ): The difference in the frequencies of two
clocks, e.g., the skew of Cc relative to Cs at time t
is δ(t) = C ′c(t)− C ′s(t).
4) Drift: The drift of Cc relative to Cs at time t is C ′′c (t)−
C ′′s (t).
According to above definition, if the server accumulates
sufficient client time information Cc(t), the clock skew δ of
this client can be computed by the server locally.
C. Platform and Corresponding Limitation
We have built a prototype system to perform experiments
on the clock skew identification. The operation system of the
platform is Ubuntu server, running with apache. Because our
skew estimating method is based on javascript, the time tick
resolution is limited at 1 kHz. This means the accuracy of
timestamp in AJAX packets is only 10−3 second.
D. Usage of Timestamp
With AJAX, timestamps can be collected by server in every
packet returned from client. Unless further specified, all clock
skew estimation is consistent with server time Cs. Assume
the data collection server has received n AJAX packets from
As shown in Fig. 4(c), the skew estimation is much
smoother than the one in Fig. 4(b); the window size w is
200, m is 5 in this example, so the total data for one skew
estimation is 40. By applying this method, the clock skew
estimation hence stable and capable for reducing the effect of
huge network delay.
4) Accumulated Sliding-Windows Skew with Lower-Bound
Filter: Since the local minimum offset is useful to find the
lower-bound skew, we further calculate the accumulated skews
with these local minimum dataset and plot the corresponding
skew distribution diagram in Fig. 4(d). We find that this
method can both reduce the effect of huge network delay
and calculate an approximate skew rapidly within 20 packets.
This skew estimation can be denoted as LR(Min(N1i)) while
receiving ith request from the client.
As a result, by comparing these four types of skew estima-
tions, the lower-bound filter is the main technique to filter out
the huge network delay in our experiments.
B. Quick Piecewise Minimum Algorithm
The quick piecewise minimum algorithm is achieved by
separating data into n segments and picking two minimum
offsets from first segment and fourth segment respectively. By
connecting these two minimum offsets, a slope of this line
can be obtained. In our experiment, n is set to 4. As shown
in Fig. 5, the black circles are offsets, the red squares are the
corresponding segments, and the two blue squares are the two
local minimum offsets. Thus, the estimated skew is the slope
of the black line between two blue squares.
As long as the data set is stable enough, the quick piecewise
minimum algorithm can have high performance with fast
computation. The estimated skew is shown in Fig. 6, using the
same data set with above methods. Since the quick piecewise
minimum algorithm has low computation overhead, it can be
efficiently apply to other cloud service.
C. Jump Point Detection and Elimination
During packet collection period, a jump point of offset
occurs if the client is performing time synchronization with
a time server or roaming between different network providers.
An example of jump point is shown in Fig. 7 marked by the
red circle. If this jump point phenomenon does not detected
by server, the skew estimation process would be affected by
the mass offset error, reacting in an inaccurate result. Thus,
an approach to detect jump point occurrence is needed while
implementing the skew estimation.
To solve the jump point problem, a jump point detection
algorithm is proposed. The main idea of this algorithm is to
divide sequential timestamps into groups, where every pair
of consecutive timestamps in a group produces only a small
time difference. Suppose diff represents the difference between
two adjoining offsets; the diff is denoted as dij , where dij =
oj−oi, ∀i #= j, i < j. Also, another threshold k is set to check
if the diff is too large, thereby detecting the jump point. The
basic jump point detection algorithm is as follows:
1) Pick the local minimum offsets for every p packets.
(a) Accumulated Skew
(b) Skew with Sliding-Windows
(c) Sliding-Windows Skew with Lower-Bound Filter
(d) Accumulated Sliding-Windows Skew with Lower-Bound Filter
Fig. 4. Comparison of each skew estimation by applying linear regression.
Fig. 9. Offset distribution diagram between server and client with network
disconnection.
TABLE I
THE SKEW ESTIMATIONS FOR THE SAME DEVICE UNDER DIFFERENT
ENVIRONMENTS
Network type Skew estimation Packets IP amount
LAN -21.91 ppm 1001 1
-23.24 ppm 207 1
-22.74 ppm 13322 1
ADSL -21.48 ppm 5837 1
-21.08 ppm 1400 1
3G -23.24 ppm 951 1
-23.71 ppm 1027 1
Wi-Fi -21.79 ppm 9810 1
-23.06 ppm 1470 1
Tor -22.53 ppm 15007 55
-23.22 ppm 12922 57
-22.88 ppm 24120 108
VM -113.19 ppm 868 1
-114.22 ppm 1001 1
-6.40 ppm 1001 1
-6.83 ppm 890 1
1000 seconds is required to detect a measurable difference of
1 ppm seconds in our system. For AJAX, our AJAX script
generates a packet every 5 seconds. Thus, the lowest number
of packets required to estimate a clock skew would be 1000/5,
i.e. 200 packets.
For the jump point detection, while detecting, the parameter
p is set to 20, and the threshold k is set to 20. These two
value p and k are adjustable according to different network
environments; with smaller value of these parameters, the jump
point detecting process leads to a much sensitive result.
A. Same Device under Different Networks
The first experiment is performed by a laptop connected
to our data collection system, via multiple network access
techniques. Host behind Tor network and in a virtual machine
(VM) are discussed in this part as well. The purpose of this
experiment is to analyze the skew variations of one device
under different network environments, thereby simulating the
situations that a device logins the cloud service from various
kind of networks. In this experiment, the device is an Apple
Mac Book with a 2.4 GHz Intel Core 2 Duo processor, running
MAC OS X 10.6.8, and the estimated skew is calculated by
jump point detection with quick piecewise minimum algo-
rithm. As shown in table I, we connect this laptop to our
system via common networks, such as LAN, ADSL, 3G, and
Wi-Fi.
According to the first four results, it justifies that clock skew
estimation is relative independent regardless of network access
technique. It is worthy to notice that the estimated skew is fluc-
tuated within 2.16 ppm, from -21.08 ppm to -23.24 ppm. Since
the clock skew may fluctuate with temperature mentioned in
[5,6,8], these experimental results are reasonable with low time
resolution and complicated network environments.
With the skew fluctuation, it is a trend-off to set a justice
threshold for detecting malicious login. If the threshold is too
large, the false positive rate is increasing, which leads to higher
probability to misjudge the skew; otherwise, if the threshold
is too small, the false negative rate is increasing, one device
might be seen as different devices by fluctuation. Thus, after
analyzing the table I, we recommend a threshold ±2 ppm in
our system to detect the malicious login. This threshold gives a
probability of misjudgment 7.4%, or (2.16−2)/2.16, assuming
skew fluctuation is uniform distributed.
Furthermore, the experimental environment on Tor is also
considered in table I. In experimental results, 200 packets
is not enough to calculate a stable estimated skew for Tor.
However, compared the results between common network
versus Tor, as long as the collecting time is long enough, the
estimated skew is close to the common one, because the long
term estimation can reduce the effect of low time resolution.
In contrast, if the host is running in a VM, the skew value is
much different from the real one. Kohno et al. [4] had indicated
that virtual machines do not have constant clock skews, and
our experiments also shows the same results. In addition, we
found that the estimated skew under a VM is relatively stable
without rebooting it; however, after restarting the VM, the
skew randomly changes to another stable value. As shown
in table I, the estimated skews are -113.19 ppm and -114.22
ppm, but the skews change to -6.4 ppm and -6.83 ppm after
rebooting the system.
B. Skew Distribution of Different Devices
In this experiment, we study the distinguishable property of
clock skew. In Fig 10, 100 various devices are connecting to
our system and the distribution of these devices’ skews are
plotted. Some extremely huge and small values are omitted
in the figure whereas only the most dense 80 ones are
shown. Each cross represents a device, whose skew value is
the corresponding y-axis, and the interval denotes ±2 ppm
range. Moreover, each gap between y-axis ticks means 2 ppm
difference. As indicated from the figure, if the identifying
threshold is based on a device’s skew ±2 ppm, most devices
have measurable difference in clock skew. It is considered to
國科會補助計畫衍生研發成果推廣資料表
日期:2012/12/10
國科會補助計畫
計畫名稱: 利用時脈偏移之無線感測節點認證方法研究
計畫主持人: 鄧惟中
計畫編號: 98-2221-E-011-066-MY3 學門領域: 資訊安全
無研發成果推廣資料
其他成果 
(無法以量化表達之
成果如辦理學術活
動、獲得獎項、重要
國際合作、研究成果
國際影響力及其他協
助產業技術發展之具
體效益事項等，請以
文字敘述填列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
