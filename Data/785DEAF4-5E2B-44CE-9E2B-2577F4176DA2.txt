   
Abstract—In this paper, we demonstrate that the logic 
computation performed by the DNA-based algorithm for solving 
general cases of the satisfiability problem can be implemented 
more efficiently by our proposed quantum algorithm on the 
quantum machine proposed by Deutsch. To test our theory, we 
carry out a three-qubit NMR experiment for solving the simplest 
satisfiability problem. 
Index Terms—Quantum Algorithms, Molecular Algorithms, 
the NP-Complete Problems, the Satisfiability Problem. 
I. INTRODUCTION 
ince the publication of Deutsch’s [1] and Adleman’s [2] 
seminal articles, various quantum algorithms and 
DNA-based algorithms have been, respectively, proposed for 
many computational problems. So far, the most frequently cited 
quantum algorithms are Shor’s algorithms for solving factoring 
integers and discrete logarithm [3] and Grover’s search 
algorithm [4] for unsorted databases. On the other hand, 
famous DNA-based algorithms are used to solve factoring 
integers [5] and the set-partition problem [6]. 
II. QUANTUM ALGORITHMS FOR BIO-MOLECULAR 
SOLUTIONS OF THE SATISFIABILITY PROBLEM 
A. All of the Possible Solutions to the Satisfiability Problem 
A clause is a formula of the form un ∨ un − 1 … ∨ u2 ∨ u1, where 
each uk for 1 ≤ k ≤ n is a Boolean variable or its negation. In 
general, a satisfiability problem includes a Boolean formula of 
the form C1 ∧ C2 … ∧ Cm where each Cj for 1 ≤ j ≤ m is a clause. 
Then, the question is to find values of the variables so that the 
 
Manuscript received April 23, 2007; revised May 13, 2008. This work was 
partly supported by the National Science Foundation of R. O. C. under Grants 
No. 96-2221-E-151-008- and 96-2218-E-151-004-, and also partly supported 
by the National Natural Science Foundation of China under Grants No. 
10774163 and No. 2006CB921203. 
Weng-Long Chang and Kawuu Weicheng Lin are with the Department of 
Computer Science and Information Engineering, National Kaohsiung 
University of Applied Sciences, Taiwan, R.O.C. (fax: +886-7-3837424; e-mail: 
changwl@cc.kuas.edu.tw, linwc@cc.kuas.edu.tw).  
Ting-Ting Ren, Jun Luo, Mang Feng are with State Key Laboratory of 
Magnetic Resonance and Atomic and Molecular Physics,Wuhan Institute of 
Physics and Mathematics, Chinese Academy of Sciences, Wuhan, 430071, 
People’s Republic of China (e-mail: ttren@wipm.ac.cn, jluo@wipm.ac.cn, 
mangfeng@wipm.ac.cn). 
Minyi Guo is with the School of Computer Science and Engineering, 
University of Aizu, Fukushima 965-8580, Japan. (e-mail: minyi@u-aizu.ac.jp). 
Copyright (c) 2008 IEEE. 
whole formula has the value 1. 
Assume that U is a set of 2n possible choices and equal to {un 
un − 1 … u2 u1| ∀ uk ∈ {0, 1} for 1 ≤ k ≤ n} and each element 
represents one of 2n combinational states for n Boolean 
variables. For the sake of presentation, we suppose that uk0 is 
used to denote the value of uk to be zero and uk1 means value of 
uk to be one. The jth element in U can be represented as a 
unique computational state vector =1u  [ ] , nn 2  12 ,12 ,11 ,1 Tuuu ×L  where ju  ,1  = 1, ∀ hu  ,1  = 0 for 1 ≤ 
h ≠ j ≤ 2n. The corresponding computational state vector for the 
first element, un0 un − 10 … u20 u10, in U is [ ] , 00 1 n2  1 T×L  
and the corresponding computational state vector for the last 
element, un1 un − 11 … u21 u11, in U is [ ] . 10 0 n2  1 T×L  For 
the sake of presentation, we assume that B is the set of the 
corresponding computational state vectors to the elements in U 
and B = { [ ]  00 1 n2  1 T×L  … [ ] Tn2  110 0 ×L }. 
Because each component in B is a coordinated vector, we span 
B = 
n
C 2 [1, 3, 4], where 
n
C 2  is a Hilbert space. This implies 
that the set B is an orthonormal basis in a Hilbert space. 
B. Computational Space of Molecules for the Satisfiability 
Problem  
The following bio-molecular operations cited from [2] will 
be used to construct computational space of molecules for 
solving the satisfiability problem with m clauses and n Boolean 
variables. 
Definition 2−1: Given a set U = {un un − 1 … u2 u1| ∀ uk ∈ {0, 1} 
for 1 ≤ k ≤ n}and a Boolean variable uj, the bio-molecular 
operation, “Append-Head”, appends uj onto the head of every 
element in the set U. The formal representation is written as 
Append-Head(U, uj) = {uj un un − 1 … u2 u1| ∀ uk ∈ {0, 1} for 1 ≤ 
k ≤ n and uj ∈ {0, 1}}. 
Definition 2−2: Given a set U = {un un − 1 … u2 u1| ∀ uk ∈ {0, 1} 
for 1 ≤ k ≤ n}and a Boolean variable uj, the bio-molecular 
operation, “Append-Tail”, appends uj onto the end of every 
element in the set U. The formal representation is written as 
Append-Tail(U, uj) = {un un − 1 … u2 u1 uj| ∀ uk ∈ {0, 1} for 1 ≤ 
k ≤ n and uj ∈ {0, 1}}. 
Definition 2−3: Given a set U = {un un − 1 … u2 u1| ∀ uk ∈ {0, 1} 
for 1 ≤ k ≤ n}, the bio-molecular operation, “Discard(U)” sets U 
Quantum Algorithms for Bio-molecular 
Solutions of the Satisfiability Problem  
on a Quantum Machine 
S 
Weng-Long Chang, Ting-Ting Ren, Jun Luo, Mang Feng, Minyi Guo and Kawuu Weicheng Lin 
 F. Constructing Quantum Networks for Solving the 
Satisfiability Problem 
The operations OR and AND are implemented by quantum 
circuits in Figures 2−1 and 2−2, respectively. For evaluating a 
clause with the form un ∨ un − 1 … ∨ u2 ∨ u1, three quantum 
registers ,  1uunL  1  yynL  and 01 1       rrrr nn L−  are 
needed. Therefore, its evaluating computation is equal to (2.2): 
1 1      rrr nn L−  0r  1  yynL  1  uunL  → 
 )( ) ( 0111 ryrryr nnn •⊕•⊕ − L 0r  1  yynL  1  uunL , 
where •  denotes operation AND of their negations of two 
Boolean variables } ,{ 1−kk ry  for 1 ≤ k ≤ n. The first bit, r0, in the 
third quantum register is initially prepared in state ,0  and 
other n bits in the third quantum register are initially prepared 
in state .1  The (n + 1)th quantum bit, rn, in the third register is 
employed to store the final result of the evaluating 
computation.  
 
Figure 2−1: OR operation of two Boolean variables. 
 
Figure 2−2: AND operation of two Boolean variables. 
Then, in order to evaluate AND operation of the previous 
clause and the current clause, the fourth quantum register 
01 1       cccc mm L−  is needed. The first bit, c0, in the fourth 
quantum register is initially prepared in state ,1  and other m 
bits in the quantum register are initially in state .0  The (m + 
1)th quantum bit, cm, in the fourth register is employed to store 
the final result of evaluating computation for all of the clauses. 
The full network, QEC (the abbreviation of quantum 
evaluating circuit for checking whether the current clause is 
true or not), is illustrated in Figure 2−3 in Appendix A and can 
be understood as follows: 
• We compute the (n + 1)th bit of the third quantum register 
to the final result of evaluating a clause. This step requires 
computing all the OR operations through the relation rk ← 
rk ⊕ ) ( 1−• kk ry  for 1 ≤ k ≤ n. Then, we compute AND 
operation of the previous clause and the current clause 
through the relation cj ← cj ⊕ ) ( 1 nj rc •−  for 1 ≤ j ≤ m.  
• Subsequently we reverse all those OR operations in order 
to restore every quantum bit of each quantum register to its 
initial state. This enables us to reuse the same quantum 
registers, should the problem, for example, require repeated 
OR operation.  
Subsequently, we reverse all those operations (NOT or 
CNOT) on the second quantum register to restore every 
quantum bit of the second quantum register to its initial state. 
This enables us to reuse the same second quantum register to 
evaluate the next clause. 
G. Quantum Algorithms of Lipton’s DNA-based Algorithms 
for Solving the Satisfiability Problem 
Based on Algorithm 2−1 in Subsection D, the following 
quantum algorithm is proposed to work on the physical 
quantum computer proposed by Deutsch [1]. For convenience 
of our following presentation, we suppose that cj1 denotes the 
value of cj to be 1 and cj0 defines the value of cj to be 0 for 1 ≤ j 
≤ m. We also assume that rk1 denotes the value of rk to be 1 and 
rk0 defines the value of rk to be 0 for 0 ≤ k ≤ n. Similarly, yk1 
denotes the value of yk to be 1 and yk0 defines the value of yk to 
be 0. Moreover, the notations used in Algorithm 2−2 below 
have been denoted in previous subsections. 
Algorithm 2−2: Quantum algorithms of Lipton’s DNA-based 
algorithm for solving the satisfiability problem with m clauses 
and n Boolean variables. 
(1) For an input Φ  = 
)( 01 sms c=⊗ ⊗ )( 10c ⊗ )( 11 qnq r=⊗ ⊗ )( 00r ⊗ )( 01 qnq y=⊗ ⊗
),( 01 qnq u=⊗  2n possible choices of n bits (including all of the 
possible choices) are 0 ,1ϕ  = )( 221 ×=⊗ Ims ⊗ (I2×2) 
⊗ )( 221 ×=⊗ Inq ⊗ (I2×2) ⊗ )( 221 ×=⊗ Inq ⊗ H⊗n Φ  = 
n2
1 )( 01 sms c=⊗ ⊗ )( 10c ⊗ )( 11 qnq r=⊗ ⊗ )( 00r ⊗
)( 01 qnq y=⊗ ⊗ )).(( 101 qqnq uu +⊗ =  
(2) For j = 1 to m do begin 
(3)   For i = 1 to |Cj| do begin 
(4)     If the ith element in the jth clause is one of n Boolean 
 variables uk, Then 
(5)   ij  ,ϕ  = )( 221 ×=⊗ Ims ⊗ (I2×2) ⊗ )( 221 ×=⊗ Inq ⊗ (I2×2) 
⊗ )( 221 ×+=⊗ Ik np ⊗ ))(( 100 kkk uuy +⊕ ⊗ )( 221 1 ×−=⊗ Ikp ⊗
)( 22
1
×=⊗ Inq 1 , −ijϕ  
=
n2
1 )( 0s
j
ms c=⊗ ⊗ )( 1 1 sjs c−=⊗ ⊗ )( 10c ⊗ )( 11 qnq r=⊗ ⊗
)( 00r ⊗ )( 01 pk np y+=⊗ ⊗  )( 10 kk yy + ⊗ )( 01 1 pkp y−=⊗  ⊗  
)),(( 101 qqnq uu +⊗ =  where 
.11for  )( 1 ≥≥−•⊕= − sjrccc nsss  
(6)     Else 
(7)    ij  ,ϕ  = )( 221 ×=⊗ Ims ⊗ (I2×2) ⊗ )( 221 ×=⊗ Inq  ⊗  (I2×2) ⊗  
 including those choices that satisfy the whole formula and 
those illegal choices that dissatisfy the whole formula. 
Finally, based on ,1mc  the execution of Step (13) is for a 
measurement to find the answer to the satisfiability problem 
with m clauses and n Boolean variables. Therefore, Algorithm 
2−2, i.e., quantum algorithm of Lipton’s DNA-based algorithm, 
can also be used to solve the satisfiability problem with m 
clauses and n Boolean variables.   J 
III. QUANTUM IMPLEMENTATION OF A 
BIO-MOLECULAR COMPUTING ON A QUANTUM 
MACHINE 
The following lemmas are introduced to show that the 
bio-molecular computer proposed by Adleman [2] can be 
implemented on the quantum machine proposed by Deutsch 
[1]. 
Lemma 3−1: For any NP-complete problem, 2n possible 
solutions on the bio-molecular computer proposed by Adleman 
[2] can be implemented on the quantum machine proposed by 
Deutsch [6], where n is the number of bits for input size of the 
problem. 
Proof: 
From Lemma 2−1, 2n possible solutions, U = {un un − 1 … u2 
u1| ∀ uk ∈ {0, 1} for 1 ≤ k ≤ n}, for any NP-complete problem 
are created from the DNA-based algorithm, 
CombinationalStates(U, n). From Lemma 2−1, 2n possible 
solutions form an orthonormal basis of a Hilbert space (a 
complex vector space, ).2
n
C  Similarly, 2n possible quantum 
solutions for the same problem are φ  = H⊗n 000L  = 
n2
1  
,
1 2
0
∑−
=
n
i
i  and also form an orthonormal basis of a Hilbert space (a 
complex vector space, ).2
n
C  Therefore, from the statements 
above, we may conclude that for any NP-complete problem, 2n 
possible solutions on the bio-molecular computer proposed by 
Adleman [2] can be implemented on the quantum machine 
proposed by Deutsch [1].   J 
Lemma 3−2: The bio-molecular operation, Append-Head(U, uj) 
= {uj un un − 1 … u2 u1| ∀ uk ∈ {0, 1} for 1 ≤ k ≤ n and uj ∈ {0, 
1}}, denoted in Definition 2−1 can be implemented by the 
corresponding quantum operator, Φ  = 0  ⊗ 
(H⊗n )0000L  = 0  ⊗ (
n2
1  ∑−
=
1 2
0
n
i
i ) or Φ  = 1  ⊗ 
(H⊗n )0000L  = 1  ⊗ (
n2
1  ∑−
=
1 2
0
n
i
i ). 
Proof: 
From Definition 2−1, for 2n possible solutions U = {un un − 1 
… u2 u1| ∀ uk ∈ {0, 1} for 1 ≤ k ≤ n} and a Boolean variable uj, 
the bio-molecular operation, “Append-Head”, appends uj onto 
the head of the elements in the set U, that is, Append-Head(U, 
uj) = {uj un un − 1 … u2 u1| ∀ uk ∈ {0, 1} for 1 ≤ k ≤ n and uj ∈ {0, 
1}}. If the value for uj is equal to 0, then from Lemma 3−1, the 
action of the bio-molecular operation “Append-Head” can be 
implemented by Φ  = 0  ⊗ (H⊗n )0000L  = 0  ⊗ (
n2
1  
∑−
=
1 2
0
n
i
i ). Otherwise, the action of the bio-molecular operation 
“Append-Head” can be implemented by Φ  = 1  ⊗ 
(H⊗n )0000L  = 1  ⊗ (
n2
1  ∑−
=
1 2
0
n
i
i ).   J 
Lemma 3−3: The bio-molecular operation, Append-Tail(U, uj) 
= {un un − 1 … u2 u1 uj| ∀ uk ∈ {0, 1} for 1 ≤ k ≤ n and uj ∈ {0, 
1}}, denoted in Definition 2−2 can be implemented by Φ  = 
(H⊗n )0000L  ⊗ 0    = (
n2
1  ∑−
=
1 2
0
n
i
i ) ⊗ 0  or Φ  = 
(H⊗n )0000L  ⊗ 1  = (
n2
1  ∑−
=
1 2
0
n
i
i ) ⊗ 1 . 
Proof: Refer to Lemma 3−2.   J 
Lemma 3−4: The bio-molecular extract operation, +(U, uj1) = 
{un un − 1 … uj1 … u2 u1| ∀ uk ∈ {0, 1} for 1 ≤ k ≠ j ≤ n}and −(U, 
uj1) = {un un − 1 … uj0 … u2 u1| ∀ uk ∈ {0, 1} for 1 ≤ k ≠ j ≤ n}, 
denoted in Definition 2−5 can be implemented by CNOT. 
Proof: Refer to Algorithm 2−2.  J 
Lemma 3−5: The bio-molecular extract operation, +(U, uj0) = 
{un un − 1 … uj0 … u2 u1| ∀ uk ∈ {0, 1} for 1 ≤ k ≠ j ≤ n}and −(U, 
uj0) = {un un − 1 … uj1 … u2 u1| ∀ uk ∈ {0, 1} for 1 ≤ k ≠ j ≤ n}, 
denoted in Definition 2−5 can be implemented by NOT and 
CNOT 
Proof: Refer to Algorithm 2−2.  J 
Lemma 3−6: Assume that U = {un un − 1 … u2 u1| ∀ uk ∈ {0, 1} 
for 1 ≤ k ≤ n} and W is a subset of U and Ua is also a subset of U 
for 1 ≤ a ≤ m. From Definition 2−3 and Definition 2−6, the 
bio-molecular merge operation and discard operation, i.e., 
∪(U1, …, Um) = U1 ∪ … ∪ Um and Discard(W) = ∅, perform 
logic computation of the satisfiability problem that can be 
implemented by NOT, CNOT, CCNOT. 
Proof: Refer to Algorithm 2−2.  J 
Lemma 3−7: Assume that U = {un un − 1 … u2 u1| ∀ uk ∈ {0, 1} 
for 1 ≤ k ≤ n}. From Definition 2−7 and Definition 2−8, the 
bio-molecular detect operation and read operation, i.e., 
Detect(U) and Read(U), to find the answer to the satisfiability 
problem  can be implemented by means of measurements. 
Proof: Refer to Algorithm 2−2.  J 
Theorem 3−1: The bio-molecular computer proposed by 
Adleman [2] is a subset of the quantum machine proposed by 
Deutsch [1] and can be implemented on the quantum machine. 
Proof:  
From Lemmas 3−1 through 3−7, it is very clear that 
bio-molecular computational space for any NP-complete 
problem can be constructed on a quantum machine, and the 
  
 
Figure 5-1: The quantum circuit of the example above. 
NMR approach has been widely employed to quantum 
information processing over past years due to its mature and 
well-controllable technology. Although the quantum 
information processing by NMR is made on ensembles of 
nuclear spins, instead of individual spins, NMR has remained 
to be the most convenient experimental tool to demonstrate 
quantum information processing. We here also adopt this 
technology to check our theory.  
Our experiment is carried out on a Varian INOVA 600 NMR 
spectrometer. The sample is 
13C labelled−  alanine with 
formula 
13 13 13
1 3 2 2 3( )CH CH NH COOH− − , where the three 
carbons 
13 13
1 , ,C C C
13
2 3   correspond to the qubits 1 2 3, ,I I I  , 
respectively. The J-coupling constants 
are 12 23 1334.79 , 54.01 , 1.20J Hz J Hz J Hz=  =  = . Selective 
excitation was achieved by using soft pulses. 
The experiment has three main steps as follows: 
Step 1 is for initialization. Before the algorithm is carried 
out, the initial state, i.e., the pseudo-pure state, must be well 
prepared. There have been many methods to do this job, among 
which the spatial averaging method proposed by Cory et al. is 
most commonly used. So in our experiment, we have also 
employed this technique to prepare the three-qubit pseudo-pure 
state for which the detailed pulse sequence can be found in. The 
states of the input qubits are prepared by following operation 
1 2 3 1 2 2 3 1 3 1 2 32 2 2 4z z z z z z z z z z z zE I I I I I I I I I I I I+ + + + + + + , where E is 
the unity operator with the form of 
1 0
0 1
E ⎛ ⎞= ⎜ ⎟⎝ ⎠ , and 
1
2iz z
I σ=
, with 
i = 1, 2 and 3, being the ith spin angular momentum operator in 
the z direction, and zσ  is the Pauli matrix,
1 0
0 1z
σ ⎛ ⎞= ⎜ ⎟−⎝ ⎠ . 
Step 2 translates the quantum gates into NMR pulses, 
respectively. We had to connect and optimize the pulses to 
construct the total NMR pulse sequence. The Hadamard gate 
can be achieved by a single 2/π  pulse with phase x. The 
CNOT gate can be implemented by NMR pulses as follows, 
2 1,2 1,2 2[ / 2] (1/ 4 ) [ ] (1/ 4 ) [ ] [ / 2]y x x xJ Jπ π π π→ → → → → , where the 
flip angle of the pulse and the time of delay are written in the 
square brackets and in the round brackets, respectively. The 
subscripts are the phases (i.e., along the x or y axis) of the pulse, 
and the superscripts are the nuclei to which the pulses are 
applied. Then we could obtain the total pulse sequence by 
connecting and optimizing the above pulses according to the 
quantum circuit. 
Step 3 is the measurement, where a readout pulse is applied 
to each qubit to obtain the spectra. 
Note that in NMR measurements, the frequencies and phases 
of NMR signals could clearly indicate the state the system 
evolved to after the readout pulses have been applied. In our 
experiment, the phases of the reference of 13C spectra from a 
thermal equilibrium was adjusted to be in absorption (i.e., to be 
positive), and then the same phase corrections were used to 
determine the absolute phases of the experimental spectra of 
the 13C after the algorithm is accomplished. In our case, the 
final state was 
2/0|)11|00(|2/)101|000(| 21313123123 〉〉+〉=〉+〉 , which 
means the first and the third qubits are entangled. As the 
readout by NMR is a weak measurement, we have no state 
collapse after the measurement. Besides, only single quantum 
coherence can be detected in NMR. As a result, we have to 
employ some additional operations for detecting the output 
state (|000>+|101>)/√2. We may detect the second qubit 
directly by applying a π/2 readout pulse along the x axis, 
yielding Figure 5-2 (b). But for the first and third qubits, we 
need to disentangle them before measurement. To this end, we 
apply a CNOT gate, respectively, on the first and second qubits 
followed by another CNOT gate, respectively, on the second 
and first qubits to get the state (|000>+|011>)/√2. Then the 
first qubit can be read out by a single π/2 pulse along the x axis, 
as shown in Figure 5-2 (a). Similar steps applied to the third 
qubit result in the spectrum in Figure 5-2 (c). It is evident that 
the experimental results are in good agreement with our 
theoretical prediction. 
Therefore, due to the fact that NMR quantum operations are 
not made on individual nuclear spins, but on spin ensemble, 
there is a difference in the operation between Figure 5-1 and 
our experiment.  Some remarks must be addressed. First of all, 
the three-qubit NMR experiment we have carried out suffices 
to make a comprehensive test for our theory, because we have 
achieved the key aspects of our theory. Although the simple 
case with three qubits did not reflect the efficiency of quantum 
computation for SAT problem, we argue that, with more 
variables and clauses involved, the quantum computing 
efficiency would be more and more evident, which has been 
reflected in our above discussion about the computational 
complexity. Secondly, DNA computation does not involve 
entanglement, whereas entanglement does appear in our 
quantum treatment. The necessity of additional operations to 
disentangle the output qubits is not the intrinsic characteristic 
of our quantum mechanical treatment, but due to the unique 
feature of NMR technique. Anyway, those additional 
operations have not changed the essence of our 
implementation. 
   
Abstract—In this paper, quantum algorithms for solving an 
instance of the subset-sum problem is proposed and a NMR 
experiment for the simplest subset-sum problem to test our 
theory is also performed. 
I. INTRODUCTION 
In this paper, an instance of the subset-sum problem can be 
implemented by our proposed quantum algorithm. By using 
nuclear magnetic resonance (NMR) technique, we perform an 
NMR experiment for the simplest subset-sum problem to test 
our theory. 
II. QUANTUM ALGORITHMS OF THE SUBSET-SUM PROBLEM 
A. Definition of the Subset-sum Problem 
Assume that a finite set A is {a1, …, am}, where ak is the kth 
element for 1 ≤ k ≤ m. Definition 4−1 is applied to denote the 
subset-sum problem for any a finite set, A. 
Definition 4−1: The subset-sum problem for an m-element 
finite set, A, is to find a subset A1 ⊆ A such that the sum of 
every element in A1 is exactly b, where b is any given positive 
integer. 
B. Computational State Space of Quantum Solutions for the 
Subset-sum Problem 
An arbitrary state ϕ  of a quantum bit is nothing else than 
a linearly weighted combination of the following 
computational basis vectors (4.1): ϕ  = l1 ⋅ 0  + l2 ⋅ 1  = 
l1 ⋅ 
120
1
×
⎥⎦
⎤⎢⎣
⎡
 + l2 ,1
0
12×
⎥⎦
⎤⎢⎣
⎡
 where the weighted factors l1 and l2 ∈ 
C2 are the so-called probability amplitudes, thus they must 
satisfy | l1 |2 + | l2 |2 = 1. 
C. Introduction of Quantum Gates for Solving the Subset-sum 
Problem  
The NOT gate is a one-qubit gate and sets the only (target) 
bit to its negation. The CNOT (controlled NOT) gate is a 
two-qubit gate and flips the second qubit (the target qubit) if 
 
Weng-Long Chang is with Department of Computer Science and 
Information Engineering, National Kaohsiung University of Applied Sciences 
Kaohsiung City, Taiwan 807-78, Republic of China (e-mail: 
changwl@cc.kuas.edu.tw).  
Mang Feng  was with State Key Laboratory of Magnetic Resonance and 
Atomic and Molecular Physics, Wuhan Institute of Physics and Mathematics, 
Chinese Academy of Sciences, Wuhan, 430071, People’s Republic of China 
(e-mail: mangfeng@wipm.ac.cn). 
 
and only if the first qubit (the control qubit) is one. The 
CCNOT (controlled-controlled-NOT) gate is a three-qubit 
gate and flips the third qubit (the target qubit) if and only if the 
first qubit and second qubit (the two control qubits) are both 
one.  
D. Constructing Quantum Networks for Solving the 
Subset-sum Problem 
The full addition network is illustrated in Figure 4-1, and 
can be understood as follows: 
 
Figure 4-1: Adder network of n quantum bits. 
 
We only reverse all these operations in Figure 4-1 in order to 
restore every quantum bit of the three registers to its initial 
state. This enables us to reuse the same registers repeatedly.  
E. Quantum Algorithms of Solving the Subset-sum Problem  
The following quantum algorithm is proposed as quantum 
implementation on a physical quantum. The notations used in 
Algorithm 4-1 below have been denoted in previous 
subsections. 
Algorithm 4-1: The quantum algorithm is to solve an instance 
of the subset-sum problem for any given positive integer b 
with a finite set A involving m elements of n bits. 
(1) For an initial input 0ϕ  = )( 01 pnp r=⊗  ⊗ )( 10r  ⊗ 
)(  ,1
1
1 qnq b+=⊗  ⊗ )( 01+nb  ⊗ )( 01 jnj b=⊗  ⊗ 
)( 0 ,
11
 , jknjmk a==⊗  ⊗ )( 01 ,11  , −==⊗ jknjmk c  ⊗ 
Quantum Algorithms of the Subset-sum Problem on a Quantum Computer 
Weng-Long Chang1*, Ting-Ting Ren2, Mang Feng3*, Lai Chin Lu4, Kawuu Weicheng Lin5 and Minyi Guo6 
 1( mk =⊗ I2×2) ⊗ I2×2 ⊗ I2×2 1,3 −++   tmϕ  = m2
1 )( 01 p
t
np r
+
=⊗  
⊗ )(( ,110 ttt brr  •⊕ −  ⊗ ))(( ,1101 1 ppptp brr •⊕⊗ −−=  ⊗ 
)( 10r  ⊗ )( ,11 1 qt nq b  + +=⊗  ⊗ )( ,1 tb   ⊗ )( ,11 1 qtq b  −=⊗  ⊗ 
)( 1+nb  ⊗ )( 1 jnj b=⊗  ⊗ )(  ,11  , jknjmk y==⊗  ⊗ 
)( 1 ,
11
 , −==⊗ jknjmk c  ⊗ )(( 101 kkmk ee +⊗ =  ⊗ )( 01+nr  
⊗ ),
2
10
(
−
 where for 1 ≤ p ≤ t − 1 )( ,110 ppp brr •⊕ −  is 
obtained from the execution of the previous iterations for Step 
(5b). 
EndFor 
 
(6) 13 +++ nmϕ = )( 221 ×=⊗ Inp  ⊗ I2×2 ⊗ )( 1 1  NOTn nq+ +=⊗  ⊗ 
)( 22
1
  ×=⊗ Inq  ⊗ I2×2 ⊗ )( 221 ×=⊗ Inj  ⊗ )( 2211  , ×==⊗ Injmk  ⊗ 
)( 22
11
 , ×==⊗ Injmk  ⊗ 1( mk =⊗ I2×2) ⊗ I2×2 ⊗ I2×2 nm ++3ϕ = 
m2
1 ))(( ,11
01
pppnp brr •⊕⊗ −= ⊗ )( 10r  ⊗ )( 1,1 + nb  
⊗ )(  ,11 qnq b=⊗  ⊗ )( 1+nb  ⊗ )( 1 jnj b=⊗  ⊗ 
)(  ,
11
 , jknjmk y==⊗  ⊗ )( 1 ,11  , −==⊗ jknjmk c  ⊗ 
)(( 101 kkmk ee +⊗ =  ⊗ )( 01+nr  ⊗ ).2
10
(
−
 
 
(7) 23 +++ nmϕ  = )( 221 ×=⊗ Inp  ⊗ I2×2 ⊗ )( 221 1 ×+=⊗ Inq      ⊗ 
I2×2 ⊗ )( 221 ×=⊗ Inj  ⊗ )( 2211  , ×==⊗ Injmk  ⊗ 
)( 22
11
 , ×==⊗ Injmk  ⊗ 1( mk =⊗ I2×2) ⊗ CCNOT ⊗ I2×2 
13 +++ nmϕ  = m2
1
 ))(( ,11
01
pppnp brr •⊕⊗ −=  ⊗ 
)( 10r  ⊗ )( 1,1 + nb  ⊗ )(  ,11 qnq b=⊗  ⊗ )( 1+nb  ⊗ 
)( 1 jnj b=⊗  ⊗ )(  ,11  , jknjmk y==⊗  ⊗ )( 1 ,11  , −==⊗ jknjmk c  
⊗ )(( 101 kkmk ee +⊗ =  ⊗ ))(( 1,10 1 ++ •⊕ nnn brr  ⊗ 
).
2
10
(
−
 
 
(8) 33 +++ nmϕ  = )( 221 ×=⊗ Inp  ⊗ I2×2 ⊗ )( 221 1 ×+=⊗ Inq      ⊗ 
I2×2 ⊗ )( 221 ×=⊗ Inj  ⊗ )( 2211  , ×==⊗ Injmk  ⊗ 
)( 22
11
 , ×==⊗ Injmk  ⊗ 1( mk =⊗ I2×2) ⊗ I2×2 ⊗ )2
10
( 1+⊕− nr  
23 +++ nmϕ  = )
2
1)1(( 1
m
rn ×− +  
))(( ,11
01
pppnp brr •⊕⊗ −=  ⊗ )( 10r  ⊗ )( 1,1 + nb  ⊗ 
)(  ,1
1
qnq b=⊗  ⊗ )( 1+nb  ⊗ )( 1 jnj b=⊗  ⊗ 
)(  ,
11
 , jknjmk y==⊗  ⊗ )( 1 ,11  , −==⊗ jknjmk c  ⊗ 
)(( 101 kkmk ee +⊗ =  ⊗ )( 1+nr  ⊗ ).2
10
(
−
 
 
(9) Since quantum operations are naturally reversible, the 
auxiliary quantum bits can be restored to their initial states by 
reversing the operations from Steps (7) to (2). 
 
(10) Apply Grover’s operator in Grover’s algorithm to the 
quantum state vector generated in Step (9). 
(11) At most repeat to execute from Step (2) to Step (10) of 
22
m
 times. 
 
(12) The answer is obtained with a successful probability of at 
least 
2
1
 after a measurement is finished. 
End Algorithm 
Lemma 4-1: For a finite set with m elements, n bits of each 
element in the finite set, and a given positive integer b, the 
quantum implementation of the DNA-based algorithm of 
solving an instance of the subset-sum problem in Algorithm 
4-1 is equivalent to the oracle work in Grover’s Algorithm, 
i.e., the target state labeling, preceding Grover’s searching 
step. 
Proof:  It is omitted due to space.   J 
III. COMPLEXITY ASSESSMENT 
 The following lemmas are used to demonstrate time 
complexity and space complexity of Algorithm 4-1 for 
solving an instance of the subset-sum problem for any given 
positive integer b and a finite set including m elements of n 
bits. 
Lemma 5-1: For any given positive integer b and a finite set 
involving m elements of n bits, the time complexity of solving 
an instance of the subset-sum problem is O(m + 1) Hadamard 
gates, O((2 × m × n + 2 × n + 2 × 1) × m2 ) NOT gates, O((8 
× m × n + 2 × n + 3 × 1) × m2 ) CNOT gates, O((4 × m × n + 
2 × n + 2 × 1) × m2 ) CCNOT gates, O( m2 ) Grover’s 
operators, and O(1) measurement. 
Proof: Refer to Algorithm 4-1.   J 
Lemma 5-2: For any given positive integer b and a finite set 
involving m elements of n bits, the space complexity of solving 
   
Abstract—In this paper, it is demonstrated that solving an 
instance of the vertex cover problem of any graph G with m edges 
and n vertices can be implemented by Hadamard gates, NOT 
gates, CNOT gates, CCNOT gates, Grover’s operators, and 
quantum measurements on a quantum computer. To test our 
theory, an NMR (nuclear magnetic resonance) experiment for 
the simplest vertex-cover problem is also performed. 
VI. INTRODUCTION  
n this paper, it is first demonstrated that solving an instance 
of the vertex cover problem of any graph with m edges and n 
vertices can be implemented by Hadamard gates, NOT gates, 
CNOT gates, CCNOT gates, Grover’s operators, and 
quantum measurements on a physical quantum computer. To 
test our theory, an NMR (nuclear magnetic resonance) 
experiment for the simplest vertex-cover problem is also 
performed. 
VII. QUANTUM ALGORITHMS FOR OF SOLVING THE 
VERTEX COVER PROBLEM  
A. Definition of the Vertex Cover Problem 
Suppose that G is a graph and G = (V, E), where V is a set of 
vertices in G and E is a set of edges in G. Mathematically, a 
vertex cover of graph G is a subset V1 ⊆ V of vertices such that 
for each edge (va, vb) in E, at least one of va and vb belongs to V1. 
Definition 4-1 is applied to denote the vertex–cover problem 
of graph G. 
Definition 4-1: The vertex cover problem of graph G with n 
vertices and m edges means finding a minimum-sized vertex 
cover in G. 
B. Computational State Space of Quantum Solutions for the 
Vertex Cover Problem 
An arbitrary state ϕ  of a quantum bit is nothing else than 
a linearly weighted combination of the following 
computational basis vectors (4.1): ϕ  = l1 ⋅ 0  + l2 ⋅ 1  = 
 
Weng-Long Chang is with Department of Computer Science and 
Information Engineering, National Kaohsiung University of Applied Sciences 
Kaohsiung City, Taiwan 807-78, Republic of China (e-mail: 
changwl@cc.kuas.edu.tw).  
Mang Feng  was with State Key Laboratory of Magnetic Resonance and 
Atomic and Molecular Physics, Wuhan Institute of Physics and Mathematics, 
Chinese Academy of Sciences, Wuhan, 430071, People’s Republic of China 
(e-mail: mangfeng@wipm.ac.cn). 
 
l1 ⋅ 
120
1
×
⎥⎦
⎤⎢⎣
⎡
 + l2 ,1
0
12×
⎥⎦
⎤⎢⎣
⎡
 where the weighted factors l1 and l2 ∈ 
C2 are the so-called probability amplitudes, thus they must 
satisfy | l1 |2 + | l2 |2 = 1.  
C. Introduction to Quantum Gates for Solving the Vertex 
Cover Problem 
The NOT gate is a one-qubit gate and sets the only (target) 
bit to its negation. The CNOT (controlled NOT) gate is a 
two-qubit gate and flips the second qubit (the target qubit) if 
and only if the first qubit (the control qubit) is one. The 
CCNOT (controlled-controlled-NOT) gate is a three-qubit 
gate and flips the third qubit (the target qubit) if and only if the 
first qubit and second qubit (the two control qubits) are both 
one.   
D. Constructing Quantum Networks for Finding Legal Vertex 
Covers 
For OR operations, its evaluating computation is equal 
to (4.4): )( 11 p
k
mp r
+
=⊗  ⊗ )( 1kr  ⊗ )( 1 1 pkp r−=⊗  ⊗ 
)( 1 qnq x=⊗  → )( 11 pk mp r+=⊗  ⊗ ) ( 1 jik xxr •⊕  ⊗ 
)( 1 1 pkp r−=⊗  ⊗ ),( 1 qnq x=⊗  where •  denotes the AND 
operation of two Boolean variables { ji xx  , } for 1 ≤ i and j ≤ n, 
and for 1 ≤ p ≤ k − 1, pr  = .1 jip xxr •⊕  For AND 
operations, its evaluating computation is equal to (4.5): 
)( 01 p
k
mp c
+
=⊗  ⊗ )( 0kc  ⊗ )( 1 1 pkp c−=⊗  ⊗ )( 10c  ⊗ 
)( 1 pmp r=⊗  ⊗ )( 1 qnq x=⊗  →  )( 01 pk mp c+=⊗  ⊗ 
) ( 1
0
kkk rcc •⊕ −  ⊗ )( 1 1 pkp c−=⊗  ⊗ )( 10c  ⊗ 
)( 1 pmp r=⊗  ⊗ ),( 1 qnq x=⊗ where •  denotes the AND 
operation of two Boolean variables { kk rc  ,1− } for 1 ≤ k ≤ m, 
and for 1 ≤ p ≤ k − 1, pc  =  .10 ppp rcc •⊕ −  
E. Constructing Quantum Networks for Finding a 
Minimum-sized Vertex Cover 
Lemma 4-1 is used to describe that the parallel logic 
computation. 
Lemma 4-1: The parallel logic computation of finding a 
vertex cover with the minimum size of vertices among legal 
Quantum Algorithms of the Vertex Cover Problem on a Quantum Computer 
Weng-Long Chang1*, Ting-Ting Ren2, Mang Feng3*, Shu-Chien Huang4, 
Lai Chin Lu5, Kawuu Weicheng Lin6 and Minyi Guo7 
I 
 End For 
End For 
(5) 
0 ,1
2
)1(1 ++×+ nn
ϕ  = )
2
10
( ,wnz⊕−  ⊗ 
)( 22
0
  
1
  ×== ⊗⊗ Iijni  ⊗ )( 22×I  ⊗ )( 220   0 1  ×=−= ⊗⊗ Iijni  ⊗ 
)( 22
0
  
0
1  ×=−= ⊗⊗ Iijni  ⊗ 
)))()((( 2222
1
 1 
00
1 ××+−==−= ⊗⊗⊗⊗ IIjiaijni  ⊗ 
)( 22
1
  ×=⊗ Imk  ⊗ )( 22×I  ⊗ )( 221   ×=⊗ Imk  ⊗ )( 221 ×=⊗ Inb  
0 ,
2
)1(1 +×+ nn
ϕ  = )
2
10
(
−
 ⊗ 
wnz
n
,)1(
2
1 −× )(  ,0   1   jiijni z== ⊗⊗  ⊗ )( 10 ,0z  ⊗ 
)( 0,,
00
1 jiijni g=−= ⊗⊗  ⊗ )( 0,,00 1 jiijni f=−= ⊗⊗  ⊗ 
)))()((( 1 0,,,,
1
 1 
00
1 jiajijiaijni hh ⊗⊗⊗⊗ +−==−=  ⊗ 
)( 1   kmk c=⊗  ⊗ )( 10c  ⊗ )( 1 kmk r=⊗  ⊗ 
)).(( 101   bbnb xx +⊗ =  
(6) Since quantum operations are reversible by nature, the 
auxiliary quantum bits can be restored to their initial states by 
reversing all these operations finished by Steps (4a) and (2). 
(7) Apply Grover’s algorithm to the quantum state vector 
generated in Step (6). 
(8) Return the result to Algorithm 4-2 after a measurement is 
finished. 
EndAlgorithm 
Lemma 4-2: Algorithm 4-1 is used to calculate the number of 
ones to legal vertex covers for any graph G with m edges and n 
vertices on a quantum computer. 
 
G. Quantum Algorithms for Solving the Vertex Cover 
Problem of any Graph G with m Edges and n Vertices 
The following quantum algorithm is applied to solve the 
vertex cover problem of any graph G with m edges and n 
vertices. The notations used in Algorithm 4-2 below have 
been denoted in previous subsections. 
 
Algorithm 4-2: Quantum algorithms for solving the vertex 
cover problem of any graph G with m edges and n vertices. 
(1) For w = 1 to n 
(1a) Call Algorithm 4-1(w). 
(1b) If the answer is obtained from the wth execution of  
Step (1a) then  
(1c) Terminate Algorithm 4-2. 
End If 
End For 
End Algorithm 
 
Lemma 4-3: Algorithm 4-2 which is equivalent to the oracle 
work (in the language of Grover’s Algorithm), that is, the 
target state labeling preceding Grover’s searching step, and is 
used to solve the vertex cover problem of any graph G with m 
edges and n vertices.   J 
VIII. COMPLEXITY ASSESSMENT 
The following lemmas are used to show the time complexity 
and the space complexity of Algorithm 4-2 for solving the 
vertex cover problem of any graph G with m edges and n 
vertices. 
Lemma 5-1: The average case for time complexity of solving 
the vertex cover problem for any graph G with m edges and n 
vertices is O((
2
1+n
) × (n+1)) Hadamard gates, O((
2
1+n
) × 
( 22
n
× (8 × m + (
3
462 23 nnn ×+×+×
)))) NOT gates, 
O((
2
1+n
) × 22
n
) CNOT gates, O((
2
1+n
) × ( 22
n
× (4 × m + 
(
3
1415 23 nnn ×+×+
)))) CCNOT gates, O((
2
1+n
) × 
( n2 )) Grover’s operators, and O(
2
1+n
) measurements.   
J 
Lemma 5-2: The average case for space complexity of solving 
the vertex cover problem for any graph G with m edges and n 
vertices is O((
2
1+n
) × ((2 × m + 3) + 
(
6
2615 23 nnn ×+×+
))) quantum bits.   J 
IX. AN EXAMPLE OF THREE-QUBIT SOLUTION FOR 
THE VERTEX-COVER PROBLEM  
Consider the simplest case of the vertex-cover problem with 
a graph G = {V, E}, where V is {v1} and E is {(v1, v1)}. Our 
experiment is carried out on a Varian INOVA 600 NMR 
spectrometer. The sample is 13C labelled−  alanine with 
formula 13 13 131 3 2 2 3( )CH CH NH COOH− − , where the 
three carbons 13 131 , ,C C C
13
2 3  correspond to the qubits 
1 2 3, ,I I I  , respectively. The J-coupling constants are 
12 23 1334.79 , 54.01 , 1.20J Hz J Hz J Hz=  =  = . Soft 
pulses are used to achieve the selective excitation. The 
experiment has three main steps as follows. 
 
Note that in NMR measurements, the frequencies and 
phases of NMR signals could clearly indicate the state the 
system evolves to after the readout pulses have been applied. 
In our experiment, the phases of the reference of 13C spectra 
from a thermal equilibrium were adjusted to be in absorption 
(i.e., to be positive), and then the same phase corrections were 
 心得報告
 
本人於七月十日及十一日出席”The 2009 WASE 
INTERNATIONAL CONFERENCE ON Information 
Engineering”，在會議上有聽過不同的”KEYNOTE”的演
講，深感隔行如隔山。雖然皆是計算機科學的領域，
但是如果你沒有從事那些子領域，那麼你很難聽的懂
他在講什麼。 
 
本人於會場上和一些論文發表者談天，發現他們
都很年輕的學生，精力充沛，後生可畏。 
 
本人於會場發表2篇論文，內容附於第二頁開始至
最後一頁結束。 
 
)( 0 ,
11
 , jknjmk a==⊗  ⊗ )( 01 ,11  , −==⊗ jknjmk c  ⊗ 
)( 01 kmk e=⊗  ⊗ )( 01+nr  ⊗ ),1(  2m possible choices of m 
bits (including all of the possible subsets) are 1 ϕ  = 
)( 22
1
×=⊗ Inp  ⊗ I2×2 ⊗ )( 221 1 ×+=⊗ Inq  ⊗ I2×2 ⊗ )( 221 ×=⊗ Inj  
⊗ )( 22
11
 , ×==⊗ Injmk  ⊗ )( 2211  , ×==⊗ Injmk  ⊗ H⊗m ⊗ I2×2 ⊗ H 
0ϕ = m2
1 )( 01 pnp r=⊗ ⊗ )( 10r ⊗ )(  ,11 1 qnq b+=⊗ ⊗
)( 01+nb  ⊗ )( 01 jnj b=⊗  ⊗ )( 0 ,11  , jknjmk a==⊗  ⊗ 
)( 01 ,
11
 , −==⊗ jknjmk c  ⊗ ))(( 101 kkmk ee +⊗ =  ⊗ 
)( 01+nr  ⊗ ).2
10
(
−
 
 
(2) 2 ϕ  = )( 221 ×=⊗ Inp ⊗ I2×2 ⊗ )( 221 1 ×+=⊗ Inq  ⊗ I2×2 ⊗ 
)( 22
1
×=⊗ Inj  ⊗ )(  ,11  , jknjmk U==⊗  ⊗ )( 2211  , ×==⊗ Injmk  ⊗ 
1( mk =⊗ I2×2) ⊗ I2×2 ⊗ I2×2 1ϕ = 
m2
1 )( 01 pnp r=⊗ ⊗ )( 10r ⊗ )(  ,11 1 qnq b+=⊗ ⊗ )( 01+nb  
⊗ )( 01 jnj b=⊗  ⊗ )(  ,11  , jknjmk y==⊗  ⊗ 
)( 01 ,
11
 , −==⊗ jknjmk c  ⊗ ))(( 101 kkmk ee +⊗ =  ⊗ 
)( 01+nr  ⊗ ),2
10
(
−
where 
⎪⎩
⎪⎨
⎧
=+⊕
== ×  1   if      )(
 0   if                              
 ,
100
 ,
 ,22
 ,
jkkkjk
jk
jk aeea
aI
U  and 
.
)( 100 ,
0
 ,
 , ⎪⎩
⎪⎨
⎧
+⊕= kkjk
jk
jk eea
a
y  
 
(3) For s = 1 to m 
(3a) 2 +sϕ  = )( 221 ×=⊗ Inp  ⊗ I2×2 ⊗ )( 221 1 ×+=⊗ Inq  ⊗ QA 
⊗ 1( mk =⊗ I2×2) ⊗ I2×2 ⊗ I2×2 1+sϕ = 
m2
1 )( 01 pnp r=⊗ ⊗ )( 10r ⊗ )(  ,11 1 qnq b+=⊗  ⊗ )( 1+nb  
⊗ )(  ,1 jsjnj yb +⊗ =  ⊗ )(  ,11  , jknjmk y==⊗  ⊗ 
)( 01 ,
11
 , −
+
==⊗ jks njmk c  ⊗ )( 1 ,1 , −==⊗ jks njsk c  ⊗ 
)( 1 ,
11
 ,1 −=−=⊗ jknjsk c  ⊗ ))(( 101 kkmk ee +⊗ = ⊗ )( 01+nr  
⊗ ),
2
10
(
−
 where QA is the quantum adder of n bits 
denoted in Figure 4-1, bn + 1 = ys, n AND bn AND cs, n − 1, cs, j − 1 = 
ys, j − 1 AND bj − 1 AND cs, j − 2 for 1 ≤ j ≤ n and ck, j − 1 = yk, j − 1 
AND bj − 1 AND ck, j − 2 for 1 ≤ k ≤ s − 1 and 1 ≤ j ≤ n. 
EndFor 
 
 (4) 3 +mϕ  = )( 221 ×=⊗ Inp  ⊗ I2×2 ⊗ )( 1 1CNOTnq     +=⊗  ⊗ 
I2×2 ⊗ )( 221 ×=⊗ Inj  ⊗ )( 2211  , ×==⊗ Injmk  ⊗ 
)( 22
11
 , ×==⊗ Injmk  ⊗ 1( mk =⊗ I2×2) ⊗ I2×2 ⊗ I2×2 2+mϕ = 
m2
1 )( 01 pnp r=⊗  ⊗ )( 10r  ⊗ )(  ,11 1    qqnq bb ⊕⊗ +=  ⊗ 
)( 1+nb  ⊗ )( 1 jnj b=⊗  ⊗ )(  ,11  , jknjmk y==⊗  ⊗ 
)( 1 ,
11
 , −==⊗ jknjmk c  ⊗ )(( 101 kkmk ee +⊗ = ⊗ )( 01+nr  
⊗ ),
2
10
(
−
 where jkjj ybb  ,  +=  and ck, j − 1 = yk, j − 1 
AND bj − 1 AND ck, j − 2 for 1 ≤ k ≤ m and 1 ≤ j ≤ n, and 1+nb  
is that the last carry is the most significant bit of the result from 
the last execution of Step (3a). 
 
(5) For t = 1 to n 
(5a) 1,3 −++   tmϕ  = )( 221 ×=⊗ Inp  ⊗ I2×2 ⊗ )( 221 1    ×+ +=⊗ It nq  ⊗ 
)( NOTt tq   =⊗  ⊗ )( 221 1 ×=⊗ Itq  -    ⊗ I2×2 ⊗ )( 221 ×=⊗ Inj  ⊗ 
)( 22
11
 , ×==⊗ Injmk  ⊗ )( 2211  , ×==⊗ Injmk  ⊗ 1( mk =⊗ I2×2) ⊗ I2×2 
⊗ I2×2 13 −++ tmϕ  = m2
1 )( 0p
t
np r=⊗  ⊗  
))(( ,11
01
1 ppptp brr •⊕⊗ −−=  ⊗ )( 10r  ⊗ )( ,11 1 qt nq b  + +=⊗  ⊗ 
)( ,1 tb   ⊗ )( ,11 1 qtq b  −=⊗  ⊗ )( 1+nb  ⊗ )( 1 jnj b=⊗  ⊗ 
)(  ,
11
 , jknjmk y==⊗  ⊗ )( 1 ,11  , −==⊗ jknjmk c  ⊗ 
)(( 101 kkmk ee +⊗ =  ⊗ )( 01+nr  ⊗ ),2
10
(
−
 where for 
1 ≤ q ≤ t − 1 qb ,1  is obtained from the execution of the 
previous iterations for Step (5a) and for 1 ≤ p ≤ t − 1 
)( ,11
0
ppp brr •⊕ −  is obtained from the execution of the 
previous iterations for Step (5b). 
(5b) tm ++3 ϕ  = )( 221 ×+=⊗ It np  ⊗ )( CCNOTt tp=⊗  ⊗ 
)( 22
1
1 ×−=⊗ Itp  ⊗ I2×2 ⊗ )( 221 1 ×+=⊗ Inq      ⊗ I2×2 ⊗ 
)( 22
1
×=⊗ Inj  ⊗ )( 2211  , ×==⊗ Injmk  ⊗ )( 2211  , ×==⊗ Injmk  ⊗ 
an instance of the subset-sum problem is O(2 × m × n + m +3 × 
n + 5) quantum bits. 
Proof: Refer to Algorithm 4-1.   J 
IV. NMR EXPERIMENTS OF THREE-QUBIT SOLUTION TO THE 
SUBSET-SUM PROBLEM  
Consider the simplest case of the subset-sum problem with a 
finite set A1 = {1} and any given value b = 1. The size of the 
first (only) element in the finite set, A1, is represented as a1, 11. 
The size of b (its size is one) is represented as b1, 11. The value 
of m is equal to one and the value of n is also equal to one. 
NMR approach has been widely employed to quantum 
information processing over past years due to its mature and 
well-controllable technology. Although the quantum 
information processing by NMR is made on ensembles of 
nuclear spins, instead of individual spins, NMR has remained 
to be the most convenient experimental tool to demonstrate 
quantum information processing. We here also adopt this 
technology to check our theory. 
Note that in NMR measurements, the frequencies and 
phases of NMR signals could clearly indicate the state the 
system evolves to after the readout pulses had been applied. In 
our experiment, the phases of the reference of 13C spectra from 
a thermal equilibrium were adjusted to be in absorption (i.e., to 
be positive), and then the same phase corrections were used to 
determine the absolute phases of the experimental spectra of 
13C after the algorithm was accomplished. In our case, the final 
state was 
123 123( 000 111 ) / 2+  which means the three 
qubits are entangled. As the readout by NMR is a weak 
measurement, we have no state collapse after the measurement. 
Besides, only single quantum coherence can be detected in 
NMR. As a result, we have to employ some additional 
operations to disentangle them for detecting the output state 
123 123( 000 111 ) / 2+ . For this end, we apply a CNOT 
gate on the second and first qubits to get the state 
123 123( 000 011 ) / 2+ . The second qubit is control 
quibte and the first qubit is the target qubit. Then the first qubit 
can be read out by a s ingle / 2π  pulse along the x-axis, as 
shown in Figure 6-1 (a). Similar steps applied to the second 
and third quits, respectively, result in the spectrum in Figure 
6-1 (b) and Figure 6-1 (c). It’s evident that the experimental 
results are in good agreement with our theoretical prediction. 
V. CONCLUSIONS 
We have investigated the availability of quantum 
implementation for an instance of the subset-sum problem 
with a finite set involving m elements of n bits. We have also 
estimate the complexity of our solution and carried out an 
experiment by NMR technology for a simplest example. 
 (a) 
 
(b) 
 
(c) 
 
Figure 6-1: Experimental spectra (a)-(c) of the three-qubit 
solution to the subset-sum problem after the readout on the 
first, second and third qubits, respectively. 
vertex covers in G is (4.6): 1,1 ++ jiz  = 1,1 ++ jiz ⊕ ( mc ∧(xi 
+ 1 ∧ jiz , ∧ ( ),11 2 kii jk z ++ +=∧ )) and 
jiz ,1+ = jiz ,1+ ⊕ ( mc  ∧ 1+ix  ∧ )., jiz    J 
F. Quantum Algorithms for Calculating the Number of Ones 
to Legal Vertex Covers for Any Graph G with m Edges and n 
Vertices 
The following quantum algorithm is proposed to work on 
the physical quantum computer and is used to calculate the 
number of ones to legal vertex covers for any graph G with m 
edges and n vertices.  
Algorithm 4-1 (w): Quantum algorithms for calculating the 
number of ones to legal vertex covers for any graph G with m 
edges and n vertices. 
(1) For an initial input Φ  = 1  ⊗ )( 0 ,0   1   jiijni z== ⊗⊗  ⊗ 
)( 10 ,0z  ⊗ )( 0 0,,00 1 jiijni g=−= ⊗⊗  ⊗ 
)( 0 0,,
00
1 jiijni f=−= ⊗⊗  ⊗ 
)))()((( 1 0,,
0
,,
1
 1 
00
1 jiajijiaijni hh ⊗⊗⊗⊗ +−==−=  ⊗ 
)( 01   kmk c=⊗  ⊗ )( 10c  ⊗ )( 11 kmk r=⊗  ⊗ 
),( 01   bnb x=⊗  2n possible choices of n bits (including all 
possible vertex covers) are 0 ,0ϕ  = (H) ⊗ 
)( 22
0
  
1
  ×== ⊗⊗ Iijni  ⊗ )( 22×I  ⊗ )( 220   0 1  ×=−= ⊗⊗ Iijni  ⊗ 
)( 22
0
  
0
1  ×=−= ⊗⊗ Iijni  ⊗ 
)))()((( 2222
1
 1 
00
1 ××+−==−= ⊗⊗⊗⊗ IIjiaijni  ⊗ 
)( 22
1
  ×=⊗ Imk  ⊗ )( 22×I  ⊗ )( 221   ×=⊗ Imk  ⊗ H⊗n Φ  = 
)
2
10
(
−
 ⊗ 
n2
1 )( 0 ,
0
  
1
  jiijni z== ⊗⊗  ⊗ )( 10 ,0z  ⊗ 
)( 0 0,,
00
1 jiijni g=−= ⊗⊗  ⊗ )( 0 0,,00 1 jiijni f=−= ⊗⊗  ⊗ 
)))()((( 1 0,,
0
,,
1
 1 
00
1 jiajijiaijni hh ⊗⊗⊗⊗ +−==−=  ⊗ 
)( 01   kmk c=⊗  ⊗ )( 10c  ⊗ )( 11 kmk r=⊗  ⊗ 
)).(( 101   bbnb xx +⊗ =  
 
(2) 0 ,1ϕ  = )( 22×I  ⊗ )( 220   1   ×== ⊗⊗ Iijni  ⊗ )( 22×I  ⊗ 
)( 22
0
  
0
1  ×=−= ⊗⊗ Iijni  ⊗ )( 220   0 1  ×=−= ⊗⊗ Iijni  ⊗ 
)))()((( 2222
1
 1 
00
1 ××+−==−= ⊗⊗⊗⊗ IIjiaijni  ⊗ QEC ⊗ 
0 ,0ϕ  = )2
10
(
−
 ⊗ 
n2
1 )( 0 ,
0
  
1
  jiijni z== ⊗⊗  ⊗ 
)( 10 ,0z  ⊗ )( 0 0,,00 1 jiijni g=−= ⊗⊗  ⊗ 
)( 0 0,,
00
1 jiijni f=−= ⊗⊗  ⊗ 
)))()((( 1 0,,
0
,,
1
 1 
00
1 jiajijiaijni hh ⊗⊗⊗⊗ +−==−=  ⊗ 
))(( 1
01
kkkmk rcc •⊕⊗ −=  ⊗ )( 10c  ⊗ 
))(( 11 jikmk xxr •⊕⊗ =  ⊗ )),(( 101   bbnb xx +⊗ =  where 
QEC is the quantum circuit in (4.4) and (4.5) in Subsection D 
and bits xi and xj represent vertices vi and vj, respectively, in the 
kth edge, ek = (vi, vj), in G to 1 ≤ k ≤ m. 
(3) For i = 0 to n − 1 
(4) For j = i down to 0 
   (4a) 
0 ,1)())1((1
1
01
1 +−+++ ∑−
=
ji
i
θ
θ
ϕ  = )( 22×I  ⊗ FMNO 
0 ),())1((1
1
01
1 ji
i
−+++ ∑−
=θ
θ
ϕ  = )
2
10
(
−
 ⊗ 
n2
1
 
)( 0 ,
0
  
2
  lssl
i
ns z=
+
= ⊗⊗  ⊗ (( 1 1  + +=⊗i is )(  ,2  lsj sl z+=⊗  ⊗ 
)( 1,13,12,1,11 ,1 +++++++++ ••••••⊕ iijijijiimji zzzzxcz L
 ⊗ )( ,1 ,1 jiimji zxcz ••⊕ ++  ⊗ )))( 0 ,0 1  lsjl z−=⊗  ⊗ 
1
  ( is =⊗ ))(  ,0   lssl z=⊗  ⊗ )( 10 ,0z  ⊗ 
)( 0 0,,
01
1 edde
i
nd g=
+
−= ⊗⊗  ⊗  )((( 0,,1 edj dei id g+== ⊗⊗  ⊗ 
)( ,1
0
0,, jiiji zxg •⊕ +  ⊗ )))( 0 0,,0 1 edje g−=⊗  ⊗ 
))(( 0,,
00
1 eddeid g=−= ⊗⊗  ⊗ )( 0 0,,01 1 eddei nd f=+ −= ⊗⊗  ⊗ 
)((( 0,,
1
ed
j
de
i
id f
+
== ⊗⊗  ⊗ )( 1,,10 0,, +−+ •⊕ jijiiji hxf  ⊗ 
)))( 0 0,,
0
1 edje f−=⊗  ⊗ ))(( 0,,00 1 eddeid f=−= ⊗⊗  ⊗ 
)))()((( 1 0,,
0
,,
1
 1 
01
1 edaededade
i
nd hh ⊗⊗⊗⊗ +−==+ −=  ⊗ 
)(((( ,,
1
1
1
aededa
j
de
i
id h+−=
+
== ⊗⊗⊗  ⊗ )))( 1 0,,edh  ⊗ 
))(( ,,,
0
1,, jijijijiji hzh −+− •⊕  ⊗ 
)))((( 1,,1,1
0
,,
1
−+++−= •⊕⊗ ajiajiajijia hzh  ⊗ )( 1 0,, jih  ⊗ 
))))()((( 1 0,,
0
,,
1
 1 
0
1 edaededaje hh ⊗⊗⊗ +−=−=  ⊗ 
)(((( ,,
1
1
00
1 aededadeid h+−==−= ⊗⊗⊗  ⊗ ))))( 1 0,,edh  ⊗ 
)( 1 kmk c=⊗  ⊗ )( 10c  ⊗ )( 1 kmk r=⊗  ⊗ 
)),(( 101   bbnb xx +⊗ =  where FMNO is the quantum 
circuit in (4.6) in Subsection E, and for m ≥ k ≥ 1 quantum 
bits kc and kr  are all the results generated in Step (2). 
