solutions for most inputs in linear time, based on 
the observation that the execution times of update 
transactions are relatively small compared to the 
validity interval lengths of realtime data objects in 
many real-time applications. In the remaining cases 
for which Phase I fails to derive solutions, Phase II 
is invoked by employing an existing deadline-
monotonic-based algorithm, which we show is also 
applicable to our problem. Meanwhile, we have devised 
several techniques which significantly reduce the 
cost of schedulability test, and hence greatly 
improve time efficiency. Our experimental results 
demonstrate that GEEDF outperforms existing 
approaches in terms of generated workloads. While 
Phase II has a pseudo-polynomial time complexity, our 
experimental study shows that Phase II runs much 
faster than other solutions with comparable quality. 
英文關鍵詞： Real-Time Databases； Temporal Consistency； Update 
Transaction； Periods and Deadlines； Earliest 
Deadline First. 
 
I 
 
目錄 
中英文摘要及關鍵詞................................................................................................. II 
中文摘要 .................................................................................................................  II 
英文摘要 ................................................................................................................  III 
報告內容........................................................................................................................ 4 
INTRODUCTION  .................................................................................................... 1 
PRELIMINARIES AND PROBLEM STATEMENT ............................................... 2 
GENERAL ALLGORITHM FOR THE ASSIGNMENT PROBLEM ...................... 3 
PERFORMANCE EVALUATION ........................................................................... 9 
RELATED WORK .................................................................................................. 12 
CONCLUSIONS ...................................................................................................... 13 
參考文獻...................................................................................................................... 14 
  
III 
 
 
 
 
2. 計畫英文摘要： 
Deriving deadlines and periods for update transactions so as to maintain 
timeliness and data freshness while minimizing imposed workload has long been 
recognized an important problem in real-time database research. Despite years of 
active research, the state-of-the-art still has much room for improvement, 
particularly for periodic transactions scheduled by the Earliest Deadline First 
(EDF) algorithm. In this paper, we propose a practical and efficient two-phase 
algorithm, GEneral EDF (ग़εா஽ி), for assigning periods and deadlines to 
EDF-scheduled update transactions. Phase I of ग़εா஽ிaims at finding solutions for 
most inputs in linear time, based on the observation that the execution times of 
update transactions are relatively small compared to the validity interval lengths 
of realtime data objects in many real-time applications. In the remaining cases for 
which Phase I fails to derive solutions, Phase II is invoked by employing an 
existing deadline-monotonic-based algorithm, which we show is also applicable to 
our problem. Meanwhile, we have devised several techniques which significantly 
reduce the cost of schedulability test, and hence greatly improve time efficiency. 
Our experimental results demonstrate that ग़εா஽ிoutperforms existing approaches 
in terms of generated workloads. While Phase II has a pseudo-polynomial time 
complexity, our experimental study shows that Phase II runs much faster than 
other solutions with comparable quality. 
  
Keywords： Real-Time Databases; Temporal Consistency; Update Transaction; 
Periods and Deadlines; Earliest Deadline First. 
  
 
 
and DS-FP [9], [29]. One exception is the work con-
ducted by Xiong et al. [31] who designed a linear-time
EDF algorithm, called MLEDF , which solves the assign-
ment problem for update transactions with deadlines
no greater than their corresponding periods. MLEDF
is efﬁcient in time, but is built on a sufﬁcient (not
necessary) feasibility condition, which means it may not
produce optimal solutions that minimize imposed CPU
workload for some inputs. The same authors further
proposed OSEDF [31], a branch and bound based search
algorithm, with the goal of obtaining optimal solutions.
By assuming a discrete-time system, OSEDF can handle
transactions with arbitrary deadlines in relation to their
periods. The main problem with OSEDF is that it does
not scale well with increasing problem size. To address
this problem, they further proposed HSEDF [31], a
heuristic search-based algorithm, which is always ca-
pable of ﬁnding a solution if one exists. Compared to
OSEDF , HSEDF ’s efﬁciency is achieved at the expense
of increased processor workload.
In this study, we take a fresh look at the problem
of determining deadlines and periods for ﬁrm periodic
real-time update transactions scheduled under EDF. Our
aim is to continue to push the envelope and further
advance the state-of-the-art. We propose a general two-
phase algorithm, called GEneral EDF (or GEEDF for
short), which outputs periods and deadlines for update
transactions that result in signiﬁcantly lower workload
than that by existing approaches. The ﬁrst phase of
GEEDF has a linear time complexity and hence can
be utilized to derive a solution very efﬁciently. The
second phase is invoked only when phase one fails.
Though having a pseudo-polynomial time complexity,
the second phase can also run in a time-efﬁcient manner
due to our novel techniques which signiﬁcantly reduce
the overhead when checking schedulability. In a nutshell,
the proposed algorithm is practical and efﬁcient for
many real-time applications. Speciﬁcally, GEEDF is im-
portant in cases where a polynomial-time test produces
transaction sets with relatively high workload, or an
exact test runs unacceptably slow, though optimal in
workload reduction. Our study shows that such cases
are not uncommon. Comparing with previous work, our
contributions can be summarized as follows:
1) We propose a novel approach based on EDF, namely
GEEDF , which outperforms all existing periodic ap-
proaches based on Deadline Monotonic (DM) and EDF
scheduling in terms of schedulability and CPU work-
load.
2) We introduce several techniques which signiﬁcantly
reduce the overhead when checking schedulability.
As a result, GEEDF can run in a time-efﬁcient manner,
although it has a pseudo-polynomial time complexity.
3) We have conducted extensive simulation experiments
to compare the performance of GEEDF with existing
periodic schemes. The experiment results demon-
strate that GEEDF is an efﬁcient solution that can sig-
niﬁcantly reduce resulting CPU workload compared
to existing approaches.
Organization: The remainder of this paper is organized
as follows: Section 2 reviews the deﬁnition of tempo-
ral validity and presents some assumptions, as well
as the period and deadline assignment problem to be
addressed. Section 3 presents the details of the two
phases of GEEDF . Section 4 presents the performance
studies. Section 5 brieﬂy discusses related work. Finally,
Section 6 concludes the paper.
In this section, we ﬁrst review the deﬁnition of temporal
validity for data freshness, and then present some nota-
tions as well as important assumptions made throughout
the paper. Finally, we precisely introduce the problem to
be addressed.
2.1 Temporal Validity for Data Freshness
In a real-time database, a data object is a logic image
of a real-world entity. As the state of a real-world en-
tity changes continuously, to monitor the entity’s state
faithfully, real-time data objects must be refreshed by
update transactions, which are generated periodically
by intelligent sensors, before they become invalid. The
actual length of the temporal validity interval of a real-
time data object is application dependent [20], [22], [23].
We assume that a sensor always samples the value of a
real-time data at the beginning of its update period.
Deﬁnition 1. A real-time data object (xi) at time t is
temporally valid if, for its jth update ﬁnished last before t,
the sampling time (ri,j) plus the validity interval (Vi) of the
data object is not less than t, i.e., ri,j + Vi ≥ t.
A value for real-time data object xi sampled at any
time t will be valid from t up to (t + Vi). To satisfy the
validity constraint, for each xi, the corresponding update
transaction should execute at least twice during Vi.
Traditional methods for maintaining temporal validity,
such as Half-Half and More-Less, have been proposed
based on ﬁxed-priority scheduling algorithms. Readers
are referred to [11], [22], [30] for more details about these
approaches.
2.2 Notations and Assumptions
In this paper, we use T = {τi}ni=1 and X = {xi}ni=1 to
denote a set of periodic sensor update transactions and
a set of real-time or temporal data, respectively. All tem-
poral data are assumed to be kept in main memory. Each
data xi (1 ≤ i ≤ n) is associated with a validity interval
length Vi. Transaction τi is responsible for updating the
corresponding data xi periodically. Since each sensor
update transaction updates different data, no concur-
rency control is considered. Each update transaction τi
is periodic and is characterized by the following 3-tuple:
{Ci, Di, Ti}, where Ci is the execution time, Di is the
relative deadline and Ti is the period. Here we consider
 
 
STATEMENT
II.    PRELIMINARIES AND PROBLEM
2
Algorithm 1 Phase I of GEEDF
1: Input: A set of update transactions T = {τi}ni=1
sorted in non-decreasing order of Vi, with ties re-
solved in favor of transactions with less slack (Vi −
Ci);
2: Output: Deadlines {Di}ni=1 and periods {Ti}ni=1;
3: U = 0; Dmax =
∑n
i=1 Ci;
4: for i = 1; i ≤ n; i + + do
5: Di =
∑i
j=1 Cj ; Ti = Vi −Di; U = U + CiTi ;
6: // Check the conditions in Theorem 2;
7: if (Di ≤ Vi2 ∧ Dmax ≤ Ti ∧ U ≤ 1) then
8: continue;
9: else
10: abort;
11: end if
12: end for
schedulability. The following theorem characterizes a
condition under which schedulability is guaranteed,
which lays the foundation for GEIEDF ’s assignment of
deadlines and periods.
Theorem 2. Given an update transaction set T = {τi}ni=1
with deadlines derived by Di =
∑i
j=1 Cj and periods by Ti =
Vi −Di, if the maximum deadline, i.e., Dmax =
∑n
j=1 Cj , is
not larger than any period in T , then T is guaranteed to be
schedulable under EDF.
Proof: Since Dmax ≤ Tk (1 ≤ k ≤ n), we know for
each transaction τi (1 ≤ i ≤ n), there is Di ≤ Tk (1 ≤
k ≤ n), hence it is obvious that Ci +
∑i−1
j=1 Di/TjCj =∑i
j=1 Cj = Di, which means T is schedulable under DM.
Since any task (or transaction) set that is schedulable un-
der DM is also schedulable under EDF [4], the theorem
follows.
It has been observed that in many real-time appli-
cations, the execution times of update transactions are
relatively small compared with the validity interval
lengths of real-time data objects [20], [30]. Based on this
observation and our deadline and period assignment
approach, the premise of Theorem 2 is likely to hold
in many real applications. This is also demonstrated in
our experimental study.
While Theorem 2 provides a useful sufﬁcient condition
for determining schedulability, it does not specify in
what order transactions should be assigned deadlines
and periods. It has been observed that different assign-
ment orders can lead to different processor workloads.
The Shortest Validity First (SVF) order, which assigns
priorities to transactions in the inverse order of validity
length with ties resolved in favor of transactions with
less slack (Vi−Ci being the slack of τi), has been shown
to be a good heuristic in many applications [3], [30],
particularly when validity interval lengths are much
larger than transaction computation times. This is also
the story for our case. In fact, by using similar partition
and merge operations as in [30], it can be shown that the
solution with SVF is within 2
∑
i∈T
(
Ci
Vi
)2
of that of an
optimal solution, under similar restrictions. Considering
that the validity interval lengths are much larger than
corresponding transaction execution times, for example,
avionics applications [11] with sensor transaction com-
putation times in the range of milliseconds and validity
interval lengths in the range of hundreds of milliseconds
and seconds, this bound is actually very small and can
be ignored. Since the derivation of the bound with SVF
is quite similar to [30], we do not detail it in this work.
Nevertheless, due to its near-optimality, we will also
use SVF in the following discussion unless otherwise
speciﬁed, and leave the search for the general optimal
assignment order as direction for future research.
Based on Theorem 2, we use the following approach
to derive a solution to the assignment problem: For
each transaction τi, we ﬁrst set Di =
∑i
j=1 Cj and
Ti = Vi−Di. Then we check (1) Di ≤ Vi2 2, (2) Dmax ≤ Ti
and (3) U ≤ 1. If all these three conditions are satisﬁed,
then Di and Ti are determined, and we proceed to
transaction τi+1. Otherwise, the process is terminated,
meaning that GEIEDF fails to derive a solution. When
each of the n transactions has been assigned a pair of
deadline and period, GEIEDF succeeds in obtaining a
solution. Algorithm 1 shows GEIEDF in pseudo code.
Given a set of update transactions sorted in non-
decreasing order of their validity interval lengths,
GEIEDF has a time complexity of O(n) and hence can
be used to determine transaction deadlines and periods
very efﬁciently. Moreover, whenever GEIEDF can derive
a solution, the workload of this solution is always less
than those achievable by all other schemes.
Theorem 3. Given an update transaction set T , if GEIEDF
can derive a solution, then the workload of this solution is
minimum over SVF ordering.
Proof: Suppose there exists another feasible solution
A under SVF ordering but with workload lower than
that of GEIEDF , then there must exist at least one transac-
tion in A whose deadline is less than the one by GEIEDF .
Since the solution derived by GEIEDF is the one with
minimum deadlines (Dj =
∑j
i=1 Cj) that can satisfy the
property in Lemma 1, it is clear that A cannot satisfy the
necessary condition in Lemma 1, and this contradicts the
assumption that A is feasible.
It should be noted that although GEIEDF can be utilized
to derive solutions for a large number of cases efﬁciently,
as demonstrated in our experimental study in Section 4,
it still fails in certain cases, particularly when the number
of transactions is large. This is because when determin-
ing Di and Ti for τi, Phase I declares failure if there is
Dmax > Ti. When the scale of the transaction set is large,
with the growth of the number of update transactions,
the sum of the execution time, i.e., Dmax, tends to exceed
2. Notice here we require Di ≤ Vi2 since if Di >
Vi
2
, then Di > Ti,
which contradicts Di ≤ Dmax ≤ Ti.
4
Theorem 5. Given an update transaction set T , the min-
imum workload derived under EDF is not larger than the
minimum one under DM.
Proof: Justiﬁed by the fact from Lemma 2 (MLDM
can result in the minimum workload solution under DM
scheduling) and Theorem 4 (an MLDM solution is also
feasible under EDF).
Based on Theorem 5, if one can derive a solution by
MLDM , then it is possible to enhance the solution to
further decrease the workload under EDF.
Another point we want to emphasize is that, based on
Lemma 2 and Theorem 4, we know that every transac-
tion set, for which a DM-based method is able to ﬁnd a
solution, also has a solution by an EDF-based method.
However, the converse is not true. For example, suppose
we reduce the validity interval length of τ3 in Example 1
from 46 to be 38. MLDM fails to derive a solution,
even if we allow arbitrary transaction deadlines and
use EMLDM to ﬁnd a solution. But one can still obtain
a solution under EDF (for example, by a search-based
algorithm like OSEDF ), with D3 = 19 and U = 0.938.
This illustrates the superiority of EDF-based methods on
solving the deadline and period assignment problem.
In summary, we know that when scheduling real-time
update transactions, EDF outperforms DM not only on
the range of transaction set, but also on the resulted
processor workload. Nevertheless, in this work, we will
utilize MLDM to derive a preliminary solution (or part
of the solution) at ﬁrst, due to its time efﬁciency.
A Discussion Regarding the Failure Condition of
MLDM : Since the maximum utilization that a trans-
action set can be schedulable is 100% and the density
factor λ should be less than the corresponding utilization
(
∑ Ci
Vi <
∑ Ci
Ti
because Ti < Vi), one may wonder
whether there exists any upper density factor bound be-
yond which the transaction set is deﬁnitely unschedula-
ble byMLDM? If we can ﬁnd such an upper bound, then
obviously, we have also identiﬁed the failure condition
of MLDM . However, to our surprise, we found there
does not exist such an upper bound, because even when
λ approaches to 1, MLDM can still derive a feasible
solution sometimes. For example, given a transaction set
with n = 18 and λi (1 ≤ i ≤ 18) be 0.106, 0.073, 0.0718,
0.0709, 0.0669, 0.0628, 0.0608, 0.0537, 0.0505, 0.0452,
0.0419, 0.0374, 0.0308, 0.0301, 0.0301, 0.0129, 0.00854,
0.0012, respectively, let K be a large integer (e.g., 1000),
we can construct the transaction set as follows:
• T1 = 1, C1 = λ11−λ1 , D1 = C1,V1 = D1 + T1, U1 =
C1/T1;
• T2 = K, V2 = T2/(1 − λ2/(1 − U1)), C2 = V2λ2;
U2 = C2/T2, D2 = C2/(1− U1);
...
• Ti = Ki, Vi = Ti/(1 − λi/(1 −
∑i−1
j=1 Uj)), Ci =
Viλi;Ui = Ci/Ti, Di = Ci/(1−
∑i−1
j=1 Uj).
It is not difﬁcult to verify the schedulability of the
constructed transaction set by performing response time
analysis3. As the transaction set is a harmonic one, the
schedulability upper bound is 100%. Following a similar
analysis as in the above example, we can construct an
MLDM schedulable transaction set with a density factor
approaching 1 as n increases by using Matlab. Hence,
the failure condition of MLDM cannot be derived by
merely judging the density factor. In fact, we need to
use MLDM itself to check whether a transaction set
is MLDM schedulable or not, and this is exactly the
method we have used in this work.
Depending on whether a solution can be obtained by
MLDM or not, Phase II can further be divided into two
subcases, as detailed in the following.
3.2.1 Case 1: MLDM succeeds in deriving a solution
According to Theorem 4, we can obtain a feasible solu-
tion to the assignment problem. But according to Theo-
rem 5, we know that the workload derived by MLDM
may be higher than the minimum one under EDF. Hence,
as a second step, we need to enhance the solution to
further decrease the workload without jeopardizing the
schedulability.
In order to decrease workload and comply with the
validity constraint, the only choice is to decrease one
transaction’s deadline, which inversely increasing its cor-
responding period. Since the assignment order is ﬁxed,
now our major concern is how to ﬁnd the minimum
deadline for τi, so that the EDF-schedulability of the
transaction set can be preserved.
Given a transaction τi, a simple but inefﬁcient method
to ﬁnd the minimum deadline for τi would be starting
by setting Di = Ci, and then increasing Di by one tick
at each iteration, until the transaction set is found to be
schedulable. This simple algorithm (denoted by one-tick
increment scheme hereafter) is inefﬁcient because it re-
quires a large number of steps to terminate. In this work,
we introduce a method to increment Di by a suitable
amount, which can signiﬁcantly improve the efﬁciency.
We will detail how to compute the increment amount
later. At ﬁrst, since the high complexity of utilizing an
exact schedulability test comes from that one needs to
check all the scheduling points, we introduce the fol-
lowing theorem to eliminate the unnecessary scheduling
points when verifying schedulability at each iteration
step. The initial value of Di is set to be Di−1 +Ci, since
according to Lemma 1, this is the minimum possible
value that can guarantee schedulability.
Theorem 6. For an EDF-schedulable update transaction set
T = {τi}ni=1, when decreasing τi’s deadline Di to be D′i and
increasing Ti to be T ′i = Vi − D′i, one only needs to check
the scheduling points in S = {di,k|di,k = kTj + Dj ∧D′i ≤
3. Note the above example may require some reduction of the value
Ci (say Δi) such that Di =
∑i−1
j=1 Di/TjCj + Ci −Δi (in order
to guarantee that the transaction set is DM schedulable). However, by
choosing a sufﬁciently large K, Δi can be considered as a minor and
negligible part.
6
When checking the schedulability of Tk, we intro-
duce the following theorem to eliminate the unnecessary
scheduling points at each iteration, and hence improve
the efﬁciency.
Theorem 8. When adding a new transaction τi into an EDF-
schedulable transaction set Ti−1, one only needs to check the
scheduling points in S = {di,k|di,k = kTj+Dj∧Di ≤ di,k ≤
min(Lia, L
i
b), k ∈ N, 1 ≤ j < i} to verify the schedulability of
Ti.
Proof: Since Ti−1 is schedulable under EDF, we have,
h(di,k, i− 1) =
i−1∑
m=1
(⌊
di,k −Dm
Tm
⌋
+ 1
)
Cm ≤ di,k (7)
Now consider the two cases of τj ,
1) j = i. It is apparant that di,k = kTi + Di ≥ Di.
2) 1 ≤ j < i. If di,k = kTj + Dj < Di, then
h(di,k, i) =
i∑
m=1
(⌊
di,k −Dm
Tm
⌋
+ 1
)
Cm
=
∑i−1
m=1
⌊
di,k + Tm −Dm
Tm
⌋
Cm +
⌊
di,k + Ti −Di
Ti
⌋
Ci
=
∑i−1
m=1
⌊
di,k + Tm −Dm
Tm
⌋
Cm = h(di,k, i− 1) ≤ di,k
(8)
which means we only need to test those scheduling
points no less than Di.
In summary, one only needs to check the scheduling
points in S = {di,k|di,k = kTj + Dj (1 ≤ j ≤ i) ∧ Di ≤
di,k ≤ min(Lia, Lib), k ∈ N, 1 ≤ j < i} to verify the
schedulability of the new transaction set Ti.
Similar to Case 1, when determining the increment
amount of Di, we have the following theorem, which
helps to decrease iteration steps and hence improves
efﬁciency.
Theorem 9. When adding a new update transaction τi into
an EDF-schedulable transaction set Ti−1 and checking the
schedulability, if h(di,k, i) > di,k, one can start the next
iteration by setting Di = h(di,k, i).
Proof: Similar to reasoning in Theorem 7.
If Tk is schedulable for deadlines and periods found
for τk, we repeat the same process for τk+1. Finally, if all
the remaining transactions τi (k < i ≤ n) can pass the
schedulability test with a pair of deadline and period,
it means we have obtained a feasible solution to the
assignment problem. Otherwise, GEIIEDF declares failure,
which means it is unable to derive a solution for the
given transaction set.
Based on the two cases described above, we present
the detail of GEIIEDF in Algorithm 2. At ﬁrst, we invoke
MLDM to see whether one solution can be found. If
the answer is positive, we proceed to Case 1 to improve
the solution derived by MLDM , as shown in lines 5-
20. In this case, we ﬁrst skip those transactions with
Di =
∑i
j=1 Cj (lines 6, 7), since according to Lemma 1,
Algorithm 2 Phase II of GEEDF
1: Input: The same as in GEIEDF ;
2: Output: Deadlines {Di}ni=1 and periods {Ti}ni=1;
3: Invoke MLDM ;
4: if One solution can be derived then
5: for (i = 1; i ≤ n; i + +) do
6: if Di =
∑i
j=1 Cj then
7: continue;
8: end if
9: for (D′i = Di−1 + Ci;D
′
i ≤ Di; ) do
10: T ′i = Vi −D′i;
11: S = {di,k|di,k = kTj + Dj ∧ D′i ≤ di,k ≤ Di ∪
di,k = D′i, k ∈ N, 1 ≤ j ≤ n ∧ j 
= i};
12: if ∀di,k ∈ S, h′(di,k, n) ≤ di,k then
13: Di = D′i; Ti = Vi −Di;
14: break;
15: else
16: Find the ﬁrst h′(di,k, n) > di,k;
17: D′i = h
′(di,k, n);
18: end if
19: end for
20: end for
21: else
22: Find Tk−1 which is schedulable by MLDM ;
23: Repeat the steps in 5-20 (replace n with k − 1) to
adjust transaction deadlines and periods in Tk−1;
24: for (i = k; i ≤ n; i + +) do
25: for (Di = Di−1 + Ci;Di ≤ Vi − Ci; ) do
26: Ti = Vi −Di;
27: S = {di,k|di,k = kTj + Dj ∧ Di ≤ di,k ≤
min(Lia, L
i
b), k ∈ N, 1 ≤ j < i};
28: if ∀di,k ∈ S, h(di,k, i) ≤ di,k then
29: break;
30: else
31: Find the ﬁrst h(di,k, i) > di,k;
32: Di = h(di,k, i);
33: end if
34: end for
35: end for
36: end if
the deadline of these transactions cannot be decreased.
Then for each transaction τi, we set the initial value of
D′i to be Di−1 + Ci and check the scheduling points
in S according to Theorem 6. If for all the scheduling
points in S, h′(di,k, n) ≤ di,k holds, we thus obtain the
minimum deadline for τi and proceed to next transaction
τi+1. Otherwise, we increase the deadline according to
Theorem 7 (lines 16, 17) and come to next iteration. If
D′i is ﬁnally found to be equal to Di, it means that the
deadline of τi remains unchanged, and obviously, the
transaction set remains to be schedulable.
On the contrary, if no solution can be found byMLDM
directly, we proceed to the second case of Phase II,
as shown in lines 22-35. In this case, we ﬁrst employ
MLDM to derive a schedulable subset Tk−1. Then fol-
8
HSEDF 5 [31] via simulation experiments. Section 4.1 de-
scribes the simulation model and parameters. Section 4.2
discusses the experimental results.
4.1 Simulation Model and Assumptions
We have conducted quantitative experiments to com-
pare the performance of GEEDF with HH, MLEDF ,
MLDM , EMLDM and HSEDF . Among these ap-
proaches, MLEDF and HSEDF are EDF-based schemes,
whereas MLDM and EMLDM are DM-based ones.
HH can be either EDF-based or DM-based. While HH,
MLDM and MLEDF only address transaction set with
deadlines no larger than their corresponding periods,
EMLDM , HSEDF and GEEDF can handle arbitrary
deadlines which are less than, equal to or larger than
their corresponding periods. The update transaction
workloads produced by these algorithms, as well as
the execution times under these algorithms, have been
compared. It is demonstrated that GEEDF can result in a
signiﬁcantly reduced CPU workload which is lower than
all existing approaches, in a time-efﬁcient manner.
Table 5 shows a summary of the parameters and de-
fault settings used in our experiments. We use the same
baseline values for the parameters as [31], which are
originally from air trafﬁc control applications [11], [20],
for the following reasons: 1) To enable easy comparison
and continuity with the several previous studies that
have used similar models and parameter values; 2) our
objective is to evaluate the relative performance charac-
teristics of the approaches, not their absolute levels.
Two categories of parameters are deﬁned: system and
update transaction. For system conﬁgurations, a single
CPU, main memory based RTDBS is considered. The
number of real-time data objects NT ranges from 50 to
300 to generate different workloads in the system. The
validity interval length Vi of each real-time data object
is assumed to be uniformly distributed in [4000, 8000].
For update transactions, it is assumed that each update
transaction updates one data object, and the execution
time of each transaction is uniformly distributed in
[5, 15]. Under the default setting, Phase I can cover all
the cases. In order to show the performance of Phase II
of GEEDF , we vary the ranges of validity interval length
and execution time to [2000, 14000] and [8, 18], respec-
tively, to produce those cases that can only be scheduled
by Phase II. Moreover, in order to produce those cases
that can show signiﬁcant workload-difference between
EDF-based and DM-based schemes, we also change the
ranges of validity interval length and execution time to
[4000, 16000] and [10, 20], respectively. It is noteworthy
that here by varying execution times and validity inter-
val lengths, we just want to investigate the scalability
of our approach in terms of the workload caused by
the update transactions. Besides the update transactions,
the system also runs other tasks (user or triggered
5. Since OSEDF does not scale well with problem size, mentioned
as in [31], we do not consider it in our experiments.
TABLE 5: Experimental parameters and settings
Para. Class Parameters Meaning Value
NCPU No. of CPU 1
System NT No. of data objects [50,300]
Vi(ms) Validity interval of xi [4000,8000]
Update Ci(ms) Time for updating xi [5,15]
Transactions Trans.length No. of data to update 1
transactions), hence it must properly control the update
workload.
The proposed algorithms are all implemented in C++,
while the knapsack problem in HSEDF is solved by
Matlab. For each point plotted in the ﬁgure, the simu-
lations continued until a conﬁdence interval of 95% with
half-width of less than 5% about the mean was achieved.
4.2 Experimental Results
4.2.1 Comparison of CPU Workloads
The CPU workloads of update transactions produced by
HH,MLEDF ,MLDM , EMLDM ,HSEDF and GEEDF are
quantitatively compared. The density factor (denoted by
DF), which provides a lower bound of the workload,
is also plotted. Three sets of experiments with different
parameter settings have been conducted. In the ﬁrst set,
update transactions are generated randomly according to
the parameter settings in Table 5. The resulting processor
workloads from the six schemes are depicted in Fig. 1, in
which the x-axis denotes the number of update transac-
tions and the y-axis denotes the resulted CPU workloads.
It can be seen that GEEDF consistently outperforms
the three EDF-based schemes, i.e., HH, MLEDF and
HSEDF , as shown in Fig. 1. With the growth of NT ,
the discrepancy between HH, MLEDF and HSEDF with
GEEDF increases. When NT grows up to 300, the per-
formance improvement of GEEDF over the other three
existing EDF-based approaches increases to 37%, 34%
and 8%, respectively. Given the small execution time
and relatively large validity interval length in the default
setting, GEEDF can obtain a solution in Phase I while NT
varies from 50 to 300.
In the second set of experiments, we vary the range
of validity interval length of xi to [2000, 14000]. Other
parameters remain the same as in Table 5. Fig. 2 presents
the performance of GEEDF as compared with the other
ﬁve schemes. It can be observed that, similar to Fig. 1,
GEEDF consistently outperforms the other three EDF-
based algorithms. When NT ≥ 250, GEEDF fails to
derive a solution in Phase I, but can derive a solution
in Phase II. This is because when NT exceeds 250, the
sum of all transactions’ execution times can be larger
than the minimal period and therefore Phase I cannot
derive a solution. But since MLDM can still derive one,
Phase II is also able to derive a solution when NT varies
from 250 to 300 in Fig. 2.
Fig. 3 presents the result of the third experiment set,
in which the range of validity interval remains to be
[2000, 14000] but execution time varies uniformly be-
tween 8 and 18ms, while other parameters remain the
10
TABLE 6: Execution time comparison
Execution time (s)# of GEEDFTrans. HH MLEDF MLDM EMLDM HSEDF I II
50 < 0.01 < 0.01 < 0.01 0.016 74.53 < 0.01 —
100 < 0.01 < 0.01 < 0.01 0.016 762.53 < 0.01 —
150 < 0.01 < 0.01 < 0.01 0.046 2284.98 < 0.01 —
200 < 0.01 < 0.01 < 0.01 0.046 5383.07 < 0.01 0.016
250 < 0.01 < 0.01 < 0.01 0.075 11943.45 < 0.01 0.031
300 < 0.01 < 0.01 < 0.01 0.091 18726.43 < 0.01 0.062
is so tiny that they are hard to be distinguished.
As can be seen from Fig. 4, 5 and 6, GEEDF consis-
tently outperforms EMLDM on the resulted workload
among all the three experiment settings. With the growth
of the number of the transactions (NT ), the gap between
them is also increasing. Moreover, when NT exceeding
a certain number (different in each setting), EMLDM
eventually fails to derive a solution, while GEEDF can
still get one. These experiment results conﬁrmed our
analysis in Section 3.2, i.e., EDF yields better workload
and feasibility performance than DM with respect to
temporal consistency scheduling.
4.2.2 Comparison of Execution Times
The execution times of the six algorithms are shown in
Table 6. It can be observed that Half-Half and MLEDF
are efﬁcient to derive their solutions. With the growth
of transaction set size, the execution times of these three
approaches are consistently less than 0.01s. The reason
is that Half-Half and MLEDF are linear-time algorithms.
MLDM has a pseudo-polynomial time complexity in
that it requires to solve an iterative equation when
determining deadline for each transaction, but it also
runs quickly (as can be observed, the computation time
is consistently less than 0.01s), due to that it only takes
O (Vmax2 · n2) time to derive a solution. EMLDM also
has pseudo-polynomial time complexity since it requires
to determine a transaction’s deadline by ﬁnding out
the longest response time which occurs during a level-
i busy period, but it also runs quickly due to that the
number of releases that need be checked is bounded by
the validity interval length. Similar to EMLDM , GEEDF
has a pseudo-polynomial time complexity, but its actual
execution time is determined by the transaction set size.
When a solution can be found in Phase I, GEEDF can run
in linear time, while it takes slightly longer to obtain a
solution by Phase II, as shown in Table 6. Nevertheless,
it can ﬁnish its execution in a few milliseconds due to
the small overhead in its schedulability test.
To illustrate the performance of Theorems 7 and 9
on reducing the overhead of schedulability test, we also
conduct the iteration steps comparison between GEEDF
and the one-tick increment scheme, as shown in Fig. 7.
In this set of experiment, the range of validity interval
length of xi is set to [2000, 14000], while the execution
time of update transactions varies uniformly between 5
and 18ms. For each point plotted, we have conducted
1000 runs and take the average. It can be observed
that GEEDF takes signiﬁcantly fewer iterations than the
200 220 240 260 280 300 320 340 360 380
0
400
800
1200
1600
2000
Number of Transactions
It
er
at
io
n
S
te
p
s
GEEDF
One-tick increment
Fig. 7: Iteration steps comparison
one-tick increment scheme. With the growing number
of transactions, the gap between these two schemes
becomes larger. This is because when NT is small, most
of the transactions can be skipped without checking due
to Di =
∑i
j=1 Cj in both approaches. But with NT
increasing, a signiﬁcantly large number of iterations are
required to be checked in the one-tick increment scheme.
Therefore, GEEDF is efﬁcient when transaction set size
scales to 300.
Compared with the other ﬁve schemes, HSEDF takes
signiﬁcantly longer time to obtain a solution, and the
execution time increases exponentially when the number
of transactions scales up. When NT = 50, the execution
time of HSEDF is about one minute. When NT increases
to 300, its execution time increases to almost 5.2 hours.
HSEDF takes much longer time to obtain a solution
because it involves solving the 0-1 knapsack problem
iteratively.
In summary, we revealed the following three observa-
tions from our experimental results.
1) GEEDF and HSEDF have better schedulability than
other approaches (all DM-based ones, and MLEDF ),
which fail to derive a solution in some settings.
2) GEEDF consistently outperforms HSEDF in terms of
the resulted processor workload in the whole range
of parameter setting.
3) The execution time of HSEDF increases exponentially
when the number of temporal data objects scales up,
which makes it less practical for large applications. In
contrast, GEEDF can derive a solution more efﬁciently,
which makes it more attractive to real applications,
e.g., air trafﬁc control, stock trading, and vehicular
systems, etc.
There has been a lot of work on RTDBSs for maintaining
real-time data freshness [6], [8], [13]–[16], [18], [19], [23],
[24], [26], [33]. [26] studies the performance of two well
known concurrency control algorithms, two-phase lock-
ing and optimistic, in maintaining temporal consistency
of shared data in a hard real-time systems. [18] inves-
tigates real-time data-semantics and proposes a class
of real-time access protocol called SSP (Similarity Stack
V.    RELATED WORK
12
ACKNOWLEDGMENTS
Research supported in part by the National Science
Foundation of China [Award No. 60873030], the Re-
search Fund for the Doctoral Program of the Ministry
of Education of China [Award No. 20090142110023], and
a grant from the Research Grants Council of the Hong
Kong Special Administrative Region, China [Project No.
CityU 115407]. This work was partially done while Jian-
jun Li was at City University of Hong Kong.
REFERENCES
[1] P. Balbastre, I. Ripoll, and A. Crespo. Minimum deadline calcu-
lation for periodic real-time tasks in dynamic priority systems.
IEEE Transactions on Computers, 57(1):96, 2008.
[2] S. Baruah, L. Rosier, and R. Howell. Algorithms and complexity
concerning the preemptive scheduling of periodic, real-time tasks
on one processor. Real-Time Systems, 2(4):301–324, 1990.
[3] A. Burns and R. Davis. Choosing task periods to minimise system
utilisation in time triggered systems. Information Processing Letters,
58(5):223–229, 1996.
[4] G. Buttazzo. Hard Real-Time Computing Systems: Predictable
Scheduling Algorithms and Applications. Springer, 2005.
[5] T. Chantem, X. Wang, M. Lemmon, and X. Hu. Period and
Deadline Selection for Schedulability in Real-Time Systems. In
Proc. of ECRTS, pages 168–177, 2008.
[6] R. Gerber, S. Hong, and M. Saksena. Guaranteeing end-to-end
timing constraints by calibrating intermediate processes. In Proc.
of IEEE Real-Time Systems Symposium, pages 192–203, 1994.
[7] T. Gustafsson and J. Hansson. Data management in real-time
systems: a case of on-demand updates in vehicle control systems.
In Proc. of RTAS, pages 182–191, 2004.
[8] T. Gustafsson and J. Hansson. Dynamic on-demand updating of
data in real-time database systems. In Proc. of ACM symposium on
Applied Computing, pages 846–853. New York, USA, 2004.
[9] S. Han, D. Chen, M. Xiong, and A. Mok. A Schedulability Analysis
of Deferrable Scheduling Using Patterns. In Proc. of ECRTS, pages
47–56, 2008.
[10] S. Han, D. Chen, M. Xiong, and A. Mok. Online Scheduling
Switch for Maintaining Data Freshness in Flexible Real-Time
Systems. In Proc. of IEEE RTSS, pages 115–124, 2009.
[11] S. Ho, T. Kuo, and A. Mok. Similarity-based load adjustment for
real-time data-intensive applications. In Proc. of IEEE Real-Time
Systems Symposium, pages 144–154, 1997.
[12] H. Hoang, G. Buttazzo, M. Jonsson, and S. Karlsson. Computing
the minimum edf feasible deadline in periodic systems. In Proc.
of RTCSA, pages 125–134, 2006.
[13] A. Jha, M. Xiong, and K. Ramamritham. Mutual Consistency
in Real-Time Databases. In Proc. of IEEE Real-Time Systems
Symposium, pages 335–343, 2006.
[14] K. Kang, S. Son, J. Stankovic, and T. Abdelzaher. A QoS-Sensitive
Approach for Timeliness and Freshness Guarantees in Real-Time
Databases. In Proc. of ECRTS, 2002.
[15] K. Kang, Y. Zhou, and J. Oh. Estimating and Enhancing Real-
Time Data Service Delays: Control Theoretic Approaches. IEEE
Transactions on Knowledge and Data Engineering, 57(2), 2009.
[16] Y. Kim and S. Son. Predictability and consistency in real-time
database systems. Advances in real-time systems, pages 509–531,
1993.
[17] T. Kuo and A. Mok. Load Adjustment in Adaptive Real-Time
Systems. In Proc. of IEEE RTSS, page 160, 1991.
[18] T. Kuo and A. Mok. Real-Time Data Semantics and Similarity-
Based Concurrency Control. IEEE Transactions on Computers, pages
1241–1254, 2000.
[19] K. Lam, M. Xiong, B. Liang, and Y. Guo. Statistical Quality of
Service Guarantee for Temporal Consistency of Real-Time Data
Objects. In Proc. of IEEE Real-Time Systems Symposium, 2004.
[20] D. Locke. Real-Time Databases: Real-World Requirements. Kluwer
International Series In Engineering and Computer Science, pages 83–
92, 1997.
[21] L. Lundberg. Utilization based schedulability bounds for age
constraint process sets in real-time systems. Real-Time Systems,
23(3):273–295, 2002.
[22] K. Ramamritham. Real-time databases. Distributed and Parallel
Databases, 1(2):199–226, 1993.
[23] K. Ramamritham. Where Do Time Constraints Come From?
Where Do They Go? Journal of Database Management, 7:4–11, 1996.
[24] K. Ramamritham, S. Son, and L. Dipippo. Real-time databases
and data services. Real-Time Systems, 28(2):179–215, 2004.
[25] C. Shih and J. Liu. State-dependent deadline scheduling. In Proc.
of IEEE Real-Time Systems Symposium, pages 3–14, 2002.
[26] X. Song and J. Liu. Maintaining temporal consistency: pessimistic
vs. optimistic concurrency control. IEEE Transactions on Knowledge
and Data Engineering, 7(5):786–796, 1995.
[27] M. Spuri. Analysis of deadline scheduled real-time systems.
Technical Report 2772, INRIA, 1996.
[28] S. Vestal. Real-time sampled signal ﬂows through asynchronous
distributed systems. In Proc. of IEEE RTAS, pages 170–179, 2005.
[29] M. Xiong, S. Han, K. Lam, and D. Chen. Deferrable scheduling
for maintaining real-time data freshness: algorithms, analysis, and
results. IEEE Transactions on Computers, pages 952–964, 2008.
[30] M. Xiong and K. Ramamritham. Deriving Deadlines and Periods
for Real-Time Update Transactions. IEEE Transactions on Comput-
ers, pages 567–583, 2004.
[31] M. Xiong, Q. Wang, and K. Ramamritham. On earliest deadline
ﬁrst scheduling for temporal consistency maintenance. Real-Time
Systems, 40(2):208–237, 2008.
[32] F. Zhang and A. Burns. Schedulability analysis for real-time
systems with EDF scheduling. IEEE Transactions on Computers,
58(9):1250–1258, 2009.
[33] Y. Zhou and K. Kang. Deadline Assignment and Tardiness Control
for Real-Time Data Services. In Proc. of ECRTS, 2010.
14
 2 
的記憶體（例如，暫存區），還是控制硬體的記憶體（如高速緩存），皆有其優缺點，如多媒
體領域適用於控制軟體的記憶體模式，而資料庫工作就適用於高速緩存。因此，有效率的記
憶體管理是非常重要的，它影響了系統的功率消耗和處理能力。傳統的階層式記憶體架構是
由晶片上 SRAM為基礎的高速緩存所組成，然而，非揮發性記憶體（NVMS）和混合臨界系
統（ mixed-criticality systems）的出現，使晶片記憶體可以是混合架構，不只是在類型上（高
速緩存和暫存器），也可以是在技術上（SRAM和 NVM）。本文調查了多核心平台之記憶體
系統的技術領域，並提出了多種策略，能在多核心領域上有效管理控制軟體的記憶體，同時
也解決了設計人員面臨部署記憶體系統的各種挑戰，像是共享的記憶體資源和子系統的變化
等。 
    此次會議共有 39篇 regular paper報告，我對其中三篇印象最深刻. 第一篇是“Partitioned 
Scheduling of Implicit-deadline Sporadic Task Systems under Multiple Resource Constraints”, 由
北卡大學 Sanjoy Baruah教授以及他的學生 Bipasa Chattopadhyay執筆。他們主要的論點是在
許多的多處理器平台,每個處理器通常都有幾項有限的資源,如運算容量,本地記憶體,以及網
路頻寬等. 為了將任務工作集有效的切割分派到這樣的平台上,切割算法必須將所有的資源
限制納入考量. 他們在論文中提出並評估一個這樣的演算法,用來將一組隱含 deadline的
sporadic任務分組到多處理器平台。 
    另一篇讓我印象深刻的論文是“An Optimal Real-Time Voltage and Frequency Scaling for 
Uniform Multiprocessors”, 由 Gabriel Moreno與 Dionisio de Niz兩位學者撰寫. 這篇論文強調
對於以電池為動力來源或需要散熱以維持運作的即時系統,電力消耗是一個日益受重視的議
題. 今天,大多數的處理器都可以讓軟體來調控其作業頻率與電壓,以減少其電力消耗. 對於
即時系統而言,調節頻率需要考慮確保任務依然能在 deadline之前完成.  在本篇論文中,作者
針對uniform多處理器即時系統提出稱為Growing Minimum Frequency的算法. 該算法能以多
項式時間執行併計算出最佳的電壓與頻率,因而達致較過去算法明顯較佳的電力效率。 
    第三篇我想分享的文章是“MinMax: A Sampling Interval Control Algorithm for Process 
Control Systems”, 由著名即時系統學者 Al Mok等人執筆. 他們首先提到流程控制系統之傳
統取樣方法是基於週期式任務模式. 這是因為控制器是以嚴格週期方式執行. 感測器取樣流
程資料,然後經由通訊系統如 field bus,將資料週期送給適當的控制器. 然而因為 field bus是由
許多的感測器共享使用, 造成取樣與控制活動間的延遲. 為了減少此延遲, 一般會採用較高
的取樣頻率,因而造成無謂的能源浪費. 作者在此論文提出一種取樣間隔控制算法來解決上
述問題,並且以模擬實驗驗證其算法之優越性。 
二、與會心得 
嵌入式與即時運算技術是當今許多應用系統背後的關鍵，各國莫不磨拳擦掌競相投入。然
而此次會議 39篇 regular論文,僅本人之論文是由台灣學者為主要作者之一. 反觀大陸學者之
論文幾乎占了一大部分的議程,這在10年前是看不到的,可以看出大陸在此重要領域崛起之快
速. 台灣學者實在需要急起直追,否則將來關鍵技術都需要仰賴外部輸入。 
三、發表論文全文或摘要 
 
To verify the feasibility of real-time task sets on homogeneous multiprocessor systems, Lopez et al. 
derived the utilization bound based on Best Fit Decreasing allocation algorithm and 
Rate-Monotonic scheduling, which coincides with the maximum achievable multiprocessor 
國科會補助計畫衍生研發成果推廣資料表
日期:2013/01/22
國科會補助計畫
計畫名稱: 採用EDF排程之即時異動其截止時間與週期選定問題之研究
計畫主持人: 徐立群
計畫編號: 100-2221-E-006-159- 學門領域: 計算機結構與計算機系統
無研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
本計畫部分成果已經發表國際頂尖期刊 IEEE Transactions on Computers 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
