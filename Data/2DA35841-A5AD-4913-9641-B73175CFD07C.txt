 I
中英文摘要 
本整合計畫主要目標是開發適用於農業之無線行動感測網路應用系統。在實務方面，
針對農業之相關應用與需求技術，開發實際應用系統。在理論方面，深度探討相關具潛力
之理論性研究議題。本整合計畫可分為三個子計畫，目標在整合無線感測網路、行動感測
器、資料處理、資料探勘及掃瞄統計等技術，開發一套完整且適用於農業之無線行動感測
網路系統。 
 
子計畫一在三年中，有三個主要的目標： (1) 開發無線感測網路之省電通訊協定︰主
要針對任意佈建的無線感測網路，設計一套省電通訊協定，使得感測器能有效涵蓋整個農
場/田野，以便完整收集環境資訊； (2) 無線感測網路之有效佈建︰主要致力於設計有效佈
建感測器於農場中之方案，利用最少數量的感測器，達到確保網路覆蓋性和連結性； (3) 開
發移動式感測器之行動管理方案︰設計移動式感測器之派遣策略和移動路線規劃，使得移
動式感測器之電量消耗最小化和感測器之使用時間能被有效延長。 
 
子計劃二的主要研究目標在研發與設計一確保資料正確，節省電源之無線感測網路資
料處理。在無線感測網路中，感測器可感測環境數值，必要時將感測數值暫時的存放在感
測器之有限儲存空間，提供使用者查詢。因此，無線感測網路可視為一大型的分散式資料
庫系統。然因感測器長年暴露於外在的環境，再加上感測器本身之硬體資源限制，使得在
無線感測網路下有限的資源內，提供低耗電，精準正確之資料、有效率資料查詢處理(data 
management)，已成為日漸重要的研究課題。在本子計畫中，主要的研究課題包含：(1)在無
線感測網路中提供確保感測資料精確性之機制：為確保感測資料之正確性，我們將依照感
測器過去感測資料之模式與感測器間實際距離，建構建構感測器信任關係網路，透過信任
關係，將可過濾錯誤的感測讀數；(2)無線感測網路有效率省電之資料收集查詢處理：就省
電之資料查詢處理上，資料的查詢具有重複性，我們將透過彼此資料查詢共享，對資料查
詢進行最佳化，以節省電源耗損。此外，感測器所感測資料因環境因素導致有相類似之感
測數值，因此，資料查詢時可以透過選定某些代表感測器來回報感測資料，進而節省能源
耗損; (3)無線感測網路中進階資料查詢機制及 in-network 資料探勘機制：在確保資料正確
性及省電的前提下，我們將進一步開發KNN查詢機制以及利用探勘資料中的群體移動行為
來發展物體追縱環境中機制。 
 
子計畫三的目的是在於預測大量隨機佈建的無線感測網路的系統特性，主要是針對傳
輸半徑對網路拓樸的影響進行機率上的分析，以期對戶外無線感測網路有更深入的了解。
本子計畫著重在網路拓樸上的分析，討論的議題可分為兩大類：(1)節點稀少區域對網路拓
樸的影響；(2)節點密集區域對網路拓樸的影響。在三年中，我們依序對相關問題進行有系
統的分析與研究。 
 
關鍵字：無線感測網路、網路佈建、移動式感測器、省電通訊協定、網路覆蓋、網路連結、
近似資料收集, 空間及資料關聯性, 物體追縱, 群聚分析, 查詢處理, KNN, 合併資料處理, 
錯誤偵測、戶外應用、掃描統計、幾何式路徑找尋，網路拓樸，臨界傳輸半徑，臨界感測半徑。 
 1
目錄 
一、前言.......................................................................................................................................... 1 
二、研究目的.................................................................................................................................. 3 
三、文獻探討.................................................................................................................................. 4 
四、研究方法.................................................................................................................................. 6 
z 無線感測網路之省電通訊協定︰ ........................................ 6 
z 無線感測網路之佈建︰ ................................................ 7 
z 移動式感測器之行動管理︰ ............................................ 8 
z 在無線感測網路中提供確保感測資料精確性之機制： ...................... 9 
z 無線感測網路有效率省電之資料收集查詢處理 ........................... 11 
z 無線感測網路中進階查詢機制及in-network 資料探勘機制 ................ 13 
z 最大掃描統計：...................................................... 17 
z 最小掃描統計：...................................................... 17 
z 圖特性的漸近值︰ ................................................... 18 
z 頻道分配問題........................................................ 19 
z 無線感測器網路的覆蓋 ............................................... 20 
z 最小連接數及連通性 ................................................. 20 
z 幾何結構中最長邊問題 ............................................... 21 
z 無局部最小化問題的幾何貪婪式遶境 ................................... 21 
z 無線隨意網路的演化 ................................................. 22 
五、結果與討論............................................................................................................................ 22 
六、參考文獻................................................................................................................................ 25 
七、出席國際學術會議心得報告及發表之論文各一份............................................................ 31 
八、附錄︰論文全文.................................................................................................................... 31 
¾ 附 錄 一 ： C.-F. Huang, L.-C. Lo, Y.-C. Tseng, and W.-T. Chen “Decentralized 
Energy-Conserving and Coverage-Preserving Protocols for Wireless Sensor Networks”, 
ACM Trans. on Sensor Networks, Vol. 2, No. 2, 2006, pp. 182-187. 
¾ 附錄二：Y.-C. Wang, C.-C. Hu, and Y.-C. Tseng, “Efficient Placement and Dispatch of 
Sensors in a Wireless Sensor Network”, IEEE Trans. on Mobile Computing, Vol. 7, No. 2, 
Feb. 2008, pp. 262-274. (SCI) 
¾ 附錄三：You-Chiun Wang, Fang-Jing Wu, and Yu-Chee Tseng, “Mobility Management 
Algorithms and Applications for Mobile Sensor Networks”,  Wireless Communications and 
Mobile Computing (WCMC), (to appear) 
¾ 附錄四：W.-C. Peng , T.-Y. Fu and W.-C. Lee, “Parallelizing Itinerary-based KNN Query 
Processing in Wireless Sensor Networks”, IEEE Trans. on Knowledge and Data Engineering 
(to appear). 
¾ 附 錄 五 ： C.-C. Hung and W.-C. Peng, “Clustering Object Moving Patterns for 
Prediction-based Object Tracking Sensor Networks”, Proceedings of the ACM 18th 
International Conference on Information and Knowledge Management (CIKM), Hong Kong, 
 3
¾ 附錄十七：出席國際學術會議SENSORCOMM2009發表之論文全文, Fang-Jing Wu, 
Hsiu-Chi Hsu, Yu-Chee Tseng, and Chi-Fu Huang, “Non-Location-Based Mobile Sensor 
Relocation in a Hybrid Static-Mobile Wireless Sensor Network”, SENSORCOMM2009 
 
的議題方面，針對任意隨機佈建的無線感測網路，我們開發一套分散式省電通協定，達到
網路覆蓋(coverage)與網路連結性(connectivity)之目的。在感測器佈建的議題上，我們設計
一套佈建網路的策略，最少的靜態感測器來達到監測整個農場所需之網路覆蓋和網路連結
性，以降低佈建網路之成本。最後，針對移動式感測器的行動管理，我們研究行動管理方
案，用來降低移動式感測器耗電量，達到延長感測器之可用時間。透過子計畫一提供有效
建構無線感測網路，並將收集到的感測資料和網路狀況提供給子計畫二和子計畫三，分別
進行資料探勘處理、和分析預測網路特性。子計畫二在三年中，主要研究目標在研發與設
計一確保資料正確，節省電源之無線感測網路資料處理。首先，為確保感測資料之正確性，
我們將依照感測器過去感測資料之模式與感測器間實際距離，建構建構感測器信任關係網
路，透過信任關係，將可過濾錯誤的感測讀數。就省電之資料查詢處理上，資料的查詢具
有重複性，我們將透過彼此資料查詢共享，對資料查詢進行最佳化，以節省電源耗損。此
外，感測器所感測資料因環境因素導致有相類似之感測數值，因此，資料查詢時可以透過
選定某些代表感測器來回報感測資料，進而節省能源耗損。在確保資料正確性及省電的前
提下，我們將進一步開發 KNN 查詢機制以及利用探勘資料中的群體移動行為來發展物體追
縱環境中機制。透過子計畫二正確的資料收集以及有效率的資料查詢及探勘，可以將這些
資訊提供給子計畫一和子計畫三，加強網路建置及分析預測網路特性的有效性及正確性。
子計畫三在三年中，主要針對傳輸半徑對網路拓樸的影響，進行機率上的分析，以期對戶
外無線感測網路有更深入的了解。根據我們推得的最小掃描統計的漸進公式，對許多的網
路拓樸結構進行定量分析，這其中包含了：無線感測網路中的覆蓋問題、無線隨意網路中
的連通問題、幾何結構中的最長邊問題及地理遶徑協定的區域極小值問題。另外，根據我
們推得的最大掃描統計的漸進公式，我們對無線網路的最大連接數、最大完全子集、最小
著色數及最小頻道數等，進行定量化的分析。我們的結果，可以提供子計畫一及二在設定
傳輸半徑及感測半徑的理論基礎，同時從計畫一及二所獲得的資料，可提供未來修正系統
參數的依據。 
 
圖二、子計畫間交互關係說明圖。 
 2
 4
三、文獻探討 
    針對子計畫ㄧ，在三年中處理的三大議題︰(1) 開發無線感測網路之省電通訊協定，(2) 
無線感測網路之有效佈建方案，和(3) 開發移動式感測器和移動式感測器之行動管理，整理
了相關的文獻如下。在第一個議題方面，其文獻探討主要分析與討論網路覆蓋和網路連結
之特性。網路覆蓋(coverage)，網路覆蓋(coverage)被當成評估某區域被網路監控的程度和品
質。在我們過去的[1][2]研究中，網路覆蓋問題（coverage problem）可以決定在2D/3D 的
感測環境中，可以決定在感測區域中的任一點是否皆可被k個感測器覆蓋。在網路連結性
(connectivity)的相關議題中，主要探討感測器之間的通訊路徑品質。[3]提出的GAF protocol
和[4]中提出SPAN，關掉多餘的感測器來延長網路存活的時間。 [5][6][7]中透過調整感測器
的傳輸電量來達到網路拓撲結構的控制(topology control)。我們將結合過去的成果，同時考
慮網路覆蓋(coverage) 和網路連結性(connectivity) 問題， 提出一個分散式的通訊協定達到
同時確保網路覆蓋(coverage) 和網路連結性(connectivity)。在第二個議題方面，[8][9][10] 研
究中把感測器感測區域視為格點(grid points)，並討論如何放置感測器於這些格點上，以滿
某種程度的網路覆蓋需求。[11] 建議用移除多餘的感測器之策略來佈建，但此研究僅能處
理當rc(通訊半徑) = rs (感測半徑)的情形，且佈建的環境不能有障礙物存在。[12][13][14][15] 
研究中，假設初始佈建時會佈建多餘的感測器，因此這類的研究主要專注於解決如何讓網
路中的感測器輪流active來達到所需求的網路覆蓋程度。在第三個議題方面，在動態移動式
感測器的派遣方面，[16][17][18] 討論如何移動感測器來增加網路覆蓋程度，而[19][20] 主
要討論在格點的模型上，移動感測器如何由高密度的格點移動到低密度的格點。此外，在
我們過去的研究[21] 中，已經成功的開發移動式感測器。此外，利用 mobile sensor 進行
資料收集的在許多研究中被採用 [22][23][24]。文獻 [22] 分析利用 mobile sensor 傳遞資
料的最佳化上限。在文獻 [23] 中, 無線感測網路中，利用 mobile sensor 在可預測的移動
路線，可顯著減少通訊所花的電量。在文獻 [24] 中提到利用mobile sensor 連接佈建稀疏
的無線感測網路時，資料傳遞的延遲較久。利用 mobile sensor 在高度不連通的無線隨意網
路中處理 routing 問題在 [25][26][27] 被討論。 
 
子計畫二在三年中，主要針對(1)在無線感測網路中提供確保感測資料精確性之機制；
(2)無線感測網路有效率省電之資料收集查詢處理；(3)無線感測網路中進階查詢機制及
in-network 資料探勘機制。在第一個議題方面，其文獻主要是探討如何偵測所偵測到的讀
數是否為錯誤或是雜訊。在研究[30]中，使用機率的方式來解決此問題，該方法將整個感測
數值空間以一特定的數值分為事件與非事件兩類，因此錯誤的感測結果便可定義為：1.事
件中的感測器未感測到事件，或2.事件外的感測器感測到事件兩種情況。當某一感測器觀
察到週遭感測器的感測結果，該感測器便可依據周遭的感測結果與自己的感測結果計算出
自己感測值正確的機率，再以此機率的高低來過濾錯誤的讀數。在[31]中，作者套入統計的
模型，以標準差來訂義錯誤讀數，也就是說當某感測讀數與週遭感測值中位數之差，與平
均讀數中位數之差超過k 個標準差之外時，表示此讀數為錯誤的感測值。其意義表示該感
測值與其它感測值差異太大，而被視為錯誤的感測值。第二個議題中，Snapshot query 便利
用無線感測網路中相鄰感測節點之資料具有高度相關性的性質[32]，設計出利用叢集代表點
對隸屬於其下之感測節點進行預測，經由作者設計之演算法選舉出適合的叢集代表點，並
通的機率分佈收斂於 ( )cpe−−exp 。 k 連通的問題，則在[39]及[41]中被討論過，若 且1≥k
( )non lnln= ，令 n
)1-
πξ
lnln2(ln ξn
n
nknr ++= ，則在 ∞→nξ 的情況下， 幾乎可以確( )nrnG V
是 連通，反之如果1+k −∞→nξ ，網路幾乎可以確不是 1+k 連通。 
 
覆蓋是無線感測器網路的一個QoS指標。在[42]中，作者推導了對隨機佈建感測器網路可
以達到 覆蓋所須的一個充分條件及一個必要條件。在k [43]中，考慮 及0≥k ( )non lnln=ξ ，令
感測半徑
n
lnln)12(ln
π
ξn
n
nknr +++= ，根據[42]中所使用的技巧，作者證明在 ∞→nξ 的情
況下，網路幾乎可以確是 覆蓋，反之如果1+k −∞→nξ ，網路幾乎可以確不是 覆蓋。 1+k
 
四、研究方法 
本整合化在三年中，在子計畫一中，深度研究設計此農業無線感測網路應用系統面臨
的三大議題︰(1) 開發無線感測網路之省電通訊協定，(2) 無線感測網路之有效佈建方案，
和(3)移動式感測器之行動管理。子計畫二在三年中，主要針對(1)在無線感測網路中提供確
保感測資料精確性之機制；(2)無線感測網路有效率省電之資料收集查詢處理；(3)無線感測
網路中進階查詢機制及in-network 資料探勘機制。子計畫三在三年中，主要針對傳輸半徑
對網路拓樸的影響，進行機率上的分析，我們利用掃描統計的漸進公式，分析無線感測網
路中多種單調網路拓樸特性所對應的臨界半徑，以期對戶外無線感測網路有更深入的了
解。研究方法細節在下面的報告以及附錄中說明。 
無線感測網路之省電通訊協定︰ 
對任意佈建的無線感測網路，我們設計一套省電通訊協定，主要利用感測器的活動週期
(active period)和睡眠週期(sleep period)的排程，來達到延長網路存活的時間。對於任兩個感
測器的感測範圍的交叉點，有一個工作周期(working cycle)的時間排程。圖四為感測器的工
作周期(working cycle)結構圖，主要包含兩個階段(phase)：初始化階段(initialization phase)
和感測階段(sensing phase)。 
 
 6
 
圖五、切割感測區域示意圖 
第二階段，針對單一帶狀區域，我們沿著中線(bisector)佈建感測器，針對多重帶狀區域我
們先選擇第一個感測器的佈建位置(x, y)，並沿著帶狀區域依序佈建每ㄧ列的感測器，並於
列與另之間佈建一行(column)感測器來達到網路連結性之特性。此階段，每加入一個點，就
將下列表格ㄧ中六個接鄰位置排進預定佈建感測器的位置的序列中。對每一個預定佈建位
置，若此位置沒有障礙物且不是落在邊界，就將感測器置於此位置。依照次佈建策略完之
後，仍有部分邊界上位置和靠近障礙物位置沒有被覆蓋，因此，我們必須另外沿著多重帶
狀區域之邊界和障礙物邊界佈建感測器。針對此情形，我們討論兩種情形：當 sc rr 3< 時，
因為沒有被覆蓋部分的寬度不會超過 ，所以感測器之間採取每間隔 的距離來佈建；另
ㄧ種情形是當
cr cr
sc rr 3≥ 時，沒有被覆蓋部分的寬度不會超過 sr3 ，所以感測器採取每間隔
sr3 的距離來佈建。對於此網路佈建方案之詳細說明於附錄二中。 
 
表格ㄧ，佈建點的六個接鄰位置 
移動式感測器之行動管理︰ 
針對目前移動式無線感測網路路徑規畫之發展狀況，討論如何規劃最佳移動路徑，達到延
長網路存活時間之目的，並做出綜合性的比較。針對兩種資料移動式感測器路徑規畫方案: 
multihop和single-hop的資料收集，並實作一套系統進行測試與比較。(i) Multihop方式的資
料收集：主要利用靜態感測器之網路樹狀拓撲來規劃資料收集器的路徑。給定一個資料收
集器m和以資料收集端(sink)當root的資料遞送樹狀結構(routing tree) T＝(V,E)，其中V包含S
中所有靜態感測器和資料收集端(sink) B，且E包含所有樹狀結構的邊(tree edges)，參考文獻
[28]考慮幫資料收集器m規劃一條環狀的移動路徑來拜訪某一個子集合的感測器V’⊆V，使
 8
 圖七：多數決機制示意圖 
 
1. 計算 SensorRank： 
在我們的設計中，SeneorRank 必須滿足以下要求： 
1. 若一個 sensor 有很多相關讀數的鄰居，則這個 sensor 是可信的。並且在做決策時具有較
大的權重。 
2. 有很多可信的鄰居的 sensor 也是可信的。  
因此，符合以上兩個條件的sensor具有較高的SensorRank。為了計算SensorRank，我們可以
將Correlation Network視為一個Markov Chain。每一個sensor si視為一個state i， state i到state 
j的機率為則為si對sj的正規化後的信賴程度 
 
2. 利用 SensorRank 決定讀數的正誤 
TrustVoting 演算法是用來決定某一個 sensor 的 reading 是否為錯的演算法。其中分成兩
個步驟： a)Self-diagnosis Phase 及  b)Neighbor-diagnosis Phase。當一個 sensor 通過
Self-diagnosis Phase，他會直接將其讀數回報給 Sink。否則則會進入第二個 phase，請鄰居
來決定是否其讀數是正確的。而 TrustVoting 演算法是在網路中執行而不用將所有的讀數傳
回 Sink。 
 
Self-diagnosis Phase 
 當 sensor 被查詢時，每一個 sensor 均會做自我診斷其讀數是否正確。每一個 sensor 均
會保留目前的讀數以及上一個 Δt 前的讀數。我們比較這兩個 reading vector。若此兩個 vector
是相似的，則視其為正常。若發現兩個 vector 不相似，則有可能是 sensor 壞掉，或是真的
是發現事件。因此會進入下一個 phase，由鄰居的資訊來判斷是否該 sensor 之讀數為誤。 
 
Neighbor-diagnosis Phase 
 若一個sensor si傳送其讀數bi(t)給其鄰居sj，sj將會比較bi(t)和bj(t)並依照比較的結果給與
si投票。從鄰居的投票結果，si即可判斷其讀數是否正確。值得注意的是，一個擁有較高
(低)SensorRank的sensor在投票的過程中具有較大(小)的影響力。 
當一個sensor si傳送其讀數bi(t)給其鄰居sj時，sj會根據bi(t)和bj(t)的值計算其相似度的值，並
依照其SensorRank給與si投票的結果votej(i)。 
 待收集完所有的votej(i)後，si會依照鄰居間的相關性以及其votej(i)值來做最後的決定。
正如上述所說，較高的SensorRank會在投票中給與較大的影響力，而鄰居間的相關性越高
也會在投票中給與較大的影響力。並依此來判斷si之讀數是否正確。 
 10
圖九：(a)查詢樹間的圖形表示法，(b)Max-cut 問題 
第二部份：利用空間時間相關性進行資料收集 
這個主題中，我們利用感測器數值之間的空間以及資料相關性(spatial and data 
correlation)來進行感測網路上的近似資料收集(approximate data collection)。近似資料收集為
自收集感測器的資料可容許些許的誤差。另外，在感測器網路中，相近位置的感測器通常
會有類似的讀數，此為空間相關性(spatial correlation)。利用此特性，我們可以將具有資料
相關性(也就是讀數類似)及空間相關性的感測器分群，並從每一群中選取可以代表這一群讀
數的感測器(稱為代表點)。以圖十為例，黑色的感測器即為代表點。如此一來，只要代表點
回傳其讀數，sink 即可在能源消耗較少的情況下，推得所有網路中感測器的讀數。 
 
 
圖十：Data Coverage 示意圖 
 
在此研究中，我們引入了資料覆蓋(Data Coverage)的概念來完成選取代表點的工作。一
個感測器si的Data Coverage意指自感測器si可到達的感測器且途中的感測器的數值和si之差
不大於給定之門檻值。以圖十為例，每一個感測器上方之數值表示”讀數/電量”。令門檻值
為 0.5，則A的data coverage為：A、B、E。針對這個主題，我們提出演算法DCglobal來決定
網路中的代表點，且這些代表點同時具有可以代表較多感測器以及有較多的能源。因此，
整個網路的運作時間(lifetime)就可以有效的延長。 
DCGlobal 是基於 Set-covering 的概念再同時考慮剩餘的電量來選取代表點。首先，在
收集一段時間的資料後，我們可以推得每一個感測器的 data coverage，亦可得知每一個感
測器目前的電量。接著，我們優先從未被代表的點中電量最多者，選出 data coverage 大的
感測器做為代表點。若整個網路的點皆可被代表，則結束。若尚有點不能被代表，則繼續
以此原則選取代表點。假設給定門檻值為 0.5，即可選出圖十的黑色點為代表點，而其灰色
的部份則為其 data coverage 的範圍。 
另外，為了能夠處理原本代表點的能源降低或是無法再代表同一群感測器的情形，我
們發展了相對應的 maintenance algorithm 來選擇較多能量而且能代替原本代表點的感測器
來替代之，以便維持有效率且節省能源的近似資料收集。詳情可見附錄。 
 
 12
 圖十二：PCIKNN 示意圖 
 
 
第二部份：利用群集移動行為做物體追蹤
 在此研究中，我們利用物體的群集移動行為(group mobility)設計物體追蹤機制。 
 
在物體追蹤的研究中，以預測為基礎的(prediction-based)預測機制被證實為較省能源。
在此種預測機制中，能源的節省程度取決於預測物體位置的準確度。我們提出了利用可以
用機率後置樹(Probabilistic Suffix Tree)來探勘出物體移動之行為。通常，感測器網路會建構
成階層式架構以達到有效率的管理。藉由在每一個階層的代表點(Cluster head)中儲存在該區
域移動物體的機率後置樹，代表點可以利用此樹來預測物體的行為，可使準確率提高而因
此可以達到省能源的目的。圖十三即為四個機率後置樹，其中在結點中代表著物體常經過
的感測器，而每一個節點均伴有一個機率表，代表著在經過某些感測器的序列後下一個路
段的機率為何。以T1為例，此物體常經過A、B、AB這三個感測器；並且若物體在感測器A
時，下一個所在的感測器為B 的機率為0.66。 
由於代表點亦為感測器，因此亦有儲存空間的限制。藉由觀察出有些物體常有群聚移
動的特性，我們可以藉由比較機率後置樹，將移動行為類似的物體分成數群，每一群物體
只需要存一棵機率後置樹即可。如此一來，可降低代表點儲存機率後置樹所需要的空間，
並且能維持預測的準確性。以圖十三為例，我們可以將T1和T4分為一群(因為他們常常通過
A、B、AB)，T2和T3分成為一群 (因為他們常常通過A、C、AC)。 
 為了達到此目的，我們的演算法分成三個步驟： 
步驟 1：計算機率後置樹間的相似度測量標準 
機率後置樹含有多種資訊，因此在設計時除了要反應出樹本身的結構之外，亦要考慮
每一個樹中的結點所出現的機率。我們先將樹中的每一個branch轉換成數個移動序列
及其出現的機率。藉由edit-distance的概念，我們可以算出將一個樹的移動序列轉成另
一個樹的移動序列需要的cost。如此一來便可以計算出樹間的相似度。 
步驟 2：將物體分群 
求出相似度之後，我們便可以將有彼此相似機率後置樹的物體分成同一群。 
  
 14
數。在圖十五中，上方曲線代表是 ( )βϕμ /11−+= ，而下方曲線則是代表是 。 ( )βϕμ /11−−=
 
圖十五、上方曲線是 ，下方曲線是( βϕμ /11−= )+ ( )βϕμ /11−= − ，而 1=μ 則是漸近線。 
令  
( ) ( )ββϕβ /11−+=U  for ( ),,0 ∞∈β  
及 
( ) ( ) ( ]⎩⎨
⎧
∈
>=
−
−
.1,0 if ,0
;1 if ,/11
β
βββϕβL . 
兩者 ( )βU 及 ( )βL 皆是嚴格遞增函數，如圖十六所示。 
 
圖十六、上方曲線是 ( )βU ，下方曲線是 ( )βL 。 
在下文中，D為一單位面積圓或單位面積正方形，代表網路的分布區域； 及 分別代表在D
上平均點密度為n的Poisson點集及均勻分佈點集，而 則可代表 或 。 是計數函數，
nP nX
nV nP nX ( )•# •  
是面積函數， ( ) 6.11 2 3320 = ≈− πβ 是一常數。 代表一系列的凸緊緻集合，如果存在常數nC β
及 使得對所有 皆滿足0c nnC C∈ ( )( ) noCn n ln1+= β 及 ( ) nn CcCdiam 0≤ ，則我們稱 是正規
的。 
nC
 16
                           [ ] 10),(Pr 2 →=nnm CVS . 
若考慮 的成員皆是圓，不失一般性，我們可以假設所有的圓是以原點為圓心，令
，則 
                            
nC
( ) ( )( )aCVV,CS
am
+∩= ∈ #min3 D
( ) ( )nnmCnnm ,CS, nn VVS 33 maxCC ∈= 。 
我們推得下列定理。 
Theorem 4. For the asymptotics of ( )nnm ,CVS 3 , we have  
(1) If  is a unit-area square, it is almost sure that 
                
D
1
4
1),(
2
1min~
ln
),(Pr 3 →⎥⎦
⎤⎢⎣
⎡ ⎟⎠
⎞⎜⎝
⎛ ββLVS
n
nnm C . 
(2) If  is a unit-area disk, it is almost sure that 
                   
D
1)(
2
1~
ln
),(
Pr 3 →⎥⎦
⎤⎢⎣
⎡ βLVS
n
nnm C . 
(3) For any 1<β , we almost surely have  
                               [ ] 10),(Pr 3 →=nnm CVS . 
圖特性的漸近值︰ 
對於圖的最大完全子圖的大小 ( )Gω 及最大節點連接數 ( )GΔ ，我們使用最大掃描統計可得到下
列定理。 
Theorem 5. Let  for some constant ( )( ) norn n ln12 += βπ 0>β . Then,  
(1) 1)
4
(~
ln
))((ω
Pr →⎥⎦
⎤⎢⎣
⎡ β
U
V
n
G nrn . 
(2) 1)(~
ln
))((
Pr →⎥⎦
⎤⎢⎣
⎡Δ βUV
n
G nrn . 
 
根據這個定理，對於圖的最小著色數 ( )Gχ ，我們有如下的一個推論。 
Corollary 1. 14
))((ω
))((
1Pr →
⎥⎥⎦
⎤
⎢⎢⎣
⎡ ≤≤
ν
ν
nr
nr
n
n
G
Gχ
. 
 
 18
(1) Smallest-last ordering (SL)：節點是以反向的順序被選擇。每次，選擇保持在剩餘
子圖中具有最小連接數的節點，然後再將其從子圖中去除。而這節點順序具有最
小的 inductivity，即 ( ) ( )GGind SL *δ= 。 
(2) Distance-increasing ordering (DI)：按照每個節點到某一固定點的歐幾里德的距離，
由小到大來作節點的排序。 
(3) Lexicographic ordering (LG)：按照節點座標的字母順序來排序。 
(4) Radius-decreasing ordering (RD)：根據節點的傳輸半徑的大小，由大到小來作排
序，如果數個節點擁有相同的傳輸半徑，則這幾個節點間可任意排序。 
關於 First-Fit 演算法，我們有如下的定理。 
Theorem 7. It is asymptotically almost sure that the approximation ratio of any FIRST-FIT 
algorithm is at most 4. Furthermore, it is asymptotically almost sure that the approximation 
ratios of FIRST-FIT in SL, DI, LG are at most 2. Furthermore, the chromatic number is a.a.s. 
at most twice of the clique number. 
無線感測器網路的覆蓋 
最小掃描統計在無線感測器網路的研究中，有各式各樣的應用。 例如，無線感測器網路的
覆蓋可以利用最小掃描統計來近似。如果說感測器系統可以 覆蓋一個區域，那表示在部k
署區域內的每個點，皆可被至少 個感測器監測，這裡 是一個應用相關的 QoS 要求。舉k k
例來說，在運用三點定位方法的追蹤定位系統中，至少三個傳感器是需要用來決定一個對
象的位置地點。因此，3 覆蓋是系統的一個必要條件。如果V 表示感測器集合，我們有 
                         
( ){ }( )
( )( )nnmx
x
rB
xBuVu
uBxVu
,,
:#min
:#mincoverage
3 o
D
D
VS=
∈∈= ( ){ }( )r
r
,
,= ∈ ∈
∈
∈
 
因此，在這個模型之下，覆蓋和最小掃描統計具有相同的意涵。 
最小連接數及連通性 
圖G 的最小連接數以 ( )Gδ 來代表，示是在所有節點的連接數的最極小值。在 r-disk 圖中，節點
u )的連接數是在 中的節點數減 1，所以我們可以得知 ( ruB ,
                         
( )( ) ( )
( )( )
( )( ) 1,,
1,#min
degmin
3 −≥
−∩=
=
∈
∈
nnm
nnu
unr
rB
ruB
uG
n
n
n
oVS
V
V
V
V
δ
 
所以我們可得下列定理。 
Theorem 8. Assume ( )( ) norn n ln12 += βπ  for some constant 0>β . Then, we have  
                  
( )( ) ( )( ) 1
ln
,,~
ln
Pr 3 →⎥⎦
⎤⎢⎣
⎡
n
rB
n
G
nnmnrn oVSVδ . 
 20
部最小化問題的困擾，我們針對貪婪式前傳遶境及格狀遶境兩個演算法，計算出無局部最
小化問題的臨界傳輸半徑。 
貪婪式前傳遶境: 使用這個演算法的節點，在接收到封包後會將封包前傳給最接近封
包目的地的鄰居，由其接續傳送。但如果不存比自己還接近封包目的地的鄰居時，則該節
點會將封包丟棄，這種情況即稱為局部最小化問題，會造成遶境演算法可到達性的疑慮。
透過加大傳輸半徑，我們可以消除局部最小化，而可以消除局部最小化問題的最小傳輸半
徑即稱為貪婪式前傳遶境的臨界半徑，用 ( )VGFRρ 來表示節點集合V 所需的臨界半徑，我們
有如下的定理。 
Theorem 11. Let  for some constant ( )( ) norn n ln12 += βπ 0>β . Then,  
                     ( ) 111Prlim
ln
0
=
⎥⎥⎦
⎤
⎢⎢⎣
⎡ +≤<−
∞→ εβ
ρε
πnn
nGFR
n
P . 
格狀遶境: 在這個演算法中，平面會被切割成同等大小的正方形格子，封包將會被延
著相鄰的兩個格子依序傳至目的地節點所在的格子。因封包是在相鄰格子中傳送，如果下
個格子中没有節點可以接收封包，即形成局部最小化問題。透過調整格子大小及傳遞半徑
大子，我們可以避免局部最小化問題。若用 每個格子的邊長，我們有如下的結果。 nl
Theorem 12. Let ( )( )
n
noln
ln1+= β  for some 0>β  and nn lr 5= . If 1>β , the network 
is a.a.s. local-minimum-free. 
無線隨意網路的演化 
在同質無線網路中，選擇不同的傳輸半徑會產生不一樣的網路拓樸，所謂網路的演化
即是指隨著傳輸半徑由小調大的過程，網路拓樸相對應的變化。在之前的討論中，我們獲
得了各種的臨界傳遞半徑，如果將這些臨界值由小到大排列，我們可以觀察到一個演化的
進程。如果 Qβ 表示特性 Q 的臨界值，目前我們的結果共計有 1cov == ββcon 、
6.10 ≈== βββ GFRRNG 及 2=GGβ 。 
 
五、結果與討論 
無線感測網路應用於農業上，不但可以幫助農民種植作物上更為方便，且低佈建成本也可
進一步地促進無線感測網路的普及。 
    在子計畫ㄧ的於計畫執行的三年中，針對三個重要目標: (1) 開發無線感測網路之省電
通訊協定，(2) 無線感測網路之有效佈建方案，和(3) 開發移動式感測器之行動管理，進行
 22
 24
(to appear). 
¾ 附 錄 五 ： C.-C. Hung and W.-C. Peng, “Clustering Object Moving Patterns for 
Prediction-based Object Tracking Sensor Networks”, Proceedings of the ACM 18th 
International Conference on Information and Knowledge Management (CIKM), Hong Kong, 
Nov. 2-6, 2009. 
¾ 附錄六：C.-C. Hung, W.-C. Peng, York S.-H. Tsai and W.-C. Lee, “Exploiting Spatial and 
Data Correlations for Approximate Data Collection in Wireless Sensor Networks”, 
Proceedings of the second ACM International Workshop on Knowledge Discovery from 
Sensor Data (In conjunction with ACM SIGKDD), Las Vegas, USA, Aug. 24. 2008. 
¾ 附錄七：T.-Y. Fuo, W.-C. Peng and W.-C. Lee, “Optimizing Parallel Itineraries for KNN 
Query Processing in Wireless Sensor Networks”, Proceedings of the ACM 16th International 
Conference on Information and Knowledge Management (CIKM), Lisboa, Portugal, Nov. 
6-9, 2007 . 
¾ 附錄八：X.-Y. Hsiao, W.-C. Peng, C.-C. Hung and W.-C. Lee, “Using SensorRanks for 
In-Network Detection of Faulty Readings in Wireless Sensor Networks”, Proceedings of the 
Sixth International ACM Workshop on Data Engineering for Wireless and Mobile Access (in 
conjunction with SIGMOD/PODS 2007), Beijing, China, June 10th, 2007.  
¾ 附錄九：H.-Y. Yang, W.-C. Peng and C.-H. Lo, “Optimizing Multiple In-Network Aggregate 
Queries in Wireless Sensor Networks”, Proceedings of the 12th International Conference on 
Database Systems for Advanced Applications (DASFAA), Bangkok, Thailand, April 9-12, 
2007. 
¾ 附錄十：C.-W. Yi, “A unified analytic framework based on minimum scan statistics for 
wireless ad hoc and sensor networks”, IEEE Transactions on Parallel and Distributed 
Systems (TPDS), Vol. 20, No. 9, pp. 1233-1245, September 2009. 
¾ 附錄十一：P.-J. Wan, C.-W. Yi, L. Wang, F. Yao, and X. Jia, “Asymptotic critical 
transmission radius for greedy forward routing in wireless ad hoc networks”, IEEE 
Transactions on Communications (TCOM), Vol. 57, No. 5, pp. 1433-1443, May 2009. 
¾ 附錄十二：C.-W. Yi, “Maximum scan statistics and channel assignment problems in 
homogeneous wireless networks”, Theoretical Computer Science (TCS), Vol. 410, No. 
21-23, pp. 2223-2233, 17 May 2009. 
¾ 附錄十三：P.-J. Wan, L. Wang, F. Yao, and C.-W. Yi, “On the longest RNG edge of wireless 
ad hoc networks”, Discrete Mathematics, Algorithms and Applications (DMAA), Vol. 1, No. 
1, pp. 25-43, March 2009.  
¾ 附錄十四：M.-T. Sun, C.-W. Yi, C.-K. Yang, and T. H. Lai, “An optimal algorithm for the 
minimum disc cover problem”, Algorithmica, Vol. 50, No. 1, pp. 58-71, January 2008. 
¾ 附錄十五：H. Liu, X. Jia, P.-J. Wan, C.-W. Yi, S. K. Makki, and N. Pissinou, “Maximizing 
lifetime of sensor surveillance systems”, IEEE/ACM Transactions on Networking (TON), 
Vol. 15, No. 2, pp. 334-345, April 2007. 
 26
routing", in ACM Int'l Conf. on Mobile Computing and Networking (MobiCom), 2001, pp. 
70-84. 
[4] B. Chen, K. Jamieson, H. Balakrishnan, and R. Morris, "Span: an energy-efficient 
coordination algorithm for topology maintenance in ad hoc wireless networks", ACM 
Wireless Networks 8, 5 (Sep.), 2002, pp. 481- 494. 
[5] M. Burkhart, P. V. Rickenbach, R. Wattenhofer, and A. Zollinger, "Does topology control 
reduce interference?", in ACM Int'l Symp. on Mobile Ad Hoc Networking and Computing 
(MobiHOC), 2004, pp. 9 - 19. 
[6] N. Li, and J. C. Hou, "FLSS: A fault-tolerant topology control algorithm for wireless 
networks", in ACM Int'l Conf. on Mobile Computing and Networking (MobiCom), 2004. 
[7] R. Wattenhofer, L. Li, P. Bahl, and Y.-M. Wang, "Distributed topology control for power 
efficient operation in multihop wireless ad hoc networks" in IEEE INFOCOM, 2001. pp. 
1388 - 1397. 
[8] K. Chakrabarty, S. S. Iyengar, H. Qi, and E. Cho, "Grid coverage for surveillance and target 
location in distributed sensor networks," IEEE Transactions on Computers, vol. 51, no. 12, 
pp. 1448-1453, 2002. 
[9] S. S. Dhillon and K. Chakrabarty, "Sensor placement for effective coverage and surveillance 
in distributed sensor networks," in IEEE Wireless Communications and Networking, 2003, 
pp. 1609-1614. 
[10] F. Y. S. Lin and P. L. Chiu, "A near-optimal sensor placement algorithm to achieve complete 
coverage/discrimination in sensor networks," IEEE Communications Letters, vol. 9, no. 1, 
pp. 43-45, 2005. 
[11] K. Kar and S. Banerjee, "Node placement for connected coverage in sensor networks," in 
International Symposium on Modeling and Optimization in Mobile, Ad Hoc and Wireless 
Networks, 2003. 
[12] A. Cerpa and D. Estrin, "ASCENT: adaptive self-configuring sensornetworks topologies," in 
IEEE INFOCOM, 2002, pp. 1278-1287. 
[13] D. Tian and N. D. Georganas, "A coverage-preserving node scheduling scheme for large 
wireless sensor networks," in ACM International Workshop on Wireless Sensor Networks 
and Applications, 2002, pp. 32-41. 
[14] F. Ye, G. Zhong, J. Cheng, S. Lu, and L. Zhang, "PEAS: a robust energy conserving protocol 
for long-lived sensor networks," in IEEE International Conference on Distributed 
Computing Systems, 2003, pp.28-37. 
[15] H. Zhang and J. C. Hou, "Maintaining sensing coverage and connectivity in large sensor 
networks," International Journal of Wireless Ad Hoc and Sensor Networks, vol. 1, no. 1-2, 
pp. 89-124, 2005. 
[16] N. Heo and P. K. Varshney, "Energy-efficient deployment of intelligent mobile sensor 
networks," IEEE Transactions on Systems, Man and Cybernetics - Part A: Systems and 
Humans, vol. 35, no. 1, pp. 78-92, 2005. 
[17] G. Wang, G. Cao, and T. L. Porta, "Movement-assisted sensor deployment," in IEEE 
INFOCOM, 2004, pp. 2469-2479. 
 28
ACM SIGMOD, 1984 
[35] J. Winter, Y. Xu, and W. C. Lee. Energy Efficient Processing of K Nearest Neighbor Queries 
in Location-aware Sensor Networks. In Proceedings of Mobiquitous, 2005. 
[36] B. Wu, K. T. Chuang, C. M. Chen, and M. S. Chen. DIKNN: An Itinerary-based KNN Query 
Processing Algorithm for Mobile Sensor Networks. In Proceedings of ICDE, 2007. 
[37] Y. Xu, T. Y. Fu, W. C. Lee, and J. Winter. Itinerary-based Techniques for Processing K 
Nearest Neighbor Queries in Location-aware Sensor Networks. Signal Processing, 2007. 
[38] P. Gupta and P. R. Kumar, “Critical power for asymptotic connectivity in wireless 
networks,” in Stochastic Analysis, Control, Optimization and Applications: A Volume in 
Honor of W. H. Fleming, W. M. McEneaney, G. Yin, and Q. Zhang, Eds. Birkhauser, March 
1998, pp. 547–566. 
[39] M. D. Penrose, “On k-connectivity for a geometric random graph,” Random Structures and 
Algorithms, vol. 15, no. 2, pp. 145–164, September 1999. 
[40] C.-W. Yi, P.-J. Wan, X.-Y. Li, and O. Frieder, “Asymptotic distribution of the number of 
isolated nodes in wireless ad hoc networks with Bernoulli nodes,” in The 2003 IEEE 
Wireless Communications and Networking Conference (WCNC 2003), vol. 3, 16-20 March 
2003, pp. 1585–1590. 
[41] P.-J. Wan and C.-W. Yi, “Asymptotic critical transmission radius and critical neighbor 
number for k-connectivity in wireless ad hoc networks,” in Proceedings of the 5th ACM 
International Symposium on Mobile Ad Hoc Networking and Computing (MobiHoc 2004), 
24-26 May 2004, pp. 1–8. 
[42] H. Zhang and J. Hou, “On deriving the upper bound of α-lifetime for large sensor networks,” 
in Proceedings of the 5th ACM International Symposium on Mobile Ad Hoc Networking 
and Computing (MobiHoc 2004), 24-26 May 2004, pp. 121–132. 
[43] P.-J. Wan and C.-W. Yi, “Coverage by randomly deployed wireless sensor networks,” IEEE 
Transactions on Information Theory, vol. 52, no. 6, pp. 2658–2669, June 2006. 
[44] C. McDiarmid, “Random channel assignment in the plane,” Random Structures and 
Algorithms, vol. 22, no. 2, pp. 187–212, March 2003. 
[45] M. D. Penrose, “Focusing of the scan statistic and geometric clique number,” Advances in 
Applied Probability, vol. 34, no. 4, pp. 739–753, December 2002. 
[46] J. Glaz, J. Naus, and S. Wallenstein, Scan statistics. Springer, 2001. 
[47] P. Auer and K. Hornik, “On the number of points of a homogeneous poisson process,” 
Journal of Multivariate Analysis, vol. 48, pp. 115–156, 1994. 
[48] P.-J. Wan, “Broadcast (radio, TV) networks.” [Online]. Available: 
http://www.cs.iit.edu/˜wan/lecture2.pdf 
[49] B. N. Clark, C. J. Colbourn, and D. S. Johnson, “Unit disk graphs,” Discrete Mathematics, 
vol. 86, pp. 165–177, 1990. 
[50] A. Gräf, M. Stumpf, and G. Weißenfels, “On coloring unit disk graphs,” Algorithmica, vol. 
20, no. 3, pp. 277–293, March 1998. 
[51] M. V. Marathe, H. Breu, H. B. Hunt III, S. S. Ravi, and D. J. Rosenkrantz, “Simple 
heuristics for unit disk graphs,” Networks, vol. 25, pp. 59–68, 1995. 
 30
no. 1, pp. 1–16, 2004. 
[69] P.-J. Wan and C.-W. Yi, “On the longest edge of gabriel graphs in wireless ad hoc 
networks,” IEEE Transactions on Parallel and Distributed Systems (TPDS), vol. 18, no. 1, 
pp. 111–125, January 2007. 
[70] P.-J. Wan, C.-W. Yi, F. Yao, and X. Jia, “Asymptotic critical transmission radius for greedy 
forward routing in wireless ad hoc networks,” in Proceedings of the 7th ACM International 
Symposium on Mobile Ad Hoc Networking and Computing, May 22-25 2006, pp. 25–36. 
[71] C.-W. Yi, “A unified analytic framework based on minimum scan statistics for wireless ad 
hoc and sensor networks,” IEEE Transactions on Parallel and Distributed Systems (TPDS), 
vol. 20, no. 9, pp. 1233–1245, September 2009. 
附錄一： 
 
Decentralized Energy-Conserving 
and Coverage-Preserving Protocols 
for Wireless Sensor Networks 
 
 
 
 
 
 
C.-F. Huang, L.-C. Lo, Y.-C. Tseng, and W.-T. Chen 
ACM Trans. on Sensor Networks, Vol. 2, No. 2, 2006. 
2 · C.-F. Huang et al.
This paper is organized as follows. Section 2 gives some preliminaries. Our basic solu-
tions for guaranteeing 1 coverage are presented in Section 3.1. Section 3.2 proposes several
extensions and optimizations of the above results. Section 4 draws our conclusions.
2. PRELIMINARIES AND PROBLEM DEFINITION
We are given a set of sensors, S = {s1, s2, . . . , sn}, in a two-dimensional area A. Each
sensor si, i = 1, . . . , n, knows its own location (xi, yi) inside A and has a sensing range
of ri. A location in A is said to be covered by si if it is within si’s sensing range and si is
active. A location in A is said to be k-covered if it is within at least k active sensors’ sensing
ranges. Two sensors si and sj are said to be neighbors if they have non-empty overlapping
sensing regions. For energy conservation, each sensor is able to switch between the active
mode and the sleeping mode. Sensor s i’s current remaining energy is denoted as E i.
Definition 1. Given a natural number k and a threshold value γ, 0 < γ ≤ 1, the
lifetime(k)(γ) of a sensor network is the duration from the network being started until the
first moment when the ratio of k-covered area over A is below the threshold γ.
For example, lifetime(k)(1) is the duration until the first location in A is no longer
k-covered. Our goal is to develop an energy-efficient k-coverage-preserving protocol for
the wireless sensor network by scheduling sensors’ active and sleeping periods such that
the lifetime of the network is as long as possible.
3. THE PROPOSED PROTOCOLS
3.1 1-Coverage-Preserving Protocols
3.1.1 Basic 1-CP Protocol. Our protocol, which is based on the model in [Yan et al.
2003], divides the time axis into a sequence of working cycles, each of the same length
Tw cycle. The working cycles of sensors are assumed to be roughly synchronous. Each
working cycle consists of two phases, an initialization phase of length T init and a sensing
phase of length Tsen. The initialization phase is for sensors to exchange information for
calculating their working schedules for energy conservation purpose. Then in the sensing
phase sensors will switch between active and sleeping modes according to their working
schedules.
Fig. 1 illustrates the structure of working cycles. During the initialization phase, each
sensor si has to wake up and broadcast a HELLO packet containing (x i, yi), ri, and a
reference time Refi, where Refi is a value generated from some random process. Based
on the HELLO packets from neighbors, s i can calculate its working schedule. To avoid
collisions, a random backoff should be taken before sending HELLO. The sensing phase
is divided into r rounds, each of the same duration T rnd, i.e., Tsen = r × Trnd. In these r
rounds, si will have a regular active and sleeping pattern.
Intuitively, a sensor will take the responsibility of sensing the environment cooperatively
with its neighbors in a time-sharing manner. Let us consider one round in a working
cycle, denoted by a duration [0, Trnd). We will choose two values, Fronti and Backi,
for sensor si, and schedule si to be active from [(Refi − Fronti) mod Trnd] to [(Refi +
Backi) mod Trnd], and to go to sleep for the rest of the round. Note that here we treat time
of a round in a circular manner.
Next, we present a basic method for selecting Ref i, Fronti, and Backi for sensor
si. First, si randomly generates a reference time Ref i in [0, Trnd). Fronti and Backi
ACM Journal Name, Vol. V, No. N, M 20YY.
4 · C.-F. Huang et al.
the larger zone. Note that lengths of zones can also be tuned.
Parameters Fronti and Backi are also chosen based on Ei. For any point p, Frontp,i
and Backp,i are calculated according to sensors’ remaining energies: Frontp,i = [(Refi−
prev(Refi)) mod Trnd] × EiEi+Ei′ and Backp,i = [(next(Refi) − Refi)) mod Trnd] ×
Ei
Ei+Ei′′
, where i′ and i′′ are the sensors in C(p) whose reference times are before and after
Refi (i.e., prev(Refi) and next(Refi)) in Lp, respectively. The definitions of Fronti and
Backi are unchanged, and the rest of the procedure is the same.
3.2 Enhancements and Extensions
3.2.1 k-Coverage-Preserving Protocol. Next, we extend our 1-CP protocol to a k-CP
protocol such that each point is always covered by at least k sensors. Note that k must be
no larger than the maximum coverage degree of the network. Sensors will cover A in a
time-sharing manner. But sensors need to stay awake for longer time to ensure k-coverage.
We define two parameters Front(k)p,i and Back
(k)
p,i for si with respect to each intersection
point p that is under si’s coverage:
Front
(k)
p,i =
{
(Refi − prev(Refi, k2 )) mod Trnd, if k is even;
(Refi − prev(Refi, k2 ) + Frontp,i′ ) mod Trnd, if k is odd.
Back
(k)
p,i =
{
(next(Refi, k2 )−Refi) mod Trnd, if k is even;
(next(Refi, k2) + Backp,i′′ −Refi) mod Trnd, if k is odd.
Here, prev(Refi,m) is defined as the mth reference time counting backwards from Ref i
in Lp, and next(Refi,m) is the mth reference time counting forwards from Ref i in Lp.
Also, i′ is defined as the sensor whose reference time Refi′ = prev(Refi, k2 ) in Lp,
and i′′ is defined as the sensor whose reference time Refi′′ = next(Refi, k2 ) in Lp.
Frontp,i′ and Backp,i′′ are both as defined in 1-CP protocol.
The rest of the procedure is similar. The integrated schedule of s i can be defined by
Front
(k)
i = max∀p∈P {Front(k)p,i } and Back(k)i = max∀p∈P{Back(k)p,i }. Then we require
that si be active from [(Refi − Front(k)i ) mod Trnd] to [(Refi + Back(k)i ) mod Trnd].
3.2.2 Active Time Optimization. Next, we show how to further reduce sensors’ on-
duty time without hurting coverage. Although the following discussion is based on the
1-CP protocol, it can be applied to other schemes, too. Recall that Front i and Backi of si
are taken from a max function. This might be too conservative. Below, we develop rules
for an individual sensor si to reduce its on-duty time.
(1) To shrink its on-duty time, a sensor s i has to collect the schedules of all its neighbors
through HELLO packets.
(2) To avoid two neighboring sensors shrinking their on-duty schedules simultaneously, s i
has to bid for the opportunity with its neighbors. There are several possibilities to do
so. We can let sensors with longer active durations in a round try first (called Longest
Schedule First (LSF)). Alternatively, we can let sensors with less remaining energies
try first (called Shortest Lifetime First (SLF)). Once winning, si can go to step 3.
(3) For each intersection point p that is under s i’s coverage, si tries to identify the smallest
values of Front′p,i and Back
′
p,i such that p is fully covered in a round even if s i
ACM Journal Name, Vol. V, No. N, M 20YY.
附錄二： 
 
Efficient Placement and Dispatch of 
Sensors in a Wireless Sensor 
Network 
 
 
 
 
Y.-C. Wang, C.-C. Hu, and Y.-C. Tseng 
IEEE Trans. on Mobile Computing, Vol. 7, No. 2, Feb. 2008.  
IEEE TRANSACTIONS ON MOBILE COMPUTING, TMC-0278-1006.R1 2
mounted with sensors. These works do motivate us to investigate
the dispatch problem.
In this work, we propose more general solutions to the sensor
placement problem than existing results. Our approach allows an
arbitrary relationship between a sensor’s communication distance
and its sensing distance. The sensing field is assumed to be a
polygon of any shape in which there may be arbitrary-shaped
obstacles. So the results can model an indoor environment. Our
approach first partitions the sensing field into smaller sub-regions.
In each sub-region, we arrange sensors row by row such that
each row guarantees continuous coverage and connectivity and
that adjacent rows ensure continuous coverage. Finally, columns
of sensors are added to ensure connectivity between rows. The
result requires fewer sensors compared to other schemes. For the
sensor dispatch problem, we have proposed a centralized and
a distributed schemes based on the former placement results.
Both schemes attempt to minimize the total energy consumption
to move sensors, or to maximize the average remaining energy
of those sensors that are moved into the area of interest. The
first scheme converts the dispatch problem to the maximum-
weight maximum-matching problem, whose optimal solution can
be found in polynomial time. With a greedy strategy, the second
scheme is distributed in that sensors will select the most suitable
locations as their destinations and compete with each other to
move to these locations.
The rest of this paper is organized as follows. Section II
formally defines the sensor placement and dispatch problems.
Sections III and IV propose our solutions to these problems.
Simulation results are presented in Section V. Conclusions are
drawn in Section VI.
II. PROBLEM DEFINITIONS
A. The Sensor Placement Problem
We are given a sensing field A to be deployed with sensors.
Each sensor has a communication distance rc and a sensing
distance rs. Sensors are homogenous, but we allow an arbitrary
relationship of rc and rs. The sensing field A is modeled by an
arbitrary 2D polygon. Obstacles may exist inside A, which are
also modeled by polygons of arbitrary shapes. However, obstacles
do not partition A (otherwise, maintaining network connectivity
wouldn’t be possible). With the presence of obstacles, we define
two sensors si and sj to be connected if |sisj | ≤ rc and the
line segment sisj does not intersect any obstacle or boundary of
A; otherwise, they are disconnected. Fig. 1(a) and (b) show two
examples. Obstacles may also reduce the coverage of a sensor.
We assume that a point can be monitored by a sensor if it is
within a distance of rs and line-of-sight exists with the existence
of obstacles. Fig. 1(c) and (d) give two examples. Note that here
we adopt the binary sensing model [14], [18] of sensors, where
a location can be either monitored or not monitored by a sensor.
In Section III-D, we will discuss how to adjust our placement
solution to adapt to the probabilistic sensing model [9], [13],
[36], where a location will be monitored by a sensor with some
probability function.
Our objective is to place sensors in A to ensure both sensing
coverage (in the sense that no point in A is unmonitored) and net-
work connectivity (in the sense that no sensor gets disconnected)
using as few sensors as possible. The concepts of coverage and
connectivity in an office environment are illustrated in Fig. 2(a)
and (b). Note that we assume rc = rs in this example.
(a) si and sj are connected (b) the obstacle disconnects si and sj
obstacle
(c) coverage with a large obstacle (d) coverage with a small obstacle
obstacle
obstacle obstacle
covered
region
line-of-sight
c
r cr
s
r
s
r
i
s
j
s is js
Fig. 1. Assumptions on connectivity and coverage.
Fig. 2. An example of sensor deployment in an office environment.
B. The Sensor Dispatch Problem
We are given a sensing field A, an area of interest I inside A,
and a set of mobile sensors S resident in A. The sensor dispatch
problem asks how to find a subset S′ ⊆ S of sensors to be moved
to I such that after the deployment, I satisfies our coverage and
connectivity requirements and the movement cost satisfies some
objective function. Here we consider two functions. The first one
is to minimize the total energy consumption to move sensors, i.e.,
min
∑
i∈S′
Δm × di, (1)
where Δm is the unit energy cost to move a sensor in one step
and di is the distance that sensor i has to be moved. The second
one is to maximize the average remaining energy of sensors after
the movement, i.e.,
max
∑
i∈S′ (ei −Δm × di)
|S′| , (2)
where ei is the initial energy of sensor i. Note that the calculation
of di should take the existence of obstacles into account. Fig. 2(c)
and (d) illustrate the concept of sensor dispatch.
IEEE TRANSACTIONS ON MOBILE COMPUTING, TMC-0278-1006.R1 4
(a) a sensing field with obstacles (b) single-row regions (c) multi-row regions
obstacle
obstacle
obstacle
obstacle
h
a
c
obstacle
123
4 5
6
g
d
e
f
b
expanded
parallel lines
min
3r
u
v
u
v
,
,
cut-off area O
min3r
min3r
min3r
min3r
min
3r
Fig. 4. Partitioning a sensing field.
obstacle
obstacle
obstacle
obstacle
single-row regions bisectors sensor placements (case of rc = rs)
o
b
s
ta
c
le
obstacle
minwidth 3r
bisector
triangulation
midpoint
minwidth 3r
minwidth 3r
minwidth 3r
Fig. 5. Finding bisectors of single-row regions and their sensor placements.
(a) (b) (d)(c)
3
s
r
c
r
s
r
1n
2
n3n
4
n
5
n
6
n
s
r 
2
s
r
c
r
c
r
1
2 c
r
2 3
2 s
r

c
r
s
r
1
2 c
r
c
r
c
r
s
r
1
2 c
r
s
r 
Fig. 6. Placing sensors in a simple 2D plane: (a) case of rc < rs, (b) case of rc = rs, (c) case of rs < rc <
√
3rs, and (d) case of rc ≥
√
3rs.
IEEE TRANSACTIONS ON MOBILE COMPUTING, TMC-0278-1006.R1 6
uncovered areas
(a) uncovered areas near the boundaries and obstacles
connectivity
(b) add sensors for coverage and connectivity
obstacle




obstacle
extra sensors along boundaries to maintain network connectivity
additional columns of sensors to improve network reliability
a
b

Fig. 7. Placing sensors along boundaries and around obstacles to fill uncovered areas and to maintain network connectivity. This example assumes that
rc = rs.
IV. SOLUTIONS TO THE SENSOR DISPATCH PROBLEM
Given a set of sensors already deployed in A and an area
of interest I that has to be monitored intensively, the dispatch
problem will be solved by the following steps:
1. Based on our placement results, we first compute the loca-
tions to be placed with sensors in I and then select some
sensors to be moved to these locations.
2. In order to correctly report sensed data in I to the sink, we
need to connect sensors in I and the sink. We then place a
row of sensors, each separated by a distance of rc, from I
to the sink.
3. After dispatching sensors in steps 1 and 2, the remaining
sensors can be deployed uniformly in the region of A−I to
ensure that the coverage of A−I is not reduced too much.
We assume that there are sufficient sensors to satisfy the need
of steps 1 and 2. Step 2 can be achieved easily. Step 3 can be
done by applying the solutions using repulsive forces between
sensors [14], [35] on A − I. As a result, we will only focus on
the design of step 1 below. Fig. 2(c) and (d) give an example. In
this section, two solutions are proposed. The centralized solution
converts the dispatch problem to the maximum-weight maximum-
matching problem, while the distributed solution is based on a
greedy strategy.
A. A Centralized Dispatch Solution
Given a set S of sensors in A and an area of interest I, our
solution involves the following five steps:
1. Run the sensor placement algorithm in Section III on the
area I to determine the locations in I to be placed with
sensors. Let the set of locations be L = {(x1, y1), (x2, y2),
· · · , (xm, ym)}. If m ≤ |S|, go to step 2; otherwise, we are
short of sensors and the algorithm terminates.
2. For each sensor si ∈ S, determine the energy cost
c(si, (xj , yj)) to move si to each location (xj , yj), j =
1 · · ·m. We define c(si, (xj , yj)) = Δm × d(si, (xj , yj)),
where d(si, (xj , yj)) is the shortest distance from si’s current
position to (xj , yj) considering the existence of obstacles.
(How to compute the shortest distance will be discussed in
Section IV-A.1.)
3. From S and L, we construct a weighted complete bipartite
graph G = (S ∪L,S×L) such that the vertex set contains S
(all sensors) and L (all locations to be placed with sensors)
and the edge set contains all edges from every element si ∈
S to every element (xj , yj) ∈ L. The weight of each edge
(si, (xj , yj)) can be defined either as
w(si, (xj , yj)) = −c(si, (xj , yj)),
if Eq. (1) is the objective function, or as
w(si, (xj , yj)) = ei − c(si, (xj , yj)),
if Eq. (2) is the objective function.
4. Solve the maximum-weight maximum-matching problem on
graph G. In particular, we construct a new graph Ĝ = (S ∪
L ∪ L̂,S × {L ∪ L̂}) from G, where L̂ is a set of |S| − |L|
IEEE TRANSACTIONS ON MOBILE COMPUTING, TMC-0278-1006.R1 8
obstacle 1
si
obstacle 2
(xj, yj)
r
r
obstacle 3
r
a
b
c
d
e
f
g
h
vertice of H
edge of H
expanded area
shortest path
r
Fig. 8. Finding a collision-free path from si to (xj , yj). Note that not all edges of H are shown in the figure.
3) Time Complexity Analysis: Next, we analyze the time
complexity of our sensor dispatch solution. Let |S| = n, |L| = m,
and k be the number of vertices of the polygons of all obstacles
and A. In step 2, there are O(nm) pairs of (si, (xj , yj)). To
compute the energy cost of each pair, we construct a graph of
O(k) vertices. Finding a shortest path on such graph can use the
Dijkstra’s algorithm [10], which takes O(k2) time. So the total
time complexity of step 2 is O(mnk2). The conversion in step
3 takes O(nm) time. In step 4, constructing the graph Ĝ from
G takes O(n(n −m)) time since it needs to add n −m vertices
and n(n−m) edges. Running the Hungarian method on Ĝ has a
time complexity of O(n3). Finally, it takes O(n) time in step 5
to check all edges in M. Therefore, the total time complexity is
O(mnk2) + O(nm) + O(n(n−m)) + O(n3) + O(n)
= O(mnk2 + n3).
B. A Distributed Dispatch Solution
The aforementioned solution is optimal but centralized. Here
we propose a distributed solution based on a greedy strategy. The
solution involves the following steps:
1. The sink runs the placement algorithm in Section III
on the area I to obtain a set of locations L =
{(x1, y1), · · · , (xm, ym)} to be occupied by sensors. The
sink then broadcasts L to all sensors.
2. On receiving the table L, a sensor will keep a copy of L and
mark each location (xj , yj) as unoccupied, j = 1 · · ·m.
3. Each sensor si then chooses an unoccupied location (xj , yj)
from L as its destination. The selection of (xj , yj) is
dependent on our objective function.
• If Eq. (1) is the objective function, si will choose
the location (xj , yj) such that the moving distance
d(si, (xj , yj)) is minimized as its destination.
• If Eq. (2) is the objective function, si will choose the
location (xj , yj) such that after moving to (xj , yj), its
remaining energy is maximized.
Sensor si will then start moving to (xj , yj) and mark (xj , yj)
as occupied.
4. On si’s way moving toward its destination, it will periodi-
cally broadcast the status of its table L, its destination, and
its cost to move to that destination. Note that the cost is
based on which objective function is used. The above action
can be controlled by setting a timer Tbroadcast. On sensor sk
receiving si’s broadcast, the following actions will be taken:
• For all locations marked as occupied by si, sk will also
mark them as occupied.
• If both si and sk are moving toward the same destina-
tion, they will compete by their costs. The one with
a lower cost will win and keep moving toward that
destination. The one with a higher cost will give up
moving toward that destination and go back to step 3
to reselect a new destination. (Note that in case that sk
has arrived at its destination, it will have a cost of zero,
in which case si will lose in the competition.)
5. Each sensor will repeat the above steps until it reaches
its destination or loses to another sensor and finds that
all locations in L have been marked as occupied. In the
former case, the sensor will execute its monitoring job at
the designated location. In the latter case, the sensor will
continue to support the remaining steps 2 and 3 mentioned
in the beginning of Section IV (to connect I and the sink
or to monitor the area A− I).
To prove the convergence of this distributed algorithm, we
have to show that every location (xj , yj) in L can eventually
be covered by one sensor. Step 4 guarantees that a sensor si will
eventually arrive at the location (xj , yj) if it always wins the
competition. If si loses the competition, it means that (xj , yj)
has been committed by another sensor. In this case, si has to
go back to step 3 to reselect another destination. A sensor will
continue moving until it finds that all locations are marked as
occupied. Therefore, as long as there are sufficient sensors, all
locations will eventually be covered by sensors. It is possible
that without sufficient information, a sensor may keep on moving
even if all locations in L are occupied. However, it will eventually
meet another sensor or reach the area I and be aware of the fact
that L has been occupied (note that the network in I must be
connected and thus sensors in I must have correct information).
So the convergence of the algorithm is proved.
V. EXPERIMENTAL RESULTS
In this section, we present some simulation results to verify
the effectiveness of the proposed algorithms. The first experiment
evaluates the number of sensors required to cover a sensing field.
We design six types of sensing fields as shown in Fig. 9. Sensors
are assumed to have omnidirectional sensing capability (such as
acoustic sensors). The communication distance rc is set to 10 m
(which is close to that specified in IEEE 802.15.4 [20] in an
indoor environment). To reflect the relationships of rc < rs,
rc = rs, rs < rc <
√
3rs, and rc ≥
√
3rs, we set the sensing
distance rs to 12 m, 10 m, 7 m, and 5 m, respectively. We compare
our result against the coverage-first and connectivity-first methods
IEEE TRANSACTIONS ON MOBILE COMPUTING, TMC-0278-1006.R1 10
0
500
1000
1500
2000
2500
3000
3500
4000
4500
n
u
m
b
e
r
o
f
s
e
n
s
o
rs
re
q
u
ir
e
d
(f) arbitrary shape
0
500
1000
1500
2000
2500
3000
3500
4000
4500
n
u
m
b
e
r
o
f
s
e
n
s
o
rs
re
q
u
ir
e
d
(e) office
0
500
1000
1500
2000
2500
3000
3500
4000
4500
n
u
m
b
e
r
o
f
s
e
n
s
o
rs
re
q
u
ir
e
d
(c) non-convex polygon
0
500
1000
1500
2000
2500
3000
3500
4000
4500
n
u
m
b
e
r
o
f
s
e
n
s
o
rs
re
q
u
ir
e
d
(d) H-shape
0
500
1000
1500
2000
2500
3000
3500
4000
4500
n
u
m
b
e
r
o
f
s
e
n
s
o
rs
re
q
u
ir
e
d
(b) circle
0
500
1000
1500
2000
2500
3000
3500
4000
4500
n
u
m
b
e
r
o
f
s
e
n
s
o
rs
re
q
u
ir
e
d
ours
coverage-first
connectivity-first
hexagon
square
(a) rectangle

c s
r r 
c s
r r   3
s c s
r r r  3
c s
r r

c s
r r 
c s
r r   3
s c s
r r r  3
c s
r r

c s
r r 
c s
r r   3
s c s
r r r  3
c s
r r 
c s
r r 
c s
r r   3
s c s
r r r  3
c s
r r

c s
r r 
c s
r r   3
s c s
r r r  3
c s
r r

c s
r r 
c s
r r   3
s c s
r r r  3
c s
r r
Fig. 11. Comparison of number of sensors required under different types of sensing fields.
the importance of the dispatch issue since blindly moving sensors
will lead to shorten network lifetime.
With the same settings in the previous experiment, the last
experiment evaluates the effect of the broadcast timer Tbroadcast
on the number of broadcasts and average moving distance of a
sensor when our distributed dispatch method is adopted. In this
experiment, we use Eq. (1) as the objective function. Fig. 14
illustrates the simulation results when the number of sensors are
200 and 400. From Fig. 14, we can observe that when Tbroadcast
becomes larger, the number of broadcasts can be reduced. How-
ever, this will cause sensors to move longer distances, and thus
extend the convergence time of the distributed algorithm. From
Fig. 14, we can find that the best value of Tbroadcast is around
two since both the number of broadcasts and average moving
distance can be kept quite small.
VI. CONCLUSIONS
In this work, we have proposed systematical solutions for
sensor placement and dispatch. Our solution allows a sensing
field of shape as an arbitrary polygon with possible existence of
obstacles. Thus, the result can be used for an indoor environment.
Our solution also allows an arbitrary relationship of sensors’
communication distances and sensing distances. It is verified
that the proposed schemes require fewer sensors to ensure full
coverage of the sensing field and connectivity of the network as
compared to other placement schemes in various types of sensing
0
20
40
60
80
100
120
140
None 1 2 3 4 5 6 7 8 Max
number of additional columns of sensors
a
v
e
ra
g
e
h
o
p
c
o
u
n
t
o
f
th
e
a
ll
-p
a
ir
s
h
o
rt
e
s
t
p
a
th
s = 10 m
= 5 m
= 3 m
rc
rc
rc
Fig. 12. Effect of additional columns on the all-pair shortest paths of sensors.
fields. A new sensor dispatch problem is defined and two energy-
efficient dispatch algorithms are presented to move sensors to the
target locations determined by our sensor placement scheme.
ACKNOWLEDGMENT
Y. C. Tseng’s research is co-sponsored by Taiwan MoE
ATU Program, by NSC grants 93-2752-E-007-001-PAE, 96-
2623-7-009-002-ET, 95-2221-E-009-058-MY3, 95-2221-E-009-
060-MY3, 95-2219-E-009-007, 95-2218-E-009-209, and 94-
2219-E-007-009, by Realtek Semiconductor Corp., by MOEA
IEEE TRANSACTIONS ON MOBILE COMPUTING, TMC-0278-1006.R1 12
[25] T. C. Shermer, “Recent results in art galleries,” Proceedings of the IEEE,
vol. 80, no. 9, pp. 1384–1399, 1992.
[26] D. Tian and N. D. Georganas, “A coverage-preserving node scheduling
scheme for large wireless sensor networks,” in ACM International
Workshop on Wireless Sensor Networks and Applications, 2002, pp. 32–
41.
[27] Y. C. Tseng, M. S. Pan, and Y. Y. Tsai, “Wireless sensor networks for
emergency navigation,” IEEE Computer, vol. 39, no. 7, pp. 55–62, 2006.
[28] Y. C. Tseng, Y. C. Wang, and K. Y. Cheng, “An integrated mobile
surveillance and wireless sensor (iMouse) system and its detection delay
analysis,” in ACM International Symposium on Modeling, Analysis and
Simulation of Wireless and Mobile Systems, 2005, pp. 178–181.
[29] G. Wang, G. Cao, and T. L. Porta, “Movement-assisted sensor deploy-
ment,” in IEEE INFOCOM, 2004, pp. 2469–2479.
[30] G. Wang, G. Cao, T. L. Porta, and W. Zhang, “Sensor relocation in
mobile sensor networks,” in IEEE INFOCOM, 2005, pp. 2302–2312.
[31] J. Wu and S. Yang, “SMART: a scan-based movement-assisted sensor
deployment method in wireless sensor networks,” in IEEE INFOCOM,
2005, pp. 2313–2324.
[32] F. Ye, G. Zhong, J. Cheng, S. Lu, and L. Zhang, “PEAS: a robust
energy conserving protocol for long-lived sensor networks,” in IEEE
International Conference on Distributed Computing Systems, 2003, pp.
28–37.
[33] H. Zhang and J. C. Hou, “Maintaining sensing coverage and connectivity
in large sensor networks,” International Journal of Wireless Ad Hoc and
Sensor Networks, vol. 1, no. 1–2, pp. 89–124, 2005.
[34] S. Q. Zheng, J. S. Lim, and S. S. Iyengar, “Finding obstacle-avoiding
shortest paths using implicit connection graphs,” IEEE Transactions on
Computer-Aided Design of Integrated Circuits and Systems, vol. 15, pp.
103–110, 1996.
[35] Y. Zou and K. Chakrabarty, “Sensor deployment and target localization
based on virtual forces,” in IEEE INFOCOM, 2003, pp. 1293–1303.
[36] Y. Zou and K. Chakrabarty, “A distributed coverage- and connectivity-
centric technique for selecting active nodes in wireless sensor networks,”
IEEE Transactions on Computers, vol. 54, pp. 978–991, 2005.
You-Chiun Wang received his B.S. and M.S. de-
grees in Computer Science and Information Engi-
neering from the National Chung-Cheng University
and the National Chiao-Tung University, Taiwan, in
2001 and 2003, respectively. He obtained his Ph.D.
in Computer Science from the National Chiao-Tung
University, Taiwan, in October of 2006. Currently, he
is a postdoctoral research associate at the department
of Computer Science, National Chiao-Tung Univer-
sity, Taiwan. His research interests include wireless
communication, mobile computing, and sensor net-
works.
Chun-Chi Hu received her B.S. and M.S. degrees
in Computer Science and Information Engineering
from the National Chiao-Tung University, Taiwan, in
2003 and 2005, respectively. Her research interests
include wireless networks and sensor networks.
Yu-Chee Tseng obtained his Ph.D. in Computer and
Information Science from the Ohio State University
in January of 1994. He is Professor (2000–preset)
and Chairman (2005–present) at the Department of
Computer Science, National Chiao-Tung University,
Taiwan. From 2006 to present, he serves as Adjunct
Chair Professor at the Chung Yuan Christian Univer-
sity. Dr. Tseng received the Outstanding Research
Award, by National Science Council, ROC, in both
2001–2002 and 2003–2005, the Best Paper Award,
by Int’l Conf. on Parallel Processing, in 2003, the
Elite I. T. Award in 2004, and the Distinguished Alumnus Award, by the
Ohio State University, in 2005. His research interests include mobile comput-
ing, wireless communication, network security, and parallel and distributed
computing. Dr. Tseng served as an Associate Editor for Telecommunication
Systems (2005–present), as an Associate Editor for IEEE Trans. on Vehicular
Technology (2005–present), and as an Associate Editor for IEEE Trans. on
Mobile Computing (2006–present).
Mobility Management Algorithms and Applications for Mobile
Sensor Networks
You-Chiun Wang, Fang-Jing Wu, and Yu-Chee Tseng
Department of Computer Science, National Chiao-Tung University, Hsin-Chu, 30010, Taiwan
Email: {wangyc, fangjing, yctseng}@cs.nctu.edu.tw
Abstract
Wireless sensor networks (WSNs) offer a convenient way to monitor physical environments. In the past, WSNs are
all considered static to continuously collect information from the environment. Today, by introducing intentional
mobility to WSNs, we can further improve the network capability on many aspects, such as automatic node
deployment, ﬂexible topology adjustment, and rapid event reaction. In this article, we survey recent progress in
mobile WSNs and compare works in this ﬁeld in terms of their models and mobility management methodologies.
The discussion includes three aspects. Firstly, we discuss mobility management of mobile sensors for the purposes
of forming a better WSN, enhancing network coverage and connectivity, and relocating some sensors. Secondly,
we introduce path-planning methods for data ferries to relay data between isolated sensors and to extend a WSN’s
lifetime. Finally, we review some existing platforms and discuss several interesting applications of mobile WSNs.
KEY WORDS: mobility management, path planning, sensor applications, topology adjustment, wireless sensor
networks.
1. Introduction
The development of wireless technologies and micro-
sensing MEMS has triggered the success of wireless
sensor networks (WSNs). A WSN is composed of
one or multiple remote sinks and many tiny, low-
power sensors, each equipped with actuators, sensing
devices, and wireless transceivers [1]. These sensors
are massively deployed in a region of interest (ROI)
to continuously collect and report surrounding data.
WSNs offer a convenient way to monitor physical
environments. Many applications such as object
tracking, health monitoring, security surveillance,
and intelligent transportation [2, 3, 4, 5] have been
proposed.
A WSN is usually deployed with static sensors
to perform monitoring missions. However, due to
the dynamics of events or environments, a purely
static WSN could face these challenges: (1) Sensors
are often scattered in a ROI by aircrafts or robots
[6]. These randomly scattered sensors could not
guarantee complete coverage of the ROI and may
be partitioned into disconnected subnetworks. The
existence of obstacles could even worsen the problem.
(2) Sensors are usually powered by batteries. As
some sensors exhaust their energy, holes could appear
and the network could be broken. However, in many
scenarios, it is quite difﬁcult to recharge sensors or
redeploy nodes. (3) A WSN may need to support
multiple missions or have multiple types of sensors
[7]. Sometimes, we may need to send a certain type
of sensors to particular locations to support particular
needs. Without mobility, this is difﬁcult to achieve.
(4) While most efforts assume that sensors are cheap,
some types of sensors may be expensive. Dispatching
of those expensive ones from locations to locations
may be necessary.
1
Fig. 1(b) shows an example, where s2, s3, and s4 all
exert repulsive forces on s1.
In the above two methods, oscillation check and
stability check are performed to examine whether a
sensor has reached its ﬁnal destination. When a sensor
si moves back and forth inside a small region many
times, it has entered the oscillation state. On the other
hand, when si moves less than a threshold distance in
a ﬁxed duration, it has entered the stable state. In both
cases, si will stop moving.
Reference [12] considers that sensors work under
a probability sensing model. The goal is to deploy a
minimum number of sensors such that the detection
probability of the ROI is above a predeﬁned threshold.
To achieve this, we can ﬁrst deploy sufﬁcient sensors
to satisfy the detection probability. Then, sensors can
exert repulsive forces on each other. In this way, the
number of sensors may be reduced since some sensors
may be pushed outside the ROI.
2.1.2. Graph-Based Deployment
The work [13] adopts a Voronoi diagram to search
uncovered holes and moves sensors to cover these
holes. Given a set of sensors on a 2D plane, the
Voronoi diagram [14] consists of a number of Voronoi
polygons such that each polygon contains one sensor
and the points in the polygon are closer to the interior
sensor than to other exterior sensors. When the sensing
range of a sensor cannot completely cover its Voronoi
polygon, there could be an uncovered hole in that
polygon. In [13], it proposes the following methods
to cover this hole:
Voronoi-based (VOR) method: A sensor should
move toward the farthest vertex of its current polygon.
Fig. 2(b) gives an example, where the dotted polygon
is sensor si’s current polygon and u is the farthest
vertex. Sensor si will move along the direction−→siu and
stop at v1, where |uv1| = rs.
Minimax method: A sensor should move to the
minimax point of its current polygon, where the
minimax point of a polygon is the center of the circle
with the minimum radius that can cover the whole
polygon (refer to [13] for details about ﬁnding the
circle). Fig. 2(c) gives an example, where v2 is the
minimax point of si’s current polygon.
2.1.3. Assignment-Based Deployment
Reference [15] focuses on deployment in ROIs with
obstacles. It considers two related problems: sensor
placement and sensor dispatch. The former asks how
u
v1
rs
(b) VOR method
v2
(c) Minimax method
(a) a Voroni diagram
si si
Voronoi
polygon
sensor
Voronoi
polygon
farthest
vertex
minimax point
Fig. 2. The VOR and Minimax methods.
to use the minimum number of sensors in a ROI to
guarantee coverage and connectivity. The latter asks
how to dispatch mobile sensors to the designated
locations computed by the placement result such that
their moving energy is minimized.
To solve the placement problem, [15] partitions
a ROI A into single-row and multi-row regions. A
single-row region requires one row of sensors to
cover it, and a multi-row region requires multiple
rows of sensors to cover it. To partition A, we ﬁrst
identify all single-row regions, which is achieved
by expanding A’s boundaries inward and obstacles’
perimeters outward by a distance of
√
3rmin, where
rmin = min{rc, rs}. When the expanded line cuts off
an obstacle with an area, we take a project from that
area to identify a single-row region. Fig. 3(a) gives an
example, where 5 single-row regions (with numbers)
are identiﬁed. Other regions will be multi-row ones.
Then, we place sensors in each region as follows:
Single-row region: We place a sequence of sensors
along the region’s bisector, each separated by a
distance of rmin. Fig. 3(b) gives an example.
Multi-row region: Two cases are considered, as
Fig. 3(c) shows. When rc ≥
√
3rs, adjacent sensors
are regularly separated by a distance of
√
3rs. When
rc <
√
3rs, sensors in each row are separated by a
distance of rc. Adjacent rows are separated by a
distance of rs +
√
r2s − r
2
c
4 and shifted by a distance
of rc2 . To connect adjacent rows, we add a column of
sensors between them, each separated by a distance
not larger than rc.
3
that select lj as their destinations and their distances
djβ to lj . Initially, OCCi[j] = ∅,∀j. Then, si selects
the nearest location lj such that |OCCi[j]| < nj as
its destination, adds (si, d(si, lj)) in OCCi[j], and
moves to lj .
2. Sensor si periodically updates and exchanges
its table with one-hop neighbors. When si hears the
OCCk table from a neighbor sk, si combines OCCi
with OCCk as follows: For each j, we calculate a
union Uj = OCCi[j] ∪OCCk[j]. If |Uj | > nj , we
remove the records in Uj that have longer moving
distances, until |Uj | = nj . Then, we replace OCCi[j]
by Uj . If si was in the original OCCi[j] entry, but
is not in the new OCCi[j] entry, it means that si is
replaced by other sensors with a shorter distance to lj .
Thus, si should reselect another destination.
3. After si reaches lj , it still exchanges its table with
neighbors. Since the sink will eventually observe that
all locations are covered, it can notify all sensors to
exit from the dispatch method.
2.2. Solutions to Enhancing Coverage and
Connectivity of a WSN
After deploying a WSN, some sensors may be broken
or may exhaust their energy. These failed sensors
may disconnect the network or cause uncovered
holes. One can move some mobile sensors to relieve
this problem. We introduce two such solutions for
enhancing connectivity and coverage of a WSN.
2.2.1. Connectivity Enhancement
Reference [18] considers a static WSN with several
isolated groups, called islands. To help these islands
communicate with each other, we can add some
mobile sensors between them. For two islands IG and
IH , the minimum number of mobile sensors required
to connect them is MG,H =
⌈
dG,H
rc
− 1
⌉
, where
dG,H = min
si∈IG,sj∈IH
{di,j} is the shortest distance
between IG and IH . Let N(IG) be the number
of sensors in island IG and W (IG,m) be the
optimal set of islands that can be connected by
m mobile sensors starting from island IG. It can
be derived that W (IG,m) = max{W (IG ∪ IH ,m−
MG,H) + N(IG ∪ IH)}, where IH is an island to
be directly connected by IG and N(IG ∪ IH) =
N(IG) + N(IH) + MG,H . However, for an island IG,
if the remaining m mobile sensors cannot connect
to any other island, we set W (IG,m) = 0. Using
dynamic programming, the minimum m to connect all
islands can be found.
The work [19] considers strengthening the topology
of a WSN to be biconnected. First, each cut-vertex
is identiﬁed. For example, in Fig. 5(a), c1 and c2 are
cut-vertices. By removing cut-vertices, the network is
divided into several biconnected components (called
blocks). Actually, we can ‘pull’ two neighboring
blocks together to eliminate the cut-vertex between
them. With this observation, a block movement method
is proposed as follows: Given a network topology, we
ﬁrst identify all blocks along with their cut-vertices. A
block can have zero, one, or multiple sensors. If two
cut-vertices are directly connected, an empty block is
established. Then, we can translate the network into
a block tree, whose nodes contain blocks and cut-
vertices. The block with the maximum number of
sensors is the root. In Fig. 5(a), there are 5 blocks
(including the empty block B4) and 2 cut-vertices c1
and c2. Block B1 is the root and blocks B2, B3, and
B5 are leaves. The method executes in two iterations
until the network becomes biconnected: (1) Move each
leaf block toward the nearest sensor of its parent block,
until a new edge appears. (2) If its parent block is
empty, we further move it to the upstream cut-vertex of
its parent block. Fig. 5(a) gives an example, where B5
moves toward v of its parent block B1, and B2 and B3
move toward the cut-vertex c1 since their parent block
B4 is empty. The ﬁnal topology is shown in Fig. 5(b).
v
(a) initial network topology (b) final network topology
B1
B5
B3
B2
B4
c1 c2
root
Fig. 5. An example of the block movement method.
2.2.2. Coverage Enhancement
The work [20] proposes a bidding protocol to enhance
the coverage of a hybrid WSN composed of static and
mobile sensors. Static sensors detect uncovered holes
locally and bid for mobile sensors by the sizes of holes.
It involves the following steps:
1. Each mobile sensor is assigned with a base price,
which is an estimation of the hole size when it leaves
its current position. Initially, the base price is zero
for all mobile sensors. Then, mobile sensors broadcast
their positions and base prices in their local areas.
5
C1
ADV
navigation field
si
mjADV
ADV
C2
C2
C2
C3
C3
C3
C4
Fig. 7. Navigate a mobile sensor by credits, where C1 >
C2 > C3 > C4.
we ﬁrst calculate the energy cost w(si, lj) = em ×
d(si, lj) for each sensor si ∈ S to reach each location
lj ∈ L, where em is the energy cost to move a sensor
in one step. The scheme tries to ﬁnd a matching M
between sensors and locations by allowing a boundBj
for each lj ∈ L as follows:
1. For each lj ∈ L, we use a bound Bj to limit the
candidate sensors that lj can match with. A sensor
si is said as lj’s candidate if w(si, lj) ≤ Bj . Since
a larger bound may lead a sensor to select a farther
location, Bj will be increased gradually. Initially, each
Bj = 1|L|
∑|L|
j=1 min∀i,(si,lj)∈S×L
{w(si, lj)}.
2. For each unmatched lj ∈ L, we ﬁnd a candidate
sensor si with the minimum w(si, lj) to match with.
If si is still unmatched, we add the pair (si, lj) in
M. Otherwise, si must be matched with another
location lo. In this case, lj will compete with lo
for si by three rules: (1) If Bj > Bo, we match si
with lj to avoid expanding Bj . (2) If Bj = Bo and
w(si, lj) < w(si, lo), we match si with lj to reduce
its energy consumption. (3) If Bj = Bo and si is the
only candidate of lj but is not that of lo, we match
si with lj . When lj wins the competition, the pair
(si, lo) is replaced by the new pair (si, lj) in M, and
lo becomes unmatched. Otherwise, lj checks other
candidate sensors, until there is no candidate.
3. If lj cannot ﬁnd any match, we increase Bj by
ΔB and go to step 2, until a match is found.
4. We repeat steps 2 and 3, until each lj ∈ L can
ﬁnd a sensor to match with.
Fig. 8 gives an example, where ΔB = 70. The
initial bound is 79+97+943 = 90. In Fig. 8(b), l1
matches with s2 with bound B1 = 90 and l2 matches
with s4 with bound B2 = 90 + 70 = 160. Then, after
expanding B3, l3 ﬁnds that its candidate s4 has been
matched with l2, so it competes with l2 for s4.
Since B3 = B2 and w(s4, l3) < w(s4, l2), (s4, l2) is
replaced by (s4, l3) in Fig. 8(c). Similarly, l2 obtains
s2 from l1 in Fig. 8(d) and thus l1 selects an unmatched
sensor s1. Fig. 8(e) shows the ﬁnal result.
(a) energy costs of mobile sensors
(b) M = {(s2, l1), (s4, l2)} (c) M = {(s2, l1), (s4, l3)}
(d) M = {(s2, l2), (s4, l3)} (e) M = {(s1, l1), (s2, l2), (s4, l3)}
cost
l2
l1
l3
s4
97
147
94
s3
153
238
177
s2
133
79
233
s1
219
105
181
l2
s3
s1
l3
s2
s4l1
B3(160)
l2
s3
s1
l1
l3
s2
s4
B2 (160)
l2
s3
s1
l1
l3
s2
s4
B1(160)
(90)
l2
s3
s1
l1
l3
s2
s4
B1
B2(160)
Fig. 8. An example of ﬁnding the matchingM.
When |S| < |L|, a clustering approach is proposed
and then the similar matching steps are executed (we
omit the details).
Reference [25] considers a mobile WSN as a multi-
robot system and addresses the cooperation among
robots. Each robot is regarded as a resource and
may be required by multiple concurrent missions.
It points out that deadlock may happen when some
missions never ﬁnish executing and resources are tied
up, preventing other missions from starting. Then, a
deadlock avoidance policy based on the Petri nets is
proposed.
2.4. Summary of Mobility Management
Table I summarizes the mobility management methods
for mobile sensors. While most methods consider a
purely mobile WSN, [18, 20, 23, 24, 25] consider
a hybrid WSN. References [18, 20] use mobile
sensors to improve the topology of a static WSN,
and [23, 24] use static sensors to detect events and
send mobile sensors to event locations. For sensors’
detection, [10, 12, 15, 17] consider the probabilistic
sensing model. For coverage and connectivity, most
deployment methods [10, 11, 13, 15, 17] address both
issues, but the work [12] addresses only the coverage
issue. References [20, 21, 22] move sensors to improve
a WSN’s coverage, while references [18, 19] move
sensors to improve the network connectivity. For
7
into 4 segments ξ1, ξ2, ξ3, and ξ4. Φp(·, ξ1) = 0 since
F cannot communicate with any sensor. Φp(s2, ξ2) =
Φp(s1, ξ4) = 1 since F can only communicate with
one sensor. Φp(s2, ξ3) = Φp(s1, ξ3) = 12 since F
should share its time to s1 and s2.
4. To meet the bandwidth requirement of each si,
F should spend sufﬁcient time to communicate with
si. If there is no sufﬁcient time, the segments for si
should be extended properly. For example, in Fig. 9(a),
segment ξ2 may be extended to the dotted curve to
increase the communication time with s2. Let xj be
the extra communication time of F to extend ξj and
ti be the original communication time of F for si.
A linear programming is formulated to minimize the
total extra communication time of F :
min
m∑
j=1
xj ,
subject to
(ti +
∑m
j=1 Φp(si, ξj)xj) ·R
|p|
v +
∑m
j=1 xj
≥ bi, (1)
where R is F’s data rate and bi is the bandwidth
requirement of si. Here, the numerator and denomi-
nator are the expected amount of data that can be sent
and received by si and the total moving time ofF after
extension, respectively. The path p after extension is
F’s traveling path.
The work [27] further considers multiple data
ferries. Given n sensors and m data ferries, the goal is
to ﬁnd a set of paths for data ferries to visit all sensors
such that the average message delay is minimized and
the bandwidth requirement of each sensor is met. Four
types of solutions are proposed.
Single-route algorithm (SIRA): All data ferries
will move along the same path and there is no
communication between them. Fig. 9(a) gives an
example with two ferries. This algorithm directly
extends that of [26]. For any path p, the delay to deliver
data from si to sj on p is T
p
ij =
|p|
2mv +
dpij
v . So, the
average delay of p is T p =
∑
1≤i,j≤n wijT
p
ij∑
1≤i,j≤n wij
, where
wij is the weight assigned to each T
p
ij . Still, edge
replacement and sequence reordering are applied to
improve p. Finally, the linear programming in Eq. (1)
can be rewritten as:
min
n∑
i=1
yi,
subject to R · (2rc + yi)|p|+∑nj=1 yj
≥ bi
m
, (2)
F data ferry sensorpath of a data ferry
F
F
contact point
G4
F F
F
F
cr F
F
1s
2s1ȟ 2ȟ
3ȟ
4ȟ
v
u
relaying
sensor
G3
G1 G2
F
F
extending
path
Fig. 9. Path-planning examples for data ferries.
where yi is the extra moving length of data ferries
in the communication range of si. In Eq. (2), the
left-hand term is the product of data ferries’ data
rate and the ratio of data ferries’ communication time
allocated to si, and the right-hand term means that si’s
bandwidth requirement bi is shared by m data ferries.
Multi-route algorithm (MURA): Each data ferry
will move along a different path and there is no
communication between them. Fig. 9(b) gives an
example. In this algorithm, given a set of paths P ,
we use a 2-tuple (E1(P), E2(P)) as the cost function
to evaluate the quality of P , where E1(P) is the
estimated total overload of data ferries in P and
E2(P) is the estimated total message delay incurred
by P (refer to [27] for details). Intuitively, overload
is the amount of data that newly appear and cannot be
delivered over a time interval. Initially, we assume that
each sensor has a ferry. Let P be the current path set
and ni be number of ferries in pi ∈ P . We adopt four
operations to reduce the number of ferries and to reﬁne
the path set P: (1) overlap(pi, pj): We extend path
pj ∈ P by including one sensor in path pi ∈ P , pi 
=
pj such that the cost is minimized. (2) merge(pi, pj):
We combine pi and pj into one new path, and put all
ni + nj ferries on the new path. (3) merge−(pi, pj):
This is the same as merge(pi, pj), except that we
decrease the number of ferries by one. (4) reduce(pi):
We decrease ni by one for pi if ni > 1. We iteratively
select one operation in a greedy manner to minimize
the cost, until there are only m paths. After obtaining
m paths, we can apply SIRA to optimize each path.
9
subject to
∀sj ,
∑
li∈L′
h(ci, ti, sj) + max
li∈L′
{g(ci, sj)} ≥ τ, (4)
In Eq. (3), O is the ROI’s center, d(li, O) is the
distance between li and O, and β is a constant to
measure the quality of the path yet to be constructed
for F . In Eq. (4), maxli∈L′{g(ci, sj)} is an estimation
of the meeting probability between F and sj .
3. After calculating L′ and the staying time ti
for each li ∈ L′, we then adopt any TSP solution to
construct a path to visit all way-points in L′.
3.2. Solutions to Prolonging a WSN’s Lifetime
by Data Ferries
The previous section mainly focuses on using
data ferries to relay data between isolated sensors.
Nevertheless, with richer energy, data ferries can also
help prolong the lifetime of a connected WSN. It
is widely known that sensors nearby the sink could
exhaust their energy faster. By scheduling data ferries
to collect data from sensors, the energy consumption
of sensors can be balanced and thus the network
lifetime can be prolonged. We will introduce four
path-planning solutions for data ferries in a connected
WSN: The recursive planning uses a divide-and-
conquer scheme to plan a ferry’s path. The tree-
based planning uses a tree structure to plan ferries’
paths. The single-hop collection allows a ferry to
directly contact each sensor. While the above solutions
are centralized, the distributed navigation considers
guiding data ferries by sensors in a distributed manner.
3.2.1. Recursive Planning
Given a set of sensors S and a data ferry F , [30]
considers planning F’s path to visit some sensors
in S such that the F’s moving distance (or time)
can be bounded by a pre-deﬁned threshold, and the
network lifetime is maximized. Suppose that F will
move from a location la = (xa, ya) to another location
lb = (xb, yb). The idea is to recursively pick a turning
point between la and lb, until we can ﬁnd a path
la → l1 → · · · → lm → lb such that the distance (or
time) bounded can be meet, and the network lifetime
is maximized when F moves along the path, where
l1, l2, · · · , lm are the turning points. A divide-and-
conquer scheme is proposed as follows:
1. Given two locations la and lb, we select a set of
possible turning points such that each point locates
at (xa+xb2 , kΔy), where k is an integer and Δy is a
constant such that every turning point will be inside
the ROI. Among these turning points, we select the
point lv and construct a path la → lv → lb such that
the network lifetime can be maximized whenF moves
along that path (refer to [30] for the details about
calculating the network lifetime). Fig. 12(a) gives an
example, where there are 4 turning point and a path
la → lv2 → lb is constructed.
2. We divide sensors into two groups according
to their distances to the line segments la → lv and
lv → lb (a sensor will favor the closer line segment).
For example, in Fig. 12(b), sensors s1, s2, and s3 are
in one group, while s4 and s5 are in another group.
3. For each cluster of sensors, we recursively
execute the above two steps, until the distance (or
time) bounded is reached. Fig. 12(c) shows the ﬁnal
result, where there are two iterations.
(a) iteration 1: select one turning point
ǻy
1
v
l
ǻy
ǻy
2
v
l
3
v
l
4
v
l
(c) result of iteration 2
(b) iteration 1: clustering
turning point
sensor
a
l
b
l
ǻy
ǻy
ǻy
2
v
l
sensor
a
l
b
l1s
2s
3s
4s 5s
ǻy
ǻy
ǻy al bl
F
cluster1 cluster2 cluster3 cluster4
ǻy),
2
xx( ba 
ǻy)-,
2
xx( ba 
Fig. 12. An example of the recursive planning method for a
data ferry.
3.2.2. Tree-Based Planning
Given a data ferry F and a routing tree T = (V, E)
rooted a sink, where V contains all sensors S and the
sink B, and E contains all tree edges, [31] considers
11
intermediate navigator
navigation agent communication link
moving path
F
N
E
Y
MX
Z
L
C
G
W
H
B
A
I
Fig. 14. An example of distributed navigation by sensors.
• When a sensor receives a Declare-NA, it will
give up becoming a NA by broadcasting an
Accept-NA message.
• When a sensor receives Accept-NA from all
lower-depth neighbors, it will declare itself as
a NA by broadcasting a Declare-NA message.
This process is repeated until each sensor is either a
NA or a one-hop neighbor of a NA. Then, for each pair
of NAs, the nodes passed by the shortest path (in terms
of hop count) between these two NAs are marked as
INs.
2. Path computation: A path P is formed to visit
each NA. The work proposes adopting the ant colony
optimization-TSP solution [38].
3. Navigation: Finally, the data ferry travels along
P with the assistance of INs based on a DOA model.
When visiting a NA, both NA and those sensors
dominated by NA will send their data to the ferry.
Reference [39] extends the above protocol to the
k-hop data collection scheme where sensors that are
within k hops from a NA can send their data to the NA
(and thus the ferry). To reduce the latency to deliver
data to a NA, a sensor can pre-transmit its data to a
sensor that is 1-hop away from a NA.
3.3. Summary of Path Planning
Table II summarizes the path-planning methods for
data ferries. While most methods consider centralized
approaches, [36, 39] uses sensors to navigate a data
ferry in a distributed manner. References [30, 31,
32, 39] consider that data sent from sensors to a
data ferry can be multi-hop transmission; other work
[26, 27, 28, 29, 34, 35, 36] consider that ferries
should directly communicate with each sensor. For
the issue of communication time, [26, 27] extend
the communication time of sensors to meet their
bandwidth requirements, [29] minimizes the total
waiting time of a ferry at each point along the path,
and [35] adopts an physical layer technology to help
a ferry quickly collect data from sensors. For energy
concern, [30] balances the trafﬁc loads among sensors,
while [31, 32, 34, 35, 36, 39] reduce the total energy
consumption of sensors. For the length concern, [30,
31, 32] give constraints on path lengths, while [26, 27,
28, 29, 34, 35, 36, 39] try to minimize path lengths.
4. Platforms and Applications of Mobile
WSNs
Below, we review some interesting platforms and
applications. Mobile Emulab [40] is a robotic testbed
developed for mobile WSNs. Mobile sensors are
robots that carry single-board computers and sensing
devices. Remote users can control these mobile
sensors in a real-time and interactive way, or through
a script. Fig. 15 shows its system architecture. The
video cameras will overlook the ROI and track
mobile sensors. Snapshots are periodically reported
to the vision system. Through image processing, the
positions of mobile sensors are determined. The robot
system can send motion commands to mobile sensors,
which can report their sensing data to the robot
system. On the other hand, the robot system can
query the current positions of mobile sensors via the
robot-backend system. Remote users can send motion
requests to control mobile sensors, or send event
requests to obtain the ROI’s status.
Emulab interface
motion requests
 event requests
position data
event reports
position data
vision system
user
video cameras
 motion requests
position data position queries
event reports
mobile sensors
robot-backend system
snapshots
robot system
motion commands sensing data
Fig. 15. The system architecture of Mobile Emulab.
13
this work designs an adaptive speed control algorithm
to determine whether a data ferry should slow down
depending on its current data deliver rate. Speciﬁcally,
a data ferry has three speeds: SLOW, STOP, and FAST.
A sensor can indicate how much data that it wishes
to transfer in a packet header. Then, the data ferry
can select a speed accordingly. To address the second
issue, a data ferry can broadcast an interest message
to help sensors learn their distances to the data ferry’s
moving path.
5. Conclusions
Static WSNs have limitations on supporting multiple
missions and handling different situations when
network conditions change. Introducing mobility to
WSNs can improve the network capability and thus
relieve the above limitations. This article provides a
comprehensive survey of current works on mobile
WSNs. Various mobility management and path-
planning schemes have been discussed. Also, several
mobile platforms and applications have introduced.
Acknowledgment
Y.-C. Tseng’s research is co-sponsored by MoE ATU
Plan, by NSC grants 96-2218-E-009-004, 97-3114-E-
009-001, 97-2221-E-009-142-MY3, and 98-2219-E-
009-005, by MOEA 98-EC-17-A-02-S2-0048 and 98-
EC-17-A-19-S2-0052, and by ITRI, Taiwan.
References
1. I.F. Akyildiz, W. Su, Y. Sankarasubramaniam, and E. Cayirci,
“A survey on sensor networks,” IEEE Comm. Magazine,
vol. 40, no. 8, pp. 102–114, 2002.
2. A. Rapaka and S. Madria, “Two energy efﬁcient algorithms
for tracking objects in a sensor network,” Wireless Comm. and
Mobile Computing, vol. 7, no. 6, pp. 809–819, 2007.
3. F. Hu, Y. Xiao, and Q. Hao, “Congestion-aware, loss-
resilient bio-monitoring sensor networking for mobile health
applications,” IEEE J. Selected Areas in Comm., vol. 27, no. 4,
pp. 450 – 465, 2009.
4. H. Liu, P. Wan, and X. Jia, “Maximal lifetime scheduling for
sensor surveillance systems with k sensors to one target,” IEEE
Trans. Parallel and Distributed Systems, vol. 17, no. 12, pp.
1526–1536, 2006.
5. M. Tubaishat, P. Zhuang, Q. Qi, and Y. Shang, “Wireless
sensor networks in intelligent transportation systems,”
Wireless Comm. and Mobile Computing, vol. 9, no. 3, pp. 287–
302, 2009.
6. S.S. Dhillon and K. Chakrabarty, “Sensor placement for
effective coverage and surveillance in distributed sensor
networks,” Proc. IEEEWireless Comm. and Networking Conf.,
pp. 1609–1614, 2003.
7. G. Cao, G. Kesidis, T.F.L. Porta, B. Yao, and S. Phoha,
“Purposeful mobility in tactical sensor networks,” Sensor
Network Operations, 2006.
8. D. Tian and N.D. Georganas, “A coverage-preserving node
scheduling scheme for large wireless sensor networks,”
Proc. ACM Int’l Workshop Wireless Sensor Networks and
Applications, pp. 32–41, 2002.
9. Y.C. Wang, C.C. Hu, and Y.C. Tseng, “Efﬁcient deployment
algorithms for ensuring coverage and connectivity of wireless
sensor networks,” Proc. IEEE Int’l Conf. Wireless Internet, pp.
114–121, 2005.
10. Y. Zou and K. Chakrabarty, “Sensor deployment and target
localization in distributed sensor networks,” ACM Trans.
Embedded Computing Systems, vol. 3, no. 1, pp. 61–91, 2004.
11. N. Heo and P.K. Varshney, “Energy-efﬁcient deployment of
intelligent mobile sensor networks,” IEEE Trans. Systems,
Man, and Cybernetics–Part A, vol. 35, no. 1, pp. 78–92, 2005.
12. N. Aitsaadi, N. Achir, K. Boussetta, and B. Gavish, “A
gradient approach for differentiated wireless sensor network
deployment,” Proc. IFIP Wireless Days Conf., 2008.
13. G. Wang, G. Cao, and T.F.L. Porta, “Movement-assisted
sensor deployment,” IEEE Trans. Mobile Computing, vol. 5,
no. 6, pp. 640–652, 2006.
14. F. Aurenhammer, “Voronoi diagrams–a survey of a funda-
mental geometric data structure,” ACM Computing Surveys,
vol. 23, no. 3, pp. 345–405, 1991.
15. Y.C. Wang, C.C. Hu, and Y.C. Tseng, “Efﬁcient placement and
dispatch of sensors in a wireless sensor network,” IEEE Trans.
Mobile Computing, vol. 7, no. 2, pp. 262–274, 2008.
16. H.W. Kuhn, “The Hungarian method for the assignment
problem,” Naval Research Logistics Quarterly, vol. 2, pp. 83–
97, 1955.
17. Y.C. Wang and Y.C. Tseng, “Distributed deployment schemes
for mobile wireless sensor networks to ensure multilevel
coverage,” IEEE Trans. Parallel and Distributed Systems,
vol. 19, no. 9, pp. 1280–1294, 2008.
18. S. Zhou, M.Y. Wu, and W. Shu, “Finding optimal
placements for mobile sensors: wireless sensor network
topology adjustment,” Proc. IEEE Circuits and Systems Symp.
Emerging Technologies: Frontiers of Mobile and Wireless
Comm., pp. 529–532, 2004.
19. P. Basu and J. Redi, “Movement control algorithms for
realization of fault-tolerant ad hoc robot networks,” IEEE
Network, vol. 18, no. 4, pp. 36–44, 2004.
20. G. Wang, G. Cao, P. Berman, and T.F.L. Porta, “Bidding
protocols for deploying mobile sensors,” IEEE Trans. Mobile
Computing, vol. 6, no. 5, pp. 515–528, 2007.
21. Z. Butler and D. Rus, “Event-based motion control for mobile-
sensor networks,” IEEE Pervasive Computing, vol. 2, no. 4,
pp. 34–42, 2003.
22. G. Wang, G. Cao, T.F.L. Porta, and W. Zhang, “Sensor reloca-
tion in mobile sensor networks,” Proc. IEEE INFOCOM, pp.
2302–2312, 2005.
23. A. Verma, H. Sawant, and J. Tan, “Selection and navigation of
mobile sensor nodes using a sensor network,” Pervasive and
Mobile Computing, vol. 2, no. 1, pp. 65–84, 2006.
24. Y.C. Wang, W.C. Peng, M.H. Chang, and Y.C. Tseng,
“Exploring load-balance to dispatch mobile sensors in wireless
sensor networks,” Proc. IEEE Int’l Conf. Computer Comm.
and Networks, pp. 669–674, 2007.
25. P. Ballal, A. Trivedi, and F. Lewis, “Deadlock avoidance policy
in mobile wireless sensor networks with free choice resource
routing,” International Journal of Advanced Robotic Systems,
vol. 5, no. 3, pp. 279–290, 2008.
26. W. Zhao and M.H. Ammar, “Message ferrying: proactive
routing in highly-partitioned wireless ad hoc networks,” Proc.
IEEE Workshop Future Trends of Distributed Computing
Systems, pp. 308–314, 2003.
27. W. Zhao, M. Ammar, and E. Zegura, “Controlling the mobility
of multiple data transport ferries in a delay-tolerant network,”
Proc. IEEE INFOCOM, pp. 1407–1418, 2005.
28. B. Yuan, M. Orlowska, and S. Sadiq, “On the optimal robot
15
(2007-present) at the Department of Computer Science,
National Chiao-Tung University, Taiwan. He is also Adjunct
Chair Professor at the Chung Yuan Christian University
(2006-present).
Dr. Tseng received Outstanding Research Award, by
National Science Council, ROC, twice in periods 2001-
2002 and 2003-2005, Best Paper Award (Int’l Conf. on
Parallel Processing, 2003), the Elite I. T. Award in 2004,
and the Distinguished Alumnus Award, by the Ohio
State University, in 2005. His research interests include
mobile computing, wireless communication, and parallel
and distributed computing.
Dr. Tseng serves on the editorial boards for Telecommu-
nication Systems (2005-present), IEEE Trans. on Vehicular
Technology (2005-2009), IEEE Trans. onMobile Computing
(2006-present), and IEEE Trans. on Parallel and Distributed
Systems (2008-present).
17
Parallelizing Itinerary-based KNN Query Processing in
Wireless Sensor Networks
Wen-Chih Peng Tao-Yang Fu
National Chiao Tung University
Hsinchu, Taiwan, ROC
{csiegoat, wcpeng}@cs.nctu.edu.tw
Wang-Chien Lee
The Pennsylvania State University
State College, PA 16801, USA
wlee@cse.psu.edu
Abstract
Wireless sensor networks have been proposed for facilitating various monitoring appli-
cations (e.g., environmental monitoring and military surveillance) over a wide geograph-
ical region. In these applications, spatial queries that collect data from wireless sensor
networks play an important role. One such query is the K Nearest Neighbor (KNN)
query that facilitates collection of sensor data samples based on a given query location
and the number of samples speciﬁed (i.e., K). Recently, itinerary-based KNN query
processing techniques, that propagate queries and collect data along a pre-determined
itinerary, have been developed. Prior studies demonstrate that itinerary-based KNN
query processing algorithms are able to achieve better energy eﬃciency than other ex-
isting algorithms developed upon tree-based network infrastructures. However, how to
derive itineraries for KNN query based on diﬀerent performance requirements remains
a challenging problem. In this paper, we propose a Parallel Concentric-circle Itinerary-
based KNN (PCIKNN) query processing technique that derives diﬀerent itineraries by
optimizing either query latency or energy consumption. The performance of PCIKNN is
analyzed mathematically and evaluated through extensive experiments. Experimental
results show that PCIKNN outperforms the state-of-the-art techniques.
Keywords: K nearest neighbor query, wireless sensor networks.
1 Introduction
Recent advances in micro-sensing MEMS and wireless communication technologies have set
oﬀ the rapid development of wireless sensor networks (WSNs) in the past few years. A WSN,
which consists of a large number of sensor nodes capable of sensing, computing, and commu-
nications, has been used for a variety of applications, including border detection, ecological
1
home node
query point q
source node
initial KNN boundary
updating KNN boundary
1. Query routing phase
2. KNN boundary estimation phase 3. Query dissemination phase
Figure 1: An overview of itinerary-based KNN query processing.
estimation phase, the home node estimates an initial KNN boundary (i.e., the solid boundary
line circle in Figure 1(a)) which is likely to contain K nearest sensor nodes from q. Finally, in
the query dissemination phase (as shown in Figure 1(b)), the home node propagates the query
to each node within the estimated initial KNN boundary. While the KNN query propagates
along certain well-designed itineraries, query results are collected at the same time. It has been
shown that, by avoiding the signiﬁcant overhead of maintaining a network infrastructure, the
itinerary-based KNN query processing techniques outperform the infrastructure-based KNN
techniques [22][23][24].
Clearly, the performance (such as the query latency and the energy consumption) of
itinerary-based KNN query processing techniques is dependent on the design of itineraries.
With a long itinerary, long query latency and high energy consumption may be incurred due to
a long itinerary traversal. On the other hand, allowing a query to run on an arbitrary number
of short itineraries in parallel may result in signiﬁcant collisions in the query dissemination
phase [26]. Thus, itinerary planning is an important design issue for itinerary-based KNN
query processing. Prior works in [22][23][24] develop several itinerary structures. However,
their proposals are not optimized neither in terms of the energy consumption nor the query
latency. In this paper, we propose a new itinerary-based KNN query processing technique,
called Parallel Concentric-circle Itinerary-based KNN (PCIKNN ) query processing technique
that is based on parallel itineraries derived for optimizing either performance criterion of query
latency or energy consumption.
While prior works have tested the idea of concurrent itineraries, the number of concur-
rent itineraries is not optimized. In contrast, PCIKNN allows a KNN query to propagate on
able for this task.
3
The rest of the paper is organized as follows. Preliminaries are presented in Section 2. The
ideas and design of the PCIKNN technique are described in Section 3. A KNN boundary
estimation method is developed in Section 4 and the issues of spatial irregularity are addressed
in Section 5. The performance of PCIKNN is evaluated in Section 6. Finally, this paper is
concluded in Section 7.
2 Preliminaries
In this section, we ﬁrst state the assumptions made in this paper and deﬁne the KNN problem
in wireless sensor networks. Next, we discuss the issues of query dissemination in itinerary-
based KNN query processing and review some closely related works. Finally, we provide an
overview of PCIKNN.
2.1 Assumptions and Problem Deﬁnition
We consider a wireless sensor network, where sensor nodes are deployed in a two-dimensional
space. Each sensor is aware of its location via GPS or other localization techniques [14]. By
periodically exchanging beacon information with sensor nodes nearby, a sensor node maintains
a list of neighboring nodes. Moreover, the sensed data are stored locally in sensor nodes. In
this network, a KNN query is issued at an arbitrary sensor node (called source node), which
is the starting node for in-network query processing. The source node is responsible for
reporting the ﬁnal query result to the user. The KNN query in wireless sensor networks is
formally deﬁned as follows:
Deﬁnition: (K Nearest Neighbor query) Given a set of sensor nodes M and a geographical
location (denoted as a query point q), ﬁnd a subset M ′ of M with K nodes (M ′ ⊆ M,
|M ′| = K) such that ∀n1 ∈ M ′ and ∀n2 ∈ M −M ′, dist(n1, q) ≤ dist(n2, q), where dist(·, ·) is
the Euclidean distance function.
Generally speaking, the “exact” result set of the KNN contains the recently sensed readings
of the K sensor nodes nearest to the query point q. In this paper, however, due to the mobility
of sensor nodes and dynamics of WSNs, the KNN query result may not contain the exact set
of K nearest neighbor nodes. Therefore, we measure the accuracy of the KNN query result
as the precision of returned data, i.e., the ratio of correct KNN sensed data among the query
result returned to the source node, where the correct KNN result refers to the set of sensed
data from K nearest sensor nodes at the time when the query result is received at the source
node.
5
KNN boundary
(a) IKNN
S1
S2 S4
S3
KNN boundary
(b) DIKNN
Figure 3: Itinerary structures in IKNN and DIKNN.
proposed algorithm is called Itinerary-based KNN processing (IKNN). In IKNN, the issue of
KNN boundary determination is not addressed. The authors focus on the issues of designing
itinerary structures and propose both sequential and parallel itinerary processing approaches.
For the sequential itinerary approach, IKNN disseminates a KNN query along a spiral itinerary
and collects data during the query dissemination phase. Once the query result contains sensed
data from K nearest sensors, it is returned to the source node. To reduce the query latency,
the parallel approach in IKNN allows two threads to disseminate query and collect data via
two itineraries (see Figure 3(a)). These two threads exchange the collected query results to
determine whether the KNN query should be further propagated or not.
On the contrary, the authors in [22] propose to estimate a KNN boundary that is likely
contain K nearby sensor nodes. Accordingly, the KNN query is quickly propagated within this
estimated boundary. Note that the KNN boundary is determined based on the node density
estimated during the routing process. Thus, the proposed algorithm is called Density-aware
Itinerary-based KNN (DIKNN). The itinerary structure for DIKNN is shown in Figure 3(b),
where the KNN boundary is divided into several cone-shape sectors. In each sector, KNN
query is propagated along an itinerary. Among itineraries, the inter-itinerary information ex-
changing is adopted when adjacent itineraries are encountered at the sector border line. When
the KNN query reaches the KNN boundary, the last Q-node in each sector directly sends the
partial results to the source node. Through a good estimation of the KNN boundary, DIKNN
improves its query latency over IKNN. However, the accuracy of the KNN boundary esti-
mation is very critical. Although DIKNN dynamically adjusts its estimated KNN boundary,
redundancy still exists in the KNN query result of DIKNN since the partial KNN query re-
sults from all sectors are sent back to the source node without any validation. Furthermore,
itinerary structures developed in IKNN and DIKNN do not explore the issues of optimizing
7
branch-
peri-
return-
maximum
 search path
KNN boundary
S1
S4S2
S3
w/2
w
Figure 4: Parallel concentric itineraries in PCIKNN.
3.1 Design of Concentric-Circle Itineraries
Given a query point q and an estimated KNN boundary, the area within the boundary can be
divided into multiple concentric-circle itineraries. The issue of estimating the KNN boundary
will be addressed later in Section 4. Let Ci denote the ith circle with a radius w × i, where
w is the itinerary width, i.e., the distance between itineraries. As mentioned, w is set as
√
3
2
r,
where r is the transmission range of a sensor node. To propagate KNN query along concentric-
circle itineraries, we partition the KNN boundary into multiple sectors. Figure 4(a) shows
an example of concentric-circle itineraries, where the number of sectors is 4. For each sector,
we have three types of itinerary segments: 1) a branch-segment, 2) a set of peri-segments,
and 3) two return-segments. As shown in Figure 4(b), a branch-segment is a straight line
through concentric-circles with the itinerary width w in each sector, two return-segments are
the boundary lines among sectors with the itinerary width w
2
and peri-segments are portions of
concentric-circles between branch-segments and return-segments. Obviously, there is no peri-
segment in a concentric-circle if the regions of branch-segments and return-segments fully cover
this concentric-circle. As shown in Figure 4(b), the arrows indicate the directions of query
propagations. Following the itineraries in PCIKNN, a KNN query is executed concurrently.
In light of the itinerary structure derived above, a KNN query is ﬁrst propagated along
branch-segments in each sector. Along the branch-segment, a Q-node broadcasts a probe
message and collects partial results from D-nodes within the region width of w. For each
sector, when the KNN query reaches one of the concentric-circles, two KNN query threads are
forked to propagate along the two peri-segments, while the original KNN query continues to
move along the branch-segment. To propagate a KNN query in two peri-segments, the Q-node
in the branch segment ﬁrst ﬁnds two Q-nodes in peri-segments and evenly divide the partial
9
shows, returning via a path from a boundary point to the source node (indicated by dotted
line) is always shorter than bypassing the home node than the source node (indicated by
the solid lines). This results in a longer query latency of PCIKNN than that of IKNN and
DIKNN. However, as we will show in the performance evaluation later, the gain in query
latency obtained due to high parallelism of PCIKNN can easily oﬀset the delay discussed
here. In addition, as shown in Section 3.4, we further propose a rotated itinerary structure
in PCIKNN to alleviate the energy exhaustion of sensor nodes along the return-segments.
In summary, with a proper itinerary design, PCIKNN achieves high performance in terms of
both the query latency and the energy consumption.
3.2 Optimal Number of Sectors in PCIKNN
PCIKNN aims at exploring parallel concentric-circles itineraries to achieve parallelism while
reducing query latency or energy consumption in KNN query processing. Thus, to determine
an appropriate number of sectors (denoted as S) is a critical issue. In this section, we ﬁrst
discuss the trade-oﬀ between the number of sectors in PCIKNN and the itinerary length within
a sector. Then we derive analytical models to determine the optimal number of sectors based
on two optimization goals: 1) the minimum latency (referred to as min latency); and 2) the
minimum energy (referred to as min energy), respectively.
3.2.1 Trade-oﬀ in PCIKNN Itinerary Design
In PCIKNN, when the number of sectors is increased, the maximal length of itineraries in each
sector becomes shorter. Clearly, the query latency and the energy consumption in each sector
is reduced. However, the total length of itineraries is likely to become longer as the number of
sectors increases. As a result, the energy consumption may be increased. On the other hand,
when a smaller number of sectors is adopted in PCIKNN, the itinerary length within a sector
may increase due to the existence of peri-segments. This leads to a higher energy consumption
and a longer query latency for each sector. From the above observations, we recognize a need
to strike a balanced trade-oﬀ between the number of sectors and the itinerary length in each
sector in order to optimize the performance of PCIKNN.
As query latency and energy consumption are the two most critical performance metrics
for KNN query processing in wireless sensor networks, we derive optimized PCIKNN itinerary
structures using them as the optimization objectives.
11
circle j+1
circle j
Qn+1Qn
itinerary j
w
Er
Er
Figure 6: Information statistics in a routing path.
To determine latencyperi, we take into account message delays for sending probe messages
and receiving D-nodes’ messages at each Q-node. Thus, the value of latencyperi is formulated
as follows:
latencyperi = E
peri
hop × (1 + EperiDnum)×Delay,
where Eperihop is the expected number of Q-nodes in the peri-segment at the farthest concentric-
circle and EperiDnum is the expected number of D-nodes of a Q-node.
Observation 2: The expected number of D-nodes is estimated as the number of D-nodes in
the gray area in Figure 6.
In light of Observation 2, we have
Eperihop =
2× π × R× w
2× S × Er ; E
peri
Dnum
= Er × w × d,
where Er is the expected length of each hop of Q-nodes. According to [22][23], Er = r2
√
d/(1+
r
√
d).
As for the latency spent on collecting partial results at the home node, assume that partial
results are sent to the home nodes at the same time ( in the worst-case scenario). The latency
for collecting partial results at the home node is formulated as follows:
latencyhome = 2× S ×Delay
According to the above deviations, the overall query latency for PCIKNN is derived as
follows:
latency = (π×R×w
S×Er × (1 + w ×Er × d)×Delay) + (2× S ×Delay)
In order to obtain the optimal number of sectors to achieve the minimum latency, we
diﬀerentiate the above equation to derive the optimal number of sectors as follows:
S =
√
(π×R×w
Er
)× (1 + w ×Er × d)
2
13
energybranch,Ci=E
branch
hop,Ci
× (Hsize + (EbranchDnum ×Dsize))× Bits,
where Ebranchhop,Ci = 1, E
branch
Dnum
= 0 since Q-nodes are assumed to be connected hop-by-hop along
with a branch-segment and D-nodes data collected are divided into peri-segments.
Next, the energy consumption of sensor nodes along the peri-segments is derived as follows:
energyperi,Ci=2× ((Eperihop,Ci ×Hsize) + ((
∑Eperi
hop,Ci
j=1 (j × EperiDnum))×Dsize))× Bits,
where Eperihop,Ci =
2× π × i× w
2× S × Er and E
peri
Dnum
= Er × w × d.
Finally, the energy consumption of sensor nodes along two return-segments in each sector,
is modeled as follows:
energyreturn,Ci=2× Ereturnhop,Ci × (Hsize + (EreturnDnum,Ci ×Dsize))× Bits,
where Ereturnhop,Ci = i, E
return
Dnum,Ci
= Eperihop,Ci × EperiDnum .
By putting the above derivations together, we could further utilize diﬀerentiation to derive
the optimal number of sectors to minimize the energy consumption of PCIKNN. Consequently,
the optimal number of sectors is derived as follows:
S =
√√√√ π
2w3d
Er
× (2
R
w
+ 1)
6
×Dsize
Hsize
3.2.5 Model Validation
We develop a simulator to validate our derivations. We simulate a wireless sensor network
that consists of 1000 sensor nodes randomly distributed in a 500×500 ﬁeld. A total of 100
KNN queries are issued and K is set to 300. The simulation results are shown in Figure 7.
The minimum latency model determines the value of sectors to be 6 (rounded from our
analytical result 6.4). As shown in Figure 7(a), we select the number of sectors to be 6 which
incurs the minimum query latency. Moreover, the optimal number of sectors for the minimum
energy consumption is 7 (rounded from our analytical result 7.1) which is consistent with the
experimental result as shown in Figure 7(b). The above comparisons show that our analysis
is very accurate. From our analytical models, we could easily determine the number of sectors
based on the targeted optimization objectives. Note that the above derivations are under the
assumption that sensors are uniformly distributed. To further validate the applicability of our
derivations under various network conditions, we conduct experiments by varying the network
density. Figure 8 shows the experimental results under various network densities. The number
of sensor nodes is from 500 to 1500 within a ﬁxed monitored region (i.e., 500×500m2). As
shown in Figure 8, when the network density is larger, the optimal numbers derived from
15
3.3 Analysis of Itinerary Structures
In this section, we analyze the performances of IKNN, DIKNN and PCIKNN in terms of the
number of concurrent query threads, the query latency and the energy consumption. Without
loss of generality, we assume that sensor nodes are uniformly distributed in the monitored
region. Moreover, the KNN boundary is known (i.e., it will be derived as shown in Section 4).
The radius R of the KNN boundary is set to c × w, where c is the number of concentric-
circles in the KNN boundary and w is the width of itineraries for query propagation and data
collection. For example, as shown in our illustrative example (see Figure 4), the radius of the
KNN boundary is 4 ∗ w since there are four concentric-circles. Since the query latency and
the energy consumption are proportional to the length of itineraries, we compare DIKNN and
PCIKNN in terms of the length of itineraries. Note that since DIKNN outperforms IKNN,
we only compare DIKNN and PCIKNN.
3.3.1 Number of Concurrent Query Threads
Figure 3(a) shows the itinerary structure of IKNN proposed in [24]. As shown, the number
of concurrent query threads in IKNN is 2. For DIKNN and PCIKNN, the number of sectors
directly aﬀects the number of concurrent query threads. It can be seen in Figure 3(b)
that only one itinerary exists in a DIKNN sector and hence the number of concurrent query
threads in DIKNN is exactly the same as the number of sectors. In each PCIKNN sector,
there are one query thread along the branch-segment and two query threads along the peri-
segments in each concentric circle. Therefore, the maximal number of concurrent KNN query
threads is (2× c + 1)× S. For example, if the number of sectors is set to 4 and the number
of concentric-circles is 4, we have 4 and 36 concurrent KNN query threads in DIKNN and
PCIKNN, respectively. Clearly, PCIKNN has more query threads than IKNN and DIKNN.
3.3.2 Query Latency
The query latency is determined by the maximal length of itineraries in DIKNN and PCIKNN.
Therefore, we derive the maximal length of itineraries shown as the dotted lines in Figure 3(b)
(for DIKNN) and Figure 4(a) (for PCIKNN) to represent the analytical latency. As shown in
Figure 3(b), the analytical query latency of DIKNN, denoted as latencyDIKNN , is the sum of
the total lengths of concentric-circles in a sector and the length of a branch-segment. Hence,
we have
latencyDIKNN =
∑R
w
i=0(LengthCi) + Lengthbranch,
17
amount of data carried is directly proportional to the itinerary length, we could use a contin-
uous function of itinerary lengths, denoted as Damount(∗), to model the energy consumption.
Hence, we have the following formula:
energys =
∫ lengths
x=0
Damount(x)× d(x) ∝ (itinerary length)2
As shown, the analytical energy is a quadratic function of itinerary lengths within a sector.
The analytical energy of DIKNN is formulated as the sum of the square of the total lengths
of concentric-circles in a sector and the length of a branch-segment. Hence, we have:
energyDIKNN = S × (
∑R
w
i=0(LengthCi) + Lengthbranch)
2
Notice that the itineraries for the data collection of PCIKNN in a sector include a branch-
segment and peri-segments. When a KNN query propagating along a branch-segment encoun-
ters a new concentric-circle, the KNN query is forked into two KNN query threads along the
two peri-segments. Meanwhile, the data collected along the branch-segment is equally divided
into two parts for two new KNN query threads. As a result, the amount of data carried along
these itineraries becomes smaller, thereby reducing the energy consumption. The analytical
energy of PCIKNN is formulated as the sum of the square of each sub-itinerary (a partial
branch-segment and a peri-segment in a concentric-circle):
energyPCIKNN = S × (
∑R
w
i=0(Lengthperi,Ci + Lengthbranch,Ci)
2),
where the length of a peri-segment in the concentric-circle Ci is Lengthperi,Ci = Lengthperi =
π×R
S
and the partial branch-segment from a concentric-circle Ci−1 to its next concentric-circle
Ci is Lengthbranch,Ci (i.e., w).
In light of the analytical energy formulas for DIKNN and PCIKNN, we compare the an-
alytical energy results by varying the number of sectors. As shown in Figure 9(b), both
DIKNN and PCIKNN have decreased the energy consumption as the number of sectors in-
crease. Furthermore, PCIKNN has a smaller energy consumption than DIKNN. From the
above, we observe that PCIKNN obtains a smaller query latency and the energy consumption
than IKNN and DIKNN. This is because PCIKNN achieves a good parallelism by allowing as
many concurrent KNN query threads as possible.
3.4 Rotated Itinerary Structures of PCIKNN
In PCIKNN, partial results are returned along the return-segments to the home node. A po-
tential concern is that sensor nodes along the return-segments may get their energy exhausted
19
Ni+1Ni
dis2ni,ni-1
disni,ni-1
(a) (b)
Figure 11: Coverage areas estimated in the routing phase.
 0
 1000
 2000
 3000
 4000
 5000
 0  10  20  30
In
te
rs
ec
tio
n 
Ar
ea
(m
^2
)
Distance Between Node Ni and Node Ni+1(m)
Intersection Area
Linear Regression
Figure 12: Intersection covered area with various node distances.
density, which in turn is used to estimate a KNN boundary. Clearly, how to determine the
network density precisely from the partial information gathered in the routing phase is an
important research issue.
Via a geo-routing protocol, such as GPSR, a KNN query is greedily forwarded from the
source node to the home node. Let Ai denote the area covered by relaying messages up to the
ith hop and Num denote the total number of nodes within the coverage area of the routing
path. By collecting the information for Ai and Num while the KNN query moves hop-by-hop
towards the home node, the network density can be estimated.
Here, we describe how PCIKNN updates these two values during the routing phase. Fig-
ure 11(a) shows a message transmitting from node Ni to node Ni+1. In the ﬁgure, the gray area
is the newly explored area, denoted as EAi. The number of sensor nodes in EAi is denoted by
inci+1. By adding inci+1 to Num, we have the updated number of nodes encountered so far.
The value of EAi is formulated as EAi = πr
2 −H(2r− dist(Ni, Ni+1)), where r is the trans-
mission range of a sensor node, H(*) is a linear function, and dist(Ni, Ni+1) is the Euclidean
distance between Ni and Ni+1. From experiments shown in Figure 12, we observed that the
intersected area between two sensor nodes is almost negative correlated with dist(Ni, Ni+1).
21
Figure 13: An example of bypassing void regions in PCIKNN.
two modes (i.e., the greedy mode and the perimeter mode) in the KNN query propagation.
In the greedy mode, a message is forwarded by selecting the sensor node making the most
progress towards the destination. When a void region is encountered, PICKNN switches to the
perimeter mode. After bypassing voids, it changes back to the greedy mode and continues to
move forward. Since void regions may appear in branch-segments, peri-segments, and return-
segments, we develop methods to bypass void regions, correspondingly. Figure 13 shows an
example of bypassing void region along the branch-segments and peri-segments, where gray
areas are void regions. In the ﬁgure, the bold and dotted lines refer to the KNN query
propagation along the branch-segments and the peri-segments, respectively. Also, the black
and gray nodes are Q-nodes and D-nodes, respectively.
When a KNN query reaches a void region on a branch-segment, the KNN query is split
into two KNN query threads. To simplify our discussion, we call them the left KNN query
threads and the right KNN query thread. The left KNN query thread continues to move
forward by using the left-hand rule to select the next Q-node close to the branch-segment.
The right KNN query thread acts similarly based on the right-hand rule. If these two KNN
query threads reach a concentric-circle, both two KNN query threads fork two additional
KNN query threads and move forward along the peri-segments. Note that after bypassing
void regions, both the left and the right KNN query threads will merge into one KNN query
that keeps propagating along the branch-segment. If a void exists on a peri-segment, the KNN
query will decide which rule to use according to the relative position of the peri-segment. If a
KNN query thread is on the left (or right, respectively) peri-segment from the perspective of
23
Mode, the KNN query will continue to propagate outwards when the holding time is expired.
At the home node, some partial results are returned as the KNN query propagates along
itineraries in each sector. Once the number of sensor readings collected is equal or larger
than K, the radius of the KNN boundary is updated as the distance between the query point
and the Kth nearest sensor node so far. The updated KNN boundary is broadcasted along
the branch-segments to the KNN query. According to the updated KNN boundary and the
position of the KNN query, the nodes holding KNN query determine whether they should
continue to propagate or not. If the KNN query is outside the updated KNN boundary, this
KNN query stops. Otherwise, the KNN query will keep propagating.
6 Performance Evaluation
In this section, we develop a simulator to evaluate the performance of PCIKNN, IKNN and
DIKNN. The simulation model and parameter settings are presented in Section 6.1 and the
experimental results are reported in Section 6.2.
6.1 Simulation Model
Our simulation is implemented in CSIM[17] and some simulation settings are the same as the
prior work [24]. There are 1000 sensor nodes randomly distributed in a 500×500m2 region
and the transmission range of a node is 40m. For each sensor node, the average number of
neighboring nodes is 20 by default. The message delay for transmitting or receiving messages
is 30ms. In our default settings, sensor nodes are static. For each query, the location of a
query point q is randomly selected. The default value of K for each KNN query is 100. A
sensed data is 4 bytes long and the query result is not aggregated. The broadcasting period
of beacon messages is 3s. A KNN query is considered as answered when the query result
is returned to the source node. In each round of experiment, ﬁve queries are issued from
randomly selected source nodes. Each experimental result is derived by obtaining average
results from ﬁfty rounds of experiments.
Three itinerary-based KNN algorithms (i.e., PCIKNN, IKNN and DIKNN) are imple-
mented. For a fair comparison, we obtain the result of DIKNN for all possible number of
sectors and use the result of DIKNN with the minimum latency/energy consumption. In
PCIKNN, we show the results for the minimum latency mode and the minimum energy mode,
respectively. We compare these three algorithms in terms of energy consumption, query la-
tency and query accuracy under various environment factors such as the network density, the
25
(a) Low density (b) High density
Figure 15: Visualization of sensor distributions under various network density settings.
monitored region (i.e., 500×500m2). Thus, we investigate the impact of network density by
varying the number of nodes from 500 to 1500. As a result, the average number of neighbors
for each node is varied from 10 to 30. Figure 14(a) shows that all three algorithms have
better query accuracy when the network density is increased. However, when the network
is sparse (i.e., the number of nodes is smaller than 800 nodes), PCIKNN outperforms IKNN
and DIKNN. The reason is that the itineraries in IKNN and DIKNN are longer than that in
PCIKNN. Thus, the KNN query on IKNN and DIKNN may easily get dropped. Due to the
high parallelism and short length in itineraries, PCIKNN is very robust. Furthermore, DIKNN
does not have a way to ensure the accuracy of KNN query results since all partial results are
directly sent to the source node. As a result, the query accuracy of DIKNN is signiﬁcantly
aﬀected by spatial irregularity. In a dense network (i.e., the number of nodes is larger than 900
nodes), both IKNN and PCIKNN have better query accuracy. As can be seen in Figure 14(b),
the latency of PCIKNN in both minimum latency and minimum energy modes is the lowest
among these three algorithms, showing the strength of concurrent KNN query propagation.
In a dense network, the latency of the three algorithms tends to decrease. Clearly, the KNN
boundary is small in a dense network, leading to a short latency. Figure 14(c) shows the energy
consumption of the three algorithms. PCIKNN has the lowest energy consumption, showing
the merits of itinerary design in PCIKNN. Note that when the network density is smaller,
there are more voids in the monitored region. Figure 15 depicts sensor distributions under
various network density settings. As shown in Figure 15(a), void regions frequently appear in
networks with low network density. From the experimental results observed above, PCIKNN
has the best performance under the settings with low network density because PCIKNN has
27
 0
 0.2
 0.4
 0.6
 0.8
 1
 1  3  5  7  9  11  13  15
Qu
er
y A
cc
ur
ac
y
Node Mobility (m/s)
PCIKNN min_latency
PCIKNN min_energy
DIKNN
IKNN
(a) Query accuracy
 2000
 4000
 6000
 8000
 10000
 12000
 1  3  5  7  9  11  13  15
Qu
er
y L
at
en
cy
 (m
s)
Node Mobility (m/s)
PCIKNN min_latency
PCIKNN min_energy
DIKNN
IKNN
(b) Query latency
 0.02
 0.04
 0.06
 0.08
 0.1
 0.12
 1  3  5  7  9  11  13  15
Tr
an
sm
is
si
on
 E
ne
rg
y 
(J)
Node Mobility (m/s)
PCIKNN min_latency
PCIKNN min_energy
DIKNN
IKNN
(c) Energy consumption
Figure 17: Impact of node mobility.
number of sensor nodes involved in KNN query is increased. Still, PCIKNN has the smallest
energy consumption. Furthermore, PCIKNN with the minimum energy mode (i.e., PCIKNN
min energy) indeed has the minimal energy consumption, validating the correctness of our
optimization. Note that when the K is small, the performance of DIKNN is very close to that
of PCIKNN although PCIKNN is still better. From the experimental results, we could observe
that when the K is small, the performance of DIKNN is almost the same as the PCIKNN in
terms of the query latency and the total energy consumption. On the other hand, PCIKNN
is signiﬁcantly better than DIKNN when the value of K is larger.
6.2.3 Impact of Node Mobility
We now conduct experiments with some mobile sensor nodes. Clearly, sensor node movements
have an impact on the query accuracy. The moving speed of mobile sensor nodes is varied
from 1m/s to 15m/s. The accuracy of query results is shown in Figure 17(a). From Figure
17(a), the accuracy of query results obtained by the three algorithms drastically decrease as
the moving speed increases. Clearly, with faster moving speeds of mobile sensor nodes, the
29
6.2.4 Impact of Node Failure
In this experiment, we investigate the impact of node failure to the performance of three
algorithms. The node failure rate of sensors clearly aﬀects the performance of KNN query
processing. Once nodes are failed, message droppings occur, thereby aﬀecting KNN query
processing. For example, a Q-node failure may result in the drops of KNN query threads,
decreasing the query accuracy. The node failure rate is varied from 0% to 0.8%. Performance
study of these three algorithms is shown in Figure 18. It can be seen in Figure 18(a) that
PCIKNN has the best query accuracy, which is still larger than 70% even when the node
failure rate is high (i.e., 0.8%). As shown in Figure 18(b) and Figure 18(c), the latency
and energy consumption results of each algorithm tend to increase when the node failure
rate increases. PCIKNN has a better performance since parallelizing itineraries leads to a
number of concurrent KNN query threads and a smaller itinerary length for each KNN query
thread. Consequently, the risk of message dropping is decreased, showing the strength of the
parallelized itineraries in PCIKNN. In addition, the design of collecting partial results at the
home node in PCIKNN increases the KNN query accuracy.
6.2.5 Impact of Link Failure
In this experiment, we examine the impact of link failures to the performance of IKNN,
DIKNN and PCIKNN. A link failure may occur due to the mobility of sensor nodes or envi-
ronmental interferences in wireless sensor networks. Clearly, a link failure results in the packet
losses in wireless sensor networks. Thus, we vary the packet loss rate, i.e., the probability of
packet losses during wireless transmissions, to investigate the impact of link failures. With
a higher packet loss rate, the links become more un-stable, leading to more packet losses
in transmissions. To deal with packet losses, a sensor node replies an ACK message upon
reception of a message from another sensor node. If a sender does not receive an ACK mes-
sage from the receiver after a pre-deﬁned timeout period, the sender will re-send the same
message until the ACK message is received. We implement the above operation in IKNN,
DIKNN and PCIKNN for comparison. The query accuracy of three algorithms is shown in
Figure 19(a). As the packet loss rate increases, the query accuracy of all algorithms tends to
decrease. As shown, since PCIKNN collects partial results at the home node, it achieves a
better query accuracy than IKNN and DIKNN. Furthermore, due to the multiple concurrent
query threads in PCIKNN, the amount of data transmission in each itinerary of PCIKNN is
smaller than that of IKNN and DIKNN. Thus, as shown in Figure 19(b), the query latency
of PCIKNN is better. The energy consumption of the examined three algorithms is shown
31
 0.5
 0.55
 0.6
 0.65
 0.7
 0.75
 0.8
 0.85
 0.9
 0.95
 1
 0  2  4  6  8  10
Qu
er
y A
cc
ur
ac
y
Noisy Data Rate (%)
PCIKNN min_latency
PCIKNN min_energy
DIKNN
IKNN
(a) Query accuracy
 0
 2000
 4000
 6000
 8000
 10000
 12000
 14000
 0  2  4  6  8  10
Qu
er
y L
at
en
cy
 (m
s)
Noisy Data Rate (%)
PCIKNN min_latency
PCIKNN min_energy
DIKNN
IKNN
(b) Query latency
 0
 0.02
 0.04
 0.06
 0.08
 0.1
 0.12
 0.14
 0  2  4  6  8  10
Tr
an
sm
is
si
on
 E
ne
rg
y 
Co
ns
um
pt
io
n 
(J)
Noisy Data Rate (%)
PCIKNN min_latency
PCIKNN min_energy
DIKNN
IKNN
(c) Energy consumption
Figure 20: Impact of noisy data.
in Figure 19(c). PCIKNN with the minimum latency mode may have more KNN query
threads, which increases the number of re-sent packets. On the other hand, PCIKNN with
the minimum energy mode still has the best performance in terms of energy consumption.
6.2.6 Impact of Noisy Data
In wireless sensor networks, some noisy data may occur in transmissions. When a noise
occurs, the data is likely to contain some errors. To detect such errors occurred in wireless
transmissions, one could utilize some existing error detection methods. In this paper, we
utilize Cyclic Redundancy Check (abbreviated as CRC), a well-known error detection method
in telecommunication, to detect possible errors occurred in transmissions. Each message
includes a corresponding CRC code determined based on its message content. Upon receiving
a message, a sensor node will check the CRC code to verify the correctness of messages
received. If this sensor node ﬁnds an error by the evaluation of CRC codes, a re-transmission
is required. To simulate the noisy environment, a noisy data rate, which is the probability
of having noisy data during message transmissions, is varied to study its impact to IKNN,
33
 0.5
 0.6
 0.7
 0.8
 0.9
 1
 50  100  150  200  250  300  350  400
Qu
er
y A
cc
ur
ac
y
K
PCIKNN min_latency
PCIKNN min_energy
Rotation min_latency
Rotation min_energy
(a) Query accuracy
 0
 2000
 4000
 6000
 8000
 10000
 50  100  150  200  250  300  350  400
Qu
er
y L
at
en
cy
(m
s)
K
PCIKNN min_latency
PCIKNN min_energy
Rotation min_latency
Rotation min_energy
(b) Query latency
 0
 0.05
 0.1
 0.15
 0.2
 0.25
 0.3
 50  100  150  200  250  300  350  400
Tr
an
sm
is
si
on
 E
ne
rg
y 
Co
ns
um
pt
io
n(J
)
K
PCIKNN min_latency
PCIKNN min_energy
Rotation min_latency
Rotation min_energy
(c) Energy consumption
 0
 0.0002
 0.0004
 0.0006
 0.0008
 0.001
 50  100  150  200  250  300  350  400
St
an
da
rd
 D
ev
ia
tio
n
K
PCIKNN min_latency
Rotation min_latency
PCIKNN min_energy
Rotation min_energy
(d) Energy consumption standard deviation
Figure 23: Performance of PCIKNN with rotated itineraries.
ary is the average distance of the kth distant nodes of all queries derived by the experiments.
As shown in Figure 21, PCIKNN is very close to the optimal KNN boundary under various
network density. However, the boundary estimated in DIKNN does not ﬁt well with the trend
of the optimal KNN boundary. Moreover, in Figure 21, when the number of nodes is smaller
than 800, the KNN boundary estimated in DIKNN is smaller than the optimal value because
the KNN boundary is large and the routing path from the source node to the home node is
not long enough to estimate a region contained K sensor nodes.
In addition, we further evaluate the performance of the two schemes we proposed for
adjusting the KNN boundary in PCIKNN. We set the value of K to be 300, and the result
is shown in Figure 22. It can be seen in Figure 22 that, when the value of K increases, the
query accuracy is worsen if the KNN boundary is not adjusted by the home node. This is
because that when the K increases, the gap between the real KNN boundary and the estimated
boundary increases and thus aﬀecting the accuracy of KNN query signiﬁcantly.
35
Acknowledgement
Wen-Chih Peng was supported in part by MoE ATU Plan, the National Science Council
under Grant no. 97-2221-E-009-053-MY3 and 95-2221-E-009-061-MY3, Taiwan, and Microsoft
Research Asia. Wang-Chien Lee was supported in part by the National Science Foundation
under Grant no. CNS-0626709 and IIS-0534343.
References
[1] M. Demirbas and H. Ferhatosmanoglu. Peer-to-Peer Spatial Queries in Sensor Networks.
In Proc. of the 3rd International Conference on Peer-to-Peer Computing, pages 32–39,
2003.
[2] D. Estrin, R. Govindan, and J. Heidemann. Next Century Challenges: Scalable Coordi-
nation in Sensor Networks. In Proc. of the 5th ACM/IEEE International Conference on
Mobile Computing and Networking (MobiCom), pages 263–270, 1999.
[3] H. Ferhatosmanoglu, E. Tuncel, D. Agrawal, and A. E. Abbadi. Approximate Nearest
Neighbor Searching in Multimedia Databases. In Proc. of the 17th IEEE International
Conference on Data Engineering (ICDE), pages 503–511, 2001.
[4] D. Goldin, M. Song, A. Kutlu, H. Gao, and H. Dave. Georouting and Delta-gathering:
Eﬃcient Data Propagation Techniques for Geosensor Networks. In NSF Worshop on
GeoSensor Networks, 2003.
[5] W. R. Heinzelman, A. Chandrakasan, and H.balakrishnan. Energy-Eﬃcient Communi-
cation Protocol for Wireless Microsensor Networks. In Proc. of the 33rd Hawaii Interna-
tional Conference on System Sciences, pages 8020–8029, 2000.
[6] G. R. Hjaltason and H. Samet. Distance Browsing in Spatial Databases. ACM Transac-
tions on Database Systems, 24(2):265–318, 1999.
[7] B. Karp and T. H. Kung. GPSR: Greedy Perimeter Stateless Routing for Wireless
Networks. In Proc. of the 6th ACM/IEEE International Conference on Mobile Computing
and Networking (MobiCom), pages 243–254, 2000.
[8] Y. B. Ko and N. H. Vaidya. Location-aided Routing (LAR) in Mobile Ad Hoc Networks.
Wireless Networks, 6(4):307–321, 2000.
[9] F. Kuhn, R. Wattenhofer, and A. Zollinger. Worst-Case Optimal and Average-Case
Eﬃcient Geometric Ad-Hoc Routing. In Proc. of the 4th ACM International Symposium
on Mobile Ad Hoc Networking and Computing (MobiHoc), pages 267–278, 2003.
[10] S. J. Leon. Linear Algebra with Applications. Prentice Hall, 2002.
[11] D. Li, K. Wong, Y. Hu, and A. Sayeed. Detection, Classiﬁcation and Tracking of Targets
in Distributed Sensor Networks. IEEE Signal Processing Magazine, pages 17–29.
[12] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong. TAG: a Tiny AGgrega-
tion Service for Ad-Hoc Sensor Networks. ACM SIGOPS Operating Systems Review,
36(SI):131–146, 2002.
[13] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong. The Design of an Acquisi-
tional Query Processor For Sensor Networks. In Proc. of the ACM SIGMOD International
Conference on Management of Data, pages 491–502, 2003.
[14] N. Patwari, A. III, M. Perkins, N. Correal, and R. O’Dea. Relative Location Estimation
in Wireless Sensor Networks. IEEE Trans. on Signal Processing, 51(8):2137–2148, 2002.
37
附錄五： 
 
Clustering Object Moving Patterns 
for Prediction-based Object 
Tracking Sensor Networks 
 
 
 
 
C.-C. Hung and W.-C. Peng 
Proceedings of the ACM 18th International Conference on Information 
and Knowledge Management (CIKM), Hong Kong, Nov. 2-6, 2009. 
Figure 2: A PST T2.
behavior of an object [3][5]. Speciﬁcally, each edge of a PST
represents a sensor id which appears in the moving path of an
object. A tree node is labeled as rk...r2r1 can be reached from
the traversal path from root →r1 → r2 → ... → rk. In a PST,
each tree node maintains a conditional table to record the ap-
pearing counts and the conditional probabilities of all appeared
labels that follow its label. Consider an example PST in Fig-
ure 1, where the object frequently travels in area A and area
AB (referred a sequential pattern from area A to area B). In
addition, the condition table of each node provides statistical
information of next movements. For example, the condition
table associated with node A reﬂects that the next movements
when the object is in area A are area B (with the probabil-
ity being 0.66) and area C (with the probability being 0.33).
Consequently, a PST is able to not only capture the moving be-
havior of objects but also be utilized for the prediction. Since
the main theme of this paper is to cluster similar moving be-
haviors of objects, interesting readers could refer to [4] for the
construction of PSTs.
3. CLUSTERING OBJECTS WITH SIMILAR
MOVING BEHAVIORS
In this section, we exploit group mobility for a prediction-
based OTSN, which is called a group-based OTSN in this pa-
per. Explicitly, a group-based OTSN consists of the following
phases: in Phase 1, a cluster head collects movements of ob-
jects and constructs PSTs for objects by using the method in
[3], in Phase 2, we compute distance values of objects in terms
of their PSTs, in Phase 3, by distance values derived in Phase
2, objects with similar moving behaviors are grouped into one
group, and at last only one representative PST is maintained
for the prediction to save the storage cost for each group in the
Phase 4. In the following sections, we describe Phase 2, Phase
3 and Phase 4 in detail.
3.1 Distance between PSTs
As mentioned above, a PST is used to capture the moving
behavior of an object. To measure the degree of similar moving
behaviors among objects, we derive a distance function δMSL
for PSTs. Inspired by prior works in [2], we ﬁrst represent a
PST into a set of sequences and then formulate the similarity
of PSTs through the editing distances between their sets of
sequences.
To measure the similarity between two PSTs, both the struc-
ture and the statistical information of a PST should be consid-
ered. Since the label of a node in a PST is the suﬃx of the label
of its child nodes, a branch in a PST represents a series of fre-
quent sequential patterns (represented as sequences of sensor
ids). In other words, by extracting a branch in a PST, frequent
sequential patterns with the same destination are determined.
Such frequent sequential patterns extracted from branches of
a PST are referred to as structure information in a PST. As
a result, the similarity of two PSTs should take the structure
information of PSTs into consideration. Except the structure
information of PSTs, we should further consider the statistical
information of PSTs. Through statistical information in PSTs,
each node can determine its corresponding importance in terms
of the probability that indicates how frequent an object travels
along this frequent sequential pattern. Thus, when designing
a distance function among PSTs, we should give higher weight
to a node with higher probability.
Based on the properties above, we propose a distance func-
tion δMSL which takes the structures of PSTs and the prob-
abilities of nodes into account. In order to capture structure
similarity of PSTs, we transform a PST into a moving sequence
list which is composed of several moving sequences. Formally,
a moving sequence of a PST is deﬁned as follows:
Deﬁnition 2. Moving Sequence: Given a PST Ti, the j-
th moving sequence is deﬁned as Lji = [TL
1
i,j : p(TL
1
i,j), TL
2
i,j :
p(TL2i,j), ..., TL

i,j : p(TL

i,j)] where TL
k
i,j denotes the k-th tree
node traversing from the root in the j-th branch of the root
node and p(TLki,j) is the corresponding probability.
To measure the importance of a moving sequence, the weight
of each moving sequence is deﬁned as follows:
Deﬁnition 3. Weight of a Moving Sequence: The
weight of a moving sequence Lji is formulated as w(L
j
i ) =∑n
k=1 p(TL
k
i,j), where n is the number of elements in L
j
i .
Consequently, a moving sequence list is deﬁned as follows:
Deﬁnition 4. Moving Sequence List: Given a PST Ti,
the moving sequence list is deﬁned to be Li =< L
1
i , L
2
i ,...,
Lni >, where n denotes the number of moving sequences and
Lji denotes the j-th moving sequence.
For example, the moving sequence list in T1 is < [A : 0.5], [B :
0.375, AB : 0.33] >. Consequently, a moving sequence list de-
rived from a PST is able to represent both the structure and
the statistical information of a PST. As such, we propose a
distance function δMSL. Given two PSTs Ti and Tj with their
moving sequence lists Li and Lj , the distance between two
PSTs δMSL(Ti, Tj) is determined by the editing distance be-
tween Li and Lj , say ed(Li[1..m], Lj [1..n]). The editing dis-
tance between Li and Lj is determined as the minimal cost
of transforming Li into Lj via three editing operations: inser-
tion, deletion and replacement. To facilitate the presentation,
let TLi,m and TL

j,n be a pair, L
j
i [1..n] be L
j
i with n elements,
and Li[1..m] be Li with m moving sequences. Three operations
and the corresponding costs are described as follows:
Insertion: We can transform Li[1..m] to Lj [1..n] by (1)
transforming Li[1..m] to Lj [1..n−1] and then (2) inserting one
moving sequence Lnj into Lj [1..n− 1]. The corresponding cost
is the sum of the cost of transforming Li[1..m] to Lj [1..n − 1]
and w(Lnj ).
Deletion: We transform Li[1..m] to Lj [1..n] by (1) trans-
forming Li[1..m − 1] to Lj [1..n] and (2) deleting one moving
sequence Lmi . The corresponding cost is the sum of the cost of
transforming Li[1..m − 1] to Lj [1..n] and w(Lmi ).
Replacement: We transform Li[1..m] to Lj [1..n] by (1)
transforming Li[1..m − 1] to Lj [1..n − 1] and (2) replacing a
moving sequence Lmi to a moving sequence L
n
j . The cost of
replacing one moving sequence Lmi by L
n
j is the sum of prob-
abilities of all elements, which is listed as R(Lmi , L
n
j ) in the
 0
 100
 200
 300
 400
 500
 0  2000  4000  6000  8000  10000
Av
er
ag
e 
Nu
m
be
r o
f T
re
e 
No
de
s
Time Unit
HTM
RG
(a) Average Number of Tree Nodes
 0.65
 0.7
 0.75
 0.8
 0.85
 0.9
 4000  5000  6000  7000  8000  9000  10000
H
it 
R
at
e 
of
 P
re
di
ct
io
n
Time Unit
HTM
RG (δMSL)
(b) Hit Rate of Prediction
Figure 4: Comparison of HTM and RG.
levels hierarchy, and 10*10 low-end sensor nodes in each level-0
cluster. In our group mobility model, a logical group pilot is
ﬁrst generated for a group and the objects in a group follow
their group pilot according to two parameters: variation period
and variation radius. For every variation period, an object will
choose a random direction to move the distance of variation
radius away from the group pilot. The variation radius of each
objects is uniformly distributed from 0 to maxV R. The group
pilot will repeatedly visit those speciﬁed locations by turns.
In our experiments, there are 30 objects and one group pilot
for objects to follow. The variation period is set to 3 and
maxV R is set to 4. The OTSN works for 10000 time units.
HTM collects the moving records of objects in the initial 3000
time units. After that, the cluster heads are in the prediction
phase. For our method, the distance threshold δt = 2.5, the
spatial proximity τt = 2 and ρ = 0.4.
4.2 Performance Comparison
In this section, we compare the storage cost and prediction
accuracy of our proposed method and HTM. Speciﬁcally, the
average number of tree nodes is deﬁned as Total Tree Nodes
Number of Objects
,
which is used to measure the average storage cost. Hit rate of
prediction is deﬁned as Total Correct Prediction
Total Prediction
.
The storage cost of HTM and RG are shown in Figure 4(a).
At the 3000-th time unit, the average number of tree nodes
of RG signiﬁcantly decreases because cluster heads cluster ob-
jects and preserve only a PST for each group. Clearly, RG
outperforms HTM in terms of storage costs. Figure 4(b) shows
that RG has slightly lower hit rate of prediction than HTM.
However, in the worst case, the hit rate of HTM is only 5%
higher than RG. We could conclude that a plenty of storage
cost reduction outweighs the slight loss of prediction accuracy.
4.3 Sensitivity Analysis
We now examine the impact of the distance threshold δt for
distance δMSL, and the spatial proximity threshold τt. In or-
der to emphasize the storage cost reduction, we introduce the
reduction rate, which is deﬁned as
 0
 20
 40
 60
 80
 100
 0  1  2  3  4  5  6  7  8
R
ed
uc
tio
n 
Ra
te
 (%
)
Dissimilarity Threshold δt
RG (τt = 1)RG (τt = 2)RG (τt = 3)
(a) Reduction Rate
 0.7
 0.75
 0.8
 0.85
 0.9
 0.95
 1
 0  1  2  3  4  5  6  7  8
H
it 
R
at
e 
of
 P
re
di
tio
n
Dissimilarity Threshold δt
HTM
RG (τt = 1)RG (τt = 2)RG (τt = 3)
(b) Hit Rate
Figure 5: The impact of δt and τt on reduction rate
and hit rate.
Total Tree NodesHTM−Total Tree NodesRG
Total Tree NodesHTM
, to measure how much stor-
age cost can be reduced. In the meantime, we also discuss the
hit rate of prediction aﬀected by diﬀerent parameter settings.
In Figure 5(a), the reduction rate increases when δt or τt
increases. With larger δt or τt, an object is more likely to form
a group with other objects. Thus, more storage cost of PSTs
can be reduced. Also, it can be seen in Figure 5(b) that the
hit rate of prediction decreases when the distance threshold δt
or the spatial proximity threshold τt is larger.
5. CONCLUSION
In this paper, we explore group mobility of objects to reduce
the cost of maintaining PSTs in OTSNs. First, to cluster ob-
jects with similar moving behaviors, we ﬁrst deﬁne a distance
function between PSTs to distinguish whether the moving be-
haviors of objects are similar or not. Furthermore, we proposed
Algorithm DP to compute the distance between two PSTs in
a dynamic programming manner. Based on the distance be-
tween PSTs, we proposed a clustering algorithms RG to group
moving objects. In order to select the r-PST for a group, we
proposed a method to select the PST which can reduce the
storage cost and maintenance good prediction accuracy. Ex-
periments were conducted to evaluate the performance of our
proposed methods. Experimental results show that the pro-
posed methods not only eﬀectively reduce the storage cost but
preserve the prediction accuracy.
6. REFERENCES
[1] H. T. Kung and D. Vlah. Eﬃcient Location Tracking Using Sensor
Networks. In Proc. of WCNC, volume 3, pages 16–20, March 2003.
[2] K. Oﬂazer. Error-Tolerant Retrieval of Trees. IEEE Transactions
on Pattern Analysis and Machine Intelligence, 19(12):1376–1380,
1997.
[3] W.-C. Peng, Y.-Z. Ko, and W.-C. Lee. On Mining Moving Patterns
for Object Tracking Sensor Networks. In Proc. of MDM, page 41,
2006.
[4] D. Ron, Y. Singer, and N. Tishby. The Power of Amnesia: Learning
Probabilistic Automata with Variable Memory Length. Machine
Learning, 25(2-3):117–149, 1996.
[5] J. Yang and W. Wang. Agile: A General Approach To Detect
Transitions In Evovling Data Streams. In Proc. of ICDM, pages
559–562, 2004.
Exploiting Spatial and Data Correlations for Approximate
Data Collection in Wireless Sensor Networks
Chih-Chieh Hung Wen-Chih Peng York Shang-Hua Tsai
National Chiao Tung University
Hsinchu, Taiwan, ROC
{hungcc, wcpeng, tsaish}@cs.nctu.edu.tw
Wang-Chien Lee
The Pennsylvania State University
State College, PA 16801, USA
wlee@cse.psu.edu
ABSTRACT
Sensor nodes with similar readings can be grouped such that
only readings from representative nodes need to be reported.
However, eﬃciently identifying the sensor groups and their
representative nodes is a very challenging task. In this pa-
per, we propose an algorithm, namely DCglobal, to deter-
mine a set of representative nodes that have high energy
levels and wide data coverage ranges, where a data cover-
age range of a sensor node is the set of sensor nodes whose
reading vectors are very close to the sensor node. Further-
more, a maintenance mechanism is proposed to dynamically
select alternative representative nodes when the representa-
tive nodes have less energy or representative nodes can no
longer capture spatial correlation within their data cover-
age ranges. Through experimental studies on both synthe-
sis and real datasets, we found that DCglobal is able to
eﬀectively and eﬃciently provide approximate data collec-
tion while prolonging the network lifetime.
Keywords:Approximate data collection, wireless sensor net-
works, spatial and data correlation.
1. INTRODUCTION
Recent advances in micro-sensing MEMS and wireless com-
munication technologies have motivated the development of
wireless sensor networks (WSN). Due to the form factor,
sensor nodes are typically powered by small batteries. As
a result, a major research issue in wireless sensor network
is how to extend the network lifetime of WSN. To address
this issue, various energy-saving techniques have been pro-
posed in the literature [2][4][5][9][11][13]. Some argue that
it is suﬃcient to support approximate data collection by
tolerant certain error in readings from sensor nodes [4][9].
Moreover, sensor nodes nearby are usually expected to have
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
Copyright 200X ACM X-XXXXX-XX-X/XX/XX ...$5.00.
similar readings due to their spatial correlation. Hence, a
set of representative sensor nodes (denoted as r-nodes) can
be used to approximate the readings of a monitored region.
By rotating the role of representative nodes, the network
lifetime of WSN can be extended.
Some research eﬀorts have been elaborated on exploiting
spatial and data correlation for approximate data collections
[7][9]. Explicitly, to capture similar reading results from spa-
tial correlation between sensor nodes, clustering techniques
can be used. A distance function in the data space of sensor
readings can be used to model the similarity between read-
ings of two sensor nodes. The smaller a distance between
two readings, the more similar they are. Meanwhile, sensor
nodes located spatially close to each other can be identi-
ﬁed by their communication connectivity. Given a speciﬁed
distance threshold, nearby sensor nodes with similar read-
ings are grouped. In [7], the authors proposed a snapshot
query in which only the r-nodes need to report their read-
ings. However, in [7], only one hop neighbor are involved
in the similarity calculation. Moreover, in [9], the authors
proposed to cluster sensor nodes nearby and formulated the
problem as a CLIQUE-COVER problem, where a clique in
the communication graph refers a group of sensor nodes hav-
ing strong data and spatial correlation1. For example, Fig-
ure 1 shows a graph that models the connectivity (represent-
ing closeness) and readings of sensor nodes in the network.
Assume that the Manhattan distance (i.e., the absolute dif-
ference value in their sensing readings) is used as the sim-
ilarity function and an error threshold is 0.5. As shown in
Figure 1(a), the number of r-nodes under snapshot queries
is 6 (i.e., the black nodes are r-nodes). In addition, it can be
seen in Figure 1(b), there are eight disjoint cliques covering
the whole set of vertices in the graph. Consequently, r-nodes
will be used to sample the readings in the network.
In this paper, we argue that selecting r-nodes by solving
a SET-COVER problem can further reduce the number of
selected r-nodes and thus extend the network lifetime. The
SET-COVER problem is deﬁned as follows:
SET-COVER Problem: Given a graph G = (V,E) and
a set S = {S1, S2, ..., Sn}, where Si ⊆ V for each i, ﬁnd
1Given a graph G = (V,E), ﬁnd the minimal number of
disjoint cliques {C1, C2, ..., Ck} such that
⋃k
i=1 Ci = V .
performed for data collection [11][13], which uses a routing
tree to partially aggregate measurements (e.g., MAX, MIN)
on their way to their destination such that the amount of
transmitted data is reduced. However, these works preserve
energy only on some speciﬁed operations. In the second cat-
egory, approximate data collection is performed by building
probabilistic models [3][4]. The authors in [3] explored a
model-driven architecture in which a centralized probabilis-
tic model is used to estimate the readings of sensor nodes by
generating an observation plan to collect appropriate read-
ings of sensor nodes. Also, the authors of [4] exploited
spatial correlation for approximate data collection, where
a replicated dynamic probabilistic model is built for each
clique to minimize the communication from sensor nodes to
the sink. However, in these works, users must deﬁne a prob-
abilistic model to ﬁt collected readings. It is hard to deﬁne
when sensor nodes are deployed in an unfamiliar environ-
ment. In the last category, approximation data collection
is performed without building probabilistic models [7][9]. In
[7], by utilizing spatial correlation, the author derived an ex-
tension of declarative query in sensor networks, called snap-
shot queries. The snapshot queries can be answered through
a data-driven approach by using a linear regression model to
predict the readings of 1-hop neighbors. The authors in [9]
proposed an algorithm, named as EEDC, that is executed
in a centralized server. Based on spatial correlation, EEDC
partitions sensor nodes into disjoint cliques such that sen-
sor nodes in the same clique have similar surveillance time
series. Round-robin scheduling has been employed to share
workload of data collection. In our paper, we exploit data
and spatial correlation for approximate data collection. To
the best of our knowledge, this is the ﬁrst work to formulate
a SET-COVER problem to achieve energy saving in support
of approximate data collection.
3. PRELIMINARIES
To model spatial correlation among sensor nodes, we ﬁrst
deﬁne the reading behaviors of sensor nodes and then the
similarity between two reading behaviors of sensor nodes.
Thus, we have the following deﬁnitions:
Deﬁnition 1. Reading Vector: Assume that the read-
ings of a sensor node si consists of a series of readings in
a sliding window . The readings vector of si is
−→vi (t) =<
xi(t− +1), xi(t− +2), ..., xi(t) >, where xi(t) is the read-
ing sensed by si at the time t.
Clearly, the readings of a sensor node within a sliding win-
dow is represented as a reading vector. Therefore, we can
deﬁne the similarity of two sensor nodes in terms of dis-
tance of their reading vectors. There are a lot of existing
distance functions, such as Euclidean distance, cosine dis-
tance and so on, which are usually application speciﬁc and
task dependent [6]. To simplify our discussions, we employ
the Manhattan distance (i.e., d(si, sj) = |−→vi (t) − −→vj (t)|) in
the following examples.
Given a distance function between two sensor nodes, we
can formally deﬁne data coverage range as follows:
Deﬁnition 2. Data Coverage Range: Given an error
threshold , the data coverage range of sensor node si, de-
noted as Ci, is the set of sensor nodes such that sensor node
sj in Ci if and only if there exists a sequence of sensor nodes
< si = s0, s1, ..., sk = sj > for k ≥ 0, st directly communi-
cates with st+1 and d(si, st) ≤  for 0 ≤ t ≤ k − 1.
For example, in Figure 1(b), suppose  to be 0.5. E is
in the data coverage range of sensor node A because there
exists a sequence of sensor node < A,B,E > such that A
can communicate with B and B can communicate with E.
In addition, d(A,B) = 0.3 ≤ 0.5, and d(A,E) = 0.3 ≤ 0.5.
Consequently, the data coverage range of sensor node A is
{A,B,E, J,K}.
To analyze the guideline for r-nodes selection to extend
network lifetime, it is necessary to derive a network lifetime
model. Here, the same concept in [1] is used for modeling.
Let G = (V,E) be the communication graph of a WSN, S be
the set of sensor nodes, Ei be the energy level of sensor node
si, and Ni be the set of neighbor sensor nodes of sensor node
si. Assume that the transmission energy required for sensor
node si to transmit an information unit to its neighboring
sensor node sj is pij . To indicate whether sensor node si and
sj involve into data collection or not, Iij(k) is deﬁned as the
indication random variable, where Iij(k) = 1 if si transmits
an information to sj when involving into data collection of
the kth time. Otherwise, Iij(k) = 0.
Following the notation above, given the frequency for data
collection f , the lifetime of a sensor node si , T (i), is given
by Ei∑f
k=1
∑
j∈Ni pij×Iij(k)
. In addition to the energy level of
sensor node si, the main factor aﬀecting the lifetime of a sen-
sor node is how many transmission during data collection.
When involving a lot of transmission for data collection (i.e.,
there are a lot of k such that Iij(k) = 1), a sensor node will
soon exhaust its energy and thus its lifetime will be short.
The network lifetime is deﬁned as the length of time un-
til the ﬁrst sensor node runs out its battery. Based on the
deﬁnitions above, the problem of selecting r-nodes can be
formulated as follows:
Problem: Let the error threshold for data collection be
 and data collection frequency be f . Given a set of sensor
node S = {s1, s2, ..., sn} with the associated data cover-
age range {C1, C2, ..., Cn} and energy level of each sensor
node: {E1, E2..., En}2, ﬁnd the set of r-nodes R ⊆ S to
maximize the network lifetime of WSN under the constraint⋃
si∈R Ci = S.
Intuitively, the size of R will signiﬁcantly aﬀect the life-
time because only r-nodes have to report their readings.
Moreover, to extend the network lifetime, the sensor nodes
with higher energy levels should have higher priority to be-
come r-nodes. Thus, a strategy for selecting r-nodes is to
give high priority to the sensor nodes with high energy lev-
els.
4. DCGLOBAL: ALGORITHMFORDETER-
MINING R-NODES WITH GLOBAL IN-
FORMATION
In Section 4.1, we propose algorithm DCglobal to select r-
nodes for extending network lifetime. The sink ﬁrst requires
sensor nodes to report their readings and energy levels. Once
collecting global information at the sink, DCglobal is able to
determine the set of r-nodes. Then, the sink broadcasts the
2In this paper, we discretize remaining energy into levels.
N, (A,F,S), (L,H), (B,C,G,M,O,P,Q,R), (D,I), E, J, K1
2
3
4
N
S, (L,H), (M,R) N,A,F,S
(F,S), (L,H), (C,G,M,R), D, K N,A,F
(A,F,S), (L,H), (B,C,G,M,R), D, E, K N,A
P list R
(a)
A
8
B
7
C
7
D
6
E
5 8
G
7
H
I
6
J
5
K
3
L
8
M
9
O
7
P
7
Q
7
N
F
R S
8
7
7 8
(b)
Figure 2: An illustrative example: (a) running pro-
cedure and (b) results
sink does not collect information from the network. Thus,
every sensor node in the network should keep monitoring the
variation of the environment. Speciﬁcally, every sensor node
si maintains its current reading vector
−→vi (t) at the current
time t and the reading vector −→vi (tp) at the time tp when
announced by its r-node. Once discovering the distance be-
tween −→vi (t) and −→vi (tp) larger than , a sensor node si will
notify its r-node. The r-node asks each sensor node in its
data coverage range to send their reading vectors at time tp
to the sink. Thus, the sink can verify whether the r-node
is valid or not. Depending on the validity of an r-node, the
diﬀerent maintenance operations will be executed as follows.
Finding substituting r-nodes
For a valid r-node, it still represents the sensor nodes in its
data coverage range. However, if the energy level of a valid r-
node is one level lower than the previous energy level (when
it became a r-node), this r-node should be substituted. Note
that if the data coverage ranges of r-nodes to be replaced are
adjacent to each other, we can select substitutes for these
r-nodes at the same time in order to reduce the number of
substituting r-nodes. To simplify our discussion, a valid r-
node needed to be replaced is abbreviated as a valid r-node
for the rest of this paper.
Here, we discuss a notion of Shared Representative Neigh-
bor (abbreviated as SRN). The SRN represents the number
of common sensor nodes covered by a sensor node and a r-
node. For example, in Figure 1(b), E can cover {A,B,E,F,J,K}
and F can cover {B,C,D,E,F,G,K}. The SRN between E and
F is 1 since B is the common sensor node covered by E and F
(note that the SRN between E and F does not count E and F
themselves). The SRN measures the degree of data coverage
range overlapping between a sensor node and a r-node. If a
sensor node has a large SRN value to a r-node, their data
coverage ranges are highly overlapping. Intuitively, the sen-
sor node with high SRN to a r-node is suitable for replacing
the r-node and thus assigned to substitute a r-node.
To exploit SRN in selection of substituting r-nodes, a DC
A
7
B
7
C
7
D
6
E
5
G
K
F
3
7
7
(a)
51
31
3
3
1
1
A
7
B
7
C
7
D
6
E
5
G
K
F
3
7
7
(b)
Figure 3: An illustrative example: (a) DC graph (b)
SRN graph
graph is constructed to reﬂect the data coverage of sensor
nodes in adjacent data coverage ranges of valid r-nodes. A
DC graph is deﬁned as follows:
Deﬁnition 4. DC Graph: Let {s1, s2, ..., sm} be the
valid r-nodes with their data coverage ranges adjacent to
each other. The DC graph for {s1, s2, ..., sm} is a graph
GDC = (VDC , EDC), where VDC =
⋃m
i=1 Ci and (si, sj) ∈
EDC if si covers sj.
Following the example in Figure 2(b), suppose that valid
r-nodes needed to be replaced are A and F, where their en-
ergy levels are reduced to level 7. The corresponding DC
graph is shown as Figure 3(a). Once obtaining a DC graph,
we can construct the SRN graph for valid r-nodes with ad-
jacent data coverage ranges:
Deﬁnition 5. SRN Graph: Let {s1, s2, ..., sm} be the
valid r-nodes with their data coverage ranges adjacent to
each other. The SRN graph for {s1, s2, ..., sm} is deﬁned to
be a weighted graph GSRN = (VSRN , ESRN ), where VSRN =⋃m
i=1 Ci and (si, s) ∈ ESRN with weight w if s has w com-
mon neighbors with a r-node si in the DC Graph GDC .
For example, as shown the DC graph in Figure 3(a), sensor
node K has ﬁve common neighbors, (i.e., B, C, D, E, and
G), to the valid r-node F. Thus, there is an edge (F, K)
with weight 5 in the SRN graph. In a similar way, the
corresponding SRN graph can be constructed as shown in
Figure 3(b).
Based on the SRN graph and the energy levels of sensor
nodes, the substituting r-node(s) can be selected as follows:
among the sensor nodes with the highest energy levels, the
sensor node with the largest total weight of each edge con-
nected to it in the SRN graph is selected to be the substitut-
ing r-node. Then, sensor nodes covered by it are removed
from the DC graph. This step is repeated until the DC
graph is empty.
For example, in Figure 3(b), among the sensors with the
highest energy level 7, G owns the largest SRN value 3,
 400
 600
 800
 1000
 1200
 1400
 1600
 1800
 2000
 0.2  0.4  0.6  0.8  1  1.2  1.4  1.6  1.8  2
N
et
w
or
k 
Li
fe
tim
e
Error Threshold
"DCglobal"
"EEDC"
"snapshot"
(a)
 0
 100
 200
 300
 400
 500
 600
 700
 0.5  1  1.5  2  2.5  3  3.5  4
N
et
w
or
k 
Li
fe
tim
e
Error Threshold
"DCglobal"
"EEDC"
"Snapshot"
(b)
Figure 5: Network lifetime over variant error
threshold under (a)synthesis and (b)real datasets
thesis dataset, Figure 5(a) shows that the network lifetime
increases when the error threshold increases. This is be-
cause that when the error threshold is loose, the number
of r-nodes will decrease and thus the network lifetime is
extended. On the other hand, for real data, Figure 5(b) in-
dicates that the lifetime for DCglobal increases when error
threshold increases. In this case, the lifetime of EEDC and
Snapshot do not increase signiﬁcantly. Note that when the
error threshold is between 0.5 to 2, the trend of the lifetime
is not signiﬁcant for EEDC and DCglobal. However, when
the error threshold exceeds to 2.5, the trend of all algorithms
is stable. Thus, in this environment, a reasonable guess to
error threshold is around 2.5.
5.4 Environmental Variation
Finally, we evaluate the performance of these algorithms
under environmental changes. To control the environmental
variation, we use synthesis data only to show the results.
In Figure 6(a) and 6(b), the impact of varied environments
is shown for each algorithm by diﬀering the event reading
changing interval, from unstable to stable. DCglobal per-
forms well, resulting longer network lifetime whether the
environment is unstable or stable. We can see that the life-
time of other algorithms do not change too much. How-
 0
 500
 1000
 1500
 2000
 2500
 5  10  15  20  25  30  35  40  45  50
N
et
w
or
k 
Li
fe
tim
e
Environment Change Frequency
"DCglobal"
"EEDC"
"Snapshot"
"Naive"
(a)
 0
 50
 100
 150
 200
 5  10  15  20  25  30  35  40  45  50
N
um
be
r o
f R
-n
od
es
Environment Change Frequency
"DCglobal"
"EEDC"
"Snapshot"
(b)
Figure 6: (a) Network lifetime under the environ-
mental change (b) Number of r-nodes over variant
environment change frequency
ever, DCglobal can extend the network lifetime when the
environment becomes stable. Also, it can be seen that the
number of r-nodes selected by DCglobal is less than EEDC
and Snapshot. It also supports our claim that DCglobal,
an algorithm based on solving a SET-COVER problem, is
eﬀective to reduce the number of r-nodes. Thus, we can con-
clude that DCglobal can adapt to dynamically environment
changing.
6. CONCLUSIONS
In this paper, we addressed the problem of selecting a set
of r-nodes for approximate data collection in WSN. Speciﬁ-
cally, we argued that the number of r-nodes can be reduced
by solving a SET-COVER problem. Moreover, by exploit-
ing spatial and data correlation, data coverage range of each
sensor is determined. By taking energy level and data cov-
erage range of each sensor node into account, DCglobal can
further reduce the number of r-nodes, thereby extending the
network lifetime. In addition, the maintenance mechanism
for DCglobal was proposed to eﬃciently select substituting
r-nodes for r-nodes with less energy and to reﬂect the change
of environments. Experimental results on both synthesis
and real datasets show that DCglobal is able to signiﬁcantly
附錄七： 
 
Optimizing Parallel Itineraries for 
KNN Query Processing in Wireless 
Sensor Networks 
 
 
 
T.-Y. Fuo, W.-C. Peng and W.-C. Lee 
Proceedings of the ACM 16th International Conference on Information 
and Knowledge Management (CIKM), Lisboa, Portugal, Nov. 6-9, 2007 . 
ergy eﬃciency and response latency) from applications, it’s
important to design itineraries that meet speciﬁc application
requirements. In this paper, we propose a new itinerary-
based KNN query processing technique that derives diﬀerent
itineraries aiming at optimizing two performance criteria,
response latency and energy consumption.
Speciﬁcally, the proposed new technique is based on opti-
mized parallel concentric-circle itineraries (thus named as
PCIKNN ). PCIKNN is designed to allow a KNN query
propagated in multiple concurrent threads. Clearly, with a
larger number of concurrent KNN threads propagated, both
the response latency and the energy consumption are sig-
niﬁcantly reduced. Furthermore, analytical models for the
latency and the energy consumption of PCIKNN are de-
rived. By optimizing the latency latency and the energy con-
sumptions, PCIKNN derive itineraries with two modes (i.e.,
min latency mode and min energy mode), speciﬁcally tai-
lored to minimize response latency or energy consumption,
respectively. Additionally, an important issue for itinerary-
based KNN query processing is to estimate a search bound-
ary covered by derived parallel itineraries. A technique has
been developed to derive accurate boundary estimation in
order to improve performance of our KNN processing. In our
approach, we derive multiple itineraries to facilitate parallel
processing of the query. The performance of PCIKNN is
analyzed mathematically and evaluated through extensive
experimentation based on simulation. Experimental results
show that PCIKNN has better performance and scalability
than the state-of-the-art.
The contributions of this study are summarized as follows:
• An eﬃcient itinerary design approach for in-network
itinerary-based KNN query processing has been devel-
oped. The derived itineraries are tailored to optimize
on response latency and energy consumption.
• A KNN boundary estimation technique is developed
to improve accuracy of KNN query in wireless sensor
networks.
• Analytical models for the performance of our proposal
are developed.
• An extensive performance evaluation is conducted that
shows the superiority of our proposal against other ex-
isting techniques.
The rest of the paper is organized as follows. Preliminar-
ies, including the problem deﬁnition and basic ideas of ex-
isting itinerary-based KNN query processing is introduced.
The design of our PCIKNN technique and analytic models
for two optimization modes are described in Section 3. A
mechanism for KNN boundary estimation is presented in
Section 4. The performance of PCIKNN and other exist-
ing techniques is evaluated in Section 5. Finally, Section 6
concludes this paper.
2. PRELIMINARIES
In this section, the basic assumptions made in this re-
search and the deﬁnition of KNN query are speciﬁed. Then,
the general idea of itinerary-based KNN query processing is
introduced. Finally, the problem addressed in this paper is
presented.
ŪůŪŵŪŢŭġŌŏŏġţŰŶůťŢųź
ŶűťŢŵŪůŨġŌŏŏġţŰŶůťŢųź
Figure 1: Overview of itinerary-based KNN query
processing.
2.1 Overview of Itinerary-based KNN Query
Processing
We assume that sensor nodes in wireless sensor networks
are randomly distributed in a two-dimensional space. Each
sensor is location-aware via GPS or other localization tech-
niques. By periodically inter-exchanging information among
sensor nodes nearby, a sensor node is able to maintain its
own neighboring information. As mentioned before, KNN
query processing provides a way to sample the data from
sensor nodes located in the proximity of a given query lo-
cation. We now deﬁne the KNN query in wireless sensor
networks as follows:
Deﬁnition: (K Nearest Neighbor query). Given a set of
sensor nodes M and a geographical location (denoted as
a query point q), ﬁnd a subset M ′ of k nodes (M ′ ⊆ M,
|M ′| = K) such that ∀n1 ∈ M ′ and ∀n2 ∈ M − M ′,
dist(n1, q) ≤ dist(n2, q), where dist represents the Euclidean
distance function.
KNN queries can be issued at any sensor node (called
source node), which is the starting node for in-network query
processing. The source node is also responsible for reporting
the query result.
As mentioned before, itinerary-based KNN query process-
ing techniques are infrastructure-free, thereby saving a con-
siderable amount of maintenance overhead. Without loss of
generality, an itinerary-based KNN query processing algo-
rithm typically consists of three phases: i) routing phase;
ii) KNN boundary estimation phase; and iii) query dissem-
ination phase. Figure 1 shows an overview of the itinerary-
based KNN query processing. Details of the three query
processing phases are described below:
Routing phase: Figure 1(a) illustrates the routing phase.
Explicitly, when a KNN query Q is issued at a source node,
the query Q that speciﬁes the query point q and the sample
size K is routed to the sensor node nearest to the query point
q (referred the home node) by using a geo-routing protocol
such as GPSR [2][3]. In the routing phase, partial network
information, such as the number of nodes and the area cov-
ered by communication ranges of relay messages, is collected
while the query is enrouting towards the home node.
Given a query point q and an estimated KNN boundary,
the area within the boundary can be divided into multiple
concentric-circle itineraries. Let Ci denote the ith circle with
a radius w × i, where w is the itinerary width, the distance
between itineraries. Similar to [12][14], w can be set as
√
3
2
r,
where r is the transmission range of a sensor node. In order
to propagate KNN query along concentric-circle itineraries,
we partition the KNN boundary into multiple sectors. Fig-
ure 3(a) shows an example of concentric-circle itineraries,
where the number of sectors is 4. For each sector, we have
three types of itinerary segments: 1) a branch-segment, 2)
a set of peri-segments, and 3) return-segments. As shown
in Figure 3(b), a branch segment is a straight line in each
sector, peri-segments are portions of concentric-circles and
the return-segments are the boundary lines among sectors.
With these segments of itineraries, KNN query are concur-
rently executed at these segments of itineraries. It is worth
mentioning that the number of concurrent KNN query prop-
agated are maximized in our PCIKNN.
In light of itinerary segments derived above, a KNN query
is ﬁrst propagated along with branch-segments in each sec-
tor. Along the branch-segment, a Q-node broadcasts a probe
message and aggregates the partial results from D-nodes
within the region width of w. Then, for each sector, when
the KNN query reaches one of concentric-circles, two KNN
query threads are forked to propagate along the two peri-
segments, while the original KNN query continues to move
along the branch-segment. This process repeats at outer
concentric-circles, which increases the number of the con-
current threads for executing the KNN query. To prop-
agate a KNN query in two peri-segments, the Q-node in
the branch segment ﬁrst ﬁnds two Q-nodes in peri-segments
and evenly divide the partial query result collected to these
two Q-nodes. Then, these two Q-nodes will start perform-
ing KNN query dissemination with peri-segments. When
KNN queries propagating along peri-segments arrive the
boundary lines of their sectors, KNN queries with data col-
lected are returned back to the home node through return-
segments. Once the home node receives more KNN query
results, it is able to decide whether to continue KNN query
propagation or not. This leads to more precise KNN query
results in PCIKNN. It can be seen by exploring parallel
concentric-circles, the number of concurrent KNN query prop-
agated is maximized. Furthermore, due to the high paral-
lelism of PCIKNN, PCIKNN achieves high performance in
terms of response time and energy consumption.
3.2 Concurrent Query Threads Comparison
In the following, we will use an example to illustrate the la-
tency and energy performances of IKNN, DIKNN and PCIKNN
in terms of the number of concurrent KNN query propa-
gated. Assume that the KNN boundary is known and all
these algorithms are performed within this boundary. In our
illustrative example, the radius R of KNN boundary is set
to 4w and there are 4 concentric-circles. First, we analyze
the latency performances which is directly aﬀected by the
number of concurrent KNN query propagated. Figure 4(b)
shows the parallel IKNN algorithm proposed in [14], which
has two itineraries. Hence, the number of concurrent KNN
query propagated is 2. For DIKNN and PCIKNN, the num-
ber of sectors aﬀects the performances directly. Assume that
the number of sectors is set to 4, which is bigger than the
number of itineraries in parallel IKNN. Thus, in DIKNN, the
S1
S2 S4
S3
(a)
KNN boundary
(b)
KNN boundary
Figure 4: Itineraries of DIKNN and IKNN.
concurrent KNN query propagated is 4 (as shown in Figure
4(a)). In PCIKNN, each itinerary in the sector has a branch-
segment and two peri-segments for each concentric circle for
query propagation. Therefore, the maximal number of con-
current KNN query propagated is 44 (branch-segment×1,
peri-segments×8 and return-segment×2 in each sector) for
4 itineraries shown in Figure 3. Comparing these three algo-
rithms, PCIKNN has the largest number of concurrent KNN
query propagated. As a result, it is expected to have better
latency performance than others.
Second, for the energy performance, we evaluate the av-
erage length of a KNN query propagated to estimate the
energy consumption. When an itinerary is longer, the en-
ergy consumed for carrying data increases faster. Thus,
it has lower total energy consumption and better energy
performance if the average length of a KNN query prop-
agated is shorter. All algorithms have the total length of
concentric-circle itineraries. The total length of concentric-
circle itineraries is formulated as follows:
∑R
w
i=1 2× π × (i− 12 )× w
In our example, since R is set to 4w, the total length of
concentric-circles is thus determined as 16πw (i.e., 2π×w×
(0.5 + 1.5 + 2.5 + 3.5) = 16πw). In parallel IKNN, the total
itinerary length is the sum of concentric-circles and addi-
tional branch-segments length which is 3.5w in each sec-
tor. Consequently, the average length of a concurrent KNN
query propagated in IKNN is 16πw+2×3.5w
2
= 28.63w. In
DIKNN, the total length of itineraries is the sum of the
total length of concentric-circles and additional branch seg-
ments (i.e., 4). Since there are four KNN query propagated,
the average itinerary of each KNN query is calculated as
16πw+4×3.5w
4
= 16.06w. Furthermore, with the number of
sectors to be 4, the total length of itineraries in PCIKNN is
estimated as 16πw+12×3.5w, which consists of concentric-
lengths, branch-segments and return-segment. Explicitly, a
sector has a branch-segment, two return-segments with their
length as 3.5w. However, though the length of itineraries is
larger, the total number of concurrent KNN query prop-
agated is also larger. In Figure 3(a), there are 44 KNN
query propagated. As a result, the average itinerary length
for a KNN query propagated is 16πw+12×3.5w
44
= 2.097w.
Among the three algorithms, PCIKNN has the smallest av-
erage itinerary length for a KNN query. Thus, PCIKNN
should have the best energy performance. The results are
illustrated in Table 1.
3.3.3 Minimum Energy for PCIKNN
As mentioned above, a long itinerary length shall incur
more energy consumption. However, the energy consump-
tion of PCIKNN should consider the energy consumption
on the query propagation and data collection along with
branch-segments and return-segments. Explicitly, a small
number of sectors leads to long itineraries in each sector, in-
curring heavy energy consumption overall in carrying data
collected from D-nodes. On the contrary, a large number of
sectors increases the number of branch-segments and return-
segments, incurring more energy consumption on query prop-
agation and data collection. Thus, an optimal number of
sectors can be derived to minimize the energy consumption.
Generally speaking, the energy consumption of PCIKNN in-
volves two parts in each itinerary segment: 1) Data collected
from D-nodes should be carried hop-by-hop along with KNN
query. 2) KNN query is propagated along with Q-nodes.
Without loss of generality, the energy consumption is mod-
eled as the communication cost in terms of the number of
bits transmitted among sensor nodes. Thus, the energy con-
sumption of PCIKNN is the sum of energy consumption
corresponding to branch-segment, peri-segment and return-
segment of all sectors. Since there are multiple concentric-
circle itineraries in PCIKNN, the energy consumption on
the type-segment in the ith concentric-circle itineraries is
expressed by energytype,Ci . For example, the energy con-
sumption of peri-segment itineraries in the ﬁrst concentric-
circle is represented as energyperi,C1 . Consequently, we have
energy =
∑R/w
i=1 (S × (energybranch,Ci + energyperi,Ci +
energyreturn,Ci)),
where the number of concentric-circles is R
w
.
The energy consumption is modeled as Ehop×Bits, where
Ehop is the expected number of hops and Bits is the energy
consumption to transmit one data bit per hop. Let Etypehop,Ci
denote the expected number of hops in the type-segment on
Ci. For example, Ebranchhop,Ci is the expected number of hops in
the branch-segment on Ci. Furthermore, EtypeDnum represents
the expected number of D-nodes of a Q-node in the type-
segment. For computation simpliﬁcation, we simplify the
radius of Ci is i × w. In the following, we will derive the
energy consumption in each itinerary segment.
Note that the energy consumption in each segment con-
sists of D-nodes data carrying energy and Q-nodes query
propagation energy. For the energy consumption for the
branch segment on Ci, we could have the following formula:
Ebranchhop,Ci × (Hsize + (EbranchDnum ×Dsize))×Bits,
where Ebranchhop,Ci = 1, E
branch
Dnum
= 0 since Q-nodes are assumed
to be connected hop-by-hop along with a branch-segment
and D-nodes data collected are divided into peri-segments.
Similar, we could derive the energy consumption in the
peri-segment as follows:
2× ((Eperihop,Ci ×Hsize) + ((
∑Eperi
hop,Ci
j=1 (j × EperiDnum))×
Dsize))×Bits,
where Eperihop,Ci =
2× π × i× w
2× S × Er and E
peri
Dnum
= Er × w × d.
Since we have two return-segments in each sector, the en-
ergy consumption is modeled as follows:
2× Ereturnhop,Ci × (Hsize + (EreturnDnum,Ci ×Dsize))×Bits,
 5000
 5500
 6000
 6500
 7000
 4  5  6  7  8  9  10  11  12
qu
er
y 
la
te
nc
y
number of sectors
Analytical Result
Latency
Figure 6: Minimum latency validation.
 0.46
 0.48
 0.5
 0.52
 0.54
 4  5  6  7  8  9  10  11  12
e
n
e
rg
y 
co
ns
um
pt
io
n
number of sectors
Analytical Result
Energy
Figure 7: Minimum energy validation.
where Ereturnhop,Ci = i, E
return
Dnum,Ci
= Eperihop,Ci × EperiDnum .
Putting the above formulas together, we could further uti-
lize diﬀerentiation to derive the optimal number of sectors so
as to minimize the energy consumption of PCIKNN. Conse-
quently, the optimal number of sectors is derived as follows:
S =
√√√√ π
2w3d
Er
× (2
R
w
+ 1)
6
×Dsize
Hsize
Model Validation: The simulation environment for model
validation is that there are 1000 sensor nodes randomly dis-
tributed in a 500×500 simulation ﬁeld. Total 100 KNN
queries are issued, where K=300. The simulation results
are shown in Figure 6 and Figure 7. The minimal latency
model determines Slatency =6.4 rounded to 6 is equal to the
experiment minimal latency with S=6. The minimal energy
model derives Senergy =7.1 rounded to 7 also matched the
experiment result with S=7. These comparisons show that
our analysis is pretty accurate. From the formulas derived,
we could easily determine the number of sectors with its
quality very close to the optimized objectives.
4. KNN BOUNDARY ESTIMATION
Obviously, the precision of the KNN boundary estimation
has a direct impact on the performance of itinerary-based
KNN query processing. In this section, we develop a mecha-
nism to estimate KNN boundary. Furthermore, to increase
the accuracy of KNN query, we dynamically adjust KNN
boundary in PCIKNN.
S1
S2 S4
S3
 initial KNN boundary
optimal KNN boundary
updateing KNN boundary
Figure 10: Updating KNN boundary dynamically.
repeated until the number of sensor nodes in KNN boundary
is larger or equal to K. This guarantees the query accuracy
of KNN query.
After estimating the KNN boundary with radius R , KNN
query is then propagated to branch-segments. The network
information obtained in the routing phase (i.e., the total
coverage area A and the number of nodes Num) is sent with
KNN query processing. When KNN query is propagated
along with the branch-segment, local network information
within the segment is accumulated via the above operation
in the routing phase. AB (respectively, NumB) is the cover-
age area (respectively, number of nodes) along the branch-
segment. Consequently, we could derive the network density
by exploring local network information. Hence, the network
density is updated as follows:
Dupdate = (Num+NumB)/(A+AB)
Rupdate =
√
K
Dupdate
By exploiting local network information in each sector,
PCIKNN is able to dynamically adapt KNN boundary. For
example, the gray area in Figure 10 is adapted to node densi-
ties in sectors. Even though this adapted boundary still can-
not guarantee the accuracy of KNN query result, PCIKNN
performs further processing the query results at the home
node and adjusts KNN boundary as needed. Basically, the
home node checks whether the KNN query is satisﬁed by
the collected result or not. If the number of nodes within
the KNN boundary is not larger than K, Q-nodes at the
farthest concentric-circle will further extend one concentric-
circle itinerary to search more number of nodes.
5. PERFORMANCE EVALUATION
We develop a simulation to evaluate the performance of
PCIKNN and other closely related works, i.e., IKNN and
DIKNN. The simulation model and parameter settings are
presented in Section 5.1. The experimental results are re-
ported in Section 5.2.
5.1 Simulation Model
Our simulation is implemented in CSIM[8]. There are
1000 sensor nodes randomly distributed in a 500×500m2 re-
gion. The transmission radius of a node is 40m. For each
sensor node, the average number of neighboring nodes is 20.
The message delay for transmitting or receiving messages is
 0.5
 0.55
 0.6
 0.65
 0.7
 0.75
 0.8
 0.85
 0.9
 0.95
 1
 600  700  800  900  1000 1100 1200 1300 1400 1500
Qu
er
y A
cc
ur
ac
y
Number of Nodes
PCIKNN min_latency
PCIKNN min_energy
DIKNN min_latency
DIKNN min_energy
IKNN
Figure 11: Query accuracy under various density.
30ms. To simplify our experiments, we assume sensor nodes
to be static. For each query, the location of a query point q
is randomly selected. The value of K for each KNN query
is drawn randomly. A KNN query is answered when the
query result is returned to the source node. For each round
of experiment, 5 queries are issued from randomly selected
source nodes. Each experimental result is obtained by aver-
age of twenty rounds of experiments. Three itinerary-based
KNN algorithms are implemented. Algorithm IKNN [14]
exploring one itinerary is adopted while Algorithm DIKNN
[12] with minimum latency is utilized. For fair comparison,
we derive the result of DIKNN with the minimum energy by
selecting the minimum energy from all possible numbers of
sectors in DIKNN. We compare three algorithms in terms
of energy consumption, query latency and query accuracy
under various environment factors such as the network den-
sity, the number of sample size (i,e., K for KNN queries).
These performance metrics are summarized as follows:
Energy Consumption (Joules): The total amount of
energy consumed for processing a KNN query in a simulation
run.
Query Latency (ms): The elapsed time between the
time a query is issued and the time the query result is re-
turned to the source node.
Query Accuracy(%): The percentage ratio of the num-
ber of sensor nodes that are exactly the K nearest sensor
nodes to query point q over the number of sensor nodes in
KNN query results collected.
5.2 Experimental Results
In this section, we ﬁrst investigate the impact of network
density on the three examined algorithms. Then, we study
the scalability of these three algorithms to the value of K.
Finally, we examine the accuracy of boundary estimation.
5.2.1 The Impact of Network Density
First, we investigate the impact of network density to the
performance of the three examined algorithms. Here, the
network density is measured as the number of sensor nodes
deployed in a ﬁxed monitored region (i.e., 500×500m2). We
varied the number of sensor nodes from 600 to 1500. As
a result, the average number of neighbors for each node is
varied from 10 to 30. Figure 11 shows that all three algo-
rithms have better query accuracy when the network den-
sity is increased. However, when the network is sparse (i.e.,
the number of nodes is smaller than 800 nodes), PCIKNN
 0
 0.5
 1
 1.5
 2
 2.5
 3
 3.5
 50  100  150  200  250  300  350  400
Tr
an
sm
is
si
on
 E
ne
rg
y 
Co
ns
um
pt
io
n(J
)
K
PCIKNN min_latency
PCIKNN min_energy
DIKNN min_latency
DIKNN min_energy
IKNN
Figure 16: Energy consumption under various K.
 100
 120
 140
 160
 180
 200
 500  600  700  800  900 1000 1100 1200 1300 1400 1500
se
a
rc
h 
re
gi
on
’s 
ra
di
us
number of nodes
OPTIMAL
PCIKNN
DIKNN
Figure 17: KNN boundary estimation of DIKNN
and PCIKNN.
ever, the boundary estimated in DIKNN does not ﬁt well
with the trend of the optimal KNN boundary. Moreover, in
Figure 17, when the number of nodes is smaller than 800,
the KNN boundary estimated in DIKNN is smaller than
the optimal value because the KNN boundary is large and
the routing path from the source node to the home node
is not long enough to estimate a region contained K sensor
nodes. On the other hand, even though the routing path
is long enough to estimate the KNN boundary, the result is
not precise due to the inaccuracy of coverage areas in rout-
ing path. Figure 17 demonstrates the correctness and the
accuracy of our KNN boundary estimation.
6. CONCLUSIONS
In this paper, we proposed an eﬃcient itinerary-based
KNN algorithm, PCIKNN, for KNN query processing in
the sensor network. PCIKNN disseminates queries and col-
lects data along pre-designed itineraries with high paral-
lelism. We derived the latency and the energy consumption
of PCIKNN and then by optimizing the derived formulas,
we are able to determine the appropriate number of sectors
for PCIKNN. Furthermore, by exploring linear regression,
the KNN boundary estimated is as close as the optimal one.
In addition, PCIKNN is able to dynamically adjust KNN
boundary by considering local network information within
sectors. Furthermore, KNN query is guaranteed to be an-
swered since the home node will decide whether to further
extend the boundary or not based on collected KNN query
result. Extensive experiments have been conducted. Experi-
mental results show that PCIKNN signiﬁcantly outperforms
others in terms of energy consumption, query latency and
query accuracy.
Acknowledgement
Wen-Chih Peng was supported in part by the National Sci-
ence Council, Project No. NSC 95-2221-E-009-061-MY3 and
by Taiwan MoE ATU Program. Wang-Chien Lee was sup-
ported in part by the National Science Foundation under
Grant no. IIS-0328881, IIS-0534343 and CNS-0626709.
7. REFERENCES
[1] A. Guttman. R-Trees: A Dynamic Index Structure for
Spatial Searching. In ACM SIGMOD, pages 47–57,
1984.
[2] B. Karp and T. H. Kung. GPSR: Greedy Perimeter
Stateless Routing for Wireless Networks. In ACM
MobiCom, pages 243–254, 2000.
[3] F. Kuhn, R. Wattenhofer, and A. Zollinger.
Worst-Case Optimal and Average-Case Eﬃcient
Geometric Ad-Hoc Routing. In ACM Mobihoc, pages
267–278, 2003.
[4] S. J. Leon. Linear Algebra with Applications. Prentice
Hall, 2002.
[5] D. Niculescu and B. Nath. Trajectory Based
Forwarding and Its Applications. In ACM MobiCom,
2003.
[6] H. Qi, X. Wang, S. Iyengar, and K. Chakrabarty. High
Performance Sensor Integration in Distributed Sensor
Networks Using Mobile Agents. International Journal
of High Performance Computer Applications,
16(3):325–335, 2002.
[7] N. Roussopoulos, S. Keeley, and F. Vicent. Nearest
Neighbor Queries *. In ACM SIGMOD, pages 71–79,
1995.
[8] H. Schwetman. CSIM user’s guide (version 18).
Mesquite Software, Inc., http://www.mesquite.com.
[9] T. Seidl and H. Kriegel. Optimal Multi-Step k-Nearest
Neighbor Search. In ACM SIGMOD, pages 154–165,
1998.
[10] Z. Song and N. Roussopoulos. K -Nearest Neighbor
Search for Moving Query Point. In International
Symposium on Spatial and Temporal Databases, pages
79–96, 2001.
[11] J. Winter, Y. Xu, and W. C. Lee. Energy Eﬃcient
Processing of K Nearest Neighbor Queries in
Location-aware Sensor Networks. In Mobiquitous,
pages 281–292, 2005.
[12] B. Wu, K. T. Chuang, C. M. Chen, and M. S. Chen.
DIKNN: An Itinerary-based KNN Query Processing
Algorithm for Mobile Sensor Networks. In ICDE, 2007.
[13] J. Xu, Y. Xu, W. C. Lee, and G. Mitchell. Processing
Window Queries in Wireless Sensor Networks. In
IEEE ICDE, 2006.
[14] Y. Xu, T. Y. Fu, W. C. Lee, and J. Winter.
Itinerary-based Techniques for Processing K Nearest
Neighbor Queries in Location-aware Sensor Networks.
Signal Processing, 2007.
Using SensorRanks for In-Network Detection of Faulty
Readings in Wireless Sensor Networks
Xiang-Yan Xiao Wen-Chih Peng Chih-Chieh Hung
National Chiao Tung University
Hsinchu, Taiwan, ROC
{xyxiao, wcpeng, hungcc}@cs.nctu.edu.tw
Wang-Chien Lee
The Pennsylvania State University
State College, PA 16801, USA
wlee@cse.psu.edu
ABSTRACT
In this paper, the problem of determining faulty readings in
a wireless sensor network without compromising detection
of important events is studied. By exploring correlations
between readings of sensors, a correlation network is built
based on similarity between readings of two sensors. By ex-
ploring Markov Chain in the network, a mechanism for rat-
ing sensors in terms of the correlation, called SensorRank,
is developed. In light of SensorRank, an eﬃcient in-network
voting algorithm, called TrustVoting, is proposed to deter-
mine faulty sensor readings. Performance studies are con-
ducted via simulation. Experimental results show that the
proposed algorithm outperforms majority voting and dis-
tance weighted voting, two state-of-the-art approaches for
in-network faulty reading detection.
Categories and Subject Descriptors: H.3.4 [Systems
and Software]: Distributed Systems
General Terms: Algorithms, Design, Reliability
Keywords: faulty readings, wireless sensor networks
1. INTRODUCTION
Sensors are prone to failure in harsh and unreliable envi-
ronments. Faulty sensors are likely to report arbitrary read-
ings which do not reﬂect the true state of environmental phe-
nomenon or events under monitoring. Meanwhile, sensors
may sometimes report noisy readings resulted from interfer-
ences [3]. Both arbitrary and noisy readings are viewed as
faulty readings in this paper. The presence of faulty readings
may cause inaccurate query results and hinder their useful-
ness. Thus, it is critical to identify and ﬁlter out faulty
readings so as to improve the query accuracy.
In this paper, we target at the problem of determining
faulty readings in sensor networks. Obviously, a naive ap-
proach to this problem is to collect all readings to a sink,
where statistical analysis is performed to determine what
readings are outliers. However, this centralized approach
may not be practical due to limited energy budget in sensor
nodes. If readings are sent to the sink all the time, sensor
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiDE’07, June 10, 2007, Beijing, China.
Copyright 2007 ACM 978-1-59593-765-0/07/0006 ...$5.00.
nodes may soon exhaust their energy. Nevertheless, simply
ﬁltering out unusual readings at individual sensor nodes may
compromise monitoring accuracy of some important events.
The goal of this study is to design an energy eﬃcient in-
network algorithm for determining faulty readings without
compromising detection of important events.
The fact that data readings of nearby sensors are similar
can be captured by spatial correlation [6]. Thus, an idea for
determining faulty readings is to exploit this spatial correla-
tion. In other words, if a sensor obtains an unusual reading,
the sensor could inquire its nearby sensors (referred to as
the witness set) by sending the suspected reading to them
in order to determine whether the reading is faulty or not.
Based on the classical majority voting, each sensor (e.g., sen-
sor si) in the witness set makes a judgment by comparing
its own reading with the unusual reading sent by the sus-
pected sensor (e.g., sensor sj). If the diﬀerence between
these two readings exceeds a predeﬁned threshold, si con-
siders the reading sent by sj as faulty and gives a negative
vote to sj . Otherwise, si claims that sj is normal and re-
turns a positive vote to sj . After collecting votes from the
nearby sensors, sj then can conclude whether the reading
is faulty or not. If the number of negative votes is smaller
than that of positive votes, the unusual reading reported by
sj is identiﬁed as a faulty reading. Otherwise, it is viewed
as an observed event. However, this simple majority voting
approach does not work well when the number of faulty sen-
sors increases. To address the problem, two weighted voting
methods has been proposed in the literature [5, 9]. Moti-
vated by an assumption that the closer sensors have more
resemble readings, the weighted voting algorithms give more
weights to closer neighbors in voting (i.e., the weights are
assigned inverse to the distances from a sensor node to its
neighbors).
In this paper, however, we argue that the distance be-
tween two sensors does not fully represent the correlation
between readings of those two sensors. Furthermore, if the
nearest sensor is faulty, the voting result may be seriously
contaminated by this faulty sensor. We refer to this problem
as a domination problem in the paper. Figure 1 illustrates
a sensor network where the neighboring sensor nodes are
linked. Each link is labeled by a weight (determined based
on heuristics adopted by diﬀerent voting methods) that will
be used in voting. Assume that the weights of sensors s2, s3
and s4 are 0.3, 0.4 and 0.9, respectively, and sensor s4 is a
faulty sensor. Obviously, the reading of sensor s1 is identi-
ﬁed as a faulty reading when the weighted voting method is
performed (i.e., 0.3*1+0.4*1+0.9*(-1)=-0.2) where positive
nodes is represented as dist(si, sj). In light of the corre-
lations among sensor nodes in the network, a correlation
network is deﬁned as follows:
Deﬁnition 2. Correlation network: The correlation
network is modeled as a graph G = (V,E), where V repre-
sents the sensor nodes in the deployment region and E =
{(si, sj)|si, sj ∈ V, dist(si, sj) < R and corri,j > 0}. The
weight of an edge (si, sj) is assigned to be corri,j .
Once the correlation network of sensors is constructed
(and maintained), one can easily deduce the correlations
among sensor nodes. Based on the correlation network, we
shall further develop an algorithm to compute SensorRank
for each sensor node, in terms of the correlation with its
neighbors, in the network.
3. SENSORRANK
SensorRank is to represent the trustworthiness of sensor
nodes. By our design, two requirements need to be met in
deriving SensorRank for each sensor.
Requirement 1: If a sensor has a large number of neigh-
bors with correlated readings, the opinion of this sensor is
trustworthy and thus its vote deserves more weight.
Requirement 2: A sensor node with a lot of trustworthy
neighbors is also trustworthy.
These two requirements ensure that 1) a sensor node which
has a large number of similar neighbors to have a high rank;
and 2) a sensor node which has a large number of ’good ref-
erences’ to have a high rank. Given a correlation network
G = (V, E) derived previously, we determine SensorRank
for each sensor to meet the above two requirements.
We model the correlation network as a Markov chain M ,
where each sensor si is viewed as the state i, and the tran-
sition probability from state i (i.e., sensor si) to state j
(i.e., sensor si) is denoted as pi,j and formulated as pi,j =
corri,j∑
k∈nei(i) corri,k
. For example, in Figure 2, p2,3 =
0.1
0.4+0.1+0.7
=
0.083. Based on the above setting, we can formulate Sen-
sorRank of si, denoted as ranki, as follows:
ranki =
∑
sj∈nei(i)
rankj · pj,i
where nei(i) is the witness set of node i.
The computation of SensorRank can be viewed as a ran-
dom walk over the correlation network. Several iterations
is required to perform random walks until a steady state
is achieved (i.e., SensorRanks become stable). Speciﬁcally,
rank
(k)
i is the value of SensorRank at the k-th iterations.
At the beginning, the initial rank
(0)
i is set to 1. Note that
rank
(0)
i can be set to any constant c, and the results will be
c times the value generated when the initial SensorRank is
set to 1. In the ﬁrst round, each sensor node si updates its
SensorRank as rank
(1)
i using the initial SensorRanks of its
neighbors. Now each sensor node has considered the ﬁrst
level neighbors to calculate its SensorRank. In the second
round, each sensor node can indirectly obtain some informa-
tion from the second level neighbors through its ﬁrst level
neighbors since its ﬁrst level neighbors have explored their
ﬁrst level neighbors as well. Therefore, after the kth round,
sensor node si has explored the kth level neighbors and up-
dated SensorRank as rank
(k)
i .
Consider an example in Figure 2. In the ﬁrst round, s3
has some similarity information from its ﬁrst level neigh-
Algorithm 1 SensorRank
Input: a sensor si, and a threshold δ.
Output: ranki for si.
1: rank
(0)
i = 1
2: for k = 1 to δ do
3: for all sj ∈ nei (si) do
4: pi,j =
corri,j∑
sk∈nei(i) corri,k
5: send rank
(k−1)
i · pi,j to sj
6: receive all rank
(k−1)
j · pj,i from every sj ∈ nei (i)
7: rank
(k)
i =
∑
sj∈nei(i) rank
(k−1)
j · pj,i
Figure 2: An example of Sensor Rank.
bors {s2, s4, s9, s10, s11}. Similarly, both s2 and s4 could ex-
change some information with their neighbors. In the second
round, s3 can obtain similarity information from the second
level neighbors {s1, s5} since its ﬁrst level neighbors s2 and
s4 have explored s1 and s5 during the ﬁrst round. If k is
larger, SensorRanks will be more accurate since every sensor
can explore more neighbors. In sensor networks, the com-
putation cost will be larger when the number of iterations
is larger. Therefore, we can limit k to a preset bound δ.
Given a correlation network in Figure 2, we now demon-
strate how to calculate SensorRank. Initially, sensor si sets
its sensorRank rank
(0)
i to 1. For sensor si, si calculates
the trust relations pi,j to the corresponding neighbor sj and
sends rank
(0)
i · pi,j to sj . For example, s3 sends rank(0)3 ·
p3,1 = 1 · 0.53.0 = 0.167 to s1, 0.033 to s2, 0.23 = 0.067 to
s4, and etc. At the same time, s3 receives SensorRanks
from its neighbors. For example, s3 receives rank
(0)
2 · p2,3 =
1 · 0.1
0.4+0.1+0.7
= 0.083 from s2. Upon receiving all the pro-
portion of SensorRank from the neighbors, s3 can update
its SensorRank to rank
(1)
3 .
rank
(1)
3 =
∑
i∈{1,2,4,9,10,11}
rank
(0)
i · pj,i
= 1 · p1,3 + 1 · p2,3 + 1 · p4,3 + 1 · p9,3
+1 · p10,3 + 1 · p11,3
=
0.5
2.1
+
0.1
1.2
+
0.2
1.9
+
0.7
1.5
+
0.8
2.3
+
0.7
1.4
= 1.74
After the ﬁrst round,
{
rank
(1)
i |i = 1, 2, 3, 4
}
={1.13, 0.59,
1.11, 1.33}. In the second round, sensors calculate the values
of SensorRank with the updated values of SensorRank in the
ﬁrst round. For example, s1 now sends rank
(1)
1 ·p1,3 = 1.13 ·
Procedure Neighbor-Diagnosis
Input: a sensor si, its current reading behavior bi (t), and
a threshold σ.
Output: the variable faulty.
1: set deci = 0
2: broadcast bi (t) to the neighbors
3: for all sj ∈ nei (i) do
4: if sim (bi (t) , bj (t)) ≥ σ then
5: votej (i) = rankj
6: else
7: votej (i) = −rankj
8: deci = deci + trij · votej (i)
9: if deci ≥ 0 then
10: return false
11: else
12: return true
Figure 3: An example query for TrustVoting.
If the weight of the positive votes are more than the weight
of the negative votes, deci will be positive which means that
si’s reading is normal and the current reading can be re-
ported. Otherwise, deci is negative, implying that the cur-
rent reading of si is faulty. For example in Figure 3, a
region of sensors is queried (s1, s2, s3, s4 and s5) and four
faulty sensors (gray nodes) exist. SensorRanks of sensors
are shown in square brackets in nodes and the correlation
between sensors are shown on edges. To facilitate presenta-
tion of this example, the plus sign (minus sign) shows that
two sensor nodes have similar (dissimilar) current readings,
and they are going to give the positive (negative) votes to
each other when executing the neighbors’ diagnosis. Con-
sider sensor node s5 as an example, where s5 will receive the
votes from its neighbors (i.e., s1, s4, s6, s7 and s8). It can
be obtained that dec5 = (−1.17) · 0.4 + 1.05 · 0.7 + (−0.77) ·
0.5 + (−0.91) · 0.2 + (−1.05) · 0.4 = −0.72. Therefore, the
reading reported by sensor node s5 is a faulty reading.
4.3 Execution Order of TrustVoting
Since the TrustVoting algorithm is a distributed algo-
rithm, sensors being queried will perform the self-diagnosis
and neighbor-diagnosis procedures individually. Diﬀerent
execution orders have produce diﬀerent results for faulty
detection. For example, consider two execution orders {s1,
s2, s3, s4, s5} and {s5, s1, s2, s3, s4} in Figure 3. Assume
that all the queried sensor nodes have to perform the neigh-
bors’ diagnosis. In the order of {s1, s2, s3, s4, s5}, when
s1 executes TrustVoting, s2, s4 and s5 give negative votes,
while s3 and s8 claim positive votes. As such, dec1 will
be 0.16 and s1 will be identiﬁed as normal. For s2, since
Order Faulty Not faulty
s1, s2, s3, s4, s5 s5 s1, s2, s3, s4
s5, s1, s2, s3, s4 s4, s5 s1, s2, s3
Table 2: Faulty detection under diﬀerent orders.
dec2 = (−1.17) · 0.4+ (−1.43) · 0.1+1.05 · 0.7 = 0.124 , s2 is
identiﬁed as normal. Following the same operations, we ﬁnd
that s4 is also identiﬁed as normal. However, in the order of
{s1, s2, s3, s4, s5}, the result is diﬀerent. When s5 executes
TrustVoting, s5 is identiﬁed as faulty obviously because al-
most all neighbors give s5 negative votes. Therefore, s5 do
not vote for other sensors. Without the vote from s5, s4 is
regarded as faulty since (−1.17)·0.3+0.68·0.7+(−1.43)·0.2 =
−0.161. Table 2 shows the results under two diﬀerent exe-
cution orders. From Table2, not all faulty readings reported
by faulty sensors (i.e., s2, s4 and s5) are detected and diﬀer-
ence executions orders have an impact on the faulty reading
detection.
As such, how to determine an appropriate order to per-
form self-diagnosis and neighbor-diagnosis in algorithm Trus-
tVoting will have an impact on the ﬁnal result. Since algo-
rithm TrustVoting is executed in a distributed manner, we
could use a timer to control the execution order of proce-
dures self-diagnosis and neighbor-diagnosis. Those sensors
having smaller values in their timers will perform ﬁrst. By
exploring SensorRank, we could allow those sensor nodes
with higher SensorRank to perform self-diagnosis and neighb-
or-diagnosis as soon as possible. As pointed out early, sen-
sor nodes with a high SensorRank are likely to have many
similar neighbors, thereby these sensors could be correctly
identiﬁed whether readings are faulty or not. Once sen-
sors reporting faulty readings are detected, these sensors do
not get involved in voting in other sensor nodes. Therefore,
the domination problem can be alleviated since those faulty
sensors with higher weights could be determined as early as
possible.
Clearly, we could determine the order of executing pro-
cedures of self-diagnosis and neighbor-diagnosis according
to SensorRank. However, some highly ranked sensor nodes
may get their ranks from their highly ranked neighbors while
having few neighbors. Therefore, the number of neighbors
should also be taken into consideration. In algorithm TrustV-
oting, timers are set for each sensor in accordance to both
of the SensorRank and the number of neighbors. Speciﬁ-
cally, assume that a time interval will be given in algorithm
TrustVoting. In algorithm TrustVoting, each sensor should
ﬁrst broadcast SensorRank to neighbors. Once receiving
SensorRank values from its neighbors, each sensor should
sort SensorRank values in a decreasing order. Then, each
sensor should determine the order of its SensorRank in such
sorted list. Furthermore, a sensor will have information re-
lated to the number of neighbors from SensorRank values
received. Therefore, we could set timer to be x· t
(n+1)
, where
x is the order of this sensor in a sorted list, n is the number
of neighbors and t is the time interval given. With a smaller
value of timer, procedures of self-diagnosis and neighbor-
diagnosis will executed ﬁrst.
Consider an illustrative example in 3. The timer value for
sensor s3 should be 1 · t7 since sensor node s3 has 6 neigh-
bors and its SensorRank is the highest among SensorRank
values collected (i.e., 6 neighbors and sensor s3). Following
be seen in Figure 6, when δ increases, the faulty detection
rate will increase. This is due to that with a larger number
of iterations, SensorRank is able to have more neighbor-
ing information. Therefore, TrustVoting is able to precisely
identify faulty readings. Furthermore, with the number of
iterations increases, the false positive rate declines. How-
ever, increasing the number of iterations for SensorRank
will incur message transmissions among sensors. In addi-
tion, from Figure 6 and Figure 7, it can be seen that after 3
iterations, the improvements in the faulty detection rate and
the false positive rate are not very signiﬁcant. Therefore, in
the following experiments, we set to number of iterations
for SensorRank to be 3. Clearly, the number of iteration for
SensorRank will be dependent upon the sensing data and
can be empirically determined.
Figure 6: Faulty detection rates with the number of
iterations of SensorRank varied.
Figure 7: Faulty positive rates with the number of
iterations of SensorRank varied.
5.2.3 Impact of Reading Behavior Length
As mentioned earlier, reading of sensors is viewed as a
series of sensing readings within a sliding window Δt. Then,
we conduct experiments to show the impact of Δt. Without
loss of generality, the number of iterations for SensorRank
is set to 3 and the similarity threshold is set to 0.5. The
experimental results are shown in Figure 8 and Figure 9.
Figure 8: Faulty detection rates with Δt varied.
Figure 9: False positive rates with Δt varied.
As can be seen in Figure 8 and Figure 9, the selection of
Δt should judiciously be determined. In Figure 8, the faulty
detection rate tends to increase with the length of reading
behavior. However, the improvement is not signiﬁcant with
larger values of the Δt. On the other hand, in Figure 9, the
false positive rate decreases when the length of the read-
ing vectors increases. However, when Δt is larger than 5,
the false positive rate is increased. Intuitively, when Δt is
small, there are not enough readings for modeling the simi-
larity among sensors, whereas with a larger value of Δt, the
reading vectors of sensors may have more noisy readings.
Therefore, the setting of Δt is also application dependent
and should judiciously selected from the experiments.
5.2.4 Impact of Neighbors
Since TrustVoting is a voting scheme, the number of neigh-
bors will have impact on the eﬀectiveness of TrustVoting.
附錄九： 
 
Optimizing Multiple In-Network 
Aggregate Queries in Wireless 
Sensor Networks 
 
 
 
H.-Y. Yang, W.-C. Peng and C.-H. Lo 
Proceedings of the 12th International Conference on Database Systems 
for Advanced Applications (DASFAA), Bangkok, Thailand, April 9-12, 
2007. 
In order to determine which query tree should be put in the backbone set
and the number of backbones, we ﬁrst formulate the problem of selecting back-
bones and transform this problem into Max-Cut problem. Speciﬁcally, given a
set of queries, we derive a graph, where each vertex represents one query and the
corresponding weight edge denotes the number of messages reduced by sharing
partial results. According to the graph derived, we develop a heuristic algorithm
SB (standing for Selecting Backbones) to derive a cut in which both backbones
and non-backbones are determined. Performance of algorithm SB is compar-
atively analyzed and simulation results show that by sharing partial results,
algorithm SB is able to signiﬁcantly reduce the total number of messages.
A signiﬁcant amount of research eorts have been elaborated upon issues of
in-network query processing for power saving in wireless sensor networks [3][5][6].
Prior works [2][6] explore the feature of in-network aggregation in which sensor
nodes in a routing tree are able to perform aggregate operators. The authors
in [1] proposed in-network materialized view that could be shared by multiple
queries to reduce the number of messages. To the best of our knowledge, no
prior works exploit the feature of sharing partial results of in-network aggregate
queries, let alone formulating the problem of selecting backbones and devising
algorithms to determine backbones for partial result sharing.
The rest of this paper is organized as follows. Preliminaries are presented in
Section 2. In Section 3, we develop algorithm SB for backbone selection. Per-
formance studies are conducted in Section 4. This paper concludes with Section
5.
2 Preliminaries
The goal of this study is to reduce the total number of messages spent for
multiple queries. In order to share partial results, queries with the same aggregate
operator and time duration are considered. Similar to prior works in [6], query
Tl is able to represent as a query tree, denoted as Wl. The leaf nodes of a query
tree are data sources that will report sensing data and intermediate nodes of the
query tree are used to aggregate sensing data from their child nodes. Hereafter,
to facilitate the presentation of our paper, query Tl is referred to as a query
tree Wl= The number of messages spent for a query Tl> expressed by Q(Wl)> is
the number of tree edges in Wl= For query tree Wl, Gl(Vm) represents the partial
result generated at sensor Vm and Ql(Vm) is the number of messages spent for
partial result Gl(Vm)> which is the number of tree edges of the subtree rooted at
sensor Vm .
To facilitate the presentation of this paper, the backbone set (respectively,
the non-backbone set) is expressed by E (respectively, QE). Clearly, by sharing
partial results from backbones, non-backbones are able to reduce a considerable
amount of messages. Denote the number of messages reduced for non-backbone
Wm as U(Wm > E)= Thus, the total number of messages involved for a set of query
trees can be formulated as follows:
Assume that nodes V| and V} are the child nodes of node V{ and both nodes
V| and V} access partial results from backbones. Obviously, since the partial
results of V| and V} is used to aggregate the result on V{, node V{ should
not access the partial result from backbones. For the same reason, it is also
unnecessary to get partial results for the descendants of V| or V}=
In light of Property 1, we have developed a procedure to determine how many
messages could be reduced through the partial result sharing. The algorithmic
form of the proposed procedure is given below:
Procedure R(Wm , E):
1. set \ = ^l5EZl>m =Wr, to determine the union set of sensors from the
auxiliary table ;
2. Generate the power set of \ , denoted as S (\ ), is the set of all subsets of
\ ;
3. ; [ 5 S (\ ), if there exists any ancestor or descendant relationship in [,
prune [ from S (\ );
4. return max;[5S (\ )(
X
Vq5[ and l5E
zl>m(Vp> Vq))
In the beginning, we will determine the set of \ from the auxiliary table.
As described above, the auxiliary table will contain all the detailed information
related to the partial result sharing. Thus, given the backbone set, we could
easily decide the set of \ . In fact, \ contains all the sensors in Wm that could
access the partial results from backbones. In order to enumerate all the possible
scenarios, we should generate the power set of \ , denoted as S (\ )= According
to Property 1, we should avoid redundant message cost and thus, for each set in
S (\ ), we should check whether there is any ancestor and descendant relationship
or not. Note that one could refer to query tree Wm to verify any ancestor and
descendant relationship. As such, the set of S (\ ) has all the possible scenarios
of partial result sharing for Wm . Consequently, the number of messages reduced
for Wm is able to be the maximal value among these possible scenarios.
To evaluate the beneﬁts of selecting query tree Wl as a backbone, we have
the following deﬁnition.
Deﬁnition 1: The backbone gain achieved by selecting Wl as a backbone,
denoted by (Wl)> can be formulated as (Wl) =
P
Wm5(QEWl)U(Wm > E ^ Wl) P
Wm5QE U(Wm > E)=
In light of Deﬁnition 1, we propose a heuristic algorithm SB that iteratively
select backbones according to backbone gains of query trees. Initially, the back-
bone set is empty and the non-backbone set is the set of query trees given.
For each query tree in the non-backbone set, we will calculate the corresponding
backbone gain. Then, the query tree with the maximal backbone gain is included
in the backbone set. Once one query tree is selected as a backbone, we should
update backbone gains for query trees in the non-backbone set. Similarly, ac-
cording to the backbone gains of query trees in the non-backbone set, we will
select the one with the maximal backbone gain as a backbone. Algorithm SB se-
lects the query trees in the non-backbone set iteratively until no additional query
tree is selected in the backbone set. When query trees in the non-backbone set
can be seen in Fig. 1(a), the numbers of messages of scheme Origin, algorithm
SB increase as the number of queries increases. Note that through the partial
result sharing, algorithm SB has smaller numbers of messages involved. Note
that when query trees have more overlapping area of query regions, these query
trees are likely to have more opportunities to share partial results. Now, we ex-
amine the impact of overlapping degree, where the number of queries is set to
10 and the query range of each query is set to 100 x 100 p2. The performance
of Origin and SB with the overlapping degree varied is shown in Fig. 1(b). The
number of messages is reduced in SB as the overlapping degree increases. This
phenomenon agrees with our above statement that with a larger value of the
overlapping degree, query trees have more changes to share partial results. As a
result, the performance of SB is better than that of Origin.
5 Conclusion
In this paper, we exploited the feature of sharing partial results to reduce the
total number of messages. Speciﬁcally, given a set of queries, we derived a graph,
where each vertex represents one query and the corresponding weight edge de-
notes the number of messages reduced by sharing the partial results. According
to the graph derived, we developed heuristic algorithm SB to derive a cut in
which both backbones and non-backbones are determined. Performance of al-
gorithm SB was comparatively analyzed and experimental results show that by
sharing the partial results, algorithm SB is able to signiﬁcantly reduce the total
number of messages.
References
1. K. C. K. Lee, W.-C. Lee, B. Zheng, and J. Winter. Processing multiple aggregation
queries in geo-sensor networks. In Proceeding of the 11th International Conference
on Database Systems for Advanced Applications (DASFAA), pages 20—34, 2006.
2. S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong. TAG: a Tiny AGgrega-
tion service for ad-hoc sensor networks. ACM SIGOPS Operating Systems Review,
36(SI):131—146, 2002.
3. S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong. Tinydb: an acqui-
sitional query processing system for sensor networks. ACM Transactions on Data
Base Systems (TODS), 30(1):122—173, 2005.
4. A. Sharaf, J. Beaver, A. Labrinidis, and K. Chrysanthis. Balancing energy e!ciency
and quality of aggregate data in sensor networks. The VLDB Journal, 13(4):384—
403, 2004.
5. N. Trigoni, Y. Yao, A. J. Demers, J. Gehrke, and R. Rajaraman. Multi-query
optimization for sensor networks. In Proceeding of the ﬁrst IEEE International
Conference on Distributed Computing in Sensor Systems (DCOSS), pages 307—321,
2005.
6. Y. Yao and J. Gehrke. The cougar approach to in-network query processing in
sensor networks. SIGMOD Record, 31(3):9—18, 2002.
A Unified Analytic Framework Based on
Minimum Scan Statistics for Wireless
Ad Hoc and Sensor Networks
Chih-Wei Yi, Member, IEEE
Abstract—Due to limitations on transmission power of wireless devices, areas with sparse nodes are decisive to some extreme
properties of network topology. In this paper, we assume wireless ad hoc and sensor networks are represented by uniform point
processes or Poisson point processes. Asymptotic analyses based on minimum scan statistics are given for some crucial network
properties, including coverage of wireless sensor networks, connectivity of wireless ad hoc networks, the largest edge length of
geometric structures, and local-minimum-free geographic routing protocols. We derive explicit formulas of minimum scan statistics. By
taking the transmission radius as a major parameter, our results are applied to various network problems. This work offers a unified
approach to solve various problems and reveals the evolution of network topology. In addition, boundary effects are thoroughly handled.
Index Terms—Wireless ad hoc networks, wireless sensor networks, minimum scan statistics, random deployment, Poisson point
processes, uniform point processes, coverage, connectivity, grid routing, greedy forward routing, Gabriel graphs, relative
neighborhood graphs.
Ç
1 INTRODUCTION
IN homogeneous wireless ad hoc networks, all wirelessdevices have the same transmission radius r, and two
nodes have a link between them if they are apart from each
other no more than r. A communication session is
established either through a single-hop radio transmission
if the communication parties are within each other’s
transmission range, or through relaying by intermediate
devices otherwise. The induced network topology is called
r-disk graphs, or unit disk graphs (UDGs) if r is scaled to 1.
An r-disk graph over a vertex set V is denoted by GrðV Þ.
Because of no need for fixed infrastructures, wireless ad hoc
networks can be flexibly deployed at low cost for various
missions such as decision making in the battlefield,
emergency disaster relief, and environmental monitoring.
In many applications, such as wireless sensor networks, a
large number of devices need to be deployed in harsh
environments. As a result, deterministic deployment
usually is not feasible, and random deployment is the only
viable solution. Hence, it is natural to model wireless
networks by r-disk graphs over random point sets, and
asymptotic analyses are interesting to the research commu-
nity [1], [2], [3], [4], [5].
In wireless communication systems, receivers can de-
code one signal at a time, so simultaneously arriving signals
are interfered and may cause transmission failure at the
receiver. Due to short transmission ranges of radio
frequency signals, interferences are from nearby nodes.
Therefore, for a receiver, nearby nodes are not only
potential message senders but also interference sources.
Therefore, the number of nodes in one’s vicinity is an
important topological parameter in a network. In this paper,
we introduce an analytical tool called minimum scan
statistics that provide an overall lower bound of a network
for the number of nodes in one’s vicinity.
Let V be a finite point set in a bounded region A, and
C be a convex compact set.1 Let #ðÞ be the cardinality
function. We say C0 is a copy of C, denoted by C0 ﬃ C, if
C0 is obtained from C by reflecting, rotating, and/or
shifting. The minimum scan statistic of V with respect to
scanning set C is the least number of points in V covered
by a copy of C, i.e., minC0ﬃC #ðV \ C0Þ. However, without
further constraints, since the copy of C can be placed
outside of A, the minimum scan statistic is always 0. To
prevent meaninglessness and for applying to various
applications, we may have several variations depending
on supplementary constraints, e.g.
1. C0 must be fully contained in A.
2. C0 must have at least half of its area contained in A.
3. C must be a disk, and the center of C0 must be in A.
4. A has a boundary-free topology such as a sphere or a
square with toroidal metrics.
In this paper, we will derive asymptotics for variations 1, 2,
and 3. Note that variation 1 was the case studied by Auer
and Hornik [6], and variation 4 has similar asymptotics of
variation 1.
In literature, most works on scan statistics studied the
largest number of points covered by scanning sets. To
IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS, VOL. 20, NO. 9, SEPTEMBER 2009 1233
. The author is with the Department of Computer Science, National Chiao
Tung University, 1001 Ta-Hseuh Rd., Hsinchu City 30010, Taiwan.
E-mail: yi@cs.nctu.edu.tw.
Manuscript received 2 Feb. 2008; revised 23 Aug. 2008; accepted 18 Sept.
2008; published online 29 Sept. 2008.
Recommended for acceptance by P. Srimani.
For information on obtaining reprints of this article, please send e-mail to:
tpds@computer.org, and reference IEEECS Log Number TPDS-2008-02-0044.
Digital Object Identifier no. 10.1109/TPDS.2008.220.
1. A set is convex if for any two points u, v in this set, the segment uv is
also contained in it. A set is compact if it is bounded and close.
1045-9219/09/$25.00  2009 IEEE Published by the IEEE Computer Society
Authorized licensed use limited to: National Chiao Tung University. Downloaded on September 18, 2009 at 10:36 from IEEE Xplore.  Restrictions apply. 
. Give a threshold of the grid size for local-minimum-
free grid routing.
The rest of this paper is organized as follows: In Section 2,
we define the notations used in this paper and give a useful
probabilistic lemma. In Section 3, we give asymptotics of
minimum scan statistics. In Section 4, minimum scan
statistics are applied to several problems raised in wireless
ad hoc and sensor networks. Our conclusions are provided
in Section 5. Some complicated mathematical proofs are left
in the Appendix.
2 PRELIMINARIES AND TERMINOLOGIES
In what follows, the disk of radius r centered at x is denoted
by Bðx; rÞ. For a, b 2 IR2 and A, B  IR2, aþ b denotes the
addition of two vectors, and Aþ b ¼ faþ b : 8a 2 Ag. kxk is
the euclidean norm of a point x 2 IR2. jAj is shorthand for
the 2D area of a measurable set A  IR2. If A is a convex
compact set, mcA denotes the mass center of A. In addition,
for a positive real number c, we use cA to denote the set
fmcA þ cðxmcAÞ : x 2 Ag. The diameter of a set A,
denoted as diamðAÞ, is the supreme of the distance between
any two points in the set, i.e., diamðAÞ ¼ supx;y2A kx yk.
The symbols O, , , o, and 	 are defined in Table 1 and
always refer to the limit n!1. An event is said to be
asymptotic almost sure (a.a.s.) if it occurs with a probability
converging to one as n!1. RV is an acronym of random
variable. Table 1 lists notations used in this paper.
Let  be the function over ð0;1Þ defined by
ðÞ ¼ 1 þ  ln. A straightforward calculation yields
0ðÞ ¼ ln and 00ðÞ ¼ 1=. Thus,  is strictly convex and
has the unique minimum zero at  ¼ 1 (see Fig. 1). Let 1 :
½0; 1Þ ! ð0; 1 be the inverse of the restriction of  to (0, 1].
We are interested in the equation  ¼ 1 ð1=Þ, and the
graph of  ¼ 1 ð1=Þ is depicted in Fig. 2. Define a
function L over ð0;1Þ by
LðÞ ¼ 
1
 ð1=Þ; if  > 1;
0; otherwise:

L is a monotonic increasing function of . The curve of LðÞ
is illustrated in Fig. 3.
The following lemma is related to the minimum of a
collection of Poisson RVs.
Lemma 1. Assume that limn!1 nlnn ¼  for some constant  > 0.
Let Y1; Y2; . . . ; YIn be In Poisson RVs with means n:
1. I f In ¼ oðn
ﬃﬃﬃﬃﬃﬃﬃﬃ
lnn
p Þ, t h en f o r any 0 2 ð0; Þ,
mini¼1;...;In Yi  Lð0Þ lnn a.a.s.
2. I f In ¼ Oð
ﬃﬃﬃﬃﬃ
n
lnn
p Þ, t h e n f o r a n y 0 2 ð0; Þ,
mini¼1;...;In Yi  12Lð20Þ lnn a.a.s.
3. If Y1; Y2; . . . ; YIn are independent and In ¼ ð nlnnÞ,
then for any 0 2 ð;1Þ, mini¼1;...;In Yi 
 Lð0Þ lnn
a.a.s.
4. If Y1; Y2; . . . ; YIn are independent and In ¼ ð
ﬃﬃﬃﬃﬃ
n
lnn
p Þ,
then for any 0 2 ð;1Þ,mini¼1;...;In Yi 
 12Lð20Þ lnn
a.a.s.
Proof. A proof is given in Appendix A. tu
YI: A UNIFIED ANALYTIC FRAMEWORK BASED ON MINIMUM SCAN STATISTICS FOR WIRELESS AD HOC AND SENSOR NETWORKS 1235
TABLE 1
Notations
Fig. 1. ðÞ ¼ 1þ  ln .
Fig. 2. The curve is of  ¼ 1 ð1=Þ, and  ¼ 1 is the asymptotics as
 !1.
Fig. 3. The curve is of LðÞ.
Authorized licensed use limited to: National Chiao Tung University. Downloaded on September 18, 2009 at 10:36 from IEEE Xplore.  Restrictions apply. 
sensor u if x is in Bðu; rÞ. If V denote the set of sensors,
we have
coverage ¼ min
x2ID
# u 2 V : x 2 Bðu; rÞf gð Þ
¼ min
x2ID
# u 2 V : u 2 Bðx; rÞf gð Þ
¼Sm3 V ;Bðo; rÞð Þ:
Hence, under this sensingmodel, coverage and theminimum
scan statistic in some sense are the same, and we can use
Theorem 4 to approximate the coverage of sensor networks.
Especially, if  > 1, ID is a.a.s. ðlnnÞ-covered, and if  < 1,
there a.a.s. exists uncovered area. Hence,  ¼ 1 is the
threshold for sensing coverage. Note that although the
boundary effects are not explicitly considered here, they are
implicitly handled by the definition of Sm3.
A graph property is called monotone increasing if all
supergraphs of a graph with these properties also have
these properties as well. Assume rn ¼ ð þ oð1ÞÞ
ﬃﬃﬃﬃﬃ
lnn
n
q
for
some constant  > 0. A constant  is the threshold of a
monotone-increasing property Q if GrnðVnÞ a.a.s. has Q for
any  >  and GrnðVnÞ a.a.s. does not have Q for any  < .
In the rest of this section, based on minimum scan statistics,
we will point out the thresholds of several important
topological properties in wireless networks. For conveni-
ence, let 0 ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
1=ð23
ﬃﬃ
3
p
2Þ
q
 1:6 in the following discussion.
4.1 The Minimum Degree and Connectivity
The minimum degree of a graph G, denoted by 	ðGÞ, is the
minimum nodal degree over all nodes. In r-disk graphs, the
degree of node u is the number of nodes in Bðu; rÞ minus 1.
Hence,
	 GrnðVnÞð Þ ¼ min
u2Vn
degðuÞ
¼ min
u2Vn
# Vn \Bðu; rnÞð Þ  1
Sm3 Vn; Bðo; rnÞð Þ  1:
If we can further prove that 	ðGrnðVnÞÞ is asymptotically
upper bounded by Sm3ðVn; Bðo; ð1þ "ÞrnÞÞ for any given
" > 0, then 	ðGrnðVnÞÞ can be approximated by
Sm3ðVn; Bðo; rÞÞ.
First, consider   1. By Theorem 4, for a given " > 0,
there a.a.s. exists a ð1þ "Þrn-disk with center in ID covering
Sm3ðVn; Bðo; ð1þ "ÞrnÞÞ nodes. Draw a concentric "rn-disk
of this ð1þ "Þrn-disk. The number of nodes in the "rn-disk is
a binomial RV, and it is a.a.s. that at least one node is in the
"rn-disk. For those nodes in the "rn-disk, their nodal
degrees are less than the number of nodes in the
ð1þ "Þrn-disk, i.e., Sm3ðVn; Bðo; ð1þ "ÞrnÞÞ. So, for any  
1 and " > 0, it is a.a.s. that
	 GrnðVnÞð Þ 
 Sm3 Vn; B o; ð1þ "Þrnð Þð Þ:
Now, consider  < 1. According to [10, Theorem 1.2] and
[15, Theorem 9], it is a.a.s. that 	ðGrnðVnÞÞ ¼ 0. Hence, we
have the following theorem.
Theorem 5. Assume rn ¼ ð þ oð1ÞÞ
ﬃﬃﬃﬃﬃ
lnn
n
q
for some constant
 > 0. We have
Pr
	 GrnðVnÞð Þ
lnn
	 Sm3 Vn; Bðo; rnÞð Þ
lnn
 
! 1:
It is known that a random geometric graph is a.a.s. k-
connected if its minimum degree is k [2]. Therefore, the
connectivity of wireless networks can also be estimated by Sm3.
In addition, if  > 1, GrnðVnÞ is a.a.s. ðlnnÞ-connected; and
if  < 1, GrnðVnÞ is a.a.s. disconnected. Therefore,  ¼ 1 is the
threshold for connectivity.
4.2 The Longest Edges of Geometric Structures
Geometric structures such as euclidean minimal spanning
trees, RNGs [16], GGs [17], Yao’s graphs, and Delauney
triangulations are widely used in topology control of
wireless ad hoc networks [18], [19], [20]. The largest edge
lengths of these structures are good references to the
configuration of the maximal transmission radius.
4.2.1 Gabriel Graphs
Two nodes u, v have a Gabriel edge between them
whenever the disk with segment uv as a diameter contains
no other nodes. In addition, since u, v is in ID, the disk has at
least half of its area in ID. Let 
GGðV Þ denote the largest edge
length of the GG over V . According to Theorem 3, a disk
with diameter larger than ð1þ "Þ2
ﬃﬃﬃﬃﬃ
lnn
n
q
for some positive
constant " almost surely contains some nodes. This implies

GGðPnÞ 
 ð1þ "Þ2
ﬃﬃﬃﬃﬃﬃﬃﬃ
lnn
n
r
:
It was further proved in [21] that for any constant " > 0,
lim
n!1
Pr 1 " 
 
GGðPnÞ
2
ﬃﬃﬃﬃﬃﬃ
lnn
n
q 
 1þ "
2
64
3
75 ¼ 1:
So,  ¼ 2 is the threshold of the longest GG edge.
4.2.2 Relative Neighborhood Graphs
If u and v are two nodes, let Luv denote the lens of
Bðu; ku vkÞ \Bðv; ku vkÞ. The segment uv is called the
waist ofLuv.Wehave jLuvj ¼ ðkuvk0 Þ
2. In RNGs, twonodesu,
v have an edge between them if and only if there are no other
nodes in Luv. Let 
RNGðV Þ denote the largest edge length of
the RNG over V . According to Theorem 3, any lens whose
waist length is larger than ð1þ "Þ0
ﬃﬃﬃﬃﬃ
lnn
n
q
for some positive
constant " a.a.s. is not empty. This implies

RNGðPnÞ 
 ð1þ "Þ0
ﬃﬃﬃﬃﬃﬃﬃﬃ
lnn
n
r
:
Furthermore, the following theorem can be proved.
Theorem 6. For any constant " > 0, we have
lim
n!1Pr 1 " 


RNGðPnÞ
0
ﬃﬃﬃﬃﬃ
lnn
n
q 
 1þ "
2
64
3
75 ¼ 1:
So,  ¼ 0 is the threshold of the longest RNG edge.
YI: A UNIFIED ANALYTIC FRAMEWORK BASED ON MINIMUM SCAN STATISTICS FOR WIRELESS AD HOC AND SENSOR NETWORKS 1237
Authorized licensed use limited to: National Chiao Tung University. Downloaded on September 18, 2009 at 10:36 from IEEE Xplore.  Restrictions apply. 
the future. First, the works given in this paper are in the
resolution of ðlnnÞ, but as pointed out in Section 4.4, it is
necessary to study related problems in finer resolutions.
Second, disk models are idealized but not realistic. We
should relax our assumptions and consider more general-
ized channel models. Third, the works given in this paper
are purely analytical. We ought to consider related issues
from application perspectives. The impact of imprecise
location information should also be carefully evaluated.
APPENDIX A
THE MINIMUM OF A COLLECTION OF POISSON RVs
This section is dedicated to the proof of Lemma 1. For any
positive integer n, the factorial of n, n! ¼ 1  2   n, is
estimated by Sterling’s formula
n! 	 ð2nÞ12nnen: ð1Þ
Since
Pr PoðÞ ¼ k 1½ 
Pr PoðÞ ¼ k½  ¼
k1
ðk1Þ! e

k
k! e
 ¼
k

;
for any  2 ð0; 1Þ, as !1, the lower tail distribution of a
Poisson RV can be given by
Pr PoðÞ 
 ½  ¼
X0
k¼
Pr PoðÞ ¼ k½ 
¼
X
k¼0
k! k
 	
k
Pr PoðÞ ¼ ½ 
	
X
k¼0
ðÞk
k
Pr PoðÞ ¼ ½ 
	 1
1 Pr PoðÞ ¼ ½ :
ð2Þ
We further have the following lemma. Remind that
functions  and 1 have been defined in Section 2.
Lemma 8. For any  2 ð0; 1Þ, as !1,
Pr PoðÞ 
 ½  	 1ﬃﬃﬃﬃﬃ
2
p 1ﬃﬃﬃ

p ð1 Þ
1ﬃﬃﬃ

p eðÞ:
Proof. From (2) and then applying (1), we have
Pr PoðÞ 
 ½  	 1
1 

ðÞ! e

	 1
1 
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
2
p ðÞe e

¼ 1
1 
1ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
2
p

eþ
¼ 1
1 
1ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
2
p eþ ln
¼ 1ﬃﬃﬃﬃﬃ
2
p 1ﬃﬃﬃ

p ð1 Þ
1ﬃﬃﬃ

p eð1þ lnÞ
¼ 1ﬃﬃﬃﬃﬃ
2
p 1ﬃﬃﬃ

p ð1 Þ
1ﬃﬃﬃ

p eðÞ:
Thus, the lemma is proved. tu
The next lemma gives a.a.s. bounds for the minimum of a
collection of Poisson RVs.
Lemma 9. Assume that limn!1 nlnn ¼  for some  > 0. Let
Y1; Y2; . . . ; YIn be In Poisson RVs with means n:
1. I f In ¼ oðn
ﬃﬃﬃﬃﬃﬃﬃﬃ
lnn
p Þ and  > 1, t hen fo r any
0 <  < 1 ð1=Þ, mini¼1;...;In Yi > n a.a.s.
2. I f In ¼ Oð
ﬃﬃﬃﬃﬃ
n
lnn
p Þ and  > 12 , t h e n f o r a ny
0 <  < 1 ð 12Þ, mini¼1;...;In Yi > n a.a.s.
3. If Y1; Y2; . . . ; YIn are independent and In ¼ ð nlnnÞ,
then for any  such that 1) 1 ð1=Þ <  < 1 if
 > 1, 2) 0 <  < 1 if  ¼ 1, or 3)  ¼ 0 if  < 1, it
is a.a.s. that mini¼1;...;In Yi 
 n.
4. If Y1; Y2; . . . ; YIn are independent and In ¼ ð
ﬃﬃﬃﬃﬃ
n
lnn
p Þ,
then for any  such that 1) 1 ð 12Þ <  < 1 if  > 12 ,
2) 0 <  < 1 if  ¼ 12 , or 3)  ¼ 0 if  < 12 , it is a.a.s.
that mini¼1;...;In Yi 
 n.
Proof. First of all, we conduct two inequalities. Let Y be a
Poisson RV with mean n, Xi be the indicator of the
event Yi 
 n, and X ¼ X1 þ    þXIn . Then, Xi is a
Bernoulli RV with probability Pr½Yi 
 n, and
minIni¼1 Yi 
 n if and only if X  1. Thus,
Pr min
In
i¼1
Yi 
 n
 
¼ Pr½X  1 
 E½X
¼
XIn
i¼1
E½Xi ¼ In Pr½Y 
 n:
ð3Þ
In addition, by Lemma 8,
In Pr½Y 
 n 	 In 1ﬃﬃﬃﬃﬃ
2
p 1ﬃﬃﬃ

p ð1 Þ
1ﬃﬃﬃﬃﬃ
n
p enðÞ
	 1ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
2
p ð1 Þ
Inﬃﬃﬃﬃﬃﬃﬃﬃ
lnn
p
nðn= lnnÞðÞ
:
ð4Þ
Assume that In ¼ oðn
ﬃﬃﬃﬃﬃﬃﬃﬃ
lnn
p Þ and 0 <  < 1 ð1=Þ.
From (3) and (4),
Pr min
In
i¼1
Yi 
 n
 
	<
1ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
2
p ð1 Þ
In
n
ﬃﬃﬃﬃﬃﬃﬃﬃ
lnn
p n1ðn= lnnÞðÞ:
Since  is decreasing over (0, 1] and 0 <  < 1 ð1=Þ,
we have ðÞ > 1= and
1 ðn= lnnÞðÞ ! 1 ðÞ < 0:
Thus,
Pr min
In
i¼1
Yi 
 n
 
¼ oð1Þ:
So, Lemma 9 (condition 1) is proved.
Similarly, if In ¼ Oð
ﬃﬃﬃﬃﬃ
n
lnn
p Þ and 0 <  < 1 ð 12Þ, we
have
Pr min
In
i¼1
Yi 
 n
 
	<
1ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
2
p ð1 Þ
Inﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
n lnn
p n1=2ðn= lnnÞðÞ;
and
1=2 ðn= lnnÞðÞ ! 1=2 ðÞ < 0:
YI: A UNIFIED ANALYTIC FRAMEWORK BASED ON MINIMUM SCAN STATISTICS FOR WIRELESS AD HOC AND SENSOR NETWORKS 1239
Authorized licensed use limited to: National Chiao Tung University. Downloaded on September 18, 2009 at 10:36 from IEEE Xplore.  Restrictions apply. 
and IDrð1Þ ¼ ID n IDrð0Þ is an annulus centered at o with
radii 1ﬃﬃ

p  r and 1ﬃﬃ

p (see Fig. 5).
B.2 Isodiametric Inequalities
Assume C  IR2 is a convex compact set. The r-
neighborhood of C, denoted as Cr, is the union of all r-disks
with centers in C, i.e., Cr ¼
S
x2C Bðx; rÞ. We use Cr to
denote the set of points of C that are apart from @C by at
least r and use periðCÞ to denote the perimeter of C.
According to the isodiametric inequality [23], [24], [25], the
disk of diameter d has the largest area 14d
2 over all
measurable sets with diameter d and also has the longest
perimeter d over all convex compact sets with diameter d.
Lemma 10. Suppose that C  IR2 is a convex compact set with
diameter at most d. We have
jCt  Cj < dtþ t2 and jCtj  jCj  dt:
Proof.We will explicitly prove the inequalities for C being a
polygon. If C is a convex compact set, the lemma can be
proved by applying the fact that C can be approximated
by a sequence of polygons contained in C. Thus, we
assume C is a polygon.
First, we prove jCt  Cj < dtþ t2. At each vertex of
C, draw two perpendicular lines to the edges of C. The
area Ct  C is divided into disjoint rectangles and sectors
(see Fig. 6). All rectangles are with the same width t, and
the sum of their length is equal to the perimeter of C. All
sectors (marked by x in Fig. 6) are with radius t, and
since the angle of each sector is supplementary to its
interior angle, the sum of their angles is equal to 2. Let l
denote the perimeter of C, then jCt  Cj ¼ ltþ t2. For
diamðCÞ 
 d, we have l < d [25]. So, the inequality
follows.
Now, we prove jCtj  jCj  dt. For each edge of C,
draw a rectangle by it with width t toward the inner of C.
Since C  Ct is fully covered by these rectangles, we
have jCtj  jCj  periðCÞt. For all compact sets with
diameter d, we have periðCÞ < d. Thus, jCrj  jCj 
dt is proved. tu
B.3 Tessellations
A "-tessellation divides the plane by vertical and horizontal
lines into a grid in which each grid cell has width ". Without
loss of generality, we assume the origin is a corner of some
cells. In a tessellation, a polyquadrate is a collection of cells
intersecting with a convex compact set. For example, in
Fig. 7, the shaded cells form a polyquadrate induced by a
polygon. The horizontal span of a polyquadrate is the
horizontal distance measured in the number of cells from
the left to the right. The vertical span of a polyquadrate is
defined similarly but in the vertical direction. If the
diameter of a polygon is d, the span of the corresponding
polyquadrate in a "-tessellation is at most dd"e þ 1.
Lemma 11. Let S be a region composed of m cells. For a positive
constant integer  , the number of polyquadrates with span at
most  and intersecting with S is ðmÞ.
Proof. For a specified cell, since  is a constant, the number
of polyquadrates that contain the cell and have span at
most  is also a constant (depending on ). For each cell
in S, the number of polyquadrates that contain the cell
and have span at most  is ð1Þ. Since there arem cells in
S, the total number of polyquadrates with span at most 
and intersecting with S is ðmÞ. tu
YI: A UNIFIED ANALYTIC FRAMEWORK BASED ON MINIMUM SCAN STATISTICS FOR WIRELESS AD HOC AND SENSOR NETWORKS 1241
Fig. 4. Partition of the unit-area square ID.
Fig. 5. Partition of the unit-area disk ID.
Fig. 6. Ct  C is the shaded area, composed of rectangles and sectors.
Fig. 7. The cells intersecting with the polygon form a polyquadrate.
Authorized licensed use limited to: National Chiao Tung University. Downloaded on September 18, 2009 at 10:36 from IEEE Xplore.  Restrictions apply. 
Proof. Wewill apply a similar argument used in the proof of
Lemma 13. Let rn be the inferior of the (smallest) distance
from the mass center of Cn to @Cn over all Cn 2 Cn, and
"n ¼ 12 ﬃﬃ2p ð1
ﬃﬃﬃ
0

q
Þrn. W e h a v e rn ¼ ð
ﬃﬃﬃﬃﬃ
lnn
n
q
Þ a n d
"n ¼ ð
ﬃﬃﬃﬃﬃ
lnn
n
q
Þ. Divide ID by a "n-tessellation. Obviously,
the distance between any two points in a cell is at mostﬃﬃﬃ
2
p
"n. Consider the collection of polyquadrates each of
which is the maximal one contained in the intersection of
ID and a copy of Cn with at least half area in ID. Let In
denote the number of those polyquadrates, and Yi denote
the number of nodes in the ith polyquadrate. Then,
Sm2ðPn;CnÞ  min
1
i
In
Yi:
Y1; Y2; . . . ; YIn are categorized into two groups. First, we
consider polyquadrates that are contained in copies of Cn
fully contained in ID. All these polyquadrates are with
span at most m ¼ ddiamðCnÞ"n e þ 1 ¼ ð1Þ and with area at
least ð0 þ oð1ÞÞ lnnn . Let I0;n denote the number of
polyquadrates, and Y0;i denote the number of nodes in
the ith polyquadrate. All Y0;i’s are Poisson RVs with
rate at least ð0 þ oð1ÞÞ lnn. From Lemma 11,
I0;n ¼ ð 1"2nÞ ¼ ð
n
lnnÞ. Applying Lemma 1 (condition 1),
it is a.a.s. that
min
I0;n
i¼1
Y0;i  Lð0Þ lnn:
Next, we consider polyquadrates that are contained in
copies of Cn not fully contained but with at least half
area in ID. All these polyquadrates are with span at
most m ¼ ddiamðCnÞ"n e þ 1 ¼ ð1Þ and with area at least
ð120 þ oð1ÞÞ lnnn . Let I1;n denote the number of polyqua-
drates, and Y1;i denote the number of nodes in the ith
polyquadrate. All Y1;i’s are Poisson RVs with rate at least
ð120 þ oð1ÞÞ lnn. From Lemma 11, I1;n ¼ ð 1"nÞ ¼ ð
ﬃﬃﬃﬃﬃ
n
lnn
p Þ.
Applying Lemma 1 (condition 2), it is a.a.s. that
min
I1;n
i¼1
Y1;i  1
2
Lð0Þ lnn:
Thus, we have
Sm2ðPn; CnÞ  min min
I0;n
i¼1
Y0;i;min
I1;n
i¼1
Y1;i
 
 1
2
Lð0Þ lnn;
and the lemma is proved. tu
Theorem 3 is proved by Lemmas 14 and 15 and the de-
Poissonization argument.
C.3 Proof of Theorem 4
Remind that here Cn is a collection of disks whose centers
are at the origin.
Lemma 16. For any constant 0 2 ð;1Þ, if ID is a square, we
a.a.s. have
Pr Sm3ðPn;CnÞ 
 min 1
2
Lð0Þ; 1
4
0
 
lnn
 
! 1;
if ID is a disk, we a.a.s. have
Pr Sm3 Pn;Cnð Þ 
 1
2
Lð0Þ lnn
 
! 1:
Especially, if  < 1, it is almost sure that
Pr Sm3ðPn;CnÞ ¼ 0½  ! 1:
Proof. For any Cn 2 Cn, place pairwise disjoint copies of Cn
with centers in @ID. Let In be the number of copies of Cn
and Yi denote the number of nodes in the ith copy. Then,
Y1; Y2; . . . ; YIn are i.i.d. Poisson RVs with rate at most
ð12 þ oð1ÞÞ lnn, and we may have In ¼ ð
ﬃﬃﬃﬃﬃﬃ
n
lnn
p Þ. From
Lemma 1 (condition 4), we have
Sm3ðPn;CnÞ 
 min
1
i
In
Yi 
 1
2
Lð0Þ lnn:
In addition, if ID is a square, we consider the copy of Cn
with its center at ð12 ; 12Þ, a vertex of ID. Let Y denote the
number of nodes in the intersection of the disk and ID.
We have Y ¼ Poð14 lnnÞ, and
Sm3ðPn;CnÞ 
 Y 
 1
4
0 lnn:
Therefore, the lemma is proved. tu
Lemma 17. For any constant 0 < 0 < , if ID is a square, we
almost surely have
Pr Sm3ðPn;CnÞ  min 1
2
Lð0Þ; 1
4
0
 
lnn
 
! 1;
if ID is a disk, we almost surely have
Pr Sm3ðPn;CnÞ  1
2
Lð0Þ lnn
 
! 1:
Proof. Choose a 1 2 ð0; Þ. Let r and r0 be given by nr2 ¼
 lnn and nr02 ¼ 1 lnn, respectively. Let Mn ¼
ﬃﬃ
2
p
rr0 and
"n ¼ 1=Mn. Divide ID by a "n-tessellation, and then for
each cell, draw a r0-disk with its center in the intersection
of this cell and ID. Since the distance between any two
points in a cell is at most
ﬃﬃﬃ
2
p
"n ¼ r r0, any r-disk with
center in IDmust contain at least one of these r0-disks. Let
In denote the number of these r
0-disks, and Yi denote the
number of nodes in the ith r0-disk. Then,
Sm3ðPn;CnÞ  min
1
i
In
Yi:
If ID is a square, we partition Y1; Y2; . . . ; YIn into three
groups. First, we consider cells contained in IDð0Þ, and let
N0 denote the number of cells. For these cells, we have
Yi ¼ Poð1 lnnÞ and
N0 	 1 2rrr0ﬃﬃ
2
p
 !2
¼
ﬃﬃﬃ
2
p ð1 2rÞ
r 1r0r
 	
 !2
¼  n
lnn

 
:
YI: A UNIFIED ANALYTIC FRAMEWORK BASED ON MINIMUM SCAN STATISTICS FOR WIRELESS AD HOC AND SENSOR NETWORKS 1243
Authorized licensed use limited to: National Chiao Tung University. Downloaded on September 18, 2009 at 10:36 from IEEE Xplore.  Restrictions apply. 
[18] N. Li, J.C. Hou, and L. Sha, “Design and Analysis of a MST-Based
Distributed Topology Control Algorithm for Wireless Ad-Hoc
Networks,” Proc. IEEE INFOCOM ’03, vol. 3, pp. 1702-1712, Apr.
2003.
[19] Y. Wang and X.-Y. Li, “Localized Construction of Bounded
Degree and Planar Spanner for Wireless Ad Hoc Networks,”
Proc. 2003 Joint Workshop Foundations of Mobile Computing
(DIALM-POMC ’03), pp. 59-68, Sept. 2003.
[20] J. Cartigny, F. Ingelrest, D. Simplot-Ryl, and I. Stojmenovic,
“Localized LMST and RNG Based Minimum-Energy Broadcast
Protocols in Ad Hoc Networks,” Ad Hoc Networks, vol. 3, no. 1,
pp. 1-16, 2004.
[21] P.-J. Wan and C.-W. Yi, “On the Longest Edge of Gabriel Graphs
in Wireless Ad Hoc Networks,” IEEE Trans. Parallel and Distributed
Systems, vol. 18, no. 1, pp. 111-125, Jan. 2007.
[22] P.-J. Wan, C.-W. Yi, F. Yao, and X. Jia, “Asymptotic Critical
Transmission Radius for Greedy Forward Routing in Wireless
Ad Hoc Networks,” Proc. ACM MobiHoc ’06, pp. 25-36, May 2006.
[23] F. Lin and X. Yang, Geometric Measure Theory: An Introduction. Int’l
Press, 2003.
[24] J. Geißler and H. von Weizsa¨cker, Fractal Sets and Preparation to
Geometric Measure Theory, script, http://www.mathematik.uni-
kl.de/~wwwstoch/2002w/skriptrev.pdf, Feb. 2006.
[25] M. Cifre, “Optimizing the Perimeter and the Area of Convex Sets
with Fixed Diameter and Circumradius,” Archiv der Math., vol. 79,
no. 2, pp. 147-157, Aug. 2002.
Chih-Wei Yi received the BS and MS degrees
from the National Taiwan University and the PhD
degree from the Illinois Institute of Technology.
He is currently an assistant professor in computer
science in the Department of Computer Science,
National Chiao Tung University. His research
focuses on wireless ad hoc and sensor networks.
He is a member of the IEEE.
. For more information on this or any other computing topic,
please visit our Digital Library at www.computer.org/publications/dlib.
YI: A UNIFIED ANALYTIC FRAMEWORK BASED ON MINIMUM SCAN STATISTICS FOR WIRELESS AD HOC AND SENSOR NETWORKS 1245
Authorized licensed use limited to: National Chiao Tung University. Downloaded on September 18, 2009 at 10:36 from IEEE Xplore.  Restrictions apply. 
IEEE TRANSACTIONS ON COMMUNICATIONS, VOL. 57, NO. 5, MAY 2009 1433
Asymptotic Critical Transmission Radii for Greedy
Forward Routing in Wireless Ad Hoc Networks
Peng-Jun Wan, Chih-Wei Yi, Member, IEEE, Lixin Wang, Frances Yao, and Xiaohua Jia
Abstract—In wireless ad hoc networks, greedy forward routing
is a localized geographic routing algorithm in which one node
discards a packet if none of its neighbors is closer to the
destination of the packet than itself, or otherwise forwards the
packet to the neighbor closest to the destination. If all nodes
have the same transmission radii, the critical transmission radius
for greedy forward routing is the smallest transmission radius
which ensures packets can be delivered by greedy forward
routing through any source-destination pair. In this paper, we
study asymptotic critical transmission radii of randomly deployed
wireless ad hoc networks. Assume network nodes are represented
by a Poisson point process of density n over a unit-area convex
compact region whose boundary curvature is bounded. We
show that the ratio of critical transmission radii to
√
lnn
πn
is
asymptotically almost surely equal to
√
1/
(
2
3
−
√
3
2π
)
≈ 1.6.
Index Terms—Wireless ad hoc networks, greedy forward
routing, critical transmission radii, random deployment.
I. INTRODUCTION
A wireless ad hoc network is a collection of wirelessdevices distributed over a geographic region. Each ad
hoc device is equipped with an omnidirectional antenna. A
communication session is established either through a single-
hop radio transmission if the communication party is close
enough, or through relaying by intermediate devices otherwise.
The selection of intermediate relay nodes is determined by
routing algorithms. Greedy forward routing (abbreviated by
GFR) is one of the localized geographic routing algorithms
proposed in literature.
In GFR, one node discards a packet if none of its neigh-
bors is closer to the destination of the packet than itself,
or otherwise forwards the packet to the neighbor closest to
the destination. Therefore, each packet should contain the
location of its destination, and each node only needs to
maintain the locations of its one-hop neighbors. GFR can be
implemented in a localized and memoryless manner. There
are some variations of GFR. For example, in [1] and [2], the
Paper approved by R. Fantacci, the Editor for Wireless Networks and
Systems of the IEEE Communications Society. Manuscript received July 24,
2006; revised March 18, 2007, December 17, 2007, June 14, 2008, and June
21, 2008.
P.-J. Wan and L. Wang are with the Department of Computer Science,
Illinois Institute of Technology, Chicago, IL 60616 (e-mail: wan@cs.iit.edu,
wanglix@iit.edu).
C-W. Yi is with the Department of Computer Science, National Chiao Tung
University, Hsinchu City 30010, Taiwan (e-mail: yi@cs.nctu.edu.tw).
F. Yao and X. Jia are with the Department of Computer Science, City
University of Hong Kong, Hong Kong (e-mail: {csfyao, csjia}@cityu.edu.hk).
A short version of this paper had been presented in the Seventh ACM
International Symposium on Mobile Ad Hoc Networking and Computing
(MobiHoc 2006), Florence, Italy, 22-25 May 2006.
Digital Object Identiﬁer 10.1109/TCOMM.2009.05.070307
v
w
w3
w2
w1
u
4
Fig. 1. u is a source node and v is the corresponding destination node.
shortest projected distance to the destination on the straight
line joining the current node and the destination node is
considered as the greedy metrics. In [1], packets are allowed
to be sent backward if there is no forwarding neighbor. In
[2], only nodes whose Voronoi cells intersect with the source-
destination line segment are eligible for being relay nodes.
Here the Voronoi cell of a node is the set of points in the
plane that are closer to the node than to any other node [3].
Due to existence of local minima where none of neighbors
is closer to the destination than the current node, a packet
may be discarded before arriving its destination. To ensure
that every packet can arrive its destination, all nodes should
have sufﬁciently large transmission radii to avoid being local
minima. For points x, y ∈ R2 and a positive real number r,
let B (x, r) denote the open disk of radius r centered at x,
‖x‖ denote the Euclidean norm of x, and ‖x− y‖ denote
the Euclidean distance between x and y. Consider Fig. 1.
Let u be a source or relay node, v be the corresponding
destination node, and wi denote nodes other than u and v.
Nodes that can relay packets for u toward v must be in the
region B (u, ‖u− v‖)∩B (v, ‖u− v‖) based on the following
observations. If wi can relay packets for u toward v, it must
be closer to v than u, i.e. ‖v − wi‖ < ‖v − u‖ or equivalently
wi ∈ B (v, ‖u− v‖). w2, w3, w4 satisfy this rule and w1 does
not. On the other hand, if no one can relay packets for u,
packets should be directly transmitted from u to v. So, in
the worst case, u at most needs to set its transmission radius
to ‖u− v‖. This implies candidates of relay nodes must be
in B (u, ‖u− v‖). For example, in Fig. 1, w4 can’t be a
candidate of relay nodes. Thus, only w2 and w3 can relay
packets for u toward v. In addition, if the transmission radius is
set to min (‖w2 − u‖ , ‖w3 − u‖), u has at least one neighbor
to relay packets. The procedure of selecting the minimal
transmission radii to ensure either u can send packets directly
to v or there exists at least one node to relay packets for u
0090-6778/09$25.00 c© 2009 IEEE
Authorized licensed use limited to: National Chiao Tung University. Downloaded on June 11, 2009 at 05:37 from IEEE Xplore.  Restrictions apply.
P.-J. WAN et al.: ASYMPTOTIC CRITICAL TRANSMISSION RADII FOR GREEDY FORWARD ROUTING IN WIRELESS AD HOC NETWORKS 1435
u w v
Fig. 2. w is the intersection point of the segment uv and the circle B (u, rn).
The shaded area is B (u, rn)∩B (w, rn) which is contained in B (u, rn)∩
B (v, ‖u− v‖).
• The critical number of nodes: To deploy a WSN over a
region, if the transmission range of nodes is known, we
need to decide how many sensor nodes are enough such
that the network can be connected by routing algorithms.
By scaling the deployment region to unit-area and also
scaling the transmission radius by the same ratio, we can
have a critical number of nodes based on the theoretical
formula or simulation data.
• Light-weight routing algorithms: If geographic informa-
tion is available, greedy forward routing is easy to imple-
ment and requires few resources, but suffers from local
minimum problems. Therefore, some relatively complex
compensatory algorithms are needed to handle such ex-
ceptional situations. If the delivery rate can be predicted
and controlled above tolerable level or even more the
deliverability can be guaranteed, the pure greedy forward
routing is enough, and complex compensatory algorithms
are not necessary.
III. OUTLINE OF PROOF
This section is dedicated to the proof of Theorem 1.
A. Upper Bounds for the Critical Transmission Radius
For a given ε > 0, let β = (1 + ε)2 β0. The up-
per bound for ρ (Pn) given in Theorem 1, i.e. ρ (Pn) ≤
(1 + ε)
√
β0 lnn
nπ , can be proved by showing that if rn =√
β lnn
πn = (1 + ε)
√
β0 lnn
nπ , there a.a.s. don’t exist local
minima. For a pair of nodes (u, v), u is a local minimum w.r.t.
v if and only if ‖u− v‖ > rn and there are no other nodes
in B (u, rn) ∩ B (v, ‖u− v‖). Now, assume ‖u− v‖ > rn
and let w be the intersection point of the segment uv and the
circle ∂B (u, rn). See Fig. 2. For convenience, for any two
points x, y ∈ R2, the region B (x, ‖x− y‖)∩B (y, ‖x− y‖),
denoted by Lxy, is called the lune associated with x and
y, and the segment xy is called the waist of Lxy. Since
Luw ⊂ B (u, rn)∩B (v, ‖u− v‖), "there exist nodes in Luw"
implies "u is not a local minimum w.r.t. v". We shall show
that any lune whose waist is of length rn , e.g. like Luw, a.a.s.
covers some nodes. Thus, the network is local-minimum-free.
0 5 10 15
0
1
2
3
4
5
6
7
8
9
10
β
L (β)
Fig. 3. The graph of L (β).
We use #(S) to denote the cardinality of a countable set
S. For any ﬁnite point set V ⊂ D and any r > 0, deﬁne
S (V, r) = min
u,v∈D,‖u−v‖=r
#(V ∩ Luv) .
S (V, r), called the minimal scan statistics, is the minimal
number of nodes of V that can be covered by a lune whose
waist is fully contained in D and with length r. So, the event
S (Pn, rn) > 0 implies the event ρ (Pn) ≤ rn. An a.a.s. lower
bound for S (Pn, rn) will be given in Lemma 3 and implies
that if β > β0, S (Pn, rn) > 0 is a.a.s..
Let φ (μ) denote the function φ (μ) = 1 − μ + μ lnμ over
μ ∈ (0,∞). φ is strictly convex and has the unique minimum
zero at μ = 1. Let φ−1 : [0, 1) → (0, 1] be the inverse of the
restriction of φ to (0, 1]. We deﬁne a function L over (0,∞)
by
L (β) =
{
βφ−1 (1/β) if β > 1,
0 otherwise.
The graph of L (β) is illustrated in Fig. 3. We have the
following lemma.
Lemma 3: Suppose that nπr2n = (β + o (1)) lnn for some
β > β0.
3 Then for any constant β1 ∈ (β0, β), it is a.a.s. that
S (Pn, rn) > 12L
(
β1
β0
)
lnn > 0.
A proof of Lemma 3 is given in the appendix and also can
be found in [10]. According to Lemma 3, we have ρ (Pn) ≤
rn = (1 + ε)
√
β0 lnn
πn is a.a.s..
B. Lower Bounds for the Critical Transmission Radius
The lower bound for ρ (Pn) given in Theorem 1, i.e.
(1− ε)
√
β0 lnn
nπ ≤ ρ (Pn), will be proved in this subsec-
tion. For a given ε > 0, let β = (1− ε)2 β0. The lower
bound can be proved by showing that if rn =
√
β lnn
πn =
(1− ε)
√
β0 lnn
nπ , there a.a.s. exist local minima. The plane is
going to be tessellated into equal-size square cells. For each
cell, an event that implies existence of local minima within
the cell is introduced, and a lower bound for the probability
of the event is derived. Since these events are identical and
3For two sequences fn and gn, we write fn = o (gn) if limn→∞ fngn = 0.
Authorized licensed use limited to: National Chiao Tung University. Downloaded on June 11, 2009 at 05:37 from IEEE Xplore.  Restrictions apply.
P.-J. WAN et al.: ASYMPTOTIC CRITICAL TRANSMISSION RADII FOR GREEDY FORWARD ROUTING IN WIRELESS AD HOC NETWORKS 1437
Ratios of Deliverable Source-Destination Pairs
0.88
0.9
0.92
0.94
0.96
0.98
1
1.02
0.75 0.8 0.85 0.9 0.95 1 1.05
Transmission Radius Factor s
R
at
io
n=200
n=400
n=800
Fig. 6. Average percentage of deliverable source-destination pairs in
networks with n = 200, n = 400, and n = 800.
bold green dotted line marked by triangles is the CDF of
normalized CTRs for n = 200, the bold solid purple line
marked by squares is for n = 400, and the ﬁne solid red
line marked by circles is for n = 800. For each network
size, the transition width is the difference between the largest
and smallest CTRs among 400 network topologies. The
normalized transition width for n = 200 (respectively, 400
and 800) is 0.9168 (respectively, 0.7591 and 0.6419) that is
the horizontal distance between the right most and left most
triangle (respectively, square and circle) markers in Fig. 5. The
decreasing of the normalized transition width agrees with the
trend of convergence.
Next, if transmission radii are set below CTRs, we would
like to investigate the impact on the deliverability of GFR.
Since CTRs usually are different from one topology to
another, to have a comparison basis, for each network topol-
ogy, the CTR is ﬁrst computed according to Eq. (1), and
then transmission radii are set to s times of the CTR for
s = 0.8, 0.85, 0.9, 0.95, or 0.99. In other words, for each
network topology, according to its CTR, transmission radii
are set to 0.8 · CTR, 0.85 · CTR, 0.9 · CTR, 0.95 · CTR,
or 0.99 · CTR. The number of deliverable source-destination
pairs in each network is counted. For each transmission radius
factor s, the average ratio of deliverable source-destination
pairs are calculated over 400 network topologies. In Fig. 6,
the x-axis represents the transmission radius factor s, and the
y-axis is the average ratio of deliverable source-destination
pairs. We can see that transmission radii have larger impact
on deliverability in sparse networks than in dense ones.
Last, we investigate the delivery efﬁciency of GFR. The
effective progress ratio (EPR) of a routing path is deﬁned as
the ratio of the Euclidean source-destination distance to the
total Euclidean path length. The ratio can be an indicator of
delivery efﬁciency. In the simulation, we calculated average
EPRs under various transmission radii and node densities.
Similarly, for each network topology, the CTR was ﬁrst
calculated, and then transmission radii are set to s times of the
CTR. Here s are 0.8, 0.9, 1, 1.1, 1.2, and 1.3. In Fig 7, the x-
axis represents the transmission radius factor s, and the y-axis
Average Effective Progress Ratios
0.75
0.8
0.85
0.9
0.95
1
0.7 0.8 0.9 1 1.1 1.2 1.3 1.4
Transmission Radius Factor s
EP
R
n=200
n=400
n=800
Fig. 7. Effective progress ratios (EPRs) under various transmission radii and
network sizes.
is the average EPR over all deliverable source-destination pairs
in 400 network topologies. We can see that the EPR mainly
depends on the transmission radius factor s but is insensitive to
the network size. If the EPR is a major concern, transmission
radii will be one of the primary parameters to tune the system.
V. CONCLUSIONS
Greedy forward routing is a localized and memoryless
geographic routing algorithm. However, it cannot guarantee
the deliverability of packets if transmission radii of nodes are
not large enough. If all nodes have the same transmission
radii, the smallest transmission radius that ensures the deliv-
erability of packets is referred to as the critical transmission
radius. In this paper, we provides tight a.a.s. bounds for the
critical transmission radius of randomly deployed wireless ad
hoc networks in which nodes are represented by a Poisson
point process. We also investigated a number of parameters
related to GFR by simulations, including the average of one-
hop progress, the expected number of hops between source-
destination pairs, and the effective hop progress. As a future
work, it is interesting to study the asymptotics of other
localized geographic routing protocols.
APPENDIX
In the appendix, we give the proof of Lemma 3 and 4. In
what follows, |A| is shorthand for 2-dimensional Lebesgue
measure (or area) of a measurable set A ⊂ R2. All integrals
considered will be Lebesgue integrals. The diameter of a set
A ⊂ R2 is denoted by diam (A). The topological boundary of
a set A ⊂ R2 is denoted by ∂A. Po (λ) represents a Poisson
RV with mean λ. The symbols O,Θ,Ω, o,∼ always refer to
the limit n →∞. To avoid trivialities, we tacitly assume n to
be sufﬁciently large if necessary. For simplicity of notation,
the dependence of sets and random variables on n will be
frequently suppressed.
A. Geometric Preliminaries
The lemmas given in this subsection are from [10], and we
will skip their proof. If ‖u− v‖ = 1/√π, a straightforward
Authorized licensed use limited to: National Chiao Tung University. Downloaded on June 11, 2009 at 05:37 from IEEE Xplore.  Restrictions apply.
P.-J. WAN et al.: ASYMPTOTIC CRITICAL TRANSMISSION RADII FOR GREEDY FORWARD ROUTING IN WIRELESS AD HOC NETWORKS 1439
By Sterling’s formula, we have
Pr (Po (λ) ≤ μλ) ∼ 1
1− μ
λμλ
(μλ)!
e−λ
∼ 1
1− μ
λμλ√
2πμλ (μλ)μλ e−μλ
e−λ
=
1
1− μ
1√
2πμλμμλ
e−λ+μλ
=
1
1− μ
1√
2πμλ
e−λ+μλ−μλ lnμ
=
1√
2π
1√
μ (1− μ)
1√
λ
e−λ(1−μ+μ lnμ)
=
1√
2π
1√
μ (1− μ)
1√
λ
e−λφ(μ).
Thus, the lemma is proved.
Assume Y is a Poisson RV with large mean. If Y generates
an output, the outcome should be close to the mean with high
probability. But as Y generates more outputs, the outcomes
are more diverse, and the minimum over the outcomes become
smaller. Corresponding to this simple observation, the follow-
ing lemma gives an quantitative result about the minimum
over a collection of Poisson RVs and it will be used in the
proof of Lemma 3.
Lemma 10: Assume that limn→∞ λnlnn = β for some β >
1. Let Y1, Y2, · · · , YIn be In Poisson RVs with means at least
λn.
1) If In = o
(
n
√
lnn
)
, then for any 1 < β′ < β,
minIni=1 Yi > L (β′) lnn a.a.s..
2) If In = O
(√
n
lnn
)
, then for any 1 < β′ < β,
minIni=1 Yi >
1
2L (2β′) lnn a.a.s..5
Proof: We ﬁrst assume that Y1, Y2, · · · , YIn all have
means λn. Let Y be a Poisson RV with mean λn. We claim
that for any μ > 0,
Pr
[
In
min
i=1
Yi ≤ μλn
]
≤ In Pr [Y ≤ μλn] .
To prove that this holds, let Xi be the indicator of the event
Yi ≤ μλn. Then Xi is a Bernoulli RV with probability
Pr [Y ≤ μλn]. Let X = X1 + · · ·+ XIn . Then, minIni=1 Yi ≤
μλn if and only if X ≥ 1. By Markov’s inequality,
Pr
[
In
min
i=1
Yi ≤ μλn
]
= Pr [X ≥ 1] ≤ E [X ] =
In∑
i=1
E [Xi]
= In Pr [Y ≤ μλn] .
Now, assume that In = o
(
n
√
lnn
)
. Since L (β′) <
L (β) = βφ−1 (1/β), we have L (β′) /β < φ−1 (1/β).
We choose a constant μ ∈ (L (β′) /β, φ−1 (1/β)). Then,
μ ∈ (0, 1) , μβ > L (β′) and βφ (μ) > 1. Thus, for sufﬁciently
large n, μλn ≥ L (β′) lnn, which implies that
Pr
[
In
min
i=1
Yi ≤ L (β′) lnn
]
≤ Pr
[
In
min
i=1
Yi ≤ μλn
]
≤ In Pr [Y ≤ μλn] .
5For two sequences fn and gn, we write fn = O (gn) if there exist
constants c and n0 such that |fn| ≤ c |gn| for all n ≥ n0.
By Lemma 9,
Pr
[
In
min
i=1
Yi ≤ L (β′) lnn
]
 1√
2πβ
1√
μ (1− μ)
In
n
√
lnn
n1−(λn/ lnn)φ(μ).
Since
1− (λn/ lnn)φ (μ) → 1− βφ (μ) < 0,
we have
Pr
[
In
min
i=1
Yi ≤ L (β′) lnn
]
= o (1) .
Hence minIni=1 Yi > L (β′) lnn a.a.s..
Next, assume that In = O
(√
n
lnn
)
. Since L (2β′) <
L (2β), we have L (2β′) / (2β) < φ−1 (1/ (2β)). We choose
a constant μ ∈ (L (2β′) / (2β) , φ−1 (1/ (2β))). Thus, μ ∈
(0, 1) , μβ > 12L (2β′) and βφ (μ) > 1/2. Thus, for sufﬁ-
ciently large n, μλn ≥ 12L (2β′) lnn, which implies that
Pr
[
In
min
i=1
Yi ≤ 12L (2β
′) lnn
]
≤ Pr
[
In
min
i=1
Yi ≤ μλn
]
≤ In Pr [Y ≤ μλn] .
By Lemma 9,
Pr
[
In
min
i=1
Yi ≤ 12L (2β
′) lnn
]
 1√
2πβ
1√
μ (1− μ)
In√
n lnn
n1/2−(λn/ lnn)φ(μ).
Since
1/2− (λn/ lnn)φ (μ) → 1/2− βφ (μ) < 0,
we have
Pr
[
In
min
i=1
Yi ≤ 12L (2β
′) lnn
]
= o (1) .
Hence minIni=1 Yi >
1
2L (2β′) lnn a.a.s..
Finally, we consider that general case that Y1, Y2, · · · , YIn
have means λn,1, λn,2, · · · , λn,In respectively with λn,i ≥ λn
for each 1 ≤ i ≤ In. Let Y ′1 , Y ′2 , · · · , Y ′In be In Poisson
RVs with means λn. For each 1 ≤ i ≤ In, let Y ′′i be a
Poisson RV with mean λn,i − λn which is independent with
Y ′i . Then by the superposition property of Poisson RVs, Yi =
Y ′i + Y
′′
i . Therefore, min
In
i=1 Yi ≥ minIni=1 Y ′i > μλn. By the
above argument, the lemma also holds in this general case.
At the end of this subsection, we state the Palm theory [11]
on the Poisson process.
Theorem 11: Let n > 0. Suppose k ∈ N , and h (Y,X )
is a bounded measurable function deﬁned on all pairs of the
form (Y,X ) with X ⊂ R2 being a ﬁnite subset and Y being
a subset of X , satisfying h (Y,X ) = 0 except when Y has k
elements. Then
E
⎡
⎣ ∑
Y⊆Pn
h (Y,Pn)
⎤
⎦ = n
k
k!
E [h (Xk,Xk∪Pn)]
where the sum on the left-hand side is over all subsets Y of
the random Poisson point set Pn, and on the right hand side
the set Xk is a binomial process with k nodes, independent of
Pn.
Authorized licensed use limited to: National Chiao Tung University. Downloaded on June 11, 2009 at 05:37 from IEEE Xplore.  Restrictions apply.
P.-J. WAN et al.: ASYMPTOTIC CRITICAL TRANSMISSION RADII FOR GREEDY FORWARD ROUTING IN WIRELESS AD HOC NETWORKS 1441
that h2 ({X ′1, X ′2, X ′3} ,Pn) = 1; and F ′3 ({X ′1, X ′2, X ′3, X ′4})
be the event that h3 ({X ′1, X ′2, X ′3, X ′4} ,Pn) = 1. Applying
Boole’s inequalities which is a special case of the inclusion-
exclusion principle, we have
Pr [E1] ≥
∑
{X′1,X′2}⊆Pn
Pr
[
F ′1
({
X ′1,X
′
2
})]
−
∑
{X′1,X′2,X′3}⊆Pn
Pr
[
F ′2
({
X ′1,X
′
2,X
′
3
})]
−
∑
{X′1,X′2,X′3,X′4}⊆Pn
Pr
[
F ′3
({
X ′1,X
′
2,X
′
3, X
′
4
})]
. (6)
Let F1 be the event that
h1 ({X1, X2} , {X1, X2} ∪ Pn) = 1, F2 be the event that
h2 ({X1, X2, X3} , {X1, X2, X3} ∪ Pn) = 1, and F3 be the
event that h3 ({X1, X2, X3, X4} , {X1, X2, X3, X4} ∪ Pn) =
1. According to the Palm theory (Theorem 11), we have
∑
{X′1,X′2}⊆Pn
Pr [F ′1 ({X ′1, X ′2})]
= E
⎡
⎢⎣
∑
{X′1,X′2}⊆Pn
h1 ({X ′1, X ′2} ,Pn)
⎤
⎥⎦
=
n2
2!
E [h1 ({X1, X2} , {X1, X2} ∪ Pn)]
=
n2
2
Pr [F1] ; (7)
∑
{X′1,X′2,X′3}⊆Pn
Pr [F ′2 ({X ′1, X ′2, X ′3})]
= E
⎡
⎢⎣
∑
{X′1,X′2,X′3}⊆Pn
h2 ({X ′1, X ′2, X ′3} ,Pn)
⎤
⎥⎦
=
n3
3!
E [h2 ({X1, X2, X3} , {X1, X2, X3} ∪ Pn)]
= 3
n3
3!
Pr [F2] =
n3
2
Pr [F2] ; (8)
and ∑
{X′1,X′2,X′3,X′4}⊆Pn
Pr [F ′3 ({X ′1, X ′2, X ′3, X ′4})]
= E
⎡
⎢⎣
∑
{X′1,X′2,X′3,X′4}⊆Pn
h3 ({X ′1, X ′2, X ′3, X ′4} ,Pn)
⎤
⎥⎦
=
n4
4!
E [h3 ({X1, X2, X3, X4} , {X1, X2, X3, X4} ∪ Pn)]
= 3
n4
4!
Pr [F3] =
n4
8
Pr [F3] . (9)
From Eq. (6), (7), (8), and (9), we have
Pr [E1] ≥ n
2
2
Pr [F1]− n
3
2
Pr [F2]− n
4
8
Pr [F3] . (10)
In the next, we derive the probabilities of F1, F2, and F3.
Let S1 (R1, R2) denote the set{
(x1, x2)
∣∣∣∣
1
2
(x1 + x2) ∈ A,R1 ≤ ‖x1 − x2‖ ≤ R2
}
.
For simplicity, S1 is shorthand for S1 (R1, R2). We have
Pr [F1] =
∫ ∫
S1
Pr [F1 | X1 = x1, X2 = x2] dx1dx2
=
∫ ∫
S1
e−n|Lx1x2 |dx1dx2
=
∫ ∫
S1
e−n
1
β0
π‖x1−x2‖2dx1dx2.
Let z = x1+x22 and r =
1
2 ‖x1 − x2‖. Then,
Pr [F1] =
∫
z∈A
∫ R2
2
r=
R1
2
e−
4
β0
nπr28πrdrdz
= 4
∫
z∈A
∫ R2
2
r=
R1
2
e
− 4β0 nπr
2
2πrdrdz
= 4
∫
z∈A
∫ R2
2
r=
R1
2
e−
4
β0
nπr2d
(
πr2
)
dz
= −
⎛
⎝ β0
n
e−
4
β0
nπr2
∣∣∣∣
R2
2
r=
R1
2
⎞
⎠ |A|
=
β0
4n2
(
n−
β1
β0 − n− β2β0
)
lnn. (11)
Let S2 (R1, R2) denote the set
⎧⎪⎪⎨
⎪⎪⎩
(x1, x2, x3)
∣∣∣∣∣∣∣∣
x1+x2
2 ,
x1+x3
2 ∈ A;
R1 ≤ ‖x1 − x2‖ ≤ R2;
R1 ≤ ‖x1 − x3‖ ≤ R2;x1, x2 /∈ Lx1x3 ;
x1, x3 /∈ Lx1x2
⎫⎪⎪⎬
⎪⎪⎭
.
Again, for simplicity, S2 is shorthand for S2 (R1, R2). Apply-
ing Lemma 6, if (x1, x2, x3) ∈ S2, we have
Pr [F2 |X1 = x1, X2 = x2, X3 = x3 ] ≤ e−n|Lx1x2∪Lx1x3 |
≤ e−n
(
1
β0
π‖x1−x2‖2+cR2‖ x1+x22 − x1+x32 ‖
)
.
Therefore,
Pr [F2]
=
∫ ∫ ∫
S2
Pr [F2 |X1 = x1,X2 = x2,X3 = x3 ] dx1dx2dx3
≤
∫ ∫ ∫
S2
e
−n
(
1
β0
π‖x1−x2‖2+cR2
∥∥∥ x1+x22 −
x1+x3
2
∥∥∥
)
dx1dx2dx3.
Let z1 = x1+x22 , r1 =
1
2 ‖x1 − x2‖, z2 = x1+x32 , and ρ =‖z1 − z2‖. Then,
Pr [F2]
≤ 16
∫
z1∈A
∫ R2
2
r1=
R1
2
∫
z2∈A
e
−n
(
4
β0
πr21+cR2‖z1−z2‖
)
2πr1
· dr1dz1dz2
≤ 16
∫
z1∈A
∫ R2
2
r1=
R1
2
e−
4
β0
nπr212πr1dr1dz1
·
∫
z2∈A
e−cnR2‖z1−z2‖dz2
≤ 16
∫
z1∈A
∫ R2
2
r1=
R1
2
e−
4
β0
nπr21d
(
πr21
)
dz1
Authorized licensed use limited to: National Chiao Tung University. Downloaded on June 11, 2009 at 05:37 from IEEE Xplore.  Restrictions apply.
P.-J. WAN et al.: ASYMPTOTIC CRITICAL TRANSMISSION RADII FOR GREEDY FORWARD ROUTING IN WIRELESS AD HOC NETWORKS 1443
Peng-Jun Wan received his PhD degree from Uni-
versity of Minnesota, MS degree from The Chinese
Academy of Science, and BS degree from Tsinghua
University. He is currently an Associate Professor
in Computer Science at Illinois Institute of Tech-
nology, and at City University of Hong Kong. His
research interests include wireless networks, optical
networks, and algorithm design and analysis.
Chih-Wei Yi received his Ph.D. degree from the
Illinois Institute of Technology, and MS and BS
degrees from the National Taiwan University. He
is currently an Assistant Professor in Computer
Science at the National Chiao Tung University. His
research focuses on wireless ad hoc and sensor
networks.
Lixin Wang received the M.S. degree in CS from
the University of Houston at Clear Lake, the M.S.
degree in Applied Math from the University of
Houston and the M.S. degree in Math from the
Fudan University, Shanghai, China. He is currently
a Ph.D. student in Computer Science at the Illinois
Institute of Technology, Chicago. His research is
on wireless networks, and algorithm design and
analysis.
Frances Yao received her BSc (1969) from Na-
tional Taiwan University and her Ph.D. (1973) in
Mathematics from Massachusetts Institute of Tech-
nology. She is currently Head of the Department of
Computer Science at City University of Hong Kong.
Her research interests include combinatorial and ge-
ometric algorithms, energy-efﬁcient computing and
sensor networks. She is a Fellow of AAAS.
Xiaohua Jia received his BSc (1984) and MEng
(1987) from the Univ of Science and Technolog of
China, and obtained his DSc (1991) in Information
Science from the Univ. of Tokyo, Japan. Prof. Jia is
currently associated with Dept of Computer Science
at City Univ of Hong Kong. His research inter-
ests include distributed systems, computer networks,
WDM optical networks, and Internet and mobile
computing.
Authorized licensed use limited to: National Chiao Tung University. Downloaded on June 11, 2009 at 05:37 from IEEE Xplore.  Restrictions apply.
Theoretical Computer Science 410 (2009) 2223–2233
Contents lists available at ScienceDirect
Theoretical Computer Science
journal homepage: www.elsevier.com/locate/tcs
Maximum scan statistics and channel assignment problems in
homogeneous wireless networks
Chih-Wei Yi ∗
Department of Computer Science, National Chiao Tung University, 1001 University Road, Hsinchu City 30010, Taiwan
a r t i c l e i n f o
Article history:
Received 14 October 2008
Received in revised form 1 February 2009
Accepted 14 February 2009
Communicated by D.-Z. Du
Keywords:
Wireless ad hoc networks
Maximum scan statistics
Channel assignment
Chromatic numbers
Clique numbers
Inductivities
a b s t r a c t
In wireless networks, to avoid collisions of simultaneous transmissions over the same
channel, adjacent nodes are assigned distinct channels, and the least number of channels
used in an assignment is called the chromatic number. The determination of the chromatic
number is NP-hard. In this paper, we introduce an analytic tool called maximum scan
statistics. For a finite point set V and a convex compact set C , themaximum scan statistic of
V with respect to the scanning set C is the largest number of points in V covered by a copy
C . Based on the study of asymptotic maximum scan statistics, we obtain the asymptotics
of the maximum degree and the clique number of homogeneous wireless networks. The
results imply that the chromatic number is almost surely at most four times the clique
number. We further prove that the approximation ratios of some vertex-ordering-based
First-Fit channel assignment algorithms are almost surely bounded by 2. In the analysis,
we also learn that the chromatic number is almost surely at most twice the clique number.
© 2009 Elsevier B.V. All rights reserved.
1. Introduction
In homogeneous wireless ad hoc networks, each node has the same transmission range r , and two nodes have a link
between them if the distance between them is at most r . Two nodes can communicate with each other either through a
single hop direct link if they are within each other’s transmission range or through a multi-hop communication session
otherwise. The induced network topology is called r-disk graphs, or unit disk graphs (UDGs) if r is scaled to 1. Because
there is no need for fixed infrastructures, wireless ad hoc networks can be flexibly deployed at low cost for varyingmissions
such as decision making in battlefields, emergency disaster relief and environmental monitoring. In many applications, for
example wireless sensor networks, a large number of devices will be randomly deployed. Consequently, wireless networks
are represented by unit disk graphs over random point sets, and the induced network topology is called random disk graphs.
In the literature, asymptotic analysis is interesting to the research community; see, e.g., [1–4].
Inwireless networks, each node can be in either sending or receivingmode but not both at the same time. Due to the short
transmission range, each node can only transmit messages to or receive messages from nearby nodes. To avoid collisions
of simultaneous transmissions over the same channel, adjacent nodes are assigned distinct channels. The assignment of
channels can be modeled by vertex coloring of graphs. A vertex coloring, assigning one color to each vertex, is proper if no
adjacent vertices receive the same color. For a graph G, χ (G) denotes the least number of colors used in a proper coloring
of G and is called the chromatic number of G.
Let G(V , E) denote a graph with vertex set V and edge set E. A graph H(V ′, E ′) is a subgraph of G(V , E) if V ′ ⊆ V and
E ′ ⊆ E. In addition, if E ′ = {(u, v) ∈ E : ∀u, v ∈ V ′}, H is called a induced subgraph of G (by V ′). For any vertex u ∈ V ,
deg (u) denotes the number of vertices adjacent to u and is called the vertex degree of u. δ (G) = minu∈V deg (u) and
∗ Tel.: +886 3 5131346.
E-mail address: yi@cs.nctu.edu.tw.
0304-3975/$ – see front matter© 2009 Elsevier B.V. All rights reserved.
doi:10.1016/j.tcs.2009.02.027
C.-W. Yi / Theoretical Computer Science 410 (2009) 2223–2233 2225
Table 1
Notations.
Gr (V ) The r-disk graph induced by a point set V
D A unit-area convex region
Pn A Poisson point process with mean n
Xn A uniform n-point process
Vn Pn orXn
rn The transmission radius
Po (n) A Poisson RV with mean n
# (A) The cardinality of countable set A
B (x, r) A disk with center x and radius r
‖x‖ The Euclidean norm of a point x
|A| The area of a measurable set A
diam (A) The diameter of A
cA The c-scaling of A
a.a.s. An acronym of asymptotic almost sure
RV An acronym of random variable
f = O (g) ∃N > 0, c > 0 s.t. f (n) ≤ cg (n) for all n ≥ N
f = Ω (g) ∃N > 0, c > 0 s.t. cg (n) ≤ f (n) for all n ≥ N
f = Θ (g) f (n) = O (g (n)) and f (n) = Ω (g (n))
f = o (g) limn→∞ f (n)g(n) = 0
f ∼ g limn→∞ f (n)g(n) = 1
Fig. 1. φ(μ) = 1 + μ lnμ − μ.
Fig. 2. The curve is μ = φ−1+ (1/β), and μ = 1 is the asymptotics as β → ∞.
For any positive integer n, the factorial of n, n! = 1 · 2 · · · · · n, can be estimated by Sterling’s formula:
n! ∼ (2πn) 12 nne−n. (1)
C.-W. Yi / Theoretical Computer Science 410 (2009) 2223–2233 2227
Let Xi be the indicator of the event Yi ≥ μλn. Then Xi is a Bernoulli RV with probability Pr [Yi ≥ μλn]. So
E [Xi] = Pr [Yi ≥ μλn] ≤ Pr [Y ≥ μλn] .
Let X = X1 + · · · + XIn . Since maxIni=1 Yi ≥ μλn if and only if X ≥ 1, by Markov’s inequality,
Pr
[
In
max
i=1
Yi ≥ μλn
]
= Pr [X ≥ 1] ≤ E [X] =
In∑
i=1
E [Xi]
≤ In Pr [Y ≥ μλn] .
By Lemma 1,
Pr
[
In
max
i=1
Yi ≥ μλn
]
 In
√
μ
μ − 1
1√
2πλn
e−λnφ(μ)
∼ 1√
2πβ
√
μ
μ − 1
In√
ln n
n−(λn/ ln n)φ(μ) = 1√
2πβ
√
μ
μ − 1
In
n
√
ln n
n1−(λn/ ln n)φ(μ).
Fix μ > φ−1+ (1/β). Then 1 − βφ (μ) < 0 and
1 − (λn/ ln n) φ (μ) → 1 − βφ (μ) < 0.
If In = o
(
n
√
ln n
)
, then
Pr
[
In
max
i=1
Yi ≥ μλn
]
= o (1) .
Thus, maxIni=1 Yi < μλn a.a.s.
Next assume that the Yi’s are i.i.d. Poisson RVs with mean λn. Then,
Pr
[
In
max
i=1
Yi ≥ μλn
]
= 1 − Pr
[
In
max
i=1
Yi < μλn
]
= 1 − Pr [Y < μλn]In
= 1 − (1 − Pr [Y ≥ μλn])In ≥ 1 − e−In Pr[Y≥μλn].
By Lemma 1,
In Pr [Y ≥ μλn] ∼ 1√2πβ
√
μ
μ − 1
In
n
√
ln n
n1−(λn/ ln n)φ(μ).
Fix 1 < μ < φ−1+ (1/β). Then 1 − βφ (μ) > 0 and
1 − (λn/ ln n) φ (μ) → 1 − βφ (μ) > 0.
If In = Ω
( n
ln n
)
, then
In Pr [Y ≥ μλ] → ∞.
Hence,
Pr
[
In
max
i=1
Yi ≥ μλn
]
→ 1.
Thus, maxIni=1 Yi ≥ μλn a.a.s. 
From Lemma 2(1), if In = o
(
n
√
ln n
)
, for any given β ′ ∈ (β,∞), choose a μ ∈
(
1, U(β
′)
U(β)
φ−1+ (1/β)
]
. Then, it is a.a.s.
that
In
max
i=1
Yi < μλn = μ
φ−1+ (1/β)
φ−1+ (1/β) β ln n =
μ
φ−1+ (1/β)
U (β) ln n
≤ U (β ′) ln n.
Similarly, from Lemma 2(2), if In = Ω
( n
ln n
)
and Y1, Y2, . . . , YIn are independent and with mean λn, then for any β
′ ∈ (0, β),
it is a.a.s. that maxIni=1 Yi ≥ U
(
β ′
)
ln n.
C.-W. Yi / Theoretical Computer Science 410 (2009) 2223–2233 2229
3.1. Theorem 5 on Poisson point processes
A lower bound for SM (Pn, Cn) is given by the following lemma.
Lemma 6. For any ε > 0, we have Pr
[
SM (Pn,Cn)
ln n ≥ (1 − ε)U (β)
]
→ 1.
Proof. Tessellate the plane into equal-size square cells with width c0
√
β ln n
n . For any given Cn ∈ Cn, since diam (Cn) ≤
c0
√
β ln n
n , we can place one copy of Cn in each cell that is fully contained inD, and those copies of Cn are pairwise disjoint. Let
In be the number of copies of Cn. In = Ω
⎛
⎝( 1
c0
√
β ln n
n
)2⎞⎠ = Ω ( nln n ). Let Yi denote the number of nodes in the i-th copy of
Cn for any 1 ≤ i ≤ In. Y1, Y2, . . . , YIn are i.i.d. Poisson RVs with rate (β + o (1)) ln n. Since SM (Pn, Cn) ≥ max1≤i≤In Yi, from
Lemma 2(2), it is a.a.s. that, for any given ε > 0,
SM (Pn, Cn) ≥ (1 − ε)U (β) ln n.
So, this lemma is proved. 
An upper bound for SM (Pn, Cn) is given by the following lemma.
Lemma 7. For any ε > 0, we have Pr
[
SM (Pn,Cn)
ln n ≤ (1 + ε)U (β)
]
→ 1.
Proof. Let dn = c0
√
β ln n
n . Recall that diam (Cn) ≤ dn for all Cn ∈ Cn. Since U (β) is an increasing function, for a given
ε > 0, we choose β1 > β such that U (β1) = (1 + ε)U (β). Let δ = min
(
β1−β
4πc20β
, 2−
√
2
2
)
and M =
⌈
1
δdn
⌉
. Divide D by a
δdn-tessellation. Let P be a polyquadrate corresponding to Cn. Since P ⊆ (Cn)√2δdn , we have
|P| ≤ ∣∣(Cn)√2δdn ∣∣
≤ |Cn| +
√
2δdn · peri (Cn) + π
(√
2δdn
)2
(by Lemma 3)
≤ |Cn| +
√
2δdn (πdn) + π
(√
2δdn
)2
(by isodiametric inequality)
= |Cn| +
(√
2 + 2δ
)
πδd2n ≤ |Cn| + 2πδd2n ∼ |Cn| + 2πδc20 |Cn|
= (1 + 2πc20δ) |Cn| ≤ β1 + β2β |Cn| = β1 + β2 ln nn .
If Y is the number of nodes in P , Y is a Poisson RV with rate at most β1+β2 ln n. Let In denote the number of polyquadrates
that are induced by a copy of Cn ∈ Cn, and Y1, Y2, . . . , YIn be the number of nodes in each polyquadrate. Since the span of P
is at mostm = dnM + 1 ≤ 1δ + dn + 1, that asymptotically depends only on the constant δ, by Lemma 4, we have
In = O
(
M2
) = O( 1
d2n
)
= O
(
1
|Cn|
)
= O
( n
ln n
)
.
Since β1+β2 < β1, from Lemma 2(1), it is a.a.s. that
SM (Pn, Cn) ≤ max
1≤i≤In
Yi < U (β1) ln n = (1 + ε)U (β) ln n.
So, the lemma is proved. 
3.2. De-Poissonization
Here we introduce a de-Poissonization technique that allow us to extend results on Poisson point processes to uniform
point processes. By Chebyshev inequality, it is almost sure that Po
(
n − n 34
)
≤ n ≤ Po
(
n + n 34
)
. Thus,
SM
(
P
n−n 34 , Cn
)
≤ SM (Xn, Cn) ≤ SM
(
P
n+n 34 , Cn
)
. (3)
C.-W. Yi / Theoretical Computer Science 410 (2009) 2223–2233 2231
Fig. 5. Draw two disks with radius δrn and (1− δ)rn at the center of a cell. If there exists a node v in the small disk, B(v, rn) contains the annulus with radii
δrn and (1 − δ)rn .
4.2. Maximum degrees
This subsection is dedicated to the proof of Theorem 8(2).
For each node in r-disk graphs, all its neighbors are in a disk of radius r centered at this node. Let Cn = {B (o, rn)}.
Obviously, Δ
(
Grn (Vn)
) ≤ SM (Vn, Cn) − 1. Hence, applying Theorem 5, for any ε > 0, we have
Pr
[
Δ
(
Grn (Vn)
)
ln n
≤ (1 + ε)U (β)
]
→ 1. (7)
In the following lemma, a lower bound for the maximum degree is provided.
Lemma 10. Let nπr2n = (β + o (1)) ln n for some β > 0. For any ε > 0, we have
Pr
[
Δ
(
Grn (Vn)
)
ln n
≥ (1 − ε)U (β)
]
→ 1.
Proof. SinceU (β) is an increasing function, for any given ε > 0, we can choose β1 < β such thatU (β1) = (1 − ε)U (β).
Let δ = β−β13β . Divide the plane into equal-size square cells by a 4rn-tessellation. For each cell fully contained in D, draw two
concentric disks at the center with radius δrn and (1 − δ) rn. Since δ < 13 , the disk with radius δrn is contained in the disk
with radius (1 − δ) rn. The area of small disks is π (δrn)2, and the area of annuli of radii δrn and (1 − δ) rn is
π
(
((1 − δ) rn)2 − (δrn)2
) = (1 − 2δ) πr2n .
Consider a cell and the two concentric disks in it. See Fig. 5. If there exists a node v in the small disk, B (v, rn) contains the
annulus and is contained in the cell.
First, we consider that Vn is a Poisson point process. Let In be the number of non-empty small disks, and Y1, . . . , YIn be
the number of nodes in the corresponding annuli of those non-empty small disks. For each small disk, the event that the
disk is not empty is a Bernoulli trial with probability 1− e−nπ(δrn)2 . So, In is a binomial RV with Θ
( n
ln n
)
trials. By Chebyshev
inequality, we can prove In = Θ
( n
ln n
)
. In addition, Y1, . . . , YIn are Poisson RVs with means
(1 − 2δ) nπr2n =
β + 2β1
3β
nπr2n =
(
1 + β − β1
3β1
)
β1 ln n,
and since those annuli are pairwise disjoint, Y1, . . . , YIn are i.i.d. Since Δ
(
Grn (Pn)
) ≥ max1≤i≤In Yi, applying Lemma 2, we
have
Δ
(
Grn (Pn)
)
ln n
≥
max
1≤i≤In
Yi
ln n
> U (β1) = (1 − ε)U (β) .
Applying the de-Poissonization technique introduced in Section 3.2, we can obtain the same result on Xn. Hence, the
lemma is proved. 
Theorem 8(2) follows Eq. (7) and Lemma 10.
C.-W. Yi / Theoretical Computer Science 410 (2009) 2223–2233 2233
(1) Smallest-last ordering (SL): The vertices are greedily selected in reverse order. Each time, a vertex with the smallest
degree in the remaining induced subgraph is selected and removed. This vertex ordering has the least inductivity, i.e.
indSL (G) = δ∗ (G). [17]
(2) Distance-increasing ordering (DI): The vertices are sorted in the increasing order of their Euclidean distances from an
arbitrary fixed point.
(3) Lexicographic ordering (LG): The vertices are sorted in the lexicographic order of their coordinates.
(4) Radius-decreasing ordering (RD): The vertices are sorted in the decreasing order of their transmission radii. If all nodes
have the same transmission radii, the ordering is random.
For any vertex set V and transmission radius r , the approximation ratios of indSL (Gr (V )), indDI (Gr (V )), indLG (Gr (V )),
and indRD (Gr (V )) to χ (Gr (V )), respectively, are 3, 3, 3, and 5 [11]. For any vertex ordering g , we have
ω (Gr (V )) ≤ χ (Gr (V )) ≤ indg (Gr (V )) + 1 ≤ Δ(Gr (V )) + 1.
Hence, from Theorem 8, it is a.a.s. that indg(Grn (Vn))
ω(Grn (Vn))
 4. In addition, since indSL
(
Grn (Vn)
) = δ∗ (Grn (Vn)), from Theorem 11,
it is a.a.s. that indSL(Grn (Vn))
ω(Grn (Vn))
 2. Moreover, applying the argument used in Theorem 11 to the vertex ordering DI and LG, we
can prove that it is a.a.s. that indDI(Grn (Vn))
ω(Grn (Vn))
 2 and indLG(Grn (Vn))
ω(Grn (Vn))
 2. Therefore, we have the following theorem.
Theorem 12. It is a.a.s. that the approximation ratio of any First-Fit algorithm is at most 4. Furthermore, it is a.a.s. that the
approximation ratios of First-Fit in SL, DI, LG are at most 2. Furthermore, the chromatic number is a.a.s. at most twice of the clique
number.
6. Conclusion
Channel assignment is an essential problem for wireless networks and is NP-hard. In this paper, we assume that
homogeneous wireless ad hoc networks are modeled by r-disk graphs over random point processes with mean density
n. First, we introduce an analytic tool called maximum scan statistics and show that the maximum scan statistics of Poisson
point processes or uniformpoint processeswith respect to regular scanning sets of area (β + o (1)) ln nn can be asymptotically
approximated by U (β) ln n. Next, we consider that the transmission radius rn is given by nπr2n = (β + o (1)) ln n. Based
on maximum scan statistics, we prove that the maximum degree and clique number of rn-disk graphs are a.a.s. U (β) ln n
andU
(
β
4
)
ln n, respectively. This result implies that the chromatic number is a.a.s. upper bounded by four times the clique
number. Last, we give analysis of several vertex-ordering-based First-Fit channel assignment algorithms, and show that the
approximation ratio of any First-Fit algorithm is a.a.s. bounded by 4 and the approximation ratios of First-Fit algorithms in
SL, DI, LG are a.a.s. bounded by 2. The analysis also implies that the chromatic number is a.a.s. upper bounded by twice the
clique number.
Acknowledgments
This work of C.-W. Yi is supported in part by the NSC under Grant Nos. NSC95-2221-E-009-059-MY3 and NSC97-2221-
E-009-052-MY3, by the ITRI under Grant No. 8352BA4124, and by the MoE ATU plan.
References
[1] M.D. Penrose, On k-connectivity for a geometric random graph, Random Structures and Algorithms 15 (2) (1999) 145–164.
[2] C.-W. Yi, P.-J. Wan, X.-Y. Li, O. Frieder, Asymptotic distribution of the number of isolated nodes in wireless ad hoc networks with Bernoulli nodes, in:
The 2003 IEEE Wireless Communications and Networking Conference, WCNC 2003, vol. 3, 2003, pp. 1585–1590.
[3] P.-J.Wan, C.-W. Yi, Asymptotic critical transmission radius and critical neighbor number for k-connectivity inwireless adhocnetworks, in: Proceedings
of the 5th ACM International Symposium on Mobile Ad Hoc Networking and Computing, MobiHoc 2004, 2004, pp. 1–8.
[4] H. Zhang, J. Hou, On deriving the upper bound of α-lifetime for large sensor networks, in: Proceedings of the 5th ACM International Symposium on
Mobile Ad Hoc Networking and Computing, MobiHoc 2004, 2004, pp. 121–132.
[5] B.N. Clark, C.J. Colbourn, D.S. Johnson, Unit disk graphs, Discrete Mathematics 86 (1990) 165–177.
[6] A. Gräf, M. Stumpf, G. Weißenfels, On coloring unit disk graphs, Algorithmica 20 (3) (1998) 277–293.
[7] M.V. Marathe, H. Breu, H.B. Hunt III, S.S. Ravi, D.J. Rosenkrantz, Simple heuristics for unit disk graphs, Networks 25 (1995) 59–68.
[8] R. Peeters, On coloring j-unit sphere graphs, Tech. Rep. FEW 512, Department of Economics, Tilburg University, The Netherlands, 1991.
[9] C. McDiarmid, Random channel assignment in the plane, Random Structures and Algorithms 22 (2) (2003) 187–212.
[10] M.D. Penrose, Focusing of the scan statistic and geometric clique number, Advances in Applied Probability 34 (4) (2002) 739–753.
[11] P.-J. Wan, Broadcast (radio, TV) networks, URL: http://www.cs.iit.edu/~wan/lecture2.pdf.
[12] J. Glaz, J. Naus, S. Wallenstein, Scan Statistics, Springer, 2001.
[13] F. Lin, X. Yang, Geometric Measure Theory: An Introduction, International Press, 2003.
[14] J. Geißler, H. von Weizsäcker, Geometric measure theory, script.
[15] C.-W. Yi, A unified analytic framework based on minimum scan statistics for wireless ad hoc and sensor networks, IEEE Transactions on Parallel and
Distributed Systems (in press).
[16] P.-J. Wan, C.-W. Yi, Coverage by randomly deployed wireless sensor networks, IEEE Transactions on Information Theory 52 (6) (2006) 2658–2669.
[17] D.W. Matula, L.L. Beck, Smallest-last ordering and clustering and graph coloring algorithms, Journal of the Association of Computing Machinery 30
(3) (1983) 417–427.
Discrete Mathematics, Algorithms and Applications
Vol. 1, No. 1 (2009) 25–43
c© World Scientiﬁc Publishing Company
ON THE LONGEST RNG EDGE OF WIRELESS
AD HOC NETWORKS
PENG-JUN WAN∗ and LIXIN WANG†
Department of Computer Science
Illinois Institute of Technology
∗wan@cs.iit.edu
†wanglix@iit.edu
FRANCES YAO
Department of Computer Science
City University of Hong Kong
csfyao@cityu.edu.hk
CHIH-WEI YI
Department of Computer Science
National Chiao Tung University
yi@cs.nctu.edu.tw
Accepted 21 January 2009
Relative neighborhood graph (RNG) has been widely used in topology control and geo-
graphic routing in wireless ad hoc networks. Its maximum edge length is the minimum
requirement on the maximum transmission radius by those applications of RNG. In this
paper, we derive the precise asymptotic probability distribution of the maximum edge
length of the RNG on a Poisson point process over a unit-area disk. Since the maximum
RNG edge length is a lower bound on the critical transmission radius for greedy forward
routing, our result also leads to an improved asymptotic almost sure lower bound on the
critical transmission radius for greedy forward routing.
Keywords: Relative neighborhood graph; Poisson point process; asymptotic probability
distribution.
Mathematics Subject Classiﬁcation 2000: 60D05
1. Introduction
Relative neighborhood graph (RNG) [15] of a ﬁnite planar set is a bounded-degree
planar graph containing the Euclidean minimum spanning tree as a subgraph. Due
to its simple construction and maintenance, RNG has found many applications in
localized topology control (e.g. [6, 8, 9]) and geographic routing (e.g. [1, 7, 13]) in
wireless ad hoc networks. All these applications require the maximum transmission
25
On the Longest RNG Edge of Wireless Ad Hoc Networks 27
destination of the packet than itself, or otherwise forwards the packet to the neigh-
bor closest to the destination of the packet. The critical transmission radius of a
planar node set V for greedy forward routing, denoted by φ(V ), is the smallest
transmission radius by V which ensures successful delivery of any packets from any
source node in V to any destination node in V . Clearly, λ(RNG(V )) ≤ φ(V ). It
was recently proved in [17] that for any constant ε > 0, it is asymptotically almost
sure (abbreviated by a.a.s.) that
(1− ε)
√
lnn
σn
≤ φ(Pn) ≤ (1 + ε)
√
lnn
σn
.
As the immediate consequence of Theorem 1.1, a tighter a.a.s. lower bound on
φ(Pn) can be obtained: For any sequence (cn) satisfying that limn→∞ cn = ∞ and
limn→∞ cn/ lnn = 0, it is a.s.s. that
φ(Pn) ≥
√
lnn− cn
σn
.
In what follows, o is the origin of the Euclidean plane R2, and D is the unit-area
(closed) disk centered at o. We assume that Pn is the Poisson point process over D
with density n. We denote by Xn = (X1, . . . , Xn) the uniform n-point process over
D. The symbols O, o,∼ always refer to the limit n → ∞. To avoid trivialities, we
tacitly assume n to be suﬃciently large if necessary. For simplicity of notation, the
dependence of sets and random variables on n will be frequently suppressed. For
any ﬁnite set S, card(S) denotes the cardinality of S. For any set S and positive
integer k, the k-fold Cartesian product of S is denoted by Sk. The Euclidean norm
of a point x is denoted by ‖x‖, and the Euclidean distance between two points u
and v is denoted by ‖uv‖. The Lebesgue measure (or area) of a measurable set
A ⊂ R2 is denoted by |A|. The topological boundary of a set A ⊂ R2 is denoted
by ∂A. The open (respectively, closed) disk of radius r centered at x is denoted by
D(x, r) (respectively, D¯(x, r)).
The remaining of this paper is organized as follows. The proof for Theorem 1.1 is
presented in Sec. 3. Some preliminary results to be used in the proof for Theorem 1.1
are established in Sec. 2. The proofs for two technical lemmas on the limits of several
relevant integrals are postponed in Sec. 4.
2. Preliminaries
The lune of a line segment uv, denoted by L(uv), is the intersection of the disks
D(u, ‖uv‖) and D(v, ‖uv‖) (see Fig. 1); the line segment uv is called the waist of
L(uv); the two intersection points of ∂D(u, ‖uv‖) and ∂D(v, ‖uv‖) are called the
vertices of L(uv). It is easy to verify that
|L(uv)| = σ‖uv‖2.
Thus, σ is the area of the lune whose waist has unit length. For a ﬁnite planar set
V , RNG(V ) consists of all edges uv satisfying that L(uv) ∩ V = ∅. For a ﬁnite
On the Longest RNG Edge of Wireless Ad Hoc Networks 29
A topology with numbered vertices is speciﬁed by a collection of the pairs of the
indices of the numbered vertices. For any integer m ≥ 2, denote Tm set of topologies
on m numbered vertices without isolated vertex. For any τ ∈ Tm, and any sequence
U of m planar points, τ(U) denotes the geometric graph on U with topology τ .
For any τ ∈ Tm, we denote by Γ(τ) the set of x ∈ Dm satisfying that all edges of
τ(x) have length in (rn, Rn]. Note that for each x ∈ Γ(τ), the
√
3Rn-disk graph
on the midpoints of the edges in any connected component of τ(x) is connected.
Thus, the
√
3Rn-disk graph on the midpoints of the edges in τ(x) has no more
connected components than τ(x) itself. For any positive integer l no more than the
number of connected components of τ , we denote by Γl(τ) the set of x ∈ Γ(τ) such
that the
√
3Rn-disk graph on the midpoints of the edges in τ(x) has l connected
components.
Lemma 2.2. Suppose that 2 < m ≤ 2k and τ is a forest in Tm with k edges. Then,
for any positive integer l ≤ min{m− k, k − 1},
nm
∫
Γl(τ)
fn(τ(x))dx = o(1),
nm
∫
Γl(τ)
gn(τ(x))dx = o(1).
The proof for Lemma 2.2 is also postponed to Sec. 4. Lemma 2.2 implies the
following two corollaries.
Corollary 2.3. Suppose that τ ∈ T2k is a perfect matching for some k ≥ 2. Then,
n2k
∫
Γk(τ)
gn(τ(x))dx ∼ (2μ)k.
Proof. We denote by Ck the perfect matching of 2k numbered vertices
v1, v2, . . . , v2k which consists of k edges v2i−1v2i for 1 ≤ i ≤ k. By symmetry,
we only have to prove the lemma holds for τ = Ck. Note that
Γk(Ck) = Γ(Ck)\∪k−1l=1 Γl(Ck).
Since Γ(Ck) = Ωk, we have
n2k
∫
Γ(Ck)
gn(Ck(x))dx =
k∏
i=1
(
n2
∫
Ω
e−nν(x2i−1x2i)dx2i−1dx2i
)
∼ (2μ)k.
By Lemma 2.2 for each 1 ≤ l ≤ k − 1,
n2k
∫
Γl(Ck)
gn(Ck(x))dx = o(1).
Thus, the corollary holds.
On the Longest RNG Edge of Wireless Ad Hoc Networks 31
In addition, if τ is a perfect matching then for any x ∈ Γm/2(τ),
Pr[Bn(τ(x)) = 1] = gn(τ(x)).
If τ is not a perfect matching, then by Corollary 2.4, we have
nmE[Bn(τ(Xm))] ≤ nm
∫
Γ(τ)
fn(τ(x))dx = o(1).
In the next, we assume that τ is a perfect matching. Let m = 2k. For k = 1,
Γ(τ) = Ω and hence by Lemma 2.1 we have
n2E[Bn(τ(X2))] = n2
∫
Ω
Pr[Bn(τ(x)) = 1]dx
= n2
∫
Ω
e−nν(x1x2)dx1dx2
∼ 2μ.
So, the Lemma holds for k = 1. So, we further assume that k ≥ 2. Note that
n2kE[Bn(τ(X2k))] = n2k
∫
Γ(τ)
Pr[Bn(τ(x)) = 1]dx
=
k∑
l=1
n2k
∫
Γl(τ)
Pr[Bn(τ(x)) = 1]dx.
By Corollary 2.3 we have
n2k
∫
Γk(τ)
Pr[Bn(τ(x)) = 1]dx = n2k
∫
Γk(τ)
gn(τ(x))dx ∼ (2μ)k,
and for any 1 ≤ l < k,
n2k
∫
Γl(τ)
Pr[Bn(τ(x)) = 1]dx ≤ n2k
∫
Γl(τ)
fn(τ(x))dx = o(1).
Thus,
n2kE[Bn(τ(X2k))] ∼ (2μ)k.
So, the Lemma holds in this case.
For any x = (x1, x2) ∈ D2, let B′n(x) be the indicator for x1x2 ∈ RNG({x1, x2}∪
Pn) and Rn < ‖x1x2‖ ≤ R′n.
Lemma 2.6. n2E[B′n(X2)] = o(1).
On the Longest RNG Edge of Wireless Ad Hoc Networks 33
that S(Pn, rn) = 0. Therefore, our claim holds. Consequently,
Pr[M ′′n > 0] ≤ Pr[S(Pn, R′n) = 0] = o(1).
Two key techniques used in our remaining proof are the Palm theory for Poisson
processes (see, e.g. Theorem 1.6 in [12]) and the Brun’s sieve (see, e.g. Theorem 10
in [16]), which are stated below.
Theorem 3.2. Suppose that N is a non-negative integer random variable, and
B1, . . . , BN are N Bernoulli random variables. If there is a constant μ such that
for every ﬁxed positive integer k,
E
⎡
⎣ ∑
I⊆{1,...,N},|I|=k
∏
i∈I
Bi
⎤
⎦ ∼ μ
k
k!
,
then
∑N
i=1 Bi is asymptotically Poisson with mean μ.
Theorem 3.3. Suppose that h(U, V ) is a bounded measurable function deﬁned on
all pairs of the form (U, V ) with V being a ﬁnite planar set and U being a subset of
V . Then for any positive integer k,
E
⎡
⎣ ∑
U⊆Pn,|U|=k
h(U,Pn)
⎤
⎦ = n
k
k!
E[h(Xk,Xk ∪ Pn)].
Now, we apply Palm theory to show that E[M ′n] is vanishing.
Lemma 3.4. E[M ′n] = o(1).
Proof. For any pair (U, V ) with V being a ﬁnite planar set and U being a subset of
V , deﬁne h′(U, V ) to be the number of edges in the subgraph of RNG(V ) induced
by U with length in (Rn, R′n]. By applying the Palm theory, we have
E[M ′n] = E
⎡
⎣ ∑
U⊂Pn,|U|=2
h′(U,Pn)
⎤
⎦
=
n2
2
E[h′(X2,X2 ∪ Pn)]
=
n2
2
E[B′n(X2)].
By Lemma 2.6, the lemma follows.
For any positive integer k, denote by Hn,k the collection of k-edge subgraphs
of RNG(Pn) in which all edges have length in (rn, Rn] and no vertex is isolated.
Next, we apply Palm theory to compute the asymptotic average of card(Hn,k).
On the Longest RNG Edge of Wireless Ad Hoc Networks 35
Lemma 3.6. Mn is asymptotically Poisson with mean μ.
Proof. Let En be the set of edges of RNG(Pn). For any edge e ∈ En, deﬁne B¯(e)
to be the Bernoulli random variable which equals to one if and only if rn < ‖e‖ ≤
Rn. Then
Mn =
∑
e∈En
B¯(e).
For subset F of En,
∏
e∈F B¯(e) = 1 if and only if F is the edge set of a subgraph of
RNG(Pn) in which all edges have length in (rn, Rn] and no vertex is isolated. Fix
a positive integer k. By treating each k-subset F of En as an k-edge subgraphs of
RNG(Pn), we have that
∑
F⊆En,|F |=k
∏
e∈F
B¯(e) = card(Hn,k).
Hence, by Lemma 3.5,
E
⎡
⎣ ∑
F⊆En,|F |=k
∏
e∈F
B¯(e)
⎤
⎦ ∼ μ
k
k!
.
By Theorem 3.2, Mn is asymptotically Poisson with mean μ.
4. Proofs for Lemma 2.1 and Lemma 2.2
In this section, we prove Lemma 2.1 and Lemma 2.2. We ﬁrst present some useful
geometric results. For x ∈ D, let t(x) denote the distance between x and ∂D, which
is equal to 1√
π
− ‖x‖. For any 0 < ρ < 1√
π
, deﬁne
Dρ(0) = {x ∈ D : t(x) ≥ ρ},
Dρ(1) =
{
x ∈ D :
√
1
π
− ρ2 ≤ t(x) < ρ
}
,
Dρ(2) =
{
x ∈ D : t(x) <
√
1
π
− ρ2
}
.
With this notation, the midpoint of any line segment xy ⊂ D is not in D‖xy‖/2(2).
For x ∈ D and 0 < ρ < 1√
π
, deﬁne θ(x, ρ) as follows. If x ∈ Dρ(0), then θ(x, ρ) = 2π.
If x ∈ Dρ(2), then θ(x, ρ) = 0. If x ∈ Dρ(1), let u and v be the two intersection
points of ∂B(x, ρ) and ∂D, and deﬁne θ(x, ρ) = 2π − ∠uxv (see Fig. 2).
Lemma 4.1. For x ∈ D and 0 < ρ < 1√
π
,
ρθ(x, ρ) ≤ 2πt(x).
On the Longest RNG Edge of Wireless Ad Hoc Networks 37
b
c
2
1
c
u
a
z
Fig. 3. L(e) ∩ D contains the triangle abc2 and the half lune abu.
R ≤ 1
200
√
π
and the midpoints of its edges induce a connected
√
3R-disk graph. Let
e′ be an outermost edge of H, and  be the largest distance between the midpoint of
e′ and the midpoints of other edges of H. Then,
∑
e∈E(H)
ν(e) ≥ ν(e′) + 0.0026R.
In addition, if χ(H) = 1 then
ν(H) ≥ ν(e′) + 0.0026R.
The proof of this lemma is very lengthy and complicated. We omit the proof
due to the limitation on the space.
Now it is ready to give the proofs for Lemma 2.1 and Lemma 2.2. We will
frequently change the integral variables using a technique introduced in [16]. Con-
sider a tree topology on k planar points x1, x2, . . . , xk, and assume without loss
of generality that xk−1xk is an edge in this tree. Let zk−1, ρ, and ω be the mid-
point, half-length and the slope of xk−1xk respectively. We root the tree at xk. For
1 ≤ i ≤ k − 2, let zi be the midpoint of the edge between xi and its parent in
such rooted tree. Then, we replace x1, x2, . . . , xk by z1, . . . , zk−1, ρ, ω. The Jacobian
determinant of this change is 4k−1ρ.
We begin with the proof for Lemma 2.1. Let ρ = ρ(x1, x2) be the half-length of
x1x2, and z = z(x1, x2) be the midpoint of x1x2. Let Ω1 be the set of (x1, x2) ∈ Ω
satisfying that z ∈ D√3ρ(0), and let Ω2 = Ω\Ω1. First, we calculate the integration
over Ω1. If (x1, x2) ∈ Ω1, L(x1x2) is fully contained in D and v(x1x2) = 4σρ2.
Changing the integration variable x1 and x2 by z, ρ, and the slope of x1x2 yields
n2
∫
Ω1
e−nv(x1x2)dx1dx2 = 8πn2
∫ Rn
2
rn
2
e−4nσρ
2
ρdρ
∫
D√3ρ(0)
dz
∼ 8πn2
∫ Rn
2
rn
2
e−4nσρ
2
ρdρ
On the Longest RNG Edge of Wireless Ad Hoc Networks 39
Therefore,
n2
∫
Ω
e−nvx1x2dx1dx2 ∼ 2μ.
Note that Ω ∪ Ω′ consists of (x1, x2) ∈ D2 satisfying that rn < ‖x1x2‖ ≤ R′n.
Using the same argument as above, we can show that
n2
∫
Ω∪Ω′
e−nv(x1x2)dx1dx2 ∼ 2μ.
Thus, the second asymptotic equality in Lemma 2.1 holds.
We move to prove Lemma 2.2 by establishing the following two lemmas.
Lemma 4.4. Suppose that 2 < m ≤ 2k and τ is a forest in Tm with k edges. Then,
nm
∫
Γ1(τ)
fn(τ(x))dx = o(1),
nm
∫
Γ1(τ)
gn(τ(x))dx = o(1).
Proof. Enumerate the edges of τ arbitrarily by e1, . . . , ek. For any x ∈ Γ1(τ), let
zi denote the middle point of ei in F (x) for each 1 ≤ i ≤ k. For any pair of distinct
integers p and q between 1 and k, let Spq denote the set of x ∈ Γ1(τ) satisfying that
ep is an outermost edge in τ(x) and zq is the farthest from zp among all z1, . . . , zk.
Then, it suﬃces to prove for any such p and q,
nm
∫
Spq
fn(τ(x))dx = o(1),
nm
∫
Spq
gn(τ(x))dx = o(1).
Fix a pair of distinct integers p and q between 1 and k. Let p′ and p′′ be the indices
of the two endpoints of the edges ep. By Lemma 4.3 for any x ∈ Spq,
fn(τ(x)) ≤ e−n(v(xp′xp′′ )+ηRn‖zpzq‖),
gn(τ(x)) ≤ e−n(v(xp′xp′′ )+ηRn‖zpzq‖),
in which η is a positive constant. Thus, we only need to show that
nm
∫
Spq
e−n(v(xp′xp′′)+ηRn‖zpzq‖)dx = o(1).
We change the integral variables x1, . . . , xm as follows. For the tree component
containing ep, we replace the xi’s in this tree by the midpoints of the edges in this
tree except zp and xp′ , xp′′ (both of which are kept). For any other tree component,
we use the method introduced at the beginning of this section: pick an arbitrary
edge as the rooted edge. We replace xi’s in this tree by the midpoints of all the
On the Longest RNG Edge of Wireless Ad Hoc Networks 41
{1, 2, . . . ,m} in which Pj = ∪q∈Qj Iq for each 1 ≤ j ≤ l. Let S(Π) denote the set of
x ∈ Γl(τ) such that for each 1 ≤ j ≤ l, the set of midpoints of the subgraph of τ(x)
induced by {xi : i ∈ Pj} is a connected component of the
√
3Rn-disk graph on the
midpoints of the edges in τ(x). Then Γl(τ) is the union of S(Π) over all nontrivial
l-partitions Π of {1, 2, . . . ,m−k}. So, it is suﬃcient to show that for any l-partition
Π of {1, 2, . . . , k},
nm
∫
S(Π)
fn(τ(x))dx = o(1),
nm
∫
S(Π)
gn(τ(x))dx = o(1).
Now, ﬁx an l-partition Π = {Q1, Q2, . . . , Ql} of {1, 2, . . . ,m − k}. Let Π′ =
{P1, P2, . . . , Pl} be the partition of {1, 2, . . . ,m} induced by Π. For each 1 ≤ j ≤ l,
let mj = card(Pj), τj be the topology on mj numbered vertices which is a subgraph
of τ induced by the subset of vertices {vi : i ∈ Pj}. Then, at least one mj ≥ 2. For
any x = (x1, x2, . . . , xm) ∈ Dm and each 1 ≤ j ≤ l, let
x(j) = (xi1 , xi2 , . . . , ximj )
where i1, i2, . . . , imj are the mj indices in Pj in the increasing order. Clearly, for
each x ∈ S(Π) and each 1 ≤ j ≤ l, x(j) ∈ Γ1(τj). Hence,
S(Π) ⊆ {x ∈ Dm : x(j) ∈ Γ1(τj), 1 ≤ j ≤ l}.
For any x ∈ S(Π),
ν(τ(x)) =
l∑
j=1
ν(τj(x(j))),
χ(τ(x)) ≤
l∏
j=1
χ(τj(x(j))),
which imply
fn(τ(x)) ≤
l∏
j=1
fn(τj(x(j))).
It is obvious that for any x ∈ S(Π),
gn(τ(x)) =
l∏
j=1
gnt(τj(x(j))).
On the Longest RNG Edge of Wireless Ad Hoc Networks 43
[7] B. Karp and H. T. Kung, GPSR: Greedy perimeter stateless routing for wireless
networks, ACM MOBICOM, 2000.
[8] X.-Y. Li, P.-J. Wan and W. Yu, Power eﬃcient and sparse spanner for wireless ad
hoc networks, IEEE ICCCN, 2001.
[9] N. Li and J. C. Hou, Localized topology control algorithms for heterogeneous wireless
networks, IEEE/ACM Trans. Netw. 13 (2005) 1313–1324.
[10] G. Kozma, Z. Lotker, M. Sharir and G. Stupp, Geometrically aware communication
in random wireless networks, ACM PODC, 2004.
[11] M. D. Penrose, The longest edge of the random minimal spanning tree, Ann. Appl.
Probab. 7 (1997) 340–361.
[12] M. Penrose, Random Geometric Graphs (Oxford University Press, 2003).
[13] M. Seddigh, J. Solano and I. Stojmenovic, RNG and internal node based broadcasting
in one-to-one wireless networks, ACM Mob. Comput. Commun. Rev. 5 (2001) 37–44.
[14] H. Takagi and L. Kleinrock, Optimal transmission ranges for randomly distributed
packet radio terminals, IEEE Trans. Commun. 32(3) (1984) 246–257.
[15] G. Toussaint, The relative neighborhood graph of a ﬁnite planar set, Pattern Recogn.
12 (1980) 261–268.
[16] P.-J. Wan and C.-W. Yi, On the longest edge of gabriel graphs in wireless ad hoc
networks, IEEE Trans. Parall. Distri. Syst. 18 (2007) 111–125.
[17] P.-J. Wan, C.-W. Yi, F. Yao and X. Jia, Asymptotic critical transmission radius
for greedy forward routing in wireless ad hoc networks, ACM MOBIHOC (2006),
pp. 25–36.
Algorithmica (2008) 50: 58–71
DOI 10.1007/s00453-007-9043-4
An Optimal Algorithm for the Minimum Disc Cover
Problem
Min-Te Sun · Chih-Wei Yi · Chuan-Kai Yang ·
Ten-Hwang Lai
Received: 13 October 2005 / Accepted: 24 May 2006 / Published online: 10 November 2007
© Springer Science+Business Media, LLC 2007
Abstract The minimum disc cover can be used to construct a dominating set on the
ﬂy for energy-efﬁcient communications in mobile ad hoc networks, but the approach
used to compute the minimum disc cover proposed in previous studies is computa-
tionally relatively expensive. In this paper, we show that the disc cover problem is
in fact a special case of the general α-hull problem. In spite of being a special case,
the disc cover problem is not easier than the general α-hull problem. In addition to
applying the existing α-hull algorithm to solve the disc cover problem, we present a
simple, yet optimal divide-and-conquer algorithm that constructs the minimum disc
cover for arbitrary cases, including those degenerate cases where the α-hull approach
would fail.
Keywords Minimum disc cover · α-hull · Optimal algorithms · Applications in ad
hoc networks
M.-T. Sun ()
Department of Computer Science and Software Engineering, Auburn University,
Auburn, AL 36849, USA
e-mail: sunmint@eng.auburn.edu
C.-W. Yi
Department of Computer Science, National Chiao Tung University, Hsinchu City 30010, Taiwan
e-mail: yi@cs.nctu.edu.tw
C.-K. Yang
Department of Information Management, National Taiwan University of Science and Technology,
Taipei 106, Taiwan
e-mail: ckyang@cs.ntust.edu.tw
T.-H. Lai
Department of Computer Science and Engineering, Ohio State University,
Columbus, OH 43210, USA
e-mail: lai@cse.ohio-state.edu
60 Algorithmica (2008) 50: 58–71
Fig. 1 The α-hull and convex
hull (the dashed lines) for a
given set of points
i’s location as Oi , or simply i if there is no ambiguity, and denote its coverage disc
as D(Oi), or simply Di . The Euclidean distance between nodes i and j is denoted as
dist(Oi,Oj ), or dist(i, j). The minimum disc cover problem is formally deﬁned as
follows.
Deﬁnition 1 Minimum Disc Cover Problem
Instance: A set of unit discs, = {D0,D1,D2, . . . ,Dn}, such that dist(D0,Di) < 11
for all i, 1 ≤ i ≤ n.
Question: Find a subset ′ ⊆  such that ∣∣′∣∣ is minimum and
⋃
Di∈′
Di =
⋃
Dj∈
Dj .
(Note that no two discs share the same origin. Also, D0 may be included in ′.)
We will relate the minimum disc cover problem to another problem, called α-hull.
For any negative number α and any set of points S on a two-dimensional plane, the α-
hull for S is deﬁned as the intersection of all closed complements of discs (with radius
−1/α) that contain all the points in S [4]. (Note that it is the discs’ complements, not
the discs themselves, that contain the points in S.)
Since we are only interested in unit discs, we will assume α = −1 unless other-
wise indicated. With such an assumption, the shape of an α-hull resembles an inward
curved convex hull, where each edge of the α-hull is an arc of a unit circle. A con-
venient way to visualize the shape of an α-hull is to envision the points in S as nails
ﬁxed on the plane and a steel wheel of radius 1 is rolled around the nails to obtain the
outer contour of S. The contour is the α-hull for S. Figure 1 illustrates a set of points’
α-hull as well as its convex hull.
The following theorem shows a simple connection between the minimum disc
cover and α-hull problems.
Theorem 1 Let  = {D0,D1, . . . ,Dn} be an instance of the minimum disc cover
problem, and let S = {O0,O1, . . . ,On} be the corresponding set of origins. Then the
set of all vertices of S’s α-hull, with α = −1, corresponds to a minimum cover for .
1In this paper, we adopt the open disk model. However, the same results can be had for the close disk
model, where dist(D0,Di) < 1 is replaced by dist(D0,Di) ≤ 1 in the problem deﬁnition.
62 Algorithmica (2008) 50: 58–71
Fig. 3 The distance between a
and x is at least 1 if x is not
covered by D(p) and D(q)
Fig. 4 The disc centered at a
vertex of the α-hull covers some
area not covered by other nodes
in S
Now, we establish the optimality of ′ by showing that any disc cover for  must
contain ′ as a subset. Let C be the set of origins of any disc cover for , and let p
be any point in P . We need to show p ∈ C.
If the steel unit disc rolls around a point p ∈ P without touching another one, all
other points in S have to be at least 2 units away from p. The only possibility of this
scenario is when p = O0 and S = {O0}.
Now suppose there are at least two points in S. Then, a point p ∈ P must be an
endpoint of some arc pq on the α-hull’s boundary. pq is part of the circumference
of the rolling steel unit disc. Let us denote the origin of the rolling steel unit disc
passing through p and q as c. The disc D(c) must contain no point in S inside it.
Note that points in S could appear on the arc pq, for example the point r in Fig. 4.
Since S contains only a ﬁnite number of points, it is easy to see from Fig. 4 that there
is always an area close to c (i.e., the part of the shaded region close to c in Fig. 4)
that is only covered by disc D(p) but not by any other disc in . Therefore, p must
be in C. 
64 Algorithmica (2008) 50: 58–71
Fig. 6 The boundary of⋃
Oi∈S D(Oi) is formed by a
series of arcs 〈AiAi+1〉
viewed as the union of Sector(AiAi+1, AiO0, Ai+1O0), 1 ≤ i ≤ k. We show in the
following lemma that the unit discs that contribute arcs AiAi+1 (1 ≤ i ≤ k) form a
minimum disc cover of .
Lemma 2 Let A1A2,

A2A3, . . . ,

Ak−1Ak,

AkAk+1 be the arcs surrounding U =⋃
Oi∈S D(Oi), where A1 = Ak+1; and for 1 ≤ i ≤ k, let D(Oti ) be the unit disc
that contributes AiAi+1. The set of unit discs, {D(Ot1),D(Ot2), . . . ,D(Otk )}, is a
minimum disc cover for .
Proof We ﬁrst claim that any unit disc D(Oti ) that contributes an arc to the boundary
of U must be included in any disc cover of . To see this, observe that if AiAi+1
is contributed by Oti , then the area close to

AiAi+1 is not covered by any disc other
than D(Oti ).
Now, the area U can be thought of as a collection of disjoint pieces, each sur-
rounded by AiAi+1, AiO , and Ai+1O , where i ranges from 1 to k. By Lemma 1,
each such piece is covered by a unit disc D(Oti ). Thus, {D(Ot1), . . . ,D(Otk )} is a
disc cover for . Applying the above claim, the cover is minimum. 
Notice that a unit disc D(Oti ) may contribute more than one arc to the boundary
of U . This implies that the same unit disc D(Oti ) may appear more than once in the
disc cover set {D(Ot1),D(Ot2), . . . ,D(Otk )}. In fact, a unit disc in  may contribute
zero, one, or two arcs to the boundary of U . The possibility of contributing more than
one arc is the main reason why the minimum disc cover problem is nontrivial. This
will be further discussed in Sect. 3.5.
66 Algorithmica (2008) 50: 58–71
Fig. 7 SplittingBC intoBF
andFC, and splittingDE into

DG andGE
we sort each list based on the value of the ﬁrst angle (i.e., αi ) in ascending or-
der, so that βsi = αsi+1 , 0 ≤ i ≤ max, with the understanding that i + 1 is com-
puted modulo max. Thus, the boundary of a super disc can be represented simply
as (Os0 , αs0,Os1, αs1, . . . ,Osmax , αsmax), where 0◦ = αs0 < · · · < αsmax < 360◦.
3.4 Merging Two Arc Lists
Now, given two sorted arc lists{
ArcList1 = (Os0, αs0 ,Os1, αs1, . . . ,Osmax , αsmax),
ArcList2 = (Ot0 , αt0,Ot1 , αt1, . . . ,Otmax , αtmax)
representing the boundaries of super discs UD(i,m) and UD(m+ 1, j), respectively,
we want to merge them so that the resulting list represents the boundary ofUD(i, j) =
UD(i,m)∪UD(m+ 1, j).
The ﬁrst step is to split the arcs in each list into smaller arcs, if necessary, so that
the two reﬁned arc lists share the same sequence of angles (i.e., α’s). For instance,
as illustrated in Fig. 7, BC is split into BF and FC, and DE is split into DG and

GE. With such splits, arc lists {AB,BC} and {DE,EC} become {AB, BF , FC}
and {DG,GE,EC}, respectively, which share the same sequence of angles with O0
at the apex. As another example, if{
ArcList1 = (Os0,0◦,Os1 ,30◦,Os2 ,140◦,Os3,200◦),
ArcList2 = (Ot0 ,0◦,Ot1,120◦,Ot2,240◦),
they will be reﬁned to{
ArcList′1 = (Os0 ,0◦,Os1 ,30◦,Os1 ,120◦,Os2 ,140◦,Os3,200◦,Os3,240◦),
ArcList′2 = (Ot0 ,0◦,Ot0 ,30◦,Ot1 ,120◦,Ot1 ,140◦,Ot1 ,200◦,Ot2 ,240◦).
Now, let us consider the general case. After splitting, the given lists will contain
the same number of arcs:{
ArcList1 = (Os0 , αs0,Os1 , αs1, . . . ,Osk , αsk ),
ArcList2 = (Ot0 , αs0,Ot1 , αs1, . . . ,Otk , αsk )
for some k. To merge the two lists, we simply merge each individual pair of corre-
sponding arcs, Arc(Osi , αi, αi+1) and Arc(Oti , αi, αi+1) as follows. (See Fig. 8 for
illustration.)
68 Algorithmica (2008) 50: 58–71
Fig. 9 The possible area for the
origin of a third disc that breaks

AB into two arcsAP andQB
disc. Now, if a disc is able to contribute three arcs to the boundary of
⋃
Oi∈S D(Oi),
the three arcs must be pairwisely separated by at least 120◦. Adding up the degrees of
the angles for the gaps and the degrees of the angles for the arcs themselves, the total
would exceed 360◦, which is not possible. Therefore, a unit disc can only contribute
at most two arcs to the boundary of
⋃
Oi∈S D(Oi). 
Now we are ready to show that our algorithm has time complexity O(n logn).
Theorem 2 Algorithm Boundary has time complexityO(n logn), where n is the num-
ber of unit discs in .
Proof The running time, T (n), of Algorithm Boundary({O0,O1,O2, . . . ,On}; i, j)
satisﬁes the recurrence
T (n) =
{
T (n2 )+ T (n2 )+ T (ArcMerge) if n > 1,
O(1) if |n| = 1,
where n = j − i + 1. Since each disc can only contribute at most two arcs (by
Lemma 3), ArcList1 and ArcList2 each contain at most O(n) “unsplit” arcs. After
splitting, each list still contains at most O(n) arcs. Since merging two arcs with the
same angle span (as described at the end of Sect. 3.4) takes O(1) time, merging the
two (reﬁned) arc lists takesO(n) time. So, the time complexity of ArcMerge isO(n).
Solving the above recurrence then yields T (n) =O(n logn). 
4 Optimality of the Time Complexity
In an earlier section we established the connection between the minimum disc cover
and α-hull problems; and it has been shown in [4] that any algorithm that constructs
70 Algorithmica (2008) 50: 58–71
5 Conclusion and Future Work
We showed the minimum disc cover problem to be a special case of the α-hull prob-
lem. Then we showed that being a special case does not make it simpler than the
general α-hull problem in terms of time complexity—both problems need at least
(n logn) time. We proposed two optimal algorithms for constructing minimum disc
covers. The ﬁrst applies an existing algorithm for the α-hull. However, this approach
needs to construct Delaunay Triangulations and would fail should more than three
disc origins fall on the circumference of a circle. Our second method is a divide-and-
conquer algorithm, which is conceptually simpler and works well even for degenerate
cases.
Although the proposed algorithms are optimal in terms of time complexity, there
may still be room for improvement when the algorithm is used in applications such as
message broadcast or media access control in mobile ad hoc networks. One possibil-
ity is for each node to keep track of its neighbors’ movements and “predict” when the
members of its minimum disc cover are likely to change, and only then re-compute
the new minimum cover. This will reduce the number of times a node computes its
minimum disc cover, thereby reducing the power consumed by such computations.
This is known as the Kinetic Collision Detection model [1]. This model will be ex-
plored in our future work.
References
1. Basch, J., Erickson, J., Guibas, L.J., Hershberger, J., Zhang, L.: Kinetic collision detection for two
simple polygons. In: Proceedings of the Tenth Annual ACM-SIAM Symposium on Discrete Algo-
rithms, pp. 102–111, 1999
2. de Berg, M., van Kreveld, M., Overmars, M., Schwarzkopf, O.: Computational Geometry. Springer,
Berlin (2000)
3. Dobkin, D.P., Lipton, R.J.: On the complexity of computations under varying sets of primitives. J.
Comput. Syst. Sci. 18, 86–91 (1979)
4. Edelsbrunner, H., Kirkpatrick, D.G., Seidel, R.: On the shape of a set of points in the plane. IEEE
Trans. Inform. Theory IT-29, 551–559 (1983)
5. Garey, M.L., Johnson, D.S.: Computers and Intractability: A Guide to the Theory of NP-
Completeness. Freeman, San Francisco (1979)
6. Intanagonwiwat, C., Govindan, R., Estrin, D.: Directed diffusion: a scalable and robust communica-
tion paradigm for sensor networks. In: Proceedings of the 6th Annual International Conference on
Mobile Computing and Networking, pp. 56–67, 2000
7. Ko, Y.-B., Vaidya, N.H.: Location-aided routing (LAR) in mobile ad hoc networks. In: Proceedings
of the 4th Annual ACM/IEEE International Conference on Mobile Computing and Networking, pp.
66–75, 1998
8. Peng, W., Lu, X.: On the reduction of broadcast redundancy in mobile ad hoc networks. In: Proceed-
ings of the First ACM International Symposium on Mobile and Ad Hoc Networking and Computing
(MobiHoc), pp. 129–130, 2000
9. Sun, M., Feng,W., Lai, T.-H., Yamada, K., Okada, H., Fujimura, K.: GPS-based message broadcast for
adaptive inter-vehicle communications. In: Proceedings of IEEE International Conference on Parallel
Processing, pp. 279–286, 2000
10. Sun, M., Huang, L., Wang, S., Arora, A., Lai, T.-H.: Reliable MAC Layer Multicast in IEEE 802.11
Wireless Networks, Special Issue of Wiley Wireless Communications and Mobile Computing on Re-
search in Ad Hoc Networking, Smart Sensing, and Pervasive Computing, 2003
11. Sun, M., Lai, T.-H.: Location aided broadcast in wireless ad hoc network systems. In: Proceedings of
IEEE Wireless Communications and Networking Conference, pp. 597–602, 2002
附錄十五： 
 
Maximizing lifetime of sensor 
surveillance systems 
 
 
 
 
H. Liu, X. Jia, P.-J. Wan, C.-W. Yi, S. K. Makki, and N. 
Pissinou 
IEEE/ACM Transactions on Networking (TON), Vol. 15, No. 2, April 
2007. 
LIU et al.: MAXIMIZING LIFETIME OF SENSOR SURVEILLANCE SYSTEMS 335
such as Directed Diffusion [7], LEACH [8], PEGASIS [9], and
ACQUIRE [10]. Directed Diffusion is regarded as an improve-
ment over the SPIN [11] protocol that used a proactive approach
for information dissemination. LEACH organizes sensor nodes
into clusters to fuse data before transmitting to the BS. PE-
GASIS improved the LEACH by considering both metrics of
energy consumption and data-gathering delay. In [12], an ana-
lytical model was proposed to ﬁnd the upper bound of the life-
time of a sensor network, given the surveillance region and a
BS, the number of sensor nodes deployed and initial energy of
each node. Some routing schemes for maximizing network life-
time were presented in [13]. In [14], an analytic model was pro-
posed to analyze the tradeoff between the energy cost for each
node to probe its neighbors and the routing accuracy in geo-
graphic routing, and a localized method was proposed. In [15]
and [16], linear programming (LP) formulation was used to ﬁnd
energy-efﬁcient routes from sensor nodes to the BS, and approx-
imation algorithms were proposed to solve the LP formulation.
Another important technique used to prolong the lifetime of
sensor networks is the introduction of switch on/off modes for
sensor nodes. J. Carle et al. did a good survey in [17] on energy-
efﬁcient area monitoring for sensor networks. They pointed out
that the best method for conserving energy is to turn off as many
sensors as possible, while still keeping the system functioning.
An analytical model was proposed in [18] to analyze the system
performance, such as network capacity and data delivery delay,
against the sensor dynamics in on/off modes. A node scheduling
scheme was developed in [19]. This scheme schedules the nodes
to turn on or off without affecting the overall service provided. A
node decides to turn off when it discovers that its neighbors can
help it to monitor its monitoring area. The scheduling scheme
works in a localized fashion where nodes make decisions based
on its local information. Similar to [19], the work in [20] deﬁned
a criterion for sensor nodes to turn themselves off in surveil-
lance systems. A node can turn itself off if its monitoring area
is the smallest among all its neighbors and its neighbors will
become responsible for that area. This process continues until
the surveillance area of a node is smaller than a given threshold.
A deployment of a wireless sensor network in the real world
for habitat monitoring was discussed in [21]. A network con-
sisting of 32 nodeswas deployed on a small island tomonitor the
habitat environment. Several energy conservation methods were
adopted, including the use of sleep mode, energy-efﬁcient com-
munication protocols, and heterogeneous transmission power
for different types of nodes.
We use both of the above-mentioned techniques to maxi-
mize the network lifetime in our solution. We ﬁnd the optimal
schedule to switch on/off sensors to watch targets in turn, and
we ﬁnd the optimal routes to forward data from sensor nodes to
the BS.
III. SYSTEM MODEL AND PROBLEM STATEMENT
We consider a set of targets and a set of sensors that are used
to watch targets and collect information. We ﬁrst introduce the
following notations:
base station whose energy is unbounded.
set of sensors, and .
set of targets, and .
set of sensors that are able to watch target
.
set of targets that are within the surveillance range
of sensor .
set of neighbors of sensor .
initial energy reserve of sensor .
distance between sensor and
.
, energy required for transmitting and receiving one
unit data, respectively.
energy required for watching a target per unit time.
data rate generated from sensors while watching
targets.
Notice that may overlap with for , and
may overlap with for . There are two requirements
for sensors watching targets:
1) Each sensor can watch at most one target at a time.
2) Each target should be watched by one sensor at anytime.
The problem of our concern is, for given , and , to ﬁnd
a schedule that meets the above two requirements for sensors
watching targets, such that the lifetime of network ismaximized.
The lifetime of network is the length of time until there exists
a target such that all sensors in run out their energy or
the sensed data cannot be forwarded back to the BS due to the
disconnection of the network.
IV. OUR SOLUTIONS
We solve the problem in three steps. First, we compute
the upper bound on the maximal lifetime of the system and
ﬁnd a workload matrix and data ﬂows of sensors. Second, we
completely decompose the workload matrix into a sequence of
schedule matrices without compromising the obtained maximal
lifetime. Finally, we determine a sensor surveillance tree for
each schedule matrix that speciﬁes the active sensors and the
routes to forward sensed data to the BS.
A. Find Maximal Lifetime
We use linear programming (LP) technique to ﬁnd the max-
imal lifetime of the system. Let denote the lifetime of the
surveillance system. We introduce two variables:
total time sensor watching target .
amount of data transmitted from sensor to sensor
(the receiver can be the BS).
The problem of ﬁnding the maximal lifetime for sensors
watching targets can be formulated as the following:
(1)
(2)
(3)
LIU et al.: MAXIMIZING LIFETIME OF SENSOR SURVEILLANCE SYSTEMS 337
To decompose the workload matrix into a se-
quence of schedule matrices, our basic idea is to represent
as a bipartite graph , where one side
are sensors and the other are targets
. For each non-zero element in the
workload matrix, there is an edge between and and the
weight of the edge is . Since , every sensor has a target
to watch in any session. This means sensors exactly match
targets in each session, which can be represented as a perfect
matching in the bipartite graph . Thus, each schedule matrix
is corresponding to a perfect matching. The problem of decom-
posing the workload matrix is transformed into the problem of
ﬁnding perfect matchings in .
The decomposing process is as follows. Each time, we com-
pute a perfect matching in the bipartite graph. has exactly
edges, which deﬁnes the pairs of sensor-target watching. Let
be the smallest weight of the edges in .We deduct from
the weight of the edges in and remove the edges whose
weight becomes zero. The schedule matrix , corresponding
to this matching , can be represented as , where is
the permutation matrix of . (A permutation matrix is a square
matrix that has only “0” and “1” elements, and each row and
each column has exactly one “1” element). The schedule matrix
deﬁnes the sensor-target watching of a session and
is the duration of this session. This decomposing process is re-
peated until there is no perfect matching can be found any more
in the bipartite graph.
For example, suppose we obtained a workload matrix
for a system with three sensors and three targets
from the LP (1)–(5). The matrix is ﬁrst represented as a bipartite
graph shown in Fig. 1(a). We compute a perfect matching in
as shown in Fig. 1(b) and the smallest edge weight
in the matching. The schedule matrix corresponding to this
matching is . Then we deduct from the weight
of the three edges in the perfect matching and remove the edges
and whose weight become zero. The resulting
bipartite graph is shown in Fig. 1(c). We repeat the operation
until all edges are removed from .
The details of the algorithm for decomposing a workload ma-
trix when are given below.
DecomposeMatrix-nn Algorithm
Input: a workload matrix .
Output: a sequence of schedule matrices .
Begin
Construct a bipartite graph from
while there exist edges in do
Find a perfect matching on ;
Represent as ;
(a)
(b)
(c)
Fig. 1. (a) The bipartite graph. (b) A perfect matching. (c) The graph after
deducting .
Deduct from the edges in and remove edges
whose weight is 0;
endwhile
Output ;
End
The above algorithm tries to decompose the matrix by using
the technique of ﬁnding perfect matchings. There are two ques-
tions about this decomposability:
1) Does it guarantee that there exists a perfect matching in
every round of the decomposition?
2) Does it guarantee that the number of decomposition rounds
is bounded?
Theorem 1 and Theorem 2 will give answers to these two
questions, respectively. To prove Theorem 1, we need the fol-
lowing lemma.
Lemma 1: For any square matrix of nonnegative real
numbers, if for , , there exists a perfect
matching in the corresponding bipartite graph, where and
are the sum of row and the sum of column of ,
respectively.
Proof: Let be the sum of all elements in a row in ,
and denotes matrix . It is obvious that
is a doubly stochastic matrix [22], [23], where the sum of
all elements in any row or column is equal to 1.
LIU et al.: MAXIMIZING LIFETIME OF SENSOR SURVEILLANCE SYSTEMS 339
This process is repeated until all elements in are de-
termined. The details of the algorithm are given below.
FillMatrix Algorithm
Input: a workload matrix .
Output: a ﬁlled matrix .
Begin
, for to ;
, for to ;
; ;
while && do
if then
// determine elements in row .
;
, for to ;
// set the rest of row to 0.
;
;
else if
//determine elements in column .
;
, for to ;
// set the rest of column to 0.
;
;
else
//determine elements in both row and column .
;
, for to ;
, for to ;
; ;
endwhile
Output ;
End
The following theorem claims the correctness of the FillMa-
trix Algorithm.
Theorem 3: For a given workload matrix , the FillMa-
trix Algorithm can compute the ﬁlled matrix , such that
the sum of each column and the sum of each row have the prop-
erties deﬁned in (7) and (10).
Proof: At the beginning of the FillMatrix Algorithm, row
sums and column sums of the dummy matrix are initialized,
and then the dummy matrix is worked out step by step to sat-
isfy conditions (12) and (13). So we can prove a general case:
given row sums and column sums of a matrix ,
, , the proposed algorithm can
compute all elements that satisfy conditions (12) and (13).
We use the induction method to prove the theorem.
1) When , , according to the FillMatrix algo-
rithm, since , we have
. The conditions (12) and (13) are both met.
2) We assume when , , the proposed al-
gorithm can compute , such that the conditions (12)
and (13) are both met.
3) When , , according the algorithm, we ﬁrst
compare with , there are three cases.
a) If , then set , ,
and , . For
the row 1 and column 1 where have been deter-
mined, we have and
. So the conditions (12)
and (13) are both met in row 1 and column 1. The re-
maining undetermined elements , ,
, are in the matrix .
According to assumption 2), the remaining matrix
can be correctly worked out.
b) If , then set , ,
and . For the
row 1 where have been determined, we have
, condition (12) is
met. For the column 1 which is updated, we have
, it does not violate condition
(13). The remaining undetermined elements ,
, , are in the matrix
. We continue run the algorithm to compute
the remaining elements in that satisﬁes
the conditions (12) and (13). Note that monoto-
nously decreases after each round of assignment and
. There must exist
in round , we set , ,
and . Then the
remaining matrix is . According to
assumption 2), the remaining matrix
can be correctly worked out.
c) If , similar to b), we can prove this case.
4) The proof of cases , and ,
are similar to 3).
Combining 1), 2), and 3) with 4), the proposed algorithm can
correctly compute all elements in the matrix , such that
the conditions (12) and (13) are both met. Theorem proved.
Theorem 4: The time complexity of FillMatrix Algorithm is
.
Proof: In FillMatrixAlgorithm, each time we compare
with and determine the dummy elements in a row (or a
column), without backtracking. Plus the initialization of and
, all dummy elements in the matrix can be determined in
time. Theorem 4 is proved.
LIU et al.: MAXIMIZING LIFETIME OF SENSOR SURVEILLANCE SYSTEMS 341
TABLE I
THE INITIAL ENERGY RESERVES OF SIX SENSORS
Fig. 2. An example with six sensors and three targets.
with the mean at 50, as shown in Table I. To simulate the energy
consumed on different tasks, we set , . These
values are in proportional to the actual power consumption for
transmitting and receiving data, respectively, as pointed out in
[29]. Experiments in [29] further showed that energy cost of
sensing data, such as monitoring temperature and humidity, is
comparable to the energy cost of receiving data.We set
and the sensing data rate . The signal decline factor á is
set to 2.
We follow the three steps in our method to ﬁnd sensor surveil-
lance trees.
First, we use the linear programming, described in
Section IV-A, to compute the maximal lifetime , work-
load matrix and data ﬂows (see Table II) that achieve :
TABLE II
THE DATA FLOWS AMONG SIX SENSORS AND THE BS
In the workload matrix, we can see target 1 is watched by
sensors 2 and 6 for 17.2300, 11.4672, respectively. The total
time for target 1 to be watched is 28.6972, which is the lifetime
of the surveillance system.
Second, we run the FillMatrix algorithm to append a dummy
matrix to the workloadmatrix tomake it a squarematrix ,
where the sum of each column and the sum of each row are all
equal to , as shown in the equation at the bottom of the page.
Third, we run the DecomposeMatrix-nn algorithm to decom-
pose into three schedule matrices , , and (i.e., the
decomposition terminates at round 3), such that
By removing the dummy columns of the schedule matrices,
we have
LIU et al.: MAXIMIZING LIFETIME OF SENSOR SURVEILLANCE SYSTEMS 343
(a)
(b)
Fig. 4. (a) versus when . (b) versus when .
sensors properly to achieve the maximal lifetime. That is why
the performance gap between the two methods becomes more
signiﬁcant as the increase of the surveillance range (themaximal
transmission range). Furthermore, we can see that the increase
of surveillance range is more effective to extending the system
lifetime than the increase of the maximal transmission range.
This is because the surveillance range is usually much smaller
than the communication range of sensors. It is always the bottle-
neck of the maximization of system lifetime, and some targets
could not be watched by enough sensors often results in quick
die of surveillance systems.
Fig.5(c)showsthelifetimeversusthenumberofsensorsplaced
in the same region. The number of sensors varies from100 to 400
and the number of targets is ﬁxed at 50. This simulation shows
how the lifetime is affected by the density of sensors. Fig. 5(c)
exhibits the similar trend as in Fig. 5(a) and (b). As more sensors
deployed in the same region, thedensitybecomeshigher.A target
can be watched by more sensors and there is a higher chance for
a target to be in the watching range of multiple sensors. At the
same time, a sensor can reach more neighbors and can choose
more energy-efﬁcient routes to forward data. Thus, our optimal
algorithm takesmore advantages by optimizing the schedule and
the performance gain becomes more signiﬁcant than the greedy
method when the density of sensors becomes higher.
(a)
(b)
(c)
Fig. 5. (a) Lifetime versus surveillance range. (b) Lifetime versus the maximal
transmission range. (c) Lifetime versus when .
From Figs. 4(a)–5(c), we can make the following conclu-
sions:
1) The actual number of steps for decomposing the workload
matrix is linear to the size of system in real runs.
2) Our optimal algorithm has signiﬁcantly better performance
in the situation where sensors have larger surveillance and
communication range, or when sensors are densely de-
ployed.
LIU et al.: MAXIMIZING LIFETIME OF SENSOR SURVEILLANCE SYSTEMS 345
Hai Liu received the B.Sc. and M.Sc. degrees in ap-
plied mathematics from the South China University
of Technology in 1999 and 2002, respectively, and
the Ph.D. degree in computer science from the City
University of Hong Kong in 2006.
He is currently a Research Fellow in the Depart-
ment of Computer Science, City University of Hong
Kong. His research interests include distributed sys-
tems, wireless networks, and mobile computing.
Xiaohua Jia received the B.S. and M.Eng. degrees
from the University of Science and Technology of
China, Hefei, China, in 1984 and 1987, respectively,
and the D.Sc. degree in information science from the
University of Tokyo, Tokyo, Japan, in 1991.
He is currently a Professor of computer science at
the City University of Hong Kong and Cheung Kong
Professor with the School of Computing,WuhanUni-
versity, China.
Prof. Jia is an editor of IEEE TRANSACTIONS ON
PARALLEL AND DISTRIBUTED SYSTEMS, The Journal
of Supercomputing, Journal of the World Wide Web, and Journal of Combina-
torial Optimization, among others. He has been a general chair, PC chair, PC
member, and OC member of many international conferences.
Peng-Jun Wan received the B.S. degree from Ts-
inghua University, China, in 1990, the M.S. degree
from the Chinese Academy of Science, Beijing, in
1993, and the Ph.D. degree from the University of
Minnesota, Minneapolis, in 1997.
He is currently an Associate Professor of com-
puter science at the Illinois Institute of Technology,
Chicago. His research interests include wireless
networks and optical networks.
Chih-Wei Yi received the B.S. and M.S. degrees
from National Taiwan University, Taipei, Taiwan,
R.O.C., and the Ph.D. degree from the Illinois
Institute of Technology, Chicago.
He is currently an Assistant Professor of computer
science at National Chiao Tung University, Hsinchu,
Taiwan, R.O.C. His research focuses on wireless ad
hoc and sensor networks.
S. Kami Makki received the Bachelors and Masters
degrees in engineering from the University of Tehran,
Iran, the M.S. degree in computer science and en-
gineering from the University of New South Wales,
Australia, and the Ph.D. degree in computer science
from the University of Queensland, Australia.
Before joining the University of Toledo, Toledo,
OH, he held a number of academic positions and re-
search appointments, and also worked in public and
private industries for a number of years. Currently,
he is the Director of the Advanced Systems Lab, and
Assistant Professor in the Department of Electrical Engineering and Computer
Science at the University of Toledo. His research areas include distributed sys-
tems, web and multimedia databases, intelligent web applications, middleware
integration and electronic services, and mobile and wireless network and secu-
rity.
Niki Pissinou received the B.S.I.S.E. degree in in-
dustrial and systems engineering fromTheOhio State
University, Columbus, the M.Sc. degree in computer
science from the University of California at River-
side, and the Ph.D. degree in computer science from
the University of Southern California, Los Angeles.
She is currently a tenured Professor and the
Director of the Telecommunication and Information
Technology Institute at Florida International Uni-
versity, Miami. She is active in the ﬁelds computer
networks, information technology, and distributed
systems. She has published over 100 refereed publications and has received
best paper awards. She has also co-edited eight volumes and is the author of an
upcoming book on wireless internet computing.
Dr. Pissinou has served as a steering committee and general chair and pro-
gram committee member of over 100 program and organizational committees
of IEEE and ACM sponsored technical conferences. She has been the editor
of eight journals including IEEE TRANSACTIONS ON KNOWLEDGE AND DATA
ENGINEERING and guest editor of seven journals. She has received eight achieve-
ments awards and been an invited speaker and keynote speaker of conferences.
She has received extensive funding for her research work from such agencies as
NSF, NASA, DARPA, and ARO, including two recent NSF awards on wireless
networks.
On the Longest Edge of Gabriel Graphs
in Wireless Ad Hoc Networks
Peng-Jun Wan and Chih-Wei Yi, Member, IEEE
Abstract—In wireless ad hoc networks, without fixed infrastructures, virtual backbones are constructed and maintained to efficiently
operate such networks. The Gabriel graph (GG) is one of widely used geometric structures for topology control in wireless ad hoc
networks. If all nodes have the same maximal transmission radii, the length of the longest edge of the GG is the critical transmission
radius such that the GG can be constructed by localized and distributed algorithms using only 1-hop neighbor information. In this
paper, we assume a wireless ad hoc network is represented by a Poisson point process with mean n on a unit-area disk, and nodes
have the same maximal transmission radii. We give three asymptotic results on the length of the longest edge of the GG. First, we
show that the ratio of the length of the longest edge to
ﬃﬃﬃﬃﬃ
lnn
n
q
is asymptotically almost surely equal to 2. Next, we show that for any ,
the expected number of GG edges whose lengths are at least 2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþ
n
q
is asymptotically equal to 2e. This implies that !1 is an
asymptotically almost sure sufficient condition for constructing the GG by 1-hop information. Last, we prove that the number of long
edges is asymptotically Poisson with mean 2e. Therefore, the probability of the event that the length of the longest edge is less
than 2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþ
n
q
is asymptotically equal to exp 2e .
Index Terms—Wireless ad hoc network, Gabriel graph, asymptotic probability distribution, the longest edge, poisson point process,
topology control.
Ç
1 INTRODUCTION
A wireless ad hoc network is a collection of wirelessdevices (transceivers) distributed over a geographic
region. Each node is equipped with an omnidirectional
antenna and has limited transmission power. A communica-
tion session is established either through a single-hop radio
transmission if the communication parties are close enough,
or through relaying by intermediate devices otherwise. Since
they have no need for a fixed infrastructure, wireless ad hoc
networks can be flexibly deployed at low cost for varying
missions such as decision making in the battlefield, emer-
gency disaster relief, and environmental monitoring.
Inwireless adhocnetworks, each node is associatedwith a
maximal transmission radius. The network topology of a
wireless ad hoc network is a graph in which two nodes have
an edge between them if they are within each other’s
transmission range. A spanner is a subset of the network
topology in which the total cost, e.g., distance or energy
consumption, between any pair of nodes is only a constant
fact larger than in the original network topology. Hence,
spanners are good candidates of virtual backbones. The
topics about how to construct and maintain spanners are
called topology control. Geometric structures, including
Euclideanminimal spanning trees (EMST), relative neighbor
graphs (RNG), Gabriel graphs (GG), Delauney triangulations
(DT), and Yao’s graphs (YG), are widely used ingredients for
constructing spanners [1], [2], [3]. A topology control
algorithm is localized if each node only needs to collect
information from few hops neighbors.
In this paper, we study the critical transmission radius
for Gabriel graphs. In the GG, two nodes have an edge
between them if and only if there is no other node on the
disk using the segment of these two nodes as its diameter.
Assume all nodes have the same maximal transmission
radius r. Then, the induced network topology is exactly the
r-disk graph over the set of nodes V , denoted by GrðV Þ. To
construct the GG only by 1-hop neighbor information, the
transmission radius r should be large enough such that the
GG is a subgraph of the r-disk graph. Thus, the transmission
radius should be not less than the length of the longest edge
of the GG. On the other hand, for each node, if it can gather
the information of nodes that are not farther than its farthest
neighbor in the GG, it can decide all GG edges incident to it.
Therefore, the length of the longest edge of the GG is called
the critical transmission radius for GGs.
For modeling radio networks, Gilbert [4] proposed a
random geometric graph model in which devices are
represented by an infinite random point process over the
entire plane and twodevices are joined by an edge if and only
if their distance is at most r. For modeling wireless ad hoc
networks which consist of finite radio nodes in a bounded
geographic region, a bounded (or finite) variant of the
Gilbert’s model has been used by Gupta and Kumar [5] and
others. In this variant, instead of an infinite random point
process, the ad hoc device is typically presented by a uniform
point process or Poisson point process over a disk or a square
by proper scaling. The largest nearest-neighbor link problem
IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS, VOL. 18, NO. 1, JANUARY 2007 111
. P.-J. Wan is with the Department of Computer Science, City University of
Hong Kong, 83 Tat Chee Avenue, Kowloon, Hong Kong.
E-mail: pwan@cs.cityu.edu.hk
. C.-W. Yi is with the Department of Computer Science, National Chiao
Tung University, 1001 Ta Hsueh Road, Hsinchu City, Hsinchu 300,
Taiwan. E-mail: yi@cs.nctu.edu.tw.
Manuscript received 15 Feb. 2005; revised 1 Sept. 2005; accepted 2 Sept. 2005;
published online 28 Nov. 2006.
Recommended for acceptance by I. Stojmenovic.
For information on obtaining reprints of this article, please send e-mail to:
tpds@computer.org, and reference IEEECS Log Number TPDS-0100-0205.
1045-9219/07/$20.00  2007 IEEE Published by the IEEE Computer Society
denote the radius of D , and o denote the origin. Without
loss of generality, we assume D is centered at the origin. For
a given transmission radius r, the unit-area disk D is
partitioned into D rð0Þ, D rð1Þ, and D rð2Þ as shown in Fig. 1:
D rð0Þ is the disk of radius 1ﬃﬃp  r centered at the origin,
D rð1Þ is the annulus of radii 1ﬃﬃp  r and
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
1
 r2
q
centered at
the origin, and D rð2Þ is the annulus of radii
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
1
 r2
q
and 1ﬃﬃ

p
centered at the origin. Then,
jD rð0Þj ¼ ð1
ﬃﬃﬃ

p
rÞ2; jD rð1Þj ¼ 2r 1ﬃﬃﬃ

p  r
 
;
and jD rð2Þj ¼ r2:
If R is a positive number, for any finite set of nodes
V ¼ fx1;    ; xkg, we use GRðx1;    ; xkÞ or GRðV Þ to denote
the R-disk graph over fx1;    ; xkg in which there is an edge
between two nodes if and only if their Euclidean distance is
at most R. For any positive integers k andmwith 1  m  k
and any positive number R, let CkmðRÞ denote the set of
ðx1;    ; xkÞ 2 D k satisfying that G2Rðx1;    ; xkÞ has exactly
m connected components. For any two points u and v, let
Duv denote the disk with the segment uv as a diameter, i.e.,
Duv ¼ B uþv2 ; kuvk2
 
. We have
jDuvj ¼ 1
4
ku vk2:
For any r ¼ ðr1;    ; rkÞ 2 ð0; R0Þk and x ¼ ðx1;    ; xkÞ 2
D k, Bðx1; r1Þ;    ; Bðxk; rkÞ are called feasible if
kxi  xjk 
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
r2i  r2j
			 			
r
for any i 6¼ j and kxi  ok 
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
R20  r2i
q
for any i. We remark
that kxi  ok 
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
R20  r2i
q
if and only if xi 2 D rið0Þ [D rið1Þ,
and kxi  xjk 
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
jr2i  r2j j
q
if and only if both disks Bðxi; riÞ
and Bðxj; rjÞ do not contain each other’s diameter. Let 1rx be
an indicator such that 1rx ¼ 1 if Bðx1; r1Þ;    ; Bðxk; rkÞ are
feasible, and 1rx ¼ 0 otherwise. In what follows, we only
consider feasible disk sets. We use rðxÞ to denote the area
of
Sk
i¼1Bðxi; riÞ \D , and sometimes by slightly abusing the
notation, to denote the union region itself. If k ¼ 1, for
x 2 D rð0Þ, rðxÞ ¼ r2 and, for x 2 D rð1Þ, rðxÞ  12r2.
Furthermore, the following lemma proved in [10] gives a
tighter lower bound for rðxÞ.
Lemma 4. For any x 2 D rð1Þ,
rðxÞ  1
2
r2 þ 1ﬃﬃﬃ

p  xk k
 
r:
The next lemma gives a lower bound for the area of the
r-neighborhood of more than one nodes.
Lemma 5. Let R  1100R0, c ¼ 0:03, x ¼ ðx1;    ; xkÞ 2 D k, and
r ¼ ðr1;    ; rkÞ 2 12R;R

 k
. Assume x1 has the largest norm
among x1;    ; xk, and kxi  xjk  2R if and only if
ji jj  1. If 1rx ¼ 1, then
rðxÞ  r1ðx1Þ þ cR
Xk1
I¼1
kxIþ1  xik:
The proof of Lemma 5 is given in the Appendix.
Corollary 6. Assume R  1100R0 and c ¼ 0:03. If x ¼ ðx1;    ;
xkÞ 2 Ck1ðRÞ, r ¼ ðr1;    ; rkÞ 2 12R;R

 k
, 1rx ¼ 1, and x1 has
the largest norm among x1;    ; xk, then
rðxÞ  r1ðx1Þ þ cR max
2ik
xi  x1k k:
Proof. Without loss of generality, we assume that kxk  x1k
achieves max
2ik
kxi  x1k. Let P be a min-hop path between
x1 and xk in G2Rðx1; x2;    ; xkÞ and t be the total length of
P . Then, every pair of nodes in P that are not adjacent
nodes in P are separated by a distance of more than R.
Thus, by applying Lemma 5 to the nodes in P , we obtain
ðfrijxi2PgÞðfxi j xi 2 PgÞ  r1ðx1Þ þ cRt:
Since rðxÞ  ðfrijxi2PgÞðfxijxi 2 PgÞ and t  kxk  x1k,
the corollary follows. tu
For x 2 D and r 2 IR, let ðx; rÞ denote the (total) central
angle corresponding to the portion of @Bðx; rÞ in which, if a
diameter of Bðx; rÞ has endpoints, it is fully contained in D .
For example, in Fig. 2, x 2 D rð1Þ, b and c are intersection
points of @Bðx; rÞ and @D , and segment ac is a diameter of
Bðx; rÞ. Then, ðx; rÞ ¼ 2ﬀaxb. If x 2 D rð1Þ, we use tðxÞ to
denote the distance between x and @D . We have
WAN AND YI: ON THE LONGEST EDGE OF GABRIEL GRAPHS IN WIRELESS AD HOC NETWORKS 113
Fig. 1. The partition of the unit-area disk D .
Fig. 2. If x 2 D rð1Þ, then ðx; rÞ ¼ 2ﬀaxb.
Proof. To prove this, we need to show that, for any k,
Pr½Y ¼ k ! 
k
k!
e:
For any i  j  1, let
S
ðjÞ
i ¼
X
fi1;;ijg
f1;;mðnÞg
Pr½Bi1 ^    ^Bij j mðnÞ ¼ i:
For convenience, let Sð0Þ ¼ 1 and Sð0Þi ¼ 1. In addition,
note that, for any j  1,
E½SðjÞ ¼
X1
i¼j
S
ðjÞ
i Pr½mðnÞ ¼ i:
According to the inclusion-exclusion principle, we have
Pr½Y ¼ 0 ¼ 1 Sð1Þ þ Sð2Þ    
¼
X1
i¼0
Xi
j¼0
ð1ÞjSðjÞi
 !
Pr½mðnÞ ¼ i
¼
X1
j¼0
ð1Þj
X1
i¼j
S
ðjÞ
i Pr½mðnÞ ¼ i
 ! !
¼
X1
j¼0
ð1ÞjE½SðjÞ:
In the general form, we have
Pr½Y ¼ k ¼ k
k
 
SðkÞ  kþ 1
k
 
Sðkþ1Þ þ   
¼
X1
i¼k
Xi
j¼k
ð1Þjk j
j k
 
S
ðjÞ
i
 !
Pr½mðnÞ ¼ i
¼
X1
j¼k
ð1Þjk j
j k
  X1
i¼j
S
ðjÞ
i Pr½mðnÞ ¼ i
 ! !
¼
X1
j¼k
ð1Þjk j
j k
 
E½SðjÞ:
Then, following the proof outline given in [13], Chapter 8,
the theorem can be proved. tu
Here, we remark that Theorem 10, in which the number
of events is a random variables is an extension to the
traditional Brun’s sieve described in [13] which is an
implication of the Bonferroni inequalities.
3.4 Integral Preliminaries
First, we introduce a technique to obtain the Jacobian
determinant in the change of variables. Assume a tree
topology is fixed over x1; x2;    ; xk 2 IR2. Without loss of
generality, we may assume xk1; xkð Þ is one of edges. Let
zk1 ¼ 12 ðxk1 þ xkÞ, r ¼ 12 kxk  xk1k, and  be the slope of
xk1xk. For 1  i  k 2, we use pðxiÞ to denote xi’s parent
in the tree rooted at xk, and let zi ¼ 12 ðxi þ pðxiÞÞ. Then,
@ðx1;    ; xk1; xkÞ
@ðz1;    ; zk1; r; Þ
				
				 ¼ @ðx1 þ pðx1Þ;    ; xk1 þ pðxk1Þ; xkÞ@ðz1;    ; zk1; r; Þ
				
				
¼ 4k1
@ x1þpðx1Þ2 ;    ; xk1þpðxk1Þ2 ; xk
 
@ðz1;    ; zk1; r; Þ
						
						
¼ 4k1 @ðz1;    ; zk1; xk  zk1Þ
@ðz1;    ; zk1; r; Þ
				
				
¼ 4k1
I2    0 0
..
. . .
. ..
. ..
.
0    I2 0
0    0 cos  r sin 
sin  r cos 
												
												
¼ 4k1r:
Now, we give several lemmas about the limits of integrals,
but leave their proofs in the Appendix.
Lemma 11. Let r ¼ 2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþ
n
q
for some constant , and either
Rn¼3
ﬃﬃﬃﬃﬃ
lnn
n
q
or Rn¼2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþn
n
q
with n ¼ oðlnnÞ and n !1.
Then,
n2
2
Z Rn
2
r¼r2
Z
z2D
enrðzÞ4rðz; rÞdzdr  2e:
In the remainder of this section, we always assume r ¼
2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþ
n
q
for some constant , and Rn ¼ 2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþn
n
q
with n ¼
oðlnnÞ and n !1.
Lemma 12. For any fixed integer k  2,
n2
2
 kZ
r2½r2 ;Rn2 k
Z
z2Ck1ðRn2 Þ
1rze
nrðzÞ
Yk
i¼1
4riðzi; riÞdzidri ¼ o ð1Þ:
Lemma 13. For any fixed integers 2  m < k,
n2
2
 kZ
r2 r2 ;Rn2½ k
Z
z2CkmðRn2 Þ
1rze
nrðzÞ
Yk
i¼1
4riðzi; riÞdzidri
¼ o ð1Þ:
Lemma 14. For any fixed integer k  2,
n2
2
 kZ
r2 r2 ;Rn2½ k
Z
z2CkkðRn2 Þ
enrðzÞ
Yk
i¼1
4riðzi; riÞdzidri
 ð2eÞk:
Lemma 15. For any constant m  3 and m2  t  i  1, let Sij
denote the set of ðz1; z2;    ; zmtÞ 2 CðmtÞ1ðRn2 Þ satisfying
that zi is the one with largest norm and zj is the one with
smallest norm among z1;    ; zk. Then,
WAN AND YI: ON THE LONGEST EDGE OF GABRIEL GRAPHS IN WIRELESS AD HOC NETWORKS 115
and F 03ðfX01; X02; X03; X04gÞ be the event that
h3ðfX01; X02; X03; X04g;PnÞ ¼ 1:
According to the Palm theory (Theorem 9), we haveX
fX0
1
;X0
2
g
Pn
Pr½F 01ðfX01; X02gÞ
¼ E
X
fX0
1
;X0
2
g
Pn
h1ðfX01; X02g;PnÞ
2
4
3
5
¼ n
2
2!
E½h1ðfX1; X2g; fX1; X2g [ PnÞ
¼ n
2
2
Pr½F1;
ð3Þ
X
fX0
1
;X0
2
;X0
3
g
Pn
Pr½F 02ðfX01; X02; X03gÞ
¼ E
X
fX0
1
;X0
2
;X0
3
g
Pn
h2ðfX01; X02; X03g;PnÞ
2
4
3
5
¼ n
3
3!
E½h2ðfX1; X2; X3g; fX1; X2; X3g [ PnÞ
¼ 3n
3
3!
Pr½F2 ¼ n
3
2
Pr½F2;
ð4Þ
and
X
fX0
1
;X0
2
;X0
3
;X0
4
g
Pn
Pr½F 03ðfX01; X02; X03; X04gÞ
¼ E
X
fX01;X02;X03;X04g
Pn
h3ðfX01; X02; X03; X04g;PnÞ
2
4
3
5
¼ n
3
3!
E½h3ðfX1; X2; X3; X4g; fX1; X2; X3; X4g [ PnÞ
¼ 3n
4
4!
Pr½F2 ¼ n
4
8
Pr½F3:
ð5Þ
Applying Boole’s inequalities and (3), (4), and (5), we have
Pr½E1 
X
fX0
1
;X0
2
g
Pn
Pr½F 01ðfX01; X02gÞ

X
fX0
1
;X0
2
;X0
3
g
Pn
Pr½F 02ðfX01; X02; X03gÞ

X
fX0
1
;X0
2
;X0
3
;X0
4
g
Pn
Pr½F 03ðfX01; X02; X03; X04gÞ
¼ n
2
2
Pr½F1  n
3
2
Pr½F2  n
4
8
Pr½F3:
Hence, our claim is true.
In the next, we derive the probabilities of F1, F2, and F3.
Let S1 denote the set
ðx1; x2Þj 1
2
ðx1 þ x2Þ 2 A;R1  kx1  x2k  R2
 
:
We have
Pr½F1 ¼
Z Z
S1
Pr½F1 j X1 ¼ x1; X2 ¼ x2dx1dx2
¼
Z Z
S1
en Dx1x2j jdx1dx2
¼
Z Z
S1
en
1
2kx1x2kð Þ2dx1dx2:
Let z ¼ x1þx22 and r ¼ 12 kx1  x2k. Then,
Pr½F1 ¼
Z
z2A
Z R2
2
r¼R12
enr
2
8rdrdz ¼ 4
Z
z2A
Z R2
2
r¼R12
enr
2
dðr2Þdz
¼  4
n
enr
2
			R22
r¼R12
 !
jAj ¼ 1
n2
n
1
4  n24
 
lnn:
ð6Þ
Let S2 denote the set
ðx1; x2; x3Þ
					
x1þx2
2 2 A;R1  kx1  x2k  R2;x1; x2 =2 Dx1x3 ;
x1þx3
2 2 A;R1  kx1  x3k  R2;x1; x3 =2 Dx1x2
8<
:
9=
;:
Applying Lemma 5, if ðx1; x2; x3Þ 2 S2, we have
Pr ½F2 j X1 ¼ x1; X2 ¼ x2; X3 ¼ x3  en Dx1x2[Dx1x3j j
 en  12kx1x2kð Þ
2þcR2kx1þx22 
x1þx3
2 k
 
:
Therefore,
Pr½F2¼
Z Z Z
S2
Pr½F2 j X1¼x1; X2 ¼ x2; X3 ¼ x3dx1dx2dx3

Z Z Z
S2
en 
1
2kx1x2kð Þ2þcR2 x1þx22 x1þx32k k
 
dx1dx2dx3:
Let z1 ¼ x1þx22 , r1 ¼ 12 kx1  x2k, z2 ¼ x1þx32 , and 	 ¼ kz1  z2k.
Then,
Pr½F2  16
Z
z12A
Z R2
2
r1¼R12
Z
z22A
en r
2
1þcR2kz1z2kð Þ2r1dr1dz1dz2
 16
Z
z12A
Z R2
2
r1¼R12
enr
2
12r1dr1dz1
Z
z22A
ecnR2kz1z2kdz2
 16
Z
z12A
Z R2
2
r1¼R12
enr
2
1d r21
 
dz1
Z 1
	¼0
ecnR2	2	d	
¼  16
n
enr
2
					
R2
2
r¼R12
0
@
1
AjAj  2ðcnR2Þ2
¼ 8
c2 nR22
 
n3
n
1
4  n24
 
lnn:
ð7Þ
Let S3 denote the set
ðx1; x2; x3; x4Þ
					
x1þx2
2 2 A;R1 kx1x2k R2;x1; x2 =2 Dx3x4 ;
x3þx4
2 2 A;R1 kx3x4k R2;x3; x4 =2 Dx1x2
( )
:
WAN AND YI: ON THE LONGEST EDGE OF GABRIEL GRAPHS IN WIRELESS AD HOC NETWORKS 117
Pr min
Pi2F
Yi ¼ 0
 
¼ 1 Pr min
Pi2F
Yi > 0
 
 0:
Put all together, and the lemma is proved. tu
Lemmas 16 and 17, respectively, give lower and upper
bounds for the length of the longest Gabriel edge. Hence,
Theorem 1 is now an immediate consequence of Lemmas 16
and 17.
5 EXPECTED NUMBER OF LONG EDGES
In the previous section, we proved that the ratio of the
length of the longest Gabriel edge to
ﬃﬃﬃﬃﬃ
lnn
n
q
is a.a.s. equal to 2.
In this section, we are going to prove Theorem 2, which
gives the expectation of the number of long Gabriel edges.
Proof of Theorem 2. Assume Y and V are point sets and
Y 
 V . Let hrðY ; V Þ denote a function such that hrðY ¼
fx1; x2g; V Þ ¼ 1 only if kx1  x2k  r and there is no
other node of V in the disk area Dx1x2 ; otherwise,
hrðY ; V Þ ¼ 0. Let X1 and X2 denote independent random
points with uniform distribution over D and indepen-
dent of Pn. According to the Palm theory,
E½NðGðPnÞ; rÞ ¼ E
X
X0
1
;X0
2f g
Pn
hr X
0
1; X
0
2
 
;Pn
 264
3
75
¼ n
2
2!
E hr X1; X2f g; X1; X2f g [ Pnð Þ½ :
Let F ðrÞ be the probability of the event that X1X2 is a
Gabriel edge and kX1 X2k  r. Then,
F ðrÞ ¼ E ½hrðfX1; X2 fX1; X2g[PnÞ
and F ðrÞ ¼ R R
x1 ;x22D
kx1x2kr
Pr XaX2 is a Gabriel edge
				X1 ¼ x1X2 ¼ x2
 
dx1dx2
¼
Z Z
x1 ;x22D
kx1x2kr
envkx1x2k=2ð
x1þx2
2 Þdx1dx2;
¼
Z 1
	¼r2
Z
z2D
env	ðzÞ4rðz; 	Þdzdr:
In the last equality, we let z ¼ x1þx22 and 	 ¼ 12 kx1  x2k.
According to Theorem 1,
F 2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþ 
n
r !
 F 2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþ 
n
r !
 F 3
ﬃﬃﬃﬃﬃﬃﬃﬃ
lnn
n
r !
¼
Z 3
2
ﬃﬃﬃﬃ
lnn
n
p
	¼
ﬃﬃﬃﬃﬃﬃﬃ
lnnþ
n
p Z
z2D
env	 zð Þ4r z; 	ð Þdzd	:
Hence, applying Lemma 11,
E N G Pnð Þ; 2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþ 
n
r !" #
¼ n
2
2!
F 2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþ 
n
r !
 2e:
ut
6 ASYMPTOTIC PROBABILITY DISTRIBUTION OF THE
MAXIMAL LENGTH
Let Rn ¼ 2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþn
n
q
for some sequence n such that n !1,
n ¼ oðlnnÞ, and mðnÞ ¼ nðn 1Þ=2. For applying Theorem
10 (Brun’s sieve) to prove Theorem 3, let Bi be the event that
the edge between the ith pair of nodes is a Gabriel edge
whose length is at least r but less than Rn for
1  i  mðPoðnÞÞ, and Y be the number of Bi that holds.
Then, Y is exactly the number of Gabriel edges whose
lengths are at least r ¼ 2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþ
n
q
but less than Rn. According
to Theorem 2, Y is a.a.s. equal to the number of Gabriel
edges whose length is at least r.
For any fixed integer k, let K1 denote the collection of set
fi1;    ; ikg 
 f1;    ;mðPoðnÞÞg such that ei1 ;    ; eik are not
incident to the same nodes, and K2 be the collection of set
fi1;    ; ikg 
 f1;    ;mðPoðnÞÞg such that ei1 ;    ; eik have
some common endpoints. Then,
SðkÞ ¼
X
fi1;;ikg
f1;;mðPoðnÞÞg
Pr½Bi1 ^    ^Bik 
¼
X
fi1;;ikg2K1
Pr½Bi1 ^    ^Bik 
þ
X
fi1;;ikg2K2
Pr½Bi1 ^    ^Bik :
In Lemma 18, we shall prove that the expectation of the sum
over fi1;    ; ikg 2 K1 are asymptotically equal to ð2eÞk. In
Lemma 19, we shall prove that the expectation of the sum
over fi1;    ; ikg 2 K2 are asymptotically equal to zero.
Therefore, Theorem 3 follows Lemmas 18 and 19 by
applying Theorem 10.
In the proofs of Lemmas 18 and 19, for applying the Palm
theory, let X l ¼ fX1;    ; Xlg denote a uniform l-points
process over D and independent of Pn, and Bi be the event
that the edge between the ith pair of nodes of X l is a Gabriel
edge over X l [ Pn whose length is at least r but less than
Rn for 1  i  mðlÞ. In addition, let ei denote the edge of
X2i1X2i (or x2i1x2i), zi ¼ x2i1þx2i2 be the midpoint of edge
ei, and ri ¼ k x2i1x2i2 k be the radius of Dx2i1x2i . keik is
shorthand for kx2i1  x2ik, i.e., the length of edge ei.
Lemma 18. For any fixed k,
E
X
fi1;;ikg2K1
Pr ½Bi1 ^    ^Bik 
2
4
3
5  ð2eÞk:
Proof. Applying the Palm theory and due to the identity
property, we have
E
X
fi1;;ikg2K1
Pr ½Bi1 ^    ^Bik 
2
4
3
5
¼ n
2k
ð2kÞ!
2k
2
 
2k2
2
     22 
k!
Pr ½B1 ^    ^Bk
 !
¼ 1
k!
n2
2
 k
Pr ½B1 ^    ^Bk:
WAN AND YI: ON THE LONGEST EDGE OF GABRIEL GRAPHS IN WIRELESS AD HOC NETWORKS 119
nm Pr ½E
  
X
1i 6¼jm1
nm
Z
x2Sij

Pr E

					 for 1  i  mXi ¼ xi
" #Ym
i¼1
dxi
 Oð1Þ
X
1i6¼jm1
nm
Z Rn
2
ri¼
r
2
Z
z2Sij
en ri ðziÞþcRnkzizjkð Þriðzi; riÞ
Ym1
k¼1
dzk
 !
dri
 0:
The last equality is given by Lemma 15. Now, we
consider t > 1. For Pr½E
 ^ fZ 2 CðmtÞ1ðRn2 Þg, we have
nm Pr E
 ^ Z 2 C mtð Þ1 Rn
2
   

X
1i6¼jmt
nm
Z
x2Sij

Pr ½E
 j Xi ¼ xi for 1  i  m
Ym
i¼1
dxi
 Oð1Þ
X
1i6¼jm1
nm
Z
r2 r2 ;Rn2½ t
Z
z2Sij
en ri ðziÞþcRnkzizjkð Þ
Yt
k¼1
rkðzk; rkÞdrk
 ! Ymt
k¼1
dzk
 !
 0:
The last equality is given by Lemma 15. For Pr½E
 ^
fZ 2 S$g, applying the same argument used in
Lemma 13, we have
nm Pr ðE
 ^ fZ 2 S$gÞ
 O ð1Þ
Yi
j¼1

nm$ðjÞ Pr E
$ðjÞ
   o ð1Þ:
Putting it all together, we have
nm Pr ½E
  ¼
Xt
i¼1
X
$2i
nm Pr ½E
 ^ fZ 2 S$g
 O ð1Þ
Xt
i¼1
X
$2i
Yi
j¼1
nm$ðjÞ Pr E
$ðjÞ
  !  o ð1Þ:
Therefore, the lemma is proved. tu
7 CONCLUSION
The Gabriel graph is one of the widely used geometric
structures in topology control of wireless ad hoc networks
and can be constructed by distributed and localized
algorithms. If all nodes have the same transmission radii,
the maximal length of Gabriel edges is the smallest transmis-
sion radius for constructing the GG by only 1-hop neighbor
information. In this paper, we assume a wireless ad hoc
network is represented by a Poisson point processwithmean
n on a unit-area disk. We first showed that the ratio of the
maximal length of Gabriel edges to
ﬃﬃﬃﬃﬃﬃ
lnn
n
q
is a.a.s. equal to 2.
Next,weproved that, for any constant , the expectednumber
of long Gabriel edges, whose lengths are at least 2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþ
n
q
, is
a.a.s. equal to 2e. This implies that, if  !1, it is a.a.s. that
themaximal length is less than 2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþ
n
q
. Last, we proved that
the number of long Gabriel edges is asymptotically Poisson
with mean 2e. Therefore, the probability of the event that
the maximal length of Gabriel edges is less than 2
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
lnnþ
n
q
is
asymptotically equal to expð2eÞ.
APPENDIX
First, we give two technical lemmas. Assume S and T are
two convex compact sets, and @S and @T intersect only at
two points x and y. Let u and v be two points to the different
side of xy such that uv and xy are perpendicular. T 0 is
obtained by shifting T away from S along uv by distance
4t. Then, we have the following lemma:
Lemma 20. If the boundaries ofS andT atx and y can be expressed
by continue functions along the axis parallel to uv, then
jS [ T 0j  jS [ T j ¼ ðkx yk þ o ð1ÞÞ 4t:
Proof. For convenience, assume v is on T . After shifting T
apart from S by 4t, x, y, and v on T are moved to x0, y0
and v0 respectively. See Fig. 5. Then, jS [ T 0j  jS [ T j is
equal to the area of the shaded region between xy and
x0y0. Since the boundaries can be expressed by continue
functions, the height of the shaded region can be
estimated by kx yk þ oð1Þ. The distance between xy
and x0y0 is equal to 4t. So, the area of the shaded region
can be expressed by ðkx yk þ oð1ÞÞ4t. tu
Lemma 21. Assume R is a constant, 12R  r2  r1  R, and
kx2  x1k 
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
r21  r22
p
. Let t ¼ kx2  x1k and fðtÞ ¼
jBðx2; r2Þ nBðx1; r1Þj. Then,
fðtÞ  0:16Rt:
Proof. Assume r1 is fixed. If t < r1 þ r2, let y1y2 be the
common chord of @Bðx1; r1Þ and @Bðx2; r2Þ. See Fig. 6a.
WAN AND YI: ON THE LONGEST EDGE OF GABRIEL GRAPHS IN WIRELESS AD HOC NETWORKS 121
Fig. 5. Two intersecting domains.
rðxÞ  r1ðx1Þ þ r3ðx3Þ  r1ðx1Þ þ
r23
3
 r1ðx1Þ þ

12
R2
 r1ðx1Þþ0:03R  4Rr1ðx1Þ þ 0:03R
X2
i¼1
kxiþ1  xik:
If k > 3, then by the induction hypothesis,
rðxÞ  ðr1;;rk2Þðx1;    ; xk2Þ þ rkðxkÞ
 r1ðx1Þ þ 0:03R
Xk3
i¼1
kxiþ1  xik þ r
2
k
3
 r1ðx1Þ þ 0:03R
Xk3
i¼1
kxiþ1  xik þ 0:03R  4R
 r1ðx1Þ þ 0:03R
Xk1
i¼1
kxiþ1  xik:
Therefore, the lemma is true by induction. tu
Proof of Lemma 11. First, we calculate the integration over
D rð0Þ.
n2
2
Z Rn
2
r¼r2
Z
z2D rð0Þ
enrðzÞ4rðz; rÞdzdr
¼ n
2
2
Z Rn
2
r¼r2
Z
z2D rð0Þ
enr
2
8rdzdr
 2n2
Z Rn
2
r¼r2
enr
2
2rdr ¼ 2n2
Z Rn
2
r¼r2
enr
2
d r2
 
¼ 2n2  1
n
enr
2
			Rn2
r¼r2
 
 2e:
Next, we calculate the integration over D rð1Þ. Let t
denote the distance from z to @D . According to Lemma 4
and (1), there exist constants c1 and c2 such that rðzÞ 
1
2r
2 þ c1rt and rðz; rÞ  c2t. Then,
n2
2
Z Rn
2
r¼r2
Z
z2D rð1Þ
enrðzÞ4rðz; rÞdzdr
 O ð1Þn2
Z Rn
2
r¼r2
Z r
t¼0
en
1
2r
2þc1rtð Þtdtdr
 O ð1Þn2e18nr2
Z Rn
2
r¼r2
Z r
t¼0
ec1nrttdtdr
¼ O ð1Þn2e12ðlnnþÞ
Z Rn
2
r¼r2
Z r
t¼0
ec1nrttdtdr
 O ð1Þn2e12ðlnnþÞ
Z Rn
2
r¼r2
Z 1
t¼0
ec1nrttdtdr
¼ O ð1Þn2e12ðlnnþÞ
Z Rn
2
r¼r2
ðnrÞ2drO ð1Þn2e12ðlnnþÞðnrÞ2Rn
 O ð1Þe12ðlnnþÞ
ﬃﬃﬃﬃﬃﬃﬃﬃ
lnn
n
r !1
¼ O ð1ÞðlnnÞ1=2 ¼ o ð1Þ:
Now, we calculate the integration over D rð2Þ. Since
ðz; rÞ ¼ 0 for any z 2 D rð2Þ,
n2
2
Z Rn
2
r¼r2
Z
z2D rð2Þ
enrðzÞ4rðz; rÞdzdr ¼ 0:
Therefore,
n2
2
Z Rn
2
r¼r2
Z
z2D
enrðzÞ4rðz; rÞdzdr  2e:
ut
Proof of Lemma 12. Let S denote the set of ðz1; z2;    ; zkÞ 2
Ck1ðRn2 Þ satisfying that z1 is the one with largest norm
among z1;    ; zk and z2 is the one with longest distance
from z1 among z2;    ; zk. Then,
n2
2
 kZ
r2 r2 ;Rn2½ k
Z
z2Ck1ðRn2 Þ
1rze
nrðzÞ
Yk
i¼1
4riðzi; riÞdzidri
 kðk 1Þ n
2
2
 kZ
r2 r2 ;Rn2½ k
Z
z2S
1rze
nrðzÞ
Yk
i¼1
4riðzi; riÞdzidri:
So, it suffices to prove
n2k
Z
r2½r2 ;Rn2 k
Z
z2S
1rze
nrðzÞ
Yk
i¼1
riðzi; riÞdzidri ¼ o ð1Þ:
Note that, for any ðz1; z2;    ; zkÞ 2 S, if 1rz ¼ 1,
r1ðz1Þ þ cRn kz2  z1k  rðzÞ  k
1
4
R2n
for some constant c by Corollary 6, otherwise, 1rz ¼ 0, and
zi 2 B ðz1; kz2  z1kÞ; for 3  i  k; z2 2 B ðz1; ðk 1ÞRnÞ:
Thus,
n2k
Z
r2 r2 ;Rn2½ k
Z
z2S
1rze
nrðzÞ
Yk
i¼1
riðzi; riÞdzidri
 n2k
Z
r2 r2 ;Rn2½ k
Z
z2S
enðr1 ðz1ÞþcRnkz2z1kÞ
Yk
i¼1
riðzi; riÞdzidri
 n2k
Z Rn
2
r1¼
r
2
Z
z12D
enr1 ðz1Þr1ðz1; r1Þdz1dr1
Z Rn
2
r2¼
r
2
2r2dr2
Z
z22Bðz1;ðk1ÞRnÞ
encRnkz2z1kdz2
Yk
i¼3
Z Rn
2
ri¼
r
2
2ridri
Z
zi2Bðz1;kz2z1kÞ
dzi
Oð1Þn2kðRnðRnrÞÞk1
Z Rn
2
r1¼
r
2
Z
z12D
enr1 ðz1Þr1ðz1; r1Þdz1dr1Z
z22Bðz1;ðk1ÞRnÞ
encRnkz2z1kkz2  z1k2ðk2Þdz2
 Oð1Þn2kðRnðRn  rÞk1
Z Rn
2
r1¼
r
2
Z
z12D
enr1 ðz1Þ
r1ðz1; r1Þdz1dr1
Z 1
0
encRn		2k3d	
¼ Oð1Þn
2kðRnðRn  rÞÞk1
ðnRnÞ2ðk1Þ
Z Rn
2
r1¼
r
2
Z
z12D
enr1 ðz1Þ
r1ðz1; r1Þdz1dr1
¼ Oð1Þ Rn  r
Rn
 k1
ð2eÞ ¼ oð1Þ:
WAN AND YI: ON THE LONGEST EDGE OF GABRIEL GRAPHS IN WIRELESS AD HOC NETWORKS 123
(In the following, we assume t  2.) Thus,
nm
Z
r2 r2 ;Rn2½ t
Z
z2Sij
en ri ðziÞþcRnkzizjkð Þ
Yt
k¼1
rkðzk; rkÞdrk
 !
Ymt
k¼1
dzk
 !
 Oð1Þnm
Z Rn
2
r1¼
r
2
Z
z12D
enr1 ðz1Þr1ðz1; r1Þdz1dr1
 !
Z
z22Bðz1;ðmt1ÞRnÞ
encRnkz2z1kdz2
 !
Yt
i¼2
Z Rn
2
ri¼
r
2
ridri
 ! Ymt
i¼3
Z
zi2Bðz1;kz2z1kÞ
dzi
 !
 Oð1ÞnmðRnðRn  rÞÞt1
Z Rn
2
r1¼
r
2
Z
z12D
enr1 ðz1Þ
r1ðz1; r1Þdz1dr1Z
z22Bðz1;ðk1ÞRnÞ
encRnkz2z1kkz2  z1k2ðmt2Þdz2
 Oð1Þnm RnðRn  rÞ
 t1Z Rn2
r1¼
r
2
Z
z12D
enr1 ðz1Þ
r1ðz1; r1Þdz1dr1
Z 1
0
encRn		2ðmtÞ3d	
¼ Oð1Þn
m RnðRn  rÞ
 t1
ðnRnÞ2ðmt1Þ
Z
r;R3½ 
Z
z12D
enr1 ðz1Þ
r1ðz1; r1Þdz1dr1
¼ Oð1Þ
nm2 RnðnÞðRnrÞn
 t1
nmt1 nR2n
 mt1
n2
Z Rn
2
r1¼
r
2
Z
z12D
enr1 ðz1Þr1ðz1; r1Þdz1dr1
 !
¼ Oð1Þ ðn  Þ
t1
lnmt1 n
 !
ðeÞ ¼ oð1Þ;
where the second to last equality follows from Lemma 11
and the last equality is based on n ¼ oðlnnÞ and
m t 1  1. tu
ACKNOWLEDGMENTS
The work of P.-J. Wang is supported in part by the US
National Science Foundation (NSF) under Grant 557904 and
CityU of Hong Kong under Grant 7200031. The work of C.-
W. Yi was supported in part by the NSC under Grant
NSC94-2218-E-009-030 and NSC95-2221-E-009-059-MY3, by
MOE ATU Program, and by Intel JRP, and was partially
done when the author visited the CityU of Hong Kong.
REFERENCES
[1] N. Li, J.C. Hou, and L. Sha, “Design and Analysis of a MST-Based
Distributed Topology Control Algorithm for Wireless Ad-Hoc
Networks,” Proc. 22nd Ann. Joint Conf. IEEE Computer and Comm.
Soc. (INFOCOM ’03), vol. 3, pp. 1702-1712, Apr. 2003.
[2] Y. Wang and X.-Y. Li, “Localized Construction of Bounded Degree
and Planar Spanner for Wireless Ad Hoc Networks,” Proc. 2003
Joint Workshop Foundations of Mobile Computing (DIALM-POMC
’03), pp. 59-68, Sept. 2003.
[3] J. Cartigny, F. Ingelrest, D. Simplot-Ryl, and I. Stojmenovic,
“Localized LMST and RNG Based Minimum-Energy Broadcast
Protocols in Ad Hoc Networks,” Ad Hoc Networks, vol. 3, no. 1,
pp. 1-16, 2004.
[4] E.N. Gilbert, “Random Plane Networks,” J. Soc. for Industrial and
Applied Math., vol. 9, no. 4, pp. 533-543, Dec. 1961.
[5] P. Gupta and P.R. Kumar, “Critical Power for Asymptotic
Connectivity in Wireless Networks,” Stochastic Analysis, Control,
Optimization and Applications: A Volume in Honor of W.H. Fleming,
W.M. McEneaney, G. Yin, and Q. Zhang, eds., pp. 547-566,
Birkhauser, Mar. 1998.
[6] H. Dette and N. Henze, “The Limit Distribution of the Largest
Nearest-Neighbour Link in the Unit d-Cube,” J. Applied Probability,
vol. 26, pp. 67-80, 1989.
[7] M.D. Penrose, “The Longest Edge of the Random Minimal
Spanning Tree,” The Annals of Applied Probability, vol. 7, no. 2,
pp. 340-361, 1997.
[8] G. Kozma, Z. Lotker, M. Sharir, and G. Stupp, “Geometrically
Aware Communication in Random Wireless Networks,” Proc.
23rd Ann. ACM Symp. Principles of Distributed Computing, pp. 310-
319, July 2004.
[9] P.-J. Wan and C.-W. Yi, “Asymptotic Critical Transmission Ranges
for Connectivity in Wireless Ad Hoc Networks With Bernoulli
Nodes,” Proc. IEEE Wireless Comm. and Networking Conf. (WCNC
’05), Mar. 2005.
[10] C.-W. Yi, P.-J. Wan, X.-Y. Li, and O. Frieder, “Asymptotic
Distribution of the Number of Isolated Nodes in Wireless Ad
Hoc Networks with Bernoulli Nodes,” Proc. IEEE Wireless Comm.
and Networking Conf. (WCNC ’03), Mar. 2003.
[11] M. Penrose, Random Geometric Graphs. Oxford Univ. Press, 2003.
[12] H. Zhang and J.C. Hou, “On the Critical Total Power for
Asymptotic k-Connectivity in Wireless Networks,” Proc. 24th
Ann. Joint Conf. IEEE Computer and Comm. Soc. (INFOCOM ’05),
Mar. 2005.
[13] N. Alon and J.H. Spencer, The Probabilistic Method, second ed.
Wiley, Mar. 2000.
Peng-Jun Wan received the PhD degree from
the University of Minnesota, the MS degree from
The Chinese Academy of Science, and the BS
degree from Tsinghua University. He is currently
an associate professor of computer science at
the Illinois Institute of Technology and the City
University of Hong Kong. His research interests
include wireless networks, optical networks, and
algorithm design and analysis.
Chih-Wei Yi received the PhD degree from the
Illinois Institute of Technology, and the MS and
BS degrees from National Taiwan University. He
is currently an assistant professor in the Depart-
ment of Computer Science, National Chiao Tung
University. His research focuses on wireless
ad hoc networks. He is a member of the IEEE.
. For more information on this or any other computing topic,
please visit our Digital Library at www.computer.org/publications/dlib.
WAN AND YI: ON THE LONGEST EDGE OF GABRIEL GRAPHS IN WIRELESS AD HOC NETWORKS 125
Non-Location-Based Mobile Sensor Relocation in a Hybrid Static-Mobile Wireless
Sensor Network
Fang-Jing Wu, Hsiu-Chi Hsu, and Yu-Chee Tseng
Department of Computer Science
National Chiao-Tung University
Hsin-Chu, Taiwan
{fangjing, hchsu, yctseng}@cs.nctu.edu.tw
Chi-Fu Huang
Department of Computer Science and
Information Engineering
National Chung Cheng University
Chia-Yi, Taiwan
cfhuang@csie.nctu.edu.tw
Abstract
An inherent concern for a wireless sensor network (WSN)
is the unbalanced energy consumption problem, where sen-
sors closer to the sink are more likely to exhaust their
energy faster than other nodes. To mitigate this problem,
this paper considers including some resource-rich mobile
nodes, called mobile data-pumps, to conduct data relaying
from static sensors to the sink. The network thus becomes
a two-tier network, with the original static sensors at the
low tier and data-pumps at both low and high tiers. We
propose a novel distributed navigation protocol that does
not rely on any location information of sensor nodes to
relocate data-pumps to meet both goals of connectivity and
load balance. The main idea is a concept called virtual
Voronoi cells, which can help data-pumps to locally balance
their loads using the underlaying low-tier topology and
thus signiﬁcantly balance energy consumption of sensors.
Simulation results are presented to verify the effectiveness
of our result.
Keywords: load balance, mobile computing, mobile sensor,
pervasive computing, wireless sensor network.
1. Introduction
The progress of embedded micro-sensing MEMS and
wireless technologies has made the success of wireless
sensor networks (WSNs). A WSN is usually composed of
a sink and a large number of sensors, each capable of
collecting environmental information. Research issues for
WSNs, such as deployment [15], [21], energy-efﬁcient MAC
[7], [11], and data aggregation [3], have been intensively
studied.
Sensor deployment is a critical issue for WSNs. A suc-
cessful deployment must guarantee both connectivity and
coverage. The former is to ensure that sensory data can be
delivered to the sink, and the latter is to ensure that the whole
sensing ﬁeld is fully monitored. Another big challenge is the
energy unbalanced problem, where it is known that sensors
closer to the sink are likely to consume their energy much
faster than other nodes; a lot of works have tried to address
this issue [1]–[4].
Recently, researchers have proposed to add resource-
richer mobile nodes to help relieve the energy unbalanced
problem. In [8], [9], [12], [13], [17], [18], [20], a set of
mobile collectors are used to move along pre-planned paths
to collect data from static sensors. The collection process
can be single-hop [9], [13], [20] or multi-hop [8], [12],
[17], [18]. While such approaches can balance the energy
consumption of sensors, moving these collectors may cause
long delays, thus harming real-time applications. To relieve
this limitation, [19] proposes a two-tier architecture, where
the low tier consists of typical sensor nodes and the high tier
consists of mobile data-pumps, called syphons, each with a
long-range and a short-range wireless interfaces. The short-
range ones can communicate with the low-tier network. The
goal is to design a range-free protocol to help these syphons
to move around to form a connected syphon tree rooted at
the sink by those long-range interfaces. The low-tier nodes
can ﬁrst relay their data to the nearest syphons and then the
syphon tree can quickly relay these data to the sink. In this
way, the energy requirement of low-tier nodes is relaxed.
In this work, we adopt the same two-tier architecture as
in [19]. However, we observe that the design of [19] does
not try to balance the loads of syphons (i.e., the numbers of
sensors served by syphons). Note that unbalanced loads of
syphons will also affect the energy consumption, and thus
the lifetime, of both high- and low-tier nodes. To resolve this
problem, we propose a novel range-free relocation protocol
based on a virtual Voronoi cell concept. We assume no loca-
tion information for syphons, and nor for low-tier sensors.
The only assumption is that the initial deployment of low-
tier sensors should be dense enough to form a connected
network with the sink. Initially, syphons may or may not
be connected with the sink. Figure 1(a) gives an example,
where the data of sensor s1 is relayed by m1 and m2, and
that of sensor s2 needs to go long way to m3 and then to
the sink. If we can properly relocate syphons as shown in
Figure 1(b), then s2 can quickly relay its data via syphons.
Relocating syphons needs to address both connectivity and
55
70
42
s1
68
data-pump
sensor
moving direction
1349,   D|)(| 1mC
7044
s2 m0
m1
m2
m3
m0
m1
m2
m3
(a) (b)
wireless link
114
Figure 2. An example of relocating data-pumps.
3.1. Balancing Mode for Attached Data-Pumps
The main idea is to enforce each attached data-pump mi
to move, based on local information, toward the ‘center’
of its current virtual Voronoi cell while keep attached.
By so doing, load balance can be achieved eventually.
Geometrically, F can be partitioned into multiple Voronoi
cells based on attached data-pumps’ locations. However,
since no location information is assumed, we will use the
connectivity information among S as a clue to navigate data-
pumps. For example, in Figure 2(a), m1 can detect that it is
not at the center of its current virtual Voronoi cell by forming
an intra-cell tree rooted at itself. Our scheme will force m1
to move toward the child with the largest subtree, i.e., s1.
After repeating this movement process several times, m1’s
subtrees will reach certain equilibrium. Concurrently, m2
and m3 will conduct the same process. More importantly,
this will repartition the virtual Voronoi cells. Figure 2(b)
shows an ideal situation after several rounds.
Our protocol is designed as an iterative process with
multiple rounds. Each round has four phases, during which
a data-pump may make a movement. Phase 1 is to partition
F into virtual Voronoi cells in a distributed manner. Phase
2 will decide each data-pump’s moving direction. Phase
3 will choose each data-pump’s parent to maintain the
connectivity in the high-tier network. The actual movement
and termination conditions are decided in phase 4. Phases
among data-pumps need to be synchronized (refer to Sec
3.3).
Phase 1: Virtual cell construction. In this phase, each
data-pump mi will compute its cell C(mi) by forming a
tree Ti rooted at itself. Each sensor sj will maintain two
variables: χ(sj) and h(sj) (hop count from mi to sj in Ti).
Initially, χ(sj) = NULL and h(sj) = ∞. To start with, mi
will broadcast a Cell(mi, h) message using its short-range
antenna with h = 1 (standing for hop count). When any sj
receives a Cell(mi, h) message, it will check the following
conditions: (i) χ(sj) = NULL and (ii) h < h(sj). If any
of the above conditions is true, sj will set χ(sj) = mi, set
h(sj) = h, and broadcast a Cell(mi, h+1) message. At the
end of Phase 1, each sensor will know its master data-pump.
Phase 2: Cell center estimation. In this phase, each
mi will try to identify the center sensor cn(mi) of its
cell C(mi). Initially, mi will assume itself as the center,
i.e., cn(mi) = mi, and broadcast a CENTER(cn(mi))
message around sensors in C(mi) to form a spanning tree
rooted at itself. Each sensor sj will calculate the depth and
the number of sensors of the subtree rooted at itself, denoted
by dj and nj , respectively. Then, each sensor sj can compute
a load index as follows:
εj = α · nj + (1− α) · dj ,
where 0 ≤ α ≤ 1 is a weight to reﬂect the importance of
our two metrics (i.e, the deviation among |C(mi)| and the
deviation among R(mi)). Then, mi will run the following
iterative process to update the center sensor cn(mi). The
main idea can be imagined that mi throws an agent which
is like a ball and will roll toward the center of C(mi) along
the sensors with higher load index. Speciﬁcally, in each
iteration, mi will try to update the center sensor cn(mi)
by the child of cn(mi) with the highest load index, denoted
by sc, if the following condition is satisﬁed: εcε′c ≥ 1, where
ε′c = α · (|C(mi)|−nc)degree(cn(mi))−1 + (1− α) · (dmax + h(sc,mi)) is
the estimation of the average load index for the remaining
subtrees rooted at cn(mi)’s children excluding the subtree
rooted at sc. Here, degree(cn(mi)) is the low-tier degree of
cn(mi) (in terms of short-range antenna degree), dmax is the
maximum depth of subtrees rooted at mi’s children in the
spanning tree except the subtree rooted at sc’s ancestor, and
h(sc,mi) is the short-range antenna hop count from sc to
mi along the spanning tree. Note that instead of reforming
the spanning tree, we use εcε′c to estimate if the loads between
the side of the subtree rooted at sc and the remaining side
in C(mi) is balancing after mi move to sc’s position. Once
mi updates cn(mi) = sc, it must memorize the history of
cn(mi) to help relocate itself along the sequence of sensors
in the history when moving. This completes one iteration.
This process is repeated until there is no descent of cn(mi)
can satisfy the above condition. Note that, this phase can be
repeated more times for reﬁning the center sensor cn(mi) of
this cell. Figure 2 gives an example, where |C(m1)| = 349,
and α = 1. Initially, m1 ﬁnds the subtree rooted at s1 with
highest load index ε1 = 114 and updates cn(mi) = s1,
because ε1ε′1 =
114
58.75 ≥ 1, where ε′1 = 349−1144 = 58.75.
Then, m1 repeatedly run this process until it ﬁnds ε2ε′2 < 1,
where ε2 = 70, and ε′2 =
349−70
2 = 139.5. Finally, m1 can
identify the center sensor cn(m1) is s1.
Phases 3: Connectivity maintenance between mobile
data-pumps. In this phase, each data-pump mi must choose
an attached data-pump to be its parent, denoted by P (mi)
for keeping attached. Speciﬁcally, mi must make sure
that it can always hear the periodical Attachment message
from P (mi) when moving. To achieve this goal, each
3.3. Synchronization Between Phases
We suggest two possible approaches to synchronize the
phases between data-pumps. The ﬁrst one is that the phases
switching is coordinated by the sink, while the second one
is that each data-pump will set a timer for each phase to
control the switching timing between phases.
For the ﬁrst type synchronization, upon the network is re-
quested to perform our protocol, the sink must ﬁrst broadcast
a Phase1-2 Start message via the high-tier network to in-
form attached data-pumps to construct cells and estimate the
centers of cells. When an attached data-pump mi receives
the Phase1-2 Start message, it will rebroadcast this message
via the high-tier network and then execute the phase 1 and
phase 2. After mi has ﬁnished phase1 and phase 2, it will
send a Phase1-2 End message to inform the sink. The sink
must collect Phase1-2 End messages from all attached data-
pumps and then broadcast a Phase3 Start message to inform
data-pumps to execute phase 3. It is similar to the above
procedures, the sink must wait until it knows that all data-
pumps have ﬁnished the current phase and then trigger the
next phase by broadcasting message in the high-tier network.
Also, when an unattached data-pump has became an attached
one, it must listen the synchronization messages from the
sink to conduct the balancing mode.
For the second type synchronization, each data-pump will
set a speciﬁed a timer for each phase. Upon the network is
requested to execute our protocol, each attached data-pump
mi will enter the phase 1 and start a timer Phases1 Timer.
After the Phases1 Timer expired, mi will enter the phase 2
and also wait a timer for the current phases until the timer
has expired. This process will be repeatedly phase by phase
until the protocol is terminated. On the other hand, when an
unattached data-pump mi becomes an attached one, it will
immediately send Synchronization Request message to the
neighboring data-pumps to query how long it should wait
for entering the balancing mode to start a new round. When
an attached data-pump receives a Synchronization Request
message, it will reply a Synchronization Reply message with
a time duration, based on the timers of the four phases
in the balancing mode. After mi receives reply message
from neighboring data-pumps, it will switch to the balancing
mode until the maximum execution rounds has been reached.
4. Simulation Results
We randomly deploy 20000 sensors and 75 data-pumps
in a disk-sharp ﬁeld with a radius of Rf . The short-range
antenna and the long-range antenna have transmission
distances rc = 60 m and Rc = 240 m, respectively (we
use WiFi and ZigBee as the reference here; the former
has a transmission range of ﬁve times the latter [10]). We
set the parameters both α (in phase 2) and β (in phase 3)
as 0.5. Our simulation results are all from the average of
100 runs. We compare our protocol against the SODaR
protocol proposed in [19] by the following two ways.
The ﬁrst one (denoted by ‘ours-only connecting mode’) is
that data-pumps only can perform the connecting mode to
achieve the same goal of the connectivity in the SODaR.
The second one (denoted by ‘ours’) is that data-pumps can
run two modes in our protocol to achieve the both goals of
connectivity and load balance. In SODaR, each unattached
data-pump mi must move along the circle composed of
sensors with the same sensor hop counts from the sink as
mi’s (in terms of short-range antenna hop count) to connect
an attached data-pump. In our simulations, we use three
metrics to evaluate the performance of ours and the SODaR
as follows.
1. The quantiﬁcation of the balance: we use the
fairness index [6] to measure the deviation of data-
pumps’ loads. Here, the fairness index is calculated by
f(|C(m1)|, |C(m2)|, . . . , |C(me)|) = (Σ
e
i=1|C(mi)|)2
e·Σei=1(|C(mi)|)2 ,
where 0 ≤ f(|C(m1)|, |C(m2)|, . . . , |C(me)|) ≤ 1. Note
that a protocol with the larger fairness index implies the less
deviation of data-pumps’ loads (i.e., it is more balancing).
2. The movement overhead: we calculate the average
moving distance of data-pumps in a protocol.
3. The communication overhead: we calculate the total
number of messages exchanged in a protocol.
First, we ﬁnd an adequate maximum execution round by
observing the improvement in balance under different num-
ber of execution rounds. Figure 3(a) shows the simulation
result, where the fairness index only is slightly improvement
after 10 rounds. Thus, we take the maximum execution
round of our protocol by 30 rounds in the following simula-
tions. Then, we investigate the impact of relocation protocols
on balance under different radius of deployment. Figure 3(b)
shows the result, where the fairness index is decreasing with
the increasing of Rf . This is because the number of data-
pumps is too less to span a large-scale high-tier network to
balance the loads of data-pumps when Rf is larger. Note
that our relocation protocol has prominent balance results
even if only the connecting mode is conducted. Then, we
focus on the goal of connectivity to compare the overheads
of relocation protocols under different Rf . Figure 3(c) shows
an interesting result on the movement overhead, where
SODaR only can successfully work under some deployment
cases (Rf is between 1000 and 2000) and results in higher
movement overhead. This is because it may fail that an
unattached data-pump in SODaR searches an attached data-
pumps within a limited area. Note that the SODaR results
in less movement overhead when Rf > 2000, because most
data-pumps can not relocate themselves due to the SODaR
fail. However, our connecting mode can always work out
ﬁne, and unattached data-pumps can quickly connect to the
sink with less moving distance. Finally, in Figure 3(d) shows
[2] R. Cristescu, B. Beferull-lozano, and M. Vetterli. On network
correlated data gathering. In Proc. IEEE INFOCOM, pages
2571–2582, 2004.
[3] K.-W. Fan, S. Liu, and P. Sinha. Structure-free data aggre-
gation in sensor networks. IEEE Trans. Mobile Computing,
6(8):929–942, 2007.
[4] K.-W. Fan, S. Liu, and P. Sinha. Dynamic forwarding over
tree-on-DAG for scalable data aggregation in sensor networks.
IEEE Trans. Mobile Computing, 6(10):1271–1284, 2008.
[5] N. Heo and P.K. Varshney. Energy-efﬁcient deployment of
intelligent mobile sensor networks. IEEE Trans. Systems,
Man, and Cybernetics–Part A, 35(1):78–92, 2005.
[6] R. K. Jain. The Art of Computer Systems Performance
Analysis: Techniques for Experimental Design, Measurement,
Simulation, and Modeling. John Wiley and Sons, New York,
1991.
[7] G. Lu, B. Krishnamachari, and C. S. Raghavendra. An adap-
tive energy-efﬁcient and low-latency MAC for data gathering
in wireless sensor networks. In Proc. IEEE Int’l Parallel and
Distributed Processing Symp., 2004.
[8] M. Ma and Y. Yang. SenCar: an energy-efﬁcient data gath-
ering mechanism for large-scale multihop sensor networks.
IEEE Trans. Parallel and Distributed Systems, 18(10):1476–
1488, 2007.
[9] M. Ma and Y. Yang. Data gathering in wireless sensor
networks with mobile collectors. Proc. IEEE Int’l Parallel
and Distributed Processing Symp., pages 1–9, 2008.
[10] T. Nolte, H. Hansson, and L. L. Bello. Wireless automotive
communications. In Euromicro Conference on Real-Time
Systems, pages 35–38, 2005.
[11] M.-S. Pan and Y.-C. Tseng. Quick Convergecast in Zig-
Bee Beacon-Enabled Tree-Based Wireless Sensor Networks.
Computer Comm., 31(5):999–1011, 2008.
[12] J. Rao and S. Biswas. Joint routing and navigation protocols
for data harvesting in sensor networks. In Proc. IEEE Int’l
Conf. Mobile Ad Hoc and Sensor Systems, pages 143–152,
2008.
[13] J. Rao, T. Wu, and S. Biswas. Network-assisted sink navi-
gation protocols for data harvesting in sensor networks. In
Proc. IEEE Wireless Comm. and Networking Conf., pages
2887–2892, 2008.
[14] G. Wang, G. Cao, and T.F.L. Porta. Movement-assisted sensor
deployment. IEEE Trans. Mobile Computing, 5(6):640–652,
2006.
[15] Y.-C. Wang, C.-C. Hu, and Y.-C. Tseng. Efﬁcient placement
and dispatch of sensors in a wireless sensor network. IEEE
Trans. Mobile Computing, 7(2):262–274, 2008.
[16] Y.-C. Wang and Y.-C. Tseng. Distributed deployment schemes
for mobile wireless sensor networks to ensure multilevel
coverage. IEEE Trans. Parallel and Distributed Systems,
19(9):1280–1294, 2008.
[17] G. Xing, T. Wang, W. Jia, and M. Li. Rendezvous design
algorithms for wireless sensor networks with a mobile base
station. Proc. ACM Int’l Symp. Mobile Ad Hoc Networking
and Computing., pages 231–240, 2008.
[18] G. Xing, T. Wang, Z. Xie, and W. Jia. Rendezvous planning in
wireless sensor networks with mobile elements. IEEE Trans.
Mobile Computing, 7(12):1430–1443, 2008.
[19] G. Yang, B. T. amd Daji Qiao, and W. Zhang. Sensor-
aided overlay deployment and relocation for vast-scale sensor
networks. In Proc. IEEE INFOCOM, pages 2216–2224, 2008.
[20] M. Zhao, M. Ma, and Y. Yang. Mobile data gathering with
space-division multiple access in wireless sensor networks.
Proc. IEEE INFOCOM, pages 1283–1291, 2008.
[21] Y. Zou and K. Chakrabarty. Sensor deployment and target lo-
calization based on virtual forces. In Proc. IEEE INFOCOM,
pages 1293– 1303, 2003.
[22] Y. Zou and K. Chakrabarty. Sensor deployment and target
localization in distributed sensor networks. ACM Trans.
Embedded Computing Systems, 3(1):61–91, 2004.
Non-Location-Based Mobile Sensor Relocation in a Hybrid Static-Mobile Wireless
Sensor Network
Fang-Jing Wu, Hsiu-Chi Hsu, and Yu-Chee Tseng
Department of Computer Science
National Chiao-Tung University
Hsin-Chu, Taiwan
{fangjing, hchsu, yctseng}@cs.nctu.edu.tw
Chi-Fu Huang
Department of Computer Science and
Information Engineering
National Chung Cheng University
Chia-Yi, Taiwan
cfhuang@csie.nctu.edu.tw
Abstract
An inherent concern for a wireless sensor network (WSN)
is the unbalanced energy consumption problem, where sen-
sors closer to the sink are more likely to exhaust their
energy faster than other nodes. To mitigate this problem,
this paper considers including some resource-rich mobile
nodes, called mobile data-pumps, to conduct data relaying
from static sensors to the sink. The network thus becomes
a two-tier network, with the original static sensors at the
low tier and data-pumps at both low and high tiers. We
propose a novel distributed navigation protocol that does
not rely on any location information of sensor nodes to
relocate data-pumps to meet both goals of connectivity and
load balance. The main idea is a concept called virtual
Voronoi cells, which can help data-pumps to locally balance
their loads using the underlaying low-tier topology and
thus signiﬁcantly balance energy consumption of sensors.
Simulation results are presented to verify the effectiveness
of our result.
Keywords: load balance, mobile computing, mobile sensor,
pervasive computing, wireless sensor network.
1. Introduction
The progress of embedded micro-sensing MEMS and
wireless technologies has made the success of wireless
sensor networks (WSNs). A WSN is usually composed of
a sink and a large number of sensors, each capable of
collecting environmental information. Research issues for
WSNs, such as deployment [15], [21], energy-efﬁcient MAC
[7], [11], and data aggregation [3], have been intensively
studied.
Sensor deployment is a critical issue for WSNs. A suc-
cessful deployment must guarantee both connectivity and
coverage. The former is to ensure that sensory data can be
delivered to the sink, and the latter is to ensure that the whole
sensing ﬁeld is fully monitored. Another big challenge is the
energy unbalanced problem, where it is known that sensors
closer to the sink are likely to consume their energy much
faster than other nodes; a lot of works have tried to address
this issue [1]–[4].
Recently, researchers have proposed to add resource-
richer mobile nodes to help relieve the energy unbalanced
problem. In [8], [9], [12], [13], [17], [18], [20], a set of
mobile collectors are used to move along pre-planned paths
to collect data from static sensors. The collection process
can be single-hop [9], [13], [20] or multi-hop [8], [12],
[17], [18]. While such approaches can balance the energy
consumption of sensors, moving these collectors may cause
long delays, thus harming real-time applications. To relieve
this limitation, [19] proposes a two-tier architecture, where
the low tier consists of typical sensor nodes and the high tier
consists of mobile data-pumps, called syphons, each with a
long-range and a short-range wireless interfaces. The short-
range ones can communicate with the low-tier network. The
goal is to design a range-free protocol to help these syphons
to move around to form a connected syphon tree rooted at
the sink by those long-range interfaces. The low-tier nodes
can ﬁrst relay their data to the nearest syphons and then the
syphon tree can quickly relay these data to the sink. In this
way, the energy requirement of low-tier nodes is relaxed.
In this work, we adopt the same two-tier architecture as
in [19]. However, we observe that the design of [19] does
not try to balance the loads of syphons (i.e., the numbers of
sensors served by syphons). Note that unbalanced loads of
syphons will also affect the energy consumption, and thus
the lifetime, of both high- and low-tier nodes. To resolve this
problem, we propose a novel range-free relocation protocol
based on a virtual Voronoi cell concept. We assume no loca-
tion information for syphons, and nor for low-tier sensors.
The only assumption is that the initial deployment of low-
tier sensors should be dense enough to form a connected
network with the sink. Initially, syphons may or may not
be connected with the sink. Figure 1(a) gives an example,
where the data of sensor s1 is relayed by m1 and m2, and
that of sensor s2 needs to go long way to m3 and then to
the sink. If we can properly relocate syphons as shown in
Figure 1(b), then s2 can quickly relay its data via syphons.
Relocating syphons needs to address both connectivity and
55
70
42
s1
68
data-pump
sensor
moving direction
1349,   D|)(| 1mC
7044
s2 m0
m1
m2
m3
m0
m1
m2
m3
(a) (b)
wireless link
114
Figure 2. An example of relocating data-pumps.
3.1. Balancing Mode for Attached Data-Pumps
The main idea is to enforce each attached data-pump mi
to move, based on local information, toward the ‘center’
of its current virtual Voronoi cell while keep attached.
By so doing, load balance can be achieved eventually.
Geometrically, F can be partitioned into multiple Voronoi
cells based on attached data-pumps’ locations. However,
since no location information is assumed, we will use the
connectivity information among S as a clue to navigate data-
pumps. For example, in Figure 2(a), m1 can detect that it is
not at the center of its current virtual Voronoi cell by forming
an intra-cell tree rooted at itself. Our scheme will force m1
to move toward the child with the largest subtree, i.e., s1.
After repeating this movement process several times, m1’s
subtrees will reach certain equilibrium. Concurrently, m2
and m3 will conduct the same process. More importantly,
this will repartition the virtual Voronoi cells. Figure 2(b)
shows an ideal situation after several rounds.
Our protocol is designed as an iterative process with
multiple rounds. Each round has four phases, during which
a data-pump may make a movement. Phase 1 is to partition
F into virtual Voronoi cells in a distributed manner. Phase
2 will decide each data-pump’s moving direction. Phase
3 will choose each data-pump’s parent to maintain the
connectivity in the high-tier network. The actual movement
and termination conditions are decided in phase 4. Phases
among data-pumps need to be synchronized (refer to Sec
3.3).
Phase 1: Virtual cell construction. In this phase, each
data-pump mi will compute its cell C(mi) by forming a
tree Ti rooted at itself. Each sensor sj will maintain two
variables: χ(sj) and h(sj) (hop count from mi to sj in Ti).
Initially, χ(sj) = NULL and h(sj) = ∞. To start with, mi
will broadcast a Cell(mi, h) message using its short-range
antenna with h = 1 (standing for hop count). When any sj
receives a Cell(mi, h) message, it will check the following
conditions: (i) χ(sj) = NULL and (ii) h < h(sj). If any
of the above conditions is true, sj will set χ(sj) = mi, set
h(sj) = h, and broadcast a Cell(mi, h+1) message. At the
end of Phase 1, each sensor will know its master data-pump.
Phase 2: Cell center estimation. In this phase, each
mi will try to identify the center sensor cn(mi) of its
cell C(mi). Initially, mi will assume itself as the center,
i.e., cn(mi) = mi, and broadcast a CENTER(cn(mi))
message around sensors in C(mi) to form a spanning tree
rooted at itself. Each sensor sj will calculate the depth and
the number of sensors of the subtree rooted at itself, denoted
by dj and nj , respectively. Then, each sensor sj can compute
a load index as follows:
εj = α · nj + (1− α) · dj ,
where 0 ≤ α ≤ 1 is a weight to reﬂect the importance of
our two metrics (i.e, the deviation among |C(mi)| and the
deviation among R(mi)). Then, mi will run the following
iterative process to update the center sensor cn(mi). The
main idea can be imagined that mi throws an agent which
is like a ball and will roll toward the center of C(mi) along
the sensors with higher load index. Speciﬁcally, in each
iteration, mi will try to update the center sensor cn(mi)
by the child of cn(mi) with the highest load index, denoted
by sc, if the following condition is satisﬁed: εcε′c ≥ 1, where
ε′c = α · (|C(mi)|−nc)degree(cn(mi))−1 + (1− α) · (dmax + h(sc,mi)) is
the estimation of the average load index for the remaining
subtrees rooted at cn(mi)’s children excluding the subtree
rooted at sc. Here, degree(cn(mi)) is the low-tier degree of
cn(mi) (in terms of short-range antenna degree), dmax is the
maximum depth of subtrees rooted at mi’s children in the
spanning tree except the subtree rooted at sc’s ancestor, and
h(sc,mi) is the short-range antenna hop count from sc to
mi along the spanning tree. Note that instead of reforming
the spanning tree, we use εcε′c to estimate if the loads between
the side of the subtree rooted at sc and the remaining side
in C(mi) is balancing after mi move to sc’s position. Once
mi updates cn(mi) = sc, it must memorize the history of
cn(mi) to help relocate itself along the sequence of sensors
in the history when moving. This completes one iteration.
This process is repeated until there is no descent of cn(mi)
can satisfy the above condition. Note that, this phase can be
repeated more times for reﬁning the center sensor cn(mi) of
this cell. Figure 2 gives an example, where |C(m1)| = 349,
and α = 1. Initially, m1 ﬁnds the subtree rooted at s1 with
highest load index ε1 = 114 and updates cn(mi) = s1,
because ε1ε′1 =
114
58.75 ≥ 1, where ε′1 = 349−1144 = 58.75.
Then, m1 repeatedly run this process until it ﬁnds ε2ε′2 < 1,
where ε2 = 70, and ε′2 =
349−70
2 = 139.5. Finally, m1 can
identify the center sensor cn(m1) is s1.
Phases 3: Connectivity maintenance between mobile
data-pumps. In this phase, each data-pump mi must choose
an attached data-pump to be its parent, denoted by P (mi)
for keeping attached. Speciﬁcally, mi must make sure
that it can always hear the periodical Attachment message
from P (mi) when moving. To achieve this goal, each
3.3. Synchronization Between Phases
We suggest two possible approaches to synchronize the
phases between data-pumps. The ﬁrst one is that the phases
switching is coordinated by the sink, while the second one
is that each data-pump will set a timer for each phase to
control the switching timing between phases.
For the ﬁrst type synchronization, upon the network is re-
quested to perform our protocol, the sink must ﬁrst broadcast
a Phase1-2 Start message via the high-tier network to in-
form attached data-pumps to construct cells and estimate the
centers of cells. When an attached data-pump mi receives
the Phase1-2 Start message, it will rebroadcast this message
via the high-tier network and then execute the phase 1 and
phase 2. After mi has ﬁnished phase1 and phase 2, it will
send a Phase1-2 End message to inform the sink. The sink
must collect Phase1-2 End messages from all attached data-
pumps and then broadcast a Phase3 Start message to inform
data-pumps to execute phase 3. It is similar to the above
procedures, the sink must wait until it knows that all data-
pumps have ﬁnished the current phase and then trigger the
next phase by broadcasting message in the high-tier network.
Also, when an unattached data-pump has became an attached
one, it must listen the synchronization messages from the
sink to conduct the balancing mode.
For the second type synchronization, each data-pump will
set a speciﬁed a timer for each phase. Upon the network is
requested to execute our protocol, each attached data-pump
mi will enter the phase 1 and start a timer Phases1 Timer.
After the Phases1 Timer expired, mi will enter the phase 2
and also wait a timer for the current phases until the timer
has expired. This process will be repeatedly phase by phase
until the protocol is terminated. On the other hand, when an
unattached data-pump mi becomes an attached one, it will
immediately send Synchronization Request message to the
neighboring data-pumps to query how long it should wait
for entering the balancing mode to start a new round. When
an attached data-pump receives a Synchronization Request
message, it will reply a Synchronization Reply message with
a time duration, based on the timers of the four phases
in the balancing mode. After mi receives reply message
from neighboring data-pumps, it will switch to the balancing
mode until the maximum execution rounds has been reached.
4. Simulation Results
We randomly deploy 20000 sensors and 75 data-pumps
in a disk-sharp ﬁeld with a radius of Rf . The short-range
antenna and the long-range antenna have transmission
distances rc = 60 m and Rc = 240 m, respectively (we
use WiFi and ZigBee as the reference here; the former
has a transmission range of ﬁve times the latter [10]). We
set the parameters both α (in phase 2) and β (in phase 3)
as 0.5. Our simulation results are all from the average of
100 runs. We compare our protocol against the SODaR
protocol proposed in [19] by the following two ways.
The ﬁrst one (denoted by ‘ours-only connecting mode’) is
that data-pumps only can perform the connecting mode to
achieve the same goal of the connectivity in the SODaR.
The second one (denoted by ‘ours’) is that data-pumps can
run two modes in our protocol to achieve the both goals of
connectivity and load balance. In SODaR, each unattached
data-pump mi must move along the circle composed of
sensors with the same sensor hop counts from the sink as
mi’s (in terms of short-range antenna hop count) to connect
an attached data-pump. In our simulations, we use three
metrics to evaluate the performance of ours and the SODaR
as follows.
1. The quantiﬁcation of the balance: we use the
fairness index [6] to measure the deviation of data-
pumps’ loads. Here, the fairness index is calculated by
f(|C(m1)|, |C(m2)|, . . . , |C(me)|) = (Σ
e
i=1|C(mi)|)2
e·Σei=1(|C(mi)|)2 ,
where 0 ≤ f(|C(m1)|, |C(m2)|, . . . , |C(me)|) ≤ 1. Note
that a protocol with the larger fairness index implies the less
deviation of data-pumps’ loads (i.e., it is more balancing).
2. The movement overhead: we calculate the average
moving distance of data-pumps in a protocol.
3. The communication overhead: we calculate the total
number of messages exchanged in a protocol.
First, we ﬁnd an adequate maximum execution round by
observing the improvement in balance under different num-
ber of execution rounds. Figure 3(a) shows the simulation
result, where the fairness index only is slightly improvement
after 10 rounds. Thus, we take the maximum execution
round of our protocol by 30 rounds in the following simula-
tions. Then, we investigate the impact of relocation protocols
on balance under different radius of deployment. Figure 3(b)
shows the result, where the fairness index is decreasing with
the increasing of Rf . This is because the number of data-
pumps is too less to span a large-scale high-tier network to
balance the loads of data-pumps when Rf is larger. Note
that our relocation protocol has prominent balance results
even if only the connecting mode is conducted. Then, we
focus on the goal of connectivity to compare the overheads
of relocation protocols under different Rf . Figure 3(c) shows
an interesting result on the movement overhead, where
SODaR only can successfully work under some deployment
cases (Rf is between 1000 and 2000) and results in higher
movement overhead. This is because it may fail that an
unattached data-pump in SODaR searches an attached data-
pumps within a limited area. Note that the SODaR results
in less movement overhead when Rf > 2000, because most
data-pumps can not relocate themselves due to the SODaR
fail. However, our connecting mode can always work out
ﬁne, and unattached data-pumps can quickly connect to the
sink with less moving distance. Finally, in Figure 3(d) shows
