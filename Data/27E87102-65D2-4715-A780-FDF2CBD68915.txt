 第 2 頁 / 共 89 頁 
計費服務，計費系統每隔五秒就會記錄 Video Stream
之流量轉換成服務費率。 
 
關鍵詞： IMS 平台、跨層管理、服務品質、資源管
理、感知網路、協力網路 
Abstract 
Accelerated advances in wireless mobile 
communications technology have rapidly transformed 
mobile communications and services. These advances 
are exhibited wireless access networks, mobile terminals 
and service providers. As companion, the emerge of IP 
multimedia subsystem (IMS) platform allows service 
providers to accommodate extended services, such as 
voice, data and video streaming based on open 
architecture and standards. Through unified 
heterogeneous networks, users are enabled to access 
applications using distinctive user terminals equipped by 
different network access technologies. When users’ 
terminals access the applications across various network 
environments, the terminals have to deal with different 
level of handoff decisions. As generally assumed, the 
certain degree of packet loss incurred by the variation of 
handoffs. This poses a major challenge for QoS 
provisioning and resource management in 4G-IMS 
network environment. 
In the first year, the project has completed the 
implementation of the “cross-layer, cognition, 
cooperation, QoS manager” (C3QM ）  on 4G-IMS 
network infrastructure. The C
3
QM data plane modules 
were designed and developed on each defined interface. 
Then, dynamic allocations of and quality-of-service 
(QoS） mechanism was embodied into the control layer 
of the C
3
QM 4G-IMS network. In addition, the project 
also focused on integrating services of QoS dynamic 
control in the C
3
QM 4G-IMS networks. The data plane 
interfaces and modules were used to accomplish Flow 
Classifier and the Monitoring mechanism design as well 
as to improve Data Collection/Transmission functions. 
 
In the second year, the project completed the QoS agent 
and cross-layer, cognitive and cooperative process 
mechanism by using a cross-layer design and 
cognition-cooperative decision-operating mode. It 
satisfied the QoS requests for various applications in 
heterogeneous networks. In order to enhance the QoS, 
this work established a hardware environment that 
integrates each sub-project mechanism to preform 
experimental tests analysis, through the analysis the 
function of each model confirms the evaluation of the 
system performance. 
 
In the third year, the project completed the design and 
development of Quality Assurance Management and 
Charging System interfaces. QAM Charging provides 
4G-IMS system billing and control mechanisms. The 
different services levels such as GPRS, IMS and MMS 
were combined with Online Charging and Offline 
Charging modules which conduct real-time monitoring 
of resource utilization levels and detect the relevant 
billing information. Moreover, the project enhanced the 
PCC (Policy Control and Charging) function using PCRF 
(Policy and Charging Rule Function) to offer a high level 
charging flexibility. In contemplation of achieving users’ 
best-assigned services through user-based billing 
principles, the charging module computes the system 
resource utilization follows the charging standard. 
 
 
Keywords: IP Multimedia Subsystem Platform, 
Cross-Layer Management, Quality of Service, Resource 
Management, Cognitive Network, Cooperative Network 
 
 
 第 4 頁 / 共 89 頁 
 
 
圖三: Cross-Layer Manager 
 
表一: 各階層之 Events 和可供調控的 Variables 
 
 
    近年來，由於無線通訊及行動計算技術的日新月
異，使行動通訊者及服務提供者處於異質的網路環境
中。此種異質性存在於無線存取技術、網路、使用者
終端機、裝置設備、應用程式及服務提供者等。基於
下列理由，這些異質性在可預見的未來不太可能消失
[12]： 
 
1、應用程式需求的多樣化，以致於很難找到單一最佳
化且全面性的解決方案。 
2、基於競爭公司佔領市場的渴求，許多擁有專利的系
統紛紛相繼釋出。 
 
    因此，一個異質環境提供 Seamless 且 Adaptive
的服務品質，將是下一代無線通訊系統的致勝關鍵之
一。未來，提供使用者符合經濟效益、無所不在、無
處不連以及高服務品質的網際網路是最基本的需求。
然而，在一個異質無線網路環境中，應用程式可能因
為不同的網路狀況，而使得執行效能降低，而這些效
能的波動將被大範圍的散佈開來。為了解決這些問題，
必頇有一個能讓上層應用不受底層變化所影響的 QoS
設計，以確保服務品質的提供。本計畫的研究將著重
於目前 TCP/IP 階層式架構中 QoS 不足的部份提出解
決策略，以下茲介紹國內外研究實例，說明 QoS 在有
無 Cross-layer、Cognitive、4G-IMS Network 支援情況
下的差異。 
 
三、 文獻探討 
本計畫依據所提出的異質網路環境以及欲達成服
務品質保證與資源管理的目標，分別針對 IMS、
Cross-Layer Issue 及 Cognitive Network 進行文獻的蒐
集與分析，以利計畫的研究與開發‧ 
 
3.1 IP Multimedia Subsystem (IMS) 
IMS 是由國際合作組織 3GPP (3rd Generation 
Partnership Project)所提出的技術標準。IMS 平台主要
以 SIP (Session Initiation Protocol)為基礎，透過開放和
標準架構，使服務提供者可以在 IMS 平台上同時提供
語音、數據、與視訊等多樣化應用服務，亦可以作為
固網、WLAN、WiMAX、GSM、GPRS 等有線或無線
網路的共同平台。IMS 的應用目的，係在 3G 網路架
構中提供行動網際網路的服務，並確保在不同網路間
轉換時的 QoS [13, 14]。  
 
在Mobile Network內提供QoS是相當具挑戰性的
議題。由於頻寬之變動、基地台之間 Handoff 問題，
嚴重影響封包之傳遞，使得 Mobile Network 中的
Realtime Applications 相當容易受影響。在一般的有線
網路中，封包傳輸處於「最佳效率」的狀態，此狀態
意味著網路會儘量保持 Application 所需的頻寬，但不
會依據頻寬的可用性和網路的擁塞情形，予以任何的
保證，此項設計並無法確保 Mobile Network 中的
Real-time Applications 服務 QoS [15]。 
 
整合 SIP-based Network Mobility至 IMS環境中，
其帶來好處是節省電力、複雜度低、減少 Handoff。
此研究提出兩種機制: Loosely Coupled Architecture 以
 第 6 頁 / 共 89 頁 
Layer ARQ 即依照 Cross-Layer 的設計理念，考慮以
Physical Layer 傳輸的調變及編碼方式（Modulation and 
Coding），搭配 Data Link Layer 的自動重傳請求訊號
(Automatic Repeat Request; ARQ)，達成即時調配的訊
號傳輸，增進無線網路的資料傳輸量。 
 
圖七為發送端以無線的方式傳送資料給接收端，
其間的傳輸 Channel 受 Channel Fading 干擾。一般 Data 
Link Layer 在傳輸期間，若受到雜訊干擾，而導致資
料錯誤或遺失，則發出 ARQ 訊號作為自動重傳請求；
若傳輸 Channel 依然持續受到相同的雜訊干擾，則重
新傳送資料的成功率依然會受到影響。因此，有相關
研究在接收端加入 Channel 偵測器，評估 Channel 的
實體環境之後，動態選擇適合的調變編碼模式，並搭
配 ARQ 的使用與發送端進行協商，選擇調變編碼模
式來進行傳輸。 
 
圖七: AMC with ARQ 系統架構圖 
 
如此設計，即包含了跨越 Physical Layer 及 Data 
Link Layer 的 Cross-Layer 運作概念，以改善資料傳輸
時的 Throughput，進一步確保了上層資料傳輸的
QoS。 
 
ECN Bit 系統 
    一般網路上的路由器，遇到網路擁塞的情況時，
將會丟棄超載的封包，此時會造成傳送效能低落。因
此，許多研究傾向在封包欄位中加入一個 ECN Bit
（ Explicit Congestion Notification Bit ）， 以 便 對
Congestion Related Loss的情況及Channel Related Loss
的情況作區別。如圖八所示，當網路發生擁塞的狀況
時，Router 將把封包中的 ECN Bit 欄位設定為 1，接
收端收到封包後，即可得知網路正處於擁塞的情形，
同時回傳封包至原發送端並將 ECN bit 設定為 1，原
發送端也因而得知網路的擁塞情況，此後兩端傳輸將
會依照相對應的排程機制，進行適當的傳輸動作，以
避免因Congestion與Channel Fading情況的混淆不清，
所導致縮減傳送速率的誤判。依據這些不同的實體網
路狀況作適當的傳送排程，一方面可以動態因應實際
的網路狀況，以避免在環境不佳的時段傳送資料，另
一方面也可避免因擁塞狀態的誤判，所導致不必要的
傳送速率縮減，從而改善整體的傳輸效能，也確保
QoS。 
 
圖八: ECN Bit 系統架構圖 
 
ECN Bit 系統主要提出的概念是由 Physical 
Layer 直接將即時的網路環境狀況，向上反映至
Network Layer,運用 IP 表頭的附加欄位作標示，以便
區隔 Congestion 及 Channel Fading 這兩種情況所造成
的封包遺失，也同樣屬於利用 Cross-Layer 的設計理念，
以確保 QoS 的實例。 
 
WQE（Wireless Quality Enhancer）系統 
WQE 系統(如圖九所示)主要是在無線網路中，
加入 WQE 裝置至 AP 有線端。上層的應用程式會將
該應用之 QoS 需求附加在每個資料片段，傳遞到
Network Layer；資料流在網路傳遞時，在 IP 表頭的延
伸欄位附加相關資訊以供區別 QoS 的需求。WQE 系
統裡的 AP 能夠依據不同 QoS 的需求，以不同的傳送
策略進行傳遞。假如遭遇 QoS 需求無法識別的封包，
便會將該封包送到 WQE 設備，由 WQE 依據該封包
的 QoS 需求，來指定適當的傳送策略，再將此傳送策
略讓 AP 知道，並由 AP 依據 WQE 所指定的傳送策略
來進行傳送。 
 
 第 8 頁 / 共 89 頁 
(OFDMA)之技術，開發出在感知無線技術系統上有效
率的Channel Sensing管理。為了增進整個系統的效能，
上 述 所 提 及 方 法 ， 為 利 用 頻 率 選 擇 性 衰 減
(Frequency-Selective Fading)的 Channel 與考慮不同類
型的主要使用者之 Multiuser-Diversity。其結果顯示，
當減少主要用戶的等待時間，可增加感知無線技術系
統的利用度[30,31]。 
 
    圖十二所示，利用 Fixed Quiet Interval 可感知主
要使用者的存在。在此 Interval，當所有感知無線技術
的使用者停止傳送和接收資料時，稱之為 Quiet 
Interval。由於感知無線技術系統只能夠在此 Quiet 
Interval 感知主要使用者的存在，所以為了在短時間內
搜尋到主要使用者的存在，Quiet Interval 之間的間隔
不能過大。基地台與其廣泛使用者構成具 OFDMA 的
Cognitive Radio Downlink 系統。為了減少在 OFDMA 
系統之上層被 Subcarrier 控制，在此由多個 Subcarriers
構成的「子通道」，可以用來作為控制的單元。而每個
具有子通道的系統，由 Channel 凝聚頻寬之內的
Adjacent Subcarriers 所構成。此外，系統時間被切割
成 Frames，每個 Frame 由 OFDM Symbols 所構成(如
圖十三所示)。 
 
 
圖十二: Fixed Quiet Interval 
 
 
圖十三: OFDMA Frame Structure 
 
此研究設計出具 OFDMA的感知無線技術系統之
動態感知的排程程式，以減少主要使用者的感知時間，
增加感知無線技術系統的利用度。與採取 Fixed Quiet 
Interval 的策略相比，此研究提出的設計具有頻率選擇
性衰減的優點，增進 Channel Sensing 的效能。 
 
Self-Aware Networks and QoS 
在各種相關的網路架構中，以QoS-Driven Routing 
Protocol 為核心的架構，稱為 Cognitive Packet Network 
(CPN)。CPN 是一種封包路徑選擇(Routing)的協定，
此協定藉由即時線上量測的數據，選擇使用適合的技
術進行路徑選擇。執行 CPN 的必備條件中，其中一項
為第一次進行隨機搜尋時，CPN 即使沒有初始值也能
夠自我啟動(Cold Start)，並經由執行的紀錄，逐步地
改善其行為。由於網路的主要功能是將某一來源(S)
的封包轉送到某一目的地(D)，因此 CPN 必頇具備即
使沒有轉送路徑的資訊，還是能將封包從 S 轉送到 D
的功能(如圖十四所示)。 
 
 
圖十四: CPN Network Topology 
 
在此研究中利用 CPN 的技術，開發出 Dynamic 
QoS Control 實驗系統，運作架構如圖十五所示。整個
系統操作範圍在網際網路中進行，使用的是動態流量
控制，其中網路伺服器藉由不同的網際網路連接埠，
將訊息傳遞出去，此方法可以有效的降低上述訊息傳
遞的延遲。 
 
圖十五: Dynamic QoS Control System 
 
網路的使用者可以藉由網際網路存取網路伺服器，
ISP1
ISP2
INTERNET
INTERNET
IP
CPN
CPN
CPN
IP
IP
CPN
CPN
Router-1
Router-2
Web server
Http-request Http client Http-reply
 第 10 頁 / 共 89 頁 
境中，能夠藉著某種程度上的互動，完成任務的軟體
代理者。 
 
其中，在 SD 設計上，可以使用自我組織
(Self-Organization)的方法。此外，軟體代理者也被設
計成能夠在大型環境及分散式環境裡運行。因此，
MASs 具備幾個特性讓其能夠去描述 Cognitive 
Network (CN)行為：其方法能夠滿足複雜的系統，讓
不同程度機器學習，能有自然均勻分佈的特點，以及
在非穩定的環境裡仍可運行。由於 MASs 本身具有互
動性，利用這些特點，使得 MAS 的自我組織及緊急
處理性得以滿足複雜的系統[46]。 
 
四、 研究方法 
以下介紹本研究所提出相關模組設計以及跨層
式 QoS 策略演算法連結 Charging System 提供之計費
機制與控制功能。 
 
4.1 4G-IMS 架構 
圖十六為整體 4G-IMS 環境架構圖，本研究將
QoS 決策建立於 IMS 中 P-CSCF 模組上，對所有通過
P-CSCF 的 Session 進行分析，並將決策後的結果，在
不同存取網路的 Gateway 上進行流量的控管，並針對
使用者的網路環境，判斷是否符合使用者QoS的需求，
再進行 Adaptive QoS 決策，挑選最適用的存取網路進
行換手，以滿足使用者對 QoS 的要求。 
 
圖十六: 4G-IMS 環境架構 
 基於Cross-layer、Cognitive 和Cooperative概念，
本研究擬開發一套 C3QM 系統，以確保 4G-IMS 網路
應用之服務品質和資源妥善管理，並改善使用者對於
服務品質的觀感。圖十七為 4G-IMS 架構模組圖，其
中分為資料層（Data Plane）、控制層（Control Plane）
與知識層（Knowledge Plane）。資料層的主要功能是
負責資料的收集與傳送及對資料流的處理並且收集
TCP/IP 各層的資訊和網路狀況的資料，提供至控制層
和知識層進行分析及管理；控制層主要目的是負責
QoS 的控制及訊號處理，提供資料層與知識層每項功
能執行時所需的控制訊號。控制層收到資料層傳來的
訊息，再依所設計的功能來做處理，並將控制訊號透
過資料層進行處理及傳送；知識層則是基於 MSM 
(Multi-Service Agent Model)架構的系統，在物件導向
式的 Multi-Agent 系統模組中，每種 Agent 都是主動式
的物件，能夠同時獨立工作。 
 
圖十七: 4G-IMS 架構模組 
 
4.2 QAM Charging System Design 
(Quality Assurance Management, QAM) Charging 
System 對 4G-IMS 系統提供計費機制與控制功能。此
模組蒐集並運算系統所消耗之資源利用率，作為
Charging System 收費之計算標準。 
本研究所定義之 QAM Charging System 依循
3GPP 的標準，如圖十八所示，提供在應用服務(如
GPRS)、子系統(IMS)和業務(如 MMS)各層的 Online 
Charging 和 Offline Charging Module，進行即時監控各
層的資源使用情況，從而檢測相關計費資訊。Offline 
Charging Module 是在資源使用後由網路向計費系統
匯報資源的使用情況；Online Charging Module 是允許
用戶使用請求的網路資源之前，先至此模組查詢用戶
Application 
Server
HSS
SCIM
BGCF
MGCF
SGW
MGW
   RACS
NASS A-RACS PDF
MRF
MRFC
MRFP
I-BCF/
SIP ALG
GGSNSGSN
PDG
BAS / 
A-BGF
DSLAM
WAG
RAN
3GPP R7: Fix Network
3GPP R6: WiFi
3GPP R5: GPRS/UMTS
Core
 Network
PSTN
IPv6 Network
IPv4 Network
Service / Application Plane
Control / Signaling Plane
Media / Transport Plane
I-BFG/TrGW
Application 
Server
Application 
Server
Signaling
Data / Media 
CSCF
I-CSCF
P-CSCF
S-CSCF
 第 12 頁 / 共 89 頁 
 
基於上述機制，QAM Charging System 將提供完
善和靈活的計費策略。由於次世代行動通訊網路可提
供的服務類型非常豐富，不同服務、不同內容可以採
取多樣的計費策略，QAM Charging System 的計費機
制可有效應用於靈活多變的計費需求。因此，當新的
計費策略引入時，營運商不需要對控制層和服務層網
路進行改造，可修改些許參數與設定，即可運作 QAM 
Charging System，用以實現相關計費功能。 
 
4.3 Charging 策略 
本研究之Charging策略依據前兩年所定義之QoS
機制，按照 3G、WLAN 及 WiMAX QoS 規格，將不
同類型之應用程式分為 Interactive Class，VoIP，
Video/Audio Streaming 以及 Best Effort 等四個類別(如
表二所示)，每類應用程式具有不同的 QoS 需求，結
合由感知能力所獲取的 RSSI 值進行 QoS 的決策，判
斷是否有更合適的存取網路提供使用者進行 Handoff
以獲得最佳的傳輸品質，如現有網路環境無法滿足眾
多使用者時，再啟動 Charging 機制。當使用者的網路
環境遭受到雜訊干擾時，系統就會根據使用者帳戶的
權重值去判斷是否請求更好的 QoS，有較高權重值的
帳戶便會啟動 QoS 策略機制，以保證應用程式所需的
QoS。 
表二:QoS 分類等級 
 Traffic Classes 
QoS 
Concern 
Typical 
Application 
#1 
Interactive 
Class 
Reliable Web Browsing 
#2 VoIP 
Delay and 
Jitter 
Voice 
#3 
Video/Audio 
Streaming 
Packet Loss MPEG Video 
#4 Best Effort Throughput FTP download 
  
依據本研究所提供之 QoS 機制，營運商可根據
使用者的付費標準，提供不同等級之服務與效能。計
費機制則主要以兩種參數為其調控主因，其為服務優
先權 /計價 (Service Priority/Accounting)和流量等級
(Traffic Class)。 
1. 服務優先權/計價(Service Priority/Accounting)：服
務優先權/計價的部份則以使用者付費多寡，來提
供對應之 QoS 服務的概念，或使用者有長期使用
次世代行動通訊網路平台，且讀取 QoS 服務之頻
率較高，則隨時間會逐漸開放其他服務於該使用者
運用。本研究定義以下三種 QoS 等級來定義其使
用者類別，當資源衝突或使用環境受到限制時，將
有助於 QAM Charging System 做出更正確的判
斷。 
 QoSClass = 3 (白金使用者) 
 QoSClass = 2 (VIP 使用者) 
 QoSClass = 1 (一般使用者) 
2. 流量等級(Traffic Class)：在流量等級的定義部份，
考慮 Bit Error Rate(BER)、數據段順序(Segment 
Order)、數據段遺失(Segment Loss)和數據段延遲
(Segment Delay)等因素。本研究將最小分辨流量稱
為 QoS 資料流(QoS Stream)。於表三中，QoS Stream 
ID #15 代表著最高等級的 QoS 資料流，相反地 QoS 
Stream ID #5代表著最低等級，而QoS Stream ID #1
～QoS Stream ID #4 是預先保留下來供未來擴充使
用。而環境變數(BER、Segment Order、Segment Loss、
Segment Delay)的評估範圍是從#4～#1，這些的參
數設定必頇根據底層頻道狀況來做動態的調整。 
表三：流量等級表 
 
以上兩個參數設定後，本研究利用以下方程式(5)
得知 QoS 參數值，可針對每個使用者所要求的服務如
語音、影像串流、資料，規劃出最適當的 QoS 狀態，
 第 14 頁 / 共 89 頁 
 
圖二十：Charging 決策流程圖 
 
五、 結果與討論 
以下介紹本研究的系統效能分析，以及相關實作
的成果。 
 
5.1 效能分析 
以下針對附加 Charging 機制下的 Video Stream 與
VoIP Stream 進行模擬量測與效能分析，量測的數據包
括：平均延遲時間(Delay Time)、抖動時間(Jitter)、及
封包遺失率(Packet Loss Ratio)。模擬環境拓樸與各段
連線能力如圖二十一所示。模擬環境包含 3G、WiMAX
與 Wi-Fi 三種網路環境，其網路頻寬分別為 2Mbps、
14Mbps 及 54Mbps；UMTS/Node B、802.16 BS 與
802.11 AP 連結到其 Gateway，其連線能力為 8Mbps，
而 Gateway 與 CN(Corresponding Node)之間的連線能
力為 100Mbp，而兩個 Gateway 之間的連線能力為
20Mbps。 
 
圖二十一:網路模擬環境拓樸 
 
本研究所模擬的應用程式型態為 VoIP 與 Video 
Stream，相關模擬參數設定與 UE 在某時間點所產生
的封包個數如圖二十二所示。其系統 Throughput 如圖
二十三所示，且於 Wi-Fi 環境則設定起始值為 0 秒，
每五秒產生封包數據；WiMAX 環境固定於 5Mbps；
而在 3G 環境中則起始值設為 70 秒，且每五秒產生封
包數據。 
 
圖二十二: 模擬參數 
 
圖二十三: Gateway Throughput 
 
模擬的結果如下圖所示。圖二十四顯示使用 VoIP
服務計費實行的情形，針對語音計費如 Session 使用
PCMU Codec(64 kbps)將會比使用 GSM Codec(13.6 
kbps)多出五倍的費率，而圖中所採用的是 GSM Codec，
曲線的變動是相當平穩。 
 第 16 頁 / 共 89 頁 
圖二十八為編輯 QoS Class Policy 之介面，藉由
此介面，管理者可依據每個建立的 Session，依據其
QoS Class 等級，限制此 Session 的網路流量在頻道傳
輸之上傳及下載的頻寬使用量。當 Policy 完成編輯後，
PCRF 中 Domain Processor 會再次解析此 Policy 定義
的參數，並將此需求送往 PCEF 實際執行。 
 
 
圖二十八: 動態編輯 QoS Class Policy 
 
圖二十九為編輯 Domain Policy 之介面，藉由此
介面，管理者能依據傳送及接收端本身的 Domain 
Name 限制其頻寬使用量。 
 
圖二十九: 動態編輯 Domain Policy 
 
圖三十為 Application Class Rule 之結構，在
Application_class 標籤內，定義每個 Application 類別
能夠佔據的頻寬使用量，當此 Policy 被 PCRF 處理完
成並授權後，則顯示 Application Class Authorized 訊
息。 
 
 
圖三十: Application Class Rule 結構 
 
圖三十一為編輯 Application Class Policy 之介面，
藉由此介面，管理者可根據正在傳送 Session 之
Application Class(透過 SDP 訊息包含的 Media Type)，
並利用此 Policy Rule 限制其所佔據的頻寬使用量。 
 
圖三十一: 動態編輯 Application Class Policy 
 
圖三十二為 QoS Parameter Database 介面，藉由
此介面，管理者可隨時監控異質存取網路之整體網路
狀態，並將底層觀察並分析後的 QoS 資訊，例如: 
Packet lost、Delay 和 Jitter 等參數呈現在管理介面上。
QoS Parameter Database也提供QoS參數儲存之功能，
將資料送到後端資料庫存放(MySQL Database)，使本
計畫設計之 QoS 策略能夠依據分析後的資訊進行決
策。 
 
 第 18 頁 / 共 89 頁 
 
圖三十七: Cooperative 架構 
  
 圖三十八為建置 C3QM 中之 Cooperative 機制，
於各異質網路之路由器中建置 Java Jade Agent-based 
System，以做為資料溝通之代理人，來傳送異質網路
中各 QoS 參數值，做為判斷 Handoff 機制之依據。 
 
 
圖三十八: Java Jade Agent-based System 
 
 依據上述相關 Agent System 資訊，建置動態偵
測之 QoS Agent。在各異質網路上建置 QoS_pAgent，
用以收集相關 QoS 參數，並可互相傳遞相關資訊，已
達 Cooperative 功能，讓各異質網路之間訊息達到互相
通訊，且與建置於 HSS 中之 QoS_dbAgent 和 PCRF
之 QoS_learningAgent 做定時之互相溝通。如圖三十九
為各 QoS Agent 建置於 4G-IMS 整體架構示意圖。 
 
 
圖三十九: QoS Agent 建置示意圖 
 
 圖四十為QoS_pAgent開始執行收集QoS資訊，
並定時傳遞資訊於 QoS_learningAgent 和各異質網路
路由器中之 QoS_pAgent，執行各異質網路之 QoS 資
訊交換，並傳遞於 QoS_dbAgent 做 HSS 資料更新，
且動態更新QoS Parameter Database介面之資料顯示，
而 QoS_learningAgent 執行 QoS 決策判斷。 
 
 
圖四十: QoS_pAgnet 執行畫面 
 
 圖四十一為 QoS_dbAgent 接收資訊後之訊息，
透過 QoS_dbAgent 可定時與 HSS 進行相互溝通，QoS
資料定時更新，可讓使用者方便於得知目前 QoS 資
訊。 
 
 
 
 
 
 
Netw
ork 
Ma
in 
Co
nta
ine
r 
Co
nta
ine
r 2 
Co
nta
ine
r 1 
Plat
for
m 1 
Plat
for
m 2 
Ma
in 
Co
nta
ine
r 
 第 20 頁 / 共 89 頁 
 
圖四十六: Record Message 
 
在 Charging 費率計算方面，透過 QoSclass、
QoSstreamID 和 QoSnetwork 等參數的設置，可針對不
同用戶及不同的服務決定其費率，於 PCRF 中增加
QoS 之 Charging Rule，對使用者而言增加了執行 QoS
理想頻段決策之公平性，並根據 Online Charging 
Module 和 Offline Charging Module 傳遞更新資訊，即
時改變費率決策資訊。圖四十七為使用多媒體服務計
費之執行畫面。 
 
 
圖四十七: 多媒體服務執行畫面 
 
六、 計畫成果自評 
現今瞬息萬變的網路應用環境中，即時性
（Real-Time）的應用服務是研發重點，然而網路資源
有限，但品質保證之需求卻無止盡地提升，因此需要
一個品質保證的服務，以確保網路使用者的權益。在
現代之網際網路蓬勃發展下，使用者皆處於有線及無
線之異質性網路環境，故注重的服務品質也不盡相同。
例如：無線網路環境中比較著重於位元錯誤率、資料
重傳，以及封包遺失的問題，主要是因為眾多服務品
質控制參數於有線環境中之敏感度較低。此外，應用
程式類別繁多，造成所需控制之服務品質參數有所差
異。例如：網路電話則注重延遲變化率，以及端對端
的延遲時間，線上電影較為重視封包遺失率相對於影
片解析度的影響。 
 
故根據現有的QoS規範，以多媒體應用軟體之
QoS分類為基礎，本計畫設計出可適性QoS管理機制，
用於即時監控網路流量及網路擁塞時的頻寬管理，且
提供可選擇性的存取網路，針對無線網路異質性的服
務品質參數來做進一步控制調整，進而確保Access 
Network的服務品質，並可提供相關參數運用於換手機
制使用，達到本計畫之QoS控制與整體4G-IMS網路架
構之完整性。 
 
本研究為三年期之研究計畫，研究主題分別為
「4G-IMS網路架構、介面定義與C3QM資料層模組設
計與開發」、「All-IP 4G網路C3QM控制層QoS整合與
動態調配」及「4G-IMS網路C3QM知識層之QoS動態
控管之服務整合」三大課題。 
在計畫研究成果 outcome 部份，本研究成果已發
表八篇國際期刊論文及八篇會議論文。包括: 
 
1. C.F. Lai, Y.M. Huang, J.L. Chen, W. Ji and M. Chen, 
“Design and Integration of the OpenCore Based Mobile TV 
Framework for DVB-H/ T Wireless Network,” ACM 
Multimedia System Journal, Vol.17, No.4, pp.299-311, 2011. 
2. J.L. Chen, S.W. Liu, S.L. Wu and M.C. Chen, “Cross-layer 
and Cognitive QoS Management System for 
Next-Generation Networking,” International Journal of 
Communication Systems, Vol.24, No.9, pp.1150-1162, 2011. 
3. M.C. Chen, J.L. Chen and T.W. Chang, 
“Android/OSGi-based Vehicular Network Management 
System,” Computer Communications, Vol.34, No.2, 
pp.169-183, 2011. 
4. C.Y. Chen, K.D. Chang, J.L. Chen and H.C. Chao, 
“Extending Emergency Services Coverage in Cooperative 
IMS Networks,” Appear to Int. J. Autonomous and Adaptive 
Communications Systems. 
5. J.L. Chen, Y.C. Chang, Y.S. Lin and H.W. Du, “Embedded 
Worldwide Interoperability for Microwave Access-based 
Vehicular Router for Telematics Computing,” IET 
Communications, Vol.4, No.7, pp.861-869, April 2010. 
6. X. Li, H. Zhang, J.M. Chang, J.L. Chen and H.C. Chao, 
“PIMac: Multicast Access Control Implementation in 
PIM-SM,” Wireless Personal Communications, Vol.55, No.1, 
pp.35-49, September 2010. 
7. J.L. Chen, Y.W. Ma, C.P. Lai and Y.M. Huang, “Multi-Hop 
Routing Mechanism for Reliable Sensor Computing,” 
Sensors, Vol.9, No.12, pp.10117-10135, 2009. 
8. H.F. Lu and J.L. Chen, “Design of Middleware for 
Tele-Homecare Systems,” Wireless Communication and 
 第 22 頁 / 共 89 頁 
參考文獻 
 
[1] J. Choi, Kihong Park and C.K. Kim, “Analysis of 
Cross-Layer Interaction in Multirate 802.11 
WLANs,” IEEE Transactions on Mobile Computing, 
Vol. 8, No. 5, pp. 682-693, May 2009. 
[2] B.J. Chang and J.F. Chen, “Cross-Layer-Based 
Adaptive Vertical Handoff with Predictive RSS in 
Heterogeneous Wireless Networks,” IEEE 
Transaction on Vehicular Technology, Vol. 57, No. 
11, pp. 3679-3692, Nov. 2008. 
[3] F. Foukalas, V. Gazis and N. Alonistioti, 
“Cross-Layer Design Proposals for Wireless Mobile 
Networks: a Survey and Taxonomy,” IEEE 
Communications Survey & Tutorials, Vol. 10, No 4, 
pp. 70-85, Apr. 2008. 
[4] C. Xiangqian, K. Makki, Y. Kang and N. Pissinou, 
“Sensor Network Security: a Survey,” IEEE 
Communications Surveys & Tutorials, Vol. 11, No. 2, 
pp. 52-73, Apr. 2009. 
[5] W.L. Benjamin, J.F. Colin and A.C. David, 
“Cross-Layer Verification of Type Flaw Attaches on 
Security Protocols,” Proceedings of ACM 13th 
Australasian Conference on Computer Science, Vol. 
62, pp. 171-180, 2007. 
[6] H. Ekstrom, “QoS control in the 3GPP evolved 
packet system,” IEEE Communications Magazine, 
Vol. 47, No. 2, pp. 76-83, Feb. 2009. 
[7] P. Bellavista, A. Corradi and L. Foschini, “IMS-based 
Presence Service with Enhanced Scalability and 
Guaranteed QoS for Interdomain Enterprise 
Mobility,” IEEE Wireless Communications, Vol. 16, 
No. 3, pp. 16-23, Jun. 2009. 
[8] Y.T. Mai, C.C. Yang and Y.H. Lin, “Cross-Layer QoS 
Framework in the IEEE 802.16 Network,” 
Proceedings of the 9th International Conference on 
Advanced Communication Technology, Vol. 3, pp. 
2090-2095, Feb. 2007. 
[9] M.S. Siddiqui, R.A. Shaikh and C.S. Hong, “QoS 
Control in Service Delivery in IMS,” Proceedings of 
the 11
th
 Interational Confernece on Advanced 
Communication Technology, Vol. 1, pp. 157-160, 
Feb. 2009. 
[10]M.K. Denjo, E. Shakshuki and H. Malik, “A 
Mobility-Aware and Cross-Layer Based Middleware 
for Mobile Ad Hoc Networks,” Proceedings of the 
21
th
 International Conference on Advanced 
Networking and Applications, pp. 474-481, 2007. 
[11] M. Chang, M. Lee and H. Lee “Per-Application 
Mobility Management with Cross-Layer Based 
Performance Enhancement,” IEEE Wireless 
Communications and Networking Conference, pp. 
2822-2827, March 2008. 
[12] V.C.M. Leung, J. Zhang, F.R. Yu, H.C.B. Chan and 
H. Tang, “Enhancing Interoperability in 
Heterogeneous Mobile Wireless Networks for 
Disaster Response,” IEEE Transactions on Wireless 
Communications, Vol. 8, No. 5, pp. 2424-2433, May 
2009. 
[13] L. Lifeng and L. Gang, “Cross-Layer Mobility 
Management based on Mobile IP and SIP in IMS,” 
Proceedings of the International Conference on 
Wireless Communications, Networking and Mobile 
Computing, pp. 803-806, Sep. 2007. 
[14] M.A. Melnyk, A. Jukan and C.D. Polychronopoulos, 
“A Cross-Layer Analysis of Session Setup Delay in 
IP Multimedia Subsystem (IMS) with EV-DD 
Wireless Transmission,” IEEE Transactions on 
Multimedia, Vol. 9, No. 4, pp. 869-881, Jun. 2007. 
[15] A. Anzaloni, M. Listanti and I. Petrilli, 
“Performance Study of IMS Authentication 
Procedures in Mobile 3G Networks,” Proceedings of 
the International Conference on Wireless 
Communications and Mobile Computing, pp. 
248-253, 2007. 
[16] W.K. Chiang, A. Ren and Y.C. Chung, "Integrating 
SIP-Based Network Mobility into IP Multimedia 
Subsystem," Proceedings of the IEEE Wireless 
Communications and Networking Conference, 
pp.1-6, 5-8 April 2009. 
[17]M.S. Siddiqui, S.O. Amin and C.S Hong, “A Set-Top 
Box for End-to-End QoS Management and Home 
Network Gateway in IMS,” IEEE Transactions on 
Consumer Electronics, Vol. 55, No. 2, pp. 527-534, 
May 2009. 
[18]K.S. Munasinghe and A. Jamalipour, “Interworked 
WiMAX-3G Cellular Data Networks: An 
Architecture for Mobility Management and 
Performance Evaluation,” IEEE Transactions on 
Wireless Communications, Vol. 8, No. 4, pp. 
1847-1853, Apr. 2009. 
[19] Q. Zhang and Y.Q. Zhang, “Cross-Layer Design for 
QoS Support in Multihop Wireless Networks,” 
Proceedings of the IEEE, Vol.96, No.1, pp.64-76, 
Jan. 2008. 
[20] B. Zamani, M. Mohammadi, A. Jalalvand, R. 
Fakouri and M. Fathy, “A Cross Model Approach to 
Support of QoS Parameters in Wireless Sensor 
network,” Proceedings of the International 
Conference on Computer and Electrical Engineering, 
pp. 41-45, Dec. 2008. 
[21] C. E. Huang and C. Leung, “Adaptive Cross Layer 
Scheduling with Flow Multiplexing,” Proceedings 
of the IEEE Wireless Communications and 
Networking Conference, pp. 1871-1876, Apr. 2008. 
[22] Y. Hu, “Cross Layer Dynamic Resource 
Management with Guaranteed QoS in MIMO 
OFDM Systems,” Proceedings of the International 
Conference on Wireless Communication, pp. 1-6, 
Oct. 2008. 
[23] C. Tian and D. Y “Cross Layer Opportunistic 
Scheduling for Multiclass Users in Cognitive Radio 
Networks,” Proceedings of the International 
Conference on Wireless Communication, pp. 1-4, 
Oct. 2008. 
[24] A. Morell, G. Seco-Granados and M. Á . 
Vázquez-Castro, “Cross-Layer Design of Dynamic 
Bandwidth Allocation in DVB-RCS,” IEEE System 
Journal, Vol. 2, No. 3, pp. 62-73, March 2008. 
[25] D. P Pezaros and L. Mathy, ”Explicit 
 第 24 頁 / 共 89 頁 
Knowledge Discovery and Data Mining, pp. 
208-211, Apr. 2010. 
[49] C. Xian-yi, L. Ying and Q. Jian-lin, “Cooperative 
Learning Based on Multi-Agent Systems,” 
Proceedings of the International Conference on 
Knowledge Discovery and Data Mining, pp. 
455-457, March 2010. 
[50] J. Yoon, K. Oh, C. Nam and D. Shin, “Agent-based 
Sensor Network Middleware using Reputation 
Mechanism over Heterogeneous Network 
Environments,” Proceedings of the International 
Conference on Computer and Automation 
Engineering (ICCAE), Vol. 2, pp. 373-376, April 
2010. 
[51] H. Al-Sammarraie, A. Merza, A. Shakeel and M. 
Adli, “Intelligent Agent System Architecture for 
Presenting Health Grid Contents from Complex 
Database,” Proceedings of the International 
Conference on Intelligent Systems, Modelling and 
Simulation (ISMS),pp. 38-42, Feb. 2010. 
[52] S. Arnon, D. Dov and S. Onn, “An 
Object-Process-Based Modeling Language for 
Multiagent Systems,” IEEE Transactions on Systems, 
Man, and Cybernetics, Part C: Applications and 
Reviews, Vol. 40, No. 2, pp. 227-241, Feb. 2010. 
[53] S. Liu, S. Wu and J.L. Chen, "Adaptive Cross-layer 
QoS Mechanism for Cognitive Network 
Applications," Proceedings of IEEE 12
th
 
International Conference on Advanced 
Communication Technology (ICACT), Vol. 2, pp. 
1389-1393, Feb. 2010. 
[54] R. Sunku, G.P. Rohan, M. Pande and D. Das, 
"Offline Charging for Multimedia Blended Services 
Using Service Capability Interaction Manager in 
IMS Network," Proceedings of the International 
Conference on Internet Multimedia Services 
Architecture and Application (IMSAA) , pp.1-6, 
March 2011. 
[55] A. Sarajlic and A. Sarajlic, "Definition, Analytical 
Derivation and Optimization of the Lower Credit 
Limit in Mobile User’s Prepaid Account for IMS 
Services," Proceedings of the International 
Conference on Information Technology Interfaces 
(ITI), pp.563-570, Aug. 2011. 
 
 第 26 頁 / 共 89 頁 
 
 /** 
      * this loads the necessary policies and 
invokes policy processor blocks based on priorities and 
trigger points 
 * and installs the created policy rule 
 * @param service information 
      */ 
 public int authorisation_request(String af_session, 
Vector ip_flows, Vector codecs) throws IOException  
 { 
  int result_code = -1; 
  /**Get policy profile information*/ 
  /**policy name; priority; trigger point*/ 
  Vector policy_vector = new Vector(); 
  for (int a = 0; a < policies.length; a++) 
  { 
   if(policies[a] != null) 
   { 
    String policy_info = policies[a] + 
";"; 
    String profile_loc = 
"/opt/OpenIMSCore/uctpcrf/policies/" + "profile_" + 
policies[a] + ".xml"; 
    //read policy profile information 
    Document doc = null; 
    DocumentBuilderFactory dbf = 
DocumentBuilderFactory.newInstance(); 
    try { 
      
     //Using factory get an 
instance of document builder 
     DocumentBuilder db = 
dbf.newDocumentBuilder(); 
      
     //parse using builder to get 
DOM representation of the XML file 
     doc = 
db.parse(profile_loc); 
      
   
   
 }catch(ParserConfigurationException pce) { 
     pce.printStackTrace(); 
    }catch(SAXException se) { 
     se.printStackTrace(); 
    }catch(IOException ioe) { 
     ioe.printStackTrace(); 
    }  
    Element docEle = 
doc.getDocumentElement(); 
    
    //get all policy information into 
vector format 
    NodeList nl = 
docEle.getElementsByTagName("priority"); 
    if(nl != null && nl.getLength() > 
0) { 
     Element priority = 
(Element)nl.item(0); 
     policy_info = policy_info 
+ priority.getFirstChild().getNodeValue().toString() + 
";"; 
    } 
  
    nl = 
docEle.getElementsByTagName("trigger_point"); 
    if(nl != null && nl.getLength() > 
0) { 
     Element trigger_point = 
(Element)nl.item(0); 
     NodeList nl1 = 
trigger_point.getElementsByTagName("media"); 
     if(nl1 != null && 
nl1.getLength() > 0) 
     { 
      Element media = 
(Element)nl1.item(0); 
 第 28 頁 / 共 89 頁 
    if(status == 
Constants.FlowStatus.ENABLED) 
    { 
     /**Send DIAMETER RAR 
remove message via Gx*/ 
     DiameterMessage rar = 
createRAR(session_id,dest_realm,PCC_rule_name,sourc
e_ip,dest_ip,source_port,dest_port,QoS_class,bw_ul,bw_
dl,guaranteed_br_ul,guaranteed_br_dl,1); //command - 1 
remove 
     System.out.println(); 
    
 System.out.println("-------------------------------------
-------------"); 
     System.out.println(); 
     System.out.println("INFO: 
Sending DIAMETER RAR message to PCEF"); 
     pcef_address = 
policyEngine.getPCEF(orig_realm,dest_realm); 
     DiameterMessage raa = 
diameterPeer.sendRequestBlocking(pcef_address,rar); 
     if (raa==null)  
     { 
     
 System.out.println("INFO: Time out waiting for 
PCEF RAA via Gx"); 
      result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
      return result_code; 
     } 
     else  
     { 
      System.out.println(); 
     
 System.out.println("INFO: Received DIAMETER 
RAA message from PCEF"); 
      if 
(raa.commandCode == Constants.Command.RAA) 
      {  
       AVP 
result_code_avp = 
raa.findAVP(Constants.AVPCode.RESULT_CODE,true, 
Constants.Vendor.DIAM); 
      
 if(result_code_avp != null) 
       { 
       
 result_code = result_code_avp.int_data; 
       
 if(result_code == 
Constants.ResultCode._DIAMETER_SUCCESS) 
        { 
        
 System.out.println("INFO: Result code SUCCESS 
received from PCEF"); 
        } 
        else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_INITIAL
_PARAMETERS) 
        { 
        
 System.out.println("INFO: Result code INVALID 
INITIAL PARAMETERS received from PCEF"); 
        
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        
 return result_code; 
        } 
        else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_TRIGGE
R_EVENT) 
        { 
        
 第 30 頁 / 共 89 頁 
      highest_priority_tag 
= a; 
     } 
     
    } 
    //policy with highest priority is 
policy_vector(a) 
    //create policy processor block 
for this policy 
    //pass info to this processor block 
and result code in return 
    //if result success enforce IP 
Flows 
    //then remove policy from policy 
vector 
    st = new 
StringTokenizer(policy_vector.get(highest_priority_tag).
toString(),";"); 
    String policy = st.nextToken(); 
    st.nextToken(); 
    String trigger_point = 
st.nextToken(); 
   
 if(policy.equals("domain_policies"))  
    { 
    
 if(trigger_point.equals("ANY")) 
     { 
     
 DomainPolicyProcessor dpp = new 
DomainPolicyProcessor(diameterPeer, policy_db, policy, 
username, password, remote_xcap_server); 
      result_code =  
dpp.authorisation_request(af_session, ip_flows, codecs); 
      
     } 
    } 
    
   
 policy_vector.removeElementAt(highest_priority_t
ag); 
 
    /**TO DO Add support to create 
dynamic Policy Processor Blocks*/ 
    //ADD new policy processor 
blocks here - remember to check the trigger points for 
each IP Flow which determine whether that policy 
should be called 
 
   } 
 
   /**To enforce ENABLED IP Flows in 
the bearer level*/ 
   if (result_code == 
Constants.ResultCode._DIAMETER_SUCCESS) 
   { 
    result_code = 
enforce_IP_Flows(ip_flows, orig_realm, dest_realm); 
   } 
   if (result_code == 
Constants.ResultCode._DIAMETER_SUCCESS) 
   { 
    System.out.println("\nINFO: The 
Request is Successful. The new session has ID : " + 
session_id); 
   } 
  } 
  return result_code; 
 } 
 
 /** 
      * This methods check through a session IP 
Flows and enforces those marked ENABLED in the 
bearer level 
 * @param ip_flows all IP Flows assocaited with 
IMS session 
 * @param orig_realm the realm or domain of the 
orginating user 
 第 32 頁 / 共 89 頁 
ATION; 
     return result_code; 
    } 
    else  
    { 
      
     if (raa.commandCode == 
Constants.Command.RAA) 
     {  
      System.out.println(); 
     
 System.out.println("INFO: Received DIAMETER 
RAA message from PCEF"); 
      AVP 
result_code_avp = 
raa.findAVP(Constants.AVPCode.RESULT_CODE,true, 
Constants.Vendor.DIAM); 
     
 if(result_code_avp != null) 
      { 
       result_code = 
result_code_avp.int_data; 
       if(result_code 
== Constants.ResultCode._DIAMETER_SUCCESS) 
       { 
       
 System.out.println("INFO: AAR Result code 
SUCCESS received from PCEF"); 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_INITIAL
_PARAMETERS) 
       { 
       
 System.out.println("INFO: AAR Result code 
INVALID INITIAL PARAMETERS received from 
PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_TRIGGE
R_EVENT) 
       { 
       
 System.out.println("INFO: Result code TRIGGER 
ERROR EVENT received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_PCC_RULE_EVE
NT) 
       { 
       
 System.out.println("INFO: Result code PCC 
RULE EVENT received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
       { 
       
 第 34 頁 / 共 89 頁 
       { 
       
 System.out.println("INFO: AAR Result code 
INVALID INITIAL PARAMETERS received from 
PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_TRIGGE
R_EVENT) 
       { 
       
 System.out.println("INFO: Result code TRIGGER 
ERROR EVENT received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_PCC_RULE_EVE
NT) 
       { 
       
 System.out.println("INFO: Result code PCC 
RULE EVENT received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
       { 
       
 System.out.println("INFO: Unknown Result Code 
received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
      } 
     } 
    } 
    System.out.println("INFO: IP 
Flow with flow id: " + flow_id + " is being removed 
from the bearer level"); 
   } 
   else 
   { 
    System.out.println("INFO: Flow 
status not yet recognised"); 
    result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
    return result_code; 
   }    
  } 
  if(result_code == 
Constants.ResultCode._DIAMETER_SUCCESS) 
  { 
   System.out.println("INFO: IP Flows 
associated with IMS session have been successfully 
processed"); 
  } 
 第 36 頁 / 共 89 頁 
  
    nl = 
docEle.getElementsByTagName("trigger_point"); 
    if(nl != null && nl.getLength() > 
0) { 
     Element trigger_point = 
(Element)nl.item(0); 
     NodeList nl1 = 
trigger_point.getElementsByTagName("media"); 
     if(nl1 != null && 
nl1.getLength() > 0) 
     { 
      Element media = 
(Element)nl1.item(0); 
      policy_info = 
policy_info + 
media.getFirstChild().getNodeValue().toString(); 
     } 
    } 
    policy_vector.add(policy_info); 
   } 
  } 
 
 
  //remove IP flows from bearer level 
  Vector current_ip_flows  = 
policyEngine.getIPFlows(session_id); 
  for (int b = 0; b < current_ip_flows.size(); 
b++) 
  { 
   int avail_QoS_ul = 0; 
   int avail_QoS_dl = 0; 
   st = new 
StringTokenizer(current_ip_flows.get(b).toString(),";"); 
   session_id = st.nextToken(); 
   session_id = session_id + ";" + 
st.nextToken(); 
   session_id =  session_id + ";" + 
st.nextToken(); 
   String flow_id = st.nextToken(); 
   String source_ip = st.nextToken(); 
   String dest_ip = st.nextToken(); 
   int dest_port = 
Integer.valueOf(st.nextToken()).intValue(); 
   int source_port = 
Integer.valueOf(st.nextToken()).intValue(); 
   int usage = 
Integer.valueOf(st.nextToken()).intValue(); 
   int status = 
Integer.valueOf(st.nextToken()).intValue(); 
   int bw_ul = 
Integer.valueOf(st.nextToken()).intValue(); 
   int bw_dl = 
Integer.valueOf(st.nextToken()).intValue(); 
   int QoS_class = 
Integer.valueOf(st.nextToken()).intValue(); 
   int guaranteed_br_ul = bw_ul; 
 //defaults to same as max 
   int guaranteed_br_dl = bw_dl;
 //defaults to same as max 
   String PCC_rule_name = session_id + 
";" + flow_id; 
      
   String pcef_address = ""; 
   /**Only send DIAMETER RAR 
remove message if flow is already enabled*/ 
 
   if(status == 
Constants.FlowStatus.ENABLED) 
   { 
    /**Send DIAMETER RAR 
remove message via Gx*/ 
    DiameterMessage rar = 
createRAR(session_id,dest_realm,PCC_rule_name,sourc
e_ip,dest_ip,source_port,dest_port,QoS_class,bw_ul,bw_
dl,guaranteed_br_ul,guaranteed_br_dl,1); //command - 1 
remove 
    System.out.println(); 
 第 38 頁 / 共 89 頁 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_ERROR_TRIGGE
R_EVENT) 
       { 
       
 System.out.println("INFO: Result code TRIGGER 
ERROR EVENT received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
if(result_code == 
Constants.ResultCode._DIAMETER_PCC_RULE_EVE
NT) 
       { 
       
 System.out.println("INFO: Result code PCC 
RULE EVENT received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
       else 
       { 
       
 System.out.println("INFO: Unknown Result Code 
received from PCEF"); 
       
 result_code = 
Constants.ResultCode._INVALID_SERVICE_INFORM
ATION; 
        return 
result_code; 
       } 
      } 
     } 
    } 
    System.out.println("INFO: IP 
Flow with flow id: " + flow_id + " is being removed 
from the bearer level"); 
   } 
  } 
  if(result_code == 
Constants.ResultCode._DIAMETER_SUCCESS) 
  { 
 
   //invoke policies according to priority 
and trigger points 
   
   //find highest priority and invoke - then 
remove policy and find next highest priority policy - 
continue until all policies invoked 
   while(policy_vector.size()>0) 
   { 
    int highest_priority = 100; 
    int highest_priority_tag = -1; 
    for (int a = 0; a < 
policy_vector.size(); a++) 
    { 
     st = new 
StringTokenizer(policy_vector.get(a).toString(),";"); 
     st.nextToken(); 
     int priority = 
Integer.valueOf(st.nextToken()).intValue(); 
     if(priority < 
highest_priority) 
     { 
      highest_priority = 
priority; 
 第 40 頁 / 共 89 頁 
   
  /**add Auth Application id */ 
                AVP auth_application_id_avp = new 
AVP(Constants.AVPCode.AUTH_APPLICATION_ID, 
true,  Constants.Vendor.DIAM); 
                
auth_application_id_avp.setData(Constants.Application.
GX); 
                
rar.addAVP(auth_application_id_avp); 
   
  /**add destination-realm*/ 
   AVP destination_realm_avp = new 
AVP(AVP.Destination_Realm,true,Constants.Vendor.DI
AM); 
 
 destination_realm_avp.setData(destination_realm); 
  rar.addAVP(destination_realm_avp); 
   
 
  if(command == 1) 
  { 
   /**add PCC Rule remove*/ 
   AVP charging_rule_remove_avp = 
new 
AVP(Constants.AVPCode.CHARGING_RULE_REMO
VE,true,Constants.Vendor.V3GPP); 
   /*Charging rule definition*/ 
   AVP charging_rule_definition_avp = 
new 
AVP(Constants.AVPCode.CHARGING_RULE_DEFIN
ITION,true,Constants.Vendor.V3GPP); 
    /*Flow description1*/ 
    AVP flow_description_avp = 
new 
AVP(Constants.AVPCode.FLOW_DESCRIPTION,true,
Constants.Vendor.V3GPP); 
    String flow = "permit out ip from 
" + source_ip + " to " + dest_ip + " " + dest_port; 
   
 flow_description_avp.setData(flow); 
   
 charging_rule_definition_avp.addChildAVP(flow_
description_avp); 
    /*Flow description2*/ 
    flow_description_avp = new 
AVP(Constants.AVPCode.FLOW_DESCRIPTION,true,
Constants.Vendor.V3GPP); 
    flow = "permit in ip from " + 
dest_ip + " to " + source_ip + " " + source_port; 
   
 flow_description_avp.setData(flow); 
   
 charging_rule_definition_avp.addChildAVP(flow_
description_avp); 
  
 charging_rule_remove_avp.addChildAVP(chargin
g_rule_definition_avp); 
   /*Charging rule name*/ 
   AVP charging_rule_name_avp = new 
AVP(Constants.AVPCode.CHARGING_RULE_NAME,
true,Constants.Vendor.V3GPP); 
  
 charging_rule_name_avp.setData(PCC_rule_name
); 
  
 charging_rule_remove_avp.addChildAVP(chargin
g_rule_name_avp); 
  
 rar.addAVP(charging_rule_remove_avp); 
  } 
  else if (command == 2) 
  { 
   /**add PCC Rule install*/ 
   AVP charging_rule_install_avp = new 
AVP(Constants.AVPCode.CHARGING_RULE_INSTA
LL,true,Constants.Vendor.V3GPP); 
   /*Charging rule definition*/ 
 第 42 頁 / 共 89 頁 
new 
AVP(Constants.AVPCode.MAX_REQUESTED_BAND
WIDTH_DL,true,Constants.Vendor.V3GPP); 
 
 max_requested_bandwidth_dl_avp.setData(max_b
w_dl); 
 
 authorised_qos_avp.addChildAVP(max_requested
_bandwidth_dl_avp);  
  /*Guaranteed bitrate uplink*/ 
  AVP guaranteed_bitrate_ul_avp = new 
AVP(Constants.AVPCode.GUARANTEED_BITRATE_
UL,true,Constants.Vendor.V3GPP); 
 
 guaranteed_bitrate_ul_avp.setData(guaranteed_br_
ul); 
 
 authorised_qos_avp.addChildAVP(guaranteed_bitr
ate_ul_avp); 
  /*Guaranteed bitrate downlink*/ 
  AVP guaranteed_bitrate_dl_avp = new 
AVP(Constants.AVPCode.GUARANTEED_BITRATE_
DL,true,Constants.Vendor.V3GPP); 
 
 guaranteed_bitrate_dl_avp.setData(guaranteed_br_
dl); 
 
 authorised_qos_avp.addChildAVP(guaranteed_bitr
ate_dl_avp); 
  rar.addAVP(authorised_qos_avp); 
    
  return rar; 
 } 
} 
 
2. DomainPolicyProcessor.java 
 
package pcrf; 
 
import java.io.*; 
import java.net.*; 
import java.util.*; 
 
import de.fhg.fokus.Constants; 
 
import de.fhg.fokus.diameter.DiameterPeer.data.AVP; 
import 
de.fhg.fokus.diameter.DiameterPeer.data.DiameterMessa
ge; 
import 
de.fhg.fokus.diameter.DiameterPeer.transaction.Transact
ionListener; 
import 
de.fhg.fokus.diameter.DiameterPeer.DiameterPeer; 
 
 
 
/** 
 * DomainPolicyProcessor: 
 *  
 * This class implements Session Admission and policy 
rule creation for Domain Policies 
 */ 
 
 
public class DomainPolicyProcessor 
{ 
 DiameterPeer diameterPeer; 
 xcap policyEngine = null; 
  
         
 /** Decision Engine constructor intialises 
variables*/ 
 public DomainPolicyProcessor(DiameterPeer 
diameterPeer, String policy_db, String policy, String 
username, String password, int remote_xcap_server) 
throws IOException 
 { 
 第 44 頁 / 共 89 頁 
" + session_id + " does not exist"); 
   result_code = newSession(af_session, 
ip_flows, codecs); 
  } 
  return result_code; 
  
 } 
 
 /** 
      * This checks if a new session is authorised 
and if so stores the relevant data in the policy repository 
 * @param af_session session information 
 * @param ip_flows associated ip flow information 
 * @param codecs requested codecs  
 */ 
 private int newSession(String af_session, Vector 
ip_flows, Vector codecs) throws IOException  
 { 
   
  int result_code = -1; 
 
  /**session id; originating realm; destination 
realm; source ip; dest ip*/ 
  //extract session information 
  StringTokenizer st = new 
StringTokenizer(af_session,";"); 
  String session_id = st.nextToken(); 
  session_id = session_id + ";" + 
st.nextToken(); 
  session_id = session_id + ";" + 
st.nextToken(); 
  String orig_realm = st.nextToken(); 
  String dest_realm = st.nextToken(); 
  String source_ip = ""; 
  String dest_ip = ""; 
 
  int total_req_bw_ul = 0; 
  int total_req_bw_dl = 0;   
 
  int avail_qos_bw_ul = 0; 
  int avail_qos_bw_dl = 0; 
 
  
  /**Check that the requested QoS classes can 
handle the bandwidth requirements for each IP Flow*/ 
   
  for (int a = 0; a < ip_flows.size(); a++) 
  { 
   st = new 
StringTokenizer(ip_flows.get(a).toString(),";"); 
   int req_bw_ul = 0; 
   int req_bw_dl = 0; 
   int QoS_class = -1; 
    
   int i = 0; 
   String temp = ""; 
   for (i = 0 ;i < 10 ;i++) 
   { 
    temp = st.nextToken(); 
   } 
   req_bw_ul = 
Integer.valueOf(st.nextToken()).intValue(); 
   req_bw_dl = 
Integer.valueOf(st.nextToken()).intValue(); 
   QoS_class = 
Integer.valueOf(st.nextToken()).intValue(); 
 
   total_req_bw_ul = total_req_bw_ul + 
req_bw_ul; 
   total_req_bw_dl = total_req_bw_dl + 
req_bw_dl;     
 
 
  
 if(policyEngine.checkQoSBW(QoS_class, 
req_bw_ul, req_bw_dl) == 0) 
   { 
    System.out.println("\nINFO: " + 
 第 46 頁 / 共 89 頁 
w_ul,req_bw_dl); 
  } 
 
  /**edit Domain remaining UL and DL 
bandwidth*/ 
   
  //if orig and dest realm are the same 
  if(orig_realm.equalsIgnoreCase(dest_realm)) 
  { 
  
 policyEngine.reqDomainBandwidth(orig_realm,tot
al_req_bw_ul,total_req_bw_dl);   
  } 
  //if orig and dest realm are different 
  else 
  { 
    
  
 policyEngine.reqDomainBandwidth(orig_realm,tot
al_req_bw_ul,total_req_bw_dl); 
  
 policyEngine.reqDomainBandwidth(dest_realm,tot
al_req_bw_ul,total_req_bw_dl); 
  } 
   
  result_code = 
Constants.ResultCode._DIAMETER_SUCCESS;  
  return result_code; 
 } 
 
 /** 
      * This checks if a previous sessions 
modifications are authorised and if so stores the relevant 
data in the policy repository 
 * @param service information 
      */ 
  
 public int modSession(String af_session, Vector 
ip_flows, Vector codecs) throws IOException  
 { 
   
  int result_code = -1; 
  
  /**session id; originating realm; destination 
realm; source ip; dest ip*/ 
  //extract session information 
  StringTokenizer st = new 
StringTokenizer(af_session,";"); 
  String session_id = st.nextToken(); 
  session_id = session_id + ";" + 
st.nextToken(); 
  session_id =  session_id + ";" + 
st.nextToken(); 
  String orig_realm = st.nextToken(); 
  String dest_realm = st.nextToken(); 
  String source_ip = ""; 
  String dest_ip = ""; 
 
  int total_req_bw_ul = 0; 
  int total_req_bw_dl = 0;   
 
  int avail_qos_bw_ul = 0; 
  int avail_qos_bw_dl = 0; 
 
  /**Check that the requested QoS classes can 
handle the bandwidth requirements for each IP Flow*/ 
 
  for (int a = 0; a < ip_flows.size(); a++) 
  { 
   st = new 
StringTokenizer(ip_flows.get(a).toString(),";"); 
   int req_bw_ul = 0; 
   int req_bw_dl = 0; 
   int QoS_class = -1; 
    
   int i = 0; 
   String temp = ""; 
   for (i = 0 ;i < 10 ;i++) 
 第 48 頁 / 共 89 頁 
  /**edit QoS_classes remaining UL and DL 
bandwidth*/ 
  for ( int b = 0; b < ip_flows.size(); b++) 
  {    
   st = new 
StringTokenizer(ip_flows.get(b).toString(),";"); 
   int req_bw_ul = 0; 
   int req_bw_dl = 0; 
   int QoS_class = -1; 
   int i = 0; 
   String temp = ""; 
   for (i = 0 ;i < 10;i++) 
   { 
    temp = st.nextToken(); 
   } 
   req_bw_ul = 
Integer.valueOf(st.nextToken()).intValue(); 
   req_bw_dl = 
Integer.valueOf(st.nextToken()).intValue(); 
   QoS_class = 
Integer.valueOf(st.nextToken()).intValue(); 
  
 policyEngine.reqQoSBandwidth(QoS_class,req_b
w_ul,req_bw_dl); 
  } 
 
  /**edit Domain remaining UL and DL 
bandwidth*/ 
   
  //if orig and dest realm are the same 
  if(orig_realm.equalsIgnoreCase(dest_realm)) 
  { 
  
 policyEngine.reqDomainBandwidth(orig_realm,tot
al_req_bw_ul,total_req_bw_dl); 
  } 
  //if orig and dest realm are different 
  else 
  { 
  
 policyEngine.reqDomainBandwidth(orig_realm,tot
al_req_bw_ul,total_req_bw_dl); 
  
 policyEngine.reqDomainBandwidth(dest_realm,tot
al_req_bw_ul,total_req_bw_dl); 
  } 
  
  result_code = 
Constants.ResultCode._DIAMETER_SUCCESS; 
  return result_code; 
 } 
 
 
/** 
      * This terminates an existing session 
 * - Updates information in the policy 
repository 
 * @param af_session session information 
      */ 
 public int termination_request(String af_session)  
throws IOException 
 { 
  int result_code = -1; 
  StringTokenizer st = new 
StringTokenizer(af_session,";"); 
  String session_id = st.nextToken(); 
  session_id = session_id + ";" + 
st.nextToken(); 
  session_id =  session_id + ";" + 
st.nextToken(); 
  String orig_realm = st.nextToken(); 
  String dest_realm = st.nextToken(); 
   
  int total_bw_ul = 0; 
  int total_bw_dl = 0; 
   
  /**Check that session exists*/ 
  if(policyEngine.sessionExists(session_id) == 
 第 50 頁 / 共 89 頁 
  else 
  { 
    
  
 policyEngine.freeDomainBandwidth(orig_realm,to
tal_bw_ul,total_bw_dl); 
  
 policyEngine.freeDomainBandwidth(dest_realm,to
tal_bw_ul,total_bw_dl); 
  } 
  /**remove all information from af_session*/ 
  policyEngine.deleteSession(session_id); 
  /**remove all associated ip flows*/ 
  policyEngine.deleteIPFlow(session_id); 
 
  result_code = 
Constants.ResultCode._DIAMETER_SUCCESS; 
  return result_code; 
 }  
} 
 
 
3. PCEF.java 
 
package pcrf; 
 
import java.net.Socket; 
import java.net.*; 
import java.util.*; 
import java.io.*; 
 
import de.fhg.fokus.pcef_diam.pcefDiameterStack; 
import 
de.fhg.fokus.diameter.DiameterPeer.DiameterPeer; 
 
/** 
 * PCEF: 
 *  
 * This is the main class for starting the PCEF 
 *   - It initialises the Diameter stack and accepts 
connections from PCRFs 
 *  - Implements the state machine that defines 
the PCEF behaviour 
 * @author Richard Good 
 */ 
public class PCEF 
{ 
 
 pcefDiameterStack diameterStack; 
 DiameterPeer diameterPeer; 
 String pcrfAddress; 
 String pcefID=null; 
 LinuxRouter linux_router; 
 static String policy_db = ""; 
 static String[] policies = new String[10]; //max 
num policies 10  
 static String username = ""; 
 static String password = ""; 
 xcap policyEngine = null; 
 static int remote_xcap_server; //one if remote zero 
if local 
 static String diffserv_interface=""; 
 static int data_counter; //1 enabled 0 disabled 
  
 /** 
 * The main method 
 * @param args 
 */ 
 public static void main(String[] args) throws 
IOException  
 { 
  getPreferences(); 
  String pcefID = "1"; 
     
  //FOR TESTING PURPOSES ASSUME 
PCEF ID 1 
  //System.out.print("Enter PCEF Name : "); 
  //pcefID = in.readLine(); 
 第 52 頁 / 共 89 頁 
pcef.properties**/ 
 private static void getPreferences() throws 
IOException 
 { 
  StringBuffer fileData = new 
StringBuffer(1000); 
          
   
  try 
  { 
   BufferedReader reader = new 
BufferedReader(new 
FileReader("/opt/OpenIMSCore/uctpcrf/config/pcef.prop
erties")); 
    
   char[] buf = new char[1024]; 
   int numRead=0; 
   while((numRead=reader.read(buf)) != 
-1){ 
    String readData = 
String.valueOf(buf, 0, numRead); 
    fileData.append(readData); 
    buf = new char[1024]; 
   } 
   reader.close(); 
   String fileStr =  fileData.toString(); 
   StringTokenizer st = new 
StringTokenizer(fileStr, "\n"); 
    
   String policy_db_line = 
st.nextToken(); 
   StringTokenizer st1 = new 
StringTokenizer(policy_db_line, "="); 
   st1.nextToken(); 
   StringTokenizer st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
   policy_db = st2.nextToken(); 
   String policies_line = ""; 
   int pol = 0; 
   while(pol != -1) 
   { 
    policies_line = st.nextToken(); 
    st1 = new 
StringTokenizer(policies_line, "="); 
   
 if(st1.nextToken().equals("policies")) 
    { 
     st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
     policies[pol] = 
st2.nextToken(); 
     pol++; 
    } 
    else 
    { 
     pol = -1; 
    } 
   } 
 
   String username_line = policies_line; 
   st1 = new 
StringTokenizer(username_line, "="); 
   st1.nextToken(); 
   st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
   username = st2.nextToken(); 
    
   String password_line = st.nextToken(); 
   st1 = new 
StringTokenizer(password_line, "="); 
   st1.nextToken(); 
   st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
   password = st2.nextToken(); 
  
   String remote_xcap_server_line = 
st.nextToken(); 
   st1 = new 
 第 54 頁 / 共 89 頁 
 * This is the main class for starting the Policy Control 
and Charging Function 
 *   - It initialises the Diameter stack and 
connects to P-CSCFs 
 *   - It initialises the Diameter stack and 
connects to PEPs 
  - It downloads necessary policies from an 
XCAP 
 *  - Implements the state machine that defines 
the PCRF behaviour 
 * @author Richard Good 
 */ 
public class PCRF  
{ 
 
 pcrfDiameterStack diameterStack; 
 DiameterPeer diameterPeer; 
 static int remote_xcap_server; //one if remote zero 
if local 
 static String policy_db = ""; 
 static String[] policies = new String[10]; //max 
num policies 10  
 static String username = ""; 
 static String password = ""; 
 xcap policyEngine = null; 
   
  
 /** 
 * The main method 
 * @param args 
 */ 
 public static void main(String[] args) throws 
IOException  
 { 
 
  //retrieves configuration information from 
config files 
  getPreferences(); 
 
  try  
  { 
   PCRF pcrf = new PCRF(); 
   pcrf.run(); 
    
  }  
  catch (Exception e) 
  { 
   e.printStackTrace(); 
  } 
 } 
 
  /** 
 * Constructor for PCRF 
 *  -initialises variables 
 *  -Ensures that there are PCEFs listed in the 
repository to control 
 * @param args 
 */ 
 public PCRF() throws RemoteException, 
IOException 
 { 
 
  diameterPeer = new 
DiameterPeer("config/DiameterPeerPCRF.xml"); 
  policyEngine = new xcap (policy_db, 
"domain_policies", username, password, 
remote_xcap_server); 
 } 
  
 /** 
 * This defines the behavour of the PCRF 
 *  -It starts the PCRF  
 * -Starts the diameter stack and connects to the 
P-CSCF 
 * -Starts the dimater stack and connects to all 
listed PCEFs 
 */ 
 public void run() throws IOException 
 第 56 頁 / 共 89 頁 
String.valueOf(buf, 0, numRead); 
    fileData.append(readData); 
    buf = new char[1024]; 
   } 
   reader.close(); 
   String fileStr =  fileData.toString(); 
   StringTokenizer st = new 
StringTokenizer(fileStr, "\n"); 
    
   String policy_db_line = 
st.nextToken(); 
   StringTokenizer st1 = new 
StringTokenizer(policy_db_line, "="); 
   st1.nextToken(); 
   StringTokenizer st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
   policy_db = st2.nextToken(); 
 
   int pol = 0; 
   String policies_line = ""; 
   while(pol != -1) 
   { 
    policies_line = st.nextToken(); 
    st1 = new 
StringTokenizer(policies_line, "="); 
   
 if(st1.nextToken().equals("policies")) 
    { 
     st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
     policies[pol] = 
st2.nextToken(); 
     pol++; 
    } 
    else 
    { 
     pol = -1; 
    } 
   } 
    
   String username_line = policies_line; 
   st1 = new 
StringTokenizer(username_line, "="); 
   st1.nextToken(); 
   st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
   username = st2.nextToken(); 
    
   String password_line = st.nextToken(); 
   st1 = new 
StringTokenizer(password_line, "="); 
   st1.nextToken(); 
   st2 = new 
StringTokenizer(st1.nextToken(), "\""); 
   password = st2.nextToken(); 
  
   String remote_xcap_server_line = 
st.nextToken(); 
   st1 = new 
StringTokenizer(remote_xcap_server_line, "="); 
   st1.nextToken(); 
   remote_xcap_server = 
Integer.valueOf(st1.nextToken()).intValue(); 
  } 
  catch(FileNotFoundException e) 
  { 
   System.out.println("Preferences file 
not found"); 
  } 
 } 
 
 /** 
  * This method waits until exit is typed in the 
console 
  * If wait is typed, then it returns. 
  */ 
 private static void waitForExit() { 
  byte[] buffer = new byte[80];  
 第 58 頁 / 共 89 頁 
 
 /** 
 * Constructor for xcap 
 *  -initialises variables 
 * @param args 
 */ 
 public xcap(String policy_db, String policy, String 
username, String password, int remote_xcap_server) 
throws IOException 
 { 
  
  this.username = username; 
  this.password = password; 
  this.remote_xcap_server = 
remote_xcap_server; 
  /**TO DO fix OpenXCAP to allow different 
Applications*/ 
  if(remote_xcap_server == 1) 
  { 
   this.policy_db = policy_db + 
"resource-lists/users/" + username + "/resource-lists.xml";
  
  } 
  else 
  { 
   this.policy_db = policy_db + policy + 
".xml"; 
  } 
  parseXML(getXML()); 
 } 
 
 /**  
 * This converts an XML Document into a String 
used to convey the doc via HTTP 
 * @param dom The XML document to be 
converted to a string 
 * @return xmlStr the String representation of the 
xml doc 
 **/ 
 private String XMLDocToString(Document dom) 
 { 
  String xmlStr = null; 
  StringWriter strWriter = null; 
  XMLSerializer probeMsgSerializer = null; 
  OutputFormat outFormat = new 
OutputFormat(); 
   
  try 
  { 
   probeMsgSerializer = new 
XMLSerializer();  
   strWriter = new StringWriter(); 
   outFormat = new OutputFormat(); 
   
   // Setup format settings 
   outFormat.setVersion("1.0"); 
   outFormat.setEncoding("UTF-8"); 
   outFormat.setIndenting(true); 
   outFormat.setIndent(4); 
   
   // Define a Writer 
  
 probeMsgSerializer.setOutputCharStream(strWrite
r); 
   
   // Apply the format settings 
  
 probeMsgSerializer.setOutputFormat(outFormat); 
   
   // Serialize XML Document  
  
   probeMsgSerializer.serialize(dom); 
   xmlStr = strWriter.toString(); 
   strWriter.close(); 
   
  } 
  catch (IOException ioEx) 
  { 
 第 60 頁 / 共 89 頁 
conditions.getElementsByTagName("codec_id"); 
      if(nl1 != null && 
nl1.getLength() > 0) 
      {  
       Element 
codec_id = (Element)nl1.item(0); 
       NodeList nl2 = 
codec_id.getElementsByTagName("id");  
       if(nl2 != null 
&& nl2.getLength() > 0)  
       { 
        for(int a 
= 0 ; a < nl2.getLength();a++) 
        { 
        
 Element ID = (Element)nl2.item(a); 
        
 authCodecs.add(ID.getFirstChild().getNodeValue(
)); 
        }  
       } 
      } 
     } 
    } 
   } 
  } 
    
  //check that all requested codecs are 
authorised 
  int authorised = 1; 
  int supported = 0; 
  for ( int b = 0; b < codecs.size(); b++) 
  { 
   supported = 0; 
   for (int c = 0; c < authCodecs.size(); 
c++) 
   {  
   
 if(Integer.valueOf(codecs.get(b).toString()).intVal
ue() == 
Integer.valueOf(authCodecs.get(c).toString()).intValue()
) 
    { 
     supported = 1; 
    } 
   } 
   //Note this is to support dynamic 
codecs, see RFC 3551 
   if (supported == 0 && 
(Integer.valueOf(codecs.get(b).toString()).intValue() < 
96 || Integer.valueOf(codecs.get(b).toString()).intValue() 
> 127)) 
   { 
     authorised = 0; 
   } 
 
  } 
  //1 if authorised 0 if not 
  return authorised; 
 } 
 
 
 /** 
      * This receives the orig and term domains 
 * It checks that both domains are allowed 
 * @param String orig originating domain 
 * @param String term terminating domain 
 * @return 1 if authorised 0 if not   
 */ 
 public int checkDomain(String orig, String term) 
throws IOException 
 { 
  //fetch and parse the policy XML document 
  parseXML(getXML()); 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
 第 62 頁 / 共 89 頁 
 } 
  
 /** 
      * This checks if a session with given session 
id already exists 
 * @param String session_id the Session to check 
 * @return 1 if exists 0 if it does not   
 */ 
 public int sessionExists(String session_id) throws 
IOException 
 { 
  int session_exists = 0; 
  //fetch and parse the policy XML document 
  parseXML(getXML()); 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
  NodeList nl = 
docEle.getElementsByTagName("tris"); 
  if(nl != null && nl.getLength() > 0) { 
   //get the tris element 
   Element tris = (Element)nl.item(0); 
   NodeList nl1 = 
tris.getElementsByTagName("af_session"); 
   if(nl1 != null && nl1.getLength() > 0)  
   { 
    for(int i = 0 ; i < 
nl1.getLength();i++)  
    { 
     Element af_session = 
(Element)nl1.item(i); 
     NodeList nl2 = 
af_session.getElementsByTagName("session_id"); 
     if(nl2 != null && 
nl2.getLength() > 0)  
     { 
      Element  
Session_ID = (Element)nl2.item(0); 
     
 if(Session_ID.hasChildNodes() && 
session_id.equals(Session_ID.getFirstChild().getNodeVa
lue().toString())) 
      { 
       session_exists 
= 1; 
      } 
     } 
    } 
   } 
  } 
  return session_exists; 
 }  
  
 /** 
      * This checks if the specified QoS class can 
handle a given bandwidth (ul and dl) 
 * @param int QoS_class the QoS class that is too 
be checked 
 * @param int bw_ul the requested uplink 
bandwidth 
 * @param int bw_dl the requested downlink 
bandwidth 
 * @return 1 if authorised 0 if not   
 */ 
 public int checkQoSBW(int QoS_class, int bw_ul, 
int bw_dl) throws IOException 
 { 
   
  int authbw_ul = 0; 
  int authbw_dl = 0; 
  parseXML(getXML()); 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
   
  NodeList nl = 
docEle.getElementsByTagName("rule"); 
 第 64 頁 / 共 89 頁 
 
   
 /** 
      * This checks if the specified domain can 
handle a given bandwidth (ul and dl) 
 * @param String domain the Domain in question 
 * @param int bw_ul the requested uplink 
bandwidth 
 * @param int bw_dl the requested downlink 
bandwidth 
 * @return 1 if authorised 0 if not   
 */ 
 public int checkDomainBW(String domain, int 
bw_ul, int bw_dl) throws IOException 
 { 
   
  int authbw_ul = 0; 
  int authbw_dl = 0; 
  parseXML(getXML()); 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
  NodeList nl = 
docEle.getElementsByTagName("rule"); 
  if(nl != null && nl.getLength() > 0) { 
   for(int i = 0 ; i < nl.getLength();i++) { 
     
    //get the authorised codec rule 
    Element rule = 
(Element)nl.item(i); 
    String id = 
rule.getAttribute("id"); 
    if(id.equals("domain 
authorisation")) 
    { 
     NodeList nl3 = 
rule.getElementsByTagName("conditions"); 
     if(nl3 != null && 
nl3.getLength() > 0) 
     {  
      Element conditions = 
(Element)nl3.item(0); 
      NodeList nl1 = 
conditions.getElementsByTagName("domain"); 
      if(nl1 != null && 
nl1.getLength() > 0) 
      {  
       Element 
Domain = (Element)nl1.item(0); 
       NodeList nl2 = 
Domain.getElementsByTagName("address");  
       if(nl2 != null 
&& nl2.getLength() > 0)  
       { 
        for(int a 
= 0 ; a < nl2.getLength();a++) 
        { 
        
 Element address = (Element)nl2.item(a); 
        
 if(domain.equals(address.getFirstChild().getNode
Value())) 
         { 
         
 if(bw_dl < 
(Integer.valueOf(address.getAttribute("bw_downlink"))).
intValue()) 
         
 { 
         
  authbw_dl = 1; 
         
 } 
         
 if(bw_ul < 
(Integer.valueOf(address.getAttribute("bw_uplink"))).int
Value()) 
 第 66 頁 / 共 89 頁 
    { 
     Element Session_ID = 
(Element)nl2.item(0); 
    
 if(!Session_ID.hasChildNodes()) 
     { 
     
 Session_ID.appendChild(dom.createTextNode(ses
sion_id)); 
      nl2= 
af_session.getElementsByTagName("orig_domain"); 
      if(nl2 != null && 
nl2.getLength() > 0)  
      { 
       Element 
Orig_Domain = (Element)nl2.item(0); 
      
 Orig_Domain.appendChild(dom.createTextNode(o
rig_domain)); 
      } 
      nl2 = 
af_session.getElementsByTagName("term_domain"); 
      if(nl2 != null && 
nl2.getLength() > 0)  
      { 
       Element 
Term_Domain = (Element)nl2.item(0); 
      
 Term_Domain.appendChild(dom.createTextNode(t
erm_domain)); 
      } 
      nl2 = 
af_session.getElementsByTagName("codecs"); 
      if(nl2 != null && 
nl2.getLength() > 0)  
      { 
       Element 
Codecs = (Element)nl2.item(0); 
      
 Codecs.appendChild(dom.createTextNode(codec_l
ist)); 
      } 
     } 
     else 
     { 
      Element 
AF_Session1 = dom.createElement("af_session"); 
      Element 
Session_ID1 = dom.createElement("session_id"); 
     
 Session_ID1.appendChild(dom.createTextNode(se
ssion_id)); 
     
 AF_Session1.appendChild(Session_ID1); 
      Element 
Orig_Domain = dom.createElement("orig_domain"); 
     
 Orig_Domain.appendChild(dom.createTextNode(o
rig_domain)); 
     
 AF_Session1.appendChild(Orig_Domain); 
      Element 
Term_Domain = dom.createElement("term_domain"); 
     
 Term_Domain.appendChild(dom.createTextNode(t
erm_domain)); 
     
 AF_Session1.appendChild(Term_Domain); 
      Element Codecs = 
dom.createElement("codecs"); 
     
 Codecs.appendChild(dom.createTextNode(codec_l
ist)); 
     
 AF_Session1.appendChild(Codecs); 
     
 tris.appendChild(AF_Session1); 
     
 第 68 頁 / 共 89 頁 
docEle.getElementsByTagName("tris"); 
   if(nl0 != null && nl0.getLength() > 0)  
   { 
    Element tris = 
(Element)nl0.item(0); 
    //get a nodelist of <IP Flow> 
elements 
    NodeList nl = 
tris.getElementsByTagName("ip_flow"); 
    if(nl != null && nl.getLength() > 
0)  
    { 
     Element IP_Flow = 
(Element)nl.item(0); 
     NodeList nl1 = 
IP_Flow.getElementsByTagName("session_id"); 
     if(nl1 != null && 
nl1.getLength() > 0)  
     { 
      Element Session_ID 
= (Element)nl1.item(0); 
     
 if(!Session_ID.hasChildNodes()) 
      { 
      
 Session_ID.appendChild(dom.createTextNode(ses
sion_id)); 
       nl1 = 
IP_Flow.getElementsByTagName("flow_id"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
Flow_ID = (Element)nl1.item(0); 
       
 Flow_ID.appendChild(dom.createTextNode(flow_
id)); 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("source_ip"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
Source_IP = (Element)nl1.item(0); 
       
 Source_IP.appendChild(dom.createTextNode(sour
ce_ip)); 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("dest_ip"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
Dest_IP = (Element)nl1.item(0); 
       
 Dest_IP.appendChild(dom.createTextNode(dest_ip
)); 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("source_port"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
Source_Port = (Element)nl1.item(0); 
       
 Source_Port.appendChild(dom.createTextNode(so
urce_port)); 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("dest_port"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
Dest_Port = (Element)nl1.item(0); 
 第 70 頁 / 共 89 頁 
       Element 
Source_IP = dom.createElement("source_ip"); 
      
 Source_IP.appendChild(dom.createTextNode(sour
ce_ip)); 
      
 IP_Flow1.appendChild(Source_IP); 
       Element 
Dest_IP = dom.createElement("dest_ip"); 
      
 Dest_IP.appendChild(dom.createTextNode(dest_ip
)); 
      
 IP_Flow1.appendChild(Dest_IP); 
       Element 
Source_Port = dom.createElement("source_port"); 
      
 Source_Port.appendChild(dom.createTextNode(so
urce_port)); 
      
 IP_Flow1.appendChild(Source_Port); 
       Element 
Dest_Port = dom.createElement("dest_port"); 
      
 Dest_Port.appendChild(dom.createTextNode(dest_
port)); 
      
 IP_Flow1.appendChild(Dest_Port); 
       Element 
Flow_Usage = dom.createElement("flow_usage"); 
      
 Flow_Usage.appendChild(dom.createTextNode(us
age)); 
      
 IP_Flow1.appendChild(Flow_Usage); 
       Element 
Flow_Status = dom.createElement("flow_status"); 
      
 Flow_Status.appendChild(dom.createTextNode(sta
tus)); 
      
 IP_Flow1.appendChild(Flow_Status); 
       Element 
BW_Uplink = dom.createElement("bw_uplink"); 
      
 BW_Uplink.appendChild(dom.createTextNode(bw
_ul)); 
      
 IP_Flow1.appendChild(BW_Uplink); 
       Element 
BW_Downlink = dom.createElement("bw_downlink"); 
      
 BW_Downlink.appendChild(dom.createTextNode(
bw_dl)); 
      
 IP_Flow1.appendChild(BW_Downlink); 
       Element 
QoS_Class = dom.createElement("qos_class"); 
      
 QoS_Class.appendChild(dom.createTextNode(Qo
S_class)); 
      
 IP_Flow1.appendChild(QoS_Class); 
      
 tris.appendChild(IP_Flow1); 
      
 //docEle.appendChild(tris); 
      } 
     } 
      
    } 
    else 
    { 
     Element IP_Flow1 = 
dom.createElement("ip_flow"); 
     Element Session_ID1 = 
dom.createElement("session_id"); 
    
 第 72 頁 / 共 89 頁 
   } 
    
  } 
  putXML(XMLDocToString(dom)); 
 } 
  
 /** 
      * This removes a session from the Policy 
repository 
 * @param session_id the ID of the session to 
remove 
 */ 
 public void deleteSession(String session_id) 
throws IOException 
 { 
  parseXML(getXML()); 
   
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
  NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
  if(nl0 != null && nl0.getLength() > 0)  
  { 
   Element tris = (Element)nl0.item(0); 
   NodeList nl = 
tris.getElementsByTagName("af_session"); 
   if(nl != null && nl.getLength() > 0)  
   { 
    int i = 0; 
    while ((nl != null && 
nl.getLength() > 0) && i < nl.getLength()) 
    { 
     Element IMS_Session = 
(Element)nl.item(i); 
     i++; 
     NodeList nl1 = 
IMS_Session.getElementsByTagName("session_id"); 
     if(nl1 != null && 
nl1.getLength() > 0)  
     { 
      Element Session_ID 
= (Element)nl1.item(0); 
      String 
current_session_id = 
Session_ID.getFirstChild().getNodeValue().toString(); 
     
 if(current_session_id.equals(session_id)) 
      { 
      
 tris.removeChild(IMS_Session); 
       i = 0; 
      } 
     } 
     nl = 
tris.getElementsByTagName("af_session"); 
    } 
   } 
 
  } 
  putXML(XMLDocToString(dom)); 
 } 
  
 /** 
      * This removes an ip flow from the Policy 
repository 
 * @param session_id the ID of the IP Flows to 
remove 
 */ 
 public void deleteIPFlow(String session_id) throws 
IOException 
 { 
   
  parseXML(getXML()); 
   
  //get the root elememt 
  Element docEle = 
 第 74 頁 / 共 89 頁 
nl3.getLength() > 0) 
     {  
      Element conditions = 
(Element)nl3.item(0); 
      NodeList nl1 = 
conditions.getElementsByTagName("qos_class"); 
      if(nl1 != null && 
nl1.getLength() > 0) 
      {  
       Element 
qos_class = (Element)nl1.item(0); 
       NodeList nl2 = 
qos_class.getElementsByTagName("class_id");  
       if(nl2 != null 
&& nl2.getLength() > 0)  
       { 
        for(int a 
= 0 ; a < nl2.getLength();a++) 
        { 
        
 Element class_id = (Element)nl2.item(a); 
        
 if(QoS_class == 
(Integer.valueOf(class_id.getFirstChild().getNodeValue(
))).intValue()) 
         { 
         
 int temp = 
(Integer.valueOf(class_id.getAttribute("bw_downlink")))
.intValue() + bw_dl; 
         
 String new_bw_dl = "" + temp; 
         
 temp = 
(Integer.valueOf(class_id.getAttribute("bw_uplink"))).int
Value() + bw_ul; 
         
 String new_bw_ul = "" + temp; 
         
 class_id.setAttribute("bw_downlink",new_bw_dl); 
         
 class_id.setAttribute("bw_uplink",new_bw_ul); 
         
  
         } 
     
        }  
       } 
      } 
     } 
    } 
   } 
  } 
  putXML(XMLDocToString(dom)); 
 } 
 
 /** 
      * This deducts the specified uplink and 
downlink bandwidth to the specified QoS class 
 * @param QoS_class the QoS class to return the 
bandwidth to 
 * @param bw_ul the uplink bandwidth to deduct 
 * @param bw_dl the downlink bandwidth to 
deduct 
 */ 
 public void reqQoSBandwidth(int QoS_class, int 
bw_ul, int bw_dl) throws IOException 
 { 
   
  parseXML(getXML()); 
   
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
 
  NodeList nl = 
docEle.getElementsByTagName("rule"); 
 第 76 頁 / 共 89 頁 
 public void freeDomainBandwidth(String domain, 
int bw_ul, int bw_dl) throws IOException 
 { 
  parseXML(getXML()); 
   
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
 
  NodeList nl = 
docEle.getElementsByTagName("rule"); 
  if(nl != null && nl.getLength() > 0) { 
   for(int i = 0 ; i < nl.getLength();i++) { 
     
    //get the authorised codec rule 
    Element rule = 
(Element)nl.item(i); 
    String id = 
rule.getAttribute("id"); 
    if(id.equals("domain 
authorisation")) 
    { 
     NodeList nl3 = 
rule.getElementsByTagName("conditions"); 
     if(nl3 != null && 
nl3.getLength() > 0) 
     {  
      Element conditions = 
(Element)nl3.item(0); 
      NodeList nl1 = 
conditions.getElementsByTagName("domain"); 
      if(nl1 != null && 
nl1.getLength() > 0) 
      {  
       Element 
Domain = (Element)nl1.item(0); 
       NodeList nl2 = 
Domain.getElementsByTagName("address");  
       if(nl2 != null 
&& nl2.getLength() > 0)  
       { 
        for(int a 
= 0 ; a < nl2.getLength();a++) 
        { 
        
 Element address = (Element)nl2.item(a); 
        
 if(domain.equals( address.getFirstChild().getNode
Value())) 
         { 
         
 int temp = 
(Integer.valueOf(address.getAttribute("bw_downlink"))).
intValue() + bw_dl; 
         
 String new_bw_dl = "" + temp; 
         
 temp = 
(Integer.valueOf(address.getAttribute("bw_uplink"))).int
Value() + bw_ul; 
         
 String new_bw_ul = "" + temp; 
         
 address.setAttribute("bw_downlink",new_bw_dl); 
         
 address.setAttribute("bw_uplink",new_bw_ul); 
         
  
         } 
     
        }  
       } 
      } 
     } 
    } 
   } 
  } 
 第 78 頁 / 共 89 頁 
         
 address.setAttribute("bw_uplink",new_bw_ul); 
         
  
         } 
     
        }  
       } 
      } 
     } 
    } 
   } 
  } 
  putXML(XMLDocToString(dom)); 
 } 
  
 /** 
 * This puts an XML file to the XDMS server 
 * @param xmlDoc String representation of the 
document to put to the server 
 */ 
 public void putXML(String xmlDoc) throws 
IOException 
 { 
  if(remote_xcap_server == 1) 
  { 
 //  
 System.out.println("-------------------------------------
-------------"); 
 //   System.out.println(); 
 //   System.out.println("INFO: Sending 
HTTP PUT to XDMS Server"); 
 //   System.out.println();  
   
   HttpClient client = new HttpClient(); 
   client.getState().setCredentials( 
   AuthScope.ANY, 
   new 
UsernamePasswordCredentials(username,password) 
   ); 
   PutMethod put = new 
PutMethod(policy_db); 
   put.setDoAuthentication( true ); 
   put.setRequestEntity(new 
StringRequestEntity(xmlDoc,"text/plain","UTF-8")); 
   try { 
    // execute the PUT 
    int status = 
client.executeMethod( put ); 
   
    // print the status and response 
    //System.out.println(status + " " 
+ put.getResponseBodyAsString() +"\n"); 
    
  
   }finally { 
   // release any connection resources 
used by the method 
    put.releaseConnection(); 
   } 
  } 
  else 
  { 
   File domain_policies = new 
File(policy_db); 
                 FileWriter out = new 
FileWriter(domain_policies); 
   out.write(xmlDoc); 
                 out.close(); 
  } 
 } 
 
 /** 
 * This gets an XML file from the XDMS server 
 * @return xmlDoc InputStream  representation of 
the document retrieved from the server 
 */ 
 public InputStream getXML() throws IOException 
 第 80 頁 / 共 89 頁 
 */ 
 public Vector getIPFlows(String session_id) 
throws IOException 
 { 
    
  //fetch and parse the policy XML document 
  parseXML(getXML()); 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
   
  Vector ip_flows = new Vector(); 
   
  NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
  if(nl0 != null && nl0.getLength() > 0)  
  { 
   Element tris = (Element)nl0.item(0); 
   NodeList nl = 
tris.getElementsByTagName("ip_flow"); 
   if(nl != null && nl.getLength() > 0) { 
    for(int i = 0 ; i < 
nl.getLength();i++) { 
      
     String ip_flow = ""; 
     Element IP_Flow = 
(Element)nl.item(i); 
     NodeList nl1 = 
IP_Flow.getElementsByTagName("session_id"); 
     if(nl1 != null && 
nl1.getLength() > 0) { 
      Element Session_ID 
= (Element)nl1.item(0); 
     
 if(session_id.equals(Session_ID.getFirstChild().get
NodeValue().toString())) 
      { 
       ip_flow = 
ip_flow + session_id + ";"; 
       nl1 = 
IP_Flow.getElementsByTagName("flow_id"); 
       if(nl1 != null 
&& nl1.getLength() > 0) { 
        Element 
Flow_ID = (Element)nl1.item(0); 
        ip_flow 
= ip_flow + Flow_ID.getFirstChild().getNodeValue() + 
";"; 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("source_ip"); 
       if(nl1 != null 
&& nl1.getLength() > 0) { 
        Element 
Source_IP = (Element)nl1.item(0); 
        ip_flow 
= ip_flow + Source_IP.getFirstChild().getNodeValue() + 
";"; 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("dest_ip"); 
       if(nl1 != null 
&& nl1.getLength() > 0) { 
        Element 
Dest_IP = (Element)nl1.item(0); 
        ip_flow 
= ip_flow + Dest_IP.getFirstChild().getNodeValue() + 
";"; 
       } 
       nl1 = 
IP_Flow.getElementsByTagName("source_port"); 
       if(nl1 != null 
&& nl1.getLength() > 0) { 
        Element 
Source_Port = (Element)nl1.item(0); 
        ip_flow 
= ip_flow + Source_Port.getFirstChild().getNodeValue() 
+ ";"; 
 第 82 頁 / 共 89 頁 
IOException 
 { 
  String pcrfAddress = ""; 
  //fetch and parse the policy XML document 
  parseXML(getXML()); 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
 
  NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
  if(nl0 != null && nl0.getLength() > 0)  
  { 
   Element tris = (Element)nl0.item(0); 
   //get all authorised domains and list of 
authorised QoS classes into vectors 
   NodeList nl = 
tris.getElementsByTagName("pcef"); 
   if(nl != null && nl.getLength() > 0)  
   { 
    for(int i = 0 ; i < 
nl.getLength();i++)  
    { 
     Element PCEF = 
(Element)nl.item(i); 
     NodeList nl1 = 
PCEF.getElementsByTagName("pcef_id"); 
     if(nl1 != null && 
nl1.getLength() > 0)  
     { 
      Element PCEF_ID = 
(Element)nl1.item(0); 
     
 if(pcef_id.equals(PCEF_ID.getFirstChild().getNod
eValue().toString())) 
      { 
       nl1 = 
PCEF.getElementsByTagName("pcrf_address"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
PCRF_Address = (Element)nl1.item(0); 
       
 pcrfAddress = 
PCRF_Address.getFirstChild().getNodeValue().toString(
); 
       } 
      } 
     } 
    } 
   } 
  }  
 
   
  return pcrfAddress; 
 } 
 
 /** 
 * This returns the address of the AS associated 
with a domain 
 * @param orig_realm the originating domain 
 * @param term_realm the terminating realm 
 * @return af_address the address of the AF 
 */ 
 public String getAF(String orig_realm,String 
dest_realm) throws IOException 
 { 
  String af_address = ""; 
  /**TODO Link multiple PCEFs if realms 
different*/ 
  /**If orig and dest realm the same*/ 
 
 //if(orig_realm.equalsIgnoreCase(dest_realm)) 
  //{ 
    
   //fetch and parse the policy XML 
document 
 第 84 頁 / 共 89 頁 
docEle.getElementsByTagName("tris"); 
  if(nl0 != null && nl0.getLength() > 0)  
  { 
   Element tris = (Element)nl0.item(0); 
   //get all authorised domains and list of 
authorised QoS classes into vectors 
   NodeList nl = 
tris.getElementsByTagName("pcrf"); 
   if(nl != null && nl.getLength() > 0)  
   { 
    for(int i = 0 ; i < 
nl.getLength();i++)  
    { 
     Element PCRF = 
(Element)nl.item(i); 
     NodeList nl1 = 
PCRF.getElementsByTagName("address"); 
     if(nl1 != null && 
nl1.getLength() > 0)  
     { 
      Element Address = 
(Element)nl1.item(0); 
     
 if(pcrf_address.equals(Address.getFirstChild().get
NodeValue().toString())) 
      { 
       nl1 = 
PCRF.getElementsByTagName("af_address"); 
       if(nl1 != null 
&& nl1.getLength() > 0)  
       { 
        Element 
AF_Address = (Element)nl1.item(0); 
       
 af_address = 
AF_Address.getFirstChild().getNodeValue().toString(); 
       } 
      } 
     } 
    } 
   } 
   
  } 
  return af_address; 
 } 
 
 
 /** 
 * This returns the address of the PCEF associated 
with a domain 
 * @param orig_realm the originating domain 
 * @param term_realm the terminating realm 
 * @return pcefAddress the address of the PCEF 
 */ 
 public String getPCEF(String orig_realm,String 
dest_realm) throws IOException 
 { 
  String pcefAddress = ""; 
  /**TODO Link multiple PCEFs if realms 
different*/ 
  /**If orig and dest realm the same*/ 
 
 //if(orig_realm.equalsIgnoreCase(dest_realm)) 
  //{ 
    
   //fetch and parse the policy XML 
document 
   parseXML(getXML()); 
   //get the root elememt 
   Element docEle = 
dom.getDocumentElement(); 
  
   NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
   if(nl0 != null && nl0.getLength() > 0)  
   { 
    Element tris = 
(Element)nl0.item(0); 
 第 86 頁 / 共 89 頁 
      Element  PCEF_ID 
= (Element)nl1.item(0); 
     
 if(pcefID.equals(PCEF_ID.getFirstChild().getNod
eValue())) 
      { 
       nl1 = 
PCEF.getElementsByTagName("status"); 
       if(nl1 != null 
&& nl1.getLength() > 0) { 
        Element  
Status = (Element)nl1.item(0); 
       
 Status.replaceChild(dom.createTextNode(status),St
atus.getFirstChild()); 
       } 
      } 
     } 
      
    } 
   } 
 
  } 
  putXML(XMLDocToString(dom)); 
 } 
  
 /** 
 * This sets the stats of the specified PCRF to ON 
or OFF 
 * @param pcrfID ID of PCRF 
 * @param status either ON or OFF 
 */ 
 public void statusPCRF(String pcrfID, String 
status) throws IOException 
 { 
  //get the root elememt 
  Element docEle = 
dom.getDocumentElement(); 
   
  NodeList nl0 = 
docEle.getElementsByTagName("tris"); 
  if(nl0 != null && nl0.getLength() > 0)  
  { 
   Element tris = (Element)nl0.item(0); 
   NodeList nl = 
tris.getElementsByTagName("pcrf"); 
   if(nl != null && nl.getLength() > 0) { 
    for(int i = 0 ; i < 
nl.getLength();i++) { 
      
     Element PCRF = 
(Element)nl.item(i); 
     NodeList nl1 = 
PCRF.getElementsByTagName("pcrf_id"); 
     if(nl1 != null && 
nl1.getLength() > 0) { 
      Element  PCRF_ID 
= (Element)nl1.item(0); 
     
 if(pcrfID.equals(PCRF_ID.getFirstChild().getNode
Value())) 
      { 
       nl1 = 
PCRF.getElementsByTagName("status"); 
       if(nl1 != null 
&& nl1.getLength() > 0) { 
        Element  
Status = (Element)nl1.item(0); 
       
 Status.replaceChild(dom.createTextNode(status),St
atus.getFirstChild()); 
       } 
      } 
     } 
      
    } 
   } 
 
 第 88 頁 / 共 89 頁 
可供推廣之研發成果資料表 
□ 可申請專利  ■ 可技術移轉                              日期：一百年十月十一日 
國科會補助計畫 
計畫名稱：跨層式感知與協力 4G-IMS 無線網路研究-子計畫三：跨
層式感知與協力 4G-IMS 無線網路之服務品質與資源管理研究(3/3) 
計畫主持人：陳俊良  國立台灣科技大學電機工程學系 
計畫編號：NSC 99－2219－E－011－006 學門領域：電信國家型計畫 
技術/創作名稱 Cooperative QoS Mechanism with QAM Charging for Heterogeneous 
Networking 
發明人/創作人 陳俊良/楊佩嘉/鄭秉昇/張新毅 
技術說明 
中文： 
該技術提出在異質網路之 QoS（Quality-of-Service）管理中，
基於 Cooperative 概念推演出的多智能系統，所提出之 Cooperative
系統，主要藉由互相交換訊息，以確保 QoS 之區域性代理人組成。
在系統之演算法中，主要應用 Q-learning 演算法，計算許多代理人
所傳達之回應資訊，以達到在不同網路中之換手運作。當正在與使
用者連線之網路無法確保 QoS 時，則會透過 QoS 代理人以及
Q-learning 演算法，選擇較適當之網路通訊介質，並基於使用者付
費之公平性原則，根據 QoSClass Rule 和 QoSStreamID Rule 的費率
決策演算法，合理分配使用者的應用服務，以提供使用者高品質之
多媒體服務。 
英文： 
The technology proposes a novel cooperative multi-agent system based 
on a cooperative concept and awareness algorithm for QoS 
management in heterogeneous network. The cooperative system is 
consisted of problem-solving agents that autonomously process local 
tasks and cooperatively exchanges information via a shared database to 
guarantee network QoS. An awareness algorithm called Q-learning is 
proposed to calculate a reward set of handoff occurred from one to 
other access networks. When an access network cannot support 
multimedia applications with desired QoS level, thus the 
problem-solving agent can adaptively select another network from the 
Q-learning set to replace the system.  
可利用之產業 
及 
可開發之產品 
可利用之產業：無線網路、網路多媒體應用及車載魯路等相關產業。 
可開發之產品：無線網路之終端設備、車載之路側系統 (Road Side 
Unit, RSU) 與車輛單元 (On-Board Unit, OBU)等。 
技術特點 
1. Q-Learning 演算分析：為實作增強式學習法 (reinforcement 
learning)之演算法。增強式學習法起源於心理學中的制約操作
理論，不同於監督式學習法，要有一個監督者來指導學習，增
強式學習法僅憑著與環境的互動進行學習，其學習代理人
(agent)並沒有明確的指導者。在連續的決策過程中，單一項決
策可能會影響後續的狀態與決策，因此增強式學習法學習的目
標是極大化所有決策報酬的總合，以及與環境互動來追求未來
附件二 
 1
 
 
國科會補助專題研究計畫項下國際合作研究計畫國外研究報告 
                                     日期：100 年 7 月 5日 
一、 國際合作研究過程 
本人因執行國科會計畫(NSC 99－2219－E－011－006;附件一所示) 需至美國 New 
Jersey Morristown 的 Telcordia Technologies 公司(前名為 Bell Labs;合作部門: 
Internet Service Management Research Department of the Internet Architecture 
Research Lab; Director for the "Service Integration Research")進行研發系統合作
測試(Protocol Validation & Application Test)，以強化未來 4G-IMS 網路通訊的研究能
量，因 Telcordia 多位研究人員於 100/6/6~100/6/9 至日本京都參加 IEEE ICC 國際研討會，
我亦有一篇論文擬於此會議發表(如附件二所示)，所以雙方約定先將已發展之系統模組互
送對方進行測試，然後於 IEEE ICC 會場租用其場地進行雙方合作研究成果討論。此外，因
日本東京工業大學亦有相關之 testbed，邀請我們進行合作，所以我們亦於 99 年藉由本校
補助本實驗室研究人員至日本東京工業大學 Takada Lab 進行合作討論。綜上所述，本人本
期國際合作研究目的為: 
(1)Telcordia Technologies 是國際網路通訊研發領導公司，亦擁有與我們研究相同之
4G-IMS Testbed，我們於前期計畫(NSC 94－2219－E－259－003; NSC 96－2219－E－
011－009; NSC 97－2219－E－011－008;NSC 98-2219-E-259-006)已與 Telcordia 公司
合作研發，進行國科會計畫研究成果測試。與 Telcordia Research Team 已有長期合作
之默契，因此雙方於 4G IMS-QoS 協定測試與分析進展順利。 
計畫編號 NSC 99－2219－E－011－006－  
計畫名稱 跨層式感知與協力 4G-IMS 無線網路研究--子計畫三:跨層式感知與協
力 4G-IMS 無線網路之服務品質與資源管理研究(3/3) 
出國人員
姓名 陳俊良 
服務機構
及職稱 台灣科技大學電機系/教授 
合作國家 美國/日本 合作機構 美國 Telcordia/日本東京工業大學 
出國時間 
99年 12月 1日至 
 99年 12月 4日 
100年 6月 6日至 
 100年 6月 9日 
出國地點 
日本/東京、京都 
附件六 
 3
 
圖四：測試終端設備 
 
圖五：系統效能監控場景 
 
圖六：於京都雙方與會人員 
 
圖七：我方人員於合作會議報告 
 5
二、 研究成果 
  經過了多年的合作，兩方(與 Telcordia)合作相當順利，成果如下所述。 
1. 研究成果發表論文 
- J.L. Chen, S.W. Liu, S.L. Wu and M.C. Chen, “Cross-layer and Cognitive QoS Management 
System for Next-Generation Networking,” International Journal of Communication Systems, 
Vol.24, No.9, pp.1150-1162, 2011. 
- J.L. Chen, Y.T. Larosa, D.J. Deng, P.J. Yang and Y.W. Ma, “QoS-aware Heterogeneous 
Networking using Distributed Multiagent Schemes,” Proceedings of the IEEE Wireless 
Communications and Mobile Computing Conference (IWCMC), pp.1713-1718, August 2011. 
- J.L. Chen, S.L. Wu, Y.T. Larosa, P.J. Yang and Y.F. Li, “IMS Cloud Computing Architecture for 
High-quality Multimedia Applications,” Proceedings of the Wireless Communications and 
Mobile Computing Conference (IWCMC), pp.1463-1468, September 2011. 
2. 系統功能模組測試 
- Online Charging Module; 
- Offline Charging Module;  
- QoSClass Rule 和 QoSStreamID Rule 的費率決策演算法; 
- Multimedia Applications over 4G-IMS with QoS Guarantee。 
3. 與東京工業大學合作撰寫未來合作計畫書 （如附件三） 
 
三、 建議 
   國際研究除建立合作研究關係以達到前瞻研究之目的外，亦應兼具培育實驗室研究人員之國
際觀。國科會補助本人多年國際合作經費與國際頂尖 Lab 合作，然前五年之運作模式皆是由實驗
室先將研發之系統模組互送對方測試，我則選定長假時間至 Telcordia 與他們的研究人員會談，
我的研究人員僅能藉由視訊會議討論，國際觀稍欠缺。本期計畫執行我則帶實驗室 8 位研究人員
直接接受東京工業大學 Takada Lab 邀請至東京與其實驗室研究人員研討，雙方人員則一一發表研
究相關模組及測試情形，成效良好，本案雖已結束，然雙方仍繼續研討。建議未來國際合作研究，
儘量讓研究人員親自出席，以培養其國際觀及強化其國際競爭力。 
四、其他 
感謝國家科學委員費經費補助參加此國際會議，受益良多。 
On Alleviating Starvation in Wireless Sensor 
Networks 
Yang-Sheng Chen,  Yu-Shiang Wong, and Der-Jiunn Deng+ 
Department of Computer Science and Information Engineering 
National Changhua University of Education 
Changhua, Taiwan, R.O.C 
yeti0193275@gmail.com, nightlossk@gmail.com, djdeng@cc.ncue.edu.tw
Jiann-Liang Chen 
Department of Electrical Engineering 
National Taiwan University of Science and 
Technology  
Taipei, Taiwan, R.O.C 
lchen@mail.ntust.edu.tw 
 
Abstract—Current medium access control (MAC) protocols for 
wireless sensor networks (WSNs) do not support prioritized 
channel access and often suffer from varying degrees of 
starvation and fairness problems. That is, with a little bad luck, a 
sensor node might have to wait arbitrarily long to send its frame, 
and thus results in the invisibility of some sensed area. In this 
paper we introduce a simple, but yet well performing starvation-
free backoff scheme based on sensor MAC (S-MAC) protocol for 
WSNs. The proposed scheme allows a sensor node to adjust its 
backoff window size according to its re-transmission times. An 
analytical analysis is carried out to study the saturation 
throughput of proposed scheme under backlogged conditions. In 
addition to the theoretical analysis, simulations were also 
conducted to analyze the proposed scheme and the results show 
that our scheme can effectively alleviate the starvation and 
fairness problem and achieve better performance in high density 
WSNs. 
Keywords: S-MAC, WSNs, starvation, backoff, priority 
I.  INTRODUCTION 
In recent years, the rapid growing of embedded systems 
and memory technique leads to the vigorous development of 
wireless sensor networks (WSNs). The core idea of wireless 
sensor networks is deploying a large number of small-sized 
sensors to collaboratively monitor physical and environment 
conditions. Generally, sensor nodes are operated with limited 
power and cooperated in unstable environment. Hence, in 
WSNs, the MAC protocol is the key component that provides 
the efficiency in sharing the common radio channel while 
satisfying the fairness requirements for each sensor node. 
In the literatures there have been adequate discussions 
about the performance of various MAC protocols for WSNs. 
Ye et al. [1] proposed a Sensor MAC (S-MAC) based on 
IEEE 802.11 protocol, which significant reduced power 
consumption by adding periodic sleep mechanism. S-MAC 
employs periodically relative synchronization by broadcasting 
next sleeping time of sensor nodes periodically and choosing 
large slot time to provide robustness when topology changes 
or clock drifts. 
Due to the active time of sensor nodes in S-MAC is 
fixed, the energy efficiency of S-MAC is not satisfied. Hence, 
Tijs and Koen [2] proposed a Timeout MAC (T-MAC), which 
uses adaptive scheme to force a sensor node to enter sleeping 
mode when a sensor node is idle and channel is busy in active 
stage. T-MAC improves the performance of S-MAC in terms 
of energy efficiency but the adaptive scheme also causes early 
sleeping problems.  
To achieve better energy efficiency, there are many 
extended versions of S-MAC have been proposed. In [3] and 
[4], a dynamic control active time mechanism has been 
proposed to provide more efficient energy usage. In [5], the 
authors proposed a Berkeley-MAC (B-MAC) which attempts 
to use hardware technique, such as lower power listening 
(LSL) and clear channel assessment (CCA) to improve its 
power consumption. In [6], the authors pointed out that Z-
MAC [7], a hybrid TDMA and CSMA/CA MAC protocol for 
WSNs, can achieve better performance than the B-MAC, but 
the robustness of network could be another problem. 
Although the aforementioned works achieve better 
performance than S-MAC, these approaches are not 
satisfactory since they did not take into account the fairness 
and starvation problems. Furthermore, many previous works, 
e.g. [1] and [2], choose to burst transmit its frames in order to 
get shorter transmission latency. However, this makes 
starvation problem worse because sensor nodes may face high 
contention from neighboring nodes. In [6], the authors 
mentioned that the fairness and starvation problems may cause 
significant parts of the network to be invisible, in that nodes 
sensing events in such areas are starved, and hence the sink 
never detects events from these areas. 
Please note that fairness problem usually come with 
starvation of sensor nodes, but essentially they are different, as 
starvation is induced by a bad luck sensor node which always 
chooses a relatively large backoff number, and therefore this 
sensor node might have to wait arbitrarily long to send its 
frame. Binary Exponential Backoff (BEB) algorithm, the 
defacto standard contention resolution algorithm for wireless 
local area networks (WLANs) might lead to a fairness 
problem as well because BEB algorithm always favors the last 
successfully transmitted node.  
In fact, the backoff algorithm of S-MAC is different from 
standard BEB algotithm. S-MAC uses fixed contention 
windows size and S-MAC does not freeze its timer if the 
channel becomes busy before time out. Hence, S-MAC 
eliminates the fairness problems but aggravates the starvation 
problem since a bad luck node may always choose a relatively 
large contention window size for each transmission. In [8], 
+Correspondence: Der-Jiunn Deng 
The work of this paper was partially sponsored by ROC NSC under Contract 97-2221-E-018-020-MY3
Variables Meaning and explanation 
sP  Probability of a successful transmission 
IP  Probability of idle channel 
cP  Probability of a collided transmission 
errP  Probability of a transmission errors 
m  Retry limit 
em  Extended retransmission limit 
eifs  Extended interframe space 
φ  Resend time threshold 
W ′  Sliding contention window size 
n  Number of sensor nodes 
sT  Duration of a success transmission time 
IT  Duration of idle channel 
cT  Duration of a collided transmission 
errT  Duration of a transmission error 
frameT  Length of time frame 
BER  Channel bit error rate 
σ  Duration of time slot 
 
Now let us try to calculate the average contention window 
size. According to the assumption and definition in section 2.1, 
both lower bound and upper bound of the random backoff 
number will decrease after a transmission failure, and we 
assume the geometric distributed random variable is used to 
choose the random backoff number. Hence, the average 
contention window size is 
 
 
 
1
0 0
2
(1 )( ') ( 1)  
2 2=  
1
8 ' (1 ) ( 8 9)
 
8(1 )
m
i
f f
i i
m
f
m
f
m
f
eifs ip W p eifs
p
W p eifs
p
φφ
φ φ
−
= =
⎢ ⎥− + + × − × ⎢ ⎥⎣ ⎦
−
× − − × − −= −
∑ ∑
 
(1) 
Here fp is the probability of a transmission failure. 
In the beginning of an active period, a sensor node starts 
to transmit a frame with probability p , and defers the 
transmission with probability1 p− . According to probability 
theory, the probability that there are x failures of transmission 
before the first success can be calculate as 
1( ) (1 )  ,  1xP X x p p x−= = − ≤ ≤ ∞  (2) 
Hence, the average contention window size, W , is 
completely identified by the value of p, and thus we have  
1 1
1 1
1 1(1 ) (1 )
2 1
x x
x x
W pxp p x p
p p
∞ ∞− −
= =
+ = − = − =−∑ ∑  (3) 
By solving the above equation, we get:  
2
1
p
W
= +  (4) 
By substituting W  in (1) into (4), we obtain: 
2
2
1
16(1 )
  
8( ' 1) (1 ) ( 8 9)
m
f
m
f
p
W
p
W p eifs φ φ
= +
−= + × − − × − −
 (5) 
However, the probability fp  is still unknown. Since the 
probability of transmission failure is defined as the probability 
that a transmitted frame collided or received with error, we 
have 
11 (1 ) (1 )nf ep p p
−= − − × −  (6) 
Here ep  is the probability that data frame error or ACK 
frame error consecutively occurred when transmitting a data 
frame. Since both lost of data or ACK frame will cause ACK 
timeout and force sender to immediately resend the data frame 
until it exceeds the extended retransmission limit or receive a 
ACK frame successfully, we can express ep  as the summation 
of probability that data or ACK frame error happened 
consecutively. Hence, we have 
( )( ) ( )
0
(1 )
em i em iem data data ack
e i e e e
i
p p p p
−
=
= − ×∑  (7) 
Where em , dataep , and 
ack
ep  stand for the extended 
retransmission limit, the probability of data frame received 
with error, and the probability of ACK frame received with 
error. Thus, we have: 
1 (1 ) dataLdataep BER= − −  (8) 
1 (1 ) ackLackep BER= − −  (9) 
C. Saturation throughput analysis 
Since the saturation throughput is defined as a relation of 
successfully transmitted payload size over a randomly chosen 
time slot in the active stage [9], the system saturation 
throughput can be defined as follows: 
s data
I I s s c c err err
P LS
PT PT PT P T
= + + +  (10)
According to the equation above, the successful 
transmission probability, sP , is defined as the system 
transmitted a data packet without collision or bit error. Hence 
we can express sP  as 
1(1 ) (1 )ns eP np p p
−= − −  (11)
Let IP  denote the probability that no sensor node try to 
send data in a time frame, and cP  denote the probability that a 
collision occurs in a time frame. Hence, they can be express as:  
(1 )nIP p= −  (12)
11 (1 ) (1 )n ncP p np p
−= − − − −  (13)
0 1 0(1 )( ') ... (1 )( ') ...
2 2 2 2
1
m
f f f f
m
f
eifs eifsp p W p p W eifs eifs
W
p
φ− ⎢ ⎥ ⎢ ⎥− + + − + − × + + − ×⎢ ⎥ ⎢ ⎥⎣ ⎦ ⎣ ⎦= −
 
B. Simulations Result 
Fig. 1 compares the system throughput obtained from the 
proposed scheme with the S-MAC protocol. In this scenario 
there are fifteen sensor nodes within the simulation 
environment. As shown in the figure, the proposed scheme can 
provide a better performance in most cases. Besides, as we 
expected, when the duty cycle (the ratio of active time divided 
sleep time) increases, the system throughput increases linearly. 
Fig. 2 depicts the system throughput as the number of 
sensor nodes increases when the duty cycle is 10 %. In general, 
for both scheme, the system throughput deteriorates as the 
number of sensor nodes increase. We can see there is not 
much difference in the values of the performance measures 
between two schemes in low density environment. However, 
as shown in figure 3, the proposed scheme obviously 
outperforms the S-MAC protocol in high density environment. 
Fig. 3 shows the effect of number of sensor nodes by 
plotting the blocking rate of data frame. Note that the blocking 
rate of S-MAC protocol dramatically increase when the 
number of sensor nodes larger than 30 in contrast to the 
smoothness of the proposed scheme. Therefore, this result is 
evidence that the proposed scheme can effectively avoid 
starvation problem especially when the system becomes 
congested. It also reveals that the proposed scheme could 
avoid starvation problem without sacrificing the overall 
system performance. 
 
 0.2
 0.4
 0.6
 0.8
 1
 1.2
 1.4
 10  20  30  40  50  60  70  80 90
Th
to
ug
hp
ut
 (k
bp
s)
Duty Cycle (%)
Proposed scheme simulation
 S-MAC simulation
 
Figure 1.   Throughput versus duty cycle 
 0.15
 0.16
 0.17
 0.18
 0.19
 0.2
 0.21
 0.22
 10  20  30  40  50 60
Th
ro
ug
hp
ut
 (k
bp
s)
Number of nodes
 Proposed scheme 
 S-MAC 
 
Figure 2.   Throughput versus number of sensor nodes 
 0
 0.005
 0.01
 0.015
 0.02
 0.025
 0.03
0.035
 10  20  30  40 50 60
B
lo
ck
in
g 
ra
te
Number of nodes
 Proposed scheme 
 S-MAC 
 
Figure 3.   Blocking rate versus number of sensor nodes 
IV. CONCLUSION 
In this paper, we proposed a pragmatic starvation-free 
bakeoff algorithm based on S-MAC protocol for WSNs and the 
analytical model has also been conducted to study system 
throughput. Through extensive simulations, we have 
demonstrated quantitatively the effectiveness of our proposed 
scheme, and it offers a remarkable performance improvement 
in high density WSNs. 
In our future work, we will extend our scheme to support 
for multimedia transmission and compare with other random 
access MAC protocols. 
REFERENCES 
[1] W. Ye, J. Heidemann, and D. Estrin, "Medium access control with 
coordinated adaptive sleeping for wireless sensor networks." 
Networking, IEEE/ACM Transactions on, Volume 12, Issue 3, pp. 493- 
506, June 2004. 
[2] T. v. Dam, and K. Langendoen, "An Adaptive Energy-Efficient MAC 
Protocol for Wireless Sensor Networks.” Proceedings of the 1st 
international conference on Embedded networked sensor systems, Los 
Angeles, California, USA, pp. 171-180, November 05 - 07, 2003. 
[3] P. Lin, C. Qiao, and X. Wang, "Medium access control with a dynamic 
duty cycle for sensor networks." Wireless Communications and 
Networking Conference, 2004. WCNC. 2004 IEEE , vol.3, no., pp. 
1534- 1539 Vol.3, 21-25 March 2004. 
[4] S.H. Yang, H.W. Tseng, E.H.-K. Wu, and G.H. Chen,  "Utilization 
based duty cycle tuning MAC protocol for wireless sensor networks," 
Global Telecommunications Conference, 2005. GLOBECOM '05. IEEE, 
vol.6, no., pp.5 pp.-3262, 2-2 Dec. 2005. 
[5] K. Fakih, J. F. Diouris, and G. Andrieux, "BMAC: Beamformed MAC 
protocol with channel tracker in MANET using smart antennas." 
Wireless Technology, 2006. The 9th European Conference on , vol., no., 
pp.185-188, 10-12 Sept. 2006. 
[6] A. Warrier, J. Min, and I. Rhee, "Mitigating Starvation in Wireless 
Sensor Networks," Military Communications Conference, 2006. 
MILCOM 2006. IEEE, vol., no., pp.1-5, 23-25 Oct. 2006. 
[7] I. Rhee, A. Warrier, M. Aia, and M. Jeongki, "Z-MAC: A Hybrid MAC 
for Wireless Sensor Networks." Networking, IEEE/ACM Transactions 
on, vol.16, no.3, pp.511-524, June 2008. 
[8] C. Zhu, Y. Chen, L. Wang, L. Shu, and Y. Zhang, "SMAC-based 
proportional fairness backoff scheme in wireless sensor networks." 
Proceedings of the 6th International Wireless Communications and 
Mobile Computing Conference, Caen, France, pp. 138-142 ,2010. 
[9] Q. Ni, T. Li, T. Turletti, and Y. Xiao, “Saturation throughput analysis of 
error-prone 802.11 wireless networks,” Wireless Commun. and Mobile 
Computing, vol. 5, no. 8, pp. 945-956, Nov. 2005. 
 Collaborator Institutions: Takada Laboratory, Tokyo Institute of Technology. Wireless 
Networks and Evolutional Communications Laboratory, National Taiwan University of 
Science and Technology. 
Goal: 4G-LTE mobile communication networks emulation test-bed, Journal Paper 
Publication.   
Project Duration: one year. 
Description (Project/Research Abstract):  
The project aims to establish an emulation of Long Term Evolution (LTE) as a forth 
generation mobile communications framework test-bed using existing open platform. Two 
main parts comprise the test bed: first is the LTE physical layer providing two directional QoS 
parameters from user to the IP and EPC core networks. The second is the construction of IP 
and EPC core networks to emulate the actual condition of end-to-end QoS. The project is 
conducted by integrating the both parts, which Takada Lab. in Tokyo Institute Technology 
provides the first part of integration. WNEC lab conducts the EPC and IP network 
reconstructions by functioning open platform to capture provide a framework to adaptively 
adjust QoS parameter from LTE physical layer. The open platform used in this project is 
NetFPGA and OpenIMS. NetFPGA is an open hardware platform enabling the packet IP 
modification. Through the platform packet IP header will be able to be adjusted follow the 
QoS requirement. Moreover, in this project NetFPGA will be used as hardware agent on EPC 
core network, and also will be implemented as modified router and gateway for LTE access 
network. OpenIMS leverages the relation of EPC network to the application services forming 
on the cloud computing systems. The network parameter from LTE access network will be 
process NetPFGA platform as real time network condition and translated to OpenIMS to give 
appropriate traffic budget on service provider domains. 
Through this cooperative project, an open platform of LTE network test be can be realized 
then can be used for further research extension. Takada Lab as LTE access network provider 
can use this test-bed to design physical parameter on LTE access network such as MIMO 
scheduling. Meanwhile WNEC lab can design the QoS mechanism in order to build integrated 
operation and maintenance system for LTE-4G communication networks. 
 
 
 
 
 
 
 
 
 
 
 
   
2. Test-bed architecture  
Adapting the comprehensive LTE network, the perspective of total integrated network 
have to be completely depicted to model for the next step architecture. Therefore in Fig. 3, 
given the IP core network perspective in the integration of LTE and IMS network as the 
purposed test-bed integration scenario.  Firstly in the IP core network is considered several 
IMSs core located inside. Meanwhile the LTE abscess networks are integrated by 
SGSN/MME gateway. As well that application server such as 3rd party software accesses 
are forming the cloud systems, connected by edge routers.  
 
 
IP core network itself is considered formed by multiple number of router connected randomly 
each other’s. By simply meaning there are also network provider and network backbones in 
domain interconnection. From whole point of view of LTE-IMS integration architecture, an 
end-to-end service perspective has to take the place in order to provide the space of NetFPGA 
platform integration. Moreover for Fig.3 the presentation of test-bed shows Takada Lab. will 
conduct all types of QoS parameters from the physical layer, where WNEC lab will identify the 
QoS parameter on a database that later will be processed for QoS policy of total networks.  
 
 
 
 
 
 
Figure 3. Proposed Architecture of LTE‐4G Test‐bed Networks 
2. eNB types (𝐺); the access node type effects on the behaviors of UE access 
location and possible direction for network mobility. 
3. UE mobility (𝑀); the common behaviors of UE, since that lot of scheme are 
provided to measure   
4. Application types (𝜀); this is the first priority of parameter needed to be fulfilled to 
determining the access priority. This parameter is only can be exceed by priority 
assessment regarding to price concern. 
5. Priority assessment (𝛾); this parameter refers to the pricing paid for network 
resources, with this parameter UE. 
The relation between those five event parameters to Action A given by: 𝛼! = 𝑐!𝑛 + 𝐺! !!! − [𝑀!(!)] 
 
Action B is the impact of IMS node query of the best route and edge link capacity of 
destination source. This action will be determined on what kind of case applied to. Recall 
that two possible cases are applied to the actions. We have. 
1. Case of Action B is directed to symmetrical link, so generally invoke that 𝛼 = 𝛽!"#$%&! so that the Action B has to fulfill the Action A type. If 𝑓 denotes as all 
possible set of event parameter  the set of  numerical discussion that the maximum 
optimization of end to end QoS for this case will be meet the requirement as: 
 𝛽!"#$%&! =  arg𝑚𝑖𝑛! 𝛼! ; 𝑖𝜖𝑐,𝑛,𝐺,𝑀, 𝜀, 𝛾 
 
2. Case of Action B is directed to asymmetrical link, in asymmetrical link the Action 
B need to enquire the best possible route to the application source. As this possible 
that the link are formed by the number of routers, with specific state. The most 
prominent parameter of router link state is the congestion state that obtained by the 
pre and the post link status. If there are n numbers of router, where the pre and post 
congestion state denoted by 𝜌!"#(!)   and 𝜌!"#$(!) respectively.  So the congestion state 
per node given by: 
 𝜌! = 𝜌!"#(!)𝜌!"#$(!)  
 Therefore, the expectation from the system to have: 
𝜌!!!!! ≤ 𝛽!"#$%&! 
 
b. Network traf f i c  contro l   
Once the network connection is established by signaling actions follow the action A and B 
preferences, the flow maintenance is needed to assure the quality regarding to connection 
setup signaling. Different from network setup action, in this part the assignment of actions 
are not taken into account anymore. Instead the entire transit nodes are having the equal 
impact on the traffic quality as well as its contribution to enhance the total link. It is 
GW R
Traffic  F lows
Radio related events
R adio related events
GW
IP  network related events IP  network related events
Figure 7. Types of action handle 
 
4. Agent module 
From the model, the realization of test bed implementation the requirement of controlling 
traffic by identifying the event, it would require a specific module on the test bed that has 
some abilities to modifying the IP packet and identifies the specific input to be translated 
as parameter modifications to the traffic flow Concatenating the principles of LTE end to 
end QoS action and event to the module, where the modules itself are implemented on the 
each node of LTE end to end traffic flow.  
 
Embracing all functions that embodied on the purposed model, a logical module is 
designed in order to accomplish all tasks in obtaining all discussed actions and events. On 
the test bed this module will be the ambassador of each node. For efficiency, each module 
needs to cover two important functions the signally for IMS setup link and the second is 
the traffic controller. 
Traffic flow control
Module
Signaling module
Policy (P)AggregateParameters
(A)
Traffic Flow
Signaling
 
Figure 8. Node logical modules 
Fig. 8 shows that two modules are required in giving the functions. This is the basic 
module of pre NetPFGA implementation. Two information exchanges aggregate 
parameters (A) and Policy (P) are interchange from those two modules in giving the real 
time event query. 
 
a. Signaling module 
  
This module is the node implementation of action model of network link establishment. 
Fig. 9 gives which e more detailed of the signaling module. To Handling and forming very 
precise signaling action for network link establishment, this module needs to obtain the 
5. Open Platform implementation 
The module need to be translated in real test bed implementation, which is NetFPGA 
platform, will be implemented on the each module.  As mentioned before NetFPGA 
platform is expected to be able to measure the traffic flows, and determines the event in 
relation for decision sequence. 
 
a. NetFPGA Test-bed architecture 
Firstly the proposed test architecture is depicted by the fig. 11. There are five nodes of 
PC integrated with NetFPGA board. For each NetFPGA board there ar four-gigabit 
Ethernet ports, two ports are assigned  
 
eth0 eth0 eth0 eth0 eth0
eth1 eth1 eth1 eth1 eth1
Open IMS
core
Test router
(optional)
 
Figure 11. NetFPGA Implantation on the Network 
b. OpenFlow mechanism implementation 
 
Follow OpenFlow specification table, each node event can be handled by VLAN 
mechanism. There three field tuple of action table in OpenFlow entries are subjected 
to customization: VLAN_id, VLAN_prority, and IP_ToS. The OpenFlow role on 
the end-to-end IP flow by LTE-IMS mechanism, Fig. 13 has the detail illustration. EA 
(ACC LTE) to eNB relation in PHY and LINK layer controlling can be translated as 
the assignment from VLAN_id as the semi static events and  VLAN_prority as dynamic 
event and IP_ToS as static events. 
C aps ulated QoS  information tunneling
VL AN_id
12 bits
VL AN_priority
3 bits
ToS
6 bits
AC C
L TE
ToS
6 bits
eNB GW R AC C  X
VL AN_id
12 bits
VL AN_priority
3 bits
VL AN_priority
3 bits
Traffic Flows
 
Figure 12 OpenFlow Table Relations to Events 
Capsulator mechanism is projected to handle end to end record specification of ToS. 
For instance the setup request information is depending on the type of applications. 
For 23 possibilities of application types, the Capsulator inform this to the IMS process 
to matched the end the type of ACC X.  
On Each traffic control module will be place on OpenFlow module and according to 
the traffic and measurement function on every node we need to put traffic monitoring 
module. This function can be performed using promiscuous reference NetFPGA 
router, to get the real time information on the network layer.    
Eventually capsulator and OpenFLow module need to be glue with a controller. NOX 
control are be able to combine the cross events between these modules. NOX 
controller will be implemented together with Open IMS server. The virtualization is 
able to place the system together as virtual machine.  
 
 2
投稿論文總數為 373 篇，大會接受 150 篇二十四國之研究論文，論文接受率為 40%。 
  
我們的報告是安排在 8/27 下午 16:00~17:30，同一個時段有 8個 Parallel Session 進行。此
次我們的研究團隊發表了 1 篇研究報告 “An Adaptive QoS Mechanism for Multimedia 
Applications over Next Generation Vehicular Network”。每一 Session 安排 paper 發表篇數不
多，所以討論熱烈，我們的研究合作夥伴 Prof. Victor Leung 亦從 Canada 趕來參加此盛會，並
與 大學的 Prof. Kung 討論未來合作事宜。我們報告完後，與會的先進也提出了一些問題，與之
回覆與討論，覺得受益良多。此外亦聽取其他 Session 的研究成果報告，包括：Xuedong Liang (Oslo
大學)的”Soft QoS Provisioning for Wireless Sensor Networks: a Cooperative Communications 
Approach＂; Mojtaba Sabeghi (Delft University of Technology, NL); Mahmoud Naghibzadeh 
(Ferdowsi University of Mashhad, IR); Koen Bertels (Delft University of Technology, NL)
的＂ RDM+: A New Mac Layer Real-Time Communication Protocol＂; Trent Jacobs (University 
of Texas at Dallas, US); Hlaing Minn (University of Texas at Dallas, US); Naofal Al-Dhahir 
(University of Texas at Dallas, US) 的 ＂ Reduced-Complexity Bandwidth-Constrained 
Distributed Estimation for Wireless Sensor Networks＂; Brian Matt (SPARTA, US); Matt Mundy 
(SPARTA, US)的＂ Designing Efficient and Resilient Tactical Sensor Network Neighborhood 
Keying Algorithms＂，對未來通訊網路研究方向的定位較明確。 
  
大會 Keynote Lecture，主題為 Challenge for Gigabit Wireless，主講者為 Prof. Fumiyuki 
Adachi。演講內容以 2005 年開始由 NSF 補助之 Optical Network Project 為主軸，參與之研究機
構包含 Princeton 大學 (主導學校)、Pittsburgh 大學、Stanford 大學、Berkeley 大學等。Prof. 
Fumiyuki 報告此項研究議題之動機、過程與相關研究，對於近年 High Speed Wireless Network
所產生電能消耗的問題與解決方案提出具體說明與分析比較，包含 Power Saving 及 Cloud 
Computing 等議題，並以 Power-Aware Architecture 闡述未來 Gigabit 發展時應具備之節能觀念
與趨勢。 
 
圖一: Keynote Speech 
 4
NJIT(USA)及 UBC(Canada)研究團隊對於我們研究團隊發展方向與人才培育有相當大的興趣，
同時也洽談未來共同進行研究議題，由此可更加肯定我們研究團隊的努力與成果。日後我們可藉
由本次與會議經驗，繼續發展未來的研究方向與研究領域。 
 
三、建議 
     CHINACOM 國際會議每年定期於中國的大學舉辦，會議中匯集了各國相關研究領域的教授及
研究人員，但會議中非華人之與會人員甚少，若能夠聚集全球(華人及非華人)的研究人員參與此
國際研討會，將可結合國內外研究能量探討未來通訊網路系統之相關研究。建議國內學者參與此
會議前先評估非華人研究人員參與比率，以評估與會將可獲得之交流效益。 
 
四、攜回資料名稱及內容 
     Conference Proceedings(CD)一片，內含 Program Committee 成員資料、會議 Keynote 報告
投影片，各 Session 之報告論文檔案資料。若國內專家學者有需要上述資料可向本人索取(E-mail: 
Lchen@mail.ntust.edu.tw;02-27376743) 亦 可 至 website: 
http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=5672531 下載。 
 
五、其他 
感謝國家科學委員費經費補助參加此國際會議，受益良多。 
An Adaptive QoS Mechanism for Multimedia 
Applications over Next Generation Vehicular 
Network 
Jiann-Liang Chen 
Dept. of Electrical Engineering, 
National Taiwan University of Science 
& Technology, 
Taipei, Taiwan. 
lchen@mail.ntust.edu.tw 
Yi-Wei Ma, Yueh-Min Huang 
Dept. of Engineering Science,  
National Cheng Kung University,  
Tainan, Taiwan. 
n9897106@mail.ncku.edu.tw 
huang@mail.ncku.edu.tw 
Qing-Tai Yang 
Institute of Electronic Engineering,  
National Dong Hwa University,  
Hualien, Taiwan. 
 
 
Abstract—This study develops a novel IEEE 802.21 MIH (Media 
Independent Handover) mechanism for next generation vehicular 
multimedia network. An adaptive QoS management mechanism 
is also proposed. By obtaining received signal strength 
parameters, the proposed MIH framework can determine the 
best available network. The adaptive QoS mechanism 
substantially improves the performance of real-time multimedia 
applications. The simulation results show that average handover 
time is slower than both UMTS and WiMAX when the MIH 
mechanism is used in vehicular network. However, the simulation 
results confirm that using the IEEE 802.21 MIH mechanism can 
increase overall throughput. Increased throughput is satisfactory 
compensation for increased handover time. 
Keywords-Vehicular Network; Next Generation Network; 
Media-Independent Handover; Quality of Service. 
I.  INTRODUCTION 
Future vehicular networks may require mobile devices to 
cross over different servicing locations. Maintaining network 
services requires seamless integration of different networks. An 
in-vehicle user roaming between different wireless 
communications technologies requires efficient handover 
between different networks and continuous connections of 
applications in the different networks. However, advanced 
multimedia services require increasing network bandwidth and 
improved quality. To satisfy the high quality requirements of 
heterogeneous vehicular network users, an effective QoS 
mechanism is needed.   
The rapid deployment of the wireless networks now enables 
MN (Mobile Node) to provide continuous internet access when 
it is moving. An MN located in an access network with weak 
strength must optimize network quality by performing 
handover conversion. In the past, MN could only provide 
handover in homogeneous networks. This technique does not 
enable the balance of network load into different networks. 
Figure 1 shows how MN can access different networks in a 
next-generation network architecture that includes 3G and 
WiMAX access technologies. When MN moves across 
different wireless networks, handover procedure automatically 
performs network optimization [1].  
 
Figure 1.  Vehicular Network 
This study designs MIH functions and then embeds them 
into OSI layers to support multimedia applications over 
heterogeneous networks [2]. The MIH layer supports handover 
processing for in-vehicle users. This study also enhances the 
application layer by developing a network management module 
that contains an adaptive QoS mechanism needed for high-
quality multimedia services. 
II. BACKGROUND KNOWLEDGE 
Overlapping networks provide alternative wireless links 
such as WLAN and 3G. Mobile users are connected to the best 
network according to predefined priorities. Dynamic network 
accesses technologies are still needed to improve the 
distribution of network resources standards have been 
developed to support dynamically roaming users in 
heterogeneous network environments.  
A. IETF Network Mobility 
The SIP is a flexible, multi-purpose signaling protocol for 
session-based communications in IP networks. Since the SIP 
only handles the session management phase, different 
communication applications can be used after the session has 
2) Network Layer: This layer adopts IETF-related 
protocols for various interface communications needed in the 
heterogeneous network environment. This layer communicates 
with MIHF layer via the MIH_SAP interface. 
3) Transport Layer: The study adopts voice-related 
protocols in this layer. The SCTP, which is the major channel 
for voice transmissions, to avoid making use of multi-homing 
properties not interrupt between wireless network and wired 
network. In application layer makes use of SIP, adopting UDP 
that delivers SIP control message and response. 
4) Application Layer: The application layer includes the 
administrator interface, SIP services and Management Module. 
Administrator interface is referred to as a communication 
interface between system and user and  responds to requests to 
transmit information. The SIP services send and receive SIP 
messages. When the system starts, the module sets up an 
external receiver channel and proceeds to SIP registration and 
also provides current contact information The study proposes 
Management Module as Handover Mechanisms, proceeds 
handover procedure that selects the appropriate network by 
MIHF layer. 
5) MIHF Layer: The study adds an MIHF layer in between 
Network layer and Lower layer. The MIHF layer provides 
assists the user during  mobility management and handover 
process. The MIHF layer includes three service modules: 
MIES, MICS and MIIS. 
B. MIH General Architecture 
This proposed IEEE 802.21 architecture defines three 
service modules to facilitate inter-technology handovers in 
Media-Independent Handover Services. 
The MIES provides lower layers information to upper 
layers, and upper layers drive handover mechanisms. The IEEE 
802.21 protocol sets up numerous events and respondent 
messages for lower layers, and the upper layers use these 
messages during handover between two systems. When the 
lower layers sets up events, it sends related messages to upper 
layers by network and also provides handover mechanisms. 
The proposed MIES in this architecture can integrate the 
original handover mechanisms to enhance system handover 
efficiency.  
The MICS allows effective management and control of 
different interfaces. During service system handover in the 
heterogeneous environment, inform user to use parameters and 
data that proceed to reserve resource, hence user have sufficient 
handover resources. The study proposes the use of MICS 
architecture, and the management module can horizontal 
handover, making use of BSs to ensure speedy handover. 
The MIIS provides the framework and corresponding 
mechanism needed for MIH services to discover available 
neighboring network information. Other neighbor system 
related-information, including transmission frequency, system 
type, and system operator set up and the BS is needed by the 
user to determine which neighboring network can supply in 
service ranges, and the BS can then perform network topology 
acquisition. The proposed IEEE 802.21 protocol can be used by 
all of the various systems. In the experimental setup, the 
independent MIIS server provides all MIIS service system in 
the network environment. 
C. Proposed Management Module 
Figure 4 shows the Management Module for the proposed 
architecture. The lower MIHF information layers pass through 
the upper layers. The Management Module divided into three 
functions: Handover Mechanism, Signal Control and Network 
Parameters. 
 
Figure 4.  Proposed Management Module 
 The MIH aims to provide upper layers with the network 
parameters relevant to the lower layers. Since the terminal can 
access several network systems simultaneously, the proposed 
Handover Mechanism selects f networks handover candidates. 
The study proposes a handover algorithm in the Handover 
Mechanism module, and Handover Mechanism determines to 
implement the mechanism that must get the relevant network 
parameters in Network Parameters module.   
The module is responsible for communicating MIHF 
information. Signal control through MIES enables the 
Management Module to perform network handover.  Handover 
Mechanism determines Signal Control parameters to receive 
MIIS information in Network Parameters Module. When the 
Management Module has passes through the Signal Control to 
send MICS information. The terminal changes connection from 
WiMAX system to UMT system. When the terminal transmits 
WiMAX RSSI ratio lower than the threshold, the MIHF sends 
„Link Going Down‟ signal to Management Module. The 
Management Module then sends out MICS to MIHF, and 
MIHF sends nearby environmental parameters to Management 
Module, and the Management Module passes through the 
Handover Mechanism selects the next target as handover 
procedures in UMTS system. When the UMTS set up is 
complete, the SIP has proceeds to session movement that 
provides the user for SIP service. 
The module stores with management module proceeding 
before the handover mechanism determine relevant network 
parameters. The terminal has a network interface that enables 
mobility in heterogeneous networks. The terminal can therefore 
cover different network systems simultaneously. The module 
stores with MIIS terminal and dynamic network information. 
Users indicate their specific requirements when setting up 
different QoS network parameters. The study adopts the 
following parameters: dropping, jitter, bandwidth and RSSI. It 
provides Handover Mechanism to select appropriate network 
algorithms. 
05
10
15
20
25
30
35
40
0 10 20 26 28 35 45 55 65 75 85 95 105 115
Vehic le  number
S
ys
te
m
 th
ro
ug
hp
ut
 (M
bp
s)
MIH-based
UMTS
WiMAX
 
Figure 5.  System Throughput 
T otal Mobile Node Handover T ime
0
10
20
30
40
50
0 10 20 30 40 50 60 70 80 90 100 110 120
simula tion time (sec )
H
an
d
o
ve
r 
T
im
e 
(m
se
c)
MIH-based
WiMAX
UMTS
 
Figure 6.  Handover Time 
The simulation indicated that, compared to the homogenous 
network, the proposed MIH Management Module obtained a 
46.13% longer handover time and 27.1% larger throughput. OR 
The simulated MIH Management Module obtained a 46.13% 
longer handover time and a 27.1% larger throughput than the 
homogenous network did.  
V. CONCLUSIONS 
This work designed an IEEE 802.21 MIH mechanism, 
which was then embedded into OSI layers. This work also 
designed the management module and adaptive QoS 
mechanism to improve service performance. The simulation 
results confirm the effectiveness of the proposed module for 
vehicular network. The simulation results show that average 
handover time is slower than both UMTS and WiMAX when 
the MIH mechanism is used in vehicular network.  However, 
the simulation results confirm that using the IEEE 802.21 MIH 
mechanism can increase overall throughput. Increased 
throughput is satisfactory compensation for increased handover 
time. By the using of Management Module with adaptive QoS 
mechanism, the proposed module enables users to manage 
Video/VoIP applications in high-quality network environments.     
REFERENCES 
[1] T.Y. Chung, F.C. Yuan, Y.M. Chen, B.J. Liu and C.C. Hsu, “Extending 
Always Best Connected Paradigm for Voice Communications in Next 
Generation Wireless Network,” Proceedings of the 22nd International 
Conference on Advanced Information Networking and Applications, 
pp.803-810, March 2008. 
[2] G. Lampropoulos, A.K. Salkintzis and N. Passas, “Media-Independent 
Handover for Seamless Service Provision in Heterogeneous Networks,” 
IEEE Communications Magazine, Vol.46, No.1, pp.64-71, January 2008. 
[3] V.S. Abhayawardhana and R. Babbage, “A Traffic Model for the IP 
Multimedia Subsystem (IMS),” Proceedings of the IEEE 65th Vehicular 
Technology Conference, pp.783-787, April 2007. 
[4] A. De La Oliva, A. Banchs, I. Soto, T. Melia and A. Vidal, “An 
Overview of IEEE 802.21: Media-independent Handover Services,” 
IEEE Wireless Communications, Vol.15, No.4, pp.96-103, August 2008. 
[5]  L. Eastwood, S. Migaldi, Q. Xie and V. Gupta, “Mobility using IEEE 
802.21 in a Heterogeneous IEEE 802.16/802.11-based, IMT-advanced 
(4G) network,” IEEE Wireless Communications, Vol.15, No.2, pp.26-34, 
April 2008. 
[6]  K. Taniuchi, Y. Ohba, V. Fajardo, S. Das, M. Tauil, C. Yuu-Heng, A. 
Dutta, D. Baker, M. Yajnik and D. Famolari, “IEEE 802.21: Media 
Independent Handover: Features, Applicability, and Realization,” IEEE 
Communications Magazine, Vol.47, No.1, pp.112-120, January 2009. 
[7]  W. Ying, Z. Yun, Y. Jun and Z. Ping, “An Enhanced Media 
Independent Handover Framework for Heterogeneous Networks,” 
Proceedings of the IEEE Vehicular Technology Conference, pp.2306-
2310, May 2008.  
[8]  G.P. Silvana and H. Schulzrinne, “SIP and 802.21 for Service Mobility 
and Pro-active Authentication,” Proceedings of the Communication 
Networks and Services Research Conference, pp.176-182, May 2008.  
[9]  M.I. Corici, A.F. Murarasu, S. Arbanowski, T. Magedanz, S. Lee and X. 
Liu, “Multimedia Mobility Service Solution,” Proceedings of the IEEE 
Vehicular Technology Conference, pp.1-5, September 2008. 
 
99 年度專題研究計畫研究成果彙整表 
計畫主持人：陳俊良 計畫編號：99-2219-E-011-006- 
計畫名稱：跨層式感知與協力 4G-IMS 無線網路研究--子計畫三:跨層式感知與協力 4G-IMS 無線網路之
服務品質與資源管理研究(3/3) 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 100%  
研究報告/技術報告 1 0 100% 
跨層式感知與協
力 4G-IMS 無線網
路之服務品質與
資源管理研究 
研討會論文 0 0 100% 
篇 
 
論文著作 
專書 0 0 100%   
申請中件數 0 0 100%  專利 已獲得件數 0 0 100% 件  
件數 0 0 100% 件  
技術移轉 
權利金 0 0 100% 千元  
碩士生 3 3 100% 
楊佩嘉、鄭秉昇、
張新毅  
 
博士生 1 1 100% 馬奕葳 
博士後研究員 0 0 100%  
國內 
參與計畫人力 
（本國籍） 
專任助理 0 0 100% 
人次 
 
國外 論文著作 期刊論文 2 0 100% 篇 1.Design and 
Integration of 
the OpenCore 
Based Mobile TV 
Framework for 
DVB-H/T Wireless 
Network 
(Publisheded in 
ACM Multimedia 
System Journal)
2.Cross-layer 
and Cognitive 
QoS Management
yielding an emulation test-bed of 4G-IMS based on integrated open 
platform. The emulation of LTE physical layer is accommodated by Takada 
Lab to provoke QoS parameter to the core network. Thereupon, through 
modified NetFPGA platform, the test-bed system is combined with 
constructed EPC/IP core networks and OpenIMS network. 
 
3.Enhance academic learning and teaching methodology of graduate level 
courses such as wireless networks, and multimedia communications in 
NTUST. Teaching and giving experimental examples through openIMS trigger 
student’s motivation, creativity and eagerness to independently 
explore the teaching materials and conducting their own research. 
Moreover, the result from this project will help the student to 
understand research methodology, especially in conducting performance 
evaluation toward their research proposal on an emulated network. 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
 
