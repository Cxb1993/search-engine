 I 
 
目錄 
 
目錄...........................................................................I 
圖目錄.......................................................................III 
表目錄.......................................................................IV 
 
第一章 導論...................................................................1 
1.1 前言.................................................................1 
1.2 研究背景.............................................................1 
1.3 研究動機與目的.....................................................3 
第二章 文獻探討..............................................................5 
    2.1 公平交換.............................................................5 
    2.2 離線型(Off-line)可信任第三方........................................5 
    2.3 身份識別基的密碼系統...............................................5 
    2.4 身份識別基的雙線性配對............................................6 
    2.5 交換的不可誤用性....................................................7 
 2.6 多方公平交換........................................................8 
  2.6.1 多方公平交換之完全連接圖....................................8 
  2.6.2 多方公平交換之環狀(Ring)架構................................8 
  2.7 多方公平合約簽署使用 PCS 簽章....................................9 
  2.8 並存簽章............................................................9 
   2.9多方公平合約簽署使用 PCS簽章協定...............................10 
第三章 研究方法.............................................................17 
     3.1 前言................................................................17 
  3.2 基本模型...........................................................17 
  3.3 身份識別基的確認簽章方案........................................21 
  3.3.1 雙線性配對之回顧.............................................21 
    3.3.2 建構細節.....................................................22 
   3.3.2.1 來自雙線性配對的確認承諾............................22 
            3.3.2.2 建構確認簽章的示範...................................25 
  3.3.3 安全性分析....................................................29 
     3.4 身份識別基的確認多重簽章與合約簽署的先進的協定.............37 
  3.5 具身份識別基之多方公平交換協定................................41 
第四章 實作成果.............................................................49 
 4.1 開發環境...........................................................49 
 4.2 程式介面介紹......................................................50 
 III 
 
 
圖目錄 
圖 1 逐步釋放秘密之公平交換…………………………………………………….1 
 
圖2 線上型TTP公平交換………………………………………………………….2 
 
圖3 離線型TTP公平交換………………………………………………………….3 
 
圖 4 完全連結圖架構……………………………………………………………….8 
 
圖 5 環狀(Ring)傳輸示意圖………………………………………………………..9 
 
圖 6 Mukhamedov 與 Ryan 訊息傳輸模式(5 人為例) ……………………………11 
 
圖 7 確認簽章(簽署以及簽署證明程序) ……………………………………...…27 
 
圖 8 確認簽章(確認程序) ………………………………………………………...27 
 
圖 9 確認簽章(轉換程序) ……………………………………………………...…29 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 1 
 
第一章 導論 
1.1 前言 
在網際網路快速發展下，電子商務的發展的議題備受矚目。如何在網路上實
現公平交換的機制顯得非常重要。所謂的公平交換(fair exchange)即是指網路上交
易的雙方公平地交換對方所需的資料，目前較熱門的電子商務應用，例如: 網路
競標、網路拍賣、網路付款、合約簽署等。公平交換的訴求是交易的雙方皆可獲
得所需的資料或是兩者都得不到任何資訊。在過去傳統的交易方式是面對面的方
式來進行交換，而利用網路來進行交換，在交易的過程中可能是不認識的雙方，
所以在交換的過程當中充滿的不確定性，例如: 欺騙、假冒、篡改等。所以在網
路上進行交易，其安全問題是一大問題，因此顯得公平交換機制的重要性。 
 
1.2 研究背景 
公平交換的議題，早期的交換方式大致上分為兩種，一種為逐步釋放秘密，
另一種則為同步交換秘密，由於上述兩種傳輸方式，在交換過程中是以一次一個
位元(bit by bit)的方式傳輸，示意圖如圖 1，因每次雙方只釋放出的資料只有一小
部分，因此其所需執行回合數較多，如果要交換的是非常大量的訊息，則在這樣
的方法下在效率上會顯得非常差，所以這樣的方式並不適合，以現今的技術來說
很少在談論此方式的交換。而近期的兩人公平交換有提出更有效率的方式來交
換，可分為兩種型式，一種為使用線上型可信任第三方(On-line TTP)，另一種則
為離線型可信任第三方(Off-line TTP)。 
 
Bit by Bit
f (Alice的秘密)
f (Bob的秘密)
Alice Bob
 
圖 1: 逐步釋放秘密之公平交換 
 
若要有效率的公平交換，則我們需要一個可信任的第三方(Trusted Third 
Party，稱為 TTP)來介入協定，來幫助解決紛爭。最簡單的方式是使用線上行的
可信任第三方來完成公平交換的機制。線上型可信任第三方(On-line TTP)[18、
52]，其交換方式為，交換的雙方在每次進行交易時，把資料傳給可信任的第三
 3 
 
TTP
Alice Bob
雙方正常交換程序
解決紛爭
程序
 
圖 3: 離線型 TTP 公平交換 
 
在這樣的協定下，在正常下是順利完成協定，紛爭的狀況為少數，因此，這
樣的設計使得有效的降低TTP的負擔。通常這類的技術伴隨著複雜的密碼技術，
例如: 可驗證加密訊技術(Verifiable Encrypted Message，VEM)[45]，加密訊息為
簽章之憑證(Certificate of Encrypted Message Being a Signature，CEMBS)[6]等。 
 
另外，在 2000 年 Asokan[4]等人提出最佳化的公平交換(Optimistic Fair 
Exchange)簽章。其主要的概念為，交換的雙方中，其中一方不能讓另一方無限
期的等待接收資料訊息，必頇在一定的時間限制底下進行公平交換。此交換的傳
輸方式為非同步的。此最佳化的公平交換通常伴隨著兩個子程序。(1)中止程序
(Abort) (2)解決程序(Resolve)。當交易的雙方中，有某一方為惡意者，則可能造
成誠實方無限期的等待資料訊息的接收，或是沒收到所需要的資料訊息，或收到
錯誤的資料訊息，此時誠實的一方會透過可信任的第三方來執行兩個子程序來解
決雙方的爭端，讓雙方獲得所需的資料訊息，或是雙方都無法獲得任何東西。 
 
1.3 研究動機與目的 
就目前文獻來看，能是以兩方公平交換為主。然而，在實際應用上，引入多
方公平交換技術是必要的。因為在應用上除了雙方的公平交換外，另外有網路競
標、網路拍賣、合約簽署、電子投票等應用是需要多方公平交換技術的引入來實
現。而在許多文獻所提出的兩方公平交換協定要延伸至多方公平交換是不容易
的。例如，Asokan等學者直接將雙方公平交換的模型延伸至多方公平交換[2]，
造成其傳輸數量接近 n2，效能上明顯不佳。另外，有其他學者提出環狀(Ring)
的架構來降低其通訊的數量，但，若是參與者很多時是否在此架構下能真正達到
 5 
 
第二章 文獻探討 
2.1 公平交換 
  在商業的交易中，合約簽署是一個不可或缺的工具。一份合約，通常描
述計畫、規格與交換的雙方必頇承擔的責任。雙方同時在紙上簽屬同意，且
簽上名字。然而，如果雙方在網路上簽署合約，則可能會出現欺騙的行為。
交換的每一方都會擔心，在他送出自己的簽章後將有可能會收不到另一方的
簽章，這是因為網路是在一個無法無天的環境下的不安全傳送通道。同樣
地，如何使得網路合約簽署達到公平性，逐漸成為一個重要的議題。交換簽
章的公平性，意旨在最後的交換程序，簽約的雙方都能獲得他們所想要的簽
章，或是雙方都接收不到任何簽章的訊息。 
 
2.2 離線型(Off-line)可信任第三方 
   公平交換的簽章可以用來履行合約簽署的需求。然而，在先前的文獻中
已解決了關鍵的效率上的問題。在早期所提出的方法中，是同時逐步地交換
秘密訊息[9、19、34]，很顯然的，此交換方式是不切實際的且不適合交換
大量的訊息。一個現代的方法需要參與一個可信任的第三方(TTP)來維持協
定的公平性。一個直接的方法是使用線上型的可信任第三方 (on-line 
TTP)[18、20、53]。無論交換的雙方是否有糾紛產生，TTP 所扮演的是一個
傳遞者的角色，在每一次的傳輸過程中都需要 TTP 的參與。另外，在其他
許多的文獻中，提出一個更複雜的技術，稱為離線型的可信任第三方(off-line 
TTP)[1、4、6、11、17、16、25、37、43、41、46、53]，此 TTP 所扮演的
角色為紛爭解決者，是來處理交換雙方所產生的糾紛。當交換的雙方在協定
中，出現錯誤或是發生糾紛時，此時才會請求 TTP 參與此協定來解決雙方
的紛爭。 
 
2.3 身份識別基的密碼系統 
  許多簽章的公平交換協定是基於憑證為基礎的公鑰加密。本文中提出一
個不同的模塊。身份識別基的密碼系統是一個很好的典範，該系統可以利用
使用者的身份來取代公鑰。此系統可以簡化鑰匙管理程序以及排除使用者所
使用的證書。此身份識別基的密碼系統的概念在 1984 年由 Shamir[40]所提
出，但真正實際的方案包括加密、金鑰管理和數位簽章，等文獻[10、12、
27、29、44、51]從 2001 年才開始被提出，因為一個新的加密基本元件: 雙
線性函數，提供了一個絕妙的性質，此性質是以特定的用戶身分建造出一個
相對應的私鑰。利用雙線性函數計算的身份識別基的簽章方案有兩個好處: 
 7 
 
的加密參數而不是基於憑證的參數。這是值得注意的問題，因為我們不想在
一個系統裡有兩個不同密碼的金鑰管理機制。除了上述所提之外，Gu 等學
者[26]提出另一個基於雙線性配對的方案。但是，在他們的方案中，可信任
的第三方需要扮演一個可信任的中心去計算出使用的私鑰，因而降低了 TTP
的選擇性。而且 TTP 一旦遭破解，將增加許多的危險。 
 
   在本計劃中，我們提出一個透過雙線性配對的身份識別基的證實簽章系
統(Confirmation Signature Scheme)，去發展出一個新的公平交換協定。證實
簽章的基本的建構區塊的優點是，包含可信任第三方的每一方，可以使用他
們的身份(ID)當成是公開的資訊。證實簽章最初是由 Chaum[13]在 1994 年所
提出，且原名為指定證實者簽章(Designated Confirner Signature)。透過與原
簽署者合作來驗證簽章解決問題。證實簽章系統有兩個不可轉移的零知識證
明(non-transferable zero-knowledge proofs)，也就是簽署者證明和證實程序，
並有非交互式證明，也就是轉換程序。一個指定證實者可以在之後去證明簽
章的正確性，或是即使缺少了簽署者，指定證實者會把簽章轉換成一般可驗
證的簽章。我們特別把焦點放在轉換的特性上，因為在建構一個公平交換協
定中，它是其中一個主要構成要素; 那就是，只有在當簽章已經被轉換後，
證實簽章才可以被任何人驗證。 
 
   Libert 和 Quisquater[29]提出一個身份識別基的不可否認簽章方法，但他
不符合我們的目標。儘管[29]有證明和轉換程序，他們只有透過簽名者才可
以這樣做。至於簽章的公平交換，有一種可能性，就是簽名者就是一個欺騙
者。同樣地，直接應用 Libert 和 Quisquater 的方法在和同簽署協定中，當交
換的雙方發生紛爭可能會導致轉換程序失敗。一個新被提出的證實簽章系
統，使用[29]的概念，然而是透過使用雙線性的特性來賦予指定證實者有證
實和轉換的能力。 
 
2.5 交換的不可誤用性 
   在基於證實多重簽章的一個擴展的合約簽署協定在本文中被提出。它擁
有了一個優點，此優點在於協議的最後，把兩個交換簽章合併成單一大小的
簽章，這可證明雙方都已簽署了合約。在先前的文獻中，這類的協定從來沒
有被討論過，例如[11]和[17]。此外，我們的協定也滿足了不可誤用(abuse-free)
的需求，不可誤用的合約簽署被 Gary[25]所提出。一個類似的概念也出現在
[23，47]。不可誤用的特性，指的是沒有簽署的一方可以去向第三方證明其
他簽署者願意在合約上簽字，但自己卻不簽字。簽署雙方都不能這樣做，直
到雙方皆已簽署了此份合約(雙方都已完成公平交換的程序且得到了對方的
在合約上的真正簽章)。由於我們的證實簽章提供不可轉移(non-transferability)
 9 
 
料正確無誤再把資料廣播出來。而 Bao 等學者所使用為離線型可信任第三方，
在正常情況下，每位使用者透過 Ring 的交換方式傳輸資料，若是有一方為惡意
的一方，破壞此協定，使得接收的資料非其所需，或是沒收到任何資料，則此時
TTP 會參與協定來進行紛爭處理。 
P1
P5
P3 P4
P2
TTP
 
圖 5: 環狀(Ring)傳輸示意圖 
 
雖然在使用環的架構簡單且有效率，可是並未符合我們所需的應用。 
 
2.7 多方公平合約簽署使用 PCS 簽章 
另外，我們參考其他離線型的可信任第三方模式的協定，在 1999 年由 Garay
與 MacKenzie[24]提出的協定，其協定利用 PCS 簽章技術[25]來保證達到防止誤
用(Abuse-free)的功能。但是，在 2004 年 Chadha 等學者[15]提出在 Garay 與
MacKenzie 的協定中如果 4n  則將會失去其公平性，並提出了修改。 
 
在 2007 年，Mukhamedov 與 Ryan [31]提出攻擊 Garay 與 MacKenzie 所提出
的協定，他們提出一樣使用 PCS 簽章技術的一個新協定，且其通訊的訊息量比
Baum-Waidner 與 Waidner 所提出的方法少了一半。其方法是利用串接式結構的
PCS 概念，前面 / 2n  回合傳遞不同層級的 PCS(號數小(下面的)的傳送 PCS 給
號數大的，號數大(上面的)的傳 PCS 給號數小的)，之後 / 2 1n    回合中，使用
者傳送 PCS 連同簽章一起傳送。 
 
2.8 並存簽章 
之後，在 2004 年由 Chen, Kulda, Paterson 學者所提出並存簽章(Concurrent 
 11 
 
不誠實的簽署者的聯合所可以做到的總要求數，這是為了傳播可信任方的中止決
定。 
 
圖 6. Mukhamedov 與 Ryan 訊息傳輸模式(5 人為例) 
 
 該協定開始於每位簽署者等待來自號數小的(下面的)簽署者的 1-level 諾
言。在收到這些諾言後，他送出他的 1-level 諾言給他號數大的(上面的)簽署者。
然後他在等待來自上面的(號數大的)諾言，並在收到後，送出他的 1-level 諾言給
他之下的(號數小的)，並完成一個回合。這個順序是重複在 r-level 的諾言中，範
圍從 2 到 / 2n  。最後，在最後一回合 / 2 1n    -level 中，諾言以及簽章才一起
被交換。該協定正式定義在表 1 中。 
 
 若沒收到所要的訊息，則參與者 Pi 就放棄該協定，或是向 T 要求中止或解
決紛爭，主要是根據 Pi是在主要協定中的位置。 
 
 當 Pi 請求中止時，則 Pi 傳送訊息給 T。訊息為 
1 1(( , , ( ,..., ), ))iP nS m P P P abort  
為了請求解決紛爭，則 Pi 傳送 
  {1,..., \{ }
({ (( , ), , } , ( , ))
i j iP P j i j n i P
S PCS m P T S m o   
給 T，凡是對 j > i
 
而言， j 是來自收到所有簽署者 'jP ( j’ > i )的諾言的最大的
level，而 i > j 而言， j 是來自收到所有簽署者 'jP ( i > j’ )的諾言的最大的 level:  
 13 
 
的諾言給其他簽署者。很直觀地， ( )ih m 是表示 Pi 可以往上傳送給號數大(上面的)
的任何一位簽署者的最高 level 的諾言，且相同地，li(m)是表示 Pi 可以往下傳送
給號數小(下面的)的任何一位簽署者的最高 level 的諾言。此建構的靈感是參考
來自於 Chadha 等學者[15]的文獻。 
T 根據需求去執行中止或是回復的協定。 
 
 中止協定 
當 T 收到由 Pi 傳送過來的中止訊息，則 T 把 i 加入集合 S(m)中。若是此協
定已經成成功地執行過回復的動作，則 T 回傳一個已簽署過的合約給 Pi; 否則，
T 就回傳一個中止的標記給 Pi。該協定正式定義在表 2。 
 
 回復協定  
T 所收到的回復訊息是被設計過的，此設計使得 T 可以推斷一個誠實的簽署
者可以傳送什麼樣的諾言且是否先前所有的要求都是由不誠實的簽署者所做
的，該協定正式定義在表 3。此協定的執行如下: 
(1) T 檢查所有的諾言與簽章皆是有效的，且無論諾言是由號數大(上面的)或是  
號數小(下面的)的傳過來的都是一致的。若是有檢查出任何錯誤，則 T 忽略
掉傳送過來的回復要求。 
(2) 如果在先前沒有對 T 查詢 m 的記錄，例如: 把 validated 設定為 false，則 T
得到一個簽署的合約，此合約是透過將包含在回復要求中的所有諾言轉換成
一般可驗證的簽章。T 將已簽署的合約存放在自己的資料庫中，且將此簽署
合約傳送回請求的答覆，並把 validated 設定為 true。 
(3) 假如在回復要求之前，T 就已經有過回復過的動作，例如 validated 等於 true，
則 T 將會傳送回存在資料庫裡的已簽署合約。 
(4) 假如在回復要求之前已經有人提出中止的要求，且 T 也允許此中止的要求，
亦或是如果 T 推斷先前所有的要求是由不誠實的簽署者所做的，則此時 T 會
答覆一個中止的記號或是推翻先前所決定的中止要求。來自 Pi 的回復請求
中，T 可以推斷 Pj 是不誠實的，原因是因為如果 Pi 呈現給 T 一個由 Pj 所產生
的諾言，這表示 Tj 向 T 提出要求之後還繼續協定的執行。 
 
此協定滿足了時效性，因為所有的簽署者可以選擇在任何時間點停止等待接
收訊息(停止，請求中止或是回復)。其相關的證明，與安全性上的分析在此不多
加討論，請參考[31]有詳細的證明。 
 
 
 
 
 
 15 
 
   if 他們中的任何人沒及時的接收到諾言 then 請求回復協定。 
表 2 中止協定(fro T) 
T 首次為了合約 m 而被聯繫(無論是中止或是回復)，首先 T 將集合 S(m)初始化設
定為且 validated 設定為 false。 
if T 收到來自 Pi 的中止訊息 1( , , ( ,..., ), )iP i nS m P P P abort 的請求 
 T 首先檢查簽章是有效的 
 if 還未經過驗證 then 
  if S(m)=   then T 將 1( ( , , ( ,..., ), ))T Pi i nS S m P P P abort 存到資料庫中 
  把 i 加入集合中 ( ) ( ) { }S m S m i  
  將 hi(m)設定為 1; li(m)設定為 0 (li(m)=1; li(m)=0) 
  T 傳送存在資料庫中的訊息
1( ( , , ( ,..., ), ))jT P j nS S m P P P abort 給 Pi 
   在此 Pj 是第一個提出中止協定的參與者 
else 
 T 傳送簽章
{1,..., }\{ }{ (( , ))}jP j j n iS m   給 Pi 
在此 j 是來自 Pj 所傳送過來的諾言的 level，而此 level 的諾言是已在回 
     復協定中經過轉換成一般可驗證的簽章。 
 
表 3 回復協定(for T) 
T 首次為了合約 m 而被聯繫(無論是中止或是回復)，首先 T 將集合 S(m)初始化設
定為且 validated 設定為 false。 
if T 收到回復訊息
{1,..., }\{ }({ (( , ), , )} , ( ,0))i j iP P j i j n i PS PCS m P T S m   
檢查諾言與簽章是有效的，且來自號數大的(上面的)或號數小的(下面的)諾
言是一致的，例如: 
 對於所有 j< i，檢查 1j i    
對於所有 j> i，檢查 1j i    
再檢查 1 1 1 1  1i i i ior          
 if ( )i S m 或是上述的檢查，檢查出失敗的話 then 忽略訊息。 
  
else if 集合 S(m)= 然後 
  將 validated 設定為 true(validated:= true) 
 17 
 
第三章  研究方法 
 
3.1 前言 
合約簽署協定已經在先前的文獻中成功的被開發。然而，在許多已被提出的
協定中，是很難達到實用性與效率性這兩個重要的議題。由於基於身分的加密基
本元件，在金鑰產生階段，是透過使用在橢圓曲線上的雙線性函數之計算，使其
更有效率且實用。在本計畫中，我們提出了一種身份識別基與雙線性配對的合約
簽署協定。每個使用者(包含可信任的第三方)使用自己的身份當成是他的公鑰，
因此，金鑰管理程序就可以被簡化。除此之外，我們介紹一個新的建構方式，稱
為身份識別基證實簽章(identity-based confirmation signature，IDCS)，這使得合約
簽署協定的建構可以更靈活。此篇提出的協定，採用了離線型的可信任第三方
(off-line trusted their party) ，藉此來達到公平性。唯有當簽署的雙方產生了糾紛，
此時，可信任的第三方就會參與簽章交換程序，並且把IDCS轉換成一般可驗證
的簽章。 
 
首先基本模型與定義在下一節中給定。身份識別基與雙線性配對的證實簽章
連同其安全性分析在第3節中被提出。在第4節中我們提出一個先進的協定，此協
定是基於證實多重簽章方案以擴展我們的基礎協定來符合傳統紙本的合約簽
署。比較與效能評估的討論在第5節中被提出。 
3.2 基本模型 
在此章節，我們將討論身份識別基的公平合約簽署協定的基本模型。在安全分析
所用到的符號與定義也會在稍後給定。 
 
定義 3.2.1 一個身份識別基證實簽章 ),( mUIDCS CUS ，所簽之訊息為 m，需要滿
足以下條件需求： 
1. 該簽章可以被簽章者 US 所建構出來，利用簽章者的私鑰以及被指定的證
實者 UC 之 ID。 
2. 任何想要驗證此簽章的人都需要簽章者 US 或指定的證實者 UC的幫助才
能辦到。 
3. 簽署者 US 可以證明該簽章是有效的，而且存在一個指定的證實者 UC能
在稍後證明此簽章的有效性或是將證實簽章轉換為一般可驗證的簽章。
此身份識別基證實簽章包括以下三個程序： 
- 簽署者證明程序(Sig-Prv)：一個由簽署者 US 所做的不可轉移證明。
簽署者可以與被指定的驗證者執行此程序來證明簽章的有效性，但
 19 
 
行 A-Resolve Phase。 
 
Abort Phase 
 UA 透過以下的程序與 TTP 聯繫來中止該合約簽署協定： 
1. UA 傳送 m、UA、UB 和 ),,,( abortBAmSig
AU
給 TTP。 
2. TTP 驗證 ),,,( abortBAmSig
AU
並去檢查他所維護的 Ω 集合。若該簽章是
合法的，而且不管是 UA 還是 UB 都沒有要求要解決紛爭的話，TTP 就傳
送 )),,,(( abortBAmSigSig
AUTTP
給 UA ， 並 且 把 {m, UA, UB, abort, 
)),,,(( abortBAmSigSig
AUTTP
}加到 Ω 中。 
3. 若 UA 或 UB 有人要求解決紛爭的話，TTP 就會把存在 Ω 裡相對應的數值
傳給 UA。(請參閱下面兩個 resolve phases 中的第 4 步驟) 
 
B-Resolve Phase 
 UB 要求 TTP 執行下列步驟來解決紛爭： 
1. UB 傳 送 m 、 ),( mTTPIDCS
AU
、 ),( mTTPIDCS
BU
以 及               
Cver
BU
 ( ),( mTTPIDCS
BU
)給 TTP。然後 TTP 會去檢查這些訊息。若是驗
證成功，TTP 會繼續執行下面的步驟。否則，TTP 停止這個階段並輸出“錯
誤”訊息。 
2. 若 UA 已 經 要 求 中 止 ， TTP 會 傳 送 儲 存 在 Ω 集 合 裡 的
)),,,(( abortBAmSigSig
AUTTP
給 UB。 
3. 若 UA 已經要求解決紛爭， TTP 會傳送儲存在 Ω 集合裡的
AU
Cver ( ),( mTTPIDCS
AU
)給 UB。 
4. 若 UA 從未要求中止或是解決紛爭，TTP 會傳送 TTPCver ( ),( mTTPIDCS AU )
給 UB 。此外， TTP 會將 {m, UA, UB, B-resolve, ),( mTTPIDCS
BU
, 
BU
Cver ( ),( mTTPIDCS
BU
)}存入 Ω 集合中。 
 
A-Resolve Phase 
 21 
 
2. UB*選擇一個訊息 m，該訊息一定要與步驟 1 傳送給 S 的訊息不同。signing 
oracle S 產生一個針對 m 所做的簽章 A 。因此初始狀態的 UA 所擁有的輸
入有：IDTTP、IDA、IDB*、m 以及 A 。在這個階段，UB*無法得知 A 。 
3. UB*任意的與 TTP、S 和 UA 互動。然而，UB*無法傳送一個有關 m 的查詢
給 signing oracle S。此外，假設 UB*無法打斷或是延遲 UA 和 TTP 之前的
連結。 
4. 一段時間後，UA 停止並且輸出 * 'B ，而 *B 也同樣停止並且輸出 'A 。若
'A 是 UA 針對 m 所做的有效簽章，但是 * 'B 並不是 UB*針對 m 所做的有
效簽章，那麼 UB*就被認定為贏得這個 game。 
若 UB*贏得 game 的機率是可忽略的話，那這合約簽署協定就是公平的。 
 
定義 3.2.2 一個對手 UB*擁有 ε(k)的優勢去打破合約簽署協定 P 的公平性，若對
一個足夠大的安全參數 k 來說，以下式子成立 
)(Game]-Fairness  winsPr[)(Adv-F *, * kUk BUP B  。 
若 )(Adv-F
*,
k
BUP
是可以忽略的函數，則我們會說 P 是公平的。 
3.3 身份識別基的證實簽章系統 
在本節中，身份識別基的證實簽章方案的建構方式被提出。此方案是公平的合約
簽署協定的主要建構區塊之一部分。在下面的小節中，我們將描述它的具體實
施，並且分析其安全性。 
 
3.3.1 雙線性配對之回顧 
假設 G1 為一個加法群，而 G2 為一個乘法群，且兩群有相同的秩為質數 q。假設
P 是 G1 的任意一個生成子，這代表 qP = O，這裡 O 表示 G1 的零元素。假設同
時要在 G1 和 G2 下解決離散對數問題是很困難的。一個映射函數
2
1 2:e G G ，此
映射函數滿足下列特性，被稱為雙線性配對函數: 
1. 雙線性(Bilinearity): 令點 P、點 Q 屬於 G1，且 a，b 屬於
*
qZ 。則等式
( , ) ( , )abe aP bQ e P Q  成立。 
2. 非退化性(Non-degeneracy): 存在點 P、點 Q 屬於 G1，使得 ( , ) 1e P Q  。 
3. 可計算性(Computability): 任兩點 P，Q 屬於 G1，必存在一個有效率的演
算法可在多項式時間內計算 ( , )e P Q 。 
引理 3.3.1 (Diffie-Hellman 的假設與雙線性 Diffie-Hellman 的假設)假設 1 2( , , )G G e
做為先前所述。下面的問題定義如下: 
- Computational Diffie-Hellman Problem (CDH): 給定 ( , , )P aP bP ，其中 P 是 G1
 23 
 
方案[27]的證明將在下一小節中被提出。 
 來自雙線性配對的證實承諾有下列四個程序: 承諾，承諾者證明，證實和轉
換。 
承諾程序: Comm(UC, m) 
 承諾者UA使用證實者UC的身分IDC去建構針對訊息m的證實承諾。詳細步驟
如下: 
1. 承諾者隨機選取一個變數 r， *qr Z ，並計算 1R rP G  。 
2. 承諾者計算
1( )cID cQ H ID 以及 2( ( ) , )pub Ck e H m P rQID G  。 
承諾Comm(UC, m) = (R, k)。 
承諾者證明程序: Co-Prv(Comm(UC, m)) 
承諾者UA向指定驗證者UB證明，透過下列非交互式的證明，證明承諾是正確的
且之後可以被證實者UC 證實是正確的。 
1. 計算 1( )BID BQ H ID 。 
2. 隨機選取 1,U W G 與
*
qv Z 並計算 
2
2
2 2
( , ) ( , )
( , )
( ( ) , )
B
v
pub ID
pub
c e P U e P Q G
a e P W G
b e H m P W G
 
 
 
 
3. 計算 *3( , , , , , ) qh H c a b m R k Z  。 
4. 計算 1( ) CIDS W h v rQ G    。 
Co-Prv(Comm(UC, m))這證明被記為(U, v, h, S)，驗證者UB執行下列驗證步驟。 
1. 計算 2' ( , ) ( , )B
v
pub IDc e P U e P Q G  。 
2. 計算 2' ( , ) ( , )C
h v
IDa e P S e R Q G
  。 
3. 計算 2 2' ( ( ) , )
h v
pubb e H m P S k G
  。 
4. 驗證是否 3( ', ', ', , , )h H c a b m R k 。 
證實程序: Cfm(Comm(UC, m)) 
 證實者UC可以幫助另一個驗證者U’B驗證承諾。證實程序非常相似於承諾者
證明程序。下面所列的等式表示了證明的要素: 
  2 2 2( ( ) , ) ( ( ) , ) ( ( ) , )C C Cpub ID ID IDk e H m P rQ e H m rP sQ e H m R d   。 
 25 
 
2. 計算 2 2' ( ( ) , )
h
pubb e H m P S k G  。 
3. 驗證 4( ', ', ', , , )h H c a b m R k 是否正確。 
第二部分: 
CU
Cver - 證實者的轉換 
 證實者透過下面步驟來轉換簽章: 
1. 隨機選取一個變數 j，
qj Z 且計算 1J jP G  。然後計算 ( , )
je P P  以
及 2 2( ( ) , )e H m R J G   。 
2. 計算 *4( , , , , ) qH m R k Z    。 
3. 計算 1CIDX J d G   。 
這個證明 ( ( , )) ( , )
CU C
Cver Comm m U X 可以被普遍驗證。任何人都可以執行下列
步驟來驗證承諾，下列步驟相似於證實程序的驗證步驟，在沒有承諾者或證實者
的幫助下去驗證承諾。 
1. 計算 2' ( , ) ( , )cpub IDe P X e P Q G
   。 
2. 計算 2 2' ( ( ) , )e H m R X k G
   。 
3. 驗證是否 4( ', ', , , )H m R k   。 
3.3.2.2 建構證實簽章的示範 
在2002年，Hess[27]提出一個有效率且來自雙線性配對的身份識別基的簽章。他
的方法已經被證明安全並且可以擴展到更一般的型式。在下面，我們說明如何利
用我們的建構方法把Hess的方案轉換成證實簽章。 
針對訊息m所簽署出的證實簽章，簽署者UA隨機選取
*
1 1P G 與
*, qr Z  並計算 
1
1 2
5 2
6 1 1
( , )
( ( , ) , )
( , )
C
A
pub ID
ID
R rP G
t e P P G
k e H m t P rQ G
Z H R k d P G


 
 
 
  
 
證實簽章 ( , )
AU C
IDCS U m 被記為 1 2 1( , , ) ( , , )R k Z G G G 。 
簽署者證明程序 Pr ( ( , ))
AU C
Sig v IDCS U m 非常相似於在 3.3.2.1 章節中所提
到的承諾者證明程序。簽署者計算 5( ( , ) , )pubb e H m t P W ，然後計算 c, a, h 和 S，
 27 
 
2. 計算 *3( , , , , , ) qh H c a b m R k Z  。 
3. 計算
1( ) CIDS W h v rQ G    。 
這證明Sig-Prv ( ( , ))
AU C
IDCS U m =(U, v, h, S)。驗證者UB執行下列驗證步驟。 
1. 計 算 6 ( , ) 2' ( , ) ( , )A
H R k
ID pubt e Z P e Q P G   以 及
5 2' ( ( , ') , )
h v
pubb e H m t P S k G
  。 
2. 計算 2' ( , ) ( , )B
v
pub IDc e P U e P Q G  與 2' ( , ) ( , )C
h v
IDa e P S e R Q G
  。 
3. 驗證 3( ', ', ', , , )h H c a b m R k 是否正確。 
 
圖 7: 證實簽章(簽署以及簽署證明程序) 
 
證實程序 
證實者UC透過執行下面步驟來向另一個驗證者U’B證明。 
1. 隨機選定 1,L T G 與
*
qy Z 並計算 
6 ( , )
2
' 2
2
5 2
' ( , ) ( , )
( , ) ( , )
( , )
( ( , ') , )
A
B
H R k
ID pub
y
pub ID
t e Z P e Q P G
e P L e P Q G
e P T G
H m t R T G



  
 
 
 
 
2. 計算 *3( , , , , , ) qH m R k Z     。 
3. 計算 1( ) CIDX T y d G    。 
證實證明為Cfm ( ( , ))
AU C
IDCS U m = ( , , , )L y X 。驗證者U’B執行下面驗證步驟。 
1. 計算 6 ( , ) 2' ( , ) ( , )A
H R k
ID pubt e Z P e Q P G   與 5 2' ( ( , ') , )b e H m t R T G  。 
2. 計算 ' 2' ( , ) ( , )B
y
pub IDe P L e P Q G   與 2' ( , ) ( , )C
y
pub IDe P X e P Q G
   。 
3. 驗證是否 3( ', ', ', , , )H m R k    。 
 
圖 8: 證實簽章(證實程序) 
 29 
 
與
5 2' ( ( , ') , )e H m t R X k G
   。 
2. 驗證是否 4( ', ', , , )H m R k   。 
 
 
圖 9: 證實簽章(轉換程序) 
 
3.3.3 安全分析 
在本節中，我們討論所提出的證實簽章的安全性。我們假設 CDH 與 DBDH 是難
解的問題，並使用雜湊函數 H1, H2,…, H6 來建模為 random oracles，將在下列的
證明中描述。 
 現在，下面給定一些定義與定理。 
定義 3.3.1 (存在不可偽造性(Existential Unforgeable)) 假設 A表示一個攻擊者進
行下列 game。如果 A贏 game 戲的機率為: 
, Pr[  ]IDCS AUF Adv A  贏得不可偽造game  
是可忽略不計的話，我們就說身份識別基的證實簽章是存在不可偽造性來防禦適
合的選擇密文攻擊。 
[不可偽造性 game:] 
假設一個挑戰者 G可以透過使用一些 oracles 來模擬系統。挑戰者 G送出系
統的參數，此參數是由起始設置演算法(setup algorithm)所產生的，並把它傳給
A，為了贏得 game，攻擊者 A執行下列多次的查詢: 
 
1. 金鑰提取查詢: 攻擊者 A送一個身份 ID 做為查詢，並收到一個相對應的私
鑰 dID。 
2. 簽章查詢: 攻擊者 A傳送(ID, ID’, m)做為查詢，並收到在與身份 ID 一致的
私鑰下針對訊息 M 所產生的簽章。簽章可以透過證實者與他的身份 ID’被證
實。 
3. 簽署者證明/證實查詢: 攻擊者 A傳送(ID, ID’, m, )做為查詢。挑戰者 G執
行簽署者證明/證實協定去說服攻擊者 A  (與非轉移的證明)  是在與身份
ID 一致的私鑰下針對訊息 m 所產生的一個合法簽章。此外，在簽署者證明
查詢中，攻擊者 A相信 可以透過 ID’被證實。 
4. 轉換查詢: 攻擊者 A傳送(ID, ID’, m, )做為查詢，並收到一個普遍驗證的證
明可以去說服攻擊者 A， 是在與身份 ID 一致的私鑰下針對訊息 m 所產生
的一個合法簽章。 
 
一段時間後，攻擊者 A輸出一組參數(ID*, ID’*, m*, *)，其中 ID*與 ID’*
 31 
 
6 ( , )
6 1 6
6 1 6
1 1
' ( , ) ( , )
   ( ( , ) , ) ( ( , ) , )
   ( ( , ) , ) ( ( , ) , )
   ( , ) ( , )
A
A A
A A
H R k
ID pub
ID ID pub
ID ID
t e Z P e Q P
e H R k d P P e H R k Q P
e H R k d P P e H R k d P
e P P e P P 



 
  
  
 
 
5
5 5
5
' ( ( , ') , )
   ( ( , ') , ( ) ) ( ( , ) , ( ) )
   ( ( , ') , )
C C
h v
pub
pub ID pub ID
pub
b e H m t P S k
e H m t P W h v rQ e H m t P h v rQ
e H m t P W

   

 
再證實階段， 與  可以由下列等式獲得。 
' ( , ) ( , )
   ( , ( ) ) ( , ( ) )
   ( , ( ) ) ( , ( ) )
   ( , )
C
C C
C C
y
pub ID
ID ID
ID ID
e P X e P Q
e P T y d e sP y Q
e P T y sQ e P y sQ
e P T

 
 

   
   

 
5
5 5
5 5
5 5
5
' ( ( , ') , )
   ( ( , ') , ( ) ) ( ( , ') , ( ) )
   ( ( , ') , ( ) ) ( ( , ') , ( ) )
   ( ( , ') , ( ) ) ( ( , ') , ( ) )
   ( ( , ') , )
C C
C C
C C
y
ID pub ID
ID ID
ID ID
e H m t R X k
e H m t R T y d e H m t P y rQ
e H m t R T y d e H m t rP y sQ
e H m t R T y d e H m t R y d
e H m t R T

 
 
 

   
   
   

 
 
定理 3.3.2 (存在不可偽造性(Existential Unforgeability)) 在 CDH 難題的安全性假
設下，我們所提出的身份識別基的證實簽章是安全且可防禦相關存在的偽造。 
 
證明: 這個定理可以利用矛盾證法來證明。我們在 random oracle model 下證明，
如果存在一個攻擊者 A可以成功在我們所提的身份識別基的證實簽章執行相關
存在的偽造，然後存有一個演算法 G (以下我們稱他為一個”挑戰者”)有著不可忽
略的優勢，就可以利用攻擊者 A來解決 CDH 的難題。假設 G有一個 CDH 難題
的例子 ( , , )P aP bP ，其中 pubaP P 。 
 相關存在的偽造 game 已經在定義 3.3.1 中被描述。 
 下面簡要的描述所使用的 oracles，類似於文獻[21]中所提。 
 Hash oracle (H1): 為了模擬 H1，挑戰者 G選取 i qZ  與投擲一個硬幣
E。如果 E = 1，挑戰者 G回傳 1( ) ( )i iH ID bP ; 否則，挑戰者 G則回
傳 1( )i iH ID P 。然後挑戰者 G把參數 ( , , )i iID E  插入到名單 1HL 中。 
 33 
 
擬 ( , , , )L y X ，其中 ( ) 'i pubX T y P     
 轉換 oracle: 轉換 oracle 相似於簽署者證明/轉換 oracle。因此，我們在
這裡省略細節。 
 
文獻[27]中，可以被用來繼續進行這個剩餘的證明。而 game 的最後，攻擊
者 A輸出一組參數 * * * * * *( , ' , , , , )ID ID m R k Z 。然後挑戰者 G為 ID*檢查掃描名
單
1H
L 。如果挑戰者 G在名單
1H
L 中找到參數 * *( ,0, )ID  ，則輸出”失敗”並且
停止。現在我們應用文獻[36]中的引理。假設 A 重新執行 game 且獲得一個
不同的 * *
6( , )H R k 。最後，A 輸出另一組參數
* * * * * *( , ' , , , , )ID ID m R k Z ，這也
是 一 個 有 效 合 法 的 簽 章 。 從 這 兩 個 有 效 的 偽 造 看 來 ， 我 們 有
*
* * * * *
6 1( , ) IDZ H R t d P  與 *
* * * * *
6 1( , ) IDZ H R t d P  。因此，挑戰者 G可以
計算出
1
* * *
* * * *
6 6( , ) ( , )
Z Z
H R k H R k
 
 
 
這等式等於abP，也就是解決 CDH 難題
的例子 ( , , )P aP bP ，故得證。 
 
定理 3.3.3 (隱形性(Invisibility)) 在 DBDH 難題的安全性假設下，我們所提出
的身份識別基的證實簽章滿足隱形的特性。 
 
證明: 這個定理可以利用矛盾證法來證明。我們在 random oracle model 下證明，
如果存在一個區分者 D 可以決定在我們所提出的身份識別基的證實簽章方案中
的簽章是否合法有效，且存在一個演算法 G 可以利用區分者 D 在不可忽略的優
勢下去解決 DBDH 難題。假設 G有一個 DBDH 難題的例子 ( , , , , )P aP bP cP z ，其
中 pubaP P 。 
 隱形的特性可以在定義 3.3.2 中被找到。 
 在這裡我們省略了 oracles 與查詢的細節。它們相似於定理 3.3.2 的那些
oracles 與查詢。在 challenge 階段中，如果 G在名單
1H
L 中找到一組參數 * *( ,0, )ID 
或 * *( ' ,0, ' )iID  ，則輸出”失敗”並停止。否則，G隨機選取
* * *, qr Z  與
*
1 1P G 並
計算
****
5* '),(**
1
** ,),(),(
 rtmHzkPPetPcrR  以及 * * * * * *6 1( , ) pubZ H R k P P   並
設置 challenge 簽章 * 為(R*, k*, Z*)。根據此一設計，如果 z 是等於 ( , )abce P P ，那
 35 
 
簽章中，簽署者證明與證實程序這兩個證明都是不可轉移的(或稱為指定驗證者
的特性)。這表示指定驗證者不能將簽署者或證實者的證明轉移給其他人，並去
說服其他人簽章是有效的且實際上是由某位簽署者所簽署的。 
 
證明: 為了證明這個定理，我們證明驗證者 UB 可以在偽造訊息上建構出一個
simulating transcript 給簽署者證明與證實程序。這表示 UB 不能把簽章的證明轉
移給其他人，因為除了 UB 之外，沒有人可以被這個證明說服。其主要的技術是
去 建 構 一 個 陷 阱 門 承 諾 (trapdoor commitment) 
( , ) ( , ) ( , )
B
v
pub IDc TarpComm U v e P U e P Q  。驗證者 UB 擁有自己的私鑰 BIDd ，並可
以找到一對(U’, v’)滿足 ( , ) ( ', ')TarpComm U v TarpComm U v 。為了簽章(R, k, Z) 
與偽造的訊息 mˆ 所模擬的簽署者證明，驗證者 UB 選擇
*
1,  R R qS G x Z  與
1' RU G 並計算: 
5
( , '),
( , ) ( , ) ,
ˆ( ( , ) , ) ,
3( , , , , , ),
(mod ),
'
C
B
x
ID
x
pub
ID
c e P U
a e P S e R Q
b e H m t P S k
h H c a b m R k
v x h q
U U vd




 
 
 
其中 6 ( , )' ( , ) ( )
A
H R k
ID pubt e Z P e Q P  。 
 在證實程序中的模擬副本非常相似於上述的程序。 
 
定理 3.3.7 (公平性(Fairness)) 在所提出的合約簽署協定的最後，UA 或 UB 皆可以
獲得其他一方在合約 m 上的簽章，或是接得不到任何東西。 
 
證明: 有三種可能的情況被考慮，去證明即使 UA 或 UB 是不誠實的而所提出的協
定是公平的。 
 
Case 1: 在下面的協定中 UA 與 UB 是誠實的。 
 在步驟 5 的最後，UA 與 UB 可以直接被證明獲得在合約 m 上的合法簽章。 
 
Case 2: UA 是不誠實的一方 
這個情況可以透過矛盾證法被證明如下，如果一個不誠實者 *AU 與誠實的一
方 UB 進行公平 game，並且在不可忽略的機率下贏得 game，這可以證明 *AU 能夠
 37 
 
game。可以看出 UB 必然能從 TTP 那獲得 *AU 的簽章的轉換訊息。 
Case 3: UB 是不誠實的一方 
 假設，經由矛盾的方式證明，一個攻擊者 *BU 與誠實的 UA 執行公平 game，
且 *BU 在不可忽略的機率下贏得 game。在這種情況下的 game 也在幾個點上被打
斷，如下所述。 
 如果 game 在當 *BU 已經在步驟 2 中送出一個有效的 ( , )BUIDCS TTP m 給 UA
後停止，如果它繼續執行則 *BU 將一定輸掉 game，因為透過定理 3.3.5 得知，UA
可以執行 A-Reslove 程序來獲得 TTP 的轉換證明給 *BU 。 
 如果 game 在步驟 4 中 *BU 送出 * *( ( , ))B BU U
Cver IDCS TTP m 給 UA 之前停止，若
它繼續執行，則 *BU 將一定輸掉 game。原因是 UA 在步驟 3 沒有送 ( , )AUIDCS TTP m
給 *BU ，除非它已經接收到一個合法的 * ( , )BU
IDCS TTP m 。在這一點，為了贏得
game， *BU 必頇送出一個不合法的 * ( , )BU
IDCS TTP m 並使得它通過 UA 的驗證。然
而，在定理 2.4 中提到，如果 *BU 可以成功欺騙在上面所提到的方式，然後他可
以進一步的解決離散對數問題。 
 最後，如果 game 當 UA 已經在步驟 4 中從 *BU 收到一個合法的
* *
( ( , ))
B B
U UCver IDCS TTP m 後停止，或是已經請求 A-Reslove 程序來達到這一點讓
他能獲得
* *
( ( , ))
B B
U UCver IDCS TTP m 或 *( ( , ))BTTP U
Cver IDCS TTP m ，因為 UA 已經收
到 *BU 在訊息 m 所簽署的簽章，所以 *BU 將一定會輸掉 game。 
3.4 身份識別基的證實多重簽章與合約簽署的先進的協定 
在本節中，我們提出一個基於證實多重簽章方案的先進的合約簽署協定，可
以減少儲存的大小並能與傳統紙上的合約簽署是一致的。由簽署者雙方所簽署的
簽章合併成只有一個簽章。這表示，在協定的最後，雙方交換的部分簽章可以合
 39 
 
 6 1, AA ID A AZ H R k d P  。然後 AU 傳送 , ,A Ak k Z 並連同簽署者在簽章
 , ,A A AR k Z 上的證明給 BU 。值得注意的是， AZ 在這裡包含的是  6 ,H R k 而
不是  6 ,A AH R k 。因此，簽署者證明程序的驗證需要略作修改。驗證者(例
如 UB)應計算     6
( , )
' , ,
A B A B
A
H R R k k
A A ID pubt e Z P e Q P
 
  。 
4. 
BU 檢查如果簽署者在簽章  , ,A A AR k Z 上的證明是否正確。如果通過驗證，
則他計算  6 1, BB ID B BZ H R k d P  與     6 1 1, A BA B ID ID A A B BZ Z Z H R k d d P P       ，
然後傳送 BZ 並連同簽署者在簽章  , ,B B BR k Z 上的證明給 AU 。否則， BU 簡
單地中止協定。 
5. AU 檢查在簽章  , ,B B BR k Z 上的簽署證明。假如是合法的，則 AU 傳送 Ar 給 BU ;
否則， AU  執行 Abort Phase。 
6. BU 檢查 Ar 是否正確。如果正確，則 BU 接受並傳送  Cver , ,BU R k Z 給 AU 。否
則 BU 執行 B -Resolve Phase。 
7. AU 檢查  Cver , ,BU R k Z 是否合法，如果通過驗證，則 AU 接受訊息。否則， AU
執行 A - Resolve Phase。 
 
Abort Phase 
AU 透過以下的程序與TTP聯繫來中止該合約簽章協定： 
1. AU 傳送 , ,A Bm U U 和  , , ,AUSig m A B about 給TTP。 
2. TTP驗證  , , ,
AU
Sig m A B about 和檢查他的維護的集合。如果簽章是合
法的且 BU 從來沒有要求解決，則TTP傳送   , , ,ATTP USig Sig m A B about
給 AU 並把    , , , , , , ,AA B TTP Um U U about Sig Sig m A B about 增加到。 
3. 如果 BU 要求解決，則TTP傳送值儲存在中相對應的數值給 AU 。（參
考下文 B -Resolve Phase 的第 3 步驟。） 
 41 
 
3.5 具身分識別基之多方公平交換協定 
在上一章節文獻探討中有參考 Mukhamedov 與 Ryan 提出的協定，此協定是
一個基於 PCS 的新協定。此發展的系統達到了不可誤用的特性，且公平的交換
簽章，但其採用的 PCS 簽章技術並非是基於身分(ID-based)的簽章架構。因此，
我們在第 3.3 節所提出的 IDCS 技術，將其套用於此協定中，且我們所提出此技
術，其安全性上的證明利用了 Random Oracle Model 方式來證明此技術，詳細證
明在 3.3.3 節。 
在 IDCS 的技術中，採用了來自雙線性配對的證實承諾，我們將此方法套用入協
定中。詳細方法如下: 
來自雙線性配對的證實承諾有下列四個程序: 承諾，承諾者證明，證實和轉
換。假設協定在執行第x回合，程序如下: 
 
承諾程序: Comm(T, (m, x)) 
 承諾者Ui使用證實者T的身分IDT去建構針對訊息m的證實承諾。詳細步驟如
下: 
1. 承諾者隨機選取一個變數 r， *qr Z ，並計算 1R rP G  。 
2. 承諾者計算 1( )T TTPQ H ID 以及 2( ( , ) , )pub Tk e H m x P rQ G  。 
承諾Comm(T, (m, x)) = (R, k)。 
 
承諾者證明程序: Co-Prv(Comm(T, (m, x)), Pj) 
承諾者Ui 向指定驗證者Uj 證明，透過下列非交互式的證明，證明承諾是正確的
且之後可以被證實者T 證實是正確的。 
1. 計算
1( )jID jQ H ID 。 
2. 隨機選取 1,U W G 與
*
qv Z 並計算 
2
2
2 2
( , ) ( , )
( , )
( ( , ) , )
j
v
pub ID
pub
c e P U e P Q G
a e P W G
b e H m x P W G
 
 
 
 
3. 計算 *3( , , , ( , ), , ) qh H c a b m x R k Z  。 
4. 計算
1( ) jIDS W h v rQ G    。 
Co-Prv(Comm(T, (m, x)))這證明被記為(U, v, h, S)，驗證者UB執行下列驗證步驟。 
 43 
 
y，可以把承諾(R, k)轉換成一般可驗證的形式。 
承諾者的轉換與證實者的轉換，這兩個轉換的程序非常相似。 
 
第一部份: 
iU
Cver - 承諾者的轉換 
 承諾者轉換透過以下面步驟來轉換簽章: 
1. 隨機選取一個變數 j，
qj Z 並計算 1J jP G  。然後計算 ( , )
ja e P P 亦
以及
2 2( ( , ) , )pubb e H m x P J G  。 
2. 計算 *4( , , ( , ), , ) qh H a b m x R k Z  。 
3. 計算 1TIDS J hrQ G   。 
這個證明 ( (( , ), ))
iU T
Cver Comm m x U = (h, S)可以被普遍驗證。任何人都可以執
行下列步驟來驗證承諾，下列步驟相似於承諾者證明程序的驗證步驟，在沒有承
諾者或證實者的幫助下去驗證承諾。 
1. 計算 2' ( , ) ( , )T
h
IDa e P S e R Q G  。 
2. 計算 2 2' ( ( , ) , )
h
pubb e H m x P S k G  。 
3. 驗證 4( ', ', ', ( , ), , )h H c a b m x R k 是否正確。 
 
第二部分: TCver - 證實者的轉換 
 證實者透過下面步驟來轉換簽章: 
1. 隨機選取一個變數 j， qj Z 且計算 1J jP G  。然後計算 ( , )
je P P  以
及 2 2( ( , ) , )e H m x R J G   。 
2. 計算 *4( , , ( , ), , ) qH m x R k Z    。 
3. 計算 1TIDX J d G   。 
這個證明 ( (( , ), )) ( , )TCver Comm m x T X 可以被普遍驗證。任何人都可以執行下
列步驟來驗證承諾，下列步驟相似於證實程序的驗證步驟，在沒有承諾者或證實
者的幫助下去驗證承諾。 
1. 計算 2' ( , ) ( , )Tpub IDe P X e P Q G
   。 
 45 
 
改的  與 ' 為 5( (( , ), ') , )e H m x t R J  與 5' ( (( , ), ') , )e H m x t R X k
  。此外，簽署
者的轉換程序也相似於證實者的轉換程序。 
所以，我們將採用雙線性配對的證實承諾的方法取代掉 PCS 的簽章，我們
所提出的技術是基於身分識別系統，且有防止誤用特性，並利用 Random Oracle 
Model 方式來證明其安全性。在將我們所提出的 IDCS 套用在此多人的協定架構
上來達到公平交換的目的。表 4、表 5、表 6 分別表示主要協定、中止協定、回
復協定的詳細步驟。 
 
 
表 4 IDCS 簽章套用於主要協定(簽署者 Pi ) 
第 1 回合 
(1) 對於每個 j< i，等待來自 Pj 的承諾 ( , ( ,1))
jP
IDCS T m 。 
if 他們中的任何人沒及時的接收到承諾 then 停止協定。 
(2) 對於每個 j> i，傳送承諾 ( , ( ,1))
iP
IDCS T m 給 Pj。 
(3) 對於每個 j> i，等待來自 Pj 的承諾 ( , ( ,1))
jP
IDCS T m 。 
if 他們中的任何人沒及時的接收到承諾 then 請求中止協定。 
(4) 對於每個 j< i，傳送承諾 ( , ( ,1))
iP
IDCS T m 給 Pj。 
第 2 回合到第 / 2n  回合 
(5) 對於每個 j< i，等待來自 Pj 的承諾 ( , ( , ))
jP
IDCS T m r 。 
if 他們中的任何人沒及時的接收到承諾 then 請求回復協定。 
(6) 對於每個 j> i，傳送承諾 ( , ( , ))
iP
IDCS T m r 給 Pj。 
(7) 對於每個 j> i，等待來自 Pj 的承諾 ( , ( , ))
jP
IDCS T m r 。 
if 他們中的任何人沒及時的接收到承諾 then 請求回復協定。 
(8) 對於每個 j< i，傳送承諾 ( , ( , ))
iP
IDCS T m r 給 Pj。 
最後一回合: / 2n   +1 
(9) 對於每個 j< i，等待來自 Pj 的承諾 ( , ( , / 2 1))
jP
IDCS T m n    與簽章
 47 
 
表 6 IDCS 簽章之回復協定(for T) 
T 首次為了合約 m 而被聯繫(無論是中止或是回復)，首先 T 將集合 S(m)初始化設
定為且 validated 設定為 false。 
if T 收到回復訊息
{1,..., }\{ }({ (( , ), , )} , (( , ),0))i j iP P j i j n i PS IDCS m P T S m x   
檢查承諾與簽章是有效的，且來自號數大的(上面的)或號數小的(下面的) 
IDCS 是一致的，例如: 
 對於所有 j< i，檢查
1j i    
對於所有 j> i，檢查 1j i    
再檢查 1 1 1 1  1i i i ior          
 if ( )i S m 或是上述的檢查，檢查出失敗的話 then 
忽略訊息。 
else if 集合 S(m)=   then 
  將 validated 設定為 true(validated:= true) 
  傳送
{1,..., }\{ }{ ( ( ,( , )))}T j j n iCver IDCS T m   給 Pi 
在此 j 是來自 Pj 所傳送過來的承諾的 leve，而此 level 的承諾是已 
在回復協定中經過轉換成一般可驗證的簽章，或是 0。 
else // 注意 validated= false 且 S(m)=   
  if ( )( ( ))p pp S m p i h m        ( ( )))p pp i l m    
   傳送儲存在資料庫的中止標記
1( (( , ), , ( ,..., ), ))jT P j nS S m x P p p abort  
   給 Pi 
   將 i 加入到集合 S(m)中(S(m):= S(m) {i}) 
   計算 hi(m)與 li(m)如下: 
   if i=1 
    //P1 在主要協定中的步驟 7 或 11 連繫 T 
    (hi(m), li(m))= ( 2 +1, 0) 
   else if i= n 
    //Pn 在主要協定中的步驟 5 或 9 連繫 T 
    (hi(m), li(m))= (0, 1n  ) 
   else if 1< i < n 且 1 1i i    
    //Pi 在主要協定中的步驟 5 或 9 連繫 T 
    (hi(m), li(m))= ( 1i  , 1i  ) 
 49 
 
第四章 實作成果 
4.1 開發環境 
1. 作業系統：Windows XP 
2. 使用語言：Java 
3. IDE：Eclipse IDE for Java Developers 3.6 
4. IDE 其他套件： 
a. Java SE Development Kit 6 
b. Visual Editor Project （用於簡化介面開發，可不裝） 
5. 使用函式庫：jPBC 1.0.0 Library 
a. jPBC is mainly developed by Angelo De Caro.  
b. 官網：http://gas.dia.unisa.it/projects/jpbc/ 
c. jPBC 1.0.0 Library 載點 http://sourceforge.net/projects/jpbc/files/ 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 51 
 
4.2.2 參與者（User）端介面 
 
 
A. UserID，User 向 TTP 註冊的 ID，每個 User 的 ID 不同，User 可自行定
  義 ID。 
B. OrderNum，User 向 TTP 註冊之後，會得到 TTP 給 User 的編號，例如
  OrderNum 為 1，User 就是 P1。 
C. 目前資料交換的回合數。 
D. 輸入 TTP 的 IP 位址和 Port Number，向 TTP 註冊時需要。 
E. 在 A 輸入 ID、在 D 輸入 TTP 的 IP 位址和 Port num 後，就可以按下註
  冊，向 TTP 註冊，並取得 B 和 TTP 的基本資訊（P、Ppub）和自己的
  私鑰（sQid） 
F. 向 TTP 註冊之後，在 F 處可看到其他 User 的資訊。 
G. Round 1 會用到的按鈕 
  G1. User 號數小的往上傳遞 IDCSpj 給號數大的。 
  G2. User 號數大的往下傳遞 IDCSpj 給號數小的。 
  G3. 當 User 為進行任何資料交換(即未傳送任何 IDCSpj 給其他 User，
  也未從其他 User 手上接收任何 IDCSpj)，可按 Quit，中止全部的資
  訊交換。 
  G4. 當 User 完成 G1，但是未接收到 User 號數大的往下傳遞的 IDCSpj， 
此時 User 可按 Abort，進行 Abort protocol。 
 53 
 
 User 向 TTP 註冊 
 
 
執行動作： 
  a. 在 A 中填入 UserID，User 可自行定義 ID，ID 頇與其他使用者不同。 
 b. 在 B 中填入 TTP 的 IP 和 Port Number。 
  c. 點擊 C，向 TTP 註冊。 
執行結果： 
a. User 會將註冊資料傳給 TTP，註冊完成後，TTP 會回傳 TTP 參數(P、Ppub)、 
   User 的 sQid、User 的參與序號(OrderNum)、其他使用者的資訊。 
b. 將 User 的參與序號(OrderNum)顯示於 D。 
c. 將其他使用者資訊顯示於 E(目前無其他使用者)。 
e. 訊息顯示在 F。 
f. 等待其他 User 參與(註冊)。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 55 
 
4.3.2 進行交換資訊步驟 
 Round 1，User 號數小的往上傳遞 IDCSpj給號數大的 
 
 
執行動作： 
a. 收到 TTP 通知可以進行資訊交換，進入 Round 1 (A 處)。 
b. 點擊 B 處。 
執行結果： 
a. User 開始製作 IDCSpj，並傳送給每一個號數大的 User。 
b. 傳送完，會有訊息顯示(C 處)。 
c. 號數大的 User 接收到 IDCSpj 後開始驗證，並顯示驗證結果(D 處)。 
   (因節省畫面，使用剪貼的方式呈現) 
 
 
 
 
 
 
 
 
 57 
 
 Round r， r = 2 to 
2
n 
 
 
，User 號數小的往上傳遞 IDCSpj 給號數大的 
 
 
執行動作： 
a. 進入 Round 2 後，點擊 A 處按鈕。 
執行結果： 
a. User 開始製作 IDCSpj，並傳送給每一個號數大的 User。 
b. 傳送完，會有訊息顯示(B 處)。 
c. 號數大的 User 接收到 IDCSpj 後開始驗證，並顯示驗證結果(C 處)。 
   (因節省畫面，使用剪貼的方式呈現) 
 
 
 
 
 
 
 
 
 
 
 59 
 
 Round 1
2
n 
 
 
，User 傳遞 IDCSpj與簽章，給其他的 User 
 
 
執行動作： 
a. 當進入了 Round 1
2
n 
 
 
（可參考 A 處），代表每個 User 都和其他 User 
正確的交換了承諾，因此可以進行簽章的交換。 
  b. 點擊 B 處按鈕。 
執行結果： 
a. User 開始製作 IDCSpj 和簽章，並傳送給每一個 User，訊息顯示於 C 處。 
b. 其他 User 收到後，開始驗證 IDCSpj 的正確性和簽章的正確性，並顯示驗證 
結果(D 處)。 
  c. 每一個 User 皆接收到其他 User 傳送的 IDCSpj 和簽章，並驗證成功，此次 
的資訊交換就順利完成了。 
 
 
 
 
 
 
 61 
 
4.4.2 Abort Potocol 
 
 
執行動作： 
a. 當 User 接收完號數小的 User 的 IDSCpj，並傳送本身的 IDCSpj給號數大的
User 後。 
  b. 未接收到 User 號數大的往下傳遞的 IDCSpj。 
  c. 按 A 處按鈕 Abort，進行 Abort protocol。 
執行結果： 
a. User 會收集之前之交換資訊 IDCSPj，和 Abort 訊息，並加以簽章傳送給 TTP。 
b. TTP 收到後(C 處)，如果此訊息驗證成功，會儲存此放棄訊息並回傳給此 
  User(B 處)。 
  (因節省畫面，使用剪貼的方式呈現) 
 
 
 
 
 
 
 
 
 63 
 
第五章  結果與討論 
5.1 結論 
本節提供在性能上和安全方面比較，去比較以前的做法和我們所提出的方
案，如表 7。我們所提出的方案更優於其他方案中的兩個關鍵的特性。第一個特
性是我們的方案提供一個完全身份識別基的環境;這表示包含 TTP 的所有參與
者，使用他們的（延伸）的 ID 當做是公開金鑰，而最以往的方案是需要 TTP 使
用憑證基礎的公共金鑰系統。Galindo 等學者 [22]在 2006 年提出一個從現存的
基於 PKI 簽章方法中的身份識別基的可驗證加密簽章的通用建構的方式。他們
的方案所使用的建構方法是來自[28]這只考慮一個標準的（非身份識別基的）可
信賴第三方。第二個是我們的方法有防止誤用的特性。此特性是合約簽署的重要
特性，因為簽署者的意願是不能被其他人證實，直到其他人已經進行合約的簽
署。不可誤用的特性在我們的方法中可以被實現，因為我們提供一個不可轉移性
的證明，這表示在簽署者證明和證實程序中，驗證者不能向其他人轉移證明，去
說服其他人簽署者確實已簽署簽章。 
 
表 7：以前的做法與所提出的方案 
 Saeednia 
et. al [39] 
Gu et al. 
[26] 
Zhang et 
al. [50] 
Yong et 
al.[48] 
Kwon and 
Lee [28] 
Yum and 
Lee [49] 
我們的技
術 
使 用 的
技術 
Guillou- 
Quisquator 
簽章 
雙線性配
對 
雙線性配
對 / 身 份
識別基的
可驗證的
機率式簽
章方法 
雙線性配
對 / 身 份
識別基的
VES 
Hess 的 
方案 
( 雙 線 性
配對) 
Guillou- 
Quisquator 
簽章 
雙線性配
對 / 身 份
識別基的
證實簽章
方法 
安 全 性
假 設 與
證明 
RSA 的 
分解難題
假設 
CDH 難題 
(random 
Oracle) 
CDH難題 
(random 
Oracle) 
沒有正式
的證明 
CDH難題 
(random 
Oracle) 
RSA 的 
分解難題
假 設
(random 
Oracle) 
CDH/DB
DH 難題 
(random 
Oracle) 
完 全 身
份 識 別
基環境 
否 否 否 否 否 否 是 
防 止 誤
用 
否 否 否 否 否 否 是 
TTP 作
為 可 信
任 方 來
得 到 使
用 者 的
金鑰 
否 是 否 否 否 否 否 
 65 
 
5.3 未來研究與計畫成果自評 
我們以身份識別基的證實簽章方案提出一個新的合約簽署協定。因為我們
已經為身份識別基的證實簽章系統設計一個靈活建構方式，所以在安全性上的
分析就可以更明確。明顯的，不適合應用古典的公開金鑰技術來交換來自雙線
性配對的基於身分的簽章。 
未來研究可更深入探討，目的在於找尋更好的工具，可以使得交換的簽章
像一些知名的安全簽章方案具有相同的形式，例如 RSA [38] 和 DSA [33]。由
於在本文所提出的協定，使用了特別設計的簽章，這些協定的應用可能僅限於
封閉的環境，證明了還有更多的發展空間。 
本計劃已將相關成果寫成論文：An Identity-based Fair Contract Signing 
Protocol from Bilinear Pairings，投稿至國外知名期刊（英文論文），目前正審
查中。此外，我們對於公平交換的議題，也研究了並存簽章的安全性問題，論
文為：並存簽章在公平交換的使用與改進，發表在「資訊安全通訊」Vol. 16, No.3, 
pp. 60-71。綜觀此計畫，我們完成以下重要貢獻，已大致完成當初計劃書所規
劃預期之項目，說明如下： 
 
1. 探討公平交換協定與多方公平交換協定之文獻。 
2. 探討身份識別基之密碼系統(Identity-based cryptosystem)與雙線配對函
數(Bilinear pairing)系統設計之文獻。 
3. 設計一個高效能具身份識別基之多方公平交換協定。 
4. 新設計之協定的特性分析，並與其他系統作比較。 
5. 新設計協定之效能分析。 
6. 提出新協定之正規化安全性證明。 
7. 推廣應用至電子商務系統。 
8. 實作多方公平交換協定及推廣至多方合約簽署之商務應用。 
 
 
 
 
 
 
 
 
 
 
 
 
 67 
 
pages 283-399. Springer-Verlag, 2003. 
[13] D. Chaum. Designated confirmer signatures. In Eurocrypt'94, pages 86-91, 1994. 
[14] L. Chen, C. Kudla, and K. G. Paterson. “Concurrent signatures”. In : 
EUROCRYPT ’04, LNCS, vol. 3027, pp. 287-305, 2004. 
[15] R. Chadha, S. Kremer, and A. Scedrov. “Formal analysis of multi-party fair 
exchange protocols,” In Riccardo Focardi, editor, 17th IEEE Computer Security 
Foundations Workshop, pp. 266–279, Asilomar, CA, USA, June 2004. IEEE 
Computer Society Press. 
[16] G. Chen, S. Qing, Z. Qi, and Y. Yang. An optimistic fair exchange protocol 
based on committed signature. In Global Mobile Congress 2009, pages 1-6. 
IEEE, Oct. 2009. 
[17] L. Chen. Efficient fair exchange with verifiable confirmation of signatures. In 
Advances in Cryptology - Proceedings of Asiacrypt'98, pages 286-299. 
Springer-Verlag, 1998. 
[18] R. H. Deng, L. Gong, A. A. Lazar, and W. Wang. Practical protocol for certified 
electronic mail. Journal of Network and Systems Management, 4(3):279-297, 
1996. 
[19] S. Even, O. Goldreich, and A. Lempel. A randomized protocol for signing 
contracts. CACM, 28(6):637{647, 1985. 
[20] M. K. Franklin and M. K. Reiter. Fair exchange with a semi-trusted third party. 
In Proceedings of the 4th ACM Conference on Computer and Communications 
Security, pages 1-5, Zurich, Switzerland, April 1997. 
[21] M. K. Franklin and G. Tsudik, ”Secure group barter: Multi-party fair exchange 
with semi-trusted neutral parties,” In Ray Hirschfeld, editor, Second Conference 
on Financial Cryptography (FC 1998), volume 1465 of Lecture Notes in 
Computer Science, pp. 90–102,Anguilla, British West Indies, February 1998. 
[22] D. Galindo, J. Herranz, and E. Kiltz. On the generic construction of 
identity-based signa- tures with additional properties. In Advances in Cryptology 
- ASIACRYPT 2006, LNCS 4284, pages 178-193. Springer Berlin / Heidelberg, 
2006. 
[23] W. Gao, F. Li, and B. Xu. An abuse-free optimistic fair exchange protocol based 
on BLS signature. In 2008 International Conference on Computational 
Intelligence and Security, volume cis, vol. 2, pages 278-282, 2008. 
[24] J. A. Garay and P. D. MacKenzie. “Abuse-free multi-party contract signing,” In 
International Symposium on Distributed Computing, volume 1693 of Lecture 
Notes in Computer Science, Bratislava, Slavak Republic, September 1999. 
Springer-Verlag. 
[25] J. A. Garay, M. Jakobsson, and P. MacKenzie. Abuse-free optimistic contract 
 69 
 
[38] R. L. Rivest, A. Shamir, and L. Adleman. A method for obtaining digital 
signatures and public-key cryptosystem. Communications of the ACM, 
21:120-126, 1978. 
[39] S. Saeednia, O. Markowitch, and Y. Roggeman. Identity-based optimistic fair 
exchange with transparent signature recovery. In The 9th International 
Conference on Distributed Multimedia Systems (DMS'03), pages 718-721, 2003. 
[40] A. Shamir. Identity based cryptosystems and signature schemes. In Advances in 
Cryptology - Proceedings of Crypto'84, Lecture Notes in Computer Science 
(LNCS) 0196, pages 47-53. Springer-Verlag, 1984. 
[41] Z. Shao. Certificate-based fair exchange protocol of signatures from pairings. 
Computer Networks, 52(16):3075-3084, November 2008. 
[42] Z. Shao. Certificate-based verifiably encrypted signatures from pairings. 
Information Sciences, 178(10):2360-2373, May 2008. 
[43] Z. Shao. Fair exchange protocol of signatures based on aggregate signatures. 
Computer Communications, 31(10):1961-1969, June 2008. 
[44] N. P. Smart. An identity based authentication key agreement protocol based on 
the Weil pairing. Electronic Letters, 38(13):630-632, 2002. 
[45] M. Stadler, “Publicly verifiable secret sharing,” In Advances in cryptology - 
Proceedings of Eurocrypto’96, Lecture Aotes in Computer Science (LACS)1070, 
Springer-Verlag, 1996, pp.190-199. 
[46] Y. Sun, L. Gu, S. Qing, S. Zheng, Y. Yang, and Y. Sun. New optimistic fair 
exchange protocol based on short signature. In Second International Conference 
on Communication Software and Networks, 2010. ICCSN '10., pages 99 - 104, 
Singapore, Feb. 2010. 
[47] G. Wang. An abuse-free fair contract-signing protocol based on the RSA 
signature. IEEE Transactions on Information Forensics and Security, 5(1):158 - 
168, March 2010. 
[48] Y. Yong, Y. Bo, and Y. Guoqing. An identity-based scheme of fair exchange of 
digital signatures. Wuhan University Journal of Natural Sciences, 
11(6):1761-1764, 2006. 
[49] D. H. YUM and P. J. Lee. Efficient fair exchange from identity-based signature. 
IEICE Tanns. Fundamentals, E91-A(1):119-126, January 2008. 
[50] J. Xu Z. Zhang, D. Feng and Y. Zhou. Efficient id-based optimistic fair exchange 
with provable security. In Information and Communications Security, Lecture 
Notes in Com- puter Science (LNCS 3783), pages 14-26. Springer Berlin / 
Heidelberg, 2005. 
[51] F. Zhang and K. Kim. ID-based blind signature and ring signature from pairings. 
In Advances in Cryptology - Proceedings of Asiacrypt'02, Lecture Notes in 
 71 
 
附錄 
程式碼解說 
 
一. 開發環境： 
1. 作業系統：Windows XP 
2. 使用語言：java 6.0 
3. IDE：Eclipse IDE for Java Developers 3.6 
4. 使用函式庫：jPBC 1.0.0 Library 
jPBC is mainly developed by Angelo De Caro.  
二. 程式介紹 
此 專 案 分 成 其 他 副 程 式 和 兩 個 主 要 程 式 ， Id_CSP_TA.java 、
Id_CSP_User.java，以下分別介紹此兩個程式的功能和主要程式內容。 
1. Id_CSP_TA.java 
此程式用於處理參與者在交易過程中，1.產生承諾、簽章，2.驗證承諾、簽
章，3.向 TTP 發出 about 或 resolve 要求。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 73 
 
v=BigInteger.probablePrime(512, securerandom); 
} 
 
//計算c 
c = pairing.pairing(P, U).mul(pairing.pairing(Ppub, 
H1(targetID)).pow(v)); 
//計算a 
a = pairing.pairing(P, W); 
//計算b 
Element temp5 = Ppub.duplicate(); 
b = pairing.pairing(temp5.mul(H5(M,t)),W); 
 
//取得承諾簽章的M 
getPromiseM(targetID); 
 
//計算h 
h = H3(c,a,b,M,R,k); 
//計算S 
S = W.duplicate(); 
S.sub(rQTA.mul(h.add(v))); 
 
return 
new BigInteger(R.toBytes()).toString()+lineSep+ 
new BigInteger(k.toBytes()).toString()+lineSep+ 
new BigInteger(Z.toBytes()).toString()+lineSep+ 
h.toString()+lineSep+ 
new BigInteger(S.toBytes()).toString()+lineSep+ 
new BigInteger(U.toBytes()).toString()+lineSep+ 
v.toString()+lineSep; 
} 
/******************************************************************* 
* Verify() 驗證其他參與者傳來的承諾 
* @param user  其他參與者編號 
* @param round 回合數 
* @return 錯誤訊息，0為驗證成功，1為承諾錯誤，2為對象錯誤，3為承諾逾時 
* @throws IOException 
*******************************************************************/ 
public int Verify(int user,int round) throws IOException{ 
System.out.println(UserID + " Verify..."); 
//取得(R,k,Z,h,S,U,v) 
getPCSpj(user,round); 
 
//計算t' (以tt表示) 
Element temp6 = Ppub.duplicate().invert(); 
tt = pairing.pairing(H1(OtherID[user]), temp6).pow(H6(R,k)); 
tt.mul(pairing.pairing(Z, P)); 
 
//計算b' (以bb表示) 
Element temp3 = Ppub.duplicate(); 
Element temp7 = k.duplicate(); 
bb = pairing.pairing(temp3.mul(H5(M,tt)),S); 
bb.mul(temp7.pow(h.add(v))); 
 
//計算c' (以cc表示); 
cc = pairing.pairing(P, U).mul(pairing.pairing(Ppub, 
H1(UserID)).pow(v)); 
 
//計算a' (以aa表示) 
 75 
 
//計算b 
Element temp = Ppub.duplicate(); 
b = pairing.pairing(temp.mul(H5(M,tt)),J); 
 
//計算h 
c = pairing.getGT().newElement().setToZero(); 
hh = H3(c,a,b,M,R,k); 
System.out.println("h=  " + hh); 
 
//計算S 
 
SS = J.duplicate(); 
SS.sub(H1("TA").mul(r).mul(hh)); 
 
return hh.toString()+lineSep+ 
new BigInteger(SS.toBytes()).toString()+lineSep; 
} 
/***************************************************** 
* Proof_User_Conversion() 驗證其他參與者簽章 
* @param user 其他參與者的編號 
* @return 是否驗證成功，true為驗證成功，false為驗證失敗 
* @throws IOException 
******************************************************/ 
public boolean Proof_User_Conversion(int user) throws IOException{ 
System.out.println(UserID + " Proof Conversion..."); 
 
//取得(h,S) 
String[] str = Signature[user].split(lineSep); 
hh = new BigInteger(str[0]); 
SS = setElement(str[1],1); 
 
//取得M 
getCSM(user); 
 
//計算a' (以aa表示) 
aa = pairing.pairing(P, SS).mul(pairing.pairing(R, H1("TA")).pow(hh)); 
 
//計算t' (以tt表示) 
Element temp2 = pairing.pairing(Z, P); 
Element temp6 = Ppub.duplicate().invert(); 
tt = pairing.pairing(H1(OtherID[user]), temp6).pow(H6(R,k)); 
tt.mul(temp2); 
 
//計算b' (以bb表示) 
Element temp3 = Ppub.duplicate(); 
Element temp7 = k.duplicate(); 
bb = pairing.pairing(temp3.mul(H5(M,tt)), SS).mul(temp7.pow(hh)); 
 
//Verify if h = H3(a0; b0; m;R; k). 
cc = pairing.getGT().newElement().setToZero(); 
BigInteger temp4 = H3(cc,aa,bb,M,R,k); 
if(hh.compareTo(temp4)==0){ 
System.out.println("標準簽章驗證成功"); 
return true; 
} 
else{ 
System.out.println("標準簽章驗證失敗"); 
return false; 
 77 
 
M = M + UserID +lineSep; 
//加上其他UserID 
for(int i =1 ;i<=NumOfMan;i++){ 
if(i!=OrderNum){ 
M = M + OtherID[i]+ lineSep; 
} 
} 
M = M + "Abort"+lineSep; 
return M; 
} 
/***************************************************** 
* getResolveM() 收集Resolve所需訊息，用於向TTP發出Resolve資訊 
* @return 收集好的Resolve訊息 
* @throws IOException 
*****************************************************/ 
public String getResolveM() { 
String tempStr = ""; 
for(int i =1; i<=NumOfMan ;i++){ 
if(i!=OrderNum){ 
tempStr = tempStr + PCSpj[i][Zetaj[i]]+ 
PCSpjM[i][Zetaj[i]]+lineSep+ 
"!$end"+lineSep; 
} 
} 
return tempStr; 
} 
/*******************************************************************
****** 
* Signing() 用於向TTP發出Abort或Resolve訊息時，針對Abort或Resolve訊息做簽章 
* @param tempM Abort訊息或Resolve訊息 
* @return 簽章後的資訊 
********************************************************************
*****/ 
public String Signing(String tempM) { 
System.out.println(UserID + " Singing..."); 
 
M = tempM; 
 
//隨機產生P1 , 
P1 = pairing.getG1().newRandomElement(); 
 
//產生r 
r=BigInteger.probablePrime(512, securerandom); 
while(r.compareTo(q)>-1){ 
r=BigInteger.probablePrime(512, securerandom); 
} 
 
//產生e 
e=BigInteger.probablePrime(512, securerandom); 
while(e.compareTo(q)>-1){ 
e=BigInteger.probablePrime(512, securerandom); 
} 
 
//計算R 
R = P.duplicate(); 
R.mul(r); 
 
//計算t 
 79 
 
public BigInteger H6(Element G1,Element G2){ 
BigInteger temp = new BigInteger(G1.toBytes()); 
temp = temp.xor(new BigInteger(G2.toBytes())); 
while(temp.compareTo(q)>-1){ 
temp = temp.divide(q); 
} 
return temp; 
} 
 
c. 其他 Function： 
/********************************************* 
* setElement 設定 Element的值 
* @param str  要設定給Element的值 
* @param type Element的型態 
* @return 設定好的Element 
**********************************************/ 
public Element setElement(String str,int type){ 
Element temp; 
if(type == 1){ 
temp = pairing.getG1().newElement(); 
} 
else 
temp = pairing.getGT().newElement(); 
 
byte[] tempbyte = new BigInteger(str).toByteArray(); 
if(tempbyte.length%2==1){ 
byte[] temp2 = new byte[tempbyte.length+1]; 
temp2[0]=0; 
for(int i = 0 ;i<tempbyte.length;i++){ 
temp2[i+1]=tempbyte[i]; 
} 
temp.setFromBytes(temp2); 
} 
else{ temp.setFromBytes(new BigInteger(str).toByteArray()); 
} 
return temp; 
} 
/************************************************* 
* getM() 取得簽章使用的文章M 
* @return 取得的文章 
* @throws IOException 
*************************************************/ 
public String getM() throws IOException { 
// TODO Auto-generated method stub 
M=""; 
BufferedReader read = new BufferedReader(new 
FileReader("PlanText.txt")); 
String str; 
str=read.readLine(); 
while(str!=null){ 
M = M + str + lineSep; 
 81 
 
* @param round 回合數 
**************************************************/ 
public void getPCSpjMInfo(int user,int round){ 
String[] str = PCSpjM[user][round].split(lineSep); 
PCSpjMInfoM = ""; 
int i = 0; 
while(str[i].compareTo("!$end")!=0){ 
PCSpjMInfoM = PCSpjMInfoM + str[i]+ lineSep; 
i++; 
} 
//str[i+1] = Round數; 
Zetaj[user] = Integer.parseInt(str[i+1]); 
PCSpjMInfoID = str[i+2]; 
PCSpjMInfoTime = str[i+3]; 
} 
/********************************************************* 
* getCSM() 其他參與者傳來的簽章所使用的M會存於 SignatureM， 
*      利用此函式取得 
* @param user 其他參與者的編號 
*********************************************************/ 
private String getCSM(int user) { 
M=SignatureM[user]; 
return M; 
} 
/********************************************************* 
* getCS() 其他參與者傳來的簽章產生的資訊，會存於 Signature， 
*      利用此函式取得 
* @param user 其他參與者的編號 
*********************************************************/ 
private void getCS(int user) { 
String[] str = Signature[user].split(lineSep); 
R = setElement(str[0],1); 
k = setElement(str[1],2); 
Z = setElement(str[2],1); 
h = new BigInteger(str[3]); 
S = setElement(str[4],1); 
} 
 
2. Id_CSP_User.java 
a. 主要 Function： 
/************************************************************** 
* InitCurve() 產生橢圓曲線資訊，用於產生pairing所需參數和產生Element 
* @throws IOException 
**************************************************************/ 
public void InitCurve() throws IOException{ 
try{ 
curveParams = new CurveParams().load("curve.properties"); 
pairing = PairingFactory.getPairing(curveParams); 
q = curveParams.getBigInteger("q"); 
} 
catch(Exception ex){ 
System.out.println("Exception: "+ex.toString()); 
generateCurve(); 
 83 
 
 
if(Proof_User_Conversion(UserOrderNum)){ 
System.out.println("放棄訊息簽章驗證成功"); 
return true; 
} 
else{ 
System.out.println("放棄訊息簽章驗證失敗"); 
return false; 
} 
} 
/********************************************************************
**** 
* Proof_User_Conversion() 驗證參與者傳來的簽章 
* @param UserOrderNum 參與者的編號 
* @return 是否驗證成功，true為驗證成功，false為驗證失敗 
* @throws IOException 
*********************************************************************
**/ 
public boolean Proof_User_Conversion(int UserOrderNum) throws 
IOException{ 
System.out.println("TA" + " Proof Abort Signature..."); 
//計算a' (以aa表示) 
aa = pairing.pairing(P, S).mul(pairing.pairing(R, H1("TA")).pow(h)); 
 
//計算t' (以tt表示) 
Element temp2 = pairing.pairing(Z, P); 
Element temp6 = Ppub.duplicate().invert(); 
tt = pairing.pairing(H1(UserID[UserOrderNum]), temp6).pow(H6(R,k)); 
tt.mul(temp2); 
 
//計算b' (以bb表示) 
Element temp3 = Ppub.duplicate(); 
Element temp7 = k.duplicate(); 
 
bb = pairing.pairing(temp3.mul(H5(M,tt)), S).mul(temp7.pow(h)); 
 
//Verify if h = H3(a0; b0; m;R; k). 
cc = pairing.getGT().newElement().setToZero(); 
BigInteger temp4 = H3(cc,aa,bb,M,R,k); 
if(h.compareTo(temp4)==0){ 
return true; 
} 
else{ 
return false; 
} 
} 
/******************************************************************** 
* Signing() 當參與者的Abort訊息驗證成功，TTP需針對此Abort訊息做簽章， 
* @param tempM 參與者傳來的Abort訊息 
* @return 產生的簽章(R,k,Z)
 ****************************************************************/ 
public String Signing(String tempM) { 
System.out.println("TA" + " Singing..."); 
M = tempM; 
 
//隨機產生P1 
Element P1 = pairing.getG1().newRandomElement(); 
 
 85 
 
//計算a 
a = pairing.pairing(P, P).pow(j); 
 
//計算t' (以tt表示) 
Element temp2 = pairing.pairing(Z, P); 
Element temp6 = Ppub.duplicate().invert(); 
tt = pairing.pairing(H1("TA"), temp6).pow(H6(R,k)); 
tt.mul(temp2); 
//System.out.println("tt= " + tt); 
 
//計算b 
Element temp = Ppub.duplicate(); 
b = pairing.pairing(temp.mul(H5(M,tt)),J); 
 
//計算h 
c = pairing.getGT().newElement().setToZero(); 
 
h = H3(c,a,b,M,R,k); 
 
//計算 
S = J.duplicate(); 
S.sub(H1("TA").mul(r).mul(h)); 
//System.out.println("S=  " + SS); 
 
return h.toString()+lineSep+ 
new BigInteger(S.toBytes()).toString()+lineSep; 
} 
/********************************************************************
*** 
* CkeckResolveSignature() 驗證參與者傳來的Resolve訊息 
* @param str 參與者傳來的Resolve訊息 
* @return 是否驗證成功，true為驗證成功，false為驗證失敗 
* @throws IOException 
*********************************************************************
**/ 
public boolean CkeckResolveSignature(String[] str) throws IOException { 
int i = 1; 
System.out.println("TA_Ckeck User "+ str[i]+" RS..."  ); 
int usernum = Integer.parseInt(str[i++]); 
 
//驗證 Spi({PCSpj}) 
R = setElement(str[i++],1); 
k = setElement(str[i++],2); 
Z = setElement(str[i++],1); 
h = new BigInteger(str[i++]); 
S = setElement(str[i++],1); 
 
//紀錄M Spi({PCSpj})的M 
M = ""; 
for(int j=1; j<=UserNum;j++){ 
if(j!=usernum){ 
//System.out.println(j); 
PCSpj[j] = str[i++]+lineSep+str[i++]+lineSep+str[i++]+lineSep+ 
str[i++]+lineSep+str[i++]+lineSep+str[i++]+lineSep+str[i++]+lineSep; 
PCSpjM[j]=""; 
for(; str[i].compareTo("!$end")!=0;i++){ 
PCSpjM[j] = PCSpjM[j] + str[i]+lineSep; 
} 
PCSpjM[j] = 
 87 
 
 
} 
for(int j=usernum+1;j<=UserNum;j++){ 
if(Zetaj[j]!=Zetaj[usernum+1]){ 
System.out.println("(2)Zetaj[j]= "+Zetaj[j]+" , Zetaj[i+1]= 
"+Zetaj[usernum+1]+ " 錯誤"); 
return false; 
} 
} 
if( (Zetaj[usernum-1]==Zetaj[usernum+1]) || 
Zetaj[usernum-1]==Zetaj[usernum+1]+1){ 
//OK 
} 
else{ 
if(i>1 && i< getUserNum()){ 
System.out.println("(3)Zetaj[i-1]= "+Zetaj[usernum-1]+" , Zetaj[i+1]= 
"+Zetaj[usernum+1]+ " 錯誤"); 
return false; 
} 
} 
 
//檢查是否有在S(m)裡 
for(int j = 1; j<=SmNum;j++){ 
if(usernum==Sm[j]){ 
System.out.println(usernum+" in the S(m)"); 
return false; 
} 
} 
return true; 
} 
/*************************************************************** 
* Verify() 驗證參與者的承諾 
* @param user 其他參與者的編號 
* @param usernum 此參與者的編號 
* @return 錯誤編號，0為驗證成功，1為承諾驗證失敗，2為承諾訊息有誤 
* @throws IOException 
****************************************************************/ 
public int Verify(int user,int usernum) throws IOException{ 
System.out.println(UserID[usernum] + " Verify..."); 
//取得(R,k,Z,h,S,U,v) 
getPCSpj(user); 
 
//計算t' (以tt表示) 
Element temp6 = Ppub.duplicate().invert(); 
tt = pairing.pairing(H1(UserID[user]), temp6).pow(H6(R,k)); 
tt.mul(pairing.pairing(Z, P)); 
 
//計算b' (以bb表示) 
Element temp3 = Ppub.duplicate(); 
Element temp7 = k.duplicate(); 
bb = pairing.pairing(temp3.mul(H5(M,tt)),S); 
bb.mul(temp7.pow(h.add(v))); 
 
//計算c' (以cc表示); 
cc = pairing.pairing(P, U).mul(pairing.pairing(Ppub, 
H1(UserID[usernum])).pow(v)); 
 
//計算a' (以aa表示) 
 89 
 
public void getPCSpj(int user){ 
String tempStr = PCSpj[user]; 
String[] str = tempStr.split(lineSep); 
R = setElement(str[0],1); 
k = setElement(str[1],2); 
Z = setElement(str[2],1); 
h = new BigInteger(str[3]); 
S = setElement(str[4],1); 
U = setElement(str[5],1); 
v = new BigInteger(str[6]); 
} 
/********************************************** 
* getPCSpjM() 取得先前儲存的參與者製作承諾的M 
* @param user 參與者編號 
************************************************/ 
public void getPCSpjM(int user){ 
String[] str = PCSpjM[user].split(lineSep); 
M = ""; 
int i = 0; 
while(str[i].compareTo("!$end")!=0){ 
M = M + str[i]+ lineSep; 
i++; 
} 
M = M + str[i]+ lineSep; 
i++; 
while(str[i+1].compareTo("!$end")!=0){ 
M = M + str[i]+ lineSep; 
i++; 
} 
M = M + str[i]; 
} 
 
 
圖一：論文發表會場前留影 
 
 
圖二：Keynote Speech 
三、建議 
 
本次會議看到主辦的查理大學提供的優良場地以及對於流程控管的用心。其舉辦
的地點特意選在地鐵交通十分便利的小城區中心，鄰近市中心的舊城區以及行政中心
的城堡區，因此交通便利對於遠道而來參加會議的人士不會造成太大困擾。有一些小
缺點是其提供的告示牌不夠醒目，因此有些場地需要多找一些時間，但這些小問題都
能簡單的解決。 
 
參訪一些國際會議舉辦方式的優點與缺點，可作為未來在自己學校中要舉辦國際
性研討會的一些參考。未來爭取主辦國際研討會應已是趨勢，也是邁向國際化所必經
之道路。 
 
四、攜回資料名稱及內容 
 
1. 會議論文集兩本 
2. 會議論文集光碟一份 
3. 會議議程一份 
4. 會場陳列之其他 Call for paper 資料。 
 
五、其他 
 
本次會議未與資訊業廠商有一些合作與展示，單純為學術性的活動。也許未來舉
辦會議時可加入這項考量，讓會議更能與實務應用結合。 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
申請人 
簽章 
 系所主管 
簽章 
 院長 
簽章 
 
(本表若不敷使用，可自行影印或至本處網頁下載) 
 
 
 Conference Schedule 
Registration - second floor 8:30 – 9:30  
July 7, 2010 
 
Registration, Opening ceremony, 
keynote speaker talk, Regular 
presentations 
Opening Ceremony - room S5 9:30 – 10:00 
 
Coffee Break 
10:00 – 10:15 
 
Keynote speaker Prof. Dr.-Ing. Dr.h.c. Theo Härder- room S5 10:15 – 11:05 
Coffee break 11:05 – 11:20 
First round of sessions - S3, S4, and S5 11:20 – 1:20 
Regular Sessions 9:30 – 200  July 8, 2010 
Regular presentations, tutorials, 
closing during Gala dinner  Tutorials 3:00- 5:00  
  
July 9, 2010 
No presentation, tour to Prague 
Castle and old town 
 
The time of each presentation including questions is 20 minutes. Please follow this. 
 
 All the presentations are in Univerzita Karlova  
Matematicko-fyzikalni fakulta  
Wen : July. 7, 2010 
Title Social Networks 
Information and Data 
Management 
Ontology 
Room S3 ( Third floor) S4 ( Third floor) S5 ( Second floor) 
Time 11:20 – up 11:20 – up 11:20 – up 
Chair Adnan Al-Smadi Milan Simunek Markus Heck  
  
107- Modeling of Trust to Provide Users Assisted 
Secure Actions in Online Communities (Romina - 
Mircea-F. Vaida) 
 
136- A Collaborative Social Decision Model for Digital 
Content Credibility Improvement (Taiwan - Yuan-Chu 
Hwang) 
 
185 - Improving Similarity-Based Methods for 
Information Propagation on Social Networks (Italy - 
Francesco Buccafurri) 
 
117- Approaches to Privacy Protection in 
Location-based Services (Finland - Anna Rohunen) 
 
148- Social Media as Means for Service Design 
(Finland - Elina Annanpera) 
 
232- Extracting Fuzzy Rules to Classify Motor Imagery 
Based on a Neural Network with Weighted Fuzzy 
Membership Functions (South Korea - Sang Hong 
Lee ) 
 
194- Copyright Protection of Relational Database 
Systems (Jordan - Ashraf Odeh) 
 
83 - Distributed data-mining in the LISp-Miner system 
using Techila Grid (Czech Republic - Milan Simunek) 
 
179- Chatbot Enhanced Algorithms: A Case Study on 
Implementation in Bahasa Malaysia Human Language 
(Malaysia - Jasni Zain) 
 
182- A Framework of Dashboard System for Higher 
Education using Graph-based Visualization Technique 
 
133- Using Probability Values for Ontology Matching in 
the Grid (Germany - Axel Tenschert),  
 
210 - Rapid Creation and Deployment of Communities 
of Interest Using the CMap Ontology Editor and the 
KAoS Policy Services Framework (USA - Andrzej 
Uszok) 
 
131- Incorporating Semantics into an Intelligent 
Clothes Search System Using Ontology  (Taiwan - 
ChingI Cheng) 
 
129- Semantic Information Retrieval on Peer-to-Peer 
Networks (Turkey - A. Halim Zaiim) 
 
207- SPPODL: Semantic Peer Profile based on 
Ontology and Description Logic  ( Luxembourg - 
Wen. July 7, 2010 
 
Title 
Web Applications Security Green Computing and health care 
Informatics 
Room S3 ( Third floor) S4 ( Third floor) S5 ( Second floor) 
Time 3:00- 5:00+ 3:00- 5:00+ 3:00- 5:00+ 
Chair Julian Szymanski Jong Yoon Ezendu Ariwa 
 
 
 
118-  Method for Countering Social Bookmarking 
Pollution using User Similarities(Japan - Hiroyuki 
Hisamatsu ) 
 
162 - A Human Readable Platform Independent 
Domain Specific Language for WSDL (Hungry - Balazs 
Simon)  
 
84- Assessing the LCC Websites Quality (Saudia 
Arabia - Saleh Alwahaishi) 
 
213- Expediency Heuristic in University Conference 
Webpage (Malaysia - Roslina Sidek)  
 
163- A Human Readable Platform Independent 
Domain Specific Language for BPEL (Hungry - Balazs 
 
139- Security mapping to enhance matching 
ﬁne-grained security policies (Tunisia – Monia  Ben 
Brahim) 
 
122- Implementation and Evaluation of Fast Parallel 
Packet Filters on a Cell Processor(Japan - Yoshiyuki 
Yamashita ) 
 
188- On the Algebraic Expression of the AES S-box 
like S-boxes( Turkey - M. Tolga SAKALLI) 
 
92- Student’s Polls for Teaching Quality Evaluation as 
an Electronic Voting System ( Poland - Marcin  
Kucharczyk) 
 
211- Using Privilege Chain for Access Control and 
 
77- Lot-size planning with non-linear cost functions 
supporting environmental sustainability ( Germany 
-Markus Heck )  
 
128- Electronic Health Record (Dossier Médical 
Personnel) as a major tool for Improving Healthcare in 
France: an approach through the Situational Semiotic 
(France- Bourret Christian ) 
 
183- Data Mining Technique for Medical Diagnosis 
Using a New Smooth Support Vector Machine 
(Malaysia - Jasni Zain ) 
 
56- Clustering Analysis for Vasculitis Diseases (Turkey 
- Pınar Yıldırım) 
 
 Thursday 8, 2010 
 
Track Networks Neural Networks E-Learning 
Room S3 ( third floor) S4 ( third floor) S5 ( second floor) 
Time 9:30 – 11:30+ 9:30 – 11:30+ 9:30 – 11:30+ 
Chair Jiri Dvorsky Jan Platos Yoshiro Imai 
  
 
 
164- Metadata management in P2P over Mobile 
Ad Hoc Network(Finland - Pekka Kaipio) 
 
47- Prediction of Network Delay with Variable 
Standard Deviation, Skewness and Kurtosis 
(Lativa - Renads Safins) 
 
146- A new computational model to evaluate the 
quality of perceptual voice using E-model in VOIP 
communications (Iran - Meysam Alavi ) 
 
225 - Modeling and Verification of RBAC Security 
Policies Using Colored Petri Nets and CPN-tool 
(France - Kahloul Laid ) 
 
 
39 – Artificial Neural Network Based Technique Compare 
with "GA"  for Web Page Classification ( Libya- Alarabi Ali)  
 
154-  Artificial Neural Network-Based Algorithm for ARMA 
Model Order Estimation(Jordan - Adnan Al-Smadi) 
 
240 - Efficient Substructure Preserving MOR Using 
Real-Time Temporal Supervised Neural Network (Jordan – 
Zaer S AboHammour) 
 
101- Solving the problem of flow shop scheduling by neural 
network approach (Iran - Saeed Rouhani) 
 
 54- An optimized cost-benefit analysis for the evaluation in 
e-Learning services(Italy - Gianni Fenu) 
 
155- Services Recommendation in Systems Based on Service 
Oriented Architecture by Applying Modified ROCK 
Algorithm( Poland - Maciej Zieba) 
 
199- Dynamic properties of knowledge networks and student profile 
in e-learning environment (Czech Republic - Libor Holub) 
Information and Data Management 
Web Services Architecture, Modeling and 
Design 
 
Thursday 8, 2010 
Track Intelligent agent-based systems, 
cognitive and reactive AI systems 
Security Information and Data Management 
Room S3 ( third floor) S4 ( third floor) S5 ( second floor) 
Time 11:45- 2:00+ 11:45- 2:00+ 11:45- 2:00+ 
Chair Isamu Shioya Chih Hung Wang Jakub Yaghob 
  
 
 
153- Agent Behavior Diagram for Intelligent Agents ( Czech 
Republic - Michal Radecky ) 
 
105- Multi-Agent System Environment Based on Repeated 
Local Effect Functions ( Japan-  Isamu Shioya ) 
 
197- Hierarchical Model of Trust in Contexts( Czech Republic - 
Jan Samek ) 
 
126- A Framework for Intelligent Games ( India: Diana 
Adamatti) 
 
221- Agent-based Digital Networking in Furniture 
Manufacturing Enterprises (Greece - Dimitra Avramouli) 
 
112- Detecting malwares in Honeynet using a Multi-agent 
system (Poland - Michał Szczepanik) 
 
109 - Users’ Acceptance of Secure Biometrics 
Authentication System: Reliability and Validate of an 
Extended UTAUT Model (UK- Fahad Alharby) 
 
110- Two Dimensional Labelled Security Model with 
Partially Trusted Subjects and Its Enforcement Using 
SELinux DTE Mechanism (Slovakia- Jaroslav Janacek) 
 
200- A Roaming-based Anonymous Authentication 
Scheme in Multi-domains Vehicular Networks (Taiwan   
- Chih Hung Wang) 
 
36 - Human Authentication using Fingerprint 
Recognition Systems with Using Logic Synthesis  
(Libya - Ahmed Elmadani) 
 
69- Aerial Threat Perception Architecture using Data 
 
43- Directed Graph Representation and Traversal in 
Relational Databases (Lebanon - Ramzi Haraty)  
 
203- The Location Path to Hell Is Paved With 
Unoptimized Axes: XPath Implementation 
Tips(Czech Republic- Martin Kruliš)  
 
239 Mobile Agent-Based Digital Rights Mana 
Implementation (Belgium – Bartlomiej Ziolk)  
 
59- A Toolkit for Application Deployment on the Grid  
(Germany - Jie Tao ) 
 
 
166 - Some results in Bipolar-valued Fuzzy 
BCK/BCI-algebras (Iran - Arsham Borumand Saeid) 
 
 99 *** Any late researcher 
2:00 Free Lunch in a restaurant Profesni Dum 
A Roaming-based Anonymous Authentication Scheme in 
Multi-domains Vehicular Networks 
Chih-Hung Wang and Po-Chin Lee 
Department of Computer Science and Information Engineering 
National Chiayi University, Chiayi, Taiwan 
{Wangch, s0970397}@mail.ncyu.edu.tw 
Abstract. In vehicular networks, a vehicular user can communicate with peer 
vehicles or connect to Internet. A vehicular user could move across multiple 
access points belonging to either their home network domain or the foreign 
networks domain. In some cases, the real identity or location privacy may be 
disclosed or traced by malicious attackers. This poses challenges on privacy to 
the current vehicular networks. On the other hand, when a vehicular user drives 
to the foreign network, the foreign server has no idea to authenticate the 
vehicular user who is not the member of the foreign server. A roaming concept 
can be used to solve this problem. In this paper, we propose a privacy 
preserving authentication scheme in multi-domains vehicular networks. Our 
scheme considers three kinds of situations when the vehicular users 
communicate with the home network or foreign networks and give some 
approaches for them by combining polynomial-pool based key distribution 
scheme and roaming technology. The proposed authentication protocols are 
designed for preserving vehicular user’s real identity and location privacy. The 
security analysis and comparisons with the previous works are also discussed. 
Keywords: Vehicular Networks, Wireless Security, Privacy, Authentication, 
Pseudonym 
1 Introduction 
In recent decades, vehicular networks (VANETs) become a popular research area in 
computer networks. A vehicular user can communicate with peer vehicles or connect 
to Internet when he drives a car. Therefore, vehicles are becoming “computers on 
wheels”, or rather “computer networks on wheels” [7,8,11]. In VANETs, user privacy 
and location privacy are two popularly discussed issues. A vehicular user could drive 
across multiple access points (APs) either belonging to their home network domain or 
to the network domain owned by different authorities during a long-distance trip. The 
real identity or location privacy may be disclosed or traced by malicious attackers. 
This poses challenges on privacy to the current vehicular networks [6,7,8]. On the 
other hand, in nowadays vehicular networks researches, most of the network models 
are constructed from a single domain environment and even ignore the handover 
procedure between different road site units [2,4,9]. Since vehicular user could move 
Privacy: When the vehicular user drives on road and communicate with RSUs, he 
doesn’t want his real identity exposed. Moreover, the vehicular user also dislikes his 
location being traced by someone. Therefore, privacy of vehicular users should be 
guaranteed. 
Real-time: At the high speeds typical in vehicular networks, real-time response of 
data transmission should be considered to guarantee the communication quality. 
2.2 Network model 
A typical vehicular network, as show in Fig. 1, has three participants and two 
communication modes in the architecture. The first participant is authentication 
authorization and accounting server (AAA server) or named key distribution center 
(KDC). The entire vehicle registrations, key managements, authentications and 
authorizations are handled by AAA server. The second one is the road side unit; it is a 
wireless access point beside roads. And the last one is the vehicular user, or named 
vehicle. These three participants communicate with each other through two kinds of 
communication modes. One is the wired communication which involves AAA server 
and RSUs; the other is the wireless communication which involves the vehicular users 
and RSUs. 
Vehicular User
Internet
RSU
RSU
AAA server
Authority Center 
KDC
 
Fig. 1. A typical architecture in vehicular networks. 
In our network model, the whole network is divided into two or more sub-network 
domains. One is the home network (HN) and the others are foreign networks (FNs). 
The vehicular user can access network service at FNs. When the vehicular user wants 
to access resources at FNs, he must be authenticated and get authorization provided 
by FNs. So, the home network and the foreign network have a roaming agreement 
between networks. We assume that there exist secure channels among the home 
network, foreign networks and RSUs, which means that the wired channels are secure 
and the attacker only can launch attacks in wireless channels. 
user communicates in the foreign networks in a short term, and the last one is the 
vehicular user communicates in the foreign networks for a long period of time. 
Table 1. Notations for the proposed scheme 
jRSU  The identity of jRSU  
PID  The pseudonym set for the vehicular user 
jiTPID ,  The temporary pseudonym of the vehicular user i given by the foreign 
jRSU  
jiCA ,  The certificate-chain for authenticating the vehicular user i by jRSU  (j=0 
being the domain server) 
jiSK ,  The secret key shared between the home jRSU  and the vehicular user i 
jiTSK ,  
The temporary session key shared between the foreign jRSU  and the 
vehicular user i 
iMSK  The master secret key shared between a foreign server and the vehicular 
user i 
iMSKTR  The master secret key shared between the foreign server and the vehicular 
user i to be used for transferring domain 
jiTAK ,  The temporary authentication key for jRSU  to authenticate the    
vehicular user i 
xyK  The secret key shared between xRSU  and yRSU  
)(h  A one-way hash function 
3.2.1 The anonymous authentication protocol in the home network 
We propose a protocol by using polynomial-pool based key distribution in the case of 
the home network. In order to achieve the requirement of privacy, we improve the 
original polynomial-pool based key distribution in [5]. In the scheme of [5], each 
vehicular user must employ the real identity to compute common keys when they 
want to communicate with each other. However in VANETs, the vehicular users need 
to hide real identity for the purpose of user privacy. Thus our protocol replaces the 
real identities with pseudonyms. 
In the Setup phase, the home server generates a set of pseudonyms 
},...,,{ 31 mPIDPIDPIDPID   and several bivariate polynomials with degree t. Each 
valid polynomial has a unique index number (e.g. ),(),...,,(),,( 21 yxfyxfyxf n ). Each 
jRSU  will obtain all polynomial shares with jRSU ’s real identity from the home 
server (e.g. ),(),...,,(),,( 21 yRSUfyRSUfyRSUf jnjj ). When a vehicular user registers at 
the home server by using his real identity, he can get polynomial shares with 
pseudonyms computed by the home server (e.g. the vehicular user iID  
can obtain the 
polynomial shares ),(),...,,(),,( 10311 yPIDfyPIDfyPIDf mn ). The polynomial shares 
and pseudonyms for each vehicular user will be stored in home server’s database, as 
show in Table 2. 
identity number  , the pseudonym PID  and the random number r  encrypted by 
the authentication key to jRSU . 
Step3: When jRSU  
received the response message, it checks the polynomial identity 
number. And then, jRSU computes the same authentication key 
),(_ ,  PIDRSUfkeyau jji  and decrypts the message. After getting the random 
number r , jRSU computes the session key )||(, srhSK ji  , where s is a random 
number selected by jRSU . At the end of the step, jRSU  
sends the random number s
and the session key encrypted by the authentication key to the vehicular user. 
Step4: After receiving the message from jRSU , the vehicular user decrypts it and gets 
the random number s . Then the vehicular user checks whether the session key is 
valid or not by verifying )||( srh . If it is, the vehicular user sends s  encrypted by the 
session key back to jRSU . If jRSU  accepts the final message, the two parties can then 
perform the anonymous authentication protocol and obtain a session key which can be 
used in the follow-up communications. 
3.2.2 The anonymous authentication protocol in the foreign network 
If the vehicular user leaves the home network, he cannot access network resources in 
the foreign networks. In this case, a roaming-based anonymous authentication scheme 
is proposed. When the vehicular user goes into the foreign networks, he must be 
authenticated in order to obtain the network access right. To achieve the requirement 
of privacy, the vehicular user does not want his real identity being disclosed in the 
foreign networks. This section will discuss the case that the vehicular user shortly 
stays in the foreign networks for business or excursion. 
Assume that the vehicular user has registered at the home network and got the 
polynomial shares provided by the home server. The detail steps of the authentication 
in the foreign network, as shown in Fig. 3, are described in the following. 
Step 1: The vehicular user i sends a temporary join request message including the 
identity of the home server, the identity of the foreign server, the pseudonym, the 
polynomial identity number  , the encrypted real identity and a random number x  
to the foreign server. Note that the transmitted messages must be forwarded through 
the foreign RSU1, which is the first RSU that the vehicular user meets in the foreign 
network. The foreign server then forwards this message to the home server through a 
secure channel for checking the vehicular user. Upon receiving the message, the home 
server decrypts the message by using the authentication key and verifies the identity 
of the vehicular user. 
Step 2: If the vehicular user is valid, the home server generates a certificate 0,iCA  by 
computing )||(0, xIDhCA ii   in order to verify the vehicular user at the foreign 
server. The home server then sends the certificate to the foreign server through a 
secure channel. Upon receiving the certificate, the foreign server selects a random 
number y  and computes a master secret key )||( 0, yCAhMSK ii  . The foreign server 
then sends the random number y  encrypted by 0,iCA to the vehicular user through 
RSU1. 
vehicular user for authentication, where 2,iCA = )( 1,iCAh . RSU1 also sends the 
random numbers 1v , 1  and the certificate 2,iCA  to RSU2 for verifying the 
credential. 
Step 2: After arriving at RSU2, the vehicular user i then sends his temporary 
pseudonym 1,iTPID  and the credential encrypted by the temporary session key  
2,iTSK  to RSU2 for authentication. 
Step 3: Upon receiving the message, RSU2 computes the temporary pseudonym 
)||( 12,1, ii CAhTPID  and corresponding temporary session key
)||( 12,2, vCAhTSK ii  . Then, RSU2 decrypts and verifies the credential )( 112 kHMAC . 
If the verification passes, RSU2 generates a new temporary pseudonym 
)||( 23,2, ii CAhTPID  , a new temporary session key 3,iTSK  
and a new credential 
)( 223 kHMAC , and sends them to the vehicular user for the next handover. RSU2 
also needs to send the random numbers 2v , 2  and the certificate 3,i
CA  to RSU3. The 
vehicular user and other RSUs also run the similar procedure for authentication until 
the vehicular user reaches the destination or arrives in a new foreign network. 
Vehicular user i
),),(,( 1,112, 121, ikiTSK TPIDHMACTSKE i  112,
,, vCA i
)),((, 111, 122, kTSKi HMACETPID i
RSU1 RSU2
),),(,(, 2,223,1, 232, ikiTSKi TPIDHMACTSKETPID i 
 
Fig. 4. Handover procedure in the foreign network. 
3.2.3 The transferring domain protocol in the foreign networks 
We consider that the vehicular users stay in the foreign network for a long period of 
time, such as the vehicular user changing dwelling place or standing in a new location 
for a business trip over one week. In this case, as the vehicular users use the foreign 
network resource in a long term of time, the communication overheads rapidly 
increase with a large number of authentications or handover processes if the protocol 
in the previous section is used. Therefore, we design a transferring domain 
authentication protocol to solve this problem. The detail steps of the protocol, as 
shown in Fig. 5, are described in the following. Note that the messages transmitted 
between the vehicular user and foreign server must be forwarded through the RSU. 
For simplicity we omit the RSU in the protocol. 
Step 1: The vehicular user sends a domain transfer request message including the 
identity of the home server, the identity of the foreign server, the pseudonym, the 
4 Discussion 
4.1 Security of the proposed schemes 
Authentication 
In our protocols, only legitimate users can access the network resource. All vehicular 
users must be authenticated by the home server or the foreign server through RSUs. 
Also, the vehicular users must authenticate the server to check whether it is 
legitimate. 
While the vehicular user stays in the home network, the authentication key is used 
to confirm the validity of the users and RSUs. To be authenticated by RSUs, the 
vehicular user must be able to generate a correct authentication key. According to our 
design, except for the vehicular user and jRSU , no one can generate the session key 
)||(, srhSK ji   without getting the authentication key because the random values r  
and s  are protected by the authentication key during transmission. Therefore, the 
vehicular user and jRSU  
can achieve mutual authentication after carrying out the 
anonymous authentication protocol. 
While the vehicular user stays in the foreign network, the foreign server and RSUs 
cannot directly authenticate the vehicular user. However, this situation can be treated 
as roaming. In our protocol, the foreign server sends the authentication message of the 
vehicular user to the home server. Except for the vehicular user and the foreign 
server, no one can generate the master secret key )||( 0, yCAhMSK ii  used in the 
anonymous authentication protocol in the foreign network, because the certificate 
)||(0, xIDCA ii  is delivered through a secure channel and unknown to the malicious 
outsiders. However, if the foreign server is unauthorized, it cannot get the certificate 
from the home server because it is assumed that there exists a roaming agreement 
between the home network and the foreign network.  
While the vehicular user wants to transfer to other domain, except for the vehicular 
user and the foreign server, no one can generate the master secret key 
)||||( yxIDhMSKTR ii  used in the proposed transferring domain protocol, because 
the malicious outsiders cannot know the real identity and the random values x and 
y . If the foreign server is unauthorized, it cannot get the real identity and the random 
number selected by the vehicular user from the home server. 
In the handover procedure, 1jRSU  can generate the temporary session key, the 
credential and the temporary pseudonym for the next stage. The vehicular user can 
obtain the above messages from 1jRSU . Also, jRSU  can compute the temporary 
session key by using the temporary pseudonym and random number received from 
1jRSU . Therefore, the vehicular user and jRSU  can mutually authenticate each 
other. Similar to the previous works, our scheme did not consider RSUs’ compromise 
raising impersonation or eavesdropping attacks. 
 
 
preserving authentication scheme in vehicular networks. Zhang et al.’s scheme is 
based on the blind signature in the elliptic curve arithmetic. 
The computational cost and communication cost of several schemes are shown in 
Table 3, where hC denotes the cost of executing the hash function,  symC  
denotes the 
cost of executing a symmetric encryption or decryption, polyC  denotes the cost of 
computing a polynomial result, asymC  denotes the cost of executing an asymmetric 
encryption or decryption, pairingC  denotes the cost of executing a pairing operation,  
RSU_AAA denotes the number of transmissions between RSU and AAA, V_RSU 
denotes the number of transmissions between the vehicular user and RSU, RSU_RSU 
denotes the number of transmissions between two different RSUs, AAA_AAA 
denotes the number of transmissions between two different AAAs and n denotes the 
number of RSUs the vehicular user meets in the handover procedure. In the 
comparison of computational cost, our method looks a little worse than Chuang and 
Lee’s scheme but better than kim et al.’s and Zhang et al.’s schemes in performance 
for the foreign network authentication. Further, in handover procedure, our method is 
more efficient than the others’ schemes in the case that a vehicular user moves across 
multiple RSUs. Hence, the efficiency by using symmetric cryptosystems in our 
method is suitable for high-speed movement in VANETs. 
Table 3. Comparison of several schemes 
 
Chuang and Lee 
[1] 
kim et al.  
[3] 
Zhang et al.  
[10] 
Ours 
Computat-
ion Cost 
Foreign 
Network 
Authenti-
cation 
7 hC + 
4 symC  
10 hC + 
7 symC + 
4 asymC  
6 symC + 
4 pairingC  
11 hC + 
10 symC + 
2 polyC  
Handover 
Procedure 
(5 hC + 
4 symC )*n 
(6 hC +4 symC
+2 asymC )*n 
(3 hC +4 symC
+3 pairingC )*n 
(6 hC + 
2 symC )*n 
Communi-
cation Cost 
Foreign 
Network 
Authenti-
cation 
2RSU_AAA 
2V_RSU 
2RSU_AAA 
2V_RSU 
5RSU_AAA 
6V_RSU 
2AAA_AAA 
5RSU_AAA 
5V_RSU 
Handover 
Procedure 
3V_RSU*n 
(2V_RSU+ 
RSU_RSU) 
*n 
(5V_RSU+ 
2RSU_RSU)*n 
(2V_RSU+ 
RSU_RSU) 
*n 
Mutual Authentication
 
Yes Yes Yes Yes 
Location/User Privacy No Yes Yes Yes 
Consideration of Multi-
domains 
Yes No No Yes 
 
In the comparison of the communication cost, it is clear that our approach is not the 
best one in the foreign network authentication. Our approach takes some costs for the 
foreign server to check an anonymous user who comes from the other domain in the 
foreign network authentication. Hence, our approach looks a little worse than the 
6. Plobl K., Nowey T., Mletzko C.: Towards a Security Architecture for Vehicular 
Ad Hoc Networks. The First International Conference on Availability, Reliability 
and Security. (2006) 
7. Raya M., Hubaux J. P.: The Security of Vehicular Ad Hoc Networks. The 3rd 
ACM Workshop on Security of Ad hoc and Sensor Networks, pp. 11-21. (2005) 
8. Raya M., Hubaux J. P.: Securing Vehicular Ad Hoc Networks. Journal of 
Computer Security, 15(1):39-68. (2007) 
9. Xi Y., Sha K., Shi W., Schwiebert L., Zhang T.: Enforcing Privacy Using 
Symmetric Random Key-set in Vehicular Networks. International Symposium on 
Autonomous Decentralized Systems, pp. 344-351. (2007) 
10. Zhang C., Liu R-X., Ho P. H., Chen A.: A Location Privacy Preserving 
Authentication Scheme in Vehicular Networks. IEEE Wireless Communications 
and Networking Conference, pp. 2543-2548. (2008) 
11. Now: Network on wheels, http://www.network-on-wheels.de 
97年度專題研究計畫研究成果彙整表 
計畫主持人：王智弘 計畫編號：97-2221-E-415-002-MY2 
計畫名稱：多方公平交換協定設計與安全分析及其在電子商務應用系統之開發 
量化 
成果項目 實際已達成
數（被接受
或已發表）
預期總達成
數(含實際已
達成數) 
本計畫實
際貢獻百
分比 
單位 
備 註 （ 質 化 說
明：如數個計畫
共同成果、成果
列 為 該 期 刊 之
封 面 故 事 ...
等） 
期刊論文 0 0 0%  
研究報告/技術報告 1 0 50% 
我們對於公平交
換的議題，也研究
了並存簽章的安
全性問題，論文
為：並存簽章在公
平交換的使用與
改進，發表在「資
訊安全通訊」Vol. 
16, No.3, pp. 
60-71。 
研討會論文 0 0 0% 
篇 
 
論文著作 
專書 0 0 0%   
申請中件數 0 0 0%  專利 已獲得件數 0 0 0% 件  
件數 0 0 0% 件  
技術移轉 
權利金 0 0 0% 千元  
碩士生 3 0 100% 
協助完成理論架
構、安全分析、程
式撰寫以及報告
整理等事項。 
博士生 0 0 0%  
博士後研究員 0 0 0%  
國內 
參與計畫人力 
（本國籍） 
專任助理 1 0 15% 
人次 
協助完成理論架
構、安全分析等。
期刊論文 0 1 100% 
本計劃已將相關
成果寫成論文：An 
Identity-based 
Fair Contract 
Signing Protocol 
from Bilinear 
Pairings，投稿至
國外知名期刊（英
文論文），目前正
審查中。 
國外 論文著作 
研究報告/技術報告 0 0 0% 
篇 
 
 
