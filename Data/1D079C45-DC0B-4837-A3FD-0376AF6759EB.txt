1 
行政院國家科學委員會專題研究計畫成果報告 
具備迴旋編碼特性之二元平方剩餘碼應用於 
無線通訊之超大型積體電路研究 
計畫編號：NSC 97－2221－E－214－027－MY2 
執行期限：2008 年 08 月 01 日至 2010 年 07 月 31 日 
    主持人：李崇道    義守大學通訊工程學系 
共同主持人：張肇健    義守大學資訊工程學系 
 
 
一、中、英文摘要 
本計畫於第一年度研究內容在找尋二元
平方剩餘碼迴旋編碼之最佳編碼方式，於執
行計畫後已獲得了多項豐碩成果。首先，提
出一個有效率計算的演算法來找出可以迴旋
編碼的方式，用以確定最佳的編碼器該如何
製作。此演算法已經經由軟體 C++語言實現
並執行找尋二元平方剩餘碼迴旋編碼。計算
後結果為平方剩餘碼碼長 24, 32, 48, 72, 
80, 104, 128 的最佳迴旋編碼器[1-3]約束長
度分別為 4, 4, 8, 11, 14, 20, 22。這些
結果是部份是新且未被發表的研究成果。 
本計畫於第二年度研究內容著重在二元
平方剩餘碼解碼器設計，根據二元平方剩餘
碼在不可約分生成多項式之特性共有三個新
解碼演算方法[4-6]，第一個解碼法過程是已
知 症 狀 計 算 、 未 知 症 狀 計 算 、
Berlekamp-Massey 演算法、錯誤位置計算(找
根演算法)。第二個解碼法過程是已知症狀計
算、通用型錯誤位置多項式計算、找根演算
法。第三個解碼法針對碼長度 23 之二元平方
剩餘碼，解碼過程有已知症狀計算、特殊通
用型錯誤位置多項式計算、找根演算法。 
另外，本計畫執行時也針對糾錯兩個位
元的 Zetterberg 碼研究出以少傳送一資訊位
元讓原本部分 Zetterberg 碼糾錯一個位元可
以糾錯至兩個位元[7]。 
 
Abstract 
In this project, an efficient algorithm to 
find the convolutional encoding of binary 
extended quadratic residue (QR) codes is 
proposed. This algorithm has been verified by 
software simulation. Programs in C++ 
language have been executed to search the 
possible convolutional encoding of the extended 
QR codes with code lengths divided by 8 and up 
to 80. Simulation results show in [1-3] that the 
smallest constraint length K=4 (resp., K=4, 8, 
11, 14, 20, 22) is convolutionally encoded for 
the extended QR code with code length 24 (resp., 
32, 48, 72, 80, 104, 128). 
    On the other hand, three decoders for 
binary QR codes with irreducible generator 
polynomials are proposed in [4-6]. The first 
decoder consists of known and unknown 
syndromes calculations, Berlekamp-Massey 
algorithm, and error locator determination. The 
second decoder consists of known syndrome 
calculations, general error locator polynomial 
computation, and finding-root algorithm. 
    Besides, the family of Zetterberg codes 
[3] C.D. Lee, T.K. Truong, “Convolutional 
Encoding of Binary (128,64,20) Quadratic 
Residue Codes,” Electronic Technology 
Symposium (ETS), I-Shou University, 
Taiwan, 2009.06 
 [4] Y. Chang, C.D. Lee, “Algebraic decoding 
of a class of binary cyclic ocdes via 
Lagrange interpolation formula,” IEEE 
Transactions on Information Theory, vol. 
56, no. 1, pp. 130-139, 2010.01 
 
下面兩圖為 quartus 軟體設計二元平方剩
餘碼長 79 迴旋編碼器。 
 
[5] C.D. Lee, Y. Chang, H. H. Chang, J. H. 
Chen, “Unusual general error locator 
polynomial for the (23,12,7) Golay code,” 
IEEE Communications Letters, vol. 14, no. 
4, pp. 339-341, 2010.04 
3 
[6] C.D. Lee, Y. Chang, “Decoding the (41, 21, 
9) Binary Quadratic Residue Code,” The 
International MultiConference of 
Engineers and Computer Scientists 2010, 
pp.780-783, Hong Kong, China, 2010.03 
 
 
 
[7] M. H. Jing, Y. Chang, C.D. Lee, J. H. Chen, 
Z. H. Chen, “A Result on Zetterberg 
Codes,” IEEE Communications Letters, vol. 
14, no. 7, pp. 662-663, 2010.07 
 
 
四、計畫內容 
本計畫第一年度研究內容為二元平方剩
餘碼迴旋編碼之最佳編碼方式，下面兩圖為
quartus 軟體設計二元平方剩餘碼長 47 迴旋
編碼器。 
 
 
本計畫第二年度研究主內容為二元平方
剩餘碼新解碼演算法之開發，共提出有三個
演算法，第一個解碼法是結合症狀計算與
Berlekamp-Massey 演算法。第二個解碼法是
利用通用型錯誤位置多項式計算。第三個
Golay 解碼法三步驟在計算一個症狀值、計算
特殊通用型錯誤位置多項式兩個係數值、決
定錯誤位置。  
 
21, 2, ..., n − 1} is the collection of all nonzero quadratic
residues modulo n. Since n ≡ ±1 (mod 8), 2 ∈ Q and
the set Q can be expressed as a disjoint union of cyclotomic
cosets modulo n. Let these cyclotomic cosets be denoted by
Ci = {i · 2j | j = 0, 1, ..., ni − 1}, where ni is the smallest
positive integer such that i·2ni ≡ i (mod n). If i is the smallest
element in Ci, then call i the representative element of Ci. For
a binary QR code with irreducible generator polynomial, the
set Q is equivalent to the unique cyclotomic coset C1. For
more detailed discussion, see [5] and [8].
B. Syndromes
Let the code polynomial c(x) = c0+ c1x+ · · ·+ cn−1xn−1
be transmitted through a noisy channel and let R(x) be the
received polynomial; then R(x) can be expressed as R(x) =
c(x)+e(x), where e(x) = e0+e1x+· · ·+en−1xn−1 is an error
polynomial. If the weight of e(x) is less than or equal to the
error-correcting capacity t = b(d− 1)/2c, where bxc denotes
the greatest integer less than or equal to x, then e(x) can be
corrected and is called correctable. Assume e(x) = xl1+xl2+
· · ·+ xlv is correctable with 0 ≤ l1 < l2 < · · · < lv ≤ n− 1.
For i ∈ {1, . . . , n − 1}, denote by Si = e(βi) and is called
the ith syndrome. Note that if i ∈ SC then
Si = e(βi) = R(βi) (1)
that can be calculated from the received polynomial R(x) and
is then called the known syndrome. On the other hand, call
the syndrome Si, where i 6∈ SC , the unknown syndrome. By
definition, the syndrome Si can be written as
Si = (βl1)i + (βl2)i + · · ·+ (βlv )i, (2)
where βlj for 1 ≤ j ≤ v are called the error locators and for
any binary cyclic codes, there is an obvious relation among
syndromes, namely, S2i = S2i , with sub-indices modulo n,
if necessary. In the case of binary QR code generated by
irreducible polynomial, one has Q = C1, and every known
syndrome is a power of S1; we call S1 the primary known
syndrome. On the contrary, if b is the smallest quadratic non-
residue, then every unknown syndrome is a power of Sb, and
Sb is called the primary unknown syndrome. If the error pattern
e(x) is correctable, then its associated syndrome S1 is said
to be correctable and denote by E the set of all correctable
syndromes, i.e.
E = {
t∑
i=1
aiβ
li | 0 ≤ l1 < · · · < lt < n, 1 ≤ v ≤ t,
ai = 1 for i ≤ v, ai = 0 for i > v}.
C. Error-Locator Polynomials
For v ≤ t, the v-error error-locator polynomial for every
correctable error pattern of weight v is defined by
σn,v(x) =
v∏
j=1
(1 + βljx) = 1 +
v∑
j=1
σ
(v)
j x
j , (3)
where
σ
(v)
j =
∑
1≤i1<···<ij≤v
βli1 · · ·βlij (1 ≤ j ≤ v). (4)
D. General Error-Locator Polynomials
The polynomial σn(x) defined below is an error-locator
polynomial for every correctable error pattern of weights v not
exceed t and is called the general error-locator polynomial:
σn(x) = 1 +
t∑
j=1
σ˜jx
j , (5)
where σ˜j is a function of a, a ∈ E. For each j = 1, . . . , t, the
coefficient σ˜j can be determined by applying the LIF and is
actually a binary polynomial function of a over F = GF (2).
E. Lagrange Interpolation Formula
The finite field version of LIF can be found in [16] and
is as follows: for q ≥ 0 let a0, a1, . . . , aq be q + 1 distinct
elements of E, and let b0, b1, . . . , bq be q+1 arbitrary elements
of E. Then there exists exactly one polynomial L(x) ∈ E[x]
of degree at most q such that L(ai) = bi for i = 0, 1, . . . , q.
The polynomial L(x) can be written in the form
L(x) =
q∑
i=0
bi
h′(ai)
h(x)
x− ai (6)
with h(x) =
∏q
k=0(x − ak) and h′(x) is the derivative of
h(x).
If a = βl1 + βl2 + · · · + βli ∈ E is a syndrome of an
error pattern of weight v, and if σn,v(x) =
∑v
j=1 σjx
j is
the associated error-locator polynomial, for r = 1, . . . , v,
use the notation a{r} to denote the coefficient σr of σn,v(x),
i.e. a{r} = σr. Since all correctable syndromes are distinct,
see [8], the polynomial Lr(x) obtained from the LIF has the
property Lr(a) = a{r} for a ∈ E and has the form
Lr(x) =
∑
a∈E
a{r}
H ′(a)
H(x)
x− a, (7)
where H(x) =
∏
a∈E(x−a). In Section III-A, it is illustrated
that the polynomial Lr(x) has the form Lr(x) = xrϕ(xn)
with ϕ(xn) a binary polynomial.
F. Generalizations of the Orsini-Sala Theorem
Recall that C is a binary cyclic code with error-correcting
capacity t, odd length n, any number of errors v, and defining
set SC . Let E be the splitting field of xn − 1 over F.
Definition 1: Let W and Tv , respectively, denote the fol-
lowing sets:
W = {β ∈ F|βn = 1},
Tv = {(β1, . . . , βv) ∈W v|βi 6= βj , i 6= j}.
We define φv to be the following map
φv : Tv → Uv = {
∑
j=1...v
βlj |(β1, . . . , βv) ∈ Tv},
where φv computes the sum of all (lth powers of the) vector
components.
Set W contains the n-roots of unity (and thus all possible
error locations), set Tv contains all possible sets of v distinct
error locations, while Uv contains their sum (or better, the sum
42) Use the IFBMA developed in Section III-B to determine
the error-locator polynomial of the QR code.
3) Use the Chien search or the fast algorithm [15] to obtain
the roots of the above error-locator polynomial and finally the
corrected codeword is obtained by subtracting the error vector
from the received vector.
IV. DECODING BY GENERAL ERROR-LOCATOR
POLYNOMIALS
This section consists of three subsections. The general error-
locator polynomials in Section IV-A are utilized to decode
the two QR codes in Section IV-C based on the algorithm
developed in Section IV-B.
A. General Error-Locator Polynomial
Computer simulations provide the threetwo general error-
locator polynomials for the binary QR codes with lengths
17 and 23 below, which can be employed in the decoding
algorithm of Section IV-B.
1) (17, 9, 5) QR code:
σ17(x) = 1 + S1x+ (
∑
i∈A17
Si1)x
2, (13)
where A17 = {53, 87, 104, 121}, which appears in [13].
Denote by |A17| and dA17e the cardinality of An and then
maximal value in An, respectively. In the case n = 17,
|A17| = 4 and dA17e = 121. Since every number in the index
set A17 is congruent to r = 2 modulo n = 17, to save space,
subtract 2 from each element of A17 and then divided by 17
to obtain {3, 5, 6, 7}. Use this to index the positions of 1 in
a base-2 number. Then we have the sequence 00010111 and
its hexadecimal representation is 8e. Denote the final result by
〈A17〉, i.e. 〈A17〉 = 8e.
2) (23, 12, 7) QR code:
σ23(x) = 1 + S1x+ (
∑
i∈A23
Si1)x
2 + (
∑
j∈B23
Sj1)x
3, (14)
where 〈A23〉 = 17fb97ffbffdbfcfffffff1, 〈B23〉 =
077b97ffbffdbfcfffffff1, |A23| = 76, |B23| = 74,
dA23e = 2026, and dB23e = 2027.
B. Algorithm D2
In Steps 1) and 3) of the decoding algorithm presented
below, the computations for the two QR codes are the same,
but in Step 2) the computations are different. Step 2) is the
step for calculating the general error-locator polynomial of a
QR code. Steps 2.1) and 2.2) are the steps for the (17, 9,
5) and (23, 12, 7) QR codes, respectively. Now the proposed
algorithm is described below by three steps.
1′) Calculate the primary known syndrome S1 for a binary
QR code from (1) in Section II-B.
2′) Calculate the general error-locator polynomial of a binary
QR code developed in Section IV-A.
2′.1) Calculate σ17(x) in (13) of the (17, 9, 5) QR code.
2′.2) Calculate σ23(x) in (14) of the (23, 12, 7) QR code.
3′) Use the Chien search or the fast algorithm [15] to obtain the
roots of the above error-locator polynomial and then correct
errors.
C. Examples
Let β = α15 be a primitive 17th root of unity in GF (28),
where α is a root of the primitive polynomial p(x) = 1 +
x2 + x3 + x4 + x8. The set of quadratic residues modulo 17
defined in Section II is Q = {1, 4, 9, 16, 8, 2, 15, 13}, and the
generator polynomial of the code is g(x) =
∏
i∈Q(x− βi) =
1+x+x2+x4+x6+x7+x8. Let I(x) = x+x3+x5+x6
be the information polynomial. Utilization of the systematic
encoder
c(x) = I(x) · x8 + [I(x) · x8 mod g(x)] (15)
yields the code polynomial c(x) = 1 + x3 + x6 + x7 + x9 +
x11 + x13 + x14.
If e(x) = x7 is the error polynomial, then the received
polynomial R(x) = c(x) + e(x) = 1 + x3 + x6 + x9 + x11 +
x13 + x14. The proposed decoding process is as follows. By
evaluating R(x) at the roots of g(x) in (1), the primary known
syndrome is S1 = α105 6= 0, which means that errors occurred.
Next, substituting S1 = α105 into the general error-locator
polynomial, (13) becomes
σ17(x) = 1 + S1x+ (S531 + S
87
1 + S
104
1 + S
121
1 )x
2
= 1 + α105x+ (α210 + α210 + α210 + α210)x2
= 1 + α105x. (16)
By the Chien search, a computer simulation shows that
σ17(x) = 0 has only one root x = α−105 = β−7 which
implies finally that e(x) = x7.
On the other hand, if e(x) = x3 + x10 is the error
polynomial, then one has the received polynomial R(x) =
1+x6+x7+x9+x10+x11+x13+x14 and the primary known
syndrome S1 = α38. The general error-locator polynomial in
(13) can be determined:
σ17(x) = 1 + S1x+ (S531 + S
87
1 + S
104
1 + S
121
1 )x
2
= 1 + α38x+ (α229 + α246 + α127 + α8)x2
= 1 + α38x+ α221x2. (17)
Application of the Chien search implies x = β−3 and x =
β−10 are of roots of σ17(x) = 0 which means the received
word can be corrected successfully.
Similar encoding and decoding procedures for the (23, 12,
7) QR code are completely listed in Table III. Although the
general error-locator polynomial provides an algebraic decoder
for QR codes, it seems inefficient when the low-weighted
errors occurred. This question will be solved in the next
section.
V. SIMULATION RESULTS
Two algorithms described in the previous sections and two
algorithms previously developed were implemented on a Duo
T7500 INTEL personal computer in C++ language. Table VI
is a timetable for the Lee-Chang-Truong (LCT) algorithm [3],
Chang-Truong-Reed-Cheng-Lee (CTRCL) algorithm [8], and
the two developed algorithms to decode the two QR codes
mentioned in this paper, respectively. The computational times
in seconds listed for a given code length n and error-weight v
6TABLE I
ENCODING OF THE TWO BINARY QR CODES
n 17 23
β α15 α89
Q {1, 4, 9, 16, 8, 2, 15} {1, 4, 9, 16, 2, 13, 3,
18, 12, 8, 6}
p(x) 1 + x2 + x3 + x4 + x8 1 + x2 + x11
g(x) 1 + x3 + x4 + x5 + x8 1 + x+ x5
+x6 + x7 + x9 + x11
I(x) x+ x3 + x5 + x6 1 + x8 + x11
c(x) 1 + x3 + x6 + x7 1 + x3 + x5 + x7
+x9 + x11 + x13 + x14 +x8 + x11 + x19 + x22
TABLE II
DECODING OF BINARY TWO QR CODES USING ALGORITHM D2
n e(x) S1 σn(x)
17 x7 α105 1 + α105x+ 0x2
x3 + x10 α38 1 + α38x+ α221x2
23 x20 α1780 1 + α1780x+ 0x2 + 0x3
x6 + x13 α1307 1 + α1307x+ α1691x2 + 0x3
1 + x5 + x17 α63 1 + α63x+ α292x2 + α1958x3
TABLE III
COMPUTATIONAL TIME IN SECONDS FOR VARIOUS ALGORITHMS TO DECODE THE TWO BINARY QR CODES WITH ALL CORRECTABLE ERROR
PATTERNS IMPLEMENTED ON A DUO T7500 INTEL PERSONAL COMPUTER
n v D2 Algorithm D1 Algorithm CTRCL Algorithm LCT Algorithm
17 1 0.001892 0.002804 0.002722 0.012794
2 0.016035 0.023242 0.036362 0.102283
23 1 0.005382 0.007221 0.006439 0.054770
2 0.063524 0.084711 0.133874 0.398495
3 0.453761 0.598908 1.535022 4.369013
2(ai, bi) = (βli1 , 0), 0 ≤ li1 ≤ 22 (3)
(ai, bi) = (
∑
1≤i1<···<iu≤v
βli1 · · ·βliu ,
∑
1≤i1<···<iu+1≤v
βli1 · · ·βliu+1 ) for u = j − 1, j ≤ v ≤ 3 (4)
σˆ3 =
∑
j∈A2 σˆ
j
2, where
A1 =

2, 94, 117, 140, 186,
209, 232, 255, 278, 301,
347, 370, 439, 462, 485,
508, 554, 577, 600, 623,
646, 669, 692, 715, 738,
761, 807, 830, 853, 876,
899, 922, 945, 968, 991,
1014, 1060, 1083, 1106, 1129,
1175, 1198, 1221, 1244, 1267,
1336, 1359, 1382, 1405, 1428,
1451, 1474, 1497, 1520, 1543,
1566, 1589, 1612, 1635, 1658,
1681, 1704, 1727, 1750, 1773,
1796, 1819, 1842, 1865, 1888,
1911, 1934, 1957, 1980, 2003,
2026

(5)
and
A2 =

36, 59, 105, 128, 174,
197, 220, 243, 289, 335,
404, 473, 496, 519, 542,
588, 634, 726, 749, 864,
1002, 1117, 1140, 1163, 1186,
1324, 1370, 1416, 1508, 1554,
1577, 1600, 1669, 1784

. (6)
In the following subsection, we present a new algebraic
decoding algorithm of Golay code utilizing the obtained GELP.
B. Algorithm I
The proposed algorithm is summarized below by five steps.
1) Compute the known syndrome S1 from (1) in Section
II-A and initialize v = 1.
2) Compute the coefficients σˆi of GELP σˆ(y1, y2; z) for
1 ≤ i ≤ v + 1 developed in Section III-A.
3) If σˆv+1 = 0, go to step 5. Otherwise, set v = v+1 and
then go to step 4.
4) If v > 3, stop. Otherwise, go to step 2.
5) Use the Chien search or fast algorithm to find the roots
of the above GELP and then correct errors.
In this algorithm, σˆv+1 provides a check criterion to start
the Chien search. In other words, σˆv+1 plays an important role
in the early termination of decoding attempts. It will be seen
in the Section V that this decoding with early termination
requires considerably fewer decoding complexity than the
algebraic decoding approach in [8].
IV. PROPOSED ELPS
A. Polynomial Calculation
For correctable error patterns of a fixed weight v ≤ 3, the
ELP σ(y1, . . . , yv−1; z) of degree v is defined to be
σ(y1, . . . , yv−1; z) = 1 + σ
(v)
1 z +
v∑
j=2
σ
(v)
j (yj−1)z
j , (7)
where y1 = σ
(v)
1 = S1 and yj = σ
(v)
j (yj−1) for j = 2, 3.
Similarly, we apply the LIF mentioned in Section II-B to
find undetermined coefficients of two ELPs, and then by a
computer calculation the obtained ELPs are shown in (8)-(9).
B. Algorithm II
The proposed algorithm is summarized below by six steps.
1) Compute the known syndrome S1 from (1) in Section
II-A and initialize v = 1.
2) Compute ELP σ(y1, . . . , yv−1; z) for 1 ≤ v ≤ 3
developed in Section IV-A.
3) Use the Chien search or fast algorithm to find the roots
of the above ELP.
4) If the number of the roots equals v, go to step 6.
Otherwise, set v = v + 1.
5) If v > 3, stop. Otherwise, go to step 2.
6) Use the obtained error pattern to correct the corrupted
word.
V. COMPLEXITY ANALYSIS
In this section, Elia’s [9], Wei-Wei [11], Lee’s [12], the two
algorithms developed in [8], and the two proposed algorithms
are compared. It is easy to see that Algorithm II totally
(respectively, for one-, three-error case) requires few com-
putation than Elia’s (respectively, Wei-Wei, Lee’s) algorithm.
The reasons are 3 syndromes needed in Elia’s and Wei-Wei
algorithms, and iterative decoding attempts in Wei-Wei and
Lee’s algorithms. In Table I, Algorithm D2 is the algebraic
decoding of using GELP and Algorithm D3 using several ELPs
developed originally in [8]. To estimate the computational
complexity, the numbers of finite field addition as well as
multiplication and decision for various decoding processes in
the five algorithms are given in Table I. Tables II lists the
numbers of finite field addition and multiplication on various
ELPs for the (23, 12, 7) Golay code. The total decoding
complexities of four algorithms for the Golay code mentioned
above are illustrated in Table III. This table demonstrates
the superiority of Algorithm I in the decoding complexity to
Algorithm D2. Algorithms II and D3 perform almost the same.
出席國際學術會議心得報告 
                                                             
計畫編號 NSC97-2221-E-214-027-MY2 
計畫名稱 
具備迴旋編碼特性之二元平方剩餘碼應用於無線通訊 
之超大型積體電路研究 
出國人員姓名 
服務機關及職稱 
李崇道 
義守大學通訊工程學系助理教授 
會議時間地點 2010/3/17-2010/3/19 香港 
會議名稱 The International MultiConference of Engineerings and Computer Scientists 2010 
發表論文題目 Decoding the (41,21,9) Binary Quadratic Residue Code 
 
※ 會議規模：;全球性  □ 區域性。 
與會國家／人數：約 50 國／ 700 人。 
 
一、研習心得 
 
香港的工程師國際學會 (The International Association of Engineers, IAENG)主辦此次學術會
議，即 The International MultiConference of Engineers and Computer Scientists (IMECS2010) 。
舉辦地點在中國香港，此學術會議今年有15個聯合會議一同舉辦。其中，The 2010 IAENG 
International Conference on Communication Systems and Applications (ICCSA2010)學術會議是
每年都有舉辦的國際性學術會議。IMECS2010收到1047篇投稿論文，最後只收錄589篇會議論
文於會中發表，會議論文錄取率56.26%。ICCSA2010共收錄19篇重要會議論文，8篇Poster論
文。由於在全世界研究工程技術的專家學者眾多，因此會議頗受到國際工程學術界重視。 
 
去年三月我曾使用國科會計畫出席國際會議經費到中國香港參加2009年The International 
MultiConference of Engineers and Computer Scientists (IMECS2009) 國際會議於會中發表論
文，此次至香港發表研究論文成果經費也得到義守大學補助教師出席國際會議經費，有足夠
經費成行。由於是第二次參加會議所以對於香港機場至會議地點已有瞭解，行程透過旅行社
安排，於三月十六日搭乘中華航空班機於早上十一點抵達香港國際機場，再坐城市巴士到飯
店入住。 
 
會議期間共展開三天的分組學術論文發表與討論，在同一時段有六個分組同時進行。ICCSA
有三個 Sessions，一個在第一天上午，兩個在第三天上午，研究領域主題有 
Communications Theory : Coding theory and techniques, Fading channels, Multiplexing, 
Adaptive modeling, Filtering techniques, Noise reduction, Transmission diversity, Demodulation, 
Synchronization, Queuing Theory, Modulation  
二、會議（任務）執行情形 
 
第一天 16 日  啟程前往會議地點中國香港。 
第二天 17日  在會議地點Royal Garden飯店參加上下午 Sessions觀察 Presentation情形。 
第三天 18 日  參加 Sessions 討論，與與會之專家學者學術交流。 
第四天 19 日  上午發表論文，期間與與會之專家學者學術交流。 
第五天 20 日  返回高雄。 
 
三、返（回）國後需要處理之工作要項 
 
根據與會專家對本發表題目之建議進一步研究。 
與會心得與論文集光碟分享給本校相關研究專家與教授參考。 
 
四、建議之工作計畫 
 
規劃與本校教授們共組研究團隊，提升研究風氣、開發重要成果與積極參與國際會議增長見
識。 
Decoding the (41, 21, 9) Quadratic Residue Code
Chong-Dao Lee, Yaotsu Chang ∗
Abstract—This paper proposes an algebraic decod-
ing algorithm for the (41, 21, 9) quadratic residue
code via Lagrange interpolation formula to determine
error check and error locator polynomials. Programs
written in C++ language have been executed to check
every possible error pattern of this quadratic residue
code.
Keywords: Lagrange interpolation formula, quadratic
residue code, error locator polynomial
1 Introduction
Quadratic residue codes [1] are a class of good algebraic
error-correcting codes due to its large minimum distance.
Recent research on quadratic residue codes is devoted to
developing the algebraic decoding method [2]-[6], deter-
mining weight distribution [7], finding double circulant
presentation [8], and improving the bounds of the mini-
mum distance [9]. In particular, the algebraic decoding
of the (41, 21, 9) binary quadratic residue codes [10] was
based on the unknown syndrome [11]-[15], error locator
polynomial [12]-[15], and lookup table [16].
In this paper, the Lagrange interpolation formula instead
of the previous algebraic methods, such as syndrome ma-
trix and Newton identities, is utilized to derive the error
check and error locator polynomials for the use of decod-
ing algorithm of the (41, 21, 9) quadratic residue code.
Programs written in C++ language have been executed
to check every possible error pattern of this quadratic
residue code. Moreover, the decoding algorithm proposed
here requires much less computational time than Algo-
rithm D2 in [6].
Section 2 describes the brief introductions concerning QR
code, syndrome, Lagrange interpolation formula. Sec-
tion 3 defines the error check and error locator polynomi-
als. Also, these polynomials are determined by Lagrange
interpolation formula and are used in the proposed de-
coding algorithm in Section 4. Conclusions are given in
the final section of the paper.
∗Departments of Communication Engineering and Applied
Mathematics, I-Shou University, Taiwan, R.O.C. Tel/Fax: 886-7-
6577711/6578930 Email: {chongdao, ytchang}@isu.edu.tw
2 Preliminaries
2.1 Quadratic Residue Code
Let n be a prime number of the form n ≡ ±1 (mod
8). A binary quadratic residue code of length n is an
(n, (n+ 1)/2, d) cyclic code with a generator polynomial
g(x) =
∏
i∈Q(x − βi) , where d stands for the minimum
distance, the set Q = {i|i ≡ j2 mod n for 1 ≤ j ≤ n− 1}
is the collection of all nonzero quadratic residues modulo
n and β is a primitive nth root of unity in E = GF (2m)
satisfying n | 2m − 1.
2.2 Syndrome
Let the code polynomial c(x) = c0+ c1x+ · · ·+ cn−1xn−1
be transmitted through a noisy channel to obtain the
received polynomial of the form r(x) = c(x)+e(x), where
e(x) = e0 + e1x+ · · ·+ en−1xn−1 is an error polynomial.
The known syndromes are obtained by evaluating r(x) at
the roots of g(x), i.e.,
Si = r(βi) = c(βi) + e(βi) = e(βi), i ∈ Q. (1)
If i /∈ Qn, then define Si = e0+e1(βi)+ · · ·+en−1(βi)n−1
and call it unknown syndrome. When v errors occur in
the received polynomial r(x), then the error polynomial
e(x) has v nonzero terms, namely, e(x) = xl1 + xi2 +
· · · + xlv , where 0 ≤ l1 < l2 < · · · < lv ≤ n− 1. For a
quadratic residue code with minimum distance d, an error
polynomial e(x) is said to be correctable if its weight is
less than or equal to the error-correcting capacity, t =
b(d− 1)/2c, where bxc denotes the greatest integer less
than or equal to x. By definition, the syndrome Si can
be written as Si = (βl1)i + (βl2)i + · · · + (βlv )i, where
βlj for 1 ≤ j ≤ v are called the error locators. For any
binary cyclic codes, there is an obvious relation among
syndromes, namely, S2i = S2i , with sub-indices modulo
n, if necessary.
2.3 Lagrange Interpolation Formula
The finite field version of Lagrange interpolation formula
can be found in [17] and is as follows: for q ≥ 0 let
a0, a1, . . . , aq be q + 1 distinct elements of E, and let
b0, b1, . . . , bq be q + 1 arbitrary elements of E. Then
there exists exactly one polynomial L(x) ∈ E[x] of degree
at most q such that L(ai) = bi for i = 0, 1, . . . , q. The
〈Z〉 = d799f67dbc6e88632b7f7a4e4f6a44e7ae270109765fbf2bf584c746397a9306e8aff52a2d8b2ae1ef234761f
3faa148b407b9db2536b781440497595fa0a548d0436be07f16b2a1158645a5b280e35f1894bbfd5ce8e920a5a
7d425c6b3994b64c3e6a046ee1bb10dece7d4855cec202d2cdf4e549af8a323c7525512b19f52e3d8695626a73
d6f67c59f9fbfcf4121648edd089ae6af4090488ff5f7099c393bef1cdf1339193814880e86e50ba2c2e2acf41
11092d9bf0e59490341f94ec45913caa0516479c2638e1ed1df281c7800de77e134c82fb8542b0851e00d8c78f
c790c1e92b5ebebe208f645e4ce8d0fc2de79357cb9566eff92da3754b66a504568272e705d6403fad2df8112b
6dbc0b1c2f8735d382a39121c5ac11252b591d3fc73dac2b8a8af50408e132cbdb3d28990d8eb1b9e9dd6d8ea1
cc11673c68b23b4c0dd03de1510e19de07e63def97e8f22a9006a5. (7)
〈U2〉 = dcf091273ab79b6239ca01c45df069cdbc753e5b913b9173987457e00358b09303d397eb3cf6f22bde0123a39
a1d90e2ff279f7f31934f6bc09fdeb12dc1dfe0aa3ee488e8635c18b034451af657e36218c2f297e98509fd402
6ceec706de389da3087cf5d8ddc1a0d87c34c1ae538ee93cad4e95bf3a205d2a60a5332f3171a462e3ee323b3f
e4f3062c4cf03b54d01108e76b46d769f0695c9773a57c84c883e33375a49fece37fe13ea9e24b50adf40bbd2d
dc6e55c3a4234cc1868e1056fe80fdf41abcbb48022e44c2daa27d56357c86379de24e6686a8974f6740a4577c
f0f02eea8a5ac0ce3e9d37b235105646da800b1d459abd284f14e091304bbc034b89e49dfaed9b0a91701ff23a
5cc032a5649dc311cbb779365ee118a5658875b1ad911a86125be3d0e04e0f0e03e1c71bb694e5e516c1d1adcf
0a7ae48b01a4385f33d345d430177b0cacc2314a89f28ef2a1e25 (8)
〈U3〉 = 19f3c4a38e8ff4fc59b105601241f538f9c26667dba60ccc8c964cef5257145ab6d22d9e46164775c18ecd332
73c7e69c9a230ef49d9077dd38c6cead11e97c261b9e61a5e2d5c9689ae23d13bcc640047ca9455cfa6d1853ea
9f2abae547242cc15e99fc3f6ee20b9d68fb86533a9858d82bde04912afcb6bb1c93321f2e614c9c484c89f863
09f3906453b80cb10bf3d384e331c7407b29ba005412c6c11a1f338f06d447cb99ff8036a621c6f67be8e93e55
a35ab7534b3b3d4e0e3cb5f31ccd32684235e5f42ceb343a996e562ff3aa512809794d5a713cc532fc1291873c
d5e0e32031ecc9f23d0ed175c6df6f9b95a2586846f6dcd7c8dc0e8aea44a4b47a09a98d8e6e6cb2292fbf8128
e98d06fe769c25ae5367b03d188cd6ad6fa42633e017e433e498ed23a47de0f8e7d4f16de119e9af0e1c7582d5
f1c0dff6f2d347a17504e7cbaf3731b73144fd1f391e1dac75f3e3 (9)
〈U4〉 = 41ab52f1cb58c4d9beb4976476d48ba1eb2aad52509c1ba301c624f75a6788527f2811dbafb0caf9bfec32c53
1a268179bde06884cd1d7d22cf83ed26aa476b32deb2bc23bc0834120ed39b32934432393598de3155c96cfe16
1caec77ee8f8d7784e019006a824def13f430a6f8f855eea06af355ff5eb54b6c5545e46b116aabb1e6eb33b2a
3d4b3954bf54a0d68a68e4ba4888c6ba229a4be2a8914d2ff102047ba811f065afa5ea74ddb1f3f6b473a3bf42
e1bd9104f46a4f3ca8547c2dcbb8b6539a46c5bed6bdc68b2863c5cfdb65a65849fd9ae2a15cd37721995126cf
deac741ba28bce7f047ac0c6a82a285e3ac1f255b81a2de80d5cdff5afd3d1be718376fe2225248e05b83fd342
e083996639fb17af0934ae78a9f0c2d249051cd23d4f4477f930f9385a6c77348b2217566ef2cdbe675736af16
2cd0e5fbd58c6193a37361498eb407ccf485eef0e41c4e1ba38552 (10)
[2] Augot, D., Bardet, M., Fauge`re, J.-C., “On the De-
coding of Binary Cyclic Codes With the Newton Iden-
tities,” Journal of Symbolic Computation, V44, N12,
PP. 1608-1625, 12/09
無衍生研發成果推廣資料
其他成果 
(無法以量化表達之成
果如辦理學術活動、獲
得獎項、重要國際合
作、研究成果國際影響
力及其他協助產業技
術發展之具體效益事
項等，請以文字敘述填
列。) 
無 
 成果項目 量化 名稱或內容性質簡述 
測驗工具(含質性與量性) 0  
課程/模組 0  
電腦及網路系統或工具 0  
教材 0  
舉辦之活動/競賽 0  
研討會/工作坊 0  
電子報、網站 0  
科 
教 
處 
計 
畫 
加 
填 
項 
目 計畫成果推廣之參與（閱聽）人數 0  
